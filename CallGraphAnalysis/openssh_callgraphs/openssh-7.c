/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

#line 214 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stddef.h"
typedef unsigned int size_t;
#line 183 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 195 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 36 "/usr/include/bits/socket.h"
typedef __socklen_t socklen_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 145 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 107 "/usr/include/openssl/ossl_typ.h"
struct bignum_st;
#line 107 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_st BIGNUM;
#line 108
struct bignum_ctx;
#line 108 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_ctx BN_CTX;
#line 109
struct bn_blinding_st;
#line 109 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_blinding_st BN_BLINDING;
#line 110
struct bn_mont_ctx_st;
#line 110 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_mont_ctx_st BN_MONT_CTX;
#line 112
struct bn_gencb_st;
#line 112 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_gencb_st BN_GENCB;
#line 128
struct rsa_st;
#line 128 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_st RSA;
#line 129
struct rsa_meth_st;
#line 129 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_meth_st RSA_METHOD;
#line 154
struct engine_st;
#line 154 "/usr/include/openssl/ossl_typ.h"
typedef struct engine_st ENGINE;
#line 165
struct crypto_ex_data_st;
#line 165 "/usr/include/openssl/ossl_typ.h"
typedef struct crypto_ex_data_st CRYPTO_EX_DATA;
#line 285 "/usr/include/openssl/bn.h"
struct bignum_st {
   unsigned long *d ;
   int top ;
   int dmax ;
   int neg ;
   int flags ;
};
#line 296 "/usr/include/openssl/bn.h"
struct bn_mont_ctx_st {
   int ri ;
   BIGNUM RR ;
   BIGNUM N ;
   BIGNUM Ni ;
   unsigned long n0 ;
   int flags ;
};
#line 320 "/usr/include/openssl/bn.h"
union __anonunion_cb_62 {
   void (*cb_1)(int  , int  , void * ) ;
   int (*cb_2)(int  , int  , BN_GENCB * ) ;
};
#line 320 "/usr/include/openssl/bn.h"
struct bn_gencb_st {
   unsigned int ver ;
   void *arg ;
   union __anonunion_cb_62 cb ;
};
#line 66 "/usr/include/openssl/stack.h"
struct stack_st {
   int num ;
   char **data ;
   int sorted ;
   int num_alloc ;
   int (*comp)(char const   * const  * , char const   * const  * ) ;
};
#line 66 "/usr/include/openssl/stack.h"
typedef struct stack_st STACK;
#line 283 "/usr/include/openssl/crypto.h"
struct crypto_ex_data_st {
   STACK *sk ;
   int dummy ;
};
#line 85 "/usr/include/openssl/rsa.h"
struct rsa_meth_st {
   char const   *name ;
   int (*rsa_pub_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_pub_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_priv_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_priv_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_mod_exp)(BIGNUM *r0 , BIGNUM const   *I , RSA *rsa , BN_CTX *ctx ) ;
   int (*bn_mod_exp)(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(RSA *rsa ) ;
   int (*finish)(RSA *rsa ) ;
   int flags ;
   char *app_data ;
   int (*rsa_sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
                   unsigned int *siglen , RSA const   *rsa ) ;
   int (*rsa_verify)(int dtype , unsigned char const   *m , unsigned int m_length ,
                     unsigned char *sigbuf , unsigned int siglen , RSA const   *rsa ) ;
   int (*rsa_keygen)(RSA *rsa , int bits , BIGNUM *e , BN_GENCB *cb ) ;
};
#line 128 "/usr/include/openssl/rsa.h"
struct rsa_st {
   int pad ;
   long version ;
   RSA_METHOD const   *meth ;
   ENGINE *engine ;
   BIGNUM *n ;
   BIGNUM *e ;
   BIGNUM *d ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *dmp1 ;
   BIGNUM *dmq1 ;
   BIGNUM *iqmp ;
   CRYPTO_EX_DATA ex_data ;
   int references ;
   int flags ;
   BN_MONT_CTX *_method_mod_n ;
   BN_MONT_CTX *_method_mod_p ;
   BN_MONT_CTX *_method_mod_q ;
   char *bignum_data ;
   BN_BLINDING *blinding ;
   BN_BLINDING *mt_blinding ;
};
#line 21 "buffer.h"
struct __anonstruct_Buffer_74 {
   char *buf ;
   unsigned int alloc ;
   unsigned int offset ;
   unsigned int end ;
};
#line 21 "buffer.h"
typedef struct __anonstruct_Buffer_74 Buffer;
#line 34 "authfd.h"
struct __anonstruct_AuthenticationConnection_75 {
   int fd ;
   Buffer packet ;
   Buffer identities ;
   int howmany ;
};
#line 34 "authfd.h"
typedef struct __anonstruct_AuthenticationConnection_75 AuthenticationConnection;
#line 59 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 60 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 137 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 143 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 144 "/usr/include/bits/types.h"
typedef long __off_t;
#line 145 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 152 "/usr/include/bits/types.h"
typedef long __time_t;
#line 167 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 172 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 88 "/usr/include/sys/types.h"
typedef __off_t off_t;
#line 203 "/usr/include/sys/types.h"
typedef unsigned int u_int32_t;
#line 121 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 177 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 183 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 268 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/openssl/ossl_typ.h"
struct asn1_string_st;
#line 79 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_INTEGER;
#line 80 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_ENUMERATED;
#line 81 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_BIT_STRING;
#line 82 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_OCTET_STRING;
#line 83 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_PRINTABLESTRING;
#line 84 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_T61STRING;
#line 85 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_IA5STRING;
#line 86 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_GENERALSTRING;
#line 87 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UNIVERSALSTRING;
#line 88 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_BMPSTRING;
#line 89 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UTCTIME;
#line 91 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_GENERALIZEDTIME;
#line 92 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_VISIBLESTRING;
#line 93 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UTF8STRING;
#line 94 "/usr/include/openssl/ossl_typ.h"
typedef int ASN1_BOOLEAN;
#line 116
struct evp_cipher_st;
#line 116 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_cipher_st EVP_CIPHER;
#line 117
struct evp_cipher_ctx_st;
#line 117 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_cipher_ctx_st EVP_CIPHER_CTX;
#line 125
struct dsa_st;
#line 125 "/usr/include/openssl/ossl_typ.h"
typedef struct dsa_st DSA;
#line 126
struct dsa_method;
#line 126 "/usr/include/openssl/ossl_typ.h"
typedef struct dsa_method DSA_METHOD;
#line 281 "/usr/include/openssl/crypto.h"
struct bio_st;
#line 256 "/usr/include/openssl/bio.h"
typedef struct bio_st BIO;
#line 258 "/usr/include/openssl/bio.h"
typedef void bio_info_cb(struct bio_st * , int  , char const   * , int  , long  ,
                         long  );
#line 261 "/usr/include/openssl/bio.h"
struct bio_method_st {
   int type ;
   char const   *name ;
   int (*bwrite)(BIO * , char const   * , int  ) ;
   int (*bread)(BIO * , char * , int  ) ;
   int (*bputs)(BIO * , char const   * ) ;
   int (*bgets)(BIO * , char * , int  ) ;
   long (*ctrl)(BIO * , int  , long  , void * ) ;
   int (*create)(BIO * ) ;
   int (*destroy)(BIO * ) ;
   long (*callback_ctrl)(BIO * , int  , bio_info_cb * ) ;
};
#line 261 "/usr/include/openssl/bio.h"
typedef struct bio_method_st BIO_METHOD;
#line 290 "/usr/include/openssl/bio.h"
struct bio_st {
   BIO_METHOD *method ;
   long (*callback)(struct bio_st * , int  , char const   * , int  , long  , long  ) ;
   char *cb_arg ;
   int init ;
   int shutdown ;
   int flags ;
   int retry_reason ;
   int num ;
   void *ptr ;
   struct bio_st *next_bio ;
   struct bio_st *prev_bio ;
   int references ;
   unsigned long num_read ;
   unsigned long num_write ;
   CRYPTO_EX_DATA ex_data ;
};
#line 106 "/usr/include/openssl/dsa.h"
struct DSA_SIG_st {
   BIGNUM *r ;
   BIGNUM *s ;
};
#line 106 "/usr/include/openssl/dsa.h"
typedef struct DSA_SIG_st DSA_SIG;
#line 112 "/usr/include/openssl/dsa.h"
struct dsa_method {
   char const   *name ;
   DSA_SIG *(*dsa_do_sign)(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
   int (*dsa_sign_setup)(DSA *dsa , BN_CTX *ctx_in , BIGNUM **kinvp , BIGNUM **rp ) ;
   int (*dsa_do_verify)(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                        DSA *dsa ) ;
   int (*dsa_mod_exp)(DSA *dsa , BIGNUM *rr , BIGNUM *a1 , BIGNUM *p1 , BIGNUM *a2 ,
                      BIGNUM *p2 , BIGNUM *m , BN_CTX *ctx , BN_MONT_CTX *in_mont ) ;
   int (*bn_mod_exp)(DSA *dsa , BIGNUM *r , BIGNUM *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DSA *dsa ) ;
   int (*finish)(DSA *dsa ) ;
   int flags ;
   char *app_data ;
   int (*dsa_paramgen)(DSA *dsa , int bits , unsigned char *seed , int seed_len ,
                       int *counter_ret , unsigned long *h_ret , BN_GENCB *cb ) ;
   int (*dsa_keygen)(DSA *dsa ) ;
};
#line 139 "/usr/include/openssl/dsa.h"
struct dsa_st {
   int pad ;
   long version ;
   int write_params ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *g ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   BIGNUM *kinv ;
   BIGNUM *r ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DSA_METHOD const   *meth ;
   ENGINE *engine ;
};
#line 206 "/usr/include/openssl/asn1.h"
struct asn1_object_st {
   char const   *sn ;
   char const   *ln ;
   int nid ;
   int length ;
   unsigned char *data ;
   int flags ;
};
#line 206 "/usr/include/openssl/asn1.h"
typedef struct asn1_object_st ASN1_OBJECT;
#line 222 "/usr/include/openssl/asn1.h"
struct asn1_string_st {
   int length ;
   int type ;
   unsigned char *data ;
   long flags ;
};
#line 222 "/usr/include/openssl/asn1.h"
typedef struct asn1_string_st ASN1_STRING;
#line 488 "/usr/include/openssl/asn1.h"
union __anonunion_value_64 {
   char *ptr ;
   ASN1_BOOLEAN boolean ;
   ASN1_STRING *asn1_string ;
   ASN1_OBJECT *object ;
   ASN1_INTEGER *integer ;
   ASN1_ENUMERATED *enumerated ;
   ASN1_BIT_STRING *bit_string ;
   ASN1_OCTET_STRING *octet_string ;
   ASN1_PRINTABLESTRING *printablestring ;
   ASN1_T61STRING *t61string ;
   ASN1_IA5STRING *ia5string ;
   ASN1_GENERALSTRING *generalstring ;
   ASN1_BMPSTRING *bmpstring ;
   ASN1_UNIVERSALSTRING *universalstring ;
   ASN1_UTCTIME *utctime ;
   ASN1_GENERALIZEDTIME *generalizedtime ;
   ASN1_VISIBLESTRING *visiblestring ;
   ASN1_UTF8STRING *utf8string ;
   ASN1_STRING *set ;
   ASN1_STRING *sequence ;
};
#line 488 "/usr/include/openssl/asn1.h"
struct asn1_type_st {
   int type ;
   union __anonunion_value_64 value ;
};
#line 488 "/usr/include/openssl/asn1.h"
typedef struct asn1_type_st ASN1_TYPE;
#line 297 "/usr/include/openssl/evp.h"
struct evp_cipher_st {
   int nid ;
   int block_size ;
   int key_len ;
   int iv_len ;
   unsigned long flags ;
   int (*init)(EVP_CIPHER_CTX *ctx , unsigned char const   *key , unsigned char const   *iv ,
               int enc ) ;
   int (*do_cipher)(EVP_CIPHER_CTX *ctx , unsigned char *out , unsigned char const   *in ,
                    unsigned int inl ) ;
   int (*cleanup)(EVP_CIPHER_CTX * ) ;
   int ctx_size ;
   int (*set_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*get_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*ctrl)(EVP_CIPHER_CTX * , int type , int arg , void *ptr ) ;
   void *app_data ;
};
#line 357 "/usr/include/openssl/evp.h"
struct evp_cipher_ctx_st {
   EVP_CIPHER const   *cipher ;
   ENGINE *engine ;
   int encrypt ;
   int buf_len ;
   unsigned char oiv[16] ;
   unsigned char iv[16] ;
   unsigned char buf[32] ;
   int num ;
   void *app_data ;
   int key_len ;
   unsigned long flags ;
   void *cipher_data ;
   int final_used ;
   int block_mask ;
   unsigned char final[32] ;
};
#line 529 "/usr/include/openssl/pem.h"
typedef int pem_password_cb(char *buf , int size , int rwflag , void *userdata );
#line 78 "/usr/include/openssl/des.h"
typedef unsigned char DES_cblock[8];
#line 83 "/usr/include/openssl/des.h"
union __anonunion_ks_73 {
   DES_cblock cblock ;
   unsigned long deslong[2] ;
};
#line 83 "/usr/include/openssl/des.h"
struct DES_ks {
   union __anonunion_ks_73 ks[16] ;
};
#line 83 "/usr/include/openssl/des.h"
typedef struct DES_ks DES_key_schedule;
#line 101 "/usr/include/openssl/blowfish.h"
struct bf_key_st {
   unsigned int P[18] ;
   unsigned int S[1024] ;
};
#line 71 "/usr/include/openssl/rc4.h"
struct rc4_key_st {
   unsigned int x ;
   unsigned int y ;
   unsigned int data[256] ;
};
#line 71 "/usr/include/openssl/rc4.h"
typedef struct rc4_key_st RC4_KEY;
#line 80 "/usr/include/openssl/cast.h"
struct cast_key_st {
   unsigned long data[32] ;
   int short_key ;
};
#line 80 "/usr/include/openssl/cast.h"
typedef struct cast_key_st CAST_KEY;
#line 43 "cipher.h"
struct __anonstruct_des3_77 {
   DES_key_schedule key1 ;
   DES_key_schedule key2 ;
   DES_cblock iv2 ;
   DES_key_schedule key3 ;
   DES_cblock iv3 ;
};
#line 43 "cipher.h"
struct __anonstruct_bf_78 {
   struct bf_key_st key ;
   unsigned char iv[8] ;
};
#line 43 "cipher.h"
struct __anonstruct_cast_79 {
   CAST_KEY key ;
   unsigned char iv[8] ;
};
#line 43 "cipher.h"
union __anonunion_u_76 {
   struct __anonstruct_des3_77 des3 ;
   struct __anonstruct_bf_78 bf ;
   struct __anonstruct_cast_79 cast ;
   RC4_KEY rc4 ;
};
#line 43 "cipher.h"
struct __anonstruct_CipherContext_75 {
   unsigned int type ;
   union __anonunion_u_76 u ;
};
#line 43 "cipher.h"
typedef struct __anonstruct_CipherContext_75 CipherContext;
#line 4 "key.h"
struct Key;
#line 4 "key.h"
typedef struct Key Key;
#line 10 "key.h"
struct Key {
   int type ;
   RSA *rsa ;
   DSA *dsa ;
};
#line 44 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 45 "/usr/include/bits/types.h"
typedef unsigned int __uint32_t;
#line 202 "/usr/include/sys/types.h"
typedef unsigned short u_int16_t;
#line 162 "/usr/include/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   __uint32_t __ss_align ;
   char __ss_padding[128U - 2U * sizeof(__uint32_t )] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 92 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 136 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 137 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 193 "/usr/include/netinet/in.h"
union __anonunion_in6_u_21 {
   uint8_t u6_addr8[16] ;
   uint16_t u6_addr16[8] ;
   uint32_t u6_addr32[4] ;
};
#line 193 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion_in6_u_21 in6_u ;
};
#line 219 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 233 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 321 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 538 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 35 "/usr/include/bits/types.h"
typedef unsigned short __u_short;
#line 146 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 36 "/usr/include/sys/types.h"
typedef __u_short u_short;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024U / (8U * sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 314 "/usr/include/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 24 "channels.h"
typedef void channel_callback_fn(int id , void *arg );
#line 26 "channels.h"
struct Channel {
   int type ;
   int self ;
   int remote_id ;
   int istate ;
   int ostate ;
   int flags ;
   int rfd ;
   int wfd ;
   int efd ;
   int sock ;
   Buffer input ;
   Buffer output ;
   Buffer extended ;
   char path[200] ;
   int listening_port ;
   int host_port ;
   char *remote_name ;
   int remote_window ;
   int remote_maxpacket ;
   int local_window ;
   int local_window_max ;
   int local_consumed ;
   int local_maxpacket ;
   int extended_usage ;
   char *ctype ;
   channel_callback_fn *cb_fn ;
   void *cb_arg ;
   int cb_event ;
   channel_callback_fn *dettach_user ;
};
#line 26 "channels.h"
typedef struct Channel Channel;
#line 80 "nchan.h"
typedef void chan_event_fn(Channel *c );
#line 92 "channels.c"
struct __anonstruct_ForwardPermission_79 {
   char *host_to_connect ;
   u_short port_to_connect ;
   u_short listen_port ;
};
#line 92 "channels.c"
typedef struct __anonstruct_ForwardPermission_79 ForwardPermission;
#line 311 "channels.c"
typedef void chan_fn(Channel *c , fd_set *readset , fd_set *writeset );
#line 79 "/usr/include/openssl/des.h"
typedef unsigned char const_DES_cblock[8];
#line 101 "/usr/include/openssl/blowfish.h"
typedef struct bf_key_st BF_KEY;
#line 99 "/usr/include/openssl/md5.h"
struct MD5state_st {
   unsigned int A ;
   unsigned int B ;
   unsigned int C ;
   unsigned int D ;
   unsigned int Nl ;
   unsigned int Nh ;
   unsigned int data[16] ;
   unsigned int num ;
};
#line 99 "/usr/include/openssl/md5.h"
typedef struct MD5state_st MD5_CTX;
#line 89 "cipher.c"
union __anonunion_t_74 {
   u_int32_t i ;
   char c[4] ;
};
#line 60 "compat.c"
struct __anonstruct_check_74 {
   char *version ;
   int bugs ;
};
#line 261 "/usr/include/zconf.h"
typedef unsigned char Byte;
#line 263 "/usr/include/zconf.h"
typedef unsigned int uInt;
#line 264 "/usr/include/zconf.h"
typedef unsigned long uLong;
#line 270 "/usr/include/zconf.h"
typedef Byte Bytef;
#line 279 "/usr/include/zconf.h"
typedef void *voidpf;
#line 80 "/usr/include/zlib.h"
struct internal_state;
#line 82 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 82 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 103 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 1346 "/usr/include/zlib.h"
struct internal_state {
   int dummy ;
};
#line 6 "dispatch.h"
typedef void dispatch_fn(int type , int plen );
#line 118 "/usr/include/openssl/ossl_typ.h"
struct env_md_st;
#line 118 "/usr/include/openssl/ossl_typ.h"
typedef struct env_md_st EVP_MD;
#line 119
struct env_md_ctx_st;
#line 119 "/usr/include/openssl/ossl_typ.h"
typedef struct env_md_ctx_st EVP_MD_CTX;
#line 220 "/usr/include/openssl/evp.h"
struct env_md_st {
   int type ;
   int pkey_type ;
   int md_size ;
   unsigned long flags ;
   int (*init)(EVP_MD_CTX *ctx ) ;
   int (*update)(EVP_MD_CTX *ctx , void const   *data , size_t count ) ;
   int (*final)(EVP_MD_CTX *ctx , unsigned char *md ) ;
   int (*copy)(EVP_MD_CTX *to , EVP_MD_CTX const   *from ) ;
   int (*cleanup)(EVP_MD_CTX *ctx ) ;
   int (*sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
               unsigned int *siglen , void *key ) ;
   int (*verify)(int type , unsigned char const   *m , unsigned int m_length , unsigned char const   *sigbuf ,
                 unsigned int siglen , void *key ) ;
   int required_pkey_type[5] ;
   int block_size ;
   int ctx_size ;
};
#line 280 "/usr/include/openssl/evp.h"
struct env_md_ctx_st {
   EVP_MD const   *digest ;
   ENGINE *engine ;
   unsigned long flags ;
   void *md_data ;
};
#line 75 "/usr/include/openssl/hmac.h"
struct hmac_ctx_st {
   EVP_MD const   *md ;
   EVP_MD_CTX md_ctx ;
   EVP_MD_CTX i_ctx ;
   EVP_MD_CTX o_ctx ;
   unsigned int key_length ;
   unsigned char key[128] ;
};
#line 75 "/usr/include/openssl/hmac.h"
typedef struct hmac_ctx_st HMAC_CTX;
#line 10 "hostfile.h"
enum __anonenum_HostStatus_74 {
    HOST_OK = 0,
    HOST_NEW = 1,
    HOST_CHANGED = 2
} ;
#line 10 "hostfile.h"
typedef enum __anonenum_HostStatus_74 HostStatus;
#line 122 "/usr/include/openssl/ossl_typ.h"
struct dh_st;
#line 122 "/usr/include/openssl/ossl_typ.h"
typedef struct dh_st DH;
#line 123
struct dh_method;
#line 123 "/usr/include/openssl/ossl_typ.h"
typedef struct dh_method DH_METHOD;
#line 95 "/usr/include/openssl/dh.h"
struct dh_method {
   char const   *name ;
   int (*generate_key)(DH *dh ) ;
   int (*compute_key)(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
   int (*bn_mod_exp)(DH const   *dh , BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p ,
                     BIGNUM const   *m , BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DH *dh ) ;
   int (*finish)(DH *dh ) ;
   int flags ;
   char *app_data ;
   int (*generate_params)(DH *dh , int prime_len , int generator , BN_GENCB *cb ) ;
};
#line 113 "/usr/include/openssl/dh.h"
struct dh_st {
   int pad ;
   int version ;
   BIGNUM *p ;
   BIGNUM *g ;
   long length ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   BIGNUM *q ;
   BIGNUM *j ;
   unsigned char *seed ;
   int seedlen ;
   BIGNUM *counter ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DH_METHOD const   *meth ;
   ENGINE *engine ;
};
#line 55 "kex.h"
struct Kex;
#line 55 "kex.h"
typedef struct Kex Kex;
#line 56
struct Mac;
#line 56 "kex.h"
typedef struct Mac Mac;
#line 57
struct Comp;
#line 57 "kex.h"
typedef struct Comp Comp;
#line 58
struct Enc;
#line 58 "kex.h"
typedef struct Enc Enc;
#line 60 "kex.h"
struct Enc {
   int type ;
   int enabled ;
   int block_size ;
   unsigned char *key ;
   unsigned char *iv ;
   int key_len ;
   int iv_len ;
   char *name ;
};
#line 70 "kex.h"
struct Mac {
   EVP_MD *md ;
   int enabled ;
   int mac_len ;
   unsigned char *key ;
   int key_len ;
   char *name ;
};
#line 78 "kex.h"
struct Comp {
   int type ;
   int enabled ;
   char *name ;
};
#line 83 "kex.h"
struct Kex {
   Enc enc[2] ;
   Mac mac[2] ;
   Comp comp[2] ;
   int we_need ;
   int server ;
   char *name ;
   char *hostkeyalg ;
};
#line 43 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 105 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 429 "ssh.h"
enum __anonenum_SyslogFacility_72 {
    SYSLOG_FACILITY_DAEMON = 0,
    SYSLOG_FACILITY_USER = 1,
    SYSLOG_FACILITY_AUTH = 2,
    SYSLOG_FACILITY_LOCAL0 = 3,
    SYSLOG_FACILITY_LOCAL1 = 4,
    SYSLOG_FACILITY_LOCAL2 = 5,
    SYSLOG_FACILITY_LOCAL3 = 6,
    SYSLOG_FACILITY_LOCAL4 = 7,
    SYSLOG_FACILITY_LOCAL5 = 8,
    SYSLOG_FACILITY_LOCAL6 = 9,
    SYSLOG_FACILITY_LOCAL7 = 10
} ;
#line 429 "ssh.h"
typedef enum __anonenum_SyslogFacility_72 SyslogFacility;
#line 443
enum __anonenum_LogLevel_73 {
    SYSLOG_LEVEL_QUIET = 0,
    SYSLOG_LEVEL_FATAL = 1,
    SYSLOG_LEVEL_ERROR = 2,
    SYSLOG_LEVEL_INFO = 3,
    SYSLOG_LEVEL_VERBOSE = 4,
    SYSLOG_LEVEL_DEBUG = 5
} ;
#line 443 "ssh.h"
typedef enum __anonenum_LogLevel_73 LogLevel;
#line 69 "log.c"
struct fatal_cleanup {
   struct fatal_cleanup *next ;
   void (*proc)(void * ) ;
   void *context ;
};
#line 132 "log.c"
struct __anonstruct_log_facilities_74 {
   char const   *name ;
   SyslogFacility val ;
};
#line 150 "log.c"
struct __anonstruct_log_levels_75 {
   char const   *name ;
   LogLevel val ;
};
#line 154 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 148 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 28 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024U / (8U * sizeof(unsigned long ))] ;
};
#line 28 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 33 "/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__kill_23 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__timer_24 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__rt_25 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_26 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_27 {
   void *si_addr ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_28 {
   long si_band ;
   int si_fd ;
};
#line 51 "/usr/include/bits/siginfo.h"
union __anonunion__sifields_22 {
   int _pad[128U / sizeof(int ) - 3U] ;
   struct __anonstruct__kill_23 _kill ;
   struct __anonstruct__timer_24 _timer ;
   struct __anonstruct__rt_25 _rt ;
   struct __anonstruct__sigchld_26 _sigchld ;
   struct __anonstruct__sigfault_27 _sigfault ;
   struct __anonstruct__sigpoll_28 _sigpoll ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_22 _sifields ;
};
#line 51 "/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 25 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_40 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_40 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 25 "/usr/include/bits/termios.h"
typedef unsigned char cc_t;
#line 26 "/usr/include/bits/termios.h"
typedef unsigned int speed_t;
#line 27 "/usr/include/bits/termios.h"
typedef unsigned int tcflag_t;
#line 30 "/usr/include/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 338 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 34 "/usr/include/bits/types.h"
typedef unsigned char __u_char;
#line 35 "/usr/include/sys/types.h"
typedef __u_char u_char;
#line 54 "bsd-misc.c"
struct __anonstruct_rc4_t_74 {
   unsigned int s[256] ;
   int i ;
   int j ;
};
#line 54 "bsd-misc.c"
typedef struct __anonstruct_rc4_t_74 rc4_t;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 85 "/usr/include/sys/select.h"
typedef __fd_mask fd_mask;
#line 75 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 28 "servconf.h"
struct __anonstruct_ServerOptions_74 {
   unsigned int num_ports ;
   unsigned int ports_from_cmdline ;
   u_short ports[256] ;
   char *listen_addr ;
   struct addrinfo *listen_addrs ;
   char *host_key_file ;
   char *host_dsa_key_file ;
   char *pid_file ;
   int server_key_bits ;
   int login_grace_time ;
   int key_regeneration_time ;
   int permit_root_login ;
   int ignore_rhosts ;
   int ignore_user_known_hosts ;
   int print_motd ;
   int check_mail ;
   int x11_forwarding ;
   int x11_display_offset ;
   int strict_modes ;
   int keepalives ;
   char *ciphers ;
   int protocol ;
   int gateway_ports ;
   SyslogFacility log_facility ;
   LogLevel log_level ;
   int rhosts_authentication ;
   int rhosts_rsa_authentication ;
   int rsa_authentication ;
   int dsa_authentication ;
   int password_authentication ;
   int permit_empty_passwd ;
   int use_login ;
   unsigned int num_allow_users ;
   char *allow_users[256] ;
   unsigned int num_deny_users ;
   char *deny_users[256] ;
   unsigned int num_allow_groups ;
   char *allow_groups[256] ;
   unsigned int num_deny_groups ;
   char *deny_groups[256] ;
};
#line 28 "servconf.h"
typedef struct __anonstruct_ServerOptions_74 ServerOptions;
#line 115 "sshd.c"
struct __anonstruct_sensitive_data_76 {
   RSA *private_key ;
   RSA *host_key ;
   Key *dsa_host_key ;
};
#line 43 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 78 "auth2.c"
struct Authctxt;
#line 78 "auth2.c"
typedef struct Authctxt Authctxt;
#line 79 "auth2.c"
struct Authctxt {
   char *user ;
   char *service ;
   struct passwd pw ;
   int valid ;
};
#line 18 "/usr/include/security/_pam_types.h"
struct pam_handle;
#line 18 "/usr/include/security/_pam_types.h"
typedef struct pam_handle pam_handle_t;
#line 244 "/usr/include/security/_pam_types.h"
struct pam_message {
   int msg_style ;
   char const   *msg ;
};
#line 269 "/usr/include/security/_pam_types.h"
struct pam_response {
   char *resp ;
   int resp_retcode ;
};
#line 276 "/usr/include/security/_pam_types.h"
struct pam_conv {
   int (*conv)(int num_msg , struct pam_message  const  **msg , struct pam_response **resp ,
               void *appdata_ptr ) ;
   void *appdata_ptr ;
};
#line 28 "auth-pam.c"
struct pam_handle_t;
#line 509 "ssh.h"
struct envstring {
   struct envstring *next ;
   char *s ;
};
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 28 "/usr/include/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 77 "/usr/include/time.h"
typedef __time_t time_t;
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 38 "/usr/include/bits/utmp.h"
struct lastlog {
   __time_t ll_time ;
   char ll_line[32] ;
   char ll_host[256] ;
};
#line 52 "/usr/include/bits/utmp.h"
struct exit_status {
   short e_termination ;
   short e_exit ;
};
#line 60 "/usr/include/bits/utmp.h"
struct utmp {
   short ut_type ;
   pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct exit_status ut_exit ;
   long ut_session ;
   struct timeval ut_tv ;
   int32_t ut_addr_v6[4] ;
   char __unused[20] ;
};
#line 161 "servconf.c"
enum __anonenum_ServerOpCodes_75 {
    sBadOption = 0,
    sPort = 1,
    sHostKeyFile = 2,
    sServerKeyBits = 3,
    sLoginGraceTime = 4,
    sKeyRegenerationTime = 5,
    sPermitRootLogin = 6,
    sLogFacility = 7,
    sLogLevel = 8,
    sRhostsAuthentication = 9,
    sRhostsRSAAuthentication = 10,
    sRSAAuthentication = 11,
    sPasswordAuthentication = 12,
    sListenAddress = 13,
    sPrintMotd = 14,
    sIgnoreRhosts = 15,
    sX11Forwarding = 16,
    sX11DisplayOffset = 17,
    sStrictModes = 18,
    sEmptyPasswd = 19,
    sRandomSeedFile = 20,
    sKeepAlives = 21,
    sCheckMail = 22,
    sUseLogin = 23,
    sAllowUsers = 24,
    sDenyUsers = 25,
    sAllowGroups = 26,
    sDenyGroups = 27,
    sIgnoreUserKnownHosts = 28,
    sHostDSAKeyFile = 29,
    sCiphers = 30,
    sProtocol = 31,
    sPidFile = 32,
    sGatewayPorts = 33,
    sDSAAuthentication = 34
} ;
#line 161 "servconf.c"
typedef enum __anonenum_ServerOpCodes_75 ServerOpCodes;
#line 184 "servconf.c"
struct __anonstruct_keywords_76 {
   char const   *name ;
   ServerOpCodes opcode ;
};
#line 63 "/usr/include/sys/wait.h"
union wait;
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_terminated_43 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_stopped_44 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_43 __wait_terminated ;
   struct __anonstruct___wait_stopped_44 __wait_stopped ;
};
#line 74 "serverloop.c"
union __anonunion_77 {
   int volatile   __in ;
   int __i ;
};
#line 74 "serverloop.c"
union __anonunion_78 {
   int volatile   __in ;
   int __i ;
};
#line 585 "serverloop.c"
union __anonunion_79 {
   int __in ;
   int __i ;
};
#line 587 "serverloop.c"
union __anonunion_80 {
   int __in ;
   int __i ;
};
#line 583 "serverloop.c"
union __anonunion_81 {
   int __in ;
   int __i ;
};
#line 609 "serverloop.c"
union __anonunion_82 {
   int __in ;
   int __i ;
};
#line 608 "serverloop.c"
union __anonunion_83 {
   int __in ;
   int __i ;
};
#line 33 "session.c"
struct Session;
#line 33 "session.c"
typedef struct Session Session;
#line 34 "session.c"
struct Session {
   int used ;
   int self ;
   int extended ;
   struct passwd *pw ;
   pid_t pid ;
   char *term ;
   int ptyfd ;
   int ttyfd ;
   int ptymaster ;
   int row ;
   int col ;
   int xpixel ;
   int ypixel ;
   char tty[64] ;
   char *display ;
   int screen ;
   char *auth_proto ;
   char *auth_data ;
   int single_connection ;
   int chanid ;
};
#line 1489 "session.c"
union __anonunion_76 {
   int __in ;
   int __i ;
};
#line 1494 "session.c"
union __anonunion_77___0 {
   int __in ;
   int __i ;
};
#line 1496 "session.c"
union __anonunion_78___0 {
   int __in ;
   int __i ;
};
#line 1491 "session.c"
union __anonunion_79___0 {
   int __in ;
   int __i ;
};
#line 1486 "session.c"
union __anonunion_80___0 {
   int __in ;
   int __i ;
};
#line 1 "atomicio.o"
#pragma merger(0,"./atomicio.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 517 "ssh.h"
ssize_t atomicio(ssize_t (*f)() , int fd , void *_s , size_t n___0 ) ;
#line 35 "atomicio.c"
ssize_t atomicio(ssize_t (*f)() , int fd , void *_s , size_t n___0 ) 
{ char *s ;
  ssize_t res ;
  ssize_t pos ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 42
  s = (char *)_s;
#line 43
  pos = 0;
#line 45
  while (n___0 > (size_t )pos) {
#line 46
    res = (*f)(fd, s + pos, n___0 - (size_t )pos);
#line 47
    switch (res) {
    case -1: 
#line 49
    tmp = __errno_location();
#line 49
    if (*tmp == 4) {
#line 50
      continue;
    } else {
#line 49
      tmp___0 = __errno_location();
#line 49
      if (*tmp___0 == 11) {
#line 50
        continue;
      }
    }
    case 0: 
#line 52
    return (res);
    default: 
#line 54
    pos += res;
    }
  }
#line 57
  return (pos);
}
}
#line 1 "authfd.o"
#pragma merger(0,"./authfd.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 100 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 124
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 242 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 256
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 76 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 660 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 320 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 327
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 333
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 7 "bsd-strlcpy.h"
size_t strlcpy(char *dst , char const   *src , size_t siz ) ;
#line 405 "/usr/include/openssl/bn.h"
extern int BN_num_bits(BIGNUM const   *a ) ;
#line 462 "ssh.h"
void ( /* format attribute */  fatal)(char const   *fmt  , ...) ;
#line 463
void ( /* format attribute */  error)(char const   *fmt  , ...) ;
#line 464
void ( /* format attribute */  log)(char const   *fmt  , ...) ;
#line 28 "buffer.h"
void buffer_init(Buffer *buffer ) ;
#line 31
void buffer_free(Buffer *buffer ) ;
#line 35
void buffer_clear(Buffer *buffer ) ;
#line 38
void buffer_append(Buffer *buffer , char const   *data , unsigned int len ) ;
#line 48
unsigned int buffer_len(Buffer *buffer ) ;
#line 51
void buffer_get(Buffer *buffer , char *buf___1 , unsigned int len ) ;
#line 60
char *buffer_ptr(Buffer *buffer ) ;
#line 41 "authfd.h"
int ssh_get_authentication_socket(void) ;
#line 48
void ssh_close_authentication_socket(int sock ) ;
#line 56
AuthenticationConnection *ssh_get_authentication_connection(void) ;
#line 62
void ssh_close_authentication_connection(AuthenticationConnection *ac ) ;
#line 70
int ssh_get_first_identity(AuthenticationConnection *auth , BIGNUM *e , BIGNUM *n___0 ,
                           char **comment ) ;
#line 80
int ssh_get_next_identity(AuthenticationConnection *auth , BIGNUM *e , BIGNUM *n___0 ,
                          char **comment ) ;
#line 86
int ssh_decrypt_challenge(AuthenticationConnection *auth , BIGNUM *e , BIGNUM *n___0 ,
                          BIGNUM *challenge , unsigned char *session_id___0 , unsigned int response_type ,
                          unsigned char *response ) ;
#line 98
int ssh_add_identity(AuthenticationConnection *auth , RSA *key , char const   *comment ) ;
#line 107
int ssh_remove_identity(AuthenticationConnection *auth , RSA *key ) ;
#line 114
int ssh_remove_all_identities(AuthenticationConnection *auth ) ;
#line 25 "bufaux.h"
void buffer_put_bignum(Buffer *buffer , BIGNUM *value ) ;
#line 29
int buffer_get_bignum(Buffer *buffer , BIGNUM *value ) ;
#line 33
unsigned int buffer_get_int(Buffer *buffer ) ;
#line 36
void buffer_put_int(Buffer *buffer , unsigned int value ) ;
#line 39
int buffer_get_char(Buffer *buffer ) ;
#line 42
void buffer_put_char(Buffer *buffer , int value ) ;
#line 52
char *buffer_get_string(Buffer *buffer , unsigned int *length_ptr ) ;
#line 55
void buffer_put_string(Buffer *buffer , void const   *buf___1 , unsigned int len ) ;
#line 23 "xmalloc.h"
void *xmalloc(size_t size ) ;
#line 29
void xfree(void *ptr ) ;
#line 31 "authfd.c"
int ssh_get_authentication_socket(void) 
{ char const   *authsocket ;
  int sock ;
  struct sockaddr_un sunaddr ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 38
  tmp = getenv("SSH_AUTH_SOCK");
#line 38
  authsocket = (char const   *)tmp;
#line 39
  if (! authsocket) {
#line 40
    return (-1);
  }
#line 42
  sunaddr.sun_family = (unsigned short)1;
#line 43
  strlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));
#line 45
  sock = socket(1, 1, 0);
#line 46
  if (sock < 0) {
#line 47
    return (-1);
  }
#line 50
  tmp___0 = fcntl(sock, 2, 1);
#line 50
  if (tmp___0 == -1) {
#line 51
    close(sock);
#line 52
    return (-1);
  }
#line 54
  tmp___1 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sunaddr)),
                    sizeof(sunaddr));
#line 54
  if (tmp___1 < 0) {
#line 55
    close(sock);
#line 56
    return (-1);
  }
#line 58
  return (sock);
}
}
#line 67 "authfd.c"
void ssh_close_authentication_socket(int sock ) 
{ char *tmp ;

  {
#line 70
  tmp = getenv("SSH_AUTH_SOCK");
#line 70
  if (tmp) {
#line 71
    close(sock);
  }
#line 72
  return;
}
}
#line 82 "authfd.c"
AuthenticationConnection *ssh_get_authentication_connection(void) 
{ AuthenticationConnection *auth ;
  int sock ;
  void *tmp ;

  {
#line 88
  sock = ssh_get_authentication_socket();
#line 94
  if (sock < 0) {
#line 95
    return ((AuthenticationConnection *)((void *)0));
  }
#line 97
  tmp = xmalloc(sizeof(*auth));
#line 97
  auth = (AuthenticationConnection *)tmp;
#line 98
  auth->fd = sock;
#line 99
  buffer_init(& auth->packet);
#line 100
  buffer_init(& auth->identities);
#line 101
  auth->howmany = 0;
#line 103
  return (auth);
}
}
#line 111 "authfd.c"
void ssh_close_authentication_connection(AuthenticationConnection *ac ) 
{ 

  {
#line 114
  buffer_free(& ac->packet);
#line 115
  buffer_free(& ac->identities);
#line 116
  close(ac->fd);
#line 117
  xfree((void *)ac);
#line 118
  return;
}
}
#line 127 "authfd.c"
int ssh_get_first_identity(AuthenticationConnection *auth , BIGNUM *e , BIGNUM *n___0 ,
                           char **comment ) 
{ unsigned char msg[8192] ;
  int len ;
  int l ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;

  {
#line 138
  msg[0] = (unsigned char)0;
#line 139
  msg[1] = (unsigned char)0;
#line 140
  msg[2] = (unsigned char)0;
#line 141
  msg[3] = (unsigned char)1;
#line 142
  msg[4] = (unsigned char)1;
#line 143
  tmp___1 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)(msg), 5U);
#line 143
  if (tmp___1 != 5) {
#line 144
    tmp = __errno_location();
#line 144
    tmp___0 = strerror(*tmp);
#line 144
    error("write auth->fd: %.100s", tmp___0);
#line 145
    return (0);
  }
#line 148
  len = 4;
#line 149
  while (len > 0) {
#line 150
    l = read(auth->fd, (void *)((msg + 4) - len), (unsigned int )len);
#line 151
    if (l <= 0) {
#line 152
      tmp___2 = __errno_location();
#line 152
      tmp___3 = strerror(*tmp___2);
#line 152
      error("read auth->fd: %.100s", tmp___3);
#line 153
      return (0);
    }
#line 155
    len -= l;
  }
#line 162
  len = (int )(((((unsigned long )msg[0] << 24) | ((unsigned long )msg[1] << 16)) | ((unsigned long )msg[2] << 8)) | (unsigned long )msg[3]);
#line 163
  if (len < 1) {
#line 164
    fatal("Authentication reply message too long: %d\n", len);
  } else {
#line 163
    if (len > 262144) {
#line 164
      fatal("Authentication reply message too long: %d\n", len);
    }
  }
#line 167
  buffer_clear(& auth->identities);
#line 168
  while (len > 0) {
#line 169
    l = len;
#line 170
    if ((unsigned int )l > sizeof(msg)) {
#line 171
      l = (int )sizeof(msg);
    }
#line 172
    l = read(auth->fd, (void *)(msg), (unsigned int )l);
#line 173
    if (l <= 0) {
#line 174
      fatal("Incomplete authentication reply.");
    }
#line 175
    buffer_append(& auth->identities, (char const   *)((char *)(msg)), (unsigned int )l);
#line 176
    len -= l;
  }
#line 180
  buffer_get(& auth->identities, (char *)(msg), 1U);
#line 181
  if ((int )msg[0] != 2) {
#line 182
    fatal("Bad authentication reply message type: %d", msg[0]);
  }
#line 185
  tmp___4 = buffer_get_int(& auth->identities);
#line 185
  auth->howmany = (int )tmp___4;
#line 186
  if (auth->howmany > 1024) {
#line 187
    fatal("Too many identities in authentication reply: %d\n", auth->howmany);
  }
#line 190
  tmp___5 = ssh_get_next_identity(auth, e, n___0, comment);
#line 190
  return (tmp___5);
}
}
#line 200 "authfd.c"
int ssh_get_next_identity(AuthenticationConnection *auth , BIGNUM *e , BIGNUM *n___0 ,
                          char **comment ) 
{ unsigned int bits ;
  int tmp ;
  int tmp___0 ;

  {
#line 207
  if (auth->howmany <= 0) {
#line 208
    return (0);
  }
#line 214
  bits = buffer_get_int(& auth->identities);
#line 215
  buffer_get_bignum(& auth->identities, e);
#line 216
  buffer_get_bignum(& auth->identities, n___0);
#line 217
  *comment = buffer_get_string(& auth->identities, (unsigned int *)((void *)0));
#line 219
  tmp___0 = BN_num_bits((BIGNUM const   *)n___0);
#line 219
  if (bits != (unsigned int )tmp___0) {
#line 220
    tmp = BN_num_bits((BIGNUM const   *)n___0);
#line 220
    log("Warning: identity keysize mismatch: actual %d, announced %u", tmp, bits);
  }
#line 224
  (auth->howmany) --;
#line 226
  return (1);
}
}
#line 237 "authfd.c"
int ssh_decrypt_challenge(AuthenticationConnection *auth , BIGNUM *e , BIGNUM *n___0 ,
                          BIGNUM *challenge , unsigned char *session_id___0 , unsigned int response_type ,
                          unsigned char *response ) 
{ Buffer buffer ;
  unsigned char buf___1[8192] ;
  int len ;
  int l ;
  int i ;
  int tmp ;
  unsigned int tmp___0 ;
  ssize_t tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  ssize_t tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;

  {
#line 249
  if (response_type == 0U) {
#line 250
    fatal("Compatibility with ssh protocol version 1.0 no longer supported.");
  }
#line 253
  buf___1[0] = (unsigned char)3;
#line 254
  buffer_init(& buffer);
#line 255
  buffer_append(& buffer, (char const   *)((char *)(buf___1)), 1U);
#line 256
  tmp = BN_num_bits((BIGNUM const   *)n___0);
#line 256
  buffer_put_int(& buffer, (unsigned int )tmp);
#line 257
  buffer_put_bignum(& buffer, e);
#line 258
  buffer_put_bignum(& buffer, n___0);
#line 259
  buffer_put_bignum(& buffer, challenge);
#line 260
  buffer_append(& buffer, (char const   *)((char *)session_id___0), 16U);
#line 261
  buffer_put_int(& buffer, response_type);
#line 264
  tmp___0 = buffer_len(& buffer);
#line 264
  len = (int )tmp___0;
#line 265
  while (1) {
#line 265
    buf___1[0] = (unsigned char )(len >> 24);
#line 265
    buf___1[1] = (unsigned char )(len >> 16);
#line 265
    buf___1[2] = (unsigned char )(len >> 8);
#line 265
    buf___1[3] = (unsigned char )len;
#line 265
    break;
  }
#line 268
  tmp___1 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)(buf___1), 4U);
#line 268
  if (tmp___1 != 4) {
    goto _L;
  } else {
#line 268
    tmp___2 = buffer_len(& buffer);
#line 268
    tmp___3 = buffer_ptr(& buffer);
#line 268
    tmp___4 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)tmp___3, tmp___2);
#line 268
    tmp___5 = buffer_len(& buffer);
#line 268
    if ((unsigned int )tmp___4 != tmp___5) {
      _L: /* CIL Label */ 
#line 271
      error("Error writing to authentication socket.");
      error_cleanup: 
#line 273
      buffer_free(& buffer);
#line 274
      return (0);
    }
  }
#line 280
  len = 4;
#line 281
  while (len > 0) {
#line 282
    l = read(auth->fd, (void *)((buf___1 + 4) - len), (unsigned int )len);
#line 283
    if (l <= 0) {
#line 284
      error("Error reading response length from authentication socket.");
      goto error_cleanup;
    }
#line 287
    len -= l;
  }
#line 291
  len = (int )(((((unsigned long )buf___1[0] << 24) | ((unsigned long )buf___1[1] << 16)) | ((unsigned long )buf___1[2] << 8)) | (unsigned long )buf___1[3]);
#line 292
  if (len > 262144) {
#line 293
    fatal("Authentication response too long: %d", len);
  }
#line 296
  buffer_clear(& buffer);
#line 297
  while (len > 0) {
#line 298
    l = len;
#line 299
    if ((unsigned int )l > sizeof(buf___1)) {
#line 300
      l = (int )sizeof(buf___1);
    }
#line 301
    l = read(auth->fd, (void *)(buf___1), (unsigned int )l);
#line 302
    if (l <= 0) {
#line 303
      error("Error reading response from authentication socket.");
      goto error_cleanup;
    }
#line 306
    buffer_append(& buffer, (char const   *)((char *)(buf___1)), (unsigned int )l);
#line 307
    len -= l;
  }
#line 311
  buffer_get(& buffer, (char *)(buf___1), 1U);
#line 314
  if ((int )buf___1[0] == 5) {
#line 315
    log("Agent admitted failure to authenticate using the key.");
    goto error_cleanup;
  }
#line 319
  if ((int )buf___1[0] != 4) {
#line 320
    fatal("Bad authentication response: %d", buf___1[0]);
  }
#line 326
  i = 0;
#line 326
  while (i < 16) {
#line 327
    tmp___6 = buffer_get_char(& buffer);
#line 327
    *(response + i) = (unsigned char )tmp___6;
#line 326
    i ++;
  }
#line 330
  buffer_free(& buffer);
#line 333
  return (1);
}
}
#line 341 "authfd.c"
int ssh_add_identity(AuthenticationConnection *auth , RSA *key , char const   *comment ) 
{ Buffer buffer ;
  unsigned char buf___1[8192] ;
  int len ;
  int l ;
  int type ;
  int tmp ;
  size_t tmp___0 ;
  unsigned int tmp___1 ;
  ssize_t tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  ssize_t tmp___5 ;
  unsigned int tmp___6 ;

  {
#line 350
  buffer_init(& buffer);
#line 351
  buffer_put_char(& buffer, 7);
#line 352
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 352
  buffer_put_int(& buffer, (unsigned int )tmp);
#line 353
  buffer_put_bignum(& buffer, key->n);
#line 354
  buffer_put_bignum(& buffer, key->e);
#line 355
  buffer_put_bignum(& buffer, key->d);
#line 357
  buffer_put_bignum(& buffer, key->iqmp);
#line 358
  buffer_put_bignum(& buffer, key->q);
#line 359
  buffer_put_bignum(& buffer, key->p);
#line 360
  tmp___0 = strlen(comment);
#line 360
  buffer_put_string(& buffer, (void const   *)comment, tmp___0);
#line 363
  tmp___1 = buffer_len(& buffer);
#line 363
  len = (int )tmp___1;
#line 364
  while (1) {
#line 364
    buf___1[0] = (unsigned char )(len >> 24);
#line 364
    buf___1[1] = (unsigned char )(len >> 16);
#line 364
    buf___1[2] = (unsigned char )(len >> 8);
#line 364
    buf___1[3] = (unsigned char )len;
#line 364
    break;
  }
#line 367
  tmp___2 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)(buf___1), 4U);
#line 367
  if (tmp___2 != 4) {
    goto _L;
  } else {
#line 367
    tmp___3 = buffer_len(& buffer);
#line 367
    tmp___4 = buffer_ptr(& buffer);
#line 367
    tmp___5 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)tmp___4, tmp___3);
#line 367
    tmp___6 = buffer_len(& buffer);
#line 367
    if ((unsigned int )tmp___5 != tmp___6) {
      _L: /* CIL Label */ 
#line 370
      error("Error writing to authentication socket.");
      error_cleanup: 
#line 372
      buffer_free(& buffer);
#line 373
      return (0);
    }
  }
#line 377
  len = 4;
#line 378
  while (len > 0) {
#line 379
    l = read(auth->fd, (void *)((buf___1 + 4) - len), (unsigned int )len);
#line 380
    if (l <= 0) {
#line 381
      error("Error reading response length from authentication socket.");
      goto error_cleanup;
    }
#line 384
    len -= l;
  }
#line 388
  len = (int )(((((unsigned long )buf___1[0] << 24) | ((unsigned long )buf___1[1] << 16)) | ((unsigned long )buf___1[2] << 8)) | (unsigned long )buf___1[3]);
#line 389
  if (len > 262144) {
#line 390
    fatal("Add identity response too long: %d", len);
  }
#line 393
  buffer_clear(& buffer);
#line 394
  while (len > 0) {
#line 395
    l = len;
#line 396
    if ((unsigned int )l > sizeof(buf___1)) {
#line 397
      l = (int )sizeof(buf___1);
    }
#line 398
    l = read(auth->fd, (void *)(buf___1), (unsigned int )l);
#line 399
    if (l <= 0) {
#line 400
      error("Error reading response from authentication socket.");
      goto error_cleanup;
    }
#line 403
    buffer_append(& buffer, (char const   *)((char *)(buf___1)), (unsigned int )l);
#line 404
    len -= l;
  }
#line 408
  type = buffer_get_char(& buffer);
#line 409
  switch (type) {
  case 5: 
#line 411
  buffer_free(& buffer);
#line 412
  return (0);
  case 6: 
#line 414
  buffer_free(& buffer);
#line 415
  return (1);
  default: 
#line 417
  fatal("Bad response to add identity from authentication agent: %d", type);
  }
#line 421
  return (0);
}
}
#line 429 "authfd.c"
int ssh_remove_identity(AuthenticationConnection *auth , RSA *key ) 
{ Buffer buffer ;
  unsigned char buf___1[8192] ;
  int len ;
  int l ;
  int type ;
  int tmp ;
  unsigned int tmp___0 ;
  ssize_t tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  ssize_t tmp___4 ;
  unsigned int tmp___5 ;

  {
#line 437
  buffer_init(& buffer);
#line 438
  buffer_put_char(& buffer, 8);
#line 439
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 439
  buffer_put_int(& buffer, (unsigned int )tmp);
#line 440
  buffer_put_bignum(& buffer, key->e);
#line 441
  buffer_put_bignum(& buffer, key->n);
#line 444
  tmp___0 = buffer_len(& buffer);
#line 444
  len = (int )tmp___0;
#line 445
  while (1) {
#line 445
    buf___1[0] = (unsigned char )(len >> 24);
#line 445
    buf___1[1] = (unsigned char )(len >> 16);
#line 445
    buf___1[2] = (unsigned char )(len >> 8);
#line 445
    buf___1[3] = (unsigned char )len;
#line 445
    break;
  }
#line 448
  tmp___1 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)(buf___1), 4U);
#line 448
  if (tmp___1 != 4) {
    goto _L;
  } else {
#line 448
    tmp___2 = buffer_len(& buffer);
#line 448
    tmp___3 = buffer_ptr(& buffer);
#line 448
    tmp___4 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)tmp___3, tmp___2);
#line 448
    tmp___5 = buffer_len(& buffer);
#line 448
    if ((unsigned int )tmp___4 != tmp___5) {
      _L: /* CIL Label */ 
#line 451
      error("Error writing to authentication socket.");
      error_cleanup: 
#line 453
      buffer_free(& buffer);
#line 454
      return (0);
    }
  }
#line 460
  len = 4;
#line 461
  while (len > 0) {
#line 462
    l = read(auth->fd, (void *)((buf___1 + 4) - len), (unsigned int )len);
#line 463
    if (l <= 0) {
#line 464
      error("Error reading response length from authentication socket.");
      goto error_cleanup;
    }
#line 467
    len -= l;
  }
#line 471
  len = (int )(((((unsigned long )buf___1[0] << 24) | ((unsigned long )buf___1[1] << 16)) | ((unsigned long )buf___1[2] << 8)) | (unsigned long )buf___1[3]);
#line 472
  if (len > 262144) {
#line 473
    fatal("Remove identity response too long: %d", len);
  }
#line 476
  buffer_clear(& buffer);
#line 477
  while (len > 0) {
#line 478
    l = len;
#line 479
    if ((unsigned int )l > sizeof(buf___1)) {
#line 480
      l = (int )sizeof(buf___1);
    }
#line 481
    l = read(auth->fd, (void *)(buf___1), (unsigned int )l);
#line 482
    if (l <= 0) {
#line 483
      error("Error reading response from authentication socket.");
      goto error_cleanup;
    }
#line 486
    buffer_append(& buffer, (char const   *)((char *)(buf___1)), (unsigned int )l);
#line 487
    len -= l;
  }
#line 491
  type = buffer_get_char(& buffer);
#line 492
  switch (type) {
  case 5: 
#line 494
  buffer_free(& buffer);
#line 495
  return (0);
  case 6: 
#line 497
  buffer_free(& buffer);
#line 498
  return (1);
  default: 
#line 500
  fatal("Bad response to remove identity from authentication agent: %d", type);
  }
#line 504
  return (0);
}
}
#line 512 "authfd.c"
int ssh_remove_all_identities(AuthenticationConnection *auth ) 
{ Buffer buffer ;
  unsigned char buf___1[8192] ;
  int len ;
  int l ;
  int type ;
  ssize_t tmp ;

  {
#line 520
  while (1) {
#line 520
    buf___1[0] = (unsigned char )(1 >> 24);
#line 520
    buf___1[1] = (unsigned char )(1 >> 16);
#line 520
    buf___1[2] = (unsigned char )(1 >> 8);
#line 520
    buf___1[3] = (unsigned char)1;
#line 520
    break;
  }
#line 521
  buf___1[4] = (unsigned char)9;
#line 524
  tmp = atomicio((ssize_t (*)())(& write), auth->fd, (void *)(buf___1), 5U);
#line 524
  if (tmp != 5) {
#line 525
    error("Error writing to authentication socket.");
#line 526
    return (0);
  }
#line 532
  len = 4;
#line 533
  while (len > 0) {
#line 534
    l = read(auth->fd, (void *)((buf___1 + 4) - len), (unsigned int )len);
#line 535
    if (l <= 0) {
#line 536
      error("Error reading response length from authentication socket.");
#line 537
      return (0);
    }
#line 539
    len -= l;
  }
#line 543
  len = (int )(((((unsigned long )buf___1[0] << 24) | ((unsigned long )buf___1[1] << 16)) | ((unsigned long )buf___1[2] << 8)) | (unsigned long )buf___1[3]);
#line 544
  if (len > 262144) {
#line 545
    fatal("Remove identity response too long: %d", len);
  }
#line 548
  buffer_init(& buffer);
#line 549
  while (len > 0) {
#line 550
    l = len;
#line 551
    if ((unsigned int )l > sizeof(buf___1)) {
#line 552
      l = (int )sizeof(buf___1);
    }
#line 553
    l = read(auth->fd, (void *)(buf___1), (unsigned int )l);
#line 554
    if (l <= 0) {
#line 555
      error("Error reading response from authentication socket.");
#line 556
      buffer_free(& buffer);
#line 557
      return (0);
    }
#line 559
    buffer_append(& buffer, (char const   *)((char *)(buf___1)), (unsigned int )l);
#line 560
    len -= l;
  }
#line 564
  type = buffer_get_char(& buffer);
#line 565
  switch (type) {
  case 5: 
#line 567
  buffer_free(& buffer);
#line 568
  return (0);
  case 6: 
#line 570
  buffer_free(& buffer);
#line 571
  return (1);
  default: 
#line 573
  fatal("Bad response to remove identity from authentication agent: %d", type);
  }
#line 577
  return (0);
}
}
#line 1 "aux.o"
#pragma merger(0,"./aux.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 466 "ssh.h"
void ( /* format attribute */  debug)(char const   *fmt  , ...) ;
#line 490
char *chop(char *s ) ;
#line 493
void set_nonblock(int fd ) ;
#line 6 "aux.c"
char *chop(char *s ) 
{ char *t ;

  {
#line 9
  t = s;
#line 10
  while (*t) {
#line 11
    if ((int )*t == 10) {
#line 12
      *t = (char )'\000';
#line 13
      return (s);
    } else {
#line 11
      if ((int )*t == 13) {
#line 12
        *t = (char )'\000';
#line 13
        return (s);
      }
    }
#line 15
    t ++;
  }
#line 17
  return (s);
}
}
#line 21 "aux.c"
void set_nonblock(int fd ) 
{ int val ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 25
  val = fcntl(fd, 3, 0);
#line 26
  if (val < 0) {
#line 27
    tmp = __errno_location();
#line 27
    tmp___0 = strerror(*tmp);
#line 27
    error("fcntl(%d, F_GETFL, 0): %s", fd, tmp___0);
#line 28
    return;
  }
#line 30
  if (val & 2048) {
#line 31
    return;
  }
#line 32
  debug("fd %d setting O_NONBLOCK", fd);
#line 33
  val |= 2048;
#line 34
  tmp___3 = fcntl(fd, 4, val);
#line 34
  if (tmp___3 == -1) {
#line 35
    tmp___1 = __errno_location();
#line 35
    tmp___2 = strerror(*tmp___1);
#line 35
    error("fcntl(%d, F_SETFL, O_NONBLOCK): %s", fd, tmp___2);
  }
#line 36
  return;
}
}
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
#line 1 "authfile.o"
#pragma merger(0,"./authfile.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 212 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 380
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __attribute__((__nonnull__(3))) ;
#line 447
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 447 "/usr/include/sys/stat.h"
__inline static int fstat(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
#line 450
  tmp = __fxstat(3, __fd, __statbuf);
#line 450
  return (tmp);
}
}
#line 59 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 154 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 213
extern int fclose(FILE *__stream ) ;
#line 280
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 85 "/usr/include/fcntl.h"
extern int open(char const   *__file , int __oflag  , ...)  __attribute__((__nonnull__(1))) ;
#line 301 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 642
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 36 "bsd-misc.h"
unsigned int arc4random(void) ;
#line 391 "/usr/include/openssl/bn.h"
extern BIGNUM const   *BN_value_one(void) ;
#line 393
extern BN_CTX *BN_CTX_new(void) ;
#line 397
extern void BN_CTX_free(BN_CTX *c ) ;
#line 407
extern BIGNUM *BN_new(void) ;
#line 409
extern void BN_clear_free(BIGNUM *a ) ;
#line 416
extern int BN_sub(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *b ) ;
#line 433
extern int BN_div(BIGNUM *dv , BIGNUM *rem , BIGNUM const   *m , BIGNUM const   *d ,
                  BN_CTX *ctx ) ;
#line 560 "/usr/include/openssl/bio.h"
extern BIO_METHOD *BIO_s_file(void) ;
#line 568
extern BIO *BIO_new(BIO_METHOD *type ) ;
#line 570
extern int BIO_free(BIO *a ) ;
#line 577
extern long BIO_ctrl(BIO *bp , int cmd , long larg , void *parg ) ;
#line 192 "/usr/include/openssl/dsa.h"
extern void DSA_free(DSA *r ) ;
#line 639 "/usr/include/openssl/evp.h"
extern EVP_CIPHER const   *EVP_des_ede3_cbc(void) ;
#line 625 "/usr/include/openssl/pem.h"
extern DSA *PEM_read_bio_DSAPrivateKey(BIO *bp , DSA **x , pem_password_cb *cb , void *u ) ;
#line 625
extern int PEM_write_DSAPrivateKey(FILE *fp , DSA *x , EVP_CIPHER const   *enc , unsigned char *kstr ,
                                   int klen , pem_password_cb *cb , void *u ) ;
#line 32 "xmalloc.h"
char *xstrdup(char const   *str ) ;
#line 45 "buffer.h"
void buffer_append_space(Buffer *buffer , char **datap , unsigned int len ) ;
#line 70 "cipher.h"
unsigned int cipher_mask1(void) ;
#line 74
char const   *cipher_name(int cipher ) ;
#line 101
void cipher_set_key_string(CipherContext *context , int cipher , char const   *passphrase ) ;
#line 106
void cipher_encrypt(CipherContext *context , unsigned char *dest , unsigned char const   *src ,
                    unsigned int len ) ;
#line 111
void cipher_decrypt(CipherContext *context , unsigned char *dest , unsigned char const   *src ,
                    unsigned int len ) ;
#line 43 "authfile.c"
int save_private_key_rsa(char const   *filename , char const   *passphrase , RSA *key ,
                         char const   *comment ) 
{ Buffer buffer ;
  Buffer encrypted ;
  char buf___1[100] ;
  char *cp ;
  int fd ;
  int i ;
  CipherContext cipher ;
  int cipher_type___0 ;
  u_int32_t rand___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  unsigned int tmp___17 ;
  char *tmp___18 ;
  ssize_t tmp___19 ;
  unsigned int tmp___20 ;

  {
#line 58
  if (0) {
#line 58
    __s1_len = strlen(passphrase);
#line 58
    __s2_len = strlen("");
#line 58
    if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
      goto _L___0;
    } else {
#line 58
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 58
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 58
          tmp___8 = 1;
        } else {
#line 58
          if (__s2_len >= 4U) {
#line 58
            tmp___8 = 1;
          } else {
#line 58
            tmp___8 = 0;
          }
        }
      } else {
#line 58
        tmp___8 = 0;
      }
    }
#line 58
    if (tmp___8) {
#line 58
      tmp___4 = __builtin_strcmp(passphrase, "");
    } else {
#line 58
      tmp___7 = __builtin_strcmp(passphrase, "");
#line 58
      tmp___4 = tmp___7;
    }
  } else {
#line 58
    tmp___7 = __builtin_strcmp(passphrase, "");
#line 58
    tmp___4 = tmp___7;
  }
#line 58
  if (tmp___4 == 0) {
#line 59
    cipher_type___0 = 0;
  } else {
#line 61
    cipher_type___0 = 3;
  }
#line 64
  buffer_init(& buffer);
#line 67
  rand___0 = arc4random();
#line 68
  buf___1[0] = (char )(rand___0 & 255U);
#line 69
  buf___1[1] = (char )((rand___0 >> 8) & 255U);
#line 70
  buf___1[2] = buf___1[0];
#line 71
  buf___1[3] = buf___1[1];
#line 72
  buffer_append(& buffer, (char const   *)(buf___1), 4U);
#line 79
  buffer_put_bignum(& buffer, key->d);
#line 80
  buffer_put_bignum(& buffer, key->iqmp);
#line 81
  buffer_put_bignum(& buffer, key->q);
#line 82
  buffer_put_bignum(& buffer, key->p);
#line 85
  while (1) {
#line 85
    tmp___9 = buffer_len(& buffer);
#line 85
    if (! (tmp___9 % 8U != 0U)) {
#line 85
      break;
    }
#line 86
    buffer_put_char(& buffer, 0);
  }
#line 89
  buffer_init(& encrypted);
#line 92
  cp = (char *)"SSH PRIVATE KEY FILE FORMAT 1.1\n";
#line 93
  i = 0;
#line 93
  while (*(cp + i)) {
#line 94
    buffer_put_char(& encrypted, (int )*(cp + i));
#line 93
    i ++;
  }
#line 95
  buffer_put_char(& encrypted, 0);
#line 98
  buffer_put_char(& encrypted, cipher_type___0);
#line 99
  buffer_put_int(& encrypted, 0U);
#line 102
  tmp___10 = BN_num_bits((BIGNUM const   *)key->n);
#line 102
  buffer_put_int(& encrypted, (unsigned int )tmp___10);
#line 103
  buffer_put_bignum(& encrypted, key->n);
#line 104
  buffer_put_bignum(& encrypted, key->e);
#line 105
  tmp___11 = strlen(comment);
#line 105
  buffer_put_string(& encrypted, (void const   *)comment, tmp___11);
#line 108
  tmp___12 = buffer_len(& buffer);
#line 108
  buffer_append_space(& encrypted, & cp, tmp___12);
#line 110
  cipher_set_key_string(& cipher, cipher_type___0, passphrase);
#line 111
  tmp___13 = buffer_len(& buffer);
#line 111
  tmp___14 = buffer_ptr(& buffer);
#line 111
  cipher_encrypt(& cipher, (unsigned char *)cp, (unsigned char const   *)((unsigned char *)tmp___14),
                 tmp___13);
#line 114
  memset((void *)(& cipher), 0, sizeof(cipher));
#line 117
  memset((void *)(buf___1), 0, sizeof(buf___1));
#line 118
  buffer_free(& buffer);
#line 120
  fd = open(filename, 577, 384);
#line 121
  if (fd < 0) {
#line 122
    return (0);
  }
#line 123
  tmp___17 = buffer_len(& encrypted);
#line 123
  tmp___18 = buffer_ptr(& encrypted);
#line 123
  tmp___19 = write(fd, (void const   *)tmp___18, tmp___17);
#line 123
  tmp___20 = buffer_len(& encrypted);
#line 123
  if ((unsigned int )tmp___19 != tmp___20) {
#line 125
    tmp___15 = __errno_location();
#line 125
    tmp___16 = strerror(*tmp___15);
#line 125
    debug("Write to key file %.200s failed: %.100s", filename, tmp___16);
#line 127
    buffer_free(& encrypted);
#line 128
    close(fd);
#line 129
    remove(filename);
#line 130
    return (0);
  }
#line 132
  close(fd);
#line 133
  buffer_free(& encrypted);
#line 134
  return (1);
}
}
#line 139 "authfile.c"
int save_private_key_dsa(char const   *filename , char const   *passphrase , DSA *dsa ,
                         char const   *comment ) 
{ FILE *fp ;
  int fd ;
  int success ;
  int len ;
  size_t tmp ;
  int *tmp___0 ;
  size_t tmp___1 ;
  EVP_CIPHER const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 145
  success = 1;
#line 146
  tmp = strlen(passphrase);
#line 146
  len = (int )tmp;
#line 148
  if (len > 0) {
#line 148
    if (len <= 4) {
#line 149
      error("passphrase too short: %d bytes", len);
#line 150
      tmp___0 = __errno_location();
#line 150
      *tmp___0 = 0;
#line 151
      return (0);
    }
  }
#line 153
  fd = open(filename, 577, 384);
#line 154
  if (fd < 0) {
#line 155
    debug("open %s failed", filename);
#line 156
    return (0);
  }
#line 158
  fp = fdopen(fd, "w");
#line 159
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 160
    debug("fdopen %s failed", filename);
#line 161
    close(fd);
#line 162
    return (0);
  }
#line 164
  if (len > 0) {
#line 165
    tmp___1 = strlen(passphrase);
#line 165
    tmp___2 = EVP_des_ede3_cbc();
#line 165
    tmp___3 = PEM_write_DSAPrivateKey(fp, dsa, tmp___2, (unsigned char *)((char *)passphrase),
                                      (int )tmp___1, (pem_password_cb *)((void *)0),
                                      (void *)0);
#line 165
    if (! tmp___3) {
#line 167
      success = 0;
    }
  } else {
#line 169
    tmp___4 = PEM_write_DSAPrivateKey(fp, dsa, (EVP_CIPHER const   *)((void *)0),
                                      (unsigned char *)((void *)0), 0, (pem_password_cb *)((void *)0),
                                      (void *)0);
#line 169
    if (! tmp___4) {
#line 171
      success = 0;
    }
  }
#line 173
  fclose(fp);
#line 174
  return (success);
}
}
#line 177 "authfile.c"
int save_private_key(char const   *filename , char const   *passphrase , Key *key ,
                     char const   *comment ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 181
  switch (key->type) {
  case 0: 
#line 183
  tmp = save_private_key_rsa(filename, passphrase, key->rsa, comment);
#line 183
  return (tmp);
#line 184
  break;
  case 1: 
#line 186
  tmp___0 = save_private_key_dsa(filename, passphrase, key->dsa, comment);
#line 186
  return (tmp___0);
#line 187
  break;
  default: ;
#line 189
  break;
  }
#line 191
  return (0);
}
}
#line 200 "authfile.c"
int load_public_key_rsa(char const   *filename , RSA *pub , char **comment_return ) 
{ int fd ;
  int i ;
  off_t len ;
  Buffer buffer ;
  char *cp ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
#line 208
  fd = open(filename, 0);
#line 209
  if (fd < 0) {
#line 210
    return (0);
  }
#line 211
  len = lseek(fd, 0L, 2);
#line 212
  lseek(fd, 0L, 0);
#line 214
  buffer_init(& buffer);
#line 215
  buffer_append_space(& buffer, & cp, (unsigned int )len);
#line 217
  tmp___1 = read(fd, (void *)cp, (unsigned int )len);
#line 217
  if ((unsigned int )tmp___1 != (unsigned int )len) {
#line 218
    tmp = __errno_location();
#line 218
    tmp___0 = strerror(*tmp);
#line 218
    debug("Read from key file %.200s failed: %.100s", filename, tmp___0);
#line 220
    buffer_free(& buffer);
#line 221
    close(fd);
#line 222
    return (0);
  }
#line 224
  close(fd);
#line 227
  tmp___2 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 227
  if ((unsigned long )len < (unsigned long )(tmp___2 + 1U)) {
#line 228
    debug("Bad key file %.200s.", filename);
#line 229
    buffer_free(& buffer);
#line 230
    return (0);
  }
#line 236
  i = 0;
#line 236
  while (1) {
#line 236
    tmp___4 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 236
    if (! ((unsigned int )i < tmp___4 + 1U)) {
#line 236
      break;
    }
#line 237
    tmp___3 = buffer_get_char(& buffer);
#line 237
    if (tmp___3 != (int )((unsigned char )*("SSH PRIVATE KEY FILE FORMAT 1.1\n" + i))) {
#line 238
      debug("Bad key file %.200s.", filename);
#line 239
      buffer_free(& buffer);
#line 240
      return (0);
    }
#line 236
    i ++;
  }
#line 243
  buffer_get_char(& buffer);
#line 244
  buffer_get_int(& buffer);
#line 247
  buffer_get_int(& buffer);
#line 249
  if ((unsigned int )pub->n == (unsigned int )((void *)0)) {
#line 250
    pub->n = BN_new();
  }
#line 251
  buffer_get_bignum(& buffer, pub->n);
#line 253
  if ((unsigned int )pub->e == (unsigned int )((void *)0)) {
#line 254
    pub->e = BN_new();
  }
#line 255
  buffer_get_bignum(& buffer, pub->e);
#line 256
  if (comment_return) {
#line 257
    *comment_return = buffer_get_string(& buffer, (unsigned int *)((void *)0));
  }
#line 260
  buffer_free(& buffer);
#line 262
  return (1);
}
}
#line 265 "authfile.c"
int load_public_key(char const   *filename , Key *key , char **comment_return ) 
{ int tmp ;

  {
#line 268
  switch (key->type) {
  case 0: 
#line 270
  tmp = load_public_key_rsa(filename, key->rsa, comment_return);
#line 270
  return (tmp);
#line 271
  break;
  case 1: 
  default: ;
#line 274
  break;
  }
#line 276
  return (0);
}
}
#line 286 "authfile.c"
int load_private_key_rsa(int fd , char const   *filename , char const   *passphrase ,
                         RSA *prv , char **comment_return ) 
{ int i ;
  int check1 ;
  int check2 ;
  int cipher_type___0 ;
  off_t len ;
  Buffer buffer ;
  Buffer decrypted ;
  char *cp ;
  CipherContext cipher ;
  BN_CTX *ctx ;
  BIGNUM *aux ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  char *tmp___10 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___16 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  BIGNUM const   *tmp___23 ;
  BIGNUM const   *tmp___24 ;

  {
#line 298
  len = lseek(fd, 0L, 2);
#line 299
  lseek(fd, 0L, 0);
#line 301
  buffer_init(& buffer);
#line 302
  buffer_append_space(& buffer, & cp, (unsigned int )len);
#line 304
  tmp___1 = read(fd, (void *)cp, (unsigned int )len);
#line 304
  if ((unsigned int )tmp___1 != (unsigned int )len) {
#line 305
    tmp = __errno_location();
#line 305
    tmp___0 = strerror(*tmp);
#line 305
    debug("Read from key file %.200s failed: %.100s", filename, tmp___0);
#line 307
    buffer_free(& buffer);
#line 308
    close(fd);
#line 309
    return (0);
  }
#line 311
  close(fd);
#line 314
  tmp___2 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 314
  if ((unsigned long )len < (unsigned long )(tmp___2 + 1U)) {
#line 315
    debug("Bad key file %.200s.", filename);
#line 316
    buffer_free(& buffer);
#line 317
    return (0);
  }
#line 323
  i = 0;
#line 323
  while (1) {
#line 323
    tmp___4 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 323
    if (! ((unsigned int )i < tmp___4 + 1U)) {
#line 323
      break;
    }
#line 324
    tmp___3 = buffer_get_char(& buffer);
#line 324
    if (tmp___3 != (int )((unsigned char )*("SSH PRIVATE KEY FILE FORMAT 1.1\n" + i))) {
#line 325
      debug("Bad key file %.200s.", filename);
#line 326
      buffer_free(& buffer);
#line 327
      return (0);
    }
#line 323
    i ++;
  }
#line 330
  cipher_type___0 = buffer_get_char(& buffer);
#line 331
  buffer_get_int(& buffer);
#line 334
  buffer_get_int(& buffer);
#line 335
  prv->n = BN_new();
#line 336
  buffer_get_bignum(& buffer, prv->n);
#line 337
  prv->e = BN_new();
#line 338
  buffer_get_bignum(& buffer, prv->e);
#line 339
  if (comment_return) {
#line 340
    *comment_return = buffer_get_string(& buffer, (unsigned int *)((void *)0));
  } else {
#line 342
    tmp___5 = buffer_get_string(& buffer, (unsigned int *)((void *)0));
#line 342
    xfree((void *)tmp___5);
  }
#line 345
  tmp___7 = cipher_mask1();
#line 345
  if (((tmp___7 | 3U) & (unsigned int )(1 << cipher_type___0)) == 0U) {
#line 347
    tmp___6 = cipher_name(cipher_type___0);
#line 347
    debug("Unsupported cipher %.100s used in key file %.200s.", tmp___6, filename);
#line 349
    buffer_free(& buffer);
    goto fail;
  }
#line 353
  buffer_init(& decrypted);
#line 354
  tmp___8 = buffer_len(& buffer);
#line 354
  buffer_append_space(& decrypted, & cp, tmp___8);
#line 357
  cipher_set_key_string(& cipher, cipher_type___0, passphrase);
#line 358
  tmp___9 = buffer_len(& buffer);
#line 358
  tmp___10 = buffer_ptr(& buffer);
#line 358
  cipher_decrypt(& cipher, (unsigned char *)cp, (unsigned char const   *)((unsigned char *)tmp___10),
                 tmp___9);
#line 362
  buffer_free(& buffer);
#line 364
  check1 = buffer_get_char(& decrypted);
#line 365
  check2 = buffer_get_char(& decrypted);
#line 366
  tmp___21 = buffer_get_char(& decrypted);
#line 366
  if (check1 != tmp___21) {
    goto _L___1;
  } else {
#line 366
    tmp___22 = buffer_get_char(& decrypted);
#line 366
    if (check2 != tmp___22) {
      _L___1: /* CIL Label */ 
#line 368
      if (0) {
#line 368
        __s1_len = strlen(passphrase);
#line 368
        __s2_len = strlen("");
#line 368
        if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
          goto _L___0;
        } else {
#line 368
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 368
            if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 368
              tmp___20 = 1;
            } else {
#line 368
              if (__s2_len >= 4U) {
#line 368
                tmp___20 = 1;
              } else {
#line 368
                tmp___20 = 0;
              }
            }
          } else {
#line 368
            tmp___20 = 0;
          }
        }
#line 368
        if (tmp___20) {
#line 368
          tmp___16 = __builtin_strcmp(passphrase, "");
        } else {
#line 368
          tmp___19 = __builtin_strcmp(passphrase, "");
#line 368
          tmp___16 = tmp___19;
        }
      } else {
#line 368
        tmp___19 = __builtin_strcmp(passphrase, "");
#line 368
        tmp___16 = tmp___19;
      }
#line 368
      if (tmp___16 != 0) {
#line 369
        debug("Bad passphrase supplied for key file %.200s.", filename);
      }
#line 371
      buffer_free(& decrypted);
      fail: 
#line 373
      BN_clear_free(prv->n);
#line 374
      prv->n = (BIGNUM *)((void *)0);
#line 375
      BN_clear_free(prv->e);
#line 376
      prv->e = (BIGNUM *)((void *)0);
#line 377
      if (comment_return) {
#line 378
        xfree((void *)*comment_return);
      }
#line 379
      return (0);
    }
  }
#line 382
  prv->d = BN_new();
#line 383
  buffer_get_bignum(& decrypted, prv->d);
#line 384
  prv->iqmp = BN_new();
#line 385
  buffer_get_bignum(& decrypted, prv->iqmp);
#line 387
  prv->q = BN_new();
#line 388
  buffer_get_bignum(& decrypted, prv->q);
#line 389
  prv->p = BN_new();
#line 390
  buffer_get_bignum(& decrypted, prv->p);
#line 392
  ctx = BN_CTX_new();
#line 393
  aux = BN_new();
#line 395
  tmp___23 = BN_value_one();
#line 395
  BN_sub(aux, (BIGNUM const   *)prv->q, tmp___23);
#line 396
  prv->dmq1 = BN_new();
#line 397
  BN_div((BIGNUM *)((void *)0), prv->dmq1, (BIGNUM const   *)prv->d, (BIGNUM const   *)aux,
         ctx);
#line 399
  tmp___24 = BN_value_one();
#line 399
  BN_sub(aux, (BIGNUM const   *)prv->p, tmp___24);
#line 400
  prv->dmp1 = BN_new();
#line 401
  BN_div((BIGNUM *)((void *)0), prv->dmp1, (BIGNUM const   *)prv->d, (BIGNUM const   *)aux,
         ctx);
#line 403
  BN_clear_free(aux);
#line 404
  BN_CTX_free(ctx);
#line 406
  buffer_free(& decrypted);
#line 408
  return (1);
}
}
#line 411 "authfile.c"
int load_private_key_dsa(int fd , char const   *passphrase , Key *k , char **comment_return ) 
{ DSA *dsa ;
  BIO *in ;
  FILE *fp ;
  BIO_METHOD *tmp ;
  int tmp___0 ;

  {
#line 418
  tmp = BIO_s_file();
#line 418
  in = BIO_new(tmp);
#line 419
  if ((unsigned int )in == (unsigned int )((void *)0)) {
#line 420
    error("BIO_new failed");
#line 421
    return (0);
  }
#line 423
  fp = fdopen(fd, "r");
#line 424
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 425
    error("fdopen failed");
#line 426
    return (0);
  }
#line 428
  BIO_ctrl(in, 106, 0L, (void *)((char *)fp));
#line 429
  dsa = PEM_read_bio_DSAPrivateKey(in, (DSA **)((void *)0), (pem_password_cb *)((void *)0),
                                   (void *)((char *)passphrase));
#line 430
  if ((unsigned int )dsa == (unsigned int )((void *)0)) {
#line 431
    debug("PEM_read_bio_DSAPrivateKey failed");
  } else {
#line 434
    DSA_free(k->dsa);
#line 435
    k->dsa = dsa;
  }
#line 437
  BIO_free(in);
#line 438
  fclose(fp);
#line 439
  if (comment_return) {
#line 440
    *comment_return = xstrdup("dsa w/o comment");
  }
#line 441
  debug("read DSA private key done");
#line 445
  if ((unsigned int )dsa != (unsigned int )((void *)0)) {
#line 445
    tmp___0 = 1;
  } else {
#line 445
    tmp___0 = 0;
  }
#line 445
  return (tmp___0);
}
}
#line 448 "authfile.c"
int load_private_key(char const   *filename , char const   *passphrase , Key *key ,
                     char **comment_return ) 
{ int fd ;
  int ret ;
  struct stat st ;
  int tmp ;
  __uid_t tmp___0 ;

  {
#line 453
  ret = 0;
#line 456
  fd = open(filename, 0);
#line 457
  if (fd < 0) {
#line 458
    return (0);
  }
#line 461
  tmp = fstat(fd, & st);
#line 461
  if (tmp < 0) {
    goto _L;
  } else {
#line 461
    if (st.st_uid != 0U) {
#line 461
      tmp___0 = getuid();
#line 461
      if (st.st_uid != tmp___0) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 461
      if ((st.st_mode & 63U) != 0U) {
        _L: /* CIL Label */ 
#line 464
        close(fd);
#line 465
        error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 466
        error("@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @");
#line 467
        error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 468
        error("Bad ownership or mode(0%3.3o) for \'%s\'.", st.st_mode & 511U, filename);
#line 470
        error("It is recommended that your private key files are NOT accessible by others.");
#line 471
        return (0);
      }
    }
  }
#line 473
  switch (key->type) {
  case 0: 
#line 475
  if ((unsigned int )(key->rsa)->e != (unsigned int )((void *)0)) {
#line 476
    BN_clear_free((key->rsa)->e);
#line 477
    (key->rsa)->e = (BIGNUM *)((void *)0);
  }
#line 479
  if ((unsigned int )(key->rsa)->n != (unsigned int )((void *)0)) {
#line 480
    BN_clear_free((key->rsa)->n);
#line 481
    (key->rsa)->n = (BIGNUM *)((void *)0);
  }
#line 483
  ret = load_private_key_rsa(fd, filename, passphrase, key->rsa, comment_return);
#line 485
  break;
  case 1: 
#line 487
  ret = load_private_key_dsa(fd, passphrase, key, comment_return);
  default: ;
#line 489
  break;
  }
#line 491
  close(fd);
#line 492
  return (ret);
}
}
#line 1 "bufaux.o"
#pragma merger(0,"./bufaux.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 412 "/usr/include/openssl/bn.h"
extern BIGNUM *BN_bin2bn(unsigned char const   *s , int len , BIGNUM *ret ) ;
#line 413
extern int BN_bn2bin(BIGNUM const   *a , unsigned char *to ) ;
#line 54 "buffer.h"
void buffer_consume(Buffer *buffer , unsigned int bytes ) ;
#line 26 "bufaux.h"
void buffer_put_bignum2(Buffer *buffer , BIGNUM *value ) ;
#line 30
int buffer_get_bignum2(Buffer *buffer , BIGNUM *value ) ;
#line 56
void buffer_put_cstring(Buffer *buffer , char const   *s ) ;
#line 32 "bufaux.c"
void buffer_put_bignum(Buffer *buffer , BIGNUM *value ) 
{ int bits ;
  int tmp ;
  int bin_size ;
  unsigned char *buf___1 ;
  void *tmp___0 ;
  int oi ;
  char msg[2] ;

  {
#line 35
  tmp = BN_num_bits((BIGNUM const   *)value);
#line 35
  bits = tmp;
#line 36
  bin_size = (bits + 7) / 8;
#line 37
  tmp___0 = xmalloc((unsigned int )bin_size);
#line 37
  buf___1 = (unsigned char *)tmp___0;
#line 42
  oi = BN_bn2bin((BIGNUM const   *)value, buf___1);
#line 43
  if (oi != bin_size) {
#line 44
    fatal("buffer_put_bignum: BN_bn2bin() failed: oi %d != bin_size %d", oi, bin_size);
  }
#line 48
  while (1) {
#line 48
    msg[0] = (char )(bits >> 8);
#line 48
    msg[1] = (char )bits;
#line 48
    break;
  }
#line 49
  buffer_append(buffer, (char const   *)(msg), 2U);
#line 51
  buffer_append(buffer, (char const   *)((char *)buf___1), (unsigned int )oi);
#line 53
  memset((void *)buf___1, 0, (unsigned int )bin_size);
#line 54
  xfree((void *)buf___1);
#line 55
  return;
}
}
#line 60 "bufaux.c"
int buffer_get_bignum(Buffer *buffer , BIGNUM *value ) 
{ int bits ;
  int bytes ;
  unsigned char buf___1[2] ;
  unsigned char *bin ;
  unsigned int tmp ;
  char *tmp___0 ;

  {
#line 67
  buffer_get(buffer, (char *)(buf___1), 2U);
#line 68
  bits = (int )(((unsigned long )buf___1[0] << 8) | (unsigned long )buf___1[1]);
#line 70
  bytes = (bits + 7) / 8;
#line 71
  tmp = buffer_len(buffer);
#line 71
  if (tmp < (unsigned int )bytes) {
#line 72
    fatal("buffer_get_bignum: input buffer too small");
  }
#line 73
  tmp___0 = buffer_ptr(buffer);
#line 73
  bin = (unsigned char *)tmp___0;
#line 74
  BN_bin2bn((unsigned char const   *)bin, bytes, value);
#line 75
  buffer_consume(buffer, (unsigned int )bytes);
#line 77
  return (2 + bytes);
}
}
#line 83 "bufaux.c"
void buffer_put_bignum2(Buffer *buffer , BIGNUM *value ) 
{ int bytes ;
  int tmp ;
  unsigned char *buf___1 ;
  void *tmp___0 ;
  int oi ;
  int hasnohigh ;
  int i ;
  int carry ;
  unsigned char *uc ;
  int tmp___1 ;

  {
#line 86
  tmp = BN_num_bits((BIGNUM const   *)value);
#line 86
  bytes = (tmp + 7) / 8 + 1;
#line 87
  tmp___0 = xmalloc((unsigned int )bytes);
#line 87
  buf___1 = (unsigned char *)tmp___0;
#line 89
  hasnohigh = 0;
#line 90
  *(buf___1 + 0) = (unsigned char )'\000';
#line 92
  oi = BN_bn2bin((BIGNUM const   *)value, buf___1 + 1);
#line 93
  if (oi != bytes - 1) {
#line 94
    fatal("buffer_put_bignum: BN_bn2bin() failed: oi %d != bin_size %d", oi, bytes);
  }
#line 96
  if ((int )*(buf___1 + 1) & 128) {
#line 96
    hasnohigh = 0;
  } else {
#line 96
    hasnohigh = 1;
  }
#line 97
  if (value->neg) {
#line 100
    uc = buf___1;
#line 101
    log("negativ!");
#line 102
    i = bytes - 1;
#line 102
    carry = 1;
#line 102
    while (i >= 0) {
#line 103
      *(uc + i) = (unsigned char )((int )*(uc + i) ^ 255);
#line 104
      if (carry) {
#line 105
        *(uc + i) = (unsigned char )((int )*(uc + i) + 1);
#line 105
        if (*(uc + i)) {
#line 105
          tmp___1 = 0;
        } else {
#line 105
          tmp___1 = 1;
        }
#line 105
        carry = tmp___1;
      }
#line 102
      i --;
    }
  }
#line 108
  buffer_put_string(buffer, (void const   *)(buf___1 + hasnohigh), (unsigned int )(bytes - hasnohigh));
#line 109
  memset((void *)buf___1, 0, (unsigned int )bytes);
#line 110
  xfree((void *)buf___1);
#line 111
  return;
}
}
#line 113 "bufaux.c"
int buffer_get_bignum2(Buffer *buffer , BIGNUM *value ) 
{ int len ;
  unsigned char *bin ;
  char *tmp ;

  {
#line 118
  tmp = buffer_get_string(buffer, (unsigned int *)(& len));
#line 118
  bin = (unsigned char *)tmp;
#line 119
  BN_bin2bn((unsigned char const   *)bin, len, value);
#line 120
  xfree((void *)bin);
#line 121
  return (len);
}
}
#line 127 "bufaux.c"
unsigned int buffer_get_int(Buffer *buffer ) 
{ unsigned char buf___1[4] ;

  {
#line 131
  buffer_get(buffer, (char *)(buf___1), 4U);
#line 132
  return ((unsigned int )(((((unsigned long )buf___1[0] << 24) | ((unsigned long )buf___1[1] << 16)) | ((unsigned long )buf___1[2] << 8)) | (unsigned long )buf___1[3]));
}
}
#line 138 "bufaux.c"
void buffer_put_int(Buffer *buffer , unsigned int value ) 
{ char buf___1[4] ;

  {
#line 142
  while (1) {
#line 142
    buf___1[0] = (char )(value >> 24);
#line 142
    buf___1[1] = (char )(value >> 16);
#line 142
    buf___1[2] = (char )(value >> 8);
#line 142
    buf___1[3] = (char )value;
#line 142
    break;
  }
#line 143
  buffer_append(buffer, (char const   *)(buf___1), 4U);
#line 144
  return;
}
}
#line 154 "bufaux.c"
char *buffer_get_string(Buffer *buffer , unsigned int *length_ptr ) 
{ unsigned int len ;
  char *value ;
  void *tmp ;

  {
#line 160
  len = buffer_get_int(buffer);
#line 161
  if (len > 262144U) {
#line 162
    fatal("Received packet with bad string length %d", len);
  }
#line 164
  tmp = xmalloc(len + 1U);
#line 164
  value = (char *)tmp;
#line 166
  buffer_get(buffer, value, len);
#line 168
  *(value + len) = (char)0;
#line 170
  if (length_ptr) {
#line 171
    *length_ptr = len;
  }
#line 172
  return (value);
}
}
#line 178 "bufaux.c"
void buffer_put_string(Buffer *buffer , void const   *buf___1 , unsigned int len ) 
{ 

  {
#line 181
  buffer_put_int(buffer, len);
#line 182
  buffer_append(buffer, (char const   *)buf___1, len);
#line 183
  return;
}
}
#line 184 "bufaux.c"
void buffer_put_cstring(Buffer *buffer , char const   *s ) 
{ size_t tmp ;

  {
#line 187
  tmp = strlen(s);
#line 187
  buffer_put_string(buffer, (void const   *)s, tmp);
#line 188
  return;
}
}
#line 193 "bufaux.c"
int buffer_get_char(Buffer *buffer ) 
{ char ch ;

  {
#line 197
  buffer_get(buffer, & ch, 1U);
#line 198
  return ((int )((unsigned char )ch));
}
}
#line 204 "bufaux.c"
void buffer_put_char(Buffer *buffer , int value ) 
{ char ch ;

  {
#line 207
  ch = (char )value;
#line 208
  buffer_append(buffer, (char const   *)(& ch), 1U);
#line 209
  return;
}
}
#line 1 "buffer.o"
#pragma merger(0,"./buffer.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 38 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                  size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 43
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 144 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 327
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 26 "xmalloc.h"
void *xrealloc(void *ptr , size_t new_size ) ;
#line 57 "buffer.h"
void buffer_consume_end(Buffer *buffer , unsigned int bytes ) ;
#line 66
void buffer_dump(Buffer *buffer ) ;
#line 25 "buffer.c"
void buffer_init(Buffer *buffer ) 
{ void *tmp ;

  {
#line 28
  buffer->alloc = 4096U;
#line 29
  tmp = xmalloc(buffer->alloc);
#line 29
  buffer->buf = (char *)tmp;
#line 30
  buffer->offset = 0U;
#line 31
  buffer->end = 0U;
#line 32
  return;
}
}
#line 36 "buffer.c"
void buffer_free(Buffer *buffer ) 
{ 

  {
#line 39
  memset((void *)buffer->buf, 0, buffer->alloc);
#line 40
  xfree((void *)buffer->buf);
#line 41
  return;
}
}
#line 48 "buffer.c"
void buffer_clear(Buffer *buffer ) 
{ 

  {
#line 51
  buffer->offset = 0U;
#line 52
  buffer->end = 0U;
#line 53
  return;
}
}
#line 57 "buffer.c"
void buffer_append(Buffer *buffer , char const   *data , unsigned int len ) 
{ char *cp ;

  {
#line 61
  buffer_append_space(buffer, & cp, len);
#line 62
  memcpy((void * __restrict  )cp, (void const   * __restrict  )data, len);
#line 63
  return;
}
}
#line 71 "buffer.c"
void buffer_append_space(Buffer *buffer , char **datap , unsigned int len ) 
{ void *tmp ;

  {
#line 75
  if (buffer->offset == buffer->end) {
#line 76
    buffer->offset = 0U;
#line 77
    buffer->end = 0U;
  }
  restart: 
#line 81
  if (buffer->end + len < buffer->alloc) {
#line 82
    *datap = buffer->buf + buffer->end;
#line 83
    buffer->end += len;
#line 84
    return;
  }
#line 90
  if (buffer->offset > buffer->alloc / 2U) {
#line 91
    memmove((void *)buffer->buf, (void const   *)(buffer->buf + buffer->offset), buffer->end - buffer->offset);
#line 93
    buffer->end -= buffer->offset;
#line 94
    buffer->offset = 0U;
    goto restart;
  }
#line 98
  buffer->alloc += len + 32768U;
#line 99
  tmp = xrealloc((void *)buffer->buf, buffer->alloc);
#line 99
  buffer->buf = (char *)tmp;
  goto restart;
}
}
#line 105 "buffer.c"
unsigned int buffer_len(Buffer *buffer ) 
{ 

  {
#line 108
  return (buffer->end - buffer->offset);
}
}
#line 113 "buffer.c"
void buffer_get(Buffer *buffer , char *buf___1 , unsigned int len ) 
{ 

  {
#line 116
  if (len > buffer->end - buffer->offset) {
#line 117
    fatal("buffer_get: trying to get more bytes than in buffer");
  }
#line 118
  memcpy((void * __restrict  )buf___1, (void const   * __restrict  )(buffer->buf + buffer->offset),
         len);
#line 119
  buffer->offset += len;
#line 120
  return;
}
}
#line 124 "buffer.c"
void buffer_consume(Buffer *buffer , unsigned int bytes ) 
{ 

  {
#line 127
  if (bytes > buffer->end - buffer->offset) {
#line 128
    fatal("buffer_consume: trying to get more bytes than in buffer");
  }
#line 129
  buffer->offset += bytes;
#line 130
  return;
}
}
#line 134 "buffer.c"
void buffer_consume_end(Buffer *buffer , unsigned int bytes ) 
{ 

  {
#line 137
  if (bytes > buffer->end - buffer->offset) {
#line 138
    fatal("buffer_consume_end: trying to get more bytes than in buffer");
  }
#line 139
  buffer->end -= bytes;
#line 140
  return;
}
}
#line 144 "buffer.c"
char *buffer_ptr(Buffer *buffer ) 
{ 

  {
#line 147
  return (buffer->buf + buffer->offset);
}
}
#line 152 "buffer.c"
void buffer_dump(Buffer *buffer ) 
{ int i ;
  unsigned char *ucp ;

  {
#line 156
  ucp = (unsigned char *)buffer->buf;
#line 158
  i = (int )buffer->offset;
#line 158
  while ((unsigned int )i < buffer->end) {
#line 159
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" %02x", *(ucp + i));
#line 158
    i ++;
  }
#line 160
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 161
  return;
}
}
#line 1 "canohost.o"
#pragma merger(0,"./canohost.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 114 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 128
extern  __attribute__((__nothrow__)) int getpeername(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 185
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
#line 352 "/usr/include/netdb.h"
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 631
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 637
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
#line 646
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , unsigned int __flags ) ;
#line 335 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 83
extern __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 116
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 190
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 190 "/usr/include/ctype.h"
__inline static int tolower(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
#line 193
  if (__c >= -128) {
#line 193
    if (__c < 256) {
#line 193
      tmp___1 = __ctype_tolower_loc();
#line 193
      tmp___0 = *(*tmp___1 + __c);
    } else {
#line 193
      tmp___0 = (int const   )__c;
    }
  } else {
#line 193
    tmp___0 = (int const   )__c;
  }
#line 193
  return ((int )tmp___0);
}
}
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 290
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   * __restrict  __nptr ,
                                                            char ** __restrict  __endptr ,
                                                            int __base , int __group )  __attribute__((__nonnull__(1))) ;
#line 332
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 332 "/usr/include/stdlib.h"
__inline static long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                            int __base ) 
{ long tmp ;

  {
#line 336
  tmp = __strtol_internal(__nptr, __endptr, __base, 0);
#line 336
  return (tmp);
}
}
#line 401
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 401 "/usr/include/stdlib.h"
__inline static int atoi(char const   *__nptr ) 
{ long tmp ;

  {
#line 404
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 404
  return ((int )tmp);
}
}
#line 34 "packet.h"
int packet_get_connection_in(void) ;
#line 152
void ( /* format attribute */  packet_disconnect)(char const   *fmt  , ...) ;
#line 210
int packet_connection_is_on_socket(void) ;
#line 388 "ssh.h"
char *get_remote_hostname(int socket___0 ) ;
#line 395
char const   *get_canonical_hostname(void) ;
#line 401
char const   *get_remote_ipaddr(void) ;
#line 404
int get_peer_port(int sock ) ;
#line 407
int get_remote_port(void) ;
#line 408
int get_local_port(void) ;
#line 469
void fatal_cleanup(void) ;
#line 28 "canohost.c"
char *get_remote_hostname(int socket___0 ) 
{ struct sockaddr_storage from ;
  int i ;
  socklen_t fromlen ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char name[64] ;
  char ntop[1025] ;
  char ntop2[1025] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  struct sockaddr_in6 *from6 ;
  struct sockaddr_in *from4 ;
  struct in_addr addr ;
  u_int16_t port ;
  register unsigned int __v ;
  register unsigned int __x ;
  int tmp___2 ;
  int __res ;
  __int32_t const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  unsigned char options___0[200] ;
  unsigned char *ucp ;
  char text[1024] ;
  char *cp ;
  socklen_t option_size ;
  int ipproto ;
  struct protoent *ip ;
  int tmp___20 ;
  char *tmp___21 ;

  {
#line 39
  fromlen = sizeof(from);
#line 40
  memset((void *)(& from), 0, sizeof(from));
#line 41
  tmp___1 = getpeername(socket___0, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                        (socklen_t * __restrict  )(& fromlen));
#line 41
  if (tmp___1 < 0) {
#line 42
    tmp = __errno_location();
#line 42
    tmp___0 = strerror(*tmp);
#line 42
    debug("getpeername failed: %.100s", tmp___0);
#line 43
    fatal_cleanup();
  }
#line 47
  if ((int )from.ss_family == 10) {
#line 48
    from6 = (struct sockaddr_in6 *)(& from);
#line 52
    if (*((uint32_t const   *)(& from6->sin6_addr) + 0) == 0U) {
#line 52
      if (*((uint32_t const   *)(& from6->sin6_addr) + 1) == 0U) {
#line 52
        __x = 65535U;
#line 52
        __asm__  ("rorw $8, %w0;"
                  "rorl $16, %0;"
                  "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 52
        if (*((uint32_t const   *)(& from6->sin6_addr) + 2) == (uint32_t const   )__v) {
#line 53
          from4 = (struct sockaddr_in *)(& from);
#line 57
          memcpy((void * __restrict  )(& addr), (void const   * __restrict  )((char *)(& from6->sin6_addr) + 12),
                 sizeof(addr));
#line 58
          port = from6->sin6_port;
#line 60
          memset((void *)(& from), 0, sizeof(from));
#line 62
          from4->sin_family = (unsigned short)2;
#line 63
          memcpy((void * __restrict  )(& from4->sin_addr), (void const   * __restrict  )(& addr),
                 sizeof(addr));
#line 64
          from4->sin_port = port;
        }
      }
    }
  }
#line 69
  tmp___2 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )((void *)0),
                        0U, 1U);
#line 69
  if (tmp___2 != 0) {
#line 71
    fatal("get_remote_hostname: getnameinfo NI_NUMERICHOST failed");
  }
#line 74
  tmp___19 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                         fromlen, (char * __restrict  )(name), sizeof(name), (char * __restrict  )((void *)0),
                         0U, 8U);
#line 74
  if (tmp___19 == 0) {
#line 77
    name[sizeof(name) - 1U] = (char )'\000';
#line 82
    i = 0;
#line 82
    while (name[i]) {
#line 83
      tmp___6 = __ctype_b_loc();
#line 83
      if ((int const   )*(*tmp___6 + (int )name[i]) & 256) {
#line 84
        if (sizeof(name[i]) > 1U) {
#line 84
          __res = tolower((int )name[i]);
        } else {
#line 84
          tmp___5 = __ctype_tolower_loc();
#line 84
          __res = (int )*(*tmp___5 + (int )name[i]);
        }
#line 84
        name[i] = (char )__res;
      }
#line 82
      i ++;
    }
#line 95
    memset((void *)(& hints), 0, sizeof(hints));
#line 96
    hints.ai_family = (int )from.ss_family;
#line 97
    hints.ai_socktype = 1;
#line 98
    tmp___7 = getaddrinfo((char const   * __restrict  )(name), (char const   * __restrict  )((void *)0),
                          (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 98
    if (tmp___7 != 0) {
#line 99
      log("reverse mapping checking getaddrinfo for %.700s failed - POSSIBLE BREAKIN ATTEMPT!",
          name);
#line 100
      strlcpy(name, (char const   *)(ntop), sizeof(name));
      goto check_ip_options;
    }
#line 104
    ai = aitop;
#line 104
    while (ai) {
#line 105
      tmp___8 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                            (char * __restrict  )(ntop2), sizeof(ntop2), (char * __restrict  )((void *)0),
                            0U, 1U);
#line 107
      if (tmp___8 == 0) {
#line 107
        if (0) {
#line 107
          __s1_len = strlen((char const   *)(ntop));
#line 107
          __s2_len = strlen((char const   *)(ntop2));
#line 107
          if (! ((unsigned int )((void const   *)(ntop + 1)) - (unsigned int )((void const   *)(ntop)) == 1U)) {
            goto _L___0;
          } else {
#line 107
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 107
              if (! ((unsigned int )((void const   *)(ntop2 + 1)) - (unsigned int )((void const   *)(ntop2)) == 1U)) {
#line 107
                tmp___18 = 1;
              } else {
#line 107
                if (__s2_len >= 4U) {
#line 107
                  tmp___18 = 1;
                } else {
#line 107
                  tmp___18 = 0;
                }
              }
            } else {
#line 107
              tmp___18 = 0;
            }
          }
#line 107
          if (tmp___18) {
#line 107
            tmp___14 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
          } else {
#line 107
            tmp___17 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
#line 107
            tmp___14 = tmp___17;
          }
        } else {
#line 107
          tmp___17 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
#line 107
          tmp___14 = tmp___17;
        }
#line 107
        if (tmp___14 == 0) {
#line 108
          break;
        }
      }
#line 104
      ai = ai->ai_next;
    }
#line 110
    freeaddrinfo(aitop);
#line 112
    if (! ai) {
#line 114
      log("Address %.100s maps to %.600s, but this does not map back to the address - POSSIBLE BREAKIN ATTEMPT!",
          ntop, name);
#line 116
      strlcpy(name, (char const   *)(ntop), sizeof(name));
      goto check_ip_options;
    }
  } else {
#line 122
    strlcpy(name, (char const   *)(ntop), sizeof(name));
#line 123
    log("Could not reverse map address %.100s.", name);
  }
  check_ip_options: 
#line 140
  if ((int )from.ss_family == 2) {
#line 147
    ip = getprotobyname("ip");
#line 147
    if ((unsigned int )ip != (unsigned int )((void *)0)) {
#line 148
      ipproto = ip->p_proto;
    } else {
#line 150
      ipproto = 0;
    }
#line 151
    option_size = sizeof(options___0);
#line 152
    tmp___20 = getsockopt(0, ipproto, 4, (void * __restrict  )((char *)(options___0)),
                          (socklen_t * __restrict  )(& option_size));
#line 152
    if (tmp___20 >= 0) {
#line 152
      if (option_size != 0U) {
#line 154
        cp = text;
#line 156
        ucp = options___0;
#line 156
        while (option_size > 0U) {
#line 157
          sprintf((char * __restrict  )cp, (char const   * __restrict  )" %2.2x",
                  *ucp);
#line 156
          ucp ++;
#line 156
          option_size --;
#line 156
          cp += 3;
        }
#line 158
        log("Connection from %.100s with IP options:%.800s", ntop, text);
#line 160
        packet_disconnect("Connection from %.100s with IP options:%.800s", ntop, text);
      }
    }
  }
#line 165
  tmp___21 = xstrdup((char const   *)(name));
#line 165
  return (tmp___21);
}
}
#line 177 "canohost.c"
static char *canonical_host_name  =    (char *)((void *)0);
#line 174 "canohost.c"
char const   *get_canonical_hostname(void) 
{ int tmp ;
  int tmp___0 ;

  {
#line 180
  if ((unsigned int )canonical_host_name != (unsigned int )((void *)0)) {
#line 181
    return ((char const   *)canonical_host_name);
  }
#line 184
  tmp___0 = packet_connection_is_on_socket();
#line 184
  if (tmp___0) {
#line 185
    tmp = packet_get_connection_in();
#line 185
    canonical_host_name = get_remote_hostname(tmp);
  } else {
#line 187
    canonical_host_name = xstrdup("UNKNOWN");
  }
#line 189
  return ((char const   *)canonical_host_name);
}
}
#line 200 "canohost.c"
static char *canonical_host_ip  =    (char *)((void *)0);
#line 197 "canohost.c"
char const   *get_remote_ipaddr(void) 
{ struct sockaddr_storage from ;
  socklen_t fromlen ;
  int socket___0 ;
  char ntop[1025] ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 207
  if ((unsigned int )canonical_host_ip != (unsigned int )((void *)0)) {
#line 208
    return ((char const   *)canonical_host_ip);
  }
#line 211
  tmp = packet_connection_is_on_socket();
#line 211
  if (! tmp) {
#line 212
    canonical_host_ip = xstrdup("UNKNOWN");
#line 213
    return ((char const   *)canonical_host_ip);
  }
#line 216
  socket___0 = packet_get_connection_in();
#line 219
  fromlen = sizeof(from);
#line 220
  memset((void *)(& from), 0, sizeof(from));
#line 221
  tmp___2 = getpeername(socket___0, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                        (socklen_t * __restrict  )(& fromlen));
#line 221
  if (tmp___2 < 0) {
#line 222
    tmp___0 = __errno_location();
#line 222
    tmp___1 = strerror(*tmp___0);
#line 222
    debug("getpeername failed: %.100s", tmp___1);
#line 223
    fatal_cleanup();
  }
#line 226
  tmp___3 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )((void *)0),
                        0U, 1U);
#line 226
  if (tmp___3 != 0) {
#line 228
    fatal("get_remote_hostname: getnameinfo NI_NUMERICHOST failed");
  }
#line 230
  canonical_host_ip = xstrdup((char const   *)(ntop));
#line 233
  return ((char const   *)canonical_host_ip);
}
}
#line 238 "canohost.c"
int get_sock_port(int sock , int local ) 
{ struct sockaddr_storage from ;
  socklen_t fromlen ;
  char strport[32] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 246
  fromlen = sizeof(from);
#line 247
  memset((void *)(& from), 0, sizeof(from));
#line 248
  if (local) {
#line 249
    tmp___1 = getsockname(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 249
    if (tmp___1 < 0) {
#line 250
      tmp = __errno_location();
#line 250
      tmp___0 = strerror(*tmp);
#line 250
      error("getsockname failed: %.100s", tmp___0);
#line 251
      return (0);
    }
  } else {
#line 254
    tmp___4 = getpeername(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 254
    if (tmp___4 < 0) {
#line 255
      tmp___2 = __errno_location();
#line 255
      tmp___3 = strerror(*tmp___2);
#line 255
      debug("getpeername failed: %.100s", tmp___3);
#line 256
      fatal_cleanup();
    }
  }
#line 260
  tmp___5 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )((void *)0), 0U, (char * __restrict  )(strport),
                        sizeof(strport), 2U);
#line 260
  if (tmp___5 != 0) {
#line 262
    fatal("get_sock_port: getnameinfo NI_NUMERICSERV failed");
  }
#line 263
  tmp___6 = atoi((char const   *)(strport));
#line 263
  return (tmp___6);
}
}
#line 268 "canohost.c"
int get_port(int local ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 275
  tmp = packet_connection_is_on_socket();
#line 275
  if (! tmp) {
#line 276
    return (65535);
  }
#line 279
  tmp___0 = packet_get_connection_in();
#line 279
  tmp___1 = get_sock_port(tmp___0, local);
#line 279
  return (tmp___1);
}
}
#line 282 "canohost.c"
int get_peer_port(int sock ) 
{ int tmp ;

  {
#line 285
  tmp = get_sock_port(sock, 0);
#line 285
  return (tmp);
}
}
#line 288 "canohost.c"
int get_remote_port(void) 
{ int tmp ;

  {
#line 291
  tmp = get_port(0);
#line 291
  return (tmp);
}
}
#line 294 "canohost.c"
int get_local_port(void) 
{ int tmp ;

  {
#line 297
  tmp = get_port(1);
#line 297
  return (tmp);
}
}
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned int  ) ;  */
#line 1 "channels.o"
#pragma merger(0,"./channels.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 110 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  *__addr ,
                                              socklen_t __len ) ;
#line 192
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 199
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 209
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 218
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
#line 62 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 102
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 170
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 640 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
#line 357 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 407
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 632
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) )  __attribute__((__nonnull__(1))) ;
#line 729
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template )  __attribute__((__nonnull__(1))) ;
#line 573 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 801
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 845
extern  __attribute__((__nothrow__)) int gethostname(char *__name , size_t __len )  __attribute__((__nonnull__(1))) ;
#line 465 "ssh.h"
void ( /* format attribute */  verbose)(char const   *fmt  , ...) ;
#line 476
void fatal_add_cleanup(void (*proc)(void *context ) , void *context ) ;
#line 551
int IPv4or6 ;
#line 73 "packet.h"
int packet_is_interactive(void) ;
#line 76
void packet_start(int type ) ;
#line 79
void packet_put_char(int value ) ;
#line 82
void packet_put_int(unsigned int value ) ;
#line 89
void packet_put_string(char const   *buf___1 , unsigned int len ) ;
#line 90
void packet_put_cstring(char const   *str ) ;
#line 97
void packet_send(void) ;
#line 106
void packet_read_expect(int *payload_len_ptr , int expected_type ) ;
#line 128
unsigned int packet_get_int(void) ;
#line 144
char *packet_get_string(unsigned int *length_ptr ) ;
#line 170
void packet_write_wait(void) ;
#line 179
int max_packet_size ;
#line 217
int packet_remaining(void) ;
#line 22 "uidswap.h"
void temporarily_use_uid(uid_t uid ) ;
#line 28
void restore_uid(void) ;
#line 70 "channels.h"
void channel_set_fds(int id , int rfd , int wfd , int efd , int extusage ) ;
#line 71
void channel_open(int id ) ;
#line 72
void channel_request(int id , char *service , int wantconfirm ) ;
#line 73
void channel_request_start(int id , char *service , int wantconfirm ) ;
#line 74
void channel_register_callback(int id , int mtype , channel_callback_fn *fn , void *arg ) ;
#line 75
void channel_register_cleanup(int id , channel_callback_fn *fn ) ;
#line 76
void channel_cancel_cleanup(int id ) ;
#line 77
Channel *channel_lookup(int id ) ;
#line 79
int channel_new(char *ctype , int type , int rfd , int wfd , int efd , int window ,
                int maxpack , int extusage , char *remote_name ) ;
#line 83
void channel_input_channel_request(int type , int plen ) ;
#line 84
void channel_input_close(int type , int plen ) ;
#line 85
void channel_input_close_confirmation(int type , int plen ) ;
#line 86
void channel_input_data(int type , int plen ) ;
#line 87
void channel_input_extended_data(int type , int plen ) ;
#line 88
void channel_input_ieof(int type , int plen ) ;
#line 89
void channel_input_oclose(int type , int plen ) ;
#line 90
void channel_input_open_confirmation(int type , int plen ) ;
#line 91
void channel_input_open_failure(int type , int plen ) ;
#line 92
void channel_input_port_open(int type , int plen ) ;
#line 93
void channel_input_window_adjust(int type , int plen ) ;
#line 97
void channel_set_options(int hostname_in_open ) ;
#line 104
int channel_allocate(int type , int sock , char *remote_name ) ;
#line 107
void channel_free(int id ) ;
#line 110
void channel_prepare_select(fd_set *readset , fd_set *writeset ) ;
#line 116
void channel_after_select(fd_set *readset , fd_set *writeset ) ;
#line 119
void channel_output_poll(void) ;
#line 122
int channel_not_very_much_buffered_data(void) ;
#line 126
void channel_stop_listening(void) ;
#line 132
void channel_close_all(void) ;
#line 135
int channel_max_fd(void) ;
#line 138
int channel_still_open(void) ;
#line 145
char *channel_open_message(void) ;
#line 152
void channel_request_local_forwarding(u_short port , char const   *host , u_short host_port ,
                                      int gateway_ports ) ;
#line 162
void channel_request_remote_forwarding(u_short listen_port , char const   *host_to_connect ,
                                       u_short port_to_connect ) ;
#line 171
void channel_permit_all_opens(void) ;
#line 178
void channel_input_port_forward_request(int is_root , int gateway_ports ) ;
#line 191
char *x11_create_display_inet(int screen_number , int x11_display_offset ) ;
#line 198
void x11_input_open(int type , int plen ) ;
#line 210
void x11_request_forwarding_with_spoofing(int client_session_id , char const   *proto ,
                                          char const   *data ) ;
#line 215
void auth_request_forwarding(void) ;
#line 222
char *auth_get_socket_name(void) ;
#line 228
void auth_input_request_forwarding(struct passwd *pw ) ;
#line 231
void auth_input_open_request(int type , int plen ) ;
#line 234
int channel_connect_to(char const   *host , u_short host_port ) ;
#line 235
int x11_connect_display(void) ;
#line 83 "nchan.h"
chan_event_fn *chan_rcvd_oclose ;
#line 84
chan_event_fn *chan_read_failed ;
#line 85
chan_event_fn *chan_ibuf_empty ;
#line 88
chan_event_fn *chan_rcvd_ieof ;
#line 89
chan_event_fn *chan_write_failed ;
#line 90
chan_event_fn *chan_obuf_empty ;
#line 92
chan_event_fn *chan_delete_if_full_closed ;
#line 94
void chan_init_iostates(Channel *c ) ;
#line 95
void chan_init(void) ;
#line 48 "compat.h"
int compat13 ;
#line 49
int compat20 ;
#line 50
int datafellows ;
#line 53 "channels.c"
static Channel *channels  =    (Channel *)((void *)0);
#line 60 "channels.c"
static int channels_alloc  =    0;
#line 66 "channels.c"
static int channel_max_fd_value  =    0;
#line 69 "channels.c"
static char *channel_forwarded_auth_socket_name  =    (char *)((void *)0);
#line 70 "channels.c"
static char *channel_forwarded_auth_socket_dir  =    (char *)((void *)0);
#line 73 "channels.c"
char *x11_saved_proto  =    (char *)((void *)0);
#line 76 "channels.c"
char *x11_saved_data  =    (char *)((void *)0);
#line 77 "channels.c"
unsigned int x11_saved_data_len  =    0U;
#line 83 "channels.c"
char *x11_fake_data  =    (char *)((void *)0);
#line 84 "channels.c"
unsigned int x11_fake_data_len  ;
#line 99 "channels.c"
static ForwardPermission permitted_opens[100]  ;
#line 101 "channels.c"
static int num_permitted_opens  =    0;
#line 107 "channels.c"
static int all_opens_permitted  =    0;
#line 110 "channels.c"
static int have_hostname_in_open  =    0;
#line 114 "channels.c"
void channel_set_options(int hostname_in_open ) 
{ 

  {
#line 117
  have_hostname_in_open = hostname_in_open;
#line 118
  return;
}
}
#line 126 "channels.c"
void channel_permit_all_opens(void) 
{ 

  {
#line 129
  all_opens_permitted = 1;
#line 130
  return;
}
}
#line 134 "channels.c"
Channel *channel_lookup(int id ) 
{ Channel *c ;

  {
#line 138
  if (id < 0) {
#line 138
    if (id > channels_alloc) {
#line 139
      log("channel_lookup: %d: bad id", id);
#line 140
      return ((Channel *)((void *)0));
    }
  }
#line 142
  c = channels + id;
#line 143
  if (c->type == 0) {
#line 144
    log("channel_lookup: %d: bad id: channel free", id);
#line 145
    return ((Channel *)((void *)0));
  }
#line 147
  return (c);
}
}
#line 155 "channels.c"
void channel_register_fds(Channel *c , int rfd , int wfd , int efd , int extusage ) 
{ 

  {
#line 159
  if (rfd > channel_max_fd_value) {
#line 160
    channel_max_fd_value = rfd;
  }
#line 161
  if (wfd > channel_max_fd_value) {
#line 162
    channel_max_fd_value = wfd;
  }
#line 163
  if (efd > channel_max_fd_value) {
#line 164
    channel_max_fd_value = efd;
  }
#line 167
  c->rfd = rfd;
#line 168
  c->wfd = wfd;
#line 169
  if (rfd == wfd) {
#line 169
    c->sock = rfd;
  } else {
#line 169
    c->sock = -1;
  }
#line 170
  c->efd = efd;
#line 171
  c->extended_usage = extusage;
#line 172
  if (rfd != -1) {
#line 173
    set_nonblock(rfd);
  }
#line 174
  if (wfd != -1) {
#line 175
    set_nonblock(wfd);
  }
#line 176
  if (efd != -1) {
#line 177
    set_nonblock(efd);
  }
#line 178
  return;
}
}
#line 185 "channels.c"
int channel_new(char *ctype , int type , int rfd , int wfd , int efd , int window ,
                int maxpack , int extusage , char *remote_name ) 
{ int i ;
  int found ;
  Channel *c ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 193
  if (channels_alloc == 0) {
#line 194
    chan_init();
#line 195
    channels_alloc = 10;
#line 196
    tmp = xmalloc((unsigned int )channels_alloc * sizeof(Channel ));
#line 196
    channels = (Channel *)tmp;
#line 197
    i = 0;
#line 197
    while (i < channels_alloc) {
#line 198
      (channels + i)->type = 0;
#line 197
      i ++;
    }
#line 203
    fatal_add_cleanup((void (*)(void * ))(& channel_stop_listening), (void *)0);
  }
#line 206
  found = -1;
#line 206
  i = 0;
#line 206
  while (i < channels_alloc) {
#line 207
    if ((channels + i)->type == 0) {
#line 209
      found = i;
#line 210
      break;
    }
#line 206
    i ++;
  }
#line 212
  if (found == -1) {
#line 214
    found = channels_alloc;
#line 215
    channels_alloc += 10;
#line 216
    debug("channel: expanding %d", channels_alloc);
#line 217
    tmp___0 = xrealloc((void *)channels, (unsigned int )channels_alloc * sizeof(Channel ));
#line 217
    channels = (Channel *)tmp___0;
#line 218
    i = found;
#line 218
    while (i < channels_alloc) {
#line 219
      (channels + i)->type = 0;
#line 218
      i ++;
    }
  }
#line 222
  c = channels + found;
#line 223
  buffer_init(& c->input);
#line 224
  buffer_init(& c->output);
#line 225
  buffer_init(& c->extended);
#line 226
  chan_init_iostates(c);
#line 227
  channel_register_fds(c, rfd, wfd, efd, extusage);
#line 228
  c->self = found;
#line 229
  c->type = type;
#line 230
  c->ctype = ctype;
#line 231
  c->local_window = window;
#line 232
  c->local_window_max = window;
#line 233
  c->local_consumed = 0;
#line 234
  c->local_maxpacket = maxpack;
#line 235
  c->remote_id = -1;
#line 236
  c->remote_name = remote_name;
#line 237
  c->remote_window = 0;
#line 238
  c->remote_maxpacket = 0;
#line 239
  c->cb_fn = (channel_callback_fn *)((void *)0);
#line 240
  c->cb_arg = (void *)0;
#line 241
  c->cb_event = 0;
#line 242
  c->dettach_user = (channel_callback_fn *)((void *)0);
#line 243
  debug("channel %d: new [%s]", found, remote_name);
#line 244
  return (found);
}
}
#line 247 "channels.c"
int channel_allocate(int type , int sock , char *remote_name ) 
{ int tmp ;

  {
#line 250
  tmp = channel_new((char *)"", type, sock, sock, -1, 0, 0, 0, remote_name);
#line 250
  return (tmp);
}
}
#line 256 "channels.c"
void channel_close_fds(Channel *c ) 
{ 

  {
#line 259
  if (c->sock != -1) {
#line 260
    close(c->sock);
#line 261
    c->sock = -1;
  }
#line 263
  if (c->rfd != -1) {
#line 264
    close(c->rfd);
#line 265
    c->rfd = -1;
  }
#line 267
  if (c->wfd != -1) {
#line 268
    close(c->wfd);
#line 269
    c->wfd = -1;
  }
#line 271
  if (c->efd != -1) {
#line 272
    close(c->efd);
#line 273
    c->efd = -1;
  }
#line 275
  return;
}
}
#line 279 "channels.c"
void channel_free(int id ) 
{ Channel *c ;
  Channel *tmp ;
  char *tmp___0 ;

  {
#line 282
  tmp = channel_lookup(id);
#line 282
  c = tmp;
#line 283
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 284
    packet_disconnect("channel free: bad local channel %d", id);
  }
#line 285
  tmp___0 = channel_open_message();
#line 285
  debug("channel_free: channel %d: status: %s", id, tmp___0);
#line 286
  if ((unsigned int )c->dettach_user != (unsigned int )((void *)0)) {
#line 287
    debug("channel_free: channel %d: dettaching channel user", id);
#line 288
    (*(c->dettach_user))(c->self, (void *)0);
  }
#line 290
  if (c->sock != -1) {
#line 291
    shutdown(c->sock, 2);
  }
#line 292
  channel_close_fds(c);
#line 293
  buffer_free(& c->input);
#line 294
  buffer_free(& c->output);
#line 295
  buffer_free(& c->extended);
#line 296
  c->type = 0;
#line 297
  if (c->remote_name) {
#line 298
    xfree((void *)c->remote_name);
#line 299
    c->remote_name = (char *)((void *)0);
  }
#line 301
  return;
}
}
#line 312 "channels.c"
chan_fn *channel_pre[11]  ;
#line 313 "channels.c"
chan_fn *channel_post[11]  ;
#line 315 "channels.c"
void channel_pre_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 318
  __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 319
  return;
}
}
#line 321 "channels.c"
void channel_pre_open_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 324
  tmp = buffer_len(& c->input);
#line 324
  if (tmp < (unsigned int )max_packet_size) {
#line 325
    __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 326
  tmp___0 = buffer_len(& c->output);
#line 326
  if (tmp___0 > 0U) {
#line 327
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 328
  return;
}
}
#line 330 "channels.c"
void channel_pre_open_15(Channel *c , fd_set *readset , fd_set *writeset ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 334
  if (c->istate == 1) {
#line 335
    tmp = buffer_len(& c->input);
#line 335
    if (tmp < (unsigned int )max_packet_size) {
#line 336
      __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
  }
#line 337
  if (c->ostate == 16) {
    goto _L;
  } else {
#line 337
    if (c->ostate == 32) {
      _L: /* CIL Label */ 
#line 339
      tmp___0 = buffer_len(& c->output);
#line 339
      if (tmp___0 > 0U) {
#line 340
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      } else {
#line 341
        if (c->ostate == 32) {
#line 342
          (*chan_obuf_empty)(c);
        }
      }
    }
  }
#line 345
  return;
}
}
#line 347 "channels.c"
void channel_pre_open_20(Channel *c , fd_set *readset , fd_set *writeset ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 350
  if (c->istate == 1) {
#line 350
    if (c->remote_window > 0) {
#line 350
      tmp = buffer_len(& c->input);
#line 350
      if (tmp < (unsigned int )c->remote_window) {
#line 353
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->rfd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->rfd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
  }
#line 354
  if (c->ostate == 16) {
    goto _L;
  } else {
#line 354
    if (c->ostate == 32) {
      _L: /* CIL Label */ 
#line 356
      tmp___0 = buffer_len(& c->output);
#line 356
      if (tmp___0 > 0U) {
#line 357
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->wfd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->wfd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      } else {
#line 358
        if (c->ostate == 32) {
#line 359
          (*chan_obuf_empty)(c);
        }
      }
    }
  }
#line 363
  if (c->efd != -1) {
#line 364
    if (c->extended_usage == 2) {
#line 364
      tmp___2 = buffer_len(& c->extended);
#line 364
      if (tmp___2 > 0U) {
#line 366
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 367
      if (c->extended_usage == 1) {
#line 367
        tmp___1 = buffer_len(& c->extended);
#line 367
        if (tmp___1 < (unsigned int )c->remote_window) {
#line 369
          __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        }
      }
    }
  }
#line 371
  return;
}
}
#line 373 "channels.c"
void channel_pre_input_draining(Channel *c , fd_set *readset , fd_set *writeset ) 
{ unsigned int tmp ;

  {
#line 376
  tmp = buffer_len(& c->input);
#line 376
  if (tmp == 0U) {
#line 377
    packet_start(24);
#line 378
    packet_put_int((unsigned int )c->remote_id);
#line 379
    packet_send();
#line 380
    c->type = 5;
#line 381
    debug("Closing channel %d after input drain.", c->self);
  }
#line 383
  return;
}
}
#line 385 "channels.c"
void channel_pre_output_draining(Channel *c , fd_set *readset , fd_set *writeset ) 
{ unsigned int tmp ;

  {
#line 388
  tmp = buffer_len(& c->output);
#line 388
  if (tmp == 0U) {
#line 389
    channel_free(c->self);
  } else {
#line 391
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 392
  return;
}
}
#line 402 "channels.c"
int x11_open_helper(Channel *c ) 
{ unsigned char *ucp ;
  unsigned int proto_len ;
  unsigned int data_len ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 409
  tmp = buffer_len(& c->output);
#line 409
  if (tmp < 12U) {
#line 410
    return (0);
  }
#line 413
  tmp___0 = buffer_ptr(& c->output);
#line 413
  ucp = (unsigned char *)tmp___0;
#line 414
  if ((int )*(ucp + 0) == 66) {
#line 415
    proto_len = (unsigned int )(256 * (int )*(ucp + 6) + (int )*(ucp + 7));
#line 416
    data_len = (unsigned int )(256 * (int )*(ucp + 8) + (int )*(ucp + 9));
  } else {
#line 417
    if ((int )*(ucp + 0) == 108) {
#line 418
      proto_len = (unsigned int )((int )*(ucp + 6) + 256 * (int )*(ucp + 7));
#line 419
      data_len = (unsigned int )((int )*(ucp + 8) + 256 * (int )*(ucp + 9));
    } else {
#line 421
      debug("Initial X11 packet contains bad byte order byte: 0x%x", *(ucp + 0));
#line 423
      return (-1);
    }
  }
#line 427
  tmp___1 = buffer_len(& c->output);
#line 427
  if (tmp___1 < (12U + ((proto_len + 3U) & 4294967292U)) + ((data_len + 3U) & 4294967292U)) {
#line 429
    return (0);
  }
#line 432
  tmp___2 = strlen((char const   *)x11_saved_proto);
#line 432
  if (proto_len != tmp___2) {
#line 434
    debug("X11 connection uses different authentication protocol.");
#line 435
    return (-1);
  } else {
#line 432
    tmp___3 = memcmp((void const   *)(ucp + 12), (void const   *)x11_saved_proto,
                     proto_len);
#line 432
    if (tmp___3 != 0) {
#line 434
      debug("X11 connection uses different authentication protocol.");
#line 435
      return (-1);
    }
  }
#line 438
  if (data_len != x11_fake_data_len) {
#line 441
    debug("X11 auth data does not match fake data.");
#line 442
    return (-1);
  } else {
#line 438
    tmp___4 = memcmp((void const   *)((ucp + 12) + ((proto_len + 3U) & 4294967292U)),
                     (void const   *)x11_fake_data, x11_fake_data_len);
#line 438
    if (tmp___4 != 0) {
#line 441
      debug("X11 auth data does not match fake data.");
#line 442
      return (-1);
    }
  }
#line 445
  if (x11_fake_data_len != x11_saved_data_len) {
#line 446
    error("X11 fake_data_len %d != saved_data_len %d", x11_fake_data_len, x11_saved_data_len);
#line 448
    return (-1);
  }
#line 455
  memcpy((void * __restrict  )((ucp + 12) + ((proto_len + 3U) & 4294967292U)), (void const   * __restrict  )x11_saved_data,
         x11_saved_data_len);
#line 457
  return (1);
}
}
#line 460 "channels.c"
void channel_pre_x11_open_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int ret ;
  int tmp ;

  {
#line 463
  tmp = x11_open_helper(c);
#line 463
  ret = tmp;
#line 464
  if (ret == 1) {
#line 466
    c->type = 4;
#line 467
    channel_pre_open_13(c, readset, writeset);
  } else {
#line 468
    if (ret == -1) {
#line 473
      log("X11 connection rejected because of wrong authentication.\r\n");
#line 474
      buffer_clear(& c->input);
#line 475
      buffer_clear(& c->output);
#line 476
      close(c->sock);
#line 477
      c->sock = -1;
#line 478
      c->type = 5;
#line 479
      packet_start(24);
#line 480
      packet_put_int((unsigned int )c->remote_id);
#line 481
      packet_send();
    }
  }
#line 483
  return;
}
}
#line 485 "channels.c"
void channel_pre_x11_open(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int ret ;
  int tmp ;

  {
#line 488
  tmp = x11_open_helper(c);
#line 488
  ret = tmp;
#line 489
  if (ret == 1) {
#line 490
    c->type = 4;
#line 491
    if (compat20) {
#line 492
      channel_pre_open_20(c, readset, writeset);
    } else {
#line 494
      channel_pre_open_15(c, readset, writeset);
    }
  } else {
#line 495
    if (ret == -1) {
#line 496
      debug("X11 rejected %d i%d/o%d", c->self, c->istate, c->ostate);
#line 497
      (*chan_read_failed)(c);
#line 498
      (*chan_write_failed)(c);
#line 499
      debug("X11 closed %d i%d/o%d", c->self, c->istate, c->ostate);
    }
  }
#line 501
  return;
}
}
#line 504 "channels.c"
void channel_post_x11_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ struct sockaddr addr ;
  int newsock ;
  int newch ;
  socklen_t addrlen ;
  char buf___1[16384] ;
  char *remote_hostname ;
  int remote_port ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  register char __result ;

  {
#line 513
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 513
  if (__result) {
#line 514
    debug("X11 connection requested.");
#line 515
    addrlen = sizeof(addr);
#line 516
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 517
    if (newsock < 0) {
#line 518
      tmp = __errno_location();
#line 518
      tmp___0 = strerror(*tmp);
#line 518
      error("accept: %.100s", tmp___0);
#line 519
      return;
    }
#line 521
    remote_hostname = get_remote_hostname(newsock);
#line 522
    remote_port = get_peer_port(newsock);
#line 523
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"X11 connection from %.200s port %d",
             remote_hostname, remote_port);
#line 526
    tmp___1 = xstrdup((char const   *)(buf___1));
#line 526
    newch = channel_new((char *)"x11", 3, newsock, newsock, -1, c->local_window_max,
                        c->local_maxpacket, 0, tmp___1);
#line 530
    if (compat20) {
#line 531
      packet_start(90);
#line 532
      packet_put_cstring("x11");
#line 533
      packet_put_int((unsigned int )newch);
#line 534
      packet_put_int((unsigned int )c->local_window_max);
#line 535
      packet_put_int((unsigned int )c->local_maxpacket);
#line 537
      packet_put_cstring((char const   *)remote_hostname);
#line 538
      if (datafellows & 8) {
#line 539
        debug("ssh2 x11 bug compat mode");
      } else {
#line 541
        packet_put_int((unsigned int )remote_port);
      }
#line 543
      packet_send();
    } else {
#line 545
      packet_start(27);
#line 546
      packet_put_int((unsigned int )newch);
#line 547
      if (have_hostname_in_open) {
#line 548
        tmp___2 = strlen((char const   *)(buf___1));
#line 548
        packet_put_string((char const   *)(buf___1), tmp___2);
      }
#line 549
      packet_send();
    }
#line 551
    xfree((void *)remote_hostname);
  }
#line 553
  return;
}
}
#line 558 "channels.c"
void channel_post_port_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ struct sockaddr addr ;
  int newsock ;
  int newch ;
  socklen_t addrlen ;
  char buf___1[1024] ;
  char *remote_hostname ;
  int remote_port ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  register char __result ;

  {
#line 567
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 567
  if (__result) {
#line 568
    debug("Connection to port %d forwarding to %.100s port %d requested.", c->listening_port,
          c->path, c->host_port);
#line 571
    addrlen = sizeof(addr);
#line 572
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 573
    if (newsock < 0) {
#line 574
      tmp = __errno_location();
#line 574
      tmp___0 = strerror(*tmp);
#line 574
      error("accept: %.100s", tmp___0);
#line 575
      return;
    }
#line 577
    remote_hostname = get_remote_hostname(newsock);
#line 578
    remote_port = get_peer_port(newsock);
#line 579
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"listen port %d for %.100s port %d, connect from %.200s port %d",
             c->listening_port, c->path, c->host_port, remote_hostname, remote_port);
#line 584
    tmp___1 = xstrdup((char const   *)(buf___1));
#line 584
    newch = channel_new((char *)"direct-tcpip", 3, newsock, newsock, -1, c->local_window_max,
                        c->local_maxpacket, 0, tmp___1);
#line 588
    if (compat20) {
#line 589
      packet_start(90);
#line 590
      packet_put_cstring("direct-tcpip");
#line 591
      packet_put_int((unsigned int )newch);
#line 592
      packet_put_int((unsigned int )c->local_window_max);
#line 593
      packet_put_int((unsigned int )c->local_maxpacket);
#line 595
      tmp___2 = strlen((char const   *)(c->path));
#line 595
      packet_put_string((char const   *)(c->path), tmp___2);
#line 596
      packet_put_int((unsigned int )c->host_port);
#line 598
      packet_put_cstring((char const   *)remote_hostname);
#line 599
      packet_put_int((unsigned int )remote_port);
#line 600
      packet_send();
    } else {
#line 602
      packet_start(29);
#line 603
      packet_put_int((unsigned int )newch);
#line 604
      tmp___3 = strlen((char const   *)(c->path));
#line 604
      packet_put_string((char const   *)(c->path), tmp___3);
#line 605
      packet_put_int((unsigned int )c->host_port);
#line 606
      if (have_hostname_in_open) {
#line 607
        tmp___4 = strlen((char const   *)(buf___1));
#line 607
        packet_put_string((char const   *)(buf___1), tmp___4);
      }
#line 609
      packet_send();
    }
#line 611
    xfree((void *)remote_hostname);
  }
#line 613
  return;
}
}
#line 619 "channels.c"
void channel_post_auth_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ struct sockaddr addr ;
  int newsock ;
  int newch ;
  socklen_t addrlen ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  register char __result ;

  {
#line 626
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 626
  if (__result) {
#line 627
    addrlen = sizeof(addr);
#line 628
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 629
    if (newsock < 0) {
#line 630
      tmp = __errno_location();
#line 630
      tmp___0 = strerror(*tmp);
#line 630
      error("accept from auth socket: %.100s", tmp___0);
#line 631
      return;
    }
#line 633
    tmp___1 = xstrdup("accepted auth socket");
#line 633
    newch = channel_allocate(3, newsock, tmp___1);
#line 635
    packet_start(31);
#line 636
    packet_put_int((unsigned int )newch);
#line 637
    packet_send();
  }
#line 639
  return;
}
}
#line 641 "channels.c"
int channel_handle_rfd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char buf___1[16384] ;
  int len ;
  int *tmp ;
  int *tmp___0 ;
  unsigned int tmp___1 ;
  register char __result ;

  {
#line 648
  if (c->rfd != -1) {
#line 648
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->rfd % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )c->rfd / (8U * sizeof(__fd_mask ))]): "cc");
#line 648
    if (__result) {
#line 649
      len = read(c->rfd, (void *)(buf___1), sizeof(buf___1));
#line 650
      if (len < 0) {
#line 650
        tmp = __errno_location();
#line 650
        if (*tmp == 4) {
#line 651
          return (1);
        } else {
#line 650
          tmp___0 = __errno_location();
#line 650
          if (*tmp___0 == 11) {
#line 651
            return (1);
          }
        }
      }
#line 652
      if (len <= 0) {
#line 653
        debug("channel %d: read<=0 rfd %d len %d", c->self, c->rfd, len);
#line 655
        if (compat13) {
#line 656
          tmp___1 = buffer_len(& c->output);
#line 656
          buffer_consume(& c->output, tmp___1);
#line 657
          c->type = 8;
#line 658
          debug("Channel %d status set to input draining.", c->self);
        } else {
#line 660
          (*chan_read_failed)(c);
        }
#line 662
        return (-1);
      }
#line 664
      buffer_append(& c->input, (char const   *)(buf___1), (unsigned int )len);
    }
  }
#line 666
  return (1);
}
}
#line 668 "channels.c"
int channel_handle_wfd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  unsigned int tmp___3 ;
  register char __result ;
  unsigned int tmp___4 ;

  {
#line 675
  if (c->wfd != -1) {
#line 675
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->wfd % (8U * sizeof(__fd_mask ))),
                         "m" (writeset->__fds_bits[(unsigned int )c->wfd / (8U * sizeof(__fd_mask ))]): "cc");
#line 675
    if (__result) {
#line 675
      tmp___4 = buffer_len(& c->output);
#line 675
      if (tmp___4 > 0U) {
#line 677
        tmp = buffer_len(& c->output);
#line 677
        tmp___0 = buffer_ptr(& c->output);
#line 677
        len = write(c->wfd, (void const   *)tmp___0, tmp);
#line 679
        if (len < 0) {
#line 679
          tmp___1 = __errno_location();
#line 679
          if (*tmp___1 == 4) {
#line 680
            return (1);
          } else {
#line 679
            tmp___2 = __errno_location();
#line 679
            if (*tmp___2 == 11) {
#line 680
              return (1);
            }
          }
        }
#line 681
        if (len <= 0) {
#line 682
          if (compat13) {
#line 683
            tmp___3 = buffer_len(& c->output);
#line 683
            buffer_consume(& c->output, tmp___3);
#line 684
            debug("Channel %d status set to input draining.", c->self);
#line 685
            c->type = 8;
          } else {
#line 687
            (*chan_write_failed)(c);
          }
#line 689
          return (-1);
        }
#line 691
        buffer_consume(& c->output, (unsigned int )len);
#line 692
        if (compat20) {
#line 692
          if (len > 0) {
#line 693
            c->local_consumed += len;
          }
        }
      }
    }
  }
#line 696
  return (1);
}
}
#line 698 "channels.c"
int channel_handle_efd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char buf___1[16384] ;
  int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  register char __result ;
  register char __result___0 ;
  unsigned int tmp___1 ;

  {
#line 705
  if (c->efd != -1) {
#line 707
    if (c->extended_usage == 2) {
#line 707
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))),
                           "m" (writeset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "cc");
#line 707
      if (__result___0) {
#line 707
        tmp___1 = buffer_len(& c->extended);
#line 707
        if (tmp___1 > 0U) {
#line 709
          tmp = buffer_len(& c->extended);
#line 709
          tmp___0 = buffer_ptr(& c->extended);
#line 709
          len = write(c->efd, (void const   *)tmp___0, tmp);
#line 711
          debug("channel %d: written %d to efd %d", c->self, len, c->efd);
#line 713
          if (len > 0) {
#line 714
            buffer_consume(& c->extended, (unsigned int )len);
#line 715
            c->local_consumed += len;
          }
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 718
      if (c->extended_usage == 1) {
#line 718
        __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))),
                             "m" (readset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "cc");
#line 718
        if (__result) {
#line 719
          len = read(c->efd, (void *)(buf___1), sizeof(buf___1));
#line 720
          debug("channel %d: read %d from efd %d", c->self, len, c->efd);
#line 722
          if (len == 0) {
#line 723
            debug("channel %d: closing efd %d", c->self, c->efd);
#line 725
            close(c->efd);
#line 726
            c->efd = -1;
          } else {
#line 727
            if (len > 0) {
#line 728
              buffer_append(& c->extended, (char const   *)(buf___1), (unsigned int )len);
            }
          }
        }
      }
    }
  }
#line 731
  return (1);
}
}
#line 733 "channels.c"
int channel_check_window(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 736
  if (! (c->flags & 3)) {
#line 736
    if (c->local_window < c->local_window_max / 2) {
#line 736
      if (c->local_consumed > 0) {
#line 739
        packet_start(93);
#line 740
        packet_put_int((unsigned int )c->remote_id);
#line 741
        packet_put_int((unsigned int )c->local_consumed);
#line 742
        packet_send();
#line 743
        debug("channel %d: window %d sent adjust %d", c->self, c->local_window, c->local_consumed);
#line 746
        c->local_window += c->local_consumed;
#line 747
        c->local_consumed = 0;
      }
    }
  }
#line 749
  return (1);
}
}
#line 752 "channels.c"
void channel_post_open_1(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 755
  channel_handle_rfd(c, readset, writeset);
#line 756
  channel_handle_wfd(c, readset, writeset);
#line 757
  return;
}
}
#line 759 "channels.c"
void channel_post_open_2(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 762
  channel_handle_rfd(c, readset, writeset);
#line 763
  channel_handle_wfd(c, readset, writeset);
#line 764
  channel_handle_efd(c, readset, writeset);
#line 765
  channel_check_window(c, readset, writeset);
#line 766
  return;
}
}
#line 768 "channels.c"
void channel_post_output_drain_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  register char __result ;
  unsigned int tmp___2 ;

  {
#line 773
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 773
  if (__result) {
#line 773
    tmp___2 = buffer_len(& c->output);
#line 773
    if (tmp___2 > 0U) {
#line 774
      tmp = buffer_len(& c->output);
#line 774
      tmp___0 = buffer_ptr(& c->output);
#line 774
      len = write(c->sock, (void const   *)tmp___0, tmp);
#line 776
      if (len <= 0) {
#line 777
        tmp___1 = buffer_len(& c->output);
#line 777
        buffer_consume(& c->output, tmp___1);
      } else {
#line 779
        buffer_consume(& c->output, (unsigned int )len);
      }
    }
  }
#line 781
  return;
}
}
#line 783 "channels.c"
void channel_handler_init_20(void) 
{ 

  {
#line 786
  channel_pre[4] = & channel_pre_open_20;
#line 787
  channel_pre[7] = & channel_pre_x11_open;
#line 788
  channel_pre[2] = & channel_pre_listener;
#line 789
  channel_pre[1] = & channel_pre_listener;
#line 791
  channel_post[4] = & channel_post_open_2;
#line 792
  channel_post[2] = & channel_post_port_listener;
#line 793
  channel_post[1] = & channel_post_x11_listener;
#line 794
  return;
}
}
#line 796 "channels.c"
void channel_handler_init_13(void) 
{ 

  {
#line 799
  channel_pre[4] = & channel_pre_open_13;
#line 800
  channel_pre[7] = & channel_pre_x11_open_13;
#line 801
  channel_pre[1] = & channel_pre_listener;
#line 802
  channel_pre[2] = & channel_pre_listener;
#line 803
  channel_pre[6] = & channel_pre_listener;
#line 804
  channel_pre[8] = & channel_pre_input_draining;
#line 805
  channel_pre[9] = & channel_pre_output_draining;
#line 807
  channel_post[4] = & channel_post_open_1;
#line 808
  channel_post[1] = & channel_post_x11_listener;
#line 809
  channel_post[2] = & channel_post_port_listener;
#line 810
  channel_post[6] = & channel_post_auth_listener;
#line 811
  channel_post[9] = & channel_post_output_drain_13;
#line 812
  return;
}
}
#line 814 "channels.c"
void channel_handler_init_15(void) 
{ 

  {
#line 817
  channel_pre[4] = & channel_pre_open_15;
#line 818
  channel_pre[7] = & channel_pre_x11_open;
#line 819
  channel_pre[1] = & channel_pre_listener;
#line 820
  channel_pre[2] = & channel_pre_listener;
#line 821
  channel_pre[6] = & channel_pre_listener;
#line 823
  channel_post[1] = & channel_post_x11_listener;
#line 824
  channel_post[2] = & channel_post_port_listener;
#line 825
  channel_post[6] = & channel_post_auth_listener;
#line 826
  channel_post[4] = & channel_post_open_1;
#line 827
  return;
}
}
#line 829 "channels.c"
void channel_handler_init(void) 
{ int i ;

  {
#line 833
  i = 0;
#line 833
  while (i < 11) {
#line 834
    channel_pre[i] = (chan_fn *)((void *)0);
#line 835
    channel_post[i] = (chan_fn *)((void *)0);
#line 833
    i ++;
  }
#line 837
  if (compat20) {
#line 838
    channel_handler_init_20();
  } else {
#line 839
    if (compat13) {
#line 840
      channel_handler_init_13();
    } else {
#line 842
      channel_handler_init_15();
    }
  }
#line 843
  return;
}
}
#line 848
void channel_handler(chan_fn **ftab , fd_set *readset , fd_set *writeset ) ;
#line 848 "channels.c"
static int did_init  =    0;
#line 845 "channels.c"
void channel_handler(chan_fn **ftab , fd_set *readset , fd_set *writeset ) 
{ int i ;
  Channel *c ;

  {
#line 852
  if (! did_init) {
#line 853
    channel_handler_init();
#line 854
    did_init = 1;
  }
#line 856
  i = 0;
#line 856
  while (i < channels_alloc) {
#line 857
    c = channels + i;
#line 858
    if (c->type == 0) {
      goto __Cont;
    }
#line 860
    if ((unsigned int )*(ftab + c->type) == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 862
    (*(*(ftab + c->type)))(c, readset, writeset);
#line 863
    (*chan_delete_if_full_closed)(c);
    __Cont: /* CIL Label */ 
#line 856
    i ++;
  }
#line 865
  return;
}
}
#line 867 "channels.c"
void channel_prepare_select(fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 870
  channel_handler(channel_pre, readset, writeset);
#line 871
  return;
}
}
#line 873 "channels.c"
void channel_after_select(fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 876
  channel_handler(channel_post, readset, writeset);
#line 877
  return;
}
}
#line 881 "channels.c"
void channel_output_poll(void) 
{ int len ;
  int i ;
  Channel *c ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;

  {
#line 887
  i = 0;
#line 887
  while (i < channels_alloc) {
#line 888
    c = channels + i;
#line 891
    if (compat13) {
#line 892
      if (c->type != 4) {
#line 892
        if (c->type != 8) {
          goto __Cont;
        }
      }
    } else {
#line 896
      if (c->type != 4) {
        goto __Cont;
      }
#line 898
      if (c->istate != 1) {
#line 898
        if (c->istate != 2) {
          goto __Cont;
        }
      }
    }
#line 902
    if (compat20) {
#line 902
      if (c->flags & 3) {
#line 904
        debug("channel: %d: no data after CLOSE", c->self);
        goto __Cont;
      }
    }
#line 909
    tmp = buffer_len(& c->input);
#line 909
    len = (int )tmp;
#line 910
    if (len > 0) {
#line 912
      if (compat20) {
#line 913
        if (len > c->remote_window) {
#line 914
          len = c->remote_window;
        }
#line 915
        if (len > c->remote_maxpacket) {
#line 916
          len = c->remote_maxpacket;
        }
      } else {
#line 918
        tmp___0 = packet_is_interactive();
#line 918
        if (tmp___0) {
#line 919
          if (len > 1024) {
#line 920
            len = 512;
          }
        } else {
#line 923
          if (len > max_packet_size / 2) {
#line 924
            len = max_packet_size / 2;
          }
        }
      }
#line 927
      if (len > 0) {
#line 928
        if (compat20) {
#line 928
          tmp___1 = 94;
        } else {
#line 928
          tmp___1 = 23;
        }
#line 928
        packet_start(tmp___1);
#line 930
        packet_put_int((unsigned int )c->remote_id);
#line 931
        tmp___2 = buffer_ptr(& c->input);
#line 931
        packet_put_string((char const   *)tmp___2, (unsigned int )len);
#line 932
        packet_send();
#line 933
        buffer_consume(& c->input, (unsigned int )len);
#line 934
        c->remote_window -= len;
#line 935
        debug("channel %d: send data len %d", c->self, len);
      }
    } else {
#line 937
      if (c->istate == 2) {
#line 938
        if (compat13) {
#line 939
          fatal("cannot happen: istate == INPUT_WAIT_DRAIN for proto 1.3");
        }
#line 944
        (*chan_ibuf_empty)(c);
      }
    }
#line 947
    if (compat20) {
#line 947
      if (c->remote_window > 0) {
#line 947
        tmp___4 = buffer_len(& c->extended);
#line 947
        len = (int )tmp___4;
#line 947
        if (len > 0) {
#line 947
          if (c->extended_usage == 1) {
#line 951
            if (len > c->remote_window) {
#line 952
              len = c->remote_window;
            }
#line 953
            if (len > c->remote_maxpacket) {
#line 954
              len = c->remote_maxpacket;
            }
#line 955
            packet_start(95);
#line 956
            packet_put_int((unsigned int )c->remote_id);
#line 957
            packet_put_int(1U);
#line 958
            tmp___3 = buffer_ptr(& c->extended);
#line 958
            packet_put_string((char const   *)tmp___3, (unsigned int )len);
#line 959
            packet_send();
#line 960
            buffer_consume(& c->extended, (unsigned int )len);
#line 961
            c->remote_window -= len;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 887
    i ++;
  }
#line 964
  return;
}
}
#line 972 "channels.c"
void channel_input_data(int type , int plen ) 
{ int id ;
  char *data ;
  unsigned int data_len ;
  Channel *c ;
  unsigned int tmp ;
  int _len ;
  int tmp___0 ;
  int _p ;
  int _e ;

  {
#line 981
  tmp = packet_get_int();
#line 981
  id = (int )tmp;
#line 982
  c = channel_lookup(id);
#line 983
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 984
    packet_disconnect("Received data for nonexistent channel %d.", id);
  }
#line 987
  if (c->type != 4) {
#line 987
    if (c->type != 7) {
#line 989
      return;
    }
  }
#line 992
  if (! compat13) {
#line 992
    if (c->ostate != 16) {
#line 993
      return;
    }
  }
#line 996
  data = packet_get_string(& data_len);
#line 997
  while (1) {
#line 997
    tmp___0 = packet_remaining();
#line 997
    _len = tmp___0;
#line 997
    if (_len > 0) {
#line 997
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          997);
#line 997
      packet_disconnect("Packet integrity error.");
    }
#line 997
    break;
  }
#line 999
  if (compat20) {
#line 1000
    if (data_len > (unsigned int )c->local_maxpacket) {
#line 1001
      log("channel %d: rcvd big packet %d, maxpack %d", c->self, data_len, c->local_maxpacket);
    }
#line 1004
    if (data_len > (unsigned int )c->local_window) {
#line 1005
      log("channel %d: rcvd too much data %d, win %d", c->self, data_len, c->local_window);
#line 1007
      xfree((void *)data);
#line 1008
      return;
    }
#line 1010
    c->local_window = (int )((unsigned int )c->local_window - data_len);
  } else {
#line 1012
    while (1) {
#line 1012
      _p = plen;
#line 1012
      _e = (int )(8U + data_len);
#line 1012
      if (_p != _e) {
#line 1012
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1012);
#line 1012
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1012
      break;
    }
  }
#line 1014
  buffer_append(& c->output, (char const   *)data, data_len);
#line 1015
  xfree((void *)data);
#line 1016
  return;
}
}
#line 1017 "channels.c"
void channel_input_extended_data(int type , int plen ) 
{ int id ;
  int tcode ;
  char *data ;
  unsigned int data_len ;
  Channel *c ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1027
  tmp = packet_get_int();
#line 1027
  id = (int )tmp;
#line 1028
  c = channel_lookup(id);
#line 1030
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1031
    packet_disconnect("Received extended_data for bad channel %d.", id);
  }
#line 1032
  if (c->type != 4) {
#line 1033
    log("channel %d: ext data for non open", id);
#line 1034
    return;
  }
#line 1036
  tmp___0 = packet_get_int();
#line 1036
  tcode = (int )tmp___0;
#line 1037
  if (c->efd == -1) {
#line 1040
    log("channel %d: bad ext data", c->self);
#line 1041
    return;
  } else {
#line 1037
    if (c->extended_usage != 2) {
#line 1040
      log("channel %d: bad ext data", c->self);
#line 1041
      return;
    } else {
#line 1037
      if (tcode != 1) {
#line 1040
        log("channel %d: bad ext data", c->self);
#line 1041
        return;
      }
    }
  }
#line 1043
  data = packet_get_string(& data_len);
#line 1044
  while (1) {
#line 1044
    tmp___1 = packet_remaining();
#line 1044
    _len = tmp___1;
#line 1044
    if (_len > 0) {
#line 1044
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1044);
#line 1044
      packet_disconnect("Packet integrity error.");
    }
#line 1044
    break;
  }
#line 1045
  if (data_len > (unsigned int )c->local_window) {
#line 1046
    log("channel %d: rcvd too much extended_data %d, win %d", c->self, data_len, c->local_window);
#line 1048
    xfree((void *)data);
#line 1049
    return;
  }
#line 1051
  debug("channel %d: rcvd ext data %d", c->self, data_len);
#line 1052
  c->local_window = (int )((unsigned int )c->local_window - data_len);
#line 1053
  buffer_append(& c->extended, (char const   *)data, data_len);
#line 1054
  xfree((void *)data);
#line 1055
  return;
}
}
#line 1063 "channels.c"
int channel_not_very_much_buffered_data(void) 
{ unsigned int i ;
  Channel *c ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 1069
  i = 0U;
#line 1069
  while (i < (unsigned int )channels_alloc) {
#line 1070
    c = channels + i;
#line 1071
    if (c->type == 4) {
#line 1072
      if (! compat20) {
#line 1072
        tmp___0 = buffer_len(& c->input);
#line 1072
        if (tmp___0 > (unsigned int )max_packet_size) {
#line 1073
          tmp = buffer_len(& c->input);
#line 1073
          debug("channel %d: big input buffer %d", c->self, tmp);
#line 1075
          return (0);
        }
      }
#line 1077
      tmp___2 = buffer_len(& c->output);
#line 1077
      if (tmp___2 > (unsigned int )max_packet_size) {
#line 1078
        tmp___1 = buffer_len(& c->output);
#line 1078
        debug("channel %d: big output buffer %d", c->self, tmp___1);
#line 1080
        return (0);
      }
    }
#line 1069
    i ++;
  }
#line 1084
  return (1);
}
}
#line 1087 "channels.c"
void channel_input_ieof(int type , int plen ) 
{ int id ;
  Channel *c ;
  int _p ;
  int _e ;
  unsigned int tmp ;

  {
#line 1093
  while (1) {
#line 1093
    _p = plen;
#line 1093
    _e = 4;
#line 1093
    if (_p != _e) {
#line 1093
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1093);
#line 1093
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 1093
    break;
  }
#line 1095
  tmp = packet_get_int();
#line 1095
  id = (int )tmp;
#line 1096
  c = channel_lookup(id);
#line 1097
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1098
    packet_disconnect("Received ieof for nonexistent channel %d.", id);
  }
#line 1099
  (*chan_rcvd_ieof)(c);
#line 1100
  return;
}
}
#line 1102 "channels.c"
void channel_input_close(int type , int plen ) 
{ int id ;
  Channel *c ;
  int _p ;
  int _e ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 1108
  while (1) {
#line 1108
    _p = plen;
#line 1108
    _e = 4;
#line 1108
    if (_p != _e) {
#line 1108
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1108);
#line 1108
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 1108
    break;
  }
#line 1110
  tmp = packet_get_int();
#line 1110
  id = (int )tmp;
#line 1111
  c = channel_lookup(id);
#line 1112
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1113
    packet_disconnect("Received close for nonexistent channel %d.", id);
  }
#line 1119
  packet_start(25);
#line 1120
  packet_put_int((unsigned int )c->remote_id);
#line 1121
  packet_send();
#line 1130
  if (c->type != 5) {
#line 1135
    tmp___0 = buffer_len(& c->input);
#line 1135
    buffer_consume(& c->input, tmp___0);
#line 1136
    c->type = 9;
  }
#line 1138
  return;
}
}
#line 1141 "channels.c"
void channel_input_oclose(int type , int plen ) 
{ int id ;
  unsigned int tmp ;
  Channel *c ;
  Channel *tmp___0 ;
  int _p ;
  int _e ;

  {
#line 1144
  tmp = packet_get_int();
#line 1144
  id = (int )tmp;
#line 1145
  tmp___0 = channel_lookup(id);
#line 1145
  c = tmp___0;
#line 1146
  while (1) {
#line 1146
    _p = plen;
#line 1146
    _e = 4;
#line 1146
    if (_p != _e) {
#line 1146
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1146);
#line 1146
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 1146
    break;
  }
#line 1147
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1148
    packet_disconnect("Received oclose for nonexistent channel %d.", id);
  }
#line 1149
  (*chan_rcvd_oclose)(c);
#line 1150
  return;
}
}
#line 1152 "channels.c"
void channel_input_close_confirmation(int type , int plen ) 
{ int id ;
  unsigned int tmp ;
  Channel *c ;
  Channel *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1155
  tmp = packet_get_int();
#line 1155
  id = (int )tmp;
#line 1156
  tmp___0 = channel_lookup(id);
#line 1156
  c = tmp___0;
#line 1158
  while (1) {
#line 1158
    tmp___1 = packet_remaining();
#line 1158
    _len = tmp___1;
#line 1158
    if (_len > 0) {
#line 1158
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1158);
#line 1158
      packet_disconnect("Packet integrity error.");
    }
#line 1158
    break;
  }
#line 1159
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1160
    packet_disconnect("Received close confirmation for out-of-range channel %d.",
                      id);
  }
#line 1162
  if (c->type != 5) {
#line 1163
    packet_disconnect("Received close confirmation for non-closed channel %d (type %d).",
                      id, c->type);
  }
#line 1165
  channel_free(c->self);
#line 1166
  return;
}
}
#line 1168 "channels.c"
void channel_input_open_confirmation(int type , int plen ) 
{ int id ;
  int remote_id ;
  Channel *c ;
  int _p ;
  int _e ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 1174
  if (! compat20) {
#line 1175
    while (1) {
#line 1175
      _p = plen;
#line 1175
      _e = 8;
#line 1175
      if (_p != _e) {
#line 1175
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1175);
#line 1175
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1175
      break;
    }
  }
#line 1177
  tmp = packet_get_int();
#line 1177
  id = (int )tmp;
#line 1178
  c = channel_lookup(id);
#line 1180
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1181
    packet_disconnect("Received open confirmation for non-opening channel %d.", id);
  } else {
#line 1180
    if (c->type != 3) {
#line 1181
      packet_disconnect("Received open confirmation for non-opening channel %d.",
                        id);
    }
  }
#line 1183
  tmp___0 = packet_get_int();
#line 1183
  remote_id = (int )tmp___0;
#line 1185
  c->remote_id = remote_id;
#line 1186
  c->type = 4;
#line 1188
  if (compat20) {
#line 1189
    tmp___1 = packet_get_int();
#line 1189
    c->remote_window = (int )tmp___1;
#line 1190
    tmp___2 = packet_get_int();
#line 1190
    c->remote_maxpacket = (int )tmp___2;
#line 1191
    while (1) {
#line 1191
      tmp___3 = packet_remaining();
#line 1191
      _len = tmp___3;
#line 1191
      if (_len > 0) {
#line 1191
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            1191);
#line 1191
        packet_disconnect("Packet integrity error.");
      }
#line 1191
      break;
    }
#line 1192
    if ((unsigned int )c->cb_fn != (unsigned int )((void *)0)) {
#line 1192
      if (c->cb_event == type) {
#line 1193
        debug("callback start");
#line 1194
        (*(c->cb_fn))(c->self, c->cb_arg);
#line 1195
        debug("callback done");
      }
    }
#line 1197
    debug("channel %d: open confirm rwindow %d rmax %d", c->self, c->remote_window,
          c->remote_maxpacket);
  }
#line 1200
  return;
}
}
#line 1202 "channels.c"
void channel_input_open_failure(int type , int plen ) 
{ int id ;
  Channel *c ;
  int _p ;
  int _e ;
  unsigned int tmp ;
  int reason ;
  unsigned int tmp___0 ;
  char *msg ;
  char *tmp___1 ;
  char *lang ;
  char *tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 1208
  if (! compat20) {
#line 1209
    while (1) {
#line 1209
      _p = plen;
#line 1209
      _e = 4;
#line 1209
      if (_p != _e) {
#line 1209
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1209);
#line 1209
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1209
      break;
    }
  }
#line 1211
  tmp = packet_get_int();
#line 1211
  id = (int )tmp;
#line 1212
  c = channel_lookup(id);
#line 1214
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1215
    packet_disconnect("Received open failure for non-opening channel %d.", id);
  } else {
#line 1214
    if (c->type != 3) {
#line 1215
      packet_disconnect("Received open failure for non-opening channel %d.", id);
    }
  }
#line 1217
  if (compat20) {
#line 1218
    tmp___0 = packet_get_int();
#line 1218
    reason = (int )tmp___0;
#line 1219
    tmp___1 = packet_get_string((unsigned int *)((void *)0));
#line 1219
    msg = tmp___1;
#line 1220
    tmp___2 = packet_get_string((unsigned int *)((void *)0));
#line 1220
    lang = tmp___2;
#line 1221
    log("channel_open_failure: %d: reason %d: %s", id, reason, msg);
#line 1222
    while (1) {
#line 1222
      tmp___3 = packet_remaining();
#line 1222
      _len = tmp___3;
#line 1222
      if (_len > 0) {
#line 1222
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            1222);
#line 1222
        packet_disconnect("Packet integrity error.");
      }
#line 1222
      break;
    }
#line 1223
    xfree((void *)msg);
#line 1224
    xfree((void *)lang);
  }
#line 1227
  channel_free(id);
#line 1228
  return;
}
}
#line 1230 "channels.c"
void channel_input_channel_request(int type , int plen ) 
{ int id ;
  Channel *c ;
  unsigned int tmp ;
  char *service ;
  char *tmp___0 ;

  {
#line 1236
  tmp = packet_get_int();
#line 1236
  id = (int )tmp;
#line 1237
  c = channel_lookup(id);
#line 1239
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1241
    packet_disconnect("Received request for non-open channel %d.", id);
  } else {
#line 1239
    if (c->type != 4) {
#line 1239
      if (c->type != 10) {
#line 1241
        packet_disconnect("Received request for non-open channel %d.", id);
      }
    }
  }
#line 1243
  if ((unsigned int )c->cb_fn != (unsigned int )((void *)0)) {
#line 1243
    if (c->cb_event == type) {
#line 1244
      debug("callback start");
#line 1245
      (*(c->cb_fn))(c->self, c->cb_arg);
#line 1246
      debug("callback done");
    } else {
#line 1248
      tmp___0 = packet_get_string((unsigned int *)((void *)0));
#line 1248
      service = tmp___0;
#line 1249
      debug("channel: %d rcvd request for %s", c->self, service);
#line 1250
      debug("cb_fn %p cb_event %d", c->cb_fn, c->cb_event);
#line 1251
      xfree((void *)service);
    }
  } else {
#line 1248
    tmp___0 = packet_get_string((unsigned int *)((void *)0));
#line 1248
    service = tmp___0;
#line 1249
    debug("channel: %d rcvd request for %s", c->self, service);
#line 1250
    debug("cb_fn %p cb_event %d", c->cb_fn, c->cb_event);
#line 1251
    xfree((void *)service);
  }
#line 1253
  return;
}
}
#line 1255 "channels.c"
void channel_input_window_adjust(int type , int plen ) 
{ Channel *c ;
  int id ;
  int adjust ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1261
  if (! compat20) {
#line 1262
    return;
  }
#line 1265
  tmp = packet_get_int();
#line 1265
  id = (int )tmp;
#line 1266
  c = channel_lookup(id);
#line 1268
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1269
    log("Received window adjust for non-open channel %d.", id);
#line 1271
    return;
  } else {
#line 1268
    if (c->type != 4) {
#line 1269
      log("Received window adjust for non-open channel %d.", id);
#line 1271
      return;
    }
  }
#line 1273
  tmp___0 = packet_get_int();
#line 1273
  adjust = (int )tmp___0;
#line 1274
  while (1) {
#line 1274
    tmp___1 = packet_remaining();
#line 1274
    _len = tmp___1;
#line 1274
    if (_len > 0) {
#line 1274
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1274);
#line 1274
      packet_disconnect("Packet integrity error.");
    }
#line 1274
    break;
  }
#line 1275
  debug("channel %d: rcvd adjust %d", id, adjust);
#line 1276
  c->remote_window += adjust;
#line 1277
  return;
}
}
#line 1284 "channels.c"
void channel_stop_listening(void) 
{ int i ;

  {
#line 1288
  i = 0;
#line 1288
  while (i < channels_alloc) {
#line 1289
    switch ((channels + i)->type) {
    case 6: 
#line 1291
    close((channels + i)->sock);
#line 1292
    remove((char const   *)((channels + i)->path));
#line 1293
    channel_free(i);
#line 1294
    break;
    case 2: 
    case 1: 
#line 1297
    close((channels + i)->sock);
#line 1298
    channel_free(i);
#line 1299
    break;
    default: ;
#line 1301
    break;
    }
#line 1288
    i ++;
  }
#line 1304
  return;
}
}
#line 1311 "channels.c"
void channel_close_all(void) 
{ int i ;

  {
#line 1315
  i = 0;
#line 1315
  while (i < channels_alloc) {
#line 1316
    if ((channels + i)->type != 0) {
#line 1317
      channel_close_fds(channels + i);
    }
#line 1315
    i ++;
  }
#line 1318
  return;
}
}
#line 1322 "channels.c"
int channel_max_fd(void) 
{ 

  {
#line 1325
  return (channel_max_fd_value);
}
}
#line 1330 "channels.c"
int channel_still_open(void) 
{ unsigned int i ;

  {
#line 1334
  i = 0U;
#line 1334
  while (i < (unsigned int )channels_alloc) {
#line 1335
    switch ((channels + i)->type) {
    case 0: 
    case 1: 
    case 2: 
    case 5: 
    case 6: 
    goto __Cont;
    case 10: 
#line 1343
    if (! compat20) {
#line 1344
      fatal("cannot happen: SSH_CHANNEL_LARVAL");
    }
    goto __Cont;
    case 3: 
    case 4: 
    case 7: 
#line 1349
    return (1);
    case 8: 
    case 9: 
#line 1352
    if (! compat13) {
#line 1353
      fatal("cannot happen: OUT_DRAIN");
    }
#line 1354
    return (1);
    default: 
#line 1356
    fatal("channel_still_open: bad channel type %d", (channels + i)->type);
    }
    __Cont: /* CIL Label */ 
#line 1334
    i ++;
  }
#line 1359
  return (0);
}
}
#line 1368 "channels.c"
char *channel_open_message(void) 
{ Buffer buffer ;
  int i ;
  char buf___1[512] ;
  char *cp ;
  size_t tmp ;
  Channel *c ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;

  {
#line 1375
  buffer_init(& buffer);
#line 1376
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"The following connections are open:\r\n");
#line 1377
  tmp = strlen((char const   *)(buf___1));
#line 1377
  buffer_append(& buffer, (char const   *)(buf___1), tmp);
#line 1378
  i = 0;
#line 1378
  while (i < channels_alloc) {
#line 1379
    c = channels + i;
#line 1380
    switch (c->type) {
    case 0: 
    case 1: 
    case 2: 
    case 5: 
    case 6: 
    goto __Cont;
    case 10: 
    case 3: 
    case 4: 
    case 7: 
    case 8: 
    case 9: 
#line 1393
    tmp___0 = buffer_len(& c->output);
#line 1393
    tmp___1 = buffer_len(& c->input);
#line 1393
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"  #%d %.300s (t%d r%d i%d/%d o%d/%d fd %d/%d)\r\n",
             c->self, c->remote_name, c->type, c->remote_id, c->istate, tmp___1, c->ostate,
             tmp___0, c->rfd, c->wfd);
#line 1399
    tmp___2 = strlen((char const   *)(buf___1));
#line 1399
    buffer_append(& buffer, (char const   *)(buf___1), tmp___2);
    goto __Cont;
    default: 
#line 1402
    fatal("channel_open_message: bad channel type %d", c->type);
    }
    __Cont: /* CIL Label */ 
#line 1378
    i ++;
  }
#line 1406
  buffer_append(& buffer, "\000", 1U);
#line 1407
  tmp___3 = buffer_ptr(& buffer);
#line 1407
  cp = xstrdup((char const   *)tmp___3);
#line 1408
  buffer_free(& buffer);
#line 1409
  return (cp);
}
}
#line 1417 "channels.c"
void channel_request_local_forwarding(u_short port , char const   *host , u_short host_port ,
                                      int gateway_ports ) 
{ int success ;
  int ch ;
  int sock ;
  int on ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char ntop[1025] ;
  char strport[32] ;
  struct linger linger ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;

  {
#line 1421
  on = 1;
#line 1426
  tmp = strlen(host);
#line 1426
  if (tmp > sizeof((channels + 0)->path) - 1U) {
#line 1427
    packet_disconnect("Forward host name too long.");
  }
#line 1433
  memset((void *)(& hints), 0, sizeof(hints));
#line 1434
  hints.ai_family = IPv4or6;
#line 1435
  if (gateway_ports) {
#line 1435
    hints.ai_flags = 1;
  } else {
#line 1435
    hints.ai_flags = 0;
  }
#line 1436
  hints.ai_socktype = 1;
#line 1437
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           port);
#line 1438
  tmp___0 = getaddrinfo((char const   * __restrict  )((void *)0), (char const   * __restrict  )(strport),
                        (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 1438
  if (tmp___0 != 0) {
#line 1439
    packet_disconnect("getaddrinfo: fatal error");
  }
#line 1441
  success = 0;
#line 1442
  ai = aitop;
#line 1442
  while (ai) {
#line 1443
    if (ai->ai_family != 2) {
#line 1443
      if (ai->ai_family != 10) {
        goto __Cont;
      }
    }
#line 1445
    tmp___1 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                          (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )(strport),
                          sizeof(strport), 3U);
#line 1445
    if (tmp___1 != 0) {
#line 1447
      error("channel_request_local_forwarding: getnameinfo failed");
      goto __Cont;
    }
#line 1451
    sock = socket(ai->ai_family, 1, 0);
#line 1452
    if (sock < 0) {
#line 1454
      tmp___2 = __errno_location();
#line 1454
      tmp___3 = strerror(*tmp___2);
#line 1454
      verbose("socket: %.100s", tmp___3);
      goto __Cont;
    }
#line 1461
    setsockopt(sock, 1, 2, (void const   *)((void *)(& on)), sizeof(on));
#line 1462
    linger.l_onoff = 1;
#line 1463
    linger.l_linger = 5;
#line 1464
    setsockopt(sock, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 1465
    debug("Local forwarding listening on %s port %s.", ntop, strport);
#line 1468
    tmp___8 = bind(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 1468
    if (tmp___8 < 0) {
#line 1470
      if (! ai->ai_next) {
#line 1471
        tmp___4 = __errno_location();
#line 1471
        tmp___5 = strerror(*tmp___4);
#line 1471
        error("bind: %.100s", tmp___5);
      } else {
#line 1473
        tmp___6 = __errno_location();
#line 1473
        tmp___7 = strerror(*tmp___6);
#line 1473
        verbose("bind: %.100s", tmp___7);
      }
#line 1475
      close(sock);
      goto __Cont;
    }
#line 1479
    tmp___11 = listen(sock, 5);
#line 1479
    if (tmp___11 < 0) {
#line 1480
      tmp___9 = __errno_location();
#line 1480
      tmp___10 = strerror(*tmp___9);
#line 1480
      error("listen: %.100s", tmp___10);
#line 1481
      close(sock);
      goto __Cont;
    }
#line 1485
    tmp___12 = xstrdup("port listener");
#line 1485
    ch = channel_new((char *)"port listener", 2, sock, sock, -1, 8192, 4096, 0, tmp___12);
#line 1490
    strlcpy((channels + ch)->path, host, sizeof((channels + ch)->path));
#line 1491
    (channels + ch)->host_port = (int )host_port;
#line 1492
    (channels + ch)->listening_port = (int )port;
#line 1493
    success = 1;
    __Cont: /* CIL Label */ 
#line 1442
    ai = ai->ai_next;
  }
#line 1495
  if (success == 0) {
#line 1496
    packet_disconnect("cannot listen port: %d", port);
  }
#line 1497
  freeaddrinfo(aitop);
#line 1498
  return;
}
}
#line 1505 "channels.c"
void channel_request_remote_forwarding(u_short listen_port , char const   *host_to_connect ,
                                       u_short port_to_connect ) 
{ int payload_len ;
  char const   *address_to_bind ;

  {
#line 1511
  if (num_permitted_opens >= 100) {
#line 1512
    fatal("channel_request_remote_forwarding: too many forwards");
  }
#line 1514
  permitted_opens[num_permitted_opens].host_to_connect = xstrdup(host_to_connect);
#line 1515
  permitted_opens[num_permitted_opens].port_to_connect = port_to_connect;
#line 1516
  permitted_opens[num_permitted_opens].listen_port = listen_port;
#line 1517
  num_permitted_opens ++;
#line 1520
  if (compat20) {
#line 1521
    address_to_bind = "0.0.0.0";
#line 1522
    packet_start(80);
#line 1523
    packet_put_cstring("tcpip-forward");
#line 1524
    packet_put_char(0);
#line 1525
    packet_put_cstring(address_to_bind);
#line 1526
    packet_put_int((unsigned int )listen_port);
  } else {
#line 1528
    packet_start(28);
#line 1529
    packet_put_int((unsigned int )listen_port);
#line 1530
    packet_put_cstring(host_to_connect);
#line 1531
    packet_put_int((unsigned int )port_to_connect);
#line 1532
    packet_send();
#line 1533
    packet_write_wait();
#line 1538
    packet_read_expect(& payload_len, 14);
  }
#line 1540
  return;
}
}
#line 1548 "channels.c"
void channel_input_port_forward_request(int is_root , int gateway_ports ) 
{ u_short port ;
  u_short host_port ;
  char *hostname ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 1555
  tmp = packet_get_int();
#line 1555
  port = (unsigned short )tmp;
#line 1556
  hostname = packet_get_string((unsigned int *)((void *)0));
#line 1557
  tmp___0 = packet_get_int();
#line 1557
  host_port = (unsigned short )tmp___0;
#line 1563
  if ((int )port < 1024) {
#line 1563
    if (! is_root) {
#line 1564
      packet_disconnect("Requested forwarding of port %d but user is not root.", port);
    }
  }
#line 1569
  channel_request_local_forwarding(port, (char const   *)hostname, host_port, gateway_ports);
#line 1572
  xfree((void *)hostname);
#line 1573
  return;
}
}
#line 1576 "channels.c"
int channel_connect_to(char const   *host , u_short host_port ) 
{ struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char ntop[1025] ;
  char strport[32] ;
  int gaierr ;
  int sock ;
  char const   *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 1582
  sock = -1;
#line 1584
  memset((void *)(& hints), 0, sizeof(hints));
#line 1585
  hints.ai_family = IPv4or6;
#line 1586
  hints.ai_socktype = 1;
#line 1587
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           host_port);
#line 1588
  gaierr = getaddrinfo((char const   * __restrict  )host, (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 1588
  if (gaierr != 0) {
#line 1589
    tmp = gai_strerror(gaierr);
#line 1589
    error("%.100s: unknown host (%s)", host, tmp);
#line 1590
    return (-1);
  }
#line 1592
  ai = aitop;
#line 1592
  while (ai) {
#line 1593
    if (ai->ai_family != 2) {
#line 1593
      if (ai->ai_family != 10) {
        goto __Cont;
      }
    }
#line 1595
    tmp___0 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                          (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )(strport),
                          sizeof(strport), 3U);
#line 1595
    if (tmp___0 != 0) {
#line 1597
      error("channel_connect_to: getnameinfo failed");
      goto __Cont;
    }
#line 1601
    sock = socket(ai->ai_family, 1, 0);
#line 1602
    if (sock < 0) {
#line 1603
      tmp___1 = __errno_location();
#line 1603
      tmp___2 = strerror(*tmp___1);
#line 1603
      error("socket: %.100s", tmp___2);
      goto __Cont;
    }
#line 1607
    tmp___5 = connect(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 1607
    if (tmp___5 < 0) {
#line 1608
      tmp___3 = __errno_location();
#line 1608
      tmp___4 = strerror(*tmp___3);
#line 1608
      error("connect %.100s port %s: %.100s", ntop, strport, tmp___4);
#line 1610
      close(sock);
      goto __Cont;
    }
#line 1613
    break;
    __Cont: /* CIL Label */ 
#line 1592
    ai = ai->ai_next;
  }
#line 1616
  freeaddrinfo(aitop);
#line 1617
  if (! ai) {
#line 1618
    error("connect %.100s port %d: failed.", host, host_port);
#line 1619
    return (-1);
  }
#line 1622
  return (sock);
}
}
#line 1631 "channels.c"
void channel_input_port_open(int type , int plen ) 
{ u_short host_port ;
  char *host ;
  char *originator_string ;
  int remote_channel ;
  int sock ;
  int newch ;
  int i ;
  int denied ;
  unsigned int host_len ;
  unsigned int originator_len ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int _p ;
  int _e ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 1636
  sock = -1;
#line 1640
  tmp = packet_get_int();
#line 1640
  remote_channel = (int )tmp;
#line 1643
  host = packet_get_string(& host_len);
#line 1646
  tmp___0 = packet_get_int();
#line 1646
  host_port = (unsigned short )tmp___0;
#line 1649
  if (have_hostname_in_open) {
#line 1650
    originator_string = packet_get_string(& originator_len);
#line 1651
    originator_len += 4U;
  } else {
#line 1653
    originator_string = xstrdup("unknown (remote did not supply name)");
#line 1654
    originator_len = 0U;
  }
#line 1657
  while (1) {
#line 1657
    _p = plen;
#line 1657
    _e = (int )(((8U + host_len) + 4U) + originator_len);
#line 1657
    if (_p != _e) {
#line 1657
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1658);
#line 1657
      packet_disconnect("Packet integrity error. (%d)", 29);
    }
#line 1657
    break;
  }
#line 1661
  denied = 0;
#line 1662
  if (! all_opens_permitted) {
#line 1664
    i = 0;
#line 1664
    while (i < num_permitted_opens) {
#line 1666
      if ((int )permitted_opens[i].port_to_connect == (int )host_port) {
#line 1666
        if (0) {
#line 1666
          __s1_len = strlen((char const   *)permitted_opens[i].host_to_connect);
#line 1666
          __s2_len = strlen((char const   *)host);
#line 1666
          if (! ((unsigned int )((void const   *)(permitted_opens[i].host_to_connect + 1)) - (unsigned int )((void const   *)permitted_opens[i].host_to_connect) == 1U)) {
            goto _L___0;
          } else {
#line 1666
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 1666
              if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
#line 1666
                tmp___10 = 1;
              } else {
#line 1666
                if (__s2_len >= 4U) {
#line 1666
                  tmp___10 = 1;
                } else {
#line 1666
                  tmp___10 = 0;
                }
              }
            } else {
#line 1666
              tmp___10 = 0;
            }
          }
#line 1666
          if (tmp___10) {
#line 1666
            tmp___6 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                       (char const   *)host);
          } else {
#line 1666
            tmp___9 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                       (char const   *)host);
#line 1666
            tmp___6 = tmp___9;
          }
        } else {
#line 1666
          tmp___9 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                     (char const   *)host);
#line 1666
          tmp___6 = tmp___9;
        }
#line 1666
        if (tmp___6 == 0) {
#line 1667
          break;
        }
      }
#line 1664
      i ++;
    }
#line 1670
    if (i >= num_permitted_opens) {
#line 1672
      log("Received request to connect to %.100s:%d, but the request was denied.",
          host, host_port);
#line 1674
      denied = 1;
    }
  }
#line 1677
  if (denied) {
#line 1677
    sock = -1;
  } else {
#line 1677
    sock = channel_connect_to((char const   *)host, host_port);
  }
#line 1678
  if (sock > 0) {
#line 1680
    newch = channel_allocate(4, sock, originator_string);
#line 1681
    (channels + newch)->remote_id = remote_channel;
#line 1683
    packet_start(21);
#line 1684
    packet_put_int((unsigned int )remote_channel);
#line 1685
    packet_put_int((unsigned int )newch);
#line 1686
    packet_send();
  } else {
#line 1688
    packet_start(22);
#line 1689
    packet_put_int((unsigned int )remote_channel);
#line 1690
    packet_send();
  }
#line 1692
  xfree((void *)host);
#line 1693
  return;
}
}
#line 1703 "channels.c"
char *x11_create_display_inet(int screen_number , int x11_display_offset ) 
{ int display_number ;
  int sock ;
  u_short port ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  int n___0 ;
  int num_socks ;
  int socks[10] ;
  char display[512] ;
  char hostname[64] ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;

  {
#line 1710
  num_socks = 0;
#line 1714
  display_number = x11_display_offset;
#line 1714
  while (display_number < 1000) {
#line 1717
    port = (unsigned short )(6000 + display_number);
#line 1718
    memset((void *)(& hints), 0, sizeof(hints));
#line 1719
    hints.ai_family = IPv4or6;
#line 1720
    hints.ai_flags = 1;
#line 1721
    hints.ai_socktype = 1;
#line 1722
    snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
             port);
#line 1723
    gaierr = getaddrinfo((char const   * __restrict  )((void *)0), (char const   * __restrict  )(strport),
                         (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 1723
    if (gaierr != 0) {
#line 1724
      tmp = gai_strerror(gaierr);
#line 1724
      error("getaddrinfo: %.100s", tmp);
#line 1725
      return ((char *)((void *)0));
    }
#line 1727
    ai = aitop;
#line 1727
    while (ai) {
#line 1728
      if (ai->ai_family != 2) {
#line 1728
        if (ai->ai_family != 10) {
          goto __Cont;
        }
      }
#line 1730
      sock = socket(ai->ai_family, 1, 0);
#line 1731
      if (sock < 0) {
#line 1732
        tmp___2 = __errno_location();
#line 1732
        if (*tmp___2 != 22) {
#line 1733
          tmp___0 = __errno_location();
#line 1733
          tmp___1 = strerror(*tmp___0);
#line 1733
          error("socket: %.100s", tmp___1);
#line 1734
          return ((char *)((void *)0));
        } else {
#line 1736
          debug("Socket family %d not supported [X11 disp create]", ai->ai_family);
          goto __Cont;
        }
      }
#line 1740
      tmp___5 = bind(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 1740
      if (tmp___5 < 0) {
#line 1741
        tmp___3 = __errno_location();
#line 1741
        tmp___4 = strerror(*tmp___3);
#line 1741
        debug("bind port %d: %.100s", port, tmp___4);
#line 1742
        shutdown(sock, 2);
#line 1743
        close(sock);
#line 1745
        if (ai->ai_next) {
          goto __Cont;
        }
#line 1748
        n___0 = 0;
#line 1748
        while (n___0 < num_socks) {
#line 1749
          shutdown(socks[n___0], 2);
#line 1750
          close(socks[n___0]);
#line 1748
          n___0 ++;
        }
#line 1752
        num_socks = 0;
#line 1753
        break;
      }
#line 1755
      tmp___6 = num_socks;
#line 1755
      num_socks ++;
#line 1755
      socks[tmp___6] = sock;
#line 1760
      break;
      __Cont: /* CIL Label */ 
#line 1727
      ai = ai->ai_next;
    }
#line 1763
    if (num_socks > 0) {
#line 1764
      break;
    }
#line 1714
    display_number ++;
  }
#line 1766
  if (display_number >= 1000) {
#line 1767
    error("Failed to allocate internet-domain X11 display socket.");
#line 1768
    return ((char *)((void *)0));
  }
#line 1771
  n___0 = 0;
#line 1771
  while (n___0 < num_socks) {
#line 1772
    sock = socks[n___0];
#line 1773
    tmp___9 = listen(sock, 5);
#line 1773
    if (tmp___9 < 0) {
#line 1774
      tmp___7 = __errno_location();
#line 1774
      tmp___8 = strerror(*tmp___7);
#line 1774
      error("listen: %.100s", tmp___8);
#line 1775
      shutdown(sock, 2);
#line 1776
      close(sock);
#line 1777
      return ((char *)((void *)0));
    }
#line 1771
    n___0 ++;
  }
#line 1783
  tmp___12 = gethostname(hostname, sizeof(hostname));
#line 1783
  if (tmp___12 < 0) {
#line 1784
    tmp___10 = __errno_location();
#line 1784
    tmp___11 = strerror(*tmp___10);
#line 1784
    fatal("gethostname: %.100s", tmp___11);
  }
#line 1821
  snprintf((char * __restrict  )(display), sizeof(display), (char const   * __restrict  )"%.400s:%d.%d",
           hostname, display_number, screen_number);
#line 1826
  n___0 = 0;
#line 1826
  while (n___0 < num_socks) {
#line 1827
    sock = socks[n___0];
#line 1828
    tmp___13 = xstrdup("X11 inet listener");
#line 1828
    channel_new((char *)"x11 listener", 1, sock, sock, -1, 4096, 2048, 0, tmp___13);
#line 1826
    n___0 ++;
  }
#line 1835
  tmp___14 = xstrdup((char const   *)(display));
#line 1835
  return (tmp___14);
}
}
#line 1846
static int connect_local_xsocket(unsigned int dnr ) ;
#line 1846 "channels.c"
static char const   * const  x_sockets[4]  = {      (char const   * const  )"/tmp/.X11-unix/X%u",      (char const   * const  )"/var/X/.X11-unix/X%u",      (char const   * const  )"/usr/spool/sockets/X11/%u",      (char const   * const  )((void *)0)};
#line 1842 "channels.c"
static int connect_local_xsocket(unsigned int dnr ) 
{ int sock ;
  struct sockaddr_un addr ;
  char const   * const  *path ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 1856
  path = x_sockets;
#line 1856
  while (*path) {
#line 1857
    sock = socket(1, 1, 0);
#line 1858
    if (sock < 0) {
#line 1859
      tmp = __errno_location();
#line 1859
      tmp___0 = strerror(*tmp);
#line 1859
      error("socket: %.100s", tmp___0);
    }
#line 1860
    memset((void *)(& addr), 0, sizeof(addr));
#line 1861
    addr.sun_family = (unsigned short)1;
#line 1862
    snprintf((char * __restrict  )(addr.sun_path), sizeof(addr.sun_path), (char const   * __restrict  )*path,
             dnr);
#line 1863
    tmp___1 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& addr)),
                      sizeof(addr));
#line 1863
    if (tmp___1 == 0) {
#line 1864
      return (sock);
    }
#line 1865
    close(sock);
#line 1856
    path ++;
  }
#line 1867
  tmp___2 = __errno_location();
#line 1867
  tmp___3 = strerror(*tmp___2);
#line 1867
  error("connect %.100s: %.100s", addr.sun_path, tmp___3);
#line 1868
  return (-1);
}
}
#line 1871 "channels.c"
int x11_connect_display(void) 
{ int display_number ;
  int sock ;
  char const   *display ;
  char buf___1[1024] ;
  char *cp ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___29 ;
  int tmp___30 ;
  char const   *tmp___31 ;
  int *tmp___32 ;
  char *tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  int *tmp___37 ;
  char *tmp___38 ;

  {
#line 1874
  sock = 0;
#line 1882
  tmp = getenv("DISPLAY");
#line 1882
  display = (char const   *)tmp;
#line 1883
  if (! display) {
#line 1884
    error("DISPLAY not set.");
#line 1885
    return (-1);
  }
#line 1896
  if (0) {
#line 1896
    if (0) {
#line 1896
      __s1_len___0 = strlen(display);
#line 1896
      __s2_len___0 = strlen("unix:");
#line 1896
      if (! ((unsigned int )((void const   *)(display + 1)) - (unsigned int )((void const   *)display) == 1U)) {
        goto _L___2;
      } else {
#line 1896
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 1896
          if (! ((unsigned int )((void const   *)("unix:" + 1)) - (unsigned int )((void const   *)"unix:") == 1U)) {
#line 1896
            tmp___25 = 1;
          } else {
#line 1896
            if (__s2_len___0 >= 4U) {
#line 1896
              tmp___25 = 1;
            } else {
#line 1896
              tmp___25 = 0;
            }
          }
        } else {
#line 1896
          tmp___25 = 0;
        }
      }
#line 1896
      if (tmp___25) {
#line 1896
        tmp___21 = __builtin_strcmp(display, "unix:");
      } else {
#line 1896
        tmp___24 = __builtin_strcmp(display, "unix:");
#line 1896
        tmp___21 = tmp___24;
      }
    } else {
#line 1896
      tmp___24 = __builtin_strcmp(display, "unix:");
#line 1896
      tmp___21 = tmp___24;
    }
#line 1896
    tmp___15 = tmp___21;
  } else {
#line 1896
    tmp___15 = strncmp(display, "unix:", 5U);
  }
#line 1896
  if (tmp___15 == 0) {
    goto _L___3;
  } else {
#line 1896
    if ((int const   )*(display + 0) == 58) {
      _L___3: /* CIL Label */ 
#line 1899
      tmp___0 = strrchr(display, ':');
#line 1899
      tmp___1 = sscanf((char const   * __restrict  )(tmp___0 + 1), (char const   * __restrict  )"%d",
                       & display_number);
#line 1899
      if (tmp___1 != 1) {
#line 1900
        error("Could not parse display number from DISPLAY: %.100s", display);
#line 1902
        return (-1);
      }
#line 1905
      sock = connect_local_xsocket((unsigned int )display_number);
#line 1906
      if (sock < 0) {
#line 1907
        return (-1);
      }
#line 1910
      return (sock);
    }
  }
#line 1916
  __builtin_strncpy(buf___1, display, sizeof(buf___1));
#line 1917
  buf___1[sizeof(buf___1) - 1U] = (char)0;
#line 1918
  tmp___29 = __builtin_strchr(buf___1, ':');
#line 1918
  cp = tmp___29;
#line 1919
  if (! cp) {
#line 1920
    error("Could not find \':\' in DISPLAY: %.100s", display);
#line 1921
    return (-1);
  }
#line 1923
  *cp = (char)0;
#line 1925
  tmp___30 = sscanf((char const   * __restrict  )(cp + 1), (char const   * __restrict  )"%d",
                    & display_number);
#line 1925
  if (tmp___30 != 1) {
#line 1926
    error("Could not parse display number from DISPLAY: %.100s", display);
#line 1928
    return (-1);
  }
#line 1932
  memset((void *)(& hints), 0, sizeof(hints));
#line 1933
  hints.ai_family = IPv4or6;
#line 1934
  hints.ai_socktype = 1;
#line 1935
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           6000 + display_number);
#line 1936
  gaierr = getaddrinfo((char const   * __restrict  )(buf___1), (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 1936
  if (gaierr != 0) {
#line 1937
    tmp___31 = gai_strerror(gaierr);
#line 1937
    error("%.100s: unknown host. (%s)", buf___1, tmp___31);
#line 1938
    return (-1);
  }
#line 1940
  ai = aitop;
#line 1940
  while (ai) {
#line 1942
    sock = socket(ai->ai_family, 1, 0);
#line 1943
    if (sock < 0) {
#line 1944
      tmp___32 = __errno_location();
#line 1944
      tmp___33 = strerror(*tmp___32);
#line 1944
      debug("socket: %.100s", tmp___33);
      goto __Cont;
    }
#line 1948
    tmp___36 = connect(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 1948
    if (tmp___36 < 0) {
#line 1949
      tmp___34 = __errno_location();
#line 1949
      tmp___35 = strerror(*tmp___34);
#line 1949
      debug("connect %.100s port %d: %.100s", buf___1, 6000 + display_number, tmp___35);
#line 1951
      close(sock);
      goto __Cont;
    }
#line 1955
    break;
    __Cont: /* CIL Label */ 
#line 1940
    ai = ai->ai_next;
  }
#line 1957
  freeaddrinfo(aitop);
#line 1958
  if (! ai) {
#line 1959
    tmp___37 = __errno_location();
#line 1959
    tmp___38 = strerror(*tmp___37);
#line 1959
    error("connect %.100s port %d: %.100s", buf___1, 6000 + display_number, tmp___38);
#line 1961
    return (-1);
  }
#line 1963
  return (sock);
}
}
#line 1972 "channels.c"
void x11_input_open(int type , int plen ) 
{ int remote_channel ;
  int sock ;
  int newch ;
  char *remote_host ;
  unsigned int remote_len ;
  unsigned int tmp ;
  int _p ;
  int _e ;
  int tmp___0 ;

  {
#line 1975
  sock = 0;
#line 1980
  tmp = packet_get_int();
#line 1980
  remote_channel = (int )tmp;
#line 1983
  if (have_hostname_in_open) {
#line 1984
    remote_host = packet_get_string(& remote_len);
#line 1985
    remote_len += 4U;
  } else {
#line 1987
    remote_host = xstrdup("unknown (remote did not supply name)");
#line 1988
    remote_len = 0U;
  }
#line 1991
  debug("Received X11 open request.");
#line 1992
  while (1) {
#line 1992
    _p = plen;
#line 1992
    _e = (int )(4U + remote_len);
#line 1992
    if (_p != _e) {
#line 1992
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1992);
#line 1992
      packet_disconnect("Packet integrity error. (%d)", 27);
    }
#line 1992
    break;
  }
#line 1995
  sock = x11_connect_display();
#line 1996
  if (sock == -1) {
#line 1998
    packet_start(22);
#line 1999
    packet_put_int((unsigned int )remote_channel);
#line 2000
    packet_send();
  } else {
#line 2003
    if ((unsigned int )x11_saved_proto == (unsigned int )((void *)0)) {
#line 2003
      tmp___0 = 4;
    } else {
#line 2003
      tmp___0 = 7;
    }
#line 2003
    newch = channel_allocate(tmp___0, sock, remote_host);
#line 2007
    (channels + newch)->remote_id = remote_channel;
#line 2010
    packet_start(21);
#line 2011
    packet_put_int((unsigned int )remote_channel);
#line 2012
    packet_put_int((unsigned int )newch);
#line 2013
    packet_send();
  }
#line 2015
  return;
}
}
#line 2022 "channels.c"
void x11_request_forwarding_with_spoofing(int client_session_id , char const   *proto ,
                                          char const   *data ) 
{ unsigned int data_len ;
  size_t tmp ;
  unsigned int i ;
  unsigned int value ;
  char *new_data ;
  int screen_number ;
  char const   *cp ;
  u_int32_t rand___0 ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;

  {
#line 2026
  tmp = strlen(data);
#line 2026
  data_len = tmp / 2U;
#line 2031
  rand___0 = (u_int32_t )0;
#line 2033
  tmp___0 = getenv("DISPLAY");
#line 2033
  cp = (char const   *)tmp___0;
#line 2034
  if (cp) {
#line 2035
    tmp___2 = __builtin_strchr((char *)cp, ':');
#line 2035
    cp = (char const   *)tmp___2;
  }
#line 2036
  if (cp) {
#line 2037
    tmp___4 = __builtin_strchr((char *)cp, '.');
#line 2037
    cp = (char const   *)tmp___4;
  }
#line 2038
  if (cp) {
#line 2039
    screen_number = atoi(cp + 1);
  } else {
#line 2041
    screen_number = 0;
  }
#line 2044
  x11_saved_proto = xstrdup(proto);
#line 2050
  tmp___5 = xmalloc(data_len);
#line 2050
  x11_saved_data = (char *)tmp___5;
#line 2051
  tmp___6 = xmalloc(data_len);
#line 2051
  x11_fake_data = (char *)tmp___6;
#line 2052
  i = 0U;
#line 2052
  while (i < data_len) {
#line 2053
    tmp___7 = sscanf((char const   * __restrict  )(data + 2U * i), (char const   * __restrict  )"%2x",
                     & value);
#line 2053
    if (tmp___7 != 1) {
#line 2054
      fatal("x11_request_forwarding: bad authentication data: %.100s", data);
    }
#line 2055
    if (i % 4U == 0U) {
#line 2056
      rand___0 = arc4random();
    }
#line 2057
    *(x11_saved_data + i) = (char )value;
#line 2058
    *(x11_fake_data + i) = (char )(rand___0 & 255U);
#line 2059
    rand___0 >>= 8;
#line 2052
    i ++;
  }
#line 2061
  x11_saved_data_len = data_len;
#line 2062
  x11_fake_data_len = data_len;
#line 2065
  tmp___8 = xmalloc(2U * data_len + 1U);
#line 2065
  new_data = (char *)tmp___8;
#line 2066
  i = 0U;
#line 2066
  while (i < data_len) {
#line 2067
    sprintf((char * __restrict  )(new_data + 2U * i), (char const   * __restrict  )"%02x",
            (unsigned char )*(x11_fake_data + i));
#line 2066
    i ++;
  }
#line 2070
  if (compat20) {
#line 2071
    channel_request_start(client_session_id, (char *)"x11-req", 0);
#line 2072
    packet_put_char(0);
  } else {
#line 2074
    packet_start(34);
  }
#line 2076
  packet_put_cstring(proto);
#line 2077
  packet_put_cstring((char const   *)new_data);
#line 2078
  packet_put_int((unsigned int )screen_number);
#line 2079
  packet_send();
#line 2080
  packet_write_wait();
#line 2081
  xfree((void *)new_data);
#line 2082
  return;
}
}
#line 2086 "channels.c"
void auth_request_forwarding(void) 
{ 

  {
#line 2089
  packet_start(30);
#line 2090
  packet_send();
#line 2091
  packet_write_wait();
#line 2092
  return;
}
}
#line 2100 "channels.c"
char *auth_get_socket_name(void) 
{ 

  {
#line 2103
  return (channel_forwarded_auth_socket_name);
}
}
#line 2108 "channels.c"
void cleanup_socket(void) 
{ 

  {
#line 2111
  remove((char const   *)channel_forwarded_auth_socket_name);
#line 2112
  rmdir((char const   *)channel_forwarded_auth_socket_dir);
#line 2113
  return;
}
}
#line 2120 "channels.c"
void auth_input_request_forwarding(struct passwd *pw ) 
{ int sock ;
  int newch ;
  struct sockaddr_un sunaddr ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  __pid_t tmp___5 ;
  int saved ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;

  {
#line 2126
  tmp = auth_get_socket_name();
#line 2126
  if ((unsigned int )tmp != (unsigned int )((void *)0)) {
#line 2127
    fatal("Protocol error: authentication forwarding requested twice.");
  }
#line 2130
  temporarily_use_uid(pw->pw_uid);
#line 2133
  tmp___0 = xmalloc(100U);
#line 2133
  channel_forwarded_auth_socket_name = (char *)tmp___0;
#line 2134
  tmp___1 = xmalloc(100U);
#line 2134
  channel_forwarded_auth_socket_dir = (char *)tmp___1;
#line 2135
  strlcpy(channel_forwarded_auth_socket_dir, "/tmp/ssh-XXXXXXXX", 100U);
#line 2138
  tmp___4 = mkdtemp(channel_forwarded_auth_socket_dir);
#line 2138
  if ((unsigned int )tmp___4 == (unsigned int )((void *)0)) {
#line 2139
    tmp___2 = __errno_location();
#line 2139
    tmp___3 = strerror(*tmp___2);
#line 2139
    packet_disconnect("mkdtemp: %.100s", tmp___3);
  }
#line 2140
  tmp___5 = getpid();
#line 2140
  snprintf((char * __restrict  )channel_forwarded_auth_socket_name, 100U, (char const   * __restrict  )"%s/agent.%d",
           channel_forwarded_auth_socket_dir, tmp___5);
#line 2143
  tmp___8 = atexit(& cleanup_socket);
#line 2143
  if (tmp___8 < 0) {
#line 2144
    tmp___6 = __errno_location();
#line 2144
    saved = *tmp___6;
#line 2145
    cleanup_socket();
#line 2146
    tmp___7 = strerror(saved);
#line 2146
    packet_disconnect("socket: %.100s", tmp___7);
  }
#line 2149
  sock = socket(1, 1, 0);
#line 2150
  if (sock < 0) {
#line 2151
    tmp___9 = __errno_location();
#line 2151
    tmp___10 = strerror(*tmp___9);
#line 2151
    packet_disconnect("socket: %.100s", tmp___10);
  }
#line 2154
  memset((void *)(& sunaddr), 0, sizeof(sunaddr));
#line 2155
  sunaddr.sun_family = (unsigned short)1;
#line 2156
  __builtin_strncpy(sunaddr.sun_path, (char const   *)channel_forwarded_auth_socket_name,
                    sizeof(sunaddr.sun_path));
#line 2159
  tmp___13 = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sunaddr)),
                  sizeof(sunaddr));
#line 2159
  if (tmp___13 < 0) {
#line 2160
    tmp___11 = __errno_location();
#line 2160
    tmp___12 = strerror(*tmp___11);
#line 2160
    packet_disconnect("bind: %.100s", tmp___12);
  }
#line 2163
  restore_uid();
#line 2166
  tmp___16 = listen(sock, 5);
#line 2166
  if (tmp___16 < 0) {
#line 2167
    tmp___14 = __errno_location();
#line 2167
    tmp___15 = strerror(*tmp___14);
#line 2167
    packet_disconnect("listen: %.100s", tmp___15);
  }
#line 2170
  tmp___17 = xstrdup("auth socket");
#line 2170
  newch = channel_allocate(6, sock, tmp___17);
#line 2172
  strlcpy((channels + newch)->path, (char const   *)channel_forwarded_auth_socket_name,
          sizeof((channels + newch)->path));
#line 2174
  return;
}
}
#line 2178 "channels.c"
void auth_input_open_request(int type , int plen ) 
{ int remch ;
  int sock ;
  int newch ;
  char *dummyname ;
  int _p ;
  int _e ;
  unsigned int tmp ;

  {
#line 2184
  while (1) {
#line 2184
    _p = plen;
#line 2184
    _e = 4;
#line 2184
    if (_p != _e) {
#line 2184
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 2184);
#line 2184
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 2184
    break;
  }
#line 2187
  tmp = packet_get_int();
#line 2187
  remch = (int )tmp;
#line 2193
  sock = ssh_get_authentication_socket();
#line 2201
  if (sock < 0) {
#line 2202
    packet_start(22);
#line 2203
    packet_put_int((unsigned int )remch);
#line 2204
    packet_send();
#line 2205
    return;
  }
#line 2207
  debug("Forwarding authentication connection.");
#line 2214
  dummyname = xstrdup("authentication agent connection");
#line 2216
  newch = channel_allocate(4, sock, dummyname);
#line 2217
  (channels + newch)->remote_id = remch;
#line 2220
  packet_start(21);
#line 2221
  packet_put_int((unsigned int )remch);
#line 2222
  packet_put_int((unsigned int )newch);
#line 2223
  packet_send();
#line 2224
  return;
}
}
#line 2226 "channels.c"
void channel_start_open(int id ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2229
  tmp = channel_lookup(id);
#line 2229
  c = tmp;
#line 2230
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2231
    log("channel_open: %d: bad id", id);
#line 2232
    return;
  }
#line 2234
  debug("send channel open %d", id);
#line 2235
  packet_start(90);
#line 2236
  packet_put_cstring((char const   *)c->ctype);
#line 2237
  packet_put_int((unsigned int )c->self);
#line 2238
  packet_put_int((unsigned int )c->local_window);
#line 2239
  packet_put_int((unsigned int )c->local_maxpacket);
#line 2240
  return;
}
}
#line 2241 "channels.c"
void channel_open(int id ) 
{ 

  {
#line 2245
  channel_start_open(id);
#line 2246
  packet_send();
#line 2247
  return;
}
}
#line 2248 "channels.c"
void channel_request(int id , char *service , int wantconfirm ) 
{ 

  {
#line 2251
  channel_request_start(id, service, wantconfirm);
#line 2252
  packet_send();
#line 2253
  debug("channel request %d: %s", id, service);
#line 2254
  return;
}
}
#line 2255 "channels.c"
void channel_request_start(int id , char *service , int wantconfirm ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2258
  tmp = channel_lookup(id);
#line 2258
  c = tmp;
#line 2259
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2260
    log("channel_request: %d: bad id", id);
#line 2261
    return;
  }
#line 2263
  packet_start(98);
#line 2264
  packet_put_int((unsigned int )c->remote_id);
#line 2265
  packet_put_cstring((char const   *)service);
#line 2266
  packet_put_char(wantconfirm);
#line 2267
  return;
}
}
#line 2268 "channels.c"
void channel_register_callback(int id , int mtype , channel_callback_fn *fn , void *arg ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2271
  tmp = channel_lookup(id);
#line 2271
  c = tmp;
#line 2272
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2273
    log("channel_register_callback: %d: bad id", id);
#line 2274
    return;
  }
#line 2276
  c->cb_event = mtype;
#line 2277
  c->cb_fn = fn;
#line 2278
  c->cb_arg = arg;
#line 2279
  return;
}
}
#line 2280 "channels.c"
void channel_register_cleanup(int id , channel_callback_fn *fn ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2283
  tmp = channel_lookup(id);
#line 2283
  c = tmp;
#line 2284
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2285
    log("channel_register_cleanup: %d: bad id", id);
#line 2286
    return;
  }
#line 2288
  c->dettach_user = fn;
#line 2289
  return;
}
}
#line 2290 "channels.c"
void channel_cancel_cleanup(int id ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2293
  tmp = channel_lookup(id);
#line 2293
  c = tmp;
#line 2294
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2295
    log("channel_cancel_cleanup: %d: bad id", id);
#line 2296
    return;
  }
#line 2298
  c->dettach_user = (channel_callback_fn *)((void *)0);
#line 2299
  return;
}
}
#line 2301 "channels.c"
void channel_set_fds(int id , int rfd , int wfd , int efd , int extusage ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2304
  tmp = channel_lookup(id);
#line 2304
  c = tmp;
#line 2305
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2306
    fatal("channel_activate for non-larval channel %d.", id);
  } else {
#line 2305
    if (c->type != 10) {
#line 2306
      fatal("channel_activate for non-larval channel %d.", id);
    }
  }
#line 2308
  channel_register_fds(c, rfd, wfd, efd, extusage);
#line 2309
  c->type = 4;
#line 2311
  c->local_window_max = c->local_maxpacket / 2;
#line 2311
  c->local_window = c->local_window_max;
#line 2312
  packet_start(93);
#line 2313
  packet_put_int((unsigned int )c->remote_id);
#line 2314
  packet_put_int((unsigned int )c->local_window);
#line 2315
  packet_send();
#line 2316
  return;
}
}
#line 1 "cipher.o"
#pragma merger(0,"./cipher.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 199 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strtok(char * __restrict  __s , char const   * __restrict  __delim )  __attribute__((__nonnull__(2))) ;
#line 138 "/usr/include/openssl/des.h"
extern void DES_cbc_encrypt(unsigned char const   *input , unsigned char *output ,
                            long length , DES_key_schedule *schedule , DES_cblock *ivec ,
                            int enc ) ;
#line 176
extern void DES_ede3_cbc_encrypt(unsigned char const   *input , unsigned char *output ,
                                 long length , DES_key_schedule *ks1 , DES_key_schedule *ks2 ,
                                 DES_key_schedule *ks3 , DES_cblock *ivec , int enc ) ;
#line 222
extern int DES_set_key(const_DES_cblock *key , DES_key_schedule *schedule ) ;
#line 108 "/usr/include/openssl/blowfish.h"
extern void BF_set_key(BF_KEY *key , int len , unsigned char const   *data ) ;
#line 115
extern void BF_cbc_encrypt(unsigned char const   *in , unsigned char *out , long length ,
                           BF_KEY const   *schedule , unsigned char *ivec , int enc ) ;
#line 79 "/usr/include/openssl/rc4.h"
extern void RC4_set_key(RC4_KEY *key , int len , unsigned char const   *data ) ;
#line 80
extern void RC4(RC4_KEY *key , unsigned long len , unsigned char const   *indata ,
                unsigned char *outdata ) ;
#line 87 "/usr/include/openssl/cast.h"
extern void CAST_set_key(CAST_KEY *key , int len , unsigned char const   *data ) ;
#line 92
extern void CAST_cbc_encrypt(unsigned char const   *in , unsigned char *out , long length ,
                             CAST_KEY *ks , unsigned char *iv , int enc ) ;
#line 69 "cipher.h"
unsigned int cipher_mask(void) ;
#line 71
unsigned int cipher_mask2(void) ;
#line 80
int cipher_number(char const   *name ) ;
#line 83
int ciphers_valid(char const   *names ) ;
#line 89
void cipher_set_key(CipherContext *context , int cipher , unsigned char const   *key ,
                    int keylen ) ;
#line 92
void cipher_set_key_iv(CipherContext *context , int cipher , unsigned char const   *key ,
                       int keylen , unsigned char const   *iv , int ivlen ) ;
#line 107 "/usr/include/openssl/md5.h"
extern int MD5_Init(MD5_CTX *c ) ;
#line 108
extern int MD5_Update(MD5_CTX *c , void const   *data , size_t len ) ;
#line 109
extern int MD5_Final(unsigned char *md , MD5_CTX *c ) ;
#line 37 "cipher.c"
void SSH_3CBC_ENCRYPT(DES_key_schedule ks1 , DES_key_schedule ks2 , DES_cblock *iv2 ,
                      DES_key_schedule ks3 , DES_cblock *iv3 , unsigned char *dest ,
                      unsigned char *src , unsigned int len ) 
{ DES_cblock iv1 ;

  {
#line 46
  memcpy((void * __restrict  )(& iv1), (void const   * __restrict  )iv2, 8U);
#line 48
  DES_cbc_encrypt((unsigned char const   *)src, dest, (long )len, & ks1, & iv1, 1);
#line 49
  memcpy((void * __restrict  )(& iv1), (void const   * __restrict  )((dest + len) - 8),
         8U);
#line 51
  DES_cbc_encrypt((unsigned char const   *)dest, dest, (long )len, & ks2, iv2, 0);
#line 52
  memcpy((void * __restrict  )iv2, (void const   * __restrict  )(& iv1), 8U);
#line 54
  DES_cbc_encrypt((unsigned char const   *)dest, dest, (long )len, & ks3, iv3, 1);
#line 55
  memcpy((void * __restrict  )iv3, (void const   * __restrict  )((dest + len) - 8),
         8U);
#line 56
  return;
}
}
#line 58 "cipher.c"
void SSH_3CBC_DECRYPT(DES_key_schedule ks1 , DES_key_schedule ks2 , DES_cblock *iv2 ,
                      DES_key_schedule ks3 , DES_cblock *iv3 , unsigned char *dest ,
                      unsigned char *src , unsigned int len ) 
{ DES_cblock iv1 ;

  {
#line 67
  memcpy((void * __restrict  )(& iv1), (void const   * __restrict  )iv2, 8U);
#line 69
  DES_cbc_encrypt((unsigned char const   *)src, dest, (long )len, & ks3, iv3, 0);
#line 70
  memcpy((void * __restrict  )iv3, (void const   * __restrict  )((src + len) - 8),
         8U);
#line 72
  DES_cbc_encrypt((unsigned char const   *)dest, dest, (long )len, & ks2, iv2, 1);
#line 73
  memcpy((void * __restrict  )iv2, (void const   * __restrict  )((dest + len) - 8),
         8U);
#line 75
  DES_cbc_encrypt((unsigned char const   *)dest, dest, (long )len, & ks1, & iv1, 0);
#line 78
  return;
}
}
#line 84 "cipher.c"
static void swap_bytes(unsigned char const   *src , unsigned char *dst_ , int n___0 ) 
{ u_int32_t *dst ;
  union __anonunion_t_74 t ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  u_int32_t *tmp___3 ;
  unsigned char const   *tmp___4 ;
  unsigned char const   *tmp___5 ;
  unsigned char const   *tmp___6 ;
  unsigned char const   *tmp___7 ;
  u_int32_t *tmp___8 ;

  {
#line 88
  dst = (u_int32_t *)dst_;
#line 95
  n___0 /= 8;
#line 95
  while (n___0 > 0) {
#line 96
    tmp = src;
#line 96
    src ++;
#line 96
    t.c[3] = (char )*tmp;
#line 97
    tmp___0 = src;
#line 97
    src ++;
#line 97
    t.c[2] = (char )*tmp___0;
#line 98
    tmp___1 = src;
#line 98
    src ++;
#line 98
    t.c[1] = (char )*tmp___1;
#line 99
    tmp___2 = src;
#line 99
    src ++;
#line 99
    t.c[0] = (char )*tmp___2;
#line 100
    tmp___3 = dst;
#line 100
    dst ++;
#line 100
    *tmp___3 = t.i;
#line 102
    tmp___4 = src;
#line 102
    src ++;
#line 102
    t.c[3] = (char )*tmp___4;
#line 103
    tmp___5 = src;
#line 103
    src ++;
#line 103
    t.c[2] = (char )*tmp___5;
#line 104
    tmp___6 = src;
#line 104
    src ++;
#line 104
    t.c[1] = (char )*tmp___6;
#line 105
    tmp___7 = src;
#line 105
    src ++;
#line 105
    t.c[0] = (char )*tmp___7;
#line 106
    tmp___8 = dst;
#line 106
    dst ++;
#line 106
    *tmp___8 = t.i;
#line 95
    n___0 --;
  }
#line 108
  return;
}
}
#line 114 "cipher.c"
static char *cipher_names[12]  = 
#line 114
  {      (char *)"none",      (char *)"idea",      (char *)"des",      (char *)"3des", 
        (char *)"tss",      (char *)"rc4",      (char *)"blowfish",      (char *)"reserved", 
        (char *)"blowfish-cbc",      (char *)"3des-cbc",      (char *)"arcfour",      (char *)"cast128-cbc"};
#line 136 "cipher.c"
unsigned int cipher_mask1(void) 
{ unsigned int mask ;

  {
#line 139
  mask = 0U;
#line 140
  mask |= (unsigned int )(1 << 3);
#line 141
  mask |= (unsigned int )(1 << 6);
#line 142
  return (mask);
}
}
#line 144 "cipher.c"
unsigned int cipher_mask2(void) 
{ unsigned int mask ;

  {
#line 147
  mask = 0U;
#line 148
  mask |= (unsigned int )(1 << 8);
#line 149
  mask |= (unsigned int )(1 << 9);
#line 150
  mask |= (unsigned int )(1 << 10);
#line 151
  mask |= (unsigned int )(1 << 11);
#line 152
  return (mask);
}
}
#line 154 "cipher.c"
unsigned int cipher_mask(void) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 157
  tmp = cipher_mask1();
#line 157
  tmp___0 = cipher_mask2();
#line 157
  return (tmp | tmp___0);
}
}
#line 162 "cipher.c"
char const   *cipher_name(int cipher ) 
{ 

  {
#line 165
  if (cipher < 0) {
#line 167
    fatal("cipher_name: bad cipher name: %d", cipher);
  } else {
#line 165
    if ((unsigned int )cipher >= sizeof(cipher_names) / sizeof(cipher_names[0])) {
#line 167
      fatal("cipher_name: bad cipher name: %d", cipher);
    } else {
#line 165
      if ((unsigned int )cipher_names[cipher] == (unsigned int )((void *)0)) {
#line 167
        fatal("cipher_name: bad cipher name: %d", cipher);
      }
    }
  }
#line 168
  return ((char const   *)cipher_names[cipher]);
}
}
#line 174 "cipher.c"
int ciphers_valid(char const   *names ) 
{ char *ciphers ;
  char *p ;
  int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 181
  if ((unsigned int )names == (unsigned int )((void *)0)) {
#line 182
    return (0);
  } else {
#line 181
    if (0) {
#line 181
      __s1_len = strlen(names);
#line 181
      __s2_len = strlen("");
#line 181
      if (! ((unsigned int )((void const   *)(names + 1)) - (unsigned int )((void const   *)names) == 1U)) {
        goto _L___0;
      } else {
#line 181
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 181
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 181
            tmp___8 = 1;
          } else {
#line 181
            if (__s2_len >= 4U) {
#line 181
              tmp___8 = 1;
            } else {
#line 181
              tmp___8 = 0;
            }
          }
        } else {
#line 181
          tmp___8 = 0;
        }
      }
#line 181
      if (tmp___8) {
#line 181
        tmp___4 = __builtin_strcmp(names, "");
      } else {
#line 181
        tmp___7 = __builtin_strcmp(names, "");
#line 181
        tmp___4 = tmp___7;
      }
    } else {
#line 181
      tmp___7 = __builtin_strcmp(names, "");
#line 181
      tmp___4 = tmp___7;
    }
#line 181
    if (tmp___4 == 0) {
#line 182
      return (0);
    }
  }
#line 183
  ciphers = xstrdup(names);
#line 184
  p = strtok((char * __restrict  )ciphers, (char const   * __restrict  )",");
#line 184
  while (p) {
#line 185
    i = cipher_number((char const   *)p);
#line 186
    if (i == -1) {
#line 187
      xfree((void *)ciphers);
#line 188
      return (0);
    } else {
#line 186
      tmp___9 = cipher_mask2();
#line 186
      if (! (tmp___9 & (unsigned int )(1 << i))) {
#line 187
        xfree((void *)ciphers);
#line 188
        return (0);
      }
    }
#line 184
    p = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )",");
  }
#line 191
  xfree((void *)ciphers);
#line 192
  return (1);
}
}
#line 200 "cipher.c"
int cipher_number(char const   *name ) 
{ int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 204
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 205
    return (-1);
  }
#line 206
  i = 0;
#line 206
  while ((unsigned int )i < sizeof(cipher_names) / sizeof(cipher_names[0])) {
#line 207
    if (0) {
#line 207
      __s1_len = strlen((char const   *)cipher_names[i]);
#line 207
      __s2_len = strlen(name);
#line 207
      if (! ((unsigned int )((void const   *)(cipher_names[i] + 1)) - (unsigned int )((void const   *)cipher_names[i]) == 1U)) {
        goto _L___0;
      } else {
#line 207
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 207
          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
#line 207
            tmp___8 = 1;
          } else {
#line 207
            if (__s2_len >= 4U) {
#line 207
              tmp___8 = 1;
            } else {
#line 207
              tmp___8 = 0;
            }
          }
        } else {
#line 207
          tmp___8 = 0;
        }
      }
#line 207
      if (tmp___8) {
#line 207
        tmp___4 = __builtin_strcmp((char const   *)cipher_names[i], name);
      } else {
#line 207
        tmp___7 = __builtin_strcmp((char const   *)cipher_names[i], name);
#line 207
        tmp___4 = tmp___7;
      }
    } else {
#line 207
      tmp___7 = __builtin_strcmp((char const   *)cipher_names[i], name);
#line 207
      tmp___4 = tmp___7;
    }
#line 207
    if (tmp___4 == 0) {
#line 207
      tmp___9 = cipher_mask();
#line 207
      if (tmp___9 & (unsigned int )(1 << i)) {
#line 209
        return (i);
      }
    }
#line 206
    i ++;
  }
#line 210
  return (-1);
}
}
#line 218 "cipher.c"
void cipher_set_key_string(CipherContext *context , int cipher , char const   *passphrase ) 
{ MD5_CTX md ;
  unsigned char digest___0[16] ;
  size_t tmp ;

  {
#line 224
  MD5_Init(& md);
#line 225
  tmp = strlen(passphrase);
#line 225
  MD5_Update(& md, (void const   *)((unsigned char const   *)passphrase), tmp);
#line 226
  MD5_Final(digest___0, & md);
#line 228
  cipher_set_key(context, cipher, (unsigned char const   *)(digest___0), 16);
#line 230
  memset((void *)(digest___0), 0, sizeof(digest___0));
#line 231
  memset((void *)(& md), 0, sizeof(md));
#line 232
  return;
}
}
#line 236 "cipher.c"
void cipher_set_key(CipherContext *context , int cipher , unsigned char const   *key ,
                    int keylen ) 
{ unsigned char padded[32] ;
  unsigned int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 243
  context->type = (unsigned int )cipher;
#line 247
  memset((void *)(padded), 0, sizeof(padded));
#line 248
  if ((unsigned int )keylen < sizeof(padded)) {
#line 248
    tmp = (unsigned int )keylen;
  } else {
#line 248
    tmp = sizeof(padded);
  }
#line 248
  memcpy((void * __restrict  )(padded), (void const   * __restrict  )key, tmp);
#line 251
  switch (cipher) {
  case 0: 
#line 257
  break;
  case 3: 
#line 265
  if (keylen < 16) {
#line 266
    error("Key length %d is insufficient for 3DES.", keylen);
  }
#line 267
  DES_set_key((const_DES_cblock *)((void *)(padded)), & context->u.des3.key1);
#line 268
  DES_set_key((const_DES_cblock *)((void *)(padded + 8)), & context->u.des3.key2);
#line 269
  if (keylen <= 16) {
#line 270
    DES_set_key((const_DES_cblock *)((void *)(padded)), & context->u.des3.key3);
  } else {
#line 272
    DES_set_key((const_DES_cblock *)((void *)(padded + 16)), & context->u.des3.key3);
  }
#line 273
  memset((void *)(context->u.des3.iv2), 0, sizeof(context->u.des3.iv2));
#line 274
  memset((void *)(context->u.des3.iv3), 0, sizeof(context->u.des3.iv3));
#line 275
  break;
  case 6: 
#line 278
  if (keylen < 16) {
#line 279
    error("Key length %d is insufficient for blowfish.", keylen);
  }
#line 280
  BF_set_key(& context->u.bf.key, keylen, (unsigned char const   *)(padded));
#line 281
  memset((void *)(context->u.bf.iv), 0, 8U);
#line 282
  break;
  case 9: 
  case 8: 
  case 10: 
  case 11: 
#line 288
  tmp___0 = cipher_name(cipher);
#line 288
  fatal("cipher_set_key: illegal cipher: %s", tmp___0);
#line 289
  break;
  default: 
#line 292
  tmp___1 = cipher_name(cipher);
#line 292
  fatal("cipher_set_key: unknown cipher: %s", tmp___1);
  }
#line 294
  memset((void *)(padded), 0, sizeof(padded));
#line 295
  return;
}
}
#line 297 "cipher.c"
void cipher_set_key_iv(CipherContext *context , int cipher , unsigned char const   *key ,
                       int keylen , unsigned char const   *iv , int ivlen ) 
{ char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 303
  context->type = (unsigned int )cipher;
#line 306
  switch (cipher) {
  case 0: 
#line 308
  break;
  case 3: 
  case 6: 
#line 312
  tmp = cipher_name(cipher);
#line 312
  fatal("cipher_set_key_iv: illegal cipher: %s", tmp);
#line 313
  break;
  case 9: 
#line 316
  if (keylen < 24) {
#line 317
    error("Key length %d is insufficient for 3des-cbc.", keylen);
  }
#line 318
  DES_set_key((const_DES_cblock *)((void *)key), & context->u.des3.key1);
#line 319
  DES_set_key((const_DES_cblock *)((void *)(key + 8)), & context->u.des3.key2);
#line 320
  DES_set_key((const_DES_cblock *)((void *)(key + 16)), & context->u.des3.key3);
#line 321
  if (ivlen < 8) {
#line 322
    error("IV length %d is insufficient for 3des-cbc.", ivlen);
  }
#line 323
  memcpy((void * __restrict  )(context->u.des3.iv3), (void const   * __restrict  )((char *)iv),
         8U);
#line 324
  break;
  case 8: 
#line 327
  if (keylen < 16) {
#line 328
    error("Key length %d is insufficient for blowfish.", keylen);
  }
#line 329
  if (ivlen < 8) {
#line 330
    error("IV length %d is insufficient for blowfish.", ivlen);
  }
#line 331
  BF_set_key(& context->u.bf.key, keylen, (unsigned char const   *)((unsigned char *)key));
#line 332
  memcpy((void * __restrict  )(context->u.bf.iv), (void const   * __restrict  )((char *)iv),
         8U);
#line 333
  break;
  case 10: 
#line 336
  if (keylen < 16) {
#line 337
    error("Key length %d is insufficient for arcfour.", keylen);
  }
#line 338
  RC4_set_key(& context->u.rc4, keylen, (unsigned char const   *)((unsigned char *)key));
#line 339
  break;
  case 11: 
#line 342
  if (keylen < 16) {
#line 343
    error("Key length %d is insufficient for cast128.", keylen);
  }
#line 344
  if (ivlen < 8) {
#line 345
    error("IV length %d is insufficient for cast128.", ivlen);
  }
#line 346
  CAST_set_key(& context->u.cast.key, keylen, (unsigned char const   *)((unsigned char *)key));
#line 347
  memcpy((void * __restrict  )(context->u.cast.iv), (void const   * __restrict  )((char *)iv),
         8U);
#line 348
  break;
  default: 
#line 351
  tmp___0 = cipher_name(cipher);
#line 351
  fatal("cipher_set_key: unknown cipher: %s", tmp___0);
  }
#line 353
  return;
}
}
#line 357 "cipher.c"
void cipher_encrypt(CipherContext *context , unsigned char *dest , unsigned char const   *src ,
                    unsigned int len ) 
{ char const   *tmp ;

  {
#line 361
  if ((len & 7U) != 0U) {
#line 362
    fatal("cipher_encrypt: bad plaintext length %d", len);
  }
#line 364
  switch ((int )context->type) {
  case 0: 
#line 366
  memcpy((void * __restrict  )dest, (void const   * __restrict  )src, len);
#line 367
  break;
  case 3: 
#line 370
  SSH_3CBC_ENCRYPT(context->u.des3.key1, context->u.des3.key2, & context->u.des3.iv2,
                   context->u.des3.key3, & context->u.des3.iv3, dest, (unsigned char *)src,
                   len);
#line 374
  break;
  case 6: 
#line 377
  swap_bytes(src, dest, (int )len);
#line 378
  BF_cbc_encrypt((unsigned char const   *)dest, dest, (long )len, (BF_KEY const   *)(& context->u.bf.key),
                 context->u.bf.iv, 1);
#line 381
  swap_bytes((unsigned char const   *)dest, dest, (int )len);
#line 382
  break;
  case 8: 
#line 385
  BF_cbc_encrypt((unsigned char const   *)((void *)src), dest, (long )len, (BF_KEY const   *)(& context->u.bf.key),
                 context->u.bf.iv, 1);
#line 388
  break;
  case 9: 
#line 391
  DES_ede3_cbc_encrypt(src, dest, (long )len, & context->u.des3.key1, & context->u.des3.key2,
                       & context->u.des3.key3, & context->u.des3.iv3, 1);
#line 394
  break;
  case 10: 
#line 397
  RC4(& context->u.rc4, (unsigned long )len, (unsigned char const   *)((unsigned char *)src),
      dest);
#line 398
  break;
  case 11: 
#line 401
  CAST_cbc_encrypt(src, dest, (long )len, & context->u.cast.key, context->u.cast.iv,
                   1);
#line 403
  break;
  default: 
#line 406
  tmp = cipher_name((int )context->type);
#line 406
  fatal("cipher_encrypt: unknown cipher: %s", tmp);
  }
#line 408
  return;
}
}
#line 412 "cipher.c"
void cipher_decrypt(CipherContext *context , unsigned char *dest , unsigned char const   *src ,
                    unsigned int len ) 
{ char const   *tmp ;

  {
#line 416
  if ((len & 7U) != 0U) {
#line 417
    fatal("cipher_decrypt: bad ciphertext length %d", len);
  }
#line 419
  switch ((int )context->type) {
  case 0: 
#line 421
  memcpy((void * __restrict  )dest, (void const   * __restrict  )src, len);
#line 422
  break;
  case 3: 
#line 425
  SSH_3CBC_DECRYPT(context->u.des3.key1, context->u.des3.key2, & context->u.des3.iv2,
                   context->u.des3.key3, & context->u.des3.iv3, dest, (unsigned char *)src,
                   len);
#line 429
  break;
  case 6: 
#line 432
  swap_bytes(src, dest, (int )len);
#line 433
  BF_cbc_encrypt((unsigned char const   *)((void *)dest), dest, (long )len, (BF_KEY const   *)(& context->u.bf.key),
                 context->u.bf.iv, 0);
#line 436
  swap_bytes((unsigned char const   *)dest, dest, (int )len);
#line 437
  break;
  case 8: 
#line 440
  BF_cbc_encrypt((unsigned char const   *)((void *)src), dest, (long )len, (BF_KEY const   *)(& context->u.bf.key),
                 context->u.bf.iv, 0);
#line 443
  break;
  case 9: 
#line 446
  DES_ede3_cbc_encrypt(src, dest, (long )len, & context->u.des3.key1, & context->u.des3.key2,
                       & context->u.des3.key3, & context->u.des3.iv3, 0);
#line 449
  break;
  case 10: 
#line 452
  RC4(& context->u.rc4, (unsigned long )len, (unsigned char const   *)((unsigned char *)src),
      dest);
#line 453
  break;
  case 11: 
#line 456
  CAST_cbc_encrypt(src, dest, (long )len, & context->u.cast.key, context->u.cast.iv,
                   0);
#line 458
  break;
  default: 
#line 461
  tmp = cipher_name((int )context->type);
#line 461
  fatal("cipher_decrypt: unknown cipher: %s", tmp);
  }
#line 463
  return;
}
}
#line 1 "compat.o"
#pragma merger(0,"./compat.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 44 "compat.h"
void enable_compat13(void) ;
#line 45
void enable_compat20(void) ;
#line 46
void compat_datafellows(char const   *version ) ;
#line 47
int proto_spec(char const   *spec ) ;
#line 38 "compat.c"
int compat13  =    0;
#line 39 "compat.c"
int compat20  =    0;
#line 40 "compat.c"
int datafellows  =    0;
#line 42 "compat.c"
void enable_compat20(void) 
{ 

  {
#line 45
  verbose("Enabling compatibility mode for protocol 2.0");
#line 46
  compat20 = 1;
#line 47
  return;
}
}
#line 48 "compat.c"
void enable_compat13(void) 
{ 

  {
#line 51
  verbose("Enabling compatibility mode for protocol 1.3");
#line 52
  compat13 = 1;
#line 53
  return;
}
}
#line 55 "compat.c"
void compat_datafellows(char const   *version ) 
{ int i ;
  size_t len ;
  struct __anonstruct_check_74 check___1[3] ;
  size_t tmp ;
  int tmp___13 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___19 ;
  int tmp___22 ;
  int tmp___23 ;

  {
#line 60
  check___1[0].version = (char *)"2.1.0";
#line 60
  check___1[0].bugs = 5;
#line 60
  check___1[1].version = (char *)"2.0.1";
#line 60
  check___1[1].bugs = 15;
#line 60
  check___1[2].version = (char *)((void *)0);
#line 60
  check___1[2].bugs = 0;
#line 68
  i = 0;
#line 68
  while (check___1[i].version) {
#line 69
    len = strlen((char const   *)check___1[i].version);
#line 70
    tmp = strlen(version);
#line 71
    if (tmp >= len) {
#line 71
      if (0) {
#line 71
        if (0) {
#line 71
          __s1_len___0 = strlen(version);
#line 71
          __s2_len___0 = strlen((char const   *)check___1[i].version);
#line 71
          if (! ((unsigned int )((void const   *)(version + 1)) - (unsigned int )((void const   *)version) == 1U)) {
            goto _L___2;
          } else {
#line 71
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 71
              if (! ((unsigned int )((void const   *)(check___1[i].version + 1)) - (unsigned int )((void const   *)check___1[i].version) == 1U)) {
#line 71
                tmp___23 = 1;
              } else {
#line 71
                if (__s2_len___0 >= 4U) {
#line 71
                  tmp___23 = 1;
                } else {
#line 71
                  tmp___23 = 0;
                }
              }
            } else {
#line 71
              tmp___23 = 0;
            }
          }
#line 71
          if (tmp___23) {
#line 71
            tmp___19 = __builtin_strcmp(version, (char const   *)check___1[i].version);
          } else {
#line 71
            tmp___22 = __builtin_strcmp(version, (char const   *)check___1[i].version);
#line 71
            tmp___19 = tmp___22;
          }
        } else {
#line 71
          tmp___22 = __builtin_strcmp(version, (char const   *)check___1[i].version);
#line 71
          tmp___19 = tmp___22;
        }
#line 71
        tmp___13 = tmp___19;
      } else {
#line 71
        tmp___13 = strncmp(version, (char const   *)check___1[i].version, len);
      }
#line 71
      if (tmp___13 == 0) {
#line 72
        verbose("datafellows: %.200s", version);
#line 73
        datafellows = check___1[i].bugs;
#line 74
        return;
      }
    }
#line 68
    i ++;
  }
#line 77
  return;
}
}
#line 80 "compat.c"
int proto_spec(char const   *spec ) 
{ char *s ;
  char *p ;
  int ret ;
  int tmp ;

  {
#line 84
  ret = 0;
#line 86
  if ((unsigned int )spec == (unsigned int )((void *)0)) {
#line 87
    return (ret);
  }
#line 88
  s = xstrdup(spec);
#line 89
  p = strtok((char * __restrict  )s, (char const   * __restrict  )",");
#line 89
  while (p) {
#line 90
    tmp = atoi((char const   *)p);
#line 90
    switch (tmp) {
    case 1: 
#line 92
    if (ret == 0) {
#line 93
      ret |= 2;
    }
#line 94
    ret |= 1;
#line 95
    break;
    case 2: 
#line 97
    ret |= 4;
#line 98
    break;
    default: 
#line 100
    log("ignoring bad proto spec: \'%s\'.", p);
#line 101
    break;
    }
#line 89
    p = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )",");
  }
#line 104
  xfree((void *)s);
#line 105
  return (ret);
}
}
#line 1 "compress.o"
#pragma merger(0,"./compress.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 242 "/usr/include/zlib.h"
extern int deflate(z_streamp strm , int flush ) ;
#line 328
extern int deflateEnd(z_streamp strm ) ;
#line 363
extern int inflate(z_streamp strm , int flush ) ;
#line 462
extern int inflateEnd(z_streamp strm ) ;
#line 1317
extern int deflateInit_(z_streamp strm , int level , char const   *version , int stream_size ) ;
#line 1319
extern int inflateInit_(z_streamp strm , char const   *version , int stream_size ) ;
#line 23 "compress.c"
static z_stream incoming_stream  ;
#line 24 "compress.c"
static z_stream outgoing_stream  ;
#line 31 "compress.c"
void buffer_compress_init(int level ) 
{ 

  {
#line 34
  debug("Enabling compression at level %d.", level);
#line 35
  if (level < 1) {
#line 36
    fatal("Bad compression level %d.", level);
  } else {
#line 35
    if (level > 9) {
#line 36
      fatal("Bad compression level %d.", level);
    }
  }
#line 37
  inflateInit_(& incoming_stream, "1.2.3", (int )sizeof(z_stream ));
#line 38
  deflateInit_(& outgoing_stream, level, "1.2.3", (int )sizeof(z_stream ));
#line 39
  return;
}
}
#line 43 "compress.c"
void buffer_compress_uninit(void) 
{ double tmp ;
  double tmp___0 ;

  {
#line 46
  if (outgoing_stream.total_in == 0UL) {
#line 46
    tmp = 0.0;
  } else {
#line 46
    tmp = (double )outgoing_stream.total_out / (double )outgoing_stream.total_in;
  }
#line 46
  debug("compress outgoing: raw data %lu, compressed %lu, factor %.2f", outgoing_stream.total_in,
        outgoing_stream.total_out, tmp);
#line 50
  if (incoming_stream.total_out == 0UL) {
#line 50
    tmp___0 = 0.0;
  } else {
#line 50
    tmp___0 = (double )incoming_stream.total_in / (double )incoming_stream.total_out;
  }
#line 50
  debug("compress incoming: raw data %lu, compressed %lu, factor %.2f", incoming_stream.total_out,
        incoming_stream.total_in, tmp___0);
#line 54
  inflateEnd(& incoming_stream);
#line 55
  deflateEnd(& outgoing_stream);
#line 56
  return;
}
}
#line 67 "compress.c"
void buffer_compress(Buffer *input_buffer , Buffer *output_buffer ) 
{ char buf___1[4096] ;
  int status ;
  unsigned int tmp ;
  char *tmp___0 ;

  {
#line 74
  tmp = buffer_len(input_buffer);
#line 74
  if (tmp == 0U) {
#line 75
    return;
  }
#line 78
  tmp___0 = buffer_ptr(input_buffer);
#line 78
  outgoing_stream.next_in = (unsigned char *)tmp___0;
#line 79
  outgoing_stream.avail_in = buffer_len(input_buffer);
#line 82
  while (1) {
#line 84
    outgoing_stream.next_out = (unsigned char *)(buf___1);
#line 85
    outgoing_stream.avail_out = sizeof(buf___1);
#line 88
    status = deflate(& outgoing_stream, 1);
#line 89
    switch (status) {
    case 0: 
#line 92
    buffer_append(output_buffer, (char const   *)(buf___1), sizeof(buf___1) - outgoing_stream.avail_out);
#line 94
    break;
    default: 
#line 96
    fatal("buffer_compress: deflate returned %d", status);
    }
#line 82
    if (! (outgoing_stream.avail_out == 0U)) {
#line 82
      break;
    }
  }
#line 100
  return;
}
}
#line 111 "compress.c"
void buffer_uncompress(Buffer *input_buffer , Buffer *output_buffer ) 
{ char buf___1[4096] ;
  int status ;
  char *tmp ;

  {
#line 117
  tmp = buffer_ptr(input_buffer);
#line 117
  incoming_stream.next_in = (unsigned char *)tmp;
#line 118
  incoming_stream.avail_in = buffer_len(input_buffer);
#line 120
  while (1) {
#line 122
    incoming_stream.next_out = (unsigned char *)(buf___1);
#line 123
    incoming_stream.avail_out = sizeof(buf___1);
#line 125
    status = inflate(& incoming_stream, 1);
#line 126
    switch (status) {
    case 0: 
#line 128
    buffer_append(output_buffer, (char const   *)(buf___1), sizeof(buf___1) - incoming_stream.avail_out);
#line 130
    break;
    case -5: 
#line 137
    return;
    default: 
#line 139
    fatal("buffer_uncompress: inflate returned %d", status);
    }
  }
}
}
#line 1 "crc32.o"
#pragma merger(0,"./crc32.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 25 "crc32.h"
unsigned int crc32(unsigned char const   *s , unsigned int len ) ;
#line 53 "crc32.c"
static unsigned int crc32_tab[256]  = 
#line 53 "crc32.c"
  {      0U,      1996959894U,      3993919788U,      2567524794U, 
        124634137U,      1886057615U,      3915621685U,      2657392035U, 
        249268274U,      2044508324U,      3772115230U,      2547177864U, 
        162941995U,      2125561021U,      3887607047U,      2428444049U, 
        498536548U,      1789927666U,      4089016648U,      2227061214U, 
        450548861U,      1843258603U,      4107580753U,      2211677639U, 
        325883990U,      1684777152U,      4251122042U,      2321926636U, 
        335633487U,      1661365465U,      4195302755U,      2366115317U, 
        997073096U,      1281953886U,      3579855332U,      2724688242U, 
        1006888145U,      1258607687U,      3524101629U,      2768942443U, 
        901097722U,      1119000684U,      3686517206U,      2898065728U, 
        853044451U,      1172266101U,      3705015759U,      2882616665U, 
        651767980U,      1373503546U,      3369554304U,      3218104598U, 
        565507253U,      1454621731U,      3485111705U,      3099436303U, 
        671266974U,      1594198024U,      3322730930U,      2970347812U, 
        795835527U,      1483230225U,      3244367275U,      3060149565U, 
        1994146192U,      31158534U,      2563907772U,      4023717930U, 
        1907459465U,      112637215U,      2680153253U,      3904427059U, 
        2013776290U,      251722036U,      2517215374U,      3775830040U, 
        2137656763U,      141376813U,      2439277719U,      3865271297U, 
        1802195444U,      476864866U,      2238001368U,      4066508878U, 
        1812370925U,      453092731U,      2181625025U,      4111451223U, 
        1706088902U,      314042704U,      2344532202U,      4240017532U, 
        1658658271U,      366619977U,      2362670323U,      4224994405U, 
        1303535960U,      984961486U,      2747007092U,      3569037538U, 
        1256170817U,      1037604311U,      2765210733U,      3554079995U, 
        1131014506U,      879679996U,      2909243462U,      3663771856U, 
        1141124467U,      855842277U,      2852801631U,      3708648649U, 
        1342533948U,      654459306U,      3188396048U,      3373015174U, 
        1466479909U,      544179635U,      3110523913U,      3462522015U, 
        1591671054U,      702138776U,      2966460450U,      3352799412U, 
        1504918807U,      783551873U,      3082640443U,      3233442989U, 
        3988292384U,      2596254646U,      62317068U,      1957810842U, 
        3939845945U,      2647816111U,      81470997U,      1943803523U, 
        3814918930U,      2489596804U,      225274430U,      2053790376U, 
        3826175755U,      2466906013U,      167816743U,      2097651377U, 
        4027552580U,      2265490386U,      503444072U,      1762050814U, 
        4150417245U,      2154129355U,      426522225U,      1852507879U, 
        4275313526U,      2312317920U,      282753626U,      1742555852U, 
        4189708143U,      2394877945U,      397917763U,      1622183637U, 
        3604390888U,      2714866558U,      953729732U,      1340076626U, 
        3518719985U,      2797360999U,      1068828381U,      1219638859U, 
        3624741850U,      2936675148U,      906185462U,      1090812512U, 
        3747672003U,      2825379669U,      829329135U,      1181335161U, 
        3412177804U,      3160834842U,      628085408U,      1382605366U, 
        3423369109U,      3138078467U,      570562233U,      1426400815U, 
        3317316542U,      2998733608U,      733239954U,      1555261956U, 
        3268935591U,      3050360625U,      752459403U,      1541320221U, 
        2607071920U,      3965973030U,      1969922972U,      40735498U, 
        2617837225U,      3943577151U,      1913087877U,      83908371U, 
        2512341634U,      3803740692U,      2075208622U,      213261112U, 
        2463272603U,      3855990285U,      2094854071U,      198958881U, 
        2262029012U,      4057260610U,      1759359992U,      534414190U, 
        2176718541U,      4139329115U,      1873836001U,      414664567U, 
        2282248934U,      4279200368U,      1711684554U,      285281116U, 
        2405801727U,      4167216745U,      1634467795U,      376229701U, 
        2685067896U,      3608007406U,      1308918612U,      956543938U, 
        2808555105U,      3495958263U,      1231636301U,      1047427035U, 
        2932959818U,      3654703836U,      1088359270U,      936918000U, 
        2847714899U,      3736837829U,      1202900863U,      817233897U, 
        3183342108U,      3401237130U,      1404277552U,      615818150U, 
        3134207493U,      3453421203U,      1423857449U,      601450431U, 
        3009837614U,      3294710456U,      1567103746U,      711928724U, 
        3020668471U,      3272380065U,      1510334235U,      755167117U};
#line 110 "crc32.c"
unsigned int crc32(unsigned char const   *s , unsigned int len ) 
{ unsigned int i ;
  unsigned int crc32val ;

  {
#line 116
  crc32val = 0U;
#line 117
  i = 0U;
#line 117
  while (i < len) {
#line 118
    crc32val = crc32_tab[(crc32val ^ (unsigned int )*(s + i)) & 255U] ^ (crc32val >> 8);
#line 117
    i ++;
  }
#line 120
  return (crc32val);
}
}
#line 1 "deattack.o"
#pragma merger(0,"./deattack.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 27 "deattack.h"
int detect_attack(unsigned char *buf___1 , u_int32_t len , unsigned char *IV ) ;
#line 49 "deattack.c"
void crc_update(u_int32_t *a , u_int32_t b ) 
{ 

  {
#line 52
  b ^= *a;
#line 53
  *a = crc32((unsigned char const   *)((unsigned char *)(& b)), sizeof(b));
#line 54
  return;
}
}
#line 57 "deattack.c"
int check_crc(unsigned char *S , unsigned char *buf___1 , u_int32_t len , unsigned char *IV ) 
{ u_int32_t crc ;
  unsigned char *c ;
  int tmp ;
  int tmp___0 ;

  {
#line 64
  crc = 0U;
#line 65
  if (IV) {
#line 65
    tmp = memcmp((void const   *)S, (void const   *)IV, 8U);
#line 65
    if (! tmp) {
#line 66
      crc_update(& crc, 1U);
#line 67
      crc_update(& crc, 0U);
    }
  }
#line 69
  c = buf___1;
#line 69
  while ((unsigned int )c < (unsigned int )(buf___1 + len)) {
#line 70
    tmp___0 = memcmp((void const   *)S, (void const   *)c, 8U);
#line 70
    if (tmp___0) {
#line 74
      crc_update(& crc, 0U);
#line 75
      crc_update(& crc, 0U);
    } else {
#line 71
      crc_update(& crc, 1U);
#line 72
      crc_update(& crc, 0U);
    }
#line 69
    c += 8;
  }
#line 78
  return (crc == 0U);
}
}
#line 86 "deattack.c"
static u_int16_t *h  =    (u_int16_t *)((void *)0);
#line 87 "deattack.c"
static u_int16_t n  =    (u_int16_t )4096;
#line 83 "deattack.c"
int detect_attack(unsigned char *buf___1 , u_int32_t len , unsigned char *IV ) 
{ register u_int32_t i ;
  register u_int32_t j ;
  u_int32_t l ;
  register unsigned char *c ;
  unsigned char *d ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 93
  if (len > 262144U) {
#line 95
    fatal("detect_attack: bad length %d", len);
  } else {
#line 93
    if (len % 8U != 0U) {
#line 95
      fatal("detect_attack: bad length %d", len);
    }
  }
#line 97
  l = (unsigned int )n;
#line 97
  while (l < ((len / 8U) * 3U) / 2U) {
#line 97
    l <<= 2;
  }
#line 100
  if ((unsigned int )h == (unsigned int )((void *)0)) {
#line 101
    debug("Installing crc compensation attack detector.");
#line 102
    n = (unsigned short )l;
#line 103
    tmp = xmalloc((unsigned int )((int )n * 2));
#line 103
    h = (u_int16_t *)tmp;
  } else {
#line 105
    if (l > (u_int32_t )n) {
#line 106
      n = (unsigned short )l;
#line 107
      tmp___0 = xrealloc((void *)h, (unsigned int )((int )n * 2));
#line 107
      h = (u_int16_t *)tmp___0;
    }
  }
#line 111
  if (len <= 56U) {
#line 112
    c = buf___1;
#line 112
    while ((unsigned int )c < (unsigned int )(buf___1 + len)) {
#line 113
      if (IV) {
#line 113
        tmp___2 = memcmp((void const   *)c, (void const   *)IV, 8U);
#line 113
        if (! tmp___2) {
#line 114
          tmp___1 = check_crc(c, buf___1, len, (unsigned char *)IV);
#line 114
          if (tmp___1) {
#line 115
            return (1);
          } else {
#line 117
            break;
          }
        }
      }
#line 119
      d = buf___1;
#line 119
      while ((unsigned int )d < (unsigned int )c) {
#line 120
        tmp___4 = memcmp((void const   *)c, (void const   *)d, 8U);
#line 120
        if (! tmp___4) {
#line 121
          tmp___3 = check_crc(c, buf___1, len, (unsigned char *)IV);
#line 121
          if (tmp___3) {
#line 122
            return (1);
          } else {
#line 124
            break;
          }
        }
#line 119
        d += 8;
      }
#line 112
      c += 8;
    }
#line 128
    return (0);
  }
#line 130
  memset((void *)h, 255, (unsigned int )((int )n * 2));
#line 132
  if (IV) {
#line 133
    *(h + ((((((unsigned long )*(IV + 0) << 24) | ((unsigned long )*(IV + 1) << 16)) | ((unsigned long )*(IV + 2) << 8)) | (unsigned long )*(IV + 3)) & (unsigned long )((int )n - 1))) = (unsigned short)65534;
  }
#line 135
  c = buf___1;
#line 135
  j = 0U;
#line 135
  while ((unsigned int )c < (unsigned int )(buf___1 + len)) {
#line 136
    i = (unsigned int )((((((unsigned long )*(c + 0) << 24) | ((unsigned long )*(c + 1) << 16)) | ((unsigned long )*(c + 2) << 8)) | (unsigned long )*(c + 3)) & (unsigned long )((int )n - 1));
#line 136
    while ((int )*(h + i) != 65535) {
#line 138
      if ((int )*(h + i) == 65534) {
#line 139
        tmp___6 = memcmp((void const   *)c, (void const   *)IV, 8U);
#line 139
        if (! tmp___6) {
#line 140
          tmp___5 = check_crc(c, buf___1, len, (unsigned char *)IV);
#line 140
          if (tmp___5) {
#line 141
            return (1);
          } else {
#line 143
            break;
          }
        }
      } else {
#line 145
        tmp___8 = memcmp((void const   *)c, (void const   *)(buf___1 + (int )*(h + i) * 8),
                         8U);
#line 145
        if (! tmp___8) {
#line 146
          tmp___7 = check_crc(c, buf___1, len, (unsigned char *)IV);
#line 146
          if (tmp___7) {
#line 147
            return (1);
          } else {
#line 149
            break;
          }
        }
      }
#line 136
      i = (i + 1U) & (unsigned int )((int )n - 1);
    }
#line 152
    *(h + i) = (unsigned short )j;
#line 135
    c += 8;
#line 135
    j ++;
  }
#line 154
  return (0);
}
}
#line 1 "dispatch.o"
#pragma merger(0,"./dispatch.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 8 "dispatch.h"
void dispatch_init(dispatch_fn *dflt ) ;
#line 9
void dispatch_set(int type , dispatch_fn *fn ) ;
#line 10
void dispatch_run(int mode , int *done ) ;
#line 11
void dispatch_protocol_error(int type , int plen ) ;
#line 100 "packet.h"
int packet_read(int *payload_len_ptr ) ;
#line 116
int packet_read_poll(int *payload_len_ptr ) ;
#line 38 "dispatch.c"
dispatch_fn *dispatch[255]  ;
#line 40 "dispatch.c"
void dispatch_protocol_error(int type , int plen ) 
{ 

  {
#line 43
  error("Hm, dispatch protocol error: type %d plen %d", type, plen);
#line 44
  return;
}
}
#line 45 "dispatch.c"
void dispatch_init(dispatch_fn *dflt ) 
{ int i ;

  {
#line 49
  i = 0;
#line 49
  while (i < 255) {
#line 50
    dispatch[i] = dflt;
#line 49
    i ++;
  }
#line 51
  return;
}
}
#line 52 "dispatch.c"
void dispatch_set(int type , dispatch_fn *fn ) 
{ 

  {
#line 55
  dispatch[type] = fn;
#line 56
  return;
}
}
#line 57 "dispatch.c"
void dispatch_run(int mode , int *done ) 
{ int plen ;
  int type ;

  {
#line 60
  while (1) {
#line 64
    if (mode == 0) {
#line 65
      type = packet_read(& plen);
    } else {
#line 67
      type = packet_read_poll(& plen);
#line 68
      if (type == 0) {
#line 69
        return;
      }
    }
#line 71
    if (type > 0) {
#line 71
      if (type < 255) {
#line 71
        if ((unsigned int )dispatch[type] != (unsigned int )((void *)0)) {
#line 72
          (*(dispatch[type]))(type, plen);
        } else {
#line 74
          packet_disconnect("protocol error: rcvd type %d", type);
        }
      } else {
#line 74
        packet_disconnect("protocol error: rcvd type %d", type);
      }
    } else {
#line 74
      packet_disconnect("protocol error: rcvd type %d", type);
    }
#line 75
    if ((unsigned int )done != (unsigned int )((void *)0)) {
#line 75
      if (*done) {
#line 76
        return;
      }
    }
  }
}
}
#line 1 "dsa.o"
#pragma merger(0,"./dsa.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 175 "/usr/include/openssl/dsa.h"
extern DSA_SIG *DSA_SIG_new(void) ;
#line 176
extern void DSA_SIG_free(DSA_SIG *a ) ;
#line 180
extern DSA_SIG *DSA_do_sign(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
#line 181
extern int DSA_do_verify(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                         DSA *dsa ) ;
#line 213
extern DSA *DSA_generate_parameters(int bits , unsigned char *seed , int seed_len ,
                                    int *counter_ret , unsigned long *h_ret , void (*callback)(int  ,
                                                                                               int  ,
                                                                                               void * ) ,
                                    void *cb_arg ) ;
#line 224
extern int DSA_generate_key(DSA *a ) ;
#line 491 "/usr/include/openssl/evp.h"
extern int EVP_DigestUpdate(EVP_MD_CTX *ctx , void const   *d , size_t cnt ) ;
#line 498
extern int EVP_DigestInit(EVP_MD_CTX *ctx , EVP_MD const   *type ) ;
#line 499
extern int EVP_DigestFinal(EVP_MD_CTX *ctx , unsigned char *md , unsigned int *s ) ;
#line 597
extern EVP_MD const   *EVP_sha1(void) ;
#line 16 "key.h"
Key *key_new(int type ) ;
#line 17
void key_free(Key *k ) ;
#line 55 "dsa.c"
Key *dsa_key_from_blob(char *blob , int blen ) 
{ Buffer b ;
  char *ktype ;
  int rlen ;
  DSA *dsa ;
  Key *key ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 69
  key = key_new(1);
#line 70
  dsa = key->dsa;
#line 71
  buffer_init(& b);
#line 72
  buffer_append(& b, (char const   *)blob, (unsigned int )blen);
#line 73
  ktype = buffer_get_string(& b, (unsigned int *)((void *)0));
#line 74
  if (0) {
#line 74
    __s1_len = strlen("ssh-dss");
#line 74
    __s2_len = strlen((char const   *)ktype);
#line 74
    if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
      goto _L___0;
    } else {
#line 74
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 74
        if (! ((unsigned int )((void const   *)(ktype + 1)) - (unsigned int )((void const   *)ktype) == 1U)) {
#line 74
          tmp___8 = 1;
        } else {
#line 74
          if (__s2_len >= 4U) {
#line 74
            tmp___8 = 1;
          } else {
#line 74
            tmp___8 = 0;
          }
        }
      } else {
#line 74
        tmp___8 = 0;
      }
    }
#line 74
    if (tmp___8) {
#line 74
      tmp___4 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
    } else {
#line 74
      tmp___7 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
#line 74
      tmp___4 = tmp___7;
    }
  } else {
#line 74
    tmp___7 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
#line 74
    tmp___4 = tmp___7;
  }
#line 74
  if (tmp___4 != 0) {
#line 75
    error("dsa_key_from_blob: cannot handle type  %s", ktype);
#line 76
    key_free(key);
#line 77
    return ((Key *)((void *)0));
  }
#line 79
  buffer_get_bignum2(& b, dsa->p);
#line 80
  buffer_get_bignum2(& b, dsa->q);
#line 81
  buffer_get_bignum2(& b, dsa->g);
#line 82
  buffer_get_bignum2(& b, dsa->pub_key);
#line 83
  tmp___9 = buffer_len(& b);
#line 83
  rlen = (int )tmp___9;
#line 84
  if (rlen != 0) {
#line 85
    error("dsa_key_from_blob: remaining bytes in key blob %d", rlen);
  }
#line 86
  buffer_free(& b);
#line 88
  debug("keytype %s", ktype);
#line 92
  return (key);
}
}
#line 94 "dsa.c"
int dsa_make_key_blob(Key *key , unsigned char **blobp , unsigned int *lenp ) 
{ Buffer b ;
  int len ;
  unsigned char *buf___1 ;
  unsigned int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 101
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 102
    return (0);
  } else {
#line 101
    if (key->type != 1) {
#line 102
      return (0);
    }
  }
#line 103
  buffer_init(& b);
#line 104
  buffer_put_cstring(& b, "ssh-dss");
#line 105
  buffer_put_bignum2(& b, (key->dsa)->p);
#line 106
  buffer_put_bignum2(& b, (key->dsa)->q);
#line 107
  buffer_put_bignum2(& b, (key->dsa)->g);
#line 108
  buffer_put_bignum2(& b, (key->dsa)->pub_key);
#line 109
  tmp = buffer_len(& b);
#line 109
  len = (int )tmp;
#line 110
  tmp___0 = xmalloc((unsigned int )len);
#line 110
  buf___1 = (unsigned char *)tmp___0;
#line 111
  tmp___1 = buffer_ptr(& b);
#line 111
  memcpy((void * __restrict  )buf___1, (void const   * __restrict  )tmp___1, (unsigned int )len);
#line 112
  tmp___2 = buffer_ptr(& b);
#line 112
  memset((void *)tmp___2, 0, (unsigned int )len);
#line 113
  buffer_free(& b);
#line 114
  if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 115
    *lenp = (unsigned int )len;
  }
#line 116
  if ((unsigned int )blobp != (unsigned int )((void *)0)) {
#line 117
    *blobp = buf___1;
  }
#line 118
  return (len);
}
}
#line 120 "dsa.c"
int dsa_sign(Key *key , unsigned char **sigp , int *lenp , unsigned char *data , int datalen ) 
{ unsigned char *digest___0 ;
  unsigned char *ret ;
  DSA_SIG *sig ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  unsigned int rlen ;
  unsigned int slen ;
  unsigned int len ;
  unsigned char sigblob[40] ;
  Buffer b ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;

  {
#line 129
  tmp = EVP_sha1();
#line 129
  evp_md = (EVP_MD *)tmp;
#line 137
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 138
    error("dsa_sign: no DSA key");
#line 139
    return (-1);
  } else {
#line 137
    if (key->type != 1) {
#line 138
      error("dsa_sign: no DSA key");
#line 139
      return (-1);
    } else {
#line 137
      if ((unsigned int )key->dsa == (unsigned int )((void *)0)) {
#line 138
        error("dsa_sign: no DSA key");
#line 139
        return (-1);
      }
    }
  }
#line 141
  tmp___0 = xmalloc((unsigned int )evp_md->md_size);
#line 141
  digest___0 = (unsigned char *)tmp___0;
#line 142
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 143
  EVP_DigestUpdate(& md, (void const   *)data, (unsigned int )datalen);
#line 144
  EVP_DigestFinal(& md, digest___0, (unsigned int *)((void *)0));
#line 146
  sig = DSA_do_sign((unsigned char const   *)digest___0, evp_md->md_size, key->dsa);
#line 147
  if ((unsigned int )sig == (unsigned int )((void *)0)) {
#line 148
    fatal("dsa_sign: cannot sign");
  }
#line 151
  tmp___1 = BN_num_bits((BIGNUM const   *)sig->r);
#line 151
  rlen = (unsigned int )((tmp___1 + 7) / 8);
#line 152
  tmp___2 = BN_num_bits((BIGNUM const   *)sig->s);
#line 152
  slen = (unsigned int )((tmp___2 + 7) / 8);
#line 153
  if (rlen > 20U) {
#line 154
    error("bad sig size %d %d", rlen, slen);
#line 155
    DSA_SIG_free(sig);
#line 156
    return (-1);
  } else {
#line 153
    if (slen > 20U) {
#line 154
      error("bad sig size %d %d", rlen, slen);
#line 155
      DSA_SIG_free(sig);
#line 156
      return (-1);
    }
  }
#line 158
  debug("sig size %d %d", rlen, slen);
#line 160
  memset((void *)(sigblob), 0, 40U);
#line 161
  BN_bn2bin((BIGNUM const   *)sig->r, ((sigblob + 40) - 20) - rlen);
#line 162
  BN_bn2bin((BIGNUM const   *)sig->s, (sigblob + 40) - slen);
#line 163
  DSA_SIG_free(sig);
#line 165
  if (datafellows & 1) {
#line 166
    debug("datafellows");
#line 167
    tmp___3 = xmalloc(40U);
#line 167
    ret = (unsigned char *)tmp___3;
#line 168
    memcpy((void * __restrict  )ret, (void const   * __restrict  )(sigblob), 40U);
#line 169
    if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 170
      *lenp = 40;
    }
#line 171
    if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 172
      *sigp = ret;
    }
  } else {
#line 175
    buffer_init(& b);
#line 176
    buffer_put_cstring(& b, "ssh-dss");
#line 177
    buffer_put_string(& b, (void const   *)(sigblob), 40U);
#line 178
    len = buffer_len(& b);
#line 179
    tmp___4 = xmalloc(len);
#line 179
    ret = (unsigned char *)tmp___4;
#line 180
    tmp___5 = buffer_ptr(& b);
#line 180
    memcpy((void * __restrict  )ret, (void const   * __restrict  )tmp___5, len);
#line 181
    buffer_free(& b);
#line 182
    if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 183
      *lenp = (int )len;
    }
#line 184
    if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 185
      *sigp = ret;
    }
  }
#line 187
  return (0);
}
}
#line 189 "dsa.c"
int dsa_verify(Key *key , unsigned char *signature , int signaturelen , unsigned char *data ,
               int datalen ) 
{ Buffer b ;
  unsigned char *digest___0 ;
  DSA_SIG *sig ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  char *ktype ;
  unsigned char *sigblob ;
  char *txt ;
  unsigned int len ;
  int rlen ;
  int ret ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  void *tmp___2 ;

  {
#line 198
  tmp = EVP_sha1();
#line 198
  evp_md = (EVP_MD *)tmp;
#line 207
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 208
    error("dsa_verify: no DSA key");
#line 209
    return (-1);
  } else {
#line 207
    if (key->type != 1) {
#line 208
      error("dsa_verify: no DSA key");
#line 209
      return (-1);
    } else {
#line 207
      if ((unsigned int )key->dsa == (unsigned int )((void *)0)) {
#line 208
        error("dsa_verify: no DSA key");
#line 209
        return (-1);
      }
    }
  }
#line 212
  if (! (datafellows & 1)) {
#line 212
    if (signaturelen == 40) {
#line 214
      datafellows |= -2;
#line 215
      log("autodetect SSH_BUG_SIGBLOB");
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 216
    if (datafellows & 1) {
#line 216
      if (signaturelen != 40) {
#line 218
        log("autoremove SSH_BUG_SIGBLOB");
#line 219
        datafellows &= -2;
      }
    }
  }
#line 222
  debug("len %d datafellows %d", signaturelen, datafellows);
#line 225
  if (datafellows & 1) {
#line 226
    sigblob = signature;
#line 227
    len = (unsigned int )signaturelen;
  } else {
#line 230
    buffer_init(& b);
#line 231
    buffer_append(& b, (char const   *)((char *)signature), (unsigned int )signaturelen);
#line 232
    ktype = buffer_get_string(& b, (unsigned int *)((void *)0));
#line 233
    tmp___0 = buffer_get_string(& b, & len);
#line 233
    sigblob = (unsigned char *)tmp___0;
#line 234
    tmp___1 = buffer_len(& b);
#line 234
    rlen = (int )tmp___1;
#line 235
    if (rlen != 0) {
#line 236
      error("remaining bytes in signature %d", rlen);
    }
#line 237
    buffer_free(& b);
  }
#line 240
  if (len != 40U) {
#line 241
    fatal("bad sigbloblen %d != SIGBLOB_LEN", len);
  }
#line 245
  sig = DSA_SIG_new();
#line 246
  sig->r = BN_new();
#line 247
  sig->s = BN_new();
#line 248
  BN_bin2bn((unsigned char const   *)sigblob, 20, sig->r);
#line 249
  BN_bin2bn((unsigned char const   *)(sigblob + 20), 20, sig->s);
#line 251
  if (! (datafellows & 1)) {
#line 252
    memset((void *)sigblob, 0, len);
#line 253
    xfree((void *)sigblob);
  }
#line 257
  tmp___2 = xmalloc((unsigned int )evp_md->md_size);
#line 257
  digest___0 = (unsigned char *)tmp___2;
#line 258
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 259
  EVP_DigestUpdate(& md, (void const   *)data, (unsigned int )datalen);
#line 260
  EVP_DigestFinal(& md, digest___0, (unsigned int *)((void *)0));
#line 262
  ret = DSA_do_verify((unsigned char const   *)digest___0, evp_md->md_size, sig, key->dsa);
#line 264
  memset((void *)digest___0, 0, (unsigned int )evp_md->md_size);
#line 265
  xfree((void *)digest___0);
#line 266
  DSA_SIG_free(sig);
#line 268
  switch (ret) {
  case 1: 
#line 270
  txt = (char *)"correct";
#line 271
  break;
  case 0: 
#line 273
  txt = (char *)"incorrect";
#line 274
  break;
  case -1: 
  default: 
#line 277
  txt = (char *)"error";
#line 278
  break;
  }
#line 280
  debug("dsa_verify: signature %s", txt);
#line 281
  return (ret);
}
}
#line 284 "dsa.c"
Key *dsa_generate_key(unsigned int bits ) 
{ DSA *dsa ;
  DSA *tmp ;
  Key *k ;
  int tmp___0 ;

  {
#line 287
  tmp = DSA_generate_parameters((int )bits, (unsigned char *)((void *)0), 0, (int *)((void *)0),
                                (unsigned long *)((void *)0), (void (*)(int  , int  ,
                                                                        void * ))((void *)0),
                                (void *)0);
#line 287
  dsa = tmp;
#line 289
  if ((unsigned int )dsa == (unsigned int )((void *)0)) {
#line 290
    fatal("DSA_generate_parameters failed");
  }
#line 292
  tmp___0 = DSA_generate_key(dsa);
#line 292
  if (! tmp___0) {
#line 293
    fatal("DSA_generate_keys failed");
  }
#line 296
  k = key_new(2);
#line 297
  k->type = 1;
#line 298
  k->dsa = dsa;
#line 299
  return (k);
}
}
#line 1 "fingerprint.o"
#pragma merger(0,"./fingerprint.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 46 "fingerprint.c"
static char retval[80]  ;
#line 43 "fingerprint.c"
char *fingerprint(BIGNUM *e , BIGNUM *n___0 ) 
{ MD5_CTX md ;
  unsigned char d[16] ;
  unsigned char *buf___1 ;
  int nlen ;
  int elen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 52
  tmp = BN_num_bits((BIGNUM const   *)n___0);
#line 52
  nlen = (tmp + 7) / 8;
#line 53
  tmp___0 = BN_num_bits((BIGNUM const   *)e);
#line 53
  elen = (tmp___0 + 7) / 8;
#line 55
  tmp___1 = xmalloc((unsigned int )(nlen + elen));
#line 55
  buf___1 = (unsigned char *)tmp___1;
#line 57
  BN_bn2bin((BIGNUM const   *)n___0, buf___1);
#line 58
  BN_bn2bin((BIGNUM const   *)e, buf___1 + nlen);
#line 60
  MD5_Init(& md);
#line 61
  MD5_Update(& md, (void const   *)buf___1, (unsigned int )(nlen + elen));
#line 62
  MD5_Final(d, & md);
#line 63
  snprintf((char * __restrict  )(retval), sizeof(retval), (char const   * __restrict  )"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x",
           d[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7], d[8], d[9], d[10], d[11],
           d[12], d[13], d[14], d[15]);
#line 66
  memset((void *)buf___1, 0, (unsigned int )(nlen + elen));
#line 67
  xfree((void *)buf___1);
#line 68
  return (retval);
}
}
#line 1 "hmac.o"
#pragma merger(0,"./hmac.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 89 "/usr/include/openssl/hmac.h"
extern void HMAC_CTX_cleanup(HMAC_CTX *ctx ) ;
#line 93
extern void HMAC_Init(HMAC_CTX *ctx , void const   *key , int len , EVP_MD const   *md ) ;
#line 97
extern void HMAC_Update(HMAC_CTX *ctx , unsigned char const   *data , size_t len ) ;
#line 98
extern void HMAC_Final(HMAC_CTX *ctx , unsigned char *md , unsigned int *len ) ;
#line 47 "hmac.c"
static unsigned char m[64]  ;
#line 39 "hmac.c"
unsigned char *hmac(EVP_MD *evp_md , unsigned int seqno , unsigned char *data , int datalen ,
                    unsigned char *key , int keylen ) 
{ HMAC_CTX c ;
  unsigned char b[4] ;

  {
#line 50
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 51
    fatal("hmac: no key");
  }
#line 52
  HMAC_Init(& c, (void const   *)key, keylen, (EVP_MD const   *)evp_md);
#line 53
  while (1) {
#line 53
    b[0] = (unsigned char )(seqno >> 24);
#line 53
    b[1] = (unsigned char )(seqno >> 16);
#line 53
    b[2] = (unsigned char )(seqno >> 8);
#line 53
    b[3] = (unsigned char )seqno;
#line 53
    break;
  }
#line 54
  HMAC_Update(& c, (unsigned char const   *)(b), sizeof(b));
#line 55
  HMAC_Update(& c, (unsigned char const   *)data, (unsigned int )datalen);
#line 56
  HMAC_Final(& c, m, (unsigned int *)((void *)0));
#line 57
  HMAC_CTX_cleanup(& c);
#line 58
  return (m);
}
}
#line 1 "hostfile.o"
#pragma merger(0,"./hostfile.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 248 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 532
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 410 "/usr/include/openssl/bn.h"
extern BIGNUM *BN_copy(BIGNUM *a , BIGNUM const   *b ) ;
#line 16 "match.h"
int match_hostname(char const   *host , char const   *pattern , unsigned int len ) ;
#line 382 "ssh.h"
int auth_rsa_read_key(char **cpp , unsigned int *bitsp , BIGNUM *e , BIGNUM *n___0 ) ;
#line 18 "key.h"
int key_equal(Key *a , Key *b ) ;
#line 21
int key_write(Key *key , FILE *f ) ;
#line 22
unsigned int key_read(Key *ret , char **cpp ) ;
#line 13 "hostfile.h"
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , Key *key ,
                                  Key *found ) ;
#line 20
int add_host_to_hostfile(char const   *filename , char const   *host , Key *key ) ;
#line 32 "hostfile.c"
int hostfile_read_key(char **cpp , unsigned int *bitsp , Key *ret ) 
{ unsigned int bits ;
  char *cp ;

  {
#line 39
  cp = *cpp;
#line 39
  while (1) {
#line 39
    if (! ((int )*cp == 32)) {
#line 39
      if (! ((int )*cp == 9)) {
#line 39
        break;
      }
    }
#line 39
    cp ++;
  }
#line 42
  bits = key_read(ret, & cp);
#line 43
  if (bits == 0U) {
#line 44
    return (0);
  }
#line 47
  while (1) {
#line 47
    if (! ((int )*cp == 32)) {
#line 47
      if (! ((int )*cp == 9)) {
#line 47
        break;
      }
    }
#line 47
    cp ++;
  }
#line 51
  *cpp = cp;
#line 52
  *bitsp = bits;
#line 53
  return (1);
}
}
#line 56 "hostfile.c"
int auth_rsa_read_key(char **cpp , unsigned int *bitsp , BIGNUM *e , BIGNUM *n___0 ) 
{ Key *k ;
  Key *tmp ;
  int ret ;
  int tmp___0 ;

  {
#line 59
  tmp = key_new(0);
#line 59
  k = tmp;
#line 60
  tmp___0 = hostfile_read_key(cpp, bitsp, k);
#line 60
  ret = tmp___0;
#line 61
  BN_copy(e, (BIGNUM const   *)(k->rsa)->e);
#line 62
  BN_copy(n___0, (BIGNUM const   *)(k->rsa)->n);
#line 63
  key_free(k);
#line 64
  return (ret);
}
}
#line 67 "hostfile.c"
int hostfile_check_key(int bits , Key *key , char const   *host , char const   *filename ,
                       int linenum ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 70
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 71
    return (1);
  } else {
#line 70
    if (key->type != 0) {
#line 71
      return (1);
    } else {
#line 70
      if ((unsigned int )key->rsa == (unsigned int )((void *)0)) {
#line 71
        return (1);
      }
    }
  }
#line 72
  tmp___1 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 72
  if (bits != tmp___1) {
#line 73
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 73
    log("Warning: %s, line %d: keysize mismatch for host %s: actual %d vs. announced %d.",
        filename, linenum, host, tmp, bits);
#line 76
    tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 76
    log("Warning: replace %d with %d in %s, line %d.", bits, tmp___0, filename, linenum);
  }
#line 79
  return (1);
}
}
#line 89 "hostfile.c"
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , Key *key ,
                                  Key *found ) 
{ FILE *f ;
  char line[8192] ;
  int linenum ;
  unsigned int kbits ;
  unsigned int hostlen ;
  char *cp ;
  char *cp2 ;
  HostStatus end_return ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 94
  linenum = 0;
#line 99
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 100
    fatal("no key to look up");
  }
#line 102
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 103
  if (! f) {
#line 104
    return (1);
  }
#line 107
  hostlen = strlen(host);
#line 114
  end_return = 1;
#line 117
  while (1) {
#line 117
    tmp___3 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 117
    if (! tmp___3) {
#line 117
      break;
    }
#line 118
    cp = line;
#line 119
    linenum ++;
#line 122
    while (1) {
#line 122
      if (! ((int )*cp == 32)) {
#line 122
        if (! ((int )*cp == 9)) {
#line 122
          break;
        }
      }
#line 122
      cp ++;
    }
#line 124
    if (! *cp) {
#line 125
      continue;
    } else {
#line 124
      if ((int )*cp == 35) {
#line 125
        continue;
      } else {
#line 124
        if ((int )*cp == 10) {
#line 125
          continue;
        }
      }
    }
#line 128
    cp2 = cp;
#line 128
    while (1) {
#line 128
      if (*cp2) {
#line 128
        if ((int )*cp2 != 32) {
#line 128
          if (! ((int )*cp2 != 9)) {
#line 128
            break;
          }
        } else {
#line 128
          break;
        }
      } else {
#line 128
        break;
      }
#line 128
      cp2 ++;
    }
#line 132
    tmp = match_hostname(host, (char const   *)cp, (unsigned int )(cp2 - cp));
#line 132
    if (! tmp) {
#line 133
      continue;
    }
#line 136
    cp = cp2;
#line 142
    tmp___0 = hostfile_read_key(& cp, & kbits, found);
#line 142
    if (! tmp___0) {
#line 143
      continue;
    }
#line 144
    tmp___1 = hostfile_check_key((int )kbits, found, host, filename, linenum);
#line 144
    if (! tmp___1) {
#line 145
      continue;
    }
#line 148
    tmp___2 = key_equal(key, found);
#line 148
    if (tmp___2) {
#line 150
      fclose(f);
#line 151
      return (0);
    }
#line 158
    end_return = 2;
  }
#line 161
  fclose(f);
#line 167
  return (end_return);
}
}
#line 175 "hostfile.c"
int add_host_to_hostfile(char const   *filename , char const   *host , Key *key ) 
{ FILE *f ;
  int success ;
  int tmp ;

  {
#line 179
  success = 0;
#line 180
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 181
    return (1);
  }
#line 182
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"a");
#line 183
  if (! f) {
#line 184
    return (0);
  }
#line 185
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s ", host);
#line 186
  tmp = key_write(key, f);
#line 186
  if (tmp) {
#line 187
    success = 1;
  } else {
#line 189
    error("add_host_to_hostfile: saving key in %s failed", filename);
  }
#line 191
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"\n");
#line 192
  fclose(f);
#line 193
  return (success);
}
}
#line 1 "key.o"
#pragma merger(0,"./key.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 603 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 457 "/usr/include/openssl/bn.h"
extern int BN_cmp(BIGNUM const   *a , BIGNUM const   *b ) ;
#line 496
extern char *BN_bn2dec(BIGNUM const   *a ) ;
#line 498
extern int BN_dec2bn(BIGNUM **a , char const   *str ) ;
#line 215 "/usr/include/openssl/rsa.h"
extern RSA *RSA_new(void) ;
#line 238
extern void RSA_free(RSA *r ) ;
#line 190 "/usr/include/openssl/dsa.h"
extern DSA *DSA_new(void) ;
#line 593 "/usr/include/openssl/evp.h"
extern EVP_MD const   *EVP_md5(void) ;
#line 19 "key.h"
char *key_fingerprint(Key *k ) ;
#line 20
char *key_type(Key *k ) ;
#line 3 "uuencode.h"
int uuencode(unsigned char *src , unsigned int srclength , char *target , size_t targsize ) ;
#line 4
int uudecode(char const   *src , unsigned char *target , size_t targsize ) ;
#line 46 "key.c"
Key *key_new(int type ) 
{ Key *k ;
  RSA *rsa ;
  DSA *dsa ;
  void *tmp ;

  {
#line 52
  tmp = xmalloc(sizeof(*k));
#line 52
  k = (Key *)tmp;
#line 53
  k->type = type;
#line 54
  k->dsa = (DSA *)((void *)0);
#line 55
  k->rsa = (RSA *)((void *)0);
#line 56
  switch (k->type) {
  case 0: 
#line 58
  rsa = RSA_new();
#line 59
  rsa->n = BN_new();
#line 60
  rsa->e = BN_new();
#line 61
  k->rsa = rsa;
#line 62
  break;
  case 1: 
#line 64
  dsa = DSA_new();
#line 65
  dsa->p = BN_new();
#line 66
  dsa->q = BN_new();
#line 67
  dsa->g = BN_new();
#line 68
  dsa->pub_key = BN_new();
#line 69
  k->dsa = dsa;
#line 70
  break;
  case 2: 
#line 72
  break;
  default: 
#line 74
  fatal("key_new: bad key type %d", k->type);
#line 75
  break;
  }
#line 77
  return (k);
}
}
#line 79 "key.c"
void key_free(Key *k ) 
{ 

  {
#line 82
  switch (k->type) {
  case 0: 
#line 84
  if ((unsigned int )k->rsa != (unsigned int )((void *)0)) {
#line 85
    RSA_free(k->rsa);
  }
#line 86
  k->rsa = (RSA *)((void *)0);
#line 87
  break;
  case 1: 
#line 89
  if ((unsigned int )k->dsa != (unsigned int )((void *)0)) {
#line 90
    DSA_free(k->dsa);
  }
#line 91
  k->dsa = (DSA *)((void *)0);
#line 92
  break;
  default: 
#line 94
  fatal("key_free: bad key type %d", k->type);
#line 95
  break;
  }
#line 97
  xfree((void *)k);
#line 98
  return;
}
}
#line 99 "key.c"
int key_equal(Key *a , Key *b ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 102
  if ((unsigned int )a == (unsigned int )((void *)0)) {
#line 103
    return (0);
  } else {
#line 102
    if ((unsigned int )b == (unsigned int )((void *)0)) {
#line 103
      return (0);
    } else {
#line 102
      if (a->type != b->type) {
#line 103
        return (0);
      }
    }
  }
#line 104
  switch (a->type) {
  case 0: 
#line 106
  if ((unsigned int )a->rsa != (unsigned int )((void *)0)) {
#line 106
    if ((unsigned int )b->rsa != (unsigned int )((void *)0)) {
#line 106
      tmp = BN_cmp((BIGNUM const   *)(a->rsa)->e, (BIGNUM const   *)(b->rsa)->e);
#line 106
      if (tmp == 0) {
#line 106
        tmp___0 = BN_cmp((BIGNUM const   *)(a->rsa)->n, (BIGNUM const   *)(b->rsa)->n);
#line 106
        if (tmp___0 == 0) {
#line 106
          tmp___1 = 1;
        } else {
#line 106
          tmp___1 = 0;
        }
      } else {
#line 106
        tmp___1 = 0;
      }
    } else {
#line 106
      tmp___1 = 0;
    }
  } else {
#line 106
    tmp___1 = 0;
  }
#line 106
  return (tmp___1);
#line 109
  break;
  case 1: 
#line 111
  if ((unsigned int )a->dsa != (unsigned int )((void *)0)) {
#line 111
    if ((unsigned int )b->dsa != (unsigned int )((void *)0)) {
#line 111
      tmp___2 = BN_cmp((BIGNUM const   *)(a->dsa)->p, (BIGNUM const   *)(b->dsa)->p);
#line 111
      if (tmp___2 == 0) {
#line 111
        tmp___3 = BN_cmp((BIGNUM const   *)(a->dsa)->q, (BIGNUM const   *)(b->dsa)->q);
#line 111
        if (tmp___3 == 0) {
#line 111
          tmp___4 = BN_cmp((BIGNUM const   *)(a->dsa)->g, (BIGNUM const   *)(b->dsa)->g);
#line 111
          if (tmp___4 == 0) {
#line 111
            tmp___5 = BN_cmp((BIGNUM const   *)(a->dsa)->pub_key, (BIGNUM const   *)(b->dsa)->pub_key);
#line 111
            if (tmp___5 == 0) {
#line 111
              tmp___6 = 1;
            } else {
#line 111
              tmp___6 = 0;
            }
          } else {
#line 111
            tmp___6 = 0;
          }
        } else {
#line 111
          tmp___6 = 0;
        }
      } else {
#line 111
        tmp___6 = 0;
      }
    } else {
#line 111
      tmp___6 = 0;
    }
  } else {
#line 111
    tmp___6 = 0;
  }
#line 111
  return (tmp___6);
#line 116
  break;
  default: 
#line 118
  fatal("key_equal: bad key type %d", a->type);
#line 119
  break;
  }
#line 121
  return (0);
}
}
#line 133 "key.c"
static char retval___0[80]  ;
#line 130 "key.c"
char *key_fingerprint(Key *k ) 
{ unsigned char *blob ;
  int len ;
  int nlen ;
  int elen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  unsigned char d[16] ;
  EVP_MD_CTX md ;
  EVP_MD const   *tmp___2 ;

  {
#line 134
  blob = (unsigned char *)((void *)0);
#line 135
  len = 0;
#line 138
  switch (k->type) {
  case 0: 
#line 140
  tmp = BN_num_bits((BIGNUM const   *)(k->rsa)->n);
#line 140
  nlen = (tmp + 7) / 8;
#line 141
  tmp___0 = BN_num_bits((BIGNUM const   *)(k->rsa)->e);
#line 141
  elen = (tmp___0 + 7) / 8;
#line 142
  len = nlen + elen;
#line 143
  tmp___1 = xmalloc((unsigned int )len);
#line 143
  blob = (unsigned char *)tmp___1;
#line 144
  BN_bn2bin((BIGNUM const   *)(k->rsa)->n, blob);
#line 145
  BN_bn2bin((BIGNUM const   *)(k->rsa)->e, blob + nlen);
#line 146
  break;
  case 1: 
#line 148
  dsa_make_key_blob(k, & blob, (unsigned int *)(& len));
#line 149
  break;
  default: 
#line 151
  fatal("key_fingerprint: bad key type %d", k->type);
#line 152
  break;
  }
#line 154
  if ((unsigned int )blob != (unsigned int )((void *)0)) {
#line 157
    tmp___2 = EVP_md5();
#line 157
    EVP_DigestInit(& md, tmp___2);
#line 158
    EVP_DigestUpdate(& md, (void const   *)blob, (unsigned int )len);
#line 159
    EVP_DigestFinal(& md, d, (unsigned int *)((void *)0));
#line 160
    snprintf((char * __restrict  )(retval___0), sizeof(retval___0), (char const   * __restrict  )"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x",
             d[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7], d[8], d[9], d[10], d[11],
             d[12], d[13], d[14], d[15]);
#line 163
    memset((void *)blob, 0, (unsigned int )len);
#line 164
    xfree((void *)blob);
  }
#line 166
  return (retval___0);
}
}
#line 176 "key.c"
int read_bignum(char **cpp , BIGNUM *value ) 
{ char *cp ;
  int old ;
  int tmp ;

  {
#line 179
  cp = *cpp;
#line 183
  while (1) {
#line 183
    if (! ((int )*cp == 32)) {
#line 183
      if (! ((int )*cp == 9)) {
#line 183
        break;
      }
    }
#line 183
    cp ++;
  }
#line 187
  if ((int )*cp < 48) {
#line 188
    return (0);
  } else {
#line 187
    if ((int )*cp > 57) {
#line 188
      return (0);
    }
  }
#line 191
  *cpp = cp;
#line 194
  while (1) {
#line 194
    if ((int )*cp >= 48) {
#line 194
      if (! ((int )*cp <= 57)) {
#line 194
        break;
      }
    } else {
#line 194
      break;
    }
#line 194
    cp ++;
  }
#line 198
  old = (int )*cp;
#line 199
  *cp = (char)0;
#line 202
  tmp = BN_dec2bn(& value, (char const   *)*cpp);
#line 202
  if (tmp == 0) {
#line 203
    return (0);
  }
#line 206
  *cp = (char )old;
#line 209
  *cpp = cp;
#line 210
  return (1);
}
}
#line 212 "key.c"
int write_bignum(FILE *f , BIGNUM *num ) 
{ char *buf___1 ;
  char *tmp ;

  {
#line 215
  tmp = BN_bn2dec((BIGNUM const   *)num);
#line 215
  buf___1 = tmp;
#line 216
  if ((unsigned int )buf___1 == (unsigned int )((void *)0)) {
#line 217
    error("write_bignum: BN_bn2dec() failed");
#line 218
    return (0);
  }
#line 220
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )" %s", buf___1);
#line 221
  free((void *)buf___1);
#line 222
  return (1);
}
}
#line 224 "key.c"
unsigned int key_read(Key *ret , char **cpp ) 
{ Key *k ;
  unsigned int bits ;
  char *cp ;
  int len ;
  int n___0 ;
  unsigned char *blob ;
  int tmp ;
  int tmp___0 ;
  int tmp___14 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  size_t tmp___27 ;
  void *tmp___28 ;
  int tmp___29 ;

  {
#line 228
  bits = 0U;
#line 233
  cp = *cpp;
#line 235
  switch (ret->type) {
  case 0: 
#line 238
  if ((int )*cp < 48) {
#line 239
    return (0U);
  } else {
#line 238
    if ((int )*cp > 57) {
#line 239
      return (0U);
    }
  }
#line 240
  bits = 0U;
#line 240
  while (1) {
#line 240
    if ((int )*cp >= 48) {
#line 240
      if (! ((int )*cp <= 57)) {
#line 240
        break;
      }
    } else {
#line 240
      break;
    }
#line 241
    bits = (10U * bits + (unsigned int )*cp) - 48U;
#line 240
    cp ++;
  }
#line 242
  if (bits == 0U) {
#line 243
    return (0U);
  }
#line 244
  *cpp = cp;
#line 246
  tmp = read_bignum(cpp, (ret->rsa)->e);
#line 246
  if (! tmp) {
#line 247
    return (0U);
  }
#line 248
  tmp___0 = read_bignum(cpp, (ret->rsa)->n);
#line 248
  if (! tmp___0) {
#line 249
    return (0U);
  }
#line 250
  break;
  case 1: 
#line 252
  if (0) {
#line 252
    if (0) {
#line 252
      __s1_len___0 = strlen((char const   *)cp);
#line 252
      __s2_len___0 = strlen("ssh-dss ");
#line 252
      if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
        goto _L___2;
      } else {
#line 252
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 252
          if (! ((unsigned int )((void const   *)("ssh-dss " + 1)) - (unsigned int )((void const   *)"ssh-dss ") == 1U)) {
#line 252
            tmp___24 = 1;
          } else {
#line 252
            if (__s2_len___0 >= 4U) {
#line 252
              tmp___24 = 1;
            } else {
#line 252
              tmp___24 = 0;
            }
          }
        } else {
#line 252
          tmp___24 = 0;
        }
      }
#line 252
      if (tmp___24) {
#line 252
        tmp___20 = __builtin_strcmp((char const   *)cp, "ssh-dss ");
      } else {
#line 252
        tmp___23 = __builtin_strcmp((char const   *)cp, "ssh-dss ");
#line 252
        tmp___20 = tmp___23;
      }
    } else {
#line 252
      tmp___23 = __builtin_strcmp((char const   *)cp, "ssh-dss ");
#line 252
      tmp___20 = tmp___23;
    }
#line 252
    tmp___14 = tmp___20;
  } else {
#line 252
    tmp___14 = strncmp((char const   *)cp, "ssh-dss ", 7U);
  }
#line 252
  if (tmp___14 != 0) {
#line 253
    return (0U);
  }
#line 254
  cp += 7;
#line 255
  tmp___27 = strlen((char const   *)cp);
#line 255
  len = (int )(2U * tmp___27);
#line 256
  tmp___28 = xmalloc((unsigned int )len);
#line 256
  blob = (unsigned char *)tmp___28;
#line 257
  n___0 = uudecode((char const   *)cp, blob, (unsigned int )len);
#line 258
  if (n___0 < 0) {
#line 259
    error("key_read: uudecode %s failed", cp);
#line 260
    return (0U);
  }
#line 262
  k = dsa_key_from_blob((char *)blob, n___0);
#line 263
  if ((unsigned int )k == (unsigned int )((void *)0)) {
#line 264
    error("key_read: dsa_key_from_blob %s failed", cp);
#line 265
    return (0U);
  }
#line 267
  xfree((void *)blob);
#line 268
  if ((unsigned int )ret->dsa != (unsigned int )((void *)0)) {
#line 269
    DSA_free(ret->dsa);
  }
#line 270
  ret->dsa = k->dsa;
#line 271
  k->dsa = (DSA *)((void *)0);
#line 272
  key_free(k);
#line 273
  tmp___29 = BN_num_bits((BIGNUM const   *)(ret->dsa)->p);
#line 273
  bits = (unsigned int )tmp___29;
#line 275
  while (1) {
#line 275
    if (! ((int )*cp == 32)) {
#line 275
      if (! ((int )*cp == 9)) {
#line 275
        break;
      }
    }
#line 276
    cp ++;
  }
#line 277
  while (1) {
#line 277
    if ((int )*cp != 0) {
#line 277
      if ((int )*cp != 32) {
#line 277
        if (! ((int )*cp != 9)) {
#line 277
          break;
        }
      } else {
#line 277
        break;
      }
    } else {
#line 277
      break;
    }
#line 278
    cp ++;
  }
#line 279
  *cpp = cp;
#line 280
  break;
  default: 
#line 282
  fatal("key_read: bad key type: %d", ret->type);
#line 283
  break;
  }
#line 285
  return (bits);
}
}
#line 287 "key.c"
int key_write(Key *key , FILE *f ) 
{ int success ;
  unsigned int bits ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int len ;
  int n___0 ;
  unsigned char *blob ;
  unsigned char *uu ;
  void *tmp___2 ;

  {
#line 290
  success = 0;
#line 291
  bits = 0U;
#line 293
  if (key->type == 0) {
#line 293
    if ((unsigned int )key->rsa != (unsigned int )((void *)0)) {
#line 295
      tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 295
      bits = (unsigned int )tmp;
#line 296
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%u", bits);
#line 297
      tmp___0 = write_bignum(f, (key->rsa)->e);
#line 297
      if (tmp___0) {
#line 297
        tmp___1 = write_bignum(f, (key->rsa)->n);
#line 297
        if (tmp___1) {
#line 299
          success = 1;
        } else {
#line 301
          error("key_write: failed for RSA key");
        }
      } else {
#line 301
        error("key_write: failed for RSA key");
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 303
    if (key->type == 1) {
#line 303
      if ((unsigned int )key->dsa != (unsigned int )((void *)0)) {
#line 306
        dsa_make_key_blob(key, & blob, (unsigned int *)(& len));
#line 307
        tmp___2 = xmalloc((unsigned int )(2 * len));
#line 307
        uu = (unsigned char *)tmp___2;
#line 308
        n___0 = uuencode(blob, (unsigned int )len, (char *)uu, (unsigned int )(2 * len));
#line 309
        if (n___0 > 0) {
#line 310
          fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s", "ssh-dss",
                  uu);
#line 311
          success = 1;
        }
#line 313
        xfree((void *)blob);
#line 314
        xfree((void *)uu);
      }
    }
  }
#line 316
  return (success);
}
}
#line 318 "key.c"
char *key_type(Key *k ) 
{ 

  {
#line 321
  switch (k->type) {
  case 0: 
#line 323
  return ((char *)"RSA");
#line 324
  break;
  case 1: 
#line 326
  return ((char *)"DSA");
#line 327
  break;
  }
#line 329
  return ((char *)"unknown");
}
}
#line 1 "kex.o"
#pragma merger(0,"./kex.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 454 "/usr/include/openssl/bn.h"
extern int BN_set_word(BIGNUM *a , unsigned long w ) ;
#line 459
extern int BN_is_bit_set(BIGNUM const   *a , int n ) ;
#line 497
extern int BN_hex2bn(BIGNUM **a , char const   *str ) ;
#line 91 "packet.h"
void packet_put_raw(char const   *buf___1 , unsigned int len ) ;
#line 125
unsigned int packet_get_char(void) ;
#line 136
char *packet_get_raw(int *length_ptr ) ;
#line 173 "/usr/include/openssl/dh.h"
extern DH *DH_new(void) ;
#line 193
extern int DH_generate_key(DH *dh ) ;
#line 611 "/usr/include/openssl/evp.h"
extern EVP_MD const   *EVP_ripemd160(void) ;
#line 93 "kex.h"
Buffer *kex_init(char **myproposal___0 ) ;
#line 94
void kex_exchange_kexinit(Buffer *my_kexinit , Buffer *peer_kexint , char **peer_proposal ) ;
#line 98
Kex *kex_choose_conf(char **cprop , char **sprop , int server ) ;
#line 101
int kex_derive_keys(Kex *k , unsigned char *hash , BIGNUM *shared_secret ) ;
#line 103
int dh_pub_is_valid(DH *dh , BIGNUM *dh_pub ) ;
#line 104
DH *dh_new_group1(void) ;
#line 106
unsigned char *kex_hash(char *client_version_string___0 , char *server_version_string___0 ,
                        char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                        char *serverhostkeyblob , int sbloblen , BIGNUM *client_dh_pub ,
                        BIGNUM *server_dh_pub , BIGNUM *shared_secret ) ;
#line 55 "kex.c"
Buffer *kex_init(char **myproposal___0 ) 
{ int first_kex_packet_follows ;
  unsigned char cookie[16] ;
  u_int32_t rand___0 ;
  int i ;
  Buffer *ki ;
  void *tmp ;

  {
#line 58
  first_kex_packet_follows = 0;
#line 60
  rand___0 = (u_int32_t )0;
#line 62
  tmp = xmalloc(sizeof(*ki));
#line 62
  ki = (Buffer *)tmp;
#line 63
  i = 0;
#line 63
  while (i < 16) {
#line 64
    if (i % 4 == 0) {
#line 65
      rand___0 = arc4random();
    }
#line 66
    cookie[i] = (unsigned char )(rand___0 & 255U);
#line 67
    rand___0 >>= 8;
#line 63
    i ++;
  }
#line 69
  buffer_init(ki);
#line 70
  buffer_append(ki, (char const   *)((char *)(cookie)), sizeof(cookie));
#line 71
  i = 0;
#line 71
  while (i < 10) {
#line 72
    buffer_put_cstring(ki, (char const   *)*(myproposal___0 + i));
#line 71
    i ++;
  }
#line 73
  buffer_put_char(ki, first_kex_packet_follows);
#line 74
  buffer_put_int(ki, 0U);
#line 75
  return (ki);
}
}
#line 79 "kex.c"
void kex_exchange_kexinit(Buffer *my_kexinit , Buffer *peer_kexint , char **peer_proposal ) 
{ int i ;
  char *ptr ;
  int plen ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 88
  debug("send KEXINIT");
#line 89
  packet_start(20);
#line 90
  tmp = buffer_len(my_kexinit);
#line 90
  tmp___0 = buffer_ptr(my_kexinit);
#line 90
  packet_put_raw((char const   *)tmp___0, tmp);
#line 91
  packet_send();
#line 92
  packet_write_wait();
#line 93
  debug("done");
#line 99
  debug("wait KEXINIT");
#line 100
  packet_read_expect(& plen, 20);
#line 101
  ptr = packet_get_raw(& plen);
#line 102
  buffer_append(peer_kexint, (char const   *)ptr, (unsigned int )plen);
#line 106
  i = 0;
#line 106
  while (i < 16) {
#line 107
    packet_get_char();
#line 106
    i ++;
  }
#line 109
  i = 0;
#line 109
  while (i < 10) {
#line 110
    *(peer_proposal + i) = packet_get_string((unsigned int *)((void *)0));
#line 111
    debug("got kexinit: %s", *(peer_proposal + i));
#line 109
    i ++;
  }
#line 114
  tmp___1 = packet_get_char();
#line 114
  i = (int )tmp___1;
#line 115
  debug("first kex follow: %d ", i);
#line 116
  tmp___2 = packet_get_int();
#line 116
  i = (int )tmp___2;
#line 117
  debug("reserved: %d ", i);
#line 118
  while (1) {
#line 118
    tmp___3 = packet_remaining();
#line 118
    _len = tmp___3;
#line 118
    if (_len > 0) {
#line 118
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kex.c", 118);
#line 118
      packet_disconnect("Packet integrity error.");
    }
#line 118
    break;
  }
#line 119
  debug("done");
#line 120
  return;
}
}
#line 124 "kex.c"
int dh_pub_is_valid(DH *dh , BIGNUM *dh_pub ) 
{ int i ;
  int n___0 ;
  int tmp ;
  int bits_set ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 128
  tmp = BN_num_bits((BIGNUM const   *)dh_pub);
#line 128
  n___0 = tmp;
#line 129
  bits_set = 0;
#line 132
  if ((dh->g)->top == 1) {
#line 132
    if (*((dh->g)->d + 0) == 2UL) {
      goto _L;
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 132
    if (0) {
      _L: /* CIL Label */ 
#line 132
      if (! (! (dh->g)->neg)) {
#line 133
        log("invalid DH base != 2");
#line 134
        return (0);
      }
    } else {
#line 133
      log("invalid DH base != 2");
#line 134
      return (0);
    }
  }
#line 136
  if (dh_pub->neg) {
#line 137
    log("invalid public DH value: negativ");
#line 138
    return (0);
  }
#line 140
  i = 0;
#line 140
  while (i <= n___0) {
#line 141
    tmp___0 = BN_is_bit_set((BIGNUM const   *)dh_pub, i);
#line 141
    if (tmp___0) {
#line 142
      bits_set ++;
    }
#line 140
    i ++;
  }
#line 143
  tmp___1 = BN_num_bits((BIGNUM const   *)dh->p);
#line 143
  debug("bits set: %d/%d", bits_set, tmp___1);
#line 146
  if (bits_set > 1) {
#line 146
    tmp___2 = BN_cmp((BIGNUM const   *)dh_pub, (BIGNUM const   *)dh->p);
#line 146
    if (tmp___2 == -1) {
#line 147
      return (1);
    }
  }
#line 148
  tmp___3 = BN_num_bits((BIGNUM const   *)dh->p);
#line 148
  log("invalid public DH value (%d/%d)", bits_set, tmp___3);
#line 149
  return (0);
}
}
#line 155 "kex.c"
static char *group1  =    (char *)"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF";
#line 152 "kex.c"
DH *dh_new_group1(void) 
{ DH *dh ;
  int ret ;
  int tries ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 163
  tries = 0;
#line 164
  dh = DH_new();
#line 165
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 166
    fatal("DH_new");
  }
#line 167
  ret = BN_hex2bn(& dh->p, (char const   *)group1);
#line 168
  if (ret < 0) {
#line 169
    fatal("BN_hex2bn");
  }
#line 170
  dh->g = BN_new();
#line 171
  if ((unsigned int )dh->g == (unsigned int )((void *)0)) {
#line 172
    fatal("DH_new g");
  }
#line 173
  BN_set_word(dh->g, 2UL);
#line 174
  while (1) {
#line 175
    tmp = DH_generate_key(dh);
#line 175
    if (tmp == 0) {
#line 176
      fatal("DH_generate_key");
    }
#line 177
    tmp___0 = tries;
#line 177
    tries ++;
#line 177
    if (tmp___0 > 10) {
#line 178
      fatal("dh_new_group1: too many bad keys: giving up");
    }
#line 174
    tmp___1 = dh_pub_is_valid(dh, dh->pub_key);
#line 174
    if (tmp___1) {
#line 174
      break;
    }
  }
#line 180
  return (dh);
}
}
#line 183 "kex.c"
void dump_digest(unsigned char *digest___0 , int len ) 
{ int i ;

  {
#line 187
  i = 0;
#line 187
  while (i < len) {
#line 188
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%02x", *(digest___0 + i));
#line 189
    if (i % 2 != 0) {
#line 190
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" ");
    }
#line 187
    i ++;
  }
#line 192
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 193
  return;
}
}
#line 207 "kex.c"
static unsigned char digest[64]  ;
#line 195 "kex.c"
unsigned char *kex_hash(char *client_version_string___0 , char *server_version_string___0 ,
                        char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                        char *serverhostkeyblob , int sbloblen , BIGNUM *client_dh_pub ,
                        BIGNUM *server_dh_pub , BIGNUM *shared_secret ) 
{ Buffer b ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;

  {
#line 208
  tmp = EVP_sha1();
#line 208
  evp_md = (EVP_MD *)tmp;
#line 211
  buffer_init(& b);
#line 212
  tmp___0 = strlen((char const   *)client_version_string___0);
#line 212
  buffer_put_string(& b, (void const   *)client_version_string___0, tmp___0);
#line 213
  tmp___1 = strlen((char const   *)server_version_string___0);
#line 213
  buffer_put_string(& b, (void const   *)server_version_string___0, tmp___1);
#line 216
  buffer_put_int(& b, (unsigned int )(ckexinitlen + 1));
#line 217
  buffer_put_char(& b, 20);
#line 218
  buffer_append(& b, (char const   *)ckexinit, (unsigned int )ckexinitlen);
#line 219
  buffer_put_int(& b, (unsigned int )(skexinitlen + 1));
#line 220
  buffer_put_char(& b, 20);
#line 221
  buffer_append(& b, (char const   *)skexinit, (unsigned int )skexinitlen);
#line 223
  buffer_put_string(& b, (void const   *)serverhostkeyblob, (unsigned int )sbloblen);
#line 224
  buffer_put_bignum2(& b, client_dh_pub);
#line 225
  buffer_put_bignum2(& b, server_dh_pub);
#line 226
  buffer_put_bignum2(& b, shared_secret);
#line 232
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 233
  tmp___2 = buffer_len(& b);
#line 233
  tmp___3 = buffer_ptr(& b);
#line 233
  EVP_DigestUpdate(& md, (void const   *)tmp___3, tmp___2);
#line 234
  EVP_DigestFinal(& md, digest, (unsigned int *)((void *)0));
#line 236
  buffer_free(& b);
#line 241
  return (digest);
}
}
#line 244 "kex.c"
unsigned char *derive_key(int id , int need , unsigned char *hash , BIGNUM *shared_secret ) 
{ Buffer b ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  char c ;
  int have ;
  int mdsz ;
  unsigned char *digest___0 ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  char *tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;

  {
#line 248
  tmp = EVP_sha1();
#line 248
  evp_md = (EVP_MD *)tmp;
#line 250
  c = (char )id;
#line 252
  mdsz = evp_md->md_size;
#line 253
  tmp___0 = xmalloc((unsigned int )((((need + mdsz) - 1) / mdsz) * mdsz));
#line 253
  digest___0 = (unsigned char *)tmp___0;
#line 255
  buffer_init(& b);
#line 256
  buffer_put_bignum2(& b, shared_secret);
#line 258
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 259
  tmp___1 = buffer_len(& b);
#line 259
  tmp___2 = buffer_ptr(& b);
#line 259
  EVP_DigestUpdate(& md, (void const   *)tmp___2, tmp___1);
#line 260
  EVP_DigestUpdate(& md, (void const   *)hash, (unsigned int )mdsz);
#line 261
  EVP_DigestUpdate(& md, (void const   *)(& c), 1U);
#line 262
  EVP_DigestUpdate(& md, (void const   *)hash, (unsigned int )mdsz);
#line 263
  EVP_DigestFinal(& md, digest___0, (unsigned int *)((void *)0));
#line 266
  have = mdsz;
#line 266
  while (need > have) {
#line 267
    EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 268
    tmp___3 = buffer_len(& b);
#line 268
    tmp___4 = buffer_ptr(& b);
#line 268
    EVP_DigestUpdate(& md, (void const   *)tmp___4, tmp___3);
#line 269
    EVP_DigestUpdate(& md, (void const   *)hash, (unsigned int )mdsz);
#line 270
    EVP_DigestUpdate(& md, (void const   *)digest___0, (unsigned int )have);
#line 271
    EVP_DigestFinal(& md, digest___0 + have, (unsigned int *)((void *)0));
#line 266
    have += mdsz;
  }
#line 273
  buffer_free(& b);
#line 278
  return (digest___0);
}
}
#line 286 "kex.c"
char *get_match(char *client , char *server ) 
{ char *sproposals[20] ;
  char *c ;
  char *s ;
  char *p ;
  char *ret ;
  int i ;
  int j ;
  int nproposals ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 293
  c = xstrdup((char const   *)client);
#line 294
  s = xstrdup((char const   *)server);
#line 296
  p = strtok((char * __restrict  )s, (char const   * __restrict  )",");
#line 296
  i = 0;
#line 296
  while (p) {
#line 297
    if (i < 20) {
#line 298
      sproposals[i] = p;
    } else {
#line 300
      break;
    }
#line 296
    p = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )",");
#line 296
    i ++;
  }
#line 302
  nproposals = i;
#line 304
  p = strtok((char * __restrict  )c, (char const   * __restrict  )",");
#line 304
  i = 0;
#line 304
  while (p) {
#line 305
    j = 0;
#line 305
    while (j < nproposals) {
#line 306
      if (0) {
#line 306
        __s1_len = strlen((char const   *)p);
#line 306
        __s2_len = strlen((char const   *)sproposals[j]);
#line 306
        if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
          goto _L___0;
        } else {
#line 306
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 306
            if (! ((unsigned int )((void const   *)(sproposals[j] + 1)) - (unsigned int )((void const   *)sproposals[j]) == 1U)) {
#line 306
              tmp___8 = 1;
            } else {
#line 306
              if (__s2_len >= 4U) {
#line 306
                tmp___8 = 1;
              } else {
#line 306
                tmp___8 = 0;
              }
            }
          } else {
#line 306
            tmp___8 = 0;
          }
        }
#line 306
        if (tmp___8) {
#line 306
          tmp___4 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
        } else {
#line 306
          tmp___7 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
#line 306
          tmp___4 = tmp___7;
        }
      } else {
#line 306
        tmp___7 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
#line 306
        tmp___4 = tmp___7;
      }
#line 306
      if (tmp___4 == 0) {
#line 307
        ret = xstrdup((char const   *)p);
#line 308
        xfree((void *)c);
#line 309
        xfree((void *)s);
#line 310
        return (ret);
      }
#line 305
      j ++;
    }
#line 304
    p = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )",");
#line 304
    i ++;
  }
#line 314
  xfree((void *)c);
#line 315
  xfree((void *)s);
#line 316
  return ((char *)((void *)0));
}
}
#line 318 "kex.c"
void choose_enc(Enc *enc , char *client , char *server ) 
{ char *name ;
  char *tmp ;

  {
#line 321
  tmp = get_match(client, server);
#line 321
  name = tmp;
#line 322
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 323
    fatal("no matching cipher found: client %s server %s", client, server);
  }
#line 324
  enc->type = cipher_number((char const   *)name);
#line 326
  switch (enc->type) {
  case 9: 
#line 328
  enc->key_len = 24;
#line 329
  enc->iv_len = 8;
#line 330
  enc->block_size = 8;
#line 331
  break;
  case 8: 
  case 11: 
#line 334
  enc->key_len = 16;
#line 335
  enc->iv_len = 8;
#line 336
  enc->block_size = 8;
#line 337
  break;
  case 10: 
#line 339
  enc->key_len = 16;
#line 340
  enc->iv_len = 0;
#line 341
  enc->block_size = 8;
#line 342
  break;
  default: 
#line 344
  fatal("unsupported cipher %s", name);
  }
#line 346
  enc->name = name;
#line 347
  enc->enabled = 0;
#line 348
  enc->iv = (unsigned char *)((void *)0);
#line 349
  enc->key = (unsigned char *)((void *)0);
#line 350
  return;
}
}
#line 351 "kex.c"
void choose_mac(Mac *mac , char *client , char *server ) 
{ char *name ;
  char *tmp ;
  EVP_MD const   *tmp___0 ;
  EVP_MD const   *tmp___1 ;
  EVP_MD const   *tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___28 ;
  int tmp___31 ;
  int tmp___32 ;

  {
#line 354
  tmp = get_match(client, server);
#line 354
  name = tmp;
#line 355
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 356
    fatal("no matching mac found: client %s server %s", client, server);
  }
#line 357
  if (0) {
#line 357
    __s1_len___1 = strlen((char const   *)name);
#line 357
    __s2_len___1 = strlen("hmac-md5");
#line 357
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___4;
    } else {
#line 357
      if (__s1_len___1 >= 4U) {
        _L___4: /* CIL Label */ 
#line 357
        if (! ((unsigned int )((void const   *)("hmac-md5" + 1)) - (unsigned int )((void const   *)"hmac-md5") == 1U)) {
#line 357
          tmp___32 = 1;
        } else {
#line 357
          if (__s2_len___1 >= 4U) {
#line 357
            tmp___32 = 1;
          } else {
#line 357
            tmp___32 = 0;
          }
        }
      } else {
#line 357
        tmp___32 = 0;
      }
    }
#line 357
    if (tmp___32) {
#line 357
      tmp___28 = __builtin_strcmp((char const   *)name, "hmac-md5");
    } else {
#line 357
      tmp___31 = __builtin_strcmp((char const   *)name, "hmac-md5");
#line 357
      tmp___28 = tmp___31;
    }
  } else {
#line 357
    tmp___31 = __builtin_strcmp((char const   *)name, "hmac-md5");
#line 357
    tmp___28 = tmp___31;
  }
#line 357
  if (tmp___28 == 0) {
#line 358
    tmp___0 = EVP_md5();
#line 358
    mac->md = (EVP_MD *)tmp___0;
  } else {
#line 359
    if (0) {
#line 359
      __s1_len___0 = strlen((char const   *)name);
#line 359
      __s2_len___0 = strlen("hmac-sha1");
#line 359
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___2;
      } else {
#line 359
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 359
          if (! ((unsigned int )((void const   *)("hmac-sha1" + 1)) - (unsigned int )((void const   *)"hmac-sha1") == 1U)) {
#line 359
            tmp___22 = 1;
          } else {
#line 359
            if (__s2_len___0 >= 4U) {
#line 359
              tmp___22 = 1;
            } else {
#line 359
              tmp___22 = 0;
            }
          }
        } else {
#line 359
          tmp___22 = 0;
        }
      }
#line 359
      if (tmp___22) {
#line 359
        tmp___18 = __builtin_strcmp((char const   *)name, "hmac-sha1");
      } else {
#line 359
        tmp___21 = __builtin_strcmp((char const   *)name, "hmac-sha1");
#line 359
        tmp___18 = tmp___21;
      }
    } else {
#line 359
      tmp___21 = __builtin_strcmp((char const   *)name, "hmac-sha1");
#line 359
      tmp___18 = tmp___21;
    }
#line 359
    if (tmp___18 == 0) {
#line 360
      tmp___1 = EVP_sha1();
#line 360
      mac->md = (EVP_MD *)tmp___1;
    } else {
#line 361
      if (0) {
#line 361
        __s1_len = strlen((char const   *)name);
#line 361
        __s2_len = strlen("hmac-ripemd160@openssh.com");
#line 361
        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
          goto _L___0;
        } else {
#line 361
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 361
            if (! ((unsigned int )((void const   *)("hmac-ripemd160@openssh.com" + 1)) - (unsigned int )((void const   *)"hmac-ripemd160@openssh.com") == 1U)) {
#line 361
              tmp___12 = 1;
            } else {
#line 361
              if (__s2_len >= 4U) {
#line 361
                tmp___12 = 1;
              } else {
#line 361
                tmp___12 = 0;
              }
            }
          } else {
#line 361
            tmp___12 = 0;
          }
        }
#line 361
        if (tmp___12) {
#line 361
          tmp___8 = __builtin_strcmp((char const   *)name, "hmac-ripemd160@openssh.com");
        } else {
#line 361
          tmp___11 = __builtin_strcmp((char const   *)name, "hmac-ripemd160@openssh.com");
#line 361
          tmp___8 = tmp___11;
        }
      } else {
#line 361
        tmp___11 = __builtin_strcmp((char const   *)name, "hmac-ripemd160@openssh.com");
#line 361
        tmp___8 = tmp___11;
      }
#line 361
      if (tmp___8 == 0) {
#line 362
        tmp___2 = EVP_ripemd160();
#line 362
        mac->md = (EVP_MD *)tmp___2;
      } else {
#line 364
        fatal("unsupported mac %s", name);
      }
    }
  }
#line 366
  mac->name = name;
#line 367
  mac->mac_len = (mac->md)->md_size;
#line 368
  if (datafellows & 4) {
#line 368
    mac->key_len = 16;
  } else {
#line 368
    mac->key_len = mac->mac_len;
  }
#line 369
  mac->key = (unsigned char *)((void *)0);
#line 370
  mac->enabled = 0;
#line 371
  return;
}
}
#line 372 "kex.c"
void choose_comp(Comp *comp , char *client , char *server ) 
{ char *name ;
  char *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 375
  tmp = get_match(client, server);
#line 375
  name = tmp;
#line 376
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 377
    fatal("no matching comp found: client %s server %s", client, server);
  }
#line 378
  if (0) {
#line 378
    __s1_len___0 = strlen((char const   *)name);
#line 378
    __s2_len___0 = strlen("zlib");
#line 378
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___2;
    } else {
#line 378
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 378
        if (! ((unsigned int )((void const   *)("zlib" + 1)) - (unsigned int )((void const   *)"zlib") == 1U)) {
#line 378
          tmp___19 = 1;
        } else {
#line 378
          if (__s2_len___0 >= 4U) {
#line 378
            tmp___19 = 1;
          } else {
#line 378
            tmp___19 = 0;
          }
        }
      } else {
#line 378
        tmp___19 = 0;
      }
    }
#line 378
    if (tmp___19) {
#line 378
      tmp___15 = __builtin_strcmp((char const   *)name, "zlib");
    } else {
#line 378
      tmp___18 = __builtin_strcmp((char const   *)name, "zlib");
#line 378
      tmp___15 = tmp___18;
    }
  } else {
#line 378
    tmp___18 = __builtin_strcmp((char const   *)name, "zlib");
#line 378
    tmp___15 = tmp___18;
  }
#line 378
  if (tmp___15 == 0) {
#line 379
    comp->type = 1;
  } else {
#line 380
    if (0) {
#line 380
      __s1_len = strlen((char const   *)name);
#line 380
      __s2_len = strlen("none");
#line 380
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___0;
      } else {
#line 380
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 380
          if (! ((unsigned int )((void const   *)("none" + 1)) - (unsigned int )((void const   *)"none") == 1U)) {
#line 380
            tmp___9 = 1;
          } else {
#line 380
            if (__s2_len >= 4U) {
#line 380
              tmp___9 = 1;
            } else {
#line 380
              tmp___9 = 0;
            }
          }
        } else {
#line 380
          tmp___9 = 0;
        }
      }
#line 380
      if (tmp___9) {
#line 380
        tmp___5 = __builtin_strcmp((char const   *)name, "none");
      } else {
#line 380
        tmp___8 = __builtin_strcmp((char const   *)name, "none");
#line 380
        tmp___5 = tmp___8;
      }
    } else {
#line 380
      tmp___8 = __builtin_strcmp((char const   *)name, "none");
#line 380
      tmp___5 = tmp___8;
    }
#line 380
    if (tmp___5 == 0) {
#line 381
      comp->type = 0;
    } else {
#line 383
      fatal("unsupported comp %s", name);
    }
  }
#line 385
  comp->name = name;
#line 386
  return;
}
}
#line 387 "kex.c"
void choose_kex(Kex *k , char *client , char *server ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 390
  k->name = get_match(client, server);
#line 391
  if ((unsigned int )k->name == (unsigned int )((void *)0)) {
#line 392
    fatal("no kex alg");
  }
#line 393
  if (0) {
#line 393
    __s1_len = strlen((char const   *)k->name);
#line 393
    __s2_len = strlen("diffie-hellman-group1-sha1");
#line 393
    if (! ((unsigned int )((void const   *)(k->name + 1)) - (unsigned int )((void const   *)k->name) == 1U)) {
      goto _L___0;
    } else {
#line 393
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 393
        if (! ((unsigned int )((void const   *)("diffie-hellman-group1-sha1" + 1)) - (unsigned int )((void const   *)"diffie-hellman-group1-sha1") == 1U)) {
#line 393
          tmp___8 = 1;
        } else {
#line 393
          if (__s2_len >= 4U) {
#line 393
            tmp___8 = 1;
          } else {
#line 393
            tmp___8 = 0;
          }
        }
      } else {
#line 393
        tmp___8 = 0;
      }
    }
#line 393
    if (tmp___8) {
#line 393
      tmp___4 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
    } else {
#line 393
      tmp___7 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
#line 393
      tmp___4 = tmp___7;
    }
  } else {
#line 393
    tmp___7 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
#line 393
    tmp___4 = tmp___7;
  }
#line 393
  if (tmp___4 != 0) {
#line 394
    fatal("bad kex alg %s", k->name);
  }
#line 395
  return;
}
}
#line 396 "kex.c"
void choose_hostkeyalg(Kex *k , char *client , char *server ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 399
  k->hostkeyalg = get_match(client, server);
#line 400
  if ((unsigned int )k->hostkeyalg == (unsigned int )((void *)0)) {
#line 401
    fatal("no hostkey alg");
  }
#line 402
  if (0) {
#line 402
    __s1_len = strlen((char const   *)k->hostkeyalg);
#line 402
    __s2_len = strlen("ssh-dss");
#line 402
    if (! ((unsigned int )((void const   *)(k->hostkeyalg + 1)) - (unsigned int )((void const   *)k->hostkeyalg) == 1U)) {
      goto _L___0;
    } else {
#line 402
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 402
        if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
#line 402
          tmp___8 = 1;
        } else {
#line 402
          if (__s2_len >= 4U) {
#line 402
            tmp___8 = 1;
          } else {
#line 402
            tmp___8 = 0;
          }
        }
      } else {
#line 402
        tmp___8 = 0;
      }
    }
#line 402
    if (tmp___8) {
#line 402
      tmp___4 = __builtin_strcmp((char const   *)k->hostkeyalg, "ssh-dss");
    } else {
#line 402
      tmp___7 = __builtin_strcmp((char const   *)k->hostkeyalg, "ssh-dss");
#line 402
      tmp___4 = tmp___7;
    }
  } else {
#line 402
    tmp___7 = __builtin_strcmp((char const   *)k->hostkeyalg, "ssh-dss");
#line 402
    tmp___4 = tmp___7;
  }
#line 402
  if (tmp___4 != 0) {
#line 403
    fatal("bad hostkey alg %s", k->hostkeyalg);
  }
#line 404
  return;
}
}
#line 406 "kex.c"
Kex *kex_choose_conf(char **cprop , char **sprop , int server ) 
{ int mode ;
  int ctos ;
  int need ;
  Kex *k ;
  void *tmp ;
  int nenc ;
  int nmac ;
  int ncomp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 414
  tmp = xmalloc(sizeof(*k));
#line 414
  k = (Kex *)tmp;
#line 415
  memset((void *)k, 0, sizeof(*k));
#line 416
  k->server = server;
#line 418
  mode = 0;
#line 418
  while (mode < 2) {
#line 420
    if (! k->server) {
#line 420
      if (mode == 1) {
#line 420
        tmp___0 = 1;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 420
      if (k->server) {
#line 420
        if (mode == 0) {
#line 420
          tmp___0 = 1;
        } else {
#line 420
          tmp___0 = 0;
        }
      } else {
#line 420
        tmp___0 = 0;
      }
    }
#line 420
    ctos = tmp___0;
#line 421
    if (ctos) {
#line 421
      nenc = 2;
    } else {
#line 421
      nenc = 3;
    }
#line 422
    if (ctos) {
#line 422
      nmac = 4;
    } else {
#line 422
      nmac = 5;
    }
#line 423
    if (ctos) {
#line 423
      ncomp = 6;
    } else {
#line 423
      ncomp = 7;
    }
#line 424
    choose_enc(& k->enc[mode], *(cprop + nenc), *(sprop + nenc));
#line 425
    choose_mac(& k->mac[mode], *(cprop + nmac), *(sprop + nmac));
#line 426
    choose_comp(& k->comp[mode], *(cprop + ncomp), *(sprop + ncomp));
#line 427
    if (ctos) {
#line 427
      tmp___1 = "client->server";
    } else {
#line 427
      tmp___1 = "server->client";
    }
#line 427
    debug("kex: %s %s %s %s", tmp___1, k->enc[mode].name, k->mac[mode].name, k->comp[mode].name);
#line 418
    mode ++;
  }
#line 433
  choose_kex(k, *(cprop + 0), *(sprop + 0));
#line 434
  choose_hostkeyalg(k, *(cprop + 1), *(sprop + 1));
#line 436
  need = 0;
#line 437
  mode = 0;
#line 437
  while (mode < 2) {
#line 438
    if (need < k->enc[mode].key_len) {
#line 439
      need = k->enc[mode].key_len;
    }
#line 440
    if (need < k->enc[mode].iv_len) {
#line 441
      need = k->enc[mode].iv_len;
    }
#line 442
    if (need < k->mac[mode].key_len) {
#line 443
      need = k->mac[mode].key_len;
    }
#line 437
    mode ++;
  }
#line 446
  k->we_need = need;
#line 447
  return (k);
}
}
#line 450 "kex.c"
int kex_derive_keys(Kex *k , unsigned char *hash , BIGNUM *shared_secret ) 
{ int i ;
  int mode ;
  int ctos ;
  unsigned char *keys[6] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 458
  i = 0;
#line 458
  while (i < 6) {
#line 459
    keys[i] = derive_key(65 + i, k->we_need, hash, shared_secret);
#line 458
    i ++;
  }
#line 461
  mode = 0;
#line 461
  while (mode < 2) {
#line 462
    if (! k->server) {
#line 462
      if (mode == 1) {
#line 462
        tmp = 1;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 462
      if (k->server) {
#line 462
        if (mode == 0) {
#line 462
          tmp = 1;
        } else {
#line 462
          tmp = 0;
        }
      } else {
#line 462
        tmp = 0;
      }
    }
#line 462
    ctos = tmp;
#line 463
    if (ctos) {
#line 463
      tmp___0 = 0;
    } else {
#line 463
      tmp___0 = 1;
    }
#line 463
    k->enc[mode].iv = keys[tmp___0];
#line 464
    if (ctos) {
#line 464
      tmp___1 = 2;
    } else {
#line 464
      tmp___1 = 3;
    }
#line 464
    k->enc[mode].key = keys[tmp___1];
#line 465
    if (ctos) {
#line 465
      tmp___2 = 4;
    } else {
#line 465
      tmp___2 = 5;
    }
#line 465
    k->mac[mode].key = keys[tmp___2];
#line 461
    mode ++;
  }
#line 467
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 1 "log.o"
#pragma merger(0,"./log.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 325 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 646 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 455 "ssh.h"
void do_log(LogLevel level , char const   *fmt , va_list args ) ;
#line 458
SyslogFacility log_facility_number(char *name ) ;
#line 459
LogLevel log_level_number(char *name ) ;
#line 479
void fatal_remove_cleanup(void (*proc)(void *context ) , void *context ) ;
#line 13 "log.c"
void ( /* format attribute */  fatal)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 17
  __builtin_va_start(args, fmt);
#line 18
  do_log(1, fmt, args);
#line 19
  __builtin_va_end(args);
#line 20
  fatal_cleanup();
#line 21
  return;
}
}
#line 25 "log.c"
void ( /* format attribute */  error)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 29
  __builtin_va_start(args, fmt);
#line 30
  do_log(2, fmt, args);
#line 31
  __builtin_va_end(args);
#line 32
  return;
}
}
#line 36 "log.c"
void ( /* format attribute */  log)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 40
  __builtin_va_start(args, fmt);
#line 41
  do_log(3, fmt, args);
#line 42
  __builtin_va_end(args);
#line 43
  return;
}
}
#line 47 "log.c"
void ( /* format attribute */  verbose)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 51
  __builtin_va_start(args, fmt);
#line 52
  do_log(4, fmt, args);
#line 53
  __builtin_va_end(args);
#line 54
  return;
}
}
#line 58 "log.c"
void ( /* format attribute */  debug)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 62
  __builtin_va_start(args, fmt);
#line 63
  do_log(5, fmt, args);
#line 64
  __builtin_va_end(args);
#line 65
  return;
}
}
#line 75 "log.c"
static struct fatal_cleanup *fatal_cleanups  =    (struct fatal_cleanup *)((void *)0);
#line 79 "log.c"
void fatal_add_cleanup(void (*proc)(void *context ) , void *context ) 
{ struct fatal_cleanup *cu ;
  void *tmp ;

  {
#line 84
  tmp = xmalloc(sizeof(*cu));
#line 84
  cu = (struct fatal_cleanup *)tmp;
#line 85
  cu->proc = proc;
#line 86
  cu->context = context;
#line 87
  cu->next = fatal_cleanups;
#line 88
  fatal_cleanups = cu;
#line 89
  return;
}
}
#line 93 "log.c"
void fatal_remove_cleanup(void (*proc)(void *context ) , void *context ) 
{ struct fatal_cleanup **cup ;
  struct fatal_cleanup *cu ;

  {
#line 98
  cup = & fatal_cleanups;
#line 98
  while (*cup) {
#line 99
    cu = *cup;
#line 100
    if ((unsigned int )cu->proc == (unsigned int )proc) {
#line 100
      if ((unsigned int )cu->context == (unsigned int )context) {
#line 101
        *cup = cu->next;
#line 102
        xfree((void *)cu);
#line 103
        return;
      }
    }
#line 98
    cup = & cu->next;
  }
#line 106
  fatal("fatal_remove_cleanup: no such cleanup function: 0x%lx 0x%lx\n", (unsigned long )proc,
        (unsigned long )context);
#line 108
  return;
}
}
#line 115 "log.c"
static int called  =    0;
#line 111 "log.c"
void fatal_cleanup(void) 
{ struct fatal_cleanup *cu ;
  struct fatal_cleanup *next_cu ;

  {
#line 117
  if (called) {
#line 118
    exit(255);
  }
#line 119
  called = 1;
#line 121
  cu = fatal_cleanups;
#line 121
  while (cu) {
#line 122
    next_cu = cu->next;
#line 123
    debug("Calling cleanup 0x%lx(0x%lx)", (unsigned long )cu->proc, (unsigned long )cu->context);
#line 125
    (*(cu->proc))(cu->context);
#line 121
    cu = next_cu;
  }
#line 127
  exit(255);
}
}
#line 132 "log.c"
static struct __anonstruct_log_facilities_74 log_facilities[12]  = 
#line 132
  {      {"DAEMON", 0}, 
        {"USER", 1}, 
        {"AUTH", 2}, 
        {"LOCAL0", 3}, 
        {"LOCAL1", 4}, 
        {"LOCAL2", 5}, 
        {"LOCAL3", 6}, 
        {"LOCAL4", 7}, 
        {"LOCAL5", 8}, 
        {"LOCAL6", 9}, 
        {"LOCAL7", 10}, 
        {(char const   *)((void *)0), (SyslogFacility )0}};
#line 150 "log.c"
static struct __anonstruct_log_levels_75 log_levels[7]  = {      {"QUIET", 0}, 
        {"FATAL", 1}, 
        {"ERROR", 2}, 
        {"INFO", 3}, 
        {"VERBOSE", 4}, 
        {"DEBUG", 5}, 
        {(char const   *)((void *)0), (LogLevel )0}};
#line 164 "log.c"
SyslogFacility log_facility_number(char *name ) 
{ int i ;
  int tmp ;

  {
#line 168
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 169
    i = 0;
#line 169
    while (log_facilities[i].name) {
#line 170
      tmp = strcasecmp(log_facilities[i].name, (char const   *)name);
#line 170
      if (tmp == 0) {
#line 171
        return (log_facilities[i].val);
      }
#line 169
      i ++;
    }
  }
#line 172
  return ((enum __anonenum_SyslogFacility_72 )-1);
}
}
#line 175 "log.c"
LogLevel log_level_number(char *name ) 
{ int i ;
  int tmp ;

  {
#line 179
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 180
    i = 0;
#line 180
    while (log_levels[i].name) {
#line 181
      tmp = strcasecmp(log_levels[i].name, (char const   *)name);
#line 181
      if (tmp == 0) {
#line 182
        return (log_levels[i].val);
      }
#line 180
      i ++;
    }
  }
#line 183
  return ((enum __anonenum_LogLevel_73 )-1);
}
}
#line 1 "match.o"
#pragma merger(0,"./match.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 116 "/usr/include/ctype.h"
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 26 "match.c"
int match_pattern(char const   *s , char const   *pattern ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 29
  while (1) {
#line 31
    if (! *pattern) {
#line 32
      return (! *s);
    }
#line 34
    if ((int const   )*pattern == 42) {
#line 36
      pattern ++;
#line 39
      if (! *pattern) {
#line 40
        return (1);
      }
#line 43
      if ((int const   )*pattern != 63) {
#line 43
        if ((int const   )*pattern != 42) {
#line 49
          while (*s) {
#line 50
            if ((int const   )*s == (int const   )*pattern) {
#line 50
              tmp = match_pattern(s + 1, pattern + 1);
#line 50
              if (tmp) {
#line 52
                return (1);
              }
            }
#line 49
            s ++;
          }
#line 54
          return (0);
        }
      }
#line 60
      while (*s) {
#line 61
        tmp___0 = match_pattern(s, pattern);
#line 61
        if (tmp___0) {
#line 62
          return (1);
        }
#line 60
        s ++;
      }
#line 64
      return (0);
    }
#line 70
    if (! *s) {
#line 71
      return (0);
    }
#line 74
    if ((int const   )*pattern != 63) {
#line 74
      if ((int const   )*pattern != (int const   )*s) {
#line 75
        return (0);
      }
    }
#line 78
    s ++;
#line 79
    pattern ++;
  }
}
}
#line 91 "match.c"
int match_hostname(char const   *host , char const   *pattern , unsigned int len ) 
{ char sub[1024] ;
  int negated ;
  int got_positive ;
  unsigned int i ;
  unsigned int subi ;
  int __res___0 ;
  __int32_t const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;

  {
#line 99
  got_positive = 0;
#line 100
  i = 0U;
#line 100
  while (i < len) {
#line 102
    if ((int const   )*(pattern + i) == 33) {
#line 103
      negated = 1;
#line 104
      i ++;
    } else {
#line 106
      negated = 0;
    }
#line 112
    subi = 0U;
#line 112
    while (1) {
#line 112
      if (i < len) {
#line 112
        if (subi < sizeof(sub) - 1U) {
#line 112
          if (! ((int const   )*(pattern + i) != 44)) {
#line 112
            break;
          }
        } else {
#line 112
          break;
        }
      } else {
#line 112
        break;
      }
#line 115
      tmp___6 = __ctype_b_loc();
#line 115
      if ((int const   )*(*tmp___6 + (int )*(pattern + i)) & 256) {
#line 115
        if (sizeof(*(pattern + i)) > 1U) {
#line 115
          __res___0 = tolower((int )*(pattern + i));
        } else {
#line 115
          tmp___5 = __ctype_tolower_loc();
#line 115
          __res___0 = (int )*(*tmp___5 + (int )*(pattern + i));
        }
#line 115
        sub[subi] = (char )__res___0;
      } else {
#line 115
        sub[subi] = (char )*(pattern + i);
      }
#line 112
      subi ++;
#line 112
      i ++;
    }
#line 117
    if (subi >= sizeof(sub) - 1U) {
#line 118
      return (0);
    }
#line 121
    if (i < len) {
#line 121
      if ((int const   )*(pattern + i) == 44) {
#line 122
        i ++;
      }
    }
#line 125
    sub[subi] = (char )'\000';
#line 128
    tmp___7 = match_pattern(host, (char const   *)(sub));
#line 128
    if (tmp___7) {
#line 129
      if (negated) {
#line 130
        return (0);
      } else {
#line 132
        got_positive = 1;
      }
    }
  }
#line 140
  return (got_positive);
}
}
#line 1 "mpaux.o"
#pragma merger(0,"./mpaux.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 26 "mpaux.c"
void compute_session_id(unsigned char *session_id___0 , unsigned char *cookie , BIGNUM *host_key_n ,
                        BIGNUM *session_key_n ) 
{ unsigned int host_key_bytes ;
  int tmp ;
  unsigned int session_key_bytes ;
  int tmp___0 ;
  unsigned int bytes ;
  unsigned char *buf___1 ;
  void *tmp___1 ;
  MD5_CTX md ;

  {
#line 32
  tmp = BN_num_bits((BIGNUM const   *)host_key_n);
#line 32
  host_key_bytes = (unsigned int )((tmp + 7) / 8);
#line 33
  tmp___0 = BN_num_bits((BIGNUM const   *)session_key_n);
#line 33
  session_key_bytes = (unsigned int )((tmp___0 + 7) / 8);
#line 34
  bytes = host_key_bytes + session_key_bytes;
#line 35
  tmp___1 = xmalloc(bytes);
#line 35
  buf___1 = (unsigned char *)tmp___1;
#line 38
  BN_bn2bin((BIGNUM const   *)host_key_n, buf___1);
#line 39
  BN_bn2bin((BIGNUM const   *)session_key_n, buf___1 + host_key_bytes);
#line 40
  MD5_Init(& md);
#line 41
  MD5_Update(& md, (void const   *)buf___1, bytes);
#line 42
  MD5_Update(& md, (void const   *)cookie, 8U);
#line 43
  MD5_Final((unsigned char *)session_id___0, & md);
#line 44
  memset((void *)buf___1, 0, bytes);
#line 45
  xfree((void *)buf___1);
#line 46
  return;
}
}
#line 1 "nchan.o"
#pragma merger(0,"./nchan.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 48 "nchan.c"
chan_event_fn *chan_rcvd_oclose  =    (chan_event_fn *)((void *)0);
#line 49 "nchan.c"
chan_event_fn *chan_read_failed  =    (chan_event_fn *)((void *)0);
#line 50 "nchan.c"
chan_event_fn *chan_ibuf_empty  =    (chan_event_fn *)((void *)0);
#line 52 "nchan.c"
chan_event_fn *chan_rcvd_ieof  =    (chan_event_fn *)((void *)0);
#line 53 "nchan.c"
chan_event_fn *chan_write_failed  =    (chan_event_fn *)((void *)0);
#line 54 "nchan.c"
chan_event_fn *chan_obuf_empty  =    (chan_event_fn *)((void *)0);
#line 58
static void chan_send_ieof1(Channel *c ) ;
#line 59
static void chan_send_oclose1(Channel *c ) ;
#line 60
static void chan_send_close2(Channel *c ) ;
#line 61
static void chan_send_eof2(Channel *c ) ;
#line 64 "nchan.c"
chan_event_fn *chan_delete_if_full_closed  =    (chan_event_fn *)((void *)0);
#line 67
static void chan_shutdown_write(Channel *c ) ;
#line 68
static void chan_shutdown_read(Channel *c ) ;
#line 74 "nchan.c"
static void chan_rcvd_oclose1(Channel *c ) 
{ 

  {
#line 77
  debug("channel %d: rcvd oclose", c->self);
#line 78
  switch (c->istate) {
  case 4: 
#line 80
  debug("channel %d: input wait_oclose -> closed", c->self);
#line 81
  c->istate = 8;
#line 82
  break;
  case 1: 
#line 84
  debug("channel %d: input open -> closed", c->self);
#line 85
  chan_shutdown_read(c);
#line 86
  chan_send_ieof1(c);
#line 87
  c->istate = 8;
#line 88
  break;
  case 2: 
#line 91
  log("channel %d: input drain -> closed", c->self);
#line 92
  chan_send_ieof1(c);
#line 93
  c->istate = 8;
#line 94
  break;
  default: 
#line 96
  error("channel %d: protocol error: chan_rcvd_oclose for istate %d", c->self, c->istate);
#line 98
  return;
  }
#line 100
  return;
}
}
#line 101 "nchan.c"
static void chan_read_failed_12(Channel *c ) 
{ unsigned int tmp ;

  {
#line 104
  debug("channel %d: read failed", c->self);
#line 105
  switch (c->istate) {
  case 1: 
#line 107
  debug("channel %d: input open -> drain", c->self);
#line 108
  chan_shutdown_read(c);
#line 109
  c->istate = 2;
#line 110
  tmp = buffer_len(& c->input);
#line 110
  if (tmp == 0U) {
#line 111
    debug("channel %d: input: no drain shortcut", c->self);
#line 112
    (*chan_ibuf_empty)(c);
  }
#line 114
  break;
  default: 
#line 116
  error("channel %d: internal error: we do not read, but chan_read_failed for istate %d",
        c->self, c->istate);
#line 118
  break;
  }
#line 120
  return;
}
}
#line 121 "nchan.c"
static void chan_ibuf_empty1(Channel *c ) 
{ unsigned int tmp ;

  {
#line 124
  debug("channel %d: ibuf empty", c->self);
#line 125
  tmp = buffer_len(& c->input);
#line 125
  if (tmp) {
#line 126
    error("channel %d: internal error: chan_ibuf_empty for non empty buffer", c->self);
#line 128
    return;
  }
#line 130
  switch (c->istate) {
  case 2: 
#line 132
  debug("channel %d: input drain -> wait_oclose", c->self);
#line 133
  chan_send_ieof1(c);
#line 134
  c->istate = 4;
#line 135
  break;
  default: 
#line 137
  error("channel %d: internal error: chan_ibuf_empty for istate %d", c->self, c->istate);
#line 139
  break;
  }
#line 141
  return;
}
}
#line 142 "nchan.c"
static void chan_rcvd_ieof1(Channel *c ) 
{ 

  {
#line 145
  debug("channel %d: rcvd ieof", c->self);
#line 146
  if (c->type != 4) {
#line 147
    debug("channel %d: non-open", c->self);
#line 148
    if (c->istate == 1) {
#line 149
      debug("channel %d: non-open: input open -> wait_oclose", c->self);
#line 150
      chan_shutdown_read(c);
#line 151
      chan_send_ieof1(c);
#line 152
      c->istate = 4;
    } else {
#line 154
      error("channel %d: istate %d != open", c->self, c->istate);
    }
#line 156
    if (c->ostate == 16) {
#line 157
      debug("channel %d: non-open: output open -> closed", c->self);
#line 158
      chan_send_oclose1(c);
#line 159
      c->ostate = 128;
    } else {
#line 161
      error("channel %d: ostate %d != open", c->self, c->ostate);
    }
#line 163
    return;
  }
#line 165
  switch (c->ostate) {
  case 16: 
#line 167
  debug("channel %d: output open -> drain", c->self);
#line 168
  c->ostate = 32;
#line 169
  break;
  case 64: 
#line 171
  debug("channel %d: output wait_ieof -> closed", c->self);
#line 172
  c->ostate = 128;
#line 173
  break;
  default: 
#line 175
  error("channel %d: protocol error: chan_rcvd_ieof for ostate %d", c->self, c->ostate);
#line 177
  break;
  }
#line 179
  return;
}
}
#line 180 "nchan.c"
static void chan_write_failed1(Channel *c ) 
{ 

  {
#line 183
  debug("channel %d: write failed", c->self);
#line 184
  switch (c->ostate) {
  case 16: 
#line 186
  debug("channel %d: output open -> wait_ieof", c->self);
#line 187
  chan_send_oclose1(c);
#line 188
  c->ostate = 64;
#line 189
  break;
  case 32: 
#line 191
  debug("channel %d: output wait_drain -> closed", c->self);
#line 192
  chan_send_oclose1(c);
#line 193
  c->ostate = 128;
#line 194
  break;
  default: 
#line 196
  error("channel %d: internal error: chan_write_failed for ostate %d", c->self, c->ostate);
#line 198
  break;
  }
#line 200
  return;
}
}
#line 201 "nchan.c"
static void chan_obuf_empty1(Channel *c ) 
{ unsigned int tmp ;

  {
#line 204
  debug("channel %d: obuf empty", c->self);
#line 205
  tmp = buffer_len(& c->output);
#line 205
  if (tmp) {
#line 206
    error("channel %d: internal error: chan_obuf_empty for non empty buffer", c->self);
#line 208
    return;
  }
#line 210
  switch (c->ostate) {
  case 32: 
#line 212
  debug("channel %d: output drain -> closed", c->self);
#line 213
  chan_send_oclose1(c);
#line 214
  c->ostate = 128;
#line 215
  break;
  default: 
#line 217
  error("channel %d: internal error: chan_obuf_empty for ostate %d", c->self, c->ostate);
#line 219
  break;
  }
#line 221
  return;
}
}
#line 222 "nchan.c"
static void chan_send_ieof1(Channel *c ) 
{ 

  {
#line 225
  debug("channel %d: send ieof", c->self);
#line 226
  switch (c->istate) {
  case 1: 
  case 2: 
#line 229
  packet_start(24);
#line 230
  packet_put_int((unsigned int )c->remote_id);
#line 231
  packet_send();
#line 232
  break;
  default: 
#line 234
  error("channel %d: internal error: cannot send ieof for istate %d", c->self, c->istate);
#line 236
  break;
  }
#line 238
  return;
}
}
#line 239 "nchan.c"
static void chan_send_oclose1(Channel *c ) 
{ unsigned int tmp ;

  {
#line 242
  debug("channel %d: send oclose", c->self);
#line 243
  switch (c->ostate) {
  case 16: 
  case 32: 
#line 246
  chan_shutdown_write(c);
#line 247
  tmp = buffer_len(& c->output);
#line 247
  buffer_consume(& c->output, tmp);
#line 248
  packet_start(25);
#line 249
  packet_put_int((unsigned int )c->remote_id);
#line 250
  packet_send();
#line 251
  break;
  default: 
#line 253
  error("channel %d: internal error: cannot send oclose for ostate %d", c->self, c->ostate);
#line 255
  break;
  }
#line 257
  return;
}
}
#line 258 "nchan.c"
static void chan_delete_if_full_closed1(Channel *c ) 
{ 

  {
#line 261
  if (c->istate == 8) {
#line 261
    if (c->ostate == 128) {
#line 262
      debug("channel %d: full closed", c->self);
#line 263
      channel_free(c->self);
    }
  }
#line 265
  return;
}
}
#line 270 "nchan.c"
static void chan_rcvd_oclose2(Channel *c ) 
{ 

  {
#line 273
  debug("channel %d: rcvd close", c->self);
#line 274
  if (c->flags & 2) {
#line 275
    error("channel %d: protocol error: close rcvd twice", c->self);
  }
#line 276
  c->flags |= 2;
#line 277
  if (c->type == 10) {
#line 279
    c->ostate = 128;
#line 280
    c->istate = 8;
#line 281
    return;
  }
#line 283
  switch (c->ostate) {
  case 16: 
#line 286
  debug("channel %d: output open -> drain", c->self);
#line 287
  c->ostate = 32;
#line 288
  break;
  }
#line 290
  switch (c->istate) {
  case 1: 
#line 292
  debug("channel %d: input open -> closed", c->self);
#line 293
  chan_shutdown_read(c);
#line 294
  break;
  case 2: 
#line 296
  debug("channel %d: input drain -> closed", c->self);
#line 297
  chan_send_eof2(c);
#line 298
  break;
  }
#line 300
  c->istate = 8;
#line 301
  return;
}
}
#line 302 "nchan.c"
static void chan_ibuf_empty2(Channel *c ) 
{ unsigned int tmp ;

  {
#line 305
  debug("channel %d: ibuf empty", c->self);
#line 306
  tmp = buffer_len(& c->input);
#line 306
  if (tmp) {
#line 307
    error("channel %d: internal error: chan_ibuf_empty for non empty buffer", c->self);
#line 309
    return;
  }
#line 311
  switch (c->istate) {
  case 2: 
#line 313
  debug("channel %d: input drain -> closed", c->self);
#line 314
  if (! (c->flags & 1)) {
#line 315
    chan_send_eof2(c);
  }
#line 316
  c->istate = 8;
#line 317
  break;
  default: 
#line 319
  error("channel %d: internal error: chan_ibuf_empty for istate %d", c->self, c->istate);
#line 321
  break;
  }
#line 323
  return;
}
}
#line 324 "nchan.c"
static void chan_rcvd_ieof2(Channel *c ) 
{ 

  {
#line 327
  debug("channel %d: rcvd eof", c->self);
#line 328
  if (c->ostate == 16) {
#line 329
    debug("channel %d: output open -> drain", c->self);
#line 330
    c->ostate = 32;
  }
#line 332
  return;
}
}
#line 333 "nchan.c"
static void chan_write_failed2(Channel *c ) 
{ 

  {
#line 336
  debug("channel %d: write failed", c->self);
#line 337
  switch (c->ostate) {
  case 16: 
#line 339
  debug("channel %d: output open -> closed", c->self);
#line 340
  chan_shutdown_write(c);
#line 341
  c->ostate = 128;
#line 342
  break;
  case 32: 
#line 344
  debug("channel %d: output drain -> closed", c->self);
#line 345
  chan_shutdown_write(c);
#line 346
  c->ostate = 128;
#line 347
  break;
  default: 
#line 349
  error("channel %d: internal error: chan_write_failed for ostate %d", c->self, c->ostate);
#line 351
  break;
  }
#line 353
  return;
}
}
#line 354 "nchan.c"
static void chan_obuf_empty2(Channel *c ) 
{ unsigned int tmp ;

  {
#line 357
  debug("channel %d: obuf empty", c->self);
#line 358
  tmp = buffer_len(& c->output);
#line 358
  if (tmp) {
#line 359
    error("internal error: chan_obuf_empty %d for non empty buffer", c->self);
#line 361
    return;
  }
#line 363
  switch (c->ostate) {
  case 32: 
#line 365
  debug("channel %d: output drain -> closed", c->self);
#line 366
  chan_shutdown_write(c);
#line 367
  c->ostate = 128;
#line 368
  break;
  default: 
#line 370
  error("channel %d: internal error: chan_obuf_empty for ostate %d", c->self, c->ostate);
#line 372
  break;
  }
#line 374
  return;
}
}
#line 375 "nchan.c"
static void chan_send_eof2(Channel *c ) 
{ 

  {
#line 378
  debug("channel %d: send eof", c->self);
#line 379
  switch (c->istate) {
  case 2: 
#line 381
  packet_start(96);
#line 382
  packet_put_int((unsigned int )c->remote_id);
#line 383
  packet_send();
#line 384
  break;
  default: 
#line 386
  error("channel %d: internal error: cannot send eof for istate %d", c->self, c->istate);
#line 388
  break;
  }
#line 390
  return;
}
}
#line 391 "nchan.c"
static void chan_send_close2(Channel *c ) 
{ 

  {
#line 394
  debug("channel %d: send close", c->self);
#line 395
  if (c->ostate != 128) {
#line 397
    error("channel %d: internal error: cannot send close for istate/ostate %d/%d",
          c->self, c->istate, c->ostate);
  } else {
#line 395
    if (c->istate != 8) {
#line 397
      error("channel %d: internal error: cannot send close for istate/ostate %d/%d",
            c->self, c->istate, c->ostate);
    } else {
#line 399
      if (c->flags & 1) {
#line 400
        error("channel %d: internal error: already sent close", c->self);
      } else {
#line 402
        packet_start(97);
#line 403
        packet_put_int((unsigned int )c->remote_id);
#line 404
        packet_send();
#line 405
        c->flags |= 1;
      }
    }
  }
#line 407
  return;
}
}
#line 408 "nchan.c"
static void chan_delete_if_full_closed2(Channel *c ) 
{ 

  {
#line 411
  if (c->istate == 8) {
#line 411
    if (c->ostate == 128) {
#line 412
      if (! (c->flags & 1)) {
#line 413
        chan_send_close2(c);
      }
#line 415
      if (c->flags & 1) {
#line 415
        if (c->flags & 2) {
#line 417
          debug("channel %d: full closed2", c->self);
#line 418
          channel_free(c->self);
        }
      }
    }
  }
#line 421
  return;
}
}
#line 424 "nchan.c"
void chan_init_iostates(Channel *c ) 
{ 

  {
#line 427
  c->ostate = 16;
#line 428
  c->istate = 1;
#line 429
  c->flags = 0;
#line 430
  return;
}
}
#line 433 "nchan.c"
void chan_init(void) 
{ 

  {
#line 436
  if (compat20) {
#line 437
    chan_rcvd_oclose = & chan_rcvd_oclose2;
#line 438
    chan_read_failed = & chan_read_failed_12;
#line 439
    chan_ibuf_empty = & chan_ibuf_empty2;
#line 441
    chan_rcvd_ieof = & chan_rcvd_ieof2;
#line 442
    chan_write_failed = & chan_write_failed2;
#line 443
    chan_obuf_empty = & chan_obuf_empty2;
#line 445
    chan_delete_if_full_closed = & chan_delete_if_full_closed2;
  } else {
#line 447
    chan_rcvd_oclose = & chan_rcvd_oclose1;
#line 448
    chan_read_failed = & chan_read_failed_12;
#line 449
    chan_ibuf_empty = & chan_ibuf_empty1;
#line 451
    chan_rcvd_ieof = & chan_rcvd_ieof1;
#line 452
    chan_write_failed = & chan_write_failed1;
#line 453
    chan_obuf_empty = & chan_obuf_empty1;
#line 455
    chan_delete_if_full_closed = & chan_delete_if_full_closed1;
  }
#line 457
  return;
}
}
#line 460 "nchan.c"
static void chan_shutdown_write(Channel *c ) 
{ unsigned int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 463
  tmp = buffer_len(& c->output);
#line 463
  buffer_consume(& c->output, tmp);
#line 464
  if (compat20) {
#line 464
    if (c->type == 10) {
#line 465
      return;
    }
  }
#line 467
  debug("channel %d: close_write", c->self);
#line 468
  if (c->sock != -1) {
#line 469
    tmp___2 = shutdown(c->sock, 1);
#line 469
    if (tmp___2 < 0) {
#line 470
      tmp___0 = __errno_location();
#line 470
      tmp___1 = strerror(*tmp___0);
#line 470
      debug("channel %d: chan_shutdown_write: shutdown() failed for fd%d: %.100s",
            c->self, c->sock, tmp___1);
    }
  } else {
#line 473
    tmp___5 = close(c->wfd);
#line 473
    if (tmp___5 < 0) {
#line 474
      tmp___3 = __errno_location();
#line 474
      tmp___4 = strerror(*tmp___3);
#line 474
      log("channel %d: chan_shutdown_write: close() failed for fd%d: %.100s", c->self,
          c->wfd, tmp___4);
    }
#line 476
    c->wfd = -1;
  }
#line 478
  return;
}
}
#line 479 "nchan.c"
static void chan_shutdown_read(Channel *c ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 482
  if (compat20) {
#line 482
    if (c->type == 10) {
#line 483
      return;
    }
  }
#line 484
  debug("channel %d: close_read", c->self);
#line 485
  if (c->sock != -1) {
#line 486
    tmp___1 = shutdown(c->sock, 0);
#line 486
    if (tmp___1 < 0) {
#line 487
      tmp = __errno_location();
#line 487
      tmp___0 = strerror(*tmp);
#line 487
      error("channel %d: chan_shutdown_read: shutdown() failed for fd%d [i%d o%d]: %.100s",
            c->self, c->sock, c->istate, c->ostate, tmp___0);
    }
  } else {
#line 490
    tmp___4 = close(c->rfd);
#line 490
    if (tmp___4 < 0) {
#line 491
      tmp___2 = __errno_location();
#line 491
      tmp___3 = strerror(*tmp___2);
#line 491
      log("channel %d: chan_shutdown_read: close() failed for fd%d: %.100s", c->self,
          c->rfd, tmp___3);
    }
#line 493
    c->rfd = -1;
  }
#line 495
  return;
}
}
#line 1 "packet.o"
#pragma merger(0,"./packet.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 361 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 28 "packet.h"
void packet_set_connection(int fd_in , int fd_out ) ;
#line 31
void packet_set_nonblocking(void) ;
#line 37
int packet_get_connection_out(void) ;
#line 43
void packet_close(void) ;
#line 50
void packet_set_encryption_key(unsigned char const   *key , unsigned int keylen ,
                               int cipher ) ;
#line 58
void packet_set_protocol_flags(unsigned int protocol_flags ) ;
#line 61
unsigned int packet_get_protocol_flags(void) ;
#line 64
void packet_start_compression(int level ) ;
#line 70
void packet_set_interactive(int interactive , int keepalives ) ;
#line 85
void packet_put_bignum(BIGNUM *value ) ;
#line 86
void packet_put_bignum2(BIGNUM *value ) ;
#line 122
void packet_process_incoming(char const   *buf___1 , unsigned int len ) ;
#line 134
void packet_get_bignum(BIGNUM *value , int *length_ptr ) ;
#line 135
void packet_get_bignum2(BIGNUM *value , int *length_ptr ) ;
#line 164
void ( /* format attribute */  packet_send_debug)(char const   *fmt  , ...) ;
#line 167
void packet_write_poll(void) ;
#line 173
int packet_have_data_to_write(void) ;
#line 176
int packet_not_very_much_data_to_write(void) ;
#line 180
int packet_set_maxsize(int s ) ;
#line 211
int packet_connection_is_ipv4(void) ;
#line 214
void packet_set_ssh2_format(void) ;
#line 102 "kex.h"
void packet_set_kex(Kex *k ) ;
#line 57 "packet.c"
static int connection_in  =    -1;
#line 58 "packet.c"
static int connection_out  =    -1;
#line 64 "packet.c"
static int cipher_type  =    0;
#line 67 "packet.c"
static unsigned int remote_protocol_flags  =    0U;
#line 70 "packet.c"
static CipherContext receive_context  ;
#line 73 "packet.c"
static CipherContext send_context  ;
#line 76 "packet.c"
static Buffer input  ;
#line 79 "packet.c"
static Buffer output  ;
#line 82 "packet.c"
static Buffer outgoing_packet  ;
#line 85 "packet.c"
static Buffer incoming_packet  ;
#line 88 "packet.c"
static Buffer compression_buffer  ;
#line 91 "packet.c"
static int packet_compression  =    0;
#line 94 "packet.c"
int max_packet_size  =    32768;
#line 97 "packet.c"
static int initialized  =    0;
#line 100 "packet.c"
static int interactive_mode  =    0;
#line 103 "packet.c"
int use_ssh2_packet_format  =    0;
#line 106 "packet.c"
Kex *kex  =    (Kex *)((void *)0);
#line 108 "packet.c"
void packet_set_kex(Kex *k ) 
{ 

  {
#line 111
  if ((unsigned int )k->mac[0].key == (unsigned int )((void *)0)) {
#line 117
    fatal("bad KEX");
  } else {
#line 111
    if ((unsigned int )k->enc[0].key == (unsigned int )((void *)0)) {
#line 117
      fatal("bad KEX");
    } else {
#line 111
      if ((unsigned int )k->enc[0].iv == (unsigned int )((void *)0)) {
#line 117
        fatal("bad KEX");
      } else {
#line 111
        if ((unsigned int )k->mac[1].key == (unsigned int )((void *)0)) {
#line 117
          fatal("bad KEX");
        } else {
#line 111
          if ((unsigned int )k->enc[1].key == (unsigned int )((void *)0)) {
#line 117
            fatal("bad KEX");
          } else {
#line 111
            if ((unsigned int )k->enc[1].iv == (unsigned int )((void *)0)) {
#line 117
              fatal("bad KEX");
            }
          }
        }
      }
    }
  }
#line 118
  kex = k;
#line 119
  return;
}
}
#line 120 "packet.c"
void clear_enc_keys(Enc *enc , int len ) 
{ 

  {
#line 123
  memset((void *)enc->iv, 0, (unsigned int )len);
#line 124
  memset((void *)enc->key, 0, (unsigned int )len);
#line 125
  xfree((void *)enc->iv);
#line 126
  xfree((void *)enc->key);
#line 127
  enc->iv = (unsigned char *)((void *)0);
#line 128
  enc->key = (unsigned char *)((void *)0);
#line 129
  return;
}
}
#line 130 "packet.c"
void packet_set_ssh2_format(void) 
{ 

  {
#line 134
  use_ssh2_packet_format = 1;
#line 135
  return;
}
}
#line 141 "packet.c"
void packet_set_connection(int fd_in , int fd_out ) 
{ 

  {
#line 144
  connection_in = fd_in;
#line 145
  connection_out = fd_out;
#line 146
  cipher_type = 0;
#line 147
  cipher_set_key(& send_context, 0, (unsigned char const   *)((unsigned char *)""),
                 0);
#line 148
  cipher_set_key(& receive_context, 0, (unsigned char const   *)((unsigned char *)""),
                 0);
#line 149
  if (! initialized) {
#line 150
    initialized = 1;
#line 151
    buffer_init(& input);
#line 152
    buffer_init(& output);
#line 153
    buffer_init(& outgoing_packet);
#line 154
    buffer_init(& incoming_packet);
  }
#line 157
  fatal_add_cleanup((void (*)(void * ))(& packet_close), (void *)0);
#line 158
  return;
}
}
#line 162 "packet.c"
int packet_connection_is_on_socket(void) 
{ struct sockaddr_storage from ;
  struct sockaddr_storage to ;
  socklen_t fromlen ;
  socklen_t tolen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 169
  if (connection_in == connection_out) {
#line 170
    return (1);
  }
#line 171
  fromlen = sizeof(from);
#line 172
  memset((void *)(& from), 0, sizeof(from));
#line 173
  tmp = getpeername(connection_in, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                    (socklen_t * __restrict  )(& fromlen));
#line 173
  if (tmp < 0) {
#line 174
    return (0);
  }
#line 175
  tolen = sizeof(to);
#line 176
  memset((void *)(& to), 0, sizeof(to));
#line 177
  tmp___0 = getpeername(connection_out, (struct sockaddr * __restrict  )((struct sockaddr *)(& to)),
                        (socklen_t * __restrict  )(& tolen));
#line 177
  if (tmp___0 < 0) {
#line 178
    return (0);
  }
#line 179
  if (fromlen != tolen) {
#line 180
    return (0);
  } else {
#line 179
    tmp___1 = memcmp((void const   *)(& from), (void const   *)(& to), fromlen);
#line 179
    if (tmp___1 != 0) {
#line 180
      return (0);
    }
  }
#line 181
  if ((int )from.ss_family != 2) {
#line 181
    if ((int )from.ss_family != 10) {
#line 182
      return (0);
    }
  }
#line 183
  return (1);
}
}
#line 188 "packet.c"
int packet_connection_is_ipv4(void) 
{ struct sockaddr_storage to ;
  socklen_t tolen ;
  int tmp ;

  {
#line 192
  tolen = sizeof(to);
#line 194
  memset((void *)(& to), 0, sizeof(to));
#line 195
  tmp = getsockname(connection_out, (struct sockaddr * __restrict  )((struct sockaddr *)(& to)),
                    (socklen_t * __restrict  )(& tolen));
#line 195
  if (tmp < 0) {
#line 196
    return (0);
  }
#line 197
  if ((int )to.ss_family != 2) {
#line 198
    return (0);
  }
#line 199
  return (1);
}
}
#line 204 "packet.c"
void packet_set_nonblocking(void) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 208
  tmp___1 = fcntl(connection_in, 4, 2048);
#line 208
  if (tmp___1 < 0) {
#line 209
    tmp = __errno_location();
#line 209
    tmp___0 = strerror(*tmp);
#line 209
    error("fcntl O_NONBLOCK: %.100s", tmp___0);
  }
#line 211
  if (connection_out != connection_in) {
#line 212
    tmp___4 = fcntl(connection_out, 4, 2048);
#line 212
    if (tmp___4 < 0) {
#line 213
      tmp___2 = __errno_location();
#line 213
      tmp___3 = strerror(*tmp___2);
#line 213
      error("fcntl O_NONBLOCK: %.100s", tmp___3);
    }
  }
#line 215
  return;
}
}
#line 219 "packet.c"
int packet_get_connection_in(void) 
{ 

  {
#line 222
  return (connection_in);
}
}
#line 227 "packet.c"
int packet_get_connection_out(void) 
{ 

  {
#line 230
  return (connection_out);
}
}
#line 235 "packet.c"
void packet_close(void) 
{ 

  {
#line 238
  if (! initialized) {
#line 239
    return;
  }
#line 240
  initialized = 0;
#line 241
  if (connection_in == connection_out) {
#line 242
    shutdown(connection_out, 2);
#line 243
    close(connection_out);
  } else {
#line 245
    close(connection_in);
#line 246
    close(connection_out);
  }
#line 248
  buffer_free(& input);
#line 249
  buffer_free(& output);
#line 250
  buffer_free(& outgoing_packet);
#line 251
  buffer_free(& incoming_packet);
#line 252
  if (packet_compression) {
#line 253
    buffer_free(& compression_buffer);
#line 254
    buffer_compress_uninit();
  }
#line 256
  return;
}
}
#line 260 "packet.c"
void packet_set_protocol_flags(unsigned int protocol_flags ) 
{ 

  {
#line 263
  remote_protocol_flags = protocol_flags;
#line 264
  channel_set_options((protocol_flags & 2U) != 0U);
#line 265
  return;
}
}
#line 269 "packet.c"
unsigned int packet_get_protocol_flags(void) 
{ 

  {
#line 272
  return (remote_protocol_flags);
}
}
#line 281 "packet.c"
void packet_start_compression(int level ) 
{ 

  {
#line 284
  if (packet_compression) {
#line 285
    fatal("Compression already enabled.");
  }
#line 286
  packet_compression = 1;
#line 287
  buffer_init(& compression_buffer);
#line 288
  buffer_compress_init(level);
#line 289
  return;
}
}
#line 296 "packet.c"
void packet_encrypt(CipherContext *cc , void *dest , void *src , unsigned int bytes ) 
{ 

  {
#line 300
  cipher_encrypt(cc, (unsigned char *)dest, (unsigned char const   *)src, bytes);
#line 301
  return;
}
}
#line 308 "packet.c"
void packet_decrypt(CipherContext *cc , void *dest , void *src , unsigned int bytes ) 
{ int i ;

  {
#line 314
  if (bytes % 8U != 0U) {
#line 315
    fatal("packet_decrypt: bad ciphertext length %d", bytes);
  }
#line 322
  if (cc->type == 0U) {
#line 323
    i = 0;
  } else {
#line 322
    if (compat20) {
#line 323
      i = 0;
    } else {
#line 325
      i = detect_attack((unsigned char *)src, bytes, (unsigned char *)((void *)0));
    }
  }
#line 327
  if (i == 1) {
#line 328
    packet_disconnect("crc32 compensation attack: network attack detected");
  }
#line 330
  cipher_decrypt(cc, (unsigned char *)dest, (unsigned char const   *)src, bytes);
#line 331
  return;
}
}
#line 339 "packet.c"
void packet_set_encryption_key(unsigned char const   *key , unsigned int keylen ,
                               int cipher ) 
{ 

  {
#line 343
  if (keylen < 20U) {
#line 344
    fatal("keylen too small: %d", keylen);
  }
#line 347
  cipher_set_key(& receive_context, cipher, key, (int )keylen);
#line 348
  cipher_set_key(& send_context, cipher, key, (int )keylen);
#line 349
  return;
}
}
#line 353 "packet.c"
void packet_start1(int type ) 
{ char buf___1[9] ;

  {
#line 358
  buffer_clear(& outgoing_packet);
#line 359
  memset((void *)(buf___1), 0, 8U);
#line 360
  buf___1[8] = (char )type;
#line 361
  buffer_append(& outgoing_packet, (char const   *)(buf___1), 9U);
#line 362
  return;
}
}
#line 364 "packet.c"
void packet_start2(int type ) 
{ char buf___1[6] ;

  {
#line 369
  buffer_clear(& outgoing_packet);
#line 370
  memset((void *)(buf___1), 0, sizeof(buf___1));
#line 373
  buf___1[5] = (char )(type & 255);
#line 374
  buffer_append(& outgoing_packet, (char const   *)(buf___1), sizeof(buf___1));
#line 375
  return;
}
}
#line 377 "packet.c"
void packet_start(int type ) 
{ 

  {
#line 381
  if (use_ssh2_packet_format) {
#line 382
    packet_start2(type);
  } else {
#line 384
    packet_start1(type);
  }
#line 385
  return;
}
}
#line 389 "packet.c"
void packet_put_char(int value ) 
{ char ch ;

  {
#line 392
  ch = (char )value;
#line 393
  buffer_append(& outgoing_packet, (char const   *)(& ch), 1U);
#line 394
  return;
}
}
#line 398 "packet.c"
void packet_put_int(unsigned int value ) 
{ 

  {
#line 401
  buffer_put_int(& outgoing_packet, value);
#line 402
  return;
}
}
#line 406 "packet.c"
void packet_put_string(char const   *buf___1 , unsigned int len ) 
{ 

  {
#line 409
  buffer_put_string(& outgoing_packet, (void const   *)buf___1, len);
#line 410
  return;
}
}
#line 411 "packet.c"
void packet_put_cstring(char const   *str ) 
{ size_t tmp ;

  {
#line 414
  tmp = strlen(str);
#line 414
  buffer_put_string(& outgoing_packet, (void const   *)str, tmp);
#line 415
  return;
}
}
#line 417 "packet.c"
void packet_put_raw(char const   *buf___1 , unsigned int len ) 
{ 

  {
#line 420
  buffer_append(& outgoing_packet, buf___1, len);
#line 421
  return;
}
}
#line 426 "packet.c"
void packet_put_bignum(BIGNUM *value ) 
{ 

  {
#line 429
  buffer_put_bignum(& outgoing_packet, value);
#line 430
  return;
}
}
#line 431 "packet.c"
void packet_put_bignum2(BIGNUM *value ) 
{ 

  {
#line 434
  buffer_put_bignum2(& outgoing_packet, value);
#line 435
  return;
}
}
#line 442 "packet.c"
void packet_send1(void) 
{ char buf___1[8] ;
  char *cp ;
  int i ;
  int padding ;
  int len ;
  unsigned int checksum ;
  u_int32_t rand___0 ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  char *tmp___6 ;

  {
#line 448
  rand___0 = (u_int32_t )0;
#line 454
  if (packet_compression) {
#line 455
    buffer_clear(& compression_buffer);
#line 457
    buffer_consume(& outgoing_packet, 8U);
#line 459
    buffer_append(& compression_buffer, "\000\000\000\000\000\000\000\000", 8U);
#line 460
    buffer_compress(& outgoing_packet, & compression_buffer);
#line 461
    buffer_clear(& outgoing_packet);
#line 462
    tmp = buffer_len(& compression_buffer);
#line 462
    tmp___0 = buffer_ptr(& compression_buffer);
#line 462
    buffer_append(& outgoing_packet, (char const   *)tmp___0, tmp);
  }
#line 466
  tmp___1 = buffer_len(& outgoing_packet);
#line 466
  len = (int )((tmp___1 + 4U) - 8U);
#line 469
  padding = 8 - len % 8;
#line 470
  if (cipher_type != 0) {
#line 471
    cp = buffer_ptr(& outgoing_packet);
#line 472
    i = 0;
#line 472
    while (i < padding) {
#line 473
      if (i % 4 == 0) {
#line 474
        rand___0 = arc4random();
      }
#line 475
      *(cp + (7 - i)) = (char )(rand___0 & 255U);
#line 476
      rand___0 >>= 8;
#line 472
      i ++;
    }
  }
#line 479
  buffer_consume(& outgoing_packet, (unsigned int )(8 - padding));
#line 482
  tmp___2 = buffer_len(& outgoing_packet);
#line 482
  tmp___3 = buffer_ptr(& outgoing_packet);
#line 482
  checksum = crc32((unsigned char const   *)((unsigned char *)tmp___3), tmp___2);
#line 484
  while (1) {
#line 484
    buf___1[0] = (char )(checksum >> 24);
#line 484
    buf___1[1] = (char )(checksum >> 16);
#line 484
    buf___1[2] = (char )(checksum >> 8);
#line 484
    buf___1[3] = (char )checksum;
#line 484
    break;
  }
#line 485
  buffer_append(& outgoing_packet, (char const   *)(buf___1), 4U);
#line 493
  while (1) {
#line 493
    buf___1[0] = (char )(len >> 24);
#line 493
    buf___1[1] = (char )(len >> 16);
#line 493
    buf___1[2] = (char )(len >> 8);
#line 493
    buf___1[3] = (char )len;
#line 493
    break;
  }
#line 494
  buffer_append(& output, (char const   *)(buf___1), 4U);
#line 495
  tmp___4 = buffer_len(& outgoing_packet);
#line 495
  buffer_append_space(& output, & cp, tmp___4);
#line 496
  tmp___5 = buffer_len(& outgoing_packet);
#line 496
  tmp___6 = buffer_ptr(& outgoing_packet);
#line 496
  packet_encrypt(& send_context, (void *)cp, (void *)tmp___6, tmp___5);
#line 504
  buffer_clear(& outgoing_packet);
#line 511
  return;
}
}
#line 524
void packet_send2(void) ;
#line 524 "packet.c"
static unsigned int seqnr  =    0U;
#line 516 "packet.c"
void packet_send2(void) 
{ unsigned char *macbuf ;
  char *cp ;
  unsigned int packet_length___0 ;
  unsigned int i ;
  unsigned int padlen ;
  unsigned int len ;
  u_int32_t rand___0 ;
  int type ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  int block_size ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  char *tmp___6 ;

  {
#line 519
  macbuf = (unsigned char *)((void *)0);
#line 521
  packet_length___0 = 0U;
#line 523
  rand___0 = (u_int32_t )0;
#line 526
  enc = (Enc *)((void *)0);
#line 527
  mac = (Mac *)((void *)0);
#line 528
  comp = (Comp *)((void *)0);
#line 531
  if ((unsigned int )kex != (unsigned int )((void *)0)) {
#line 532
    enc = & kex->enc[1];
#line 533
    mac = & kex->mac[1];
#line 534
    comp = & kex->comp[1];
  }
#line 536
  if (enc) {
#line 536
    block_size = enc->block_size;
  } else {
#line 536
    block_size = 8;
  }
#line 538
  cp = buffer_ptr(& outgoing_packet);
#line 539
  type = (int )*(cp + 5) & 255;
#line 546
  if (comp) {
#line 546
    if (comp->enabled) {
#line 547
      len = buffer_len(& outgoing_packet);
#line 549
      buffer_consume(& outgoing_packet, 5U);
#line 550
      buffer_clear(& compression_buffer);
#line 551
      buffer_compress(& outgoing_packet, & compression_buffer);
#line 552
      buffer_clear(& outgoing_packet);
#line 553
      buffer_append(& outgoing_packet, "\000\000\000\000\000", 5U);
#line 554
      tmp = buffer_len(& compression_buffer);
#line 554
      tmp___0 = buffer_ptr(& compression_buffer);
#line 554
      buffer_append(& outgoing_packet, (char const   *)tmp___0, tmp);
    }
  }
#line 561
  len = buffer_len(& outgoing_packet);
#line 567
  padlen = (unsigned int )block_size - len % (unsigned int )block_size;
#line 568
  if (padlen < 4U) {
#line 569
    padlen += (unsigned int )block_size;
  }
#line 570
  buffer_append_space(& outgoing_packet, & cp, padlen);
#line 571
  if (enc) {
#line 571
    if (enc->type != 0) {
#line 573
      i = 0U;
#line 573
      while (i < padlen) {
#line 574
        if (i % 4U == 0U) {
#line 575
          rand___0 = arc4random();
        }
#line 576
        *(cp + i) = (char )(rand___0 & 255U);
#line 577
        rand___0 <<= 8;
#line 573
        i ++;
      }
    } else {
#line 581
      memset((void *)cp, 0, padlen);
    }
  } else {
#line 581
    memset((void *)cp, 0, padlen);
  }
#line 584
  tmp___1 = buffer_len(& outgoing_packet);
#line 584
  packet_length___0 = tmp___1 - 4U;
#line 585
  cp = buffer_ptr(& outgoing_packet);
#line 586
  while (1) {
#line 586
    *(cp + 0) = (char )(packet_length___0 >> 24);
#line 586
    *(cp + 1) = (char )(packet_length___0 >> 16);
#line 586
    *(cp + 2) = (char )(packet_length___0 >> 8);
#line 586
    *(cp + 3) = (char )packet_length___0;
#line 586
    break;
  }
#line 587
  *(cp + 4) = (char )(padlen & 255U);
#line 591
  if (mac) {
#line 591
    if (mac->enabled) {
#line 592
      tmp___2 = buffer_len(& outgoing_packet);
#line 592
      tmp___3 = buffer_ptr(& outgoing_packet);
#line 592
      macbuf = hmac(mac->md, seqnr, (unsigned char *)tmp___3, (int )tmp___2, mac->key,
                    mac->key_len);
    }
  }
#line 600
  tmp___4 = buffer_len(& outgoing_packet);
#line 600
  buffer_append_space(& output, & cp, tmp___4);
#line 601
  tmp___5 = buffer_len(& outgoing_packet);
#line 601
  tmp___6 = buffer_ptr(& outgoing_packet);
#line 601
  packet_encrypt(& send_context, (void *)cp, (void *)tmp___6, tmp___5);
#line 604
  if (mac) {
#line 604
    if (mac->enabled) {
#line 605
      buffer_append(& output, (char const   *)((char *)macbuf), (unsigned int )mac->mac_len);
    }
  }
#line 611
  seqnr ++;
#line 611
  if (seqnr == 0U) {
#line 612
    log("outgoing seqnr wraps around");
  }
#line 613
  buffer_clear(& outgoing_packet);
#line 615
  if (type == 21) {
#line 616
    if ((unsigned int )kex == (unsigned int )((void *)0)) {
#line 617
      fatal("packet_send2: no KEX");
    } else {
#line 616
      if ((unsigned int )mac == (unsigned int )((void *)0)) {
#line 617
        fatal("packet_send2: no KEX");
      } else {
#line 616
        if ((unsigned int )enc == (unsigned int )((void *)0)) {
#line 617
          fatal("packet_send2: no KEX");
        } else {
#line 616
          if ((unsigned int )comp == (unsigned int )((void *)0)) {
#line 617
            fatal("packet_send2: no KEX");
          }
        }
      }
    }
#line 618
    if ((unsigned int )mac->md != (unsigned int )((void *)0)) {
#line 619
      mac->enabled = 1;
    }
#line 621
    cipher_set_key_iv(& send_context, enc->type, (unsigned char const   *)enc->key,
                      enc->key_len, (unsigned char const   *)enc->iv, enc->iv_len);
#line 624
    clear_enc_keys(enc, kex->we_need);
#line 625
    if (comp->type != 0) {
#line 625
      if (comp->enabled == 0) {
#line 626
        comp->enabled = 1;
#line 627
        if (! packet_compression) {
#line 628
          packet_start_compression(6);
        }
      }
    }
  }
#line 631
  return;
}
}
#line 633 "packet.c"
void packet_send(void) 
{ 

  {
#line 636
  if (use_ssh2_packet_format) {
#line 637
    packet_send2();
  } else {
#line 639
    packet_send1();
  }
#line 641
  return;
}
}
#line 649 "packet.c"
int packet_read(int *payload_len_ptr ) 
{ int type ;
  int len ;
  fd_set set ;
  char buf___1[8192] ;
  int _p ;
  int _e ;
  int __d0 ;
  int __d1 ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 658
  packet_write_wait();
#line 661
  while (1) {
#line 663
    type = packet_read_poll(payload_len_ptr);
#line 664
    if (! use_ssh2_packet_format) {
#line 664
      if (type == 14) {
        goto _L;
      } else {
#line 664
        if (type == 15) {
          goto _L;
        } else {
#line 664
          if (type == 19) {
            goto _L;
          } else {
#line 664
            if (type == 33) {
              _L: /* CIL Label */ 
#line 669
              while (1) {
#line 669
                _p = *payload_len_ptr;
#line 669
                _e = 0;
#line 669
                if (_p != _e) {
#line 669
                  log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "packet.c",
                      669);
#line 669
                  packet_disconnect("Packet integrity error. (%d)", type);
                }
#line 669
                break;
              }
            }
          }
        }
      }
    }
#line 671
    if (type != 0) {
#line 672
      return (type);
    }
#line 677
    while (1) {
#line 677
      __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& set.__fds_bits[0]): "memory");
#line 677
      break;
    }
#line 678
    __asm__  volatile   ("btsl %1,%0": "=m" (set.__fds_bits[(unsigned int )connection_in / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 681
    select(connection_in + 1, (fd_set * __restrict  )(& set), (fd_set * __restrict  )((void *)0),
           (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 684
    len = read(connection_in, (void *)(buf___1), sizeof(buf___1));
#line 685
    if (len == 0) {
#line 686
      tmp = get_remote_ipaddr();
#line 686
      log("Connection closed by %.200s", tmp);
#line 687
      fatal_cleanup();
    }
#line 689
    if (len < 0) {
#line 690
      tmp___0 = __errno_location();
#line 690
      tmp___1 = strerror(*tmp___0);
#line 690
      fatal("Read from socket failed: %.100s", tmp___1);
    }
#line 692
    packet_process_incoming((char const   *)(buf___1), (unsigned int )len);
  }
}
}
#line 702 "packet.c"
void packet_read_expect(int *payload_len_ptr , int expected_type ) 
{ int type ;

  {
#line 707
  type = packet_read(payload_len_ptr);
#line 708
  if (type != expected_type) {
#line 709
    packet_disconnect("Protocol error: expected packet type %d, got %d", expected_type,
                      type);
  }
#line 711
  return;
}
}
#line 728 "packet.c"
int packet_read_poll1(int *payload_len_ptr ) 
{ unsigned int len ;
  unsigned int padded_len ;
  unsigned char *ucp ;
  char buf___1[8] ;
  char *cp ;
  unsigned int checksum ;
  unsigned int stored_checksum ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  char *tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  unsigned int tmp___8 ;
  char *tmp___9 ;
  unsigned int tmp___10 ;

  {
#line 737
  tmp = buffer_len(& input);
#line 737
  if (tmp < 12U) {
#line 738
    return (0);
  }
#line 740
  tmp___0 = buffer_ptr(& input);
#line 740
  ucp = (unsigned char *)tmp___0;
#line 741
  len = (unsigned int )(((((unsigned long )*(ucp + 0) << 24) | ((unsigned long )*(ucp + 1) << 16)) | ((unsigned long )*(ucp + 2) << 8)) | (unsigned long )*(ucp + 3));
#line 742
  if (len < 5U) {
#line 743
    packet_disconnect("Bad packet length %d.", len);
  } else {
#line 742
    if (len > 262144U) {
#line 743
      packet_disconnect("Bad packet length %d.", len);
    }
  }
#line 744
  padded_len = (len + 8U) & 4294967288U;
#line 747
  tmp___1 = buffer_len(& input);
#line 747
  if (tmp___1 < 4U + padded_len) {
#line 748
    return (0);
  }
#line 753
  buffer_consume(& input, 4U);
#line 756
  buffer_clear(& incoming_packet);
#line 757
  buffer_append_space(& incoming_packet, & cp, padded_len);
#line 758
  tmp___2 = buffer_ptr(& input);
#line 758
  packet_decrypt(& receive_context, (void *)cp, (void *)tmp___2, padded_len);
#line 759
  buffer_consume(& input, padded_len);
#line 767
  tmp___3 = buffer_len(& incoming_packet);
#line 767
  tmp___4 = buffer_ptr(& incoming_packet);
#line 767
  checksum = crc32((unsigned char const   *)((unsigned char *)tmp___4), tmp___3 - 4U);
#line 771
  buffer_consume(& incoming_packet, 8U - len % 8U);
#line 775
  tmp___6 = buffer_len(& incoming_packet);
#line 775
  if (len != tmp___6) {
#line 776
    tmp___5 = buffer_len(& incoming_packet);
#line 776
    packet_disconnect("packet_read_poll: len %d != buffer_len %d.", len, tmp___5);
  }
#line 779
  tmp___7 = buffer_ptr(& incoming_packet);
#line 779
  ucp = ((unsigned char *)tmp___7 + len) - 4;
#line 780
  stored_checksum = (unsigned int )(((((unsigned long )*(ucp + 0) << 24) | ((unsigned long )*(ucp + 1) << 16)) | ((unsigned long )*(ucp + 2) << 8)) | (unsigned long )*(ucp + 3));
#line 781
  if (checksum != stored_checksum) {
#line 782
    packet_disconnect("Corrupted check bytes on input.");
  }
#line 783
  buffer_consume_end(& incoming_packet, 4U);
#line 786
  if (packet_compression) {
#line 787
    buffer_clear(& compression_buffer);
#line 788
    buffer_uncompress(& incoming_packet, & compression_buffer);
#line 789
    buffer_clear(& incoming_packet);
#line 790
    tmp___8 = buffer_len(& compression_buffer);
#line 790
    tmp___9 = buffer_ptr(& compression_buffer);
#line 790
    buffer_append(& incoming_packet, (char const   *)tmp___9, tmp___8);
  }
#line 794
  buffer_get(& incoming_packet, buf___1, 1U);
#line 797
  tmp___10 = buffer_len(& incoming_packet);
#line 797
  *payload_len_ptr = (int )tmp___10;
#line 800
  return ((int )((unsigned char )buf___1[0]));
}
}
#line 810
int packet_read_poll2(int *payload_len_ptr ) ;
#line 810 "packet.c"
static unsigned int packet_length  =    0U;
#line 811 "packet.c"
static unsigned int seqnr___0  =    0U;
#line 803 "packet.c"
int packet_read_poll2(int *payload_len_ptr ) 
{ unsigned int padlen ;
  unsigned int need ;
  unsigned char buf___1[8] ;
  unsigned char *macbuf ;
  unsigned char *ucp ;
  char *cp ;
  int type ;
  int maclen ;
  int block_size ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  unsigned int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  unsigned int tmp___9 ;
  char *tmp___10 ;
  unsigned int tmp___11 ;

  {
#line 814
  enc = (Enc *)((void *)0);
#line 815
  mac = (Mac *)((void *)0);
#line 816
  comp = (Comp *)((void *)0);
#line 818
  if ((unsigned int )kex != (unsigned int )((void *)0)) {
#line 819
    enc = & kex->enc[0];
#line 820
    mac = & kex->mac[0];
#line 821
    comp = & kex->comp[0];
  }
#line 823
  if (mac) {
#line 823
    if (mac->enabled) {
#line 823
      maclen = mac->mac_len;
    } else {
#line 823
      maclen = 0;
    }
  } else {
#line 823
    maclen = 0;
  }
#line 824
  if (enc) {
#line 824
    block_size = enc->block_size;
  } else {
#line 824
    block_size = 8;
  }
#line 826
  if (packet_length == 0U) {
#line 831
    tmp = buffer_len(& input);
#line 831
    if (tmp < (unsigned int )block_size) {
#line 832
      return (0);
    }
#line 833
    buffer_clear(& incoming_packet);
#line 834
    buffer_append_space(& incoming_packet, & cp, (unsigned int )block_size);
#line 835
    tmp___0 = buffer_ptr(& input);
#line 835
    packet_decrypt(& receive_context, (void *)cp, (void *)tmp___0, (unsigned int )block_size);
#line 837
    tmp___1 = buffer_ptr(& incoming_packet);
#line 837
    ucp = (unsigned char *)tmp___1;
#line 838
    packet_length = (unsigned int )(((((unsigned long )*(ucp + 0) << 24) | ((unsigned long )*(ucp + 1) << 16)) | ((unsigned long )*(ucp + 2) << 8)) | (unsigned long )*(ucp + 3));
#line 839
    if (packet_length < 5U) {
#line 840
      buffer_dump(& incoming_packet);
#line 841
      packet_disconnect("Bad packet length %d.", packet_length);
    } else {
#line 839
      if (packet_length > 262144U) {
#line 840
        buffer_dump(& incoming_packet);
#line 841
        packet_disconnect("Bad packet length %d.", packet_length);
      }
    }
#line 844
    buffer_consume(& input, (unsigned int )block_size);
  }
#line 847
  need = (4U + packet_length) - (unsigned int )block_size;
#line 850
  if (need % (unsigned int )block_size != 0U) {
#line 851
    fatal("padding error: need %d block %d mod %d", need, block_size, need % (unsigned int )block_size);
  }
#line 857
  tmp___2 = buffer_len(& input);
#line 857
  if (tmp___2 < need + (unsigned int )maclen) {
#line 858
    return (0);
  }
#line 863
  buffer_append_space(& incoming_packet, & cp, need);
#line 864
  tmp___3 = buffer_ptr(& input);
#line 864
  packet_decrypt(& receive_context, (void *)cp, (void *)tmp___3, need);
#line 865
  buffer_consume(& input, need);
#line 870
  if (mac) {
#line 870
    if (mac->enabled) {
#line 871
      tmp___4 = buffer_len(& incoming_packet);
#line 871
      tmp___5 = buffer_ptr(& incoming_packet);
#line 871
      macbuf = hmac(mac->md, seqnr___0, (unsigned char *)tmp___5, (int )tmp___4, mac->key,
                    mac->key_len);
#line 876
      tmp___6 = buffer_ptr(& input);
#line 876
      tmp___7 = memcmp((void const   *)macbuf, (void const   *)tmp___6, (unsigned int )mac->mac_len);
#line 876
      if (tmp___7 != 0) {
#line 877
        packet_disconnect("Corrupted HMAC on input.");
      }
#line 879
      buffer_consume(& input, (unsigned int )mac->mac_len);
    }
  }
#line 881
  seqnr___0 ++;
#line 881
  if (seqnr___0 == 0U) {
#line 882
    log("incoming seqnr wraps around");
  }
#line 885
  tmp___8 = buffer_ptr(& incoming_packet);
#line 885
  cp = tmp___8 + 4;
#line 886
  padlen = (unsigned int )((int )*cp & 255);
#line 888
  if (padlen < 4U) {
#line 889
    packet_disconnect("Corrupted padlen %d on input.", padlen);
  }
#line 892
  buffer_consume(& incoming_packet, 5U);
#line 893
  buffer_consume_end(& incoming_packet, padlen);
#line 896
  if (comp) {
#line 896
    if (comp->enabled) {
#line 897
      buffer_clear(& compression_buffer);
#line 898
      buffer_uncompress(& incoming_packet, & compression_buffer);
#line 899
      buffer_clear(& incoming_packet);
#line 900
      tmp___9 = buffer_len(& compression_buffer);
#line 900
      tmp___10 = buffer_ptr(& compression_buffer);
#line 900
      buffer_append(& incoming_packet, (char const   *)tmp___10, tmp___9);
    }
  }
#line 908
  buffer_get(& incoming_packet, (char *)(buf___1), 1U);
#line 909
  tmp___11 = buffer_len(& incoming_packet);
#line 909
  *payload_len_ptr = (int )tmp___11;
#line 912
  packet_length = 0U;
#line 915
  type = (int )buf___1[0];
#line 917
  if (type == 21) {
#line 918
    if ((unsigned int )kex == (unsigned int )((void *)0)) {
#line 919
      fatal("packet_read_poll2: no KEX");
    } else {
#line 918
      if ((unsigned int )mac == (unsigned int )((void *)0)) {
#line 919
        fatal("packet_read_poll2: no KEX");
      } else {
#line 918
        if ((unsigned int )enc == (unsigned int )((void *)0)) {
#line 919
          fatal("packet_read_poll2: no KEX");
        } else {
#line 918
          if ((unsigned int )comp == (unsigned int )((void *)0)) {
#line 919
            fatal("packet_read_poll2: no KEX");
          }
        }
      }
    }
#line 920
    if ((unsigned int )mac->md != (unsigned int )((void *)0)) {
#line 921
      mac->enabled = 1;
    }
#line 923
    cipher_set_key_iv(& receive_context, enc->type, (unsigned char const   *)enc->key,
                      enc->key_len, (unsigned char const   *)enc->iv, enc->iv_len);
#line 926
    clear_enc_keys(enc, kex->we_need);
#line 927
    if (comp->type != 0) {
#line 927
      if (comp->enabled == 0) {
#line 928
        comp->enabled = 1;
#line 929
        if (! packet_compression) {
#line 930
          packet_start_compression(6);
        }
      }
    }
  }
#line 938
  return ((int )((unsigned char )type));
}
}
#line 941 "packet.c"
int packet_read_poll(int *payload_len_ptr ) 
{ char *msg ;
  int type ;
  int tmp___1 ;
  int reason ;
  unsigned int tmp___2 ;

  {
#line 945
  while (1) {
#line 946
    if (use_ssh2_packet_format) {
#line 946
      tmp___1 = packet_read_poll2(payload_len_ptr);
    } else {
#line 946
      tmp___1 = packet_read_poll1(payload_len_ptr);
    }
#line 946
    type = tmp___1;
#line 950
    if (compat20) {
#line 952
      if (type != 0) {

      }
#line 954
      switch (type) {
      case 2: 
#line 956
      break;
      case 4: 
#line 958
      packet_get_char();
#line 959
      msg = packet_get_string((unsigned int *)((void *)0));
#line 960
      debug("Remote: %.900s", msg);
#line 961
      xfree((void *)msg);
#line 962
      msg = packet_get_string((unsigned int *)((void *)0));
#line 963
      xfree((void *)msg);
#line 964
      break;
      case 1: 
#line 966
      tmp___2 = packet_get_int();
#line 966
      reason = (int )tmp___2;
#line 967
      msg = packet_get_string((unsigned int *)((void *)0));
#line 968
      log("Received disconnect: %d: %.900s", reason, msg);
#line 969
      xfree((void *)msg);
#line 970
      fatal_cleanup();
#line 971
      break;
      default: ;
#line 973
      return (type);
#line 974
      break;
      }
    } else {
#line 977
      switch (type) {
      case 32: 
#line 979
      break;
      case 36: 
#line 981
      msg = packet_get_string((unsigned int *)((void *)0));
#line 982
      debug("Remote: %.900s", msg);
#line 983
      xfree((void *)msg);
#line 984
      break;
      case 1: 
#line 986
      msg = packet_get_string((unsigned int *)((void *)0));
#line 987
      log("Received disconnect: %.900s", msg);
#line 988
      fatal_cleanup();
#line 989
      xfree((void *)msg);
#line 990
      break;
      default: ;
#line 992
      if (type != 0) {

      }
#line 994
      return (type);
#line 995
      break;
      }
    }
  }
}
}
#line 1006 "packet.c"
void packet_process_incoming(char const   *buf___1 , unsigned int len ) 
{ 

  {
#line 1009
  buffer_append(& input, buf___1, len);
#line 1010
  return;
}
}
#line 1014 "packet.c"
unsigned int packet_get_char(void) 
{ char ch ;

  {
#line 1018
  buffer_get(& incoming_packet, & ch, 1U);
#line 1019
  return ((unsigned int )((unsigned char )ch));
}
}
#line 1024 "packet.c"
unsigned int packet_get_int(void) 
{ unsigned int tmp ;

  {
#line 1027
  tmp = buffer_get_int(& incoming_packet);
#line 1027
  return (tmp);
}
}
#line 1035 "packet.c"
void packet_get_bignum(BIGNUM *value , int *length_ptr ) 
{ 

  {
#line 1038
  *length_ptr = buffer_get_bignum(& incoming_packet, value);
#line 1039
  return;
}
}
#line 1041 "packet.c"
void packet_get_bignum2(BIGNUM *value , int *length_ptr ) 
{ 

  {
#line 1044
  *length_ptr = buffer_get_bignum2(& incoming_packet, value);
#line 1045
  return;
}
}
#line 1047 "packet.c"
char *packet_get_raw(int *length_ptr ) 
{ int bytes ;
  unsigned int tmp ;
  char *tmp___0 ;

  {
#line 1050
  tmp = buffer_len(& incoming_packet);
#line 1050
  bytes = (int )tmp;
#line 1051
  if ((unsigned int )length_ptr != (unsigned int )((void *)0)) {
#line 1052
    *length_ptr = bytes;
  }
#line 1053
  tmp___0 = buffer_ptr(& incoming_packet);
#line 1053
  return (tmp___0);
}
}
#line 1056 "packet.c"
int packet_remaining(void) 
{ unsigned int tmp ;

  {
#line 1059
  tmp = buffer_len(& incoming_packet);
#line 1059
  return ((int )tmp);
}
}
#line 1069 "packet.c"
char *packet_get_string(unsigned int *length_ptr ) 
{ char *tmp ;

  {
#line 1072
  tmp = buffer_get_string(& incoming_packet, length_ptr);
#line 1072
  return (tmp);
}
}
#line 1084 "packet.c"
void ( /* format attribute */  packet_send_debug)(char const   *fmt  , ...) 
{ char buf___1[1024] ;
  va_list args ;

  {
#line 1090
  __builtin_va_start(args, fmt);
#line 1091
  vsnprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )fmt,
            args);
#line 1092
  __builtin_va_end(args);
#line 1094
  if (compat20) {
#line 1095
    packet_start(4);
#line 1096
    packet_put_char(0);
#line 1097
    packet_put_cstring((char const   *)(buf___1));
#line 1098
    packet_put_cstring("");
  } else {
#line 1100
    packet_start(36);
#line 1101
    packet_put_cstring((char const   *)(buf___1));
  }
#line 1103
  packet_send();
#line 1104
  packet_write_wait();
#line 1105
  return;
}
}
#line 1119 "packet.c"
static int disconnecting  =    0;
#line 1114 "packet.c"
void ( /* format attribute */  packet_disconnect)(char const   *fmt  , ...) 
{ char buf___1[1024] ;
  va_list args ;
  size_t tmp ;

  {
#line 1120
  if (disconnecting) {
#line 1121
    fatal("packet_disconnect called recursively.");
  }
#line 1122
  disconnecting = 1;
#line 1128
  __builtin_va_start(args, fmt);
#line 1129
  vsnprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )fmt,
            args);
#line 1130
  __builtin_va_end(args);
#line 1133
  if (compat20) {
#line 1134
    packet_start(1);
#line 1135
    packet_put_int(2U);
#line 1136
    packet_put_cstring((char const   *)(buf___1));
#line 1137
    packet_put_cstring("");
  } else {
#line 1139
    packet_start(1);
#line 1140
    tmp = strlen((char const   *)(buf___1));
#line 1140
    packet_put_string((char const   *)(buf___1), tmp);
  }
#line 1142
  packet_send();
#line 1143
  packet_write_wait();
#line 1146
  channel_stop_listening();
#line 1149
  packet_close();
#line 1152
  log("Disconnecting: %.100s", buf___1);
#line 1153
  fatal_cleanup();
#line 1154
  return;
}
}
#line 1158 "packet.c"
void packet_write_poll(void) 
{ int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
#line 1161
  tmp = buffer_len(& output);
#line 1161
  len = (int )tmp;
#line 1162
  if (len > 0) {
#line 1163
    tmp___0 = buffer_ptr(& output);
#line 1163
    len = write(connection_out, (void const   *)tmp___0, (unsigned int )len);
#line 1164
    if (len <= 0) {
#line 1165
      tmp___3 = __errno_location();
#line 1165
      if (*tmp___3 == 11) {
#line 1166
        return;
      } else {
#line 1168
        tmp___1 = __errno_location();
#line 1168
        tmp___2 = strerror(*tmp___1);
#line 1168
        fatal("Write failed: %.100s", tmp___2);
      }
    }
#line 1170
    buffer_consume(& output, (unsigned int )len);
  }
#line 1172
  return;
}
}
#line 1179 "packet.c"
void packet_write_wait(void) 
{ fd_set set ;
  int __d0 ;
  int __d1 ;
  int tmp ;

  {
#line 1182
  packet_write_poll();
#line 1183
  while (1) {
#line 1183
    tmp = packet_have_data_to_write();
#line 1183
    if (! tmp) {
#line 1183
      break;
    }
#line 1185
    while (1) {
#line 1185
      __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& set.__fds_bits[0]): "memory");
#line 1185
      break;
    }
#line 1186
    __asm__  volatile   ("btsl %1,%0": "=m" (set.__fds_bits[(unsigned int )connection_out / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 1187
    select(connection_out + 1, (fd_set * __restrict  )((void *)0), (fd_set * __restrict  )(& set),
           (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 1188
    packet_write_poll();
  }
#line 1190
  return;
}
}
#line 1194 "packet.c"
int packet_have_data_to_write(void) 
{ unsigned int tmp ;

  {
#line 1197
  tmp = buffer_len(& output);
#line 1197
  return (tmp != 0U);
}
}
#line 1202 "packet.c"
int packet_not_very_much_data_to_write(void) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 1205
  if (interactive_mode) {
#line 1206
    tmp = buffer_len(& output);
#line 1206
    return (tmp < 16384U);
  } else {
#line 1208
    tmp___0 = buffer_len(& output);
#line 1208
    return (tmp___0 < 131072U);
  }
}
}
#line 1213 "packet.c"
void packet_set_interactive(int interactive , int keepalives ) 
{ int on ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int lowdelay ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int throughput ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
#line 1216
  on = 1;
#line 1219
  interactive_mode = interactive;
#line 1222
  tmp = packet_connection_is_on_socket();
#line 1222
  if (! tmp) {
#line 1223
    return;
  }
#line 1224
  if (keepalives) {
#line 1226
    tmp___2 = setsockopt(connection_in, 1, 9, (void const   *)((void *)(& on)), sizeof(on));
#line 1226
    if (tmp___2 < 0) {
#line 1228
      tmp___0 = __errno_location();
#line 1228
      tmp___1 = strerror(*tmp___0);
#line 1228
      error("setsockopt SO_KEEPALIVE: %.100s", tmp___1);
    }
  }
#line 1233
  tmp___3 = packet_connection_is_ipv4();
#line 1233
  if (! tmp___3) {
#line 1234
    return;
  }
#line 1235
  if (interactive) {
#line 1241
    lowdelay = 16;
#line 1242
    tmp___6 = setsockopt(connection_in, 0, 1, (void const   *)((void *)(& lowdelay)),
                         sizeof(lowdelay));
#line 1242
    if (tmp___6 < 0) {
#line 1244
      tmp___4 = __errno_location();
#line 1244
      tmp___5 = strerror(*tmp___4);
#line 1244
      error("setsockopt IPTOS_LOWDELAY: %.100s", tmp___5);
    }
#line 1246
    tmp___9 = setsockopt(connection_in, 6, 1, (void const   *)((void *)(& on)), sizeof(on));
#line 1246
    if (tmp___9 < 0) {
#line 1248
      tmp___7 = __errno_location();
#line 1248
      tmp___8 = strerror(*tmp___7);
#line 1248
      error("setsockopt TCP_NODELAY: %.100s", tmp___8);
    }
  } else {
#line 1255
    throughput = 8;
#line 1256
    tmp___12 = setsockopt(connection_in, 0, 1, (void const   *)((void *)(& throughput)),
                          sizeof(throughput));
#line 1256
    if (tmp___12 < 0) {
#line 1258
      tmp___10 = __errno_location();
#line 1258
      tmp___11 = strerror(*tmp___10);
#line 1258
      error("setsockopt IPTOS_THROUGHPUT: %.100s", tmp___11);
    }
  }
#line 1261
  return;
}
}
#line 1265 "packet.c"
int packet_is_interactive(void) 
{ 

  {
#line 1268
  return (interactive_mode);
}
}
#line 1274 "packet.c"
static int called___0  =    0;
#line 1271 "packet.c"
int packet_set_maxsize(int s ) 
{ 

  {
#line 1275
  if (called___0) {
#line 1276
    log("packet_set_maxsize: called twice: old %d new %d", max_packet_size, s);
#line 1278
    return (-1);
  }
#line 1280
  if (s < 4096) {
#line 1281
    log("packet_set_maxsize: bad size %d", s);
#line 1282
    return (-1);
  } else {
#line 1280
    if (s > 1048576) {
#line 1281
      log("packet_set_maxsize: bad size %d", s);
#line 1282
      return (-1);
    }
  }
#line 1284
  log("packet_set_maxsize: setting to %d", s);
#line 1285
  max_packet_size = s;
#line 1286
  return (s);
}
}
#line 1 "radix.o"
#pragma merger(0,"./radix.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "entropy.o"
#pragma merger(0,"./entropy.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 33 "entropy.h"
void seed_rng(void) ;
#line 105 "/usr/include/openssl/rand.h"
extern void RAND_add(void const   *buf , int num , double entropy ) ;
#line 93 "entropy.c"
void get_random_bytes(unsigned char *buf___1 , int len ) ;
#line 93 "entropy.c"
static int random_pool  =    -1;
#line 91 "entropy.c"
void get_random_bytes(unsigned char *buf___1 , int len ) 
{ int c ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
#line 96
  if (random_pool == -1) {
#line 97
    random_pool = open("/dev/urandom", 0);
#line 98
    if (random_pool == -1) {
#line 99
      tmp = __errno_location();
#line 99
      tmp___0 = strerror(*tmp);
#line 99
      fatal("Couldn\'t open random pool \"%s\": %s", "/dev/urandom", tmp___0);
    }
  }
#line 102
  c = atomicio((ssize_t (*)())(& read), random_pool, (void *)buf___1, (unsigned int )len);
#line 103
  if (c <= 0) {
#line 104
    tmp___1 = __errno_location();
#line 104
    tmp___2 = strerror(*tmp___1);
#line 104
    fatal("Couldn\'t read from random pool \"%s\": %s", "/dev/urandom", tmp___2);
  }
#line 105
  return;
}
}
#line 709 "entropy.c"
void seed_rng(void) 
{ char buf___1[32] ;

  {
#line 714
  debug("Seeding random number generator");
#line 715
  get_random_bytes((unsigned char *)(buf___1), (int )sizeof(buf___1));
#line 716
  RAND_add((void const   *)(buf___1), (int )sizeof(buf___1), (double )sizeof(buf___1));
#line 717
  memset((void *)(buf___1), '\000', sizeof(buf___1));
#line 718
  return;
}
}
#line 1 "readpass.o"
#pragma merger(0,"./readpass.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 117 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 216
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
#line 222
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo )  __attribute__((__nonnull__(1))) ;
#line 249
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
#line 257
extern int sigsuspend(sigset_t const   *__set )  __attribute__((__nonnull__(1))) ;
#line 260
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 143 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 218
extern int fflush(FILE *__stream ) ;
#line 67 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 71
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
#line 423 "ssh.h"
char *read_passphrase(char const   *prompt , int from_stdin ) ;
#line 40 "readpass.c"
int volatile   intr  ;
#line 42 "readpass.c"
void intcatch(void) 
{ 

  {
#line 45
  intr = (int volatile   )1;
#line 46
  return;
}
}
#line 53 "readpass.c"
char *read_passphrase(char const   *prompt , int from_stdin ) 
{ char buf___1[1024] ;
  char *p ;
  char ch ;
  struct termios tio ;
  struct termios saved_tio ;
  sigset_t oset ;
  sigset_t nset ;
  struct sigaction sa ;
  struct sigaction osa ;
  int input___0 ;
  int output___0 ;
  int echo ;
  int tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  ssize_t tmp___2 ;
  __pid_t tmp___3 ;

  {
#line 60
  echo = 0;
#line 62
  if (from_stdin) {
#line 63
    input___0 = 0;
#line 64
    output___0 = 2;
  } else {
#line 66
    output___0 = open("/dev/tty", 2);
#line 66
    input___0 = output___0;
  }
#line 68
  if (input___0 == -1) {
#line 69
    fatal("You have no controlling tty.  Cannot read passphrase.\n");
  }
#line 72
  sigemptyset(& nset);
#line 73
  sigaddset(& nset, 20);
#line 74
  sigprocmask(0, (sigset_t const   * __restrict  )(& nset), (sigset_t * __restrict  )(& oset));
#line 75
  memset((void *)(& sa), 0, sizeof(sa));
#line 76
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))(& intcatch);
#line 77
  sigaction(2, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& osa));
#line 79
  intr = (int volatile   )0;
#line 81
  tmp = tcgetattr(input___0, & saved_tio);
#line 81
  if (tmp == 0) {
#line 81
    if (saved_tio.c_lflag & 8U) {
#line 82
      echo = 1;
#line 83
      tio = saved_tio;
#line 84
      tio.c_lflag &= 4294967175U;
#line 85
      tcsetattr(input___0, 0, (struct termios  const  *)(& tio));
    }
  }
#line 88
  fflush(stdout);
#line 90
  tmp___0 = strlen(prompt);
#line 90
  write(output___0, (void const   *)prompt, tmp___0);
#line 91
  p = buf___1;
#line 91
  while (1) {
#line 91
    tmp___2 = read(input___0, (void *)(& ch), 1U);
#line 91
    if (tmp___2 == 1) {
#line 91
      if (! ((int )ch != 10)) {
#line 91
        break;
      }
    } else {
#line 91
      break;
    }
#line 92
    if (intr) {
#line 93
      break;
    }
#line 94
    if ((unsigned int )p < (unsigned int )((buf___1 + sizeof(buf___1)) - 1)) {
#line 95
      tmp___1 = p;
#line 95
      p ++;
#line 95
      *tmp___1 = ch;
    }
  }
#line 97
  *p = (char )'\000';
#line 98
  if (! intr) {
#line 99
    write(output___0, (void const   *)"\n", 1U);
  }
#line 102
  if (echo) {
#line 103
    tcsetattr(input___0, 0, (struct termios  const  *)(& saved_tio));
  }
#line 104
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((void *)0));
#line 105
  sigaction(2, (struct sigaction  const  * __restrict  )(& osa), (struct sigaction * __restrict  )((void *)0));
#line 107
  if (intr) {
#line 108
    tmp___3 = getpid();
#line 108
    kill(tmp___3, 2);
#line 109
    sigemptyset(& nset);
#line 111
    sigsuspend((sigset_t const   *)(& nset));
  }
#line 114
  if (! from_stdin) {
#line 115
    close(input___0);
  }
#line 116
  p = xstrdup((char const   *)(buf___1));
#line 117
  memset((void *)(buf___1), 0, sizeof(buf___1));
#line 118
  return (p);
}
}
#line 1 "rsa.o"
#pragma merger(0,"./rsa.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 452 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 333 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 490
__inline static int putchar(int __c ) ;
#line 75 "/usr/include/bits/stdio.h"
__inline static int putchar(int __c ) 
{ int tmp ;

  {
#line 78
  tmp = _IO_putc(__c, stdout);
#line 78
  return (tmp);
}
}
#line 221 "/usr/include/openssl/rsa.h"
extern RSA *RSA_generate_key(int bits , unsigned long e , void (*callback)(int  ,
                                                                           int  ,
                                                                           void * ) ,
                             void *cb_arg ) ;
#line 230
extern int RSA_public_encrypt(int flen , unsigned char const   *from , unsigned char *to ,
                              RSA *rsa , int padding ) ;
#line 236
extern int RSA_private_decrypt(int flen , unsigned char const   *from , unsigned char *to ,
                               RSA *rsa , int padding ) ;
#line 25 "rsa.h"
void rsa_generate_key(RSA *prv , RSA *pub , unsigned int bits ) ;
#line 31
void rsa_set_verbose(int verbose___0 ) ;
#line 33
int rsa_alive(void) ;
#line 35
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 36
void rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 45 "rsa.c"
int rsa_verbose  =    1;
#line 47 "rsa.c"
int rsa_alive(void) 
{ RSA *key ;

  {
#line 52
  seed_rng();
#line 53
  key = RSA_generate_key(32, 3UL, (void (*)(int  , int  , void * ))((void *)0), (void *)0);
#line 54
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 55
    return (0);
  }
#line 56
  RSA_free(key);
#line 57
  return (1);
}
}
#line 63 "rsa.c"
void keygen_progress(int p , int n___0 , void *arg ) 
{ char progress_chars[6] ;

  {
#line 66
  progress_chars[0] = (char )'.';
#line 66
  progress_chars[1] = (char )'o';
#line 66
  progress_chars[2] = (char )'+';
#line 66
  progress_chars[3] = (char )'O';
#line 66
  progress_chars[4] = (char )'?';
#line 66
  progress_chars[5] = (char )'\000';
#line 68
  if (p < 0) {
#line 69
    p = (int )(sizeof(progress_chars) - 2U);
  } else {
#line 68
    if ((unsigned int )p > sizeof(progress_chars) - 2U) {
#line 69
      p = (int )(sizeof(progress_chars) - 2U);
    }
  }
#line 71
  putchar((int )progress_chars[p]);
#line 72
  fflush(stdout);
#line 73
  return;
}
}
#line 81 "rsa.c"
void rsa_generate_key(RSA *prv , RSA *pub , unsigned int bits ) 
{ RSA *key ;

  {
#line 86
  seed_rng();
#line 88
  if (rsa_verbose) {
#line 89
    printf((char const   * __restrict  )"Generating RSA keys:  ");
#line 90
    fflush(stdout);
#line 91
    key = RSA_generate_key((int )bits, 35UL, & keygen_progress, (void *)0);
#line 92
    printf((char const   * __restrict  )"\n");
  } else {
#line 94
    key = RSA_generate_key((int )bits, 35UL, (void (*)(int  , int  , void * ))((void *)0),
                           (void *)0);
  }
#line 96
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 97
    fatal("rsa_generate_key: key generation failed.");
  }
#line 100
  pub->n = BN_new();
#line 101
  BN_copy(pub->n, (BIGNUM const   *)key->n);
#line 102
  pub->e = BN_new();
#line 103
  BN_copy(pub->e, (BIGNUM const   *)key->e);
#line 106
  prv->n = BN_new();
#line 107
  BN_copy(prv->n, (BIGNUM const   *)key->n);
#line 108
  prv->e = BN_new();
#line 109
  BN_copy(prv->e, (BIGNUM const   *)key->e);
#line 110
  prv->d = BN_new();
#line 111
  BN_copy(prv->d, (BIGNUM const   *)key->d);
#line 112
  prv->p = BN_new();
#line 113
  BN_copy(prv->p, (BIGNUM const   *)key->p);
#line 114
  prv->q = BN_new();
#line 115
  BN_copy(prv->q, (BIGNUM const   *)key->q);
#line 117
  prv->dmp1 = BN_new();
#line 118
  BN_copy(prv->dmp1, (BIGNUM const   *)key->dmp1);
#line 120
  prv->dmq1 = BN_new();
#line 121
  BN_copy(prv->dmq1, (BIGNUM const   *)key->dmq1);
#line 123
  prv->iqmp = BN_new();
#line 124
  BN_copy(prv->iqmp, (BIGNUM const   *)key->iqmp);
#line 126
  RSA_free(key);
#line 128
  if (rsa_verbose) {
#line 129
    printf((char const   * __restrict  )"Key generation complete.\n");
  }
#line 130
  return;
}
}
#line 132 "rsa.c"
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ unsigned char *inbuf ;
  unsigned char *outbuf ;
  int len ;
  int ilen ;
  int olen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 138
  tmp = BN_num_bits((BIGNUM const   *)key->e);
#line 138
  if (tmp < 2) {
#line 139
    fatal("rsa_public_encrypt() exponent too small or not odd");
  } else {
#line 138
    if ((key->e)->top > 0) {
#line 138
      if (! (*((key->e)->d + 0) & 1UL)) {
#line 139
        fatal("rsa_public_encrypt() exponent too small or not odd");
      }
    } else {
#line 139
      fatal("rsa_public_encrypt() exponent too small or not odd");
    }
  }
#line 141
  tmp___0 = BN_num_bits((BIGNUM const   *)key->n);
#line 141
  olen = (tmp___0 + 7) / 8;
#line 142
  tmp___1 = xmalloc((unsigned int )olen);
#line 142
  outbuf = (unsigned char *)tmp___1;
#line 144
  tmp___2 = BN_num_bits((BIGNUM const   *)in);
#line 144
  ilen = (tmp___2 + 7) / 8;
#line 145
  tmp___3 = xmalloc((unsigned int )ilen);
#line 145
  inbuf = (unsigned char *)tmp___3;
#line 146
  BN_bn2bin((BIGNUM const   *)in, inbuf);
#line 148
  len = RSA_public_encrypt(ilen, (unsigned char const   *)inbuf, outbuf, key, 1);
#line 148
  if (len <= 0) {
#line 150
    fatal("rsa_public_encrypt() failed");
  }
#line 152
  BN_bin2bn((unsigned char const   *)outbuf, len, out);
#line 154
  memset((void *)outbuf, 0, (unsigned int )olen);
#line 155
  memset((void *)inbuf, 0, (unsigned int )ilen);
#line 156
  xfree((void *)outbuf);
#line 157
  xfree((void *)inbuf);
#line 158
  return;
}
}
#line 160 "rsa.c"
void rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ unsigned char *inbuf ;
  unsigned char *outbuf ;
  int len ;
  int ilen ;
  int olen ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 166
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 166
  olen = (tmp + 7) / 8;
#line 167
  tmp___0 = xmalloc((unsigned int )olen);
#line 167
  outbuf = (unsigned char *)tmp___0;
#line 169
  tmp___1 = BN_num_bits((BIGNUM const   *)in);
#line 169
  ilen = (tmp___1 + 7) / 8;
#line 170
  tmp___2 = xmalloc((unsigned int )ilen);
#line 170
  inbuf = (unsigned char *)tmp___2;
#line 171
  BN_bn2bin((BIGNUM const   *)in, inbuf);
#line 173
  len = RSA_private_decrypt(ilen, (unsigned char const   *)inbuf, outbuf, key, 1);
#line 173
  if (len <= 0) {
#line 175
    fatal("rsa_private_decrypt() failed");
  }
#line 177
  BN_bin2bn((unsigned char const   *)outbuf, len, out);
#line 179
  memset((void *)outbuf, 0, (unsigned int )olen);
#line 180
  memset((void *)inbuf, 0, (unsigned int )ilen);
#line 181
  xfree((void *)outbuf);
#line 182
  xfree((void *)inbuf);
#line 183
  return;
}
}
#line 187 "rsa.c"
void rsa_set_verbose(int verbose___0 ) 
{ 

  {
#line 190
  rsa_verbose = verbose___0;
#line 191
  return;
}
}
#line 1 "tildexpand.o"
#pragma merger(0,"./tildexpand.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 111 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 117
extern struct passwd *getpwnam(char const   *__name ) ;
#line 487 "ssh.h"
char *tilde_expand_filename(char const   *filename , uid_t my_uid ) ;
#line 18 "tildexpand.c"
char *tilde_expand_filename(char const   *filename , uid_t my_uid ) 
{ char const   *cp ;
  unsigned int userlen ;
  char *expanded ;
  struct passwd *pw ;
  char user[100] ;
  int len ;
  char *tmp ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;

  {
#line 29
  if ((int const   )*(filename + 0) != 126) {
#line 30
    tmp = xstrdup(filename);
#line 30
    return (tmp);
  }
#line 33
  filename ++;
#line 36
  tmp___1 = __builtin_strchr((char *)filename, '/');
#line 36
  cp = (char const   *)tmp___1;
#line 37
  if (cp) {
#line 38
    userlen = (unsigned int )(cp - filename);
  } else {
#line 40
    userlen = strlen(filename);
  }
#line 41
  if (userlen == 0U) {
#line 42
    pw = getpwuid(my_uid);
  } else {
#line 45
    if (userlen > sizeof(user) - 1U) {
#line 46
      fatal("User name after tilde too long.");
    }
#line 47
    memcpy((void * __restrict  )(user), (void const   * __restrict  )filename, userlen);
#line 48
    user[userlen] = (char)0;
#line 49
    pw = getpwnam((char const   *)(user));
  }
#line 51
  if (! pw) {
#line 52
    fatal("Unknown user %100s.", user);
  }
#line 55
  if (! cp) {
#line 57
    tmp___2 = xstrdup((char const   *)pw->pw_dir);
#line 57
    return (tmp___2);
  }
#line 60
  tmp___3 = strlen((char const   *)pw->pw_dir);
#line 60
  tmp___4 = strlen(cp + 1);
#line 60
  len = (int )((tmp___3 + tmp___4) + 2U);
#line 61
  if (len > 4096) {
#line 62
    fatal("Home directory too long (%d > %d", len - 1, 4095);
  }
#line 63
  tmp___5 = xmalloc((unsigned int )len);
#line 63
  expanded = (char *)tmp___5;
#line 64
  snprintf((char * __restrict  )expanded, (unsigned int )len, (char const   * __restrict  )"%s/%s",
           pw->pw_dir, cp + 1);
#line 65
  return (expanded);
}
}
#line 1 "ttymodes.o"
#pragma merger(0,"./ttymodes.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 49 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) speed_t cfgetospeed(struct termios  const  *__termios_p ) ;
#line 52
extern  __attribute__((__nothrow__)) speed_t cfgetispeed(struct termios  const  *__termios_p ) ;
#line 55
extern  __attribute__((__nothrow__)) int cfsetospeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 58
extern  __attribute__((__nothrow__)) int cfsetispeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 184 "packet.h"
void tty_make_modes(int fd ) ;
#line 187
void tty_parse_modes(int fd , int *n_bytes_ptr ) ;
#line 26 "ttymodes.c"
static int speed_to_baud(speed_t speed ) 
{ 

  {
#line 29
  switch ((int )speed) {
  case 0: 
#line 31
  return (0);
  case 1: 
#line 33
  return (50);
  case 2: 
#line 35
  return (75);
  case 3: 
#line 37
  return (110);
  case 4: 
#line 39
  return (134);
  case 5: 
#line 41
  return (150);
  case 6: 
#line 43
  return (200);
  case 7: 
#line 45
  return (300);
  case 8: 
#line 47
  return (600);
  case 9: 
#line 49
  return (1200);
  case 10: 
#line 51
  return (1800);
  case 11: 
#line 53
  return (2400);
  case 12: 
#line 55
  return (4800);
  case 13: 
#line 57
  return (9600);
  case 14: 
#line 61
  return (19200);
  case 15: 
#line 71
  return (38400);
  case 4097: 
#line 93
  return (57600);
  case 4098: 
#line 101
  return (115200);
  case 4099: 
#line 105
  return (230400);
  default: ;
#line 108
  return (9600);
  }
}
}
#line 115 "ttymodes.c"
static speed_t baud_to_speed(int baud ) 
{ 

  {
#line 118
  switch (baud) {
  case 0: 
#line 120
  return (0U);
  case 50: 
#line 122
  return (1U);
  case 75: 
#line 124
  return (2U);
  case 110: 
#line 126
  return (3U);
  case 134: 
#line 128
  return (4U);
  case 150: 
#line 130
  return (5U);
  case 200: 
#line 132
  return (6U);
  case 300: 
#line 134
  return (7U);
  case 600: 
#line 136
  return (8U);
  case 1200: 
#line 138
  return (9U);
  case 1800: 
#line 140
  return (10U);
  case 2400: 
#line 142
  return (11U);
  case 4800: 
#line 144
  return (12U);
  case 9600: 
#line 146
  return (13U);
  case 19200: 
#line 150
  return (14U);
  case 38400: 
#line 160
  return (15U);
  case 57600: 
#line 182
  return (4097U);
  case 115200: 
#line 190
  return (4098U);
  case 230400: 
#line 194
  return (4099U);
  default: ;
#line 197
  return (13U);
  }
}
}
#line 206 "ttymodes.c"
void tty_make_modes(int fd ) 
{ struct termios tio ;
  int baud ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  speed_t tmp___2 ;
  speed_t tmp___3 ;

  {
#line 212
  tmp___1 = tcgetattr(fd, & tio);
#line 212
  if (tmp___1 < 0) {
#line 213
    packet_put_char(0);
#line 214
    tmp = __errno_location();
#line 214
    tmp___0 = strerror(*tmp);
#line 214
    log("tcgetattr: %.100s", tmp___0);
#line 215
    return;
  }
#line 218
  tmp___2 = cfgetospeed((struct termios  const  *)(& tio));
#line 218
  baud = speed_to_baud(tmp___2);
#line 219
  packet_put_char(193);
#line 220
  packet_put_int((unsigned int )baud);
#line 221
  tmp___3 = cfgetispeed((struct termios  const  *)(& tio));
#line 221
  baud = speed_to_baud(tmp___3);
#line 222
  packet_put_char(192);
#line 223
  packet_put_int((unsigned int )baud);
#line 37 "ttymodes.h"
  packet_put_char(1);
#line 37
  packet_put_char((int )tio.c_cc[0]);
#line 38
  packet_put_char(2);
#line 38
  packet_put_char((int )tio.c_cc[1]);
#line 39
  packet_put_char(3);
#line 39
  packet_put_char((int )tio.c_cc[2]);
#line 41
  packet_put_char(4);
#line 41
  packet_put_char((int )tio.c_cc[3]);
#line 43
  packet_put_char(5);
#line 43
  packet_put_char((int )tio.c_cc[4]);
#line 45
  packet_put_char(6);
#line 45
  packet_put_char((int )tio.c_cc[11]);
#line 48
  packet_put_char(7);
#line 48
  packet_put_char((int )tio.c_cc[16]);
#line 50
  packet_put_char(8);
#line 50
  packet_put_char((int )tio.c_cc[8]);
#line 51
  packet_put_char(9);
#line 51
  packet_put_char((int )tio.c_cc[9]);
#line 53
  packet_put_char(10);
#line 53
  packet_put_char((int )tio.c_cc[10]);
#line 59
  packet_put_char(12);
#line 59
  packet_put_char((int )tio.c_cc[12]);
#line 62
  packet_put_char(13);
#line 62
  packet_put_char((int )tio.c_cc[14]);
#line 65
  packet_put_char(14);
#line 65
  packet_put_char((int )tio.c_cc[15]);
#line 77
  packet_put_char(18);
#line 77
  packet_put_char((int )tio.c_cc[13]);
#line 81
  packet_put_char(30);
#line 81
  packet_put_char((tio.c_iflag & 4U) != 0U);
#line 82
  packet_put_char(31);
#line 82
  packet_put_char((tio.c_iflag & 8U) != 0U);
#line 83
  packet_put_char(32);
#line 83
  packet_put_char((tio.c_iflag & 16U) != 0U);
#line 84
  packet_put_char(33);
#line 84
  packet_put_char((tio.c_iflag & 32U) != 0U);
#line 85
  packet_put_char(34);
#line 85
  packet_put_char((tio.c_iflag & 64U) != 0U);
#line 86
  packet_put_char(35);
#line 86
  packet_put_char((tio.c_iflag & 128U) != 0U);
#line 87
  packet_put_char(36);
#line 87
  packet_put_char((tio.c_iflag & 256U) != 0U);
#line 89
  packet_put_char(37);
#line 89
  packet_put_char((tio.c_iflag & 512U) != 0U);
#line 91
  packet_put_char(38);
#line 91
  packet_put_char((tio.c_iflag & 1024U) != 0U);
#line 92
  packet_put_char(39);
#line 92
  packet_put_char((tio.c_iflag & 2048U) != 0U);
#line 93
  packet_put_char(40);
#line 93
  packet_put_char((tio.c_iflag & 4096U) != 0U);
#line 95
  packet_put_char(41);
#line 95
  packet_put_char((tio.c_iflag & 8192U) != 0U);
#line 98
  packet_put_char(50);
#line 98
  packet_put_char((tio.c_lflag & 1U) != 0U);
#line 99
  packet_put_char(51);
#line 99
  packet_put_char((tio.c_lflag & 2U) != 0U);
#line 101
  packet_put_char(52);
#line 101
  packet_put_char((tio.c_lflag & 4U) != 0U);
#line 103
  packet_put_char(53);
#line 103
  packet_put_char((tio.c_lflag & 8U) != 0U);
#line 104
  packet_put_char(54);
#line 104
  packet_put_char((tio.c_lflag & 16U) != 0U);
#line 105
  packet_put_char(55);
#line 105
  packet_put_char((tio.c_lflag & 32U) != 0U);
#line 106
  packet_put_char(56);
#line 106
  packet_put_char((tio.c_lflag & 64U) != 0U);
#line 107
  packet_put_char(57);
#line 107
  packet_put_char((tio.c_lflag & 128U) != 0U);
#line 108
  packet_put_char(58);
#line 108
  packet_put_char((tio.c_lflag & 256U) != 0U);
#line 110
  packet_put_char(59);
#line 110
  packet_put_char((tio.c_lflag & 32768U) != 0U);
#line 113
  packet_put_char(60);
#line 113
  packet_put_char((tio.c_lflag & 512U) != 0U);
#line 116
  packet_put_char(61);
#line 116
  packet_put_char((tio.c_lflag & 2048U) != 0U);
#line 119
  packet_put_char(62);
#line 119
  packet_put_char((tio.c_lflag & 16384U) != 0U);
#line 122
  packet_put_char(70);
#line 122
  packet_put_char((tio.c_oflag & 1U) != 0U);
#line 124
  packet_put_char(71);
#line 124
  packet_put_char((tio.c_oflag & 2U) != 0U);
#line 126
  packet_put_char(72);
#line 126
  packet_put_char((tio.c_oflag & 4U) != 0U);
#line 128
  packet_put_char(73);
#line 128
  packet_put_char((tio.c_oflag & 8U) != 0U);
#line 131
  packet_put_char(74);
#line 131
  packet_put_char((tio.c_oflag & 16U) != 0U);
#line 134
  packet_put_char(75);
#line 134
  packet_put_char((tio.c_oflag & 32U) != 0U);
#line 137
  packet_put_char(90);
#line 137
  packet_put_char((tio.c_cflag & 32U) != 0U);
#line 138
  packet_put_char(91);
#line 138
  packet_put_char((tio.c_cflag & 48U) != 0U);
#line 139
  packet_put_char(92);
#line 139
  packet_put_char((tio.c_cflag & 256U) != 0U);
#line 140
  packet_put_char(93);
#line 140
  packet_put_char((tio.c_cflag & 512U) != 0U);
#line 243 "ttymodes.c"
  packet_put_char(0);
#line 244
  return;
}
}
#line 250 "ttymodes.c"
void tty_parse_modes(int fd , int *n_bytes_ptr ) 
{ struct termios tio ;
  int opcode ;
  int baud ;
  int n_bytes ;
  int failure ;
  int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  speed_t tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  speed_t tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;
  unsigned int tmp___22 ;
  unsigned int tmp___23 ;
  unsigned int tmp___24 ;
  unsigned int tmp___25 ;
  unsigned int tmp___26 ;
  unsigned int tmp___27 ;
  unsigned int tmp___28 ;
  unsigned int tmp___29 ;
  unsigned int tmp___30 ;
  unsigned int tmp___31 ;
  unsigned int tmp___32 ;
  unsigned int tmp___33 ;
  unsigned int tmp___34 ;
  unsigned int tmp___35 ;
  unsigned int tmp___36 ;
  unsigned int tmp___37 ;
  unsigned int tmp___38 ;
  unsigned int tmp___39 ;
  unsigned int tmp___40 ;
  unsigned int tmp___41 ;
  unsigned int tmp___42 ;
  unsigned int tmp___43 ;
  unsigned int tmp___44 ;
  unsigned int tmp___45 ;
  unsigned int tmp___46 ;
  unsigned int tmp___47 ;
  unsigned int tmp___48 ;
  unsigned int tmp___49 ;
  unsigned int tmp___50 ;
  unsigned int tmp___51 ;
  unsigned int tmp___52 ;
  unsigned int tmp___53 ;
  unsigned int tmp___54 ;
  unsigned int tmp___55 ;
  int _p ;
  int _e ;
  int *tmp___56 ;
  char *tmp___57 ;
  int tmp___58 ;

  {
#line 255
  n_bytes = 0;
#line 256
  failure = 0;
#line 263
  tmp = tcgetattr(fd, & tio);
#line 263
  if (tmp < 0) {
#line 264
    failure = -1;
  }
#line 266
  while (1) {
#line 267
    n_bytes ++;
#line 268
    tmp___0 = packet_get_char();
#line 268
    opcode = (int )tmp___0;
#line 269
    switch (opcode) {
    case 0: 
    goto set;
    case 192: 
#line 274
    n_bytes += 4;
#line 275
    tmp___1 = packet_get_int();
#line 275
    baud = (int )tmp___1;
#line 276
    if (failure != -1) {
#line 276
      tmp___2 = baud_to_speed(baud);
#line 276
      tmp___3 = cfsetispeed(& tio, tmp___2);
#line 276
      if (tmp___3 < 0) {
#line 277
        error("cfsetispeed failed for %d", baud);
      }
    }
#line 278
    break;
    case 193: 
#line 281
    n_bytes += 4;
#line 282
    tmp___4 = packet_get_int();
#line 282
    baud = (int )tmp___4;
#line 283
    if (failure != -1) {
#line 283
      tmp___5 = baud_to_speed(baud);
#line 283
      tmp___6 = cfsetospeed(& tio, tmp___5);
#line 283
      if (tmp___6 < 0) {
#line 284
        error("cfsetospeed failed for %d", baud);
      }
    }
#line 285
    break;
    case 1: 
#line 37 "ttymodes.h"
    n_bytes ++;
#line 37
    tmp___7 = packet_get_char();
#line 37
    tio.c_cc[0] = (unsigned char )tmp___7;
#line 37
    break;
    case 2: 
#line 38
    n_bytes ++;
#line 38
    tmp___8 = packet_get_char();
#line 38
    tio.c_cc[1] = (unsigned char )tmp___8;
#line 38
    break;
    case 3: 
#line 39
    n_bytes ++;
#line 39
    tmp___9 = packet_get_char();
#line 39
    tio.c_cc[2] = (unsigned char )tmp___9;
#line 39
    break;
    case 4: 
#line 41
    n_bytes ++;
#line 41
    tmp___10 = packet_get_char();
#line 41
    tio.c_cc[3] = (unsigned char )tmp___10;
#line 41
    break;
    case 5: 
#line 43
    n_bytes ++;
#line 43
    tmp___11 = packet_get_char();
#line 43
    tio.c_cc[4] = (unsigned char )tmp___11;
#line 43
    break;
    case 6: 
#line 45
    n_bytes ++;
#line 45
    tmp___12 = packet_get_char();
#line 45
    tio.c_cc[11] = (unsigned char )tmp___12;
#line 45
    break;
    case 7: 
#line 48
    n_bytes ++;
#line 48
    tmp___13 = packet_get_char();
#line 48
    tio.c_cc[16] = (unsigned char )tmp___13;
#line 48
    break;
    case 8: 
#line 50
    n_bytes ++;
#line 50
    tmp___14 = packet_get_char();
#line 50
    tio.c_cc[8] = (unsigned char )tmp___14;
#line 50
    break;
    case 9: 
#line 51
    n_bytes ++;
#line 51
    tmp___15 = packet_get_char();
#line 51
    tio.c_cc[9] = (unsigned char )tmp___15;
#line 51
    break;
    case 10: 
#line 53
    n_bytes ++;
#line 53
    tmp___16 = packet_get_char();
#line 53
    tio.c_cc[10] = (unsigned char )tmp___16;
#line 53
    break;
    case 12: 
#line 59
    n_bytes ++;
#line 59
    tmp___17 = packet_get_char();
#line 59
    tio.c_cc[12] = (unsigned char )tmp___17;
#line 59
    break;
    case 13: 
#line 62
    n_bytes ++;
#line 62
    tmp___18 = packet_get_char();
#line 62
    tio.c_cc[14] = (unsigned char )tmp___18;
#line 62
    break;
    case 14: 
#line 65
    n_bytes ++;
#line 65
    tmp___19 = packet_get_char();
#line 65
    tio.c_cc[15] = (unsigned char )tmp___19;
#line 65
    break;
    case 18: 
#line 77
    n_bytes ++;
#line 77
    tmp___20 = packet_get_char();
#line 77
    tio.c_cc[13] = (unsigned char )tmp___20;
#line 77
    break;
    case 30: 
#line 81
    n_bytes ++;
#line 81
    tmp___21 = packet_get_char();
#line 81
    if (tmp___21) {
#line 81
      tio.c_iflag |= 4U;
    } else {
#line 81
      tio.c_iflag &= 4294967291U;
    }
#line 81
    break;
    case 31: 
#line 82
    n_bytes ++;
#line 82
    tmp___22 = packet_get_char();
#line 82
    if (tmp___22) {
#line 82
      tio.c_iflag |= 8U;
    } else {
#line 82
      tio.c_iflag &= 4294967287U;
    }
#line 82
    break;
    case 32: 
#line 83
    n_bytes ++;
#line 83
    tmp___23 = packet_get_char();
#line 83
    if (tmp___23) {
#line 83
      tio.c_iflag |= 16U;
    } else {
#line 83
      tio.c_iflag &= 4294967279U;
    }
#line 83
    break;
    case 33: 
#line 84
    n_bytes ++;
#line 84
    tmp___24 = packet_get_char();
#line 84
    if (tmp___24) {
#line 84
      tio.c_iflag |= 32U;
    } else {
#line 84
      tio.c_iflag &= 4294967263U;
    }
#line 84
    break;
    case 34: 
#line 85
    n_bytes ++;
#line 85
    tmp___25 = packet_get_char();
#line 85
    if (tmp___25) {
#line 85
      tio.c_iflag |= 64U;
    } else {
#line 85
      tio.c_iflag &= 4294967231U;
    }
#line 85
    break;
    case 35: 
#line 86
    n_bytes ++;
#line 86
    tmp___26 = packet_get_char();
#line 86
    if (tmp___26) {
#line 86
      tio.c_iflag |= 128U;
    } else {
#line 86
      tio.c_iflag &= 4294967167U;
    }
#line 86
    break;
    case 36: 
#line 87
    n_bytes ++;
#line 87
    tmp___27 = packet_get_char();
#line 87
    if (tmp___27) {
#line 87
      tio.c_iflag |= 256U;
    } else {
#line 87
      tio.c_iflag &= 4294967039U;
    }
#line 87
    break;
    case 37: 
#line 89
    n_bytes ++;
#line 89
    tmp___28 = packet_get_char();
#line 89
    if (tmp___28) {
#line 89
      tio.c_iflag |= 512U;
    } else {
#line 89
      tio.c_iflag &= 4294966783U;
    }
#line 89
    break;
    case 38: 
#line 91
    n_bytes ++;
#line 91
    tmp___29 = packet_get_char();
#line 91
    if (tmp___29) {
#line 91
      tio.c_iflag |= 1024U;
    } else {
#line 91
      tio.c_iflag &= 4294966271U;
    }
#line 91
    break;
    case 39: 
#line 92
    n_bytes ++;
#line 92
    tmp___30 = packet_get_char();
#line 92
    if (tmp___30) {
#line 92
      tio.c_iflag |= 2048U;
    } else {
#line 92
      tio.c_iflag &= 4294965247U;
    }
#line 92
    break;
    case 40: 
#line 93
    n_bytes ++;
#line 93
    tmp___31 = packet_get_char();
#line 93
    if (tmp___31) {
#line 93
      tio.c_iflag |= 4096U;
    } else {
#line 93
      tio.c_iflag &= 4294963199U;
    }
#line 93
    break;
    case 41: 
#line 95
    n_bytes ++;
#line 95
    tmp___32 = packet_get_char();
#line 95
    if (tmp___32) {
#line 95
      tio.c_iflag |= 8192U;
    } else {
#line 95
      tio.c_iflag &= 4294959103U;
    }
#line 95
    break;
    case 50: 
#line 98
    n_bytes ++;
#line 98
    tmp___33 = packet_get_char();
#line 98
    if (tmp___33) {
#line 98
      tio.c_lflag |= 1U;
    } else {
#line 98
      tio.c_lflag &= 4294967294U;
    }
#line 98
    break;
    case 51: 
#line 99
    n_bytes ++;
#line 99
    tmp___34 = packet_get_char();
#line 99
    if (tmp___34) {
#line 99
      tio.c_lflag |= 2U;
    } else {
#line 99
      tio.c_lflag &= 4294967293U;
    }
#line 99
    break;
    case 52: 
#line 101
    n_bytes ++;
#line 101
    tmp___35 = packet_get_char();
#line 101
    if (tmp___35) {
#line 101
      tio.c_lflag |= 4U;
    } else {
#line 101
      tio.c_lflag &= 4294967291U;
    }
#line 101
    break;
    case 53: 
#line 103
    n_bytes ++;
#line 103
    tmp___36 = packet_get_char();
#line 103
    if (tmp___36) {
#line 103
      tio.c_lflag |= 8U;
    } else {
#line 103
      tio.c_lflag &= 4294967287U;
    }
#line 103
    break;
    case 54: 
#line 104
    n_bytes ++;
#line 104
    tmp___37 = packet_get_char();
#line 104
    if (tmp___37) {
#line 104
      tio.c_lflag |= 16U;
    } else {
#line 104
      tio.c_lflag &= 4294967279U;
    }
#line 104
    break;
    case 55: 
#line 105
    n_bytes ++;
#line 105
    tmp___38 = packet_get_char();
#line 105
    if (tmp___38) {
#line 105
      tio.c_lflag |= 32U;
    } else {
#line 105
      tio.c_lflag &= 4294967263U;
    }
#line 105
    break;
    case 56: 
#line 106
    n_bytes ++;
#line 106
    tmp___39 = packet_get_char();
#line 106
    if (tmp___39) {
#line 106
      tio.c_lflag |= 64U;
    } else {
#line 106
      tio.c_lflag &= 4294967231U;
    }
#line 106
    break;
    case 57: 
#line 107
    n_bytes ++;
#line 107
    tmp___40 = packet_get_char();
#line 107
    if (tmp___40) {
#line 107
      tio.c_lflag |= 128U;
    } else {
#line 107
      tio.c_lflag &= 4294967167U;
    }
#line 107
    break;
    case 58: 
#line 108
    n_bytes ++;
#line 108
    tmp___41 = packet_get_char();
#line 108
    if (tmp___41) {
#line 108
      tio.c_lflag |= 256U;
    } else {
#line 108
      tio.c_lflag &= 4294967039U;
    }
#line 108
    break;
    case 59: 
#line 110
    n_bytes ++;
#line 110
    tmp___42 = packet_get_char();
#line 110
    if (tmp___42) {
#line 110
      tio.c_lflag |= 32768U;
    } else {
#line 110
      tio.c_lflag &= 4294934527U;
    }
#line 110
    break;
    case 60: 
#line 113
    n_bytes ++;
#line 113
    tmp___43 = packet_get_char();
#line 113
    if (tmp___43) {
#line 113
      tio.c_lflag |= 512U;
    } else {
#line 113
      tio.c_lflag &= 4294966783U;
    }
#line 113
    break;
    case 61: 
#line 116
    n_bytes ++;
#line 116
    tmp___44 = packet_get_char();
#line 116
    if (tmp___44) {
#line 116
      tio.c_lflag |= 2048U;
    } else {
#line 116
      tio.c_lflag &= 4294965247U;
    }
#line 116
    break;
    case 62: 
#line 119
    n_bytes ++;
#line 119
    tmp___45 = packet_get_char();
#line 119
    if (tmp___45) {
#line 119
      tio.c_lflag |= 16384U;
    } else {
#line 119
      tio.c_lflag &= 4294950911U;
    }
#line 119
    break;
    case 70: 
#line 122
    n_bytes ++;
#line 122
    tmp___46 = packet_get_char();
#line 122
    if (tmp___46) {
#line 122
      tio.c_oflag |= 1U;
    } else {
#line 122
      tio.c_oflag &= 4294967294U;
    }
#line 122
    break;
    case 71: 
#line 124
    n_bytes ++;
#line 124
    tmp___47 = packet_get_char();
#line 124
    if (tmp___47) {
#line 124
      tio.c_oflag |= 2U;
    } else {
#line 124
      tio.c_oflag &= 4294967293U;
    }
#line 124
    break;
    case 72: 
#line 126
    n_bytes ++;
#line 126
    tmp___48 = packet_get_char();
#line 126
    if (tmp___48) {
#line 126
      tio.c_oflag |= 4U;
    } else {
#line 126
      tio.c_oflag &= 4294967291U;
    }
#line 126
    break;
    case 73: 
#line 128
    n_bytes ++;
#line 128
    tmp___49 = packet_get_char();
#line 128
    if (tmp___49) {
#line 128
      tio.c_oflag |= 8U;
    } else {
#line 128
      tio.c_oflag &= 4294967287U;
    }
#line 128
    break;
    case 74: 
#line 131
    n_bytes ++;
#line 131
    tmp___50 = packet_get_char();
#line 131
    if (tmp___50) {
#line 131
      tio.c_oflag |= 16U;
    } else {
#line 131
      tio.c_oflag &= 4294967279U;
    }
#line 131
    break;
    case 75: 
#line 134
    n_bytes ++;
#line 134
    tmp___51 = packet_get_char();
#line 134
    if (tmp___51) {
#line 134
      tio.c_oflag |= 32U;
    } else {
#line 134
      tio.c_oflag &= 4294967263U;
    }
#line 134
    break;
    case 90: 
#line 137
    n_bytes ++;
#line 137
    tmp___52 = packet_get_char();
#line 137
    if (tmp___52) {
#line 137
      tio.c_cflag |= 32U;
    } else {
#line 137
      tio.c_cflag &= 4294967263U;
    }
#line 137
    break;
    case 91: 
#line 138
    n_bytes ++;
#line 138
    tmp___53 = packet_get_char();
#line 138
    if (tmp___53) {
#line 138
      tio.c_cflag |= 48U;
    } else {
#line 138
      tio.c_cflag &= 4294967247U;
    }
#line 138
    break;
    case 92: 
#line 139
    n_bytes ++;
#line 139
    tmp___54 = packet_get_char();
#line 139
    if (tmp___54) {
#line 139
      tio.c_cflag |= 256U;
    } else {
#line 139
      tio.c_cflag &= 4294967039U;
    }
#line 139
    break;
    case 93: 
#line 140
    n_bytes ++;
#line 140
    tmp___55 = packet_get_char();
#line 140
    if (tmp___55) {
#line 140
      tio.c_cflag |= 512U;
    } else {
#line 140
      tio.c_cflag &= 4294966783U;
    }
#line 140
    break;
    default: 
#line 313 "ttymodes.c"
    debug("Ignoring unsupported tty mode opcode %d (0x%x)", opcode, opcode);
#line 319
    if (opcode >= 0) {
#line 319
      if (opcode < 128) {
#line 320
        n_bytes ++;
#line 321
        packet_get_char();
#line 322
        break;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 328
      if (opcode >= 128) {
#line 328
        if (opcode < 160) {
#line 329
          n_bytes += 4;
#line 330
          packet_get_int();
#line 331
          break;
        }
      }
    }
#line 341
    log("parse_tty_modes: unknown opcode %d", opcode);
#line 342
    while (1) {
#line 342
      _p = 0;
#line 342
      _e = 1;
#line 342
      if (_p != _e) {
#line 342
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "ttymodes.c", 342);
#line 342
        packet_disconnect("Packet integrity error. (%d)", 10);
      }
#line 342
      break;
    }
    goto set;
    }
  }
  set: 
#line 348
  if (*n_bytes_ptr != n_bytes) {
#line 349
    *n_bytes_ptr = n_bytes;
#line 350
    return;
  }
#line 352
  if (failure == -1) {
#line 353
    return;
  }
#line 356
  tmp___58 = tcsetattr(fd, 0, (struct termios  const  *)(& tio));
#line 356
  if (tmp___58 < 0) {
#line 357
    tmp___56 = __errno_location();
#line 357
    tmp___57 = strerror(*tmp___56);
#line 357
    log("Setting tty modes failed: %.100s", tmp___57);
  }
#line 358
  return;
}
}
#line 1 "uidswap.o"
#pragma merger(0,"./uidswap.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 645 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 667
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 677
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 34 "uidswap.h"
void permanently_set_uid(uid_t uid ) ;
#line 30 "uidswap.c"
static uid_t saved_euid  =    (uid_t )0;
#line 38 "uidswap.c"
void temporarily_use_uid(uid_t uid ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 43
  saved_euid = geteuid();
#line 46
  tmp___1 = seteuid(uid);
#line 46
  if (tmp___1 == -1) {
#line 47
    tmp = __errno_location();
#line 47
    tmp___0 = strerror(*tmp);
#line 47
    debug("seteuid %d: %.100s", (int )uid, tmp___0);
  }
#line 57
  return;
}
}
#line 62 "uidswap.c"
void restore_uid(void) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 67
  tmp___1 = seteuid(saved_euid);
#line 67
  if (tmp___1 < 0) {
#line 68
    tmp = __errno_location();
#line 68
    tmp___0 = strerror(*tmp);
#line 68
    debug("seteuid %d: %.100s", (int )saved_euid, tmp___0);
  }
#line 77
  return;
}
}
#line 83 "uidswap.c"
void permanently_set_uid(uid_t uid ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 86
  tmp___1 = setuid(uid);
#line 86
  if (tmp___1 < 0) {
#line 87
    tmp = __errno_location();
#line 87
    tmp___0 = strerror(*tmp);
#line 87
    debug("setuid %d: %.100s", (int )uid, tmp___0);
  }
#line 88
  return;
}
}
#line 1 "uuencode.o"
#pragma merger(0,"./uuencode.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 8 "bsd-base64.h"
int b64_ntop(u_char const   *src , size_t srclength , char *target , size_t targsize ) ;
#line 10
int b64_pton(char const   *src , u_char *target , size_t targsize ) ;
#line 7 "uuencode.c"
int uuencode(unsigned char *src , unsigned int srclength , char *target , size_t targsize ) 
{ int tmp ;

  {
#line 11
  tmp = b64_ntop((u_char const   *)src, srclength, target, targsize);
#line 11
  return (tmp);
}
}
#line 14 "uuencode.c"
int uudecode(char const   *src , unsigned char *target , size_t targsize ) 
{ int len ;
  char *encoded ;
  char *p ;

  {
#line 21
  encoded = xstrdup(src);
#line 23
  p = encoded;
#line 23
  while (1) {
#line 23
    if (! ((int )*p == 32)) {
#line 23
      if (! ((int )*p == 9)) {
#line 23
        break;
      }
    }
#line 23
    p ++;
  }
#line 25
  while (1) {
#line 25
    if ((int )*p != 0) {
#line 25
      if ((int )*p != 32) {
#line 25
        if (! ((int )*p != 9)) {
#line 25
          break;
        }
      } else {
#line 25
        break;
      }
    } else {
#line 25
      break;
    }
#line 25
    p ++;
  }
#line 28
  *p = (char )'\000';
#line 29
  len = b64_pton((char const   *)encoded, target, targsize);
#line 30
  xfree((void *)encoded);
#line 31
  return (len);
}
}
#line 34 "uuencode.c"
void dump_base64(FILE *fp , unsigned char *data , int len ) 
{ unsigned char *buf___1 ;
  void *tmp ;
  int i ;
  int n___0 ;

  {
#line 37
  tmp = xmalloc((unsigned int )(2 * len));
#line 37
  buf___1 = (unsigned char *)tmp;
#line 39
  n___0 = uuencode(data, (unsigned int )len, (char *)buf___1, (unsigned int )(2 * len));
#line 40
  i = 0;
#line 40
  while (i < n___0) {
#line 41
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%c", *(buf___1 + i));
#line 42
    if (i % 70 == 69) {
#line 43
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
    }
#line 40
    i ++;
  }
#line 45
  if (i % 70 != 69) {
#line 46
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  }
#line 47
  xfree((void *)buf___1);
#line 48
  return;
}
}
#line 1 "xmalloc.o"
#pragma merger(0,"./xmalloc.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 589 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 600
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__warn_unused_result__,
__malloc__)) ;
#line 15 "xmalloc.c"
void *xmalloc(size_t size ) 
{ void *ptr ;
  void *tmp ;

  {
#line 18
  tmp = malloc(size);
#line 18
  ptr = tmp;
#line 19
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 20
    fatal("xmalloc: out of memory (allocating %d bytes)", (int )size);
  }
#line 21
  return (ptr);
}
}
#line 24 "xmalloc.c"
void *xrealloc(void *ptr , size_t new_size ) 
{ void *new_ptr ;

  {
#line 29
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 30
    fatal("xrealloc: NULL pointer given as argument");
  }
#line 31
  new_ptr = realloc(ptr, new_size);
#line 32
  if ((unsigned int )new_ptr == (unsigned int )((void *)0)) {
#line 33
    fatal("xrealloc: out of memory (new_size %d bytes)", (int )new_size);
  }
#line 34
  return (new_ptr);
}
}
#line 37 "xmalloc.c"
void xfree(void *ptr ) 
{ 

  {
#line 40
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 41
    fatal("xfree: NULL pointer given as argument");
  }
#line 42
  free(ptr);
#line 43
  return;
}
}
#line 45 "xmalloc.c"
char *xstrdup(char const   *str ) 
{ int len ;
  size_t tmp ;
  char *cp ;
  void *tmp___0 ;

  {
#line 48
  tmp = strlen(str);
#line 48
  len = (int )(tmp + 1U);
#line 50
  tmp___0 = xmalloc((unsigned int )len);
#line 50
  cp = (char *)tmp___0;
#line 51
  strlcpy(cp, str, (unsigned int )len);
#line 52
  return (cp);
}
}
#line 1 "bsd-base64.o"
#pragma merger(0,"./bsd-base64.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 628 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 65 "bsd-base64.c"
static char const   Base64[65]  = 
#line 65 "bsd-base64.c"
  {      (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'g',      (char const   )'h',      (char const   )'i',      (char const   )'j', 
        (char const   )'k',      (char const   )'l',      (char const   )'m',      (char const   )'n', 
        (char const   )'o',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'+',      (char const   )'/', 
        (char const   )'\000'};
#line 67 "bsd-base64.c"
static char const   Pad64  =    (char const   )'=';
#line 132 "bsd-base64.c"
int b64_ntop(u_char const   *src , size_t srclength , char *target , size_t targsize ) 
{ size_t datalength ;
  u_char input___0[3] ;
  u_char output___0[4] ;
  int i ;
  u_char const   *tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  u_char const   *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;

  {
#line 135
  datalength = (size_t )0;
#line 140
  while (2U < srclength) {
#line 141
    tmp = src;
#line 141
    src ++;
#line 141
    input___0[0] = (unsigned char )*tmp;
#line 142
    tmp___0 = src;
#line 142
    src ++;
#line 142
    input___0[1] = (unsigned char )*tmp___0;
#line 143
    tmp___1 = src;
#line 143
    src ++;
#line 143
    input___0[2] = (unsigned char )*tmp___1;
#line 144
    srclength -= 3U;
#line 146
    output___0[0] = (unsigned char )((int )input___0[0] >> 2);
#line 147
    output___0[1] = (unsigned char )((((int )input___0[0] & 3) << 4) + ((int )input___0[1] >> 4));
#line 148
    output___0[2] = (unsigned char )((((int )input___0[1] & 15) << 2) + ((int )input___0[2] >> 6));
#line 149
    output___0[3] = (unsigned char )((int )input___0[2] & 63);
#line 150
    if (! ((int )output___0[0] < 64)) {
#line 150
      abort();
    }
#line 151
    if (! ((int )output___0[1] < 64)) {
#line 151
      abort();
    }
#line 152
    if (! ((int )output___0[2] < 64)) {
#line 152
      abort();
    }
#line 153
    if (! ((int )output___0[3] < 64)) {
#line 153
      abort();
    }
#line 155
    if (datalength + 4U > targsize) {
#line 156
      return (-1);
    }
#line 157
    tmp___2 = datalength;
#line 157
    datalength ++;
#line 157
    *(target + tmp___2) = (char )Base64[output___0[0]];
#line 158
    tmp___3 = datalength;
#line 158
    datalength ++;
#line 158
    *(target + tmp___3) = (char )Base64[output___0[1]];
#line 159
    tmp___4 = datalength;
#line 159
    datalength ++;
#line 159
    *(target + tmp___4) = (char )Base64[output___0[2]];
#line 160
    tmp___5 = datalength;
#line 160
    datalength ++;
#line 160
    *(target + tmp___5) = (char )Base64[output___0[3]];
  }
#line 164
  if (0U != srclength) {
#line 166
    input___0[2] = (unsigned char )'\000';
#line 166
    input___0[1] = input___0[2];
#line 166
    input___0[0] = input___0[1];
#line 167
    i = 0;
#line 167
    while ((size_t )i < srclength) {
#line 168
      tmp___6 = src;
#line 168
      src ++;
#line 168
      input___0[i] = (unsigned char )*tmp___6;
#line 167
      i ++;
    }
#line 170
    output___0[0] = (unsigned char )((int )input___0[0] >> 2);
#line 171
    output___0[1] = (unsigned char )((((int )input___0[0] & 3) << 4) + ((int )input___0[1] >> 4));
#line 172
    output___0[2] = (unsigned char )((((int )input___0[1] & 15) << 2) + ((int )input___0[2] >> 6));
#line 173
    if (! ((int )output___0[0] < 64)) {
#line 173
      abort();
    }
#line 174
    if (! ((int )output___0[1] < 64)) {
#line 174
      abort();
    }
#line 175
    if (! ((int )output___0[2] < 64)) {
#line 175
      abort();
    }
#line 177
    if (datalength + 4U > targsize) {
#line 178
      return (-1);
    }
#line 179
    tmp___7 = datalength;
#line 179
    datalength ++;
#line 179
    *(target + tmp___7) = (char )Base64[output___0[0]];
#line 180
    tmp___8 = datalength;
#line 180
    datalength ++;
#line 180
    *(target + tmp___8) = (char )Base64[output___0[1]];
#line 181
    if (srclength == 1U) {
#line 182
      tmp___9 = datalength;
#line 182
      datalength ++;
#line 182
      *(target + tmp___9) = (char )Pad64;
    } else {
#line 184
      tmp___10 = datalength;
#line 184
      datalength ++;
#line 184
      *(target + tmp___10) = (char )Base64[output___0[2]];
    }
#line 185
    tmp___11 = datalength;
#line 185
    datalength ++;
#line 185
    *(target + tmp___11) = (char )Pad64;
  }
#line 187
  if (datalength >= targsize) {
#line 188
    return (-1);
  }
#line 189
  *(target + datalength) = (char )'\000';
#line 190
  return ((int )datalength);
}
}
#line 199 "bsd-base64.c"
int b64_pton(char const   *src , u_char *target , size_t targsize ) 
{ int tarindex ;
  int state ;
  int ch ;
  char *pos ;
  unsigned short const   **tmp ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  unsigned short const   **tmp___8 ;

  {
#line 205
  state = 0;
#line 206
  tarindex = 0;
#line 208
  while (1) {
#line 208
    tmp___2 = src;
#line 208
    src ++;
#line 208
    ch = (int )*tmp___2;
#line 208
    if (! (ch != 0)) {
#line 208
      break;
    }
#line 209
    tmp = __ctype_b_loc();
#line 209
    if ((int const   )*(*tmp + ch) & 8192) {
#line 210
      continue;
    }
#line 212
    if (ch == (int )Pad64) {
#line 213
      break;
    }
#line 215
    tmp___1 = __builtin_strchr((char *)(Base64), ch);
#line 215
    pos = tmp___1;
#line 216
    if ((unsigned int )pos == (unsigned int )((char *)0)) {
#line 217
      return (-1);
    }
#line 219
    switch (state) {
    case 0: 
#line 221
    if (target) {
#line 222
      if ((size_t )tarindex >= targsize) {
#line 223
        return (-1);
      }
#line 224
      *(target + tarindex) = (unsigned char )((pos - (char *)(Base64)) << 2);
    }
#line 226
    state = 1;
#line 227
    break;
    case 1: 
#line 229
    if (target) {
#line 230
      if ((size_t )(tarindex + 1) >= targsize) {
#line 231
        return (-1);
      }
#line 232
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | ((pos - (char *)(Base64)) >> 4));
#line 233
      *(target + (tarindex + 1)) = (unsigned char )(((pos - (char *)(Base64)) & 15) << 4);
    }
#line 236
    tarindex ++;
#line 237
    state = 2;
#line 238
    break;
    case 2: 
#line 240
    if (target) {
#line 241
      if ((size_t )(tarindex + 1) >= targsize) {
#line 242
        return (-1);
      }
#line 243
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | ((pos - (char *)(Base64)) >> 2));
#line 244
      *(target + (tarindex + 1)) = (unsigned char )(((pos - (char *)(Base64)) & 3) << 6);
    }
#line 247
    tarindex ++;
#line 248
    state = 3;
#line 249
    break;
    case 3: 
#line 251
    if (target) {
#line 252
      if ((size_t )tarindex >= targsize) {
#line 253
        return (-1);
      }
#line 254
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | (pos - (char *)(Base64)));
    }
#line 256
    tarindex ++;
#line 257
    state = 0;
#line 258
    break;
    }
  }
#line 267
  if (ch == (int )Pad64) {
#line 268
    tmp___3 = src;
#line 268
    src ++;
#line 268
    ch = (int )*tmp___3;
#line 269
    switch (state) {
    case 0: 
    case 1: 
#line 272
    return (-1);
    case 2: 
#line 276
    while (ch != 0) {
#line 277
      tmp___5 = __ctype_b_loc();
#line 277
      if (! ((int const   )*(*tmp___5 + ch) & 8192)) {
#line 278
        break;
      }
#line 276
      tmp___4 = src;
#line 276
      src ++;
#line 276
      ch = (int )*tmp___4;
    }
#line 280
    if (ch != (int )Pad64) {
#line 281
      return (-1);
    }
#line 282
    tmp___6 = src;
#line 282
    src ++;
#line 282
    ch = (int )*tmp___6;
    case 3: 
#line 291
    while (ch != 0) {
#line 292
      tmp___8 = __ctype_b_loc();
#line 292
      if (! ((int const   )*(*tmp___8 + ch) & 8192)) {
#line 293
        return (-1);
      }
#line 291
      tmp___7 = src;
#line 291
      src ++;
#line 291
      ch = (int )*tmp___7;
    }
#line 301
    if (target) {
#line 301
      if ((int )*(target + tarindex) != 0) {
#line 302
        return (-1);
      }
    }
    }
  } else {
#line 309
    if (state != 0) {
#line 310
      return (-1);
    }
  }
#line 313
  return (tarindex);
}
}
#line 1 "bsd-bindresvport.o"
#pragma merger(0,"./bsd-bindresvport.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 7 "bsd-bindresvport.h"
int bindresvport_af(int sd , struct sockaddr *sa , int af ) ;
#line 53 "bsd-bindresvport.c"
int bindresvport_af(int sd , struct sockaddr *sa , int af ) 
{ int error___0 ;
  struct sockaddr_storage myaddr ;
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;
  u_int16_t *portp ;
  u_int16_t port ;
  int salen ;
  int i ;
  int *tmp ;
  register unsigned short __v ;
  register unsigned short __x ;
  unsigned int tmp___0 ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 68
  if ((unsigned int )sa == (unsigned int )((void *)0)) {
#line 69
    memset((void *)(& myaddr), 0, sizeof(myaddr));
#line 70
    sa = (struct sockaddr *)(& myaddr);
  }
#line 73
  if (af == 2) {
#line 74
    sin = (struct sockaddr_in *)sa;
#line 75
    salen = (int )sizeof(struct sockaddr_in );
#line 76
    portp = & sin->sin_port;
  } else {
#line 77
    if (af == 10) {
#line 78
      sin6 = (struct sockaddr_in6 *)sa;
#line 79
      salen = (int )sizeof(struct sockaddr_in6 );
#line 80
      portp = & sin6->sin6_port;
    } else {
#line 82
      tmp = __errno_location();
#line 82
      *tmp = 96;
#line 83
      return (-1);
    }
  }
#line 85
  sa->sa_family = (unsigned short )af;
#line 87
  __x = *portp;
#line 87
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 87
  port = __v;
#line 88
  if ((int )port == 0) {
#line 89
    tmp___0 = arc4random();
#line 89
    port = (unsigned short )(tmp___0 % 424U + 600U);
  }
#line 91
  i = 0;
#line 91
  while (i < 424) {
#line 92
    __x___0 = port;
#line 92
    __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 92
    *portp = __v___0;
#line 94
    error___0 = bind(sd, (struct sockaddr  const  *)sa, (unsigned int )salen);
#line 97
    if (error___0 == 0) {
#line 98
      break;
    }
#line 101
    if (error___0 < 0) {
#line 101
      tmp___1 = __errno_location();
#line 101
      if (! (*tmp___1 == 98)) {
#line 101
        tmp___2 = __errno_location();
#line 101
        if (! (*tmp___2 == 22)) {
#line 102
          break;
        }
      }
    }
#line 104
    port = (u_int16_t )((int )port + 1);
#line 105
    if ((int )port > 1023) {
#line 106
      port = (unsigned short)600;
    }
#line 91
    i ++;
  }
#line 109
  return (error___0);
}
}
#line 1 "bsd-daemon.o"
#pragma merger(0,"./bsd-daemon.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "bsd-misc.o"
#pragma merger(0,"./bsd-misc.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 828 "/usr/include/unistd.h"
 __attribute__((__nothrow__)) int setlogin(char const   *name )  __attribute__((__nonnull__(1))) ;
#line 37 "bsd-misc.h"
void arc4random_stir(void) ;
#line 41
void setproctitle(char const   *fmt  , ...) ;
#line 102 "/usr/include/openssl/rand.h"
extern int RAND_bytes(unsigned char *buf , int num ) ;
#line 61 "bsd-misc.c"
void rc4_key(rc4_t *r , unsigned char *key , int len ) ;
#line 62
void rc4_getbytes(rc4_t *r , unsigned char *buffer , int len ) ;
#line 64 "bsd-misc.c"
static rc4_t *rc4  =    (rc4_t *)((void *)0);
#line 66 "bsd-misc.c"
void rc4_key(rc4_t *r , unsigned char *key , int len ) 
{ int t ;

  {
#line 70
  r->i = 0;
#line 70
  while (r->i < 256) {
#line 71
    r->s[r->i] = (unsigned int )r->i;
#line 70
    (r->i) ++;
  }
#line 73
  r->j = 0;
#line 74
  r->i = 0;
#line 74
  while (r->i < 256) {
#line 76
    r->j = (int )((((unsigned int )r->j + r->s[r->i]) + (unsigned int )*(key + r->i % len)) % 256U);
#line 77
    t = (int )r->s[r->i];
#line 78
    r->s[r->i] = r->s[r->j];
#line 79
    r->s[r->j] = (unsigned int )t;
#line 74
    (r->i) ++;
  }
#line 81
  r->j = 0;
#line 81
  r->i = r->j;
#line 82
  return;
}
}
#line 84 "bsd-misc.c"
void rc4_getbytes(rc4_t *r , unsigned char *buffer , int len ) 
{ int t ;
  int c ;

  {
#line 89
  c = 0;
#line 90
  while (c < len) {
#line 92
    r->i = (r->i + 1) % 256;
#line 93
    r->j = (int )(((unsigned int )r->j + r->s[r->i]) % 256U);
#line 94
    t = (int )r->s[r->i];
#line 95
    r->s[r->i] = r->s[r->j];
#line 96
    r->s[r->j] = (unsigned int )t;
#line 98
    t = (int )((r->s[r->i] + r->s[r->j]) % 256U);
#line 100
    *(buffer + c) = (unsigned char )r->s[t];
#line 101
    c ++;
  }
#line 103
  return;
}
}
#line 105 "bsd-misc.c"
unsigned int arc4random(void) 
{ unsigned int r ;

  {
#line 109
  if ((unsigned int )rc4 == (unsigned int )((void *)0)) {
#line 110
    arc4random_stir();
  }
#line 112
  rc4_getbytes(rc4, (unsigned char *)(& r), (int )sizeof(r));
#line 114
  return (r);
}
}
#line 117 "bsd-misc.c"
void arc4random_stir(void) 
{ unsigned char rand_buf[32] ;
  void *tmp ;

  {
#line 121
  if ((unsigned int )rc4 == (unsigned int )((void *)0)) {
#line 122
    tmp = xmalloc(sizeof(*rc4));
#line 122
    rc4 = (rc4_t *)tmp;
  }
#line 124
  seed_rng();
#line 125
  RAND_bytes(rand_buf, (int )sizeof(rand_buf));
#line 127
  rc4_key(rc4, rand_buf, (int )sizeof(rand_buf));
#line 128
  memset((void *)(rand_buf), 0, sizeof(rand_buf));
#line 129
  return;
}
}
#line 133 "bsd-misc.c"
void setproctitle(char const   *fmt  , ...) 
{ 

  {
#line 136
  return;
}
}
#line 140
 __attribute__((__nothrow__)) int setlogin(char const   *name )  __attribute__((__nonnull__(1))) ;
#line 140 "bsd-misc.c"
int setlogin(char const   *name ) 
{ 

  {
#line 142
  return (0);
}
}
#line 1 "bsd-mktemp.o"
#pragma merger(0,"./bsd-mktemp.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "bsd-rresvport.o"
#pragma merger(0,"./bsd-rresvport.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "bsd-setenv.o"
#pragma merger(0,"./bsd-setenv.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "bsd-snprintf.o"
#pragma merger(0,"./bsd-snprintf.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "bsd-strlcat.o"
#pragma merger(0,"./bsd-strlcat.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 46 "bsd-strlcat.c"
size_t strlcat(char *dst , char const   *src , size_t siz ) 
{ register char *d ;
  register char const   *s ;
  register size_t n___0 ;
  size_t dlen ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 51
  d = dst;
#line 52
  s = src;
#line 53
  n___0 = siz;
#line 57
  while (1) {
#line 57
    if ((int )*d != 0) {
#line 57
      tmp = n___0;
#line 57
      n___0 --;
#line 57
      if (! (tmp != 0U)) {
#line 57
        break;
      }
    } else {
#line 57
      break;
    }
#line 58
    d ++;
  }
#line 59
  dlen = (unsigned int )(d - dst);
#line 60
  n___0 = siz - dlen;
#line 62
  if (n___0 == 0U) {
#line 63
    tmp___0 = strlen(s);
#line 63
    return (dlen + tmp___0);
  }
#line 64
  while ((int const   )*s != 0) {
#line 65
    if (n___0 != 1U) {
#line 66
      tmp___1 = d;
#line 66
      d ++;
#line 66
      *tmp___1 = (char )*s;
#line 67
      n___0 --;
    }
#line 69
    s ++;
  }
#line 71
  *d = (char )'\000';
#line 73
  return (dlen + (size_t )(s - src));
}
}
#line 1 "bsd-strlcpy.o"
#pragma merger(0,"./bsd-strlcpy.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 45 "bsd-strlcpy.c"
size_t strlcpy(char *dst , char const   *src , size_t siz ) 
{ register char *d ;
  register char const   *s ;
  register size_t n___0 ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 50
  d = dst;
#line 51
  s = src;
#line 52
  n___0 = siz;
#line 55
  if (n___0 != 0U) {
#line 55
    n___0 --;
#line 55
    if (n___0 != 0U) {
#line 56
      while (1) {
#line 57
        tmp = d;
#line 57
        d ++;
#line 57
        tmp___0 = s;
#line 57
        s ++;
#line 57
        *tmp = (char )*tmp___0;
#line 57
        if ((int )*tmp == 0) {
#line 58
          break;
        }
#line 56
        n___0 --;
#line 56
        if (! (n___0 != 0U)) {
#line 56
          break;
        }
      }
    }
  }
#line 63
  if (n___0 == 0U) {
#line 64
    if (siz != 0U) {
#line 65
      *d = (char )'\000';
    }
#line 66
    while (1) {
#line 66
      tmp___1 = s;
#line 66
      s ++;
#line 66
      if (! *tmp___1) {
#line 66
        break;
      }
    }
  }
#line 70
  return ((unsigned int )((s - src) - 1));
}
}
#line 1 "fake-getaddrinfo.o"
#pragma merger(0,"./fake-getaddrinfo.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "fake-getnameinfo.o"
#pragma merger(0,"./fake-getnameinfo.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "sshd.o"
#pragma merger(0,"./sshd.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 92 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 393 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 457
extern  __attribute__((__nothrow__)) int chdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 490
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 516
extern  __attribute__((__nothrow__)) int execv(char const   *__path , char * const  *__argv )  __attribute__((__nonnull__(1))) ;
#line 723
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 792
extern  __attribute__((__nothrow__)) int unlink(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 73
extern int optind ;
#line 152
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 903 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
#line 478 "/usr/include/openssl/bn.h"
extern int BN_mask_bits(BIGNUM *a , int n ) ;
#line 452 "ssh.h"
void log_init(char *av0___0 , LogLevel level , SyslogFacility facility , int on_stderr ) ;
#line 7 "auth-pam.h"
void finish_pam(void) ;
#line 101 "servconf.h"
void initialize_server_options(ServerOptions *options___0 ) ;
#line 107
void read_server_config(ServerOptions *options___0 , char const   *filename ) ;
#line 110
void fill_default_server_options(ServerOptions *options___0 ) ;
#line 174 "/usr/include/openssl/dh.h"
extern void DH_free(DH *dh ) ;
#line 176
extern int DH_size(DH const   *dh ) ;
#line 194
extern int DH_compute_key(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
#line 4 "auth.h"
void do_authentication(void) ;
#line 5
void do_authentication2(void) ;
#line 9 "myproposal.h"
static char *myproposal[10]  = 
#line 9 "myproposal.h"
  {      (char *)"diffie-hellman-group1-sha1",      (char *)"ssh-dss",      (char *)"3des-cbc,blowfish-cbc,arcfour,cast128-cbc",      (char *)"3des-cbc,blowfish-cbc,arcfour,cast128-cbc", 
        (char *)"hmac-sha1,hmac-md5,hmac-ripemd160@openssh.com",      (char *)"hmac-sha1,hmac-md5,hmac-ripemd160@openssh.com",      (char *)"zlib,none",      (char *)"zlib,none", 
        (char *)"",      (char *)""};
#line 57 "sshd.c"
ServerOptions options  ;
#line 60 "sshd.c"
char *config_file_name  =    (char *)"/usr/local/etc/sshd_config";
#line 69 "sshd.c"
int IPv4or6  =    0;
#line 78 "sshd.c"
int debug_flag  =    0;
#line 81 "sshd.c"
int inetd_flag  =    0;
#line 84 "sshd.c"
int log_stderr  =    0;
#line 87 "sshd.c"
char *av0  ;
#line 90 "sshd.c"
char **saved_argv  ;
#line 97 "sshd.c"
int listen_socks[16]  ;
#line 98 "sshd.c"
int num_listen_socks  =    0;
#line 104 "sshd.c"
char *client_version_string  =    (char *)((void *)0);
#line 105 "sshd.c"
char *server_version_string  =    (char *)((void *)0);
#line 115 "sshd.c"
struct __anonstruct_sensitive_data_76 sensitive_data  ;
#line 125 "sshd.c"
int key_used  =    0;
#line 128 "sshd.c"
int received_sighup  =    0;
#line 132 "sshd.c"
RSA *public_key  ;
#line 135 "sshd.c"
unsigned char session_id[16]  ;
#line 138 "sshd.c"
unsigned char *session_id2  =    (unsigned char *)((void *)0);
#line 139 "sshd.c"
int session_id2_len  =    0;
#line 142
void do_ssh1_kex(void) ;
#line 143
void do_ssh2_kex(void) ;
#line 148 "sshd.c"
void close_listen_socks(void) 
{ int i ;

  {
#line 152
  i = 0;
#line 152
  while (i < num_listen_socks) {
#line 153
    close(listen_socks[i]);
#line 152
    i ++;
  }
#line 154
  num_listen_socks = -1;
#line 155
  return;
}
}
#line 162 "sshd.c"
void sighup_handler(int sig ) 
{ 

  {
#line 165
  received_sighup = 1;
#line 166
  signal(1, & sighup_handler);
#line 167
  return;
}
}
#line 173 "sshd.c"
void sighup_restart(void) 
{ int *tmp ;
  char *tmp___0 ;

  {
#line 176
  log("Received SIGHUP; restarting.");
#line 177
  close_listen_socks();
#line 178
  execv((char const   *)*(saved_argv + 0), (char * const  *)saved_argv);
#line 179
  tmp = __errno_location();
#line 179
  tmp___0 = strerror(*tmp);
#line 179
  log("RESTART FAILED: av0=\'%s\', error: %s.", av0, tmp___0);
#line 180
  exit(1);
}
}
#line 188 "sshd.c"
void sigterm_handler(int sig ) 
{ 

  {
#line 191
  log("Received signal %d; terminating.", sig);
#line 192
  close_listen_socks();
#line 193
  unlink((char const   *)options.pid_file);
#line 194
  exit(255);
}
}
#line 201 "sshd.c"
void main_sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  int status ;
  __pid_t tmp___0 ;
  int *tmp___1 ;

  {
#line 204
  tmp = __errno_location();
#line 204
  save_errno = *tmp;
#line 207
  while (1) {
#line 207
    tmp___0 = waitpid(-1, & status, 1);
#line 207
    if (! (tmp___0 > 0)) {
#line 207
      break;
    }
  }
#line 210
  signal(17, & main_sigchld_handler);
#line 211
  tmp___1 = __errno_location();
#line 211
  *tmp___1 = save_errno;
#line 212
  return;
}
}
#line 217 "sshd.c"
void grace_alarm_handler(int sig ) 
{ char const   *tmp ;

  {
#line 221
  packet_close();
#line 224
  tmp = get_remote_ipaddr();
#line 224
  fatal("Timeout before authentication for %s.", tmp);
#line 225
  return;
}
}
#line 235 "sshd.c"
void key_regeneration_alarm(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 238
  tmp = __errno_location();
#line 238
  save_errno = *tmp;
#line 241
  if (key_used) {
#line 243
    log("Generating new %d bit RSA key.", options.server_key_bits);
#line 245
    if ((unsigned int )sensitive_data.private_key != (unsigned int )((void *)0)) {
#line 246
      RSA_free(sensitive_data.private_key);
    }
#line 247
    sensitive_data.private_key = RSA_new();
#line 249
    if ((unsigned int )public_key != (unsigned int )((void *)0)) {
#line 250
      RSA_free(public_key);
    }
#line 251
    public_key = RSA_new();
#line 253
    rsa_generate_key(sensitive_data.private_key, public_key, (unsigned int )options.server_key_bits);
#line 255
    arc4random_stir();
#line 256
    key_used = 0;
#line 257
    log("RSA key generation complete.");
  }
#line 260
  signal(14, & key_regeneration_alarm);
#line 261
  alarm((unsigned int )options.key_regeneration_time);
#line 262
  tmp___0 = __errno_location();
#line 262
  *tmp___0 = save_errno;
#line 263
  return;
}
}
#line 265 "sshd.c"
void sshd_exchange_identification(int sock_in , int sock_out ) 
{ int i ;
  int mismatch ;
  int remote_major ;
  int remote_minor ;
  int major ;
  int minor ;
  char *s ;
  char buf___1[256] ;
  char remote_version[256] ;
  char const   *tmp ;
  size_t tmp___0 ;
  ssize_t tmp___1 ;
  size_t tmp___2 ;
  char const   *tmp___3 ;
  ssize_t tmp___4 ;
  size_t tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  char const   *tmp___9 ;

  {
#line 275
  if (options.protocol & 1) {
#line 275
    if (options.protocol & 4) {
#line 277
      major = 1;
#line 278
      minor = 99;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 279
    if (options.protocol & 4) {
#line 280
      major = 2;
#line 281
      minor = 0;
    } else {
#line 283
      major = 1;
#line 284
      minor = 5;
    }
  }
#line 286
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"SSH-%d.%d-%.100s\n",
           major, minor, "OpenSSH-2.1");
#line 287
  server_version_string = xstrdup((char const   *)(buf___1));
#line 289
  if ((unsigned int )client_version_string == (unsigned int )((void *)0)) {
#line 291
    tmp___0 = strlen((char const   *)server_version_string);
#line 291
    tmp___1 = atomicio((ssize_t (*)())(& write), sock_out, (void *)server_version_string,
                       tmp___0);
#line 291
    tmp___2 = strlen((char const   *)server_version_string);
#line 291
    if ((size_t )tmp___1 != tmp___2) {
#line 293
      tmp = get_remote_ipaddr();
#line 293
      log("Could not write ident string to %s.", tmp);
#line 294
      fatal_cleanup();
    }
#line 298
    i = 0;
#line 298
    while ((unsigned int )i < sizeof(buf___1) - 1U) {
#line 299
      tmp___4 = read(sock_in, (void *)(& buf___1[i]), 1U);
#line 299
      if (tmp___4 != 1) {
#line 300
        tmp___3 = get_remote_ipaddr();
#line 300
        log("Did not receive ident string from %s.", tmp___3);
#line 301
        fatal_cleanup();
      }
#line 303
      if ((int )buf___1[i] == 13) {
#line 304
        buf___1[i] = (char )'\n';
#line 305
        buf___1[i + 1] = (char)0;
        goto __Cont;
      }
#line 308
      if ((int )buf___1[i] == 10) {
#line 310
        buf___1[i + 1] = (char)0;
#line 311
        break;
      }
      __Cont: /* CIL Label */ 
#line 298
      i ++;
    }
#line 314
    buf___1[sizeof(buf___1) - 1U] = (char)0;
#line 315
    client_version_string = xstrdup((char const   *)(buf___1));
  }
#line 322
  tmp___7 = sscanf((char const   * __restrict  )client_version_string, (char const   * __restrict  )"SSH-%d.%d-%[^\n]\n",
                   & remote_major, & remote_minor, remote_version);
#line 322
  if (tmp___7 != 3) {
#line 324
    s = (char *)"Protocol mismatch.\n";
#line 325
    tmp___5 = strlen((char const   *)s);
#line 325
    atomicio((ssize_t (*)())(& write), sock_out, (void *)s, tmp___5);
#line 326
    close(sock_in);
#line 327
    close(sock_out);
#line 328
    tmp___6 = get_remote_ipaddr();
#line 328
    log("Bad protocol version identification \'%.100s\' from %s", client_version_string,
        tmp___6);
#line 330
    fatal_cleanup();
  }
#line 332
  debug("Client protocol version %d.%d; client software version %.100s", remote_major,
        remote_minor, remote_version);
#line 335
  compat_datafellows((char const   *)(remote_version));
#line 337
  mismatch = 0;
#line 338
  switch (remote_major) {
  case 1: 
#line 340
  if (remote_minor == 99) {
#line 341
    if (options.protocol & 4) {
#line 342
      enable_compat20();
    } else {
#line 344
      mismatch = 1;
    }
#line 345
    break;
  }
#line 347
  if (! (options.protocol & 1)) {
#line 348
    mismatch = 1;
#line 349
    break;
  }
#line 351
  if (remote_minor < 3) {
#line 352
    packet_disconnect("Your ssh version is too old andis no longer supported.  Please install a newer version.");
  } else {
#line 354
    if (remote_minor == 3) {
#line 356
      enable_compat13();
    }
  }
#line 358
  break;
  case 2: 
#line 360
  if (options.protocol & 4) {
#line 361
    enable_compat20();
#line 362
    break;
  }
  default: 
#line 366
  mismatch = 1;
#line 367
  break;
  }
#line 369
  chop(server_version_string);
#line 370
  chop(client_version_string);
#line 371
  debug("Local version string %.200s", server_version_string);
#line 373
  if (mismatch) {
#line 374
    s = (char *)"Protocol major versions differ.\n";
#line 375
    tmp___8 = strlen((char const   *)s);
#line 375
    atomicio((ssize_t (*)())(& write), sock_out, (void *)s, tmp___8);
#line 376
    close(sock_in);
#line 377
    close(sock_out);
#line 378
    tmp___9 = get_remote_ipaddr();
#line 378
    log("Protocol major versions differ for %s: %.200s vs. %.200s", tmp___9, server_version_string,
        client_version_string);
#line 381
    fatal_cleanup();
  }
#line 383
  if (compat20) {
#line 384
    packet_set_ssh2_format();
  }
#line 385
  return;
}
}
#line 388 "sshd.c"
void destroy_sensitive_data(void) 
{ 

  {
#line 392
  if (public_key) {
#line 393
    RSA_free(public_key);
  }
#line 394
  if (sensitive_data.private_key) {
#line 395
    RSA_free(sensitive_data.private_key);
  }
#line 396
  if (sensitive_data.host_key) {
#line 397
    RSA_free(sensitive_data.host_key);
  }
#line 398
  if ((unsigned int )sensitive_data.dsa_host_key != (unsigned int )((void *)0)) {
#line 399
    key_free(sensitive_data.dsa_host_key);
  }
#line 400
  return;
}
}
#line 405 "sshd.c"
int main(int ac , char **av ) 
{ int opt ;
  int sock_in ;
  int sock_out ;
  int newsock ;
  int i ;
  int fdsetsz ;
  int on ;
  pid_t pid ;
  socklen_t fromlen ;
  int silent ;
  fd_set *fdset ;
  struct sockaddr_storage from ;
  char const   *remote_ip ;
  int remote_port ;
  FILE *f ;
  struct linger linger ;
  struct addrinfo *ai ;
  char ntop[1025] ;
  char strport[32] ;
  int listen_sock ;
  int maxfd ;
  char *tmp ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  Key k ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int fd ;
  int *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int s1 ;
  int s2 ;
  int tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int *tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  __pid_t tmp___31 ;
  void *tmp___32 ;
  int *tmp___33 ;
  char *tmp___34 ;
  int *tmp___35 ;
  int tmp___36 ;
  register char __result ;
  int *tmp___37 ;
  char *tmp___38 ;
  int *tmp___39 ;
  int *tmp___40 ;
  int *tmp___41 ;
  char *tmp___42 ;
  int tmp___43 ;
  int *tmp___44 ;
  char *tmp___45 ;

  {
#line 410
  sock_in = 0;
#line 410
  sock_out = 0;
#line 410
  on = 1;
#line 413
  silent = 0;
#line 425
  saved_argv = av;
#line 426
  tmp___1 = __builtin_strchr(*(av + 0), '/');
#line 426
  if (tmp___1) {
#line 427
    tmp = strrchr((char const   *)*(av + 0), '/');
#line 427
    av0 = tmp + 1;
  } else {
#line 429
    av0 = *(av + 0);
  }
#line 432
  initialize_server_options(& options);
#line 435
  while (1) {
#line 435
    opt = getopt(ac, (char * const  *)av, "f:p:b:k:h:g:V:diqQ46");
#line 435
    if (! (opt != -1)) {
#line 435
      break;
    }
#line 436
    switch (opt) {
    case 52: 
#line 438
    IPv4or6 = 2;
#line 439
    break;
    case 54: 
#line 441
    IPv4or6 = 10;
#line 442
    break;
    case 102: 
#line 444
    config_file_name = optarg;
#line 445
    break;
    case 100: 
#line 447
    debug_flag = 1;
#line 448
    options.log_level = 5;
#line 449
    break;
    case 105: 
#line 451
    inetd_flag = 1;
#line 452
    break;
    case 81: 
#line 454
    silent = 1;
#line 455
    break;
    case 113: 
#line 457
    options.log_level = 0;
#line 458
    break;
    case 98: 
#line 460
    options.server_key_bits = atoi((char const   *)optarg);
#line 461
    break;
    case 112: 
#line 463
    options.ports_from_cmdline = 1U;
#line 464
    if (options.num_ports >= 256U) {
#line 465
      fatal("too many ports.\n");
    }
#line 466
    tmp___2 = options.num_ports;
#line 466
    (options.num_ports) ++;
#line 466
    tmp___3 = atoi((char const   *)optarg);
#line 466
    options.ports[tmp___2] = (unsigned short )tmp___3;
#line 467
    break;
    case 103: 
#line 469
    options.login_grace_time = atoi((char const   *)optarg);
#line 470
    break;
    case 107: 
#line 472
    options.key_regeneration_time = atoi((char const   *)optarg);
#line 473
    break;
    case 104: 
#line 475
    options.host_key_file = optarg;
#line 476
    break;
    case 86: 
#line 478
    client_version_string = optarg;
#line 480
    inetd_flag = 1;
#line 481
    break;
    case 63: 
    default: 
#line 484
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"sshd version %s\n",
            "OpenSSH-2.1");
#line 485
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: %s [options]\n",
            av0);
#line 486
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Options:\n");
#line 487
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -f file    Configuration file (default %s)\n",
            "/usr/local/etc/sshd_config");
#line 488
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -d         Debugging mode\n");
#line 489
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -i         Started from inetd\n");
#line 490
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -q         Quiet (no logging)\n");
#line 491
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -p port    Listen on the specified port (default: 22)\n");
#line 492
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -k seconds Regenerate server key every this many seconds (default: 3600)\n");
#line 493
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -g seconds Grace period for authentication (default: 300)\n");
#line 494
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -b bits    Size of server RSA key (default: 768 bits)\n");
#line 495
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -h file    File from which to read host key (default: %s)\n",
            "/usr/local/etc/ssh_host_key");
#line 497
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -4         Use IPv4 only\n");
#line 498
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -6         Use IPv6 only\n");
#line 499
    exit(1);
    }
  }
#line 507
  if (! silent) {
#line 507
    if (! inetd_flag) {
#line 507
      tmp___4 = 1;
    } else {
#line 507
      tmp___4 = 0;
    }
  } else {
#line 507
    tmp___4 = 0;
  }
#line 507
  if ((int )options.log_facility == -1) {
#line 507
    tmp___5 = 2;
  } else {
#line 507
    tmp___5 = (int )options.log_facility;
  }
#line 507
  if ((int )options.log_level == -1) {
#line 507
    tmp___6 = 3;
  } else {
#line 507
    tmp___6 = (int )options.log_level;
  }
#line 507
  log_init(av0, (enum __anonenum_LogLevel_73 )tmp___6, (enum __anonenum_SyslogFacility_72 )tmp___5,
           tmp___4);
#line 513
  read_server_config(& options, (char const   *)config_file_name);
#line 516
  fill_default_server_options(& options);
#line 519
  if (optind < ac) {
#line 520
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Extra argument %s.\n",
            *(av + optind));
#line 521
    exit(1);
  }
#line 524
  debug("sshd version %.100s", "OpenSSH-2.1");
#line 526
  sensitive_data.dsa_host_key = (Key *)((void *)0);
#line 527
  sensitive_data.host_key = (RSA *)((void *)0);
#line 530
  if (options.protocol & 1) {
#line 530
    tmp___7 = rsa_alive();
#line 530
    if (tmp___7 == 0) {
#line 532
      log("no RSA support in libssl and libcrypto.  See ssl(8)");
#line 533
      log("Disabling protocol version 1");
#line 534
      options.protocol &= -2;
    }
  }
#line 537
  if (options.protocol & 1) {
#line 539
    sensitive_data.host_key = RSA_new();
#line 540
    k.type = 0;
#line 541
    k.rsa = sensitive_data.host_key;
#line 542
    tmp___8 = __errno_location();
#line 542
    *tmp___8 = 0;
#line 543
    tmp___11 = load_private_key((char const   *)options.host_key_file, "", & k, (char **)((void *)0));
#line 543
    if (! tmp___11) {
#line 544
      tmp___9 = __errno_location();
#line 544
      tmp___10 = strerror(*tmp___9);
#line 544
      error("Could not load host key: %.200s: %.100s", options.host_key_file, tmp___10);
#line 546
      log("Disabling protocol version 1");
#line 547
      options.protocol &= -2;
    }
#line 549
    k.rsa = (RSA *)((void *)0);
  }
#line 551
  if (options.protocol & 4) {
#line 552
    sensitive_data.dsa_host_key = key_new(1);
#line 553
    tmp___12 = load_private_key((char const   *)options.host_dsa_key_file, "", sensitive_data.dsa_host_key,
                                (char **)((void *)0));
#line 553
    if (! tmp___12) {
#line 555
      error("Could not load DSA host key: %.200s", options.host_dsa_key_file);
#line 556
      log("Disabling protocol version 2");
#line 557
      options.protocol &= -5;
    }
  }
#line 560
  if (! options.protocol & 5) {
#line 561
    if (silent == 0) {
#line 562
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"sshd: no hostkeys available -- exiting.\n");
    }
#line 563
    log("sshd: no hostkeys available -- exiting.\n");
#line 564
    exit(1);
  }
#line 568
  if (options.protocol & 1) {
#line 569
    if (options.server_key_bits < 512) {
#line 571
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 572
      exit(1);
    } else {
#line 569
      if (options.server_key_bits > 32768) {
#line 571
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 572
        exit(1);
      }
    }
#line 579
    tmp___14 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 579
    if (options.server_key_bits > tmp___14 - 128) {
#line 579
      tmp___15 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 579
      if (options.server_key_bits < tmp___15 + 128) {
#line 583
        tmp___13 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 583
        options.server_key_bits = tmp___13 + 128;
#line 585
        debug("Forcing server key to %d bits to make it differ from host key.", options.server_key_bits);
      }
    }
  }
#line 591
  if (debug_flag) {
#line 591
    if (! inetd_flag) {
#line 592
      log_stderr = 1;
    }
  }
#line 593
  log_init(av0, options.log_level, options.log_facility, log_stderr);
#line 600
  if (! debug_flag) {
#line 600
    if (! inetd_flag) {
#line 604
      tmp___18 = daemon(0, 0);
#line 604
      if (tmp___18 < 0) {
#line 605
        tmp___16 = __errno_location();
#line 605
        tmp___17 = strerror(*tmp___16);
#line 605
        fatal("daemon() failed: %.200s", tmp___17);
      }
#line 609
      fd = open("/dev/tty", 258);
#line 610
      if (fd >= 0) {
#line 611
        ioctl(fd, 21538UL, (void *)0);
#line 612
        close(fd);
      }
    }
  }
#line 617
  log_init(av0, options.log_level, options.log_facility, log_stderr);
#line 620
  rsa_set_verbose(0);
#line 623
  arc4random_stir();
#line 627
  chdir("/");
#line 630
  if (inetd_flag) {
#line 632
    s1 = dup(0);
#line 633
    s2 = dup(s1);
#line 634
    sock_in = dup(0);
#line 635
    sock_out = dup(1);
#line 641
    debug("inetd sockets after dupping: %d, %d", sock_in, sock_out);
#line 643
    if (options.protocol & 1) {
#line 644
      public_key = RSA_new();
#line 645
      sensitive_data.private_key = RSA_new();
#line 646
      log("Generating %d bit RSA key.", options.server_key_bits);
#line 647
      rsa_generate_key(sensitive_data.private_key, public_key, (unsigned int )options.server_key_bits);
#line 649
      arc4random_stir();
#line 650
      log("RSA key generation complete.");
    }
  } else {
#line 653
    ai = options.listen_addrs;
#line 653
    while (ai) {
#line 654
      if (ai->ai_family != 2) {
#line 654
        if (ai->ai_family != 10) {
          goto __Cont;
        }
      }
#line 656
      if (num_listen_socks >= 16) {
#line 657
        fatal("Too many listen sockets. Enlarge MAX_LISTEN_SOCKS");
      }
#line 659
      tmp___19 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr,
                             ai->ai_addrlen, (char * __restrict  )(ntop), sizeof(ntop),
                             (char * __restrict  )(strport), sizeof(strport), 3U);
#line 659
      if (tmp___19 != 0) {
#line 662
        error("getnameinfo failed");
        goto __Cont;
      }
#line 666
      listen_sock = socket(ai->ai_family, 1, 0);
#line 667
      if (listen_sock < 0) {
#line 669
        tmp___20 = __errno_location();
#line 669
        tmp___21 = strerror(*tmp___20);
#line 669
        verbose("socket: %.100s", tmp___21);
        goto __Cont;
      }
#line 672
      tmp___24 = fcntl(listen_sock, 4, 2048);
#line 672
      if (tmp___24 < 0) {
#line 673
        tmp___22 = __errno_location();
#line 673
        tmp___23 = strerror(*tmp___22);
#line 673
        error("listen_sock O_NONBLOCK: %s", tmp___23);
#line 674
        close(listen_sock);
        goto __Cont;
      }
#line 683
      setsockopt(listen_sock, 1, 2, (void const   *)((void *)(& on)), sizeof(on));
#line 685
      linger.l_onoff = 1;
#line 686
      linger.l_linger = 5;
#line 687
      setsockopt(listen_sock, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 690
      debug("Bind to port %s on %s.", strport, ntop);
#line 693
      tmp___27 = bind(listen_sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 693
      if (tmp___27 < 0) {
#line 693
        if (! ai->ai_next) {
#line 695
          tmp___25 = __errno_location();
#line 695
          tmp___26 = strerror(*tmp___25);
#line 695
          error("Bind to port %s on %s failed: %.200s.", strport, ntop, tmp___26);
#line 697
          close(listen_sock);
          goto __Cont;
        }
      }
#line 700
      listen_socks[num_listen_socks] = listen_sock;
#line 701
      num_listen_socks ++;
#line 704
      log("Server listening on %s port %s.", ntop, strport);
#line 705
      tmp___30 = listen(listen_sock, 5);
#line 705
      if (tmp___30 < 0) {
#line 706
        tmp___28 = __errno_location();
#line 706
        tmp___29 = strerror(*tmp___28);
#line 706
        fatal("listen: %.100s", tmp___29);
      }
      __Cont: /* CIL Label */ 
#line 653
      ai = ai->ai_next;
    }
#line 709
    freeaddrinfo(options.listen_addrs);
#line 711
    if (! num_listen_socks) {
#line 712
      fatal("Cannot bind any address.");
    }
#line 714
    if (! debug_flag) {
#line 722
      f = fopen((char const   * __restrict  )options.pid_file, (char const   * __restrict  )"w");
#line 723
      if (f) {
#line 724
        tmp___31 = getpid();
#line 724
        fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%u\n", (unsigned int )tmp___31);
#line 725
        fclose(f);
      }
    }
#line 728
    if (options.protocol & 1) {
#line 729
      public_key = RSA_new();
#line 730
      sensitive_data.private_key = RSA_new();
#line 732
      log("Generating %d bit RSA key.", options.server_key_bits);
#line 733
      rsa_generate_key(sensitive_data.private_key, public_key, (unsigned int )options.server_key_bits);
#line 735
      arc4random_stir();
#line 736
      log("RSA key generation complete.");
#line 739
      signal(14, & key_regeneration_alarm);
#line 740
      alarm((unsigned int )options.key_regeneration_time);
    }
#line 744
    signal(1, & sighup_handler);
#line 745
    signal(15, & sigterm_handler);
#line 746
    signal(3, & sigterm_handler);
#line 749
    signal(17, & main_sigchld_handler);
#line 752
    maxfd = 0;
#line 753
    i = 0;
#line 753
    while (i < num_listen_socks) {
#line 754
      if (listen_socks[i] > maxfd) {
#line 755
        maxfd = listen_socks[i];
      }
#line 753
      i ++;
    }
#line 756
    fdsetsz = (int )((((unsigned int )maxfd + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 757
    tmp___32 = xmalloc((unsigned int )fdsetsz);
#line 757
    fdset = (fd_set *)tmp___32;
#line 763
    while (1) {
#line 764
      if (received_sighup) {
#line 765
        sighup_restart();
      }
#line 767
      memset((void *)fdset, 0, (unsigned int )fdsetsz);
#line 768
      i = 0;
#line 768
      while (i < num_listen_socks) {
#line 769
        __asm__  volatile   ("btsl %1,%0": "=m" (fdset->__fds_bits[(unsigned int )listen_socks[i] / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )listen_socks[i] % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
#line 768
        i ++;
      }
#line 770
      tmp___36 = select(maxfd + 1, (fd_set * __restrict  )fdset, (fd_set * __restrict  )((void *)0),
                        (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 770
      if (tmp___36 < 0) {
#line 771
        tmp___35 = __errno_location();
#line 771
        if (*tmp___35 != 4) {
#line 772
          tmp___33 = __errno_location();
#line 772
          tmp___34 = strerror(*tmp___33);
#line 772
          error("select: %.100s", tmp___34);
        }
        goto __Cont___0;
      }
#line 775
      i = 0;
#line 775
      while (i < num_listen_socks) {
#line 776
        __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )listen_socks[i] % (8U * sizeof(__fd_mask ))),
                             "m" (fdset->__fds_bits[(unsigned int )listen_socks[i] / (8U * sizeof(__fd_mask ))]): "cc");
#line 776
        if (! __result) {
          goto __Cont___1;
        }
#line 778
        fromlen = sizeof(from);
#line 779
        newsock = accept(listen_socks[i], (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                         (socklen_t * __restrict  )(& fromlen));
#line 781
        if (newsock < 0) {
#line 782
          tmp___39 = __errno_location();
#line 782
          if (*tmp___39 != 4) {
#line 782
            tmp___40 = __errno_location();
#line 782
            if (*tmp___40 != 11) {
#line 783
              tmp___37 = __errno_location();
#line 783
              tmp___38 = strerror(*tmp___37);
#line 783
              error("accept: %.100s", tmp___38);
            }
          }
          goto __Cont___1;
        }
#line 786
        tmp___43 = fcntl(newsock, 4, 0);
#line 786
        if (tmp___43 < 0) {
#line 787
          tmp___41 = __errno_location();
#line 787
          tmp___42 = strerror(*tmp___41);
#line 787
          error("newsock del O_NONBLOCK: %s", tmp___42);
          goto __Cont___1;
        }
#line 794
        if (debug_flag) {
#line 800
          debug("Server will not fork when running in debugging mode.");
#line 801
          close_listen_socks();
#line 802
          sock_in = newsock;
#line 803
          sock_out = newsock;
#line 804
          pid = getpid();
#line 805
          break;
        } else {
#line 812
          pid = fork();
#line 812
          if (pid == 0) {
#line 818
            close_listen_socks();
#line 819
            sock_in = newsock;
#line 820
            sock_out = newsock;
#line 821
            log_init(av0, options.log_level, options.log_facility, log_stderr);
#line 822
            break;
          }
        }
#line 827
        if (pid < 0) {
#line 828
          tmp___44 = __errno_location();
#line 828
          tmp___45 = strerror(*tmp___44);
#line 828
          error("fork: %.100s", tmp___45);
        } else {
#line 830
          debug("Forked child %d.", pid);
        }
#line 833
        key_used = 1;
#line 835
        arc4random_stir();
#line 838
        close(newsock);
        __Cont___1: /* CIL Label */ 
#line 775
        i ++;
      }
#line 841
      if (num_listen_socks < 0) {
#line 842
        break;
      }
      __Cont___0: /* CIL Label */ ;
    }
  }
#line 853
  alarm(0U);
#line 854
  signal(14, (void (*)(int  ))0);
#line 855
  signal(1, (void (*)(int  ))0);
#line 856
  signal(15, (void (*)(int  ))0);
#line 857
  signal(3, (void (*)(int  ))0);
#line 858
  signal(17, (void (*)(int  ))0);
#line 866
  linger.l_onoff = 1;
#line 867
  linger.l_linger = 5;
#line 868
  setsockopt(sock_in, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 874
  packet_set_connection(sock_in, sock_out);
#line 876
  remote_port = get_remote_port();
#line 877
  remote_ip = get_remote_ipaddr();
#line 897
  verbose("Connection from %.500s port %d", remote_ip, remote_port);
#line 907
  signal(14, & grace_alarm_handler);
#line 908
  if (! debug_flag) {
#line 909
    alarm((unsigned int )options.login_grace_time);
  }
#line 911
  sshd_exchange_identification(sock_in, sock_out);
#line 919
  if (remote_port >= 1024) {
#line 921
    options.rhosts_authentication = 0;
#line 922
    options.rhosts_rsa_authentication = 0;
  } else {
#line 919
    if (remote_port < 512) {
#line 921
      options.rhosts_authentication = 0;
#line 922
      options.rhosts_rsa_authentication = 0;
    }
  }
#line 932
  packet_set_nonblocking();
#line 936
  if (compat20) {
#line 937
    do_ssh2_kex();
#line 938
    do_authentication2();
  } else {
#line 940
    do_ssh1_kex();
#line 941
    do_authentication();
  }
#line 951
  verbose("Closing connection to %.100s", remote_ip);
#line 954
  finish_pam();
#line 957
  packet_close();
#line 958
  exit(0);
}
}
#line 964 "sshd.c"
void do_ssh1_kex(void) 
{ int i ;
  int len ;
  int plen ;
  int slen ;
  BIGNUM *session_key_int ;
  unsigned char session_key[32] ;
  unsigned char cookie[8] ;
  unsigned int cipher_type___0 ;
  unsigned int auth_mask ;
  unsigned int protocol_flags ;
  u_int32_t rand___0 ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  char const   *tmp___6 ;
  int _p ;
  int _e ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char const   *tmp___19 ;

  {
#line 973
  rand___0 = (u_int32_t )0;
#line 984
  i = 0;
#line 984
  while (i < 8) {
#line 985
    if (i % 4 == 0) {
#line 986
      rand___0 = arc4random();
    }
#line 987
    cookie[i] = (unsigned char )(rand___0 & 255U);
#line 988
    rand___0 >>= 8;
#line 984
    i ++;
  }
#line 996
  packet_start(2);
#line 997
  i = 0;
#line 997
  while (i < 8) {
#line 998
    packet_put_char((int )cookie[i]);
#line 997
    i ++;
  }
#line 1001
  tmp = BN_num_bits((BIGNUM const   *)public_key->n);
#line 1001
  packet_put_int((unsigned int )tmp);
#line 1002
  packet_put_bignum(public_key->e);
#line 1003
  packet_put_bignum(public_key->n);
#line 1006
  tmp___0 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1006
  packet_put_int((unsigned int )tmp___0);
#line 1007
  packet_put_bignum((sensitive_data.host_key)->e);
#line 1008
  packet_put_bignum((sensitive_data.host_key)->n);
#line 1011
  packet_put_int(2U);
#line 1014
  tmp___1 = cipher_mask1();
#line 1014
  packet_put_int(tmp___1);
#line 1017
  auth_mask = 0U;
#line 1018
  if (options.rhosts_authentication) {
#line 1019
    auth_mask |= (unsigned int )(1 << 1);
  }
#line 1020
  if (options.rhosts_rsa_authentication) {
#line 1021
    auth_mask |= (unsigned int )(1 << 4);
  }
#line 1022
  if (options.rsa_authentication) {
#line 1023
    auth_mask |= (unsigned int )(1 << 2);
  }
#line 1038
  if (options.password_authentication) {
#line 1039
    auth_mask |= (unsigned int )(1 << 3);
  }
#line 1040
  packet_put_int(auth_mask);
#line 1043
  packet_send();
#line 1044
  packet_write_wait();
#line 1046
  tmp___2 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1046
  tmp___3 = BN_num_bits((BIGNUM const   *)public_key->n);
#line 1046
  debug("Sent %d bit public key and %d bit host key.", tmp___3, tmp___2);
#line 1050
  packet_read_expect(& plen, 3);
#line 1053
  cipher_type___0 = packet_get_char();
#line 1055
  tmp___4 = cipher_mask();
#line 1055
  if (! (tmp___4 & (unsigned int )(1 << cipher_type___0))) {
#line 1056
    packet_disconnect("Warning: client selects unsupported cipher.");
  }
#line 1060
  i = 0;
#line 1060
  while (i < 8) {
#line 1061
    tmp___5 = packet_get_char();
#line 1061
    if ((unsigned int )cookie[i] != tmp___5) {
#line 1062
      packet_disconnect("IP Spoofing check bytes do not match.");
    }
#line 1060
    i ++;
  }
#line 1064
  tmp___6 = cipher_name((int )cipher_type___0);
#line 1064
  debug("Encryption type: %.200s", tmp___6);
#line 1067
  session_key_int = BN_new();
#line 1068
  packet_get_bignum(session_key_int, & slen);
#line 1070
  protocol_flags = packet_get_int();
#line 1071
  packet_set_protocol_flags(protocol_flags);
#line 1073
  while (1) {
#line 1073
    _p = plen;
#line 1073
    _e = (9 + slen) + 4;
#line 1073
    if (_p != _e) {
#line 1073
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "sshd.c", 1073);
#line 1073
      packet_disconnect("Packet integrity error. (%d)", 3);
    }
#line 1073
    break;
  }
#line 1079
  tmp___17 = BN_cmp((BIGNUM const   *)(sensitive_data.private_key)->n, (BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1079
  if (tmp___17 > 0) {
#line 1081
    tmp___10 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 1081
    tmp___11 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1081
    if (tmp___10 < tmp___11 + 128) {
#line 1083
      tmp___7 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1083
      tmp___8 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 1083
      tmp___9 = get_remote_ipaddr();
#line 1083
      fatal("do_connection: %s: private_key %d < host_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___9, tmp___8, tmp___7, 128);
    }
#line 1089
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.private_key);
#line 1091
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.host_key);
  } else {
#line 1095
    tmp___15 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1095
    tmp___16 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 1095
    if (tmp___15 < tmp___16 + 128) {
#line 1097
      tmp___12 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 1097
      tmp___13 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1097
      tmp___14 = get_remote_ipaddr();
#line 1097
      fatal("do_connection: %s: host_key %d < private_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___14, tmp___13, tmp___12, 128);
    }
#line 1103
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.host_key);
#line 1105
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.private_key);
  }
#line 1109
  compute_session_id((unsigned char *)(session_id), (unsigned char *)(cookie), (sensitive_data.host_key)->n,
                     (sensitive_data.private_key)->n);
#line 1114
  destroy_sensitive_data();
#line 1121
  BN_mask_bits(session_key_int, (int )(sizeof(session_key) * 8U));
#line 1122
  tmp___18 = BN_num_bits((BIGNUM const   *)session_key_int);
#line 1122
  len = (tmp___18 + 7) / 8;
#line 1123
  if (len < 0) {
#line 1124
    tmp___19 = get_remote_ipaddr();
#line 1124
    fatal("do_connection: bad len from %s: session_key_int %d > sizeof(session_key) %d",
          tmp___19, len, sizeof(session_key));
  } else {
#line 1123
    if ((unsigned int )len > sizeof(session_key)) {
#line 1124
      tmp___19 = get_remote_ipaddr();
#line 1124
      fatal("do_connection: bad len from %s: session_key_int %d > sizeof(session_key) %d",
            tmp___19, len, sizeof(session_key));
    }
  }
#line 1127
  memset((void *)(session_key), 0, sizeof(session_key));
#line 1128
  BN_bn2bin((BIGNUM const   *)session_key_int, (session_key + sizeof(session_key)) - len);
#line 1131
  BN_clear_free(session_key_int);
#line 1134
  i = 0;
#line 1134
  while (i < 16) {
#line 1135
    session_key[i] = (unsigned char )((int )session_key[i] ^ (int )session_id[i]);
#line 1134
    i ++;
  }
#line 1138
  packet_set_encryption_key((unsigned char const   *)(session_key), 32U, (int )cipher_type___0);
#line 1141
  memset((void *)(session_key), 0, sizeof(session_key));
#line 1143
  debug("Received session key; encryption turned on.");
#line 1146
  packet_start(14);
#line 1147
  packet_send();
#line 1148
  packet_write_wait();
#line 1149
  return;
}
}
#line 1154 "sshd.c"
void do_ssh2_kex(void) 
{ Buffer *server_kexinit ;
  Buffer *client_kexinit ;
  int payload_len ;
  int dlen ;
  int slen ;
  unsigned int klen ;
  unsigned int kout ;
  unsigned char *signature ;
  unsigned char *server_host_key_blob ;
  unsigned int sbloblen ;
  DH *dh ;
  BIGNUM *dh_client_pub ;
  BIGNUM *shared_secret ;
  int i ;
  unsigned char *kbuf ;
  unsigned char *hash ;
  Kex *kex___0 ;
  char *cprop[10] ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  char *tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  void *tmp___8 ;

  {
#line 1162
  signature = (unsigned char *)((void *)0);
#line 1163
  server_host_key_blob = (unsigned char *)((void *)0);
#line 1166
  dh_client_pub = (BIGNUM *)0;
#line 1167
  shared_secret = (BIGNUM *)0;
#line 1176
  if ((unsigned int )options.ciphers != (unsigned int )((void *)0)) {
#line 1177
    myproposal[3] = options.ciphers;
#line 1177
    myproposal[2] = myproposal[3];
  }
#line 1180
  server_kexinit = kex_init((char **)(myproposal));
#line 1181
  tmp = xmalloc(sizeof(*client_kexinit));
#line 1181
  client_kexinit = (Buffer *)tmp;
#line 1182
  buffer_init(client_kexinit);
#line 1185
  kex_exchange_kexinit(server_kexinit, client_kexinit, (char **)(cprop));
#line 1186
  kex___0 = kex_choose_conf((char **)(cprop), (char **)(myproposal), 1);
#line 1187
  i = 0;
#line 1187
  while (i < 10) {
#line 1188
    xfree((void *)cprop[i]);
#line 1187
    i ++;
  }
#line 1192
  debug("Wait SSH2_MSG_KEXDH_INIT.");
#line 1193
  packet_read_expect(& payload_len, 30);
#line 1196
  dh_client_pub = BN_new();
#line 1197
  if ((unsigned int )dh_client_pub == (unsigned int )((void *)0)) {
#line 1198
    fatal("dh_client_pub == NULL");
  }
#line 1199
  packet_get_bignum2(dh_client_pub, & dlen);
#line 1209
  dh = dh_new_group1();
#line 1220
  tmp___0 = dh_pub_is_valid(dh, dh_client_pub);
#line 1220
  if (! tmp___0) {
#line 1221
    packet_disconnect("bad client public DH value");
  }
#line 1223
  tmp___1 = DH_size((DH const   *)dh);
#line 1223
  klen = (unsigned int )tmp___1;
#line 1224
  tmp___2 = xmalloc(klen);
#line 1224
  kbuf = (unsigned char *)tmp___2;
#line 1225
  tmp___3 = DH_compute_key(kbuf, (BIGNUM const   *)dh_client_pub, dh);
#line 1225
  kout = (unsigned int )tmp___3;
#line 1234
  shared_secret = BN_new();
#line 1236
  BN_bin2bn((unsigned char const   *)kbuf, (int )kout, shared_secret);
#line 1237
  memset((void *)kbuf, 0, klen);
#line 1238
  xfree((void *)kbuf);
#line 1241
  dsa_make_key_blob(sensitive_data.dsa_host_key, & server_host_key_blob, & sbloblen);
#line 1244
  tmp___4 = buffer_len(server_kexinit);
#line 1244
  tmp___5 = buffer_ptr(server_kexinit);
#line 1244
  tmp___6 = buffer_len(client_kexinit);
#line 1244
  tmp___7 = buffer_ptr(client_kexinit);
#line 1244
  hash = kex_hash(client_version_string, server_version_string, tmp___7, (int )tmp___6,
                  tmp___5, (int )tmp___4, (char *)server_host_key_blob, (int )sbloblen,
                  dh_client_pub, dh->pub_key, shared_secret);
#line 1254
  buffer_free(client_kexinit);
#line 1255
  buffer_free(server_kexinit);
#line 1256
  xfree((void *)client_kexinit);
#line 1257
  xfree((void *)server_kexinit);
#line 1266
  session_id2_len = 20;
#line 1267
  tmp___8 = xmalloc((unsigned int )session_id2_len);
#line 1267
  session_id2 = (unsigned char *)tmp___8;
#line 1268
  memcpy((void * __restrict  )session_id2, (void const   * __restrict  )hash, (unsigned int )session_id2_len);
#line 1272
  dsa_sign(sensitive_data.dsa_host_key, & signature, & slen, hash, 20);
#line 1274
  destroy_sensitive_data();
#line 1277
  packet_start(31);
#line 1278
  packet_put_string((char const   *)((char *)server_host_key_blob), sbloblen);
#line 1279
  packet_put_bignum2(dh->pub_key);
#line 1280
  packet_put_string((char const   *)((char *)signature), (unsigned int )slen);
#line 1281
  packet_send();
#line 1282
  xfree((void *)signature);
#line 1283
  xfree((void *)server_host_key_blob);
#line 1284
  packet_write_wait();
#line 1286
  kex_derive_keys(kex___0, hash, shared_secret);
#line 1287
  packet_set_kex(kex___0);
#line 1290
  DH_free(dh);
#line 1292
  debug("send SSH2_MSG_NEWKEYS.");
#line 1293
  packet_start(21);
#line 1294
  packet_send();
#line 1295
  packet_write_wait();
#line 1296
  debug("done: send SSH2_MSG_NEWKEYS.");
#line 1298
  debug("Wait SSH2_MSG_NEWKEYS.");
#line 1299
  packet_read_expect(& payload_len, 21);
#line 1300
  debug("GOT SSH2_MSG_NEWKEYS.");
#line 1309
  debug("done: KEX2.");
#line 1310
  return;
}
}
#line 1 "auth.o"
#pragma merger(0,"./auth.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 382
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
#line 433
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 433 "/usr/include/sys/stat.h"
__inline static int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
#line 436
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
#line 436
  return (tmp);
}
}
#line 103 "/usr/include/grp.h"
extern struct group *getgrgid(__gid_t __gid ) ;
#line 10 "auth.h"
int allowed_user(struct passwd *pw ) ;
#line 46 "auth.c"
int allowed_user(struct passwd *pw ) 
{ struct stat st ;
  struct group *grp ;
  char *shell ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 58
  if (! pw) {
#line 59
    return (0);
  }
#line 65
  if ((int )*(pw->pw_shell + 0) == 0) {
#line 65
    shell = (char *)"/bin/sh";
  } else {
#line 65
    shell = pw->pw_shell;
  }
#line 68
  tmp = stat((char const   * __restrict  )shell, (struct stat * __restrict  )(& st));
#line 68
  if (tmp != 0) {
#line 69
    return (0);
  }
#line 70
  if (st.st_mode & 32768U) {
#line 70
    if (! (st.st_mode & (unsigned int )((((64 >> 3) >> 3) | 64) | (64 >> 3)))) {
#line 71
      return (0);
    }
  } else {
#line 71
    return (0);
  }
#line 74
  if (options.num_deny_users > 0U) {
#line 75
    if (! pw->pw_name) {
#line 76
      return (0);
    }
#line 77
    i = 0;
#line 77
    while ((unsigned int )i < options.num_deny_users) {
#line 78
      tmp___0 = match_pattern((char const   *)pw->pw_name, (char const   *)options.deny_users[i]);
#line 78
      if (tmp___0) {
#line 79
        return (0);
      }
#line 77
      i ++;
    }
  }
#line 82
  if (options.num_allow_users > 0U) {
#line 83
    if (! pw->pw_name) {
#line 84
      return (0);
    }
#line 85
    i = 0;
#line 85
    while ((unsigned int )i < options.num_allow_users) {
#line 86
      tmp___1 = match_pattern((char const   *)pw->pw_name, (char const   *)options.allow_users[i]);
#line 86
      if (tmp___1) {
#line 87
        break;
      }
#line 85
      i ++;
    }
#line 89
    if ((unsigned int )i >= options.num_allow_users) {
#line 90
      return (0);
    }
  }
#line 93
  if (options.num_deny_groups > 0U) {
    goto _L;
  } else {
#line 93
    if (options.num_allow_groups > 0U) {
      _L: /* CIL Label */ 
#line 94
      grp = getgrgid(pw->pw_gid);
#line 95
      if (! grp) {
#line 96
        return (0);
      }
#line 99
      if (options.num_deny_groups > 0U) {
#line 100
        if (! grp->gr_name) {
#line 101
          return (0);
        }
#line 102
        i = 0;
#line 102
        while ((unsigned int )i < options.num_deny_groups) {
#line 103
          tmp___2 = match_pattern((char const   *)grp->gr_name, (char const   *)options.deny_groups[i]);
#line 103
          if (tmp___2) {
#line 104
            return (0);
          }
#line 102
          i ++;
        }
      }
#line 110
      if (options.num_allow_groups > 0U) {
#line 111
        if (! grp->gr_name) {
#line 112
          return (0);
        }
#line 113
        i = 0;
#line 113
        while ((unsigned int )i < options.num_allow_groups) {
#line 114
          tmp___3 = match_pattern((char const   *)grp->gr_name, (char const   *)options.allow_groups[i]);
#line 114
          if (tmp___3) {
#line 115
            break;
          }
#line 113
          i ++;
        }
#line 118
        if ((unsigned int )i >= options.num_allow_groups) {
#line 119
          return (0);
        }
      }
    }
  }
#line 141
  return (1);
}
}
#line 1 "auth1.o"
#pragma merger(0,"./auth1.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 356 "ssh.h"
int auth_rhosts(struct passwd *pw , char const   *client_user ) ;
#line 362
int auth_rhosts_rsa(struct passwd *pw , char const   *client_user , RSA *client_host_key ) ;
#line 376
int auth_rsa(struct passwd *pw , BIGNUM *client_n ) ;
#line 6 "auth-pam.h"
void start_pam(struct passwd *pw ) ;
#line 8
int auth_pam_password(struct passwd *pw , char const   *password ) ;
#line 10
int do_pam_account(char *username , char *remote_user ) ;
#line 5 "session.h"
void do_authenticated(struct passwd *pw ) ;
#line 23 "auth1.c"
char *forced_command ;
#line 31 "auth1.c"
static char buf[1024]  ;
#line 28 "auth1.c"
char *get_authname(int type ) 
{ 

  {
#line 32
  switch (type) {
  case 9: 
#line 34
  return ((char *)"password");
  case 6: 
#line 36
  return ((char *)"rsa");
  case 35: 
#line 38
  return ((char *)"rhosts-rsa");
  case 5: 
#line 40
  return ((char *)"rhosts");
  }
#line 50
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"bad-auth-msg-%d",
           type);
#line 51
  return (buf);
}
}
#line 58 "auth1.c"
void do_fake_authloop1(char *user ) 
{ int attempt___0 ;
  int tmp ;
  char const   *tmp___0 ;
  int plen ;

  {
#line 61
  attempt___0 = 0;
#line 63
  tmp = get_remote_port();
#line 63
  tmp___0 = get_remote_ipaddr();
#line 63
  log("Faking authloop for illegal user %.200s from %.200s port %d", user, tmp___0,
      tmp);
#line 73
  packet_start(15);
#line 74
  packet_send();
#line 75
  packet_write_wait();
#line 81
  attempt___0 = 1;
#line 81
  while (1) {
#line 85
    packet_read(& plen);
#line 111
    if (attempt___0 > 6) {
#line 112
      packet_disconnect("Too many authentication failures for %.100s", user);
    }
#line 118
    packet_start(15);
#line 119
    packet_send();
#line 120
    packet_write_wait();
#line 81
    attempt___0 ++;
  }
#line 123
  abort();
}
}
#line 130 "auth1.c"
void do_authloop(struct passwd *pw ) 
{ int attempt___0 ;
  unsigned int bits ;
  RSA *client_host_key ;
  BIGNUM *n___0 ;
  char *client_user ;
  char *password ;
  char user[1024] ;
  unsigned int dlen ;
  int plen ;
  int nlen ;
  int elen ;
  unsigned int ulen ;
  int type ;
  void (*authlog___0)(char const   *fmt  , ...) ;
  int authenticated ;
  int _p ;
  int _e ;
  int tmp ;
  int tmp___0 ;
  int _p___0 ;
  int _e___0 ;
  int _p___1 ;
  int _e___1 ;
  int _p___2 ;
  int _e___2 ;
  size_t tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;

  {
#line 133
  attempt___0 = 0;
#line 137
  client_user = (char *)((void *)0);
#line 137
  password = (char *)((void *)0);
#line 142
  type = 0;
#line 143
  authlog___0 = (void (*)(char const   *fmt  , ...))(& verbose);
#line 146
  packet_start(15);
#line 147
  packet_send();
#line 148
  packet_write_wait();
#line 150
  attempt___0 = 1;
#line 150
  while (1) {
#line 151
    authenticated = 0;
#line 152
    strlcpy(user, "", sizeof(user));
#line 155
    type = packet_read(& plen);
#line 158
    switch (type) {
    case 5: 
#line 218
    if (! options.rhosts_authentication) {
#line 219
      verbose("Rhosts authentication disabled.");
#line 220
      break;
    }
#line 228
    client_user = packet_get_string(& ulen);
#line 229
    while (1) {
#line 229
      _p = plen;
#line 229
      _e = (int )(4U + ulen);
#line 229
      if (_p != _e) {
#line 229
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "auth1.c", 229);
#line 229
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 229
      break;
    }
#line 233
    authenticated = auth_rhosts(pw, (char const   *)client_user);
#line 235
    snprintf((char * __restrict  )(user), sizeof(user), (char const   * __restrict  )" ruser %s",
             client_user);
#line 236
    break;
    case 35: 
#line 239
    if (! options.rhosts_rsa_authentication) {
#line 240
      verbose("Rhosts with RSA authentication disabled.");
#line 241
      break;
    }
#line 248
    client_user = packet_get_string(& ulen);
#line 251
    client_host_key = RSA_new();
#line 252
    if ((unsigned int )client_host_key == (unsigned int )((void *)0)) {
#line 253
      fatal("RSA_new failed");
    }
#line 254
    client_host_key->e = BN_new();
#line 255
    client_host_key->n = BN_new();
#line 256
    if ((unsigned int )client_host_key->e == (unsigned int )((void *)0)) {
#line 257
      fatal("BN_new failed");
    } else {
#line 256
      if ((unsigned int )client_host_key->n == (unsigned int )((void *)0)) {
#line 257
        fatal("BN_new failed");
      }
    }
#line 258
    bits = packet_get_int();
#line 259
    packet_get_bignum(client_host_key->e, & elen);
#line 260
    packet_get_bignum(client_host_key->n, & nlen);
#line 262
    tmp___0 = BN_num_bits((BIGNUM const   *)client_host_key->n);
#line 262
    if (bits != (unsigned int )tmp___0) {
#line 263
      tmp = BN_num_bits((BIGNUM const   *)client_host_key->n);
#line 263
      log("Warning: keysize mismatch for client_host_key: actual %d, announced %d",
          tmp, bits);
    }
#line 265
    while (1) {
#line 265
      _p___0 = plen;
#line 265
      _e___0 = (int )((((4U + ulen) + 4U) + (unsigned int )elen) + (unsigned int )nlen);
#line 265
      if (_p___0 != _e___0) {
#line 265
        log("Packet integrity error (%d != %d) at %s:%d", _p___0, _e___0, "auth1.c",
            265);
#line 265
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 265
      break;
    }
#line 267
    authenticated = auth_rhosts_rsa(pw, (char const   *)client_user, client_host_key);
#line 268
    RSA_free(client_host_key);
#line 270
    snprintf((char * __restrict  )(user), sizeof(user), (char const   * __restrict  )" ruser %s",
             client_user);
#line 271
    break;
    case 6: 
#line 274
    if (! options.rsa_authentication) {
#line 275
      verbose("RSA authentication disabled.");
#line 276
      break;
    }
#line 279
    n___0 = BN_new();
#line 280
    packet_get_bignum(n___0, & nlen);
#line 281
    while (1) {
#line 281
      _p___1 = plen;
#line 281
      _e___1 = nlen;
#line 281
      if (_p___1 != _e___1) {
#line 281
        log("Packet integrity error (%d != %d) at %s:%d", _p___1, _e___1, "auth1.c",
            281);
#line 281
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 281
      break;
    }
#line 282
    authenticated = auth_rsa(pw, n___0);
#line 283
    BN_clear_free(n___0);
#line 284
    break;
    case 9: 
#line 287
    if (! options.password_authentication) {
#line 288
      verbose("Password authentication disabled.");
#line 289
      break;
    }
#line 296
    password = packet_get_string(& dlen);
#line 297
    while (1) {
#line 297
      _p___2 = plen;
#line 297
      _e___2 = (int )(4U + dlen);
#line 297
      if (_p___2 != _e___2) {
#line 297
        log("Packet integrity error (%d != %d) at %s:%d", _p___2, _e___2, "auth1.c",
            297);
#line 297
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 297
      break;
    }
#line 301
    authenticated = auth_pam_password(pw, (char const   *)password);
#line 307
    tmp___1 = strlen((char const   *)password);
#line 307
    memset((void *)password, 0, tmp___1);
#line 308
    xfree((void *)password);
#line 309
    break;
    case 39: 
#line 345
    log("TIS authentication unsupported.");
#line 346
    break;
    default: 
#line 354
    log("Unknown message during authentication: type %d", type);
#line 355
    break;
    }
#line 363
    if (authenticated) {
#line 363
      if (pw->pw_uid == 0U) {
#line 363
        if (! options.permit_root_login) {
#line 364
          if (forced_command) {
#line 365
            log("Root login accepted for forced command.");
          } else {
#line 367
            authenticated = 0;
#line 368
            tmp___2 = get_canonical_hostname();
#line 368
            log("ROOT LOGIN REFUSED FROM %.200s", tmp___2);
          }
        }
      }
    }
#line 374
    if (authenticated) {
#line 377
      authlog___0 = (void (*)(char const   *fmt  , ...))(& log);
    } else {
#line 374
      if (attempt___0 == 3) {
#line 377
        authlog___0 = (void (*)(char const   *fmt  , ...))(& log);
      } else {
#line 374
        if (type == 9) {
#line 377
          authlog___0 = (void (*)(char const   *fmt  , ...))(& log);
        }
      }
    }
#line 379
    tmp___3 = get_remote_port();
#line 379
    tmp___4 = get_remote_ipaddr();
#line 379
    if (pw->pw_uid == 0U) {
#line 379
      tmp___5 = "ROOT";
    } else {
#line 379
      tmp___5 = (char const   *)pw->pw_name;
    }
#line 379
    tmp___6 = get_authname(type);
#line 379
    if (authenticated) {
#line 379
      tmp___7 = "Accepted";
    } else {
#line 379
      tmp___7 = "Failed";
    }
#line 379
    (*authlog___0)("%s %s for %.200s from %.200s port %d%s", tmp___7, tmp___6, tmp___5,
                   tmp___4, tmp___3, user);
#line 388
    if (authenticated) {
#line 389
      tmp___8 = do_pam_account(pw->pw_name, client_user);
#line 389
      if (! tmp___8) {
#line 390
        if ((unsigned int )client_user != (unsigned int )((void *)0)) {
#line 391
          xfree((void *)client_user);
#line 392
          client_user = (char *)((void *)0);
        }
#line 394
        do_fake_authloop1(pw->pw_name);
      }
#line 396
      return;
    }
#line 404
    if ((unsigned int )client_user != (unsigned int )((void *)0)) {
#line 405
      xfree((void *)client_user);
#line 406
      client_user = (char *)((void *)0);
    }
#line 409
    if (attempt___0 > 6) {
#line 413
      packet_disconnect("Too many authentication failures for %.100s", pw->pw_name);
    }
#line 417
    packet_start(15);
#line 418
    packet_send();
#line 419
    packet_write_wait();
#line 150
    attempt___0 ++;
  }
}
}
#line 427 "auth1.c"
void do_authentication(void) 
{ struct passwd *pw ;
  struct passwd pwcopy ;
  int plen ;
  unsigned int ulen ;
  char *user ;
  int _p ;
  int _e ;
  int tmp ;
  __uid_t tmp___0 ;
  __uid_t tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
#line 439
  packet_read_expect(& plen, 4);
#line 442
  user = packet_get_string(& ulen);
#line 443
  while (1) {
#line 443
    _p = plen;
#line 443
    _e = (int )(4U + ulen);
#line 443
    if (_p != _e) {
#line 443
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "auth1.c", 443);
#line 443
      packet_disconnect("Packet integrity error. (%d)", 4);
    }
#line 443
    break;
  }
#line 445
  setproctitle("%s", user);
#line 456
  pw = getpwnam((char const   *)user);
#line 457
  if (! pw) {
#line 458
    do_fake_authloop1(user);
  } else {
#line 457
    tmp = allowed_user(pw);
#line 457
    if (! tmp) {
#line 458
      do_fake_authloop1(user);
    }
  }
#line 459
  xfree((void *)user);
#line 462
  memset((void *)(& pwcopy), 0, sizeof(pwcopy));
#line 463
  pwcopy.pw_name = xstrdup((char const   *)pw->pw_name);
#line 464
  pwcopy.pw_passwd = xstrdup((char const   *)pw->pw_passwd);
#line 465
  pwcopy.pw_uid = pw->pw_uid;
#line 466
  pwcopy.pw_gid = pw->pw_gid;
#line 467
  pwcopy.pw_dir = xstrdup((char const   *)pw->pw_dir);
#line 468
  pwcopy.pw_shell = xstrdup((char const   *)pw->pw_shell);
#line 469
  pw = & pwcopy;
#line 472
  start_pam(pw);
#line 479
  tmp___0 = getuid();
#line 479
  if (tmp___0 != 0U) {
#line 479
    tmp___1 = getuid();
#line 479
    if (pw->pw_uid != tmp___1) {
#line 480
      packet_disconnect("Cannot change user when server not running as root.");
    }
  }
#line 482
  debug("Attempting authentication for %.100s.", pw->pw_name);
#line 485
  if (options.password_authentication) {
#line 485
    tmp___3 = auth_pam_password(pw, "");
#line 485
    if (tmp___3) {
#line 495
      tmp___2 = get_remote_ipaddr();
#line 495
      log("Login for user %s from %.100s, accepted without authentication.", pw->pw_name,
          tmp___2);
    } else {
#line 501
      do_authloop(pw);
    }
  } else {
#line 501
    do_authloop(pw);
  }
#line 510
  packet_start(14);
#line 511
  packet_send();
#line 512
  packet_write_wait();
#line 515
  do_authenticated(pw);
#line 516
  return;
}
}
#line 1 "auth2.o"
#pragma merger(0,"./auth2.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 212
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 759 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 7 "auth.h"
struct passwd *auth_get_user(void) ;
#line 8 "session.h"
void do_authenticated2(void) ;
#line 65 "auth2.c"
void input_service_request(int type , int plen ) ;
#line 66
void input_userauth_request(int type , int plen ) ;
#line 67
void protocol_error(int type , int plen ) ;
#line 70
int ssh2_auth_none(struct passwd *pw ) ;
#line 71
int ssh2_auth_password(struct passwd *pw ) ;
#line 72
int ssh2_auth_pubkey(struct passwd *pw , unsigned char *raw , unsigned int rlen ) ;
#line 75
struct passwd *auth_set_user(char *u , char *s ) ;
#line 76
int user_dsa_key_allowed(struct passwd *pw , Key *key ) ;
#line 85 "auth2.c"
static Authctxt *authctxt  =    (Authctxt *)((void *)0);
#line 86 "auth2.c"
static int userauth_success  =    0;
#line 92 "auth2.c"
void do_authentication2(void) 
{ 

  {
#line 103
  dispatch_init(& protocol_error);
#line 104
  dispatch_set(5, & input_service_request);
#line 105
  dispatch_run(0, & userauth_success);
#line 106
  do_authenticated2();
#line 107
  return;
}
}
#line 109 "auth2.c"
void protocol_error(int type , int plen ) 
{ 

  {
#line 112
  log("auth: protocol error: type %d plen %d", type, plen);
#line 113
  packet_start(3);
#line 114
  packet_put_int(0U);
#line 115
  packet_send();
#line 116
  packet_write_wait();
#line 117
  return;
}
}
#line 119 "auth2.c"
void input_service_request(int type , int plen ) 
{ unsigned int len ;
  int accept___0 ;
  char *service ;
  char *tmp ;
  int _len ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 123
  accept___0 = 0;
#line 124
  tmp = packet_get_string(& len);
#line 124
  service = tmp;
#line 125
  while (1) {
#line 125
    tmp___0 = packet_remaining();
#line 125
    _len = tmp___0;
#line 125
    if (_len > 0) {
#line 125
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
          125);
#line 125
      packet_disconnect("Packet integrity error.");
    }
#line 125
    break;
  }
#line 127
  if (0) {
#line 127
    __s1_len = strlen((char const   *)service);
#line 127
    __s2_len = strlen("ssh-userauth");
#line 127
    if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
      goto _L___0;
    } else {
#line 127
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 127
        if (! ((unsigned int )((void const   *)("ssh-userauth" + 1)) - (unsigned int )((void const   *)"ssh-userauth") == 1U)) {
#line 127
          tmp___10 = 1;
        } else {
#line 127
          if (__s2_len >= 4U) {
#line 127
            tmp___10 = 1;
          } else {
#line 127
            tmp___10 = 0;
          }
        }
      } else {
#line 127
        tmp___10 = 0;
      }
    }
#line 127
    if (tmp___10) {
#line 127
      tmp___6 = __builtin_strcmp((char const   *)service, "ssh-userauth");
    } else {
#line 127
      tmp___9 = __builtin_strcmp((char const   *)service, "ssh-userauth");
#line 127
      tmp___6 = tmp___9;
    }
  } else {
#line 127
    tmp___9 = __builtin_strcmp((char const   *)service, "ssh-userauth");
#line 127
    tmp___6 = tmp___9;
  }
#line 127
  if (tmp___6 == 0) {
#line 128
    if (! userauth_success) {
#line 129
      accept___0 = 1;
#line 131
      dispatch_set(50, & input_userauth_request);
    }
  }
#line 136
  if (accept___0) {
#line 137
    packet_start(6);
#line 138
    packet_put_cstring((char const   *)service);
#line 139
    packet_send();
#line 140
    packet_write_wait();
  } else {
#line 142
    debug("bad service request %s", service);
#line 143
    packet_disconnect("bad service request %s", service);
  }
#line 145
  xfree((void *)service);
#line 146
  return;
}
}
#line 151 "auth2.c"
static void (*authlog)(char const   *fmt  , ...)  =    (void (*)(char const   *fmt  , ...))(& verbose);
#line 152 "auth2.c"
static int attempt  =    0;
#line 148 "auth2.c"
void input_userauth_request(int type , int plen ) 
{ unsigned int len ;
  unsigned int rlen ;
  int authenticated ;
  char *raw ;
  char *user ;
  char *service ;
  char *method ;
  char *authmsg ;
  struct passwd *pw ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  char const   *tmp___39 ;
  int tmp___40 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___46 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  char const   *tmp___52 ;
  char const   *tmp___53 ;

  {
#line 154
  authenticated = 0;
#line 155
  authmsg = (char *)((void *)0);
#line 161
  raw = packet_get_raw((int *)(& rlen));
#line 162
  if ((unsigned int )plen != rlen) {
#line 163
    fatal("plen != rlen");
  }
#line 164
  user = packet_get_string(& len);
#line 165
  service = packet_get_string(& len);
#line 166
  method = packet_get_string(& len);
#line 167
  attempt ++;
#line 167
  if (attempt == 6) {
#line 171
    packet_disconnect("too many failed userauth_requests");
  }
#line 173
  debug("userauth-request for user %s service %s method %s", user, service, method);
#line 176
  pw = auth_set_user(user, service);
#line 177
  if (pw) {
#line 177
    if (0) {
#line 177
      __s1_len___2 = strlen((char const   *)service);
#line 177
      __s2_len___2 = strlen("ssh-connection");
#line 177
      if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
        goto _L___6;
      } else {
#line 177
        if (__s1_len___2 >= 4U) {
          _L___6: /* CIL Label */ 
#line 177
          if (! ((unsigned int )((void const   *)("ssh-connection" + 1)) - (unsigned int )((void const   *)"ssh-connection") == 1U)) {
#line 177
            tmp___38 = 1;
          } else {
#line 177
            if (__s2_len___2 >= 4U) {
#line 177
              tmp___38 = 1;
            } else {
#line 177
              tmp___38 = 0;
            }
          }
        } else {
#line 177
          tmp___38 = 0;
        }
      }
#line 177
      if (tmp___38) {
#line 177
        tmp___34 = __builtin_strcmp((char const   *)service, "ssh-connection");
      } else {
#line 177
        tmp___37 = __builtin_strcmp((char const   *)service, "ssh-connection");
#line 177
        tmp___34 = tmp___37;
      }
    } else {
#line 177
      tmp___37 = __builtin_strcmp((char const   *)service, "ssh-connection");
#line 177
      tmp___34 = tmp___37;
    }
#line 177
    if (tmp___34 == 0) {
#line 178
      if (0) {
#line 178
        __s1_len___1 = strlen((char const   *)method);
#line 178
        __s2_len___1 = strlen("none");
#line 178
        if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
          goto _L___4;
        } else {
#line 178
          if (__s1_len___1 >= 4U) {
            _L___4: /* CIL Label */ 
#line 178
            if (! ((unsigned int )((void const   *)("none" + 1)) - (unsigned int )((void const   *)"none") == 1U)) {
#line 178
              tmp___28 = 1;
            } else {
#line 178
              if (__s2_len___1 >= 4U) {
#line 178
                tmp___28 = 1;
              } else {
#line 178
                tmp___28 = 0;
              }
            }
          } else {
#line 178
            tmp___28 = 0;
          }
        }
#line 178
        if (tmp___28) {
#line 178
          tmp___24 = __builtin_strcmp((char const   *)method, "none");
        } else {
#line 178
          tmp___27 = __builtin_strcmp((char const   *)method, "none");
#line 178
          tmp___24 = tmp___27;
        }
      } else {
#line 178
        tmp___27 = __builtin_strcmp((char const   *)method, "none");
#line 178
        tmp___24 = tmp___27;
      }
#line 178
      if (tmp___24 == 0) {
#line 179
        authenticated = ssh2_auth_none(pw);
      } else {
#line 180
        if (0) {
#line 180
          __s1_len___0 = strlen((char const   *)method);
#line 180
          __s2_len___0 = strlen("password");
#line 180
          if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
            goto _L___2;
          } else {
#line 180
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 180
              if (! ((unsigned int )((void const   *)("password" + 1)) - (unsigned int )((void const   *)"password") == 1U)) {
#line 180
                tmp___18 = 1;
              } else {
#line 180
                if (__s2_len___0 >= 4U) {
#line 180
                  tmp___18 = 1;
                } else {
#line 180
                  tmp___18 = 0;
                }
              }
            } else {
#line 180
              tmp___18 = 0;
            }
          }
#line 180
          if (tmp___18) {
#line 180
            tmp___14 = __builtin_strcmp((char const   *)method, "password");
          } else {
#line 180
            tmp___17 = __builtin_strcmp((char const   *)method, "password");
#line 180
            tmp___14 = tmp___17;
          }
        } else {
#line 180
          tmp___17 = __builtin_strcmp((char const   *)method, "password");
#line 180
          tmp___14 = tmp___17;
        }
#line 180
        if (tmp___14 == 0) {
#line 181
          authenticated = ssh2_auth_password(pw);
        } else {
#line 182
          if (0) {
#line 182
            __s1_len = strlen((char const   *)method);
#line 182
            __s2_len = strlen("publickey");
#line 182
            if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
              goto _L___0;
            } else {
#line 182
              if (__s1_len >= 4U) {
                _L___0: /* CIL Label */ 
#line 182
                if (! ((unsigned int )((void const   *)("publickey" + 1)) - (unsigned int )((void const   *)"publickey") == 1U)) {
#line 182
                  tmp___8 = 1;
                } else {
#line 182
                  if (__s2_len >= 4U) {
#line 182
                    tmp___8 = 1;
                  } else {
#line 182
                    tmp___8 = 0;
                  }
                }
              } else {
#line 182
                tmp___8 = 0;
              }
            }
#line 182
            if (tmp___8) {
#line 182
              tmp___4 = __builtin_strcmp((char const   *)method, "publickey");
            } else {
#line 182
              tmp___7 = __builtin_strcmp((char const   *)method, "publickey");
#line 182
              tmp___4 = tmp___7;
            }
          } else {
#line 182
            tmp___7 = __builtin_strcmp((char const   *)method, "publickey");
#line 182
            tmp___4 = tmp___7;
          }
#line 182
          if (tmp___4 == 0) {
#line 183
            authenticated = ssh2_auth_pubkey(pw, (unsigned char *)raw, rlen);
          }
        }
      }
    }
  }
#line 186
  if (authenticated) {
#line 186
    if (pw) {
#line 186
      if (pw->pw_uid == 0U) {
#line 186
        if (! options.permit_root_login) {
#line 187
          authenticated = 0;
#line 188
          tmp___39 = get_canonical_hostname();
#line 188
          log("ROOT LOGIN REFUSED FROM %.200s", tmp___39);
        }
      }
    }
  }
#line 193
  if (authenticated) {
#line 193
    tmp___40 = do_pam_account(pw->pw_name, (char *)((void *)0));
#line 193
    if (! tmp___40) {
#line 194
      authenticated = 0;
    }
  }
#line 200
  if (authenticated == 1) {
#line 201
    authlog = (void (*)(char const   *fmt  , ...))(& log);
  } else {
#line 200
    if (attempt == 3) {
#line 201
      authlog = (void (*)(char const   *fmt  , ...))(& log);
    } else {
#line 200
      if (0) {
#line 200
        __s1_len___3 = strlen((char const   *)method);
#line 200
        __s2_len___3 = strlen("password");
#line 200
        if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
          goto _L___8;
        } else {
#line 200
          if (__s1_len___3 >= 4U) {
            _L___8: /* CIL Label */ 
#line 200
            if (! ((unsigned int )((void const   *)("password" + 1)) - (unsigned int )((void const   *)"password") == 1U)) {
#line 200
              tmp___50 = 1;
            } else {
#line 200
              if (__s2_len___3 >= 4U) {
#line 200
                tmp___50 = 1;
              } else {
#line 200
                tmp___50 = 0;
              }
            }
          } else {
#line 200
            tmp___50 = 0;
          }
        }
#line 200
        if (tmp___50) {
#line 200
          tmp___46 = __builtin_strcmp((char const   *)method, "password");
        } else {
#line 200
          tmp___49 = __builtin_strcmp((char const   *)method, "password");
#line 200
          tmp___46 = tmp___49;
        }
      } else {
#line 200
        tmp___49 = __builtin_strcmp((char const   *)method, "password");
#line 200
        tmp___46 = tmp___49;
      }
#line 200
      if (tmp___46 == 0) {
#line 201
        authlog = (void (*)(char const   *fmt  , ...))(& log);
      }
    }
  }
#line 204
  if (authenticated == 1) {
#line 205
    authmsg = (char *)"Accepted";
  } else {
#line 206
    if (authenticated == 0) {
#line 207
      authmsg = (char *)"Failed";
    } else {
#line 209
      authmsg = (char *)"Postponed";
    }
  }
#line 211
  tmp___51 = get_remote_port();
#line 211
  tmp___52 = get_remote_ipaddr();
#line 211
  if (pw) {
#line 211
    if (pw->pw_uid == 0U) {
#line 211
      tmp___53 = "ROOT";
    } else {
#line 211
      tmp___53 = (char const   *)user;
    }
  } else {
#line 211
    tmp___53 = (char const   *)user;
  }
#line 211
  (*authlog)("%s %s for %.200s from %.200s port %d ssh2", authmsg, method, tmp___53,
             tmp___52, tmp___51);
#line 219
  if (authenticated == 1) {
#line 227
    dispatch_set(50, & protocol_error);
#line 228
    packet_start(52);
#line 229
    packet_send();
#line 230
    packet_write_wait();
#line 232
    userauth_success = 1;
  } else {
#line 233
    if (authenticated == 0) {
#line 234
      packet_start(51);
#line 235
      packet_put_cstring("publickey,password");
#line 236
      packet_put_char(0);
#line 237
      packet_send();
#line 238
      packet_write_wait();
    }
  }
#line 241
  xfree((void *)service);
#line 242
  xfree((void *)user);
#line 243
  xfree((void *)method);
#line 244
  return;
}
}
#line 246 "auth2.c"
int ssh2_auth_none(struct passwd *pw ) 
{ int _len ;
  int tmp ;
  int tmp___0 ;

  {
#line 249
  while (1) {
#line 249
    tmp = packet_remaining();
#line 249
    _len = tmp;
#line 249
    if (_len > 0) {
#line 249
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
          249);
#line 249
      packet_disconnect("Packet integrity error.");
    }
#line 249
    break;
  }
#line 251
  tmp___0 = auth_pam_password(pw, "");
#line 251
  return (tmp___0);
}
}
#line 256 "auth2.c"
int ssh2_auth_password(struct passwd *pw ) 
{ char *password ;
  int authenticated ;
  int change ;
  unsigned int len ;
  unsigned int tmp ;
  int _len ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 260
  authenticated = 0;
#line 263
  tmp = packet_get_char();
#line 263
  change = (int )tmp;
#line 264
  if (change) {
#line 265
    log("password change not supported");
  }
#line 266
  password = packet_get_string(& len);
#line 267
  while (1) {
#line 267
    tmp___0 = packet_remaining();
#line 267
    _len = tmp___0;
#line 267
    if (_len > 0) {
#line 267
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
          267);
#line 267
      packet_disconnect("Packet integrity error.");
    }
#line 267
    break;
  }
#line 268
  if (options.password_authentication) {
#line 268
    tmp___1 = auth_pam_password(pw, (char const   *)password);
#line 268
    if (tmp___1 == 1) {
#line 274
      authenticated = 1;
    }
  }
#line 275
  memset((void *)password, 0, len);
#line 276
  xfree((void *)password);
#line 277
  return (authenticated);
}
}
#line 279 "auth2.c"
int ssh2_auth_pubkey(struct passwd *pw , unsigned char *raw , unsigned int rlen ) 
{ Buffer b ;
  Key *key ;
  char *pkalg ;
  char *pkblob ;
  char *sig ;
  unsigned int alen ;
  unsigned int blen ;
  unsigned int slen ;
  int have_sig ;
  int authenticated ;
  unsigned int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  int _len ;
  int tmp___10 ;
  int tmp___11 ;
  unsigned int tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int _len___0 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 287
  authenticated = 0;
#line 289
  if (options.dsa_authentication == 0) {
#line 290
    debug("pubkey auth disabled");
#line 291
    return (0);
  }
#line 293
  if (datafellows & 2) {
#line 294
    log("bug compatibility with ssh-2.0.13 pubkey not implemented");
#line 295
    return (0);
  }
#line 297
  tmp = packet_get_char();
#line 297
  have_sig = (int )tmp;
#line 298
  pkalg = packet_get_string(& alen);
#line 299
  if (0) {
#line 299
    __s1_len = strlen((char const   *)pkalg);
#line 299
    __s2_len = strlen("ssh-dss");
#line 299
    if (! ((unsigned int )((void const   *)(pkalg + 1)) - (unsigned int )((void const   *)pkalg) == 1U)) {
      goto _L___0;
    } else {
#line 299
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 299
        if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
#line 299
          tmp___9 = 1;
        } else {
#line 299
          if (__s2_len >= 4U) {
#line 299
            tmp___9 = 1;
          } else {
#line 299
            tmp___9 = 0;
          }
        }
      } else {
#line 299
        tmp___9 = 0;
      }
    }
#line 299
    if (tmp___9) {
#line 299
      tmp___5 = __builtin_strcmp((char const   *)pkalg, "ssh-dss");
    } else {
#line 299
      tmp___8 = __builtin_strcmp((char const   *)pkalg, "ssh-dss");
#line 299
      tmp___5 = tmp___8;
    }
  } else {
#line 299
    tmp___8 = __builtin_strcmp((char const   *)pkalg, "ssh-dss");
#line 299
    tmp___5 = tmp___8;
  }
#line 299
  if (tmp___5 != 0) {
#line 300
    xfree((void *)pkalg);
#line 301
    log("bad pkalg %s", pkalg);
#line 302
    return (0);
  }
#line 304
  pkblob = packet_get_string(& blen);
#line 305
  key = dsa_key_from_blob(pkblob, (int )blen);
#line 306
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 307
    if (have_sig) {
#line 308
      sig = packet_get_string(& slen);
#line 309
      while (1) {
#line 309
        tmp___10 = packet_remaining();
#line 309
        _len = tmp___10;
#line 309
        if (_len > 0) {
#line 309
          log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
              309);
#line 309
          packet_disconnect("Packet integrity error.");
        }
#line 309
        break;
      }
#line 310
      buffer_init(& b);
#line 311
      buffer_append(& b, (char const   *)session_id2, (unsigned int )session_id2_len);
#line 312
      buffer_put_char(& b, 50);
#line 313
      if (slen + 4U > rlen) {
#line 314
        fatal("bad rlen/slen");
      }
#line 315
      buffer_append(& b, (char const   *)raw, (rlen - slen) - 4U);
#line 320
      tmp___11 = user_dsa_key_allowed(pw, key);
#line 320
      if (tmp___11) {
#line 320
        tmp___12 = buffer_len(& b);
#line 320
        tmp___13 = buffer_ptr(& b);
#line 320
        tmp___14 = dsa_verify(key, (unsigned char *)sig, (int )slen, (unsigned char *)tmp___13,
                              (int )tmp___12);
#line 320
        if (tmp___14 == 1) {
#line 322
          authenticated = 1;
        }
      }
#line 323
      buffer_clear(& b);
#line 324
      xfree((void *)sig);
    } else {
#line 326
      while (1) {
#line 326
        tmp___15 = packet_remaining();
#line 326
        _len___0 = tmp___15;
#line 326
        if (_len___0 > 0) {
#line 326
          log("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "auth2.c",
              326);
#line 326
          packet_disconnect("Packet integrity error.");
        }
#line 326
        break;
      }
#line 327
      debug("test key...");
#line 337
      tmp___16 = user_dsa_key_allowed(pw, key);
#line 337
      if (tmp___16) {
#line 338
        packet_start(60);
#line 339
        packet_put_string((char const   *)pkalg, alen);
#line 340
        packet_put_string((char const   *)pkblob, blen);
#line 341
        packet_send();
#line 342
        packet_write_wait();
#line 343
        authenticated = -1;
      }
    }
#line 346
    key_free(key);
  }
#line 348
  xfree((void *)pkalg);
#line 349
  xfree((void *)pkblob);
#line 350
  return (authenticated);
}
}
#line 355 "auth2.c"
struct passwd *auth_get_user(void) 
{ struct passwd *tmp ;

  {
#line 358
  if ((unsigned int )authctxt != (unsigned int )((void *)0)) {
#line 358
    if (authctxt->valid) {
#line 358
      tmp = & authctxt->pw;
    } else {
#line 358
      tmp = (struct passwd *)((void *)0);
    }
  } else {
#line 358
    tmp = (struct passwd *)((void *)0);
  }
#line 358
  return (tmp);
}
}
#line 361 "auth2.c"
struct passwd *auth_set_user(char *u , char *s ) 
{ struct passwd *pw ;
  struct passwd *copy ;
  void *tmp ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___16 ;
  int tmp___19 ;
  int tmp___20 ;
  struct passwd *tmp___21 ;

  {
#line 366
  if ((unsigned int )authctxt == (unsigned int )((void *)0)) {
#line 367
    tmp = xmalloc(sizeof(*authctxt));
#line 367
    authctxt = (Authctxt *)tmp;
#line 368
    authctxt->valid = 0;
#line 369
    authctxt->user = xstrdup((char const   *)u);
#line 370
    authctxt->service = xstrdup((char const   *)s);
#line 371
    setproctitle("%s", u);
#line 372
    pw = getpwnam((char const   *)u);
#line 373
    if (! pw) {
#line 374
      log("auth_set_user: illegal user %s", u);
#line 375
      return ((struct passwd *)((void *)0));
    } else {
#line 373
      tmp___0 = allowed_user(pw);
#line 373
      if (! tmp___0) {
#line 374
        log("auth_set_user: illegal user %s", u);
#line 375
        return ((struct passwd *)((void *)0));
      }
    }
#line 378
    start_pam(pw);
#line 380
    copy = & authctxt->pw;
#line 381
    memset((void *)copy, 0, sizeof(*copy));
#line 382
    copy->pw_name = xstrdup((char const   *)pw->pw_name);
#line 383
    copy->pw_passwd = xstrdup((char const   *)pw->pw_passwd);
#line 384
    copy->pw_uid = pw->pw_uid;
#line 385
    copy->pw_gid = pw->pw_gid;
#line 386
    copy->pw_dir = xstrdup((char const   *)pw->pw_dir);
#line 387
    copy->pw_shell = xstrdup((char const   *)pw->pw_shell);
#line 388
    authctxt->valid = 1;
  } else {
#line 390
    if (0) {
#line 390
      __s1_len = strlen((char const   *)u);
#line 390
      __s2_len = strlen((char const   *)authctxt->user);
#line 390
      if (! ((unsigned int )((void const   *)(u + 1)) - (unsigned int )((void const   *)u) == 1U)) {
        goto _L___0;
      } else {
#line 390
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 390
          if (! ((unsigned int )((void const   *)(authctxt->user + 1)) - (unsigned int )((void const   *)authctxt->user) == 1U)) {
#line 390
            tmp___10 = 1;
          } else {
#line 390
            if (__s2_len >= 4U) {
#line 390
              tmp___10 = 1;
            } else {
#line 390
              tmp___10 = 0;
            }
          }
        } else {
#line 390
          tmp___10 = 0;
        }
      }
#line 390
      if (tmp___10) {
#line 390
        tmp___6 = __builtin_strcmp((char const   *)u, (char const   *)authctxt->user);
      } else {
#line 390
        tmp___9 = __builtin_strcmp((char const   *)u, (char const   *)authctxt->user);
#line 390
        tmp___6 = tmp___9;
      }
    } else {
#line 390
      tmp___9 = __builtin_strcmp((char const   *)u, (char const   *)authctxt->user);
#line 390
      tmp___6 = tmp___9;
    }
#line 391
    if (tmp___6 != 0) {
#line 392
      log("auth_set_user: missmatch: (%s,%s)!=(%s,%s)", u, s, authctxt->user, authctxt->service);
#line 394
      return ((struct passwd *)((void *)0));
    } else {
#line 391
      if (0) {
#line 391
        __s1_len___0 = strlen((char const   *)s);
#line 391
        __s2_len___0 = strlen((char const   *)authctxt->service);
#line 391
        if (! ((unsigned int )((void const   *)(s + 1)) - (unsigned int )((void const   *)s) == 1U)) {
          goto _L___2;
        } else {
#line 391
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 391
            if (! ((unsigned int )((void const   *)(authctxt->service + 1)) - (unsigned int )((void const   *)authctxt->service) == 1U)) {
#line 391
              tmp___20 = 1;
            } else {
#line 391
              if (__s2_len___0 >= 4U) {
#line 391
                tmp___20 = 1;
              } else {
#line 391
                tmp___20 = 0;
              }
            }
          } else {
#line 391
            tmp___20 = 0;
          }
        }
#line 391
        if (tmp___20) {
#line 391
          tmp___16 = __builtin_strcmp((char const   *)s, (char const   *)authctxt->service);
        } else {
#line 391
          tmp___19 = __builtin_strcmp((char const   *)s, (char const   *)authctxt->service);
#line 391
          tmp___16 = tmp___19;
        }
      } else {
#line 391
        tmp___19 = __builtin_strcmp((char const   *)s, (char const   *)authctxt->service);
#line 391
        tmp___16 = tmp___19;
      }
#line 391
      if (tmp___16 != 0) {
#line 392
        log("auth_set_user: missmatch: (%s,%s)!=(%s,%s)", u, s, authctxt->user, authctxt->service);
#line 394
        return ((struct passwd *)((void *)0));
      }
    }
  }
#line 397
  tmp___21 = auth_get_user();
#line 397
  return (tmp___21);
}
}
#line 445 "auth2.c"
static char const   *check[3]  = {      "",      ".ssh",      (char const   *)((void *)0)};
#line 401 "auth2.c"
int user_dsa_key_allowed(struct passwd *pw , Key *key ) 
{ char line[8192] ;
  char file[1024] ;
  int found_key ;
  unsigned int bits ;
  FILE *f ;
  unsigned long linenum ;
  struct stat st ;
  Key *found ;
  int tmp ;
  int fail ;
  char buf___1[1024] ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *cp ;
  int tmp___3 ;
  char *tmp___4 ;

  {
#line 405
  found_key = 0;
#line 406
  bits = 4294967295U;
#line 408
  linenum = 0UL;
#line 413
  temporarily_use_uid(pw->pw_uid);
#line 416
  snprintf((char * __restrict  )(file), sizeof(file), (char const   * __restrict  )"%.500s/%.100s",
           pw->pw_dir, ".ssh/authorized_keys2");
#line 420
  tmp = stat((char const   * __restrict  )(file), (struct stat * __restrict  )(& st));
#line 420
  if (tmp < 0) {
#line 422
    restore_uid();
#line 423
    return (0);
  }
#line 426
  f = fopen((char const   * __restrict  )(file), (char const   * __restrict  )"r");
#line 427
  if (! f) {
#line 429
    restore_uid();
#line 430
    return (0);
  }
#line 432
  if (options.strict_modes) {
#line 433
    fail = 0;
#line 436
    tmp___1 = fileno(f);
#line 436
    tmp___2 = fstat(tmp___1, & st);
#line 436
    if (tmp___2 < 0) {
#line 439
      snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"DSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
               pw->pw_name, file);
#line 441
      fail = 1;
    } else {
#line 436
      if (st.st_uid != 0U) {
#line 436
        if (st.st_uid != pw->pw_uid) {
#line 439
          snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"DSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   pw->pw_name, file);
#line 441
          fail = 1;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 436
        if ((st.st_mode & 18U) != 0U) {
#line 439
          snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"DSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   pw->pw_name, file);
#line 441
          fail = 1;
        } else {
#line 448
          i = 0;
#line 448
          while (check[i]) {
#line 449
            snprintf((char * __restrict  )(line), sizeof(line), (char const   * __restrict  )"%.500s/%.100s",
                     pw->pw_dir, check[i]);
#line 451
            tmp___0 = stat((char const   * __restrict  )(line), (struct stat * __restrict  )(& st));
#line 451
            if (tmp___0 < 0) {
#line 454
              snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"DSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                       pw->pw_name, line);
#line 458
              fail = 1;
#line 459
              break;
            } else {
#line 451
              if (st.st_uid != 0U) {
#line 451
                if (st.st_uid != pw->pw_uid) {
#line 454
                  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"DSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           pw->pw_name, line);
#line 458
                  fail = 1;
#line 459
                  break;
                } else {
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
#line 451
                if ((st.st_mode & 18U) != 0U) {
#line 454
                  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"DSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           pw->pw_name, line);
#line 458
                  fail = 1;
#line 459
                  break;
                }
              }
            }
#line 448
            i ++;
          }
        }
      }
    }
#line 463
    if (fail) {
#line 464
      log((char const   *)(buf___1));
#line 465
      fclose(f);
#line 466
      restore_uid();
#line 467
      return (0);
    }
  }
#line 470
  found_key = 0;
#line 471
  found = key_new(1);
#line 473
  while (1) {
#line 473
    tmp___4 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 473
    if (! tmp___4) {
#line 473
      break;
    }
#line 475
    linenum ++;
#line 477
    cp = line;
#line 477
    while (1) {
#line 477
      if (! ((int )*cp == 32)) {
#line 477
        if (! ((int )*cp == 9)) {
#line 477
          break;
        }
      }
#line 477
      cp ++;
    }
#line 479
    if (! *cp) {
#line 480
      continue;
    } else {
#line 479
      if ((int )*cp == 10) {
#line 480
        continue;
      } else {
#line 479
        if ((int )*cp == 35) {
#line 480
          continue;
        }
      }
    }
#line 481
    bits = key_read(found, & cp);
#line 482
    if (bits == 0U) {
#line 483
      continue;
    }
#line 484
    tmp___3 = key_equal(found, key);
#line 484
    if (tmp___3) {
#line 485
      found_key = 1;
#line 486
      debug("matching key found: file %s, line %ld", file, linenum);
#line 488
      break;
    }
  }
#line 491
  restore_uid();
#line 492
  fclose(f);
#line 493
  key_free(found);
#line 494
  return (found_key);
}
}
#line 1 "auth-rhosts.o"
#pragma merger(0,"./auth-rhosts.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 418 "/usr/include/netdb.h"
extern int innetgr(char const   *__netgroup , char const   *__host , char const   *__user ,
                   char const   *domain ) ;
#line 33 "auth-rhosts.c"
int check_rhosts_file(char const   *filename , char const   *hostname , char const   *ipaddr ,
                      char const   *client_user , char const   *server_user ) 
{ FILE *f ;
  char buf___1[1024] ;
  char hostbuf[1024] ;
  char userbuf[1024] ;
  char dummy[1024] ;
  char *host ;
  char *user ;
  char *cp ;
  int negated ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___45 ;
  int tmp___48 ;
  int tmp___49 ;
  char *tmp___50 ;

  {
#line 42
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 43
  if (! f) {
#line 44
    return (0);
  }
#line 46
  while (1) {
#line 46
    tmp___50 = fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )f);
#line 46
    if (! tmp___50) {
#line 46
      break;
    }
#line 51
    cp = buf___1;
#line 51
    while (1) {
#line 51
      if (! ((int )*cp == 32)) {
#line 51
        if (! ((int )*cp == 9)) {
#line 51
          break;
        }
      }
#line 51
      cp ++;
    }
#line 53
    if ((int )*cp == 35) {
#line 54
      continue;
    } else {
#line 53
      if ((int )*cp == 10) {
#line 54
        continue;
      } else {
#line 53
        if (! *cp) {
#line 54
          continue;
        }
      }
    }
#line 60
    if (0) {
#line 60
      if (0) {
#line 60
        __s1_len___0 = strlen((char const   *)cp);
#line 60
        __s2_len___0 = strlen("NO_PLUS");
#line 60
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___2;
        } else {
#line 60
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 60
            if (! ((unsigned int )((void const   *)("NO_PLUS" + 1)) - (unsigned int )((void const   *)"NO_PLUS") == 1U)) {
#line 60
              tmp___22 = 1;
            } else {
#line 60
              if (__s2_len___0 >= 4U) {
#line 60
                tmp___22 = 1;
              } else {
#line 60
                tmp___22 = 0;
              }
            }
          } else {
#line 60
            tmp___22 = 0;
          }
        }
#line 60
        if (tmp___22) {
#line 60
          tmp___18 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
        } else {
#line 60
          tmp___21 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 60
          tmp___18 = tmp___21;
        }
      } else {
#line 60
        tmp___21 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 60
        tmp___18 = tmp___21;
      }
#line 60
      tmp___12 = tmp___18;
    } else {
#line 60
      tmp___12 = strncmp((char const   *)cp, "NO_PLUS", 7U);
    }
#line 60
    if (tmp___12 == 0) {
#line 61
      continue;
    }
#line 67
    tmp___25 = sscanf((char const   * __restrict  )(buf___1), (char const   * __restrict  )"%s %s %s",
                      hostbuf, userbuf, dummy);
#line 67
    switch (tmp___25) {
    case 0: 
#line 69
    packet_send_debug("Found empty line in %.100s.", filename);
#line 70
    continue;
    case 1: 
#line 73
    strlcpy(userbuf, server_user, sizeof(userbuf));
#line 74
    break;
    case 2: 
#line 77
    break;
    case 3: 
#line 79
    packet_send_debug("Found garbage in %.100s.", filename);
#line 80
    continue;
    default: ;
#line 83
    continue;
    }
#line 86
    host = hostbuf;
#line 87
    user = userbuf;
#line 88
    negated = 0;
#line 91
    if ((int )*(host + 0) == 45) {
#line 92
      negated = 1;
#line 93
      host ++;
    } else {
#line 94
      if ((int )*(host + 0) == 43) {
#line 95
        host ++;
      }
    }
#line 97
    if ((int )*(user + 0) == 45) {
#line 98
      negated = 1;
#line 99
      user ++;
    } else {
#line 100
      if ((int )*(user + 0) == 43) {
#line 101
        user ++;
      }
    }
#line 104
    if (! *(host + 0)) {
#line 106
      packet_send_debug("Ignoring wild host/user names in %.100s.", filename);
#line 108
      continue;
    } else {
#line 104
      if (! *(user + 0)) {
#line 106
        packet_send_debug("Ignoring wild host/user names in %.100s.", filename);
#line 108
        continue;
      }
    }
#line 111
    if ((int )*(host + 0) == 64) {
#line 112
      tmp___26 = innetgr((char const   *)(host + 1), hostname, (char const   *)((void *)0),
                         (char const   *)((void *)0));
#line 112
      if (! tmp___26) {
#line 112
        tmp___27 = innetgr((char const   *)(host + 1), ipaddr, (char const   *)((void *)0),
                           (char const   *)((void *)0));
#line 112
        if (! tmp___27) {
#line 114
          continue;
        }
      }
    } else {
#line 115
      tmp___28 = strcasecmp((char const   *)host, hostname);
#line 115
      if (tmp___28) {
#line 115
        if (0) {
#line 115
          __s1_len___1 = strlen((char const   *)host);
#line 115
          __s2_len___1 = strlen(ipaddr);
#line 115
          if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
            goto _L___4;
          } else {
#line 115
            if (__s1_len___1 >= 4U) {
              _L___4: /* CIL Label */ 
#line 115
              if (! ((unsigned int )((void const   *)(ipaddr + 1)) - (unsigned int )((void const   *)ipaddr) == 1U)) {
#line 115
                tmp___38 = 1;
              } else {
#line 115
                if (__s2_len___1 >= 4U) {
#line 115
                  tmp___38 = 1;
                } else {
#line 115
                  tmp___38 = 0;
                }
              }
            } else {
#line 115
              tmp___38 = 0;
            }
          }
#line 115
          if (tmp___38) {
#line 115
            tmp___34 = __builtin_strcmp((char const   *)host, ipaddr);
          } else {
#line 115
            tmp___37 = __builtin_strcmp((char const   *)host, ipaddr);
#line 115
            tmp___34 = tmp___37;
          }
        } else {
#line 115
          tmp___37 = __builtin_strcmp((char const   *)host, ipaddr);
#line 115
          tmp___34 = tmp___37;
        }
#line 115
        if (tmp___34 != 0) {
#line 116
          continue;
        }
      }
    }
#line 119
    if ((int )*(user + 0) == 64) {
#line 120
      tmp___39 = innetgr((char const   *)(user + 1), (char const   *)((void *)0),
                         client_user, (char const   *)((void *)0));
#line 120
      if (! tmp___39) {
#line 121
        continue;
      }
    } else {
#line 122
      if (0) {
#line 122
        __s1_len___2 = strlen((char const   *)user);
#line 122
        __s2_len___2 = strlen(client_user);
#line 122
        if (! ((unsigned int )((void const   *)(user + 1)) - (unsigned int )((void const   *)user) == 1U)) {
          goto _L___6;
        } else {
#line 122
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 122
            if (! ((unsigned int )((void const   *)(client_user + 1)) - (unsigned int )((void const   *)client_user) == 1U)) {
#line 122
              tmp___49 = 1;
            } else {
#line 122
              if (__s2_len___2 >= 4U) {
#line 122
                tmp___49 = 1;
              } else {
#line 122
                tmp___49 = 0;
              }
            }
          } else {
#line 122
            tmp___49 = 0;
          }
        }
#line 122
        if (tmp___49) {
#line 122
          tmp___45 = __builtin_strcmp((char const   *)user, client_user);
        } else {
#line 122
          tmp___48 = __builtin_strcmp((char const   *)user, client_user);
#line 122
          tmp___45 = tmp___48;
        }
      } else {
#line 122
        tmp___48 = __builtin_strcmp((char const   *)user, client_user);
#line 122
        tmp___45 = tmp___48;
      }
#line 122
      if (tmp___45 != 0) {
#line 123
        continue;
      }
    }
#line 126
    fclose(f);
#line 129
    if (negated) {
#line 130
      packet_send_debug("Matched negative entry in %.100s.", filename);
#line 132
      return (0);
    }
#line 135
    return (1);
  }
#line 139
  fclose(f);
#line 140
  return (0);
}
}
#line 156 "auth-rhosts.c"
static char const   *rhosts_files[3]  = {      ".shosts",      ".rhosts",      (char const   *)((void *)0)};
#line 149 "auth-rhosts.c"
int auth_rhosts(struct passwd *pw , char const   *client_user ) 
{ char buf___1[1024] ;
  char const   *hostname ;
  char const   *ipaddr ;
  struct stat st ;
  unsigned int rhosts_file_index ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 160
  temporarily_use_uid(pw->pw_uid);
#line 166
  rhosts_file_index = 0U;
#line 166
  while (rhosts_files[rhosts_file_index]) {
#line 169
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.500s/%.100s",
             pw->pw_dir, rhosts_files[rhosts_file_index]);
#line 171
    tmp = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )(& st));
#line 171
    if (tmp >= 0) {
#line 172
      break;
    }
#line 166
    rhosts_file_index ++;
  }
#line 175
  restore_uid();
#line 178
  if (! rhosts_files[rhosts_file_index]) {
#line 178
    tmp___0 = stat((char const   * __restrict  )"/etc/hosts.equiv", (struct stat * __restrict  )(& st));
#line 178
    if (tmp___0 < 0) {
#line 178
      tmp___1 = stat((char const   * __restrict  )"/usr/local/etc/shosts.equiv", (struct stat * __restrict  )(& st));
#line 178
      if (tmp___1 < 0) {
#line 181
        return (0);
      }
    }
  }
#line 183
  hostname = get_canonical_hostname();
#line 184
  ipaddr = get_remote_ipaddr();
#line 187
  if (pw->pw_uid != 0U) {
#line 188
    tmp___2 = check_rhosts_file("/etc/hosts.equiv", hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 188
    if (tmp___2) {
#line 190
      packet_send_debug("Accepted for %.100s [%.100s] by /etc/hosts.equiv.", hostname,
                        ipaddr);
#line 192
      return (1);
    }
#line 194
    tmp___3 = check_rhosts_file("/usr/local/etc/shosts.equiv", hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 194
    if (tmp___3) {
#line 196
      packet_send_debug("Accepted for %.100s [%.100s] by %.100s.", hostname, ipaddr,
                        "/usr/local/etc/shosts.equiv");
#line 198
      return (1);
    }
  }
#line 205
  tmp___4 = stat((char const   * __restrict  )pw->pw_dir, (struct stat * __restrict  )(& st));
#line 205
  if (tmp___4 < 0) {
#line 206
    log("Rhosts authentication refused for %.100s: no home directory %.200s", pw->pw_name,
        pw->pw_dir);
#line 208
    packet_send_debug("Rhosts authentication refused for %.100s: no home directory %.200s",
                      pw->pw_name, pw->pw_dir);
#line 210
    return (0);
  }
#line 212
  if (options.strict_modes) {
#line 212
    if (st.st_uid != 0U) {
#line 212
      if (st.st_uid != pw->pw_uid) {
#line 215
        log("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
            pw->pw_name);
#line 217
        packet_send_debug("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                          pw->pw_name);
#line 219
        return (0);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 212
      if ((st.st_mode & 18U) != 0U) {
#line 215
        log("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
            pw->pw_name);
#line 217
        packet_send_debug("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                          pw->pw_name);
#line 219
        return (0);
      }
    }
  }
#line 222
  temporarily_use_uid(pw->pw_uid);
#line 225
  rhosts_file_index = 0U;
#line 225
  while (rhosts_files[rhosts_file_index]) {
#line 228
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.500s/%.100s",
             pw->pw_dir, rhosts_files[rhosts_file_index]);
#line 230
    tmp___5 = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )(& st));
#line 230
    if (tmp___5 < 0) {
      goto __Cont;
    }
#line 239
    if (options.strict_modes) {
#line 239
      if (st.st_uid != 0U) {
#line 239
        if (st.st_uid != pw->pw_uid) {
#line 242
          log("Rhosts authentication refused for %.100s: bad modes for %.200s", pw->pw_name,
              buf___1);
#line 244
          packet_send_debug("Bad file modes for %.200s", buf___1);
          goto __Cont;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 239
        if ((st.st_mode & 18U) != 0U) {
#line 242
          log("Rhosts authentication refused for %.100s: bad modes for %.200s", pw->pw_name,
              buf___1);
#line 244
          packet_send_debug("Bad file modes for %.200s", buf___1);
          goto __Cont;
        }
      }
    }
#line 248
    if (options.ignore_rhosts) {
#line 249
      packet_send_debug("Server has been configured to ignore %.100s.", rhosts_files[rhosts_file_index]);
      goto __Cont;
    }
#line 254
    tmp___6 = check_rhosts_file((char const   *)(buf___1), hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 254
    if (tmp___6) {
#line 255
      packet_send_debug("Accepted by %.100s.", rhosts_files[rhosts_file_index]);
#line 258
      restore_uid();
#line 259
      return (1);
    }
    __Cont: /* CIL Label */ 
#line 225
    rhosts_file_index ++;
  }
#line 264
  restore_uid();
#line 265
  return (0);
}
}
#line 1 "auth-krb4.o"
#pragma merger(0,"./auth-krb4.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "auth-pam.o"
#pragma merger(0,"./auth-pam.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 167 "/usr/include/security/_pam_types.h"
extern int __attribute__((__nonnull__(1)))  pam_set_item(pam_handle_t *pamh , int item_type ,
                                                         void const   *item ) ;
#line 173
extern char const   *pam_strerror(pam_handle_t *pamh , int errnum ) ;
#line 182
extern char ** __attribute__((__nonnull__(1))) pam_getenvlist(pam_handle_t *pamh ) ;
#line 22 "/usr/include/security/pam_appl.h"
extern int __attribute__((__nonnull__(1,3,4)))  pam_start(char const   *service_name ,
                                                          char const   *user , struct pam_conv  const  *pam_conversation ,
                                                          pam_handle_t **pamh ) ;
#line 27
extern int __attribute__((__nonnull__(1)))  pam_end(pam_handle_t *pamh , int pam_status ) ;
#line 32
extern int __attribute__((__nonnull__(1)))  pam_authenticate(pam_handle_t *pamh ,
                                                             int flags ) ;
#line 35
extern int __attribute__((__nonnull__(1)))  pam_setcred(pam_handle_t *pamh , int flags ) ;
#line 40
extern int __attribute__((__nonnull__(1)))  pam_acct_mgmt(pam_handle_t *pamh , int flags ) ;
#line 45
extern int __attribute__((__nonnull__(1)))  pam_open_session(pam_handle_t *pamh ,
                                                             int flags ) ;
#line 48
extern int __attribute__((__nonnull__(1)))  pam_close_session(pam_handle_t *pamh ,
                                                              int flags ) ;
#line 9 "auth-pam.h"
char **fetch_pam_environment(void) ;
#line 11
void do_pam_session(char *username , char const   *ttyname___0 ) ;
#line 12
void do_pam_setcred(void) ;
#line 13
void print_pam_messages(void) ;
#line 19 "auth-pam.c"
static int pamconv(int num_msg , struct pam_message  const  **msg , struct pam_response **resp ,
                   void *appdata_ptr ) ;
#line 21
void pam_cleanup_proc(void *context ) ;
#line 24 "auth-pam.c"
static struct pam_conv conv  =    {& pamconv, (void *)0};
#line 28 "auth-pam.c"
static struct pam_handle_t *pamh  =    (struct pam_handle_t *)((void *)0);
#line 29 "auth-pam.c"
static char const   *pampasswd  =    (char const   *)((void *)0);
#line 30 "auth-pam.c"
static char *pamconv_msg  =    (char *)((void *)0);
#line 34 "auth-pam.c"
static int pamconv(int num_msg , struct pam_message  const  **msg , struct pam_response **resp ,
                   void *appdata_ptr ) 
{ struct pam_response *reply ;
  int count ;
  size_t msg_len ;
  char *p ;
  void *tmp ;
  size_t n___0 ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 43
  tmp = malloc((unsigned int )num_msg * sizeof(*reply));
#line 43
  reply = (struct pam_response *)tmp;
#line 44
  if ((unsigned int )reply == (unsigned int )((void *)0)) {
#line 45
    return (19);
  }
#line 47
  count = 0;
#line 47
  while (count < num_msg) {
#line 48
    switch ((int )(*(msg + count))->msg_style) {
    case 1: 
#line 50
    if ((unsigned int )pampasswd == (unsigned int )((void *)0)) {
#line 51
      free((void *)reply);
#line 52
      return (19);
    }
#line 54
    (reply + count)->resp_retcode = 0;
#line 55
    (reply + count)->resp = xstrdup(pampasswd);
#line 56
    break;
    case 4: 
#line 59
    (reply + count)->resp_retcode = 0;
#line 60
    (reply + count)->resp = xstrdup("");
#line 62
    if ((unsigned int )(*(msg + count))->msg == (unsigned int )((void *)0)) {
#line 63
      break;
    }
#line 65
    debug("Adding PAM message: %s", (*(msg + count))->msg);
#line 67
    msg_len = strlen((char const   *)(*(msg + count))->msg);
#line 68
    if (pamconv_msg) {
#line 69
      tmp___0 = strlen((char const   *)pamconv_msg);
#line 69
      n___0 = tmp___0;
#line 70
      tmp___1 = xrealloc((void *)pamconv_msg, (n___0 + msg_len) + 2U);
#line 70
      pamconv_msg = (char *)tmp___1;
#line 71
      p = pamconv_msg + n___0;
    } else {
#line 73
      tmp___2 = xmalloc(msg_len + 2U);
#line 73
      p = (char *)tmp___2;
#line 73
      pamconv_msg = p;
    }
#line 75
    memcpy((void * __restrict  )p, (void const   * __restrict  )(*(msg + count))->msg,
           msg_len);
#line 76
    *(p + msg_len) = (char )'\n';
#line 77
    *(p + (msg_len + 1U)) = (char )'\000';
#line 78
    break;
    case 2: 
    case 3: 
    default: 
#line 83
    free((void *)reply);
#line 84
    return (19);
    }
#line 47
    count ++;
  }
#line 88
  *resp = reply;
#line 90
  return (0);
}
}
#line 94 "auth-pam.c"
void pam_cleanup_proc(void *context ) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1)))  tmp ;
  char const   *tmp___0 ;
  int __attribute__((__nonnull__(1)))  tmp___1 ;
  char const   *tmp___2 ;
  int __attribute__((__nonnull__(1)))  tmp___3 ;
  char const   *tmp___4 ;

  {
#line 98
  if ((unsigned int )pamh != (unsigned int )((void *)0)) {
#line 100
    tmp = pam_close_session((pam_handle_t *)pamh, 0);
#line 100
    pam_retval = (int )tmp;
#line 101
    if (pam_retval != 0) {
#line 102
      tmp___0 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 102
      log("Cannot close PAM session: %.200s", tmp___0);
    }
#line 106
    tmp___1 = pam_setcred((pam_handle_t *)pamh, 4);
#line 106
    pam_retval = (int )tmp___1;
#line 107
    if (pam_retval != 0) {
#line 108
      tmp___2 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 108
      log("Cannot delete credentials: %.200s", tmp___2);
    }
#line 112
    tmp___3 = pam_end((pam_handle_t *)pamh, pam_retval);
#line 112
    pam_retval = (int )tmp___3;
#line 113
    if (pam_retval != 0) {
#line 114
      tmp___4 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 114
      log("Cannot release PAM authentication: %.200s", tmp___4);
    }
  }
#line 118
  return;
}
}
#line 121 "auth-pam.c"
int auth_pam_password(struct passwd *pw , char const   *password ) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1)))  tmp ;
  char const   *tmp___0 ;

  {
#line 127
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 128
    return (0);
  }
#line 129
  if (pw->pw_uid == 0U) {
#line 129
    if (options.permit_root_login == 2) {
#line 130
      return (0);
    }
  }
#line 131
  if ((int const   )*password == 0) {
#line 131
    if (options.permit_empty_passwd == 0) {
#line 132
      return (0);
    }
  }
#line 134
  pampasswd = password;
#line 136
  tmp = pam_authenticate((pam_handle_t *)pamh, 0);
#line 136
  pam_retval = (int )tmp;
#line 137
  if (pam_retval == 0) {
#line 138
    debug("PAM Password authentication accepted for user \"%.100s\"", pw->pw_name);
#line 139
    return (1);
  } else {
#line 141
    tmp___0 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 141
    debug("PAM Password authentication for \"%.100s\" failed: %s", pw->pw_name, tmp___0);
#line 143
    return (0);
  }
}
}
#line 148 "auth-pam.c"
int do_pam_account(char *username , char *remote_user ) 
{ int pam_retval ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int __attribute__((__nonnull__(1)))  tmp___1 ;
  char const   *tmp___2 ;
  int __attribute__((__nonnull__(1)))  tmp___3 ;
  char const   *tmp___4 ;
  int __attribute__((__nonnull__(1)))  tmp___5 ;
  char const   *tmp___6 ;

  {
#line 152
  tmp = get_canonical_hostname();
#line 152
  debug("PAM setting rhost to \"%.200s\"", tmp);
#line 153
  tmp___0 = get_canonical_hostname();
#line 153
  tmp___1 = pam_set_item((pam_handle_t *)pamh, 4, (void const   *)tmp___0);
#line 153
  pam_retval = (int )tmp___1;
#line 155
  if (pam_retval != 0) {
#line 156
    tmp___2 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 156
    fatal("PAM set rhost failed: %.200s", tmp___2);
  }
#line 159
  if ((unsigned int )remote_user != (unsigned int )((void *)0)) {
#line 160
    debug("PAM setting ruser to \"%.200s\"", remote_user);
#line 161
    tmp___3 = pam_set_item((pam_handle_t *)pamh, 8, (void const   *)remote_user);
#line 161
    pam_retval = (int )tmp___3;
#line 162
    if (pam_retval != 0) {
#line 163
      tmp___4 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 163
      fatal("PAM set ruser failed: %.200s", tmp___4);
    }
  }
#line 167
  tmp___5 = pam_acct_mgmt((pam_handle_t *)pamh, 0);
#line 167
  pam_retval = (int )tmp___5;
#line 168
  if (pam_retval != 0) {
#line 169
    tmp___6 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 169
    log("PAM rejected by account configuration: %.200s", tmp___6);
#line 170
    return (0);
  }
#line 173
  return (1);
}
}
#line 177 "auth-pam.c"
void do_pam_session(char *username , char const   *ttyname___0 ) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1)))  tmp ;
  char const   *tmp___0 ;
  int __attribute__((__nonnull__(1)))  tmp___1 ;
  char const   *tmp___2 ;

  {
#line 181
  if ((unsigned int )ttyname___0 != (unsigned int )((void *)0)) {
#line 182
    debug("PAM setting tty to \"%.200s\"", ttyname___0);
#line 183
    tmp = pam_set_item((pam_handle_t *)pamh, 3, (void const   *)ttyname___0);
#line 183
    pam_retval = (int )tmp;
#line 184
    if (pam_retval != 0) {
#line 185
      tmp___0 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 185
      fatal("PAM set tty failed: %.200s", tmp___0);
    }
  }
#line 188
  tmp___1 = pam_open_session((pam_handle_t *)pamh, 0);
#line 188
  pam_retval = (int )tmp___1;
#line 189
  if (pam_retval != 0) {
#line 190
    tmp___2 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 190
    fatal("PAM session setup failed: %.200s", tmp___2);
  }
#line 191
  return;
}
}
#line 194 "auth-pam.c"
void do_pam_setcred(void) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1)))  tmp ;
  char const   *tmp___0 ;

  {
#line 198
  debug("PAM establishing creds");
#line 199
  tmp = pam_setcred((pam_handle_t *)pamh, 2);
#line 199
  pam_retval = (int )tmp;
#line 200
  if (pam_retval != 0) {
#line 201
    tmp___0 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 201
    fatal("PAM setcred failed: %.200s", tmp___0);
  }
#line 202
  return;
}
}
#line 205 "auth-pam.c"
void finish_pam(void) 
{ 

  {
#line 207
  pam_cleanup_proc((void *)0);
#line 208
  fatal_remove_cleanup(& pam_cleanup_proc, (void *)0);
#line 209
  return;
}
}
#line 212 "auth-pam.c"
void start_pam(struct passwd *pw ) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1,3,4)))  tmp ;
  char const   *tmp___0 ;

  {
#line 216
  debug("Starting up PAM with username \"%.200s\"", pw->pw_name);
#line 218
  tmp = pam_start("sshd", (char const   *)pw->pw_name, (struct pam_conv  const  *)(& conv),
                  (pam_handle_t **)(& pamh));
#line 218
  pam_retval = (int )tmp;
#line 220
  if (pam_retval != 0) {
#line 221
    tmp___0 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 221
    fatal("PAM initialisation failed: %.200s", tmp___0);
  }
#line 223
  fatal_add_cleanup(& pam_cleanup_proc, (void *)0);
#line 224
  return;
}
}
#line 227 "auth-pam.c"
char **fetch_pam_environment(void) 
{ char ** __attribute__((__nonnull__(1))) tmp ;

  {
#line 230
  tmp = pam_getenvlist((pam_handle_t *)pamh);
#line 230
  return ((char **)tmp);
}
}
#line 238 "auth-pam.c"
void print_pam_messages(void) 
{ 

  {
#line 240
  if ((unsigned int )pamconv_msg != (unsigned int )((void *)0)) {
#line 241
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )pamconv_msg);
  }
#line 242
  return;
}
}
#line 1 "auth-passwd.o"
#pragma merger(0,"./auth-passwd.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "auth-rsa.o"
#pragma merger(0,"./auth-rsa.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 212
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 401 "/usr/include/openssl/bn.h"
extern int BN_rand(BIGNUM *rnd , int bits , int top , int bottom ) ;
#line 416 "ssh.h"
int auth_rsa_challenge_dialog(RSA *pk ) ;
#line 34 "auth-rsa.c"
int no_port_forwarding_flag ;
#line 35
int no_agent_forwarding_flag ;
#line 36
int no_x11_forwarding_flag ;
#line 37
int no_pty_flag ;
#line 39
struct envstring *custom_environment ;
#line 63 "auth-rsa.c"
int auth_rsa_challenge_dialog(RSA *pk ) 
{ BIGNUM *challenge ;
  BIGNUM *encrypted_challenge ;
  BN_CTX *ctx ;
  unsigned char buf___1[32] ;
  unsigned char mdbuf[16] ;
  unsigned char response[16] ;
  MD5_CTX md ;
  unsigned int i ;
  int plen ;
  int len ;
  int _p ;
  int _e ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 73
  encrypted_challenge = BN_new();
#line 74
  challenge = BN_new();
#line 77
  BN_rand(challenge, 256, 0, 0);
#line 78
  ctx = BN_CTX_new();
#line 79
  BN_div((BIGNUM *)((void *)0), challenge, (BIGNUM const   *)challenge, (BIGNUM const   *)pk->n,
         ctx);
#line 80
  BN_CTX_free(ctx);
#line 83
  rsa_public_encrypt(encrypted_challenge, challenge, pk);
#line 86
  packet_start(7);
#line 87
  packet_put_bignum(encrypted_challenge);
#line 88
  packet_send();
#line 89
  BN_clear_free(encrypted_challenge);
#line 90
  packet_write_wait();
#line 93
  packet_read_expect(& plen, 8);
#line 94
  while (1) {
#line 94
    _p = plen;
#line 94
    _e = 16;
#line 94
    if (_p != _e) {
#line 94
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "auth-rsa.c", 94);
#line 94
      packet_disconnect("Packet integrity error. (%d)", 8);
    }
#line 94
    break;
  }
#line 95
  i = 0U;
#line 95
  while (i < 16U) {
#line 96
    tmp = packet_get_char();
#line 96
    response[i] = (unsigned char )tmp;
#line 95
    i ++;
  }
#line 99
  tmp___0 = BN_num_bits((BIGNUM const   *)challenge);
#line 99
  len = (tmp___0 + 7) / 8;
#line 100
  if (len <= 0) {
#line 101
    fatal("auth_rsa_challenge_dialog: bad challenge length %d", len);
  } else {
#line 100
    if (len > 32) {
#line 101
      fatal("auth_rsa_challenge_dialog: bad challenge length %d", len);
    }
  }
#line 102
  memset((void *)(buf___1), 0, 32U);
#line 103
  BN_bn2bin((BIGNUM const   *)challenge, (buf___1 + 32) - len);
#line 104
  MD5_Init(& md);
#line 105
  MD5_Update(& md, (void const   *)(buf___1), 32U);
#line 106
  MD5_Update(& md, (void const   *)(session_id), 16U);
#line 107
  MD5_Final(mdbuf, & md);
#line 108
  BN_clear_free(challenge);
#line 111
  tmp___1 = memcmp((void const   *)(response), (void const   *)(mdbuf), 16U);
#line 111
  if (tmp___1 != 0) {
#line 113
    return (0);
  }
#line 116
  return (1);
}
}
#line 172 "auth-rsa.c"
static char const   *check___0[3]  = {      "",      ".ssh",      (char const   *)((void *)0)};
#line 125 "auth-rsa.c"
int auth_rsa(struct passwd *pw , BIGNUM *client_n ) 
{ char line[8192] ;
  char file[1024] ;
  int authenticated ;
  unsigned int bits ;
  FILE *f ;
  unsigned long linenum ;
  struct stat st ;
  RSA *pk ;
  int tmp ;
  int fail ;
  char buf___1[1024] ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *cp ;
  char *options___0 ;
  int quoted ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___26 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___32 ;
  int tmp___35 ;
  int tmp___36 ;
  size_t tmp___37 ;
  size_t tmp___43 ;
  int tmp___61 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___67 ;
  int tmp___70 ;
  int tmp___71 ;
  size_t tmp___72 ;
  size_t tmp___78 ;
  int tmp___96 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___102 ;
  int tmp___105 ;
  int tmp___106 ;
  size_t tmp___107 ;
  size_t tmp___113 ;
  int tmp___131 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___137 ;
  int tmp___140 ;
  int tmp___141 ;
  size_t tmp___142 ;
  int i___0 ;
  size_t tmp___148 ;
  size_t tmp___149 ;
  void *tmp___150 ;
  int tmp___151 ;
  int tmp___152 ;
  char *tmp___153 ;
  int tmp___171 ;
  size_t __s1_len___8 ;
  size_t __s2_len___8 ;
  int tmp___177 ;
  int tmp___180 ;
  int tmp___181 ;
  size_t tmp___182 ;
  int i___1 ;
  char *s ;
  struct envstring *new_envstring ;
  size_t tmp___188 ;
  size_t tmp___189 ;
  void *tmp___190 ;
  int tmp___191 ;
  int tmp___192 ;
  char *tmp___193 ;
  void *tmp___194 ;
  int tmp___212 ;
  size_t __s1_len___10 ;
  size_t __s2_len___10 ;
  int tmp___218 ;
  int tmp___221 ;
  int tmp___222 ;
  size_t tmp___223 ;
  char *patterns ;
  size_t tmp___229 ;
  void *tmp___230 ;
  int i___2 ;
  size_t tmp___231 ;
  int tmp___232 ;
  int tmp___233 ;
  char *tmp___234 ;
  char const   *tmp___235 ;
  char const   *tmp___236 ;
  char const   *tmp___237 ;
  struct envstring *ce ;
  size_t tmp___238 ;
  char const   *tmp___239 ;
  int tmp___240 ;
  size_t tmp___241 ;
  char const   *tmp___242 ;
  int tmp___243 ;
  int tmp___261 ;
  size_t __s1_len___12 ;
  size_t __s2_len___12 ;
  int tmp___267 ;
  int tmp___270 ;
  int tmp___271 ;
  size_t tmp___272 ;
  char *tmp___278 ;

  {
#line 133
  linenum = 0UL;
#line 138
  temporarily_use_uid(pw->pw_uid);
#line 141
  snprintf((char * __restrict  )(file), sizeof(file), (char const   * __restrict  )"%.500s/%.100s",
           pw->pw_dir, ".ssh/authorized_keys");
#line 145
  tmp = stat((char const   * __restrict  )(file), (struct stat * __restrict  )(& st));
#line 145
  if (tmp < 0) {
#line 147
    restore_uid();
#line 148
    return (0);
  }
#line 151
  f = fopen((char const   * __restrict  )(file), (char const   * __restrict  )"r");
#line 152
  if (! f) {
#line 154
    restore_uid();
#line 155
    packet_send_debug("Could not open %.900s for reading.", file);
#line 156
    packet_send_debug("If your home is on an NFS volume, it may need to be world-readable.");
#line 157
    return (0);
  }
#line 159
  if (options.strict_modes) {
#line 160
    fail = 0;
#line 163
    tmp___1 = fileno(f);
#line 163
    tmp___2 = fstat(tmp___1, & st);
#line 163
    if (tmp___2 < 0) {
#line 166
      snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
               pw->pw_name, file);
#line 168
      fail = 1;
    } else {
#line 163
      if (st.st_uid != 0U) {
#line 163
        if (st.st_uid != pw->pw_uid) {
#line 166
          snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   pw->pw_name, file);
#line 168
          fail = 1;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 163
        if ((st.st_mode & 18U) != 0U) {
#line 166
          snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   pw->pw_name, file);
#line 168
          fail = 1;
        } else {
#line 175
          i = 0;
#line 175
          while (check___0[i]) {
#line 176
            snprintf((char * __restrict  )(line), sizeof(line), (char const   * __restrict  )"%.500s/%.100s",
                     pw->pw_dir, check___0[i]);
#line 177
            tmp___0 = stat((char const   * __restrict  )(line), (struct stat * __restrict  )(& st));
#line 177
            if (tmp___0 < 0) {
#line 180
              snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                       pw->pw_name, line);
#line 182
              fail = 1;
#line 183
              break;
            } else {
#line 177
              if (st.st_uid != 0U) {
#line 177
                if (st.st_uid != pw->pw_uid) {
#line 180
                  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           pw->pw_name, line);
#line 182
                  fail = 1;
#line 183
                  break;
                } else {
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
#line 177
                if ((st.st_mode & 18U) != 0U) {
#line 180
                  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           pw->pw_name, line);
#line 182
                  fail = 1;
#line 183
                  break;
                }
              }
            }
#line 175
            i ++;
          }
        }
      }
    }
#line 187
    if (fail) {
#line 188
      fclose(f);
#line 189
      log((char const   *)(buf___1));
#line 190
      packet_send_debug((char const   *)(buf___1));
#line 191
      restore_uid();
#line 192
      return (0);
    }
  }
#line 196
  authenticated = 0;
#line 198
  pk = RSA_new();
#line 199
  pk->e = BN_new();
#line 200
  pk->n = BN_new();
#line 207
  while (1) {
#line 207
    tmp___278 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 207
    if (! tmp___278) {
#line 207
      break;
    }
#line 211
    linenum ++;
#line 214
    cp = line;
#line 214
    while (1) {
#line 214
      if (! ((int )*cp == 32)) {
#line 214
        if (! ((int )*cp == 9)) {
#line 214
          break;
        }
      }
#line 214
      cp ++;
    }
#line 216
    if (! *cp) {
#line 217
      continue;
    } else {
#line 216
      if ((int )*cp == 10) {
#line 217
        continue;
      } else {
#line 216
        if ((int )*cp == 35) {
#line 217
          continue;
        }
      }
    }
#line 225
    if ((int )*cp < 48) {
      goto _L___2;
    } else {
#line 225
      if ((int )*cp > 57) {
        _L___2: /* CIL Label */ 
#line 226
        quoted = 0;
#line 227
        options___0 = cp;
#line 228
        while (1) {
#line 228
          if (*cp) {
#line 228
            if (! quoted) {
#line 228
              if ((int )*cp != 32) {
#line 228
                if (! ((int )*cp != 9)) {
#line 228
                  break;
                }
              } else {
#line 228
                break;
              }
            }
          } else {
#line 228
            break;
          }
#line 229
          if ((int )*cp == 92) {
#line 229
            if ((int )*(cp + 1) == 34) {
#line 230
              cp ++;
            } else {
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
#line 231
            if ((int )*cp == 34) {
#line 232
              quoted = ! quoted;
            }
          }
#line 228
          cp ++;
        }
      } else {
#line 235
        options___0 = (char *)((void *)0);
      }
    }
#line 238
    tmp___3 = auth_rsa_read_key(& cp, & bits, pk->e, pk->n);
#line 238
    if (! tmp___3) {
#line 239
      debug("%.100s, line %lu: bad key syntax", ".ssh/authorized_keys", linenum);
#line 241
      packet_send_debug("%.100s, line %lu: bad key syntax", ".ssh/authorized_keys",
                        linenum);
#line 243
      continue;
    }
#line 248
    tmp___4 = BN_cmp((BIGNUM const   *)pk->n, (BIGNUM const   *)client_n);
#line 248
    if (tmp___4 != 0) {
#line 249
      continue;
    }
#line 252
    tmp___6 = BN_num_bits((BIGNUM const   *)pk->n);
#line 252
    if (bits != (unsigned int )tmp___6) {
#line 253
      tmp___5 = BN_num_bits((BIGNUM const   *)pk->n);
#line 253
      log("Warning: %s, line %ld: keysize mismatch: actual %d vs. announced %d.",
          file, linenum, tmp___5, bits);
    }
#line 260
    tmp___7 = auth_rsa_challenge_dialog(pk);
#line 260
    if (! tmp___7) {
#line 262
      verbose("Wrong response to RSA authentication challenge.");
#line 263
      packet_send_debug("Wrong response to RSA authentication challenge.");
#line 264
      continue;
    }
#line 272
    authenticated = 1;
#line 275
    if (options___0) {
#line 276
      while (1) {
#line 276
        if (*options___0) {
#line 276
          if ((int )*options___0 != 32) {
#line 276
            if (! ((int )*options___0 != 9)) {
#line 276
              break;
            }
          } else {
#line 276
            break;
          }
        } else {
#line 276
          break;
        }
#line 277
        cp = (char *)"no-port-forwarding";
#line 278
        if (0) {
#line 278
          if (0) {
#line 278
            __s1_len___0 = strlen((char const   *)options___0);
#line 278
            __s2_len___0 = strlen((char const   *)cp);
#line 278
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___6;
            } else {
#line 278
              if (__s1_len___0 >= 4U) {
                _L___6: /* CIL Label */ 
#line 278
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 278
                  tmp___36 = 1;
                } else {
#line 278
                  if (__s2_len___0 >= 4U) {
#line 278
                    tmp___36 = 1;
                  } else {
#line 278
                    tmp___36 = 0;
                  }
                }
              } else {
#line 278
                tmp___36 = 0;
              }
            }
#line 278
            if (tmp___36) {
#line 278
              tmp___32 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 278
              tmp___35 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 278
              tmp___32 = tmp___35;
            }
          } else {
#line 278
            tmp___35 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 278
            tmp___32 = tmp___35;
          }
#line 278
          tmp___26 = tmp___32;
        } else {
#line 278
          tmp___37 = strlen((char const   *)cp);
#line 278
          tmp___26 = strncmp((char const   *)options___0, (char const   *)cp, tmp___37);
        }
#line 278
        if (tmp___26 == 0) {
#line 279
          packet_send_debug("Port forwarding disabled.");
#line 280
          no_port_forwarding_flag = 1;
#line 281
          tmp___8 = strlen((char const   *)cp);
#line 281
          options___0 += tmp___8;
          goto next_option;
        }
#line 284
        cp = (char *)"no-agent-forwarding";
#line 285
        if (0) {
#line 285
          if (0) {
#line 285
            __s1_len___2 = strlen((char const   *)options___0);
#line 285
            __s2_len___2 = strlen((char const   *)cp);
#line 285
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___10;
            } else {
#line 285
              if (__s1_len___2 >= 4U) {
                _L___10: /* CIL Label */ 
#line 285
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 285
                  tmp___71 = 1;
                } else {
#line 285
                  if (__s2_len___2 >= 4U) {
#line 285
                    tmp___71 = 1;
                  } else {
#line 285
                    tmp___71 = 0;
                  }
                }
              } else {
#line 285
                tmp___71 = 0;
              }
            }
#line 285
            if (tmp___71) {
#line 285
              tmp___67 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 285
              tmp___70 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 285
              tmp___67 = tmp___70;
            }
          } else {
#line 285
            tmp___70 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 285
            tmp___67 = tmp___70;
          }
#line 285
          tmp___61 = tmp___67;
        } else {
#line 285
          tmp___72 = strlen((char const   *)cp);
#line 285
          tmp___61 = strncmp((char const   *)options___0, (char const   *)cp, tmp___72);
        }
#line 285
        if (tmp___61 == 0) {
#line 286
          packet_send_debug("Agent forwarding disabled.");
#line 287
          no_agent_forwarding_flag = 1;
#line 288
          tmp___43 = strlen((char const   *)cp);
#line 288
          options___0 += tmp___43;
          goto next_option;
        }
#line 291
        cp = (char *)"no-X11-forwarding";
#line 292
        if (0) {
#line 292
          if (0) {
#line 292
            __s1_len___4 = strlen((char const   *)options___0);
#line 292
            __s2_len___4 = strlen((char const   *)cp);
#line 292
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___14;
            } else {
#line 292
              if (__s1_len___4 >= 4U) {
                _L___14: /* CIL Label */ 
#line 292
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 292
                  tmp___106 = 1;
                } else {
#line 292
                  if (__s2_len___4 >= 4U) {
#line 292
                    tmp___106 = 1;
                  } else {
#line 292
                    tmp___106 = 0;
                  }
                }
              } else {
#line 292
                tmp___106 = 0;
              }
            }
#line 292
            if (tmp___106) {
#line 292
              tmp___102 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 292
              tmp___105 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 292
              tmp___102 = tmp___105;
            }
          } else {
#line 292
            tmp___105 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 292
            tmp___102 = tmp___105;
          }
#line 292
          tmp___96 = tmp___102;
        } else {
#line 292
          tmp___107 = strlen((char const   *)cp);
#line 292
          tmp___96 = strncmp((char const   *)options___0, (char const   *)cp, tmp___107);
        }
#line 292
        if (tmp___96 == 0) {
#line 293
          packet_send_debug("X11 forwarding disabled.");
#line 294
          no_x11_forwarding_flag = 1;
#line 295
          tmp___78 = strlen((char const   *)cp);
#line 295
          options___0 += tmp___78;
          goto next_option;
        }
#line 298
        cp = (char *)"no-pty";
#line 299
        if (0) {
#line 299
          if (0) {
#line 299
            __s1_len___6 = strlen((char const   *)options___0);
#line 299
            __s2_len___6 = strlen((char const   *)cp);
#line 299
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___18;
            } else {
#line 299
              if (__s1_len___6 >= 4U) {
                _L___18: /* CIL Label */ 
#line 299
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 299
                  tmp___141 = 1;
                } else {
#line 299
                  if (__s2_len___6 >= 4U) {
#line 299
                    tmp___141 = 1;
                  } else {
#line 299
                    tmp___141 = 0;
                  }
                }
              } else {
#line 299
                tmp___141 = 0;
              }
            }
#line 299
            if (tmp___141) {
#line 299
              tmp___137 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 299
              tmp___140 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 299
              tmp___137 = tmp___140;
            }
          } else {
#line 299
            tmp___140 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 299
            tmp___137 = tmp___140;
          }
#line 299
          tmp___131 = tmp___137;
        } else {
#line 299
          tmp___142 = strlen((char const   *)cp);
#line 299
          tmp___131 = strncmp((char const   *)options___0, (char const   *)cp, tmp___142);
        }
#line 299
        if (tmp___131 == 0) {
#line 300
          packet_send_debug("Pty allocation disabled.");
#line 301
          no_pty_flag = 1;
#line 302
          tmp___113 = strlen((char const   *)cp);
#line 302
          options___0 += tmp___113;
          goto next_option;
        }
#line 305
        cp = (char *)"command=\"";
#line 306
        if (0) {
#line 306
          if (0) {
#line 306
            __s1_len___8 = strlen((char const   *)options___0);
#line 306
            __s2_len___8 = strlen((char const   *)cp);
#line 306
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___22;
            } else {
#line 306
              if (__s1_len___8 >= 4U) {
                _L___22: /* CIL Label */ 
#line 306
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 306
                  tmp___181 = 1;
                } else {
#line 306
                  if (__s2_len___8 >= 4U) {
#line 306
                    tmp___181 = 1;
                  } else {
#line 306
                    tmp___181 = 0;
                  }
                }
              } else {
#line 306
                tmp___181 = 0;
              }
            }
#line 306
            if (tmp___181) {
#line 306
              tmp___177 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 306
              tmp___180 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 306
              tmp___177 = tmp___180;
            }
          } else {
#line 306
            tmp___180 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 306
            tmp___177 = tmp___180;
          }
#line 306
          tmp___171 = tmp___177;
        } else {
#line 306
          tmp___182 = strlen((char const   *)cp);
#line 306
          tmp___171 = strncmp((char const   *)options___0, (char const   *)cp, tmp___182);
        }
#line 306
        if (tmp___171 == 0) {
#line 308
          tmp___148 = strlen((char const   *)cp);
#line 308
          options___0 += tmp___148;
#line 309
          tmp___149 = strlen((char const   *)options___0);
#line 309
          tmp___150 = xmalloc(tmp___149 + 1U);
#line 309
          forced_command = (char *)tmp___150;
#line 310
          i___0 = 0;
#line 311
          while (*options___0) {
#line 312
            if ((int )*options___0 == 34) {
#line 313
              break;
            }
#line 314
            if ((int )*options___0 == 92) {
#line 314
              if ((int )*(options___0 + 1) == 34) {
#line 315
                options___0 += 2;
#line 316
                tmp___151 = i___0;
#line 316
                i___0 ++;
#line 316
                *(forced_command + tmp___151) = (char )'\"';
#line 317
                continue;
              }
            }
#line 319
            tmp___152 = i___0;
#line 319
            i___0 ++;
#line 319
            tmp___153 = options___0;
#line 319
            options___0 ++;
#line 319
            *(forced_command + tmp___152) = *tmp___153;
          }
#line 321
          if (! *options___0) {
#line 322
            debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys", linenum);
#line 324
            packet_send_debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys",
                              linenum);
#line 326
            continue;
          }
#line 328
          *(forced_command + i___0) = (char)0;
#line 329
          packet_send_debug("Forced command: %.900s", forced_command);
#line 330
          options___0 ++;
          goto next_option;
        }
#line 333
        cp = (char *)"environment=\"";
#line 334
        if (0) {
#line 334
          if (0) {
#line 334
            __s1_len___10 = strlen((char const   *)options___0);
#line 334
            __s2_len___10 = strlen((char const   *)cp);
#line 334
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___26;
            } else {
#line 334
              if (__s1_len___10 >= 4U) {
                _L___26: /* CIL Label */ 
#line 334
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 334
                  tmp___222 = 1;
                } else {
#line 334
                  if (__s2_len___10 >= 4U) {
#line 334
                    tmp___222 = 1;
                  } else {
#line 334
                    tmp___222 = 0;
                  }
                }
              } else {
#line 334
                tmp___222 = 0;
              }
            }
#line 334
            if (tmp___222) {
#line 334
              tmp___218 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 334
              tmp___221 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 334
              tmp___218 = tmp___221;
            }
          } else {
#line 334
            tmp___221 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 334
            tmp___218 = tmp___221;
          }
#line 334
          tmp___212 = tmp___218;
        } else {
#line 334
          tmp___223 = strlen((char const   *)cp);
#line 334
          tmp___212 = strncmp((char const   *)options___0, (char const   *)cp, tmp___223);
        }
#line 334
        if (tmp___212 == 0) {
#line 338
          tmp___188 = strlen((char const   *)cp);
#line 338
          options___0 += tmp___188;
#line 339
          tmp___189 = strlen((char const   *)options___0);
#line 339
          tmp___190 = xmalloc(tmp___189 + 1U);
#line 339
          s = (char *)tmp___190;
#line 340
          i___1 = 0;
#line 341
          while (*options___0) {
#line 342
            if ((int )*options___0 == 34) {
#line 343
              break;
            }
#line 344
            if ((int )*options___0 == 92) {
#line 344
              if ((int )*(options___0 + 1) == 34) {
#line 345
                options___0 += 2;
#line 346
                tmp___191 = i___1;
#line 346
                i___1 ++;
#line 346
                *(s + tmp___191) = (char )'\"';
#line 347
                continue;
              }
            }
#line 349
            tmp___192 = i___1;
#line 349
            i___1 ++;
#line 349
            tmp___193 = options___0;
#line 349
            options___0 ++;
#line 349
            *(s + tmp___192) = *tmp___193;
          }
#line 351
          if (! *options___0) {
#line 352
            debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys", linenum);
#line 354
            packet_send_debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys",
                              linenum);
#line 356
            continue;
          }
#line 358
          *(s + i___1) = (char)0;
#line 359
          packet_send_debug("Adding to environment: %.900s", s);
#line 360
          debug("Adding to environment: %.900s", s);
#line 361
          options___0 ++;
#line 362
          tmp___194 = xmalloc(sizeof(struct envstring ));
#line 362
          new_envstring = (struct envstring *)tmp___194;
#line 363
          new_envstring->s = s;
#line 364
          new_envstring->next = custom_environment;
#line 365
          custom_environment = new_envstring;
          goto next_option;
        }
#line 368
        cp = (char *)"from=\"";
#line 369
        if (0) {
#line 369
          if (0) {
#line 369
            __s1_len___12 = strlen((char const   *)options___0);
#line 369
            __s2_len___12 = strlen((char const   *)cp);
#line 369
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___30;
            } else {
#line 369
              if (__s1_len___12 >= 4U) {
                _L___30: /* CIL Label */ 
#line 369
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 369
                  tmp___271 = 1;
                } else {
#line 369
                  if (__s2_len___12 >= 4U) {
#line 369
                    tmp___271 = 1;
                  } else {
#line 369
                    tmp___271 = 0;
                  }
                }
              } else {
#line 369
                tmp___271 = 0;
              }
            }
#line 369
            if (tmp___271) {
#line 369
              tmp___267 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 369
              tmp___270 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 369
              tmp___267 = tmp___270;
            }
          } else {
#line 369
            tmp___270 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 369
            tmp___267 = tmp___270;
          }
#line 369
          tmp___261 = tmp___267;
        } else {
#line 369
          tmp___272 = strlen((char const   *)cp);
#line 369
          tmp___261 = strncmp((char const   *)options___0, (char const   *)cp, tmp___272);
        }
#line 369
        if (tmp___261 == 0) {
#line 370
          tmp___229 = strlen((char const   *)options___0);
#line 370
          tmp___230 = xmalloc(tmp___229 + 1U);
#line 370
          patterns = (char *)tmp___230;
#line 372
          tmp___231 = strlen((char const   *)cp);
#line 372
          options___0 += tmp___231;
#line 373
          i___2 = 0;
#line 374
          while (*options___0) {
#line 375
            if ((int )*options___0 == 34) {
#line 376
              break;
            }
#line 377
            if ((int )*options___0 == 92) {
#line 377
              if ((int )*(options___0 + 1) == 34) {
#line 378
                options___0 += 2;
#line 379
                tmp___232 = i___2;
#line 379
                i___2 ++;
#line 379
                *(patterns + tmp___232) = (char )'\"';
#line 380
                continue;
              }
            }
#line 382
            tmp___233 = i___2;
#line 382
            i___2 ++;
#line 382
            tmp___234 = options___0;
#line 382
            options___0 ++;
#line 382
            *(patterns + tmp___233) = *tmp___234;
          }
#line 384
          if (! *options___0) {
#line 385
            debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys", linenum);
#line 387
            packet_send_debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys",
                              linenum);
#line 389
            continue;
          }
#line 391
          *(patterns + i___2) = (char)0;
#line 392
          options___0 ++;
#line 393
          tmp___238 = strlen((char const   *)patterns);
#line 393
          tmp___239 = get_canonical_hostname();
#line 393
          tmp___240 = match_hostname(tmp___239, (char const   *)patterns, tmp___238);
#line 393
          if (! tmp___240) {
#line 393
            tmp___241 = strlen((char const   *)patterns);
#line 393
            tmp___242 = get_remote_ipaddr();
#line 393
            tmp___243 = match_hostname(tmp___242, (char const   *)patterns, tmp___241);
#line 393
            if (! tmp___243) {
#line 397
              tmp___235 = get_remote_ipaddr();
#line 397
              tmp___236 = get_canonical_hostname();
#line 397
              log("RSA authentication tried for %.100s with correct key but not from a permitted host (host=%.200s, ip=%.200s).",
                  pw->pw_name, tmp___236, tmp___235);
#line 400
              tmp___237 = get_canonical_hostname();
#line 400
              packet_send_debug("Your host \'%.200s\' is not permitted to use this key for login.",
                                tmp___237);
#line 402
              xfree((void *)patterns);
#line 404
              authenticated = 0;
#line 405
              no_agent_forwarding_flag = 0;
#line 406
              no_port_forwarding_flag = 0;
#line 407
              no_pty_flag = 0;
#line 408
              no_x11_forwarding_flag = 0;
#line 409
              while (custom_environment) {
#line 410
                ce = custom_environment;
#line 411
                custom_environment = ce->next;
#line 412
                xfree((void *)ce->s);
#line 413
                xfree((void *)ce);
              }
#line 415
              if (forced_command) {
#line 416
                xfree((void *)forced_command);
#line 417
                forced_command = (char *)((void *)0);
              }
#line 419
              break;
            }
          }
#line 421
          xfree((void *)patterns);
          goto next_option;
        }
        bad_option: 
#line 426
        log("Bad options in %.100s file, line %lu: %.50s", ".ssh/authorized_keys",
            linenum, options___0);
#line 428
        packet_send_debug("Bad options in %.100s file, line %lu: %.50s", ".ssh/authorized_keys",
                          linenum, options___0);
#line 430
        authenticated = 0;
#line 431
        break;
        next_option: 
#line 438
        if (! *options___0) {
#line 439
          fatal("Bugs in auth-rsa.c option processing.");
        }
#line 440
        if ((int )*options___0 == 32) {
#line 441
          break;
        } else {
#line 440
          if ((int )*options___0 == 9) {
#line 441
            break;
          }
        }
#line 442
        if ((int )*options___0 != 44) {
          goto bad_option;
        }
#line 444
        options___0 ++;
#line 446
        continue;
      }
    }
#line 453
    if (authenticated) {
#line 454
      break;
    }
  }
#line 458
  restore_uid();
#line 461
  fclose(f);
#line 463
  RSA_free(pk);
#line 465
  if (authenticated) {
#line 466
    packet_send_debug("RSA authentication accepted.");
  }
#line 469
  return (authenticated);
}
}
#line 1 "auth-rh-rsa.o"
#pragma merger(0,"./auth-rh-rsa.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 36 "auth-rh-rsa.c"
int auth_rhosts_rsa(struct passwd *pw , char const   *client_user , RSA *client_host_key ) 
{ char const   *canonical_hostname ;
  HostStatus host_status ;
  Key *client_key ;
  Key *found ;
  int tmp ;
  struct stat st ;
  char *user_hostfile ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 44
  debug("Trying rhosts with RSA host authentication for %.100s", client_user);
#line 46
  if ((unsigned int )client_host_key == (unsigned int )((void *)0)) {
#line 47
    return (0);
  }
#line 50
  tmp = auth_rhosts(pw, client_user);
#line 50
  if (! tmp) {
#line 51
    return (0);
  }
#line 53
  canonical_hostname = get_canonical_hostname();
#line 55
  debug("Rhosts RSA authentication: canonical host %.900s", canonical_hostname);
#line 58
  client_key = key_new(0);
#line 59
  BN_copy((client_key->rsa)->e, (BIGNUM const   *)client_host_key->e);
#line 60
  BN_copy((client_key->rsa)->n, (BIGNUM const   *)client_host_key->n);
#line 61
  found = key_new(0);
#line 64
  host_status = check_host_in_hostfile("/usr/local/etc/ssh_known_hosts", canonical_hostname,
                                       client_key, found);
#line 68
  if ((int )host_status != 0) {
#line 68
    if (! options.ignore_user_known_hosts) {
#line 70
      tmp___0 = tilde_expand_filename("~/.ssh/known_hosts", pw->pw_uid);
#line 70
      user_hostfile = tmp___0;
#line 75
      if (options.strict_modes) {
#line 75
        tmp___1 = stat((char const   * __restrict  )user_hostfile, (struct stat * __restrict  )(& st));
#line 75
        if (tmp___1 == 0) {
#line 75
          if (st.st_uid != 0U) {
#line 75
            if (st.st_uid != pw->pw_uid) {
#line 79
              log("Rhosts RSA authentication refused for %.100s: bad owner or modes for %.200s",
                  pw->pw_name, user_hostfile);
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 75
            if ((st.st_mode & 18U) != 0U) {
#line 79
              log("Rhosts RSA authentication refused for %.100s: bad owner or modes for %.200s",
                  pw->pw_name, user_hostfile);
            } else {
#line 83
              temporarily_use_uid(pw->pw_uid);
#line 84
              host_status = check_host_in_hostfile((char const   *)user_hostfile,
                                                   canonical_hostname, client_key,
                                                   found);
#line 86
              restore_uid();
            }
          }
        } else {
#line 83
          temporarily_use_uid(pw->pw_uid);
#line 84
          host_status = check_host_in_hostfile((char const   *)user_hostfile, canonical_hostname,
                                               client_key, found);
#line 86
          restore_uid();
        }
      } else {
#line 83
        temporarily_use_uid(pw->pw_uid);
#line 84
        host_status = check_host_in_hostfile((char const   *)user_hostfile, canonical_hostname,
                                             client_key, found);
#line 86
        restore_uid();
      }
#line 88
      xfree((void *)user_hostfile);
    }
  }
#line 90
  key_free(client_key);
#line 91
  key_free(found);
#line 93
  if ((int )host_status != 0) {
#line 94
    debug("Rhosts with RSA host authentication denied: unknown or invalid host key");
#line 95
    packet_send_debug("Your host key cannot be verified: unknown or invalid host key.");
#line 96
    return (0);
  }
#line 101
  tmp___2 = auth_rsa_challenge_dialog(client_host_key);
#line 101
  if (! tmp___2) {
#line 102
    log("Client on %.800s failed to respond correctly to host authentication.", canonical_hostname);
#line 104
    return (0);
  }
#line 111
  verbose("Rhosts with RSA host authentication accepted for %.100s, %.100s on %.700s.",
          pw->pw_name, client_user, canonical_hostname);
#line 113
  packet_send_debug("Rhosts with RSA host authentication accepted.");
#line 114
  return (1);
}
}
#line 1 "pty.o"
#pragma merger(0,"./pty.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 280 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 109 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 433 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group )  __attribute__((__nonnull__(1))) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 872
extern  __attribute__((__nothrow__)) int vhangup(void) ;
#line 27 "pty.h"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) ;
#line 33
void pty_release(char const   *ttyname___0 ) ;
#line 39
void pty_make_controlling_tty(int *ttyfd , char const   *ttyname___0 ) ;
#line 42
void pty_change_window_size(int ptyfd , int row , int col , int xpixel , int ypixel ) ;
#line 46
void pty_setowner(struct passwd *pw , char const   *ttyname___0 ) ;
#line 57 "pty.c"
extern int ( /* missing proto */  openpty)() ;
#line 49 "pty.c"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) 
{ char buf___1[64] ;
  int i ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 57
  i = openpty(ptyfd, ttyfd, buf___1, (void *)0, (void *)0);
#line 58
  if (i < 0) {
#line 59
    tmp = __errno_location();
#line 59
    tmp___0 = strerror(*tmp);
#line 59
    error("openpty: %.100s", tmp___0);
#line 60
    return (0);
  }
#line 62
  strlcpy(namebuf, (char const   *)(buf___1), (unsigned int )namebuflen);
#line 63
  return (1);
}
}
#line 189 "pty.c"
void pty_release(char const   *ttyname___0 ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 192
  tmp___1 = chown(ttyname___0, 0U, 0U);
#line 192
  if (tmp___1 < 0) {
#line 193
    tmp = __errno_location();
#line 193
    tmp___0 = strerror(*tmp);
#line 193
    error("chown %.100s 0 0 failed: %.100s", ttyname___0, tmp___0);
  }
#line 194
  tmp___4 = chmod(ttyname___0, 438U);
#line 194
  if (tmp___4 < 0) {
#line 195
    tmp___2 = __errno_location();
#line 195
    tmp___3 = strerror(*tmp___2);
#line 195
    error("chmod %.100s 0666 failed: %.100s", ttyname___0, tmp___3);
  }
#line 196
  return;
}
}
#line 200 "pty.c"
void pty_make_controlling_tty(int *ttyfd , char const   *ttyname___0 ) 
{ int fd ;
  void *old ;
  int *tmp ;
  char *tmp___0 ;
  __pid_t tmp___1 ;
  __sighandler_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
#line 210
  fd = open("/dev/tty", 258);
#line 211
  if (fd >= 0) {
#line 212
    ioctl(fd, 21538UL, (void *)0);
#line 213
    close(fd);
  }
#line 216
  tmp___1 = setsid();
#line 216
  if (tmp___1 < 0) {
#line 217
    tmp = __errno_location();
#line 217
    tmp___0 = strerror(*tmp);
#line 217
    error("setsid: %.100s", tmp___0);
  }
#line 223
  fd = open("/dev/tty", 258);
#line 224
  if (fd >= 0) {
#line 225
    error("Failed to disconnect from controlling tty.");
#line 226
    close(fd);
  }
#line 230
  debug("Setting controlling tty using TIOCSCTTY.");
#line 236
  ioctl(*ttyfd, 21518UL, (void *)0);
#line 239
  tmp___2 = signal(1, (void (*)(int  ))1);
#line 239
  old = (void *)tmp___2;
#line 240
  vhangup();
#line 241
  signal(1, (void (*)(int  ))old);
#line 243
  fd = open(ttyname___0, 2);
#line 244
  if (fd < 0) {
#line 245
    tmp___3 = __errno_location();
#line 245
    tmp___4 = strerror(*tmp___3);
#line 245
    error("%.100s: %.100s", ttyname___0, tmp___4);
  } else {
#line 248
    close(*ttyfd);
#line 249
    *ttyfd = fd;
  }
#line 255
  fd = open("/dev/tty", 1);
#line 256
  if (fd < 0) {
#line 257
    tmp___5 = __errno_location();
#line 257
    tmp___6 = strerror(*tmp___5);
#line 257
    error("open /dev/tty failed - could not set controlling tty: %.100s", tmp___6);
  } else {
#line 260
    close(fd);
  }
#line 262
  return;
}
}
#line 266 "pty.c"
void pty_change_window_size(int ptyfd , int row , int col , int xpixel , int ypixel ) 
{ struct winsize w ;

  {
#line 271
  w.ws_row = (unsigned short )row;
#line 272
  w.ws_col = (unsigned short )col;
#line 273
  w.ws_xpixel = (unsigned short )xpixel;
#line 274
  w.ws_ypixel = (unsigned short )ypixel;
#line 275
  ioctl(ptyfd, 21524UL, & w);
#line 276
  return;
}
}
#line 278 "pty.c"
void pty_setowner(struct passwd *pw , char const   *ttyname___0 ) 
{ struct group *grp ;
  gid_t gid ;
  mode_t mode ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 286
  grp = getgrnam("tty");
#line 287
  if (grp) {
#line 288
    gid = grp->gr_gid;
#line 289
    mode = (unsigned int )(384 | (128 >> 3));
  } else {
#line 291
    gid = pw->pw_gid;
#line 292
    mode = (unsigned int )((384 | (128 >> 3)) | ((128 >> 3) >> 3));
  }
#line 296
  tmp___1 = chown(ttyname___0, pw->pw_uid, gid);
#line 296
  if (tmp___1 < 0) {
#line 297
    tmp = __errno_location();
#line 297
    tmp___0 = strerror(*tmp);
#line 297
    fatal("chown(%.100s, %d, %d) failed: %.100s", ttyname___0, pw->pw_uid, gid, tmp___0);
  }
#line 299
  tmp___4 = chmod(ttyname___0, mode);
#line 299
  if (tmp___4 < 0) {
#line 300
    tmp___2 = __errno_location();
#line 300
    tmp___3 = strerror(*tmp___2);
#line 300
    fatal("chmod(%.100s, 0%o) failed: %.100s", ttyname___0, mode, tmp___3);
  }
#line 302
  return;
}
}
#line 1 "log-server.o"
#pragma merger(0,"./log-server.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 175 "/usr/include/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 26 "log-server.c"
extern char *__progname ;
#line 31 "log-server.c"
static LogLevel log_level  =    3;
#line 32 "log-server.c"
static int log_on_stderr  =    0;
#line 33 "log-server.c"
static int log_facility  =    4 << 3;
#line 41 "log-server.c"
void log_init(char *av0___0 , LogLevel level , SyslogFacility facility , int on_stderr ) 
{ 

  {
#line 44
  switch ((int )level) {
  case 0: 
  case 2: 
  case 1: 
  case 3: 
  case 4: 
  case 5: 
#line 51
  log_level = level;
#line 52
  break;
  default: 
#line 54
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized internal syslog level code %d\n",
          (int )level);
#line 56
  exit(1);
  }
#line 58
  switch ((int )facility) {
  case 0: 
#line 60
  log_facility = 3 << 3;
#line 61
  break;
  case 1: 
#line 63
  log_facility = 1 << 3;
#line 64
  break;
  case 2: 
#line 66
  log_facility = 4 << 3;
#line 67
  break;
  case 3: 
#line 69
  log_facility = 16 << 3;
#line 70
  break;
  case 4: 
#line 72
  log_facility = 17 << 3;
#line 73
  break;
  case 5: 
#line 75
  log_facility = 18 << 3;
#line 76
  break;
  case 6: 
#line 78
  log_facility = 19 << 3;
#line 79
  break;
  case 7: 
#line 81
  log_facility = 20 << 3;
#line 82
  break;
  case 8: 
#line 84
  log_facility = 21 << 3;
#line 85
  break;
  case 9: 
#line 87
  log_facility = 22 << 3;
#line 88
  break;
  case 10: 
#line 90
  log_facility = 23 << 3;
#line 91
  break;
  default: 
#line 93
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized internal syslog facility code %d\n",
          (int )facility);
#line 95
  exit(1);
  }
#line 97
  log_on_stderr = on_stderr;
#line 98
  return;
}
}
#line 102 "log-server.c"
void do_log(LogLevel level , char const   *fmt , va_list args ) 
{ char msgbuf[1024] ;
  char fmtbuf[1024] ;
  char *txt ;
  int pri ;

  {
#line 107
  txt = (char *)((void *)0);
#line 108
  pri = 6;
#line 110
  if ((int )level > (int )log_level) {
#line 111
    return;
  }
#line 112
  switch ((int )level) {
  case 2: 
#line 114
  txt = (char *)"error";
#line 115
  pri = 3;
#line 116
  break;
  case 1: 
#line 118
  txt = (char *)"fatal";
#line 119
  pri = 3;
#line 120
  break;
  case 3: 
  case 4: 
#line 123
  pri = 6;
#line 124
  break;
  case 5: 
#line 126
  txt = (char *)"debug";
#line 127
  pri = 7;
#line 128
  break;
  default: 
#line 130
  txt = (char *)"internal error";
#line 131
  pri = 3;
#line 132
  break;
  }
#line 134
  if ((unsigned int )txt != (unsigned int )((void *)0)) {
#line 135
    snprintf((char * __restrict  )(fmtbuf), sizeof(fmtbuf), (char const   * __restrict  )"%s: %s",
             txt, fmt);
#line 136
    vsnprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )(fmtbuf),
              args);
  } else {
#line 138
    vsnprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )fmt,
              args);
  }
#line 140
  if (log_on_stderr) {
#line 141
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n", msgbuf);
  } else {
#line 143
    openlog((char const   *)__progname, 1, log_facility);
#line 144
    syslog(pri, "%.500s", msgbuf);
#line 145
    closelog();
  }
#line 147
  return;
}
}
#line 1 "login.o"
#pragma merger(0,"./login.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 46 "/usr/include/utmp.h"
extern  __attribute__((__nothrow__)) void login(struct utmp  const  *__entry ) ;
#line 49
extern  __attribute__((__nothrow__)) int logout(char const   *__ut_line ) ;
#line 52
extern  __attribute__((__nothrow__)) void logwtmp(char const   *__ut_line , char const   *__ut_name ,
                                                  char const   *__ut_host ) ;
#line 187 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 301 "ssh.h"
unsigned long get_last_login_time(uid_t uid , char const   *logname , char *buf___1 ,
                                  unsigned int bufsize ) ;
#line 309
void record_login(pid_t pid , char const   *ttyname___0 , char const   *user , uid_t uid ,
                  char const   *host , struct sockaddr *addr ) ;
#line 317
void record_logout(pid_t pid , char const   *ttyname___0 ) ;
#line 52 "login.c"
unsigned long get_last_login_time(uid_t uid , char const   *logname , char *buf___1 ,
                                  unsigned int bufsize ) 
{ struct lastlog ll ;
  char *lastlog ;
  int fd ;
  ssize_t tmp ;

  {
#line 68
  lastlog = (char *)"/var/log/lastlog";
#line 69
  *(buf___1 + 0) = (char )'\000';
#line 72
  fd = open((char const   *)lastlog, 0);
#line 73
  if (fd < 0) {
#line 74
    return (0UL);
  }
#line 75
  lseek(fd, (long )((unsigned long )((long )uid) * (unsigned long )sizeof(ll)), 0);
#line 82
  tmp = read(fd, (void *)(& ll), sizeof(ll));
#line 82
  if ((unsigned int )tmp != sizeof(ll)) {
#line 83
    close(fd);
#line 84
    return (0UL);
  }
#line 86
  close(fd);
#line 87
  if (bufsize > sizeof(ll.ll_host) + 1U) {
#line 88
    bufsize = sizeof(ll.ll_host) + 1U;
  }
#line 89
  __builtin_strncpy(buf___1, (char const   *)(ll.ll_host), bufsize - 1U);
#line 90
  *(buf___1 + (bufsize - 1U)) = (char)0;
#line 91
  return ((unsigned long )ll.ll_time);
}
}
#line 147 "login.c"
void record_login(pid_t pid , char const   *ttyname___0 , char const   *user , uid_t uid ,
                  char const   *host , struct sockaddr *addr ) 
{ struct lastlog ll ;
  char *lastlog ;
  struct utmp u ;
  int fd ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 164
  memset((void *)(& u), 0, sizeof(u));
#line 165
  __builtin_strncpy(u.ut_line, ttyname___0 + 5, sizeof(u.ut_line));
#line 173
  __builtin_strncpy(u.ut_user, user, sizeof(u.ut_user));
#line 177
  u.ut_tv.tv_sec = time((time_t *)((void *)0));
#line 254
  login((struct utmp  const  *)(& u));
#line 259
  lastlog = (char *)"/var/log/lastlog";
#line 262
  if (0) {
#line 262
    __s1_len = strlen(user);
#line 262
    __s2_len = strlen("");
#line 262
    if (! ((unsigned int )((void const   *)(user + 1)) - (unsigned int )((void const   *)user) == 1U)) {
      goto _L___0;
    } else {
#line 262
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 262
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 262
          tmp___11 = 1;
        } else {
#line 262
          if (__s2_len >= 4U) {
#line 262
            tmp___11 = 1;
          } else {
#line 262
            tmp___11 = 0;
          }
        }
      } else {
#line 262
        tmp___11 = 0;
      }
    }
#line 262
    if (tmp___11) {
#line 262
      tmp___7 = __builtin_strcmp(user, "");
    } else {
#line 262
      tmp___10 = __builtin_strcmp(user, "");
#line 262
      tmp___7 = tmp___10;
    }
  } else {
#line 262
    tmp___10 = __builtin_strcmp(user, "");
#line 262
    tmp___7 = tmp___10;
  }
#line 262
  if (tmp___7 != 0) {
#line 268
    memset((void *)(& ll), 0, sizeof(ll));
#line 271
    ll.ll_time = time((time_t *)((void *)0));
#line 272
    __builtin_strncpy(ll.ll_line, ttyname___0 + 5, sizeof(ll.ll_line));
#line 273
    __builtin_strncpy(ll.ll_host, host, sizeof(ll.ll_host));
#line 279
    fd = open((char const   *)lastlog, 2);
#line 280
    if (fd >= 0) {
#line 281
      lseek(fd, (long )((unsigned long )((long )uid) * (unsigned long )sizeof(ll)),
            0);
#line 283
      tmp___1 = write(fd, (void const   *)(& ll), sizeof(ll));
#line 283
      if ((unsigned int )tmp___1 != sizeof(ll)) {
#line 284
        tmp = __errno_location();
#line 284
        tmp___0 = strerror(*tmp);
#line 284
        log("Could not write %.100s: %.100s", lastlog, tmp___0);
      }
#line 285
      close(fd);
    }
  }
#line 289
  return;
}
}
#line 293 "login.c"
void record_logout(pid_t pid , char const   *ttyname___0 ) 
{ char const   *line ;
  int tmp ;

  {
#line 297
  line = ttyname___0 + 5;
#line 298
  tmp = logout(line);
#line 298
  if (tmp) {
#line 299
    logwtmp(line, "", "");
  }
#line 303
  return;
}
}
/* compiler builtin: 
   unsigned int __builtin_strspn(char const   * , char const   * ) ;  */
#line 1 "servconf.o"
#pragma merger(0,"./servconf.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 747 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 23 "servconf.c"
void add_listen_addr(ServerOptions *options___0 , char *addr ) ;
#line 27 "servconf.c"
void initialize_server_options(ServerOptions *options___0 ) 
{ 

  {
#line 30
  memset((void *)options___0, 0, sizeof(*options___0));
#line 31
  options___0->num_ports = 0U;
#line 32
  options___0->ports_from_cmdline = 0U;
#line 33
  options___0->listen_addrs = (struct addrinfo *)((void *)0);
#line 34
  options___0->host_key_file = (char *)((void *)0);
#line 35
  options___0->host_dsa_key_file = (char *)((void *)0);
#line 36
  options___0->pid_file = (char *)((void *)0);
#line 37
  options___0->server_key_bits = -1;
#line 38
  options___0->login_grace_time = -1;
#line 39
  options___0->key_regeneration_time = -1;
#line 40
  options___0->permit_root_login = -1;
#line 41
  options___0->ignore_rhosts = -1;
#line 42
  options___0->ignore_user_known_hosts = -1;
#line 43
  options___0->print_motd = -1;
#line 44
  options___0->check_mail = -1;
#line 45
  options___0->x11_forwarding = -1;
#line 46
  options___0->x11_display_offset = -1;
#line 47
  options___0->strict_modes = -1;
#line 48
  options___0->keepalives = -1;
#line 49
  options___0->log_facility = (enum __anonenum_SyslogFacility_72 )-1;
#line 50
  options___0->log_level = (enum __anonenum_LogLevel_73 )-1;
#line 51
  options___0->rhosts_authentication = -1;
#line 52
  options___0->rhosts_rsa_authentication = -1;
#line 53
  options___0->rsa_authentication = -1;
#line 54
  options___0->dsa_authentication = -1;
#line 64
  options___0->password_authentication = -1;
#line 68
  options___0->permit_empty_passwd = -1;
#line 69
  options___0->use_login = -1;
#line 70
  options___0->num_allow_users = 0U;
#line 71
  options___0->num_deny_users = 0U;
#line 72
  options___0->num_allow_groups = 0U;
#line 73
  options___0->num_deny_groups = 0U;
#line 74
  options___0->ciphers = (char *)((void *)0);
#line 75
  options___0->protocol = 0;
#line 76
  options___0->gateway_ports = -1;
#line 77
  return;
}
}
#line 79 "servconf.c"
void fill_default_server_options(ServerOptions *options___0 ) 
{ unsigned int tmp ;

  {
#line 82
  if (options___0->num_ports == 0U) {
#line 83
    tmp = options___0->num_ports;
#line 83
    (options___0->num_ports) ++;
#line 83
    options___0->ports[tmp] = (unsigned short)22;
  }
#line 84
  if ((unsigned int )options___0->listen_addrs == (unsigned int )((void *)0)) {
#line 85
    add_listen_addr(options___0, (char *)((void *)0));
  }
#line 86
  if ((unsigned int )options___0->host_key_file == (unsigned int )((void *)0)) {
#line 87
    options___0->host_key_file = (char *)"/usr/local/etc/ssh_host_key";
  }
#line 88
  if ((unsigned int )options___0->host_dsa_key_file == (unsigned int )((void *)0)) {
#line 89
    options___0->host_dsa_key_file = (char *)"/usr/local/etc/ssh_host_dsa_key";
  }
#line 90
  if ((unsigned int )options___0->pid_file == (unsigned int )((void *)0)) {
#line 91
    options___0->pid_file = (char *)"/var/run/sshd.pid";
  }
#line 92
  if (options___0->server_key_bits == -1) {
#line 93
    options___0->server_key_bits = 768;
  }
#line 94
  if (options___0->login_grace_time == -1) {
#line 95
    options___0->login_grace_time = 600;
  }
#line 96
  if (options___0->key_regeneration_time == -1) {
#line 97
    options___0->key_regeneration_time = 3600;
  }
#line 98
  if (options___0->permit_root_login == -1) {
#line 99
    options___0->permit_root_login = 1;
  }
#line 100
  if (options___0->ignore_rhosts == -1) {
#line 101
    options___0->ignore_rhosts = 1;
  }
#line 102
  if (options___0->ignore_user_known_hosts == -1) {
#line 103
    options___0->ignore_user_known_hosts = 0;
  }
#line 104
  if (options___0->check_mail == -1) {
#line 105
    options___0->check_mail = 0;
  }
#line 106
  if (options___0->print_motd == -1) {
#line 107
    options___0->print_motd = 1;
  }
#line 108
  if (options___0->x11_forwarding == -1) {
#line 109
    options___0->x11_forwarding = 0;
  }
#line 110
  if (options___0->x11_display_offset == -1) {
#line 111
    options___0->x11_display_offset = 10;
  }
#line 112
  if (options___0->strict_modes == -1) {
#line 113
    options___0->strict_modes = 1;
  }
#line 114
  if (options___0->keepalives == -1) {
#line 115
    options___0->keepalives = 1;
  }
#line 116
  if ((int )options___0->log_facility == (int )((enum __anonenum_SyslogFacility_72 )-1)) {
#line 117
    options___0->log_facility = 2;
  }
#line 118
  if ((int )options___0->log_level == (int )((enum __anonenum_LogLevel_73 )-1)) {
#line 119
    options___0->log_level = 3;
  }
#line 120
  if (options___0->rhosts_authentication == -1) {
#line 121
    options___0->rhosts_authentication = 0;
  }
#line 122
  if (options___0->rhosts_rsa_authentication == -1) {
#line 123
    options___0->rhosts_rsa_authentication = 0;
  }
#line 124
  if (options___0->rsa_authentication == -1) {
#line 125
    options___0->rsa_authentication = 1;
  }
#line 126
  if (options___0->dsa_authentication == -1) {
#line 127
    options___0->dsa_authentication = 1;
  }
#line 142
  if (options___0->password_authentication == -1) {
#line 143
    options___0->password_authentication = 1;
  }
#line 148
  if (options___0->permit_empty_passwd == -1) {
#line 149
    options___0->permit_empty_passwd = 0;
  }
#line 150
  if (options___0->use_login == -1) {
#line 151
    options___0->use_login = 0;
  }
#line 152
  if (options___0->protocol == 0) {
#line 153
    options___0->protocol = 5;
  }
#line 154
  if (options___0->gateway_ports == -1) {
#line 155
    options___0->gateway_ports = 0;
  }
#line 156
  return;
}
}
#line 184 "servconf.c"
static struct __anonstruct_keywords_76 keywords[35]  = 
#line 184
  {      {"port", 1}, 
        {"hostkey", 2}, 
        {"hostdsakey", 29}, 
        {"pidfile", 32}, 
        {"serverkeybits", 3}, 
        {"logingracetime", 4}, 
        {"keyregenerationinterval", 5}, 
        {"permitrootlogin", 6}, 
        {"syslogfacility", 7}, 
        {"loglevel", 8}, 
        {"rhostsauthentication", 9}, 
        {"rhostsrsaauthentication", 10}, 
        {"rsaauthentication", 11}, 
        {"dsaauthentication", 34}, 
        {"passwordauthentication", 12}, 
        {"checkmail", 22}, 
        {"listenaddress", 13}, 
        {"printmotd", 14}, 
        {"ignorerhosts", 15}, 
        {"ignoreuserknownhosts", 28}, 
        {"x11forwarding", 16}, 
        {"x11displayoffset", 17}, 
        {"strictmodes", 18}, 
        {"permitemptypasswords", 19}, 
        {"uselogin", 23}, 
        {"randomseed", 20}, 
        {"keepalive", 21}, 
        {"allowusers", 24}, 
        {"denyusers", 25}, 
        {"allowgroups", 26}, 
        {"denygroups", 27}, 
        {"ciphers", 30}, 
        {"protocol", 31}, 
        {"gatewayports", 33}, 
        {(char const   *)((void *)0), (ServerOpCodes )0}};
#line 242 "servconf.c"
static ServerOpCodes parse_token(char const   *cp , char const   *filename , int linenum ) 
{ unsigned int i ;
  int tmp ;

  {
#line 248
  i = 0U;
#line 248
  while (keywords[i].name) {
#line 249
    tmp = strcasecmp(cp, keywords[i].name);
#line 249
    if (tmp == 0) {
#line 250
      return (keywords[i].opcode);
    }
#line 248
    i ++;
  }
#line 252
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: line %d: Bad configuration option: %s\n",
          filename, linenum, cp);
#line 254
  return (0);
}
}
#line 260 "servconf.c"
void add_listen_addr(ServerOptions *options___0 , char *addr ) 
{ struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  int i ;
  unsigned int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 269
  if (options___0->num_ports == 0U) {
#line 270
    tmp = options___0->num_ports;
#line 270
    (options___0->num_ports) ++;
#line 270
    options___0->ports[tmp] = (unsigned short)22;
  }
#line 271
  i = 0;
#line 271
  while ((unsigned int )i < options___0->num_ports) {
#line 272
    memset((void *)(& hints), 0, sizeof(hints));
#line 273
    hints.ai_family = IPv4or6;
#line 274
    hints.ai_socktype = 1;
#line 275
    if ((unsigned int )addr == (unsigned int )((void *)0)) {
#line 275
      hints.ai_flags = 1;
    } else {
#line 275
      hints.ai_flags = 0;
    }
#line 276
    snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
             options___0->ports[i]);
#line 277
    gaierr = getaddrinfo((char const   * __restrict  )addr, (char const   * __restrict  )(strport),
                         (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 277
    if (gaierr != 0) {
#line 278
      tmp___0 = gai_strerror(gaierr);
#line 278
      if (addr) {
#line 278
        tmp___1 = (char const   *)addr;
      } else {
#line 278
        tmp___1 = "<NULL>";
      }
#line 278
      fatal("bad addr or host: %s (%s)\n", tmp___1, tmp___0);
    }
#line 281
    ai = aitop;
#line 281
    while (ai->ai_next) {
#line 281
      ai = ai->ai_next;
    }
#line 283
    ai->ai_next = options___0->listen_addrs;
#line 284
    options___0->listen_addrs = aitop;
#line 271
    i ++;
  }
#line 286
  return;
}
}
#line 290 "servconf.c"
void read_server_config(ServerOptions *options___0 , char const   *filename ) 
{ FILE *f ;
  char line[1024] ;
  char *cp ;
  char **charptr ;
  int linenum ;
  int *intptr ;
  int value ;
  int bad_options ;
  ServerOpCodes opcode ;
  unsigned int tmp___30 ;
  unsigned int tmp___31 ;
  int tmp___32 ;
  __uid_t tmp___33 ;
  __uid_t tmp___34 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___40 ;
  int tmp___43 ;
  int tmp___44 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___50 ;
  int tmp___53 ;
  int tmp___54 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___60 ;
  int tmp___63 ;
  int tmp___64 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___70 ;
  int tmp___73 ;
  int tmp___74 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___80 ;
  int tmp___83 ;
  int tmp___84 ;
  SyslogFacility tmp___85 ;
  char const   *tmp___86 ;
  LogLevel tmp___87 ;
  char const   *tmp___88 ;
  unsigned int tmp___89 ;
  unsigned int tmp___90 ;
  unsigned int tmp___91 ;
  unsigned int tmp___92 ;
  char const   *tmp___93 ;
  int tmp___94 ;
  char const   *tmp___95 ;
  char *tmp___96 ;
  char *tmp___97 ;

  {
#line 297
  bad_options = 0;
#line 300
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 301
  if (! f) {
#line 302
    perror(filename);
#line 303
    exit(1);
  }
#line 305
  linenum = 0;
#line 306
  while (1) {
#line 306
    tmp___97 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 306
    if (! tmp___97) {
#line 306
      break;
    }
#line 307
    linenum ++;
#line 308
    tmp___30 = __builtin_strspn((char const   *)(line), " \t\r\n");
#line 308
    cp = line + tmp___30;
#line 309
    if (! *cp) {
#line 310
      continue;
    } else {
#line 309
      if ((int )*cp == 35) {
#line 310
        continue;
      }
    }
#line 311
    cp = strtok((char * __restrict  )cp, (char const   * __restrict  )" \t\r\n");
#line 312
    opcode = parse_token((char const   *)cp, filename, linenum);
#line 313
    switch ((int )opcode) {
    case 0: 
#line 315
    bad_options ++;
#line 316
    continue;
    case 1: 
#line 319
    if (options___0->ports_from_cmdline) {
#line 320
      continue;
    }
#line 321
    if ((unsigned int )options___0->listen_addrs != (unsigned int )((void *)0)) {
#line 322
      fatal("%s line %d: ports must be specified before ListenAdress.\n", filename,
            linenum);
    }
#line 324
    if (options___0->num_ports >= 256U) {
#line 325
      fatal("%s line %d: too many ports.\n", filename, linenum);
    }
#line 327
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 328
    if (! cp) {
#line 329
      fatal("%s line %d: missing port number.\n", filename, linenum);
    }
#line 331
    tmp___31 = options___0->num_ports;
#line 331
    (options___0->num_ports) ++;
#line 331
    tmp___32 = atoi((char const   *)cp);
#line 331
    options___0->ports[tmp___31] = (unsigned short )tmp___32;
#line 332
    break;
    case 3: 
#line 335
    intptr = & options___0->server_key_bits;
    parse_int: 
#line 337
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 338
    if (! cp) {
#line 339
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing integer value.\n",
              filename, linenum);
#line 341
      exit(1);
    }
#line 343
    value = atoi((char const   *)cp);
#line 344
    if (*intptr == -1) {
#line 345
      *intptr = value;
    }
#line 346
    break;
    case 4: 
#line 349
    intptr = & options___0->login_grace_time;
    goto parse_int;
    case 5: 
#line 353
    intptr = & options___0->key_regeneration_time;
    goto parse_int;
    case 13: 
#line 357
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 358
    if (! cp) {
#line 359
      fatal("%s line %d: missing inet addr.\n", filename, linenum);
    }
#line 361
    add_listen_addr(options___0, cp);
#line 362
    break;
    case 2: 
    case 29: 
#line 366
    if ((int )opcode == 2) {
#line 366
      charptr = & options___0->host_key_file;
    } else {
#line 366
      charptr = & options___0->host_dsa_key_file;
    }
#line 368
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 369
    if (! cp) {
#line 370
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing file name.\n",
              filename, linenum);
#line 372
      exit(1);
    }
#line 374
    if ((unsigned int )*charptr == (unsigned int )((void *)0)) {
#line 375
      tmp___33 = getuid();
#line 375
      *charptr = tilde_expand_filename((char const   *)cp, tmp___33);
    }
#line 376
    break;
    case 32: 
#line 379
    charptr = & options___0->pid_file;
#line 380
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 381
    if (! cp) {
#line 382
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing file name.\n",
              filename, linenum);
#line 384
      exit(1);
    }
#line 386
    if ((unsigned int )*charptr == (unsigned int )((void *)0)) {
#line 387
      tmp___34 = getuid();
#line 387
      *charptr = tilde_expand_filename((char const   *)cp, tmp___34);
    }
#line 388
    break;
    case 20: 
#line 391
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: \"randomseed\" option is obsolete.\n",
            filename, linenum);
#line 393
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 394
    break;
    case 6: 
#line 397
    intptr = & options___0->permit_root_login;
#line 398
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 399
    if (! cp) {
#line 400
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing yes/without-password/no argument.\n",
              filename, linenum);
#line 402
      exit(1);
    }
#line 404
    if (0) {
#line 404
      __s1_len___1 = strlen((char const   *)cp);
#line 404
      __s2_len___1 = strlen("without-password");
#line 404
      if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
        goto _L___4;
      } else {
#line 404
        if (__s1_len___1 >= 4U) {
          _L___4: /* CIL Label */ 
#line 404
          if (! ((unsigned int )((void const   *)("without-password" + 1)) - (unsigned int )((void const   *)"without-password") == 1U)) {
#line 404
            tmp___64 = 1;
          } else {
#line 404
            if (__s2_len___1 >= 4U) {
#line 404
              tmp___64 = 1;
            } else {
#line 404
              tmp___64 = 0;
            }
          }
        } else {
#line 404
          tmp___64 = 0;
        }
      }
#line 404
      if (tmp___64) {
#line 404
        tmp___60 = __builtin_strcmp((char const   *)cp, "without-password");
      } else {
#line 404
        tmp___63 = __builtin_strcmp((char const   *)cp, "without-password");
#line 404
        tmp___60 = tmp___63;
      }
    } else {
#line 404
      tmp___63 = __builtin_strcmp((char const   *)cp, "without-password");
#line 404
      tmp___60 = tmp___63;
    }
#line 404
    if (tmp___60 == 0) {
#line 405
      value = 2;
    } else {
#line 406
      if (0) {
#line 406
        __s1_len___0 = strlen((char const   *)cp);
#line 406
        __s2_len___0 = strlen("yes");
#line 406
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___2;
        } else {
#line 406
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 406
            if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 406
              tmp___54 = 1;
            } else {
#line 406
              if (__s2_len___0 >= 4U) {
#line 406
                tmp___54 = 1;
              } else {
#line 406
                tmp___54 = 0;
              }
            }
          } else {
#line 406
            tmp___54 = 0;
          }
        }
#line 406
        if (tmp___54) {
#line 406
          tmp___50 = __builtin_strcmp((char const   *)cp, "yes");
        } else {
#line 406
          tmp___53 = __builtin_strcmp((char const   *)cp, "yes");
#line 406
          tmp___50 = tmp___53;
        }
      } else {
#line 406
        tmp___53 = __builtin_strcmp((char const   *)cp, "yes");
#line 406
        tmp___50 = tmp___53;
      }
#line 406
      if (tmp___50 == 0) {
#line 407
        value = 1;
      } else {
#line 408
        if (0) {
#line 408
          __s1_len = strlen((char const   *)cp);
#line 408
          __s2_len = strlen("no");
#line 408
          if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
            goto _L___0;
          } else {
#line 408
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 408
              if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 408
                tmp___44 = 1;
              } else {
#line 408
                if (__s2_len >= 4U) {
#line 408
                  tmp___44 = 1;
                } else {
#line 408
                  tmp___44 = 0;
                }
              }
            } else {
#line 408
              tmp___44 = 0;
            }
          }
#line 408
          if (tmp___44) {
#line 408
            tmp___40 = __builtin_strcmp((char const   *)cp, "no");
          } else {
#line 408
            tmp___43 = __builtin_strcmp((char const   *)cp, "no");
#line 408
            tmp___40 = tmp___43;
          }
        } else {
#line 408
          tmp___43 = __builtin_strcmp((char const   *)cp, "no");
#line 408
          tmp___40 = tmp___43;
        }
#line 408
        if (tmp___40 == 0) {
#line 409
          value = 0;
        } else {
#line 411
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: Bad yes/without-password/no argument: %s\n",
                  filename, linenum, cp);
#line 413
          exit(1);
        }
      }
    }
#line 415
    if (*intptr == -1) {
#line 416
      *intptr = value;
    }
#line 417
    break;
    case 15: 
#line 420
    intptr = & options___0->ignore_rhosts;
    parse_flag: 
#line 422
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 423
    if (! cp) {
#line 424
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing yes/no argument.\n",
              filename, linenum);
#line 426
      exit(1);
    }
#line 428
    if (0) {
#line 428
      __s1_len___3 = strlen((char const   *)cp);
#line 428
      __s2_len___3 = strlen("yes");
#line 428
      if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
        goto _L___8;
      } else {
#line 428
        if (__s1_len___3 >= 4U) {
          _L___8: /* CIL Label */ 
#line 428
          if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 428
            tmp___84 = 1;
          } else {
#line 428
            if (__s2_len___3 >= 4U) {
#line 428
              tmp___84 = 1;
            } else {
#line 428
              tmp___84 = 0;
            }
          }
        } else {
#line 428
          tmp___84 = 0;
        }
      }
#line 428
      if (tmp___84) {
#line 428
        tmp___80 = __builtin_strcmp((char const   *)cp, "yes");
      } else {
#line 428
        tmp___83 = __builtin_strcmp((char const   *)cp, "yes");
#line 428
        tmp___80 = tmp___83;
      }
    } else {
#line 428
      tmp___83 = __builtin_strcmp((char const   *)cp, "yes");
#line 428
      tmp___80 = tmp___83;
    }
#line 428
    if (tmp___80 == 0) {
#line 429
      value = 1;
    } else {
#line 430
      if (0) {
#line 430
        __s1_len___2 = strlen((char const   *)cp);
#line 430
        __s2_len___2 = strlen("no");
#line 430
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___6;
        } else {
#line 430
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 430
            if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 430
              tmp___74 = 1;
            } else {
#line 430
              if (__s2_len___2 >= 4U) {
#line 430
                tmp___74 = 1;
              } else {
#line 430
                tmp___74 = 0;
              }
            }
          } else {
#line 430
            tmp___74 = 0;
          }
        }
#line 430
        if (tmp___74) {
#line 430
          tmp___70 = __builtin_strcmp((char const   *)cp, "no");
        } else {
#line 430
          tmp___73 = __builtin_strcmp((char const   *)cp, "no");
#line 430
          tmp___70 = tmp___73;
        }
      } else {
#line 430
        tmp___73 = __builtin_strcmp((char const   *)cp, "no");
#line 430
        tmp___70 = tmp___73;
      }
#line 430
      if (tmp___70 == 0) {
#line 431
        value = 0;
      } else {
#line 433
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: Bad yes/no argument: %s\n",
                filename, linenum, cp);
#line 435
        exit(1);
      }
    }
#line 437
    if (*intptr == -1) {
#line 438
      *intptr = value;
    }
#line 439
    break;
    case 28: 
#line 442
    intptr = & options___0->ignore_user_known_hosts;
    goto parse_flag;
    case 9: 
#line 446
    intptr = & options___0->rhosts_authentication;
    goto parse_flag;
    case 10: 
#line 450
    intptr = & options___0->rhosts_rsa_authentication;
    goto parse_flag;
    case 11: 
#line 454
    intptr = & options___0->rsa_authentication;
    goto parse_flag;
    case 34: 
#line 458
    intptr = & options___0->dsa_authentication;
    goto parse_flag;
    case 12: 
#line 486
    intptr = & options___0->password_authentication;
    goto parse_flag;
    case 22: 
#line 490
    intptr = & options___0->check_mail;
    goto parse_flag;
    case 14: 
#line 500
    intptr = & options___0->print_motd;
    goto parse_flag;
    case 16: 
#line 504
    intptr = & options___0->x11_forwarding;
    goto parse_flag;
    case 17: 
#line 508
    intptr = & options___0->x11_display_offset;
    goto parse_int;
    case 18: 
#line 512
    intptr = & options___0->strict_modes;
    goto parse_flag;
    case 21: 
#line 516
    intptr = & options___0->keepalives;
    goto parse_flag;
    case 19: 
#line 520
    intptr = & options___0->permit_empty_passwd;
    goto parse_flag;
    case 23: 
#line 524
    intptr = & options___0->use_login;
    goto parse_flag;
    case 33: 
#line 528
    intptr = & options___0->gateway_ports;
    goto parse_flag;
    case 7: 
#line 532
    intptr = (int *)(& options___0->log_facility);
#line 533
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 534
    tmp___85 = log_facility_number(cp);
#line 534
    value = (int )tmp___85;
#line 535
    if (value == (int )((enum __anonenum_SyslogFacility_72 )-1)) {
#line 536
      if (cp) {
#line 536
        tmp___86 = (char const   *)cp;
      } else {
#line 536
        tmp___86 = "<NONE>";
      }
#line 536
      fatal("%.200s line %d: unsupported log facility \'%s\'\n", filename, linenum,
            tmp___86);
    }
#line 538
    if (*intptr == -1) {
#line 539
      *intptr = (int )((enum __anonenum_SyslogFacility_72 )value);
    }
#line 540
    break;
    case 8: 
#line 543
    intptr = (int *)(& options___0->log_level);
#line 544
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 545
    tmp___87 = log_level_number(cp);
#line 545
    value = (int )tmp___87;
#line 546
    if (value == (int )((enum __anonenum_LogLevel_73 )-1)) {
#line 547
      if (cp) {
#line 547
        tmp___88 = (char const   *)cp;
      } else {
#line 547
        tmp___88 = "<NONE>";
      }
#line 547
      fatal("%.200s line %d: unsupported log level \'%s\'\n", filename, linenum, tmp___88);
    }
#line 549
    if (*intptr == -1) {
#line 550
      *intptr = (int )((enum __anonenum_LogLevel_73 )value);
    }
#line 551
    break;
    case 24: 
#line 554
    while (1) {
#line 554
      cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 554
      if (! cp) {
#line 554
        break;
      }
#line 555
      if (options___0->num_allow_users >= 256U) {
#line 556
        fatal("%s line %d: too many allow users.\n", filename, linenum);
      }
#line 558
      tmp___89 = options___0->num_allow_users;
#line 558
      (options___0->num_allow_users) ++;
#line 558
      options___0->allow_users[tmp___89] = xstrdup((char const   *)cp);
    }
#line 560
    break;
    case 25: 
#line 563
    while (1) {
#line 563
      cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 563
      if (! cp) {
#line 563
        break;
      }
#line 564
      if (options___0->num_deny_users >= 256U) {
#line 565
        fatal("%s line %d: too many deny users.\n", filename, linenum);
      }
#line 567
      tmp___90 = options___0->num_deny_users;
#line 567
      (options___0->num_deny_users) ++;
#line 567
      options___0->deny_users[tmp___90] = xstrdup((char const   *)cp);
    }
#line 569
    break;
    case 26: 
#line 572
    while (1) {
#line 572
      cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 572
      if (! cp) {
#line 572
        break;
      }
#line 573
      if (options___0->num_allow_groups >= 256U) {
#line 574
        fatal("%s line %d: too many allow groups.\n", filename, linenum);
      }
#line 576
      tmp___91 = options___0->num_allow_groups;
#line 576
      (options___0->num_allow_groups) ++;
#line 576
      options___0->allow_groups[tmp___91] = xstrdup((char const   *)cp);
    }
#line 578
    break;
    case 27: 
#line 581
    while (1) {
#line 581
      cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 581
      if (! cp) {
#line 581
        break;
      }
#line 582
      if (options___0->num_deny_groups >= 256U) {
#line 583
        fatal("%s line %d: too many deny groups.\n", filename, linenum);
      }
#line 585
      tmp___92 = options___0->num_deny_groups;
#line 585
      (options___0->num_deny_groups) ++;
#line 585
      options___0->deny_groups[tmp___92] = xstrdup((char const   *)cp);
    }
#line 587
    break;
    case 30: 
#line 590
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 591
    if (! cp) {
#line 592
      fatal("%s line %d: Missing argument.", filename, linenum);
    }
#line 593
    tmp___94 = ciphers_valid((char const   *)cp);
#line 593
    if (! tmp___94) {
#line 594
      if (cp) {
#line 594
        tmp___93 = (char const   *)cp;
      } else {
#line 594
        tmp___93 = "<NONE>";
      }
#line 594
      fatal("%s line %d: Bad SSH2 cipher spec \'%s\'.", filename, linenum, tmp___93);
    }
#line 596
    if ((unsigned int )options___0->ciphers == (unsigned int )((void *)0)) {
#line 597
      options___0->ciphers = xstrdup((char const   *)cp);
    }
#line 598
    break;
    case 31: 
#line 601
    intptr = & options___0->protocol;
#line 602
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 603
    if (! cp) {
#line 604
      fatal("%s line %d: Missing argument.", filename, linenum);
    }
#line 605
    value = proto_spec((char const   *)cp);
#line 606
    if (value == 0) {
#line 607
      if (cp) {
#line 607
        tmp___95 = (char const   *)cp;
      } else {
#line 607
        tmp___95 = "<NONE>";
      }
#line 607
      fatal("%s line %d: Bad protocol spec \'%s\'.", filename, linenum, tmp___95);
    }
#line 609
    if (*intptr == 0) {
#line 610
      *intptr = value;
    }
#line 611
    break;
    default: 
#line 614
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: Missing handler for opcode %s (%d)\n",
            filename, linenum, cp, opcode);
#line 616
    exit(1);
    }
#line 618
    tmp___96 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 618
    if ((unsigned int )tmp___96 != (unsigned int )((void *)0)) {
#line 619
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: garbage at end of line.\n",
              filename, linenum);
#line 621
      exit(1);
    }
  }
#line 624
  fclose(f);
#line 625
  if (bad_options > 0) {
#line 626
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: terminating, %d bad configuration options\n",
            filename, bad_options);
#line 628
    exit(1);
  }
#line 630
  return;
}
}
#line 1 "serverloop.o"
#pragma merger(0,"./serverloop.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 116 "/usr/include/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 502 "ssh.h"
void server_loop(pid_t pid , int fdin_arg , int fdout_arg , int fderr_arg ) ;
#line 503
void server_loop2(void) ;
#line 9 "session.h"
int session_open(int chanid ) ;
#line 10
void session_input_channel_req(int id , void *arg ) ;
#line 11
void session_close_by_pid(pid_t pid , int status ) ;
#line 12
void session_close_by_channel(int id , void *arg ) ;
#line 27 "serverloop.c"
static Buffer stdin_buffer  ;
#line 28 "serverloop.c"
static Buffer stdout_buffer  ;
#line 29 "serverloop.c"
static Buffer stderr_buffer  ;
#line 30 "serverloop.c"
static int fdin  ;
#line 31 "serverloop.c"
static int fdout  ;
#line 33 "serverloop.c"
static int fderr  ;
#line 34 "serverloop.c"
static long stdin_bytes  =    0L;
#line 35 "serverloop.c"
static long stdout_bytes  =    0L;
#line 36 "serverloop.c"
static long stderr_bytes  =    0L;
#line 37 "serverloop.c"
static long fdout_bytes  =    0L;
#line 38 "serverloop.c"
static int stdin_eof  =    0;
#line 39 "serverloop.c"
static int fdout_eof  =    0;
#line 40 "serverloop.c"
static int fderr_eof  =    0;
#line 41 "serverloop.c"
static int connection_in___0  ;
#line 42 "serverloop.c"
static int connection_out___0  ;
#line 43 "serverloop.c"
static unsigned int buffer_high  ;
#line 44 "serverloop.c"
static int max_fd  ;
#line 55 "serverloop.c"
static pid_t child_pid  ;
#line 56 "serverloop.c"
static int volatile   child_terminated  ;
#line 57 "serverloop.c"
static int volatile   child_has_selected  ;
#line 58 "serverloop.c"
static int volatile   child_wait_status  ;
#line 60
void server_init_dispatch(void) ;
#line 62 "serverloop.c"
void sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  pid_t wait_pid ;
  union __anonunion_77 __constr_expr_0 ;
  union __anonunion_78 __constr_expr_1 ;
  int *tmp___0 ;

  {
#line 65
  tmp = __errno_location();
#line 65
  save_errno = *tmp;
#line 68
  debug("Received SIGCHLD.");
#line 69
  wait_pid = wait((union wait *)((int *)(& child_wait_status)));
#line 70
  if (wait_pid != -1) {
#line 71
    if (wait_pid != child_pid) {
#line 72
      error("Strange, got SIGCHLD and wait returned pid %d but child is %d", wait_pid,
            child_pid);
    }
#line 74
    __constr_expr_0.__in = child_wait_status;
#line 74
    if ((__constr_expr_0.__i & 127) == 0) {
#line 76
      child_terminated = (int volatile   )1;
    } else {
#line 74
      __constr_expr_1.__in = child_wait_status;
#line 74
      if ((int )((signed char )((__constr_expr_1.__i & 127) + 1)) >> 1 > 0) {
#line 76
        child_terminated = (int volatile   )1;
      }
    }
#line 77
    child_has_selected = (int volatile   )0;
  }
#line 79
  signal(17, & sigchld_handler);
#line 80
  tmp___0 = __errno_location();
#line 80
  *tmp___0 = save_errno;
#line 81
  return;
}
}
#line 82 "serverloop.c"
void sigchld_handler2(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 85
  tmp = __errno_location();
#line 85
  save_errno = *tmp;
#line 86
  debug("Received SIGCHLD.");
#line 87
  child_terminated = (int volatile   )1;
#line 88
  tmp___0 = __errno_location();
#line 88
  *tmp___0 = save_errno;
#line 89
  return;
}
}
#line 95 "serverloop.c"
void make_packets_from_stderr_data(void) 
{ int len ;
  unsigned int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
#line 101
  while (1) {
#line 101
    tmp___2 = buffer_len(& stderr_buffer);
#line 101
    if (tmp___2 > 0U) {
#line 101
      tmp___3 = packet_not_very_much_data_to_write();
#line 101
      if (! tmp___3) {
#line 101
        break;
      }
    } else {
#line 101
      break;
    }
#line 103
    tmp = buffer_len(& stderr_buffer);
#line 103
    len = (int )tmp;
#line 104
    tmp___0 = packet_is_interactive();
#line 104
    if (tmp___0) {
#line 105
      if (len > 512) {
#line 106
        len = 512;
      }
    } else {
#line 109
      if (len > max_packet_size) {
#line 110
        len = max_packet_size;
      }
    }
#line 112
    packet_start(18);
#line 113
    tmp___1 = buffer_ptr(& stderr_buffer);
#line 113
    packet_put_string((char const   *)tmp___1, (unsigned int )len);
#line 114
    packet_send();
#line 115
    buffer_consume(& stderr_buffer, (unsigned int )len);
#line 116
    stderr_bytes += (long )len;
  }
#line 118
  return;
}
}
#line 124 "serverloop.c"
void make_packets_from_stdout_data(void) 
{ int len ;
  unsigned int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
#line 130
  while (1) {
#line 130
    tmp___2 = buffer_len(& stdout_buffer);
#line 130
    if (tmp___2 > 0U) {
#line 130
      tmp___3 = packet_not_very_much_data_to_write();
#line 130
      if (! tmp___3) {
#line 130
        break;
      }
    } else {
#line 130
      break;
    }
#line 132
    tmp = buffer_len(& stdout_buffer);
#line 132
    len = (int )tmp;
#line 133
    tmp___0 = packet_is_interactive();
#line 133
    if (tmp___0) {
#line 134
      if (len > 512) {
#line 135
        len = 512;
      }
    } else {
#line 138
      if (len > max_packet_size) {
#line 139
        len = max_packet_size;
      }
    }
#line 141
    packet_start(17);
#line 142
    tmp___1 = buffer_ptr(& stdout_buffer);
#line 142
    packet_put_string((char const   *)tmp___1, (unsigned int )len);
#line 143
    packet_send();
#line 144
    buffer_consume(& stdout_buffer, (unsigned int )len);
#line 145
    stdout_bytes += (long )len;
  }
#line 147
  return;
}
}
#line 155 "serverloop.c"
void wait_until_can_do_something(fd_set *readset , fd_set *writeset , unsigned int max_time_milliseconds ) 
{ struct timeval tv ;
  struct timeval *tvp ;
  int ret ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;

  {
  retry_select: 
#line 166
  while (1) {
#line 166
    __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readset->__fds_bits[0]): "memory");
#line 166
    break;
  }
#line 167
  while (1) {
#line 167
    __asm__  volatile   ("cld; rep; stosl": "=c" (__d0___0), "=D" (__d1___0): "a" (0),
                         "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& writeset->__fds_bits[0]): "memory");
#line 167
    break;
  }
#line 169
  if (compat20) {
#line 171
    tmp = channel_not_very_much_buffered_data();
#line 171
    if (tmp) {
#line 172
      __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
  } else {
#line 178
    tmp___0 = buffer_len(& stdin_buffer);
#line 178
    if (tmp___0 < buffer_high) {
#line 178
      tmp___1 = channel_not_very_much_buffered_data();
#line 178
      if (tmp___1) {
#line 180
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
#line 185
    tmp___2 = packet_not_very_much_data_to_write();
#line 185
    if (tmp___2) {
#line 186
      if (! fdout_eof) {
#line 187
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
#line 188
      if (! fderr_eof) {
#line 189
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
#line 195
    if (fdin != -1) {
#line 195
      tmp___3 = buffer_len(& stdin_buffer);
#line 195
      if (tmp___3 > 0U) {
#line 196
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
  }
#line 199
  channel_prepare_select(readset, writeset);
#line 205
  tmp___4 = packet_have_data_to_write();
#line 205
  if (tmp___4) {
#line 206
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 209
  tmp___5 = channel_max_fd();
#line 209
  if (tmp___5 > max_fd) {
#line 210
    max_fd = channel_max_fd();
  }
#line 216
  if (child_terminated) {
#line 216
    tmp___6 = packet_not_very_much_data_to_write();
#line 216
    if (tmp___6) {
#line 217
      if (max_time_milliseconds == 0U) {
#line 218
        max_time_milliseconds = 100U;
      }
    }
  }
#line 220
  if (max_time_milliseconds == 0U) {
#line 221
    tvp = (struct timeval *)((void *)0);
  } else {
#line 223
    tv.tv_sec = (long )(max_time_milliseconds / 1000U);
#line 224
    tv.tv_usec = (long )(1000U * (max_time_milliseconds % 1000U));
#line 225
    tvp = & tv;
  }
#line 227
  if ((unsigned int )tvp != (unsigned int )((void *)0)) {
#line 228
    debug("tvp!=NULL kid %d mili %d", child_terminated, max_time_milliseconds);
  }
#line 231
  ret = select(max_fd + 1, (fd_set * __restrict  )readset, (fd_set * __restrict  )writeset,
               (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )tvp);
#line 233
  if (ret < 0) {
#line 234
    tmp___9 = __errno_location();
#line 234
    if (*tmp___9 != 4) {
#line 235
      tmp___7 = __errno_location();
#line 235
      tmp___8 = strerror(*tmp___7);
#line 235
      error("select: %.100s", tmp___8);
    } else {
      goto retry_select;
    }
  }
#line 240
  if (child_terminated) {
#line 241
    child_has_selected = (int volatile   )1;
  }
#line 242
  return;
}
}
#line 248 "serverloop.c"
void process_input(fd_set *readset ) 
{ int len ;
  char buf___1[16384] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  register char __result ;
  int *tmp___3 ;
  int *tmp___4 ;
  register char __result___0 ;
  int *tmp___5 ;
  int *tmp___6 ;
  register char __result___1 ;

  {
#line 255
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 255
  if (__result) {
#line 256
    len = read(connection_in___0, (void *)(buf___1), sizeof(buf___1));
#line 257
    if (len == 0) {
#line 258
      verbose("Connection closed by remote host.");
#line 259
      fatal_cleanup();
    } else {
#line 260
      if (len < 0) {
#line 261
        tmp___1 = __errno_location();
#line 261
        if (*tmp___1 != 4) {
#line 261
          tmp___2 = __errno_location();
#line 261
          if (*tmp___2 != 11) {
#line 262
            tmp = __errno_location();
#line 262
            tmp___0 = strerror(*tmp);
#line 262
            verbose("Read error from remote host: %.100s", tmp___0);
#line 263
            fatal_cleanup();
          }
        }
      } else {
#line 267
        packet_process_incoming((char const   *)(buf___1), (unsigned int )len);
      }
    }
  }
#line 270
  if (compat20) {
#line 271
    return;
  }
#line 274
  if (! fdout_eof) {
#line 274
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "cc");
#line 274
    if (__result___0) {
#line 275
      len = read(fdout, (void *)(buf___1), sizeof(buf___1));
#line 276
      if (len < 0) {
#line 276
        tmp___3 = __errno_location();
#line 276
        if (! (*tmp___3 == 4)) {
#line 276
          tmp___4 = __errno_location();
#line 276
          if (! (*tmp___4 == 11)) {
            goto _L;
          }
        }
      } else {
        _L: /* CIL Label */ 
#line 278
        if (len <= 0) {
#line 279
          fdout_eof = 1;
        } else {
#line 281
          buffer_append(& stdout_buffer, (char const   *)(buf___1), (unsigned int )len);
#line 282
          fdout_bytes += (long )len;
        }
      }
    }
  }
#line 286
  if (! fderr_eof) {
#line 286
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___1): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "cc");
#line 286
    if (__result___1) {
#line 287
      len = read(fderr, (void *)(buf___1), sizeof(buf___1));
#line 288
      if (len < 0) {
#line 288
        tmp___5 = __errno_location();
#line 288
        if (! (*tmp___5 == 4)) {
#line 288
          tmp___6 = __errno_location();
#line 288
          if (! (*tmp___6 == 11)) {
            goto _L___0;
          }
        }
      } else {
        _L___0: /* CIL Label */ 
#line 290
        if (len <= 0) {
#line 291
          fderr_eof = 1;
        } else {
#line 293
          buffer_append(& stderr_buffer, (char const   *)(buf___1), (unsigned int )len);
        }
      }
    }
  }
#line 296
  return;
}
}
#line 301 "serverloop.c"
void process_output(fd_set *writeset ) 
{ int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  register char __result ;
  register char __result___0 ;

  {
#line 307
  if (! compat20) {
#line 307
    if (fdin != -1) {
#line 307
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))),
                           "m" (writeset->__fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "cc");
#line 307
      if (__result) {
#line 308
        tmp = buffer_len(& stdin_buffer);
#line 308
        tmp___0 = buffer_ptr(& stdin_buffer);
#line 308
        len = write(fdin, (void const   *)tmp___0, tmp);
#line 310
        if (len < 0) {
#line 310
          tmp___1 = __errno_location();
#line 310
          if (! (*tmp___1 == 4)) {
#line 310
            tmp___2 = __errno_location();
#line 310
            if (! (*tmp___2 == 11)) {
              goto _L;
            }
          }
        } else {
          _L: /* CIL Label */ 
#line 312
          if (len <= 0) {
#line 316
            if (fdin != fdout) {
#line 317
              close(fdin);
            } else {
#line 319
              shutdown(fdin, 1);
            }
#line 321
            fdin = -1;
          } else {
#line 324
            buffer_consume(& stdin_buffer, (unsigned int )len);
#line 326
            stdin_bytes += (long )len;
          }
        }
      }
    }
  }
#line 330
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->__fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 330
  if (__result___0) {
#line 331
    packet_write_poll();
  }
#line 332
  return;
}
}
#line 338 "serverloop.c"
void drain_output(void) 
{ unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;

  {
#line 342
  tmp___2 = buffer_len(& stdout_buffer);
#line 342
  if (tmp___2 > 0U) {
#line 343
    packet_start(17);
#line 344
    tmp = buffer_len(& stdout_buffer);
#line 344
    tmp___0 = buffer_ptr(& stdout_buffer);
#line 344
    packet_put_string((char const   *)tmp___0, tmp);
#line 346
    packet_send();
#line 348
    tmp___1 = buffer_len(& stdout_buffer);
#line 348
    stdout_bytes = (long )((unsigned long )stdout_bytes + (unsigned long )tmp___1);
  }
#line 351
  tmp___6 = buffer_len(& stderr_buffer);
#line 351
  if (tmp___6 > 0U) {
#line 352
    packet_start(18);
#line 353
    tmp___3 = buffer_len(& stderr_buffer);
#line 353
    tmp___4 = buffer_ptr(& stderr_buffer);
#line 353
    packet_put_string((char const   *)tmp___4, tmp___3);
#line 355
    packet_send();
#line 357
    tmp___5 = buffer_len(& stderr_buffer);
#line 357
    stderr_bytes = (long )((unsigned long )stderr_bytes + (unsigned long )tmp___5);
  }
#line 360
  packet_write_wait();
#line 361
  return;
}
}
#line 363 "serverloop.c"
void process_buffered_input_packets(void) 
{ 

  {
#line 366
  dispatch_run(1, (int *)((void *)0));
#line 367
  return;
}
}
#line 376 "serverloop.c"
void server_loop(pid_t pid , int fdin_arg , int fdout_arg , int fderr_arg ) 
{ fd_set readset ;
  fd_set writeset ;
  int wait_status ;
  pid_t wait_pid ;
  int waiting_termination ;
  unsigned int max_time_milliseconds ;
  unsigned int previous_stdout_buffer_bytes ;
  unsigned int stdout_buffer_bytes ;
  int type ;
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *s ;
  char *cp ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  union __anonunion_79 __constr_expr_0 ;
  union __anonunion_80 __constr_expr_1 ;
  int plen ;
  union __anonunion_81 __constr_expr_2 ;
  union __anonunion_82 __constr_expr_3 ;
  union __anonunion_83 __constr_expr_4 ;

  {
#line 382
  waiting_termination = 0;
#line 388
  debug("Entering interactive session.");
#line 391
  child_pid = pid;
#line 392
  child_terminated = (int volatile   )0;
#line 393
  child_has_selected = (int volatile   )0;
#line 394
  signal(17, & sigchld_handler);
#line 397
  fdin = fdin_arg;
#line 398
  fdout = fdout_arg;
#line 399
  fderr = fderr_arg;
#line 402
  set_nonblock(fdin);
#line 403
  set_nonblock(fdout);
#line 405
  if (fderr != -1) {
#line 406
    set_nonblock(fderr);
  }
#line 408
  connection_in___0 = packet_get_connection_in();
#line 409
  connection_out___0 = packet_get_connection_out();
#line 411
  previous_stdout_buffer_bytes = 0U;
#line 414
  tmp = packet_is_interactive();
#line 414
  if (tmp) {
#line 415
    buffer_high = 4096U;
  } else {
#line 417
    buffer_high = 65536U;
  }
#line 420
  max_fd = fdin;
#line 421
  if (fdout > max_fd) {
#line 422
    max_fd = fdout;
  }
#line 423
  if (fderr != -1) {
#line 423
    if (fderr > max_fd) {
#line 424
      max_fd = fderr;
    }
  }
#line 425
  if (connection_in___0 > max_fd) {
#line 426
    max_fd = connection_in___0;
  }
#line 427
  if (connection_out___0 > max_fd) {
#line 428
    max_fd = connection_out___0;
  }
#line 431
  buffer_init(& stdin_buffer);
#line 432
  buffer_init(& stdout_buffer);
#line 433
  buffer_init(& stderr_buffer);
#line 441
  if (fderr == -1) {
#line 442
    fderr_eof = 1;
  }
#line 444
  server_init_dispatch();
#line 447
  while (1) {
#line 450
    process_buffered_input_packets();
#line 456
    if (stdin_eof) {
#line 456
      if (fdin != -1) {
#line 456
        tmp___0 = buffer_len(& stdin_buffer);
#line 456
        if (tmp___0 == 0U) {
#line 460
          if (fdin != fdout) {
#line 461
            close(fdin);
          } else {
#line 463
            shutdown(fdin, 1);
          }
#line 465
          fdin = -1;
        }
      }
    }
#line 468
    make_packets_from_stderr_data();
#line 477
    max_time_milliseconds = 0U;
#line 478
    stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 479
    if (stdout_buffer_bytes != 0U) {
#line 479
      if (stdout_buffer_bytes < 256U) {
#line 479
        if (stdout_buffer_bytes != previous_stdout_buffer_bytes) {
#line 482
          max_time_milliseconds = 10U;
        } else {
#line 485
          make_packets_from_stdout_data();
        }
      } else {
#line 485
        make_packets_from_stdout_data();
      }
    } else {
#line 485
      make_packets_from_stdout_data();
    }
#line 487
    previous_stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 490
    tmp___1 = packet_not_very_much_data_to_write();
#line 490
    if (tmp___1) {
#line 491
      channel_output_poll();
    }
#line 498
    if (fdout_eof) {
#line 498
      if (fderr_eof) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 498
      if (child_terminated) {
#line 498
        if (child_has_selected) {
          _L: /* CIL Label */ 
#line 498
          tmp___5 = packet_have_data_to_write();
#line 498
          if (! tmp___5) {
#line 498
            tmp___6 = buffer_len(& stdout_buffer);
#line 498
            if (tmp___6 == 0U) {
#line 498
              tmp___7 = buffer_len(& stderr_buffer);
#line 498
              if (tmp___7 == 0U) {
#line 503
                tmp___2 = channel_still_open();
#line 503
                if (! tmp___2) {
#line 504
                  break;
                }
#line 505
                if (! waiting_termination) {
#line 506
                  s = "Waiting for forwarded connections to terminate...\r\n";
#line 508
                  waiting_termination = 1;
#line 509
                  tmp___3 = strlen(s);
#line 509
                  buffer_append(& stderr_buffer, s, tmp___3);
#line 512
                  cp = channel_open_message();
#line 513
                  tmp___4 = strlen((char const   *)cp);
#line 513
                  buffer_append(& stderr_buffer, (char const   *)cp, tmp___4);
#line 514
                  xfree((void *)cp);
                }
              }
            }
          }
        }
      }
    }
#line 518
    wait_until_can_do_something(& readset, & writeset, max_time_milliseconds);
#line 522
    channel_after_select(& readset, & writeset);
#line 525
    process_input(& readset);
#line 528
    process_output(& writeset);
  }
#line 534
  drain_output();
#line 536
  debug("End of interactive session; stdin %ld, stdout (read %ld, sent %ld), stderr %ld bytes.",
        stdin_bytes, fdout_bytes, stdout_bytes, stderr_bytes);
#line 540
  buffer_free(& stdin_buffer);
#line 541
  buffer_free(& stdout_buffer);
#line 542
  buffer_free(& stderr_buffer);
#line 545
  if (fdout != -1) {
#line 546
    close(fdout);
  }
#line 547
  fdout = -1;
#line 548
  fdout_eof = 1;
#line 549
  if (fderr != -1) {
#line 550
    close(fderr);
  }
#line 551
  fderr = -1;
#line 552
  fderr_eof = 1;
#line 553
  if (fdin != -1) {
#line 554
    close(fdin);
  }
#line 555
  fdin = -1;
#line 558
  channel_stop_listening();
#line 561
  wait_pid = wait((union wait *)(& wait_status));
#line 562
  if (wait_pid < 0) {
#line 568
    if (child_terminated) {
#line 569
      wait_status = (int )child_wait_status;
    } else {
#line 571
      tmp___8 = __errno_location();
#line 571
      tmp___9 = strerror(*tmp___8);
#line 571
      packet_disconnect("wait: %.100s", tmp___9);
    }
  } else {
#line 574
    if (wait_pid != pid) {
#line 575
      error("Strange, wait returned pid %d, expected %d", wait_pid, pid);
    }
  }
#line 580
  signal(17, (void (*)(int  ))0);
#line 583
  __constr_expr_2.__in = wait_status;
#line 583
  if ((__constr_expr_2.__i & 127) == 0) {
#line 585
    __constr_expr_0.__in = wait_status;
#line 585
    debug("Command exited with status %d.", (__constr_expr_0.__i & 65280) >> 8);
#line 586
    packet_start(20);
#line 587
    __constr_expr_1.__in = wait_status;
#line 587
    packet_put_int((unsigned int )((__constr_expr_1.__i & 65280) >> 8));
#line 588
    packet_send();
#line 589
    packet_write_wait();
#line 598
    while (1) {
#line 600
      type = packet_read(& plen);
#line 598
      if (! (type != 33)) {
#line 598
        break;
      }
    }
#line 604
    debug("Received exit confirmation.");
#line 605
    return;
  }
#line 608
  __constr_expr_4.__in = wait_status;
#line 608
  if ((int )((signed char )((__constr_expr_4.__i & 127) + 1)) >> 1 > 0) {
#line 609
    __constr_expr_3.__in = wait_status;
#line 609
    packet_disconnect("Command terminated on signal %d.", __constr_expr_3.__i & 127);
  }
#line 613
  packet_disconnect("wait returned status %04x.", wait_status);
#line 615
  return;
}
}
#line 617 "serverloop.c"
void server_loop2(void) 
{ fd_set readset ;
  fd_set writeset ;
  int had_channel ;
  int status ;
  pid_t pid ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 621
  had_channel = 0;
#line 625
  debug("Entering interactive session for SSH2.");
#line 627
  signal(17, & sigchld_handler2);
#line 628
  child_terminated = (int volatile   )0;
#line 629
  connection_in___0 = packet_get_connection_in();
#line 630
  connection_out___0 = packet_get_connection_out();
#line 631
  max_fd = connection_in___0;
#line 632
  if (connection_out___0 > max_fd) {
#line 633
    max_fd = connection_out___0;
  }
#line 634
  server_init_dispatch();
#line 636
  while (1) {
#line 637
    process_buffered_input_packets();
#line 638
    if (! had_channel) {
#line 638
      tmp = channel_still_open();
#line 638
      if (tmp) {
#line 639
        had_channel = 1;
      }
    }
#line 640
    if (had_channel) {
#line 640
      tmp___0 = channel_still_open();
#line 640
      if (! tmp___0) {
#line 641
        debug("!channel_still_open.");
#line 642
        break;
      }
    }
#line 644
    tmp___1 = packet_not_very_much_data_to_write();
#line 644
    if (tmp___1) {
#line 645
      channel_output_poll();
    }
#line 646
    wait_until_can_do_something(& readset, & writeset, 0U);
#line 647
    if (child_terminated) {
#line 648
      while (1) {
#line 648
        pid = waitpid(-1, & status, 1);
#line 648
        if (! (pid > 0)) {
#line 648
          break;
        }
#line 649
        session_close_by_pid(pid, status);
      }
#line 650
      child_terminated = (int volatile   )0;
#line 651
      signal(17, & sigchld_handler2);
    }
#line 653
    channel_after_select(& readset, & writeset);
#line 654
    process_input(& readset);
#line 655
    process_output(& writeset);
  }
#line 657
  signal(17, (void (*)(int  ))0);
#line 658
  while (1) {
#line 658
    pid = waitpid(-1, & status, 1);
#line 658
    if (! (pid > 0)) {
#line 658
      break;
    }
#line 659
    session_close_by_pid(pid, status);
  }
#line 660
  channel_stop_listening();
#line 661
  return;
}
}
#line 663 "serverloop.c"
void server_input_stdin_data(int type , int plen ) 
{ char *data ;
  unsigned int data_len ;
  int _p ;
  int _e ;

  {
#line 671
  if (fdin == -1) {
#line 672
    return;
  }
#line 673
  data = packet_get_string(& data_len);
#line 674
  while (1) {
#line 674
    _p = plen;
#line 674
    _e = (int )(4U + data_len);
#line 674
    if (_p != _e) {
#line 674
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "serverloop.c", 674);
#line 674
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 674
    break;
  }
#line 675
  buffer_append(& stdin_buffer, (char const   *)data, data_len);
#line 676
  memset((void *)data, 0, data_len);
#line 677
  xfree((void *)data);
#line 678
  return;
}
}
#line 680 "serverloop.c"
void server_input_eof(int type , int plen ) 
{ int _p ;
  int _e ;

  {
#line 688
  debug("EOF received for stdin.");
#line 689
  while (1) {
#line 689
    _p = plen;
#line 689
    _e = 0;
#line 689
    if (_p != _e) {
#line 689
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "serverloop.c", 689);
#line 689
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 689
    break;
  }
#line 690
  stdin_eof = 1;
#line 691
  return;
}
}
#line 693 "serverloop.c"
void server_input_window_size(int type , int plen ) 
{ int row ;
  unsigned int tmp ;
  int col ;
  unsigned int tmp___0 ;
  int xpixel ;
  unsigned int tmp___1 ;
  int ypixel ;
  unsigned int tmp___2 ;
  int _p ;
  int _e ;

  {
#line 696
  tmp = packet_get_int();
#line 696
  row = (int )tmp;
#line 697
  tmp___0 = packet_get_int();
#line 697
  col = (int )tmp___0;
#line 698
  tmp___1 = packet_get_int();
#line 698
  xpixel = (int )tmp___1;
#line 699
  tmp___2 = packet_get_int();
#line 699
  ypixel = (int )tmp___2;
#line 701
  debug("Window change received.");
#line 702
  while (1) {
#line 702
    _p = plen;
#line 702
    _e = 16;
#line 702
    if (_p != _e) {
#line 702
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "serverloop.c", 702);
#line 702
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 702
    break;
  }
#line 703
  if (fdin != -1) {
#line 704
    pty_change_window_size(fdin, row, col, xpixel, ypixel);
  }
#line 705
  return;
}
}
#line 707 "serverloop.c"
int input_direct_tcpip(void) 
{ int sock ;
  char *target ;
  char *originator ;
  int target_port ;
  int originator_port ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int _len ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 714
  target = packet_get_string((unsigned int *)((void *)0));
#line 715
  tmp = packet_get_int();
#line 715
  target_port = (int )tmp;
#line 716
  originator = packet_get_string((unsigned int *)((void *)0));
#line 717
  tmp___0 = packet_get_int();
#line 717
  originator_port = (int )tmp___0;
#line 718
  while (1) {
#line 718
    tmp___1 = packet_remaining();
#line 718
    _len = tmp___1;
#line 718
    if (_len > 0) {
#line 718
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
          718);
#line 718
      packet_disconnect("Packet integrity error.");
    }
#line 718
    break;
  }
#line 720
  debug("open direct-tcpip: from %s port %d to %s port %d", originator, originator_port,
        target, target_port);
#line 723
  sock = channel_connect_to((char const   *)target, (unsigned short )target_port);
#line 724
  xfree((void *)target);
#line 725
  xfree((void *)originator);
#line 726
  if (sock < 0) {
#line 727
    return (-1);
  }
#line 728
  tmp___2 = xstrdup("direct-tcpip");
#line 728
  tmp___3 = channel_new((char *)"direct-tcpip", 4, sock, sock, -1, 4096, 32768, 0,
                        tmp___2);
#line 728
  return (tmp___3);
}
}
#line 732 "serverloop.c"
void server_input_channel_open(int type , int plen ) 
{ Channel *c ;
  char *ctype ;
  int id ;
  unsigned int len ;
  int rchan ;
  int rmaxpack ;
  int rwindow ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  int _len ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___10 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;

  {
#line 735
  c = (Channel *)((void *)0);
#line 743
  ctype = packet_get_string(& len);
#line 744
  tmp = packet_get_int();
#line 744
  rchan = (int )tmp;
#line 745
  tmp___0 = packet_get_int();
#line 745
  rwindow = (int )tmp___0;
#line 746
  tmp___1 = packet_get_int();
#line 746
  rmaxpack = (int )tmp___1;
#line 748
  debug("channel_input_open: ctype %s rchan %d win %d max %d", ctype, rchan, rwindow,
        rmaxpack);
#line 751
  if (0) {
#line 751
    __s1_len___0 = strlen((char const   *)ctype);
#line 751
    __s2_len___0 = strlen("session");
#line 751
    if (! ((unsigned int )((void const   *)(ctype + 1)) - (unsigned int )((void const   *)ctype) == 1U)) {
      goto _L___2;
    } else {
#line 751
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 751
        if (! ((unsigned int )((void const   *)("session" + 1)) - (unsigned int )((void const   *)"session") == 1U)) {
#line 751
          tmp___24 = 1;
        } else {
#line 751
          if (__s2_len___0 >= 4U) {
#line 751
            tmp___24 = 1;
          } else {
#line 751
            tmp___24 = 0;
          }
        }
      } else {
#line 751
        tmp___24 = 0;
      }
    }
#line 751
    if (tmp___24) {
#line 751
      tmp___20 = __builtin_strcmp((char const   *)ctype, "session");
    } else {
#line 751
      tmp___23 = __builtin_strcmp((char const   *)ctype, "session");
#line 751
      tmp___20 = tmp___23;
    }
  } else {
#line 751
    tmp___23 = __builtin_strcmp((char const   *)ctype, "session");
#line 751
    tmp___20 = tmp___23;
  }
#line 751
  if (tmp___20 == 0) {
#line 752
    debug("open session");
#line 753
    while (1) {
#line 753
      tmp___2 = packet_remaining();
#line 753
      _len = tmp___2;
#line 753
      if (_len > 0) {
#line 753
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
            753);
#line 753
        packet_disconnect("Packet integrity error.");
      }
#line 753
      break;
    }
#line 761
    tmp___3 = xstrdup("server-session");
#line 761
    id = channel_new(ctype, 10, -1, -1, -1, 0, 32768, 0, tmp___3);
#line 763
    tmp___4 = session_open(id);
#line 763
    if (tmp___4 == 1) {
#line 764
      channel_register_callback(id, 98, & session_input_channel_req, (void *)0);
#line 766
      channel_register_cleanup(id, & session_close_by_channel);
#line 767
      c = channel_lookup(id);
    } else {
#line 769
      debug("session open failed, free channel %d", id);
#line 770
      channel_free(id);
    }
  } else {
#line 772
    if (0) {
#line 772
      __s1_len = strlen((char const   *)ctype);
#line 772
      __s2_len = strlen("direct-tcpip");
#line 772
      if (! ((unsigned int )((void const   *)(ctype + 1)) - (unsigned int )((void const   *)ctype) == 1U)) {
        goto _L___0;
      } else {
#line 772
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 772
          if (! ((unsigned int )((void const   *)("direct-tcpip" + 1)) - (unsigned int )((void const   *)"direct-tcpip") == 1U)) {
#line 772
            tmp___14 = 1;
          } else {
#line 772
            if (__s2_len >= 4U) {
#line 772
              tmp___14 = 1;
            } else {
#line 772
              tmp___14 = 0;
            }
          }
        } else {
#line 772
          tmp___14 = 0;
        }
      }
#line 772
      if (tmp___14) {
#line 772
        tmp___10 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
      } else {
#line 772
        tmp___13 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
#line 772
        tmp___10 = tmp___13;
      }
    } else {
#line 772
      tmp___13 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
#line 772
      tmp___10 = tmp___13;
    }
#line 772
    if (tmp___10 == 0) {
#line 773
      id = input_direct_tcpip();
#line 774
      if (id >= 0) {
#line 775
        c = channel_lookup(id);
      }
    }
  }
#line 777
  if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 778
    debug("confirm %s", ctype);
#line 779
    c->remote_id = rchan;
#line 780
    c->remote_window = rwindow;
#line 781
    c->remote_maxpacket = rmaxpack;
#line 783
    packet_start(91);
#line 784
    packet_put_int((unsigned int )c->remote_id);
#line 785
    packet_put_int((unsigned int )c->self);
#line 786
    packet_put_int((unsigned int )c->local_window);
#line 787
    packet_put_int((unsigned int )c->local_maxpacket);
#line 788
    packet_send();
  } else {
#line 790
    debug("failure %s", ctype);
#line 791
    packet_start(92);
#line 792
    packet_put_int((unsigned int )rchan);
#line 793
    packet_put_int(1U);
#line 794
    packet_put_cstring("bla bla");
#line 795
    packet_put_cstring("");
#line 796
    packet_send();
  }
#line 798
  xfree((void *)ctype);
#line 799
  return;
}
}
#line 801 "serverloop.c"
void server_init_dispatch_20(void) 
{ 

  {
#line 804
  debug("server_init_dispatch_20");
#line 805
  dispatch_init(& dispatch_protocol_error);
#line 806
  dispatch_set(97, & channel_input_oclose);
#line 807
  dispatch_set(94, & channel_input_data);
#line 808
  dispatch_set(96, & channel_input_ieof);
#line 809
  dispatch_set(95, & channel_input_extended_data);
#line 810
  dispatch_set(90, & server_input_channel_open);
#line 811
  dispatch_set(91, & channel_input_open_confirmation);
#line 812
  dispatch_set(92, & channel_input_open_failure);
#line 813
  dispatch_set(98, & channel_input_channel_request);
#line 814
  dispatch_set(93, & channel_input_window_adjust);
#line 815
  return;
}
}
#line 816 "serverloop.c"
void server_init_dispatch_13(void) 
{ 

  {
#line 819
  debug("server_init_dispatch_13");
#line 820
  dispatch_init((dispatch_fn *)((void *)0));
#line 821
  dispatch_set(19, & server_input_eof);
#line 822
  dispatch_set(16, & server_input_stdin_data);
#line 823
  dispatch_set(11, & server_input_window_size);
#line 824
  dispatch_set(24, & channel_input_close);
#line 825
  dispatch_set(25, & channel_input_close_confirmation);
#line 826
  dispatch_set(23, & channel_input_data);
#line 827
  dispatch_set(21, & channel_input_open_confirmation);
#line 828
  dispatch_set(22, & channel_input_open_failure);
#line 829
  dispatch_set(29, & channel_input_port_open);
#line 830
  return;
}
}
#line 831 "serverloop.c"
void server_init_dispatch_15(void) 
{ 

  {
#line 834
  server_init_dispatch_13();
#line 835
  debug("server_init_dispatch_15");
#line 836
  dispatch_set(24, & channel_input_ieof);
#line 837
  dispatch_set(25, & channel_input_oclose);
#line 838
  return;
}
}
#line 839 "serverloop.c"
void server_init_dispatch(void) 
{ 

  {
#line 842
  if (compat20) {
#line 843
    server_init_dispatch_20();
  } else {
#line 844
    if (compat13) {
#line 845
      server_init_dispatch_13();
    } else {
#line 847
      server_init_dispatch_15();
    }
  }
#line 848
  return;
}
}
#line 1 "bsd-login.o"
#pragma merger(0,"./bsd-login.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "md5crypt.o"
#pragma merger(0,"./md5crypt.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "session.o"
#pragma merger(0,"./session.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 106 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socketpair(int __domain , int __type , int __protocol ,
                                                    int *__fds ) ;
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 84 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strcpy(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 194
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 142 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 590
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 774
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 780
extern int pclose(FILE *__stream ) ;
#line 79 "/usr/include/pwd.h"
extern void endpwent(void) ;
#line 69 "/usr/include/grp.h"
extern void endgrent(void) ;
#line 199
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 493 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 504
extern  __attribute__((__nothrow__)) int execve(char const   *__path , char * const  *__argv ,
                                                char * const  *__envp )  __attribute__((__nonnull__(1))) ;
#line 526
extern  __attribute__((__nothrow__)) int execl(char const   *__path , char const   *__arg 
                                               , ...)  __attribute__((__nonnull__(1))) ;
#line 684
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 257 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 57 "session.c"
Session *session_new(void) ;
#line 58
void session_set_fds(Session *s , int fdin___0 , int fdout___0 , int fderr___0 ) ;
#line 59
void session_pty_cleanup(Session *s ) ;
#line 60
void session_proctitle(Session *s ) ;
#line 61
void do_exec_pty(Session *s , char const   *command , struct passwd *pw ) ;
#line 62
void do_exec_no_pty(Session *s , char const   *command , struct passwd *pw ) ;
#line 64
void do_child(char const   *command , struct passwd *pw , char const   *term , char const   *display ,
              char const   *auth_proto , char const   *auth_data , char const   *ttyname___0 ) ;
#line 81 "session.c"
static char *xauthfile  ;
#line 85 "session.c"
Session sessions[10]  ;
#line 92 "session.c"
int no_port_forwarding_flag  =    0;
#line 93 "session.c"
int no_agent_forwarding_flag  =    0;
#line 94 "session.c"
int no_x11_forwarding_flag  =    0;
#line 95 "session.c"
int no_pty_flag  =    0;
#line 98 "session.c"
char *forced_command  =    (char *)((void *)0);
#line 101 "session.c"
struct envstring *custom_environment  =    (struct envstring *)((void *)0);
#line 106 "session.c"
void xauthfile_cleanup_proc(void *ignore ) 
{ char *p ;

  {
#line 109
  debug("xauthfile_cleanup_proc called");
#line 111
  if ((unsigned int )xauthfile != (unsigned int )((void *)0)) {
#line 113
    unlink((char const   *)xauthfile);
#line 114
    p = strrchr((char const   *)xauthfile, '/');
#line 115
    if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 116
      *p = (char )'\000';
#line 117
      rmdir((char const   *)xauthfile);
    }
#line 119
    xfree((void *)xauthfile);
#line 120
    xauthfile = (char *)((void *)0);
  }
#line 122
  return;
}
}
#line 128 "session.c"
void pty_cleanup_proc(void *session ) 
{ Session *s ;

  {
#line 131
  s = (Session *)session;
#line 132
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 133
    fatal("pty_cleanup_proc: no session");
  }
#line 134
  debug("pty_cleanup_proc: %s", s->tty);
#line 136
  if (s->pid != 0) {
#line 138
    record_logout(s->pid, (char const   *)(s->tty));
  }
#line 142
  pty_release((char const   *)(s->tty));
#line 143
  return;
}
}
#line 151 "session.c"
void do_authenticated(struct passwd *pw ) 
{ Session *s ;
  int type ;
  int compression_level ;
  int enable_compression_after_reply ;
  int have_pty ;
  char *command ;
  int n_bytes ;
  int plen ;
  unsigned int proto_len ;
  unsigned int data_len ;
  unsigned int dlen ;
  int success ;
  int _p ;
  int _e ;
  unsigned int tmp ;
  int tmp___0 ;
  int _p___0 ;
  int _e___0 ;
  size_t tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  int _p___1 ;
  int _e___1 ;
  int _p___2 ;
  int _e___2 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  void *tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  unsigned int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int _p___3 ;
  int _e___3 ;
  int _p___4 ;
  int _e___4 ;
  int tmp___25 ;

  {
#line 156
  compression_level = 0;
#line 156
  enable_compression_after_reply = 0;
#line 157
  have_pty = 0;
#line 167
  alarm(0U);
#line 176
  if (! no_port_forwarding_flag) {
#line 177
    channel_permit_all_opens();
  }
#line 179
  s = session_new();
#line 180
  s->pw = pw;
#line 186
  while (1) {
#line 187
    success = 0;
#line 190
    type = packet_read(& plen);
#line 193
    switch (type) {
    case 37: 
#line 195
    while (1) {
#line 195
      _p = plen;
#line 195
      _e = 4;
#line 195
      if (_p != _e) {
#line 195
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "session.c", 195);
#line 195
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 195
      break;
    }
#line 196
    tmp = packet_get_int();
#line 196
    compression_level = (int )tmp;
#line 197
    if (compression_level < 1) {
#line 198
      packet_send_debug("Received illegal compression level %d.", compression_level);
#line 200
      break;
    } else {
#line 197
      if (compression_level > 9) {
#line 198
        packet_send_debug("Received illegal compression level %d.", compression_level);
#line 200
        break;
      }
    }
#line 203
    enable_compression_after_reply = 1;
#line 204
    success = 1;
#line 205
    break;
    case 10: 
#line 208
    if (no_pty_flag) {
#line 209
      debug("Allocating a pty not permitted for this authentication.");
#line 210
      break;
    }
#line 212
    if (have_pty) {
#line 213
      packet_disconnect("Protocol error: you already have a pty.");
    }
#line 215
    debug("Allocating pty.");
#line 218
    tmp___0 = pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, (int )sizeof(s->tty));
#line 218
    if (! tmp___0) {
#line 220
      error("Failed to allocate pty.");
#line 221
      break;
    }
#line 223
    fatal_add_cleanup(& pty_cleanup_proc, (void *)s);
#line 224
    pty_setowner(pw, (char const   *)(s->tty));
#line 227
    s->term = packet_get_string(& dlen);
#line 228
    while (1) {
#line 228
      _p___0 = (int )dlen;
#line 228
      tmp___1 = strlen((char const   *)s->term);
#line 228
      _e___0 = (int )tmp___1;
#line 228
      if (_p___0 != _e___0) {
#line 228
        log("Packet integrity error (%d != %d) at %s:%d", _p___0, _e___0, "session.c",
            228);
#line 228
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 228
      break;
    }
#line 231
    n_bytes = (int )((unsigned int )plen - ((4U + dlen) + 16U));
#line 233
    if (0) {
#line 233
      __s1_len = strlen((char const   *)s->term);
#line 233
      __s2_len = strlen("");
#line 233
      if (! ((unsigned int )((void const   *)(s->term + 1)) - (unsigned int )((void const   *)s->term) == 1U)) {
        goto _L___0;
      } else {
#line 233
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 233
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 233
            tmp___11 = 1;
          } else {
#line 233
            if (__s2_len >= 4U) {
#line 233
              tmp___11 = 1;
            } else {
#line 233
              tmp___11 = 0;
            }
          }
        } else {
#line 233
          tmp___11 = 0;
        }
      }
#line 233
      if (tmp___11) {
#line 233
        tmp___7 = __builtin_strcmp((char const   *)s->term, "");
      } else {
#line 233
        tmp___10 = __builtin_strcmp((char const   *)s->term, "");
#line 233
        tmp___7 = tmp___10;
      }
    } else {
#line 233
      tmp___10 = __builtin_strcmp((char const   *)s->term, "");
#line 233
      tmp___7 = tmp___10;
    }
#line 233
    if (tmp___7 == 0) {
#line 234
      xfree((void *)s->term);
#line 235
      s->term = (char *)((void *)0);
    }
#line 238
    tmp___12 = packet_get_int();
#line 238
    s->row = (int )tmp___12;
#line 239
    tmp___13 = packet_get_int();
#line 239
    s->col = (int )tmp___13;
#line 240
    tmp___14 = packet_get_int();
#line 240
    s->xpixel = (int )tmp___14;
#line 241
    tmp___15 = packet_get_int();
#line 241
    s->ypixel = (int )tmp___15;
#line 242
    pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);
#line 245
    tty_parse_modes(s->ttyfd, & n_bytes);
#line 246
    while (1) {
#line 246
      _p___1 = plen;
#line 246
      _e___1 = (int )(((4U + dlen) + 16U) + (unsigned int )n_bytes);
#line 246
      if (_p___1 != _e___1) {
#line 246
        log("Packet integrity error (%d != %d) at %s:%d", _p___1, _e___1, "session.c",
            246);
#line 246
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 246
      break;
    }
#line 248
    session_proctitle(s);
#line 251
    success = 1;
#line 252
    have_pty = 1;
#line 253
    break;
    case 34: 
#line 256
    if (! options.x11_forwarding) {
#line 257
      packet_send_debug("X11 forwarding disabled in server configuration file.");
#line 258
      break;
    }
#line 261
    if (no_x11_forwarding_flag) {
#line 262
      packet_send_debug("X11 forwarding not permitted for this authentication.");
#line 263
      break;
    }
#line 265
    debug("Received request for X11 forwarding with auth spoofing.");
#line 266
    if ((unsigned int )s->display != (unsigned int )((void *)0)) {
#line 267
      packet_disconnect("Protocol error: X11 display already set.");
    }
#line 269
    s->auth_proto = packet_get_string(& proto_len);
#line 270
    s->auth_data = packet_get_string(& data_len);
#line 271
    while (1) {
#line 271
      _p___2 = plen;
#line 271
      _e___2 = (int )((((4U + proto_len) + 4U) + data_len) + 4U);
#line 271
      if (_p___2 != _e___2) {
#line 271
        log("Packet integrity error (%d != %d) at %s:%d", _p___2, _e___2, "session.c",
            271);
#line 271
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 271
      break;
    }
#line 273
    tmp___17 = packet_get_protocol_flags();
#line 273
    if (tmp___17 & 1U) {
#line 274
      tmp___16 = packet_get_int();
#line 274
      s->screen = (int )tmp___16;
    } else {
#line 276
      s->screen = 0;
    }
#line 277
    s->display = x11_create_display_inet(s->screen, options.x11_display_offset);
#line 279
    if ((unsigned int )s->display == (unsigned int )((void *)0)) {
#line 280
      break;
    }
#line 283
    tmp___18 = xmalloc(4096U);
#line 283
    xauthfile = (char *)tmp___18;
#line 284
    strlcpy(xauthfile, "/tmp/ssh-XXXXXXXX", 4096U);
#line 285
    temporarily_use_uid(pw->pw_uid);
#line 286
    tmp___21 = mkdtemp(xauthfile);
#line 286
    if ((unsigned int )tmp___21 == (unsigned int )((void *)0)) {
#line 287
      restore_uid();
#line 288
      tmp___19 = __errno_location();
#line 288
      tmp___20 = strerror(*tmp___19);
#line 288
      error("private X11 dir: mkdtemp %s failed: %s", xauthfile, tmp___20);
#line 290
      xfree((void *)xauthfile);
#line 291
      xauthfile = (char *)((void *)0);
#line 293
      break;
    }
#line 295
    strlcat(xauthfile, "/cookies", 4096U);
#line 296
    open((char const   *)xauthfile, 194, 384);
#line 297
    restore_uid();
#line 298
    fatal_add_cleanup(& xauthfile_cleanup_proc, (void *)0);
#line 299
    success = 1;
#line 300
    break;
    case 30: 
#line 307
    if (no_agent_forwarding_flag) {
#line 308
      debug("Authentication agent forwarding not permitted for this authentication.");
#line 309
      break;
    } else {
#line 307
      if (compat13) {
#line 308
        debug("Authentication agent forwarding not permitted for this authentication.");
#line 309
        break;
      }
    }
#line 311
    debug("Received authentication agent forwarding request.");
#line 312
    auth_input_request_forwarding(pw);
#line 313
    success = 1;
#line 314
    break;
    case 28: 
#line 317
    if (no_port_forwarding_flag) {
#line 318
      debug("Port forwarding not permitted for this authentication.");
#line 319
      break;
    }
#line 321
    debug("Received TCP/IP port forwarding request.");
#line 322
    channel_input_port_forward_request(pw->pw_uid == 0U, options.gateway_ports);
#line 323
    success = 1;
#line 324
    break;
    case 38: 
#line 327
    tmp___22 = packet_get_int();
#line 327
    tmp___23 = packet_set_maxsize((int )tmp___22);
#line 327
    if (tmp___23 > 0) {
#line 328
      success = 1;
    }
#line 329
    break;
    case 12: 
    case 13: 
#line 334
    if (have_pty) {
#line 334
      tmp___24 = 1;
    } else {
#line 334
      if ((unsigned int )s->display != (unsigned int )((void *)0)) {
#line 334
        tmp___24 = 1;
      } else {
#line 334
        tmp___24 = 0;
      }
    }
#line 334
    packet_set_interactive(tmp___24, options.keepalives);
#line 337
    if (type == 13) {
#line 338
      command = packet_get_string(& dlen);
#line 339
      debug("Exec command \'%.500s\'", command);
#line 340
      while (1) {
#line 340
        _p___3 = plen;
#line 340
        _e___3 = (int )(4U + dlen);
#line 340
        if (_p___3 != _e___3) {
#line 340
          log("Packet integrity error (%d != %d) at %s:%d", _p___3, _e___3, "session.c",
              340);
#line 340
          packet_disconnect("Packet integrity error. (%d)", type);
        }
#line 340
        break;
      }
    } else {
#line 342
      command = (char *)((void *)0);
#line 343
      while (1) {
#line 343
        _p___4 = plen;
#line 343
        _e___4 = 0;
#line 343
        if (_p___4 != _e___4) {
#line 343
          log("Packet integrity error (%d != %d) at %s:%d", _p___4, _e___4, "session.c",
              343);
#line 343
          packet_disconnect("Packet integrity error. (%d)", type);
        }
#line 343
        break;
      }
    }
#line 345
    if ((unsigned int )forced_command != (unsigned int )((void *)0)) {
#line 346
      command = forced_command;
#line 347
      debug("Forced command \'%.500s\'", forced_command);
    }
#line 349
    if (have_pty) {
#line 350
      do_exec_pty(s, (char const   *)command, pw);
    } else {
#line 352
      do_exec_no_pty(s, (char const   *)command, pw);
    }
#line 354
    if ((unsigned int )command != (unsigned int )((void *)0)) {
#line 355
      xfree((void *)command);
    }
#line 357
    if (xauthfile) {
#line 358
      xauthfile_cleanup_proc((void *)0);
    }
#line 359
    return;
    default: 
#line 366
    log("Unknown packet type received after authentication: %d", type);
    }
#line 368
    if (success) {
#line 368
      tmp___25 = 14;
    } else {
#line 368
      tmp___25 = 15;
    }
#line 368
    packet_start(tmp___25);
#line 369
    packet_send();
#line 370
    packet_write_wait();
#line 373
    if (enable_compression_after_reply) {
#line 374
      enable_compression_after_reply = 0;
#line 375
      packet_start_compression(compression_level);
    }
  }
}
}
#line 385 "session.c"
void do_exec_no_pty(Session *s , char const   *command , struct passwd *pw ) 
{ int pid ;
  int inout[2] ;
  int err[2] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  __pid_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
#line 399
  tmp___1 = socketpair(1, 1, 0, (int *)(inout));
#line 399
  if (tmp___1 < 0) {
#line 401
    tmp = __errno_location();
#line 401
    tmp___0 = strerror(*tmp);
#line 401
    packet_disconnect("Could not create socket pairs: %.100s", tmp___0);
  } else {
#line 399
    tmp___2 = socketpair(1, 1, 0, (int *)(err));
#line 399
    if (tmp___2 < 0) {
#line 401
      tmp = __errno_location();
#line 401
      tmp___0 = strerror(*tmp);
#line 401
      packet_disconnect("Could not create socket pairs: %.100s", tmp___0);
    }
  }
#line 404
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 405
    fatal("do_exec_no_pty: no session");
  }
#line 407
  session_proctitle(s);
#line 410
  do_pam_setcred();
#line 414
  pid = fork();
#line 414
  if (pid == 0) {
#line 416
    log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 422
    tmp___5 = setsid();
#line 422
    if (tmp___5 < 0) {
#line 423
      tmp___3 = __errno_location();
#line 423
      tmp___4 = strerror(*tmp___3);
#line 423
      error("setsid failed: %.100s", tmp___4);
    }
#line 452
    close(inout[1]);
#line 453
    close(err[1]);
#line 454
    tmp___6 = dup2(inout[0], 0);
#line 454
    if (tmp___6 < 0) {
#line 455
      perror("dup2 stdin");
    }
#line 456
    tmp___7 = dup2(inout[0], 1);
#line 456
    if (tmp___7 < 0) {
#line 457
      perror("dup2 stdout");
    }
#line 458
    tmp___8 = dup2(err[0], 2);
#line 458
    if (tmp___8 < 0) {
#line 459
      perror("dup2 stderr");
    }
#line 463
    do_child(command, pw, (char const   *)((void *)0), (char const   *)s->display,
             (char const   *)s->auth_proto, (char const   *)s->auth_data, (char const   *)((void *)0));
  }
#line 466
  if (pid < 0) {
#line 467
    tmp___9 = __errno_location();
#line 467
    tmp___10 = strerror(*tmp___9);
#line 467
    packet_disconnect("fork failed: %.100s", tmp___10);
  }
#line 468
  s->pid = pid;
#line 484
  close(inout[0]);
#line 485
  close(err[0]);
#line 491
  if (compat20) {
#line 492
    if (s->extended) {
#line 492
      tmp___11 = err[1];
    } else {
#line 492
      tmp___11 = -1;
    }
#line 492
    session_set_fds(s, inout[1], inout[1], tmp___11);
  } else {
#line 494
    server_loop(pid, inout[1], inout[1], err[1]);
  }
#line 498
  return;
}
}
#line 506 "session.c"
void do_exec_pty(Session *s , char const   *command , struct passwd *pw ) 
{ FILE *f ;
  char buf___1[100] ;
  char *time_string ;
  char line[256] ;
  char const   *hostname ;
  int fdout___0 ;
  int ptyfd ;
  int ttyfd ;
  int ptymaster ;
  int quiet_login ;
  pid_t pid ;
  socklen_t fromlen ;
  struct sockaddr_storage from ;
  struct stat st ;
  time_t last_login_time ;
  unsigned long tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *tmp___19 ;
  char *tmp___21 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___27 ;
  int tmp___30 ;
  int tmp___31 ;
  char *tmp___32 ;
  int *tmp___33 ;
  char *tmp___34 ;
  int *tmp___35 ;
  char *tmp___36 ;
  int *tmp___37 ;
  char *tmp___38 ;

  {
#line 521
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 522
    fatal("do_exec_pty: no session");
  }
#line 523
  ptyfd = s->ptyfd;
#line 524
  ttyfd = s->ttyfd;
#line 527
  hostname = get_canonical_hostname();
#line 533
  if (! options.use_login) {
#line 534
    tmp = get_last_login_time(pw->pw_uid, (char const   *)pw->pw_name, buf___1, sizeof(buf___1));
#line 534
    last_login_time = (long )tmp;
  }
#line 539
  do_pam_session(pw->pw_name, (char const   *)(s->tty));
#line 540
  do_pam_setcred();
#line 544
  pid = fork();
#line 544
  if (pid == 0) {
#line 545
    pid = getpid();
#line 549
    log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 552
    close(ptyfd);
#line 555
    pty_make_controlling_tty(& ttyfd, (char const   *)(s->tty));
#line 558
    tmp___2 = fileno(stdin);
#line 558
    tmp___3 = dup2(ttyfd, tmp___2);
#line 558
    if (tmp___3 < 0) {
#line 559
      tmp___0 = __errno_location();
#line 559
      tmp___1 = strerror(*tmp___0);
#line 559
      error("dup2 stdin failed: %.100s", tmp___1);
    }
#line 562
    tmp___6 = fileno(stdout);
#line 562
    tmp___7 = dup2(ttyfd, tmp___6);
#line 562
    if (tmp___7 < 0) {
#line 563
      tmp___4 = __errno_location();
#line 563
      tmp___5 = strerror(*tmp___4);
#line 563
      error("dup2 stdin failed: %.100s", tmp___5);
    }
#line 566
    tmp___10 = fileno(stderr);
#line 566
    tmp___11 = dup2(ttyfd, tmp___10);
#line 566
    if (tmp___11 < 0) {
#line 567
      tmp___8 = __errno_location();
#line 567
      tmp___9 = strerror(*tmp___8);
#line 567
      error("dup2 stdin failed: %.100s", tmp___9);
    }
#line 570
    close(ttyfd);
#line 578
    memset((void *)(& from), 0, sizeof(from));
#line 579
    tmp___16 = packet_connection_is_on_socket();
#line 579
    if (tmp___16) {
#line 580
      fromlen = sizeof(from);
#line 581
      tmp___14 = packet_get_connection_in();
#line 581
      tmp___15 = getpeername(tmp___14, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                             (socklen_t * __restrict  )(& fromlen));
#line 581
      if (tmp___15 < 0) {
#line 583
        tmp___12 = __errno_location();
#line 583
        tmp___13 = strerror(*tmp___12);
#line 583
        debug("getpeername: %.100s", tmp___13);
#line 584
        fatal_cleanup();
      }
    }
#line 588
    record_login(pid, (char const   *)(s->tty), (char const   *)pw->pw_name, pw->pw_uid,
                 hostname, (struct sockaddr *)(& from));
#line 592
    snprintf((char * __restrict  )(line), sizeof(line), (char const   * __restrict  )"%.200s/.hushlogin",
             pw->pw_dir);
#line 593
    tmp___17 = stat((char const   * __restrict  )(line), (struct stat * __restrict  )(& st));
#line 593
    quiet_login = tmp___17 >= 0;
#line 596
    if (! quiet_login) {
#line 597
      print_pam_messages();
    }
#line 608
    if ((unsigned int )command == (unsigned int )((void *)0)) {
#line 608
      if (last_login_time != 0L) {
#line 608
        if (! quiet_login) {
#line 608
          if (! options.use_login) {
#line 611
            time_string = ctime((time_t const   *)(& last_login_time));
#line 613
            tmp___21 = __builtin_strchr(time_string, '\n');
#line 613
            if (tmp___21) {
#line 614
              tmp___19 = __builtin_strchr(time_string, '\n');
#line 614
              *tmp___19 = (char)0;
            }
#line 617
            if (0) {
#line 617
              __s1_len = strlen((char const   *)(buf___1));
#line 617
              __s2_len = strlen("");
#line 617
              if (! ((unsigned int )((void const   *)(buf___1 + 1)) - (unsigned int )((void const   *)(buf___1)) == 1U)) {
                goto _L___0;
              } else {
#line 617
                if (__s1_len >= 4U) {
                  _L___0: /* CIL Label */ 
#line 617
                  if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 617
                    tmp___31 = 1;
                  } else {
#line 617
                    if (__s2_len >= 4U) {
#line 617
                      tmp___31 = 1;
                    } else {
#line 617
                      tmp___31 = 0;
                    }
                  }
                } else {
#line 617
                  tmp___31 = 0;
                }
              }
#line 617
              if (tmp___31) {
#line 617
                tmp___27 = __builtin_strcmp((char const   *)(buf___1), "");
              } else {
#line 617
                tmp___30 = __builtin_strcmp((char const   *)(buf___1), "");
#line 617
                tmp___27 = tmp___30;
              }
            } else {
#line 617
              tmp___30 = __builtin_strcmp((char const   *)(buf___1), "");
#line 617
              tmp___27 = tmp___30;
            }
#line 617
            if (tmp___27 == 0) {
#line 618
              printf((char const   * __restrict  )"Last login: %s\r\n", time_string);
            } else {
#line 620
              printf((char const   * __restrict  )"Last login: %s from %s\r\n", time_string,
                     buf___1);
            }
          }
        }
      }
    }
#line 628
    if ((unsigned int )command == (unsigned int )((void *)0)) {
#line 628
      if (options.print_motd) {
#line 628
        if (! quiet_login) {
#line 628
          if (! options.use_login) {
#line 631
            f = fopen((char const   * __restrict  )"/etc/motd", (char const   * __restrict  )"r");
#line 632
            if (f) {
#line 633
              while (1) {
#line 633
                tmp___32 = fgets((char * __restrict  )(line), (int )sizeof(line),
                                 (FILE * __restrict  )f);
#line 633
                if (! tmp___32) {
#line 633
                  break;
                }
#line 634
                fputs((char const   * __restrict  )(line), (FILE * __restrict  )stdout);
              }
#line 635
              fclose(f);
            }
          }
        }
      }
    }
#line 648
    do_child(command, pw, (char const   *)s->term, (char const   *)s->display, (char const   *)s->auth_proto,
             (char const   *)s->auth_data, (char const   *)(s->tty));
  }
#line 652
  if (pid < 0) {
#line 653
    tmp___33 = __errno_location();
#line 653
    tmp___34 = strerror(*tmp___33);
#line 653
    packet_disconnect("fork failed: %.100s", tmp___34);
  }
#line 654
  s->pid = pid;
#line 657
  close(ttyfd);
#line 664
  fdout___0 = dup(ptyfd);
#line 665
  if (fdout___0 < 0) {
#line 666
    tmp___35 = __errno_location();
#line 666
    tmp___36 = strerror(*tmp___35);
#line 666
    packet_disconnect("dup #1 failed: %.100s", tmp___36);
  }
#line 669
  ptymaster = dup(ptyfd);
#line 670
  if (ptymaster < 0) {
#line 671
    tmp___37 = __errno_location();
#line 671
    tmp___38 = strerror(*tmp___37);
#line 671
    packet_disconnect("dup #2 failed: %.100s", tmp___38);
  }
#line 672
  s->ptymaster = ptymaster;
#line 675
  if (compat20) {
#line 676
    session_set_fds(s, ptyfd, fdout___0, -1);
  } else {
#line 678
    server_loop(pid, ptyfd, fdout___0, -1);
#line 680
    session_pty_cleanup(s);
  }
#line 682
  return;
}
}
#line 688 "session.c"
void child_set_env(char ***envp , unsigned int *envsizep , char const   *name , char const   *value ) 
{ unsigned int i ;
  unsigned int namelen ;
  char **env ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  void *tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  void *tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;

  {
#line 700
  env = *envp;
#line 701
  namelen = strlen(name);
#line 702
  i = 0U;
#line 702
  while (*(env + i)) {
#line 703
    if (0) {
#line 703
      if (0) {
#line 703
        __s1_len___0 = strlen((char const   *)*(env + i));
#line 703
        __s2_len___0 = strlen(name);
#line 703
        if (! ((unsigned int )((void const   *)(*(env + i) + 1)) - (unsigned int )((void const   *)*(env + i)) == 1U)) {
          goto _L___2;
        } else {
#line 703
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 703
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
#line 703
              tmp___22 = 1;
            } else {
#line 703
              if (__s2_len___0 >= 4U) {
#line 703
                tmp___22 = 1;
              } else {
#line 703
                tmp___22 = 0;
              }
            }
          } else {
#line 703
            tmp___22 = 0;
          }
        }
#line 703
        if (tmp___22) {
#line 703
          tmp___18 = __builtin_strcmp((char const   *)*(env + i), name);
        } else {
#line 703
          tmp___21 = __builtin_strcmp((char const   *)*(env + i), name);
#line 703
          tmp___18 = tmp___21;
        }
      } else {
#line 703
        tmp___21 = __builtin_strcmp((char const   *)*(env + i), name);
#line 703
        tmp___18 = tmp___21;
      }
#line 703
      tmp___12 = tmp___18;
    } else {
#line 703
      tmp___12 = strncmp((char const   *)*(env + i), name, namelen);
    }
#line 703
    if (tmp___12 == 0) {
#line 703
      if ((int )*(*(env + i) + namelen) == 61) {
#line 704
        break;
      }
    }
#line 702
    i ++;
  }
#line 705
  if (*(env + i)) {
#line 707
    xfree((void *)*(env + i));
  } else {
#line 710
    if (i >= *envsizep - 1U) {
#line 711
      *envsizep += 50U;
#line 712
      tmp___25 = xrealloc((void *)env, *envsizep * sizeof(char *));
#line 712
      *envp = (char **)tmp___25;
#line 712
      env = *envp;
    }
#line 715
    *(env + (i + 1U)) = (char *)((void *)0);
  }
#line 719
  tmp___26 = strlen(name);
#line 719
  tmp___27 = strlen(value);
#line 719
  tmp___28 = xmalloc(((tmp___26 + 1U) + tmp___27) + 1U);
#line 719
  *(env + i) = (char *)tmp___28;
#line 720
  tmp___29 = strlen(name);
#line 720
  tmp___30 = strlen(value);
#line 720
  snprintf((char * __restrict  )*(env + i), ((tmp___29 + 1U) + tmp___30) + 1U, (char const   * __restrict  )"%s=%s",
           name, value);
#line 721
  return;
}
}
#line 729 "session.c"
void read_environment_file(char ***env , unsigned int *envsize , char const   *filename ) 
{ FILE *f ;
  char buf___1[4096] ;
  char *cp ;
  char *value ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 737
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 738
  if (! f) {
#line 739
    return;
  }
#line 741
  while (1) {
#line 741
    tmp___5 = fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )f);
#line 741
    if (! tmp___5) {
#line 741
      break;
    }
#line 742
    cp = buf___1;
#line 742
    while (1) {
#line 742
      if (! ((int )*cp == 32)) {
#line 742
        if (! ((int )*cp == 9)) {
#line 742
          break;
        }
      }
#line 742
      cp ++;
    }
#line 744
    if (! *cp) {
#line 745
      continue;
    } else {
#line 744
      if ((int )*cp == 35) {
#line 745
        continue;
      } else {
#line 744
        if ((int )*cp == 10) {
#line 745
          continue;
        }
      }
    }
#line 746
    tmp___2 = __builtin_strchr(cp, '\n');
#line 746
    if (tmp___2) {
#line 747
      tmp___0 = __builtin_strchr(cp, '\n');
#line 747
      *tmp___0 = (char )'\000';
    }
#line 748
    tmp___4 = __builtin_strchr(cp, '=');
#line 748
    value = tmp___4;
#line 749
    if ((unsigned int )value == (unsigned int )((void *)0)) {
#line 750
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad line in %.100s: %.200s\n",
              filename, buf___1);
#line 751
      continue;
    }
#line 757
    *value = (char )'\000';
#line 758
    value ++;
#line 759
    child_set_env(env, envsize, (char const   *)cp, (char const   *)value);
  }
#line 761
  fclose(f);
#line 762
  return;
}
}
#line 768 "session.c"
void do_pam_environment(char ***env , int *envsize ) 
{ char *equals ;
  char var_name[512] ;
  char var_val[512] ;
  char **pam_env ;
  int i ;
  size_t tmp ;

  {
#line 774
  pam_env = fetch_pam_environment();
#line 774
  if ((unsigned int )pam_env == (unsigned int )((void *)0)) {
#line 775
    return;
  }
#line 777
  i = 0;
#line 777
  while ((unsigned int )*(pam_env + i) != (unsigned int )((void *)0)) {
#line 778
    equals = strstr((char const   *)*(pam_env + i), "=");
#line 778
    if ((unsigned int )equals == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 781
    tmp = strlen((char const   *)*(pam_env + i));
#line 781
    if (tmp < sizeof(var_name) - 1U) {
#line 782
      memset((void *)(var_name), '\000', sizeof(var_name));
#line 783
      memset((void *)(var_val), '\000', sizeof(var_val));
#line 785
      __builtin_strncpy(var_name, (char const   *)*(pam_env + i), (unsigned int )(equals - *(pam_env + i)));
#line 786
      strcpy((char * __restrict  )(var_val), (char const   * __restrict  )(equals + 1));
#line 788
      debug("PAM environment: %s=%s", var_name, var_val);
#line 790
      child_set_env(env, (unsigned int *)envsize, (char const   *)(var_name), (char const   *)(var_val));
    }
    __Cont: /* CIL Label */ 
#line 777
    i ++;
  }
#line 793
  return;
}
}
#line 811
extern char **environ ;
#line 801 "session.c"
void do_child(char const   *command , struct passwd *pw , char const   *term , char const   *display ,
              char const   *auth_proto , char const   *auth_data , char const   *ttyname___0 ) 
{ char const   *shell ;
  char const   *cp ;
  char buf___1[256] ;
  FILE *f ;
  unsigned int envsize ;
  unsigned int i ;
  char **env ;
  struct stat st ;
  char *argv[10] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  __uid_t tmp___4 ;
  __uid_t tmp___5 ;
  __uid_t tmp___6 ;
  __uid_t tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  struct envstring *ce ;
  char *s ;
  int i___0 ;
  int tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  char *screen ;
  char *tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  char *tmp___28 ;
  char buf___2[256] ;
  char *mailbox ;
  struct stat mailstat ;
  int tmp___29 ;
  char const   *tmp___30 ;

  {
#line 806
  cp = (char const   *)((void *)0);
#line 828
  tmp___1 = setlogin((char const   *)pw->pw_name);
#line 828
  if (tmp___1 < 0) {
#line 829
    tmp = __errno_location();
#line 829
    tmp___0 = strerror(*tmp);
#line 829
    error("setlogin failed: %s", tmp___0);
  }
#line 834
  if (! options.use_login) {
#line 835
    tmp___4 = getuid();
#line 835
    if (tmp___4 == 0U) {
      goto _L;
    } else {
#line 835
      tmp___5 = geteuid();
#line 835
      if (tmp___5 == 0U) {
        _L: /* CIL Label */ 
#line 836
        tmp___2 = setgid(pw->pw_gid);
#line 836
        if (tmp___2 < 0) {
#line 837
          perror("setgid");
#line 838
          exit(1);
        }
#line 841
        tmp___3 = initgroups((char const   *)pw->pw_name, pw->pw_gid);
#line 841
        if (tmp___3 < 0) {
#line 842
          perror("initgroups");
#line 843
          exit(1);
        }
#line 845
        endgrent();
#line 848
        permanently_set_uid(pw->pw_uid);
      }
    }
#line 850
    tmp___6 = getuid();
#line 850
    if (tmp___6 != pw->pw_uid) {
#line 851
      fatal("Failed to set uids to %d.", (int )pw->pw_uid);
    } else {
#line 850
      tmp___7 = geteuid();
#line 850
      if (tmp___7 != pw->pw_uid) {
#line 851
        fatal("Failed to set uids to %d.", (int )pw->pw_uid);
      }
    }
  }
#line 857
  if ((int )*(pw->pw_shell + 0) == 0) {
#line 857
    shell = "/bin/sh";
  } else {
#line 857
    shell = (char const   *)pw->pw_shell;
  }
#line 872
  envsize = 100U;
#line 873
  tmp___8 = xmalloc(envsize * sizeof(char *));
#line 873
  env = (char **)tmp___8;
#line 874
  *(env + 0) = (char *)((void *)0);
#line 876
  if (! options.use_login) {
#line 878
    child_set_env(& env, & envsize, "USER", (char const   *)pw->pw_name);
#line 879
    child_set_env(& env, & envsize, "LOGNAME", (char const   *)pw->pw_name);
#line 880
    child_set_env(& env, & envsize, "HOME", (char const   *)pw->pw_dir);
#line 881
    child_set_env(& env, & envsize, "PATH", "/usr/bin:/bin:/usr/sbin:/sbin");
#line 883
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.200s/%.50s",
             "/var/mail", pw->pw_name);
#line 885
    child_set_env(& env, & envsize, "MAIL", (char const   *)(buf___1));
#line 888
    child_set_env(& env, & envsize, "SHELL", shell);
  }
#line 890
  tmp___10 = getenv("TZ");
#line 890
  if (tmp___10) {
#line 891
    tmp___9 = getenv("TZ");
#line 891
    child_set_env(& env, & envsize, "TZ", (char const   *)tmp___9);
  }
#line 894
  while (custom_environment) {
#line 895
    ce = custom_environment;
#line 896
    s = ce->s;
#line 898
    i___0 = 0;
#line 898
    while (1) {
#line 898
      if ((int )*(s + i___0) != 61) {
#line 898
        if (! *(s + i___0)) {
#line 898
          break;
        }
      } else {
#line 898
        break;
      }
#line 898
      i___0 ++;
    }
#line 899
    if ((int )*(s + i___0) == 61) {
#line 900
      *(s + i___0) = (char)0;
#line 901
      child_set_env(& env, & envsize, (char const   *)s, (char const   *)((s + i___0) + 1));
    }
#line 903
    custom_environment = ce->next;
#line 904
    xfree((void *)ce->s);
#line 905
    xfree((void *)ce);
  }
#line 908
  tmp___11 = get_local_port();
#line 908
  tmp___12 = get_remote_port();
#line 908
  tmp___13 = get_remote_ipaddr();
#line 908
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.50s %d %d",
           tmp___13, tmp___12, tmp___11);
#line 910
  child_set_env(& env, & envsize, "SSH_CLIENT", (char const   *)(buf___1));
#line 912
  if (ttyname___0) {
#line 913
    child_set_env(& env, & envsize, "SSH_TTY", ttyname___0);
  }
#line 914
  if (term) {
#line 915
    child_set_env(& env, & envsize, "TERM", term);
  }
#line 916
  if (display) {
#line 917
    child_set_env(& env, & envsize, "DISPLAY", display);
  }
#line 942
  do_pam_environment(& env, (int *)(& envsize));
#line 945
  read_environment_file(& env, & envsize, "/etc/environment");
#line 947
  if (xauthfile) {
#line 948
    child_set_env(& env, & envsize, "XAUTHORITY", (char const   *)xauthfile);
  }
#line 949
  tmp___15 = auth_get_socket_name();
#line 949
  if ((unsigned int )tmp___15 != (unsigned int )((void *)0)) {
#line 950
    tmp___14 = auth_get_socket_name();
#line 950
    child_set_env(& env, & envsize, "SSH_AUTH_SOCK", (char const   *)tmp___14);
  }
#line 954
  if (! options.use_login) {
#line 955
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.200s/.ssh/environment",
             pw->pw_dir);
#line 957
    read_environment_file(& env, & envsize, (char const   *)(buf___1));
  }
#line 959
  if (debug_flag) {
#line 961
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Environment:\n");
#line 962
    i = 0U;
#line 962
    while (*(env + i)) {
#line 963
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  %.200s\n",
              *(env + i));
#line 962
      i ++;
    }
  }
#line 972
  tmp___19 = packet_get_connection_in();
#line 972
  tmp___20 = packet_get_connection_out();
#line 972
  if (tmp___19 == tmp___20) {
#line 973
    tmp___16 = packet_get_connection_in();
#line 973
    close(tmp___16);
  } else {
#line 975
    tmp___17 = packet_get_connection_in();
#line 975
    close(tmp___17);
#line 976
    tmp___18 = packet_get_connection_out();
#line 976
    close(tmp___18);
  }
#line 983
  channel_close_all();
#line 989
  endpwent();
#line 997
  i = 3U;
#line 997
  while (i < 64U) {
#line 998
    close((int )i);
#line 997
    i ++;
  }
#line 1001
  tmp___23 = chdir((char const   *)pw->pw_dir);
#line 1001
  if (tmp___23 < 0) {
#line 1002
    tmp___21 = __errno_location();
#line 1002
    tmp___22 = strerror(*tmp___21);
#line 1002
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not chdir to home directory %s: %s\n",
            pw->pw_dir, tmp___22);
  }
#line 1009
  environ = env;
#line 1015
  if (! options.use_login) {
#line 1016
    tmp___27 = stat((char const   * __restrict  )".ssh/rc", (struct stat * __restrict  )(& st));
#line 1016
    if (tmp___27 >= 0) {
#line 1017
      if (debug_flag) {
#line 1018
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running /bin/sh %s\n",
                ".ssh/rc");
      }
#line 1020
      f = popen("/bin/sh .ssh/rc", "w");
#line 1021
      if (f) {
#line 1022
        if ((unsigned int )auth_proto != (unsigned int )((void *)0)) {
#line 1022
          if ((unsigned int )auth_data != (unsigned int )((void *)0)) {
#line 1023
            fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                    auth_proto, auth_data);
          }
        }
#line 1024
        pclose(f);
      } else {
#line 1026
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                ".ssh/rc");
      }
    } else {
#line 1027
      tmp___26 = stat((char const   * __restrict  )"/usr/local/etc/sshrc", (struct stat * __restrict  )(& st));
#line 1027
      if (tmp___26 >= 0) {
#line 1028
        if (debug_flag) {
#line 1029
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running /bin/sh %s\n",
                  "/usr/local/etc/sshrc");
        }
#line 1031
        f = popen("/bin/sh /usr/local/etc/sshrc", "w");
#line 1032
        if (f) {
#line 1033
          if ((unsigned int )auth_proto != (unsigned int )((void *)0)) {
#line 1033
            if ((unsigned int )auth_data != (unsigned int )((void *)0)) {
#line 1034
              fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                      auth_proto, auth_data);
            }
          }
#line 1035
          pclose(f);
        } else {
#line 1037
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                  "/usr/local/etc/sshrc");
        }
      } else {
#line 1042
        if ((unsigned int )auth_proto != (unsigned int )((void *)0)) {
#line 1042
          if ((unsigned int )auth_data != (unsigned int )((void *)0)) {
#line 1043
            tmp___25 = __builtin_strchr((char *)display, ':');
#line 1043
            screen = tmp___25;
#line 1044
            if (debug_flag) {
#line 1045
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %.100s add %.100s %.100s %.100s\n",
                      "/usr/bin//xauth", display, auth_proto, auth_data);
#line 1048
              if ((unsigned int )screen != (unsigned int )((void *)0)) {
#line 1049
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Adding %.*s/unix%s %s %s\n",
                        screen - (char *)display, display, screen, auth_proto, auth_data);
              }
            }
#line 1054
            f = popen("/usr/bin//xauth -q -", "w");
#line 1055
            if (f) {
#line 1056
              fprintf((FILE * __restrict  )f, (char const   * __restrict  )"add %s %s %s\n",
                      display, auth_proto, auth_data);
#line 1058
              if ((unsigned int )screen != (unsigned int )((void *)0)) {
#line 1059
                fprintf((FILE * __restrict  )f, (char const   * __restrict  )"add %.*s/unix%s %s %s\n",
                        screen - (char *)display, display, screen, auth_proto, auth_data);
              }
#line 1062
              pclose(f);
            } else {
#line 1064
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s -q -\n",
                      "/usr/bin//xauth");
            }
          }
        }
      }
    }
#line 1071
    tmp___28 = strrchr(shell, '/');
#line 1071
    cp = (char const   *)tmp___28;
#line 1072
    if (cp) {
#line 1073
      cp ++;
    } else {
#line 1075
      cp = shell;
    }
  }
#line 1082
  if (! command) {
#line 1083
    if (! options.use_login) {
#line 1090
      if (ttyname___0) {
#line 1090
        if (options.check_mail) {
#line 1093
          mailbox = getenv("MAIL");
#line 1094
          if ((unsigned int )mailbox != (unsigned int )((void *)0)) {
#line 1095
            tmp___29 = stat((char const   * __restrict  )mailbox, (struct stat * __restrict  )(& mailstat));
#line 1095
            if (tmp___29 != 0) {
#line 1097
              printf((char const   * __restrict  )"No mail.\n");
            } else {
#line 1095
              if (mailstat.st_size == 0L) {
#line 1097
                printf((char const   * __restrict  )"No mail.\n");
              } else {
#line 1098
                if (mailstat.st_mtim.tv_sec < mailstat.st_atim.tv_sec) {
#line 1099
                  printf((char const   * __restrict  )"You have mail.\n");
                } else {
#line 1101
                  printf((char const   * __restrict  )"You have new mail.\n");
                }
              }
            }
          }
        }
      }
#line 1105
      buf___2[0] = (char )'-';
#line 1106
      __builtin_strncpy(buf___2 + 1, cp, sizeof(buf___2) - 1U);
#line 1107
      buf___2[sizeof(buf___2) - 1U] = (char)0;
#line 1110
      argv[0] = buf___2;
#line 1111
      argv[1] = (char *)((void *)0);
#line 1112
      execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 1115
      perror(shell);
#line 1116
      exit(1);
    } else {
#line 1121
      tmp___30 = get_remote_ipaddr();
#line 1121
      execl("/usr/bin/login", "login", "-h", tmp___30, "-p", "-f", "--", pw->pw_name,
            (void *)0);
#line 1126
      perror("login");
#line 1127
      exit(1);
    }
  }
#line 1134
  argv[0] = (char *)cp;
#line 1135
  argv[1] = (char *)"-c";
#line 1136
  argv[2] = (char *)command;
#line 1137
  argv[3] = (char *)((void *)0);
#line 1138
  execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 1139
  perror(shell);
#line 1140
  exit(1);
}
}
#line 1147 "session.c"
static int did_init___0  =    0;
#line 1143 "session.c"
Session *session_new(void) 
{ int i ;
  Session *s ;

  {
#line 1148
  if (! did_init___0) {
#line 1149
    debug("session_new: init");
#line 1150
    i = 0;
#line 1150
    while (i < 10) {
#line 1151
      sessions[i].used = 0;
#line 1152
      sessions[i].self = i;
#line 1150
      i ++;
    }
#line 1154
    did_init___0 = 1;
  }
#line 1156
  i = 0;
#line 1156
  while (i < 10) {
#line 1157
    s = & sessions[i];
#line 1158
    if (! s->used) {
#line 1159
      s->pid = 0;
#line 1160
      s->extended = 0;
#line 1161
      s->chanid = -1;
#line 1162
      s->ptyfd = -1;
#line 1163
      s->ttyfd = -1;
#line 1164
      s->term = (char *)((void *)0);
#line 1165
      s->pw = (struct passwd *)((void *)0);
#line 1166
      s->display = (char *)((void *)0);
#line 1167
      s->screen = 0;
#line 1168
      s->auth_data = (char *)((void *)0);
#line 1169
      s->auth_proto = (char *)((void *)0);
#line 1170
      s->used = 1;
#line 1171
      s->pw = (struct passwd *)((void *)0);
#line 1172
      debug("session_new: session %d", i);
#line 1173
      return (s);
    }
#line 1156
    i ++;
  }
#line 1176
  return ((Session *)((void *)0));
}
}
#line 1179 "session.c"
void session_dump(void) 
{ int i ;
  Session *s ;

  {
#line 1183
  i = 0;
#line 1183
  while (i < 10) {
#line 1184
    s = & sessions[i];
#line 1185
    debug("dump: used %d session %d %p channel %d pid %d", s->used, s->self, s, s->chanid,
          s->pid);
#line 1183
    i ++;
  }
#line 1192
  return;
}
}
#line 1194 "session.c"
int session_open(int chanid ) 
{ Session *s ;
  Session *tmp ;

  {
#line 1197
  tmp = session_new();
#line 1197
  s = tmp;
#line 1198
  debug("session_open: channel %d", chanid);
#line 1199
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1200
    error("no more sessions");
#line 1201
    return (0);
  }
#line 1203
  s->pw = auth_get_user();
#line 1204
  if ((unsigned int )s->pw == (unsigned int )((void *)0)) {
#line 1205
    fatal("no user for session %i", s->self);
  }
#line 1206
  debug("session_open: session %d: link with channel %d", s->self, chanid);
#line 1207
  s->chanid = chanid;
#line 1208
  return (1);
}
}
#line 1211 "session.c"
Session *session_by_channel(int id ) 
{ int i ;
  Session *s ;

  {
#line 1215
  i = 0;
#line 1215
  while (i < 10) {
#line 1216
    s = & sessions[i];
#line 1217
    if (s->used) {
#line 1217
      if (s->chanid == id) {
#line 1218
        debug("session_by_channel: session %d channel %d", i, id);
#line 1219
        return (s);
      }
    }
#line 1215
    i ++;
  }
#line 1222
  debug("session_by_channel: unknown channel %d", id);
#line 1223
  session_dump();
#line 1224
  return ((Session *)((void *)0));
}
}
#line 1227 "session.c"
Session *session_by_pid(pid_t pid ) 
{ int i ;
  Session *s ;

  {
#line 1231
  debug("session_by_pid: pid %d", pid);
#line 1232
  i = 0;
#line 1232
  while (i < 10) {
#line 1233
    s = & sessions[i];
#line 1234
    if (s->used) {
#line 1234
      if (s->pid == pid) {
#line 1235
        return (s);
      }
    }
#line 1232
    i ++;
  }
#line 1237
  error("session_by_pid: unknown pid %d", pid);
#line 1238
  session_dump();
#line 1239
  return ((Session *)((void *)0));
}
}
#line 1242 "session.c"
int session_window_change_req(Session *s ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 1245
  tmp = packet_get_int();
#line 1245
  s->col = (int )tmp;
#line 1246
  tmp___0 = packet_get_int();
#line 1246
  s->row = (int )tmp___0;
#line 1247
  tmp___1 = packet_get_int();
#line 1247
  s->xpixel = (int )tmp___1;
#line 1248
  tmp___2 = packet_get_int();
#line 1248
  s->ypixel = (int )tmp___2;
#line 1249
  while (1) {
#line 1249
    tmp___3 = packet_remaining();
#line 1249
    _len = tmp___3;
#line 1249
    if (_len > 0) {
#line 1249
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1249);
#line 1249
      packet_disconnect("Packet integrity error.");
    }
#line 1249
    break;
  }
#line 1250
  pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);
#line 1251
  return (1);
}
}
#line 1254 "session.c"
int session_pty_req(Session *s ) 
{ unsigned int len ;
  char *term_modes ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int _len ;
  int tmp___3 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___9 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 1260
  if (s->ttyfd != -1) {
#line 1261
    return (0);
  }
#line 1262
  s->term = packet_get_string(& len);
#line 1263
  tmp = packet_get_int();
#line 1263
  s->col = (int )tmp;
#line 1264
  tmp___0 = packet_get_int();
#line 1264
  s->row = (int )tmp___0;
#line 1265
  tmp___1 = packet_get_int();
#line 1265
  s->xpixel = (int )tmp___1;
#line 1266
  tmp___2 = packet_get_int();
#line 1266
  s->ypixel = (int )tmp___2;
#line 1267
  term_modes = packet_get_string(& len);
#line 1268
  while (1) {
#line 1268
    tmp___3 = packet_remaining();
#line 1268
    _len = tmp___3;
#line 1268
    if (_len > 0) {
#line 1268
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1268);
#line 1268
      packet_disconnect("Packet integrity error.");
    }
#line 1268
    break;
  }
#line 1270
  if (0) {
#line 1270
    __s1_len = strlen((char const   *)s->term);
#line 1270
    __s2_len = strlen("");
#line 1270
    if (! ((unsigned int )((void const   *)(s->term + 1)) - (unsigned int )((void const   *)s->term) == 1U)) {
      goto _L___0;
    } else {
#line 1270
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1270
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 1270
          tmp___13 = 1;
        } else {
#line 1270
          if (__s2_len >= 4U) {
#line 1270
            tmp___13 = 1;
          } else {
#line 1270
            tmp___13 = 0;
          }
        }
      } else {
#line 1270
        tmp___13 = 0;
      }
    }
#line 1270
    if (tmp___13) {
#line 1270
      tmp___9 = __builtin_strcmp((char const   *)s->term, "");
    } else {
#line 1270
      tmp___12 = __builtin_strcmp((char const   *)s->term, "");
#line 1270
      tmp___9 = tmp___12;
    }
  } else {
#line 1270
    tmp___12 = __builtin_strcmp((char const   *)s->term, "");
#line 1270
    tmp___9 = tmp___12;
  }
#line 1270
  if (tmp___9 == 0) {
#line 1271
    xfree((void *)s->term);
#line 1272
    s->term = (char *)((void *)0);
  }
#line 1275
  tmp___14 = pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, (int )sizeof(s->tty));
#line 1275
  if (! tmp___14) {
#line 1276
    xfree((void *)s->term);
#line 1277
    s->term = (char *)((void *)0);
#line 1278
    s->ptyfd = -1;
#line 1279
    s->ttyfd = -1;
#line 1280
    error("session_pty_req: session %d alloc failed", s->self);
#line 1281
    xfree((void *)term_modes);
#line 1282
    return (0);
  }
#line 1284
  debug("session_pty_req: session %d alloc %s", s->self, s->tty);
#line 1289
  fatal_add_cleanup(& pty_cleanup_proc, (void *)s);
#line 1290
  pty_setowner(s->pw, (char const   *)(s->tty));
#line 1292
  pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);
#line 1294
  session_proctitle(s);
#line 1297
  xfree((void *)term_modes);
#line 1298
  return (1);
}
}
#line 1301 "session.c"
int session_subsystem_req(Session *s ) 
{ unsigned int len ;
  int success ;
  char *subsys ;
  char *tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 1305
  success = 0;
#line 1306
  tmp = packet_get_string(& len);
#line 1306
  subsys = tmp;
#line 1308
  while (1) {
#line 1308
    tmp___0 = packet_remaining();
#line 1308
    _len = tmp___0;
#line 1308
    if (_len > 0) {
#line 1308
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1308);
#line 1308
      packet_disconnect("Packet integrity error.");
    }
#line 1308
    break;
  }
#line 1309
  log("subsystem request for %s", subsys);
#line 1311
  xfree((void *)subsys);
#line 1312
  return (success);
}
}
#line 1315 "session.c"
int session_x11_req(Session *s ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;
  int _len ;
  int tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 1318
  if (! options.x11_forwarding) {
#line 1319
    debug("X11 forwarding disabled in server configuration file.");
#line 1320
    return (0);
  }
#line 1322
  if ((unsigned int )xauthfile != (unsigned int )((void *)0)) {
#line 1323
    debug("X11 fwd already started.");
#line 1324
    return (0);
  }
#line 1327
  debug("Received request for X11 forwarding with auth spoofing.");
#line 1328
  if ((unsigned int )s->display != (unsigned int )((void *)0)) {
#line 1329
    packet_disconnect("Protocol error: X11 display already set.");
  }
#line 1331
  tmp = packet_get_char();
#line 1331
  s->single_connection = (int )tmp;
#line 1332
  s->auth_proto = packet_get_string((unsigned int *)((void *)0));
#line 1333
  s->auth_data = packet_get_string((unsigned int *)((void *)0));
#line 1334
  tmp___0 = packet_get_int();
#line 1334
  s->screen = (int )tmp___0;
#line 1335
  while (1) {
#line 1335
    tmp___1 = packet_remaining();
#line 1335
    _len = tmp___1;
#line 1335
    if (_len > 0) {
#line 1335
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1335);
#line 1335
      packet_disconnect("Packet integrity error.");
    }
#line 1335
    break;
  }
#line 1337
  s->display = x11_create_display_inet(s->screen, options.x11_display_offset);
#line 1338
  if ((unsigned int )s->display == (unsigned int )((void *)0)) {
#line 1339
    xfree((void *)s->auth_proto);
#line 1340
    xfree((void *)s->auth_data);
#line 1341
    return (0);
  }
#line 1343
  tmp___2 = xmalloc(4096U);
#line 1343
  xauthfile = (char *)tmp___2;
#line 1344
  strlcpy(xauthfile, "/tmp/ssh-XXXXXXXX", 4096U);
#line 1345
  temporarily_use_uid((s->pw)->pw_uid);
#line 1346
  tmp___5 = mkdtemp(xauthfile);
#line 1346
  if ((unsigned int )tmp___5 == (unsigned int )((void *)0)) {
#line 1347
    restore_uid();
#line 1348
    tmp___3 = __errno_location();
#line 1348
    tmp___4 = strerror(*tmp___3);
#line 1348
    error("private X11 dir: mkdtemp %s failed: %s", xauthfile, tmp___4);
#line 1350
    xfree((void *)xauthfile);
#line 1351
    xauthfile = (char *)((void *)0);
#line 1352
    xfree((void *)s->auth_proto);
#line 1353
    xfree((void *)s->auth_data);
#line 1355
    return (0);
  }
#line 1357
  strlcat(xauthfile, "/cookies", 4096U);
#line 1358
  open((char const   *)xauthfile, 194, 384);
#line 1359
  restore_uid();
#line 1360
  fatal_add_cleanup(& xauthfile_cleanup_proc, (void *)s);
#line 1361
  return (1);
}
}
#line 1364 "session.c"
void session_input_channel_req(int id , void *arg ) 
{ unsigned int len ;
  int reply ;
  int success ;
  char *rtype ;
  Session *s ;
  Channel *c ;
  unsigned int tmp ;
  int _len ;
  int tmp___0 ;
  char *command ;
  char *tmp___1 ;
  int _len___0 ;
  int tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___28 ;
  int tmp___31 ;
  int tmp___32 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___38 ;
  int tmp___41 ;
  int tmp___42 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___48 ;
  int tmp___51 ;
  int tmp___52 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___58 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;

  {
#line 1369
  success = 0;
#line 1374
  rtype = packet_get_string(& len);
#line 1375
  tmp = packet_get_char();
#line 1375
  reply = (int )tmp;
#line 1377
  s = session_by_channel(id);
#line 1378
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1379
    fatal("session_input_channel_req: channel %d: no session", id);
  }
#line 1380
  c = channel_lookup(id);
#line 1381
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1382
    fatal("session_input_channel_req: channel %d: bad channel", id);
  }
#line 1384
  debug("session_input_channel_req: session %d channel %d request %s reply %d", s->self,
        id, rtype, reply);
#line 1391
  if (c->type == 10) {
#line 1392
    if (0) {
#line 1392
      __s1_len___3 = strlen((char const   *)rtype);
#line 1392
      __s2_len___3 = strlen("shell");
#line 1392
      if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
        goto _L___8;
      } else {
#line 1392
        if (__s1_len___3 >= 4U) {
          _L___8: /* CIL Label */ 
#line 1392
          if (! ((unsigned int )((void const   *)("shell" + 1)) - (unsigned int )((void const   *)"shell") == 1U)) {
#line 1392
            tmp___52 = 1;
          } else {
#line 1392
            if (__s2_len___3 >= 4U) {
#line 1392
              tmp___52 = 1;
            } else {
#line 1392
              tmp___52 = 0;
            }
          }
        } else {
#line 1392
          tmp___52 = 0;
        }
      }
#line 1392
      if (tmp___52) {
#line 1392
        tmp___48 = __builtin_strcmp((char const   *)rtype, "shell");
      } else {
#line 1392
        tmp___51 = __builtin_strcmp((char const   *)rtype, "shell");
#line 1392
        tmp___48 = tmp___51;
      }
    } else {
#line 1392
      tmp___51 = __builtin_strcmp((char const   *)rtype, "shell");
#line 1392
      tmp___48 = tmp___51;
    }
#line 1392
    if (tmp___48 == 0) {
#line 1393
      while (1) {
#line 1393
        tmp___0 = packet_remaining();
#line 1393
        _len = tmp___0;
#line 1393
        if (_len > 0) {
#line 1393
          log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
              1393);
#line 1393
          packet_disconnect("Packet integrity error.");
        }
#line 1393
        break;
      }
#line 1394
      s->extended = 1;
#line 1395
      if (s->ttyfd == -1) {
#line 1396
        do_exec_no_pty(s, (char const   *)((void *)0), s->pw);
      } else {
#line 1398
        do_exec_pty(s, (char const   *)((void *)0), s->pw);
      }
#line 1399
      success = 1;
    } else {
#line 1400
      if (0) {
#line 1400
        __s1_len___2 = strlen((char const   *)rtype);
#line 1400
        __s2_len___2 = strlen("exec");
#line 1400
        if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
          goto _L___6;
        } else {
#line 1400
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 1400
            if (! ((unsigned int )((void const   *)("exec" + 1)) - (unsigned int )((void const   *)"exec") == 1U)) {
#line 1400
              tmp___42 = 1;
            } else {
#line 1400
              if (__s2_len___2 >= 4U) {
#line 1400
                tmp___42 = 1;
              } else {
#line 1400
                tmp___42 = 0;
              }
            }
          } else {
#line 1400
            tmp___42 = 0;
          }
        }
#line 1400
        if (tmp___42) {
#line 1400
          tmp___38 = __builtin_strcmp((char const   *)rtype, "exec");
        } else {
#line 1400
          tmp___41 = __builtin_strcmp((char const   *)rtype, "exec");
#line 1400
          tmp___38 = tmp___41;
        }
      } else {
#line 1400
        tmp___41 = __builtin_strcmp((char const   *)rtype, "exec");
#line 1400
        tmp___38 = tmp___41;
      }
#line 1400
      if (tmp___38 == 0) {
#line 1401
        tmp___1 = packet_get_string(& len);
#line 1401
        command = tmp___1;
#line 1402
        while (1) {
#line 1402
          tmp___2 = packet_remaining();
#line 1402
          _len___0 = tmp___2;
#line 1402
          if (_len___0 > 0) {
#line 1402
            log("Packet integrity error (%d bytes remaining) at %s:%d", _len___0,
                "session.c", 1402);
#line 1402
            packet_disconnect("Packet integrity error.");
          }
#line 1402
          break;
        }
#line 1403
        s->extended = 1;
#line 1404
        if (s->ttyfd == -1) {
#line 1405
          do_exec_no_pty(s, (char const   *)command, s->pw);
        } else {
#line 1407
          do_exec_pty(s, (char const   *)command, s->pw);
        }
#line 1408
        xfree((void *)command);
#line 1409
        success = 1;
      } else {
#line 1410
        if (0) {
#line 1410
          __s1_len___1 = strlen((char const   *)rtype);
#line 1410
          __s2_len___1 = strlen("pty-req");
#line 1410
          if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
            goto _L___4;
          } else {
#line 1410
            if (__s1_len___1 >= 4U) {
              _L___4: /* CIL Label */ 
#line 1410
              if (! ((unsigned int )((void const   *)("pty-req" + 1)) - (unsigned int )((void const   *)"pty-req") == 1U)) {
#line 1410
                tmp___32 = 1;
              } else {
#line 1410
                if (__s2_len___1 >= 4U) {
#line 1410
                  tmp___32 = 1;
                } else {
#line 1410
                  tmp___32 = 0;
                }
              }
            } else {
#line 1410
              tmp___32 = 0;
            }
          }
#line 1410
          if (tmp___32) {
#line 1410
            tmp___28 = __builtin_strcmp((char const   *)rtype, "pty-req");
          } else {
#line 1410
            tmp___31 = __builtin_strcmp((char const   *)rtype, "pty-req");
#line 1410
            tmp___28 = tmp___31;
          }
        } else {
#line 1410
          tmp___31 = __builtin_strcmp((char const   *)rtype, "pty-req");
#line 1410
          tmp___28 = tmp___31;
        }
#line 1410
        if (tmp___28 == 0) {
#line 1411
          success = session_pty_req(s);
        } else {
#line 1412
          if (0) {
#line 1412
            __s1_len___0 = strlen((char const   *)rtype);
#line 1412
            __s2_len___0 = strlen("x11-req");
#line 1412
            if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
              goto _L___2;
            } else {
#line 1412
              if (__s1_len___0 >= 4U) {
                _L___2: /* CIL Label */ 
#line 1412
                if (! ((unsigned int )((void const   *)("x11-req" + 1)) - (unsigned int )((void const   *)"x11-req") == 1U)) {
#line 1412
                  tmp___22 = 1;
                } else {
#line 1412
                  if (__s2_len___0 >= 4U) {
#line 1412
                    tmp___22 = 1;
                  } else {
#line 1412
                    tmp___22 = 0;
                  }
                }
              } else {
#line 1412
                tmp___22 = 0;
              }
            }
#line 1412
            if (tmp___22) {
#line 1412
              tmp___18 = __builtin_strcmp((char const   *)rtype, "x11-req");
            } else {
#line 1412
              tmp___21 = __builtin_strcmp((char const   *)rtype, "x11-req");
#line 1412
              tmp___18 = tmp___21;
            }
          } else {
#line 1412
            tmp___21 = __builtin_strcmp((char const   *)rtype, "x11-req");
#line 1412
            tmp___18 = tmp___21;
          }
#line 1412
          if (tmp___18 == 0) {
#line 1413
            success = session_x11_req(s);
          } else {
#line 1414
            if (0) {
#line 1414
              __s1_len = strlen((char const   *)rtype);
#line 1414
              __s2_len = strlen("subsystem");
#line 1414
              if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
                goto _L___0;
              } else {
#line 1414
                if (__s1_len >= 4U) {
                  _L___0: /* CIL Label */ 
#line 1414
                  if (! ((unsigned int )((void const   *)("subsystem" + 1)) - (unsigned int )((void const   *)"subsystem") == 1U)) {
#line 1414
                    tmp___12 = 1;
                  } else {
#line 1414
                    if (__s2_len >= 4U) {
#line 1414
                      tmp___12 = 1;
                    } else {
#line 1414
                      tmp___12 = 0;
                    }
                  }
                } else {
#line 1414
                  tmp___12 = 0;
                }
              }
#line 1414
              if (tmp___12) {
#line 1414
                tmp___8 = __builtin_strcmp((char const   *)rtype, "subsystem");
              } else {
#line 1414
                tmp___11 = __builtin_strcmp((char const   *)rtype, "subsystem");
#line 1414
                tmp___8 = tmp___11;
              }
            } else {
#line 1414
              tmp___11 = __builtin_strcmp((char const   *)rtype, "subsystem");
#line 1414
              tmp___8 = tmp___11;
            }
#line 1414
            if (tmp___8 == 0) {
#line 1415
              success = session_subsystem_req(s);
            }
          }
        }
      }
    }
  }
#line 1418
  if (0) {
#line 1418
    __s1_len___4 = strlen((char const   *)rtype);
#line 1418
    __s2_len___4 = strlen("window-change");
#line 1418
    if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
      goto _L___10;
    } else {
#line 1418
      if (__s1_len___4 >= 4U) {
        _L___10: /* CIL Label */ 
#line 1418
        if (! ((unsigned int )((void const   *)("window-change" + 1)) - (unsigned int )((void const   *)"window-change") == 1U)) {
#line 1418
          tmp___62 = 1;
        } else {
#line 1418
          if (__s2_len___4 >= 4U) {
#line 1418
            tmp___62 = 1;
          } else {
#line 1418
            tmp___62 = 0;
          }
        }
      } else {
#line 1418
        tmp___62 = 0;
      }
    }
#line 1418
    if (tmp___62) {
#line 1418
      tmp___58 = __builtin_strcmp((char const   *)rtype, "window-change");
    } else {
#line 1418
      tmp___61 = __builtin_strcmp((char const   *)rtype, "window-change");
#line 1418
      tmp___58 = tmp___61;
    }
  } else {
#line 1418
    tmp___61 = __builtin_strcmp((char const   *)rtype, "window-change");
#line 1418
    tmp___58 = tmp___61;
  }
#line 1418
  if (tmp___58 == 0) {
#line 1419
    success = session_window_change_req(s);
  }
#line 1422
  if (reply) {
#line 1423
    if (success) {
#line 1423
      tmp___63 = 99;
    } else {
#line 1423
      tmp___63 = 100;
    }
#line 1423
    packet_start(tmp___63);
#line 1425
    packet_put_int((unsigned int )c->remote_id);
#line 1426
    packet_send();
  }
#line 1428
  xfree((void *)rtype);
#line 1429
  return;
}
}
#line 1431 "session.c"
void session_set_fds(Session *s , int fdin___0 , int fdout___0 , int fderr___0 ) 
{ int tmp ;

  {
#line 1434
  if (! compat20) {
#line 1435
    fatal("session_set_fds: called for proto != 2.0");
  }
#line 1440
  if (s->chanid == -1) {
#line 1441
    fatal("no channel for session %d", s->self);
  }
#line 1442
  if (fderr___0 == -1) {
#line 1442
    tmp = 0;
  } else {
#line 1442
    tmp = 1;
  }
#line 1442
  channel_set_fds(s->chanid, fdout___0, fdin___0, fderr___0, tmp);
#line 1445
  return;
}
}
#line 1447 "session.c"
void session_pty_cleanup(Session *s ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1450
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1451
    return;
  } else {
#line 1450
    if (s->ttyfd == -1) {
#line 1451
      return;
    }
  }
#line 1453
  debug("session_pty_cleanup: session %i release %s", s->self, s->tty);
#line 1456
  fatal_remove_cleanup(& pty_cleanup_proc, (void *)s);
#line 1459
  record_logout(s->pid, (char const   *)(s->tty));
#line 1462
  pty_release((char const   *)(s->tty));
#line 1469
  tmp___1 = close(s->ptymaster);
#line 1469
  if (tmp___1 < 0) {
#line 1470
    tmp = __errno_location();
#line 1470
    tmp___0 = strerror(*tmp);
#line 1470
    error("close(s->ptymaster): %s", tmp___0);
  }
#line 1471
  return;
}
}
#line 1473 "session.c"
void session_exit_message(Session *s , int status ) 
{ Channel *c ;
  union __anonunion_76 __constr_expr_0 ;
  union __anonunion_77___0 __constr_expr_1 ;
  union __anonunion_78___0 __constr_expr_2 ;
  union __anonunion_79___0 __constr_expr_3 ;
  union __anonunion_80___0 __constr_expr_4 ;

  {
#line 1477
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1478
    fatal("session_close: no session");
  }
#line 1479
  c = channel_lookup(s->chanid);
#line 1480
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1481
    fatal("session_close: session %d: no channel %d", s->self, s->chanid);
  }
#line 1483
  debug("session_exit_message: session %d channel %d pid %d", s->self, s->chanid,
        s->pid);
#line 1486
  __constr_expr_4.__in = status;
#line 1486
  if ((__constr_expr_4.__i & 127) == 0) {
#line 1487
    channel_request_start(s->chanid, (char *)"exit-status", 0);
#line 1489
    __constr_expr_0.__in = status;
#line 1489
    packet_put_int((unsigned int )((__constr_expr_0.__i & 65280) >> 8));
#line 1490
    packet_send();
  } else {
#line 1491
    __constr_expr_3.__in = status;
#line 1491
    if ((int )((signed char )((__constr_expr_3.__i & 127) + 1)) >> 1 > 0) {
#line 1492
      channel_request_start(s->chanid, (char *)"exit-signal", 0);
#line 1494
      __constr_expr_1.__in = status;
#line 1494
      packet_put_int((unsigned int )(__constr_expr_1.__i & 127));
#line 1496
      __constr_expr_2.__in = status;
#line 1496
      packet_put_char(__constr_expr_2.__i & 128);
#line 1500
      packet_put_cstring("");
#line 1501
      packet_put_cstring("");
#line 1502
      packet_send();
    } else {
#line 1505
      packet_disconnect("wait returned status %04x.", status);
    }
  }
#line 1509
  debug("session_exit_message: release channel %d", s->chanid);
#line 1510
  channel_cancel_cleanup(s->chanid);
#line 1517
  if (c->ostate != 128) {
#line 1518
    (*chan_write_failed)(c);
  }
#line 1519
  s->chanid = -1;
#line 1520
  return;
}
}
#line 1522 "session.c"
void session_free(Session *s ) 
{ 

  {
#line 1525
  debug("session_free: session %d pid %d", s->self, s->pid);
#line 1526
  if (s->term) {
#line 1527
    xfree((void *)s->term);
  }
#line 1528
  if (s->display) {
#line 1529
    xfree((void *)s->display);
  }
#line 1530
  if (s->auth_data) {
#line 1531
    xfree((void *)s->auth_data);
  }
#line 1532
  if (s->auth_proto) {
#line 1533
    xfree((void *)s->auth_proto);
  }
#line 1534
  s->used = 0;
#line 1535
  return;
}
}
#line 1537 "session.c"
void session_close(Session *s ) 
{ 

  {
#line 1540
  session_pty_cleanup(s);
#line 1541
  session_free(s);
#line 1542
  session_proctitle(s);
#line 1543
  return;
}
}
#line 1545 "session.c"
void session_close_by_pid(pid_t pid , int status ) 
{ Session *s ;
  Session *tmp ;

  {
#line 1548
  tmp = session_by_pid(pid);
#line 1548
  s = tmp;
#line 1549
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1550
    debug("session_close_by_pid: no session for pid %d", s->pid);
#line 1551
    return;
  }
#line 1553
  if (s->chanid != -1) {
#line 1554
    session_exit_message(s, status);
  }
#line 1555
  session_close(s);
#line 1556
  return;
}
}
#line 1562 "session.c"
void session_close_by_channel(int id , void *arg ) 
{ Session *s ;
  Session *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1565
  tmp = session_by_channel(id);
#line 1565
  s = tmp;
#line 1566
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1567
    debug("session_close_by_channel: no session for channel %d", id);
#line 1568
    return;
  }
#line 1571
  channel_cancel_cleanup(s->chanid);
#line 1572
  s->chanid = -1;
#line 1574
  debug("session_close_by_channel: channel %d kill %d", id, s->pid);
#line 1575
  if (s->pid == 0) {
#line 1577
    session_close(s);
  } else {
#line 1580
    if (s->ttyfd == -1) {
#line 1580
      tmp___2 = 15;
    } else {
#line 1580
      tmp___2 = 1;
    }
#line 1580
    tmp___3 = kill(s->pid, tmp___2);
#line 1580
    if (tmp___3 < 0) {
#line 1581
      tmp___0 = __errno_location();
#line 1581
      tmp___1 = strerror(*tmp___0);
#line 1581
      error("session_close_by_channel: kill %d: %s", s->pid, tmp___1);
    }
  }
#line 1584
  return;
}
}
#line 1589 "session.c"
static char buf___0[1024]  ;
#line 1586 "session.c"
char *session_tty_list(void) 
{ int i ;
  Session *s ;
  char *tmp ;

  {
#line 1591
  buf___0[0] = (char )'\000';
#line 1592
  i = 0;
#line 1592
  while (i < 10) {
#line 1593
    s = & sessions[i];
#line 1594
    if (s->used) {
#line 1594
      if (s->ttyfd != -1) {
#line 1595
        if ((int )buf___0[0] != 0) {
#line 1596
          strlcat(buf___0, ",", sizeof(buf___0));
        }
#line 1597
        tmp = strrchr((char const   *)(s->tty), '/');
#line 1597
        strlcat(buf___0, (char const   *)(tmp + 1), sizeof(buf___0));
      }
    }
#line 1592
    i ++;
  }
#line 1600
  if ((int )buf___0[0] == 0) {
#line 1601
    strlcpy(buf___0, "notty", sizeof(buf___0));
  }
#line 1602
  return (buf___0);
}
}
#line 1605 "session.c"
void session_proctitle(Session *s ) 
{ char *tmp ;

  {
#line 1608
  if ((unsigned int )s->pw == (unsigned int )((void *)0)) {
#line 1609
    error("no user for session %d", s->self);
  } else {
#line 1611
    tmp = session_tty_list();
#line 1611
    setproctitle("%s@%s", (s->pw)->pw_name, tmp);
  }
#line 1612
  return;
}
}
#line 1614 "session.c"
void do_authenticated2(void) 
{ 

  {
#line 1621
  alarm(0U);
#line 1622
  server_loop2();
#line 1623
  if (xauthfile) {
#line 1624
    xauthfile_cleanup_proc((void *)0);
  }
#line 1625
  return;
}
}
