/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

#line 214 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stddef.h"
typedef unsigned int size_t;
#line 71 "/usr/include/openssl/rc4.h"
struct rc4_key_st {
   unsigned int x ;
   unsigned int y ;
   unsigned int data[256] ;
};
#line 71 "/usr/include/openssl/rc4.h"
typedef struct rc4_key_st RC4_KEY;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 146 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 195 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 245 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 302 "/usr/include/bits/socket.h"
struct ucred {
   pid_t pid ;
   uid_t uid ;
   gid_t gid ;
};
#line 148 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 28 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_11 {
   unsigned long __val[1024U / (8U * sizeof(unsigned long ))] ;
};
#line 28 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_11 __sigset_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 33 "/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__kill_26 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__timer_27 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__rt_28 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_29 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_30 {
   void *si_addr ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_31 {
   long si_band ;
   int si_fd ;
};
#line 51 "/usr/include/bits/siginfo.h"
union __anonunion__sifields_25 {
   int _pad[128U / sizeof(int ) - 3U] ;
   struct __anonstruct__kill_26 _kill ;
   struct __anonstruct__timer_27 _timer ;
   struct __anonstruct__rt_28 _rt ;
   struct __anonstruct__sigchld_29 _sigchld ;
   struct __anonstruct__sigfault_30 _sigfault ;
   struct __anonstruct__sigpoll_31 _sigpoll ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_25 _sifields ;
};
#line 51 "/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 25 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_43 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_43 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 97 "./openbsd-compat/bsd-misc.h"
typedef void (*mysig_t)(int  );
#line 59 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 145 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 40 "/usr/include/shadow.h"
struct spwd {
   char *sp_namp ;
   char *sp_pwdp ;
   long sp_lstchg ;
   long sp_min ;
   long sp_max ;
   long sp_warn ;
   long sp_inact ;
   long sp_expire ;
   unsigned long sp_flag ;
};
#line 34 "/usr/include/bits/types.h"
typedef unsigned char __u_char;
#line 35 "/usr/include/sys/types.h"
typedef __u_char u_char;
#line 45 "/usr/include/bits/types.h"
typedef unsigned int __uint32_t;
#line 202 "/usr/include/sys/types.h"
typedef unsigned short u_int16_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 145 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 162 "/usr/include/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   __uint32_t __ss_align ;
   char __ss_padding[128U - 2U * sizeof(__uint32_t )] ;
};
#line 87 "/usr/include/sys/socket.h"
struct sockaddr_in;
#line 87
struct sockaddr_in6;
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 92 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 136 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 137 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 193 "/usr/include/netinet/in.h"
union __anonunion_in6_u_62 {
   uint8_t u6_addr8[16] ;
   uint16_t u6_addr16[8] ;
   uint32_t u6_addr32[4] ;
};
#line 193 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion_in6_u_62 in6_u ;
};
#line 219 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 233 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 144 "/usr/include/bits/types.h"
typedef long __off_t;
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 177 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 183 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 268 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t )] ;
};
#line 35 "/usr/include/bits/types.h"
typedef unsigned short __u_short;
#line 36 "/usr/include/bits/types.h"
typedef unsigned int __u_int;
#line 37 "/usr/include/bits/types.h"
typedef unsigned long __u_long;
#line 36 "/usr/include/sys/types.h"
typedef __u_short u_short;
#line 37 "/usr/include/sys/types.h"
typedef __u_int u_int;
#line 38 "/usr/include/sys/types.h"
typedef __u_long u_long;
#line 203 "/usr/include/sys/types.h"
typedef unsigned int u_int32_t;
#line 48 "/usr/include/arpa/nameser_compat.h"
struct __anonstruct_HEADER_65 {
   unsigned int id : 16 ;
   unsigned int rd : 1 ;
   unsigned int tc : 1 ;
   unsigned int aa : 1 ;
   unsigned int opcode : 4 ;
   unsigned int qr : 1 ;
   unsigned int rcode : 4 ;
   unsigned int cd : 1 ;
   unsigned int ad : 1 ;
   unsigned int unused : 1 ;
   unsigned int ra : 1 ;
   unsigned int qdcount : 16 ;
   unsigned int ancount : 16 ;
   unsigned int nscount : 16 ;
   unsigned int arcount : 16 ;
};
#line 48 "/usr/include/arpa/nameser_compat.h"
typedef struct __anonstruct_HEADER_65 HEADER;
#line 71 "/usr/include/resolv.h"
enum __anonenum_res_sendhookact_66 {
    res_goahead = 0,
    res_nextns = 1,
    res_modified = 2,
    res_done = 3,
    res_error = 4
} ;
#line 71 "/usr/include/resolv.h"
typedef enum __anonenum_res_sendhookact_66 res_sendhookact;
#line 104 "/usr/include/resolv.h"
struct __anonstruct_sort_list_67 {
   struct in_addr addr ;
   u_int32_t mask ;
};
#line 104 "/usr/include/resolv.h"
struct __anonstruct__ext_69 {
   u_int16_t nscount ;
   u_int16_t nsmap[3] ;
   int nssocks[3] ;
   u_int16_t nscount6 ;
   u_int16_t nsinit ;
   struct sockaddr_in6 *nsaddrs[3] ;
   unsigned int _initstamp[2] ;
};
#line 104 "/usr/include/resolv.h"
union __anonunion__u_68 {
   char pad[52] ;
   struct __anonstruct__ext_69 _ext ;
};
#line 104 "/usr/include/resolv.h"
struct __res_state {
   int retrans ;
   int retry ;
   u_long options ;
   int nscount ;
   struct sockaddr_in nsaddr_list[3] ;
   u_short id ;
   char *dnsrch[7] ;
   char defdname[256] ;
   u_long pfcode ;
   unsigned int ndots : 4 ;
   unsigned int nsort : 4 ;
   char unused[3] ;
   struct __anonstruct_sort_list_67 sort_list[10] ;
   res_sendhookact (*qhook)(struct sockaddr_in * const  *ns , u_char const   **query ,
                            int *querylen , u_char *ans , int anssiz , int *resplen ) ;
   res_sendhookact (*rhook)(struct sockaddr_in  const  *ns , u_char const   *query ,
                            int querylen , u_char *ans , int anssiz , int *resplen ) ;
   int res_h_errno ;
   int _vcsock ;
   u_int _flags ;
   union __anonunion__u_68 _u ;
};
#line 88 "./openbsd-compat/getrrsetbyname.h"
struct rdatainfo {
   unsigned int rdi_length ;
   unsigned char *rdi_data ;
};
#line 93 "./openbsd-compat/getrrsetbyname.h"
struct rrsetinfo {
   unsigned int rri_flags ;
   unsigned int rri_rdclass ;
   unsigned int rri_rdtype ;
   unsigned int rri_ttl ;
   unsigned int rri_nrdatas ;
   unsigned int rri_nsigs ;
   char *rri_name ;
   struct rdatainfo *rri_rdatas ;
   struct rdatainfo *rri_sigs ;
};
#line 56 "openbsd-compat/getrrsetbyname.c"
struct dns_query {
   char *name ;
   u_int16_t type ;
   u_int16_t class ;
   struct dns_query *next ;
};
#line 63 "openbsd-compat/getrrsetbyname.c"
struct dns_rr {
   char *name ;
   u_int16_t type ;
   u_int16_t class ;
   u_int16_t ttl ;
   u_int16_t size ;
   void *rdata ;
   struct dns_rr *next ;
};
#line 73 "openbsd-compat/getrrsetbyname.c"
struct dns_response {
   HEADER header ;
   struct dns_query *query ;
   struct dns_rr *answer ;
   struct dns_rr *authority ;
   struct dns_rr *additional ;
};
#line 60 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 137 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 141 "/usr/include/bits/types.h"
typedef __u_quad_t __ino64_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 143 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 152 "/usr/include/bits/types.h"
typedef long __time_t;
#line 167 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 173 "/usr/include/bits/types.h"
typedef __quad_t __blkcnt64_t;
#line 121 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino64_t d_ino ;
   __off64_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t __st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off64_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __ino64_t st_ino ;
};
#line 47 "./openbsd-compat/glob.h"
struct __anonstruct_glob_t_64 {
   int gl_pathc ;
   int gl_matchc ;
   int gl_offs ;
   int gl_flags ;
   char **gl_pathv ;
   int (*gl_errfunc)(char const   * , int  ) ;
   void (*gl_closedir)(void * ) ;
   struct dirent *(*gl_readdir)(void * ) ;
   void *(*gl_opendir)(char const   * ) ;
   int (*gl_lstat)(char const   * , struct stat * ) ;
   int (*gl_stat)(char const   * , struct stat * ) ;
};
#line 47 "./openbsd-compat/glob.h"
typedef struct __anonstruct_glob_t_64 glob_t;
#line 113 "openbsd-compat/glob.c"
typedef u_short Char;
#line 44 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 183 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 23 "/usr/include/bits/sigset.h"
typedef int __sig_atomic_t;
#line 41 "/usr/include/signal.h"
typedef __sig_atomic_t sig_atomic_t;
#line 25 "/usr/include/bits/termios.h"
typedef unsigned char cc_t;
#line 26 "/usr/include/bits/termios.h"
typedef unsigned int speed_t;
#line 27 "/usr/include/bits/termios.h"
typedef unsigned int tcflag_t;
#line 30 "/usr/include/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 43 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 105 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 30 "acss.h"
struct acss_key_st {
   unsigned int lfsr17 ;
   unsigned int lfsr25 ;
   unsigned int lfsrsum ;
   unsigned char seed[5] ;
   unsigned char data[5] ;
   unsigned char subkey[5] ;
   int encrypt ;
   int mode ;
   int seeded ;
   int subkey_avilable ;
};
#line 30 "acss.h"
typedef struct acss_key_st ACSS_KEY;
#line 87 "/usr/include/sys/socket.h"
struct sockaddr_un;
#line 30 "/usr/include/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 107 "/usr/include/openssl/ossl_typ.h"
struct bignum_st;
#line 107 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_st BIGNUM;
#line 108
struct bignum_ctx;
#line 108 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_ctx BN_CTX;
#line 109
struct bn_blinding_st;
#line 109 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_blinding_st BN_BLINDING;
#line 110
struct bn_mont_ctx_st;
#line 110 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_mont_ctx_st BN_MONT_CTX;
#line 112
struct bn_gencb_st;
#line 112 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_gencb_st BN_GENCB;
#line 125
struct dsa_st;
#line 125 "/usr/include/openssl/ossl_typ.h"
typedef struct dsa_st DSA;
#line 126
struct dsa_method;
#line 126 "/usr/include/openssl/ossl_typ.h"
typedef struct dsa_method DSA_METHOD;
#line 128
struct rsa_st;
#line 128 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_st RSA;
#line 129
struct rsa_meth_st;
#line 129 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_meth_st RSA_METHOD;
#line 154
struct engine_st;
#line 154 "/usr/include/openssl/ossl_typ.h"
typedef struct engine_st ENGINE;
#line 165
struct crypto_ex_data_st;
#line 165 "/usr/include/openssl/ossl_typ.h"
typedef struct crypto_ex_data_st CRYPTO_EX_DATA;
#line 66 "/usr/include/openssl/stack.h"
struct stack_st {
   int num ;
   char **data ;
   int sorted ;
   int num_alloc ;
   int (*comp)(char const   * const  * , char const   * const  * ) ;
};
#line 66 "/usr/include/openssl/stack.h"
typedef struct stack_st STACK;
#line 283 "/usr/include/openssl/crypto.h"
struct crypto_ex_data_st {
   STACK *sk ;
   int dummy ;
};
#line 285 "/usr/include/openssl/bn.h"
struct bignum_st {
   unsigned long *d ;
   int top ;
   int dmax ;
   int neg ;
   int flags ;
};
#line 296 "/usr/include/openssl/bn.h"
struct bn_mont_ctx_st {
   int ri ;
   BIGNUM RR ;
   BIGNUM N ;
   BIGNUM Ni ;
   unsigned long n0 ;
   int flags ;
};
#line 320 "/usr/include/openssl/bn.h"
union __anonunion_cb_71 {
   void (*cb_1)(int  , int  , void * ) ;
   int (*cb_2)(int  , int  , BN_GENCB * ) ;
};
#line 320 "/usr/include/openssl/bn.h"
struct bn_gencb_st {
   unsigned int ver ;
   void *arg ;
   union __anonunion_cb_71 cb ;
};
#line 85 "/usr/include/openssl/rsa.h"
struct rsa_meth_st {
   char const   *name ;
   int (*rsa_pub_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_pub_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_priv_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_priv_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_mod_exp)(BIGNUM *r0 , BIGNUM const   *I , RSA *rsa , BN_CTX *ctx ) ;
   int (*bn_mod_exp)(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(RSA *rsa ) ;
   int (*finish)(RSA *rsa ) ;
   int flags ;
   char *app_data ;
   int (*rsa_sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
                   unsigned int *siglen , RSA const   *rsa ) ;
   int (*rsa_verify)(int dtype , unsigned char const   *m , unsigned int m_length ,
                     unsigned char *sigbuf , unsigned int siglen , RSA const   *rsa ) ;
   int (*rsa_keygen)(RSA *rsa , int bits , BIGNUM *e , BN_GENCB *cb ) ;
};
#line 128 "/usr/include/openssl/rsa.h"
struct rsa_st {
   int pad ;
   long version ;
   RSA_METHOD const   *meth ;
   ENGINE *engine ;
   BIGNUM *n ;
   BIGNUM *e ;
   BIGNUM *d ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *dmp1 ;
   BIGNUM *dmq1 ;
   BIGNUM *iqmp ;
   CRYPTO_EX_DATA ex_data ;
   int references ;
   int flags ;
   BN_MONT_CTX *_method_mod_n ;
   BN_MONT_CTX *_method_mod_p ;
   BN_MONT_CTX *_method_mod_q ;
   char *bignum_data ;
   BN_BLINDING *blinding ;
   BN_BLINDING *mt_blinding ;
};
#line 19 "buffer.h"
struct __anonstruct_Buffer_74 {
   u_char *buf ;
   u_int alloc ;
   u_int offset ;
   u_int end ;
};
#line 19 "buffer.h"
typedef struct __anonstruct_Buffer_74 Buffer;
#line 106 "/usr/include/openssl/dsa.h"
struct DSA_SIG_st {
   BIGNUM *r ;
   BIGNUM *s ;
};
#line 106 "/usr/include/openssl/dsa.h"
typedef struct DSA_SIG_st DSA_SIG;
#line 112 "/usr/include/openssl/dsa.h"
struct dsa_method {
   char const   *name ;
   DSA_SIG *(*dsa_do_sign)(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
   int (*dsa_sign_setup)(DSA *dsa , BN_CTX *ctx_in , BIGNUM **kinvp , BIGNUM **rp ) ;
   int (*dsa_do_verify)(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                        DSA *dsa ) ;
   int (*dsa_mod_exp)(DSA *dsa , BIGNUM *rr , BIGNUM *a1 , BIGNUM *p1 , BIGNUM *a2 ,
                      BIGNUM *p2 , BIGNUM *m , BN_CTX *ctx , BN_MONT_CTX *in_mont ) ;
   int (*bn_mod_exp)(DSA *dsa , BIGNUM *r , BIGNUM *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DSA *dsa ) ;
   int (*finish)(DSA *dsa ) ;
   int flags ;
   char *app_data ;
   int (*dsa_paramgen)(DSA *dsa , int bits , unsigned char *seed , int seed_len ,
                       int *counter_ret , unsigned long *h_ret , BN_GENCB *cb ) ;
   int (*dsa_keygen)(DSA *dsa ) ;
};
#line 139 "/usr/include/openssl/dsa.h"
struct dsa_st {
   int pad ;
   long version ;
   int write_params ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *g ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   BIGNUM *kinv ;
   BIGNUM *r ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DSA_METHOD const   *meth ;
   ENGINE *engine ;
};
#line 32 "key.h"
struct Key;
#line 32 "key.h"
typedef struct Key Key;
#line 51 "key.h"
struct Key {
   int type ;
   int flags ;
   RSA *rsa ;
   DSA *dsa ;
};
#line 65 "authfd.h"
struct __anonstruct_AuthenticationConnection_75 {
   int fd ;
   Buffer identities ;
   int howmany ;
};
#line 65 "authfd.h"
typedef struct __anonstruct_AuthenticationConnection_75 AuthenticationConnection;
#line 90 "/usr/include/sys/types.h"
typedef __off64_t off_t;
#line 79 "/usr/include/openssl/ossl_typ.h"
struct asn1_string_st;
#line 79 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_INTEGER;
#line 80 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_ENUMERATED;
#line 81 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_BIT_STRING;
#line 82 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_OCTET_STRING;
#line 83 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_PRINTABLESTRING;
#line 84 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_T61STRING;
#line 85 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_IA5STRING;
#line 86 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_GENERALSTRING;
#line 87 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UNIVERSALSTRING;
#line 88 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_BMPSTRING;
#line 89 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UTCTIME;
#line 91 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_GENERALIZEDTIME;
#line 92 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_VISIBLESTRING;
#line 93 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UTF8STRING;
#line 94 "/usr/include/openssl/ossl_typ.h"
typedef int ASN1_BOOLEAN;
#line 116
struct evp_cipher_st;
#line 116 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_cipher_st EVP_CIPHER;
#line 117
struct evp_cipher_ctx_st;
#line 117 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_cipher_ctx_st EVP_CIPHER_CTX;
#line 120
struct evp_pkey_st;
#line 120 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_pkey_st EVP_PKEY;
#line 122
struct dh_st;
#line 122 "/usr/include/openssl/ossl_typ.h"
typedef struct dh_st DH;
#line 123
struct dh_method;
#line 123 "/usr/include/openssl/ossl_typ.h"
typedef struct dh_method DH_METHOD;
#line 206 "/usr/include/openssl/asn1.h"
struct asn1_object_st {
   char const   *sn ;
   char const   *ln ;
   int nid ;
   int length ;
   unsigned char *data ;
   int flags ;
};
#line 206 "/usr/include/openssl/asn1.h"
typedef struct asn1_object_st ASN1_OBJECT;
#line 222 "/usr/include/openssl/asn1.h"
struct asn1_string_st {
   int length ;
   int type ;
   unsigned char *data ;
   long flags ;
};
#line 222 "/usr/include/openssl/asn1.h"
typedef struct asn1_string_st ASN1_STRING;
#line 488 "/usr/include/openssl/asn1.h"
union __anonunion_value_72 {
   char *ptr ;
   ASN1_BOOLEAN boolean ;
   ASN1_STRING *asn1_string ;
   ASN1_OBJECT *object ;
   ASN1_INTEGER *integer ;
   ASN1_ENUMERATED *enumerated ;
   ASN1_BIT_STRING *bit_string ;
   ASN1_OCTET_STRING *octet_string ;
   ASN1_PRINTABLESTRING *printablestring ;
   ASN1_T61STRING *t61string ;
   ASN1_IA5STRING *ia5string ;
   ASN1_GENERALSTRING *generalstring ;
   ASN1_BMPSTRING *bmpstring ;
   ASN1_UNIVERSALSTRING *universalstring ;
   ASN1_UTCTIME *utctime ;
   ASN1_GENERALIZEDTIME *generalizedtime ;
   ASN1_VISIBLESTRING *visiblestring ;
   ASN1_UTF8STRING *utf8string ;
   ASN1_STRING *set ;
   ASN1_STRING *sequence ;
};
#line 488 "/usr/include/openssl/asn1.h"
struct asn1_type_st {
   int type ;
   union __anonunion_value_72 value ;
};
#line 488 "/usr/include/openssl/asn1.h"
typedef struct asn1_type_st ASN1_TYPE;
#line 126 "/usr/include/openssl/evp.h"
union __anonunion_pkey_73 {
   char *ptr ;
   struct rsa_st *rsa ;
   struct dsa_st *dsa ;
   struct dh_st *dh ;
};
#line 126 "/usr/include/openssl/evp.h"
struct evp_pkey_st {
   int type ;
   int save_type ;
   int references ;
   union __anonunion_pkey_73 pkey ;
   int save_parameters ;
   STACK *attributes ;
};
#line 297 "/usr/include/openssl/evp.h"
struct evp_cipher_st {
   int nid ;
   int block_size ;
   int key_len ;
   int iv_len ;
   unsigned long flags ;
   int (*init)(EVP_CIPHER_CTX *ctx , unsigned char const   *key , unsigned char const   *iv ,
               int enc ) ;
   int (*do_cipher)(EVP_CIPHER_CTX *ctx , unsigned char *out , unsigned char const   *in ,
                    unsigned int inl ) ;
   int (*cleanup)(EVP_CIPHER_CTX * ) ;
   int ctx_size ;
   int (*set_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*get_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*ctrl)(EVP_CIPHER_CTX * , int type , int arg , void *ptr ) ;
   void *app_data ;
};
#line 357 "/usr/include/openssl/evp.h"
struct evp_cipher_ctx_st {
   EVP_CIPHER const   *cipher ;
   ENGINE *engine ;
   int encrypt ;
   int buf_len ;
   unsigned char oiv[16] ;
   unsigned char iv[16] ;
   unsigned char buf[32] ;
   int num ;
   void *app_data ;
   int key_len ;
   unsigned long flags ;
   void *cipher_data ;
   int final_used ;
   int block_mask ;
   unsigned char final[32] ;
};
#line 95 "/usr/include/openssl/dh.h"
struct dh_method {
   char const   *name ;
   int (*generate_key)(DH *dh ) ;
   int (*compute_key)(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
   int (*bn_mod_exp)(DH const   *dh , BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p ,
                     BIGNUM const   *m , BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DH *dh ) ;
   int (*finish)(DH *dh ) ;
   int flags ;
   char *app_data ;
   int (*generate_params)(DH *dh , int prime_len , int generator , BN_GENCB *cb ) ;
};
#line 113 "/usr/include/openssl/dh.h"
struct dh_st {
   int pad ;
   int version ;
   BIGNUM *p ;
   BIGNUM *g ;
   long length ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   BIGNUM *q ;
   BIGNUM *j ;
   unsigned char *seed ;
   int seedlen ;
   BIGNUM *counter ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DH_METHOD const   *meth ;
   ENGINE *engine ;
};
#line 529 "/usr/include/openssl/pem.h"
typedef int pem_password_cb(char *buf , int size , int rwflag , void *userdata );
#line 61 "cipher.h"
struct Cipher;
#line 61 "cipher.h"
typedef struct Cipher Cipher;
#line 62
struct CipherContext;
#line 62 "cipher.h"
typedef struct CipherContext CipherContext;
#line 65 "cipher.h"
struct CipherContext {
   int plaintext ;
   EVP_CIPHER_CTX evp ;
   Cipher *cipher ;
};
#line 204 "/usr/include/sys/types.h"
typedef unsigned long long u_int64_t;
#line 321 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 538 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 201 "/usr/include/sys/types.h"
typedef unsigned char u_int8_t;
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_12 {
   __fd_mask __fds_bits[1024U / (8U * sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_12 fd_set;
#line 85 "/usr/include/sys/select.h"
typedef __fd_mask fd_mask;
#line 62 "channels.h"
struct Channel;
#line 63 "channels.h"
typedef struct Channel Channel;
#line 65 "channels.h"
typedef void channel_callback_fn(int  , void * );
#line 66 "channels.h"
typedef int channel_filter_fn(struct Channel * , char * , int  );
#line 68 "channels.h"
struct Channel {
   int type ;
   int self ;
   int remote_id ;
   u_int istate ;
   u_int ostate ;
   int flags ;
   int rfd ;
   int wfd ;
   int efd ;
   int sock ;
   int isatty ;
   int wfd_isatty ;
   int force_drain ;
   int delayed ;
   Buffer input ;
   Buffer output ;
   Buffer extended ;
   char path[256] ;
   int listening_port ;
   int host_port ;
   char *remote_name ;
   u_int remote_window ;
   u_int remote_maxpacket ;
   u_int local_window ;
   u_int local_window_max ;
   u_int local_consumed ;
   u_int local_maxpacket ;
   int extended_usage ;
   int single_connection ;
   char *ctype ;
   channel_callback_fn *confirm ;
   channel_callback_fn *detach_user ;
   channel_filter_fn *input_filter ;
};
#line 88 "channels.c"
struct __anonstruct_ForwardPermission_77 {
   char *host_to_connect ;
   u_short port_to_connect ;
   u_short listen_port ;
};
#line 88 "channels.c"
typedef struct __anonstruct_ForwardPermission_77 ForwardPermission;
#line 675 "channels.c"
typedef void chan_fn(Channel *c , fd_set *readset , fd_set *writeset );
#line 881 "channels.c"
struct __anonstruct_s4_req_78 {
   u_int8_t version ;
   u_int8_t command ;
   u_int16_t dest_port ;
   struct in_addr dest_addr ;
};
#line 956 "channels.c"
struct __anonstruct_s5_req_79 {
   u_int8_t version ;
   u_int8_t command ;
   u_int8_t reserved ;
   u_int8_t atyp ;
};
#line 99 "/usr/include/openssl/md5.h"
struct MD5state_st {
   unsigned int A ;
   unsigned int B ;
   unsigned int C ;
   unsigned int D ;
   unsigned int Nl ;
   unsigned int Nh ;
   unsigned int data[16] ;
   unsigned int num ;
};
#line 99 "/usr/include/openssl/md5.h"
typedef struct MD5state_st MD5_CTX;
#line 72 "cipher.c"
struct Cipher {
   char *name ;
   int number ;
   u_int block_size ;
   u_int key_len ;
   EVP_CIPHER const   *(*evptype)(void) ;
};
#line 28 "cipher-acss.c"
struct __anonstruct_EVP_ACSS_KEY_74 {
   ACSS_KEY ks ;
};
#line 28 "cipher-acss.c"
typedef struct __anonstruct_EVP_ACSS_KEY_74 EVP_ACSS_KEY;
#line 74 "/usr/include/openssl/aes.h"
struct aes_key_st {
   unsigned int rd_key[60] ;
   int rounds ;
};
#line 82 "/usr/include/openssl/aes.h"
typedef struct aes_key_st AES_KEY;
#line 41 "cipher-ctr.c"
struct ssh_aes_ctr_ctx {
   AES_KEY aes_ctx ;
   u_char aes_counter[16] ;
};
#line 50 "cipher-3des1.c"
struct ssh1_3des_ctx {
   EVP_CIPHER_CTX k1 ;
   EVP_CIPHER_CTX k2 ;
   EVP_CIPHER_CTX k3 ;
};
#line 56 "compat.c"
struct __anonstruct_check_74 {
   char *pat ;
   int bugs ;
};
#line 261 "/usr/include/zconf.h"
typedef unsigned char Byte;
#line 263 "/usr/include/zconf.h"
typedef unsigned int uInt;
#line 264 "/usr/include/zconf.h"
typedef unsigned long uLong;
#line 270 "/usr/include/zconf.h"
typedef Byte Bytef;
#line 279 "/usr/include/zconf.h"
typedef void *voidpf;
#line 80 "/usr/include/zlib.h"
struct internal_state;
#line 82 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 82 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 103 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 1346 "/usr/include/zlib.h"
struct internal_state {
   int dummy ;
};
#line 39 "log.h"
enum __anonenum_LogLevel_71 {
    SYSLOG_LEVEL_QUIET = 0,
    SYSLOG_LEVEL_FATAL = 1,
    SYSLOG_LEVEL_ERROR = 2,
    SYSLOG_LEVEL_INFO = 3,
    SYSLOG_LEVEL_VERBOSE = 4,
    SYSLOG_LEVEL_DEBUG1 = 5,
    SYSLOG_LEVEL_DEBUG2 = 6,
    SYSLOG_LEVEL_DEBUG3 = 7,
    SYSLOG_LEVEL_NOT_SET = -1
} ;
#line 39 "log.h"
typedef enum __anonenum_LogLevel_71 LogLevel;
#line 17 "hostfile.h"
enum __anonenum_HostStatus_73 {
    HOST_OK = 0,
    HOST_NEW = 1,
    HOST_CHANGED = 2,
    HOST_FOUND = 3
} ;
#line 17 "hostfile.h"
typedef enum __anonenum_HostStatus_73 HostStatus;
#line 21 "log.h"
enum __anonenum_SyslogFacility_70 {
    SYSLOG_FACILITY_DAEMON = 0,
    SYSLOG_FACILITY_USER = 1,
    SYSLOG_FACILITY_AUTH = 2,
    SYSLOG_FACILITY_AUTHPRIV = 3,
    SYSLOG_FACILITY_LOCAL0 = 4,
    SYSLOG_FACILITY_LOCAL1 = 5,
    SYSLOG_FACILITY_LOCAL2 = 6,
    SYSLOG_FACILITY_LOCAL3 = 7,
    SYSLOG_FACILITY_LOCAL4 = 8,
    SYSLOG_FACILITY_LOCAL5 = 9,
    SYSLOG_FACILITY_LOCAL6 = 10,
    SYSLOG_FACILITY_LOCAL7 = 11,
    SYSLOG_FACILITY_NOT_SET = -1
} ;
#line 21 "log.h"
typedef enum __anonenum_SyslogFacility_70 SyslogFacility;
#line 56 "log.c"
struct __anonstruct_log_facilities_72 {
   char const   *name ;
   SyslogFacility val ;
};
#line 77 "log.c"
struct __anonstruct_log_levels_73 {
   char const   *name ;
   LogLevel val ;
};
#line 77 "/usr/include/time.h"
typedef __time_t time_t;
#line 134 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 154 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 118 "/usr/include/openssl/ossl_typ.h"
struct env_md_st;
#line 118 "/usr/include/openssl/ossl_typ.h"
typedef struct env_md_st EVP_MD;
#line 119
struct env_md_ctx_st;
#line 119 "/usr/include/openssl/ossl_typ.h"
typedef struct env_md_ctx_st EVP_MD_CTX;
#line 220 "/usr/include/openssl/evp.h"
struct env_md_st {
   int type ;
   int pkey_type ;
   int md_size ;
   unsigned long flags ;
   int (*init)(EVP_MD_CTX *ctx ) ;
   int (*update)(EVP_MD_CTX *ctx , void const   *data , size_t count ) ;
   int (*final)(EVP_MD_CTX *ctx , unsigned char *md ) ;
   int (*copy)(EVP_MD_CTX *to , EVP_MD_CTX const   *from ) ;
   int (*cleanup)(EVP_MD_CTX *ctx ) ;
   int (*sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
               unsigned int *siglen , void *key ) ;
   int (*verify)(int type , unsigned char const   *m , unsigned int m_length , unsigned char const   *sigbuf ,
                 unsigned int siglen , void *key ) ;
   int required_pkey_type[5] ;
   int block_size ;
   int ctx_size ;
};
#line 280 "/usr/include/openssl/evp.h"
struct env_md_ctx_st {
   EVP_MD const   *digest ;
   ENGINE *engine ;
   unsigned long flags ;
   void *md_data ;
};
#line 66 "kex.h"
struct Mac;
#line 66 "kex.h"
typedef struct Mac Mac;
#line 67
struct Comp;
#line 67 "kex.h"
typedef struct Comp Comp;
#line 68
struct Enc;
#line 68 "kex.h"
typedef struct Enc Enc;
#line 69
struct Newkeys;
#line 69 "kex.h"
typedef struct Newkeys Newkeys;
#line 71 "kex.h"
struct Enc {
   char *name ;
   Cipher *cipher ;
   int enabled ;
   u_int key_len ;
   u_int block_size ;
   u_char *key ;
   u_char *iv ;
};
#line 80 "kex.h"
struct Mac {
   char *name ;
   int enabled ;
   EVP_MD const   *md ;
   int mac_len ;
   u_char *key ;
   int key_len ;
};
#line 88 "kex.h"
struct Comp {
   int type ;
   int enabled ;
   char *name ;
};
#line 93 "kex.h"
struct Newkeys {
   Enc enc ;
   Mac mac ;
   Comp comp ;
};
#line 121 "packet.c"
struct packet_state {
   u_int32_t seqnr ;
   u_int32_t packets ;
   u_int64_t blocks ;
};
#line 137 "packet.c"
struct __anonstruct_next_77 {
   struct packet *tqe_next ;
   struct packet **tqe_prev ;
};
#line 137 "packet.c"
struct packet {
   struct __anonstruct_next_77 next ;
   u_char type ;
   Buffer payload ;
};
#line 142 "packet.c"
struct __anonstruct_outgoing_78 {
   struct packet *tqh_first ;
   struct packet **tqh_last ;
};
#line 82 "readpass.c"
union __anonunion_72 {
   int __in ;
   int __i ;
};
#line 82 "readpass.c"
union __anonunion_73 {
   int __in ;
   int __i ;
};
#line 39 "key.h"
enum fp_type {
    SSH_FP_SHA1 = 0,
    SSH_FP_MD5 = 1
} ;
#line 43
enum fp_rep {
    SSH_FP_HEX = 0,
    SSH_FP_BUBBLEBABBLE = 1
} ;
#line 31 "dispatch.h"
typedef void dispatch_fn(int  , u_int32_t  , void * );
#line 65 "kex.h"
struct Kex;
#line 65 "kex.h"
typedef struct Kex Kex;
#line 98 "kex.h"
struct Kex {
   u_char *session_id ;
   u_int session_id_len ;
   Newkeys *newkeys[2] ;
   int we_need ;
   int server ;
   char *name ;
   int hostkey_type ;
   int kex_type ;
   Buffer my ;
   Buffer peer ;
   int done ;
   int flags ;
   char *client_version_string ;
   char *server_version_string ;
   int (*verify_host_key)(Key * ) ;
   Key *(*load_host_key)(int  ) ;
   int (*host_key_index)(Key * ) ;
   void (*kex[2])(Kex * ) ;
};
#line 75 "/usr/include/openssl/hmac.h"
struct hmac_ctx_st {
   EVP_MD const   *md ;
   EVP_MD_CTX md_ctx ;
   EVP_MD_CTX i_ctx ;
   EVP_MD_CTX o_ctx ;
   unsigned int key_length ;
   unsigned char key[128] ;
};
#line 75 "/usr/include/openssl/hmac.h"
typedef struct hmac_ctx_st HMAC_CTX;
#line 37 "mac.c"
struct __anonstruct_macs_77 {
   char *name ;
   EVP_MD const   *(*mdfunc)(void) ;
   int truncatebits ;
};
#line 27 "misc.h"
struct arglist;
#line 27 "misc.h"
typedef struct arglist arglist;
#line 28 "misc.h"
struct arglist {
   char **list ;
   int num ;
   int nalloc ;
};
#line 35 "rijndael.h"
typedef unsigned char u8;
#line 37 "rijndael.h"
typedef unsigned int u32;
#line 40 "rijndael.h"
struct __anonstruct_rijndael_ctx_70 {
   int decrypt ;
   int Nr ;
   u32 ek[60] ;
   u32 dk[60] ;
};
#line 40 "rijndael.h"
typedef struct __anonstruct_rijndael_ctx_70 rijndael_ctx;
#line 29 "dh.h"
struct dhgroup {
   int size ;
   BIGNUM *g ;
   BIGNUM *p ;
};
#line 28 "/usr/include/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 36 "servconf.h"
struct __anonstruct_ServerOptions_75 {
   u_int num_ports ;
   u_int ports_from_cmdline ;
   u_short ports[256] ;
   char *listen_addr ;
   struct addrinfo *listen_addrs ;
   char *host_key_files[256] ;
   int num_host_key_files ;
   char *pid_file ;
   int server_key_bits ;
   int login_grace_time ;
   int key_regeneration_time ;
   int permit_root_login ;
   int ignore_rhosts ;
   int ignore_user_known_hosts ;
   int print_motd ;
   int print_lastlog ;
   int x11_forwarding ;
   int x11_display_offset ;
   int x11_use_localhost ;
   char *xauth_location ;
   int strict_modes ;
   int tcp_keep_alive ;
   char *ciphers ;
   char *macs ;
   int protocol ;
   int gateway_ports ;
   SyslogFacility log_facility ;
   LogLevel log_level ;
   int rhosts_rsa_authentication ;
   int hostbased_authentication ;
   int hostbased_uses_name_from_packet_only ;
   int rsa_authentication ;
   int pubkey_authentication ;
   int kerberos_authentication ;
   int kerberos_or_local_passwd ;
   int kerberos_ticket_cleanup ;
   int kerberos_get_afs_token ;
   int gss_authentication ;
   int gss_cleanup_creds ;
   int password_authentication ;
   int kbd_interactive_authentication ;
   int challenge_response_authentication ;
   int permit_empty_passwd ;
   int permit_user_env ;
   int use_login ;
   int compression ;
   int allow_tcp_forwarding ;
   u_int num_allow_users ;
   char *allow_users[256] ;
   u_int num_deny_users ;
   char *deny_users[256] ;
   u_int num_allow_groups ;
   char *allow_groups[256] ;
   u_int num_deny_groups ;
   char *deny_groups[256] ;
   u_int num_subsystems ;
   char *subsystem_name[256] ;
   char *subsystem_command[256] ;
   int max_startups_begin ;
   int max_startups_rate ;
   int max_startups ;
   char *banner ;
   int use_dns ;
   int client_alive_interval ;
   int client_alive_count_max ;
   char *authorized_keys_file ;
   char *authorized_keys_file2 ;
   int use_pam ;
};
#line 36 "servconf.h"
typedef struct __anonstruct_ServerOptions_75 ServerOptions;
#line 45 "auth.h"
struct Authctxt;
#line 45 "auth.h"
typedef struct Authctxt Authctxt;
#line 49 "auth.h"
struct Authctxt {
   int success ;
   int postponed ;
   int valid ;
   int attempt ;
   int failures ;
   int force_pwchange ;
   char *user ;
   char *service ;
   struct passwd *pw ;
   char *style ;
   void *kbdintctxt ;
   void *methoddata ;
};
#line 32 "monitor_mm.h"
struct __anonstruct_next_80 {
   struct mm_share *rbe_left ;
   struct mm_share *rbe_right ;
   struct mm_share *rbe_parent ;
   int rbe_color ;
};
#line 32 "monitor_mm.h"
struct mm_share {
   struct __anonstruct_next_80 next ;
   void *address ;
   size_t size ;
};
#line 38 "monitor_mm.h"
struct mmtree {
   struct mm_share *rbh_root ;
};
#line 38 "monitor_mm.h"
struct mm_master {
   struct mmtree rb_free ;
   struct mmtree rb_allocated ;
   void *address ;
   size_t size ;
   struct mm_master *mmalloc ;
   int write ;
   int read ;
};
#line 66 "monitor.h"
struct monitor {
   int m_recvfd ;
   int m_sendfd ;
   struct mm_master *m_zback ;
   struct mm_master *m_zlib ;
   struct Kex **m_pkex ;
   pid_t m_pid ;
};
#line 167 "sshd.c"
struct __anonstruct_sensitive_data_81 {
   Key *server_key ;
   Key *ssh1_host_key ;
   Key **host_keys ;
   int have_ssh1_key ;
   int have_ssh2_key ;
   u_char ssh1_cookie[32] ;
};
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 43 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 48 "loginrec.h"
union login_netinfo {
   struct sockaddr sa ;
   struct sockaddr_in sa_in ;
   struct sockaddr_storage sa_storage ;
};
#line 68 "loginrec.h"
struct logininfo {
   char progname[64] ;
   int progname_null ;
   short type ;
   int pid ;
   int uid ;
   char line[64] ;
   char username[64] ;
   char hostname[256] ;
   int exit ;
   int termination ;
   unsigned int tv_sec ;
   unsigned int tv_usec ;
   union login_netinfo hostaddr ;
};
#line 247 "servconf.c"
enum __anonenum_ServerOpCodes_78 {
    sBadOption = 0,
    sUsePAM = 1,
    sPort = 2,
    sHostKeyFile = 3,
    sServerKeyBits = 4,
    sLoginGraceTime = 5,
    sKeyRegenerationTime = 6,
    sPermitRootLogin = 7,
    sLogFacility = 8,
    sLogLevel = 9,
    sRhostsRSAAuthentication = 10,
    sRSAAuthentication = 11,
    sKerberosAuthentication = 12,
    sKerberosOrLocalPasswd = 13,
    sKerberosTicketCleanup = 14,
    sKerberosGetAFSToken = 15,
    sKerberosTgtPassing = 16,
    sChallengeResponseAuthentication = 17,
    sPasswordAuthentication = 18,
    sKbdInteractiveAuthentication = 19,
    sListenAddress = 20,
    sPrintMotd = 21,
    sPrintLastLog = 22,
    sIgnoreRhosts = 23,
    sX11Forwarding = 24,
    sX11DisplayOffset = 25,
    sX11UseLocalhost = 26,
    sStrictModes = 27,
    sEmptyPasswd = 28,
    sTCPKeepAlive = 29,
    sPermitUserEnvironment = 30,
    sUseLogin = 31,
    sAllowTcpForwarding = 32,
    sCompression = 33,
    sAllowUsers = 34,
    sDenyUsers = 35,
    sAllowGroups = 36,
    sDenyGroups = 37,
    sIgnoreUserKnownHosts = 38,
    sCiphers = 39,
    sMacs = 40,
    sProtocol = 41,
    sPidFile = 42,
    sGatewayPorts = 43,
    sPubkeyAuthentication = 44,
    sXAuthLocation = 45,
    sSubsystem = 46,
    sMaxStartups = 47,
    sBanner = 48,
    sUseDNS = 49,
    sHostbasedAuthentication = 50,
    sHostbasedUsesNameFromPacketOnly = 51,
    sClientAliveInterval = 52,
    sClientAliveCountMax = 53,
    sAuthorizedKeysFile = 54,
    sAuthorizedKeysFile2 = 55,
    sGssAuthentication = 56,
    sGssCleanupCreds = 57,
    sUsePrivilegeSeparation = 58,
    sDeprecated = 59,
    sUnsupported = 60
} ;
#line 247 "servconf.c"
typedef enum __anonenum_ServerOpCodes_78 ServerOpCodes;
#line 275 "servconf.c"
struct __anonstruct_keywords_79 {
   char const   *name ;
   ServerOpCodes opcode ;
};
#line 30 "session.h"
struct Session;
#line 30 "session.h"
typedef struct Session Session;
#line 31 "session.h"
struct Session {
   int used ;
   int self ;
   struct passwd *pw ;
   Authctxt *authctxt ;
   pid_t pid ;
   char *term ;
   int ptyfd ;
   int ttyfd ;
   int ptymaster ;
   u_int row ;
   u_int col ;
   u_int xpixel ;
   u_int ypixel ;
   char tty[64] ;
   char hostname[64] ;
   time_t last_login_time ;
   u_int display_number ;
   char *display ;
   u_int screen ;
   char *auth_display ;
   char *auth_proto ;
   char *auth_data ;
   int single_connection ;
   int chanid ;
   int is_subsystem ;
};
#line 686 "serverloop.c"
union __anonunion_80 {
   int __in ;
   int __i ;
};
#line 688 "serverloop.c"
union __anonunion_81 {
   int __in ;
   int __i ;
};
#line 684 "serverloop.c"
union __anonunion_82 {
   int __in ;
   int __i ;
};
#line 709 "serverloop.c"
union __anonunion_83 {
   int __in ;
   int __i ;
};
#line 708 "serverloop.c"
union __anonunion_84 {
   int __in ;
   int __i ;
};
#line 46 "auth.h"
struct Authmethod;
#line 46 "auth.h"
typedef struct Authmethod Authmethod;
#line 80 "auth.h"
struct Authmethod {
   char *name ;
   int (*userauth)(Authctxt *authctxt ) ;
   int *enabled ;
};
#line 19 "auth-options.h"
struct envstring {
   struct envstring *next ;
   char *s ;
};
#line 1985 "session.c"
union __anonunion_78 {
   int __in ;
   int __i ;
};
#line 1989 "session.c"
union __anonunion_79 {
   int __in ;
   int __i ;
};
#line 1991 "session.c"
union __anonunion_80___0 {
   int __in ;
   int __i ;
};
#line 1987 "session.c"
union __anonunion_81___0 {
   int __in ;
   int __i ;
};
#line 1983 "session.c"
union __anonunion_82___0 {
   int __in ;
   int __i ;
};
#line 47 "auth.h"
struct KbdintDevice;
#line 47 "auth.h"
typedef struct KbdintDevice KbdintDevice;
#line 93 "auth.h"
struct KbdintDevice {
   char const   *name ;
   void *(*init_ctx)(Authctxt * ) ;
   int (*query)(void *ctx , char **name , char **infotxt , u_int *numprompts , char ***prompts ,
                u_int **echo_on ) ;
   int (*respond)(void *ctx , u_int numresp , char **responses ) ;
   void (*free_ctx)(void *ctx ) ;
};
#line 66 "auth2-chall.c"
struct KbdintAuthctxt;
#line 66 "auth2-chall.c"
typedef struct KbdintAuthctxt KbdintAuthctxt;
#line 67 "auth2-chall.c"
struct KbdintAuthctxt {
   char *devices ;
   void *ctxt ;
   KbdintDevice *device ;
   u_int nreq ;
};
#line 31 "monitor.h"
enum monitor_reqtype {
    MONITOR_REQ_MODULI = 0,
    MONITOR_ANS_MODULI = 1,
    MONITOR_REQ_FREE = 2,
    MONITOR_REQ_AUTHSERV = 3,
    MONITOR_REQ_SIGN = 4,
    MONITOR_ANS_SIGN = 5,
    MONITOR_REQ_PWNAM = 6,
    MONITOR_ANS_PWNAM = 7,
    MONITOR_REQ_AUTH2_READ_BANNER = 8,
    MONITOR_ANS_AUTH2_READ_BANNER = 9,
    MONITOR_REQ_AUTHPASSWORD = 10,
    MONITOR_ANS_AUTHPASSWORD = 11,
    MONITOR_REQ_BSDAUTHQUERY = 12,
    MONITOR_ANS_BSDAUTHQUERY = 13,
    MONITOR_REQ_BSDAUTHRESPOND = 14,
    MONITOR_ANS_BSDAUTHRESPOND = 15,
    MONITOR_REQ_SKEYQUERY = 16,
    MONITOR_ANS_SKEYQUERY = 17,
    MONITOR_REQ_SKEYRESPOND = 18,
    MONITOR_ANS_SKEYRESPOND = 19,
    MONITOR_REQ_KEYALLOWED = 20,
    MONITOR_ANS_KEYALLOWED = 21,
    MONITOR_REQ_KEYVERIFY = 22,
    MONITOR_ANS_KEYVERIFY = 23,
    MONITOR_REQ_KEYEXPORT = 24,
    MONITOR_REQ_PTY = 25,
    MONITOR_ANS_PTY = 26,
    MONITOR_REQ_PTYCLEANUP = 27,
    MONITOR_REQ_SESSKEY = 28,
    MONITOR_ANS_SESSKEY = 29,
    MONITOR_REQ_SESSID = 30,
    MONITOR_REQ_RSAKEYALLOWED = 31,
    MONITOR_ANS_RSAKEYALLOWED = 32,
    MONITOR_REQ_RSACHALLENGE = 33,
    MONITOR_ANS_RSACHALLENGE = 34,
    MONITOR_REQ_RSARESPONSE = 35,
    MONITOR_ANS_RSARESPONSE = 36,
    MONITOR_REQ_GSSSETUP = 37,
    MONITOR_ANS_GSSSETUP = 38,
    MONITOR_REQ_GSSSTEP = 39,
    MONITOR_ANS_GSSSTEP = 40,
    MONITOR_REQ_GSSUSEROK = 41,
    MONITOR_ANS_GSSUSEROK = 42,
    MONITOR_REQ_GSSCHECKMIC = 43,
    MONITOR_ANS_GSSCHECKMIC = 44,
    MONITOR_REQ_PAM_START = 45,
    MONITOR_REQ_PAM_ACCOUNT = 46,
    MONITOR_ANS_PAM_ACCOUNT = 47,
    MONITOR_REQ_PAM_INIT_CTX = 48,
    MONITOR_ANS_PAM_INIT_CTX = 49,
    MONITOR_REQ_PAM_QUERY = 50,
    MONITOR_ANS_PAM_QUERY = 51,
    MONITOR_REQ_PAM_RESPOND = 52,
    MONITOR_ANS_PAM_RESPOND = 53,
    MONITOR_REQ_PAM_FREE_CTX = 54,
    MONITOR_ANS_PAM_FREE_CTX = 55,
    MONITOR_REQ_TERM = 56
} ;
#line 83
struct mon_table;
#line 36 "monitor_wrap.h"
enum mm_keytype {
    MM_NOKEY = 0,
    MM_HOSTKEY = 1,
    MM_USERKEY = 2,
    MM_RSAHOSTKEY = 3,
    MM_RSAUSERKEY = 4
} ;
#line 86 "monitor.c"
struct __anonstruct_child_state_80 {
   z_stream incoming ;
   z_stream outgoing ;
   u_char *keyin ;
   u_int keyinlen ;
   u_char *keyout ;
   u_int keyoutlen ;
   u_char *ivin ;
   u_int ivinlen ;
   u_char *ivout ;
   u_int ivoutlen ;
   u_char *ssh1key ;
   u_int ssh1keylen ;
   int ssh1cipher ;
   int ssh1protoflags ;
   u_char *input ;
   u_int ilen ;
   u_char *output ;
   u_int olen ;
};
#line 160 "monitor.c"
struct mon_table {
   enum monitor_reqtype type ;
   int flags ;
   int (*f)(int  , Buffer * ) ;
};
#line 1480 "monitor.c"
union __anonunion_81___1 {
   int __in ;
   int __i ;
};
#line 1480 "monitor.c"
union __anonunion_82___1 {
   int __in ;
   int __i ;
};
#line 1480 "monitor.c"
union __anonunion_83___0 {
   int __in ;
   int __i ;
};
#line 1480 "monitor.c"
union __anonunion_84___0 {
   int __in ;
   int __i ;
};
#line 44 "/usr/include/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 215 "/usr/include/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 233 "/usr/include/bits/socket.h"
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 38 "/usr/include/bits/utmp.h"
struct lastlog {
   __time_t ll_time ;
   char ll_line[32] ;
   char ll_host[256] ;
};
#line 52 "/usr/include/bits/utmp.h"
struct exit_status {
   short e_termination ;
   short e_exit ;
};
#line 60 "/usr/include/bits/utmp.h"
struct utmp {
   short ut_type ;
   pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct exit_status ut_exit ;
   long ut_session ;
   struct timeval ut_tv ;
   int32_t ut_addr_v6[4] ;
   char __unused[20] ;
};
#line 1 "port-irix.o"
#line 1 "port-aix.o"
#line 1 "bsd-arc4random.o"
#line 59 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 137 "./openbsd-compat/openbsd-compat.h"
unsigned int arc4random(void) ;
#line 138
void arc4random_stir(void) ;
#line 30 "./entropy.h"
void seed_rng(void) ;
#line 56 "./log.h"
void ( /* format attribute */  fatal)(char const   *fmt  , ...) ;
#line 102 "/usr/include/openssl/rand.h"
extern int RAND_bytes(unsigned char *buf , int num ) ;
#line 79 "/usr/include/openssl/rc4.h"
extern void RC4_set_key(RC4_KEY *key , int len , unsigned char const   *data ) ;
#line 80
extern void RC4(RC4_KEY *key , unsigned long len , unsigned char const   *indata ,
                unsigned char *outdata ) ;
#line 258 "/usr/include/openssl/err.h"
extern unsigned long ERR_get_error(void) ;
#line 34 "openbsd-compat/bsd-arc4random.c"
static int rc4_ready  =    0;
#line 35 "openbsd-compat/bsd-arc4random.c"
static RC4_KEY rc4  ;
#line 40 "openbsd-compat/bsd-arc4random.c"
static int first_time  =    1;
#line 37 "openbsd-compat/bsd-arc4random.c"
unsigned int arc4random(void) 
{ unsigned int r ;

  {
#line 39
  r = 0U;
#line 42
  if (rc4_ready <= 0) {
#line 43
    if (first_time) {
#line 44
      seed_rng();
    }
#line 45
    first_time = 0;
#line 46
    arc4random_stir();
  }
#line 49
  RC4(& rc4, (unsigned long )sizeof(r), (unsigned char const   *)((unsigned char *)(& r)),
      (unsigned char *)(& r));
#line 51
  rc4_ready = (int )((unsigned int )rc4_ready - sizeof(r));
#line 53
  return (r);
}
}
#line 56 "openbsd-compat/bsd-arc4random.c"
void arc4random_stir(void) 
{ unsigned char rand_buf[20] ;
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 60
  memset((void *)(& rc4), 0, sizeof(rc4));
#line 61
  tmp___0 = RAND_bytes(rand_buf, (int )sizeof(rand_buf));
#line 61
  if (tmp___0 <= 0) {
#line 62
    tmp = ERR_get_error();
#line 62
    fatal("Couldn\'t obtain random bytes (error %ld)", tmp);
  }
#line 64
  RC4_set_key(& rc4, (int )sizeof(rand_buf), (unsigned char const   *)(rand_buf));
#line 65
  RC4(& rc4, (unsigned long )sizeof(rand_buf), (unsigned char const   *)(rand_buf),
      rand_buf);
#line 66
  memset((void *)(rand_buf), 0, sizeof(rand_buf));
#line 68
  rc4_ready = 1 << 24;
#line 69
  return;
}
}
#line 1 "bsd-cray.o"
#line 1 "bsd-cygwin_util.o"
#line 1 "bsd-getpeereid.o"
#line 185 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
#line 133 "./openbsd-compat/openbsd-compat.h"
int getpeereid(int s , uid_t *euid , gid_t *gid ) ;
#line 24 "openbsd-compat/bsd-getpeereid.c"
int getpeereid(int s , uid_t *euid , gid_t *gid ) 
{ struct ucred cred ;
  socklen_t len ;
  int tmp ;

  {
#line 28
  len = sizeof(cred);
#line 30
  tmp = getsockopt(s, 1, 17, (void * __restrict  )(& cred), (socklen_t * __restrict  )(& len));
#line 30
  if (tmp < 0) {
#line 31
    return (-1);
  }
#line 32
  *euid = cred.uid;
#line 33
  *gid = cred.gid;
#line 35
  return (0);
}
}
#line 1 "bsd-misc.o"
#line 216 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
#line 260
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 828 "/usr/include/unistd.h"
 __attribute__((__nothrow__)) int setlogin(char const   *name )  __attribute__((__nonnull__(1))) ;
#line 24 "./openbsd-compat/bsd-misc.h"
char *ssh_get_progname(char *argv0___0 ) ;
#line 98
mysig_t mysignal(int sig , void (*act)(int  ) ) ;
#line 25 "./xmalloc.h"
char *xstrdup(char const   *str ) ;
#line 29 "openbsd-compat/bsd-misc.c"
extern char *__progname ;
#line 26 "openbsd-compat/bsd-misc.c"
char *ssh_get_progname(char *argv0___0 ) 
{ char *tmp ;

  {
#line 31
  tmp = xstrdup((char const   *)__progname);
#line 31
  return (tmp);
}
}
#line 48
 __attribute__((__nothrow__)) int setlogin(char const   *name )  __attribute__((__nonnull__(1))) ;
#line 48 "openbsd-compat/bsd-misc.c"
int setlogin(char const   *name ) 
{ 

  {
#line 50
  return (0);
}
}
#line 195 "openbsd-compat/bsd-misc.c"
mysig_t mysignal(int sig , void (*act)(int  ) ) 
{ struct sigaction sa ;
  struct sigaction osa ;
  int tmp ;
  int tmp___0 ;

  {
#line 201
  tmp = sigaction(sig, (struct sigaction  const  * __restrict  )((void *)0), (struct sigaction * __restrict  )(& osa));
#line 201
  if (tmp == -1) {
#line 202
    return ((void (*)(int  ))-1);
  }
#line 203
  if ((unsigned int )osa.__sigaction_handler.sa_handler != (unsigned int )act) {
#line 204
    memset((void *)(& sa), 0, sizeof(sa));
#line 205
    sigemptyset(& sa.sa_mask);
#line 206
    sa.sa_flags = 0;
#line 208
    if (sig == 14) {
#line 209
      sa.sa_flags |= 536870912;
    }
#line 211
    sa.__sigaction_handler.sa_handler = act;
#line 212
    tmp___0 = sigaction(sig, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
#line 212
    if (tmp___0 == -1) {
#line 213
      return ((void (*)(int  ))-1);
    }
  }
#line 215
  return (osa.__sigaction_handler.sa_handler);
}
}
#line 1 "bsd-nextstep.o"
#line 1 "bsd-openpty.o"
#line 1 "bsd-snprintf.o"
#line 1 "bsd-waitpid.o"
#line 1 "fake-rfc2553.o"
#line 1 "xmmap.o"
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 712 "/usr/include/stdlib.h"
int mkstemp(char *path )  __asm__("mkstemp64") __attribute__((__nonnull__(1))) ;
#line 256 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 320 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 792
extern  __attribute__((__nothrow__)) int unlink(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 973
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off64_t __length )  __asm__("ftruncate64")  ;
#line 62 "/usr/include/sys/mman.h"
extern  __attribute__((__nothrow__)) void *mmap(void *__addr , size_t __len , int __prot ,
                                                int __flags , int __fd , __off64_t __offset )  __asm__("mmap64")  ;
#line 155 "./openbsd-compat/openbsd-compat.h"
void *xmmap(size_t size ) ;
#line 36 "openbsd-compat/xmmap.c"
void *xmmap(size_t size ) 
{ void *address ;
  char tmpname[sizeof("/var/run/sshd.mm.XXXXXXXX")] ;
  int tmpfd ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 42
  address = mmap((void *)0, size, 3, 33, -1, 0LL);
#line 50
  if ((unsigned int )address == (unsigned int )((void *)-1)) {
#line 51
    tmpname[0] = (char )'/';
#line 51
    tmpname[1] = (char )'v';
#line 51
    tmpname[2] = (char )'a';
#line 51
    tmpname[3] = (char )'r';
#line 51
    tmpname[4] = (char )'/';
#line 51
    tmpname[5] = (char )'r';
#line 51
    tmpname[6] = (char )'u';
#line 51
    tmpname[7] = (char )'n';
#line 51
    tmpname[8] = (char )'/';
#line 51
    tmpname[9] = (char )'s';
#line 51
    tmpname[10] = (char )'s';
#line 51
    tmpname[11] = (char )'h';
#line 51
    tmpname[12] = (char )'d';
#line 51
    tmpname[13] = (char )'.';
#line 51
    tmpname[14] = (char )'m';
#line 51
    tmpname[15] = (char )'m';
#line 51
    tmpname[16] = (char )'.';
#line 51
    tmpname[17] = (char )'X';
#line 51
    tmpname[18] = (char )'X';
#line 51
    tmpname[19] = (char )'X';
#line 51
    tmpname[20] = (char )'X';
#line 51
    tmpname[21] = (char )'X';
#line 51
    tmpname[22] = (char )'X';
#line 51
    tmpname[23] = (char )'X';
#line 51
    tmpname[24] = (char )'X';
#line 51
    tmpname[25] = (char )'\000';
#line 54
    tmpfd = mkstemp(tmpname);
#line 55
    if (tmpfd == -1) {
#line 56
      tmp = __errno_location();
#line 56
      tmp___0 = strerror(*tmp);
#line 56
      fatal("mkstemp(\"%s\"): %s", "/var/run/sshd.mm.XXXXXXXX", tmp___0);
    }
#line 58
    unlink((char const   *)(tmpname));
#line 59
    ftruncate(tmpfd, (long long )size);
#line 60
    address = mmap((void *)0, size, 3, 1, tmpfd, 0LL);
#line 62
    close(tmpfd);
  }
#line 65
  return (address);
}
}
#line 1 "xcrypt.o"
#line 156 "./openbsd-compat/openbsd-compat.h"
char *xcrypt(char const   *password , char const   *salt ) ;
#line 157
char *shadow_pw(struct passwd *pw ) ;
#line 33 "/usr/include/crypt.h"
extern  __attribute__((__nothrow__)) char *crypt(char const   *__key , char const   *__salt )  __attribute__((__nonnull__(1,2))) ;
#line 87 "/usr/include/shadow.h"
extern struct spwd *getspnam(char const   *__name ) ;
#line 56 "openbsd-compat/xcrypt.c"
char *xcrypt(char const   *password , char const   *salt ) 
{ char *crypted ;

  {
#line 74
  crypted = crypt(password, salt);
#line 77
  return (crypted);
}
}
#line 85 "openbsd-compat/xcrypt.c"
char *shadow_pw(struct passwd *pw ) 
{ char *pw_password ;
  struct spwd *spw ;
  struct spwd *tmp ;

  {
#line 88
  pw_password = pw->pw_passwd;
#line 91
  tmp = getspnam((char const   *)pw->pw_name);
#line 91
  spw = tmp;
#line 93
  if ((unsigned int )spw != (unsigned int )((void *)0)) {
#line 94
    pw_password = spw->sp_pwdp;
  }
#line 107
  return (pw_password);
}
}
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
#line 1 "base64.o"
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 628 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 323 "/usr/include/resolv.h"
 __attribute__((__nothrow__)) int __b64_ntop(u_char const   *src , size_t srclength ,
                                             char *target , size_t targsize ) ;
#line 324
 __attribute__((__nothrow__)) int __b64_pton(char const   *src , u_char *target ,
                                             size_t targsize ) ;
#line 68 "openbsd-compat/base64.c"
static char const   Base64[65]  = 
#line 68 "openbsd-compat/base64.c"
  {      (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'g',      (char const   )'h',      (char const   )'i',      (char const   )'j', 
        (char const   )'k',      (char const   )'l',      (char const   )'m',      (char const   )'n', 
        (char const   )'o',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'+',      (char const   )'/', 
        (char const   )'\000'};
#line 70 "openbsd-compat/base64.c"
static char const   Pad64  =    (char const   )'=';
#line 136
 __attribute__((__nothrow__)) int __b64_ntop(u_char const   *src , size_t srclength ,
                                             char *target , size_t targsize ) ;
#line 136 "openbsd-compat/base64.c"
int __b64_ntop(u_char const   *src , size_t srclength , char *target , size_t targsize ) 
{ size_t datalength ;
  u_char input___0[3] ;
  u_char output___0[4] ;
  int i ;
  u_char const   *tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  u_char const   *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;

  {
#line 139
  datalength = (size_t )0;
#line 144
  while (2U < srclength) {
#line 145
    tmp = src;
#line 145
    src ++;
#line 145
    input___0[0] = (unsigned char )*tmp;
#line 146
    tmp___0 = src;
#line 146
    src ++;
#line 146
    input___0[1] = (unsigned char )*tmp___0;
#line 147
    tmp___1 = src;
#line 147
    src ++;
#line 147
    input___0[2] = (unsigned char )*tmp___1;
#line 148
    srclength -= 3U;
#line 150
    output___0[0] = (unsigned char )((int )input___0[0] >> 2);
#line 151
    output___0[1] = (unsigned char )((((int )input___0[0] & 3) << 4) + ((int )input___0[1] >> 4));
#line 152
    output___0[2] = (unsigned char )((((int )input___0[1] & 15) << 2) + ((int )input___0[2] >> 6));
#line 153
    output___0[3] = (unsigned char )((int )input___0[2] & 63);
#line 154
    if (! ((int )output___0[0] < 64)) {
#line 154
      abort();
    }
#line 155
    if (! ((int )output___0[1] < 64)) {
#line 155
      abort();
    }
#line 156
    if (! ((int )output___0[2] < 64)) {
#line 156
      abort();
    }
#line 157
    if (! ((int )output___0[3] < 64)) {
#line 157
      abort();
    }
#line 159
    if (datalength + 4U > targsize) {
#line 160
      return (-1);
    }
#line 161
    tmp___2 = datalength;
#line 161
    datalength ++;
#line 161
    *(target + tmp___2) = (char )Base64[output___0[0]];
#line 162
    tmp___3 = datalength;
#line 162
    datalength ++;
#line 162
    *(target + tmp___3) = (char )Base64[output___0[1]];
#line 163
    tmp___4 = datalength;
#line 163
    datalength ++;
#line 163
    *(target + tmp___4) = (char )Base64[output___0[2]];
#line 164
    tmp___5 = datalength;
#line 164
    datalength ++;
#line 164
    *(target + tmp___5) = (char )Base64[output___0[3]];
  }
#line 168
  if (0U != srclength) {
#line 170
    input___0[2] = (unsigned char )'\000';
#line 170
    input___0[1] = input___0[2];
#line 170
    input___0[0] = input___0[1];
#line 171
    i = 0;
#line 171
    while ((size_t )i < srclength) {
#line 172
      tmp___6 = src;
#line 172
      src ++;
#line 172
      input___0[i] = (unsigned char )*tmp___6;
#line 171
      i ++;
    }
#line 174
    output___0[0] = (unsigned char )((int )input___0[0] >> 2);
#line 175
    output___0[1] = (unsigned char )((((int )input___0[0] & 3) << 4) + ((int )input___0[1] >> 4));
#line 176
    output___0[2] = (unsigned char )((((int )input___0[1] & 15) << 2) + ((int )input___0[2] >> 6));
#line 177
    if (! ((int )output___0[0] < 64)) {
#line 177
      abort();
    }
#line 178
    if (! ((int )output___0[1] < 64)) {
#line 178
      abort();
    }
#line 179
    if (! ((int )output___0[2] < 64)) {
#line 179
      abort();
    }
#line 181
    if (datalength + 4U > targsize) {
#line 182
      return (-1);
    }
#line 183
    tmp___7 = datalength;
#line 183
    datalength ++;
#line 183
    *(target + tmp___7) = (char )Base64[output___0[0]];
#line 184
    tmp___8 = datalength;
#line 184
    datalength ++;
#line 184
    *(target + tmp___8) = (char )Base64[output___0[1]];
#line 185
    if (srclength == 1U) {
#line 186
      tmp___9 = datalength;
#line 186
      datalength ++;
#line 186
      *(target + tmp___9) = (char )Pad64;
    } else {
#line 188
      tmp___10 = datalength;
#line 188
      datalength ++;
#line 188
      *(target + tmp___10) = (char )Base64[output___0[2]];
    }
#line 189
    tmp___11 = datalength;
#line 189
    datalength ++;
#line 189
    *(target + tmp___11) = (char )Pad64;
  }
#line 191
  if (datalength >= targsize) {
#line 192
    return (-1);
  }
#line 193
  *(target + datalength) = (char )'\000';
#line 194
  return ((int )datalength);
}
}
#line 206
 __attribute__((__nothrow__)) int __b64_pton(char const   *src , u_char *target ,
                                             size_t targsize ) ;
#line 206 "openbsd-compat/base64.c"
int __b64_pton(char const   *src , u_char *target , size_t targsize ) 
{ int tarindex ;
  int state ;
  int ch ;
  char *pos ;
  unsigned short const   **tmp ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  unsigned short const   **tmp___8 ;

  {
#line 212
  state = 0;
#line 213
  tarindex = 0;
#line 215
  while (1) {
#line 215
    tmp___2 = src;
#line 215
    src ++;
#line 215
    ch = (int )*tmp___2;
#line 215
    if (! (ch != 0)) {
#line 215
      break;
    }
#line 216
    tmp = __ctype_b_loc();
#line 216
    if ((int const   )*(*tmp + ch) & 8192) {
#line 217
      continue;
    }
#line 219
    if (ch == (int )Pad64) {
#line 220
      break;
    }
#line 222
    tmp___1 = __builtin_strchr((char *)(Base64), ch);
#line 222
    pos = tmp___1;
#line 223
    if ((unsigned int )pos == (unsigned int )((char *)0)) {
#line 224
      return (-1);
    }
#line 226
    switch (state) {
    case 0: 
#line 228
    if (target) {
#line 229
      if ((size_t )tarindex >= targsize) {
#line 230
        return (-1);
      }
#line 231
      *(target + tarindex) = (unsigned char )((pos - (char *)(Base64)) << 2);
    }
#line 233
    state = 1;
#line 234
    break;
    case 1: 
#line 236
    if (target) {
#line 237
      if ((size_t )(tarindex + 1) >= targsize) {
#line 238
        return (-1);
      }
#line 239
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | ((pos - (char *)(Base64)) >> 4));
#line 240
      *(target + (tarindex + 1)) = (unsigned char )(((pos - (char *)(Base64)) & 15) << 4);
    }
#line 243
    tarindex ++;
#line 244
    state = 2;
#line 245
    break;
    case 2: 
#line 247
    if (target) {
#line 248
      if ((size_t )(tarindex + 1) >= targsize) {
#line 249
        return (-1);
      }
#line 250
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | ((pos - (char *)(Base64)) >> 2));
#line 251
      *(target + (tarindex + 1)) = (unsigned char )(((pos - (char *)(Base64)) & 3) << 6);
    }
#line 254
    tarindex ++;
#line 255
    state = 3;
#line 256
    break;
    case 3: 
#line 258
    if (target) {
#line 259
      if ((size_t )tarindex >= targsize) {
#line 260
        return (-1);
      }
#line 261
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | (pos - (char *)(Base64)));
    }
#line 263
    tarindex ++;
#line 264
    state = 0;
#line 265
    break;
    }
  }
#line 274
  if (ch == (int )Pad64) {
#line 275
    tmp___3 = src;
#line 275
    src ++;
#line 275
    ch = (int )*tmp___3;
#line 276
    switch (state) {
    case 0: 
    case 1: 
#line 279
    return (-1);
    case 2: 
#line 283
    while (ch != 0) {
#line 284
      tmp___5 = __ctype_b_loc();
#line 284
      if (! ((int const   )*(*tmp___5 + ch) & 8192)) {
#line 285
        break;
      }
#line 283
      tmp___4 = src;
#line 283
      src ++;
#line 283
      ch = (int )*tmp___4;
    }
#line 287
    if (ch != (int )Pad64) {
#line 288
      return (-1);
    }
#line 289
    tmp___6 = src;
#line 289
    src ++;
#line 289
    ch = (int )*tmp___6;
    case 3: 
#line 298
    while (ch != 0) {
#line 299
      tmp___8 = __ctype_b_loc();
#line 299
      if (! ((int const   )*(*tmp___8 + ch) & 8192)) {
#line 300
        return (-1);
      }
#line 298
      tmp___7 = src;
#line 298
      src ++;
#line 298
      ch = (int )*tmp___7;
    }
#line 308
    if (target) {
#line 308
      if ((int )*(target + tarindex) != 0) {
#line 309
        return (-1);
      }
    }
    }
  } else {
#line 316
    if (state != 0) {
#line 317
      return (-1);
    }
  }
#line 320
  return (tarindex);
}
}
#line 1 "basename.o"
#line 1 "bindresvport.o"
#line 110 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  * __restrict  __addr ,
                                              socklen_t __len ) ;
#line 114
extern  __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 48 "./openbsd-compat/openbsd-compat.h"
int bindresvport_sa(int sd , struct sockaddr *sa ) ;
#line 44 "openbsd-compat/bindresvport.c"
int bindresvport_sa(int sd , struct sockaddr *sa ) 
{ int error___0 ;
  int af ;
  struct sockaddr_storage myaddr ;
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;
  u_int16_t *portp ;
  u_int16_t port ;
  socklen_t salen ;
  int i ;
  int tmp ;
  int *tmp___0 ;
  register unsigned short __v ;
  register unsigned short __x ;
  unsigned int tmp___1 ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 58
  if ((unsigned int )sa == (unsigned int )((void *)0)) {
#line 59
    memset((void *)(& myaddr), 0, sizeof(myaddr));
#line 60
    sa = (struct sockaddr *)(& myaddr);
#line 62
    tmp = getsockname(sd, (struct sockaddr * __restrict  )sa, (socklen_t * __restrict  )(& salen));
#line 62
    if (tmp == -1) {
#line 63
      return (-1);
    }
#line 65
    af = (int )sa->sa_family;
#line 66
    memset((void *)(& myaddr), 0, salen);
  } else {
#line 68
    af = (int )sa->sa_family;
  }
#line 70
  if (af == 2) {
#line 71
    sin = (struct sockaddr_in *)sa;
#line 72
    salen = sizeof(struct sockaddr_in );
#line 73
    portp = & sin->sin_port;
  } else {
#line 74
    if (af == 10) {
#line 75
      sin6 = (struct sockaddr_in6 *)sa;
#line 76
      salen = sizeof(struct sockaddr_in6 );
#line 77
      portp = & sin6->sin6_port;
    } else {
#line 79
      tmp___0 = __errno_location();
#line 79
      *tmp___0 = 96;
#line 80
      return (-1);
    }
  }
#line 82
  sa->sa_family = (unsigned short )af;
#line 84
  __x = *portp;
#line 84
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 84
  port = __v;
#line 85
  if ((int )port == 0) {
#line 86
    tmp___1 = arc4random();
#line 86
    port = (unsigned short )(tmp___1 % 424U + 600U);
  }
#line 89
  error___0 = -1;
#line 91
  i = 0;
#line 91
  while (i < 424) {
#line 92
    __x___0 = port;
#line 92
    __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 92
    *portp = __v___0;
#line 94
    error___0 = bind(sd, (struct sockaddr  const  * __restrict  )sa, salen);
#line 97
    if (error___0 == 0) {
#line 98
      break;
    }
#line 101
    if (error___0 < 0) {
#line 101
      tmp___2 = __errno_location();
#line 101
      if (! (*tmp___2 == 98)) {
#line 101
        tmp___3 = __errno_location();
#line 101
        if (! (*tmp___3 == 22)) {
#line 102
          break;
        }
      }
    }
#line 104
    port = (u_int16_t )((int )port + 1);
#line 105
    if ((int )port > 1023) {
#line 106
      port = (unsigned short)600;
    }
#line 91
    i ++;
  }
#line 109
  return (error___0);
}
}
#line 1 "daemon.o"
#line 1 "dirname.o"
#line 1 "getcwd.o"
#line 1 "getgrouplist.o"
#line 1 "getopt.o"
#line 144 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 327
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 122 "./openbsd-compat/openbsd-compat.h"
int BSDgetopt(int nargc , char * const  *nargv , char const   *ostr ) ;
#line 43 "openbsd-compat/getopt.c"
int BSDopterr  =    1;
#line 43 "openbsd-compat/getopt.c"
int BSDoptind  =    1;
#line 43 "openbsd-compat/getopt.c"
int BSDoptopt  ;
#line 43 "openbsd-compat/getopt.c"
int BSDoptreset  ;
#line 47 "openbsd-compat/getopt.c"
char *BSDoptarg  ;
#line 64 "openbsd-compat/getopt.c"
static char *place  =    (char *)"";
#line 57 "openbsd-compat/getopt.c"
int BSDgetopt(int nargc , char * const  *nargv , char const   *ostr ) 
{ char *oli ;
  char *tmp ;
  char *tmp___1 ;

  {
#line 67
  if ((unsigned int )ostr == (unsigned int )((void *)0)) {
#line 68
    return (-1);
  }
#line 70
  if (BSDoptreset) {
    goto _L;
  } else {
#line 70
    if (! *place) {
      _L: /* CIL Label */ 
#line 71
      BSDoptreset = 0;
#line 72
      if (BSDoptind >= nargc) {
#line 73
        place = (char *)"";
#line 74
        return (-1);
      } else {
#line 72
        place = (char *)*(nargv + BSDoptind);
#line 72
        if ((int )*place != 45) {
#line 73
          place = (char *)"";
#line 74
          return (-1);
        }
      }
#line 76
      if (*(place + 1)) {
#line 76
        place ++;
#line 76
        if ((int )*place == 45) {
#line 77
          BSDoptind ++;
#line 78
          place = (char *)"";
#line 79
          return (-1);
        }
      }
    }
  }
#line 82
  tmp = place;
#line 82
  place ++;
#line 82
  BSDoptopt = (int )*tmp;
#line 82
  if (BSDoptopt == 58) {
    goto _L___0;
  } else {
#line 82
    tmp___1 = __builtin_strchr((char *)ostr, BSDoptopt);
#line 82
    oli = tmp___1;
#line 82
    if (! oli) {
      _L___0: /* CIL Label */ 
#line 88
      if (BSDoptopt == 45) {
#line 89
        return (-1);
      }
#line 90
      if (! *place) {
#line 91
        BSDoptind ++;
      }
#line 92
      if (BSDopterr) {
#line 92
        if ((int const   )*ostr != 58) {
#line 93
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: illegal option -- %c\n",
                  __progname, BSDoptopt);
        }
      }
#line 95
      return ('?');
    }
  }
#line 97
  oli ++;
#line 97
  if ((int )*oli != 58) {
#line 98
    BSDoptarg = (char *)((void *)0);
#line 99
    if (! *place) {
#line 100
      BSDoptind ++;
    }
  } else {
#line 103
    if (*place) {
#line 104
      BSDoptarg = place;
    } else {
#line 105
      BSDoptind ++;
#line 105
      if (nargc <= BSDoptind) {
#line 106
        place = (char *)"";
#line 107
        if ((int const   )*ostr == 58) {
#line 108
          return (':');
        }
#line 109
        if (BSDopterr) {
#line 110
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: option requires an argument -- %c\n",
                  __progname, BSDoptopt);
        }
#line 113
        return ('?');
      } else {
#line 116
        BSDoptarg = (char *)*(nargv + BSDoptind);
      }
    }
#line 117
    place = (char *)"";
#line 118
    BSDoptind ++;
  }
#line 120
  return (BSDoptopt);
}
}
#line 1 "getrrsetbyname.o"
#line 589 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 591
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 603
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 38 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                  size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 242
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 1304 "/usr/include/bits/string2.h"
extern  __attribute__((__nothrow__)) char *__strdup(char const   *__string )  __attribute__((__malloc__)) ;
#line 61 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) int *__h_errno_location(void)  __attribute__((__const__)) ;
#line 237 "/usr/include/resolv.h"
extern struct __res_state *__res_state(void)  __attribute__((__const__)) ;
#line 261
extern  __attribute__((__nothrow__)) int __res_init(void) ;
#line 265
extern  __attribute__((__nothrow__)) int __res_query(char const   * , int  , int  ,
                                                     u_char * , int  ) ;
#line 345
extern  __attribute__((__nothrow__)) int __dn_expand(u_char const   * , u_char const   * ,
                                                     u_char const   * , char * , int  ) ;
#line 105 "./openbsd-compat/getrrsetbyname.h"
int getrrsetbyname(char const   *hostname , unsigned int rdclass , unsigned int rdtype ,
                   unsigned int flags , struct rrsetinfo **res ) ;
#line 106
void freerrset(struct rrsetinfo *rrset ) ;
#line 65 "./openbsd-compat/openbsd-compat.h"
size_t strlcpy(char *dst , char const   *src , size_t siz ) ;
#line 81 "openbsd-compat/getrrsetbyname.c"
static struct dns_response *parse_dns_response(u_char const   *answer , int size ) ;
#line 82
static struct dns_query *parse_dns_qsection(u_char const   *answer , int size , u_char const   **cp ,
                                            int count ) ;
#line 84
static struct dns_rr *parse_dns_rrsection(u_char const   *answer , int size , u_char const   **cp ,
                                          int count ) ;
#line 87
static void free_dns_query(struct dns_query *p ) ;
#line 88
static void free_dns_rr(struct dns_rr *p ) ;
#line 89
static void free_dns_response(struct dns_response *p ) ;
#line 91
static int count_dns_rr(struct dns_rr *p , u_int16_t class , u_int16_t type ) ;
#line 157 "openbsd-compat/getrrsetbyname.c"
int getrrsetbyname(char const   *hostname , unsigned int rdclass , unsigned int rdtype ,
                   unsigned int flags , struct rrsetinfo **res ) 
{ int result ;
  struct rrsetinfo *rrset ;
  struct dns_response *response ;
  struct dns_rr *rr ;
  struct rdatainfo *rdata ;
  int length ;
  unsigned int index_ans ;
  unsigned int index_sig ;
  u_char answer[65536] ;
  struct __res_state *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  void *tmp___11 ;

  {
#line 163
  rrset = (struct rrsetinfo *)((void *)0);
#line 172
  if (rdclass > 65535U) {
#line 173
    result = 3;
    goto fail;
  } else {
#line 172
    if (rdtype > 65535U) {
#line 173
      result = 3;
      goto fail;
    }
  }
#line 178
  if (rdclass == 255U) {
#line 179
    result = 3;
    goto fail;
  } else {
#line 178
    if (rdtype == 255U) {
#line 179
      result = 3;
      goto fail;
    }
  }
#line 184
  if (flags) {
#line 185
    result = 3;
    goto fail;
  }
#line 190
  tmp = __res_state();
#line 190
  if ((tmp->options & 1UL) == 0UL) {
#line 190
    tmp___0 = __res_init();
#line 190
    if (tmp___0 == -1) {
#line 191
      result = 2;
      goto fail;
    }
  }
#line 206
  length = __res_query(hostname, (int )rdclass, (int )rdtype, answer, (int )sizeof(answer));
#line 208
  if (length < 0) {
#line 209
    tmp___1 = __h_errno_location();
#line 209
    switch (*tmp___1) {
    case 1: 
#line 211
    result = 4;
    goto fail;
    case 4: 
#line 214
    result = 5;
    goto fail;
    default: 
#line 217
    result = 2;
    goto fail;
    }
  }
#line 223
  response = parse_dns_response((u_char const   *)(answer), length);
#line 224
  if ((unsigned int )response == (unsigned int )((void *)0)) {
#line 225
    result = 2;
    goto fail;
  }
#line 229
  if (response->header.qdcount != 1U) {
#line 230
    result = 2;
    goto fail;
  }
#line 235
  tmp___2 = calloc(1U, sizeof(struct rrsetinfo ));
#line 235
  rrset = (struct rrsetinfo *)tmp___2;
#line 236
  if ((unsigned int )rrset == (unsigned int )((void *)0)) {
#line 237
    result = 1;
    goto fail;
  }
#line 240
  rrset->rri_rdclass = (unsigned int )(response->query)->class;
#line 241
  rrset->rri_rdtype = (unsigned int )(response->query)->type;
#line 242
  rrset->rri_ttl = (unsigned int )(response->answer)->ttl;
#line 243
  rrset->rri_nrdatas = response->header.ancount;
#line 247
  if (response->header.ad == 1U) {
#line 248
    rrset->rri_flags |= 1U;
  }
#line 252
  tmp___3 = strlen((char const   *)(response->answer)->name);
#line 252
  length = (int )tmp___3;
#line 253
  tmp___4 = malloc((unsigned int )(length + 1));
#line 253
  rrset->rri_name = (char *)tmp___4;
#line 254
  if ((unsigned int )rrset->rri_name == (unsigned int )((void *)0)) {
#line 255
    result = 1;
    goto fail;
  }
#line 258
  strlcpy(rrset->rri_name, (char const   *)(response->answer)->name, (unsigned int )(length + 1));
#line 261
  tmp___5 = count_dns_rr(response->answer, (unsigned short )rrset->rri_rdclass, (unsigned short )rrset->rri_rdtype);
#line 261
  rrset->rri_nrdatas = (unsigned int )tmp___5;
#line 263
  tmp___6 = count_dns_rr(response->answer, (unsigned short )rrset->rri_rdclass, (unsigned short)24);
#line 263
  rrset->rri_nsigs = (unsigned int )tmp___6;
#line 267
  tmp___7 = calloc(rrset->rri_nrdatas, sizeof(struct rdatainfo ));
#line 267
  rrset->rri_rdatas = (struct rdatainfo *)tmp___7;
#line 269
  if ((unsigned int )rrset->rri_rdatas == (unsigned int )((void *)0)) {
#line 270
    result = 1;
    goto fail;
  }
#line 275
  tmp___8 = calloc(rrset->rri_nsigs, sizeof(struct rdatainfo ));
#line 275
  rrset->rri_sigs = (struct rdatainfo *)tmp___8;
#line 276
  if ((unsigned int )rrset->rri_sigs == (unsigned int )((void *)0)) {
#line 277
    result = 1;
    goto fail;
  }
#line 282
  rr = response->answer;
#line 282
  index_ans = 0U;
#line 282
  index_sig = 0U;
#line 282
  while (rr) {
#line 285
    rdata = (struct rdatainfo *)((void *)0);
#line 287
    if ((unsigned int )rr->class == rrset->rri_rdclass) {
#line 287
      if ((unsigned int )rr->type == rrset->rri_rdtype) {
#line 289
        tmp___9 = index_ans;
#line 289
        index_ans ++;
#line 289
        rdata = rrset->rri_rdatas + tmp___9;
      }
    }
#line 291
    if ((unsigned int )rr->class == rrset->rri_rdclass) {
#line 291
      if ((int )rr->type == 24) {
#line 293
        tmp___10 = index_sig;
#line 293
        index_sig ++;
#line 293
        rdata = rrset->rri_sigs + tmp___10;
      }
    }
#line 295
    if (rdata) {
#line 296
      rdata->rdi_length = (unsigned int )rr->size;
#line 297
      tmp___11 = malloc((unsigned int )rr->size);
#line 297
      rdata->rdi_data = (unsigned char *)tmp___11;
#line 299
      if ((unsigned int )rdata->rdi_data == (unsigned int )((void *)0)) {
#line 300
        result = 1;
        goto fail;
      }
#line 303
      memcpy((void * __restrict  )rdata->rdi_data, (void const   * __restrict  )rr->rdata,
             (unsigned int )rr->size);
    }
#line 282
    rr = rr->next;
  }
#line 307
  *res = rrset;
#line 308
  return (0);
  fail: 
#line 311
  if ((unsigned int )rrset != (unsigned int )((void *)0)) {
#line 312
    freerrset(rrset);
  }
#line 313
  return (result);
}
}
#line 316 "openbsd-compat/getrrsetbyname.c"
void freerrset(struct rrsetinfo *rrset ) 
{ u_int16_t i ;

  {
#line 321
  if ((unsigned int )rrset == (unsigned int )((void *)0)) {
#line 322
    return;
  }
#line 324
  if (rrset->rri_rdatas) {
#line 325
    i = (unsigned short)0;
#line 325
    while ((unsigned int )i < rrset->rri_nrdatas) {
#line 326
      if ((unsigned int )(rrset->rri_rdatas + i)->rdi_data == (unsigned int )((void *)0)) {
#line 327
        break;
      }
#line 328
      free((void *)(rrset->rri_rdatas + i)->rdi_data);
#line 325
      i = (u_int16_t )((int )i + 1);
    }
#line 330
    free((void *)rrset->rri_rdatas);
  }
#line 333
  if (rrset->rri_sigs) {
#line 334
    i = (unsigned short)0;
#line 334
    while ((unsigned int )i < rrset->rri_nsigs) {
#line 335
      if ((unsigned int )(rrset->rri_sigs + i)->rdi_data == (unsigned int )((void *)0)) {
#line 336
        break;
      }
#line 337
      free((void *)(rrset->rri_sigs + i)->rdi_data);
#line 334
      i = (u_int16_t )((int )i + 1);
    }
#line 339
    free((void *)rrset->rri_sigs);
  }
#line 342
  if (rrset->rri_name) {
#line 343
    free((void *)rrset->rri_name);
  }
#line 344
  free((void *)rrset);
#line 345
  return;
}
}
#line 350 "openbsd-compat/getrrsetbyname.c"
static struct dns_response *parse_dns_response(u_char const   *answer , int size ) 
{ struct dns_response *resp ;
  u_char const   *cp ;
  void *tmp ;
  register unsigned short __v ;
  register unsigned short __x ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  register unsigned short __v___1 ;
  register unsigned short __x___1 ;
  register unsigned short __v___2 ;
  register unsigned short __x___2 ;

  {
#line 357
  tmp = calloc(1U, sizeof(*resp));
#line 357
  resp = (struct dns_response *)tmp;
#line 358
  if ((unsigned int )resp == (unsigned int )((void *)0)) {
#line 359
    return ((struct dns_response *)((void *)0));
  }
#line 362
  cp = answer;
#line 365
  memcpy((void * __restrict  )(& resp->header), (void const   * __restrict  )cp, 12U);
#line 366
  cp += 12;
#line 369
  __x = (unsigned short )resp->header.qdcount;
#line 369
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 369
  resp->header.qdcount = (unsigned int )__v;
#line 370
  __x___0 = (unsigned short )resp->header.ancount;
#line 370
  __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 370
  resp->header.ancount = (unsigned int )__v___0;
#line 371
  __x___1 = (unsigned short )resp->header.nscount;
#line 371
  __asm__  ("rorw $8, %w0": "=r" (__v___1): "0" (__x___1): "cc");
#line 371
  resp->header.nscount = (unsigned int )__v___1;
#line 372
  __x___2 = (unsigned short )resp->header.arcount;
#line 372
  __asm__  ("rorw $8, %w0": "=r" (__v___2): "0" (__x___2): "cc");
#line 372
  resp->header.arcount = (unsigned int )__v___2;
#line 375
  if (resp->header.qdcount < 1U) {
#line 376
    free_dns_response(resp);
#line 377
    return ((struct dns_response *)((void *)0));
  }
#line 381
  resp->query = parse_dns_qsection(answer, size, & cp, (int )resp->header.qdcount);
#line 383
  if (resp->header.qdcount) {
#line 383
    if ((unsigned int )resp->query == (unsigned int )((void *)0)) {
#line 384
      free_dns_response(resp);
#line 385
      return ((struct dns_response *)((void *)0));
    }
  }
#line 389
  resp->answer = parse_dns_rrsection(answer, size, & cp, (int )resp->header.ancount);
#line 391
  if (resp->header.ancount) {
#line 391
    if ((unsigned int )resp->answer == (unsigned int )((void *)0)) {
#line 392
      free_dns_response(resp);
#line 393
      return ((struct dns_response *)((void *)0));
    }
  }
#line 397
  resp->authority = parse_dns_rrsection(answer, size, & cp, (int )resp->header.nscount);
#line 399
  if (resp->header.nscount) {
#line 399
    if ((unsigned int )resp->authority == (unsigned int )((void *)0)) {
#line 400
      free_dns_response(resp);
#line 401
      return ((struct dns_response *)((void *)0));
    }
  }
#line 405
  resp->additional = parse_dns_rrsection(answer, size, & cp, (int )resp->header.arcount);
#line 407
  if (resp->header.arcount) {
#line 407
    if ((unsigned int )resp->additional == (unsigned int )((void *)0)) {
#line 408
      free_dns_response(resp);
#line 409
      return ((struct dns_response *)((void *)0));
    }
  }
#line 412
  return (resp);
}
}
#line 450
extern int ( /* missing proto */  _getshort)() ;
#line 415 "openbsd-compat/getrrsetbyname.c"
static struct dns_query *parse_dns_qsection(u_char const   *answer , int size , u_char const   **cp ,
                                            int count ) 
{ struct dns_query *head ;
  struct dns_query *curr ;
  struct dns_query *prev ;
  int i ;
  int length ;
  char name[1025] ;
  void *tmp ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 422
  i = 1;
#line 422
  head = (struct dns_query *)((void *)0);
#line 422
  prev = (struct dns_query *)((void *)0);
#line 422
  while (i <= count) {
#line 425
    tmp = calloc(1U, sizeof(struct dns_query ));
#line 425
    curr = (struct dns_query *)tmp;
#line 426
    if ((unsigned int )curr == (unsigned int )((void *)0)) {
#line 427
      free_dns_query(head);
#line 428
      return ((struct dns_query *)((void *)0));
    }
#line 430
    if ((unsigned int )head == (unsigned int )((void *)0)) {
#line 431
      head = curr;
    }
#line 432
    if ((unsigned int )prev != (unsigned int )((void *)0)) {
#line 433
      prev->next = curr;
    }
#line 436
    length = __dn_expand(answer, answer + size, *cp, name, (int )sizeof(name));
#line 438
    if (length < 0) {
#line 439
      free_dns_query(head);
#line 440
      return ((struct dns_query *)((void *)0));
    }
#line 442
    tmp___9 = __strdup((char const   *)(name));
#line 442
    curr->name = tmp___9;
#line 443
    if ((unsigned int )curr->name == (unsigned int )((void *)0)) {
#line 444
      free_dns_query(head);
#line 445
      return ((struct dns_query *)((void *)0));
    }
#line 447
    *cp += length;
#line 450
    tmp___10 = _getshort(*cp);
#line 450
    curr->type = (unsigned short )tmp___10;
#line 451
    *cp += 2;
#line 454
    tmp___11 = _getshort(*cp);
#line 454
    curr->class = (unsigned short )tmp___11;
#line 455
    *cp += 2;
#line 422
    i ++;
#line 422
    prev = curr;
  }
#line 458
  return (head);
}
}
#line 504
extern int ( /* missing proto */  _getlong)() ;
#line 461 "openbsd-compat/getrrsetbyname.c"
static struct dns_rr *parse_dns_rrsection(u_char const   *answer , int size , u_char const   **cp ,
                                          int count ) 
{ struct dns_rr *head ;
  struct dns_rr *curr ;
  struct dns_rr *prev ;
  int i ;
  int length ;
  char name[1025] ;
  void *tmp ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 468
  i = 1;
#line 468
  head = (struct dns_rr *)((void *)0);
#line 468
  prev = (struct dns_rr *)((void *)0);
#line 468
  while (i <= count) {
#line 471
    tmp = calloc(1U, sizeof(struct dns_rr ));
#line 471
    curr = (struct dns_rr *)tmp;
#line 472
    if ((unsigned int )curr == (unsigned int )((void *)0)) {
#line 473
      free_dns_rr(head);
#line 474
      return ((struct dns_rr *)((void *)0));
    }
#line 476
    if ((unsigned int )head == (unsigned int )((void *)0)) {
#line 477
      head = curr;
    }
#line 478
    if ((unsigned int )prev != (unsigned int )((void *)0)) {
#line 479
      prev->next = curr;
    }
#line 482
    length = __dn_expand(answer, answer + size, *cp, name, (int )sizeof(name));
#line 484
    if (length < 0) {
#line 485
      free_dns_rr(head);
#line 486
      return ((struct dns_rr *)((void *)0));
    }
#line 488
    tmp___9 = __strdup((char const   *)(name));
#line 488
    curr->name = tmp___9;
#line 489
    if ((unsigned int )curr->name == (unsigned int )((void *)0)) {
#line 490
      free_dns_rr(head);
#line 491
      return ((struct dns_rr *)((void *)0));
    }
#line 493
    *cp += length;
#line 496
    tmp___10 = _getshort(*cp);
#line 496
    curr->type = (unsigned short )tmp___10;
#line 497
    *cp += 2;
#line 500
    tmp___11 = _getshort(*cp);
#line 500
    curr->class = (unsigned short )tmp___11;
#line 501
    *cp += 2;
#line 504
    tmp___12 = _getlong(*cp);
#line 504
    curr->ttl = (unsigned short )tmp___12;
#line 505
    *cp += 4;
#line 508
    tmp___13 = _getshort(*cp);
#line 508
    curr->size = (unsigned short )tmp___13;
#line 509
    *cp += 2;
#line 512
    curr->rdata = malloc((unsigned int )curr->size);
#line 513
    if ((unsigned int )curr->rdata == (unsigned int )((void *)0)) {
#line 514
      free_dns_rr(head);
#line 515
      return ((struct dns_rr *)((void *)0));
    }
#line 517
    memcpy((void * __restrict  )curr->rdata, (void const   * __restrict  )*cp, (unsigned int )curr->size);
#line 518
    *cp += (int )curr->size;
#line 468
    i ++;
#line 468
    prev = curr;
  }
#line 521
  return (head);
}
}
#line 524 "openbsd-compat/getrrsetbyname.c"
static void free_dns_query(struct dns_query *p ) 
{ 

  {
#line 527
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 528
    return;
  }
#line 530
  if (p->name) {
#line 531
    free((void *)p->name);
  }
#line 532
  free_dns_query(p->next);
#line 533
  free((void *)p);
#line 534
  return;
}
}
#line 536 "openbsd-compat/getrrsetbyname.c"
static void free_dns_rr(struct dns_rr *p ) 
{ 

  {
#line 539
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 540
    return;
  }
#line 542
  if (p->name) {
#line 543
    free((void *)p->name);
  }
#line 544
  if (p->rdata) {
#line 545
    free(p->rdata);
  }
#line 546
  free_dns_rr(p->next);
#line 547
  free((void *)p);
#line 548
  return;
}
}
#line 550 "openbsd-compat/getrrsetbyname.c"
static void free_dns_response(struct dns_response *p ) 
{ 

  {
#line 553
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 554
    return;
  }
#line 556
  free_dns_query(p->query);
#line 557
  free_dns_rr(p->answer);
#line 558
  free_dns_rr(p->authority);
#line 559
  free_dns_rr(p->additional);
#line 560
  free((void *)p);
#line 561
  return;
}
}
#line 563 "openbsd-compat/getrrsetbyname.c"
static int count_dns_rr(struct dns_rr *p , u_int16_t class , u_int16_t type ) 
{ int n___0 ;

  {
#line 566
  n___0 = 0;
#line 568
  while (p) {
#line 569
    if ((int )p->class == (int )class) {
#line 569
      if ((int )p->type == (int )type) {
#line 570
        n___0 ++;
      }
    }
#line 571
    p = p->next;
  }
#line 574
  return (n___0);
}
}
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
#line 1 "glob.o"
#line 600 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__warn_unused_result__,
__malloc__)) ;
#line 660
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 780
extern void qsort(void *__base , size_t __nmemb , size_t __size , int (*__compar)(void const   * ,
                                                                                  void const   * ) )  __attribute__((__nonnull__(1,4))) ;
#line 111 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 117
extern struct passwd *getpwnam(char const   *__name ) ;
#line 135 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 150
extern int closedir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 166
extern struct dirent *readdir(DIR *__dirp )  __asm__("readdir64") __attribute__((__nonnull__(1))) ;
#line 642 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 645
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 263
__inline static  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path ,
                                                        struct stat * __restrict  __statbuf )  __asm__("lstat64") __attribute__((__nonnull__(1,2))) ;
#line 394
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __asm__("__xstat64") __attribute__((__nonnull__(2,3))) ;
#line 397
extern  __attribute__((__nothrow__)) int __lxstat(int __ver , char const   *__filename ,
                                                  struct stat *__stat_buf )  __asm__("__lxstat64") __attribute__((__nonnull__(2,3))) ;
#line 433
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 433 "/usr/include/sys/stat.h"
__inline static int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
#line 436
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
#line 436
  return (tmp);
}
}
#line 440
__inline static  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path ,
                                                        struct stat * __restrict  __statbuf )  __asm__("lstat64") __attribute__((__nonnull__(1,2))) ;
#line 440 "/usr/include/sys/stat.h"
__inline static int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
#line 443
  tmp = __lxstat(3, (char const   *)__path, (struct stat *)__statbuf);
#line 443
  return (tmp);
}
}
#line 92 "./openbsd-compat/glob.h"
int glob(char const   *pattern , int flags , int (*errfunc)(char const   * , int  ) ,
         glob_t *pglob ) ;
#line 93
void globfree(glob_t *pglob ) ;
#line 38 "openbsd-compat/glob.c"
static long get_arg_max(void) 
{ 

  {
#line 42
  return (131072L);
}
}
#line 138
static int compare(void const   *p , void const   *q ) ;
#line 139
static int g_Ctoc(Char const   *str , char *buf___1 , u_int len ) ;
#line 140
static int g_lstat(Char *fn , struct stat *sb , glob_t *pglob ) ;
#line 141
static DIR *g_opendir(Char *str , glob_t *pglob ) ;
#line 142
static Char *g_strchr(Char *str , int ch ) ;
#line 143
static int g_stat(Char *fn , struct stat *sb , glob_t *pglob ) ;
#line 144
static int glob0(Char const   *pattern , glob_t *pglob ) ;
#line 145
static int glob1(Char *pattern , Char *pattern_last , glob_t *pglob , size_t *limitp ) ;
#line 146
static int glob2(Char *pathbuf , Char *pathbuf_last , Char *pathend , Char *pathend_last ,
                 Char *pattern , Char *pattern_last , glob_t *pglob , size_t *limitp ) ;
#line 148
static int glob3(Char *pathbuf , Char *pathbuf_last , Char *pathend , Char *pathend_last ,
                 Char *pattern , Char *pattern_last , Char *restpattern , Char *restpattern_last ,
                 glob_t *pglob , size_t *limitp ) ;
#line 150
static int globextend(Char const   *path , glob_t *pglob , size_t *limitp ) ;
#line 151
static Char const   *globtilde(Char const   *pattern , Char *patbuf , size_t patbuf_len ,
                               glob_t *pglob ) ;
#line 153
static int globexp1(Char const   *pattern , glob_t *pglob ) ;
#line 154
static int globexp2(Char const   *ptr , Char const   *pattern , glob_t *pglob , int *rv ) ;
#line 155
static int match(Char *name , Char *pat , Char *patend ) ;
#line 160 "openbsd-compat/glob.c"
int glob(char const   *pattern , int flags , int (*errfunc)(char const   * , int  ) ,
         glob_t *pglob ) 
{ u_char const   *patnext ;
  int c ;
  Char *bufnext ;
  Char *bufend ;
  Char patbuf[4096] ;
  Char *tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  Char *tmp___2 ;
  Char *tmp___3 ;
  u_char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 170
  patnext = (u_char const   *)((u_char *)pattern);
#line 171
  if (! (flags & 1)) {
#line 172
    pglob->gl_pathc = 0;
#line 173
    pglob->gl_pathv = (char **)((void *)0);
#line 174
    if (! (flags & 2)) {
#line 175
      pglob->gl_offs = 0;
    }
  }
#line 177
  pglob->gl_flags = flags & -257;
#line 178
  pglob->gl_errfunc = errfunc;
#line 179
  pglob->gl_matchc = 0;
#line 181
  bufnext = patbuf;
#line 182
  bufend = (bufnext + 4096) - 1;
#line 183
  if (flags & 4096) {
#line 184
    while (1) {
#line 184
      if ((unsigned int )bufnext < (unsigned int )bufend) {
#line 184
        tmp___0 = patnext;
#line 184
        patnext ++;
#line 184
        c = (int )*tmp___0;
#line 184
        if (! (c != 0)) {
#line 184
          break;
        }
      } else {
#line 184
        break;
      }
#line 185
      tmp = bufnext;
#line 185
      bufnext ++;
#line 185
      *tmp = (unsigned short )c;
    }
  } else {
#line 188
    while (1) {
#line 188
      if ((unsigned int )bufnext < (unsigned int )bufend) {
#line 188
        tmp___4 = patnext;
#line 188
        patnext ++;
#line 188
        c = (int )*tmp___4;
#line 188
        if (! (c != 0)) {
#line 188
          break;
        }
      } else {
#line 188
        break;
      }
#line 189
      if (c == 92) {
#line 190
        tmp___1 = patnext;
#line 190
        patnext ++;
#line 190
        c = (int )*tmp___1;
#line 190
        if (c == 0) {
#line 191
          c = '\\';
#line 192
          patnext --;
        }
#line 194
        tmp___2 = bufnext;
#line 194
        bufnext ++;
#line 194
        *tmp___2 = (unsigned short )(c | 16384);
      } else {
#line 196
        tmp___3 = bufnext;
#line 196
        bufnext ++;
#line 196
        *tmp___3 = (unsigned short )c;
      }
    }
  }
#line 198
  *bufnext = (unsigned short )'\000';
#line 200
  if (flags & 128) {
#line 201
    tmp___5 = globexp1((Char const   *)(patbuf), pglob);
#line 201
    return (tmp___5);
  } else {
#line 203
    tmp___6 = glob0((Char const   *)(patbuf), pglob);
#line 203
    return (tmp___6);
  }
}
}
#line 211 "openbsd-compat/glob.c"
static int globexp1(Char const   *pattern , glob_t *pglob ) 
{ Char const   *ptr ;
  int rv ;
  int tmp ;
  int tmp___0 ;
  Char *tmp___1 ;
  int tmp___2 ;

  {
#line 216
  ptr = pattern;
#line 220
  if ((int const   )*(pattern + 0) == 123) {
#line 220
    if ((int const   )*(pattern + 1) == 125) {
#line 220
      if ((int const   )*(pattern + 2) == 0) {
#line 221
        tmp = glob0(pattern, pglob);
#line 221
        return (tmp);
      }
    }
  }
#line 223
  while (1) {
#line 223
    tmp___1 = g_strchr((Char *)ptr, '{');
#line 223
    ptr = (Char const   *)tmp___1;
#line 223
    if (! ((unsigned int )ptr != (unsigned int )((void *)0))) {
#line 223
      break;
    }
#line 224
    tmp___0 = globexp2(ptr, pattern, pglob, & rv);
#line 224
    if (! tmp___0) {
#line 225
      return (rv);
    }
  }
#line 227
  tmp___2 = glob0(pattern, pglob);
#line 227
  return (tmp___2);
}
}
#line 236 "openbsd-compat/glob.c"
static int globexp2(Char const   *ptr , Char const   *pattern , glob_t *pglob , int *rv ) 
{ int i ;
  Char *lm ;
  Char *ls ;
  Char const   *pe ;
  Char const   *pm ;
  Char const   *pl ;
  Char patbuf[4096] ;
  Char *tmp ;
  Char const   *tmp___0 ;
  Char const   *tmp___1 ;
  Char const   *tmp___2 ;
  Char *tmp___3 ;
  Char const   *tmp___4 ;
  Char *tmp___5 ;
  Char const   *tmp___6 ;

  {
#line 248
  lm = patbuf;
#line 248
  pm = pattern;
#line 248
  while ((unsigned int )pm != (unsigned int )ptr) {
#line 248
    tmp = lm;
#line 248
    lm ++;
#line 248
    tmp___0 = pm;
#line 248
    pm ++;
#line 248
    *tmp = (unsigned short )*tmp___0;
  }
#line 250
  *lm = (unsigned short )'\000';
#line 251
  ls = lm;
#line 254
  i = 0;
#line 254
  ptr ++;
#line 254
  pe = ptr;
#line 254
  while (*pe) {
#line 255
    if ((int const   )*pe == 91) {
#line 257
      tmp___1 = pe;
#line 257
      pe ++;
#line 257
      pm = tmp___1;
#line 257
      while (1) {
#line 257
        if ((int const   )*pe != 93) {
#line 257
          if (! ((int const   )*pe != 0)) {
#line 257
            break;
          }
        } else {
#line 257
          break;
        }
#line 257
        pe ++;
      }
#line 259
      if ((int const   )*pe == 0) {
#line 264
        pe = pm;
      }
    } else {
#line 266
      if ((int const   )*pe == 123) {
#line 267
        i ++;
      } else {
#line 268
        if ((int const   )*pe == 125) {
#line 269
          if (i == 0) {
#line 270
            break;
          }
#line 271
          i --;
        }
      }
    }
#line 254
    pe ++;
  }
#line 275
  if (i != 0) {
#line 276
    *rv = glob0((Char const   *)(patbuf), pglob);
#line 277
    return (0);
  } else {
#line 275
    if ((int const   )*pe == 0) {
#line 276
      *rv = glob0((Char const   *)(patbuf), pglob);
#line 277
      return (0);
    }
  }
#line 280
  i = 0;
#line 280
  pm = ptr;
#line 280
  pl = pm;
#line 280
  while ((unsigned int )pm <= (unsigned int )pe) {
#line 281
    switch ((int )*pm) {
    case 91: 
#line 284
    tmp___2 = pm;
#line 284
    pm ++;
#line 284
    pl = tmp___2;
#line 284
    while (1) {
#line 284
      if ((int const   )*pm != 93) {
#line 284
        if (! ((int const   )*pm != 0)) {
#line 284
          break;
        }
      } else {
#line 284
        break;
      }
#line 284
      pm ++;
    }
#line 286
    if ((int const   )*pm == 0) {
#line 291
      pm = pl;
    }
#line 293
    break;
    case 123: 
#line 296
    i ++;
#line 297
    break;
    case 125: 
#line 300
    if (i) {
#line 301
      i --;
#line 302
      break;
    }
    case 44: 
#line 306
    if (i) {
#line 306
      if ((int const   )*pm == 44) {
#line 307
        break;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 310
      lm = ls;
#line 310
      while ((unsigned int )pl < (unsigned int )pm) {
#line 310
        tmp___3 = lm;
#line 310
        lm ++;
#line 310
        tmp___4 = pl;
#line 310
        pl ++;
#line 310
        *tmp___3 = (unsigned short )*tmp___4;
      }
#line 317
      pl = pe + 1;
#line 317
      while (1) {
#line 317
        tmp___5 = lm;
#line 317
        lm ++;
#line 317
        tmp___6 = pl;
#line 317
        pl ++;
#line 317
        *tmp___5 = (unsigned short )*tmp___6;
#line 317
        if (! ((int )*tmp___5 != 0)) {
#line 317
          break;
        }
      }
#line 324
      *rv = globexp1((Char const   *)(patbuf), pglob);
#line 327
      pl = pm + 1;
    }
#line 329
    break;
    default: ;
#line 332
    break;
    }
#line 280
    pm ++;
  }
#line 335
  *rv = 0;
#line 336
  return (0);
}
}
#line 344 "openbsd-compat/glob.c"
static Char const   *globtilde(Char const   *pattern , Char *patbuf , size_t patbuf_len ,
                               glob_t *pglob ) 
{ struct passwd *pwd ;
  char *h___0 ;
  Char const   *p ;
  Char *b ;
  Char *eb ;
  char *tmp ;
  Char const   *tmp___0 ;
  __uid_t tmp___1 ;
  __uid_t tmp___2 ;
  __uid_t tmp___3 ;
  Char *tmp___4 ;
  char *tmp___5 ;
  Char *tmp___6 ;
  Char const   *tmp___7 ;

  {
#line 356
  if ((int const   )*pattern != 126) {
#line 357
    return (pattern);
  } else {
#line 356
    if (! (pglob->gl_flags & 2048)) {
#line 357
      return (pattern);
    }
  }
#line 360
  eb = patbuf + (patbuf_len - 1U);
#line 361
  p = pattern + 1;
#line 361
  h___0 = (char *)patbuf;
#line 361
  while (1) {
#line 361
    if ((unsigned int )h___0 < (unsigned int )((char *)eb)) {
#line 361
      if (*p) {
#line 361
        if (! ((int const   )*p != 47)) {
#line 361
          break;
        }
      } else {
#line 361
        break;
      }
    } else {
#line 361
      break;
    }
#line 361
    tmp = h___0;
#line 361
    h___0 ++;
#line 361
    tmp___0 = p;
#line 361
    p ++;
#line 361
    *tmp = (char )*tmp___0;
  }
#line 365
  *h___0 = (char )'\000';
#line 372
  if ((int )*((char *)patbuf + 0) == 0) {
#line 380
    tmp___2 = getuid();
#line 380
    tmp___3 = geteuid();
#line 380
    if (tmp___2 != tmp___3) {
      goto _L;
    } else {
#line 380
      h___0 = getenv("HOME");
#line 380
      if ((unsigned int )h___0 == (unsigned int )((void *)0)) {
        _L: /* CIL Label */ 
#line 381
        tmp___1 = getuid();
#line 381
        pwd = getpwuid(tmp___1);
#line 381
        if ((unsigned int )pwd == (unsigned int )((void *)0)) {
#line 382
          return (pattern);
        } else {
#line 384
          h___0 = pwd->pw_dir;
        }
      }
    }
  } else {
#line 390
    pwd = getpwnam((char const   *)((char *)patbuf));
#line 390
    if ((unsigned int )pwd == (unsigned int )((void *)0)) {
#line 391
      return (pattern);
    } else {
#line 393
      h___0 = pwd->pw_dir;
    }
  }
#line 397
  b = patbuf;
#line 397
  while (1) {
#line 397
    if ((unsigned int )b < (unsigned int )eb) {
#line 397
      if (! *h___0) {
#line 397
        break;
      }
    } else {
#line 397
      break;
    }
#line 397
    tmp___4 = b;
#line 397
    b ++;
#line 397
    tmp___5 = h___0;
#line 397
    h___0 ++;
#line 397
    *tmp___4 = (unsigned short )*tmp___5;
  }
#line 401
  while (1) {
#line 401
    if ((unsigned int )b < (unsigned int )eb) {
#line 401
      tmp___6 = b;
#line 401
      b ++;
#line 401
      tmp___7 = p;
#line 401
      p ++;
#line 401
      *tmp___6 = (unsigned short )*tmp___7;
#line 401
      if (! ((int )*tmp___6 != 0)) {
#line 401
        break;
      }
    } else {
#line 401
      break;
    }
  }
#line 403
  *b = (unsigned short )'\000';
#line 405
  return ((Char const   *)patbuf);
}
}
#line 416 "openbsd-compat/glob.c"
static int glob0(Char const   *pattern , glob_t *pglob ) 
{ Char const   *qpatnext ;
  int c ;
  int err ;
  int oldpathc ;
  Char *bufnext ;
  Char patbuf[4096] ;
  size_t limit ;
  Char *tmp ;
  Char *tmp___0 ;
  Char *tmp___1 ;
  Char *tmp___2 ;
  Char const   *tmp___3 ;
  Char *tmp___4 ;
  Char *tmp___5 ;
  Char *tmp___6 ;
  Char const   *tmp___7 ;
  Char *tmp___8 ;
  Char *tmp___9 ;
  Char *tmp___10 ;
  Char *tmp___11 ;
  Char const   *tmp___12 ;
  int tmp___13 ;

  {
#line 424
  limit = (size_t )0;
#line 426
  qpatnext = globtilde(pattern, patbuf, 4096U, pglob);
#line 427
  oldpathc = pglob->gl_pathc;
#line 428
  bufnext = patbuf;
#line 431
  while (1) {
#line 431
    tmp___12 = qpatnext;
#line 431
    qpatnext ++;
#line 431
    c = (int )*tmp___12;
#line 431
    if (! (c != 0)) {
#line 431
      break;
    }
#line 432
    switch (c) {
    case 91: 
#line 434
    c = (int )*qpatnext;
#line 435
    if (c == 33) {
#line 436
      qpatnext ++;
    }
#line 437
    if ((int const   )*qpatnext == 0) {
      goto _L;
    } else {
#line 437
      tmp___0 = g_strchr((Char *)qpatnext + 1, ']');
#line 437
      if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
        _L: /* CIL Label */ 
#line 439
        tmp = bufnext;
#line 439
        bufnext ++;
#line 439
        *tmp = (unsigned short )'[';
#line 440
        if (c == 33) {
#line 441
          qpatnext --;
        }
#line 442
        break;
      }
    }
#line 444
    tmp___1 = bufnext;
#line 444
    bufnext ++;
#line 444
    *tmp___1 = (unsigned short)32859;
#line 445
    if (c == 33) {
#line 446
      tmp___2 = bufnext;
#line 446
      bufnext ++;
#line 446
      *tmp___2 = (unsigned short)32801;
    }
#line 447
    tmp___3 = qpatnext;
#line 447
    qpatnext ++;
#line 447
    c = (int )*tmp___3;
#line 448
    while (1) {
#line 449
      tmp___4 = bufnext;
#line 449
      bufnext ++;
#line 449
      *tmp___4 = (unsigned short )(c & 255);
#line 450
      if ((int const   )*qpatnext == 45) {
#line 450
        c = (int )*(qpatnext + 1);
#line 450
        if (c != 93) {
#line 452
          tmp___5 = bufnext;
#line 452
          bufnext ++;
#line 452
          *tmp___5 = (unsigned short)32813;
#line 453
          tmp___6 = bufnext;
#line 453
          bufnext ++;
#line 453
          *tmp___6 = (unsigned short )(c & 255);
#line 454
          qpatnext += 2;
        }
      }
#line 448
      tmp___7 = qpatnext;
#line 448
      qpatnext ++;
#line 448
      c = (int )*tmp___7;
#line 448
      if (! (c != 93)) {
#line 448
        break;
      }
    }
#line 457
    pglob->gl_flags |= 256;
#line 458
    tmp___8 = bufnext;
#line 458
    bufnext ++;
#line 458
    *tmp___8 = (unsigned short)32861;
#line 459
    break;
    case 63: 
#line 461
    pglob->gl_flags |= 256;
#line 462
    tmp___9 = bufnext;
#line 462
    bufnext ++;
#line 462
    *tmp___9 = (unsigned short)32831;
#line 463
    break;
    case 42: 
#line 465
    pglob->gl_flags |= 256;
#line 469
    if ((unsigned int )bufnext == (unsigned int )(patbuf)) {
#line 470
      tmp___10 = bufnext;
#line 470
      bufnext ++;
#line 470
      *tmp___10 = (unsigned short)32810;
    } else {
#line 469
      if ((int )*(bufnext + -1) != 32810) {
#line 470
        tmp___10 = bufnext;
#line 470
        bufnext ++;
#line 470
        *tmp___10 = (unsigned short)32810;
      }
    }
#line 471
    break;
    default: 
#line 473
    tmp___11 = bufnext;
#line 473
    bufnext ++;
#line 473
    *tmp___11 = (unsigned short )(c & 255);
#line 474
    break;
    }
  }
#line 477
  *bufnext = (unsigned short )'\000';
#line 482
  err = glob1(patbuf, (patbuf + 4096) - 1, pglob, & limit);
#line 482
  if (err != 0) {
#line 483
    return (err);
  }
#line 491
  if (pglob->gl_pathc == oldpathc) {
#line 492
    if (pglob->gl_flags & 16) {
#line 495
      tmp___13 = globextend(pattern, pglob, & limit);
#line 495
      return (tmp___13);
    } else {
#line 492
      if (pglob->gl_flags & 512) {
#line 492
        if (! (pglob->gl_flags & 256)) {
#line 495
          tmp___13 = globextend(pattern, pglob, & limit);
#line 495
          return (tmp___13);
        } else {
#line 497
          return (-3);
        }
      } else {
#line 497
        return (-3);
      }
    }
  }
#line 499
  if (! (pglob->gl_flags & 32)) {
#line 500
    qsort((void *)((pglob->gl_pathv + pglob->gl_offs) + oldpathc), (unsigned int )(pglob->gl_pathc - oldpathc),
          sizeof(char *), & compare);
  }
#line 502
  return (0);
}
}
#line 505 "openbsd-compat/glob.c"
static int compare(void const   *p , void const   *q ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 509
  if (0) {
#line 509
    __s1_len = strlen((char const   *)*((char **)p));
#line 509
    __s2_len = strlen((char const   *)*((char **)q));
#line 509
    if (! ((unsigned int )((void const   *)(*((char **)p) + 1)) - (unsigned int )((void const   *)*((char **)p)) == 1U)) {
      goto _L___0;
    } else {
#line 509
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 509
        if (! ((unsigned int )((void const   *)(*((char **)q) + 1)) - (unsigned int )((void const   *)*((char **)q)) == 1U)) {
#line 509
          tmp___8 = 1;
        } else {
#line 509
          if (__s2_len >= 4U) {
#line 509
            tmp___8 = 1;
          } else {
#line 509
            tmp___8 = 0;
          }
        }
      } else {
#line 509
        tmp___8 = 0;
      }
    }
#line 509
    if (tmp___8) {
#line 509
      tmp___4 = __builtin_strcmp((char const   *)*((char **)p), (char const   *)*((char **)q));
    } else {
#line 509
      tmp___7 = __builtin_strcmp((char const   *)*((char **)p), (char const   *)*((char **)q));
#line 509
      tmp___4 = tmp___7;
    }
  } else {
#line 509
    tmp___7 = __builtin_strcmp((char const   *)*((char **)p), (char const   *)*((char **)q));
#line 509
    tmp___4 = tmp___7;
  }
#line 509
  return (tmp___4);
}
}
#line 512 "openbsd-compat/glob.c"
static int glob1(Char *pattern , Char *pattern_last , glob_t *pglob , size_t *limitp ) 
{ Char pathbuf[4096] ;
  int tmp ;

  {
#line 521
  if ((int )*pattern == 0) {
#line 522
    return (0);
  }
#line 523
  tmp = glob2(pathbuf, (pathbuf + 4096) - 1, pathbuf, (pathbuf + 4096) - 1, pattern,
              pattern_last, pglob, limitp);
#line 523
  return (tmp);
}
}
#line 533 "openbsd-compat/glob.c"
static int glob2(Char *pathbuf , Char *pathbuf_last , Char *pathend , Char *pathend_last ,
                 Char *pattern , Char *pattern_last , glob_t *pglob , size_t *limitp ) 
{ struct stat sb ;
  Char *p ;
  Char *q ;
  int anymeta ;
  int tmp ;
  Char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  Char *tmp___3 ;
  Char *tmp___4 ;
  Char *tmp___5 ;
  Char *tmp___6 ;
  int tmp___7 ;

  {
#line 549
  anymeta = 0;
#line 549
  while (1) {
#line 550
    if ((int )*pattern == 0) {
#line 551
      *pathend = (unsigned short )'\000';
#line 552
      tmp = g_lstat(pathbuf, & sb, pglob);
#line 552
      if (tmp) {
#line 553
        return (0);
      }
#line 555
      if (pglob->gl_flags & 8) {
#line 555
        if ((int )*(pathend + -1) != 47) {
#line 555
          if ((sb.st_mode & 61440U) == 16384U) {
            goto _L;
          } else {
#line 555
            if ((sb.st_mode & 61440U) == 40960U) {
#line 555
              tmp___1 = g_stat(pathbuf, & sb, pglob);
#line 555
              if (tmp___1 == 0) {
#line 555
                if ((sb.st_mode & 61440U) == 16384U) {
                  _L: /* CIL Label */ 
#line 560
                  if ((unsigned int )(pathend + 1) > (unsigned int )pathend_last) {
#line 561
                    return (1);
                  }
#line 562
                  tmp___0 = pathend;
#line 562
                  pathend ++;
#line 562
                  *tmp___0 = (unsigned short )'/';
#line 563
                  *pathend = (unsigned short )'\000';
                }
              }
            }
          }
        }
      }
#line 565
      (pglob->gl_matchc) ++;
#line 566
      tmp___2 = globextend((Char const   *)pathbuf, pglob, limitp);
#line 566
      return (tmp___2);
    }
#line 570
    q = pathend;
#line 571
    p = pattern;
#line 572
    while (1) {
#line 572
      if ((int )*p != 0) {
#line 572
        if (! ((int )*p != 47)) {
#line 572
          break;
        }
      } else {
#line 572
        break;
      }
#line 573
      if (((int )*p & 32768) != 0) {
#line 574
        anymeta = 1;
      }
#line 575
      if ((unsigned int )(q + 1) > (unsigned int )pathend_last) {
#line 576
        return (1);
      }
#line 577
      tmp___3 = q;
#line 577
      q ++;
#line 577
      tmp___4 = p;
#line 577
      p ++;
#line 577
      *tmp___3 = *tmp___4;
    }
#line 580
    if (! anymeta) {
#line 581
      pathend = q;
#line 582
      pattern = p;
#line 583
      while ((int )*pattern == 47) {
#line 584
        if ((unsigned int )(pathend + 1) > (unsigned int )pathend_last) {
#line 585
          return (1);
        }
#line 586
        tmp___5 = pathend;
#line 586
        pathend ++;
#line 586
        tmp___6 = pattern;
#line 586
        pattern ++;
#line 586
        *tmp___5 = *tmp___6;
      }
    } else {
#line 590
      tmp___7 = glob3(pathbuf, pathbuf_last, pathend, pathend_last, pattern, pattern_last,
                      p, pattern_last, pglob, limitp);
#line 590
      return (tmp___7);
    }
  }
}
}
#line 597 "openbsd-compat/glob.c"
static int glob3(Char *pathbuf , Char *pathbuf_last , Char *pathend , Char *pathend_last ,
                 Char *pattern , Char *pattern_last , Char *restpattern , Char *restpattern_last ,
                 glob_t *pglob , size_t *limitp ) 
{ register struct dirent *dp ;
  DIR *dirp ;
  int err ;
  char buf___1[4096] ;
  struct dirent *(*readdirfunc)(void * ) ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  register u_char *sc ;
  register Char *dc ;
  Char *tmp___3 ;
  u_char *tmp___4 ;
  int tmp___5 ;

  {
#line 618
  if ((unsigned int )pathend > (unsigned int )pathend_last) {
#line 619
    return (1);
  }
#line 620
  *pathend = (unsigned short )'\000';
#line 621
  tmp = __errno_location();
#line 621
  *tmp = 0;
#line 623
  dirp = g_opendir(pathbuf, pglob);
#line 623
  if ((unsigned int )dirp == (unsigned int )((void *)0)) {
#line 625
    if (pglob->gl_errfunc) {
#line 626
      tmp___0 = g_Ctoc((Char const   *)pathbuf, buf___1, sizeof(buf___1));
#line 626
      if (tmp___0) {
#line 627
        return (-2);
      }
#line 628
      tmp___1 = __errno_location();
#line 628
      tmp___2 = (*(pglob->gl_errfunc))((char const   *)(buf___1), *tmp___1);
#line 628
      if (tmp___2) {
#line 630
        return (-2);
      } else {
#line 628
        if (pglob->gl_flags & 4) {
#line 630
          return (-2);
        }
      }
    }
#line 632
    return (0);
  }
#line 635
  err = 0;
#line 638
  if (pglob->gl_flags & 64) {
#line 639
    readdirfunc = pglob->gl_readdir;
  } else {
#line 641
    readdirfunc = (struct dirent *(*)(void * ))(& readdir);
  }
#line 642
  while (1) {
#line 642
    dp = (*readdirfunc)((void *)dirp);
#line 642
    if (! dp) {
#line 642
      break;
    }
#line 647
    if ((int )dp->d_name[0] == 46) {
#line 647
      if ((int )*pattern != 46) {
#line 648
        continue;
      }
    }
#line 649
    dc = pathend;
#line 650
    sc = (u_char *)(dp->d_name);
#line 651
    while (1) {
#line 651
      if ((unsigned int )dc < (unsigned int )pathend_last) {
#line 651
        tmp___3 = dc;
#line 651
        dc ++;
#line 651
        tmp___4 = sc;
#line 651
        sc ++;
#line 651
        *tmp___3 = (unsigned short )*tmp___4;
#line 651
        if (! ((int )*tmp___3 != 0)) {
#line 651
          break;
        }
      } else {
#line 651
        break;
      }
    }
#line 653
    if ((unsigned int )dc >= (unsigned int )pathend_last) {
#line 654
      *dc = (unsigned short )'\000';
#line 655
      err = 1;
#line 656
      break;
    }
#line 659
    tmp___5 = match(pathend, pattern, restpattern);
#line 659
    if (! tmp___5) {
#line 660
      *pathend = (unsigned short )'\000';
#line 661
      continue;
    }
#line 663
    dc --;
#line 663
    err = glob2(pathbuf, pathbuf_last, dc, pathend_last, restpattern, restpattern_last,
                pglob, limitp);
#line 665
    if (err) {
#line 666
      break;
    }
  }
#line 669
  if (pglob->gl_flags & 64) {
#line 670
    (*(pglob->gl_closedir))((void *)dirp);
  } else {
#line 672
    closedir(dirp);
  }
#line 673
  return (err);
}
}
#line 691 "openbsd-compat/glob.c"
static int globextend(Char const   *path , glob_t *pglob , size_t *limitp ) 
{ register char **pathv ;
  register int i ;
  u_int newsize ;
  u_int len ;
  char *copy ;
  Char const   *p ;
  void *tmp___1 ;
  void *tmp___2 ;
  Char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;

  {
#line 703
  newsize = sizeof(*pathv) * (unsigned int )((2 + pglob->gl_pathc) + pglob->gl_offs);
#line 704
  if (pglob->gl_pathv) {
#line 704
    tmp___1 = realloc((void *)((char *)pglob->gl_pathv), newsize);
#line 704
    pathv = (char **)tmp___1;
  } else {
#line 704
    tmp___2 = malloc(newsize);
#line 704
    pathv = (char **)tmp___2;
  }
#line 706
  if ((unsigned int )pathv == (unsigned int )((void *)0)) {
#line 707
    if (pglob->gl_pathv) {
#line 708
      free((void *)pglob->gl_pathv);
#line 709
      pglob->gl_pathv = (char **)((void *)0);
    }
#line 711
    return (-1);
  }
#line 714
  if ((unsigned int )pglob->gl_pathv == (unsigned int )((void *)0)) {
#line 714
    if (pglob->gl_offs > 0) {
#line 716
      pathv += pglob->gl_offs;
#line 717
      i = pglob->gl_offs;
#line 717
      while (1) {
#line 717
        i --;
#line 717
        if (! (i >= 0)) {
#line 717
          break;
        }
#line 718
        pathv --;
#line 718
        *pathv = (char *)((void *)0);
      }
    }
  }
#line 720
  pglob->gl_pathv = pathv;
#line 722
  p = path;
#line 722
  while (1) {
#line 722
    tmp___3 = p;
#line 722
    p ++;
#line 722
    if (! *tmp___3) {
#line 722
      break;
    }
  }
#line 724
  len = (unsigned int )(p - path);
#line 725
  *limitp += len;
#line 726
  tmp___6 = malloc(len);
#line 726
  copy = (char *)tmp___6;
#line 726
  if ((unsigned int )copy != (unsigned int )((void *)0)) {
#line 727
    tmp___4 = g_Ctoc(path, copy, len);
#line 727
    if (tmp___4) {
#line 728
      free((void *)copy);
#line 729
      return (-1);
    }
#line 731
    tmp___5 = pglob->gl_pathc;
#line 731
    (pglob->gl_pathc) ++;
#line 731
    *(pathv + (pglob->gl_offs + tmp___5)) = copy;
  }
#line 733
  *(pathv + (pglob->gl_offs + pglob->gl_pathc)) = (char *)((void *)0);
#line 735
  if (pglob->gl_flags & 8192) {
#line 735
    tmp___8 = get_arg_max();
#line 735
    if (newsize + *limitp >= (unsigned int )tmp___8) {
#line 737
      tmp___7 = __errno_location();
#line 737
      *tmp___7 = 0;
#line 738
      return (-1);
    }
  }
#line 741
  if ((unsigned int )copy == (unsigned int )((void *)0)) {
#line 741
    tmp___9 = -1;
  } else {
#line 741
    tmp___9 = 0;
  }
#line 741
  return (tmp___9);
}
}
#line 749 "openbsd-compat/glob.c"
static int match(Char *name , Char *pat , Char *patend ) 
{ int ok ;
  int negate_range ;
  Char c ;
  Char k ;
  Char *tmp ;
  int tmp___0 ;
  Char *tmp___1 ;
  Char *tmp___2 ;
  Char *tmp___3 ;
  Char *tmp___4 ;
  Char *tmp___5 ;

  {
#line 756
  while ((unsigned int )pat < (unsigned int )patend) {
#line 757
    tmp = pat;
#line 757
    pat ++;
#line 757
    c = *tmp;
#line 758
    switch ((int )c & 65535) {
    case (unsigned short)32810: 
#line 760
    if ((unsigned int )pat == (unsigned int )patend) {
#line 761
      return (1);
    }
#line 762
    while (1) {
#line 763
      tmp___0 = match(name, pat, patend);
#line 763
      if (tmp___0) {
#line 764
        return (1);
      }
#line 762
      tmp___1 = name;
#line 762
      name ++;
#line 762
      if (! ((int )*tmp___1 != 0)) {
#line 762
        break;
      }
    }
#line 767
    return (0);
    case (unsigned short)32831: 
#line 769
    tmp___2 = name;
#line 769
    name ++;
#line 769
    if ((int )*tmp___2 == 0) {
#line 770
      return (0);
    }
#line 771
    break;
    case (unsigned short)32859: 
#line 773
    ok = 0;
#line 774
    tmp___3 = name;
#line 774
    name ++;
#line 774
    k = *tmp___3;
#line 774
    if ((int )k == 0) {
#line 775
      return (0);
    }
#line 776
    negate_range = ((int )*pat & 65535) == 32801;
#line 776
    if (negate_range != 0) {
#line 777
      pat ++;
    }
#line 778
    while (1) {
#line 778
      tmp___4 = pat;
#line 778
      pat ++;
#line 778
      c = *tmp___4;
#line 778
      if (! (((int )c & 65535) != 32861)) {
#line 778
        break;
      }
#line 779
      if (((int )*pat & 65535) == 32813) {
#line 780
        if ((int )c <= (int )k) {
#line 780
          if ((int )k <= (int )*(pat + 1)) {
#line 781
            ok = 1;
          }
        }
#line 782
        pat += 2;
      } else {
#line 783
        if ((int )c == (int )k) {
#line 784
          ok = 1;
        }
      }
    }
#line 785
    if (ok == negate_range) {
#line 786
      return (0);
    }
#line 787
    break;
    default: 
#line 789
    tmp___5 = name;
#line 789
    name ++;
#line 789
    if ((int )*tmp___5 != (int )c) {
#line 790
      return (0);
    }
#line 791
    break;
    }
  }
#line 794
  return ((int )*name == 0);
}
}
#line 798 "openbsd-compat/glob.c"
void globfree(glob_t *pglob ) 
{ register int i ;
  register char **pp ;
  int tmp ;

  {
#line 805
  if ((unsigned int )pglob->gl_pathv != (unsigned int )((void *)0)) {
#line 806
    pp = pglob->gl_pathv + pglob->gl_offs;
#line 807
    i = pglob->gl_pathc;
#line 807
    while (1) {
#line 807
      tmp = i;
#line 807
      i --;
#line 807
      if (! tmp) {
#line 807
        break;
      }
#line 808
      if (*pp) {
#line 809
        free((void *)*pp);
      }
#line 807
      pp ++;
    }
#line 810
    free((void *)pglob->gl_pathv);
#line 811
    pglob->gl_pathv = (char **)((void *)0);
  }
#line 813
  return;
}
}
#line 815 "openbsd-compat/glob.c"
static DIR *g_opendir(Char *str , glob_t *pglob ) 
{ char buf___1[4096] ;
  int tmp ;
  void *tmp___0 ;
  DIR *tmp___1 ;

  {
#line 822
  if (! *str) {
#line 823
    strlcpy(buf___1, ".", sizeof(buf___1));
  } else {
#line 825
    tmp = g_Ctoc((Char const   *)str, buf___1, sizeof(buf___1));
#line 825
    if (tmp) {
#line 826
      return ((DIR *)((void *)0));
    }
  }
#line 829
  if (pglob->gl_flags & 64) {
#line 830
    tmp___0 = (*(pglob->gl_opendir))((char const   *)(buf___1));
#line 830
    return ((DIR *)tmp___0);
  }
#line 832
  tmp___1 = opendir((char const   *)(buf___1));
#line 832
  return (tmp___1);
}
}
#line 835 "openbsd-compat/glob.c"
static int g_lstat(Char *fn , struct stat *sb , glob_t *pglob ) 
{ char buf___1[4096] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 843
  tmp = g_Ctoc((Char const   *)fn, buf___1, sizeof(buf___1));
#line 843
  if (tmp) {
#line 844
    return (-1);
  }
#line 845
  if (pglob->gl_flags & 64) {
#line 846
    tmp___0 = (*(pglob->gl_lstat))((char const   *)(buf___1), sb);
#line 846
    return (tmp___0);
  }
#line 847
  tmp___1 = lstat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )sb);
#line 847
  return (tmp___1);
}
}
#line 850 "openbsd-compat/glob.c"
static int g_stat(Char *fn , struct stat *sb , glob_t *pglob ) 
{ char buf___1[4096] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 858
  tmp = g_Ctoc((Char const   *)fn, buf___1, sizeof(buf___1));
#line 858
  if (tmp) {
#line 859
    return (-1);
  }
#line 860
  if (pglob->gl_flags & 64) {
#line 861
    tmp___0 = (*(pglob->gl_stat))((char const   *)(buf___1), sb);
#line 861
    return (tmp___0);
  }
#line 862
  tmp___1 = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )sb);
#line 862
  return (tmp___1);
}
}
#line 865 "openbsd-compat/glob.c"
static Char *g_strchr(Char *str , int ch ) 
{ Char *tmp ;

  {
#line 870
  while (1) {
#line 871
    if ((int )*str == ch) {
#line 872
      return (str);
    }
#line 870
    tmp = str;
#line 870
    str ++;
#line 870
    if (! *tmp) {
#line 870
      break;
    }
  }
#line 874
  return ((Char *)((void *)0));
}
}
#line 877 "openbsd-compat/glob.c"
static int g_Ctoc(Char const   *str , char *buf___1 , u_int len ) 
{ char *tmp ;
  Char const   *tmp___0 ;
  u_int tmp___1 ;

  {
#line 884
  while (1) {
#line 884
    tmp___1 = len;
#line 884
    len --;
#line 884
    if (! tmp___1) {
#line 884
      break;
    }
#line 885
    tmp = buf___1;
#line 885
    buf___1 ++;
#line 885
    tmp___0 = str;
#line 885
    str ++;
#line 885
    *tmp = (char )*tmp___0;
#line 885
    if ((int )*tmp == 0) {
#line 886
      return (0);
    }
  }
#line 888
  return (1);
}
}
#line 1 "inet_aton.o"
#line 1 "inet_ntoa.o"
#line 1 "inet_ntop.o"
#line 1 "mktemp.o"
#line 88 "/usr/include/fcntl.h"
extern int open(char const   *__file , int __oflag  , ...)  __asm__("open64") __attribute__((__nonnull__(1))) ;
#line 729 "/usr/include/stdlib.h"
 __attribute__((__nothrow__)) char *mkdtemp(char *path )  __attribute__((__nonnull__(1))) ;
#line 573 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 263
__inline static  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path ,
                                                        struct stat * __restrict  __statbuf )  __asm__("lstat64") __attribute__((__nonnull__(1,2))) ;
#line 316
extern  __attribute__((__nothrow__)) int mkdir(char const   *__path , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 82 "./openbsd-compat/openbsd-compat.h"
int mkstemps(char *path , int slen ) ;
#line 48 "openbsd-compat/mktemp.c"
static int _gettemp(char *path , int *doopen , int domkdir , int slen ) ;
#line 50 "openbsd-compat/mktemp.c"
int mkstemps(char *path , int slen ) 
{ int fd ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 57
  tmp___1 = _gettemp(path, & fd, 0, slen);
#line 57
  if (tmp___1) {
#line 57
    tmp___0 = fd;
  } else {
#line 57
    tmp___0 = -1;
  }
#line 57
  return (tmp___0);
}
}
#line 60
int mkstemp(char *path )  __asm__("mkstemp64") __attribute__((__nonnull__(1))) ;
#line 60 "openbsd-compat/mktemp.c"
int mkstemp(char *path ) 
{ int fd ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 66
  tmp___1 = _gettemp(path, & fd, 0, 0);
#line 66
  if (tmp___1) {
#line 66
    tmp___0 = fd;
  } else {
#line 66
    tmp___0 = -1;
  }
#line 66
  return (tmp___0);
}
}
#line 69
 __attribute__((__nothrow__)) char *mkdtemp(char *path )  __attribute__((__nonnull__(1))) ;
#line 69 "openbsd-compat/mktemp.c"
char *mkdtemp(char *path ) 
{ char *tmp___0 ;
  int tmp___1 ;

  {
#line 73
  tmp___1 = _gettemp(path, (int *)((void *)0), 1, 0);
#line 73
  if (tmp___1) {
#line 73
    tmp___0 = path;
  } else {
#line 73
    tmp___0 = (char *)((void *)0);
  }
#line 73
  return (tmp___0);
}
}
#line 76 "openbsd-compat/mktemp.c"
static int _gettemp(char *path , int *doopen , int domkdir , int slen ) 
{ register char *start___0 ;
  register char *trv ;
  register char *suffp ;
  struct stat sbuf ;
  int rval ;
  pid_t pid ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char c ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  unsigned short const   **tmp___13 ;

  {
#line 88
  if (doopen) {
#line 88
    if (domkdir) {
#line 89
      tmp = __errno_location();
#line 89
      *tmp = 22;
#line 90
      return (0);
    }
  }
#line 93
  trv = path;
#line 93
  while (*trv) {
#line 93
    trv ++;
  }
#line 95
  trv -= slen;
#line 96
  suffp = trv;
#line 97
  trv --;
#line 98
  if ((unsigned int )trv < (unsigned int )path) {
#line 99
    tmp___0 = __errno_location();
#line 99
    *tmp___0 = 22;
#line 100
    return (0);
  }
#line 102
  pid = getpid();
#line 103
  while (1) {
#line 103
    if ((unsigned int )trv >= (unsigned int )path) {
#line 103
      if ((int )*trv == 88) {
#line 103
        if (! (pid != 0)) {
#line 103
          break;
        }
      } else {
#line 103
        break;
      }
    } else {
#line 103
      break;
    }
#line 104
    tmp___1 = trv;
#line 104
    trv --;
#line 104
    *tmp___1 = (char )(pid % 10 + 48);
#line 105
    pid /= 10;
  }
#line 107
  while (1) {
#line 107
    if ((unsigned int )trv >= (unsigned int )path) {
#line 107
      if (! ((int )*trv == 88)) {
#line 107
        break;
      }
    } else {
#line 107
      break;
    }
#line 110
    tmp___2 = arc4random();
#line 110
    pid = (int )((tmp___2 & 65535U) % 52U);
#line 111
    if (pid < 26) {
#line 112
      c = (char )(pid + 65);
    } else {
#line 114
      c = (char )((pid - 26) + 97);
    }
#line 115
    tmp___3 = trv;
#line 115
    trv --;
#line 115
    *tmp___3 = c;
  }
#line 117
  start___0 = trv + 1;
#line 123
  if (doopen) {
    goto _L;
  } else {
#line 123
    if (domkdir) {
      _L: /* CIL Label */ 
#line 124
      while (! ((unsigned int )trv <= (unsigned int )path)) {
#line 127
        if ((int )*trv == 47) {
#line 128
          *trv = (char )'\000';
#line 129
          rval = stat((char const   * __restrict  )path, (struct stat * __restrict  )(& sbuf));
#line 130
          *trv = (char )'/';
#line 131
          if (rval != 0) {
#line 132
            return (0);
          }
#line 133
          if (! ((sbuf.st_mode & 61440U) == 16384U)) {
#line 134
            tmp___4 = __errno_location();
#line 134
            *tmp___4 = 20;
#line 135
            return (0);
          }
#line 137
          break;
        }
#line 124
        trv --;
      }
    }
  }
#line 142
  while (1) {
#line 143
    if (doopen) {
#line 144
      *doopen = open((char const   *)path, 194, 384);
#line 144
      if (*doopen >= 0) {
#line 146
        return (1);
      }
#line 147
      tmp___5 = __errno_location();
#line 147
      if (*tmp___5 != 17) {
#line 148
        return (0);
      }
    } else {
#line 149
      if (domkdir) {
#line 150
        tmp___6 = mkdir((char const   *)path, 448U);
#line 150
        if (tmp___6 == 0) {
#line 151
          return (1);
        }
#line 152
        tmp___7 = __errno_location();
#line 152
        if (*tmp___7 != 17) {
#line 153
          return (0);
        }
      } else {
#line 154
        tmp___11 = lstat((char const   * __restrict  )path, (struct stat * __restrict  )(& sbuf));
#line 154
        if (tmp___11) {
#line 155
          tmp___10 = __errno_location();
#line 155
          if (*tmp___10 == 2) {
#line 155
            tmp___9 = 1;
          } else {
#line 155
            tmp___9 = 0;
          }
#line 155
          return (tmp___9);
        }
      }
    }
#line 158
    trv = start___0;
#line 158
    while (1) {
#line 159
      if (! *trv) {
#line 160
        return (0);
      }
#line 161
      if ((int )*trv == 90) {
#line 162
        if ((unsigned int )trv == (unsigned int )suffp) {
#line 163
          return (0);
        }
#line 164
        tmp___12 = trv;
#line 164
        trv ++;
#line 164
        *tmp___12 = (char )'a';
      } else {
#line 166
        tmp___13 = __ctype_b_loc();
#line 166
        if ((int const   )*(*tmp___13 + (int )*trv) & 2048) {
#line 167
          *trv = (char )'a';
        } else {
#line 168
          if ((int )*trv == 122) {
#line 169
            *trv = (char )'A';
          } else {
#line 171
            if ((unsigned int )trv == (unsigned int )suffp) {
#line 172
              return (0);
            }
#line 173
            *trv = (char )((int )*trv + 1);
          }
        }
#line 175
        break;
      }
    }
  }
}
}
#line 1 "readpassphrase.o"
#line 83 "/usr/include/ctype.h"
extern __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 85
extern __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
#line 116
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 119
__inline static  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 190
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 190 "/usr/include/ctype.h"
__inline static int tolower(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
#line 193
  if (__c >= -128) {
#line 193
    if (__c < 256) {
#line 193
      tmp___1 = __ctype_tolower_loc();
#line 193
      tmp___0 = *(*tmp___1 + __c);
    } else {
#line 193
      tmp___0 = (int const   )__c;
    }
  } else {
#line 193
    tmp___0 = (int const   )__c;
  }
#line 193
  return ((int )tmp___0);
}
}
#line 196
__inline static  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 196 "/usr/include/ctype.h"
__inline static int toupper(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
#line 199
  if (__c >= -128) {
#line 199
    if (__c < 256) {
#line 199
      tmp___1 = __ctype_toupper_loc();
#line 199
      tmp___0 = *(*tmp___1 + __c);
    } else {
#line 199
      tmp___0 = (int const   )__c;
    }
  } else {
#line 199
    tmp___0 = (int const   )__c;
  }
#line 199
  return ((int )tmp___0);
}
}
#line 117 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 62 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 327 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 333
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 67 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 71
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
#line 47 "./openbsd-compat/readpassphrase.h"
char *readpassphrase(char const   *prompt , char *buf___1 , size_t bufsiz , int flags ) ;
#line 47 "openbsd-compat/readpassphrase.c"
static sig_atomic_t volatile   signo  ;
#line 49
static void handler(int s ) ;
#line 51 "openbsd-compat/readpassphrase.c"
char *readpassphrase(char const   *prompt , char *buf___1 , size_t bufsiz , int flags ) 
{ ssize_t nr ;
  int input___0 ;
  int output___0 ;
  int save_errno ;
  char ch ;
  char *p ;
  char *end ;
  struct termios term ;
  struct termios oterm ;
  struct sigaction sa ;
  struct sigaction savealrm ;
  struct sigaction saveint ;
  struct sigaction savehup ;
  struct sigaction savequit ;
  struct sigaction saveterm ;
  struct sigaction savetstp ;
  struct sigaction savettin ;
  struct sigaction savettou ;
  struct sigaction savepipe ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int __res ;
  __int32_t const   **tmp___5 ;
  int __res___0 ;
  __int32_t const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  __pid_t tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;

  {
#line 62
  if (bufsiz == 0U) {
#line 63
    tmp = __errno_location();
#line 63
    *tmp = 22;
#line 64
    return ((char *)((void *)0));
  }
  restart: 
#line 68
  signo = (int volatile   )0;
#line 73
  if (flags & 32) {
    goto _L;
  } else {
#line 73
    output___0 = open("/dev/tty", 2);
#line 73
    input___0 = output___0;
#line 73
    if (input___0 == -1) {
      _L: /* CIL Label */ 
#line 75
      if (flags & 2) {
#line 76
        tmp___0 = __errno_location();
#line 76
        *tmp___0 = 25;
#line 77
        return ((char *)((void *)0));
      }
#line 79
      input___0 = 0;
#line 80
      output___0 = 2;
    }
  }
#line 88
  sigemptyset(& sa.sa_mask);
#line 89
  sa.sa_flags = 0;
#line 90
  sa.__sigaction_handler.sa_handler = & handler;
#line 91
  sigaction(14, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savealrm));
#line 92
  sigaction(1, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savehup));
#line 93
  sigaction(2, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& saveint));
#line 94
  sigaction(13, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savepipe));
#line 95
  sigaction(3, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savequit));
#line 96
  sigaction(15, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& saveterm));
#line 97
  sigaction(20, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savetstp));
#line 98
  sigaction(21, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savettin));
#line 99
  sigaction(22, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savettou));
#line 102
  if (input___0 != 0) {
#line 102
    tmp___1 = tcgetattr(input___0, & oterm);
#line 102
    if (tmp___1 == 0) {
#line 103
      memcpy((void * __restrict  )(& term), (void const   * __restrict  )(& oterm),
             sizeof(term));
#line 104
      if (! (flags & 1)) {
#line 105
        term.c_lflag &= 4294967223U;
      }
#line 110
      tcsetattr(input___0, 2, (struct termios  const  *)(& term));
    } else {
#line 112
      memset((void *)(& term), 0, sizeof(term));
#line 113
      term.c_lflag |= 8U;
#line 114
      memset((void *)(& oterm), 0, sizeof(oterm));
#line 115
      oterm.c_lflag |= 8U;
    }
  } else {
#line 112
    memset((void *)(& term), 0, sizeof(term));
#line 113
    term.c_lflag |= 8U;
#line 114
    memset((void *)(& oterm), 0, sizeof(oterm));
#line 115
    oterm.c_lflag |= 8U;
  }
#line 118
  if (! (flags & 32)) {
#line 119
    tmp___2 = strlen(prompt);
#line 119
    write(output___0, (void const   *)prompt, tmp___2);
  }
#line 120
  end = (buf___1 + bufsiz) - 1;
#line 121
  p = buf___1;
#line 121
  while (1) {
#line 121
    nr = read(input___0, (void *)(& ch), 1U);
#line 121
    if (nr == 1) {
#line 121
      if ((int )ch != 10) {
#line 121
        if (! ((int )ch != 13)) {
#line 121
          break;
        }
      } else {
#line 121
        break;
      }
    } else {
#line 121
      break;
    }
#line 122
    if ((unsigned int )p < (unsigned int )end) {
#line 123
      if (flags & 16) {
#line 124
        ch = (char )((int )ch & 127);
      }
#line 125
      tmp___9 = __ctype_b_loc();
#line 125
      if ((int const   )*(*tmp___9 + (int )ch) & 1024) {
#line 126
        if (flags & 4) {
#line 127
          if (sizeof(ch) > 1U) {
#line 127
            __res = tolower((int )ch);
          } else {
#line 127
            tmp___5 = __ctype_tolower_loc();
#line 127
            __res = (int )*(*tmp___5 + (int )ch);
          }
#line 127
          ch = (char )__res;
        }
#line 128
        if (flags & 8) {
#line 129
          if (sizeof(ch) > 1U) {
#line 129
            __res___0 = toupper((int )ch);
          } else {
#line 129
            tmp___8 = __ctype_toupper_loc();
#line 129
            __res___0 = (int )*(*tmp___8 + (int )ch);
          }
#line 129
          ch = (char )__res___0;
        }
      }
#line 131
      tmp___10 = p;
#line 131
      p ++;
#line 131
      *tmp___10 = ch;
    }
  }
#line 134
  *p = (char )'\000';
#line 135
  tmp___11 = __errno_location();
#line 135
  save_errno = *tmp___11;
#line 136
  if (! (term.c_lflag & 8U)) {
#line 137
    write(output___0, (void const   *)"\n", 1U);
  }
#line 140
  tmp___12 = memcmp((void const   *)(& term), (void const   *)(& oterm), sizeof(term));
#line 140
  if (tmp___12 != 0) {
#line 141
    tcsetattr(input___0, 2, (struct termios  const  *)(& oterm));
  }
#line 142
  sigaction(14, (struct sigaction  const  * __restrict  )(& savealrm), (struct sigaction * __restrict  )((void *)0));
#line 143
  sigaction(1, (struct sigaction  const  * __restrict  )(& savehup), (struct sigaction * __restrict  )((void *)0));
#line 144
  sigaction(2, (struct sigaction  const  * __restrict  )(& saveint), (struct sigaction * __restrict  )((void *)0));
#line 145
  sigaction(3, (struct sigaction  const  * __restrict  )(& savequit), (struct sigaction * __restrict  )((void *)0));
#line 146
  sigaction(13, (struct sigaction  const  * __restrict  )(& savepipe), (struct sigaction * __restrict  )((void *)0));
#line 147
  sigaction(15, (struct sigaction  const  * __restrict  )(& saveterm), (struct sigaction * __restrict  )((void *)0));
#line 148
  sigaction(20, (struct sigaction  const  * __restrict  )(& savetstp), (struct sigaction * __restrict  )((void *)0));
#line 149
  sigaction(21, (struct sigaction  const  * __restrict  )(& savettin), (struct sigaction * __restrict  )((void *)0));
#line 150
  if (input___0 != 0) {
#line 151
    close(input___0);
  }
#line 157
  if (signo) {
#line 158
    tmp___13 = getpid();
#line 158
    kill(tmp___13, (int )signo);
#line 159
    switch ((int )signo) {
    case 20: 
    case 21: 
    case 22: 
    goto restart;
    }
  }
#line 167
  tmp___14 = __errno_location();
#line 167
  *tmp___14 = save_errno;
#line 168
  if (nr == -1) {
#line 168
    tmp___15 = (char *)((void *)0);
  } else {
#line 168
    tmp___15 = buf___1;
  }
#line 168
  return (tmp___15);
}
}
#line 181 "openbsd-compat/readpassphrase.c"
static void handler(int s ) 
{ 

  {
#line 184
  signo = (int volatile   )s;
#line 185
  return;
}
}
#line 1 "realpath.o"
#line 1 "rresvport.o"
#line 1 "setenv.o"
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 1 "setproctitle.o"
#line 361 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 498 "/usr/include/unistd.h"
extern char **environ ;
#line 70 "./openbsd-compat/openbsd-compat.h"
size_t strlcat(char *dst , char const   *src , size_t siz ) ;
#line 112
void setproctitle(char const   *fmt  , ...) ;
#line 113
void compat_init_setproctitle(int argc , char **argv ) ;
#line 56 "openbsd-compat/setproctitle.c"
static char *argv_start  =    (char *)((void *)0);
#line 57 "openbsd-compat/setproctitle.c"
static size_t argv_env_len  =    (size_t )0;
#line 62 "openbsd-compat/setproctitle.c"
void compat_init_setproctitle(int argc , char **argv ) 
{ char *lastargv ;
  char **envp ;
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___11 ;

  {
#line 67
  lastargv = (char *)((void *)0);
#line 68
  envp = environ;
#line 77
  if (argc == 0) {
#line 78
    return;
  } else {
#line 77
    if ((unsigned int )*(argv + 0) == (unsigned int )((void *)0)) {
#line 78
      return;
    }
  }
#line 81
  i = 0;
#line 81
  while ((unsigned int )*(envp + i) != (unsigned int )((void *)0)) {
#line 81
    i ++;
  }
#line 83
  tmp = malloc(sizeof(*environ) * (unsigned int )(i + 1));
#line 83
  environ = (char **)tmp;
#line 83
  if ((unsigned int )environ == (unsigned int )((void *)0)) {
#line 84
    environ = envp;
#line 85
    return;
  }
#line 92
  i = 0;
#line 92
  while (i < argc) {
#line 93
    if ((unsigned int )lastargv == (unsigned int )((void *)0)) {
#line 94
      tmp___0 = strlen((char const   *)*(argv + i));
#line 94
      lastargv = *(argv + i) + tmp___0;
    } else {
#line 93
      if ((unsigned int )(lastargv + 1) == (unsigned int )*(argv + i)) {
#line 94
        tmp___0 = strlen((char const   *)*(argv + i));
#line 94
        lastargv = *(argv + i) + tmp___0;
      }
    }
#line 92
    i ++;
  }
#line 96
  i = 0;
#line 96
  while ((unsigned int )*(envp + i) != (unsigned int )((void *)0)) {
#line 97
    if ((unsigned int )(lastargv + 1) == (unsigned int )*(envp + i)) {
#line 98
      tmp___1 = strlen((char const   *)*(envp + i));
#line 98
      lastargv = *(envp + i) + tmp___1;
    }
#line 96
    i ++;
  }
#line 101
  *(argv + 1) = (char *)((void *)0);
#line 102
  argv_start = *(argv + 0);
#line 103
  argv_env_len = (unsigned int )((lastargv - *(argv + 0)) - 1);
#line 109
  i = 0;
#line 109
  while ((unsigned int )*(envp + i) != (unsigned int )((void *)0)) {
#line 110
    tmp___11 = __strdup((char const   *)*(envp + i));
#line 110
    *(environ + i) = tmp___11;
#line 109
    i ++;
  }
#line 111
  *(environ + i) = (char *)((void *)0);
#line 113
  return;
}
}
#line 116 "openbsd-compat/setproctitle.c"
void setproctitle(char const   *fmt  , ...) 
{ va_list ap ;
  char buf___1[1024] ;
  size_t len ;

  {
#line 129
  if (argv_env_len <= 0U) {
#line 130
    return;
  }
#line 133
  strlcpy(buf___1, (char const   *)__progname, sizeof(buf___1));
#line 135
  __builtin_va_start(ap, fmt);
#line 136
  if ((unsigned int )fmt != (unsigned int )((void *)0)) {
#line 137
    len = strlcat(buf___1, ": ", sizeof(buf___1));
#line 138
    if (len < sizeof(buf___1)) {
#line 139
      vsnprintf((char * __restrict  )(buf___1 + len), sizeof(buf___1) - len, (char const   * __restrict  )fmt,
                ap);
    }
  }
#line 141
  __builtin_va_end(ap);
#line 149
  len = strlcpy(argv_start, (char const   *)(buf___1), argv_env_len);
#line 150
  while (len < argv_env_len) {
#line 151
    *(argv_start + len) = (char )'\000';
#line 150
    len ++;
  }
#line 155
  return;
}
}
#line 1 "sigact.o"
#line 1 "strlcat.o"
#line 38 "openbsd-compat/strlcat.c"
size_t strlcat(char *dst , char const   *src , size_t siz ) 
{ register char *d ;
  register char const   *s ;
  register size_t n___0 ;
  size_t dlen ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 41
  d = dst;
#line 42
  s = src;
#line 43
  n___0 = siz;
#line 47
  while (1) {
#line 47
    tmp = n___0;
#line 47
    n___0 --;
#line 47
    if (tmp != 0U) {
#line 47
      if (! ((int )*d != 0)) {
#line 47
        break;
      }
    } else {
#line 47
      break;
    }
#line 48
    d ++;
  }
#line 49
  dlen = (unsigned int )(d - dst);
#line 50
  n___0 = siz - dlen;
#line 52
  if (n___0 == 0U) {
#line 53
    tmp___0 = strlen(s);
#line 53
    return (dlen + tmp___0);
  }
#line 54
  while ((int const   )*s != 0) {
#line 55
    if (n___0 != 1U) {
#line 56
      tmp___1 = d;
#line 56
      d ++;
#line 56
      *tmp___1 = (char )*s;
#line 57
      n___0 --;
    }
#line 59
    s ++;
  }
#line 61
  *d = (char )'\000';
#line 63
  return (dlen + (size_t )(s - src));
}
}
#line 1 "strlcpy.o"
#line 36 "openbsd-compat/strlcpy.c"
size_t strlcpy(char *dst , char const   *src , size_t siz ) 
{ register char *d ;
  register char const   *s ;
  register size_t n___0 ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 39
  d = dst;
#line 40
  s = src;
#line 41
  n___0 = siz;
#line 44
  if (n___0 != 0U) {
#line 44
    n___0 --;
#line 44
    if (n___0 != 0U) {
#line 45
      while (1) {
#line 46
        tmp = d;
#line 46
        d ++;
#line 46
        tmp___0 = s;
#line 46
        s ++;
#line 46
        *tmp = (char )*tmp___0;
#line 46
        if ((int )*tmp == 0) {
#line 47
          break;
        }
#line 45
        n___0 --;
#line 45
        if (! (n___0 != 0U)) {
#line 45
          break;
        }
      }
    }
  }
#line 52
  if (n___0 == 0U) {
#line 53
    if (siz != 0U) {
#line 54
      *d = (char )'\000';
    }
#line 55
    while (1) {
#line 55
      tmp___1 = s;
#line 55
      s ++;
#line 55
      if (! *tmp___1) {
#line 55
        break;
      }
    }
  }
#line 59
  return ((unsigned int )((s - src) - 1));
}
}
#line 1 "strmode.o"
#line 78 "./openbsd-compat/openbsd-compat.h"
void strmode(int mode , char *p ) ;
#line 45 "openbsd-compat/strmode.c"
void strmode(int mode , char *p ) 
{ char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;

  {
#line 49
  switch (mode & 61440) {
  case 16384: 
#line 51
  tmp = p;
#line 51
  p ++;
#line 51
  *tmp = (char )'d';
#line 52
  break;
  case 8192: 
#line 54
  tmp___0 = p;
#line 54
  p ++;
#line 54
  *tmp___0 = (char )'c';
#line 55
  break;
  case 24576: 
#line 57
  tmp___1 = p;
#line 57
  p ++;
#line 57
  *tmp___1 = (char )'b';
#line 58
  break;
  case 32768: 
#line 60
  tmp___2 = p;
#line 60
  p ++;
#line 60
  *tmp___2 = (char )'-';
#line 61
  break;
  case 40960: 
#line 63
  tmp___3 = p;
#line 63
  p ++;
#line 63
  *tmp___3 = (char )'l';
#line 64
  break;
  case 49152: 
#line 67
  tmp___4 = p;
#line 67
  p ++;
#line 67
  *tmp___4 = (char )'s';
#line 68
  break;
  case 4096: 
#line 72
  tmp___5 = p;
#line 72
  p ++;
#line 72
  *tmp___5 = (char )'p';
#line 73
  break;
  default: 
#line 81
  tmp___6 = p;
#line 81
  p ++;
#line 81
  *tmp___6 = (char )'?';
#line 82
  break;
  }
#line 85
  if (mode & 256) {
#line 86
    tmp___7 = p;
#line 86
    p ++;
#line 86
    *tmp___7 = (char )'r';
  } else {
#line 88
    tmp___8 = p;
#line 88
    p ++;
#line 88
    *tmp___8 = (char )'-';
  }
#line 89
  if (mode & 128) {
#line 90
    tmp___9 = p;
#line 90
    p ++;
#line 90
    *tmp___9 = (char )'w';
  } else {
#line 92
    tmp___10 = p;
#line 92
    p ++;
#line 92
    *tmp___10 = (char )'-';
  }
#line 93
  switch (mode & 2112) {
  case 0: 
#line 95
  tmp___11 = p;
#line 95
  p ++;
#line 95
  *tmp___11 = (char )'-';
#line 96
  break;
  case 64: 
#line 98
  tmp___12 = p;
#line 98
  p ++;
#line 98
  *tmp___12 = (char )'x';
#line 99
  break;
  case 2048: 
#line 101
  tmp___13 = p;
#line 101
  p ++;
#line 101
  *tmp___13 = (char )'S';
#line 102
  break;
  case 2112: 
#line 104
  tmp___14 = p;
#line 104
  p ++;
#line 104
  *tmp___14 = (char )'s';
#line 105
  break;
  }
#line 108
  if (mode & (256 >> 3)) {
#line 109
    tmp___15 = p;
#line 109
    p ++;
#line 109
    *tmp___15 = (char )'r';
  } else {
#line 111
    tmp___16 = p;
#line 111
    p ++;
#line 111
    *tmp___16 = (char )'-';
  }
#line 112
  if (mode & (128 >> 3)) {
#line 113
    tmp___17 = p;
#line 113
    p ++;
#line 113
    *tmp___17 = (char )'w';
  } else {
#line 115
    tmp___18 = p;
#line 115
    p ++;
#line 115
    *tmp___18 = (char )'-';
  }
#line 116
  switch (mode & ((64 >> 3) | 1024)) {
  case 0: 
#line 118
  tmp___19 = p;
#line 118
  p ++;
#line 118
  *tmp___19 = (char )'-';
#line 119
  break;
  case 64 >> 3: 
#line 121
  tmp___20 = p;
#line 121
  p ++;
#line 121
  *tmp___20 = (char )'x';
#line 122
  break;
  case 1024: 
#line 124
  tmp___21 = p;
#line 124
  p ++;
#line 124
  *tmp___21 = (char )'S';
#line 125
  break;
  case (64 >> 3) | 1024: 
#line 127
  tmp___22 = p;
#line 127
  p ++;
#line 127
  *tmp___22 = (char )'s';
#line 128
  break;
  }
#line 131
  if (mode & ((256 >> 3) >> 3)) {
#line 132
    tmp___23 = p;
#line 132
    p ++;
#line 132
    *tmp___23 = (char )'r';
  } else {
#line 134
    tmp___24 = p;
#line 134
    p ++;
#line 134
    *tmp___24 = (char )'-';
  }
#line 135
  if (mode & ((128 >> 3) >> 3)) {
#line 136
    tmp___25 = p;
#line 136
    p ++;
#line 136
    *tmp___25 = (char )'w';
  } else {
#line 138
    tmp___26 = p;
#line 138
    p ++;
#line 138
    *tmp___26 = (char )'-';
  }
#line 139
  switch (mode & (((64 >> 3) >> 3) | 512)) {
  case 0: 
#line 141
  tmp___27 = p;
#line 141
  p ++;
#line 141
  *tmp___27 = (char )'-';
#line 142
  break;
  case (64 >> 3) >> 3: 
#line 144
  tmp___28 = p;
#line 144
  p ++;
#line 144
  *tmp___28 = (char )'x';
#line 145
  break;
  case 512: 
#line 147
  tmp___29 = p;
#line 147
  p ++;
#line 147
  *tmp___29 = (char )'T';
#line 148
  break;
  case ((64 >> 3) >> 3) | 512: 
#line 150
  tmp___30 = p;
#line 150
  p ++;
#line 150
  *tmp___30 = (char )'t';
#line 151
  break;
  }
#line 153
  tmp___31 = p;
#line 153
  p ++;
#line 153
  *tmp___31 = (char )' ';
#line 154
  *p = (char )'\000';
#line 155
  return;
}
}
#line 1 "strsep.o"
#line 1 "strtoul.o"
#line 1 "vis.o"
#line 81 "./openbsd-compat/vis.h"
char *vis(char *dst , int c , int flag , int nextc ) ;
#line 82
int strvis(char *dst , char const   *src , int flag ) ;
#line 83
int strnvis(char *dst , char const   *src , size_t siz , int flag ) ;
#line 84
int strvisx(char *dst , char const   *src , size_t len , int flag ) ;
#line 56 "openbsd-compat/vis.c"
char *vis(char *dst , int c , int flag , int nextc ) 
{ char *tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  unsigned short const   **tmp___34 ;

  {
#line 62
  if ((unsigned int )c <= 255U) {
#line 62
    if (((int )((unsigned char )c) & -128) == 0) {
#line 62
      tmp___1 = __ctype_b_loc();
#line 62
      if ((int const   )*(*tmp___1 + (int )((unsigned char )c)) & 32768) {
        goto _L___0;
      } else {
        goto _L___5;
      }
    } else {
      goto _L___5;
    }
  } else {
    _L___5: /* CIL Label */ 
#line 62
    if ((flag & 4) == 0) {
#line 62
      if (c == 32) {
        goto _L___0;
      } else {
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
#line 62
      if ((flag & 8) == 0) {
#line 62
        if (c == 9) {
          goto _L___0;
        } else {
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
#line 62
        if ((flag & 16) == 0) {
#line 62
          if (c == 10) {
            goto _L___0;
          } else {
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
#line 62
          if (flag & 32) {
#line 62
            if (c == 8) {
              goto _L___0;
            } else {
#line 62
              if (c == 7) {
                goto _L___0;
              } else {
#line 62
                if (c == 13) {
                  goto _L___0;
                } else {
#line 62
                  tmp___2 = __ctype_b_loc();
#line 62
                  if ((int const   )*(*tmp___2 + (int )((unsigned char )c)) & 32768) {
                    _L___0: /* CIL Label */ 
#line 63
                    tmp = dst;
#line 63
                    dst ++;
#line 63
                    *tmp = (char )c;
#line 64
                    if (c == 92) {
#line 64
                      if ((flag & 64) == 0) {
#line 65
                        tmp___0 = dst;
#line 65
                        dst ++;
#line 65
                        *tmp___0 = (char )'\\';
                      }
                    }
#line 66
                    *dst = (char )'\000';
#line 67
                    return (dst);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 70
  if (flag & 2) {
#line 71
    switch (c) {
    case 10: 
#line 73
    tmp___3 = dst;
#line 73
    dst ++;
#line 73
    *tmp___3 = (char )'\\';
#line 74
    tmp___4 = dst;
#line 74
    dst ++;
#line 74
    *tmp___4 = (char )'n';
    goto done;
    case 13: 
#line 77
    tmp___5 = dst;
#line 77
    dst ++;
#line 77
    *tmp___5 = (char )'\\';
#line 78
    tmp___6 = dst;
#line 78
    dst ++;
#line 78
    *tmp___6 = (char )'r';
    goto done;
    case 8: 
#line 81
    tmp___7 = dst;
#line 81
    dst ++;
#line 81
    *tmp___7 = (char )'\\';
#line 82
    tmp___8 = dst;
#line 82
    dst ++;
#line 82
    *tmp___8 = (char )'b';
    goto done;
    case 7: 
#line 85
    tmp___9 = dst;
#line 85
    dst ++;
#line 85
    *tmp___9 = (char )'\\';
#line 86
    tmp___10 = dst;
#line 86
    dst ++;
#line 86
    *tmp___10 = (char )'a';
    goto done;
    case 11: 
#line 89
    tmp___11 = dst;
#line 89
    dst ++;
#line 89
    *tmp___11 = (char )'\\';
#line 90
    tmp___12 = dst;
#line 90
    dst ++;
#line 90
    *tmp___12 = (char )'v';
    goto done;
    case 9: 
#line 93
    tmp___13 = dst;
#line 93
    dst ++;
#line 93
    *tmp___13 = (char )'\\';
#line 94
    tmp___14 = dst;
#line 94
    dst ++;
#line 94
    *tmp___14 = (char )'t';
    goto done;
    case 12: 
#line 97
    tmp___15 = dst;
#line 97
    dst ++;
#line 97
    *tmp___15 = (char )'\\';
#line 98
    tmp___16 = dst;
#line 98
    dst ++;
#line 98
    *tmp___16 = (char )'f';
    goto done;
    case 32: 
#line 101
    tmp___17 = dst;
#line 101
    dst ++;
#line 101
    *tmp___17 = (char )'\\';
#line 102
    tmp___18 = dst;
#line 102
    dst ++;
#line 102
    *tmp___18 = (char )'s';
    goto done;
    case 0: 
#line 105
    tmp___19 = dst;
#line 105
    dst ++;
#line 105
    *tmp___19 = (char )'\\';
#line 106
    tmp___20 = dst;
#line 106
    dst ++;
#line 106
    *tmp___20 = (char )'0';
#line 107
    if ((int )((unsigned char )nextc) >= 48) {
#line 107
      if ((int )((unsigned char )nextc) <= 55) {
#line 108
        tmp___21 = dst;
#line 108
        dst ++;
#line 108
        *tmp___21 = (char )'0';
#line 109
        tmp___22 = dst;
#line 109
        dst ++;
#line 109
        *tmp___22 = (char )'0';
      }
    }
    goto done;
    }
  }
#line 114
  if ((c & 127) == 32) {
    goto _L___6;
  } else {
#line 114
    if (flag & 1) {
      _L___6: /* CIL Label */ 
#line 115
      tmp___23 = dst;
#line 115
      dst ++;
#line 115
      *tmp___23 = (char )'\\';
#line 116
      tmp___24 = dst;
#line 116
      dst ++;
#line 116
      *tmp___24 = (char )((((int )((unsigned char )c) >> 6) & 7) + 48);
#line 117
      tmp___25 = dst;
#line 117
      dst ++;
#line 117
      *tmp___25 = (char )((((int )((unsigned char )c) >> 3) & 7) + 48);
#line 118
      tmp___26 = dst;
#line 118
      dst ++;
#line 118
      *tmp___26 = (char )(((int )((unsigned char )c) & 7) + 48);
      goto done;
    }
  }
#line 121
  if ((flag & 64) == 0) {
#line 122
    tmp___27 = dst;
#line 122
    dst ++;
#line 122
    *tmp___27 = (char )'\\';
  }
#line 123
  if (c & 128) {
#line 124
    c &= 127;
#line 125
    tmp___28 = dst;
#line 125
    dst ++;
#line 125
    *tmp___28 = (char )'M';
  }
#line 127
  tmp___34 = __ctype_b_loc();
#line 127
  if ((int const   )*(*tmp___34 + c) & 2) {
#line 128
    tmp___29 = dst;
#line 128
    dst ++;
#line 128
    *tmp___29 = (char )'^';
#line 129
    if (c == 127) {
#line 130
      tmp___30 = dst;
#line 130
      dst ++;
#line 130
      *tmp___30 = (char )'?';
    } else {
#line 132
      tmp___31 = dst;
#line 132
      dst ++;
#line 132
      *tmp___31 = (char )(c + 64);
    }
  } else {
#line 134
    tmp___32 = dst;
#line 134
    dst ++;
#line 134
    *tmp___32 = (char )'-';
#line 135
    tmp___33 = dst;
#line 135
    dst ++;
#line 135
    *tmp___33 = (char )c;
  }
  done: 
#line 138
  *dst = (char )'\000';
#line 139
  return (dst);
}
}
#line 155 "openbsd-compat/vis.c"
int strvis(char *dst , char const   *src , int flag ) 
{ register char c ;
  char *start___0 ;

  {
#line 164
  start___0 = dst;
#line 164
  while (1) {
#line 164
    c = (char )*src;
#line 164
    if (! c) {
#line 164
      break;
    }
#line 165
    src ++;
#line 165
    dst = vis(dst, (int )c, flag, (int )*src);
  }
#line 166
  *dst = (char )'\000';
#line 167
  return (dst - start___0);
}
}
#line 170 "openbsd-compat/vis.c"
int strnvis(char *dst , char const   *src , size_t siz , int flag ) 
{ char c ;
  char *start___0 ;
  char *end ;
  char tbuf[5] ;
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;

  {
#line 182
  i = 0;
#line 183
  start___0 = dst;
#line 183
  end = (start___0 + siz) - 1;
#line 183
  while (1) {
#line 183
    c = (char )*src;
#line 183
    if (c) {
#line 183
      if (! ((unsigned int )dst < (unsigned int )end)) {
#line 183
        break;
      }
    } else {
#line 183
      break;
    }
#line 184
    if ((unsigned int )c <= 255U) {
#line 184
      if (((int )((unsigned char )c) & -128) == 0) {
#line 184
        tmp___2 = __ctype_b_loc();
#line 184
        if ((int const   )*(*tmp___2 + (int )((unsigned char )c)) & 32768) {
          goto _L___1;
        } else {
          goto _L___6;
        }
      } else {
        goto _L___6;
      }
    } else {
      _L___6: /* CIL Label */ 
#line 184
      if ((flag & 4) == 0) {
#line 184
        if ((int )c == 32) {
          goto _L___1;
        } else {
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
#line 184
        if ((flag & 8) == 0) {
#line 184
          if ((int )c == 9) {
            goto _L___1;
          } else {
            goto _L___3;
          }
        } else {
          _L___3: /* CIL Label */ 
#line 184
          if ((flag & 16) == 0) {
#line 184
            if ((int )c == 10) {
              goto _L___1;
            } else {
              goto _L___2;
            }
          } else {
            _L___2: /* CIL Label */ 
#line 184
            if (flag & 32) {
#line 184
              if ((int )c == 8) {
                goto _L___1;
              } else {
#line 184
                if ((int )c == 7) {
                  goto _L___1;
                } else {
#line 184
                  if ((int )c == 13) {
                    goto _L___1;
                  } else {
#line 184
                    tmp___3 = __ctype_b_loc();
#line 184
                    if ((int const   )*(*tmp___3 + (int )((unsigned char )c)) & 32768) {
                      _L___1: /* CIL Label */ 
#line 185
                      i = 1;
#line 186
                      tmp = dst;
#line 186
                      dst ++;
#line 186
                      *tmp = c;
#line 187
                      if ((int )c == 92) {
#line 187
                        if ((flag & 64) == 0) {
#line 189
                          if ((unsigned int )dst < (unsigned int )end) {
#line 190
                            tmp___0 = dst;
#line 190
                            dst ++;
#line 190
                            *tmp___0 = (char )'\\';
                          } else {
#line 192
                            dst --;
#line 193
                            i = 2;
#line 194
                            break;
                          }
                        }
                      }
#line 197
                      src ++;
                    } else {
                      goto _L___0;
                    }
                  }
                }
              }
            } else {
              _L___0: /* CIL Label */ 
#line 199
              src ++;
#line 199
              tmp___1 = vis(tbuf, (int )c, flag, (int )*src);
#line 199
              i = tmp___1 - tbuf;
#line 200
              if ((unsigned int )(dst + i) <= (unsigned int )end) {
#line 201
                memcpy((void * __restrict  )dst, (void const   * __restrict  )(tbuf),
                       (unsigned int )i);
#line 202
                dst += i;
              } else {
#line 204
                src --;
#line 205
                break;
              }
            }
          }
        }
      }
    }
  }
#line 209
  if (siz > 0U) {
#line 210
    *dst = (char )'\000';
  }
#line 211
  if ((unsigned int )(dst + i) > (unsigned int )end) {
#line 213
    while (1) {
#line 213
      c = (char )*src;
#line 213
      if (! c) {
#line 213
        break;
      }
#line 214
      src ++;
#line 214
      tmp___4 = vis(tbuf, (int )c, flag, (int )*src);
#line 214
      dst += tmp___4 - tbuf;
    }
  }
#line 216
  return (dst - start___0);
}
}
#line 219 "openbsd-compat/vis.c"
int strvisx(char *dst , char const   *src , size_t len , int flag ) 
{ register char c ;
  char *start___0 ;

  {
#line 229
  start___0 = dst;
#line 229
  while (len > 1U) {
#line 230
    c = (char )*src;
#line 231
    src ++;
#line 231
    dst = vis(dst, (int )c, flag, (int )*src);
#line 229
    len --;
  }
#line 233
  if (len) {
#line 234
    dst = vis(dst, (int )*src, flag, '\000');
  }
#line 235
  *dst = (char )'\000';
#line 236
  return (dst - start___0);
}
}
#line 1 "acss.o"
#line 43 "acss.h"
void acss_setkey(ACSS_KEY *key , unsigned char const   *data , int enc , int mode ) ;
#line 44
void acss_setsubkey(ACSS_KEY *key , unsigned char const   *subkey ) ;
#line 45
int acss(ACSS_KEY *key , unsigned long len , unsigned char const   *in , unsigned char *out ) ;
#line 26 "acss.c"
static unsigned char sboxdec[256]  = 
#line 26 "acss.c"
  {      (unsigned char)51,      (unsigned char)115,      (unsigned char)59,      (unsigned char)38, 
        (unsigned char)99,      (unsigned char)35,      (unsigned char)107,      (unsigned char)118, 
        (unsigned char)62,      (unsigned char)126,      (unsigned char)54,      (unsigned char)43, 
        (unsigned char)110,      (unsigned char)46,      (unsigned char)102,      (unsigned char)123, 
        (unsigned char)211,      (unsigned char)147,      (unsigned char)219,      (unsigned char)6, 
        (unsigned char)67,      (unsigned char)3,      (unsigned char)75,      (unsigned char)150, 
        (unsigned char)222,      (unsigned char)158,      (unsigned char)214,      (unsigned char)11, 
        (unsigned char)78,      (unsigned char)14,      (unsigned char)70,      (unsigned char)155, 
        (unsigned char)87,      (unsigned char)23,      (unsigned char)95,      (unsigned char)130, 
        (unsigned char)199,      (unsigned char)135,      (unsigned char)207,      (unsigned char)18, 
        (unsigned char)90,      (unsigned char)26,      (unsigned char)82,      (unsigned char)143, 
        (unsigned char)202,      (unsigned char)138,      (unsigned char)194,      (unsigned char)31, 
        (unsigned char)217,      (unsigned char)153,      (unsigned char)209,      (unsigned char)0, 
        (unsigned char)73,      (unsigned char)9,      (unsigned char)65,      (unsigned char)144, 
        (unsigned char)216,      (unsigned char)152,      (unsigned char)208,      (unsigned char)1, 
        (unsigned char)72,      (unsigned char)8,      (unsigned char)64,      (unsigned char)145, 
        (unsigned char)61,      (unsigned char)125,      (unsigned char)53,      (unsigned char)36, 
        (unsigned char)109,      (unsigned char)45,      (unsigned char)101,      (unsigned char)116, 
        (unsigned char)60,      (unsigned char)124,      (unsigned char)52,      (unsigned char)37, 
        (unsigned char)108,      (unsigned char)44,      (unsigned char)100,      (unsigned char)117, 
        (unsigned char)221,      (unsigned char)157,      (unsigned char)213,      (unsigned char)4, 
        (unsigned char)77,      (unsigned char)13,      (unsigned char)69,      (unsigned char)148, 
        (unsigned char)220,      (unsigned char)156,      (unsigned char)212,      (unsigned char)5, 
        (unsigned char)76,      (unsigned char)12,      (unsigned char)68,      (unsigned char)149, 
        (unsigned char)89,      (unsigned char)25,      (unsigned char)81,      (unsigned char)128, 
        (unsigned char)201,      (unsigned char)137,      (unsigned char)193,      (unsigned char)16, 
        (unsigned char)88,      (unsigned char)24,      (unsigned char)80,      (unsigned char)129, 
        (unsigned char)200,      (unsigned char)136,      (unsigned char)192,      (unsigned char)17, 
        (unsigned char)215,      (unsigned char)151,      (unsigned char)223,      (unsigned char)2, 
        (unsigned char)71,      (unsigned char)7,      (unsigned char)79,      (unsigned char)146, 
        (unsigned char)218,      (unsigned char)154,      (unsigned char)210,      (unsigned char)15, 
        (unsigned char)74,      (unsigned char)10,      (unsigned char)66,      (unsigned char)159, 
        (unsigned char)83,      (unsigned char)19,      (unsigned char)91,      (unsigned char)134, 
        (unsigned char)195,      (unsigned char)131,      (unsigned char)203,      (unsigned char)22, 
        (unsigned char)94,      (unsigned char)30,      (unsigned char)86,      (unsigned char)139, 
        (unsigned char)206,      (unsigned char)142,      (unsigned char)198,      (unsigned char)27, 
        (unsigned char)179,      (unsigned char)243,      (unsigned char)187,      (unsigned char)166, 
        (unsigned char)227,      (unsigned char)163,      (unsigned char)235,      (unsigned char)246, 
        (unsigned char)190,      (unsigned char)254,      (unsigned char)182,      (unsigned char)171, 
        (unsigned char)238,      (unsigned char)174,      (unsigned char)230,      (unsigned char)251, 
        (unsigned char)55,      (unsigned char)119,      (unsigned char)63,      (unsigned char)34, 
        (unsigned char)103,      (unsigned char)39,      (unsigned char)111,      (unsigned char)114, 
        (unsigned char)58,      (unsigned char)122,      (unsigned char)50,      (unsigned char)47, 
        (unsigned char)106,      (unsigned char)42,      (unsigned char)98,      (unsigned char)127, 
        (unsigned char)185,      (unsigned char)249,      (unsigned char)177,      (unsigned char)160, 
        (unsigned char)233,      (unsigned char)169,      (unsigned char)225,      (unsigned char)240, 
        (unsigned char)184,      (unsigned char)248,      (unsigned char)176,      (unsigned char)161, 
        (unsigned char)232,      (unsigned char)168,      (unsigned char)224,      (unsigned char)241, 
        (unsigned char)93,      (unsigned char)29,      (unsigned char)85,      (unsigned char)132, 
        (unsigned char)205,      (unsigned char)141,      (unsigned char)197,      (unsigned char)20, 
        (unsigned char)92,      (unsigned char)28,      (unsigned char)84,      (unsigned char)133, 
        (unsigned char)204,      (unsigned char)140,      (unsigned char)196,      (unsigned char)21, 
        (unsigned char)189,      (unsigned char)253,      (unsigned char)181,      (unsigned char)164, 
        (unsigned char)237,      (unsigned char)173,      (unsigned char)229,      (unsigned char)244, 
        (unsigned char)188,      (unsigned char)252,      (unsigned char)180,      (unsigned char)165, 
        (unsigned char)236,      (unsigned char)172,      (unsigned char)228,      (unsigned char)245, 
        (unsigned char)57,      (unsigned char)121,      (unsigned char)49,      (unsigned char)32, 
        (unsigned char)105,      (unsigned char)41,      (unsigned char)97,      (unsigned char)112, 
        (unsigned char)56,      (unsigned char)120,      (unsigned char)48,      (unsigned char)33, 
        (unsigned char)104,      (unsigned char)40,      (unsigned char)96,      (unsigned char)113, 
        (unsigned char)183,      (unsigned char)247,      (unsigned char)191,      (unsigned char)162, 
        (unsigned char)231,      (unsigned char)167,      (unsigned char)239,      (unsigned char)242, 
        (unsigned char)186,      (unsigned char)250,      (unsigned char)178,      (unsigned char)175, 
        (unsigned char)234,      (unsigned char)170,      (unsigned char)226,      (unsigned char)255};
#line 62 "acss.c"
static unsigned char sboxenc[256]  = 
#line 62
  {      (unsigned char)51,      (unsigned char)59,      (unsigned char)115,      (unsigned char)21, 
        (unsigned char)83,      (unsigned char)91,      (unsigned char)19,      (unsigned char)117, 
        (unsigned char)61,      (unsigned char)53,      (unsigned char)125,      (unsigned char)27, 
        (unsigned char)93,      (unsigned char)85,      (unsigned char)29,      (unsigned char)123, 
        (unsigned char)103,      (unsigned char)111,      (unsigned char)39,      (unsigned char)129, 
        (unsigned char)199,      (unsigned char)207,      (unsigned char)135,      (unsigned char)33, 
        (unsigned char)105,      (unsigned char)97,      (unsigned char)41,      (unsigned char)143, 
        (unsigned char)201,      (unsigned char)193,      (unsigned char)137,      (unsigned char)47, 
        (unsigned char)227,      (unsigned char)235,      (unsigned char)163,      (unsigned char)5, 
        (unsigned char)67,      (unsigned char)75,      (unsigned char)3,      (unsigned char)165, 
        (unsigned char)237,      (unsigned char)229,      (unsigned char)173,      (unsigned char)11, 
        (unsigned char)77,      (unsigned char)69,      (unsigned char)13,      (unsigned char)171, 
        (unsigned char)234,      (unsigned char)226,      (unsigned char)170,      (unsigned char)0, 
        (unsigned char)74,      (unsigned char)66,      (unsigned char)10,      (unsigned char)160, 
        (unsigned char)232,      (unsigned char)224,      (unsigned char)168,      (unsigned char)2, 
        (unsigned char)72,      (unsigned char)64,      (unsigned char)8,      (unsigned char)162, 
        (unsigned char)62,      (unsigned char)54,      (unsigned char)126,      (unsigned char)20, 
        (unsigned char)94,      (unsigned char)86,      (unsigned char)30,      (unsigned char)116, 
        (unsigned char)60,      (unsigned char)52,      (unsigned char)124,      (unsigned char)22, 
        (unsigned char)92,      (unsigned char)84,      (unsigned char)28,      (unsigned char)118, 
        (unsigned char)106,      (unsigned char)98,      (unsigned char)42,      (unsigned char)128, 
        (unsigned char)202,      (unsigned char)194,      (unsigned char)138,      (unsigned char)32, 
        (unsigned char)104,      (unsigned char)96,      (unsigned char)40,      (unsigned char)130, 
        (unsigned char)200,      (unsigned char)192,      (unsigned char)136,      (unsigned char)34, 
        (unsigned char)238,      (unsigned char)230,      (unsigned char)174,      (unsigned char)4, 
        (unsigned char)78,      (unsigned char)70,      (unsigned char)14,      (unsigned char)164, 
        (unsigned char)236,      (unsigned char)228,      (unsigned char)172,      (unsigned char)6, 
        (unsigned char)76,      (unsigned char)68,      (unsigned char)12,      (unsigned char)166, 
        (unsigned char)231,      (unsigned char)239,      (unsigned char)167,      (unsigned char)1, 
        (unsigned char)71,      (unsigned char)79,      (unsigned char)7,      (unsigned char)161, 
        (unsigned char)233,      (unsigned char)225,      (unsigned char)169,      (unsigned char)15, 
        (unsigned char)73,      (unsigned char)65,      (unsigned char)9,      (unsigned char)175, 
        (unsigned char)99,      (unsigned char)107,      (unsigned char)35,      (unsigned char)133, 
        (unsigned char)195,      (unsigned char)203,      (unsigned char)131,      (unsigned char)37, 
        (unsigned char)109,      (unsigned char)101,      (unsigned char)45,      (unsigned char)139, 
        (unsigned char)205,      (unsigned char)197,      (unsigned char)141,      (unsigned char)43, 
        (unsigned char)55,      (unsigned char)63,      (unsigned char)119,      (unsigned char)17, 
        (unsigned char)87,      (unsigned char)95,      (unsigned char)23,      (unsigned char)113, 
        (unsigned char)57,      (unsigned char)49,      (unsigned char)121,      (unsigned char)31, 
        (unsigned char)89,      (unsigned char)81,      (unsigned char)25,      (unsigned char)127, 
        (unsigned char)179,      (unsigned char)187,      (unsigned char)243,      (unsigned char)149, 
        (unsigned char)211,      (unsigned char)219,      (unsigned char)147,      (unsigned char)245, 
        (unsigned char)189,      (unsigned char)181,      (unsigned char)253,      (unsigned char)155, 
        (unsigned char)221,      (unsigned char)213,      (unsigned char)157,      (unsigned char)251, 
        (unsigned char)186,      (unsigned char)178,      (unsigned char)250,      (unsigned char)144, 
        (unsigned char)218,      (unsigned char)210,      (unsigned char)154,      (unsigned char)240, 
        (unsigned char)184,      (unsigned char)176,      (unsigned char)248,      (unsigned char)146, 
        (unsigned char)216,      (unsigned char)208,      (unsigned char)152,      (unsigned char)242, 
        (unsigned char)110,      (unsigned char)102,      (unsigned char)46,      (unsigned char)132, 
        (unsigned char)206,      (unsigned char)198,      (unsigned char)142,      (unsigned char)36, 
        (unsigned char)108,      (unsigned char)100,      (unsigned char)44,      (unsigned char)134, 
        (unsigned char)204,      (unsigned char)196,      (unsigned char)140,      (unsigned char)38, 
        (unsigned char)58,      (unsigned char)50,      (unsigned char)122,      (unsigned char)16, 
        (unsigned char)90,      (unsigned char)82,      (unsigned char)26,      (unsigned char)112, 
        (unsigned char)56,      (unsigned char)48,      (unsigned char)120,      (unsigned char)18, 
        (unsigned char)88,      (unsigned char)80,      (unsigned char)24,      (unsigned char)114, 
        (unsigned char)190,      (unsigned char)182,      (unsigned char)254,      (unsigned char)148, 
        (unsigned char)222,      (unsigned char)214,      (unsigned char)158,      (unsigned char)244, 
        (unsigned char)188,      (unsigned char)180,      (unsigned char)252,      (unsigned char)150, 
        (unsigned char)220,      (unsigned char)212,      (unsigned char)156,      (unsigned char)246, 
        (unsigned char)183,      (unsigned char)191,      (unsigned char)247,      (unsigned char)145, 
        (unsigned char)215,      (unsigned char)223,      (unsigned char)151,      (unsigned char)241, 
        (unsigned char)185,      (unsigned char)177,      (unsigned char)249,      (unsigned char)159, 
        (unsigned char)217,      (unsigned char)209,      (unsigned char)153,      (unsigned char)255};
#line 97 "acss.c"
static unsigned char reverse[256]  = 
#line 97
  {      (unsigned char)0,      (unsigned char)128,      (unsigned char)64,      (unsigned char)192, 
        (unsigned char)32,      (unsigned char)160,      (unsigned char)96,      (unsigned char)224, 
        (unsigned char)16,      (unsigned char)144,      (unsigned char)80,      (unsigned char)208, 
        (unsigned char)48,      (unsigned char)176,      (unsigned char)112,      (unsigned char)240, 
        (unsigned char)8,      (unsigned char)136,      (unsigned char)72,      (unsigned char)200, 
        (unsigned char)40,      (unsigned char)168,      (unsigned char)104,      (unsigned char)232, 
        (unsigned char)24,      (unsigned char)152,      (unsigned char)88,      (unsigned char)216, 
        (unsigned char)56,      (unsigned char)184,      (unsigned char)120,      (unsigned char)248, 
        (unsigned char)4,      (unsigned char)132,      (unsigned char)68,      (unsigned char)196, 
        (unsigned char)36,      (unsigned char)164,      (unsigned char)100,      (unsigned char)228, 
        (unsigned char)20,      (unsigned char)148,      (unsigned char)84,      (unsigned char)212, 
        (unsigned char)52,      (unsigned char)180,      (unsigned char)116,      (unsigned char)244, 
        (unsigned char)12,      (unsigned char)140,      (unsigned char)76,      (unsigned char)204, 
        (unsigned char)44,      (unsigned char)172,      (unsigned char)108,      (unsigned char)236, 
        (unsigned char)28,      (unsigned char)156,      (unsigned char)92,      (unsigned char)220, 
        (unsigned char)60,      (unsigned char)188,      (unsigned char)124,      (unsigned char)252, 
        (unsigned char)2,      (unsigned char)130,      (unsigned char)66,      (unsigned char)194, 
        (unsigned char)34,      (unsigned char)162,      (unsigned char)98,      (unsigned char)226, 
        (unsigned char)18,      (unsigned char)146,      (unsigned char)82,      (unsigned char)210, 
        (unsigned char)50,      (unsigned char)178,      (unsigned char)114,      (unsigned char)242, 
        (unsigned char)10,      (unsigned char)138,      (unsigned char)74,      (unsigned char)202, 
        (unsigned char)42,      (unsigned char)170,      (unsigned char)106,      (unsigned char)234, 
        (unsigned char)26,      (unsigned char)154,      (unsigned char)90,      (unsigned char)218, 
        (unsigned char)58,      (unsigned char)186,      (unsigned char)122,      (unsigned char)250, 
        (unsigned char)6,      (unsigned char)134,      (unsigned char)70,      (unsigned char)198, 
        (unsigned char)38,      (unsigned char)166,      (unsigned char)102,      (unsigned char)230, 
        (unsigned char)22,      (unsigned char)150,      (unsigned char)86,      (unsigned char)214, 
        (unsigned char)54,      (unsigned char)182,      (unsigned char)118,      (unsigned char)246, 
        (unsigned char)14,      (unsigned char)142,      (unsigned char)78,      (unsigned char)206, 
        (unsigned char)46,      (unsigned char)174,      (unsigned char)110,      (unsigned char)238, 
        (unsigned char)30,      (unsigned char)158,      (unsigned char)94,      (unsigned char)222, 
        (unsigned char)62,      (unsigned char)190,      (unsigned char)126,      (unsigned char)254, 
        (unsigned char)1,      (unsigned char)129,      (unsigned char)65,      (unsigned char)193, 
        (unsigned char)33,      (unsigned char)161,      (unsigned char)97,      (unsigned char)225, 
        (unsigned char)17,      (unsigned char)145,      (unsigned char)81,      (unsigned char)209, 
        (unsigned char)49,      (unsigned char)177,      (unsigned char)113,      (unsigned char)241, 
        (unsigned char)9,      (unsigned char)137,      (unsigned char)73,      (unsigned char)201, 
        (unsigned char)41,      (unsigned char)169,      (unsigned char)105,      (unsigned char)233, 
        (unsigned char)25,      (unsigned char)153,      (unsigned char)89,      (unsigned char)217, 
        (unsigned char)57,      (unsigned char)185,      (unsigned char)121,      (unsigned char)249, 
        (unsigned char)5,      (unsigned char)133,      (unsigned char)69,      (unsigned char)197, 
        (unsigned char)37,      (unsigned char)165,      (unsigned char)101,      (unsigned char)229, 
        (unsigned char)21,      (unsigned char)149,      (unsigned char)85,      (unsigned char)213, 
        (unsigned char)53,      (unsigned char)181,      (unsigned char)117,      (unsigned char)245, 
        (unsigned char)13,      (unsigned char)141,      (unsigned char)77,      (unsigned char)205, 
        (unsigned char)45,      (unsigned char)173,      (unsigned char)109,      (unsigned char)237, 
        (unsigned char)29,      (unsigned char)157,      (unsigned char)93,      (unsigned char)221, 
        (unsigned char)61,      (unsigned char)189,      (unsigned char)125,      (unsigned char)253, 
        (unsigned char)3,      (unsigned char)131,      (unsigned char)67,      (unsigned char)195, 
        (unsigned char)35,      (unsigned char)163,      (unsigned char)99,      (unsigned char)227, 
        (unsigned char)19,      (unsigned char)147,      (unsigned char)83,      (unsigned char)211, 
        (unsigned char)51,      (unsigned char)179,      (unsigned char)115,      (unsigned char)243, 
        (unsigned char)11,      (unsigned char)139,      (unsigned char)75,      (unsigned char)203, 
        (unsigned char)43,      (unsigned char)171,      (unsigned char)107,      (unsigned char)235, 
        (unsigned char)27,      (unsigned char)155,      (unsigned char)91,      (unsigned char)219, 
        (unsigned char)59,      (unsigned char)187,      (unsigned char)123,      (unsigned char)251, 
        (unsigned char)7,      (unsigned char)135,      (unsigned char)71,      (unsigned char)199, 
        (unsigned char)39,      (unsigned char)167,      (unsigned char)103,      (unsigned char)231, 
        (unsigned char)23,      (unsigned char)151,      (unsigned char)87,      (unsigned char)215, 
        (unsigned char)55,      (unsigned char)183,      (unsigned char)119,      (unsigned char)247, 
        (unsigned char)15,      (unsigned char)143,      (unsigned char)79,      (unsigned char)207, 
        (unsigned char)47,      (unsigned char)175,      (unsigned char)111,      (unsigned char)239, 
        (unsigned char)31,      (unsigned char)159,      (unsigned char)95,      (unsigned char)223, 
        (unsigned char)63,      (unsigned char)191,      (unsigned char)127,      (unsigned char)255};
#line 159 "acss.c"
int acss(ACSS_KEY *key , unsigned long len , unsigned char const   *in , unsigned char *out ) 
{ unsigned long i ;
  unsigned long lfsr17tmp ;
  unsigned long lfsr25tmp ;
  unsigned long lfsrsumtmp ;

  {
#line 166
  lfsr25tmp = 0UL;
#line 166
  lfsr17tmp = lfsr25tmp;
#line 166
  lfsrsumtmp = lfsr17tmp;
#line 169
  i = 0UL;
#line 169
  while (i < len) {
#line 170
    lfsr17tmp = (unsigned long )(key->lfsr17 ^ (key->lfsr17 >> 14));
#line 171
    key->lfsr17 = (unsigned int )((((unsigned long )(key->lfsr17 >> 8) ^ (lfsr17tmp << 9)) ^ (lfsr17tmp << 12)) ^ (lfsr17tmp << 15));
#line 175
    key->lfsr17 &= 131071U;
#line 177
    lfsr25tmp = (unsigned long )(((key->lfsr25 ^ (key->lfsr25 >> 3)) ^ (key->lfsr25 >> 4)) ^ (key->lfsr25 >> 12));
#line 181
    key->lfsr25 = (unsigned int )((unsigned long )(key->lfsr25 >> 8) ^ (lfsr25tmp << 17));
#line 182
    key->lfsr25 &= 33554431U;
#line 184
    lfsrsumtmp = (unsigned long )key->lfsrsum;
#line 187
    switch (key->mode) {
    case 0: 
    case 3: 
#line 190
    key->lfsrsum = 255U & ~ (key->lfsr17 >> 9);
#line 191
    key->lfsrsum += key->lfsr25 >> 17;
#line 192
    break;
    case 1: 
#line 194
    key->lfsrsum = key->lfsr17 >> 9;
#line 195
    key->lfsrsum += key->lfsr25 >> 17;
#line 196
    break;
    case 2: 
#line 198
    key->lfsrsum = key->lfsr17 >> 9;
#line 199
    key->lfsrsum += 255U & ~ (key->lfsr25 >> 17);
#line 200
    break;
    default: ;
#line 202
    return (1);
    }
#line 204
    key->lfsrsum = (unsigned int )((unsigned long )key->lfsrsum + (lfsrsumtmp >> 8));
#line 206
    if (key->encrypt) {
#line 207
      *(out + i) = sboxenc[((unsigned int )*(in + i) ^ key->lfsrsum) & 255U];
    } else {
#line 209
      *(out + i) = (unsigned char )(((unsigned int )sboxdec[*(in + i)] ^ key->lfsrsum) & 255U);
    }
#line 169
    i ++;
  }
#line 213
  return (0);
}
}
#line 216 "acss.c"
static void acss_seed(ACSS_KEY *key ) 
{ int i ;

  {
#line 222
  if (key->subkey_avilable) {
#line 223
    i = 0;
#line 223
    while (i < 5) {
#line 224
      key->seed[i] = reverse[(int )key->data[i] ^ (int )key->subkey[i]];
#line 223
      i ++;
    }
  } else {
#line 226
    i = 0;
#line 226
    while (i < 5) {
#line 227
      key->seed[i] = reverse[key->data[i]];
#line 226
      i ++;
    }
  }
#line 231
  key->lfsr17 = (unsigned int )(((int )key->seed[1] | ((int )key->seed[0] << 9)) | (1 << 8));
#line 234
  key->lfsr25 = (unsigned int )(((((int )key->seed[4] | ((int )key->seed[3] << 8)) | (((int )key->seed[2] & 31) << 16)) | (((int )key->seed[2] & 224) << 17)) | (1 << 21));
#line 240
  key->lfsrsum = 0U;
#line 241
  return;
}
}
#line 243 "acss.c"
void acss_setkey(ACSS_KEY *key , unsigned char const   *data , int enc , int mode ) 
{ 

  {
#line 246
  memcpy((void * __restrict  )(key->data), (void const   * __restrict  )data, sizeof(key->data));
#line 247
  memset((void *)(key->subkey), 0, sizeof(key->subkey));
#line 249
  if (enc != -1) {
#line 250
    key->encrypt = enc;
  }
#line 251
  key->mode = mode;
#line 252
  key->subkey_avilable = 0;
#line 254
  acss_seed(key);
#line 255
  return;
}
}
#line 257 "acss.c"
void acss_setsubkey(ACSS_KEY *key , unsigned char const   *subkey ) 
{ 

  {
#line 260
  memcpy((void * __restrict  )(key->subkey), (void const   * __restrict  )subkey,
         sizeof(key->subkey));
#line 261
  key->subkey_avilable = 1;
#line 262
  acss_seed(key);
#line 263
  return;
}
}
#line 1 "authfd.o"
#line 76 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 100 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 124
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 405 "/usr/include/openssl/bn.h"
extern int BN_num_bits(BIGNUM const   *a ) ;
#line 26 "buffer.h"
void buffer_init(Buffer *buffer ) ;
#line 27
void buffer_clear(Buffer *buffer ) ;
#line 28
void buffer_free(Buffer *buffer ) ;
#line 30
u_int buffer_len(Buffer *buffer ) ;
#line 31
void *buffer_ptr(Buffer *buffer ) ;
#line 33
void buffer_append(Buffer *buffer , void const   *data , u_int len ) ;
#line 21 "bufaux.h"
void buffer_put_bignum(Buffer *buffer , BIGNUM const   *value ) ;
#line 22
void buffer_put_bignum2(Buffer *buffer , BIGNUM const   *value ) ;
#line 23
void buffer_get_bignum(Buffer *buffer , BIGNUM *value ) ;
#line 29
u_int buffer_get_int(Buffer *buffer ) ;
#line 30
void buffer_put_int(Buffer *buffer , u_int value ) ;
#line 35
int buffer_get_char(Buffer *buffer ) ;
#line 36
void buffer_put_char(Buffer *buffer , int value ) ;
#line 38
void *buffer_get_string(Buffer *buffer , u_int *length_ptr ) ;
#line 39
void buffer_put_string(Buffer *buffer , void const   *buf___1 , u_int len ) ;
#line 40
void buffer_put_cstring(Buffer *buffer , char const   *s ) ;
#line 22 "xmalloc.h"
void *xmalloc(size_t size ) ;
#line 24
void xfree(void *ptr ) ;
#line 58 "key.h"
Key *key_new(int type ) ;
#line 74
Key *key_from_blob(u_char const   *blob , u_int blen ) ;
#line 75
int key_to_blob(Key const   *key , u_char **blobp , u_int *lenp ) ;
#line 76
char const   *key_ssh_name(Key const   *k ) ;
#line 71 "authfd.h"
int ssh_agent_present(void) ;
#line 72
int ssh_get_authentication_socket(void) ;
#line 73
void ssh_close_authentication_socket(int sock ) ;
#line 75
AuthenticationConnection *ssh_get_authentication_connection(void) ;
#line 76
void ssh_close_authentication_connection(AuthenticationConnection *auth ) ;
#line 77
int ssh_get_num_identities(AuthenticationConnection *auth , int version ) ;
#line 78
Key *ssh_get_first_identity(AuthenticationConnection *auth , char **comment , int version ) ;
#line 79
Key *ssh_get_next_identity(AuthenticationConnection *auth , char **comment , int version ) ;
#line 80
int ssh_add_identity(AuthenticationConnection *auth , Key *key , char const   *comment ) ;
#line 81
int ssh_add_identity_constrained(AuthenticationConnection *auth , Key *key , char const   *comment ,
                                 u_int life , u_int confirm ) ;
#line 83
int ssh_remove_identity(AuthenticationConnection *auth , Key *key ) ;
#line 84
int ssh_remove_all_identities(AuthenticationConnection *auth , int version ) ;
#line 85
int ssh_lock_agent(AuthenticationConnection *auth , int lock , char const   *password ) ;
#line 86
int ssh_update_card(AuthenticationConnection *auth , int add , char const   *reader_id ,
                    char const   *pin , u_int life , u_int confirm ) ;
#line 89
int ssh_decrypt_challenge(AuthenticationConnection *auth , Key *key , BIGNUM *challenge ,
                          u_char *session_id___0 , u_int response_type , u_char *response ) ;
#line 93
int ssh_agent_sign(AuthenticationConnection *auth , Key *key , u_char **sigp , u_int *lenp ,
                   u_char *data , u_int datalen ) ;
#line 67 "compat.h"
int datafellows ;
#line 57 "log.h"
void ( /* format attribute */  error)(char const   *fmt  , ...) ;
#line 58
void ( /* format attribute */  logit)(char const   *fmt  , ...) ;
#line 31 "atomicio.h"
ssize_t atomicio(ssize_t (*f)(int  , void * , size_t  ) , int fd , void *_s , size_t n___0 ) ;
#line 56 "authfd.c"
static int agent_present  =    0;
#line 59
int decode_reply(int type ) ;
#line 66 "authfd.c"
int ssh_agent_present(void) 
{ int authfd ;

  {
#line 71
  if (agent_present) {
#line 72
    return (1);
  }
#line 73
  authfd = ssh_get_authentication_socket();
#line 73
  if (authfd == -1) {
#line 74
    return (0);
  } else {
#line 76
    ssh_close_authentication_socket(authfd);
#line 77
    return (1);
  }
}
}
#line 83 "authfd.c"
int ssh_get_authentication_socket(void) 
{ char const   *authsocket ;
  int sock ;
  struct sockaddr_un sunaddr ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 90
  tmp = getenv("SSH_AUTH_SOCK");
#line 90
  authsocket = (char const   *)tmp;
#line 91
  if (! authsocket) {
#line 92
    return (-1);
  }
#line 94
  sunaddr.sun_family = (unsigned short)1;
#line 95
  strlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));
#line 97
  sock = socket(1, 1, 0);
#line 98
  if (sock < 0) {
#line 99
    return (-1);
  }
#line 102
  tmp___0 = fcntl(sock, 2, 1);
#line 102
  if (tmp___0 == -1) {
#line 103
    close(sock);
#line 104
    return (-1);
  }
#line 106
  tmp___1 = connect(sock, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& sunaddr)),
                    sizeof(sunaddr));
#line 106
  if (tmp___1 < 0) {
#line 107
    close(sock);
#line 108
    return (-1);
  }
#line 110
  agent_present = 1;
#line 111
  return (sock);
}
}
#line 114 "authfd.c"
static int ssh_request_reply(AuthenticationConnection *auth , Buffer *request , Buffer *reply ) 
{ int l ;
  u_int len ;
  char buf___1[1024] ;
  ssize_t tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  ssize_t tmp___2 ;
  u_int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;

  {
#line 122
  len = buffer_len(request);
#line 123
  while (1) {
#line 123
    buf___1[0] = (char )(len >> 24);
#line 123
    buf___1[1] = (char )(len >> 16);
#line 123
    buf___1[2] = (char )(len >> 8);
#line 123
    buf___1[3] = (char )len;
#line 123
    break;
  }
#line 126
  tmp = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), auth->fd, (void *)(buf___1),
                 4U);
#line 126
  if (tmp != 4) {
#line 129
    error("Error writing to authentication socket.");
#line 130
    return (0);
  } else {
#line 126
    tmp___0 = buffer_len(request);
#line 126
    tmp___1 = buffer_ptr(request);
#line 126
    tmp___2 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), auth->fd,
                       tmp___1, tmp___0);
#line 126
    tmp___3 = buffer_len(request);
#line 126
    if ((u_int )tmp___2 != tmp___3) {
#line 129
      error("Error writing to authentication socket.");
#line 130
      return (0);
    }
  }
#line 136
  len = 4U;
#line 137
  while (len > 0U) {
#line 138
    l = read(auth->fd, (void *)((buf___1 + 4) - len), len);
#line 139
    if (l == -1) {
#line 139
      tmp___4 = __errno_location();
#line 139
      if (*tmp___4 == 11) {
#line 140
        continue;
      } else {
#line 139
        tmp___5 = __errno_location();
#line 139
        if (*tmp___5 == 4) {
#line 140
          continue;
        }
      }
    }
#line 141
    if (l <= 0) {
#line 142
      error("Error reading response length from authentication socket.");
#line 143
      return (0);
    }
#line 145
    len -= (u_int )l;
  }
#line 149
  len = (unsigned int )(((((unsigned long )((unsigned char )buf___1[0]) << 24) | ((unsigned long )((unsigned char )buf___1[1]) << 16)) | ((unsigned long )((unsigned char )buf___1[2]) << 8)) | (unsigned long )((unsigned char )buf___1[3]));
#line 150
  if (len > 262144U) {
#line 151
    fatal("Authentication response too long: %u", len);
  }
#line 154
  buffer_clear(reply);
#line 155
  while (len > 0U) {
#line 156
    l = (int )len;
#line 157
    if ((unsigned int )l > sizeof(buf___1)) {
#line 158
      l = (int )sizeof(buf___1);
    }
#line 159
    l = read(auth->fd, (void *)(buf___1), (unsigned int )l);
#line 160
    if (l == -1) {
#line 160
      tmp___6 = __errno_location();
#line 160
      if (*tmp___6 == 11) {
#line 161
        continue;
      } else {
#line 160
        tmp___7 = __errno_location();
#line 160
        if (*tmp___7 == 4) {
#line 161
          continue;
        }
      }
    }
#line 162
    if (l <= 0) {
#line 163
      error("Error reading response from authentication socket.");
#line 164
      return (0);
    }
#line 166
    buffer_append(reply, (void const   *)(buf___1), (unsigned int )l);
#line 167
    len -= (u_int )l;
  }
#line 169
  return (1);
}
}
#line 178 "authfd.c"
void ssh_close_authentication_socket(int sock ) 
{ char *tmp ;

  {
#line 181
  tmp = getenv("SSH_AUTH_SOCK");
#line 181
  if (tmp) {
#line 182
    close(sock);
  }
#line 183
  return;
}
}
#line 193 "authfd.c"
AuthenticationConnection *ssh_get_authentication_connection(void) 
{ AuthenticationConnection *auth ;
  int sock ;
  void *tmp ;

  {
#line 199
  sock = ssh_get_authentication_socket();
#line 205
  if (sock < 0) {
#line 206
    return ((AuthenticationConnection *)((void *)0));
  }
#line 208
  tmp = xmalloc(sizeof(*auth));
#line 208
  auth = (AuthenticationConnection *)tmp;
#line 209
  auth->fd = sock;
#line 210
  buffer_init(& auth->identities);
#line 211
  auth->howmany = 0;
#line 213
  return (auth);
}
}
#line 221 "authfd.c"
void ssh_close_authentication_connection(AuthenticationConnection *auth ) 
{ 

  {
#line 224
  buffer_free(& auth->identities);
#line 225
  close(auth->fd);
#line 226
  xfree((void *)auth);
#line 227
  return;
}
}
#line 230 "authfd.c"
int ssh_lock_agent(AuthenticationConnection *auth , int lock , char const   *password ) 
{ int type ;
  Buffer msg ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 236
  buffer_init(& msg);
#line 237
  if (lock) {
#line 237
    tmp = 22;
  } else {
#line 237
    tmp = 23;
  }
#line 237
  buffer_put_char(& msg, tmp);
#line 238
  buffer_put_cstring(& msg, password);
#line 240
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 240
  if (tmp___0 == 0) {
#line 241
    buffer_free(& msg);
#line 242
    return (0);
  }
#line 244
  type = buffer_get_char(& msg);
#line 245
  buffer_free(& msg);
#line 246
  tmp___1 = decode_reply(type);
#line 246
  return (tmp___1);
}
}
#line 253 "authfd.c"
int ssh_get_num_identities(AuthenticationConnection *auth , int version ) 
{ int type ;
  int code1 ;
  int code2 ;
  Buffer request ;
  int tmp ;
  u_int tmp___0 ;

  {
#line 256
  code1 = 0;
#line 256
  code2 = 0;
#line 259
  switch (version) {
  case 1: 
#line 261
  code1 = 1;
#line 262
  code2 = 2;
#line 263
  break;
  case 2: 
#line 265
  code1 = 11;
#line 266
  code2 = 12;
#line 267
  break;
  default: ;
#line 269
  return (0);
  }
#line 276
  buffer_init(& request);
#line 277
  buffer_put_char(& request, code1);
#line 279
  buffer_clear(& auth->identities);
#line 280
  tmp = ssh_request_reply(auth, & request, & auth->identities);
#line 280
  if (tmp == 0) {
#line 281
    buffer_free(& request);
#line 282
    return (0);
  }
#line 284
  buffer_free(& request);
#line 287
  type = buffer_get_char(& auth->identities);
#line 288
  if (type == 5) {
#line 289
    return (0);
  } else {
#line 288
    if (type == 102) {
#line 289
      return (0);
    } else {
#line 288
      if (type == 30) {
#line 289
        return (0);
      } else {
#line 290
        if (type != code2) {
#line 291
          fatal("Bad authentication reply message type: %d", type);
        }
      }
    }
  }
#line 295
  tmp___0 = buffer_get_int(& auth->identities);
#line 295
  auth->howmany = (int )tmp___0;
#line 296
  if ((unsigned int )auth->howmany > 1024U) {
#line 297
    fatal("Too many identities in authentication reply: %d", auth->howmany);
  }
#line 300
  return (auth->howmany);
}
}
#line 303 "authfd.c"
Key *ssh_get_first_identity(AuthenticationConnection *auth , char **comment , int version ) 
{ Key *tmp ;
  int tmp___0 ;

  {
#line 307
  tmp___0 = ssh_get_num_identities(auth, version);
#line 307
  if (tmp___0 > 0) {
#line 308
    tmp = ssh_get_next_identity(auth, comment, version);
#line 308
    return (tmp);
  }
#line 309
  return ((Key *)((void *)0));
}
}
#line 312 "authfd.c"
Key *ssh_get_next_identity(AuthenticationConnection *auth , char **comment , int version ) 
{ u_int bits ;
  u_char *blob ;
  u_int blen ;
  Key *key ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 318
  key = (Key *)((void *)0);
#line 321
  if (auth->howmany <= 0) {
#line 322
    return ((Key *)((void *)0));
  }
#line 328
  switch (version) {
  case 1: 
#line 330
  key = key_new(0);
#line 331
  bits = buffer_get_int(& auth->identities);
#line 332
  buffer_get_bignum(& auth->identities, (key->rsa)->e);
#line 333
  buffer_get_bignum(& auth->identities, (key->rsa)->n);
#line 334
  tmp = buffer_get_string(& auth->identities, (u_int *)((void *)0));
#line 334
  *comment = (char *)tmp;
#line 335
  tmp___1 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 335
  if (bits != (u_int )tmp___1) {
#line 336
    tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 336
    logit("Warning: identity keysize mismatch: actual %d, announced %u", tmp___0,
          bits);
  }
#line 338
  break;
  case 2: 
#line 340
  tmp___2 = buffer_get_string(& auth->identities, & blen);
#line 340
  blob = (u_char *)tmp___2;
#line 341
  tmp___3 = buffer_get_string(& auth->identities, (u_int *)((void *)0));
#line 341
  *comment = (char *)tmp___3;
#line 342
  key = key_from_blob((u_char const   *)blob, blen);
#line 343
  xfree((void *)blob);
#line 344
  break;
  default: ;
#line 346
  return ((Key *)((void *)0));
#line 347
  break;
  }
#line 350
  (auth->howmany) --;
#line 351
  return (key);
}
}
#line 362 "authfd.c"
int ssh_decrypt_challenge(AuthenticationConnection *auth , Key *key , BIGNUM *challenge ,
                          u_char *session_id___0 , u_int response_type , u_char *response ) 
{ Buffer buffer ;
  int success ;
  int i ;
  int type ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 370
  success = 0;
#line 374
  if (key->type != 0) {
#line 375
    return (0);
  }
#line 376
  if (response_type == 0U) {
#line 377
    logit("Compatibility with ssh protocol version 1.0 no longer supported.");
#line 378
    return (0);
  }
#line 380
  buffer_init(& buffer);
#line 381
  buffer_put_char(& buffer, 3);
#line 382
  tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 382
  buffer_put_int(& buffer, (unsigned int )tmp);
#line 383
  buffer_put_bignum(& buffer, (BIGNUM const   *)(key->rsa)->e);
#line 384
  buffer_put_bignum(& buffer, (BIGNUM const   *)(key->rsa)->n);
#line 385
  buffer_put_bignum(& buffer, (BIGNUM const   *)challenge);
#line 386
  buffer_append(& buffer, (void const   *)session_id___0, 16U);
#line 387
  buffer_put_int(& buffer, response_type);
#line 389
  tmp___0 = ssh_request_reply(auth, & buffer, & buffer);
#line 389
  if (tmp___0 == 0) {
#line 390
    buffer_free(& buffer);
#line 391
    return (0);
  }
#line 393
  type = buffer_get_char(& buffer);
#line 395
  if (type == 5) {
#line 396
    logit("Agent admitted failure to authenticate using the key.");
  } else {
#line 395
    if (type == 102) {
#line 396
      logit("Agent admitted failure to authenticate using the key.");
    } else {
#line 395
      if (type == 30) {
#line 396
        logit("Agent admitted failure to authenticate using the key.");
      } else {
#line 397
        if (type != 4) {
#line 398
          fatal("Bad authentication response: %d", type);
        } else {
#line 400
          success = 1;
#line 405
          i = 0;
#line 405
          while (i < 16) {
#line 406
            tmp___1 = buffer_get_char(& buffer);
#line 406
            *(response + i) = (unsigned char )tmp___1;
#line 405
            i ++;
          }
        }
      }
    }
  }
#line 408
  buffer_free(& buffer);
#line 409
  return (success);
}
}
#line 413 "authfd.c"
int ssh_agent_sign(AuthenticationConnection *auth , Key *key , u_char **sigp , u_int *lenp ,
                   u_char *data , u_int datalen ) 
{ Buffer msg ;
  u_char *blob ;
  u_int blen ;
  int type ;
  int flags ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 423
  flags = 0;
#line 424
  ret = -1;
#line 426
  tmp = key_to_blob((Key const   *)key, & blob, & blen);
#line 426
  if (tmp == 0) {
#line 427
    return (-1);
  }
#line 429
  if (datafellows & 1) {
#line 430
    flags = 1;
  }
#line 432
  buffer_init(& msg);
#line 433
  buffer_put_char(& msg, 13);
#line 434
  buffer_put_string(& msg, (void const   *)blob, blen);
#line 435
  buffer_put_string(& msg, (void const   *)data, datalen);
#line 436
  buffer_put_int(& msg, (unsigned int )flags);
#line 437
  xfree((void *)blob);
#line 439
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 439
  if (tmp___0 == 0) {
#line 440
    buffer_free(& msg);
#line 441
    return (-1);
  }
#line 443
  type = buffer_get_char(& msg);
#line 444
  if (type == 5) {
#line 445
    logit("Agent admitted failure to sign using the key.");
  } else {
#line 444
    if (type == 102) {
#line 445
      logit("Agent admitted failure to sign using the key.");
    } else {
#line 444
      if (type == 30) {
#line 445
        logit("Agent admitted failure to sign using the key.");
      } else {
#line 446
        if (type != 14) {
#line 447
          fatal("Bad authentication response: %d", type);
        } else {
#line 449
          ret = 0;
#line 450
          tmp___1 = buffer_get_string(& msg, lenp);
#line 450
          *sigp = (u_char *)tmp___1;
        }
      }
    }
  }
#line 452
  buffer_free(& msg);
#line 453
  return (ret);
}
}
#line 458 "authfd.c"
static void ssh_encode_identity_rsa1(Buffer *b , RSA *key , char const   *comment ) 
{ int tmp ;

  {
#line 461
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 461
  buffer_put_int(b, (unsigned int )tmp);
#line 462
  buffer_put_bignum(b, (BIGNUM const   *)key->n);
#line 463
  buffer_put_bignum(b, (BIGNUM const   *)key->e);
#line 464
  buffer_put_bignum(b, (BIGNUM const   *)key->d);
#line 466
  buffer_put_bignum(b, (BIGNUM const   *)key->iqmp);
#line 467
  buffer_put_bignum(b, (BIGNUM const   *)key->q);
#line 468
  buffer_put_bignum(b, (BIGNUM const   *)key->p);
#line 469
  buffer_put_cstring(b, comment);
#line 470
  return;
}
}
#line 472 "authfd.c"
static void ssh_encode_identity_ssh2(Buffer *b , Key *key , char const   *comment ) 
{ char const   *tmp ;

  {
#line 475
  tmp = key_ssh_name((Key const   *)key);
#line 475
  buffer_put_cstring(b, tmp);
#line 476
  switch (key->type) {
  case 1: 
#line 478
  buffer_put_bignum2(b, (BIGNUM const   *)(key->rsa)->n);
#line 479
  buffer_put_bignum2(b, (BIGNUM const   *)(key->rsa)->e);
#line 480
  buffer_put_bignum2(b, (BIGNUM const   *)(key->rsa)->d);
#line 481
  buffer_put_bignum2(b, (BIGNUM const   *)(key->rsa)->iqmp);
#line 482
  buffer_put_bignum2(b, (BIGNUM const   *)(key->rsa)->p);
#line 483
  buffer_put_bignum2(b, (BIGNUM const   *)(key->rsa)->q);
#line 484
  break;
  case 2: 
#line 486
  buffer_put_bignum2(b, (BIGNUM const   *)(key->dsa)->p);
#line 487
  buffer_put_bignum2(b, (BIGNUM const   *)(key->dsa)->q);
#line 488
  buffer_put_bignum2(b, (BIGNUM const   *)(key->dsa)->g);
#line 489
  buffer_put_bignum2(b, (BIGNUM const   *)(key->dsa)->pub_key);
#line 490
  buffer_put_bignum2(b, (BIGNUM const   *)(key->dsa)->priv_key);
#line 491
  break;
  }
#line 493
  buffer_put_cstring(b, comment);
#line 494
  return;
}
}
#line 501 "authfd.c"
int ssh_add_identity_constrained(AuthenticationConnection *auth , Key *key , char const   *comment ,
                                 u_int life , u_int confirm ) 
{ Buffer msg ;
  int type ;
  int constrained ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 506
  if (life) {
#line 506
    tmp = 1;
  } else {
#line 506
    if (confirm) {
#line 506
      tmp = 1;
    } else {
#line 506
      tmp = 0;
    }
  }
#line 506
  constrained = tmp;
#line 508
  buffer_init(& msg);
#line 510
  switch (key->type) {
  case 0: 
#line 512
  if (constrained) {
#line 512
    type = 24;
  } else {
#line 512
    type = 7;
  }
#line 515
  buffer_put_char(& msg, type);
#line 516
  ssh_encode_identity_rsa1(& msg, key->rsa, comment);
#line 517
  break;
  case 1: 
  case 2: 
#line 520
  if (constrained) {
#line 520
    type = 25;
  } else {
#line 520
    type = 17;
  }
#line 523
  buffer_put_char(& msg, type);
#line 524
  ssh_encode_identity_ssh2(& msg, key, comment);
#line 525
  break;
  default: 
#line 527
  buffer_free(& msg);
#line 528
  return (0);
#line 529
  break;
  }
#line 531
  if (constrained) {
#line 532
    if (life != 0U) {
#line 533
      buffer_put_char(& msg, 1);
#line 534
      buffer_put_int(& msg, life);
    }
#line 536
    if (confirm != 0U) {
#line 537
      buffer_put_char(& msg, 2);
    }
  }
#line 539
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 539
  if (tmp___0 == 0) {
#line 540
    buffer_free(& msg);
#line 541
    return (0);
  }
#line 543
  type = buffer_get_char(& msg);
#line 544
  buffer_free(& msg);
#line 545
  tmp___1 = decode_reply(type);
#line 545
  return (tmp___1);
}
}
#line 548 "authfd.c"
int ssh_add_identity(AuthenticationConnection *auth , Key *key , char const   *comment ) 
{ int tmp ;

  {
#line 551
  tmp = ssh_add_identity_constrained(auth, key, comment, 0U, 0U);
#line 551
  return (tmp);
}
}
#line 559 "authfd.c"
int ssh_remove_identity(AuthenticationConnection *auth , Key *key ) 
{ Buffer msg ;
  int type ;
  u_char *blob ;
  u_int blen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 567
  buffer_init(& msg);
#line 569
  if (key->type == 0) {
#line 570
    buffer_put_char(& msg, 8);
#line 571
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 571
    buffer_put_int(& msg, (unsigned int )tmp);
#line 572
    buffer_put_bignum(& msg, (BIGNUM const   *)(key->rsa)->e);
#line 573
    buffer_put_bignum(& msg, (BIGNUM const   *)(key->rsa)->n);
  } else {
#line 574
    if (key->type == 2) {
#line 575
      key_to_blob((Key const   *)key, & blob, & blen);
#line 576
      buffer_put_char(& msg, 18);
#line 577
      buffer_put_string(& msg, (void const   *)blob, blen);
#line 578
      xfree((void *)blob);
    } else {
#line 574
      if (key->type == 1) {
#line 575
        key_to_blob((Key const   *)key, & blob, & blen);
#line 576
        buffer_put_char(& msg, 18);
#line 577
        buffer_put_string(& msg, (void const   *)blob, blen);
#line 578
        xfree((void *)blob);
      } else {
#line 580
        buffer_free(& msg);
#line 581
        return (0);
      }
    }
  }
#line 583
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 583
  if (tmp___0 == 0) {
#line 584
    buffer_free(& msg);
#line 585
    return (0);
  }
#line 587
  type = buffer_get_char(& msg);
#line 588
  buffer_free(& msg);
#line 589
  tmp___1 = decode_reply(type);
#line 589
  return (tmp___1);
}
}
#line 592 "authfd.c"
int ssh_update_card(AuthenticationConnection *auth , int add , char const   *reader_id ,
                    char const   *pin , u_int life , u_int confirm ) 
{ Buffer msg ;
  int type ;
  int constrained ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 597
  if (life) {
#line 597
    tmp = 1;
  } else {
#line 597
    if (confirm) {
#line 597
      tmp = 1;
    } else {
#line 597
      tmp = 0;
    }
  }
#line 597
  constrained = tmp;
#line 599
  if (add) {
#line 600
    if (constrained) {
#line 600
      type = 26;
    } else {
#line 600
      type = 20;
    }
  } else {
#line 604
    type = 21;
  }
#line 606
  buffer_init(& msg);
#line 607
  buffer_put_char(& msg, type);
#line 608
  buffer_put_cstring(& msg, reader_id);
#line 609
  buffer_put_cstring(& msg, pin);
#line 611
  if (constrained) {
#line 612
    if (life != 0U) {
#line 613
      buffer_put_char(& msg, 1);
#line 614
      buffer_put_int(& msg, life);
    }
#line 616
    if (confirm != 0U) {
#line 617
      buffer_put_char(& msg, 2);
    }
  }
#line 620
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 620
  if (tmp___0 == 0) {
#line 621
    buffer_free(& msg);
#line 622
    return (0);
  }
#line 624
  type = buffer_get_char(& msg);
#line 625
  buffer_free(& msg);
#line 626
  tmp___1 = decode_reply(type);
#line 626
  return (tmp___1);
}
}
#line 634 "authfd.c"
int ssh_remove_all_identities(AuthenticationConnection *auth , int version ) 
{ Buffer msg ;
  int type ;
  int code ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 639
  if (version == 1) {
#line 639
    tmp = 9;
  } else {
#line 639
    tmp = 19;
  }
#line 639
  code = tmp;
#line 643
  buffer_init(& msg);
#line 644
  buffer_put_char(& msg, code);
#line 646
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 646
  if (tmp___0 == 0) {
#line 647
    buffer_free(& msg);
#line 648
    return (0);
  }
#line 650
  type = buffer_get_char(& msg);
#line 651
  buffer_free(& msg);
#line 652
  tmp___1 = decode_reply(type);
#line 652
  return (tmp___1);
}
}
#line 655 "authfd.c"
int decode_reply(int type ) 
{ 

  {
#line 658
  switch (type) {
  case 5: 
  case 102: 
  case 30: 
#line 662
  logit("SSH_AGENT_FAILURE");
#line 663
  return (0);
  case 6: 
#line 665
  return (1);
  default: 
#line 667
  fatal("Bad response from authentication agent: %d", type);
  }
#line 670
  return (0);
}
}
#line 1 "authfile.o"
#line 213 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 259
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 280
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 532
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 304 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off64_t lseek(int __fd , __off64_t __offset ,
                                                     int __whence )  __asm__("lseek64")  ;
#line 218 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64") __attribute__((__nonnull__(2))) ;
#line 391
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __asm__("__fxstat64") __attribute__((__nonnull__(3))) ;
#line 447
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64") __attribute__((__nonnull__(2))) ;
#line 447 "/usr/include/sys/stat.h"
__inline static int fstat(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
#line 450
  tmp = __fxstat(3, __fd, __statbuf);
#line 450
  return (tmp);
}
}
#line 639 "/usr/include/openssl/evp.h"
extern EVP_CIPHER const   *EVP_des_ede3_cbc(void) ;
#line 749
extern struct rsa_st *EVP_PKEY_get1_RSA(EVP_PKEY *pkey ) ;
#line 754
extern struct dsa_st *EVP_PKEY_get1_DSA(EVP_PKEY *pkey ) ;
#line 763
extern void EVP_PKEY_free(EVP_PKEY *pkey ) ;
#line 298 "/usr/include/openssl/rsa.h"
extern int RSA_blinding_on(RSA *rsa , BN_CTX *ctx ) ;
#line 616 "/usr/include/openssl/pem.h"
extern int PEM_write_RSAPrivateKey(FILE *fp , RSA *x , EVP_CIPHER const   *enc , unsigned char *kstr ,
                                   int klen , pem_password_cb *cb , void *u ) ;
#line 625
extern int PEM_write_DSAPrivateKey(FILE *fp , DSA *x , EVP_CIPHER const   *enc , unsigned char *kstr ,
                                   int klen , pem_password_cb *cb , void *u ) ;
#line 640
extern EVP_PKEY *PEM_read_PrivateKey(FILE *fp , EVP_PKEY **x , pem_password_cb *cb ,
                                     void *u ) ;
#line 73 "cipher.h"
Cipher *cipher_by_number(int id ) ;
#line 79
void cipher_crypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) ;
#line 80
void cipher_cleanup(CipherContext *cc ) ;
#line 81
void cipher_set_key_string(CipherContext *cc , Cipher *cipher , char const   *passphrase ,
                           int encrypt ) ;
#line 34 "buffer.h"
void *buffer_append_space(Buffer *buffer , u_int len ) ;
#line 59 "key.h"
Key *key_new_private(int type ) ;
#line 60
void key_free(Key *k ) ;
#line 65
char const   *key_type(Key const   *k ) ;
#line 67
int key_read(Key *ret , char **cpp ) ;
#line 60 "log.h"
void ( /* format attribute */  debug)(char const   *fmt  , ...) ;
#line 62
void ( /* format attribute */  debug3)(char const   *fmt  , ...) ;
#line 18 "authfile.h"
int key_save_private(Key *key , char const   *filename , char const   *passphrase ,
                     char const   *comment ) ;
#line 19
Key *key_load_public(char const   *filename , char **commentp ) ;
#line 20
Key *key_load_public_type(int type , char const   *filename , char **commentp ) ;
#line 21
Key *key_load_private(char const   *filename , char const   *passphrase , char **commentp ) ;
#line 22
Key *key_load_private_type(int type , char const   *filename , char const   *passphrase ,
                           char **commentp ) ;
#line 23
Key *key_load_private_pem(int fd , int type , char const   *passphrase , char **commentp ) ;
#line 24 "rsa.h"
void rsa_generate_additional_parameters(RSA *rsa ) ;
#line 56 "authfile.c"
static char const   authfile_id_string[33]  = 
#line 56 "authfile.c"
  {      (char const   )'S',      (char const   )'S',      (char const   )'H',      (char const   )' ', 
        (char const   )'P',      (char const   )'R',      (char const   )'I',      (char const   )'V', 
        (char const   )'A',      (char const   )'T',      (char const   )'E',      (char const   )' ', 
        (char const   )'K',      (char const   )'E',      (char const   )'Y',      (char const   )' ', 
        (char const   )'F',      (char const   )'I',      (char const   )'L',      (char const   )'E', 
        (char const   )' ',      (char const   )'F',      (char const   )'O',      (char const   )'R', 
        (char const   )'M',      (char const   )'A',      (char const   )'T',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )'\n', 
        (char const   )'\000'};
#line 66 "authfile.c"
static int key_save_private_rsa1(Key *key , char const   *filename , char const   *passphrase ,
                                 char const   *comment ) 
{ Buffer buffer ;
  Buffer encrypted ;
  u_char buf___1[100] ;
  u_char *cp ;
  int fd ;
  int i ;
  int cipher_num ;
  CipherContext ciphercontext ;
  Cipher *cipher ;
  u_int32_t rand___0 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  u_int tmp___19 ;
  int tmp___20 ;
  u_int tmp___21 ;
  void *tmp___22 ;
  u_int tmp___23 ;
  void *tmp___24 ;
  int *tmp___25 ;
  char *tmp___26 ;
  int *tmp___27 ;
  char *tmp___28 ;
  u_int tmp___29 ;
  void *tmp___30 ;
  ssize_t tmp___31 ;
  u_int tmp___32 ;

  {
#line 81
  if (0) {
#line 81
    __s1_len___0 = strlen(passphrase);
#line 81
    __s2_len___0 = strlen("");
#line 81
    if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
      goto _L___2;
    } else {
#line 81
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 81
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 81
          tmp___18 = 1;
        } else {
#line 81
          if (__s2_len___0 >= 4U) {
#line 81
            tmp___18 = 1;
          } else {
#line 81
            tmp___18 = 0;
          }
        }
      } else {
#line 81
        tmp___18 = 0;
      }
    }
#line 81
    if (tmp___18) {
#line 81
      tmp___14 = __builtin_strcmp(passphrase, "");
    } else {
#line 81
      tmp___17 = __builtin_strcmp(passphrase, "");
#line 81
      tmp___14 = tmp___17;
    }
  } else {
#line 81
    tmp___17 = __builtin_strcmp(passphrase, "");
#line 81
    tmp___14 = tmp___17;
  }
#line 81
  if (tmp___14 == 0) {
#line 81
    cipher_num = 0;
  } else {
#line 81
    cipher_num = 3;
  }
#line 83
  cipher = cipher_by_number(cipher_num);
#line 83
  if ((unsigned int )cipher == (unsigned int )((void *)0)) {
#line 84
    fatal("save_private_key_rsa: bad cipher");
  }
#line 87
  buffer_init(& buffer);
#line 90
  rand___0 = arc4random();
#line 91
  buf___1[0] = (unsigned char )(rand___0 & 255U);
#line 92
  buf___1[1] = (unsigned char )((rand___0 >> 8) & 255U);
#line 93
  buf___1[2] = buf___1[0];
#line 94
  buf___1[3] = buf___1[1];
#line 95
  buffer_append(& buffer, (void const   *)(buf___1), 4U);
#line 102
  buffer_put_bignum(& buffer, (BIGNUM const   *)(key->rsa)->d);
#line 103
  buffer_put_bignum(& buffer, (BIGNUM const   *)(key->rsa)->iqmp);
#line 104
  buffer_put_bignum(& buffer, (BIGNUM const   *)(key->rsa)->q);
#line 105
  buffer_put_bignum(& buffer, (BIGNUM const   *)(key->rsa)->p);
#line 108
  while (1) {
#line 108
    tmp___19 = buffer_len(& buffer);
#line 108
    if (! (tmp___19 % 8U != 0U)) {
#line 108
      break;
    }
#line 109
    buffer_put_char(& buffer, 0);
  }
#line 112
  buffer_init(& encrypted);
#line 115
  i = 0;
#line 115
  while (authfile_id_string[i]) {
#line 116
    buffer_put_char(& encrypted, (int )authfile_id_string[i]);
#line 115
    i ++;
  }
#line 117
  buffer_put_char(& encrypted, 0);
#line 120
  buffer_put_char(& encrypted, cipher_num);
#line 121
  buffer_put_int(& encrypted, 0U);
#line 124
  tmp___20 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 124
  buffer_put_int(& encrypted, (unsigned int )tmp___20);
#line 125
  buffer_put_bignum(& encrypted, (BIGNUM const   *)(key->rsa)->n);
#line 126
  buffer_put_bignum(& encrypted, (BIGNUM const   *)(key->rsa)->e);
#line 127
  buffer_put_cstring(& encrypted, comment);
#line 130
  tmp___21 = buffer_len(& buffer);
#line 130
  tmp___22 = buffer_append_space(& encrypted, tmp___21);
#line 130
  cp = (u_char *)tmp___22;
#line 132
  cipher_set_key_string(& ciphercontext, cipher, passphrase, 1);
#line 134
  tmp___23 = buffer_len(& buffer);
#line 134
  tmp___24 = buffer_ptr(& buffer);
#line 134
  cipher_crypt(& ciphercontext, cp, (u_char const   *)tmp___24, tmp___23);
#line 136
  cipher_cleanup(& ciphercontext);
#line 137
  memset((void *)(& ciphercontext), 0, sizeof(ciphercontext));
#line 140
  memset((void *)(buf___1), 0, sizeof(buf___1));
#line 141
  buffer_free(& buffer);
#line 143
  fd = open(filename, 577, 384);
#line 144
  if (fd < 0) {
#line 145
    tmp___25 = __errno_location();
#line 145
    tmp___26 = strerror(*tmp___25);
#line 145
    error("open %s failed: %s.", filename, tmp___26);
#line 146
    buffer_free(& encrypted);
#line 147
    return (0);
  }
#line 149
  tmp___29 = buffer_len(& encrypted);
#line 149
  tmp___30 = buffer_ptr(& encrypted);
#line 149
  tmp___31 = write(fd, (void const   *)tmp___30, tmp___29);
#line 149
  tmp___32 = buffer_len(& encrypted);
#line 149
  if ((u_int )tmp___31 != tmp___32) {
#line 151
    tmp___27 = __errno_location();
#line 151
    tmp___28 = strerror(*tmp___27);
#line 151
    error("write to key file %s failed: %s", filename, tmp___28);
#line 153
    buffer_free(& encrypted);
#line 154
    close(fd);
#line 155
    unlink(filename);
#line 156
    return (0);
  }
#line 158
  close(fd);
#line 159
  buffer_free(& encrypted);
#line 160
  return (1);
}
}
#line 164 "authfile.c"
static int key_save_private_pem(Key *key , char const   *filename , char const   *_passphrase ,
                                char const   *comment ) 
{ FILE *fp ;
  int fd ;
  int success ;
  int len ;
  size_t tmp ;
  u_char *passphrase ;
  u_char *tmp___0 ;
  EVP_CIPHER const   *cipher ;
  EVP_CIPHER const   *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
#line 170
  success = 0;
#line 171
  tmp = strlen(_passphrase);
#line 171
  len = (int )tmp;
#line 172
  if (len > 0) {
#line 172
    tmp___0 = (u_char *)_passphrase;
  } else {
#line 172
    tmp___0 = (u_char *)((void *)0);
  }
#line 172
  passphrase = tmp___0;
#line 173
  if (len > 0) {
#line 173
    tmp___2 = EVP_des_ede3_cbc();
  } else {
#line 173
    tmp___2 = (EVP_CIPHER const   *)((void *)0);
  }
#line 173
  cipher = tmp___2;
#line 175
  if (len > 0) {
#line 175
    if (len <= 4) {
#line 176
      error("passphrase too short: have %d bytes, need > 4", len);
#line 177
      return (0);
    }
  }
#line 179
  fd = open(filename, 577, 384);
#line 180
  if (fd < 0) {
#line 181
    tmp___3 = __errno_location();
#line 181
    tmp___4 = strerror(*tmp___3);
#line 181
    error("open %s failed: %s.", filename, tmp___4);
#line 182
    return (0);
  }
#line 184
  fp = fdopen(fd, "w");
#line 185
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 186
    tmp___5 = __errno_location();
#line 186
    tmp___6 = strerror(*tmp___5);
#line 186
    error("fdopen %s failed: %s.", filename, tmp___6);
#line 187
    close(fd);
#line 188
    return (0);
  }
#line 190
  switch (key->type) {
  case 2: 
#line 192
  success = PEM_write_DSAPrivateKey(fp, key->dsa, cipher, passphrase, len, (pem_password_cb *)((void *)0),
                                    (void *)0);
#line 194
  break;
  case 1: 
#line 196
  success = PEM_write_RSAPrivateKey(fp, key->rsa, cipher, passphrase, len, (pem_password_cb *)((void *)0),
                                    (void *)0);
#line 198
  break;
  }
#line 200
  fclose(fp);
#line 201
  return (success);
}
}
#line 204 "authfile.c"
int key_save_private(Key *key , char const   *filename , char const   *passphrase ,
                     char const   *comment ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 208
  switch (key->type) {
  case 0: 
#line 210
  tmp = key_save_private_rsa1(key, filename, passphrase, comment);
#line 210
  return (tmp);
#line 212
  break;
  case 2: 
  case 1: 
#line 215
  tmp___0 = key_save_private_pem(key, filename, passphrase, comment);
#line 215
  return (tmp___0);
#line 217
  break;
  default: ;
#line 219
  break;
  }
#line 221
  error("key_save_private: cannot save key type %d", key->type);
#line 222
  return (0);
}
}
#line 231 "authfile.c"
static Key *key_load_public_rsa1(int fd , char const   *filename , char **commentp ) 
{ Buffer buffer ;
  Key *pub ;
  struct stat st ;
  char *cp ;
  int i ;
  off_t len ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  ssize_t tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;

  {
#line 241
  tmp___1 = fstat(fd, & st);
#line 241
  if (tmp___1 < 0) {
#line 242
    tmp = __errno_location();
#line 242
    tmp___0 = strerror(*tmp);
#line 242
    error("fstat for key file %.200s failed: %.100s", filename, tmp___0);
#line 244
    return ((Key *)((void *)0));
  }
#line 246
  len = st.st_size;
#line 248
  buffer_init(& buffer);
#line 249
  tmp___2 = buffer_append_space(& buffer, (unsigned int )len);
#line 249
  cp = (char *)tmp___2;
#line 251
  tmp___5 = read(fd, (void *)cp, (unsigned int )len);
#line 251
  if ((unsigned int )tmp___5 != (unsigned int )len) {
#line 252
    tmp___3 = __errno_location();
#line 252
    tmp___4 = strerror(*tmp___3);
#line 252
    debug("Read from key file %.200s failed: %.100s", filename, tmp___4);
#line 254
    buffer_free(& buffer);
#line 255
    return ((Key *)((void *)0));
  }
#line 259
  if (len < (off_t )sizeof(authfile_id_string)) {
#line 260
    debug3("Not a RSA1 key file %.200s.", filename);
#line 261
    buffer_free(& buffer);
#line 262
    return ((Key *)((void *)0));
  }
#line 268
  i = 0;
#line 268
  while ((unsigned int )i < sizeof(authfile_id_string)) {
#line 269
    tmp___6 = buffer_get_char(& buffer);
#line 269
    if (tmp___6 != (int )authfile_id_string[i]) {
#line 270
      debug3("Not a RSA1 key file %.200s.", filename);
#line 271
      buffer_free(& buffer);
#line 272
      return ((Key *)((void *)0));
    }
#line 268
    i ++;
  }
#line 275
  buffer_get_char(& buffer);
#line 276
  buffer_get_int(& buffer);
#line 279
  buffer_get_int(& buffer);
#line 280
  pub = key_new(0);
#line 281
  buffer_get_bignum(& buffer, (pub->rsa)->n);
#line 282
  buffer_get_bignum(& buffer, (pub->rsa)->e);
#line 283
  if (commentp) {
#line 284
    tmp___7 = buffer_get_string(& buffer, (u_int *)((void *)0));
#line 284
    *commentp = (char *)tmp___7;
  }
#line 287
  buffer_free(& buffer);
#line 288
  return (pub);
}
}
#line 292 "authfile.c"
Key *key_load_public_type(int type , char const   *filename , char **commentp ) 
{ Key *pub ;
  int fd ;

  {
#line 298
  if (type == 0) {
#line 299
    fd = open(filename, 0);
#line 300
    if (fd < 0) {
#line 301
      return ((Key *)((void *)0));
    }
#line 302
    pub = key_load_public_rsa1(fd, filename, commentp);
#line 303
    close(fd);
#line 304
    return (pub);
  }
#line 306
  return ((Key *)((void *)0));
}
}
#line 316 "authfile.c"
static Key *key_load_private_rsa1(int fd , char const   *filename , char const   *passphrase ,
                                  char **commentp ) 
{ int i ;
  int check1 ;
  int check2 ;
  int cipher_type ;
  off_t len ;
  Buffer buffer ;
  Buffer decrypted ;
  u_char *cp ;
  CipherContext ciphercontext ;
  Cipher *cipher ;
  Key *prv ;
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  ssize_t tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  u_int tmp___9 ;
  void *tmp___10 ;
  u_int tmp___11 ;
  void *tmp___12 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;

  {
#line 326
  prv = (Key *)((void *)0);
#line 329
  tmp___1 = fstat(fd, & st);
#line 329
  if (tmp___1 < 0) {
#line 330
    tmp = __errno_location();
#line 330
    tmp___0 = strerror(*tmp);
#line 330
    error("fstat for key file %.200s failed: %.100s", filename, tmp___0);
#line 332
    close(fd);
#line 333
    return ((Key *)((void *)0));
  }
#line 335
  len = st.st_size;
#line 337
  buffer_init(& buffer);
#line 338
  tmp___2 = buffer_append_space(& buffer, (unsigned int )len);
#line 338
  cp = (u_char *)tmp___2;
#line 340
  tmp___5 = read(fd, (void *)cp, (unsigned int )len);
#line 340
  if ((unsigned int )tmp___5 != (unsigned int )len) {
#line 341
    tmp___3 = __errno_location();
#line 341
    tmp___4 = strerror(*tmp___3);
#line 341
    debug("Read from key file %.200s failed: %.100s", filename, tmp___4);
#line 343
    buffer_free(& buffer);
#line 344
    close(fd);
#line 345
    return ((Key *)((void *)0));
  }
#line 349
  if (len < (off_t )sizeof(authfile_id_string)) {
#line 350
    debug3("Not a RSA1 key file %.200s.", filename);
#line 351
    buffer_free(& buffer);
#line 352
    close(fd);
#line 353
    return ((Key *)((void *)0));
  }
#line 359
  i = 0;
#line 359
  while ((unsigned int )i < sizeof(authfile_id_string)) {
#line 360
    tmp___6 = buffer_get_char(& buffer);
#line 360
    if (tmp___6 != (int )authfile_id_string[i]) {
#line 361
      debug3("Not a RSA1 key file %.200s.", filename);
#line 362
      buffer_free(& buffer);
#line 363
      close(fd);
#line 364
      return ((Key *)((void *)0));
    }
#line 359
    i ++;
  }
#line 368
  cipher_type = buffer_get_char(& buffer);
#line 369
  buffer_get_int(& buffer);
#line 372
  buffer_get_int(& buffer);
#line 373
  prv = key_new_private(0);
#line 375
  buffer_get_bignum(& buffer, (prv->rsa)->n);
#line 376
  buffer_get_bignum(& buffer, (prv->rsa)->e);
#line 377
  if (commentp) {
#line 378
    tmp___7 = buffer_get_string(& buffer, (u_int *)((void *)0));
#line 378
    *commentp = (char *)tmp___7;
  } else {
#line 380
    tmp___8 = buffer_get_string(& buffer, (u_int *)((void *)0));
#line 380
    xfree(tmp___8);
  }
#line 383
  cipher = cipher_by_number(cipher_type);
#line 384
  if ((unsigned int )cipher == (unsigned int )((void *)0)) {
#line 385
    debug("Unsupported cipher %d used in key file %.200s.", cipher_type, filename);
#line 387
    buffer_free(& buffer);
    goto fail;
  }
#line 391
  buffer_init(& decrypted);
#line 392
  tmp___9 = buffer_len(& buffer);
#line 392
  tmp___10 = buffer_append_space(& decrypted, tmp___9);
#line 392
  cp = (u_char *)tmp___10;
#line 395
  cipher_set_key_string(& ciphercontext, cipher, passphrase, 0);
#line 397
  tmp___11 = buffer_len(& buffer);
#line 397
  tmp___12 = buffer_ptr(& buffer);
#line 397
  cipher_crypt(& ciphercontext, cp, (u_char const   *)tmp___12, tmp___11);
#line 399
  cipher_cleanup(& ciphercontext);
#line 400
  memset((void *)(& ciphercontext), 0, sizeof(ciphercontext));
#line 401
  buffer_free(& buffer);
#line 403
  check1 = buffer_get_char(& decrypted);
#line 404
  check2 = buffer_get_char(& decrypted);
#line 405
  tmp___23 = buffer_get_char(& decrypted);
#line 405
  if (check1 != tmp___23) {
    goto _L___1;
  } else {
#line 405
    tmp___24 = buffer_get_char(& decrypted);
#line 405
    if (check2 != tmp___24) {
      _L___1: /* CIL Label */ 
#line 407
      if (0) {
#line 407
        __s1_len = strlen(passphrase);
#line 407
        __s2_len = strlen("");
#line 407
        if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
          goto _L___0;
        } else {
#line 407
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 407
            if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 407
              tmp___22 = 1;
            } else {
#line 407
              if (__s2_len >= 4U) {
#line 407
                tmp___22 = 1;
              } else {
#line 407
                tmp___22 = 0;
              }
            }
          } else {
#line 407
            tmp___22 = 0;
          }
        }
#line 407
        if (tmp___22) {
#line 407
          tmp___18 = __builtin_strcmp(passphrase, "");
        } else {
#line 407
          tmp___21 = __builtin_strcmp(passphrase, "");
#line 407
          tmp___18 = tmp___21;
        }
      } else {
#line 407
        tmp___21 = __builtin_strcmp(passphrase, "");
#line 407
        tmp___18 = tmp___21;
      }
#line 407
      if (tmp___18 != 0) {
#line 408
        debug("Bad passphrase supplied for key file %.200s.", filename);
      }
#line 411
      buffer_free(& decrypted);
      goto fail;
    }
  }
#line 415
  buffer_get_bignum(& decrypted, (prv->rsa)->d);
#line 416
  buffer_get_bignum(& decrypted, (prv->rsa)->iqmp);
#line 418
  buffer_get_bignum(& decrypted, (prv->rsa)->q);
#line 419
  buffer_get_bignum(& decrypted, (prv->rsa)->p);
#line 422
  rsa_generate_additional_parameters(prv->rsa);
#line 424
  buffer_free(& decrypted);
#line 427
  tmp___25 = RSA_blinding_on(prv->rsa, (BN_CTX *)((void *)0));
#line 427
  if (tmp___25 != 1) {
#line 428
    error("key_load_private_rsa1: RSA_blinding_on failed");
    goto fail;
  }
#line 431
  close(fd);
#line 432
  return (prv);
  fail: 
#line 435
  if (commentp) {
#line 436
    xfree((void *)*commentp);
  }
#line 437
  close(fd);
#line 438
  key_free(prv);
#line 439
  return ((Key *)((void *)0));
}
}
#line 442 "authfile.c"
Key *key_load_private_pem(int fd , int type , char const   *passphrase , char **commentp ) 
{ FILE *fp ;
  EVP_PKEY *pk ;
  Key *prv ;
  char *name ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___3 ;

  {
#line 447
  pk = (EVP_PKEY *)((void *)0);
#line 448
  prv = (Key *)((void *)0);
#line 449
  name = (char *)"<no key>";
#line 451
  fp = fdopen(fd, "r");
#line 452
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 453
    tmp = __errno_location();
#line 453
    tmp___0 = strerror(*tmp);
#line 453
    error("fdopen failed: %s", tmp___0);
#line 454
    close(fd);
#line 455
    return ((Key *)((void *)0));
  }
#line 457
  pk = PEM_read_PrivateKey(fp, (EVP_PKEY **)((void *)0), (pem_password_cb *)((void *)0),
                           (void *)((char *)passphrase));
#line 458
  if ((unsigned int )pk == (unsigned int )((void *)0)) {
#line 459
    debug("PEM_read_PrivateKey failed");
#line 460
    ERR_get_error();
  } else {
#line 461
    if (pk->type == 6) {
#line 461
      if (type == 3) {
        goto _L___0;
      } else {
#line 461
        if (type == 1) {
          _L___0: /* CIL Label */ 
#line 463
          prv = key_new(3);
#line 464
          prv->rsa = EVP_PKEY_get1_RSA(pk);
#line 465
          prv->type = 1;
#line 466
          name = (char *)"rsa w/o comment";
#line 470
          tmp___1 = RSA_blinding_on(prv->rsa, (BN_CTX *)((void *)0));
#line 470
          if (tmp___1 != 1) {
#line 471
            error("key_load_private_pem: RSA_blinding_on failed");
#line 472
            key_free(prv);
#line 473
            prv = (Key *)((void *)0);
          }
        } else {
          goto _L;
        }
      }
    } else {
      _L: /* CIL Label */ 
#line 475
      if (pk->type == 116) {
#line 475
        if (type == 3) {
#line 477
          prv = key_new(3);
#line 478
          prv->dsa = EVP_PKEY_get1_DSA(pk);
#line 479
          prv->type = 2;
#line 480
          name = (char *)"dsa w/o comment";
        } else {
#line 475
          if (type == 2) {
#line 477
            prv = key_new(3);
#line 478
            prv->dsa = EVP_PKEY_get1_DSA(pk);
#line 479
            prv->type = 2;
#line 480
            name = (char *)"dsa w/o comment";
          } else {
#line 485
            error("PEM_read_PrivateKey: mismatch or unknown EVP_PKEY save_type %d",
                  pk->save_type);
          }
        }
      } else {
#line 485
        error("PEM_read_PrivateKey: mismatch or unknown EVP_PKEY save_type %d", pk->save_type);
      }
    }
  }
#line 488
  fclose(fp);
#line 489
  if ((unsigned int )pk != (unsigned int )((void *)0)) {
#line 490
    EVP_PKEY_free(pk);
  }
#line 491
  if ((unsigned int )prv != (unsigned int )((void *)0)) {
#line 491
    if (commentp) {
#line 492
      *commentp = xstrdup((char const   *)name);
    }
  }
#line 493
  if (prv) {
#line 493
    tmp___3 = key_type((Key const   *)prv);
  } else {
#line 493
    tmp___3 = "<unknown>";
  }
#line 493
  debug("read PEM private key done: type %s", tmp___3);
#line 495
  return (prv);
}
}
#line 498 "authfile.c"
static int key_perm_ok(int fd , char const   *filename ) 
{ struct stat st ;
  int tmp ;
  __uid_t tmp___0 ;

  {
#line 503
  tmp = fstat(fd, & st);
#line 503
  if (tmp < 0) {
#line 504
    return (0);
  }
#line 513
  tmp___0 = getuid();
#line 513
  if (st.st_uid == tmp___0) {
#line 513
    if ((st.st_mode & 63U) != 0U) {
#line 514
      error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 515
      error("@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @");
#line 516
      error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 517
      error("Permissions 0%3.3o for \'%s\' are too open.", st.st_mode & 511U, filename);
#line 519
      error("It is recommended that your private key files are NOT accessible by others.");
#line 520
      error("This private key will be ignored.");
#line 521
      return (0);
    }
  }
#line 523
  return (1);
}
}
#line 526 "authfile.c"
Key *key_load_private_type(int type , char const   *filename , char const   *passphrase ,
                           char **commentp ) 
{ int fd ;
  int tmp ;
  Key *tmp___0 ;
  Key *tmp___1 ;

  {
#line 532
  fd = open(filename, 0);
#line 533
  if (fd < 0) {
#line 534
    return ((Key *)((void *)0));
  }
#line 535
  tmp = key_perm_ok(fd, filename);
#line 535
  if (! tmp) {
#line 536
    error("bad permissions: ignore key: %s", filename);
#line 537
    close(fd);
#line 538
    return ((Key *)((void *)0));
  }
#line 540
  switch (type) {
  case 0: 
#line 542
  tmp___0 = key_load_private_rsa1(fd, filename, passphrase, commentp);
#line 542
  return (tmp___0);
#line 545
  break;
  case 2: 
  case 1: 
  case 3: 
#line 549
  tmp___1 = key_load_private_pem(fd, type, passphrase, commentp);
#line 549
  return (tmp___1);
#line 551
  break;
  default: 
#line 553
  close(fd);
#line 554
  break;
  }
#line 556
  return ((Key *)((void *)0));
}
}
#line 559 "authfile.c"
Key *key_load_private(char const   *filename , char const   *passphrase , char **commentp ) 
{ Key *pub ;
  Key *prv ;
  int fd ;
  int tmp ;

  {
#line 566
  fd = open(filename, 0);
#line 567
  if (fd < 0) {
#line 568
    return ((Key *)((void *)0));
  }
#line 569
  tmp = key_perm_ok(fd, filename);
#line 569
  if (! tmp) {
#line 570
    error("bad permissions: ignore key: %s", filename);
#line 571
    close(fd);
#line 572
    return ((Key *)((void *)0));
  }
#line 574
  pub = key_load_public_rsa1(fd, filename, commentp);
#line 575
  lseek(fd, 0LL, 0);
#line 576
  if ((unsigned int )pub == (unsigned int )((void *)0)) {
#line 578
    prv = key_load_private_pem(fd, 3, passphrase, (char **)((void *)0));
#line 580
    if (commentp) {
#line 580
      if (prv) {
#line 581
        *commentp = xstrdup(filename);
      }
    }
  } else {
#line 584
    key_free(pub);
#line 586
    prv = key_load_private_rsa1(fd, filename, passphrase, (char **)((void *)0));
  }
#line 588
  return (prv);
}
}
#line 591 "authfile.c"
static int key_try_load_public(Key *k , char const   *filename , char **commentp ) 
{ FILE *f ;
  char line[4096] ;
  char *cp ;
  int tmp ;
  char *tmp___0 ;

  {
#line 598
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 599
  if ((unsigned int )f != (unsigned int )((void *)0)) {
#line 600
    while (1) {
#line 600
      tmp___0 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 600
      if (! tmp___0) {
#line 600
        break;
      }
#line 601
      line[sizeof(line) - 1U] = (char )'\000';
#line 602
      cp = line;
#line 603
      switch ((int )*cp) {
      case 35: 
      case 10: 
      case 0: 
#line 607
      continue;
      }
#line 610
      while (1) {
#line 610
        if (*cp) {
#line 610
          if (! ((int )*cp == 32)) {
#line 610
            if (! ((int )*cp == 9)) {
#line 610
              break;
            }
          }
        } else {
#line 610
          break;
        }
#line 610
        cp ++;
      }
#line 612
      if (*cp) {
#line 613
        tmp = key_read(k, & cp);
#line 613
        if (tmp == 1) {
#line 614
          if (commentp) {
#line 615
            *commentp = xstrdup(filename);
          }
#line 616
          fclose(f);
#line 617
          return (1);
        }
      }
    }
#line 621
    fclose(f);
  }
#line 623
  return (0);
}
}
#line 627 "authfile.c"
Key *key_load_public(char const   *filename , char **commentp ) 
{ Key *pub ;
  char file___0[4096] ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 634
  pub = key_load_public_type(0, filename, commentp);
#line 635
  if ((unsigned int )pub != (unsigned int )((void *)0)) {
#line 636
    return (pub);
  }
#line 639
  pub = key_new(0);
#line 640
  tmp = key_try_load_public(pub, filename, commentp);
#line 640
  if (tmp == 1) {
#line 641
    return (pub);
  }
#line 642
  key_free(pub);
#line 645
  pub = key_new(3);
#line 646
  tmp___0 = key_try_load_public(pub, filename, commentp);
#line 646
  if (tmp___0 == 1) {
#line 647
    return (pub);
  }
#line 648
  tmp___1 = strlcpy(file___0, filename, sizeof(file___0));
#line 648
  if (tmp___1 < sizeof(file___0)) {
#line 648
    tmp___2 = strlcat(file___0, ".pub", sizeof(file___0));
#line 648
    if (tmp___2 < sizeof(file___0)) {
#line 648
      tmp___3 = key_try_load_public(pub, (char const   *)(file___0), commentp);
#line 648
      if (tmp___3 == 1) {
#line 651
        return (pub);
      }
    }
  }
#line 652
  key_free(pub);
#line 653
  return ((Key *)((void *)0));
}
}
#line 1 "bufaux.o"
#line 412 "/usr/include/openssl/bn.h"
extern BIGNUM *BN_bin2bn(unsigned char const   *s , int len , BIGNUM *ret ) ;
#line 413
extern int BN_bn2bin(BIGNUM const   *a , unsigned char *to ) ;
#line 36 "buffer.h"
void buffer_get(Buffer *buffer , void *buf___1 , u_int len ) ;
#line 38
void buffer_consume(Buffer *buffer , u_int bytes ) ;
#line 24 "bufaux.h"
void buffer_get_bignum2(Buffer *buffer , BIGNUM *value ) ;
#line 26
u_short buffer_get_short(Buffer *buffer ) ;
#line 27
void buffer_put_short(Buffer *buffer , u_short value ) ;
#line 32
u_int64_t buffer_get_int64(Buffer *buffer ) ;
#line 33
void buffer_put_int64(Buffer *buffer , u_int64_t value ) ;
#line 52 "bufaux.c"
void buffer_put_bignum(Buffer *buffer , BIGNUM const   *value ) 
{ int bits ;
  int tmp ;
  int bin_size ;
  u_char *buf___1 ;
  void *tmp___0 ;
  int oi ;
  char msg[2] ;

  {
#line 55
  tmp = BN_num_bits(value);
#line 55
  bits = tmp;
#line 56
  bin_size = (bits + 7) / 8;
#line 57
  tmp___0 = xmalloc((unsigned int )bin_size);
#line 57
  buf___1 = (u_char *)tmp___0;
#line 62
  oi = BN_bn2bin(value, buf___1);
#line 63
  if (oi != bin_size) {
#line 64
    fatal("buffer_put_bignum: BN_bn2bin() failed: oi %d != bin_size %d", oi, bin_size);
  }
#line 68
  while (1) {
#line 68
    msg[0] = (char )(bits >> 8);
#line 68
    msg[1] = (char )bits;
#line 68
    break;
  }
#line 69
  buffer_append(buffer, (void const   *)(msg), 2U);
#line 71
  buffer_append(buffer, (void const   *)((char *)buf___1), (unsigned int )oi);
#line 73
  memset((void *)buf___1, 0, (unsigned int )bin_size);
#line 74
  xfree((void *)buf___1);
#line 75
  return;
}
}
#line 80 "bufaux.c"
void buffer_get_bignum(Buffer *buffer , BIGNUM *value ) 
{ u_int bits ;
  u_int bytes ;
  u_char buf___1[2] ;
  u_char *bin ;
  u_int tmp ;
  void *tmp___0 ;

  {
#line 87
  buffer_get(buffer, (void *)((char *)(buf___1)), 2U);
#line 88
  bits = (unsigned int )(((unsigned long )buf___1[0] << 8) | (unsigned long )buf___1[1]);
#line 90
  bytes = (bits + 7U) / 8U;
#line 91
  if (bytes > 8192U) {
#line 92
    fatal("buffer_get_bignum: cannot handle BN of size %d", bytes);
  }
#line 93
  tmp = buffer_len(buffer);
#line 93
  if (tmp < bytes) {
#line 94
    fatal("buffer_get_bignum: input buffer too small");
  }
#line 95
  tmp___0 = buffer_ptr(buffer);
#line 95
  bin = (u_char *)tmp___0;
#line 96
  BN_bin2bn((unsigned char const   *)bin, (int )bytes, value);
#line 97
  buffer_consume(buffer, bytes);
#line 98
  return;
}
}
#line 103 "bufaux.c"
void buffer_put_bignum2(Buffer *buffer , BIGNUM const   *value ) 
{ u_int bytes ;
  u_char *buf___1 ;
  int oi ;
  u_int hasnohigh ;
  int tmp ;
  void *tmp___0 ;

  {
#line 109
  hasnohigh = (u_int )0;
#line 111
  if (value->top == 0) {
#line 112
    buffer_put_int(buffer, 0U);
#line 113
    return;
  }
#line 115
  if (value->neg) {
#line 116
    fatal("buffer_put_bignum2: negative numbers not supported");
  }
#line 117
  tmp = BN_num_bits(value);
#line 117
  bytes = (unsigned int )((tmp + 7) / 8 + 1);
#line 118
  if (bytes < 2U) {
#line 119
    fatal("buffer_put_bignum2: BN too small");
  }
#line 120
  tmp___0 = xmalloc(bytes);
#line 120
  buf___1 = (u_char *)tmp___0;
#line 121
  *(buf___1 + 0) = (unsigned char )'\000';
#line 123
  oi = BN_bn2bin(value, buf___1 + 1);
#line 124
  if ((u_int )oi != bytes - 1U) {
#line 125
    fatal("buffer_put_bignum2: BN_bn2bin() failed: oi %d != bin_size %d", oi, bytes);
  }
#line 127
  if ((int )*(buf___1 + 1) & 128) {
#line 127
    hasnohigh = 0U;
  } else {
#line 127
    hasnohigh = 1U;
  }
#line 128
  buffer_put_string(buffer, (void const   *)(buf___1 + hasnohigh), bytes - hasnohigh);
#line 129
  memset((void *)buf___1, 0, bytes);
#line 130
  xfree((void *)buf___1);
#line 131
  return;
}
}
#line 133 "bufaux.c"
void buffer_get_bignum2(Buffer *buffer , BIGNUM *value ) 
{ u_int len ;
  u_char *bin ;
  void *tmp ;

  {
#line 137
  tmp = buffer_get_string(buffer, & len);
#line 137
  bin = (u_char *)tmp;
#line 139
  if (len > 0U) {
#line 139
    if ((int )*(bin + 0) & 128) {
#line 140
      fatal("buffer_get_bignum2: negative numbers not supported");
    }
  }
#line 141
  if (len > 8192U) {
#line 142
    fatal("buffer_get_bignum2: cannot handle BN of size %d", len);
  }
#line 143
  BN_bin2bn((unsigned char const   *)bin, (int )len, value);
#line 144
  xfree((void *)bin);
#line 145
  return;
}
}
#line 151 "bufaux.c"
u_short buffer_get_short(Buffer *buffer ) 
{ u_char buf___1[2] ;

  {
#line 156
  buffer_get(buffer, (void *)((char *)(buf___1)), 2U);
#line 157
  return ((unsigned short )(((unsigned long )buf___1[0] << 8) | (unsigned long )buf___1[1]));
}
}
#line 160 "bufaux.c"
u_int buffer_get_int(Buffer *buffer ) 
{ u_char buf___1[4] ;

  {
#line 165
  buffer_get(buffer, (void *)((char *)(buf___1)), 4U);
#line 166
  return ((unsigned int )(((((unsigned long )buf___1[0] << 24) | ((unsigned long )buf___1[1] << 16)) | ((unsigned long )buf___1[2] << 8)) | (unsigned long )buf___1[3]));
}
}
#line 169 "bufaux.c"
u_int64_t buffer_get_int64(Buffer *buffer ) 
{ u_char buf___1[8] ;

  {
#line 174
  buffer_get(buffer, (void *)((char *)(buf___1)), 8U);
#line 175
  return (((((((((unsigned long long )buf___1[0] << 56) | ((unsigned long long )buf___1[1] << 48)) | ((unsigned long long )buf___1[2] << 40)) | ((unsigned long long )buf___1[3] << 32)) | ((unsigned long long )buf___1[4] << 24)) | ((unsigned long long )buf___1[5] << 16)) | ((unsigned long long )buf___1[6] << 8)) | (unsigned long long )buf___1[7]);
}
}
#line 181 "bufaux.c"
void buffer_put_short(Buffer *buffer , u_short value ) 
{ char buf___1[2] ;

  {
#line 186
  while (1) {
#line 186
    buf___1[0] = (char )((int )value >> 8);
#line 186
    buf___1[1] = (char )value;
#line 186
    break;
  }
#line 187
  buffer_append(buffer, (void const   *)(buf___1), 2U);
#line 188
  return;
}
}
#line 190 "bufaux.c"
void buffer_put_int(Buffer *buffer , u_int value ) 
{ char buf___1[4] ;

  {
#line 195
  while (1) {
#line 195
    buf___1[0] = (char )(value >> 24);
#line 195
    buf___1[1] = (char )(value >> 16);
#line 195
    buf___1[2] = (char )(value >> 8);
#line 195
    buf___1[3] = (char )value;
#line 195
    break;
  }
#line 196
  buffer_append(buffer, (void const   *)(buf___1), 4U);
#line 197
  return;
}
}
#line 199 "bufaux.c"
void buffer_put_int64(Buffer *buffer , u_int64_t value ) 
{ char buf___1[8] ;

  {
#line 204
  while (1) {
#line 204
    buf___1[0] = (char )(value >> 56);
#line 204
    buf___1[1] = (char )(value >> 48);
#line 204
    buf___1[2] = (char )(value >> 40);
#line 204
    buf___1[3] = (char )(value >> 32);
#line 204
    buf___1[4] = (char )(value >> 24);
#line 204
    buf___1[5] = (char )(value >> 16);
#line 204
    buf___1[6] = (char )(value >> 8);
#line 204
    buf___1[7] = (char )value;
#line 204
    break;
  }
#line 205
  buffer_append(buffer, (void const   *)(buf___1), 8U);
#line 206
  return;
}
}
#line 216 "bufaux.c"
void *buffer_get_string(Buffer *buffer , u_int *length_ptr ) 
{ u_char *value ;
  u_int len ;
  void *tmp ;

  {
#line 223
  len = buffer_get_int(buffer);
#line 224
  if (len > 262144U) {
#line 225
    fatal("buffer_get_string: bad string length %u", len);
  }
#line 227
  tmp = xmalloc(len + 1U);
#line 227
  value = (u_char *)tmp;
#line 229
  buffer_get(buffer, (void *)value, len);
#line 231
  *(value + len) = (unsigned char)0;
#line 233
  if (length_ptr) {
#line 234
    *length_ptr = len;
  }
#line 235
  return ((void *)value);
}
}
#line 241 "bufaux.c"
void buffer_put_string(Buffer *buffer , void const   *buf___1 , u_int len ) 
{ 

  {
#line 244
  buffer_put_int(buffer, len);
#line 245
  buffer_append(buffer, buf___1, len);
#line 246
  return;
}
}
#line 247 "bufaux.c"
void buffer_put_cstring(Buffer *buffer , char const   *s ) 
{ size_t tmp ;

  {
#line 250
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 251
    fatal("buffer_put_cstring: s == NULL");
  }
#line 252
  tmp = strlen(s);
#line 252
  buffer_put_string(buffer, (void const   *)s, tmp);
#line 253
  return;
}
}
#line 258 "bufaux.c"
int buffer_get_char(Buffer *buffer ) 
{ char ch ;

  {
#line 263
  buffer_get(buffer, (void *)(& ch), 1U);
#line 264
  return ((int )((unsigned char )ch));
}
}
#line 270 "bufaux.c"
void buffer_put_char(Buffer *buffer , int value ) 
{ char ch ;

  {
#line 273
  ch = (char )value;
#line 275
  buffer_append(buffer, (void const   *)(& ch), 1U);
#line 276
  return;
}
}
#line 1 "buffer.o"
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 23 "xmalloc.h"
void *xrealloc(void *ptr , size_t new_size ) ;
#line 39 "buffer.h"
void buffer_consume_end(Buffer *buffer , u_int bytes ) ;
#line 41
void buffer_dump(Buffer *buffer ) ;
#line 23 "buffer.c"
void buffer_init(Buffer *buffer ) 
{ u_int len ;
  void *tmp ;

  {
#line 26
  len = (u_int )4096;
#line 28
  buffer->alloc = 0U;
#line 29
  tmp = xmalloc(len);
#line 29
  buffer->buf = (u_char *)tmp;
#line 30
  buffer->alloc = len;
#line 31
  buffer->offset = 0U;
#line 32
  buffer->end = 0U;
#line 33
  return;
}
}
#line 37 "buffer.c"
void buffer_free(Buffer *buffer ) 
{ 

  {
#line 40
  if (buffer->alloc > 0U) {
#line 41
    memset((void *)buffer->buf, 0, buffer->alloc);
#line 42
    buffer->alloc = 0U;
#line 43
    xfree((void *)buffer->buf);
  }
#line 45
  return;
}
}
#line 52 "buffer.c"
void buffer_clear(Buffer *buffer ) 
{ 

  {
#line 55
  buffer->offset = 0U;
#line 56
  buffer->end = 0U;
#line 57
  return;
}
}
#line 61 "buffer.c"
void buffer_append(Buffer *buffer , void const   *data , u_int len ) 
{ void *p ;

  {
#line 65
  p = buffer_append_space(buffer, len);
#line 66
  memcpy((void * __restrict  )p, (void const   * __restrict  )data, len);
#line 67
  return;
}
}
#line 75 "buffer.c"
void *buffer_append_space(Buffer *buffer , u_int len ) 
{ u_int newlen ;
  void *p ;
  void *tmp ;

  {
#line 81
  if (len > 1048576U) {
#line 82
    fatal("buffer_append_space: len %u not supported", len);
  }
#line 85
  if (buffer->offset == buffer->end) {
#line 86
    buffer->offset = 0U;
#line 87
    buffer->end = 0U;
  }
  restart: 
#line 91
  if (buffer->end + len < buffer->alloc) {
#line 92
    p = (void *)(buffer->buf + buffer->end);
#line 93
    buffer->end += len;
#line 94
    return (p);
  }
#line 100
  if (buffer->offset > buffer->alloc / 2U) {
#line 101
    memmove((void *)buffer->buf, (void const   *)(buffer->buf + buffer->offset), buffer->end - buffer->offset);
#line 103
    buffer->end -= buffer->offset;
#line 104
    buffer->offset = 0U;
    goto restart;
  }
#line 109
  newlen = (buffer->alloc + len) + 32768U;
#line 110
  if (newlen > 10485760U) {
#line 111
    fatal("buffer_append_space: alloc %u not supported", newlen);
  }
#line 113
  tmp = xrealloc((void *)buffer->buf, newlen);
#line 113
  buffer->buf = (u_char *)tmp;
#line 114
  buffer->alloc = newlen;
  goto restart;
}
}
#line 121 "buffer.c"
u_int buffer_len(Buffer *buffer ) 
{ 

  {
#line 124
  return (buffer->end - buffer->offset);
}
}
#line 129 "buffer.c"
void buffer_get(Buffer *buffer , void *buf___1 , u_int len ) 
{ 

  {
#line 132
  if (len > buffer->end - buffer->offset) {
#line 133
    fatal("buffer_get: trying to get more bytes %d than in buffer %d", len, buffer->end - buffer->offset);
  }
#line 135
  memcpy((void * __restrict  )buf___1, (void const   * __restrict  )(buffer->buf + buffer->offset),
         len);
#line 136
  buffer->offset += len;
#line 137
  return;
}
}
#line 141 "buffer.c"
void buffer_consume(Buffer *buffer , u_int bytes ) 
{ 

  {
#line 144
  if (bytes > buffer->end - buffer->offset) {
#line 145
    fatal("buffer_consume: trying to get more bytes than in buffer");
  }
#line 146
  buffer->offset += bytes;
#line 147
  return;
}
}
#line 151 "buffer.c"
void buffer_consume_end(Buffer *buffer , u_int bytes ) 
{ 

  {
#line 154
  if (bytes > buffer->end - buffer->offset) {
#line 155
    fatal("buffer_consume_end: trying to get more bytes than in buffer");
  }
#line 156
  buffer->end -= bytes;
#line 157
  return;
}
}
#line 161 "buffer.c"
void *buffer_ptr(Buffer *buffer ) 
{ 

  {
#line 164
  return ((void *)(buffer->buf + buffer->offset));
}
}
#line 169 "buffer.c"
void buffer_dump(Buffer *buffer ) 
{ u_int i ;
  u_char *ucp ;

  {
#line 173
  ucp = buffer->buf;
#line 175
  i = buffer->offset;
#line 175
  while (i < buffer->end) {
#line 176
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%02x", *(ucp + i));
#line 177
    if ((i - buffer->offset) % 16U == 15U) {
#line 178
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\r\n");
    } else {
#line 179
      if ((i - buffer->offset) % 2U == 1U) {
#line 180
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" ");
      }
    }
#line 175
    i ++;
  }
#line 182
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\r\n");
#line 183
  return;
}
}
#line 1 "canohost.o"
#line 357 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 116 "/usr/include/ctype.h"
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 290
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   * __restrict  __nptr ,
                                                            char ** __restrict  __endptr ,
                                                            int __base , int __group )  __attribute__((__nonnull__(1))) ;
#line 332
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 332 "/usr/include/stdlib.h"
__inline static long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                            int __base ) 
{ long tmp ;

  {
#line 336
  tmp = __strtol_internal(__nptr, __endptr, __base, 0);
#line 336
  return (tmp);
}
}
#line 401
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 401 "/usr/include/stdlib.h"
__inline static int atoi(char const   *__nptr ) 
{ long tmp ;

  {
#line 404
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 404
  return ((int )tmp);
}
}
#line 128 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int getpeername(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 352 "/usr/include/netdb.h"
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 631
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 637
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
#line 646
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , unsigned int __flags ) ;
#line 23 "packet.h"
int packet_get_connection_in(void) ;
#line 57
void ( /* format attribute */  packet_disconnect)(char const   *fmt  , ...) ;
#line 75
int packet_connection_is_on_socket(void) ;
#line 65 "log.h"
void cleanup_exit(int i ) ;
#line 15 "canohost.h"
char const   *get_canonical_hostname(int use_dns ) ;
#line 16
char const   *get_remote_ipaddr(void) ;
#line 17
char const   *get_remote_name_or_ip(u_int utmp_len___0 , int use_dns ) ;
#line 19
char *get_peer_ipaddr(int socket___0 ) ;
#line 20
int get_peer_port(int sock ) ;
#line 21
char *get_local_ipaddr(int socket___0 ) ;
#line 22
char *get_local_name(int socket___0 ) ;
#line 24
int get_remote_port(void) ;
#line 25
int get_local_port(void) ;
#line 22 "canohost.c"
static void check_ip_options(int socket___0 , char *ipaddr ) ;
#line 23
static void ipv64_normalise_mapped(struct sockaddr_storage *addr , socklen_t *len ) ;
#line 30 "canohost.c"
static char *get_remote_hostname(int socket___0 , int use_dns ) 
{ struct sockaddr_storage from ;
  int i ;
  socklen_t fromlen ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char name[1025] ;
  char ntop[1025] ;
  char ntop2[1025] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int __res ;
  __int32_t const   **tmp___10 ;
  unsigned short const   **tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;

  {
#line 40
  fromlen = sizeof(from);
#line 41
  memset((void *)(& from), 0, sizeof(from));
#line 42
  tmp___1 = getpeername(socket___0, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                        (socklen_t * __restrict  )(& fromlen));
#line 42
  if (tmp___1 < 0) {
#line 43
    tmp = __errno_location();
#line 43
    tmp___0 = strerror(*tmp);
#line 43
    debug("getpeername failed: %.100s", tmp___0);
#line 44
    cleanup_exit(255);
  }
#line 47
  if ((int )from.ss_family == 2) {
#line 48
    check_ip_options(socket___0, ntop);
  }
#line 50
  ipv64_normalise_mapped(& from, & fromlen);
#line 52
  if ((int )from.ss_family == 10) {
#line 53
    fromlen = sizeof(struct sockaddr_in6 );
  }
#line 55
  tmp___2 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )((void *)0),
                        0U, 1U);
#line 55
  if (tmp___2 != 0) {
#line 57
    fatal("get_remote_hostname: getnameinfo NI_NUMERICHOST failed");
  }
#line 59
  if (! use_dns) {
#line 60
    tmp___3 = xstrdup((char const   *)(ntop));
#line 60
    return (tmp___3);
  }
#line 62
  debug3("Trying to reverse map address %.100s.", ntop);
#line 64
  tmp___5 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )(name), sizeof(name), (char * __restrict  )((void *)0),
                        0U, 8U);
#line 64
  if (tmp___5 != 0) {
#line 67
    tmp___4 = xstrdup((char const   *)(ntop));
#line 67
    return (tmp___4);
  }
#line 75
  memset((void *)(& hints), 0, sizeof(hints));
#line 76
  hints.ai_socktype = 2;
#line 77
  hints.ai_flags = 4;
#line 78
  tmp___7 = getaddrinfo((char const   * __restrict  )(name), (char const   * __restrict  )"0",
                        (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& ai));
#line 78
  if (tmp___7 == 0) {
#line 79
    logit("Nasty PTR record \"%s\" is set up for %s, ignoring", name, ntop);
#line 81
    freeaddrinfo(ai);
#line 82
    tmp___6 = xstrdup((char const   *)(ntop));
#line 82
    return (tmp___6);
  }
#line 89
  i = 0;
#line 89
  while (name[i]) {
#line 90
    tmp___11 = __ctype_b_loc();
#line 90
    if ((int const   )*(*tmp___11 + (int )name[i]) & 256) {
#line 91
      if (sizeof(name[i]) > 1U) {
#line 91
        __res = tolower((int )name[i]);
      } else {
#line 91
        tmp___10 = __ctype_tolower_loc();
#line 91
        __res = (int )*(*tmp___10 + (int )name[i]);
      }
#line 91
      name[i] = (char )__res;
    }
#line 89
    i ++;
  }
#line 101
  memset((void *)(& hints), 0, sizeof(hints));
#line 102
  hints.ai_family = (int )from.ss_family;
#line 103
  hints.ai_socktype = 1;
#line 104
  tmp___13 = getaddrinfo((char const   * __restrict  )(name), (char const   * __restrict  )((void *)0),
                         (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 104
  if (tmp___13 != 0) {
#line 105
    logit("reverse mapping checking getaddrinfo for %.700s failed - POSSIBLE BREAKIN ATTEMPT!",
          name);
#line 107
    tmp___12 = xstrdup((char const   *)(ntop));
#line 107
    return (tmp___12);
  }
#line 110
  ai = aitop;
#line 110
  while (ai) {
#line 111
    tmp___14 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                           (char * __restrict  )(ntop2), sizeof(ntop2), (char * __restrict  )((void *)0),
                           0U, 1U);
#line 113
    if (tmp___14 == 0) {
#line 113
      if (0) {
#line 113
        __s1_len = strlen((char const   *)(ntop));
#line 113
        __s2_len = strlen((char const   *)(ntop2));
#line 113
        if (! ((unsigned int )((void const   *)(ntop + 1)) - (unsigned int )((void const   *)(ntop)) == 1U)) {
          goto _L___0;
        } else {
#line 113
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 113
            if (! ((unsigned int )((void const   *)(ntop2 + 1)) - (unsigned int )((void const   *)(ntop2)) == 1U)) {
#line 113
              tmp___24 = 1;
            } else {
#line 113
              if (__s2_len >= 4U) {
#line 113
                tmp___24 = 1;
              } else {
#line 113
                tmp___24 = 0;
              }
            }
          } else {
#line 113
            tmp___24 = 0;
          }
        }
#line 113
        if (tmp___24) {
#line 113
          tmp___20 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
        } else {
#line 113
          tmp___23 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
#line 113
          tmp___20 = tmp___23;
        }
      } else {
#line 113
        tmp___23 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
#line 113
        tmp___20 = tmp___23;
      }
#line 113
      if (tmp___20 == 0) {
#line 114
        break;
      }
    }
#line 110
    ai = ai->ai_next;
  }
#line 116
  freeaddrinfo(aitop);
#line 118
  if (! ai) {
#line 120
    logit("Address %.100s maps to %.600s, but this does not map back to the address - POSSIBLE BREAKIN ATTEMPT!",
          ntop, name);
#line 123
    tmp___25 = xstrdup((char const   *)(ntop));
#line 123
    return (tmp___25);
  }
#line 125
  tmp___26 = xstrdup((char const   *)(name));
#line 125
  return (tmp___26);
}
}
#line 140 "canohost.c"
static void check_ip_options(int socket___0 , char *ipaddr ) 
{ u_char options___0[200] ;
  char text[sizeof(options___0) * 3U + 1U] ;
  socklen_t option_size ;
  int i ;
  int ipproto ;
  struct protoent *ip ;
  int tmp ;

  {
#line 150
  ip = getprotobyname("ip");
#line 150
  if ((unsigned int )ip != (unsigned int )((void *)0)) {
#line 151
    ipproto = ip->p_proto;
  } else {
#line 153
    ipproto = 0;
  }
#line 154
  option_size = sizeof(options___0);
#line 155
  tmp = getsockopt(socket___0, ipproto, 4, (void * __restrict  )(options___0), (socklen_t * __restrict  )(& option_size));
#line 155
  if (tmp >= 0) {
#line 155
    if (option_size != 0U) {
#line 157
      text[0] = (char )'\000';
#line 158
      i = 0;
#line 158
      while ((socklen_t )i < option_size) {
#line 159
        snprintf((char * __restrict  )(text + i * 3), sizeof(text) - (unsigned int )(i * 3),
                 (char const   * __restrict  )" %2.2x", options___0[i]);
#line 158
        i ++;
      }
#line 161
      logit("Connection from %.100s with IP options:%.800s", ipaddr, text);
#line 163
      packet_disconnect("Connection from %.100s with IP options:%.800s", ipaddr, text);
    }
  }
#line 167
  return;
}
}
#line 169 "canohost.c"
static void ipv64_normalise_mapped(struct sockaddr_storage *addr , socklen_t *len ) 
{ struct sockaddr_in6 *a6 ;
  struct sockaddr_in *a4 ;
  struct in_addr inaddr ;
  u_int16_t port ;
  register unsigned int __v ;
  register unsigned int __x ;

  {
#line 172
  a6 = (struct sockaddr_in6 *)addr;
#line 173
  a4 = (struct sockaddr_in *)addr;
#line 178
  if ((int )addr->ss_family != 10) {
#line 179
    return;
  } else {
#line 178
    if (*((uint32_t const   *)(& a6->sin6_addr) + 0) == 0U) {
#line 178
      if (*((uint32_t const   *)(& a6->sin6_addr) + 1) == 0U) {
#line 178
        __x = 65535U;
#line 178
        __asm__  ("rorw $8, %w0;"
                  "rorl $16, %0;"
                  "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 178
        if (! (*((uint32_t const   *)(& a6->sin6_addr) + 2) == (uint32_t const   )__v)) {
#line 179
          return;
        }
      } else {
#line 179
        return;
      }
    } else {
#line 179
      return;
    }
  }
#line 181
  debug3("Normalising mapped IPv4 in IPv6 address");
#line 183
  memcpy((void * __restrict  )(& inaddr), (void const   * __restrict  )((char *)(& a6->sin6_addr) + 12),
         sizeof(inaddr));
#line 184
  port = a6->sin6_port;
#line 186
  memset((void *)addr, 0, sizeof(*a4));
#line 188
  a4->sin_family = (unsigned short)2;
#line 189
  *len = sizeof(*a4);
#line 190
  memcpy((void * __restrict  )(& a4->sin_addr), (void const   * __restrict  )(& inaddr),
         sizeof(inaddr));
#line 191
  a4->sin_port = port;
#line 192
  return;
}
}
#line 203 "canohost.c"
static char *canonical_host_name  =    (char *)((void *)0);
#line 204 "canohost.c"
static int use_dns_done  =    0;
#line 200 "canohost.c"
char const   *get_canonical_hostname(int use_dns ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 207
  if ((unsigned int )canonical_host_name != (unsigned int )((void *)0)) {
#line 208
    if (use_dns_done != use_dns) {
#line 209
      xfree((void *)canonical_host_name);
    } else {
#line 211
      return ((char const   *)canonical_host_name);
    }
  }
#line 215
  tmp___0 = packet_connection_is_on_socket();
#line 215
  if (tmp___0) {
#line 216
    tmp = packet_get_connection_in();
#line 216
    canonical_host_name = get_remote_hostname(tmp, use_dns);
  } else {
#line 219
    canonical_host_name = xstrdup("UNKNOWN");
  }
#line 221
  use_dns_done = use_dns;
#line 222
  return ((char const   *)canonical_host_name);
}
}
#line 229 "canohost.c"
static char *get_socket_address(int socket___0 , int remote___0 , int flags ) 
{ struct sockaddr_storage addr ;
  socklen_t addrlen ;
  char ntop[1025] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 237
  addrlen = sizeof(addr);
#line 238
  memset((void *)(& addr), 0, sizeof(addr));
#line 240
  if (remote___0) {
#line 241
    tmp = getpeername(socket___0, (struct sockaddr * __restrict  )((struct sockaddr *)(& addr)),
                      (socklen_t * __restrict  )(& addrlen));
#line 241
    if (tmp < 0) {
#line 243
      return ((char *)((void *)0));
    }
  } else {
#line 245
    tmp___0 = getsockname(socket___0, (struct sockaddr * __restrict  )((struct sockaddr *)(& addr)),
                          (socklen_t * __restrict  )(& addrlen));
#line 245
    if (tmp___0 < 0) {
#line 247
      return ((char *)((void *)0));
    }
  }
#line 251
  if ((int )addr.ss_family == 10) {
#line 252
    addrlen = sizeof(struct sockaddr_in6 );
  }
#line 255
  tmp___1 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& addr)),
                        addrlen, (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )((void *)0),
                        0U, (unsigned int )flags);
#line 255
  if (tmp___1 != 0) {
#line 257
    error("get_socket_address: getnameinfo %d failed", flags);
#line 258
    return ((char *)((void *)0));
  }
#line 260
  tmp___2 = xstrdup((char const   *)(ntop));
#line 260
  return (tmp___2);
}
}
#line 263 "canohost.c"
char *get_peer_ipaddr(int socket___0 ) 
{ char *p ;
  char *tmp ;

  {
#line 268
  p = get_socket_address(socket___0, 1, 1);
#line 268
  if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 269
    return (p);
  }
#line 270
  tmp = xstrdup("UNKNOWN");
#line 270
  return (tmp);
}
}
#line 273 "canohost.c"
char *get_local_ipaddr(int socket___0 ) 
{ char *p ;
  char *tmp ;

  {
#line 278
  p = get_socket_address(socket___0, 0, 1);
#line 278
  if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 279
    return (p);
  }
#line 280
  tmp = xstrdup("UNKNOWN");
#line 280
  return (tmp);
}
}
#line 283 "canohost.c"
char *get_local_name(int socket___0 ) 
{ char *tmp ;

  {
#line 286
  tmp = get_socket_address(socket___0, 0, 8);
#line 286
  return (tmp);
}
}
#line 297 "canohost.c"
static char *canonical_host_ip  =    (char *)((void *)0);
#line 294 "canohost.c"
char const   *get_remote_ipaddr(void) 
{ int tmp ;
  int tmp___0 ;

  {
#line 300
  if ((unsigned int )canonical_host_ip == (unsigned int )((void *)0)) {
#line 301
    tmp___0 = packet_connection_is_on_socket();
#line 301
    if (tmp___0) {
#line 302
      tmp = packet_get_connection_in();
#line 302
      canonical_host_ip = get_peer_ipaddr(tmp);
#line 304
      if ((unsigned int )canonical_host_ip == (unsigned int )((void *)0)) {
#line 305
        cleanup_exit(255);
      }
    } else {
#line 308
      canonical_host_ip = xstrdup("UNKNOWN");
    }
  }
#line 311
  return ((char const   *)canonical_host_ip);
}
}
#line 317 "canohost.c"
static char const   *remote  =    "";
#line 314 "canohost.c"
char const   *get_remote_name_or_ip(u_int utmp_len___0 , int use_dns ) 
{ size_t tmp ;

  {
#line 318
  if (utmp_len___0 > 0U) {
#line 319
    remote = get_canonical_hostname(use_dns);
  }
#line 320
  if (utmp_len___0 == 0U) {
#line 321
    remote = get_remote_ipaddr();
  } else {
#line 320
    tmp = strlen(remote);
#line 320
    if (tmp > utmp_len___0) {
#line 321
      remote = get_remote_ipaddr();
    }
  }
#line 322
  return (remote);
}
}
#line 327 "canohost.c"
static int get_sock_port(int sock , int local ) 
{ struct sockaddr_storage from ;
  socklen_t fromlen ;
  char strport[32] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 335
  fromlen = sizeof(from);
#line 336
  memset((void *)(& from), 0, sizeof(from));
#line 337
  if (local) {
#line 338
    tmp___1 = getsockname(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 338
    if (tmp___1 < 0) {
#line 339
      tmp = __errno_location();
#line 339
      tmp___0 = strerror(*tmp);
#line 339
      error("getsockname failed: %.100s", tmp___0);
#line 340
      return (0);
    }
  } else {
#line 343
    tmp___4 = getpeername(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 343
    if (tmp___4 < 0) {
#line 344
      tmp___2 = __errno_location();
#line 344
      tmp___3 = strerror(*tmp___2);
#line 344
      debug("getpeername failed: %.100s", tmp___3);
#line 345
      cleanup_exit(255);
    }
  }
#line 350
  if ((int )from.ss_family == 10) {
#line 351
    fromlen = sizeof(struct sockaddr_in6 );
  }
#line 354
  tmp___5 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )((void *)0), 0U, (char * __restrict  )(strport),
                        sizeof(strport), 2U);
#line 354
  if (tmp___5 != 0) {
#line 356
    fatal("get_sock_port: getnameinfo NI_NUMERICSERV failed");
  }
#line 357
  tmp___6 = atoi((char const   *)(strport));
#line 357
  return (tmp___6);
}
}
#line 362 "canohost.c"
static int get_port(int local ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 369
  tmp = packet_connection_is_on_socket();
#line 369
  if (! tmp) {
#line 370
    return (65535);
  }
#line 373
  tmp___0 = packet_get_connection_in();
#line 373
  tmp___1 = get_sock_port(tmp___0, local);
#line 373
  return (tmp___1);
}
}
#line 376 "canohost.c"
int get_peer_port(int sock ) 
{ int tmp ;

  {
#line 379
  tmp = get_sock_port(sock, 0);
#line 379
  return (tmp);
}
}
#line 382 "canohost.c"
int get_remote_port(void) 
{ int tmp ;

  {
#line 385
  tmp = get_port(0);
#line 385
  return (tmp);
}
}
#line 388 "canohost.c"
int get_local_port(void) 
{ int tmp ;

  {
#line 391
  tmp = get_port(1);
#line 391
  return (tmp);
}
}
#line 1 "channels.o"
#line 407 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 102 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 170
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 745 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 192 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 199
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 209
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 218
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
#line 54 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
#line 65
extern  __attribute__((__nothrow__)) char const   *inet_ntop(int __af , void const   * __restrict  __cp ,
                                                             char * __restrict  __buf ,
                                                             socklen_t __len ) ;
#line 640 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
#line 29 "packet.h"
u_int packet_get_protocol_flags(void) ;
#line 32
int packet_is_interactive(void) ;
#line 34
void packet_start(u_char type ) ;
#line 35
void packet_put_char(int value ) ;
#line 36
void packet_put_int(u_int value ) ;
#line 39
void packet_put_string(void const   *buf___1 , u_int len ) ;
#line 40
void packet_put_cstring(char const   *str ) ;
#line 42
void packet_send(void) ;
#line 44
int packet_read(void) ;
#line 52
u_int packet_get_int(void) ;
#line 56
void *packet_get_string(u_int *length_ptr ) ;
#line 71
void packet_write_wait(void) ;
#line 77
int packet_remaining(void) ;
#line 78
void packet_send_ignore(int nbytes ) ;
#line 84
u_int max_packet_size ;
#line 59 "log.h"
void ( /* format attribute */  verbose)(char const   *fmt  , ...) ;
#line 61
void ( /* format attribute */  debug2)(char const   *fmt  , ...) ;
#line 17 "misc.h"
void set_nonblock(int fd ) ;
#line 19
void set_nodelay(int fd ) ;
#line 154 "channels.h"
Channel *channel_lookup(int id ) ;
#line 155
Channel *channel_new(char *ctype , int type , int rfd , int wfd , int efd , u_int window ,
                     u_int maxpack , int extusage , char *remote_name , int nonblock ) ;
#line 156
void channel_set_fds(int id , int rfd , int wfd , int efd , int extusage , int nonblock ,
                     u_int window_max ) ;
#line 157
void channel_free(Channel *c ) ;
#line 158
void channel_free_all(void) ;
#line 159
void channel_stop_listening(void) ;
#line 161
void channel_send_open(int id ) ;
#line 162
void channel_request_start(int id , char *service , int wantconfirm ) ;
#line 163
void channel_register_cleanup(int id , channel_callback_fn *fn ) ;
#line 164
void channel_register_confirm(int id , channel_callback_fn *fn ) ;
#line 165
void channel_register_filter(int id , channel_filter_fn *fn ) ;
#line 166
void channel_cancel_cleanup(int id ) ;
#line 167
int channel_close_fd(int *fdp ) ;
#line 171
void channel_input_close(int type , u_int32_t seq , void *ctxt ) ;
#line 172
void channel_input_close_confirmation(int type , u_int32_t seq , void *ctxt ) ;
#line 173
void channel_input_data(int type , u_int32_t seq , void *ctxt ) ;
#line 174
void channel_input_extended_data(int type , u_int32_t seq , void *ctxt ) ;
#line 175
void channel_input_ieof(int type , u_int32_t seq , void *ctxt ) ;
#line 176
void channel_input_oclose(int type , u_int32_t seq , void *ctxt ) ;
#line 177
void channel_input_open_confirmation(int type , u_int32_t seq , void *ctxt ) ;
#line 178
void channel_input_open_failure(int type , u_int32_t seq , void *ctxt ) ;
#line 179
void channel_input_port_open(int type , u_int32_t seq , void *ctxt ) ;
#line 180
void channel_input_window_adjust(int type , u_int32_t seq , void *ctxt ) ;
#line 184
void channel_prepare_select(fd_set **readsetp , fd_set **writesetp , int *maxfdp ,
                            int *nallocp , int rekeying___0 ) ;
#line 185
void channel_after_select(fd_set *readset , fd_set *writeset ) ;
#line 186
void channel_output_poll(void) ;
#line 188
int channel_not_very_much_buffered_data(void) ;
#line 189
void channel_close_all(void) ;
#line 190
int channel_still_open(void) ;
#line 191
char *channel_open_message(void) ;
#line 192
int channel_find_open(void) ;
#line 195
void channel_set_af(int af ) ;
#line 196
void channel_permit_all_opens(void) ;
#line 197
void channel_add_permitted_opens(char *host , int port ) ;
#line 198
void channel_clear_permitted_opens(void) ;
#line 199
void channel_input_port_forward_request(int is_root , int gateway_ports ) ;
#line 200
int channel_connect_to(char const   *host , u_short port ) ;
#line 201
int channel_connect_by_listen_address(u_short listen_port ) ;
#line 202
void channel_request_remote_forwarding(u_short listen_port , char const   *host_to_connect ,
                                       u_short port_to_connect ) ;
#line 203
int channel_setup_local_fwd_listener(u_short listen_port , char const   *host_to_connect ,
                                     u_short port_to_connect , int gateway_ports ) ;
#line 204
int channel_setup_remote_fwd_listener(char const   *listen_address , u_short listen_port ,
                                      int gateway_ports ) ;
#line 208
int x11_connect_display(void) ;
#line 209
int x11_create_display_inet(int x11_display_offset , int x11_use_localhost , int single_connection ,
                            u_int *display_numberp ) ;
#line 210
void x11_input_open(int type , u_int32_t seq , void *ctxt ) ;
#line 211
void x11_request_forwarding_with_spoofing(int client_session_id , char const   *proto ,
                                          char const   *data ) ;
#line 212
void deny_input_open(int type , u_int32_t seq , void *ctxt ) ;
#line 216
void auth_request_forwarding(void) ;
#line 220
int chan_is_dead(Channel *c , int send___0 ) ;
#line 221
void chan_mark_dead(Channel *c ) ;
#line 225
void chan_rcvd_oclose(Channel *c ) ;
#line 226
void chan_read_failed(Channel *c ) ;
#line 227
void chan_ibuf_empty(Channel *c ) ;
#line 229
void chan_rcvd_ieof(Channel *c ) ;
#line 230
void chan_write_failed(Channel *c ) ;
#line 231
void chan_obuf_empty(Channel *c ) ;
#line 65 "compat.h"
int compat13 ;
#line 66
int compat20 ;
#line 65 "channels.c"
static Channel **channels  =    (Channel **)((void *)0);
#line 71 "channels.c"
static int channels_alloc  =    0;
#line 77 "channels.c"
static int channel_max_fd  =    0;
#line 95 "channels.c"
static ForwardPermission permitted_opens[100]  ;
#line 98 "channels.c"
static int num_permitted_opens  =    0;
#line 104 "channels.c"
static int all_opens_permitted  =    0;
#line 113 "channels.c"
static char *x11_saved_proto  =    (char *)((void *)0);
#line 116 "channels.c"
static char *x11_saved_data  =    (char *)((void *)0);
#line 117 "channels.c"
static u_int x11_saved_data_len  =    (u_int )0;
#line 123 "channels.c"
static char *x11_fake_data  =    (char *)((void *)0);
#line 124 "channels.c"
static u_int x11_fake_data_len  ;
#line 132 "channels.c"
static int IPv4or6___0  =    0;
#line 135
static void port_open_helper(Channel *c , char *rtype ) ;
#line 139 "channels.c"
Channel *channel_lookup(int id ) 
{ Channel *c ;

  {
#line 144
  if (id < 0) {
#line 145
    logit("channel_lookup: %d: bad id", id);
#line 146
    return ((Channel *)((void *)0));
  } else {
#line 144
    if (id >= channels_alloc) {
#line 145
      logit("channel_lookup: %d: bad id", id);
#line 146
      return ((Channel *)((void *)0));
    }
  }
#line 148
  c = *(channels + id);
#line 149
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 150
    logit("channel_lookup: %d: bad id: channel free", id);
#line 151
    return ((Channel *)((void *)0));
  }
#line 153
  return (c);
}
}
#line 161 "channels.c"
static void channel_register_fds(Channel *c , int rfd , int wfd , int efd , int extusage ,
                                 int nonblock ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 166
  if (channel_max_fd > rfd) {
#line 166
    channel_max_fd = channel_max_fd;
  } else {
#line 166
    channel_max_fd = rfd;
  }
#line 167
  if (channel_max_fd > wfd) {
#line 167
    channel_max_fd = channel_max_fd;
  } else {
#line 167
    channel_max_fd = wfd;
  }
#line 168
  if (channel_max_fd > efd) {
#line 168
    channel_max_fd = channel_max_fd;
  } else {
#line 168
    channel_max_fd = efd;
  }
#line 172
  c->rfd = rfd;
#line 173
  c->wfd = wfd;
#line 174
  if (rfd == wfd) {
#line 174
    c->sock = rfd;
  } else {
#line 174
    c->sock = -1;
  }
#line 175
  c->efd = efd;
#line 176
  c->extended_usage = extusage;
#line 179
  if (nonblock) {
#line 179
    tmp___0 = isatty(c->rfd);
#line 179
    if (tmp___0) {
#line 180
      debug2("channel %d: rfd %d isatty", c->self, c->rfd);
#line 181
      c->isatty = 1;
#line 182
      tmp = isatty(c->wfd);
#line 182
      if (! tmp) {
#line 183
        error("channel %d: wfd %d is not a tty?", c->self, c->wfd);
      }
    } else {
#line 187
      c->isatty = 0;
    }
  } else {
#line 187
    c->isatty = 0;
  }
#line 189
  c->wfd_isatty = isatty(c->wfd);
#line 192
  if (nonblock) {
#line 193
    if (rfd != -1) {
#line 194
      set_nonblock(rfd);
    }
#line 195
    if (wfd != -1) {
#line 196
      set_nonblock(wfd);
    }
#line 197
    if (efd != -1) {
#line 198
      set_nonblock(efd);
    }
  }
#line 200
  return;
}
}
#line 207 "channels.c"
Channel *channel_new(char *ctype , int type , int rfd , int wfd , int efd , u_int window ,
                     u_int maxpack , int extusage , char *remote_name , int nonblock ) 
{ int i ;
  int found ;
  Channel *c ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 215
  if (channels_alloc == 0) {
#line 216
    channels_alloc = 10;
#line 217
    tmp = xmalloc((unsigned int )channels_alloc * sizeof(Channel *));
#line 217
    channels = (Channel **)tmp;
#line 218
    i = 0;
#line 218
    while (i < channels_alloc) {
#line 219
      *(channels + i) = (Channel *)((void *)0);
#line 218
      i ++;
    }
  }
#line 222
  found = -1;
#line 222
  i = 0;
#line 222
  while (i < channels_alloc) {
#line 223
    if ((unsigned int )*(channels + i) == (unsigned int )((void *)0)) {
#line 225
      found = i;
#line 226
      break;
    }
#line 222
    i ++;
  }
#line 228
  if (found == -1) {
#line 230
    found = channels_alloc;
#line 231
    if (channels_alloc > 10000) {
#line 232
      fatal("channel_new: internal error: channels_alloc %d too big.", channels_alloc);
    }
#line 234
    tmp___0 = xrealloc((void *)channels, (unsigned int )(channels_alloc + 10) * sizeof(Channel *));
#line 234
    channels = (Channel **)tmp___0;
#line 236
    channels_alloc += 10;
#line 237
    debug2("channel: expanding %d", channels_alloc);
#line 238
    i = found;
#line 238
    while (i < channels_alloc) {
#line 239
      *(channels + i) = (Channel *)((void *)0);
#line 238
      i ++;
    }
  }
#line 242
  tmp___1 = xmalloc(sizeof(Channel ));
#line 242
  *(channels + found) = (Channel *)tmp___1;
#line 242
  c = *(channels + found);
#line 243
  memset((void *)c, 0, sizeof(Channel ));
#line 244
  buffer_init(& c->input);
#line 245
  buffer_init(& c->output);
#line 246
  buffer_init(& c->extended);
#line 247
  c->ostate = 0U;
#line 248
  c->istate = 0U;
#line 249
  c->flags = 0;
#line 250
  channel_register_fds(c, rfd, wfd, efd, extusage, nonblock);
#line 251
  c->self = found;
#line 252
  c->type = type;
#line 253
  c->ctype = ctype;
#line 254
  c->local_window = window;
#line 255
  c->local_window_max = window;
#line 256
  c->local_consumed = 0U;
#line 257
  c->local_maxpacket = maxpack;
#line 258
  c->remote_id = -1;
#line 259
  c->remote_name = xstrdup((char const   *)remote_name);
#line 260
  c->remote_window = 0U;
#line 261
  c->remote_maxpacket = 0U;
#line 262
  c->force_drain = 0;
#line 263
  c->single_connection = 0;
#line 264
  c->detach_user = (channel_callback_fn *)((void *)0);
#line 265
  c->confirm = (channel_callback_fn *)((void *)0);
#line 266
  c->input_filter = (channel_filter_fn *)((void *)0);
#line 267
  debug("channel %d: new [%s]", found, remote_name);
#line 268
  return (c);
}
}
#line 271 "channels.c"
static int channel_find_maxfd(void) 
{ int i ;
  int max ;
  Channel *c ;

  {
#line 274
  max = 0;
#line 277
  i = 0;
#line 277
  while (i < channels_alloc) {
#line 278
    c = *(channels + i);
#line 279
    if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 280
      if (max > c->rfd) {
#line 280
        max = max;
      } else {
#line 280
        max = c->rfd;
      }
#line 281
      if (max > c->wfd) {
#line 281
        max = max;
      } else {
#line 281
        max = c->wfd;
      }
#line 282
      if (max > c->efd) {
#line 282
        max = max;
      } else {
#line 282
        max = c->efd;
      }
    }
#line 277
    i ++;
  }
#line 285
  return (max);
}
}
#line 288 "channels.c"
int channel_close_fd(int *fdp ) 
{ int ret ;
  int fd ;

  {
#line 291
  ret = 0;
#line 291
  fd = *fdp;
#line 293
  if (fd != -1) {
#line 294
    ret = close(fd);
#line 295
    *fdp = -1;
#line 296
    if (fd == channel_max_fd) {
#line 297
      channel_max_fd = channel_find_maxfd();
    }
  }
#line 299
  return (ret);
}
}
#line 304 "channels.c"
static void channel_close_fds(Channel *c ) 
{ 

  {
#line 307
  debug3("channel %d: close_fds r %d w %d e %d", c->self, c->rfd, c->wfd, c->efd);
#line 310
  channel_close_fd(& c->sock);
#line 311
  channel_close_fd(& c->rfd);
#line 312
  channel_close_fd(& c->wfd);
#line 313
  channel_close_fd(& c->efd);
#line 314
  return;
}
}
#line 318 "channels.c"
void channel_free(Channel *c ) 
{ char *s ;
  int i ;
  int n___0 ;
  char const   *tmp ;

  {
#line 324
  n___0 = 0;
#line 324
  i = 0;
#line 324
  while (i < channels_alloc) {
#line 325
    if (*(channels + i)) {
#line 326
      n___0 ++;
    }
#line 324
    i ++;
  }
#line 327
  if (c->remote_name) {
#line 327
    tmp = (char const   *)c->remote_name;
  } else {
#line 327
    tmp = "???";
  }
#line 327
  debug("channel %d: free: %s, nchannels %d", c->self, tmp, n___0);
#line 330
  s = channel_open_message();
#line 331
  debug3("channel %d: status: %s", c->self, s);
#line 332
  xfree((void *)s);
#line 334
  if (c->sock != -1) {
#line 335
    shutdown(c->sock, 2);
  }
#line 336
  channel_close_fds(c);
#line 337
  buffer_free(& c->input);
#line 338
  buffer_free(& c->output);
#line 339
  buffer_free(& c->extended);
#line 340
  if (c->remote_name) {
#line 341
    xfree((void *)c->remote_name);
#line 342
    c->remote_name = (char *)((void *)0);
  }
#line 344
  *(channels + c->self) = (Channel *)((void *)0);
#line 345
  xfree((void *)c);
#line 346
  return;
}
}
#line 348 "channels.c"
void channel_free_all(void) 
{ int i ;

  {
#line 353
  i = 0;
#line 353
  while (i < channels_alloc) {
#line 354
    if ((unsigned int )*(channels + i) != (unsigned int )((void *)0)) {
#line 355
      channel_free(*(channels + i));
    }
#line 353
    i ++;
  }
#line 356
  return;
}
}
#line 363 "channels.c"
void channel_close_all(void) 
{ int i ;

  {
#line 368
  i = 0;
#line 368
  while (i < channels_alloc) {
#line 369
    if ((unsigned int )*(channels + i) != (unsigned int )((void *)0)) {
#line 370
      channel_close_fds(*(channels + i));
    }
#line 368
    i ++;
  }
#line 371
  return;
}
}
#line 377 "channels.c"
void channel_stop_listening(void) 
{ int i ;
  Channel *c ;

  {
#line 383
  i = 0;
#line 383
  while (i < channels_alloc) {
#line 384
    c = *(channels + i);
#line 385
    if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 386
      switch (c->type) {
      case 6: 
      case 2: 
      case 11: 
      case 1: 
#line 391
      channel_close_fd(& c->sock);
#line 392
      channel_free(c);
#line 393
      break;
      }
    }
#line 383
    i ++;
  }
#line 397
  return;
}
}
#line 404 "channels.c"
int channel_not_very_much_buffered_data(void) 
{ u_int i ;
  Channel *c ;
  u_int tmp ;
  u_int tmp___0 ;

  {
#line 410
  i = 0U;
#line 410
  while (i < (u_int )channels_alloc) {
#line 411
    c = *(channels + i);
#line 412
    if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 412
      if (c->type == 4) {
#line 421
        tmp___0 = buffer_len(& c->output);
#line 421
        if (tmp___0 > max_packet_size) {
#line 422
          tmp = buffer_len(& c->output);
#line 422
          debug2("channel %d: big output buffer %u > %u", c->self, tmp, max_packet_size);
#line 425
          return (0);
        }
      }
    }
#line 410
    i ++;
  }
#line 429
  return (1);
}
}
#line 434 "channels.c"
int channel_still_open(void) 
{ int i ;
  Channel *c ;

  {
#line 440
  i = 0;
#line 440
  while (i < channels_alloc) {
#line 441
    c = *(channels + i);
#line 442
    if ((unsigned int )c == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 444
    switch (c->type) {
    case 1: 
    case 2: 
    case 11: 
    case 5: 
    case 6: 
    case 13: 
    case 12: 
    case 14: 
    goto __Cont;
    case 10: 
#line 455
    if (! compat20) {
#line 456
      fatal("cannot happen: SSH_CHANNEL_LARVAL");
    }
    goto __Cont;
    case 3: 
    case 4: 
    case 7: 
#line 461
    return (1);
    case 8: 
    case 9: 
#line 464
    if (! compat13) {
#line 465
      fatal("cannot happen: OUT_DRAIN");
    }
#line 466
    return (1);
    default: 
#line 468
    fatal("channel_still_open: bad channel type %d", c->type);
    }
    __Cont: /* CIL Label */ 
#line 440
    i ++;
  }
#line 472
  return (0);
}
}
#line 477 "channels.c"
int channel_find_open(void) 
{ int i ;
  Channel *c ;

  {
#line 483
  i = 0;
#line 483
  while (i < channels_alloc) {
#line 484
    c = *(channels + i);
#line 485
    if ((unsigned int )c == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 487
    switch (c->type) {
    case 5: 
    case 13: 
    case 1: 
    case 2: 
    case 11: 
    case 3: 
    case 12: 
    case 14: 
    goto __Cont;
    case 10: 
    case 6: 
    case 4: 
    case 7: 
#line 501
    return (i);
    case 8: 
    case 9: 
#line 504
    if (! compat13) {
#line 505
      fatal("cannot happen: OUT_DRAIN");
    }
#line 506
    return (i);
    default: 
#line 508
    fatal("channel_find_open: bad channel type %d", c->type);
    }
    __Cont: /* CIL Label */ 
#line 483
    i ++;
  }
#line 512
  return (-1);
}
}
#line 522 "channels.c"
char *channel_open_message(void) 
{ Buffer buffer ;
  Channel *c ;
  char buf___1[1024] ;
  char *cp ;
  int i ;
  size_t tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
#line 530
  buffer_init(& buffer);
#line 531
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"The following connections are open:\r\n");
#line 532
  tmp = strlen((char const   *)(buf___1));
#line 532
  buffer_append(& buffer, (void const   *)(buf___1), tmp);
#line 533
  i = 0;
#line 533
  while (i < channels_alloc) {
#line 534
    c = *(channels + i);
#line 535
    if ((unsigned int )c == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 537
    switch (c->type) {
    case 1: 
    case 2: 
    case 11: 
    case 5: 
    case 6: 
    case 14: 
    goto __Cont;
    case 10: 
    case 3: 
    case 12: 
    case 13: 
    case 4: 
    case 7: 
    case 8: 
    case 9: 
#line 553
    tmp___0 = buffer_len(& c->output);
#line 553
    tmp___1 = buffer_len(& c->input);
#line 553
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"  #%d %.300s (t%d r%d i%d/%d o%d/%d fd %d/%d)\r\n",
             c->self, c->remote_name, c->type, c->remote_id, c->istate, tmp___1, c->ostate,
             tmp___0, c->rfd, c->wfd);
#line 559
    tmp___2 = strlen((char const   *)(buf___1));
#line 559
    buffer_append(& buffer, (void const   *)(buf___1), tmp___2);
    goto __Cont;
    default: 
#line 562
    fatal("channel_open_message: bad channel type %d", c->type);
    }
    __Cont: /* CIL Label */ 
#line 533
    i ++;
  }
#line 566
  buffer_append(& buffer, (void const   *)"\000", 1U);
#line 567
  tmp___3 = buffer_ptr(& buffer);
#line 567
  cp = xstrdup((char const   *)tmp___3);
#line 568
  buffer_free(& buffer);
#line 569
  return (cp);
}
}
#line 572 "channels.c"
void channel_send_open(int id ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 575
  tmp = channel_lookup(id);
#line 575
  c = tmp;
#line 577
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 578
    logit("channel_send_open: %d: bad id", id);
#line 579
    return;
  }
#line 581
  debug2("channel %d: send open", id);
#line 582
  packet_start((unsigned char)90);
#line 583
  packet_put_cstring((char const   *)c->ctype);
#line 584
  packet_put_int((unsigned int )c->self);
#line 585
  packet_put_int(c->local_window);
#line 586
  packet_put_int(c->local_maxpacket);
#line 587
  packet_send();
#line 588
  return;
}
}
#line 590 "channels.c"
void channel_request_start(int id , char *service , int wantconfirm ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 593
  tmp = channel_lookup(id);
#line 593
  c = tmp;
#line 595
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 596
    logit("channel_request_start: %d: unknown channel id", id);
#line 597
    return;
  }
#line 599
  debug2("channel %d: request %s", id, service);
#line 600
  packet_start((unsigned char)98);
#line 601
  packet_put_int((unsigned int )c->remote_id);
#line 602
  packet_put_cstring((char const   *)service);
#line 603
  packet_put_char(wantconfirm);
#line 604
  return;
}
}
#line 605 "channels.c"
void channel_register_confirm(int id , channel_callback_fn *fn ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 608
  tmp = channel_lookup(id);
#line 608
  c = tmp;
#line 610
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 611
    logit("channel_register_comfirm: %d: bad id", id);
#line 612
    return;
  }
#line 614
  c->confirm = fn;
#line 615
  return;
}
}
#line 616 "channels.c"
void channel_register_cleanup(int id , channel_callback_fn *fn ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 619
  tmp = channel_lookup(id);
#line 619
  c = tmp;
#line 621
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 622
    logit("channel_register_cleanup: %d: bad id", id);
#line 623
    return;
  }
#line 625
  c->detach_user = fn;
#line 626
  return;
}
}
#line 627 "channels.c"
void channel_cancel_cleanup(int id ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 630
  tmp = channel_lookup(id);
#line 630
  c = tmp;
#line 632
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 633
    logit("channel_cancel_cleanup: %d: bad id", id);
#line 634
    return;
  }
#line 636
  c->detach_user = (channel_callback_fn *)((void *)0);
#line 637
  return;
}
}
#line 638 "channels.c"
void channel_register_filter(int id , channel_filter_fn *fn ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 641
  tmp = channel_lookup(id);
#line 641
  c = tmp;
#line 643
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 644
    logit("channel_register_filter: %d: bad id", id);
#line 645
    return;
  }
#line 647
  c->input_filter = fn;
#line 648
  return;
}
}
#line 650 "channels.c"
void channel_set_fds(int id , int rfd , int wfd , int efd , int extusage , int nonblock ,
                     u_int window_max ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 654
  tmp = channel_lookup(id);
#line 654
  c = tmp;
#line 656
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 657
    fatal("channel_activate for non-larval channel %d.", id);
  } else {
#line 656
    if (c->type != 10) {
#line 657
      fatal("channel_activate for non-larval channel %d.", id);
    }
  }
#line 658
  channel_register_fds(c, rfd, wfd, efd, extusage, nonblock);
#line 659
  c->type = 4;
#line 660
  c->local_window_max = window_max;
#line 660
  c->local_window = c->local_window_max;
#line 661
  packet_start((unsigned char)93);
#line 662
  packet_put_int((unsigned int )c->remote_id);
#line 663
  packet_put_int(c->local_window);
#line 664
  packet_send();
#line 665
  return;
}
}
#line 676 "channels.c"
chan_fn *channel_pre[15]  ;
#line 677 "channels.c"
chan_fn *channel_post[15]  ;
#line 679 "channels.c"
static void channel_pre_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 682
  __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 683
  return;
}
}
#line 685 "channels.c"
static void channel_pre_connecting(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 688
  debug3("channel %d: waiting for connection", c->self);
#line 689
  __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 690
  return;
}
}
#line 692 "channels.c"
static void channel_pre_open_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int tmp ;
  u_int tmp___0 ;

  {
#line 695
  tmp = buffer_len(& c->input);
#line 695
  if (tmp < max_packet_size) {
#line 696
    __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 697
  tmp___0 = buffer_len(& c->output);
#line 697
  if (tmp___0 > 0U) {
#line 698
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 699
  return;
}
}
#line 701 "channels.c"
static void channel_pre_open(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int limit ;
  u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;

  {
#line 704
  if (compat20) {
#line 704
    tmp = c->remote_window;
  } else {
#line 704
    tmp = max_packet_size;
  }
#line 704
  limit = tmp;
#line 706
  if (c->istate == 0U) {
#line 706
    if (limit > 0U) {
#line 706
      tmp___0 = buffer_len(& c->input);
#line 706
      if (tmp___0 < limit) {
#line 709
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->rfd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->rfd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
  }
#line 710
  if (c->ostate == 0U) {
    goto _L___0;
  } else {
#line 710
    if (c->ostate == 1U) {
      _L___0: /* CIL Label */ 
#line 712
      tmp___3 = buffer_len(& c->output);
#line 712
      if (tmp___3 > 0U) {
#line 713
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->wfd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->wfd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      } else {
#line 714
        if (c->ostate == 1U) {
#line 715
          if (compat20) {
#line 715
            if (c->extended_usage == 2) {
#line 715
              if (c->efd != -1) {
#line 715
                if (! (c->flags & 10)) {
#line 716
                  tmp___1 = buffer_len(& c->extended);
#line 716
                  debug2("channel %d: obuf_empty delayed efd %d/(%d)", c->self, c->efd,
                         tmp___1);
                } else {
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
#line 715
                tmp___2 = buffer_len(& c->extended);
#line 715
                if (tmp___2 > 0U) {
#line 716
                  tmp___1 = buffer_len(& c->extended);
#line 716
                  debug2("channel %d: obuf_empty delayed efd %d/(%d)", c->self, c->efd,
                         tmp___1);
                } else {
#line 719
                  chan_obuf_empty(c);
                }
              }
            } else {
#line 719
              chan_obuf_empty(c);
            }
          } else {
#line 719
            chan_obuf_empty(c);
          }
        }
      }
    }
  }
#line 723
  if (compat20) {
#line 723
    if (c->efd != -1) {
#line 724
      if (c->extended_usage == 2) {
#line 724
        tmp___5 = buffer_len(& c->extended);
#line 724
        if (tmp___5 > 0U) {
#line 726
          __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        } else {
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 727
        if (! (c->flags & 4)) {
#line 727
          if (c->extended_usage == 1) {
#line 727
            tmp___4 = buffer_len(& c->extended);
#line 727
            if (tmp___4 < c->remote_window) {
#line 730
              __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))): "cc",
                                   "memory");
            }
          }
        }
      }
    }
  }
#line 732
  return;
}
}
#line 734 "channels.c"
static void channel_pre_input_draining(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int tmp ;

  {
#line 737
  tmp = buffer_len(& c->input);
#line 737
  if (tmp == 0U) {
#line 738
    packet_start((unsigned char)24);
#line 739
    packet_put_int((unsigned int )c->remote_id);
#line 740
    packet_send();
#line 741
    c->type = 5;
#line 742
    debug2("channel %d: closing after input drain.", c->self);
  }
#line 744
  return;
}
}
#line 746 "channels.c"
static void channel_pre_output_draining(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int tmp ;

  {
#line 749
  tmp = buffer_len(& c->output);
#line 749
  if (tmp == 0U) {
#line 750
    chan_mark_dead(c);
  } else {
#line 752
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 753
  return;
}
}
#line 764 "channels.c"
static int x11_open_helper(Buffer *b ) 
{ u_char *ucp ;
  u_int proto_len ;
  u_int data_len ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 771
  tmp = buffer_len(b);
#line 771
  if (tmp < 12U) {
#line 772
    return (0);
  }
#line 775
  tmp___0 = buffer_ptr(b);
#line 775
  ucp = (u_char *)tmp___0;
#line 776
  if ((int )*(ucp + 0) == 66) {
#line 777
    proto_len = (unsigned int )(256 * (int )*(ucp + 6) + (int )*(ucp + 7));
#line 778
    data_len = (unsigned int )(256 * (int )*(ucp + 8) + (int )*(ucp + 9));
  } else {
#line 779
    if ((int )*(ucp + 0) == 108) {
#line 780
      proto_len = (unsigned int )((int )*(ucp + 6) + 256 * (int )*(ucp + 7));
#line 781
      data_len = (unsigned int )((int )*(ucp + 8) + 256 * (int )*(ucp + 9));
    } else {
#line 783
      debug2("Initial X11 packet contains bad byte order byte: 0x%x", *(ucp + 0));
#line 785
      return (-1);
    }
  }
#line 789
  tmp___1 = buffer_len(b);
#line 789
  if (tmp___1 < (12U + ((proto_len + 3U) & 4294967292U)) + ((data_len + 3U) & 4294967292U)) {
#line 791
    return (0);
  }
#line 794
  tmp___2 = strlen((char const   *)x11_saved_proto);
#line 794
  if (proto_len != tmp___2) {
#line 796
    debug2("X11 connection uses different authentication protocol.");
#line 797
    return (-1);
  } else {
#line 794
    tmp___3 = memcmp((void const   *)(ucp + 12), (void const   *)x11_saved_proto,
                     proto_len);
#line 794
    if (tmp___3 != 0) {
#line 796
      debug2("X11 connection uses different authentication protocol.");
#line 797
      return (-1);
    }
  }
#line 800
  if (data_len != x11_fake_data_len) {
#line 803
    debug2("X11 auth data does not match fake data.");
#line 804
    return (-1);
  } else {
#line 800
    tmp___4 = memcmp((void const   *)((ucp + 12) + ((proto_len + 3U) & 4294967292U)),
                     (void const   *)x11_fake_data, x11_fake_data_len);
#line 800
    if (tmp___4 != 0) {
#line 803
      debug2("X11 auth data does not match fake data.");
#line 804
      return (-1);
    }
  }
#line 807
  if (x11_fake_data_len != x11_saved_data_len) {
#line 808
    error("X11 fake_data_len %d != saved_data_len %d", x11_fake_data_len, x11_saved_data_len);
#line 810
    return (-1);
  }
#line 817
  memcpy((void * __restrict  )((ucp + 12) + ((proto_len + 3U) & 4294967292U)), (void const   * __restrict  )x11_saved_data,
         x11_saved_data_len);
#line 819
  return (1);
}
}
#line 822 "channels.c"
static void channel_pre_x11_open_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int ret ;
  int tmp ;

  {
#line 825
  tmp = x11_open_helper(& c->output);
#line 825
  ret = tmp;
#line 827
  if (ret == 1) {
#line 829
    c->type = 4;
#line 830
    channel_pre_open_13(c, readset, writeset);
  } else {
#line 831
    if (ret == -1) {
#line 836
      logit("X11 connection rejected because of wrong authentication.");
#line 837
      buffer_clear(& c->input);
#line 838
      buffer_clear(& c->output);
#line 839
      channel_close_fd(& c->sock);
#line 840
      c->sock = -1;
#line 841
      c->type = 5;
#line 842
      packet_start((unsigned char)24);
#line 843
      packet_put_int((unsigned int )c->remote_id);
#line 844
      packet_send();
    }
  }
#line 846
  return;
}
}
#line 848 "channels.c"
static void channel_pre_x11_open(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int ret ;
  int tmp ;

  {
#line 851
  tmp = x11_open_helper(& c->output);
#line 851
  ret = tmp;
#line 855
  if (ret == 1) {
#line 856
    c->type = 4;
#line 857
    channel_pre_open(c, readset, writeset);
  } else {
#line 858
    if (ret == -1) {
#line 859
      logit("X11 connection rejected because of wrong authentication.");
#line 860
      debug2("X11 rejected %d i%d/o%d", c->self, c->istate, c->ostate);
#line 861
      chan_read_failed(c);
#line 862
      buffer_clear(& c->input);
#line 863
      chan_ibuf_empty(c);
#line 864
      buffer_clear(& c->output);
#line 866
      if (compat20) {
#line 867
        chan_write_failed(c);
      } else {
#line 869
        c->type = 4;
      }
#line 870
      debug2("X11 closed %d i%d/o%d", c->self, c->istate, c->ostate);
    }
  }
#line 872
  return;
}
}
#line 875 "channels.c"
static int channel_decode_socks4(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char *p ;
  char *host ;
  int len ;
  int have ;
  int i ;
  int found ;
  char username[256] ;
  struct __anonstruct_s4_req_78 s4_req ;
  struct __anonstruct_s4_req_78 s4_rsp ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  register unsigned short __v ;
  register unsigned short __x ;

  {
#line 888
  debug2("channel %d: decode socks4", c->self);
#line 890
  tmp = buffer_len(& c->input);
#line 890
  have = (int )tmp;
#line 891
  len = (int )sizeof(s4_req);
#line 892
  if (have < len) {
#line 893
    return (0);
  }
#line 894
  tmp___0 = buffer_ptr(& c->input);
#line 894
  p = (char *)tmp___0;
#line 895
  found = 0;
#line 895
  i = len;
#line 895
  while (i < have) {
#line 896
    if ((int )*(p + i) == 0) {
#line 897
      found = 1;
#line 898
      break;
    }
#line 900
    if (i > 1024) {
#line 902
      debug("channel %d: decode socks4: too long", c->self);
#line 904
      return (-1);
    }
#line 895
    i ++;
  }
#line 907
  if (! found) {
#line 908
    return (0);
  }
#line 909
  buffer_get(& c->input, (void *)((char *)(& s4_req.version)), 1U);
#line 910
  buffer_get(& c->input, (void *)((char *)(& s4_req.command)), 1U);
#line 911
  buffer_get(& c->input, (void *)((char *)(& s4_req.dest_port)), 2U);
#line 912
  buffer_get(& c->input, (void *)((char *)(& s4_req.dest_addr)), 4U);
#line 913
  tmp___1 = buffer_len(& c->input);
#line 913
  have = (int )tmp___1;
#line 914
  tmp___2 = buffer_ptr(& c->input);
#line 914
  p = (char *)tmp___2;
#line 915
  tmp___3 = strlen((char const   *)p);
#line 915
  len = (int )tmp___3;
#line 916
  debug2("channel %d: decode socks4: user %s/%d", c->self, p, len);
#line 917
  if (len > have) {
#line 918
    fatal("channel %d: decode socks4: len %d > have %d", c->self, len, have);
  }
#line 920
  strlcpy(username, (char const   *)p, sizeof(username));
#line 921
  buffer_consume(& c->input, (unsigned int )len);
#line 922
  buffer_consume(& c->input, 1U);
#line 924
  host = inet_ntoa(s4_req.dest_addr);
#line 925
  strlcpy(c->path, (char const   *)host, sizeof(c->path));
#line 926
  __x = s4_req.dest_port;
#line 926
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 926
  c->host_port = (int )__v;
#line 928
  debug2("channel %d: dynamic request: socks4 host %s port %u command %u", c->self,
         host, c->host_port, s4_req.command);
#line 931
  if ((int )s4_req.command != 1) {
#line 932
    debug("channel %d: cannot handle: socks4 cn %d", c->self, s4_req.command);
#line 934
    return (-1);
  }
#line 936
  s4_rsp.version = (unsigned char)0;
#line 937
  s4_rsp.command = (unsigned char)90;
#line 938
  s4_rsp.dest_port = (unsigned short)0;
#line 939
  s4_rsp.dest_addr.s_addr = 0U;
#line 940
  buffer_append(& c->output, (void const   *)((char *)(& s4_rsp)), sizeof(s4_rsp));
#line 941
  return (1);
}
}
#line 953 "channels.c"
static int channel_decode_socks5(Channel *c , fd_set *readset , fd_set *writeset ) 
{ struct __anonstruct_s5_req_79 s5_req ;
  struct __anonstruct_s5_req_79 s5_rsp ;
  u_int16_t dest_port ;
  u_char *p ;
  u_char dest_addr[256] ;
  int i ;
  int have ;
  int found ;
  int nmethods ;
  int addrlen ;
  int af ;
  void *tmp ;
  u_int tmp___0 ;
  char const   *tmp___1 ;
  register unsigned short __v ;
  register unsigned short __x ;

  {
#line 966
  debug2("channel %d: decode socks5", c->self);
#line 967
  tmp = buffer_ptr(& c->input);
#line 967
  p = (u_char *)tmp;
#line 968
  if ((int )*(p + 0) != 5) {
#line 969
    return (-1);
  }
#line 970
  tmp___0 = buffer_len(& c->input);
#line 970
  have = (int )tmp___0;
#line 971
  if (! (c->flags & 4096)) {
#line 973
    if (have < 2) {
#line 974
      return (0);
    }
#line 975
    nmethods = (int )*(p + 1);
#line 976
    if (have < nmethods + 2) {
#line 977
      return (0);
    }
#line 979
    found = 0;
#line 979
    i = 2;
#line 979
    while (i < nmethods + 2) {
#line 980
      if ((int )*(p + i) == 0) {
#line 981
        found = 1;
#line 982
        break;
      }
#line 979
      i ++;
    }
#line 985
    if (! found) {
#line 986
      debug("channel %d: method SSH_SOCKS5_NOAUTH not found", c->self);
#line 988
      return (-1);
    }
#line 990
    buffer_consume(& c->input, (unsigned int )(nmethods + 2));
#line 991
    buffer_put_char(& c->output, 5);
#line 992
    buffer_put_char(& c->output, 0);
#line 993
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 994
    c->flags |= 4096;
#line 995
    debug2("channel %d: socks5 auth done", c->self);
#line 996
    return (0);
  }
#line 998
  debug2("channel %d: socks5 post auth", c->self);
#line 999
  if ((unsigned int )have < sizeof(s5_req) + 1U) {
#line 1000
    return (0);
  }
#line 1001
  memcpy((void * __restrict  )((char *)(& s5_req)), (void const   * __restrict  )p,
         sizeof(s5_req));
#line 1002
  if ((int )s5_req.version != 5) {
#line 1005
    debug2("channel %d: only socks5 connect supported", c->self);
#line 1006
    return (-1);
  } else {
#line 1002
    if ((int )s5_req.command != 1) {
#line 1005
      debug2("channel %d: only socks5 connect supported", c->self);
#line 1006
      return (-1);
    } else {
#line 1002
      if ((int )s5_req.reserved != 0) {
#line 1005
        debug2("channel %d: only socks5 connect supported", c->self);
#line 1006
        return (-1);
      }
    }
  }
#line 1008
  switch ((int )s5_req.atyp) {
  case 1: 
#line 1010
  addrlen = 4;
#line 1011
  af = 2;
#line 1012
  break;
  case 3: 
#line 1014
  addrlen = (int )*(p + sizeof(s5_req));
#line 1015
  af = -1;
#line 1016
  break;
  case 4: 
#line 1018
  addrlen = 16;
#line 1019
  af = 10;
#line 1020
  break;
  default: 
#line 1022
  debug2("channel %d: bad socks5 atyp %d", c->self, s5_req.atyp);
#line 1023
  return (-1);
  }
#line 1025
  if (have < (4 + addrlen) + 2) {
#line 1026
    return (0);
  }
#line 1027
  buffer_consume(& c->input, sizeof(s5_req));
#line 1028
  if ((int )s5_req.atyp == 3) {
#line 1029
    buffer_consume(& c->input, 1U);
  }
#line 1030
  buffer_get(& c->input, (void *)((char *)(& dest_addr)), (unsigned int )addrlen);
#line 1031
  buffer_get(& c->input, (void *)((char *)(& dest_port)), 2U);
#line 1032
  dest_addr[addrlen] = (unsigned char )'\000';
#line 1033
  if ((int )s5_req.atyp == 3) {
#line 1034
    strlcpy(c->path, (char const   *)(dest_addr), sizeof(c->path));
  } else {
#line 1035
    tmp___1 = inet_ntop(af, (void const   * __restrict  )(dest_addr), (char * __restrict  )(c->path),
                        sizeof(c->path));
#line 1035
    if ((unsigned int )tmp___1 == (unsigned int )((void *)0)) {
#line 1036
      return (-1);
    }
  }
#line 1037
  __x = dest_port;
#line 1037
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 1037
  c->host_port = (int )__v;
#line 1039
  debug2("channel %d: dynamic request: socks5 host %s port %u command %u", c->self,
         c->path, c->host_port, s5_req.command);
#line 1042
  s5_rsp.version = (unsigned char)5;
#line 1043
  s5_rsp.command = (unsigned char)0;
#line 1044
  s5_rsp.reserved = (unsigned char)0;
#line 1045
  s5_rsp.atyp = (unsigned char)1;
#line 1046
  ((struct in_addr *)(& dest_addr))->s_addr = 0U;
#line 1047
  dest_port = (unsigned short)0;
#line 1049
  buffer_append(& c->output, (void const   *)((char *)(& s5_rsp)), sizeof(s5_rsp));
#line 1050
  buffer_append(& c->output, (void const   *)((char *)(& dest_addr)), sizeof(struct in_addr ));
#line 1051
  buffer_append(& c->output, (void const   *)((char *)(& dest_port)), sizeof(dest_port));
#line 1052
  return (1);
}
}
#line 1056 "channels.c"
static void channel_pre_dynamic(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_char *p ;
  int have ;
  int ret ;
  u_int tmp ;
  void *tmp___0 ;

  {
#line 1062
  tmp = buffer_len(& c->input);
#line 1062
  have = (int )tmp;
#line 1063
  c->delayed = 0;
#line 1064
  debug2("channel %d: pre_dynamic: have %d", c->self, have);
#line 1067
  if (have < 3) {
#line 1069
    __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 1070
    return;
  }
#line 1073
  tmp___0 = buffer_ptr(& c->input);
#line 1073
  p = (u_char *)tmp___0;
#line 1074
  switch ((int )*(p + 0)) {
  case 4: 
#line 1076
  ret = channel_decode_socks4(c, readset, writeset);
#line 1077
  break;
  case 5: 
#line 1079
  ret = channel_decode_socks5(c, readset, writeset);
#line 1080
  break;
  default: 
#line 1082
  ret = -1;
#line 1083
  break;
  }
#line 1085
  if (ret < 0) {
#line 1086
    chan_mark_dead(c);
  } else {
#line 1087
    if (ret == 0) {
#line 1088
      debug2("channel %d: pre_dynamic: need more", c->self);
#line 1090
      __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    } else {
#line 1093
      c->type = 3;
#line 1094
      port_open_helper(c, (char *)"direct-tcpip");
    }
  }
#line 1096
  return;
}
}
#line 1099 "channels.c"
static void channel_post_x11_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ Channel *nc ;
  struct sockaddr addr ;
  int newsock ;
  socklen_t addrlen ;
  char buf___1[16384] ;
  char *remote_ipaddr ;
  int remote_port ;
  int *tmp ;
  char *tmp___0 ;
  u_int tmp___1 ;
  register char __result ;

  {
#line 1109
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 1109
  if (__result) {
#line 1110
    debug("X11 connection requested.");
#line 1111
    addrlen = sizeof(addr);
#line 1112
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 1113
    if (c->single_connection) {
#line 1114
      debug2("single_connection: closing X11 listener.");
#line 1115
      channel_close_fd(& c->sock);
#line 1116
      chan_mark_dead(c);
    }
#line 1118
    if (newsock < 0) {
#line 1119
      tmp = __errno_location();
#line 1119
      tmp___0 = strerror(*tmp);
#line 1119
      error("accept: %.100s", tmp___0);
#line 1120
      return;
    }
#line 1122
    set_nodelay(newsock);
#line 1123
    remote_ipaddr = get_peer_ipaddr(newsock);
#line 1124
    remote_port = get_peer_port(newsock);
#line 1125
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"X11 connection from %.200s port %d",
             remote_ipaddr, remote_port);
#line 1128
    nc = channel_new((char *)"accepted x11 socket", 3, newsock, newsock, -1, c->local_window_max,
                     c->local_maxpacket, 0, buf___1, 1);
#line 1131
    if (compat20) {
#line 1132
      packet_start((unsigned char)90);
#line 1133
      packet_put_cstring("x11");
#line 1134
      packet_put_int((unsigned int )nc->self);
#line 1135
      packet_put_int(nc->local_window_max);
#line 1136
      packet_put_int(nc->local_maxpacket);
#line 1138
      packet_put_cstring((char const   *)remote_ipaddr);
#line 1139
      if (datafellows & 8) {
#line 1140
        debug2("ssh2 x11 bug compat mode");
      } else {
#line 1142
        packet_put_int((unsigned int )remote_port);
      }
#line 1144
      packet_send();
    } else {
#line 1146
      packet_start((unsigned char)27);
#line 1147
      packet_put_int((unsigned int )nc->self);
#line 1148
      tmp___1 = packet_get_protocol_flags();
#line 1148
      if (tmp___1 & 2U) {
#line 1150
        packet_put_cstring((char const   *)(buf___1));
      }
#line 1151
      packet_send();
    }
#line 1153
    xfree((void *)remote_ipaddr);
  }
#line 1155
  return;
}
}
#line 1157 "channels.c"
static void port_open_helper(Channel *c , char *rtype ) 
{ int direct ;
  char buf___1[1024] ;
  char *remote_ipaddr ;
  char *tmp ;
  u_short remote_port ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  u_int tmp___11 ;

  {
#line 1162
  tmp = get_peer_ipaddr(c->sock);
#line 1162
  remote_ipaddr = tmp;
#line 1163
  tmp___0 = get_peer_port(c->sock);
#line 1163
  remote_port = (u_short )tmp___0;
#line 1165
  if (0) {
#line 1165
    __s1_len = strlen((char const   *)rtype);
#line 1165
    __s2_len = strlen("direct-tcpip");
#line 1165
    if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
      goto _L___0;
    } else {
#line 1165
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1165
        if (! ((unsigned int )((void const   *)("direct-tcpip" + 1)) - (unsigned int )((void const   *)"direct-tcpip") == 1U)) {
#line 1165
          tmp___10 = 1;
        } else {
#line 1165
          if (__s2_len >= 4U) {
#line 1165
            tmp___10 = 1;
          } else {
#line 1165
            tmp___10 = 0;
          }
        }
      } else {
#line 1165
        tmp___10 = 0;
      }
    }
#line 1165
    if (tmp___10) {
#line 1165
      tmp___6 = __builtin_strcmp((char const   *)rtype, "direct-tcpip");
    } else {
#line 1165
      tmp___9 = __builtin_strcmp((char const   *)rtype, "direct-tcpip");
#line 1165
      tmp___6 = tmp___9;
    }
  } else {
#line 1165
    tmp___9 = __builtin_strcmp((char const   *)rtype, "direct-tcpip");
#line 1165
    tmp___6 = tmp___9;
  }
#line 1165
  direct = tmp___6 == 0;
#line 1167
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%s: listening port %d for %.100s port %d, connect from %.200s port %d",
           rtype, c->listening_port, c->path, c->host_port, remote_ipaddr, remote_port);
#line 1173
  xfree((void *)c->remote_name);
#line 1174
  c->remote_name = xstrdup((char const   *)(buf___1));
#line 1176
  if (compat20) {
#line 1177
    packet_start((unsigned char)90);
#line 1178
    packet_put_cstring((char const   *)rtype);
#line 1179
    packet_put_int((unsigned int )c->self);
#line 1180
    packet_put_int(c->local_window_max);
#line 1181
    packet_put_int(c->local_maxpacket);
#line 1182
    if (direct) {
#line 1184
      packet_put_cstring((char const   *)(c->path));
#line 1185
      packet_put_int((unsigned int )c->host_port);
    } else {
#line 1188
      packet_put_cstring((char const   *)(c->path));
#line 1189
      packet_put_int((unsigned int )c->listening_port);
    }
#line 1192
    packet_put_cstring((char const   *)remote_ipaddr);
#line 1193
    packet_put_int((unsigned int )remote_port);
#line 1194
    packet_send();
  } else {
#line 1196
    packet_start((unsigned char)29);
#line 1197
    packet_put_int((unsigned int )c->self);
#line 1198
    packet_put_cstring((char const   *)(c->path));
#line 1199
    packet_put_int((unsigned int )c->host_port);
#line 1200
    tmp___11 = packet_get_protocol_flags();
#line 1200
    if (tmp___11 & 2U) {
#line 1202
      packet_put_cstring((char const   *)c->remote_name);
    }
#line 1203
    packet_send();
  }
#line 1205
  xfree((void *)remote_ipaddr);
#line 1206
  return;
}
}
#line 1211 "channels.c"
static void channel_post_port_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ Channel *nc ;
  struct sockaddr addr ;
  int newsock ;
  int nextstate ;
  socklen_t addrlen ;
  char *rtype ;
  int *tmp ;
  char *tmp___0 ;
  register char __result ;

  {
#line 1220
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 1220
  if (__result) {
#line 1221
    debug("Connection to port %d forwarding to %.100s port %d requested.", c->listening_port,
          c->path, c->host_port);
#line 1225
    if (c->type == 11) {
#line 1226
      nextstate = 3;
#line 1227
      rtype = (char *)"forwarded-tcpip";
    } else {
#line 1229
      if (c->host_port == 0) {
#line 1230
        nextstate = 13;
#line 1231
        rtype = (char *)"dynamic-tcpip";
      } else {
#line 1233
        nextstate = 3;
#line 1234
        rtype = (char *)"direct-tcpip";
      }
    }
#line 1238
    addrlen = sizeof(addr);
#line 1239
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 1240
    if (newsock < 0) {
#line 1241
      tmp = __errno_location();
#line 1241
      tmp___0 = strerror(*tmp);
#line 1241
      error("accept: %.100s", tmp___0);
#line 1242
      return;
    }
#line 1244
    set_nodelay(newsock);
#line 1245
    nc = channel_new(rtype, nextstate, newsock, newsock, -1, c->local_window_max,
                     c->local_maxpacket, 0, rtype, 1);
#line 1247
    nc->listening_port = c->listening_port;
#line 1248
    nc->host_port = c->host_port;
#line 1249
    strlcpy(nc->path, (char const   *)(c->path), sizeof(nc->path));
#line 1251
    if (nextstate == 13) {
#line 1257
      nc->delayed = 1;
    } else {
#line 1259
      port_open_helper(nc, rtype);
    }
  }
#line 1262
  return;
}
}
#line 1268 "channels.c"
static void channel_post_auth_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ Channel *nc ;
  int newsock ;
  struct sockaddr addr ;
  socklen_t addrlen ;
  int *tmp ;
  char *tmp___0 ;
  register char __result ;

  {
#line 1276
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 1276
  if (__result) {
#line 1277
    addrlen = sizeof(addr);
#line 1278
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 1279
    if (newsock < 0) {
#line 1280
      tmp = __errno_location();
#line 1280
      tmp___0 = strerror(*tmp);
#line 1280
      error("accept from auth socket: %.100s", tmp___0);
#line 1281
      return;
    }
#line 1283
    nc = channel_new((char *)"accepted auth socket", 3, newsock, newsock, -1, c->local_window_max,
                     c->local_maxpacket, 0, (char *)"accepted auth socket", 1);
#line 1287
    if (compat20) {
#line 1288
      packet_start((unsigned char)90);
#line 1289
      packet_put_cstring("auth-agent@openssh.com");
#line 1290
      packet_put_int((unsigned int )nc->self);
#line 1291
      packet_put_int(c->local_window_max);
#line 1292
      packet_put_int(c->local_maxpacket);
    } else {
#line 1294
      packet_start((unsigned char)31);
#line 1295
      packet_put_int((unsigned int )nc->self);
    }
#line 1297
    packet_send();
  }
#line 1299
  return;
}
}
#line 1301 "channels.c"
static void channel_post_connecting(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int err ;
  socklen_t sz ;
  int *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  register char __result ;

  {
#line 1304
  err = 0;
#line 1305
  sz = sizeof(err);
#line 1307
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 1307
  if (__result) {
#line 1308
    tmp___0 = getsockopt(c->sock, 1, 4, (void * __restrict  )(& err), (socklen_t * __restrict  )(& sz));
#line 1308
    if (tmp___0 < 0) {
#line 1309
      tmp = __errno_location();
#line 1309
      err = *tmp;
#line 1310
      error("getsockopt SO_ERROR failed");
    }
#line 1312
    if (err == 0) {
#line 1313
      debug("channel %d: connected", c->self);
#line 1314
      c->type = 4;
#line 1315
      if (compat20) {
#line 1316
        packet_start((unsigned char)91);
#line 1317
        packet_put_int((unsigned int )c->remote_id);
#line 1318
        packet_put_int((unsigned int )c->self);
#line 1319
        packet_put_int(c->local_window);
#line 1320
        packet_put_int(c->local_maxpacket);
      } else {
#line 1322
        packet_start((unsigned char)21);
#line 1323
        packet_put_int((unsigned int )c->remote_id);
#line 1324
        packet_put_int((unsigned int )c->self);
      }
    } else {
#line 1327
      tmp___1 = strerror(err);
#line 1327
      debug("channel %d: not connected: %s", c->self, tmp___1);
#line 1329
      if (compat20) {
#line 1330
        packet_start((unsigned char)92);
#line 1331
        packet_put_int((unsigned int )c->remote_id);
#line 1332
        packet_put_int(2U);
#line 1333
        if (! (datafellows & 131072)) {
#line 1334
          tmp___2 = strerror(err);
#line 1334
          packet_put_cstring((char const   *)tmp___2);
#line 1335
          packet_put_cstring("");
        }
      } else {
#line 1338
        packet_start((unsigned char)22);
#line 1339
        packet_put_int((unsigned int )c->remote_id);
      }
#line 1341
      chan_mark_dead(c);
    }
#line 1343
    packet_send();
  }
#line 1345
  return;
}
}
#line 1347 "channels.c"
static int channel_handle_rfd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char buf___1[16384] ;
  int len ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  register char __result ;

  {
#line 1354
  if (c->rfd != -1) {
#line 1354
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->rfd % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )c->rfd / (8U * sizeof(__fd_mask ))]): "cc");
#line 1354
    if (__result) {
#line 1355
      len = read(c->rfd, (void *)(buf___1), sizeof(buf___1));
#line 1356
      if (len < 0) {
#line 1356
        tmp = __errno_location();
#line 1356
        if (*tmp == 4) {
#line 1357
          return (1);
        } else {
#line 1356
          tmp___0 = __errno_location();
#line 1356
          if (*tmp___0 == 11) {
#line 1357
            return (1);
          }
        }
      }
#line 1358
      if (len <= 0) {
#line 1359
        debug2("channel %d: read<=0 rfd %d len %d", c->self, c->rfd, len);
#line 1361
        if (c->type != 4) {
#line 1362
          debug2("channel %d: not open", c->self);
#line 1363
          chan_mark_dead(c);
#line 1364
          return (-1);
        } else {
#line 1365
          if (compat13) {
#line 1366
            buffer_clear(& c->output);
#line 1367
            c->type = 8;
#line 1368
            debug2("channel %d: input draining.", c->self);
          } else {
#line 1370
            chan_read_failed(c);
          }
        }
#line 1372
        return (-1);
      }
#line 1374
      if ((unsigned int )c->input_filter != (unsigned int )((void *)0)) {
#line 1375
        tmp___1 = (*(c->input_filter))(c, buf___1, len);
#line 1375
        if (tmp___1 == -1) {
#line 1376
          debug2("channel %d: filter stops", c->self);
#line 1377
          chan_read_failed(c);
        }
      } else {
#line 1380
        buffer_append(& c->input, (void const   *)(buf___1), (unsigned int )len);
      }
    }
  }
#line 1383
  return (1);
}
}
#line 1385 "channels.c"
static int channel_handle_wfd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ struct termios tio ;
  u_char *data ;
  u_int dlen ;
  int len ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  register char __result ;
  u_int tmp___3 ;

  {
#line 1395
  if (c->wfd != -1) {
#line 1395
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->wfd % (8U * sizeof(__fd_mask ))),
                         "m" (writeset->__fds_bits[(unsigned int )c->wfd / (8U * sizeof(__fd_mask ))]): "cc");
#line 1395
    if (__result) {
#line 1395
      tmp___3 = buffer_len(& c->output);
#line 1395
      if (tmp___3 > 0U) {
#line 1397
        tmp = buffer_ptr(& c->output);
#line 1397
        data = (u_char *)tmp;
#line 1398
        dlen = buffer_len(& c->output);
#line 1404
        len = write(c->wfd, (void const   *)data, dlen);
#line 1405
        if (len < 0) {
#line 1405
          tmp___0 = __errno_location();
#line 1405
          if (*tmp___0 == 4) {
#line 1406
            return (1);
          } else {
#line 1405
            tmp___1 = __errno_location();
#line 1405
            if (*tmp___1 == 11) {
#line 1406
              return (1);
            }
          }
        }
#line 1407
        if (len <= 0) {
#line 1408
          if (c->type != 4) {
#line 1409
            debug2("channel %d: not open", c->self);
#line 1410
            chan_mark_dead(c);
#line 1411
            return (-1);
          } else {
#line 1412
            if (compat13) {
#line 1413
              buffer_clear(& c->output);
#line 1414
              debug2("channel %d: input draining.", c->self);
#line 1415
              c->type = 8;
            } else {
#line 1417
              chan_write_failed(c);
            }
          }
#line 1419
          return (-1);
        }
#line 1421
        if (compat20) {
#line 1421
          if (c->isatty) {
#line 1421
            if (dlen >= 1U) {
#line 1421
              if ((int )*(data + 0) != 13) {
#line 1422
                tmp___2 = tcgetattr(c->wfd, & tio);
#line 1422
                if (tmp___2 == 0) {
#line 1422
                  if (! (tio.c_lflag & 8U)) {
#line 1422
                    if (tio.c_lflag & 2U) {
#line 1430
                      packet_send_ignore(4 + len);
#line 1431
                      packet_send();
                    }
                  }
                }
              }
            }
          }
        }
#line 1434
        buffer_consume(& c->output, (unsigned int )len);
#line 1435
        if (compat20) {
#line 1435
          if (len > 0) {
#line 1436
            c->local_consumed += (u_int )len;
          }
        }
      }
    }
  }
#line 1439
  return (1);
}
}
#line 1441 "channels.c"
static int channel_handle_efd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char buf___1[16384] ;
  int len ;
  u_int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  register char __result ;
  register char __result___0 ;
  u_int tmp___5 ;

  {
#line 1448
  if (c->efd != -1) {
#line 1450
    if (c->extended_usage == 2) {
#line 1450
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))),
                           "m" (writeset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "cc");
#line 1450
      if (__result___0) {
#line 1450
        tmp___5 = buffer_len(& c->extended);
#line 1450
        if (tmp___5 > 0U) {
#line 1452
          tmp = buffer_len(& c->extended);
#line 1452
          tmp___0 = buffer_ptr(& c->extended);
#line 1452
          len = write(c->efd, (void const   *)tmp___0, tmp);
#line 1454
          debug2("channel %d: written %d to efd %d", c->self, len, c->efd);
#line 1456
          if (len < 0) {
#line 1456
            tmp___1 = __errno_location();
#line 1456
            if (*tmp___1 == 4) {
#line 1457
              return (1);
            } else {
#line 1456
              tmp___2 = __errno_location();
#line 1456
              if (*tmp___2 == 11) {
#line 1457
                return (1);
              }
            }
          }
#line 1458
          if (len <= 0) {
#line 1459
            debug2("channel %d: closing write-efd %d", c->self, c->efd);
#line 1461
            channel_close_fd(& c->efd);
          } else {
#line 1463
            buffer_consume(& c->extended, (unsigned int )len);
#line 1464
            c->local_consumed += (u_int )len;
          }
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 1467
      if (c->extended_usage == 1) {
#line 1467
        __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))),
                             "m" (readset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "cc");
#line 1467
        if (__result) {
#line 1468
          len = read(c->efd, (void *)(buf___1), sizeof(buf___1));
#line 1469
          debug2("channel %d: read %d from efd %d", c->self, len, c->efd);
#line 1471
          if (len < 0) {
#line 1471
            tmp___3 = __errno_location();
#line 1471
            if (*tmp___3 == 4) {
#line 1472
              return (1);
            } else {
#line 1471
              tmp___4 = __errno_location();
#line 1471
              if (*tmp___4 == 11) {
#line 1472
                return (1);
              }
            }
          }
#line 1473
          if (len <= 0) {
#line 1474
            debug2("channel %d: closing read-efd %d", c->self, c->efd);
#line 1476
            channel_close_fd(& c->efd);
          } else {
#line 1478
            buffer_append(& c->extended, (void const   *)(buf___1), (unsigned int )len);
          }
        }
      }
    }
  }
#line 1482
  return (1);
}
}
#line 1484 "channels.c"
static int channel_check_window(Channel *c ) 
{ 

  {
#line 1487
  if (c->type == 4) {
#line 1487
    if (! (c->flags & 3)) {
#line 1487
      if (c->local_window < c->local_window_max / 2U) {
#line 1487
        if (c->local_consumed > 0U) {
#line 1491
          packet_start((unsigned char)93);
#line 1492
          packet_put_int((unsigned int )c->remote_id);
#line 1493
          packet_put_int(c->local_consumed);
#line 1494
          packet_send();
#line 1495
          debug2("channel %d: window %d sent adjust %d", c->self, c->local_window,
                 c->local_consumed);
#line 1498
          c->local_window += c->local_consumed;
#line 1499
          c->local_consumed = 0U;
        }
      }
    }
  }
#line 1501
  return (1);
}
}
#line 1504 "channels.c"
static void channel_post_open(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 1507
  if (c->delayed) {
#line 1508
    return;
  }
#line 1509
  channel_handle_rfd(c, readset, writeset);
#line 1510
  channel_handle_wfd(c, readset, writeset);
#line 1511
  if (! compat20) {
#line 1512
    return;
  }
#line 1513
  channel_handle_efd(c, readset, writeset);
#line 1514
  channel_check_window(c);
#line 1515
  return;
}
}
#line 1517 "channels.c"
static void channel_post_output_drain_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int len ;
  u_int tmp ;
  void *tmp___0 ;
  register char __result ;
  u_int tmp___1 ;

  {
#line 1523
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 1523
  if (__result) {
#line 1523
    tmp___1 = buffer_len(& c->output);
#line 1523
    if (tmp___1 > 0U) {
#line 1524
      tmp = buffer_len(& c->output);
#line 1524
      tmp___0 = buffer_ptr(& c->output);
#line 1524
      len = write(c->sock, (void const   *)tmp___0, tmp);
#line 1526
      if (len <= 0) {
#line 1527
        buffer_clear(& c->output);
      } else {
#line 1529
        buffer_consume(& c->output, (unsigned int )len);
      }
    }
  }
#line 1531
  return;
}
}
#line 1533 "channels.c"
static void channel_handler_init_20(void) 
{ 

  {
#line 1536
  channel_pre[4] = & channel_pre_open;
#line 1537
  channel_pre[7] = & channel_pre_x11_open;
#line 1538
  channel_pre[2] = & channel_pre_listener;
#line 1539
  channel_pre[11] = & channel_pre_listener;
#line 1540
  channel_pre[1] = & channel_pre_listener;
#line 1541
  channel_pre[6] = & channel_pre_listener;
#line 1542
  channel_pre[12] = & channel_pre_connecting;
#line 1543
  channel_pre[13] = & channel_pre_dynamic;
#line 1545
  channel_post[4] = & channel_post_open;
#line 1546
  channel_post[2] = & channel_post_port_listener;
#line 1547
  channel_post[11] = & channel_post_port_listener;
#line 1548
  channel_post[1] = & channel_post_x11_listener;
#line 1549
  channel_post[6] = & channel_post_auth_listener;
#line 1550
  channel_post[12] = & channel_post_connecting;
#line 1551
  channel_post[13] = & channel_post_open;
#line 1552
  return;
}
}
#line 1554 "channels.c"
static void channel_handler_init_13(void) 
{ 

  {
#line 1557
  channel_pre[4] = & channel_pre_open_13;
#line 1558
  channel_pre[7] = & channel_pre_x11_open_13;
#line 1559
  channel_pre[1] = & channel_pre_listener;
#line 1560
  channel_pre[2] = & channel_pre_listener;
#line 1561
  channel_pre[6] = & channel_pre_listener;
#line 1562
  channel_pre[8] = & channel_pre_input_draining;
#line 1563
  channel_pre[9] = & channel_pre_output_draining;
#line 1564
  channel_pre[12] = & channel_pre_connecting;
#line 1565
  channel_pre[13] = & channel_pre_dynamic;
#line 1567
  channel_post[4] = & channel_post_open;
#line 1568
  channel_post[1] = & channel_post_x11_listener;
#line 1569
  channel_post[2] = & channel_post_port_listener;
#line 1570
  channel_post[6] = & channel_post_auth_listener;
#line 1571
  channel_post[9] = & channel_post_output_drain_13;
#line 1572
  channel_post[12] = & channel_post_connecting;
#line 1573
  channel_post[13] = & channel_post_open;
#line 1574
  return;
}
}
#line 1576 "channels.c"
static void channel_handler_init_15(void) 
{ 

  {
#line 1579
  channel_pre[4] = & channel_pre_open;
#line 1580
  channel_pre[7] = & channel_pre_x11_open;
#line 1581
  channel_pre[1] = & channel_pre_listener;
#line 1582
  channel_pre[2] = & channel_pre_listener;
#line 1583
  channel_pre[6] = & channel_pre_listener;
#line 1584
  channel_pre[12] = & channel_pre_connecting;
#line 1585
  channel_pre[13] = & channel_pre_dynamic;
#line 1587
  channel_post[1] = & channel_post_x11_listener;
#line 1588
  channel_post[2] = & channel_post_port_listener;
#line 1589
  channel_post[6] = & channel_post_auth_listener;
#line 1590
  channel_post[4] = & channel_post_open;
#line 1591
  channel_post[12] = & channel_post_connecting;
#line 1592
  channel_post[13] = & channel_post_open;
#line 1593
  return;
}
}
#line 1595 "channels.c"
static void channel_handler_init(void) 
{ int i ;

  {
#line 1600
  i = 0;
#line 1600
  while (i < 15) {
#line 1601
    channel_pre[i] = (chan_fn *)((void *)0);
#line 1602
    channel_post[i] = (chan_fn *)((void *)0);
#line 1600
    i ++;
  }
#line 1604
  if (compat20) {
#line 1605
    channel_handler_init_20();
  } else {
#line 1606
    if (compat13) {
#line 1607
      channel_handler_init_13();
    } else {
#line 1609
      channel_handler_init_15();
    }
  }
#line 1610
  return;
}
}
#line 1613 "channels.c"
static void channel_garbage_collect(Channel *c ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 1616
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1617
    return;
  }
#line 1618
  if ((unsigned int )c->detach_user != (unsigned int )((void *)0)) {
#line 1619
    tmp = chan_is_dead(c, 0);
#line 1619
    if (! tmp) {
#line 1620
      return;
    }
#line 1621
    debug2("channel %d: gc: notify user", c->self);
#line 1622
    (*(c->detach_user))(c->self, (void *)0);
#line 1624
    if ((unsigned int )c->detach_user != (unsigned int )((void *)0)) {
#line 1625
      return;
    }
#line 1626
    debug2("channel %d: gc: user detached", c->self);
  }
#line 1628
  tmp___0 = chan_is_dead(c, 1);
#line 1628
  if (! tmp___0) {
#line 1629
    return;
  }
#line 1630
  debug2("channel %d: garbage collecting", c->self);
#line 1631
  channel_free(c);
#line 1632
  return;
}
}
#line 1637
static void channel_handler(chan_fn **ftab , fd_set *readset , fd_set *writeset ) ;
#line 1637 "channels.c"
static int did_init  =    0;
#line 1634 "channels.c"
static void channel_handler(chan_fn **ftab , fd_set *readset , fd_set *writeset ) 
{ int i ;
  Channel *c ;

  {
#line 1641
  if (! did_init) {
#line 1642
    channel_handler_init();
#line 1643
    did_init = 1;
  }
#line 1645
  i = 0;
#line 1645
  while (i < channels_alloc) {
#line 1646
    c = *(channels + i);
#line 1647
    if ((unsigned int )c == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 1649
    if ((unsigned int )*(ftab + c->type) != (unsigned int )((void *)0)) {
#line 1650
      (*(*(ftab + c->type)))(c, readset, writeset);
    }
#line 1651
    channel_garbage_collect(c);
    __Cont: /* CIL Label */ 
#line 1645
    i ++;
  }
#line 1653
  return;
}
}
#line 1659 "channels.c"
void channel_prepare_select(fd_set **readsetp , fd_set **writesetp , int *maxfdp ,
                            int *nallocp , int rekeying___0 ) 
{ int n___0 ;
  u_int sz ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1666
  if (*maxfdp > channel_max_fd) {
#line 1666
    n___0 = *maxfdp;
  } else {
#line 1666
    n___0 = channel_max_fd;
  }
#line 1668
  sz = (((unsigned int )(n___0 + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask );
#line 1670
  if ((unsigned int )*readsetp == (unsigned int )((void *)0)) {
#line 1671
    tmp = xrealloc((void *)*readsetp, sz);
#line 1671
    *readsetp = (fd_set *)tmp;
#line 1672
    tmp___0 = xrealloc((void *)*writesetp, sz);
#line 1672
    *writesetp = (fd_set *)tmp___0;
#line 1673
    *nallocp = (int )sz;
  } else {
#line 1670
    if (sz > (u_int )*nallocp) {
#line 1671
      tmp = xrealloc((void *)*readsetp, sz);
#line 1671
      *readsetp = (fd_set *)tmp;
#line 1672
      tmp___0 = xrealloc((void *)*writesetp, sz);
#line 1672
      *writesetp = (fd_set *)tmp___0;
#line 1673
      *nallocp = (int )sz;
    }
  }
#line 1675
  *maxfdp = n___0;
#line 1676
  memset((void *)*readsetp, 0, sz);
#line 1677
  memset((void *)*writesetp, 0, sz);
#line 1679
  if (! rekeying___0) {
#line 1680
    channel_handler(channel_pre, *readsetp, *writesetp);
  }
#line 1681
  return;
}
}
#line 1687 "channels.c"
void channel_after_select(fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 1690
  channel_handler(channel_post, readset, writeset);
#line 1691
  return;
}
}
#line 1696 "channels.c"
void channel_output_poll(void) 
{ Channel *c ;
  int i ;
  u_int len ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  u_int tmp___4 ;
  void *tmp___5 ;

  {
#line 1703
  i = 0;
#line 1703
  while (i < channels_alloc) {
#line 1704
    c = *(channels + i);
#line 1705
    if ((unsigned int )c == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 1712
    if (compat13) {
#line 1713
      if (c->type != 4) {
#line 1713
        if (c->type != 8) {
          goto __Cont;
        }
      }
    } else {
#line 1717
      if (c->type != 4) {
        goto __Cont;
      }
    }
#line 1720
    if (compat20) {
#line 1720
      if (c->flags & 3) {
#line 1723
        debug3("channel %d: will not send data after close", c->self);
        goto __Cont;
      }
    }
#line 1728
    if (c->istate == 0U) {
      goto _L___0;
    } else {
#line 1728
      if (c->istate == 1U) {
        _L___0: /* CIL Label */ 
#line 1728
        len = buffer_len(& c->input);
#line 1728
        if (len > 0U) {
#line 1735
          if (compat20) {
#line 1736
            if (len > c->remote_window) {
#line 1737
              len = c->remote_window;
            }
#line 1738
            if (len > c->remote_maxpacket) {
#line 1739
              len = c->remote_maxpacket;
            }
          } else {
#line 1741
            tmp = packet_is_interactive();
#line 1741
            if (tmp) {
#line 1742
              if (len > 1024U) {
#line 1743
                len = 512U;
              }
            } else {
#line 1746
              if (len > max_packet_size / 2U) {
#line 1747
                len = max_packet_size / 2U;
              }
            }
          }
#line 1750
          if (len > 0U) {
#line 1751
            if (compat20) {
#line 1751
              tmp___0 = 94;
            } else {
#line 1751
              tmp___0 = 23;
            }
#line 1751
            packet_start((unsigned char )tmp___0);
#line 1753
            packet_put_int((unsigned int )c->remote_id);
#line 1754
            tmp___1 = buffer_ptr(& c->input);
#line 1754
            packet_put_string((void const   *)tmp___1, len);
#line 1755
            packet_send();
#line 1756
            buffer_consume(& c->input, len);
#line 1757
            c->remote_window -= len;
          }
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 1759
        if (c->istate == 1U) {
#line 1760
          if (compat13) {
#line 1761
            fatal("cannot happen: istate == INPUT_WAIT_DRAIN for proto 1.3");
          }
#line 1767
          if (compat20) {
#line 1767
            if (c->extended_usage == 1) {
#line 1767
              if (c->efd != -1) {
#line 1768
                tmp___2 = buffer_len(& c->extended);
#line 1768
                debug2("channel %d: ibuf_empty delayed efd %d/(%d)", c->self, c->efd,
                       tmp___2);
              } else {
#line 1767
                tmp___3 = buffer_len(& c->extended);
#line 1767
                if (tmp___3 > 0U) {
#line 1768
                  tmp___2 = buffer_len(& c->extended);
#line 1768
                  debug2("channel %d: ibuf_empty delayed efd %d/(%d)", c->self, c->efd,
                         tmp___2);
                } else {
#line 1771
                  chan_ibuf_empty(c);
                }
              }
            } else {
#line 1771
              chan_ibuf_empty(c);
            }
          } else {
#line 1771
            chan_ibuf_empty(c);
          }
        }
      }
    }
#line 1774
    if (compat20) {
#line 1774
      if (! (c->flags & 4)) {
#line 1774
        if (c->remote_window > 0U) {
#line 1774
          len = buffer_len(& c->extended);
#line 1774
          if (len > 0U) {
#line 1774
            if (c->extended_usage == 1) {
#line 1779
              tmp___4 = buffer_len(& c->extended);
#line 1779
              debug2("channel %d: rwin %u elen %u euse %d", c->self, c->remote_window,
                     tmp___4, c->extended_usage);
#line 1782
              if (len > c->remote_window) {
#line 1783
                len = c->remote_window;
              }
#line 1784
              if (len > c->remote_maxpacket) {
#line 1785
                len = c->remote_maxpacket;
              }
#line 1786
              packet_start((unsigned char)95);
#line 1787
              packet_put_int((unsigned int )c->remote_id);
#line 1788
              packet_put_int(1U);
#line 1789
              tmp___5 = buffer_ptr(& c->extended);
#line 1789
              packet_put_string((void const   *)tmp___5, len);
#line 1790
              packet_send();
#line 1791
              buffer_consume(& c->extended, len);
#line 1792
              c->remote_window -= len;
#line 1793
              debug2("channel %d: sent ext data %d", c->self, len);
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1703
    i ++;
  }
#line 1796
  return;
}
}
#line 1801 "channels.c"
void channel_input_data(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  char *data ;
  u_int data_len ;
  Channel *c ;
  u_int tmp ;
  void *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1810
  tmp = packet_get_int();
#line 1810
  id = (int )tmp;
#line 1811
  c = channel_lookup(id);
#line 1812
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1813
    packet_disconnect("Received data for nonexistent channel %d.", id);
  }
#line 1816
  if (c->type != 4) {
#line 1816
    if (c->type != 7) {
#line 1818
      return;
    }
  }
#line 1821
  tmp___0 = packet_get_string(& data_len);
#line 1821
  data = (char *)tmp___0;
#line 1830
  if (! compat13) {
#line 1830
    if (c->ostate != 0U) {
#line 1831
      if (compat20) {
#line 1832
        c->local_window -= data_len;
#line 1833
        c->local_consumed += data_len;
      }
#line 1835
      xfree((void *)data);
#line 1836
      return;
    }
  }
#line 1839
  if (compat20) {
#line 1840
    if (data_len > c->local_maxpacket) {
#line 1841
      logit("channel %d: rcvd big packet %d, maxpack %d", c->self, data_len, c->local_maxpacket);
    }
#line 1844
    if (data_len > c->local_window) {
#line 1845
      logit("channel %d: rcvd too much data %d, win %d", c->self, data_len, c->local_window);
#line 1847
      xfree((void *)data);
#line 1848
      return;
    }
#line 1850
    c->local_window -= data_len;
  }
#line 1852
  while (1) {
#line 1852
    tmp___1 = packet_remaining();
#line 1852
    _len = tmp___1;
#line 1852
    if (_len > 0) {
#line 1852
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            1852);
#line 1852
      packet_disconnect("Packet integrity error.");
    }
#line 1852
    break;
  }
#line 1853
  buffer_append(& c->output, (void const   *)data, data_len);
#line 1854
  xfree((void *)data);
#line 1855
  return;
}
}
#line 1857 "channels.c"
void channel_input_extended_data(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  char *data ;
  u_int data_len ;
  u_int tcode ;
  Channel *c ;
  u_int tmp ;
  void *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1866
  tmp = packet_get_int();
#line 1866
  id = (int )tmp;
#line 1867
  c = channel_lookup(id);
#line 1869
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1870
    packet_disconnect("Received extended_data for bad channel %d.", id);
  }
#line 1871
  if (c->type != 4) {
#line 1872
    logit("channel %d: ext data for non open", id);
#line 1873
    return;
  }
#line 1875
  if (c->flags & 8) {
#line 1876
    if (datafellows & 2097152) {
#line 1877
      debug("channel %d: accepting ext data after eof", id);
    } else {
#line 1879
      packet_disconnect("Received extended_data after EOF on channel %d.", id);
    }
  }
#line 1882
  tcode = packet_get_int();
#line 1883
  if (c->efd == -1) {
#line 1886
    logit("channel %d: bad ext data", c->self);
#line 1887
    return;
  } else {
#line 1883
    if (c->extended_usage != 2) {
#line 1886
      logit("channel %d: bad ext data", c->self);
#line 1887
      return;
    } else {
#line 1883
      if (tcode != 1U) {
#line 1886
        logit("channel %d: bad ext data", c->self);
#line 1887
        return;
      }
    }
  }
#line 1889
  tmp___0 = packet_get_string(& data_len);
#line 1889
  data = (char *)tmp___0;
#line 1890
  while (1) {
#line 1890
    tmp___1 = packet_remaining();
#line 1890
    _len = tmp___1;
#line 1890
    if (_len > 0) {
#line 1890
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            1890);
#line 1890
      packet_disconnect("Packet integrity error.");
    }
#line 1890
    break;
  }
#line 1891
  if (data_len > c->local_window) {
#line 1892
    logit("channel %d: rcvd too much extended_data %d, win %d", c->self, data_len,
          c->local_window);
#line 1894
    xfree((void *)data);
#line 1895
    return;
  }
#line 1897
  debug2("channel %d: rcvd ext data %d", c->self, data_len);
#line 1898
  c->local_window -= data_len;
#line 1899
  buffer_append(& c->extended, (void const   *)data, data_len);
#line 1900
  xfree((void *)data);
#line 1901
  return;
}
}
#line 1903 "channels.c"
void channel_input_ieof(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  Channel *c ;
  u_int tmp ;
  int _len ;
  int tmp___0 ;
  u_int tmp___1 ;

  {
#line 1909
  tmp = packet_get_int();
#line 1909
  id = (int )tmp;
#line 1910
  while (1) {
#line 1910
    tmp___0 = packet_remaining();
#line 1910
    _len = tmp___0;
#line 1910
    if (_len > 0) {
#line 1910
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            1910);
#line 1910
      packet_disconnect("Packet integrity error.");
    }
#line 1910
    break;
  }
#line 1911
  c = channel_lookup(id);
#line 1912
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1913
    packet_disconnect("Received ieof for nonexistent channel %d.", id);
  }
#line 1914
  chan_rcvd_ieof(c);
#line 1917
  if (c->force_drain) {
#line 1917
    if (c->istate == 0U) {
#line 1918
      debug("channel %d: FORCE input drain", c->self);
#line 1919
      c->istate = 1U;
#line 1920
      tmp___1 = buffer_len(& c->input);
#line 1920
      if (tmp___1 == 0U) {
#line 1921
        chan_ibuf_empty(c);
      }
    }
  }
#line 1924
  return;
}
}
#line 1926 "channels.c"
void channel_input_close(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  Channel *c ;
  u_int tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 1932
  tmp = packet_get_int();
#line 1932
  id = (int )tmp;
#line 1933
  while (1) {
#line 1933
    tmp___0 = packet_remaining();
#line 1933
    _len = tmp___0;
#line 1933
    if (_len > 0) {
#line 1933
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            1933);
#line 1933
      packet_disconnect("Packet integrity error.");
    }
#line 1933
    break;
  }
#line 1934
  c = channel_lookup(id);
#line 1935
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1936
    packet_disconnect("Received close for nonexistent channel %d.", id);
  }
#line 1942
  packet_start((unsigned char)25);
#line 1943
  packet_put_int((unsigned int )c->remote_id);
#line 1944
  packet_send();
#line 1953
  if (c->type != 5) {
#line 1958
    buffer_clear(& c->input);
#line 1959
    c->type = 9;
  }
#line 1961
  return;
}
}
#line 1964 "channels.c"
void channel_input_oclose(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  u_int tmp ;
  Channel *c ;
  Channel *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1967
  tmp = packet_get_int();
#line 1967
  id = (int )tmp;
#line 1968
  tmp___0 = channel_lookup(id);
#line 1968
  c = tmp___0;
#line 1970
  while (1) {
#line 1970
    tmp___1 = packet_remaining();
#line 1970
    _len = tmp___1;
#line 1970
    if (_len > 0) {
#line 1970
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            1970);
#line 1970
      packet_disconnect("Packet integrity error.");
    }
#line 1970
    break;
  }
#line 1971
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1972
    packet_disconnect("Received oclose for nonexistent channel %d.", id);
  }
#line 1973
  chan_rcvd_oclose(c);
#line 1974
  return;
}
}
#line 1976 "channels.c"
void channel_input_close_confirmation(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  u_int tmp ;
  Channel *c ;
  Channel *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1979
  tmp = packet_get_int();
#line 1979
  id = (int )tmp;
#line 1980
  tmp___0 = channel_lookup(id);
#line 1980
  c = tmp___0;
#line 1982
  while (1) {
#line 1982
    tmp___1 = packet_remaining();
#line 1982
    _len = tmp___1;
#line 1982
    if (_len > 0) {
#line 1982
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            1982);
#line 1982
      packet_disconnect("Packet integrity error.");
    }
#line 1982
    break;
  }
#line 1983
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1984
    packet_disconnect("Received close confirmation for out-of-range channel %d.",
                      id);
  }
#line 1986
  if (c->type != 5) {
#line 1987
    packet_disconnect("Received close confirmation for non-closed channel %d (type %d).",
                      id, c->type);
  }
#line 1989
  channel_free(c);
#line 1990
  return;
}
}
#line 1992 "channels.c"
void channel_input_open_confirmation(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  int remote_id ;
  Channel *c ;
  u_int tmp ;
  u_int tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1998
  tmp = packet_get_int();
#line 1998
  id = (int )tmp;
#line 1999
  c = channel_lookup(id);
#line 2001
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2002
    packet_disconnect("Received open confirmation for non-opening channel %d.", id);
  } else {
#line 2001
    if (c->type != 3) {
#line 2002
      packet_disconnect("Received open confirmation for non-opening channel %d.",
                        id);
    }
  }
#line 2004
  tmp___0 = packet_get_int();
#line 2004
  remote_id = (int )tmp___0;
#line 2006
  c->remote_id = remote_id;
#line 2007
  c->type = 4;
#line 2009
  if (compat20) {
#line 2010
    c->remote_window = packet_get_int();
#line 2011
    c->remote_maxpacket = packet_get_int();
#line 2012
    if (c->confirm) {
#line 2013
      debug2("callback start");
#line 2014
      (*(c->confirm))(c->self, (void *)0);
#line 2015
      debug2("callback done");
    }
#line 2017
    debug2("channel %d: open confirm rwindow %u rmax %u", c->self, c->remote_window,
           c->remote_maxpacket);
  }
#line 2020
  while (1) {
#line 2020
    tmp___1 = packet_remaining();
#line 2020
    _len = tmp___1;
#line 2020
    if (_len > 0) {
#line 2020
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2020);
#line 2020
      packet_disconnect("Packet integrity error.");
    }
#line 2020
    break;
  }
#line 2021
  return;
}
}
#line 2023 "channels.c"
static char *reason2txt(int reason ) 
{ 

  {
#line 2026
  switch (reason) {
  case 1: 
#line 2028
  return ((char *)"administratively prohibited");
  case 2: 
#line 2030
  return ((char *)"connect failed");
  case 3: 
#line 2032
  return ((char *)"unknown channel type");
  case 4: 
#line 2034
  return ((char *)"resource shortage");
  }
#line 2036
  return ((char *)"unknown reason");
}
}
#line 2039 "channels.c"
void channel_input_open_failure(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  int reason ;
  char *msg ;
  char *lang ;
  Channel *c ;
  u_int tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  int _len ;
  int tmp___6 ;

  {
#line 2043
  msg = (char *)((void *)0);
#line 2043
  lang = (char *)((void *)0);
#line 2046
  tmp = packet_get_int();
#line 2046
  id = (int )tmp;
#line 2047
  c = channel_lookup(id);
#line 2049
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2050
    packet_disconnect("Received open failure for non-opening channel %d.", id);
  } else {
#line 2049
    if (c->type != 3) {
#line 2050
      packet_disconnect("Received open failure for non-opening channel %d.", id);
    }
  }
#line 2052
  if (compat20) {
#line 2053
    tmp___0 = packet_get_int();
#line 2053
    reason = (int )tmp___0;
#line 2054
    if (! (datafellows & 131072)) {
#line 2055
      tmp___1 = packet_get_string((u_int *)((void *)0));
#line 2055
      msg = (char *)tmp___1;
#line 2056
      tmp___2 = packet_get_string((u_int *)((void *)0));
#line 2056
      lang = (char *)tmp___2;
    }
#line 2058
    if (msg) {
#line 2058
      tmp___3 = (char const   *)msg;
    } else {
#line 2058
      tmp___3 = "";
    }
#line 2058
    if (msg) {
#line 2058
      tmp___4 = ": ";
    } else {
#line 2058
      tmp___4 = "";
    }
#line 2058
    tmp___5 = reason2txt(reason);
#line 2058
    logit("channel %d: open failed: %s%s%s", id, tmp___5, tmp___4, tmp___3);
#line 2060
    if ((unsigned int )msg != (unsigned int )((void *)0)) {
#line 2061
      xfree((void *)msg);
    }
#line 2062
    if ((unsigned int )lang != (unsigned int )((void *)0)) {
#line 2063
      xfree((void *)lang);
    }
  }
#line 2065
  while (1) {
#line 2065
    tmp___6 = packet_remaining();
#line 2065
    _len = tmp___6;
#line 2065
    if (_len > 0) {
#line 2065
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2065);
#line 2065
      packet_disconnect("Packet integrity error.");
    }
#line 2065
    break;
  }
#line 2067
  channel_free(c);
#line 2068
  return;
}
}
#line 2070 "channels.c"
void channel_input_window_adjust(int type , u_int32_t seq , void *ctxt ) 
{ Channel *c ;
  int id ;
  u_int adjust ;
  u_int tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 2077
  if (! compat20) {
#line 2078
    return;
  }
#line 2081
  tmp = packet_get_int();
#line 2081
  id = (int )tmp;
#line 2082
  c = channel_lookup(id);
#line 2084
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2085
    logit("Received window adjust for non-open channel %d.", id);
#line 2087
    return;
  } else {
#line 2084
    if (c->type != 4) {
#line 2085
      logit("Received window adjust for non-open channel %d.", id);
#line 2087
      return;
    }
  }
#line 2089
  adjust = packet_get_int();
#line 2090
  while (1) {
#line 2090
    tmp___0 = packet_remaining();
#line 2090
    _len = tmp___0;
#line 2090
    if (_len > 0) {
#line 2090
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2090);
#line 2090
      packet_disconnect("Packet integrity error.");
    }
#line 2090
    break;
  }
#line 2091
  debug2("channel %d: rcvd adjust %u", id, adjust);
#line 2092
  c->remote_window += adjust;
#line 2093
  return;
}
}
#line 2095 "channels.c"
void channel_input_port_open(int type , u_int32_t seq , void *ctxt ) 
{ Channel *c ;
  u_short host_port ;
  char *host ;
  char *originator_string ;
  int remote_id ;
  int sock ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  u_int tmp___3 ;
  int _len ;
  int tmp___4 ;

  {
#line 2098
  c = (Channel *)((void *)0);
#line 2101
  sock = -1;
#line 2103
  tmp = packet_get_int();
#line 2103
  remote_id = (int )tmp;
#line 2104
  tmp___0 = packet_get_string((u_int *)((void *)0));
#line 2104
  host = (char *)tmp___0;
#line 2105
  tmp___1 = packet_get_int();
#line 2105
  host_port = (unsigned short )tmp___1;
#line 2107
  tmp___3 = packet_get_protocol_flags();
#line 2107
  if (tmp___3 & 2U) {
#line 2108
    tmp___2 = packet_get_string((u_int *)((void *)0));
#line 2108
    originator_string = (char *)tmp___2;
  } else {
#line 2110
    originator_string = xstrdup("unknown (remote did not supply name)");
  }
#line 2112
  while (1) {
#line 2112
    tmp___4 = packet_remaining();
#line 2112
    _len = tmp___4;
#line 2112
    if (_len > 0) {
#line 2112
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2112);
#line 2112
      packet_disconnect("Packet integrity error.");
    }
#line 2112
    break;
  }
#line 2113
  sock = channel_connect_to((char const   *)host, host_port);
#line 2114
  if (sock != -1) {
#line 2115
    c = channel_new((char *)"connected socket", 12, sock, sock, -1, 0U, 0U, 0, originator_string,
                    1);
#line 2118
    c->remote_id = remote_id;
  }
#line 2120
  xfree((void *)originator_string);
#line 2121
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2122
    packet_start((unsigned char)22);
#line 2123
    packet_put_int((unsigned int )remote_id);
#line 2124
    packet_send();
  }
#line 2126
  xfree((void *)host);
#line 2127
  return;
}
}
#line 2132 "channels.c"
void channel_set_af(int af ) 
{ 

  {
#line 2135
  IPv4or6___0 = af;
#line 2136
  return;
}
}
#line 2138 "channels.c"
static int channel_setup_fwd_listener(int type , char const   *listen_addr , u_short listen_port ,
                                      char const   *host_to_connect , u_short port_to_connect ,
                                      int gateway_ports ) 
{ Channel *c ;
  int success ;
  int sock ;
  int on ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char const   *host ;
  char ntop[1025] ;
  char strport[32] ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;

  {
#line 2143
  on = 1;
#line 2148
  success = 0;
#line 2149
  if (type == 11) {
#line 2149
    host = listen_addr;
  } else {
#line 2149
    host = host_to_connect;
  }
#line 2152
  if ((unsigned int )host == (unsigned int )((void *)0)) {
#line 2153
    error("No forward host name.");
#line 2154
    return (success);
  }
#line 2156
  tmp = strlen(host);
#line 2156
  if (tmp > 255U) {
#line 2157
    error("Forward host name too long.");
#line 2158
    return (success);
  }
#line 2165
  memset((void *)(& hints), 0, sizeof(hints));
#line 2166
  hints.ai_family = IPv4or6___0;
#line 2167
  if (gateway_ports) {
#line 2167
    hints.ai_flags = 1;
  } else {
#line 2167
    hints.ai_flags = 0;
  }
#line 2168
  hints.ai_socktype = 1;
#line 2169
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           listen_port);
#line 2170
  tmp___0 = getaddrinfo((char const   * __restrict  )((void *)0), (char const   * __restrict  )(strport),
                        (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 2170
  if (tmp___0 != 0) {
#line 2171
    packet_disconnect("getaddrinfo: fatal error");
  }
#line 2173
  ai = aitop;
#line 2173
  while (ai) {
#line 2174
    if (ai->ai_family != 2) {
#line 2174
      if (ai->ai_family != 10) {
        goto __Cont;
      }
    }
#line 2176
    tmp___1 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                          (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )(strport),
                          sizeof(strport), 3U);
#line 2176
    if (tmp___1 != 0) {
#line 2178
      error("channel_setup_fwd_listener: getnameinfo failed");
      goto __Cont;
    }
#line 2182
    sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
#line 2183
    if (sock < 0) {
#line 2185
      tmp___2 = __errno_location();
#line 2185
      tmp___3 = strerror(*tmp___2);
#line 2185
      verbose("socket: %.100s", tmp___3);
      goto __Cont;
    }
#line 2192
    tmp___6 = setsockopt(sock, 1, 2, (void const   *)(& on), sizeof(on));
#line 2192
    if (tmp___6 == -1) {
#line 2194
      tmp___4 = __errno_location();
#line 2194
      tmp___5 = strerror(*tmp___4);
#line 2194
      error("setsockopt SO_REUSEADDR: %s", tmp___5);
    }
#line 2196
    debug("Local forwarding listening on %s port %s.", ntop, strport);
#line 2199
    tmp___11 = bind(sock, (struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen);
#line 2199
    if (tmp___11 < 0) {
#line 2201
      if (! ai->ai_next) {
#line 2202
        tmp___7 = __errno_location();
#line 2202
        tmp___8 = strerror(*tmp___7);
#line 2202
        error("bind: %.100s", tmp___8);
      } else {
#line 2204
        tmp___9 = __errno_location();
#line 2204
        tmp___10 = strerror(*tmp___9);
#line 2204
        verbose("bind: %.100s", tmp___10);
      }
#line 2206
      close(sock);
      goto __Cont;
    }
#line 2210
    tmp___14 = listen(sock, 128);
#line 2210
    if (tmp___14 < 0) {
#line 2211
      tmp___12 = __errno_location();
#line 2211
      tmp___13 = strerror(*tmp___12);
#line 2211
      error("listen: %.100s", tmp___13);
#line 2212
      close(sock);
      goto __Cont;
    }
#line 2216
    c = channel_new((char *)"port listener", type, sock, sock, -1, 131072U, 32768U,
                    0, (char *)"port listener", 1);
#line 2219
    strlcpy(c->path, host, sizeof(c->path));
#line 2220
    c->host_port = (int )port_to_connect;
#line 2221
    c->listening_port = (int )listen_port;
#line 2222
    success = 1;
    __Cont: /* CIL Label */ 
#line 2173
    ai = ai->ai_next;
  }
#line 2224
  if (success == 0) {
#line 2225
    error("channel_setup_fwd_listener: cannot listen to port: %d", listen_port);
  }
#line 2227
  freeaddrinfo(aitop);
#line 2228
  return (success);
}
}
#line 2232 "channels.c"
int channel_setup_local_fwd_listener(u_short listen_port , char const   *host_to_connect ,
                                     u_short port_to_connect , int gateway_ports ) 
{ int tmp ;

  {
#line 2236
  tmp = channel_setup_fwd_listener(2, (char const   *)((void *)0), listen_port, host_to_connect,
                                   port_to_connect, gateway_ports);
#line 2236
  return (tmp);
}
}
#line 2241 "channels.c"
int channel_setup_remote_fwd_listener(char const   *listen_address , u_short listen_port ,
                                      int gateway_ports ) 
{ int tmp ;

  {
#line 2245
  tmp = channel_setup_fwd_listener(11, listen_address, listen_port, (char const   *)((void *)0),
                                   (unsigned short)0, gateway_ports);
#line 2245
  return (tmp);
}
}
#line 2254 "channels.c"
void channel_request_remote_forwarding(u_short listen_port , char const   *host_to_connect ,
                                       u_short port_to_connect ) 
{ int type ;
  int success ;
  char const   *address_to_bind ;

  {
#line 2258
  success = 0;
#line 2261
  if (num_permitted_opens >= 100) {
#line 2262
    fatal("channel_request_remote_forwarding: too many forwards");
  }
#line 2265
  if (compat20) {
#line 2266
    address_to_bind = "0.0.0.0";
#line 2267
    packet_start((unsigned char)80);
#line 2268
    packet_put_cstring("tcpip-forward");
#line 2269
    packet_put_char(1);
#line 2270
    packet_put_cstring(address_to_bind);
#line 2271
    packet_put_int((unsigned int )listen_port);
#line 2272
    packet_send();
#line 2273
    packet_write_wait();
#line 2275
    success = 1;
  } else {
#line 2277
    packet_start((unsigned char)28);
#line 2278
    packet_put_int((unsigned int )listen_port);
#line 2279
    packet_put_cstring(host_to_connect);
#line 2280
    packet_put_int((unsigned int )port_to_connect);
#line 2281
    packet_send();
#line 2282
    packet_write_wait();
#line 2285
    type = packet_read();
#line 2286
    switch (type) {
    case 14: 
#line 2288
    success = 1;
#line 2289
    break;
    case 15: 
#line 2291
    logit("Warning: Server denied remote port forwarding.");
#line 2292
    break;
    default: 
#line 2295
    packet_disconnect("Protocol error for port forward request:received packet type %d.",
                      type);
    }
  }
#line 2299
  if (success) {
#line 2300
    permitted_opens[num_permitted_opens].host_to_connect = xstrdup(host_to_connect);
#line 2301
    permitted_opens[num_permitted_opens].port_to_connect = port_to_connect;
#line 2302
    permitted_opens[num_permitted_opens].listen_port = listen_port;
#line 2303
    num_permitted_opens ++;
  }
#line 2305
  return;
}
}
#line 2313 "channels.c"
void channel_input_port_forward_request(int is_root , int gateway_ports ) 
{ u_short port ;
  u_short host_port ;
  char *hostname ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;

  {
#line 2320
  tmp = packet_get_int();
#line 2320
  port = (unsigned short )tmp;
#line 2321
  tmp___0 = packet_get_string((u_int *)((void *)0));
#line 2321
  hostname = (char *)tmp___0;
#line 2322
  tmp___1 = packet_get_int();
#line 2322
  host_port = (unsigned short )tmp___1;
#line 2329
  if ((int )port < 1024) {
#line 2329
    if (! is_root) {
#line 2330
      packet_disconnect("Requested forwarding of port %d but user is not root.", port);
    }
  }
#line 2333
  if ((int )host_port == 0) {
#line 2334
    packet_disconnect("Dynamic forwarding denied.");
  }
#line 2338
  channel_setup_local_fwd_listener(port, (char const   *)hostname, host_port, gateway_ports);
#line 2341
  xfree((void *)hostname);
#line 2342
  return;
}
}
#line 2349 "channels.c"
void channel_permit_all_opens(void) 
{ 

  {
#line 2352
  if (num_permitted_opens == 0) {
#line 2353
    all_opens_permitted = 1;
  }
#line 2354
  return;
}
}
#line 2356 "channels.c"
void channel_add_permitted_opens(char *host , int port ) 
{ 

  {
#line 2359
  if (num_permitted_opens >= 100) {
#line 2360
    fatal("channel_request_remote_forwarding: too many forwards");
  }
#line 2361
  debug("allow port forwarding to host %s port %d", host, port);
#line 2363
  permitted_opens[num_permitted_opens].host_to_connect = xstrdup((char const   *)host);
#line 2364
  permitted_opens[num_permitted_opens].port_to_connect = (unsigned short )port;
#line 2365
  num_permitted_opens ++;
#line 2367
  all_opens_permitted = 0;
#line 2368
  return;
}
}
#line 2370 "channels.c"
void channel_clear_permitted_opens(void) 
{ int i ;

  {
#line 2375
  i = 0;
#line 2375
  while (i < num_permitted_opens) {
#line 2376
    xfree((void *)permitted_opens[i].host_to_connect);
#line 2375
    i ++;
  }
#line 2377
  num_permitted_opens = 0;
#line 2379
  return;
}
}
#line 2383 "channels.c"
static int connect_to(char const   *host , u_short port ) 
{ struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char ntop[1025] ;
  char strport[32] ;
  int gaierr ;
  int sock ;
  char const   *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;

  {
#line 2389
  sock = -1;
#line 2391
  memset((void *)(& hints), 0, sizeof(hints));
#line 2392
  hints.ai_family = IPv4or6___0;
#line 2393
  hints.ai_socktype = 1;
#line 2394
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           port);
#line 2395
  gaierr = getaddrinfo((char const   * __restrict  )host, (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 2395
  if (gaierr != 0) {
#line 2396
    tmp = gai_strerror(gaierr);
#line 2396
    error("connect_to %.100s: unknown host (%s)", host, tmp);
#line 2398
    return (-1);
  }
#line 2400
  ai = aitop;
#line 2400
  while (ai) {
#line 2401
    if (ai->ai_family != 2) {
#line 2401
      if (ai->ai_family != 10) {
        goto __Cont;
      }
    }
#line 2403
    tmp___0 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                          (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )(strport),
                          sizeof(strport), 3U);
#line 2403
    if (tmp___0 != 0) {
#line 2405
      error("connect_to: getnameinfo failed");
      goto __Cont;
    }
#line 2408
    sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
#line 2409
    if (sock < 0) {
#line 2410
      if ((unsigned int )ai->ai_next == (unsigned int )((void *)0)) {
#line 2411
        tmp___1 = __errno_location();
#line 2411
        tmp___2 = strerror(*tmp___1);
#line 2411
        error("socket: %.100s", tmp___2);
      } else {
#line 2413
        tmp___3 = __errno_location();
#line 2413
        tmp___4 = strerror(*tmp___3);
#line 2413
        verbose("socket: %.100s", tmp___4);
      }
      goto __Cont;
    }
#line 2416
    tmp___7 = fcntl(sock, 4, 2048);
#line 2416
    if (tmp___7 < 0) {
#line 2417
      tmp___5 = __errno_location();
#line 2417
      tmp___6 = strerror(*tmp___5);
#line 2417
      fatal("connect_to: F_SETFL: %s", tmp___6);
    }
#line 2418
    tmp___10 = connect(sock, (struct sockaddr  const  * __restrict  )ai->ai_addr,
                       ai->ai_addrlen);
#line 2418
    if (tmp___10 < 0) {
#line 2418
      tmp___11 = __errno_location();
#line 2418
      if (*tmp___11 != 115) {
#line 2420
        tmp___8 = __errno_location();
#line 2420
        tmp___9 = strerror(*tmp___8);
#line 2420
        error("connect_to %.100s port %s: %.100s", ntop, strport, tmp___9);
#line 2422
        close(sock);
        goto __Cont;
      }
    }
#line 2425
    break;
    __Cont: /* CIL Label */ 
#line 2400
    ai = ai->ai_next;
  }
#line 2428
  freeaddrinfo(aitop);
#line 2429
  if (! ai) {
#line 2430
    error("connect_to %.100s port %d: failed.", host, port);
#line 2431
    return (-1);
  }
#line 2434
  set_nodelay(sock);
#line 2435
  return (sock);
}
}
#line 2438 "channels.c"
int channel_connect_by_listen_address(u_short listen_port ) 
{ int i ;
  int tmp ;

  {
#line 2443
  i = 0;
#line 2443
  while (i < num_permitted_opens) {
#line 2444
    if ((int )permitted_opens[i].listen_port == (int )listen_port) {
#line 2445
      tmp = connect_to((char const   *)permitted_opens[i].host_to_connect, permitted_opens[i].port_to_connect);
#line 2445
      return (tmp);
    }
#line 2443
    i ++;
  }
#line 2448
  error("WARNING: Server requests forwarding for unknown listen_port %d", listen_port);
#line 2450
  return (-1);
}
}
#line 2454 "channels.c"
int channel_connect_to(char const   *host , u_short port ) 
{ int i ;
  int permit ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 2459
  permit = all_opens_permitted;
#line 2460
  if (! permit) {
#line 2461
    i = 0;
#line 2461
    while (i < num_permitted_opens) {
#line 2463
      if ((int )permitted_opens[i].port_to_connect == (int )port) {
#line 2463
        if (0) {
#line 2463
          __s1_len = strlen((char const   *)permitted_opens[i].host_to_connect);
#line 2463
          __s2_len = strlen(host);
#line 2463
          if (! ((unsigned int )((void const   *)(permitted_opens[i].host_to_connect + 1)) - (unsigned int )((void const   *)permitted_opens[i].host_to_connect) == 1U)) {
            goto _L___0;
          } else {
#line 2463
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 2463
              if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
#line 2463
                tmp___8 = 1;
              } else {
#line 2463
                if (__s2_len >= 4U) {
#line 2463
                  tmp___8 = 1;
                } else {
#line 2463
                  tmp___8 = 0;
                }
              }
            } else {
#line 2463
              tmp___8 = 0;
            }
          }
#line 2463
          if (tmp___8) {
#line 2463
            tmp___4 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                       host);
          } else {
#line 2463
            tmp___7 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                       host);
#line 2463
            tmp___4 = tmp___7;
          }
        } else {
#line 2463
          tmp___7 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                     host);
#line 2463
          tmp___4 = tmp___7;
        }
#line 2463
        if (tmp___4 == 0) {
#line 2464
          permit = 1;
        }
      }
#line 2461
      i ++;
    }
  }
#line 2467
  if (! permit) {
#line 2468
    logit("Received request to connect to host %.100s port %d, but the request was denied.",
          host, port);
#line 2470
    return (-1);
  }
#line 2472
  tmp___9 = connect_to(host, port);
#line 2472
  return (tmp___9);
}
}
#line 2482 "channels.c"
int x11_create_display_inet(int x11_display_offset , int x11_use_localhost , int single_connection ,
                            u_int *display_numberp ) 
{ Channel *nc ;
  int display_number ;
  int sock ;
  u_short port ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  int n___0 ;
  int num_socks ;
  int socks[10] ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int on ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;

  {
#line 2486
  nc = (Channel *)((void *)0);
#line 2491
  num_socks = 0;
#line 2493
  display_number = x11_display_offset;
#line 2493
  while (display_number < 1000) {
#line 2496
    port = (unsigned short )(6000 + display_number);
#line 2497
    memset((void *)(& hints), 0, sizeof(hints));
#line 2498
    hints.ai_family = IPv4or6___0;
#line 2499
    if (x11_use_localhost) {
#line 2499
      hints.ai_flags = 0;
    } else {
#line 2499
      hints.ai_flags = 1;
    }
#line 2500
    hints.ai_socktype = 1;
#line 2501
    snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
             port);
#line 2502
    gaierr = getaddrinfo((char const   * __restrict  )((void *)0), (char const   * __restrict  )(strport),
                         (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 2502
    if (gaierr != 0) {
#line 2503
      tmp = gai_strerror(gaierr);
#line 2503
      error("getaddrinfo: %.100s", tmp);
#line 2504
      return (-1);
    }
#line 2506
    ai = aitop;
#line 2506
    while (ai) {
#line 2507
      if (ai->ai_family != 2) {
#line 2507
        if (ai->ai_family != 10) {
          goto __Cont;
        }
      }
#line 2509
      sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
#line 2511
      if (sock < 0) {
#line 2512
        tmp___2 = __errno_location();
#line 2512
        if (*tmp___2 != 22) {
#line 2512
          tmp___3 = __errno_location();
#line 2512
          if (*tmp___3 != 97) {
#line 2513
            tmp___0 = __errno_location();
#line 2513
            tmp___1 = strerror(*tmp___0);
#line 2513
            error("socket: %.100s", tmp___1);
#line 2514
            return (-1);
          } else {
#line 2516
            debug("x11_create_display_inet: Socket family %d not supported", ai->ai_family);
            goto __Cont;
          }
        } else {
#line 2516
          debug("x11_create_display_inet: Socket family %d not supported", ai->ai_family);
          goto __Cont;
        }
      }
#line 2522
      if (ai->ai_family == 10) {
#line 2523
        on = 1;
#line 2524
        tmp___6 = setsockopt(sock, 41, 26, (void const   *)(& on), sizeof(on));
#line 2524
        if (tmp___6 < 0) {
#line 2525
          tmp___4 = __errno_location();
#line 2525
          tmp___5 = strerror(*tmp___4);
#line 2525
          error("setsockopt IPV6_V6ONLY: %.100s", tmp___5);
        }
      }
#line 2528
      tmp___9 = bind(sock, (struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen);
#line 2528
      if (tmp___9 < 0) {
#line 2529
        tmp___7 = __errno_location();
#line 2529
        tmp___8 = strerror(*tmp___7);
#line 2529
        debug2("bind port %d: %.100s", port, tmp___8);
#line 2530
        close(sock);
#line 2532
        if (ai->ai_next) {
          goto __Cont;
        }
#line 2535
        n___0 = 0;
#line 2535
        while (n___0 < num_socks) {
#line 2536
          close(socks[n___0]);
#line 2535
          n___0 ++;
        }
#line 2538
        num_socks = 0;
#line 2539
        break;
      }
#line 2541
      tmp___10 = num_socks;
#line 2541
      num_socks ++;
#line 2541
      socks[tmp___10] = sock;
#line 2546
      if (x11_use_localhost) {
#line 2547
        if (num_socks == 10) {
#line 2548
          break;
        }
      } else {
#line 2550
        break;
      }
      __Cont: /* CIL Label */ 
#line 2506
      ai = ai->ai_next;
    }
#line 2554
    freeaddrinfo(aitop);
#line 2555
    if (num_socks > 0) {
#line 2556
      break;
    }
#line 2493
    display_number ++;
  }
#line 2558
  if (display_number >= 1000) {
#line 2559
    error("Failed to allocate internet-domain X11 display socket.");
#line 2560
    return (-1);
  }
#line 2563
  n___0 = 0;
#line 2563
  while (n___0 < num_socks) {
#line 2564
    sock = socks[n___0];
#line 2565
    tmp___13 = listen(sock, 128);
#line 2565
    if (tmp___13 < 0) {
#line 2566
      tmp___11 = __errno_location();
#line 2566
      tmp___12 = strerror(*tmp___11);
#line 2566
      error("listen: %.100s", tmp___12);
#line 2567
      close(sock);
#line 2568
      return (-1);
    }
#line 2563
    n___0 ++;
  }
#line 2573
  n___0 = 0;
#line 2573
  while (n___0 < num_socks) {
#line 2574
    sock = socks[n___0];
#line 2575
    nc = channel_new((char *)"x11 listener", 1, sock, sock, -1, 65536U, 16384U, 0,
                     (char *)"X11 inet listener", 1);
#line 2579
    nc->single_connection = single_connection;
#line 2573
    n___0 ++;
  }
#line 2583
  *display_numberp = (unsigned int )display_number;
#line 2584
  return (0);
}
}
#line 2587 "channels.c"
static int connect_local_xsocket(u_int dnr ) 
{ int sock ;
  struct sockaddr_un addr ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 2593
  sock = socket(1, 1, 0);
#line 2594
  if (sock < 0) {
#line 2595
    tmp = __errno_location();
#line 2595
    tmp___0 = strerror(*tmp);
#line 2595
    error("socket: %.100s", tmp___0);
  }
#line 2596
  memset((void *)(& addr), 0, sizeof(addr));
#line 2597
  addr.sun_family = (unsigned short)1;
#line 2598
  snprintf((char * __restrict  )(addr.sun_path), sizeof(addr.sun_path), (char const   * __restrict  )"/tmp/.X11-unix/X%u",
           dnr);
#line 2599
  tmp___1 = connect(sock, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& addr)),
                    sizeof(addr));
#line 2599
  if (tmp___1 == 0) {
#line 2600
    return (sock);
  }
#line 2601
  close(sock);
#line 2602
  tmp___2 = __errno_location();
#line 2602
  tmp___3 = strerror(*tmp___2);
#line 2602
  error("connect %.100s: %.100s", addr.sun_path, tmp___3);
#line 2603
  return (-1);
}
}
#line 2606 "channels.c"
int x11_connect_display(void) 
{ int display_number ;
  int sock ;
  char const   *display ;
  char buf___1[1024] ;
  char *cp ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___29 ;
  int tmp___30 ;
  char const   *tmp___31 ;
  int *tmp___32 ;
  char *tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  int *tmp___37 ;
  char *tmp___38 ;

  {
#line 2609
  sock = 0;
#line 2617
  tmp = getenv("DISPLAY");
#line 2617
  display = (char const   *)tmp;
#line 2618
  if (! display) {
#line 2619
    error("DISPLAY not set.");
#line 2620
    return (-1);
  }
#line 2631
  if (0) {
#line 2631
    if (0) {
#line 2631
      __s1_len___0 = strlen(display);
#line 2631
      __s2_len___0 = strlen("unix:");
#line 2631
      if (! ((unsigned int )((void const   *)(display + 1)) - (unsigned int )((void const   *)display) == 1U)) {
        goto _L___2;
      } else {
#line 2631
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 2631
          if (! ((unsigned int )((void const   *)("unix:" + 1)) - (unsigned int )((void const   *)"unix:") == 1U)) {
#line 2631
            tmp___25 = 1;
          } else {
#line 2631
            if (__s2_len___0 >= 4U) {
#line 2631
              tmp___25 = 1;
            } else {
#line 2631
              tmp___25 = 0;
            }
          }
        } else {
#line 2631
          tmp___25 = 0;
        }
      }
#line 2631
      if (tmp___25) {
#line 2631
        tmp___21 = __builtin_strcmp(display, "unix:");
      } else {
#line 2631
        tmp___24 = __builtin_strcmp(display, "unix:");
#line 2631
        tmp___21 = tmp___24;
      }
    } else {
#line 2631
      tmp___24 = __builtin_strcmp(display, "unix:");
#line 2631
      tmp___21 = tmp___24;
    }
#line 2631
    tmp___15 = tmp___21;
  } else {
#line 2631
    tmp___15 = strncmp(display, "unix:", 5U);
  }
#line 2631
  if (tmp___15 == 0) {
    goto _L___3;
  } else {
#line 2631
    if ((int const   )*(display + 0) == 58) {
      _L___3: /* CIL Label */ 
#line 2634
      tmp___0 = strrchr(display, ':');
#line 2634
      tmp___1 = sscanf((char const   * __restrict  )(tmp___0 + 1), (char const   * __restrict  )"%d",
                       & display_number);
#line 2634
      if (tmp___1 != 1) {
#line 2635
        error("Could not parse display number from DISPLAY: %.100s", display);
#line 2637
        return (-1);
      }
#line 2640
      sock = connect_local_xsocket((unsigned int )display_number);
#line 2641
      if (sock < 0) {
#line 2642
        return (-1);
      }
#line 2645
      return (sock);
    }
  }
#line 2651
  strlcpy(buf___1, display, sizeof(buf___1));
#line 2652
  tmp___29 = __builtin_strchr(buf___1, ':');
#line 2652
  cp = tmp___29;
#line 2653
  if (! cp) {
#line 2654
    error("Could not find \':\' in DISPLAY: %.100s", display);
#line 2655
    return (-1);
  }
#line 2657
  *cp = (char)0;
#line 2659
  tmp___30 = sscanf((char const   * __restrict  )(cp + 1), (char const   * __restrict  )"%d",
                    & display_number);
#line 2659
  if (tmp___30 != 1) {
#line 2660
    error("Could not parse display number from DISPLAY: %.100s", display);
#line 2662
    return (-1);
  }
#line 2666
  memset((void *)(& hints), 0, sizeof(hints));
#line 2667
  hints.ai_family = IPv4or6___0;
#line 2668
  hints.ai_socktype = 1;
#line 2669
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           6000 + display_number);
#line 2670
  gaierr = getaddrinfo((char const   * __restrict  )(buf___1), (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 2670
  if (gaierr != 0) {
#line 2671
    tmp___31 = gai_strerror(gaierr);
#line 2671
    error("%.100s: unknown host. (%s)", buf___1, tmp___31);
#line 2672
    return (-1);
  }
#line 2674
  ai = aitop;
#line 2674
  while (ai) {
#line 2676
    sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
#line 2677
    if (sock < 0) {
#line 2678
      tmp___32 = __errno_location();
#line 2678
      tmp___33 = strerror(*tmp___32);
#line 2678
      debug2("socket: %.100s", tmp___33);
      goto __Cont;
    }
#line 2682
    tmp___36 = connect(sock, (struct sockaddr  const  * __restrict  )ai->ai_addr,
                       ai->ai_addrlen);
#line 2682
    if (tmp___36 < 0) {
#line 2683
      tmp___34 = __errno_location();
#line 2683
      tmp___35 = strerror(*tmp___34);
#line 2683
      debug2("connect %.100s port %d: %.100s", buf___1, 6000 + display_number, tmp___35);
#line 2685
      close(sock);
      goto __Cont;
    }
#line 2689
    break;
    __Cont: /* CIL Label */ 
#line 2674
    ai = ai->ai_next;
  }
#line 2691
  freeaddrinfo(aitop);
#line 2692
  if (! ai) {
#line 2693
    tmp___37 = __errno_location();
#line 2693
    tmp___38 = strerror(*tmp___37);
#line 2693
    error("connect %.100s port %d: %.100s", buf___1, 6000 + display_number, tmp___38);
#line 2695
    return (-1);
  }
#line 2697
  set_nodelay(sock);
#line 2698
  return (sock);
}
}
#line 2707 "channels.c"
void x11_input_open(int type , u_int32_t seq , void *ctxt ) 
{ Channel *c ;
  int remote_id ;
  int sock ;
  char *remote_host ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  int _len ;
  int tmp___2 ;

  {
#line 2710
  c = (Channel *)((void *)0);
#line 2711
  sock = 0;
#line 2714
  debug("Received X11 open request.");
#line 2716
  tmp = packet_get_int();
#line 2716
  remote_id = (int )tmp;
#line 2718
  tmp___1 = packet_get_protocol_flags();
#line 2718
  if (tmp___1 & 2U) {
#line 2719
    tmp___0 = packet_get_string((u_int *)((void *)0));
#line 2719
    remote_host = (char *)tmp___0;
  } else {
#line 2721
    remote_host = xstrdup("unknown (remote did not supply name)");
  }
#line 2723
  while (1) {
#line 2723
    tmp___2 = packet_remaining();
#line 2723
    _len = tmp___2;
#line 2723
    if (_len > 0) {
#line 2723
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2723);
#line 2723
      packet_disconnect("Packet integrity error.");
    }
#line 2723
    break;
  }
#line 2726
  sock = x11_connect_display();
#line 2727
  if (sock != -1) {
#line 2729
    c = channel_new((char *)"connected x11 socket", 7, sock, sock, -1, 0U, 0U, 0,
                    remote_host, 1);
#line 2732
    c->remote_id = remote_id;
#line 2733
    c->force_drain = 1;
  }
#line 2735
  xfree((void *)remote_host);
#line 2736
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2738
    packet_start((unsigned char)22);
#line 2739
    packet_put_int((unsigned int )remote_id);
  } else {
#line 2742
    packet_start((unsigned char)21);
#line 2743
    packet_put_int((unsigned int )remote_id);
#line 2744
    packet_put_int((unsigned int )c->self);
  }
#line 2746
  packet_send();
#line 2747
  return;
}
}
#line 2750 "channels.c"
void deny_input_open(int type , u_int32_t seq , void *ctxt ) 
{ int rchan ;
  u_int tmp ;

  {
#line 2753
  tmp = packet_get_int();
#line 2753
  rchan = (int )tmp;
#line 2755
  switch (type) {
  case 31: 
#line 2757
  error("Warning: ssh server tried agent forwarding.");
#line 2758
  break;
  case 27: 
#line 2760
  error("Warning: ssh server tried X11 forwarding.");
#line 2761
  break;
  default: 
#line 2763
  error("deny_input_open: type %d", type);
#line 2764
  break;
  }
#line 2766
  error("Warning: this is probably a break in attempt by a malicious server.");
#line 2767
  packet_start((unsigned char)22);
#line 2768
  packet_put_int((unsigned int )rchan);
#line 2769
  packet_send();
#line 2770
  return;
}
}
#line 2777 "channels.c"
void x11_request_forwarding_with_spoofing(int client_session_id , char const   *proto ,
                                          char const   *data ) 
{ u_int data_len ;
  size_t tmp ;
  u_int i ;
  u_int value ;
  u_int len ;
  char *new_data ;
  int screen_number ;
  char const   *cp ;
  u_int32_t rand___0 ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;

  {
#line 2781
  tmp = strlen(data);
#line 2781
  data_len = tmp / 2U;
#line 2786
  rand___0 = (u_int32_t )0;
#line 2788
  tmp___0 = getenv("DISPLAY");
#line 2788
  cp = (char const   *)tmp___0;
#line 2789
  if (cp) {
#line 2790
    tmp___2 = __builtin_strchr((char *)cp, ':');
#line 2790
    cp = (char const   *)tmp___2;
  }
#line 2791
  if (cp) {
#line 2792
    tmp___4 = __builtin_strchr((char *)cp, '.');
#line 2792
    cp = (char const   *)tmp___4;
  }
#line 2793
  if (cp) {
#line 2794
    screen_number = atoi(cp + 1);
  } else {
#line 2796
    screen_number = 0;
  }
#line 2799
  x11_saved_proto = xstrdup(proto);
#line 2805
  tmp___5 = xmalloc(data_len);
#line 2805
  x11_saved_data = (char *)tmp___5;
#line 2806
  tmp___6 = xmalloc(data_len);
#line 2806
  x11_fake_data = (char *)tmp___6;
#line 2807
  i = 0U;
#line 2807
  while (i < data_len) {
#line 2808
    tmp___7 = sscanf((char const   * __restrict  )(data + 2U * i), (char const   * __restrict  )"%2x",
                     & value);
#line 2808
    if (tmp___7 != 1) {
#line 2809
      fatal("x11_request_forwarding: bad authentication data: %.100s", data);
    }
#line 2810
    if (i % 4U == 0U) {
#line 2811
      rand___0 = arc4random();
    }
#line 2812
    *(x11_saved_data + i) = (char )value;
#line 2813
    *(x11_fake_data + i) = (char )(rand___0 & 255U);
#line 2814
    rand___0 >>= 8;
#line 2807
    i ++;
  }
#line 2816
  x11_saved_data_len = data_len;
#line 2817
  x11_fake_data_len = data_len;
#line 2820
  len = 2U * data_len + 1U;
#line 2821
  tmp___8 = xmalloc(len);
#line 2821
  new_data = (char *)tmp___8;
#line 2822
  i = 0U;
#line 2822
  while (i < data_len) {
#line 2823
    snprintf((char * __restrict  )(new_data + 2U * i), len - 2U * i, (char const   * __restrict  )"%02x",
             (unsigned char )*(x11_fake_data + i));
#line 2822
    i ++;
  }
#line 2827
  if (compat20) {
#line 2828
    channel_request_start(client_session_id, (char *)"x11-req", 0);
#line 2829
    packet_put_char(0);
  } else {
#line 2831
    packet_start((unsigned char)34);
  }
#line 2833
  packet_put_cstring(proto);
#line 2834
  packet_put_cstring((char const   *)new_data);
#line 2835
  packet_put_int((unsigned int )screen_number);
#line 2836
  packet_send();
#line 2837
  packet_write_wait();
#line 2838
  xfree((void *)new_data);
#line 2839
  return;
}
}
#line 2846 "channels.c"
void auth_request_forwarding(void) 
{ 

  {
#line 2849
  packet_start((unsigned char)30);
#line 2850
  packet_send();
#line 2851
  packet_write_wait();
#line 2852
  return;
}
}
#line 1 "cipher.o"
#line 325 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 1205 "/usr/include/bits/string2.h"
extern char *__strsep_g(char **__stringp , char const   *__delim ) ;
#line 527 "/usr/include/openssl/evp.h"
extern int EVP_CipherInit(EVP_CIPHER_CTX *ctx , EVP_CIPHER const   *cipher , unsigned char const   *key ,
                          unsigned char const   *iv , int enc ) ;
#line 567
extern void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *a ) ;
#line 568
extern int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *a ) ;
#line 571
extern int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x , int keylen ) ;
#line 613
extern EVP_CIPHER const   *EVP_enc_null(void) ;
#line 637
extern EVP_CIPHER const   *EVP_des_cbc(void) ;
#line 652
extern EVP_CIPHER const   *EVP_rc4(void) ;
#line 666
extern EVP_CIPHER const   *EVP_bf_cbc(void) ;
#line 673
extern EVP_CIPHER const   *EVP_cast5_cbc(void) ;
#line 680
extern EVP_CIPHER const   *EVP_aes_128_cbc(void) ;
#line 690
extern EVP_CIPHER const   *EVP_aes_192_cbc(void) ;
#line 700
extern EVP_CIPHER const   *EVP_aes_256_cbc(void) ;
#line 71 "cipher.h"
u_int cipher_mask_ssh1(int client ) ;
#line 72
Cipher *cipher_by_name(char const   *name ) ;
#line 74
int cipher_number(char const   *name ) ;
#line 75
char *cipher_name(int id ) ;
#line 76
int ciphers_valid(char const   *names ) ;
#line 77
void cipher_init(CipherContext *cc , Cipher *cipher , u_char const   *key , u_int keylen ,
                 u_char const   *iv , u_int ivlen , int encrypt ) ;
#line 82
u_int cipher_blocksize(Cipher const   *c ) ;
#line 83
u_int cipher_keylen(Cipher const   *c ) ;
#line 85
u_int cipher_get_number(Cipher const   *c ) ;
#line 86
void cipher_get_keyiv(CipherContext *cc , u_char *iv , u_int len ) ;
#line 87
void cipher_set_keyiv(CipherContext *cc , u_char *iv ) ;
#line 88
int cipher_get_keyiv_len(CipherContext const   *cc ) ;
#line 89
int cipher_get_keycontext(CipherContext const   *cc , u_char *dat ) ;
#line 90
void cipher_set_keycontext(CipherContext *cc , u_char *dat ) ;
#line 107 "/usr/include/openssl/md5.h"
extern int MD5_Init(MD5_CTX *c ) ;
#line 108
extern int MD5_Update(MD5_CTX *c , void const   *data , size_t len ) ;
#line 109
extern int MD5_Final(unsigned char *md , MD5_CTX *c ) ;
#line 58 "cipher.c"
EVP_CIPHER const   *evp_acss(void) ;
#line 66
EVP_CIPHER const   *evp_ssh1_bf(void) ;
#line 67
EVP_CIPHER const   *evp_ssh1_3des(void) ;
#line 68
void ssh1_3des_iv(EVP_CIPHER_CTX *evp , int doset , u_char *iv , int len ) ;
#line 69
EVP_CIPHER const   *evp_aes_128_ctr(void) ;
#line 70
void ssh_aes_ctr_iv(EVP_CIPHER_CTX *evp , int doset , u_char *iv , u_int len ) ;
#line 72 "cipher.c"
struct Cipher ciphers[17]  = 
#line 72
  {      {(char *)"none", 0, (u_int )8, (u_int )0, & EVP_enc_null}, 
        {(char *)"des", 2, (u_int )8, (u_int )8, & EVP_des_cbc}, 
        {(char *)"3des", 3, (u_int )8, (u_int )16, & evp_ssh1_3des}, 
        {(char *)"blowfish", 6, (u_int )8, (u_int )32, & evp_ssh1_bf}, 
        {(char *)"3des-cbc", -3, (u_int )8, (u_int )24, & EVP_des_ede3_cbc}, 
        {(char *)"blowfish-cbc", -3, (u_int )8, (u_int )16, & EVP_bf_cbc}, 
        {(char *)"cast128-cbc", -3, (u_int )8, (u_int )16, & EVP_cast5_cbc}, 
        {(char *)"arcfour", -3, (u_int )8, (u_int )16, & EVP_rc4}, 
        {(char *)"aes128-cbc", -3, (u_int )16, (u_int )16, & EVP_aes_128_cbc}, 
        {(char *)"aes192-cbc", -3, (u_int )16, (u_int )24, & EVP_aes_192_cbc}, 
        {(char *)"aes256-cbc", -3, (u_int )16, (u_int )32, & EVP_aes_256_cbc}, 
        {(char *)"rijndael-cbc@lysator.liu.se", -3, (u_int )16, (u_int )32, & EVP_aes_256_cbc}, 
        {(char *)"aes128-ctr",
      -3, (u_int )16, (u_int )16, & evp_aes_128_ctr}, 
        {(char *)"aes192-ctr", -3, (u_int )16, (u_int )24, & evp_aes_128_ctr}, 
        {(char *)"aes256-ctr", -3, (u_int )16, (u_int )32, & evp_aes_128_ctr}, 
        {(char *)"acss@openssh.org", -3, (u_int )16, (u_int )5, & evp_acss}, 
        {(char *)((void *)0), -2, (u_int )0, (u_int )0, (EVP_CIPHER const   *(*)(void))((void *)0)}};
#line 114 "cipher.c"
u_int cipher_blocksize(Cipher const   *c ) 
{ 

  {
#line 117
  return ((unsigned int )c->block_size);
}
}
#line 120 "cipher.c"
u_int cipher_keylen(Cipher const   *c ) 
{ 

  {
#line 123
  return ((unsigned int )c->key_len);
}
}
#line 126 "cipher.c"
u_int cipher_get_number(Cipher const   *c ) 
{ 

  {
#line 129
  return ((unsigned int )c->number);
}
}
#line 132 "cipher.c"
u_int cipher_mask_ssh1(int client ) 
{ u_int mask ;

  {
#line 135
  mask = (u_int )0;
#line 136
  mask |= (unsigned int )(1 << 3);
#line 137
  mask |= (unsigned int )(1 << 6);
#line 138
  if (client) {
#line 139
    mask |= (unsigned int )(1 << 2);
  }
#line 141
  return (mask);
}
}
#line 144 "cipher.c"
Cipher *cipher_by_name(char const   *name ) 
{ Cipher *c ;
  int tmp ;

  {
#line 148
  c = ciphers;
#line 148
  while ((unsigned int )c->name != (unsigned int )((void *)0)) {
#line 149
    tmp = strcasecmp((char const   *)c->name, name);
#line 149
    if (tmp == 0) {
#line 150
      return (c);
    }
#line 148
    c ++;
  }
#line 151
  return ((Cipher *)((void *)0));
}
}
#line 154 "cipher.c"
Cipher *cipher_by_number(int id ) 
{ Cipher *c ;

  {
#line 158
  c = ciphers;
#line 158
  while ((unsigned int )c->name != (unsigned int )((void *)0)) {
#line 159
    if (c->number == id) {
#line 160
      return (c);
    }
#line 158
    c ++;
  }
#line 161
  return ((Cipher *)((void *)0));
}
}
#line 165 "cipher.c"
int ciphers_valid(char const   *names ) 
{ Cipher *c ;
  char *ciphers___0 ;
  char *cp ;
  char *p ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___24 ;
  char *tmp___40 ;

  {
#line 172
  if ((unsigned int )names == (unsigned int )((void *)0)) {
#line 173
    return (0);
  } else {
#line 172
    if (0) {
#line 172
      __s1_len = strlen(names);
#line 172
      __s2_len = strlen("");
#line 172
      if (! ((unsigned int )((void const   *)(names + 1)) - (unsigned int )((void const   *)names) == 1U)) {
        goto _L___0;
      } else {
#line 172
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 172
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 172
            tmp___8 = 1;
          } else {
#line 172
            if (__s2_len >= 4U) {
#line 172
              tmp___8 = 1;
            } else {
#line 172
              tmp___8 = 0;
            }
          }
        } else {
#line 172
          tmp___8 = 0;
        }
      }
#line 172
      if (tmp___8) {
#line 172
        tmp___4 = __builtin_strcmp(names, "");
      } else {
#line 172
        tmp___7 = __builtin_strcmp(names, "");
#line 172
        tmp___4 = tmp___7;
      }
    } else {
#line 172
      tmp___7 = __builtin_strcmp(names, "");
#line 172
      tmp___4 = tmp___7;
    }
#line 172
    if (tmp___4 == 0) {
#line 173
      return (0);
    }
  }
#line 174
  cp = xstrdup(names);
#line 174
  ciphers___0 = cp;
#line 175
  tmp___24 = __strsep_g(& cp, ",");
#line 175
  p = tmp___24;
#line 175
  while (1) {
#line 175
    if (p) {
#line 175
      if (! ((int )*p != 0)) {
#line 175
        break;
      }
    } else {
#line 175
      break;
    }
#line 177
    c = cipher_by_name((char const   *)p);
#line 178
    if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 179
      debug("bad cipher %s [%s]", p, names);
#line 180
      xfree((void *)ciphers___0);
#line 181
      return (0);
    } else {
#line 178
      if (c->number != -3) {
#line 179
        debug("bad cipher %s [%s]", p, names);
#line 180
        xfree((void *)ciphers___0);
#line 181
        return (0);
      } else {
#line 183
        debug3("cipher ok: %s [%s]", p, names);
      }
    }
#line 176
    tmp___40 = __strsep_g(& cp, ",");
#line 176
    p = tmp___40;
  }
#line 186
  debug3("ciphers ok: [%s]", names);
#line 187
  xfree((void *)ciphers___0);
#line 188
  return (1);
}
}
#line 196 "cipher.c"
int cipher_number(char const   *name ) 
{ Cipher *c ;
  int tmp ;

  {
#line 200
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 201
    return (-1);
  }
#line 202
  c = cipher_by_name(name);
#line 203
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 203
    tmp = -1;
  } else {
#line 203
    tmp = c->number;
  }
#line 203
  return (tmp);
}
}
#line 206 "cipher.c"
char *cipher_name(int id ) 
{ Cipher *c ;
  Cipher *tmp ;
  char const   *tmp___0 ;

  {
#line 209
  tmp = cipher_by_number(id);
#line 209
  c = tmp;
#line 210
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 210
    tmp___0 = "<unknown>";
  } else {
#line 210
    tmp___0 = (char const   *)c->name;
  }
#line 210
  return ((char *)tmp___0);
}
}
#line 218 "cipher.c"
static int dowarn  =    1;
#line 213 "cipher.c"
void cipher_init(CipherContext *cc , Cipher *cipher , u_char const   *key , u_int keylen ,
                 u_char const   *iv , u_int ivlen , int encrypt ) 
{ EVP_CIPHER const   *type ;
  int klen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 226
  if (cipher->number == 2) {
#line 227
    if (dowarn) {
#line 228
      error("Warning: use of DES is strongly discouraged due to cryptographic weaknesses");
#line 230
      dowarn = 0;
    }
#line 232
    if (keylen > 8U) {
#line 233
      keylen = 8U;
    }
  }
#line 235
  cc->plaintext = cipher->number == 0;
#line 237
  if (keylen < cipher->key_len) {
#line 238
    fatal("cipher_init: key length %d is insufficient for %s.", keylen, cipher->name);
  }
#line 240
  if ((unsigned int )iv != (unsigned int )((void *)0)) {
#line 240
    if (ivlen < cipher->block_size) {
#line 241
      fatal("cipher_init: iv length %d is insufficient for %s.", ivlen, cipher->name);
    }
  }
#line 243
  cc->cipher = cipher;
#line 245
  type = (*(cipher->evptype))();
#line 247
  EVP_CIPHER_CTX_init(& cc->evp);
#line 257
  tmp = EVP_CipherInit(& cc->evp, type, (unsigned char const   *)((void *)0), (unsigned char const   *)((u_char *)iv),
                       encrypt == 1);
#line 257
  if (tmp == 0) {
#line 259
    fatal("cipher_init: EVP_CipherInit failed for %s", cipher->name);
  }
#line 261
  klen = cc->evp.key_len;
#line 262
  if (klen > 0) {
#line 262
    if (keylen != (u_int )klen) {
#line 263
      debug2("cipher_init: set keylen (%d -> %d)", klen, keylen);
#line 264
      tmp___0 = EVP_CIPHER_CTX_set_key_length(& cc->evp, (int )keylen);
#line 264
      if (tmp___0 == 0) {
#line 265
        fatal("cipher_init: set keylen failed (%d -> %d)", klen, keylen);
      }
    }
  }
#line 268
  tmp___1 = EVP_CipherInit(& cc->evp, (EVP_CIPHER const   *)((void *)0), (unsigned char const   *)((u_char *)key),
                           (unsigned char const   *)((void *)0), -1);
#line 268
  if (tmp___1 == 0) {
#line 269
    fatal("cipher_init: EVP_CipherInit: set key failed for %s", cipher->name);
  }
#line 272
  return;
}
}
#line 274 "cipher.c"
void cipher_crypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ int tmp ;

  {
#line 277
  if (len % (cc->cipher)->block_size) {
#line 278
    fatal("cipher_encrypt: bad plaintext length %d", len);
  }
#line 282
  tmp = (*((cc->evp.cipher)->do_cipher))(& cc->evp, dest, (unsigned char const   *)((u_char *)src),
                                         len);
#line 282
  if (tmp == 0) {
#line 283
    fatal("evp_crypt: EVP_Cipher failed");
  }
#line 285
  return;
}
}
#line 287 "cipher.c"
void cipher_cleanup(CipherContext *cc ) 
{ int tmp ;

  {
#line 293
  tmp = EVP_CIPHER_CTX_cleanup(& cc->evp);
#line 293
  if (tmp == 0) {
#line 294
    error("cipher_cleanup: EVP_CIPHER_CTX_cleanup failed");
  }
#line 296
  return;
}
}
#line 303 "cipher.c"
void cipher_set_key_string(CipherContext *cc , Cipher *cipher , char const   *passphrase ,
                           int encrypt ) 
{ MD5_CTX md ;
  u_char digest___1[16] ;
  size_t tmp ;

  {
#line 310
  MD5_Init(& md);
#line 311
  tmp = strlen(passphrase);
#line 311
  MD5_Update(& md, (void const   *)((u_char const   *)passphrase), tmp);
#line 312
  MD5_Final(digest___1, & md);
#line 314
  cipher_init(cc, cipher, (u_char const   *)(digest___1), 16U, (u_char const   *)((void *)0),
              0U, encrypt);
#line 316
  memset((void *)(digest___1), 0, sizeof(digest___1));
#line 317
  memset((void *)(& md), 0, sizeof(md));
#line 318
  return;
}
}
#line 326 "cipher.c"
int cipher_get_keyiv_len(CipherContext const   *cc ) 
{ Cipher *c ;
  int ivlen ;

  {
#line 329
  c = (Cipher *)cc->cipher;
#line 332
  if (c->number == 3) {
#line 333
    ivlen = 24;
  } else {
#line 335
    ivlen = (int )(cc->evp.cipher)->iv_len;
  }
#line 336
  return (ivlen);
}
}
#line 339 "cipher.c"
void cipher_get_keyiv(CipherContext *cc , u_char *iv , u_int len ) 
{ Cipher *c ;
  int evplen ;

  {
#line 342
  c = cc->cipher;
#line 345
  switch (c->number) {
  case -3: 
  case 2: 
  case 6: 
#line 349
  evplen = (int )(cc->evp.cipher)->iv_len;
#line 350
  if (evplen == 0) {
#line 351
    return;
  }
#line 352
  if ((u_int )evplen != len) {
#line 353
    fatal("%s: wrong iv length %d != %d", "cipher_get_keyiv", evplen, len);
  }
#line 360
  if ((unsigned int )c->evptype == (unsigned int )(& evp_aes_128_ctr)) {
#line 361
    ssh_aes_ctr_iv(& cc->evp, 0, iv, len);
  } else {
#line 363
    memcpy((void * __restrict  )iv, (void const   * __restrict  )(cc->evp.iv), len);
  }
#line 364
  break;
  case 3: 
#line 366
  ssh1_3des_iv(& cc->evp, 0, iv, 24);
#line 367
  break;
  default: 
#line 369
  fatal("%s: bad cipher %d", "cipher_get_keyiv", c->number);
  }
#line 371
  return;
}
}
#line 373 "cipher.c"
void cipher_set_keyiv(CipherContext *cc , u_char *iv ) 
{ Cipher *c ;
  int evplen ;

  {
#line 376
  c = cc->cipher;
#line 377
  evplen = 0;
#line 379
  switch (c->number) {
  case -3: 
  case 2: 
  case 6: 
#line 383
  evplen = (int )(cc->evp.cipher)->iv_len;
#line 384
  if (evplen == 0) {
#line 385
    return;
  }
#line 391
  if ((unsigned int )c->evptype == (unsigned int )(& evp_aes_128_ctr)) {
#line 392
    ssh_aes_ctr_iv(& cc->evp, 1, iv, (unsigned int )evplen);
  } else {
#line 394
    memcpy((void * __restrict  )(cc->evp.iv), (void const   * __restrict  )iv, (unsigned int )evplen);
  }
#line 395
  break;
  case 3: 
#line 397
  ssh1_3des_iv(& cc->evp, 1, iv, 24);
#line 398
  break;
  default: 
#line 400
  fatal("%s: bad cipher %d", "cipher_set_keyiv", c->number);
  }
#line 402
  return;
}
}
#line 412 "cipher.c"
int cipher_get_keycontext(CipherContext const   *cc , u_char *dat ) 
{ Cipher *c ;
  int plen ;

  {
#line 415
  c = (Cipher *)cc->cipher;
#line 416
  plen = 0;
#line 418
  if ((unsigned int )c->evptype == (unsigned int )(& EVP_rc4)) {
    goto _L;
  } else {
#line 418
    if ((unsigned int )c->evptype == (unsigned int )(& evp_acss)) {
      _L: /* CIL Label */ 
#line 419
      plen = (int )(cc->evp.cipher)->ctx_size;
#line 420
      if ((unsigned int )dat == (unsigned int )((void *)0)) {
#line 421
        return (plen);
      }
#line 422
      memcpy((void * __restrict  )dat, (void const   * __restrict  )cc->evp.cipher_data,
             (unsigned int )plen);
    }
  }
#line 424
  return (plen);
}
}
#line 427 "cipher.c"
void cipher_set_keycontext(CipherContext *cc , u_char *dat ) 
{ Cipher *c ;
  int plen ;

  {
#line 430
  c = cc->cipher;
#line 433
  if ((unsigned int )c->evptype == (unsigned int )(& EVP_rc4)) {
#line 434
    plen = (int )(cc->evp.cipher)->ctx_size;
#line 435
    memcpy((void * __restrict  )cc->evp.cipher_data, (void const   * __restrict  )dat,
           (unsigned int )plen);
  } else {
#line 433
    if ((unsigned int )c->evptype == (unsigned int )(& evp_acss)) {
#line 434
      plen = (int )(cc->evp.cipher)->ctx_size;
#line 435
      memcpy((void * __restrict  )cc->evp.cipher_data, (void const   * __restrict  )dat,
             (unsigned int )plen);
    }
  }
#line 437
  return;
}
}
#line 1 "cipher-acss.o"
#line 35 "cipher-acss.c"
static int acss_init_key(EVP_CIPHER_CTX *ctx , unsigned char const   *key , unsigned char const   *iv ,
                         int enc ) 
{ 

  {
#line 39
  acss_setkey(& ((EVP_ACSS_KEY *)ctx->cipher_data)->ks, key, enc, 3);
#line 40
  return (1);
}
}
#line 43 "cipher-acss.c"
static int acss_ciph(EVP_CIPHER_CTX *ctx , unsigned char *out , unsigned char const   *in ,
                     unsigned int inl ) 
{ 

  {
#line 47
  acss(& ((EVP_ACSS_KEY *)ctx->cipher_data)->ks, (unsigned long )inl, in, out);
#line 48
  return (1);
}
}
#line 51 "cipher-acss.c"
static int acss_ctrl(EVP_CIPHER_CTX *ctx , int type , int arg , void *ptr ) 
{ 

  {
#line 54
  switch (type) {
  case 65286: 
#line 56
  ((EVP_ACSS_KEY *)ctx->cipher_data)->ks.mode = arg;
#line 57
  return (1);
  case 65287: 
#line 59
  acss_setsubkey(& ((EVP_ACSS_KEY *)ctx->cipher_data)->ks, (unsigned char const   *)((unsigned char *)ptr));
#line 60
  return (1);
  default: ;
#line 62
  return (-1);
  }
}
}
#line 69 "cipher-acss.c"
static EVP_CIPHER acss_cipher  ;
#line 66 "cipher-acss.c"
EVP_CIPHER const   *evp_acss(void) 
{ 

  {
#line 71
  memset((void *)(& acss_cipher), 0, sizeof(EVP_CIPHER ));
#line 73
  acss_cipher.nid = 0;
#line 74
  acss_cipher.block_size = 1;
#line 75
  acss_cipher.key_len = 5;
#line 76
  acss_cipher.init = & acss_init_key;
#line 77
  acss_cipher.do_cipher = & acss_ciph;
#line 78
  acss_cipher.ctx_size = (int )sizeof(EVP_ACSS_KEY );
#line 79
  acss_cipher.ctrl = & acss_ctrl;
#line 81
  return ((EVP_CIPHER const   *)(& acss_cipher));
}
}
#line 1 "cipher-aes.o"
#line 1 "cipher-bf1.o"
#line 43 "cipher-bf1.c"
static void swap_bytes(u_char const   *src , u_char *dst , int n___0 ) 
{ u_char c[4] ;
  u_char const   *tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  u_char const   *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  u_char *tmp___6 ;

  {
#line 49
  n___0 /= 4;
#line 49
  while (n___0 > 0) {
#line 50
    tmp = src;
#line 50
    src ++;
#line 50
    c[3] = (unsigned char )*tmp;
#line 51
    tmp___0 = src;
#line 51
    src ++;
#line 51
    c[2] = (unsigned char )*tmp___0;
#line 52
    tmp___1 = src;
#line 52
    src ++;
#line 52
    c[1] = (unsigned char )*tmp___1;
#line 53
    tmp___2 = src;
#line 53
    src ++;
#line 53
    c[0] = (unsigned char )*tmp___2;
#line 55
    tmp___3 = dst;
#line 55
    dst ++;
#line 55
    *tmp___3 = c[0];
#line 56
    tmp___4 = dst;
#line 56
    dst ++;
#line 56
    *tmp___4 = c[1];
#line 57
    tmp___5 = dst;
#line 57
    dst ++;
#line 57
    *tmp___5 = c[2];
#line 58
    tmp___6 = dst;
#line 58
    dst ++;
#line 58
    *tmp___6 = c[3];
#line 49
    n___0 --;
  }
#line 60
  return;
}
}
#line 75 "cipher-bf1.c"
static int (*orig_bf)(EVP_CIPHER_CTX * , u_char * , u_char const   * , u_int  )  =    (int (*)(EVP_CIPHER_CTX * ,
            u_char * , u_char const   * , u_int  ))((void *)0);
#line 77 "cipher-bf1.c"
static int bf_ssh1_cipher(EVP_CIPHER_CTX *ctx , u_char *out , u_char const   *in ,
                          u_int len ) 
{ int ret ;

  {
#line 82
  swap_bytes(in, out, (int )len);
#line 83
  ret = (*orig_bf)(ctx, out, (u_char const   *)out, len);
#line 84
  swap_bytes((u_char const   *)out, out, (int )len);
#line 85
  return (ret);
}
}
#line 91 "cipher-bf1.c"
static EVP_CIPHER ssh1_bf  ;
#line 88 "cipher-bf1.c"
EVP_CIPHER const   *evp_ssh1_bf(void) 
{ EVP_CIPHER const   *tmp ;

  {
#line 93
  tmp = EVP_bf_cbc();
#line 93
  memcpy((void * __restrict  )(& ssh1_bf), (void const   * __restrict  )tmp, sizeof(EVP_CIPHER ));
#line 94
  orig_bf = ssh1_bf.do_cipher;
#line 95
  ssh1_bf.nid = 0;
#line 99
  ssh1_bf.do_cipher = & bf_ssh1_cipher;
#line 100
  ssh1_bf.key_len = 32;
#line 101
  return ((EVP_CIPHER const   *)(& ssh1_bf));
}
}
#line 1 "cipher-ctr.o"
#line 86 "/usr/include/openssl/aes.h"
extern int AES_set_encrypt_key(unsigned char const   *userKey , int bits , AES_KEY *key ) ;
#line 91
extern void AES_encrypt(unsigned char const   *in , unsigned char *out , AES_KEY const   *key ) ;
#line 52 "cipher-ctr.c"
static void ssh_ctr_inc(u_char *ctr , u_int len ) 
{ int i ;

  {
#line 57
  i = (int )(len - 1U);
#line 57
  while (i >= 0) {
#line 58
    *(ctr + i) = (u_char )((int )*(ctr + i) + 1);
#line 58
    if (*(ctr + i)) {
#line 59
      return;
    }
#line 57
    i --;
  }
#line 60
  return;
}
}
#line 62 "cipher-ctr.c"
static int ssh_aes_ctr(EVP_CIPHER_CTX *ctx , u_char *dest , u_char const   *src ,
                       u_int len ) 
{ struct ssh_aes_ctr_ctx *c ;
  u_int n___0 ;
  u_char buf___1[16] ;
  u_char *tmp ;
  u_char const   *tmp___0 ;
  u_int tmp___1 ;

  {
#line 67
  n___0 = (u_int )0;
#line 70
  if (len == 0U) {
#line 71
    return (1);
  }
#line 72
  c = (struct ssh_aes_ctr_ctx *)ctx->app_data;
#line 72
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 73
    return (0);
  }
#line 75
  while (1) {
#line 75
    tmp___1 = len;
#line 75
    len --;
#line 75
    if (! (tmp___1 > 0U)) {
#line 75
      break;
    }
#line 76
    if (n___0 == 0U) {
#line 77
      AES_encrypt((unsigned char const   *)(c->aes_counter), buf___1, (AES_KEY const   *)(& c->aes_ctx));
#line 78
      ssh_ctr_inc(c->aes_counter, 16U);
    }
#line 80
    tmp = dest;
#line 80
    dest ++;
#line 80
    tmp___0 = src;
#line 80
    src ++;
#line 80
    *tmp = (unsigned char )((int const   )*tmp___0 ^ (int const   )buf___1[n___0]);
#line 81
    n___0 = (n___0 + 1U) % 16U;
  }
#line 83
  return (1);
}
}
#line 86 "cipher-ctr.c"
static int ssh_aes_ctr_init(EVP_CIPHER_CTX *ctx , u_char const   *key , u_char const   *iv ,
                            int enc ) 
{ struct ssh_aes_ctr_ctx *c ;
  void *tmp ;

  {
#line 92
  c = (struct ssh_aes_ctr_ctx *)ctx->app_data;
#line 92
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 93
    tmp = xmalloc(sizeof(*c));
#line 93
    c = (struct ssh_aes_ctr_ctx *)tmp;
#line 94
    ctx->app_data = (void *)((char *)c);
  }
#line 96
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 97
    AES_set_encrypt_key(key, ctx->key_len * 8, & c->aes_ctx);
  }
#line 99
  if ((unsigned int )iv != (unsigned int )((void *)0)) {
#line 100
    memcpy((void * __restrict  )(c->aes_counter), (void const   * __restrict  )iv,
           16U);
  }
#line 101
  return (1);
}
}
#line 104 "cipher-ctr.c"
static int ssh_aes_ctr_cleanup(EVP_CIPHER_CTX *ctx ) 
{ struct ssh_aes_ctr_ctx *c ;

  {
#line 109
  c = (struct ssh_aes_ctr_ctx *)ctx->app_data;
#line 109
  if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 110
    memset((void *)c, 0, sizeof(*c));
#line 111
    xfree((void *)c);
#line 112
    ctx->app_data = (void *)((char *)((void *)0));
  }
#line 114
  return (1);
}
}
#line 117 "cipher-ctr.c"
void ssh_aes_ctr_iv(EVP_CIPHER_CTX *evp , int doset , u_char *iv , u_int len ) 
{ struct ssh_aes_ctr_ctx *c ;

  {
#line 122
  c = (struct ssh_aes_ctr_ctx *)evp->app_data;
#line 122
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 123
    fatal("ssh_aes_ctr_iv: no context");
  }
#line 124
  if (doset) {
#line 125
    memcpy((void * __restrict  )(c->aes_counter), (void const   * __restrict  )iv,
           len);
  } else {
#line 127
    memcpy((void * __restrict  )iv, (void const   * __restrict  )(c->aes_counter),
           len);
  }
#line 128
  return;
}
}
#line 133 "cipher-ctr.c"
static EVP_CIPHER aes_ctr  ;
#line 130 "cipher-ctr.c"
EVP_CIPHER const   *evp_aes_128_ctr(void) 
{ 

  {
#line 135
  memset((void *)(& aes_ctr), 0, sizeof(EVP_CIPHER ));
#line 136
  aes_ctr.nid = 0;
#line 137
  aes_ctr.block_size = 16;
#line 138
  aes_ctr.iv_len = 16;
#line 139
  aes_ctr.key_len = 16;
#line 140
  aes_ctr.init = & ssh_aes_ctr_init;
#line 141
  aes_ctr.cleanup = & ssh_aes_ctr_cleanup;
#line 142
  aes_ctr.do_cipher = & ssh_aes_ctr;
#line 144
  aes_ctr.flags = 58UL;
#line 147
  return ((EVP_CIPHER const   *)(& aes_ctr));
}
}
#line 1 "cipher-3des1.o"
#line 58 "cipher-3des1.c"
static int ssh1_3des_init(EVP_CIPHER_CTX *ctx , u_char const   *key , u_char const   *iv ,
                          int enc ) 
{ struct ssh1_3des_ctx *c ;
  u_char *k1 ;
  u_char *k2 ;
  u_char *k3 ;
  void *tmp ;
  EVP_CIPHER const   *tmp___0 ;
  int tmp___1 ;
  EVP_CIPHER const   *tmp___2 ;
  int tmp___3 ;
  EVP_CIPHER const   *tmp___4 ;
  int tmp___5 ;

  {
#line 65
  c = (struct ssh1_3des_ctx *)ctx->app_data;
#line 65
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 66
    tmp = xmalloc(sizeof(*c));
#line 66
    c = (struct ssh1_3des_ctx *)tmp;
#line 67
    ctx->app_data = (void *)((char *)c);
  }
#line 69
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 70
    return (1);
  }
#line 71
  if (enc == -1) {
#line 72
    enc = ctx->encrypt;
  }
#line 73
  k3 = (u_char *)key;
#line 73
  k2 = k3;
#line 73
  k1 = k2;
#line 74
  k2 += 8;
#line 75
  if (ctx->key_len >= 24) {
#line 76
    if (enc) {
#line 77
      k3 += 16;
    } else {
#line 79
      k1 += 16;
    }
  }
#line 81
  EVP_CIPHER_CTX_init(& c->k1);
#line 82
  EVP_CIPHER_CTX_init(& c->k2);
#line 83
  EVP_CIPHER_CTX_init(& c->k3);
#line 89
  tmp___0 = EVP_des_cbc();
#line 89
  tmp___1 = EVP_CipherInit(& c->k1, tmp___0, (unsigned char const   *)k1, (unsigned char const   *)((void *)0),
                           enc);
#line 89
  if (tmp___1 == 0) {
#line 92
    memset((void *)c, 0, sizeof(*c));
#line 93
    xfree((void *)c);
#line 94
    ctx->app_data = (void *)((char *)((void *)0));
#line 95
    return (0);
  } else {
#line 89
    tmp___2 = EVP_des_cbc();
#line 89
    tmp___3 = EVP_CipherInit(& c->k2, tmp___2, (unsigned char const   *)k2, (unsigned char const   *)((void *)0),
                             ! enc);
#line 89
    if (tmp___3 == 0) {
#line 92
      memset((void *)c, 0, sizeof(*c));
#line 93
      xfree((void *)c);
#line 94
      ctx->app_data = (void *)((char *)((void *)0));
#line 95
      return (0);
    } else {
#line 89
      tmp___4 = EVP_des_cbc();
#line 89
      tmp___5 = EVP_CipherInit(& c->k3, tmp___4, (unsigned char const   *)k3, (unsigned char const   *)((void *)0),
                               enc);
#line 89
      if (tmp___5 == 0) {
#line 92
        memset((void *)c, 0, sizeof(*c));
#line 93
        xfree((void *)c);
#line 94
        ctx->app_data = (void *)((char *)((void *)0));
#line 95
        return (0);
      }
    }
  }
#line 98
  return (1);
}
}
#line 101 "cipher-3des1.c"
static int ssh1_3des_cbc(EVP_CIPHER_CTX *ctx , u_char *dest , u_char const   *src ,
                         u_int len ) 
{ struct ssh1_3des_ctx *c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 106
  c = (struct ssh1_3des_ctx *)ctx->app_data;
#line 106
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 107
    error("ssh1_3des_cbc: no context");
#line 108
    return (0);
  }
#line 115
  tmp = (*((c->k1.cipher)->do_cipher))(& c->k1, dest, (unsigned char const   *)((u_char *)src),
                                       len);
#line 115
  if (tmp == 0) {
#line 118
    return (0);
  } else {
#line 115
    tmp___0 = (*((c->k2.cipher)->do_cipher))(& c->k2, dest, (unsigned char const   *)dest,
                                             len);
#line 115
    if (tmp___0 == 0) {
#line 118
      return (0);
    } else {
#line 115
      tmp___1 = (*((c->k3.cipher)->do_cipher))(& c->k3, dest, (unsigned char const   *)dest,
                                               len);
#line 115
      if (tmp___1 == 0) {
#line 118
        return (0);
      }
    }
  }
#line 120
  return (1);
}
}
#line 123 "cipher-3des1.c"
static int ssh1_3des_cleanup(EVP_CIPHER_CTX *ctx ) 
{ struct ssh1_3des_ctx *c ;

  {
#line 128
  c = (struct ssh1_3des_ctx *)ctx->app_data;
#line 128
  if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 129
    EVP_CIPHER_CTX_cleanup(& c->k1);
#line 130
    EVP_CIPHER_CTX_cleanup(& c->k2);
#line 131
    EVP_CIPHER_CTX_cleanup(& c->k3);
#line 132
    memset((void *)c, 0, sizeof(*c));
#line 133
    xfree((void *)c);
#line 134
    ctx->app_data = (void *)((char *)((void *)0));
  }
#line 136
  return (1);
}
}
#line 139 "cipher-3des1.c"
void ssh1_3des_iv(EVP_CIPHER_CTX *evp , int doset , u_char *iv , int len ) 
{ struct ssh1_3des_ctx *c ;

  {
#line 144
  if (len != 24) {
#line 145
    fatal("%s: bad 3des iv length: %d", "ssh1_3des_iv", len);
  }
#line 146
  c = (struct ssh1_3des_ctx *)evp->app_data;
#line 146
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 147
    fatal("%s: no 3des context", "ssh1_3des_iv");
  }
#line 148
  if (doset) {
#line 149
    debug3("%s: Installed 3DES IV", "ssh1_3des_iv");
#line 150
    memcpy((void * __restrict  )(c->k1.iv), (void const   * __restrict  )iv, 8U);
#line 151
    memcpy((void * __restrict  )(c->k2.iv), (void const   * __restrict  )(iv + 8),
           8U);
#line 152
    memcpy((void * __restrict  )(c->k3.iv), (void const   * __restrict  )(iv + 16),
           8U);
  } else {
#line 154
    debug3("%s: Copying 3DES IV", "ssh1_3des_iv");
#line 155
    memcpy((void * __restrict  )iv, (void const   * __restrict  )(c->k1.iv), 8U);
#line 156
    memcpy((void * __restrict  )(iv + 8), (void const   * __restrict  )(c->k2.iv),
           8U);
#line 157
    memcpy((void * __restrict  )(iv + 16), (void const   * __restrict  )(c->k3.iv),
           8U);
  }
#line 159
  return;
}
}
#line 164 "cipher-3des1.c"
static EVP_CIPHER ssh1_3des  ;
#line 161 "cipher-3des1.c"
EVP_CIPHER const   *evp_ssh1_3des(void) 
{ 

  {
#line 166
  memset((void *)(& ssh1_3des), 0, sizeof(EVP_CIPHER ));
#line 167
  ssh1_3des.nid = 0;
#line 168
  ssh1_3des.block_size = 8;
#line 169
  ssh1_3des.iv_len = 0;
#line 170
  ssh1_3des.key_len = 16;
#line 171
  ssh1_3des.init = & ssh1_3des_init;
#line 172
  ssh1_3des.cleanup = & ssh1_3des_cleanup;
#line 173
  ssh1_3des.do_cipher = & ssh1_3des_cbc;
#line 175
  ssh1_3des.flags = 10UL;
#line 177
  return ((EVP_CIPHER const   *)(& ssh1_3des));
}
}
#line 1 "cleanup.o"
#line 548 "/usr/include/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 22 "cleanup.c"
void cleanup_exit(int i ) 
{ 

  {
#line 25
  _exit(i);
}
}
#line 1 "compat.o"
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 59 "compat.h"
void enable_compat13(void) ;
#line 60
void enable_compat20(void) ;
#line 61
void compat_datafellows(char const   *version ) ;
#line 62
int proto_spec(char const   *spec ) ;
#line 63
char *compat_cipher_proposal(char *cipher_prop ) ;
#line 18 "match.h"
int match_pattern_list(char const   *string , char const   *pattern , u_int len ,
                       int dolower ) ;
#line 35 "compat.c"
int compat13  =    0;
#line 36 "compat.c"
int compat20  =    0;
#line 37 "compat.c"
int datafellows  =    0;
#line 39 "compat.c"
void enable_compat20(void) 
{ 

  {
#line 42
  debug("Enabling compatibility mode for protocol 2.0");
#line 43
  compat20 = 1;
#line 44
  return;
}
}
#line 45 "compat.c"
void enable_compat13(void) 
{ 

  {
#line 48
  debug("Enabling compatibility mode for protocol 1.3");
#line 49
  compat13 = 1;
#line 50
  return;
}
}
#line 56 "compat.c"
static struct __anonstruct_check_74 check[29]  = 
#line 56
  {      {(char *)"OpenSSH-2.0*,OpenSSH-2.1*,OpenSSH_2.1*,OpenSSH_2.2*", 2146448}, 
        {(char *)"OpenSSH_2.3.0*", 2150528}, 
        {(char *)"OpenSSH_2.3.*", 2150400}, 
        {(char *)"OpenSSH_2.5.0p1*,OpenSSH_2.5.1p1*", 2150400}, 
        {(char *)"OpenSSH_2.5.0*,OpenSSH_2.5.1*,OpenSSH_2.5.2*", 2146304}, 
        {(char *)"OpenSSH_2.5.3*", 2129920}, 
        {(char *)"OpenSSH_2.*,OpenSSH_3.0*,OpenSSH_3.1*", 2097152}, 
        {(char *)"Sun_SSH_1.0*", 2129920}, 
        {(char *)"OpenSSH*", 0}, 
        {(char *)"*MindTerm*", 0}, 
        {(char *)"2.1.0*", 8462421}, 
        {(char *)"2.1 *", 8462421}, 
        {(char *)"2.0.13*,2.0.14*,2.0.15*,2.0.16*,2.0.17*,2.0.18*,2.0.19*", 9642591}, 
        {(char *)"2.0.11*,2.0.12*",
      9577087}, 
        {(char *)"2.0.*", 9839231}, 
        {(char *)"2.2.0*,2.3.0*", 8396868}, 
        {(char *)"2.3.*", 8396864}, 
        {(char *)"2.4", 16}, 
        {(char *)"2.*", 8388672}, 
        {(char *)"3.0.*", 64}, 
        {(char *)"3.0 SecureCRT*", 16}, 
        {(char *)"1.7 SecureFX*", 16}, 
        {(char *)"1.2.18*,1.2.19*,1.2.20*,1.2.21*,1.2.22*", 256}, 
        {(char *)"1.3.2*", 256}, 
        {(char *)"*SSH Compatible Server*", 1024}, 
        {(char *)"*OSU_0*,OSU_1.0*,OSU_1.1*,OSU_1.2*,OSU_1.3*,OSU_1.4*,OSU_1.5alpha1*,OSU_1.5alpha2*,OSU_1.5alpha3*",
      1024}, 
        {(char *)"*SSH_Version_Mapper*", 2048}, 
        {(char *)"Probe-*", 4194304}, 
        {(char *)((void *)0), 0}};
#line 52 "compat.c"
void compat_datafellows(char const   *version ) 
{ int i ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 156
  i = 0;
#line 156
  while (check[i].pat) {
#line 157
    tmp = strlen((char const   *)check[i].pat);
#line 157
    tmp___0 = match_pattern_list(version, (char const   *)check[i].pat, tmp, 0);
#line 157
    if (tmp___0 == 1) {
#line 159
      debug("match: %s pat %s", version, check[i].pat);
#line 160
      datafellows = check[i].bugs;
#line 161
      return;
    }
#line 156
    i ++;
  }
#line 164
  debug("no match: %s", version);
#line 165
  return;
}
}
#line 168 "compat.c"
int proto_spec(char const   *spec ) 
{ char *s ;
  char *p ;
  char *q ;
  int ret ;
  char *tmp___14 ;
  char *tmp___30 ;
  int tmp___31 ;

  {
#line 172
  ret = 0;
#line 174
  if ((unsigned int )spec == (unsigned int )((void *)0)) {
#line 175
    return (ret);
  }
#line 176
  s = xstrdup(spec);
#line 176
  q = s;
#line 177
  tmp___14 = __strsep_g(& q, ",");
#line 177
  p = tmp___14;
#line 177
  while (1) {
#line 177
    if (p) {
#line 177
      if (! ((int )*p != 0)) {
#line 177
        break;
      }
    } else {
#line 177
      break;
    }
#line 178
    tmp___31 = atoi((char const   *)p);
#line 178
    switch (tmp___31) {
    case 1: 
#line 180
    if (ret == 0) {
#line 181
      ret |= 2;
    }
#line 182
    ret |= 1;
#line 183
    break;
    case 2: 
#line 185
    ret |= 4;
#line 186
    break;
    default: 
#line 188
    logit("ignoring bad proto spec: \'%s\'.", p);
#line 189
    break;
    }
#line 177
    tmp___30 = __strsep_g(& q, ",");
#line 177
    p = tmp___30;
  }
#line 192
  xfree((void *)s);
#line 193
  return (ret);
}
}
#line 196 "compat.c"
char *compat_cipher_proposal(char *cipher_prop ) 
{ Buffer b ;
  char *orig_prop ;
  char *fix_ciphers ;
  char *cp ;
  char *tmp ;
  u_int tmp___0 ;
  size_t tmp___1 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___43 ;
  void *tmp___44 ;

  {
#line 203
  if (! (datafellows & 4096)) {
#line 204
    return (cipher_prop);
  }
#line 206
  buffer_init(& b);
#line 207
  orig_prop = xstrdup((char const   *)cipher_prop);
#line 207
  tmp = orig_prop;
#line 208
  while (1) {
#line 208
    tmp___43 = __strsep_g(& tmp, ",");
#line 208
    cp = tmp___43;
#line 208
    if (! ((unsigned int )cp != (unsigned int )((void *)0))) {
#line 208
      break;
    }
#line 209
    if (0) {
#line 209
      if (0) {
#line 209
        __s1_len___0 = strlen((char const   *)cp);
#line 209
        __s2_len___0 = strlen("aes");
#line 209
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___2;
        } else {
#line 209
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 209
            if (! ((unsigned int )((void const   *)("aes" + 1)) - (unsigned int )((void const   *)"aes") == 1U)) {
#line 209
              tmp___25 = 1;
            } else {
#line 209
              if (__s2_len___0 >= 4U) {
#line 209
                tmp___25 = 1;
              } else {
#line 209
                tmp___25 = 0;
              }
            }
          } else {
#line 209
            tmp___25 = 0;
          }
        }
#line 209
        if (tmp___25) {
#line 209
          tmp___21 = __builtin_strcmp((char const   *)cp, "aes");
        } else {
#line 209
          tmp___24 = __builtin_strcmp((char const   *)cp, "aes");
#line 209
          tmp___21 = tmp___24;
        }
      } else {
#line 209
        tmp___24 = __builtin_strcmp((char const   *)cp, "aes");
#line 209
        tmp___21 = tmp___24;
      }
#line 209
      tmp___15 = tmp___21;
    } else {
#line 209
      tmp___15 = strncmp((char const   *)cp, "aes", 3U);
    }
#line 209
    if (tmp___15 != 0) {
#line 210
      tmp___0 = buffer_len(& b);
#line 210
      if (tmp___0 > 0U) {
#line 211
        buffer_append(& b, (void const   *)",", 1U);
      }
#line 212
      tmp___1 = strlen((char const   *)cp);
#line 212
      buffer_append(& b, (void const   *)cp, tmp___1);
    }
  }
#line 215
  buffer_append(& b, (void const   *)"\000", 1U);
#line 216
  tmp___44 = buffer_ptr(& b);
#line 216
  fix_ciphers = xstrdup((char const   *)tmp___44);
#line 217
  buffer_free(& b);
#line 218
  xfree((void *)orig_prop);
#line 219
  debug2("Original cipher proposal: %s", cipher_prop);
#line 220
  debug2("Compat cipher proposal: %s", fix_ciphers);
#line 221
  if (! *fix_ciphers) {
#line 222
    fatal("No available ciphers found.");
  }
#line 224
  return (fix_ciphers);
}
}
#line 1 "compress.o"
#line 242 "/usr/include/zlib.h"
extern int deflate(z_streamp strm , int flush ) ;
#line 328
extern int deflateEnd(z_streamp strm ) ;
#line 363
extern int inflate(z_streamp strm , int flush ) ;
#line 462
extern int inflateEnd(z_streamp strm ) ;
#line 1317
extern int deflateInit_(z_streamp strm , int level , char const   *version , int stream_size ) ;
#line 1319
extern int inflateInit_(z_streamp strm , char const   *version , int stream_size ) ;
#line 19 "compress.h"
void buffer_compress_init_send(int level ) ;
#line 20
void buffer_compress_init_recv(void) ;
#line 21
void buffer_compress_uninit(void) ;
#line 22
void buffer_compress(Buffer *input_buffer , Buffer *output_buffer ) ;
#line 23
void buffer_uncompress(Buffer *input_buffer , Buffer *output_buffer ) ;
#line 22 "compress.c"
z_stream incoming_stream  ;
#line 23 "compress.c"
z_stream outgoing_stream  ;
#line 24 "compress.c"
static int compress_init_send_called  =    0;
#line 25 "compress.c"
static int compress_init_recv_called  =    0;
#line 26 "compress.c"
static int inflate_failed  =    0;
#line 27 "compress.c"
static int deflate_failed  =    0;
#line 34 "compress.c"
void buffer_compress_init_send(int level ) 
{ 

  {
#line 37
  if (compress_init_send_called == 1) {
#line 38
    deflateEnd(& outgoing_stream);
  }
#line 39
  compress_init_send_called = 1;
#line 40
  debug("Enabling compression at level %d.", level);
#line 41
  if (level < 1) {
#line 42
    fatal("Bad compression level %d.", level);
  } else {
#line 41
    if (level > 9) {
#line 42
      fatal("Bad compression level %d.", level);
    }
  }
#line 43
  deflateInit_(& outgoing_stream, level, "1.2.3", (int )sizeof(z_stream ));
#line 44
  return;
}
}
#line 45 "compress.c"
void buffer_compress_init_recv(void) 
{ 

  {
#line 48
  if (compress_init_recv_called == 1) {
#line 49
    inflateEnd(& incoming_stream);
  }
#line 50
  compress_init_recv_called = 1;
#line 51
  inflateInit_(& incoming_stream, "1.2.3", (int )sizeof(z_stream ));
#line 52
  return;
}
}
#line 56 "compress.c"
void buffer_compress_uninit(void) 
{ double tmp ;
  double tmp___0 ;

  {
#line 59
  if (outgoing_stream.total_in == 0UL) {
#line 59
    tmp = 0.0;
  } else {
#line 59
    tmp = (double )outgoing_stream.total_out / (double )outgoing_stream.total_in;
  }
#line 59
  debug("compress outgoing: raw data %llu, compressed %llu, factor %.2f", (unsigned long long )outgoing_stream.total_in,
        (unsigned long long )outgoing_stream.total_out, tmp);
#line 64
  if (incoming_stream.total_out == 0UL) {
#line 64
    tmp___0 = 0.0;
  } else {
#line 64
    tmp___0 = (double )incoming_stream.total_in / (double )incoming_stream.total_out;
  }
#line 64
  debug("compress incoming: raw data %llu, compressed %llu, factor %.2f", (unsigned long long )incoming_stream.total_out,
        (unsigned long long )incoming_stream.total_in, tmp___0);
#line 69
  if (compress_init_recv_called == 1) {
#line 69
    if (inflate_failed == 0) {
#line 70
      inflateEnd(& incoming_stream);
    }
  }
#line 71
  if (compress_init_send_called == 1) {
#line 71
    if (deflate_failed == 0) {
#line 72
      deflateEnd(& outgoing_stream);
    }
  }
#line 73
  return;
}
}
#line 84 "compress.c"
void buffer_compress(Buffer *input_buffer , Buffer *output_buffer ) 
{ u_char buf___1[4096] ;
  int status ;
  u_int tmp ;
  void *tmp___0 ;

  {
#line 91
  tmp = buffer_len(input_buffer);
#line 91
  if (tmp == 0U) {
#line 92
    return;
  }
#line 95
  tmp___0 = buffer_ptr(input_buffer);
#line 95
  outgoing_stream.next_in = (Bytef *)tmp___0;
#line 96
  outgoing_stream.avail_in = buffer_len(input_buffer);
#line 99
  while (1) {
#line 101
    outgoing_stream.next_out = buf___1;
#line 102
    outgoing_stream.avail_out = sizeof(buf___1);
#line 105
    status = deflate(& outgoing_stream, 1);
#line 106
    switch (status) {
    case 0: 
#line 109
    buffer_append(output_buffer, (void const   *)(buf___1), sizeof(buf___1) - outgoing_stream.avail_out);
#line 111
    break;
    default: 
#line 113
    deflate_failed = 1;
#line 114
    fatal("buffer_compress: deflate returned %d", status);
    }
#line 99
    if (! (outgoing_stream.avail_out == 0U)) {
#line 99
      break;
    }
  }
#line 118
  return;
}
}
#line 129 "compress.c"
void buffer_uncompress(Buffer *input_buffer , Buffer *output_buffer ) 
{ u_char buf___1[4096] ;
  int status ;
  void *tmp ;

  {
#line 135
  tmp = buffer_ptr(input_buffer);
#line 135
  incoming_stream.next_in = (Bytef *)tmp;
#line 136
  incoming_stream.avail_in = buffer_len(input_buffer);
#line 138
  while (1) {
#line 140
    incoming_stream.next_out = buf___1;
#line 141
    incoming_stream.avail_out = sizeof(buf___1);
#line 143
    status = inflate(& incoming_stream, 1);
#line 144
    switch (status) {
    case 0: 
#line 146
    buffer_append(output_buffer, (void const   *)(buf___1), sizeof(buf___1) - incoming_stream.avail_out);
#line 148
    break;
    case -5: 
#line 155
    return;
    default: 
#line 157
    inflate_failed = 1;
#line 158
    fatal("buffer_uncompress: inflate returned %d", status);
    }
  }
}
}
#line 1 "crc32.o"
#line 29 "crc32.h"
u_int32_t ssh_crc32(u_char const   *buf___1 , u_int32_t size ) ;
#line 29 "crc32.c"
static u_int32_t const   crc32tab[256]  = 
#line 29 "crc32.c"
  {      (u_int32_t const   )0L,      (u_int32_t const   )1996959894L,      (u_int32_t const   )3993919788UL,      (u_int32_t const   )2567524794UL, 
        (u_int32_t const   )124634137L,      (u_int32_t const   )1886057615L,      (u_int32_t const   )3915621685UL,      (u_int32_t const   )2657392035UL, 
        (u_int32_t const   )249268274L,      (u_int32_t const   )2044508324L,      (u_int32_t const   )3772115230UL,      (u_int32_t const   )2547177864UL, 
        (u_int32_t const   )162941995L,      (u_int32_t const   )2125561021L,      (u_int32_t const   )3887607047UL,      (u_int32_t const   )2428444049UL, 
        (u_int32_t const   )498536548L,      (u_int32_t const   )1789927666L,      (u_int32_t const   )4089016648UL,      (u_int32_t const   )2227061214UL, 
        (u_int32_t const   )450548861L,      (u_int32_t const   )1843258603L,      (u_int32_t const   )4107580753UL,      (u_int32_t const   )2211677639UL, 
        (u_int32_t const   )325883990L,      (u_int32_t const   )1684777152L,      (u_int32_t const   )4251122042UL,      (u_int32_t const   )2321926636UL, 
        (u_int32_t const   )335633487L,      (u_int32_t const   )1661365465L,      (u_int32_t const   )4195302755UL,      (u_int32_t const   )2366115317UL, 
        (u_int32_t const   )997073096L,      (u_int32_t const   )1281953886L,      (u_int32_t const   )3579855332UL,      (u_int32_t const   )2724688242UL, 
        (u_int32_t const   )1006888145L,      (u_int32_t const   )1258607687L,      (u_int32_t const   )3524101629UL,      (u_int32_t const   )2768942443UL, 
        (u_int32_t const   )901097722L,      (u_int32_t const   )1119000684L,      (u_int32_t const   )3686517206UL,      (u_int32_t const   )2898065728UL, 
        (u_int32_t const   )853044451L,      (u_int32_t const   )1172266101L,      (u_int32_t const   )3705015759UL,      (u_int32_t const   )2882616665UL, 
        (u_int32_t const   )651767980L,      (u_int32_t const   )1373503546L,      (u_int32_t const   )3369554304UL,      (u_int32_t const   )3218104598UL, 
        (u_int32_t const   )565507253L,      (u_int32_t const   )1454621731L,      (u_int32_t const   )3485111705UL,      (u_int32_t const   )3099436303UL, 
        (u_int32_t const   )671266974L,      (u_int32_t const   )1594198024L,      (u_int32_t const   )3322730930UL,      (u_int32_t const   )2970347812UL, 
        (u_int32_t const   )795835527L,      (u_int32_t const   )1483230225L,      (u_int32_t const   )3244367275UL,      (u_int32_t const   )3060149565UL, 
        (u_int32_t const   )1994146192L,      (u_int32_t const   )31158534L,      (u_int32_t const   )2563907772UL,      (u_int32_t const   )4023717930UL, 
        (u_int32_t const   )1907459465L,      (u_int32_t const   )112637215L,      (u_int32_t const   )2680153253UL,      (u_int32_t const   )3904427059UL, 
        (u_int32_t const   )2013776290L,      (u_int32_t const   )251722036L,      (u_int32_t const   )2517215374UL,      (u_int32_t const   )3775830040UL, 
        (u_int32_t const   )2137656763L,      (u_int32_t const   )141376813L,      (u_int32_t const   )2439277719UL,      (u_int32_t const   )3865271297UL, 
        (u_int32_t const   )1802195444L,      (u_int32_t const   )476864866L,      (u_int32_t const   )2238001368UL,      (u_int32_t const   )4066508878UL, 
        (u_int32_t const   )1812370925L,      (u_int32_t const   )453092731L,      (u_int32_t const   )2181625025UL,      (u_int32_t const   )4111451223UL, 
        (u_int32_t const   )1706088902L,      (u_int32_t const   )314042704L,      (u_int32_t const   )2344532202UL,      (u_int32_t const   )4240017532UL, 
        (u_int32_t const   )1658658271L,      (u_int32_t const   )366619977L,      (u_int32_t const   )2362670323UL,      (u_int32_t const   )4224994405UL, 
        (u_int32_t const   )1303535960L,      (u_int32_t const   )984961486L,      (u_int32_t const   )2747007092UL,      (u_int32_t const   )3569037538UL, 
        (u_int32_t const   )1256170817L,      (u_int32_t const   )1037604311L,      (u_int32_t const   )2765210733UL,      (u_int32_t const   )3554079995UL, 
        (u_int32_t const   )1131014506L,      (u_int32_t const   )879679996L,      (u_int32_t const   )2909243462UL,      (u_int32_t const   )3663771856UL, 
        (u_int32_t const   )1141124467L,      (u_int32_t const   )855842277L,      (u_int32_t const   )2852801631UL,      (u_int32_t const   )3708648649UL, 
        (u_int32_t const   )1342533948L,      (u_int32_t const   )654459306L,      (u_int32_t const   )3188396048UL,      (u_int32_t const   )3373015174UL, 
        (u_int32_t const   )1466479909L,      (u_int32_t const   )544179635L,      (u_int32_t const   )3110523913UL,      (u_int32_t const   )3462522015UL, 
        (u_int32_t const   )1591671054L,      (u_int32_t const   )702138776L,      (u_int32_t const   )2966460450UL,      (u_int32_t const   )3352799412UL, 
        (u_int32_t const   )1504918807L,      (u_int32_t const   )783551873L,      (u_int32_t const   )3082640443UL,      (u_int32_t const   )3233442989UL, 
        (u_int32_t const   )3988292384UL,      (u_int32_t const   )2596254646UL,      (u_int32_t const   )62317068L,      (u_int32_t const   )1957810842L, 
        (u_int32_t const   )3939845945UL,      (u_int32_t const   )2647816111UL,      (u_int32_t const   )81470997L,      (u_int32_t const   )1943803523L, 
        (u_int32_t const   )3814918930UL,      (u_int32_t const   )2489596804UL,      (u_int32_t const   )225274430L,      (u_int32_t const   )2053790376L, 
        (u_int32_t const   )3826175755UL,      (u_int32_t const   )2466906013UL,      (u_int32_t const   )167816743L,      (u_int32_t const   )2097651377L, 
        (u_int32_t const   )4027552580UL,      (u_int32_t const   )2265490386UL,      (u_int32_t const   )503444072L,      (u_int32_t const   )1762050814L, 
        (u_int32_t const   )4150417245UL,      (u_int32_t const   )2154129355UL,      (u_int32_t const   )426522225L,      (u_int32_t const   )1852507879L, 
        (u_int32_t const   )4275313526UL,      (u_int32_t const   )2312317920UL,      (u_int32_t const   )282753626L,      (u_int32_t const   )1742555852L, 
        (u_int32_t const   )4189708143UL,      (u_int32_t const   )2394877945UL,      (u_int32_t const   )397917763L,      (u_int32_t const   )1622183637L, 
        (u_int32_t const   )3604390888UL,      (u_int32_t const   )2714866558UL,      (u_int32_t const   )953729732L,      (u_int32_t const   )1340076626L, 
        (u_int32_t const   )3518719985UL,      (u_int32_t const   )2797360999UL,      (u_int32_t const   )1068828381L,      (u_int32_t const   )1219638859L, 
        (u_int32_t const   )3624741850UL,      (u_int32_t const   )2936675148UL,      (u_int32_t const   )906185462L,      (u_int32_t const   )1090812512L, 
        (u_int32_t const   )3747672003UL,      (u_int32_t const   )2825379669UL,      (u_int32_t const   )829329135L,      (u_int32_t const   )1181335161L, 
        (u_int32_t const   )3412177804UL,      (u_int32_t const   )3160834842UL,      (u_int32_t const   )628085408L,      (u_int32_t const   )1382605366L, 
        (u_int32_t const   )3423369109UL,      (u_int32_t const   )3138078467UL,      (u_int32_t const   )570562233L,      (u_int32_t const   )1426400815L, 
        (u_int32_t const   )3317316542UL,      (u_int32_t const   )2998733608UL,      (u_int32_t const   )733239954L,      (u_int32_t const   )1555261956L, 
        (u_int32_t const   )3268935591UL,      (u_int32_t const   )3050360625UL,      (u_int32_t const   )752459403L,      (u_int32_t const   )1541320221L, 
        (u_int32_t const   )2607071920UL,      (u_int32_t const   )3965973030UL,      (u_int32_t const   )1969922972L,      (u_int32_t const   )40735498L, 
        (u_int32_t const   )2617837225UL,      (u_int32_t const   )3943577151UL,      (u_int32_t const   )1913087877L,      (u_int32_t const   )83908371L, 
        (u_int32_t const   )2512341634UL,      (u_int32_t const   )3803740692UL,      (u_int32_t const   )2075208622L,      (u_int32_t const   )213261112L, 
        (u_int32_t const   )2463272603UL,      (u_int32_t const   )3855990285UL,      (u_int32_t const   )2094854071L,      (u_int32_t const   )198958881L, 
        (u_int32_t const   )2262029012UL,      (u_int32_t const   )4057260610UL,      (u_int32_t const   )1759359992L,      (u_int32_t const   )534414190L, 
        (u_int32_t const   )2176718541UL,      (u_int32_t const   )4139329115UL,      (u_int32_t const   )1873836001L,      (u_int32_t const   )414664567L, 
        (u_int32_t const   )2282248934UL,      (u_int32_t const   )4279200368UL,      (u_int32_t const   )1711684554L,      (u_int32_t const   )285281116L, 
        (u_int32_t const   )2405801727UL,      (u_int32_t const   )4167216745UL,      (u_int32_t const   )1634467795L,      (u_int32_t const   )376229701L, 
        (u_int32_t const   )2685067896UL,      (u_int32_t const   )3608007406UL,      (u_int32_t const   )1308918612L,      (u_int32_t const   )956543938L, 
        (u_int32_t const   )2808555105UL,      (u_int32_t const   )3495958263UL,      (u_int32_t const   )1231636301L,      (u_int32_t const   )1047427035L, 
        (u_int32_t const   )2932959818UL,      (u_int32_t const   )3654703836UL,      (u_int32_t const   )1088359270L,      (u_int32_t const   )936918000L, 
        (u_int32_t const   )2847714899UL,      (u_int32_t const   )3736837829UL,      (u_int32_t const   )1202900863L,      (u_int32_t const   )817233897L, 
        (u_int32_t const   )3183342108UL,      (u_int32_t const   )3401237130UL,      (u_int32_t const   )1404277552L,      (u_int32_t const   )615818150L, 
        (u_int32_t const   )3134207493UL,      (u_int32_t const   )3453421203UL,      (u_int32_t const   )1423857449L,      (u_int32_t const   )601450431L, 
        (u_int32_t const   )3009837614UL,      (u_int32_t const   )3294710456UL,      (u_int32_t const   )1567103746L,      (u_int32_t const   )711928724L, 
        (u_int32_t const   )3020668471UL,      (u_int32_t const   )3272380065UL,      (u_int32_t const   )1510334235L,      (u_int32_t const   )755167117L};
#line 96 "crc32.c"
u_int32_t ssh_crc32(u_char const   *buf___1 , u_int32_t size ) 
{ u_int32_t i ;
  u_int32_t crc ;

  {
#line 101
  crc = 0U;
#line 102
  i = 0U;
#line 102
  while (i < size) {
#line 103
    crc = (unsigned int )(crc32tab[(crc ^ (unsigned int )*(buf___1 + i)) & 255U] ^ (unsigned int const   )(crc >> 8));
#line 102
    i ++;
  }
#line 104
  return (crc);
}
}
#line 1 "deattack.o"
#line 29 "deattack.h"
int detect_attack(u_char *buf___1 , u_int32_t len , u_char *IV ) ;
#line 50 "deattack.c"
static void crc_update(u_int32_t *a , u_int32_t b ) 
{ 

  {
#line 53
  b ^= *a;
#line 54
  *a = ssh_crc32((u_char const   *)((u_char *)(& b)), sizeof(b));
#line 55
  return;
}
}
#line 58 "deattack.c"
static int check_crc(u_char *S , u_char *buf___1 , u_int32_t len , u_char *IV ) 
{ u_int32_t crc ;
  u_char *c ;
  int tmp ;
  int tmp___0 ;

  {
#line 65
  crc = 0U;
#line 66
  if (IV) {
#line 66
    tmp = memcmp((void const   *)S, (void const   *)IV, 8U);
#line 66
    if (! tmp) {
#line 67
      crc_update(& crc, 1U);
#line 68
      crc_update(& crc, 0U);
    }
  }
#line 70
  c = buf___1;
#line 70
  while ((unsigned int )c < (unsigned int )(buf___1 + len)) {
#line 71
    tmp___0 = memcmp((void const   *)S, (void const   *)c, 8U);
#line 71
    if (tmp___0) {
#line 75
      crc_update(& crc, 0U);
#line 76
      crc_update(& crc, 0U);
    } else {
#line 72
      crc_update(& crc, 1U);
#line 73
      crc_update(& crc, 0U);
    }
#line 70
    c += 8;
  }
#line 79
  return (crc == 0U);
}
}
#line 87 "deattack.c"
static u_int16_t *h  =    (u_int16_t *)((void *)0);
#line 88 "deattack.c"
static u_int32_t n  =    (u_int32_t )4096;
#line 84 "deattack.c"
int detect_attack(u_char *buf___1 , u_int32_t len , u_char *IV ) 
{ u_int32_t i ;
  u_int32_t j ;
  u_int32_t l ;
  u_char *c ;
  u_char *d ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 94
  if (len > 262144U) {
#line 96
    fatal("detect_attack: bad length %d", len);
  } else {
#line 94
    if (len % 8U != 0U) {
#line 96
      fatal("detect_attack: bad length %d", len);
    }
  }
#line 98
  l = n;
#line 98
  while (l < ((len / 8U) * 3U) / 2U) {
#line 98
    l <<= 2;
  }
#line 101
  if ((unsigned int )h == (unsigned int )((void *)0)) {
#line 102
    debug("Installing crc compensation attack detector.");
#line 103
    tmp = xmalloc(l * 2U);
#line 103
    h = (u_int16_t *)tmp;
#line 104
    n = l;
  } else {
#line 106
    if (l > n) {
#line 107
      tmp___0 = xrealloc((void *)h, l * 2U);
#line 107
      h = (u_int16_t *)tmp___0;
#line 108
      n = l;
    }
  }
#line 112
  if (len <= 56U) {
#line 113
    c = buf___1;
#line 113
    while ((unsigned int )c < (unsigned int )(buf___1 + len)) {
#line 114
      if (IV) {
#line 114
        tmp___2 = memcmp((void const   *)c, (void const   *)IV, 8U);
#line 114
        if (! tmp___2) {
#line 115
          tmp___1 = check_crc(c, buf___1, len, (u_char *)IV);
#line 115
          if (tmp___1) {
#line 116
            return (1);
          } else {
#line 118
            break;
          }
        }
      }
#line 120
      d = buf___1;
#line 120
      while ((unsigned int )d < (unsigned int )c) {
#line 121
        tmp___4 = memcmp((void const   *)c, (void const   *)d, 8U);
#line 121
        if (! tmp___4) {
#line 122
          tmp___3 = check_crc(c, buf___1, len, (u_char *)IV);
#line 122
          if (tmp___3) {
#line 123
            return (1);
          } else {
#line 125
            break;
          }
        }
#line 120
        d += 8;
      }
#line 113
      c += 8;
    }
#line 129
    return (0);
  }
#line 131
  memset((void *)h, 255, n * 2U);
#line 133
  if (IV) {
#line 134
    *(h + ((((((unsigned long )*(IV + 0) << 24) | ((unsigned long )*(IV + 1) << 16)) | ((unsigned long )*(IV + 2) << 8)) | (unsigned long )*(IV + 3)) & (unsigned long )(n - 1U))) = (unsigned short)65534;
  }
#line 136
  c = buf___1;
#line 136
  j = 0U;
#line 136
  while ((unsigned int )c < (unsigned int )(buf___1 + len)) {
#line 137
    i = (unsigned int )((((((unsigned long )*(c + 0) << 24) | ((unsigned long )*(c + 1) << 16)) | ((unsigned long )*(c + 2) << 8)) | (unsigned long )*(c + 3)) & (unsigned long )(n - 1U));
#line 137
    while ((int )*(h + i) != 65535) {
#line 139
      if ((int )*(h + i) == 65534) {
#line 140
        tmp___6 = memcmp((void const   *)c, (void const   *)IV, 8U);
#line 140
        if (! tmp___6) {
#line 141
          tmp___5 = check_crc(c, buf___1, len, (u_char *)IV);
#line 141
          if (tmp___5) {
#line 142
            return (1);
          } else {
#line 144
            break;
          }
        }
      } else {
#line 146
        tmp___8 = memcmp((void const   *)c, (void const   *)(buf___1 + (int )*(h + i) * 8),
                         8U);
#line 146
        if (! tmp___8) {
#line 147
          tmp___7 = check_crc(c, buf___1, len, (u_char *)IV);
#line 147
          if (tmp___7) {
#line 148
            return (1);
          } else {
#line 150
            break;
          }
        }
      }
#line 137
      i = (i + 1U) & (n - 1U);
    }
#line 153
    *(h + i) = (unsigned short )j;
#line 136
    c += 8;
#line 136
    j ++;
  }
#line 155
  return (0);
}
}
#line 1 "fatal.o"
#line 64 "log.h"
void do_log(LogLevel level , char const   *fmt , va_list args ) ;
#line 32 "fatal.c"
void ( /* format attribute */  fatal)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 36
  __builtin_va_start(args, fmt);
#line 37
  do_log(1, fmt, args);
#line 38
  __builtin_va_end(args);
#line 39
  cleanup_exit(255);
#line 40
  return;
}
}
#line 1 "hostfile.o"
#line 19 "match.h"
int match_hostname(char const   *host , char const   *pattern , u_int len ) ;
#line 62 "key.h"
int key_equal(Key const   *a , Key const   *b ) ;
#line 66
int key_write(Key const   *key , FILE *f ) ;
#line 68
u_int key_size(Key const   *k ) ;
#line 21 "hostfile.h"
int hostfile_read_key(char **cpp , u_int *bitsp , Key *ret ) ;
#line 22
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , Key const   *key ,
                                  Key *found , int *numret ) ;
#line 24
int add_host_to_hostfile(char const   *filename , char const   *host , Key const   *key ) ;
#line 25
int lookup_key_in_hostfile_by_type(char const   *filename , char const   *host , int keytype ,
                                   Key *found , int *numret ) ;
#line 52 "hostfile.c"
int hostfile_read_key(char **cpp , u_int *bitsp , Key *ret ) 
{ char *cp ;
  int tmp ;

  {
#line 58
  cp = *cpp;
#line 58
  while (1) {
#line 58
    if (! ((int )*cp == 32)) {
#line 58
      if (! ((int )*cp == 9)) {
#line 58
        break;
      }
    }
#line 58
    cp ++;
  }
#line 61
  tmp = key_read(ret, & cp);
#line 61
  if (tmp != 1) {
#line 62
    return (0);
  }
#line 65
  while (1) {
#line 65
    if (! ((int )*cp == 32)) {
#line 65
      if (! ((int )*cp == 9)) {
#line 65
        break;
      }
    }
#line 65
    cp ++;
  }
#line 69
  *cpp = cp;
#line 70
  *bitsp = key_size((Key const   *)ret);
#line 71
  return (1);
}
}
#line 74 "hostfile.c"
static int hostfile_check_key(int bits , Key const   *key , char const   *host , char const   *filename ,
                              int linenum ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 77
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 78
    return (1);
  } else {
#line 77
    if (key->type != 0) {
#line 78
      return (1);
    } else {
#line 77
      if ((unsigned int )key->rsa == (unsigned int )((void *)0)) {
#line 78
        return (1);
      }
    }
  }
#line 79
  tmp___1 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 79
  if (bits != tmp___1) {
#line 80
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 80
    logit("Warning: %s, line %d: keysize mismatch for host %s: actual %d vs. announced %d.",
          filename, linenum, host, tmp, bits);
#line 83
    tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 83
    logit("Warning: replace %d with %d in %s, line %d.", bits, tmp___0, filename,
          linenum);
  }
#line 86
  return (1);
}
}
#line 99 "hostfile.c"
static HostStatus check_host_in_hostfile_by_key_or_type(char const   *filename , char const   *host ,
                                                        Key const   *key , int keytype ,
                                                        Key *found , int *numret ) 
{ FILE *f ;
  char line[8192] ;
  int linenum ;
  u_int kbits ;
  char *cp ;
  char *cp2 ;
  HostStatus end_return ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 105
  linenum = 0;
#line 110
  debug3("check_host_in_hostfile: filename %s", filename);
#line 113
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 114
  if (! f) {
#line 115
    return (1);
  }
#line 122
  end_return = 1;
#line 125
  while (1) {
#line 125
    tmp___3 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 125
    if (! tmp___3) {
#line 125
      break;
    }
#line 126
    cp = line;
#line 127
    linenum ++;
#line 130
    while (1) {
#line 130
      if (! ((int )*cp == 32)) {
#line 130
        if (! ((int )*cp == 9)) {
#line 130
          break;
        }
      }
#line 130
      cp ++;
    }
#line 132
    if (! *cp) {
#line 133
      continue;
    } else {
#line 132
      if ((int )*cp == 35) {
#line 133
        continue;
      } else {
#line 132
        if ((int )*cp == 10) {
#line 133
          continue;
        }
      }
    }
#line 136
    cp2 = cp;
#line 136
    while (1) {
#line 136
      if (*cp2) {
#line 136
        if ((int )*cp2 != 32) {
#line 136
          if (! ((int )*cp2 != 9)) {
#line 136
            break;
          }
        } else {
#line 136
          break;
        }
      } else {
#line 136
        break;
      }
#line 136
      cp2 ++;
    }
#line 140
    tmp = match_hostname(host, (char const   *)cp, (unsigned int )(cp2 - cp));
#line 140
    if (tmp != 1) {
#line 141
      continue;
    }
#line 144
    cp = cp2;
#line 150
    tmp___0 = hostfile_read_key(& cp, & kbits, found);
#line 150
    if (! tmp___0) {
#line 151
      continue;
    }
#line 153
    if ((unsigned int )numret != (unsigned int )((void *)0)) {
#line 154
      *numret = linenum;
    }
#line 156
    if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 158
      if (found->type == keytype) {
#line 159
        return (3);
      }
#line 160
      continue;
    }
#line 163
    tmp___1 = hostfile_check_key((int )kbits, (Key const   *)found, host, filename,
                                 linenum);
#line 163
    if (! tmp___1) {
#line 164
      continue;
    }
#line 167
    tmp___2 = key_equal(key, (Key const   *)found);
#line 167
    if (tmp___2) {
#line 169
      debug3("check_host_in_hostfile: match line %d", linenum);
#line 170
      fclose(f);
#line 171
      return (0);
    }
#line 178
    end_return = 2;
  }
#line 181
  fclose(f);
#line 187
  return (end_return);
}
}
#line 190 "hostfile.c"
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , Key const   *key ,
                                  Key *found , int *numret ) 
{ HostStatus tmp ;

  {
#line 194
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 195
    fatal("no key to look up");
  }
#line 196
  tmp = check_host_in_hostfile_by_key_or_type(filename, host, key, 0, found, numret);
#line 196
  return (tmp);
}
}
#line 200 "hostfile.c"
int lookup_key_in_hostfile_by_type(char const   *filename , char const   *host , int keytype ,
                                   Key *found , int *numret ) 
{ HostStatus tmp ;

  {
#line 204
  tmp = check_host_in_hostfile_by_key_or_type(filename, host, (Key const   *)((void *)0),
                                              keytype, found, numret);
#line 204
  return ((int )tmp == 3);
}
}
#line 213 "hostfile.c"
int add_host_to_hostfile(char const   *filename , char const   *host , Key const   *key ) 
{ FILE *f ;
  int success ;
  int tmp ;

  {
#line 217
  success = 0;
#line 218
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 219
    return (1);
  }
#line 220
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"a");
#line 221
  if (! f) {
#line 222
    return (0);
  }
#line 223
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s ", host);
#line 224
  tmp = key_write(key, f);
#line 224
  if (tmp) {
#line 225
    success = 1;
  } else {
#line 227
    error("add_host_to_hostfile: saving key in %s failed", filename);
  }
#line 229
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"\n");
#line 230
  fclose(f);
#line 231
  return (success);
}
}
#line 1 "log.o"
#line 646 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 175 "/usr/include/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 51 "log.h"
void log_init(char *av0 , LogLevel level , SyslogFacility facility , int on_stderr ) ;
#line 53
SyslogFacility log_facility_number(char *name ) ;
#line 54
LogLevel log_level_number(char *name ) ;
#line 47 "log.c"
static LogLevel log_level  =    3;
#line 48 "log.c"
static int log_on_stderr  =    1;
#line 49 "log.c"
static int log_facility  =    4 << 3;
#line 50 "log.c"
static char *argv0  ;
#line 56 "log.c"
static struct __anonstruct_log_facilities_72 log_facilities[13]  = 
#line 56
  {      {"DAEMON", 0}, 
        {"USER", 1}, 
        {"AUTH", 2}, 
        {"AUTHPRIV", 3}, 
        {"LOCAL0", 4}, 
        {"LOCAL1", 5}, 
        {"LOCAL2", 6}, 
        {"LOCAL3", 7}, 
        {"LOCAL4", 8}, 
        {"LOCAL5", 9}, 
        {"LOCAL6", 10}, 
        {"LOCAL7", 11}, 
        {(char const   *)((void *)0), -1}};
#line 77 "log.c"
static struct __anonstruct_log_levels_73 log_levels[10]  = 
#line 77
  {      {"QUIET", 0}, 
        {"FATAL", 1}, 
        {"ERROR", 2}, 
        {"INFO", 3}, 
        {"VERBOSE", 4}, 
        {"DEBUG", 5}, 
        {"DEBUG1", 5}, 
        {"DEBUG2", 6}, 
        {"DEBUG3", 7}, 
        {(char const   *)((void *)0), -1}};
#line 94 "log.c"
SyslogFacility log_facility_number(char *name ) 
{ int i ;
  int tmp ;

  {
#line 99
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 100
    i = 0;
#line 100
    while (log_facilities[i].name) {
#line 101
      tmp = strcasecmp(log_facilities[i].name, (char const   *)name);
#line 101
      if (tmp == 0) {
#line 102
        return (log_facilities[i].val);
      }
#line 100
      i ++;
    }
  }
#line 103
  return (-1);
}
}
#line 106 "log.c"
LogLevel log_level_number(char *name ) 
{ int i ;
  int tmp ;

  {
#line 111
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 112
    i = 0;
#line 112
    while (log_levels[i].name) {
#line 113
      tmp = strcasecmp(log_levels[i].name, (char const   *)name);
#line 113
      if (tmp == 0) {
#line 114
        return (log_levels[i].val);
      }
#line 112
      i ++;
    }
  }
#line 115
  return (-1);
}
}
#line 120 "log.c"
void ( /* format attribute */  error)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 125
  __builtin_va_start(args, fmt);
#line 126
  do_log(2, fmt, args);
#line 127
  __builtin_va_end(args);
#line 128
  return;
}
}
#line 132 "log.c"
void ( /* format attribute */  logit)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 137
  __builtin_va_start(args, fmt);
#line 138
  do_log(3, fmt, args);
#line 139
  __builtin_va_end(args);
#line 140
  return;
}
}
#line 144 "log.c"
void ( /* format attribute */  verbose)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 149
  __builtin_va_start(args, fmt);
#line 150
  do_log(4, fmt, args);
#line 151
  __builtin_va_end(args);
#line 152
  return;
}
}
#line 156 "log.c"
void ( /* format attribute */  debug)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 161
  __builtin_va_start(args, fmt);
#line 162
  do_log(5, fmt, args);
#line 163
  __builtin_va_end(args);
#line 164
  return;
}
}
#line 166 "log.c"
void ( /* format attribute */  debug2)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 171
  __builtin_va_start(args, fmt);
#line 172
  do_log(6, fmt, args);
#line 173
  __builtin_va_end(args);
#line 174
  return;
}
}
#line 176 "log.c"
void ( /* format attribute */  debug3)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 181
  __builtin_va_start(args, fmt);
#line 182
  do_log(7, fmt, args);
#line 183
  __builtin_va_end(args);
#line 184
  return;
}
}
#line 190 "log.c"
void log_init(char *av0 , LogLevel level , SyslogFacility facility , int on_stderr ) 
{ 

  {
#line 193
  argv0 = av0;
#line 195
  switch ((int )level) {
  case 0: 
  case 1: 
  case 2: 
  case 3: 
  case 4: 
  case 5: 
  case 6: 
  case 7: 
#line 204
  log_level = level;
#line 205
  break;
  default: 
#line 207
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized internal syslog level code %d\n",
          (int )level);
#line 209
  exit(1);
  }
#line 212
  log_on_stderr = on_stderr;
#line 213
  if (on_stderr) {
#line 214
    return;
  }
#line 216
  switch ((int )facility) {
  case 0: 
#line 218
  log_facility = 3 << 3;
#line 219
  break;
  case 1: 
#line 221
  log_facility = 1 << 3;
#line 222
  break;
  case 2: 
#line 224
  log_facility = 4 << 3;
#line 225
  break;
  case 3: 
#line 228
  log_facility = 10 << 3;
#line 229
  break;
  case 4: 
#line 232
  log_facility = 16 << 3;
#line 233
  break;
  case 5: 
#line 235
  log_facility = 17 << 3;
#line 236
  break;
  case 6: 
#line 238
  log_facility = 18 << 3;
#line 239
  break;
  case 7: 
#line 241
  log_facility = 19 << 3;
#line 242
  break;
  case 8: 
#line 244
  log_facility = 20 << 3;
#line 245
  break;
  case 9: 
#line 247
  log_facility = 21 << 3;
#line 248
  break;
  case 10: 
#line 250
  log_facility = 22 << 3;
#line 251
  break;
  case 11: 
#line 253
  log_facility = 23 << 3;
#line 254
  break;
  default: 
#line 256
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized internal syslog facility code %d\n",
          (int )facility);
#line 259
  exit(1);
  }
#line 261
  return;
}
}
#line 265 "log.c"
void do_log(LogLevel level , char const   *fmt , va_list args ) 
{ char msgbuf[1024] ;
  char fmtbuf[1024] ;
  char *txt ;
  int pri ;
  size_t tmp ;
  char *tmp___0 ;

  {
#line 273
  txt = (char *)((void *)0);
#line 274
  pri = 6;
#line 276
  if ((int )level > (int )log_level) {
#line 277
    return;
  }
#line 279
  switch ((int )level) {
  case 1: 
#line 281
  if (! log_on_stderr) {
#line 282
    txt = (char *)"fatal";
  }
#line 283
  pri = 2;
#line 284
  break;
  case 2: 
#line 286
  if (! log_on_stderr) {
#line 287
    txt = (char *)"error";
  }
#line 288
  pri = 3;
#line 289
  break;
  case 3: 
#line 291
  pri = 6;
#line 292
  break;
  case 4: 
#line 294
  pri = 6;
#line 295
  break;
  case 5: 
#line 297
  txt = (char *)"debug1";
#line 298
  pri = 7;
#line 299
  break;
  case 6: 
#line 301
  txt = (char *)"debug2";
#line 302
  pri = 7;
#line 303
  break;
  case 7: 
#line 305
  txt = (char *)"debug3";
#line 306
  pri = 7;
#line 307
  break;
  default: 
#line 309
  txt = (char *)"internal error";
#line 310
  pri = 3;
#line 311
  break;
  }
#line 313
  if ((unsigned int )txt != (unsigned int )((void *)0)) {
#line 314
    snprintf((char * __restrict  )(fmtbuf), sizeof(fmtbuf), (char const   * __restrict  )"%s: %s",
             txt, fmt);
#line 315
    vsnprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )(fmtbuf),
              args);
  } else {
#line 317
    vsnprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )fmt,
              args);
  }
#line 319
  strnvis(fmtbuf, (char const   *)(msgbuf), sizeof(fmtbuf), 33);
#line 320
  if (log_on_stderr) {
#line 321
    snprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )"%s\r\n",
             fmtbuf);
#line 322
    tmp = strlen((char const   *)(msgbuf));
#line 322
    write(2, (void const   *)(msgbuf), tmp);
  } else {
#line 329
    if (argv0) {
#line 329
      tmp___0 = argv0;
    } else {
#line 329
      tmp___0 = __progname;
    }
#line 329
    openlog((char const   *)tmp___0, 1, log_facility);
#line 330
    syslog(pri, "%.500s", fmtbuf);
#line 331
    closelog();
  }
#line 334
  return;
}
}
#line 1 "match.o"
#line 116 "/usr/include/ctype.h"
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 17 "match.h"
int match_pattern(char const   *s , char const   *pattern ) ;
#line 20
int match_host_and_ip(char const   *host , char const   *ipaddr , char const   *patterns ) ;
#line 21
int match_user(char const   *user , char const   *host , char const   *ipaddr , char const   *pattern ) ;
#line 22
char *match_list(char const   *client , char const   *server , u_int *next ) ;
#line 48 "match.c"
int match_pattern(char const   *s , char const   *pattern ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 51
  while (1) {
#line 53
    if (! *pattern) {
#line 54
      return (! *s);
    }
#line 56
    if ((int const   )*pattern == 42) {
#line 58
      pattern ++;
#line 61
      if (! *pattern) {
#line 62
        return (1);
      }
#line 65
      if ((int const   )*pattern != 63) {
#line 65
        if ((int const   )*pattern != 42) {
#line 71
          while (*s) {
#line 72
            if ((int const   )*s == (int const   )*pattern) {
#line 72
              tmp = match_pattern(s + 1, pattern + 1);
#line 72
              if (tmp) {
#line 74
                return (1);
              }
            }
#line 71
            s ++;
          }
#line 76
          return (0);
        }
      }
#line 82
      while (*s) {
#line 83
        tmp___0 = match_pattern(s, pattern);
#line 83
        if (tmp___0) {
#line 84
          return (1);
        }
#line 82
        s ++;
      }
#line 86
      return (0);
    }
#line 92
    if (! *s) {
#line 93
      return (0);
    }
#line 96
    if ((int const   )*pattern != 63) {
#line 96
      if ((int const   )*pattern != (int const   )*s) {
#line 97
        return (0);
      }
    }
#line 100
    s ++;
#line 101
    pattern ++;
  }
}
}
#line 113 "match.c"
int match_pattern_list(char const   *string , char const   *pattern , u_int len ,
                       int dolower ) 
{ char sub[1024] ;
  int negated ;
  int got_positive ;
  u_int i ;
  u_int subi ;
  int __res___0 ;
  __int32_t const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;

  {
#line 122
  got_positive = 0;
#line 123
  i = 0U;
#line 123
  while (i < len) {
#line 125
    if ((int const   )*(pattern + i) == 33) {
#line 126
      negated = 1;
#line 127
      i ++;
    } else {
#line 129
      negated = 0;
    }
#line 135
    subi = 0U;
#line 135
    while (1) {
#line 135
      if (i < len) {
#line 135
        if (subi < sizeof(sub) - 1U) {
#line 135
          if (! ((int const   )*(pattern + i) != 44)) {
#line 135
            break;
          }
        } else {
#line 135
          break;
        }
      } else {
#line 135
        break;
      }
#line 139
      if (dolower) {
#line 139
        tmp___6 = __ctype_b_loc();
#line 139
        if ((int const   )*(*tmp___6 + (int )*(pattern + i)) & 256) {
#line 139
          if (sizeof(*(pattern + i)) > 1U) {
#line 139
            __res___0 = tolower((int )*(pattern + i));
          } else {
#line 139
            tmp___5 = __ctype_tolower_loc();
#line 139
            __res___0 = (int )*(*tmp___5 + (int )*(pattern + i));
          }
#line 139
          sub[subi] = (char )__res___0;
        } else {
#line 139
          sub[subi] = (char )*(pattern + i);
        }
      } else {
#line 139
        sub[subi] = (char )*(pattern + i);
      }
#line 135
      subi ++;
#line 135
      i ++;
    }
#line 141
    if (subi >= sizeof(sub) - 1U) {
#line 142
      return (0);
    }
#line 145
    if (i < len) {
#line 145
      if ((int const   )*(pattern + i) == 44) {
#line 146
        i ++;
      }
    }
#line 149
    sub[subi] = (char )'\000';
#line 152
    tmp___7 = match_pattern(string, (char const   *)(sub));
#line 152
    if (tmp___7) {
#line 153
      if (negated) {
#line 154
        return (-1);
      } else {
#line 156
        got_positive = 1;
      }
    }
  }
#line 164
  return (got_positive);
}
}
#line 173 "match.c"
int match_hostname(char const   *host , char const   *pattern , u_int len ) 
{ int tmp ;

  {
#line 176
  tmp = match_pattern_list(host, pattern, len, 1);
#line 176
  return (tmp);
}
}
#line 183 "match.c"
int match_host_and_ip(char const   *host , char const   *ipaddr , char const   *patterns ) 
{ int mhost ;
  int mip ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 190
  tmp = strlen(patterns);
#line 190
  mip = match_hostname(ipaddr, patterns, tmp);
#line 190
  if (mip == -1) {
#line 191
    return (0);
  }
#line 193
  tmp___0 = strlen(patterns);
#line 193
  mhost = match_hostname(host, patterns, tmp___0);
#line 193
  if (mhost == -1) {
#line 194
    return (0);
  }
#line 196
  if (mhost == 0) {
#line 196
    if (mip == 0) {
#line 197
      return (0);
    }
  }
#line 198
  return (1);
}
}
#line 204 "match.c"
int match_user(char const   *user , char const   *host , char const   *ipaddr , char const   *pattern ) 
{ char *p ;
  char *pat ;
  int ret ;
  int tmp ;
  char *tmp___1 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 211
  tmp___1 = __builtin_strchr((char *)pattern, '@');
#line 211
  p = tmp___1;
#line 211
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 212
    tmp = match_pattern(user, pattern);
#line 212
    return (tmp);
  }
#line 214
  pat = xstrdup(pattern);
#line 215
  tmp___3 = __builtin_strchr(pat, '@');
#line 215
  p = tmp___3;
#line 216
  tmp___4 = p;
#line 216
  p ++;
#line 216
  *tmp___4 = (char )'\000';
#line 218
  ret = match_pattern(user, (char const   *)pat);
#line 218
  if (ret == 1) {
#line 219
    ret = match_host_and_ip(host, ipaddr, (char const   *)p);
  }
#line 220
  xfree((void *)pat);
#line 222
  return (ret);
}
}
#line 231 "match.c"
char *match_list(char const   *client , char const   *server , u_int *next ) 
{ char *sproposals[40] ;
  char *c ;
  char *s ;
  char *p ;
  char *ret ;
  char *cp ;
  char *sp ;
  int i ;
  int j ;
  int nproposals ;
  char *tmp___14 ;
  char *tmp___30 ;
  char *tmp___46 ;
  char *tmp___62 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___69 ;
  int tmp___72 ;
  int tmp___73 ;

  {
#line 238
  cp = xstrdup(client);
#line 238
  c = cp;
#line 239
  sp = xstrdup(server);
#line 239
  s = sp;
#line 241
  tmp___14 = __strsep_g(& sp, ",");
#line 241
  p = tmp___14;
#line 241
  i = 0;
#line 241
  while (1) {
#line 241
    if (p) {
#line 241
      if (! ((int )*p != 0)) {
#line 241
        break;
      }
    } else {
#line 241
      break;
    }
#line 243
    if (i < 40) {
#line 244
      sproposals[i] = p;
    } else {
#line 246
      break;
    }
#line 242
    tmp___30 = __strsep_g(& sp, ",");
#line 242
    p = tmp___30;
#line 242
    i ++;
  }
#line 248
  nproposals = i;
#line 250
  tmp___46 = __strsep_g(& cp, ",");
#line 250
  p = tmp___46;
#line 250
  i = 0;
#line 250
  while (1) {
#line 250
    if (p) {
#line 250
      if (! ((int )*p != 0)) {
#line 250
        break;
      }
    } else {
#line 250
      break;
    }
#line 252
    j = 0;
#line 252
    while (j < nproposals) {
#line 253
      if (0) {
#line 253
        __s1_len = strlen((char const   *)p);
#line 253
        __s2_len = strlen((char const   *)sproposals[j]);
#line 253
        if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
          goto _L___0;
        } else {
#line 253
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 253
            if (! ((unsigned int )((void const   *)(sproposals[j] + 1)) - (unsigned int )((void const   *)sproposals[j]) == 1U)) {
#line 253
              tmp___73 = 1;
            } else {
#line 253
              if (__s2_len >= 4U) {
#line 253
                tmp___73 = 1;
              } else {
#line 253
                tmp___73 = 0;
              }
            }
          } else {
#line 253
            tmp___73 = 0;
          }
        }
#line 253
        if (tmp___73) {
#line 253
          tmp___69 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
        } else {
#line 253
          tmp___72 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
#line 253
          tmp___69 = tmp___72;
        }
      } else {
#line 253
        tmp___72 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
#line 253
        tmp___69 = tmp___72;
      }
#line 253
      if (tmp___69 == 0) {
#line 254
        ret = xstrdup((char const   *)p);
#line 255
        if ((unsigned int )next != (unsigned int )((void *)0)) {
#line 256
          if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 256
            *next = strlen((char const   *)c);
          } else {
#line 256
            *next = (unsigned int )(cp - c);
          }
        }
#line 258
        xfree((void *)c);
#line 259
        xfree((void *)s);
#line 260
        return (ret);
      }
#line 252
      j ++;
    }
#line 251
    tmp___62 = __strsep_g(& cp, ",");
#line 251
    p = tmp___62;
#line 251
    i ++;
  }
#line 264
  if ((unsigned int )next != (unsigned int )((void *)0)) {
#line 265
    *next = strlen((char const   *)c);
  }
#line 266
  xfree((void *)c);
#line 267
  xfree((void *)s);
#line 268
  return ((char *)((void *)0));
}
}
/* compiler builtin: 
   unsigned int __builtin_strspn(char const   * , char const   * ) ;  */
#line 1 "moduli.o"
#line 218 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 188 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) unsigned long strtoul(char const   * __restrict  __nptr ,
                                                                    char ** __restrict  __endptr ,
                                                                    int __base )  __attribute__((__nonnull__(1))) ;
#line 297
extern  __attribute__((__nothrow__)) unsigned long __strtoul_internal(char const   * __restrict  __nptr ,
                                                                      char ** __restrict  __endptr ,
                                                                      int __base ,
                                                                      int __group )  __attribute__((__nonnull__(1))) ;
#line 338
__inline static  __attribute__((__nothrow__)) unsigned long strtoul(char const   * __restrict  __nptr ,
                                                                    char ** __restrict  __endptr ,
                                                                    int __base )  __attribute__((__nonnull__(1))) ;
#line 338 "/usr/include/stdlib.h"
__inline static unsigned long strtoul(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                      int __base ) 
{ unsigned long tmp ;

  {
#line 342
  tmp = __strtoul_internal(__nptr, __endptr, __base, 0);
#line 342
  return (tmp);
}
}
#line 187 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 232
extern  __attribute__((__nothrow__)) struct tm *gmtime(time_t const   *__timer ) ;
#line 257
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 393 "/usr/include/openssl/bn.h"
extern BN_CTX *BN_CTX_new(void) ;
#line 397
extern void BN_CTX_free(BN_CTX *c ) ;
#line 401
extern int BN_rand(BIGNUM *rnd , int bits , int top , int bottom ) ;
#line 407
extern BIGNUM *BN_new(void) ;
#line 410
extern BIGNUM *BN_copy(BIGNUM *a , BIGNUM const   *b ) ;
#line 419
extern int BN_add(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *b ) ;
#line 449
extern unsigned long BN_mod_word(BIGNUM const   *a , unsigned long w ) ;
#line 452
extern int BN_add_word(BIGNUM *a , unsigned long w ) ;
#line 454
extern int BN_set_word(BIGNUM *a , unsigned long w ) ;
#line 458
extern void BN_free(BIGNUM *a ) ;
#line 460
extern int BN_lshift(BIGNUM *r , BIGNUM const   *a , int n ) ;
#line 480
extern int BN_print_fp(FILE *fp , BIGNUM const   *a ) ;
#line 488
extern int BN_rshift(BIGNUM *r , BIGNUM const   *a , int n ) ;
#line 493
extern int BN_set_bit(BIGNUM *a , int n ) ;
#line 495
extern char *BN_bn2hex(BIGNUM const   *a ) ;
#line 497
extern int BN_hex2bn(BIGNUM **a , char const   *str ) ;
#line 511
extern int BN_is_prime(BIGNUM const   *p , int nchecks , void (*callback)(int  , int  ,
                                                                          void * ) ,
                       BN_CTX *ctx , void *cb_arg ) ;
#line 22 "moduli.h"
int gen_candidates(FILE *out , int memory , int power , BIGNUM *start___0 ) ;
#line 23
int prime_test(FILE *in , FILE *out , u_int32_t trials , u_int32_t generator_wanted ) ;
#line 122 "moduli.c"
static u_int32_t *TinySieve  ;
#line 122 "moduli.c"
static u_int32_t tinybits  ;
#line 125 "moduli.c"
static u_int32_t *SmallSieve  ;
#line 125 "moduli.c"
static u_int32_t smallbits  ;
#line 125 "moduli.c"
static u_int32_t smallbase  ;
#line 128 "moduli.c"
static u_int32_t *LargeSieve  ;
#line 128 "moduli.c"
static u_int32_t largewords  ;
#line 128 "moduli.c"
static u_int32_t largetries  ;
#line 128 "moduli.c"
static u_int32_t largenumbers  ;
#line 129 "moduli.c"
static u_int32_t largebits  ;
#line 129 "moduli.c"
static u_int32_t largememory  ;
#line 130 "moduli.c"
static BIGNUM *largebase  ;
#line 136 "moduli.c"
static int qfileout(FILE *ofile , u_int32_t otype , u_int32_t otests , u_int32_t otries ,
                    u_int32_t osize , u_int32_t ogenerator , BIGNUM *omodulus ) 
{ struct tm *gtm ;
  time_t time_now ;
  int res ;
  int tmp ;
  int tmp___0 ;

  {
#line 144
  time(& time_now);
#line 145
  gtm = gmtime((time_t const   *)(& time_now));
#line 147
  res = fprintf((FILE * __restrict  )ofile, (char const   * __restrict  )"%04d%02d%02d%02d%02d%02d %u %u %u %u %x ",
                gtm->tm_year + 1900, gtm->tm_mon + 1, gtm->tm_mday, gtm->tm_hour,
                gtm->tm_min, gtm->tm_sec, otype, otests, otries, osize, ogenerator);
#line 152
  if (res < 0) {
#line 153
    return (-1);
  }
#line 155
  tmp = BN_print_fp(ofile, (BIGNUM const   *)omodulus);
#line 155
  if (tmp < 1) {
#line 156
    return (-1);
  }
#line 158
  res = fprintf((FILE * __restrict  )ofile, (char const   * __restrict  )"\n");
#line 159
  fflush(ofile);
#line 161
  if (res > 0) {
#line 161
    tmp___0 = 0;
  } else {
#line 161
    tmp___0 = -1;
  }
#line 161
  return (tmp___0);
}
}
#line 168 "moduli.c"
static void sieve_large(u_int32_t s ) 
{ u_int32_t r ;
  u_int32_t u ;
  unsigned long tmp ;

  {
#line 173
  debug3("sieve_large %u", s);
#line 174
  largetries ++;
#line 176
  tmp = BN_mod_word((BIGNUM const   *)largebase, (unsigned long )s);
#line 176
  r = (unsigned int )tmp;
#line 177
  if (r == 0U) {
#line 178
    u = 0U;
  } else {
#line 180
    u = s - r;
  }
#line 182
  if (u < largebits * 2U) {
#line 188
    if (u & 1U) {
#line 189
      u += s;
    }
#line 192
    u /= 2U;
#line 192
    while (u < largebits) {
#line 193
      *(LargeSieve + (u >> 5)) = (unsigned int )((unsigned long )*(LargeSieve + (u >> 5)) | (unsigned long )(1L << (u & 31U)));
#line 192
      u += s;
    }
  }
#line 197
  r = (2U * r + 1U) % s;
#line 198
  if (r == 0U) {
#line 199
    u = 0U;
  } else {
#line 201
    u = s - r;
  }
#line 203
  if (u < largebits * 4U) {
#line 209
    while (u & 3U) {
#line 210
      if (4294967295UL - (unsigned long )u < (unsigned long )s) {
#line 211
        return;
      }
#line 212
      u += s;
    }
#line 216
    u /= 4U;
#line 216
    while (u < largebits) {
#line 217
      *(LargeSieve + (u >> 5)) = (unsigned int )((unsigned long )*(LargeSieve + (u >> 5)) | (unsigned long )(1L << (u & 31U)));
#line 216
      u += s;
    }
  }
#line 219
  return;
}
}
#line 226 "moduli.c"
int gen_candidates(FILE *out , int memory , int power , BIGNUM *start___0 ) 
{ BIGNUM *q ;
  u_int32_t j ;
  u_int32_t r ;
  u_int32_t s ;
  u_int32_t t ;
  u_int32_t smallwords ;
  u_int32_t tinywords ;
  time_t time_start ;
  time_t time_stop ;
  int i ;
  int ret ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
#line 231
  smallwords = (u_int32_t )((1UL << 16) >> 6);
#line 232
  tinywords = (u_int32_t )((1UL << 16) >> 6);
#line 234
  ret = 0;
#line 236
  largememory = (unsigned int )memory;
#line 242
  if ((unsigned long )power > 1UL << 16) {
#line 243
    error("Too many bits: %u > %lu", power, 1UL << 16);
#line 244
    return (-1);
  } else {
#line 245
    if (power < 512) {
#line 246
      error("Too few bits: %u < %u", power, 512);
#line 247
      return (-1);
    }
  }
#line 249
  power --;
#line 257
  largewords = (unsigned int )(power * power >> 2);
#line 263
  if ((unsigned long )largememory > 127UL) {
#line 264
    logit("Limited memory: %u MB; limit %lu MB", largememory, 127UL);
#line 266
    largememory = 127U;
  }
#line 269
  if (largewords <= largememory << 18) {
#line 270
    logit("Increased memory: %u MB; need %u bytes", largememory, largewords << 2);
#line 272
    largewords = largememory << 18;
  } else {
#line 273
    if (largememory > 0U) {
#line 274
      logit("Decreased memory: %u MB; want %u bytes", largememory, largewords << 2);
#line 276
      largewords = largememory << 18;
    }
  }
#line 279
  tmp = calloc(tinywords, sizeof(u_int32_t ));
#line 279
  TinySieve = (u_int32_t *)tmp;
#line 280
  if ((unsigned int )TinySieve == (unsigned int )((void *)0)) {
#line 281
    error("Insufficient memory for tiny sieve: need %u bytes", tinywords << 2);
#line 283
    exit(1);
  }
#line 285
  tinybits = tinywords << 5;
#line 287
  tmp___0 = calloc(smallwords, sizeof(u_int32_t ));
#line 287
  SmallSieve = (u_int32_t *)tmp___0;
#line 288
  if ((unsigned int )SmallSieve == (unsigned int )((void *)0)) {
#line 289
    error("Insufficient memory for small sieve: need %u bytes", smallwords << 2);
#line 291
    xfree((void *)TinySieve);
#line 292
    exit(1);
  }
#line 294
  smallbits = smallwords << 5;
#line 299
  while (1) {
#line 299
    tmp___1 = calloc(largewords, sizeof(u_int32_t ));
#line 299
    LargeSieve = (u_int32_t *)tmp___1;
#line 299
    if (! ((unsigned int )LargeSieve == (unsigned int )((void *)0))) {
#line 299
      break;
    }
#line 300
    largewords = (unsigned int )((unsigned long )largewords - (unsigned long )(1L << 16));
  }
#line 302
  largebits = largewords << 5;
#line 303
  largenumbers = largebits * 2U;
#line 306
  largetries = 0U;
#line 307
  q = BN_new();
#line 313
  largebase = BN_new();
#line 314
  if ((unsigned int )start___0 == (unsigned int )((void *)0)) {
#line 315
    BN_rand(largebase, power, 1, 1);
  } else {
#line 317
    BN_copy(largebase, (BIGNUM const   *)start___0);
  }
#line 320
  BN_set_bit(largebase, 0);
#line 322
  time(& time_start);
#line 324
  tmp___2 = ctime((time_t const   *)(& time_start));
#line 324
  logit("%.24s Sieve next %u plus %u-bit", tmp___2, largenumbers, power);
#line 326
  tmp___3 = BN_bn2hex((BIGNUM const   *)largebase);
#line 326
  debug2("start point: 0x%s", tmp___3);
#line 331
  i = 0;
#line 331
  while ((u_int32_t )i < tinybits) {
#line 332
    if ((unsigned long )*(TinySieve + (i >> 5)) & (unsigned long )(1L << (i & 31))) {
      goto __Cont;
    }
#line 336
    t = (unsigned int )(2 * i + 3);
#line 339
    j = (u_int32_t )i + t;
#line 339
    while (j < tinybits) {
#line 340
      *(TinySieve + (j >> 5)) = (unsigned int )((unsigned long )*(TinySieve + (j >> 5)) | (unsigned long )(1L << (j & 31U)));
#line 339
      j += t;
    }
#line 342
    sieve_large(t);
    __Cont: /* CIL Label */ 
#line 331
    i ++;
  }
#line 349
  smallbase = (unsigned int )((1UL << 16) + 3UL);
#line 349
  while ((unsigned long )smallbase < 4294967295UL - (1UL << 16)) {
#line 352
    i = 0;
#line 352
    while ((u_int32_t )i < tinybits) {
#line 353
      if ((unsigned long )*(TinySieve + (i >> 5)) & (unsigned long )(1L << (i & 31))) {
        goto __Cont___0;
      }
#line 357
      t = (unsigned int )(2 * i + 3);
#line 358
      r = smallbase % t;
#line 360
      if (r == 0U) {
#line 361
        s = 0U;
      } else {
#line 364
        s = t - r;
      }
#line 372
      if (s & 1U) {
#line 373
        s += t;
      }
#line 376
      s /= 2U;
#line 376
      while (s < smallbits) {
#line 377
        *(SmallSieve + (s >> 5)) = (unsigned int )((unsigned long )*(SmallSieve + (s >> 5)) | (unsigned long )(1L << (s & 31U)));
#line 376
        s += t;
      }
      __Cont___0: /* CIL Label */ 
#line 352
      i ++;
    }
#line 383
    i = 0;
#line 383
    while ((u_int32_t )i < smallbits) {
#line 384
      if ((unsigned long )*(SmallSieve + (i >> 5)) & (unsigned long )(1L << (i & 31))) {
        goto __Cont___1;
      }
#line 388
      sieve_large((u_int32_t )(2 * i) + smallbase);
      __Cont___1: /* CIL Label */ 
#line 383
      i ++;
    }
#line 391
    memset((void *)SmallSieve, 0, smallwords << 2);
#line 349
    smallbase = (unsigned int )((unsigned long )smallbase + (1UL << 16));
  }
#line 394
  time(& time_stop);
#line 396
  tmp___4 = ctime((time_t const   *)(& time_stop));
#line 396
  logit("%.24s Sieved with %u small primes in %ld seconds", tmp___4, largetries, time_stop - time_start);
#line 399
  r = 0U;
#line 399
  j = r;
#line 399
  while (j < largebits) {
#line 400
    if ((unsigned long )*(LargeSieve + (j >> 5)) & (unsigned long )(1L << (j & 31U))) {
      goto __Cont___2;
    }
#line 403
    debug2("test q = largebase+%u", 2U * j);
#line 404
    BN_set_word(q, (unsigned long )(2U * j));
#line 405
    BN_add(q, (BIGNUM const   *)q, (BIGNUM const   *)largebase);
#line 406
    tmp___5 = qfileout(out, 4U, 2U, largetries, (unsigned int )(power - 1), 0U, q);
#line 406
    if (tmp___5 == -1) {
#line 408
      ret = -1;
#line 409
      break;
    }
#line 412
    r ++;
    __Cont___2: /* CIL Label */ 
#line 399
    j ++;
  }
#line 415
  time(& time_stop);
#line 417
  xfree((void *)LargeSieve);
#line 418
  xfree((void *)SmallSieve);
#line 419
  xfree((void *)TinySieve);
#line 421
  tmp___6 = ctime((time_t const   *)(& time_stop));
#line 421
  logit("%.24s Found %u candidates", tmp___6, r);
#line 423
  return (ret);
}
}
#line 432 "moduli.c"
int prime_test(FILE *in , FILE *out , u_int32_t trials , u_int32_t generator_wanted ) 
{ BIGNUM *q ;
  BIGNUM *p ;
  BIGNUM *a ;
  BN_CTX *ctx ;
  char *cp ;
  char *lp ;
  u_int32_t count_in ;
  u_int32_t count_out ;
  u_int32_t count_possible ;
  u_int32_t generator_known ;
  u_int32_t in_tests ;
  u_int32_t in_tries ;
  u_int32_t in_type ;
  u_int32_t in_size ;
  time_t time_start ;
  time_t time_stop ;
  int res ;
  char *tmp ;
  void *tmp___0 ;
  int ll ;
  size_t tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned int tmp___38 ;
  int tmp___39 ;
  u_int32_t r ;
  unsigned long tmp___40 ;
  unsigned long tmp___41 ;
  unsigned long tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;

  {
#line 439
  count_in = (u_int32_t )0;
#line 439
  count_out = (u_int32_t )0;
#line 439
  count_possible = (u_int32_t )0;
#line 444
  time(& time_start);
#line 446
  p = BN_new();
#line 447
  q = BN_new();
#line 448
  ctx = BN_CTX_new();
#line 450
  tmp = ctime((time_t const   *)(& time_start));
#line 450
  debug2("%.24s Final %u Miller-Rabin trials (%x generator)", tmp, trials, generator_wanted);
#line 453
  res = 0;
#line 454
  tmp___0 = xmalloc(8293U);
#line 454
  lp = (char *)tmp___0;
#line 455
  while (1) {
#line 455
    tmp___47 = fgets((char * __restrict  )lp, 8292, (FILE * __restrict  )in);
#line 455
    if (! ((unsigned int )tmp___47 != (unsigned int )((void *)0))) {
#line 455
      break;
    }
#line 456
    tmp___1 = strlen((char const   *)lp);
#line 456
    ll = (int )tmp___1;
#line 458
    count_in ++;
#line 459
    if (ll < 14) {
#line 460
      debug2("%10u: comment or short line", count_in);
#line 461
      continue;
    } else {
#line 459
      if ((int )*lp == 33) {
#line 460
        debug2("%10u: comment or short line", count_in);
#line 461
        continue;
      } else {
#line 459
        if ((int )*lp == 35) {
#line 460
          debug2("%10u: comment or short line", count_in);
#line 461
          continue;
        }
      }
    }
#line 466
    cp = lp + 14;
#line 469
    tmp___2 = strtoul((char const   * __restrict  )cp, (char ** __restrict  )(& cp),
                      10);
#line 469
    in_type = (unsigned int )tmp___2;
#line 472
    tmp___3 = strtoul((char const   * __restrict  )cp, (char ** __restrict  )(& cp),
                      10);
#line 472
    in_tests = (unsigned int )tmp___3;
#line 474
    if (in_tests & 1U) {
#line 475
      debug2("%10u: known composite", count_in);
#line 476
      continue;
    }
#line 480
    tmp___4 = strtoul((char const   * __restrict  )cp, (char ** __restrict  )(& cp),
                      10);
#line 480
    in_tries = (unsigned int )tmp___4;
#line 483
    tmp___5 = strtoul((char const   * __restrict  )cp, (char ** __restrict  )(& cp),
                      10);
#line 483
    in_size = (unsigned int )tmp___5;
#line 486
    tmp___6 = strtoul((char const   * __restrict  )cp, (char ** __restrict  )(& cp),
                      16);
#line 486
    generator_known = (unsigned int )tmp___6;
#line 489
    tmp___38 = __builtin_strspn((char const   *)cp, " ");
#line 489
    cp += tmp___38;
#line 492
    switch ((int )in_type) {
    case 4: 
#line 494
    debug2("%10u: (%u) Sophie-Germaine", count_in, in_type);
#line 495
    a = q;
#line 496
    BN_hex2bn(& a, (char const   *)cp);
#line 498
    BN_lshift(p, (BIGNUM const   *)q, 1);
#line 499
    BN_add_word(p, 1UL);
#line 500
    in_size ++;
#line 501
    generator_known = 0U;
#line 502
    break;
    case 1: 
    case 2: 
    case 3: 
    case 5: 
    case 0: 
#line 508
    debug2("%10u: (%u)", count_in, in_type);
#line 509
    a = p;
#line 510
    BN_hex2bn(& a, (char const   *)cp);
#line 512
    BN_rshift(q, (BIGNUM const   *)p, 1);
#line 513
    break;
    default: 
#line 515
    debug2("Unknown prime type");
#line 516
    break;
    }
#line 523
    tmp___39 = BN_num_bits((BIGNUM const   *)p);
#line 523
    if ((u_int32_t )tmp___39 != in_size + 1U) {
#line 524
      debug2("%10u: bit size %u mismatch", count_in, in_size);
#line 525
      continue;
    }
#line 527
    if (in_size < 511U) {
#line 528
      debug2("%10u: bit size %u too short", count_in, in_size);
#line 529
      continue;
    }
#line 532
    if (in_tests & 4U) {
#line 533
      in_tries += trials;
    } else {
#line 535
      in_tries = trials;
    }
#line 540
    if (generator_known == 0U) {
#line 541
      tmp___42 = BN_mod_word((BIGNUM const   *)p, 24UL);
#line 541
      if (tmp___42 == 11UL) {
#line 542
        generator_known = 2U;
      } else {
#line 543
        tmp___41 = BN_mod_word((BIGNUM const   *)p, 12UL);
#line 543
        if (tmp___41 == 5UL) {
#line 544
          generator_known = 3U;
        } else {
#line 546
          tmp___40 = BN_mod_word((BIGNUM const   *)p, 10UL);
#line 546
          r = (u_int32_t )tmp___40;
#line 548
          if (r == 3U) {
#line 549
            generator_known = 5U;
          } else {
#line 548
            if (r == 7U) {
#line 549
              generator_known = 5U;
            }
          }
        }
      }
    }
#line 555
    if (generator_wanted > 0U) {
#line 555
      if (generator_wanted != generator_known) {
#line 557
        debug2("%10u: generator %d != %d", count_in, generator_known, generator_wanted);
#line 559
        continue;
      }
    }
#line 566
    if (generator_known == 0U) {
#line 567
      debug2("%10u: no known generator", count_in);
#line 568
      continue;
    }
#line 571
    count_possible ++;
#line 580
    tmp___43 = BN_is_prime((BIGNUM const   *)q, 1, (void (*)(int  , int  , void * ))((void *)0),
                           ctx, (void *)0);
#line 580
    if (tmp___43 <= 0) {
#line 581
      debug("%10u: q failed first possible prime test", count_in);
#line 583
      continue;
    }
#line 593
    tmp___44 = BN_is_prime((BIGNUM const   *)p, (int )trials, (void (*)(int  , int  ,
                                                                        void * ))((void *)0),
                           ctx, (void *)0);
#line 593
    if (! tmp___44) {
#line 594
      debug("%10u: p is not prime", count_in);
#line 595
      continue;
    }
#line 597
    debug("%10u: p is almost certainly prime", count_in);
#line 600
    tmp___45 = BN_is_prime((BIGNUM const   *)q, (int )(trials - 1U), (void (*)(int  ,
                                                                               int  ,
                                                                               void * ))((void *)0),
                           ctx, (void *)0);
#line 600
    if (! tmp___45) {
#line 601
      debug("%10u: q is not prime", count_in);
#line 602
      continue;
    }
#line 604
    debug("%10u: q is almost certainly prime", count_in);
#line 606
    tmp___46 = qfileout(out, 2U, in_tests | 4U, in_tries, in_size, generator_known,
                        p);
#line 606
    if (tmp___46) {
#line 608
      res = -1;
#line 609
      break;
    }
#line 612
    count_out ++;
  }
#line 615
  time(& time_stop);
#line 616
  xfree((void *)lp);
#line 617
  BN_free(p);
#line 618
  BN_free(q);
#line 619
  BN_CTX_free(ctx);
#line 621
  tmp___48 = ctime((time_t const   *)(& time_stop));
#line 621
  logit("%.24s Found %u safe primes of %u candidates in %ld seconds", tmp___48, count_out,
        count_possible, time_stop - time_start);
#line 625
  return (res);
}
}
#line 1 "mpaux.o"
#line 20 "mpaux.h"
void compute_session_id(u_char *session_id___0 , u_char *cookie , BIGNUM *host_key_n ,
                        BIGNUM *session_key_n ) ;
#line 26 "mpaux.c"
void compute_session_id(u_char *session_id___0 , u_char *cookie , BIGNUM *host_key_n ,
                        BIGNUM *session_key_n ) 
{ u_int host_key_bytes ;
  int tmp ;
  u_int session_key_bytes ;
  int tmp___0 ;
  u_int bytes ;
  u_char *buf___1 ;
  void *tmp___1 ;
  MD5_CTX md ;

  {
#line 32
  tmp = BN_num_bits((BIGNUM const   *)host_key_n);
#line 32
  host_key_bytes = (u_int )((tmp + 7) / 8);
#line 33
  tmp___0 = BN_num_bits((BIGNUM const   *)session_key_n);
#line 33
  session_key_bytes = (u_int )((tmp___0 + 7) / 8);
#line 34
  bytes = host_key_bytes + session_key_bytes;
#line 35
  tmp___1 = xmalloc(bytes);
#line 35
  buf___1 = (u_char *)tmp___1;
#line 38
  BN_bn2bin((BIGNUM const   *)host_key_n, buf___1);
#line 39
  BN_bn2bin((BIGNUM const   *)session_key_n, buf___1 + host_key_bytes);
#line 40
  MD5_Init(& md);
#line 41
  MD5_Update(& md, (void const   *)buf___1, bytes);
#line 42
  MD5_Update(& md, (void const   *)cookie, 8U);
#line 43
  MD5_Final((unsigned char *)session_id___0, & md);
#line 44
  memset((void *)buf___1, 0, bytes);
#line 45
  xfree((void *)buf___1);
#line 46
  return;
}
}
#line 1 "nchan.o"
#line 69 "nchan.c"
static void chan_send_ieof1(Channel *c ) ;
#line 70
static void chan_send_oclose1(Channel *c ) ;
#line 71
static void chan_send_close2(Channel *c ) ;
#line 72
static void chan_send_eof2(Channel *c ) ;
#line 75
static void chan_shutdown_write(Channel *c ) ;
#line 76
static void chan_shutdown_read(Channel *c ) ;
#line 78 "nchan.c"
static char *ostates[4]  = {      (char *)"open",      (char *)"drain",      (char *)"wait_ieof",      (char *)"closed"};
#line 79 "nchan.c"
static char *istates[4]  = {      (char *)"open",      (char *)"drain",      (char *)"wait_oclose",      (char *)"closed"};
#line 81 "nchan.c"
static void chan_set_istate(Channel *c , u_int next ) 
{ 

  {
#line 84
  if (c->istate > 3U) {
#line 85
    fatal("chan_set_istate: bad state %d -> %d", c->istate, next);
  } else {
#line 84
    if (next > 3U) {
#line 85
      fatal("chan_set_istate: bad state %d -> %d", c->istate, next);
    }
  }
#line 86
  debug2("channel %d: input %s -> %s", c->self, istates[c->istate], istates[next]);
#line 88
  c->istate = next;
#line 89
  return;
}
}
#line 90 "nchan.c"
static void chan_set_ostate(Channel *c , u_int next ) 
{ 

  {
#line 93
  if (c->ostate > 3U) {
#line 94
    fatal("chan_set_ostate: bad state %d -> %d", c->ostate, next);
  } else {
#line 93
    if (next > 3U) {
#line 94
      fatal("chan_set_ostate: bad state %d -> %d", c->ostate, next);
    }
  }
#line 95
  debug2("channel %d: output %s -> %s", c->self, ostates[c->ostate], ostates[next]);
#line 97
  c->ostate = next;
#line 98
  return;
}
}
#line 104 "nchan.c"
static void chan_rcvd_oclose1(Channel *c ) 
{ 

  {
#line 107
  debug2("channel %d: rcvd oclose", c->self);
#line 108
  switch ((int )c->istate) {
  case 2: 
#line 110
  chan_set_istate(c, 3U);
#line 111
  break;
  case 0: 
#line 113
  chan_shutdown_read(c);
#line 114
  chan_send_ieof1(c);
#line 115
  chan_set_istate(c, 3U);
#line 116
  break;
  case 1: 
#line 119
  chan_send_ieof1(c);
#line 120
  chan_set_istate(c, 3U);
#line 121
  break;
  default: 
#line 123
  error("channel %d: protocol error: rcvd_oclose for istate %d", c->self, c->istate);
#line 125
  return;
  }
#line 127
  return;
}
}
#line 128 "nchan.c"
void chan_read_failed(Channel *c ) 
{ 

  {
#line 131
  debug2("channel %d: read failed", c->self);
#line 132
  switch ((int )c->istate) {
  case 0: 
#line 134
  chan_shutdown_read(c);
#line 135
  chan_set_istate(c, 1U);
#line 136
  break;
  default: 
#line 138
  error("channel %d: chan_read_failed for istate %d", c->self, c->istate);
#line 140
  break;
  }
#line 142
  return;
}
}
#line 143 "nchan.c"
void chan_ibuf_empty(Channel *c ) 
{ u_int tmp ;

  {
#line 146
  debug2("channel %d: ibuf empty", c->self);
#line 147
  tmp = buffer_len(& c->input);
#line 147
  if (tmp) {
#line 148
    error("channel %d: chan_ibuf_empty for non empty buffer", c->self);
#line 150
    return;
  }
#line 152
  switch ((int )c->istate) {
  case 1: 
#line 154
  if (compat20) {
#line 155
    if (! (c->flags & 1)) {
#line 156
      chan_send_eof2(c);
    }
#line 157
    chan_set_istate(c, 3U);
  } else {
#line 159
    chan_send_ieof1(c);
#line 160
    chan_set_istate(c, 2U);
  }
#line 162
  break;
  default: 
#line 164
  error("channel %d: chan_ibuf_empty for istate %d", c->self, c->istate);
#line 166
  break;
  }
#line 168
  return;
}
}
#line 169 "nchan.c"
static void chan_rcvd_ieof1(Channel *c ) 
{ 

  {
#line 172
  debug2("channel %d: rcvd ieof", c->self);
#line 173
  switch ((int )c->ostate) {
  case 0: 
#line 175
  chan_set_ostate(c, 1U);
#line 176
  break;
  case 2: 
#line 178
  chan_set_ostate(c, 3U);
#line 179
  break;
  default: 
#line 181
  error("channel %d: protocol error: rcvd_ieof for ostate %d", c->self, c->ostate);
#line 183
  break;
  }
#line 185
  return;
}
}
#line 186 "nchan.c"
static void chan_write_failed1(Channel *c ) 
{ 

  {
#line 189
  debug2("channel %d: write failed", c->self);
#line 190
  switch ((int )c->ostate) {
  case 0: 
#line 192
  chan_shutdown_write(c);
#line 193
  chan_send_oclose1(c);
#line 194
  chan_set_ostate(c, 2U);
#line 195
  break;
  case 1: 
#line 197
  chan_shutdown_write(c);
#line 198
  chan_send_oclose1(c);
#line 199
  chan_set_ostate(c, 3U);
#line 200
  break;
  default: 
#line 202
  error("channel %d: chan_write_failed for ostate %d", c->self, c->ostate);
#line 204
  break;
  }
#line 206
  return;
}
}
#line 207 "nchan.c"
void chan_obuf_empty(Channel *c ) 
{ u_int tmp ;

  {
#line 210
  debug2("channel %d: obuf empty", c->self);
#line 211
  tmp = buffer_len(& c->output);
#line 211
  if (tmp) {
#line 212
    error("channel %d: chan_obuf_empty for non empty buffer", c->self);
#line 214
    return;
  }
#line 216
  switch ((int )c->ostate) {
  case 1: 
#line 218
  chan_shutdown_write(c);
#line 219
  if (! compat20) {
#line 220
    chan_send_oclose1(c);
  }
#line 221
  chan_set_ostate(c, 3U);
#line 222
  break;
  default: 
#line 224
  error("channel %d: internal error: obuf_empty for ostate %d", c->self, c->ostate);
#line 226
  break;
  }
#line 228
  return;
}
}
#line 229 "nchan.c"
static void chan_send_ieof1(Channel *c ) 
{ 

  {
#line 232
  debug2("channel %d: send ieof", c->self);
#line 233
  switch ((int )c->istate) {
  case 0: 
  case 1: 
#line 236
  packet_start((unsigned char)24);
#line 237
  packet_put_int((unsigned int )c->remote_id);
#line 238
  packet_send();
#line 239
  break;
  default: 
#line 241
  error("channel %d: cannot send ieof for istate %d", c->self, c->istate);
#line 243
  break;
  }
#line 245
  return;
}
}
#line 246 "nchan.c"
static void chan_send_oclose1(Channel *c ) 
{ 

  {
#line 249
  debug2("channel %d: send oclose", c->self);
#line 250
  switch ((int )c->ostate) {
  case 0: 
  case 1: 
#line 253
  buffer_clear(& c->output);
#line 254
  packet_start((unsigned char)25);
#line 255
  packet_put_int((unsigned int )c->remote_id);
#line 256
  packet_send();
#line 257
  break;
  default: 
#line 259
  error("channel %d: cannot send oclose for ostate %d", c->self, c->ostate);
#line 261
  break;
  }
#line 263
  return;
}
}
#line 268 "nchan.c"
static void chan_rcvd_close2(Channel *c ) 
{ 

  {
#line 271
  debug2("channel %d: rcvd close", c->self);
#line 272
  if (c->flags & 2) {
#line 273
    error("channel %d: protocol error: close rcvd twice", c->self);
  }
#line 274
  c->flags |= 2;
#line 275
  if (c->type == 10) {
#line 277
    chan_set_ostate(c, 3U);
#line 278
    chan_set_istate(c, 3U);
#line 279
    return;
  }
#line 281
  switch ((int )c->ostate) {
  case 0: 
#line 287
  chan_set_ostate(c, 1U);
#line 288
  break;
  }
#line 290
  switch ((int )c->istate) {
  case 0: 
#line 292
  chan_shutdown_read(c);
#line 293
  chan_set_istate(c, 3U);
#line 294
  break;
  case 1: 
#line 296
  chan_send_eof2(c);
#line 297
  chan_set_istate(c, 3U);
#line 298
  break;
  }
#line 300
  return;
}
}
#line 301 "nchan.c"
static void chan_rcvd_eof2(Channel *c ) 
{ 

  {
#line 304
  debug2("channel %d: rcvd eof", c->self);
#line 305
  c->flags |= 8;
#line 306
  if (c->ostate == 0U) {
#line 307
    chan_set_ostate(c, 1U);
  }
#line 308
  return;
}
}
#line 309 "nchan.c"
static void chan_write_failed2(Channel *c ) 
{ 

  {
#line 312
  debug2("channel %d: write failed", c->self);
#line 313
  switch ((int )c->ostate) {
  case 0: 
  case 1: 
#line 316
  chan_shutdown_write(c);
#line 317
  chan_set_ostate(c, 3U);
#line 318
  break;
  default: 
#line 320
  error("channel %d: chan_write_failed for ostate %d", c->self, c->ostate);
#line 322
  break;
  }
#line 324
  return;
}
}
#line 325 "nchan.c"
static void chan_send_eof2(Channel *c ) 
{ 

  {
#line 328
  debug2("channel %d: send eof", c->self);
#line 329
  switch ((int )c->istate) {
  case 1: 
#line 331
  packet_start((unsigned char)96);
#line 332
  packet_put_int((unsigned int )c->remote_id);
#line 333
  packet_send();
#line 334
  c->flags |= 4;
#line 335
  break;
  default: 
#line 337
  error("channel %d: cannot send eof for istate %d", c->self, c->istate);
#line 339
  break;
  }
#line 341
  return;
}
}
#line 342 "nchan.c"
static void chan_send_close2(Channel *c ) 
{ 

  {
#line 345
  debug2("channel %d: send close", c->self);
#line 346
  if (c->ostate != 3U) {
#line 348
    error("channel %d: cannot send close for istate/ostate %d/%d", c->self, c->istate,
          c->ostate);
  } else {
#line 346
    if (c->istate != 3U) {
#line 348
      error("channel %d: cannot send close for istate/ostate %d/%d", c->self, c->istate,
            c->ostate);
    } else {
#line 350
      if (c->flags & 1) {
#line 351
        error("channel %d: already sent close", c->self);
      } else {
#line 353
        packet_start((unsigned char)97);
#line 354
        packet_put_int((unsigned int )c->remote_id);
#line 355
        packet_send();
#line 356
        c->flags |= 1;
      }
    }
  }
#line 358
  return;
}
}
#line 362 "nchan.c"
void chan_rcvd_ieof(Channel *c ) 
{ u_int tmp ;
  u_int tmp___0 ;

  {
#line 365
  if (compat20) {
#line 366
    chan_rcvd_eof2(c);
  } else {
#line 368
    chan_rcvd_ieof1(c);
  }
#line 369
  if (c->ostate == 1U) {
#line 369
    tmp = buffer_len(& c->output);
#line 369
    if (tmp == 0U) {
#line 369
      if (compat20) {
#line 369
        if (c->extended_usage == 2) {
#line 369
          if (c->efd != -1) {
#line 369
            if (! (! (c->flags & 10))) {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 369
            tmp___0 = buffer_len(& c->extended);
#line 369
            if (! (tmp___0 > 0U)) {
#line 372
              chan_obuf_empty(c);
            }
          }
        } else {
#line 372
          chan_obuf_empty(c);
        }
      } else {
#line 372
        chan_obuf_empty(c);
      }
    }
  }
#line 373
  return;
}
}
#line 374 "nchan.c"
void chan_rcvd_oclose(Channel *c ) 
{ 

  {
#line 377
  if (compat20) {
#line 378
    chan_rcvd_close2(c);
  } else {
#line 380
    chan_rcvd_oclose1(c);
  }
#line 381
  return;
}
}
#line 382 "nchan.c"
void chan_write_failed(Channel *c ) 
{ 

  {
#line 385
  if (compat20) {
#line 386
    chan_write_failed2(c);
  } else {
#line 388
    chan_write_failed1(c);
  }
#line 389
  return;
}
}
#line 391 "nchan.c"
void chan_mark_dead(Channel *c ) 
{ 

  {
#line 394
  c->type = 14;
#line 395
  return;
}
}
#line 397 "nchan.c"
int chan_is_dead(Channel *c , int send___0 ) 
{ u_int tmp ;
  u_int tmp___0 ;

  {
#line 400
  if (c->type == 14) {
#line 401
    debug2("channel %d: zombie", c->self);
#line 402
    return (1);
  }
#line 404
  if (c->istate != 3U) {
#line 405
    return (0);
  } else {
#line 404
    if (c->ostate != 3U) {
#line 405
      return (0);
    }
  }
#line 406
  if (! compat20) {
#line 407
    debug2("channel %d: is dead", c->self);
#line 408
    return (1);
  }
#line 410
  if (datafellows & 2097152) {
#line 410
    if (c->extended_usage == 2) {
#line 410
      if (c->efd != -1) {
#line 410
        tmp___0 = buffer_len(& c->extended);
#line 410
        if (tmp___0 > 0U) {
#line 414
          tmp = buffer_len(& c->extended);
#line 414
          debug2("channel %d: active efd: %d len %d", c->self, c->efd, tmp);
#line 416
          return (0);
        }
      }
    }
  }
#line 418
  if (! (c->flags & 1)) {
#line 419
    if (send___0) {
#line 420
      chan_send_close2(c);
    } else {
#line 423
      if (c->flags & 2) {
#line 424
        debug2("channel %d: almost dead", c->self);
#line 426
        return (1);
      }
    }
  }
#line 430
  if (c->flags & 1) {
#line 430
    if (c->flags & 2) {
#line 432
      debug2("channel %d: is dead", c->self);
#line 433
      return (1);
    }
  }
#line 435
  return (0);
}
}
#line 439 "nchan.c"
static void chan_shutdown_write(Channel *c ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 442
  buffer_clear(& c->output);
#line 443
  if (compat20) {
#line 443
    if (c->type == 10) {
#line 444
      return;
    }
  }
#line 446
  debug2("channel %d: close_write", c->self);
#line 447
  if (c->sock != -1) {
#line 448
    tmp___1 = shutdown(c->sock, 1);
#line 448
    if (tmp___1 < 0) {
#line 449
      tmp = __errno_location();
#line 449
      tmp___0 = strerror(*tmp);
#line 449
      debug2("channel %d: chan_shutdown_write: shutdown() failed for fd%d: %.100s",
             c->self, c->sock, tmp___0);
    }
  } else {
#line 453
    tmp___4 = channel_close_fd(& c->wfd);
#line 453
    if (tmp___4 < 0) {
#line 454
      tmp___2 = __errno_location();
#line 454
      tmp___3 = strerror(*tmp___2);
#line 454
      logit("channel %d: chan_shutdown_write: close() failed for fd%d: %.100s", c->self,
            c->wfd, tmp___3);
    }
  }
#line 458
  return;
}
}
#line 459 "nchan.c"
static void chan_shutdown_read(Channel *c ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 462
  if (compat20) {
#line 462
    if (c->type == 10) {
#line 463
      return;
    }
  }
#line 464
  debug2("channel %d: close_read", c->self);
#line 465
  if (c->sock != -1) {
#line 471
    tmp___1 = shutdown(c->sock, 0);
#line 471
    if (tmp___1 < 0) {
#line 471
      tmp___2 = __errno_location();
#line 471
      if (*tmp___2 != 107) {
#line 473
        tmp = __errno_location();
#line 473
        tmp___0 = strerror(*tmp);
#line 473
        error("channel %d: chan_shutdown_read: shutdown() failed for fd%d [i%d o%d]: %.100s",
              c->self, c->sock, c->istate, c->ostate, tmp___0);
      }
    }
  } else {
#line 478
    tmp___5 = channel_close_fd(& c->rfd);
#line 478
    if (tmp___5 < 0) {
#line 479
      tmp___3 = __errno_location();
#line 479
      tmp___4 = strerror(*tmp___3);
#line 479
      logit("channel %d: chan_shutdown_read: close() failed for fd%d: %.100s", c->self,
            c->rfd, tmp___4);
    }
  }
#line 483
  return;
}
}
#line 1 "packet.o"
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 21 "packet.h"
void packet_set_connection(int fd_in , int fd_out ) ;
#line 22
void packet_set_nonblocking(void) ;
#line 24
int packet_get_connection_out(void) ;
#line 25
void packet_close(void) ;
#line 26
void packet_set_encryption_key(u_char const   *key , u_int keylen , int number ) ;
#line 27
u_int packet_get_encryption_key(u_char *key ) ;
#line 28
void packet_set_protocol_flags(u_int protocol_flags ) ;
#line 30
void packet_start_compression(int level ) ;
#line 31
void packet_set_interactive(int interactive ) ;
#line 37
void packet_put_bignum(BIGNUM *value ) ;
#line 38
void packet_put_bignum2(BIGNUM *value ) ;
#line 41
void packet_put_raw(void const   *buf___1 , u_int len ) ;
#line 45
void packet_read_expect(int expected_type ) ;
#line 46
int packet_read_poll(void) ;
#line 47
void packet_process_incoming(char const   *buf___1 , u_int len ) ;
#line 48
int packet_read_seqnr(u_int32_t *seqnr_p ) ;
#line 49
int packet_read_poll_seqnr(u_int32_t *seqnr_p ) ;
#line 51
u_int packet_get_char(void) ;
#line 53
void packet_get_bignum(BIGNUM *value ) ;
#line 54
void packet_get_bignum2(BIGNUM *value ) ;
#line 55
void *packet_get_raw(int *length_ptr ) ;
#line 58
void ( /* format attribute */  packet_send_debug)(char const   *fmt  , ...) ;
#line 60
void set_newkeys(int mode ) ;
#line 61
int packet_get_keyiv_len(int mode ) ;
#line 62
void packet_get_keyiv(int mode , u_char *iv , u_int len ) ;
#line 63
int packet_get_keycontext(int mode , u_char *dat ) ;
#line 64
void packet_set_keycontext(int mode , u_char *dat ) ;
#line 65
void packet_get_state(int mode , u_int32_t *seqnr , u_int64_t *blocks , u_int32_t *packets ) ;
#line 66
void packet_set_state(int mode , u_int32_t seqnr , u_int64_t blocks , u_int32_t packets ) ;
#line 67
int packet_get_ssh1_cipher(void) ;
#line 68
void packet_set_iv(int mode , u_char *dat ) ;
#line 70
void packet_write_poll(void) ;
#line 72
int packet_have_data_to_write(void) ;
#line 73
int packet_not_very_much_data_to_write(void) ;
#line 76
int packet_connection_is_ipv4(void) ;
#line 79
void packet_add_padding(u_char pad ) ;
#line 85
u_int packet_set_maxsize(u_int s ) ;
#line 99
int packet_need_rekeying(void) ;
#line 100
void packet_set_rekey_limit(u_int32_t bytes ) ;
#line 126 "kex.h"
Newkeys *kex_get_newkeys(int mode ) ;
#line 28 "mac.h"
u_char *mac_compute(Mac *mac , u_int32_t seqno , u_char *data , int datalen ) ;
#line 79 "packet.c"
static int connection_in  =    -1;
#line 80 "packet.c"
static int connection_out  =    -1;
#line 83 "packet.c"
static u_int remote_protocol_flags  =    (u_int )0;
#line 86 "packet.c"
static CipherContext receive_context  ;
#line 89 "packet.c"
static CipherContext send_context  ;
#line 92 "packet.c"
Buffer input  ;
#line 95 "packet.c"
Buffer output  ;
#line 98 "packet.c"
static Buffer outgoing_packet  ;
#line 101 "packet.c"
static Buffer incoming_packet  ;
#line 104 "packet.c"
static Buffer compression_buffer  ;
#line 105 "packet.c"
static int compression_buffer_ready  =    0;
#line 108 "packet.c"
static int packet_compression  =    0;
#line 111 "packet.c"
u_int max_packet_size  =    (u_int )32768;
#line 114 "packet.c"
static int initialized  =    0;
#line 117 "packet.c"
static int interactive_mode  =    0;
#line 120 "packet.c"
Newkeys *newkeys[2]  ;
#line 121 "packet.c"
static struct packet_state p_read  ;
#line 121 "packet.c"
static struct packet_state p_send  ;
#line 127 "packet.c"
static u_int64_t max_blocks_in  ;
#line 127 "packet.c"
static u_int64_t max_blocks_out  ;
#line 128 "packet.c"
static u_int32_t rekey_limit  ;
#line 131 "packet.c"
static u_char ssh1_key[32]  ;
#line 132 "packet.c"
static u_int ssh1_keylen  ;
#line 135 "packet.c"
static u_char extra_pad  =    (u_char )0;
#line 142 "packet.c"
struct __anonstruct_outgoing_78 outgoing  ;
#line 148 "packet.c"
void packet_set_connection(int fd_in , int fd_out ) 
{ Cipher *none ;
  Cipher *tmp ;

  {
#line 151
  tmp = cipher_by_name("none");
#line 151
  none = tmp;
#line 153
  if ((unsigned int )none == (unsigned int )((void *)0)) {
#line 154
    fatal("packet_set_connection: cannot load cipher \'none\'");
  }
#line 155
  connection_in = fd_in;
#line 156
  connection_out = fd_out;
#line 157
  cipher_init(& send_context, none, (u_char const   *)"", 0U, (u_char const   *)((void *)0),
              0U, 1);
#line 158
  cipher_init(& receive_context, none, (u_char const   *)"", 0U, (u_char const   *)((void *)0),
              0U, 0);
#line 159
  newkeys[1] = (Newkeys *)((void *)0);
#line 159
  newkeys[0] = newkeys[1];
#line 160
  if (! initialized) {
#line 161
    initialized = 1;
#line 162
    buffer_init(& input);
#line 163
    buffer_init(& output);
#line 164
    buffer_init(& outgoing_packet);
#line 165
    buffer_init(& incoming_packet);
#line 166
    while (1) {
#line 166
      outgoing.tqh_first = (struct packet *)((void *)0);
#line 166
      outgoing.tqh_last = & outgoing.tqh_first;
#line 166
      break;
    }
  }
#line 168
  return;
}
}
#line 172 "packet.c"
int packet_connection_is_on_socket(void) 
{ struct sockaddr_storage from ;
  struct sockaddr_storage to ;
  socklen_t fromlen ;
  socklen_t tolen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 179
  if (connection_in == connection_out) {
#line 180
    return (1);
  }
#line 181
  fromlen = sizeof(from);
#line 182
  memset((void *)(& from), 0, sizeof(from));
#line 183
  tmp = getpeername(connection_in, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                    (socklen_t * __restrict  )(& fromlen));
#line 183
  if (tmp < 0) {
#line 184
    return (0);
  }
#line 185
  tolen = sizeof(to);
#line 186
  memset((void *)(& to), 0, sizeof(to));
#line 187
  tmp___0 = getpeername(connection_out, (struct sockaddr * __restrict  )((struct sockaddr *)(& to)),
                        (socklen_t * __restrict  )(& tolen));
#line 187
  if (tmp___0 < 0) {
#line 188
    return (0);
  }
#line 189
  if (fromlen != tolen) {
#line 190
    return (0);
  } else {
#line 189
    tmp___1 = memcmp((void const   *)(& from), (void const   *)(& to), fromlen);
#line 189
    if (tmp___1 != 0) {
#line 190
      return (0);
    }
  }
#line 191
  if ((int )from.ss_family != 2) {
#line 191
    if ((int )from.ss_family != 10) {
#line 192
      return (0);
    }
  }
#line 193
  return (1);
}
}
#line 202 "packet.c"
void packet_get_keyiv(int mode , u_char *iv , u_int len ) 
{ CipherContext *cc ;

  {
#line 207
  if (mode == 1) {
#line 208
    cc = & send_context;
  } else {
#line 210
    cc = & receive_context;
  }
#line 212
  cipher_get_keyiv(cc, iv, len);
#line 213
  return;
}
}
#line 215 "packet.c"
int packet_get_keycontext(int mode , u_char *dat ) 
{ CipherContext *cc ;
  int tmp ;

  {
#line 220
  if (mode == 1) {
#line 221
    cc = & send_context;
  } else {
#line 223
    cc = & receive_context;
  }
#line 225
  tmp = cipher_get_keycontext((CipherContext const   *)cc, dat);
#line 225
  return (tmp);
}
}
#line 228 "packet.c"
void packet_set_keycontext(int mode , u_char *dat ) 
{ CipherContext *cc ;

  {
#line 233
  if (mode == 1) {
#line 234
    cc = & send_context;
  } else {
#line 236
    cc = & receive_context;
  }
#line 238
  cipher_set_keycontext(cc, dat);
#line 239
  return;
}
}
#line 241 "packet.c"
int packet_get_keyiv_len(int mode ) 
{ CipherContext *cc ;
  int tmp ;

  {
#line 246
  if (mode == 1) {
#line 247
    cc = & send_context;
  } else {
#line 249
    cc = & receive_context;
  }
#line 251
  tmp = cipher_get_keyiv_len((CipherContext const   *)cc);
#line 251
  return (tmp);
}
}
#line 253 "packet.c"
void packet_set_iv(int mode , u_char *dat ) 
{ CipherContext *cc ;

  {
#line 258
  if (mode == 1) {
#line 259
    cc = & send_context;
  } else {
#line 261
    cc = & receive_context;
  }
#line 263
  cipher_set_keyiv(cc, dat);
#line 264
  return;
}
}
#line 265 "packet.c"
int packet_get_ssh1_cipher(void) 
{ u_int tmp ;

  {
#line 268
  tmp = cipher_get_number((Cipher const   *)receive_context.cipher);
#line 268
  return ((int )tmp);
}
}
#line 271 "packet.c"
void packet_get_state(int mode , u_int32_t *seqnr , u_int64_t *blocks , u_int32_t *packets ) 
{ struct packet_state *state ;

  {
#line 276
  if (mode == 0) {
#line 276
    state = & p_read;
  } else {
#line 276
    state = & p_send;
  }
#line 277
  *seqnr = state->seqnr;
#line 278
  *blocks = state->blocks;
#line 279
  *packets = state->packets;
#line 280
  return;
}
}
#line 282 "packet.c"
void packet_set_state(int mode , u_int32_t seqnr , u_int64_t blocks , u_int32_t packets ) 
{ struct packet_state *state ;

  {
#line 287
  if (mode == 0) {
#line 287
    state = & p_read;
  } else {
#line 287
    state = & p_send;
  }
#line 288
  state->seqnr = seqnr;
#line 289
  state->blocks = blocks;
#line 290
  state->packets = packets;
#line 291
  return;
}
}
#line 295 "packet.c"
int packet_connection_is_ipv4(void) 
{ struct sockaddr_storage to ;
  socklen_t tolen ;
  int tmp ;
  register unsigned int __v ;
  register unsigned int __x ;

  {
#line 299
  tolen = sizeof(to);
#line 301
  memset((void *)(& to), 0, sizeof(to));
#line 302
  tmp = getsockname(connection_out, (struct sockaddr * __restrict  )((struct sockaddr *)(& to)),
                    (socklen_t * __restrict  )(& tolen));
#line 302
  if (tmp < 0) {
#line 303
    return (0);
  }
#line 304
  if ((int )to.ss_family == 2) {
#line 305
    return (1);
  }
#line 308
  if ((int )to.ss_family == 10) {
#line 308
    if (*((uint32_t const   *)(& ((struct sockaddr_in6 *)(& to))->sin6_addr) + 0) == 0U) {
#line 308
      if (*((uint32_t const   *)(& ((struct sockaddr_in6 *)(& to))->sin6_addr) + 1) == 0U) {
#line 308
        __x = 65535U;
#line 308
        __asm__  ("rorw $8, %w0;"
                  "rorl $16, %0;"
                  "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 308
        if (*((uint32_t const   *)(& ((struct sockaddr_in6 *)(& to))->sin6_addr) + 2) == (uint32_t const   )__v) {
#line 309
          return (1);
        }
      }
    }
  }
#line 311
  return (0);
}
}
#line 316 "packet.c"
void packet_set_nonblocking(void) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 320
  tmp___1 = fcntl(connection_in, 4, 2048);
#line 320
  if (tmp___1 < 0) {
#line 321
    tmp = __errno_location();
#line 321
    tmp___0 = strerror(*tmp);
#line 321
    error("fcntl O_NONBLOCK: %.100s", tmp___0);
  }
#line 323
  if (connection_out != connection_in) {
#line 324
    tmp___4 = fcntl(connection_out, 4, 2048);
#line 324
    if (tmp___4 < 0) {
#line 325
      tmp___2 = __errno_location();
#line 325
      tmp___3 = strerror(*tmp___2);
#line 325
      error("fcntl O_NONBLOCK: %.100s", tmp___3);
    }
  }
#line 327
  return;
}
}
#line 331 "packet.c"
int packet_get_connection_in(void) 
{ 

  {
#line 334
  return (connection_in);
}
}
#line 339 "packet.c"
int packet_get_connection_out(void) 
{ 

  {
#line 342
  return (connection_out);
}
}
#line 347 "packet.c"
void packet_close(void) 
{ 

  {
#line 350
  if (! initialized) {
#line 351
    return;
  }
#line 352
  initialized = 0;
#line 353
  if (connection_in == connection_out) {
#line 354
    shutdown(connection_out, 2);
#line 355
    close(connection_out);
  } else {
#line 357
    close(connection_in);
#line 358
    close(connection_out);
  }
#line 360
  buffer_free(& input);
#line 361
  buffer_free(& output);
#line 362
  buffer_free(& outgoing_packet);
#line 363
  buffer_free(& incoming_packet);
#line 364
  if (compression_buffer_ready) {
#line 365
    buffer_free(& compression_buffer);
#line 366
    buffer_compress_uninit();
  }
#line 368
  cipher_cleanup(& send_context);
#line 369
  cipher_cleanup(& receive_context);
#line 370
  return;
}
}
#line 374 "packet.c"
void packet_set_protocol_flags(u_int protocol_flags ) 
{ 

  {
#line 377
  remote_protocol_flags = protocol_flags;
#line 378
  return;
}
}
#line 382 "packet.c"
u_int packet_get_protocol_flags(void) 
{ 

  {
#line 385
  return (remote_protocol_flags);
}
}
#line 393 "packet.c"
static void packet_init_compression(void) 
{ 

  {
#line 396
  if (compression_buffer_ready == 1) {
#line 397
    return;
  }
#line 398
  compression_buffer_ready = 1;
#line 399
  buffer_init(& compression_buffer);
#line 400
  return;
}
}
#line 402 "packet.c"
void packet_start_compression(int level ) 
{ 

  {
#line 405
  if (packet_compression) {
#line 405
    if (! compat20) {
#line 406
      fatal("Compression already enabled.");
    }
  }
#line 407
  packet_compression = 1;
#line 408
  packet_init_compression();
#line 409
  buffer_compress_init_send(level);
#line 410
  buffer_compress_init_recv();
#line 411
  return;
}
}
#line 419 "packet.c"
void packet_set_encryption_key(u_char const   *key , u_int keylen , int number ) 
{ Cipher *cipher ;
  Cipher *tmp ;

  {
#line 423
  tmp = cipher_by_number(number);
#line 423
  cipher = tmp;
#line 425
  if ((unsigned int )cipher == (unsigned int )((void *)0)) {
#line 426
    fatal("packet_set_encryption_key: unknown cipher number %d", number);
  }
#line 427
  if (keylen < 20U) {
#line 428
    fatal("packet_set_encryption_key: keylen too small: %d", keylen);
  }
#line 429
  if (keylen > 32U) {
#line 430
    fatal("packet_set_encryption_key: keylen too big: %d", keylen);
  }
#line 431
  memcpy((void * __restrict  )(ssh1_key), (void const   * __restrict  )key, keylen);
#line 432
  ssh1_keylen = keylen;
#line 433
  cipher_init(& send_context, cipher, key, keylen, (u_char const   *)((void *)0),
              0U, 1);
#line 434
  cipher_init(& receive_context, cipher, key, keylen, (u_char const   *)((void *)0),
              0U, 0);
#line 435
  return;
}
}
#line 437 "packet.c"
u_int packet_get_encryption_key(u_char *key ) 
{ 

  {
#line 440
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 441
    return (ssh1_keylen);
  }
#line 442
  memcpy((void * __restrict  )key, (void const   * __restrict  )(ssh1_key), ssh1_keylen);
#line 443
  return (ssh1_keylen);
}
}
#line 447 "packet.c"
void packet_start(u_char type ) 
{ u_char buf___1[9] ;
  int len ;

  {
#line 454
  if (compat20) {
#line 454
    len = 6;
  } else {
#line 454
    len = 9;
  }
#line 455
  memset((void *)(buf___1), 0, (unsigned int )(len - 1));
#line 456
  buf___1[len - 1] = type;
#line 457
  buffer_clear(& outgoing_packet);
#line 458
  buffer_append(& outgoing_packet, (void const   *)(buf___1), (unsigned int )len);
#line 459
  return;
}
}
#line 462 "packet.c"
void packet_put_char(int value ) 
{ char ch ;

  {
#line 465
  ch = (char )value;
#line 467
  buffer_append(& outgoing_packet, (void const   *)(& ch), 1U);
#line 468
  return;
}
}
#line 469 "packet.c"
void packet_put_int(u_int value ) 
{ 

  {
#line 472
  buffer_put_int(& outgoing_packet, value);
#line 473
  return;
}
}
#line 474 "packet.c"
void packet_put_string(void const   *buf___1 , u_int len ) 
{ 

  {
#line 477
  buffer_put_string(& outgoing_packet, buf___1, len);
#line 478
  return;
}
}
#line 479 "packet.c"
void packet_put_cstring(char const   *str ) 
{ 

  {
#line 482
  buffer_put_cstring(& outgoing_packet, str);
#line 483
  return;
}
}
#line 484 "packet.c"
void packet_put_raw(void const   *buf___1 , u_int len ) 
{ 

  {
#line 487
  buffer_append(& outgoing_packet, buf___1, len);
#line 488
  return;
}
}
#line 489 "packet.c"
void packet_put_bignum(BIGNUM *value ) 
{ 

  {
#line 492
  buffer_put_bignum(& outgoing_packet, (BIGNUM const   *)value);
#line 493
  return;
}
}
#line 494 "packet.c"
void packet_put_bignum2(BIGNUM *value ) 
{ 

  {
#line 497
  buffer_put_bignum2(& outgoing_packet, (BIGNUM const   *)value);
#line 498
  return;
}
}
#line 505 "packet.c"
static void packet_send1(void) 
{ u_char buf___1[8] ;
  u_char *cp ;
  int i ;
  int padding ;
  int len ;
  u_int checksum ;
  u_int32_t rand___0 ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  u_int tmp___3 ;
  void *tmp___4 ;
  u_int tmp___5 ;
  void *tmp___6 ;
  u_int tmp___7 ;
  void *tmp___8 ;

  {
#line 511
  rand___0 = (u_int32_t )0;
#line 517
  if (packet_compression) {
#line 518
    buffer_clear(& compression_buffer);
#line 520
    buffer_consume(& outgoing_packet, 8U);
#line 522
    buffer_append(& compression_buffer, (void const   *)"\000\000\000\000\000\000\000\000",
                  8U);
#line 523
    buffer_compress(& outgoing_packet, & compression_buffer);
#line 524
    buffer_clear(& outgoing_packet);
#line 525
    tmp = buffer_len(& compression_buffer);
#line 525
    tmp___0 = buffer_ptr(& compression_buffer);
#line 525
    buffer_append(& outgoing_packet, (void const   *)tmp___0, tmp);
  }
#line 529
  tmp___1 = buffer_len(& outgoing_packet);
#line 529
  len = (int )((tmp___1 + 4U) - 8U);
#line 532
  padding = 8 - len % 8;
#line 533
  if (! send_context.plaintext) {
#line 534
    tmp___2 = buffer_ptr(& outgoing_packet);
#line 534
    cp = (u_char *)tmp___2;
#line 535
    i = 0;
#line 535
    while (i < padding) {
#line 536
      if (i % 4 == 0) {
#line 537
        rand___0 = arc4random();
      }
#line 538
      *(cp + (7 - i)) = (unsigned char )(rand___0 & 255U);
#line 539
      rand___0 >>= 8;
#line 535
      i ++;
    }
  }
#line 542
  buffer_consume(& outgoing_packet, (unsigned int )(8 - padding));
#line 545
  tmp___3 = buffer_len(& outgoing_packet);
#line 545
  tmp___4 = buffer_ptr(& outgoing_packet);
#line 545
  checksum = ssh_crc32((u_char const   *)tmp___4, tmp___3);
#line 547
  while (1) {
#line 547
    buf___1[0] = (unsigned char )(checksum >> 24);
#line 547
    buf___1[1] = (unsigned char )(checksum >> 16);
#line 547
    buf___1[2] = (unsigned char )(checksum >> 8);
#line 547
    buf___1[3] = (unsigned char )checksum;
#line 547
    break;
  }
#line 548
  buffer_append(& outgoing_packet, (void const   *)(buf___1), 4U);
#line 556
  while (1) {
#line 556
    buf___1[0] = (unsigned char )(len >> 24);
#line 556
    buf___1[1] = (unsigned char )(len >> 16);
#line 556
    buf___1[2] = (unsigned char )(len >> 8);
#line 556
    buf___1[3] = (unsigned char )len;
#line 556
    break;
  }
#line 557
  buffer_append(& output, (void const   *)(buf___1), 4U);
#line 558
  tmp___5 = buffer_len(& outgoing_packet);
#line 558
  tmp___6 = buffer_append_space(& output, tmp___5);
#line 558
  cp = (u_char *)tmp___6;
#line 559
  tmp___7 = buffer_len(& outgoing_packet);
#line 559
  tmp___8 = buffer_ptr(& outgoing_packet);
#line 559
  cipher_crypt(& send_context, cp, (u_char const   *)tmp___8, tmp___7);
#line 567
  buffer_clear(& outgoing_packet);
#line 574
  return;
}
}
#line 576 "packet.c"
void set_newkeys(int mode ) 
{ Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  CipherContext *cc ;
  u_int64_t *max_blocks ;
  int encrypt ;

  {
#line 586
  debug2("set_newkeys: mode %d", mode);
#line 588
  if (mode == 1) {
#line 589
    cc = & send_context;
#line 590
    encrypt = 1;
#line 591
    p_send.blocks = 0ULL;
#line 591
    p_send.packets = (unsigned int )p_send.blocks;
#line 592
    max_blocks = & max_blocks_out;
  } else {
#line 594
    cc = & receive_context;
#line 595
    encrypt = 0;
#line 596
    p_read.blocks = 0ULL;
#line 596
    p_read.packets = (unsigned int )p_read.blocks;
#line 597
    max_blocks = & max_blocks_in;
  }
#line 599
  if ((unsigned int )newkeys[mode] != (unsigned int )((void *)0)) {
#line 600
    debug("set_newkeys: rekeying");
#line 601
    cipher_cleanup(cc);
#line 602
    enc = & (newkeys[mode])->enc;
#line 603
    mac = & (newkeys[mode])->mac;
#line 604
    comp = & (newkeys[mode])->comp;
#line 605
    memset((void *)mac->key, 0, (unsigned int )mac->key_len);
#line 606
    xfree((void *)enc->name);
#line 607
    xfree((void *)enc->iv);
#line 608
    xfree((void *)enc->key);
#line 609
    xfree((void *)mac->name);
#line 610
    xfree((void *)mac->key);
#line 611
    xfree((void *)comp->name);
#line 612
    xfree((void *)newkeys[mode]);
  }
#line 614
  newkeys[mode] = kex_get_newkeys(mode);
#line 615
  if ((unsigned int )newkeys[mode] == (unsigned int )((void *)0)) {
#line 616
    fatal("newkeys: no keys for mode %d", mode);
  }
#line 617
  enc = & (newkeys[mode])->enc;
#line 618
  mac = & (newkeys[mode])->mac;
#line 619
  comp = & (newkeys[mode])->comp;
#line 620
  if ((unsigned int )mac->md != (unsigned int )((void *)0)) {
#line 621
    mac->enabled = 1;
  }
#line 623
  cipher_init(cc, enc->cipher, (u_char const   *)enc->key, enc->key_len, (u_char const   *)enc->iv,
              enc->block_size, encrypt);
#line 628
  if (comp->type != 0) {
#line 628
    if (comp->enabled == 0) {
#line 629
      packet_init_compression();
#line 630
      if (mode == 1) {
#line 631
        buffer_compress_init_send(6);
      } else {
#line 633
        buffer_compress_init_recv();
      }
#line 634
      comp->enabled = 1;
    }
  }
#line 640
  if (enc->block_size >= 16U) {
#line 641
    *max_blocks = 1ULL << enc->block_size * 2U;
  } else {
#line 643
    *max_blocks = (1ULL << 30) / (unsigned long long )enc->block_size;
  }
#line 644
  if (rekey_limit) {
#line 645
    if (*max_blocks < (u_int64_t )(rekey_limit / enc->block_size)) {
#line 645
      *max_blocks = *max_blocks;
    } else {
#line 645
      *max_blocks = (unsigned long long )(rekey_limit / enc->block_size);
    }
  }
#line 646
  return;
}
}
#line 651 "packet.c"
static void packet_send2_wrapped(void) 
{ u_char type ;
  u_char *cp ;
  u_char *macbuf ;
  u_char padlen ;
  u_char pad ;
  u_int packet_length___0 ;
  u_int i ;
  u_int len ;
  u_int32_t rand___0 ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  int block_size ;
  void *tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  u_int tmp___3 ;
  void *tmp___4 ;
  u_int tmp___5 ;
  void *tmp___6 ;
  u_int tmp___7 ;
  void *tmp___8 ;
  u_int tmp___9 ;
  void *tmp___10 ;

  {
#line 654
  macbuf = (u_char *)((void *)0);
#line 656
  packet_length___0 = (u_int )0;
#line 658
  rand___0 = (u_int32_t )0;
#line 659
  enc = (Enc *)((void *)0);
#line 660
  mac = (Mac *)((void *)0);
#line 661
  comp = (Comp *)((void *)0);
#line 664
  if ((unsigned int )newkeys[1] != (unsigned int )((void *)0)) {
#line 665
    enc = & (newkeys[1])->enc;
#line 666
    mac = & (newkeys[1])->mac;
#line 667
    comp = & (newkeys[1])->comp;
  }
#line 669
  if (enc) {
#line 669
    block_size = (int )enc->block_size;
  } else {
#line 669
    block_size = 8;
  }
#line 671
  tmp = buffer_ptr(& outgoing_packet);
#line 671
  cp = (u_char *)tmp;
#line 672
  type = *(cp + 5);
#line 679
  if (comp) {
#line 679
    if (comp->enabled) {
#line 680
      len = buffer_len(& outgoing_packet);
#line 682
      buffer_consume(& outgoing_packet, 5U);
#line 683
      buffer_clear(& compression_buffer);
#line 684
      buffer_compress(& outgoing_packet, & compression_buffer);
#line 685
      buffer_clear(& outgoing_packet);
#line 686
      buffer_append(& outgoing_packet, (void const   *)"\000\000\000\000\000", 5U);
#line 687
      tmp___0 = buffer_len(& compression_buffer);
#line 687
      tmp___1 = buffer_ptr(& compression_buffer);
#line 687
      buffer_append(& outgoing_packet, (void const   *)tmp___1, tmp___0);
    }
  }
#line 694
  len = buffer_len(& outgoing_packet);
#line 700
  padlen = (unsigned char )((unsigned int )block_size - len % (unsigned int )block_size);
#line 701
  if ((int )padlen < 4) {
#line 702
    padlen = (unsigned char )((int )padlen + block_size);
  }
#line 703
  if (extra_pad) {
#line 705
    extra_pad = (unsigned char )((((int )extra_pad + (block_size - 1)) / block_size) * block_size);
#line 706
    pad = (unsigned char )((unsigned int )extra_pad - (len + (u_int )padlen) % (unsigned int )extra_pad);
#line 707
    debug3("packet_send2: adding %d (len %d padlen %d extra_pad %d)", pad, len, padlen,
           extra_pad);
#line 709
    padlen = (unsigned char )((int )padlen + (int )pad);
#line 710
    extra_pad = (unsigned char)0;
  }
#line 712
  tmp___2 = buffer_append_space(& outgoing_packet, (unsigned int )padlen);
#line 712
  cp = (u_char *)tmp___2;
#line 713
  if (enc) {
#line 713
    if (! send_context.plaintext) {
#line 715
      i = 0U;
#line 715
      while (i < (u_int )padlen) {
#line 716
        if (i % 4U == 0U) {
#line 717
          rand___0 = arc4random();
        }
#line 718
        *(cp + i) = (unsigned char )(rand___0 & 255U);
#line 719
        rand___0 >>= 8;
#line 715
        i ++;
      }
    } else {
#line 723
      memset((void *)cp, 0, (unsigned int )padlen);
    }
  } else {
#line 723
    memset((void *)cp, 0, (unsigned int )padlen);
  }
#line 726
  tmp___3 = buffer_len(& outgoing_packet);
#line 726
  packet_length___0 = tmp___3 - 4U;
#line 727
  tmp___4 = buffer_ptr(& outgoing_packet);
#line 727
  cp = (u_char *)tmp___4;
#line 728
  while (1) {
#line 728
    *(cp + 0) = (unsigned char )(packet_length___0 >> 24);
#line 728
    *(cp + 1) = (unsigned char )(packet_length___0 >> 16);
#line 728
    *(cp + 2) = (unsigned char )(packet_length___0 >> 8);
#line 728
    *(cp + 3) = (unsigned char )packet_length___0;
#line 728
    break;
  }
#line 729
  *(cp + 4) = padlen;
#line 733
  if (mac) {
#line 733
    if (mac->enabled) {
#line 734
      tmp___5 = buffer_len(& outgoing_packet);
#line 734
      tmp___6 = buffer_ptr(& outgoing_packet);
#line 734
      macbuf = mac_compute(mac, p_send.seqnr, (u_char *)tmp___6, (int )tmp___5);
    }
  }
#line 740
  tmp___7 = buffer_len(& outgoing_packet);
#line 740
  tmp___8 = buffer_append_space(& output, tmp___7);
#line 740
  cp = (u_char *)tmp___8;
#line 741
  tmp___9 = buffer_len(& outgoing_packet);
#line 741
  tmp___10 = buffer_ptr(& outgoing_packet);
#line 741
  cipher_crypt(& send_context, cp, (u_char const   *)tmp___10, tmp___9);
#line 744
  if (mac) {
#line 744
    if (mac->enabled) {
#line 745
      buffer_append(& output, (void const   *)((char *)macbuf), (unsigned int )mac->mac_len);
    }
  }
#line 751
  (p_send.seqnr) ++;
#line 751
  if (p_send.seqnr == 0U) {
#line 752
    logit("outgoing seqnr wraps around");
  }
#line 753
  (p_send.packets) ++;
#line 753
  if (p_send.packets == 0U) {
#line 754
    if (! (datafellows & 32768)) {
#line 755
      fatal("XXX too many packets with same key");
    }
  }
#line 756
  p_send.blocks += (u_int64_t )((packet_length___0 + 4U) / (u_int )block_size);
#line 757
  buffer_clear(& outgoing_packet);
#line 759
  if ((int )type == 21) {
#line 760
    set_newkeys(1);
  }
#line 761
  return;
}
}
#line 766
static void packet_send2(void) ;
#line 766 "packet.c"
static int rekeying  =    0;
#line 763 "packet.c"
static void packet_send2(void) 
{ struct packet *p ;
  u_char type ;
  u_char *cp ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 770
  tmp = buffer_ptr(& outgoing_packet);
#line 770
  cp = (u_char *)tmp;
#line 771
  type = *(cp + 5);
#line 774
  if (rekeying) {
#line 775
    if ((int )type >= 1) {
#line 775
      if (! ((int )type <= 49)) {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 777
      debug("enqueue packet: %u", type);
#line 778
      tmp___0 = xmalloc(sizeof(*p));
#line 778
      p = (struct packet *)tmp___0;
#line 779
      p->type = type;
#line 780
      memcpy((void * __restrict  )(& p->payload), (void const   * __restrict  )(& outgoing_packet),
             sizeof(Buffer ));
#line 781
      buffer_init(& outgoing_packet);
#line 782
      while (1) {
#line 782
        p->next.tqe_next = (struct packet *)((void *)0);
#line 782
        p->next.tqe_prev = outgoing.tqh_last;
#line 782
        *(outgoing.tqh_last) = p;
#line 782
        outgoing.tqh_last = & p->next.tqe_next;
#line 782
        break;
      }
#line 783
      return;
    }
  }
#line 788
  if ((int )type == 20) {
#line 789
    rekeying = 1;
  }
#line 791
  packet_send2_wrapped();
#line 794
  if ((int )type == 21) {
#line 795
    rekeying = 0;
#line 796
    while (1) {
#line 796
      p = outgoing.tqh_first;
#line 796
      if (! p) {
#line 796
        break;
      }
#line 797
      type = p->type;
#line 798
      debug("dequeue packet: %u", type);
#line 799
      buffer_free(& outgoing_packet);
#line 800
      memcpy((void * __restrict  )(& outgoing_packet), (void const   * __restrict  )(& p->payload),
             sizeof(Buffer ));
#line 802
      while (1) {
#line 802
        if ((unsigned int )p->next.tqe_next != (unsigned int )((void *)0)) {
#line 802
          (p->next.tqe_next)->next.tqe_prev = p->next.tqe_prev;
        } else {
#line 802
          outgoing.tqh_last = p->next.tqe_prev;
        }
#line 802
        *(p->next.tqe_prev) = p->next.tqe_next;
#line 802
        break;
      }
#line 803
      xfree((void *)p);
#line 804
      packet_send2_wrapped();
    }
  }
#line 807
  return;
}
}
#line 809 "packet.c"
void packet_send(void) 
{ 

  {
#line 812
  if (compat20) {
#line 813
    packet_send2();
  } else {
#line 815
    packet_send1();
  }
#line 817
  return;
}
}
#line 825 "packet.c"
int packet_read_seqnr(u_int32_t *seqnr_p ) 
{ int type ;
  int len ;
  fd_set *setp ;
  char buf___1[8192] ;
  void *tmp ;
  int _len ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char const   *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
#line 833
  tmp = xmalloc((((unsigned int )(connection_in + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 833
  setp = (fd_set *)tmp;
#line 837
  packet_write_wait();
#line 840
  while (1) {
#line 842
    type = packet_read_poll_seqnr(seqnr_p);
#line 843
    if (! compat20) {
#line 843
      if (type == 14) {
        goto _L;
      } else {
#line 843
        if (type == 15) {
          goto _L;
        } else {
#line 843
          if (type == 19) {
            goto _L;
          } else {
#line 843
            if (type == 33) {
              _L: /* CIL Label */ 
#line 848
              while (1) {
#line 848
                tmp___0 = packet_remaining();
#line 848
                _len = tmp___0;
#line 848
                if (_len > 0) {
#line 848
                  logit("Packet integrity error (%d bytes remaining) at %s:%d", _len,
                        "packet.c", 848);
#line 848
                  packet_disconnect("Packet integrity error.");
                }
#line 848
                break;
              }
            }
          }
        }
      }
    }
#line 850
    if (type != 0) {
#line 851
      xfree((void *)setp);
#line 852
      return (type);
    }
#line 858
    memset((void *)setp, 0, (((unsigned int )(connection_in + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 860
    __asm__  volatile   ("btsl %1,%0": "=m" (setp->__fds_bits[(unsigned int )connection_in / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 863
    while (1) {
#line 863
      tmp___1 = select(connection_in + 1, (fd_set * __restrict  )setp, (fd_set * __restrict  )((void *)0),
                       (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 863
      if (tmp___1 == -1) {
#line 863
        tmp___2 = __errno_location();
#line 863
        if (! (*tmp___2 == 11)) {
#line 863
          tmp___3 = __errno_location();
#line 863
          if (! (*tmp___3 == 4)) {
#line 863
            break;
          }
        }
      } else {
#line 863
        break;
      }
    }
#line 868
    len = read(connection_in, (void *)(buf___1), sizeof(buf___1));
#line 869
    if (len == 0) {
#line 870
      tmp___4 = get_remote_ipaddr();
#line 870
      logit("Connection closed by %.200s", tmp___4);
#line 871
      cleanup_exit(255);
    }
#line 873
    if (len < 0) {
#line 874
      tmp___5 = __errno_location();
#line 874
      tmp___6 = strerror(*tmp___5);
#line 874
      fatal("Read from socket failed: %.100s", tmp___6);
    }
#line 876
    packet_process_incoming((char const   *)(buf___1), (unsigned int )len);
  }
}
}
#line 881 "packet.c"
int packet_read(void) 
{ int tmp ;

  {
#line 884
  tmp = packet_read_seqnr((u_int32_t *)((void *)0));
#line 884
  return (tmp);
}
}
#line 892 "packet.c"
void packet_read_expect(int expected_type ) 
{ int type ;

  {
#line 897
  type = packet_read();
#line 898
  if (type != expected_type) {
#line 899
    packet_disconnect("Protocol error: expected packet type %d, got %d", expected_type,
                      type);
  }
#line 901
  return;
}
}
#line 912 "packet.c"
static int packet_read_poll1(void) 
{ u_int len ;
  u_int padded_len ;
  u_char *cp ;
  u_char type ;
  u_int checksum ;
  u_int stored_checksum ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  u_int tmp___6 ;
  void *tmp___7 ;
  u_int tmp___8 ;
  u_int tmp___9 ;
  void *tmp___10 ;
  u_int tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;

  {
#line 920
  tmp = buffer_len(& input);
#line 920
  if (tmp < 12U) {
#line 921
    return (0);
  }
#line 923
  tmp___0 = buffer_ptr(& input);
#line 923
  cp = (u_char *)tmp___0;
#line 924
  len = (unsigned int )(((((unsigned long )*(cp + 0) << 24) | ((unsigned long )*(cp + 1) << 16)) | ((unsigned long )*(cp + 2) << 8)) | (unsigned long )*(cp + 3));
#line 925
  if (len < 5U) {
#line 926
    packet_disconnect("Bad packet length %u.", len);
  } else {
#line 925
    if (len > 262144U) {
#line 926
      packet_disconnect("Bad packet length %u.", len);
    }
  }
#line 927
  padded_len = (len + 8U) & 4294967288U;
#line 930
  tmp___1 = buffer_len(& input);
#line 930
  if (tmp___1 < 4U + padded_len) {
#line 931
    return (0);
  }
#line 936
  buffer_consume(& input, 4U);
#line 943
  if (! receive_context.plaintext) {
#line 943
    tmp___2 = buffer_ptr(& input);
#line 943
    tmp___3 = detect_attack((u_char *)tmp___2, padded_len, (u_char *)((void *)0));
#line 943
    if (tmp___3 == 1) {
#line 945
      packet_disconnect("crc32 compensation attack: network attack detected");
    }
  }
#line 948
  buffer_clear(& incoming_packet);
#line 949
  tmp___4 = buffer_append_space(& incoming_packet, padded_len);
#line 949
  cp = (u_char *)tmp___4;
#line 950
  tmp___5 = buffer_ptr(& input);
#line 950
  cipher_crypt(& receive_context, cp, (u_char const   *)tmp___5, padded_len);
#line 952
  buffer_consume(& input, padded_len);
#line 960
  tmp___6 = buffer_len(& incoming_packet);
#line 960
  tmp___7 = buffer_ptr(& incoming_packet);
#line 960
  checksum = ssh_crc32((u_char const   *)tmp___7, tmp___6 - 4U);
#line 964
  buffer_consume(& incoming_packet, 8U - len % 8U);
#line 967
  tmp___9 = buffer_len(& incoming_packet);
#line 967
  if (len != tmp___9) {
#line 968
    tmp___8 = buffer_len(& incoming_packet);
#line 968
    packet_disconnect("packet_read_poll1: len %d != buffer_len %d.", len, tmp___8);
  }
#line 971
  tmp___10 = buffer_ptr(& incoming_packet);
#line 971
  cp = ((u_char *)tmp___10 + len) - 4;
#line 972
  stored_checksum = (unsigned int )(((((unsigned long )*(cp + 0) << 24) | ((unsigned long )*(cp + 1) << 16)) | ((unsigned long )*(cp + 2) << 8)) | (unsigned long )*(cp + 3));
#line 973
  if (checksum != stored_checksum) {
#line 974
    packet_disconnect("Corrupted check bytes on input.");
  }
#line 975
  buffer_consume_end(& incoming_packet, 4U);
#line 977
  if (packet_compression) {
#line 978
    buffer_clear(& compression_buffer);
#line 979
    buffer_uncompress(& incoming_packet, & compression_buffer);
#line 980
    buffer_clear(& incoming_packet);
#line 981
    tmp___11 = buffer_len(& compression_buffer);
#line 981
    tmp___12 = buffer_ptr(& compression_buffer);
#line 981
    buffer_append(& incoming_packet, (void const   *)tmp___12, tmp___11);
  }
#line 984
  tmp___13 = buffer_get_char(& incoming_packet);
#line 984
  type = (unsigned char )tmp___13;
#line 985
  return ((int )type);
}
}
#line 991
static int packet_read_poll2(u_int32_t *seqnr_p ) ;
#line 991 "packet.c"
static u_int packet_length  =    (u_int )0;
#line 988 "packet.c"
static int packet_read_poll2(u_int32_t *seqnr_p ) 
{ u_int padlen ;
  u_int need ;
  u_char *macbuf ;
  u_char *cp ;
  u_char type ;
  int maclen ;
  int block_size ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  u_int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  u_int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;
  u_int tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;

  {
#line 995
  enc = (Enc *)((void *)0);
#line 996
  mac = (Mac *)((void *)0);
#line 997
  comp = (Comp *)((void *)0);
#line 999
  if ((unsigned int )newkeys[0] != (unsigned int )((void *)0)) {
#line 1000
    enc = & (newkeys[0])->enc;
#line 1001
    mac = & (newkeys[0])->mac;
#line 1002
    comp = & (newkeys[0])->comp;
  }
#line 1004
  if (mac) {
#line 1004
    if (mac->enabled) {
#line 1004
      maclen = mac->mac_len;
    } else {
#line 1004
      maclen = 0;
    }
  } else {
#line 1004
    maclen = 0;
  }
#line 1005
  if (enc) {
#line 1005
    block_size = (int )enc->block_size;
  } else {
#line 1005
    block_size = 8;
  }
#line 1007
  if (packet_length == 0U) {
#line 1012
    tmp = buffer_len(& input);
#line 1012
    if (tmp < (u_int )block_size) {
#line 1013
      return (0);
    }
#line 1014
    buffer_clear(& incoming_packet);
#line 1015
    tmp___0 = buffer_append_space(& incoming_packet, (unsigned int )block_size);
#line 1015
    cp = (u_char *)tmp___0;
#line 1016
    tmp___1 = buffer_ptr(& input);
#line 1016
    cipher_crypt(& receive_context, cp, (u_char const   *)tmp___1, (unsigned int )block_size);
#line 1018
    tmp___2 = buffer_ptr(& incoming_packet);
#line 1018
    cp = (u_char *)tmp___2;
#line 1019
    packet_length = (unsigned int )(((((unsigned long )*(cp + 0) << 24) | ((unsigned long )*(cp + 1) << 16)) | ((unsigned long )*(cp + 2) << 8)) | (unsigned long )*(cp + 3));
#line 1020
    if (packet_length < 5U) {
#line 1024
      packet_disconnect("Bad packet length %u.", packet_length);
    } else {
#line 1020
      if (packet_length > 262144U) {
#line 1024
        packet_disconnect("Bad packet length %u.", packet_length);
      }
    }
#line 1027
    buffer_consume(& input, (unsigned int )block_size);
  }
#line 1030
  need = (4U + packet_length) - (u_int )block_size;
#line 1033
  if (need % (unsigned int )block_size != 0U) {
#line 1034
    fatal("padding error: need %d block %d mod %d", need, block_size, need % (unsigned int )block_size);
  }
#line 1040
  tmp___3 = buffer_len(& input);
#line 1040
  if (tmp___3 < need + (u_int )maclen) {
#line 1041
    return (0);
  }
#line 1046
  tmp___4 = buffer_append_space(& incoming_packet, need);
#line 1046
  cp = (u_char *)tmp___4;
#line 1047
  tmp___5 = buffer_ptr(& input);
#line 1047
  cipher_crypt(& receive_context, cp, (u_char const   *)tmp___5, need);
#line 1048
  buffer_consume(& input, need);
#line 1053
  if (mac) {
#line 1053
    if (mac->enabled) {
#line 1054
      tmp___6 = buffer_len(& incoming_packet);
#line 1054
      tmp___7 = buffer_ptr(& incoming_packet);
#line 1054
      macbuf = mac_compute(mac, p_read.seqnr, (u_char *)tmp___7, (int )tmp___6);
#line 1057
      tmp___8 = buffer_ptr(& input);
#line 1057
      tmp___9 = memcmp((void const   *)macbuf, (void const   *)tmp___8, (unsigned int )mac->mac_len);
#line 1057
      if (tmp___9 != 0) {
#line 1058
        packet_disconnect("Corrupted MAC on input.");
      }
#line 1060
      buffer_consume(& input, (unsigned int )mac->mac_len);
    }
  }
#line 1062
  if ((unsigned int )seqnr_p != (unsigned int )((void *)0)) {
#line 1063
    *seqnr_p = p_read.seqnr;
  }
#line 1064
  (p_read.seqnr) ++;
#line 1064
  if (p_read.seqnr == 0U) {
#line 1065
    logit("incoming seqnr wraps around");
  }
#line 1066
  (p_read.packets) ++;
#line 1066
  if (p_read.packets == 0U) {
#line 1067
    if (! (datafellows & 32768)) {
#line 1068
      fatal("XXX too many packets with same key");
    }
  }
#line 1069
  p_read.blocks += (u_int64_t )((packet_length + 4U) / (u_int )block_size);
#line 1072
  tmp___10 = buffer_ptr(& incoming_packet);
#line 1072
  cp = (u_char *)tmp___10;
#line 1073
  padlen = (unsigned int )*(cp + 4);
#line 1075
  if (padlen < 4U) {
#line 1076
    packet_disconnect("Corrupted padlen %d on input.", padlen);
  }
#line 1079
  buffer_consume(& incoming_packet, 5U);
#line 1080
  buffer_consume_end(& incoming_packet, padlen);
#line 1083
  if (comp) {
#line 1083
    if (comp->enabled) {
#line 1084
      buffer_clear(& compression_buffer);
#line 1085
      buffer_uncompress(& incoming_packet, & compression_buffer);
#line 1086
      buffer_clear(& incoming_packet);
#line 1087
      tmp___11 = buffer_len(& compression_buffer);
#line 1087
      tmp___12 = buffer_ptr(& compression_buffer);
#line 1087
      buffer_append(& incoming_packet, (void const   *)tmp___12, tmp___11);
    }
  }
#line 1096
  tmp___13 = buffer_get_char(& incoming_packet);
#line 1096
  type = (unsigned char )tmp___13;
#line 1097
  if ((int )type == 21) {
#line 1098
    set_newkeys(0);
  }
#line 1104
  packet_length = 0U;
#line 1105
  return ((int )type);
}
}
#line 1108 "packet.c"
int packet_read_poll_seqnr(u_int32_t *seqnr_p ) 
{ u_int reason ;
  u_int seqnr ;
  u_char type ;
  char *msg ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  char const   *tmp___7 ;

  {
#line 1115
  while (1) {
#line 1116
    if (compat20) {
#line 1117
      tmp = packet_read_poll2(seqnr_p);
#line 1117
      type = (unsigned char )tmp;
#line 1118
      if (type) {

      }
#line 1120
      switch ((int )type) {
      case 2: 
#line 1122
      break;
      case 4: 
#line 1124
      packet_get_char();
#line 1125
      tmp___0 = packet_get_string((u_int *)((void *)0));
#line 1125
      msg = (char *)tmp___0;
#line 1126
      debug("Remote: %.900s", msg);
#line 1127
      xfree((void *)msg);
#line 1128
      tmp___1 = packet_get_string((u_int *)((void *)0));
#line 1128
      msg = (char *)tmp___1;
#line 1129
      xfree((void *)msg);
#line 1130
      break;
      case 1: 
#line 1132
      reason = packet_get_int();
#line 1133
      tmp___2 = packet_get_string((u_int *)((void *)0));
#line 1133
      msg = (char *)tmp___2;
#line 1134
      tmp___3 = get_remote_ipaddr();
#line 1134
      logit("Received disconnect from %s: %u: %.400s", tmp___3, reason, msg);
#line 1136
      xfree((void *)msg);
#line 1137
      cleanup_exit(255);
#line 1138
      break;
      case 3: 
#line 1140
      seqnr = packet_get_int();
#line 1141
      debug("Received SSH2_MSG_UNIMPLEMENTED for %u", seqnr);
#line 1143
      break;
      default: ;
#line 1145
      return ((int )type);
#line 1146
      break;
      }
    } else {
#line 1149
      tmp___4 = packet_read_poll1();
#line 1149
      type = (unsigned char )tmp___4;
#line 1150
      switch ((int )type) {
      case 32: 
#line 1152
      break;
      case 36: 
#line 1154
      tmp___5 = packet_get_string((u_int *)((void *)0));
#line 1154
      msg = (char *)tmp___5;
#line 1155
      debug("Remote: %.900s", msg);
#line 1156
      xfree((void *)msg);
#line 1157
      break;
      case 1: 
#line 1159
      tmp___6 = packet_get_string((u_int *)((void *)0));
#line 1159
      msg = (char *)tmp___6;
#line 1160
      tmp___7 = get_remote_ipaddr();
#line 1160
      logit("Received disconnect from %s: %.400s", tmp___7, msg);
#line 1162
      cleanup_exit(255);
#line 1163
      xfree((void *)msg);
#line 1164
      break;
      default: ;
#line 1166
      if (type) {

      }
#line 1168
      return ((int )type);
#line 1169
      break;
      }
    }
  }
}
}
#line 1175 "packet.c"
int packet_read_poll(void) 
{ int tmp ;

  {
#line 1178
  tmp = packet_read_poll_seqnr((u_int32_t *)((void *)0));
#line 1178
  return (tmp);
}
}
#line 1186 "packet.c"
void packet_process_incoming(char const   *buf___1 , u_int len ) 
{ 

  {
#line 1189
  buffer_append(& input, (void const   *)buf___1, len);
#line 1190
  return;
}
}
#line 1194 "packet.c"
u_int packet_get_char(void) 
{ char ch ;

  {
#line 1199
  buffer_get(& incoming_packet, (void *)(& ch), 1U);
#line 1200
  return ((unsigned int )((unsigned char )ch));
}
}
#line 1205 "packet.c"
u_int packet_get_int(void) 
{ u_int tmp ;

  {
#line 1208
  tmp = buffer_get_int(& incoming_packet);
#line 1208
  return (tmp);
}
}
#line 1216 "packet.c"
void packet_get_bignum(BIGNUM *value ) 
{ 

  {
#line 1219
  buffer_get_bignum(& incoming_packet, value);
#line 1220
  return;
}
}
#line 1222 "packet.c"
void packet_get_bignum2(BIGNUM *value ) 
{ 

  {
#line 1225
  buffer_get_bignum2(& incoming_packet, value);
#line 1226
  return;
}
}
#line 1228 "packet.c"
void *packet_get_raw(int *length_ptr ) 
{ int bytes ;
  u_int tmp ;
  void *tmp___0 ;

  {
#line 1231
  tmp = buffer_len(& incoming_packet);
#line 1231
  bytes = (int )tmp;
#line 1233
  if ((unsigned int )length_ptr != (unsigned int )((void *)0)) {
#line 1234
    *length_ptr = bytes;
  }
#line 1235
  tmp___0 = buffer_ptr(& incoming_packet);
#line 1235
  return (tmp___0);
}
}
#line 1238 "packet.c"
int packet_remaining(void) 
{ u_int tmp ;

  {
#line 1241
  tmp = buffer_len(& incoming_packet);
#line 1241
  return ((int )tmp);
}
}
#line 1251 "packet.c"
void *packet_get_string(u_int *length_ptr ) 
{ void *tmp ;

  {
#line 1254
  tmp = buffer_get_string(& incoming_packet, length_ptr);
#line 1254
  return (tmp);
}
}
#line 1266 "packet.c"
void ( /* format attribute */  packet_send_debug)(char const   *fmt  , ...) 
{ char buf___1[1024] ;
  va_list args ;

  {
#line 1272
  if (compat20) {
#line 1272
    if (datafellows & 64) {
#line 1273
      return;
    }
  }
#line 1275
  __builtin_va_start(args, fmt);
#line 1276
  vsnprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )fmt,
            args);
#line 1277
  __builtin_va_end(args);
#line 1279
  if (compat20) {
#line 1280
    packet_start((unsigned char)4);
#line 1281
    packet_put_char(0);
#line 1282
    packet_put_cstring((char const   *)(buf___1));
#line 1283
    packet_put_cstring("");
  } else {
#line 1285
    packet_start((unsigned char)36);
#line 1286
    packet_put_cstring((char const   *)(buf___1));
  }
#line 1288
  packet_send();
#line 1289
  packet_write_wait();
#line 1290
  return;
}
}
#line 1304 "packet.c"
static int disconnecting  =    0;
#line 1299 "packet.c"
void ( /* format attribute */  packet_disconnect)(char const   *fmt  , ...) 
{ char buf___1[1024] ;
  va_list args ;

  {
#line 1306
  if (disconnecting) {
#line 1307
    fatal("packet_disconnect called recursively.");
  }
#line 1308
  disconnecting = 1;
#line 1314
  __builtin_va_start(args, fmt);
#line 1315
  vsnprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )fmt,
            args);
#line 1316
  __builtin_va_end(args);
#line 1319
  logit("Disconnecting: %.100s", buf___1);
#line 1322
  if (compat20) {
#line 1323
    packet_start((unsigned char)1);
#line 1324
    packet_put_int(2U);
#line 1325
    packet_put_cstring((char const   *)(buf___1));
#line 1326
    packet_put_cstring("");
  } else {
#line 1328
    packet_start((unsigned char)1);
#line 1329
    packet_put_cstring((char const   *)(buf___1));
  }
#line 1331
  packet_send();
#line 1332
  packet_write_wait();
#line 1335
  channel_close_all();
#line 1338
  packet_close();
#line 1339
  cleanup_exit(255);
#line 1340
  return;
}
}
#line 1344 "packet.c"
void packet_write_poll(void) 
{ int len ;
  u_int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
#line 1347
  tmp = buffer_len(& output);
#line 1347
  len = (int )tmp;
#line 1349
  if (len > 0) {
#line 1350
    tmp___0 = buffer_ptr(& output);
#line 1350
    len = write(connection_out, (void const   *)tmp___0, (unsigned int )len);
#line 1351
    if (len <= 0) {
#line 1352
      tmp___3 = __errno_location();
#line 1352
      if (*tmp___3 == 11) {
#line 1353
        return;
      } else {
#line 1355
        tmp___1 = __errno_location();
#line 1355
        tmp___2 = strerror(*tmp___1);
#line 1355
        fatal("Write failed: %.100s", tmp___2);
      }
    }
#line 1357
    buffer_consume(& output, (unsigned int )len);
  }
#line 1359
  return;
}
}
#line 1366 "packet.c"
void packet_write_wait(void) 
{ fd_set *setp ;
  void *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
#line 1371
  tmp = xmalloc((((unsigned int )(connection_out + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 1371
  setp = (fd_set *)tmp;
#line 1373
  packet_write_poll();
#line 1374
  while (1) {
#line 1374
    tmp___3 = packet_have_data_to_write();
#line 1374
    if (! tmp___3) {
#line 1374
      break;
    }
#line 1375
    memset((void *)setp, 0, (((unsigned int )(connection_out + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 1377
    __asm__  volatile   ("btsl %1,%0": "=m" (setp->__fds_bits[(unsigned int )connection_out / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 1378
    while (1) {
#line 1378
      tmp___0 = select(connection_out + 1, (fd_set * __restrict  )((void *)0), (fd_set * __restrict  )setp,
                       (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 1378
      if (tmp___0 == -1) {
#line 1378
        tmp___1 = __errno_location();
#line 1378
        if (! (*tmp___1 == 11)) {
#line 1378
          tmp___2 = __errno_location();
#line 1378
          if (! (*tmp___2 == 4)) {
#line 1378
            break;
          }
        }
      } else {
#line 1378
        break;
      }
    }
#line 1381
    packet_write_poll();
  }
#line 1383
  xfree((void *)setp);
#line 1384
  return;
}
}
#line 1388 "packet.c"
int packet_have_data_to_write(void) 
{ u_int tmp ;

  {
#line 1391
  tmp = buffer_len(& output);
#line 1391
  return (tmp != 0U);
}
}
#line 1396 "packet.c"
int packet_not_very_much_data_to_write(void) 
{ u_int tmp ;
  u_int tmp___0 ;

  {
#line 1399
  if (interactive_mode) {
#line 1400
    tmp = buffer_len(& output);
#line 1400
    return (tmp < 16384U);
  } else {
#line 1402
    tmp___0 = buffer_len(& output);
#line 1402
    return (tmp___0 < 131072U);
  }
}
}
#line 1406 "packet.c"
static void packet_set_tos(int interactive ) 
{ int tos ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 1410
  if (interactive) {
#line 1410
    tmp = 16;
  } else {
#line 1410
    tmp = 8;
  }
#line 1410
  tos = tmp;
#line 1412
  tmp___0 = packet_connection_is_on_socket();
#line 1412
  if (tmp___0) {
#line 1412
    tmp___1 = packet_connection_is_ipv4();
#line 1412
    if (! tmp___1) {
#line 1414
      return;
    }
  } else {
#line 1414
    return;
  }
#line 1415
  tmp___4 = setsockopt(connection_in, 0, 1, (void const   *)(& tos), sizeof(tos));
#line 1415
  if (tmp___4 < 0) {
#line 1417
    tmp___2 = __errno_location();
#line 1417
    tmp___3 = strerror(*tmp___2);
#line 1417
    error("setsockopt IP_TOS %d: %.100s:", tos, tmp___3);
  }
#line 1420
  return;
}
}
#line 1427 "packet.c"
static int called  =    0;
#line 1424 "packet.c"
void packet_set_interactive(int interactive ) 
{ int tmp ;

  {
#line 1429
  if (called) {
#line 1430
    return;
  }
#line 1431
  called = 1;
#line 1434
  interactive_mode = interactive;
#line 1437
  tmp = packet_connection_is_on_socket();
#line 1437
  if (! tmp) {
#line 1438
    return;
  }
#line 1439
  if (interactive) {
#line 1440
    set_nodelay(connection_in);
  }
#line 1441
  packet_set_tos(interactive);
#line 1442
  return;
}
}
#line 1446 "packet.c"
int packet_is_interactive(void) 
{ 

  {
#line 1449
  return (interactive_mode);
}
}
#line 1455 "packet.c"
static int called___0  =    0;
#line 1452 "packet.c"
u_int packet_set_maxsize(u_int s ) 
{ 

  {
#line 1457
  if (called___0) {
#line 1458
    logit("packet_set_maxsize: called twice: old %d new %d", max_packet_size, s);
#line 1460
    return (4294967295U);
  }
#line 1462
  if (s < 4096U) {
#line 1463
    logit("packet_set_maxsize: bad size %d", s);
#line 1464
    return (4294967295U);
  } else {
#line 1462
    if (s > 1048576U) {
#line 1463
      logit("packet_set_maxsize: bad size %d", s);
#line 1464
      return (4294967295U);
    }
  }
#line 1466
  called___0 = 1;
#line 1467
  debug("packet_set_maxsize: setting to %d", s);
#line 1468
  max_packet_size = s;
#line 1469
  return (s);
}
}
#line 1473 "packet.c"
void packet_add_padding(u_char pad ) 
{ 

  {
#line 1476
  extra_pad = pad;
#line 1477
  return;
}
}
#line 1490 "packet.c"
void packet_send_ignore(int nbytes ) 
{ u_int32_t rand___0 ;
  int i ;
  int tmp ;

  {
#line 1493
  rand___0 = (u_int32_t )0;
#line 1496
  if (compat20) {
#line 1496
    tmp = 2;
  } else {
#line 1496
    tmp = 32;
  }
#line 1496
  packet_start((unsigned char )tmp);
#line 1497
  packet_put_int((unsigned int )nbytes);
#line 1498
  i = 0;
#line 1498
  while (i < nbytes) {
#line 1499
    if (i % 4 == 0) {
#line 1500
      rand___0 = arc4random();
    }
#line 1501
    packet_put_char((int )(rand___0 & 255U));
#line 1502
    rand___0 >>= 8;
#line 1498
    i ++;
  }
#line 1504
  return;
}
}
#line 1507 "packet.c"
int packet_need_rekeying(void) 
{ int tmp ;

  {
#line 1510
  if (datafellows & 32768) {
#line 1511
    return (0);
  }
#line 1512
  if (p_send.packets > (u_int32_t )(1 << 31)) {
#line 1512
    tmp = 1;
  } else {
#line 1512
    if (p_read.packets > (u_int32_t )(1 << 31)) {
#line 1512
      tmp = 1;
    } else {
#line 1512
      if (max_blocks_out) {
#line 1512
        if (p_send.blocks > max_blocks_out) {
#line 1512
          tmp = 1;
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 1512
        if (max_blocks_in) {
#line 1512
          if (p_read.blocks > max_blocks_in) {
#line 1512
            tmp = 1;
          } else {
#line 1512
            tmp = 0;
          }
        } else {
#line 1512
          tmp = 0;
        }
      }
    }
  }
#line 1512
  return (tmp);
}
}
#line 1519 "packet.c"
void packet_set_rekey_limit(u_int32_t bytes ) 
{ 

  {
#line 1522
  rekey_limit = bytes;
#line 1523
  return;
}
}
/* compiler builtin: 
   unsigned int __builtin_strcspn(char const   * , char const   * ) ;  */
#line 1 "readpass.o"
#line 143 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 384 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 493
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 537
extern  __attribute__((__nothrow__)) int execlp(char const   *__file , char const   *__arg 
                                                , ...)  __attribute__((__nonnull__(1))) ;
#line 667
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 677
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 723
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 19 "readpass.h"
char *read_passphrase(char const   *prompt , int flags ) ;
#line 34 "readpass.c"
static char *ssh_askpass(char *askpass , char const   *msg ) 
{ pid_t pid ;
  size_t len ;
  char *pass ;
  int p[2] ;
  int status ;
  int ret ;
  char buf___1[1024] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  __uid_t tmp___7 ;
  __uid_t tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  __pid_t tmp___16 ;
  union __anonunion_72 __constr_expr_0 ;
  union __anonunion_73 __constr_expr_1 ;
  unsigned int tmp___49 ;

  {
#line 43
  tmp___1 = fflush(stdout);
#line 43
  if (tmp___1 != 0) {
#line 44
    tmp = __errno_location();
#line 44
    tmp___0 = strerror(*tmp);
#line 44
    error("ssh_askpass: fflush: %s", tmp___0);
  }
#line 45
  if ((unsigned int )askpass == (unsigned int )((void *)0)) {
#line 46
    fatal("internal error: askpass undefined");
  }
#line 47
  tmp___4 = pipe((int *)(p));
#line 47
  if (tmp___4 < 0) {
#line 48
    tmp___2 = __errno_location();
#line 48
    tmp___3 = strerror(*tmp___2);
#line 48
    error("ssh_askpass: pipe: %s", tmp___3);
#line 49
    return ((char *)((void *)0));
  }
#line 51
  pid = fork();
#line 51
  if (pid < 0) {
#line 52
    tmp___5 = __errno_location();
#line 52
    tmp___6 = strerror(*tmp___5);
#line 52
    error("ssh_askpass: fork: %s", tmp___6);
#line 53
    return ((char *)((void *)0));
  }
#line 55
  if (pid == 0) {
#line 56
    tmp___7 = getuid();
#line 56
    seteuid(tmp___7);
#line 57
    tmp___8 = getuid();
#line 57
    setuid(tmp___8);
#line 58
    close(p[0]);
#line 59
    tmp___11 = dup2(p[1], 1);
#line 59
    if (tmp___11 < 0) {
#line 60
      tmp___9 = __errno_location();
#line 60
      tmp___10 = strerror(*tmp___9);
#line 60
      fatal("ssh_askpass: dup2: %s", tmp___10);
    }
#line 61
    execlp((char const   *)askpass, (char const   *)askpass, msg, (char *)0);
#line 62
    tmp___12 = __errno_location();
#line 62
    tmp___13 = strerror(*tmp___12);
#line 62
    fatal("ssh_askpass: exec(%s): %s", askpass, tmp___13);
  }
#line 64
  close(p[1]);
#line 66
  ret = 0;
#line 66
  len = (unsigned int )ret;
#line 67
  while (1) {
#line 68
    ret = read(p[0], (void *)(buf___1 + len), (sizeof(buf___1) - 1U) - len);
#line 69
    if (ret == -1) {
#line 69
      tmp___14 = __errno_location();
#line 69
      if (*tmp___14 == 4) {
        goto __Cont;
      }
    }
#line 71
    if (ret <= 0) {
#line 72
      break;
    }
#line 73
    len += (size_t )ret;
    __Cont: /* CIL Label */ 
#line 67
    if (! ((sizeof(buf___1) - 1U) - len > 0U)) {
#line 67
      break;
    }
  }
#line 75
  buf___1[len] = (char )'\000';
#line 77
  close(p[0]);
#line 78
  while (1) {
#line 78
    tmp___16 = waitpid(pid, & status, 0);
#line 78
    if (! (tmp___16 < 0)) {
#line 78
      break;
    }
#line 79
    tmp___15 = __errno_location();
#line 79
    if (*tmp___15 != 4) {
#line 80
      break;
    }
  }
#line 82
  __constr_expr_0.__in = status;
#line 82
  if ((__constr_expr_0.__i & 127) == 0) {
#line 82
    __constr_expr_1.__in = status;
#line 82
    if ((__constr_expr_1.__i & 65280) >> 8 != 0) {
#line 83
      memset((void *)(buf___1), 0, sizeof(buf___1));
#line 84
      return ((char *)((void *)0));
    }
  } else {
#line 83
    memset((void *)(buf___1), 0, sizeof(buf___1));
#line 84
    return ((char *)((void *)0));
  }
#line 87
  tmp___49 = __builtin_strcspn((char const   *)(buf___1), "\r\n");
#line 87
  buf___1[tmp___49] = (char )'\000';
#line 88
  pass = xstrdup((char const   *)(buf___1));
#line 89
  memset((void *)(buf___1), 0, sizeof(buf___1));
#line 90
  return (pass);
}
}
#line 99 "readpass.c"
char *read_passphrase(char const   *prompt , int flags ) 
{ char *askpass ;
  char *ret ;
  char buf___1[1024] ;
  int rppflags ;
  int use_askpass ;
  int ttyfd ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 102
  askpass = (char *)((void *)0);
#line 103
  use_askpass = 0;
#line 105
  if (flags & 1) {
#line 105
    rppflags = 1;
  } else {
#line 105
    rppflags = 0;
  }
#line 106
  if (flags & 2) {
#line 107
    tmp = isatty(0);
#line 107
    if (! tmp) {
#line 108
      use_askpass = 1;
    }
  } else {
#line 110
    rppflags |= 2;
#line 111
    ttyfd = open("/dev/tty", 2);
#line 112
    if (ttyfd >= 0) {
#line 113
      close(ttyfd);
    } else {
#line 115
      use_askpass = 1;
    }
  }
#line 118
  if (use_askpass) {
#line 118
    tmp___2 = getenv("DISPLAY");
#line 118
    if (tmp___2) {
#line 119
      tmp___0 = getenv("SSH_ASKPASS");
#line 119
      if (tmp___0) {
#line 120
        askpass = getenv("SSH_ASKPASS");
      } else {
#line 122
        askpass = (char *)"/usr/local/libexec/ssh-askpass";
      }
#line 123
      ret = ssh_askpass(askpass, prompt);
#line 123
      if ((unsigned int )ret == (unsigned int )((void *)0)) {
#line 124
        if (! (flags & 4)) {
#line 125
          tmp___1 = xstrdup("");
#line 125
          return (tmp___1);
        }
      }
#line 126
      return (ret);
    }
  }
#line 129
  tmp___4 = readpassphrase(prompt, buf___1, sizeof(buf___1), rppflags);
#line 129
  if ((unsigned int )tmp___4 == (unsigned int )((void *)0)) {
#line 130
    if (flags & 4) {
#line 131
      return ((char *)((void *)0));
    }
#line 132
    tmp___3 = xstrdup("");
#line 132
    return (tmp___3);
  }
#line 135
  ret = xstrdup((char const   *)(buf___1));
#line 136
  memset((void *)(buf___1), 'x', sizeof(buf___1));
#line 137
  return (ret);
}
}
#line 1 "rsa.o"
#line 391 "/usr/include/openssl/bn.h"
extern BIGNUM const   *BN_value_one(void) ;
#line 409
extern void BN_clear_free(BIGNUM *a ) ;
#line 416
extern int BN_sub(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *b ) ;
#line 433
extern int BN_div(BIGNUM *dv , BIGNUM *rem , BIGNUM const   *m , BIGNUM const   *d ,
                  BN_CTX *ctx ) ;
#line 230 "/usr/include/openssl/rsa.h"
extern int RSA_public_encrypt(int flen , unsigned char const   *from , unsigned char *to ,
                              RSA *rsa , int padding ) ;
#line 236
extern int RSA_private_decrypt(int flen , unsigned char const   *from , unsigned char *to ,
                               RSA *rsa , int padding ) ;
#line 22 "rsa.h"
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 23
int rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 69 "rsa.c"
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ u_char *inbuf ;
  u_char *outbuf ;
  int len ;
  int ilen ;
  int olen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 75
  tmp = BN_num_bits((BIGNUM const   *)key->e);
#line 75
  if (tmp < 2) {
#line 76
    fatal("rsa_public_encrypt() exponent too small or not odd");
  } else {
#line 75
    if ((key->e)->top > 0) {
#line 75
      if (! (*((key->e)->d + 0) & 1UL)) {
#line 76
        fatal("rsa_public_encrypt() exponent too small or not odd");
      }
    } else {
#line 76
      fatal("rsa_public_encrypt() exponent too small or not odd");
    }
  }
#line 78
  tmp___0 = BN_num_bits((BIGNUM const   *)key->n);
#line 78
  olen = (tmp___0 + 7) / 8;
#line 79
  tmp___1 = xmalloc((unsigned int )olen);
#line 79
  outbuf = (u_char *)tmp___1;
#line 81
  tmp___2 = BN_num_bits((BIGNUM const   *)in);
#line 81
  ilen = (tmp___2 + 7) / 8;
#line 82
  tmp___3 = xmalloc((unsigned int )ilen);
#line 82
  inbuf = (u_char *)tmp___3;
#line 83
  BN_bn2bin((BIGNUM const   *)in, inbuf);
#line 85
  len = RSA_public_encrypt(ilen, (unsigned char const   *)inbuf, outbuf, key, 1);
#line 85
  if (len <= 0) {
#line 87
    fatal("rsa_public_encrypt() failed");
  }
#line 89
  BN_bin2bn((unsigned char const   *)outbuf, len, out);
#line 91
  memset((void *)outbuf, 0, (unsigned int )olen);
#line 92
  memset((void *)inbuf, 0, (unsigned int )ilen);
#line 93
  xfree((void *)outbuf);
#line 94
  xfree((void *)inbuf);
#line 95
  return;
}
}
#line 97 "rsa.c"
int rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ u_char *inbuf ;
  u_char *outbuf ;
  int len ;
  int ilen ;
  int olen ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 103
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 103
  olen = (tmp + 7) / 8;
#line 104
  tmp___0 = xmalloc((unsigned int )olen);
#line 104
  outbuf = (u_char *)tmp___0;
#line 106
  tmp___1 = BN_num_bits((BIGNUM const   *)in);
#line 106
  ilen = (tmp___1 + 7) / 8;
#line 107
  tmp___2 = xmalloc((unsigned int )ilen);
#line 107
  inbuf = (u_char *)tmp___2;
#line 108
  BN_bn2bin((BIGNUM const   *)in, inbuf);
#line 110
  len = RSA_private_decrypt(ilen, (unsigned char const   *)inbuf, outbuf, key, 1);
#line 110
  if (len <= 0) {
#line 112
    error("rsa_private_decrypt() failed");
  } else {
#line 114
    BN_bin2bn((unsigned char const   *)outbuf, len, out);
  }
#line 116
  memset((void *)outbuf, 0, (unsigned int )olen);
#line 117
  memset((void *)inbuf, 0, (unsigned int )ilen);
#line 118
  xfree((void *)outbuf);
#line 119
  xfree((void *)inbuf);
#line 120
  return (len);
}
}
#line 124 "rsa.c"
void rsa_generate_additional_parameters(RSA *rsa ) 
{ BIGNUM *aux ;
  BN_CTX *ctx ;
  BIGNUM const   *tmp ;
  BIGNUM const   *tmp___0 ;

  {
#line 130
  aux = BN_new();
#line 130
  if ((unsigned int )aux == (unsigned int )((void *)0)) {
#line 131
    fatal("rsa_generate_additional_parameters: BN_new failed");
  }
#line 132
  ctx = BN_CTX_new();
#line 132
  if ((unsigned int )ctx == (unsigned int )((void *)0)) {
#line 133
    fatal("rsa_generate_additional_parameters: BN_CTX_new failed");
  }
#line 135
  tmp = BN_value_one();
#line 135
  BN_sub(aux, (BIGNUM const   *)rsa->q, tmp);
#line 136
  BN_div((BIGNUM *)((void *)0), rsa->dmq1, (BIGNUM const   *)rsa->d, (BIGNUM const   *)aux,
         ctx);
#line 138
  tmp___0 = BN_value_one();
#line 138
  BN_sub(aux, (BIGNUM const   *)rsa->p, tmp___0);
#line 139
  BN_div((BIGNUM *)((void *)0), rsa->dmp1, (BIGNUM const   *)rsa->d, (BIGNUM const   *)aux,
         ctx);
#line 141
  BN_clear_free(aux);
#line 142
  BN_CTX_free(ctx);
#line 143
  return;
}
}
#line 1 "tildexpand.o"
#line 15 "tildexpand.h"
char *tilde_expand_filename(char const   *filename , uid_t my_uid ) ;
#line 24 "tildexpand.c"
char *tilde_expand_filename(char const   *filename , uid_t my_uid ) 
{ char const   *cp ;
  u_int userlen ;
  char *expanded ;
  struct passwd *pw ;
  char user[100] ;
  int len ;
  char *tmp ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char const   *tmp___16 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;

  {
#line 35
  if ((int const   )*(filename + 0) != 126) {
#line 36
    tmp = xstrdup(filename);
#line 36
    return (tmp);
  }
#line 39
  filename ++;
#line 42
  tmp___1 = __builtin_strchr((char *)filename, '/');
#line 42
  cp = (char const   *)tmp___1;
#line 43
  if (cp) {
#line 44
    userlen = (unsigned int )(cp - filename);
  } else {
#line 46
    userlen = strlen(filename);
  }
#line 47
  if (userlen == 0U) {
#line 48
    pw = getpwuid(my_uid);
  } else {
#line 51
    if (userlen > sizeof(user) - 1U) {
#line 52
      fatal("User name after tilde too long.");
    }
#line 53
    memcpy((void * __restrict  )(user), (void const   * __restrict  )filename, userlen);
#line 54
    user[userlen] = (char)0;
#line 55
    pw = getpwnam((char const   *)(user));
  }
#line 57
  if (! pw) {
#line 58
    fatal("Unknown user %100s.", user);
  }
#line 61
  if (! cp) {
#line 63
    tmp___2 = xstrdup((char const   *)pw->pw_dir);
#line 63
    return (tmp___2);
  }
#line 66
  tmp___3 = strlen((char const   *)pw->pw_dir);
#line 66
  tmp___4 = strlen(cp + 1);
#line 66
  len = (int )((tmp___3 + tmp___4) + 2U);
#line 67
  if (len > 4096) {
#line 68
    fatal("Home directory too long (%d > %d", len - 1, 4095);
  }
#line 69
  tmp___5 = xmalloc((unsigned int )len);
#line 69
  expanded = (char *)tmp___5;
#line 71
  if (0) {
#line 71
    __s1_len___0 = strlen((char const   *)pw->pw_dir);
#line 71
    __s2_len___0 = strlen("/");
#line 71
    if (! ((unsigned int )((void const   *)(pw->pw_dir + 1)) - (unsigned int )((void const   *)pw->pw_dir) == 1U)) {
      goto _L___2;
    } else {
#line 71
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 71
        if (! ((unsigned int )((void const   *)("/" + 1)) - (unsigned int )((void const   *)"/") == 1U)) {
#line 71
          tmp___26 = 1;
        } else {
#line 71
          if (__s2_len___0 >= 4U) {
#line 71
            tmp___26 = 1;
          } else {
#line 71
            tmp___26 = 0;
          }
        }
      } else {
#line 71
        tmp___26 = 0;
      }
    }
#line 71
    if (tmp___26) {
#line 71
      tmp___22 = __builtin_strcmp((char const   *)pw->pw_dir, "/");
    } else {
#line 71
      tmp___25 = __builtin_strcmp((char const   *)pw->pw_dir, "/");
#line 71
      tmp___22 = tmp___25;
    }
  } else {
#line 71
    tmp___25 = __builtin_strcmp((char const   *)pw->pw_dir, "/");
#line 71
    tmp___22 = tmp___25;
  }
#line 71
  if (tmp___22) {
#line 71
    tmp___16 = "/";
  } else {
#line 71
    tmp___16 = "";
  }
#line 71
  snprintf((char * __restrict  )expanded, (unsigned int )len, (char const   * __restrict  )"%s%s%s",
           pw->pw_dir, tmp___16, cp + 1);
#line 72
  return (expanded);
}
}
#line 1 "ttymodes.o"
#line 49 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) speed_t cfgetospeed(struct termios  const  *__termios_p ) ;
#line 52
extern  __attribute__((__nothrow__)) speed_t cfgetispeed(struct termios  const  *__termios_p ) ;
#line 55
extern  __attribute__((__nothrow__)) int cfsetospeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 58
extern  __attribute__((__nothrow__)) int cfsetispeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 81 "packet.h"
void tty_make_modes(int fd , struct termios *tiop ) ;
#line 82
void tty_parse_modes(int fd , int *n_bytes_ptr ) ;
#line 68 "ttymodes.c"
static int speed_to_baud(speed_t speed ) 
{ 

  {
#line 71
  switch ((int )speed) {
  case 0: 
#line 73
  return (0);
  case 1: 
#line 75
  return (50);
  case 2: 
#line 77
  return (75);
  case 3: 
#line 79
  return (110);
  case 4: 
#line 81
  return (134);
  case 5: 
#line 83
  return (150);
  case 6: 
#line 85
  return (200);
  case 7: 
#line 87
  return (300);
  case 8: 
#line 89
  return (600);
  case 9: 
#line 91
  return (1200);
  case 10: 
#line 93
  return (1800);
  case 11: 
#line 95
  return (2400);
  case 12: 
#line 97
  return (4800);
  case 13: 
#line 99
  return (9600);
  case 14: 
#line 103
  return (19200);
  case 15: 
#line 113
  return (38400);
  case 4097: 
#line 135
  return (57600);
  case 4098: 
#line 143
  return (115200);
  case 4099: 
#line 147
  return (230400);
  default: ;
#line 150
  return (9600);
  }
}
}
#line 157 "ttymodes.c"
static speed_t baud_to_speed(int baud ) 
{ 

  {
#line 160
  switch (baud) {
  case 0: 
#line 162
  return (0U);
  case 50: 
#line 164
  return (1U);
  case 75: 
#line 166
  return (2U);
  case 110: 
#line 168
  return (3U);
  case 134: 
#line 170
  return (4U);
  case 150: 
#line 172
  return (5U);
  case 200: 
#line 174
  return (6U);
  case 300: 
#line 176
  return (7U);
  case 600: 
#line 178
  return (8U);
  case 1200: 
#line 180
  return (9U);
  case 1800: 
#line 182
  return (10U);
  case 2400: 
#line 184
  return (11U);
  case 4800: 
#line 186
  return (12U);
  case 9600: 
#line 188
  return (13U);
  case 19200: 
#line 192
  return (14U);
  case 38400: 
#line 202
  return (15U);
  case 57600: 
#line 224
  return (4097U);
  case 115200: 
#line 232
  return (4098U);
  case 230400: 
#line 236
  return (4099U);
  default: ;
#line 239
  return (13U);
  }
}
}
#line 248 "ttymodes.c"
void tty_make_modes(int fd , struct termios *tiop ) 
{ struct termios tio ;
  int baud ;
  Buffer buf___1 ;
  int tty_op_ospeed ;
  int tty_op_ispeed ;
  void (*put_arg)(Buffer * , u_int  ) ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  speed_t tmp___2 ;
  speed_t tmp___3 ;
  u_int tmp___4 ;
  void *tmp___5 ;
  u_int tmp___6 ;
  void *tmp___7 ;

  {
#line 257
  buffer_init(& buf___1);
#line 258
  if (compat20) {
#line 259
    tty_op_ospeed = 129;
#line 260
    tty_op_ispeed = 128;
#line 261
    put_arg = & buffer_put_int;
  } else {
#line 263
    tty_op_ospeed = 193;
#line 264
    tty_op_ispeed = 192;
#line 265
    put_arg = (void (*)(Buffer * , u_int  ))(& buffer_put_char);
  }
#line 268
  if ((unsigned int )tiop == (unsigned int )((void *)0)) {
#line 269
    tmp___1 = tcgetattr(fd, & tio);
#line 269
    if (tmp___1 == -1) {
#line 270
      tmp = __errno_location();
#line 270
      tmp___0 = strerror(*tmp);
#line 270
      logit("tcgetattr: %.100s", tmp___0);
      goto end;
    }
  } else {
#line 274
    tio = *tiop;
  }
#line 277
  tmp___2 = cfgetospeed((struct termios  const  *)(& tio));
#line 277
  baud = speed_to_baud(tmp___2);
#line 278
  debug3("tty_make_modes: ospeed %d", baud);
#line 279
  buffer_put_char(& buf___1, tty_op_ospeed);
#line 280
  buffer_put_int(& buf___1, (unsigned int )baud);
#line 281
  tmp___3 = cfgetispeed((struct termios  const  *)(& tio));
#line 281
  baud = speed_to_baud(tmp___3);
#line 282
  debug3("tty_make_modes: ispeed %d", baud);
#line 283
  buffer_put_char(& buf___1, tty_op_ispeed);
#line 284
  buffer_put_int(& buf___1, (unsigned int )baud);
#line 70 "ttymodes.h"
  debug3("tty_make_modes: %d %d", 1, tio.c_cc[0]);
#line 70
  buffer_put_char(& buf___1, 1);
#line 70
  (*put_arg)(& buf___1, (unsigned int )tio.c_cc[0]);
#line 71
  debug3("tty_make_modes: %d %d", 2, tio.c_cc[1]);
#line 71
  buffer_put_char(& buf___1, 2);
#line 71
  (*put_arg)(& buf___1, (unsigned int )tio.c_cc[1]);
#line 72
  debug3("tty_make_modes: %d %d", 3, tio.c_cc[2]);
#line 72
  buffer_put_char(& buf___1, 3);
#line 72
  (*put_arg)(& buf___1, (unsigned int )tio.c_cc[2]);
#line 74
  debug3("tty_make_modes: %d %d", 4, tio.c_cc[3]);
#line 74
  buffer_put_char(& buf___1, 4);
#line 74
  (*put_arg)(& buf___1, (unsigned int )tio.c_cc[3]);
#line 76
  debug3("tty_make_modes: %d %d", 5, tio.c_cc[4]);
#line 76
  buffer_put_char(& buf___1, 5);
#line 76
  (*put_arg)(& buf___1, (unsigned int )tio.c_cc[4]);
#line 78
  debug3("tty_make_modes: %d %d", 6, tio.c_cc[11]);
#line 78
  buffer_put_char(& buf___1, 6);
#line 78
  (*put_arg)(& buf___1, (unsigned int )tio.c_cc[11]);
#line 81
  debug3("tty_make_modes: %d %d", 7, tio.c_cc[16]);
#line 81
  buffer_put_char(& buf___1, 7);
#line 81
  (*put_arg)(& buf___1, (unsigned int )tio.c_cc[16]);
#line 83
  debug3("tty_make_modes: %d %d", 8, tio.c_cc[8]);
#line 83
  buffer_put_char(& buf___1, 8);
#line 83
  (*put_arg)(& buf___1, (unsigned int )tio.c_cc[8]);
#line 84
  debug3("tty_make_modes: %d %d", 9, tio.c_cc[9]);
#line 84
  buffer_put_char(& buf___1, 9);
#line 84
  (*put_arg)(& buf___1, (unsigned int )tio.c_cc[9]);
#line 86
  debug3("tty_make_modes: %d %d", 10, tio.c_cc[10]);
#line 86
  buffer_put_char(& buf___1, 10);
#line 86
  (*put_arg)(& buf___1, (unsigned int )tio.c_cc[10]);
#line 92
  debug3("tty_make_modes: %d %d", 12, tio.c_cc[12]);
#line 92
  buffer_put_char(& buf___1, 12);
#line 92
  (*put_arg)(& buf___1, (unsigned int )tio.c_cc[12]);
#line 95
  debug3("tty_make_modes: %d %d", 13, tio.c_cc[14]);
#line 95
  buffer_put_char(& buf___1, 13);
#line 95
  (*put_arg)(& buf___1, (unsigned int )tio.c_cc[14]);
#line 98
  debug3("tty_make_modes: %d %d", 14, tio.c_cc[15]);
#line 98
  buffer_put_char(& buf___1, 14);
#line 98
  (*put_arg)(& buf___1, (unsigned int )tio.c_cc[15]);
#line 110
  debug3("tty_make_modes: %d %d", 18, tio.c_cc[13]);
#line 110
  buffer_put_char(& buf___1, 18);
#line 110
  (*put_arg)(& buf___1, (unsigned int )tio.c_cc[13]);
#line 114
  debug3("tty_make_modes: %d %d", 30, (tio.c_iflag & 4U) != 0U);
#line 114
  buffer_put_char(& buf___1, 30);
#line 114
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 4U) != 0U));
#line 115
  debug3("tty_make_modes: %d %d", 31, (tio.c_iflag & 8U) != 0U);
#line 115
  buffer_put_char(& buf___1, 31);
#line 115
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 8U) != 0U));
#line 116
  debug3("tty_make_modes: %d %d", 32, (tio.c_iflag & 16U) != 0U);
#line 116
  buffer_put_char(& buf___1, 32);
#line 116
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 16U) != 0U));
#line 117
  debug3("tty_make_modes: %d %d", 33, (tio.c_iflag & 32U) != 0U);
#line 117
  buffer_put_char(& buf___1, 33);
#line 117
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 32U) != 0U));
#line 118
  debug3("tty_make_modes: %d %d", 34, (tio.c_iflag & 64U) != 0U);
#line 118
  buffer_put_char(& buf___1, 34);
#line 118
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 64U) != 0U));
#line 119
  debug3("tty_make_modes: %d %d", 35, (tio.c_iflag & 128U) != 0U);
#line 119
  buffer_put_char(& buf___1, 35);
#line 119
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 128U) != 0U));
#line 120
  debug3("tty_make_modes: %d %d", 36, (tio.c_iflag & 256U) != 0U);
#line 120
  buffer_put_char(& buf___1, 36);
#line 120
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 256U) != 0U));
#line 122
  debug3("tty_make_modes: %d %d", 37, (tio.c_iflag & 512U) != 0U);
#line 122
  buffer_put_char(& buf___1, 37);
#line 122
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 512U) != 0U));
#line 124
  debug3("tty_make_modes: %d %d", 38, (tio.c_iflag & 1024U) != 0U);
#line 124
  buffer_put_char(& buf___1, 38);
#line 124
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 1024U) != 0U));
#line 125
  debug3("tty_make_modes: %d %d", 39, (tio.c_iflag & 2048U) != 0U);
#line 125
  buffer_put_char(& buf___1, 39);
#line 125
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 2048U) != 0U));
#line 126
  debug3("tty_make_modes: %d %d", 40, (tio.c_iflag & 4096U) != 0U);
#line 126
  buffer_put_char(& buf___1, 40);
#line 126
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 4096U) != 0U));
#line 128
  debug3("tty_make_modes: %d %d", 41, (tio.c_iflag & 8192U) != 0U);
#line 128
  buffer_put_char(& buf___1, 41);
#line 128
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 8192U) != 0U));
#line 131
  debug3("tty_make_modes: %d %d", 50, (tio.c_lflag & 1U) != 0U);
#line 131
  buffer_put_char(& buf___1, 50);
#line 131
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 1U) != 0U));
#line 132
  debug3("tty_make_modes: %d %d", 51, (tio.c_lflag & 2U) != 0U);
#line 132
  buffer_put_char(& buf___1, 51);
#line 132
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 2U) != 0U));
#line 134
  debug3("tty_make_modes: %d %d", 52, (tio.c_lflag & 4U) != 0U);
#line 134
  buffer_put_char(& buf___1, 52);
#line 134
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 4U) != 0U));
#line 136
  debug3("tty_make_modes: %d %d", 53, (tio.c_lflag & 8U) != 0U);
#line 136
  buffer_put_char(& buf___1, 53);
#line 136
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 8U) != 0U));
#line 137
  debug3("tty_make_modes: %d %d", 54, (tio.c_lflag & 16U) != 0U);
#line 137
  buffer_put_char(& buf___1, 54);
#line 137
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 16U) != 0U));
#line 138
  debug3("tty_make_modes: %d %d", 55, (tio.c_lflag & 32U) != 0U);
#line 138
  buffer_put_char(& buf___1, 55);
#line 138
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 32U) != 0U));
#line 139
  debug3("tty_make_modes: %d %d", 56, (tio.c_lflag & 64U) != 0U);
#line 139
  buffer_put_char(& buf___1, 56);
#line 139
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 64U) != 0U));
#line 140
  debug3("tty_make_modes: %d %d", 57, (tio.c_lflag & 128U) != 0U);
#line 140
  buffer_put_char(& buf___1, 57);
#line 140
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 128U) != 0U));
#line 141
  debug3("tty_make_modes: %d %d", 58, (tio.c_lflag & 256U) != 0U);
#line 141
  buffer_put_char(& buf___1, 58);
#line 141
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 256U) != 0U));
#line 143
  debug3("tty_make_modes: %d %d", 59, (tio.c_lflag & 32768U) != 0U);
#line 143
  buffer_put_char(& buf___1, 59);
#line 143
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 32768U) != 0U));
#line 146
  debug3("tty_make_modes: %d %d", 60, (tio.c_lflag & 512U) != 0U);
#line 146
  buffer_put_char(& buf___1, 60);
#line 146
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 512U) != 0U));
#line 149
  debug3("tty_make_modes: %d %d", 61, (tio.c_lflag & 2048U) != 0U);
#line 149
  buffer_put_char(& buf___1, 61);
#line 149
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 2048U) != 0U));
#line 152
  debug3("tty_make_modes: %d %d", 62, (tio.c_lflag & 16384U) != 0U);
#line 152
  buffer_put_char(& buf___1, 62);
#line 152
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 16384U) != 0U));
#line 155
  debug3("tty_make_modes: %d %d", 70, (tio.c_oflag & 1U) != 0U);
#line 155
  buffer_put_char(& buf___1, 70);
#line 155
  (*put_arg)(& buf___1, (unsigned int )((tio.c_oflag & 1U) != 0U));
#line 157
  debug3("tty_make_modes: %d %d", 71, (tio.c_oflag & 2U) != 0U);
#line 157
  buffer_put_char(& buf___1, 71);
#line 157
  (*put_arg)(& buf___1, (unsigned int )((tio.c_oflag & 2U) != 0U));
#line 160
  debug3("tty_make_modes: %d %d", 72, (tio.c_oflag & 4U) != 0U);
#line 160
  buffer_put_char(& buf___1, 72);
#line 160
  (*put_arg)(& buf___1, (unsigned int )((tio.c_oflag & 4U) != 0U));
#line 163
  debug3("tty_make_modes: %d %d", 73, (tio.c_oflag & 8U) != 0U);
#line 163
  buffer_put_char(& buf___1, 73);
#line 163
  (*put_arg)(& buf___1, (unsigned int )((tio.c_oflag & 8U) != 0U));
#line 166
  debug3("tty_make_modes: %d %d", 74, (tio.c_oflag & 16U) != 0U);
#line 166
  buffer_put_char(& buf___1, 74);
#line 166
  (*put_arg)(& buf___1, (unsigned int )((tio.c_oflag & 16U) != 0U));
#line 169
  debug3("tty_make_modes: %d %d", 75, (tio.c_oflag & 32U) != 0U);
#line 169
  buffer_put_char(& buf___1, 75);
#line 169
  (*put_arg)(& buf___1, (unsigned int )((tio.c_oflag & 32U) != 0U));
#line 172
  debug3("tty_make_modes: %d %d", 90, (tio.c_cflag & 32U) != 0U);
#line 172
  buffer_put_char(& buf___1, 90);
#line 172
  (*put_arg)(& buf___1, (unsigned int )((tio.c_cflag & 32U) != 0U));
#line 173
  debug3("tty_make_modes: %d %d", 91, (tio.c_cflag & 48U) != 0U);
#line 173
  buffer_put_char(& buf___1, 91);
#line 173
  (*put_arg)(& buf___1, (unsigned int )((tio.c_cflag & 48U) != 0U));
#line 174
  debug3("tty_make_modes: %d %d", 92, (tio.c_cflag & 256U) != 0U);
#line 174
  buffer_put_char(& buf___1, 92);
#line 174
  (*put_arg)(& buf___1, (unsigned int )((tio.c_cflag & 256U) != 0U));
#line 175
  debug3("tty_make_modes: %d %d", 93, (tio.c_cflag & 512U) != 0U);
#line 175
  buffer_put_char(& buf___1, 93);
#line 175
  (*put_arg)(& buf___1, (unsigned int )((tio.c_cflag & 512U) != 0U));
  end: 
#line 304 "ttymodes.c"
  buffer_put_char(& buf___1, 0);
#line 305
  if (compat20) {
#line 306
    tmp___4 = buffer_len(& buf___1);
#line 306
    tmp___5 = buffer_ptr(& buf___1);
#line 306
    packet_put_string((void const   *)tmp___5, tmp___4);
  } else {
#line 308
    tmp___6 = buffer_len(& buf___1);
#line 308
    tmp___7 = buffer_ptr(& buf___1);
#line 308
    packet_put_raw((void const   *)tmp___7, tmp___6);
  }
#line 309
  buffer_free(& buf___1);
#line 310
  return;
}
}
#line 316 "ttymodes.c"
void tty_parse_modes(int fd , int *n_bytes_ptr ) 
{ struct termios tio ;
  int opcode ;
  int baud ;
  int n_bytes ;
  int failure ;
  u_int (*get_arg)(void) ;
  int arg ;
  int arg_size ;
  u_int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  u_int tmp___3 ;
  u_int tmp___4 ;
  speed_t tmp___5 ;
  int tmp___6 ;
  u_int tmp___7 ;
  speed_t tmp___8 ;
  int tmp___9 ;
  u_int tmp___10 ;
  u_int tmp___11 ;
  u_int tmp___12 ;
  u_int tmp___13 ;
  u_int tmp___14 ;
  u_int tmp___15 ;
  u_int tmp___16 ;
  u_int tmp___17 ;
  u_int tmp___18 ;
  u_int tmp___19 ;
  u_int tmp___20 ;
  u_int tmp___21 ;
  u_int tmp___22 ;
  u_int tmp___23 ;
  u_int tmp___24 ;
  u_int tmp___25 ;
  u_int tmp___26 ;
  u_int tmp___27 ;
  u_int tmp___28 ;
  u_int tmp___29 ;
  u_int tmp___30 ;
  u_int tmp___31 ;
  u_int tmp___32 ;
  u_int tmp___33 ;
  u_int tmp___34 ;
  u_int tmp___35 ;
  u_int tmp___36 ;
  u_int tmp___37 ;
  u_int tmp___38 ;
  u_int tmp___39 ;
  u_int tmp___40 ;
  u_int tmp___41 ;
  u_int tmp___42 ;
  u_int tmp___43 ;
  u_int tmp___44 ;
  u_int tmp___45 ;
  u_int tmp___46 ;
  u_int tmp___47 ;
  u_int tmp___48 ;
  u_int tmp___49 ;
  u_int tmp___50 ;
  u_int tmp___51 ;
  u_int tmp___52 ;
  u_int tmp___53 ;
  u_int tmp___54 ;
  u_int tmp___55 ;
  u_int tmp___56 ;
  u_int tmp___57 ;
  u_int tmp___58 ;
  int *tmp___59 ;
  char *tmp___60 ;
  int tmp___61 ;

  {
#line 321
  n_bytes = 0;
#line 322
  failure = 0;
#line 326
  if (compat20) {
#line 327
    tmp = packet_get_int();
#line 327
    *n_bytes_ptr = (int )tmp;
#line 328
    debug3("tty_parse_modes: SSH2 n_bytes %d", *n_bytes_ptr);
#line 329
    if (*n_bytes_ptr == 0) {
#line 330
      return;
    }
#line 331
    get_arg = & packet_get_int;
#line 332
    arg_size = 4;
  } else {
#line 334
    get_arg = & packet_get_char;
#line 335
    arg_size = 1;
  }
#line 343
  tmp___2 = tcgetattr(fd, & tio);
#line 343
  if (tmp___2 == -1) {
#line 344
    tmp___0 = __errno_location();
#line 344
    tmp___1 = strerror(*tmp___0);
#line 344
    logit("tcgetattr: %.100s", tmp___1);
#line 345
    failure = -1;
  }
#line 348
  while (1) {
#line 349
    n_bytes ++;
#line 350
    tmp___3 = packet_get_char();
#line 350
    opcode = (int )tmp___3;
#line 351
    switch (opcode) {
    case 0: 
    goto set;
    case 192: 
    case 128: 
#line 358
    n_bytes += 4;
#line 359
    tmp___4 = packet_get_int();
#line 359
    baud = (int )tmp___4;
#line 360
    debug3("tty_parse_modes: ispeed %d", baud);
#line 361
    if (failure != -1) {
#line 361
      tmp___5 = baud_to_speed(baud);
#line 361
      tmp___6 = cfsetispeed(& tio, tmp___5);
#line 361
      if (tmp___6 == -1) {
#line 362
        error("cfsetispeed failed for %d", baud);
      }
    }
#line 363
    break;
    case 193: 
    case 129: 
#line 368
    n_bytes += 4;
#line 369
    tmp___7 = packet_get_int();
#line 369
    baud = (int )tmp___7;
#line 370
    debug3("tty_parse_modes: ospeed %d", baud);
#line 371
    if (failure != -1) {
#line 371
      tmp___8 = baud_to_speed(baud);
#line 371
      tmp___9 = cfsetospeed(& tio, tmp___8);
#line 371
      if (tmp___9 == -1) {
#line 372
        error("cfsetospeed failed for %d", baud);
      }
    }
#line 373
    break;
    case 1: 
#line 70 "ttymodes.h"
    n_bytes += arg_size;
#line 70
    tmp___10 = (*get_arg)();
#line 70
    tio.c_cc[0] = (unsigned char )tmp___10;
#line 70
    debug3("tty_parse_modes: %d %d", 1, tio.c_cc[0]);
#line 70
    break;
    case 2: 
#line 71
    n_bytes += arg_size;
#line 71
    tmp___11 = (*get_arg)();
#line 71
    tio.c_cc[1] = (unsigned char )tmp___11;
#line 71
    debug3("tty_parse_modes: %d %d", 2, tio.c_cc[1]);
#line 71
    break;
    case 3: 
#line 72
    n_bytes += arg_size;
#line 72
    tmp___12 = (*get_arg)();
#line 72
    tio.c_cc[2] = (unsigned char )tmp___12;
#line 72
    debug3("tty_parse_modes: %d %d", 3, tio.c_cc[2]);
#line 72
    break;
    case 4: 
#line 74
    n_bytes += arg_size;
#line 74
    tmp___13 = (*get_arg)();
#line 74
    tio.c_cc[3] = (unsigned char )tmp___13;
#line 74
    debug3("tty_parse_modes: %d %d", 4, tio.c_cc[3]);
#line 74
    break;
    case 5: 
#line 76
    n_bytes += arg_size;
#line 76
    tmp___14 = (*get_arg)();
#line 76
    tio.c_cc[4] = (unsigned char )tmp___14;
#line 76
    debug3("tty_parse_modes: %d %d", 5, tio.c_cc[4]);
#line 76
    break;
    case 6: 
#line 78
    n_bytes += arg_size;
#line 78
    tmp___15 = (*get_arg)();
#line 78
    tio.c_cc[11] = (unsigned char )tmp___15;
#line 78
    debug3("tty_parse_modes: %d %d", 6, tio.c_cc[11]);
#line 78
    break;
    case 7: 
#line 81
    n_bytes += arg_size;
#line 81
    tmp___16 = (*get_arg)();
#line 81
    tio.c_cc[16] = (unsigned char )tmp___16;
#line 81
    debug3("tty_parse_modes: %d %d", 7, tio.c_cc[16]);
#line 81
    break;
    case 8: 
#line 83
    n_bytes += arg_size;
#line 83
    tmp___17 = (*get_arg)();
#line 83
    tio.c_cc[8] = (unsigned char )tmp___17;
#line 83
    debug3("tty_parse_modes: %d %d", 8, tio.c_cc[8]);
#line 83
    break;
    case 9: 
#line 84
    n_bytes += arg_size;
#line 84
    tmp___18 = (*get_arg)();
#line 84
    tio.c_cc[9] = (unsigned char )tmp___18;
#line 84
    debug3("tty_parse_modes: %d %d", 9, tio.c_cc[9]);
#line 84
    break;
    case 10: 
#line 86
    n_bytes += arg_size;
#line 86
    tmp___19 = (*get_arg)();
#line 86
    tio.c_cc[10] = (unsigned char )tmp___19;
#line 86
    debug3("tty_parse_modes: %d %d", 10, tio.c_cc[10]);
#line 86
    break;
    case 12: 
#line 92
    n_bytes += arg_size;
#line 92
    tmp___20 = (*get_arg)();
#line 92
    tio.c_cc[12] = (unsigned char )tmp___20;
#line 92
    debug3("tty_parse_modes: %d %d", 12, tio.c_cc[12]);
#line 92
    break;
    case 13: 
#line 95
    n_bytes += arg_size;
#line 95
    tmp___21 = (*get_arg)();
#line 95
    tio.c_cc[14] = (unsigned char )tmp___21;
#line 95
    debug3("tty_parse_modes: %d %d", 13, tio.c_cc[14]);
#line 95
    break;
    case 14: 
#line 98
    n_bytes += arg_size;
#line 98
    tmp___22 = (*get_arg)();
#line 98
    tio.c_cc[15] = (unsigned char )tmp___22;
#line 98
    debug3("tty_parse_modes: %d %d", 14, tio.c_cc[15]);
#line 98
    break;
    case 18: 
#line 110
    n_bytes += arg_size;
#line 110
    tmp___23 = (*get_arg)();
#line 110
    tio.c_cc[13] = (unsigned char )tmp___23;
#line 110
    debug3("tty_parse_modes: %d %d", 18, tio.c_cc[13]);
#line 110
    break;
    case 30: 
#line 114
    n_bytes += arg_size;
#line 114
    tmp___24 = (*get_arg)();
#line 114
    arg = (int )tmp___24;
#line 114
    if (arg) {
#line 114
      tio.c_iflag |= 4U;
    } else {
#line 114
      tio.c_iflag &= 4294967291U;
    }
#line 114
    debug3("tty_parse_modes: %d %d", 30, arg);
#line 114
    break;
    case 31: 
#line 115
    n_bytes += arg_size;
#line 115
    tmp___25 = (*get_arg)();
#line 115
    arg = (int )tmp___25;
#line 115
    if (arg) {
#line 115
      tio.c_iflag |= 8U;
    } else {
#line 115
      tio.c_iflag &= 4294967287U;
    }
#line 115
    debug3("tty_parse_modes: %d %d", 31, arg);
#line 115
    break;
    case 32: 
#line 116
    n_bytes += arg_size;
#line 116
    tmp___26 = (*get_arg)();
#line 116
    arg = (int )tmp___26;
#line 116
    if (arg) {
#line 116
      tio.c_iflag |= 16U;
    } else {
#line 116
      tio.c_iflag &= 4294967279U;
    }
#line 116
    debug3("tty_parse_modes: %d %d", 32, arg);
#line 116
    break;
    case 33: 
#line 117
    n_bytes += arg_size;
#line 117
    tmp___27 = (*get_arg)();
#line 117
    arg = (int )tmp___27;
#line 117
    if (arg) {
#line 117
      tio.c_iflag |= 32U;
    } else {
#line 117
      tio.c_iflag &= 4294967263U;
    }
#line 117
    debug3("tty_parse_modes: %d %d", 33, arg);
#line 117
    break;
    case 34: 
#line 118
    n_bytes += arg_size;
#line 118
    tmp___28 = (*get_arg)();
#line 118
    arg = (int )tmp___28;
#line 118
    if (arg) {
#line 118
      tio.c_iflag |= 64U;
    } else {
#line 118
      tio.c_iflag &= 4294967231U;
    }
#line 118
    debug3("tty_parse_modes: %d %d", 34, arg);
#line 118
    break;
    case 35: 
#line 119
    n_bytes += arg_size;
#line 119
    tmp___29 = (*get_arg)();
#line 119
    arg = (int )tmp___29;
#line 119
    if (arg) {
#line 119
      tio.c_iflag |= 128U;
    } else {
#line 119
      tio.c_iflag &= 4294967167U;
    }
#line 119
    debug3("tty_parse_modes: %d %d", 35, arg);
#line 119
    break;
    case 36: 
#line 120
    n_bytes += arg_size;
#line 120
    tmp___30 = (*get_arg)();
#line 120
    arg = (int )tmp___30;
#line 120
    if (arg) {
#line 120
      tio.c_iflag |= 256U;
    } else {
#line 120
      tio.c_iflag &= 4294967039U;
    }
#line 120
    debug3("tty_parse_modes: %d %d", 36, arg);
#line 120
    break;
    case 37: 
#line 122
    n_bytes += arg_size;
#line 122
    tmp___31 = (*get_arg)();
#line 122
    arg = (int )tmp___31;
#line 122
    if (arg) {
#line 122
      tio.c_iflag |= 512U;
    } else {
#line 122
      tio.c_iflag &= 4294966783U;
    }
#line 122
    debug3("tty_parse_modes: %d %d", 37, arg);
#line 122
    break;
    case 38: 
#line 124
    n_bytes += arg_size;
#line 124
    tmp___32 = (*get_arg)();
#line 124
    arg = (int )tmp___32;
#line 124
    if (arg) {
#line 124
      tio.c_iflag |= 1024U;
    } else {
#line 124
      tio.c_iflag &= 4294966271U;
    }
#line 124
    debug3("tty_parse_modes: %d %d", 38, arg);
#line 124
    break;
    case 39: 
#line 125
    n_bytes += arg_size;
#line 125
    tmp___33 = (*get_arg)();
#line 125
    arg = (int )tmp___33;
#line 125
    if (arg) {
#line 125
      tio.c_iflag |= 2048U;
    } else {
#line 125
      tio.c_iflag &= 4294965247U;
    }
#line 125
    debug3("tty_parse_modes: %d %d", 39, arg);
#line 125
    break;
    case 40: 
#line 126
    n_bytes += arg_size;
#line 126
    tmp___34 = (*get_arg)();
#line 126
    arg = (int )tmp___34;
#line 126
    if (arg) {
#line 126
      tio.c_iflag |= 4096U;
    } else {
#line 126
      tio.c_iflag &= 4294963199U;
    }
#line 126
    debug3("tty_parse_modes: %d %d", 40, arg);
#line 126
    break;
    case 41: 
#line 128
    n_bytes += arg_size;
#line 128
    tmp___35 = (*get_arg)();
#line 128
    arg = (int )tmp___35;
#line 128
    if (arg) {
#line 128
      tio.c_iflag |= 8192U;
    } else {
#line 128
      tio.c_iflag &= 4294959103U;
    }
#line 128
    debug3("tty_parse_modes: %d %d", 41, arg);
#line 128
    break;
    case 50: 
#line 131
    n_bytes += arg_size;
#line 131
    tmp___36 = (*get_arg)();
#line 131
    arg = (int )tmp___36;
#line 131
    if (arg) {
#line 131
      tio.c_lflag |= 1U;
    } else {
#line 131
      tio.c_lflag &= 4294967294U;
    }
#line 131
    debug3("tty_parse_modes: %d %d", 50, arg);
#line 131
    break;
    case 51: 
#line 132
    n_bytes += arg_size;
#line 132
    tmp___37 = (*get_arg)();
#line 132
    arg = (int )tmp___37;
#line 132
    if (arg) {
#line 132
      tio.c_lflag |= 2U;
    } else {
#line 132
      tio.c_lflag &= 4294967293U;
    }
#line 132
    debug3("tty_parse_modes: %d %d", 51, arg);
#line 132
    break;
    case 52: 
#line 134
    n_bytes += arg_size;
#line 134
    tmp___38 = (*get_arg)();
#line 134
    arg = (int )tmp___38;
#line 134
    if (arg) {
#line 134
      tio.c_lflag |= 4U;
    } else {
#line 134
      tio.c_lflag &= 4294967291U;
    }
#line 134
    debug3("tty_parse_modes: %d %d", 52, arg);
#line 134
    break;
    case 53: 
#line 136
    n_bytes += arg_size;
#line 136
    tmp___39 = (*get_arg)();
#line 136
    arg = (int )tmp___39;
#line 136
    if (arg) {
#line 136
      tio.c_lflag |= 8U;
    } else {
#line 136
      tio.c_lflag &= 4294967287U;
    }
#line 136
    debug3("tty_parse_modes: %d %d", 53, arg);
#line 136
    break;
    case 54: 
#line 137
    n_bytes += arg_size;
#line 137
    tmp___40 = (*get_arg)();
#line 137
    arg = (int )tmp___40;
#line 137
    if (arg) {
#line 137
      tio.c_lflag |= 16U;
    } else {
#line 137
      tio.c_lflag &= 4294967279U;
    }
#line 137
    debug3("tty_parse_modes: %d %d", 54, arg);
#line 137
    break;
    case 55: 
#line 138
    n_bytes += arg_size;
#line 138
    tmp___41 = (*get_arg)();
#line 138
    arg = (int )tmp___41;
#line 138
    if (arg) {
#line 138
      tio.c_lflag |= 32U;
    } else {
#line 138
      tio.c_lflag &= 4294967263U;
    }
#line 138
    debug3("tty_parse_modes: %d %d", 55, arg);
#line 138
    break;
    case 56: 
#line 139
    n_bytes += arg_size;
#line 139
    tmp___42 = (*get_arg)();
#line 139
    arg = (int )tmp___42;
#line 139
    if (arg) {
#line 139
      tio.c_lflag |= 64U;
    } else {
#line 139
      tio.c_lflag &= 4294967231U;
    }
#line 139
    debug3("tty_parse_modes: %d %d", 56, arg);
#line 139
    break;
    case 57: 
#line 140
    n_bytes += arg_size;
#line 140
    tmp___43 = (*get_arg)();
#line 140
    arg = (int )tmp___43;
#line 140
    if (arg) {
#line 140
      tio.c_lflag |= 128U;
    } else {
#line 140
      tio.c_lflag &= 4294967167U;
    }
#line 140
    debug3("tty_parse_modes: %d %d", 57, arg);
#line 140
    break;
    case 58: 
#line 141
    n_bytes += arg_size;
#line 141
    tmp___44 = (*get_arg)();
#line 141
    arg = (int )tmp___44;
#line 141
    if (arg) {
#line 141
      tio.c_lflag |= 256U;
    } else {
#line 141
      tio.c_lflag &= 4294967039U;
    }
#line 141
    debug3("tty_parse_modes: %d %d", 58, arg);
#line 141
    break;
    case 59: 
#line 143
    n_bytes += arg_size;
#line 143
    tmp___45 = (*get_arg)();
#line 143
    arg = (int )tmp___45;
#line 143
    if (arg) {
#line 143
      tio.c_lflag |= 32768U;
    } else {
#line 143
      tio.c_lflag &= 4294934527U;
    }
#line 143
    debug3("tty_parse_modes: %d %d", 59, arg);
#line 143
    break;
    case 60: 
#line 146
    n_bytes += arg_size;
#line 146
    tmp___46 = (*get_arg)();
#line 146
    arg = (int )tmp___46;
#line 146
    if (arg) {
#line 146
      tio.c_lflag |= 512U;
    } else {
#line 146
      tio.c_lflag &= 4294966783U;
    }
#line 146
    debug3("tty_parse_modes: %d %d", 60, arg);
#line 146
    break;
    case 61: 
#line 149
    n_bytes += arg_size;
#line 149
    tmp___47 = (*get_arg)();
#line 149
    arg = (int )tmp___47;
#line 149
    if (arg) {
#line 149
      tio.c_lflag |= 2048U;
    } else {
#line 149
      tio.c_lflag &= 4294965247U;
    }
#line 149
    debug3("tty_parse_modes: %d %d", 61, arg);
#line 149
    break;
    case 62: 
#line 152
    n_bytes += arg_size;
#line 152
    tmp___48 = (*get_arg)();
#line 152
    arg = (int )tmp___48;
#line 152
    if (arg) {
#line 152
      tio.c_lflag |= 16384U;
    } else {
#line 152
      tio.c_lflag &= 4294950911U;
    }
#line 152
    debug3("tty_parse_modes: %d %d", 62, arg);
#line 152
    break;
    case 70: 
#line 155
    n_bytes += arg_size;
#line 155
    tmp___49 = (*get_arg)();
#line 155
    arg = (int )tmp___49;
#line 155
    if (arg) {
#line 155
      tio.c_oflag |= 1U;
    } else {
#line 155
      tio.c_oflag &= 4294967294U;
    }
#line 155
    debug3("tty_parse_modes: %d %d", 70, arg);
#line 155
    break;
    case 71: 
#line 157
    n_bytes += arg_size;
#line 157
    tmp___50 = (*get_arg)();
#line 157
    arg = (int )tmp___50;
#line 157
    if (arg) {
#line 157
      tio.c_oflag |= 2U;
    } else {
#line 157
      tio.c_oflag &= 4294967293U;
    }
#line 157
    debug3("tty_parse_modes: %d %d", 71, arg);
#line 157
    break;
    case 72: 
#line 160
    n_bytes += arg_size;
#line 160
    tmp___51 = (*get_arg)();
#line 160
    arg = (int )tmp___51;
#line 160
    if (arg) {
#line 160
      tio.c_oflag |= 4U;
    } else {
#line 160
      tio.c_oflag &= 4294967291U;
    }
#line 160
    debug3("tty_parse_modes: %d %d", 72, arg);
#line 160
    break;
    case 73: 
#line 163
    n_bytes += arg_size;
#line 163
    tmp___52 = (*get_arg)();
#line 163
    arg = (int )tmp___52;
#line 163
    if (arg) {
#line 163
      tio.c_oflag |= 8U;
    } else {
#line 163
      tio.c_oflag &= 4294967287U;
    }
#line 163
    debug3("tty_parse_modes: %d %d", 73, arg);
#line 163
    break;
    case 74: 
#line 166
    n_bytes += arg_size;
#line 166
    tmp___53 = (*get_arg)();
#line 166
    arg = (int )tmp___53;
#line 166
    if (arg) {
#line 166
      tio.c_oflag |= 16U;
    } else {
#line 166
      tio.c_oflag &= 4294967279U;
    }
#line 166
    debug3("tty_parse_modes: %d %d", 74, arg);
#line 166
    break;
    case 75: 
#line 169
    n_bytes += arg_size;
#line 169
    tmp___54 = (*get_arg)();
#line 169
    arg = (int )tmp___54;
#line 169
    if (arg) {
#line 169
      tio.c_oflag |= 32U;
    } else {
#line 169
      tio.c_oflag &= 4294967263U;
    }
#line 169
    debug3("tty_parse_modes: %d %d", 75, arg);
#line 169
    break;
    case 90: 
#line 172
    n_bytes += arg_size;
#line 172
    tmp___55 = (*get_arg)();
#line 172
    arg = (int )tmp___55;
#line 172
    if (arg) {
#line 172
      tio.c_cflag |= 32U;
    } else {
#line 172
      tio.c_cflag &= 4294967263U;
    }
#line 172
    debug3("tty_parse_modes: %d %d", 90, arg);
#line 172
    break;
    case 91: 
#line 173
    n_bytes += arg_size;
#line 173
    tmp___56 = (*get_arg)();
#line 173
    arg = (int )tmp___56;
#line 173
    if (arg) {
#line 173
      tio.c_cflag |= 48U;
    } else {
#line 173
      tio.c_cflag &= 4294967247U;
    }
#line 173
    debug3("tty_parse_modes: %d %d", 91, arg);
#line 173
    break;
    case 92: 
#line 174
    n_bytes += arg_size;
#line 174
    tmp___57 = (*get_arg)();
#line 174
    arg = (int )tmp___57;
#line 174
    if (arg) {
#line 174
      tio.c_cflag |= 256U;
    } else {
#line 174
      tio.c_cflag &= 4294967039U;
    }
#line 174
    debug3("tty_parse_modes: %d %d", 92, arg);
#line 174
    break;
    case 93: 
#line 175
    n_bytes += arg_size;
#line 175
    tmp___58 = (*get_arg)();
#line 175
    arg = (int )tmp___58;
#line 175
    if (arg) {
#line 175
      tio.c_cflag |= 512U;
    } else {
#line 175
      tio.c_cflag &= 4294966783U;
    }
#line 175
    debug3("tty_parse_modes: %d %d", 93, arg);
#line 175
    break;
    default: 
#line 397 "ttymodes.c"
    debug("Ignoring unsupported tty mode opcode %d (0x%x)", opcode, opcode);
#line 399
    if (! compat20) {
#line 407
      if (opcode > 0) {
#line 407
        if (opcode < 128) {
#line 408
          n_bytes ++;
#line 409
          packet_get_char();
#line 410
          break;
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 411
        if (opcode >= 128) {
#line 411
          if (opcode < 160) {
#line 412
            n_bytes += 4;
#line 413
            packet_get_int();
#line 414
            break;
          } else {
#line 423
            logit("parse_tty_modes: unknown opcode %d", opcode);
            goto set;
          }
        } else {
#line 423
          logit("parse_tty_modes: unknown opcode %d", opcode);
          goto set;
        }
      }
    } else {
#line 434
      if (opcode > 0) {
#line 434
        if (opcode < 160) {
#line 435
          n_bytes += 4;
#line 436
          packet_get_int();
#line 437
          break;
        } else {
#line 439
          logit("parse_tty_modes: unknown opcode %d", opcode);
          goto set;
        }
      } else {
#line 439
        logit("parse_tty_modes: unknown opcode %d", opcode);
        goto set;
      }
    }
    }
  }
  set: 
#line 447
  if (*n_bytes_ptr != n_bytes) {
#line 448
    *n_bytes_ptr = n_bytes;
#line 449
    logit("parse_tty_modes: n_bytes_ptr != n_bytes: %d %d", *n_bytes_ptr, n_bytes);
#line 451
    return;
  }
#line 453
  if (failure == -1) {
#line 454
    return;
  }
#line 457
  tmp___61 = tcsetattr(fd, 0, (struct termios  const  *)(& tio));
#line 457
  if (tmp___61 == -1) {
#line 458
    tmp___59 = __errno_location();
#line 458
    tmp___60 = strerror(*tmp___59);
#line 458
    logit("Setting tty modes failed: %.100s", tmp___60);
  }
#line 459
  return;
}
}
#line 1 "xmalloc.o"
#line 21 "xmalloc.c"
void *xmalloc(size_t size ) 
{ void *ptr ;

  {
#line 26
  if (size == 0U) {
#line 27
    fatal("xmalloc: zero size");
  }
#line 28
  ptr = malloc(size);
#line 29
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 30
    fatal("xmalloc: out of memory (allocating %lu bytes)", (unsigned long )size);
  }
#line 31
  return (ptr);
}
}
#line 34 "xmalloc.c"
void *xrealloc(void *ptr , size_t new_size ) 
{ void *new_ptr ;

  {
#line 39
  if (new_size == 0U) {
#line 40
    fatal("xrealloc: zero size");
  }
#line 41
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 42
    new_ptr = malloc(new_size);
  } else {
#line 44
    new_ptr = realloc(ptr, new_size);
  }
#line 45
  if ((unsigned int )new_ptr == (unsigned int )((void *)0)) {
#line 46
    fatal("xrealloc: out of memory (new_size %lu bytes)", (unsigned long )new_size);
  }
#line 47
  return (new_ptr);
}
}
#line 50 "xmalloc.c"
void xfree(void *ptr ) 
{ 

  {
#line 53
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 54
    fatal("xfree: NULL pointer given as argument");
  }
#line 55
  free(ptr);
#line 56
  return;
}
}
#line 58 "xmalloc.c"
char *xstrdup(char const   *str ) 
{ size_t len ;
  char *cp ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 64
  tmp = strlen(str);
#line 64
  len = tmp + 1U;
#line 65
  tmp___0 = xmalloc(len);
#line 65
  cp = (char *)tmp___0;
#line 66
  strlcpy(cp, str, len);
#line 67
  return (cp);
}
}
#line 1 "atomicio.o"
#line 34 "atomicio.c"
ssize_t atomicio(ssize_t (*f)(int  , void * , size_t  ) , int fd , void *_s , size_t n___0 ) 
{ char *s ;
  ssize_t res ;
  ssize_t pos ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 41
  s = (char *)_s;
#line 42
  pos = 0;
#line 44
  while (n___0 > (size_t )pos) {
#line 45
    res = (*f)(fd, (void *)(s + pos), n___0 - (size_t )pos);
#line 46
    switch (res) {
    case -1: 
#line 49
    tmp = __errno_location();
#line 49
    if (*tmp == 4) {
#line 53
      continue;
    } else {
#line 49
      tmp___0 = __errno_location();
#line 49
      if (*tmp___0 == 11) {
#line 53
        continue;
      } else {
#line 49
        tmp___1 = __errno_location();
#line 49
        if (*tmp___1 == 11) {
#line 53
          continue;
        }
      }
    }
    case 0: 
#line 55
    return (res);
    default: 
#line 57
    pos += res;
    }
  }
#line 60
  return (pos);
}
}
#line 1 "key.o"
#line 470 "/usr/include/openssl/crypto.h"
extern void CRYPTO_free(void * ) ;
#line 457 "/usr/include/openssl/bn.h"
extern int BN_cmp(BIGNUM const   *a , BIGNUM const   *b ) ;
#line 491
extern BIGNUM *BN_dup(BIGNUM const   *a ) ;
#line 496
extern char *BN_bn2dec(BIGNUM const   *a ) ;
#line 498
extern int BN_dec2bn(BIGNUM **a , char const   *str ) ;
#line 491 "/usr/include/openssl/evp.h"
extern int EVP_DigestUpdate(EVP_MD_CTX *ctx , void const   *d , size_t cnt ) ;
#line 498
extern int EVP_DigestInit(EVP_MD_CTX *ctx , EVP_MD const   *type ) ;
#line 499
extern int EVP_DigestFinal(EVP_MD_CTX *ctx , unsigned char *md , unsigned int *s ) ;
#line 593
extern EVP_MD const   *EVP_md5(void) ;
#line 597
extern EVP_MD const   *EVP_sha1(void) ;
#line 215 "/usr/include/openssl/rsa.h"
extern RSA *RSA_new(void) ;
#line 221
extern RSA *RSA_generate_key(int bits , unsigned long e , void (*callback)(int  ,
                                                                           int  ,
                                                                           void * ) ,
                             void *cb_arg ) ;
#line 238
extern void RSA_free(RSA *r ) ;
#line 190 "/usr/include/openssl/dsa.h"
extern DSA *DSA_new(void) ;
#line 192
extern void DSA_free(DSA *r ) ;
#line 213
extern DSA *DSA_generate_parameters(int bits , unsigned char *seed , int seed_len ,
                                    int *counter_ret , unsigned long *h_ret , void (*callback)(int  ,
                                                                                               int  ,
                                                                                               void * ) ,
                                    void *cb_arg ) ;
#line 224
extern int DSA_generate_key(DSA *a ) ;
#line 61 "key.h"
Key *key_demote(Key const   *k ) ;
#line 63
char *key_fingerprint(Key const   *k , enum fp_type dgst_type , enum fp_rep dgst_rep ) ;
#line 64
u_char *key_fingerprint_raw(Key const   *k , enum fp_type dgst_type , u_int *dgst_raw_length ) ;
#line 70
Key *key_generate(int type , u_int bits ) ;
#line 71
Key *key_from_private(Key const   *k ) ;
#line 72
int key_type_from_name(char *name ) ;
#line 77
int key_names_valid2(char const   *names ) ;
#line 79
int key_sign(Key const   *key , u_char **sigp , u_int *lenp , u_char const   *data ,
             u_int datalen ) ;
#line 80
int key_verify(Key const   *key , u_char const   *signature , u_int signaturelen ,
               u_char const   *data , u_int datalen ) ;
#line 82
int ssh_dss_sign(Key const   *key , u_char **sigp , u_int *lenp , u_char const   *data ,
                 u_int datalen ) ;
#line 83
int ssh_dss_verify(Key const   *key , u_char const   *signature , u_int signaturelen ,
                   u_char const   *data , u_int datalen ) ;
#line 84
int ssh_rsa_sign(Key const   *key , u_char **sigp , u_int *lenp , u_char const   *data ,
                 u_int datalen ) ;
#line 85
int ssh_rsa_verify(Key const   *key , u_char const   *signature , u_int signaturelen ,
                   u_char const   *data , u_int datalen ) ;
#line 29 "uuencode.h"
int uuencode(u_char const   *src , u_int srclength , char *target , size_t targsize ) ;
#line 30
int uudecode(char const   *src , u_char *target , size_t targsize ) ;
#line 47 "key.c"
Key *key_new(int type ) 
{ Key *k ;
  RSA *rsa ;
  DSA *dsa ;
  void *tmp ;

  {
#line 53
  tmp = xmalloc(sizeof(*k));
#line 53
  k = (Key *)tmp;
#line 54
  k->type = type;
#line 55
  k->flags = 0;
#line 56
  k->dsa = (DSA *)((void *)0);
#line 57
  k->rsa = (RSA *)((void *)0);
#line 58
  switch (k->type) {
  case 0: 
  case 1: 
#line 61
  rsa = RSA_new();
#line 61
  if ((unsigned int )rsa == (unsigned int )((void *)0)) {
#line 62
    fatal("key_new: RSA_new failed");
  }
#line 63
  rsa->n = BN_new();
#line 63
  if ((unsigned int )rsa->n == (unsigned int )((void *)0)) {
#line 64
    fatal("key_new: BN_new failed");
  }
#line 65
  rsa->e = BN_new();
#line 65
  if ((unsigned int )rsa->e == (unsigned int )((void *)0)) {
#line 66
    fatal("key_new: BN_new failed");
  }
#line 67
  k->rsa = rsa;
#line 68
  break;
  case 2: 
#line 70
  dsa = DSA_new();
#line 70
  if ((unsigned int )dsa == (unsigned int )((void *)0)) {
#line 71
    fatal("key_new: DSA_new failed");
  }
#line 72
  dsa->p = BN_new();
#line 72
  if ((unsigned int )dsa->p == (unsigned int )((void *)0)) {
#line 73
    fatal("key_new: BN_new failed");
  }
#line 74
  dsa->q = BN_new();
#line 74
  if ((unsigned int )dsa->q == (unsigned int )((void *)0)) {
#line 75
    fatal("key_new: BN_new failed");
  }
#line 76
  dsa->g = BN_new();
#line 76
  if ((unsigned int )dsa->g == (unsigned int )((void *)0)) {
#line 77
    fatal("key_new: BN_new failed");
  }
#line 78
  dsa->pub_key = BN_new();
#line 78
  if ((unsigned int )dsa->pub_key == (unsigned int )((void *)0)) {
#line 79
    fatal("key_new: BN_new failed");
  }
#line 80
  k->dsa = dsa;
#line 81
  break;
  case 3: 
#line 83
  break;
  default: 
#line 85
  fatal("key_new: bad key type %d", k->type);
#line 86
  break;
  }
#line 88
  return (k);
}
}
#line 91 "key.c"
Key *key_new_private(int type ) 
{ Key *k ;
  Key *tmp ;

  {
#line 94
  tmp = key_new(type);
#line 94
  k = tmp;
#line 95
  switch (k->type) {
  case 0: 
  case 1: 
#line 98
  (k->rsa)->d = BN_new();
#line 98
  if ((unsigned int )(k->rsa)->d == (unsigned int )((void *)0)) {
#line 99
    fatal("key_new_private: BN_new failed");
  }
#line 100
  (k->rsa)->iqmp = BN_new();
#line 100
  if ((unsigned int )(k->rsa)->iqmp == (unsigned int )((void *)0)) {
#line 101
    fatal("key_new_private: BN_new failed");
  }
#line 102
  (k->rsa)->q = BN_new();
#line 102
  if ((unsigned int )(k->rsa)->q == (unsigned int )((void *)0)) {
#line 103
    fatal("key_new_private: BN_new failed");
  }
#line 104
  (k->rsa)->p = BN_new();
#line 104
  if ((unsigned int )(k->rsa)->p == (unsigned int )((void *)0)) {
#line 105
    fatal("key_new_private: BN_new failed");
  }
#line 106
  (k->rsa)->dmq1 = BN_new();
#line 106
  if ((unsigned int )(k->rsa)->dmq1 == (unsigned int )((void *)0)) {
#line 107
    fatal("key_new_private: BN_new failed");
  }
#line 108
  (k->rsa)->dmp1 = BN_new();
#line 108
  if ((unsigned int )(k->rsa)->dmp1 == (unsigned int )((void *)0)) {
#line 109
    fatal("key_new_private: BN_new failed");
  }
#line 110
  break;
  case 2: 
#line 112
  (k->dsa)->priv_key = BN_new();
#line 112
  if ((unsigned int )(k->dsa)->priv_key == (unsigned int )((void *)0)) {
#line 113
    fatal("key_new_private: BN_new failed");
  }
#line 114
  break;
  case 3: 
#line 116
  break;
  default: ;
#line 118
  break;
  }
#line 120
  return (k);
}
}
#line 123 "key.c"
void key_free(Key *k ) 
{ 

  {
#line 126
  switch (k->type) {
  case 0: 
  case 1: 
#line 129
  if ((unsigned int )k->rsa != (unsigned int )((void *)0)) {
#line 130
    RSA_free(k->rsa);
  }
#line 131
  k->rsa = (RSA *)((void *)0);
#line 132
  break;
  case 2: 
#line 134
  if ((unsigned int )k->dsa != (unsigned int )((void *)0)) {
#line 135
    DSA_free(k->dsa);
  }
#line 136
  k->dsa = (DSA *)((void *)0);
#line 137
  break;
  case 3: 
#line 139
  break;
  default: 
#line 141
  fatal("key_free: bad key type %d", k->type);
#line 142
  break;
  }
#line 144
  xfree((void *)k);
#line 145
  return;
}
}
#line 147 "key.c"
int key_equal(Key const   *a , Key const   *b ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 150
  if ((unsigned int )a == (unsigned int )((void *)0)) {
#line 151
    return (0);
  } else {
#line 150
    if ((unsigned int )b == (unsigned int )((void *)0)) {
#line 151
      return (0);
    } else {
#line 150
      if (a->type != b->type) {
#line 151
        return (0);
      }
    }
  }
#line 152
  switch ((int )a->type) {
  case 0: 
  case 1: 
#line 155
  if ((unsigned int )a->rsa != (unsigned int )((void *)0)) {
#line 155
    if ((unsigned int )b->rsa != (unsigned int )((void *)0)) {
#line 155
      tmp = BN_cmp((BIGNUM const   *)(a->rsa)->e, (BIGNUM const   *)(b->rsa)->e);
#line 155
      if (tmp == 0) {
#line 155
        tmp___0 = BN_cmp((BIGNUM const   *)(a->rsa)->n, (BIGNUM const   *)(b->rsa)->n);
#line 155
        if (tmp___0 == 0) {
#line 155
          tmp___1 = 1;
        } else {
#line 155
          tmp___1 = 0;
        }
      } else {
#line 155
        tmp___1 = 0;
      }
    } else {
#line 155
      tmp___1 = 0;
    }
  } else {
#line 155
    tmp___1 = 0;
  }
#line 155
  return (tmp___1);
#line 158
  break;
  case 2: 
#line 160
  if ((unsigned int )a->dsa != (unsigned int )((void *)0)) {
#line 160
    if ((unsigned int )b->dsa != (unsigned int )((void *)0)) {
#line 160
      tmp___2 = BN_cmp((BIGNUM const   *)(a->dsa)->p, (BIGNUM const   *)(b->dsa)->p);
#line 160
      if (tmp___2 == 0) {
#line 160
        tmp___3 = BN_cmp((BIGNUM const   *)(a->dsa)->q, (BIGNUM const   *)(b->dsa)->q);
#line 160
        if (tmp___3 == 0) {
#line 160
          tmp___4 = BN_cmp((BIGNUM const   *)(a->dsa)->g, (BIGNUM const   *)(b->dsa)->g);
#line 160
          if (tmp___4 == 0) {
#line 160
            tmp___5 = BN_cmp((BIGNUM const   *)(a->dsa)->pub_key, (BIGNUM const   *)(b->dsa)->pub_key);
#line 160
            if (tmp___5 == 0) {
#line 160
              tmp___6 = 1;
            } else {
#line 160
              tmp___6 = 0;
            }
          } else {
#line 160
            tmp___6 = 0;
          }
        } else {
#line 160
          tmp___6 = 0;
        }
      } else {
#line 160
        tmp___6 = 0;
      }
    } else {
#line 160
      tmp___6 = 0;
    }
  } else {
#line 160
    tmp___6 = 0;
  }
#line 160
  return (tmp___6);
#line 165
  break;
  default: 
#line 167
  fatal("key_equal: bad key type %d", a->type);
#line 168
  break;
  }
#line 170
  return (0);
}
}
#line 173 "key.c"
u_char *key_fingerprint_raw(Key const   *k , enum fp_type dgst_type , u_int *dgst_raw_length ) 
{ EVP_MD const   *md ;
  EVP_MD_CTX ctx ;
  u_char *blob ;
  u_char *retval ;
  u_int len ;
  int nlen ;
  int elen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 177
  md = (EVP_MD const   *)((void *)0);
#line 179
  blob = (u_char *)((void *)0);
#line 180
  retval = (u_char *)((void *)0);
#line 181
  len = (u_int )0;
#line 184
  *dgst_raw_length = 0U;
#line 186
  switch ((int )dgst_type) {
  case 1: 
#line 188
  md = EVP_md5();
#line 189
  break;
  case 0: 
#line 191
  md = EVP_sha1();
#line 192
  break;
  default: 
#line 194
  fatal("key_fingerprint_raw: bad digest type %d", dgst_type);
  }
#line 197
  switch ((int )k->type) {
  case 0: 
#line 199
  tmp = BN_num_bits((BIGNUM const   *)(k->rsa)->n);
#line 199
  nlen = (tmp + 7) / 8;
#line 200
  tmp___0 = BN_num_bits((BIGNUM const   *)(k->rsa)->e);
#line 200
  elen = (tmp___0 + 7) / 8;
#line 201
  len = (unsigned int )(nlen + elen);
#line 202
  tmp___1 = xmalloc(len);
#line 202
  blob = (u_char *)tmp___1;
#line 203
  BN_bn2bin((BIGNUM const   *)(k->rsa)->n, blob);
#line 204
  BN_bn2bin((BIGNUM const   *)(k->rsa)->e, blob + nlen);
#line 205
  break;
  case 2: 
  case 1: 
#line 208
  key_to_blob(k, & blob, & len);
#line 209
  break;
  case 3: 
#line 211
  return (retval);
#line 212
  break;
  default: 
#line 214
  fatal("key_fingerprint_raw: bad key type %d", k->type);
#line 215
  break;
  }
#line 217
  if ((unsigned int )blob != (unsigned int )((void *)0)) {
#line 218
    tmp___2 = xmalloc(64U);
#line 218
    retval = (u_char *)tmp___2;
#line 219
    EVP_DigestInit(& ctx, md);
#line 220
    EVP_DigestUpdate(& ctx, (void const   *)blob, len);
#line 221
    EVP_DigestFinal(& ctx, retval, dgst_raw_length);
#line 222
    memset((void *)blob, 0, len);
#line 223
    xfree((void *)blob);
  } else {
#line 225
    fatal("key_fingerprint_raw: blob is null");
  }
#line 227
  return (retval);
}
}
#line 230 "key.c"
static char *key_fingerprint_hex(u_char *dgst_raw , u_int dgst_raw_len ) 
{ char *retval ;
  int i ;
  void *tmp ;
  char hex[4] ;

  {
#line 236
  tmp = xmalloc(dgst_raw_len * 3U + 1U);
#line 236
  retval = (char *)tmp;
#line 237
  *(retval + 0) = (char )'\000';
#line 238
  i = 0;
#line 238
  while ((u_int )i < dgst_raw_len) {
#line 240
    snprintf((char * __restrict  )(hex), sizeof(hex), (char const   * __restrict  )"%02x:",
             *(dgst_raw + i));
#line 241
    strlcat(retval, (char const   *)(hex), dgst_raw_len * 3U + 1U);
#line 238
    i ++;
  }
#line 245
  *(retval + (dgst_raw_len * 3U - 1U)) = (char )'\000';
#line 246
  return (retval);
}
}
#line 249 "key.c"
static char *key_fingerprint_bubblebabble(u_char *dgst_raw , u_int dgst_raw_len ) 
{ char vowels[6] ;
  char consonants[17] ;
  u_int i ;
  u_int j ;
  u_int rounds ;
  u_int seed ;
  char *retval ;
  void *tmp ;
  u_int tmp___0 ;
  u_int idx0 ;
  u_int idx1 ;
  u_int idx2 ;
  u_int idx3 ;
  u_int idx4 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  u_int tmp___6 ;
  u_int tmp___7 ;
  u_int tmp___8 ;
  u_int tmp___9 ;
  u_int tmp___10 ;
  u_int tmp___11 ;

  {
#line 252
  vowels[0] = (char )'a';
#line 252
  vowels[1] = (char )'e';
#line 252
  vowels[2] = (char )'i';
#line 252
  vowels[3] = (char )'o';
#line 252
  vowels[4] = (char )'u';
#line 252
  vowels[5] = (char )'y';
#line 253
  consonants[0] = (char )'b';
#line 253
  consonants[1] = (char )'c';
#line 253
  consonants[2] = (char )'d';
#line 253
  consonants[3] = (char )'f';
#line 253
  consonants[4] = (char )'g';
#line 253
  consonants[5] = (char )'h';
#line 253
  consonants[6] = (char )'k';
#line 253
  consonants[7] = (char )'l';
#line 253
  consonants[8] = (char )'m';
#line 253
  consonants[9] = (char )'n';
#line 253
  consonants[10] = (char )'p';
#line 253
  consonants[11] = (char )'r';
#line 253
  consonants[12] = (char )'s';
#line 253
  consonants[13] = (char )'t';
#line 253
  consonants[14] = (char )'v';
#line 253
  consonants[15] = (char )'z';
#line 253
  consonants[16] = (char )'x';
#line 255
  j = (u_int )0;
#line 255
  seed = (u_int )1;
#line 258
  rounds = dgst_raw_len / 2U + 1U;
#line 259
  tmp = xmalloc(sizeof(char ) * (rounds * 6U));
#line 259
  retval = (char *)tmp;
#line 260
  tmp___0 = j;
#line 260
  j ++;
#line 260
  *(retval + tmp___0) = (char )'x';
#line 261
  i = 0U;
#line 261
  while (i < rounds) {
#line 263
    if (i + 1U < rounds) {
      goto _L;
    } else {
#line 263
      if (dgst_raw_len % 2U != 0U) {
        _L: /* CIL Label */ 
#line 264
        idx0 = ((((unsigned int )*(dgst_raw + 2U * i) >> 6) & 3U) + seed) % 6U;
#line 266
        idx1 = ((unsigned int )*(dgst_raw + 2U * i) >> 2) & 15U;
#line 267
        idx2 = (((unsigned int )*(dgst_raw + 2U * i) & 3U) + seed / 6U) % 6U;
#line 269
        tmp___1 = j;
#line 269
        j ++;
#line 269
        *(retval + tmp___1) = vowels[idx0];
#line 270
        tmp___2 = j;
#line 270
        j ++;
#line 270
        *(retval + tmp___2) = consonants[idx1];
#line 271
        tmp___3 = j;
#line 271
        j ++;
#line 271
        *(retval + tmp___3) = vowels[idx2];
#line 272
        if (i + 1U < rounds) {
#line 273
          idx3 = ((unsigned int )*(dgst_raw + (2U * i + 1U)) >> 4) & 15U;
#line 274
          idx4 = (unsigned int )*(dgst_raw + (2U * i + 1U)) & 15U;
#line 275
          tmp___4 = j;
#line 275
          j ++;
#line 275
          *(retval + tmp___4) = consonants[idx3];
#line 276
          tmp___5 = j;
#line 276
          j ++;
#line 276
          *(retval + tmp___5) = (char )'-';
#line 277
          tmp___6 = j;
#line 277
          j ++;
#line 277
          *(retval + tmp___6) = consonants[idx4];
#line 278
          seed = (seed * 5U + ((unsigned int )*(dgst_raw + 2U * i) * 7U + (unsigned int )*(dgst_raw + (2U * i + 1U)))) % 36U;
        }
      } else {
#line 283
        idx0 = seed % 6U;
#line 284
        idx1 = 16U;
#line 285
        idx2 = seed / 6U;
#line 286
        tmp___7 = j;
#line 286
        j ++;
#line 286
        *(retval + tmp___7) = vowels[idx0];
#line 287
        tmp___8 = j;
#line 287
        j ++;
#line 287
        *(retval + tmp___8) = consonants[idx1];
#line 288
        tmp___9 = j;
#line 288
        j ++;
#line 288
        *(retval + tmp___9) = vowels[idx2];
      }
    }
#line 261
    i ++;
  }
#line 291
  tmp___10 = j;
#line 291
  j ++;
#line 291
  *(retval + tmp___10) = (char )'x';
#line 292
  tmp___11 = j;
#line 292
  j ++;
#line 292
  *(retval + tmp___11) = (char )'\000';
#line 293
  return (retval);
}
}
#line 296 "key.c"
char *key_fingerprint(Key const   *k , enum fp_type dgst_type , enum fp_rep dgst_rep ) 
{ char *retval ;
  u_char *dgst_raw ;
  u_int dgst_raw_len ;

  {
#line 299
  retval = (char *)((void *)0);
#line 303
  dgst_raw = key_fingerprint_raw(k, dgst_type, & dgst_raw_len);
#line 304
  if (! dgst_raw) {
#line 305
    fatal("key_fingerprint: null from key_fingerprint_raw()");
  }
#line 306
  switch ((int )dgst_rep) {
  case 0: 
#line 308
  retval = key_fingerprint_hex(dgst_raw, dgst_raw_len);
#line 309
  break;
  case 1: 
#line 311
  retval = key_fingerprint_bubblebabble(dgst_raw, dgst_raw_len);
#line 312
  break;
  default: 
#line 314
  fatal("key_fingerprint_ex: bad digest representation %d", dgst_rep);
#line 316
  break;
  }
#line 318
  memset((void *)dgst_raw, 0, dgst_raw_len);
#line 319
  xfree((void *)dgst_raw);
#line 320
  return (retval);
}
}
#line 330 "key.c"
static int read_bignum(char **cpp , BIGNUM *value ) 
{ char *cp ;
  int old ;
  int tmp ;

  {
#line 333
  cp = *cpp;
#line 337
  while (1) {
#line 337
    if (! ((int )*cp == 32)) {
#line 337
      if (! ((int )*cp == 9)) {
#line 337
        break;
      }
    }
#line 337
    cp ++;
  }
#line 341
  if ((int )*cp < 48) {
#line 342
    return (0);
  } else {
#line 341
    if ((int )*cp > 57) {
#line 342
      return (0);
    }
  }
#line 345
  *cpp = cp;
#line 348
  while (1) {
#line 348
    if ((int )*cp >= 48) {
#line 348
      if (! ((int )*cp <= 57)) {
#line 348
        break;
      }
    } else {
#line 348
      break;
    }
#line 348
    cp ++;
  }
#line 352
  old = (int )*cp;
#line 353
  *cp = (char)0;
#line 356
  tmp = BN_dec2bn(& value, (char const   *)*cpp);
#line 356
  if (tmp == 0) {
#line 357
    return (0);
  }
#line 360
  *cp = (char )old;
#line 363
  *cpp = cp;
#line 364
  return (1);
}
}
#line 367 "key.c"
static int write_bignum(FILE *f , BIGNUM *num ) 
{ char *buf___1 ;
  char *tmp ;

  {
#line 370
  tmp = BN_bn2dec((BIGNUM const   *)num);
#line 370
  buf___1 = tmp;
#line 371
  if ((unsigned int )buf___1 == (unsigned int )((void *)0)) {
#line 372
    error("write_bignum: BN_bn2dec() failed");
#line 373
    return (0);
  }
#line 375
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )" %s", buf___1);
#line 376
  CRYPTO_free((void *)buf___1);
#line 377
  return (1);
}
}
#line 381 "key.c"
int key_read(Key *ret , char **cpp ) 
{ Key *k ;
  int success ;
  char *cp ;
  char *space ;
  int len ;
  int n___0 ;
  int type ;
  u_int bits ;
  u_char *blob ;
  int tmp ;
  int tmp___0 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
#line 385
  success = -1;
#line 391
  cp = *cpp;
#line 393
  switch (ret->type) {
  case 0: 
#line 396
  if ((int )*cp < 48) {
#line 397
    return (-1);
  } else {
#line 396
    if ((int )*cp > 57) {
#line 397
      return (-1);
    }
  }
#line 398
  bits = 0U;
#line 398
  while (1) {
#line 398
    if ((int )*cp >= 48) {
#line 398
      if (! ((int )*cp <= 57)) {
#line 398
        break;
      }
    } else {
#line 398
      break;
    }
#line 399
    bits = (10U * bits + (u_int )*cp) - 48U;
#line 398
    cp ++;
  }
#line 400
  if (bits == 0U) {
#line 401
    return (-1);
  }
#line 402
  *cpp = cp;
#line 404
  tmp = read_bignum(cpp, (ret->rsa)->e);
#line 404
  if (! tmp) {
#line 405
    return (-1);
  }
#line 406
  tmp___0 = read_bignum(cpp, (ret->rsa)->n);
#line 406
  if (! tmp___0) {
#line 407
    return (-1);
  }
#line 408
  success = 1;
#line 409
  break;
  case 3: 
  case 1: 
  case 2: 
#line 413
  tmp___2 = __builtin_strchr(cp, ' ');
#line 413
  space = tmp___2;
#line 414
  if ((unsigned int )space == (unsigned int )((void *)0)) {
#line 415
    debug3("key_read: missing whitespace");
#line 416
    return (-1);
  }
#line 418
  *space = (char )'\000';
#line 419
  type = key_type_from_name(cp);
#line 420
  *space = (char )' ';
#line 421
  if (type == 3) {
#line 422
    debug3("key_read: missing keytype");
#line 423
    return (-1);
  }
#line 425
  cp = space + 1;
#line 426
  if ((int )*cp == 0) {
#line 427
    debug3("key_read: short string");
#line 428
    return (-1);
  }
#line 430
  if (ret->type == 3) {
#line 431
    ret->type = type;
  } else {
#line 432
    if (ret->type != type) {
#line 434
      debug3("key_read: type mismatch");
#line 435
      return (-1);
    }
  }
#line 437
  tmp___3 = strlen((char const   *)cp);
#line 437
  len = (int )(2U * tmp___3);
#line 438
  tmp___4 = xmalloc((unsigned int )len);
#line 438
  blob = (u_char *)tmp___4;
#line 439
  n___0 = uudecode((char const   *)cp, blob, (unsigned int )len);
#line 440
  if (n___0 < 0) {
#line 441
    error("key_read: uudecode %s failed", cp);
#line 442
    xfree((void *)blob);
#line 443
    return (-1);
  }
#line 445
  k = key_from_blob((u_char const   *)blob, (unsigned int )n___0);
#line 446
  xfree((void *)blob);
#line 447
  if ((unsigned int )k == (unsigned int )((void *)0)) {
#line 448
    error("key_read: key_from_blob %s failed", cp);
#line 449
    return (-1);
  }
#line 451
  if (k->type != type) {
#line 452
    error("key_read: type mismatch: encoding error");
#line 453
    key_free(k);
#line 454
    return (-1);
  }
#line 457
  if (ret->type == 1) {
#line 458
    if ((unsigned int )ret->rsa != (unsigned int )((void *)0)) {
#line 459
      RSA_free(ret->rsa);
    }
#line 460
    ret->rsa = k->rsa;
#line 461
    k->rsa = (RSA *)((void *)0);
#line 462
    success = 1;
  } else {
#line 467
    if ((unsigned int )ret->dsa != (unsigned int )((void *)0)) {
#line 468
      DSA_free(ret->dsa);
    }
#line 469
    ret->dsa = k->dsa;
#line 470
    k->dsa = (DSA *)((void *)0);
#line 471
    success = 1;
  }
#line 477
  key_free(k);
#line 478
  if (success != 1) {
#line 479
    break;
  }
#line 481
  while (1) {
#line 481
    if (! ((int )*cp == 32)) {
#line 481
      if (! ((int )*cp == 9)) {
#line 481
        break;
      }
    }
#line 482
    cp ++;
  }
#line 483
  while (1) {
#line 483
    if ((int )*cp != 0) {
#line 483
      if ((int )*cp != 32) {
#line 483
        if (! ((int )*cp != 9)) {
#line 483
          break;
        }
      } else {
#line 483
        break;
      }
    } else {
#line 483
      break;
    }
#line 484
    cp ++;
  }
#line 485
  *cpp = cp;
#line 486
  break;
  default: 
#line 488
  fatal("key_read: bad key type: %d", ret->type);
#line 489
  break;
  }
#line 491
  return (success);
}
}
#line 494 "key.c"
int key_write(Key const   *key , FILE *f ) 
{ int n___0 ;
  int success ;
  u_int len ;
  u_int bits ;
  u_char *blob ;
  char *uu ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 497
  success = 0;
#line 498
  bits = (u_int )0;
#line 502
  if (key->type == 0) {
#line 502
    if ((unsigned int )key->rsa != (unsigned int )((void *)0)) {
#line 504
      tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 504
      bits = (unsigned int )tmp;
#line 505
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%u", bits);
#line 506
      tmp___0 = write_bignum(f, (key->rsa)->e);
#line 506
      if (tmp___0) {
#line 506
        tmp___1 = write_bignum(f, (key->rsa)->n);
#line 506
        if (tmp___1) {
#line 508
          success = 1;
        } else {
#line 510
          error("key_write: failed for RSA key");
        }
      } else {
#line 510
        error("key_write: failed for RSA key");
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 512
    if (key->type == 2) {
#line 512
      if ((unsigned int )key->dsa != (unsigned int )((void *)0)) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 512
      if (key->type == 1) {
#line 512
        if ((unsigned int )key->rsa != (unsigned int )((void *)0)) {
          _L: /* CIL Label */ 
#line 514
          key_to_blob(key, & blob, & len);
#line 515
          tmp___2 = xmalloc(2U * len);
#line 515
          uu = (char *)tmp___2;
#line 516
          n___0 = uuencode((u_char const   *)blob, len, uu, 2U * len);
#line 517
          if (n___0 > 0) {
#line 518
            tmp___3 = key_ssh_name(key);
#line 518
            fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s",
                    tmp___3, uu);
#line 519
            success = 1;
          }
#line 521
          xfree((void *)blob);
#line 522
          xfree((void *)uu);
        }
      }
    }
  }
#line 524
  return (success);
}
}
#line 527 "key.c"
char const   *key_type(Key const   *k ) 
{ 

  {
#line 530
  switch ((int )k->type) {
  case 0: 
#line 532
  return ("RSA1");
#line 533
  break;
  case 1: 
#line 535
  return ("RSA");
#line 536
  break;
  case 2: 
#line 538
  return ("DSA");
#line 539
  break;
  }
#line 541
  return ("unknown");
}
}
#line 544 "key.c"
char const   *key_ssh_name(Key const   *k ) 
{ 

  {
#line 547
  switch ((int )k->type) {
  case 1: 
#line 549
  return ("ssh-rsa");
#line 550
  break;
  case 2: 
#line 552
  return ("ssh-dss");
#line 553
  break;
  }
#line 555
  return ("ssh-unknown");
}
}
#line 558 "key.c"
u_int key_size(Key const   *k ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 561
  switch ((int )k->type) {
  case 0: 
  case 1: 
#line 564
  tmp = BN_num_bits((BIGNUM const   *)(k->rsa)->n);
#line 564
  return ((unsigned int )tmp);
#line 565
  break;
  case 2: 
#line 567
  tmp___0 = BN_num_bits((BIGNUM const   *)(k->dsa)->p);
#line 567
  return ((unsigned int )tmp___0);
#line 568
  break;
  }
#line 570
  return (0U);
}
}
#line 573 "key.c"
static RSA *rsa_generate_private_key(u_int bits ) 
{ RSA *private ;

  {
#line 577
  private = RSA_generate_key((int )bits, 35UL, (void (*)(int  , int  , void * ))((void *)0),
                             (void *)0);
#line 578
  if ((unsigned int )private == (unsigned int )((void *)0)) {
#line 579
    fatal("rsa_generate_private_key: key generation failed.");
  }
#line 580
  return (private);
}
}
#line 583 "key.c"
static DSA *dsa_generate_private_key(u_int bits ) 
{ DSA *private ;
  DSA *tmp ;
  int tmp___0 ;

  {
#line 586
  tmp = DSA_generate_parameters((int )bits, (unsigned char *)((void *)0), 0, (int *)((void *)0),
                                (unsigned long *)((void *)0), (void (*)(int  , int  ,
                                                                        void * ))((void *)0),
                                (void *)0);
#line 586
  private = tmp;
#line 587
  if ((unsigned int )private == (unsigned int )((void *)0)) {
#line 588
    fatal("dsa_generate_private_key: DSA_generate_parameters failed");
  }
#line 589
  tmp___0 = DSA_generate_key(private);
#line 589
  if (! tmp___0) {
#line 590
    fatal("dsa_generate_private_key: DSA_generate_key failed.");
  }
#line 591
  if ((unsigned int )private == (unsigned int )((void *)0)) {
#line 592
    fatal("dsa_generate_private_key: NULL.");
  }
#line 593
  return (private);
}
}
#line 596 "key.c"
Key *key_generate(int type , u_int bits ) 
{ Key *k ;
  Key *tmp ;

  {
#line 599
  tmp = key_new(3);
#line 599
  k = tmp;
#line 600
  switch (type) {
  case 2: 
#line 602
  k->dsa = dsa_generate_private_key(bits);
#line 603
  break;
  case 1: 
  case 0: 
#line 606
  k->rsa = rsa_generate_private_key(bits);
#line 607
  break;
  default: 
#line 609
  fatal("key_generate: unknown type %d", type);
  }
#line 611
  k->type = type;
#line 612
  return (k);
}
}
#line 615 "key.c"
Key *key_from_private(Key const   *k ) 
{ Key *n___0 ;

  {
#line 618
  n___0 = (Key *)((void *)0);
#line 619
  switch ((int )k->type) {
  case 2: 
#line 621
  n___0 = key_new((int )k->type);
#line 622
  BN_copy((n___0->dsa)->p, (BIGNUM const   *)(k->dsa)->p);
#line 623
  BN_copy((n___0->dsa)->q, (BIGNUM const   *)(k->dsa)->q);
#line 624
  BN_copy((n___0->dsa)->g, (BIGNUM const   *)(k->dsa)->g);
#line 625
  BN_copy((n___0->dsa)->pub_key, (BIGNUM const   *)(k->dsa)->pub_key);
#line 626
  break;
  case 1: 
  case 0: 
#line 629
  n___0 = key_new((int )k->type);
#line 630
  BN_copy((n___0->rsa)->n, (BIGNUM const   *)(k->rsa)->n);
#line 631
  BN_copy((n___0->rsa)->e, (BIGNUM const   *)(k->rsa)->e);
#line 632
  break;
  default: 
#line 634
  fatal("key_from_private: unknown type %d", k->type);
#line 635
  break;
  }
#line 637
  return (n___0);
}
}
#line 640 "key.c"
int key_type_from_name(char *name ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;

  {
#line 643
  if (0) {
#line 643
    __s1_len___3 = strlen((char const   *)name);
#line 643
    __s2_len___3 = strlen("rsa1");
#line 643
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___8;
    } else {
#line 643
      if (__s1_len___3 >= 4U) {
        _L___8: /* CIL Label */ 
#line 643
        if (! ((unsigned int )((void const   *)("rsa1" + 1)) - (unsigned int )((void const   *)"rsa1") == 1U)) {
#line 643
          tmp___48 = 1;
        } else {
#line 643
          if (__s2_len___3 >= 4U) {
#line 643
            tmp___48 = 1;
          } else {
#line 643
            tmp___48 = 0;
          }
        }
      } else {
#line 643
        tmp___48 = 0;
      }
    }
#line 643
    if (tmp___48) {
#line 643
      tmp___44 = __builtin_strcmp((char const   *)name, "rsa1");
    } else {
#line 643
      tmp___47 = __builtin_strcmp((char const   *)name, "rsa1");
#line 643
      tmp___44 = tmp___47;
    }
  } else {
#line 643
    tmp___47 = __builtin_strcmp((char const   *)name, "rsa1");
#line 643
    tmp___44 = tmp___47;
  }
#line 643
  if (tmp___44 == 0) {
#line 644
    return (0);
  } else {
#line 645
    if (0) {
#line 645
      __s1_len___2 = strlen((char const   *)name);
#line 645
      __s2_len___2 = strlen("rsa");
#line 645
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___6;
      } else {
#line 645
        if (__s1_len___2 >= 4U) {
          _L___6: /* CIL Label */ 
#line 645
          if (! ((unsigned int )((void const   *)("rsa" + 1)) - (unsigned int )((void const   *)"rsa") == 1U)) {
#line 645
            tmp___38 = 1;
          } else {
#line 645
            if (__s2_len___2 >= 4U) {
#line 645
              tmp___38 = 1;
            } else {
#line 645
              tmp___38 = 0;
            }
          }
        } else {
#line 645
          tmp___38 = 0;
        }
      }
#line 645
      if (tmp___38) {
#line 645
        tmp___34 = __builtin_strcmp((char const   *)name, "rsa");
      } else {
#line 645
        tmp___37 = __builtin_strcmp((char const   *)name, "rsa");
#line 645
        tmp___34 = tmp___37;
      }
    } else {
#line 645
      tmp___37 = __builtin_strcmp((char const   *)name, "rsa");
#line 645
      tmp___34 = tmp___37;
    }
#line 645
    if (tmp___34 == 0) {
#line 646
      return (1);
    } else {
#line 647
      if (0) {
#line 647
        __s1_len___1 = strlen((char const   *)name);
#line 647
        __s2_len___1 = strlen("dsa");
#line 647
        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
          goto _L___4;
        } else {
#line 647
          if (__s1_len___1 >= 4U) {
            _L___4: /* CIL Label */ 
#line 647
            if (! ((unsigned int )((void const   *)("dsa" + 1)) - (unsigned int )((void const   *)"dsa") == 1U)) {
#line 647
              tmp___28 = 1;
            } else {
#line 647
              if (__s2_len___1 >= 4U) {
#line 647
                tmp___28 = 1;
              } else {
#line 647
                tmp___28 = 0;
              }
            }
          } else {
#line 647
            tmp___28 = 0;
          }
        }
#line 647
        if (tmp___28) {
#line 647
          tmp___24 = __builtin_strcmp((char const   *)name, "dsa");
        } else {
#line 647
          tmp___27 = __builtin_strcmp((char const   *)name, "dsa");
#line 647
          tmp___24 = tmp___27;
        }
      } else {
#line 647
        tmp___27 = __builtin_strcmp((char const   *)name, "dsa");
#line 647
        tmp___24 = tmp___27;
      }
#line 647
      if (tmp___24 == 0) {
#line 648
        return (2);
      } else {
#line 649
        if (0) {
#line 649
          __s1_len___0 = strlen((char const   *)name);
#line 649
          __s2_len___0 = strlen("ssh-rsa");
#line 649
          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
            goto _L___2;
          } else {
#line 649
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 649
              if (! ((unsigned int )((void const   *)("ssh-rsa" + 1)) - (unsigned int )((void const   *)"ssh-rsa") == 1U)) {
#line 649
                tmp___18 = 1;
              } else {
#line 649
                if (__s2_len___0 >= 4U) {
#line 649
                  tmp___18 = 1;
                } else {
#line 649
                  tmp___18 = 0;
                }
              }
            } else {
#line 649
              tmp___18 = 0;
            }
          }
#line 649
          if (tmp___18) {
#line 649
            tmp___14 = __builtin_strcmp((char const   *)name, "ssh-rsa");
          } else {
#line 649
            tmp___17 = __builtin_strcmp((char const   *)name, "ssh-rsa");
#line 649
            tmp___14 = tmp___17;
          }
        } else {
#line 649
          tmp___17 = __builtin_strcmp((char const   *)name, "ssh-rsa");
#line 649
          tmp___14 = tmp___17;
        }
#line 649
        if (tmp___14 == 0) {
#line 650
          return (1);
        } else {
#line 651
          if (0) {
#line 651
            __s1_len = strlen((char const   *)name);
#line 651
            __s2_len = strlen("ssh-dss");
#line 651
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
              goto _L___0;
            } else {
#line 651
              if (__s1_len >= 4U) {
                _L___0: /* CIL Label */ 
#line 651
                if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
#line 651
                  tmp___8 = 1;
                } else {
#line 651
                  if (__s2_len >= 4U) {
#line 651
                    tmp___8 = 1;
                  } else {
#line 651
                    tmp___8 = 0;
                  }
                }
              } else {
#line 651
                tmp___8 = 0;
              }
            }
#line 651
            if (tmp___8) {
#line 651
              tmp___4 = __builtin_strcmp((char const   *)name, "ssh-dss");
            } else {
#line 651
              tmp___7 = __builtin_strcmp((char const   *)name, "ssh-dss");
#line 651
              tmp___4 = tmp___7;
            }
          } else {
#line 651
            tmp___7 = __builtin_strcmp((char const   *)name, "ssh-dss");
#line 651
            tmp___4 = tmp___7;
          }
#line 651
          if (tmp___4 == 0) {
#line 652
            return (2);
          }
        }
      }
    }
  }
#line 654
  debug2("key_type_from_name: unknown key type \'%s\'", name);
#line 655
  return (3);
}
}
#line 658 "key.c"
int key_names_valid2(char const   *names ) 
{ char *s ;
  char *cp ;
  char *p ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___24 ;
  char *tmp___40 ;
  int tmp___41 ;

  {
#line 663
  if ((unsigned int )names == (unsigned int )((void *)0)) {
#line 664
    return (0);
  } else {
#line 663
    if (0) {
#line 663
      __s1_len = strlen(names);
#line 663
      __s2_len = strlen("");
#line 663
      if (! ((unsigned int )((void const   *)(names + 1)) - (unsigned int )((void const   *)names) == 1U)) {
        goto _L___0;
      } else {
#line 663
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 663
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 663
            tmp___8 = 1;
          } else {
#line 663
            if (__s2_len >= 4U) {
#line 663
              tmp___8 = 1;
            } else {
#line 663
              tmp___8 = 0;
            }
          }
        } else {
#line 663
          tmp___8 = 0;
        }
      }
#line 663
      if (tmp___8) {
#line 663
        tmp___4 = __builtin_strcmp(names, "");
      } else {
#line 663
        tmp___7 = __builtin_strcmp(names, "");
#line 663
        tmp___4 = tmp___7;
      }
    } else {
#line 663
      tmp___7 = __builtin_strcmp(names, "");
#line 663
      tmp___4 = tmp___7;
    }
#line 663
    if (tmp___4 == 0) {
#line 664
      return (0);
    }
  }
#line 665
  cp = xstrdup(names);
#line 665
  s = cp;
#line 666
  tmp___24 = __strsep_g(& cp, ",");
#line 666
  p = tmp___24;
#line 666
  while (1) {
#line 666
    if (p) {
#line 666
      if (! ((int )*p != 0)) {
#line 666
        break;
      }
    } else {
#line 666
      break;
    }
#line 668
    tmp___41 = key_type_from_name(p);
#line 668
    switch (tmp___41) {
    case 0: 
    case 3: 
#line 671
    xfree((void *)s);
#line 672
    return (0);
    }
#line 667
    tmp___40 = __strsep_g(& cp, ",");
#line 667
    p = tmp___40;
  }
#line 675
  debug3("key names ok: [%s]", names);
#line 676
  xfree((void *)s);
#line 677
  return (1);
}
}
#line 680 "key.c"
Key *key_from_blob(u_char const   *blob , u_int blen ) 
{ Buffer b ;
  char *ktype ;
  int rlen ;
  int type ;
  Key *key ;
  void *tmp ;
  u_int tmp___0 ;

  {
#line 686
  key = (Key *)((void *)0);
#line 691
  buffer_init(& b);
#line 692
  buffer_append(& b, (void const   *)blob, blen);
#line 693
  tmp = buffer_get_string(& b, (u_int *)((void *)0));
#line 693
  ktype = (char *)tmp;
#line 694
  type = key_type_from_name(ktype);
#line 696
  switch (type) {
  case 1: 
#line 698
  key = key_new(type);
#line 699
  buffer_get_bignum2(& b, (key->rsa)->e);
#line 700
  buffer_get_bignum2(& b, (key->rsa)->n);
#line 704
  break;
  case 2: 
#line 706
  key = key_new(type);
#line 707
  buffer_get_bignum2(& b, (key->dsa)->p);
#line 708
  buffer_get_bignum2(& b, (key->dsa)->q);
#line 709
  buffer_get_bignum2(& b, (key->dsa)->g);
#line 710
  buffer_get_bignum2(& b, (key->dsa)->pub_key);
#line 714
  break;
  case 3: 
#line 716
  key = key_new(type);
#line 717
  break;
  default: 
#line 719
  error("key_from_blob: cannot handle type %s", ktype);
#line 720
  break;
  }
#line 722
  tmp___0 = buffer_len(& b);
#line 722
  rlen = (int )tmp___0;
#line 723
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 723
    if (rlen != 0) {
#line 724
      error("key_from_blob: remaining bytes in key blob %d", rlen);
    }
  }
#line 725
  xfree((void *)ktype);
#line 726
  buffer_free(& b);
#line 727
  return (key);
}
}
#line 730 "key.c"
int key_to_blob(Key const   *key , u_char **blobp , u_int *lenp ) 
{ Buffer b ;
  int len ;
  char const   *tmp ;
  char const   *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 736
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 737
    error("key_to_blob: key == NULL");
#line 738
    return (0);
  }
#line 740
  buffer_init(& b);
#line 741
  switch ((int )key->type) {
  case 2: 
#line 743
  tmp = key_ssh_name(key);
#line 743
  buffer_put_cstring(& b, tmp);
#line 744
  buffer_put_bignum2(& b, (BIGNUM const   *)(key->dsa)->p);
#line 745
  buffer_put_bignum2(& b, (BIGNUM const   *)(key->dsa)->q);
#line 746
  buffer_put_bignum2(& b, (BIGNUM const   *)(key->dsa)->g);
#line 747
  buffer_put_bignum2(& b, (BIGNUM const   *)(key->dsa)->pub_key);
#line 748
  break;
  case 1: 
#line 750
  tmp___0 = key_ssh_name(key);
#line 750
  buffer_put_cstring(& b, tmp___0);
#line 751
  buffer_put_bignum2(& b, (BIGNUM const   *)(key->rsa)->e);
#line 752
  buffer_put_bignum2(& b, (BIGNUM const   *)(key->rsa)->n);
#line 753
  break;
  default: 
#line 755
  error("key_to_blob: unsupported key type %d", key->type);
#line 756
  buffer_free(& b);
#line 757
  return (0);
  }
#line 759
  tmp___1 = buffer_len(& b);
#line 759
  len = (int )tmp___1;
#line 760
  if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 761
    *lenp = (unsigned int )len;
  }
#line 762
  if ((unsigned int )blobp != (unsigned int )((void *)0)) {
#line 763
    tmp___2 = xmalloc((unsigned int )len);
#line 763
    *blobp = (u_char *)tmp___2;
#line 764
    tmp___3 = buffer_ptr(& b);
#line 764
    memcpy((void * __restrict  )*blobp, (void const   * __restrict  )tmp___3, (unsigned int )len);
  }
#line 766
  tmp___4 = buffer_ptr(& b);
#line 766
  memset(tmp___4, 0, (unsigned int )len);
#line 767
  buffer_free(& b);
#line 768
  return (len);
}
}
#line 771 "key.c"
int key_sign(Key const   *key , u_char **sigp , u_int *lenp , u_char const   *data ,
             u_int datalen ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 777
  switch ((int )key->type) {
  case 2: 
#line 779
  tmp = ssh_dss_sign(key, sigp, lenp, data, datalen);
#line 779
  return (tmp);
#line 780
  break;
  case 1: 
#line 782
  tmp___0 = ssh_rsa_sign(key, sigp, lenp, data, datalen);
#line 782
  return (tmp___0);
#line 783
  break;
  default: 
#line 785
  error("key_sign: illegal key type %d", key->type);
#line 786
  return (-1);
#line 787
  break;
  }
#line 789
  return (0);
}
}
#line 795 "key.c"
int key_verify(Key const   *key , u_char const   *signature , u_int signaturelen ,
               u_char const   *data , u_int datalen ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 801
  if (signaturelen == 0U) {
#line 802
    return (-1);
  }
#line 804
  switch ((int )key->type) {
  case 2: 
#line 806
  tmp = ssh_dss_verify(key, signature, signaturelen, data, datalen);
#line 806
  return (tmp);
#line 807
  break;
  case 1: 
#line 809
  tmp___0 = ssh_rsa_verify(key, signature, signaturelen, data, datalen);
#line 809
  return (tmp___0);
#line 810
  break;
  default: 
#line 812
  error("key_verify: illegal key type %d", key->type);
#line 813
  return (-1);
#line 814
  break;
  }
#line 816
  return (0);
}
}
#line 819 "key.c"
Key *key_demote(Key const   *k ) 
{ Key *pk ;
  void *tmp ;

  {
#line 824
  tmp = xmalloc(sizeof(*pk));
#line 824
  pk = (Key *)tmp;
#line 825
  pk->type = (int )k->type;
#line 826
  pk->flags = (int )k->flags;
#line 827
  pk->dsa = (DSA *)((void *)0);
#line 828
  pk->rsa = (RSA *)((void *)0);
#line 830
  switch ((int )k->type) {
  case 0: 
  case 1: 
#line 833
  pk->rsa = RSA_new();
#line 833
  if ((unsigned int )pk->rsa == (unsigned int )((void *)0)) {
#line 834
    fatal("key_demote: RSA_new failed");
  }
#line 835
  (pk->rsa)->e = BN_dup((BIGNUM const   *)(k->rsa)->e);
#line 835
  if ((unsigned int )(pk->rsa)->e == (unsigned int )((void *)0)) {
#line 836
    fatal("key_demote: BN_dup failed");
  }
#line 837
  (pk->rsa)->n = BN_dup((BIGNUM const   *)(k->rsa)->n);
#line 837
  if ((unsigned int )(pk->rsa)->n == (unsigned int )((void *)0)) {
#line 838
    fatal("key_demote: BN_dup failed");
  }
#line 839
  break;
  case 2: 
#line 841
  pk->dsa = DSA_new();
#line 841
  if ((unsigned int )pk->dsa == (unsigned int )((void *)0)) {
#line 842
    fatal("key_demote: DSA_new failed");
  }
#line 843
  (pk->dsa)->p = BN_dup((BIGNUM const   *)(k->dsa)->p);
#line 843
  if ((unsigned int )(pk->dsa)->p == (unsigned int )((void *)0)) {
#line 844
    fatal("key_demote: BN_dup failed");
  }
#line 845
  (pk->dsa)->q = BN_dup((BIGNUM const   *)(k->dsa)->q);
#line 845
  if ((unsigned int )(pk->dsa)->q == (unsigned int )((void *)0)) {
#line 846
    fatal("key_demote: BN_dup failed");
  }
#line 847
  (pk->dsa)->g = BN_dup((BIGNUM const   *)(k->dsa)->g);
#line 847
  if ((unsigned int )(pk->dsa)->g == (unsigned int )((void *)0)) {
#line 848
    fatal("key_demote: BN_dup failed");
  }
#line 849
  (pk->dsa)->pub_key = BN_dup((BIGNUM const   *)(k->dsa)->pub_key);
#line 849
  if ((unsigned int )(pk->dsa)->pub_key == (unsigned int )((void *)0)) {
#line 850
    fatal("key_demote: BN_dup failed");
  }
#line 851
  break;
  default: 
#line 853
  fatal("key_free: bad key type %d", k->type);
#line 854
  break;
  }
#line 857
  return (pk);
}
}
#line 1 "dispatch.o"
#line 33 "dispatch.h"
void dispatch_init(dispatch_fn *dflt ) ;
#line 34
void dispatch_set(int type , dispatch_fn *fn ) ;
#line 35
void dispatch_range(u_int from , u_int to , dispatch_fn *fn ) ;
#line 36
void dispatch_run(int mode , int *done , void *ctxt ) ;
#line 37
void dispatch_protocol_error(int type , u_int32_t seq , void *ctxt ) ;
#line 38
void dispatch_protocol_ignore(int type , u_int32_t seq , void *ctxt ) ;
#line 37 "dispatch.c"
dispatch_fn *dispatch[255]  ;
#line 39 "dispatch.c"
void dispatch_protocol_error(int type , u_int32_t seq , void *ctxt ) 
{ 

  {
#line 42
  logit("dispatch_protocol_error: type %d seq %u", type, seq);
#line 43
  if (! compat20) {
#line 44
    fatal("protocol error");
  }
#line 45
  packet_start((unsigned char)3);
#line 46
  packet_put_int(seq);
#line 47
  packet_send();
#line 48
  packet_write_wait();
#line 49
  return;
}
}
#line 50 "dispatch.c"
void dispatch_protocol_ignore(int type , u_int32_t seq , void *ctxt ) 
{ 

  {
#line 53
  logit("dispatch_protocol_ignore: type %d seq %u", type, seq);
#line 54
  return;
}
}
#line 55 "dispatch.c"
void dispatch_init(dispatch_fn *dflt ) 
{ u_int i ;

  {
#line 59
  i = 0U;
#line 59
  while (i < 255U) {
#line 60
    dispatch[i] = dflt;
#line 59
    i ++;
  }
#line 61
  return;
}
}
#line 62 "dispatch.c"
void dispatch_range(u_int from , u_int to , dispatch_fn *fn ) 
{ u_int i ;

  {
#line 67
  i = from;
#line 67
  while (i <= to) {
#line 68
    if (i >= 255U) {
#line 69
      break;
    }
#line 70
    dispatch[i] = fn;
#line 67
    i ++;
  }
#line 72
  return;
}
}
#line 73 "dispatch.c"
void dispatch_set(int type , dispatch_fn *fn ) 
{ 

  {
#line 76
  dispatch[type] = fn;
#line 77
  return;
}
}
#line 78 "dispatch.c"
void dispatch_run(int mode , int *done , void *ctxt ) 
{ int type ;
  u_int32_t seqnr ;

  {
#line 81
  while (1) {
#line 85
    if (mode == 0) {
#line 86
      type = packet_read_seqnr(& seqnr);
    } else {
#line 88
      type = packet_read_poll_seqnr(& seqnr);
#line 89
      if (type == 0) {
#line 90
        return;
      }
    }
#line 92
    if (type > 0) {
#line 92
      if (type < 255) {
#line 92
        if ((unsigned int )dispatch[type] != (unsigned int )((void *)0)) {
#line 93
          (*(dispatch[type]))(type, seqnr, ctxt);
        } else {
#line 95
          packet_disconnect("protocol error: rcvd type %d", type);
        }
      } else {
#line 95
        packet_disconnect("protocol error: rcvd type %d", type);
      }
    } else {
#line 95
      packet_disconnect("protocol error: rcvd type %d", type);
    }
#line 96
    if ((unsigned int )done != (unsigned int )((void *)0)) {
#line 96
      if (*done) {
#line 97
        return;
      }
    }
  }
}
}
#line 1 "kex.o"
#line 119 "kex.h"
Kex *kex_setup(char **proposal ) ;
#line 120
void kex_finish(Kex *kex ) ;
#line 122
void kex_send_kexinit(Kex *kex ) ;
#line 123
void kex_input_kexinit(int type , u_int32_t seq , void *ctxt ) ;
#line 124
void kex_derive_keys(Kex *kex , u_char *hash , BIGNUM *shared_secret ) ;
#line 27 "mac.h"
int mac_init(Mac *mac , char *name ) ;
#line 48 "kex.c"
static void kex_kexinit_finish(Kex *kex ) ;
#line 49
static void kex_choose_conf(Kex *kex ) ;
#line 52 "kex.c"
static void kex_prop2buf(Buffer *b , char **proposal ) 
{ int i ;

  {
#line 57
  buffer_clear(b);
#line 62
  i = 0;
#line 62
  while (i < 16) {
#line 63
    buffer_put_char(b, 0);
#line 62
    i ++;
  }
#line 64
  i = 0;
#line 64
  while (i < 10) {
#line 65
    buffer_put_cstring(b, (char const   *)*(proposal + i));
#line 64
    i ++;
  }
#line 66
  buffer_put_char(b, 0);
#line 67
  buffer_put_int(b, 0U);
#line 68
  return;
}
}
#line 71 "kex.c"
static char **kex_buf2prop(Buffer *raw , int *first_kex_follows ) 
{ Buffer b ;
  int i ;
  char **proposal ;
  void *tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  u_int tmp___3 ;

  {
#line 78
  tmp = xmalloc(10U * sizeof(char *));
#line 78
  proposal = (char **)tmp;
#line 80
  buffer_init(& b);
#line 81
  tmp___0 = buffer_len(raw);
#line 81
  tmp___1 = buffer_ptr(raw);
#line 81
  buffer_append(& b, (void const   *)tmp___1, tmp___0);
#line 83
  i = 0;
#line 83
  while (i < 16) {
#line 84
    buffer_get_char(& b);
#line 83
    i ++;
  }
#line 86
  i = 0;
#line 86
  while (i < 10) {
#line 87
    tmp___2 = buffer_get_string(& b, (u_int *)((void *)0));
#line 87
    *(proposal + i) = (char *)tmp___2;
#line 88
    debug2("kex_parse_kexinit: %s", *(proposal + i));
#line 86
    i ++;
  }
#line 91
  i = buffer_get_char(& b);
#line 92
  if ((unsigned int )first_kex_follows != (unsigned int )((void *)0)) {
#line 93
    *first_kex_follows = i;
  }
#line 94
  debug2("kex_parse_kexinit: first_kex_follows %d ", i);
#line 95
  tmp___3 = buffer_get_int(& b);
#line 95
  i = (int )tmp___3;
#line 96
  debug2("kex_parse_kexinit: reserved %d ", i);
#line 97
  buffer_free(& b);
#line 98
  return (proposal);
}
}
#line 101 "kex.c"
static void kex_prop_free(char **proposal ) 
{ int i ;

  {
#line 106
  i = 0;
#line 106
  while (i < 10) {
#line 107
    xfree((void *)*(proposal + i));
#line 106
    i ++;
  }
#line 108
  xfree((void *)proposal);
#line 109
  return;
}
}
#line 111 "kex.c"
static void kex_protocol_error(int type , u_int32_t seq , void *ctxt ) 
{ 

  {
#line 114
  error("Hm, kex protocol error: type %d seq %u", type, seq);
#line 115
  return;
}
}
#line 117 "kex.c"
static void kex_reset_dispatch(void) 
{ 

  {
#line 120
  dispatch_range(1U, 49U, & kex_protocol_error);
#line 122
  dispatch_set(20, & kex_input_kexinit);
#line 123
  return;
}
}
#line 125 "kex.c"
void kex_finish(Kex *kex ) 
{ int _len ;
  int tmp ;

  {
#line 128
  kex_reset_dispatch();
#line 130
  packet_start((unsigned char)21);
#line 131
  packet_send();
#line 133
  debug("SSH2_MSG_NEWKEYS sent");
#line 135
  debug("expecting SSH2_MSG_NEWKEYS");
#line 136
  packet_read_expect(21);
#line 137
  while (1) {
#line 137
    tmp = packet_remaining();
#line 137
    _len = tmp;
#line 137
    if (_len > 0) {
#line 137
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kex.c",
            137);
#line 137
      packet_disconnect("Packet integrity error.");
    }
#line 137
    break;
  }
#line 138
  debug("SSH2_MSG_NEWKEYS received");
#line 140
  kex->done = 1;
#line 141
  buffer_clear(& kex->peer);
#line 143
  kex->flags &= -2;
#line 144
  xfree((void *)kex->name);
#line 145
  kex->name = (char *)((void *)0);
#line 146
  return;
}
}
#line 148 "kex.c"
void kex_send_kexinit(Kex *kex ) 
{ u_int32_t rand___0 ;
  u_char *cookie ;
  int i ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;

  {
#line 151
  rand___0 = (u_int32_t )0;
#line 155
  if ((unsigned int )kex == (unsigned int )((void *)0)) {
#line 156
    error("kex_send_kexinit: no kex, cannot rekey");
#line 157
    return;
  }
#line 159
  if (kex->flags & 1) {
#line 160
    debug("KEX_INIT_SENT");
#line 161
    return;
  }
#line 163
  kex->done = 0;
#line 166
  tmp = buffer_len(& kex->my);
#line 166
  if (tmp < 16U) {
#line 167
    fatal("kex_send_kexinit: kex proposal too short");
  }
#line 168
  tmp___0 = buffer_ptr(& kex->my);
#line 168
  cookie = (u_char *)tmp___0;
#line 169
  i = 0;
#line 169
  while (i < 16) {
#line 170
    if (i % 4 == 0) {
#line 171
      rand___0 = arc4random();
    }
#line 172
    *(cookie + i) = (unsigned char )rand___0;
#line 173
    rand___0 >>= 8;
#line 169
    i ++;
  }
#line 175
  packet_start((unsigned char)20);
#line 176
  tmp___1 = buffer_len(& kex->my);
#line 176
  tmp___2 = buffer_ptr(& kex->my);
#line 176
  packet_put_raw((void const   *)tmp___2, tmp___1);
#line 177
  packet_send();
#line 178
  debug("SSH2_MSG_KEXINIT sent");
#line 179
  kex->flags |= 1;
#line 180
  return;
}
}
#line 182 "kex.c"
void kex_input_kexinit(int type , u_int32_t seq , void *ctxt ) 
{ char *ptr ;
  int dlen ;
  int i ;
  Kex *kex ;
  void *tmp ;
  void *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 188
  kex = (Kex *)ctxt;
#line 190
  debug("SSH2_MSG_KEXINIT received");
#line 191
  if ((unsigned int )kex == (unsigned int )((void *)0)) {
#line 192
    fatal("kex_input_kexinit: no kex, cannot rekey");
  }
#line 194
  tmp = packet_get_raw(& dlen);
#line 194
  ptr = (char *)tmp;
#line 195
  buffer_append(& kex->peer, (void const   *)ptr, (unsigned int )dlen);
#line 198
  i = 0;
#line 198
  while (i < 16) {
#line 199
    packet_get_char();
#line 198
    i ++;
  }
#line 200
  i = 0;
#line 200
  while (i < 10) {
#line 201
    tmp___0 = packet_get_string((u_int *)((void *)0));
#line 201
    xfree(tmp___0);
#line 200
    i ++;
  }
#line 202
  packet_get_char();
#line 203
  packet_get_int();
#line 204
  while (1) {
#line 204
    tmp___1 = packet_remaining();
#line 204
    _len = tmp___1;
#line 204
    if (_len > 0) {
#line 204
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kex.c",
            204);
#line 204
      packet_disconnect("Packet integrity error.");
    }
#line 204
    break;
  }
#line 206
  kex_kexinit_finish(kex);
#line 207
  return;
}
}
#line 209 "kex.c"
Kex *kex_setup(char **proposal ) 
{ Kex *kex ;
  void *tmp ;

  {
#line 214
  tmp = xmalloc(sizeof(*kex));
#line 214
  kex = (Kex *)tmp;
#line 215
  memset((void *)kex, 0, sizeof(*kex));
#line 216
  buffer_init(& kex->peer);
#line 217
  buffer_init(& kex->my);
#line 218
  kex_prop2buf(& kex->my, proposal);
#line 219
  kex->done = 0;
#line 221
  kex_send_kexinit(kex);
#line 222
  kex_reset_dispatch();
#line 224
  return (kex);
}
}
#line 227 "kex.c"
static void kex_kexinit_finish(Kex *kex ) 
{ 

  {
#line 230
  if (! (kex->flags & 1)) {
#line 231
    kex_send_kexinit(kex);
  }
#line 233
  kex_choose_conf(kex);
#line 235
  if (kex->kex_type >= 0) {
#line 235
    if (kex->kex_type < 2) {
#line 235
      if ((unsigned int )kex->kex[kex->kex_type] != (unsigned int )((void *)0)) {
#line 237
        (*(kex->kex[kex->kex_type]))(kex);
      } else {
#line 239
        fatal("Unsupported key exchange %d", kex->kex_type);
      }
    } else {
#line 239
      fatal("Unsupported key exchange %d", kex->kex_type);
    }
  } else {
#line 239
    fatal("Unsupported key exchange %d", kex->kex_type);
  }
#line 241
  return;
}
}
#line 243 "kex.c"
static void choose_enc(Enc *enc , char *client , char *server ) 
{ char *name ;
  char *tmp ;

  {
#line 246
  tmp = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 246
  name = tmp;
#line 247
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 248
    fatal("no matching cipher found: client %s server %s", client, server);
  }
#line 249
  enc->cipher = cipher_by_name((char const   *)name);
#line 249
  if ((unsigned int )enc->cipher == (unsigned int )((void *)0)) {
#line 250
    fatal("matching cipher is not supported: %s", name);
  }
#line 251
  enc->name = name;
#line 252
  enc->enabled = 0;
#line 253
  enc->iv = (u_char *)((void *)0);
#line 254
  enc->key = (u_char *)((void *)0);
#line 255
  enc->key_len = cipher_keylen((Cipher const   *)enc->cipher);
#line 256
  enc->block_size = cipher_blocksize((Cipher const   *)enc->cipher);
#line 257
  return;
}
}
#line 258 "kex.c"
static void choose_mac(Mac *mac , char *client , char *server ) 
{ char *name ;
  char *tmp ;
  int tmp___0 ;

  {
#line 261
  tmp = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 261
  name = tmp;
#line 262
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 263
    fatal("no matching mac found: client %s server %s", client, server);
  }
#line 264
  tmp___0 = mac_init(mac, name);
#line 264
  if (tmp___0 < 0) {
#line 265
    fatal("unsupported mac %s", name);
  }
#line 267
  if (datafellows & 4) {
#line 268
    mac->key_len = 16;
  }
#line 269
  mac->name = name;
#line 270
  mac->key = (u_char *)((void *)0);
#line 271
  mac->enabled = 0;
#line 272
  return;
}
}
#line 273 "kex.c"
static void choose_comp(Comp *comp , char *client , char *server ) 
{ char *name ;
  char *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 276
  tmp = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 276
  name = tmp;
#line 277
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 278
    fatal("no matching comp found: client %s server %s", client, server);
  }
#line 279
  if (0) {
#line 279
    __s1_len___0 = strlen((char const   *)name);
#line 279
    __s2_len___0 = strlen("zlib");
#line 279
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___2;
    } else {
#line 279
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 279
        if (! ((unsigned int )((void const   *)("zlib" + 1)) - (unsigned int )((void const   *)"zlib") == 1U)) {
#line 279
          tmp___19 = 1;
        } else {
#line 279
          if (__s2_len___0 >= 4U) {
#line 279
            tmp___19 = 1;
          } else {
#line 279
            tmp___19 = 0;
          }
        }
      } else {
#line 279
        tmp___19 = 0;
      }
    }
#line 279
    if (tmp___19) {
#line 279
      tmp___15 = __builtin_strcmp((char const   *)name, "zlib");
    } else {
#line 279
      tmp___18 = __builtin_strcmp((char const   *)name, "zlib");
#line 279
      tmp___15 = tmp___18;
    }
  } else {
#line 279
    tmp___18 = __builtin_strcmp((char const   *)name, "zlib");
#line 279
    tmp___15 = tmp___18;
  }
#line 279
  if (tmp___15 == 0) {
#line 280
    comp->type = 1;
  } else {
#line 281
    if (0) {
#line 281
      __s1_len = strlen((char const   *)name);
#line 281
      __s2_len = strlen("none");
#line 281
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___0;
      } else {
#line 281
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 281
          if (! ((unsigned int )((void const   *)("none" + 1)) - (unsigned int )((void const   *)"none") == 1U)) {
#line 281
            tmp___9 = 1;
          } else {
#line 281
            if (__s2_len >= 4U) {
#line 281
              tmp___9 = 1;
            } else {
#line 281
              tmp___9 = 0;
            }
          }
        } else {
#line 281
          tmp___9 = 0;
        }
      }
#line 281
      if (tmp___9) {
#line 281
        tmp___5 = __builtin_strcmp((char const   *)name, "none");
      } else {
#line 281
        tmp___8 = __builtin_strcmp((char const   *)name, "none");
#line 281
        tmp___5 = tmp___8;
      }
    } else {
#line 281
      tmp___8 = __builtin_strcmp((char const   *)name, "none");
#line 281
      tmp___5 = tmp___8;
    }
#line 281
    if (tmp___5 == 0) {
#line 282
      comp->type = 0;
    } else {
#line 284
      fatal("unsupported comp %s", name);
    }
  }
#line 286
  comp->name = name;
#line 287
  return;
}
}
#line 288 "kex.c"
static void choose_kex(Kex *k , char *client , char *server ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 291
  k->name = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 292
  if ((unsigned int )k->name == (unsigned int )((void *)0)) {
#line 293
    fatal("no kex alg");
  }
#line 294
  if (0) {
#line 294
    __s1_len___0 = strlen((char const   *)k->name);
#line 294
    __s2_len___0 = strlen("diffie-hellman-group1-sha1");
#line 294
    if (! ((unsigned int )((void const   *)(k->name + 1)) - (unsigned int )((void const   *)k->name) == 1U)) {
      goto _L___2;
    } else {
#line 294
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 294
        if (! ((unsigned int )((void const   *)("diffie-hellman-group1-sha1" + 1)) - (unsigned int )((void const   *)"diffie-hellman-group1-sha1") == 1U)) {
#line 294
          tmp___18 = 1;
        } else {
#line 294
          if (__s2_len___0 >= 4U) {
#line 294
            tmp___18 = 1;
          } else {
#line 294
            tmp___18 = 0;
          }
        }
      } else {
#line 294
        tmp___18 = 0;
      }
    }
#line 294
    if (tmp___18) {
#line 294
      tmp___14 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
    } else {
#line 294
      tmp___17 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
#line 294
      tmp___14 = tmp___17;
    }
  } else {
#line 294
    tmp___17 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
#line 294
    tmp___14 = tmp___17;
  }
#line 294
  if (tmp___14 == 0) {
#line 295
    k->kex_type = 0;
  } else {
#line 296
    if (0) {
#line 296
      __s1_len = strlen((char const   *)k->name);
#line 296
      __s2_len = strlen("diffie-hellman-group-exchange-sha1");
#line 296
      if (! ((unsigned int )((void const   *)(k->name + 1)) - (unsigned int )((void const   *)k->name) == 1U)) {
        goto _L___0;
      } else {
#line 296
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 296
          if (! ((unsigned int )((void const   *)("diffie-hellman-group-exchange-sha1" + 1)) - (unsigned int )((void const   *)"diffie-hellman-group-exchange-sha1") == 1U)) {
#line 296
            tmp___8 = 1;
          } else {
#line 296
            if (__s2_len >= 4U) {
#line 296
              tmp___8 = 1;
            } else {
#line 296
              tmp___8 = 0;
            }
          }
        } else {
#line 296
          tmp___8 = 0;
        }
      }
#line 296
      if (tmp___8) {
#line 296
        tmp___4 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha1");
      } else {
#line 296
        tmp___7 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha1");
#line 296
        tmp___4 = tmp___7;
      }
    } else {
#line 296
      tmp___7 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha1");
#line 296
      tmp___4 = tmp___7;
    }
#line 296
    if (tmp___4 == 0) {
#line 297
      k->kex_type = 1;
    } else {
#line 299
      fatal("bad kex alg %s", k->name);
    }
  }
#line 300
  return;
}
}
#line 301 "kex.c"
static void choose_hostkeyalg(Kex *k , char *client , char *server ) 
{ char *hostkeyalg ;
  char *tmp ;

  {
#line 304
  tmp = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 304
  hostkeyalg = tmp;
#line 305
  if ((unsigned int )hostkeyalg == (unsigned int )((void *)0)) {
#line 306
    fatal("no hostkey alg");
  }
#line 307
  k->hostkey_type = key_type_from_name(hostkeyalg);
#line 308
  if (k->hostkey_type == 3) {
#line 309
    fatal("bad hostkey alg \'%s\'", hostkeyalg);
  }
#line 310
  xfree((void *)hostkeyalg);
#line 311
  return;
}
}
#line 316
static int proposals_match(char **my , char **peer ) ;
#line 316 "kex.c"
static int check___0[3]  = {      0,      1,      -1};
#line 313 "kex.c"
static int proposals_match(char **my , char **peer ) 
{ int *idx ;
  char *p ;
  char *tmp___0 ;
  char *tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 322
  idx = check___0;
#line 322
  while (*idx != -1) {
#line 323
    tmp___0 = __builtin_strchr(*(my + *idx), ',');
#line 323
    p = tmp___0;
#line 323
    if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 324
      *p = (char )'\000';
    }
#line 325
    tmp___2 = __builtin_strchr(*(peer + *idx), ',');
#line 325
    p = tmp___2;
#line 325
    if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 326
      *p = (char )'\000';
    }
#line 327
    if (0) {
#line 327
      __s1_len = strlen((char const   *)*(my + *idx));
#line 327
      __s2_len = strlen((char const   *)*(peer + *idx));
#line 327
      if (! ((unsigned int )((void const   *)(*(my + *idx) + 1)) - (unsigned int )((void const   *)*(my + *idx)) == 1U)) {
        goto _L___0;
      } else {
#line 327
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 327
          if (! ((unsigned int )((void const   *)(*(peer + *idx) + 1)) - (unsigned int )((void const   *)*(peer + *idx)) == 1U)) {
#line 327
            tmp___12 = 1;
          } else {
#line 327
            if (__s2_len >= 4U) {
#line 327
              tmp___12 = 1;
            } else {
#line 327
              tmp___12 = 0;
            }
          }
        } else {
#line 327
          tmp___12 = 0;
        }
      }
#line 327
      if (tmp___12) {
#line 327
        tmp___8 = __builtin_strcmp((char const   *)*(my + *idx), (char const   *)*(peer + *idx));
      } else {
#line 327
        tmp___11 = __builtin_strcmp((char const   *)*(my + *idx), (char const   *)*(peer + *idx));
#line 327
        tmp___8 = tmp___11;
      }
    } else {
#line 327
      tmp___11 = __builtin_strcmp((char const   *)*(my + *idx), (char const   *)*(peer + *idx));
#line 327
      tmp___8 = tmp___11;
    }
#line 327
    if (tmp___8 != 0) {
#line 328
      debug2("proposal mismatch: my %s peer %s", *(my + *idx), *(peer + *idx));
#line 330
      return (0);
    }
#line 322
    idx ++;
  }
#line 333
  debug2("proposals match");
#line 334
  return (1);
}
}
#line 337 "kex.c"
static void kex_choose_conf(Kex *kex ) 
{ Newkeys *newkeys___0 ;
  char **my ;
  char **peer ;
  char **cprop ;
  char **sprop ;
  int nenc ;
  int nmac ;
  int ncomp ;
  int mode ;
  int ctos ;
  int need ;
  int first_kex_follows ;
  int type ;
  void *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 349
  my = kex_buf2prop(& kex->my, (int *)((void *)0));
#line 350
  peer = kex_buf2prop(& kex->peer, & first_kex_follows);
#line 352
  if (kex->server) {
#line 353
    cprop = peer;
#line 354
    sprop = my;
  } else {
#line 356
    cprop = my;
#line 357
    sprop = peer;
  }
#line 361
  mode = 0;
#line 361
  while (mode < 2) {
#line 362
    tmp = xmalloc(sizeof(*newkeys___0));
#line 362
    newkeys___0 = (Newkeys *)tmp;
#line 363
    memset((void *)newkeys___0, 0, sizeof(*newkeys___0));
#line 364
    kex->newkeys[mode] = newkeys___0;
#line 365
    if (! kex->server) {
#line 365
      if (mode == 1) {
#line 365
        tmp___0 = 1;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 365
      if (kex->server) {
#line 365
        if (mode == 0) {
#line 365
          tmp___0 = 1;
        } else {
#line 365
          tmp___0 = 0;
        }
      } else {
#line 365
        tmp___0 = 0;
      }
    }
#line 365
    ctos = tmp___0;
#line 366
    if (ctos) {
#line 366
      nenc = 2;
    } else {
#line 366
      nenc = 3;
    }
#line 367
    if (ctos) {
#line 367
      nmac = 4;
    } else {
#line 367
      nmac = 5;
    }
#line 368
    if (ctos) {
#line 368
      ncomp = 6;
    } else {
#line 368
      ncomp = 7;
    }
#line 369
    choose_enc(& newkeys___0->enc, *(cprop + nenc), *(sprop + nenc));
#line 370
    choose_mac(& newkeys___0->mac, *(cprop + nmac), *(sprop + nmac));
#line 371
    choose_comp(& newkeys___0->comp, *(cprop + ncomp), *(sprop + ncomp));
#line 372
    if (ctos) {
#line 372
      tmp___1 = "client->server";
    } else {
#line 372
      tmp___1 = "server->client";
    }
#line 372
    debug("kex: %s %s %s %s", tmp___1, newkeys___0->enc.name, newkeys___0->mac.name,
          newkeys___0->comp.name);
#line 361
    mode ++;
  }
#line 378
  choose_kex(kex, *(cprop + 0), *(sprop + 0));
#line 379
  choose_hostkeyalg(kex, *(cprop + 1), *(sprop + 1));
#line 381
  need = 0;
#line 382
  mode = 0;
#line 382
  while (mode < 2) {
#line 383
    newkeys___0 = kex->newkeys[mode];
#line 384
    if ((u_int )need < newkeys___0->enc.key_len) {
#line 385
      need = (int )newkeys___0->enc.key_len;
    }
#line 386
    if ((u_int )need < newkeys___0->enc.block_size) {
#line 387
      need = (int )newkeys___0->enc.block_size;
    }
#line 388
    if (need < newkeys___0->mac.key_len) {
#line 389
      need = newkeys___0->mac.key_len;
    }
#line 382
    mode ++;
  }
#line 392
  kex->we_need = need;
#line 395
  if (first_kex_follows) {
#line 395
    tmp___2 = proposals_match((char **)my, (char **)peer);
#line 395
    if (! tmp___2) {
#line 395
      if (! (datafellows & 8388608)) {
#line 397
        type = packet_read();
#line 398
        debug2("skipping next packet (type %u)", type);
      }
    }
  }
#line 401
  kex_prop_free(my);
#line 402
  kex_prop_free(peer);
#line 403
  return;
}
}
#line 405 "kex.c"
static u_char *derive_key(Kex *kex , int id , int need , u_char *hash , BIGNUM *shared_secret ) 
{ Buffer b ;
  EVP_MD const   *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  char c ;
  int have ;
  int mdsz ;
  u_char *digest___1 ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  u_int tmp___3 ;
  void *tmp___4 ;

  {
#line 409
  tmp = EVP_sha1();
#line 409
  evp_md = tmp;
#line 411
  c = (char )id;
#line 413
  mdsz = (int )evp_md->md_size;
#line 414
  tmp___0 = xmalloc((unsigned int )(((need + (mdsz - 1)) / mdsz) * mdsz));
#line 414
  digest___1 = (u_char *)tmp___0;
#line 416
  buffer_init(& b);
#line 417
  buffer_put_bignum2(& b, (BIGNUM const   *)shared_secret);
#line 420
  EVP_DigestInit(& md, evp_md);
#line 421
  if (! (datafellows & 262144)) {
#line 422
    tmp___1 = buffer_len(& b);
#line 422
    tmp___2 = buffer_ptr(& b);
#line 422
    EVP_DigestUpdate(& md, (void const   *)tmp___2, tmp___1);
  }
#line 423
  EVP_DigestUpdate(& md, (void const   *)hash, (unsigned int )mdsz);
#line 424
  EVP_DigestUpdate(& md, (void const   *)(& c), 1U);
#line 425
  EVP_DigestUpdate(& md, (void const   *)kex->session_id, kex->session_id_len);
#line 426
  EVP_DigestFinal(& md, digest___1, (unsigned int *)((void *)0));
#line 433
  have = mdsz;
#line 433
  while (need > have) {
#line 434
    EVP_DigestInit(& md, evp_md);
#line 435
    if (! (datafellows & 262144)) {
#line 436
      tmp___3 = buffer_len(& b);
#line 436
      tmp___4 = buffer_ptr(& b);
#line 436
      EVP_DigestUpdate(& md, (void const   *)tmp___4, tmp___3);
    }
#line 437
    EVP_DigestUpdate(& md, (void const   *)hash, (unsigned int )mdsz);
#line 438
    EVP_DigestUpdate(& md, (void const   *)digest___1, (unsigned int )have);
#line 439
    EVP_DigestFinal(& md, digest___1 + have, (unsigned int *)((void *)0));
#line 433
    have += mdsz;
  }
#line 441
  buffer_free(& b);
#line 446
  return (digest___1);
}
}
#line 449 "kex.c"
Newkeys *current_keys[2]  ;
#line 452 "kex.c"
void kex_derive_keys(Kex *kex , u_char *hash , BIGNUM *shared_secret ) 
{ u_char *keys[6] ;
  int i ;
  int mode ;
  int ctos ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 458
  i = 0;
#line 458
  while (i < 6) {
#line 459
    keys[i] = derive_key(kex, 65 + i, kex->we_need, hash, shared_secret);
#line 458
    i ++;
  }
#line 461
  debug2("kex_derive_keys");
#line 462
  mode = 0;
#line 462
  while (mode < 2) {
#line 463
    current_keys[mode] = kex->newkeys[mode];
#line 464
    kex->newkeys[mode] = (Newkeys *)((void *)0);
#line 465
    if (! kex->server) {
#line 465
      if (mode == 1) {
#line 465
        tmp = 1;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 465
      if (kex->server) {
#line 465
        if (mode == 0) {
#line 465
          tmp = 1;
        } else {
#line 465
          tmp = 0;
        }
      } else {
#line 465
        tmp = 0;
      }
    }
#line 465
    ctos = tmp;
#line 466
    if (ctos) {
#line 466
      tmp___0 = 0;
    } else {
#line 466
      tmp___0 = 1;
    }
#line 466
    (current_keys[mode])->enc.iv = keys[tmp___0];
#line 467
    if (ctos) {
#line 467
      tmp___1 = 2;
    } else {
#line 467
      tmp___1 = 3;
    }
#line 467
    (current_keys[mode])->enc.key = keys[tmp___1];
#line 468
    if (ctos) {
#line 468
      tmp___2 = 4;
    } else {
#line 468
      tmp___2 = 5;
    }
#line 468
    (current_keys[mode])->mac.key = keys[tmp___2];
#line 462
    mode ++;
  }
#line 470
  return;
}
}
#line 472 "kex.c"
Newkeys *kex_get_newkeys(int mode ) 
{ Newkeys *ret ;

  {
#line 477
  ret = current_keys[mode];
#line 478
  current_keys[mode] = (Newkeys *)((void *)0);
#line 479
  return (ret);
}
}
#line 1 "mac.o"
#line 611 "/usr/include/openssl/evp.h"
extern EVP_MD const   *EVP_ripemd160(void) ;
#line 89 "/usr/include/openssl/hmac.h"
extern void HMAC_CTX_cleanup(HMAC_CTX *ctx ) ;
#line 93
extern void HMAC_Init(HMAC_CTX *ctx , void const   *key , int len , EVP_MD const   *md ) ;
#line 97
extern void HMAC_Update(HMAC_CTX *ctx , unsigned char const   *data , size_t len ) ;
#line 98
extern void HMAC_Final(HMAC_CTX *ctx , unsigned char *md , unsigned int *len ) ;
#line 26 "mac.h"
int mac_valid(char const   *names ) ;
#line 37 "mac.c"
struct __anonstruct_macs_77 macs[7]  = {      {(char *)"hmac-sha1", & EVP_sha1, 0}, 
        {(char *)"hmac-sha1-96", & EVP_sha1, 96}, 
        {(char *)"hmac-md5", & EVP_md5, 0}, 
        {(char *)"hmac-md5-96", & EVP_md5, 96}, 
        {(char *)"hmac-ripemd160", & EVP_ripemd160, 0}, 
        {(char *)"hmac-ripemd160@openssh.com", & EVP_ripemd160, 0}, 
        {(char *)((void *)0), (EVP_MD const   *(*)(void))((void *)0), 0}};
#line 51 "mac.c"
int mac_init(Mac *mac , char *name ) 
{ int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 55
  i = 0;
#line 55
  while (macs[i].name) {
#line 56
    if (0) {
#line 56
      __s1_len = strlen((char const   *)name);
#line 56
      __s2_len = strlen((char const   *)macs[i].name);
#line 56
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___0;
      } else {
#line 56
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 56
          if (! ((unsigned int )((void const   *)(macs[i].name + 1)) - (unsigned int )((void const   *)macs[i].name) == 1U)) {
#line 56
            tmp___8 = 1;
          } else {
#line 56
            if (__s2_len >= 4U) {
#line 56
              tmp___8 = 1;
            } else {
#line 56
              tmp___8 = 0;
            }
          }
        } else {
#line 56
          tmp___8 = 0;
        }
      }
#line 56
      if (tmp___8) {
#line 56
        tmp___4 = __builtin_strcmp((char const   *)name, (char const   *)macs[i].name);
      } else {
#line 56
        tmp___7 = __builtin_strcmp((char const   *)name, (char const   *)macs[i].name);
#line 56
        tmp___4 = tmp___7;
      }
    } else {
#line 56
      tmp___7 = __builtin_strcmp((char const   *)name, (char const   *)macs[i].name);
#line 56
      tmp___4 = tmp___7;
    }
#line 56
    if (tmp___4 == 0) {
#line 57
      if ((unsigned int )mac != (unsigned int )((void *)0)) {
#line 58
        mac->md = (*(macs[i].mdfunc))();
#line 59
        mac->mac_len = (int )(mac->md)->md_size;
#line 59
        mac->key_len = mac->mac_len;
#line 60
        if (macs[i].truncatebits != 0) {
#line 61
          mac->mac_len = macs[i].truncatebits / 8;
        }
      }
#line 63
      debug2("mac_init: found %s", name);
#line 64
      return (0);
    }
#line 55
    i ++;
  }
#line 67
  debug2("mac_init: unknown %s", name);
#line 68
  return (-1);
}
}
#line 75 "mac.c"
static u_char m[64]  ;
#line 71 "mac.c"
u_char *mac_compute(Mac *mac , u_int32_t seqno , u_char *data , int datalen ) 
{ HMAC_CTX c ;
  u_char b[4] ;

  {
#line 78
  if ((unsigned int )mac->key == (unsigned int )((void *)0)) {
#line 79
    fatal("mac_compute: no key");
  }
#line 80
  if ((unsigned int )mac->mac_len > sizeof(m)) {
#line 81
    fatal("mac_compute: mac too long");
  }
#line 82
  HMAC_Init(& c, (void const   *)mac->key, mac->key_len, mac->md);
#line 83
  while (1) {
#line 83
    b[0] = (unsigned char )(seqno >> 24);
#line 83
    b[1] = (unsigned char )(seqno >> 16);
#line 83
    b[2] = (unsigned char )(seqno >> 8);
#line 83
    b[3] = (unsigned char )seqno;
#line 83
    break;
  }
#line 84
  HMAC_Update(& c, (unsigned char const   *)(b), sizeof(b));
#line 85
  HMAC_Update(& c, (unsigned char const   *)data, (unsigned int )datalen);
#line 86
  HMAC_Final(& c, m, (unsigned int *)((void *)0));
#line 87
  HMAC_CTX_cleanup(& c);
#line 88
  return (m);
}
}
#line 93 "mac.c"
int mac_valid(char const   *names ) 
{ char *maclist ;
  char *cp ;
  char *p ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___24 ;
  char *tmp___40 ;
  int tmp___41 ;

  {
#line 98
  if ((unsigned int )names == (unsigned int )((void *)0)) {
#line 99
    return (0);
  } else {
#line 98
    if (0) {
#line 98
      __s1_len = strlen(names);
#line 98
      __s2_len = strlen("");
#line 98
      if (! ((unsigned int )((void const   *)(names + 1)) - (unsigned int )((void const   *)names) == 1U)) {
        goto _L___0;
      } else {
#line 98
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 98
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 98
            tmp___8 = 1;
          } else {
#line 98
            if (__s2_len >= 4U) {
#line 98
              tmp___8 = 1;
            } else {
#line 98
              tmp___8 = 0;
            }
          }
        } else {
#line 98
          tmp___8 = 0;
        }
      }
#line 98
      if (tmp___8) {
#line 98
        tmp___4 = __builtin_strcmp(names, "");
      } else {
#line 98
        tmp___7 = __builtin_strcmp(names, "");
#line 98
        tmp___4 = tmp___7;
      }
    } else {
#line 98
      tmp___7 = __builtin_strcmp(names, "");
#line 98
      tmp___4 = tmp___7;
    }
#line 98
    if (tmp___4 == 0) {
#line 99
      return (0);
    }
  }
#line 100
  cp = xstrdup(names);
#line 100
  maclist = cp;
#line 101
  tmp___24 = __strsep_g(& cp, ",");
#line 101
  p = tmp___24;
#line 101
  while (1) {
#line 101
    if (p) {
#line 101
      if (! ((int )*p != 0)) {
#line 101
        break;
      }
    } else {
#line 101
      break;
    }
#line 103
    tmp___41 = mac_init((Mac *)((void *)0), p);
#line 103
    if (tmp___41 < 0) {
#line 104
      debug("bad mac %s [%s]", p, names);
#line 105
      xfree((void *)maclist);
#line 106
      return (0);
    } else {
#line 108
      debug3("mac ok: %s [%s]", p, names);
    }
#line 102
    tmp___40 = __strsep_g(& cp, ",");
#line 102
    p = tmp___40;
  }
#line 111
  debug3("macs ok: [%s]", names);
#line 112
  xfree((void *)maclist);
#line 113
  return (1);
}
}
#line 1 "uuencode.o"
#line 31 "uuencode.h"
void dump_base64(FILE *fp , u_char *data , u_int len ) ;
#line 31 "uuencode.c"
int uuencode(u_char const   *src , u_int srclength , char *target , size_t targsize ) 
{ int tmp ;

  {
#line 35
  tmp = __b64_ntop(src, srclength, target, targsize);
#line 35
  return (tmp);
}
}
#line 38 "uuencode.c"
int uudecode(char const   *src , u_char *target , size_t targsize ) 
{ int len ;
  char *encoded ;
  char *p ;

  {
#line 45
  encoded = xstrdup(src);
#line 47
  p = encoded;
#line 47
  while (1) {
#line 47
    if (! ((int )*p == 32)) {
#line 47
      if (! ((int )*p == 9)) {
#line 47
        break;
      }
    }
#line 47
    p ++;
  }
#line 49
  while (1) {
#line 49
    if ((int )*p != 0) {
#line 49
      if ((int )*p != 32) {
#line 49
        if (! ((int )*p != 9)) {
#line 49
          break;
        }
      } else {
#line 49
        break;
      }
    } else {
#line 49
      break;
    }
#line 49
    p ++;
  }
#line 52
  *p = (char )'\000';
#line 53
  len = __b64_pton((char const   *)encoded, target, targsize);
#line 54
  xfree((void *)encoded);
#line 55
  return (len);
}
}
#line 58 "uuencode.c"
void dump_base64(FILE *fp , u_char *data , u_int len ) 
{ char *buf___1 ;
  void *tmp ;
  int i ;
  int n___0 ;

  {
#line 61
  tmp = xmalloc(2U * len);
#line 61
  buf___1 = (char *)tmp;
#line 64
  n___0 = uuencode((u_char const   *)data, len, buf___1, 2U * len);
#line 65
  i = 0;
#line 65
  while (i < n___0) {
#line 66
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%c", *(buf___1 + i));
#line 67
    if (i % 70 == 69) {
#line 68
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
    }
#line 65
    i ++;
  }
#line 70
  if (i % 70 != 69) {
#line 71
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  }
#line 72
  xfree((void *)buf___1);
#line 73
  return;
}
}
/* compiler builtin: 
   char *__builtin_strpbrk(char const   * , char const   * ) ;  */
#line 1 "misc.o"
#line 184 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 15 "misc.h"
char *chop(char *s ) ;
#line 16
char *strdelim(char **s ) ;
#line 18
void unset_nonblock(int fd ) ;
#line 20
int a2port(char const   *s ) ;
#line 21
char *cleanhostname(char *host ) ;
#line 22
char *colon(char *cp ) ;
#line 23
long convtime(char const   *s ) ;
#line 25
struct passwd *pwcopy(struct passwd *pw ) ;
#line 33
void ( /* format attribute */  addargs)(arglist *args , char *fmt  , ...) ;
#line 33 "misc.c"
char *chop(char *s ) 
{ char *t ;

  {
#line 36
  t = s;
#line 37
  while (*t) {
#line 38
    if ((int )*t == 10) {
#line 39
      *t = (char )'\000';
#line 40
      return (s);
    } else {
#line 38
      if ((int )*t == 13) {
#line 39
        *t = (char )'\000';
#line 40
        return (s);
      }
    }
#line 42
    t ++;
  }
#line 44
  return (s);
}
}
#line 49 "misc.c"
void set_nonblock(int fd ) 
{ int val ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 54
  val = fcntl(fd, 3, 0);
#line 55
  if (val < 0) {
#line 56
    tmp = __errno_location();
#line 56
    tmp___0 = strerror(*tmp);
#line 56
    error("fcntl(%d, F_GETFL, 0): %s", fd, tmp___0);
#line 57
    return;
  }
#line 59
  if (val & 2048) {
#line 60
    debug2("fd %d is O_NONBLOCK", fd);
#line 61
    return;
  }
#line 63
  debug2("fd %d setting O_NONBLOCK", fd);
#line 64
  val |= 2048;
#line 65
  tmp___3 = fcntl(fd, 4, val);
#line 65
  if (tmp___3 == -1) {
#line 66
    tmp___1 = __errno_location();
#line 66
    tmp___2 = strerror(*tmp___1);
#line 66
    debug("fcntl(%d, F_SETFL, O_NONBLOCK): %s", fd, tmp___2);
  }
#line 68
  return;
}
}
#line 70 "misc.c"
void unset_nonblock(int fd ) 
{ int val ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 75
  val = fcntl(fd, 3, 0);
#line 76
  if (val < 0) {
#line 77
    tmp = __errno_location();
#line 77
    tmp___0 = strerror(*tmp);
#line 77
    error("fcntl(%d, F_GETFL, 0): %s", fd, tmp___0);
#line 78
    return;
  }
#line 80
  if (! (val & 2048)) {
#line 81
    debug2("fd %d is not O_NONBLOCK", fd);
#line 82
    return;
  }
#line 84
  debug("fd %d clearing O_NONBLOCK", fd);
#line 85
  val &= -2049;
#line 86
  tmp___3 = fcntl(fd, 4, val);
#line 86
  if (tmp___3 == -1) {
#line 87
    tmp___1 = __errno_location();
#line 87
    tmp___2 = strerror(*tmp___1);
#line 87
    debug("fcntl(%d, F_SETFL, O_NONBLOCK): %s", fd, tmp___2);
  }
#line 89
  return;
}
}
#line 92 "misc.c"
void set_nodelay(int fd ) 
{ int opt ;
  socklen_t optlen ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 98
  optlen = sizeof(opt);
#line 99
  tmp___1 = getsockopt(fd, 6, 1, (void * __restrict  )(& opt), (socklen_t * __restrict  )(& optlen));
#line 99
  if (tmp___1 == -1) {
#line 100
    tmp = __errno_location();
#line 100
    tmp___0 = strerror(*tmp);
#line 100
    debug("getsockopt TCP_NODELAY: %.100s", tmp___0);
#line 101
    return;
  }
#line 103
  if (opt == 1) {
#line 104
    debug2("fd %d is TCP_NODELAY", fd);
#line 105
    return;
  }
#line 107
  opt = 1;
#line 108
  debug2("fd %d setting TCP_NODELAY", fd);
#line 109
  tmp___4 = setsockopt(fd, 6, 1, (void const   *)(& opt), sizeof(opt));
#line 109
  if (tmp___4 == -1) {
#line 110
    tmp___2 = __errno_location();
#line 110
    tmp___3 = strerror(*tmp___2);
#line 110
    error("setsockopt TCP_NODELAY: %.100s", tmp___3);
  }
#line 111
  return;
}
}
#line 117 "misc.c"
char *strdelim(char **s ) 
{ char *old ;
  int wspace ;
  char *tmp___30 ;
  unsigned int tmp___62 ;
  unsigned int tmp___94 ;

  {
#line 121
  wspace = 0;
#line 123
  if ((unsigned int )*s == (unsigned int )((void *)0)) {
#line 124
    return ((char *)((void *)0));
  }
#line 126
  old = *s;
#line 128
  tmp___30 = __builtin_strpbrk((char const   *)*s, " \t\r\n=");
#line 128
  *s = tmp___30;
#line 129
  if ((unsigned int )*s == (unsigned int )((void *)0)) {
#line 130
    return (old);
  }
#line 133
  if ((int )*(*(s + 0)) == 61) {
#line 134
    wspace = 1;
  }
#line 135
  *(*(s + 0)) = (char )'\000';
#line 137
  tmp___62 = __builtin_strspn((char const   *)(*s + 1), " \t\r\n");
#line 137
  *s += tmp___62 + 1U;
#line 138
  if ((int )*(*(s + 0)) == 61) {
#line 138
    if (! wspace) {
#line 139
      tmp___94 = __builtin_strspn((char const   *)(*s + 1), " \t\r\n");
#line 139
      *s += tmp___94 + 1U;
    }
  }
#line 141
  return (old);
}
}
#line 144 "misc.c"
struct passwd *pwcopy(struct passwd *pw ) 
{ struct passwd *copy ;
  void *tmp ;

  {
#line 147
  tmp = xmalloc(sizeof(*copy));
#line 147
  copy = (struct passwd *)tmp;
#line 149
  memset((void *)copy, 0, sizeof(*copy));
#line 150
  copy->pw_name = xstrdup((char const   *)pw->pw_name);
#line 151
  copy->pw_passwd = xstrdup((char const   *)pw->pw_passwd);
#line 152
  copy->pw_gecos = xstrdup((char const   *)pw->pw_gecos);
#line 153
  copy->pw_uid = pw->pw_uid;
#line 154
  copy->pw_gid = pw->pw_gid;
#line 164
  copy->pw_dir = xstrdup((char const   *)pw->pw_dir);
#line 165
  copy->pw_shell = xstrdup((char const   *)pw->pw_shell);
#line 166
  return (copy);
}
}
#line 174 "misc.c"
int a2port(char const   *s ) 
{ long port ;
  char *endp ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 180
  tmp = __errno_location();
#line 180
  *tmp = 0;
#line 181
  port = strtol((char const   * __restrict  )s, (char ** __restrict  )(& endp), 0);
#line 182
  if ((unsigned int )s == (unsigned int )endp) {
#line 185
    return (0);
  } else {
#line 182
    if ((int )*endp != 0) {
#line 185
      return (0);
    } else {
#line 182
      tmp___0 = __errno_location();
#line 182
      if (*tmp___0 == 34) {
#line 182
        if (port == (-0x7FFFFFFF-1)) {
#line 185
          return (0);
        } else {
#line 182
          if (port == 2147483647L) {
#line 185
            return (0);
          } else {
            goto _L;
          }
        }
      } else {
        _L: /* CIL Label */ 
#line 182
        if (port <= 0L) {
#line 185
          return (0);
        } else {
#line 182
          if (port > 65535L) {
#line 185
            return (0);
          }
        }
      }
    }
  }
#line 187
  return ((int )port);
}
}
#line 217 "misc.c"
long convtime(char const   *s ) 
{ long total ;
  long secs ;
  char const   *p ;
  char *endp ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 224
  tmp = __errno_location();
#line 224
  *tmp = 0;
#line 225
  total = 0L;
#line 226
  p = s;
#line 228
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 229
    return (-1L);
  } else {
#line 228
    if ((int const   )*p == 0) {
#line 229
      return (-1L);
    }
  }
#line 231
  while (*p) {
#line 232
    secs = strtol((char const   * __restrict  )p, (char ** __restrict  )(& endp),
                  10);
#line 233
    if ((unsigned int )p == (unsigned int )endp) {
#line 236
      return (-1L);
    } else {
#line 233
      tmp___0 = __errno_location();
#line 233
      if (*tmp___0 == 34) {
#line 233
        if (secs == (-0x7FFFFFFF-1)) {
#line 236
          return (-1L);
        } else {
#line 233
          if (secs == 2147483647L) {
#line 236
            return (-1L);
          } else {
            goto _L;
          }
        }
      } else {
        _L: /* CIL Label */ 
#line 233
        if (secs < 0L) {
#line 236
          return (-1L);
        }
      }
    }
#line 238
    tmp___1 = endp;
#line 238
    endp ++;
#line 238
    switch ((int )*tmp___1) {
    case 0: 
#line 240
    endp --;
    case 115: 
    case 83: 
#line 243
    break;
    case 109: 
    case 77: 
#line 246
    secs *= 60L;
#line 247
    break;
    case 104: 
    case 72: 
#line 250
    secs *= 3600L;
#line 251
    break;
    case 100: 
    case 68: 
#line 254
    secs *= 86400L;
#line 255
    break;
    case 119: 
    case 87: 
#line 258
    secs *= 604800L;
#line 259
    break;
    default: ;
#line 261
    return (-1L);
    }
#line 263
    total += secs;
#line 264
    if (total < 0L) {
#line 265
      return (-1L);
    }
#line 266
    p = (char const   *)endp;
  }
#line 269
  return (total);
}
}
#line 272 "misc.c"
char *cleanhostname(char *host ) 
{ size_t tmp ;
  size_t tmp___0 ;

  {
#line 275
  if ((int )*host == 91) {
#line 275
    tmp___0 = strlen((char const   *)host);
#line 275
    if ((int )*(host + (tmp___0 - 1U)) == 93) {
#line 276
      tmp = strlen((char const   *)host);
#line 276
      *(host + (tmp - 1U)) = (char )'\000';
#line 277
      return (host + 1);
    } else {
#line 279
      return (host);
    }
  } else {
#line 279
    return (host);
  }
}
}
#line 282 "misc.c"
char *colon(char *cp ) 
{ int flag ;

  {
#line 285
  flag = 0;
#line 287
  if ((int )*cp == 58) {
#line 288
    return ((char *)0);
  }
#line 289
  if ((int )*cp == 91) {
#line 290
    flag = 1;
  }
#line 292
  while (*cp) {
#line 293
    if ((int )*cp == 64) {
#line 293
      if ((int )*(cp + 1) == 91) {
#line 294
        flag = 1;
      }
    }
#line 295
    if ((int )*cp == 93) {
#line 295
      if ((int )*(cp + 1) == 58) {
#line 295
        if (flag) {
#line 296
          return (cp + 1);
        }
      }
    }
#line 297
    if ((int )*cp == 58) {
#line 297
      if (! flag) {
#line 298
        return (cp);
      }
    }
#line 299
    if ((int )*cp == 47) {
#line 300
      return ((char *)0);
    }
#line 292
    cp ++;
  }
#line 302
  return ((char *)0);
}
}
#line 306 "misc.c"
void ( /* format attribute */  addargs)(arglist *args , char *fmt  , ...) 
{ va_list ap ;
  char buf___1[1024] ;
  int nalloc ;
  void *tmp ;
  int tmp___0 ;

  {
#line 313
  __builtin_va_start(ap, fmt);
#line 314
  vsnprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )fmt,
            ap);
#line 315
  __builtin_va_end(ap);
#line 317
  nalloc = args->nalloc;
#line 318
  if ((unsigned int )args->list == (unsigned int )((void *)0)) {
#line 319
    nalloc = 32;
#line 320
    args->num = 0;
  } else {
#line 321
    if (args->num + 2 >= nalloc) {
#line 322
      nalloc *= 2;
    }
  }
#line 324
  tmp = xrealloc((void *)args->list, (unsigned int )nalloc * sizeof(char *));
#line 324
  args->list = (char **)tmp;
#line 325
  args->nalloc = nalloc;
#line 326
  tmp___0 = args->num;
#line 326
  (args->num) ++;
#line 326
  *(args->list + tmp___0) = xstrdup((char const   *)(buf___1));
#line 327
  *(args->list + args->num) = (char *)((void *)0);
#line 328
  return;
}
}
#line 1 "rijndael.o"
#line 47 "rijndael.h"
void rijndael_set_key(rijndael_ctx *ctx , u_char *key , int bits , int encrypt ) ;
#line 48
void rijndael_decrypt(rijndael_ctx *ctx , u_char *src , u_char *dst ) ;
#line 49
void rijndael_encrypt(rijndael_ctx *ctx , u_char *src , u_char *dst ) ;
#line 51 "rijndael.c"
static u32 const   Te0[256]  = 
#line 51 "rijndael.c"
  {      (u32 const   )3328402341U,      (u32 const   )4168907908U,      (u32 const   )4000806809U,      (u32 const   )4135287693U, 
        (u32 const   )4294111757U,      (u32 const   )3597364157U,      (u32 const   )3731845041U,      (u32 const   )2445657428U, 
        (u32 const   )1613770832U,      (u32 const   )33620227U,      (u32 const   )3462883241U,      (u32 const   )1445669757U, 
        (u32 const   )3892248089U,      (u32 const   )3050821474U,      (u32 const   )1303096294U,      (u32 const   )3967186586U, 
        (u32 const   )2412431941U,      (u32 const   )528646813U,      (u32 const   )2311702848U,      (u32 const   )4202528135U, 
        (u32 const   )4026202645U,      (u32 const   )2992200171U,      (u32 const   )2387036105U,      (u32 const   )4226871307U, 
        (u32 const   )1101901292U,      (u32 const   )3017069671U,      (u32 const   )1604494077U,      (u32 const   )1169141738U, 
        (u32 const   )597466303U,      (u32 const   )1403299063U,      (u32 const   )3832705686U,      (u32 const   )2613100635U, 
        (u32 const   )1974974402U,      (u32 const   )3791519004U,      (u32 const   )1033081774U,      (u32 const   )1277568618U, 
        (u32 const   )1815492186U,      (u32 const   )2118074177U,      (u32 const   )4126668546U,      (u32 const   )2211236943U, 
        (u32 const   )1748251740U,      (u32 const   )1369810420U,      (u32 const   )3521504564U,      (u32 const   )4193382664U, 
        (u32 const   )3799085459U,      (u32 const   )2883115123U,      (u32 const   )1647391059U,      (u32 const   )706024767U, 
        (u32 const   )134480908U,      (u32 const   )2512897874U,      (u32 const   )1176707941U,      (u32 const   )2646852446U, 
        (u32 const   )806885416U,      (u32 const   )932615841U,      (u32 const   )168101135U,      (u32 const   )798661301U, 
        (u32 const   )235341577U,      (u32 const   )605164086U,      (u32 const   )461406363U,      (u32 const   )3756188221U, 
        (u32 const   )3454790438U,      (u32 const   )1311188841U,      (u32 const   )2142417613U,      (u32 const   )3933566367U, 
        (u32 const   )302582043U,      (u32 const   )495158174U,      (u32 const   )1479289972U,      (u32 const   )874125870U, 
        (u32 const   )907746093U,      (u32 const   )3698224818U,      (u32 const   )3025820398U,      (u32 const   )1537253627U, 
        (u32 const   )2756858614U,      (u32 const   )1983593293U,      (u32 const   )3084310113U,      (u32 const   )2108928974U, 
        (u32 const   )1378429307U,      (u32 const   )3722699582U,      (u32 const   )1580150641U,      (u32 const   )327451799U, 
        (u32 const   )2790478837U,      (u32 const   )3117535592U,      (u32 const   )0U,      (u32 const   )3253595436U, 
        (u32 const   )1075847264U,      (u32 const   )3825007647U,      (u32 const   )2041688520U,      (u32 const   )3059440621U, 
        (u32 const   )3563743934U,      (u32 const   )2378943302U,      (u32 const   )1740553945U,      (u32 const   )1916352843U, 
        (u32 const   )2487896798U,      (u32 const   )2555137236U,      (u32 const   )2958579944U,      (u32 const   )2244988746U, 
        (u32 const   )3151024235U,      (u32 const   )3320835882U,      (u32 const   )1336584933U,      (u32 const   )3992714006U, 
        (u32 const   )2252555205U,      (u32 const   )2588757463U,      (u32 const   )1714631509U,      (u32 const   )293963156U, 
        (u32 const   )2319795663U,      (u32 const   )3925473552U,      (u32 const   )67240454U,      (u32 const   )4269768577U, 
        (u32 const   )2689618160U,      (u32 const   )2017213508U,      (u32 const   )631218106U,      (u32 const   )1269344483U, 
        (u32 const   )2723238387U,      (u32 const   )1571005438U,      (u32 const   )2151694528U,      (u32 const   )93294474U, 
        (u32 const   )1066570413U,      (u32 const   )563977660U,      (u32 const   )1882732616U,      (u32 const   )4059428100U, 
        (u32 const   )1673313503U,      (u32 const   )2008463041U,      (u32 const   )2950355573U,      (u32 const   )1109467491U, 
        (u32 const   )537923632U,      (u32 const   )3858759450U,      (u32 const   )4260623118U,      (u32 const   )3218264685U, 
        (u32 const   )2177748300U,      (u32 const   )403442708U,      (u32 const   )638784309U,      (u32 const   )3287084079U, 
        (u32 const   )3193921505U,      (u32 const   )899127202U,      (u32 const   )2286175436U,      (u32 const   )773265209U, 
        (u32 const   )2479146071U,      (u32 const   )1437050866U,      (u32 const   )4236148354U,      (u32 const   )2050833735U, 
        (u32 const   )3362022572U,      (u32 const   )3126681063U,      (u32 const   )840505643U,      (u32 const   )3866325909U, 
        (u32 const   )3227541664U,      (u32 const   )427917720U,      (u32 const   )2655997905U,      (u32 const   )2749160575U, 
        (u32 const   )1143087718U,      (u32 const   )1412049534U,      (u32 const   )999329963U,      (u32 const   )193497219U, 
        (u32 const   )2353415882U,      (u32 const   )3354324521U,      (u32 const   )1807268051U,      (u32 const   )672404540U, 
        (u32 const   )2816401017U,      (u32 const   )3160301282U,      (u32 const   )369822493U,      (u32 const   )2916866934U, 
        (u32 const   )3688947771U,      (u32 const   )1681011286U,      (u32 const   )1949973070U,      (u32 const   )336202270U, 
        (u32 const   )2454276571U,      (u32 const   )201721354U,      (u32 const   )1210328172U,      (u32 const   )3093060836U, 
        (u32 const   )2680341085U,      (u32 const   )3184776046U,      (u32 const   )1135389935U,      (u32 const   )3294782118U, 
        (u32 const   )965841320U,      (u32 const   )831886756U,      (u32 const   )3554993207U,      (u32 const   )4068047243U, 
        (u32 const   )3588745010U,      (u32 const   )2345191491U,      (u32 const   )1849112409U,      (u32 const   )3664604599U, 
        (u32 const   )26054028U,      (u32 const   )2983581028U,      (u32 const   )2622377682U,      (u32 const   )1235855840U, 
        (u32 const   )3630984372U,      (u32 const   )2891339514U,      (u32 const   )4092916743U,      (u32 const   )3488279077U, 
        (u32 const   )3395642799U,      (u32 const   )4101667470U,      (u32 const   )1202630377U,      (u32 const   )268961816U, 
        (u32 const   )1874508501U,      (u32 const   )4034427016U,      (u32 const   )1243948399U,      (u32 const   )1546530418U, 
        (u32 const   )941366308U,      (u32 const   )1470539505U,      (u32 const   )1941222599U,      (u32 const   )2546386513U, 
        (u32 const   )3421038627U,      (u32 const   )2715671932U,      (u32 const   )3899946140U,      (u32 const   )1042226977U, 
        (u32 const   )2521517021U,      (u32 const   )1639824860U,      (u32 const   )227249030U,      (u32 const   )260737669U, 
        (u32 const   )3765465232U,      (u32 const   )2084453954U,      (u32 const   )1907733956U,      (u32 const   )3429263018U, 
        (u32 const   )2420656344U,      (u32 const   )100860677U,      (u32 const   )4160157185U,      (u32 const   )470683154U, 
        (u32 const   )3261161891U,      (u32 const   )1781871967U,      (u32 const   )2924959737U,      (u32 const   )1773779408U, 
        (u32 const   )394692241U,      (u32 const   )2579611992U,      (u32 const   )974986535U,      (u32 const   )664706745U, 
        (u32 const   )3655459128U,      (u32 const   )3958962195U,      (u32 const   )731420851U,      (u32 const   )571543859U, 
        (u32 const   )3530123707U,      (u32 const   )2849626480U,      (u32 const   )126783113U,      (u32 const   )865375399U, 
        (u32 const   )765172662U,      (u32 const   )1008606754U,      (u32 const   )361203602U,      (u32 const   )3387549984U, 
        (u32 const   )2278477385U,      (u32 const   )2857719295U,      (u32 const   )1344809080U,      (u32 const   )2782912378U, 
        (u32 const   )59542671U,      (u32 const   )1503764984U,      (u32 const   )160008576U,      (u32 const   )437062935U, 
        (u32 const   )1707065306U,      (u32 const   )3622233649U,      (u32 const   )2218934982U,      (u32 const   )3496503480U, 
        (u32 const   )2185314755U,      (u32 const   )697932208U,      (u32 const   )1512910199U,      (u32 const   )504303377U, 
        (u32 const   )2075177163U,      (u32 const   )2824099068U,      (u32 const   )1841019862U,      (u32 const   )739644986U};
#line 117 "rijndael.c"
static u32 const   Te1[256]  = 
#line 117
  {      (u32 const   )2781242211U,      (u32 const   )2230877308U,      (u32 const   )2582542199U,      (u32 const   )2381740923U, 
        (u32 const   )234877682U,      (u32 const   )3184946027U,      (u32 const   )2984144751U,      (u32 const   )1418839493U, 
        (u32 const   )1348481072U,      (u32 const   )50462977U,      (u32 const   )2848876391U,      (u32 const   )2102799147U, 
        (u32 const   )434634494U,      (u32 const   )1656084439U,      (u32 const   )3863849899U,      (u32 const   )2599188086U, 
        (u32 const   )1167051466U,      (u32 const   )2636087938U,      (u32 const   )1082771913U,      (u32 const   )2281340285U, 
        (u32 const   )368048890U,      (u32 const   )3954334041U,      (u32 const   )3381544775U,      (u32 const   )201060592U, 
        (u32 const   )3963727277U,      (u32 const   )1739838676U,      (u32 const   )4250903202U,      (u32 const   )3930435503U, 
        (u32 const   )3206782108U,      (u32 const   )4149453988U,      (u32 const   )2531553906U,      (u32 const   )1536934080U, 
        (u32 const   )3262494647U,      (u32 const   )484572669U,      (u32 const   )2923271059U,      (u32 const   )1783375398U, 
        (u32 const   )1517041206U,      (u32 const   )1098792767U,      (u32 const   )49674231U,      (u32 const   )1334037708U, 
        (u32 const   )1550332980U,      (u32 const   )4098991525U,      (u32 const   )886171109U,      (u32 const   )150598129U, 
        (u32 const   )2481090929U,      (u32 const   )1940642008U,      (u32 const   )1398944049U,      (u32 const   )1059722517U, 
        (u32 const   )201851908U,      (u32 const   )1385547719U,      (u32 const   )1699095331U,      (u32 const   )1587397571U, 
        (u32 const   )674240536U,      (u32 const   )2704774806U,      (u32 const   )252314885U,      (u32 const   )3039795866U, 
        (u32 const   )151914247U,      (u32 const   )908333586U,      (u32 const   )2602270848U,      (u32 const   )1038082786U, 
        (u32 const   )651029483U,      (u32 const   )1766729511U,      (u32 const   )3447698098U,      (u32 const   )2682942837U, 
        (u32 const   )454166793U,      (u32 const   )2652734339U,      (u32 const   )1951935532U,      (u32 const   )775166490U, 
        (u32 const   )758520603U,      (u32 const   )3000790638U,      (u32 const   )4004797018U,      (u32 const   )4217086112U, 
        (u32 const   )4137964114U,      (u32 const   )1299594043U,      (u32 const   )1639438038U,      (u32 const   )3464344499U, 
        (u32 const   )2068982057U,      (u32 const   )1054729187U,      (u32 const   )1901997871U,      (u32 const   )2534638724U, 
        (u32 const   )4121318227U,      (u32 const   )1757008337U,      (u32 const   )0U,      (u32 const   )750906861U, 
        (u32 const   )1614815264U,      (u32 const   )535035132U,      (u32 const   )3363418545U,      (u32 const   )3988151131U, 
        (u32 const   )3201591914U,      (u32 const   )1183697867U,      (u32 const   )3647454910U,      (u32 const   )1265776953U, 
        (u32 const   )3734260298U,      (u32 const   )3566750796U,      (u32 const   )3903871064U,      (u32 const   )1250283471U, 
        (u32 const   )1807470800U,      (u32 const   )717615087U,      (u32 const   )3847203498U,      (u32 const   )384695291U, 
        (u32 const   )3313910595U,      (u32 const   )3617213773U,      (u32 const   )1432761139U,      (u32 const   )2484176261U, 
        (u32 const   )3481945413U,      (u32 const   )283769337U,      (u32 const   )100925954U,      (u32 const   )2180939647U, 
        (u32 const   )4037038160U,      (u32 const   )1148730428U,      (u32 const   )3123027871U,      (u32 const   )3813386408U, 
        (u32 const   )4087501137U,      (u32 const   )4267549603U,      (u32 const   )3229630528U,      (u32 const   )2315620239U, 
        (u32 const   )2906624658U,      (u32 const   )3156319645U,      (u32 const   )1215313976U,      (u32 const   )82966005U, 
        (u32 const   )3747855548U,      (u32 const   )3245848246U,      (u32 const   )1974459098U,      (u32 const   )1665278241U, 
        (u32 const   )807407632U,      (u32 const   )451280895U,      (u32 const   )251524083U,      (u32 const   )1841287890U, 
        (u32 const   )1283575245U,      (u32 const   )337120268U,      (u32 const   )891687699U,      (u32 const   )801369324U, 
        (u32 const   )3787349855U,      (u32 const   )2721421207U,      (u32 const   )3431482436U,      (u32 const   )959321879U, 
        (u32 const   )1469301956U,      (u32 const   )4065699751U,      (u32 const   )2197585534U,      (u32 const   )1199193405U, 
        (u32 const   )2898814052U,      (u32 const   )3887750493U,      (u32 const   )724703513U,      (u32 const   )2514908019U, 
        (u32 const   )2696962144U,      (u32 const   )2551808385U,      (u32 const   )3516813135U,      (u32 const   )2141445340U, 
        (u32 const   )1715741218U,      (u32 const   )2119445034U,      (u32 const   )2872807568U,      (u32 const   )2198571144U, 
        (u32 const   )3398190662U,      (u32 const   )700968686U,      (u32 const   )3547052216U,      (u32 const   )1009259540U, 
        (u32 const   )2041044702U,      (u32 const   )3803995742U,      (u32 const   )487983883U,      (u32 const   )1991105499U, 
        (u32 const   )1004265696U,      (u32 const   )1449407026U,      (u32 const   )1316239930U,      (u32 const   )504629770U, 
        (u32 const   )3683797321U,      (u32 const   )168560134U,      (u32 const   )1816667172U,      (u32 const   )3837287516U, 
        (u32 const   )1570751170U,      (u32 const   )1857934291U,      (u32 const   )4014189740U,      (u32 const   )2797888098U, 
        (u32 const   )2822345105U,      (u32 const   )2754712981U,      (u32 const   )936633572U,      (u32 const   )2347923833U, 
        (u32 const   )852879335U,      (u32 const   )1133234376U,      (u32 const   )1500395319U,      (u32 const   )3084545389U, 
        (u32 const   )2348912013U,      (u32 const   )1689376213U,      (u32 const   )3533459022U,      (u32 const   )3762923945U, 
        (u32 const   )3034082412U,      (u32 const   )4205598294U,      (u32 const   )133428468U,      (u32 const   )634383082U, 
        (u32 const   )2949277029U,      (u32 const   )2398386810U,      (u32 const   )3913789102U,      (u32 const   )403703816U, 
        (u32 const   )3580869306U,      (u32 const   )2297460856U,      (u32 const   )1867130149U,      (u32 const   )1918643758U, 
        (u32 const   )607656988U,      (u32 const   )4049053350U,      (u32 const   )3346248884U,      (u32 const   )1368901318U, 
        (u32 const   )600565992U,      (u32 const   )2090982877U,      (u32 const   )2632479860U,      (u32 const   )557719327U, 
        (u32 const   )3717614411U,      (u32 const   )3697393085U,      (u32 const   )2249034635U,      (u32 const   )2232388234U, 
        (u32 const   )2430627952U,      (u32 const   )1115438654U,      (u32 const   )3295786421U,      (u32 const   )2865522278U, 
        (u32 const   )3633334344U,      (u32 const   )84280067U,      (u32 const   )33027830U,      (u32 const   )303828494U, 
        (u32 const   )2747425121U,      (u32 const   )1600795957U,      (u32 const   )4188952407U,      (u32 const   )3496589753U, 
        (u32 const   )2434238086U,      (u32 const   )1486471617U,      (u32 const   )658119965U,      (u32 const   )3106381470U, 
        (u32 const   )953803233U,      (u32 const   )334231800U,      (u32 const   )3005978776U,      (u32 const   )857870609U, 
        (u32 const   )3151128937U,      (u32 const   )1890179545U,      (u32 const   )2298973838U,      (u32 const   )2805175444U, 
        (u32 const   )3056442267U,      (u32 const   )574365214U,      (u32 const   )2450884487U,      (u32 const   )550103529U, 
        (u32 const   )1233637070U,      (u32 const   )4289353045U,      (u32 const   )2018519080U,      (u32 const   )2057691103U, 
        (u32 const   )2399374476U,      (u32 const   )4166623649U,      (u32 const   )2148108681U,      (u32 const   )387583245U, 
        (u32 const   )3664101311U,      (u32 const   )836232934U,      (u32 const   )3330556482U,      (u32 const   )3100665960U, 
        (u32 const   )3280093505U,      (u32 const   )2955516313U,      (u32 const   )2002398509U,      (u32 const   )287182607U, 
        (u32 const   )3413881008U,      (u32 const   )4238890068U,      (u32 const   )3597515707U,      (u32 const   )975967766U};
#line 183 "rijndael.c"
static u32 const   Te2[256]  = 
#line 183
  {      (u32 const   )1671808611U,      (u32 const   )2089089148U,      (u32 const   )2006576759U,      (u32 const   )2072901243U, 
        (u32 const   )4061003762U,      (u32 const   )1807603307U,      (u32 const   )1873927791U,      (u32 const   )3310653893U, 
        (u32 const   )810573872U,      (u32 const   )16974337U,      (u32 const   )1739181671U,      (u32 const   )729634347U, 
        (u32 const   )4263110654U,      (u32 const   )3613570519U,      (u32 const   )2883997099U,      (u32 const   )1989864566U, 
        (u32 const   )3393556426U,      (u32 const   )2191335298U,      (u32 const   )3376449993U,      (u32 const   )2106063485U, 
        (u32 const   )4195741690U,      (u32 const   )1508618841U,      (u32 const   )1204391495U,      (u32 const   )4027317232U, 
        (u32 const   )2917941677U,      (u32 const   )3563566036U,      (u32 const   )2734514082U,      (u32 const   )2951366063U, 
        (u32 const   )2629772188U,      (u32 const   )2767672228U,      (u32 const   )1922491506U,      (u32 const   )3227229120U, 
        (u32 const   )3082974647U,      (u32 const   )4246528509U,      (u32 const   )2477669779U,      (u32 const   )644500518U, 
        (u32 const   )911895606U,      (u32 const   )1061256767U,      (u32 const   )4144166391U,      (u32 const   )3427763148U, 
        (u32 const   )878471220U,      (u32 const   )2784252325U,      (u32 const   )3845444069U,      (u32 const   )4043897329U, 
        (u32 const   )1905517169U,      (u32 const   )3631459288U,      (u32 const   )827548209U,      (u32 const   )356461077U, 
        (u32 const   )67897348U,      (u32 const   )3344078279U,      (u32 const   )593839651U,      (u32 const   )3277757891U, 
        (u32 const   )405286936U,      (u32 const   )2527147926U,      (u32 const   )84871685U,      (u32 const   )2595565466U, 
        (u32 const   )118033927U,      (u32 const   )305538066U,      (u32 const   )2157648768U,      (u32 const   )3795705826U, 
        (u32 const   )3945188843U,      (u32 const   )661212711U,      (u32 const   )2999812018U,      (u32 const   )1973414517U, 
        (u32 const   )152769033U,      (u32 const   )2208177539U,      (u32 const   )745822252U,      (u32 const   )439235610U, 
        (u32 const   )455947803U,      (u32 const   )1857215598U,      (u32 const   )1525593178U,      (u32 const   )2700827552U, 
        (u32 const   )1391895634U,      (u32 const   )994932283U,      (u32 const   )3596728278U,      (u32 const   )3016654259U, 
        (u32 const   )695947817U,      (u32 const   )3812548067U,      (u32 const   )795958831U,      (u32 const   )2224493444U, 
        (u32 const   )1408607827U,      (u32 const   )3513301457U,      (u32 const   )0U,      (u32 const   )3979133421U, 
        (u32 const   )543178784U,      (u32 const   )4229948412U,      (u32 const   )2982705585U,      (u32 const   )1542305371U, 
        (u32 const   )1790891114U,      (u32 const   )3410398667U,      (u32 const   )3201918910U,      (u32 const   )961245753U, 
        (u32 const   )1256100938U,      (u32 const   )1289001036U,      (u32 const   )1491644504U,      (u32 const   )3477767631U, 
        (u32 const   )3496721360U,      (u32 const   )4012557807U,      (u32 const   )2867154858U,      (u32 const   )4212583931U, 
        (u32 const   )1137018435U,      (u32 const   )1305975373U,      (u32 const   )861234739U,      (u32 const   )2241073541U, 
        (u32 const   )1171229253U,      (u32 const   )4178635257U,      (u32 const   )33948674U,      (u32 const   )2139225727U, 
        (u32 const   )1357946960U,      (u32 const   )1011120188U,      (u32 const   )2679776671U,      (u32 const   )2833468328U, 
        (u32 const   )1374921297U,      (u32 const   )2751356323U,      (u32 const   )1086357568U,      (u32 const   )2408187279U, 
        (u32 const   )2460827538U,      (u32 const   )2646352285U,      (u32 const   )944271416U,      (u32 const   )4110742005U, 
        (u32 const   )3168756668U,      (u32 const   )3066132406U,      (u32 const   )3665145818U,      (u32 const   )560153121U, 
        (u32 const   )271589392U,      (u32 const   )4279952895U,      (u32 const   )4077846003U,      (u32 const   )3530407890U, 
        (u32 const   )3444343245U,      (u32 const   )202643468U,      (u32 const   )322250259U,      (u32 const   )3962553324U, 
        (u32 const   )1608629855U,      (u32 const   )2543990167U,      (u32 const   )1154254916U,      (u32 const   )389623319U, 
        (u32 const   )3294073796U,      (u32 const   )2817676711U,      (u32 const   )2122513534U,      (u32 const   )1028094525U, 
        (u32 const   )1689045092U,      (u32 const   )1575467613U,      (u32 const   )422261273U,      (u32 const   )1939203699U, 
        (u32 const   )1621147744U,      (u32 const   )2174228865U,      (u32 const   )1339137615U,      (u32 const   )3699352540U, 
        (u32 const   )577127458U,      (u32 const   )712922154U,      (u32 const   )2427141008U,      (u32 const   )2290289544U, 
        (u32 const   )1187679302U,      (u32 const   )3995715566U,      (u32 const   )3100863416U,      (u32 const   )339486740U, 
        (u32 const   )3732514782U,      (u32 const   )1591917662U,      (u32 const   )186455563U,      (u32 const   )3681988059U, 
        (u32 const   )3762019296U,      (u32 const   )844522546U,      (u32 const   )978220090U,      (u32 const   )169743370U, 
        (u32 const   )1239126601U,      (u32 const   )101321734U,      (u32 const   )611076132U,      (u32 const   )1558493276U, 
        (u32 const   )3260915650U,      (u32 const   )3547250131U,      (u32 const   )2901361580U,      (u32 const   )1655096418U, 
        (u32 const   )2443721105U,      (u32 const   )2510565781U,      (u32 const   )3828863972U,      (u32 const   )2039214713U, 
        (u32 const   )3878868455U,      (u32 const   )3359869896U,      (u32 const   )928607799U,      (u32 const   )1840765549U, 
        (u32 const   )2374762893U,      (u32 const   )3580146133U,      (u32 const   )1322425422U,      (u32 const   )2850048425U, 
        (u32 const   )1823791212U,      (u32 const   )1459268694U,      (u32 const   )4094161908U,      (u32 const   )3928346602U, 
        (u32 const   )1706019429U,      (u32 const   )2056189050U,      (u32 const   )2934523822U,      (u32 const   )135794696U, 
        (u32 const   )3134549946U,      (u32 const   )2022240376U,      (u32 const   )628050469U,      (u32 const   )779246638U, 
        (u32 const   )472135708U,      (u32 const   )2800834470U,      (u32 const   )3032970164U,      (u32 const   )3327236038U, 
        (u32 const   )3894660072U,      (u32 const   )3715932637U,      (u32 const   )1956440180U,      (u32 const   )522272287U, 
        (u32 const   )1272813131U,      (u32 const   )3185336765U,      (u32 const   )2340818315U,      (u32 const   )2323976074U, 
        (u32 const   )1888542832U,      (u32 const   )1044544574U,      (u32 const   )3049550261U,      (u32 const   )1722469478U, 
        (u32 const   )1222152264U,      (u32 const   )50660867U,      (u32 const   )4127324150U,      (u32 const   )236067854U, 
        (u32 const   )1638122081U,      (u32 const   )895445557U,      (u32 const   )1475980887U,      (u32 const   )3117443513U, 
        (u32 const   )2257655686U,      (u32 const   )3243809217U,      (u32 const   )489110045U,      (u32 const   )2662934430U, 
        (u32 const   )3778599393U,      (u32 const   )4162055160U,      (u32 const   )2561878936U,      (u32 const   )288563729U, 
        (u32 const   )1773916777U,      (u32 const   )3648039385U,      (u32 const   )2391345038U,      (u32 const   )2493985684U, 
        (u32 const   )2612407707U,      (u32 const   )505560094U,      (u32 const   )2274497927U,      (u32 const   )3911240169U, 
        (u32 const   )3460925390U,      (u32 const   )1442818645U,      (u32 const   )678973480U,      (u32 const   )3749357023U, 
        (u32 const   )2358182796U,      (u32 const   )2717407649U,      (u32 const   )2306869641U,      (u32 const   )219617805U, 
        (u32 const   )3218761151U,      (u32 const   )3862026214U,      (u32 const   )1120306242U,      (u32 const   )1756942440U, 
        (u32 const   )1103331905U,      (u32 const   )2578459033U,      (u32 const   )762796589U,      (u32 const   )252780047U, 
        (u32 const   )2966125488U,      (u32 const   )1425844308U,      (u32 const   )3151392187U,      (u32 const   )372911126U};
#line 249 "rijndael.c"
static u32 const   Te3[256]  = 
#line 249
  {      (u32 const   )1667474886U,      (u32 const   )2088535288U,      (u32 const   )2004326894U,      (u32 const   )2071694838U, 
        (u32 const   )4075949567U,      (u32 const   )1802223062U,      (u32 const   )1869591006U,      (u32 const   )3318043793U, 
        (u32 const   )808472672U,      (u32 const   )16843522U,      (u32 const   )1734846926U,      (u32 const   )724270422U, 
        (u32 const   )4278065639U,      (u32 const   )3621216949U,      (u32 const   )2880169549U,      (u32 const   )1987484396U, 
        (u32 const   )3402253711U,      (u32 const   )2189597983U,      (u32 const   )3385409673U,      (u32 const   )2105378810U, 
        (u32 const   )4210693615U,      (u32 const   )1499065266U,      (u32 const   )1195886990U,      (u32 const   )4042263547U, 
        (u32 const   )2913856577U,      (u32 const   )3570689971U,      (u32 const   )2728590687U,      (u32 const   )2947541573U, 
        (u32 const   )2627518243U,      (u32 const   )2762274643U,      (u32 const   )1920112356U,      (u32 const   )3233831835U, 
        (u32 const   )3082273397U,      (u32 const   )4261223649U,      (u32 const   )2475929149U,      (u32 const   )640051788U, 
        (u32 const   )909531756U,      (u32 const   )1061110142U,      (u32 const   )4160160501U,      (u32 const   )3435941763U, 
        (u32 const   )875846760U,      (u32 const   )2779116625U,      (u32 const   )3857003729U,      (u32 const   )4059105529U, 
        (u32 const   )1903268834U,      (u32 const   )3638064043U,      (u32 const   )825316194U,      (u32 const   )353713962U, 
        (u32 const   )67374088U,      (u32 const   )3351728789U,      (u32 const   )589522246U,      (u32 const   )3284360861U, 
        (u32 const   )404236336U,      (u32 const   )2526454071U,      (u32 const   )84217610U,      (u32 const   )2593830191U, 
        (u32 const   )117901582U,      (u32 const   )303183396U,      (u32 const   )2155911963U,      (u32 const   )3806477791U, 
        (u32 const   )3958056653U,      (u32 const   )656894286U,      (u32 const   )2998062463U,      (u32 const   )1970642922U, 
        (u32 const   )151591698U,      (u32 const   )2206440989U,      (u32 const   )741110872U,      (u32 const   )437923380U, 
        (u32 const   )454765878U,      (u32 const   )1852748508U,      (u32 const   )1515908788U,      (u32 const   )2694904667U, 
        (u32 const   )1381168804U,      (u32 const   )993742198U,      (u32 const   )3604373943U,      (u32 const   )3014905469U, 
        (u32 const   )690584402U,      (u32 const   )3823320797U,      (u32 const   )791638366U,      (u32 const   )2223281939U, 
        (u32 const   )1398011302U,      (u32 const   )3520161977U,      (u32 const   )0U,      (u32 const   )3991743681U, 
        (u32 const   )538992704U,      (u32 const   )4244381667U,      (u32 const   )2981218425U,      (u32 const   )1532751286U, 
        (u32 const   )1785380564U,      (u32 const   )3419096717U,      (u32 const   )3200178535U,      (u32 const   )960056178U, 
        (u32 const   )1246420628U,      (u32 const   )1280103576U,      (u32 const   )1482221744U,      (u32 const   )3486468741U, 
        (u32 const   )3503319995U,      (u32 const   )4025428677U,      (u32 const   )2863326543U,      (u32 const   )4227536621U, 
        (u32 const   )1128514950U,      (u32 const   )1296947098U,      (u32 const   )859002214U,      (u32 const   )2240123921U, 
        (u32 const   )1162203018U,      (u32 const   )4193849577U,      (u32 const   )33687044U,      (u32 const   )2139062782U, 
        (u32 const   )1347481760U,      (u32 const   )1010582648U,      (u32 const   )2678045221U,      (u32 const   )2829640523U, 
        (u32 const   )1364325282U,      (u32 const   )2745433693U,      (u32 const   )1077985408U,      (u32 const   )2408548869U, 
        (u32 const   )2459086143U,      (u32 const   )2644360225U,      (u32 const   )943212656U,      (u32 const   )4126475505U, 
        (u32 const   )3166494563U,      (u32 const   )3065430391U,      (u32 const   )3671750063U,      (u32 const   )555836226U, 
        (u32 const   )269496352U,      (u32 const   )4294908645U,      (u32 const   )4092792573U,      (u32 const   )3537006015U, 
        (u32 const   )3452783745U,      (u32 const   )202118168U,      (u32 const   )320025894U,      (u32 const   )3974901699U, 
        (u32 const   )1600119230U,      (u32 const   )2543297077U,      (u32 const   )1145359496U,      (u32 const   )387397934U, 
        (u32 const   )3301201811U,      (u32 const   )2812801621U,      (u32 const   )2122220284U,      (u32 const   )1027426170U, 
        (u32 const   )1684319432U,      (u32 const   )1566435258U,      (u32 const   )421079858U,      (u32 const   )1936954854U, 
        (u32 const   )1616945344U,      (u32 const   )2172753945U,      (u32 const   )1330631070U,      (u32 const   )3705438115U, 
        (u32 const   )572679748U,      (u32 const   )707427924U,      (u32 const   )2425400123U,      (u32 const   )2290647819U, 
        (u32 const   )1179044492U,      (u32 const   )4008585671U,      (u32 const   )3099120491U,      (u32 const   )336870440U, 
        (u32 const   )3739122087U,      (u32 const   )1583276732U,      (u32 const   )185277718U,      (u32 const   )3688593069U, 
        (u32 const   )3772791771U,      (u32 const   )842159716U,      (u32 const   )976899700U,      (u32 const   )168435220U, 
        (u32 const   )1229577106U,      (u32 const   )101059084U,      (u32 const   )606366792U,      (u32 const   )1549591736U, 
        (u32 const   )3267517855U,      (u32 const   )3553849021U,      (u32 const   )2897014595U,      (u32 const   )1650632388U, 
        (u32 const   )2442242105U,      (u32 const   )2509612081U,      (u32 const   )3840161747U,      (u32 const   )2038008818U, 
        (u32 const   )3890688725U,      (u32 const   )3368567691U,      (u32 const   )926374254U,      (u32 const   )1835907034U, 
        (u32 const   )2374863873U,      (u32 const   )3587531953U,      (u32 const   )1313788572U,      (u32 const   )2846482505U, 
        (u32 const   )1819063512U,      (u32 const   )1448540844U,      (u32 const   )4109633523U,      (u32 const   )3941213647U, 
        (u32 const   )1701162954U,      (u32 const   )2054852340U,      (u32 const   )2930698567U,      (u32 const   )134748176U, 
        (u32 const   )3132806511U,      (u32 const   )2021165296U,      (u32 const   )623210314U,      (u32 const   )774795868U, 
        (u32 const   )471606328U,      (u32 const   )2795958615U,      (u32 const   )3031746419U,      (u32 const   )3334885783U, 
        (u32 const   )3907527627U,      (u32 const   )3722280097U,      (u32 const   )1953799400U,      (u32 const   )522133822U, 
        (u32 const   )1263263126U,      (u32 const   )3183336545U,      (u32 const   )2341176845U,      (u32 const   )2324333839U, 
        (u32 const   )1886425312U,      (u32 const   )1044267644U,      (u32 const   )3048588401U,      (u32 const   )1718004428U, 
        (u32 const   )1212733584U,      (u32 const   )50529542U,      (u32 const   )4143317495U,      (u32 const   )235803164U, 
        (u32 const   )1633788866U,      (u32 const   )892690282U,      (u32 const   )1465383342U,      (u32 const   )3115962473U, 
        (u32 const   )2256965911U,      (u32 const   )3250673817U,      (u32 const   )488449850U,      (u32 const   )2661202215U, 
        (u32 const   )3789633753U,      (u32 const   )4177007595U,      (u32 const   )2560144171U,      (u32 const   )286339874U, 
        (u32 const   )1768537042U,      (u32 const   )3654906025U,      (u32 const   )2391705863U,      (u32 const   )2492770099U, 
        (u32 const   )2610673197U,      (u32 const   )505291324U,      (u32 const   )2273808917U,      (u32 const   )3924369609U, 
        (u32 const   )3469625735U,      (u32 const   )1431699370U,      (u32 const   )673740880U,      (u32 const   )3755965093U, 
        (u32 const   )2358021891U,      (u32 const   )2711746649U,      (u32 const   )2307489801U,      (u32 const   )218961690U, 
        (u32 const   )3217021541U,      (u32 const   )3873845719U,      (u32 const   )1111672452U,      (u32 const   )1751693520U, 
        (u32 const   )1094828930U,      (u32 const   )2576986153U,      (u32 const   )757954394U,      (u32 const   )252645662U, 
        (u32 const   )2964376443U,      (u32 const   )1414855848U,      (u32 const   )3149649517U,      (u32 const   )370555436U};
#line 316 "rijndael.c"
static u32 const   Te4[256]  = 
#line 316
  {      (u32 const   )1667457891U,      (u32 const   )2088533116U,      (u32 const   )2004318071U,      (u32 const   )2071690107U, 
        (u32 const   )4076008178U,      (u32 const   )1802201963U,      (u32 const   )1869573999U,      (u32 const   )3318072773U, 
        (u32 const   )808464432U,      (u32 const   )16843009U,      (u32 const   )1734829927U,      (u32 const   )724249387U, 
        (u32 const   )4278124286U,      (u32 const   )3621246935U,      (u32 const   )2880154539U,      (u32 const   )1987475062U, 
        (u32 const   )3402287818U,      (u32 const   )2189591170U,      (u32 const   )3385444809U,      (u32 const   )2105376125U, 
        (u32 const   )4210752250U,      (u32 const   )1499027801U,      (u32 const   )1195853639U,      (u32 const   )4042322160U, 
        (u32 const   )2913840557U,      (u32 const   )3570717908U,      (u32 const   )2728567458U,      (u32 const   )2947526575U, 
        (u32 const   )2627509404U,      (u32 const   )2762253476U,      (u32 const   )1920103026U,      (u32 const   )3233857728U, 
        (u32 const   )3082270647U,      (u32 const   )4261281277U,      (u32 const   )2475922323U,      (u32 const   )640034342U, 
        (u32 const   )909522486U,      (u32 const   )1061109567U,      (u32 const   )4160223223U,      (u32 const   )3435973836U, 
        (u32 const   )875836468U,      (u32 const   )2779096485U,      (u32 const   )3857049061U,      (u32 const   )4059165169U, 
        (u32 const   )1903260017U,      (u32 const   )3638089944U,      (u32 const   )825307441U,      (u32 const   )353703189U, 
        (u32 const   )67372036U,      (u32 const   )3351758791U,      (u32 const   )589505315U,      (u32 const   )3284386755U, 
        (u32 const   )404232216U,      (u32 const   )2526451350U,      (u32 const   )84215045U,      (u32 const   )2593823386U, 
        (u32 const   )117901063U,      (u32 const   )303174162U,      (u32 const   )2155905152U,      (u32 const   )3806520034U, 
        (u32 const   )3958107115U,      (u32 const   )656877351U,      (u32 const   )2998055602U,      (u32 const   )1970632053U, 
        (u32 const   )151587081U,      (u32 const   )2206434179U,      (u32 const   )741092396U,      (u32 const   )437918234U, 
        (u32 const   )454761243U,      (u32 const   )1852730990U,      (u32 const   )1515870810U,      (u32 const   )2694881440U, 
        (u32 const   )1381126738U,      (u32 const   )993737531U,      (u32 const   )3604403926U,      (u32 const   )3014898611U, 
        (u32 const   )690563369U,      (u32 const   )3823363043U,      (u32 const   )791621423U,      (u32 const   )2223277188U, 
        (u32 const   )1397969747U,      (u32 const   )3520188881U,      (u32 const   )0U,      (u32 const   )3991793133U, 
        (u32 const   )538976288U,      (u32 const   )4244438268U,      (u32 const   )2981212593U,      (u32 const   )1532713819U, 
        (u32 const   )1785358954U,      (u32 const   )3419130827U,      (u32 const   )3200171710U,      (u32 const   )960051513U, 
        (u32 const   )1246382666U,      (u32 const   )1280068684U,      (u32 const   )1482184792U,      (u32 const   )3486502863U, 
        (u32 const   )3503345872U,      (u32 const   )4025479151U,      (u32 const   )2863311530U,      (u32 const   )4227595259U, 
        (u32 const   )1128481603U,      (u32 const   )1296911693U,      (u32 const   )858993459U,      (u32 const   )2240120197U, 
        (u32 const   )1162167621U,      (u32 const   )4193909241U,      (u32 const   )33686018U,      (u32 const   )2139062143U, 
        (u32 const   )1347440720U,      (u32 const   )1010580540U,      (u32 const   )2678038431U,      (u32 const   )2829625512U, 
        (u32 const   )1364283729U,      (u32 const   )2745410467U,      (u32 const   )1077952576U,      (u32 const   )2408550287U, 
        (u32 const   )2459079314U,      (u32 const   )2644352413U,      (u32 const   )943208504U,      (u32 const   )4126537205U, 
        (u32 const   )3166485692U,      (u32 const   )3065427638U,      (u32 const   )3671775962U,      (u32 const   )555819297U, 
        (u32 const   )269488144U,      (u32 const   )4294967295U,      (u32 const   )4092851187U,      (u32 const   )3537031890U, 
        (u32 const   )3452816845U,      (u32 const   )202116108U,      (u32 const   )320017171U,      (u32 const   )3974950124U, 
        (u32 const   )1600085855U,      (u32 const   )2543294359U,      (u32 const   )1145324612U,      (u32 const   )387389207U, 
        (u32 const   )3301229764U,      (u32 const   )2812782503U,      (u32 const   )2122219134U,      (u32 const   )1027423549U, 
        (u32 const   )1684300900U,      (u32 const   )1566399837U,      (u32 const   )421075225U,      (u32 const   )1936946035U, 
        (u32 const   )1616928864U,      (u32 const   )2172748161U,      (u32 const   )1330597711U,      (u32 const   )3705461980U, 
        (u32 const   )572662306U,      (u32 const   )707406378U,      (u32 const   )2425393296U,      (u32 const   )2290649224U, 
        (u32 const   )1179010630U,      (u32 const   )4008636142U,      (u32 const   )3099113656U,      (u32 const   )336860180U, 
        (u32 const   )3739147998U,      (u32 const   )1583242846U,      (u32 const   )185273099U,      (u32 const   )3688618971U, 
        (u32 const   )3772834016U,      (u32 const   )842150450U,      (u32 const   )976894522U,      (u32 const   )168430090U, 
        (u32 const   )1229539657U,      (u32 const   )101058054U,      (u32 const   )606348324U,      (u32 const   )1549556828U, 
        (u32 const   )3267543746U,      (u32 const   )3553874899U,      (u32 const   )2896997548U,      (u32 const   )1650614882U, 
        (u32 const   )2442236305U,      (u32 const   )2509608341U,      (u32 const   )3840206052U,      (u32 const   )2038004089U, 
        (u32 const   )3890735079U,      (u32 const   )3368601800U,      (u32 const   )926365495U,      (u32 const   )1835887981U, 
        (u32 const   )2374864269U,      (u32 const   )3587560917U,      (u32 const   )1313754702U,      (u32 const   )2846468521U, 
        (u32 const   )1819044972U,      (u32 const   )1448498774U,      (u32 const   )4109694196U,      (u32 const   )3941264106U, 
        (u32 const   )1701143909U,      (u32 const   )2054847098U,      (u32 const   )2930683566U,      (u32 const   )134744072U, 
        (u32 const   )3132799674U,      (u32 const   )2021161080U,      (u32 const   )623191333U,      (u32 const   )774778414U, 
        (u32 const   )471604252U,      (u32 const   )2795939494U,      (u32 const   )3031741620U,      (u32 const   )3334915782U, 
        (u32 const   )3907578088U,      (u32 const   )3722304989U,      (u32 const   )1953789044U,      (u32 const   )522133279U, 
        (u32 const   )1263225675U,      (u32 const   )3183328701U,      (u32 const   )2341178251U,      (u32 const   )2324335242U, 
        (u32 const   )1886417008U,      (u32 const   )1044266558U,      (u32 const   )3048584629U,      (u32 const   )1717986918U, 
        (u32 const   )1212696648U,      (u32 const   )50529027U,      (u32 const   )4143380214U,      (u32 const   )235802126U, 
        (u32 const   )1633771873U,      (u32 const   )892679477U,      (u32 const   )1465341783U,      (u32 const   )3115956665U, 
        (u32 const   )2256963206U,      (u32 const   )3250700737U,      (u32 const   )488447261U,      (u32 const   )2661195422U, 
        (u32 const   )3789677025U,      (u32 const   )4177066232U,      (u32 const   )2560137368U,      (u32 const   )286331153U, 
        (u32 const   )1768515945U,      (u32 const   )3654932953U,      (u32 const   )2391707278U,      (u32 const   )2492765332U, 
        (u32 const   )2610666395U,      (u32 const   )505290270U,      (u32 const   )2273806215U,      (u32 const   )3924421097U, 
        (u32 const   )3469659854U,      (u32 const   )1431655765U,      (u32 const   )673720360U,      (u32 const   )3755991007U, 
        (u32 const   )2358021260U,      (u32 const   )2711724449U,      (u32 const   )2307492233U,      (u32 const   )218959117U, 
        (u32 const   )3217014719U,      (u32 const   )3873892070U,      (u32 const   )1111638594U,      (u32 const   )1751672936U, 
        (u32 const   )1094795585U,      (u32 const   )2576980377U,      (u32 const   )757935405U,      (u32 const   )252645135U, 
        (u32 const   )2964369584U,      (u32 const   )1414812756U,      (u32 const   )3149642683U,      (u32 const   )370546198U};
#line 382 "rijndael.c"
static u32 const   Td0[256]  = 
#line 382
  {      (u32 const   )1374988112U,      (u32 const   )2118214995U,      (u32 const   )437757123U,      (u32 const   )975658646U, 
        (u32 const   )1001089995U,      (u32 const   )530400753U,      (u32 const   )2902087851U,      (u32 const   )1273168787U, 
        (u32 const   )540080725U,      (u32 const   )2910219766U,      (u32 const   )2295101073U,      (u32 const   )4110568485U, 
        (u32 const   )1340463100U,      (u32 const   )3307916247U,      (u32 const   )641025152U,      (u32 const   )3043140495U, 
        (u32 const   )3736164937U,      (u32 const   )632953703U,      (u32 const   )1172967064U,      (u32 const   )1576976609U, 
        (u32 const   )3274667266U,      (u32 const   )2169303058U,      (u32 const   )2370213795U,      (u32 const   )1809054150U, 
        (u32 const   )59727847U,      (u32 const   )361929877U,      (u32 const   )3211623147U,      (u32 const   )2505202138U, 
        (u32 const   )3569255213U,      (u32 const   )1484005843U,      (u32 const   )1239443753U,      (u32 const   )2395588676U, 
        (u32 const   )1975683434U,      (u32 const   )4102977912U,      (u32 const   )2572697195U,      (u32 const   )666464733U, 
        (u32 const   )3202437046U,      (u32 const   )4035489047U,      (u32 const   )3374361702U,      (u32 const   )2110667444U, 
        (u32 const   )1675577880U,      (u32 const   )3843699074U,      (u32 const   )2538681184U,      (u32 const   )1649639237U, 
        (u32 const   )2976151520U,      (u32 const   )3144396420U,      (u32 const   )4269907996U,      (u32 const   )4178062228U, 
        (u32 const   )1883793496U,      (u32 const   )2403728665U,      (u32 const   )2497604743U,      (u32 const   )1383856311U, 
        (u32 const   )2876494627U,      (u32 const   )1917518562U,      (u32 const   )3810496343U,      (u32 const   )1716890410U, 
        (u32 const   )3001755655U,      (u32 const   )800440835U,      (u32 const   )2261089178U,      (u32 const   )3543599269U, 
        (u32 const   )807962610U,      (u32 const   )599762354U,      (u32 const   )33778362U,      (u32 const   )3977675356U, 
        (u32 const   )2328828971U,      (u32 const   )2809771154U,      (u32 const   )4077384432U,      (u32 const   )1315562145U, 
        (u32 const   )1708848333U,      (u32 const   )101039829U,      (u32 const   )3509871135U,      (u32 const   )3299278474U, 
        (u32 const   )875451293U,      (u32 const   )2733856160U,      (u32 const   )92987698U,      (u32 const   )2767645557U, 
        (u32 const   )193195065U,      (u32 const   )1080094634U,      (u32 const   )1584504582U,      (u32 const   )3178106961U, 
        (u32 const   )1042385657U,      (u32 const   )2531067453U,      (u32 const   )3711829422U,      (u32 const   )1306967366U, 
        (u32 const   )2438237621U,      (u32 const   )1908694277U,      (u32 const   )67556463U,      (u32 const   )1615861247U, 
        (u32 const   )429456164U,      (u32 const   )3602770327U,      (u32 const   )2302690252U,      (u32 const   )1742315127U, 
        (u32 const   )2968011453U,      (u32 const   )126454664U,      (u32 const   )3877198648U,      (u32 const   )2043211483U, 
        (u32 const   )2709260871U,      (u32 const   )2084704233U,      (u32 const   )4169408201U,      (u32 const   )0U, 
        (u32 const   )159417987U,      (u32 const   )841739592U,      (u32 const   )504459436U,      (u32 const   )1817866830U, 
        (u32 const   )4245618683U,      (u32 const   )260388950U,      (u32 const   )1034867998U,      (u32 const   )908933415U, 
        (u32 const   )168810852U,      (u32 const   )1750902305U,      (u32 const   )2606453969U,      (u32 const   )607530554U, 
        (u32 const   )202008497U,      (u32 const   )2472011535U,      (u32 const   )3035535058U,      (u32 const   )463180190U, 
        (u32 const   )2160117071U,      (u32 const   )1641816226U,      (u32 const   )1517767529U,      (u32 const   )470948374U, 
        (u32 const   )3801332234U,      (u32 const   )3231722213U,      (u32 const   )1008918595U,      (u32 const   )303765277U, 
        (u32 const   )235474187U,      (u32 const   )4069246893U,      (u32 const   )766945465U,      (u32 const   )337553864U, 
        (u32 const   )1475418501U,      (u32 const   )2943682380U,      (u32 const   )4003061179U,      (u32 const   )2743034109U, 
        (u32 const   )4144047775U,      (u32 const   )1551037884U,      (u32 const   )1147550661U,      (u32 const   )1543208500U, 
        (u32 const   )2336434550U,      (u32 const   )3408119516U,      (u32 const   )3069049960U,      (u32 const   )3102011747U, 
        (u32 const   )3610369226U,      (u32 const   )1113818384U,      (u32 const   )328671808U,      (u32 const   )2227573024U, 
        (u32 const   )2236228733U,      (u32 const   )3535486456U,      (u32 const   )2935566865U,      (u32 const   )3341394285U, 
        (u32 const   )496906059U,      (u32 const   )3702665459U,      (u32 const   )226906860U,      (u32 const   )2009195472U, 
        (u32 const   )733156972U,      (u32 const   )2842737049U,      (u32 const   )294930682U,      (u32 const   )1206477858U, 
        (u32 const   )2835123396U,      (u32 const   )2700099354U,      (u32 const   )1451044056U,      (u32 const   )573804783U, 
        (u32 const   )2269728455U,      (u32 const   )3644379585U,      (u32 const   )2362090238U,      (u32 const   )2564033334U, 
        (u32 const   )2801107407U,      (u32 const   )2776292904U,      (u32 const   )3669462566U,      (u32 const   )1068351396U, 
        (u32 const   )742039012U,      (u32 const   )1350078989U,      (u32 const   )1784663195U,      (u32 const   )1417561698U, 
        (u32 const   )4136440770U,      (u32 const   )2430122216U,      (u32 const   )775550814U,      (u32 const   )2193862645U, 
        (u32 const   )2673705150U,      (u32 const   )1775276924U,      (u32 const   )1876241833U,      (u32 const   )3475313331U, 
        (u32 const   )3366754619U,      (u32 const   )270040487U,      (u32 const   )3902563182U,      (u32 const   )3678124923U, 
        (u32 const   )3441850377U,      (u32 const   )1851332852U,      (u32 const   )3969562369U,      (u32 const   )2203032232U, 
        (u32 const   )3868552805U,      (u32 const   )2868897406U,      (u32 const   )566021896U,      (u32 const   )4011190502U, 
        (u32 const   )3135740889U,      (u32 const   )1248802510U,      (u32 const   )3936291284U,      (u32 const   )699432150U, 
        (u32 const   )832877231U,      (u32 const   )708780849U,      (u32 const   )3332740144U,      (u32 const   )899835584U, 
        (u32 const   )1951317047U,      (u32 const   )4236429990U,      (u32 const   )3767586992U,      (u32 const   )866637845U, 
        (u32 const   )4043610186U,      (u32 const   )1106041591U,      (u32 const   )2144161806U,      (u32 const   )395441711U, 
        (u32 const   )1984812685U,      (u32 const   )1139781709U,      (u32 const   )3433712980U,      (u32 const   )3835036895U, 
        (u32 const   )2664543715U,      (u32 const   )1282050075U,      (u32 const   )3240894392U,      (u32 const   )1181045119U, 
        (u32 const   )2640243204U,      (u32 const   )25965917U,      (u32 const   )4203181171U,      (u32 const   )4211818798U, 
        (u32 const   )3009879386U,      (u32 const   )2463879762U,      (u32 const   )3910161971U,      (u32 const   )1842759443U, 
        (u32 const   )2597806476U,      (u32 const   )933301370U,      (u32 const   )1509430414U,      (u32 const   )3943906441U, 
        (u32 const   )3467192302U,      (u32 const   )3076639029U,      (u32 const   )3776767469U,      (u32 const   )2051518780U, 
        (u32 const   )2631065433U,      (u32 const   )1441952575U,      (u32 const   )404016761U,      (u32 const   )1942435775U, 
        (u32 const   )1408749034U,      (u32 const   )1610459739U,      (u32 const   )3745345300U,      (u32 const   )2017778566U, 
        (u32 const   )3400528769U,      (u32 const   )3110650942U,      (u32 const   )941896748U,      (u32 const   )3265478751U, 
        (u32 const   )371049330U,      (u32 const   )3168937228U,      (u32 const   )675039627U,      (u32 const   )4279080257U, 
        (u32 const   )967311729U,      (u32 const   )135050206U,      (u32 const   )3635733660U,      (u32 const   )1683407248U, 
        (u32 const   )2076935265U,      (u32 const   )3576870512U,      (u32 const   )1215061108U,      (u32 const   )3501741890U};
#line 448 "rijndael.c"
static u32 const   Td1[256]  = 
#line 448
  {      (u32 const   )1347548327U,      (u32 const   )1400783205U,      (u32 const   )3273267108U,      (u32 const   )2520393566U, 
        (u32 const   )3409685355U,      (u32 const   )4045380933U,      (u32 const   )2880240216U,      (u32 const   )2471224067U, 
        (u32 const   )1428173050U,      (u32 const   )4138563181U,      (u32 const   )2441661558U,      (u32 const   )636813900U, 
        (u32 const   )4233094615U,      (u32 const   )3620022987U,      (u32 const   )2149987652U,      (u32 const   )2411029155U, 
        (u32 const   )1239331162U,      (u32 const   )1730525723U,      (u32 const   )2554718734U,      (u32 const   )3781033664U, 
        (u32 const   )46346101U,      (u32 const   )310463728U,      (u32 const   )2743944855U,      (u32 const   )3328955385U, 
        (u32 const   )3875770207U,      (u32 const   )2501218972U,      (u32 const   )3955191162U,      (u32 const   )3667219033U, 
        (u32 const   )768917123U,      (u32 const   )3545789473U,      (u32 const   )692707433U,      (u32 const   )1150208456U, 
        (u32 const   )1786102409U,      (u32 const   )2029293177U,      (u32 const   )1805211710U,      (u32 const   )3710368113U, 
        (u32 const   )3065962831U,      (u32 const   )401639597U,      (u32 const   )1724457132U,      (u32 const   )3028143674U, 
        (u32 const   )409198410U,      (u32 const   )2196052529U,      (u32 const   )1620529459U,      (u32 const   )1164071807U, 
        (u32 const   )3769721975U,      (u32 const   )2226875310U,      (u32 const   )486441376U,      (u32 const   )2499348523U, 
        (u32 const   )1483753576U,      (u32 const   )428819965U,      (u32 const   )2274680428U,      (u32 const   )3075636216U, 
        (u32 const   )598438867U,      (u32 const   )3799141122U,      (u32 const   )1474502543U,      (u32 const   )711349675U, 
        (u32 const   )129166120U,      (u32 const   )53458370U,      (u32 const   )2592523643U,      (u32 const   )2782082824U, 
        (u32 const   )4063242375U,      (u32 const   )2988687269U,      (u32 const   )3120694122U,      (u32 const   )1559041666U, 
        (u32 const   )730517276U,      (u32 const   )2460449204U,      (u32 const   )4042459122U,      (u32 const   )2706270690U, 
        (u32 const   )3446004468U,      (u32 const   )3573941694U,      (u32 const   )533804130U,      (u32 const   )2328143614U, 
        (u32 const   )2637442643U,      (u32 const   )2695033685U,      (u32 const   )839224033U,      (u32 const   )1973745387U, 
        (u32 const   )957055980U,      (u32 const   )2856345839U,      (u32 const   )106852767U,      (u32 const   )1371368976U, 
        (u32 const   )4181598602U,      (u32 const   )1033297158U,      (u32 const   )2933734917U,      (u32 const   )1179510461U, 
        (u32 const   )3046200461U,      (u32 const   )91341917U,      (u32 const   )1862534868U,      (u32 const   )4284502037U, 
        (u32 const   )605657339U,      (u32 const   )2547432937U,      (u32 const   )3431546947U,      (u32 const   )2003294622U, 
        (u32 const   )3182487618U,      (u32 const   )2282195339U,      (u32 const   )954669403U,      (u32 const   )3682191598U, 
        (u32 const   )1201765386U,      (u32 const   )3917234703U,      (u32 const   )3388507166U,      (u32 const   )0U, 
        (u32 const   )2198438022U,      (u32 const   )1211247597U,      (u32 const   )2887651696U,      (u32 const   )1315723890U, 
        (u32 const   )4227665663U,      (u32 const   )1443857720U,      (u32 const   )507358933U,      (u32 const   )657861945U, 
        (u32 const   )1678381017U,      (u32 const   )560487590U,      (u32 const   )3516619604U,      (u32 const   )975451694U, 
        (u32 const   )2970356327U,      (u32 const   )261314535U,      (u32 const   )3535072918U,      (u32 const   )2652609425U, 
        (u32 const   )1333838021U,      (u32 const   )2724322336U,      (u32 const   )1767536459U,      (u32 const   )370938394U, 
        (u32 const   )182621114U,      (u32 const   )3854606378U,      (u32 const   )1128014560U,      (u32 const   )487725847U, 
        (u32 const   )185469197U,      (u32 const   )2918353863U,      (u32 const   )3106780840U,      (u32 const   )3356761769U, 
        (u32 const   )2237133081U,      (u32 const   )1286567175U,      (u32 const   )3152976349U,      (u32 const   )4255350624U, 
        (u32 const   )2683765030U,      (u32 const   )3160175349U,      (u32 const   )3309594171U,      (u32 const   )878443390U, 
        (u32 const   )1988838185U,      (u32 const   )3704300486U,      (u32 const   )1756818940U,      (u32 const   )1673061617U, 
        (u32 const   )3403100636U,      (u32 const   )272786309U,      (u32 const   )1075025698U,      (u32 const   )545572369U, 
        (u32 const   )2105887268U,      (u32 const   )4174560061U,      (u32 const   )296679730U,      (u32 const   )1841768865U, 
        (u32 const   )1260232239U,      (u32 const   )4091327024U,      (u32 const   )3960309330U,      (u32 const   )3497509347U, 
        (u32 const   )1814803222U,      (u32 const   )2578018489U,      (u32 const   )4195456072U,      (u32 const   )575138148U, 
        (u32 const   )3299409036U,      (u32 const   )446754879U,      (u32 const   )3629546796U,      (u32 const   )4011996048U, 
        (u32 const   )3347532110U,      (u32 const   )3252238545U,      (u32 const   )4270639778U,      (u32 const   )915985419U, 
        (u32 const   )3483825537U,      (u32 const   )681933534U,      (u32 const   )651868046U,      (u32 const   )2755636671U, 
        (u32 const   )3828103837U,      (u32 const   )223377554U,      (u32 const   )2607439820U,      (u32 const   )1649704518U, 
        (u32 const   )3270937875U,      (u32 const   )3901806776U,      (u32 const   )1580087799U,      (u32 const   )4118987695U, 
        (u32 const   )3198115200U,      (u32 const   )2087309459U,      (u32 const   )2842678573U,      (u32 const   )3016697106U, 
        (u32 const   )1003007129U,      (u32 const   )2802849917U,      (u32 const   )1860738147U,      (u32 const   )2077965243U, 
        (u32 const   )164439672U,      (u32 const   )4100872472U,      (u32 const   )32283319U,      (u32 const   )2827177882U, 
        (u32 const   )1709610350U,      (u32 const   )2125135846U,      (u32 const   )136428751U,      (u32 const   )3874428392U, 
        (u32 const   )3652904859U,      (u32 const   )3460984630U,      (u32 const   )3572145929U,      (u32 const   )3593056380U, 
        (u32 const   )2939266226U,      (u32 const   )824852259U,      (u32 const   )818324884U,      (u32 const   )3224740454U, 
        (u32 const   )930369212U,      (u32 const   )2801566410U,      (u32 const   )2967507152U,      (u32 const   )355706840U, 
        (u32 const   )1257309336U,      (u32 const   )4148292826U,      (u32 const   )243256656U,      (u32 const   )790073846U, 
        (u32 const   )2373340630U,      (u32 const   )1296297904U,      (u32 const   )1422699085U,      (u32 const   )3756299780U, 
        (u32 const   )3818836405U,      (u32 const   )457992840U,      (u32 const   )3099667487U,      (u32 const   )2135319889U, 
        (u32 const   )77422314U,      (u32 const   )1560382517U,      (u32 const   )1945798516U,      (u32 const   )788204353U, 
        (u32 const   )1521706781U,      (u32 const   )1385356242U,      (u32 const   )870912086U,      (u32 const   )325965383U, 
        (u32 const   )2358957921U,      (u32 const   )2050466060U,      (u32 const   )2388260884U,      (u32 const   )2313884476U, 
        (u32 const   )4006521127U,      (u32 const   )901210569U,      (u32 const   )3990953189U,      (u32 const   )1014646705U, 
        (u32 const   )1503449823U,      (u32 const   )1062597235U,      (u32 const   )2031621326U,      (u32 const   )3212035895U, 
        (u32 const   )3931371469U,      (u32 const   )1533017514U,      (u32 const   )350174575U,      (u32 const   )2256028891U, 
        (u32 const   )2177544179U,      (u32 const   )1052338372U,      (u32 const   )741876788U,      (u32 const   )1606591296U, 
        (u32 const   )1914052035U,      (u32 const   )213705253U,      (u32 const   )2334669897U,      (u32 const   )1107234197U, 
        (u32 const   )1899603969U,      (u32 const   )3725069491U,      (u32 const   )2631447780U,      (u32 const   )2422494913U, 
        (u32 const   )1635502980U,      (u32 const   )1893020342U,      (u32 const   )1950903388U,      (u32 const   )1120974935U};
#line 514 "rijndael.c"
static u32 const   Td2[256]  = 
#line 514
  {      (u32 const   )2807058932U,      (u32 const   )1699970625U,      (u32 const   )2764249623U,      (u32 const   )1586903591U, 
        (u32 const   )1808481195U,      (u32 const   )1173430173U,      (u32 const   )1487645946U,      (u32 const   )59984867U, 
        (u32 const   )4199882800U,      (u32 const   )1844882806U,      (u32 const   )1989249228U,      (u32 const   )1277555970U, 
        (u32 const   )3623636965U,      (u32 const   )3419915562U,      (u32 const   )1149249077U,      (u32 const   )2744104290U, 
        (u32 const   )1514790577U,      (u32 const   )459744698U,      (u32 const   )244860394U,      (u32 const   )3235995134U, 
        (u32 const   )1963115311U,      (u32 const   )4027744588U,      (u32 const   )2544078150U,      (u32 const   )4190530515U, 
        (u32 const   )1608975247U,      (u32 const   )2627016082U,      (u32 const   )2062270317U,      (u32 const   )1507497298U, 
        (u32 const   )2200818878U,      (u32 const   )567498868U,      (u32 const   )1764313568U,      (u32 const   )3359936201U, 
        (u32 const   )2305455554U,      (u32 const   )2037970062U,      (u32 const   )1047239000U,      (u32 const   )1910319033U, 
        (u32 const   )1337376481U,      (u32 const   )2904027272U,      (u32 const   )2892417312U,      (u32 const   )984907214U, 
        (u32 const   )1243112415U,      (u32 const   )830661914U,      (u32 const   )861968209U,      (u32 const   )2135253587U, 
        (u32 const   )2011214180U,      (u32 const   )2927934315U,      (u32 const   )2686254721U,      (u32 const   )731183368U, 
        (u32 const   )1750626376U,      (u32 const   )4246310725U,      (u32 const   )1820824798U,      (u32 const   )4172763771U, 
        (u32 const   )3542330227U,      (u32 const   )48394827U,      (u32 const   )2404901663U,      (u32 const   )2871682645U, 
        (u32 const   )671593195U,      (u32 const   )3254988725U,      (u32 const   )2073724613U,      (u32 const   )145085239U, 
        (u32 const   )2280796200U,      (u32 const   )2779915199U,      (u32 const   )1790575107U,      (u32 const   )2187128086U, 
        (u32 const   )472615631U,      (u32 const   )3029510009U,      (u32 const   )4075877127U,      (u32 const   )3802222185U, 
        (u32 const   )4107101658U,      (u32 const   )3201631749U,      (u32 const   )1646252340U,      (u32 const   )4270507174U, 
        (u32 const   )1402811438U,      (u32 const   )1436590835U,      (u32 const   )3778151818U,      (u32 const   )3950355702U, 
        (u32 const   )3963161475U,      (u32 const   )4020912224U,      (u32 const   )2667994737U,      (u32 const   )273792366U, 
        (u32 const   )2331590177U,      (u32 const   )104699613U,      (u32 const   )95345982U,      (u32 const   )3175501286U, 
        (u32 const   )2377486676U,      (u32 const   )1560637892U,      (u32 const   )3564045318U,      (u32 const   )369057872U, 
        (u32 const   )4213447064U,      (u32 const   )3919042237U,      (u32 const   )1137477952U,      (u32 const   )2658625497U, 
        (u32 const   )1119727848U,      (u32 const   )2340947849U,      (u32 const   )1530455833U,      (u32 const   )4007360968U, 
        (u32 const   )172466556U,      (u32 const   )266959938U,      (u32 const   )516552836U,      (u32 const   )0U, 
        (u32 const   )2256734592U,      (u32 const   )3980931627U,      (u32 const   )1890328081U,      (u32 const   )1917742170U, 
        (u32 const   )4294704398U,      (u32 const   )945164165U,      (u32 const   )3575528878U,      (u32 const   )958871085U, 
        (u32 const   )3647212047U,      (u32 const   )2787207260U,      (u32 const   )1423022939U,      (u32 const   )775562294U, 
        (u32 const   )1739656202U,      (u32 const   )3876557655U,      (u32 const   )2530391278U,      (u32 const   )2443058075U, 
        (u32 const   )3310321856U,      (u32 const   )547512796U,      (u32 const   )1265195639U,      (u32 const   )437656594U, 
        (u32 const   )3121275539U,      (u32 const   )719700128U,      (u32 const   )3762502690U,      (u32 const   )387781147U, 
        (u32 const   )218828297U,      (u32 const   )3350065803U,      (u32 const   )2830708150U,      (u32 const   )2848461854U, 
        (u32 const   )428169201U,      (u32 const   )122466165U,      (u32 const   )3720081049U,      (u32 const   )1627235199U, 
        (u32 const   )648017665U,      (u32 const   )4122762354U,      (u32 const   )1002783846U,      (u32 const   )2117360635U, 
        (u32 const   )695634755U,      (u32 const   )3336358691U,      (u32 const   )4234721005U,      (u32 const   )4049844452U, 
        (u32 const   )3704280881U,      (u32 const   )2232435299U,      (u32 const   )574624663U,      (u32 const   )287343814U, 
        (u32 const   )612205898U,      (u32 const   )1039717051U,      (u32 const   )840019705U,      (u32 const   )2708326185U, 
        (u32 const   )793451934U,      (u32 const   )821288114U,      (u32 const   )1391201670U,      (u32 const   )3822090177U, 
        (u32 const   )376187827U,      (u32 const   )3113855344U,      (u32 const   )1224348052U,      (u32 const   )1679968233U, 
        (u32 const   )2361698556U,      (u32 const   )1058709744U,      (u32 const   )752375421U,      (u32 const   )2431590963U, 
        (u32 const   )1321699145U,      (u32 const   )3519142200U,      (u32 const   )2734591178U,      (u32 const   )188127444U, 
        (u32 const   )2177869557U,      (u32 const   )3727205754U,      (u32 const   )2384911031U,      (u32 const   )3215212461U, 
        (u32 const   )2648976442U,      (u32 const   )2450346104U,      (u32 const   )3432737375U,      (u32 const   )1180849278U, 
        (u32 const   )331544205U,      (u32 const   )3102249176U,      (u32 const   )4150144569U,      (u32 const   )2952102595U, 
        (u32 const   )2159976285U,      (u32 const   )2474404304U,      (u32 const   )766078933U,      (u32 const   )313773861U, 
        (u32 const   )2570832044U,      (u32 const   )2108100632U,      (u32 const   )1668212892U,      (u32 const   )3145456443U, 
        (u32 const   )2013908262U,      (u32 const   )418672217U,      (u32 const   )3070356634U,      (u32 const   )2594734927U, 
        (u32 const   )1852171925U,      (u32 const   )3867060991U,      (u32 const   )3473416636U,      (u32 const   )3907448597U, 
        (u32 const   )2614737639U,      (u32 const   )919489135U,      (u32 const   )164948639U,      (u32 const   )2094410160U, 
        (u32 const   )2997825956U,      (u32 const   )590424639U,      (u32 const   )2486224549U,      (u32 const   )1723872674U, 
        (u32 const   )3157750862U,      (u32 const   )3399941250U,      (u32 const   )3501252752U,      (u32 const   )3625268135U, 
        (u32 const   )2555048196U,      (u32 const   )3673637356U,      (u32 const   )1343127501U,      (u32 const   )4130281361U, 
        (u32 const   )3599595085U,      (u32 const   )2957853679U,      (u32 const   )1297403050U,      (u32 const   )81781910U, 
        (u32 const   )3051593425U,      (u32 const   )2283490410U,      (u32 const   )532201772U,      (u32 const   )1367295589U, 
        (u32 const   )3926170974U,      (u32 const   )895287692U,      (u32 const   )1953757831U,      (u32 const   )1093597963U, 
        (u32 const   )492483431U,      (u32 const   )3528626907U,      (u32 const   )1446242576U,      (u32 const   )1192455638U, 
        (u32 const   )1636604631U,      (u32 const   )209336225U,      (u32 const   )344873464U,      (u32 const   )1015671571U, 
        (u32 const   )669961897U,      (u32 const   )3375740769U,      (u32 const   )3857572124U,      (u32 const   )2973530695U, 
        (u32 const   )3747192018U,      (u32 const   )1933530610U,      (u32 const   )3464042516U,      (u32 const   )935293895U, 
        (u32 const   )3454686199U,      (u32 const   )2858115069U,      (u32 const   )1863638845U,      (u32 const   )3683022916U, 
        (u32 const   )4085369519U,      (u32 const   )3292445032U,      (u32 const   )875313188U,      (u32 const   )1080017571U, 
        (u32 const   )3279033885U,      (u32 const   )621591778U,      (u32 const   )1233856572U,      (u32 const   )2504130317U, 
        (u32 const   )24197544U,      (u32 const   )3017672716U,      (u32 const   )3835484340U,      (u32 const   )3247465558U, 
        (u32 const   )2220981195U,      (u32 const   )3060847922U,      (u32 const   )1551124588U,      (u32 const   )1463996600U};
#line 581 "rijndael.c"
static u32 const   Td3[256]  = 
#line 581
  {      (u32 const   )4104605777U,      (u32 const   )1097159550U,      (u32 const   )396673818U,      (u32 const   )660510266U, 
        (u32 const   )2875968315U,      (u32 const   )2638606623U,      (u32 const   )4200115116U,      (u32 const   )3808662347U, 
        (u32 const   )821712160U,      (u32 const   )1986918061U,      (u32 const   )3430322568U,      (u32 const   )38544885U, 
        (u32 const   )3856137295U,      (u32 const   )718002117U,      (u32 const   )893681702U,      (u32 const   )1654886325U, 
        (u32 const   )2975484382U,      (u32 const   )3122358053U,      (u32 const   )3926825029U,      (u32 const   )4274053469U, 
        (u32 const   )796197571U,      (u32 const   )1290801793U,      (u32 const   )1184342925U,      (u32 const   )3556361835U, 
        (u32 const   )2405426947U,      (u32 const   )2459735317U,      (u32 const   )1836772287U,      (u32 const   )1381620373U, 
        (u32 const   )3196267988U,      (u32 const   )1948373848U,      (u32 const   )3764988233U,      (u32 const   )3385345166U, 
        (u32 const   )3263785589U,      (u32 const   )2390325492U,      (u32 const   )1480485785U,      (u32 const   )3111247143U, 
        (u32 const   )3780097726U,      (u32 const   )2293045232U,      (u32 const   )548169417U,      (u32 const   )3459953789U, 
        (u32 const   )3746175075U,      (u32 const   )439452389U,      (u32 const   )1362321559U,      (u32 const   )1400849762U, 
        (u32 const   )1685577905U,      (u32 const   )1806599355U,      (u32 const   )2174754046U,      (u32 const   )137073913U, 
        (u32 const   )1214797936U,      (u32 const   )1174215055U,      (u32 const   )3731654548U,      (u32 const   )2079897426U, 
        (u32 const   )1943217067U,      (u32 const   )1258480242U,      (u32 const   )529487843U,      (u32 const   )1437280870U, 
        (u32 const   )3945269170U,      (u32 const   )3049390895U,      (u32 const   )3313212038U,      (u32 const   )923313619U, 
        (u32 const   )679998000U,      (u32 const   )3215307299U,      (u32 const   )57326082U,      (u32 const   )377642221U, 
        (u32 const   )3474729866U,      (u32 const   )2041877159U,      (u32 const   )133361907U,      (u32 const   )1776460110U, 
        (u32 const   )3673476453U,      (u32 const   )96392454U,      (u32 const   )878845905U,      (u32 const   )2801699524U, 
        (u32 const   )777231668U,      (u32 const   )4082475170U,      (u32 const   )2330014213U,      (u32 const   )4142626212U, 
        (u32 const   )2213296395U,      (u32 const   )1626319424U,      (u32 const   )1906247262U,      (u32 const   )1846563261U, 
        (u32 const   )562755902U,      (u32 const   )3708173718U,      (u32 const   )1040559837U,      (u32 const   )3871163981U, 
        (u32 const   )1418573201U,      (u32 const   )3294430577U,      (u32 const   )114585348U,      (u32 const   )1343618912U, 
        (u32 const   )2566595609U,      (u32 const   )3186202582U,      (u32 const   )1078185097U,      (u32 const   )3651041127U, 
        (u32 const   )3896688048U,      (u32 const   )2307622919U,      (u32 const   )425408743U,      (u32 const   )3371096953U, 
        (u32 const   )2081048481U,      (u32 const   )1108339068U,      (u32 const   )2216610296U,      (u32 const   )0U, 
        (u32 const   )2156299017U,      (u32 const   )736970802U,      (u32 const   )292596766U,      (u32 const   )1517440620U, 
        (u32 const   )251657213U,      (u32 const   )2235061775U,      (u32 const   )2933202493U,      (u32 const   )758720310U, 
        (u32 const   )265905162U,      (u32 const   )1554391400U,      (u32 const   )1532285339U,      (u32 const   )908999204U, 
        (u32 const   )174567692U,      (u32 const   )1474760595U,      (u32 const   )4002861748U,      (u32 const   )2610011675U, 
        (u32 const   )3234156416U,      (u32 const   )3693126241U,      (u32 const   )2001430874U,      (u32 const   )303699484U, 
        (u32 const   )2478443234U,      (u32 const   )2687165888U,      (u32 const   )585122620U,      (u32 const   )454499602U, 
        (u32 const   )151849742U,      (u32 const   )2345119218U,      (u32 const   )3064510765U,      (u32 const   )514443284U, 
        (u32 const   )4044981591U,      (u32 const   )1963412655U,      (u32 const   )2581445614U,      (u32 const   )2137062819U, 
        (u32 const   )19308535U,      (u32 const   )1928707164U,      (u32 const   )1715193156U,      (u32 const   )4219352155U, 
        (u32 const   )1126790795U,      (u32 const   )600235211U,      (u32 const   )3992742070U,      (u32 const   )3841024952U, 
        (u32 const   )836553431U,      (u32 const   )1669664834U,      (u32 const   )2535604243U,      (u32 const   )3323011204U, 
        (u32 const   )1243905413U,      (u32 const   )3141400786U,      (u32 const   )4180808110U,      (u32 const   )698445255U, 
        (u32 const   )2653899549U,      (u32 const   )2989552604U,      (u32 const   )2253581325U,      (u32 const   )3252932727U, 
        (u32 const   )3004591147U,      (u32 const   )1891211689U,      (u32 const   )2487810577U,      (u32 const   )3915653703U, 
        (u32 const   )4237083816U,      (u32 const   )4030667424U,      (u32 const   )2100090966U,      (u32 const   )865136418U, 
        (u32 const   )1229899655U,      (u32 const   )953270745U,      (u32 const   )3399679628U,      (u32 const   )3557504664U, 
        (u32 const   )4118925222U,      (u32 const   )2061379749U,      (u32 const   )3079546586U,      (u32 const   )2915017791U, 
        (u32 const   )983426092U,      (u32 const   )2022837584U,      (u32 const   )1607244650U,      (u32 const   )2118541908U, 
        (u32 const   )2366882550U,      (u32 const   )3635996816U,      (u32 const   )972512814U,      (u32 const   )3283088770U, 
        (u32 const   )1568718495U,      (u32 const   )3499326569U,      (u32 const   )3576539503U,      (u32 const   )621982671U, 
        (u32 const   )2895723464U,      (u32 const   )410887952U,      (u32 const   )2623762152U,      (u32 const   )1002142683U, 
        (u32 const   )645401037U,      (u32 const   )1494807662U,      (u32 const   )2595684844U,      (u32 const   )1335535747U, 
        (u32 const   )2507040230U,      (u32 const   )4293295786U,      (u32 const   )3167684641U,      (u32 const   )367585007U, 
        (u32 const   )3885750714U,      (u32 const   )1865862730U,      (u32 const   )2668221674U,      (u32 const   )2960971305U, 
        (u32 const   )2763173681U,      (u32 const   )1059270954U,      (u32 const   )2777952454U,      (u32 const   )2724642869U, 
        (u32 const   )1320957812U,      (u32 const   )2194319100U,      (u32 const   )2429595872U,      (u32 const   )2815956275U, 
        (u32 const   )77089521U,      (u32 const   )3973773121U,      (u32 const   )3444575871U,      (u32 const   )2448830231U, 
        (u32 const   )1305906550U,      (u32 const   )4021308739U,      (u32 const   )2857194700U,      (u32 const   )2516901860U, 
        (u32 const   )3518358430U,      (u32 const   )1787304780U,      (u32 const   )740276417U,      (u32 const   )1699839814U, 
        (u32 const   )1592394909U,      (u32 const   )2352307457U,      (u32 const   )2272556026U,      (u32 const   )188821243U, 
        (u32 const   )1729977011U,      (u32 const   )3687994002U,      (u32 const   )274084841U,      (u32 const   )3594982253U, 
        (u32 const   )3613494426U,      (u32 const   )2701949495U,      (u32 const   )4162096729U,      (u32 const   )322734571U, 
        (u32 const   )2837966542U,      (u32 const   )1640576439U,      (u32 const   )484830689U,      (u32 const   )1202797690U, 
        (u32 const   )3537852828U,      (u32 const   )4067639125U,      (u32 const   )349075736U,      (u32 const   )3342319475U, 
        (u32 const   )4157467219U,      (u32 const   )4255800159U,      (u32 const   )1030690015U,      (u32 const   )1155237496U, 
        (u32 const   )2951971274U,      (u32 const   )1757691577U,      (u32 const   )607398968U,      (u32 const   )2738905026U, 
        (u32 const   )499347990U,      (u32 const   )3794078908U,      (u32 const   )1011452712U,      (u32 const   )227885567U, 
        (u32 const   )2818666809U,      (u32 const   )213114376U,      (u32 const   )3034881240U,      (u32 const   )1455525988U, 
        (u32 const   )3414450555U,      (u32 const   )850817237U,      (u32 const   )1817998408U,      (u32 const   )3092726480U};
#line 647 "rijndael.c"
static u32 const   Td4[256]  = 
#line 647
  {      (u32 const   )1381126738U,      (u32 const   )151587081U,      (u32 const   )1785358954U,      (u32 const   )3587560917U, 
        (u32 const   )808464432U,      (u32 const   )909522486U,      (u32 const   )2779096485U,      (u32 const   )943208504U, 
        (u32 const   )3217014719U,      (u32 const   )1077952576U,      (u32 const   )2745410467U,      (u32 const   )2661195422U, 
        (u32 const   )2172748161U,      (u32 const   )4092851187U,      (u32 const   )3621246935U,      (u32 const   )4227595259U, 
        (u32 const   )2088533116U,      (u32 const   )3823363043U,      (u32 const   )960051513U,      (u32 const   )2189591170U, 
        (u32 const   )2610666395U,      (u32 const   )791621423U,      (u32 const   )4294967295U,      (u32 const   )2273806215U, 
        (u32 const   )875836468U,      (u32 const   )2391707278U,      (u32 const   )1128481603U,      (u32 const   )1145324612U, 
        (u32 const   )3301229764U,      (u32 const   )3739147998U,      (u32 const   )3924421097U,      (u32 const   )3419130827U, 
        (u32 const   )1414812756U,      (u32 const   )2071690107U,      (u32 const   )2492765332U,      (u32 const   )842150450U, 
        (u32 const   )2795939494U,      (u32 const   )3267543746U,      (u32 const   )589505315U,      (u32 const   )1027423549U, 
        (u32 const   )4008636142U,      (u32 const   )1280068684U,      (u32 const   )2509608341U,      (u32 const   )185273099U, 
        (u32 const   )1111638594U,      (u32 const   )4210752250U,      (u32 const   )3284386755U,      (u32 const   )1313754702U, 
        (u32 const   )134744072U,      (u32 const   )774778414U,      (u32 const   )2711724449U,      (u32 const   )1717986918U, 
        (u32 const   )673720360U,      (u32 const   )3654932953U,      (u32 const   )606348324U,      (u32 const   )2998055602U, 
        (u32 const   )1987475062U,      (u32 const   )1532713819U,      (u32 const   )2728567458U,      (u32 const   )1229539657U, 
        (u32 const   )1835887981U,      (u32 const   )2341178251U,      (u32 const   )3520188881U,      (u32 const   )623191333U, 
        (u32 const   )1920103026U,      (u32 const   )4177066232U,      (u32 const   )4143380214U,      (u32 const   )1684300900U, 
        (u32 const   )2256963206U,      (u32 const   )1751672936U,      (u32 const   )2560137368U,      (u32 const   )370546198U, 
        (u32 const   )3570717908U,      (u32 const   )2762253476U,      (u32 const   )1549556828U,      (u32 const   )3435973836U, 
        (u32 const   )1566399837U,      (u32 const   )1701143909U,      (u32 const   )3065427638U,      (u32 const   )2459079314U, 
        (u32 const   )1819044972U,      (u32 const   )1886417008U,      (u32 const   )1212696648U,      (u32 const   )1347440720U, 
        (u32 const   )4261281277U,      (u32 const   )3991793133U,      (u32 const   )3115956665U,      (u32 const   )3671775962U, 
        (u32 const   )1583242846U,      (u32 const   )353703189U,      (u32 const   )1179010630U,      (u32 const   )1465341783U, 
        (u32 const   )2812782503U,      (u32 const   )2374864269U,      (u32 const   )2644352413U,      (u32 const   )2223277188U, 
        (u32 const   )2425393296U,      (u32 const   )3638089944U,      (u32 const   )2880154539U,      (u32 const   )0U, 
        (u32 const   )2358021260U,      (u32 const   )3166485692U,      (u32 const   )3553874899U,      (u32 const   )168430090U, 
        (u32 const   )4160223223U,      (u32 const   )3840206052U,      (u32 const   )1482184792U,      (u32 const   )84215045U, 
        (u32 const   )3099113656U,      (u32 const   )3014898611U,      (u32 const   )1162167621U,      (u32 const   )101058054U, 
        (u32 const   )3503345872U,      (u32 const   )741092396U,      (u32 const   )505290270U,      (u32 const   )2408550287U, 
        (u32 const   )3402287818U,      (u32 const   )1061109567U,      (u32 const   )252645135U,      (u32 const   )33686018U, 
        (u32 const   )3250700737U,      (u32 const   )2947526575U,      (u32 const   )3183328701U,      (u32 const   )50529027U, 
        (u32 const   )16843009U,      (u32 const   )320017171U,      (u32 const   )2324335242U,      (u32 const   )1802201963U, 
        (u32 const   )976894522U,      (u32 const   )2442236305U,      (u32 const   )286331153U,      (u32 const   )1094795585U, 
        (u32 const   )1330597711U,      (u32 const   )1734829927U,      (u32 const   )3705461980U,      (u32 const   )3941264106U, 
        (u32 const   )2543294359U,      (u32 const   )4076008178U,      (u32 const   )3486502863U,      (u32 const   )3469659854U, 
        (u32 const   )4042322160U,      (u32 const   )3031741620U,      (u32 const   )3873892070U,      (u32 const   )1936946035U, 
        (u32 const   )2526451350U,      (u32 const   )2896997548U,      (u32 const   )1953789044U,      (u32 const   )572662306U, 
        (u32 const   )3890735079U,      (u32 const   )2913840557U,      (u32 const   )892679477U,      (u32 const   )2240120197U, 
        (u32 const   )3806520034U,      (u32 const   )4193909241U,      (u32 const   )926365495U,      (u32 const   )3907578088U, 
        (u32 const   )471604252U,      (u32 const   )1970632053U,      (u32 const   )3755991007U,      (u32 const   )1852730990U, 
        (u32 const   )1195853639U,      (u32 const   )4059165169U,      (u32 const   )437918234U,      (u32 const   )1903260017U, 
        (u32 const   )488447261U,      (u32 const   )690563369U,      (u32 const   )3318072773U,      (u32 const   )2307492233U, 
        (u32 const   )1869573999U,      (u32 const   )3082270647U,      (u32 const   )1650614882U,      (u32 const   )235802126U, 
        (u32 const   )2863311530U,      (u32 const   )404232216U,      (u32 const   )3200171710U,      (u32 const   )454761243U, 
        (u32 const   )4244438268U,      (u32 const   )1448498774U,      (u32 const   )1044266558U,      (u32 const   )1263225675U, 
        (u32 const   )3334915782U,      (u32 const   )3537031890U,      (u32 const   )2038004089U,      (u32 const   )538976288U, 
        (u32 const   )2593823386U,      (u32 const   )3688618971U,      (u32 const   )3233857728U,      (u32 const   )4278124286U, 
        (u32 const   )2021161080U,      (u32 const   )3452816845U,      (u32 const   )1515870810U,      (u32 const   )4109694196U, 
        (u32 const   )522133279U,      (u32 const   )3722304989U,      (u32 const   )2829625512U,      (u32 const   )858993459U, 
        (u32 const   )2290649224U,      (u32 const   )117901063U,      (u32 const   )3351758791U,      (u32 const   )825307441U, 
        (u32 const   )2981212593U,      (u32 const   )303174162U,      (u32 const   )269488144U,      (u32 const   )1499027801U, 
        (u32 const   )656877351U,      (u32 const   )2155905152U,      (u32 const   )3974950124U,      (u32 const   )1600085855U, 
        (u32 const   )1616928864U,      (u32 const   )1364283729U,      (u32 const   )2139062143U,      (u32 const   )2846468521U, 
        (u32 const   )421075225U,      (u32 const   )3048584629U,      (u32 const   )1246382666U,      (u32 const   )218959117U, 
        (u32 const   )757935405U,      (u32 const   )3857049061U,      (u32 const   )2054847098U,      (u32 const   )2678038431U, 
        (u32 const   )2475922323U,      (u32 const   )3385444809U,      (u32 const   )2627509404U,      (u32 const   )4025479151U, 
        (u32 const   )2694881440U,      (u32 const   )3772834016U,      (u32 const   )993737531U,      (u32 const   )1296911693U, 
        (u32 const   )2930683566U,      (u32 const   )707406378U,      (u32 const   )4126537205U,      (u32 const   )2964369584U, 
        (u32 const   )3368601800U,      (u32 const   )3958107115U,      (u32 const   )3149642683U,      (u32 const   )1010580540U, 
        (u32 const   )2206434179U,      (u32 const   )1397969747U,      (u32 const   )2576980377U,      (u32 const   )1633771873U, 
        (u32 const   )387389207U,      (u32 const   )724249387U,      (u32 const   )67372036U,      (u32 const   )2122219134U, 
        (u32 const   )3132799674U,      (u32 const   )2004318071U,      (u32 const   )3604403926U,      (u32 const   )640034342U, 
        (u32 const   )3789677025U,      (u32 const   )1768515945U,      (u32 const   )336860180U,      (u32 const   )1667457891U, 
        (u32 const   )1431655765U,      (u32 const   )555819297U,      (u32 const   )202116108U,      (u32 const   )2105376125U};
#line 713 "rijndael.c"
static u32 const   rcon[10]  = 
#line 713
  {      (u32 const   )16777216,      (u32 const   )33554432,      (u32 const   )67108864,      (u32 const   )134217728, 
        (u32 const   )268435456,      (u32 const   )536870912,      (u32 const   )1073741824,      (u32 const   )2147483648U, 
        (u32 const   )452984832,      (u32 const   )905969664};
#line 727 "rijndael.c"
static int rijndaelKeySetupEnc(u32 *rk , u8 const   *cipherKey , int keyBits ) 
{ int i ;
  u32 temp ;

  {
#line 728
  i = 0;
#line 731
  *(rk + 0) = ((((unsigned int )*(cipherKey + 0) << 24) ^ ((unsigned int )*(cipherKey + 1) << 16)) ^ ((unsigned int )*(cipherKey + 2) << 8)) ^ (unsigned int )*(cipherKey + 3);
#line 732
  *(rk + 1) = ((((unsigned int )*((cipherKey + 4) + 0) << 24) ^ ((unsigned int )*((cipherKey + 4) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 4) + 2) << 8)) ^ (unsigned int )*((cipherKey + 4) + 3);
#line 733
  *(rk + 2) = ((((unsigned int )*((cipherKey + 8) + 0) << 24) ^ ((unsigned int )*((cipherKey + 8) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 8) + 2) << 8)) ^ (unsigned int )*((cipherKey + 8) + 3);
#line 734
  *(rk + 3) = ((((unsigned int )*((cipherKey + 12) + 0) << 24) ^ ((unsigned int )*((cipherKey + 12) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 12) + 2) << 8)) ^ (unsigned int )*((cipherKey + 12) + 3);
#line 735
  if (keyBits == 128) {
#line 736
    while (1) {
#line 737
      temp = *(rk + 3);
#line 738
      *(rk + 4) = ((((*(rk + 0) ^ (unsigned int )(Te4[(temp >> 16) & 255U] & 4278190080U)) ^ (unsigned int )(Te4[(temp >> 8) & 255U] & 16711680U)) ^ (unsigned int )(Te4[temp & 255U] & 65280U)) ^ (unsigned int )(Te4[temp >> 24] & 255U)) ^ (unsigned int )rcon[i];
#line 744
      *(rk + 5) = *(rk + 1) ^ *(rk + 4);
#line 745
      *(rk + 6) = *(rk + 2) ^ *(rk + 5);
#line 746
      *(rk + 7) = *(rk + 3) ^ *(rk + 6);
#line 747
      i ++;
#line 747
      if (i == 10) {
#line 748
        return (10);
      }
#line 750
      rk += 4;
    }
  }
#line 753
  *(rk + 4) = ((((unsigned int )*((cipherKey + 16) + 0) << 24) ^ ((unsigned int )*((cipherKey + 16) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 16) + 2) << 8)) ^ (unsigned int )*((cipherKey + 16) + 3);
#line 754
  *(rk + 5) = ((((unsigned int )*((cipherKey + 20) + 0) << 24) ^ ((unsigned int )*((cipherKey + 20) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 20) + 2) << 8)) ^ (unsigned int )*((cipherKey + 20) + 3);
#line 755
  if (keyBits == 192) {
#line 756
    while (1) {
#line 757
      temp = *(rk + 5);
#line 758
      *(rk + 6) = ((((*(rk + 0) ^ (unsigned int )(Te4[(temp >> 16) & 255U] & 4278190080U)) ^ (unsigned int )(Te4[(temp >> 8) & 255U] & 16711680U)) ^ (unsigned int )(Te4[temp & 255U] & 65280U)) ^ (unsigned int )(Te4[temp >> 24] & 255U)) ^ (unsigned int )rcon[i];
#line 764
      *(rk + 7) = *(rk + 1) ^ *(rk + 6);
#line 765
      *(rk + 8) = *(rk + 2) ^ *(rk + 7);
#line 766
      *(rk + 9) = *(rk + 3) ^ *(rk + 8);
#line 767
      i ++;
#line 767
      if (i == 8) {
#line 768
        return (12);
      }
#line 770
      *(rk + 10) = *(rk + 4) ^ *(rk + 9);
#line 771
      *(rk + 11) = *(rk + 5) ^ *(rk + 10);
#line 772
      rk += 6;
    }
  }
#line 775
  *(rk + 6) = ((((unsigned int )*((cipherKey + 24) + 0) << 24) ^ ((unsigned int )*((cipherKey + 24) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 24) + 2) << 8)) ^ (unsigned int )*((cipherKey + 24) + 3);
#line 776
  *(rk + 7) = ((((unsigned int )*((cipherKey + 28) + 0) << 24) ^ ((unsigned int )*((cipherKey + 28) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 28) + 2) << 8)) ^ (unsigned int )*((cipherKey + 28) + 3);
#line 777
  if (keyBits == 256) {
#line 778
    while (1) {
#line 779
      temp = *(rk + 7);
#line 780
      *(rk + 8) = ((((*(rk + 0) ^ (unsigned int )(Te4[(temp >> 16) & 255U] & 4278190080U)) ^ (unsigned int )(Te4[(temp >> 8) & 255U] & 16711680U)) ^ (unsigned int )(Te4[temp & 255U] & 65280U)) ^ (unsigned int )(Te4[temp >> 24] & 255U)) ^ (unsigned int )rcon[i];
#line 786
      *(rk + 9) = *(rk + 1) ^ *(rk + 8);
#line 787
      *(rk + 10) = *(rk + 2) ^ *(rk + 9);
#line 788
      *(rk + 11) = *(rk + 3) ^ *(rk + 10);
#line 789
      i ++;
#line 789
      if (i == 7) {
#line 790
        return (14);
      }
#line 792
      temp = *(rk + 11);
#line 793
      *(rk + 12) = (((*(rk + 4) ^ (unsigned int )(Te4[temp >> 24] & 4278190080U)) ^ (unsigned int )(Te4[(temp >> 16) & 255U] & 16711680U)) ^ (unsigned int )(Te4[(temp >> 8) & 255U] & 65280U)) ^ (unsigned int )(Te4[temp & 255U] & 255U);
#line 798
      *(rk + 13) = *(rk + 5) ^ *(rk + 12);
#line 799
      *(rk + 14) = *(rk + 6) ^ *(rk + 13);
#line 800
      *(rk + 15) = *(rk + 7) ^ *(rk + 14);
#line 801
      rk += 8;
    }
  }
#line 804
  return (0);
}
}
#line 812 "rijndael.c"
static int rijndaelKeySetupDec(u32 *rk , u8 const   *cipherKey , int keyBits , int have_encrypt ) 
{ int Nr ;
  int i ;
  int j ;
  u32 temp ;

  {
#line 818
  if (have_encrypt) {
#line 819
    Nr = have_encrypt;
  } else {
#line 822
    Nr = rijndaelKeySetupEnc(rk, cipherKey, keyBits);
  }
#line 825
  i = 0;
#line 825
  j = 4 * Nr;
#line 825
  while (i < j) {
#line 826
    temp = *(rk + i);
#line 826
    *(rk + i) = *(rk + j);
#line 826
    *(rk + j) = temp;
#line 827
    temp = *(rk + (i + 1));
#line 827
    *(rk + (i + 1)) = *(rk + (j + 1));
#line 827
    *(rk + (j + 1)) = temp;
#line 828
    temp = *(rk + (i + 2));
#line 828
    *(rk + (i + 2)) = *(rk + (j + 2));
#line 828
    *(rk + (j + 2)) = temp;
#line 829
    temp = *(rk + (i + 3));
#line 829
    *(rk + (i + 3)) = *(rk + (j + 3));
#line 829
    *(rk + (j + 3)) = temp;
#line 825
    i += 4;
#line 825
    j -= 4;
  }
#line 832
  i = 1;
#line 832
  while (i < Nr) {
#line 833
    rk += 4;
#line 834
    *(rk + 0) = (unsigned int )(((Td0[Te4[*(rk + 0) >> 24] & 255U] ^ Td1[Te4[(*(rk + 0) >> 16) & 255U] & 255U]) ^ Td2[Te4[(*(rk + 0) >> 8) & 255U] & 255U]) ^ Td3[Te4[*(rk + 0) & 255U] & 255U]);
#line 839
    *(rk + 1) = (unsigned int )(((Td0[Te4[*(rk + 1) >> 24] & 255U] ^ Td1[Te4[(*(rk + 1) >> 16) & 255U] & 255U]) ^ Td2[Te4[(*(rk + 1) >> 8) & 255U] & 255U]) ^ Td3[Te4[*(rk + 1) & 255U] & 255U]);
#line 844
    *(rk + 2) = (unsigned int )(((Td0[Te4[*(rk + 2) >> 24] & 255U] ^ Td1[Te4[(*(rk + 2) >> 16) & 255U] & 255U]) ^ Td2[Te4[(*(rk + 2) >> 8) & 255U] & 255U]) ^ Td3[Te4[*(rk + 2) & 255U] & 255U]);
#line 849
    *(rk + 3) = (unsigned int )(((Td0[Te4[*(rk + 3) >> 24] & 255U] ^ Td1[Te4[(*(rk + 3) >> 16) & 255U] & 255U]) ^ Td2[Te4[(*(rk + 3) >> 8) & 255U] & 255U]) ^ Td3[Te4[*(rk + 3) & 255U] & 255U]);
#line 832
    i ++;
  }
#line 855
  return (Nr);
}
}
#line 858 "rijndael.c"
static void rijndaelEncrypt(u32 const   *rk , int Nr , u8 const   *pt , u8 *ct ) 
{ u32 s0 ;
  u32 s1 ;
  u32 s2 ;
  u32 s3 ;
  u32 t0 ;
  u32 t1 ;
  u32 t2 ;
  u32 t3 ;

  {
#line 868
  s0 = (((((unsigned int )*(pt + 0) << 24) ^ ((unsigned int )*(pt + 1) << 16)) ^ ((unsigned int )*(pt + 2) << 8)) ^ (unsigned int )*(pt + 3)) ^ (unsigned int )*(rk + 0);
#line 869
  s1 = (((((unsigned int )*((pt + 4) + 0) << 24) ^ ((unsigned int )*((pt + 4) + 1) << 16)) ^ ((unsigned int )*((pt + 4) + 2) << 8)) ^ (unsigned int )*((pt + 4) + 3)) ^ (unsigned int )*(rk + 1);
#line 870
  s2 = (((((unsigned int )*((pt + 8) + 0) << 24) ^ ((unsigned int )*((pt + 8) + 1) << 16)) ^ ((unsigned int )*((pt + 8) + 2) << 8)) ^ (unsigned int )*((pt + 8) + 3)) ^ (unsigned int )*(rk + 2);
#line 871
  s3 = (((((unsigned int )*((pt + 12) + 0) << 24) ^ ((unsigned int )*((pt + 12) + 1) << 16)) ^ ((unsigned int )*((pt + 12) + 2) << 8)) ^ (unsigned int )*((pt + 12) + 3)) ^ (unsigned int )*(rk + 3);
#line 874
  t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 4));
#line 875
  t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 5));
#line 876
  t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 6));
#line 877
  t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 7));
#line 879
  s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 8));
#line 880
  s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 9));
#line 881
  s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 10));
#line 882
  s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 11));
#line 884
  t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 12));
#line 885
  t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 13));
#line 886
  t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 14));
#line 887
  t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 15));
#line 889
  s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 16));
#line 890
  s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 17));
#line 891
  s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 18));
#line 892
  s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 19));
#line 894
  t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 20));
#line 895
  t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 21));
#line 896
  t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 22));
#line 897
  t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 23));
#line 899
  s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 24));
#line 900
  s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 25));
#line 901
  s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 26));
#line 902
  s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 27));
#line 904
  t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 28));
#line 905
  t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 29));
#line 906
  t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 30));
#line 907
  t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 31));
#line 909
  s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 32));
#line 910
  s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 33));
#line 911
  s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 34));
#line 912
  s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 35));
#line 914
  t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 36));
#line 915
  t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 37));
#line 916
  t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 38));
#line 917
  t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 39));
#line 918
  if (Nr > 10) {
#line 920
    s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 40));
#line 921
    s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 41));
#line 922
    s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 42));
#line 923
    s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 43));
#line 925
    t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 44));
#line 926
    t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 45));
#line 927
    t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 46));
#line 928
    t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 47));
#line 929
    if (Nr > 12) {
#line 931
      s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 48));
#line 932
      s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 49));
#line 933
      s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 50));
#line 934
      s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 51));
#line 936
      t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 52));
#line 937
      t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 53));
#line 938
      t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 54));
#line 939
      t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 55));
    }
  }
#line 942
  rk += Nr << 2;
#line 1009
  s0 = (unsigned int )(((((Te4[t0 >> 24] & 4278190080U) ^ (Te4[(t1 >> 16) & 255U] & 16711680U)) ^ (Te4[(t2 >> 8) & 255U] & 65280U)) ^ (Te4[t3 & 255U] & 255U)) ^ *(rk + 0));
#line 1015
  *(ct + 0) = (unsigned char )(s0 >> 24);
#line 1015
  *(ct + 1) = (unsigned char )(s0 >> 16);
#line 1015
  *(ct + 2) = (unsigned char )(s0 >> 8);
#line 1015
  *(ct + 3) = (unsigned char )s0;
#line 1016
  s1 = (unsigned int )(((((Te4[t1 >> 24] & 4278190080U) ^ (Te4[(t2 >> 16) & 255U] & 16711680U)) ^ (Te4[(t3 >> 8) & 255U] & 65280U)) ^ (Te4[t0 & 255U] & 255U)) ^ *(rk + 1));
#line 1022
  *((ct + 4) + 0) = (unsigned char )(s1 >> 24);
#line 1022
  *((ct + 4) + 1) = (unsigned char )(s1 >> 16);
#line 1022
  *((ct + 4) + 2) = (unsigned char )(s1 >> 8);
#line 1022
  *((ct + 4) + 3) = (unsigned char )s1;
#line 1023
  s2 = (unsigned int )(((((Te4[t2 >> 24] & 4278190080U) ^ (Te4[(t3 >> 16) & 255U] & 16711680U)) ^ (Te4[(t0 >> 8) & 255U] & 65280U)) ^ (Te4[t1 & 255U] & 255U)) ^ *(rk + 2));
#line 1029
  *((ct + 8) + 0) = (unsigned char )(s2 >> 24);
#line 1029
  *((ct + 8) + 1) = (unsigned char )(s2 >> 16);
#line 1029
  *((ct + 8) + 2) = (unsigned char )(s2 >> 8);
#line 1029
  *((ct + 8) + 3) = (unsigned char )s2;
#line 1030
  s3 = (unsigned int )(((((Te4[t3 >> 24] & 4278190080U) ^ (Te4[(t0 >> 16) & 255U] & 16711680U)) ^ (Te4[(t1 >> 8) & 255U] & 65280U)) ^ (Te4[t2 & 255U] & 255U)) ^ *(rk + 3));
#line 1036
  *((ct + 12) + 0) = (unsigned char )(s3 >> 24);
#line 1036
  *((ct + 12) + 1) = (unsigned char )(s3 >> 16);
#line 1036
  *((ct + 12) + 2) = (unsigned char )(s3 >> 8);
#line 1036
  *((ct + 12) + 3) = (unsigned char )s3;
#line 1037
  return;
}
}
#line 1039 "rijndael.c"
static void rijndaelDecrypt(u32 const   *rk , int Nr , u8 const   *ct , u8 *pt ) 
{ u32 s0 ;
  u32 s1 ;
  u32 s2 ;
  u32 s3 ;
  u32 t0 ;
  u32 t1 ;
  u32 t2 ;
  u32 t3 ;

  {
#line 1049
  s0 = (((((unsigned int )*(ct + 0) << 24) ^ ((unsigned int )*(ct + 1) << 16)) ^ ((unsigned int )*(ct + 2) << 8)) ^ (unsigned int )*(ct + 3)) ^ (unsigned int )*(rk + 0);
#line 1050
  s1 = (((((unsigned int )*((ct + 4) + 0) << 24) ^ ((unsigned int )*((ct + 4) + 1) << 16)) ^ ((unsigned int )*((ct + 4) + 2) << 8)) ^ (unsigned int )*((ct + 4) + 3)) ^ (unsigned int )*(rk + 1);
#line 1051
  s2 = (((((unsigned int )*((ct + 8) + 0) << 24) ^ ((unsigned int )*((ct + 8) + 1) << 16)) ^ ((unsigned int )*((ct + 8) + 2) << 8)) ^ (unsigned int )*((ct + 8) + 3)) ^ (unsigned int )*(rk + 2);
#line 1052
  s3 = (((((unsigned int )*((ct + 12) + 0) << 24) ^ ((unsigned int )*((ct + 12) + 1) << 16)) ^ ((unsigned int )*((ct + 12) + 2) << 8)) ^ (unsigned int )*((ct + 12) + 3)) ^ (unsigned int )*(rk + 3);
#line 1055
  t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 4));
#line 1056
  t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 5));
#line 1057
  t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 6));
#line 1058
  t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 7));
#line 1060
  s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 8));
#line 1061
  s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 9));
#line 1062
  s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 10));
#line 1063
  s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 11));
#line 1065
  t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 12));
#line 1066
  t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 13));
#line 1067
  t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 14));
#line 1068
  t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 15));
#line 1070
  s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 16));
#line 1071
  s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 17));
#line 1072
  s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 18));
#line 1073
  s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 19));
#line 1075
  t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 20));
#line 1076
  t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 21));
#line 1077
  t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 22));
#line 1078
  t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 23));
#line 1080
  s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 24));
#line 1081
  s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 25));
#line 1082
  s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 26));
#line 1083
  s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 27));
#line 1085
  t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 28));
#line 1086
  t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 29));
#line 1087
  t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 30));
#line 1088
  t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 31));
#line 1090
  s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 32));
#line 1091
  s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 33));
#line 1092
  s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 34));
#line 1093
  s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 35));
#line 1095
  t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 36));
#line 1096
  t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 37));
#line 1097
  t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 38));
#line 1098
  t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 39));
#line 1099
  if (Nr > 10) {
#line 1101
    s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 40));
#line 1102
    s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 41));
#line 1103
    s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 42));
#line 1104
    s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 43));
#line 1106
    t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 44));
#line 1107
    t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 45));
#line 1108
    t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 46));
#line 1109
    t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 47));
#line 1110
    if (Nr > 12) {
#line 1112
      s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 48));
#line 1113
      s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 49));
#line 1114
      s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 50));
#line 1115
      s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 51));
#line 1117
      t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 52));
#line 1118
      t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 53));
#line 1119
      t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 54));
#line 1120
      t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 55));
    }
  }
#line 1123
  rk += Nr << 2;
#line 1190
  s0 = (unsigned int )(((((Td4[t0 >> 24] & 4278190080U) ^ (Td4[(t3 >> 16) & 255U] & 16711680U)) ^ (Td4[(t2 >> 8) & 255U] & 65280U)) ^ (Td4[t1 & 255U] & 255U)) ^ *(rk + 0));
#line 1196
  *(pt + 0) = (unsigned char )(s0 >> 24);
#line 1196
  *(pt + 1) = (unsigned char )(s0 >> 16);
#line 1196
  *(pt + 2) = (unsigned char )(s0 >> 8);
#line 1196
  *(pt + 3) = (unsigned char )s0;
#line 1197
  s1 = (unsigned int )(((((Td4[t1 >> 24] & 4278190080U) ^ (Td4[(t0 >> 16) & 255U] & 16711680U)) ^ (Td4[(t3 >> 8) & 255U] & 65280U)) ^ (Td4[t2 & 255U] & 255U)) ^ *(rk + 1));
#line 1203
  *((pt + 4) + 0) = (unsigned char )(s1 >> 24);
#line 1203
  *((pt + 4) + 1) = (unsigned char )(s1 >> 16);
#line 1203
  *((pt + 4) + 2) = (unsigned char )(s1 >> 8);
#line 1203
  *((pt + 4) + 3) = (unsigned char )s1;
#line 1204
  s2 = (unsigned int )(((((Td4[t2 >> 24] & 4278190080U) ^ (Td4[(t1 >> 16) & 255U] & 16711680U)) ^ (Td4[(t0 >> 8) & 255U] & 65280U)) ^ (Td4[t3 & 255U] & 255U)) ^ *(rk + 2));
#line 1210
  *((pt + 8) + 0) = (unsigned char )(s2 >> 24);
#line 1210
  *((pt + 8) + 1) = (unsigned char )(s2 >> 16);
#line 1210
  *((pt + 8) + 2) = (unsigned char )(s2 >> 8);
#line 1210
  *((pt + 8) + 3) = (unsigned char )s2;
#line 1211
  s3 = (unsigned int )(((((Td4[t3 >> 24] & 4278190080U) ^ (Td4[(t2 >> 16) & 255U] & 16711680U)) ^ (Td4[(t1 >> 8) & 255U] & 65280U)) ^ (Td4[t0 & 255U] & 255U)) ^ *(rk + 3));
#line 1217
  *((pt + 12) + 0) = (unsigned char )(s3 >> 24);
#line 1217
  *((pt + 12) + 1) = (unsigned char )(s3 >> 16);
#line 1217
  *((pt + 12) + 2) = (unsigned char )(s3 >> 8);
#line 1217
  *((pt + 12) + 3) = (unsigned char )s3;
#line 1218
  return;
}
}
#line 1220 "rijndael.c"
void rijndael_set_key(rijndael_ctx *ctx , u_char *key , int bits , int encrypt ) 
{ 

  {
#line 1223
  ctx->Nr = rijndaelKeySetupEnc(ctx->ek, (u8 const   *)key, bits);
#line 1224
  if (encrypt) {
#line 1225
    ctx->decrypt = 0;
#line 1226
    memset((void *)(ctx->dk), 0, sizeof(ctx->dk));
  } else {
#line 1228
    ctx->decrypt = 1;
#line 1229
    memcpy((void * __restrict  )(ctx->dk), (void const   * __restrict  )(ctx->ek),
           sizeof(ctx->dk));
#line 1230
    rijndaelKeySetupDec(ctx->dk, (u8 const   *)key, bits, ctx->Nr);
  }
#line 1232
  return;
}
}
#line 1234 "rijndael.c"
void rijndael_decrypt(rijndael_ctx *ctx , u_char *src , u_char *dst ) 
{ 

  {
#line 1237
  rijndaelDecrypt((u32 const   *)(ctx->dk), ctx->Nr, (u8 const   *)src, (u8 *)dst);
#line 1238
  return;
}
}
#line 1240 "rijndael.c"
void rijndael_encrypt(rijndael_ctx *ctx , u_char *src , u_char *dst ) 
{ 

  {
#line 1243
  rijndaelEncrypt((u32 const   *)(ctx->ek), ctx->Nr, (u8 const   *)src, (u8 *)dst);
#line 1244
  return;
}
}
#line 1 "ssh-dss.o"
#line 175 "/usr/include/openssl/dsa.h"
extern DSA_SIG *DSA_SIG_new(void) ;
#line 176
extern void DSA_SIG_free(DSA_SIG *a ) ;
#line 180
extern DSA_SIG *DSA_do_sign(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
#line 181
extern int DSA_do_verify(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                         DSA *dsa ) ;
#line 41 "ssh-dss.c"
int ssh_dss_sign(Key const   *key , u_char **sigp , u_int *lenp , u_char const   *data ,
                 u_int datalen ) 
{ DSA_SIG *sig ;
  EVP_MD const   *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  u_char digest___1[64] ;
  u_char sigblob[40] ;
  u_int rlen ;
  u_int slen ;
  u_int len ;
  u_int dlen ;
  Buffer b ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 46
  tmp = EVP_sha1();
#line 46
  evp_md = tmp;
#line 52
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 53
    error("ssh_dss_sign: no DSA key");
#line 54
    return (-1);
  } else {
#line 52
    if (key->type != 2) {
#line 53
      error("ssh_dss_sign: no DSA key");
#line 54
      return (-1);
    } else {
#line 52
      if ((unsigned int )key->dsa == (unsigned int )((void *)0)) {
#line 53
        error("ssh_dss_sign: no DSA key");
#line 54
        return (-1);
      }
    }
  }
#line 56
  EVP_DigestInit(& md, evp_md);
#line 57
  EVP_DigestUpdate(& md, (void const   *)data, datalen);
#line 58
  EVP_DigestFinal(& md, digest___1, & dlen);
#line 60
  sig = DSA_do_sign((unsigned char const   *)(digest___1), (int )dlen, (DSA *)key->dsa);
#line 61
  memset((void *)(digest___1), 'd', sizeof(digest___1));
#line 63
  if ((unsigned int )sig == (unsigned int )((void *)0)) {
#line 64
    error("ssh_dss_sign: sign failed");
#line 65
    return (-1);
  }
#line 68
  tmp___0 = BN_num_bits((BIGNUM const   *)sig->r);
#line 68
  rlen = (unsigned int )((tmp___0 + 7) / 8);
#line 69
  tmp___1 = BN_num_bits((BIGNUM const   *)sig->s);
#line 69
  slen = (unsigned int )((tmp___1 + 7) / 8);
#line 70
  if (rlen > 20U) {
#line 71
    error("bad sig size %u %u", rlen, slen);
#line 72
    DSA_SIG_free(sig);
#line 73
    return (-1);
  } else {
#line 70
    if (slen > 20U) {
#line 71
      error("bad sig size %u %u", rlen, slen);
#line 72
      DSA_SIG_free(sig);
#line 73
      return (-1);
    }
  }
#line 75
  memset((void *)(sigblob), 0, 40U);
#line 76
  BN_bn2bin((BIGNUM const   *)sig->r, ((sigblob + 40) - 20) - rlen);
#line 77
  BN_bn2bin((BIGNUM const   *)sig->s, (sigblob + 40) - slen);
#line 78
  DSA_SIG_free(sig);
#line 80
  if (datafellows & 1) {
#line 81
    if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 82
      *lenp = 40U;
    }
#line 83
    if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 84
      tmp___2 = xmalloc(40U);
#line 84
      *sigp = (u_char *)tmp___2;
#line 85
      memcpy((void * __restrict  )*sigp, (void const   * __restrict  )(sigblob), 40U);
    }
  } else {
#line 89
    buffer_init(& b);
#line 90
    buffer_put_cstring(& b, "ssh-dss");
#line 91
    buffer_put_string(& b, (void const   *)(sigblob), 40U);
#line 92
    len = buffer_len(& b);
#line 93
    if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 94
      *lenp = len;
    }
#line 95
    if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 96
      tmp___3 = xmalloc(len);
#line 96
      *sigp = (u_char *)tmp___3;
#line 97
      tmp___4 = buffer_ptr(& b);
#line 97
      memcpy((void * __restrict  )*sigp, (void const   * __restrict  )tmp___4, len);
    }
#line 99
    buffer_free(& b);
  }
#line 101
  return (0);
}
}
#line 103 "ssh-dss.c"
int ssh_dss_verify(Key const   *key , u_char const   *signature , u_int signaturelen ,
                   u_char const   *data , u_int datalen ) 
{ DSA_SIG *sig ;
  EVP_MD const   *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  u_char digest___1[64] ;
  u_char *sigblob ;
  u_int len ;
  u_int dlen ;
  int rlen ;
  int ret ;
  Buffer b ;
  void *tmp___0 ;
  char *ktype ;
  void *tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;
  u_int tmp___13 ;
  char const   *tmp___15 ;

  {
#line 108
  tmp = EVP_sha1();
#line 108
  evp_md = tmp;
#line 115
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 116
    error("ssh_dss_verify: no DSA key");
#line 117
    return (-1);
  } else {
#line 115
    if (key->type != 2) {
#line 116
      error("ssh_dss_verify: no DSA key");
#line 117
      return (-1);
    } else {
#line 115
      if ((unsigned int )key->dsa == (unsigned int )((void *)0)) {
#line 116
        error("ssh_dss_verify: no DSA key");
#line 117
        return (-1);
      }
    }
  }
#line 121
  if (datafellows & 1) {
#line 122
    tmp___0 = xmalloc(signaturelen);
#line 122
    sigblob = (u_char *)tmp___0;
#line 123
    memcpy((void * __restrict  )sigblob, (void const   * __restrict  )signature, signaturelen);
#line 124
    len = signaturelen;
  } else {
#line 128
    buffer_init(& b);
#line 129
    buffer_append(& b, (void const   *)signature, signaturelen);
#line 130
    tmp___1 = buffer_get_string(& b, (u_int *)((void *)0));
#line 130
    ktype = (char *)tmp___1;
#line 131
    if (0) {
#line 131
      __s1_len = strlen("ssh-dss");
#line 131
      __s2_len = strlen((char const   *)ktype);
#line 131
      if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
        goto _L___0;
      } else {
#line 131
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 131
          if (! ((unsigned int )((void const   *)(ktype + 1)) - (unsigned int )((void const   *)ktype) == 1U)) {
#line 131
            tmp___11 = 1;
          } else {
#line 131
            if (__s2_len >= 4U) {
#line 131
              tmp___11 = 1;
            } else {
#line 131
              tmp___11 = 0;
            }
          }
        } else {
#line 131
          tmp___11 = 0;
        }
      }
#line 131
      if (tmp___11) {
#line 131
        tmp___7 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
      } else {
#line 131
        tmp___10 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
#line 131
        tmp___7 = tmp___10;
      }
    } else {
#line 131
      tmp___10 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
#line 131
      tmp___7 = tmp___10;
    }
#line 131
    if (tmp___7 != 0) {
#line 132
      error("ssh_dss_verify: cannot handle type %s", ktype);
#line 133
      buffer_free(& b);
#line 134
      xfree((void *)ktype);
#line 135
      return (-1);
    }
#line 137
    xfree((void *)ktype);
#line 138
    tmp___12 = buffer_get_string(& b, & len);
#line 138
    sigblob = (u_char *)tmp___12;
#line 139
    tmp___13 = buffer_len(& b);
#line 139
    rlen = (int )tmp___13;
#line 140
    buffer_free(& b);
#line 141
    if (rlen != 0) {
#line 142
      error("ssh_dss_verify: remaining bytes in signature %d", rlen);
#line 144
      xfree((void *)sigblob);
#line 145
      return (-1);
    }
  }
#line 149
  if (len != 40U) {
#line 150
    fatal("bad sigbloblen %u != SIGBLOB_LEN", len);
  }
#line 154
  sig = DSA_SIG_new();
#line 154
  if ((unsigned int )sig == (unsigned int )((void *)0)) {
#line 155
    fatal("ssh_dss_verify: DSA_SIG_new failed");
  }
#line 156
  sig->r = BN_new();
#line 156
  if ((unsigned int )sig->r == (unsigned int )((void *)0)) {
#line 157
    fatal("ssh_dss_verify: BN_new failed");
  }
#line 158
  sig->s = BN_new();
#line 158
  if ((unsigned int )sig->s == (unsigned int )((void *)0)) {
#line 159
    fatal("ssh_dss_verify: BN_new failed");
  }
#line 160
  BN_bin2bn((unsigned char const   *)sigblob, 20, sig->r);
#line 161
  BN_bin2bn((unsigned char const   *)(sigblob + 20), 20, sig->s);
#line 164
  memset((void *)sigblob, 0, len);
#line 165
  xfree((void *)sigblob);
#line 168
  EVP_DigestInit(& md, evp_md);
#line 169
  EVP_DigestUpdate(& md, (void const   *)data, datalen);
#line 170
  EVP_DigestFinal(& md, digest___1, & dlen);
#line 172
  ret = DSA_do_verify((unsigned char const   *)(digest___1), (int )dlen, sig, (DSA *)key->dsa);
#line 173
  memset((void *)(digest___1), 'd', sizeof(digest___1));
#line 175
  DSA_SIG_free(sig);
#line 177
  if (ret == 1) {
#line 177
    tmp___15 = "correct";
  } else {
#line 177
    if (ret == 0) {
#line 177
      tmp___15 = "incorrect";
    } else {
#line 177
      tmp___15 = "error";
    }
  }
#line 177
  debug("ssh_dss_verify: signature %s", tmp___15);
#line 179
  return (ret);
}
}
#line 1 "ssh-rsa.o"
#line 1006 "/usr/include/openssl/objects.h"
extern char const   *OBJ_nid2sn(int n ) ;
#line 732 "/usr/include/openssl/evp.h"
extern EVP_MD const   *EVP_get_digestbyname(char const   *name ) ;
#line 271 "/usr/include/openssl/err.h"
extern char *ERR_error_string(unsigned long e , char *buf ) ;
#line 217 "/usr/include/openssl/rsa.h"
extern int RSA_size(RSA const   * ) ;
#line 234
extern int RSA_public_decrypt(int flen , unsigned char const   *from , unsigned char *to ,
                              RSA *rsa , int padding ) ;
#line 284
extern int RSA_sign(int type , unsigned char const   *m , unsigned int m_length ,
                    unsigned char *sigret , unsigned int *siglen , RSA *rsa ) ;
#line 30 "ssh-rsa.c"
static int openssh_RSA_verify(int type , u_char *hash , u_int hashlen , u_char *sigbuf ,
                              u_int siglen , RSA *rsa ) ;
#line 33 "ssh-rsa.c"
int ssh_rsa_sign(Key const   *key , u_char **sigp , u_int *lenp , u_char const   *data ,
                 u_int datalen ) 
{ EVP_MD const   *evp_md ;
  EVP_MD_CTX md ;
  u_char digest___1[64] ;
  u_char *sig ;
  u_int slen ;
  u_int dlen ;
  u_int len ;
  int ok ;
  int nid ;
  Buffer b ;
  char const   *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int ecode ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  u_int diff ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
#line 44
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 45
    error("ssh_rsa_sign: no RSA key");
#line 46
    return (-1);
  } else {
#line 44
    if (key->type != 1) {
#line 45
      error("ssh_rsa_sign: no RSA key");
#line 46
      return (-1);
    } else {
#line 44
      if ((unsigned int )key->rsa == (unsigned int )((void *)0)) {
#line 45
        error("ssh_rsa_sign: no RSA key");
#line 46
        return (-1);
      }
    }
  }
#line 48
  if (datafellows & 8192) {
#line 48
    nid = 4;
  } else {
#line 48
    nid = 64;
  }
#line 49
  tmp = OBJ_nid2sn(nid);
#line 49
  evp_md = EVP_get_digestbyname(tmp);
#line 49
  if ((unsigned int )evp_md == (unsigned int )((void *)0)) {
#line 50
    error("ssh_rsa_sign: EVP_get_digestbynid %d failed", nid);
#line 51
    return (-1);
  }
#line 53
  EVP_DigestInit(& md, evp_md);
#line 54
  EVP_DigestUpdate(& md, (void const   *)data, datalen);
#line 55
  EVP_DigestFinal(& md, digest___1, & dlen);
#line 57
  tmp___0 = RSA_size((RSA const   *)key->rsa);
#line 57
  slen = (unsigned int )tmp___0;
#line 58
  tmp___1 = xmalloc(slen);
#line 58
  sig = (u_char *)tmp___1;
#line 60
  ok = RSA_sign(nid, (unsigned char const   *)(digest___1), dlen, sig, & len, (RSA *)key->rsa);
#line 61
  memset((void *)(digest___1), 'd', sizeof(digest___1));
#line 63
  if (ok != 1) {
#line 64
    tmp___2 = ERR_get_error();
#line 64
    ecode = (int )tmp___2;
#line 65
    tmp___3 = ERR_error_string((unsigned long )ecode, (char *)((void *)0));
#line 65
    error("ssh_rsa_sign: RSA_sign failed: %s", tmp___3);
#line 67
    xfree((void *)sig);
#line 68
    return (-1);
  }
#line 70
  if (len < slen) {
#line 71
    diff = slen - len;
#line 72
    debug("slen %u > len %u", slen, len);
#line 73
    memmove((void *)(sig + diff), (void const   *)sig, len);
#line 74
    memset((void *)sig, 0, diff);
  } else {
#line 75
    if (len > slen) {
#line 76
      error("ssh_rsa_sign: slen %u slen2 %u", slen, len);
#line 77
      xfree((void *)sig);
#line 78
      return (-1);
    }
  }
#line 81
  buffer_init(& b);
#line 82
  buffer_put_cstring(& b, "ssh-rsa");
#line 83
  buffer_put_string(& b, (void const   *)sig, slen);
#line 84
  len = buffer_len(& b);
#line 85
  if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 86
    *lenp = len;
  }
#line 87
  if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 88
    tmp___4 = xmalloc(len);
#line 88
    *sigp = (u_char *)tmp___4;
#line 89
    tmp___5 = buffer_ptr(& b);
#line 89
    memcpy((void * __restrict  )*sigp, (void const   * __restrict  )tmp___5, len);
  }
#line 91
  buffer_free(& b);
#line 92
  memset((void *)sig, 's', slen);
#line 93
  xfree((void *)sig);
#line 95
  return (0);
}
}
#line 98 "ssh-rsa.c"
int ssh_rsa_verify(Key const   *key , u_char const   *signature , u_int signaturelen ,
                   u_char const   *data , u_int datalen ) 
{ Buffer b ;
  EVP_MD const   *evp_md ;
  EVP_MD_CTX md ;
  char *ktype ;
  u_char digest___1[64] ;
  u_char *sigblob ;
  u_int len ;
  u_int dlen ;
  u_int modlen ;
  int rlen ;
  int ret ;
  int nid ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;
  u_int tmp___13 ;
  int tmp___14 ;
  u_int diff ;
  void *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;

  {
#line 110
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 111
    error("ssh_rsa_verify: no RSA key");
#line 112
    return (-1);
  } else {
#line 110
    if (key->type != 1) {
#line 111
      error("ssh_rsa_verify: no RSA key");
#line 112
      return (-1);
    } else {
#line 110
      if ((unsigned int )key->rsa == (unsigned int )((void *)0)) {
#line 111
        error("ssh_rsa_verify: no RSA key");
#line 112
        return (-1);
      }
    }
  }
#line 114
  tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 114
  if (tmp___0 < 768) {
#line 115
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 115
    error("ssh_rsa_verify: RSA modulus too small: %d < minimum %d bits", tmp, 768);
#line 117
    return (-1);
  }
#line 119
  buffer_init(& b);
#line 120
  buffer_append(& b, (void const   *)signature, signaturelen);
#line 121
  tmp___1 = buffer_get_string(& b, (u_int *)((void *)0));
#line 121
  ktype = (char *)tmp___1;
#line 122
  if (0) {
#line 122
    __s1_len = strlen("ssh-rsa");
#line 122
    __s2_len = strlen((char const   *)ktype);
#line 122
    if (! ((unsigned int )((void const   *)("ssh-rsa" + 1)) - (unsigned int )((void const   *)"ssh-rsa") == 1U)) {
      goto _L___0;
    } else {
#line 122
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 122
        if (! ((unsigned int )((void const   *)(ktype + 1)) - (unsigned int )((void const   *)ktype) == 1U)) {
#line 122
          tmp___11 = 1;
        } else {
#line 122
          if (__s2_len >= 4U) {
#line 122
            tmp___11 = 1;
          } else {
#line 122
            tmp___11 = 0;
          }
        }
      } else {
#line 122
        tmp___11 = 0;
      }
    }
#line 122
    if (tmp___11) {
#line 122
      tmp___7 = __builtin_strcmp("ssh-rsa", (char const   *)ktype);
    } else {
#line 122
      tmp___10 = __builtin_strcmp("ssh-rsa", (char const   *)ktype);
#line 122
      tmp___7 = tmp___10;
    }
  } else {
#line 122
    tmp___10 = __builtin_strcmp("ssh-rsa", (char const   *)ktype);
#line 122
    tmp___7 = tmp___10;
  }
#line 122
  if (tmp___7 != 0) {
#line 123
    error("ssh_rsa_verify: cannot handle type %s", ktype);
#line 124
    buffer_free(& b);
#line 125
    xfree((void *)ktype);
#line 126
    return (-1);
  }
#line 128
  xfree((void *)ktype);
#line 129
  tmp___12 = buffer_get_string(& b, & len);
#line 129
  sigblob = (u_char *)tmp___12;
#line 130
  tmp___13 = buffer_len(& b);
#line 130
  rlen = (int )tmp___13;
#line 131
  buffer_free(& b);
#line 132
  if (rlen != 0) {
#line 133
    error("ssh_rsa_verify: remaining bytes in signature %d", rlen);
#line 134
    xfree((void *)sigblob);
#line 135
    return (-1);
  }
#line 138
  tmp___14 = RSA_size((RSA const   *)key->rsa);
#line 138
  modlen = (unsigned int )tmp___14;
#line 139
  if (len > modlen) {
#line 140
    error("ssh_rsa_verify: len %u > modlen %u", len, modlen);
#line 141
    xfree((void *)sigblob);
#line 142
    return (-1);
  } else {
#line 143
    if (len < modlen) {
#line 144
      diff = modlen - len;
#line 145
      debug("ssh_rsa_verify: add padding: modlen %u > len %u", modlen, len);
#line 147
      tmp___15 = xrealloc((void *)sigblob, modlen);
#line 147
      sigblob = (u_char *)tmp___15;
#line 148
      memmove((void *)(sigblob + diff), (void const   *)sigblob, len);
#line 149
      memset((void *)sigblob, 0, diff);
#line 150
      len = modlen;
    }
  }
#line 152
  if (datafellows & 8192) {
#line 152
    nid = 4;
  } else {
#line 152
    nid = 64;
  }
#line 153
  tmp___16 = OBJ_nid2sn(nid);
#line 153
  evp_md = EVP_get_digestbyname(tmp___16);
#line 153
  if ((unsigned int )evp_md == (unsigned int )((void *)0)) {
#line 154
    error("ssh_rsa_verify: EVP_get_digestbynid %d failed", nid);
#line 155
    xfree((void *)sigblob);
#line 156
    return (-1);
  }
#line 158
  EVP_DigestInit(& md, evp_md);
#line 159
  EVP_DigestUpdate(& md, (void const   *)data, datalen);
#line 160
  EVP_DigestFinal(& md, digest___1, & dlen);
#line 162
  ret = openssh_RSA_verify(nid, digest___1, dlen, sigblob, len, (RSA *)key->rsa);
#line 163
  memset((void *)(digest___1), 'd', sizeof(digest___1));
#line 164
  memset((void *)sigblob, 's', len);
#line 165
  xfree((void *)sigblob);
#line 166
  if (ret == 0) {
#line 166
    tmp___17 = "in";
  } else {
#line 166
    tmp___17 = "";
  }
#line 166
  debug("ssh_rsa_verify: signature %scorrect", tmp___17);
#line 167
  return (ret);
}
}
#line 179 "ssh-rsa.c"
static u_char const   id_sha1[15]  = 
#line 179
  {      (u_char const   )48,      (u_char const   )33,      (u_char const   )48,      (u_char const   )9, 
        (u_char const   )6,      (u_char const   )5,      (u_char const   )43,      (u_char const   )14, 
        (u_char const   )3,      (u_char const   )2,      (u_char const   )26,      (u_char const   )5, 
        (u_char const   )0,      (u_char const   )4,      (u_char const   )20};
#line 191 "ssh-rsa.c"
static u_char const   id_md5[18]  = 
#line 191
  {      (u_char const   )48,      (u_char const   )32,      (u_char const   )48,      (u_char const   )12, 
        (u_char const   )6,      (u_char const   )8,      (u_char const   )42,      (u_char const   )134, 
        (u_char const   )72,      (u_char const   )134,      (u_char const   )247,      (u_char const   )13, 
        (u_char const   )2,      (u_char const   )5,      (u_char const   )5,      (u_char const   )0, 
        (u_char const   )4,      (u_char const   )16};
#line 200 "ssh-rsa.c"
static int openssh_RSA_verify(int type , u_char *hash , u_int hashlen , u_char *sigbuf ,
                              u_int siglen , RSA *rsa ) 
{ u_int ret ;
  u_int rsasize ;
  u_int oidlen ;
  u_int hlen ;
  int len ;
  u_char const   *oid ;
  u_char *decrypted ;
  int tmp ;
  void *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 204
  oidlen = (u_int )0;
#line 204
  hlen = (u_int )0;
#line 206
  oid = (u_char const   *)((void *)0);
#line 207
  decrypted = (u_char *)((void *)0);
#line 209
  ret = 0U;
#line 210
  switch (type) {
  case 64: 
#line 212
  oid = id_sha1;
#line 213
  oidlen = sizeof(id_sha1);
#line 214
  hlen = 20U;
#line 215
  break;
  case 4: 
#line 217
  oid = id_md5;
#line 218
  oidlen = sizeof(id_md5);
#line 219
  hlen = 16U;
#line 220
  break;
  default: ;
  goto done;
#line 223
  break;
  }
#line 225
  if (hashlen != hlen) {
#line 226
    error("bad hashlen");
    goto done;
  }
#line 229
  tmp = RSA_size((RSA const   *)rsa);
#line 229
  rsasize = (unsigned int )tmp;
#line 230
  if (siglen == 0U) {
#line 231
    error("bad siglen");
    goto done;
  } else {
#line 230
    if (siglen > rsasize) {
#line 231
      error("bad siglen");
      goto done;
    }
  }
#line 234
  tmp___0 = xmalloc(rsasize);
#line 234
  decrypted = (u_char *)tmp___0;
#line 235
  len = RSA_public_decrypt((int )siglen, (unsigned char const   *)sigbuf, decrypted,
                           rsa, 1);
#line 235
  if (len < 0) {
#line 237
    tmp___1 = ERR_get_error();
#line 237
    tmp___2 = ERR_error_string(tmp___1, (char *)((void *)0));
#line 237
    error("RSA_public_decrypt failed: %s", tmp___2);
    goto done;
  }
#line 241
  if ((u_int )len != hlen + oidlen) {
#line 242
    error("bad decrypted len: %d != %d + %d", len, hlen, oidlen);
    goto done;
  }
#line 245
  tmp___3 = memcmp((void const   *)decrypted, (void const   *)oid, oidlen);
#line 245
  if (tmp___3 != 0) {
#line 246
    error("oid mismatch");
    goto done;
  }
#line 249
  tmp___4 = memcmp((void const   *)(decrypted + oidlen), (void const   *)hash, hlen);
#line 249
  if (tmp___4 != 0) {
#line 250
    error("hash mismatch");
    goto done;
  }
#line 253
  ret = 1U;
  done: 
#line 255
  if (decrypted) {
#line 256
    xfree((void *)decrypted);
  }
#line 257
  return ((int )ret);
}
}
#line 1 "dh.o"
#line 660 "/usr/include/stdio.h"
extern void rewind(FILE *__stream ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 459 "/usr/include/openssl/bn.h"
extern int BN_is_bit_set(BIGNUM const   *a , int n ) ;
#line 173 "/usr/include/openssl/dh.h"
extern DH *DH_new(void) ;
#line 193
extern int DH_generate_key(DH *dh ) ;
#line 35 "dh.h"
DH *choose_dh(int min , int wantbits , int max ) ;
#line 36
DH *dh_new_group_asc(char const   *gen___0 , char const   *modulus ) ;
#line 37
DH *dh_new_group(BIGNUM *gen___0 , BIGNUM *modulus ) ;
#line 38
DH *dh_new_group1(void) ;
#line 40
void dh_gen_key(DH *dh , int need ) ;
#line 41
int dh_pub_is_valid(DH *dh , BIGNUM *dh_pub ) ;
#line 43
int dh_estimate(int bits ) ;
#line 42 "dh.c"
static int parse_prime(int linenum , char *line , struct dhgroup *dhg ) 
{ char *cp ;
  char *arg ;
  char *strsize ;
  char *gen___0 ;
  char *prime ;
  char *tmp___14 ;
  char *tmp___30 ;
  char *tmp___46 ;
  char *tmp___62 ;
  char *tmp___78 ;
  char *tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;

  {
#line 48
  cp = line;
#line 49
  arg = strdelim(& cp);
#line 51
  if ((int )*arg == 0) {
#line 52
    arg = strdelim(& cp);
  }
#line 53
  if (! arg) {
#line 54
    return (0);
  } else {
#line 53
    if (! *arg) {
#line 54
      return (0);
    } else {
#line 53
      if ((int )*arg == 35) {
#line 54
        return (0);
      }
    }
  }
#line 57
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 57
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 59
  tmp___14 = __strsep_g(& cp, " ");
#line 59
  arg = tmp___14;
#line 60
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 60
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 62
  tmp___30 = __strsep_g(& cp, " ");
#line 62
  arg = tmp___30;
#line 63
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 63
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 65
  tmp___46 = __strsep_g(& cp, " ");
#line 65
  arg = tmp___46;
#line 66
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 66
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 68
  tmp___62 = __strsep_g(& cp, " ");
#line 68
  strsize = tmp___62;
#line 69
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 69
    if ((int )*strsize == 0) {
      goto fail;
    } else {
#line 69
      dhg->size = atoi((char const   *)strsize);
#line 69
      if (dhg->size == 0) {
        goto fail;
      }
    }
  }
#line 73
  (dhg->size) ++;
#line 74
  tmp___78 = __strsep_g(& cp, " ");
#line 74
  gen___0 = tmp___78;
#line 75
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 75
    if ((int )*gen___0 == 0) {
      goto fail;
    }
  }
#line 77
  tmp___94 = __strsep_g(& cp, " ");
#line 77
  prime = tmp___94;
#line 78
  if ((unsigned int )cp != (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 78
    if ((int )*prime == 0) {
      goto fail;
    }
  }
#line 81
  dhg->g = BN_new();
#line 81
  if ((unsigned int )dhg->g == (unsigned int )((void *)0)) {
#line 82
    fatal("parse_prime: BN_new failed");
  }
#line 83
  dhg->p = BN_new();
#line 83
  if ((unsigned int )dhg->p == (unsigned int )((void *)0)) {
#line 84
    fatal("parse_prime: BN_new failed");
  }
#line 85
  tmp___95 = BN_hex2bn(& dhg->g, (char const   *)gen___0);
#line 85
  if (tmp___95 == 0) {
    goto failclean;
  }
#line 88
  tmp___96 = BN_hex2bn(& dhg->p, (char const   *)prime);
#line 88
  if (tmp___96 == 0) {
    goto failclean;
  }
#line 91
  tmp___97 = BN_num_bits((BIGNUM const   *)dhg->p);
#line 91
  if (tmp___97 != dhg->size) {
    goto failclean;
  }
#line 94
  if ((dhg->g)->top == 0) {
    goto failclean;
  } else {
#line 94
    if ((dhg->g)->top == 1) {
#line 94
      if (*((dhg->g)->d + 0) == 1UL) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 94
      if (0) {
        _L: /* CIL Label */ 
#line 94
        if (! (dhg->g)->neg) {
          goto failclean;
        }
      }
    }
  }
#line 97
  return (1);
  failclean: 
#line 100
  BN_clear_free(dhg->g);
#line 101
  BN_clear_free(dhg->p);
  fail: 
#line 103
  error("Bad prime description in line %d", linenum);
#line 104
  return (0);
}
}
#line 107 "dh.c"
DH *choose_dh(int min , int wantbits , int max ) 
{ FILE *f ;
  char line[4096] ;
  int best ;
  int bestcount ;
  int which ;
  int linenum ;
  struct dhgroup dhg ;
  DH *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  DH *tmp___6 ;

  {
#line 116
  f = fopen((char const   * __restrict  )"/usr/local/etc/moduli", (char const   * __restrict  )"r");
#line 116
  if ((unsigned int )f == (unsigned int )((void *)0)) {
#line 116
    f = fopen((char const   * __restrict  )"/usr/local/etc/primes", (char const   * __restrict  )"r");
#line 116
    if ((unsigned int )f == (unsigned int )((void *)0)) {
#line 118
      logit("WARNING: %s does not exist, using old modulus", "/usr/local/etc/moduli");
#line 119
      tmp = dh_new_group1();
#line 119
      return (tmp);
    }
  }
#line 122
  linenum = 0;
#line 123
  bestcount = 0;
#line 123
  best = bestcount;
#line 124
  while (1) {
#line 124
    tmp___1 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 124
    if (! tmp___1) {
#line 124
      break;
    }
#line 125
    linenum ++;
#line 126
    tmp___0 = parse_prime(linenum, line, & dhg);
#line 126
    if (! tmp___0) {
#line 127
      continue;
    }
#line 128
    BN_clear_free(dhg.g);
#line 129
    BN_clear_free(dhg.p);
#line 131
    if (dhg.size > max) {
#line 132
      continue;
    } else {
#line 131
      if (dhg.size < min) {
#line 132
        continue;
      }
    }
#line 134
    if (dhg.size > wantbits) {
#line 134
      if (dhg.size < best) {
#line 136
        best = dhg.size;
#line 137
        bestcount = 0;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 134
      if (dhg.size > best) {
#line 134
        if (best < wantbits) {
#line 136
          best = dhg.size;
#line 137
          bestcount = 0;
        }
      }
    }
#line 139
    if (dhg.size == best) {
#line 140
      bestcount ++;
    }
  }
#line 142
  rewind(f);
#line 144
  if (bestcount == 0) {
#line 145
    fclose(f);
#line 146
    logit("WARNING: no suitable primes in %s", "/usr/local/etc/primes");
#line 147
    return ((DH *)((void *)0));
  }
#line 150
  linenum = 0;
#line 151
  tmp___2 = arc4random();
#line 151
  which = (int )(tmp___2 % (unsigned int )bestcount);
#line 152
  while (1) {
#line 152
    tmp___5 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 152
    if (! tmp___5) {
#line 152
      break;
    }
#line 153
    tmp___3 = parse_prime(linenum, line, & dhg);
#line 153
    if (! tmp___3) {
#line 154
      continue;
    }
#line 155
    if (dhg.size > max) {
#line 158
      BN_clear_free(dhg.g);
#line 159
      BN_clear_free(dhg.p);
#line 160
      continue;
    } else {
#line 155
      if (dhg.size < min) {
#line 158
        BN_clear_free(dhg.g);
#line 159
        BN_clear_free(dhg.p);
#line 160
        continue;
      } else {
#line 155
        if (dhg.size != best) {
#line 158
          BN_clear_free(dhg.g);
#line 159
          BN_clear_free(dhg.p);
#line 160
          continue;
        } else {
#line 155
          tmp___4 = linenum;
#line 155
          linenum ++;
#line 155
          if (tmp___4 != which) {
#line 158
            BN_clear_free(dhg.g);
#line 159
            BN_clear_free(dhg.p);
#line 160
            continue;
          }
        }
      }
    }
#line 162
    break;
  }
#line 164
  fclose(f);
#line 165
  if (linenum != which + 1) {
#line 166
    fatal("WARNING: line %d disappeared in %s, giving up", which, "/usr/local/etc/primes");
  }
#line 169
  tmp___6 = dh_new_group(dhg.g, dhg.p);
#line 169
  return (tmp___6);
}
}
#line 174 "dh.c"
int dh_pub_is_valid(DH *dh , BIGNUM *dh_pub ) 
{ int i ;
  int n___0 ;
  int tmp ;
  int bits_set ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 178
  tmp = BN_num_bits((BIGNUM const   *)dh_pub);
#line 178
  n___0 = tmp;
#line 179
  bits_set = 0;
#line 181
  if (dh_pub->neg) {
#line 182
    logit("invalid public DH value: negativ");
#line 183
    return (0);
  }
#line 185
  i = 0;
#line 185
  while (i <= n___0) {
#line 186
    tmp___0 = BN_is_bit_set((BIGNUM const   *)dh_pub, i);
#line 186
    if (tmp___0) {
#line 187
      bits_set ++;
    }
#line 185
    i ++;
  }
#line 188
  tmp___1 = BN_num_bits((BIGNUM const   *)dh->p);
#line 188
  debug2("bits set: %d/%d", bits_set, tmp___1);
#line 191
  if (bits_set > 1) {
#line 191
    tmp___2 = BN_cmp((BIGNUM const   *)dh_pub, (BIGNUM const   *)dh->p);
#line 191
    if (tmp___2 == -1) {
#line 192
      return (1);
    }
  }
#line 193
  tmp___3 = BN_num_bits((BIGNUM const   *)dh->p);
#line 193
  logit("invalid public DH value (%d/%d)", bits_set, tmp___3);
#line 194
  return (0);
}
}
#line 197 "dh.c"
void dh_gen_key(DH *dh , int need ) 
{ int i ;
  int bits_set ;
  int tries ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 200
  tries = 0;
#line 202
  if ((unsigned int )dh->p == (unsigned int )((void *)0)) {
#line 203
    fatal("dh_gen_key: dh->p == NULL");
  }
#line 204
  if (need > 1073741823) {
#line 205
    tmp = BN_num_bits((BIGNUM const   *)dh->p);
#line 205
    fatal("dh_gen_key: group too small: %d (2*need %d)", tmp, 2 * need);
  } else {
#line 204
    tmp___0 = BN_num_bits((BIGNUM const   *)dh->p);
#line 204
    if (2 * need >= tmp___0) {
#line 205
      tmp = BN_num_bits((BIGNUM const   *)dh->p);
#line 205
      fatal("dh_gen_key: group too small: %d (2*need %d)", tmp, 2 * need);
    }
  }
#line 207
  while (1) {
#line 208
    if ((unsigned int )dh->priv_key != (unsigned int )((void *)0)) {
#line 209
      BN_clear_free(dh->priv_key);
    }
#line 210
    dh->priv_key = BN_new();
#line 210
    if ((unsigned int )dh->priv_key == (unsigned int )((void *)0)) {
#line 211
      fatal("dh_gen_key: BN_new failed");
    }
#line 213
    tmp___1 = BN_rand(dh->priv_key, 2 * need, 0, 0);
#line 213
    if (! tmp___1) {
#line 214
      fatal("dh_gen_key: BN_rand failed");
    }
#line 215
    tmp___2 = DH_generate_key(dh);
#line 215
    if (tmp___2 == 0) {
#line 216
      fatal("DH_generate_key");
    }
#line 217
    i = 0;
#line 217
    bits_set = 0;
#line 217
    while (1) {
#line 217
      tmp___4 = BN_num_bits((BIGNUM const   *)dh->priv_key);
#line 217
      if (! (i <= tmp___4)) {
#line 217
        break;
      }
#line 218
      tmp___3 = BN_is_bit_set((BIGNUM const   *)dh->priv_key, i);
#line 218
      if (tmp___3) {
#line 219
        bits_set ++;
      }
#line 217
      i ++;
    }
#line 220
    tmp___5 = BN_num_bits((BIGNUM const   *)dh->priv_key);
#line 220
    debug2("dh_gen_key: priv key bits set: %d/%d", bits_set, tmp___5);
#line 222
    tmp___6 = tries;
#line 222
    tries ++;
#line 222
    if (tmp___6 > 10) {
#line 223
      fatal("dh_gen_key: too many bad keys: giving up");
    }
#line 207
    tmp___7 = dh_pub_is_valid(dh, dh->pub_key);
#line 207
    if (tmp___7) {
#line 207
      break;
    }
  }
#line 225
  return;
}
}
#line 227 "dh.c"
DH *dh_new_group_asc(char const   *gen___0 , char const   *modulus ) 
{ DH *dh ;
  int tmp ;
  int tmp___0 ;

  {
#line 232
  dh = DH_new();
#line 232
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 233
    fatal("dh_new_group_asc: DH_new");
  }
#line 235
  tmp = BN_hex2bn(& dh->p, modulus);
#line 235
  if (tmp == 0) {
#line 236
    fatal("BN_hex2bn p");
  }
#line 237
  tmp___0 = BN_hex2bn(& dh->g, gen___0);
#line 237
  if (tmp___0 == 0) {
#line 238
    fatal("BN_hex2bn g");
  }
#line 240
  return (dh);
}
}
#line 248 "dh.c"
DH *dh_new_group(BIGNUM *gen___0 , BIGNUM *modulus ) 
{ DH *dh ;

  {
#line 253
  dh = DH_new();
#line 253
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 254
    fatal("dh_new_group: DH_new");
  }
#line 255
  dh->p = modulus;
#line 256
  dh->g = gen___0;
#line 258
  return (dh);
}
}
#line 264 "dh.c"
static char *gen  =    (char *)"2";
#line 264 "dh.c"
static char *group1  =    (char *)"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF";
#line 261 "dh.c"
DH *dh_new_group1(void) 
{ DH *tmp ;

  {
#line 272
  tmp = dh_new_group_asc((char const   *)gen, (char const   *)group1);
#line 272
  return (tmp);
}
}
#line 281 "dh.c"
int dh_estimate(int bits ) 
{ 

  {
#line 285
  if (bits <= 128) {
#line 286
    return (1024);
  }
#line 287
  if (bits <= 192) {
#line 288
    return (2048);
  }
#line 289
  return (4096);
}
}
#line 1 "kexdh.o"
#line 133 "kex.h"
u_char *kex_dh_hash(char *client_version_string___0 , char *server_version_string___0 ,
                    char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                    u_char *serverhostkeyblob , int sbloblen , BIGNUM *client_dh_pub ,
                    BIGNUM *server_dh_pub , BIGNUM *shared_secret ) ;
#line 47 "kexdh.c"
static u_char digest[64]  ;
#line 35 "kexdh.c"
u_char *kex_dh_hash(char *client_version_string___0 , char *server_version_string___0 ,
                    char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                    u_char *serverhostkeyblob , int sbloblen , BIGNUM *client_dh_pub ,
                    BIGNUM *server_dh_pub , BIGNUM *shared_secret ) 
{ Buffer b ;
  EVP_MD const   *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  u_int tmp___0 ;
  void *tmp___1 ;

  {
#line 48
  tmp = EVP_sha1();
#line 48
  evp_md = tmp;
#line 51
  buffer_init(& b);
#line 52
  buffer_put_cstring(& b, (char const   *)client_version_string___0);
#line 53
  buffer_put_cstring(& b, (char const   *)server_version_string___0);
#line 56
  buffer_put_int(& b, (unsigned int )(ckexinitlen + 1));
#line 57
  buffer_put_char(& b, 20);
#line 58
  buffer_append(& b, (void const   *)ckexinit, (unsigned int )ckexinitlen);
#line 59
  buffer_put_int(& b, (unsigned int )(skexinitlen + 1));
#line 60
  buffer_put_char(& b, 20);
#line 61
  buffer_append(& b, (void const   *)skexinit, (unsigned int )skexinitlen);
#line 63
  buffer_put_string(& b, (void const   *)serverhostkeyblob, (unsigned int )sbloblen);
#line 64
  buffer_put_bignum2(& b, (BIGNUM const   *)client_dh_pub);
#line 65
  buffer_put_bignum2(& b, (BIGNUM const   *)server_dh_pub);
#line 66
  buffer_put_bignum2(& b, (BIGNUM const   *)shared_secret);
#line 71
  EVP_DigestInit(& md, evp_md);
#line 72
  tmp___0 = buffer_len(& b);
#line 72
  tmp___1 = buffer_ptr(& b);
#line 72
  EVP_DigestUpdate(& md, (void const   *)tmp___1, tmp___0);
#line 73
  EVP_DigestFinal(& md, digest, (unsigned int *)((void *)0));
#line 75
  buffer_free(& b);
#line 80
  return (digest);
}
}
#line 1 "kexgex.o"
#line 136 "kex.h"
u_char *kexgex_hash(char *client_version_string___0 , char *server_version_string___0 ,
                    char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                    u_char *serverhostkeyblob , int sbloblen , int min , int wantbits ,
                    int max , BIGNUM *prime , BIGNUM *gen___0 , BIGNUM *client_dh_pub ,
                    BIGNUM *server_dh_pub , BIGNUM *shared_secret ) ;
#line 49 "kexgex.c"
static u_char digest___0[64]  ;
#line 36 "kexgex.c"
u_char *kexgex_hash(char *client_version_string___0 , char *server_version_string___0 ,
                    char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                    u_char *serverhostkeyblob , int sbloblen , int min , int wantbits ,
                    int max , BIGNUM *prime , BIGNUM *gen___0 , BIGNUM *client_dh_pub ,
                    BIGNUM *server_dh_pub , BIGNUM *shared_secret ) 
{ Buffer b ;
  EVP_MD const   *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  u_int tmp___0 ;
  void *tmp___1 ;

  {
#line 50
  tmp = EVP_sha1();
#line 50
  evp_md = tmp;
#line 53
  buffer_init(& b);
#line 54
  buffer_put_cstring(& b, (char const   *)client_version_string___0);
#line 55
  buffer_put_cstring(& b, (char const   *)server_version_string___0);
#line 58
  buffer_put_int(& b, (unsigned int )(ckexinitlen + 1));
#line 59
  buffer_put_char(& b, 20);
#line 60
  buffer_append(& b, (void const   *)ckexinit, (unsigned int )ckexinitlen);
#line 61
  buffer_put_int(& b, (unsigned int )(skexinitlen + 1));
#line 62
  buffer_put_char(& b, 20);
#line 63
  buffer_append(& b, (void const   *)skexinit, (unsigned int )skexinitlen);
#line 65
  buffer_put_string(& b, (void const   *)serverhostkeyblob, (unsigned int )sbloblen);
#line 66
  if (min == -1) {
#line 67
    buffer_put_int(& b, (unsigned int )wantbits);
  } else {
#line 66
    if (max == -1) {
#line 67
      buffer_put_int(& b, (unsigned int )wantbits);
    } else {
#line 69
      buffer_put_int(& b, (unsigned int )min);
#line 70
      buffer_put_int(& b, (unsigned int )wantbits);
#line 71
      buffer_put_int(& b, (unsigned int )max);
    }
  }
#line 73
  buffer_put_bignum2(& b, (BIGNUM const   *)prime);
#line 74
  buffer_put_bignum2(& b, (BIGNUM const   *)gen___0);
#line 75
  buffer_put_bignum2(& b, (BIGNUM const   *)client_dh_pub);
#line 76
  buffer_put_bignum2(& b, (BIGNUM const   *)server_dh_pub);
#line 77
  buffer_put_bignum2(& b, (BIGNUM const   *)shared_secret);
#line 82
  EVP_DigestInit(& md, evp_md);
#line 83
  tmp___0 = buffer_len(& b);
#line 83
  tmp___1 = buffer_ptr(& b);
#line 83
  EVP_DigestUpdate(& md, (void const   *)tmp___1, tmp___0);
#line 84
  EVP_DigestFinal(& md, digest___0, (unsigned int *)((void *)0));
#line 86
  buffer_free(& b);
#line 91
  return (digest___0);
}
}
#line 1 "kexdhc.o"
#line 174 "/usr/include/openssl/dh.h"
extern void DH_free(DH *dh ) ;
#line 176
extern int DH_size(DH const   *dh ) ;
#line 194
extern int DH_compute_key(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
#line 128 "kex.h"
void kexdh_client(Kex *kex ) ;
#line 36 "kexdhc.c"
void kexdh_client(Kex *kex ) 
{ BIGNUM *dh_server_pub ;
  BIGNUM *shared_secret ;
  DH *dh ;
  Key *server_host_key ;
  u_char *server_host_key_blob ;
  u_char *signature ;
  u_char *kbuf ;
  u_char *hash ;
  u_int klen ;
  u_int kout ;
  u_int slen ;
  u_int sbloblen ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int _len ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  u_int tmp___7 ;
  void *tmp___8 ;
  u_int tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;

  {
#line 39
  dh_server_pub = (BIGNUM *)((void *)0);
#line 39
  shared_secret = (BIGNUM *)((void *)0);
#line 42
  server_host_key_blob = (u_char *)((void *)0);
#line 42
  signature = (u_char *)((void *)0);
#line 47
  dh = dh_new_group1();
#line 48
  dh_gen_key(dh, kex->we_need * 8);
#line 49
  packet_start((unsigned char)30);
#line 50
  packet_put_bignum2(dh->pub_key);
#line 51
  packet_send();
#line 53
  debug("sending SSH2_MSG_KEXDH_INIT");
#line 61
  debug("expecting SSH2_MSG_KEXDH_REPLY");
#line 62
  packet_read_expect(31);
#line 65
  tmp = packet_get_string(& sbloblen);
#line 65
  server_host_key_blob = (u_char *)tmp;
#line 66
  server_host_key = key_from_blob((u_char const   *)server_host_key_blob, sbloblen);
#line 67
  if ((unsigned int )server_host_key == (unsigned int )((void *)0)) {
#line 68
    fatal("cannot decode server_host_key_blob");
  }
#line 69
  if (server_host_key->type != kex->hostkey_type) {
#line 70
    fatal("type mismatch for decoded server_host_key_blob");
  }
#line 71
  if ((unsigned int )kex->verify_host_key == (unsigned int )((void *)0)) {
#line 72
    fatal("cannot verify server_host_key");
  }
#line 73
  tmp___0 = (*(kex->verify_host_key))(server_host_key);
#line 73
  if (tmp___0 == -1) {
#line 74
    fatal("server_host_key verification failed");
  }
#line 77
  dh_server_pub = BN_new();
#line 77
  if ((unsigned int )dh_server_pub == (unsigned int )((void *)0)) {
#line 78
    fatal("dh_server_pub == NULL");
  }
#line 79
  packet_get_bignum2(dh_server_pub);
#line 89
  tmp___1 = packet_get_string(& slen);
#line 89
  signature = (u_char *)tmp___1;
#line 90
  while (1) {
#line 90
    tmp___2 = packet_remaining();
#line 90
    _len = tmp___2;
#line 90
    if (_len > 0) {
#line 90
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kexdhc.c",
            90);
#line 90
      packet_disconnect("Packet integrity error.");
    }
#line 90
    break;
  }
#line 92
  tmp___3 = dh_pub_is_valid(dh, dh_server_pub);
#line 92
  if (! tmp___3) {
#line 93
    packet_disconnect("bad server public DH value");
  }
#line 95
  tmp___4 = DH_size((DH const   *)dh);
#line 95
  klen = (unsigned int )tmp___4;
#line 96
  tmp___5 = xmalloc(klen);
#line 96
  kbuf = (u_char *)tmp___5;
#line 97
  tmp___6 = DH_compute_key(kbuf, (BIGNUM const   *)dh_server_pub, dh);
#line 97
  kout = (unsigned int )tmp___6;
#line 101
  shared_secret = BN_new();
#line 101
  if ((unsigned int )shared_secret == (unsigned int )((void *)0)) {
#line 102
    fatal("kexdh_client: BN_new failed");
  }
#line 103
  BN_bin2bn((unsigned char const   *)kbuf, (int )kout, shared_secret);
#line 104
  memset((void *)kbuf, 0, klen);
#line 105
  xfree((void *)kbuf);
#line 108
  tmp___7 = buffer_len(& kex->peer);
#line 108
  tmp___8 = buffer_ptr(& kex->peer);
#line 108
  tmp___9 = buffer_len(& kex->my);
#line 108
  tmp___10 = buffer_ptr(& kex->my);
#line 108
  hash = kex_dh_hash(kex->client_version_string, kex->server_version_string, (char *)tmp___10,
                     (int )tmp___9, (char *)tmp___8, (int )tmp___7, server_host_key_blob,
                     (int )sbloblen, dh->pub_key, dh_server_pub, shared_secret);
#line 118
  xfree((void *)server_host_key_blob);
#line 119
  BN_clear_free(dh_server_pub);
#line 120
  DH_free(dh);
#line 122
  tmp___11 = key_verify((Key const   *)server_host_key, (u_char const   *)signature,
                        slen, (u_char const   *)hash, 20U);
#line 122
  if (tmp___11 != 1) {
#line 123
    fatal("key_verify failed for server_host_key");
  }
#line 124
  key_free(server_host_key);
#line 125
  xfree((void *)signature);
#line 128
  if ((unsigned int )kex->session_id == (unsigned int )((void *)0)) {
#line 129
    kex->session_id_len = 20U;
#line 130
    tmp___12 = xmalloc(kex->session_id_len);
#line 130
    kex->session_id = (u_char *)tmp___12;
#line 131
    memcpy((void * __restrict  )kex->session_id, (void const   * __restrict  )hash,
           kex->session_id_len);
  }
#line 134
  kex_derive_keys(kex, hash, shared_secret);
#line 135
  BN_clear_free(shared_secret);
#line 136
  kex_finish(kex);
#line 137
  return;
}
}
#line 1 "kexgexc.o"
#line 130 "kex.h"
void kexgex_client(Kex *kex ) ;
#line 38 "kexgexc.c"
void kexgex_client(Kex *kex ) 
{ BIGNUM *dh_server_pub ;
  BIGNUM *shared_secret ;
  BIGNUM *p ;
  BIGNUM *g ;
  Key *server_host_key ;
  u_char *kbuf ;
  u_char *hash ;
  u_char *signature ;
  u_char *server_host_key_blob ;
  u_int klen ;
  u_int kout ;
  u_int slen ;
  u_int sbloblen ;
  int min ;
  int max ;
  int nbits ;
  DH *dh ;
  int _len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int _len___0 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  u_int tmp___11 ;
  void *tmp___12 ;
  u_int tmp___13 ;
  void *tmp___14 ;
  int tmp___15 ;
  void *tmp___16 ;

  {
#line 41
  dh_server_pub = (BIGNUM *)((void *)0);
#line 41
  shared_secret = (BIGNUM *)((void *)0);
#line 42
  p = (BIGNUM *)((void *)0);
#line 42
  g = (BIGNUM *)((void *)0);
#line 44
  signature = (u_char *)((void *)0);
#line 44
  server_host_key_blob = (u_char *)((void *)0);
#line 49
  nbits = dh_estimate(kex->we_need * 8);
#line 51
  if (datafellows & 16384) {
#line 53
    packet_start((unsigned char)30);
#line 54
    packet_put_int((unsigned int )nbits);
#line 55
    min = 1024;
#line 56
    max = 8192;
#line 58
    debug("SSH2_MSG_KEX_DH_GEX_REQUEST_OLD(%u) sent", nbits);
  } else {
#line 61
    min = 1024;
#line 62
    max = 8192;
#line 63
    packet_start((unsigned char)34);
#line 64
    packet_put_int((unsigned int )min);
#line 65
    packet_put_int((unsigned int )nbits);
#line 66
    packet_put_int((unsigned int )max);
#line 68
    debug("SSH2_MSG_KEX_DH_GEX_REQUEST(%u<%u<%u) sent", min, nbits, max);
  }
#line 75
  packet_send();
#line 77
  debug("expecting SSH2_MSG_KEX_DH_GEX_GROUP");
#line 78
  packet_read_expect(31);
#line 80
  p = BN_new();
#line 80
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 81
    fatal("BN_new");
  }
#line 82
  packet_get_bignum2(p);
#line 83
  g = BN_new();
#line 83
  if ((unsigned int )g == (unsigned int )((void *)0)) {
#line 84
    fatal("BN_new");
  }
#line 85
  packet_get_bignum2(g);
#line 86
  while (1) {
#line 86
    tmp = packet_remaining();
#line 86
    _len = tmp;
#line 86
    if (_len > 0) {
#line 86
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kexgexc.c",
            86);
#line 86
      packet_disconnect("Packet integrity error.");
    }
#line 86
    break;
  }
#line 88
  tmp___1 = BN_num_bits((BIGNUM const   *)p);
#line 88
  if (tmp___1 < min) {
#line 89
    tmp___0 = BN_num_bits((BIGNUM const   *)p);
#line 89
    fatal("DH_GEX group out of range: %d !< %d !< %d", min, tmp___0, max);
  } else {
#line 88
    tmp___2 = BN_num_bits((BIGNUM const   *)p);
#line 88
    if (tmp___2 > max) {
#line 89
      tmp___0 = BN_num_bits((BIGNUM const   *)p);
#line 89
      fatal("DH_GEX group out of range: %d !< %d !< %d", min, tmp___0, max);
    }
  }
#line 92
  dh = dh_new_group(g, p);
#line 93
  dh_gen_key(dh, kex->we_need * 8);
#line 102
  debug("SSH2_MSG_KEX_DH_GEX_INIT sent");
#line 104
  packet_start((unsigned char)32);
#line 105
  packet_put_bignum2(dh->pub_key);
#line 106
  packet_send();
#line 108
  debug("expecting SSH2_MSG_KEX_DH_GEX_REPLY");
#line 109
  packet_read_expect(33);
#line 112
  tmp___3 = packet_get_string(& sbloblen);
#line 112
  server_host_key_blob = (u_char *)tmp___3;
#line 113
  server_host_key = key_from_blob((u_char const   *)server_host_key_blob, sbloblen);
#line 114
  if ((unsigned int )server_host_key == (unsigned int )((void *)0)) {
#line 115
    fatal("cannot decode server_host_key_blob");
  }
#line 116
  if (server_host_key->type != kex->hostkey_type) {
#line 117
    fatal("type mismatch for decoded server_host_key_blob");
  }
#line 118
  if ((unsigned int )kex->verify_host_key == (unsigned int )((void *)0)) {
#line 119
    fatal("cannot verify server_host_key");
  }
#line 120
  tmp___4 = (*(kex->verify_host_key))(server_host_key);
#line 120
  if (tmp___4 == -1) {
#line 121
    fatal("server_host_key verification failed");
  }
#line 124
  dh_server_pub = BN_new();
#line 124
  if ((unsigned int )dh_server_pub == (unsigned int )((void *)0)) {
#line 125
    fatal("dh_server_pub == NULL");
  }
#line 126
  packet_get_bignum2(dh_server_pub);
#line 136
  tmp___5 = packet_get_string(& slen);
#line 136
  signature = (u_char *)tmp___5;
#line 137
  while (1) {
#line 137
    tmp___6 = packet_remaining();
#line 137
    _len___0 = tmp___6;
#line 137
    if (_len___0 > 0) {
#line 137
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "kexgexc.c",
            137);
#line 137
      packet_disconnect("Packet integrity error.");
    }
#line 137
    break;
  }
#line 139
  tmp___7 = dh_pub_is_valid(dh, dh_server_pub);
#line 139
  if (! tmp___7) {
#line 140
    packet_disconnect("bad server public DH value");
  }
#line 142
  tmp___8 = DH_size((DH const   *)dh);
#line 142
  klen = (unsigned int )tmp___8;
#line 143
  tmp___9 = xmalloc(klen);
#line 143
  kbuf = (u_char *)tmp___9;
#line 144
  tmp___10 = DH_compute_key(kbuf, (BIGNUM const   *)dh_server_pub, dh);
#line 144
  kout = (unsigned int )tmp___10;
#line 148
  shared_secret = BN_new();
#line 148
  if ((unsigned int )shared_secret == (unsigned int )((void *)0)) {
#line 149
    fatal("kexgex_client: BN_new failed");
  }
#line 150
  BN_bin2bn((unsigned char const   *)kbuf, (int )kout, shared_secret);
#line 151
  memset((void *)kbuf, 0, klen);
#line 152
  xfree((void *)kbuf);
#line 154
  if (datafellows & 16384) {
#line 155
    max = -1;
#line 155
    min = max;
  }
#line 158
  tmp___11 = buffer_len(& kex->peer);
#line 158
  tmp___12 = buffer_ptr(& kex->peer);
#line 158
  tmp___13 = buffer_len(& kex->my);
#line 158
  tmp___14 = buffer_ptr(& kex->my);
#line 158
  hash = kexgex_hash(kex->client_version_string, kex->server_version_string, (char *)tmp___14,
                     (int )tmp___13, (char *)tmp___12, (int )tmp___11, server_host_key_blob,
                     (int )sbloblen, min, nbits, max, dh->p, dh->g, dh->pub_key, dh_server_pub,
                     shared_secret);
#line 171
  DH_free(dh);
#line 172
  xfree((void *)server_host_key_blob);
#line 173
  BN_clear_free(dh_server_pub);
#line 175
  tmp___15 = key_verify((Key const   *)server_host_key, (u_char const   *)signature,
                        slen, (u_char const   *)hash, 20U);
#line 175
  if (tmp___15 != 1) {
#line 176
    fatal("key_verify failed for server_host_key");
  }
#line 177
  key_free(server_host_key);
#line 178
  xfree((void *)signature);
#line 181
  if ((unsigned int )kex->session_id == (unsigned int )((void *)0)) {
#line 182
    kex->session_id_len = 20U;
#line 183
    tmp___16 = xmalloc(kex->session_id_len);
#line 183
    kex->session_id = (u_char *)tmp___16;
#line 184
    memcpy((void * __restrict  )kex->session_id, (void const   * __restrict  )hash,
           kex->session_id_len);
  }
#line 186
  kex_derive_keys(kex, hash, shared_secret);
#line 187
  BN_clear_free(shared_secret);
#line 189
  kex_finish(kex);
#line 190
  return;
}
}
#line 1 "scard.o"
#line 1 "msg.o"
#line 28 "msg.h"
int ssh_msg_send(int fd , u_char type , Buffer *m___0 ) ;
#line 29
int ssh_msg_recv(int fd , Buffer *m___0 ) ;
#line 33 "msg.c"
int ssh_msg_send(int fd , u_char type , Buffer *m___0 ) 
{ u_char buf___1[5] ;
  u_int mlen ;
  u_int tmp ;
  ssize_t tmp___0 ;
  void *tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 37
  tmp = buffer_len(m___0);
#line 37
  mlen = tmp;
#line 39
  debug3("ssh_msg_send: type %u", (unsigned int )type & 255U);
#line 41
  while (1) {
#line 41
    buf___1[0] = (unsigned char )((mlen + 1U) >> 24);
#line 41
    buf___1[1] = (unsigned char )((mlen + 1U) >> 16);
#line 41
    buf___1[2] = (unsigned char )((mlen + 1U) >> 8);
#line 41
    buf___1[3] = (unsigned char )(mlen + 1U);
#line 41
    break;
  }
#line 42
  buf___1[4] = type;
#line 43
  tmp___0 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), fd, (void *)(buf___1),
                     sizeof(buf___1));
#line 43
  if ((unsigned int )tmp___0 != sizeof(buf___1)) {
#line 44
    error("ssh_msg_send: write");
#line 45
    return (-1);
  }
#line 47
  tmp___1 = buffer_ptr(m___0);
#line 47
  tmp___2 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), fd, tmp___1,
                     mlen);
#line 47
  if ((u_int )tmp___2 != mlen) {
#line 48
    error("ssh_msg_send: write");
#line 49
    return (-1);
  }
#line 51
  return (0);
}
}
#line 54 "msg.c"
int ssh_msg_recv(int fd , Buffer *m___0 ) 
{ u_char buf___1[4] ;
  ssize_t res ;
  u_int msg_len ;
  void *tmp ;

  {
#line 61
  debug3("ssh_msg_recv entering");
#line 63
  res = atomicio(& read, fd, (void *)(buf___1), sizeof(buf___1));
#line 64
  if ((unsigned int )res != sizeof(buf___1)) {
#line 65
    if (res != 0) {
#line 66
      error("ssh_msg_recv: read: header %ld", (long )res);
    }
#line 67
    return (-1);
  }
#line 69
  msg_len = (unsigned int )(((((unsigned long )buf___1[0] << 24) | ((unsigned long )buf___1[1] << 16)) | ((unsigned long )buf___1[2] << 8)) | (unsigned long )buf___1[3]);
#line 70
  if (msg_len > 262144U) {
#line 71
    error("ssh_msg_recv: read: bad msg_len %u", msg_len);
#line 72
    return (-1);
  }
#line 74
  buffer_clear(m___0);
#line 75
  buffer_append_space(m___0, msg_len);
#line 76
  tmp = buffer_ptr(m___0);
#line 76
  res = atomicio(& read, fd, tmp, msg_len);
#line 77
  if ((u_int )res != msg_len) {
#line 78
    error("ssh_msg_recv: read: %ld != msg_len", (long )res);
#line 79
    return (-1);
  }
#line 81
  return (0);
}
}
#line 1 "progressmeter.o"
#line 393 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 581
extern  __attribute__((__nothrow__)) __pid_t getpgrp(void) ;
#line 805
extern  __attribute__((__nothrow__)) __pid_t tcgetpgrp(int __fd ) ;
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 26 "progressmeter.h"
void start_progress_meter(char *f , off_t filesize , off_t *stat___0 ) ;
#line 27
void stop_progress_meter(void) ;
#line 39 "progressmeter.c"
static int can_output(void) ;
#line 42
static void format_size(char *buf___1 , int size , off_t bytes ) ;
#line 43
static void format_rate(char *buf___1 , int size , off_t bytes ) ;
#line 46
void refresh_progress_meter(void) ;
#line 49
static void update_progress_meter(int ignore ) ;
#line 51 "progressmeter.c"
static time_t start  ;
#line 52 "progressmeter.c"
static time_t last_update  ;
#line 53 "progressmeter.c"
static char *file  ;
#line 54 "progressmeter.c"
static off_t end_pos  ;
#line 55 "progressmeter.c"
static off_t cur_pos  ;
#line 56 "progressmeter.c"
static off_t volatile   *counter  ;
#line 57 "progressmeter.c"
static long stalled  ;
#line 58 "progressmeter.c"
static int bytes_per_second  ;
#line 59 "progressmeter.c"
static int win_size  ;
#line 62 "progressmeter.c"
static char const   unit[6]  = {      (char const   )' ',      (char const   )'K',      (char const   )'M',      (char const   )'G', 
        (char const   )'T',      (char const   )'\000'};
#line 64 "progressmeter.c"
static int can_output(void) 
{ __pid_t tmp ;
  __pid_t tmp___0 ;

  {
#line 67
  tmp = getpgrp();
#line 67
  tmp___0 = tcgetpgrp(1);
#line 67
  return (tmp == tmp___0);
}
}
#line 70 "progressmeter.c"
static void format_rate(char *buf___1 , int size , off_t bytes ) 
{ int i ;
  char const   *tmp ;

  {
#line 75
  bytes *= 100LL;
#line 76
  i = 0;
#line 76
  while (1) {
#line 76
    if (bytes >= 100000LL) {
#line 76
      if (! ((int const   )unit[i] != 84)) {
#line 76
        break;
      }
    } else {
#line 76
      break;
    }
#line 77
    bytes = (bytes + 512LL) / 1024LL;
#line 76
    i ++;
  }
#line 78
  if (i == 0) {
#line 79
    i ++;
#line 80
    bytes = (bytes + 512LL) / 1024LL;
  }
#line 82
  if (i) {
#line 82
    tmp = "B";
  } else {
#line 82
    tmp = " ";
  }
#line 82
  snprintf((char * __restrict  )buf___1, (unsigned int )size, (char const   * __restrict  )"%3lld.%1lld%c%s",
           (bytes + 5LL) / 100LL, ((bytes + 5LL) / 10LL) % 10LL, unit[i], tmp);
#line 87
  return;
}
}
#line 89 "progressmeter.c"
static void format_size(char *buf___1 , int size , off_t bytes ) 
{ int i ;
  char const   *tmp ;

  {
#line 94
  i = 0;
#line 94
  while (1) {
#line 94
    if (bytes >= 10000LL) {
#line 94
      if (! ((int const   )unit[i] != 84)) {
#line 94
        break;
      }
    } else {
#line 94
      break;
    }
#line 95
    bytes = (bytes + 512LL) / 1024LL;
#line 94
    i ++;
  }
#line 96
  if (i) {
#line 96
    tmp = "B";
  } else {
#line 96
    tmp = " ";
  }
#line 96
  snprintf((char * __restrict  )buf___1, (unsigned int )size, (char const   * __restrict  )"%4lld%c%s",
           bytes, unit[i], tmp);
#line 100
  return;
}
}
#line 102 "progressmeter.c"
void refresh_progress_meter(void) 
{ char buf___1[513] ;
  time_t now ;
  off_t transferred ;
  double elapsed ;
  int percent ;
  off_t bytes_left ;
  int cur_speed ;
  int hours ;
  int minutes ;
  int seconds ;
  int i ;
  int len ;
  int file_len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
#line 116
  transferred = (long long )(*counter - (off_t volatile   )cur_pos);
#line 117
  cur_pos = (long long )*counter;
#line 118
  now = time((time_t *)((void *)0));
#line 119
  bytes_left = end_pos - cur_pos;
#line 121
  if (bytes_left > 0LL) {
#line 122
    elapsed = (double )(now - last_update);
  } else {
#line 124
    elapsed = (double )(now - start);
#line 126
    transferred = end_pos;
#line 127
    bytes_per_second = 0;
  }
#line 131
  if (elapsed != (double )0) {
#line 132
    cur_speed = (int )((double )transferred / elapsed);
  } else {
#line 134
    cur_speed = (int )transferred;
  }
#line 137
  if (bytes_per_second != 0) {
#line 138
    bytes_per_second = (int )((double )bytes_per_second * 0.9 + (double )cur_speed * (1.0 - 0.9));
  } else {
#line 141
    bytes_per_second = cur_speed;
  }
#line 144
  buf___1[0] = (char )'\000';
#line 145
  file_len = win_size - 35;
#line 146
  if (file_len > 0) {
#line 147
    len = snprintf((char * __restrict  )(buf___1), (unsigned int )(file_len + 1),
                   (char const   * __restrict  )"\r%s", file);
#line 148
    if (len < 0) {
#line 149
      len = 0;
    }
#line 150
    i = len;
#line 150
    while (i < file_len) {
#line 151
      buf___1[i] = (char )' ';
#line 150
      i ++;
    }
#line 152
    buf___1[file_len] = (char )'\000';
  }
#line 156
  if (end_pos != 0LL) {
#line 157
    percent = (int )(((float )cur_pos / (float )end_pos) * (float )100);
  } else {
#line 159
    percent = 100;
  }
#line 160
  tmp = strlen((char const   *)(buf___1));
#line 160
  tmp___0 = strlen((char const   *)(buf___1));
#line 160
  snprintf((char * __restrict  )(buf___1 + tmp___0), (size_t )win_size - tmp, (char const   * __restrict  )" %3d%% ",
           percent);
#line 164
  tmp___1 = strlen((char const   *)(buf___1));
#line 164
  tmp___2 = strlen((char const   *)(buf___1));
#line 164
  format_size(buf___1 + tmp___2, (int )((size_t )win_size - tmp___1), cur_pos);
#line 166
  strlcat(buf___1, " ", (unsigned int )win_size);
#line 169
  tmp___3 = strlen((char const   *)(buf___1));
#line 169
  tmp___4 = strlen((char const   *)(buf___1));
#line 169
  format_rate(buf___1 + tmp___4, (int )((size_t )win_size - tmp___3), (long long )bytes_per_second);
#line 171
  strlcat(buf___1, "/s ", (unsigned int )win_size);
#line 174
  if (! transferred) {
#line 175
    stalled = (long )((double )stalled + elapsed);
  } else {
#line 177
    stalled = 0L;
  }
#line 179
  if (stalled >= 5L) {
#line 180
    strlcat(buf___1, "- stalled -", (unsigned int )win_size);
  } else {
#line 181
    if (bytes_per_second == 0) {
#line 181
      if (bytes_left) {
#line 182
        strlcat(buf___1, "  --:-- ETA", (unsigned int )win_size);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 184
      if (bytes_left > 0LL) {
#line 185
        seconds = (int )(bytes_left / (off_t )bytes_per_second);
      } else {
#line 187
        seconds = (int )elapsed;
      }
#line 189
      hours = seconds / 3600;
#line 190
      seconds -= hours * 3600;
#line 191
      minutes = seconds / 60;
#line 192
      seconds -= minutes * 60;
#line 194
      if (hours != 0) {
#line 195
        tmp___5 = strlen((char const   *)(buf___1));
#line 195
        tmp___6 = strlen((char const   *)(buf___1));
#line 195
        snprintf((char * __restrict  )(buf___1 + tmp___6), (size_t )win_size - tmp___5,
                 (char const   * __restrict  )"%d:%02d:%02d", hours, minutes, seconds);
      } else {
#line 198
        tmp___7 = strlen((char const   *)(buf___1));
#line 198
        tmp___8 = strlen((char const   *)(buf___1));
#line 198
        snprintf((char * __restrict  )(buf___1 + tmp___8), (size_t )win_size - tmp___7,
                 (char const   * __restrict  )"  %02d:%02d", minutes, seconds);
      }
#line 201
      if (bytes_left > 0LL) {
#line 202
        strlcat(buf___1, " ETA", (unsigned int )win_size);
      } else {
#line 204
        strlcat(buf___1, "    ", (unsigned int )win_size);
      }
    }
  }
#line 207
  atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), 1, (void *)(buf___1),
           (unsigned int )(win_size - 1));
#line 208
  last_update = now;
#line 209
  return;
}
}
#line 211 "progressmeter.c"
static void update_progress_meter(int ignore ) 
{ int save_errno ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
#line 216
  tmp = __errno_location();
#line 216
  save_errno = *tmp;
#line 218
  tmp___0 = can_output();
#line 218
  if (tmp___0) {
#line 219
    refresh_progress_meter();
  }
#line 221
  mysignal(14, & update_progress_meter);
#line 222
  alarm(1U);
#line 223
  tmp___1 = __errno_location();
#line 223
  *tmp___1 = save_errno;
#line 224
  return;
}
}
#line 226 "progressmeter.c"
void start_progress_meter(char *f , off_t filesize , off_t *stat___0 ) 
{ struct winsize winsize ;
  int tmp ;
  int tmp___0 ;

  {
#line 231
  last_update = time((time_t *)((void *)0));
#line 231
  start = last_update;
#line 232
  file = f;
#line 233
  end_pos = filesize;
#line 234
  cur_pos = 0LL;
#line 235
  counter = (off_t volatile   *)stat___0;
#line 236
  stalled = 0L;
#line 237
  bytes_per_second = 0;
#line 239
  tmp = ioctl(1, 21523UL, & winsize);
#line 239
  if (tmp != -1) {
#line 239
    if ((int )winsize.ws_col != 0) {
#line 241
      if ((int )winsize.ws_col > 512) {
#line 242
        win_size = 512;
      } else {
#line 244
        win_size = (int )winsize.ws_col;
      }
    } else {
#line 246
      win_size = 80;
    }
  } else {
#line 246
    win_size = 80;
  }
#line 247
  win_size ++;
#line 249
  tmp___0 = can_output();
#line 249
  if (tmp___0) {
#line 250
    refresh_progress_meter();
  }
#line 252
  mysignal(14, & update_progress_meter);
#line 253
  alarm(1U);
#line 254
  return;
}
}
#line 256 "progressmeter.c"
void stop_progress_meter(void) 
{ int tmp ;

  {
#line 259
  alarm(0U);
#line 261
  tmp = can_output();
#line 261
  if (! tmp) {
#line 262
    return;
  }
#line 265
  if (cur_pos != end_pos) {
#line 266
    refresh_progress_meter();
  }
#line 268
  atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), 1, (void *)"\n", 1U);
#line 269
  return;
}
}
#line 1 "dns.o"
#line 53 "dns.h"
int verify_host_key_dns(char const   *hostname , struct sockaddr *address , Key const   *hostkey ,
                        int *flags ) ;
#line 54
int export_dns_rr(char const   *hostname , Key const   *key , FILE *f , int generic ) ;
#line 49 "dns.c"
static char const   *errset_text[6]  = {      "success",      "out of memory",      "general failure",      "invalid parameter", 
        "name does not exist",      "data does not exist"};
#line 58 "dns.c"
static char const   *dns_result_totext(unsigned int error___0 ) 
{ 

  {
#line 61
  switch ((int )error___0) {
  case 0: 
#line 63
  return (errset_text[0]);
  case 1: 
#line 65
  return (errset_text[1]);
  case 2: 
#line 67
  return (errset_text[2]);
  case 3: 
#line 69
  return (errset_text[3]);
  case 4: 
#line 71
  return (errset_text[4]);
  case 5: 
#line 73
  return (errset_text[5]);
  default: ;
#line 75
  return ("unknown error");
  }
}
}
#line 84 "dns.c"
static int dns_read_key(u_int8_t *algorithm , u_int8_t *digest_type , u_char **digest___1 ,
                        u_int *digest_len , Key const   *key ) 
{ int success ;

  {
#line 88
  success = 0;
#line 90
  switch ((int )key->type) {
  case 1: 
#line 92
  *algorithm = (unsigned char)1;
#line 93
  break;
  case 2: 
#line 95
  *algorithm = (unsigned char)2;
#line 96
  break;
  default: 
#line 98
  *algorithm = (unsigned char)0;
  }
#line 101
  if (*algorithm) {
#line 102
    *digest_type = (unsigned char)1;
#line 103
    *digest___1 = key_fingerprint_raw(key, 0, digest_len);
#line 104
    success = 1;
  } else {
#line 106
    *digest_type = (unsigned char)0;
#line 107
    *digest___1 = (u_char *)((void *)0);
#line 108
    *digest_len = 0U;
#line 109
    success = 0;
  }
#line 112
  return (success);
}
}
#line 118 "dns.c"
static int dns_read_rdata(u_int8_t *algorithm , u_int8_t *digest_type , u_char **digest___1 ,
                          u_int *digest_len , u_char *rdata , int rdata_len ) 
{ int success ;
  void *tmp ;

  {
#line 122
  success = 0;
#line 124
  *algorithm = (unsigned char)0;
#line 125
  *digest_type = (unsigned char)0;
#line 127
  if (rdata_len >= 2) {
#line 128
    *algorithm = *(rdata + 0);
#line 129
    *digest_type = *(rdata + 1);
#line 130
    *digest_len = (unsigned int )(rdata_len - 2);
#line 132
    if (*digest_len > 0U) {
#line 133
      tmp = xmalloc(*digest_len);
#line 133
      *digest___1 = (u_char *)tmp;
#line 134
      memcpy((void * __restrict  )*digest___1, (void const   * __restrict  )(rdata + 2),
             *digest_len);
    } else {
#line 136
      *digest___1 = (u_char *)((void *)0);
    }
#line 139
    success = 1;
  }
#line 142
  return (success);
}
}
#line 150 "dns.c"
int verify_host_key_dns(char const   *hostname , struct sockaddr *address , Key const   *hostkey ,
                        int *flags ) 
{ int counter___0 ;
  int result ;
  struct rrsetinfo *fingerprints ;
  u_int8_t hostkey_algorithm ;
  u_int8_t hostkey_digest_type ;
  u_char *hostkey_digest ;
  u_int hostkey_digest_len ;
  u_int8_t dnskey_algorithm ;
  u_int8_t dnskey_digest_type ;
  u_char *dnskey_digest ;
  u_int dnskey_digest_len ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 156
  fingerprints = (struct rrsetinfo *)((void *)0);
#line 168
  *flags = 0;
#line 170
  debug3("verify_hostkey_dns");
#line 171
  if ((unsigned int )hostkey == (unsigned int )((void *)0)) {
#line 172
    fatal("No key to look up!");
  }
#line 174
  result = getrrsetbyname(hostname, 1U, 44U, 0U, & fingerprints);
#line 176
  if (result) {
#line 177
    tmp = dns_result_totext((unsigned int )result);
#line 177
    verbose("DNS lookup error: %s", tmp);
#line 178
    return (-1);
  }
#line 181
  if (fingerprints->rri_flags & 1U) {
#line 182
    *flags |= 4;
#line 183
    debug("found %d secure fingerprints in DNS", fingerprints->rri_nrdatas);
  } else {
#line 186
    debug("found %d insecure fingerprints in DNS", fingerprints->rri_nrdatas);
  }
#line 191
  tmp___0 = dns_read_key(& hostkey_algorithm, & hostkey_digest_type, & hostkey_digest,
                         & hostkey_digest_len, hostkey);
#line 191
  if (! tmp___0) {
#line 193
    error("Error calculating host key fingerprint.");
#line 194
    freerrset(fingerprints);
#line 195
    return (-1);
  }
#line 198
  if (fingerprints->rri_nrdatas) {
#line 199
    *flags |= 1;
  }
#line 201
  counter___0 = 0;
#line 201
  while ((unsigned int )counter___0 < fingerprints->rri_nrdatas) {
#line 206
    tmp___1 = dns_read_rdata(& dnskey_algorithm, & dnskey_digest_type, & dnskey_digest,
                             & dnskey_digest_len, (fingerprints->rri_rdatas + counter___0)->rdi_data,
                             (int )(fingerprints->rri_rdatas + counter___0)->rdi_length);
#line 206
    if (! tmp___1) {
#line 210
      verbose("Error parsing fingerprint from DNS.");
      goto __Cont;
    }
#line 215
    if ((int )hostkey_algorithm == (int )dnskey_algorithm) {
#line 215
      if ((int )hostkey_digest_type == (int )dnskey_digest_type) {
#line 218
        if (hostkey_digest_len == dnskey_digest_len) {
#line 218
          tmp___2 = memcmp((void const   *)hostkey_digest, (void const   *)dnskey_digest,
                           hostkey_digest_len);
#line 218
          if (tmp___2 == 0) {
#line 222
            *flags |= 2;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 201
    counter___0 ++;
  }
#line 227
  freerrset(fingerprints);
#line 229
  if (*flags & 1) {
#line 230
    if (*flags & 2) {
#line 231
      debug("matching host key fingerprint found in DNS");
    } else {
#line 233
      debug("mismatching host key fingerprint found in DNS");
    }
  } else {
#line 235
    debug("no host key fingerprint found in DNS");
  }
#line 237
  return (0);
}
}
#line 244 "dns.c"
int export_dns_rr(char const   *hostname , Key const   *key , FILE *f , int generic ) 
{ u_int8_t rdata_pubkey_algorithm ;
  u_int8_t rdata_digest_type ;
  u_char *rdata_digest ;
  u_int rdata_digest_len ;
  int i ;
  int success ;
  int tmp ;

  {
#line 247
  rdata_pubkey_algorithm = (u_int8_t )0;
#line 248
  rdata_digest_type = (u_int8_t )1;
#line 253
  success = 0;
#line 255
  tmp = dns_read_key(& rdata_pubkey_algorithm, & rdata_digest_type, & rdata_digest,
                     & rdata_digest_len, key);
#line 255
  if (tmp) {
#line 258
    if (generic) {
#line 259
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s IN TYPE%d \\# %d %02x %02x ",
              hostname, 44, 2U + rdata_digest_len, rdata_pubkey_algorithm, rdata_digest_type);
    } else {
#line 263
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s IN SSHFP %d %d ",
              hostname, rdata_pubkey_algorithm, rdata_digest_type);
    }
#line 266
    i = 0;
#line 266
    while ((u_int )i < rdata_digest_len) {
#line 267
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%02x", *(rdata_digest + i));
#line 266
      i ++;
    }
#line 268
    fprintf((FILE * __restrict  )f, (char const   * __restrict  )"\n");
#line 269
    success = 1;
  } else {
#line 271
    error("dns_export_rr: unsupported algorithm");
  }
#line 274
  return (success);
}
}
#line 1 "entropy.o"
#line 31 "entropy.h"
void init_rng(void) ;
#line 109 "/usr/include/openssl/rand.h"
extern int RAND_status(void) ;
#line 381 "/usr/include/openssl/crypto.h"
extern unsigned long SSLeay(void) ;
#line 55 "entropy.c"
void seed_rng(void) 
{ int tmp ;

  {
#line 132
  tmp = RAND_status();
#line 132
  if (tmp != 1) {
#line 133
    fatal("PRNG is not seeded");
  }
#line 134
  return;
}
}
#line 136 "entropy.c"
void init_rng(void) 
{ unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 143
  tmp___0 = SSLeay();
#line 143
  if ((tmp___0 ^ 9469999UL) & 4294963215UL) {
#line 144
    tmp = SSLeay();
#line 144
    fatal("OpenSSL version mismatch. Built against %lx, you have %lx", 9469999L, tmp);
  }
#line 153
  return;
}
}
#line 1 "scard-opensc.o"
#line 1 "gss-genr.o"
#line 1 "sshd.o"
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 79 "/usr/include/pwd.h"
extern void endpwent(void) ;
#line 178 "/usr/include/grp.h"
extern  __attribute__((__nothrow__)) int setgroups(size_t __n , __gid_t const   *__groups ) ;
#line 457 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int chdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 490
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 516
extern  __attribute__((__nothrow__)) int execv(char const   *__path , char * const  *__argv )  __attribute__((__nonnull__(1))) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 903
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
#line 910
extern  __attribute__((__nothrow__)) int chroot(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 380 "/usr/include/openssl/crypto.h"
extern char const   *SSLeay_version(int type ) ;
#line 478 "/usr/include/openssl/bn.h"
extern int BN_mask_bits(BIGNUM *a , int n ) ;
#line 104 "/usr/include/openssl/rand.h"
extern void RAND_seed(void const   *buf , int num ) ;
#line 130 "servconf.h"
void initialize_server_options(ServerOptions *options___0 ) ;
#line 131
void read_server_config(ServerOptions *options___0 , char const   *filename ) ;
#line 132
void fill_default_server_options(ServerOptions *options___0 ) ;
#line 133
int process_server_config_line(ServerOptions *options___0 , char *line , char const   *filename ,
                               int linenum ) ;
#line 20 "uidswap.h"
void permanently_set_uid(struct passwd *pw ) ;
#line 711 "/usr/include/openssl/evp.h"
extern void OPENSSL_add_all_algorithms_noconf(void) ;
#line 129 "kex.h"
void kexdh_server(Kex *kex ) ;
#line 131
void kexgex_server(Kex *kex ) ;
#line 40 "myproposal.h"
static char *myproposal[10]  = 
#line 40 "myproposal.h"
  {      (char *)"diffie-hellman-group-exchange-sha1,diffie-hellman-group1-sha1",      (char *)"ssh-rsa,ssh-dss",      (char *)"aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,arcfour,aes192-cbc,aes256-cbc,rijndael-cbc@lysator.liu.se,aes128-ctr,aes192-ctr,aes256-ctr",      (char *)"aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,arcfour,aes192-cbc,aes256-cbc,rijndael-cbc@lysator.liu.se,aes128-ctr,aes192-ctr,aes256-ctr", 
        (char *)"hmac-md5,hmac-sha1,hmac-ripemd160,hmac-ripemd160@openssh.com,hmac-sha1-96,hmac-md5-96",      (char *)"hmac-md5,hmac-sha1,hmac-ripemd160,hmac-ripemd160@openssh.com,hmac-sha1-96,hmac-md5-96",      (char *)"none,zlib",      (char *)"none,zlib", 
        (char *)"",      (char *)""};
#line 135 "auth.h"
void do_authentication(Authctxt *authctxt___0 ) ;
#line 136
void do_authentication2(Authctxt *authctxt___0 ) ;
#line 144
void privsep_challenge_enable(void) ;
#line 172
Key *get_hostkey_by_index(int ind ) ;
#line 173
Key *get_hostkey_by_type(int type ) ;
#line 174
int get_hostkey_index(Key *key ) ;
#line 175
int ssh1_session_key(BIGNUM *session_key_int ) ;
#line 58 "session.h"
void do_authenticated(Authctxt *authctxt___0 ) ;
#line 59
void do_cleanup(Authctxt *authctxt___0 ) ;
#line 71
void do_setusercontext(struct passwd *pw ) ;
#line 75 "monitor.h"
struct monitor *monitor_init(void) ;
#line 76
void monitor_reinit(struct monitor *mon ) ;
#line 77
void monitor_sync(struct monitor *pmonitor___0 ) ;
#line 80
void monitor_child_preauth(struct Authctxt *_authctxt , struct monitor *pmonitor___0 ) ;
#line 81
void monitor_child_postauth(struct monitor *pmonitor___0 ) ;
#line 33 "monitor_wrap.h"
int use_privsep  ;
#line 78
void mm_terminate(void) ;
#line 83
void mm_ssh1_session_id(u_char *session_id___0 ) ;
#line 84
int mm_ssh1_session_key(BIGNUM *num ) ;
#line 90
void monitor_apply_keystate(struct monitor *pmonitor___0 ) ;
#line 92
void mm_send_keystate(struct monitor *pmonitor___0 ) ;
#line 106 "sshd.c"
ServerOptions options  ;
#line 109 "sshd.c"
char *config_file_name  =    (char *)"/usr/local/etc/sshd_config";
#line 115 "sshd.c"
int IPv4or6  =    0;
#line 123 "sshd.c"
int debug_flag  =    0;
#line 126 "sshd.c"
int test_flag  =    0;
#line 129 "sshd.c"
int inetd_flag  =    0;
#line 132 "sshd.c"
int no_daemon_flag  =    0;
#line 135 "sshd.c"
int log_stderr  =    0;
#line 138 "sshd.c"
char **saved_argv  ;
#line 139 "sshd.c"
int saved_argc  ;
#line 146 "sshd.c"
int listen_socks[16]  ;
#line 147 "sshd.c"
int num_listen_socks  =    0;
#line 153 "sshd.c"
char *client_version_string  =    (char *)((void *)0);
#line 154 "sshd.c"
char *server_version_string  =    (char *)((void *)0);
#line 157 "sshd.c"
Kex *xxx_kex  ;
#line 167 "sshd.c"
struct __anonstruct_sensitive_data_81 sensitive_data  ;
#line 180 "sshd.c"
static int volatile   key_do_regen  =    (sig_atomic_t volatile   )0;
#line 183 "sshd.c"
static int volatile   received_sighup  =    (sig_atomic_t volatile   )0;
#line 184 "sshd.c"
static int volatile   received_sigterm  =    (sig_atomic_t volatile   )0;
#line 187 "sshd.c"
u_char session_id[16]  ;
#line 190 "sshd.c"
u_char *session_id2  =    (u_char *)((void *)0);
#line 191 "sshd.c"
u_int session_id2_len  =    (u_int )0;
#line 194 "sshd.c"
u_int utmp_len  =    (u_int )64;
#line 197 "sshd.c"
int *startup_pipes  =    (int *)((void *)0);
#line 198 "sshd.c"
int startup_pipe  ;
#line 202 "sshd.c"
struct monitor *pmonitor  =    (struct monitor *)((void *)0);
#line 205 "sshd.c"
Buffer loginmsg  ;
#line 208 "sshd.c"
Authctxt *the_authctxt  =    (Authctxt *)((void *)0);
#line 211
void destroy_sensitive_data(void) ;
#line 212
void demote_sensitive_data(void) ;
#line 214
static void do_ssh1_kex(void) ;
#line 215
static void do_ssh2_kex(void) ;
#line 220 "sshd.c"
static void close_listen_socks(void) 
{ int i ;

  {
#line 225
  i = 0;
#line 225
  while (i < num_listen_socks) {
#line 226
    close(listen_socks[i]);
#line 225
    i ++;
  }
#line 227
  num_listen_socks = -1;
#line 228
  return;
}
}
#line 230 "sshd.c"
static void close_startup_pipes(void) 
{ int i ;

  {
#line 235
  if (startup_pipes) {
#line 236
    i = 0;
#line 236
    while (i < options.max_startups) {
#line 237
      if (*(startup_pipes + i) != -1) {
#line 238
        close(*(startup_pipes + i));
      }
#line 236
      i ++;
    }
  }
#line 239
  return;
}
}
#line 246 "sshd.c"
static void sighup_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 249
  tmp = __errno_location();
#line 249
  save_errno = *tmp;
#line 251
  received_sighup = (int volatile   )1;
#line 252
  mysignal(1, & sighup_handler);
#line 253
  tmp___0 = __errno_location();
#line 253
  *tmp___0 = save_errno;
#line 254
  return;
}
}
#line 260 "sshd.c"
static void sighup_restart(void) 
{ int *tmp ;
  char *tmp___0 ;

  {
#line 263
  logit("Received SIGHUP; restarting.");
#line 264
  close_listen_socks();
#line 265
  close_startup_pipes();
#line 266
  execv((char const   *)*(saved_argv + 0), (char * const  *)saved_argv);
#line 267
  tmp = __errno_location();
#line 267
  tmp___0 = strerror(*tmp);
#line 267
  logit("RESTART FAILED: av[0]=\'%.100s\', error: %.100s.", *(saved_argv + 0), tmp___0);
#line 269
  exit(1);
}
}
#line 275 "sshd.c"
static void sigterm_handler(int sig ) 
{ 

  {
#line 278
  received_sigterm = (int volatile   )sig;
#line 279
  return;
}
}
#line 285 "sshd.c"
static void main_sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  pid_t pid ;
  int status ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 288
  tmp = __errno_location();
#line 288
  save_errno = *tmp;
#line 292
  while (1) {
#line 292
    pid = waitpid(-1, & status, 1);
#line 292
    if (! (pid > 0)) {
#line 292
      if (pid < 0) {
#line 292
        tmp___0 = __errno_location();
#line 292
        if (! (*tmp___0 == 4)) {
#line 292
          break;
        }
      } else {
#line 292
        break;
      }
    }
  }
#line 296
  mysignal(17, & main_sigchld_handler);
#line 297
  tmp___1 = __errno_location();
#line 297
  *tmp___1 = save_errno;
#line 298
  return;
}
}
#line 303 "sshd.c"
static void grace_alarm_handler(int sig ) 
{ char const   *tmp ;

  {
#line 308
  if (use_privsep) {
#line 308
    if ((unsigned int )pmonitor != (unsigned int )((void *)0)) {
#line 308
      if (pmonitor->m_pid > 0) {
#line 309
        kill(pmonitor->m_pid, 14);
      }
    }
  }
#line 312
  tmp = get_remote_ipaddr();
#line 312
  fatal("Timeout before authentication for %s", tmp);
#line 313
  return;
}
}
#line 322 "sshd.c"
static void generate_ephemeral_server_key(void) 
{ u_int32_t rnd ;
  int i ;
  char const   *tmp ;

  {
#line 325
  rnd = (u_int32_t )0;
#line 328
  if (sensitive_data.server_key) {
#line 328
    tmp = "new ";
  } else {
#line 328
    tmp = "";
  }
#line 328
  verbose("Generating %s%d bit RSA key.", tmp, options.server_key_bits);
#line 330
  if ((unsigned int )sensitive_data.server_key != (unsigned int )((void *)0)) {
#line 331
    key_free(sensitive_data.server_key);
  }
#line 332
  sensitive_data.server_key = key_generate(0, (unsigned int )options.server_key_bits);
#line 334
  verbose("RSA key generation complete.");
#line 336
  i = 0;
#line 336
  while (i < 32) {
#line 337
    if (i % 4 == 0) {
#line 338
      rnd = arc4random();
    }
#line 339
    sensitive_data.ssh1_cookie[i] = (unsigned char )(rnd & 255U);
#line 340
    rnd >>= 8;
#line 336
    i ++;
  }
#line 342
  arc4random_stir();
#line 343
  return;
}
}
#line 345 "sshd.c"
static void key_regeneration_alarm(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 348
  tmp = __errno_location();
#line 348
  save_errno = *tmp;
#line 350
  mysignal(14, (void (*)(int  ))0);
#line 351
  tmp___0 = __errno_location();
#line 351
  *tmp___0 = save_errno;
#line 352
  key_do_regen = (int volatile   )1;
#line 353
  return;
}
}
#line 355 "sshd.c"
static void sshd_exchange_identification(int sock_in , int sock_out ) 
{ int i ;
  int mismatch ;
  int remote_major ;
  int remote_minor ;
  int major ;
  int minor ;
  char *s ;
  char buf___1[256] ;
  char remote_version[256] ;
  char const   *tmp ;
  size_t tmp___0 ;
  ssize_t tmp___1 ;
  size_t tmp___2 ;
  char const   *tmp___3 ;
  ssize_t tmp___4 ;
  int tmp___18 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t tmp___31 ;
  char const   *tmp___32 ;
  int tmp___33 ;
  char const   *tmp___34 ;
  char const   *tmp___35 ;
  size_t tmp___36 ;
  char const   *tmp___37 ;

  {
#line 365
  if (options.protocol & 1) {
#line 365
    if (options.protocol & 4) {
#line 367
      major = 1;
#line 368
      minor = 99;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 369
    if (options.protocol & 4) {
#line 370
      major = 2;
#line 371
      minor = 0;
    } else {
#line 373
      major = 1;
#line 374
      minor = 5;
    }
  }
#line 376
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"SSH-%d.%d-%.100s\n",
           major, minor, "OpenSSH_3.8.1p1");
#line 377
  server_version_string = xstrdup((char const   *)(buf___1));
#line 380
  tmp___0 = strlen((char const   *)server_version_string);
#line 380
  tmp___1 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), sock_out, (void *)server_version_string,
                     tmp___0);
#line 380
  tmp___2 = strlen((char const   *)server_version_string);
#line 380
  if ((size_t )tmp___1 != tmp___2) {
#line 383
    tmp = get_remote_ipaddr();
#line 383
    logit("Could not write ident string to %s", tmp);
#line 384
    cleanup_exit(255);
  }
#line 388
  memset((void *)(buf___1), 0, sizeof(buf___1));
#line 389
  i = 0;
#line 389
  while ((unsigned int )i < sizeof(buf___1) - 1U) {
#line 390
    tmp___4 = atomicio(& read, sock_in, (void *)(& buf___1[i]), 1U);
#line 390
    if (tmp___4 != 1) {
#line 391
      tmp___3 = get_remote_ipaddr();
#line 391
      logit("Did not receive identification string from %s", tmp___3);
#line 393
      cleanup_exit(255);
    }
#line 395
    if ((int )buf___1[i] == 13) {
#line 396
      buf___1[i] = (char)0;
#line 399
      if (i == 12) {
#line 399
        if (0) {
#line 399
          if (0) {
#line 399
            __s1_len___0 = strlen((char const   *)(buf___1));
#line 399
            __s2_len___0 = strlen("SSH-1.5-W1.0");
#line 399
            if (! ((unsigned int )((void const   *)(buf___1 + 1)) - (unsigned int )((void const   *)(buf___1)) == 1U)) {
              goto _L___3;
            } else {
#line 399
              if (__s1_len___0 >= 4U) {
                _L___3: /* CIL Label */ 
#line 399
                if (! ((unsigned int )((void const   *)("SSH-1.5-W1.0" + 1)) - (unsigned int )((void const   *)"SSH-1.5-W1.0") == 1U)) {
#line 399
                  tmp___28 = 1;
                } else {
#line 399
                  if (__s2_len___0 >= 4U) {
#line 399
                    tmp___28 = 1;
                  } else {
#line 399
                    tmp___28 = 0;
                  }
                }
              } else {
#line 399
                tmp___28 = 0;
              }
            }
#line 399
            if (tmp___28) {
#line 399
              tmp___24 = __builtin_strcmp((char const   *)(buf___1), "SSH-1.5-W1.0");
            } else {
#line 399
              tmp___27 = __builtin_strcmp((char const   *)(buf___1), "SSH-1.5-W1.0");
#line 399
              tmp___24 = tmp___27;
            }
          } else {
#line 399
            tmp___27 = __builtin_strcmp((char const   *)(buf___1), "SSH-1.5-W1.0");
#line 399
            tmp___24 = tmp___27;
          }
#line 399
          tmp___18 = tmp___24;
        } else {
#line 399
          tmp___18 = strncmp((char const   *)(buf___1), "SSH-1.5-W1.0", 12U);
        }
#line 399
        if (tmp___18 == 0) {
#line 400
          break;
        }
      }
      goto __Cont;
    }
#line 403
    if ((int )buf___1[i] == 10) {
#line 404
      buf___1[i] = (char)0;
#line 405
      break;
    }
    __Cont: /* CIL Label */ 
#line 389
    i ++;
  }
#line 408
  buf___1[sizeof(buf___1) - 1U] = (char)0;
#line 409
  client_version_string = xstrdup((char const   *)(buf___1));
#line 415
  tmp___33 = sscanf((char const   * __restrict  )client_version_string, (char const   * __restrict  )"SSH-%d.%d-%[^\n]\n",
                    & remote_major, & remote_minor, remote_version);
#line 415
  if (tmp___33 != 3) {
#line 417
    s = (char *)"Protocol mismatch.\n";
#line 418
    tmp___31 = strlen((char const   *)s);
#line 418
    atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), sock_out, (void *)s,
             tmp___31);
#line 419
    close(sock_in);
#line 420
    close(sock_out);
#line 421
    tmp___32 = get_remote_ipaddr();
#line 421
    logit("Bad protocol version identification \'%.100s\' from %s", client_version_string,
          tmp___32);
#line 423
    cleanup_exit(255);
  }
#line 425
  debug("Client protocol version %d.%d; client software version %.100s", remote_major,
        remote_minor, remote_version);
#line 428
  compat_datafellows((char const   *)(remote_version));
#line 430
  if (datafellows & 4194304) {
#line 431
    tmp___34 = get_remote_ipaddr();
#line 431
    logit("probed from %s with %s.  Don\'t panic.", tmp___34, client_version_string);
#line 433
    cleanup_exit(255);
  }
#line 436
  if (datafellows & 2048) {
#line 437
    tmp___35 = get_remote_ipaddr();
#line 437
    logit("scanned from %s with %s.  Don\'t panic.", tmp___35, client_version_string);
#line 439
    cleanup_exit(255);
  }
#line 442
  mismatch = 0;
#line 443
  switch (remote_major) {
  case 1: 
#line 445
  if (remote_minor == 99) {
#line 446
    if (options.protocol & 4) {
#line 447
      enable_compat20();
    } else {
#line 449
      mismatch = 1;
    }
#line 450
    break;
  }
#line 452
  if (! (options.protocol & 1)) {
#line 453
    mismatch = 1;
#line 454
    break;
  }
#line 456
  if (remote_minor < 3) {
#line 457
    packet_disconnect("Your ssh version is too old and is no longer supported.  Please install a newer version.");
  } else {
#line 459
    if (remote_minor == 3) {
#line 461
      enable_compat13();
    }
  }
#line 463
  break;
  case 2: 
#line 465
  if (options.protocol & 4) {
#line 466
    enable_compat20();
#line 467
    break;
  }
  default: 
#line 471
  mismatch = 1;
#line 472
  break;
  }
#line 474
  chop(server_version_string);
#line 475
  debug("Local version string %.200s", server_version_string);
#line 477
  if (mismatch) {
#line 478
    s = (char *)"Protocol major versions differ.\n";
#line 479
    tmp___36 = strlen((char const   *)s);
#line 479
    atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), sock_out, (void *)s,
             tmp___36);
#line 480
    close(sock_in);
#line 481
    close(sock_out);
#line 482
    tmp___37 = get_remote_ipaddr();
#line 482
    logit("Protocol major versions differ for %s: %.200s vs. %.200s", tmp___37, server_version_string,
          client_version_string);
#line 485
    cleanup_exit(255);
  }
#line 487
  return;
}
}
#line 490 "sshd.c"
void destroy_sensitive_data(void) 
{ int i ;

  {
#line 495
  if (sensitive_data.server_key) {
#line 496
    key_free(sensitive_data.server_key);
#line 497
    sensitive_data.server_key = (Key *)((void *)0);
  }
#line 499
  i = 0;
#line 499
  while (i < options.num_host_key_files) {
#line 500
    if (*(sensitive_data.host_keys + i)) {
#line 501
      key_free(*(sensitive_data.host_keys + i));
#line 502
      *(sensitive_data.host_keys + i) = (Key *)((void *)0);
    }
#line 499
    i ++;
  }
#line 505
  sensitive_data.ssh1_host_key = (Key *)((void *)0);
#line 506
  memset((void *)(sensitive_data.ssh1_cookie), 0, 32U);
#line 507
  return;
}
}
#line 510 "sshd.c"
void demote_sensitive_data(void) 
{ Key *tmp ;
  int i ;

  {
#line 516
  if (sensitive_data.server_key) {
#line 517
    tmp = key_demote((Key const   *)sensitive_data.server_key);
#line 518
    key_free(sensitive_data.server_key);
#line 519
    sensitive_data.server_key = tmp;
  }
#line 522
  i = 0;
#line 522
  while (i < options.num_host_key_files) {
#line 523
    if (*(sensitive_data.host_keys + i)) {
#line 524
      tmp = key_demote((Key const   *)*(sensitive_data.host_keys + i));
#line 525
      key_free(*(sensitive_data.host_keys + i));
#line 526
      *(sensitive_data.host_keys + i) = tmp;
#line 527
      if (tmp->type == 0) {
#line 528
        sensitive_data.ssh1_host_key = tmp;
      }
    }
#line 522
    i ++;
  }
#line 533
  return;
}
}
#line 535 "sshd.c"
static void privsep_preauth_child(void) 
{ u_int32_t rnd[256] ;
  gid_t gidset[1] ;
  struct passwd *pw ;
  int i ;
  size_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
#line 544
  privsep_challenge_enable();
#line 546
  i = 0;
#line 546
  while (i < 256) {
#line 547
    rnd[i] = arc4random();
#line 546
    i ++;
  }
#line 548
  RAND_seed((void const   *)(rnd), (int )sizeof(rnd));
#line 551
  demote_sensitive_data();
#line 553
  pw = getpwnam("sshd");
#line 553
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 554
    fatal("Privilege separation user %s does not exist", "sshd");
  }
#line 556
  tmp = strlen((char const   *)pw->pw_passwd);
#line 556
  memset((void *)pw->pw_passwd, 0, tmp);
#line 557
  endpwent();
#line 560
  tmp___2 = chroot("/var/empty");
#line 560
  if (tmp___2 == -1) {
#line 561
    tmp___0 = __errno_location();
#line 561
    tmp___1 = strerror(*tmp___0);
#line 561
    fatal("chroot(\"%s\"): %s", "/var/empty", tmp___1);
  }
#line 563
  tmp___5 = chdir("/");
#line 563
  if (tmp___5 == -1) {
#line 564
    tmp___3 = __errno_location();
#line 564
    tmp___4 = strerror(*tmp___3);
#line 564
    fatal("chdir(\"/\"): %s", tmp___4);
  }
#line 567
  debug3("privsep user:group %u:%u", pw->pw_uid, pw->pw_gid);
#line 573
  gidset[0] = pw->pw_gid;
#line 574
  tmp___8 = setgroups(1U, (__gid_t const   *)(gidset));
#line 574
  if (tmp___8 < 0) {
#line 575
    tmp___6 = __errno_location();
#line 575
    tmp___7 = strerror(*tmp___6);
#line 575
    fatal("setgroups: %.100s", tmp___7);
  }
#line 576
  permanently_set_uid(pw);
#line 578
  return;
}
}
#line 580 "sshd.c"
static int privsep_preauth(Authctxt *authctxt___0 ) 
{ int status ;
  pid_t pid ;
  int *tmp ;
  __pid_t tmp___0 ;
  __uid_t tmp___1 ;
  __uid_t tmp___2 ;

  {
#line 587
  pmonitor = monitor_init();
#line 589
  pmonitor->m_pkex = & xxx_kex;
#line 591
  pid = fork();
#line 592
  if (pid == -1) {
#line 593
    fatal("fork of unprivileged child failed");
  } else {
#line 594
    if (pid != 0) {
#line 595
      debug2("Network child is on pid %ld", (long )pid);
#line 597
      close(pmonitor->m_recvfd);
#line 598
      pmonitor->m_pid = pid;
#line 599
      monitor_child_preauth(authctxt___0, pmonitor);
#line 600
      close(pmonitor->m_sendfd);
#line 603
      monitor_sync(pmonitor);
#line 606
      while (1) {
#line 606
        tmp___0 = waitpid(pid, & status, 0);
#line 606
        if (! (tmp___0 < 0)) {
#line 606
          break;
        }
#line 607
        tmp = __errno_location();
#line 607
        if (*tmp != 4) {
#line 608
          break;
        }
      }
#line 609
      return (1);
    } else {
#line 613
      close(pmonitor->m_sendfd);
#line 616
      tmp___1 = getuid();
#line 616
      if (tmp___1 == 0U) {
#line 617
        privsep_preauth_child();
      } else {
#line 616
        tmp___2 = geteuid();
#line 616
        if (tmp___2 == 0U) {
#line 617
          privsep_preauth_child();
        }
      }
#line 618
      setproctitle("%s", "[net]");
    }
  }
#line 620
  return (0);
}
}
#line 623 "sshd.c"
static void privsep_postauth(Authctxt *authctxt___0 ) 
{ 

  {
#line 629
  if ((authctxt___0->pw)->pw_uid == 0U) {
#line 632
    monitor_apply_keystate(pmonitor);
#line 633
    use_privsep = 0;
#line 634
    return;
  } else {
#line 629
    if (options.use_login) {
#line 632
      monitor_apply_keystate(pmonitor);
#line 633
      use_privsep = 0;
#line 634
      return;
    }
  }
#line 638
  alarm(0U);
#line 639
  if (startup_pipe != -1) {
#line 640
    close(startup_pipe);
#line 641
    startup_pipe = -1;
  }
#line 645
  monitor_reinit(pmonitor);
#line 647
  pmonitor->m_pid = fork();
#line 648
  if (pmonitor->m_pid == -1) {
#line 649
    fatal("fork of unprivileged child failed");
  } else {
#line 650
    if (pmonitor->m_pid != 0) {
#line 651
      debug2("User child is on pid %ld", (long )pmonitor->m_pid);
#line 652
      close(pmonitor->m_recvfd);
#line 653
      monitor_child_postauth(pmonitor);
#line 656
      exit(0);
    }
  }
#line 659
  close(pmonitor->m_sendfd);
#line 662
  demote_sensitive_data();
#line 665
  do_setusercontext(authctxt___0->pw);
#line 668
  monitor_apply_keystate(pmonitor);
#line 669
  return;
}
}
#line 671 "sshd.c"
static char *list_hostkey_types(void) 
{ Buffer b ;
  char const   *p ;
  char *ret ;
  int i ;
  Key *key ;
  u_int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 679
  buffer_init(& b);
#line 680
  i = 0;
#line 680
  while (i < options.num_host_key_files) {
#line 681
    key = *(sensitive_data.host_keys + i);
#line 682
    if ((unsigned int )key == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 684
    switch (key->type) {
    case 1: 
    case 2: 
#line 687
    tmp = buffer_len(& b);
#line 687
    if (tmp > 0U) {
#line 688
      buffer_append(& b, (void const   *)",", 1U);
    }
#line 689
    p = key_ssh_name((Key const   *)key);
#line 690
    tmp___0 = strlen(p);
#line 690
    buffer_append(& b, (void const   *)p, tmp___0);
#line 691
    break;
    }
    __Cont: /* CIL Label */ 
#line 680
    i ++;
  }
#line 694
  buffer_append(& b, (void const   *)"\000", 1U);
#line 695
  tmp___1 = buffer_ptr(& b);
#line 695
  ret = xstrdup((char const   *)tmp___1);
#line 696
  buffer_free(& b);
#line 697
  debug("list_hostkey_types: %s", ret);
#line 698
  return (ret);
}
}
#line 701 "sshd.c"
Key *get_hostkey_by_type(int type ) 
{ int i ;
  Key *key ;

  {
#line 706
  i = 0;
#line 706
  while (i < options.num_host_key_files) {
#line 707
    key = *(sensitive_data.host_keys + i);
#line 708
    if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 708
      if (key->type == type) {
#line 709
        return (key);
      }
    }
#line 706
    i ++;
  }
#line 711
  return ((Key *)((void *)0));
}
}
#line 714 "sshd.c"
Key *get_hostkey_by_index(int ind ) 
{ 

  {
#line 717
  if (ind < 0) {
#line 718
    return ((Key *)((void *)0));
  } else {
#line 717
    if (ind >= options.num_host_key_files) {
#line 718
      return ((Key *)((void *)0));
    }
  }
#line 719
  return (*(sensitive_data.host_keys + ind));
}
}
#line 722 "sshd.c"
int get_hostkey_index(Key *key ) 
{ int i ;

  {
#line 727
  i = 0;
#line 727
  while (i < options.num_host_key_files) {
#line 728
    if ((unsigned int )key == (unsigned int )*(sensitive_data.host_keys + i)) {
#line 729
      return (i);
    }
#line 727
    i ++;
  }
#line 731
  return (-1);
}
}
#line 740 "sshd.c"
static int drop_connection(int startups ) 
{ double p ;
  double r ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 745
  if (startups < options.max_startups_begin) {
#line 746
    return (0);
  }
#line 747
  if (startups >= options.max_startups) {
#line 748
    return (1);
  }
#line 749
  if (options.max_startups_rate == 100) {
#line 750
    return (1);
  }
#line 752
  p = (double )(100 - options.max_startups_rate);
#line 753
  p *= (double )(startups - options.max_startups_begin);
#line 754
  p /= (double )(options.max_startups - options.max_startups_begin);
#line 755
  p += (double )options.max_startups_rate;
#line 756
  p /= 100.0;
#line 757
  tmp = arc4random();
#line 757
  r = (double )tmp / (double )4294967295U;
#line 759
  debug("drop_connection: p %g, r %g", p, r);
#line 760
  if (r < p) {
#line 760
    tmp___0 = 1;
  } else {
#line 760
    tmp___0 = 0;
  }
#line 760
  return (tmp___0);
}
}
#line 763 "sshd.c"
static void usage(void) 
{ char const   *tmp ;

  {
#line 766
  tmp = SSLeay_version(0);
#line 766
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s, %s\n", "OpenSSH_3.8.1p1",
          tmp);
#line 768
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"usage: sshd [-46Ddeiqt] [-b bits] [-f config_file] [-g login_grace_time]\n            [-h host_key_file] [-k key_gen_time] [-o option] [-p port] [-u len]\n");
#line 772
  exit(1);
}
}
#line 778 "sshd.c"
int main(int ac , char **av ) 
{ int opt ;
  int sock_in ;
  int sock_out ;
  int newsock ;
  int j ;
  int i ;
  int fdsetsz ;
  int on ;
  pid_t pid ;
  socklen_t fromlen ;
  fd_set *fdset ;
  struct sockaddr_storage from ;
  char const   *remote_ip ;
  int remote_port ;
  FILE *f ;
  struct addrinfo *ai ;
  char ntop[1025] ;
  char strport[32] ;
  char *line ;
  int listen_sock ;
  int maxfd ;
  int startup_p[2] ;
  int startups ;
  Key *key ;
  Authctxt *authctxt___0 ;
  int ret ;
  int key_used ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  __uid_t tmp___2 ;
  int tmp___3 ;
  u_int tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  void *tmp___14 ;
  char const   *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  struct passwd *pw ;
  struct stat st ;
  int tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  int fd ;
  int *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  int s1 ;
  int tmp___26 ;
  int *tmp___27 ;
  char *tmp___28 ;
  int *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  int *tmp___32 ;
  char *tmp___33 ;
  int tmp___34 ;
  int *tmp___35 ;
  char *tmp___36 ;
  int tmp___37 ;
  int *tmp___38 ;
  char *tmp___39 ;
  int tmp___40 ;
  int *tmp___41 ;
  char *tmp___42 ;
  __pid_t tmp___43 ;
  void *tmp___44 ;
  void *tmp___45 ;
  int *tmp___46 ;
  char *tmp___47 ;
  int *tmp___48 ;
  register char __result ;
  register char __result___0 ;
  int *tmp___49 ;
  char *tmp___50 ;
  int *tmp___51 ;
  int *tmp___52 ;
  int *tmp___53 ;
  char *tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int *tmp___58 ;
  char *tmp___59 ;
  int *tmp___60 ;
  char *tmp___61 ;
  __pid_t tmp___62 ;
  int *tmp___63 ;
  char *tmp___64 ;
  int tmp___65 ;
  void *tmp___66 ;
  int tmp___67 ;

  {
#line 783
  sock_in = 0;
#line 783
  sock_out = 0;
#line 783
  on = 1;
#line 796
  startups = 0;
#line 799
  key_used = 0;
#line 804
  __progname = ssh_get_progname(*(av + 0));
#line 805
  init_rng();
#line 808
  saved_argc = ac;
#line 809
  tmp = xmalloc(sizeof(*saved_argv) * (unsigned int )(ac + 1));
#line 809
  saved_argv = (char **)tmp;
#line 810
  i = 0;
#line 810
  while (i < ac) {
#line 811
    *(saved_argv + i) = xstrdup((char const   *)*(av + i));
#line 810
    i ++;
  }
#line 812
  *(saved_argv + i) = (char *)((void *)0);
#line 816
  compat_init_setproctitle(ac, av);
#line 817
  av = saved_argv;
#line 820
  tmp___2 = geteuid();
#line 820
  if (tmp___2 == 0U) {
#line 820
    tmp___3 = setgroups(0U, (__gid_t const   *)((void *)0));
#line 820
    if (tmp___3 == -1) {
#line 821
      tmp___0 = __errno_location();
#line 821
      tmp___1 = strerror(*tmp___0);
#line 821
      debug("setgroups(): %.200s", tmp___1);
    }
  }
#line 824
  initialize_server_options(& options);
#line 827
  while (1) {
#line 827
    opt = BSDgetopt(ac, (char * const  *)av, "f:p:b:k:h:g:u:o:dDeiqtQ46");
#line 827
    if (! (opt != -1)) {
#line 827
      break;
    }
#line 828
    switch (opt) {
    case 52: 
#line 830
    IPv4or6 = 2;
#line 831
    break;
    case 54: 
#line 833
    IPv4or6 = 10;
#line 834
    break;
    case 102: 
#line 836
    config_file_name = BSDoptarg;
#line 837
    break;
    case 100: 
#line 839
    if (debug_flag == 0) {
#line 840
      debug_flag = 1;
#line 841
      options.log_level = 5;
    } else {
#line 842
      if ((int )options.log_level < 7) {
#line 843
        options.log_level = (LogLevel )((int )options.log_level + 1);
      }
    }
#line 844
    break;
    case 68: 
#line 846
    no_daemon_flag = 1;
#line 847
    break;
    case 101: 
#line 849
    log_stderr = 1;
#line 850
    break;
    case 105: 
#line 852
    inetd_flag = 1;
#line 853
    break;
    case 81: 
#line 856
    break;
    case 113: 
#line 858
    options.log_level = 0;
#line 859
    break;
    case 98: 
#line 861
    options.server_key_bits = atoi((char const   *)BSDoptarg);
#line 862
    break;
    case 112: 
#line 864
    options.ports_from_cmdline = 1U;
#line 865
    if (options.num_ports >= 256U) {
#line 866
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"too many ports.\n");
#line 867
      exit(1);
    }
#line 869
    tmp___4 = options.num_ports;
#line 869
    (options.num_ports) ++;
#line 869
    tmp___5 = a2port((char const   *)BSDoptarg);
#line 869
    options.ports[tmp___4] = (unsigned short )tmp___5;
#line 870
    if ((int )options.ports[options.num_ports - 1U] == 0) {
#line 871
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad port number.\n");
#line 872
      exit(1);
    }
#line 874
    break;
    case 103: 
#line 876
    tmp___6 = convtime((char const   *)BSDoptarg);
#line 876
    options.login_grace_time = (int )tmp___6;
#line 876
    if (options.login_grace_time == -1) {
#line 877
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid login grace time.\n");
#line 878
      exit(1);
    }
#line 880
    break;
    case 107: 
#line 882
    tmp___7 = convtime((char const   *)BSDoptarg);
#line 882
    options.key_regeneration_time = (int )tmp___7;
#line 882
    if (options.key_regeneration_time == -1) {
#line 883
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid key regeneration interval.\n");
#line 884
      exit(1);
    }
#line 886
    break;
    case 104: 
#line 888
    if (options.num_host_key_files >= 256) {
#line 889
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"too many host keys.\n");
#line 890
      exit(1);
    }
#line 892
    tmp___8 = options.num_host_key_files;
#line 892
    (options.num_host_key_files) ++;
#line 892
    options.host_key_files[tmp___8] = BSDoptarg;
#line 893
    break;
    case 116: 
#line 895
    test_flag = 1;
#line 896
    break;
    case 117: 
#line 898
    tmp___9 = atoi((char const   *)BSDoptarg);
#line 898
    utmp_len = (unsigned int )tmp___9;
#line 899
    if (utmp_len > 64U) {
#line 900
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid utmp length.\n");
#line 901
      exit(1);
    }
#line 903
    break;
    case 111: 
#line 905
    line = xstrdup((char const   *)BSDoptarg);
#line 906
    tmp___10 = process_server_config_line(& options, line, "command-line", 0);
#line 906
    if (tmp___10 != 0) {
#line 908
      exit(1);
    }
#line 909
    xfree((void *)line);
#line 910
    break;
    case 63: 
    default: 
#line 913
    usage();
#line 914
    break;
    }
  }
#line 917
  OPENSSL_add_all_algorithms_noconf();
#line 918
  channel_set_af(IPv4or6);
#line 924
  if (log_stderr) {
#line 924
    tmp___11 = 1;
  } else {
#line 924
    if (! inetd_flag) {
#line 924
      tmp___11 = 1;
    } else {
#line 924
      tmp___11 = 0;
    }
  }
#line 924
  if ((int )options.log_facility == -1) {
#line 924
    tmp___12 = 2;
  } else {
#line 924
    tmp___12 = (int )options.log_facility;
  }
#line 924
  if ((int )options.log_level == -1) {
#line 924
    tmp___13 = 3;
  } else {
#line 924
    tmp___13 = (int )options.log_level;
  }
#line 924
  log_init(__progname, (enum __anonenum_LogLevel_71 )tmp___13, (enum __anonenum_SyslogFacility_70 )tmp___12,
           tmp___11);
#line 945
  seed_rng();
#line 948
  read_server_config(& options, (char const   *)config_file_name);
#line 951
  fill_default_server_options(& options);
#line 954
  if (BSDoptind < ac) {
#line 955
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Extra argument %s.\n",
            *(av + BSDoptind));
#line 956
    exit(1);
  }
#line 959
  debug("sshd version %.100s", "OpenSSH_3.8.1p1");
#line 962
  tmp___14 = xmalloc((unsigned int )options.num_host_key_files * sizeof(Key *));
#line 962
  sensitive_data.host_keys = (Key **)tmp___14;
#line 964
  i = 0;
#line 964
  while (i < options.num_host_key_files) {
#line 965
    *(sensitive_data.host_keys + i) = (Key *)((void *)0);
#line 964
    i ++;
  }
#line 966
  sensitive_data.server_key = (Key *)((void *)0);
#line 967
  sensitive_data.ssh1_host_key = (Key *)((void *)0);
#line 968
  sensitive_data.have_ssh1_key = 0;
#line 969
  sensitive_data.have_ssh2_key = 0;
#line 971
  i = 0;
#line 971
  while (i < options.num_host_key_files) {
#line 972
    key = key_load_private((char const   *)options.host_key_files[i], "", (char **)((void *)0));
#line 973
    *(sensitive_data.host_keys + i) = key;
#line 974
    if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 975
      error("Could not load host key: %s", options.host_key_files[i]);
#line 977
      *(sensitive_data.host_keys + i) = (Key *)((void *)0);
      goto __Cont;
    }
#line 980
    switch (key->type) {
    case 0: 
#line 982
    sensitive_data.ssh1_host_key = key;
#line 983
    sensitive_data.have_ssh1_key = 1;
#line 984
    break;
    case 1: 
    case 2: 
#line 987
    sensitive_data.have_ssh2_key = 1;
#line 988
    break;
    }
#line 990
    tmp___15 = key_type((Key const   *)key);
#line 990
    debug("private host key: #%d type %d %s", i, key->type, tmp___15);
    __Cont: /* CIL Label */ 
#line 971
    i ++;
  }
#line 993
  if (options.protocol & 1) {
#line 993
    if (! sensitive_data.have_ssh1_key) {
#line 994
      logit("Disabling protocol version 1. Could not load host key");
#line 995
      options.protocol &= -2;
    }
  }
#line 997
  if (options.protocol & 4) {
#line 997
    if (! sensitive_data.have_ssh2_key) {
#line 998
      logit("Disabling protocol version 2. Could not load host key");
#line 999
      options.protocol &= -5;
    }
  }
#line 1001
  if (! (options.protocol & 5)) {
#line 1002
    logit("sshd: no hostkeys available -- exiting.");
#line 1003
    exit(1);
  }
#line 1007
  if (options.protocol & 1) {
#line 1008
    if (options.server_key_bits < 512) {
#line 1010
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 1011
      exit(1);
    } else {
#line 1008
      if (options.server_key_bits > 32768) {
#line 1010
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 1011
        exit(1);
      }
    }
#line 1018
    tmp___17 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1018
    if (options.server_key_bits > tmp___17 - 128) {
#line 1018
      tmp___18 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1018
      if (options.server_key_bits < tmp___18 + 128) {
#line 1023
        tmp___16 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1023
        options.server_key_bits = tmp___16 + 128;
#line 1026
        debug("Forcing server key to %d bits to make it differ from host key.", options.server_key_bits);
      }
    }
  }
#line 1031
  if (use_privsep) {
#line 1035
    pw = getpwnam("sshd");
#line 1035
    if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 1036
      fatal("Privilege separation user %s does not exist", "sshd");
    }
#line 1038
    tmp___19 = stat((char const   * __restrict  )"/var/empty", (struct stat * __restrict  )(& st));
#line 1038
    if (tmp___19 == -1) {
#line 1040
      fatal("Missing privilege separation directory: %s", "/var/empty");
    } else {
#line 1038
      if (((st.st_mode & 61440U) == 16384U) == 0) {
#line 1040
        fatal("Missing privilege separation directory: %s", "/var/empty");
      }
    }
#line 1048
    if (st.st_uid != 0U) {
#line 1050
      fatal("%s must be owned by root and not group or world-writable.", "/var/empty");
    } else {
#line 1048
      if ((st.st_mode & (unsigned int )((128 >> 3) | ((128 >> 3) >> 3))) != 0U) {
#line 1050
        fatal("%s must be owned by root and not group or world-writable.", "/var/empty");
      }
    }
  }
#line 1055
  if (test_flag) {
#line 1056
    exit(0);
  }
#line 1065
  tmp___22 = setgroups(0U, (__gid_t const   *)((void *)0));
#line 1065
  if (tmp___22 < 0) {
#line 1066
    tmp___20 = __errno_location();
#line 1066
    tmp___21 = strerror(*tmp___20);
#line 1066
    debug("setgroups() failed: %.200s", tmp___21);
  }
#line 1069
  if (debug_flag) {
#line 1069
    if (! inetd_flag) {
#line 1070
      log_stderr = 1;
    }
  }
#line 1071
  log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 1078
  if (! debug_flag) {
#line 1078
    if (! inetd_flag) {
#line 1078
      if (! no_daemon_flag) {
#line 1082
        tmp___25 = daemon(0, 0);
#line 1082
        if (tmp___25 < 0) {
#line 1083
          tmp___23 = __errno_location();
#line 1083
          tmp___24 = strerror(*tmp___23);
#line 1083
          fatal("daemon() failed: %.200s", tmp___24);
        }
#line 1087
        fd = open("/dev/tty", 258);
#line 1088
        if (fd >= 0) {
#line 1089
          ioctl(fd, 21538UL, (void *)0);
#line 1090
          close(fd);
        }
      }
    }
  }
#line 1095
  log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 1098
  arc4random_stir();
#line 1102
  chdir("/");
#line 1105
  mysignal(13, (void (*)(int  ))1);
#line 1108
  if (inetd_flag) {
#line 1110
    s1 = dup(0);
#line 1111
    dup(s1);
#line 1112
    sock_in = dup(0);
#line 1113
    sock_out = dup(1);
#line 1114
    startup_pipe = -1;
#line 1120
    debug("inetd sockets after dupping: %d, %d", sock_in, sock_out);
#line 1121
    if (options.protocol & 1) {
#line 1122
      generate_ephemeral_server_key();
    }
  } else {
#line 1124
    ai = options.listen_addrs;
#line 1124
    while (ai) {
#line 1125
      if (ai->ai_family != 2) {
#line 1125
        if (ai->ai_family != 10) {
          goto __Cont___0;
        }
      }
#line 1127
      if (num_listen_socks >= 16) {
#line 1128
        fatal("Too many listen sockets. Enlarge MAX_LISTEN_SOCKS");
      }
#line 1130
      tmp___26 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr,
                             ai->ai_addrlen, (char * __restrict  )(ntop), sizeof(ntop),
                             (char * __restrict  )(strport), sizeof(strport), 3U);
#line 1130
      if (tmp___26 != 0) {
#line 1133
        error("getnameinfo failed");
        goto __Cont___0;
      }
#line 1137
      listen_sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
#line 1139
      if (listen_sock < 0) {
#line 1141
        tmp___27 = __errno_location();
#line 1141
        tmp___28 = strerror(*tmp___27);
#line 1141
        verbose("socket: %.100s", tmp___28);
        goto __Cont___0;
      }
#line 1144
      tmp___31 = fcntl(listen_sock, 4, 2048);
#line 1144
      if (tmp___31 < 0) {
#line 1145
        tmp___29 = __errno_location();
#line 1145
        tmp___30 = strerror(*tmp___29);
#line 1145
        error("listen_sock O_NONBLOCK: %s", tmp___30);
#line 1146
        close(listen_sock);
        goto __Cont___0;
      }
#line 1153
      tmp___34 = setsockopt(listen_sock, 1, 2, (void const   *)(& on), sizeof(on));
#line 1153
      if (tmp___34 == -1) {
#line 1155
        tmp___32 = __errno_location();
#line 1155
        tmp___33 = strerror(*tmp___32);
#line 1155
        error("setsockopt SO_REUSEADDR: %s", tmp___33);
      }
#line 1157
      debug("Bind to port %s on %s.", strport, ntop);
#line 1160
      tmp___37 = bind(listen_sock, (struct sockaddr  const  * __restrict  )ai->ai_addr,
                      ai->ai_addrlen);
#line 1160
      if (tmp___37 < 0) {
#line 1161
        if (! ai->ai_next) {
#line 1162
          tmp___35 = __errno_location();
#line 1162
          tmp___36 = strerror(*tmp___35);
#line 1162
          error("Bind to port %s on %s failed: %.200s.", strport, ntop, tmp___36);
        }
#line 1164
        close(listen_sock);
        goto __Cont___0;
      }
#line 1167
      listen_socks[num_listen_socks] = listen_sock;
#line 1168
      num_listen_socks ++;
#line 1171
      logit("Server listening on %s port %s.", ntop, strport);
#line 1172
      tmp___40 = listen(listen_sock, 128);
#line 1172
      if (tmp___40 < 0) {
#line 1173
        tmp___38 = __errno_location();
#line 1173
        tmp___39 = strerror(*tmp___38);
#line 1173
        fatal("listen: %.100s", tmp___39);
      }
      __Cont___0: /* CIL Label */ 
#line 1124
      ai = ai->ai_next;
    }
#line 1176
    freeaddrinfo(options.listen_addrs);
#line 1178
    if (! num_listen_socks) {
#line 1179
      fatal("Cannot bind any address.");
    }
#line 1181
    if (options.protocol & 1) {
#line 1182
      generate_ephemeral_server_key();
    }
#line 1188
    mysignal(1, & sighup_handler);
#line 1190
    mysignal(15, & sigterm_handler);
#line 1191
    mysignal(3, & sigterm_handler);
#line 1194
    mysignal(17, & main_sigchld_handler);
#line 1197
    if (! debug_flag) {
#line 1205
      f = fopen((char const   * __restrict  )options.pid_file, (char const   * __restrict  )"wb");
#line 1206
      if ((unsigned int )f == (unsigned int )((void *)0)) {
#line 1207
        tmp___41 = __errno_location();
#line 1207
        tmp___42 = strerror(*tmp___41);
#line 1207
        error("Couldn\'t create pid file \"%s\": %s", options.pid_file, tmp___42);
      } else {
#line 1210
        tmp___43 = getpid();
#line 1210
        fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%ld\n", (long )tmp___43);
#line 1211
        fclose(f);
      }
    }
#line 1216
    fdset = (fd_set *)((void *)0);
#line 1217
    maxfd = 0;
#line 1218
    i = 0;
#line 1218
    while (i < num_listen_socks) {
#line 1219
      if (listen_socks[i] > maxfd) {
#line 1220
        maxfd = listen_socks[i];
      }
#line 1218
      i ++;
    }
#line 1222
    tmp___44 = xmalloc((unsigned int )options.max_startups * sizeof(int ));
#line 1222
    startup_pipes = (int *)tmp___44;
#line 1223
    i = 0;
#line 1223
    while (i < options.max_startups) {
#line 1224
      *(startup_pipes + i) = -1;
#line 1223
      i ++;
    }
#line 1230
    while (1) {
#line 1231
      if (received_sighup) {
#line 1232
        sighup_restart();
      }
#line 1233
      if ((unsigned int )fdset != (unsigned int )((void *)0)) {
#line 1234
        xfree((void *)fdset);
      }
#line 1235
      fdsetsz = (int )((((unsigned int )(maxfd + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 1236
      tmp___45 = xmalloc((unsigned int )fdsetsz);
#line 1236
      fdset = (fd_set *)tmp___45;
#line 1237
      memset((void *)fdset, 0, (unsigned int )fdsetsz);
#line 1239
      i = 0;
#line 1239
      while (i < num_listen_socks) {
#line 1240
        __asm__  volatile   ("btsl %1,%0": "=m" (fdset->__fds_bits[(unsigned int )listen_socks[i] / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )listen_socks[i] % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
#line 1239
        i ++;
      }
#line 1241
      i = 0;
#line 1241
      while (i < options.max_startups) {
#line 1242
        if (*(startup_pipes + i) != -1) {
#line 1243
          __asm__  volatile   ("btsl %1,%0": "=m" (fdset->__fds_bits[(unsigned int )*(startup_pipes + i) / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )*(startup_pipes + i) % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        }
#line 1241
        i ++;
      }
#line 1246
      ret = select(maxfd + 1, (fd_set * __restrict  )fdset, (fd_set * __restrict  )((void *)0),
                   (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 1247
      if (ret < 0) {
#line 1247
        tmp___48 = __errno_location();
#line 1247
        if (*tmp___48 != 4) {
#line 1248
          tmp___46 = __errno_location();
#line 1248
          tmp___47 = strerror(*tmp___46);
#line 1248
          error("select: %.100s", tmp___47);
        }
      }
#line 1249
      if (received_sigterm) {
#line 1250
        logit("Received signal %d; terminating.", (int )received_sigterm);
#line 1252
        close_listen_socks();
#line 1253
        unlink((char const   *)options.pid_file);
#line 1254
        exit(255);
      }
#line 1256
      if (key_used) {
#line 1256
        if (key_do_regen) {
#line 1257
          generate_ephemeral_server_key();
#line 1258
          key_used = 0;
#line 1259
          key_do_regen = (int volatile   )0;
        }
      }
#line 1261
      if (ret < 0) {
        goto __Cont___1;
      }
#line 1264
      i = 0;
#line 1264
      while (i < options.max_startups) {
#line 1266
        if (*(startup_pipes + i) != -1) {
#line 1266
          __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )*(startup_pipes + i) % (8U * sizeof(__fd_mask ))),
                               "m" (fdset->__fds_bits[(unsigned int )*(startup_pipes + i) / (8U * sizeof(__fd_mask ))]): "cc");
#line 1266
          if (__result) {
#line 1273
            close(*(startup_pipes + i));
#line 1274
            *(startup_pipes + i) = -1;
#line 1275
            startups --;
          }
        }
#line 1264
        i ++;
      }
#line 1277
      i = 0;
#line 1277
      while (i < num_listen_socks) {
#line 1278
        __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )listen_socks[i] % (8U * sizeof(__fd_mask ))),
                             "m" (fdset->__fds_bits[(unsigned int )listen_socks[i] / (8U * sizeof(__fd_mask ))]): "cc");
#line 1278
        if (! __result___0) {
          goto __Cont___2;
        }
#line 1280
        fromlen = sizeof(from);
#line 1281
        newsock = accept(listen_socks[i], (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                         (socklen_t * __restrict  )(& fromlen));
#line 1283
        if (newsock < 0) {
#line 1284
          tmp___51 = __errno_location();
#line 1284
          if (*tmp___51 != 4) {
#line 1284
            tmp___52 = __errno_location();
#line 1284
            if (*tmp___52 != 11) {
#line 1285
              tmp___49 = __errno_location();
#line 1285
              tmp___50 = strerror(*tmp___49);
#line 1285
              error("accept: %.100s", tmp___50);
            }
          }
          goto __Cont___2;
        }
#line 1288
        tmp___55 = fcntl(newsock, 4, 0);
#line 1288
        if (tmp___55 < 0) {
#line 1289
          tmp___53 = __errno_location();
#line 1289
          tmp___54 = strerror(*tmp___53);
#line 1289
          error("newsock del O_NONBLOCK: %s", tmp___54);
#line 1290
          close(newsock);
          goto __Cont___2;
        }
#line 1293
        tmp___56 = drop_connection(startups);
#line 1293
        if (tmp___56 == 1) {
#line 1294
          debug("drop connection #%d", startups);
#line 1295
          close(newsock);
          goto __Cont___2;
        }
#line 1298
        tmp___57 = pipe((int *)(startup_p));
#line 1298
        if (tmp___57 == -1) {
#line 1299
          close(newsock);
          goto __Cont___2;
        }
#line 1303
        j = 0;
#line 1303
        while (j < options.max_startups) {
#line 1304
          if (*(startup_pipes + j) == -1) {
#line 1305
            *(startup_pipes + j) = startup_p[0];
#line 1306
            if (maxfd < startup_p[0]) {
#line 1307
              maxfd = startup_p[0];
            }
#line 1308
            startups ++;
#line 1309
            break;
          }
#line 1303
          j ++;
        }
#line 1316
        if (debug_flag) {
#line 1322
          debug("Server will not fork when running in debugging mode.");
#line 1323
          close_listen_socks();
#line 1324
          sock_in = newsock;
#line 1325
          sock_out = newsock;
#line 1326
          startup_pipe = -1;
#line 1327
          pid = getpid();
#line 1328
          break;
        } else {
#line 1335
          pid = fork();
#line 1335
          if (pid == 0) {
#line 1343
            startup_pipe = startup_p[1];
#line 1344
            close_startup_pipes();
#line 1345
            close_listen_socks();
#line 1346
            sock_in = newsock;
#line 1347
            sock_out = newsock;
#line 1348
            log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 1349
            break;
          }
        }
#line 1354
        if (pid < 0) {
#line 1355
          tmp___58 = __errno_location();
#line 1355
          tmp___59 = strerror(*tmp___58);
#line 1355
          error("fork: %.100s", tmp___59);
        } else {
#line 1357
          debug("Forked child %ld.", (long )pid);
        }
#line 1359
        close(startup_p[1]);
#line 1362
        if (options.protocol & 1) {
#line 1362
          if (key_used == 0) {
#line 1365
            mysignal(14, & key_regeneration_alarm);
#line 1366
            alarm((unsigned int )options.key_regeneration_time);
#line 1367
            key_used = 1;
          }
        }
#line 1370
        arc4random_stir();
#line 1373
        close(newsock);
        __Cont___2: /* CIL Label */ 
#line 1277
        i ++;
      }
#line 1376
      if (num_listen_socks < 0) {
#line 1377
        break;
      }
      __Cont___1: /* CIL Label */ ;
    }
  }
#line 1382
  setproctitle("%s", "[accepted]");
#line 1395
  if (! debug_flag) {
#line 1395
    if (! inetd_flag) {
#line 1395
      tmp___62 = setsid();
#line 1395
      if (tmp___62 < 0) {
#line 1396
        tmp___60 = __errno_location();
#line 1396
        tmp___61 = strerror(*tmp___60);
#line 1396
        error("setsid: %.100s", tmp___61);
      }
    }
  }
#line 1404
  alarm(0U);
#line 1405
  mysignal(14, (void (*)(int  ))0);
#line 1406
  mysignal(1, (void (*)(int  ))0);
#line 1407
  mysignal(15, (void (*)(int  ))0);
#line 1408
  mysignal(3, (void (*)(int  ))0);
#line 1409
  mysignal(17, (void (*)(int  ))0);
#line 1410
  mysignal(2, (void (*)(int  ))0);
#line 1413
  if (options.tcp_keep_alive) {
#line 1413
    tmp___65 = setsockopt(sock_in, 1, 9, (void const   *)(& on), sizeof(on));
#line 1413
    if (tmp___65 < 0) {
#line 1416
      tmp___63 = __errno_location();
#line 1416
      tmp___64 = strerror(*tmp___63);
#line 1416
      error("setsockopt SO_KEEPALIVE: %.100s", tmp___64);
    }
  }
#line 1422
  packet_set_connection(sock_in, sock_out);
#line 1424
  remote_port = get_remote_port();
#line 1425
  remote_ip = get_remote_ipaddr();
#line 1445
  verbose("Connection from %.500s port %d", remote_ip, remote_port);
#line 1455
  mysignal(14, & grace_alarm_handler);
#line 1456
  if (! debug_flag) {
#line 1457
    alarm((unsigned int )options.login_grace_time);
  }
#line 1459
  sshd_exchange_identification(sock_in, sock_out);
#line 1461
  packet_set_nonblocking();
#line 1464
  buffer_init(& loginmsg);
#line 1467
  tmp___66 = xmalloc(sizeof(*authctxt___0));
#line 1467
  authctxt___0 = (Authctxt *)tmp___66;
#line 1468
  memset((void *)authctxt___0, 0, sizeof(*authctxt___0));
#line 1471
  the_authctxt = authctxt___0;
#line 1473
  if (use_privsep) {
#line 1474
    tmp___67 = privsep_preauth(authctxt___0);
#line 1474
    if (tmp___67 == 1) {
      goto authenticated;
    }
  }
#line 1479
  if (compat20) {
#line 1480
    do_ssh2_kex();
#line 1481
    do_authentication2(authctxt___0);
  } else {
#line 1483
    do_ssh1_kex();
#line 1484
    do_authentication(authctxt___0);
  }
#line 1490
  if (use_privsep) {
#line 1491
    mm_send_keystate(pmonitor);
#line 1492
    exit(0);
  }
  authenticated: 
#line 1500
  if (use_privsep) {
#line 1501
    privsep_postauth(authctxt___0);
#line 1503
    if (! compat20) {
#line 1504
      destroy_sensitive_data();
    }
  }
#line 1508
  do_authenticated(authctxt___0);
#line 1511
  verbose("Closing connection to %.100s", remote_ip);
#line 1518
  packet_close();
#line 1520
  if (use_privsep) {
#line 1521
    mm_terminate();
  }
#line 1523
  exit(0);
}
}
#line 1530 "sshd.c"
int ssh1_session_key(BIGNUM *session_key_int ) 
{ int rsafail ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 1533
  rsafail = 0;
#line 1535
  tmp___13 = BN_cmp((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n, (BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1535
  if (tmp___13 > 0) {
#line 1537
    tmp___2 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1537
    tmp___3 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1537
    if (tmp___2 < tmp___3 + 128) {
#line 1539
      tmp = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1539
      tmp___0 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1539
      tmp___1 = get_remote_ipaddr();
#line 1539
      fatal("do_connection: %s: server_key %d < host_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___1, tmp___0, tmp, 128);
    }
#line 1545
    tmp___4 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.server_key)->rsa);
#line 1545
    if (tmp___4 <= 0) {
#line 1547
      rsafail ++;
    }
#line 1548
    tmp___5 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.ssh1_host_key)->rsa);
#line 1548
    if (tmp___5 <= 0) {
#line 1550
      rsafail ++;
    }
  } else {
#line 1553
    tmp___9 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1553
    tmp___10 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1553
    if (tmp___9 < tmp___10 + 128) {
#line 1555
      tmp___6 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1555
      tmp___7 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1555
      tmp___8 = get_remote_ipaddr();
#line 1555
      fatal("do_connection: %s: host_key %d < server_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___8, tmp___7, tmp___6, 128);
    }
#line 1561
    tmp___11 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.ssh1_host_key)->rsa);
#line 1561
    if (tmp___11 < 0) {
#line 1563
      rsafail ++;
    }
#line 1564
    tmp___12 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.server_key)->rsa);
#line 1564
    if (tmp___12 < 0) {
#line 1566
      rsafail ++;
    }
  }
#line 1568
  return (rsafail);
}
}
#line 1573 "sshd.c"
static void do_ssh1_kex(void) 
{ int i ;
  int len ;
  int rsafail ;
  BIGNUM *session_key_int ;
  u_char session_key[32] ;
  u_char cookie[8] ;
  u_int cipher_type ;
  u_int auth_mask ;
  u_int protocol_flags ;
  u_int32_t rnd ;
  int tmp ;
  int tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  char *tmp___6 ;
  int _len ;
  int tmp___7 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  int bytes ;
  int tmp___12 ;
  u_char *buf___1 ;
  void *tmp___13 ;
  MD5_CTX md ;

  {
#line 1577
  rsafail = 0;
#line 1582
  rnd = (u_int32_t )0;
#line 1593
  i = 0;
#line 1593
  while (i < 8) {
#line 1594
    if (i % 4 == 0) {
#line 1595
      rnd = arc4random();
    }
#line 1596
    cookie[i] = (unsigned char )(rnd & 255U);
#line 1597
    rnd >>= 8;
#line 1593
    i ++;
  }
#line 1605
  packet_start((unsigned char)2);
#line 1606
  i = 0;
#line 1606
  while (i < 8) {
#line 1607
    packet_put_char((int )cookie[i]);
#line 1606
    i ++;
  }
#line 1610
  tmp = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1610
  packet_put_int((unsigned int )tmp);
#line 1611
  packet_put_bignum(((sensitive_data.server_key)->rsa)->e);
#line 1612
  packet_put_bignum(((sensitive_data.server_key)->rsa)->n);
#line 1615
  tmp___0 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1615
  packet_put_int((unsigned int )tmp___0);
#line 1616
  packet_put_bignum(((sensitive_data.ssh1_host_key)->rsa)->e);
#line 1617
  packet_put_bignum(((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1620
  packet_put_int(2U);
#line 1623
  tmp___1 = cipher_mask_ssh1(0);
#line 1623
  packet_put_int(tmp___1);
#line 1626
  auth_mask = 0U;
#line 1627
  if (options.rhosts_rsa_authentication) {
#line 1628
    auth_mask |= (unsigned int )(1 << 4);
  }
#line 1629
  if (options.rsa_authentication) {
#line 1630
    auth_mask |= (unsigned int )(1 << 2);
  }
#line 1631
  if (options.challenge_response_authentication == 1) {
#line 1632
    auth_mask |= (unsigned int )(1 << 5);
  }
#line 1633
  if (options.password_authentication) {
#line 1634
    auth_mask |= (unsigned int )(1 << 3);
  }
#line 1635
  packet_put_int(auth_mask);
#line 1638
  packet_send();
#line 1639
  packet_write_wait();
#line 1641
  tmp___2 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1641
  tmp___3 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1641
  debug("Sent %d bit server key and %d bit host key.", tmp___3, tmp___2);
#line 1646
  packet_read_expect(3);
#line 1649
  cipher_type = packet_get_char();
#line 1651
  tmp___4 = cipher_mask_ssh1(0);
#line 1651
  if (! (tmp___4 & (unsigned int )(1 << cipher_type))) {
#line 1652
    packet_disconnect("Warning: client selects unsupported cipher.");
  }
#line 1656
  i = 0;
#line 1656
  while (i < 8) {
#line 1657
    tmp___5 = packet_get_char();
#line 1657
    if ((u_int )cookie[i] != tmp___5) {
#line 1658
      packet_disconnect("IP Spoofing check bytes do not match.");
    }
#line 1656
    i ++;
  }
#line 1660
  tmp___6 = cipher_name((int )cipher_type);
#line 1660
  debug("Encryption type: %.200s", tmp___6);
#line 1663
  session_key_int = BN_new();
#line 1663
  if ((unsigned int )session_key_int == (unsigned int )((void *)0)) {
#line 1664
    fatal("do_ssh1_kex: BN_new failed");
  }
#line 1665
  packet_get_bignum(session_key_int);
#line 1667
  protocol_flags = packet_get_int();
#line 1668
  packet_set_protocol_flags(protocol_flags);
#line 1669
  while (1) {
#line 1669
    tmp___7 = packet_remaining();
#line 1669
    _len = tmp___7;
#line 1669
    if (_len > 0) {
#line 1669
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "sshd.c",
            1669);
#line 1669
      packet_disconnect("Packet integrity error.");
    }
#line 1669
    break;
  }
#line 1672
  if (use_privsep) {
#line 1672
    rsafail = mm_ssh1_session_key(session_key_int);
  } else {
#line 1672
    rsafail = ssh1_session_key(session_key_int);
  }
#line 1679
  if (! rsafail) {
#line 1680
    BN_mask_bits(session_key_int, (int )(sizeof(session_key) * 8U));
#line 1681
    tmp___10 = BN_num_bits((BIGNUM const   *)session_key_int);
#line 1681
    len = (tmp___10 + 7) / 8;
#line 1682
    if (len < 0) {
#line 1683
      tmp___11 = get_remote_ipaddr();
#line 1683
      error("do_connection: bad session key len from %s: session_key_int %d > sizeof(session_key) %lu",
            tmp___11, len, (unsigned long )sizeof(session_key));
#line 1686
      rsafail ++;
    } else {
#line 1682
      if ((unsigned int )len > sizeof(session_key)) {
#line 1683
        tmp___11 = get_remote_ipaddr();
#line 1683
        error("do_connection: bad session key len from %s: session_key_int %d > sizeof(session_key) %lu",
              tmp___11, len, (unsigned long )sizeof(session_key));
#line 1686
        rsafail ++;
      } else {
#line 1688
        memset((void *)(session_key), 0, sizeof(session_key));
#line 1689
        BN_bn2bin((BIGNUM const   *)session_key_int, (session_key + sizeof(session_key)) - len);
#line 1692
        compute_session_id((u_char *)(session_id), (u_char *)(cookie), ((sensitive_data.ssh1_host_key)->rsa)->n,
                           ((sensitive_data.server_key)->rsa)->n);
#line 1699
        i = 0;
#line 1699
        while (i < 16) {
#line 1700
          session_key[i] = (unsigned char )((int )session_key[i] ^ (int )session_id[i]);
#line 1699
          i ++;
        }
      }
    }
  }
#line 1703
  if (rsafail) {
#line 1704
    tmp___12 = BN_num_bits((BIGNUM const   *)session_key_int);
#line 1704
    bytes = (tmp___12 + 7) / 8;
#line 1705
    tmp___13 = xmalloc((unsigned int )bytes);
#line 1705
    buf___1 = (u_char *)tmp___13;
#line 1708
    logit("do_connection: generating a fake encryption key");
#line 1709
    BN_bn2bin((BIGNUM const   *)session_key_int, buf___1);
#line 1710
    MD5_Init(& md);
#line 1711
    MD5_Update(& md, (void const   *)buf___1, (unsigned int )bytes);
#line 1712
    MD5_Update(& md, (void const   *)(sensitive_data.ssh1_cookie), 32U);
#line 1713
    MD5_Final(session_key, & md);
#line 1714
    MD5_Init(& md);
#line 1715
    MD5_Update(& md, (void const   *)(session_key), 16U);
#line 1716
    MD5_Update(& md, (void const   *)buf___1, (unsigned int )bytes);
#line 1717
    MD5_Update(& md, (void const   *)(sensitive_data.ssh1_cookie), 32U);
#line 1718
    MD5_Final(session_key + 16, & md);
#line 1719
    memset((void *)buf___1, 0, (unsigned int )bytes);
#line 1720
    xfree((void *)buf___1);
#line 1721
    i = 0;
#line 1721
    while (i < 16) {
#line 1722
      session_id[i] = (unsigned char )((int )session_key[i] ^ (int )session_key[i + 16]);
#line 1721
      i ++;
    }
  }
#line 1725
  destroy_sensitive_data();
#line 1727
  if (use_privsep) {
#line 1728
    mm_ssh1_session_id(session_id);
  }
#line 1731
  BN_clear_free(session_key_int);
#line 1734
  packet_set_encryption_key((u_char const   *)(session_key), 32U, (int )cipher_type);
#line 1737
  memset((void *)(session_key), 0, sizeof(session_key));
#line 1739
  debug("Received session key; encryption turned on.");
#line 1742
  packet_start((unsigned char)14);
#line 1743
  packet_send();
#line 1744
  packet_write_wait();
#line 1745
  return;
}
}
#line 1750 "sshd.c"
static void do_ssh2_kex(void) 
{ Kex *kex ;

  {
#line 1755
  if ((unsigned int )options.ciphers != (unsigned int )((void *)0)) {
#line 1756
    myproposal[3] = options.ciphers;
#line 1756
    myproposal[2] = myproposal[3];
  }
#line 1759
  myproposal[2] = compat_cipher_proposal(myproposal[2]);
#line 1761
  myproposal[3] = compat_cipher_proposal(myproposal[3]);
#line 1764
  if ((unsigned int )options.macs != (unsigned int )((void *)0)) {
#line 1765
    myproposal[5] = options.macs;
#line 1765
    myproposal[4] = myproposal[5];
  }
#line 1768
  if (! options.compression) {
#line 1769
    myproposal[7] = (char *)"none";
#line 1769
    myproposal[6] = myproposal[7];
  }
#line 1772
  myproposal[1] = list_hostkey_types();
#line 1775
  kex = kex_setup((char **)(myproposal));
#line 1776
  kex->kex[0] = & kexdh_server;
#line 1777
  kex->kex[1] = & kexgex_server;
#line 1778
  kex->server = 1;
#line 1779
  kex->client_version_string = client_version_string;
#line 1780
  kex->server_version_string = server_version_string;
#line 1781
  kex->load_host_key = & get_hostkey_by_type;
#line 1782
  kex->host_key_index = & get_hostkey_index;
#line 1784
  xxx_kex = kex;
#line 1786
  dispatch_run(0, & kex->done, (void *)kex);
#line 1788
  session_id2 = kex->session_id;
#line 1789
  session_id2_len = kex->session_id_len;
#line 1798
  debug("KEX done");
#line 1799
  return;
}
}
#line 1 "auth-rhosts.o"
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 418 "/usr/include/netdb.h"
extern int innetgr(char const   *__netgroup , char const   *__host , char const   *__user ,
                   char const   *domain ) ;
#line 18 "uidswap.h"
void temporarily_use_uid(struct passwd *pw ) ;
#line 19
void restore_uid(void) ;
#line 103 "auth.h"
int auth_rhosts(struct passwd *pw , char const   *client_user ) ;
#line 104
int auth_rhosts2(struct passwd *pw , char const   *client_user , char const   *hostname ,
                 char const   *ipaddr ) ;
#line 178
void ( /* format attribute */  auth_debug_add)(char const   *fmt  , ...) ;
#line 179
void auth_debug_send(void) ;
#line 180
void auth_debug_reset(void) ;
#line 37 "auth-rhosts.c"
static int check_rhosts_file(char const   *filename , char const   *hostname , char const   *ipaddr ,
                             char const   *client_user , char const   *server_user ) 
{ FILE *f ;
  char buf___1[1024] ;
  char hostbuf[1024] ;
  char userbuf[1024] ;
  char dummy[1024] ;
  char *host ;
  char *user ;
  char *cp ;
  int negated ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___45 ;
  int tmp___48 ;
  int tmp___49 ;
  char *tmp___50 ;

  {
#line 46
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 47
  if (! f) {
#line 48
    return (0);
  }
#line 50
  while (1) {
#line 50
    tmp___50 = fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )f);
#line 50
    if (! tmp___50) {
#line 50
      break;
    }
#line 55
    cp = buf___1;
#line 55
    while (1) {
#line 55
      if (! ((int )*cp == 32)) {
#line 55
        if (! ((int )*cp == 9)) {
#line 55
          break;
        }
      }
#line 55
      cp ++;
    }
#line 57
    if ((int )*cp == 35) {
#line 58
      continue;
    } else {
#line 57
      if ((int )*cp == 10) {
#line 58
        continue;
      } else {
#line 57
        if (! *cp) {
#line 58
          continue;
        }
      }
    }
#line 64
    if (0) {
#line 64
      if (0) {
#line 64
        __s1_len___0 = strlen((char const   *)cp);
#line 64
        __s2_len___0 = strlen("NO_PLUS");
#line 64
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___2;
        } else {
#line 64
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 64
            if (! ((unsigned int )((void const   *)("NO_PLUS" + 1)) - (unsigned int )((void const   *)"NO_PLUS") == 1U)) {
#line 64
              tmp___22 = 1;
            } else {
#line 64
              if (__s2_len___0 >= 4U) {
#line 64
                tmp___22 = 1;
              } else {
#line 64
                tmp___22 = 0;
              }
            }
          } else {
#line 64
            tmp___22 = 0;
          }
        }
#line 64
        if (tmp___22) {
#line 64
          tmp___18 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
        } else {
#line 64
          tmp___21 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 64
          tmp___18 = tmp___21;
        }
      } else {
#line 64
        tmp___21 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 64
        tmp___18 = tmp___21;
      }
#line 64
      tmp___12 = tmp___18;
    } else {
#line 64
      tmp___12 = strncmp((char const   *)cp, "NO_PLUS", 7U);
    }
#line 64
    if (tmp___12 == 0) {
#line 65
      continue;
    }
#line 71
    tmp___25 = sscanf((char const   * __restrict  )(buf___1), (char const   * __restrict  )"%1023s %1023s %1023s",
                      hostbuf, userbuf, dummy);
#line 71
    switch (tmp___25) {
    case 0: 
#line 74
    auth_debug_add("Found empty line in %.100s.", filename);
#line 75
    continue;
    case 1: 
#line 78
    strlcpy(userbuf, server_user, sizeof(userbuf));
#line 79
    break;
    case 2: 
#line 82
    break;
    case 3: 
#line 84
    auth_debug_add("Found garbage in %.100s.", filename);
#line 85
    continue;
    default: ;
#line 88
    continue;
    }
#line 91
    host = hostbuf;
#line 92
    user = userbuf;
#line 93
    negated = 0;
#line 96
    if ((int )*(host + 0) == 45) {
#line 97
      negated = 1;
#line 98
      host ++;
    } else {
#line 99
      if ((int )*(host + 0) == 43) {
#line 100
        host ++;
      }
    }
#line 102
    if ((int )*(user + 0) == 45) {
#line 103
      negated = 1;
#line 104
      user ++;
    } else {
#line 105
      if ((int )*(user + 0) == 43) {
#line 106
        user ++;
      }
    }
#line 109
    if (! *(host + 0)) {
#line 111
      auth_debug_add("Ignoring wild host/user names in %.100s.", filename);
#line 113
      continue;
    } else {
#line 109
      if (! *(user + 0)) {
#line 111
        auth_debug_add("Ignoring wild host/user names in %.100s.", filename);
#line 113
        continue;
      }
    }
#line 116
    if ((int )*(host + 0) == 64) {
#line 117
      tmp___26 = innetgr((char const   *)(host + 1), hostname, (char const   *)((void *)0),
                         (char const   *)((void *)0));
#line 117
      if (! tmp___26) {
#line 117
        tmp___27 = innetgr((char const   *)(host + 1), ipaddr, (char const   *)((void *)0),
                           (char const   *)((void *)0));
#line 117
        if (! tmp___27) {
#line 119
          continue;
        }
      }
    } else {
#line 120
      tmp___28 = strcasecmp((char const   *)host, hostname);
#line 120
      if (tmp___28) {
#line 120
        if (0) {
#line 120
          __s1_len___1 = strlen((char const   *)host);
#line 120
          __s2_len___1 = strlen(ipaddr);
#line 120
          if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
            goto _L___4;
          } else {
#line 120
            if (__s1_len___1 >= 4U) {
              _L___4: /* CIL Label */ 
#line 120
              if (! ((unsigned int )((void const   *)(ipaddr + 1)) - (unsigned int )((void const   *)ipaddr) == 1U)) {
#line 120
                tmp___38 = 1;
              } else {
#line 120
                if (__s2_len___1 >= 4U) {
#line 120
                  tmp___38 = 1;
                } else {
#line 120
                  tmp___38 = 0;
                }
              }
            } else {
#line 120
              tmp___38 = 0;
            }
          }
#line 120
          if (tmp___38) {
#line 120
            tmp___34 = __builtin_strcmp((char const   *)host, ipaddr);
          } else {
#line 120
            tmp___37 = __builtin_strcmp((char const   *)host, ipaddr);
#line 120
            tmp___34 = tmp___37;
          }
        } else {
#line 120
          tmp___37 = __builtin_strcmp((char const   *)host, ipaddr);
#line 120
          tmp___34 = tmp___37;
        }
#line 120
        if (tmp___34 != 0) {
#line 121
          continue;
        }
      }
    }
#line 124
    if ((int )*(user + 0) == 64) {
#line 125
      tmp___39 = innetgr((char const   *)(user + 1), (char const   *)((void *)0),
                         client_user, (char const   *)((void *)0));
#line 125
      if (! tmp___39) {
#line 126
        continue;
      }
    } else {
#line 127
      if (0) {
#line 127
        __s1_len___2 = strlen((char const   *)user);
#line 127
        __s2_len___2 = strlen(client_user);
#line 127
        if (! ((unsigned int )((void const   *)(user + 1)) - (unsigned int )((void const   *)user) == 1U)) {
          goto _L___6;
        } else {
#line 127
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 127
            if (! ((unsigned int )((void const   *)(client_user + 1)) - (unsigned int )((void const   *)client_user) == 1U)) {
#line 127
              tmp___49 = 1;
            } else {
#line 127
              if (__s2_len___2 >= 4U) {
#line 127
                tmp___49 = 1;
              } else {
#line 127
                tmp___49 = 0;
              }
            }
          } else {
#line 127
            tmp___49 = 0;
          }
        }
#line 127
        if (tmp___49) {
#line 127
          tmp___45 = __builtin_strcmp((char const   *)user, client_user);
        } else {
#line 127
          tmp___48 = __builtin_strcmp((char const   *)user, client_user);
#line 127
          tmp___45 = tmp___48;
        }
      } else {
#line 127
        tmp___48 = __builtin_strcmp((char const   *)user, client_user);
#line 127
        tmp___45 = tmp___48;
      }
#line 127
      if (tmp___45 != 0) {
#line 128
        continue;
      }
    }
#line 131
    fclose(f);
#line 134
    if (negated) {
#line 135
      auth_debug_add("Matched negative entry in %.100s.", filename);
#line 137
      return (0);
    }
#line 140
    return (1);
  }
#line 144
  fclose(f);
#line 145
  return (0);
}
}
#line 154 "auth-rhosts.c"
int auth_rhosts(struct passwd *pw , char const   *client_user ) 
{ char const   *hostname ;
  char const   *ipaddr ;
  int tmp ;

  {
#line 159
  hostname = get_canonical_hostname(options.use_dns);
#line 160
  ipaddr = get_remote_ipaddr();
#line 161
  tmp = auth_rhosts2(pw, client_user, hostname, ipaddr);
#line 161
  return (tmp);
}
}
#line 170
static int auth_rhosts2_raw(struct passwd *pw , char const   *client_user , char const   *hostname ,
                            char const   *ipaddr ) ;
#line 170 "auth-rhosts.c"
static char const   *rhosts_files[3]  = {      ".shosts",      ".rhosts",      (char const   *)((void *)0)};
#line 164 "auth-rhosts.c"
static int auth_rhosts2_raw(struct passwd *pw , char const   *client_user , char const   *hostname ,
                            char const   *ipaddr ) 
{ char buf___1[1024] ;
  struct stat st ;
  u_int rhosts_file_index ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 173
  debug2("auth_rhosts2: clientuser %s hostname %s ipaddr %s", client_user, hostname,
         ipaddr);
#line 177
  temporarily_use_uid(pw);
#line 183
  rhosts_file_index = 0U;
#line 183
  while (rhosts_files[rhosts_file_index]) {
#line 186
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.500s/%.100s",
             pw->pw_dir, rhosts_files[rhosts_file_index]);
#line 188
    tmp = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )(& st));
#line 188
    if (tmp >= 0) {
#line 189
      break;
    }
#line 183
    rhosts_file_index ++;
  }
#line 192
  restore_uid();
#line 195
  if (! rhosts_files[rhosts_file_index]) {
#line 195
    tmp___0 = stat((char const   * __restrict  )"/etc/hosts.equiv", (struct stat * __restrict  )(& st));
#line 195
    if (tmp___0 < 0) {
#line 195
      tmp___1 = stat((char const   * __restrict  )"/usr/local/etc/shosts.equiv", (struct stat * __restrict  )(& st));
#line 195
      if (tmp___1 < 0) {
#line 198
        return (0);
      }
    }
  }
#line 201
  if (pw->pw_uid != 0U) {
#line 202
    tmp___2 = check_rhosts_file("/etc/hosts.equiv", hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 202
    if (tmp___2) {
#line 204
      auth_debug_add("Accepted for %.100s [%.100s] by /etc/hosts.equiv.", hostname,
                     ipaddr);
#line 206
      return (1);
    }
#line 208
    tmp___3 = check_rhosts_file("/usr/local/etc/shosts.equiv", hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 208
    if (tmp___3) {
#line 210
      auth_debug_add("Accepted for %.100s [%.100s] by %.100s.", hostname, ipaddr,
                     "/usr/local/etc/shosts.equiv");
#line 212
      return (1);
    }
  }
#line 219
  tmp___4 = stat((char const   * __restrict  )pw->pw_dir, (struct stat * __restrict  )(& st));
#line 219
  if (tmp___4 < 0) {
#line 220
    logit("Rhosts authentication refused for %.100s: no home directory %.200s", pw->pw_name,
          pw->pw_dir);
#line 222
    auth_debug_add("Rhosts authentication refused for %.100s: no home directory %.200s",
                   pw->pw_name, pw->pw_dir);
#line 224
    return (0);
  }
#line 226
  if (options.strict_modes) {
#line 226
    if (st.st_uid != 0U) {
#line 226
      if (st.st_uid != pw->pw_uid) {
#line 229
        logit("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
              pw->pw_name);
#line 231
        auth_debug_add("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                       pw->pw_name);
#line 233
        return (0);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 226
      if ((st.st_mode & 18U) != 0U) {
#line 229
        logit("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
              pw->pw_name);
#line 231
        auth_debug_add("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                       pw->pw_name);
#line 233
        return (0);
      }
    }
  }
#line 236
  temporarily_use_uid(pw);
#line 239
  rhosts_file_index = 0U;
#line 239
  while (rhosts_files[rhosts_file_index]) {
#line 242
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.500s/%.100s",
             pw->pw_dir, rhosts_files[rhosts_file_index]);
#line 244
    tmp___5 = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )(& st));
#line 244
    if (tmp___5 < 0) {
      goto __Cont;
    }
#line 253
    if (options.strict_modes) {
#line 253
      if (st.st_uid != 0U) {
#line 253
        if (st.st_uid != pw->pw_uid) {
#line 256
          logit("Rhosts authentication refused for %.100s: bad modes for %.200s",
                pw->pw_name, buf___1);
#line 258
          auth_debug_add("Bad file modes for %.200s", buf___1);
          goto __Cont;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 253
        if ((st.st_mode & 18U) != 0U) {
#line 256
          logit("Rhosts authentication refused for %.100s: bad modes for %.200s",
                pw->pw_name, buf___1);
#line 258
          auth_debug_add("Bad file modes for %.200s", buf___1);
          goto __Cont;
        }
      }
    }
#line 262
    if (options.ignore_rhosts) {
#line 263
      auth_debug_add("Server has been configured to ignore %.100s.", rhosts_files[rhosts_file_index]);
      goto __Cont;
    }
#line 268
    tmp___6 = check_rhosts_file((char const   *)(buf___1), hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 268
    if (tmp___6) {
#line 269
      auth_debug_add("Accepted by %.100s.", rhosts_files[rhosts_file_index]);
#line 272
      restore_uid();
#line 273
      auth_debug_add("Accepted host %s ip %s client_user %s server_user %s", hostname,
                     ipaddr, client_user, pw->pw_name);
#line 275
      return (1);
    }
    __Cont: /* CIL Label */ 
#line 239
    rhosts_file_index ++;
  }
#line 280
  restore_uid();
#line 281
  return (0);
}
}
#line 284 "auth-rhosts.c"
int auth_rhosts2(struct passwd *pw , char const   *client_user , char const   *hostname ,
                 char const   *ipaddr ) 
{ int ret ;

  {
#line 290
  auth_debug_reset();
#line 291
  ret = auth_rhosts2_raw(pw, client_user, hostname, ipaddr);
#line 292
  if (! use_privsep) {
#line 293
    auth_debug_send();
  }
#line 294
  return (ret);
}
}
#line 1 "auth-passwd.o"
#line 108 "auth.h"
int auth_password(Authctxt *authctxt___0 , char const   *password ) ;
#line 129
int auth_shadow_pwexpired(Authctxt *ctxt ) ;
#line 133
void disable_forwarding(void) ;
#line 25 "auth-options.h"
int no_port_forwarding_flag ;
#line 26
int no_agent_forwarding_flag ;
#line 27
int no_x11_forwarding_flag ;
#line 48 "auth-passwd.c"
int sys_auth_passwd(Authctxt *authctxt___0 , char const   *password ) ;
#line 50 "auth-passwd.c"
void disable_forwarding(void) 
{ 

  {
#line 53
  no_port_forwarding_flag = 1;
#line 54
  no_agent_forwarding_flag = 1;
#line 55
  no_x11_forwarding_flag = 1;
#line 56
  return;
}
}
#line 67 "auth-passwd.c"
static int expire_checked  =    0;
#line 62 "auth-passwd.c"
int auth_password(Authctxt *authctxt___0 , char const   *password ) 
{ struct passwd *pw ;
  int ok ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 65
  pw = authctxt___0->pw;
#line 66
  ok = authctxt___0->valid;
#line 70
  if (pw->pw_uid == 0U) {
#line 70
    if (options.permit_root_login != 3) {
#line 71
      ok = 0;
    }
  }
#line 73
  if ((int const   )*password == 0) {
#line 73
    if (options.permit_empty_passwd == 0) {
#line 74
      return (0);
    }
  }
#line 95
  if (! expire_checked) {
#line 96
    expire_checked = 1;
#line 97
    tmp = auth_shadow_pwexpired(authctxt___0);
#line 97
    if (tmp) {
#line 98
      disable_forwarding();
#line 99
      authctxt___0->force_pwchange = 1;
    }
  }
#line 104
  tmp___0 = sys_auth_passwd(authctxt___0, password);
#line 104
  if (tmp___0) {
#line 104
    if (ok) {
#line 104
      tmp___1 = 1;
    } else {
#line 104
      tmp___1 = 0;
    }
  } else {
#line 104
    tmp___1 = 0;
  }
#line 104
  return (tmp___1);
}
}
#line 126 "auth-passwd.c"
int sys_auth_passwd(Authctxt *authctxt___0 , char const   *password ) 
{ struct passwd *pw ;
  char *encrypted_password ;
  char *pw_password ;
  char *tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___16 ;
  int tmp___19 ;
  int tmp___20 ;
  char const   *tmp___21 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___27 ;
  int tmp___30 ;
  int tmp___31 ;

  {
#line 129
  pw = authctxt___0->pw;
#line 133
  if (authctxt___0->valid) {
#line 133
    tmp___0 = shadow_pw(pw);
  } else {
#line 133
    tmp___0 = pw->pw_passwd;
  }
#line 133
  pw_password = tmp___0;
#line 136
  if (0) {
#line 136
    __s1_len = strlen((char const   *)pw_password);
#line 136
    __s2_len = strlen("");
#line 136
    if (! ((unsigned int )((void const   *)(pw_password + 1)) - (unsigned int )((void const   *)pw_password) == 1U)) {
      goto _L___0;
    } else {
#line 136
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 136
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 136
          tmp___10 = 1;
        } else {
#line 136
          if (__s2_len >= 4U) {
#line 136
            tmp___10 = 1;
          } else {
#line 136
            tmp___10 = 0;
          }
        }
      } else {
#line 136
        tmp___10 = 0;
      }
    }
#line 136
    if (tmp___10) {
#line 136
      tmp___6 = __builtin_strcmp((char const   *)pw_password, "");
    } else {
#line 136
      tmp___9 = __builtin_strcmp((char const   *)pw_password, "");
#line 136
      tmp___6 = tmp___9;
    }
  } else {
#line 136
    tmp___9 = __builtin_strcmp((char const   *)pw_password, "");
#line 136
    tmp___6 = tmp___9;
  }
#line 136
  if (tmp___6 == 0) {
#line 136
    if (0) {
#line 136
      __s1_len___0 = strlen(password);
#line 136
      __s2_len___0 = strlen("");
#line 136
      if (! ((unsigned int )((void const   *)(password + 1)) - (unsigned int )((void const   *)password) == 1U)) {
        goto _L___2;
      } else {
#line 136
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 136
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 136
            tmp___20 = 1;
          } else {
#line 136
            if (__s2_len___0 >= 4U) {
#line 136
              tmp___20 = 1;
            } else {
#line 136
              tmp___20 = 0;
            }
          }
        } else {
#line 136
          tmp___20 = 0;
        }
      }
#line 136
      if (tmp___20) {
#line 136
        tmp___16 = __builtin_strcmp(password, "");
      } else {
#line 136
        tmp___19 = __builtin_strcmp(password, "");
#line 136
        tmp___16 = tmp___19;
      }
    } else {
#line 136
      tmp___19 = __builtin_strcmp(password, "");
#line 136
      tmp___16 = tmp___19;
    }
#line 136
    if (tmp___16 == 0) {
#line 137
      return (1);
    }
  }
#line 140
  if (*(pw_password + 0)) {
#line 140
    if (*(pw_password + 1)) {
#line 140
      tmp___21 = (char const   *)pw_password;
    } else {
#line 140
      tmp___21 = "xx";
    }
  } else {
#line 140
    tmp___21 = "xx";
  }
#line 140
  encrypted_password = xcrypt(password, tmp___21);
#line 147
  if (0) {
#line 147
    __s1_len___1 = strlen((char const   *)encrypted_password);
#line 147
    __s2_len___1 = strlen((char const   *)pw_password);
#line 147
    if (! ((unsigned int )((void const   *)(encrypted_password + 1)) - (unsigned int )((void const   *)encrypted_password) == 1U)) {
      goto _L___4;
    } else {
#line 147
      if (__s1_len___1 >= 4U) {
        _L___4: /* CIL Label */ 
#line 147
        if (! ((unsigned int )((void const   *)(pw_password + 1)) - (unsigned int )((void const   *)pw_password) == 1U)) {
#line 147
          tmp___31 = 1;
        } else {
#line 147
          if (__s2_len___1 >= 4U) {
#line 147
            tmp___31 = 1;
          } else {
#line 147
            tmp___31 = 0;
          }
        }
      } else {
#line 147
        tmp___31 = 0;
      }
    }
#line 147
    if (tmp___31) {
#line 147
      tmp___27 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)pw_password);
    } else {
#line 147
      tmp___30 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)pw_password);
#line 147
      tmp___27 = tmp___30;
    }
  } else {
#line 147
    tmp___30 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)pw_password);
#line 147
    tmp___27 = tmp___30;
  }
#line 147
  return (tmp___27 == 0);
}
}
#line 1 "auth-rsa.o"
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 32 "auth-options.h"
int auth_parse_options(struct passwd *pw , char *opts , char *file___0 , u_long linenum ) ;
#line 33
void auth_clear_options(void) ;
#line 109 "auth.h"
int auth_rsa(Authctxt *authctxt___0 , BIGNUM *client_n ) ;
#line 110
int auth_rsa_challenge_dialog(Key *key ) ;
#line 111
BIGNUM *auth_rsa_generate_challenge(Key *key ) ;
#line 112
int auth_rsa_verify_response(Key *key , BIGNUM *challenge , u_char *response ) ;
#line 113
int auth_rsa_key_allowed(struct passwd *pw , BIGNUM *client_n , Key **rkey ) ;
#line 161
char *authorized_keys_file(struct passwd *pw ) ;
#line 164
int secure_filename(FILE *f , char const   *file___0 , struct passwd *pw , char *err ,
                    size_t errlen ) ;
#line 55 "monitor_wrap.h"
int mm_auth_rsa_key_allowed(struct passwd *pw , BIGNUM *client_n , Key **rkey ) ;
#line 56
int mm_auth_rsa_verify_response(Key *key , BIGNUM *p , u_char *response ) ;
#line 57
BIGNUM *mm_auth_rsa_generate_challenge(Key *key ) ;
#line 57 "auth-rsa.c"
BIGNUM *auth_rsa_generate_challenge(Key *key ) 
{ BIGNUM *challenge ;
  BN_CTX *ctx ;

  {
#line 63
  challenge = BN_new();
#line 63
  if ((unsigned int )challenge == (unsigned int )((void *)0)) {
#line 64
    fatal("auth_rsa_generate_challenge: BN_new() failed");
  }
#line 66
  BN_rand(challenge, 256, 0, 0);
#line 67
  ctx = BN_CTX_new();
#line 67
  if ((unsigned int )ctx == (unsigned int )((void *)0)) {
#line 68
    fatal("auth_rsa_generate_challenge: BN_CTX_new() failed");
  }
#line 69
  BN_div((BIGNUM *)((void *)0), challenge, (BIGNUM const   *)challenge, (BIGNUM const   *)(key->rsa)->n,
         ctx);
#line 70
  BN_CTX_free(ctx);
#line 72
  return (challenge);
}
}
#line 75 "auth-rsa.c"
int auth_rsa_verify_response(Key *key , BIGNUM *challenge , u_char *response ) 
{ u_char buf___1[32] ;
  u_char mdbuf[16] ;
  MD5_CTX md ;
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 83
  tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 83
  if (tmp___0 < 768) {
#line 84
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 84
    error("auth_rsa_verify_response: RSA modulus too small: %d < minimum %d bits",
          tmp, 768);
#line 86
    return (0);
  }
#line 90
  tmp___1 = BN_num_bits((BIGNUM const   *)challenge);
#line 90
  len = (tmp___1 + 7) / 8;
#line 91
  if (len <= 0) {
#line 92
    fatal("auth_rsa_verify_response: bad challenge length %d", len);
  } else {
#line 91
    if (len > 32) {
#line 92
      fatal("auth_rsa_verify_response: bad challenge length %d", len);
    }
  }
#line 93
  memset((void *)(buf___1), 0, 32U);
#line 94
  BN_bn2bin((BIGNUM const   *)challenge, (buf___1 + 32) - len);
#line 95
  MD5_Init(& md);
#line 96
  MD5_Update(& md, (void const   *)(buf___1), 32U);
#line 97
  MD5_Update(& md, (void const   *)(session_id), 16U);
#line 98
  MD5_Final(mdbuf, & md);
#line 101
  tmp___2 = memcmp((void const   *)response, (void const   *)(mdbuf), 16U);
#line 101
  if (tmp___2 != 0) {
#line 103
    return (0);
  }
#line 106
  return (1);
}
}
#line 115 "auth-rsa.c"
int auth_rsa_challenge_dialog(Key *key ) 
{ BIGNUM *challenge ;
  BIGNUM *encrypted_challenge ;
  u_char response[16] ;
  int i ;
  int success ;
  u_int tmp___1 ;
  int _len ;
  int tmp___2 ;

  {
#line 122
  encrypted_challenge = BN_new();
#line 122
  if ((unsigned int )encrypted_challenge == (unsigned int )((void *)0)) {
#line 123
    fatal("auth_rsa_challenge_dialog: BN_new() failed");
  }
#line 125
  if (use_privsep) {
#line 125
    challenge = mm_auth_rsa_generate_challenge(key);
  } else {
#line 125
    challenge = auth_rsa_generate_challenge(key);
  }
#line 128
  rsa_public_encrypt(encrypted_challenge, challenge, key->rsa);
#line 131
  packet_start((unsigned char)7);
#line 132
  packet_put_bignum(encrypted_challenge);
#line 133
  packet_send();
#line 134
  BN_clear_free(encrypted_challenge);
#line 135
  packet_write_wait();
#line 138
  packet_read_expect(8);
#line 139
  i = 0;
#line 139
  while (i < 16) {
#line 140
    tmp___1 = packet_get_char();
#line 140
    response[i] = (unsigned char )tmp___1;
#line 139
    i ++;
  }
#line 141
  while (1) {
#line 141
    tmp___2 = packet_remaining();
#line 141
    _len = tmp___2;
#line 141
    if (_len > 0) {
#line 141
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth-rsa.c",
            141);
#line 141
      packet_disconnect("Packet integrity error.");
    }
#line 141
    break;
  }
#line 143
  if (use_privsep) {
#line 143
    success = mm_auth_rsa_verify_response(key, challenge, response);
  } else {
#line 143
    success = auth_rsa_verify_response(key, challenge, (u_char *)(response));
  }
#line 144
  BN_clear_free(challenge);
#line 145
  return (success);
}
}
#line 153 "auth-rsa.c"
int auth_rsa_key_allowed(struct passwd *pw , BIGNUM *client_n , Key **rkey ) 
{ char line[8192] ;
  char *file___0 ;
  int allowed ;
  u_int bits ;
  FILE *f ;
  u_long linenum ;
  struct stat st ;
  Key *key ;
  int tmp ;
  int tmp___0 ;
  char *cp ;
  char *options___0 ;
  int quoted ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
#line 157
  allowed = 0;
#line 160
  linenum = (u_long )0;
#line 165
  temporarily_use_uid(pw);
#line 168
  file___0 = authorized_keys_file(pw);
#line 169
  debug("trying public RSA key file %s", file___0);
#line 172
  tmp = stat((char const   * __restrict  )file___0, (struct stat * __restrict  )(& st));
#line 172
  if (tmp < 0) {
#line 174
    restore_uid();
#line 175
    xfree((void *)file___0);
#line 176
    return (0);
  }
#line 179
  f = fopen((char const   * __restrict  )file___0, (char const   * __restrict  )"r");
#line 180
  if (! f) {
#line 182
    restore_uid();
#line 183
    xfree((void *)file___0);
#line 184
    return (0);
  }
#line 186
  if (options.strict_modes) {
#line 186
    tmp___0 = secure_filename(f, (char const   *)file___0, pw, line, sizeof(line));
#line 186
    if (tmp___0 != 0) {
#line 188
      xfree((void *)file___0);
#line 189
      fclose(f);
#line 190
      logit("Authentication refused: %s", line);
#line 191
      restore_uid();
#line 192
      return (0);
    }
  }
#line 196
  allowed = 0;
#line 198
  key = key_new(0);
#line 205
  while (1) {
#line 205
    tmp___6 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 205
    if (! tmp___6) {
#line 205
      break;
    }
#line 209
    linenum ++;
#line 212
    cp = line;
#line 212
    while (1) {
#line 212
      if (! ((int )*cp == 32)) {
#line 212
        if (! ((int )*cp == 9)) {
#line 212
          break;
        }
      }
#line 212
      cp ++;
    }
#line 214
    if (! *cp) {
#line 215
      continue;
    } else {
#line 214
      if ((int )*cp == 10) {
#line 215
        continue;
      } else {
#line 214
        if ((int )*cp == 35) {
#line 215
          continue;
        }
      }
    }
#line 223
    if ((int )*cp < 48) {
      goto _L___0;
    } else {
#line 223
      if ((int )*cp > 57) {
        _L___0: /* CIL Label */ 
#line 224
        quoted = 0;
#line 225
        options___0 = cp;
#line 226
        while (1) {
#line 226
          if (*cp) {
#line 226
            if (! quoted) {
#line 226
              if ((int )*cp != 32) {
#line 226
                if (! ((int )*cp != 9)) {
#line 226
                  break;
                }
              } else {
#line 226
                break;
              }
            }
          } else {
#line 226
            break;
          }
#line 227
          if ((int )*cp == 92) {
#line 227
            if ((int )*(cp + 1) == 34) {
#line 228
              cp ++;
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 229
            if ((int )*cp == 34) {
#line 230
              quoted = ! quoted;
            }
          }
#line 226
          cp ++;
        }
      } else {
#line 233
        options___0 = (char *)((void *)0);
      }
    }
#line 236
    tmp___1 = hostfile_read_key(& cp, & bits, key);
#line 236
    if (tmp___1 == 0) {
#line 237
      debug("%.100s, line %lu: non ssh1 key syntax", file___0, linenum);
#line 239
      continue;
    }
#line 244
    tmp___2 = BN_cmp((BIGNUM const   *)(key->rsa)->n, (BIGNUM const   *)client_n);
#line 244
    if (tmp___2 != 0) {
#line 245
      continue;
    }
#line 248
    tmp___4 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 248
    if (bits != (u_int )tmp___4) {
#line 249
      tmp___3 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 249
      logit("Warning: %s, line %lu: keysize mismatch: actual %d vs. announced %d.",
            file___0, linenum, tmp___3, bits);
    }
#line 258
    tmp___5 = auth_parse_options(pw, options___0, file___0, linenum);
#line 258
    if (! tmp___5) {
#line 259
      continue;
    }
#line 262
    allowed = 1;
#line 263
    break;
  }
#line 267
  restore_uid();
#line 270
  xfree((void *)file___0);
#line 271
  fclose(f);
#line 274
  if (allowed) {
#line 274
    if ((unsigned int )rkey != (unsigned int )((void *)0)) {
#line 275
      *rkey = key;
    } else {
#line 277
      key_free(key);
    }
  } else {
#line 277
    key_free(key);
  }
#line 278
  return (allowed);
}
}
#line 286 "auth-rsa.c"
int auth_rsa(Authctxt *authctxt___0 , BIGNUM *client_n ) 
{ Key *key ;
  char *fp ;
  struct passwd *pw ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;

  {
#line 291
  pw = authctxt___0->pw;
#line 294
  if (! authctxt___0->valid) {
#line 295
    return (0);
  }
#line 297
  if (use_privsep) {
#line 297
    tmp___1 = mm_auth_rsa_key_allowed(pw, client_n, & key);
  } else {
#line 297
    tmp___1 = auth_rsa_key_allowed(pw, client_n, & key);
  }
#line 297
  if (! tmp___1) {
#line 298
    auth_clear_options();
#line 299
    return (0);
  }
#line 303
  tmp___2 = auth_rsa_challenge_dialog(key);
#line 303
  if (! tmp___2) {
#line 305
    verbose("Wrong response to RSA authentication challenge.");
#line 306
    packet_send_debug("Wrong response to RSA authentication challenge.");
#line 311
    key_free(key);
#line 312
    return (0);
  }
#line 320
  fp = key_fingerprint((Key const   *)key, 1, 0);
#line 321
  tmp___3 = key_type((Key const   *)key);
#line 321
  verbose("Found matching %s key: %s", tmp___3, fp);
#line 323
  xfree((void *)fp);
#line 324
  key_free(key);
#line 326
  packet_send_debug("RSA authentication accepted.");
#line 327
  return (1);
}
}
#line 1 "auth-rh-rsa.o"
#line 107 "auth.h"
int auth_rhosts_rsa(Authctxt *authctxt___0 , char *cuser , Key *client_host_key ) ;
#line 115
int auth_rhosts_rsa_key_allowed(struct passwd *pw , char *cuser , char *chost , Key *client_host_key ) ;
#line 167
HostStatus check_key_in_hostfiles(struct passwd *pw , Key *key , char const   *host ,
                                  char const   *sysfile , char const   *userfile ) ;
#line 53 "monitor_wrap.h"
int mm_auth_rhosts_rsa_key_allowed(struct passwd *pw , char *user , char *host , Key *key ) ;
#line 33 "auth-rh-rsa.c"
int auth_rhosts_rsa_key_allowed(struct passwd *pw , char *cuser , char *chost , Key *client_host_key ) 
{ HostStatus host_status ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 40
  tmp = auth_rhosts(pw, (char const   *)cuser);
#line 40
  if (! tmp) {
#line 41
    return (0);
  }
#line 43
  if (options.ignore_user_known_hosts) {
#line 43
    tmp___0 = (char const   *)((void *)0);
  } else {
#line 43
    tmp___0 = "~/.ssh/known_hosts";
  }
#line 43
  host_status = check_key_in_hostfiles(pw, client_host_key, (char const   *)chost,
                                       "/usr/local/etc/ssh_known_hosts", tmp___0);
#line 47
  return ((int )host_status == 0);
}
}
#line 54 "auth-rh-rsa.c"
int auth_rhosts_rsa(Authctxt *authctxt___0 , char *cuser , Key *client_host_key ) 
{ char *chost ;
  struct passwd *pw ;
  char const   *tmp ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 58
  pw = authctxt___0->pw;
#line 60
  debug("Trying rhosts with RSA host authentication for client user %.100s", cuser);
#line 63
  if (! authctxt___0->valid) {
#line 65
    return (0);
  } else {
#line 63
    if ((unsigned int )client_host_key == (unsigned int )((void *)0)) {
#line 65
      return (0);
    } else {
#line 63
      if ((unsigned int )client_host_key->rsa == (unsigned int )((void *)0)) {
#line 65
        return (0);
      }
    }
  }
#line 67
  tmp = get_canonical_hostname(options.use_dns);
#line 67
  chost = (char *)tmp;
#line 68
  debug("Rhosts RSA authentication: canonical host %.900s", chost);
#line 70
  if (use_privsep) {
#line 70
    tmp___2 = mm_auth_rhosts_rsa_key_allowed(pw, cuser, chost, client_host_key);
  } else {
#line 70
    tmp___2 = auth_rhosts_rsa_key_allowed(pw, cuser, chost, client_host_key);
  }
#line 70
  if (! tmp___2) {
#line 71
    debug("Rhosts with RSA host authentication denied: unknown or invalid host key");
#line 72
    packet_send_debug("Your host key cannot be verified: unknown or invalid host key.");
#line 73
    return (0);
  }
#line 78
  tmp___3 = auth_rsa_challenge_dialog(client_host_key);
#line 78
  if (! tmp___3) {
#line 79
    logit("Client on %.800s failed to respond correctly to host authentication.",
          chost);
#line 81
    return (0);
  }
#line 88
  verbose("Rhosts with RSA host authentication accepted for %.100s, %.100s on %.700s.",
          pw->pw_name, cuser, chost);
#line 90
  packet_send_debug("Rhosts with RSA host authentication accepted.");
#line 91
  return (1);
}
}
#line 1 "sshpty.o"
#line 109 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 433 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group )  __attribute__((__nonnull__(1))) ;
#line 736
extern  __attribute__((__nothrow__)) char *ttyname(int __fd ) ;
#line 872
extern  __attribute__((__nothrow__)) int vhangup(void) ;
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 280
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 20 "sshpty.h"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) ;
#line 21
void pty_release(char const   *ttyname___0 ) ;
#line 22
void pty_make_controlling_tty(int *ttyfd , char const   *ttyname___0 ) ;
#line 23
void pty_change_window_size(int ptyfd , int row , int col , int xpixel , int ypixel ) ;
#line 24
void pty_setowner(struct passwd *pw , char const   *ttyname___0 ) ;
#line 34 "/usr/include/pty.h"
extern  __attribute__((__nothrow__)) int openpty(int *__amaster , int *__aslave ,
                                                 char *__name , struct termios *__termp ,
                                                 struct winsize *__winp ) ;
#line 40 "sshpty.c"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) 
{ char *name ;
  int i ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 47
  i = openpty(ptyfd, ttyfd, (char *)((void *)0), (struct termios *)((void *)0), (struct winsize *)((void *)0));
#line 48
  if (i < 0) {
#line 49
    tmp = __errno_location();
#line 49
    tmp___0 = strerror(*tmp);
#line 49
    error("openpty: %.100s", tmp___0);
#line 50
    return (0);
  }
#line 52
  name = ttyname(*ttyfd);
#line 53
  if (! name) {
#line 54
    fatal("openpty returns device for which ttyname fails.");
  }
#line 56
  strlcpy(namebuf, (char const   *)name, (unsigned int )namebuflen);
#line 57
  return (1);
}
}
#line 62 "sshpty.c"
void pty_release(char const   *ttyname___0 ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 65
  tmp___1 = chown(ttyname___0, 0U, 0U);
#line 65
  if (tmp___1 < 0) {
#line 66
    tmp = __errno_location();
#line 66
    tmp___0 = strerror(*tmp);
#line 66
    error("chown %.100s 0 0 failed: %.100s", ttyname___0, tmp___0);
  }
#line 67
  tmp___4 = chmod(ttyname___0, 438U);
#line 67
  if (tmp___4 < 0) {
#line 68
    tmp___2 = __errno_location();
#line 68
    tmp___3 = strerror(*tmp___2);
#line 68
    error("chmod %.100s 0666 failed: %.100s", ttyname___0, tmp___3);
  }
#line 69
  return;
}
}
#line 73 "sshpty.c"
void pty_make_controlling_tty(int *ttyfd , char const   *ttyname___0 ) 
{ int fd ;
  void *old ;
  int *tmp ;
  char *tmp___0 ;
  __pid_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  mysig_t tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;

  {
#line 107
  fd = open("/dev/tty", 258);
#line 108
  if (fd >= 0) {
#line 109
    ioctl(fd, 21538UL, (void *)0);
#line 110
    close(fd);
  }
#line 113
  tmp___1 = setsid();
#line 113
  if (tmp___1 < 0) {
#line 114
    tmp = __errno_location();
#line 114
    tmp___0 = strerror(*tmp);
#line 114
    error("setsid: %.100s", tmp___0);
  }
#line 120
  fd = open("/dev/tty", 258);
#line 121
  if (fd >= 0) {
#line 122
    error("Failed to disconnect from controlling tty.");
#line 123
    close(fd);
  }
#line 127
  debug("Setting controlling tty using TIOCSCTTY.");
#line 128
  tmp___4 = ioctl(*ttyfd, 21518UL, (void *)0);
#line 128
  if (tmp___4 < 0) {
#line 129
    tmp___2 = __errno_location();
#line 129
    tmp___3 = strerror(*tmp___2);
#line 129
    error("ioctl(TIOCSCTTY): %.100s", tmp___3);
  }
#line 136
  tmp___5 = mysignal(1, (void (*)(int  ))1);
#line 136
  old = (void *)tmp___5;
#line 137
  vhangup();
#line 138
  mysignal(1, (void (*)(int  ))old);
#line 140
  fd = open(ttyname___0, 2);
#line 141
  if (fd < 0) {
#line 142
    tmp___6 = __errno_location();
#line 142
    tmp___7 = strerror(*tmp___6);
#line 142
    error("%.100s: %.100s", ttyname___0, tmp___7);
  } else {
#line 145
    close(*ttyfd);
#line 146
    *ttyfd = fd;
  }
#line 152
  fd = open("/dev/tty", 1);
#line 153
  if (fd < 0) {
#line 154
    tmp___8 = __errno_location();
#line 154
    tmp___9 = strerror(*tmp___8);
#line 154
    error("open /dev/tty failed - could not set controlling tty: %.100s", tmp___9);
  } else {
#line 157
    close(fd);
  }
#line 159
  return;
}
}
#line 163 "sshpty.c"
void pty_change_window_size(int ptyfd , int row , int col , int xpixel , int ypixel ) 
{ struct winsize w ;

  {
#line 169
  w.ws_row = (unsigned short )row;
#line 170
  w.ws_col = (unsigned short )col;
#line 171
  w.ws_xpixel = (unsigned short )xpixel;
#line 172
  w.ws_ypixel = (unsigned short )ypixel;
#line 173
  ioctl(ptyfd, 21524UL, & w);
#line 174
  return;
}
}
#line 176 "sshpty.c"
void pty_setowner(struct passwd *pw , char const   *ttyname___0 ) 
{ struct group *grp ;
  gid_t gid ;
  mode_t mode ;
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;

  {
#line 185
  grp = getgrnam("tty");
#line 186
  if (grp) {
#line 187
    gid = grp->gr_gid;
#line 188
    mode = (unsigned int )(384 | (128 >> 3));
  } else {
#line 190
    gid = pw->pw_gid;
#line 191
    mode = (unsigned int )((384 | (128 >> 3)) | ((128 >> 3) >> 3));
  }
#line 199
  tmp___1 = stat((char const   * __restrict  )ttyname___0, (struct stat * __restrict  )(& st));
#line 199
  if (tmp___1) {
#line 200
    tmp = __errno_location();
#line 200
    tmp___0 = strerror(*tmp);
#line 200
    fatal("stat(%.100s) failed: %.100s", ttyname___0, tmp___0);
  }
#line 203
  if (st.st_uid != pw->pw_uid) {
    goto _L;
  } else {
#line 203
    if (st.st_gid != gid) {
      _L: /* CIL Label */ 
#line 204
      tmp___7 = chown(ttyname___0, pw->pw_uid, gid);
#line 204
      if (tmp___7 < 0) {
#line 205
        tmp___6 = __errno_location();
#line 205
        if (*tmp___6 == 30) {
#line 205
          if (st.st_uid == pw->pw_uid) {
#line 207
            tmp___2 = __errno_location();
#line 207
            tmp___3 = strerror(*tmp___2);
#line 207
            debug("chown(%.100s, %u, %u) failed: %.100s", ttyname___0, pw->pw_uid,
                  gid, tmp___3);
          } else {
#line 205
            if (st.st_uid == 0U) {
#line 207
              tmp___2 = __errno_location();
#line 207
              tmp___3 = strerror(*tmp___2);
#line 207
              debug("chown(%.100s, %u, %u) failed: %.100s", ttyname___0, pw->pw_uid,
                    gid, tmp___3);
            } else {
#line 211
              tmp___4 = __errno_location();
#line 211
              tmp___5 = strerror(*tmp___4);
#line 211
              fatal("chown(%.100s, %u, %u) failed: %.100s", ttyname___0, pw->pw_uid,
                    gid, tmp___5);
            }
          }
        } else {
#line 211
          tmp___4 = __errno_location();
#line 211
          tmp___5 = strerror(*tmp___4);
#line 211
          fatal("chown(%.100s, %u, %u) failed: %.100s", ttyname___0, pw->pw_uid, gid,
                tmp___5);
        }
      }
    }
  }
#line 217
  if ((st.st_mode & (unsigned int )((448 | (448 >> 3)) | ((448 >> 3) >> 3))) != mode) {
#line 218
    tmp___13 = chmod(ttyname___0, mode);
#line 218
    if (tmp___13 < 0) {
#line 219
      tmp___12 = __errno_location();
#line 219
      if (*tmp___12 == 30) {
#line 219
        if ((st.st_mode & (unsigned int )((256 >> 3) | ((256 >> 3) >> 3))) == 0U) {
#line 221
          tmp___8 = __errno_location();
#line 221
          tmp___9 = strerror(*tmp___8);
#line 221
          debug("chmod(%.100s, 0%o) failed: %.100s", ttyname___0, mode, tmp___9);
        } else {
#line 224
          tmp___10 = __errno_location();
#line 224
          tmp___11 = strerror(*tmp___10);
#line 224
          fatal("chmod(%.100s, 0%o) failed: %.100s", ttyname___0, mode, tmp___11);
        }
      } else {
#line 224
        tmp___10 = __errno_location();
#line 224
        tmp___11 = strerror(*tmp___10);
#line 224
        fatal("chmod(%.100s, 0%o) failed: %.100s", ttyname___0, mode, tmp___11);
      }
    }
  }
#line 228
  return;
}
}
#line 1 "sshlogin.o"
#line 95 "loginrec.h"
struct logininfo *login_alloc_entry(int pid , char const   *username , char const   *hostname ,
                                    char const   *line ) ;
#line 98
void login_free_entry(struct logininfo *li ) ;
#line 106
int login_login(struct logininfo *li ) ;
#line 107
int login_logout(struct logininfo *li ) ;
#line 119
void login_set_addr(struct logininfo *li , struct sockaddr  const  *sa , unsigned int sa_size ) ;
#line 126
struct logininfo *login_get_lastlog(struct logininfo *li , int uid ) ;
#line 51 "sshlogin.c"
u_long get_last_login_time(uid_t uid , char const   *logname , char *buf___1 , u_int bufsize ) 
{ struct logininfo li ;

  {
#line 57
  login_get_lastlog(& li, (int )uid);
#line 58
  strlcpy(buf___1, (char const   *)(li.hostname), bufsize);
#line 59
  return ((unsigned long )li.tv_sec);
}
}
#line 66 "sshlogin.c"
void record_login(pid_t pid , char const   *ttyname___0 , char const   *user , uid_t uid ,
                  char const   *host , struct sockaddr *addr , socklen_t addrlen ) 
{ struct logininfo *li ;

  {
#line 72
  li = login_alloc_entry(pid, user, host, ttyname___0);
#line 73
  login_set_addr(li, (struct sockaddr  const  *)addr, addrlen);
#line 74
  login_login(li);
#line 75
  login_free_entry(li);
#line 76
  return;
}
}
#line 93 "sshlogin.c"
void record_logout(pid_t pid , char const   *ttyname___0 , char const   *user ) 
{ struct logininfo *li ;

  {
#line 98
  li = login_alloc_entry(pid, user, (char const   *)((void *)0), ttyname___0);
#line 99
  login_logout(li);
#line 100
  login_free_entry(li);
#line 101
  return;
}
}
#line 1 "servconf.o"
#line 747 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 27 "servconf.c"
static void add_listen_addr(ServerOptions *options___0 , char *addr , u_short port ) ;
#line 28
static void add_one_listen_addr(ServerOptions *options___0 , char *addr , u_short port ) ;
#line 37 "servconf.c"
void initialize_server_options(ServerOptions *options___0 ) 
{ 

  {
#line 40
  memset((void *)options___0, 0, sizeof(*options___0));
#line 43
  options___0->use_pam = -1;
#line 46
  options___0->num_ports = 0U;
#line 47
  options___0->ports_from_cmdline = 0U;
#line 48
  options___0->listen_addrs = (struct addrinfo *)((void *)0);
#line 49
  options___0->num_host_key_files = 0;
#line 50
  options___0->pid_file = (char *)((void *)0);
#line 51
  options___0->server_key_bits = -1;
#line 52
  options___0->login_grace_time = -1;
#line 53
  options___0->key_regeneration_time = -1;
#line 54
  options___0->permit_root_login = -1;
#line 55
  options___0->ignore_rhosts = -1;
#line 56
  options___0->ignore_user_known_hosts = -1;
#line 57
  options___0->print_motd = -1;
#line 58
  options___0->print_lastlog = -1;
#line 59
  options___0->x11_forwarding = -1;
#line 60
  options___0->x11_display_offset = -1;
#line 61
  options___0->x11_use_localhost = -1;
#line 62
  options___0->xauth_location = (char *)((void *)0);
#line 63
  options___0->strict_modes = -1;
#line 64
  options___0->tcp_keep_alive = -1;
#line 65
  options___0->log_facility = -1;
#line 66
  options___0->log_level = -1;
#line 67
  options___0->rhosts_rsa_authentication = -1;
#line 68
  options___0->hostbased_authentication = -1;
#line 69
  options___0->hostbased_uses_name_from_packet_only = -1;
#line 70
  options___0->rsa_authentication = -1;
#line 71
  options___0->pubkey_authentication = -1;
#line 72
  options___0->kerberos_authentication = -1;
#line 73
  options___0->kerberos_or_local_passwd = -1;
#line 74
  options___0->kerberos_ticket_cleanup = -1;
#line 75
  options___0->kerberos_get_afs_token = -1;
#line 76
  options___0->gss_authentication = -1;
#line 77
  options___0->gss_cleanup_creds = -1;
#line 78
  options___0->password_authentication = -1;
#line 79
  options___0->kbd_interactive_authentication = -1;
#line 80
  options___0->challenge_response_authentication = -1;
#line 81
  options___0->permit_empty_passwd = -1;
#line 82
  options___0->permit_user_env = -1;
#line 83
  options___0->use_login = -1;
#line 84
  options___0->compression = -1;
#line 85
  options___0->allow_tcp_forwarding = -1;
#line 86
  options___0->num_allow_users = 0U;
#line 87
  options___0->num_deny_users = 0U;
#line 88
  options___0->num_allow_groups = 0U;
#line 89
  options___0->num_deny_groups = 0U;
#line 90
  options___0->ciphers = (char *)((void *)0);
#line 91
  options___0->macs = (char *)((void *)0);
#line 92
  options___0->protocol = 0;
#line 93
  options___0->gateway_ports = -1;
#line 94
  options___0->num_subsystems = 0U;
#line 95
  options___0->max_startups_begin = -1;
#line 96
  options___0->max_startups_rate = -1;
#line 97
  options___0->max_startups = -1;
#line 98
  options___0->banner = (char *)((void *)0);
#line 99
  options___0->use_dns = -1;
#line 100
  options___0->client_alive_interval = -1;
#line 101
  options___0->client_alive_count_max = -1;
#line 102
  options___0->authorized_keys_file = (char *)((void *)0);
#line 103
  options___0->authorized_keys_file2 = (char *)((void *)0);
#line 106
  use_privsep = -1;
#line 107
  return;
}
}
#line 109 "servconf.c"
void fill_default_server_options(ServerOptions *options___0 ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  u_int tmp___2 ;

  {
#line 113
  if (options___0->use_pam == -1) {
#line 114
    options___0->use_pam = 0;
  }
#line 117
  if (options___0->protocol == 0) {
#line 118
    options___0->protocol = 5;
  }
#line 119
  if (options___0->num_host_key_files == 0) {
#line 121
    if (options___0->protocol & 1) {
#line 122
      tmp = options___0->num_host_key_files;
#line 122
      (options___0->num_host_key_files) ++;
#line 122
      options___0->host_key_files[tmp] = (char *)"/usr/local/etc/ssh_host_key";
    }
#line 124
    if (options___0->protocol & 4) {
#line 125
      tmp___0 = options___0->num_host_key_files;
#line 125
      (options___0->num_host_key_files) ++;
#line 125
      options___0->host_key_files[tmp___0] = (char *)"/usr/local/etc/ssh_host_rsa_key";
#line 127
      tmp___1 = options___0->num_host_key_files;
#line 127
      (options___0->num_host_key_files) ++;
#line 127
      options___0->host_key_files[tmp___1] = (char *)"/usr/local/etc/ssh_host_dsa_key";
    }
  }
#line 131
  if (options___0->num_ports == 0U) {
#line 132
    tmp___2 = options___0->num_ports;
#line 132
    (options___0->num_ports) ++;
#line 132
    options___0->ports[tmp___2] = (unsigned short)22;
  }
#line 133
  if ((unsigned int )options___0->listen_addrs == (unsigned int )((void *)0)) {
#line 134
    add_listen_addr(options___0, (char *)((void *)0), (unsigned short)0);
  }
#line 135
  if ((unsigned int )options___0->pid_file == (unsigned int )((void *)0)) {
#line 136
    options___0->pid_file = (char *)"/var/run/sshd.pid";
  }
#line 137
  if (options___0->server_key_bits == -1) {
#line 138
    options___0->server_key_bits = 768;
  }
#line 139
  if (options___0->login_grace_time == -1) {
#line 140
    options___0->login_grace_time = 120;
  }
#line 141
  if (options___0->key_regeneration_time == -1) {
#line 142
    options___0->key_regeneration_time = 3600;
  }
#line 143
  if (options___0->permit_root_login == -1) {
#line 144
    options___0->permit_root_login = 3;
  }
#line 145
  if (options___0->ignore_rhosts == -1) {
#line 146
    options___0->ignore_rhosts = 1;
  }
#line 147
  if (options___0->ignore_user_known_hosts == -1) {
#line 148
    options___0->ignore_user_known_hosts = 0;
  }
#line 149
  if (options___0->print_motd == -1) {
#line 150
    options___0->print_motd = 1;
  }
#line 151
  if (options___0->print_lastlog == -1) {
#line 152
    options___0->print_lastlog = 1;
  }
#line 153
  if (options___0->x11_forwarding == -1) {
#line 154
    options___0->x11_forwarding = 0;
  }
#line 155
  if (options___0->x11_display_offset == -1) {
#line 156
    options___0->x11_display_offset = 10;
  }
#line 157
  if (options___0->x11_use_localhost == -1) {
#line 158
    options___0->x11_use_localhost = 1;
  }
#line 159
  if ((unsigned int )options___0->xauth_location == (unsigned int )((void *)0)) {
#line 160
    options___0->xauth_location = (char *)"/usr/bin//xauth";
  }
#line 161
  if (options___0->strict_modes == -1) {
#line 162
    options___0->strict_modes = 1;
  }
#line 163
  if (options___0->tcp_keep_alive == -1) {
#line 164
    options___0->tcp_keep_alive = 1;
  }
#line 165
  if ((int )options___0->log_facility == -1) {
#line 166
    options___0->log_facility = 2;
  }
#line 167
  if ((int )options___0->log_level == -1) {
#line 168
    options___0->log_level = 3;
  }
#line 169
  if (options___0->rhosts_rsa_authentication == -1) {
#line 170
    options___0->rhosts_rsa_authentication = 0;
  }
#line 171
  if (options___0->hostbased_authentication == -1) {
#line 172
    options___0->hostbased_authentication = 0;
  }
#line 173
  if (options___0->hostbased_uses_name_from_packet_only == -1) {
#line 174
    options___0->hostbased_uses_name_from_packet_only = 0;
  }
#line 175
  if (options___0->rsa_authentication == -1) {
#line 176
    options___0->rsa_authentication = 1;
  }
#line 177
  if (options___0->pubkey_authentication == -1) {
#line 178
    options___0->pubkey_authentication = 1;
  }
#line 179
  if (options___0->kerberos_authentication == -1) {
#line 180
    options___0->kerberos_authentication = 0;
  }
#line 181
  if (options___0->kerberos_or_local_passwd == -1) {
#line 182
    options___0->kerberos_or_local_passwd = 1;
  }
#line 183
  if (options___0->kerberos_ticket_cleanup == -1) {
#line 184
    options___0->kerberos_ticket_cleanup = 1;
  }
#line 185
  if (options___0->kerberos_get_afs_token == -1) {
#line 186
    options___0->kerberos_get_afs_token = 0;
  }
#line 187
  if (options___0->gss_authentication == -1) {
#line 188
    options___0->gss_authentication = 0;
  }
#line 189
  if (options___0->gss_cleanup_creds == -1) {
#line 190
    options___0->gss_cleanup_creds = 1;
  }
#line 191
  if (options___0->password_authentication == -1) {
#line 192
    options___0->password_authentication = 1;
  }
#line 193
  if (options___0->kbd_interactive_authentication == -1) {
#line 194
    options___0->kbd_interactive_authentication = 0;
  }
#line 195
  if (options___0->challenge_response_authentication == -1) {
#line 196
    options___0->challenge_response_authentication = 1;
  }
#line 197
  if (options___0->permit_empty_passwd == -1) {
#line 198
    options___0->permit_empty_passwd = 0;
  }
#line 199
  if (options___0->permit_user_env == -1) {
#line 200
    options___0->permit_user_env = 0;
  }
#line 201
  if (options___0->use_login == -1) {
#line 202
    options___0->use_login = 0;
  }
#line 203
  if (options___0->compression == -1) {
#line 204
    options___0->compression = 1;
  }
#line 205
  if (options___0->allow_tcp_forwarding == -1) {
#line 206
    options___0->allow_tcp_forwarding = 1;
  }
#line 207
  if (options___0->gateway_ports == -1) {
#line 208
    options___0->gateway_ports = 0;
  }
#line 209
  if (options___0->max_startups == -1) {
#line 210
    options___0->max_startups = 10;
  }
#line 211
  if (options___0->max_startups_rate == -1) {
#line 212
    options___0->max_startups_rate = 100;
  }
#line 213
  if (options___0->max_startups_begin == -1) {
#line 214
    options___0->max_startups_begin = options___0->max_startups;
  }
#line 215
  if (options___0->use_dns == -1) {
#line 216
    options___0->use_dns = 1;
  }
#line 217
  if (options___0->client_alive_interval == -1) {
#line 218
    options___0->client_alive_interval = 0;
  }
#line 219
  if (options___0->client_alive_count_max == -1) {
#line 220
    options___0->client_alive_count_max = 3;
  }
#line 221
  if ((unsigned int )options___0->authorized_keys_file2 == (unsigned int )((void *)0)) {
#line 223
    if ((unsigned int )options___0->authorized_keys_file != (unsigned int )((void *)0)) {
#line 224
      options___0->authorized_keys_file2 = options___0->authorized_keys_file;
    } else {
#line 226
      options___0->authorized_keys_file2 = (char *)".ssh/authorized_keys2";
    }
  }
#line 228
  if ((unsigned int )options___0->authorized_keys_file == (unsigned int )((void *)0)) {
#line 229
    options___0->authorized_keys_file = (char *)".ssh/authorized_keys";
  }
#line 232
  if (use_privsep == -1) {
#line 233
    use_privsep = 1;
  }
#line 244
  return;
}
}
#line 275 "servconf.c"
static struct __anonstruct_keywords_79 keywords[69]  = 
#line 275
  {      {"usepam", 60}, 
        {"pamauthenticationviakbdint", 59}, 
        {"port", 2}, 
        {"hostkey", 3}, 
        {"hostdsakey", 3}, 
        {"pidfile", 42}, 
        {"serverkeybits", 4}, 
        {"logingracetime", 5}, 
        {"keyregenerationinterval", 6}, 
        {"permitrootlogin", 7}, 
        {"syslogfacility", 8}, 
        {"loglevel", 9}, 
        {"rhostsauthentication", 59}, 
        {"rhostsrsaauthentication", 10}, 
        {"hostbasedauthentication", 50}, 
        {"hostbasedusesnamefrompacketonly", 51}, 
        {"rsaauthentication", 11}, 
        {"pubkeyauthentication", 44}, 
        {"dsaauthentication", 44}, 
        {"kerberosauthentication", 60}, 
        {"kerberosorlocalpasswd", 60}, 
        {"kerberosticketcleanup", 60}, 
        {"kerberosgetafstoken", 60}, 
        {"kerberostgtpassing", 60}, 
        {"afstokenpassing", 60}, 
        {"gssapiauthentication", 60}, 
        {"gssapicleanupcredentials", 60}, 
        {"passwordauthentication", 18}, 
        {"kbdinteractiveauthentication", 19}, 
        {"challengeresponseauthentication", 17}, 
        {"skeyauthentication", 17}, 
        {"checkmail", 59}, 
        {"listenaddress", 20}, 
        {"printmotd", 21}, 
        {"printlastlog", 22}, 
        {"ignorerhosts", 23}, 
        {"ignoreuserknownhosts", 38}, 
        {"x11forwarding", 24}, 
        {"x11displayoffset", 25}, 
        {"x11uselocalhost", 26}, 
        {"xauthlocation", 45}, 
        {"strictmodes", 27}, 
        {"permitemptypasswords", 28}, 
        {"permituserenvironment", 30}, 
        {"uselogin", 31}, 
        {"compression", 33}, 
        {"tcpkeepalive", 29}, 
        {"keepalive", 29}, 
        {"allowtcpforwarding", 32}, 
        {"allowusers", 34}, 
        {"denyusers", 35}, 
        {"allowgroups", 36}, 
        {"denygroups", 37}, 
        {"ciphers", 39}, 
        {"macs", 40}, 
        {"protocol", 41}, 
        {"gatewayports", 43}, 
        {"subsystem", 46}, 
        {"maxstartups", 47}, 
        {"banner", 48}, 
        {"usedns", 49}, 
        {"verifyreversemapping", 59}, 
        {"reversemappingcheck", 59}, 
        {"clientaliveinterval", 52}, 
        {"clientalivecountmax", 53}, 
        {"authorizedkeysfile", 54}, 
        {"authorizedkeysfile2", 55}, 
        {"useprivilegeseparation", 58}, 
        {(char const   *)((void *)0), 0}};
#line 376 "servconf.c"
static ServerOpCodes parse_token(char const   *cp , char const   *filename , int linenum ) 
{ u_int i ;
  int tmp ;

  {
#line 382
  i = 0U;
#line 382
  while (keywords[i].name) {
#line 383
    tmp = strcasecmp(cp, keywords[i].name);
#line 383
    if (tmp == 0) {
#line 384
      return (keywords[i].opcode);
    }
#line 382
    i ++;
  }
#line 386
  error("%s: line %d: Bad configuration option: %s", filename, linenum, cp);
#line 388
  return (0);
}
}
#line 391 "servconf.c"
static void add_listen_addr(ServerOptions *options___0 , char *addr , u_short port ) 
{ int i ;
  u_int tmp ;

  {
#line 396
  if (options___0->num_ports == 0U) {
#line 397
    tmp = options___0->num_ports;
#line 397
    (options___0->num_ports) ++;
#line 397
    options___0->ports[tmp] = (unsigned short)22;
  }
#line 398
  if ((int )port == 0) {
#line 399
    i = 0;
#line 399
    while ((u_int )i < options___0->num_ports) {
#line 400
      add_one_listen_addr(options___0, addr, options___0->ports[i]);
#line 399
      i ++;
    }
  } else {
#line 402
    add_one_listen_addr(options___0, addr, port);
  }
#line 403
  return;
}
}
#line 405 "servconf.c"
static void add_one_listen_addr(ServerOptions *options___0 , char *addr , u_short port ) 
{ struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 412
  memset((void *)(& hints), 0, sizeof(hints));
#line 413
  hints.ai_family = IPv4or6;
#line 414
  hints.ai_socktype = 1;
#line 415
  if ((unsigned int )addr == (unsigned int )((void *)0)) {
#line 415
    hints.ai_flags = 1;
  } else {
#line 415
    hints.ai_flags = 0;
  }
#line 416
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%u",
           port);
#line 417
  gaierr = getaddrinfo((char const   * __restrict  )addr, (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 417
  if (gaierr != 0) {
#line 418
    tmp = gai_strerror(gaierr);
#line 418
    if (addr) {
#line 418
      tmp___0 = (char const   *)addr;
    } else {
#line 418
      tmp___0 = "<NULL>";
    }
#line 418
    fatal("bad addr or host: %s (%s)", tmp___0, tmp);
  }
#line 421
  ai = aitop;
#line 421
  while (ai->ai_next) {
#line 421
    ai = ai->ai_next;
  }
#line 423
  ai->ai_next = options___0->listen_addrs;
#line 424
  options___0->listen_addrs = aitop;
#line 425
  return;
}
}
#line 427 "servconf.c"
int process_server_config_line(ServerOptions *options___0 , char *line , char const   *filename ,
                               int linenum ) 
{ char *cp ;
  char **charptr ;
  char *arg ;
  char *p ;
  int *intptr ;
  int value ;
  int i ;
  int n___0 ;
  ServerOpCodes opcode ;
  u_int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___29 ;
  size_t tmp___30 ;
  char *tmp___32 ;
  char *tmp___34 ;
  u_short port ;
  int tmp___35 ;
  __uid_t tmp___36 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___42 ;
  int tmp___45 ;
  int tmp___46 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___52 ;
  int tmp___55 ;
  int tmp___56 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___62 ;
  int tmp___65 ;
  int tmp___66 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___72 ;
  int tmp___75 ;
  int tmp___76 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___82 ;
  int tmp___85 ;
  int tmp___86 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___92 ;
  int tmp___95 ;
  int tmp___96 ;
  SyslogFacility tmp___97 ;
  char const   *tmp___98 ;
  LogLevel tmp___99 ;
  char const   *tmp___100 ;
  u_int tmp___101 ;
  u_int tmp___102 ;
  u_int tmp___103 ;
  u_int tmp___104 ;
  char const   *tmp___105 ;
  int tmp___106 ;
  char const   *tmp___107 ;
  int tmp___108 ;
  char const   *tmp___109 ;
  size_t __s1_len___7 ;
  size_t __s2_len___7 ;
  int tmp___115 ;
  int tmp___118 ;
  int tmp___119 ;

  {
#line 435
  cp = line;
#line 436
  arg = strdelim(& cp);
#line 438
  if ((int )*arg == 0) {
#line 439
    arg = strdelim(& cp);
  }
#line 440
  if (! arg) {
#line 441
    return (0);
  } else {
#line 440
    if (! *arg) {
#line 441
      return (0);
    } else {
#line 440
      if ((int )*arg == 35) {
#line 441
        return (0);
      }
    }
  }
#line 442
  intptr = (int *)((void *)0);
#line 443
  charptr = (char **)((void *)0);
#line 444
  opcode = parse_token((char const   *)arg, filename, linenum);
#line 445
  switch ((int )opcode) {
  case 1: 
#line 448
  intptr = & options___0->use_pam;
  goto parse_flag;
  case 0: 
#line 453
  return (-1);
  case 2: 
#line 456
  if (options___0->ports_from_cmdline) {
#line 457
    return (0);
  }
#line 458
  if ((unsigned int )options___0->listen_addrs != (unsigned int )((void *)0)) {
#line 459
    fatal("%s line %d: ports must be specified before ListenAddress.", filename, linenum);
  }
#line 461
  if (options___0->num_ports >= 256U) {
#line 462
    fatal("%s line %d: too many ports.", filename, linenum);
  }
#line 464
  arg = strdelim(& cp);
#line 465
  if (! arg) {
#line 466
    fatal("%s line %d: missing port number.", filename, linenum);
  } else {
#line 465
    if ((int )*arg == 0) {
#line 466
      fatal("%s line %d: missing port number.", filename, linenum);
    }
  }
#line 468
  tmp = options___0->num_ports;
#line 468
  (options___0->num_ports) ++;
#line 468
  tmp___0 = a2port((char const   *)arg);
#line 468
  options___0->ports[tmp] = (unsigned short )tmp___0;
#line 469
  if ((int )options___0->ports[options___0->num_ports - 1U] == 0) {
#line 470
    fatal("%s line %d: Badly formatted port number.", filename, linenum);
  }
#line 472
  break;
  case 4: 
#line 475
  intptr = & options___0->server_key_bits;
  parse_int: 
#line 477
  arg = strdelim(& cp);
#line 478
  if (! arg) {
#line 479
    fatal("%s line %d: missing integer value.", filename, linenum);
  } else {
#line 478
    if ((int )*arg == 0) {
#line 479
      fatal("%s line %d: missing integer value.", filename, linenum);
    }
  }
#line 481
  value = atoi((char const   *)arg);
#line 482
  if (*intptr == -1) {
#line 483
    *intptr = value;
  }
#line 484
  break;
  case 5: 
#line 487
  intptr = & options___0->login_grace_time;
  parse_time: 
#line 489
  arg = strdelim(& cp);
#line 490
  if (! arg) {
#line 491
    fatal("%s line %d: missing time value.", filename, linenum);
  } else {
#line 490
    if ((int )*arg == 0) {
#line 491
      fatal("%s line %d: missing time value.", filename, linenum);
    }
  }
#line 493
  tmp___1 = convtime((char const   *)arg);
#line 493
  value = (int )tmp___1;
#line 493
  if (value == -1) {
#line 494
    fatal("%s line %d: invalid time value.", filename, linenum);
  }
#line 496
  if (*intptr == -1) {
#line 497
    *intptr = value;
  }
#line 498
  break;
  case 6: 
#line 501
  intptr = & options___0->key_regeneration_time;
  goto parse_time;
  case 20: 
#line 505
  arg = strdelim(& cp);
#line 506
  if (! arg) {
#line 507
    fatal("%s line %d: missing inet addr.", filename, linenum);
  } else {
#line 506
    if ((int )*arg == 0) {
#line 507
      fatal("%s line %d: missing inet addr.", filename, linenum);
    } else {
#line 506
      if (0) {
#line 506
        if (0) {
#line 506
          __s1_len___0 = strlen((char const   *)arg);
#line 506
          __s2_len___0 = strlen("[]");
#line 506
          if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
            goto _L___2;
          } else {
#line 506
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 506
              if (! ((unsigned int )((void const   *)("[]" + 1)) - (unsigned int )((void const   *)"[]") == 1U)) {
#line 506
                tmp___25 = 1;
              } else {
#line 506
                if (__s2_len___0 >= 4U) {
#line 506
                  tmp___25 = 1;
                } else {
#line 506
                  tmp___25 = 0;
                }
              }
            } else {
#line 506
              tmp___25 = 0;
            }
          }
#line 506
          if (tmp___25) {
#line 506
            tmp___21 = __builtin_strcmp((char const   *)arg, "[]");
          } else {
#line 506
            tmp___24 = __builtin_strcmp((char const   *)arg, "[]");
#line 506
            tmp___21 = tmp___24;
          }
        } else {
#line 506
          tmp___24 = __builtin_strcmp((char const   *)arg, "[]");
#line 506
          tmp___21 = tmp___24;
        }
#line 506
        tmp___15 = tmp___21;
      } else {
#line 506
        tmp___15 = strncmp((char const   *)arg, "[]", 2U);
      }
#line 506
      if (tmp___15 == 0) {
#line 507
        fatal("%s line %d: missing inet addr.", filename, linenum);
      }
    }
  }
#line 509
  if ((int )*arg == 91) {
#line 510
    tmp___29 = __builtin_strchr(arg, ']');
#line 510
    p = tmp___29;
#line 510
    if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 511
      fatal("%s line %d: bad ipv6 inet addr usage.", filename, linenum);
    }
#line 513
    arg ++;
#line 514
    tmp___30 = strlen((char const   *)(p + 1));
#line 514
    memmove((void *)p, (void const   *)(p + 1), tmp___30 + 1U);
  } else {
#line 515
    tmp___32 = __builtin_strchr(arg, ':');
#line 515
    p = tmp___32;
#line 515
    if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 517
      add_listen_addr(options___0, arg, (unsigned short)0);
#line 518
      break;
    } else {
#line 515
      tmp___34 = __builtin_strchr(p + 1, ':');
#line 515
      if ((unsigned int )tmp___34 != (unsigned int )((void *)0)) {
#line 517
        add_listen_addr(options___0, arg, (unsigned short)0);
#line 518
        break;
      }
    }
  }
#line 520
  if ((int )*p == 58) {
#line 523
    p ++;
#line 524
    if ((int )*p == 0) {
#line 525
      fatal("%s line %d: bad inet addr:port usage.", filename, linenum);
    } else {
#line 528
      *(p - 1) = (char )'\000';
#line 529
      tmp___35 = a2port((char const   *)p);
#line 529
      port = (unsigned short )tmp___35;
#line 529
      if ((int )port == 0) {
#line 530
        fatal("%s line %d: bad port number.", filename, linenum);
      }
#line 532
      add_listen_addr(options___0, arg, port);
    }
  } else {
#line 534
    if ((int )*p == 0) {
#line 535
      add_listen_addr(options___0, arg, (unsigned short)0);
    } else {
#line 537
      fatal("%s line %d: bad inet addr usage.", filename, linenum);
    }
  }
#line 539
  break;
  case 3: 
#line 542
  intptr = & options___0->num_host_key_files;
#line 543
  if (*intptr >= 256) {
#line 544
    fatal("%s line %d: too many host keys specified (max %d).", filename, linenum,
          256);
  }
#line 546
  charptr = & options___0->host_key_files[*intptr];
  parse_filename: 
#line 548
  arg = strdelim(& cp);
#line 549
  if (! arg) {
#line 550
    fatal("%s line %d: missing file name.", filename, linenum);
  } else {
#line 549
    if ((int )*arg == 0) {
#line 550
      fatal("%s line %d: missing file name.", filename, linenum);
    }
  }
#line 552
  if ((unsigned int )*charptr == (unsigned int )((void *)0)) {
#line 553
    tmp___36 = getuid();
#line 553
    *charptr = tilde_expand_filename((char const   *)arg, tmp___36);
#line 555
    if ((unsigned int )intptr != (unsigned int )((void *)0)) {
#line 556
      (*intptr) ++;
    }
  }
#line 558
  break;
  case 42: 
#line 561
  charptr = & options___0->pid_file;
  goto parse_filename;
  case 7: 
#line 565
  intptr = & options___0->permit_root_login;
#line 566
  arg = strdelim(& cp);
#line 567
  if (! arg) {
#line 568
    fatal("%s line %d: missing yes/without-password/forced-commands-only/no argument.",
          filename, linenum);
  } else {
#line 567
    if ((int )*arg == 0) {
#line 568
      fatal("%s line %d: missing yes/without-password/forced-commands-only/no argument.",
            filename, linenum);
    }
  }
#line 571
  value = 0;
#line 572
  if (0) {
#line 572
    __s1_len___4 = strlen((char const   *)arg);
#line 572
    __s2_len___4 = strlen("without-password");
#line 572
    if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
      goto _L___10;
    } else {
#line 572
      if (__s1_len___4 >= 4U) {
        _L___10: /* CIL Label */ 
#line 572
        if (! ((unsigned int )((void const   *)("without-password" + 1)) - (unsigned int )((void const   *)"without-password") == 1U)) {
#line 572
          tmp___76 = 1;
        } else {
#line 572
          if (__s2_len___4 >= 4U) {
#line 572
            tmp___76 = 1;
          } else {
#line 572
            tmp___76 = 0;
          }
        }
      } else {
#line 572
        tmp___76 = 0;
      }
    }
#line 572
    if (tmp___76) {
#line 572
      tmp___72 = __builtin_strcmp((char const   *)arg, "without-password");
    } else {
#line 572
      tmp___75 = __builtin_strcmp((char const   *)arg, "without-password");
#line 572
      tmp___72 = tmp___75;
    }
  } else {
#line 572
    tmp___75 = __builtin_strcmp((char const   *)arg, "without-password");
#line 572
    tmp___72 = tmp___75;
  }
#line 572
  if (tmp___72 == 0) {
#line 573
    value = 2;
  } else {
#line 574
    if (0) {
#line 574
      __s1_len___3 = strlen((char const   *)arg);
#line 574
      __s2_len___3 = strlen("forced-commands-only");
#line 574
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___8;
      } else {
#line 574
        if (__s1_len___3 >= 4U) {
          _L___8: /* CIL Label */ 
#line 574
          if (! ((unsigned int )((void const   *)("forced-commands-only" + 1)) - (unsigned int )((void const   *)"forced-commands-only") == 1U)) {
#line 574
            tmp___66 = 1;
          } else {
#line 574
            if (__s2_len___3 >= 4U) {
#line 574
              tmp___66 = 1;
            } else {
#line 574
              tmp___66 = 0;
            }
          }
        } else {
#line 574
          tmp___66 = 0;
        }
      }
#line 574
      if (tmp___66) {
#line 574
        tmp___62 = __builtin_strcmp((char const   *)arg, "forced-commands-only");
      } else {
#line 574
        tmp___65 = __builtin_strcmp((char const   *)arg, "forced-commands-only");
#line 574
        tmp___62 = tmp___65;
      }
    } else {
#line 574
      tmp___65 = __builtin_strcmp((char const   *)arg, "forced-commands-only");
#line 574
      tmp___62 = tmp___65;
    }
#line 574
    if (tmp___62 == 0) {
#line 575
      value = 1;
    } else {
#line 576
      if (0) {
#line 576
        __s1_len___2 = strlen((char const   *)arg);
#line 576
        __s2_len___2 = strlen("yes");
#line 576
        if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
          goto _L___6;
        } else {
#line 576
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 576
            if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 576
              tmp___56 = 1;
            } else {
#line 576
              if (__s2_len___2 >= 4U) {
#line 576
                tmp___56 = 1;
              } else {
#line 576
                tmp___56 = 0;
              }
            }
          } else {
#line 576
            tmp___56 = 0;
          }
        }
#line 576
        if (tmp___56) {
#line 576
          tmp___52 = __builtin_strcmp((char const   *)arg, "yes");
        } else {
#line 576
          tmp___55 = __builtin_strcmp((char const   *)arg, "yes");
#line 576
          tmp___52 = tmp___55;
        }
      } else {
#line 576
        tmp___55 = __builtin_strcmp((char const   *)arg, "yes");
#line 576
        tmp___52 = tmp___55;
      }
#line 576
      if (tmp___52 == 0) {
#line 577
        value = 3;
      } else {
#line 578
        if (0) {
#line 578
          __s1_len___1 = strlen((char const   *)arg);
#line 578
          __s2_len___1 = strlen("no");
#line 578
          if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
            goto _L___4;
          } else {
#line 578
            if (__s1_len___1 >= 4U) {
              _L___4: /* CIL Label */ 
#line 578
              if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 578
                tmp___46 = 1;
              } else {
#line 578
                if (__s2_len___1 >= 4U) {
#line 578
                  tmp___46 = 1;
                } else {
#line 578
                  tmp___46 = 0;
                }
              }
            } else {
#line 578
              tmp___46 = 0;
            }
          }
#line 578
          if (tmp___46) {
#line 578
            tmp___42 = __builtin_strcmp((char const   *)arg, "no");
          } else {
#line 578
            tmp___45 = __builtin_strcmp((char const   *)arg, "no");
#line 578
            tmp___42 = tmp___45;
          }
        } else {
#line 578
          tmp___45 = __builtin_strcmp((char const   *)arg, "no");
#line 578
          tmp___42 = tmp___45;
        }
#line 578
        if (tmp___42 == 0) {
#line 579
          value = 0;
        } else {
#line 581
          fatal("%s line %d: Bad yes/without-password/forced-commands-only/no argument: %s",
                filename, linenum, arg);
        }
      }
    }
  }
#line 584
  if (*intptr == -1) {
#line 585
    *intptr = value;
  }
#line 586
  break;
  case 23: 
#line 589
  intptr = & options___0->ignore_rhosts;
  parse_flag: 
#line 591
  arg = strdelim(& cp);
#line 592
  if (! arg) {
#line 593
    fatal("%s line %d: missing yes/no argument.", filename, linenum);
  } else {
#line 592
    if ((int )*arg == 0) {
#line 593
      fatal("%s line %d: missing yes/no argument.", filename, linenum);
    }
  }
#line 595
  value = 0;
#line 596
  if (0) {
#line 596
    __s1_len___6 = strlen((char const   *)arg);
#line 596
    __s2_len___6 = strlen("yes");
#line 596
    if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
      goto _L___14;
    } else {
#line 596
      if (__s1_len___6 >= 4U) {
        _L___14: /* CIL Label */ 
#line 596
        if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 596
          tmp___96 = 1;
        } else {
#line 596
          if (__s2_len___6 >= 4U) {
#line 596
            tmp___96 = 1;
          } else {
#line 596
            tmp___96 = 0;
          }
        }
      } else {
#line 596
        tmp___96 = 0;
      }
    }
#line 596
    if (tmp___96) {
#line 596
      tmp___92 = __builtin_strcmp((char const   *)arg, "yes");
    } else {
#line 596
      tmp___95 = __builtin_strcmp((char const   *)arg, "yes");
#line 596
      tmp___92 = tmp___95;
    }
  } else {
#line 596
    tmp___95 = __builtin_strcmp((char const   *)arg, "yes");
#line 596
    tmp___92 = tmp___95;
  }
#line 596
  if (tmp___92 == 0) {
#line 597
    value = 1;
  } else {
#line 598
    if (0) {
#line 598
      __s1_len___5 = strlen((char const   *)arg);
#line 598
      __s2_len___5 = strlen("no");
#line 598
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___12;
      } else {
#line 598
        if (__s1_len___5 >= 4U) {
          _L___12: /* CIL Label */ 
#line 598
          if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 598
            tmp___86 = 1;
          } else {
#line 598
            if (__s2_len___5 >= 4U) {
#line 598
              tmp___86 = 1;
            } else {
#line 598
              tmp___86 = 0;
            }
          }
        } else {
#line 598
          tmp___86 = 0;
        }
      }
#line 598
      if (tmp___86) {
#line 598
        tmp___82 = __builtin_strcmp((char const   *)arg, "no");
      } else {
#line 598
        tmp___85 = __builtin_strcmp((char const   *)arg, "no");
#line 598
        tmp___82 = tmp___85;
      }
    } else {
#line 598
      tmp___85 = __builtin_strcmp((char const   *)arg, "no");
#line 598
      tmp___82 = tmp___85;
    }
#line 598
    if (tmp___82 == 0) {
#line 599
      value = 0;
    } else {
#line 601
      fatal("%s line %d: Bad yes/no argument: %s", filename, linenum, arg);
    }
  }
#line 603
  if (*intptr == -1) {
#line 604
    *intptr = value;
  }
#line 605
  break;
  case 38: 
#line 608
  intptr = & options___0->ignore_user_known_hosts;
  goto parse_flag;
  case 10: 
#line 612
  intptr = & options___0->rhosts_rsa_authentication;
  goto parse_flag;
  case 50: 
#line 616
  intptr = & options___0->hostbased_authentication;
  goto parse_flag;
  case 51: 
#line 620
  intptr = & options___0->hostbased_uses_name_from_packet_only;
  goto parse_flag;
  case 11: 
#line 624
  intptr = & options___0->rsa_authentication;
  goto parse_flag;
  case 44: 
#line 628
  intptr = & options___0->pubkey_authentication;
  goto parse_flag;
  case 12: 
#line 632
  intptr = & options___0->kerberos_authentication;
  goto parse_flag;
  case 13: 
#line 636
  intptr = & options___0->kerberos_or_local_passwd;
  goto parse_flag;
  case 14: 
#line 640
  intptr = & options___0->kerberos_ticket_cleanup;
  goto parse_flag;
  case 15: 
#line 644
  intptr = & options___0->kerberos_get_afs_token;
  goto parse_flag;
  case 56: 
#line 648
  intptr = & options___0->gss_authentication;
  goto parse_flag;
  case 57: 
#line 652
  intptr = & options___0->gss_cleanup_creds;
  goto parse_flag;
  case 18: 
#line 656
  intptr = & options___0->password_authentication;
  goto parse_flag;
  case 19: 
#line 660
  intptr = & options___0->kbd_interactive_authentication;
  goto parse_flag;
  case 17: 
#line 664
  intptr = & options___0->challenge_response_authentication;
  goto parse_flag;
  case 21: 
#line 668
  intptr = & options___0->print_motd;
  goto parse_flag;
  case 22: 
#line 672
  intptr = & options___0->print_lastlog;
  goto parse_flag;
  case 24: 
#line 676
  intptr = & options___0->x11_forwarding;
  goto parse_flag;
  case 25: 
#line 680
  intptr = & options___0->x11_display_offset;
  goto parse_int;
  case 26: 
#line 684
  intptr = & options___0->x11_use_localhost;
  goto parse_flag;
  case 45: 
#line 688
  charptr = & options___0->xauth_location;
  goto parse_filename;
  case 27: 
#line 692
  intptr = & options___0->strict_modes;
  goto parse_flag;
  case 29: 
#line 696
  intptr = & options___0->tcp_keep_alive;
  goto parse_flag;
  case 28: 
#line 700
  intptr = & options___0->permit_empty_passwd;
  goto parse_flag;
  case 30: 
#line 704
  intptr = & options___0->permit_user_env;
  goto parse_flag;
  case 31: 
#line 708
  intptr = & options___0->use_login;
  goto parse_flag;
  case 33: 
#line 712
  intptr = & options___0->compression;
  goto parse_flag;
  case 43: 
#line 716
  intptr = & options___0->gateway_ports;
  goto parse_flag;
  case 49: 
#line 720
  intptr = & options___0->use_dns;
  goto parse_flag;
  case 8: 
#line 724
  intptr = (int *)(& options___0->log_facility);
#line 725
  arg = strdelim(& cp);
#line 726
  tmp___97 = log_facility_number(arg);
#line 726
  value = (int )tmp___97;
#line 727
  if (value == -1) {
#line 728
    if (arg) {
#line 728
      tmp___98 = (char const   *)arg;
    } else {
#line 728
      tmp___98 = "<NONE>";
    }
#line 728
    fatal("%.200s line %d: unsupported log facility \'%s\'", filename, linenum, tmp___98);
  }
#line 730
  if (*intptr == -1) {
#line 731
    *intptr = (int )((enum __anonenum_SyslogFacility_70 )value);
  }
#line 732
  break;
  case 9: 
#line 735
  intptr = (int *)(& options___0->log_level);
#line 736
  arg = strdelim(& cp);
#line 737
  tmp___99 = log_level_number(arg);
#line 737
  value = (int )tmp___99;
#line 738
  if (value == -1) {
#line 739
    if (arg) {
#line 739
      tmp___100 = (char const   *)arg;
    } else {
#line 739
      tmp___100 = "<NONE>";
    }
#line 739
    fatal("%.200s line %d: unsupported log level \'%s\'", filename, linenum, tmp___100);
  }
#line 741
  if (*intptr == -1) {
#line 742
    *intptr = (int )((enum __anonenum_LogLevel_71 )value);
  }
#line 743
  break;
  case 32: 
#line 746
  intptr = & options___0->allow_tcp_forwarding;
  goto parse_flag;
  case 58: 
#line 750
  intptr = & use_privsep;
  goto parse_flag;
  case 34: 
#line 754
  while (1) {
#line 754
    arg = strdelim(& cp);
#line 754
    if (arg) {
#line 754
      if (! ((int )*arg != 0)) {
#line 754
        break;
      }
    } else {
#line 754
      break;
    }
#line 755
    if (options___0->num_allow_users >= 256U) {
#line 756
      fatal("%s line %d: too many allow users.", filename, linenum);
    }
#line 758
    tmp___101 = options___0->num_allow_users;
#line 758
    (options___0->num_allow_users) ++;
#line 758
    options___0->allow_users[tmp___101] = xstrdup((char const   *)arg);
  }
#line 761
  break;
  case 35: 
#line 764
  while (1) {
#line 764
    arg = strdelim(& cp);
#line 764
    if (arg) {
#line 764
      if (! ((int )*arg != 0)) {
#line 764
        break;
      }
    } else {
#line 764
      break;
    }
#line 765
    if (options___0->num_deny_users >= 256U) {
#line 766
      fatal("%s line %d: too many deny users.", filename, linenum);
    }
#line 768
    tmp___102 = options___0->num_deny_users;
#line 768
    (options___0->num_deny_users) ++;
#line 768
    options___0->deny_users[tmp___102] = xstrdup((char const   *)arg);
  }
#line 771
  break;
  case 36: 
#line 774
  while (1) {
#line 774
    arg = strdelim(& cp);
#line 774
    if (arg) {
#line 774
      if (! ((int )*arg != 0)) {
#line 774
        break;
      }
    } else {
#line 774
      break;
    }
#line 775
    if (options___0->num_allow_groups >= 256U) {
#line 776
      fatal("%s line %d: too many allow groups.", filename, linenum);
    }
#line 778
    tmp___103 = options___0->num_allow_groups;
#line 778
    (options___0->num_allow_groups) ++;
#line 778
    options___0->allow_groups[tmp___103] = xstrdup((char const   *)arg);
  }
#line 781
  break;
  case 37: 
#line 784
  while (1) {
#line 784
    arg = strdelim(& cp);
#line 784
    if (arg) {
#line 784
      if (! ((int )*arg != 0)) {
#line 784
        break;
      }
    } else {
#line 784
      break;
    }
#line 785
    if (options___0->num_deny_groups >= 256U) {
#line 786
      fatal("%s line %d: too many deny groups.", filename, linenum);
    }
#line 788
    tmp___104 = options___0->num_deny_groups;
#line 788
    (options___0->num_deny_groups) ++;
#line 788
    options___0->deny_groups[tmp___104] = xstrdup((char const   *)arg);
  }
#line 790
  break;
  case 39: 
#line 793
  arg = strdelim(& cp);
#line 794
  if (! arg) {
#line 795
    fatal("%s line %d: Missing argument.", filename, linenum);
  } else {
#line 794
    if ((int )*arg == 0) {
#line 795
      fatal("%s line %d: Missing argument.", filename, linenum);
    }
  }
#line 796
  tmp___106 = ciphers_valid((char const   *)arg);
#line 796
  if (! tmp___106) {
#line 797
    if (arg) {
#line 797
      tmp___105 = (char const   *)arg;
    } else {
#line 797
      tmp___105 = "<NONE>";
    }
#line 797
    fatal("%s line %d: Bad SSH2 cipher spec \'%s\'.", filename, linenum, tmp___105);
  }
#line 799
  if ((unsigned int )options___0->ciphers == (unsigned int )((void *)0)) {
#line 800
    options___0->ciphers = xstrdup((char const   *)arg);
  }
#line 801
  break;
  case 40: 
#line 804
  arg = strdelim(& cp);
#line 805
  if (! arg) {
#line 806
    fatal("%s line %d: Missing argument.", filename, linenum);
  } else {
#line 805
    if ((int )*arg == 0) {
#line 806
      fatal("%s line %d: Missing argument.", filename, linenum);
    }
  }
#line 807
  tmp___108 = mac_valid((char const   *)arg);
#line 807
  if (! tmp___108) {
#line 808
    if (arg) {
#line 808
      tmp___107 = (char const   *)arg;
    } else {
#line 808
      tmp___107 = "<NONE>";
    }
#line 808
    fatal("%s line %d: Bad SSH2 mac spec \'%s\'.", filename, linenum, tmp___107);
  }
#line 810
  if ((unsigned int )options___0->macs == (unsigned int )((void *)0)) {
#line 811
    options___0->macs = xstrdup((char const   *)arg);
  }
#line 812
  break;
  case 41: 
#line 815
  intptr = & options___0->protocol;
#line 816
  arg = strdelim(& cp);
#line 817
  if (! arg) {
#line 818
    fatal("%s line %d: Missing argument.", filename, linenum);
  } else {
#line 817
    if ((int )*arg == 0) {
#line 818
      fatal("%s line %d: Missing argument.", filename, linenum);
    }
  }
#line 819
  value = proto_spec((char const   *)arg);
#line 820
  if (value == 0) {
#line 821
    if (arg) {
#line 821
      tmp___109 = (char const   *)arg;
    } else {
#line 821
      tmp___109 = "<NONE>";
    }
#line 821
    fatal("%s line %d: Bad protocol spec \'%s\'.", filename, linenum, tmp___109);
  }
#line 823
  if (*intptr == 0) {
#line 824
    *intptr = value;
  }
#line 825
  break;
  case 46: 
#line 828
  if (options___0->num_subsystems >= 256U) {
#line 829
    fatal("%s line %d: too many subsystems defined.", filename, linenum);
  }
#line 832
  arg = strdelim(& cp);
#line 833
  if (! arg) {
#line 834
    fatal("%s line %d: Missing subsystem name.", filename, linenum);
  } else {
#line 833
    if ((int )*arg == 0) {
#line 834
      fatal("%s line %d: Missing subsystem name.", filename, linenum);
    }
  }
#line 836
  i = 0;
#line 836
  while ((u_int )i < options___0->num_subsystems) {
#line 837
    if (0) {
#line 837
      __s1_len___7 = strlen((char const   *)arg);
#line 837
      __s2_len___7 = strlen((char const   *)options___0->subsystem_name[i]);
#line 837
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___16;
      } else {
#line 837
        if (__s1_len___7 >= 4U) {
          _L___16: /* CIL Label */ 
#line 837
          if (! ((unsigned int )((void const   *)(options___0->subsystem_name[i] + 1)) - (unsigned int )((void const   *)options___0->subsystem_name[i]) == 1U)) {
#line 837
            tmp___119 = 1;
          } else {
#line 837
            if (__s2_len___7 >= 4U) {
#line 837
              tmp___119 = 1;
            } else {
#line 837
              tmp___119 = 0;
            }
          }
        } else {
#line 837
          tmp___119 = 0;
        }
      }
#line 837
      if (tmp___119) {
#line 837
        tmp___115 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
      } else {
#line 837
        tmp___118 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
#line 837
        tmp___115 = tmp___118;
      }
    } else {
#line 837
      tmp___118 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
#line 837
      tmp___115 = tmp___118;
    }
#line 837
    if (tmp___115 == 0) {
#line 838
      fatal("%s line %d: Subsystem \'%s\' already defined.", filename, linenum, arg);
    }
#line 836
    i ++;
  }
#line 840
  options___0->subsystem_name[options___0->num_subsystems] = xstrdup((char const   *)arg);
#line 841
  arg = strdelim(& cp);
#line 842
  if (! arg) {
#line 843
    fatal("%s line %d: Missing subsystem command.", filename, linenum);
  } else {
#line 842
    if ((int )*arg == 0) {
#line 843
      fatal("%s line %d: Missing subsystem command.", filename, linenum);
    }
  }
#line 845
  options___0->subsystem_command[options___0->num_subsystems] = xstrdup((char const   *)arg);
#line 846
  (options___0->num_subsystems) ++;
#line 847
  break;
  case 47: 
#line 850
  arg = strdelim(& cp);
#line 851
  if (! arg) {
#line 852
    fatal("%s line %d: Missing MaxStartups spec.", filename, linenum);
  } else {
#line 851
    if ((int )*arg == 0) {
#line 852
      fatal("%s line %d: Missing MaxStartups spec.", filename, linenum);
    }
  }
#line 854
  n___0 = sscanf((char const   * __restrict  )arg, (char const   * __restrict  )"%d:%d:%d",
                 & options___0->max_startups_begin, & options___0->max_startups_rate,
                 & options___0->max_startups);
#line 854
  if (n___0 == 3) {
#line 858
    if (options___0->max_startups_begin > options___0->max_startups) {
#line 862
      fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
    } else {
#line 858
      if (options___0->max_startups_rate > 100) {
#line 862
        fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
      } else {
#line 858
        if (options___0->max_startups_rate < 1) {
#line 862
          fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
        }
      }
    }
  } else {
#line 864
    if (n___0 != 1) {
#line 865
      fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
    } else {
#line 868
      options___0->max_startups = options___0->max_startups_begin;
    }
  }
#line 869
  break;
  case 48: 
#line 872
  charptr = & options___0->banner;
  goto parse_filename;
  case 54: 
  case 55: 
#line 882
  if ((int )opcode == 54) {
#line 882
    charptr = & options___0->authorized_keys_file;
  } else {
#line 882
    charptr = & options___0->authorized_keys_file2;
  }
  goto parse_filename;
  case 52: 
#line 888
  intptr = & options___0->client_alive_interval;
  goto parse_time;
  case 53: 
#line 892
  intptr = & options___0->client_alive_count_max;
  goto parse_int;
  case 59: 
#line 896
  logit("%s line %d: Deprecated option %s", filename, linenum, arg);
#line 898
  while (arg) {
#line 899
    arg = strdelim(& cp);
  }
#line 900
  break;
  case 60: 
#line 903
  logit("%s line %d: Unsupported option %s", filename, linenum, arg);
#line 905
  while (arg) {
#line 906
    arg = strdelim(& cp);
  }
#line 907
  break;
  default: 
#line 910
  fatal("%s line %d: Missing handler for opcode %s (%d)", filename, linenum, arg,
        opcode);
  }
#line 913
  arg = strdelim(& cp);
#line 913
  if ((unsigned int )arg != (unsigned int )((void *)0)) {
#line 913
    if ((int )*arg != 0) {
#line 914
      fatal("%s line %d: garbage at end of line; \"%.200s\".", filename, linenum,
            arg);
    }
  }
#line 916
  return (0);
}
}
#line 921 "servconf.c"
void read_server_config(ServerOptions *options___0 , char const   *filename ) 
{ int linenum ;
  int bad_options ;
  char line[1024] ;
  FILE *f ;
  int tmp ;
  char *tmp___0 ;

  {
#line 924
  bad_options = 0;
#line 928
  debug2("read_server_config: filename %s", filename);
#line 929
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 930
  if (! f) {
#line 931
    perror(filename);
#line 932
    exit(1);
  }
#line 934
  linenum = 0;
#line 935
  while (1) {
#line 935
    tmp___0 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 935
    if (! tmp___0) {
#line 935
      break;
    }
#line 937
    linenum ++;
#line 938
    tmp = process_server_config_line(options___0, line, filename, linenum);
#line 938
    if (tmp != 0) {
#line 939
      bad_options ++;
    }
  }
#line 941
  fclose(f);
#line 942
  if (bad_options > 0) {
#line 943
    fatal("%s: terminating, %d bad configuration options", filename, bad_options);
  }
#line 945
  return;
}
}
#line 1 "serverloop.o"
#line 222 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo )  __attribute__((__nonnull__(1))) ;
#line 249
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
#line 61 "session.h"
int session_open(Authctxt *authctxt___0 , int chanid ) ;
#line 62
int session_input_channel_req(Channel *c , char const   *rtype ) ;
#line 63
void session_close_by_pid(pid_t pid , int status ) ;
#line 64
void session_close_by_channel(int id , void *arg ) ;
#line 65
void session_destroy_all(void (*closefunc)(Session * ) ) ;
#line 24 "serverloop.h"
void server_loop(pid_t pid , int fdin_arg , int fdout_arg , int fderr_arg ) ;
#line 25
void server_loop2(Authctxt *authctxt___0 ) ;
#line 65 "serverloop.c"
static Buffer stdin_buffer  ;
#line 66 "serverloop.c"
static Buffer stdout_buffer  ;
#line 67 "serverloop.c"
static Buffer stderr_buffer  ;
#line 68 "serverloop.c"
static int fdin  ;
#line 69 "serverloop.c"
static int fdout  ;
#line 71 "serverloop.c"
static int fderr  ;
#line 72 "serverloop.c"
static long stdin_bytes  =    0L;
#line 73 "serverloop.c"
static long stdout_bytes  =    0L;
#line 74 "serverloop.c"
static long stderr_bytes  =    0L;
#line 75 "serverloop.c"
static long fdout_bytes  =    0L;
#line 76 "serverloop.c"
static int stdin_eof  =    0;
#line 77 "serverloop.c"
static int fdout_eof  =    0;
#line 78 "serverloop.c"
static int fderr_eof  =    0;
#line 79 "serverloop.c"
static int fdin_is_tty  =    0;
#line 80 "serverloop.c"
static int connection_in___0  ;
#line 81 "serverloop.c"
static int connection_out___0  ;
#line 82 "serverloop.c"
static int connection_closed  =    0;
#line 83 "serverloop.c"
static u_int buffer_high  ;
#line 84 "serverloop.c"
static int client_alive_timeouts  =    0;
#line 91 "serverloop.c"
static int volatile   child_terminated  =    (sig_atomic_t volatile   )0;
#line 94
static void server_init_dispatch(void) ;
#line 100 "serverloop.c"
static int notify_pipe[2]  ;
#line 101 "serverloop.c"
static void notify_setup(void) 
{ int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 104
  tmp___5 = pipe((int *)(notify_pipe));
#line 104
  if (tmp___5 < 0) {
#line 105
    tmp = __errno_location();
#line 105
    tmp___0 = strerror(*tmp);
#line 105
    error("pipe(notify_pipe) failed %s", tmp___0);
  } else {
#line 106
    tmp___3 = fcntl(notify_pipe[0], 2, 1);
#line 106
    if (tmp___3 == -1) {
#line 108
      tmp___1 = __errno_location();
#line 108
      tmp___2 = strerror(*tmp___1);
#line 108
      error("fcntl(notify_pipe, F_SETFD) failed %s", tmp___2);
#line 109
      close(notify_pipe[0]);
#line 110
      close(notify_pipe[1]);
    } else {
#line 106
      tmp___4 = fcntl(notify_pipe[1], 2, 1);
#line 106
      if (tmp___4 == -1) {
#line 108
        tmp___1 = __errno_location();
#line 108
        tmp___2 = strerror(*tmp___1);
#line 108
        error("fcntl(notify_pipe, F_SETFD) failed %s", tmp___2);
#line 109
        close(notify_pipe[0]);
#line 110
        close(notify_pipe[1]);
      } else {
#line 112
        set_nonblock(notify_pipe[0]);
#line 113
        set_nonblock(notify_pipe[1]);
#line 114
        return;
      }
    }
  }
#line 116
  notify_pipe[0] = -1;
#line 117
  notify_pipe[1] = -1;
#line 118
  return;
}
}
#line 119 "serverloop.c"
static void notify_parent(void) 
{ 

  {
#line 122
  if (notify_pipe[1] != -1) {
#line 123
    write(notify_pipe[1], (void const   *)"", 1U);
  }
#line 124
  return;
}
}
#line 125 "serverloop.c"
static void notify_prepare(fd_set *readset ) 
{ 

  {
#line 128
  if (notify_pipe[0] != -1) {
#line 129
    __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )notify_pipe[0] / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )notify_pipe[0] % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 130
  return;
}
}
#line 131 "serverloop.c"
static void notify_done(fd_set *readset ) 
{ char c ;
  ssize_t tmp ;
  register char __result ;

  {
#line 136
  if (notify_pipe[0] != -1) {
#line 136
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )notify_pipe[0] % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )notify_pipe[0] / (8U * sizeof(__fd_mask ))]): "cc");
#line 136
    if (__result) {
#line 137
      while (1) {
#line 137
        tmp = read(notify_pipe[0], (void *)(& c), 1U);
#line 137
        if (! (tmp != -1)) {
#line 137
          break;
        }
#line 138
        debug2("notify_done: reading");
      }
    }
  }
#line 139
  return;
}
}
#line 141 "serverloop.c"
static void sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 144
  tmp = __errno_location();
#line 144
  save_errno = *tmp;
#line 145
  debug("Received SIGCHLD.");
#line 146
  child_terminated = (int volatile   )1;
#line 148
  mysignal(17, & sigchld_handler);
#line 150
  notify_parent();
#line 151
  tmp___0 = __errno_location();
#line 151
  *tmp___0 = save_errno;
#line 152
  return;
}
}
#line 158 "serverloop.c"
static void make_packets_from_stderr_data(void) 
{ u_int len ;
  int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;

  {
#line 164
  while (1) {
#line 164
    tmp___1 = buffer_len(& stderr_buffer);
#line 164
    if (tmp___1 > 0U) {
#line 164
      tmp___2 = packet_not_very_much_data_to_write();
#line 164
      if (! tmp___2) {
#line 164
        break;
      }
    } else {
#line 164
      break;
    }
#line 166
    len = buffer_len(& stderr_buffer);
#line 167
    tmp = packet_is_interactive();
#line 167
    if (tmp) {
#line 168
      if (len > 512U) {
#line 169
        len = 512U;
      }
    } else {
#line 172
      if (len > max_packet_size) {
#line 173
        len = max_packet_size;
      }
    }
#line 175
    packet_start((unsigned char)18);
#line 176
    tmp___0 = buffer_ptr(& stderr_buffer);
#line 176
    packet_put_string((void const   *)tmp___0, len);
#line 177
    packet_send();
#line 178
    buffer_consume(& stderr_buffer, len);
#line 179
    stderr_bytes = (long )((unsigned long )stderr_bytes + (unsigned long )len);
  }
#line 181
  return;
}
}
#line 187 "serverloop.c"
static void make_packets_from_stdout_data(void) 
{ u_int len ;
  int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;

  {
#line 193
  while (1) {
#line 193
    tmp___1 = buffer_len(& stdout_buffer);
#line 193
    if (tmp___1 > 0U) {
#line 193
      tmp___2 = packet_not_very_much_data_to_write();
#line 193
      if (! tmp___2) {
#line 193
        break;
      }
    } else {
#line 193
      break;
    }
#line 195
    len = buffer_len(& stdout_buffer);
#line 196
    tmp = packet_is_interactive();
#line 196
    if (tmp) {
#line 197
      if (len > 512U) {
#line 198
        len = 512U;
      }
    } else {
#line 201
      if (len > max_packet_size) {
#line 202
        len = max_packet_size;
      }
    }
#line 204
    packet_start((unsigned char)17);
#line 205
    tmp___0 = buffer_ptr(& stdout_buffer);
#line 205
    packet_put_string((void const   *)tmp___0, len);
#line 206
    packet_send();
#line 207
    buffer_consume(& stdout_buffer, len);
#line 208
    stdout_bytes = (long )((unsigned long )stdout_bytes + (unsigned long )len);
  }
#line 210
  return;
}
}
#line 212 "serverloop.c"
static void client_alive_check(void) 
{ int channel_id ;

  {
#line 218
  client_alive_timeouts ++;
#line 218
  if (client_alive_timeouts > options.client_alive_count_max) {
#line 219
    packet_disconnect("Timeout, your session not responding.");
  }
#line 225
  channel_id = channel_find_open();
#line 225
  if (channel_id == -1) {
#line 226
    packet_start((unsigned char)80);
#line 227
    packet_put_cstring("keepalive@openssh.com");
#line 228
    packet_put_char(1);
  } else {
#line 230
    channel_request_start(channel_id, (char *)"keepalive@openssh.com", 1);
  }
#line 232
  packet_send();
#line 233
  return;
}
}
#line 241 "serverloop.c"
static void wait_until_can_do_something(fd_set **readsetp , fd_set **writesetp , int *maxfdp ,
                                        int *nallocp , u_int max_time_milliseconds ) 
{ struct timeval tv ;
  struct timeval *tvp ;
  int ret ;
  int client_alive_scheduled ;
  u_int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  u_int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;

  {
#line 247
  client_alive_scheduled = 0;
#line 257
  if (compat20) {
#line 257
    if (max_time_milliseconds == 0U) {
#line 257
      if (options.client_alive_interval) {
#line 259
        client_alive_scheduled = 1;
#line 260
        max_time_milliseconds = (unsigned int )(options.client_alive_interval * 1000);
      }
    }
  }
#line 264
  channel_prepare_select(readsetp, writesetp, maxfdp, nallocp, 0);
#line 266
  if (compat20) {
#line 271
    __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  } else {
#line 277
    tmp = buffer_len(& stdin_buffer);
#line 277
    if (tmp < buffer_high) {
#line 277
      tmp___0 = channel_not_very_much_buffered_data();
#line 277
      if (tmp___0) {
#line 279
        __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
#line 284
    tmp___1 = packet_not_very_much_data_to_write();
#line 284
    if (tmp___1) {
#line 285
      if (! fdout_eof) {
#line 286
        __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->__fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
#line 287
      if (! fderr_eof) {
#line 288
        __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->__fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
#line 294
    if (fdin != -1) {
#line 294
      tmp___2 = buffer_len(& stdin_buffer);
#line 294
      if (tmp___2 > 0U) {
#line 295
        __asm__  volatile   ("btsl %1,%0": "=m" ((*writesetp)->__fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
  }
#line 297
  notify_prepare(*readsetp);
#line 303
  tmp___3 = packet_have_data_to_write();
#line 303
  if (tmp___3) {
#line 304
    __asm__  volatile   ("btsl %1,%0": "=m" ((*writesetp)->__fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 310
  if (child_terminated) {
#line 310
    tmp___4 = packet_not_very_much_data_to_write();
#line 310
    if (tmp___4) {
#line 311
      if (max_time_milliseconds == 0U) {
#line 312
        max_time_milliseconds = 100U;
      } else {
#line 311
        if (client_alive_scheduled) {
#line 312
          max_time_milliseconds = 100U;
        }
      }
    }
  }
#line 314
  if (max_time_milliseconds == 0U) {
#line 315
    tvp = (struct timeval *)((void *)0);
  } else {
#line 317
    tv.tv_sec = (long )(max_time_milliseconds / 1000U);
#line 318
    tv.tv_usec = (long )(1000U * (max_time_milliseconds % 1000U));
#line 319
    tvp = & tv;
  }
#line 323
  ret = select(*maxfdp + 1, (fd_set * __restrict  )*readsetp, (fd_set * __restrict  )*writesetp,
               (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )tvp);
#line 325
  if (ret == -1) {
#line 326
    memset((void *)*readsetp, 0, (unsigned int )*nallocp);
#line 327
    memset((void *)*writesetp, 0, (unsigned int )*nallocp);
#line 328
    tmp___7 = __errno_location();
#line 328
    if (*tmp___7 != 4) {
#line 329
      tmp___5 = __errno_location();
#line 329
      tmp___6 = strerror(*tmp___5);
#line 329
      error("select: %.100s", tmp___6);
    }
  } else {
#line 330
    if (ret == 0) {
#line 330
      if (client_alive_scheduled) {
#line 331
        client_alive_check();
      }
    }
  }
#line 333
  notify_done(*readsetp);
#line 334
  return;
}
}
#line 340 "serverloop.c"
static void process_input(fd_set *readset ) 
{ int len ;
  char buf___1[16384] ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  register char __result ;
  int *tmp___5 ;
  int *tmp___6 ;
  register char __result___0 ;
  int *tmp___7 ;
  int *tmp___8 ;
  register char __result___1 ;

  {
#line 347
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 347
  if (__result) {
#line 348
    len = read(connection_in___0, (void *)(buf___1), sizeof(buf___1));
#line 349
    if (len == 0) {
#line 350
      tmp = get_remote_ipaddr();
#line 350
      verbose("Connection closed by %.100s", tmp);
#line 352
      connection_closed = 1;
#line 353
      if (compat20) {
#line 354
        return;
      }
#line 355
      cleanup_exit(255);
    } else {
#line 356
      if (len < 0) {
#line 357
        tmp___3 = __errno_location();
#line 357
        if (*tmp___3 != 4) {
#line 357
          tmp___4 = __errno_location();
#line 357
          if (*tmp___4 != 11) {
#line 358
            tmp___0 = __errno_location();
#line 358
            tmp___1 = strerror(*tmp___0);
#line 358
            tmp___2 = get_remote_ipaddr();
#line 358
            verbose("Read error from remote host %.100s: %.100s", tmp___2, tmp___1);
#line 361
            cleanup_exit(255);
          }
        }
      } else {
#line 365
        packet_process_incoming((char const   *)(buf___1), (unsigned int )len);
      }
    }
  }
#line 368
  if (compat20) {
#line 369
    return;
  }
#line 372
  if (! fdout_eof) {
#line 372
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "cc");
#line 372
    if (__result___0) {
#line 373
      len = read(fdout, (void *)(buf___1), sizeof(buf___1));
#line 374
      if (len < 0) {
#line 374
        tmp___5 = __errno_location();
#line 374
        if (! (*tmp___5 == 4)) {
#line 374
          tmp___6 = __errno_location();
#line 374
          if (! (*tmp___6 == 11)) {
            goto _L;
          }
        }
      } else {
        _L: /* CIL Label */ 
#line 376
        if (len <= 0) {
#line 377
          fdout_eof = 1;
        } else {
#line 379
          buffer_append(& stdout_buffer, (void const   *)(buf___1), (unsigned int )len);
#line 380
          fdout_bytes += (long )len;
        }
      }
    }
  }
#line 384
  if (! fderr_eof) {
#line 384
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___1): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "cc");
#line 384
    if (__result___1) {
#line 385
      len = read(fderr, (void *)(buf___1), sizeof(buf___1));
#line 386
      if (len < 0) {
#line 386
        tmp___7 = __errno_location();
#line 386
        if (! (*tmp___7 == 4)) {
#line 386
          tmp___8 = __errno_location();
#line 386
          if (! (*tmp___8 == 11)) {
            goto _L___0;
          }
        }
      } else {
        _L___0: /* CIL Label */ 
#line 388
        if (len <= 0) {
#line 389
          fderr_eof = 1;
        } else {
#line 391
          buffer_append(& stderr_buffer, (void const   *)(buf___1), (unsigned int )len);
        }
      }
    }
  }
#line 394
  return;
}
}
#line 399 "serverloop.c"
static void process_output(fd_set *writeset ) 
{ struct termios tio ;
  u_char *data ;
  u_int dlen ;
  int len ;
  void *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  register char __result ;
  register char __result___0 ;

  {
#line 408
  if (! compat20) {
#line 408
    if (fdin != -1) {
#line 408
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))),
                           "m" (writeset->__fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "cc");
#line 408
      if (__result) {
#line 409
        tmp = buffer_ptr(& stdin_buffer);
#line 409
        data = (u_char *)tmp;
#line 410
        dlen = buffer_len(& stdin_buffer);
#line 411
        len = write(fdin, (void const   *)data, dlen);
#line 412
        if (len < 0) {
#line 412
          tmp___1 = __errno_location();
#line 412
          if (! (*tmp___1 == 4)) {
#line 412
            tmp___2 = __errno_location();
#line 412
            if (! (*tmp___2 == 11)) {
              goto _L;
            }
          }
        } else {
          _L: /* CIL Label */ 
#line 414
          if (len <= 0) {
#line 415
            if (fdin != fdout) {
#line 416
              close(fdin);
            } else {
#line 418
              shutdown(fdin, 1);
            }
#line 419
            fdin = -1;
          } else {
#line 422
            if (fdin_is_tty) {
#line 422
              if (dlen >= 1U) {
#line 422
                if ((int )*(data + 0) != 13) {
#line 422
                  tmp___0 = tcgetattr(fdin, & tio);
#line 422
                  if (tmp___0 == 0) {
#line 422
                    if (! (tio.c_lflag & 8U)) {
#line 422
                      if (tio.c_lflag & 2U) {
#line 429
                        packet_send_ignore(len);
#line 430
                        packet_send();
                      }
                    }
                  }
                }
              }
            }
#line 433
            buffer_consume(& stdin_buffer, (unsigned int )len);
#line 435
            stdin_bytes += (long )len;
          }
        }
      }
    }
  }
#line 439
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->__fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 439
  if (__result___0) {
#line 440
    packet_write_poll();
  }
#line 441
  return;
}
}
#line 447 "serverloop.c"
static void drain_output(void) 
{ u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  void *tmp___4 ;
  u_int tmp___5 ;
  u_int tmp___6 ;

  {
#line 451
  tmp___2 = buffer_len(& stdout_buffer);
#line 451
  if (tmp___2 > 0U) {
#line 452
    packet_start((unsigned char)17);
#line 453
    tmp = buffer_len(& stdout_buffer);
#line 453
    tmp___0 = buffer_ptr(& stdout_buffer);
#line 453
    packet_put_string((void const   *)tmp___0, tmp);
#line 455
    packet_send();
#line 457
    tmp___1 = buffer_len(& stdout_buffer);
#line 457
    stdout_bytes = (long )((unsigned long )stdout_bytes + (unsigned long )tmp___1);
  }
#line 460
  tmp___6 = buffer_len(& stderr_buffer);
#line 460
  if (tmp___6 > 0U) {
#line 461
    packet_start((unsigned char)18);
#line 462
    tmp___3 = buffer_len(& stderr_buffer);
#line 462
    tmp___4 = buffer_ptr(& stderr_buffer);
#line 462
    packet_put_string((void const   *)tmp___4, tmp___3);
#line 464
    packet_send();
#line 466
    tmp___5 = buffer_len(& stderr_buffer);
#line 466
    stderr_bytes = (long )((unsigned long )stderr_bytes + (unsigned long )tmp___5);
  }
#line 469
  packet_write_wait();
#line 470
  return;
}
}
#line 472 "serverloop.c"
static void process_buffered_input_packets(void) 
{ Kex *tmp ;

  {
#line 475
  if (compat20) {
#line 475
    tmp = xxx_kex;
  } else {
#line 475
    tmp = (Kex *)((void *)0);
  }
#line 475
  dispatch_run(1, (int *)((void *)0), (void *)tmp);
#line 476
  return;
}
}
#line 485 "serverloop.c"
void server_loop(pid_t pid , int fdin_arg , int fdout_arg , int fderr_arg ) 
{ fd_set *readset ;
  fd_set *writeset ;
  int max_fd ;
  int nalloc ;
  int wait_status ;
  pid_t wait_pid ;
  int waiting_termination ;
  u_int max_time_milliseconds ;
  u_int previous_stdout_buffer_bytes ;
  u_int stdout_buffer_bytes ;
  int type ;
  int tmp ;
  int tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *s ;
  char *cp ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  u_int tmp___7 ;
  u_int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  union __anonunion_80 __constr_expr_0 ;
  union __anonunion_81 __constr_expr_1 ;
  union __anonunion_82 __constr_expr_2 ;
  union __anonunion_83 __constr_expr_3 ;
  union __anonunion_84 __constr_expr_4 ;

  {
#line 488
  readset = (fd_set *)((void *)0);
#line 488
  writeset = (fd_set *)((void *)0);
#line 489
  max_fd = 0;
#line 489
  nalloc = 0;
#line 492
  waiting_termination = 0;
#line 498
  debug("Entering interactive session.");
#line 501
  child_terminated = (int volatile   )0;
#line 502
  mysignal(17, & sigchld_handler);
#line 505
  fdin = fdin_arg;
#line 506
  fdout = fdout_arg;
#line 507
  fderr = fderr_arg;
#line 510
  set_nonblock(fdin);
#line 511
  set_nonblock(fdout);
#line 513
  if (fderr != -1) {
#line 514
    set_nonblock(fderr);
  }
#line 516
  if (! (datafellows & 256)) {
#line 516
    tmp = isatty(fdin);
#line 516
    if (tmp) {
#line 517
      fdin_is_tty = 1;
    }
  }
#line 519
  connection_in___0 = packet_get_connection_in();
#line 520
  connection_out___0 = packet_get_connection_out();
#line 522
  notify_setup();
#line 524
  previous_stdout_buffer_bytes = 0U;
#line 527
  tmp___0 = packet_is_interactive();
#line 527
  if (tmp___0) {
#line 528
    buffer_high = 4096U;
  } else {
#line 530
    buffer_high = 65536U;
  }
#line 542
  buffer_init(& stdin_buffer);
#line 543
  buffer_init(& stdout_buffer);
#line 544
  buffer_init(& stderr_buffer);
#line 552
  if (fderr == -1) {
#line 553
    fderr_eof = 1;
  }
#line 555
  server_init_dispatch();
#line 558
  while (1) {
#line 561
    process_buffered_input_packets();
#line 567
    if (stdin_eof) {
#line 567
      if (fdin != -1) {
#line 567
        tmp___1 = buffer_len(& stdin_buffer);
#line 567
        if (tmp___1 == 0U) {
#line 568
          if (fdin != fdout) {
#line 569
            close(fdin);
          } else {
#line 571
            shutdown(fdin, 1);
          }
#line 572
          fdin = -1;
        }
      }
    }
#line 575
    make_packets_from_stderr_data();
#line 584
    max_time_milliseconds = 0U;
#line 585
    stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 586
    if (stdout_buffer_bytes != 0U) {
#line 586
      if (stdout_buffer_bytes < 256U) {
#line 586
        if (stdout_buffer_bytes != previous_stdout_buffer_bytes) {
#line 589
          max_time_milliseconds = 10U;
        } else {
#line 592
          make_packets_from_stdout_data();
        }
      } else {
#line 592
        make_packets_from_stdout_data();
      }
    } else {
#line 592
      make_packets_from_stdout_data();
    }
#line 594
    previous_stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 597
    tmp___2 = packet_not_very_much_data_to_write();
#line 597
    if (tmp___2) {
#line 598
      channel_output_poll();
    }
#line 605
    if (fdout_eof) {
#line 605
      if (fderr_eof) {
#line 605
        tmp___6 = packet_have_data_to_write();
#line 605
        if (! tmp___6) {
#line 605
          tmp___7 = buffer_len(& stdout_buffer);
#line 605
          if (tmp___7 == 0U) {
#line 605
            tmp___8 = buffer_len(& stderr_buffer);
#line 605
            if (tmp___8 == 0U) {
#line 607
              tmp___3 = channel_still_open();
#line 607
              if (! tmp___3) {
#line 608
                break;
              }
#line 609
              if (! waiting_termination) {
#line 610
                s = "Waiting for forwarded connections to terminate...\r\n";
#line 612
                waiting_termination = 1;
#line 613
                tmp___4 = strlen(s);
#line 613
                buffer_append(& stderr_buffer, (void const   *)s, tmp___4);
#line 616
                cp = channel_open_message();
#line 617
                tmp___5 = strlen((char const   *)cp);
#line 617
                buffer_append(& stderr_buffer, (void const   *)cp, tmp___5);
#line 618
                xfree((void *)cp);
              }
            }
          }
        }
      }
    }
#line 621
    if (connection_in___0 > connection_out___0) {
#line 621
      max_fd = connection_in___0;
    } else {
#line 621
      max_fd = connection_out___0;
    }
#line 622
    if (max_fd > fdin) {
#line 622
      max_fd = max_fd;
    } else {
#line 622
      max_fd = fdin;
    }
#line 623
    if (max_fd > fdout) {
#line 623
      max_fd = max_fd;
    } else {
#line 623
      max_fd = fdout;
    }
#line 624
    if (max_fd > fderr) {
#line 624
      max_fd = max_fd;
    } else {
#line 624
      max_fd = fderr;
    }
#line 625
    if (max_fd > notify_pipe[0]) {
#line 625
      max_fd = max_fd;
    } else {
#line 625
      max_fd = notify_pipe[0];
    }
#line 628
    wait_until_can_do_something(& readset, & writeset, & max_fd, & nalloc, max_time_milliseconds);
#line 632
    channel_after_select(readset, writeset);
#line 635
    process_input(readset);
#line 638
    process_output(writeset);
  }
#line 640
  if (readset) {
#line 641
    xfree((void *)readset);
  }
#line 642
  if (writeset) {
#line 643
    xfree((void *)writeset);
  }
#line 648
  drain_output();
#line 650
  debug("End of interactive session; stdin %ld, stdout (read %ld, sent %ld), stderr %ld bytes.",
        stdin_bytes, fdout_bytes, stdout_bytes, stderr_bytes);
#line 654
  buffer_free(& stdin_buffer);
#line 655
  buffer_free(& stdout_buffer);
#line 656
  buffer_free(& stderr_buffer);
#line 659
  if (fdout != -1) {
#line 660
    close(fdout);
  }
#line 661
  fdout = -1;
#line 662
  fdout_eof = 1;
#line 663
  if (fderr != -1) {
#line 664
    close(fderr);
  }
#line 665
  fderr = -1;
#line 666
  fderr_eof = 1;
#line 667
  if (fdin != -1) {
#line 668
    close(fdin);
  }
#line 669
  fdin = -1;
#line 671
  channel_free_all();
#line 674
  mysignal(17, (void (*)(int  ))0);
#line 676
  while (1) {
#line 676
    wait_pid = waitpid(-1, & wait_status, 0);
#line 676
    if (! (wait_pid < 0)) {
#line 676
      break;
    }
#line 677
    tmp___11 = __errno_location();
#line 677
    if (*tmp___11 != 4) {
#line 678
      tmp___9 = __errno_location();
#line 678
      tmp___10 = strerror(*tmp___9);
#line 678
      packet_disconnect("wait: %.100s", tmp___10);
    }
  }
#line 679
  if (wait_pid != pid) {
#line 680
    error("Strange, wait returned pid %ld, expected %ld", (long )wait_pid, (long )pid);
  }
#line 684
  __constr_expr_2.__in = wait_status;
#line 684
  if ((__constr_expr_2.__i & 127) == 0) {
#line 686
    __constr_expr_0.__in = wait_status;
#line 686
    debug("Command exited with status %d.", (__constr_expr_0.__i & 65280) >> 8);
#line 687
    packet_start((unsigned char)20);
#line 688
    __constr_expr_1.__in = wait_status;
#line 688
    packet_put_int((unsigned int )((__constr_expr_1.__i & 65280) >> 8));
#line 689
    packet_send();
#line 690
    packet_write_wait();
#line 699
    while (1) {
#line 700
      type = packet_read();
#line 699
      if (! (type != 33)) {
#line 699
        break;
      }
    }
#line 704
    debug("Received exit confirmation.");
#line 705
    return;
  }
#line 708
  __constr_expr_4.__in = wait_status;
#line 708
  if ((int )((signed char )((__constr_expr_4.__i & 127) + 1)) >> 1 > 0) {
#line 709
    __constr_expr_3.__in = wait_status;
#line 709
    packet_disconnect("Command terminated on signal %d.", __constr_expr_3.__i & 127);
  }
#line 713
  packet_disconnect("wait returned status %04x.", wait_status);
#line 715
  return;
}
}
#line 717 "serverloop.c"
static void collect_children(void) 
{ pid_t pid ;
  sigset_t oset ;
  sigset_t nset ;
  int status ;
  int *tmp ;

  {
#line 725
  sigemptyset(& nset);
#line 726
  sigaddset(& nset, 17);
#line 727
  sigprocmask(0, (sigset_t const   * __restrict  )(& nset), (sigset_t * __restrict  )(& oset));
#line 728
  if (child_terminated) {
#line 729
    while (1) {
#line 729
      pid = waitpid(-1, & status, 1);
#line 729
      if (! (pid > 0)) {
#line 729
        if (pid < 0) {
#line 729
          tmp = __errno_location();
#line 729
          if (! (*tmp == 4)) {
#line 729
            break;
          }
        } else {
#line 729
          break;
        }
      }
#line 731
      if (pid > 0) {
#line 732
        session_close_by_pid(pid, status);
      }
    }
#line 733
    child_terminated = (int volatile   )0;
  }
#line 735
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((void *)0));
#line 736
  return;
}
}
#line 738 "serverloop.c"
void server_loop2(Authctxt *authctxt___0 ) 
{ fd_set *readset ;
  fd_set *writeset ;
  int rekeying___0 ;
  int max_fd ;
  int nalloc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 741
  readset = (fd_set *)((void *)0);
#line 741
  writeset = (fd_set *)((void *)0);
#line 742
  rekeying___0 = 0;
#line 742
  nalloc = 0;
#line 744
  debug("Entering interactive session for SSH2.");
#line 746
  mysignal(17, & sigchld_handler);
#line 747
  child_terminated = (int volatile   )0;
#line 748
  connection_in___0 = packet_get_connection_in();
#line 749
  connection_out___0 = packet_get_connection_out();
#line 751
  notify_setup();
#line 753
  if (connection_in___0 > connection_out___0) {
#line 753
    max_fd = connection_in___0;
  } else {
#line 753
    max_fd = connection_out___0;
  }
#line 754
  if (max_fd > notify_pipe[0]) {
#line 754
    max_fd = max_fd;
  } else {
#line 754
    max_fd = notify_pipe[0];
  }
#line 756
  server_init_dispatch();
#line 758
  while (1) {
#line 759
    process_buffered_input_packets();
#line 761
    if ((unsigned int )xxx_kex != (unsigned int )((void *)0)) {
#line 761
      if (! xxx_kex->done) {
#line 761
        tmp = 1;
      } else {
#line 761
        tmp = 0;
      }
    } else {
#line 761
      tmp = 0;
    }
#line 761
    rekeying___0 = tmp;
#line 763
    if (! rekeying___0) {
#line 763
      tmp___0 = packet_not_very_much_data_to_write();
#line 763
      if (tmp___0) {
#line 764
        channel_output_poll();
      }
    }
#line 765
    wait_until_can_do_something(& readset, & writeset, & max_fd, & nalloc, 0U);
#line 768
    collect_children();
#line 769
    if (! rekeying___0) {
#line 770
      channel_after_select(readset, writeset);
#line 771
      tmp___1 = packet_need_rekeying();
#line 771
      if (tmp___1) {
#line 772
        debug("need rekeying");
#line 773
        xxx_kex->done = 0;
#line 774
        kex_send_kexinit(xxx_kex);
      }
    }
#line 777
    process_input(readset);
#line 778
    if (connection_closed) {
#line 779
      break;
    }
#line 780
    process_output(writeset);
  }
#line 782
  collect_children();
#line 784
  if (readset) {
#line 785
    xfree((void *)readset);
  }
#line 786
  if (writeset) {
#line 787
    xfree((void *)writeset);
  }
#line 790
  channel_free_all();
#line 793
  session_destroy_all((void (*)(Session * ))((void *)0));
#line 794
  return;
}
}
#line 796 "serverloop.c"
static void server_input_keep_alive(int type , u_int32_t seq , void *ctxt ) 
{ 

  {
#line 799
  debug("Got %d/%u for keepalive", type, seq);
#line 805
  client_alive_timeouts = 0;
#line 806
  return;
}
}
#line 808 "serverloop.c"
static void server_input_stdin_data(int type , u_int32_t seq , void *ctxt ) 
{ char *data ;
  u_int data_len ;
  void *tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 816
  if (fdin == -1) {
#line 817
    return;
  }
#line 818
  tmp = packet_get_string(& data_len);
#line 818
  data = (char *)tmp;
#line 819
  while (1) {
#line 819
    tmp___0 = packet_remaining();
#line 819
    _len = tmp___0;
#line 819
    if (_len > 0) {
#line 819
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
            819);
#line 819
      packet_disconnect("Packet integrity error.");
    }
#line 819
    break;
  }
#line 820
  buffer_append(& stdin_buffer, (void const   *)data, data_len);
#line 821
  memset((void *)data, 0, data_len);
#line 822
  xfree((void *)data);
#line 823
  return;
}
}
#line 825 "serverloop.c"
static void server_input_eof(int type , u_int32_t seq , void *ctxt ) 
{ int _len ;
  int tmp ;

  {
#line 833
  debug("EOF received for stdin.");
#line 834
  while (1) {
#line 834
    tmp = packet_remaining();
#line 834
    _len = tmp;
#line 834
    if (_len > 0) {
#line 834
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
            834);
#line 834
      packet_disconnect("Packet integrity error.");
    }
#line 834
    break;
  }
#line 835
  stdin_eof = 1;
#line 836
  return;
}
}
#line 838 "serverloop.c"
static void server_input_window_size(int type , u_int32_t seq , void *ctxt ) 
{ int row ;
  u_int tmp ;
  int col ;
  u_int tmp___0 ;
  int xpixel ;
  u_int tmp___1 ;
  int ypixel ;
  u_int tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 841
  tmp = packet_get_int();
#line 841
  row = (int )tmp;
#line 842
  tmp___0 = packet_get_int();
#line 842
  col = (int )tmp___0;
#line 843
  tmp___1 = packet_get_int();
#line 843
  xpixel = (int )tmp___1;
#line 844
  tmp___2 = packet_get_int();
#line 844
  ypixel = (int )tmp___2;
#line 846
  debug("Window change received.");
#line 847
  while (1) {
#line 847
    tmp___3 = packet_remaining();
#line 847
    _len = tmp___3;
#line 847
    if (_len > 0) {
#line 847
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
            847);
#line 847
      packet_disconnect("Packet integrity error.");
    }
#line 847
    break;
  }
#line 848
  if (fdin != -1) {
#line 849
    pty_change_window_size(fdin, row, col, xpixel, ypixel);
  }
#line 850
  return;
}
}
#line 852 "serverloop.c"
static Channel *server_request_direct_tcpip(void) 
{ Channel *c ;
  int sock ;
  char *target ;
  char *originator ;
  int target_port ;
  int originator_port ;
  void *tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  u_int tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 860
  tmp = packet_get_string((u_int *)((void *)0));
#line 860
  target = (char *)tmp;
#line 861
  tmp___0 = packet_get_int();
#line 861
  target_port = (int )tmp___0;
#line 862
  tmp___1 = packet_get_string((u_int *)((void *)0));
#line 862
  originator = (char *)tmp___1;
#line 863
  tmp___2 = packet_get_int();
#line 863
  originator_port = (int )tmp___2;
#line 864
  while (1) {
#line 864
    tmp___3 = packet_remaining();
#line 864
    _len = tmp___3;
#line 864
    if (_len > 0) {
#line 864
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
            864);
#line 864
      packet_disconnect("Packet integrity error.");
    }
#line 864
    break;
  }
#line 866
  debug("server_request_direct_tcpip: originator %s port %d, target %s port %d", originator,
        originator_port, target, target_port);
#line 870
  sock = channel_connect_to((char const   *)target, (unsigned short )target_port);
#line 871
  xfree((void *)target);
#line 872
  xfree((void *)originator);
#line 873
  if (sock < 0) {
#line 874
    return ((Channel *)((void *)0));
  }
#line 875
  c = channel_new((char *)"direct-tcpip", 12, sock, sock, -1, 131072U, 32768U, 0,
                  (char *)"direct-tcpip", 1);
#line 878
  return (c);
}
}
#line 881 "serverloop.c"
static Channel *server_request_session(void) 
{ Channel *c ;
  int _len ;
  int tmp ;
  int tmp___0 ;

  {
#line 886
  debug("input_session_request");
#line 887
  while (1) {
#line 887
    tmp = packet_remaining();
#line 887
    _len = tmp;
#line 887
    if (_len > 0) {
#line 887
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
            887);
#line 887
      packet_disconnect("Packet integrity error.");
    }
#line 887
    break;
  }
#line 894
  c = channel_new((char *)"session", 10, -1, -1, -1, 0U, 32768U, 0, (char *)"server-session",
                  1);
#line 897
  tmp___0 = session_open(the_authctxt, c->self);
#line 897
  if (tmp___0 != 1) {
#line 898
    debug("session open failed, free channel %d", c->self);
#line 899
    channel_free(c);
#line 900
    return ((Channel *)((void *)0));
  }
#line 902
  channel_register_cleanup(c->self, & session_close_by_channel);
#line 903
  return (c);
}
}
#line 906 "serverloop.c"
static void server_input_channel_open(int type , u_int32_t seq , void *ctxt ) 
{ Channel *c ;
  char *ctype ;
  int rchan ;
  u_int rmaxpack ;
  u_int rwindow ;
  u_int len ;
  void *tmp ;
  u_int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___16 ;
  int tmp___19 ;
  int tmp___20 ;

  {
#line 909
  c = (Channel *)((void *)0);
#line 914
  tmp = packet_get_string(& len);
#line 914
  ctype = (char *)tmp;
#line 915
  tmp___0 = packet_get_int();
#line 915
  rchan = (int )tmp___0;
#line 916
  rwindow = packet_get_int();
#line 917
  rmaxpack = packet_get_int();
#line 919
  debug("server_input_channel_open: ctype %s rchan %d win %d max %d", ctype, rchan,
        rwindow, rmaxpack);
#line 922
  if (0) {
#line 922
    __s1_len___0 = strlen((char const   *)ctype);
#line 922
    __s2_len___0 = strlen("session");
#line 922
    if (! ((unsigned int )((void const   *)(ctype + 1)) - (unsigned int )((void const   *)ctype) == 1U)) {
      goto _L___2;
    } else {
#line 922
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 922
        if (! ((unsigned int )((void const   *)("session" + 1)) - (unsigned int )((void const   *)"session") == 1U)) {
#line 922
          tmp___20 = 1;
        } else {
#line 922
          if (__s2_len___0 >= 4U) {
#line 922
            tmp___20 = 1;
          } else {
#line 922
            tmp___20 = 0;
          }
        }
      } else {
#line 922
        tmp___20 = 0;
      }
    }
#line 922
    if (tmp___20) {
#line 922
      tmp___16 = __builtin_strcmp((char const   *)ctype, "session");
    } else {
#line 922
      tmp___19 = __builtin_strcmp((char const   *)ctype, "session");
#line 922
      tmp___16 = tmp___19;
    }
  } else {
#line 922
    tmp___19 = __builtin_strcmp((char const   *)ctype, "session");
#line 922
    tmp___16 = tmp___19;
  }
#line 922
  if (tmp___16 == 0) {
#line 923
    c = server_request_session();
  } else {
#line 924
    if (0) {
#line 924
      __s1_len = strlen((char const   *)ctype);
#line 924
      __s2_len = strlen("direct-tcpip");
#line 924
      if (! ((unsigned int )((void const   *)(ctype + 1)) - (unsigned int )((void const   *)ctype) == 1U)) {
        goto _L___0;
      } else {
#line 924
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 924
          if (! ((unsigned int )((void const   *)("direct-tcpip" + 1)) - (unsigned int )((void const   *)"direct-tcpip") == 1U)) {
#line 924
            tmp___10 = 1;
          } else {
#line 924
            if (__s2_len >= 4U) {
#line 924
              tmp___10 = 1;
            } else {
#line 924
              tmp___10 = 0;
            }
          }
        } else {
#line 924
          tmp___10 = 0;
        }
      }
#line 924
      if (tmp___10) {
#line 924
        tmp___6 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
      } else {
#line 924
        tmp___9 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
#line 924
        tmp___6 = tmp___9;
      }
    } else {
#line 924
      tmp___9 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
#line 924
      tmp___6 = tmp___9;
    }
#line 924
    if (tmp___6 == 0) {
#line 925
      c = server_request_direct_tcpip();
    }
  }
#line 927
  if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 928
    debug("server_input_channel_open: confirm %s", ctype);
#line 929
    c->remote_id = rchan;
#line 930
    c->remote_window = rwindow;
#line 931
    c->remote_maxpacket = rmaxpack;
#line 932
    if (c->type != 12) {
#line 933
      packet_start((unsigned char)91);
#line 934
      packet_put_int((unsigned int )c->remote_id);
#line 935
      packet_put_int((unsigned int )c->self);
#line 936
      packet_put_int(c->local_window);
#line 937
      packet_put_int(c->local_maxpacket);
#line 938
      packet_send();
    }
  } else {
#line 941
    debug("server_input_channel_open: failure %s", ctype);
#line 942
    packet_start((unsigned char)92);
#line 943
    packet_put_int((unsigned int )rchan);
#line 944
    packet_put_int(1U);
#line 945
    if (! (datafellows & 131072)) {
#line 946
      packet_put_cstring("open failed");
#line 947
      packet_put_cstring("");
    }
#line 949
    packet_send();
  }
#line 951
  xfree((void *)ctype);
#line 952
  return;
}
}
#line 954 "serverloop.c"
static void server_input_global_request(int type , u_int32_t seq , void *ctxt ) 
{ char *rtype ;
  int want_reply ;
  int success ;
  void *tmp ;
  u_int tmp___0 ;
  struct passwd *pw ;
  char *listen_address ;
  u_short listen_port ;
  void *tmp___1 ;
  u_int tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 959
  success = 0;
#line 961
  tmp = packet_get_string((u_int *)((void *)0));
#line 961
  rtype = (char *)tmp;
#line 962
  tmp___0 = packet_get_char();
#line 962
  want_reply = (int )tmp___0;
#line 963
  debug("server_input_global_request: rtype %s want_reply %d", rtype, want_reply);
#line 966
  if (0) {
#line 966
    __s1_len = strlen((char const   *)rtype);
#line 966
    __s2_len = strlen("tcpip-forward");
#line 966
    if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
      goto _L___0;
    } else {
#line 966
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 966
        if (! ((unsigned int )((void const   *)("tcpip-forward" + 1)) - (unsigned int )((void const   *)"tcpip-forward") == 1U)) {
#line 966
          tmp___12 = 1;
        } else {
#line 966
          if (__s2_len >= 4U) {
#line 966
            tmp___12 = 1;
          } else {
#line 966
            tmp___12 = 0;
          }
        }
      } else {
#line 966
        tmp___12 = 0;
      }
    }
#line 966
    if (tmp___12) {
#line 966
      tmp___8 = __builtin_strcmp((char const   *)rtype, "tcpip-forward");
    } else {
#line 966
      tmp___11 = __builtin_strcmp((char const   *)rtype, "tcpip-forward");
#line 966
      tmp___8 = tmp___11;
    }
  } else {
#line 966
    tmp___11 = __builtin_strcmp((char const   *)rtype, "tcpip-forward");
#line 966
    tmp___8 = tmp___11;
  }
#line 966
  if (tmp___8 == 0) {
#line 971
    pw = the_authctxt->pw;
#line 972
    if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 973
      fatal("server_input_global_request: no/invalid user");
    } else {
#line 972
      if (! the_authctxt->valid) {
#line 973
        fatal("server_input_global_request: no/invalid user");
      }
    }
#line 974
    tmp___1 = packet_get_string((u_int *)((void *)0));
#line 974
    listen_address = (char *)tmp___1;
#line 975
    tmp___2 = packet_get_int();
#line 975
    listen_port = (unsigned short )tmp___2;
#line 976
    debug("server_input_global_request: tcpip-forward listen %s port %d", listen_address,
          listen_port);
#line 980
    if (! options.allow_tcp_forwarding) {
#line 986
      success = 0;
#line 987
      packet_send_debug("Server has disabled port forwarding.");
    } else {
#line 980
      if (no_port_forwarding_flag) {
#line 986
        success = 0;
#line 987
        packet_send_debug("Server has disabled port forwarding.");
      } else {
#line 980
        if ((int )listen_port < 1024) {
#line 980
          if (pw->pw_uid != 0U) {
#line 986
            success = 0;
#line 987
            packet_send_debug("Server has disabled port forwarding.");
          } else {
#line 990
            success = channel_setup_remote_fwd_listener((char const   *)listen_address,
                                                        listen_port, options.gateway_ports);
          }
        } else {
#line 990
          success = channel_setup_remote_fwd_listener((char const   *)listen_address,
                                                      listen_port, options.gateway_ports);
        }
      }
    }
#line 993
    xfree((void *)listen_address);
  }
#line 995
  if (want_reply) {
#line 996
    if (success) {
#line 996
      tmp___13 = 81;
    } else {
#line 996
      tmp___13 = 82;
    }
#line 996
    packet_start((unsigned char )tmp___13);
#line 998
    packet_send();
#line 999
    packet_write_wait();
  }
#line 1001
  xfree((void *)rtype);
#line 1002
  return;
}
}
#line 1003 "serverloop.c"
static void server_input_channel_req(int type , u_int32_t seq , void *ctxt ) 
{ Channel *c ;
  int id ;
  int reply ;
  int success ;
  char *rtype ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;

  {
#line 1007
  success = 0;
#line 1010
  tmp = packet_get_int();
#line 1010
  id = (int )tmp;
#line 1011
  tmp___0 = packet_get_string((u_int *)((void *)0));
#line 1011
  rtype = (char *)tmp___0;
#line 1012
  tmp___1 = packet_get_char();
#line 1012
  reply = (int )tmp___1;
#line 1014
  debug("server_input_channel_req: channel %d request %s reply %d", id, rtype, reply);
#line 1017
  c = channel_lookup(id);
#line 1017
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1018
    packet_disconnect("server_input_channel_req: unknown channel %d", id);
  }
#line 1020
  if (c->type == 10) {
#line 1021
    success = session_input_channel_req(c, (char const   *)rtype);
  } else {
#line 1020
    if (c->type == 4) {
#line 1021
      success = session_input_channel_req(c, (char const   *)rtype);
    }
  }
#line 1022
  if (reply) {
#line 1023
    if (success) {
#line 1023
      tmp___2 = 99;
    } else {
#line 1023
      tmp___2 = 100;
    }
#line 1023
    packet_start((unsigned char )tmp___2);
#line 1025
    packet_put_int((unsigned int )c->remote_id);
#line 1026
    packet_send();
  }
#line 1028
  xfree((void *)rtype);
#line 1029
  return;
}
}
#line 1031 "serverloop.c"
static void server_init_dispatch_20(void) 
{ 

  {
#line 1034
  debug("server_init_dispatch_20");
#line 1035
  dispatch_init(& dispatch_protocol_error);
#line 1036
  dispatch_set(97, & channel_input_oclose);
#line 1037
  dispatch_set(94, & channel_input_data);
#line 1038
  dispatch_set(96, & channel_input_ieof);
#line 1039
  dispatch_set(95, & channel_input_extended_data);
#line 1040
  dispatch_set(90, & server_input_channel_open);
#line 1041
  dispatch_set(91, & channel_input_open_confirmation);
#line 1042
  dispatch_set(92, & channel_input_open_failure);
#line 1043
  dispatch_set(98, & server_input_channel_req);
#line 1044
  dispatch_set(93, & channel_input_window_adjust);
#line 1045
  dispatch_set(80, & server_input_global_request);
#line 1047
  dispatch_set(100, & server_input_keep_alive);
#line 1048
  dispatch_set(81, & server_input_keep_alive);
#line 1049
  dispatch_set(82, & server_input_keep_alive);
#line 1051
  dispatch_set(20, & kex_input_kexinit);
#line 1052
  return;
}
}
#line 1053 "serverloop.c"
static void server_init_dispatch_13(void) 
{ 

  {
#line 1056
  debug("server_init_dispatch_13");
#line 1057
  dispatch_init((dispatch_fn *)((void *)0));
#line 1058
  dispatch_set(19, & server_input_eof);
#line 1059
  dispatch_set(16, & server_input_stdin_data);
#line 1060
  dispatch_set(11, & server_input_window_size);
#line 1061
  dispatch_set(24, & channel_input_close);
#line 1062
  dispatch_set(25, & channel_input_close_confirmation);
#line 1063
  dispatch_set(23, & channel_input_data);
#line 1064
  dispatch_set(21, & channel_input_open_confirmation);
#line 1065
  dispatch_set(22, & channel_input_open_failure);
#line 1066
  dispatch_set(29, & channel_input_port_open);
#line 1067
  return;
}
}
#line 1068 "serverloop.c"
static void server_init_dispatch_15(void) 
{ 

  {
#line 1071
  server_init_dispatch_13();
#line 1072
  debug("server_init_dispatch_15");
#line 1073
  dispatch_set(24, & channel_input_ieof);
#line 1074
  dispatch_set(25, & channel_input_oclose);
#line 1075
  return;
}
}
#line 1076 "serverloop.c"
static void server_init_dispatch(void) 
{ 

  {
#line 1079
  if (compat20) {
#line 1080
    server_init_dispatch_20();
  } else {
#line 1081
    if (compat13) {
#line 1082
      server_init_dispatch_13();
    } else {
#line 1084
      server_init_dispatch_15();
    }
  }
#line 1085
  return;
}
}
#line 1 "uidswap.o"
#line 199 "/usr/include/grp.h"
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 648 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
#line 651
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 656
extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t *__list ) ;
#line 684
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 694
extern  __attribute__((__nothrow__)) int setegid(__gid_t __gid ) ;
#line 710
extern  __attribute__((__nothrow__)) int setresuid(__uid_t __ruid , __uid_t __euid ,
                                                   __uid_t __suid ) ;
#line 715
extern  __attribute__((__nothrow__)) int setresgid(__gid_t __rgid , __gid_t __egid ,
                                                   __gid_t __sgid ) ;
#line 35 "uidswap.c"
static uid_t saved_euid  =    (uid_t )0;
#line 36 "uidswap.c"
static gid_t saved_egid  =    (gid_t )0;
#line 40 "uidswap.c"
static int privileged  =    0;
#line 41 "uidswap.c"
static int temporarily_use_uid_effective  =    0;
#line 42 "uidswap.c"
static gid_t *saved_egroups  =    (gid_t *)((void *)0);
#line 42 "uidswap.c"
static gid_t *user_groups  =    (gid_t *)((void *)0);
#line 43 "uidswap.c"
static int saved_egroupslen  =    -1;
#line 43 "uidswap.c"
static int user_groupslen  =    -1;
#line 49 "uidswap.c"
void temporarily_use_uid(struct passwd *pw ) 
{ int *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  void *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;

  {
#line 54
  saved_euid = geteuid();
#line 55
  saved_egid = getegid();
#line 56
  debug("temporarily_use_uid: %u/%u (e=%u/%u)", pw->pw_uid, pw->pw_gid, saved_euid,
        saved_egid);
#line 59
  if (saved_euid != 0U) {
#line 60
    privileged = 0;
#line 61
    return;
  }
#line 70
  privileged = 1;
#line 71
  temporarily_use_uid_effective = 1;
#line 73
  saved_egroupslen = getgroups(0, (__gid_t *)((void *)0));
#line 74
  if (saved_egroupslen < 0) {
#line 75
    tmp = __errno_location();
#line 75
    tmp___0 = strerror(*tmp);
#line 75
    fatal("getgroups: %.100s", tmp___0);
  }
#line 76
  if (saved_egroupslen > 0) {
#line 77
    tmp___1 = xrealloc((void *)saved_egroups, (unsigned int )saved_egroupslen * sizeof(gid_t ));
#line 77
    saved_egroups = (gid_t *)tmp___1;
#line 79
    tmp___4 = getgroups(saved_egroupslen, saved_egroups);
#line 79
    if (tmp___4 < 0) {
#line 80
      tmp___2 = __errno_location();
#line 80
      tmp___3 = strerror(*tmp___2);
#line 80
      fatal("getgroups: %.100s", tmp___3);
    }
  } else {
#line 82
    if ((unsigned int )saved_egroups != (unsigned int )((void *)0)) {
#line 83
      xfree((void *)saved_egroups);
    }
  }
#line 87
  if (user_groupslen == -1) {
#line 88
    tmp___7 = initgroups((char const   *)pw->pw_name, pw->pw_gid);
#line 88
    if (tmp___7 < 0) {
#line 89
      tmp___5 = __errno_location();
#line 89
      tmp___6 = strerror(*tmp___5);
#line 89
      fatal("initgroups: %s: %.100s", pw->pw_name, tmp___6);
    }
#line 92
    user_groupslen = getgroups(0, (__gid_t *)((void *)0));
#line 93
    if (user_groupslen < 0) {
#line 94
      tmp___8 = __errno_location();
#line 94
      tmp___9 = strerror(*tmp___8);
#line 94
      fatal("getgroups: %.100s", tmp___9);
    }
#line 95
    if (user_groupslen > 0) {
#line 96
      tmp___10 = xrealloc((void *)user_groups, (unsigned int )user_groupslen * sizeof(gid_t ));
#line 96
      user_groups = (gid_t *)tmp___10;
#line 98
      tmp___13 = getgroups(user_groupslen, user_groups);
#line 98
      if (tmp___13 < 0) {
#line 99
        tmp___11 = __errno_location();
#line 99
        tmp___12 = strerror(*tmp___11);
#line 99
        fatal("getgroups: %.100s", tmp___12);
      }
    } else {
#line 101
      if (user_groups) {
#line 102
        xfree((void *)user_groups);
      }
    }
  }
#line 106
  tmp___16 = setgroups((unsigned int )user_groupslen, (__gid_t const   *)user_groups);
#line 106
  if (tmp___16 < 0) {
#line 107
    tmp___14 = __errno_location();
#line 107
    tmp___15 = strerror(*tmp___14);
#line 107
    fatal("setgroups: %.100s", tmp___15);
  }
#line 116
  tmp___19 = setegid(pw->pw_gid);
#line 116
  if (tmp___19 < 0) {
#line 117
    tmp___17 = __errno_location();
#line 117
    tmp___18 = strerror(*tmp___17);
#line 117
    fatal("setegid %u: %.100s", pw->pw_gid, tmp___18);
  }
#line 119
  tmp___22 = seteuid(pw->pw_uid);
#line 119
  if (tmp___22 == -1) {
#line 120
    tmp___20 = __errno_location();
#line 120
    tmp___21 = strerror(*tmp___20);
#line 120
    fatal("seteuid %u: %.100s", pw->pw_uid, tmp___21);
  }
#line 122
  return;
}
}
#line 127 "uidswap.c"
void restore_uid(void) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
#line 131
  if (! privileged) {
#line 132
    debug("restore_uid: (unprivileged)");
#line 133
    return;
  }
#line 135
  if (! temporarily_use_uid_effective) {
#line 136
    fatal("restore_uid: temporarily_use_uid not effective");
  }
#line 139
  debug("restore_uid: %u/%u", saved_euid, saved_egid);
#line 141
  tmp___1 = seteuid(saved_euid);
#line 141
  if (tmp___1 < 0) {
#line 142
    tmp = __errno_location();
#line 142
    tmp___0 = strerror(*tmp);
#line 142
    fatal("seteuid %u: %.100s", saved_euid, tmp___0);
  }
#line 143
  tmp___4 = setegid(saved_egid);
#line 143
  if (tmp___4 < 0) {
#line 144
    tmp___2 = __errno_location();
#line 144
    tmp___3 = strerror(*tmp___2);
#line 144
    fatal("setegid %u: %.100s", saved_egid, tmp___3);
  }
#line 155
  tmp___7 = setgroups((unsigned int )saved_egroupslen, (__gid_t const   *)saved_egroups);
#line 155
  if (tmp___7 < 0) {
#line 156
    tmp___5 = __errno_location();
#line 156
    tmp___6 = strerror(*tmp___5);
#line 156
    fatal("setgroups: %.100s", tmp___6);
  }
#line 157
  temporarily_use_uid_effective = 0;
#line 158
  return;
}
}
#line 164 "uidswap.c"
void permanently_set_uid(struct passwd *pw ) 
{ uid_t old_uid ;
  __uid_t tmp ;
  gid_t old_gid ;
  __gid_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __gid_t tmp___9 ;
  __gid_t tmp___10 ;
  __gid_t tmp___11 ;
  __gid_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  __uid_t tmp___15 ;
  __uid_t tmp___16 ;
  __uid_t tmp___17 ;
  __uid_t tmp___18 ;

  {
#line 167
  tmp = getuid();
#line 167
  old_uid = tmp;
#line 168
  tmp___0 = getgid();
#line 168
  old_gid = tmp___0;
#line 170
  if (temporarily_use_uid_effective) {
#line 171
    fatal("permanently_set_uid: temporarily_use_uid effective");
  }
#line 172
  debug("permanently_set_uid: %u/%u", pw->pw_uid, pw->pw_gid);
#line 176
  tmp___3 = setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid);
#line 176
  if (tmp___3 < 0) {
#line 177
    tmp___1 = __errno_location();
#line 177
    tmp___2 = strerror(*tmp___1);
#line 177
    fatal("setresgid %u: %.100s", pw->pw_gid, tmp___2);
  }
#line 189
  tmp___6 = setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid);
#line 189
  if (tmp___6 < 0) {
#line 190
    tmp___4 = __errno_location();
#line 190
    tmp___5 = strerror(*tmp___4);
#line 190
    fatal("setresuid %u: %.100s", pw->pw_uid, tmp___5);
  }
#line 204
  if (old_gid != pw->pw_gid) {
#line 204
    tmp___7 = setgid(old_gid);
#line 204
    if (tmp___7 != -1) {
#line 206
      fatal("%s: was able to restore old [e]gid", "permanently_set_uid");
    } else {
#line 204
      tmp___8 = setegid(old_gid);
#line 204
      if (tmp___8 != -1) {
#line 206
        fatal("%s: was able to restore old [e]gid", "permanently_set_uid");
      }
    }
  }
#line 209
  tmp___11 = getgid();
#line 209
  if (tmp___11 != pw->pw_gid) {
#line 210
    tmp___9 = getegid();
#line 210
    tmp___10 = getgid();
#line 210
    fatal("%s: egid incorrect gid:%u egid:%u (should be %u)", "permanently_set_uid",
          tmp___10, tmp___9, pw->pw_gid);
  } else {
#line 209
    tmp___12 = getegid();
#line 209
    if (tmp___12 != pw->pw_gid) {
#line 210
      tmp___9 = getegid();
#line 210
      tmp___10 = getgid();
#line 210
      fatal("%s: egid incorrect gid:%u egid:%u (should be %u)", "permanently_set_uid",
            tmp___10, tmp___9, pw->pw_gid);
    }
  }
#line 217
  if (old_uid != pw->pw_uid) {
#line 217
    tmp___13 = setuid(old_uid);
#line 217
    if (tmp___13 != -1) {
#line 219
      fatal("%s: was able to restore old [e]uid", "permanently_set_uid");
    } else {
#line 217
      tmp___14 = seteuid(old_uid);
#line 217
      if (tmp___14 != -1) {
#line 219
        fatal("%s: was able to restore old [e]uid", "permanently_set_uid");
      }
    }
  }
#line 223
  tmp___17 = getuid();
#line 223
  if (tmp___17 != pw->pw_uid) {
#line 224
    tmp___15 = geteuid();
#line 224
    tmp___16 = getuid();
#line 224
    fatal("%s: euid incorrect uid:%u euid:%u (should be %u)", "permanently_set_uid",
          tmp___16, tmp___15, pw->pw_uid);
  } else {
#line 223
    tmp___18 = geteuid();
#line 223
    if (tmp___18 != pw->pw_uid) {
#line 224
      tmp___15 = geteuid();
#line 224
      tmp___16 = getuid();
#line 224
      fatal("%s: euid incorrect uid:%u euid:%u (should be %u)", "permanently_set_uid",
            tmp___16, tmp___15, pw->pw_uid);
    }
  }
#line 228
  return;
}
}
#line 1 "auth.o"
#line 759 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 756 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *realpath(char const   * __restrict  __name ,
                                                    char * __restrict  __resolved ) ;
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 218
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64") __attribute__((__nonnull__(2))) ;
#line 27 "/usr/include/libgen.h"
extern  __attribute__((__nothrow__)) char *dirname(char *__path ) ;
#line 32 "groupaccess.h"
int ga_init(char const   *user , gid_t base ) ;
#line 33
int ga_match(char * const  *groups , int n___0 ) ;
#line 34
void ga_free(void) ;
#line 128 "auth.h"
int auth_shadow_acctexpired(struct spwd *spw ) ;
#line 138
void auth_log(Authctxt *authctxt___0 , int authenticated , char *method , char *info ) ;
#line 140
int auth_root_allowed(char *method ) ;
#line 153
int allowed_user(struct passwd *pw ) ;
#line 154
struct passwd *getpwnamallow(char const   *user ) ;
#line 160
char *expand_filename(char const   *filename , struct passwd *pw ) ;
#line 162
char *authorized_keys_file2(struct passwd *pw ) ;
#line 182
struct passwd *fakepw(void) ;
#line 29 "auth-options.h"
char *forced_command ;
#line 60 "auth.c"
Buffer auth_debug  ;
#line 61 "auth.c"
int auth_debug_init  ;
#line 72 "auth.c"
int allowed_user(struct passwd *pw ) 
{ struct stat st ;
  char const   *hostname ;
  char const   *ipaddr ;
  char const   *passwd ;
  char *shell ;
  int i ;
  struct spwd *spw ;
  int tmp ;
  int locked ;
  int tmp___17 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___23 ;
  int tmp___26 ;
  int tmp___27 ;
  size_t tmp___28 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;

  {
#line 76
  hostname = (char const   *)((void *)0);
#line 76
  ipaddr = (char const   *)((void *)0);
#line 76
  passwd = (char const   *)((void *)0);
#line 80
  spw = (struct spwd *)((void *)0);
#line 84
  if (! pw) {
#line 85
    return (0);
  } else {
#line 84
    if (! pw->pw_name) {
#line 85
      return (0);
    }
  }
#line 88
  if (! options.use_pam) {
#line 89
    spw = getspnam((char const   *)pw->pw_name);
  }
#line 91
  if (! options.use_pam) {
#line 91
    if ((unsigned int )spw != (unsigned int )((void *)0)) {
#line 91
      tmp = auth_shadow_acctexpired(spw);
#line 91
      if (tmp) {
#line 92
        return (0);
      }
    }
  }
#line 98
  if ((unsigned int )spw != (unsigned int )((void *)0)) {
#line 99
    passwd = (char const   *)spw->sp_pwdp;
  }
#line 105
  if (! options.use_pam) {
#line 105
    if (passwd) {
#line 105
      if (*passwd) {
#line 106
        locked = 0;
#line 113
        if (0) {
#line 113
          if (0) {
#line 113
            __s1_len___0 = strlen(passwd);
#line 113
            __s2_len___0 = strlen("!");
#line 113
            if (! ((unsigned int )((void const   *)(passwd + 1)) - (unsigned int )((void const   *)passwd) == 1U)) {
              goto _L___2;
            } else {
#line 113
              if (__s1_len___0 >= 4U) {
                _L___2: /* CIL Label */ 
#line 113
                if (! ((unsigned int )((void const   *)("!" + 1)) - (unsigned int )((void const   *)"!") == 1U)) {
#line 113
                  tmp___27 = 1;
                } else {
#line 113
                  if (__s2_len___0 >= 4U) {
#line 113
                    tmp___27 = 1;
                  } else {
#line 113
                    tmp___27 = 0;
                  }
                }
              } else {
#line 113
                tmp___27 = 0;
              }
            }
#line 113
            if (tmp___27) {
#line 113
              tmp___23 = __builtin_strcmp(passwd, "!");
            } else {
#line 113
              tmp___26 = __builtin_strcmp(passwd, "!");
#line 113
              tmp___23 = tmp___26;
            }
          } else {
#line 113
            tmp___26 = __builtin_strcmp(passwd, "!");
#line 113
            tmp___23 = tmp___26;
          }
#line 113
          tmp___17 = tmp___23;
        } else {
#line 113
          tmp___28 = strlen("!");
#line 113
          tmp___17 = strncmp(passwd, "!", tmp___28);
        }
#line 113
        if (tmp___17 == 0) {
#line 115
          locked = 1;
        }
#line 121
        if (locked) {
#line 122
          logit("User %.100s not allowed because account is locked", pw->pw_name);
#line 124
          return (0);
        }
      }
    }
  }
#line 132
  if ((int )*(pw->pw_shell + 0) == 0) {
#line 132
    shell = (char *)"/bin/sh";
  } else {
#line 132
    shell = pw->pw_shell;
  }
#line 135
  tmp___34 = stat((char const   * __restrict  )shell, (struct stat * __restrict  )(& st));
#line 135
  if (tmp___34 != 0) {
#line 136
    logit("User %.100s not allowed because shell %.100s does not exist", pw->pw_name,
          shell);
#line 138
    return (0);
  }
#line 140
  if (((st.st_mode & 61440U) == 32768U) == 0) {
#line 142
    logit("User %.100s not allowed because shell %.100s is not executable", pw->pw_name,
          shell);
#line 144
    return (0);
  } else {
#line 140
    if ((st.st_mode & (unsigned int )((((64 >> 3) >> 3) | 64) | (64 >> 3))) == 0U) {
#line 142
      logit("User %.100s not allowed because shell %.100s is not executable", pw->pw_name,
            shell);
#line 144
      return (0);
    }
  }
#line 147
  if (options.num_deny_users > 0U) {
#line 148
    hostname = get_canonical_hostname(options.use_dns);
#line 149
    ipaddr = get_remote_ipaddr();
  } else {
#line 147
    if (options.num_allow_users > 0U) {
#line 148
      hostname = get_canonical_hostname(options.use_dns);
#line 149
      ipaddr = get_remote_ipaddr();
    }
  }
#line 153
  if (options.num_deny_users > 0U) {
#line 154
    i = 0;
#line 154
    while ((u_int )i < options.num_deny_users) {
#line 155
      tmp___35 = match_user((char const   *)pw->pw_name, hostname, ipaddr, (char const   *)options.deny_users[i]);
#line 155
      if (tmp___35) {
#line 157
        logit("User %.100s not allowed because listed in DenyUsers", pw->pw_name);
#line 159
        return (0);
      }
#line 154
      i ++;
    }
  }
#line 163
  if (options.num_allow_users > 0U) {
#line 164
    i = 0;
#line 164
    while ((u_int )i < options.num_allow_users) {
#line 165
      tmp___36 = match_user((char const   *)pw->pw_name, hostname, ipaddr, (char const   *)options.allow_users[i]);
#line 165
      if (tmp___36) {
#line 167
        break;
      }
#line 164
      i ++;
    }
#line 169
    if ((u_int )i >= options.num_allow_users) {
#line 170
      logit("User %.100s not allowed because not listed in AllowUsers", pw->pw_name);
#line 172
      return (0);
    }
  }
#line 175
  if (options.num_deny_groups > 0U) {
    goto _L___3;
  } else {
#line 175
    if (options.num_allow_groups > 0U) {
      _L___3: /* CIL Label */ 
#line 177
      tmp___37 = ga_init((char const   *)pw->pw_name, pw->pw_gid);
#line 177
      if (tmp___37 == 0) {
#line 178
        logit("User %.100s not allowed because not in any group", pw->pw_name);
#line 180
        return (0);
      }
#line 184
      if (options.num_deny_groups > 0U) {
#line 185
        tmp___38 = ga_match((char * const  *)(options.deny_groups), (int )options.num_deny_groups);
#line 185
        if (tmp___38) {
#line 187
          ga_free();
#line 188
          logit("User %.100s not allowed because a group is listed in DenyGroups",
                pw->pw_name);
#line 190
          return (0);
        }
      }
#line 196
      if (options.num_allow_groups > 0U) {
#line 197
        tmp___39 = ga_match((char * const  *)(options.allow_groups), (int )options.num_allow_groups);
#line 197
        if (! tmp___39) {
#line 199
          ga_free();
#line 200
          logit("User %.100s not allowed because none of user\'s groups are listed in AllowGroups",
                pw->pw_name);
#line 202
          return (0);
        }
      }
#line 204
      ga_free();
    }
  }
#line 234
  return (1);
}
}
#line 237 "auth.c"
void auth_log(Authctxt *authctxt___0 , int authenticated , char *method , char *info ) 
{ void (*authlog)(char const   *fmt  , ...) ;
  char *authmsg ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;

  {
#line 240
  authlog = (void (*)(char const   *fmt  , ...))(& verbose);
#line 247
  if (authenticated == 1) {
#line 248
    authlog = (void (*)(char const   *fmt  , ...))(& logit);
  } else {
#line 247
    if (! authctxt___0->valid) {
#line 248
      authlog = (void (*)(char const   *fmt  , ...))(& logit);
    } else {
#line 247
      if (authctxt___0->failures >= 3) {
#line 248
        authlog = (void (*)(char const   *fmt  , ...))(& logit);
      } else {
#line 247
        if (0) {
#line 247
          __s1_len = strlen((char const   *)method);
#line 247
          __s2_len = strlen("password");
#line 247
          if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
            goto _L___0;
          } else {
#line 247
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 247
              if (! ((unsigned int )((void const   *)("password" + 1)) - (unsigned int )((void const   *)"password") == 1U)) {
#line 247
                tmp___8 = 1;
              } else {
#line 247
                if (__s2_len >= 4U) {
#line 247
                  tmp___8 = 1;
                } else {
#line 247
                  tmp___8 = 0;
                }
              }
            } else {
#line 247
              tmp___8 = 0;
            }
          }
#line 247
          if (tmp___8) {
#line 247
            tmp___4 = __builtin_strcmp((char const   *)method, "password");
          } else {
#line 247
            tmp___7 = __builtin_strcmp((char const   *)method, "password");
#line 247
            tmp___4 = tmp___7;
          }
        } else {
#line 247
          tmp___7 = __builtin_strcmp((char const   *)method, "password");
#line 247
          tmp___4 = tmp___7;
        }
#line 247
        if (tmp___4 == 0) {
#line 248
          authlog = (void (*)(char const   *fmt  , ...))(& logit);
        }
      }
    }
  }
#line 250
  if (authctxt___0->postponed) {
#line 251
    authmsg = (char *)"Postponed";
  } else {
#line 253
    if (authenticated) {
#line 253
      authmsg = (char *)"Accepted";
    } else {
#line 253
      authmsg = (char *)"Failed";
    }
  }
#line 255
  tmp___9 = get_remote_port();
#line 255
  tmp___10 = get_remote_ipaddr();
#line 255
  if (authctxt___0->valid) {
#line 255
    tmp___11 = "";
  } else {
#line 255
    tmp___11 = "illegal user ";
  }
#line 255
  (*authlog)("%s %s for %s%.100s from %.200s port %d%s", authmsg, method, tmp___11,
             authctxt___0->user, tmp___10, tmp___9, info);
#line 268
  return;
}
}
#line 273 "auth.c"
int auth_root_allowed(char *method ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;

  {
#line 276
  switch (options.permit_root_login) {
  case 3: 
#line 278
  return (1);
#line 279
  break;
  case 2: 
#line 281
  if (0) {
#line 281
    __s1_len = strlen((char const   *)method);
#line 281
    __s2_len = strlen("password");
#line 281
    if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
      goto _L___0;
    } else {
#line 281
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 281
        if (! ((unsigned int )((void const   *)("password" + 1)) - (unsigned int )((void const   *)"password") == 1U)) {
#line 281
          tmp___8 = 1;
        } else {
#line 281
          if (__s2_len >= 4U) {
#line 281
            tmp___8 = 1;
          } else {
#line 281
            tmp___8 = 0;
          }
        }
      } else {
#line 281
        tmp___8 = 0;
      }
    }
#line 281
    if (tmp___8) {
#line 281
      tmp___4 = __builtin_strcmp((char const   *)method, "password");
    } else {
#line 281
      tmp___7 = __builtin_strcmp((char const   *)method, "password");
#line 281
      tmp___4 = tmp___7;
    }
  } else {
#line 281
    tmp___7 = __builtin_strcmp((char const   *)method, "password");
#line 281
    tmp___4 = tmp___7;
  }
#line 281
  if (tmp___4 != 0) {
#line 282
    return (1);
  }
#line 283
  break;
  case 1: 
#line 285
  if (forced_command) {
#line 286
    logit("Root login accepted for forced command.");
#line 287
    return (1);
  }
#line 289
  break;
  }
#line 291
  tmp___9 = get_remote_ipaddr();
#line 291
  logit("ROOT LOGIN REFUSED FROM %.200s", tmp___9);
#line 292
  return (0);
}
}
#line 303 "auth.c"
char *expand_filename(char const   *filename , struct passwd *pw ) 
{ Buffer buffer ;
  char *file___0 ;
  char const   *cp ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 314
  buffer_init(& buffer);
#line 315
  cp = filename;
#line 315
  while (*cp) {
#line 316
    if ((int const   )*(cp + 0) == 37) {
#line 316
      if ((int const   )*(cp + 1) == 37) {
#line 317
        buffer_append(& buffer, (void const   *)"%", 1U);
#line 318
        cp ++;
        goto __Cont;
      }
    }
#line 321
    if ((int const   )*(cp + 0) == 37) {
#line 321
      if ((int const   )*(cp + 1) == 104) {
#line 322
        tmp = strlen((char const   *)pw->pw_dir);
#line 322
        buffer_append(& buffer, (void const   *)pw->pw_dir, tmp);
#line 323
        cp ++;
        goto __Cont;
      }
    }
#line 326
    if ((int const   )*(cp + 0) == 37) {
#line 326
      if ((int const   )*(cp + 1) == 117) {
#line 327
        tmp___0 = strlen((char const   *)pw->pw_name);
#line 327
        buffer_append(& buffer, (void const   *)pw->pw_name, tmp___0);
#line 329
        cp ++;
        goto __Cont;
      }
    }
#line 332
    buffer_append(& buffer, (void const   *)cp, 1U);
    __Cont: /* CIL Label */ 
#line 315
    cp ++;
  }
#line 334
  buffer_append(& buffer, (void const   *)"\000", 1U);
#line 340
  tmp___1 = xmalloc(4096U);
#line 340
  file___0 = (char *)tmp___1;
#line 341
  tmp___2 = buffer_ptr(& buffer);
#line 341
  cp = (char const   *)tmp___2;
#line 342
  if ((int const   )*cp != 47) {
#line 343
    snprintf((char * __restrict  )file___0, 4096U, (char const   * __restrict  )"%s/%s",
             pw->pw_dir, cp);
  } else {
#line 345
    strlcpy(file___0, cp, 4096U);
  }
#line 347
  buffer_free(& buffer);
#line 348
  return (file___0);
}
}
#line 351 "auth.c"
char *authorized_keys_file(struct passwd *pw ) 
{ char *tmp ;

  {
#line 354
  tmp = expand_filename((char const   *)options.authorized_keys_file, pw);
#line 354
  return (tmp);
}
}
#line 357 "auth.c"
char *authorized_keys_file2(struct passwd *pw ) 
{ char *tmp ;

  {
#line 360
  tmp = expand_filename((char const   *)options.authorized_keys_file2, pw);
#line 360
  return (tmp);
}
}
#line 364 "auth.c"
HostStatus check_key_in_hostfiles(struct passwd *pw , Key *key , char const   *host ,
                                  char const   *sysfile , char const   *userfile ) 
{ Key *found ;
  char *user_hostfile ;
  struct stat st ;
  HostStatus host_status ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 374
  found = key_new(key->type);
#line 375
  host_status = check_host_in_hostfile(sysfile, host, (Key const   *)key, found, (int *)((void *)0));
#line 377
  if ((int )host_status != 0) {
#line 377
    if ((unsigned int )userfile != (unsigned int )((void *)0)) {
#line 378
      user_hostfile = tilde_expand_filename(userfile, pw->pw_uid);
#line 379
      if (options.strict_modes) {
#line 379
        tmp = stat((char const   * __restrict  )user_hostfile, (struct stat * __restrict  )(& st));
#line 379
        if (tmp == 0) {
#line 379
          if (st.st_uid != 0U) {
#line 379
            if (st.st_uid != pw->pw_uid) {
#line 383
              logit("Authentication refused for %.100s: bad owner or modes for %.200s",
                    pw->pw_name, user_hostfile);
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 379
            if ((st.st_mode & 18U) != 0U) {
#line 383
              logit("Authentication refused for %.100s: bad owner or modes for %.200s",
                    pw->pw_name, user_hostfile);
            } else {
#line 387
              temporarily_use_uid(pw);
#line 388
              host_status = check_host_in_hostfile((char const   *)user_hostfile,
                                                   host, (Key const   *)key, found,
                                                   (int *)((void *)0));
#line 390
              restore_uid();
            }
          }
        } else {
#line 387
          temporarily_use_uid(pw);
#line 388
          host_status = check_host_in_hostfile((char const   *)user_hostfile, host,
                                               (Key const   *)key, found, (int *)((void *)0));
#line 390
          restore_uid();
        }
      } else {
#line 387
        temporarily_use_uid(pw);
#line 388
        host_status = check_host_in_hostfile((char const   *)user_hostfile, host,
                                             (Key const   *)key, found, (int *)((void *)0));
#line 390
        restore_uid();
      }
#line 392
      xfree((void *)user_hostfile);
    }
  }
#line 394
  key_free(found);
#line 396
  if ((int )host_status == 0) {
#line 396
    tmp___0 = "ok";
  } else {
#line 396
    tmp___0 = "not found";
  }
#line 396
  debug2("check_key_in_hostfiles: key %s for %s", tmp___0, host);
#line 398
  return (host_status);
}
}
#line 414 "auth.c"
int secure_filename(FILE *f , char const   *file___0 , struct passwd *pw , char *err ,
                    size_t errlen ) 
{ uid_t uid ;
  char buf___1[4096] ;
  char homedir[4096] ;
  char *cp ;
  int comparehome ;
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___11 ;
  int tmp___14 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___31 ;
  int tmp___34 ;
  int tmp___35 ;

  {
#line 418
  uid = pw->pw_uid;
#line 421
  comparehome = 0;
#line 424
  tmp___1 = realpath((char const   * __restrict  )file___0, (char * __restrict  )(buf___1));
#line 424
  if ((unsigned int )tmp___1 == (unsigned int )((void *)0)) {
#line 425
    tmp = __errno_location();
#line 425
    tmp___0 = strerror(*tmp);
#line 425
    snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"realpath %s failed: %s",
             file___0, tmp___0);
#line 427
    return (-1);
  }
#line 429
  tmp___2 = realpath((char const   * __restrict  )pw->pw_dir, (char * __restrict  )(homedir));
#line 429
  if ((unsigned int )tmp___2 != (unsigned int )((void *)0)) {
#line 430
    comparehome = 1;
  }
#line 433
  tmp___3 = fileno(f);
#line 433
  tmp___4 = fstat(tmp___3, & st);
#line 433
  if (tmp___4 < 0) {
#line 436
    snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for file %s",
             buf___1);
#line 438
    return (-1);
  } else {
#line 433
    if (st.st_uid != 0U) {
#line 433
      if (st.st_uid != uid) {
#line 436
        snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for file %s",
                 buf___1);
#line 438
        return (-1);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 433
      if ((st.st_mode & 18U) != 0U) {
#line 436
        snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for file %s",
                 buf___1);
#line 438
        return (-1);
      }
    }
  }
#line 442
  while (1) {
#line 443
    cp = dirname(buf___1);
#line 443
    if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 444
      snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"dirname() failed");
#line 445
      return (-1);
    }
#line 447
    strlcpy(buf___1, (char const   *)cp, sizeof(buf___1));
#line 449
    debug3("secure_filename: checking \'%s\'", buf___1);
#line 450
    tmp___5 = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )(& st));
#line 450
    if (tmp___5 < 0) {
#line 453
      snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for directory %s",
               buf___1);
#line 455
      return (-1);
    } else {
#line 450
      if (st.st_uid != 0U) {
#line 450
        if (st.st_uid != uid) {
#line 453
          snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for directory %s",
                   buf___1);
#line 455
          return (-1);
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 450
        if ((st.st_mode & 18U) != 0U) {
#line 453
          snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for directory %s",
                   buf___1);
#line 455
          return (-1);
        }
      }
    }
#line 459
    if (comparehome) {
#line 459
      if (0) {
#line 459
        __s1_len = strlen((char const   *)(homedir));
#line 459
        __s2_len = strlen((char const   *)(buf___1));
#line 459
        if (! ((unsigned int )((void const   *)(homedir + 1)) - (unsigned int )((void const   *)(homedir)) == 1U)) {
          goto _L___2;
        } else {
#line 459
          if (__s1_len >= 4U) {
            _L___2: /* CIL Label */ 
#line 459
            if (! ((unsigned int )((void const   *)(buf___1 + 1)) - (unsigned int )((void const   *)(buf___1)) == 1U)) {
#line 459
              tmp___15 = 1;
            } else {
#line 459
              if (__s2_len >= 4U) {
#line 459
                tmp___15 = 1;
              } else {
#line 459
                tmp___15 = 0;
              }
            }
          } else {
#line 459
            tmp___15 = 0;
          }
        }
#line 459
        if (tmp___15) {
#line 459
          tmp___11 = __builtin_strcmp((char const   *)(homedir), (char const   *)(buf___1));
        } else {
#line 459
          tmp___14 = __builtin_strcmp((char const   *)(homedir), (char const   *)(buf___1));
#line 459
          tmp___11 = tmp___14;
        }
      } else {
#line 459
        tmp___14 = __builtin_strcmp((char const   *)(homedir), (char const   *)(buf___1));
#line 459
        tmp___11 = tmp___14;
      }
#line 459
      if (tmp___11 == 0) {
#line 460
        debug3("secure_filename: terminating check at \'%s\'", buf___1);
#line 462
        break;
      }
    }
#line 468
    if (0) {
#line 468
      __s1_len___0 = strlen("/");
#line 468
      __s2_len___0 = strlen((char const   *)(buf___1));
#line 468
      if (! ((unsigned int )((void const   *)("/" + 1)) - (unsigned int )((void const   *)"/") == 1U)) {
        goto _L___4;
      } else {
#line 468
        if (__s1_len___0 >= 4U) {
          _L___4: /* CIL Label */ 
#line 468
          if (! ((unsigned int )((void const   *)(buf___1 + 1)) - (unsigned int )((void const   *)(buf___1)) == 1U)) {
#line 468
            tmp___25 = 1;
          } else {
#line 468
            if (__s2_len___0 >= 4U) {
#line 468
              tmp___25 = 1;
            } else {
#line 468
              tmp___25 = 0;
            }
          }
        } else {
#line 468
          tmp___25 = 0;
        }
      }
#line 468
      if (tmp___25) {
#line 468
        tmp___21 = __builtin_strcmp("/", (char const   *)(buf___1));
      } else {
#line 468
        tmp___24 = __builtin_strcmp("/", (char const   *)(buf___1));
#line 468
        tmp___21 = tmp___24;
      }
    } else {
#line 468
      tmp___24 = __builtin_strcmp("/", (char const   *)(buf___1));
#line 468
      tmp___21 = tmp___24;
    }
#line 468
    if (tmp___21 == 0) {
#line 469
      break;
    } else {
#line 468
      if (0) {
#line 468
        __s1_len___1 = strlen(".");
#line 468
        __s2_len___1 = strlen((char const   *)(buf___1));
#line 468
        if (! ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") == 1U)) {
          goto _L___6;
        } else {
#line 468
          if (__s1_len___1 >= 4U) {
            _L___6: /* CIL Label */ 
#line 468
            if (! ((unsigned int )((void const   *)(buf___1 + 1)) - (unsigned int )((void const   *)(buf___1)) == 1U)) {
#line 468
              tmp___35 = 1;
            } else {
#line 468
              if (__s2_len___1 >= 4U) {
#line 468
                tmp___35 = 1;
              } else {
#line 468
                tmp___35 = 0;
              }
            }
          } else {
#line 468
            tmp___35 = 0;
          }
        }
#line 468
        if (tmp___35) {
#line 468
          tmp___31 = __builtin_strcmp(".", (char const   *)(buf___1));
        } else {
#line 468
          tmp___34 = __builtin_strcmp(".", (char const   *)(buf___1));
#line 468
          tmp___31 = tmp___34;
        }
      } else {
#line 468
        tmp___34 = __builtin_strcmp(".", (char const   *)(buf___1));
#line 468
        tmp___31 = tmp___34;
      }
#line 468
      if (tmp___31 == 0) {
#line 469
        break;
      }
    }
  }
#line 471
  return (0);
}
}
#line 474 "auth.c"
struct passwd *getpwnamallow(char const   *user ) 
{ struct passwd *pw ;
  char const   *tmp ;
  int tmp___0 ;
  struct passwd *tmp___1 ;

  {
#line 485
  pw = getpwnam(user);
#line 486
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 487
    tmp = get_remote_ipaddr();
#line 487
    logit("Illegal user %.100s from %.100s", user, tmp);
#line 492
    return ((struct passwd *)((void *)0));
  }
#line 494
  tmp___0 = allowed_user(pw);
#line 494
  if (! tmp___0) {
#line 495
    return ((struct passwd *)((void *)0));
  }
#line 511
  if ((unsigned int )pw != (unsigned int )((void *)0)) {
#line 512
    tmp___1 = pwcopy(pw);
#line 512
    return (tmp___1);
  }
#line 513
  return ((struct passwd *)((void *)0));
}
}
#line 516 "auth.c"
void ( /* format attribute */  auth_debug_add)(char const   *fmt  , ...) 
{ char buf___1[1024] ;
  va_list args ;

  {
#line 522
  if (! auth_debug_init) {
#line 523
    return;
  }
#line 525
  __builtin_va_start(args, fmt);
#line 526
  vsnprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )fmt,
            args);
#line 527
  __builtin_va_end(args);
#line 528
  buffer_put_cstring(& auth_debug, (char const   *)(buf___1));
#line 529
  return;
}
}
#line 531 "auth.c"
void auth_debug_send(void) 
{ char *msg ;
  void *tmp ;
  u_int tmp___0 ;

  {
#line 536
  if (! auth_debug_init) {
#line 537
    return;
  }
#line 538
  while (1) {
#line 538
    tmp___0 = buffer_len(& auth_debug);
#line 538
    if (! tmp___0) {
#line 538
      break;
    }
#line 539
    tmp = buffer_get_string(& auth_debug, (u_int *)((void *)0));
#line 539
    msg = (char *)tmp;
#line 540
    packet_send_debug("%s", msg);
#line 541
    xfree((void *)msg);
  }
#line 543
  return;
}
}
#line 545 "auth.c"
void auth_debug_reset(void) 
{ 

  {
#line 548
  if (auth_debug_init) {
#line 549
    buffer_clear(& auth_debug);
  } else {
#line 551
    buffer_init(& auth_debug);
#line 552
    auth_debug_init = 1;
  }
#line 554
  return;
}
}
#line 559 "auth.c"
static struct passwd fake  ;
#line 556 "auth.c"
struct passwd *fakepw(void) 
{ 

  {
#line 561
  memset((void *)(& fake), 0, sizeof(fake));
#line 562
  fake.pw_name = (char *)"NOUSER";
#line 563
  fake.pw_passwd = (char *)"$2a$06$r3.juUaHZDlIbQaO2dS9FuYxL1W9M81R1Tc92PoSNmzvpEqLkLGrK";
#line 565
  fake.pw_gecos = (char *)"NOUSER";
#line 566
  fake.pw_uid = 4294967295U;
#line 567
  fake.pw_gid = 4294967295U;
#line 571
  fake.pw_dir = (char *)"/nonexist";
#line 572
  fake.pw_shell = (char *)"/nonexist";
#line 574
  return (& fake);
}
}
#line 1 "auth1.o"
#line 156 "auth.h"
char *get_challenge(Authctxt *authctxt___0 ) ;
#line 157
int verify_response(Authctxt *authctxt___0 , char const   *response ) ;
#line 158
void abandon_challenge_response(Authctxt *authctxt___0 ) ;
#line 47 "monitor_wrap.h"
struct passwd *mm_getpwnamallow(char const   *login___0 ) ;
#line 49
int mm_auth_password(struct Authctxt *authctxt___0 , char *password ) ;
#line 39 "auth1.c"
static char buf[1024]  ;
#line 36 "auth1.c"
static char *get_authname(int type ) 
{ 

  {
#line 40
  switch (type) {
  case 9: 
#line 42
  return ((char *)"password");
  case 6: 
#line 44
  return ((char *)"rsa");
  case 35: 
#line 46
  return ((char *)"rhosts-rsa");
  case 5: 
#line 48
  return ((char *)"rhosts");
  case 39: 
  case 41: 
#line 51
  return ((char *)"challenge-response");
  }
#line 53
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"bad-auth-msg-%d",
           type);
#line 54
  return (buf);
}
}
#line 61 "auth1.c"
static void do_authloop(Authctxt *authctxt___0 ) 
{ int authenticated ;
  u_int bits ;
  Key *client_host_key ;
  BIGNUM *n___0 ;
  char *client_user ;
  char *password ;
  char info[1024] ;
  u_int dlen ;
  u_int ulen ;
  int prev ;
  int type ;
  struct passwd *pw ;
  char const   *tmp ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int _len ;
  int tmp___6 ;
  int _len___0 ;
  int tmp___7 ;
  void *tmp___8 ;
  int _len___1 ;
  int tmp___9 ;
  size_t tmp___12 ;
  char *challenge ;
  char *tmp___13 ;
  char *response ;
  void *tmp___14 ;
  int _len___2 ;
  int tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;

  {
#line 64
  authenticated = 0;
#line 72
  type = 0;
#line 73
  pw = authctxt___0->pw;
#line 75
  if (authctxt___0->valid) {
#line 75
    tmp = "";
  } else {
#line 75
    tmp = "illegal user ";
  }
#line 75
  debug("Attempting authentication for %s%.100s.", tmp, authctxt___0->user);
#line 79
  if (options.password_authentication) {
#line 79
    if (use_privsep) {
#line 79
      tmp___2 = mm_auth_password(authctxt___0, (char *)"");
    } else {
#line 79
      tmp___2 = auth_password(authctxt___0, "");
    }
#line 79
    if (tmp___2) {
#line 84
      auth_log(authctxt___0, 1, (char *)"without authentication", (char *)"");
#line 85
      return;
    }
  }
#line 89
  packet_start((unsigned char)15);
#line 90
  packet_send();
#line 91
  packet_write_wait();
#line 93
  client_user = (char *)((void *)0);
#line 95
  while (1) {
#line 97
    authenticated = 0;
#line 99
    info[0] = (char )'\000';
#line 102
    prev = type;
#line 103
    type = packet_read();
#line 112
    if (prev == 39) {
#line 112
      if (type != 41) {
#line 114
        abandon_challenge_response(authctxt___0);
      }
    }
#line 117
    switch (type) {
    case 35: 
#line 119
    if (! options.rhosts_rsa_authentication) {
#line 120
      verbose("Rhosts with RSA authentication disabled.");
#line 121
      break;
    }
#line 128
    tmp___3 = packet_get_string(& ulen);
#line 128
    client_user = (char *)tmp___3;
#line 131
    client_host_key = key_new(0);
#line 132
    bits = packet_get_int();
#line 133
    packet_get_bignum((client_host_key->rsa)->e);
#line 134
    packet_get_bignum((client_host_key->rsa)->n);
#line 136
    tmp___5 = BN_num_bits((BIGNUM const   *)(client_host_key->rsa)->n);
#line 136
    if (bits != (u_int )tmp___5) {
#line 137
      tmp___4 = BN_num_bits((BIGNUM const   *)(client_host_key->rsa)->n);
#line 137
      verbose("Warning: keysize mismatch for client_host_key: actual %d, announced %d",
              tmp___4, bits);
    }
#line 140
    while (1) {
#line 140
      tmp___6 = packet_remaining();
#line 140
      _len = tmp___6;
#line 140
      if (_len > 0) {
#line 140
        logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth1.c",
              140);
#line 140
        packet_disconnect("Packet integrity error.");
      }
#line 140
      break;
    }
#line 142
    authenticated = auth_rhosts_rsa(authctxt___0, client_user, client_host_key);
#line 144
    key_free(client_host_key);
#line 146
    snprintf((char * __restrict  )(info), sizeof(info), (char const   * __restrict  )" ruser %.100s",
             client_user);
#line 147
    break;
    case 6: 
#line 150
    if (! options.rsa_authentication) {
#line 151
      verbose("RSA authentication disabled.");
#line 152
      break;
    }
#line 155
    n___0 = BN_new();
#line 155
    if ((unsigned int )n___0 == (unsigned int )((void *)0)) {
#line 156
      fatal("do_authloop: BN_new failed");
    }
#line 157
    packet_get_bignum(n___0);
#line 158
    while (1) {
#line 158
      tmp___7 = packet_remaining();
#line 158
      _len___0 = tmp___7;
#line 158
      if (_len___0 > 0) {
#line 158
        logit("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "auth1.c",
              158);
#line 158
        packet_disconnect("Packet integrity error.");
      }
#line 158
      break;
    }
#line 159
    authenticated = auth_rsa(authctxt___0, n___0);
#line 160
    BN_clear_free(n___0);
#line 161
    break;
    case 9: 
#line 164
    if (! options.password_authentication) {
#line 165
      verbose("Password authentication disabled.");
#line 166
      break;
    }
#line 173
    tmp___8 = packet_get_string(& dlen);
#line 173
    password = (char *)tmp___8;
#line 174
    while (1) {
#line 174
      tmp___9 = packet_remaining();
#line 174
      _len___1 = tmp___9;
#line 174
      if (_len___1 > 0) {
#line 174
        logit("Packet integrity error (%d bytes remaining) at %s:%d", _len___1, "auth1.c",
              174);
#line 174
        packet_disconnect("Packet integrity error.");
      }
#line 174
      break;
    }
#line 177
    if (use_privsep) {
#line 177
      authenticated = mm_auth_password(authctxt___0, password);
    } else {
#line 177
      authenticated = auth_password(authctxt___0, (char const   *)password);
    }
#line 179
    tmp___12 = strlen((char const   *)password);
#line 179
    memset((void *)password, 0, tmp___12);
#line 180
    xfree((void *)password);
#line 181
    break;
    case 39: 
#line 184
    debug("rcvd SSH_CMSG_AUTH_TIS");
#line 185
    if (options.challenge_response_authentication == 1) {
#line 186
      tmp___13 = get_challenge(authctxt___0);
#line 186
      challenge = tmp___13;
#line 187
      if ((unsigned int )challenge != (unsigned int )((void *)0)) {
#line 188
        debug("sending challenge \'%s\'", challenge);
#line 189
        packet_start((unsigned char)40);
#line 190
        packet_put_cstring((char const   *)challenge);
#line 191
        xfree((void *)challenge);
#line 192
        packet_send();
#line 193
        packet_write_wait();
        goto __Cont;
      }
    }
#line 197
    break;
    case 41: 
#line 199
    debug("rcvd SSH_CMSG_AUTH_TIS_RESPONSE");
#line 200
    if (options.challenge_response_authentication == 1) {
#line 201
      tmp___14 = packet_get_string(& dlen);
#line 201
      response = (char *)tmp___14;
#line 202
      while (1) {
#line 202
        tmp___15 = packet_remaining();
#line 202
        _len___2 = tmp___15;
#line 202
        if (_len___2 > 0) {
#line 202
          logit("Packet integrity error (%d bytes remaining) at %s:%d", _len___2,
                "auth1.c", 202);
#line 202
          packet_disconnect("Packet integrity error.");
        }
#line 202
        break;
      }
#line 203
      authenticated = verify_response(authctxt___0, (char const   *)response);
#line 204
      memset((void *)response, 'r', dlen);
#line 205
      xfree((void *)response);
    }
#line 207
    break;
    default: 
#line 214
    logit("Unknown message during authentication: type %d", type);
#line 215
    break;
    }
#line 223
    if (! authctxt___0->valid) {
#line 223
      if (authenticated) {
#line 224
        fatal("INTERNAL ERROR: authenticated invalid user %s", authctxt___0->user);
      }
    }
#line 243
    if (authenticated) {
#line 243
      if ((authctxt___0->pw)->pw_uid == 0U) {
#line 243
        tmp___16 = get_authname(type);
#line 243
        tmp___17 = auth_root_allowed(tmp___16);
#line 243
        if (! tmp___17) {
#line 245
          authenticated = 0;
        }
      }
    }
#line 255
    tmp___18 = get_authname(type);
#line 255
    auth_log(authctxt___0, authenticated, tmp___18, info);
#line 257
    if ((unsigned int )client_user != (unsigned int )((void *)0)) {
#line 258
      xfree((void *)client_user);
#line 259
      client_user = (char *)((void *)0);
    }
#line 262
    if (authenticated) {
#line 263
      return;
    }
#line 265
    tmp___19 = authctxt___0->failures;
#line 265
    (authctxt___0->failures) ++;
#line 265
    if (tmp___19 > 6) {
#line 266
      packet_disconnect("Too many authentication failures for %.100s", authctxt___0->user);
    }
#line 268
    packet_start((unsigned char)15);
#line 269
    packet_send();
#line 270
    packet_write_wait();
    __Cont: /* CIL Label */ ;
  }
}
}
#line 278 "auth1.c"
void do_authentication(Authctxt *authctxt___0 ) 
{ u_int ulen ;
  char *user ;
  char *style ;
  void *tmp ;
  int _len ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___3 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  __uid_t tmp___8 ;
  __uid_t tmp___9 ;

  {
#line 282
  style = (char *)((void *)0);
#line 285
  packet_read_expect(4);
#line 288
  tmp = packet_get_string(& ulen);
#line 288
  user = (char *)tmp;
#line 289
  while (1) {
#line 289
    tmp___0 = packet_remaining();
#line 289
    _len = tmp___0;
#line 289
    if (_len > 0) {
#line 289
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth1.c",
            289);
#line 289
      packet_disconnect("Packet integrity error.");
    }
#line 289
    break;
  }
#line 291
  tmp___3 = __builtin_strchr(user, ':');
#line 291
  style = tmp___3;
#line 291
  if ((unsigned int )style != (unsigned int )((void *)0)) {
#line 292
    tmp___1 = style;
#line 292
    style ++;
#line 292
    *tmp___1 = (char )'\000';
  }
#line 294
  authctxt___0->user = user;
#line 295
  authctxt___0->style = style;
#line 298
  if (use_privsep) {
#line 298
    authctxt___0->pw = mm_getpwnamallow((char const   *)user);
  } else {
#line 298
    authctxt___0->pw = getpwnamallow((char const   *)user);
  }
#line 298
  if ((unsigned int )authctxt___0->pw != (unsigned int )((void *)0)) {
#line 299
    authctxt___0->valid = 1;
  } else {
#line 301
    debug("do_authentication: illegal user %s", user);
#line 302
    authctxt___0->pw = fakepw();
  }
#line 305
  if (use_privsep) {
#line 305
    tmp___6 = " [net]";
  } else {
#line 305
    tmp___6 = "";
  }
#line 305
  if (authctxt___0->pw) {
#line 305
    tmp___7 = (char const   *)user;
  } else {
#line 305
    tmp___7 = "unknown";
  }
#line 305
  setproctitle("%s%s", tmp___7, tmp___6);
#line 318
  if (! use_privsep) {
#line 318
    tmp___8 = getuid();
#line 318
    if (tmp___8 != 0U) {
#line 318
      if (authctxt___0->pw) {
#line 318
        tmp___9 = getuid();
#line 318
        if ((authctxt___0->pw)->pw_uid != tmp___9) {
#line 320
          packet_disconnect("Cannot change user when server not running as root.");
        }
      }
    }
  }
#line 327
  do_authloop(authctxt___0);
#line 330
  packet_start((unsigned char)14);
#line 331
  packet_send();
#line 332
  packet_write_wait();
#line 333
  return;
}
}
#line 1 "auth2.o"
#line 139 "auth.h"
void userauth_finish(Authctxt *authctxt___0 , int authenticated , char *method ) ;
#line 147
void auth2_challenge_stop(Authctxt *authctxt___0 ) ;
#line 46 "monitor_wrap.h"
void mm_inform_authserv(char *service , char *style ) ;
#line 50 "auth2.c"
Authmethod method_none ;
#line 51
Authmethod method_pubkey ;
#line 52
Authmethod method_passwd ;
#line 53
Authmethod method_kbdint ;
#line 54
Authmethod method_hostbased ;
#line 59 "auth2.c"
Authmethod *authmethods[6]  = {      & method_none,      & method_pubkey,      & method_passwd,      & method_kbdint, 
        & method_hostbased,      (Authmethod *)((void *)0)};
#line 73
static void input_service_request(int type , u_int32_t seq , void *ctxt ) ;
#line 74
static void input_userauth_request(int type , u_int32_t seq , void *ctxt ) ;
#line 77
static Authmethod *authmethod_lookup(char const   *name ) ;
#line 78
static char *authmethods_get(void) ;
#line 85 "auth2.c"
void do_authentication2(Authctxt *authctxt___0 ) 
{ 

  {
#line 89
  if (options.challenge_response_authentication) {
#line 90
    options.kbd_interactive_authentication = 1;
  }
#line 92
  dispatch_init(& dispatch_protocol_error);
#line 93
  dispatch_set(5, & input_service_request);
#line 94
  dispatch_run(0, & authctxt___0->success, (void *)authctxt___0);
#line 95
  return;
}
}
#line 97 "auth2.c"
static void input_service_request(int type , u_int32_t seq , void *ctxt ) 
{ Authctxt *authctxt___0 ;
  u_int len ;
  int acceptit ;
  char *service ;
  void *tmp ;
  int _len ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 100
  authctxt___0 = (Authctxt *)ctxt;
#line 102
  acceptit = 0;
#line 103
  tmp = packet_get_string(& len);
#line 103
  service = (char *)tmp;
#line 104
  while (1) {
#line 104
    tmp___0 = packet_remaining();
#line 104
    _len = tmp___0;
#line 104
    if (_len > 0) {
#line 104
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
            104);
#line 104
      packet_disconnect("Packet integrity error.");
    }
#line 104
    break;
  }
#line 106
  if ((unsigned int )authctxt___0 == (unsigned int )((void *)0)) {
#line 107
    fatal("input_service_request: no authctxt");
  }
#line 109
  if (0) {
#line 109
    __s1_len = strlen((char const   *)service);
#line 109
    __s2_len = strlen("ssh-userauth");
#line 109
    if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
      goto _L___0;
    } else {
#line 109
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 109
        if (! ((unsigned int )((void const   *)("ssh-userauth" + 1)) - (unsigned int )((void const   *)"ssh-userauth") == 1U)) {
#line 109
          tmp___10 = 1;
        } else {
#line 109
          if (__s2_len >= 4U) {
#line 109
            tmp___10 = 1;
          } else {
#line 109
            tmp___10 = 0;
          }
        }
      } else {
#line 109
        tmp___10 = 0;
      }
    }
#line 109
    if (tmp___10) {
#line 109
      tmp___6 = __builtin_strcmp((char const   *)service, "ssh-userauth");
    } else {
#line 109
      tmp___9 = __builtin_strcmp((char const   *)service, "ssh-userauth");
#line 109
      tmp___6 = tmp___9;
    }
  } else {
#line 109
    tmp___9 = __builtin_strcmp((char const   *)service, "ssh-userauth");
#line 109
    tmp___6 = tmp___9;
  }
#line 109
  if (tmp___6 == 0) {
#line 110
    if (! authctxt___0->success) {
#line 111
      acceptit = 1;
#line 113
      dispatch_set(50, & input_userauth_request);
    }
  }
#line 118
  if (acceptit) {
#line 119
    packet_start((unsigned char)6);
#line 120
    packet_put_cstring((char const   *)service);
#line 121
    packet_send();
#line 122
    packet_write_wait();
  } else {
#line 124
    debug("bad service request %s", service);
#line 125
    packet_disconnect("bad service request %s", service);
  }
#line 127
  xfree((void *)service);
#line 128
  return;
}
}
#line 130 "auth2.c"
static void input_userauth_request(int type , u_int32_t seq , void *ctxt ) 
{ Authctxt *authctxt___0 ;
  Authmethod *m___0 ;
  char *user ;
  char *service ;
  char *method ;
  char *style ;
  int authenticated ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___4 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___12 ;
  int tmp___15 ;
  int tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___25 ;
  int tmp___28 ;
  int tmp___29 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___35 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;

  {
#line 133
  authctxt___0 = (Authctxt *)ctxt;
#line 134
  m___0 = (Authmethod *)((void *)0);
#line 135
  style = (char *)((void *)0);
#line 136
  authenticated = 0;
#line 138
  if ((unsigned int )authctxt___0 == (unsigned int )((void *)0)) {
#line 139
    fatal("input_userauth_request: no authctxt");
  }
#line 141
  tmp = packet_get_string((u_int *)((void *)0));
#line 141
  user = (char *)tmp;
#line 142
  tmp___0 = packet_get_string((u_int *)((void *)0));
#line 142
  service = (char *)tmp___0;
#line 143
  tmp___1 = packet_get_string((u_int *)((void *)0));
#line 143
  method = (char *)tmp___1;
#line 144
  debug("userauth-request for user %s service %s method %s", user, service, method);
#line 145
  debug("attempt %d failures %d", authctxt___0->attempt, authctxt___0->failures);
#line 147
  tmp___4 = __builtin_strchr(user, ':');
#line 147
  style = tmp___4;
#line 147
  if ((unsigned int )style != (unsigned int )((void *)0)) {
#line 148
    tmp___2 = style;
#line 148
    style ++;
#line 148
    *tmp___2 = (char)0;
  }
#line 150
  tmp___40 = authctxt___0->attempt;
#line 150
  (authctxt___0->attempt) ++;
#line 150
  if (tmp___40 == 0) {
#line 152
    if (use_privsep) {
#line 152
      authctxt___0->pw = mm_getpwnamallow((char const   *)user);
    } else {
#line 152
      authctxt___0->pw = getpwnamallow((char const   *)user);
    }
#line 153
    authctxt___0->user = xstrdup((char const   *)user);
#line 154
    if (authctxt___0->pw) {
#line 154
      if (0) {
#line 154
        __s1_len = strlen((char const   *)service);
#line 154
        __s2_len = strlen("ssh-connection");
#line 154
        if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
          goto _L___0;
        } else {
#line 154
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 154
            if (! ((unsigned int )((void const   *)("ssh-connection" + 1)) - (unsigned int )((void const   *)"ssh-connection") == 1U)) {
#line 154
              tmp___16 = 1;
            } else {
#line 154
              if (__s2_len >= 4U) {
#line 154
                tmp___16 = 1;
              } else {
#line 154
                tmp___16 = 0;
              }
            }
          } else {
#line 154
            tmp___16 = 0;
          }
        }
#line 154
        if (tmp___16) {
#line 154
          tmp___12 = __builtin_strcmp((char const   *)service, "ssh-connection");
        } else {
#line 154
          tmp___15 = __builtin_strcmp((char const   *)service, "ssh-connection");
#line 154
          tmp___12 = tmp___15;
        }
      } else {
#line 154
        tmp___15 = __builtin_strcmp((char const   *)service, "ssh-connection");
#line 154
        tmp___12 = tmp___15;
      }
#line 154
      if (tmp___12 == 0) {
#line 155
        authctxt___0->valid = 1;
#line 156
        debug2("input_userauth_request: setting up authctxt for %s", user);
      } else {
#line 162
        logit("input_userauth_request: illegal user %s", user);
#line 163
        authctxt___0->pw = fakepw();
      }
    } else {
#line 162
      logit("input_userauth_request: illegal user %s", user);
#line 163
      authctxt___0->pw = fakepw();
    }
#line 169
    if (use_privsep) {
#line 169
      tmp___17 = " [net]";
    } else {
#line 169
      tmp___17 = "";
    }
#line 169
    if (authctxt___0->pw) {
#line 169
      tmp___18 = (char const   *)user;
    } else {
#line 169
      tmp___18 = "unknown";
    }
#line 169
    setproctitle("%s%s", tmp___18, tmp___17);
#line 171
    authctxt___0->service = xstrdup((char const   *)service);
#line 172
    if (style) {
#line 172
      authctxt___0->style = xstrdup((char const   *)style);
    } else {
#line 172
      authctxt___0->style = (char *)((void *)0);
    }
#line 173
    if (use_privsep) {
#line 174
      mm_inform_authserv(service, style);
    }
  } else {
#line 175
    if (0) {
#line 175
      __s1_len___0 = strlen((char const   *)user);
#line 175
      __s2_len___0 = strlen((char const   *)authctxt___0->user);
#line 175
      if (! ((unsigned int )((void const   *)(user + 1)) - (unsigned int )((void const   *)user) == 1U)) {
        goto _L___2;
      } else {
#line 175
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 175
          if (! ((unsigned int )((void const   *)(authctxt___0->user + 1)) - (unsigned int )((void const   *)authctxt___0->user) == 1U)) {
#line 175
            tmp___29 = 1;
          } else {
#line 175
            if (__s2_len___0 >= 4U) {
#line 175
              tmp___29 = 1;
            } else {
#line 175
              tmp___29 = 0;
            }
          }
        } else {
#line 175
          tmp___29 = 0;
        }
      }
#line 175
      if (tmp___29) {
#line 175
        tmp___25 = __builtin_strcmp((char const   *)user, (char const   *)authctxt___0->user);
      } else {
#line 175
        tmp___28 = __builtin_strcmp((char const   *)user, (char const   *)authctxt___0->user);
#line 175
        tmp___25 = tmp___28;
      }
    } else {
#line 175
      tmp___28 = __builtin_strcmp((char const   *)user, (char const   *)authctxt___0->user);
#line 175
      tmp___25 = tmp___28;
    }
#line 176
    if (tmp___25 != 0) {
#line 177
      packet_disconnect("Change of username or service not allowed: (%s,%s) -> (%s,%s)",
                        authctxt___0->user, authctxt___0->service, user, service);
    } else {
#line 176
      if (0) {
#line 176
        __s1_len___1 = strlen((char const   *)service);
#line 176
        __s2_len___1 = strlen((char const   *)authctxt___0->service);
#line 176
        if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
          goto _L___4;
        } else {
#line 176
          if (__s1_len___1 >= 4U) {
            _L___4: /* CIL Label */ 
#line 176
            if (! ((unsigned int )((void const   *)(authctxt___0->service + 1)) - (unsigned int )((void const   *)authctxt___0->service) == 1U)) {
#line 176
              tmp___39 = 1;
            } else {
#line 176
              if (__s2_len___1 >= 4U) {
#line 176
                tmp___39 = 1;
              } else {
#line 176
                tmp___39 = 0;
              }
            }
          } else {
#line 176
            tmp___39 = 0;
          }
        }
#line 176
        if (tmp___39) {
#line 176
          tmp___35 = __builtin_strcmp((char const   *)service, (char const   *)authctxt___0->service);
        } else {
#line 176
          tmp___38 = __builtin_strcmp((char const   *)service, (char const   *)authctxt___0->service);
#line 176
          tmp___35 = tmp___38;
        }
      } else {
#line 176
        tmp___38 = __builtin_strcmp((char const   *)service, (char const   *)authctxt___0->service);
#line 176
        tmp___35 = tmp___38;
      }
#line 176
      if (tmp___35 != 0) {
#line 177
        packet_disconnect("Change of username or service not allowed: (%s,%s) -> (%s,%s)",
                          authctxt___0->user, authctxt___0->service, user, service);
      }
    }
  }
#line 182
  auth2_challenge_stop(authctxt___0);
#line 189
  authctxt___0->postponed = 0;
#line 192
  m___0 = authmethod_lookup((char const   *)method);
#line 193
  if ((unsigned int )m___0 != (unsigned int )((void *)0)) {
#line 194
    debug2("input_userauth_request: try method %s", method);
#line 195
    authenticated = (*(m___0->userauth))(authctxt___0);
  }
#line 197
  userauth_finish(authctxt___0, authenticated, method);
#line 199
  xfree((void *)service);
#line 200
  xfree((void *)user);
#line 201
  xfree((void *)method);
#line 202
  return;
}
}
#line 204 "auth2.c"
void userauth_finish(Authctxt *authctxt___0 , int authenticated , char *method ) 
{ char *methods ;
  int tmp ;
  int tmp___0 ;

  {
#line 209
  if (! authctxt___0->valid) {
#line 209
    if (authenticated) {
#line 210
      fatal("INTERNAL ERROR: authenticated invalid user %s", authctxt___0->user);
    }
  }
#line 214
  if (authenticated) {
#line 214
    if ((authctxt___0->pw)->pw_uid == 0U) {
#line 214
      tmp = auth_root_allowed(method);
#line 214
      if (! tmp) {
#line 216
        authenticated = 0;
      }
    }
  }
#line 231
  auth_log(authctxt___0, authenticated, method, (char *)" ssh2");
#line 233
  if (authctxt___0->postponed) {
#line 234
    return;
  }
#line 237
  if (authenticated == 1) {
#line 239
    dispatch_set(50, & dispatch_protocol_ignore);
#line 240
    packet_start((unsigned char)52);
#line 241
    packet_send();
#line 242
    packet_write_wait();
#line 244
    authctxt___0->success = 1;
  } else {
#line 246
    tmp___0 = authctxt___0->failures;
#line 246
    (authctxt___0->failures) ++;
#line 246
    if (tmp___0 > 6) {
#line 247
      packet_disconnect("Too many authentication failures for %.100s", authctxt___0->user);
    }
#line 248
    methods = authmethods_get();
#line 249
    packet_start((unsigned char)51);
#line 250
    packet_put_cstring((char const   *)methods);
#line 251
    packet_put_char(0);
#line 252
    packet_send();
#line 253
    packet_write_wait();
#line 254
    xfree((void *)methods);
  }
#line 256
  return;
}
}
#line 260 "auth2.c"
static char *authmethods_get(void) 
{ Buffer b ;
  char *list ;
  int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  u_int tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;

  {
#line 267
  buffer_init(& b);
#line 268
  i = 0;
#line 268
  while ((unsigned int )authmethods[i] != (unsigned int )((void *)0)) {
#line 269
    if (0) {
#line 269
      __s1_len = strlen((char const   *)(authmethods[i])->name);
#line 269
      __s2_len = strlen("none");
#line 269
      if (! ((unsigned int )((void const   *)((authmethods[i])->name + 1)) - (unsigned int )((void const   *)(authmethods[i])->name) == 1U)) {
        goto _L___0;
      } else {
#line 269
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 269
          if (! ((unsigned int )((void const   *)("none" + 1)) - (unsigned int )((void const   *)"none") == 1U)) {
#line 269
            tmp___8 = 1;
          } else {
#line 269
            if (__s2_len >= 4U) {
#line 269
              tmp___8 = 1;
            } else {
#line 269
              tmp___8 = 0;
            }
          }
        } else {
#line 269
          tmp___8 = 0;
        }
      }
#line 269
      if (tmp___8) {
#line 269
        tmp___4 = __builtin_strcmp((char const   *)(authmethods[i])->name, "none");
      } else {
#line 269
        tmp___7 = __builtin_strcmp((char const   *)(authmethods[i])->name, "none");
#line 269
        tmp___4 = tmp___7;
      }
    } else {
#line 269
      tmp___7 = __builtin_strcmp((char const   *)(authmethods[i])->name, "none");
#line 269
      tmp___4 = tmp___7;
    }
#line 269
    if (tmp___4 == 0) {
      goto __Cont;
    }
#line 271
    if ((unsigned int )(authmethods[i])->enabled != (unsigned int )((void *)0)) {
#line 271
      if (*((authmethods[i])->enabled) != 0) {
#line 273
        tmp___9 = buffer_len(& b);
#line 273
        if (tmp___9 > 0U) {
#line 274
          buffer_append(& b, (void const   *)",", 1U);
        }
#line 275
        tmp___10 = strlen((char const   *)(authmethods[i])->name);
#line 275
        buffer_append(& b, (void const   *)(authmethods[i])->name, tmp___10);
      }
    }
    __Cont: /* CIL Label */ 
#line 268
    i ++;
  }
#line 279
  buffer_append(& b, (void const   *)"\000", 1U);
#line 280
  tmp___11 = buffer_ptr(& b);
#line 280
  list = xstrdup((char const   *)tmp___11);
#line 281
  buffer_free(& b);
#line 282
  return (list);
}
}
#line 285 "auth2.c"
static Authmethod *authmethod_lookup(char const   *name ) 
{ int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;

  {
#line 290
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 291
    i = 0;
#line 291
    while ((unsigned int )authmethods[i] != (unsigned int )((void *)0)) {
#line 294
      if ((unsigned int )(authmethods[i])->enabled != (unsigned int )((void *)0)) {
#line 294
        if (*((authmethods[i])->enabled) != 0) {
#line 294
          if (0) {
#line 294
            __s1_len = strlen(name);
#line 294
            __s2_len = strlen((char const   *)(authmethods[i])->name);
#line 294
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
              goto _L___0;
            } else {
#line 294
              if (__s1_len >= 4U) {
                _L___0: /* CIL Label */ 
#line 294
                if (! ((unsigned int )((void const   *)((authmethods[i])->name + 1)) - (unsigned int )((void const   *)(authmethods[i])->name) == 1U)) {
#line 294
                  tmp___8 = 1;
                } else {
#line 294
                  if (__s2_len >= 4U) {
#line 294
                    tmp___8 = 1;
                  } else {
#line 294
                    tmp___8 = 0;
                  }
                }
              } else {
#line 294
                tmp___8 = 0;
              }
            }
#line 294
            if (tmp___8) {
#line 294
              tmp___4 = __builtin_strcmp(name, (char const   *)(authmethods[i])->name);
            } else {
#line 294
              tmp___7 = __builtin_strcmp(name, (char const   *)(authmethods[i])->name);
#line 294
              tmp___4 = tmp___7;
            }
          } else {
#line 294
            tmp___7 = __builtin_strcmp(name, (char const   *)(authmethods[i])->name);
#line 294
            tmp___4 = tmp___7;
          }
#line 294
          if (tmp___4 == 0) {
#line 295
            return (authmethods[i]);
          }
        }
      }
#line 291
      i ++;
    }
  }
#line 296
  if (name) {
#line 296
    tmp___9 = name;
  } else {
#line 296
    tmp___9 = "NULL";
  }
#line 296
  debug2("Unrecognized authentication method name: %s", tmp___9);
#line 298
  return ((Authmethod *)((void *)0));
}
}
#line 1 "auth-options.o"
#line 329 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 28 "auth-options.h"
int no_pty_flag ;
#line 30
struct envstring *custom_environment ;
#line 27 "auth-options.c"
int no_port_forwarding_flag  =    0;
#line 28 "auth-options.c"
int no_agent_forwarding_flag  =    0;
#line 29 "auth-options.c"
int no_x11_forwarding_flag  =    0;
#line 30 "auth-options.c"
int no_pty_flag  =    0;
#line 33 "auth-options.c"
char *forced_command  =    (char *)((void *)0);
#line 36 "auth-options.c"
struct envstring *custom_environment  =    (struct envstring *)((void *)0);
#line 40 "auth-options.c"
void auth_clear_options(void) 
{ struct envstring *ce ;

  {
#line 43
  no_agent_forwarding_flag = 0;
#line 44
  no_port_forwarding_flag = 0;
#line 45
  no_pty_flag = 0;
#line 46
  no_x11_forwarding_flag = 0;
#line 47
  while (custom_environment) {
#line 48
    ce = custom_environment;
#line 49
    custom_environment = ce->next;
#line 50
    xfree((void *)ce->s);
#line 51
    xfree((void *)ce);
  }
#line 53
  if (forced_command) {
#line 54
    xfree((void *)forced_command);
#line 55
    forced_command = (char *)((void *)0);
  }
#line 57
  channel_clear_permitted_opens();
#line 58
  auth_debug_reset();
#line 59
  return;
}
}
#line 65 "auth-options.c"
int auth_parse_options(struct passwd *pw , char *opts , char *file___0 , u_long linenum ) 
{ char const   *cp ;
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  size_t tmp___17 ;
  int tmp___18 ;
  char *s ;
  struct envstring *new_envstring ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  void *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  void *tmp___25 ;
  size_t tmp___26 ;
  int tmp___27 ;
  char const   *remote_ip ;
  char const   *tmp___28 ;
  char const   *remote_host ;
  char const   *tmp___29 ;
  char *patterns ;
  size_t tmp___30 ;
  void *tmp___31 ;
  size_t tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  size_t tmp___37 ;
  int tmp___38 ;
  char host[256] ;
  char sport[6] ;
  u_short port ;
  char *patterns___0 ;
  size_t tmp___39 ;
  void *tmp___40 ;
  size_t tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  char *tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  size_t tmp___48 ;
  int tmp___49 ;

  {
#line 72
  auth_clear_options();
#line 74
  if (! opts) {
#line 75
    return (1);
  }
#line 77
  while (1) {
#line 77
    if (*opts) {
#line 77
      if ((int )*opts != 32) {
#line 77
        if (! ((int )*opts != 9)) {
#line 77
          break;
        }
      } else {
#line 77
        break;
      }
    } else {
#line 77
      break;
    }
#line 78
    cp = "no-port-forwarding";
#line 79
    tmp___0 = strlen(cp);
#line 79
    tmp___1 = strncasecmp((char const   *)opts, cp, tmp___0);
#line 79
    if (tmp___1 == 0) {
#line 80
      auth_debug_add("Port forwarding disabled.");
#line 81
      no_port_forwarding_flag = 1;
#line 82
      tmp = strlen(cp);
#line 82
      opts += tmp;
      goto next_option;
    }
#line 85
    cp = "no-agent-forwarding";
#line 86
    tmp___3 = strlen(cp);
#line 86
    tmp___4 = strncasecmp((char const   *)opts, cp, tmp___3);
#line 86
    if (tmp___4 == 0) {
#line 87
      auth_debug_add("Agent forwarding disabled.");
#line 88
      no_agent_forwarding_flag = 1;
#line 89
      tmp___2 = strlen(cp);
#line 89
      opts += tmp___2;
      goto next_option;
    }
#line 92
    cp = "no-X11-forwarding";
#line 93
    tmp___6 = strlen(cp);
#line 93
    tmp___7 = strncasecmp((char const   *)opts, cp, tmp___6);
#line 93
    if (tmp___7 == 0) {
#line 94
      auth_debug_add("X11 forwarding disabled.");
#line 95
      no_x11_forwarding_flag = 1;
#line 96
      tmp___5 = strlen(cp);
#line 96
      opts += tmp___5;
      goto next_option;
    }
#line 99
    cp = "no-pty";
#line 100
    tmp___9 = strlen(cp);
#line 100
    tmp___10 = strncasecmp((char const   *)opts, cp, tmp___9);
#line 100
    if (tmp___10 == 0) {
#line 101
      auth_debug_add("Pty allocation disabled.");
#line 102
      no_pty_flag = 1;
#line 103
      tmp___8 = strlen(cp);
#line 103
      opts += tmp___8;
      goto next_option;
    }
#line 106
    cp = "command=\"";
#line 107
    tmp___17 = strlen(cp);
#line 107
    tmp___18 = strncasecmp((char const   *)opts, cp, tmp___17);
#line 107
    if (tmp___18 == 0) {
#line 108
      tmp___11 = strlen(cp);
#line 108
      opts += tmp___11;
#line 109
      tmp___12 = strlen((char const   *)opts);
#line 109
      tmp___13 = xmalloc(tmp___12 + 1U);
#line 109
      forced_command = (char *)tmp___13;
#line 110
      i = 0;
#line 111
      while (*opts) {
#line 112
        if ((int )*opts == 34) {
#line 113
          break;
        }
#line 114
        if ((int )*opts == 92) {
#line 114
          if ((int )*(opts + 1) == 34) {
#line 115
            opts += 2;
#line 116
            tmp___14 = i;
#line 116
            i ++;
#line 116
            *(forced_command + tmp___14) = (char )'\"';
#line 117
            continue;
          }
        }
#line 119
        tmp___15 = i;
#line 119
        i ++;
#line 119
        tmp___16 = opts;
#line 119
        opts ++;
#line 119
        *(forced_command + tmp___15) = *tmp___16;
      }
#line 121
      if (! *opts) {
#line 122
        debug("%.100s, line %lu: missing end quote", file___0, linenum);
#line 124
        auth_debug_add("%.100s, line %lu: missing end quote", file___0, linenum);
#line 126
        xfree((void *)forced_command);
#line 127
        forced_command = (char *)((void *)0);
        goto bad_option;
      }
#line 130
      *(forced_command + i) = (char)0;
#line 131
      auth_debug_add("Forced command: %.900s", forced_command);
#line 132
      opts ++;
      goto next_option;
    }
#line 135
    cp = "environment=\"";
#line 136
    if (options.permit_user_env) {
#line 136
      tmp___26 = strlen(cp);
#line 136
      tmp___27 = strncasecmp((char const   *)opts, cp, tmp___26);
#line 136
      if (tmp___27 == 0) {
#line 141
        tmp___19 = strlen(cp);
#line 141
        opts += tmp___19;
#line 142
        tmp___20 = strlen((char const   *)opts);
#line 142
        tmp___21 = xmalloc(tmp___20 + 1U);
#line 142
        s = (char *)tmp___21;
#line 143
        i = 0;
#line 144
        while (*opts) {
#line 145
          if ((int )*opts == 34) {
#line 146
            break;
          }
#line 147
          if ((int )*opts == 92) {
#line 147
            if ((int )*(opts + 1) == 34) {
#line 148
              opts += 2;
#line 149
              tmp___22 = i;
#line 149
              i ++;
#line 149
              *(s + tmp___22) = (char )'\"';
#line 150
              continue;
            }
          }
#line 152
          tmp___23 = i;
#line 152
          i ++;
#line 152
          tmp___24 = opts;
#line 152
          opts ++;
#line 152
          *(s + tmp___23) = *tmp___24;
        }
#line 154
        if (! *opts) {
#line 155
          debug("%.100s, line %lu: missing end quote", file___0, linenum);
#line 157
          auth_debug_add("%.100s, line %lu: missing end quote", file___0, linenum);
#line 159
          xfree((void *)s);
          goto bad_option;
        }
#line 162
        *(s + i) = (char)0;
#line 163
        auth_debug_add("Adding to environment: %.900s", s);
#line 164
        debug("Adding to environment: %.900s", s);
#line 165
        opts ++;
#line 166
        tmp___25 = xmalloc(sizeof(struct envstring ));
#line 166
        new_envstring = (struct envstring *)tmp___25;
#line 167
        new_envstring->s = s;
#line 168
        new_envstring->next = custom_environment;
#line 169
        custom_environment = new_envstring;
        goto next_option;
      }
    }
#line 172
    cp = "from=\"";
#line 173
    tmp___37 = strlen(cp);
#line 173
    tmp___38 = strncasecmp((char const   *)opts, cp, tmp___37);
#line 173
    if (tmp___38 == 0) {
#line 174
      tmp___28 = get_remote_ipaddr();
#line 174
      remote_ip = tmp___28;
#line 175
      tmp___29 = get_canonical_hostname(options.use_dns);
#line 175
      remote_host = tmp___29;
#line 177
      tmp___30 = strlen((char const   *)opts);
#line 177
      tmp___31 = xmalloc(tmp___30 + 1U);
#line 177
      patterns = (char *)tmp___31;
#line 179
      tmp___32 = strlen(cp);
#line 179
      opts += tmp___32;
#line 180
      i = 0;
#line 181
      while (*opts) {
#line 182
        if ((int )*opts == 34) {
#line 183
          break;
        }
#line 184
        if ((int )*opts == 92) {
#line 184
          if ((int )*(opts + 1) == 34) {
#line 185
            opts += 2;
#line 186
            tmp___33 = i;
#line 186
            i ++;
#line 186
            *(patterns + tmp___33) = (char )'\"';
#line 187
            continue;
          }
        }
#line 189
        tmp___34 = i;
#line 189
        i ++;
#line 189
        tmp___35 = opts;
#line 189
        opts ++;
#line 189
        *(patterns + tmp___34) = *tmp___35;
      }
#line 191
      if (! *opts) {
#line 192
        debug("%.100s, line %lu: missing end quote", file___0, linenum);
#line 194
        auth_debug_add("%.100s, line %lu: missing end quote", file___0, linenum);
#line 196
        xfree((void *)patterns);
        goto bad_option;
      }
#line 199
      *(patterns + i) = (char)0;
#line 200
      opts ++;
#line 201
      tmp___36 = match_host_and_ip(remote_host, remote_ip, (char const   *)patterns);
#line 201
      if (tmp___36 != 1) {
#line 203
        xfree((void *)patterns);
#line 204
        logit("Authentication tried for %.100s with correct key but not from a permitted host (host=%.200s, ip=%.200s).",
              pw->pw_name, remote_host, remote_ip);
#line 208
        auth_debug_add("Your host \'%.200s\' is not permitted to use this key for login.",
                       remote_host);
#line 212
        return (0);
      }
#line 214
      xfree((void *)patterns);
      goto next_option;
    }
#line 218
    cp = "permitopen=\"";
#line 219
    tmp___48 = strlen(cp);
#line 219
    tmp___49 = strncasecmp((char const   *)opts, cp, tmp___48);
#line 219
    if (tmp___49 == 0) {
#line 222
      tmp___39 = strlen((char const   *)opts);
#line 222
      tmp___40 = xmalloc(tmp___39 + 1U);
#line 222
      patterns___0 = (char *)tmp___40;
#line 224
      tmp___41 = strlen(cp);
#line 224
      opts += tmp___41;
#line 225
      i = 0;
#line 226
      while (*opts) {
#line 227
        if ((int )*opts == 34) {
#line 228
          break;
        }
#line 229
        if ((int )*opts == 92) {
#line 229
          if ((int )*(opts + 1) == 34) {
#line 230
            opts += 2;
#line 231
            tmp___42 = i;
#line 231
            i ++;
#line 231
            *(patterns___0 + tmp___42) = (char )'\"';
#line 232
            continue;
          }
        }
#line 234
        tmp___43 = i;
#line 234
        i ++;
#line 234
        tmp___44 = opts;
#line 234
        opts ++;
#line 234
        *(patterns___0 + tmp___43) = *tmp___44;
      }
#line 236
      if (! *opts) {
#line 237
        debug("%.100s, line %lu: missing end quote", file___0, linenum);
#line 239
        auth_debug_add("%.100s, line %lu: missing end quote", file___0, linenum);
#line 241
        xfree((void *)patterns___0);
        goto bad_option;
      }
#line 244
      *(patterns___0 + i) = (char)0;
#line 245
      opts ++;
#line 246
      tmp___45 = sscanf((char const   * __restrict  )patterns___0, (char const   * __restrict  )"%255[^:]:%5[0-9]",
                        host, sport);
#line 246
      if (tmp___45 != 2) {
#line 246
        tmp___46 = sscanf((char const   * __restrict  )patterns___0, (char const   * __restrict  )"%255[^/]/%5[0-9]",
                          host, sport);
#line 246
        if (tmp___46 != 2) {
#line 248
          debug("%.100s, line %lu: Bad permitopen specification <%.100s>", file___0,
                linenum, patterns___0);
#line 250
          auth_debug_add("%.100s, line %lu: Bad permitopen specification", file___0,
                         linenum);
#line 252
          xfree((void *)patterns___0);
          goto bad_option;
        }
      }
#line 255
      tmp___47 = a2port((char const   *)(sport));
#line 255
      port = (unsigned short )tmp___47;
#line 255
      if ((int )port == 0) {
#line 256
        debug("%.100s, line %lu: Bad permitopen port <%.100s>", file___0, linenum,
              sport);
#line 258
        auth_debug_add("%.100s, line %lu: Bad permitopen port", file___0, linenum);
#line 260
        xfree((void *)patterns___0);
        goto bad_option;
      }
#line 263
      if (options.allow_tcp_forwarding) {
#line 264
        channel_add_permitted_opens(host, (int )port);
      }
#line 265
      xfree((void *)patterns___0);
      goto next_option;
    }
    next_option: 
#line 273
    if (! *opts) {
#line 274
      fatal("Bugs in auth-options.c option processing.");
    }
#line 275
    if ((int )*opts == 32) {
#line 276
      break;
    } else {
#line 275
      if ((int )*opts == 9) {
#line 276
        break;
      }
    }
#line 277
    if ((int )*opts != 44) {
      goto bad_option;
    }
#line 279
    opts ++;
  }
#line 283
  if (! use_privsep) {
#line 284
    auth_debug_send();
  }
#line 287
  return (1);
  bad_option: 
#line 290
  logit("Bad options in %.100s file, line %lu: %.50s", file___0, linenum, opts);
#line 292
  auth_debug_add("Bad options in %.100s file, line %lu: %.50s", file___0, linenum,
                 opts);
#line 295
  if (! use_privsep) {
#line 296
    auth_debug_send();
  }
#line 299
  return (0);
}
}
#line 1 "session.o"
#line 333 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 590
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 774
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 780
extern int pclose(FILE *__stream ) ;
#line 194 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 69 "/usr/include/grp.h"
extern void endgrent(void) ;
#line 504 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int execve(char const   *__path , char * const  *__argv ,
                                                char * const  *__envp )  __attribute__((__nonnull__(1))) ;
#line 526
extern  __attribute__((__nothrow__)) int execl(char const   *__path , char const   *__arg 
                                               , ...)  __attribute__((__nonnull__(1))) ;
#line 801
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 845
extern  __attribute__((__nothrow__)) int gethostname(char *__name , size_t __len )  __attribute__((__nonnull__(1))) ;
#line 81 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcsendbreak(int __fd , int __duration ) ;
#line 106 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socketpair(int __domain , int __type , int __protocol ,
                                                    int *__fds ) ;
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 66 "session.h"
void session_pty_cleanup2(Session *s ) ;
#line 68
Session *session_new(void) ;
#line 69
Session *session_by_tty(char *tty ) ;
#line 70
void session_close(Session *s ) ;
#line 72
void child_set_env(char ***envp , u_int *envsizep , char const   *name , char const   *value ) ;
#line 43 "monitor_wrap.h"
int mm_is_monitor(void) ;
#line 79
int mm_pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) ;
#line 80
void mm_session_pty_cleanup2(struct Session *s ) ;
#line 72 "session.c"
void session_set_fds(Session *s , int fdin___0 , int fdout___0 , int fderr___0 ) ;
#line 73
void session_pty_cleanup(Session *s ) ;
#line 74
void session_proctitle(Session *s ) ;
#line 75
int session_setup_x11fwd(Session *s ) ;
#line 76
void do_exec_pty(Session *s , char const   *command ) ;
#line 77
void do_exec_no_pty(Session *s , char const   *command ) ;
#line 78
void do_exec(Session *s , char const   *command ) ;
#line 79
void do_login(Session *s , char const   *command ) ;
#line 83
void do_child(Session *s , char const   *command ) ;
#line 84
void do_motd(void) ;
#line 85
int check_quietlogin(Session *s , char const   *command ) ;
#line 87
static void do_authenticated1(Authctxt *authctxt___0 ) ;
#line 88
static void do_authenticated2(Authctxt *authctxt___0 ) ;
#line 90
static int session_pty_req(Session *s ) ;
#line 103 "session.c"
char const   *original_command  =    (char const   *)((void *)0);
#line 107 "session.c"
Session sessions[10]  ;
#line 113 "session.c"
static int is_child  =    0;
#line 116 "session.c"
static char *auth_sock_name  =    (char *)((void *)0);
#line 117 "session.c"
static char *auth_sock_dir  =    (char *)((void *)0);
#line 121 "session.c"
static void auth_sock_cleanup_proc(struct passwd *pw ) 
{ 

  {
#line 124
  if ((unsigned int )auth_sock_name != (unsigned int )((void *)0)) {
#line 125
    temporarily_use_uid(pw);
#line 126
    unlink((char const   *)auth_sock_name);
#line 127
    rmdir((char const   *)auth_sock_dir);
#line 128
    auth_sock_name = (char *)((void *)0);
#line 129
    restore_uid();
  }
#line 131
  return;
}
}
#line 133 "session.c"
static int auth_input_request_forwarding(struct passwd *pw ) 
{ Channel *nc ;
  int sock ;
  struct sockaddr_un sunaddr ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  __pid_t tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
#line 140
  if ((unsigned int )auth_sock_name != (unsigned int )((void *)0)) {
#line 141
    error("authentication forwarding requested twice.");
#line 142
    return (0);
  }
#line 146
  temporarily_use_uid(pw);
#line 149
  tmp = xmalloc(4096U);
#line 149
  auth_sock_name = (char *)tmp;
#line 150
  tmp___0 = xmalloc(4096U);
#line 150
  auth_sock_dir = (char *)tmp___0;
#line 151
  strlcpy(auth_sock_dir, "/tmp/ssh-XXXXXXXXXX", 4096U);
#line 154
  tmp___3 = mkdtemp(auth_sock_dir);
#line 154
  if ((unsigned int )tmp___3 == (unsigned int )((void *)0)) {
#line 155
    tmp___1 = __errno_location();
#line 155
    tmp___2 = strerror(*tmp___1);
#line 155
    packet_send_debug("Agent forwarding disabled: mkdtemp() failed: %.100s", tmp___2);
#line 157
    restore_uid();
#line 158
    xfree((void *)auth_sock_name);
#line 159
    xfree((void *)auth_sock_dir);
#line 160
    auth_sock_name = (char *)((void *)0);
#line 161
    auth_sock_dir = (char *)((void *)0);
#line 162
    return (0);
  }
#line 164
  tmp___4 = getpid();
#line 164
  snprintf((char * __restrict  )auth_sock_name, 4096U, (char const   * __restrict  )"%s/agent.%ld",
           auth_sock_dir, (long )tmp___4);
#line 168
  sock = socket(1, 1, 0);
#line 169
  if (sock < 0) {
#line 170
    tmp___5 = __errno_location();
#line 170
    tmp___6 = strerror(*tmp___5);
#line 170
    packet_disconnect("socket: %.100s", tmp___6);
  }
#line 173
  memset((void *)(& sunaddr), 0, sizeof(sunaddr));
#line 174
  sunaddr.sun_family = (unsigned short)1;
#line 175
  strlcpy(sunaddr.sun_path, (char const   *)auth_sock_name, sizeof(sunaddr.sun_path));
#line 177
  tmp___9 = bind(sock, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& sunaddr)),
                 sizeof(sunaddr));
#line 177
  if (tmp___9 < 0) {
#line 178
    tmp___7 = __errno_location();
#line 178
    tmp___8 = strerror(*tmp___7);
#line 178
    packet_disconnect("bind: %.100s", tmp___8);
  }
#line 181
  restore_uid();
#line 184
  tmp___12 = listen(sock, 128);
#line 184
  if (tmp___12 < 0) {
#line 185
    tmp___10 = __errno_location();
#line 185
    tmp___11 = strerror(*tmp___10);
#line 185
    packet_disconnect("listen: %.100s", tmp___11);
  }
#line 188
  nc = channel_new((char *)"auth socket", 6, sock, sock, -1, 65536U, 16384U, 0, (char *)"auth socket",
                   1);
#line 192
  strlcpy(nc->path, (char const   *)auth_sock_name, sizeof(nc->path));
#line 193
  return (1);
}
}
#line 196 "session.c"
static void display_loginmsg(void) 
{ void *tmp ;
  u_int tmp___0 ;

  {
#line 199
  tmp___0 = buffer_len(& loginmsg);
#line 199
  if (tmp___0 > 0U) {
#line 200
    buffer_append(& loginmsg, (void const   *)"\000", 1U);
#line 201
    tmp = buffer_ptr(& loginmsg);
#line 201
    printf((char const   * __restrict  )"%s\n", (char *)tmp);
#line 202
    buffer_clear(& loginmsg);
  }
#line 204
  fflush(stdout);
#line 205
  return;
}
}
#line 207 "session.c"
void do_authenticated(Authctxt *authctxt___0 ) 
{ 

  {
#line 210
  setproctitle("%s", (authctxt___0->pw)->pw_name);
#line 216
  alarm(0U);
#line 217
  if (startup_pipe != -1) {
#line 218
    close(startup_pipe);
#line 219
    startup_pipe = -1;
  }
#line 222
  if (! no_port_forwarding_flag) {
#line 222
    if (options.allow_tcp_forwarding) {
#line 223
      channel_permit_all_opens();
    }
  }
#line 225
  if (compat20) {
#line 226
    do_authenticated2(authctxt___0);
  } else {
#line 228
    do_authenticated1(authctxt___0);
  }
#line 230
  do_cleanup(authctxt___0);
#line 231
  return;
}
}
#line 239 "session.c"
static void do_authenticated1(Authctxt *authctxt___0 ) 
{ Session *s ;
  char *command ;
  int success ;
  int type ;
  int screen_flag ;
  int enable_compression_after_reply ;
  u_int proto_len ;
  u_int data_len ;
  u_int dlen ;
  u_int compression_level ;
  int _len ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  u_int tmp___2 ;
  int tmp___3 ;
  int _len___0 ;
  int tmp___4 ;
  u_int tmp___5 ;
  u_int tmp___6 ;
  void *tmp___7 ;
  int _len___1 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 245
  enable_compression_after_reply = 0;
#line 246
  compression_level = (u_int )0;
#line 248
  s = session_new();
#line 249
  s->authctxt = authctxt___0;
#line 250
  s->pw = authctxt___0->pw;
#line 256
  while (1) {
#line 257
    success = 0;
#line 260
    type = packet_read();
#line 263
    switch (type) {
    case 37: 
#line 265
    compression_level = packet_get_int();
#line 266
    while (1) {
#line 266
      tmp = packet_remaining();
#line 266
      _len = tmp;
#line 266
      if (_len > 0) {
#line 266
        logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
              266);
#line 266
        packet_disconnect("Packet integrity error.");
      }
#line 266
      break;
    }
#line 267
    if (compression_level < 1U) {
#line 268
      packet_send_debug("Received illegal compression level %d.", compression_level);
#line 270
      break;
    } else {
#line 267
      if (compression_level > 9U) {
#line 268
        packet_send_debug("Received illegal compression level %d.", compression_level);
#line 270
        break;
      }
    }
#line 272
    if (! options.compression) {
#line 273
      debug2("compression disabled");
#line 274
      break;
    }
#line 277
    enable_compression_after_reply = 1;
#line 278
    success = 1;
#line 279
    break;
    case 10: 
#line 282
    success = session_pty_req(s);
#line 283
    break;
    case 34: 
#line 286
    tmp___0 = packet_get_string(& proto_len);
#line 286
    s->auth_proto = (char *)tmp___0;
#line 287
    tmp___1 = packet_get_string(& data_len);
#line 287
    s->auth_data = (char *)tmp___1;
#line 289
    tmp___2 = packet_get_protocol_flags();
#line 289
    screen_flag = (int )(tmp___2 & 1U);
#line 291
    debug2("SSH_PROTOFLAG_SCREEN_NUMBER: %d", screen_flag);
#line 293
    tmp___3 = packet_remaining();
#line 293
    if (tmp___3 == 4) {
#line 294
      if (! screen_flag) {
#line 295
        debug2("Buggy client: X11 screen flag missing");
      }
#line 297
      s->screen = packet_get_int();
    } else {
#line 299
      s->screen = 0U;
    }
#line 301
    while (1) {
#line 301
      tmp___4 = packet_remaining();
#line 301
      _len___0 = tmp___4;
#line 301
      if (_len___0 > 0) {
#line 301
        logit("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "session.c",
              301);
#line 301
        packet_disconnect("Packet integrity error.");
      }
#line 301
      break;
    }
#line 302
    success = session_setup_x11fwd(s);
#line 303
    if (! success) {
#line 304
      xfree((void *)s->auth_proto);
#line 305
      xfree((void *)s->auth_data);
#line 306
      s->auth_proto = (char *)((void *)0);
#line 307
      s->auth_data = (char *)((void *)0);
    }
#line 309
    break;
    case 30: 
#line 312
    if (no_agent_forwarding_flag) {
#line 313
      debug("Authentication agent forwarding not permitted for this authentication.");
#line 314
      break;
    } else {
#line 312
      if (compat13) {
#line 313
        debug("Authentication agent forwarding not permitted for this authentication.");
#line 314
        break;
      }
    }
#line 316
    debug("Received authentication agent forwarding request.");
#line 317
    success = auth_input_request_forwarding(s->pw);
#line 318
    break;
    case 28: 
#line 321
    if (no_port_forwarding_flag) {
#line 322
      debug("Port forwarding not permitted for this authentication.");
#line 323
      break;
    }
#line 325
    if (! options.allow_tcp_forwarding) {
#line 326
      debug("Port forwarding not permitted.");
#line 327
      break;
    }
#line 329
    debug("Received TCP/IP port forwarding request.");
#line 330
    channel_input_port_forward_request((s->pw)->pw_uid == 0U, options.gateway_ports);
#line 331
    success = 1;
#line 332
    break;
    case 38: 
#line 335
    tmp___5 = packet_get_int();
#line 335
    tmp___6 = packet_set_maxsize(tmp___5);
#line 335
    if (tmp___6 > 0U) {
#line 336
      success = 1;
    }
#line 337
    break;
    case 12: 
    case 13: 
#line 341
    if (type == 13) {
#line 342
      tmp___7 = packet_get_string(& dlen);
#line 342
      command = (char *)tmp___7;
#line 343
      debug("Exec command \'%.500s\'", command);
#line 344
      do_exec(s, (char const   *)command);
#line 345
      xfree((void *)command);
    } else {
#line 347
      do_exec(s, (char const   *)((void *)0));
    }
#line 349
    while (1) {
#line 349
      tmp___8 = packet_remaining();
#line 349
      _len___1 = tmp___8;
#line 349
      if (_len___1 > 0) {
#line 349
        logit("Packet integrity error (%d bytes remaining) at %s:%d", _len___1, "session.c",
              349);
#line 349
        packet_disconnect("Packet integrity error.");
      }
#line 349
      break;
    }
#line 350
    session_close(s);
#line 351
    return;
    default: 
#line 358
    logit("Unknown packet type received after authentication: %d", type);
    }
#line 360
    if (success) {
#line 360
      tmp___9 = 14;
    } else {
#line 360
      tmp___9 = 15;
    }
#line 360
    packet_start((unsigned char )tmp___9);
#line 361
    packet_send();
#line 362
    packet_write_wait();
#line 365
    if (enable_compression_after_reply) {
#line 366
      enable_compression_after_reply = 0;
#line 367
      packet_start_compression((int )compression_level);
    }
  }
}
}
#line 377 "session.c"
void do_exec_no_pty(Session *s , char const   *command ) 
{ pid_t pid ;
  int inout[2] ;
  int err[2] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  __pid_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
#line 391
  tmp___1 = socketpair(1, 1, 0, (int *)(inout));
#line 391
  if (tmp___1 < 0) {
#line 393
    tmp = __errno_location();
#line 393
    tmp___0 = strerror(*tmp);
#line 393
    packet_disconnect("Could not create socket pairs: %.100s", tmp___0);
  } else {
#line 391
    tmp___2 = socketpair(1, 1, 0, (int *)(err));
#line 391
    if (tmp___2 < 0) {
#line 393
      tmp = __errno_location();
#line 393
      tmp___0 = strerror(*tmp);
#line 393
      packet_disconnect("Could not create socket pairs: %.100s", tmp___0);
    }
  }
#line 396
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 397
    fatal("do_exec_no_pty: no session");
  }
#line 399
  session_proctitle(s);
#line 407
  pid = fork();
#line 407
  if (pid == 0) {
#line 408
    is_child = 1;
#line 411
    log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 417
    tmp___5 = setsid();
#line 417
    if (tmp___5 < 0) {
#line 418
      tmp___3 = __errno_location();
#line 418
      tmp___4 = strerror(*tmp___3);
#line 418
      error("setsid failed: %.100s", tmp___4);
    }
#line 447
    close(inout[1]);
#line 448
    close(err[1]);
#line 449
    tmp___6 = dup2(inout[0], 0);
#line 449
    if (tmp___6 < 0) {
#line 450
      perror("dup2 stdin");
    }
#line 451
    tmp___7 = dup2(inout[0], 1);
#line 451
    if (tmp___7 < 0) {
#line 452
      perror("dup2 stdout");
    }
#line 453
    tmp___8 = dup2(err[0], 2);
#line 453
    if (tmp___8 < 0) {
#line 454
      perror("dup2 stderr");
    }
#line 462
    do_child(s, command);
  }
#line 472
  if (pid < 0) {
#line 473
    tmp___9 = __errno_location();
#line 473
    tmp___10 = strerror(*tmp___9);
#line 473
    packet_disconnect("fork failed: %.100s", tmp___10);
  }
#line 474
  s->pid = pid;
#line 476
  packet_set_interactive((unsigned int )s->display != (unsigned int )((void *)0));
#line 492
  close(inout[0]);
#line 493
  close(err[0]);
#line 500
  buffer_clear(& loginmsg);
#line 506
  if (compat20) {
#line 507
    if (s->is_subsystem) {
#line 507
      tmp___11 = -1;
    } else {
#line 507
      tmp___11 = err[1];
    }
#line 507
    session_set_fds(s, inout[1], inout[1], tmp___11);
  } else {
#line 509
    server_loop(pid, inout[1], inout[1], err[1]);
  }
#line 513
  return;
}
}
#line 521 "session.c"
void do_exec_pty(Session *s , char const   *command ) 
{ int fdout___0 ;
  int ptyfd ;
  int ttyfd ;
  int ptymaster ;
  pid_t pid ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;

  {
#line 527
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 528
    fatal("do_exec_pty: no session");
  }
#line 529
  ptyfd = s->ptyfd;
#line 530
  ttyfd = s->ttyfd;
#line 541
  pid = fork();
#line 541
  if (pid == 0) {
#line 542
    is_child = 1;
#line 545
    log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 547
    close(ptyfd);
#line 550
    pty_make_controlling_tty(& ttyfd, (char const   *)(s->tty));
#line 553
    tmp___1 = dup2(ttyfd, 0);
#line 553
    if (tmp___1 < 0) {
#line 554
      tmp = __errno_location();
#line 554
      tmp___0 = strerror(*tmp);
#line 554
      error("dup2 stdin: %s", tmp___0);
    }
#line 555
    tmp___4 = dup2(ttyfd, 1);
#line 555
    if (tmp___4 < 0) {
#line 556
      tmp___2 = __errno_location();
#line 556
      tmp___3 = strerror(*tmp___2);
#line 556
      error("dup2 stdout: %s", tmp___3);
    }
#line 557
    tmp___7 = dup2(ttyfd, 2);
#line 557
    if (tmp___7 < 0) {
#line 558
      tmp___5 = __errno_location();
#line 558
      tmp___6 = strerror(*tmp___5);
#line 558
      error("dup2 stderr: %s", tmp___6);
    }
#line 561
    close(ttyfd);
#line 565
    if (options.use_login) {
#line 565
      if (! ((unsigned int )command == (unsigned int )((void *)0))) {
#line 569
        do_login(s, command);
      }
    } else {
#line 569
      do_login(s, command);
    }
#line 578
    do_child(s, command);
  }
#line 588
  if (pid < 0) {
#line 589
    tmp___8 = __errno_location();
#line 589
    tmp___9 = strerror(*tmp___8);
#line 589
    packet_disconnect("fork failed: %.100s", tmp___9);
  }
#line 590
  s->pid = pid;
#line 593
  close(ttyfd);
#line 600
  fdout___0 = dup(ptyfd);
#line 601
  if (fdout___0 < 0) {
#line 602
    tmp___10 = __errno_location();
#line 602
    tmp___11 = strerror(*tmp___10);
#line 602
    packet_disconnect("dup #1 failed: %.100s", tmp___11);
  }
#line 605
  ptymaster = dup(ptyfd);
#line 606
  if (ptymaster < 0) {
#line 607
    tmp___12 = __errno_location();
#line 607
    tmp___13 = strerror(*tmp___12);
#line 607
    packet_disconnect("dup #2 failed: %.100s", tmp___13);
  }
#line 608
  s->ptymaster = ptymaster;
#line 611
  packet_set_interactive(1);
#line 612
  if (compat20) {
#line 613
    session_set_fds(s, ptyfd, fdout___0, -1);
  } else {
#line 615
    server_loop(pid, ptyfd, fdout___0, -1);
  }
#line 618
  return;
}
}
#line 652 "session.c"
void do_exec(Session *s , char const   *command ) 
{ 

  {
#line 655
  if (forced_command) {
#line 656
    original_command = command;
#line 657
    command = (char const   *)forced_command;
#line 658
    debug("Forced command \'%.900s\'", command);
  }
#line 669
  if (s->ttyfd != -1) {
#line 670
    do_exec_pty(s, command);
  } else {
#line 672
    do_exec_no_pty(s, command);
  }
#line 674
  original_command = (char const   *)((void *)0);
#line 675
  return;
}
}
#line 679 "session.c"
void do_login(Session *s , char const   *command ) 
{ char *time_string ;
  socklen_t fromlen ;
  struct sockaddr_storage from ;
  struct passwd *pw ;
  pid_t pid ;
  __pid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  char *tmp___8 ;
  char *tmp___10 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___16 ;
  int tmp___19 ;
  int tmp___20 ;

  {
#line 685
  pw = s->pw;
#line 686
  tmp = getpid();
#line 686
  pid = tmp;
#line 692
  memset((void *)(& from), 0, sizeof(from));
#line 693
  fromlen = sizeof(from);
#line 694
  tmp___4 = packet_connection_is_on_socket();
#line 694
  if (tmp___4) {
#line 695
    tmp___2 = packet_get_connection_in();
#line 695
    tmp___3 = getpeername(tmp___2, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 695
    if (tmp___3 < 0) {
#line 697
      tmp___0 = __errno_location();
#line 697
      tmp___1 = strerror(*tmp___0);
#line 697
      debug("getpeername: %.100s", tmp___1);
#line 698
      cleanup_exit(255);
    }
  }
#line 703
  if (! use_privsep) {
#line 704
    tmp___5 = get_remote_name_or_ip(utmp_len, options.use_dns);
#line 704
    record_login(pid, (char const   *)(s->tty), (char const   *)pw->pw_name, pw->pw_uid,
                 tmp___5, (struct sockaddr *)(& from), fromlen);
  }
#line 722
  tmp___6 = check_quietlogin(s, command);
#line 722
  if (tmp___6) {
#line 723
    return;
  }
#line 725
  display_loginmsg();
#line 728
  if (options.print_lastlog) {
#line 728
    if (s->last_login_time != 0L) {
#line 729
      time_string = ctime((time_t const   *)(& s->last_login_time));
#line 730
      tmp___10 = __builtin_strchr(time_string, '\n');
#line 730
      if (tmp___10) {
#line 731
        tmp___8 = __builtin_strchr(time_string, '\n');
#line 731
        *tmp___8 = (char)0;
      }
#line 732
      if (0) {
#line 732
        __s1_len = strlen((char const   *)(s->hostname));
#line 732
        __s2_len = strlen("");
#line 732
        if (! ((unsigned int )((void const   *)(s->hostname + 1)) - (unsigned int )((void const   *)(s->hostname)) == 1U)) {
          goto _L___0;
        } else {
#line 732
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 732
            if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 732
              tmp___20 = 1;
            } else {
#line 732
              if (__s2_len >= 4U) {
#line 732
                tmp___20 = 1;
              } else {
#line 732
                tmp___20 = 0;
              }
            }
          } else {
#line 732
            tmp___20 = 0;
          }
        }
#line 732
        if (tmp___20) {
#line 732
          tmp___16 = __builtin_strcmp((char const   *)(s->hostname), "");
        } else {
#line 732
          tmp___19 = __builtin_strcmp((char const   *)(s->hostname), "");
#line 732
          tmp___16 = tmp___19;
        }
      } else {
#line 732
        tmp___19 = __builtin_strcmp((char const   *)(s->hostname), "");
#line 732
        tmp___16 = tmp___19;
      }
#line 732
      if (tmp___16 == 0) {
#line 733
        printf((char const   * __restrict  )"Last login: %s\r\n", time_string);
      } else {
#line 735
        printf((char const   * __restrict  )"Last login: %s from %s\r\n", time_string,
               s->hostname);
      }
    }
  }
#line 740
  do_motd();
#line 741
  return;
}
}
#line 746 "session.c"
void do_motd(void) 
{ FILE *f ;
  char buf___1[256] ;
  char *tmp ;

  {
#line 752
  if (options.print_motd) {
#line 757
    f = fopen((char const   * __restrict  )"/etc/motd", (char const   * __restrict  )"r");
#line 759
    if (f) {
#line 760
      while (1) {
#line 760
        tmp = fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )f);
#line 760
        if (! tmp) {
#line 760
          break;
        }
#line 761
        fputs((char const   * __restrict  )(buf___1), (FILE * __restrict  )stdout);
      }
#line 762
      fclose(f);
    }
  }
#line 765
  return;
}
}
#line 771 "session.c"
int check_quietlogin(Session *s , char const   *command ) 
{ char buf___1[256] ;
  struct passwd *pw ;
  struct stat st ;
  int tmp ;

  {
#line 775
  pw = s->pw;
#line 779
  if ((unsigned int )command != (unsigned int )((void *)0)) {
#line 780
    return (1);
  }
#line 781
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.200s/.hushlogin",
           pw->pw_dir);
#line 786
  tmp = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )(& st));
#line 786
  if (tmp >= 0) {
#line 787
    return (1);
  }
#line 789
  return (0);
}
}
#line 796 "session.c"
void child_set_env(char ***envp , u_int *envsizep , char const   *name , char const   *value ) 
{ char **env ;
  u_int envsize ;
  u_int i ;
  u_int namelen ;
  void *tmp ;
  int tmp___13 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___19 ;
  int tmp___22 ;
  int tmp___23 ;
  void *tmp___26 ;
  size_t tmp___27 ;
  size_t tmp___28 ;
  void *tmp___29 ;
  size_t tmp___30 ;
  size_t tmp___31 ;

  {
#line 808
  if ((unsigned int )*envp == (unsigned int )((void *)0)) {
#line 808
    if (*envsizep == 0U) {
#line 809
      tmp = xmalloc(sizeof(char *));
#line 809
      *envp = (char **)tmp;
#line 810
      *(*(envp + 0)) = (char *)((void *)0);
#line 811
      *envsizep = 1U;
    }
  }
#line 819
  env = *envp;
#line 820
  namelen = strlen(name);
#line 821
  i = 0U;
#line 821
  while (*(env + i)) {
#line 822
    if (0) {
#line 822
      if (0) {
#line 822
        __s1_len___0 = strlen((char const   *)*(env + i));
#line 822
        __s2_len___0 = strlen(name);
#line 822
        if (! ((unsigned int )((void const   *)(*(env + i) + 1)) - (unsigned int )((void const   *)*(env + i)) == 1U)) {
          goto _L___2;
        } else {
#line 822
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 822
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
#line 822
              tmp___23 = 1;
            } else {
#line 822
              if (__s2_len___0 >= 4U) {
#line 822
                tmp___23 = 1;
              } else {
#line 822
                tmp___23 = 0;
              }
            }
          } else {
#line 822
            tmp___23 = 0;
          }
        }
#line 822
        if (tmp___23) {
#line 822
          tmp___19 = __builtin_strcmp((char const   *)*(env + i), name);
        } else {
#line 822
          tmp___22 = __builtin_strcmp((char const   *)*(env + i), name);
#line 822
          tmp___19 = tmp___22;
        }
      } else {
#line 822
        tmp___22 = __builtin_strcmp((char const   *)*(env + i), name);
#line 822
        tmp___19 = tmp___22;
      }
#line 822
      tmp___13 = tmp___19;
    } else {
#line 822
      tmp___13 = strncmp((char const   *)*(env + i), name, namelen);
    }
#line 822
    if (tmp___13 == 0) {
#line 822
      if ((int )*(*(env + i) + namelen) == 61) {
#line 823
        break;
      }
    }
#line 821
    i ++;
  }
#line 824
  if (*(env + i)) {
#line 826
    xfree((void *)*(env + i));
  } else {
#line 829
    envsize = *envsizep;
#line 830
    if (i >= envsize - 1U) {
#line 831
      if (envsize >= 1000U) {
#line 832
        fatal("child_set_env: too many env vars");
      }
#line 833
      envsize += 50U;
#line 834
      tmp___26 = xrealloc((void *)env, envsize * sizeof(char *));
#line 834
      *envp = (char **)tmp___26;
#line 834
      env = *envp;
#line 835
      *envsizep = envsize;
    }
#line 838
    *(env + (i + 1U)) = (char *)((void *)0);
  }
#line 842
  tmp___27 = strlen(name);
#line 842
  tmp___28 = strlen(value);
#line 842
  tmp___29 = xmalloc(((tmp___27 + 1U) + tmp___28) + 1U);
#line 842
  *(env + i) = (char *)tmp___29;
#line 843
  tmp___30 = strlen(name);
#line 843
  tmp___31 = strlen(value);
#line 843
  snprintf((char * __restrict  )*(env + i), ((tmp___30 + 1U) + tmp___31) + 1U, (char const   * __restrict  )"%s=%s",
           name, value);
#line 844
  return;
}
}
#line 852 "session.c"
static void read_environment_file(char ***env , u_int *envsize , char const   *filename ) 
{ FILE *f ;
  char buf___1[4096] ;
  char *cp ;
  char *value ;
  u_int lineno ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 859
  lineno = (u_int )0;
#line 861
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 862
  if (! f) {
#line 863
    return;
  }
#line 865
  while (1) {
#line 865
    tmp___5 = fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )f);
#line 865
    if (! tmp___5) {
#line 865
      break;
    }
#line 866
    lineno ++;
#line 866
    if (lineno > 1000U) {
#line 867
      fatal("Too many lines in environment file %s", filename);
    }
#line 868
    cp = buf___1;
#line 868
    while (1) {
#line 868
      if (! ((int )*cp == 32)) {
#line 868
        if (! ((int )*cp == 9)) {
#line 868
          break;
        }
      }
#line 868
      cp ++;
    }
#line 870
    if (! *cp) {
#line 871
      continue;
    } else {
#line 870
      if ((int )*cp == 35) {
#line 871
        continue;
      } else {
#line 870
        if ((int )*cp == 10) {
#line 871
          continue;
        }
      }
    }
#line 872
    tmp___2 = __builtin_strchr(cp, '\n');
#line 872
    if (tmp___2) {
#line 873
      tmp___0 = __builtin_strchr(cp, '\n');
#line 873
      *tmp___0 = (char )'\000';
    }
#line 874
    tmp___4 = __builtin_strchr(cp, '=');
#line 874
    value = tmp___4;
#line 875
    if ((unsigned int )value == (unsigned int )((void *)0)) {
#line 876
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad line %u in %.100s\n",
              lineno, filename);
#line 878
      continue;
    }
#line 884
    *value = (char )'\000';
#line 885
    value ++;
#line 886
    child_set_env(env, envsize, (char const   *)cp, (char const   *)value);
  }
#line 888
  fclose(f);
#line 889
  return;
}
}
#line 946 "session.c"
void copy_environment(char **source , char ***env , u_int *envsize ) 
{ char *var_name ;
  char *var_val ;
  int i ;
  char *tmp ;

  {
#line 951
  if ((unsigned int )source == (unsigned int )((void *)0)) {
#line 952
    return;
  }
#line 954
  i = 0;
#line 954
  while ((unsigned int )*(source + i) != (unsigned int )((void *)0)) {
#line 955
    var_name = xstrdup((char const   *)*(source + i));
#line 956
    var_val = strstr((char const   *)var_name, "=");
#line 956
    if ((unsigned int )var_val == (unsigned int )((void *)0)) {
#line 957
      xfree((void *)var_name);
      goto __Cont;
    }
#line 960
    tmp = var_val;
#line 960
    var_val ++;
#line 960
    *tmp = (char )'\000';
#line 962
    debug3("Copy environment: %s=%s", var_name, var_val);
#line 963
    child_set_env(env, envsize, (char const   *)var_name, (char const   *)var_val);
#line 965
    xfree((void *)var_name);
    __Cont: /* CIL Label */ 
#line 954
    i ++;
  }
#line 967
  return;
}
}
#line 969 "session.c"
static char **do_setup_env(Session *s , char const   *shell ) 
{ char buf___1[256] ;
  u_int i ;
  u_int envsize ;
  char **env ;
  char *laddr ;
  char *path ;
  struct passwd *pw ;
  void *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  struct envstring *ce ;
  char *str ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___20 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___26 ;
  int tmp___29 ;
  int tmp___30 ;

  {
#line 974
  path = (char *)((void *)0);
#line 975
  pw = s->pw;
#line 978
  envsize = 100U;
#line 979
  tmp = xmalloc(envsize * sizeof(char *));
#line 979
  env = (char **)tmp;
#line 980
  *(env + 0) = (char *)((void *)0);
#line 997
  if (! options.use_login) {
#line 999
    child_set_env(& env, & envsize, "USER", (char const   *)pw->pw_name);
#line 1000
    child_set_env(& env, & envsize, "LOGNAME", (char const   *)pw->pw_name);
#line 1004
    child_set_env(& env, & envsize, "HOME", (char const   *)pw->pw_dir);
#line 1022
    if ((unsigned int )path == (unsigned int )((void *)0)) {
      goto _L;
    } else {
#line 1022
      if ((int )*path == 0) {
        _L: /* CIL Label */ 
#line 1023
        if ((s->pw)->pw_uid == 0U) {
#line 1023
          tmp___0 = "/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin";
        } else {
#line 1023
          tmp___0 = "/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin";
        }
#line 1023
        child_set_env(& env, & envsize, "PATH", tmp___0);
      }
    }
#line 1030
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.200s/%.50s",
             "/var/mail", pw->pw_name);
#line 1032
    child_set_env(& env, & envsize, "MAIL", (char const   *)(buf___1));
#line 1035
    child_set_env(& env, & envsize, "SHELL", shell);
  }
#line 1037
  tmp___2 = getenv("TZ");
#line 1037
  if (tmp___2) {
#line 1038
    tmp___1 = getenv("TZ");
#line 1038
    child_set_env(& env, & envsize, "TZ", (char const   *)tmp___1);
  }
#line 1041
  if (! options.use_login) {
#line 1042
    while (custom_environment) {
#line 1043
      ce = custom_environment;
#line 1044
      str = ce->s;
#line 1046
      i = 0U;
#line 1046
      while (1) {
#line 1046
        if ((int )*(str + i) != 61) {
#line 1046
          if (! *(str + i)) {
#line 1046
            break;
          }
        } else {
#line 1046
          break;
        }
#line 1046
        i ++;
      }
#line 1048
      if ((int )*(str + i) == 61) {
#line 1049
        *(str + i) = (char)0;
#line 1050
        child_set_env(& env, & envsize, (char const   *)str, (char const   *)((str + i) + 1));
      }
#line 1052
      custom_environment = ce->next;
#line 1053
      xfree((void *)ce->s);
#line 1054
      xfree((void *)ce);
    }
  }
#line 1059
  tmp___3 = get_local_port();
#line 1059
  tmp___4 = get_remote_port();
#line 1059
  tmp___5 = get_remote_ipaddr();
#line 1059
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.50s %d %d",
           tmp___5, tmp___4, tmp___3);
#line 1061
  child_set_env(& env, & envsize, "SSH_CLIENT", (char const   *)(buf___1));
#line 1063
  tmp___6 = packet_get_connection_in();
#line 1063
  laddr = get_local_ipaddr(tmp___6);
#line 1064
  tmp___7 = get_local_port();
#line 1064
  tmp___8 = get_remote_port();
#line 1064
  tmp___9 = get_remote_ipaddr();
#line 1064
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.50s %d %.50s %d",
           tmp___9, tmp___8, laddr, tmp___7);
#line 1066
  xfree((void *)laddr);
#line 1067
  child_set_env(& env, & envsize, "SSH_CONNECTION", (char const   *)(buf___1));
#line 1069
  if (s->ttyfd != -1) {
#line 1070
    child_set_env(& env, & envsize, "SSH_TTY", (char const   *)(s->tty));
  }
#line 1071
  if (s->term) {
#line 1072
    child_set_env(& env, & envsize, "TERM", (char const   *)s->term);
  }
#line 1073
  if (s->display) {
#line 1074
    child_set_env(& env, & envsize, "DISPLAY", (char const   *)s->display);
  }
#line 1075
  if (original_command) {
#line 1076
    child_set_env(& env, & envsize, "SSH_ORIGINAL_COMMAND", original_command);
  }
#line 1118
  if ((unsigned int )auth_sock_name != (unsigned int )((void *)0)) {
#line 1119
    child_set_env(& env, & envsize, "SSH_AUTH_SOCK", (char const   *)auth_sock_name);
  }
#line 1123
  if (options.permit_user_env) {
#line 1123
    if (! options.use_login) {
#line 1125
      if (0) {
#line 1125
        __s1_len___0 = strlen((char const   *)pw->pw_dir);
#line 1125
        __s2_len___0 = strlen("/");
#line 1125
        if (! ((unsigned int )((void const   *)(pw->pw_dir + 1)) - (unsigned int )((void const   *)pw->pw_dir) == 1U)) {
          goto _L___3;
        } else {
#line 1125
          if (__s1_len___0 >= 4U) {
            _L___3: /* CIL Label */ 
#line 1125
            if (! ((unsigned int )((void const   *)("/" + 1)) - (unsigned int )((void const   *)"/") == 1U)) {
#line 1125
              tmp___30 = 1;
            } else {
#line 1125
              if (__s2_len___0 >= 4U) {
#line 1125
                tmp___30 = 1;
              } else {
#line 1125
                tmp___30 = 0;
              }
            }
          } else {
#line 1125
            tmp___30 = 0;
          }
        }
#line 1125
        if (tmp___30) {
#line 1125
          tmp___26 = __builtin_strcmp((char const   *)pw->pw_dir, "/");
        } else {
#line 1125
          tmp___29 = __builtin_strcmp((char const   *)pw->pw_dir, "/");
#line 1125
          tmp___26 = tmp___29;
        }
      } else {
#line 1125
        tmp___29 = __builtin_strcmp((char const   *)pw->pw_dir, "/");
#line 1125
        tmp___26 = tmp___29;
      }
#line 1125
      if (tmp___26) {
#line 1125
        tmp___20 = (char const   *)pw->pw_dir;
      } else {
#line 1125
        tmp___20 = "";
      }
#line 1125
      snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.200s/.ssh/environment",
               tmp___20);
#line 1126
      read_environment_file(& env, & envsize, (char const   *)(buf___1));
    }
  }
#line 1128
  if (debug_flag) {
#line 1130
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Environment:\n");
#line 1131
    i = 0U;
#line 1131
    while (*(env + i)) {
#line 1132
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  %.200s\n",
              *(env + i));
#line 1131
      i ++;
    }
  }
#line 1134
  return (env);
}
}
#line 1141 "session.c"
static void do_rc_files(Session *s , char const   *shell ) 
{ FILE *f ;
  char cmd[1024] ;
  int do_xauth ;
  struct stat st ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1144
  f = (FILE *)((void *)0);
#line 1149
  if ((unsigned int )s->display != (unsigned int )((void *)0)) {
#line 1149
    if ((unsigned int )s->auth_proto != (unsigned int )((void *)0)) {
#line 1149
      if ((unsigned int )s->auth_data != (unsigned int )((void *)0)) {
#line 1149
        tmp = 1;
      } else {
#line 1149
        tmp = 0;
      }
    } else {
#line 1149
      tmp = 0;
    }
  } else {
#line 1149
    tmp = 0;
  }
#line 1149
  do_xauth = tmp;
#line 1153
  if (! s->is_subsystem) {
#line 1153
    tmp___1 = stat((char const   * __restrict  )".ssh/rc", (struct stat * __restrict  )(& st));
#line 1153
    if (tmp___1 >= 0) {
#line 1154
      snprintf((char * __restrict  )(cmd), sizeof(cmd), (char const   * __restrict  )"%s -c \'%s %s\'",
               shell, "/bin/sh", ".ssh/rc");
#line 1156
      if (debug_flag) {
#line 1157
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %s\n",
                cmd);
      }
#line 1158
      f = popen((char const   *)(cmd), "w");
#line 1159
      if (f) {
#line 1160
        if (do_xauth) {
#line 1161
          fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                  s->auth_proto, s->auth_data);
        }
#line 1163
        pclose(f);
      } else {
#line 1165
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                ".ssh/rc");
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1167
    tmp___0 = stat((char const   * __restrict  )"/usr/local/etc/sshrc", (struct stat * __restrict  )(& st));
#line 1167
    if (tmp___0 >= 0) {
#line 1168
      if (debug_flag) {
#line 1169
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %s %s\n",
                "/bin/sh", "/usr/local/etc/sshrc");
      }
#line 1171
      f = popen("/bin/sh /usr/local/etc/sshrc", "w");
#line 1172
      if (f) {
#line 1173
        if (do_xauth) {
#line 1174
          fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                  s->auth_proto, s->auth_data);
        }
#line 1176
        pclose(f);
      } else {
#line 1178
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                "/usr/local/etc/sshrc");
      }
    } else {
#line 1180
      if (do_xauth) {
#line 1180
        if ((unsigned int )options.xauth_location != (unsigned int )((void *)0)) {
#line 1182
          if (debug_flag) {
#line 1183
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %.500s remove %.100s\n",
                    options.xauth_location, s->auth_display);
#line 1186
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%.500s add %.100s %.100s %.100s\n",
                    options.xauth_location, s->auth_display, s->auth_proto, s->auth_data);
          }
#line 1191
          snprintf((char * __restrict  )(cmd), sizeof(cmd), (char const   * __restrict  )"%s -q -",
                   options.xauth_location);
#line 1193
          f = popen((char const   *)(cmd), "w");
#line 1194
          if (f) {
#line 1195
            fprintf((FILE * __restrict  )f, (char const   * __restrict  )"remove %s\n",
                    s->auth_display);
#line 1197
            fprintf((FILE * __restrict  )f, (char const   * __restrict  )"add %s %s %s\n",
                    s->auth_display, s->auth_proto, s->auth_data);
#line 1200
            pclose(f);
          } else {
#line 1202
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                    cmd);
          }
        }
      }
    }
  }
#line 1206
  return;
}
}
#line 1208 "session.c"
static void do_nologin(struct passwd *pw ) 
{ FILE *f ;
  char buf___1[1024] ;
  char *tmp ;

  {
#line 1211
  f = (FILE *)((void *)0);
#line 1219
  if (pw->pw_uid) {
#line 1220
    f = fopen((char const   * __restrict  )"/etc/nologin", (char const   * __restrict  )"r");
  }
#line 1222
  if (f) {
#line 1224
    logit("User %.100s not allowed because %s exists", pw->pw_name, "/etc/nologin");
#line 1226
    while (1) {
#line 1226
      tmp = fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )f);
#line 1226
      if (! tmp) {
#line 1226
        break;
      }
#line 1227
      fputs((char const   * __restrict  )(buf___1), (FILE * __restrict  )stderr);
    }
#line 1228
    fclose(f);
#line 1229
    fflush((FILE *)((void *)0));
#line 1230
    exit(254);
  }
#line 1232
  return;
}
}
#line 1235 "session.c"
void do_setusercontext(struct passwd *pw ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  __uid_t tmp___4 ;
  __uid_t tmp___5 ;
  __uid_t tmp___6 ;
  __uid_t tmp___7 ;

  {
#line 1239
  tmp___4 = getuid();
#line 1239
  if (tmp___4 == 0U) {
    goto _L;
  } else {
#line 1239
    tmp___5 = geteuid();
#line 1239
    if (tmp___5 == 0U) {
      _L: /* CIL Label */ 
#line 1269
      tmp___1 = setlogin((char const   *)pw->pw_name);
#line 1269
      if (tmp___1 < 0) {
#line 1270
        tmp = __errno_location();
#line 1270
        tmp___0 = strerror(*tmp);
#line 1270
        error("setlogin failed: %s", tmp___0);
      }
#line 1271
      tmp___2 = setgid(pw->pw_gid);
#line 1271
      if (tmp___2 < 0) {
#line 1272
        perror("setgid");
#line 1273
        exit(1);
      }
#line 1276
      tmp___3 = initgroups((char const   *)pw->pw_name, pw->pw_gid);
#line 1276
      if (tmp___3 < 0) {
#line 1277
        perror("initgroups");
#line 1278
        exit(1);
      }
#line 1280
      endgrent();
#line 1299
      permanently_set_uid(pw);
    }
  }
#line 1306
  tmp___6 = getuid();
#line 1306
  if (tmp___6 != pw->pw_uid) {
#line 1307
    fatal("Failed to set uids to %u.", pw->pw_uid);
  } else {
#line 1306
    tmp___7 = geteuid();
#line 1306
    if (tmp___7 != pw->pw_uid) {
#line 1307
      fatal("Failed to set uids to %u.", pw->pw_uid);
    }
  }
#line 1308
  return;
}
}
#line 1310 "session.c"
static void do_pwchange(Session *s ) 
{ 

  {
#line 1313
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"WARNING: Your password has expired.\n");
#line 1314
  if (s->ttyfd != -1) {
#line 1315
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"You must change your password now and login again!\n");
#line 1317
    execl("/usr/bin//passwd", "passwd", (char *)((void *)0));
#line 1318
    perror("passwd");
  } else {
#line 1320
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Password change required but no TTY available.\n");
  }
#line 1323
  exit(1);
}
}
#line 1326 "session.c"
static void launch_login(struct passwd *pw , char const   *hostname ) 
{ 

  {
#line 1331
  execl("/bin/login", "login", "-h", hostname, "-p", "-f", "--", pw->pw_name, (char *)((void *)0));
#line 1343
  perror("login");
#line 1344
  exit(1);
}
}
#line 1347 "session.c"
static void child_close_fds(void) 
{ int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1352
  tmp___2 = packet_get_connection_in();
#line 1352
  tmp___3 = packet_get_connection_out();
#line 1352
  if (tmp___2 == tmp___3) {
#line 1353
    tmp = packet_get_connection_in();
#line 1353
    close(tmp);
  } else {
#line 1355
    tmp___0 = packet_get_connection_in();
#line 1355
    close(tmp___0);
#line 1356
    tmp___1 = packet_get_connection_out();
#line 1356
    close(tmp___1);
  }
#line 1363
  channel_close_all();
#line 1369
  endpwent();
#line 1377
  i = 3;
#line 1377
  while (i < 64) {
#line 1378
    close(i);
#line 1377
    i ++;
  }
#line 1379
  return;
}
}
#line 1386 "session.c"
void do_child(Session *s , char const   *command ) 
{ char **env ;
  char *argv[10] ;
  char const   *shell ;
  char const   *shell0 ;
  char const   *hostname ;
  struct passwd *pw ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char argv0___0[256] ;
  int *tmp___3 ;
  size_t tmp___4 ;

  {
#line 1392
  hostname = (char const   *)((void *)0);
#line 1393
  pw = s->pw;
#line 1396
  destroy_sensitive_data();
#line 1399
  if ((s->authctxt)->force_pwchange) {
#line 1400
    do_setusercontext(pw);
#line 1401
    child_close_fds();
#line 1402
    do_pwchange(s);
#line 1403
    exit(1);
  }
#line 1407
  if (options.use_login) {
#line 1407
    if ((unsigned int )command != (unsigned int )((void *)0)) {
#line 1408
      options.use_login = 0;
    }
  }
#line 1418
  if (! options.use_login) {
#line 1424
    do_nologin(pw);
#line 1425
    do_setusercontext(pw);
  }
#line 1433
  if ((int )*(pw->pw_shell + 0) == 0) {
#line 1433
    shell = "/bin/sh";
  } else {
#line 1433
    shell = (char const   *)pw->pw_shell;
  }
#line 1439
  env = do_setup_env(s, shell);
#line 1446
  if (options.use_login) {
#line 1447
    hostname = get_remote_name_or_ip(utmp_len, options.use_dns);
  }
#line 1456
  child_close_fds();
#line 1462
  environ = env;
#line 1491
  tmp___1 = chdir((char const   *)pw->pw_dir);
#line 1491
  if (tmp___1 < 0) {
#line 1492
    tmp = __errno_location();
#line 1492
    tmp___0 = strerror(*tmp);
#line 1492
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not chdir to home directory %s: %s\n",
            pw->pw_dir, tmp___0);
  }
#line 1500
  if (! options.use_login) {
#line 1501
    do_rc_files(s, shell);
  }
#line 1504
  mysignal(13, (void (*)(int  ))0);
#line 1506
  if (options.use_login) {
#line 1507
    launch_login(pw, hostname);
  }
#line 1512
  tmp___2 = strrchr(shell, '/');
#line 1512
  shell0 = (char const   *)tmp___2;
#line 1512
  if ((unsigned int )shell0 != (unsigned int )((void *)0)) {
#line 1513
    shell0 ++;
  } else {
#line 1515
    shell0 = shell;
  }
#line 1522
  if (! command) {
#line 1526
    argv0___0[0] = (char )'-';
#line 1528
    tmp___4 = strlcpy(argv0___0 + 1, shell0, sizeof(argv0___0) - 1U);
#line 1528
    if (tmp___4 >= sizeof(argv0___0) - 1U) {
#line 1530
      tmp___3 = __errno_location();
#line 1530
      *tmp___3 = 22;
#line 1531
      perror(shell);
#line 1532
      exit(1);
    }
#line 1536
    argv[0] = argv0___0;
#line 1537
    argv[1] = (char *)((void *)0);
#line 1538
    execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 1541
    perror(shell);
#line 1542
    exit(1);
  }
#line 1548
  argv[0] = (char *)shell0;
#line 1549
  argv[1] = (char *)"-c";
#line 1550
  argv[2] = (char *)command;
#line 1551
  argv[3] = (char *)((void *)0);
#line 1552
  execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 1553
  perror(shell);
#line 1554
  exit(1);
}
}
#line 1561 "session.c"
static int did_init___0  =    0;
#line 1557 "session.c"
Session *session_new(void) 
{ int i ;
  Session *s ;

  {
#line 1562
  if (! did_init___0) {
#line 1563
    debug("session_new: init");
#line 1564
    i = 0;
#line 1564
    while (i < 10) {
#line 1565
      sessions[i].used = 0;
#line 1564
      i ++;
    }
#line 1567
    did_init___0 = 1;
  }
#line 1569
  i = 0;
#line 1569
  while (i < 10) {
#line 1570
    s = & sessions[i];
#line 1571
    if (! s->used) {
#line 1572
      memset((void *)s, 0, sizeof(*s));
#line 1573
      s->chanid = -1;
#line 1574
      s->ptyfd = -1;
#line 1575
      s->ttyfd = -1;
#line 1576
      s->used = 1;
#line 1577
      s->self = i;
#line 1578
      debug("session_new: session %d", i);
#line 1579
      return (s);
    }
#line 1569
    i ++;
  }
#line 1582
  return ((Session *)((void *)0));
}
}
#line 1585 "session.c"
static void session_dump(void) 
{ int i ;
  Session *s ;

  {
#line 1589
  i = 0;
#line 1589
  while (i < 10) {
#line 1590
    s = & sessions[i];
#line 1591
    debug("dump: used %d session %d %p channel %d pid %ld", s->used, s->self, s, s->chanid,
          (long )s->pid);
#line 1589
    i ++;
  }
#line 1598
  return;
}
}
#line 1600 "session.c"
int session_open(Authctxt *authctxt___0 , int chanid ) 
{ Session *s ;
  Session *tmp ;

  {
#line 1603
  tmp = session_new();
#line 1603
  s = tmp;
#line 1604
  debug("session_open: channel %d", chanid);
#line 1605
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1606
    error("no more sessions");
#line 1607
    return (0);
  }
#line 1609
  s->authctxt = authctxt___0;
#line 1610
  s->pw = authctxt___0->pw;
#line 1611
  if ((unsigned int )s->pw == (unsigned int )((void *)0)) {
#line 1612
    fatal("no user for session %d", s->self);
  } else {
#line 1611
    if (! authctxt___0->valid) {
#line 1612
      fatal("no user for session %d", s->self);
    }
  }
#line 1613
  debug("session_open: session %d: link with channel %d", s->self, chanid);
#line 1614
  s->chanid = chanid;
#line 1615
  return (1);
}
}
#line 1618 "session.c"
Session *session_by_tty(char *tty ) 
{ int i ;
  Session *s ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1622
  i = 0;
#line 1622
  while (i < 10) {
#line 1623
    s = & sessions[i];
#line 1624
    if (s->used) {
#line 1624
      if (s->ttyfd != -1) {
#line 1624
        if (0) {
#line 1624
          __s1_len = strlen((char const   *)(s->tty));
#line 1624
          __s2_len = strlen((char const   *)tty);
#line 1624
          if (! ((unsigned int )((void const   *)(s->tty + 1)) - (unsigned int )((void const   *)(s->tty)) == 1U)) {
            goto _L___0;
          } else {
#line 1624
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 1624
              if (! ((unsigned int )((void const   *)(tty + 1)) - (unsigned int )((void const   *)tty) == 1U)) {
#line 1624
                tmp___8 = 1;
              } else {
#line 1624
                if (__s2_len >= 4U) {
#line 1624
                  tmp___8 = 1;
                } else {
#line 1624
                  tmp___8 = 0;
                }
              }
            } else {
#line 1624
              tmp___8 = 0;
            }
          }
#line 1624
          if (tmp___8) {
#line 1624
            tmp___4 = __builtin_strcmp((char const   *)(s->tty), (char const   *)tty);
          } else {
#line 1624
            tmp___7 = __builtin_strcmp((char const   *)(s->tty), (char const   *)tty);
#line 1624
            tmp___4 = tmp___7;
          }
        } else {
#line 1624
          tmp___7 = __builtin_strcmp((char const   *)(s->tty), (char const   *)tty);
#line 1624
          tmp___4 = tmp___7;
        }
#line 1624
        if (tmp___4 == 0) {
#line 1625
          debug("session_by_tty: session %d tty %s", i, tty);
#line 1626
          return (s);
        }
      }
    }
#line 1622
    i ++;
  }
#line 1629
  debug("session_by_tty: unknown tty %.100s", tty);
#line 1630
  session_dump();
#line 1631
  return ((Session *)((void *)0));
}
}
#line 1634 "session.c"
static Session *session_by_channel(int id ) 
{ int i ;
  Session *s ;

  {
#line 1638
  i = 0;
#line 1638
  while (i < 10) {
#line 1639
    s = & sessions[i];
#line 1640
    if (s->used) {
#line 1640
      if (s->chanid == id) {
#line 1641
        debug("session_by_channel: session %d channel %d", i, id);
#line 1642
        return (s);
      }
    }
#line 1638
    i ++;
  }
#line 1645
  debug("session_by_channel: unknown channel %d", id);
#line 1646
  session_dump();
#line 1647
  return ((Session *)((void *)0));
}
}
#line 1650 "session.c"
static Session *session_by_pid(pid_t pid ) 
{ int i ;
  Session *s ;

  {
#line 1654
  debug("session_by_pid: pid %ld", (long )pid);
#line 1655
  i = 0;
#line 1655
  while (i < 10) {
#line 1656
    s = & sessions[i];
#line 1657
    if (s->used) {
#line 1657
      if (s->pid == pid) {
#line 1658
        return (s);
      }
    }
#line 1655
    i ++;
  }
#line 1660
  error("session_by_pid: unknown pid %ld", (long )pid);
#line 1661
  session_dump();
#line 1662
  return ((Session *)((void *)0));
}
}
#line 1665 "session.c"
static int session_window_change_req(Session *s ) 
{ int _len ;
  int tmp ;

  {
#line 1668
  s->col = packet_get_int();
#line 1669
  s->row = packet_get_int();
#line 1670
  s->xpixel = packet_get_int();
#line 1671
  s->ypixel = packet_get_int();
#line 1672
  while (1) {
#line 1672
    tmp = packet_remaining();
#line 1672
    _len = tmp;
#line 1672
    if (_len > 0) {
#line 1672
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            1672);
#line 1672
      packet_disconnect("Packet integrity error.");
    }
#line 1672
    break;
  }
#line 1673
  pty_change_window_size(s->ptyfd, (int )s->row, (int )s->col, (int )s->xpixel, (int )s->ypixel);
#line 1674
  return (1);
}
}
#line 1677 "session.c"
static int session_pty_req(Session *s ) 
{ u_int len ;
  int n_bytes ;
  u_long tmp ;
  void *tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___13 ;
  int _len ;
  int tmp___14 ;

  {
#line 1683
  if (no_pty_flag) {
#line 1684
    debug("Allocating a pty not permitted for this authentication.");
#line 1685
    return (0);
  }
#line 1687
  if (s->ttyfd != -1) {
#line 1688
    packet_disconnect("Protocol error: you already have a pty.");
#line 1689
    return (0);
  }
#line 1692
  if (options.print_lastlog) {
#line 1693
    s->hostname[0] = (char )'\000';
#line 1694
    tmp = get_last_login_time((s->pw)->pw_uid, (char const   *)(s->pw)->pw_name, s->hostname,
                              sizeof(s->hostname));
#line 1694
    s->last_login_time = (long )tmp;
  }
#line 1698
  tmp___0 = packet_get_string(& len);
#line 1698
  s->term = (char *)tmp___0;
#line 1700
  if (compat20) {
#line 1701
    s->col = packet_get_int();
#line 1702
    s->row = packet_get_int();
  } else {
#line 1704
    s->row = packet_get_int();
#line 1705
    s->col = packet_get_int();
  }
#line 1707
  s->xpixel = packet_get_int();
#line 1708
  s->ypixel = packet_get_int();
#line 1710
  if (0) {
#line 1710
    __s1_len = strlen((char const   *)s->term);
#line 1710
    __s2_len = strlen("");
#line 1710
    if (! ((unsigned int )((void const   *)(s->term + 1)) - (unsigned int )((void const   *)s->term) == 1U)) {
      goto _L___0;
    } else {
#line 1710
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1710
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 1710
          tmp___10 = 1;
        } else {
#line 1710
          if (__s2_len >= 4U) {
#line 1710
            tmp___10 = 1;
          } else {
#line 1710
            tmp___10 = 0;
          }
        }
      } else {
#line 1710
        tmp___10 = 0;
      }
    }
#line 1710
    if (tmp___10) {
#line 1710
      tmp___6 = __builtin_strcmp((char const   *)s->term, "");
    } else {
#line 1710
      tmp___9 = __builtin_strcmp((char const   *)s->term, "");
#line 1710
      tmp___6 = tmp___9;
    }
  } else {
#line 1710
    tmp___9 = __builtin_strcmp((char const   *)s->term, "");
#line 1710
    tmp___6 = tmp___9;
  }
#line 1710
  if (tmp___6 == 0) {
#line 1711
    xfree((void *)s->term);
#line 1712
    s->term = (char *)((void *)0);
  }
#line 1716
  debug("Allocating pty.");
#line 1717
  if (use_privsep) {
#line 1717
    tmp___13 = mm_pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, (int )sizeof(s->tty));
  } else {
#line 1717
    tmp___13 = pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, (int )sizeof(s->tty));
  }
#line 1717
  if (! tmp___13) {
#line 1718
    if (s->term) {
#line 1719
      xfree((void *)s->term);
    }
#line 1720
    s->term = (char *)((void *)0);
#line 1721
    s->ptyfd = -1;
#line 1722
    s->ttyfd = -1;
#line 1723
    error("session_pty_req: session %d alloc failed", s->self);
#line 1724
    return (0);
  }
#line 1726
  debug("session_pty_req: session %d alloc %s", s->self, s->tty);
#line 1729
  if (! compat20) {
#line 1730
    n_bytes = packet_remaining();
  }
#line 1731
  tty_parse_modes(s->ttyfd, & n_bytes);
#line 1733
  if (! use_privsep) {
#line 1734
    pty_setowner(s->pw, (char const   *)(s->tty));
  }
#line 1737
  pty_change_window_size(s->ptyfd, (int )s->row, (int )s->col, (int )s->xpixel, (int )s->ypixel);
#line 1739
  while (1) {
#line 1739
    tmp___14 = packet_remaining();
#line 1739
    _len = tmp___14;
#line 1739
    if (_len > 0) {
#line 1739
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            1739);
#line 1739
      packet_disconnect("Packet integrity error.");
    }
#line 1739
    break;
  }
#line 1740
  session_proctitle(s);
#line 1741
  return (1);
}
}
#line 1744 "session.c"
static int session_subsystem_req(Session *s ) 
{ struct stat st ;
  u_int len ;
  int success ;
  char *cmd ;
  char *subsys ;
  void *tmp ;
  int i ;
  int _len ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___9 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 1749
  success = 0;
#line 1750
  tmp = packet_get_string(& len);
#line 1750
  subsys = (char *)tmp;
#line 1753
  while (1) {
#line 1753
    tmp___0 = packet_remaining();
#line 1753
    _len = tmp___0;
#line 1753
    if (_len > 0) {
#line 1753
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            1753);
#line 1753
      packet_disconnect("Packet integrity error.");
    }
#line 1753
    break;
  }
#line 1754
  logit("subsystem request for %.100s", subsys);
#line 1756
  i = 0;
#line 1756
  while ((u_int )i < options.num_subsystems) {
#line 1757
    if (0) {
#line 1757
      __s1_len = strlen((char const   *)subsys);
#line 1757
      __s2_len = strlen((char const   *)options.subsystem_name[i]);
#line 1757
      if (! ((unsigned int )((void const   *)(subsys + 1)) - (unsigned int )((void const   *)subsys) == 1U)) {
        goto _L___0;
      } else {
#line 1757
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 1757
          if (! ((unsigned int )((void const   *)(options.subsystem_name[i] + 1)) - (unsigned int )((void const   *)options.subsystem_name[i]) == 1U)) {
#line 1757
            tmp___13 = 1;
          } else {
#line 1757
            if (__s2_len >= 4U) {
#line 1757
              tmp___13 = 1;
            } else {
#line 1757
              tmp___13 = 0;
            }
          }
        } else {
#line 1757
          tmp___13 = 0;
        }
      }
#line 1757
      if (tmp___13) {
#line 1757
        tmp___9 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
      } else {
#line 1757
        tmp___12 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
#line 1757
        tmp___9 = tmp___12;
      }
    } else {
#line 1757
      tmp___12 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
#line 1757
      tmp___9 = tmp___12;
    }
#line 1757
    if (tmp___9 == 0) {
#line 1758
      cmd = options.subsystem_command[i];
#line 1759
      tmp___3 = stat((char const   * __restrict  )cmd, (struct stat * __restrict  )(& st));
#line 1759
      if (tmp___3 < 0) {
#line 1760
        tmp___1 = __errno_location();
#line 1760
        tmp___2 = strerror(*tmp___1);
#line 1760
        error("subsystem: cannot stat %s: %s", cmd, tmp___2);
#line 1762
        break;
      }
#line 1764
      debug("subsystem: exec() %s", cmd);
#line 1765
      s->is_subsystem = 1;
#line 1766
      do_exec(s, (char const   *)cmd);
#line 1767
      success = 1;
#line 1768
      break;
    }
#line 1756
    i ++;
  }
#line 1772
  if (! success) {
#line 1773
    logit("subsystem request for %.100s failed, subsystem not found", subsys);
  }
#line 1776
  xfree((void *)subsys);
#line 1777
  return (success);
}
}
#line 1780 "session.c"
static int session_x11_req(Session *s ) 
{ int success ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int _len ;
  int tmp___2 ;

  {
#line 1785
  tmp = packet_get_char();
#line 1785
  s->single_connection = (int )tmp;
#line 1786
  tmp___0 = packet_get_string((u_int *)((void *)0));
#line 1786
  s->auth_proto = (char *)tmp___0;
#line 1787
  tmp___1 = packet_get_string((u_int *)((void *)0));
#line 1787
  s->auth_data = (char *)tmp___1;
#line 1788
  s->screen = packet_get_int();
#line 1789
  while (1) {
#line 1789
    tmp___2 = packet_remaining();
#line 1789
    _len = tmp___2;
#line 1789
    if (_len > 0) {
#line 1789
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            1789);
#line 1789
      packet_disconnect("Packet integrity error.");
    }
#line 1789
    break;
  }
#line 1791
  success = session_setup_x11fwd(s);
#line 1792
  if (! success) {
#line 1793
    xfree((void *)s->auth_proto);
#line 1794
    xfree((void *)s->auth_data);
#line 1795
    s->auth_proto = (char *)((void *)0);
#line 1796
    s->auth_data = (char *)((void *)0);
  }
#line 1798
  return (success);
}
}
#line 1801 "session.c"
static int session_shell_req(Session *s ) 
{ int _len ;
  int tmp ;

  {
#line 1804
  while (1) {
#line 1804
    tmp = packet_remaining();
#line 1804
    _len = tmp;
#line 1804
    if (_len > 0) {
#line 1804
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            1804);
#line 1804
      packet_disconnect("Packet integrity error.");
    }
#line 1804
    break;
  }
#line 1805
  do_exec(s, (char const   *)((void *)0));
#line 1806
  return (1);
}
}
#line 1809 "session.c"
static int session_exec_req(Session *s ) 
{ u_int len ;
  char *command ;
  void *tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 1813
  tmp = packet_get_string(& len);
#line 1813
  command = (char *)tmp;
#line 1814
  while (1) {
#line 1814
    tmp___0 = packet_remaining();
#line 1814
    _len = tmp___0;
#line 1814
    if (_len > 0) {
#line 1814
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            1814);
#line 1814
      packet_disconnect("Packet integrity error.");
    }
#line 1814
    break;
  }
#line 1815
  do_exec(s, (char const   *)command);
#line 1816
  xfree((void *)command);
#line 1817
  return (1);
}
}
#line 1820 "session.c"
static int session_break_req(Session *s ) 
{ u_int break_length ;
  int _len ;
  int tmp ;
  int tmp___0 ;

  {
#line 1825
  break_length = packet_get_int();
#line 1826
  while (1) {
#line 1826
    tmp = packet_remaining();
#line 1826
    _len = tmp;
#line 1826
    if (_len > 0) {
#line 1826
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            1826);
#line 1826
      packet_disconnect("Packet integrity error.");
    }
#line 1826
    break;
  }
#line 1828
  if (s->ttyfd == -1) {
#line 1830
    return (0);
  } else {
#line 1828
    tmp___0 = tcsendbreak(s->ttyfd, 0);
#line 1828
    if (tmp___0 < 0) {
#line 1830
      return (0);
    }
  }
#line 1831
  return (1);
}
}
#line 1837
static int session_auth_agent_req(Session *s ) ;
#line 1837 "session.c"
static int called___1  =    0;
#line 1834 "session.c"
static int session_auth_agent_req(Session *s ) 
{ int _len ;
  int tmp ;
  int tmp___0 ;

  {
#line 1838
  while (1) {
#line 1838
    tmp = packet_remaining();
#line 1838
    _len = tmp;
#line 1838
    if (_len > 0) {
#line 1838
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            1838);
#line 1838
      packet_disconnect("Packet integrity error.");
    }
#line 1838
    break;
  }
#line 1839
  if (no_agent_forwarding_flag) {
#line 1840
    debug("session_auth_agent_req: no_agent_forwarding_flag");
#line 1841
    return (0);
  }
#line 1843
  if (called___1) {
#line 1844
    return (0);
  } else {
#line 1846
    called___1 = 1;
#line 1847
    tmp___0 = auth_input_request_forwarding(s->pw);
#line 1847
    return (tmp___0);
  }
}
}
#line 1851 "session.c"
int session_input_channel_req(Channel *c , char const   *rtype ) 
{ int success ;
  Session *s ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___54 ;
  int tmp___57 ;
  int tmp___58 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___64 ;
  int tmp___67 ;
  int tmp___68 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___74 ;
  int tmp___77 ;
  int tmp___78 ;

  {
#line 1854
  success = 0;
#line 1857
  s = session_by_channel(c->self);
#line 1857
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1858
    logit("session_input_channel_req: no session %d req %.100s", c->self, rtype);
#line 1860
    return (0);
  }
#line 1862
  debug("session_input_channel_req: session %d req %s", s->self, rtype);
#line 1868
  if (c->type == 10) {
#line 1869
    if (0) {
#line 1869
      __s1_len___5 = strlen(rtype);
#line 1869
      __s2_len___5 = strlen("shell");
#line 1869
      if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
        goto _L___12;
      } else {
#line 1869
        if (__s1_len___5 >= 4U) {
          _L___12: /* CIL Label */ 
#line 1869
          if (! ((unsigned int )((void const   *)("shell" + 1)) - (unsigned int )((void const   *)"shell") == 1U)) {
#line 1869
            tmp___68 = 1;
          } else {
#line 1869
            if (__s2_len___5 >= 4U) {
#line 1869
              tmp___68 = 1;
            } else {
#line 1869
              tmp___68 = 0;
            }
          }
        } else {
#line 1869
          tmp___68 = 0;
        }
      }
#line 1869
      if (tmp___68) {
#line 1869
        tmp___64 = __builtin_strcmp(rtype, "shell");
      } else {
#line 1869
        tmp___67 = __builtin_strcmp(rtype, "shell");
#line 1869
        tmp___64 = tmp___67;
      }
    } else {
#line 1869
      tmp___67 = __builtin_strcmp(rtype, "shell");
#line 1869
      tmp___64 = tmp___67;
    }
#line 1869
    if (tmp___64 == 0) {
#line 1870
      success = session_shell_req(s);
    } else {
#line 1871
      if (0) {
#line 1871
        __s1_len___4 = strlen(rtype);
#line 1871
        __s2_len___4 = strlen("exec");
#line 1871
        if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
          goto _L___10;
        } else {
#line 1871
          if (__s1_len___4 >= 4U) {
            _L___10: /* CIL Label */ 
#line 1871
            if (! ((unsigned int )((void const   *)("exec" + 1)) - (unsigned int )((void const   *)"exec") == 1U)) {
#line 1871
              tmp___58 = 1;
            } else {
#line 1871
              if (__s2_len___4 >= 4U) {
#line 1871
                tmp___58 = 1;
              } else {
#line 1871
                tmp___58 = 0;
              }
            }
          } else {
#line 1871
            tmp___58 = 0;
          }
        }
#line 1871
        if (tmp___58) {
#line 1871
          tmp___54 = __builtin_strcmp(rtype, "exec");
        } else {
#line 1871
          tmp___57 = __builtin_strcmp(rtype, "exec");
#line 1871
          tmp___54 = tmp___57;
        }
      } else {
#line 1871
        tmp___57 = __builtin_strcmp(rtype, "exec");
#line 1871
        tmp___54 = tmp___57;
      }
#line 1871
      if (tmp___54 == 0) {
#line 1872
        success = session_exec_req(s);
      } else {
#line 1873
        if (0) {
#line 1873
          __s1_len___3 = strlen(rtype);
#line 1873
          __s2_len___3 = strlen("pty-req");
#line 1873
          if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
            goto _L___8;
          } else {
#line 1873
            if (__s1_len___3 >= 4U) {
              _L___8: /* CIL Label */ 
#line 1873
              if (! ((unsigned int )((void const   *)("pty-req" + 1)) - (unsigned int )((void const   *)"pty-req") == 1U)) {
#line 1873
                tmp___48 = 1;
              } else {
#line 1873
                if (__s2_len___3 >= 4U) {
#line 1873
                  tmp___48 = 1;
                } else {
#line 1873
                  tmp___48 = 0;
                }
              }
            } else {
#line 1873
              tmp___48 = 0;
            }
          }
#line 1873
          if (tmp___48) {
#line 1873
            tmp___44 = __builtin_strcmp(rtype, "pty-req");
          } else {
#line 1873
            tmp___47 = __builtin_strcmp(rtype, "pty-req");
#line 1873
            tmp___44 = tmp___47;
          }
        } else {
#line 1873
          tmp___47 = __builtin_strcmp(rtype, "pty-req");
#line 1873
          tmp___44 = tmp___47;
        }
#line 1873
        if (tmp___44 == 0) {
#line 1874
          success = session_pty_req(s);
        } else {
#line 1875
          if (0) {
#line 1875
            __s1_len___2 = strlen(rtype);
#line 1875
            __s2_len___2 = strlen("x11-req");
#line 1875
            if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
              goto _L___6;
            } else {
#line 1875
              if (__s1_len___2 >= 4U) {
                _L___6: /* CIL Label */ 
#line 1875
                if (! ((unsigned int )((void const   *)("x11-req" + 1)) - (unsigned int )((void const   *)"x11-req") == 1U)) {
#line 1875
                  tmp___38 = 1;
                } else {
#line 1875
                  if (__s2_len___2 >= 4U) {
#line 1875
                    tmp___38 = 1;
                  } else {
#line 1875
                    tmp___38 = 0;
                  }
                }
              } else {
#line 1875
                tmp___38 = 0;
              }
            }
#line 1875
            if (tmp___38) {
#line 1875
              tmp___34 = __builtin_strcmp(rtype, "x11-req");
            } else {
#line 1875
              tmp___37 = __builtin_strcmp(rtype, "x11-req");
#line 1875
              tmp___34 = tmp___37;
            }
          } else {
#line 1875
            tmp___37 = __builtin_strcmp(rtype, "x11-req");
#line 1875
            tmp___34 = tmp___37;
          }
#line 1875
          if (tmp___34 == 0) {
#line 1876
            success = session_x11_req(s);
          } else {
#line 1877
            if (0) {
#line 1877
              __s1_len___1 = strlen(rtype);
#line 1877
              __s2_len___1 = strlen("auth-agent-req@openssh.com");
#line 1877
              if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
                goto _L___4;
              } else {
#line 1877
                if (__s1_len___1 >= 4U) {
                  _L___4: /* CIL Label */ 
#line 1877
                  if (! ((unsigned int )((void const   *)("auth-agent-req@openssh.com" + 1)) - (unsigned int )((void const   *)"auth-agent-req@openssh.com") == 1U)) {
#line 1877
                    tmp___28 = 1;
                  } else {
#line 1877
                    if (__s2_len___1 >= 4U) {
#line 1877
                      tmp___28 = 1;
                    } else {
#line 1877
                      tmp___28 = 0;
                    }
                  }
                } else {
#line 1877
                  tmp___28 = 0;
                }
              }
#line 1877
              if (tmp___28) {
#line 1877
                tmp___24 = __builtin_strcmp(rtype, "auth-agent-req@openssh.com");
              } else {
#line 1877
                tmp___27 = __builtin_strcmp(rtype, "auth-agent-req@openssh.com");
#line 1877
                tmp___24 = tmp___27;
              }
            } else {
#line 1877
              tmp___27 = __builtin_strcmp(rtype, "auth-agent-req@openssh.com");
#line 1877
              tmp___24 = tmp___27;
            }
#line 1877
            if (tmp___24 == 0) {
#line 1878
              success = session_auth_agent_req(s);
            } else {
#line 1879
              if (0) {
#line 1879
                __s1_len___0 = strlen(rtype);
#line 1879
                __s2_len___0 = strlen("subsystem");
#line 1879
                if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
                  goto _L___2;
                } else {
#line 1879
                  if (__s1_len___0 >= 4U) {
                    _L___2: /* CIL Label */ 
#line 1879
                    if (! ((unsigned int )((void const   *)("subsystem" + 1)) - (unsigned int )((void const   *)"subsystem") == 1U)) {
#line 1879
                      tmp___18 = 1;
                    } else {
#line 1879
                      if (__s2_len___0 >= 4U) {
#line 1879
                        tmp___18 = 1;
                      } else {
#line 1879
                        tmp___18 = 0;
                      }
                    }
                  } else {
#line 1879
                    tmp___18 = 0;
                  }
                }
#line 1879
                if (tmp___18) {
#line 1879
                  tmp___14 = __builtin_strcmp(rtype, "subsystem");
                } else {
#line 1879
                  tmp___17 = __builtin_strcmp(rtype, "subsystem");
#line 1879
                  tmp___14 = tmp___17;
                }
              } else {
#line 1879
                tmp___17 = __builtin_strcmp(rtype, "subsystem");
#line 1879
                tmp___14 = tmp___17;
              }
#line 1879
              if (tmp___14 == 0) {
#line 1880
                success = session_subsystem_req(s);
              } else {
#line 1881
                if (0) {
#line 1881
                  __s1_len = strlen(rtype);
#line 1881
                  __s2_len = strlen("break");
#line 1881
                  if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
                    goto _L___0;
                  } else {
#line 1881
                    if (__s1_len >= 4U) {
                      _L___0: /* CIL Label */ 
#line 1881
                      if (! ((unsigned int )((void const   *)("break" + 1)) - (unsigned int )((void const   *)"break") == 1U)) {
#line 1881
                        tmp___8 = 1;
                      } else {
#line 1881
                        if (__s2_len >= 4U) {
#line 1881
                          tmp___8 = 1;
                        } else {
#line 1881
                          tmp___8 = 0;
                        }
                      }
                    } else {
#line 1881
                      tmp___8 = 0;
                    }
                  }
#line 1881
                  if (tmp___8) {
#line 1881
                    tmp___4 = __builtin_strcmp(rtype, "break");
                  } else {
#line 1881
                    tmp___7 = __builtin_strcmp(rtype, "break");
#line 1881
                    tmp___4 = tmp___7;
                  }
                } else {
#line 1881
                  tmp___7 = __builtin_strcmp(rtype, "break");
#line 1881
                  tmp___4 = tmp___7;
                }
#line 1881
                if (tmp___4 == 0) {
#line 1882
                  success = session_break_req(s);
                }
              }
            }
          }
        }
      }
    }
  }
#line 1885
  if (0) {
#line 1885
    __s1_len___6 = strlen(rtype);
#line 1885
    __s2_len___6 = strlen("window-change");
#line 1885
    if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
      goto _L___14;
    } else {
#line 1885
      if (__s1_len___6 >= 4U) {
        _L___14: /* CIL Label */ 
#line 1885
        if (! ((unsigned int )((void const   *)("window-change" + 1)) - (unsigned int )((void const   *)"window-change") == 1U)) {
#line 1885
          tmp___78 = 1;
        } else {
#line 1885
          if (__s2_len___6 >= 4U) {
#line 1885
            tmp___78 = 1;
          } else {
#line 1885
            tmp___78 = 0;
          }
        }
      } else {
#line 1885
        tmp___78 = 0;
      }
    }
#line 1885
    if (tmp___78) {
#line 1885
      tmp___74 = __builtin_strcmp(rtype, "window-change");
    } else {
#line 1885
      tmp___77 = __builtin_strcmp(rtype, "window-change");
#line 1885
      tmp___74 = tmp___77;
    }
  } else {
#line 1885
    tmp___77 = __builtin_strcmp(rtype, "window-change");
#line 1885
    tmp___74 = tmp___77;
  }
#line 1885
  if (tmp___74 == 0) {
#line 1886
    success = session_window_change_req(s);
  }
#line 1888
  return (success);
}
}
#line 1891 "session.c"
void session_set_fds(Session *s , int fdin___0 , int fdout___0 , int fderr___0 ) 
{ int tmp ;

  {
#line 1894
  if (! compat20) {
#line 1895
    fatal("session_set_fds: called for proto != 2.0");
  }
#line 1900
  if (s->chanid == -1) {
#line 1901
    fatal("no channel for session %d", s->self);
  }
#line 1902
  if (fderr___0 == -1) {
#line 1902
    tmp = 0;
  } else {
#line 1902
    tmp = 1;
  }
#line 1902
  channel_set_fds(s->chanid, fdout___0, fdin___0, fderr___0, tmp, 1, 131072U);
#line 1907
  return;
}
}
#line 1913 "session.c"
void session_pty_cleanup2(Session *s ) 
{ __uid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 1916
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1917
    error("session_pty_cleanup: no session");
#line 1918
    return;
  }
#line 1920
  if (s->ttyfd == -1) {
#line 1921
    return;
  }
#line 1923
  debug("session_pty_cleanup: session %d release %s", s->self, s->tty);
#line 1926
  if (s->pid != 0) {
#line 1927
    record_logout(s->pid, (char const   *)(s->tty), (char const   *)(s->pw)->pw_name);
  }
#line 1930
  tmp = getuid();
#line 1930
  if (tmp == 0U) {
#line 1931
    pty_release((char const   *)(s->tty));
  }
#line 1938
  tmp___2 = close(s->ptymaster);
#line 1938
  if (tmp___2 < 0) {
#line 1939
    tmp___0 = __errno_location();
#line 1939
    tmp___1 = strerror(*tmp___0);
#line 1939
    error("close(s->ptymaster/%d): %s", s->ptymaster, tmp___1);
  }
#line 1942
  s->ttyfd = -1;
#line 1943
  return;
}
}
#line 1945 "session.c"
void session_pty_cleanup(Session *s ) 
{ 

  {
#line 1948
  if (use_privsep) {
#line 1948
    mm_session_pty_cleanup2(s);
  } else {
#line 1948
    session_pty_cleanup2(s);
  }
#line 1949
  return;
}
}
#line 1951 "session.c"
static char *sig2name(int sig ) 
{ 

  {
#line 1955
  if (sig == 6) {
#line 1955
    return ((char *)"ABRT");
  }
#line 1956
  if (sig == 14) {
#line 1956
    return ((char *)"ALRM");
  }
#line 1957
  if (sig == 8) {
#line 1957
    return ((char *)"FPE");
  }
#line 1958
  if (sig == 1) {
#line 1958
    return ((char *)"HUP");
  }
#line 1959
  if (sig == 4) {
#line 1959
    return ((char *)"ILL");
  }
#line 1960
  if (sig == 2) {
#line 1960
    return ((char *)"INT");
  }
#line 1961
  if (sig == 9) {
#line 1961
    return ((char *)"KILL");
  }
#line 1962
  if (sig == 13) {
#line 1962
    return ((char *)"PIPE");
  }
#line 1963
  if (sig == 3) {
#line 1963
    return ((char *)"QUIT");
  }
#line 1964
  if (sig == 11) {
#line 1964
    return ((char *)"SEGV");
  }
#line 1965
  if (sig == 15) {
#line 1965
    return ((char *)"TERM");
  }
#line 1966
  if (sig == 10) {
#line 1966
    return ((char *)"USR1");
  }
#line 1967
  if (sig == 12) {
#line 1967
    return ((char *)"USR2");
  }
#line 1969
  return ((char *)"SIG@openssh.com");
}
}
#line 1972 "session.c"
static void session_exit_message(Session *s , int status ) 
{ Channel *c ;
  union __anonunion_78 __constr_expr_0 ;
  union __anonunion_79 __constr_expr_1 ;
  char *tmp ;
  union __anonunion_80___0 __constr_expr_2 ;
  union __anonunion_81___0 __constr_expr_3 ;
  union __anonunion_82___0 __constr_expr_4 ;

  {
#line 1977
  c = channel_lookup(s->chanid);
#line 1977
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1978
    fatal("session_exit_message: session %d: no channel %d", s->self, s->chanid);
  }
#line 1980
  debug("session_exit_message: session %d channel %d pid %ld", s->self, s->chanid,
        (long )s->pid);
#line 1983
  __constr_expr_4.__in = status;
#line 1983
  if ((__constr_expr_4.__i & 127) == 0) {
#line 1984
    channel_request_start(s->chanid, (char *)"exit-status", 0);
#line 1985
    __constr_expr_0.__in = status;
#line 1985
    packet_put_int((unsigned int )((__constr_expr_0.__i & 65280) >> 8));
#line 1986
    packet_send();
  } else {
#line 1987
    __constr_expr_3.__in = status;
#line 1987
    if ((int )((signed char )((__constr_expr_3.__i & 127) + 1)) >> 1 > 0) {
#line 1988
      channel_request_start(s->chanid, (char *)"exit-signal", 0);
#line 1989
      __constr_expr_1.__in = status;
#line 1989
      tmp = sig2name(__constr_expr_1.__i & 127);
#line 1989
      packet_put_cstring((char const   *)tmp);
#line 1991
      __constr_expr_2.__in = status;
#line 1991
      packet_put_char(__constr_expr_2.__i & 128);
#line 1995
      packet_put_cstring("");
#line 1996
      packet_put_cstring("");
#line 1997
      packet_send();
    } else {
#line 2000
      packet_disconnect("wait returned status %04x.", status);
    }
  }
#line 2004
  debug("session_exit_message: release channel %d", s->chanid);
#line 2005
  channel_cancel_cleanup(s->chanid);
#line 2012
  if (c->ostate != 3U) {
#line 2013
    chan_write_failed(c);
  }
#line 2014
  s->chanid = -1;
#line 2015
  return;
}
}
#line 2017 "session.c"
void session_close(Session *s ) 
{ 

  {
#line 2020
  debug("session_close: session %d pid %ld", s->self, (long )s->pid);
#line 2021
  if (s->ttyfd != -1) {
#line 2022
    session_pty_cleanup(s);
  }
#line 2023
  if (s->term) {
#line 2024
    xfree((void *)s->term);
  }
#line 2025
  if (s->display) {
#line 2026
    xfree((void *)s->display);
  }
#line 2027
  if (s->auth_display) {
#line 2028
    xfree((void *)s->auth_display);
  }
#line 2029
  if (s->auth_data) {
#line 2030
    xfree((void *)s->auth_data);
  }
#line 2031
  if (s->auth_proto) {
#line 2032
    xfree((void *)s->auth_proto);
  }
#line 2033
  s->used = 0;
#line 2034
  session_proctitle(s);
#line 2035
  return;
}
}
#line 2037 "session.c"
void session_close_by_pid(pid_t pid , int status ) 
{ Session *s ;
  Session *tmp ;

  {
#line 2040
  tmp = session_by_pid(pid);
#line 2040
  s = tmp;
#line 2041
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 2042
    debug("session_close_by_pid: no session for pid %ld", (long )pid);
#line 2044
    return;
  }
#line 2046
  if (s->chanid != -1) {
#line 2047
    session_exit_message(s, status);
  }
#line 2048
  session_close(s);
#line 2049
  return;
}
}
#line 2055 "session.c"
void session_close_by_channel(int id , void *arg ) 
{ Session *s ;
  Session *tmp ;

  {
#line 2058
  tmp = session_by_channel(id);
#line 2058
  s = tmp;
#line 2059
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 2060
    debug("session_close_by_channel: no session for id %d", id);
#line 2061
    return;
  }
#line 2063
  debug("session_close_by_channel: channel %d child %ld", id, (long )s->pid);
#line 2065
  if (s->pid != 0) {
#line 2066
    debug("session_close_by_channel: channel %d: has child", id);
#line 2071
    if (s->ttyfd != -1) {
#line 2072
      session_pty_cleanup(s);
    }
#line 2073
    return;
  }
#line 2076
  channel_cancel_cleanup(s->chanid);
#line 2077
  s->chanid = -1;
#line 2078
  session_close(s);
#line 2079
  return;
}
}
#line 2081 "session.c"
void session_destroy_all(void (*closefunc)(Session * ) ) 
{ int i ;
  Session *s ;

  {
#line 2085
  i = 0;
#line 2085
  while (i < 10) {
#line 2086
    s = & sessions[i];
#line 2087
    if (s->used) {
#line 2088
      if ((unsigned int )closefunc != (unsigned int )((void *)0)) {
#line 2089
        (*closefunc)(s);
      } else {
#line 2091
        session_close(s);
      }
    }
#line 2085
    i ++;
  }
#line 2094
  return;
}
}
#line 2099 "session.c"
static char buf___0[1024]  ;
#line 2096 "session.c"
static char *session_tty_list(void) 
{ int i ;
  char *cp ;
  Session *s ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 2103
  buf___0[0] = (char )'\000';
#line 2104
  i = 0;
#line 2104
  while (i < 10) {
#line 2105
    s = & sessions[i];
#line 2106
    if (s->used) {
#line 2106
      if (s->ttyfd != -1) {
#line 2108
        if (0) {
#line 2108
          if (0) {
#line 2108
            __s1_len___0 = strlen((char const   *)(s->tty));
#line 2108
            __s2_len___0 = strlen("/dev/");
#line 2108
            if (! ((unsigned int )((void const   *)(s->tty + 1)) - (unsigned int )((void const   *)(s->tty)) == 1U)) {
              goto _L___2;
            } else {
#line 2108
              if (__s1_len___0 >= 4U) {
                _L___2: /* CIL Label */ 
#line 2108
                if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 2108
                  tmp___22 = 1;
                } else {
#line 2108
                  if (__s2_len___0 >= 4U) {
#line 2108
                    tmp___22 = 1;
                  } else {
#line 2108
                    tmp___22 = 0;
                  }
                }
              } else {
#line 2108
                tmp___22 = 0;
              }
            }
#line 2108
            if (tmp___22) {
#line 2108
              tmp___18 = __builtin_strcmp((char const   *)(s->tty), "/dev/");
            } else {
#line 2108
              tmp___21 = __builtin_strcmp((char const   *)(s->tty), "/dev/");
#line 2108
              tmp___18 = tmp___21;
            }
          } else {
#line 2108
            tmp___21 = __builtin_strcmp((char const   *)(s->tty), "/dev/");
#line 2108
            tmp___18 = tmp___21;
          }
#line 2108
          tmp___12 = tmp___18;
        } else {
#line 2108
          tmp___12 = strncmp((char const   *)(s->tty), "/dev/", 5U);
        }
#line 2108
        if (tmp___12 != 0) {
#line 2109
          cp = strrchr((char const   *)(s->tty), '/');
#line 2110
          if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 2110
            cp = s->tty;
          } else {
#line 2110
            cp ++;
          }
        } else {
#line 2112
          cp = s->tty + 5;
        }
#line 2114
        if ((int )buf___0[0] != 0) {
#line 2115
          strlcat(buf___0, ",", sizeof(buf___0));
        }
#line 2116
        strlcat(buf___0, (char const   *)cp, sizeof(buf___0));
      }
    }
#line 2104
    i ++;
  }
#line 2119
  if ((int )buf___0[0] == 0) {
#line 2120
    strlcpy(buf___0, "notty", sizeof(buf___0));
  }
#line 2121
  return (buf___0);
}
}
#line 2124 "session.c"
void session_proctitle(Session *s ) 
{ char *tmp ;

  {
#line 2127
  if ((unsigned int )s->pw == (unsigned int )((void *)0)) {
#line 2128
    error("no user for session %d", s->self);
  } else {
#line 2130
    tmp = session_tty_list();
#line 2130
    setproctitle("%s@%s", (s->pw)->pw_name, tmp);
  }
#line 2131
  return;
}
}
#line 2133 "session.c"
int session_setup_x11fwd(Session *s ) 
{ struct stat st ;
  char display[512] ;
  char auth_display[512] ;
  char hostname[64] ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 2140
  if (no_x11_forwarding_flag) {
#line 2141
    packet_send_debug("X11 forwarding disabled in user configuration file.");
#line 2142
    return (0);
  }
#line 2144
  if (! options.x11_forwarding) {
#line 2145
    debug("X11 forwarding disabled in server configuration file.");
#line 2146
    return (0);
  }
#line 2148
  if (! options.xauth_location) {
#line 2150
    packet_send_debug("No xauth program; cannot forward with spoofing.");
#line 2151
    return (0);
  } else {
#line 2148
    tmp = stat((char const   * __restrict  )options.xauth_location, (struct stat * __restrict  )(& st));
#line 2148
    if (tmp == -1) {
#line 2150
      packet_send_debug("No xauth program; cannot forward with spoofing.");
#line 2151
      return (0);
    }
  }
#line 2153
  if (options.use_login) {
#line 2154
    packet_send_debug("X11 forwarding disabled; not compatible with UseLogin=yes.");
#line 2156
    return (0);
  }
#line 2158
  if ((unsigned int )s->display != (unsigned int )((void *)0)) {
#line 2159
    debug("X11 display already set.");
#line 2160
    return (0);
  }
#line 2162
  tmp___0 = x11_create_display_inet(options.x11_display_offset, options.x11_use_localhost,
                                    s->single_connection, & s->display_number);
#line 2162
  if (tmp___0 == -1) {
#line 2165
    debug("x11_create_display_inet failed.");
#line 2166
    return (0);
  }
#line 2170
  tmp___3 = gethostname(hostname, sizeof(hostname));
#line 2170
  if (tmp___3 < 0) {
#line 2171
    tmp___1 = __errno_location();
#line 2171
    tmp___2 = strerror(*tmp___1);
#line 2171
    fatal("gethostname: %.100s", tmp___2);
  }
#line 2177
  if (options.x11_use_localhost) {
#line 2178
    snprintf((char * __restrict  )(display), sizeof(display), (char const   * __restrict  )"localhost:%u.%u",
             s->display_number, s->screen);
#line 2180
    snprintf((char * __restrict  )(auth_display), sizeof(auth_display), (char const   * __restrict  )"unix:%u.%u",
             s->display_number, s->screen);
#line 2182
    s->display = xstrdup((char const   *)(display));
#line 2183
    s->auth_display = xstrdup((char const   *)(auth_display));
  } else {
#line 2199
    snprintf((char * __restrict  )(display), sizeof(display), (char const   * __restrict  )"%.400s:%u.%u",
             hostname, s->display_number, s->screen);
#line 2202
    s->display = xstrdup((char const   *)(display));
#line 2203
    s->auth_display = xstrdup((char const   *)(display));
  }
#line 2206
  return (1);
}
}
#line 2209 "session.c"
static void do_authenticated2(Authctxt *authctxt___0 ) 
{ 

  {
#line 2212
  server_loop2(authctxt___0);
#line 2213
  return;
}
}
#line 2218 "session.c"
static int called___2  =    0;
#line 2215 "session.c"
void do_cleanup(Authctxt *authctxt___0 ) 
{ int tmp ;

  {
#line 2220
  debug("do_cleanup");
#line 2223
  if (is_child) {
#line 2224
    return;
  }
#line 2227
  if (called___2) {
#line 2228
    return;
  }
#line 2229
  called___2 = 1;
#line 2231
  if ((unsigned int )authctxt___0 == (unsigned int )((void *)0)) {
#line 2232
    return;
  }
#line 2252
  auth_sock_cleanup_proc(authctxt___0->pw);
#line 2258
  if (! use_privsep) {
#line 2259
    session_destroy_all(& session_pty_cleanup2);
  } else {
#line 2258
    tmp = mm_is_monitor();
#line 2258
    if (tmp) {
#line 2259
      session_destroy_all(& session_pty_cleanup2);
    }
  }
#line 2260
  return;
}
}
#line 1 "auth-chall.o"
#line 34 "auth-chall.c"
KbdintDevice *devices[1] ;
#line 35 "auth-chall.c"
static KbdintDevice *device  ;
#line 37 "auth-chall.c"
char *get_challenge(Authctxt *authctxt___0 ) 
{ char *challenge ;
  char *name ;
  char *info ;
  char **prompts ;
  u_int i ;
  u_int numprompts ;
  u_int *echo_on ;
  int tmp ;

  {
#line 44
  device = devices[0];
#line 45
  if ((unsigned int )device == (unsigned int )((void *)0)) {
#line 46
    return ((char *)((void *)0));
  }
#line 47
  authctxt___0->kbdintctxt = (*(device->init_ctx))(authctxt___0);
#line 47
  if ((unsigned int )authctxt___0->kbdintctxt == (unsigned int )((void *)0)) {
#line 48
    return ((char *)((void *)0));
  }
#line 49
  tmp = (*(device->query))(authctxt___0->kbdintctxt, & name, & info, & numprompts,
                           & prompts, & echo_on);
#line 49
  if (tmp) {
#line 51
    (*(device->free_ctx))(authctxt___0->kbdintctxt);
#line 52
    authctxt___0->kbdintctxt = (void *)0;
#line 53
    return ((char *)((void *)0));
  }
#line 55
  if (numprompts < 1U) {
#line 56
    fatal("get_challenge: numprompts < 1");
  }
#line 57
  challenge = xstrdup((char const   *)*(prompts + 0));
#line 58
  i = 0U;
#line 58
  while (i < numprompts) {
#line 59
    xfree((void *)*(prompts + i));
#line 58
    i ++;
  }
#line 60
  xfree((void *)prompts);
#line 61
  xfree((void *)name);
#line 62
  xfree((void *)echo_on);
#line 63
  xfree((void *)info);
#line 65
  return (challenge);
}
}
#line 67 "auth-chall.c"
int verify_response(Authctxt *authctxt___0 , char const   *response ) 
{ char *resp[1] ;
  char *name ;
  char *info ;
  char **prompts ;
  u_int i ;
  u_int numprompts ;
  u_int *echo_on ;
  int authenticated ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 72
  authenticated = 0;
#line 74
  if ((unsigned int )device == (unsigned int )((void *)0)) {
#line 75
    return (0);
  }
#line 76
  if ((unsigned int )authctxt___0->kbdintctxt == (unsigned int )((void *)0)) {
#line 77
    return (0);
  }
#line 78
  resp[0] = (char *)response;
#line 79
  tmp = (*(device->respond))(authctxt___0->kbdintctxt, 1U, resp);
#line 79
  switch (tmp) {
  case 0: 
#line 81
  authenticated = 1;
#line 82
  break;
  case 1: 
#line 84
  tmp___0 = (*(device->query))(authctxt___0->kbdintctxt, & name, & info, & numprompts,
                               & prompts, & echo_on);
#line 84
  if (tmp___0 != 0) {
#line 86
    break;
  }
#line 87
  if (numprompts == 0U) {
#line 87
    tmp___1 = (*(device->respond))(authctxt___0->kbdintctxt, 0U, resp);
#line 87
    if (tmp___1 == 0) {
#line 89
      authenticated = 1;
    }
  }
#line 91
  i = 0U;
#line 91
  while (i < numprompts) {
#line 92
    xfree((void *)*(prompts + i));
#line 91
    i ++;
  }
#line 93
  xfree((void *)prompts);
#line 94
  xfree((void *)name);
#line 95
  xfree((void *)echo_on);
#line 96
  xfree((void *)info);
#line 97
  break;
  }
#line 99
  (*(device->free_ctx))(authctxt___0->kbdintctxt);
#line 100
  authctxt___0->kbdintctxt = (void *)0;
#line 101
  return (authenticated);
}
}
#line 103 "auth-chall.c"
void abandon_challenge_response(Authctxt *authctxt___0 ) 
{ 

  {
#line 106
  if ((unsigned int )authctxt___0->kbdintctxt != (unsigned int )((void *)0)) {
#line 107
    (*(device->free_ctx))(authctxt___0->kbdintctxt);
#line 108
    authctxt___0->kbdintctxt = (void *)0;
  }
#line 110
  return;
}
}
#line 1 "auth2-chall.o"
#line 146 "auth.h"
int auth2_challenge(Authctxt *authctxt___0 , char *devs ) ;
#line 37 "auth2-chall.c"
static int auth2_challenge_start(Authctxt *authctxt___0 ) ;
#line 38
static int send_userauth_info_request(Authctxt *authctxt___0 ) ;
#line 39
static void input_userauth_info_response(int type , u_int32_t seq , void *ctxt ) ;
#line 52 "auth2-chall.c"
KbdintDevice *devices[1]  = {      (KbdintDevice *)((void *)0)};
#line 75 "auth2-chall.c"
static KbdintAuthctxt *kbdint_alloc(char const   *devs ) 
{ KbdintAuthctxt *kbdintctxt ;
  Buffer b ;
  int i ;
  void *tmp ;
  u_int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 82
  tmp = xmalloc(sizeof(KbdintAuthctxt ));
#line 82
  kbdintctxt = (KbdintAuthctxt *)tmp;
#line 83
  if (0) {
#line 83
    __s1_len = strlen(devs);
#line 83
    __s2_len = strlen("");
#line 83
    if (! ((unsigned int )((void const   *)(devs + 1)) - (unsigned int )((void const   *)devs) == 1U)) {
      goto _L___0;
    } else {
#line 83
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 83
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 83
          tmp___12 = 1;
        } else {
#line 83
          if (__s2_len >= 4U) {
#line 83
            tmp___12 = 1;
          } else {
#line 83
            tmp___12 = 0;
          }
        }
      } else {
#line 83
        tmp___12 = 0;
      }
    }
#line 83
    if (tmp___12) {
#line 83
      tmp___8 = __builtin_strcmp(devs, "");
    } else {
#line 83
      tmp___11 = __builtin_strcmp(devs, "");
#line 83
      tmp___8 = tmp___11;
    }
  } else {
#line 83
    tmp___11 = __builtin_strcmp(devs, "");
#line 83
    tmp___8 = tmp___11;
  }
#line 83
  if (tmp___8 == 0) {
#line 84
    buffer_init(& b);
#line 85
    i = 0;
#line 85
    while (devices[i]) {
#line 86
      tmp___0 = buffer_len(& b);
#line 86
      if (tmp___0 > 0U) {
#line 87
        buffer_append(& b, (void const   *)",", 1U);
      }
#line 88
      tmp___1 = strlen((devices[i])->name);
#line 88
      buffer_append(& b, (void const   *)(devices[i])->name, tmp___1);
#line 85
      i ++;
    }
#line 91
    buffer_append(& b, (void const   *)"\000", 1U);
#line 92
    tmp___2 = buffer_ptr(& b);
#line 92
    kbdintctxt->devices = xstrdup((char const   *)tmp___2);
#line 93
    buffer_free(& b);
  } else {
#line 95
    kbdintctxt->devices = xstrdup(devs);
  }
#line 97
  debug("kbdint_alloc: devices \'%s\'", kbdintctxt->devices);
#line 98
  kbdintctxt->ctxt = (void *)0;
#line 99
  kbdintctxt->device = (KbdintDevice *)((void *)0);
#line 100
  kbdintctxt->nreq = 0U;
#line 102
  return (kbdintctxt);
}
}
#line 104 "auth2-chall.c"
static void kbdint_reset_device(KbdintAuthctxt *kbdintctxt ) 
{ 

  {
#line 107
  if (kbdintctxt->ctxt) {
#line 108
    (*((kbdintctxt->device)->free_ctx))(kbdintctxt->ctxt);
#line 109
    kbdintctxt->ctxt = (void *)0;
  }
#line 111
  kbdintctxt->device = (KbdintDevice *)((void *)0);
#line 112
  return;
}
}
#line 113 "auth2-chall.c"
static void kbdint_free(KbdintAuthctxt *kbdintctxt ) 
{ 

  {
#line 116
  if (kbdintctxt->device) {
#line 117
    kbdint_reset_device(kbdintctxt);
  }
#line 118
  if (kbdintctxt->devices) {
#line 119
    xfree((void *)kbdintctxt->devices);
#line 120
    kbdintctxt->devices = (char *)((void *)0);
  }
#line 122
  xfree((void *)kbdintctxt);
#line 123
  return;
}
}
#line 125 "auth2-chall.c"
static int kbdint_next_device(KbdintAuthctxt *kbdintctxt ) 
{ size_t len ;
  char *t ;
  int i ;
  unsigned int tmp___64 ;
  int tmp___78 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___84 ;
  int tmp___87 ;
  int tmp___88 ;
  char const   *tmp___92 ;
  int tmp___93 ;

  {
#line 132
  if (kbdintctxt->device) {
#line 133
    kbdint_reset_device(kbdintctxt);
  }
#line 134
  while (1) {
#line 136
    if (kbdintctxt->devices) {
#line 136
      tmp___64 = __builtin_strcspn((char const   *)kbdintctxt->devices, ",");
#line 136
      len = tmp___64;
    } else {
#line 136
      len = 0U;
    }
#line 138
    if (len == 0U) {
#line 139
      break;
    }
#line 140
    i = 0;
#line 140
    while (devices[i]) {
#line 141
      if (0) {
#line 141
        if (0) {
#line 141
          __s1_len___0 = strlen((char const   *)kbdintctxt->devices);
#line 141
          __s2_len___0 = strlen((devices[i])->name);
#line 141
          if (! ((unsigned int )((void const   *)(kbdintctxt->devices + 1)) - (unsigned int )((void const   *)kbdintctxt->devices) == 1U)) {
            goto _L___2;
          } else {
#line 141
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 141
              if (! ((unsigned int )((void const   *)((devices[i])->name + 1)) - (unsigned int )((void const   *)(devices[i])->name) == 1U)) {
#line 141
                tmp___88 = 1;
              } else {
#line 141
                if (__s2_len___0 >= 4U) {
#line 141
                  tmp___88 = 1;
                } else {
#line 141
                  tmp___88 = 0;
                }
              }
            } else {
#line 141
              tmp___88 = 0;
            }
          }
#line 141
          if (tmp___88) {
#line 141
            tmp___84 = __builtin_strcmp((char const   *)kbdintctxt->devices, (devices[i])->name);
          } else {
#line 141
            tmp___87 = __builtin_strcmp((char const   *)kbdintctxt->devices, (devices[i])->name);
#line 141
            tmp___84 = tmp___87;
          }
        } else {
#line 141
          tmp___87 = __builtin_strcmp((char const   *)kbdintctxt->devices, (devices[i])->name);
#line 141
          tmp___84 = tmp___87;
        }
#line 141
        tmp___78 = tmp___84;
      } else {
#line 141
        tmp___78 = strncmp((char const   *)kbdintctxt->devices, (devices[i])->name,
                           len);
      }
#line 141
      if (tmp___78 == 0) {
#line 142
        kbdintctxt->device = devices[i];
      }
#line 140
      i ++;
    }
#line 143
    t = kbdintctxt->devices;
#line 144
    if (*(t + len)) {
#line 144
      kbdintctxt->devices = xstrdup((char const   *)((t + len) + 1));
    } else {
#line 144
      kbdintctxt->devices = (char *)((void *)0);
    }
#line 145
    xfree((void *)t);
#line 146
    if (kbdintctxt->devices) {
#line 146
      tmp___92 = (char const   *)kbdintctxt->devices;
    } else {
#line 146
      tmp___92 = "<empty>";
    }
#line 146
    debug2("kbdint_next_device: devices %s", tmp___92);
#line 134
    if (kbdintctxt->devices) {
#line 134
      if (! (! kbdintctxt->device)) {
#line 134
        break;
      }
    } else {
#line 134
      break;
    }
  }
#line 150
  if (kbdintctxt->device) {
#line 150
    tmp___93 = 1;
  } else {
#line 150
    tmp___93 = 0;
  }
#line 150
  return (tmp___93);
}
}
#line 157 "auth2-chall.c"
int auth2_challenge(Authctxt *authctxt___0 , char *devs ) 
{ char const   *tmp ;
  char const   *tmp___0 ;
  KbdintAuthctxt *tmp___1 ;
  int tmp___2 ;

  {
#line 160
  if (devs) {
#line 160
    tmp = (char const   *)devs;
  } else {
#line 160
    tmp = "<no devs>";
  }
#line 160
  if (authctxt___0->user) {
#line 160
    tmp___0 = (char const   *)authctxt___0->user;
  } else {
#line 160
    tmp___0 = "<nouser>";
  }
#line 160
  debug("auth2_challenge: user=%s devs=%s", tmp___0, tmp);
#line 164
  if ((unsigned int )authctxt___0->user == (unsigned int )((void *)0)) {
#line 165
    return (0);
  } else {
#line 164
    if (! devs) {
#line 165
      return (0);
    }
  }
#line 166
  if ((unsigned int )authctxt___0->kbdintctxt == (unsigned int )((void *)0)) {
#line 167
    tmp___1 = kbdint_alloc((char const   *)devs);
#line 167
    authctxt___0->kbdintctxt = (void *)tmp___1;
  }
#line 168
  tmp___2 = auth2_challenge_start(authctxt___0);
#line 168
  return (tmp___2);
}
}
#line 172 "auth2-chall.c"
void auth2_challenge_stop(Authctxt *authctxt___0 ) 
{ 

  {
#line 176
  dispatch_set(61, (dispatch_fn *)((void *)0));
#line 177
  if ((unsigned int )authctxt___0->kbdintctxt != (unsigned int )((void *)0)) {
#line 178
    kbdint_free((KbdintAuthctxt *)authctxt___0->kbdintctxt);
#line 179
    authctxt___0->kbdintctxt = (void *)0;
  }
#line 181
  return;
}
}
#line 184 "auth2-chall.c"
static int auth2_challenge_start(Authctxt *authctxt___0 ) 
{ KbdintAuthctxt *kbdintctxt ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 187
  kbdintctxt = (KbdintAuthctxt *)authctxt___0->kbdintctxt;
#line 189
  if (kbdintctxt->devices) {
#line 189
    tmp = (char const   *)kbdintctxt->devices;
  } else {
#line 189
    tmp = "<empty>";
  }
#line 189
  debug2("auth2_challenge_start: devices %s", tmp);
#line 192
  tmp___0 = kbdint_next_device(kbdintctxt);
#line 192
  if (tmp___0 == 0) {
#line 193
    auth2_challenge_stop(authctxt___0);
#line 194
    return (0);
  }
#line 196
  debug("auth2_challenge_start: trying authentication method \'%s\'", (kbdintctxt->device)->name);
#line 199
  kbdintctxt->ctxt = (*((kbdintctxt->device)->init_ctx))(authctxt___0);
#line 199
  if ((unsigned int )kbdintctxt->ctxt == (unsigned int )((void *)0)) {
#line 200
    auth2_challenge_stop(authctxt___0);
#line 201
    return (0);
  }
#line 203
  tmp___1 = send_userauth_info_request(authctxt___0);
#line 203
  if (tmp___1 == 0) {
#line 204
    auth2_challenge_stop(authctxt___0);
#line 205
    return (0);
  }
#line 207
  dispatch_set(61, & input_userauth_info_response);
#line 210
  authctxt___0->postponed = 1;
#line 211
  return (0);
}
}
#line 214 "auth2-chall.c"
static int send_userauth_info_request(Authctxt *authctxt___0 ) 
{ KbdintAuthctxt *kbdintctxt ;
  char *name ;
  char *instr ;
  char **prompts ;
  int i ;
  u_int *echo_on ;
  int tmp ;

  {
#line 222
  kbdintctxt = (KbdintAuthctxt *)authctxt___0->kbdintctxt;
#line 223
  tmp = (*((kbdintctxt->device)->query))(kbdintctxt->ctxt, & name, & instr, & kbdintctxt->nreq,
                                         & prompts, & echo_on);
#line 223
  if (tmp) {
#line 225
    return (0);
  }
#line 227
  packet_start((unsigned char)60);
#line 228
  packet_put_cstring((char const   *)name);
#line 229
  packet_put_cstring((char const   *)instr);
#line 230
  packet_put_cstring("");
#line 231
  packet_put_int(kbdintctxt->nreq);
#line 232
  i = 0;
#line 232
  while ((u_int )i < kbdintctxt->nreq) {
#line 233
    packet_put_cstring((char const   *)*(prompts + i));
#line 234
    packet_put_char((int )*(echo_on + i));
#line 232
    i ++;
  }
#line 236
  packet_send();
#line 237
  packet_write_wait();
#line 239
  i = 0;
#line 239
  while ((u_int )i < kbdintctxt->nreq) {
#line 240
    xfree((void *)*(prompts + i));
#line 239
    i ++;
  }
#line 241
  xfree((void *)prompts);
#line 242
  xfree((void *)echo_on);
#line 243
  xfree((void *)name);
#line 244
  xfree((void *)instr);
#line 245
  return (1);
}
}
#line 248 "auth2-chall.c"
static void input_userauth_info_response(int type , u_int32_t seq , void *ctxt ) 
{ Authctxt *authctxt___0 ;
  KbdintAuthctxt *kbdintctxt ;
  int i ;
  int authenticated ;
  int res ;
  int len ;
  u_int nresp ;
  char **response ;
  char *method ;
  void *tmp ;
  void *tmp___0 ;
  int _len ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;

  {
#line 251
  authctxt___0 = (Authctxt *)ctxt;
#line 253
  authenticated = 0;
#line 255
  response = (char **)((void *)0);
#line 257
  if ((unsigned int )authctxt___0 == (unsigned int )((void *)0)) {
#line 258
    fatal("input_userauth_info_response: no authctxt");
  }
#line 259
  kbdintctxt = (KbdintAuthctxt *)authctxt___0->kbdintctxt;
#line 260
  if ((unsigned int )kbdintctxt == (unsigned int )((void *)0)) {
#line 261
    fatal("input_userauth_info_response: no kbdintctxt");
  } else {
#line 260
    if ((unsigned int )kbdintctxt->ctxt == (unsigned int )((void *)0)) {
#line 261
      fatal("input_userauth_info_response: no kbdintctxt");
    }
  }
#line 262
  if ((unsigned int )kbdintctxt->device == (unsigned int )((void *)0)) {
#line 263
    fatal("input_userauth_info_response: no device");
  }
#line 265
  authctxt___0->postponed = 0;
#line 266
  nresp = packet_get_int();
#line 267
  if (nresp != kbdintctxt->nreq) {
#line 268
    fatal("input_userauth_info_response: wrong number of replies");
  }
#line 269
  if (nresp > 100U) {
#line 270
    fatal("input_userauth_info_response: too many replies");
  }
#line 271
  if (nresp > 0U) {
#line 272
    tmp = xmalloc(nresp * sizeof(char *));
#line 272
    response = (char **)tmp;
#line 273
    i = 0;
#line 273
    while ((u_int )i < nresp) {
#line 274
      tmp___0 = packet_get_string((u_int *)((void *)0));
#line 274
      *(response + i) = (char *)tmp___0;
#line 273
      i ++;
    }
  }
#line 276
  while (1) {
#line 276
    tmp___1 = packet_remaining();
#line 276
    _len = tmp___1;
#line 276
    if (_len > 0) {
#line 276
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2-chall.c",
            276);
#line 276
      packet_disconnect("Packet integrity error.");
    }
#line 276
    break;
  }
#line 278
  if (authctxt___0->valid) {
#line 279
    res = (*((kbdintctxt->device)->respond))(kbdintctxt->ctxt, nresp, response);
  } else {
#line 282
    res = -1;
  }
#line 285
  i = 0;
#line 285
  while ((u_int )i < nresp) {
#line 286
    tmp___2 = strlen((char const   *)*(response + i));
#line 286
    memset((void *)*(response + i), 'r', tmp___2);
#line 287
    xfree((void *)*(response + i));
#line 285
    i ++;
  }
#line 289
  if (response) {
#line 290
    xfree((void *)response);
  }
#line 292
  switch (res) {
  case 0: 
#line 295
  authenticated = 1;
#line 296
  break;
  case 1: 
#line 299
  tmp___3 = send_userauth_info_request(authctxt___0);
#line 299
  if (tmp___3 == 1) {
#line 300
    authctxt___0->postponed = 1;
  }
#line 301
  break;
  default: ;
#line 304
  break;
  }
#line 307
  tmp___4 = strlen("keyboard-interactive");
#line 307
  tmp___5 = strlen((kbdintctxt->device)->name);
#line 307
  len = (int )((tmp___4 + 2U) + tmp___5);
#line 309
  tmp___6 = xmalloc((unsigned int )len);
#line 309
  method = (char *)tmp___6;
#line 310
  snprintf((char * __restrict  )method, (unsigned int )len, (char const   * __restrict  )"keyboard-interactive/%s",
           (kbdintctxt->device)->name);
#line 313
  if (! authctxt___0->postponed) {
#line 314
    if (authenticated) {
#line 315
      auth2_challenge_stop(authctxt___0);
    } else {
#line 319
      auth2_challenge_start(authctxt___0);
    }
  }
#line 322
  userauth_finish(authctxt___0, authenticated, method);
#line 323
  xfree((void *)method);
#line 324
  return;
}
}
#line 326 "auth2-chall.c"
void privsep_challenge_enable(void) 
{ 

  {
#line 352
  return;
}
}
#line 1 "groupaccess.o"
#line 103 "/usr/include/grp.h"
extern struct group *getgrgid(__gid_t __gid ) ;
#line 188
extern int getgrouplist(char const   *__user , __gid_t __group , __gid_t *__groups ,
                        int *__ngroups ) ;
#line 564 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long sysconf(int __name )  __attribute__((__const__)) ;
#line 33 "groupaccess.c"
static int ngroups  ;
#line 34 "groupaccess.c"
static char **groups_byname  ;
#line 40 "groupaccess.c"
int ga_init(char const   *user , gid_t base ) 
{ gid_t *groups_bygid ;
  int i ;
  int j ;
  struct group *gr ;
  long tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 47
  if (ngroups > 0) {
#line 48
    ga_free();
  }
#line 50
  ngroups = 65536;
#line 52
  tmp___2 = sysconf(3);
#line 52
  if (65536L > tmp___2) {
#line 52
    ngroups = 65536;
  } else {
#line 52
    tmp___1 = sysconf(3);
#line 52
    ngroups = (int )tmp___1;
  }
#line 55
  tmp___3 = xmalloc((unsigned int )ngroups * sizeof(*groups_bygid));
#line 55
  groups_bygid = (gid_t *)tmp___3;
#line 56
  tmp___4 = xmalloc((unsigned int )ngroups * sizeof(*groups_byname));
#line 56
  groups_byname = (char **)tmp___4;
#line 58
  tmp___5 = getgrouplist(user, base, groups_bygid, & ngroups);
#line 58
  if (tmp___5 == -1) {
#line 59
    logit("getgrouplist: groups list too small");
  }
#line 60
  i = 0;
#line 60
  j = 0;
#line 60
  while (i < ngroups) {
#line 61
    gr = getgrgid(*(groups_bygid + i));
#line 61
    if ((unsigned int )gr != (unsigned int )((void *)0)) {
#line 62
      tmp___6 = j;
#line 62
      j ++;
#line 62
      *(groups_byname + tmp___6) = xstrdup((char const   *)gr->gr_name);
    }
#line 60
    i ++;
  }
#line 63
  xfree((void *)groups_bygid);
#line 64
  ngroups = j;
#line 64
  return (ngroups);
}
}
#line 71 "groupaccess.c"
int ga_match(char * const  *groups , int n___0 ) 
{ int i ;
  int j ;
  int tmp ;

  {
#line 76
  i = 0;
#line 76
  while (i < ngroups) {
#line 77
    j = 0;
#line 77
    while (j < n___0) {
#line 78
      tmp = match_pattern((char const   *)*(groups_byname + i), (char const   *)*(groups + j));
#line 78
      if (tmp) {
#line 79
        return (1);
      }
#line 77
      j ++;
    }
#line 76
    i ++;
  }
#line 80
  return (0);
}
}
#line 86 "groupaccess.c"
void ga_free(void) 
{ int i ;

  {
#line 91
  if (ngroups > 0) {
#line 92
    i = 0;
#line 92
    while (i < ngroups) {
#line 93
      xfree((void *)*(groups_byname + i));
#line 92
      i ++;
    }
#line 94
    ngroups = 0;
#line 95
    xfree((void *)groups_byname);
  }
#line 97
  return;
}
}
#line 1 "auth-skey.o"
#line 1 "auth-bsdauth.o"
#line 1 "auth2-hostbased.o"
#line 116 "auth.h"
int hostbased_key_allowed(struct passwd *pw , char const   *cuser , char *chost ,
                          Key *key ) ;
#line 52 "monitor_wrap.h"
int mm_hostbased_key_allowed(struct passwd *pw , char *user , char *host , Key *key ) ;
#line 54
int mm_key_verify(Key *key , u_char *sig , u_int siglen , u_char *data , u_int datalen ) ;
#line 47 "auth2-hostbased.c"
static int userauth_hostbased(Authctxt *authctxt___0 ) 
{ Buffer b ;
  Key *key ;
  char *pkalg ;
  char *cuser ;
  char *chost ;
  char *service ;
  u_char *pkblob ;
  u_char *sig ;
  u_int alen ;
  u_int blen ;
  u_int slen ;
  int pktype ;
  int authenticated ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___6 ;
  int tmp___13 ;
  u_int tmp___14 ;
  void *tmp___15 ;
  u_int tmp___16 ;
  void *tmp___17 ;

  {
#line 51
  key = (Key *)((void *)0);
#line 56
  authenticated = 0;
#line 58
  if (! authctxt___0->valid) {
#line 59
    debug2("userauth_hostbased: disabled because of invalid user");
#line 60
    return (0);
  }
#line 62
  tmp = packet_get_string(& alen);
#line 62
  pkalg = (char *)tmp;
#line 63
  tmp___0 = packet_get_string(& blen);
#line 63
  pkblob = (u_char *)tmp___0;
#line 64
  tmp___1 = packet_get_string((u_int *)((void *)0));
#line 64
  chost = (char *)tmp___1;
#line 65
  tmp___2 = packet_get_string((u_int *)((void *)0));
#line 65
  cuser = (char *)tmp___2;
#line 66
  tmp___3 = packet_get_string(& slen);
#line 66
  sig = (u_char *)tmp___3;
#line 68
  debug("userauth_hostbased: cuser %s chost %s pkalg %s slen %d", cuser, chost, pkalg,
        slen);
#line 77
  pktype = key_type_from_name(pkalg);
#line 78
  if (pktype == 3) {
#line 80
    logit("userauth_hostbased: unsupported public key algorithm: %s", pkalg);
    goto done;
  }
#line 84
  key = key_from_blob((u_char const   *)pkblob, blen);
#line 85
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 86
    error("userauth_hostbased: cannot decode key: %s", pkalg);
    goto done;
  }
#line 89
  if (key->type != pktype) {
#line 90
    error("userauth_hostbased: type mismatch for decoded key (received %d, expected %d)",
          key->type, pktype);
    goto done;
  }
#line 94
  if (datafellows & 65536) {
#line 94
    service = (char *)"ssh-userauth";
  } else {
#line 94
    service = authctxt___0->service;
  }
#line 96
  buffer_init(& b);
#line 97
  buffer_put_string(& b, (void const   *)session_id2, session_id2_len);
#line 99
  buffer_put_char(& b, 50);
#line 100
  buffer_put_cstring(& b, (char const   *)authctxt___0->user);
#line 101
  buffer_put_cstring(& b, (char const   *)service);
#line 102
  buffer_put_cstring(& b, "hostbased");
#line 103
  buffer_put_string(& b, (void const   *)pkalg, alen);
#line 104
  buffer_put_string(& b, (void const   *)pkblob, blen);
#line 105
  buffer_put_cstring(& b, (char const   *)chost);
#line 106
  buffer_put_cstring(& b, (char const   *)cuser);
#line 111
  authenticated = 0;
#line 112
  if (use_privsep) {
#line 112
    tmp___6 = mm_hostbased_key_allowed(authctxt___0->pw, cuser, chost, key);
  } else {
#line 112
    tmp___6 = hostbased_key_allowed(authctxt___0->pw, (char const   *)cuser, chost,
                                    key);
  }
#line 112
  if (tmp___6) {
#line 112
    if (use_privsep) {
#line 112
      tmp___14 = buffer_len(& b);
#line 112
      tmp___15 = buffer_ptr(& b);
#line 112
      tmp___13 = mm_key_verify(key, sig, slen, (u_char *)tmp___15, tmp___14);
    } else {
#line 112
      tmp___16 = buffer_len(& b);
#line 112
      tmp___17 = buffer_ptr(& b);
#line 112
      tmp___13 = key_verify((Key const   *)key, (u_char const   *)sig, slen, (u_char const   *)tmp___17,
                            tmp___16);
    }
#line 112
    if (tmp___13 == 1) {
#line 115
      authenticated = 1;
    }
  }
#line 117
  buffer_free(& b);
  done: 
#line 119
  debug2("userauth_hostbased: authenticated %d", authenticated);
#line 120
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 121
    key_free(key);
  }
#line 122
  xfree((void *)pkalg);
#line 123
  xfree((void *)pkblob);
#line 124
  xfree((void *)cuser);
#line 125
  xfree((void *)chost);
#line 126
  xfree((void *)sig);
#line 127
  return (authenticated);
}
}
#line 131 "auth2-hostbased.c"
int hostbased_key_allowed(struct passwd *pw , char const   *cuser , char *chost ,
                          Key *key ) 
{ char const   *resolvedname ;
  char const   *ipaddr ;
  char const   *lookup ;
  HostStatus host_status ;
  int len ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
#line 139
  resolvedname = get_canonical_hostname(options.use_dns);
#line 140
  ipaddr = get_remote_ipaddr();
#line 142
  debug2("userauth_hostbased: chost %s resolvedname %s ipaddr %s", chost, resolvedname,
         ipaddr);
#line 145
  if (options.hostbased_uses_name_from_packet_only) {
#line 146
    tmp = auth_rhosts2(pw, cuser, (char const   *)chost, (char const   *)chost);
#line 146
    if (tmp == 0) {
#line 147
      return (0);
    }
#line 148
    lookup = (char const   *)chost;
  } else {
#line 150
    tmp___0 = strlen((char const   *)chost);
#line 150
    len = (int )tmp___0;
#line 150
    if (len > 0) {
#line 150
      if ((int )*(chost + (len - 1)) == 46) {
#line 151
        debug2("stripping trailing dot from chost %s", chost);
#line 152
        *(chost + (len - 1)) = (char )'\000';
      }
    }
#line 154
    tmp___1 = strcasecmp(resolvedname, (char const   *)chost);
#line 154
    if (tmp___1 != 0) {
#line 155
      logit("userauth_hostbased mismatch: client sends %s, but we resolve %s to %s",
            chost, ipaddr, resolvedname);
    }
#line 158
    tmp___2 = auth_rhosts2(pw, cuser, resolvedname, ipaddr);
#line 158
    if (tmp___2 == 0) {
#line 159
      return (0);
    }
#line 160
    lookup = resolvedname;
  }
#line 162
  debug2("userauth_hostbased: access allowed by auth_rhosts2");
#line 164
  if (options.ignore_user_known_hosts) {
#line 164
    tmp___3 = (char const   *)((void *)0);
  } else {
#line 164
    tmp___3 = "~/.ssh/known_hosts";
  }
#line 164
  host_status = check_key_in_hostfiles(pw, key, lookup, "/usr/local/etc/ssh_known_hosts",
                                       tmp___3);
#line 169
  if ((int )host_status == 1) {
#line 170
    if (options.ignore_user_known_hosts) {
#line 170
      tmp___4 = (char const   *)((void *)0);
    } else {
#line 170
      tmp___4 = "~/.ssh/known_hosts2";
    }
#line 170
    host_status = check_key_in_hostfiles(pw, key, lookup, "/usr/local/etc/ssh_known_hosts2",
                                         tmp___4);
  }
#line 175
  return ((int )host_status == 0);
}
}
#line 178 "auth2-hostbased.c"
Authmethod method_hostbased  =    {(char *)"hostbased", & userauth_hostbased, & options.hostbased_authentication};
#line 1 "auth2-kbdint.o"
#line 37 "auth2-kbdint.c"
static int userauth_kbdint(Authctxt *authctxt___0 ) 
{ int authenticated ;
  char *lang ;
  char *devs ;
  void *tmp ;
  void *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 40
  authenticated = 0;
#line 43
  tmp = packet_get_string((u_int *)((void *)0));
#line 43
  lang = (char *)tmp;
#line 44
  tmp___0 = packet_get_string((u_int *)((void *)0));
#line 44
  devs = (char *)tmp___0;
#line 45
  while (1) {
#line 45
    tmp___1 = packet_remaining();
#line 45
    _len = tmp___1;
#line 45
    if (_len > 0) {
#line 45
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2-kbdint.c",
            45);
#line 45
      packet_disconnect("Packet integrity error.");
    }
#line 45
    break;
  }
#line 47
  debug("keyboard-interactive devs %s", devs);
#line 49
  if (options.challenge_response_authentication) {
#line 50
    authenticated = auth2_challenge(authctxt___0, devs);
  }
#line 52
  xfree((void *)devs);
#line 53
  xfree((void *)lang);
#line 58
  return (authenticated);
}
}
#line 61 "auth2-kbdint.c"
Authmethod method_kbdint  =    {(char *)"keyboard-interactive", & userauth_kbdint, & options.kbd_interactive_authentication};
#line 1 "auth2-none.o"
#line 218 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64") __attribute__((__nonnull__(2))) ;
#line 142 "auth.h"
char *auth2_read_banner(void) ;
#line 48 "monitor_wrap.h"
char *mm_auth2_read_banner(void) ;
#line 42 "auth2-none.c"
static int none_enabled  =    1;
#line 44 "auth2-none.c"
char *auth2_read_banner(void) 
{ struct stat st ;
  char *banner ;
  off_t len ;
  off_t n___0 ;
  int fd ;
  int tmp ;
  void *tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 48
  banner = (char *)((void *)0);
#line 52
  fd = open((char const   *)options.banner, 0);
#line 52
  if (fd == -1) {
#line 53
    return ((char *)((void *)0));
  }
#line 54
  tmp = fstat(fd, & st);
#line 54
  if (tmp == -1) {
#line 55
    close(fd);
#line 56
    return ((char *)((void *)0));
  }
#line 58
  len = st.st_size;
#line 59
  tmp___0 = xmalloc((unsigned int )(len + 1LL));
#line 59
  banner = (char *)tmp___0;
#line 60
  tmp___1 = atomicio(& read, fd, (void *)banner, (unsigned int )len);
#line 60
  n___0 = (long long )tmp___1;
#line 61
  close(fd);
#line 63
  if (n___0 != len) {
#line 64
    xfree((void *)banner);
#line 65
    return ((char *)((void *)0));
  }
#line 67
  *(banner + n___0) = (char )'\000';
#line 69
  return (banner);
}
}
#line 72 "auth2-none.c"
static void userauth_banner(void) 
{ char *banner ;

  {
#line 75
  banner = (char *)((void *)0);
#line 77
  if ((unsigned int )options.banner == (unsigned int )((void *)0)) {
#line 78
    return;
  } else {
#line 77
    if (datafellows & 128) {
#line 78
      return;
    }
  }
#line 80
  if (use_privsep) {
#line 80
    banner = mm_auth2_read_banner();
  } else {
#line 80
    banner = auth2_read_banner();
  }
#line 80
  if ((unsigned int )banner == (unsigned int )((void *)0)) {
    goto done;
  }
#line 83
  packet_start((unsigned char)53);
#line 84
  packet_put_cstring((char const   *)banner);
#line 85
  packet_put_cstring("");
#line 86
  packet_send();
#line 87
  debug("userauth_banner: sent");
  done: 
#line 89
  if (banner) {
#line 90
    xfree((void *)banner);
  }
#line 91
  return;
}
}
#line 93 "auth2-none.c"
static int userauth_none(Authctxt *authctxt___0 ) 
{ int _len ;
  int tmp ;
  int tmp___2 ;

  {
#line 96
  none_enabled = 0;
#line 97
  while (1) {
#line 97
    tmp = packet_remaining();
#line 97
    _len = tmp;
#line 97
    if (_len > 0) {
#line 97
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2-none.c",
            97);
#line 97
      packet_disconnect("Packet integrity error.");
    }
#line 97
    break;
  }
#line 98
  userauth_banner();
#line 103
  if (options.password_authentication) {
#line 104
    if (use_privsep) {
#line 104
      tmp___2 = mm_auth_password(authctxt___0, (char *)"");
    } else {
#line 104
      tmp___2 = auth_password(authctxt___0, "");
    }
#line 104
    return (tmp___2);
  }
#line 105
  return (0);
}
}
#line 108 "auth2-none.c"
Authmethod method_none  =    {(char *)"none", & userauth_none, & none_enabled};
#line 1 "auth2-passwd.o"
#line 38 "auth2-passwd.c"
static int userauth_passwd(Authctxt *authctxt___0 ) 
{ char *password ;
  char *newpass ;
  int authenticated ;
  int change ;
  u_int len ;
  u_int newlen ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int _len ;
  int tmp___2 ;
  int tmp___5 ;

  {
#line 42
  authenticated = 0;
#line 46
  tmp = packet_get_char();
#line 46
  change = (int )tmp;
#line 47
  tmp___0 = packet_get_string(& len);
#line 47
  password = (char *)tmp___0;
#line 48
  if (change) {
#line 50
    tmp___1 = packet_get_string(& newlen);
#line 50
    newpass = (char *)tmp___1;
#line 51
    memset((void *)newpass, 0, newlen);
#line 52
    xfree((void *)newpass);
  }
#line 54
  while (1) {
#line 54
    tmp___2 = packet_remaining();
#line 54
    _len = tmp___2;
#line 54
    if (_len > 0) {
#line 54
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2-passwd.c",
            54);
#line 54
      packet_disconnect("Packet integrity error.");
    }
#line 54
    break;
  }
#line 56
  if (change) {
#line 57
    logit("password change not supported");
  } else {
#line 58
    if (use_privsep) {
#line 58
      tmp___5 = mm_auth_password(authctxt___0, password);
    } else {
#line 58
      tmp___5 = auth_password(authctxt___0, (char const   *)password);
    }
#line 58
    if (tmp___5 == 1) {
#line 63
      authenticated = 1;
    }
  }
#line 64
  memset((void *)password, 0, len);
#line 65
  xfree((void *)password);
#line 66
  return (authenticated);
}
}
#line 69 "auth2-passwd.c"
Authmethod method_passwd  =    {(char *)"password", & userauth_passwd, & options.password_authentication};
#line 1 "auth2-pubkey.o"
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 117 "auth.h"
int user_key_allowed(struct passwd *pw , Key *key ) ;
#line 51 "monitor_wrap.h"
int mm_user_key_allowed(struct passwd *pw , Key *key ) ;
#line 49 "auth2-pubkey.c"
static int userauth_pubkey(Authctxt *authctxt___0 ) 
{ Buffer b ;
  Key *key ;
  char *pkalg ;
  u_char *pkblob ;
  u_char *sig ;
  u_int alen ;
  u_int blen ;
  u_int slen ;
  int have_sig ;
  int pktype ;
  int authenticated ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int _len ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int tmp___9 ;
  int tmp___16 ;
  u_int tmp___17 ;
  void *tmp___18 ;
  u_int tmp___19 ;
  void *tmp___20 ;
  int _len___0 ;
  int tmp___21 ;
  int tmp___24 ;

  {
#line 53
  key = (Key *)((void *)0);
#line 58
  authenticated = 0;
#line 60
  if (! authctxt___0->valid) {
#line 61
    debug2("userauth_pubkey: disabled because of invalid user");
#line 62
    return (0);
  }
#line 64
  tmp = packet_get_char();
#line 64
  have_sig = (int )tmp;
#line 65
  if (datafellows & 32) {
#line 66
    debug2("userauth_pubkey: SSH_BUG_PKAUTH");
#line 68
    tmp___0 = packet_get_string(& blen);
#line 68
    pkblob = (u_char *)tmp___0;
#line 69
    buffer_init(& b);
#line 70
    buffer_append(& b, (void const   *)pkblob, blen);
#line 72
    tmp___1 = buffer_get_string(& b, & alen);
#line 72
    pkalg = (char *)tmp___1;
#line 73
    buffer_free(& b);
  } else {
#line 75
    tmp___2 = packet_get_string(& alen);
#line 75
    pkalg = (char *)tmp___2;
#line 76
    tmp___3 = packet_get_string(& blen);
#line 76
    pkblob = (u_char *)tmp___3;
  }
#line 78
  pktype = key_type_from_name(pkalg);
#line 79
  if (pktype == 3) {
#line 81
    logit("userauth_pubkey: unsupported public key algorithm: %s", pkalg);
    goto done;
  }
#line 85
  key = key_from_blob((u_char const   *)pkblob, blen);
#line 86
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 87
    error("userauth_pubkey: cannot decode key: %s", pkalg);
    goto done;
  }
#line 90
  if (key->type != pktype) {
#line 91
    error("userauth_pubkey: type mismatch for decoded key (received %d, expected %d)",
          key->type, pktype);
    goto done;
  }
#line 95
  if (have_sig) {
#line 96
    tmp___4 = packet_get_string(& slen);
#line 96
    sig = (u_char *)tmp___4;
#line 97
    while (1) {
#line 97
      tmp___5 = packet_remaining();
#line 97
      _len = tmp___5;
#line 97
      if (_len > 0) {
#line 97
        logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2-pubkey.c",
              97);
#line 97
        packet_disconnect("Packet integrity error.");
      }
#line 97
      break;
    }
#line 98
    buffer_init(& b);
#line 99
    if (datafellows & 16) {
#line 100
      buffer_append(& b, (void const   *)session_id2, session_id2_len);
    } else {
#line 102
      buffer_put_string(& b, (void const   *)session_id2, session_id2_len);
    }
#line 105
    buffer_put_char(& b, 50);
#line 106
    buffer_put_cstring(& b, (char const   *)authctxt___0->user);
#line 107
    if (datafellows & 2) {
#line 107
      tmp___6 = "ssh-userauth";
    } else {
#line 107
      tmp___6 = (char const   *)authctxt___0->service;
    }
#line 107
    buffer_put_cstring(& b, tmp___6);
#line 111
    if (datafellows & 32) {
#line 112
      buffer_put_char(& b, have_sig);
    } else {
#line 114
      buffer_put_cstring(& b, "publickey");
#line 115
      buffer_put_char(& b, have_sig);
#line 116
      buffer_put_cstring(& b, (char const   *)pkalg);
    }
#line 118
    buffer_put_string(& b, (void const   *)pkblob, blen);
#line 123
    authenticated = 0;
#line 124
    if (use_privsep) {
#line 124
      tmp___9 = mm_user_key_allowed(authctxt___0->pw, key);
    } else {
#line 124
      tmp___9 = user_key_allowed(authctxt___0->pw, key);
    }
#line 124
    if (tmp___9) {
#line 124
      if (use_privsep) {
#line 124
        tmp___17 = buffer_len(& b);
#line 124
        tmp___18 = buffer_ptr(& b);
#line 124
        tmp___16 = mm_key_verify(key, sig, slen, (u_char *)tmp___18, tmp___17);
      } else {
#line 124
        tmp___19 = buffer_len(& b);
#line 124
        tmp___20 = buffer_ptr(& b);
#line 124
        tmp___16 = key_verify((Key const   *)key, (u_char const   *)sig, slen, (u_char const   *)tmp___20,
                              tmp___19);
      }
#line 124
      if (tmp___16 == 1) {
#line 127
        authenticated = 1;
      }
    }
#line 128
    buffer_free(& b);
#line 129
    xfree((void *)sig);
  } else {
#line 131
    debug("test whether pkalg/pkblob are acceptable");
#line 132
    while (1) {
#line 132
      tmp___21 = packet_remaining();
#line 132
      _len___0 = tmp___21;
#line 132
      if (_len___0 > 0) {
#line 132
        logit("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "auth2-pubkey.c",
              132);
#line 132
        packet_disconnect("Packet integrity error.");
      }
#line 132
      break;
    }
#line 142
    if (use_privsep) {
#line 142
      tmp___24 = mm_user_key_allowed(authctxt___0->pw, key);
    } else {
#line 142
      tmp___24 = user_key_allowed(authctxt___0->pw, key);
    }
#line 142
    if (tmp___24) {
#line 143
      packet_start((unsigned char)60);
#line 144
      packet_put_string((void const   *)pkalg, alen);
#line 145
      packet_put_string((void const   *)pkblob, blen);
#line 146
      packet_send();
#line 147
      packet_write_wait();
#line 148
      authctxt___0->postponed = 1;
    }
  }
#line 151
  if (authenticated != 1) {
#line 152
    auth_clear_options();
  }
  done: 
#line 154
  debug2("userauth_pubkey: authenticated %d pkalg %s", authenticated, pkalg);
#line 155
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 156
    key_free(key);
  }
#line 157
  xfree((void *)pkalg);
#line 158
  xfree((void *)pkblob);
#line 163
  return (authenticated);
}
}
#line 167 "auth2-pubkey.c"
static int user_key_allowed2(struct passwd *pw , Key *key , char *file___0 ) 
{ char line[8192] ;
  int found_key ;
  FILE *f ;
  u_long linenum ;
  struct stat st ;
  Key *found ;
  char *fp ;
  int tmp ;
  int tmp___0 ;
  char *cp ;
  char *options___0 ;
  int quoted ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
#line 171
  found_key = 0;
#line 173
  linenum = (u_long )0;
#line 179
  temporarily_use_uid(pw);
#line 181
  debug("trying public key file %s", file___0);
#line 184
  tmp = stat((char const   * __restrict  )file___0, (struct stat * __restrict  )(& st));
#line 184
  if (tmp < 0) {
#line 186
    restore_uid();
#line 187
    return (0);
  }
#line 190
  f = fopen((char const   * __restrict  )file___0, (char const   * __restrict  )"r");
#line 191
  if (! f) {
#line 193
    restore_uid();
#line 194
    return (0);
  }
#line 196
  if (options.strict_modes) {
#line 196
    tmp___0 = secure_filename(f, (char const   *)file___0, pw, line, sizeof(line));
#line 196
    if (tmp___0 != 0) {
#line 198
      fclose(f);
#line 199
      logit("Authentication refused: %s", line);
#line 200
      restore_uid();
#line 201
      return (0);
    }
  }
#line 204
  found_key = 0;
#line 205
  found = key_new(key->type);
#line 207
  while (1) {
#line 207
    tmp___6 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 207
    if (! tmp___6) {
#line 207
      break;
    }
#line 208
    options___0 = (char *)((void *)0);
#line 209
    linenum ++;
#line 211
    cp = line;
#line 211
    while (1) {
#line 211
      if (! ((int )*cp == 32)) {
#line 211
        if (! ((int )*cp == 9)) {
#line 211
          break;
        }
      }
#line 211
      cp ++;
    }
#line 213
    if (! *cp) {
#line 214
      continue;
    } else {
#line 213
      if ((int )*cp == 10) {
#line 214
        continue;
      } else {
#line 213
        if ((int )*cp == 35) {
#line 214
          continue;
        }
      }
    }
#line 216
    tmp___2 = key_read(found, & cp);
#line 216
    if (tmp___2 != 1) {
#line 218
      quoted = 0;
#line 219
      debug2("user_key_allowed: check options: \'%s\'", cp);
#line 220
      options___0 = cp;
#line 221
      while (1) {
#line 221
        if (*cp) {
#line 221
          if (! quoted) {
#line 221
            if ((int )*cp != 32) {
#line 221
              if (! ((int )*cp != 9)) {
#line 221
                break;
              }
            } else {
#line 221
              break;
            }
          }
        } else {
#line 221
          break;
        }
#line 222
        if ((int )*cp == 92) {
#line 222
          if ((int )*(cp + 1) == 34) {
#line 223
            cp ++;
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 224
          if ((int )*cp == 34) {
#line 225
            quoted = ! quoted;
          }
        }
#line 221
        cp ++;
      }
#line 228
      while (1) {
#line 228
        if (! ((int )*cp == 32)) {
#line 228
          if (! ((int )*cp == 9)) {
#line 228
            break;
          }
        }
#line 228
        cp ++;
      }
#line 230
      tmp___1 = key_read(found, & cp);
#line 230
      if (tmp___1 != 1) {
#line 231
        debug2("user_key_allowed: advance: \'%s\'", cp);
#line 233
        continue;
      }
    }
#line 236
    tmp___4 = key_equal((Key const   *)found, (Key const   *)key);
#line 236
    if (tmp___4) {
#line 236
      tmp___5 = auth_parse_options(pw, options___0, file___0, linenum);
#line 236
      if (tmp___5 == 1) {
#line 238
        found_key = 1;
#line 239
        debug("matching key found: file %s, line %lu", file___0, linenum);
#line 241
        fp = key_fingerprint((Key const   *)found, 1, 0);
#line 242
        tmp___3 = key_type((Key const   *)found);
#line 242
        verbose("Found matching %s key: %s", tmp___3, fp);
#line 244
        xfree((void *)fp);
#line 245
        break;
      }
    }
  }
#line 248
  restore_uid();
#line 249
  fclose(f);
#line 250
  key_free(found);
#line 251
  if (! found_key) {
#line 252
    debug2("key not found");
  }
#line 253
  return (found_key);
}
}
#line 257 "auth2-pubkey.c"
int user_key_allowed(struct passwd *pw , Key *key ) 
{ int success ;
  char *file___0 ;

  {
#line 263
  file___0 = authorized_keys_file(pw);
#line 264
  success = user_key_allowed2(pw, key, file___0);
#line 265
  xfree((void *)file___0);
#line 266
  if (success) {
#line 267
    return (success);
  }
#line 270
  file___0 = authorized_keys_file2(pw);
#line 271
  success = user_key_allowed2(pw, key, file___0);
#line 272
  xfree((void *)file___0);
#line 273
  return (success);
}
}
#line 276 "auth2-pubkey.c"
Authmethod method_pubkey  =    {(char *)"publickey", & userauth_pubkey, & options.pubkey_authentication};
#line 1 "monitor_mm.o"
#line 77 "/usr/include/sys/mman.h"
extern  __attribute__((__nothrow__)) int munmap(void *__addr , size_t __len ) ;
#line 50 "monitor_mm.h"
void mmtree_RB_INSERT_COLOR(struct mmtree *head , struct mm_share *elm ) ;
#line 50
void mmtree_RB_REMOVE_COLOR(struct mmtree *head , struct mm_share *parent , struct mm_share *elm ) ;
#line 50
struct mm_share *mmtree_RB_REMOVE(struct mmtree *head , struct mm_share *elm ) ;
#line 50
struct mm_share *mmtree_RB_INSERT(struct mmtree *head , struct mm_share *elm ) ;
#line 50
struct mm_share *mmtree_RB_FIND(struct mmtree *head , struct mm_share *elm ) ;
#line 50
struct mm_share *mmtree_RB_NEXT(struct mmtree *head , struct mm_share *elm ) ;
#line 50
struct mm_share *mmtree_RB_MINMAX(struct mmtree *head , int val ) ;
#line 56
struct mm_master *mm_create(struct mm_master *mmalloc , size_t size ) ;
#line 57
void mm_destroy(struct mm_master *mm ) ;
#line 59
void mm_share_sync(struct mm_master **pmm , struct mm_master **pmmalloc ) ;
#line 61
void *mm_malloc(struct mm_master *mm , size_t size ) ;
#line 62
void *mm_xmalloc(struct mm_master *mm , size_t size ) ;
#line 63
void mm_free(struct mm_master *mm , void *address ) ;
#line 65
void mm_memvalid(struct mm_master *mm , void *address , size_t size ) ;
#line 38 "monitor_mm.c"
static int mm_compare(struct mm_share *a , struct mm_share *b ) 
{ long diff ;

  {
#line 41
  diff = (long )((char *)a->address - (char *)b->address);
#line 43
  if (diff == 0L) {
#line 44
    return (0);
  } else {
#line 45
    if (diff < 0L) {
#line 46
      return (-1);
    } else {
#line 48
      return (1);
    }
  }
}
}
#line 51 "monitor_mm.c"
void mmtree_RB_INSERT_COLOR(struct mmtree *head , struct mm_share *elm ) 
{ struct mm_share *parent ;
  struct mm_share *gparent ;
  struct mm_share *tmp ;

  {
#line 51
  while (1) {
#line 51
    parent = elm->next.rbe_parent;
#line 51
    if (parent) {
#line 51
      if (! (parent->next.rbe_color == 1)) {
#line 51
        break;
      }
    } else {
#line 51
      break;
    }
#line 51
    gparent = parent->next.rbe_parent;
#line 51
    if ((unsigned int )parent == (unsigned int )gparent->next.rbe_left) {
#line 51
      tmp = gparent->next.rbe_right;
#line 51
      if (tmp) {
#line 51
        if (tmp->next.rbe_color == 1) {
#line 51
          tmp->next.rbe_color = 0;
#line 51
          while (1) {
#line 51
            parent->next.rbe_color = 0;
#line 51
            gparent->next.rbe_color = 1;
#line 51
            break;
          }
#line 51
          elm = gparent;
#line 51
          continue;
        }
      }
#line 51
      if ((unsigned int )parent->next.rbe_right == (unsigned int )elm) {
#line 51
        while (1) {
#line 51
          tmp = parent->next.rbe_right;
#line 51
          parent->next.rbe_right = tmp->next.rbe_left;
#line 51
          if (parent->next.rbe_right) {
#line 51
            (tmp->next.rbe_left)->next.rbe_parent = parent;
          }
#line 51
          tmp->next.rbe_parent = parent->next.rbe_parent;
#line 51
          if (tmp->next.rbe_parent) {
#line 51
            if ((unsigned int )parent == (unsigned int )(parent->next.rbe_parent)->next.rbe_left) {
#line 51
              (parent->next.rbe_parent)->next.rbe_left = tmp;
            } else {
#line 51
              (parent->next.rbe_parent)->next.rbe_right = tmp;
            }
          } else {
#line 51
            head->rbh_root = tmp;
          }
#line 51
          tmp->next.rbe_left = parent;
#line 51
          parent->next.rbe_parent = tmp;
#line 51
          if (tmp->next.rbe_parent) {

          }
#line 51
          break;
        }
#line 51
        tmp = parent;
#line 51
        parent = elm;
#line 51
        elm = tmp;
      }
#line 51
      while (1) {
#line 51
        parent->next.rbe_color = 0;
#line 51
        gparent->next.rbe_color = 1;
#line 51
        break;
      }
#line 51
      while (1) {
#line 51
        tmp = gparent->next.rbe_left;
#line 51
        gparent->next.rbe_left = tmp->next.rbe_right;
#line 51
        if (gparent->next.rbe_left) {
#line 51
          (tmp->next.rbe_right)->next.rbe_parent = gparent;
        }
#line 51
        tmp->next.rbe_parent = gparent->next.rbe_parent;
#line 51
        if (tmp->next.rbe_parent) {
#line 51
          if ((unsigned int )gparent == (unsigned int )(gparent->next.rbe_parent)->next.rbe_left) {
#line 51
            (gparent->next.rbe_parent)->next.rbe_left = tmp;
          } else {
#line 51
            (gparent->next.rbe_parent)->next.rbe_right = tmp;
          }
        } else {
#line 51
          head->rbh_root = tmp;
        }
#line 51
        tmp->next.rbe_right = gparent;
#line 51
        gparent->next.rbe_parent = tmp;
#line 51
        if (tmp->next.rbe_parent) {

        }
#line 51
        break;
      }
    } else {
#line 51
      tmp = gparent->next.rbe_left;
#line 51
      if (tmp) {
#line 51
        if (tmp->next.rbe_color == 1) {
#line 51
          tmp->next.rbe_color = 0;
#line 51
          while (1) {
#line 51
            parent->next.rbe_color = 0;
#line 51
            gparent->next.rbe_color = 1;
#line 51
            break;
          }
#line 51
          elm = gparent;
#line 51
          continue;
        }
      }
#line 51
      if ((unsigned int )parent->next.rbe_left == (unsigned int )elm) {
#line 51
        while (1) {
#line 51
          tmp = parent->next.rbe_left;
#line 51
          parent->next.rbe_left = tmp->next.rbe_right;
#line 51
          if (parent->next.rbe_left) {
#line 51
            (tmp->next.rbe_right)->next.rbe_parent = parent;
          }
#line 51
          tmp->next.rbe_parent = parent->next.rbe_parent;
#line 51
          if (tmp->next.rbe_parent) {
#line 51
            if ((unsigned int )parent == (unsigned int )(parent->next.rbe_parent)->next.rbe_left) {
#line 51
              (parent->next.rbe_parent)->next.rbe_left = tmp;
            } else {
#line 51
              (parent->next.rbe_parent)->next.rbe_right = tmp;
            }
          } else {
#line 51
            head->rbh_root = tmp;
          }
#line 51
          tmp->next.rbe_right = parent;
#line 51
          parent->next.rbe_parent = tmp;
#line 51
          if (tmp->next.rbe_parent) {

          }
#line 51
          break;
        }
#line 51
        tmp = parent;
#line 51
        parent = elm;
#line 51
        elm = tmp;
      }
#line 51
      while (1) {
#line 51
        parent->next.rbe_color = 0;
#line 51
        gparent->next.rbe_color = 1;
#line 51
        break;
      }
#line 51
      while (1) {
#line 51
        tmp = gparent->next.rbe_right;
#line 51
        gparent->next.rbe_right = tmp->next.rbe_left;
#line 51
        if (gparent->next.rbe_right) {
#line 51
          (tmp->next.rbe_left)->next.rbe_parent = gparent;
        }
#line 51
        tmp->next.rbe_parent = gparent->next.rbe_parent;
#line 51
        if (tmp->next.rbe_parent) {
#line 51
          if ((unsigned int )gparent == (unsigned int )(gparent->next.rbe_parent)->next.rbe_left) {
#line 51
            (gparent->next.rbe_parent)->next.rbe_left = tmp;
          } else {
#line 51
            (gparent->next.rbe_parent)->next.rbe_right = tmp;
          }
        } else {
#line 51
          head->rbh_root = tmp;
        }
#line 51
        tmp->next.rbe_left = gparent;
#line 51
        gparent->next.rbe_parent = tmp;
#line 51
        if (tmp->next.rbe_parent) {

        }
#line 51
        break;
      }
    }
  }
#line 51
  (head->rbh_root)->next.rbe_color = 0;
#line 51
  return;
}
}
#line 51 "monitor_mm.c"
void mmtree_RB_REMOVE_COLOR(struct mmtree *head , struct mm_share *parent , struct mm_share *elm ) 
{ struct mm_share *tmp ;
  struct mm_share *oleft ;
  struct mm_share *oright ;

  {
#line 51
  while (1) {
#line 51
    if ((unsigned int )elm == (unsigned int )((void *)0)) {
      goto _L___5;
    } else {
#line 51
      if (elm->next.rbe_color == 0) {
        _L___5: /* CIL Label */ 
#line 51
        if (! ((unsigned int )elm != (unsigned int )head->rbh_root)) {
#line 51
          break;
        }
      } else {
#line 51
        break;
      }
    }
#line 51
    if ((unsigned int )parent->next.rbe_left == (unsigned int )elm) {
#line 51
      tmp = parent->next.rbe_right;
#line 51
      if (tmp->next.rbe_color == 1) {
#line 51
        while (1) {
#line 51
          tmp->next.rbe_color = 0;
#line 51
          parent->next.rbe_color = 1;
#line 51
          break;
        }
#line 51
        while (1) {
#line 51
          tmp = parent->next.rbe_right;
#line 51
          parent->next.rbe_right = tmp->next.rbe_left;
#line 51
          if (parent->next.rbe_right) {
#line 51
            (tmp->next.rbe_left)->next.rbe_parent = parent;
          }
#line 51
          tmp->next.rbe_parent = parent->next.rbe_parent;
#line 51
          if (tmp->next.rbe_parent) {
#line 51
            if ((unsigned int )parent == (unsigned int )(parent->next.rbe_parent)->next.rbe_left) {
#line 51
              (parent->next.rbe_parent)->next.rbe_left = tmp;
            } else {
#line 51
              (parent->next.rbe_parent)->next.rbe_right = tmp;
            }
          } else {
#line 51
            head->rbh_root = tmp;
          }
#line 51
          tmp->next.rbe_left = parent;
#line 51
          parent->next.rbe_parent = tmp;
#line 51
          if (tmp->next.rbe_parent) {

          }
#line 51
          break;
        }
#line 51
        tmp = parent->next.rbe_right;
      }
#line 51
      if ((unsigned int )tmp->next.rbe_left == (unsigned int )((void *)0)) {
        goto _L___1;
      } else {
#line 51
        if ((tmp->next.rbe_left)->next.rbe_color == 0) {
          _L___1: /* CIL Label */ 
#line 51
          if ((unsigned int )tmp->next.rbe_right == (unsigned int )((void *)0)) {
#line 51
            tmp->next.rbe_color = 1;
#line 51
            elm = parent;
#line 51
            parent = elm->next.rbe_parent;
          } else {
#line 51
            if ((tmp->next.rbe_right)->next.rbe_color == 0) {
#line 51
              tmp->next.rbe_color = 1;
#line 51
              elm = parent;
#line 51
              parent = elm->next.rbe_parent;
            } else {
              goto _L___0;
            }
          }
        } else {
          _L___0: /* CIL Label */ 
#line 51
          if ((unsigned int )tmp->next.rbe_right == (unsigned int )((void *)0)) {
            goto _L;
          } else {
#line 51
            if ((tmp->next.rbe_right)->next.rbe_color == 0) {
              _L: /* CIL Label */ 
#line 51
              oleft = tmp->next.rbe_left;
#line 51
              if (oleft) {
#line 51
                oleft->next.rbe_color = 0;
              }
#line 51
              tmp->next.rbe_color = 1;
#line 51
              while (1) {
#line 51
                oleft = tmp->next.rbe_left;
#line 51
                tmp->next.rbe_left = oleft->next.rbe_right;
#line 51
                if (tmp->next.rbe_left) {
#line 51
                  (oleft->next.rbe_right)->next.rbe_parent = tmp;
                }
#line 51
                oleft->next.rbe_parent = tmp->next.rbe_parent;
#line 51
                if (oleft->next.rbe_parent) {
#line 51
                  if ((unsigned int )tmp == (unsigned int )(tmp->next.rbe_parent)->next.rbe_left) {
#line 51
                    (tmp->next.rbe_parent)->next.rbe_left = oleft;
                  } else {
#line 51
                    (tmp->next.rbe_parent)->next.rbe_right = oleft;
                  }
                } else {
#line 51
                  head->rbh_root = oleft;
                }
#line 51
                oleft->next.rbe_right = tmp;
#line 51
                tmp->next.rbe_parent = oleft;
#line 51
                if (oleft->next.rbe_parent) {

                }
#line 51
                break;
              }
#line 51
              tmp = parent->next.rbe_right;
            }
          }
#line 51
          tmp->next.rbe_color = parent->next.rbe_color;
#line 51
          parent->next.rbe_color = 0;
#line 51
          if (tmp->next.rbe_right) {
#line 51
            (tmp->next.rbe_right)->next.rbe_color = 0;
          }
#line 51
          while (1) {
#line 51
            tmp = parent->next.rbe_right;
#line 51
            parent->next.rbe_right = tmp->next.rbe_left;
#line 51
            if (parent->next.rbe_right) {
#line 51
              (tmp->next.rbe_left)->next.rbe_parent = parent;
            }
#line 51
            tmp->next.rbe_parent = parent->next.rbe_parent;
#line 51
            if (tmp->next.rbe_parent) {
#line 51
              if ((unsigned int )parent == (unsigned int )(parent->next.rbe_parent)->next.rbe_left) {
#line 51
                (parent->next.rbe_parent)->next.rbe_left = tmp;
              } else {
#line 51
                (parent->next.rbe_parent)->next.rbe_right = tmp;
              }
            } else {
#line 51
              head->rbh_root = tmp;
            }
#line 51
            tmp->next.rbe_left = parent;
#line 51
            parent->next.rbe_parent = tmp;
#line 51
            if (tmp->next.rbe_parent) {

            }
#line 51
            break;
          }
#line 51
          elm = head->rbh_root;
#line 51
          break;
        }
      }
    } else {
#line 51
      tmp = parent->next.rbe_left;
#line 51
      if (tmp->next.rbe_color == 1) {
#line 51
        while (1) {
#line 51
          tmp->next.rbe_color = 0;
#line 51
          parent->next.rbe_color = 1;
#line 51
          break;
        }
#line 51
        while (1) {
#line 51
          tmp = parent->next.rbe_left;
#line 51
          parent->next.rbe_left = tmp->next.rbe_right;
#line 51
          if (parent->next.rbe_left) {
#line 51
            (tmp->next.rbe_right)->next.rbe_parent = parent;
          }
#line 51
          tmp->next.rbe_parent = parent->next.rbe_parent;
#line 51
          if (tmp->next.rbe_parent) {
#line 51
            if ((unsigned int )parent == (unsigned int )(parent->next.rbe_parent)->next.rbe_left) {
#line 51
              (parent->next.rbe_parent)->next.rbe_left = tmp;
            } else {
#line 51
              (parent->next.rbe_parent)->next.rbe_right = tmp;
            }
          } else {
#line 51
            head->rbh_root = tmp;
          }
#line 51
          tmp->next.rbe_right = parent;
#line 51
          parent->next.rbe_parent = tmp;
#line 51
          if (tmp->next.rbe_parent) {

          }
#line 51
          break;
        }
#line 51
        tmp = parent->next.rbe_left;
      }
#line 51
      if ((unsigned int )tmp->next.rbe_left == (unsigned int )((void *)0)) {
        goto _L___4;
      } else {
#line 51
        if ((tmp->next.rbe_left)->next.rbe_color == 0) {
          _L___4: /* CIL Label */ 
#line 51
          if ((unsigned int )tmp->next.rbe_right == (unsigned int )((void *)0)) {
#line 51
            tmp->next.rbe_color = 1;
#line 51
            elm = parent;
#line 51
            parent = elm->next.rbe_parent;
          } else {
#line 51
            if ((tmp->next.rbe_right)->next.rbe_color == 0) {
#line 51
              tmp->next.rbe_color = 1;
#line 51
              elm = parent;
#line 51
              parent = elm->next.rbe_parent;
            } else {
              goto _L___3;
            }
          }
        } else {
          _L___3: /* CIL Label */ 
#line 51
          if ((unsigned int )tmp->next.rbe_left == (unsigned int )((void *)0)) {
            goto _L___2;
          } else {
#line 51
            if ((tmp->next.rbe_left)->next.rbe_color == 0) {
              _L___2: /* CIL Label */ 
#line 51
              oright = tmp->next.rbe_right;
#line 51
              if (oright) {
#line 51
                oright->next.rbe_color = 0;
              }
#line 51
              tmp->next.rbe_color = 1;
#line 51
              while (1) {
#line 51
                oright = tmp->next.rbe_right;
#line 51
                tmp->next.rbe_right = oright->next.rbe_left;
#line 51
                if (tmp->next.rbe_right) {
#line 51
                  (oright->next.rbe_left)->next.rbe_parent = tmp;
                }
#line 51
                oright->next.rbe_parent = tmp->next.rbe_parent;
#line 51
                if (oright->next.rbe_parent) {
#line 51
                  if ((unsigned int )tmp == (unsigned int )(tmp->next.rbe_parent)->next.rbe_left) {
#line 51
                    (tmp->next.rbe_parent)->next.rbe_left = oright;
                  } else {
#line 51
                    (tmp->next.rbe_parent)->next.rbe_right = oright;
                  }
                } else {
#line 51
                  head->rbh_root = oright;
                }
#line 51
                oright->next.rbe_left = tmp;
#line 51
                tmp->next.rbe_parent = oright;
#line 51
                if (oright->next.rbe_parent) {

                }
#line 51
                break;
              }
#line 51
              tmp = parent->next.rbe_left;
            }
          }
#line 51
          tmp->next.rbe_color = parent->next.rbe_color;
#line 51
          parent->next.rbe_color = 0;
#line 51
          if (tmp->next.rbe_left) {
#line 51
            (tmp->next.rbe_left)->next.rbe_color = 0;
          }
#line 51
          while (1) {
#line 51
            tmp = parent->next.rbe_left;
#line 51
            parent->next.rbe_left = tmp->next.rbe_right;
#line 51
            if (parent->next.rbe_left) {
#line 51
              (tmp->next.rbe_right)->next.rbe_parent = parent;
            }
#line 51
            tmp->next.rbe_parent = parent->next.rbe_parent;
#line 51
            if (tmp->next.rbe_parent) {
#line 51
              if ((unsigned int )parent == (unsigned int )(parent->next.rbe_parent)->next.rbe_left) {
#line 51
                (parent->next.rbe_parent)->next.rbe_left = tmp;
              } else {
#line 51
                (parent->next.rbe_parent)->next.rbe_right = tmp;
              }
            } else {
#line 51
              head->rbh_root = tmp;
            }
#line 51
            tmp->next.rbe_right = parent;
#line 51
            parent->next.rbe_parent = tmp;
#line 51
            if (tmp->next.rbe_parent) {

            }
#line 51
            break;
          }
#line 51
          elm = head->rbh_root;
#line 51
          break;
        }
      }
    }
  }
#line 51
  if (elm) {
#line 51
    elm->next.rbe_color = 0;
  }
#line 51
  return;
}
}
#line 51 "monitor_mm.c"
struct mm_share *mmtree_RB_REMOVE(struct mmtree *head , struct mm_share *elm ) 
{ struct mm_share *child ;
  struct mm_share *parent ;
  struct mm_share *old ;
  int color ;
  struct mm_share *left ;

  {
#line 51
  old = elm;
#line 51
  if ((unsigned int )elm->next.rbe_left == (unsigned int )((void *)0)) {
#line 51
    child = elm->next.rbe_right;
  } else {
#line 51
    if ((unsigned int )elm->next.rbe_right == (unsigned int )((void *)0)) {
#line 51
      child = elm->next.rbe_left;
    } else {
#line 51
      elm = elm->next.rbe_right;
#line 51
      while (1) {
#line 51
        left = elm->next.rbe_left;
#line 51
        if (! left) {
#line 51
          break;
        }
#line 51
        elm = left;
      }
#line 51
      child = elm->next.rbe_right;
#line 51
      parent = elm->next.rbe_parent;
#line 51
      color = elm->next.rbe_color;
#line 51
      if (child) {
#line 51
        child->next.rbe_parent = parent;
      }
#line 51
      if (parent) {
#line 51
        if ((unsigned int )parent->next.rbe_left == (unsigned int )elm) {
#line 51
          parent->next.rbe_left = child;
        } else {
#line 51
          parent->next.rbe_right = child;
        }
      } else {
#line 51
        head->rbh_root = child;
      }
#line 51
      if ((unsigned int )elm->next.rbe_parent == (unsigned int )old) {
#line 51
        parent = elm;
      }
#line 51
      elm->next = old->next;
#line 51
      if (old->next.rbe_parent) {
#line 51
        if ((unsigned int )(old->next.rbe_parent)->next.rbe_left == (unsigned int )old) {
#line 51
          (old->next.rbe_parent)->next.rbe_left = elm;
        } else {
#line 51
          (old->next.rbe_parent)->next.rbe_right = elm;
        }
      } else {
#line 51
        head->rbh_root = elm;
      }
#line 51
      (old->next.rbe_left)->next.rbe_parent = elm;
#line 51
      if (old->next.rbe_right) {
#line 51
        (old->next.rbe_right)->next.rbe_parent = elm;
      }
#line 51
      if (parent) {
#line 51
        left = parent;
#line 51
        while (1) {
#line 51
          left = left->next.rbe_parent;
#line 51
          if (! left) {
#line 51
            break;
          }
        }
      }
      goto color;
    }
  }
#line 51
  parent = elm->next.rbe_parent;
#line 51
  color = elm->next.rbe_color;
#line 51
  if (child) {
#line 51
    child->next.rbe_parent = parent;
  }
#line 51
  if (parent) {
#line 51
    if ((unsigned int )parent->next.rbe_left == (unsigned int )elm) {
#line 51
      parent->next.rbe_left = child;
    } else {
#line 51
      parent->next.rbe_right = child;
    }
  } else {
#line 51
    head->rbh_root = child;
  }
  color: 
#line 51
  if (color == 0) {
#line 51
    mmtree_RB_REMOVE_COLOR(head, parent, child);
  }
#line 51
  return (old);
}
}
#line 51 "monitor_mm.c"
struct mm_share *mmtree_RB_INSERT(struct mmtree *head , struct mm_share *elm ) 
{ struct mm_share *tmp ;
  struct mm_share *parent ;
  int comp ;

  {
#line 51
  parent = (struct mm_share *)((void *)0);
#line 51
  comp = 0;
#line 51
  tmp = head->rbh_root;
#line 51
  while (tmp) {
#line 51
    parent = tmp;
#line 51
    comp = mm_compare(elm, parent);
#line 51
    if (comp < 0) {
#line 51
      tmp = tmp->next.rbe_left;
    } else {
#line 51
      if (comp > 0) {
#line 51
        tmp = tmp->next.rbe_right;
      } else {
#line 51
        return (tmp);
      }
    }
  }
#line 51
  while (1) {
#line 51
    elm->next.rbe_parent = parent;
#line 51
    elm->next.rbe_right = (struct mm_share *)((void *)0);
#line 51
    elm->next.rbe_left = elm->next.rbe_right;
#line 51
    elm->next.rbe_color = 1;
#line 51
    break;
  }
#line 51
  if ((unsigned int )parent != (unsigned int )((void *)0)) {
#line 51
    if (comp < 0) {
#line 51
      parent->next.rbe_left = elm;
    } else {
#line 51
      parent->next.rbe_right = elm;
    }
  } else {
#line 51
    head->rbh_root = elm;
  }
#line 51
  mmtree_RB_INSERT_COLOR(head, elm);
#line 51
  return ((struct mm_share *)((void *)0));
}
}
#line 51 "monitor_mm.c"
struct mm_share *mmtree_RB_FIND(struct mmtree *head , struct mm_share *elm ) 
{ struct mm_share *tmp ;
  int comp ;

  {
#line 51
  tmp = head->rbh_root;
#line 51
  while (tmp) {
#line 51
    comp = mm_compare(elm, tmp);
#line 51
    if (comp < 0) {
#line 51
      tmp = tmp->next.rbe_left;
    } else {
#line 51
      if (comp > 0) {
#line 51
        tmp = tmp->next.rbe_right;
      } else {
#line 51
        return (tmp);
      }
    }
  }
#line 51
  return ((struct mm_share *)((void *)0));
}
}
#line 51 "monitor_mm.c"
struct mm_share *mmtree_RB_NEXT(struct mmtree *head , struct mm_share *elm ) 
{ 

  {
#line 51
  if (elm->next.rbe_right) {
#line 51
    elm = elm->next.rbe_right;
#line 51
    while (elm->next.rbe_left) {
#line 51
      elm = elm->next.rbe_left;
    }
  } else {
#line 51
    if (elm->next.rbe_parent) {
#line 51
      if ((unsigned int )elm == (unsigned int )(elm->next.rbe_parent)->next.rbe_left) {
#line 51
        elm = elm->next.rbe_parent;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 51
      while (1) {
#line 51
        if (elm->next.rbe_parent) {
#line 51
          if (! ((unsigned int )elm == (unsigned int )(elm->next.rbe_parent)->next.rbe_right)) {
#line 51
            break;
          }
        } else {
#line 51
          break;
        }
#line 51
        elm = elm->next.rbe_parent;
      }
#line 51
      elm = elm->next.rbe_parent;
    }
  }
#line 51
  return (elm);
}
}
#line 51 "monitor_mm.c"
struct mm_share *mmtree_RB_MINMAX(struct mmtree *head , int val ) 
{ struct mm_share *tmp ;
  struct mm_share *parent ;

  {
#line 51
  tmp = head->rbh_root;
#line 51
  parent = (struct mm_share *)((void *)0);
#line 51
  while (tmp) {
#line 51
    parent = tmp;
#line 51
    if (val < 0) {
#line 51
      tmp = tmp->next.rbe_left;
    } else {
#line 51
      tmp = tmp->next.rbe_right;
    }
  }
#line 51
  return (parent);
}
}
#line 53 "monitor_mm.c"
static struct mm_share *mm_make_entry(struct mm_master *mm , struct mmtree *head ,
                                      void *address , size_t size ) 
{ struct mm_share *tmp ;
  struct mm_share *tmp2 ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 59
  if ((unsigned int )mm->mmalloc == (unsigned int )((void *)0)) {
#line 60
    tmp___0 = xmalloc(sizeof(struct mm_share ));
#line 60
    tmp = (struct mm_share *)tmp___0;
  } else {
#line 62
    tmp___1 = mm_xmalloc(mm->mmalloc, sizeof(struct mm_share ));
#line 62
    tmp = (struct mm_share *)tmp___1;
  }
#line 63
  tmp->address = address;
#line 64
  tmp->size = size;
#line 66
  tmp2 = mmtree_RB_INSERT(head, tmp);
#line 67
  if ((unsigned int )tmp2 != (unsigned int )((void *)0)) {
#line 68
    fatal("mm_make_entry(%p): double address %p->%p(%lu)", mm, tmp2, address, (unsigned long )size);
  }
#line 71
  return (tmp);
}
}
#line 76 "monitor_mm.c"
struct mm_master *mm_create(struct mm_master *mmalloc , size_t size ) 
{ void *address ;
  struct mm_master *mm ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
#line 82
  if ((unsigned int )mmalloc == (unsigned int )((void *)0)) {
#line 83
    tmp = xmalloc(sizeof(struct mm_master ));
#line 83
    mm = (struct mm_master *)tmp;
  } else {
#line 85
    tmp___0 = mm_xmalloc(mmalloc, sizeof(struct mm_master ));
#line 85
    mm = (struct mm_master *)tmp___0;
  }
#line 92
  mm->mmalloc = mmalloc;
#line 94
  address = xmmap(size);
#line 95
  if ((unsigned int )address == (unsigned int )((void *)-1)) {
#line 96
    tmp___1 = __errno_location();
#line 96
    tmp___2 = strerror(*tmp___1);
#line 96
    fatal("mmap(%lu): %s", (unsigned long )size, tmp___2);
  }
#line 98
  mm->address = address;
#line 99
  mm->size = size;
#line 101
  while (1) {
#line 101
    mm->rb_free.rbh_root = (struct mm_share *)((void *)0);
#line 101
    break;
  }
#line 102
  while (1) {
#line 102
    mm->rb_allocated.rbh_root = (struct mm_share *)((void *)0);
#line 102
    break;
  }
#line 104
  mm_make_entry(mm, & mm->rb_free, address, size);
#line 106
  return (mm);
}
}
#line 111 "monitor_mm.c"
static void mm_freelist(struct mm_master *mmalloc , struct mmtree *head ) 
{ struct mm_share *mms ;
  struct mm_share *next ;

  {
#line 116
  mms = head->rbh_root;
#line 116
  while (mms) {
#line 117
    next = mmtree_RB_NEXT(head, mms);
#line 118
    mmtree_RB_REMOVE(head, mms);
#line 119
    if ((unsigned int )mmalloc == (unsigned int )((void *)0)) {
#line 120
      xfree((void *)mms);
    } else {
#line 122
      mm_free(mmalloc, (void *)mms);
    }
#line 116
    mms = next;
  }
#line 124
  return;
}
}
#line 128 "monitor_mm.c"
void mm_destroy(struct mm_master *mm ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 131
  mm_freelist(mm->mmalloc, & mm->rb_free);
#line 132
  mm_freelist(mm->mmalloc, & mm->rb_allocated);
#line 135
  tmp___1 = munmap(mm->address, mm->size);
#line 135
  if (tmp___1 == -1) {
#line 136
    tmp = __errno_location();
#line 136
    tmp___0 = strerror(*tmp);
#line 136
    fatal("munmap(%p, %lu): %s", mm->address, (unsigned long )mm->size, tmp___0);
  }
#line 142
  if ((unsigned int )mm->mmalloc == (unsigned int )((void *)0)) {
#line 143
    xfree((void *)mm);
  } else {
#line 145
    mm_free(mm->mmalloc, (void *)mm);
  }
#line 146
  return;
}
}
#line 148 "monitor_mm.c"
void *mm_xmalloc(struct mm_master *mm , size_t size ) 
{ void *address ;

  {
#line 153
  address = mm_malloc(mm, size);
#line 154
  if ((unsigned int )address == (unsigned int )((void *)0)) {
#line 155
    fatal("%s: mm_malloc(%lu)", "mm_xmalloc", (unsigned long )size);
  }
#line 156
  return (address);
}
}
#line 162 "monitor_mm.c"
void *mm_malloc(struct mm_master *mm , size_t size ) 
{ struct mm_share *mms ;
  struct mm_share *tmp ;

  {
#line 167
  if (size == 0U) {
#line 168
    fatal("mm_malloc: try to allocate 0 space");
  }
#line 169
  if ((unsigned long )size > 4294967168UL) {
#line 170
    fatal("mm_malloc: size too big");
  }
#line 172
  size = ((size + 127U) / 128U) * 128U;
#line 174
  mms = mmtree_RB_MINMAX(& mm->rb_free, -1);
#line 174
  while ((unsigned int )mms != (unsigned int )((void *)0)) {
#line 175
    if (mms->size >= size) {
#line 176
      break;
    }
#line 174
    mms = mmtree_RB_NEXT(& mm->rb_free, mms);
  }
#line 179
  if ((unsigned int )mms == (unsigned int )((void *)0)) {
#line 180
    return ((void *)0);
  }
#line 183
  memset(mms->address, 208, size);
#line 185
  tmp = mm_make_entry(mm, & mm->rb_allocated, mms->address, size);
#line 188
  mms->size -= size;
#line 189
  mms->address = (void *)((u_char *)mms->address + size);
#line 191
  if (mms->size == 0U) {
#line 192
    mmtree_RB_REMOVE(& mm->rb_free, mms);
#line 193
    if ((unsigned int )mm->mmalloc == (unsigned int )((void *)0)) {
#line 194
      xfree((void *)mms);
    } else {
#line 196
      mm_free(mm->mmalloc, (void *)mms);
    }
  }
#line 199
  return (tmp->address);
}
}
#line 204 "monitor_mm.c"
void mm_free(struct mm_master *mm , void *address ) 
{ struct mm_share *mms ;
  struct mm_share *prev ;
  struct mm_share tmp ;
  struct mm_share *tmp___0 ;

  {
#line 209
  tmp.address = address;
#line 210
  mms = mmtree_RB_FIND(& mm->rb_allocated, & tmp);
#line 211
  if ((unsigned int )mms == (unsigned int )((void *)0)) {
#line 212
    fatal("mm_free(%p): can not find %p", mm, address);
  }
#line 215
  memset(mms->address, 208, mms->size);
#line 218
  mmtree_RB_REMOVE(& mm->rb_allocated, mms);
#line 219
  tmp___0 = mmtree_RB_INSERT(& mm->rb_free, mms);
#line 219
  if ((unsigned int )tmp___0 != (unsigned int )((void *)0)) {
#line 220
    fatal("mm_free(%p): double address %p", mm, address);
  }
#line 223
  prev = mms;
#line 224
  if (prev->next.rbe_left) {
#line 225
    prev = prev->next.rbe_left;
#line 226
    while (prev->next.rbe_right) {
#line 227
      prev = prev->next.rbe_right;
    }
  } else {
#line 229
    if (prev->next.rbe_parent) {
#line 229
      if ((unsigned int )prev == (unsigned int )(prev->next.rbe_parent)->next.rbe_right) {
#line 231
        prev = prev->next.rbe_parent;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 233
      while (1) {
#line 233
        if (prev->next.rbe_parent) {
#line 233
          if (! ((unsigned int )prev == (unsigned int )(prev->next.rbe_parent)->next.rbe_left)) {
#line 233
            break;
          }
        } else {
#line 233
          break;
        }
#line 235
        prev = prev->next.rbe_parent;
      }
#line 236
      prev = prev->next.rbe_parent;
    }
  }
#line 241
  if ((unsigned int )prev != (unsigned int )((void *)0)) {
#line 241
    if ((unsigned int )((void *)((u_char *)prev->address + prev->size)) > (unsigned int )address) {
#line 242
      fatal("mm_free: memory corruption: %p(%lu) > %p", prev->address, (unsigned long )prev->size,
            address);
    }
  }
#line 246
  if ((unsigned int )prev != (unsigned int )((void *)0)) {
#line 246
    if ((unsigned int )((void *)((u_char *)prev->address + prev->size)) == (unsigned int )address) {
#line 247
      prev->size += mms->size;
#line 248
      mmtree_RB_REMOVE(& mm->rb_free, mms);
#line 249
      if ((unsigned int )mm->mmalloc == (unsigned int )((void *)0)) {
#line 250
        xfree((void *)mms);
      } else {
#line 252
        mm_free(mm->mmalloc, (void *)mms);
      }
    } else {
#line 254
      prev = mms;
    }
  } else {
#line 254
    prev = mms;
  }
#line 256
  if ((unsigned int )prev == (unsigned int )((void *)0)) {
#line 257
    return;
  }
#line 260
  mms = mmtree_RB_NEXT(& mm->rb_free, prev);
#line 261
  if ((unsigned int )mms == (unsigned int )((void *)0)) {
#line 262
    return;
  }
#line 264
  if ((unsigned int )((void *)((u_char *)prev->address + prev->size)) > (unsigned int )mms->address) {
#line 265
    fatal("mm_free: memory corruption: %p < %p(%lu)", mms->address, prev->address,
          (unsigned long )prev->size);
  }
#line 267
  if ((unsigned int )((void *)((u_char *)prev->address + prev->size)) != (unsigned int )mms->address) {
#line 268
    return;
  }
#line 270
  prev->size += mms->size;
#line 271
  mmtree_RB_REMOVE(& mm->rb_free, mms);
#line 273
  if ((unsigned int )mm->mmalloc == (unsigned int )((void *)0)) {
#line 274
    xfree((void *)mms);
  } else {
#line 276
    mm_free(mm->mmalloc, (void *)mms);
  }
#line 277
  return;
}
}
#line 279 "monitor_mm.c"
static void mm_sync_list(struct mmtree *oldtree , struct mmtree *newtree , struct mm_master *mm ,
                         struct mm_master *mmold ) 
{ struct mm_master *mmalloc ;
  struct mm_share *mms ;
  struct mm_share *new ;
  void *tmp ;

  {
#line 283
  mmalloc = mm->mmalloc;
#line 287
  mms = mmtree_RB_MINMAX(oldtree, -1);
#line 287
  while ((unsigned int )mms != (unsigned int )((void *)0)) {
#line 289
    mm_memvalid(mmold, (void *)mms, sizeof(struct mm_share ));
#line 290
    mm_memvalid(mm, mms->address, mms->size);
#line 292
    tmp = mm_xmalloc(mmalloc, sizeof(struct mm_share ));
#line 292
    new = (struct mm_share *)tmp;
#line 293
    memcpy((void * __restrict  )new, (void const   * __restrict  )mms, sizeof(struct mm_share ));
#line 294
    mmtree_RB_INSERT(newtree, new);
#line 287
    mms = mmtree_RB_NEXT(oldtree, mms);
  }
#line 296
  return;
}
}
#line 298 "monitor_mm.c"
void mm_share_sync(struct mm_master **pmm , struct mm_master **pmmalloc ) 
{ struct mm_master *mm ;
  struct mm_master *mmalloc ;
  struct mm_master *mmold ;
  struct mmtree rb_free ;
  struct mmtree rb_allocated ;
  void *tmp ;

  {
#line 306
  debug3("%s: Share sync", "mm_share_sync");
#line 308
  mm = *pmm;
#line 309
  mmold = mm->mmalloc;
#line 310
  mm_memvalid(mmold, (void *)mm, sizeof(*mm));
#line 312
  mmalloc = mm_create((struct mm_master *)((void *)0), mm->size);
#line 313
  tmp = mm_xmalloc(mmalloc, sizeof(struct mm_master ));
#line 313
  mm = (struct mm_master *)tmp;
#line 314
  memcpy((void * __restrict  )mm, (void const   * __restrict  )*pmm, sizeof(struct mm_master ));
#line 315
  mm->mmalloc = mmalloc;
#line 317
  rb_free = mm->rb_free;
#line 318
  rb_allocated = mm->rb_allocated;
#line 320
  while (1) {
#line 320
    mm->rb_free.rbh_root = (struct mm_share *)((void *)0);
#line 320
    break;
  }
#line 321
  while (1) {
#line 321
    mm->rb_allocated.rbh_root = (struct mm_share *)((void *)0);
#line 321
    break;
  }
#line 323
  mm_sync_list(& rb_free, & mm->rb_free, mm, mmold);
#line 324
  mm_sync_list(& rb_allocated, & mm->rb_allocated, mm, mmold);
#line 326
  mm_destroy(mmold);
#line 328
  *pmm = mm;
#line 329
  *pmmalloc = mmalloc;
#line 331
  debug3("%s: Share sync end", "mm_share_sync");
#line 332
  return;
}
}
#line 334 "monitor_mm.c"
void mm_memvalid(struct mm_master *mm , void *address , size_t size ) 
{ void *end ;

  {
#line 337
  end = (void *)((u_char *)address + size);
#line 339
  if ((unsigned int )address < (unsigned int )mm->address) {
#line 340
    fatal("mm_memvalid: address too small: %p", address);
  }
#line 341
  if ((unsigned int )end < (unsigned int )address) {
#line 342
    fatal("mm_memvalid: end < address: %p < %p", end, address);
  }
#line 343
  if ((unsigned int )end > (unsigned int )((void *)((u_char *)mm->address + mm->size))) {
#line 344
    fatal("mm_memvalid: address too large: %p", address);
  }
#line 345
  return;
}
}
#line 1 "monitor.o"
#line 84 "monitor.h"
int monitor_read(struct monitor *pmonitor___0 , struct mon_table *ent , struct mon_table **pent ) ;
#line 87
void mm_request_send(int socket___0 , enum monitor_reqtype type , Buffer *m___0 ) ;
#line 88
void mm_request_receive(int socket___0 , Buffer *m___0 ) ;
#line 89
void mm_request_receive_expect(int socket___0 , enum monitor_reqtype type , Buffer *m___0 ) ;
#line 87 "monitor_wrap.h"
struct Newkeys *mm_newkeys_from_blob(u_char *blob , int blen ) ;
#line 91
void mm_get_keystate(struct monitor *pmonitor___0 ) ;
#line 104
void *mm_zalloc(struct mm_master *mm , u_int ncount , u_int size ) ;
#line 105
void mm_zfree(struct mm_master *mm , void *address ) ;
#line 106
void mm_init_compression(struct mm_master *mm ) ;
#line 31 "monitor_fdpass.h"
void mm_send_fd(int socket___0 , int fd ) ;
#line 86 "monitor.c"
struct __anonstruct_child_state_80 child_state  ;
#line 109
int mm_answer_moduli(int socket___0 , Buffer *m___0 ) ;
#line 110
int mm_answer_sign(int socket___0 , Buffer *m___0 ) ;
#line 111
int mm_answer_pwnamallow(int socket___0 , Buffer *m___0 ) ;
#line 112
int mm_answer_auth2_read_banner(int socket___0 , Buffer *m___0 ) ;
#line 113
int mm_answer_authserv(int socket___0 , Buffer *m___0 ) ;
#line 114
int mm_answer_authpassword(int socket___0 , Buffer *m___0 ) ;
#line 119
int mm_answer_keyallowed(int socket___0 , Buffer *m___0 ) ;
#line 120
int mm_answer_keyverify(int socket___0 , Buffer *m___0 ) ;
#line 121
int mm_answer_pty(int socket___0 , Buffer *m___0 ) ;
#line 122
int mm_answer_pty_cleanup(int socket___0 , Buffer *m___0 ) ;
#line 123
int mm_answer_term(int socket___0 , Buffer *req ) ;
#line 124
int mm_answer_rsa_keyallowed(int socket___0 , Buffer *m___0 ) ;
#line 125
int mm_answer_rsa_challenge(int socket___0 , Buffer *m___0 ) ;
#line 126
int mm_answer_rsa_response(int socket___0 , Buffer *m___0 ) ;
#line 127
int mm_answer_sesskey(int socket___0 , Buffer *m___0 ) ;
#line 128
int mm_answer_sessid(int socket___0 , Buffer *m___0 ) ;
#line 146 "monitor.c"
static Authctxt *authctxt  ;
#line 147 "monitor.c"
static BIGNUM *ssh1_challenge  =    (BIGNUM *)((void *)0);
#line 150 "monitor.c"
static u_char *key_blob  =    (u_char *)((void *)0);
#line 151 "monitor.c"
static u_int key_bloblen  =    (u_int )0;
#line 152 "monitor.c"
static int key_blobtype  =    0;
#line 153 "monitor.c"
static char *hostbased_cuser  =    (char *)((void *)0);
#line 154 "monitor.c"
static char *hostbased_chost  =    (char *)((void *)0);
#line 155 "monitor.c"
static char *auth_method  =    (char *)"unknown";
#line 156 "monitor.c"
static u_int session_id2_len___0  =    (u_int )0;
#line 157 "monitor.c"
static u_char *session_id2___0  =    (u_char *)((void *)0);
#line 158 "monitor.c"
static pid_t monitor_child_pid  ;
#line 174 "monitor.c"
struct mon_table mon_dispatch_proto20[9]  = 
#line 174
  {      {0, 16, & mm_answer_moduli}, 
        {4, 16, & mm_answer_sign}, 
        {6, 16, & mm_answer_pwnamallow}, 
        {3, 16, & mm_answer_authserv}, 
        {8, 16, & mm_answer_auth2_read_banner}, 
        {10, 12, & mm_answer_authpassword}, 
        {20, 4, & mm_answer_keyallowed}, 
        {22, 12, & mm_answer_keyverify}, 
        {(enum monitor_reqtype )0, 0, (int (*)(int  , Buffer * ))((void *)0)}};
#line 208 "monitor.c"
struct mon_table mon_dispatch_postauth20[6]  = {      {0, 0, & mm_answer_moduli}, 
        {4, 0, & mm_answer_sign}, 
        {25, 0, & mm_answer_pty}, 
        {27, 0, & mm_answer_pty_cleanup}, 
        {56, 0, & mm_answer_term}, 
        {(enum monitor_reqtype )0, 0, (int (*)(int  , Buffer * ))((void *)0)}};
#line 217 "monitor.c"
struct mon_table mon_dispatch_proto15[9]  = 
#line 217
  {      {6, 16, & mm_answer_pwnamallow}, 
        {28, 16, & mm_answer_sesskey}, 
        {30, 16, & mm_answer_sessid}, 
        {10, 12, & mm_answer_authpassword}, 
        {31, 4, & mm_answer_rsa_keyallowed}, 
        {20, 4, & mm_answer_keyallowed}, 
        {33, 16, & mm_answer_rsa_challenge}, 
        {35, 24, & mm_answer_rsa_response}, 
        {(enum monitor_reqtype )0, 0, (int (*)(int  , Buffer * ))((void *)0)}};
#line 245 "monitor.c"
struct mon_table mon_dispatch_postauth15[4]  = {      {25, 16, & mm_answer_pty}, 
        {27, 16, & mm_answer_pty_cleanup}, 
        {56, 0, & mm_answer_term}, 
        {(enum monitor_reqtype )0, 0, (int (*)(int  , Buffer * ))((void *)0)}};
#line 252 "monitor.c"
struct mon_table *mon_dispatch  ;
#line 256 "monitor.c"
static void monitor_permit(struct mon_table *ent , enum monitor_reqtype type , int permit ) 
{ int tmp ;

  {
#line 259
  while ((unsigned int )ent->f != (unsigned int )((void *)0)) {
#line 260
    if ((int )ent->type == (int )type) {
#line 261
      ent->flags &= -4097;
#line 262
      if (permit) {
#line 262
        tmp = 4096;
      } else {
#line 262
        tmp = 0;
      }
#line 262
      ent->flags |= tmp;
#line 263
      return;
    }
#line 265
    ent ++;
  }
#line 267
  return;
}
}
#line 269 "monitor.c"
static void monitor_permit_authentications(int permit ) 
{ struct mon_table *ent ;
  int tmp ;

  {
#line 272
  ent = mon_dispatch;
#line 274
  while ((unsigned int )ent->f != (unsigned int )((void *)0)) {
#line 275
    if (ent->flags & 12) {
#line 276
      ent->flags &= -4097;
#line 277
      if (permit) {
#line 277
        tmp = 4096;
      } else {
#line 277
        tmp = 0;
      }
#line 277
      ent->flags |= tmp;
    }
#line 279
    ent ++;
  }
#line 281
  return;
}
}
#line 283 "monitor.c"
void monitor_child_preauth(struct Authctxt *_authctxt , struct monitor *pmonitor___0 ) 
{ struct mon_table *ent ;
  int authenticated ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 287
  authenticated = 0;
#line 289
  debug3("preauth child monitor started");
#line 291
  authctxt = _authctxt;
#line 292
  memset((void *)authctxt, 0, sizeof(*authctxt));
#line 294
  if (compat20) {
#line 295
    mon_dispatch = mon_dispatch_proto20;
#line 298
    monitor_permit(mon_dispatch, 0, 1);
#line 299
    monitor_permit(mon_dispatch, 4, 1);
  } else {
#line 301
    mon_dispatch = mon_dispatch_proto15;
#line 303
    monitor_permit(mon_dispatch, 28, 1);
  }
#line 307
  while (! authenticated) {
#line 308
    authenticated = monitor_read(pmonitor___0, mon_dispatch, & ent);
#line 309
    if (authenticated) {
#line 310
      if (! (ent->flags & 8)) {
#line 311
        fatal("%s: unexpected authentication from %d", "monitor_child_preauth", ent->type);
      }
#line 313
      if ((authctxt->pw)->pw_uid == 0U) {
#line 313
        tmp = auth_root_allowed(auth_method);
#line 313
        if (! tmp) {
#line 315
          authenticated = 0;
        }
      }
    }
#line 330
    if (ent->flags & 8) {
#line 331
      if (compat20) {
#line 331
        tmp___0 = " ssh2";
      } else {
#line 331
        tmp___0 = "";
      }
#line 331
      auth_log(authctxt, authenticated, auth_method, (char *)tmp___0);
#line 333
      if (! authenticated) {
#line 334
        (authctxt->failures) ++;
      }
    }
  }
#line 338
  if (! authctxt->valid) {
#line 339
    fatal("%s: authenticated invalid user", "monitor_child_preauth");
  }
#line 341
  debug("%s: %s has been authenticated by privileged process", "monitor_child_preauth",
        authctxt->user);
#line 344
  mm_get_keystate(pmonitor___0);
#line 345
  return;
}
}
#line 347 "monitor.c"
static void monitor_set_child_handler(pid_t pid ) 
{ 

  {
#line 350
  monitor_child_pid = pid;
#line 351
  return;
}
}
#line 353 "monitor.c"
static void monitor_child_handler(int signal___0 ) 
{ 

  {
#line 356
  kill(monitor_child_pid, signal___0);
#line 357
  return;
}
}
#line 359 "monitor.c"
void monitor_child_postauth(struct monitor *pmonitor___0 ) 
{ 

  {
#line 362
  monitor_set_child_handler(pmonitor___0->m_pid);
#line 363
  mysignal(1, & monitor_child_handler);
#line 364
  mysignal(15, & monitor_child_handler);
#line 366
  if (compat20) {
#line 367
    mon_dispatch = mon_dispatch_postauth20;
#line 370
    monitor_permit(mon_dispatch, 0, 1);
#line 371
    monitor_permit(mon_dispatch, 4, 1);
#line 372
    monitor_permit(mon_dispatch, 56, 1);
  } else {
#line 374
    mon_dispatch = mon_dispatch_postauth15;
#line 375
    monitor_permit(mon_dispatch, 56, 1);
  }
#line 377
  if (! no_pty_flag) {
#line 378
    monitor_permit(mon_dispatch, 25, 1);
#line 379
    monitor_permit(mon_dispatch, 27, 1);
  }
#line 382
  while (1) {
#line 383
    monitor_read(pmonitor___0, mon_dispatch, (struct mon_table **)((void *)0));
  }
}
}
#line 386 "monitor.c"
void monitor_sync(struct monitor *pmonitor___0 ) 
{ 

  {
#line 389
  if (options.compression) {
#line 391
    mm_share_sync(& pmonitor___0->m_zlib, & pmonitor___0->m_zback);
  }
#line 393
  return;
}
}
#line 395 "monitor.c"
int monitor_read(struct monitor *pmonitor___0 , struct mon_table *ent , struct mon_table **pent ) 
{ Buffer m___0 ;
  int ret ;
  u_char type ;
  int tmp ;

  {
#line 403
  buffer_init(& m___0);
#line 405
  mm_request_receive(pmonitor___0->m_sendfd, & m___0);
#line 406
  tmp = buffer_get_char(& m___0);
#line 406
  type = (unsigned char )tmp;
#line 408
  debug3("%s: checking request %d", "monitor_read", type);
#line 410
  while ((unsigned int )ent->f != (unsigned int )((void *)0)) {
#line 411
    if ((int )ent->type == (int )type) {
#line 412
      break;
    }
#line 413
    ent ++;
  }
#line 416
  if ((unsigned int )ent->f != (unsigned int )((void *)0)) {
#line 417
    if (! (ent->flags & 4096)) {
#line 418
      fatal("%s: unpermitted request %d", "monitor_read", type);
    }
#line 420
    ret = (*(ent->f))(pmonitor___0->m_sendfd, & m___0);
#line 421
    buffer_free(& m___0);
#line 424
    if (ent->flags & 16) {
#line 425
      debug2("%s: %d used once, disabling now", "monitor_read", type);
#line 427
      ent->flags &= -4097;
    }
#line 430
    if ((unsigned int )pent != (unsigned int )((void *)0)) {
#line 431
      *pent = ent;
    }
#line 433
    return (ret);
  }
#line 436
  fatal("%s: unsupported request: %d", "monitor_read", type);
#line 439
  return (-1);
}
}
#line 443 "monitor.c"
static int monitor_allowed_key(u_char *blob , u_int bloblen ) 
{ int tmp ;

  {
#line 447
  if ((unsigned int )key_blob == (unsigned int )((void *)0)) {
#line 449
    return (0);
  } else {
#line 447
    if (key_bloblen != bloblen) {
#line 449
      return (0);
    } else {
#line 447
      tmp = memcmp((void const   *)key_blob, (void const   *)blob, key_bloblen);
#line 447
      if (tmp) {
#line 449
        return (0);
      }
    }
  }
#line 450
  return (1);
}
}
#line 453 "monitor.c"
static void monitor_reset_key_state(void) 
{ 

  {
#line 457
  if ((unsigned int )key_blob != (unsigned int )((void *)0)) {
#line 458
    xfree((void *)key_blob);
  }
#line 459
  if ((unsigned int )hostbased_cuser != (unsigned int )((void *)0)) {
#line 460
    xfree((void *)hostbased_cuser);
  }
#line 461
  if ((unsigned int )hostbased_chost != (unsigned int )((void *)0)) {
#line 462
    xfree((void *)hostbased_chost);
  }
#line 463
  key_blob = (u_char *)((void *)0);
#line 464
  key_bloblen = 0U;
#line 465
  key_blobtype = 0;
#line 466
  hostbased_cuser = (char *)((void *)0);
#line 467
  hostbased_chost = (char *)((void *)0);
#line 468
  return;
}
}
#line 470 "monitor.c"
int mm_answer_moduli(int socket___0 , Buffer *m___0 ) 
{ DH *dh ;
  int min ;
  int want ;
  int max ;
  u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;

  {
#line 476
  tmp = buffer_get_int(m___0);
#line 476
  min = (int )tmp;
#line 477
  tmp___0 = buffer_get_int(m___0);
#line 477
  want = (int )tmp___0;
#line 478
  tmp___1 = buffer_get_int(m___0);
#line 478
  max = (int )tmp___1;
#line 480
  debug3("%s: got parameters: %d %d %d", "mm_answer_moduli", min, want, max);
#line 483
  if (max < min) {
#line 484
    fatal("%s: bad parameters: %d %d %d", "mm_answer_moduli", min, want, max);
  } else {
#line 483
    if (want < min) {
#line 484
      fatal("%s: bad parameters: %d %d %d", "mm_answer_moduli", min, want, max);
    } else {
#line 483
      if (max < want) {
#line 484
        fatal("%s: bad parameters: %d %d %d", "mm_answer_moduli", min, want, max);
      }
    }
  }
#line 487
  buffer_clear(m___0);
#line 489
  dh = choose_dh(min, want, max);
#line 490
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 491
    buffer_put_char(m___0, 0);
#line 492
    return (0);
  } else {
#line 495
    buffer_put_char(m___0, 1);
#line 496
    buffer_put_bignum2(m___0, (BIGNUM const   *)dh->p);
#line 497
    buffer_put_bignum2(m___0, (BIGNUM const   *)dh->g);
#line 499
    DH_free(dh);
  }
#line 501
  mm_request_send(socket___0, 1, m___0);
#line 502
  return (0);
}
}
#line 505 "monitor.c"
int mm_answer_sign(int socket___0 , Buffer *m___0 ) 
{ Key *key ;
  u_char *p ;
  u_char *signature ;
  u_int siglen ;
  u_int datlen ;
  int keyid ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 514
  debug3("%s", "mm_answer_sign");
#line 516
  tmp = buffer_get_int(m___0);
#line 516
  keyid = (int )tmp;
#line 517
  tmp___0 = buffer_get_string(m___0, & datlen);
#line 517
  p = (u_char *)tmp___0;
#line 519
  if (datlen != 20U) {
#line 520
    fatal("%s: data length incorrect: %u", "mm_answer_sign", datlen);
  }
#line 523
  if (session_id2_len___0 == 0U) {
#line 524
    session_id2_len___0 = datlen;
#line 525
    tmp___1 = xmalloc(session_id2_len___0);
#line 525
    session_id2___0 = (u_char *)tmp___1;
#line 526
    memcpy((void * __restrict  )session_id2___0, (void const   * __restrict  )p, session_id2_len___0);
  }
#line 529
  key = get_hostkey_by_index(keyid);
#line 529
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 530
    fatal("%s: no hostkey from index %d", "mm_answer_sign", keyid);
  }
#line 531
  tmp___2 = key_sign((Key const   *)key, & signature, & siglen, (u_char const   *)p,
                     datlen);
#line 531
  if (tmp___2 < 0) {
#line 532
    fatal("%s: key_sign failed", "mm_answer_sign");
  }
#line 534
  debug3("%s: signature %p(%u)", "mm_answer_sign", signature, siglen);
#line 536
  buffer_clear(m___0);
#line 537
  buffer_put_string(m___0, (void const   *)signature, siglen);
#line 539
  xfree((void *)p);
#line 540
  xfree((void *)signature);
#line 542
  mm_request_send(socket___0, 5, m___0);
#line 545
  monitor_permit(mon_dispatch, 6, 1);
#line 547
  return (0);
}
}
#line 552 "monitor.c"
int mm_answer_pwnamallow(int socket___0 , Buffer *m___0 ) 
{ char *login___0 ;
  struct passwd *pwent ;
  int allowed ;
  int tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 557
  allowed = 0;
#line 559
  debug3("%s", "mm_answer_pwnamallow");
#line 561
  tmp = authctxt->attempt;
#line 561
  (authctxt->attempt) ++;
#line 561
  if (tmp != 0) {
#line 562
    fatal("%s: multiple attempts for getpwnam", "mm_answer_pwnamallow");
  }
#line 564
  tmp___0 = buffer_get_string(m___0, (u_int *)((void *)0));
#line 564
  login___0 = (char *)tmp___0;
#line 566
  pwent = getpwnamallow((char const   *)login___0);
#line 568
  authctxt->user = xstrdup((char const   *)login___0);
#line 569
  if (pwent) {
#line 569
    tmp___1 = (char const   *)login___0;
  } else {
#line 569
    tmp___1 = "unknown";
  }
#line 569
  setproctitle("%s [priv]", tmp___1);
#line 570
  xfree((void *)login___0);
#line 572
  buffer_clear(m___0);
#line 574
  if ((unsigned int )pwent == (unsigned int )((void *)0)) {
#line 575
    buffer_put_char(m___0, 0);
#line 576
    authctxt->pw = fakepw();
    goto out;
  }
#line 580
  allowed = 1;
#line 581
  authctxt->pw = pwent;
#line 582
  authctxt->valid = 1;
#line 584
  buffer_put_char(m___0, 1);
#line 585
  buffer_put_string(m___0, (void const   *)pwent, sizeof(struct passwd ));
#line 586
  buffer_put_cstring(m___0, (char const   *)pwent->pw_name);
#line 587
  buffer_put_cstring(m___0, "*");
#line 588
  buffer_put_cstring(m___0, (char const   *)pwent->pw_gecos);
#line 592
  buffer_put_cstring(m___0, (char const   *)pwent->pw_dir);
#line 593
  buffer_put_cstring(m___0, (char const   *)pwent->pw_shell);
  out: 
#line 596
  debug3("%s: sending MONITOR_ANS_PWNAM: %d", "mm_answer_pwnamallow", allowed);
#line 597
  mm_request_send(socket___0, 7, m___0);
#line 600
  if (! compat20) {
#line 601
    monitor_permit_authentications(1);
  } else {
#line 604
    monitor_permit(mon_dispatch, 3, 1);
#line 605
    monitor_permit(mon_dispatch, 8, 1);
  }
#line 613
  return (0);
}
}
#line 616 "monitor.c"
int mm_answer_auth2_read_banner(int socket___0 , Buffer *m___0 ) 
{ char *banner ;
  char const   *tmp ;

  {
#line 620
  buffer_clear(m___0);
#line 621
  banner = auth2_read_banner();
#line 622
  if ((unsigned int )banner != (unsigned int )((void *)0)) {
#line 622
    tmp = (char const   *)banner;
  } else {
#line 622
    tmp = "";
  }
#line 622
  buffer_put_cstring(m___0, tmp);
#line 623
  mm_request_send(socket___0, 9, m___0);
#line 625
  if ((unsigned int )banner != (unsigned int )((void *)0)) {
#line 626
    xfree((void *)banner);
  }
#line 628
  return (0);
}
}
#line 631 "monitor.c"
int mm_answer_authserv(int socket___0 , Buffer *m___0 ) 
{ void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
#line 634
  monitor_permit_authentications(1);
#line 636
  tmp = buffer_get_string(m___0, (u_int *)((void *)0));
#line 636
  authctxt->service = (char *)tmp;
#line 637
  tmp___0 = buffer_get_string(m___0, (u_int *)((void *)0));
#line 637
  authctxt->style = (char *)tmp___0;
#line 638
  debug3("%s: service=%s, style=%s", "mm_answer_authserv", authctxt->service, authctxt->style);
#line 641
  tmp___1 = strlen((char const   *)authctxt->style);
#line 641
  if (tmp___1 == 0U) {
#line 642
    xfree((void *)authctxt->style);
#line 643
    authctxt->style = (char *)((void *)0);
  }
#line 646
  return (0);
}
}
#line 652 "monitor.c"
static int call_count  ;
#line 649 "monitor.c"
int mm_answer_authpassword(int socket___0 , Buffer *m___0 ) 
{ char *passwd ;
  int authenticated ;
  u_int plen ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
#line 657
  tmp = buffer_get_string(m___0, & plen);
#line 657
  passwd = (char *)tmp;
#line 659
  if (options.password_authentication) {
#line 659
    tmp___0 = auth_password(authctxt, (char const   *)passwd);
#line 659
    if (tmp___0) {
#line 659
      tmp___1 = 1;
    } else {
#line 659
      tmp___1 = 0;
    }
  } else {
#line 659
    tmp___1 = 0;
  }
#line 659
  authenticated = tmp___1;
#line 661
  tmp___2 = strlen((char const   *)passwd);
#line 661
  memset((void *)passwd, 0, tmp___2);
#line 662
  xfree((void *)passwd);
#line 664
  buffer_clear(m___0);
#line 665
  buffer_put_int(m___0, (unsigned int )authenticated);
#line 667
  debug3("%s: sending result %d", "mm_answer_authpassword", authenticated);
#line 668
  mm_request_send(socket___0, 11, m___0);
#line 670
  call_count ++;
#line 671
  if (plen == 0U) {
#line 671
    if (call_count == 1) {
#line 672
      auth_method = (char *)"none";
    } else {
#line 674
      auth_method = (char *)"password";
    }
  } else {
#line 674
    auth_method = (char *)"password";
  }
#line 677
  return (authenticated);
}
}
#line 917 "monitor.c"
static void mm_append_debug(Buffer *m___0 ) 
{ u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;

  {
#line 920
  if (auth_debug_init) {
#line 920
    tmp___1 = buffer_len(& auth_debug);
#line 920
    if (tmp___1) {
#line 921
      debug3("%s: Appending debug messages for child", "mm_append_debug");
#line 922
      tmp = buffer_len(& auth_debug);
#line 922
      tmp___0 = buffer_ptr(& auth_debug);
#line 922
      buffer_append(m___0, (void const   *)tmp___0, tmp);
#line 924
      buffer_clear(& auth_debug);
    }
  }
#line 926
  return;
}
}
#line 928 "monitor.c"
int mm_answer_keyallowed(int socket___0 , Buffer *m___0 ) 
{ Key *key ;
  char *cuser ;
  char *chost ;
  u_char *blob ;
  u_int bloblen ;
  enum mm_keytype type ;
  int allowed ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;

  {
#line 935
  type = (enum mm_keytype )0;
#line 936
  allowed = 0;
#line 938
  debug3("%s entering", "mm_answer_keyallowed");
#line 940
  tmp = buffer_get_int(m___0);
#line 940
  type = (enum mm_keytype )tmp;
#line 941
  tmp___0 = buffer_get_string(m___0, (u_int *)((void *)0));
#line 941
  cuser = (char *)tmp___0;
#line 942
  tmp___1 = buffer_get_string(m___0, (u_int *)((void *)0));
#line 942
  chost = (char *)tmp___1;
#line 943
  tmp___2 = buffer_get_string(m___0, & bloblen);
#line 943
  blob = (u_char *)tmp___2;
#line 945
  key = key_from_blob((u_char const   *)blob, bloblen);
#line 947
  if (compat20) {
#line 947
    if ((int )type == 3) {
#line 949
      fatal("%s: key type and protocol mismatch", "mm_answer_keyallowed");
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 947
    if (! compat20) {
#line 947
      if ((int )type != 3) {
#line 949
        fatal("%s: key type and protocol mismatch", "mm_answer_keyallowed");
      }
    }
  }
#line 951
  debug3("%s: key_from_blob: %p", "mm_answer_keyallowed", key);
#line 953
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 953
    if (authctxt->valid) {
#line 954
      switch ((int )type) {
      case 2: 
#line 956
      if (options.pubkey_authentication) {
#line 956
        tmp___3 = user_key_allowed(authctxt->pw, key);
#line 956
        if (tmp___3) {
#line 956
          tmp___4 = 1;
        } else {
#line 956
          tmp___4 = 0;
        }
      } else {
#line 956
        tmp___4 = 0;
      }
#line 956
      allowed = tmp___4;
#line 958
      break;
      case 1: 
#line 960
      if (options.hostbased_authentication) {
#line 960
        tmp___5 = hostbased_key_allowed(authctxt->pw, (char const   *)cuser, chost,
                                        key);
#line 960
        if (tmp___5) {
#line 960
          tmp___6 = 1;
        } else {
#line 960
          tmp___6 = 0;
        }
      } else {
#line 960
        tmp___6 = 0;
      }
#line 960
      allowed = tmp___6;
#line 963
      break;
      case 3: 
#line 965
      key->type = 0;
#line 966
      if (options.rhosts_rsa_authentication) {
#line 966
        tmp___7 = auth_rhosts_rsa_key_allowed(authctxt->pw, cuser, chost, key);
#line 966
        if (tmp___7) {
#line 966
          tmp___8 = 1;
        } else {
#line 966
          tmp___8 = 0;
        }
      } else {
#line 966
        tmp___8 = 0;
      }
#line 966
      allowed = tmp___8;
#line 969
      break;
      default: 
#line 971
      fatal("%s: unknown key type %d", "mm_answer_keyallowed", type);
#line 972
      break;
      }
    }
  }
#line 975
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 976
    key_free(key);
  }
#line 979
  monitor_reset_key_state();
#line 981
  if (allowed) {
#line 983
    key_blob = blob;
#line 984
    key_bloblen = bloblen;
#line 985
    key_blobtype = (int )type;
#line 986
    hostbased_cuser = cuser;
#line 987
    hostbased_chost = chost;
  }
#line 990
  if (allowed) {
#line 990
    tmp___9 = "allowed";
  } else {
#line 990
    tmp___9 = "disallowed";
  }
#line 990
  debug3("%s: key %p is %s", "mm_answer_keyallowed", key, tmp___9);
#line 993
  buffer_clear(m___0);
#line 994
  buffer_put_int(m___0, (unsigned int )allowed);
#line 995
  buffer_put_int(m___0, (unsigned int )((unsigned int )forced_command != (unsigned int )((void *)0)));
#line 997
  mm_append_debug(m___0);
#line 999
  mm_request_send(socket___0, 21, m___0);
#line 1001
  if ((int )type == 3) {
#line 1002
    monitor_permit(mon_dispatch, 33, allowed);
  }
#line 1004
  return (0);
}
}
#line 1007 "monitor.c"
static int monitor_valid_userblob(u_char *data , u_int datalen ) 
{ Buffer b ;
  char *p ;
  u_int len ;
  int fail ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___10 ;
  int tmp___13 ;
  int tmp___14 ;
  u_int l ;
  u_int tmp___15 ;
  int tmp___16 ;
  void *tmp___17 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___23 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  u_int l___0 ;
  u_int tmp___29 ;
  u_int l___1 ;
  u_int tmp___30 ;
  u_int tmp___31 ;

  {
#line 1013
  fail = 0;
#line 1015
  buffer_init(& b);
#line 1016
  buffer_append(& b, (void const   *)data, datalen);
#line 1018
  if (datafellows & 16) {
#line 1019
    tmp = buffer_ptr(& b);
#line 1019
    p = (char *)tmp;
#line 1020
    len = buffer_len(& b);
#line 1021
    if ((unsigned int )session_id2___0 == (unsigned int )((void *)0)) {
#line 1024
      fail ++;
    } else {
#line 1021
      if (len < session_id2_len___0) {
#line 1024
        fail ++;
      } else {
#line 1021
        tmp___0 = memcmp((void const   *)p, (void const   *)session_id2___0, session_id2_len___0);
#line 1021
        if (tmp___0 != 0) {
#line 1024
          fail ++;
        }
      }
    }
#line 1025
    buffer_consume(& b, session_id2_len___0);
  } else {
#line 1027
    tmp___1 = buffer_get_string(& b, & len);
#line 1027
    p = (char *)tmp___1;
#line 1028
    if ((unsigned int )session_id2___0 == (unsigned int )((void *)0)) {
#line 1031
      fail ++;
    } else {
#line 1028
      if (len != session_id2_len___0) {
#line 1031
        fail ++;
      } else {
#line 1028
        tmp___2 = memcmp((void const   *)p, (void const   *)session_id2___0, session_id2_len___0);
#line 1028
        if (tmp___2 != 0) {
#line 1031
          fail ++;
        }
      }
    }
#line 1032
    xfree((void *)p);
  }
#line 1034
  tmp___3 = buffer_get_char(& b);
#line 1034
  if (tmp___3 != 50) {
#line 1035
    fail ++;
  }
#line 1036
  tmp___4 = buffer_get_string(& b, (u_int *)((void *)0));
#line 1036
  p = (char *)tmp___4;
#line 1037
  if (0) {
#line 1037
    __s1_len = strlen((char const   *)authctxt->user);
#line 1037
    __s2_len = strlen((char const   *)p);
#line 1037
    if (! ((unsigned int )((void const   *)(authctxt->user + 1)) - (unsigned int )((void const   *)authctxt->user) == 1U)) {
      goto _L___0;
    } else {
#line 1037
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1037
        if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
#line 1037
          tmp___14 = 1;
        } else {
#line 1037
          if (__s2_len >= 4U) {
#line 1037
            tmp___14 = 1;
          } else {
#line 1037
            tmp___14 = 0;
          }
        }
      } else {
#line 1037
        tmp___14 = 0;
      }
    }
#line 1037
    if (tmp___14) {
#line 1037
      tmp___10 = __builtin_strcmp((char const   *)authctxt->user, (char const   *)p);
    } else {
#line 1037
      tmp___13 = __builtin_strcmp((char const   *)authctxt->user, (char const   *)p);
#line 1037
      tmp___10 = tmp___13;
    }
  } else {
#line 1037
    tmp___13 = __builtin_strcmp((char const   *)authctxt->user, (char const   *)p);
#line 1037
    tmp___10 = tmp___13;
  }
#line 1037
  if (tmp___10 != 0) {
#line 1038
    logit("wrong user name passed to monitor: expected %s != %.100s", authctxt->user,
          p);
#line 1040
    fail ++;
  }
#line 1042
  xfree((void *)p);
#line 1043
  while (1) {
#line 1043
    tmp___15 = buffer_get_int(& b);
#line 1043
    l = tmp___15;
#line 1043
    buffer_consume(& b, l);
#line 1043
    break;
  }
#line 1044
  if (datafellows & 32) {
#line 1045
    tmp___16 = buffer_get_char(& b);
#line 1045
    if (! tmp___16) {
#line 1046
      fail ++;
    }
  } else {
#line 1048
    tmp___17 = buffer_get_string(& b, (u_int *)((void *)0));
#line 1048
    p = (char *)tmp___17;
#line 1049
    if (0) {
#line 1049
      __s1_len___0 = strlen("publickey");
#line 1049
      __s2_len___0 = strlen((char const   *)p);
#line 1049
      if (! ((unsigned int )((void const   *)("publickey" + 1)) - (unsigned int )((void const   *)"publickey") == 1U)) {
        goto _L___2;
      } else {
#line 1049
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 1049
          if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
#line 1049
            tmp___27 = 1;
          } else {
#line 1049
            if (__s2_len___0 >= 4U) {
#line 1049
              tmp___27 = 1;
            } else {
#line 1049
              tmp___27 = 0;
            }
          }
        } else {
#line 1049
          tmp___27 = 0;
        }
      }
#line 1049
      if (tmp___27) {
#line 1049
        tmp___23 = __builtin_strcmp("publickey", (char const   *)p);
      } else {
#line 1049
        tmp___26 = __builtin_strcmp("publickey", (char const   *)p);
#line 1049
        tmp___23 = tmp___26;
      }
    } else {
#line 1049
      tmp___26 = __builtin_strcmp("publickey", (char const   *)p);
#line 1049
      tmp___23 = tmp___26;
    }
#line 1049
    if (tmp___23 != 0) {
#line 1050
      fail ++;
    }
#line 1051
    xfree((void *)p);
#line 1052
    tmp___28 = buffer_get_char(& b);
#line 1052
    if (! tmp___28) {
#line 1053
      fail ++;
    }
#line 1054
    while (1) {
#line 1054
      tmp___29 = buffer_get_int(& b);
#line 1054
      l___0 = tmp___29;
#line 1054
      buffer_consume(& b, l___0);
#line 1054
      break;
    }
  }
#line 1056
  while (1) {
#line 1056
    tmp___30 = buffer_get_int(& b);
#line 1056
    l___1 = tmp___30;
#line 1056
    buffer_consume(& b, l___1);
#line 1056
    break;
  }
#line 1057
  tmp___31 = buffer_len(& b);
#line 1057
  if (tmp___31 != 0U) {
#line 1058
    fail ++;
  }
#line 1059
  buffer_free(& b);
#line 1060
  return (fail == 0);
}
}
#line 1063 "monitor.c"
static int monitor_valid_hostbasedblob(u_char *data , u_int datalen , char *cuser ,
                                       char *chost ) 
{ Buffer b ;
  char *p ;
  u_int len ;
  int fail ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  u_int l ;
  u_int tmp___13 ;
  void *tmp___14 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  u_int l___0 ;
  u_int tmp___25 ;
  u_int l___1 ;
  u_int tmp___26 ;
  void *tmp___27 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___33 ;
  int tmp___36 ;
  int tmp___37 ;
  void *tmp___38 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;
  u_int tmp___49 ;

  {
#line 1070
  fail = 0;
#line 1072
  buffer_init(& b);
#line 1073
  buffer_append(& b, (void const   *)data, datalen);
#line 1075
  tmp = buffer_get_string(& b, & len);
#line 1075
  p = (char *)tmp;
#line 1076
  if ((unsigned int )session_id2___0 == (unsigned int )((void *)0)) {
#line 1079
    fail ++;
  } else {
#line 1076
    if (len != session_id2_len___0) {
#line 1079
      fail ++;
    } else {
#line 1076
      tmp___0 = memcmp((void const   *)p, (void const   *)session_id2___0, session_id2_len___0);
#line 1076
      if (tmp___0 != 0) {
#line 1079
        fail ++;
      }
    }
  }
#line 1080
  xfree((void *)p);
#line 1082
  tmp___1 = buffer_get_char(& b);
#line 1082
  if (tmp___1 != 50) {
#line 1083
    fail ++;
  }
#line 1084
  tmp___2 = buffer_get_string(& b, (u_int *)((void *)0));
#line 1084
  p = (char *)tmp___2;
#line 1085
  if (0) {
#line 1085
    __s1_len = strlen((char const   *)authctxt->user);
#line 1085
    __s2_len = strlen((char const   *)p);
#line 1085
    if (! ((unsigned int )((void const   *)(authctxt->user + 1)) - (unsigned int )((void const   *)authctxt->user) == 1U)) {
      goto _L___0;
    } else {
#line 1085
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1085
        if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
#line 1085
          tmp___12 = 1;
        } else {
#line 1085
          if (__s2_len >= 4U) {
#line 1085
            tmp___12 = 1;
          } else {
#line 1085
            tmp___12 = 0;
          }
        }
      } else {
#line 1085
        tmp___12 = 0;
      }
    }
#line 1085
    if (tmp___12) {
#line 1085
      tmp___8 = __builtin_strcmp((char const   *)authctxt->user, (char const   *)p);
    } else {
#line 1085
      tmp___11 = __builtin_strcmp((char const   *)authctxt->user, (char const   *)p);
#line 1085
      tmp___8 = tmp___11;
    }
  } else {
#line 1085
    tmp___11 = __builtin_strcmp((char const   *)authctxt->user, (char const   *)p);
#line 1085
    tmp___8 = tmp___11;
  }
#line 1085
  if (tmp___8 != 0) {
#line 1086
    logit("wrong user name passed to monitor: expected %s != %.100s", authctxt->user,
          p);
#line 1088
    fail ++;
  }
#line 1090
  xfree((void *)p);
#line 1091
  while (1) {
#line 1091
    tmp___13 = buffer_get_int(& b);
#line 1091
    l = tmp___13;
#line 1091
    buffer_consume(& b, l);
#line 1091
    break;
  }
#line 1092
  tmp___14 = buffer_get_string(& b, (u_int *)((void *)0));
#line 1092
  p = (char *)tmp___14;
#line 1093
  if (0) {
#line 1093
    __s1_len___0 = strlen((char const   *)p);
#line 1093
    __s2_len___0 = strlen("hostbased");
#line 1093
    if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
      goto _L___2;
    } else {
#line 1093
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 1093
        if (! ((unsigned int )((void const   *)("hostbased" + 1)) - (unsigned int )((void const   *)"hostbased") == 1U)) {
#line 1093
          tmp___24 = 1;
        } else {
#line 1093
          if (__s2_len___0 >= 4U) {
#line 1093
            tmp___24 = 1;
          } else {
#line 1093
            tmp___24 = 0;
          }
        }
      } else {
#line 1093
        tmp___24 = 0;
      }
    }
#line 1093
    if (tmp___24) {
#line 1093
      tmp___20 = __builtin_strcmp((char const   *)p, "hostbased");
    } else {
#line 1093
      tmp___23 = __builtin_strcmp((char const   *)p, "hostbased");
#line 1093
      tmp___20 = tmp___23;
    }
  } else {
#line 1093
    tmp___23 = __builtin_strcmp((char const   *)p, "hostbased");
#line 1093
    tmp___20 = tmp___23;
  }
#line 1093
  if (tmp___20 != 0) {
#line 1094
    fail ++;
  }
#line 1095
  xfree((void *)p);
#line 1096
  while (1) {
#line 1096
    tmp___25 = buffer_get_int(& b);
#line 1096
    l___0 = tmp___25;
#line 1096
    buffer_consume(& b, l___0);
#line 1096
    break;
  }
#line 1097
  while (1) {
#line 1097
    tmp___26 = buffer_get_int(& b);
#line 1097
    l___1 = tmp___26;
#line 1097
    buffer_consume(& b, l___1);
#line 1097
    break;
  }
#line 1100
  tmp___27 = buffer_get_string(& b, (u_int *)((void *)0));
#line 1100
  p = (char *)tmp___27;
#line 1101
  len = strlen((char const   *)p);
#line 1101
  if (len > 0U) {
#line 1101
    if ((int )*(p + (len - 1U)) == 46) {
#line 1102
      *(p + (len - 1U)) = (char )'\000';
    }
  }
#line 1103
  if (0) {
#line 1103
    __s1_len___1 = strlen((char const   *)p);
#line 1103
    __s2_len___1 = strlen((char const   *)chost);
#line 1103
    if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
      goto _L___4;
    } else {
#line 1103
      if (__s1_len___1 >= 4U) {
        _L___4: /* CIL Label */ 
#line 1103
        if (! ((unsigned int )((void const   *)(chost + 1)) - (unsigned int )((void const   *)chost) == 1U)) {
#line 1103
          tmp___37 = 1;
        } else {
#line 1103
          if (__s2_len___1 >= 4U) {
#line 1103
            tmp___37 = 1;
          } else {
#line 1103
            tmp___37 = 0;
          }
        }
      } else {
#line 1103
        tmp___37 = 0;
      }
    }
#line 1103
    if (tmp___37) {
#line 1103
      tmp___33 = __builtin_strcmp((char const   *)p, (char const   *)chost);
    } else {
#line 1103
      tmp___36 = __builtin_strcmp((char const   *)p, (char const   *)chost);
#line 1103
      tmp___33 = tmp___36;
    }
  } else {
#line 1103
    tmp___36 = __builtin_strcmp((char const   *)p, (char const   *)chost);
#line 1103
    tmp___33 = tmp___36;
  }
#line 1103
  if (tmp___33 != 0) {
#line 1104
    fail ++;
  }
#line 1105
  xfree((void *)p);
#line 1108
  tmp___38 = buffer_get_string(& b, (u_int *)((void *)0));
#line 1108
  p = (char *)tmp___38;
#line 1109
  if (0) {
#line 1109
    __s1_len___2 = strlen((char const   *)p);
#line 1109
    __s2_len___2 = strlen((char const   *)cuser);
#line 1109
    if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
      goto _L___6;
    } else {
#line 1109
      if (__s1_len___2 >= 4U) {
        _L___6: /* CIL Label */ 
#line 1109
        if (! ((unsigned int )((void const   *)(cuser + 1)) - (unsigned int )((void const   *)cuser) == 1U)) {
#line 1109
          tmp___48 = 1;
        } else {
#line 1109
          if (__s2_len___2 >= 4U) {
#line 1109
            tmp___48 = 1;
          } else {
#line 1109
            tmp___48 = 0;
          }
        }
      } else {
#line 1109
        tmp___48 = 0;
      }
    }
#line 1109
    if (tmp___48) {
#line 1109
      tmp___44 = __builtin_strcmp((char const   *)p, (char const   *)cuser);
    } else {
#line 1109
      tmp___47 = __builtin_strcmp((char const   *)p, (char const   *)cuser);
#line 1109
      tmp___44 = tmp___47;
    }
  } else {
#line 1109
    tmp___47 = __builtin_strcmp((char const   *)p, (char const   *)cuser);
#line 1109
    tmp___44 = tmp___47;
  }
#line 1109
  if (tmp___44 != 0) {
#line 1110
    fail ++;
  }
#line 1111
  xfree((void *)p);
#line 1113
  tmp___49 = buffer_len(& b);
#line 1113
  if (tmp___49 != 0U) {
#line 1114
    fail ++;
  }
#line 1115
  buffer_free(& b);
#line 1116
  return (fail == 0);
}
}
#line 1119 "monitor.c"
int mm_answer_keyverify(int socket___0 , Buffer *m___0 ) 
{ Key *key ;
  u_char *signature ;
  u_char *data ;
  u_char *blob ;
  u_int signaturelen ;
  u_int datalen ;
  u_int bloblen ;
  int verified ;
  int valid_data ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;

  {
#line 1125
  verified = 0;
#line 1126
  valid_data = 0;
#line 1128
  tmp = buffer_get_string(m___0, & bloblen);
#line 1128
  blob = (u_char *)tmp;
#line 1129
  tmp___0 = buffer_get_string(m___0, & signaturelen);
#line 1129
  signature = (u_char *)tmp___0;
#line 1130
  tmp___1 = buffer_get_string(m___0, & datalen);
#line 1130
  data = (u_char *)tmp___1;
#line 1132
  if ((unsigned int )hostbased_cuser == (unsigned int )((void *)0)) {
#line 1134
    fatal("%s: bad key, not previously allowed", "mm_answer_keyverify");
  } else {
#line 1132
    if ((unsigned int )hostbased_chost == (unsigned int )((void *)0)) {
#line 1134
      fatal("%s: bad key, not previously allowed", "mm_answer_keyverify");
    } else {
#line 1132
      tmp___2 = monitor_allowed_key(blob, bloblen);
#line 1132
      if (! tmp___2) {
#line 1134
        fatal("%s: bad key, not previously allowed", "mm_answer_keyverify");
      }
    }
  }
#line 1136
  key = key_from_blob((u_char const   *)blob, bloblen);
#line 1137
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 1138
    fatal("%s: bad public key blob", "mm_answer_keyverify");
  }
#line 1140
  switch (key_blobtype) {
  case 2: 
#line 1142
  valid_data = monitor_valid_userblob(data, datalen);
#line 1143
  break;
  case 1: 
#line 1145
  valid_data = monitor_valid_hostbasedblob(data, datalen, hostbased_cuser, hostbased_chost);
#line 1147
  break;
  default: 
#line 1149
  valid_data = 0;
#line 1150
  break;
  }
#line 1152
  if (! valid_data) {
#line 1153
    fatal("%s: bad signature data blob", "mm_answer_keyverify");
  }
#line 1155
  verified = key_verify((Key const   *)key, (u_char const   *)signature, signaturelen,
                        (u_char const   *)data, datalen);
#line 1156
  if (verified) {
#line 1156
    tmp___3 = "verified";
  } else {
#line 1156
    tmp___3 = "unverified";
  }
#line 1156
  debug3("%s: key %p signature %s", "mm_answer_keyverify", key, tmp___3);
#line 1159
  key_free(key);
#line 1160
  xfree((void *)blob);
#line 1161
  xfree((void *)signature);
#line 1162
  xfree((void *)data);
#line 1164
  if (key_blobtype == 2) {
#line 1164
    auth_method = (char *)"publickey";
  } else {
#line 1164
    auth_method = (char *)"hostbased";
  }
#line 1166
  monitor_reset_key_state();
#line 1168
  buffer_clear(m___0);
#line 1169
  buffer_put_int(m___0, (unsigned int )verified);
#line 1170
  mm_request_send(socket___0, 23, m___0);
#line 1172
  return (verified);
}
}
#line 1175 "monitor.c"
static void mm_record_login(Session *s , struct passwd *pw ) 
{ socklen_t fromlen ;
  struct sockaddr_storage from ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;

  {
#line 1185
  memset((void *)(& from), 0, sizeof(from));
#line 1186
  fromlen = sizeof(from);
#line 1187
  tmp___3 = packet_connection_is_on_socket();
#line 1187
  if (tmp___3) {
#line 1188
    tmp___1 = packet_get_connection_in();
#line 1188
    tmp___2 = getpeername(tmp___1, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 1188
    if (tmp___2 < 0) {
#line 1190
      tmp = __errno_location();
#line 1190
      tmp___0 = strerror(*tmp);
#line 1190
      debug("getpeername: %.100s", tmp___0);
#line 1191
      cleanup_exit(255);
    }
  }
#line 1195
  tmp___4 = get_remote_name_or_ip(utmp_len, options.use_dns);
#line 1195
  record_login(s->pid, (char const   *)(s->tty), (char const   *)pw->pw_name, pw->pw_uid,
               tmp___4, (struct sockaddr *)(& from), fromlen);
#line 1198
  return;
}
}
#line 1200 "monitor.c"
static void mm_session_close(Session *s ) 
{ 

  {
#line 1203
  debug3("%s: session %d pid %ld", "mm_session_close", s->self, (long )s->pid);
#line 1204
  if (s->ttyfd != -1) {
#line 1205
    debug3("%s: tty %s ptyfd %d", "mm_session_close", s->tty, s->ptyfd);
#line 1206
    session_pty_cleanup2(s);
  }
#line 1208
  s->used = 0;
#line 1209
  return;
}
}
#line 1211 "monitor.c"
int mm_answer_pty(int socket___0 , Buffer *m___0 ) 
{ Session *s ;
  int res ;
  int fd0 ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 1218
  debug3("%s entering", "mm_answer_pty");
#line 1220
  buffer_clear(m___0);
#line 1221
  s = session_new();
#line 1222
  if ((unsigned int )s == (unsigned int )((void *)0)) {
    goto error;
  }
#line 1224
  s->authctxt = authctxt;
#line 1225
  s->pw = authctxt->pw;
#line 1226
  s->pid = pmonitor->m_pid;
#line 1227
  res = pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, (int )sizeof(s->tty));
#line 1228
  if (res == 0) {
    goto error;
  }
#line 1230
  pty_setowner(authctxt->pw, (char const   *)(s->tty));
#line 1232
  buffer_put_int(m___0, 1U);
#line 1233
  buffer_put_cstring(m___0, (char const   *)(s->tty));
#line 1234
  mm_request_send(socket___0, 26, m___0);
#line 1236
  mm_send_fd(socket___0, s->ptyfd);
#line 1237
  mm_send_fd(socket___0, s->ttyfd);
#line 1240
  tmp = dup2(s->ttyfd, 0);
#line 1240
  if (tmp == -1) {
#line 1241
    fatal("%s: dup2", "mm_answer_pty");
  }
#line 1243
  mm_record_login(s, authctxt->pw);
#line 1246
  close(0);
#line 1249
  fd0 = open("/dev/null", 0);
#line 1249
  if (fd0 < 0) {
#line 1250
    tmp___0 = __errno_location();
#line 1250
    tmp___1 = strerror(*tmp___0);
#line 1250
    fatal("%s: open(/dev/null): %s", "mm_answer_pty", tmp___1);
  }
#line 1251
  if (fd0 != 0) {
#line 1252
    error("%s: fd0 %d != 0", "mm_answer_pty", fd0);
  }
#line 1255
  close(s->ttyfd);
#line 1256
  s->ttyfd = s->ptyfd;
#line 1258
  s->ptymaster = s->ptyfd;
#line 1260
  debug3("%s: tty %s ptyfd %d", "mm_answer_pty", s->tty, s->ttyfd);
#line 1262
  return (0);
  error: 
#line 1265
  if ((unsigned int )s != (unsigned int )((void *)0)) {
#line 1266
    mm_session_close(s);
  }
#line 1267
  buffer_put_int(m___0, 0U);
#line 1268
  mm_request_send(socket___0, 26, m___0);
#line 1269
  return (0);
}
}
#line 1272 "monitor.c"
int mm_answer_pty_cleanup(int socket___0 , Buffer *m___0 ) 
{ Session *s ;
  char *tty ;
  void *tmp ;

  {
#line 1278
  debug3("%s entering", "mm_answer_pty_cleanup");
#line 1280
  tmp = buffer_get_string(m___0, (u_int *)((void *)0));
#line 1280
  tty = (char *)tmp;
#line 1281
  s = session_by_tty(tty);
#line 1281
  if ((unsigned int )s != (unsigned int )((void *)0)) {
#line 1282
    mm_session_close(s);
  }
#line 1283
  buffer_clear(m___0);
#line 1284
  xfree((void *)tty);
#line 1285
  return (0);
}
}
#line 1288 "monitor.c"
int mm_answer_sesskey(int socket___0 , Buffer *m___0 ) 
{ BIGNUM *p ;
  int rsafail ;

  {
#line 1295
  monitor_permit(mon_dispatch, 28, 1);
#line 1297
  p = BN_new();
#line 1297
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 1298
    fatal("%s: BN_new", "mm_answer_sesskey");
  }
#line 1300
  buffer_get_bignum2(m___0, p);
#line 1302
  rsafail = ssh1_session_key(p);
#line 1304
  buffer_clear(m___0);
#line 1305
  buffer_put_int(m___0, (unsigned int )rsafail);
#line 1306
  buffer_put_bignum2(m___0, (BIGNUM const   *)p);
#line 1308
  BN_clear_free(p);
#line 1310
  mm_request_send(socket___0, 29, m___0);
#line 1313
  monitor_permit(mon_dispatch, 30, 1);
#line 1315
  return (0);
}
}
#line 1318 "monitor.c"
int mm_answer_sessid(int socket___0 , Buffer *m___0 ) 
{ int i ;
  u_int tmp ;
  int tmp___0 ;

  {
#line 1323
  debug3("%s entering", "mm_answer_sessid");
#line 1325
  tmp = buffer_len(m___0);
#line 1325
  if (tmp != 16U) {
#line 1326
    fatal("%s: bad ssh1 session id", "mm_answer_sessid");
  }
#line 1327
  i = 0;
#line 1327
  while (i < 16) {
#line 1328
    tmp___0 = buffer_get_char(m___0);
#line 1328
    session_id[i] = (unsigned char )tmp___0;
#line 1327
    i ++;
  }
#line 1331
  monitor_permit(mon_dispatch, 6, 1);
#line 1333
  return (0);
}
}
#line 1336 "monitor.c"
int mm_answer_rsa_keyallowed(int socket___0 , Buffer *m___0 ) 
{ BIGNUM *client_n ;
  Key *key ;
  u_char *blob ;
  u_int blen ;
  int allowed ;
  int tmp ;

  {
#line 1340
  key = (Key *)((void *)0);
#line 1341
  blob = (u_char *)((void *)0);
#line 1342
  blen = (u_int )0;
#line 1343
  allowed = 0;
#line 1345
  debug3("%s entering", "mm_answer_rsa_keyallowed");
#line 1347
  if (options.rsa_authentication) {
#line 1347
    if (authctxt->valid) {
#line 1348
      client_n = BN_new();
#line 1348
      if ((unsigned int )client_n == (unsigned int )((void *)0)) {
#line 1349
        fatal("%s: BN_new", "mm_answer_rsa_keyallowed");
      }
#line 1350
      buffer_get_bignum2(m___0, client_n);
#line 1351
      allowed = auth_rsa_key_allowed(authctxt->pw, client_n, & key);
#line 1352
      BN_clear_free(client_n);
    }
  }
#line 1354
  buffer_clear(m___0);
#line 1355
  buffer_put_int(m___0, (unsigned int )allowed);
#line 1356
  buffer_put_int(m___0, (unsigned int )((unsigned int )forced_command != (unsigned int )((void *)0)));
#line 1359
  monitor_reset_key_state();
#line 1361
  if (allowed) {
#line 1361
    if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 1362
      key->type = 1;
#line 1363
      tmp = key_to_blob((Key const   *)key, & blob, & blen);
#line 1363
      if (tmp == 0) {
#line 1364
        fatal("%s: key_to_blob failed", "mm_answer_rsa_keyallowed");
      }
#line 1365
      buffer_put_string(m___0, (void const   *)blob, blen);
#line 1368
      key_blob = blob;
#line 1369
      key_bloblen = blen;
#line 1370
      key_blobtype = 4;
    }
  }
#line 1372
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 1373
    key_free(key);
  }
#line 1375
  mm_append_debug(m___0);
#line 1377
  mm_request_send(socket___0, 32, m___0);
#line 1379
  monitor_permit(mon_dispatch, 33, allowed);
#line 1380
  monitor_permit(mon_dispatch, 35, 0);
#line 1381
  return (0);
}
}
#line 1384 "monitor.c"
int mm_answer_rsa_challenge(int socket___0 , Buffer *m___0 ) 
{ Key *key ;
  u_char *blob ;
  u_int blen ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1387
  key = (Key *)((void *)0);
#line 1391
  debug3("%s entering", "mm_answer_rsa_challenge");
#line 1393
  if (! authctxt->valid) {
#line 1394
    fatal("%s: authctxt not valid", "mm_answer_rsa_challenge");
  }
#line 1395
  tmp = buffer_get_string(m___0, & blen);
#line 1395
  blob = (u_char *)tmp;
#line 1396
  tmp___0 = monitor_allowed_key(blob, blen);
#line 1396
  if (! tmp___0) {
#line 1397
    fatal("%s: bad key, not previously allowed", "mm_answer_rsa_challenge");
  }
#line 1398
  if (key_blobtype != 4) {
#line 1398
    if (key_blobtype != 3) {
#line 1399
      fatal("%s: key type mismatch", "mm_answer_rsa_challenge");
    }
  }
#line 1400
  key = key_from_blob((u_char const   *)blob, blen);
#line 1400
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 1401
    fatal("%s: received bad key", "mm_answer_rsa_challenge");
  }
#line 1403
  if (ssh1_challenge) {
#line 1404
    BN_clear_free(ssh1_challenge);
  }
#line 1405
  ssh1_challenge = auth_rsa_generate_challenge(key);
#line 1407
  buffer_clear(m___0);
#line 1408
  buffer_put_bignum2(m___0, (BIGNUM const   *)ssh1_challenge);
#line 1410
  debug3("%s sending reply", "mm_answer_rsa_challenge");
#line 1411
  mm_request_send(socket___0, 34, m___0);
#line 1413
  monitor_permit(mon_dispatch, 35, 1);
#line 1415
  xfree((void *)blob);
#line 1416
  key_free(key);
#line 1417
  return (0);
}
}
#line 1420 "monitor.c"
int mm_answer_rsa_response(int socket___0 , Buffer *m___0 ) 
{ Key *key ;
  u_char *blob ;
  u_char *response ;
  u_int blen ;
  u_int len ;
  int success ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 1423
  key = (Key *)((void *)0);
#line 1428
  debug3("%s entering", "mm_answer_rsa_response");
#line 1430
  if (! authctxt->valid) {
#line 1431
    fatal("%s: authctxt not valid", "mm_answer_rsa_response");
  }
#line 1432
  if ((unsigned int )ssh1_challenge == (unsigned int )((void *)0)) {
#line 1433
    fatal("%s: no ssh1_challenge", "mm_answer_rsa_response");
  }
#line 1435
  tmp = buffer_get_string(m___0, & blen);
#line 1435
  blob = (u_char *)tmp;
#line 1436
  tmp___0 = monitor_allowed_key(blob, blen);
#line 1436
  if (! tmp___0) {
#line 1437
    fatal("%s: bad key, not previously allowed", "mm_answer_rsa_response");
  }
#line 1438
  if (key_blobtype != 4) {
#line 1438
    if (key_blobtype != 3) {
#line 1439
      fatal("%s: key type mismatch: %d", "mm_answer_rsa_response", key_blobtype);
    }
  }
#line 1440
  key = key_from_blob((u_char const   *)blob, blen);
#line 1440
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 1441
    fatal("%s: received bad key", "mm_answer_rsa_response");
  }
#line 1442
  tmp___1 = buffer_get_string(m___0, & len);
#line 1442
  response = (u_char *)tmp___1;
#line 1443
  if (len != 16U) {
#line 1444
    fatal("%s: received bad response to challenge", "mm_answer_rsa_response");
  }
#line 1445
  success = auth_rsa_verify_response(key, ssh1_challenge, response);
#line 1447
  xfree((void *)blob);
#line 1448
  key_free(key);
#line 1449
  xfree((void *)response);
#line 1451
  if (key_blobtype == 4) {
#line 1451
    auth_method = (char *)"rsa";
  } else {
#line 1451
    auth_method = (char *)"rhosts-rsa";
  }
#line 1454
  BN_clear_free(ssh1_challenge);
#line 1455
  ssh1_challenge = (BIGNUM *)((void *)0);
#line 1456
  monitor_reset_key_state();
#line 1458
  buffer_clear(m___0);
#line 1459
  buffer_put_int(m___0, (unsigned int )success);
#line 1460
  mm_request_send(socket___0, 36, m___0);
#line 1462
  return (success);
}
}
#line 1465 "monitor.c"
int mm_answer_term(int socket___0 , Buffer *req ) 
{ int res ;
  int status ;
  int *tmp ;
  __pid_t tmp___0 ;
  union __anonunion_83___0 __constr_expr_2 ;
  union __anonunion_84___0 __constr_expr_3 ;

  {
#line 1471
  debug3("%s: tearing down sessions", "mm_answer_term");
#line 1474
  session_destroy_all(& mm_session_close);
#line 1476
  while (1) {
#line 1476
    tmp___0 = waitpid(pmonitor->m_pid, & status, 0);
#line 1476
    if (! (tmp___0 == -1)) {
#line 1476
      break;
    }
#line 1477
    tmp = __errno_location();
#line 1477
    if (*tmp != 4) {
#line 1478
      exit(1);
    }
  }
#line 1480
  __constr_expr_3.__in = status;
#line 1480
  if ((__constr_expr_3.__i & 127) == 0) {
#line 1480
    __constr_expr_2.__in = status;
#line 1480
    res = (__constr_expr_2.__i & 65280) >> 8;
  } else {
#line 1480
    res = 1;
  }
#line 1483
  exit(res);
}
}
#line 1486 "monitor.c"
void monitor_apply_keystate(struct monitor *pmonitor___0 ) 
{ 

  {
#line 1489
  if (compat20) {
#line 1490
    set_newkeys(0);
#line 1491
    set_newkeys(1);
  } else {
#line 1493
    packet_set_protocol_flags((unsigned int )child_state.ssh1protoflags);
#line 1494
    packet_set_encryption_key((u_char const   *)child_state.ssh1key, child_state.ssh1keylen,
                              child_state.ssh1cipher);
#line 1496
    xfree((void *)child_state.ssh1key);
  }
#line 1500
  packet_set_keycontext(1, child_state.keyout);
#line 1501
  xfree((void *)child_state.keyout);
#line 1502
  packet_set_keycontext(0, child_state.keyin);
#line 1503
  xfree((void *)child_state.keyin);
#line 1505
  if (! compat20) {
#line 1506
    packet_set_iv(1, child_state.ivout);
#line 1507
    xfree((void *)child_state.ivout);
#line 1508
    packet_set_iv(0, child_state.ivin);
#line 1509
    xfree((void *)child_state.ivin);
  }
#line 1512
  memcpy((void * __restrict  )(& incoming_stream), (void const   * __restrict  )(& child_state.incoming),
         sizeof(incoming_stream));
#line 1514
  memcpy((void * __restrict  )(& outgoing_stream), (void const   * __restrict  )(& child_state.outgoing),
         sizeof(outgoing_stream));
#line 1518
  if (options.compression) {
#line 1519
    mm_init_compression(pmonitor___0->m_zlib);
  }
#line 1523
  buffer_clear(& input);
#line 1524
  buffer_append(& input, (void const   *)child_state.input, child_state.ilen);
#line 1525
  memset((void *)child_state.input, 0, child_state.ilen);
#line 1526
  xfree((void *)child_state.input);
#line 1528
  buffer_clear(& output);
#line 1529
  buffer_append(& output, (void const   *)child_state.output, child_state.olen);
#line 1530
  memset((void *)child_state.output, 0, child_state.olen);
#line 1531
  xfree((void *)child_state.output);
#line 1532
  return;
}
}
#line 1534 "monitor.c"
static Kex *mm_get_kex(Buffer *m___0 ) 
{ Kex *kex ;
  void *blob ;
  u_int bloblen ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
#line 1541
  tmp = xmalloc(sizeof(*kex));
#line 1541
  kex = (Kex *)tmp;
#line 1542
  memset((void *)kex, 0, sizeof(*kex));
#line 1543
  tmp___0 = buffer_get_string(m___0, & kex->session_id_len);
#line 1543
  kex->session_id = (u_char *)tmp___0;
#line 1544
  if ((unsigned int )session_id2___0 == (unsigned int )((void *)0)) {
#line 1547
    fatal("mm_get_get: internal error: bad session id");
  } else {
#line 1544
    if (kex->session_id_len != session_id2_len___0) {
#line 1547
      fatal("mm_get_get: internal error: bad session id");
    } else {
#line 1544
      tmp___1 = memcmp((void const   *)kex->session_id, (void const   *)session_id2___0,
                       session_id2_len___0);
#line 1544
      if (tmp___1 != 0) {
#line 1547
        fatal("mm_get_get: internal error: bad session id");
      }
    }
  }
#line 1548
  tmp___2 = buffer_get_int(m___0);
#line 1548
  kex->we_need = (int )tmp___2;
#line 1549
  kex->kex[0] = & kexdh_server;
#line 1550
  kex->kex[1] = & kexgex_server;
#line 1551
  kex->server = 1;
#line 1552
  tmp___3 = buffer_get_int(m___0);
#line 1552
  kex->hostkey_type = (int )tmp___3;
#line 1553
  tmp___4 = buffer_get_int(m___0);
#line 1553
  kex->kex_type = (int )tmp___4;
#line 1554
  blob = buffer_get_string(m___0, & bloblen);
#line 1555
  buffer_init(& kex->my);
#line 1556
  buffer_append(& kex->my, (void const   *)blob, bloblen);
#line 1557
  xfree(blob);
#line 1558
  blob = buffer_get_string(m___0, & bloblen);
#line 1559
  buffer_init(& kex->peer);
#line 1560
  buffer_append(& kex->peer, (void const   *)blob, bloblen);
#line 1561
  xfree(blob);
#line 1562
  kex->done = 1;
#line 1563
  tmp___5 = buffer_get_int(m___0);
#line 1563
  kex->flags = (int )tmp___5;
#line 1564
  tmp___6 = buffer_get_string(m___0, (u_int *)((void *)0));
#line 1564
  kex->client_version_string = (char *)tmp___6;
#line 1565
  tmp___7 = buffer_get_string(m___0, (u_int *)((void *)0));
#line 1565
  kex->server_version_string = (char *)tmp___7;
#line 1566
  kex->load_host_key = & get_hostkey_by_type;
#line 1567
  kex->host_key_index = & get_hostkey_index;
#line 1569
  return (kex);
}
}
#line 1574 "monitor.c"
void mm_get_keystate(struct monitor *pmonitor___0 ) 
{ Buffer m___0 ;
  u_char *blob ;
  u_char *p ;
  u_int bloblen ;
  u_int plen ;
  u_int32_t seqnr ;
  u_int32_t packets ;
  u_int64_t blocks ;
  u_int tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;

  {
#line 1583
  debug3("%s: Waiting for new keys", "mm_get_keystate");
#line 1585
  buffer_init(& m___0);
#line 1586
  mm_request_receive_expect(pmonitor___0->m_sendfd, 24, & m___0);
#line 1587
  if (! compat20) {
#line 1588
    tmp = buffer_get_int(& m___0);
#line 1588
    child_state.ssh1protoflags = (int )tmp;
#line 1589
    tmp___0 = buffer_get_int(& m___0);
#line 1589
    child_state.ssh1cipher = (int )tmp___0;
#line 1590
    tmp___1 = buffer_get_string(& m___0, & child_state.ssh1keylen);
#line 1590
    child_state.ssh1key = (u_char *)tmp___1;
#line 1592
    tmp___2 = buffer_get_string(& m___0, & child_state.ivoutlen);
#line 1592
    child_state.ivout = (u_char *)tmp___2;
#line 1594
    tmp___3 = buffer_get_string(& m___0, & child_state.ivinlen);
#line 1594
    child_state.ivin = (u_char *)tmp___3;
    goto skip;
  } else {
#line 1598
    *(pmonitor___0->m_pkex) = mm_get_kex(& m___0);
  }
#line 1601
  tmp___4 = buffer_get_string(& m___0, & bloblen);
#line 1601
  blob = (u_char *)tmp___4;
#line 1602
  current_keys[1] = mm_newkeys_from_blob(blob, (int )bloblen);
#line 1603
  xfree((void *)blob);
#line 1605
  debug3("%s: Waiting for second key", "mm_get_keystate");
#line 1606
  tmp___5 = buffer_get_string(& m___0, & bloblen);
#line 1606
  blob = (u_char *)tmp___5;
#line 1607
  current_keys[0] = mm_newkeys_from_blob(blob, (int )bloblen);
#line 1608
  xfree((void *)blob);
#line 1611
  seqnr = buffer_get_int(& m___0);
#line 1612
  blocks = buffer_get_int64(& m___0);
#line 1613
  packets = buffer_get_int(& m___0);
#line 1614
  packet_set_state(1, seqnr, blocks, packets);
#line 1615
  seqnr = buffer_get_int(& m___0);
#line 1616
  blocks = buffer_get_int64(& m___0);
#line 1617
  packets = buffer_get_int(& m___0);
#line 1618
  packet_set_state(0, seqnr, blocks, packets);
  skip: 
#line 1622
  tmp___6 = buffer_get_string(& m___0, & child_state.keyoutlen);
#line 1622
  child_state.keyout = (u_char *)tmp___6;
#line 1623
  tmp___7 = buffer_get_string(& m___0, & child_state.keyinlen);
#line 1623
  child_state.keyin = (u_char *)tmp___7;
#line 1625
  debug3("%s: Getting compression state", "mm_get_keystate");
#line 1627
  tmp___8 = buffer_get_string(& m___0, & plen);
#line 1627
  p = (u_char *)tmp___8;
#line 1628
  if (plen != sizeof(child_state.outgoing)) {
#line 1629
    fatal("%s: bad request size", "mm_get_keystate");
  }
#line 1630
  memcpy((void * __restrict  )(& child_state.outgoing), (void const   * __restrict  )p,
         sizeof(child_state.outgoing));
#line 1631
  xfree((void *)p);
#line 1633
  tmp___9 = buffer_get_string(& m___0, & plen);
#line 1633
  p = (u_char *)tmp___9;
#line 1634
  if (plen != sizeof(child_state.incoming)) {
#line 1635
    fatal("%s: bad request size", "mm_get_keystate");
  }
#line 1636
  memcpy((void * __restrict  )(& child_state.incoming), (void const   * __restrict  )p,
         sizeof(child_state.incoming));
#line 1637
  xfree((void *)p);
#line 1640
  debug3("%s: Getting Network I/O buffers", "mm_get_keystate");
#line 1641
  tmp___10 = buffer_get_string(& m___0, & child_state.ilen);
#line 1641
  child_state.input = (u_char *)tmp___10;
#line 1642
  tmp___11 = buffer_get_string(& m___0, & child_state.olen);
#line 1642
  child_state.output = (u_char *)tmp___11;
#line 1644
  buffer_free(& m___0);
#line 1645
  return;
}
}
#line 1649 "monitor.c"
void *mm_zalloc(struct mm_master *mm , u_int ncount , u_int size ) 
{ size_t len ;
  void *address ;

  {
#line 1652
  len = size * ncount;
#line 1655
  if (len == 0U) {
#line 1656
    fatal("%s: mm_zalloc(%u, %u)", "mm_zalloc", ncount, size);
  } else {
#line 1655
    if ((unsigned long )ncount > 4294967295UL / (unsigned long )size) {
#line 1656
      fatal("%s: mm_zalloc(%u, %u)", "mm_zalloc", ncount, size);
    }
  }
#line 1658
  address = mm_malloc(mm, len);
#line 1660
  return (address);
}
}
#line 1663 "monitor.c"
void mm_zfree(struct mm_master *mm , void *address ) 
{ 

  {
#line 1666
  mm_free(mm, address);
#line 1667
  return;
}
}
#line 1669 "monitor.c"
void mm_init_compression(struct mm_master *mm ) 
{ 

  {
#line 1672
  outgoing_stream.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))(& mm_zalloc);
#line 1673
  outgoing_stream.zfree = (void (*)(voidpf opaque , voidpf address ))(& mm_zfree);
#line 1674
  outgoing_stream.opaque = (void *)mm;
#line 1676
  incoming_stream.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))(& mm_zalloc);
#line 1677
  incoming_stream.zfree = (void (*)(voidpf opaque , voidpf address ))(& mm_zfree);
#line 1678
  incoming_stream.opaque = (void *)mm;
#line 1679
  return;
}
}
#line 1688 "monitor.c"
static void monitor_socketpair(int *pair ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1692
  tmp = socketpair(1, 1, 0, (int *)pair);
#line 1692
  if (tmp == -1) {
#line 1693
    fatal("%s: socketpair", "monitor_socketpair");
  }
#line 1698
  while (1) {
#line 1698
    tmp___0 = fcntl(*(pair + 0), 2, 1);
#line 1698
    if (tmp___0 == -1) {
#line 1698
      fatal("fcntl(%d, F_SETFD)", *(pair + 0));
    }
#line 1698
    break;
  }
#line 1699
  while (1) {
#line 1699
    tmp___1 = fcntl(*(pair + 1), 2, 1);
#line 1699
    if (tmp___1 == -1) {
#line 1699
      fatal("fcntl(%d, F_SETFD)", *(pair + 1));
    }
#line 1699
    break;
  }
#line 1700
  return;
}
}
#line 1704 "monitor.c"
struct monitor *monitor_init(void) 
{ struct monitor *mon ;
  int pair[2] ;
  void *tmp ;

  {
#line 1710
  tmp = xmalloc(sizeof(*mon));
#line 1710
  mon = (struct monitor *)tmp;
#line 1712
  mon->m_pid = 0;
#line 1713
  monitor_socketpair(pair);
#line 1715
  mon->m_recvfd = pair[0];
#line 1716
  mon->m_sendfd = pair[1];
#line 1719
  if (options.compression) {
#line 1720
    mon->m_zback = mm_create((struct mm_master *)((void *)0), 65536U);
#line 1721
    mon->m_zlib = mm_create(mon->m_zback, 1310720U);
#line 1724
    mm_init_compression(mon->m_zlib);
  }
#line 1727
  return (mon);
}
}
#line 1730 "monitor.c"
void monitor_reinit(struct monitor *mon ) 
{ int pair[2] ;

  {
#line 1735
  monitor_socketpair(pair);
#line 1737
  mon->m_recvfd = pair[0];
#line 1738
  mon->m_sendfd = pair[1];
#line 1739
  return;
}
}
#line 1 "monitor_wrap.o"
#line 44 "monitor_wrap.h"
DH *mm_choose_dh(int min , int nbits , int max ) ;
#line 45
int mm_key_sign(Key *key , u_char **sigp , u_int *lenp , u_char *data , u_int datalen ) ;
#line 50
int mm_key_allowed(enum mm_keytype type , char *user , char *host , Key *key ) ;
#line 88
int mm_newkeys_to_blob(int mode , u_char **blobp , u_int *lenp ) ;
#line 95
int mm_bsdauth_query(void *ctx , char **name , char **infotxt , u_int *numprompts ,
                     char ***prompts , u_int **echo_on ) ;
#line 96
int mm_bsdauth_respond(void *ctx , u_int numresponses , char **responses ) ;
#line 99
int mm_skey_query(void *ctx , char **name , char **infotxt , u_int *numprompts , char ***prompts ,
                  u_int **echo_on ) ;
#line 100
int mm_skey_respond(void *ctx , u_int numresponses , char **responses ) ;
#line 32 "monitor_fdpass.h"
int mm_receive_fd(int socket___0 ) ;
#line 75 "monitor_wrap.c"
int mm_is_monitor(void) 
{ int tmp ;

  {
#line 82
  if (pmonitor) {
#line 82
    if (pmonitor->m_pid > 0) {
#line 82
      tmp = 1;
    } else {
#line 82
      tmp = 0;
    }
  } else {
#line 82
    tmp = 0;
  }
#line 82
  return (tmp);
}
}
#line 85 "monitor_wrap.c"
void mm_request_send(int socket___0 , enum monitor_reqtype type , Buffer *m___0 ) 
{ u_int mlen ;
  u_int tmp ;
  u_char buf___1[5] ;
  ssize_t tmp___0 ;
  void *tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 88
  tmp = buffer_len(m___0);
#line 88
  mlen = tmp;
#line 91
  debug3("%s entering: type %d", "mm_request_send", type);
#line 93
  while (1) {
#line 93
    buf___1[0] = (unsigned char )((mlen + 1U) >> 24);
#line 93
    buf___1[1] = (unsigned char )((mlen + 1U) >> 16);
#line 93
    buf___1[2] = (unsigned char )((mlen + 1U) >> 8);
#line 93
    buf___1[3] = (unsigned char )(mlen + 1U);
#line 93
    break;
  }
#line 94
  buf___1[4] = (unsigned char )type;
#line 95
  tmp___0 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), socket___0,
                     (void *)(buf___1), sizeof(buf___1));
#line 95
  if ((unsigned int )tmp___0 != sizeof(buf___1)) {
#line 96
    fatal("%s: write", "mm_request_send");
  }
#line 97
  tmp___1 = buffer_ptr(m___0);
#line 97
  tmp___2 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), socket___0,
                     tmp___1, mlen);
#line 97
  if ((u_int )tmp___2 != mlen) {
#line 98
    fatal("%s: write", "mm_request_send");
  }
#line 99
  return;
}
}
#line 101 "monitor_wrap.c"
void mm_request_receive(int socket___0 , Buffer *m___0 ) 
{ u_char buf___1[4] ;
  u_int msg_len ;
  ssize_t res ;
  void *tmp ;

  {
#line 108
  debug3("%s entering", "mm_request_receive");
#line 110
  res = atomicio(& read, socket___0, (void *)(buf___1), sizeof(buf___1));
#line 111
  if ((unsigned int )res != sizeof(buf___1)) {
#line 112
    if (res == 0) {
#line 113
      cleanup_exit(255);
    }
#line 114
    fatal("%s: read: %ld", "mm_request_receive", (long )res);
  }
#line 116
  msg_len = (unsigned int )(((((unsigned long )buf___1[0] << 24) | ((unsigned long )buf___1[1] << 16)) | ((unsigned long )buf___1[2] << 8)) | (unsigned long )buf___1[3]);
#line 117
  if (msg_len > 262144U) {
#line 118
    fatal("%s: read: bad msg_len %d", "mm_request_receive", msg_len);
  }
#line 119
  buffer_clear(m___0);
#line 120
  buffer_append_space(m___0, msg_len);
#line 121
  tmp = buffer_ptr(m___0);
#line 121
  res = atomicio(& read, socket___0, tmp, msg_len);
#line 122
  if ((u_int )res != msg_len) {
#line 123
    fatal("%s: read: %ld != msg_len", "mm_request_receive", (long )res);
  }
#line 124
  return;
}
}
#line 126 "monitor_wrap.c"
void mm_request_receive_expect(int socket___0 , enum monitor_reqtype type , Buffer *m___0 ) 
{ u_char rtype ;
  int tmp ;

  {
#line 131
  debug3("%s entering: type %d", "mm_request_receive_expect", type);
#line 133
  mm_request_receive(socket___0, m___0);
#line 134
  tmp = buffer_get_char(m___0);
#line 134
  rtype = (unsigned char )tmp;
#line 135
  if ((int )rtype != (int )type) {
#line 136
    fatal("%s: read: rtype %d != type %d", "mm_request_receive_expect", rtype, type);
  }
#line 138
  return;
}
}
#line 140 "monitor_wrap.c"
DH *mm_choose_dh(int min , int nbits , int max ) 
{ BIGNUM *p ;
  BIGNUM *g ;
  int success ;
  Buffer m___0 ;
  u_int tmp ;
  DH *tmp___0 ;

  {
#line 144
  success = 0;
#line 147
  buffer_init(& m___0);
#line 148
  buffer_put_int(& m___0, (unsigned int )min);
#line 149
  buffer_put_int(& m___0, (unsigned int )nbits);
#line 150
  buffer_put_int(& m___0, (unsigned int )max);
#line 152
  mm_request_send(pmonitor->m_recvfd, 0, & m___0);
#line 154
  debug3("%s: waiting for MONITOR_ANS_MODULI", "mm_choose_dh");
#line 155
  mm_request_receive_expect(pmonitor->m_recvfd, 1, & m___0);
#line 157
  success = buffer_get_char(& m___0);
#line 158
  if (success == 0) {
#line 159
    fatal("%s: MONITOR_ANS_MODULI failed", "mm_choose_dh");
  }
#line 161
  p = BN_new();
#line 161
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 162
    fatal("%s: BN_new failed", "mm_choose_dh");
  }
#line 163
  g = BN_new();
#line 163
  if ((unsigned int )g == (unsigned int )((void *)0)) {
#line 164
    fatal("%s: BN_new failed", "mm_choose_dh");
  }
#line 165
  buffer_get_bignum2(& m___0, p);
#line 166
  buffer_get_bignum2(& m___0, g);
#line 168
  tmp = buffer_len(& m___0);
#line 168
  debug3("%s: remaining %d", "mm_choose_dh", tmp);
#line 169
  buffer_free(& m___0);
#line 171
  tmp___0 = dh_new_group(g, p);
#line 171
  return (tmp___0);
}
}
#line 174 "monitor_wrap.c"
int mm_key_sign(Key *key , u_char **sigp , u_int *lenp , u_char *data , u_int datalen ) 
{ Kex *kex ;
  Buffer m___0 ;
  int tmp ;
  void *tmp___0 ;

  {
#line 177
  kex = *(pmonitor->m_pkex);
#line 180
  debug3("%s entering", "mm_key_sign");
#line 182
  buffer_init(& m___0);
#line 183
  tmp = (*(kex->host_key_index))(key);
#line 183
  buffer_put_int(& m___0, (unsigned int )tmp);
#line 184
  buffer_put_string(& m___0, (void const   *)data, datalen);
#line 186
  mm_request_send(pmonitor->m_recvfd, 4, & m___0);
#line 188
  debug3("%s: waiting for MONITOR_ANS_SIGN", "mm_key_sign");
#line 189
  mm_request_receive_expect(pmonitor->m_recvfd, 5, & m___0);
#line 190
  tmp___0 = buffer_get_string(& m___0, lenp);
#line 190
  *sigp = (u_char *)tmp___0;
#line 191
  buffer_free(& m___0);
#line 193
  return (0);
}
}
#line 196 "monitor_wrap.c"
struct passwd *mm_getpwnamallow(char const   *login___0 ) 
{ Buffer m___0 ;
  struct passwd *pw ;
  u_int pwlen ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
#line 203
  debug3("%s entering", "mm_getpwnamallow");
#line 205
  buffer_init(& m___0);
#line 206
  buffer_put_cstring(& m___0, login___0);
#line 208
  mm_request_send(pmonitor->m_recvfd, 6, & m___0);
#line 210
  debug3("%s: waiting for MONITOR_ANS_PWNAM", "mm_getpwnamallow");
#line 211
  mm_request_receive_expect(pmonitor->m_recvfd, 7, & m___0);
#line 213
  tmp = buffer_get_char(& m___0);
#line 213
  if (tmp == 0) {
#line 214
    buffer_free(& m___0);
#line 215
    return ((struct passwd *)((void *)0));
  }
#line 217
  tmp___0 = buffer_get_string(& m___0, & pwlen);
#line 217
  pw = (struct passwd *)tmp___0;
#line 218
  if (pwlen != sizeof(struct passwd )) {
#line 219
    fatal("%s: struct passwd size mismatch", "mm_getpwnamallow");
  }
#line 220
  tmp___1 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 220
  pw->pw_name = (char *)tmp___1;
#line 221
  tmp___2 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 221
  pw->pw_passwd = (char *)tmp___2;
#line 222
  tmp___3 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 222
  pw->pw_gecos = (char *)tmp___3;
#line 226
  tmp___4 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 226
  pw->pw_dir = (char *)tmp___4;
#line 227
  tmp___5 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 227
  pw->pw_shell = (char *)tmp___5;
#line 228
  buffer_free(& m___0);
#line 230
  return (pw);
}
}
#line 233 "monitor_wrap.c"
char *mm_auth2_read_banner(void) 
{ Buffer m___0 ;
  char *banner ;
  void *tmp ;
  size_t tmp___0 ;

  {
#line 239
  debug3("%s entering", "mm_auth2_read_banner");
#line 241
  buffer_init(& m___0);
#line 242
  mm_request_send(pmonitor->m_recvfd, 8, & m___0);
#line 243
  buffer_clear(& m___0);
#line 245
  mm_request_receive_expect(pmonitor->m_recvfd, 9, & m___0);
#line 247
  tmp = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 247
  banner = (char *)tmp;
#line 248
  buffer_free(& m___0);
#line 251
  tmp___0 = strlen((char const   *)banner);
#line 251
  if (tmp___0 == 0U) {
#line 252
    xfree((void *)banner);
#line 253
    banner = (char *)((void *)0);
  }
#line 255
  return (banner);
}
}
#line 260 "monitor_wrap.c"
void mm_inform_authserv(char *service , char *style ) 
{ Buffer m___0 ;
  char const   *tmp ;

  {
#line 265
  debug3("%s entering", "mm_inform_authserv");
#line 267
  buffer_init(& m___0);
#line 268
  buffer_put_cstring(& m___0, (char const   *)service);
#line 269
  if (style) {
#line 269
    tmp = (char const   *)style;
  } else {
#line 269
    tmp = "";
  }
#line 269
  buffer_put_cstring(& m___0, tmp);
#line 271
  mm_request_send(pmonitor->m_recvfd, 3, & m___0);
#line 273
  buffer_free(& m___0);
#line 274
  return;
}
}
#line 277 "monitor_wrap.c"
int mm_auth_password(struct Authctxt *authctxt___0 , char *password ) 
{ Buffer m___0 ;
  int authenticated ;
  u_int tmp ;
  char const   *tmp___0 ;

  {
#line 281
  authenticated = 0;
#line 283
  debug3("%s entering", "mm_auth_password");
#line 285
  buffer_init(& m___0);
#line 286
  buffer_put_cstring(& m___0, (char const   *)password);
#line 287
  mm_request_send(pmonitor->m_recvfd, 10, & m___0);
#line 289
  debug3("%s: waiting for MONITOR_ANS_AUTHPASSWORD", "mm_auth_password");
#line 290
  mm_request_receive_expect(pmonitor->m_recvfd, 11, & m___0);
#line 292
  tmp = buffer_get_int(& m___0);
#line 292
  authenticated = (int )tmp;
#line 294
  buffer_free(& m___0);
#line 296
  if (authenticated) {
#line 296
    tmp___0 = "";
  } else {
#line 296
    tmp___0 = "not ";
  }
#line 296
  debug3("%s: user %sauthenticated", "mm_auth_password", tmp___0);
#line 298
  return (authenticated);
}
}
#line 301 "monitor_wrap.c"
int mm_user_key_allowed(struct passwd *pw , Key *key ) 
{ int tmp ;

  {
#line 304
  tmp = mm_key_allowed(2, (char *)((void *)0), (char *)((void *)0), key);
#line 304
  return (tmp);
}
}
#line 307 "monitor_wrap.c"
int mm_hostbased_key_allowed(struct passwd *pw , char *user , char *host , Key *key ) 
{ int tmp ;

  {
#line 311
  tmp = mm_key_allowed(1, user, host, key);
#line 311
  return (tmp);
}
}
#line 314 "monitor_wrap.c"
int mm_auth_rhosts_rsa_key_allowed(struct passwd *pw , char *user , char *host , Key *key ) 
{ int ret ;

  {
#line 320
  key->type = 1;
#line 321
  ret = mm_key_allowed(3, user, host, key);
#line 322
  key->type = 0;
#line 323
  return (ret);
}
}
#line 326 "monitor_wrap.c"
static void mm_send_debug(Buffer *m___0 ) 
{ char *msg ;
  void *tmp ;
  u_int tmp___0 ;

  {
#line 331
  while (1) {
#line 331
    tmp___0 = buffer_len(m___0);
#line 331
    if (! tmp___0) {
#line 331
      break;
    }
#line 332
    tmp = buffer_get_string(m___0, (u_int *)((void *)0));
#line 332
    msg = (char *)tmp;
#line 333
    debug3("%s: Sending debug: %s", "mm_send_debug", msg);
#line 334
    packet_send_debug("%s", msg);
#line 335
    xfree((void *)msg);
  }
#line 337
  return;
}
}
#line 339 "monitor_wrap.c"
int mm_key_allowed(enum mm_keytype type , char *user , char *host , Key *key ) 
{ Buffer m___0 ;
  u_char *blob ;
  u_int len ;
  int allowed ;
  int have_forced ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;

  {
#line 345
  allowed = 0;
#line 345
  have_forced = 0;
#line 347
  debug3("%s entering", "mm_key_allowed");
#line 350
  tmp = key_to_blob((Key const   *)key, & blob, & len);
#line 350
  if (! tmp) {
#line 351
    return (0);
  }
#line 353
  buffer_init(& m___0);
#line 354
  buffer_put_int(& m___0, (unsigned int )type);
#line 355
  if (user) {
#line 355
    tmp___0 = (char const   *)user;
  } else {
#line 355
    tmp___0 = "";
  }
#line 355
  buffer_put_cstring(& m___0, tmp___0);
#line 356
  if (host) {
#line 356
    tmp___1 = (char const   *)host;
  } else {
#line 356
    tmp___1 = "";
  }
#line 356
  buffer_put_cstring(& m___0, tmp___1);
#line 357
  buffer_put_string(& m___0, (void const   *)blob, len);
#line 358
  xfree((void *)blob);
#line 360
  mm_request_send(pmonitor->m_recvfd, 20, & m___0);
#line 362
  debug3("%s: waiting for MONITOR_ANS_KEYALLOWED", "mm_key_allowed");
#line 363
  mm_request_receive_expect(pmonitor->m_recvfd, 21, & m___0);
#line 365
  tmp___2 = buffer_get_int(& m___0);
#line 365
  allowed = (int )tmp___2;
#line 368
  auth_clear_options();
#line 369
  tmp___3 = buffer_get_int(& m___0);
#line 369
  have_forced = (int )tmp___3;
#line 370
  if (have_forced) {
#line 370
    forced_command = xstrdup("true");
  } else {
#line 370
    forced_command = (char *)((void *)0);
  }
#line 373
  mm_send_debug(& m___0);
#line 375
  buffer_free(& m___0);
#line 377
  return (allowed);
}
}
#line 386 "monitor_wrap.c"
int mm_key_verify(Key *key , u_char *sig , u_int siglen , u_char *data , u_int datalen ) 
{ Buffer m___0 ;
  u_char *blob ;
  u_int len ;
  int verified ;
  int tmp ;
  u_int tmp___0 ;

  {
#line 392
  verified = 0;
#line 394
  debug3("%s entering", "mm_key_verify");
#line 397
  tmp = key_to_blob((Key const   *)key, & blob, & len);
#line 397
  if (! tmp) {
#line 398
    return (0);
  }
#line 400
  buffer_init(& m___0);
#line 401
  buffer_put_string(& m___0, (void const   *)blob, len);
#line 402
  buffer_put_string(& m___0, (void const   *)sig, siglen);
#line 403
  buffer_put_string(& m___0, (void const   *)data, datalen);
#line 404
  xfree((void *)blob);
#line 406
  mm_request_send(pmonitor->m_recvfd, 22, & m___0);
#line 408
  debug3("%s: waiting for MONITOR_ANS_KEYVERIFY", "mm_key_verify");
#line 409
  mm_request_receive_expect(pmonitor->m_recvfd, 23, & m___0);
#line 411
  tmp___0 = buffer_get_int(& m___0);
#line 411
  verified = (int )tmp___0;
#line 413
  buffer_free(& m___0);
#line 415
  return (verified);
}
}
#line 419 "monitor_wrap.c"
struct Newkeys *mm_newkeys_from_blob(u_char *blob , int blen ) 
{ Buffer b ;
  u_int len ;
  Newkeys *newkey ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  void *tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  Cipher *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  u_int tmp___7 ;
  void *tmp___8 ;
  u_int tmp___9 ;
  u_int tmp___10 ;
  void *tmp___11 ;

  {
#line 424
  newkey = (Newkeys *)((void *)0);
#line 429
  debug3("%s: %p(%d)", "mm_newkeys_from_blob", blob, blen);
#line 433
  buffer_init(& b);
#line 434
  buffer_append(& b, (void const   *)blob, (unsigned int )blen);
#line 436
  tmp = xmalloc(sizeof(*newkey));
#line 436
  newkey = (Newkeys *)tmp;
#line 437
  enc = & newkey->enc;
#line 438
  mac = & newkey->mac;
#line 439
  comp = & newkey->comp;
#line 442
  tmp___0 = buffer_get_string(& b, (u_int *)((void *)0));
#line 442
  enc->name = (char *)tmp___0;
#line 443
  buffer_get(& b, (void *)(& enc->cipher), sizeof(enc->cipher));
#line 444
  tmp___1 = buffer_get_int(& b);
#line 444
  enc->enabled = (int )tmp___1;
#line 445
  enc->block_size = buffer_get_int(& b);
#line 446
  tmp___2 = buffer_get_string(& b, & enc->key_len);
#line 446
  enc->key = (u_char *)tmp___2;
#line 447
  tmp___3 = buffer_get_string(& b, & len);
#line 447
  enc->iv = (u_char *)tmp___3;
#line 448
  if (len != enc->block_size) {
#line 449
    fatal("%s: bad ivlen: expected %u != %u", "mm_newkeys_from_blob", enc->block_size,
          len);
  }
#line 452
  if ((unsigned int )enc->name == (unsigned int )((void *)0)) {
#line 453
    fatal("%s: bad cipher name %s or pointer %p", "mm_newkeys_from_blob", enc->name,
          enc->cipher);
  } else {
#line 452
    tmp___4 = cipher_by_name((char const   *)enc->name);
#line 452
    if ((unsigned int )tmp___4 != (unsigned int )enc->cipher) {
#line 453
      fatal("%s: bad cipher name %s or pointer %p", "mm_newkeys_from_blob", enc->name,
            enc->cipher);
    }
  }
#line 457
  tmp___5 = buffer_get_string(& b, (u_int *)((void *)0));
#line 457
  mac->name = (char *)tmp___5;
#line 458
  if ((unsigned int )mac->name == (unsigned int )((void *)0)) {
#line 459
    fatal("%s: can not init mac %s", "mm_newkeys_from_blob", mac->name);
  } else {
#line 458
    tmp___6 = mac_init(mac, mac->name);
#line 458
    if (tmp___6 == -1) {
#line 459
      fatal("%s: can not init mac %s", "mm_newkeys_from_blob", mac->name);
    }
  }
#line 460
  tmp___7 = buffer_get_int(& b);
#line 460
  mac->enabled = (int )tmp___7;
#line 461
  tmp___8 = buffer_get_string(& b, & len);
#line 461
  mac->key = (u_char *)tmp___8;
#line 462
  if (len > (u_int )mac->key_len) {
#line 463
    fatal("%s: bad mac key length: %u > %d", "mm_newkeys_from_blob", len, mac->key_len);
  }
#line 465
  mac->key_len = (int )len;
#line 468
  tmp___9 = buffer_get_int(& b);
#line 468
  comp->type = (int )tmp___9;
#line 469
  tmp___10 = buffer_get_int(& b);
#line 469
  comp->enabled = (int )tmp___10;
#line 470
  tmp___11 = buffer_get_string(& b, (u_int *)((void *)0));
#line 470
  comp->name = (char *)tmp___11;
#line 472
  len = buffer_len(& b);
#line 473
  if (len != 0U) {
#line 474
    error("newkeys_from_blob: remaining bytes in blob %u", len);
  }
#line 475
  buffer_free(& b);
#line 476
  return (newkey);
}
}
#line 479 "monitor_wrap.c"
int mm_newkeys_to_blob(int mode , u_char **blobp , u_int *lenp ) 
{ Buffer b ;
  int len ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  Newkeys *newkey ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 487
  newkey = newkeys[mode];
#line 489
  debug3("%s: converting %p", "mm_newkeys_to_blob", newkey);
#line 491
  if ((unsigned int )newkey == (unsigned int )((void *)0)) {
#line 492
    error("%s: newkey == NULL", "mm_newkeys_to_blob");
#line 493
    return (0);
  }
#line 495
  enc = & newkey->enc;
#line 496
  mac = & newkey->mac;
#line 497
  comp = & newkey->comp;
#line 499
  buffer_init(& b);
#line 501
  buffer_put_cstring(& b, (char const   *)enc->name);
#line 503
  buffer_append(& b, (void const   *)(& enc->cipher), sizeof(enc->cipher));
#line 504
  buffer_put_int(& b, (unsigned int )enc->enabled);
#line 505
  buffer_put_int(& b, enc->block_size);
#line 506
  buffer_put_string(& b, (void const   *)enc->key, enc->key_len);
#line 507
  packet_get_keyiv(mode, enc->iv, enc->block_size);
#line 508
  buffer_put_string(& b, (void const   *)enc->iv, enc->block_size);
#line 511
  buffer_put_cstring(& b, (char const   *)mac->name);
#line 512
  buffer_put_int(& b, (unsigned int )mac->enabled);
#line 513
  buffer_put_string(& b, (void const   *)mac->key, (unsigned int )mac->key_len);
#line 516
  buffer_put_int(& b, (unsigned int )comp->type);
#line 517
  buffer_put_int(& b, (unsigned int )comp->enabled);
#line 518
  buffer_put_cstring(& b, (char const   *)comp->name);
#line 520
  tmp = buffer_len(& b);
#line 520
  len = (int )tmp;
#line 521
  if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 522
    *lenp = (unsigned int )len;
  }
#line 523
  if ((unsigned int )blobp != (unsigned int )((void *)0)) {
#line 524
    tmp___0 = xmalloc((unsigned int )len);
#line 524
    *blobp = (u_char *)tmp___0;
#line 525
    tmp___1 = buffer_ptr(& b);
#line 525
    memcpy((void * __restrict  )*blobp, (void const   * __restrict  )tmp___1, (unsigned int )len);
  }
#line 527
  tmp___2 = buffer_ptr(& b);
#line 527
  memset(tmp___2, 0, (unsigned int )len);
#line 528
  buffer_free(& b);
#line 529
  return (len);
}
}
#line 532 "monitor_wrap.c"
static void mm_send_kex(Buffer *m___0 , Kex *kex ) 
{ u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;

  {
#line 535
  buffer_put_string(m___0, (void const   *)kex->session_id, kex->session_id_len);
#line 536
  buffer_put_int(m___0, (unsigned int )kex->we_need);
#line 537
  buffer_put_int(m___0, (unsigned int )kex->hostkey_type);
#line 538
  buffer_put_int(m___0, (unsigned int )kex->kex_type);
#line 539
  tmp = buffer_len(& kex->my);
#line 539
  tmp___0 = buffer_ptr(& kex->my);
#line 539
  buffer_put_string(m___0, (void const   *)tmp___0, tmp);
#line 540
  tmp___1 = buffer_len(& kex->peer);
#line 540
  tmp___2 = buffer_ptr(& kex->peer);
#line 540
  buffer_put_string(m___0, (void const   *)tmp___2, tmp___1);
#line 541
  buffer_put_int(m___0, (unsigned int )kex->flags);
#line 542
  buffer_put_cstring(m___0, (char const   *)kex->client_version_string);
#line 543
  buffer_put_cstring(m___0, (char const   *)kex->server_version_string);
#line 544
  return;
}
}
#line 546 "monitor_wrap.c"
void mm_send_keystate(struct monitor *pmonitor___0 ) 
{ Buffer m___0 ;
  u_char *blob ;
  u_char *p ;
  u_int bloblen ;
  u_int plen ;
  u_int32_t seqnr ;
  u_int32_t packets ;
  u_int64_t blocks ;
  u_char iv[24] ;
  u_char *key ;
  u_int ivlen ;
  u_int keylen ;
  u_int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  u_int tmp___10 ;
  void *tmp___11 ;
  u_int tmp___12 ;
  void *tmp___13 ;

  {
#line 555
  buffer_init(& m___0);
#line 557
  if (! compat20) {
#line 562
    tmp = packet_get_protocol_flags();
#line 562
    buffer_put_int(& m___0, tmp);
#line 564
    tmp___0 = packet_get_ssh1_cipher();
#line 564
    buffer_put_int(& m___0, (unsigned int )tmp___0);
#line 566
    debug3("%s: Sending ssh1 KEY+IV", "mm_send_keystate");
#line 567
    keylen = packet_get_encryption_key((u_char *)((void *)0));
#line 568
    tmp___1 = xmalloc(keylen + 1U);
#line 568
    key = (u_char *)tmp___1;
#line 569
    keylen = packet_get_encryption_key(key);
#line 570
    buffer_put_string(& m___0, (void const   *)key, keylen);
#line 571
    memset((void *)key, 0, keylen);
#line 572
    xfree((void *)key);
#line 574
    tmp___2 = packet_get_keyiv_len(1);
#line 574
    ivlen = (unsigned int )tmp___2;
#line 575
    packet_get_keyiv(1, iv, ivlen);
#line 576
    buffer_put_string(& m___0, (void const   *)(iv), ivlen);
#line 577
    tmp___3 = packet_get_keyiv_len(1);
#line 577
    ivlen = (unsigned int )tmp___3;
#line 578
    packet_get_keyiv(0, iv, ivlen);
#line 579
    buffer_put_string(& m___0, (void const   *)(iv), ivlen);
    goto skip;
  } else {
#line 583
    mm_send_kex(& m___0, *(pmonitor___0->m_pkex));
  }
#line 586
  debug3("%s: Sending new keys: %p %p", "mm_send_keystate", newkeys[1], newkeys[0]);
#line 590
  tmp___4 = mm_newkeys_to_blob(1, & blob, & bloblen);
#line 590
  if (! tmp___4) {
#line 591
    fatal("%s: conversion of newkeys failed", "mm_send_keystate");
  }
#line 593
  buffer_put_string(& m___0, (void const   *)blob, bloblen);
#line 594
  xfree((void *)blob);
#line 596
  tmp___5 = mm_newkeys_to_blob(0, & blob, & bloblen);
#line 596
  if (! tmp___5) {
#line 597
    fatal("%s: conversion of newkeys failed", "mm_send_keystate");
  }
#line 599
  buffer_put_string(& m___0, (void const   *)blob, bloblen);
#line 600
  xfree((void *)blob);
#line 602
  packet_get_state(1, & seqnr, & blocks, & packets);
#line 603
  buffer_put_int(& m___0, seqnr);
#line 604
  buffer_put_int64(& m___0, blocks);
#line 605
  buffer_put_int(& m___0, packets);
#line 606
  packet_get_state(0, & seqnr, & blocks, & packets);
#line 607
  buffer_put_int(& m___0, seqnr);
#line 608
  buffer_put_int64(& m___0, blocks);
#line 609
  buffer_put_int(& m___0, packets);
#line 611
  debug3("%s: New keys have been sent", "mm_send_keystate");
  skip: 
#line 614
  tmp___6 = packet_get_keycontext(1, (u_char *)((void *)0));
#line 614
  plen = (unsigned int )tmp___6;
#line 615
  tmp___7 = xmalloc(plen + 1U);
#line 615
  p = (u_char *)tmp___7;
#line 616
  packet_get_keycontext(1, p);
#line 617
  buffer_put_string(& m___0, (void const   *)p, plen);
#line 618
  xfree((void *)p);
#line 620
  tmp___8 = packet_get_keycontext(0, (u_char *)((void *)0));
#line 620
  plen = (unsigned int )tmp___8;
#line 621
  tmp___9 = xmalloc(plen + 1U);
#line 621
  p = (u_char *)tmp___9;
#line 622
  packet_get_keycontext(0, p);
#line 623
  buffer_put_string(& m___0, (void const   *)p, plen);
#line 624
  xfree((void *)p);
#line 627
  debug3("%s: Sending compression state", "mm_send_keystate");
#line 628
  buffer_put_string(& m___0, (void const   *)(& outgoing_stream), sizeof(outgoing_stream));
#line 629
  buffer_put_string(& m___0, (void const   *)(& incoming_stream), sizeof(incoming_stream));
#line 632
  tmp___10 = buffer_len(& input);
#line 632
  tmp___11 = buffer_ptr(& input);
#line 632
  buffer_put_string(& m___0, (void const   *)tmp___11, tmp___10);
#line 633
  tmp___12 = buffer_len(& output);
#line 633
  tmp___13 = buffer_ptr(& output);
#line 633
  buffer_put_string(& m___0, (void const   *)tmp___13, tmp___12);
#line 635
  mm_request_send(pmonitor___0->m_recvfd, 24, & m___0);
#line 636
  debug3("%s: Finished sending state", "mm_send_keystate");
#line 638
  buffer_free(& m___0);
#line 639
  return;
}
}
#line 641 "monitor_wrap.c"
int mm_pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) 
{ Buffer m___0 ;
  char *p ;
  int success ;
  u_int tmp ;
  void *tmp___0 ;

  {
#line 646
  success = 0;
#line 648
  buffer_init(& m___0);
#line 649
  mm_request_send(pmonitor->m_recvfd, 25, & m___0);
#line 651
  debug3("%s: waiting for MONITOR_ANS_PTY", "mm_pty_allocate");
#line 652
  mm_request_receive_expect(pmonitor->m_recvfd, 26, & m___0);
#line 654
  tmp = buffer_get_int(& m___0);
#line 654
  success = (int )tmp;
#line 655
  if (success == 0) {
#line 656
    debug3("%s: pty alloc failed", "mm_pty_allocate");
#line 657
    buffer_free(& m___0);
#line 658
    return (0);
  }
#line 660
  tmp___0 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 660
  p = (char *)tmp___0;
#line 661
  buffer_free(& m___0);
#line 663
  strlcpy(namebuf, (char const   *)p, (unsigned int )namebuflen);
#line 664
  xfree((void *)p);
#line 666
  *ptyfd = mm_receive_fd(pmonitor->m_recvfd);
#line 667
  *ttyfd = mm_receive_fd(pmonitor->m_recvfd);
#line 670
  return (1);
}
}
#line 673 "monitor_wrap.c"
void mm_session_pty_cleanup2(struct Session *s ) 
{ Buffer m___0 ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 678
  if (s->ttyfd == -1) {
#line 679
    return;
  }
#line 680
  buffer_init(& m___0);
#line 681
  buffer_put_cstring(& m___0, (char const   *)(s->tty));
#line 682
  mm_request_send(pmonitor->m_recvfd, 27, & m___0);
#line 683
  buffer_free(& m___0);
#line 686
  tmp___1 = close(s->ptymaster);
#line 686
  if (tmp___1 < 0) {
#line 687
    tmp = __errno_location();
#line 687
    tmp___0 = strerror(*tmp);
#line 687
    error("close(s->ptymaster): %s", tmp___0);
  }
#line 690
  s->ttyfd = -1;
#line 691
  return;
}
}
#line 818 "monitor_wrap.c"
void mm_terminate(void) 
{ Buffer m___0 ;

  {
#line 823
  buffer_init(& m___0);
#line 824
  mm_request_send(pmonitor->m_recvfd, 56, & m___0);
#line 825
  buffer_free(& m___0);
#line 826
  return;
}
}
#line 828 "monitor_wrap.c"
int mm_ssh1_session_key(BIGNUM *num ) 
{ int rsafail ;
  Buffer m___0 ;
  u_int tmp ;

  {
#line 834
  buffer_init(& m___0);
#line 835
  buffer_put_bignum2(& m___0, (BIGNUM const   *)num);
#line 836
  mm_request_send(pmonitor->m_recvfd, 28, & m___0);
#line 838
  mm_request_receive_expect(pmonitor->m_recvfd, 29, & m___0);
#line 840
  tmp = buffer_get_int(& m___0);
#line 840
  rsafail = (int )tmp;
#line 841
  buffer_get_bignum2(& m___0, num);
#line 843
  buffer_free(& m___0);
#line 845
  return (rsafail);
}
}
#line 848 "monitor_wrap.c"
static void mm_chall_setup(char **name , char **infotxt , u_int *numprompts , char ***prompts ,
                           u_int **echo_on ) 
{ void *tmp ;
  void *tmp___0 ;

  {
#line 852
  *name = xstrdup("");
#line 853
  *infotxt = xstrdup("");
#line 854
  *numprompts = 1U;
#line 855
  tmp = xmalloc(*numprompts * sizeof(char *));
#line 855
  *prompts = (char **)tmp;
#line 856
  tmp___0 = xmalloc(*numprompts * sizeof(u_int ));
#line 856
  *echo_on = (u_int *)tmp___0;
#line 857
  *(*echo_on + 0) = 0U;
#line 858
  return;
}
}
#line 860 "monitor_wrap.c"
int mm_bsdauth_query(void *ctx , char **name , char **infotxt , u_int *numprompts ,
                     char ***prompts , u_int **echo_on ) 
{ Buffer m___0 ;
  u_int success ;
  char *challenge ;
  void *tmp ;

  {
#line 868
  debug3("%s: entering", "mm_bsdauth_query");
#line 870
  buffer_init(& m___0);
#line 871
  mm_request_send(pmonitor->m_recvfd, 12, & m___0);
#line 873
  mm_request_receive_expect(pmonitor->m_recvfd, 13, & m___0);
#line 875
  success = buffer_get_int(& m___0);
#line 876
  if (success == 0U) {
#line 877
    debug3("%s: no challenge", "mm_bsdauth_query");
#line 878
    buffer_free(& m___0);
#line 879
    return (-1);
  }
#line 883
  tmp = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 883
  challenge = (char *)tmp;
#line 884
  buffer_free(& m___0);
#line 886
  mm_chall_setup(name, infotxt, numprompts, prompts, echo_on);
#line 887
  *(*prompts + 0) = challenge;
#line 889
  debug3("%s: received challenge: %s", "mm_bsdauth_query", challenge);
#line 891
  return (0);
}
}
#line 894 "monitor_wrap.c"
int mm_bsdauth_respond(void *ctx , u_int numresponses , char **responses ) 
{ Buffer m___0 ;
  int authok ;
  u_int tmp ;
  int tmp___0 ;

  {
#line 900
  debug3("%s: entering", "mm_bsdauth_respond");
#line 901
  if (numresponses != 1U) {
#line 902
    return (-1);
  }
#line 904
  buffer_init(& m___0);
#line 905
  buffer_put_cstring(& m___0, (char const   *)*(responses + 0));
#line 906
  mm_request_send(pmonitor->m_recvfd, 14, & m___0);
#line 908
  mm_request_receive_expect(pmonitor->m_recvfd, 15, & m___0);
#line 911
  tmp = buffer_get_int(& m___0);
#line 911
  authok = (int )tmp;
#line 912
  buffer_free(& m___0);
#line 914
  if (authok == 0) {
#line 914
    tmp___0 = -1;
  } else {
#line 914
    tmp___0 = 0;
  }
#line 914
  return (tmp___0);
}
}
#line 917 "monitor_wrap.c"
int mm_skey_query(void *ctx , char **name , char **infotxt , u_int *numprompts , char ***prompts ,
                  u_int **echo_on ) 
{ Buffer m___0 ;
  int len ;
  u_int success ;
  char *p ;
  char *challenge ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
#line 926
  debug3("%s: entering", "mm_skey_query");
#line 928
  buffer_init(& m___0);
#line 929
  mm_request_send(pmonitor->m_recvfd, 16, & m___0);
#line 931
  mm_request_receive_expect(pmonitor->m_recvfd, 17, & m___0);
#line 933
  success = buffer_get_int(& m___0);
#line 934
  if (success == 0U) {
#line 935
    debug3("%s: no challenge", "mm_skey_query");
#line 936
    buffer_free(& m___0);
#line 937
    return (-1);
  }
#line 941
  tmp = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 941
  challenge = (char *)tmp;
#line 942
  buffer_free(& m___0);
#line 944
  debug3("%s: received challenge: %s", "mm_skey_query", challenge);
#line 946
  mm_chall_setup(name, infotxt, numprompts, prompts, echo_on);
#line 948
  tmp___0 = strlen((char const   *)challenge);
#line 948
  tmp___1 = strlen("\nS/Key Password: ");
#line 948
  len = (int )((tmp___0 + tmp___1) + 1U);
#line 949
  tmp___2 = xmalloc((unsigned int )len);
#line 949
  p = (char *)tmp___2;
#line 950
  strlcpy(p, (char const   *)challenge, (unsigned int )len);
#line 951
  strlcat(p, "\nS/Key Password: ", (unsigned int )len);
#line 952
  *(*prompts + 0) = p;
#line 953
  xfree((void *)challenge);
#line 955
  return (0);
}
}
#line 958 "monitor_wrap.c"
int mm_skey_respond(void *ctx , u_int numresponses , char **responses ) 
{ Buffer m___0 ;
  int authok ;
  u_int tmp ;
  int tmp___0 ;

  {
#line 964
  debug3("%s: entering", "mm_skey_respond");
#line 965
  if (numresponses != 1U) {
#line 966
    return (-1);
  }
#line 968
  buffer_init(& m___0);
#line 969
  buffer_put_cstring(& m___0, (char const   *)*(responses + 0));
#line 970
  mm_request_send(pmonitor->m_recvfd, 18, & m___0);
#line 972
  mm_request_receive_expect(pmonitor->m_recvfd, 19, & m___0);
#line 975
  tmp = buffer_get_int(& m___0);
#line 975
  authok = (int )tmp;
#line 976
  buffer_free(& m___0);
#line 978
  if (authok == 0) {
#line 978
    tmp___0 = -1;
  } else {
#line 978
    tmp___0 = 0;
  }
#line 978
  return (tmp___0);
}
}
#line 981 "monitor_wrap.c"
void mm_ssh1_session_id(u_char *session_id___0 ) 
{ Buffer m___0 ;
  int i ;

  {
#line 987
  debug3("%s entering", "mm_ssh1_session_id");
#line 989
  buffer_init(& m___0);
#line 990
  i = 0;
#line 990
  while (i < 16) {
#line 991
    buffer_put_char(& m___0, (int )*(session_id___0 + i));
#line 990
    i ++;
  }
#line 993
  mm_request_send(pmonitor->m_recvfd, 30, & m___0);
#line 994
  buffer_free(& m___0);
#line 995
  return;
}
}
#line 997 "monitor_wrap.c"
int mm_auth_rsa_key_allowed(struct passwd *pw , BIGNUM *client_n , Key **rkey ) 
{ Buffer m___0 ;
  Key *key ;
  u_char *blob ;
  u_int blen ;
  int allowed ;
  int have_forced ;
  u_int tmp ;
  u_int tmp___0 ;
  void *tmp___2 ;

  {
#line 1004
  allowed = 0;
#line 1004
  have_forced = 0;
#line 1006
  debug3("%s entering", "mm_auth_rsa_key_allowed");
#line 1008
  buffer_init(& m___0);
#line 1009
  buffer_put_bignum2(& m___0, (BIGNUM const   *)client_n);
#line 1011
  mm_request_send(pmonitor->m_recvfd, 31, & m___0);
#line 1012
  mm_request_receive_expect(pmonitor->m_recvfd, 32, & m___0);
#line 1014
  tmp = buffer_get_int(& m___0);
#line 1014
  allowed = (int )tmp;
#line 1017
  auth_clear_options();
#line 1018
  tmp___0 = buffer_get_int(& m___0);
#line 1018
  have_forced = (int )tmp___0;
#line 1019
  if (have_forced) {
#line 1019
    forced_command = xstrdup("true");
  } else {
#line 1019
    forced_command = (char *)((void *)0);
  }
#line 1021
  if (allowed) {
#line 1021
    if ((unsigned int )rkey != (unsigned int )((void *)0)) {
#line 1022
      tmp___2 = buffer_get_string(& m___0, & blen);
#line 1022
      blob = (u_char *)tmp___2;
#line 1023
      key = key_from_blob((u_char const   *)blob, blen);
#line 1023
      if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 1024
        fatal("%s: key_from_blob failed", "mm_auth_rsa_key_allowed");
      }
#line 1025
      *rkey = key;
#line 1026
      xfree((void *)blob);
    }
  }
#line 1028
  mm_send_debug(& m___0);
#line 1029
  buffer_free(& m___0);
#line 1031
  return (allowed);
}
}
#line 1034 "monitor_wrap.c"
BIGNUM *mm_auth_rsa_generate_challenge(Key *key ) 
{ Buffer m___0 ;
  BIGNUM *challenge ;
  u_char *blob ;
  u_int blen ;
  int tmp ;

  {
#line 1042
  debug3("%s entering", "mm_auth_rsa_generate_challenge");
#line 1044
  challenge = BN_new();
#line 1044
  if ((unsigned int )challenge == (unsigned int )((void *)0)) {
#line 1045
    fatal("%s: BN_new failed", "mm_auth_rsa_generate_challenge");
  }
#line 1047
  key->type = 1;
#line 1048
  tmp = key_to_blob((Key const   *)key, & blob, & blen);
#line 1048
  if (tmp == 0) {
#line 1049
    fatal("%s: key_to_blob failed", "mm_auth_rsa_generate_challenge");
  }
#line 1050
  key->type = 0;
#line 1052
  buffer_init(& m___0);
#line 1053
  buffer_put_string(& m___0, (void const   *)blob, blen);
#line 1054
  xfree((void *)blob);
#line 1056
  mm_request_send(pmonitor->m_recvfd, 33, & m___0);
#line 1057
  mm_request_receive_expect(pmonitor->m_recvfd, 34, & m___0);
#line 1059
  buffer_get_bignum2(& m___0, challenge);
#line 1060
  buffer_free(& m___0);
#line 1062
  return (challenge);
}
}
#line 1065 "monitor_wrap.c"
int mm_auth_rsa_verify_response(Key *key , BIGNUM *p , u_char *response ) 
{ Buffer m___0 ;
  u_char *blob ;
  u_int blen ;
  int success ;
  int tmp ;
  u_int tmp___0 ;

  {
#line 1071
  success = 0;
#line 1073
  debug3("%s entering", "mm_auth_rsa_verify_response");
#line 1075
  key->type = 1;
#line 1076
  tmp = key_to_blob((Key const   *)key, & blob, & blen);
#line 1076
  if (tmp == 0) {
#line 1077
    fatal("%s: key_to_blob failed", "mm_auth_rsa_verify_response");
  }
#line 1078
  key->type = 0;
#line 1080
  buffer_init(& m___0);
#line 1081
  buffer_put_string(& m___0, (void const   *)blob, blen);
#line 1082
  buffer_put_string(& m___0, (void const   *)response, 16U);
#line 1083
  xfree((void *)blob);
#line 1085
  mm_request_send(pmonitor->m_recvfd, 35, & m___0);
#line 1086
  mm_request_receive_expect(pmonitor->m_recvfd, 36, & m___0);
#line 1088
  tmp___0 = buffer_get_int(& m___0);
#line 1088
  success = (int )tmp___0;
#line 1089
  buffer_free(& m___0);
#line 1091
  return (success);
}
}
#line 1 "monitor_fdpass.o"
#line 171 "/usr/include/sys/socket.h"
extern ssize_t sendmsg(int __fd , struct msghdr  const  *__message , int __flags ) ;
#line 179
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 34 "monitor_fdpass.c"
void mm_send_fd(int socket___0 , int fd ) 
{ struct msghdr msg ;
  struct iovec vec ;
  char ch ;
  ssize_t n___0 ;
  char tmp[(((sizeof(int ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U))] ;
  struct cmsghdr *cmsg ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 40
  ch = (char )'\000';
#line 47
  memset((void *)(& msg), 0, sizeof(msg));
#line 52
  msg.msg_control = (void *)(tmp);
#line 53
  msg.msg_controllen = (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U)) + sizeof(int );
#line 54
  if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 54
    cmsg = (struct cmsghdr *)msg.msg_control;
  } else {
#line 54
    cmsg = (struct cmsghdr *)((void *)0);
  }
#line 55
  cmsg->cmsg_len = (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U)) + sizeof(int );
#line 56
  cmsg->cmsg_level = 1;
#line 57
  cmsg->cmsg_type = 1;
#line 58
  *((int *)(cmsg->__cmsg_data)) = fd;
#line 61
  vec.iov_base = (void *)(& ch);
#line 62
  vec.iov_len = 1U;
#line 63
  msg.msg_iov = & vec;
#line 64
  msg.msg_iovlen = 1U;
#line 66
  n___0 = sendmsg(socket___0, (struct msghdr  const  *)(& msg), 0);
#line 66
  if (n___0 == -1) {
#line 67
    tmp___0 = __errno_location();
#line 67
    tmp___1 = strerror(*tmp___0);
#line 67
    fatal("%s: sendmsg(%d): %s", "mm_send_fd", fd, tmp___1);
  }
#line 69
  if (n___0 != 1) {
#line 70
    fatal("%s: sendmsg: expected sent 1 got %ld", "mm_send_fd", (long )n___0);
  }
#line 76
  return;
}
}
#line 78 "monitor_fdpass.c"
int mm_receive_fd(int socket___0 ) 
{ struct msghdr msg ;
  struct iovec vec ;
  ssize_t n___0 ;
  char ch ;
  int fd ;
  char tmp[(((sizeof(int ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U))] ;
  struct cmsghdr *cmsg ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 92
  memset((void *)(& msg), 0, sizeof(msg));
#line 93
  vec.iov_base = (void *)(& ch);
#line 94
  vec.iov_len = 1U;
#line 95
  msg.msg_iov = & vec;
#line 96
  msg.msg_iovlen = 1U;
#line 101
  msg.msg_control = (void *)(tmp);
#line 102
  msg.msg_controllen = sizeof(tmp);
#line 105
  n___0 = recvmsg(socket___0, & msg, 0);
#line 105
  if (n___0 == -1) {
#line 106
    tmp___0 = __errno_location();
#line 106
    tmp___1 = strerror(*tmp___0);
#line 106
    fatal("%s: recvmsg: %s", "mm_receive_fd", tmp___1);
  }
#line 107
  if (n___0 != 1) {
#line 108
    fatal("%s: recvmsg: expected received 1 got %ld", "mm_receive_fd", (long )n___0);
  }
#line 115
  if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 115
    cmsg = (struct cmsghdr *)msg.msg_control;
  } else {
#line 115
    cmsg = (struct cmsghdr *)((void *)0);
  }
#line 117
  if (cmsg->cmsg_type != 1) {
#line 118
    fatal("%s: expected type %d got %d", "mm_receive_fd", 1, cmsg->cmsg_type);
  }
#line 121
  fd = *((int *)(cmsg->__cmsg_data));
#line 123
  return (fd);
}
}
#line 1 "kexdhs.o"
#line 37 "kexdhs.c"
void kexdh_server(Kex *kex ) 
{ BIGNUM *shared_secret ;
  BIGNUM *dh_client_pub ;
  DH *dh ;
  Key *server_host_key ;
  u_char *kbuf ;
  u_char *hash ;
  u_char *signature ;
  u_char *server_host_key_blob ;
  u_int sbloblen ;
  u_int klen ;
  u_int kout ;
  u_int slen ;
  int _len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  u_int tmp___4 ;
  void *tmp___5 ;
  u_int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;

  {
#line 40
  shared_secret = (BIGNUM *)((void *)0);
#line 40
  dh_client_pub = (BIGNUM *)((void *)0);
#line 43
  signature = (u_char *)((void *)0);
#line 43
  server_host_key_blob = (u_char *)((void *)0);
#line 48
  dh = dh_new_group1();
#line 49
  dh_gen_key(dh, kex->we_need * 8);
#line 51
  debug("expecting SSH2_MSG_KEXDH_INIT");
#line 52
  packet_read_expect(30);
#line 54
  if ((unsigned int )kex->load_host_key == (unsigned int )((void *)0)) {
#line 55
    fatal("Cannot load hostkey");
  }
#line 56
  server_host_key = (*(kex->load_host_key))(kex->hostkey_type);
#line 57
  if ((unsigned int )server_host_key == (unsigned int )((void *)0)) {
#line 58
    fatal("Unsupported hostkey type %d", kex->hostkey_type);
  }
#line 61
  dh_client_pub = BN_new();
#line 61
  if ((unsigned int )dh_client_pub == (unsigned int )((void *)0)) {
#line 62
    fatal("dh_client_pub == NULL");
  }
#line 63
  packet_get_bignum2(dh_client_pub);
#line 64
  while (1) {
#line 64
    tmp = packet_remaining();
#line 64
    _len = tmp;
#line 64
    if (_len > 0) {
#line 64
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kexdhs.c",
            64);
#line 64
      packet_disconnect("Packet integrity error.");
    }
#line 64
    break;
  }
#line 79
  tmp___0 = dh_pub_is_valid(dh, dh_client_pub);
#line 79
  if (! tmp___0) {
#line 80
    packet_disconnect("bad client public DH value");
  }
#line 82
  tmp___1 = DH_size((DH const   *)dh);
#line 82
  klen = (unsigned int )tmp___1;
#line 83
  tmp___2 = xmalloc(klen);
#line 83
  kbuf = (u_char *)tmp___2;
#line 84
  tmp___3 = DH_compute_key(kbuf, (BIGNUM const   *)dh_client_pub, dh);
#line 84
  kout = (unsigned int )tmp___3;
#line 88
  shared_secret = BN_new();
#line 88
  if ((unsigned int )shared_secret == (unsigned int )((void *)0)) {
#line 89
    fatal("kexdh_server: BN_new failed");
  }
#line 90
  BN_bin2bn((unsigned char const   *)kbuf, (int )kout, shared_secret);
#line 91
  memset((void *)kbuf, 0, klen);
#line 92
  xfree((void *)kbuf);
#line 94
  key_to_blob((Key const   *)server_host_key, & server_host_key_blob, & sbloblen);
#line 97
  tmp___4 = buffer_len(& kex->my);
#line 97
  tmp___5 = buffer_ptr(& kex->my);
#line 97
  tmp___6 = buffer_len(& kex->peer);
#line 97
  tmp___7 = buffer_ptr(& kex->peer);
#line 97
  hash = kex_dh_hash(kex->client_version_string, kex->server_version_string, (char *)tmp___7,
                     (int )tmp___6, (char *)tmp___5, (int )tmp___4, server_host_key_blob,
                     (int )sbloblen, dh_client_pub, dh->pub_key, shared_secret);
#line 107
  BN_clear_free(dh_client_pub);
#line 111
  if ((unsigned int )kex->session_id == (unsigned int )((void *)0)) {
#line 112
    kex->session_id_len = 20U;
#line 113
    tmp___8 = xmalloc(kex->session_id_len);
#line 113
    kex->session_id = (u_char *)tmp___8;
#line 114
    memcpy((void * __restrict  )kex->session_id, (void const   * __restrict  )hash,
           kex->session_id_len);
  }
#line 119
  if (use_privsep) {
#line 119
    mm_key_sign(server_host_key, & signature, & slen, hash, 20U);
  } else {
#line 119
    key_sign((Key const   *)server_host_key, & signature, & slen, (u_char const   *)hash,
             20U);
  }
#line 124
  packet_start((unsigned char)31);
#line 125
  packet_put_string((void const   *)server_host_key_blob, sbloblen);
#line 126
  packet_put_bignum2(dh->pub_key);
#line 127
  packet_put_string((void const   *)signature, slen);
#line 128
  packet_send();
#line 130
  xfree((void *)signature);
#line 131
  xfree((void *)server_host_key_blob);
#line 133
  DH_free(dh);
#line 135
  kex_derive_keys(kex, hash, shared_secret);
#line 136
  BN_clear_free(shared_secret);
#line 137
  kex_finish(kex);
#line 138
  return;
}
}
#line 1 "kexgexs.o"
#line 39 "kexgexs.c"
void kexgex_server(Kex *kex ) 
{ BIGNUM *shared_secret ;
  BIGNUM *dh_client_pub ;
  Key *server_host_key ;
  DH *dh ;
  u_char *kbuf ;
  u_char *hash ;
  u_char *signature ;
  u_char *server_host_key_blob ;
  u_int sbloblen ;
  u_int klen ;
  u_int kout ;
  u_int slen ;
  int min ;
  int max ;
  int nbits ;
  int type ;
  u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  int _len ;
  int tmp___3 ;
  int _len___0 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  u_int tmp___11 ;
  void *tmp___12 ;
  u_int tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;

  {
#line 42
  shared_secret = (BIGNUM *)((void *)0);
#line 42
  dh_client_pub = (BIGNUM *)((void *)0);
#line 45
  signature = (u_char *)((void *)0);
#line 45
  server_host_key_blob = (u_char *)((void *)0);
#line 47
  min = -1;
#line 47
  max = -1;
#line 47
  nbits = -1;
#line 49
  if ((unsigned int )kex->load_host_key == (unsigned int )((void *)0)) {
#line 50
    fatal("Cannot load hostkey");
  }
#line 51
  server_host_key = (*(kex->load_host_key))(kex->hostkey_type);
#line 52
  if ((unsigned int )server_host_key == (unsigned int )((void *)0)) {
#line 53
    fatal("Unsupported hostkey type %d", kex->hostkey_type);
  }
#line 55
  type = packet_read();
#line 56
  switch (type) {
  case 34: 
#line 58
  debug("SSH2_MSG_KEX_DH_GEX_REQUEST received");
#line 59
  tmp = packet_get_int();
#line 59
  min = (int )tmp;
#line 60
  tmp___0 = packet_get_int();
#line 60
  nbits = (int )tmp___0;
#line 61
  tmp___1 = packet_get_int();
#line 61
  max = (int )tmp___1;
#line 62
  if (1024 > min) {
#line 62
    min = 1024;
  } else {
#line 62
    min = min;
  }
#line 63
  if (8192 < max) {
#line 63
    max = 8192;
  } else {
#line 63
    max = max;
  }
#line 64
  break;
  case 30: 
#line 66
  debug("SSH2_MSG_KEX_DH_GEX_REQUEST_OLD received");
#line 67
  tmp___2 = packet_get_int();
#line 67
  nbits = (int )tmp___2;
#line 68
  min = 1024;
#line 69
  max = 8192;
#line 71
  break;
  default: 
#line 73
  fatal("protocol error during kex, no DH_GEX_REQUEST: %d", type);
  }
#line 75
  while (1) {
#line 75
    tmp___3 = packet_remaining();
#line 75
    _len = tmp___3;
#line 75
    if (_len > 0) {
#line 75
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kexgexs.c",
            75);
#line 75
      packet_disconnect("Packet integrity error.");
    }
#line 75
    break;
  }
#line 77
  if (max < min) {
#line 78
    fatal("DH_GEX_REQUEST, bad parameters: %d !< %d !< %d", min, nbits, max);
  } else {
#line 77
    if (nbits < min) {
#line 78
      fatal("DH_GEX_REQUEST, bad parameters: %d !< %d !< %d", min, nbits, max);
    } else {
#line 77
      if (max < nbits) {
#line 78
        fatal("DH_GEX_REQUEST, bad parameters: %d !< %d !< %d", min, nbits, max);
      }
    }
  }
#line 82
  if (use_privsep) {
#line 82
    dh = mm_choose_dh(min, nbits, max);
  } else {
#line 82
    dh = choose_dh(min, nbits, max);
  }
#line 83
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 84
    packet_disconnect("Protocol error: no matching DH grp found");
  }
#line 86
  debug("SSH2_MSG_KEX_DH_GEX_GROUP sent");
#line 87
  packet_start((unsigned char)31);
#line 88
  packet_put_bignum2(dh->p);
#line 89
  packet_put_bignum2(dh->g);
#line 90
  packet_send();
#line 93
  packet_write_wait();
#line 96
  dh_gen_key(dh, kex->we_need * 8);
#line 98
  debug("expecting SSH2_MSG_KEX_DH_GEX_INIT");
#line 99
  packet_read_expect(32);
#line 102
  dh_client_pub = BN_new();
#line 102
  if ((unsigned int )dh_client_pub == (unsigned int )((void *)0)) {
#line 103
    fatal("dh_client_pub == NULL");
  }
#line 104
  packet_get_bignum2(dh_client_pub);
#line 105
  while (1) {
#line 105
    tmp___6 = packet_remaining();
#line 105
    _len___0 = tmp___6;
#line 105
    if (_len___0 > 0) {
#line 105
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "kexgexs.c",
            105);
#line 105
      packet_disconnect("Packet integrity error.");
    }
#line 105
    break;
  }
#line 120
  tmp___7 = dh_pub_is_valid(dh, dh_client_pub);
#line 120
  if (! tmp___7) {
#line 121
    packet_disconnect("bad client public DH value");
  }
#line 123
  tmp___8 = DH_size((DH const   *)dh);
#line 123
  klen = (unsigned int )tmp___8;
#line 124
  tmp___9 = xmalloc(klen);
#line 124
  kbuf = (u_char *)tmp___9;
#line 125
  tmp___10 = DH_compute_key(kbuf, (BIGNUM const   *)dh_client_pub, dh);
#line 125
  kout = (unsigned int )tmp___10;
#line 129
  shared_secret = BN_new();
#line 129
  if ((unsigned int )shared_secret == (unsigned int )((void *)0)) {
#line 130
    fatal("kexgex_server: BN_new failed");
  }
#line 131
  BN_bin2bn((unsigned char const   *)kbuf, (int )kout, shared_secret);
#line 132
  memset((void *)kbuf, 0, klen);
#line 133
  xfree((void *)kbuf);
#line 135
  key_to_blob((Key const   *)server_host_key, & server_host_key_blob, & sbloblen);
#line 137
  if (type == 30) {
#line 138
    max = -1;
#line 138
    min = max;
  }
#line 141
  tmp___11 = buffer_len(& kex->my);
#line 141
  tmp___12 = buffer_ptr(& kex->my);
#line 141
  tmp___13 = buffer_len(& kex->peer);
#line 141
  tmp___14 = buffer_ptr(& kex->peer);
#line 141
  hash = kexgex_hash(kex->client_version_string, kex->server_version_string, (char *)tmp___14,
                     (int )tmp___13, (char *)tmp___12, (int )tmp___11, server_host_key_blob,
                     (int )sbloblen, min, nbits, max, dh->p, dh->g, dh_client_pub,
                     dh->pub_key, shared_secret);
#line 153
  BN_clear_free(dh_client_pub);
#line 157
  if ((unsigned int )kex->session_id == (unsigned int )((void *)0)) {
#line 158
    kex->session_id_len = 20U;
#line 159
    tmp___15 = xmalloc(kex->session_id_len);
#line 159
    kex->session_id = (u_char *)tmp___15;
#line 160
    memcpy((void * __restrict  )kex->session_id, (void const   * __restrict  )hash,
           kex->session_id_len);
  }
#line 165
  if (use_privsep) {
#line 165
    mm_key_sign(server_host_key, & signature, & slen, hash, 20U);
  } else {
#line 165
    key_sign((Key const   *)server_host_key, & signature, & slen, (u_char const   *)hash,
             20U);
  }
#line 170
  debug("SSH2_MSG_KEX_DH_GEX_REPLY sent");
#line 171
  packet_start((unsigned char)33);
#line 172
  packet_put_string((void const   *)server_host_key_blob, sbloblen);
#line 173
  packet_put_bignum2(dh->pub_key);
#line 174
  packet_put_string((void const   *)signature, slen);
#line 175
  packet_send();
#line 177
  xfree((void *)signature);
#line 178
  xfree((void *)server_host_key_blob);
#line 180
  DH_free(dh);
#line 182
  kex_derive_keys(kex, hash, shared_secret);
#line 183
  BN_clear_free(shared_secret);
#line 185
  kex_finish(kex);
#line 186
  return;
}
}
#line 1 "auth-krb5.o"
#line 1 "auth2-gss.o"
#line 1 "gss-serv.o"
#line 1 "gss-serv-krb5.o"
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned int  ) ;  */
#line 1 "loginrec.o"
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval * __restrict  __tv ,
                                                      __timezone_ptr_t __tz )  __attribute__((__nonnull__(1))) ;
#line 46 "/usr/include/utmp.h"
extern  __attribute__((__nothrow__)) void login(struct utmp  const  *__entry ) ;
#line 49
extern  __attribute__((__nothrow__)) int logout(char const   *__ut_line ) ;
#line 52
extern  __attribute__((__nothrow__)) void logwtmp(char const   *__ut_line , char const   *__ut_name ,
                                                  char const   *__ut_host ) ;
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 100 "loginrec.h"
int login_init_entry(struct logininfo *li , int pid , char const   *username , char const   *hostname ,
                     char const   *line ) ;
#line 103
void login_set_current_time(struct logininfo *li ) ;
#line 115
int login_write(struct logininfo *li ) ;
#line 128
unsigned int login_get_lastlog_time(int uid ) ;
#line 131
char *line_fullname(char *dst , char const   *src , int dstsize ) ;
#line 132
char *line_stripname(char *dst , char const   *src , int dstsize ) ;
#line 133
char *line_abbrevname(char *dst , char const   *src , int dstsize ) ;
#line 176 "loginrec.c"
void set_utmp_time(struct logininfo *li , struct utmp *ut ) ;
#line 177
void construct_utmp(struct logininfo *li , struct utmp *ut ) ;
#line 189
int lastlog_write_entry(struct logininfo *li ) ;
#line 190
int syslogin_write_entry(struct logininfo *li ) ;
#line 192
int getlast_entry(struct logininfo *li ) ;
#line 193
int lastlog_get_entry(struct logininfo *li ) ;
#line 213 "loginrec.c"
int login_login(struct logininfo *li ) 
{ int tmp ;

  {
#line 216
  li->type = (short)7;
#line 217
  tmp = login_write(li);
#line 217
  return (tmp);
}
}
#line 229 "loginrec.c"
int login_logout(struct logininfo *li ) 
{ int tmp ;

  {
#line 232
  li->type = (short)8;
#line 233
  tmp = login_write(li);
#line 233
  return (tmp);
}
}
#line 253 "loginrec.c"
unsigned int login_get_lastlog_time(int uid ) 
{ struct logininfo li ;
  struct logininfo *tmp ;

  {
#line 258
  tmp = login_get_lastlog(& li, uid);
#line 258
  if (tmp) {
#line 259
    return (li.tv_sec);
  } else {
#line 261
    return (0U);
  }
}
}
#line 277 "loginrec.c"
struct logininfo *login_get_lastlog(struct logininfo *li , int uid ) 
{ struct passwd *pw ;
  int tmp ;

  {
#line 282
  memset((void *)li, '\000', sizeof(*li));
#line 283
  li->uid = uid;
#line 290
  pw = getpwuid((unsigned int )uid);
#line 291
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 292
    fatal("login_get_lastlog: Cannot find account for uid %i", uid);
  }
#line 296
  strlcpy(li->username, (char const   *)pw->pw_name, sizeof(li->username));
#line 298
  tmp = getlast_entry(li);
#line 298
  if (tmp) {
#line 299
    return (li);
  } else {
#line 301
    return ((struct logininfo *)((void *)0));
  }
}
}
#line 314 "loginrec.c"
struct logininfo *login_alloc_entry(int pid , char const   *username , char const   *hostname ,
                                    char const   *line ) 
{ struct logininfo *newli ;
  void *tmp ;

  {
#line 320
  tmp = xmalloc(sizeof(*newli));
#line 320
  newli = (struct logininfo *)tmp;
#line 321
  login_init_entry(newli, pid, username, hostname, line);
#line 322
  return (newli);
}
}
#line 327 "loginrec.c"
void login_free_entry(struct logininfo *li ) 
{ 

  {
#line 330
  xfree((void *)li);
#line 331
  return;
}
}
#line 342 "loginrec.c"
int login_init_entry(struct logininfo *li , int pid , char const   *username , char const   *hostname ,
                     char const   *line ) 
{ struct passwd *pw ;

  {
#line 348
  memset((void *)li, 0, sizeof(*li));
#line 350
  li->pid = pid;
#line 353
  if (line) {
#line 354
    line_fullname(li->line, line, (int )sizeof(li->line));
  }
#line 356
  if (username) {
#line 357
    strlcpy(li->username, username, sizeof(li->username));
#line 358
    pw = getpwnam((char const   *)(li->username));
#line 359
    if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 360
      fatal("login_init_entry: Cannot find user \"%s\"", li->username);
    }
#line 361
    li->uid = (int )pw->pw_uid;
  }
#line 364
  if (hostname) {
#line 365
    strlcpy(li->hostname, hostname, sizeof(li->hostname));
  }
#line 367
  return (1);
}
}
#line 376 "loginrec.c"
void login_set_current_time(struct logininfo *li ) 
{ struct timeval tv ;

  {
#line 381
  gettimeofday((struct timeval * __restrict  )(& tv), (struct timezone * __restrict  )((void *)0));
#line 383
  li->tv_sec = (unsigned int )tv.tv_sec;
#line 384
  li->tv_usec = (unsigned int )tv.tv_usec;
#line 385
  return;
}
}
#line 388 "loginrec.c"
void login_set_addr(struct logininfo *li , struct sockaddr  const  *sa , unsigned int sa_size ) 
{ unsigned int bufsize ;

  {
#line 392
  bufsize = sa_size;
#line 395
  if (sizeof(li->hostaddr) < sa_size) {
#line 396
    bufsize = sizeof(li->hostaddr);
  }
#line 398
  memcpy((void * __restrict  )((void *)(& li->hostaddr.sa)), (void const   * __restrict  )((void const   *)sa),
         bufsize);
#line 399
  return;
}
}
#line 406 "loginrec.c"
int login_write(struct logininfo *li ) 
{ __uid_t tmp ;

  {
#line 410
  tmp = geteuid();
#line 410
  if ((int )tmp != 0) {
#line 411
    logit("Attempt to write login records by non-root user (aborting)");
#line 412
    return (1);
  }
#line 417
  login_set_current_time(li);
#line 419
  syslogin_write_entry(li);
#line 422
  if ((int )li->type == 7) {
#line 423
    lastlog_write_entry(li);
  }
#line 438
  return (0);
}
}
#line 469 "loginrec.c"
int getlast_entry(struct logininfo *li ) 
{ int tmp ;

  {
#line 473
  tmp = lastlog_get_entry(li);
#line 473
  return (tmp);
}
}
#line 520 "loginrec.c"
char *line_fullname(char *dst , char const   *src , int dstsize ) 
{ int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  size_t tmp___25 ;

  {
#line 523
  memset((void *)dst, '\000', (unsigned int )dstsize);
#line 524
  if (0) {
#line 524
    if (0) {
#line 524
      __s1_len___0 = strlen(src);
#line 524
      __s2_len___0 = strlen("/dev/");
#line 524
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 524
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 524
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 524
            tmp___22 = 1;
          } else {
#line 524
            if (__s2_len___0 >= 4U) {
#line 524
              tmp___22 = 1;
            } else {
#line 524
              tmp___22 = 0;
            }
          }
        } else {
#line 524
          tmp___22 = 0;
        }
      }
#line 524
      if (tmp___22) {
#line 524
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 524
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 524
        tmp___18 = tmp___21;
      }
    } else {
#line 524
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 524
      tmp___18 = tmp___21;
    }
#line 524
    tmp___12 = tmp___18;
  } else {
#line 524
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 524
  if (tmp___12 == 0) {
#line 525
    strlcpy(dst, src, (unsigned int )dstsize);
  } else {
#line 524
    tmp___25 = strlen(src);
#line 524
    if ((size_t )dstsize < tmp___25 + 5U) {
#line 525
      strlcpy(dst, src, (unsigned int )dstsize);
    } else {
#line 527
      strlcpy(dst, "/dev/", (unsigned int )dstsize);
#line 528
      strlcat(dst, src, (unsigned int )dstsize);
    }
  }
#line 530
  return (dst);
}
}
#line 534 "loginrec.c"
char *line_stripname(char *dst , char const   *src , int dstsize ) 
{ int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 537
  memset((void *)dst, '\000', (unsigned int )dstsize);
#line 538
  if (0) {
#line 538
    if (0) {
#line 538
      __s1_len___0 = strlen(src);
#line 538
      __s2_len___0 = strlen("/dev/");
#line 538
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 538
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 538
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 538
            tmp___22 = 1;
          } else {
#line 538
            if (__s2_len___0 >= 4U) {
#line 538
              tmp___22 = 1;
            } else {
#line 538
              tmp___22 = 0;
            }
          }
        } else {
#line 538
          tmp___22 = 0;
        }
      }
#line 538
      if (tmp___22) {
#line 538
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 538
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 538
        tmp___18 = tmp___21;
      }
    } else {
#line 538
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 538
      tmp___18 = tmp___21;
    }
#line 538
    tmp___12 = tmp___18;
  } else {
#line 538
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 538
  if (tmp___12 == 0) {
#line 539
    strlcpy(dst, src + 5, (unsigned int )dstsize);
  } else {
#line 541
    strlcpy(dst, src, (unsigned int )dstsize);
  }
#line 542
  return (dst);
}
}
#line 551 "loginrec.c"
char *line_abbrevname(char *dst , char const   *src , int dstsize ) 
{ size_t len ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 556
  memset((void *)dst, '\000', (unsigned int )dstsize);
#line 559
  if (0) {
#line 559
    if (0) {
#line 559
      __s1_len___0 = strlen(src);
#line 559
      __s2_len___0 = strlen("/dev/");
#line 559
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 559
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 559
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 559
            tmp___22 = 1;
          } else {
#line 559
            if (__s2_len___0 >= 4U) {
#line 559
              tmp___22 = 1;
            } else {
#line 559
              tmp___22 = 0;
            }
          }
        } else {
#line 559
          tmp___22 = 0;
        }
      }
#line 559
      if (tmp___22) {
#line 559
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 559
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 559
        tmp___18 = tmp___21;
      }
    } else {
#line 559
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 559
      tmp___18 = tmp___21;
    }
#line 559
    tmp___12 = tmp___18;
  } else {
#line 559
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 559
  if (tmp___12 == 0) {
#line 560
    src += 5;
  }
#line 567
  len = strlen(src);
#line 569
  if (len > 0U) {
#line 570
    if ((int )len - dstsize > 0) {
#line 571
      src += (int )len - dstsize;
    }
#line 574
    __builtin_strncpy(dst, src, (unsigned int )dstsize);
  }
#line 577
  return (dst);
}
}
#line 590 "loginrec.c"
void set_utmp_time(struct logininfo *li , struct utmp *ut ) 
{ 

  {
#line 594
  ut->ut_tv.tv_sec = (long )li->tv_sec;
#line 595
  ut->ut_tv.tv_usec = (long )li->tv_usec;
#line 601
  return;
}
}
#line 603 "loginrec.c"
void construct_utmp(struct logininfo *li , struct utmp *ut ) 
{ struct sockaddr_in6 *sa6 ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  register unsigned int __v ;
  register unsigned int __x ;

  {
#line 610
  memset((void *)ut, '\000', sizeof(*ut));
#line 615
  line_abbrevname(ut->ut_id, (char const   *)(li->line), (int )sizeof(ut->ut_id));
#line 620
  switch ((int )li->type) {
  case 7: 
#line 622
  ut->ut_type = (short)7;
#line 626
  break;
  case 8: 
#line 628
  ut->ut_type = (short)8;
#line 632
  break;
  }
#line 635
  set_utmp_time(li, ut);
#line 637
  line_stripname(ut->ut_line, (char const   *)(li->line), (int )sizeof(ut->ut_line));
#line 640
  ut->ut_pid = li->pid;
#line 644
  if ((int )li->type == 8) {
#line 645
    return;
  }
#line 653
  if (sizeof(ut->ut_user) < sizeof(li->username)) {
#line 653
    tmp = sizeof(ut->ut_user);
  } else {
#line 653
    tmp = sizeof(li->username);
  }
#line 653
  __builtin_strncpy(ut->ut_user, (char const   *)(li->username), tmp);
#line 655
  if (sizeof(ut->ut_host) < sizeof(li->hostname)) {
#line 655
    tmp___0 = sizeof(ut->ut_host);
  } else {
#line 655
    tmp___0 = sizeof(li->hostname);
  }
#line 655
  __builtin_strncpy(ut->ut_host, (char const   *)(li->hostname), tmp___0);
#line 659
  if ((int )li->hostaddr.sa.sa_family == 2) {
#line 660
    ut->ut_addr_v6[0] = (int )li->hostaddr.sa_in.sin_addr.s_addr;
  }
#line 664
  if ((int )li->hostaddr.sa.sa_family == 10) {
#line 665
    sa6 = (struct sockaddr_in6 *)(& li->hostaddr.sa);
#line 666
    memcpy((void * __restrict  )(ut->ut_addr_v6), (void const   * __restrict  )(sa6->sin6_addr.in6_u.u6_addr8),
           16U);
#line 667
    if (*((uint32_t const   *)(& sa6->sin6_addr) + 0) == 0U) {
#line 667
      if (*((uint32_t const   *)(& sa6->sin6_addr) + 1) == 0U) {
#line 667
        __x = 65535U;
#line 667
        __asm__  ("rorw $8, %w0;"
                  "rorl $16, %0;"
                  "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 667
        if (*((uint32_t const   *)(& sa6->sin6_addr) + 2) == (uint32_t const   )__v) {
#line 668
          ut->ut_addr_v6[0] = ut->ut_addr_v6[3];
#line 669
          ut->ut_addr_v6[1] = 0;
#line 670
          ut->ut_addr_v6[2] = 0;
#line 671
          ut->ut_addr_v6[3] = 0;
        }
      }
    }
  }
#line 675
  return;
}
}
#line 1337 "loginrec.c"
static int syslogin_perform_login(struct logininfo *li ) 
{ struct utmp *ut ;
  void *tmp ;

  {
#line 1342
  tmp = malloc(sizeof(*ut));
#line 1342
  ut = (struct utmp *)tmp;
#line 1342
  if (! ut) {
#line 1343
    logit("syslogin_perform_login: couldn\'t malloc()");
#line 1344
    return (0);
  }
#line 1346
  construct_utmp(li, ut);
#line 1347
  login((struct utmp  const  *)ut);
#line 1348
  free((void *)ut);
#line 1350
  return (1);
}
}
#line 1353 "loginrec.c"
static int syslogin_perform_logout(struct logininfo *li ) 
{ char line[32] ;
  int tmp ;

  {
#line 1359
  line_stripname(line, (char const   *)(li->line), (int )sizeof(line));
#line 1361
  tmp = logout((char const   *)(line));
#line 1361
  if (tmp) {
#line 1365
    logwtmp((char const   *)(line), "", "");
  } else {
#line 1362
    logit("syslogin_perform_logout: logout() returned an error");
  }
#line 1373
  return (1);
}
}
#line 1376 "loginrec.c"
int syslogin_write_entry(struct logininfo *li ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 1379
  switch ((int )li->type) {
  case 7: 
#line 1381
  tmp = syslogin_perform_login(li);
#line 1381
  return (tmp);
  case 8: 
#line 1383
  tmp___0 = syslogin_perform_logout(li);
#line 1383
  return (tmp___0);
  default: 
#line 1385
  logit("syslogin_write_entry: Invalid type field");
#line 1386
  return (0);
  }
}
}
#line 1402 "loginrec.c"
static void lastlog_construct(struct logininfo *li , struct lastlog *last ) 
{ unsigned int tmp ;

  {
#line 1406
  memset((void *)last, '\000', sizeof(*last));
#line 1408
  line_stripname(last->ll_line, (char const   *)(li->line), (int )sizeof(last->ll_line));
#line 1409
  if (sizeof(last->ll_host) < sizeof(li->hostname)) {
#line 1409
    tmp = sizeof(last->ll_host);
  } else {
#line 1409
    tmp = sizeof(li->hostname);
  }
#line 1409
  strlcpy(last->ll_host, (char const   *)(li->hostname), tmp);
#line 1411
  last->ll_time = (long )li->tv_sec;
#line 1412
  return;
}
}
#line 1414 "loginrec.c"
static int lastlog_filetype(char *filename ) 
{ struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1419
  tmp___1 = stat((char const   * __restrict  )"/var/log/lastlog", (struct stat * __restrict  )(& st));
#line 1419
  if (tmp___1 != 0) {
#line 1420
    tmp = __errno_location();
#line 1420
    tmp___0 = strerror(*tmp);
#line 1420
    logit("lastlog_perform_login: Couldn\'t stat %s: %s", "/var/log/lastlog", tmp___0);
#line 1422
    return (0);
  }
#line 1424
  if ((st.st_mode & 61440U) == 16384U) {
#line 1425
    return (2);
  } else {
#line 1426
    if ((st.st_mode & 61440U) == 32768U) {
#line 1427
      return (1);
    } else {
#line 1429
      return (3);
    }
  }
}
}
#line 1434 "loginrec.c"
static int lastlog_openseek(struct logininfo *li , int *fd , int filemode ) 
{ off_t offset ;
  int type ;
  char lastlog_file[1024] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  __off64_t tmp___3 ;

  {
#line 1441
  type = lastlog_filetype((char *)"/var/log/lastlog");
#line 1442
  switch (type) {
  case 1: 
#line 1444
  strlcpy(lastlog_file, "/var/log/lastlog", sizeof(lastlog_file));
#line 1445
  break;
  case 2: 
#line 1447
  snprintf((char * __restrict  )(lastlog_file), sizeof(lastlog_file), (char const   * __restrict  )"%s/%s",
           "/var/log/lastlog", li->username);
#line 1449
  break;
  default: 
#line 1451
  logit("lastlog_openseek: %.100s is not a file or directory!", "/var/log/lastlog");
#line 1453
  return (0);
  }
#line 1456
  *fd = open((char const   *)(lastlog_file), filemode, 384);
#line 1457
  if (*fd < 0) {
#line 1458
    tmp = __errno_location();
#line 1458
    tmp___0 = strerror(*tmp);
#line 1458
    debug("lastlog_openseek: Couldn\'t open %s: %s", lastlog_file, tmp___0);
#line 1460
    return (0);
  }
#line 1463
  if (type == 1) {
#line 1465
    offset = (long long )((unsigned long )((long )li->uid) * (unsigned long )sizeof(struct lastlog ));
#line 1467
    tmp___3 = lseek(*fd, offset, 0);
#line 1467
    if (tmp___3 != offset) {
#line 1468
      tmp___1 = __errno_location();
#line 1468
      tmp___2 = strerror(*tmp___1);
#line 1468
      logit("lastlog_openseek: %s->lseek(): %s", lastlog_file, tmp___2);
#line 1470
      return (0);
    }
  }
#line 1474
  return (1);
}
}
#line 1477 "loginrec.c"
static int lastlog_perform_login(struct logininfo *li ) 
{ struct lastlog last ;
  int fd ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 1484
  lastlog_construct(li, & last);
#line 1486
  tmp = lastlog_openseek(li, & fd, 66);
#line 1486
  if (! tmp) {
#line 1487
    return (0);
  }
#line 1490
  tmp___2 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), fd, (void *)(& last),
                     sizeof(last));
#line 1490
  if ((unsigned int )tmp___2 != sizeof(last)) {
#line 1491
    close(fd);
#line 1492
    tmp___0 = __errno_location();
#line 1492
    tmp___1 = strerror(*tmp___0);
#line 1492
    logit("lastlog_write_filemode: Error writing to %s: %s", "/var/log/lastlog", tmp___1);
#line 1494
    return (0);
  }
#line 1497
  close(fd);
#line 1498
  return (1);
}
}
#line 1501 "loginrec.c"
int lastlog_write_entry(struct logininfo *li ) 
{ int tmp ;

  {
#line 1504
  switch ((int )li->type) {
  case 7: 
#line 1506
  tmp = lastlog_perform_login(li);
#line 1506
  return (tmp);
  default: 
#line 1508
  logit("lastlog_write_entry: Invalid type field");
#line 1509
  return (0);
  }
}
}
#line 1513 "loginrec.c"
static void lastlog_populate_entry(struct logininfo *li , struct lastlog *last ) 
{ unsigned int tmp ;

  {
#line 1516
  line_fullname(li->line, (char const   *)(last->ll_line), (int )sizeof(li->line));
#line 1517
  if (sizeof(li->hostname) < sizeof(last->ll_host)) {
#line 1517
    tmp = sizeof(li->hostname);
  } else {
#line 1517
    tmp = sizeof(last->ll_host);
  }
#line 1517
  strlcpy(li->hostname, (char const   *)(last->ll_host), tmp);
#line 1519
  li->tv_sec = (unsigned int )last->ll_time;
#line 1520
  return;
}
}
#line 1522 "loginrec.c"
int lastlog_get_entry(struct logininfo *li ) 
{ struct lastlog last ;
  int fd ;
  int ret ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 1528
  tmp = lastlog_openseek(li, & fd, 0);
#line 1528
  if (! tmp) {
#line 1529
    return (0);
  }
#line 1531
  ret = atomicio(& read, fd, (void *)(& last), sizeof(last));
#line 1532
  close(fd);
#line 1534
  switch (ret) {
  case 0: 
#line 1536
  memset((void *)(& last), '\000', sizeof(last));
  case sizeof(last): 
#line 1539
  lastlog_populate_entry(li, & last);
#line 1540
  return (1);
  case -1: 
#line 1542
  tmp___0 = __errno_location();
#line 1542
  tmp___1 = strerror(*tmp___0);
#line 1542
  error("%s: Error reading from %s: %s", "lastlog_get_entry", "/var/log/lastlog",
        tmp___1);
#line 1544
  return (0);
  default: 
#line 1546
  error("%s: Error reading from %s: Expecting %d, got %d", "lastlog_get_entry", "/var/log/lastlog",
        sizeof(last), ret);
#line 1548
  return (0);
  }
#line 1552
  return (0);
}
}
#line 1 "auth-pam.o"
#line 1 "auth-shadow.o"
#line 48 "auth-shadow.c"
int auth_shadow_acctexpired(struct spwd *spw ) 
{ time_t today ;
  int daysleft ;
  char buf___1[256] ;
  time_t tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;

  {
#line 55
  tmp = time((time_t *)((void *)0));
#line 55
  today = tmp / 86400L;
#line 56
  daysleft = (int )(spw->sp_expire - today);
#line 57
  debug3("%s: today %d sp_expire %d days left %d", "auth_shadow_acctexpired", (int )today,
         (int )spw->sp_expire, daysleft);
#line 60
  if (spw->sp_expire == -1L) {
#line 61
    debug3("account expiration disabled");
  } else {
#line 62
    if (daysleft < 0) {
#line 63
      logit("Account %.100s has expired", spw->sp_namp);
#line 64
      return (1);
    } else {
#line 65
      if ((long )daysleft <= spw->sp_warn) {
#line 66
        debug3("account will expire in %d days", daysleft);
#line 67
        if (daysleft == 1) {
#line 67
          tmp___0 = "";
        } else {
#line 67
          tmp___0 = "s";
        }
#line 67
        snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"Your account will expire in %d day%s.\n",
                 daysleft, tmp___0);
#line 70
        tmp___1 = strlen((char const   *)(buf___1));
#line 70
        buffer_append(& loginmsg, (void const   *)(buf___1), tmp___1);
      }
    }
  }
#line 73
  return (0);
}
}
#line 80 "auth-shadow.c"
int auth_shadow_pwexpired(Authctxt *ctxt ) 
{ struct spwd *spw ;
  char const   *user ;
  char buf___1[256] ;
  time_t today ;
  int daysleft ;
  int disabled ;
  time_t tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;

  {
#line 83
  spw = (struct spwd *)((void *)0);
#line 84
  user = (char const   *)(ctxt->pw)->pw_name;
#line 87
  disabled = 0;
#line 89
  spw = getspnam((char const   *)((char *)user));
#line 89
  if ((unsigned int )spw == (unsigned int )((void *)0)) {
#line 90
    error("Could not get shadow information for %.100s", user);
#line 91
    return (0);
  }
#line 94
  tmp = time((time_t *)((void *)0));
#line 94
  today = tmp / 86400L;
#line 95
  debug3("%s: today %d sp_lstchg %d sp_max %d", "auth_shadow_pwexpired", (int )today,
         (int )spw->sp_lstchg, (int )spw->sp_max);
#line 114
  daysleft = (int )((spw->sp_lstchg + spw->sp_max) - today);
#line 115
  if (disabled) {
#line 116
    debug3("password expiration disabled");
  } else {
#line 117
    if (spw->sp_lstchg == 0L) {
#line 118
      logit("User %.100s password has expired (root forced)", user);
#line 119
      return (1);
    } else {
#line 120
      if (spw->sp_max == -1L) {
#line 121
        debug3("password expiration disabled");
      } else {
#line 122
        if (daysleft < 0) {
#line 123
          logit("User %.100s password has expired (password aged)", user);
#line 124
          return (1);
        } else {
#line 125
          if ((long )daysleft <= spw->sp_warn) {
#line 126
            debug3("password will expire in %d days", daysleft);
#line 127
            if (daysleft == 1) {
#line 127
              tmp___0 = "";
            } else {
#line 127
              tmp___0 = "s";
            }
#line 127
            snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"Your password will expire in %d day%s.\n",
                     daysleft, tmp___0);
#line 130
            tmp___1 = strlen((char const   *)(buf___1));
#line 130
            buffer_append(& loginmsg, (void const   *)(buf___1), tmp___1);
          }
        }
      }
    }
  }
#line 133
  return (0);
}
}
#line 1 "auth-sia.o"
#line 1 "md5crypt.o"
