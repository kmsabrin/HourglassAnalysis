/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

#line 214 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stddef.h"
typedef unsigned int size_t;
#line 71 "/usr/include/openssl/rc4.h"
struct rc4_key_st {
   unsigned int x ;
   unsigned int y ;
   unsigned int data[256] ;
};
#line 71 "/usr/include/openssl/rc4.h"
typedef struct rc4_key_st RC4_KEY;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 146 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 195 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 245 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 302 "/usr/include/bits/socket.h"
struct ucred {
   pid_t pid ;
   uid_t uid ;
   gid_t gid ;
};
#line 148 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 28 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_12 {
   unsigned long __val[1024U / (8U * sizeof(unsigned long ))] ;
};
#line 28 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_12 __sigset_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 33 "/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__kill_27 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__timer_28 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__rt_29 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_30 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_31 {
   void *si_addr ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_32 {
   long si_band ;
   int si_fd ;
};
#line 51 "/usr/include/bits/siginfo.h"
union __anonunion__sifields_26 {
   int _pad[128U / sizeof(int ) - 3U] ;
   struct __anonstruct__kill_27 _kill ;
   struct __anonstruct__timer_28 _timer ;
   struct __anonstruct__rt_29 _rt ;
   struct __anonstruct__sigchld_30 _sigchld ;
   struct __anonstruct__sigfault_31 _sigfault ;
   struct __anonstruct__sigpoll_32 _sigpoll ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_26 _sifields ;
};
#line 51 "/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 25 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_44 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_44 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 93 "./openbsd-compat/bsd-misc.h"
typedef void (*mysig_t)(int  );
#line 59 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 60 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 141 "/usr/include/bits/types.h"
typedef __u_quad_t __ino64_t;
#line 145 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino64_t d_ino ;
   __off64_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 40 "/usr/include/shadow.h"
struct spwd {
   char *sp_namp ;
   char *sp_pwdp ;
   long sp_lstchg ;
   long sp_min ;
   long sp_max ;
   long sp_warn ;
   long sp_inact ;
   long sp_expire ;
   unsigned long sp_flag ;
};
#line 34 "/usr/include/bits/types.h"
typedef unsigned char __u_char;
#line 35 "/usr/include/bits/types.h"
typedef unsigned short __u_short;
#line 36 "/usr/include/bits/types.h"
typedef unsigned int __u_int;
#line 35 "/usr/include/sys/types.h"
typedef __u_char u_char;
#line 36 "/usr/include/sys/types.h"
typedef __u_short u_short;
#line 37 "/usr/include/sys/types.h"
typedef __u_int u_int;
#line 201 "/usr/include/sys/types.h"
typedef unsigned char u_int8_t;
#line 203 "/usr/include/sys/types.h"
typedef unsigned int u_int32_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 145 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 136 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 137 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 108 "/usr/include/netinet/ip.h"
struct ip {
   unsigned int ip_hl : 4 ;
   unsigned int ip_v : 4 ;
   u_int8_t ip_tos ;
   u_short ip_len ;
   u_short ip_id ;
   u_short ip_off ;
   u_int8_t ip_ttl ;
   u_int8_t ip_p ;
   u_short ip_sum ;
   struct in_addr ip_src ;
   struct in_addr ip_dst ;
};
#line 19 "./buffer.h"
struct __anonstruct_Buffer_74 {
   u_char *buf ;
   u_int alloc ;
   u_int offset ;
   u_int end ;
};
#line 19 "./buffer.h"
typedef struct __anonstruct_Buffer_74 Buffer;
#line 62 "./channels.h"
struct Channel;
#line 65 "./channels.h"
typedef void channel_callback_fn(int  , void * );
#line 66 "./channels.h"
typedef int channel_infilter_fn(struct Channel * , char * , int  );
#line 67 "./channels.h"
typedef u_char *channel_outfilter_fn(struct Channel * , u_char ** , u_int * );
#line 69 "./channels.h"
struct Channel {
   int type ;
   int self ;
   int remote_id ;
   u_int istate ;
   u_int ostate ;
   int flags ;
   int rfd ;
   int wfd ;
   int efd ;
   int sock ;
   int ctl_fd ;
   int isatty ;
   int wfd_isatty ;
   int client_tty ;
   int force_drain ;
   int delayed ;
   Buffer input ;
   Buffer output ;
   Buffer extended ;
   char path[256] ;
   int listening_port ;
   int host_port ;
   char *remote_name ;
   u_int remote_window ;
   u_int remote_maxpacket ;
   u_int local_window ;
   u_int local_window_max ;
   u_int local_consumed ;
   u_int local_maxpacket ;
   int extended_usage ;
   int single_connection ;
   char *ctype ;
   channel_callback_fn *confirm ;
   void *confirm_ctx ;
   channel_callback_fn *detach_user ;
   int detach_close ;
   channel_infilter_fn *input_filter ;
   channel_outfilter_fn *output_filter ;
   int datagram ;
};
#line 4 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_80 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 4 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_80 sync_serial_settings;
#line 10 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_81 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 10 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_81 te1_settings;
#line 17 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_82 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 17 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_82 raw_hdlc_proto;
#line 22 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_83 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 22 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_83 fr_proto;
#line 32 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_84 {
   unsigned int dlci ;
};
#line 32 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_84 fr_proto_pvc;
#line 36 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_85 {
   unsigned int dlci ;
   char master[16] ;
};
#line 36 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_85 fr_proto_pvc_info;
#line 41 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_86 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 41 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_86 cisco_proto;
#line 118 "/usr/include/linux/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 129 "/usr/include/linux/if.h"
union __anonunion_ifs_ifsu_89 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 129 "/usr/include/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_89 ifs_ifsu ;
};
#line 154 "/usr/include/linux/if.h"
union __anonunion_ifr_ifrn_90 {
   char ifrn_name[16] ;
};
#line 154 "/usr/include/linux/if.h"
union __anonunion_ifr_ifru_91 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 154 "/usr/include/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_90 ifr_ifrn ;
   union __anonunion_ifr_ifru_91 ifr_ifru ;
};
#line 37 "openbsd-compat/strtonum.c"
struct errval {
   char const   *errstr ;
   int err ;
};
#line 45 "/usr/include/bits/types.h"
typedef unsigned int __uint32_t;
#line 202 "/usr/include/sys/types.h"
typedef unsigned short u_int16_t;
#line 162 "/usr/include/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   __uint32_t __ss_align ;
   char __ss_padding[128U - 2U * sizeof(__uint32_t )] ;
};
#line 87 "/usr/include/sys/socket.h"
struct sockaddr_in;
#line 87
struct sockaddr_in6;
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 92 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 193 "/usr/include/netinet/in.h"
union __anonunion_in6_u_66 {
   uint8_t u6_addr8[16] ;
   uint16_t u6_addr16[8] ;
   uint32_t u6_addr32[4] ;
};
#line 193 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion_in6_u_66 in6_u ;
};
#line 219 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 233 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 144 "/usr/include/bits/types.h"
typedef long __off_t;
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 177 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 183 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 268 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t )] ;
};
#line 37 "/usr/include/bits/types.h"
typedef unsigned long __u_long;
#line 38 "/usr/include/sys/types.h"
typedef __u_long u_long;
#line 48 "/usr/include/arpa/nameser_compat.h"
struct __anonstruct_HEADER_69 {
   unsigned int id : 16 ;
   unsigned int rd : 1 ;
   unsigned int tc : 1 ;
   unsigned int aa : 1 ;
   unsigned int opcode : 4 ;
   unsigned int qr : 1 ;
   unsigned int rcode : 4 ;
   unsigned int cd : 1 ;
   unsigned int ad : 1 ;
   unsigned int unused : 1 ;
   unsigned int ra : 1 ;
   unsigned int qdcount : 16 ;
   unsigned int ancount : 16 ;
   unsigned int nscount : 16 ;
   unsigned int arcount : 16 ;
};
#line 48 "/usr/include/arpa/nameser_compat.h"
typedef struct __anonstruct_HEADER_69 HEADER;
#line 71 "/usr/include/resolv.h"
enum __anonenum_res_sendhookact_70 {
    res_goahead = 0,
    res_nextns = 1,
    res_modified = 2,
    res_done = 3,
    res_error = 4
} ;
#line 71 "/usr/include/resolv.h"
typedef enum __anonenum_res_sendhookact_70 res_sendhookact;
#line 104 "/usr/include/resolv.h"
struct __anonstruct_sort_list_71 {
   struct in_addr addr ;
   u_int32_t mask ;
};
#line 104 "/usr/include/resolv.h"
struct __anonstruct__ext_73 {
   u_int16_t nscount ;
   u_int16_t nsmap[3] ;
   int nssocks[3] ;
   u_int16_t nscount6 ;
   u_int16_t nsinit ;
   struct sockaddr_in6 *nsaddrs[3] ;
   unsigned int _initstamp[2] ;
};
#line 104 "/usr/include/resolv.h"
union __anonunion__u_72 {
   char pad[52] ;
   struct __anonstruct__ext_73 _ext ;
};
#line 104 "/usr/include/resolv.h"
struct __res_state {
   int retrans ;
   int retry ;
   u_long options ;
   int nscount ;
   struct sockaddr_in nsaddr_list[3] ;
   u_short id ;
   char *dnsrch[7] ;
   char defdname[256] ;
   u_long pfcode ;
   unsigned int ndots : 4 ;
   unsigned int nsort : 4 ;
   char unused[3] ;
   struct __anonstruct_sort_list_71 sort_list[10] ;
   res_sendhookact (*qhook)(struct sockaddr_in * const  *ns , u_char const   **query ,
                            int *querylen , u_char *ans , int anssiz , int *resplen ) ;
   res_sendhookact (*rhook)(struct sockaddr_in  const  *ns , u_char const   *query ,
                            int querylen , u_char *ans , int anssiz , int *resplen ) ;
   int res_h_errno ;
   int _vcsock ;
   u_int _flags ;
   union __anonunion__u_72 _u ;
};
#line 88 "./openbsd-compat/getrrsetbyname.h"
struct rdatainfo {
   unsigned int rdi_length ;
   unsigned char *rdi_data ;
};
#line 93 "./openbsd-compat/getrrsetbyname.h"
struct rrsetinfo {
   unsigned int rri_flags ;
   unsigned int rri_rdclass ;
   unsigned int rri_rdtype ;
   unsigned int rri_ttl ;
   unsigned int rri_nrdatas ;
   unsigned int rri_nsigs ;
   char *rri_name ;
   struct rdatainfo *rri_rdatas ;
   struct rdatainfo *rri_sigs ;
};
#line 139 "openbsd-compat/getrrsetbyname.c"
struct dns_query {
   char *name ;
   u_int16_t type ;
   u_int16_t class ;
   struct dns_query *next ;
};
#line 146 "openbsd-compat/getrrsetbyname.c"
struct dns_rr {
   char *name ;
   u_int16_t type ;
   u_int16_t class ;
   u_int16_t ttl ;
   u_int16_t size ;
   void *rdata ;
   struct dns_rr *next ;
};
#line 156 "openbsd-compat/getrrsetbyname.c"
struct dns_response {
   HEADER header ;
   struct dns_query *query ;
   struct dns_rr *answer ;
   struct dns_rr *authority ;
   struct dns_rr *additional ;
};
#line 137 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 143 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 152 "/usr/include/bits/types.h"
typedef long __time_t;
#line 167 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 173 "/usr/include/bits/types.h"
typedef __quad_t __blkcnt64_t;
#line 121 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t __st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off64_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __ino64_t st_ino ;
};
#line 47 "./openbsd-compat/glob.h"
struct __anonstruct_glob_t_68 {
   int gl_pathc ;
   int gl_matchc ;
   int gl_offs ;
   int gl_flags ;
   char **gl_pathv ;
   int (*gl_errfunc)(char const   * , int  ) ;
   void (*gl_closedir)(void * ) ;
   struct dirent *(*gl_readdir)(void * ) ;
   void *(*gl_opendir)(char const   * ) ;
   int (*gl_lstat)(char const   * , struct stat * ) ;
   int (*gl_stat)(char const   * , struct stat * ) ;
};
#line 47 "./openbsd-compat/glob.h"
typedef struct __anonstruct_glob_t_68 glob_t;
#line 106 "openbsd-compat/glob.c"
typedef u_short Char;
#line 44 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 183 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 23 "/usr/include/bits/sigset.h"
typedef int __sig_atomic_t;
#line 41 "/usr/include/signal.h"
typedef __sig_atomic_t sig_atomic_t;
#line 25 "/usr/include/bits/termios.h"
typedef unsigned char cc_t;
#line 26 "/usr/include/bits/termios.h"
typedef unsigned int speed_t;
#line 27 "/usr/include/bits/termios.h"
typedef unsigned int tcflag_t;
#line 30 "/usr/include/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 43 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 105 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 30 "acss.h"
struct acss_key_st {
   unsigned int lfsr17 ;
   unsigned int lfsr25 ;
   unsigned int lfsrsum ;
   unsigned char seed[5] ;
   unsigned char data[5] ;
   unsigned char subkey[5] ;
   int encrypt ;
   int mode ;
   int seeded ;
   int subkey_avilable ;
};
#line 30 "acss.h"
typedef struct acss_key_st ACSS_KEY;
#line 87 "/usr/include/sys/socket.h"
struct sockaddr_un;
#line 30 "/usr/include/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 107 "/usr/include/openssl/ossl_typ.h"
struct bignum_st;
#line 107 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_st BIGNUM;
#line 108
struct bignum_ctx;
#line 108 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_ctx BN_CTX;
#line 109
struct bn_blinding_st;
#line 109 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_blinding_st BN_BLINDING;
#line 110
struct bn_mont_ctx_st;
#line 110 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_mont_ctx_st BN_MONT_CTX;
#line 112
struct bn_gencb_st;
#line 112 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_gencb_st BN_GENCB;
#line 125
struct dsa_st;
#line 125 "/usr/include/openssl/ossl_typ.h"
typedef struct dsa_st DSA;
#line 126
struct dsa_method;
#line 126 "/usr/include/openssl/ossl_typ.h"
typedef struct dsa_method DSA_METHOD;
#line 128
struct rsa_st;
#line 128 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_st RSA;
#line 129
struct rsa_meth_st;
#line 129 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_meth_st RSA_METHOD;
#line 154
struct engine_st;
#line 154 "/usr/include/openssl/ossl_typ.h"
typedef struct engine_st ENGINE;
#line 165
struct crypto_ex_data_st;
#line 165 "/usr/include/openssl/ossl_typ.h"
typedef struct crypto_ex_data_st CRYPTO_EX_DATA;
#line 66 "/usr/include/openssl/stack.h"
struct stack_st {
   int num ;
   char **data ;
   int sorted ;
   int num_alloc ;
   int (*comp)(char const   * const  * , char const   * const  * ) ;
};
#line 66 "/usr/include/openssl/stack.h"
typedef struct stack_st STACK;
#line 283 "/usr/include/openssl/crypto.h"
struct crypto_ex_data_st {
   STACK *sk ;
   int dummy ;
};
#line 285 "/usr/include/openssl/bn.h"
struct bignum_st {
   unsigned long *d ;
   int top ;
   int dmax ;
   int neg ;
   int flags ;
};
#line 296 "/usr/include/openssl/bn.h"
struct bn_mont_ctx_st {
   int ri ;
   BIGNUM RR ;
   BIGNUM N ;
   BIGNUM Ni ;
   unsigned long n0 ;
   int flags ;
};
#line 320 "/usr/include/openssl/bn.h"
union __anonunion_cb_76 {
   void (*cb_1)(int  , int  , void * ) ;
   int (*cb_2)(int  , int  , BN_GENCB * ) ;
};
#line 320 "/usr/include/openssl/bn.h"
struct bn_gencb_st {
   unsigned int ver ;
   void *arg ;
   union __anonunion_cb_76 cb ;
};
#line 85 "/usr/include/openssl/rsa.h"
struct rsa_meth_st {
   char const   *name ;
   int (*rsa_pub_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_pub_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_priv_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_priv_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_mod_exp)(BIGNUM *r0 , BIGNUM const   *I , RSA *rsa , BN_CTX *ctx ) ;
   int (*bn_mod_exp)(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(RSA *rsa ) ;
   int (*finish)(RSA *rsa ) ;
   int flags ;
   char *app_data ;
   int (*rsa_sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
                   unsigned int *siglen , RSA const   *rsa ) ;
   int (*rsa_verify)(int dtype , unsigned char const   *m , unsigned int m_length ,
                     unsigned char *sigbuf , unsigned int siglen , RSA const   *rsa ) ;
   int (*rsa_keygen)(RSA *rsa , int bits , BIGNUM *e , BN_GENCB *cb ) ;
};
#line 128 "/usr/include/openssl/rsa.h"
struct rsa_st {
   int pad ;
   long version ;
   RSA_METHOD const   *meth ;
   ENGINE *engine ;
   BIGNUM *n ;
   BIGNUM *e ;
   BIGNUM *d ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *dmp1 ;
   BIGNUM *dmq1 ;
   BIGNUM *iqmp ;
   CRYPTO_EX_DATA ex_data ;
   int references ;
   int flags ;
   BN_MONT_CTX *_method_mod_n ;
   BN_MONT_CTX *_method_mod_p ;
   BN_MONT_CTX *_method_mod_q ;
   char *bignum_data ;
   BN_BLINDING *blinding ;
   BN_BLINDING *mt_blinding ;
};
#line 106 "/usr/include/openssl/dsa.h"
struct DSA_SIG_st {
   BIGNUM *r ;
   BIGNUM *s ;
};
#line 106 "/usr/include/openssl/dsa.h"
typedef struct DSA_SIG_st DSA_SIG;
#line 112 "/usr/include/openssl/dsa.h"
struct dsa_method {
   char const   *name ;
   DSA_SIG *(*dsa_do_sign)(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
   int (*dsa_sign_setup)(DSA *dsa , BN_CTX *ctx_in , BIGNUM **kinvp , BIGNUM **rp ) ;
   int (*dsa_do_verify)(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                        DSA *dsa ) ;
   int (*dsa_mod_exp)(DSA *dsa , BIGNUM *rr , BIGNUM *a1 , BIGNUM *p1 , BIGNUM *a2 ,
                      BIGNUM *p2 , BIGNUM *m , BN_CTX *ctx , BN_MONT_CTX *in_mont ) ;
   int (*bn_mod_exp)(DSA *dsa , BIGNUM *r , BIGNUM *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DSA *dsa ) ;
   int (*finish)(DSA *dsa ) ;
   int flags ;
   char *app_data ;
   int (*dsa_paramgen)(DSA *dsa , int bits , unsigned char *seed , int seed_len ,
                       int *counter_ret , unsigned long *h_ret , BN_GENCB *cb ) ;
   int (*dsa_keygen)(DSA *dsa ) ;
};
#line 139 "/usr/include/openssl/dsa.h"
struct dsa_st {
   int pad ;
   long version ;
   int write_params ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *g ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   BIGNUM *kinv ;
   BIGNUM *r ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DSA_METHOD const   *meth ;
   ENGINE *engine ;
};
#line 32 "key.h"
struct Key;
#line 32 "key.h"
typedef struct Key Key;
#line 51 "key.h"
struct Key {
   int type ;
   int flags ;
   RSA *rsa ;
   DSA *dsa ;
};
#line 65 "authfd.h"
struct __anonstruct_AuthenticationConnection_79 {
   int fd ;
   Buffer identities ;
   int howmany ;
};
#line 65 "authfd.h"
typedef struct __anonstruct_AuthenticationConnection_79 AuthenticationConnection;
#line 79 "/usr/include/openssl/ossl_typ.h"
struct asn1_string_st;
#line 79 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_INTEGER;
#line 80 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_ENUMERATED;
#line 81 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_BIT_STRING;
#line 82 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_OCTET_STRING;
#line 83 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_PRINTABLESTRING;
#line 84 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_T61STRING;
#line 85 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_IA5STRING;
#line 86 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_GENERALSTRING;
#line 87 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UNIVERSALSTRING;
#line 88 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_BMPSTRING;
#line 89 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UTCTIME;
#line 91 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_GENERALIZEDTIME;
#line 92 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_VISIBLESTRING;
#line 93 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UTF8STRING;
#line 94 "/usr/include/openssl/ossl_typ.h"
typedef int ASN1_BOOLEAN;
#line 116
struct evp_cipher_st;
#line 116 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_cipher_st EVP_CIPHER;
#line 117
struct evp_cipher_ctx_st;
#line 117 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_cipher_ctx_st EVP_CIPHER_CTX;
#line 120
struct evp_pkey_st;
#line 120 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_pkey_st EVP_PKEY;
#line 122
struct dh_st;
#line 122 "/usr/include/openssl/ossl_typ.h"
typedef struct dh_st DH;
#line 123
struct dh_method;
#line 123 "/usr/include/openssl/ossl_typ.h"
typedef struct dh_method DH_METHOD;
#line 206 "/usr/include/openssl/asn1.h"
struct asn1_object_st {
   char const   *sn ;
   char const   *ln ;
   int nid ;
   int length ;
   unsigned char *data ;
   int flags ;
};
#line 206 "/usr/include/openssl/asn1.h"
typedef struct asn1_object_st ASN1_OBJECT;
#line 222 "/usr/include/openssl/asn1.h"
struct asn1_string_st {
   int length ;
   int type ;
   unsigned char *data ;
   long flags ;
};
#line 222 "/usr/include/openssl/asn1.h"
typedef struct asn1_string_st ASN1_STRING;
#line 488 "/usr/include/openssl/asn1.h"
union __anonunion_value_77 {
   char *ptr ;
   ASN1_BOOLEAN boolean ;
   ASN1_STRING *asn1_string ;
   ASN1_OBJECT *object ;
   ASN1_INTEGER *integer ;
   ASN1_ENUMERATED *enumerated ;
   ASN1_BIT_STRING *bit_string ;
   ASN1_OCTET_STRING *octet_string ;
   ASN1_PRINTABLESTRING *printablestring ;
   ASN1_T61STRING *t61string ;
   ASN1_IA5STRING *ia5string ;
   ASN1_GENERALSTRING *generalstring ;
   ASN1_BMPSTRING *bmpstring ;
   ASN1_UNIVERSALSTRING *universalstring ;
   ASN1_UTCTIME *utctime ;
   ASN1_GENERALIZEDTIME *generalizedtime ;
   ASN1_VISIBLESTRING *visiblestring ;
   ASN1_UTF8STRING *utf8string ;
   ASN1_STRING *set ;
   ASN1_STRING *sequence ;
};
#line 488 "/usr/include/openssl/asn1.h"
struct asn1_type_st {
   int type ;
   union __anonunion_value_77 value ;
};
#line 488 "/usr/include/openssl/asn1.h"
typedef struct asn1_type_st ASN1_TYPE;
#line 126 "/usr/include/openssl/evp.h"
union __anonunion_pkey_78 {
   char *ptr ;
   struct rsa_st *rsa ;
   struct dsa_st *dsa ;
   struct dh_st *dh ;
};
#line 126 "/usr/include/openssl/evp.h"
struct evp_pkey_st {
   int type ;
   int save_type ;
   int references ;
   union __anonunion_pkey_78 pkey ;
   int save_parameters ;
   STACK *attributes ;
};
#line 297 "/usr/include/openssl/evp.h"
struct evp_cipher_st {
   int nid ;
   int block_size ;
   int key_len ;
   int iv_len ;
   unsigned long flags ;
   int (*init)(EVP_CIPHER_CTX *ctx , unsigned char const   *key , unsigned char const   *iv ,
               int enc ) ;
   int (*do_cipher)(EVP_CIPHER_CTX *ctx , unsigned char *out , unsigned char const   *in ,
                    unsigned int inl ) ;
   int (*cleanup)(EVP_CIPHER_CTX * ) ;
   int ctx_size ;
   int (*set_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*get_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*ctrl)(EVP_CIPHER_CTX * , int type , int arg , void *ptr ) ;
   void *app_data ;
};
#line 357 "/usr/include/openssl/evp.h"
struct evp_cipher_ctx_st {
   EVP_CIPHER const   *cipher ;
   ENGINE *engine ;
   int encrypt ;
   int buf_len ;
   unsigned char oiv[16] ;
   unsigned char iv[16] ;
   unsigned char buf[32] ;
   int num ;
   void *app_data ;
   int key_len ;
   unsigned long flags ;
   void *cipher_data ;
   int final_used ;
   int block_mask ;
   unsigned char final[32] ;
};
#line 95 "/usr/include/openssl/dh.h"
struct dh_method {
   char const   *name ;
   int (*generate_key)(DH *dh ) ;
   int (*compute_key)(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
   int (*bn_mod_exp)(DH const   *dh , BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p ,
                     BIGNUM const   *m , BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DH *dh ) ;
   int (*finish)(DH *dh ) ;
   int flags ;
   char *app_data ;
   int (*generate_params)(DH *dh , int prime_len , int generator , BN_GENCB *cb ) ;
};
#line 113 "/usr/include/openssl/dh.h"
struct dh_st {
   int pad ;
   int version ;
   BIGNUM *p ;
   BIGNUM *g ;
   long length ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   BIGNUM *q ;
   BIGNUM *j ;
   unsigned char *seed ;
   int seedlen ;
   BIGNUM *counter ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DH_METHOD const   *meth ;
   ENGINE *engine ;
};
#line 529 "/usr/include/openssl/pem.h"
typedef int pem_password_cb(char *buf , int size , int rwflag , void *userdata );
#line 61 "cipher.h"
struct Cipher;
#line 61 "cipher.h"
typedef struct Cipher Cipher;
#line 62
struct CipherContext;
#line 62 "cipher.h"
typedef struct CipherContext CipherContext;
#line 65 "cipher.h"
struct CipherContext {
   int plaintext ;
   EVP_CIPHER_CTX evp ;
   Cipher *cipher ;
};
#line 204 "/usr/include/sys/types.h"
typedef unsigned long long u_int64_t;
#line 321 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 538 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_13 {
   __fd_mask fds_bits[1024U / (8U * sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_13 fd_set;
#line 85 "/usr/include/sys/select.h"
typedef __fd_mask fd_mask;
#line 28 "/usr/include/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 63 "./channels.h"
typedef struct Channel Channel;
#line 88 "channels.c"
struct __anonstruct_ForwardPermission_81 {
   char *host_to_connect ;
   u_short port_to_connect ;
   u_short listen_port ;
};
#line 88 "channels.c"
typedef struct __anonstruct_ForwardPermission_81 ForwardPermission;
#line 721 "channels.c"
typedef void chan_fn(Channel *c , fd_set *readset , fd_set *writeset );
#line 934 "channels.c"
struct __anonstruct_s4_req_82 {
   u_int8_t version ;
   u_int8_t command ;
   u_int16_t dest_port ;
   struct in_addr dest_addr ;
};
#line 1009 "channels.c"
struct __anonstruct_s5_req_83 {
   u_int8_t version ;
   u_int8_t command ;
   u_int8_t reserved ;
   u_int8_t atyp ;
};
#line 99 "/usr/include/openssl/md5.h"
struct MD5state_st {
   unsigned int A ;
   unsigned int B ;
   unsigned int C ;
   unsigned int D ;
   unsigned int Nl ;
   unsigned int Nh ;
   unsigned int data[16] ;
   unsigned int num ;
};
#line 99 "/usr/include/openssl/md5.h"
typedef struct MD5state_st MD5_CTX;
#line 55 "cipher.c"
struct Cipher {
   char *name ;
   int number ;
   u_int block_size ;
   u_int key_len ;
   u_int discard_len ;
   EVP_CIPHER const   *(*evptype)(void) ;
};
#line 28 "cipher-acss.c"
struct __anonstruct_EVP_ACSS_KEY_79 {
   ACSS_KEY ks ;
};
#line 28 "cipher-acss.c"
typedef struct __anonstruct_EVP_ACSS_KEY_79 EVP_ACSS_KEY;
#line 37 "rijndael.h"
typedef unsigned int u32;
#line 40 "rijndael.h"
struct __anonstruct_rijndael_ctx_79 {
   int decrypt ;
   int Nr ;
   u32 ek[60] ;
   u32 dk[60] ;
};
#line 40 "rijndael.h"
typedef struct __anonstruct_rijndael_ctx_79 rijndael_ctx;
#line 39 "cipher-aes.c"
struct ssh_rijndael_ctx {
   rijndael_ctx r_ctx ;
   u_char r_iv[16] ;
};
#line 40 "cipher-ctr.c"
struct ssh_aes_ctr_ctx {
   rijndael_ctx aes_ctx ;
   u_char aes_counter[16] ;
};
#line 50 "cipher-3des1.c"
struct ssh1_3des_ctx {
   EVP_CIPHER_CTX k1 ;
   EVP_CIPHER_CTX k2 ;
   EVP_CIPHER_CTX k3 ;
};
#line 56 "compat.c"
struct __anonstruct_check_78 {
   char *pat ;
   int bugs ;
};
#line 261 "/usr/include/zconf.h"
typedef unsigned char Byte;
#line 263 "/usr/include/zconf.h"
typedef unsigned int uInt;
#line 264 "/usr/include/zconf.h"
typedef unsigned long uLong;
#line 270 "/usr/include/zconf.h"
typedef Byte Bytef;
#line 279 "/usr/include/zconf.h"
typedef void *voidpf;
#line 80 "/usr/include/zlib.h"
struct internal_state;
#line 82 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 82 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 103 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 1346 "/usr/include/zlib.h"
struct internal_state {
   int dummy ;
};
#line 39 "log.h"
enum __anonenum_LogLevel_76 {
    SYSLOG_LEVEL_QUIET = 0,
    SYSLOG_LEVEL_FATAL = 1,
    SYSLOG_LEVEL_ERROR = 2,
    SYSLOG_LEVEL_INFO = 3,
    SYSLOG_LEVEL_VERBOSE = 4,
    SYSLOG_LEVEL_DEBUG1 = 5,
    SYSLOG_LEVEL_DEBUG2 = 6,
    SYSLOG_LEVEL_DEBUG3 = 7,
    SYSLOG_LEVEL_NOT_SET = -1
} ;
#line 39 "log.h"
typedef enum __anonenum_LogLevel_76 LogLevel;
#line 118 "/usr/include/openssl/ossl_typ.h"
struct env_md_st;
#line 118 "/usr/include/openssl/ossl_typ.h"
typedef struct env_md_st EVP_MD;
#line 119
struct env_md_ctx_st;
#line 119 "/usr/include/openssl/ossl_typ.h"
typedef struct env_md_ctx_st EVP_MD_CTX;
#line 220 "/usr/include/openssl/evp.h"
struct env_md_st {
   int type ;
   int pkey_type ;
   int md_size ;
   unsigned long flags ;
   int (*init)(EVP_MD_CTX *ctx ) ;
   int (*update)(EVP_MD_CTX *ctx , void const   *data , size_t count ) ;
   int (*final)(EVP_MD_CTX *ctx , unsigned char *md ) ;
   int (*copy)(EVP_MD_CTX *to , EVP_MD_CTX const   *from ) ;
   int (*cleanup)(EVP_MD_CTX *ctx ) ;
   int (*sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
               unsigned int *siglen , void *key ) ;
   int (*verify)(int type , unsigned char const   *m , unsigned int m_length , unsigned char const   *sigbuf ,
                 unsigned int siglen , void *key ) ;
   int required_pkey_type[5] ;
   int block_size ;
   int ctx_size ;
};
#line 280 "/usr/include/openssl/evp.h"
struct env_md_ctx_st {
   EVP_MD const   *digest ;
   ENGINE *engine ;
   unsigned long flags ;
   void *md_data ;
};
#line 75 "/usr/include/openssl/hmac.h"
struct hmac_ctx_st {
   EVP_MD const   *md ;
   EVP_MD_CTX md_ctx ;
   EVP_MD_CTX i_ctx ;
   EVP_MD_CTX o_ctx ;
   unsigned int key_length ;
   unsigned char key[128] ;
};
#line 75 "/usr/include/openssl/hmac.h"
typedef struct hmac_ctx_st HMAC_CTX;
#line 17 "hostfile.h"
enum __anonenum_HostStatus_80 {
    HOST_OK = 0,
    HOST_NEW = 1,
    HOST_CHANGED = 2,
    HOST_FOUND = 3
} ;
#line 17 "hostfile.h"
typedef enum __anonenum_HostStatus_80 HostStatus;
#line 21 "log.h"
enum __anonenum_SyslogFacility_75 {
    SYSLOG_FACILITY_DAEMON = 0,
    SYSLOG_FACILITY_USER = 1,
    SYSLOG_FACILITY_AUTH = 2,
    SYSLOG_FACILITY_AUTHPRIV = 3,
    SYSLOG_FACILITY_LOCAL0 = 4,
    SYSLOG_FACILITY_LOCAL1 = 5,
    SYSLOG_FACILITY_LOCAL2 = 6,
    SYSLOG_FACILITY_LOCAL3 = 7,
    SYSLOG_FACILITY_LOCAL4 = 8,
    SYSLOG_FACILITY_LOCAL5 = 9,
    SYSLOG_FACILITY_LOCAL6 = 10,
    SYSLOG_FACILITY_LOCAL7 = 11,
    SYSLOG_FACILITY_NOT_SET = -1
} ;
#line 21 "log.h"
typedef enum __anonenum_SyslogFacility_75 SyslogFacility;
#line 59 "log.c"
struct __anonstruct_log_facilities_77 {
   char const   *name ;
   SyslogFacility val ;
};
#line 80 "log.c"
struct __anonstruct_log_levels_78 {
   char const   *name ;
   LogLevel val ;
};
#line 77 "/usr/include/time.h"
typedef __time_t time_t;
#line 134 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 154 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 72 "kex.h"
struct Mac;
#line 72 "kex.h"
typedef struct Mac Mac;
#line 73
struct Comp;
#line 73 "kex.h"
typedef struct Comp Comp;
#line 74
struct Enc;
#line 74 "kex.h"
typedef struct Enc Enc;
#line 75
struct Newkeys;
#line 75 "kex.h"
typedef struct Newkeys Newkeys;
#line 77 "kex.h"
struct Enc {
   char *name ;
   Cipher *cipher ;
   int enabled ;
   u_int key_len ;
   u_int block_size ;
   u_char *key ;
   u_char *iv ;
};
#line 86 "kex.h"
struct Mac {
   char *name ;
   int enabled ;
   EVP_MD const   *md ;
   u_int mac_len ;
   u_char *key ;
   u_int key_len ;
};
#line 94 "kex.h"
struct Comp {
   int type ;
   int enabled ;
   char *name ;
};
#line 99 "kex.h"
struct Newkeys {
   Enc enc ;
   Mac mac ;
   Comp comp ;
};
#line 127 "packet.c"
struct packet_state {
   u_int32_t seqnr ;
   u_int32_t packets ;
   u_int64_t blocks ;
};
#line 143 "packet.c"
struct __anonstruct_next_81 {
   struct packet *tqe_next ;
   struct packet **tqe_prev ;
};
#line 143 "packet.c"
struct packet {
   struct __anonstruct_next_81 next ;
   u_char type ;
   Buffer payload ;
};
#line 148 "packet.c"
struct __anonstruct_outgoing_82 {
   struct packet *tqh_first ;
   struct packet **tqh_last ;
};
#line 82 "readpass.c"
union __anonunion___u_77 {
   int __in ;
   int __i ;
};
#line 82 "readpass.c"
union __anonunion___u_78 {
   int __in ;
   int __i ;
};
#line 39 "key.h"
enum fp_type {
    SSH_FP_SHA1 = 0,
    SSH_FP_MD5 = 1
} ;
#line 43
enum fp_rep {
    SSH_FP_HEX = 0,
    SSH_FP_BUBBLEBABBLE = 1
} ;
#line 31 "dispatch.h"
typedef void dispatch_fn(int  , u_int32_t  , void * );
#line 71 "kex.h"
struct Kex;
#line 71 "kex.h"
typedef struct Kex Kex;
#line 104 "kex.h"
struct Kex {
   u_char *session_id ;
   u_int session_id_len ;
   Newkeys *newkeys[2] ;
   u_int we_need ;
   int server ;
   char *name ;
   int hostkey_type ;
   int kex_type ;
   Buffer my ;
   Buffer peer ;
   int done ;
   int flags ;
   EVP_MD const   *evp_md ;
   char *client_version_string ;
   char *server_version_string ;
   int (*verify_host_key)(Key * ) ;
   Key *(*load_host_key)(int  ) ;
   int (*host_key_index)(Key * ) ;
   void (*kex[3])(Kex * ) ;
};
#line 37 "mac.c"
struct __anonstruct_macs_81 {
   char *name ;
   EVP_MD const   *(*mdfunc)(void) ;
   int truncatebits ;
};
#line 35 "misc.h"
struct arglist;
#line 35 "misc.h"
typedef struct arglist arglist;
#line 36 "misc.h"
struct arglist {
   char **list ;
   u_int num ;
   u_int nalloc ;
};
#line 507 "misc.c"
struct __anonstruct_keys_77 {
   char const   *key ;
   char const   *repl ;
};
#line 44 "/usr/include/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 215 "/usr/include/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 233 "/usr/include/bits/socket.h"
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
#line 35 "rijndael.h"
typedef unsigned char u8;
#line 29 "dh.h"
struct dhgroup {
   int size ;
   BIGNUM *g ;
   BIGNUM *p ;
};
#line 90 "/usr/include/sys/types.h"
typedef __off64_t off_t;
#line 40 "servconf.h"
struct __anonstruct_ServerOptions_80 {
   u_int num_ports ;
   u_int ports_from_cmdline ;
   u_short ports[256] ;
   char *listen_addr ;
   struct addrinfo *listen_addrs ;
   int address_family ;
   char *host_key_files[256] ;
   int num_host_key_files ;
   char *pid_file ;
   int server_key_bits ;
   int login_grace_time ;
   int key_regeneration_time ;
   int permit_root_login ;
   int ignore_rhosts ;
   int ignore_user_known_hosts ;
   int print_motd ;
   int print_lastlog ;
   int x11_forwarding ;
   int x11_display_offset ;
   int x11_use_localhost ;
   char *xauth_location ;
   int strict_modes ;
   int tcp_keep_alive ;
   char *ciphers ;
   char *macs ;
   int protocol ;
   int gateway_ports ;
   SyslogFacility log_facility ;
   LogLevel log_level ;
   int rhosts_rsa_authentication ;
   int hostbased_authentication ;
   int hostbased_uses_name_from_packet_only ;
   int rsa_authentication ;
   int pubkey_authentication ;
   int kerberos_authentication ;
   int kerberos_or_local_passwd ;
   int kerberos_ticket_cleanup ;
   int kerberos_get_afs_token ;
   int gss_authentication ;
   int gss_cleanup_creds ;
   int password_authentication ;
   int kbd_interactive_authentication ;
   int challenge_response_authentication ;
   int permit_empty_passwd ;
   int permit_user_env ;
   int use_login ;
   int compression ;
   int allow_tcp_forwarding ;
   u_int num_allow_users ;
   char *allow_users[256] ;
   u_int num_deny_users ;
   char *deny_users[256] ;
   u_int num_allow_groups ;
   char *allow_groups[256] ;
   u_int num_deny_groups ;
   char *deny_groups[256] ;
   u_int num_subsystems ;
   char *subsystem_name[256] ;
   char *subsystem_command[256] ;
   u_int num_accept_env ;
   char *accept_env[256] ;
   int max_startups_begin ;
   int max_startups_rate ;
   int max_startups ;
   int max_authtries ;
   char *banner ;
   int use_dns ;
   int client_alive_interval ;
   int client_alive_count_max ;
   char *authorized_keys_file ;
   char *authorized_keys_file2 ;
   int use_pam ;
   int permit_tun ;
};
#line 40 "servconf.h"
typedef struct __anonstruct_ServerOptions_80 ServerOptions;
#line 46 "auth.h"
struct Authctxt;
#line 46 "auth.h"
typedef struct Authctxt Authctxt;
#line 50 "auth.h"
struct Authctxt {
   int success ;
   int postponed ;
   int valid ;
   int attempt ;
   int failures ;
   int force_pwchange ;
   char *user ;
   char *service ;
   struct passwd *pw ;
   char *style ;
   void *kbdintctxt ;
   Buffer *loginmsg ;
   void *methoddata ;
};
#line 32 "monitor_mm.h"
struct __anonstruct_next_85 {
   struct mm_share *rbe_left ;
   struct mm_share *rbe_right ;
   struct mm_share *rbe_parent ;
   int rbe_color ;
};
#line 32 "monitor_mm.h"
struct mm_share {
   struct __anonstruct_next_85 next ;
   void *address ;
   size_t size ;
};
#line 38 "monitor_mm.h"
struct mmtree {
   struct mm_share *rbh_root ;
};
#line 38 "monitor_mm.h"
struct mm_master {
   struct mmtree rb_free ;
   struct mmtree rb_allocated ;
   void *address ;
   size_t size ;
   struct mm_master *mmalloc ;
   int write ;
   int read ;
};
#line 67 "monitor.h"
struct monitor {
   int m_recvfd ;
   int m_sendfd ;
   struct mm_master *m_zback ;
   struct mm_master *m_zlib ;
   struct Kex **m_pkex ;
   pid_t m_pid ;
};
#line 170 "sshd.c"
struct __anonstruct_sensitive_data_86 {
   Key *server_key ;
   Key *ssh1_host_key ;
   Key **host_keys ;
   int have_ssh1_key ;
   int have_ssh2_key ;
   u_char ssh1_cookie[32] ;
};
#line 43 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 48 "loginrec.h"
union login_netinfo {
   struct sockaddr sa ;
   struct sockaddr_in sa_in ;
   struct sockaddr_storage sa_storage ;
};
#line 68 "loginrec.h"
struct logininfo {
   char progname[64] ;
   int progname_null ;
   short type ;
   int pid ;
   int uid ;
   char line[64] ;
   char username[128] ;
   char hostname[256] ;
   int exit ;
   int termination ;
   unsigned int tv_sec ;
   unsigned int tv_usec ;
   union login_netinfo hostaddr ;
};
#line 252 "servconf.c"
enum __anonenum_ServerOpCodes_82 {
    sBadOption = 0,
    sUsePAM = 1,
    sPort = 2,
    sHostKeyFile = 3,
    sServerKeyBits = 4,
    sLoginGraceTime = 5,
    sKeyRegenerationTime = 6,
    sPermitRootLogin = 7,
    sLogFacility = 8,
    sLogLevel = 9,
    sRhostsRSAAuthentication = 10,
    sRSAAuthentication = 11,
    sKerberosAuthentication = 12,
    sKerberosOrLocalPasswd = 13,
    sKerberosTicketCleanup = 14,
    sKerberosGetAFSToken = 15,
    sKerberosTgtPassing = 16,
    sChallengeResponseAuthentication = 17,
    sPasswordAuthentication = 18,
    sKbdInteractiveAuthentication = 19,
    sListenAddress = 20,
    sAddressFamily = 21,
    sPrintMotd = 22,
    sPrintLastLog = 23,
    sIgnoreRhosts = 24,
    sX11Forwarding = 25,
    sX11DisplayOffset = 26,
    sX11UseLocalhost = 27,
    sStrictModes = 28,
    sEmptyPasswd = 29,
    sTCPKeepAlive = 30,
    sPermitUserEnvironment = 31,
    sUseLogin = 32,
    sAllowTcpForwarding = 33,
    sCompression = 34,
    sAllowUsers = 35,
    sDenyUsers = 36,
    sAllowGroups = 37,
    sDenyGroups = 38,
    sIgnoreUserKnownHosts = 39,
    sCiphers = 40,
    sMacs = 41,
    sProtocol = 42,
    sPidFile = 43,
    sGatewayPorts = 44,
    sPubkeyAuthentication = 45,
    sXAuthLocation = 46,
    sSubsystem = 47,
    sMaxStartups = 48,
    sMaxAuthTries = 49,
    sBanner = 50,
    sUseDNS = 51,
    sHostbasedAuthentication = 52,
    sHostbasedUsesNameFromPacketOnly = 53,
    sClientAliveInterval = 54,
    sClientAliveCountMax = 55,
    sAuthorizedKeysFile = 56,
    sAuthorizedKeysFile2 = 57,
    sGssAuthentication = 58,
    sGssCleanupCreds = 59,
    sAcceptEnv = 60,
    sPermitTunnel = 61,
    sUsePrivilegeSeparation = 62,
    sDeprecated = 63,
    sUnsupported = 64
} ;
#line 252 "servconf.c"
typedef enum __anonenum_ServerOpCodes_82 ServerOpCodes;
#line 282 "servconf.c"
struct __anonstruct_keywords_83 {
   char const   *name ;
   ServerOpCodes opcode ;
};
#line 30 "session.h"
struct Session;
#line 30 "session.h"
typedef struct Session Session;
#line 31 "session.h"
struct __anonstruct_env_82 {
   char *name ;
   char *val ;
};
#line 31 "session.h"
struct Session {
   int used ;
   int self ;
   struct passwd *pw ;
   Authctxt *authctxt ;
   pid_t pid ;
   char *term ;
   int ptyfd ;
   int ttyfd ;
   int ptymaster ;
   u_int row ;
   u_int col ;
   u_int xpixel ;
   u_int ypixel ;
   char tty[64] ;
   u_int display_number ;
   char *display ;
   u_int screen ;
   char *auth_display ;
   char *auth_proto ;
   char *auth_data ;
   int single_connection ;
   int chanid ;
   int *x11_chanids ;
   int is_subsystem ;
   u_int num_env ;
   struct __anonstruct_env_82 *env ;
};
#line 709 "serverloop.c"
union __anonunion___u_85 {
   int __in ;
   int __i ;
};
#line 711 "serverloop.c"
union __anonunion___u_86 {
   int __in ;
   int __i ;
};
#line 707 "serverloop.c"
union __anonunion___u_87 {
   int __in ;
   int __i ;
};
#line 733 "serverloop.c"
union __anonunion___u_88 {
   int __in ;
   int __i ;
};
#line 731 "serverloop.c"
union __anonunion___u_89 {
   int __in ;
   int __i ;
};
#line 42 "auth1.c"
struct AuthMethod1 {
   int type ;
   char *name ;
   int *enabled ;
   int (*method)(Authctxt * , char * , size_t  ) ;
};
#line 47 "auth.h"
struct Authmethod;
#line 47 "auth.h"
typedef struct Authmethod Authmethod;
#line 82 "auth.h"
struct Authmethod {
   char *name ;
   int (*userauth)(Authctxt *authctxt ) ;
   int *enabled ;
};
#line 19 "auth-options.h"
struct envstring {
   struct envstring *next ;
   char *s ;
};
#line 2159 "session.c"
union __anonunion___u_84 {
   int __in ;
   int __i ;
};
#line 2163 "session.c"
union __anonunion___u_85___0 {
   int __in ;
   int __i ;
};
#line 2165 "session.c"
union __anonunion___u_86___0 {
   int __in ;
   int __i ;
};
#line 2161 "session.c"
union __anonunion___u_87___0 {
   int __in ;
   int __i ;
};
#line 2157 "session.c"
union __anonunion___u_88___0 {
   int __in ;
   int __i ;
};
#line 48 "auth.h"
struct KbdintDevice;
#line 48 "auth.h"
typedef struct KbdintDevice KbdintDevice;
#line 95 "auth.h"
struct KbdintDevice {
   char const   *name ;
   void *(*init_ctx)(Authctxt * ) ;
   int (*query)(void *ctx , char **name , char **infotxt , u_int *numprompts , char ***prompts ,
                u_int **echo_on ) ;
   int (*respond)(void *ctx , u_int numresp , char **responses ) ;
   void (*free_ctx)(void *ctx ) ;
};
#line 69 "auth2-chall.c"
struct KbdintAuthctxt;
#line 69 "auth2-chall.c"
typedef struct KbdintAuthctxt KbdintAuthctxt;
#line 70 "auth2-chall.c"
struct KbdintAuthctxt {
   char *devices ;
   void *ctxt ;
   KbdintDevice *device ;
   u_int nreq ;
};
#line 31 "monitor.h"
enum monitor_reqtype {
    MONITOR_REQ_MODULI = 0,
    MONITOR_ANS_MODULI = 1,
    MONITOR_REQ_FREE = 2,
    MONITOR_REQ_AUTHSERV = 3,
    MONITOR_REQ_SIGN = 4,
    MONITOR_ANS_SIGN = 5,
    MONITOR_REQ_PWNAM = 6,
    MONITOR_ANS_PWNAM = 7,
    MONITOR_REQ_AUTH2_READ_BANNER = 8,
    MONITOR_ANS_AUTH2_READ_BANNER = 9,
    MONITOR_REQ_AUTHPASSWORD = 10,
    MONITOR_ANS_AUTHPASSWORD = 11,
    MONITOR_REQ_BSDAUTHQUERY = 12,
    MONITOR_ANS_BSDAUTHQUERY = 13,
    MONITOR_REQ_BSDAUTHRESPOND = 14,
    MONITOR_ANS_BSDAUTHRESPOND = 15,
    MONITOR_REQ_SKEYQUERY = 16,
    MONITOR_ANS_SKEYQUERY = 17,
    MONITOR_REQ_SKEYRESPOND = 18,
    MONITOR_ANS_SKEYRESPOND = 19,
    MONITOR_REQ_KEYALLOWED = 20,
    MONITOR_ANS_KEYALLOWED = 21,
    MONITOR_REQ_KEYVERIFY = 22,
    MONITOR_ANS_KEYVERIFY = 23,
    MONITOR_REQ_KEYEXPORT = 24,
    MONITOR_REQ_PTY = 25,
    MONITOR_ANS_PTY = 26,
    MONITOR_REQ_PTYCLEANUP = 27,
    MONITOR_REQ_SESSKEY = 28,
    MONITOR_ANS_SESSKEY = 29,
    MONITOR_REQ_SESSID = 30,
    MONITOR_REQ_RSAKEYALLOWED = 31,
    MONITOR_ANS_RSAKEYALLOWED = 32,
    MONITOR_REQ_RSACHALLENGE = 33,
    MONITOR_ANS_RSACHALLENGE = 34,
    MONITOR_REQ_RSARESPONSE = 35,
    MONITOR_ANS_RSARESPONSE = 36,
    MONITOR_REQ_GSSSETUP = 37,
    MONITOR_ANS_GSSSETUP = 38,
    MONITOR_REQ_GSSSTEP = 39,
    MONITOR_ANS_GSSSTEP = 40,
    MONITOR_REQ_GSSUSEROK = 41,
    MONITOR_ANS_GSSUSEROK = 42,
    MONITOR_REQ_GSSCHECKMIC = 43,
    MONITOR_ANS_GSSCHECKMIC = 44,
    MONITOR_REQ_PAM_START = 45,
    MONITOR_REQ_PAM_ACCOUNT = 46,
    MONITOR_ANS_PAM_ACCOUNT = 47,
    MONITOR_REQ_PAM_INIT_CTX = 48,
    MONITOR_ANS_PAM_INIT_CTX = 49,
    MONITOR_REQ_PAM_QUERY = 50,
    MONITOR_ANS_PAM_QUERY = 51,
    MONITOR_REQ_PAM_RESPOND = 52,
    MONITOR_ANS_PAM_RESPOND = 53,
    MONITOR_REQ_PAM_FREE_CTX = 54,
    MONITOR_ANS_PAM_FREE_CTX = 55,
    MONITOR_REQ_AUDIT_EVENT = 56,
    MONITOR_REQ_AUDIT_COMMAND = 57,
    MONITOR_REQ_TERM = 58
} ;
#line 84
struct mon_table;
#line 36 "monitor_wrap.h"
enum mm_keytype {
    MM_NOKEY = 0,
    MM_HOSTKEY = 1,
    MM_USERKEY = 2,
    MM_RSAHOSTKEY = 3,
    MM_RSAUSERKEY = 4
} ;
#line 86 "monitor.c"
struct __anonstruct_child_state_85 {
   z_stream incoming ;
   z_stream outgoing ;
   u_char *keyin ;
   u_int keyinlen ;
   u_char *keyout ;
   u_int keyoutlen ;
   u_char *ivin ;
   u_int ivinlen ;
   u_char *ivout ;
   u_int ivoutlen ;
   u_char *ssh1key ;
   u_int ssh1keylen ;
   int ssh1cipher ;
   int ssh1protoflags ;
   u_char *input ;
   u_int ilen ;
   u_char *output ;
   u_int olen ;
};
#line 165 "monitor.c"
struct mon_table {
   enum monitor_reqtype type ;
   int flags ;
   int (*f)(int  , Buffer * ) ;
};
#line 1510 "monitor.c"
union __anonunion___u_86___1 {
   int __in ;
   int __i ;
};
#line 1510 "monitor.c"
union __anonunion___u_87___1 {
   int __in ;
   int __i ;
};
#line 1510 "monitor.c"
union __anonunion___u_88___1 {
   int __in ;
   int __i ;
};
#line 1510 "monitor.c"
union __anonunion___u_89___0 {
   int __in ;
   int __i ;
};
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 38 "/usr/include/bits/utmp.h"
struct lastlog {
   __time_t ll_time ;
   char ll_line[32] ;
   char ll_host[256] ;
};
#line 52 "/usr/include/bits/utmp.h"
struct exit_status {
   short e_termination ;
   short e_exit ;
};
#line 60 "/usr/include/bits/utmp.h"
struct utmp {
   short ut_type ;
   pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct exit_status ut_exit ;
   long ut_session ;
   struct timeval ut_tv ;
   int32_t ut_addr_v6[4] ;
   char __unused[20] ;
};
#line 1 "port-irix.o"
#line 1 "port-aix.o"
#line 1 "bsd-arc4random.o"
#line 59 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 141 "./openbsd-compat/openbsd-compat.h"
unsigned int arc4random(void) ;
#line 142
void arc4random_stir(void) ;
#line 32 "./entropy.h"
void seed_rng(void) ;
#line 56 "./log.h"
 __attribute__((__noreturn__)) void ( /* format attribute */  fatal)(char const   *fmt 
                                                                     , ...) ;
#line 102 "/usr/include/openssl/rand.h"
extern int RAND_bytes(unsigned char *buf , int num ) ;
#line 79 "/usr/include/openssl/rc4.h"
extern void RC4_set_key(RC4_KEY *key , int len , unsigned char const   *data ) ;
#line 80
extern void RC4(RC4_KEY *key , unsigned long len , unsigned char const   *indata ,
                unsigned char *outdata ) ;
#line 258 "/usr/include/openssl/err.h"
extern unsigned long ERR_get_error(void) ;
#line 34 "openbsd-compat/bsd-arc4random.c"
static int rc4_ready  =    0;
#line 35 "openbsd-compat/bsd-arc4random.c"
static RC4_KEY rc4  ;
#line 41 "openbsd-compat/bsd-arc4random.c"
static int first_time  =    1;
#line 37 "openbsd-compat/bsd-arc4random.c"
unsigned int arc4random(void) 
{ unsigned int r ;

  {
#line 40
  r = 0U;
#line 43
  if (rc4_ready <= 0) {
#line 44
    if (first_time) {
#line 45
      seed_rng();
    }
#line 46
    first_time = 0;
#line 47
    arc4random_stir();
  }
#line 50
  RC4(& rc4, (unsigned long )sizeof(r), (unsigned char const   *)((unsigned char *)(& r)),
      (unsigned char *)(& r));
#line 52
  rc4_ready = (int )((unsigned int )rc4_ready - sizeof(r));
#line 54
  return (r);
}
}
#line 57 "openbsd-compat/bsd-arc4random.c"
void arc4random_stir(void) 
{ unsigned char rand_buf[20] ;
  int i ;
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 63
  memset((void *)(& rc4), 0, sizeof(rc4));
#line 64
  tmp___0 = RAND_bytes(rand_buf, (int )sizeof(rand_buf));
#line 64
  if (tmp___0 <= 0) {
#line 65
    tmp = ERR_get_error();
#line 65
    fatal("Couldn\'t obtain random bytes (error %ld)", tmp);
  }
#line 67
  RC4_set_key(& rc4, (int )sizeof(rand_buf), (unsigned char const   *)(rand_buf));
#line 73
  i = 0;
#line 73
  while (i <= 256) {
#line 74
    RC4(& rc4, (unsigned long )sizeof(rand_buf), (unsigned char const   *)(rand_buf),
        rand_buf);
#line 73
    i = (int )((unsigned int )i + sizeof(rand_buf));
  }
#line 76
  memset((void *)(rand_buf), 0, sizeof(rand_buf));
#line 78
  rc4_ready = 1 << 24;
#line 79
  return;
}
}
#line 1 "bsd-cray.o"
#line 1 "bsd-cygwin_util.o"
#line 1 "bsd-getpeereid.o"
#line 185 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
#line 137 "./openbsd-compat/openbsd-compat.h"
int getpeereid(int s , uid_t *euid , gid_t *gid ) ;
#line 24 "openbsd-compat/bsd-getpeereid.c"
int getpeereid(int s , uid_t *euid , gid_t *gid ) 
{ struct ucred cred ;
  socklen_t len ;
  int tmp ;

  {
#line 28
  len = sizeof(cred);
#line 30
  tmp = getsockopt(s, 1, 17, (void * __restrict  )(& cred), (socklen_t * __restrict  )(& len));
#line 30
  if (tmp < 0) {
#line 31
    return (-1);
  }
#line 32
  *euid = cred.uid;
#line 33
  *gid = cred.gid;
#line 35
  return (0);
}
}
#line 1 "bsd-misc.o"
#line 216 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
#line 260
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 828 "/usr/include/unistd.h"
 __attribute__((__nothrow__)) int setlogin(char const   *name )  __attribute__((__nonnull__(1))) ;
#line 24 "./openbsd-compat/bsd-misc.h"
char *ssh_get_progname(char *argv0___0 ) ;
#line 94
mysig_t mysignal(int sig , void (*act)(int  ) ) ;
#line 25 "./xmalloc.h"
char *xstrdup(char const   *str ) ;
#line 34 "openbsd-compat/bsd-misc.c"
extern char *__progname ;
#line 31 "openbsd-compat/bsd-misc.c"
char *ssh_get_progname(char *argv0___0 ) 
{ char *tmp ;

  {
#line 36
  tmp = xstrdup((char const   *)__progname);
#line 36
  return (tmp);
}
}
#line 53
 __attribute__((__nothrow__)) int setlogin(char const   *name )  __attribute__((__nonnull__(1))) ;
#line 53 "openbsd-compat/bsd-misc.c"
int setlogin(char const   *name ) 
{ 

  {
#line 55
  return (0);
}
}
#line 189 "openbsd-compat/bsd-misc.c"
mysig_t mysignal(int sig , void (*act)(int  ) ) 
{ struct sigaction sa ;
  struct sigaction osa ;
  int tmp ;
  int tmp___0 ;

  {
#line 195
  tmp = sigaction(sig, (struct sigaction  const  * __restrict  )((void *)0), (struct sigaction * __restrict  )(& osa));
#line 195
  if (tmp == -1) {
#line 196
    return ((void (*)(int  ))-1);
  }
#line 197
  if ((unsigned int )osa.__sigaction_handler.sa_handler != (unsigned int )act) {
#line 198
    memset((void *)(& sa), 0, sizeof(sa));
#line 199
    sigemptyset(& sa.sa_mask);
#line 200
    sa.sa_flags = 0;
#line 202
    if (sig == 14) {
#line 203
      sa.sa_flags |= 536870912;
    }
#line 205
    sa.__sigaction_handler.sa_handler = act;
#line 206
    tmp___0 = sigaction(sig, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
#line 206
    if (tmp___0 == -1) {
#line 207
      return ((void (*)(int  ))-1);
    }
  }
#line 209
  return (osa.__sigaction_handler.sa_handler);
}
}
#line 1 "bsd-nextstep.o"
#line 1 "bsd-openpty.o"
#line 1 "bsd-snprintf.o"
#line 1 "bsd-waitpid.o"
#line 1 "bsd-closefrom.o"
#line 357 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 184 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 290
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   * __restrict  __nptr ,
                                                            char ** __restrict  __endptr ,
                                                            int __base , int __group )  __attribute__((__nonnull__(1))) ;
#line 332
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 332 "/usr/include/stdlib.h"
__inline static long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                            int __base ) 
{ long tmp ;

  {
#line 336
  tmp = __strtol_internal(__nptr, __endptr, __base, 0);
#line 336
  return (tmp);
}
}
#line 135 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 150
extern int closedir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 166
extern struct dirent *readdir(DIR *__dirp )  __asm__("readdir64") __attribute__((__nonnull__(1))) ;
#line 224
extern  __attribute__((__nothrow__)) int dirfd(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 320 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 564
extern  __attribute__((__nothrow__)) long sysconf(int __name )  __attribute__((__const__)) ;
#line 573
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 52 "./openbsd-compat/openbsd-compat.h"
void closefrom(int lowfd ) ;
#line 58 "openbsd-compat/bsd-closefrom.c"
void closefrom(int lowfd ) 
{ long fd ;
  long maxfd ;
  char fdpath[4096] ;
  char *endp ;
  struct dirent *dent ;
  DIR *dirp ;
  int len ;
  __pid_t tmp ;
  int tmp___0 ;

  {
#line 69
  tmp = getpid();
#line 69
  len = snprintf((char * __restrict  )(fdpath), sizeof(fdpath), (char const   * __restrict  )"/proc/%ld/fd",
                 (long )tmp);
#line 70
  if (len >= 0) {
#line 70
    if ((unsigned int )len <= sizeof(fdpath)) {
#line 70
      dirp = opendir((char const   *)(fdpath));
#line 70
      if (dirp) {
#line 71
        while (1) {
#line 71
          dent = readdir(dirp);
#line 71
          if (! ((unsigned int )dent != (unsigned int )((void *)0))) {
#line 71
            break;
          }
#line 72
          fd = strtol((char const   * __restrict  )(dent->d_name), (char ** __restrict  )(& endp),
                      10);
#line 73
          if ((unsigned int )(dent->d_name) != (unsigned int )endp) {
#line 73
            if ((int )*endp == 0) {
#line 73
              if (fd >= 0L) {
#line 73
                if (fd < 2147483647L) {
#line 73
                  if (fd >= (long )lowfd) {
#line 73
                    tmp___0 = dirfd(dirp);
#line 73
                    if (fd != (long )tmp___0) {
#line 75
                      close((int )fd);
                    }
                  }
                }
              }
            }
          }
        }
#line 77
        closedir(dirp);
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 87
    maxfd = sysconf(4);
#line 91
    if (maxfd < 0L) {
#line 92
      maxfd = 256L;
    }
#line 94
    fd = (long )lowfd;
#line 94
    while (fd < maxfd) {
#line 95
      close((int )fd);
#line 94
      fd ++;
    }
  }
#line 97
  return;
}
}
#line 1 "fake-rfc2553.o"
#line 1 "xmmap.o"
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 307 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 712 "/usr/include/stdlib.h"
int mkstemp(char *path )  __asm__("mkstemp64") __attribute__((__nonnull__(1))) ;
#line 256 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 792 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int unlink(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 973
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off64_t __length )  __asm__("ftruncate64")  ;
#line 62 "/usr/include/sys/mman.h"
extern  __attribute__((__nothrow__)) void *mmap(void *__addr , size_t __len , int __prot ,
                                                int __flags , int __fd , __off64_t __offset )  __asm__("mmap64")  ;
#line 175 "./openbsd-compat/openbsd-compat.h"
void *xmmap(size_t size ) ;
#line 36 "openbsd-compat/xmmap.c"
void *xmmap(size_t size ) 
{ void *address ;
  char tmpname[sizeof("/var/run/sshd.mm.XXXXXXXX")] ;
  int tmpfd ;
  mode_t old_umask ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 42
  address = mmap((void *)0, size, 3, 33, -1, 0LL);
#line 50
  if ((unsigned int )address == (unsigned int )((void *)-1)) {
#line 51
    tmpname[0] = (char )'/';
#line 51
    tmpname[1] = (char )'v';
#line 51
    tmpname[2] = (char )'a';
#line 51
    tmpname[3] = (char )'r';
#line 51
    tmpname[4] = (char )'/';
#line 51
    tmpname[5] = (char )'r';
#line 51
    tmpname[6] = (char )'u';
#line 51
    tmpname[7] = (char )'n';
#line 51
    tmpname[8] = (char )'/';
#line 51
    tmpname[9] = (char )'s';
#line 51
    tmpname[10] = (char )'s';
#line 51
    tmpname[11] = (char )'h';
#line 51
    tmpname[12] = (char )'d';
#line 51
    tmpname[13] = (char )'.';
#line 51
    tmpname[14] = (char )'m';
#line 51
    tmpname[15] = (char )'m';
#line 51
    tmpname[16] = (char )'.';
#line 51
    tmpname[17] = (char )'X';
#line 51
    tmpname[18] = (char )'X';
#line 51
    tmpname[19] = (char )'X';
#line 51
    tmpname[20] = (char )'X';
#line 51
    tmpname[21] = (char )'X';
#line 51
    tmpname[22] = (char )'X';
#line 51
    tmpname[23] = (char )'X';
#line 51
    tmpname[24] = (char )'X';
#line 51
    tmpname[25] = (char )'\000';
#line 55
    old_umask = umask(127U);
#line 56
    tmpfd = mkstemp(tmpname);
#line 57
    umask(old_umask);
#line 58
    if (tmpfd == -1) {
#line 59
      tmp = __errno_location();
#line 59
      tmp___0 = strerror(*tmp);
#line 59
      fatal("mkstemp(\"%s\"): %s", "/var/run/sshd.mm.XXXXXXXX", tmp___0);
    }
#line 61
    unlink((char const   *)(tmpname));
#line 62
    ftruncate(tmpfd, (long long )size);
#line 63
    address = mmap((void *)0, size, 3, 1, tmpfd, 0LL);
#line 65
    close(tmpfd);
  }
#line 68
  return (address);
}
}
#line 1 "xcrypt.o"
#line 1073 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *crypt(char const   *__key , char const   *__salt )  __attribute__((__nonnull__(1,2))) ;
#line 176 "./openbsd-compat/openbsd-compat.h"
char *xcrypt(char const   *password , char const   *salt ) ;
#line 177
char *shadow_pw(struct passwd *pw ) ;
#line 87 "/usr/include/shadow.h"
extern struct spwd *getspnam(char const   *__name ) ;
#line 56 "openbsd-compat/xcrypt.c"
char *xcrypt(char const   *password , char const   *salt ) 
{ char *crypted ;

  {
#line 74
  crypted = crypt(password, salt);
#line 77
  return (crypted);
}
}
#line 85 "openbsd-compat/xcrypt.c"
char *shadow_pw(struct passwd *pw ) 
{ char *pw_password ;
  struct spwd *spw ;
  struct spwd *tmp ;

  {
#line 88
  pw_password = pw->pw_passwd;
#line 91
  tmp = getspnam((char const   *)pw->pw_name);
#line 91
  spw = tmp;
#line 93
  if ((unsigned int )spw != (unsigned int )((void *)0)) {
#line 94
    pw_password = spw->sp_pwdp;
  }
#line 112
  return (pw_password);
}
}
#line 1 "port-tun.o"
#line 88 "/usr/include/fcntl.h"
extern int open(char const   *__file , int __oflag  , ...)  __asm__("open64") __attribute__((__nonnull__(1))) ;
#line 292 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 296
extern  __attribute__((__nothrow__)) void bzero(void *__s , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 51 "/usr/include/asm-generic/ioctl.h"
extern unsigned int __invalid_size_argument_for_IOC ;
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 24 "./openbsd-compat/port-tun.h"
int sys_tun_open(int tun , int mode ) ;
#line 29
int sys_tun_infilter(struct Channel *c , char *buf___1 , int len ) ;
#line 30
u_char *sys_tun_outfilter(struct Channel *c , u_char **data , u_int *dlen ) ;
#line 60 "./log.h"
void ( /* format attribute */  debug)(char const   *fmt  , ...) ;
#line 38 "./bufaux.h"
void *buffer_get_string(Buffer *buffer , u_int *length_ptr ) ;
#line 39
void buffer_put_string(Buffer *buffer , void const   *buf___1 , u_int len ) ;
#line 41 "openbsd-compat/port-tun.c"
int sys_tun_open(int tun , int mode ) 
{ struct ifreq ifr ;
  int fd ;
  char const   *name ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;

  {
#line 45
  fd = -1;
#line 46
  name = (char const   *)((void *)0);
#line 48
  fd = open("/dev/net/tun", 2);
#line 48
  if (fd == -1) {
#line 49
    tmp = __errno_location();
#line 49
    tmp___0 = strerror(*tmp);
#line 49
    debug("%s: failed to open tunnel control interface: %s", "sys_tun_open", tmp___0);
#line 51
    return (-1);
  }
#line 54
  bzero((void *)(& ifr), sizeof(ifr));
#line 56
  if (mode == 2) {
#line 57
    ifr.ifr_ifru.ifru_flags = (short)2;
#line 58
    name = "tap%d";
  } else {
#line 60
    ifr.ifr_ifru.ifru_flags = (short)1;
#line 61
    name = "tun%d";
  }
#line 63
  ifr.ifr_ifru.ifru_flags = (short )((int )ifr.ifr_ifru.ifru_flags | 4096);
#line 65
  if (tun != 2147483647) {
#line 66
    if (tun > 2147483645) {
#line 67
      tmp___1 = __errno_location();
#line 67
      tmp___2 = strerror(*tmp___1);
#line 67
      debug("%s: invalid tunnel id %x: %s", "sys_tun_open", tun, tmp___2);
      goto failed;
    }
#line 71
    snprintf((char * __restrict  )(ifr.ifr_ifrn.ifrn_name), sizeof(ifr.ifr_ifrn.ifrn_name),
             (char const   * __restrict  )name, tun);
  }
#line 74
  if (sizeof(int ) == sizeof(int [1])) {
#line 74
    if (sizeof(int ) < (unsigned int )(1 << 14)) {
#line 74
      tmp___5 = sizeof(int );
    } else {
#line 74
      tmp___5 = __invalid_size_argument_for_IOC;
    }
  } else {
#line 74
    tmp___5 = __invalid_size_argument_for_IOC;
  }
#line 74
  tmp___6 = ioctl(fd, (unsigned long )((((1U << 30) | (unsigned int )(84 << 8)) | 202U) | (tmp___5 << 16)),
                  & ifr);
#line 74
  if (tmp___6 == -1) {
#line 75
    tmp___3 = __errno_location();
#line 75
    tmp___4 = strerror(*tmp___3);
#line 75
    debug("%s: failed to configure tunnel (mode %d): %s", "sys_tun_open", mode, tmp___4);
    goto failed;
  }
#line 80
  if (tun == 2147483647) {
#line 81
    debug("%s: tunnel mode %d fd %d", "sys_tun_open", mode, fd);
  } else {
#line 83
    debug("%s: %s mode %d fd %d", "sys_tun_open", ifr.ifr_ifrn.ifrn_name, mode, fd);
  }
#line 85
  return (fd);
  failed: 
#line 88
  close(fd);
#line 89
  return (-1);
}
}
#line 183 "openbsd-compat/port-tun.c"
int sys_tun_infilter(struct Channel *c , char *buf___1 , int len ) 
{ char rbuf[16384] ;
  struct ip *iph ;
  u_int32_t *af ;
  char *ptr ;
  register unsigned int __v ;
  register unsigned int __x ;
  register unsigned int __v___0 ;
  register unsigned int __x___0 ;
  register unsigned int __v___1 ;
  register unsigned int __x___1 ;

  {
#line 191
  ptr = buf___1;
#line 194
  if (len <= 0) {
#line 195
    return (-1);
  } else {
#line 194
    if (len > (int )(sizeof(rbuf) - sizeof(*af))) {
#line 195
      return (-1);
    }
  }
#line 196
  ptr = rbuf;
#line 197
  bcopy((void const   *)buf___1, (void *)(ptr + sizeof(u_int32_t )), (unsigned int )len);
#line 198
  len = (int )((unsigned int )len + sizeof(u_int32_t ));
#line 199
  af = (u_int32_t *)ptr;
#line 201
  iph = (struct ip *)(ptr + sizeof(u_int32_t ));
#line 202
  switch ((int )iph->ip_v) {
  case 6: 
#line 204
  *af = 10U;
#line 205
  break;
  case 4: 
  default: 
#line 208
  *af = 2U;
#line 209
  break;
  }
#line 214
  if (len < (int )sizeof(u_int32_t )) {
#line 215
    return (-1);
  }
#line 217
  af = (u_int32_t *)ptr;
#line 218
  __x___1 = 10U;
#line 218
  __asm__  ("rorw $8, %w0;"
            "rorl $16, %0;"
            "rorw $8, %w0": "=r" (__v___1): "0" (__x___1): "cc");
#line 218
  if (*af == __v___1) {
#line 219
    __x = 24U;
#line 219
    __asm__  ("rorw $8, %w0;"
              "rorl $16, %0;"
              "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 219
    *af = __v;
  } else {
#line 221
    __x___0 = 2U;
#line 221
    __asm__  ("rorw $8, %w0;"
              "rorl $16, %0;"
              "rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 221
    *af = __v___0;
  }
#line 224
  buffer_put_string(& c->input, (void const   *)ptr, (unsigned int )len);
#line 225
  return (0);
}
}
#line 228 "openbsd-compat/port-tun.c"
u_char *sys_tun_outfilter(struct Channel *c , u_char **data , u_int *dlen ) 
{ u_char *buf___1 ;
  u_int32_t *af ;
  void *tmp ;

  {
#line 234
  tmp = buffer_get_string(& c->output, dlen);
#line 234
  *data = (u_char *)tmp;
#line 235
  if (*dlen < sizeof(*af)) {
#line 236
    return ((u_char *)((void *)0));
  }
#line 237
  buf___1 = *data;
#line 240
  *dlen -= sizeof(u_int32_t );
#line 241
  buf___1 = *data + sizeof(u_int32_t );
#line 250
  return (buf___1);
}
}
#line 1 "strtonum.o"
#line 210 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) long long strtoll(char const   * __restrict  __nptr ,
                                                                char ** __restrict  __endptr ,
                                                                int __base )  __attribute__((__nonnull__(1))) ;
#line 306
extern  __attribute__((__nothrow__)) long long __strtoll_internal(char const   * __restrict  __nptr ,
                                                                  char ** __restrict  __endptr ,
                                                                  int __base , int __group )  __attribute__((__nonnull__(1))) ;
#line 380
__inline static  __attribute__((__nothrow__)) long long strtoll(char const   * __restrict  __nptr ,
                                                                char ** __restrict  __endptr ,
                                                                int __base )  __attribute__((__nonnull__(1))) ;
#line 380 "/usr/include/stdlib.h"
__inline static long long strtoll(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                  int __base ) 
{ long long tmp ;

  {
#line 384
  tmp = __strtoll_internal(__nptr, __endptr, __base, 0);
#line 384
  return (tmp);
}
}
#line 164 "./openbsd-compat/openbsd-compat.h"
long long strtonum(char const   *numstr , long long minval , long long maxval , char const   **errstrp ) ;
#line 30 "openbsd-compat/strtonum.c"
long long strtonum(char const   *numstr , long long minval , long long maxval , char const   **errstrp ) 
{ long long ll ;
  char *ep ;
  int error___0 ;
  struct errval ev[4] ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 34
  ll = 0LL;
#line 36
  error___0 = 0;
#line 37
  ev[0].errstr = (char const   *)((void *)0);
#line 37
  ev[0].err = 0;
#line 37
  ev[1].errstr = "invalid";
#line 37
  ev[1].err = 22;
#line 37
  ev[2].errstr = "too small";
#line 37
  ev[2].err = 34;
#line 37
  ev[3].errstr = "too large";
#line 37
  ev[3].err = 34;
#line 47
  tmp = __errno_location();
#line 47
  ev[0].err = *tmp;
#line 48
  tmp___0 = __errno_location();
#line 48
  *tmp___0 = 0;
#line 49
  if (minval > maxval) {
#line 50
    error___0 = 1;
  } else {
#line 52
    ll = strtoll((char const   * __restrict  )numstr, (char ** __restrict  )(& ep),
                 10);
#line 53
    if ((unsigned int )numstr == (unsigned int )ep) {
#line 54
      error___0 = 1;
    } else {
#line 53
      if ((int )*ep != 0) {
#line 54
        error___0 = 1;
      } else {
#line 55
        if (ll == (-0x7FFFFFFFFFFFFFFF-1)) {
#line 55
          tmp___2 = __errno_location();
#line 55
          if (*tmp___2 == 34) {
#line 56
            error___0 = 2;
          } else {
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 55
          if (ll < minval) {
#line 56
            error___0 = 2;
          } else {
#line 57
            if (ll == 9223372036854775807LL) {
#line 57
              tmp___1 = __errno_location();
#line 57
              if (*tmp___1 == 34) {
#line 58
                error___0 = 3;
              } else {
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
#line 57
              if (ll > maxval) {
#line 58
                error___0 = 3;
              }
            }
          }
        }
      }
    }
  }
#line 60
  if ((unsigned int )errstrp != (unsigned int )((void *)0)) {
#line 61
    *errstrp = ev[error___0].errstr;
  }
#line 62
  tmp___3 = __errno_location();
#line 62
  *tmp___3 = ev[error___0].err;
#line 63
  if (error___0) {
#line 64
    ll = 0LL;
  }
#line 66
  return (ll);
}
}
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
#line 1 "base64.o"
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 628 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 323 "/usr/include/resolv.h"
 __attribute__((__nothrow__)) int __b64_ntop(u_char const   *src , size_t srclength ,
                                             char *target , size_t targsize ) ;
#line 324
 __attribute__((__nothrow__)) int __b64_pton(char const   *src , u_char *target ,
                                             size_t targsize ) ;
#line 68 "openbsd-compat/base64.c"
static char const   Base64[65]  = 
#line 68 "openbsd-compat/base64.c"
  {      (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'g',      (char const   )'h',      (char const   )'i',      (char const   )'j', 
        (char const   )'k',      (char const   )'l',      (char const   )'m',      (char const   )'n', 
        (char const   )'o',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'+',      (char const   )'/', 
        (char const   )'\000'};
#line 70 "openbsd-compat/base64.c"
static char const   Pad64  =    (char const   )'=';
#line 136
 __attribute__((__nothrow__)) int __b64_ntop(u_char const   *src , size_t srclength ,
                                             char *target , size_t targsize ) ;
#line 136 "openbsd-compat/base64.c"
int __b64_ntop(u_char const   *src , size_t srclength , char *target , size_t targsize ) 
{ size_t datalength ;
  u_char input___0[3] ;
  u_char output___0[4] ;
  u_int i ;
  u_char const   *tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  u_char const   *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;

  {
#line 139
  datalength = (size_t )0;
#line 144
  while (2U < srclength) {
#line 145
    tmp = src;
#line 145
    src ++;
#line 145
    input___0[0] = (unsigned char )*tmp;
#line 146
    tmp___0 = src;
#line 146
    src ++;
#line 146
    input___0[1] = (unsigned char )*tmp___0;
#line 147
    tmp___1 = src;
#line 147
    src ++;
#line 147
    input___0[2] = (unsigned char )*tmp___1;
#line 148
    srclength -= 3U;
#line 150
    output___0[0] = (unsigned char )((int )input___0[0] >> 2);
#line 151
    output___0[1] = (unsigned char )((((int )input___0[0] & 3) << 4) + ((int )input___0[1] >> 4));
#line 152
    output___0[2] = (unsigned char )((((int )input___0[1] & 15) << 2) + ((int )input___0[2] >> 6));
#line 153
    output___0[3] = (unsigned char )((int )input___0[2] & 63);
#line 154
    if (! ((int )output___0[0] < 64)) {
#line 154
      abort();
    }
#line 155
    if (! ((int )output___0[1] < 64)) {
#line 155
      abort();
    }
#line 156
    if (! ((int )output___0[2] < 64)) {
#line 156
      abort();
    }
#line 157
    if (! ((int )output___0[3] < 64)) {
#line 157
      abort();
    }
#line 159
    if (datalength + 4U > targsize) {
#line 160
      return (-1);
    }
#line 161
    tmp___2 = datalength;
#line 161
    datalength ++;
#line 161
    *(target + tmp___2) = (char )Base64[output___0[0]];
#line 162
    tmp___3 = datalength;
#line 162
    datalength ++;
#line 162
    *(target + tmp___3) = (char )Base64[output___0[1]];
#line 163
    tmp___4 = datalength;
#line 163
    datalength ++;
#line 163
    *(target + tmp___4) = (char )Base64[output___0[2]];
#line 164
    tmp___5 = datalength;
#line 164
    datalength ++;
#line 164
    *(target + tmp___5) = (char )Base64[output___0[3]];
  }
#line 168
  if (0U != srclength) {
#line 170
    input___0[2] = (unsigned char )'\000';
#line 170
    input___0[1] = input___0[2];
#line 170
    input___0[0] = input___0[1];
#line 171
    i = 0U;
#line 171
    while (i < srclength) {
#line 172
      tmp___6 = src;
#line 172
      src ++;
#line 172
      input___0[i] = (unsigned char )*tmp___6;
#line 171
      i ++;
    }
#line 174
    output___0[0] = (unsigned char )((int )input___0[0] >> 2);
#line 175
    output___0[1] = (unsigned char )((((int )input___0[0] & 3) << 4) + ((int )input___0[1] >> 4));
#line 176
    output___0[2] = (unsigned char )((((int )input___0[1] & 15) << 2) + ((int )input___0[2] >> 6));
#line 177
    if (! ((int )output___0[0] < 64)) {
#line 177
      abort();
    }
#line 178
    if (! ((int )output___0[1] < 64)) {
#line 178
      abort();
    }
#line 179
    if (! ((int )output___0[2] < 64)) {
#line 179
      abort();
    }
#line 181
    if (datalength + 4U > targsize) {
#line 182
      return (-1);
    }
#line 183
    tmp___7 = datalength;
#line 183
    datalength ++;
#line 183
    *(target + tmp___7) = (char )Base64[output___0[0]];
#line 184
    tmp___8 = datalength;
#line 184
    datalength ++;
#line 184
    *(target + tmp___8) = (char )Base64[output___0[1]];
#line 185
    if (srclength == 1U) {
#line 186
      tmp___9 = datalength;
#line 186
      datalength ++;
#line 186
      *(target + tmp___9) = (char )Pad64;
    } else {
#line 188
      tmp___10 = datalength;
#line 188
      datalength ++;
#line 188
      *(target + tmp___10) = (char )Base64[output___0[2]];
    }
#line 189
    tmp___11 = datalength;
#line 189
    datalength ++;
#line 189
    *(target + tmp___11) = (char )Pad64;
  }
#line 191
  if (datalength >= targsize) {
#line 192
    return (-1);
  }
#line 193
  *(target + datalength) = (char )'\000';
#line 194
  return ((int )datalength);
}
}
#line 206
 __attribute__((__nothrow__)) int __b64_pton(char const   *src , u_char *target ,
                                             size_t targsize ) ;
#line 206 "openbsd-compat/base64.c"
int __b64_pton(char const   *src , u_char *target , size_t targsize ) 
{ u_int tarindex ;
  u_int state ;
  int ch ;
  char *pos ;
  unsigned short const   **tmp ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  unsigned short const   **tmp___8 ;

  {
#line 213
  state = 0U;
#line 214
  tarindex = 0U;
#line 216
  while (1) {
#line 216
    tmp___2 = src;
#line 216
    src ++;
#line 216
    ch = (int )*tmp___2;
#line 216
    if (! (ch != 0)) {
#line 216
      break;
    }
#line 217
    tmp = __ctype_b_loc();
#line 217
    if ((int const   )*(*tmp + ch) & 8192) {
#line 218
      continue;
    }
#line 220
    if (ch == (int )Pad64) {
#line 221
      break;
    }
#line 223
    tmp___1 = __builtin_strchr((char *)(Base64), ch);
#line 223
    pos = tmp___1;
#line 224
    if ((unsigned int )pos == (unsigned int )((char *)0)) {
#line 225
      return (-1);
    }
#line 227
    switch ((int )state) {
    case 0: 
#line 229
    if (target) {
#line 230
      if (tarindex >= targsize) {
#line 231
        return (-1);
      }
#line 232
      *(target + tarindex) = (unsigned char )((pos - (char *)(Base64)) << 2);
    }
#line 234
    state = 1U;
#line 235
    break;
    case 1: 
#line 237
    if (target) {
#line 238
      if (tarindex + 1U >= targsize) {
#line 239
        return (-1);
      }
#line 240
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | ((pos - (char *)(Base64)) >> 4));
#line 241
      *(target + (tarindex + 1U)) = (unsigned char )(((pos - (char *)(Base64)) & 15) << 4);
    }
#line 244
    tarindex ++;
#line 245
    state = 2U;
#line 246
    break;
    case 2: 
#line 248
    if (target) {
#line 249
      if (tarindex + 1U >= targsize) {
#line 250
        return (-1);
      }
#line 251
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | ((pos - (char *)(Base64)) >> 2));
#line 252
      *(target + (tarindex + 1U)) = (unsigned char )(((pos - (char *)(Base64)) & 3) << 6);
    }
#line 255
    tarindex ++;
#line 256
    state = 3U;
#line 257
    break;
    case 3: 
#line 259
    if (target) {
#line 260
      if (tarindex >= targsize) {
#line 261
        return (-1);
      }
#line 262
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | (pos - (char *)(Base64)));
    }
#line 264
    tarindex ++;
#line 265
    state = 0U;
#line 266
    break;
    }
  }
#line 275
  if (ch == (int )Pad64) {
#line 276
    tmp___3 = src;
#line 276
    src ++;
#line 276
    ch = (int )*tmp___3;
#line 277
    switch ((int )state) {
    case 0: 
    case 1: 
#line 280
    return (-1);
    case 2: 
#line 284
    while (ch != 0) {
#line 285
      tmp___5 = __ctype_b_loc();
#line 285
      if (! ((int const   )*(*tmp___5 + ch) & 8192)) {
#line 286
        break;
      }
#line 284
      tmp___4 = src;
#line 284
      src ++;
#line 284
      ch = (int )*tmp___4;
    }
#line 288
    if (ch != (int )Pad64) {
#line 289
      return (-1);
    }
#line 290
    tmp___6 = src;
#line 290
    src ++;
#line 290
    ch = (int )*tmp___6;
    case 3: 
#line 299
    while (ch != 0) {
#line 300
      tmp___8 = __ctype_b_loc();
#line 300
      if (! ((int const   )*(*tmp___8 + ch) & 8192)) {
#line 301
        return (-1);
      }
#line 299
      tmp___7 = src;
#line 299
      src ++;
#line 299
      ch = (int )*tmp___7;
    }
#line 309
    if (target) {
#line 309
      if ((int )*(target + tarindex) != 0) {
#line 310
        return (-1);
      }
    }
    }
  } else {
#line 317
    if (state != 0U) {
#line 318
      return (-1);
    }
  }
#line 321
  return ((int )tarindex);
}
}
#line 1 "basename.o"
#line 1 "bindresvport.o"
#line 110 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  * __restrict  __addr ,
                                              socklen_t __len ) ;
#line 114
extern  __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 48 "./openbsd-compat/openbsd-compat.h"
int bindresvport_sa(int sd , struct sockaddr *sa ) ;
#line 46 "openbsd-compat/bindresvport.c"
int bindresvport_sa(int sd , struct sockaddr *sa ) 
{ int error___0 ;
  int af ;
  struct sockaddr_storage myaddr ;
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;
  u_int16_t *portp ;
  u_int16_t port___0 ;
  socklen_t salen ;
  int i ;
  int tmp ;
  int *tmp___0 ;
  register unsigned short __v ;
  register unsigned short __x ;
  unsigned int tmp___1 ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 58
  if ((unsigned int )sa == (unsigned int )((void *)0)) {
#line 59
    memset((void *)(& myaddr), 0, sizeof(myaddr));
#line 60
    sa = (struct sockaddr *)(& myaddr);
#line 62
    tmp = getsockname(sd, (struct sockaddr * __restrict  )sa, (socklen_t * __restrict  )(& salen));
#line 62
    if (tmp == -1) {
#line 63
      return (-1);
    }
#line 65
    af = (int )sa->sa_family;
#line 66
    memset((void *)(& myaddr), 0, salen);
  } else {
#line 68
    af = (int )sa->sa_family;
  }
#line 70
  if (af == 2) {
#line 71
    sin = (struct sockaddr_in *)sa;
#line 72
    salen = sizeof(struct sockaddr_in );
#line 73
    portp = & sin->sin_port;
  } else {
#line 74
    if (af == 10) {
#line 75
      sin6 = (struct sockaddr_in6 *)sa;
#line 76
      salen = sizeof(struct sockaddr_in6 );
#line 77
      portp = & sin6->sin6_port;
    } else {
#line 79
      tmp___0 = __errno_location();
#line 79
      *tmp___0 = 96;
#line 80
      return (-1);
    }
  }
#line 82
  sa->sa_family = (unsigned short )af;
#line 84
  __x = *portp;
#line 84
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 84
  port___0 = __v;
#line 85
  if ((int )port___0 == 0) {
#line 86
    tmp___1 = arc4random();
#line 86
    port___0 = (unsigned short )(tmp___1 % 424U + 600U);
  }
#line 89
  error___0 = -1;
#line 91
  i = 0;
#line 91
  while (i < 424) {
#line 92
    __x___0 = port___0;
#line 92
    __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 92
    *portp = __v___0;
#line 94
    error___0 = bind(sd, (struct sockaddr  const  * __restrict  )sa, salen);
#line 97
    if (error___0 == 0) {
#line 98
      break;
    }
#line 101
    if (error___0 < 0) {
#line 101
      tmp___2 = __errno_location();
#line 101
      if (! (*tmp___2 == 98)) {
#line 101
        tmp___3 = __errno_location();
#line 101
        if (! (*tmp___3 == 22)) {
#line 102
          break;
        }
      }
    }
#line 104
    port___0 = (u_int16_t )((int )port___0 + 1);
#line 105
    if ((int )port___0 > 1023) {
#line 106
      port___0 = (unsigned short)600;
    }
#line 91
    i ++;
  }
#line 109
  return (error___0);
}
}
#line 1 "daemon.o"
#line 1 "dirname.o"
#line 1 "getcwd.o"
#line 1 "getgrouplist.o"
#line 1 "getopt.o"
#line 144 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 327
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 126 "./openbsd-compat/openbsd-compat.h"
int BSDgetopt(int nargc , char * const  *nargv , char const   *ostr ) ;
#line 43 "openbsd-compat/getopt.c"
int BSDopterr  =    1;
#line 43 "openbsd-compat/getopt.c"
int BSDoptind  =    1;
#line 43 "openbsd-compat/getopt.c"
int BSDoptopt  ;
#line 43 "openbsd-compat/getopt.c"
int BSDoptreset  ;
#line 47 "openbsd-compat/getopt.c"
char *BSDoptarg  ;
#line 64 "openbsd-compat/getopt.c"
static char *place  =    (char *)"";
#line 57 "openbsd-compat/getopt.c"
int BSDgetopt(int nargc , char * const  *nargv , char const   *ostr ) 
{ char *oli ;
  char *tmp ;
  char *tmp___1 ;

  {
#line 67
  if ((unsigned int )ostr == (unsigned int )((void *)0)) {
#line 68
    return (-1);
  }
#line 70
  if (BSDoptreset) {
    goto _L;
  } else {
#line 70
    if (! *place) {
      _L: /* CIL Label */ 
#line 71
      BSDoptreset = 0;
#line 72
      if (BSDoptind >= nargc) {
#line 73
        place = (char *)"";
#line 74
        return (-1);
      } else {
#line 72
        place = (char *)*(nargv + BSDoptind);
#line 72
        if ((int )*place != 45) {
#line 73
          place = (char *)"";
#line 74
          return (-1);
        }
      }
#line 76
      if (*(place + 1)) {
#line 76
        place ++;
#line 76
        if ((int )*place == 45) {
#line 77
          BSDoptind ++;
#line 78
          place = (char *)"";
#line 79
          return (-1);
        }
      }
    }
  }
#line 82
  tmp = place;
#line 82
  place ++;
#line 82
  BSDoptopt = (int )*tmp;
#line 82
  if (BSDoptopt == 58) {
    goto _L___0;
  } else {
#line 82
    tmp___1 = __builtin_strchr((char *)ostr, BSDoptopt);
#line 82
    oli = tmp___1;
#line 82
    if (! oli) {
      _L___0: /* CIL Label */ 
#line 88
      if (BSDoptopt == 45) {
#line 89
        return (-1);
      }
#line 90
      if (! *place) {
#line 91
        BSDoptind ++;
      }
#line 92
      if (BSDopterr) {
#line 92
        if ((int const   )*ostr != 58) {
#line 93
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: illegal option -- %c\n",
                  __progname, BSDoptopt);
        }
      }
#line 95
      return ('?');
    }
  }
#line 97
  oli ++;
#line 97
  if ((int )*oli != 58) {
#line 98
    BSDoptarg = (char *)((void *)0);
#line 99
    if (! *place) {
#line 100
      BSDoptind ++;
    }
  } else {
#line 103
    if (*place) {
#line 104
      BSDoptarg = place;
    } else {
#line 105
      BSDoptind ++;
#line 105
      if (nargc <= BSDoptind) {
#line 106
        place = (char *)"";
#line 107
        if ((int const   )*ostr == 58) {
#line 108
          return (':');
        }
#line 109
        if (BSDopterr) {
#line 110
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: option requires an argument -- %c\n",
                  __progname, BSDoptopt);
        }
#line 113
        return ('?');
      } else {
#line 116
        BSDoptarg = (char *)*(nargv + BSDoptind);
      }
    }
#line 117
    place = (char *)"";
#line 118
    BSDoptind ++;
  }
#line 120
  return (BSDoptopt);
}
}
#line 1 "getrrsetbyname.o"
#line 589 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 591
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 603
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 38 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                  size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 1304 "/usr/include/bits/string2.h"
extern  __attribute__((__nothrow__)) char *__strdup(char const   *__string )  __attribute__((__malloc__)) ;
#line 61 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) int *__h_errno_location(void)  __attribute__((__const__)) ;
#line 237 "/usr/include/resolv.h"
extern struct __res_state *__res_state(void)  __attribute__((__const__)) ;
#line 261
extern  __attribute__((__nothrow__)) int __res_init(void) ;
#line 265
extern  __attribute__((__nothrow__)) int __res_query(char const   * , int  , int  ,
                                                     u_char * , int  ) ;
#line 345
extern  __attribute__((__nothrow__)) int __dn_expand(u_char const   * , u_char const   * ,
                                                     u_char const   * , char * , int  ) ;
#line 105 "./openbsd-compat/getrrsetbyname.h"
int getrrsetbyname(char const   *hostname , unsigned int rdclass , unsigned int rdtype ,
                   unsigned int flags , struct rrsetinfo **res ) ;
#line 106
void freerrset(struct rrsetinfo *rrset ) ;
#line 118 "openbsd-compat/getrrsetbyname.c"
extern u_int16_t _getshort(u_char const   * ) ;
#line 132
extern u_int32_t _getlong(u_char const   * ) ;
#line 164
static struct dns_response *parse_dns_response(u_char const   *answer , int size ) ;
#line 165
static struct dns_query *parse_dns_qsection(u_char const   *answer , int size , u_char const   **cp ,
                                            int count ) ;
#line 167
static struct dns_rr *parse_dns_rrsection(u_char const   *answer , int size , u_char const   **cp ,
                                          int count ) ;
#line 170
static void free_dns_query(struct dns_query *p ) ;
#line 171
static void free_dns_rr(struct dns_rr *p ) ;
#line 172
static void free_dns_response(struct dns_response *p ) ;
#line 174
static int count_dns_rr(struct dns_rr *p , u_int16_t class , u_int16_t type ) ;
#line 176 "openbsd-compat/getrrsetbyname.c"
int getrrsetbyname(char const   *hostname , unsigned int rdclass , unsigned int rdtype ,
                   unsigned int flags , struct rrsetinfo **res ) 
{ struct __res_state *_resp ;
  struct __res_state *tmp ;
  int result ;
  struct rrsetinfo *rrset ;
  struct dns_response *response ;
  struct dns_rr *rr ;
  struct rdatainfo *rdata ;
  int length ;
  unsigned int index_ans ;
  unsigned int index_sig ;
  u_char answer[65536] ;
  int tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  void *tmp___19 ;

  {
#line 181
  tmp = __res_state();
#line 181
  _resp = tmp;
#line 183
  rrset = (struct rrsetinfo *)((void *)0);
#line 184
  response = (struct dns_response *)((void *)0);
#line 192
  if (rdclass > 65535U) {
#line 193
    result = 3;
    goto fail;
  } else {
#line 192
    if (rdtype > 65535U) {
#line 193
      result = 3;
      goto fail;
    }
  }
#line 198
  if (rdclass == 255U) {
#line 199
    result = 3;
    goto fail;
  } else {
#line 198
    if (rdtype == 255U) {
#line 199
      result = 3;
      goto fail;
    }
  }
#line 204
  if (flags) {
#line 205
    result = 3;
    goto fail;
  }
#line 210
  if ((_resp->options & 1UL) == 0UL) {
#line 210
    tmp___0 = __res_init();
#line 210
    if (tmp___0 == -1) {
#line 211
      result = 2;
      goto fail;
    }
  }
#line 226
  length = __res_query(hostname, (int )rdclass, (int )rdtype, answer, (int )sizeof(answer));
#line 228
  if (length < 0) {
#line 229
    tmp___1 = __h_errno_location();
#line 229
    switch (*tmp___1) {
    case 1: 
#line 231
    result = 4;
    goto fail;
    case 4: 
#line 234
    result = 5;
    goto fail;
    default: 
#line 237
    result = 2;
    goto fail;
    }
  }
#line 243
  response = parse_dns_response((u_char const   *)(answer), length);
#line 244
  if ((unsigned int )response == (unsigned int )((void *)0)) {
#line 245
    result = 2;
    goto fail;
  }
#line 249
  if (response->header.qdcount != 1U) {
#line 250
    result = 2;
    goto fail;
  }
#line 255
  tmp___2 = calloc(1U, sizeof(struct rrsetinfo ));
#line 255
  rrset = (struct rrsetinfo *)tmp___2;
#line 256
  if ((unsigned int )rrset == (unsigned int )((void *)0)) {
#line 257
    result = 1;
    goto fail;
  }
#line 260
  rrset->rri_rdclass = (unsigned int )(response->query)->class;
#line 261
  rrset->rri_rdtype = (unsigned int )(response->query)->type;
#line 262
  rrset->rri_ttl = (unsigned int )(response->answer)->ttl;
#line 263
  rrset->rri_nrdatas = response->header.ancount;
#line 267
  if (response->header.ad == 1U) {
#line 268
    rrset->rri_flags |= 1U;
  }
#line 272
  tmp___12 = __strdup((char const   *)(response->answer)->name);
#line 272
  rrset->rri_name = tmp___12;
#line 273
  if ((unsigned int )rrset->rri_name == (unsigned int )((void *)0)) {
#line 274
    result = 1;
    goto fail;
  }
#line 279
  tmp___13 = count_dns_rr(response->answer, (unsigned short )rrset->rri_rdclass, (unsigned short )rrset->rri_rdtype);
#line 279
  rrset->rri_nrdatas = (unsigned int )tmp___13;
#line 281
  tmp___14 = count_dns_rr(response->answer, (unsigned short )rrset->rri_rdclass, (unsigned short)24);
#line 281
  rrset->rri_nsigs = (unsigned int )tmp___14;
#line 285
  tmp___15 = calloc(rrset->rri_nrdatas, sizeof(struct rdatainfo ));
#line 285
  rrset->rri_rdatas = (struct rdatainfo *)tmp___15;
#line 287
  if ((unsigned int )rrset->rri_rdatas == (unsigned int )((void *)0)) {
#line 288
    result = 1;
    goto fail;
  }
#line 293
  tmp___16 = calloc(rrset->rri_nsigs, sizeof(struct rdatainfo ));
#line 293
  rrset->rri_sigs = (struct rdatainfo *)tmp___16;
#line 294
  if ((unsigned int )rrset->rri_sigs == (unsigned int )((void *)0)) {
#line 295
    result = 1;
    goto fail;
  }
#line 300
  rr = response->answer;
#line 300
  index_ans = 0U;
#line 300
  index_sig = 0U;
#line 300
  while (rr) {
#line 303
    rdata = (struct rdatainfo *)((void *)0);
#line 305
    if ((unsigned int )rr->class == rrset->rri_rdclass) {
#line 305
      if ((unsigned int )rr->type == rrset->rri_rdtype) {
#line 307
        tmp___17 = index_ans;
#line 307
        index_ans ++;
#line 307
        rdata = rrset->rri_rdatas + tmp___17;
      }
    }
#line 309
    if ((unsigned int )rr->class == rrset->rri_rdclass) {
#line 309
      if ((int )rr->type == 24) {
#line 311
        tmp___18 = index_sig;
#line 311
        index_sig ++;
#line 311
        rdata = rrset->rri_sigs + tmp___18;
      }
    }
#line 313
    if (rdata) {
#line 314
      rdata->rdi_length = (unsigned int )rr->size;
#line 315
      tmp___19 = malloc((unsigned int )rr->size);
#line 315
      rdata->rdi_data = (unsigned char *)tmp___19;
#line 317
      if ((unsigned int )rdata->rdi_data == (unsigned int )((void *)0)) {
#line 318
        result = 1;
        goto fail;
      }
#line 321
      memcpy((void * __restrict  )rdata->rdi_data, (void const   * __restrict  )rr->rdata,
             (unsigned int )rr->size);
    }
#line 300
    rr = rr->next;
  }
#line 324
  free_dns_response(response);
#line 326
  *res = rrset;
#line 327
  return (0);
  fail: 
#line 330
  if ((unsigned int )rrset != (unsigned int )((void *)0)) {
#line 331
    freerrset(rrset);
  }
#line 332
  if ((unsigned int )response != (unsigned int )((void *)0)) {
#line 333
    free_dns_response(response);
  }
#line 334
  return (result);
}
}
#line 337 "openbsd-compat/getrrsetbyname.c"
void freerrset(struct rrsetinfo *rrset ) 
{ u_int16_t i ;

  {
#line 342
  if ((unsigned int )rrset == (unsigned int )((void *)0)) {
#line 343
    return;
  }
#line 345
  if (rrset->rri_rdatas) {
#line 346
    i = (unsigned short)0;
#line 346
    while ((unsigned int )i < rrset->rri_nrdatas) {
#line 347
      if ((unsigned int )(rrset->rri_rdatas + i)->rdi_data == (unsigned int )((void *)0)) {
#line 348
        break;
      }
#line 349
      free((void *)(rrset->rri_rdatas + i)->rdi_data);
#line 346
      i = (u_int16_t )((int )i + 1);
    }
#line 351
    free((void *)rrset->rri_rdatas);
  }
#line 354
  if (rrset->rri_sigs) {
#line 355
    i = (unsigned short)0;
#line 355
    while ((unsigned int )i < rrset->rri_nsigs) {
#line 356
      if ((unsigned int )(rrset->rri_sigs + i)->rdi_data == (unsigned int )((void *)0)) {
#line 357
        break;
      }
#line 358
      free((void *)(rrset->rri_sigs + i)->rdi_data);
#line 355
      i = (u_int16_t )((int )i + 1);
    }
#line 360
    free((void *)rrset->rri_sigs);
  }
#line 363
  if (rrset->rri_name) {
#line 364
    free((void *)rrset->rri_name);
  }
#line 365
  free((void *)rrset);
#line 366
  return;
}
}
#line 371 "openbsd-compat/getrrsetbyname.c"
static struct dns_response *parse_dns_response(u_char const   *answer , int size ) 
{ struct dns_response *resp ;
  u_char const   *cp ;
  void *tmp ;
  register unsigned short __v ;
  register unsigned short __x ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  register unsigned short __v___1 ;
  register unsigned short __x___1 ;
  register unsigned short __v___2 ;
  register unsigned short __x___2 ;

  {
#line 378
  tmp = calloc(1U, sizeof(*resp));
#line 378
  resp = (struct dns_response *)tmp;
#line 379
  if ((unsigned int )resp == (unsigned int )((void *)0)) {
#line 380
    return ((struct dns_response *)((void *)0));
  }
#line 383
  cp = answer;
#line 386
  memcpy((void * __restrict  )(& resp->header), (void const   * __restrict  )cp, 12U);
#line 387
  cp += 12;
#line 390
  __x = (unsigned short )resp->header.qdcount;
#line 390
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 390
  resp->header.qdcount = (unsigned int )__v;
#line 391
  __x___0 = (unsigned short )resp->header.ancount;
#line 391
  __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 391
  resp->header.ancount = (unsigned int )__v___0;
#line 392
  __x___1 = (unsigned short )resp->header.nscount;
#line 392
  __asm__  ("rorw $8, %w0": "=r" (__v___1): "0" (__x___1): "cc");
#line 392
  resp->header.nscount = (unsigned int )__v___1;
#line 393
  __x___2 = (unsigned short )resp->header.arcount;
#line 393
  __asm__  ("rorw $8, %w0": "=r" (__v___2): "0" (__x___2): "cc");
#line 393
  resp->header.arcount = (unsigned int )__v___2;
#line 396
  if (resp->header.qdcount < 1U) {
#line 397
    free_dns_response(resp);
#line 398
    return ((struct dns_response *)((void *)0));
  }
#line 402
  resp->query = parse_dns_qsection(answer, size, & cp, (int )resp->header.qdcount);
#line 404
  if (resp->header.qdcount) {
#line 404
    if ((unsigned int )resp->query == (unsigned int )((void *)0)) {
#line 405
      free_dns_response(resp);
#line 406
      return ((struct dns_response *)((void *)0));
    }
  }
#line 410
  resp->answer = parse_dns_rrsection(answer, size, & cp, (int )resp->header.ancount);
#line 412
  if (resp->header.ancount) {
#line 412
    if ((unsigned int )resp->answer == (unsigned int )((void *)0)) {
#line 413
      free_dns_response(resp);
#line 414
      return ((struct dns_response *)((void *)0));
    }
  }
#line 418
  resp->authority = parse_dns_rrsection(answer, size, & cp, (int )resp->header.nscount);
#line 420
  if (resp->header.nscount) {
#line 420
    if ((unsigned int )resp->authority == (unsigned int )((void *)0)) {
#line 421
      free_dns_response(resp);
#line 422
      return ((struct dns_response *)((void *)0));
    }
  }
#line 426
  resp->additional = parse_dns_rrsection(answer, size, & cp, (int )resp->header.arcount);
#line 428
  if (resp->header.arcount) {
#line 428
    if ((unsigned int )resp->additional == (unsigned int )((void *)0)) {
#line 429
      free_dns_response(resp);
#line 430
      return ((struct dns_response *)((void *)0));
    }
  }
#line 433
  return (resp);
}
}
#line 436 "openbsd-compat/getrrsetbyname.c"
static struct dns_query *parse_dns_qsection(u_char const   *answer , int size , u_char const   **cp ,
                                            int count ) 
{ struct dns_query *head ;
  struct dns_query *curr ;
  struct dns_query *prev ;
  int i ;
  int length ;
  char name[1025] ;
  void *tmp ;
  char *tmp___9 ;

  {
#line 443
  i = 1;
#line 443
  head = (struct dns_query *)((void *)0);
#line 443
  prev = (struct dns_query *)((void *)0);
#line 443
  while (i <= count) {
#line 446
    tmp = calloc(1U, sizeof(struct dns_query ));
#line 446
    curr = (struct dns_query *)tmp;
#line 447
    if ((unsigned int )curr == (unsigned int )((void *)0)) {
#line 448
      free_dns_query(head);
#line 449
      return ((struct dns_query *)((void *)0));
    }
#line 451
    if ((unsigned int )head == (unsigned int )((void *)0)) {
#line 452
      head = curr;
    }
#line 453
    if ((unsigned int )prev != (unsigned int )((void *)0)) {
#line 454
      prev->next = curr;
    }
#line 457
    length = __dn_expand(answer, answer + size, *cp, name, (int )sizeof(name));
#line 459
    if (length < 0) {
#line 460
      free_dns_query(head);
#line 461
      return ((struct dns_query *)((void *)0));
    }
#line 463
    tmp___9 = __strdup((char const   *)(name));
#line 463
    curr->name = tmp___9;
#line 464
    if ((unsigned int )curr->name == (unsigned int )((void *)0)) {
#line 465
      free_dns_query(head);
#line 466
      return ((struct dns_query *)((void *)0));
    }
#line 468
    *cp += length;
#line 471
    curr->type = _getshort(*cp);
#line 472
    *cp += 2;
#line 475
    curr->class = _getshort(*cp);
#line 476
    *cp += 2;
#line 443
    i ++;
#line 443
    prev = curr;
  }
#line 479
  return (head);
}
}
#line 482 "openbsd-compat/getrrsetbyname.c"
static struct dns_rr *parse_dns_rrsection(u_char const   *answer , int size , u_char const   **cp ,
                                          int count ) 
{ struct dns_rr *head ;
  struct dns_rr *curr ;
  struct dns_rr *prev ;
  int i ;
  int length ;
  char name[1025] ;
  void *tmp ;
  char *tmp___9 ;
  u_int32_t tmp___10 ;

  {
#line 490
  i = 1;
#line 490
  head = (struct dns_rr *)((void *)0);
#line 490
  prev = (struct dns_rr *)((void *)0);
#line 490
  while (i <= count) {
#line 493
    tmp = calloc(1U, sizeof(struct dns_rr ));
#line 493
    curr = (struct dns_rr *)tmp;
#line 494
    if ((unsigned int )curr == (unsigned int )((void *)0)) {
#line 495
      free_dns_rr(head);
#line 496
      return ((struct dns_rr *)((void *)0));
    }
#line 498
    if ((unsigned int )head == (unsigned int )((void *)0)) {
#line 499
      head = curr;
    }
#line 500
    if ((unsigned int )prev != (unsigned int )((void *)0)) {
#line 501
      prev->next = curr;
    }
#line 504
    length = __dn_expand(answer, answer + size, *cp, name, (int )sizeof(name));
#line 506
    if (length < 0) {
#line 507
      free_dns_rr(head);
#line 508
      return ((struct dns_rr *)((void *)0));
    }
#line 510
    tmp___9 = __strdup((char const   *)(name));
#line 510
    curr->name = tmp___9;
#line 511
    if ((unsigned int )curr->name == (unsigned int )((void *)0)) {
#line 512
      free_dns_rr(head);
#line 513
      return ((struct dns_rr *)((void *)0));
    }
#line 515
    *cp += length;
#line 518
    curr->type = _getshort(*cp);
#line 519
    *cp += 2;
#line 522
    curr->class = _getshort(*cp);
#line 523
    *cp += 2;
#line 526
    tmp___10 = _getlong(*cp);
#line 526
    curr->ttl = (unsigned short )tmp___10;
#line 527
    *cp += 4;
#line 530
    curr->size = _getshort(*cp);
#line 531
    *cp += 2;
#line 534
    curr->rdata = malloc((unsigned int )curr->size);
#line 535
    if ((unsigned int )curr->rdata == (unsigned int )((void *)0)) {
#line 536
      free_dns_rr(head);
#line 537
      return ((struct dns_rr *)((void *)0));
    }
#line 539
    memcpy((void * __restrict  )curr->rdata, (void const   * __restrict  )*cp, (unsigned int )curr->size);
#line 540
    *cp += (int )curr->size;
#line 490
    i ++;
#line 490
    prev = curr;
  }
#line 543
  return (head);
}
}
#line 546 "openbsd-compat/getrrsetbyname.c"
static void free_dns_query(struct dns_query *p ) 
{ 

  {
#line 549
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 550
    return;
  }
#line 552
  if (p->name) {
#line 553
    free((void *)p->name);
  }
#line 554
  free_dns_query(p->next);
#line 555
  free((void *)p);
#line 556
  return;
}
}
#line 558 "openbsd-compat/getrrsetbyname.c"
static void free_dns_rr(struct dns_rr *p ) 
{ 

  {
#line 561
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 562
    return;
  }
#line 564
  if (p->name) {
#line 565
    free((void *)p->name);
  }
#line 566
  if (p->rdata) {
#line 567
    free(p->rdata);
  }
#line 568
  free_dns_rr(p->next);
#line 569
  free((void *)p);
#line 570
  return;
}
}
#line 572 "openbsd-compat/getrrsetbyname.c"
static void free_dns_response(struct dns_response *p ) 
{ 

  {
#line 575
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 576
    return;
  }
#line 578
  free_dns_query(p->query);
#line 579
  free_dns_rr(p->answer);
#line 580
  free_dns_rr(p->authority);
#line 581
  free_dns_rr(p->additional);
#line 582
  free((void *)p);
#line 583
  return;
}
}
#line 585 "openbsd-compat/getrrsetbyname.c"
static int count_dns_rr(struct dns_rr *p , u_int16_t class , u_int16_t type ) 
{ int n___0 ;

  {
#line 588
  n___0 = 0;
#line 590
  while (p) {
#line 591
    if ((int )p->class == (int )class) {
#line 591
      if ((int )p->type == (int )type) {
#line 592
        n___0 ++;
      }
    }
#line 593
    p = p->next;
  }
#line 596
  return (n___0);
}
}
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
#line 1 "glob.o"
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 263
__inline static  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path ,
                                                        struct stat * __restrict  __statbuf )  __asm__("lstat64") __attribute__((__nonnull__(1,2))) ;
#line 394
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __asm__("__xstat64") __attribute__((__nonnull__(2,3))) ;
#line 397
extern  __attribute__((__nothrow__)) int __lxstat(int __ver , char const   *__filename ,
                                                  struct stat *__stat_buf )  __asm__("__lxstat64") __attribute__((__nonnull__(2,3))) ;
#line 433
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 433 "/usr/include/sys/stat.h"
__inline static int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
#line 436
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
#line 436
  return (tmp);
}
}
#line 440
__inline static  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path ,
                                                        struct stat * __restrict  __statbuf )  __asm__("lstat64") __attribute__((__nonnull__(1,2))) ;
#line 440 "/usr/include/sys/stat.h"
__inline static int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
#line 443
  tmp = __lxstat(3, (char const   *)__path, (struct stat *)__statbuf);
#line 443
  return (tmp);
}
}
#line 600 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__warn_unused_result__,
__malloc__)) ;
#line 660
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 780
extern void qsort(void *__base , size_t __nmemb , size_t __size , int (*__compar)(void const   * ,
                                                                                  void const   * ) )  __attribute__((__nonnull__(1,4))) ;
#line 242 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 111 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 117
extern struct passwd *getpwnam(char const   *__name ) ;
#line 642 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 645
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 92 "./openbsd-compat/glob.h"
int glob(char const   *pattern , int flags , int (*errfunc)(char const   * , int  ) ,
         glob_t *pglob ) ;
#line 93
void globfree(glob_t *pglob ) ;
#line 69 "./openbsd-compat/openbsd-compat.h"
size_t strlcpy(char *dst , char const   *src , size_t siz ) ;
#line 39 "openbsd-compat/glob.c"
static long get_arg_max(void) 
{ 

  {
#line 43
  return (131072L);
}
}
#line 131
static int compare(void const   *p , void const   *q ) ;
#line 132
static int g_Ctoc(Char const   *str , char *buf___1 , u_int len ) ;
#line 133
static int g_lstat(Char *fn , struct stat *sb , glob_t *pglob ) ;
#line 134
static DIR *g_opendir(Char *str , glob_t *pglob ) ;
#line 135
static Char *g_strchr(Char *str , int ch ) ;
#line 136
static int g_stat(Char *fn , struct stat *sb , glob_t *pglob ) ;
#line 137
static int glob0(Char const   *pattern , glob_t *pglob ) ;
#line 138
static int glob1(Char *pattern , Char *pattern_last , glob_t *pglob , size_t *limitp ) ;
#line 139
static int glob2(Char *pathbuf , Char *pathbuf_last , Char *pathend , Char *pathend_last ,
                 Char *pattern , Char *pattern_last , glob_t *pglob , size_t *limitp ) ;
#line 141
static int glob3(Char *pathbuf , Char *pathbuf_last , Char *pathend , Char *pathend_last ,
                 Char *pattern , Char *pattern_last , Char *restpattern , Char *restpattern_last ,
                 glob_t *pglob , size_t *limitp ) ;
#line 143
static int globextend(Char const   *path , glob_t *pglob , size_t *limitp ) ;
#line 144
static Char const   *globtilde(Char const   *pattern , Char *patbuf , size_t patbuf_len ,
                               glob_t *pglob ) ;
#line 146
static int globexp1(Char const   *pattern , glob_t *pglob ) ;
#line 147
static int globexp2(Char const   *ptr , Char const   *pattern , glob_t *pglob , int *rv ) ;
#line 148
static int match(Char *name , Char *pat , Char *patend ) ;
#line 153 "openbsd-compat/glob.c"
int glob(char const   *pattern , int flags , int (*errfunc)(char const   * , int  ) ,
         glob_t *pglob ) 
{ u_char const   *patnext ;
  int c ;
  Char *bufnext ;
  Char *bufend ;
  Char patbuf[4096] ;
  Char *tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  Char *tmp___2 ;
  Char *tmp___3 ;
  u_char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 161
  patnext = (u_char const   *)((u_char *)pattern);
#line 162
  if (! (flags & 1)) {
#line 163
    pglob->gl_pathc = 0;
#line 164
    pglob->gl_pathv = (char **)((void *)0);
#line 165
    if (! (flags & 2)) {
#line 166
      pglob->gl_offs = 0;
    }
  }
#line 168
  pglob->gl_flags = flags & -257;
#line 169
  pglob->gl_errfunc = errfunc;
#line 170
  pglob->gl_matchc = 0;
#line 172
  bufnext = patbuf;
#line 173
  bufend = (bufnext + 4096) - 1;
#line 174
  if (flags & 4096) {
#line 175
    while (1) {
#line 175
      if ((unsigned int )bufnext < (unsigned int )bufend) {
#line 175
        tmp___0 = patnext;
#line 175
        patnext ++;
#line 175
        c = (int )*tmp___0;
#line 175
        if (! (c != 0)) {
#line 175
          break;
        }
      } else {
#line 175
        break;
      }
#line 176
      tmp = bufnext;
#line 176
      bufnext ++;
#line 176
      *tmp = (unsigned short )c;
    }
  } else {
#line 179
    while (1) {
#line 179
      if ((unsigned int )bufnext < (unsigned int )bufend) {
#line 179
        tmp___4 = patnext;
#line 179
        patnext ++;
#line 179
        c = (int )*tmp___4;
#line 179
        if (! (c != 0)) {
#line 179
          break;
        }
      } else {
#line 179
        break;
      }
#line 180
      if (c == 92) {
#line 181
        tmp___1 = patnext;
#line 181
        patnext ++;
#line 181
        c = (int )*tmp___1;
#line 181
        if (c == 0) {
#line 182
          c = '\\';
#line 183
          patnext --;
        }
#line 185
        tmp___2 = bufnext;
#line 185
        bufnext ++;
#line 185
        *tmp___2 = (unsigned short )(c | 16384);
      } else {
#line 187
        tmp___3 = bufnext;
#line 187
        bufnext ++;
#line 187
        *tmp___3 = (unsigned short )c;
      }
    }
  }
#line 189
  *bufnext = (unsigned short )'\000';
#line 191
  if (flags & 128) {
#line 192
    tmp___5 = globexp1((Char const   *)(patbuf), pglob);
#line 192
    return (tmp___5);
  } else {
#line 194
    tmp___6 = glob0((Char const   *)(patbuf), pglob);
#line 194
    return (tmp___6);
  }
}
}
#line 202 "openbsd-compat/glob.c"
static int globexp1(Char const   *pattern , glob_t *pglob ) 
{ Char const   *ptr ;
  int rv ;
  int tmp ;
  int tmp___0 ;
  Char *tmp___1 ;
  int tmp___2 ;

  {
#line 205
  ptr = pattern;
#line 209
  if ((int const   )*(pattern + 0) == 123) {
#line 209
    if ((int const   )*(pattern + 1) == 125) {
#line 209
      if ((int const   )*(pattern + 2) == 0) {
#line 210
        tmp = glob0(pattern, pglob);
#line 210
        return (tmp);
      }
    }
  }
#line 212
  while (1) {
#line 212
    tmp___1 = g_strchr((Char *)ptr, '{');
#line 212
    ptr = (Char const   *)tmp___1;
#line 212
    if (! ((unsigned int )ptr != (unsigned int )((void *)0))) {
#line 212
      break;
    }
#line 213
    tmp___0 = globexp2(ptr, pattern, pglob, & rv);
#line 213
    if (! tmp___0) {
#line 214
      return (rv);
    }
  }
#line 216
  tmp___2 = glob0(pattern, pglob);
#line 216
  return (tmp___2);
}
}
#line 225 "openbsd-compat/glob.c"
static int globexp2(Char const   *ptr , Char const   *pattern , glob_t *pglob , int *rv ) 
{ int i ;
  Char *lm ;
  Char *ls ;
  Char const   *pe ;
  Char const   *pm ;
  Char const   *pl ;
  Char patbuf[4096] ;
  Char *tmp ;
  Char const   *tmp___0 ;
  Char const   *tmp___1 ;
  Char const   *tmp___2 ;
  Char *tmp___3 ;
  Char const   *tmp___4 ;
  Char *tmp___5 ;
  Char const   *tmp___6 ;

  {
#line 234
  lm = patbuf;
#line 234
  pm = pattern;
#line 234
  while ((unsigned int )pm != (unsigned int )ptr) {
#line 234
    tmp = lm;
#line 234
    lm ++;
#line 234
    tmp___0 = pm;
#line 234
    pm ++;
#line 234
    *tmp = (unsigned short )*tmp___0;
  }
#line 236
  *lm = (unsigned short )'\000';
#line 237
  ls = lm;
#line 240
  i = 0;
#line 240
  ptr ++;
#line 240
  pe = ptr;
#line 240
  while (*pe) {
#line 241
    if ((int const   )*pe == 91) {
#line 243
      tmp___1 = pe;
#line 243
      pe ++;
#line 243
      pm = tmp___1;
#line 243
      while (1) {
#line 243
        if ((int const   )*pe != 93) {
#line 243
          if (! ((int const   )*pe != 0)) {
#line 243
            break;
          }
        } else {
#line 243
          break;
        }
#line 243
        pe ++;
      }
#line 245
      if ((int const   )*pe == 0) {
#line 250
        pe = pm;
      }
    } else {
#line 252
      if ((int const   )*pe == 123) {
#line 253
        i ++;
      } else {
#line 254
        if ((int const   )*pe == 125) {
#line 255
          if (i == 0) {
#line 256
            break;
          }
#line 257
          i --;
        }
      }
    }
#line 240
    pe ++;
  }
#line 261
  if (i != 0) {
#line 262
    *rv = glob0((Char const   *)(patbuf), pglob);
#line 263
    return (0);
  } else {
#line 261
    if ((int const   )*pe == 0) {
#line 262
      *rv = glob0((Char const   *)(patbuf), pglob);
#line 263
      return (0);
    }
  }
#line 266
  i = 0;
#line 266
  pm = ptr;
#line 266
  pl = pm;
#line 266
  while ((unsigned int )pm <= (unsigned int )pe) {
#line 267
    switch ((int )*pm) {
    case 91: 
#line 270
    tmp___2 = pm;
#line 270
    pm ++;
#line 270
    pl = tmp___2;
#line 270
    while (1) {
#line 270
      if ((int const   )*pm != 93) {
#line 270
        if (! ((int const   )*pm != 0)) {
#line 270
          break;
        }
      } else {
#line 270
        break;
      }
#line 270
      pm ++;
    }
#line 272
    if ((int const   )*pm == 0) {
#line 277
      pm = pl;
    }
#line 279
    break;
    case 123: 
#line 282
    i ++;
#line 283
    break;
    case 125: 
#line 286
    if (i) {
#line 287
      i --;
#line 288
      break;
    }
    case 44: 
#line 292
    if (i) {
#line 292
      if ((int const   )*pm == 44) {
#line 293
        break;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 296
      lm = ls;
#line 296
      while ((unsigned int )pl < (unsigned int )pm) {
#line 296
        tmp___3 = lm;
#line 296
        lm ++;
#line 296
        tmp___4 = pl;
#line 296
        pl ++;
#line 296
        *tmp___3 = (unsigned short )*tmp___4;
      }
#line 303
      pl = pe + 1;
#line 303
      while (1) {
#line 303
        tmp___5 = lm;
#line 303
        lm ++;
#line 303
        tmp___6 = pl;
#line 303
        pl ++;
#line 303
        *tmp___5 = (unsigned short )*tmp___6;
#line 303
        if (! ((int )*tmp___5 != 0)) {
#line 303
          break;
        }
      }
#line 310
      *rv = globexp1((Char const   *)(patbuf), pglob);
#line 313
      pl = pm + 1;
    }
#line 315
    break;
    default: ;
#line 318
    break;
    }
#line 266
    pm ++;
  }
#line 321
  *rv = 0;
#line 322
  return (0);
}
}
#line 330 "openbsd-compat/glob.c"
static Char const   *globtilde(Char const   *pattern , Char *patbuf , size_t patbuf_len ,
                               glob_t *pglob ) 
{ struct passwd *pwd ;
  char *h___0 ;
  Char const   *p ;
  Char *b ;
  Char *eb ;
  char *tmp ;
  Char const   *tmp___0 ;
  __uid_t tmp___1 ;
  __uid_t tmp___2 ;
  __uid_t tmp___3 ;
  Char *tmp___4 ;
  char *tmp___5 ;
  Char *tmp___6 ;
  Char const   *tmp___7 ;

  {
#line 338
  if ((int const   )*pattern != 126) {
#line 339
    return (pattern);
  } else {
#line 338
    if (! (pglob->gl_flags & 2048)) {
#line 339
      return (pattern);
    }
  }
#line 342
  eb = patbuf + (patbuf_len - 1U);
#line 343
  p = pattern + 1;
#line 343
  h___0 = (char *)patbuf;
#line 343
  while (1) {
#line 343
    if ((unsigned int )h___0 < (unsigned int )((char *)eb)) {
#line 343
      if (*p) {
#line 343
        if (! ((int const   )*p != 47)) {
#line 343
          break;
        }
      } else {
#line 343
        break;
      }
    } else {
#line 343
      break;
    }
#line 343
    tmp = h___0;
#line 343
    h___0 ++;
#line 343
    tmp___0 = p;
#line 343
    p ++;
#line 343
    *tmp = (char )*tmp___0;
  }
#line 347
  *h___0 = (char )'\000';
#line 354
  if ((int )*((char *)patbuf + 0) == 0) {
#line 362
    tmp___2 = getuid();
#line 362
    tmp___3 = geteuid();
#line 362
    if (tmp___2 != tmp___3) {
      goto _L;
    } else {
#line 362
      h___0 = getenv("HOME");
#line 362
      if ((unsigned int )h___0 == (unsigned int )((void *)0)) {
        _L: /* CIL Label */ 
#line 363
        tmp___1 = getuid();
#line 363
        pwd = getpwuid(tmp___1);
#line 363
        if ((unsigned int )pwd == (unsigned int )((void *)0)) {
#line 364
          return (pattern);
        } else {
#line 366
          h___0 = pwd->pw_dir;
        }
      }
    }
  } else {
#line 372
    pwd = getpwnam((char const   *)((char *)patbuf));
#line 372
    if ((unsigned int )pwd == (unsigned int )((void *)0)) {
#line 373
      return (pattern);
    } else {
#line 375
      h___0 = pwd->pw_dir;
    }
  }
#line 379
  b = patbuf;
#line 379
  while (1) {
#line 379
    if ((unsigned int )b < (unsigned int )eb) {
#line 379
      if (! *h___0) {
#line 379
        break;
      }
    } else {
#line 379
      break;
    }
#line 379
    tmp___4 = b;
#line 379
    b ++;
#line 379
    tmp___5 = h___0;
#line 379
    h___0 ++;
#line 379
    *tmp___4 = (unsigned short )*tmp___5;
  }
#line 383
  while (1) {
#line 383
    if ((unsigned int )b < (unsigned int )eb) {
#line 383
      tmp___6 = b;
#line 383
      b ++;
#line 383
      tmp___7 = p;
#line 383
      p ++;
#line 383
      *tmp___6 = (unsigned short )*tmp___7;
#line 383
      if (! ((int )*tmp___6 != 0)) {
#line 383
        break;
      }
    } else {
#line 383
      break;
    }
  }
#line 385
  *b = (unsigned short )'\000';
#line 387
  return ((Char const   *)patbuf);
}
}
#line 398 "openbsd-compat/glob.c"
static int glob0(Char const   *pattern , glob_t *pglob ) 
{ Char const   *qpatnext ;
  int c ;
  int err ;
  int oldpathc ;
  Char *bufnext ;
  Char patbuf[4096] ;
  size_t limit ;
  Char *tmp ;
  Char *tmp___0 ;
  Char *tmp___1 ;
  Char *tmp___2 ;
  Char const   *tmp___3 ;
  Char *tmp___4 ;
  Char *tmp___5 ;
  Char *tmp___6 ;
  Char const   *tmp___7 ;
  Char *tmp___8 ;
  Char *tmp___9 ;
  Char *tmp___10 ;
  Char *tmp___11 ;
  Char const   *tmp___12 ;
  int tmp___13 ;

  {
#line 404
  limit = (size_t )0;
#line 406
  qpatnext = globtilde(pattern, patbuf, 4096U, pglob);
#line 407
  oldpathc = pglob->gl_pathc;
#line 408
  bufnext = patbuf;
#line 411
  while (1) {
#line 411
    tmp___12 = qpatnext;
#line 411
    qpatnext ++;
#line 411
    c = (int )*tmp___12;
#line 411
    if (! (c != 0)) {
#line 411
      break;
    }
#line 412
    switch (c) {
    case 91: 
#line 414
    c = (int )*qpatnext;
#line 415
    if (c == 33) {
#line 416
      qpatnext ++;
    }
#line 417
    if ((int const   )*qpatnext == 0) {
      goto _L;
    } else {
#line 417
      tmp___0 = g_strchr((Char *)qpatnext + 1, ']');
#line 417
      if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
        _L: /* CIL Label */ 
#line 419
        tmp = bufnext;
#line 419
        bufnext ++;
#line 419
        *tmp = (unsigned short )'[';
#line 420
        if (c == 33) {
#line 421
          qpatnext --;
        }
#line 422
        break;
      }
    }
#line 424
    tmp___1 = bufnext;
#line 424
    bufnext ++;
#line 424
    *tmp___1 = (unsigned short)32859;
#line 425
    if (c == 33) {
#line 426
      tmp___2 = bufnext;
#line 426
      bufnext ++;
#line 426
      *tmp___2 = (unsigned short)32801;
    }
#line 427
    tmp___3 = qpatnext;
#line 427
    qpatnext ++;
#line 427
    c = (int )*tmp___3;
#line 428
    while (1) {
#line 429
      tmp___4 = bufnext;
#line 429
      bufnext ++;
#line 429
      *tmp___4 = (unsigned short )(c & 255);
#line 430
      if ((int const   )*qpatnext == 45) {
#line 430
        c = (int )*(qpatnext + 1);
#line 430
        if (c != 93) {
#line 432
          tmp___5 = bufnext;
#line 432
          bufnext ++;
#line 432
          *tmp___5 = (unsigned short)32813;
#line 433
          tmp___6 = bufnext;
#line 433
          bufnext ++;
#line 433
          *tmp___6 = (unsigned short )(c & 255);
#line 434
          qpatnext += 2;
        }
      }
#line 428
      tmp___7 = qpatnext;
#line 428
      qpatnext ++;
#line 428
      c = (int )*tmp___7;
#line 428
      if (! (c != 93)) {
#line 428
        break;
      }
    }
#line 437
    pglob->gl_flags |= 256;
#line 438
    tmp___8 = bufnext;
#line 438
    bufnext ++;
#line 438
    *tmp___8 = (unsigned short)32861;
#line 439
    break;
    case 63: 
#line 441
    pglob->gl_flags |= 256;
#line 442
    tmp___9 = bufnext;
#line 442
    bufnext ++;
#line 442
    *tmp___9 = (unsigned short)32831;
#line 443
    break;
    case 42: 
#line 445
    pglob->gl_flags |= 256;
#line 449
    if ((unsigned int )bufnext == (unsigned int )(patbuf)) {
#line 450
      tmp___10 = bufnext;
#line 450
      bufnext ++;
#line 450
      *tmp___10 = (unsigned short)32810;
    } else {
#line 449
      if ((int )*(bufnext + -1) != 32810) {
#line 450
        tmp___10 = bufnext;
#line 450
        bufnext ++;
#line 450
        *tmp___10 = (unsigned short)32810;
      }
    }
#line 451
    break;
    default: 
#line 453
    tmp___11 = bufnext;
#line 453
    bufnext ++;
#line 453
    *tmp___11 = (unsigned short )(c & 255);
#line 454
    break;
    }
  }
#line 457
  *bufnext = (unsigned short )'\000';
#line 462
  err = glob1(patbuf, (patbuf + 4096) - 1, pglob, & limit);
#line 462
  if (err != 0) {
#line 463
    return (err);
  }
#line 471
  if (pglob->gl_pathc == oldpathc) {
#line 472
    if (pglob->gl_flags & 16) {
#line 475
      tmp___13 = globextend(pattern, pglob, & limit);
#line 475
      return (tmp___13);
    } else {
#line 472
      if (pglob->gl_flags & 512) {
#line 472
        if (! (pglob->gl_flags & 256)) {
#line 475
          tmp___13 = globextend(pattern, pglob, & limit);
#line 475
          return (tmp___13);
        } else {
#line 477
          return (-3);
        }
      } else {
#line 477
        return (-3);
      }
    }
  }
#line 479
  if (! (pglob->gl_flags & 32)) {
#line 480
    qsort((void *)((pglob->gl_pathv + pglob->gl_offs) + oldpathc), (unsigned int )(pglob->gl_pathc - oldpathc),
          sizeof(char *), & compare);
  }
#line 482
  return (0);
}
}
#line 485 "openbsd-compat/glob.c"
static int compare(void const   *p , void const   *q ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 488
  if (0) {
#line 488
    __s1_len = strlen((char const   *)*((char **)p));
#line 488
    __s2_len = strlen((char const   *)*((char **)q));
#line 488
    if (! ((unsigned int )((void const   *)(*((char **)p) + 1)) - (unsigned int )((void const   *)*((char **)p)) == 1U)) {
      goto _L___0;
    } else {
#line 488
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 488
        if (! ((unsigned int )((void const   *)(*((char **)q) + 1)) - (unsigned int )((void const   *)*((char **)q)) == 1U)) {
#line 488
          tmp___8 = 1;
        } else {
#line 488
          if (__s2_len >= 4U) {
#line 488
            tmp___8 = 1;
          } else {
#line 488
            tmp___8 = 0;
          }
        }
      } else {
#line 488
        tmp___8 = 0;
      }
    }
#line 488
    if (tmp___8) {
#line 488
      tmp___4 = __builtin_strcmp((char const   *)*((char **)p), (char const   *)*((char **)q));
    } else {
#line 488
      tmp___7 = __builtin_strcmp((char const   *)*((char **)p), (char const   *)*((char **)q));
#line 488
      tmp___4 = tmp___7;
    }
  } else {
#line 488
    tmp___7 = __builtin_strcmp((char const   *)*((char **)p), (char const   *)*((char **)q));
#line 488
    tmp___4 = tmp___7;
  }
#line 488
  return (tmp___4);
}
}
#line 491 "openbsd-compat/glob.c"
static int glob1(Char *pattern , Char *pattern_last , glob_t *pglob , size_t *limitp ) 
{ Char pathbuf[4096] ;
  int tmp ;

  {
#line 497
  if ((int )*pattern == 0) {
#line 498
    return (0);
  }
#line 499
  tmp = glob2(pathbuf, (pathbuf + 4096) - 1, pathbuf, (pathbuf + 4096) - 1, pattern,
              pattern_last, pglob, limitp);
#line 499
  return (tmp);
}
}
#line 509 "openbsd-compat/glob.c"
static int glob2(Char *pathbuf , Char *pathbuf_last , Char *pathend , Char *pathend_last ,
                 Char *pattern , Char *pattern_last , glob_t *pglob , size_t *limitp ) 
{ struct stat sb ;
  Char *p ;
  Char *q ;
  int anymeta ;
  int tmp ;
  Char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  Char *tmp___3 ;
  Char *tmp___4 ;
  Char *tmp___5 ;
  Char *tmp___6 ;
  int tmp___7 ;

  {
#line 521
  anymeta = 0;
#line 521
  while (1) {
#line 522
    if ((int )*pattern == 0) {
#line 523
      *pathend = (unsigned short )'\000';
#line 524
      tmp = g_lstat(pathbuf, & sb, pglob);
#line 524
      if (tmp) {
#line 525
        return (0);
      }
#line 527
      if (pglob->gl_flags & 8) {
#line 527
        if ((int )*(pathend + -1) != 47) {
#line 527
          if ((sb.st_mode & 61440U) == 16384U) {
            goto _L;
          } else {
#line 527
            if ((sb.st_mode & 61440U) == 40960U) {
#line 527
              tmp___1 = g_stat(pathbuf, & sb, pglob);
#line 527
              if (tmp___1 == 0) {
#line 527
                if ((sb.st_mode & 61440U) == 16384U) {
                  _L: /* CIL Label */ 
#line 532
                  if ((unsigned int )(pathend + 1) > (unsigned int )pathend_last) {
#line 533
                    return (1);
                  }
#line 534
                  tmp___0 = pathend;
#line 534
                  pathend ++;
#line 534
                  *tmp___0 = (unsigned short )'/';
#line 535
                  *pathend = (unsigned short )'\000';
                }
              }
            }
          }
        }
      }
#line 537
      (pglob->gl_matchc) ++;
#line 538
      tmp___2 = globextend((Char const   *)pathbuf, pglob, limitp);
#line 538
      return (tmp___2);
    }
#line 542
    q = pathend;
#line 543
    p = pattern;
#line 544
    while (1) {
#line 544
      if ((int )*p != 0) {
#line 544
        if (! ((int )*p != 47)) {
#line 544
          break;
        }
      } else {
#line 544
        break;
      }
#line 545
      if (((int )*p & 32768) != 0) {
#line 546
        anymeta = 1;
      }
#line 547
      if ((unsigned int )(q + 1) > (unsigned int )pathend_last) {
#line 548
        return (1);
      }
#line 549
      tmp___3 = q;
#line 549
      q ++;
#line 549
      tmp___4 = p;
#line 549
      p ++;
#line 549
      *tmp___3 = *tmp___4;
    }
#line 552
    if (! anymeta) {
#line 553
      pathend = q;
#line 554
      pattern = p;
#line 555
      while ((int )*pattern == 47) {
#line 556
        if ((unsigned int )(pathend + 1) > (unsigned int )pathend_last) {
#line 557
          return (1);
        }
#line 558
        tmp___5 = pathend;
#line 558
        pathend ++;
#line 558
        tmp___6 = pattern;
#line 558
        pattern ++;
#line 558
        *tmp___5 = *tmp___6;
      }
    } else {
#line 562
      tmp___7 = glob3(pathbuf, pathbuf_last, pathend, pathend_last, pattern, pattern_last,
                      p, pattern_last, pglob, limitp);
#line 562
      return (tmp___7);
    }
  }
}
}
#line 569 "openbsd-compat/glob.c"
static int glob3(Char *pathbuf , Char *pathbuf_last , Char *pathend , Char *pathend_last ,
                 Char *pattern , Char *pattern_last , Char *restpattern , Char *restpattern_last ,
                 glob_t *pglob , size_t *limitp ) 
{ struct dirent *dp ;
  DIR *dirp ;
  int err ;
  char buf___1[4096] ;
  struct dirent *(*readdirfunc)(void * ) ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  u_char *sc ;
  Char *dc ;
  Char *tmp___3 ;
  u_char *tmp___4 ;
  int tmp___5 ;

  {
#line 587
  if ((unsigned int )pathend > (unsigned int )pathend_last) {
#line 588
    return (1);
  }
#line 589
  *pathend = (unsigned short )'\000';
#line 590
  tmp = __errno_location();
#line 590
  *tmp = 0;
#line 592
  dirp = g_opendir(pathbuf, pglob);
#line 592
  if ((unsigned int )dirp == (unsigned int )((void *)0)) {
#line 594
    if (pglob->gl_errfunc) {
#line 595
      tmp___0 = g_Ctoc((Char const   *)pathbuf, buf___1, sizeof(buf___1));
#line 595
      if (tmp___0) {
#line 596
        return (-2);
      }
#line 597
      tmp___1 = __errno_location();
#line 597
      tmp___2 = (*(pglob->gl_errfunc))((char const   *)(buf___1), *tmp___1);
#line 597
      if (tmp___2) {
#line 599
        return (-2);
      } else {
#line 597
        if (pglob->gl_flags & 4) {
#line 599
          return (-2);
        }
      }
    }
#line 601
    return (0);
  }
#line 604
  err = 0;
#line 607
  if (pglob->gl_flags & 64) {
#line 608
    readdirfunc = pglob->gl_readdir;
  } else {
#line 610
    readdirfunc = (struct dirent *(*)(void * ))(& readdir);
  }
#line 611
  while (1) {
#line 611
    dp = (*readdirfunc)((void *)dirp);
#line 611
    if (! dp) {
#line 611
      break;
    }
#line 616
    if ((int )dp->d_name[0] == 46) {
#line 616
      if ((int )*pattern != 46) {
#line 617
        continue;
      }
    }
#line 618
    dc = pathend;
#line 619
    sc = (u_char *)(dp->d_name);
#line 620
    while (1) {
#line 620
      if ((unsigned int )dc < (unsigned int )pathend_last) {
#line 620
        tmp___3 = dc;
#line 620
        dc ++;
#line 620
        tmp___4 = sc;
#line 620
        sc ++;
#line 620
        *tmp___3 = (unsigned short )*tmp___4;
#line 620
        if (! ((int )*tmp___3 != 0)) {
#line 620
          break;
        }
      } else {
#line 620
        break;
      }
    }
#line 622
    if ((unsigned int )dc >= (unsigned int )pathend_last) {
#line 623
      *dc = (unsigned short )'\000';
#line 624
      err = 1;
#line 625
      break;
    }
#line 628
    tmp___5 = match(pathend, pattern, restpattern);
#line 628
    if (! tmp___5) {
#line 629
      *pathend = (unsigned short )'\000';
#line 630
      continue;
    }
#line 632
    dc --;
#line 632
    err = glob2(pathbuf, pathbuf_last, dc, pathend_last, restpattern, restpattern_last,
                pglob, limitp);
#line 634
    if (err) {
#line 635
      break;
    }
  }
#line 638
  if (pglob->gl_flags & 64) {
#line 639
    (*(pglob->gl_closedir))((void *)dirp);
  } else {
#line 641
    closedir(dirp);
  }
#line 642
  return (err);
}
}
#line 660 "openbsd-compat/glob.c"
static int globextend(Char const   *path , glob_t *pglob , size_t *limitp ) 
{ char **pathv ;
  int i ;
  u_int newsize ;
  u_int len ;
  char *copy ;
  Char const   *p ;
  void *tmp___1 ;
  void *tmp___2 ;
  Char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;

  {
#line 669
  newsize = sizeof(*pathv) * (unsigned int )((2 + pglob->gl_pathc) + pglob->gl_offs);
#line 670
  if (pglob->gl_pathv) {
#line 670
    tmp___1 = realloc((void *)((char *)pglob->gl_pathv), newsize);
#line 670
    pathv = (char **)tmp___1;
  } else {
#line 670
    tmp___2 = malloc(newsize);
#line 670
    pathv = (char **)tmp___2;
  }
#line 672
  if ((unsigned int )pathv == (unsigned int )((void *)0)) {
#line 673
    if (pglob->gl_pathv) {
#line 674
      free((void *)pglob->gl_pathv);
#line 675
      pglob->gl_pathv = (char **)((void *)0);
    }
#line 677
    return (-1);
  }
#line 680
  if ((unsigned int )pglob->gl_pathv == (unsigned int )((void *)0)) {
#line 680
    if (pglob->gl_offs > 0) {
#line 682
      pathv += pglob->gl_offs;
#line 683
      i = pglob->gl_offs;
#line 683
      while (1) {
#line 683
        i --;
#line 683
        if (! (i >= 0)) {
#line 683
          break;
        }
#line 684
        pathv --;
#line 684
        *pathv = (char *)((void *)0);
      }
    }
  }
#line 686
  pglob->gl_pathv = pathv;
#line 688
  p = path;
#line 688
  while (1) {
#line 688
    tmp___3 = p;
#line 688
    p ++;
#line 688
    if (! *tmp___3) {
#line 688
      break;
    }
  }
#line 690
  len = (unsigned int )(p - path);
#line 691
  *limitp += len;
#line 692
  tmp___6 = malloc(len);
#line 692
  copy = (char *)tmp___6;
#line 692
  if ((unsigned int )copy != (unsigned int )((void *)0)) {
#line 693
    tmp___4 = g_Ctoc(path, copy, len);
#line 693
    if (tmp___4) {
#line 694
      free((void *)copy);
#line 695
      return (-1);
    }
#line 697
    tmp___5 = pglob->gl_pathc;
#line 697
    (pglob->gl_pathc) ++;
#line 697
    *(pathv + (pglob->gl_offs + tmp___5)) = copy;
  }
#line 699
  *(pathv + (pglob->gl_offs + pglob->gl_pathc)) = (char *)((void *)0);
#line 701
  if (pglob->gl_flags & 8192) {
#line 701
    tmp___8 = get_arg_max();
#line 701
    if (newsize + *limitp >= (unsigned int )tmp___8) {
#line 703
      tmp___7 = __errno_location();
#line 703
      *tmp___7 = 0;
#line 704
      return (-1);
    }
  }
#line 707
  if ((unsigned int )copy == (unsigned int )((void *)0)) {
#line 707
    tmp___9 = -1;
  } else {
#line 707
    tmp___9 = 0;
  }
#line 707
  return (tmp___9);
}
}
#line 715 "openbsd-compat/glob.c"
static int match(Char *name , Char *pat , Char *patend ) 
{ int ok ;
  int negate_range ;
  Char c ;
  Char k ;
  Char *tmp ;
  int tmp___0 ;
  Char *tmp___1 ;
  Char *tmp___2 ;
  Char *tmp___3 ;
  Char *tmp___4 ;
  Char *tmp___5 ;

  {
#line 721
  while ((unsigned int )pat < (unsigned int )patend) {
#line 722
    tmp = pat;
#line 722
    pat ++;
#line 722
    c = *tmp;
#line 723
    switch ((int )c & 65535) {
    case (unsigned short)32810: 
#line 725
    if ((unsigned int )pat == (unsigned int )patend) {
#line 726
      return (1);
    }
#line 727
    while (1) {
#line 728
      tmp___0 = match(name, pat, patend);
#line 728
      if (tmp___0) {
#line 729
        return (1);
      }
#line 727
      tmp___1 = name;
#line 727
      name ++;
#line 727
      if (! ((int )*tmp___1 != 0)) {
#line 727
        break;
      }
    }
#line 731
    return (0);
    case (unsigned short)32831: 
#line 733
    tmp___2 = name;
#line 733
    name ++;
#line 733
    if ((int )*tmp___2 == 0) {
#line 734
      return (0);
    }
#line 735
    break;
    case (unsigned short)32859: 
#line 737
    ok = 0;
#line 738
    tmp___3 = name;
#line 738
    name ++;
#line 738
    k = *tmp___3;
#line 738
    if ((int )k == 0) {
#line 739
      return (0);
    }
#line 740
    negate_range = ((int )*pat & 65535) == 32801;
#line 740
    if (negate_range != 0) {
#line 741
      pat ++;
    }
#line 742
    while (1) {
#line 742
      tmp___4 = pat;
#line 742
      pat ++;
#line 742
      c = *tmp___4;
#line 742
      if (! (((int )c & 65535) != 32861)) {
#line 742
        break;
      }
#line 743
      if (((int )*pat & 65535) == 32813) {
#line 744
        if ((int )c <= (int )k) {
#line 744
          if ((int )k <= (int )*(pat + 1)) {
#line 745
            ok = 1;
          }
        }
#line 746
        pat += 2;
      } else {
#line 747
        if ((int )c == (int )k) {
#line 748
          ok = 1;
        }
      }
    }
#line 749
    if (ok == negate_range) {
#line 750
      return (0);
    }
#line 751
    break;
    default: 
#line 753
    tmp___5 = name;
#line 753
    name ++;
#line 753
    if ((int )*tmp___5 != (int )c) {
#line 754
      return (0);
    }
#line 755
    break;
    }
  }
#line 758
  return ((int )*name == 0);
}
}
#line 762 "openbsd-compat/glob.c"
void globfree(glob_t *pglob ) 
{ int i ;
  char **pp ;
  int tmp ;

  {
#line 768
  if ((unsigned int )pglob->gl_pathv != (unsigned int )((void *)0)) {
#line 769
    pp = pglob->gl_pathv + pglob->gl_offs;
#line 770
    i = pglob->gl_pathc;
#line 770
    while (1) {
#line 770
      tmp = i;
#line 770
      i --;
#line 770
      if (! tmp) {
#line 770
        break;
      }
#line 771
      if (*pp) {
#line 772
        free((void *)*pp);
      }
#line 770
      pp ++;
    }
#line 773
    free((void *)pglob->gl_pathv);
#line 774
    pglob->gl_pathv = (char **)((void *)0);
  }
#line 776
  return;
}
}
#line 778 "openbsd-compat/glob.c"
static DIR *g_opendir(Char *str , glob_t *pglob ) 
{ char buf___1[4096] ;
  int tmp ;
  void *tmp___0 ;
  DIR *tmp___1 ;

  {
#line 783
  if (! *str) {
#line 784
    strlcpy(buf___1, ".", sizeof(buf___1));
  } else {
#line 786
    tmp = g_Ctoc((Char const   *)str, buf___1, sizeof(buf___1));
#line 786
    if (tmp) {
#line 787
      return ((DIR *)((void *)0));
    }
  }
#line 790
  if (pglob->gl_flags & 64) {
#line 791
    tmp___0 = (*(pglob->gl_opendir))((char const   *)(buf___1));
#line 791
    return ((DIR *)tmp___0);
  }
#line 793
  tmp___1 = opendir((char const   *)(buf___1));
#line 793
  return (tmp___1);
}
}
#line 796 "openbsd-compat/glob.c"
static int g_lstat(Char *fn , struct stat *sb , glob_t *pglob ) 
{ char buf___1[4096] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 801
  tmp = g_Ctoc((Char const   *)fn, buf___1, sizeof(buf___1));
#line 801
  if (tmp) {
#line 802
    return (-1);
  }
#line 803
  if (pglob->gl_flags & 64) {
#line 804
    tmp___0 = (*(pglob->gl_lstat))((char const   *)(buf___1), sb);
#line 804
    return (tmp___0);
  }
#line 805
  tmp___1 = lstat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )sb);
#line 805
  return (tmp___1);
}
}
#line 808 "openbsd-compat/glob.c"
static int g_stat(Char *fn , struct stat *sb , glob_t *pglob ) 
{ char buf___1[4096] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 813
  tmp = g_Ctoc((Char const   *)fn, buf___1, sizeof(buf___1));
#line 813
  if (tmp) {
#line 814
    return (-1);
  }
#line 815
  if (pglob->gl_flags & 64) {
#line 816
    tmp___0 = (*(pglob->gl_stat))((char const   *)(buf___1), sb);
#line 816
    return (tmp___0);
  }
#line 817
  tmp___1 = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )sb);
#line 817
  return (tmp___1);
}
}
#line 820 "openbsd-compat/glob.c"
static Char *g_strchr(Char *str , int ch ) 
{ Char *tmp ;

  {
#line 823
  while (1) {
#line 824
    if ((int )*str == ch) {
#line 825
      return (str);
    }
#line 823
    tmp = str;
#line 823
    str ++;
#line 823
    if (! *tmp) {
#line 823
      break;
    }
  }
#line 827
  return ((Char *)((void *)0));
}
}
#line 830 "openbsd-compat/glob.c"
static int g_Ctoc(Char const   *str , char *buf___1 , u_int len ) 
{ char *tmp ;
  Char const   *tmp___0 ;
  u_int tmp___1 ;

  {
#line 834
  while (1) {
#line 834
    tmp___1 = len;
#line 834
    len --;
#line 834
    if (! tmp___1) {
#line 834
      break;
    }
#line 835
    tmp = buf___1;
#line 835
    buf___1 ++;
#line 835
    tmp___0 = str;
#line 835
    str ++;
#line 835
    *tmp = (char )*tmp___0;
#line 835
    if ((int )*tmp == 0) {
#line 836
      return (0);
    }
  }
#line 838
  return (1);
}
}
#line 1 "inet_aton.o"
#line 1 "inet_ntoa.o"
#line 1 "inet_ntop.o"
#line 1 "mktemp.o"
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 263
__inline static  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path ,
                                                        struct stat * __restrict  __statbuf )  __asm__("lstat64") __attribute__((__nonnull__(1,2))) ;
#line 316
extern  __attribute__((__nothrow__)) int mkdir(char const   *__path , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 729 "/usr/include/stdlib.h"
 __attribute__((__nothrow__)) char *mkdtemp(char *path )  __attribute__((__nonnull__(1))) ;
#line 86 "./openbsd-compat/openbsd-compat.h"
int mkstemps(char *path , int slen ) ;
#line 40 "openbsd-compat/mktemp.c"
static int _gettemp(char *path , int *doopen , int domkdir , int slen ) ;
#line 42 "openbsd-compat/mktemp.c"
int mkstemps(char *path , int slen ) 
{ int fd ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 47
  tmp___1 = _gettemp(path, & fd, 0, slen);
#line 47
  if (tmp___1) {
#line 47
    tmp___0 = fd;
  } else {
#line 47
    tmp___0 = -1;
  }
#line 47
  return (tmp___0);
}
}
#line 50
int mkstemp(char *path )  __asm__("mkstemp64") __attribute__((__nonnull__(1))) ;
#line 50 "openbsd-compat/mktemp.c"
int mkstemp(char *path ) 
{ int fd ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 55
  tmp___1 = _gettemp(path, & fd, 0, 0);
#line 55
  if (tmp___1) {
#line 55
    tmp___0 = fd;
  } else {
#line 55
    tmp___0 = -1;
  }
#line 55
  return (tmp___0);
}
}
#line 58
 __attribute__((__nothrow__)) char *mkdtemp(char *path )  __attribute__((__nonnull__(1))) ;
#line 58 "openbsd-compat/mktemp.c"
char *mkdtemp(char *path ) 
{ char *tmp___0 ;
  int tmp___1 ;

  {
#line 61
  tmp___1 = _gettemp(path, (int *)((void *)0), 1, 0);
#line 61
  if (tmp___1) {
#line 61
    tmp___0 = path;
  } else {
#line 61
    tmp___0 = (char *)((void *)0);
  }
#line 61
  return (tmp___0);
}
}
#line 64 "openbsd-compat/mktemp.c"
static int _gettemp(char *path , int *doopen , int domkdir , int slen ) 
{ register char *start___0 ;
  register char *trv ;
  register char *suffp ;
  struct stat sbuf ;
  int rval ;
  pid_t pid ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char c ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  unsigned short const   **tmp___13 ;

  {
#line 76
  if (doopen) {
#line 76
    if (domkdir) {
#line 77
      tmp = __errno_location();
#line 77
      *tmp = 22;
#line 78
      return (0);
    }
  }
#line 81
  trv = path;
#line 81
  while (*trv) {
#line 81
    trv ++;
  }
#line 83
  trv -= slen;
#line 84
  suffp = trv;
#line 85
  trv --;
#line 86
  if ((unsigned int )trv < (unsigned int )path) {
#line 87
    tmp___0 = __errno_location();
#line 87
    *tmp___0 = 22;
#line 88
    return (0);
  }
#line 90
  pid = getpid();
#line 91
  while (1) {
#line 91
    if ((unsigned int )trv >= (unsigned int )path) {
#line 91
      if ((int )*trv == 88) {
#line 91
        if (! (pid != 0)) {
#line 91
          break;
        }
      } else {
#line 91
        break;
      }
    } else {
#line 91
      break;
    }
#line 92
    tmp___1 = trv;
#line 92
    trv --;
#line 92
    *tmp___1 = (char )(pid % 10 + 48);
#line 93
    pid /= 10;
  }
#line 95
  while (1) {
#line 95
    if ((unsigned int )trv >= (unsigned int )path) {
#line 95
      if (! ((int )*trv == 88)) {
#line 95
        break;
      }
    } else {
#line 95
      break;
    }
#line 98
    tmp___2 = arc4random();
#line 98
    pid = (int )((tmp___2 & 65535U) % 52U);
#line 99
    if (pid < 26) {
#line 100
      c = (char )(pid + 65);
    } else {
#line 102
      c = (char )((pid - 26) + 97);
    }
#line 103
    tmp___3 = trv;
#line 103
    trv --;
#line 103
    *tmp___3 = c;
  }
#line 105
  start___0 = trv + 1;
#line 111
  if (doopen) {
    goto _L;
  } else {
#line 111
    if (domkdir) {
      _L: /* CIL Label */ 
#line 112
      while (! ((unsigned int )trv <= (unsigned int )path)) {
#line 115
        if ((int )*trv == 47) {
#line 116
          *trv = (char )'\000';
#line 117
          rval = stat((char const   * __restrict  )path, (struct stat * __restrict  )(& sbuf));
#line 118
          *trv = (char )'/';
#line 119
          if (rval != 0) {
#line 120
            return (0);
          }
#line 121
          if (! ((sbuf.st_mode & 61440U) == 16384U)) {
#line 122
            tmp___4 = __errno_location();
#line 122
            *tmp___4 = 20;
#line 123
            return (0);
          }
#line 125
          break;
        }
#line 112
        trv --;
      }
    }
  }
#line 130
  while (1) {
#line 131
    if (doopen) {
#line 132
      *doopen = open((char const   *)path, 194, 384);
#line 132
      if (*doopen >= 0) {
#line 134
        return (1);
      }
#line 135
      tmp___5 = __errno_location();
#line 135
      if (*tmp___5 != 17) {
#line 136
        return (0);
      }
    } else {
#line 137
      if (domkdir) {
#line 138
        tmp___6 = mkdir((char const   *)path, 448U);
#line 138
        if (tmp___6 == 0) {
#line 139
          return (1);
        }
#line 140
        tmp___7 = __errno_location();
#line 140
        if (*tmp___7 != 17) {
#line 141
          return (0);
        }
      } else {
#line 142
        tmp___11 = lstat((char const   * __restrict  )path, (struct stat * __restrict  )(& sbuf));
#line 142
        if (tmp___11) {
#line 143
          tmp___10 = __errno_location();
#line 143
          if (*tmp___10 == 2) {
#line 143
            tmp___9 = 1;
          } else {
#line 143
            tmp___9 = 0;
          }
#line 143
          return (tmp___9);
        }
      }
    }
#line 146
    trv = start___0;
#line 146
    while (1) {
#line 147
      if (! *trv) {
#line 148
        return (0);
      }
#line 149
      if ((int )*trv == 90) {
#line 150
        if ((unsigned int )trv == (unsigned int )suffp) {
#line 151
          return (0);
        }
#line 152
        tmp___12 = trv;
#line 152
        trv ++;
#line 152
        *tmp___12 = (char )'a';
      } else {
#line 154
        tmp___13 = __ctype_b_loc();
#line 154
        if ((int const   )*(*tmp___13 + (int )*trv) & 2048) {
#line 155
          *trv = (char )'a';
        } else {
#line 156
          if ((int )*trv == 122) {
#line 157
            *trv = (char )'A';
          } else {
#line 159
            if ((unsigned int )trv == (unsigned int )suffp) {
#line 160
              return (0);
            }
#line 161
            *trv = (char )((int )*trv + 1);
          }
        }
#line 163
        break;
      }
    }
  }
}
}
#line 1 "readpassphrase.o"
#line 83 "/usr/include/ctype.h"
extern __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 85
extern __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
#line 116
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 119
__inline static  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 190
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 190 "/usr/include/ctype.h"
__inline static int tolower(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
#line 193
  if (__c >= -128) {
#line 193
    if (__c < 256) {
#line 193
      tmp___1 = __ctype_tolower_loc();
#line 193
      tmp___0 = *(*tmp___1 + __c);
    } else {
#line 193
      tmp___0 = (int const   )__c;
    }
  } else {
#line 193
    tmp___0 = (int const   )__c;
  }
#line 193
  return ((int )tmp___0);
}
}
#line 196
__inline static  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 196 "/usr/include/ctype.h"
__inline static int toupper(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
#line 199
  if (__c >= -128) {
#line 199
    if (__c < 256) {
#line 199
      tmp___1 = __ctype_toupper_loc();
#line 199
      tmp___0 = *(*tmp___1 + __c);
    } else {
#line 199
      tmp___0 = (int const   )__c;
    }
  } else {
#line 199
    tmp___0 = (int const   )__c;
  }
#line 199
  return ((int )tmp___0);
}
}
#line 117 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 62 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 327 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 333
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 67 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 71
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
#line 40 "./openbsd-compat/readpassphrase.h"
char *readpassphrase(char const   *prompt , char *buf___1 , size_t bufsiz , int flags ) ;
#line 43 "openbsd-compat/readpassphrase.c"
static sig_atomic_t volatile   signo  ;
#line 45
static void handler(int s ) ;
#line 47 "openbsd-compat/readpassphrase.c"
char *readpassphrase(char const   *prompt , char *buf___1 , size_t bufsiz , int flags ) 
{ ssize_t nr ;
  int input___0 ;
  int output___0 ;
  int save_errno ;
  char ch ;
  char *p ;
  char *end ;
  struct termios term ;
  struct termios oterm ;
  struct sigaction sa ;
  struct sigaction savealrm ;
  struct sigaction saveint ;
  struct sigaction savehup ;
  struct sigaction savequit ;
  struct sigaction saveterm ;
  struct sigaction savetstp ;
  struct sigaction savettin ;
  struct sigaction savettou ;
  struct sigaction savepipe ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int __res ;
  __int32_t const   **tmp___5 ;
  int __res___0 ;
  __int32_t const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  __pid_t tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;

  {
#line 58
  if (bufsiz == 0U) {
#line 59
    tmp = __errno_location();
#line 59
    *tmp = 22;
#line 60
    return ((char *)((void *)0));
  }
  restart: 
#line 64
  signo = (int volatile   )0;
#line 69
  if (flags & 32) {
    goto _L;
  } else {
#line 69
    output___0 = open("/dev/tty", 2);
#line 69
    input___0 = output___0;
#line 69
    if (input___0 == -1) {
      _L: /* CIL Label */ 
#line 71
      if (flags & 2) {
#line 72
        tmp___0 = __errno_location();
#line 72
        *tmp___0 = 25;
#line 73
        return ((char *)((void *)0));
      }
#line 75
      input___0 = 0;
#line 76
      output___0 = 2;
    }
  }
#line 84
  sigemptyset(& sa.sa_mask);
#line 85
  sa.sa_flags = 0;
#line 86
  sa.__sigaction_handler.sa_handler = & handler;
#line 87
  sigaction(14, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savealrm));
#line 88
  sigaction(1, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savehup));
#line 89
  sigaction(2, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& saveint));
#line 90
  sigaction(13, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savepipe));
#line 91
  sigaction(3, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savequit));
#line 92
  sigaction(15, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& saveterm));
#line 93
  sigaction(20, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savetstp));
#line 94
  sigaction(21, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savettin));
#line 95
  sigaction(22, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savettou));
#line 98
  if (input___0 != 0) {
#line 98
    tmp___1 = tcgetattr(input___0, & oterm);
#line 98
    if (tmp___1 == 0) {
#line 99
      memcpy((void * __restrict  )(& term), (void const   * __restrict  )(& oterm),
             sizeof(term));
#line 100
      if (! (flags & 1)) {
#line 101
        term.c_lflag &= 4294967223U;
      }
#line 106
      tcsetattr(input___0, 2, (struct termios  const  *)(& term));
    } else {
#line 108
      memset((void *)(& term), 0, sizeof(term));
#line 109
      term.c_lflag |= 8U;
#line 110
      memset((void *)(& oterm), 0, sizeof(oterm));
#line 111
      oterm.c_lflag |= 8U;
    }
  } else {
#line 108
    memset((void *)(& term), 0, sizeof(term));
#line 109
    term.c_lflag |= 8U;
#line 110
    memset((void *)(& oterm), 0, sizeof(oterm));
#line 111
    oterm.c_lflag |= 8U;
  }
#line 114
  if (! (flags & 32)) {
#line 115
    tmp___2 = strlen(prompt);
#line 115
    write(output___0, (void const   *)prompt, tmp___2);
  }
#line 116
  end = (buf___1 + bufsiz) - 1;
#line 117
  p = buf___1;
#line 117
  while (1) {
#line 117
    nr = read(input___0, (void *)(& ch), 1U);
#line 117
    if (nr == 1) {
#line 117
      if ((int )ch != 10) {
#line 117
        if (! ((int )ch != 13)) {
#line 117
          break;
        }
      } else {
#line 117
        break;
      }
    } else {
#line 117
      break;
    }
#line 118
    if ((unsigned int )p < (unsigned int )end) {
#line 119
      if (flags & 16) {
#line 120
        ch = (char )((int )ch & 127);
      }
#line 121
      tmp___9 = __ctype_b_loc();
#line 121
      if ((int const   )*(*tmp___9 + (int )ch) & 1024) {
#line 122
        if (flags & 4) {
#line 123
          if (sizeof(ch) > 1U) {
#line 123
            __res = tolower((int )ch);
          } else {
#line 123
            tmp___5 = __ctype_tolower_loc();
#line 123
            __res = (int )*(*tmp___5 + (int )ch);
          }
#line 123
          ch = (char )__res;
        }
#line 124
        if (flags & 8) {
#line 125
          if (sizeof(ch) > 1U) {
#line 125
            __res___0 = toupper((int )ch);
          } else {
#line 125
            tmp___8 = __ctype_toupper_loc();
#line 125
            __res___0 = (int )*(*tmp___8 + (int )ch);
          }
#line 125
          ch = (char )__res___0;
        }
      }
#line 127
      tmp___10 = p;
#line 127
      p ++;
#line 127
      *tmp___10 = ch;
    }
  }
#line 130
  *p = (char )'\000';
#line 131
  tmp___11 = __errno_location();
#line 131
  save_errno = *tmp___11;
#line 132
  if (! (term.c_lflag & 8U)) {
#line 133
    write(output___0, (void const   *)"\n", 1U);
  }
#line 136
  tmp___14 = memcmp((void const   *)(& term), (void const   *)(& oterm), sizeof(term));
#line 136
  if (tmp___14 != 0) {
#line 137
    while (1) {
#line 137
      tmp___12 = tcsetattr(input___0, 2, (struct termios  const  *)(& oterm));
#line 137
      if (tmp___12 == -1) {
#line 137
        tmp___13 = __errno_location();
#line 137
        if (! (*tmp___13 == 4)) {
#line 137
          break;
        }
      } else {
#line 137
        break;
      }
#line 139
      continue;
    }
  }
#line 141
  sigaction(14, (struct sigaction  const  * __restrict  )(& savealrm), (struct sigaction * __restrict  )((void *)0));
#line 142
  sigaction(1, (struct sigaction  const  * __restrict  )(& savehup), (struct sigaction * __restrict  )((void *)0));
#line 143
  sigaction(2, (struct sigaction  const  * __restrict  )(& saveint), (struct sigaction * __restrict  )((void *)0));
#line 144
  sigaction(3, (struct sigaction  const  * __restrict  )(& savequit), (struct sigaction * __restrict  )((void *)0));
#line 145
  sigaction(13, (struct sigaction  const  * __restrict  )(& savepipe), (struct sigaction * __restrict  )((void *)0));
#line 146
  sigaction(15, (struct sigaction  const  * __restrict  )(& saveterm), (struct sigaction * __restrict  )((void *)0));
#line 147
  sigaction(20, (struct sigaction  const  * __restrict  )(& savetstp), (struct sigaction * __restrict  )((void *)0));
#line 148
  sigaction(21, (struct sigaction  const  * __restrict  )(& savettin), (struct sigaction * __restrict  )((void *)0));
#line 149
  if (input___0 != 0) {
#line 150
    close(input___0);
  }
#line 156
  if (signo) {
#line 157
    tmp___15 = getpid();
#line 157
    kill(tmp___15, (int )signo);
#line 158
    switch ((int )signo) {
    case 20: 
    case 21: 
    case 22: 
    goto restart;
    }
  }
#line 166
  tmp___16 = __errno_location();
#line 166
  *tmp___16 = save_errno;
#line 167
  if (nr == -1) {
#line 167
    tmp___17 = (char *)((void *)0);
  } else {
#line 167
    tmp___17 = buf___1;
  }
#line 167
  return (tmp___17);
}
}
#line 180 "openbsd-compat/readpassphrase.c"
static void handler(int s ) 
{ 

  {
#line 183
  signo = (int volatile   )s;
#line 184
  return;
}
}
#line 1 "realpath.o"
#line 1 "rresvport.o"
#line 1 "setenv.o"
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 1 "setproctitle.o"
#line 361 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 498 "/usr/include/unistd.h"
extern char **environ ;
#line 74 "./openbsd-compat/openbsd-compat.h"
size_t strlcat(char *dst , char const   *src , size_t siz ) ;
#line 116
void setproctitle(char const   *fmt  , ...) ;
#line 117
void compat_init_setproctitle(int argc , char **argv ) ;
#line 56 "openbsd-compat/setproctitle.c"
static char *argv_start  =    (char *)((void *)0);
#line 57 "openbsd-compat/setproctitle.c"
static size_t argv_env_len  =    (size_t )0;
#line 62 "openbsd-compat/setproctitle.c"
void compat_init_setproctitle(int argc , char **argv ) 
{ char *lastargv ;
  char **envp ;
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___11 ;

  {
#line 67
  lastargv = (char *)((void *)0);
#line 68
  envp = environ;
#line 77
  if (argc == 0) {
#line 78
    return;
  } else {
#line 77
    if ((unsigned int )*(argv + 0) == (unsigned int )((void *)0)) {
#line 78
      return;
    }
  }
#line 81
  i = 0;
#line 81
  while ((unsigned int )*(envp + i) != (unsigned int )((void *)0)) {
#line 81
    i ++;
  }
#line 83
  tmp = malloc(sizeof(*environ) * (unsigned int )(i + 1));
#line 83
  environ = (char **)tmp;
#line 83
  if ((unsigned int )environ == (unsigned int )((void *)0)) {
#line 84
    environ = envp;
#line 85
    return;
  }
#line 92
  i = 0;
#line 92
  while (i < argc) {
#line 93
    if ((unsigned int )lastargv == (unsigned int )((void *)0)) {
#line 94
      tmp___0 = strlen((char const   *)*(argv + i));
#line 94
      lastargv = *(argv + i) + tmp___0;
    } else {
#line 93
      if ((unsigned int )(lastargv + 1) == (unsigned int )*(argv + i)) {
#line 94
        tmp___0 = strlen((char const   *)*(argv + i));
#line 94
        lastargv = *(argv + i) + tmp___0;
      }
    }
#line 92
    i ++;
  }
#line 96
  i = 0;
#line 96
  while ((unsigned int )*(envp + i) != (unsigned int )((void *)0)) {
#line 97
    if ((unsigned int )(lastargv + 1) == (unsigned int )*(envp + i)) {
#line 98
      tmp___1 = strlen((char const   *)*(envp + i));
#line 98
      lastargv = *(envp + i) + tmp___1;
    }
#line 96
    i ++;
  }
#line 101
  *(argv + 1) = (char *)((void *)0);
#line 102
  argv_start = *(argv + 0);
#line 103
  argv_env_len = (unsigned int )((lastargv - *(argv + 0)) - 1);
#line 109
  i = 0;
#line 109
  while ((unsigned int )*(envp + i) != (unsigned int )((void *)0)) {
#line 110
    tmp___11 = __strdup((char const   *)*(envp + i));
#line 110
    *(environ + i) = tmp___11;
#line 109
    i ++;
  }
#line 111
  *(environ + i) = (char *)((void *)0);
#line 113
  return;
}
}
#line 116 "openbsd-compat/setproctitle.c"
void setproctitle(char const   *fmt  , ...) 
{ va_list ap ;
  char buf___1[1024] ;
  size_t len ;

  {
#line 129
  if (argv_env_len <= 0U) {
#line 130
    return;
  }
#line 133
  strlcpy(buf___1, (char const   *)__progname, sizeof(buf___1));
#line 135
  __builtin_va_start(ap, fmt);
#line 136
  if ((unsigned int )fmt != (unsigned int )((void *)0)) {
#line 137
    len = strlcat(buf___1, ": ", sizeof(buf___1));
#line 138
    if (len < sizeof(buf___1)) {
#line 139
      vsnprintf((char * __restrict  )(buf___1 + len), sizeof(buf___1) - len, (char const   * __restrict  )fmt,
                ap);
    }
  }
#line 141
  __builtin_va_end(ap);
#line 149
  len = strlcpy(argv_start, (char const   *)(buf___1), argv_env_len);
#line 150
  while (len < argv_env_len) {
#line 151
    *(argv_start + len) = (char )'\000';
#line 150
    len ++;
  }
#line 155
  return;
}
}
#line 1 "sigact.o"
#line 1 "strlcat.o"
#line 34 "openbsd-compat/strlcat.c"
size_t strlcat(char *dst , char const   *src , size_t siz ) 
{ char *d ;
  char const   *s ;
  size_t n___0 ;
  size_t dlen ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 37
  d = dst;
#line 38
  s = src;
#line 39
  n___0 = siz;
#line 43
  while (1) {
#line 43
    tmp = n___0;
#line 43
    n___0 --;
#line 43
    if (tmp != 0U) {
#line 43
      if (! ((int )*d != 0)) {
#line 43
        break;
      }
    } else {
#line 43
      break;
    }
#line 44
    d ++;
  }
#line 45
  dlen = (unsigned int )(d - dst);
#line 46
  n___0 = siz - dlen;
#line 48
  if (n___0 == 0U) {
#line 49
    tmp___0 = strlen(s);
#line 49
    return (dlen + tmp___0);
  }
#line 50
  while ((int const   )*s != 0) {
#line 51
    if (n___0 != 1U) {
#line 52
      tmp___1 = d;
#line 52
      d ++;
#line 52
      *tmp___1 = (char )*s;
#line 53
      n___0 --;
    }
#line 55
    s ++;
  }
#line 57
  *d = (char )'\000';
#line 59
  return (dlen + (size_t )(s - src));
}
}
#line 1 "strlcpy.o"
#line 32 "openbsd-compat/strlcpy.c"
size_t strlcpy(char *dst , char const   *src , size_t siz ) 
{ char *d ;
  char const   *s ;
  size_t n___0 ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 35
  d = dst;
#line 36
  s = src;
#line 37
  n___0 = siz;
#line 40
  if (n___0 != 0U) {
#line 40
    n___0 --;
#line 40
    if (n___0 != 0U) {
#line 41
      while (1) {
#line 42
        tmp = d;
#line 42
        d ++;
#line 42
        tmp___0 = s;
#line 42
        s ++;
#line 42
        *tmp = (char )*tmp___0;
#line 42
        if ((int )*tmp == 0) {
#line 43
          break;
        }
#line 41
        n___0 --;
#line 41
        if (! (n___0 != 0U)) {
#line 41
          break;
        }
      }
    }
  }
#line 48
  if (n___0 == 0U) {
#line 49
    if (siz != 0U) {
#line 50
      *d = (char )'\000';
    }
#line 51
    while (1) {
#line 51
      tmp___1 = s;
#line 51
      s ++;
#line 51
      if (! *tmp___1) {
#line 51
        break;
      }
    }
  }
#line 55
  return ((unsigned int )((s - src) - 1));
}
}
#line 1 "strmode.o"
#line 82 "./openbsd-compat/openbsd-compat.h"
void strmode(int mode , char *p ) ;
#line 42 "openbsd-compat/strmode.c"
void strmode(int mode , char *p ) 
{ char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;

  {
#line 46
  switch (mode & 61440) {
  case 16384: 
#line 48
  tmp = p;
#line 48
  p ++;
#line 48
  *tmp = (char )'d';
#line 49
  break;
  case 8192: 
#line 51
  tmp___0 = p;
#line 51
  p ++;
#line 51
  *tmp___0 = (char )'c';
#line 52
  break;
  case 24576: 
#line 54
  tmp___1 = p;
#line 54
  p ++;
#line 54
  *tmp___1 = (char )'b';
#line 55
  break;
  case 32768: 
#line 57
  tmp___2 = p;
#line 57
  p ++;
#line 57
  *tmp___2 = (char )'-';
#line 58
  break;
  case 40960: 
#line 60
  tmp___3 = p;
#line 60
  p ++;
#line 60
  *tmp___3 = (char )'l';
#line 61
  break;
  case 49152: 
#line 64
  tmp___4 = p;
#line 64
  p ++;
#line 64
  *tmp___4 = (char )'s';
#line 65
  break;
  case 4096: 
#line 69
  tmp___5 = p;
#line 69
  p ++;
#line 69
  *tmp___5 = (char )'p';
#line 70
  break;
  default: 
#line 73
  tmp___6 = p;
#line 73
  p ++;
#line 73
  *tmp___6 = (char )'?';
#line 74
  break;
  }
#line 77
  if (mode & 256) {
#line 78
    tmp___7 = p;
#line 78
    p ++;
#line 78
    *tmp___7 = (char )'r';
  } else {
#line 80
    tmp___8 = p;
#line 80
    p ++;
#line 80
    *tmp___8 = (char )'-';
  }
#line 81
  if (mode & 128) {
#line 82
    tmp___9 = p;
#line 82
    p ++;
#line 82
    *tmp___9 = (char )'w';
  } else {
#line 84
    tmp___10 = p;
#line 84
    p ++;
#line 84
    *tmp___10 = (char )'-';
  }
#line 85
  switch (mode & 2112) {
  case 0: 
#line 87
  tmp___11 = p;
#line 87
  p ++;
#line 87
  *tmp___11 = (char )'-';
#line 88
  break;
  case 64: 
#line 90
  tmp___12 = p;
#line 90
  p ++;
#line 90
  *tmp___12 = (char )'x';
#line 91
  break;
  case 2048: 
#line 93
  tmp___13 = p;
#line 93
  p ++;
#line 93
  *tmp___13 = (char )'S';
#line 94
  break;
  case 2112: 
#line 96
  tmp___14 = p;
#line 96
  p ++;
#line 96
  *tmp___14 = (char )'s';
#line 97
  break;
  }
#line 100
  if (mode & (256 >> 3)) {
#line 101
    tmp___15 = p;
#line 101
    p ++;
#line 101
    *tmp___15 = (char )'r';
  } else {
#line 103
    tmp___16 = p;
#line 103
    p ++;
#line 103
    *tmp___16 = (char )'-';
  }
#line 104
  if (mode & (128 >> 3)) {
#line 105
    tmp___17 = p;
#line 105
    p ++;
#line 105
    *tmp___17 = (char )'w';
  } else {
#line 107
    tmp___18 = p;
#line 107
    p ++;
#line 107
    *tmp___18 = (char )'-';
  }
#line 108
  switch (mode & ((64 >> 3) | 1024)) {
  case 0: 
#line 110
  tmp___19 = p;
#line 110
  p ++;
#line 110
  *tmp___19 = (char )'-';
#line 111
  break;
  case 64 >> 3: 
#line 113
  tmp___20 = p;
#line 113
  p ++;
#line 113
  *tmp___20 = (char )'x';
#line 114
  break;
  case 1024: 
#line 116
  tmp___21 = p;
#line 116
  p ++;
#line 116
  *tmp___21 = (char )'S';
#line 117
  break;
  case (64 >> 3) | 1024: 
#line 119
  tmp___22 = p;
#line 119
  p ++;
#line 119
  *tmp___22 = (char )'s';
#line 120
  break;
  }
#line 123
  if (mode & ((256 >> 3) >> 3)) {
#line 124
    tmp___23 = p;
#line 124
    p ++;
#line 124
    *tmp___23 = (char )'r';
  } else {
#line 126
    tmp___24 = p;
#line 126
    p ++;
#line 126
    *tmp___24 = (char )'-';
  }
#line 127
  if (mode & ((128 >> 3) >> 3)) {
#line 128
    tmp___25 = p;
#line 128
    p ++;
#line 128
    *tmp___25 = (char )'w';
  } else {
#line 130
    tmp___26 = p;
#line 130
    p ++;
#line 130
    *tmp___26 = (char )'-';
  }
#line 131
  switch (mode & (((64 >> 3) >> 3) | 512)) {
  case 0: 
#line 133
  tmp___27 = p;
#line 133
  p ++;
#line 133
  *tmp___27 = (char )'-';
#line 134
  break;
  case (64 >> 3) >> 3: 
#line 136
  tmp___28 = p;
#line 136
  p ++;
#line 136
  *tmp___28 = (char )'x';
#line 137
  break;
  case 512: 
#line 139
  tmp___29 = p;
#line 139
  p ++;
#line 139
  *tmp___29 = (char )'T';
#line 140
  break;
  case ((64 >> 3) >> 3) | 512: 
#line 142
  tmp___30 = p;
#line 142
  p ++;
#line 142
  *tmp___30 = (char )'t';
#line 143
  break;
  }
#line 145
  tmp___31 = p;
#line 145
  p ++;
#line 145
  *tmp___31 = (char )' ';
#line 146
  *p = (char )'\000';
#line 147
  return;
}
}
#line 1 "strsep.o"
#line 1 "strtoul.o"
#line 1 "vis.o"
#line 82 "./openbsd-compat/vis.h"
char *vis(char *dst , int c , int flag , int nextc ) ;
#line 83
int strvis(char *dst , char const   *src , int flag ) ;
#line 84
int strnvis(char *dst , char const   *src , size_t siz , int flag ) ;
#line 86
int strvisx(char *dst , char const   *src , size_t len , int flag ) ;
#line 56 "openbsd-compat/vis.c"
char *vis(char *dst , int c , int flag , int nextc ) 
{ char *tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  unsigned short const   **tmp___34 ;

  {
#line 59
  if ((unsigned int )c <= 255U) {
#line 59
    if (((int )((unsigned char )c) & -128) == 0) {
#line 59
      if (c != 42) {
#line 59
        if (c != 63) {
#line 59
          if (c != 91) {
#line 59
            if (c != 35) {
              goto _L___6;
            } else {
              goto _L___9;
            }
          } else {
            goto _L___9;
          }
        } else {
          goto _L___9;
        }
      } else {
        _L___9: /* CIL Label */ 
#line 59
        if ((flag & 256) == 0) {
          _L___6: /* CIL Label */ 
#line 59
          tmp___1 = __ctype_b_loc();
#line 59
          if ((int const   )*(*tmp___1 + (int )((unsigned char )c)) & 32768) {
            goto _L___0;
          } else {
            goto _L___10;
          }
        } else {
          goto _L___10;
        }
      }
    } else {
      goto _L___10;
    }
  } else {
    _L___10: /* CIL Label */ 
#line 59
    if ((flag & 4) == 0) {
#line 59
      if (c == 32) {
        goto _L___0;
      } else {
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
#line 59
      if ((flag & 8) == 0) {
#line 59
        if (c == 9) {
          goto _L___0;
        } else {
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
#line 59
        if ((flag & 16) == 0) {
#line 59
          if (c == 10) {
            goto _L___0;
          } else {
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
#line 59
          if (flag & 32) {
#line 59
            if (c == 8) {
              goto _L___0;
            } else {
#line 59
              if (c == 7) {
                goto _L___0;
              } else {
#line 59
                if (c == 13) {
                  goto _L___0;
                } else {
#line 59
                  tmp___2 = __ctype_b_loc();
#line 59
                  if ((int const   )*(*tmp___2 + (int )((unsigned char )c)) & 32768) {
                    _L___0: /* CIL Label */ 
#line 60
                    tmp = dst;
#line 60
                    dst ++;
#line 60
                    *tmp = (char )c;
#line 61
                    if (c == 92) {
#line 61
                      if ((flag & 64) == 0) {
#line 62
                        tmp___0 = dst;
#line 62
                        dst ++;
#line 62
                        *tmp___0 = (char )'\\';
                      }
                    }
#line 63
                    *dst = (char )'\000';
#line 64
                    return (dst);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 67
  if (flag & 2) {
#line 68
    switch (c) {
    case 10: 
#line 70
    tmp___3 = dst;
#line 70
    dst ++;
#line 70
    *tmp___3 = (char )'\\';
#line 71
    tmp___4 = dst;
#line 71
    dst ++;
#line 71
    *tmp___4 = (char )'n';
    goto done;
    case 13: 
#line 74
    tmp___5 = dst;
#line 74
    dst ++;
#line 74
    *tmp___5 = (char )'\\';
#line 75
    tmp___6 = dst;
#line 75
    dst ++;
#line 75
    *tmp___6 = (char )'r';
    goto done;
    case 8: 
#line 78
    tmp___7 = dst;
#line 78
    dst ++;
#line 78
    *tmp___7 = (char )'\\';
#line 79
    tmp___8 = dst;
#line 79
    dst ++;
#line 79
    *tmp___8 = (char )'b';
    goto done;
    case 7: 
#line 82
    tmp___9 = dst;
#line 82
    dst ++;
#line 82
    *tmp___9 = (char )'\\';
#line 83
    tmp___10 = dst;
#line 83
    dst ++;
#line 83
    *tmp___10 = (char )'a';
    goto done;
    case 11: 
#line 86
    tmp___11 = dst;
#line 86
    dst ++;
#line 86
    *tmp___11 = (char )'\\';
#line 87
    tmp___12 = dst;
#line 87
    dst ++;
#line 87
    *tmp___12 = (char )'v';
    goto done;
    case 9: 
#line 90
    tmp___13 = dst;
#line 90
    dst ++;
#line 90
    *tmp___13 = (char )'\\';
#line 91
    tmp___14 = dst;
#line 91
    dst ++;
#line 91
    *tmp___14 = (char )'t';
    goto done;
    case 12: 
#line 94
    tmp___15 = dst;
#line 94
    dst ++;
#line 94
    *tmp___15 = (char )'\\';
#line 95
    tmp___16 = dst;
#line 95
    dst ++;
#line 95
    *tmp___16 = (char )'f';
    goto done;
    case 32: 
#line 98
    tmp___17 = dst;
#line 98
    dst ++;
#line 98
    *tmp___17 = (char )'\\';
#line 99
    tmp___18 = dst;
#line 99
    dst ++;
#line 99
    *tmp___18 = (char )'s';
    goto done;
    case 0: 
#line 102
    tmp___19 = dst;
#line 102
    dst ++;
#line 102
    *tmp___19 = (char )'\\';
#line 103
    tmp___20 = dst;
#line 103
    dst ++;
#line 103
    *tmp___20 = (char )'0';
#line 104
    if ((int )((unsigned char )nextc) >= 48) {
#line 104
      if ((int )((unsigned char )nextc) <= 55) {
#line 105
        tmp___21 = dst;
#line 105
        dst ++;
#line 105
        *tmp___21 = (char )'0';
#line 106
        tmp___22 = dst;
#line 106
        dst ++;
#line 106
        *tmp___22 = (char )'0';
      }
    }
    goto done;
    }
  }
#line 111
  if ((c & 127) == 32) {
    goto _L___12;
  } else {
#line 111
    if (flag & 1) {
      goto _L___12;
    } else {
#line 111
      if (flag & 256) {
#line 111
        if (c == 42) {
          goto _L___12;
        } else {
#line 111
          if (c == 63) {
            goto _L___12;
          } else {
#line 111
            if (c == 91) {
              goto _L___12;
            } else {
#line 111
              if (c == 35) {
                _L___12: /* CIL Label */ 
#line 113
                tmp___23 = dst;
#line 113
                dst ++;
#line 113
                *tmp___23 = (char )'\\';
#line 114
                tmp___24 = dst;
#line 114
                dst ++;
#line 114
                *tmp___24 = (char )((((int )((unsigned char )c) >> 6) & 7) + 48);
#line 115
                tmp___25 = dst;
#line 115
                dst ++;
#line 115
                *tmp___25 = (char )((((int )((unsigned char )c) >> 3) & 7) + 48);
#line 116
                tmp___26 = dst;
#line 116
                dst ++;
#line 116
                *tmp___26 = (char )(((int )((unsigned char )c) & 7) + 48);
                goto done;
              }
            }
          }
        }
      }
    }
  }
#line 119
  if ((flag & 64) == 0) {
#line 120
    tmp___27 = dst;
#line 120
    dst ++;
#line 120
    *tmp___27 = (char )'\\';
  }
#line 121
  if (c & 128) {
#line 122
    c &= 127;
#line 123
    tmp___28 = dst;
#line 123
    dst ++;
#line 123
    *tmp___28 = (char )'M';
  }
#line 125
  tmp___34 = __ctype_b_loc();
#line 125
  if ((int const   )*(*tmp___34 + (int )((unsigned char )c)) & 2) {
#line 126
    tmp___29 = dst;
#line 126
    dst ++;
#line 126
    *tmp___29 = (char )'^';
#line 127
    if (c == 127) {
#line 128
      tmp___30 = dst;
#line 128
      dst ++;
#line 128
      *tmp___30 = (char )'?';
    } else {
#line 130
      tmp___31 = dst;
#line 130
      dst ++;
#line 130
      *tmp___31 = (char )(c + 64);
    }
  } else {
#line 132
    tmp___32 = dst;
#line 132
    dst ++;
#line 132
    *tmp___32 = (char )'-';
#line 133
    tmp___33 = dst;
#line 133
    dst ++;
#line 133
    *tmp___33 = (char )c;
  }
  done: 
#line 136
  *dst = (char )'\000';
#line 137
  return (dst);
}
}
#line 153 "openbsd-compat/vis.c"
int strvis(char *dst , char const   *src , int flag ) 
{ char c ;
  char *start___0 ;

  {
#line 159
  start___0 = dst;
#line 159
  while (1) {
#line 159
    c = (char )*src;
#line 159
    if (! c) {
#line 159
      break;
    }
#line 160
    src ++;
#line 160
    dst = vis(dst, (int )c, flag, (int )*src);
  }
#line 161
  *dst = (char )'\000';
#line 162
  return (dst - start___0);
}
}
#line 165 "openbsd-compat/vis.c"
int strnvis(char *dst , char const   *src , size_t siz , int flag ) 
{ char *start___0 ;
  char *end ;
  char tbuf[5] ;
  int c ;
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;

  {
#line 172
  i = 0;
#line 173
  start___0 = dst;
#line 173
  end = (start___0 + siz) - 1;
#line 173
  while (1) {
#line 173
    c = (int )*src;
#line 173
    if (c) {
#line 173
      if (! ((unsigned int )dst < (unsigned int )end)) {
#line 173
        break;
      }
    } else {
#line 173
      break;
    }
#line 174
    if ((unsigned int )c <= 255U) {
#line 174
      if (((int )((unsigned char )c) & -128) == 0) {
#line 174
        if (c != 42) {
#line 174
          if (c != 63) {
#line 174
            if (c != 91) {
#line 174
              if (c != 35) {
                goto _L___7;
              } else {
                goto _L___10;
              }
            } else {
              goto _L___10;
            }
          } else {
            goto _L___10;
          }
        } else {
          _L___10: /* CIL Label */ 
#line 174
          if ((flag & 256) == 0) {
            _L___7: /* CIL Label */ 
#line 174
            tmp___2 = __ctype_b_loc();
#line 174
            if ((int const   )*(*tmp___2 + (int )((unsigned char )c)) & 32768) {
              goto _L___1;
            } else {
              goto _L___11;
            }
          } else {
            goto _L___11;
          }
        }
      } else {
        goto _L___11;
      }
    } else {
      _L___11: /* CIL Label */ 
#line 174
      if ((flag & 4) == 0) {
#line 174
        if (c == 32) {
          goto _L___1;
        } else {
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
#line 174
        if ((flag & 8) == 0) {
#line 174
          if (c == 9) {
            goto _L___1;
          } else {
            goto _L___3;
          }
        } else {
          _L___3: /* CIL Label */ 
#line 174
          if ((flag & 16) == 0) {
#line 174
            if (c == 10) {
              goto _L___1;
            } else {
              goto _L___2;
            }
          } else {
            _L___2: /* CIL Label */ 
#line 174
            if (flag & 32) {
#line 174
              if (c == 8) {
                goto _L___1;
              } else {
#line 174
                if (c == 7) {
                  goto _L___1;
                } else {
#line 174
                  if (c == 13) {
                    goto _L___1;
                  } else {
#line 174
                    tmp___3 = __ctype_b_loc();
#line 174
                    if ((int const   )*(*tmp___3 + (int )((unsigned char )c)) & 32768) {
                      _L___1: /* CIL Label */ 
#line 175
                      i = 1;
#line 176
                      tmp = dst;
#line 176
                      dst ++;
#line 176
                      *tmp = (char )c;
#line 177
                      if (c == 92) {
#line 177
                        if ((flag & 64) == 0) {
#line 179
                          if ((unsigned int )dst < (unsigned int )end) {
#line 180
                            tmp___0 = dst;
#line 180
                            dst ++;
#line 180
                            *tmp___0 = (char )'\\';
                          } else {
#line 182
                            dst --;
#line 183
                            i = 2;
#line 184
                            break;
                          }
                        }
                      }
#line 187
                      src ++;
                    } else {
                      goto _L___0;
                    }
                  }
                }
              }
            } else {
              _L___0: /* CIL Label */ 
#line 189
              src ++;
#line 189
              tmp___1 = vis(tbuf, c, flag, (int )*src);
#line 189
              i = tmp___1 - tbuf;
#line 190
              if ((unsigned int )(dst + i) <= (unsigned int )end) {
#line 191
                memcpy((void * __restrict  )dst, (void const   * __restrict  )(tbuf),
                       (unsigned int )i);
#line 192
                dst += i;
              } else {
#line 194
                src --;
#line 195
                break;
              }
            }
          }
        }
      }
    }
  }
#line 199
  if (siz > 0U) {
#line 200
    *dst = (char )'\000';
  }
#line 201
  if ((unsigned int )(dst + i) > (unsigned int )end) {
#line 203
    while (1) {
#line 203
      c = (int )*src;
#line 203
      if (! c) {
#line 203
        break;
      }
#line 204
      src ++;
#line 204
      tmp___4 = vis(tbuf, c, flag, (int )*src);
#line 204
      dst += tmp___4 - tbuf;
    }
  }
#line 206
  return (dst - start___0);
}
}
#line 209 "openbsd-compat/vis.c"
int strvisx(char *dst , char const   *src , size_t len , int flag ) 
{ char c ;
  char *start___0 ;

  {
#line 215
  start___0 = dst;
#line 215
  while (len > 1U) {
#line 216
    c = (char )*src;
#line 217
    src ++;
#line 217
    dst = vis(dst, (int )c, flag, (int )*src);
#line 215
    len --;
  }
#line 219
  if (len) {
#line 220
    dst = vis(dst, (int )*src, flag, '\000');
  }
#line 221
  *dst = (char )'\000';
#line 222
  return (dst - start___0);
}
}
#line 1 "acss.o"
#line 43 "acss.h"
void acss_setkey(ACSS_KEY *key , unsigned char const   *data , int enc , int mode ) ;
#line 44
void acss_setsubkey(ACSS_KEY *key , unsigned char const   *subkey ) ;
#line 45
int acss(ACSS_KEY *key , unsigned long len , unsigned char const   *in , unsigned char *out ) ;
#line 26 "acss.c"
static unsigned char sboxdec[256]  = 
#line 26 "acss.c"
  {      (unsigned char)51,      (unsigned char)115,      (unsigned char)59,      (unsigned char)38, 
        (unsigned char)99,      (unsigned char)35,      (unsigned char)107,      (unsigned char)118, 
        (unsigned char)62,      (unsigned char)126,      (unsigned char)54,      (unsigned char)43, 
        (unsigned char)110,      (unsigned char)46,      (unsigned char)102,      (unsigned char)123, 
        (unsigned char)211,      (unsigned char)147,      (unsigned char)219,      (unsigned char)6, 
        (unsigned char)67,      (unsigned char)3,      (unsigned char)75,      (unsigned char)150, 
        (unsigned char)222,      (unsigned char)158,      (unsigned char)214,      (unsigned char)11, 
        (unsigned char)78,      (unsigned char)14,      (unsigned char)70,      (unsigned char)155, 
        (unsigned char)87,      (unsigned char)23,      (unsigned char)95,      (unsigned char)130, 
        (unsigned char)199,      (unsigned char)135,      (unsigned char)207,      (unsigned char)18, 
        (unsigned char)90,      (unsigned char)26,      (unsigned char)82,      (unsigned char)143, 
        (unsigned char)202,      (unsigned char)138,      (unsigned char)194,      (unsigned char)31, 
        (unsigned char)217,      (unsigned char)153,      (unsigned char)209,      (unsigned char)0, 
        (unsigned char)73,      (unsigned char)9,      (unsigned char)65,      (unsigned char)144, 
        (unsigned char)216,      (unsigned char)152,      (unsigned char)208,      (unsigned char)1, 
        (unsigned char)72,      (unsigned char)8,      (unsigned char)64,      (unsigned char)145, 
        (unsigned char)61,      (unsigned char)125,      (unsigned char)53,      (unsigned char)36, 
        (unsigned char)109,      (unsigned char)45,      (unsigned char)101,      (unsigned char)116, 
        (unsigned char)60,      (unsigned char)124,      (unsigned char)52,      (unsigned char)37, 
        (unsigned char)108,      (unsigned char)44,      (unsigned char)100,      (unsigned char)117, 
        (unsigned char)221,      (unsigned char)157,      (unsigned char)213,      (unsigned char)4, 
        (unsigned char)77,      (unsigned char)13,      (unsigned char)69,      (unsigned char)148, 
        (unsigned char)220,      (unsigned char)156,      (unsigned char)212,      (unsigned char)5, 
        (unsigned char)76,      (unsigned char)12,      (unsigned char)68,      (unsigned char)149, 
        (unsigned char)89,      (unsigned char)25,      (unsigned char)81,      (unsigned char)128, 
        (unsigned char)201,      (unsigned char)137,      (unsigned char)193,      (unsigned char)16, 
        (unsigned char)88,      (unsigned char)24,      (unsigned char)80,      (unsigned char)129, 
        (unsigned char)200,      (unsigned char)136,      (unsigned char)192,      (unsigned char)17, 
        (unsigned char)215,      (unsigned char)151,      (unsigned char)223,      (unsigned char)2, 
        (unsigned char)71,      (unsigned char)7,      (unsigned char)79,      (unsigned char)146, 
        (unsigned char)218,      (unsigned char)154,      (unsigned char)210,      (unsigned char)15, 
        (unsigned char)74,      (unsigned char)10,      (unsigned char)66,      (unsigned char)159, 
        (unsigned char)83,      (unsigned char)19,      (unsigned char)91,      (unsigned char)134, 
        (unsigned char)195,      (unsigned char)131,      (unsigned char)203,      (unsigned char)22, 
        (unsigned char)94,      (unsigned char)30,      (unsigned char)86,      (unsigned char)139, 
        (unsigned char)206,      (unsigned char)142,      (unsigned char)198,      (unsigned char)27, 
        (unsigned char)179,      (unsigned char)243,      (unsigned char)187,      (unsigned char)166, 
        (unsigned char)227,      (unsigned char)163,      (unsigned char)235,      (unsigned char)246, 
        (unsigned char)190,      (unsigned char)254,      (unsigned char)182,      (unsigned char)171, 
        (unsigned char)238,      (unsigned char)174,      (unsigned char)230,      (unsigned char)251, 
        (unsigned char)55,      (unsigned char)119,      (unsigned char)63,      (unsigned char)34, 
        (unsigned char)103,      (unsigned char)39,      (unsigned char)111,      (unsigned char)114, 
        (unsigned char)58,      (unsigned char)122,      (unsigned char)50,      (unsigned char)47, 
        (unsigned char)106,      (unsigned char)42,      (unsigned char)98,      (unsigned char)127, 
        (unsigned char)185,      (unsigned char)249,      (unsigned char)177,      (unsigned char)160, 
        (unsigned char)233,      (unsigned char)169,      (unsigned char)225,      (unsigned char)240, 
        (unsigned char)184,      (unsigned char)248,      (unsigned char)176,      (unsigned char)161, 
        (unsigned char)232,      (unsigned char)168,      (unsigned char)224,      (unsigned char)241, 
        (unsigned char)93,      (unsigned char)29,      (unsigned char)85,      (unsigned char)132, 
        (unsigned char)205,      (unsigned char)141,      (unsigned char)197,      (unsigned char)20, 
        (unsigned char)92,      (unsigned char)28,      (unsigned char)84,      (unsigned char)133, 
        (unsigned char)204,      (unsigned char)140,      (unsigned char)196,      (unsigned char)21, 
        (unsigned char)189,      (unsigned char)253,      (unsigned char)181,      (unsigned char)164, 
        (unsigned char)237,      (unsigned char)173,      (unsigned char)229,      (unsigned char)244, 
        (unsigned char)188,      (unsigned char)252,      (unsigned char)180,      (unsigned char)165, 
        (unsigned char)236,      (unsigned char)172,      (unsigned char)228,      (unsigned char)245, 
        (unsigned char)57,      (unsigned char)121,      (unsigned char)49,      (unsigned char)32, 
        (unsigned char)105,      (unsigned char)41,      (unsigned char)97,      (unsigned char)112, 
        (unsigned char)56,      (unsigned char)120,      (unsigned char)48,      (unsigned char)33, 
        (unsigned char)104,      (unsigned char)40,      (unsigned char)96,      (unsigned char)113, 
        (unsigned char)183,      (unsigned char)247,      (unsigned char)191,      (unsigned char)162, 
        (unsigned char)231,      (unsigned char)167,      (unsigned char)239,      (unsigned char)242, 
        (unsigned char)186,      (unsigned char)250,      (unsigned char)178,      (unsigned char)175, 
        (unsigned char)234,      (unsigned char)170,      (unsigned char)226,      (unsigned char)255};
#line 62 "acss.c"
static unsigned char sboxenc[256]  = 
#line 62
  {      (unsigned char)51,      (unsigned char)59,      (unsigned char)115,      (unsigned char)21, 
        (unsigned char)83,      (unsigned char)91,      (unsigned char)19,      (unsigned char)117, 
        (unsigned char)61,      (unsigned char)53,      (unsigned char)125,      (unsigned char)27, 
        (unsigned char)93,      (unsigned char)85,      (unsigned char)29,      (unsigned char)123, 
        (unsigned char)103,      (unsigned char)111,      (unsigned char)39,      (unsigned char)129, 
        (unsigned char)199,      (unsigned char)207,      (unsigned char)135,      (unsigned char)33, 
        (unsigned char)105,      (unsigned char)97,      (unsigned char)41,      (unsigned char)143, 
        (unsigned char)201,      (unsigned char)193,      (unsigned char)137,      (unsigned char)47, 
        (unsigned char)227,      (unsigned char)235,      (unsigned char)163,      (unsigned char)5, 
        (unsigned char)67,      (unsigned char)75,      (unsigned char)3,      (unsigned char)165, 
        (unsigned char)237,      (unsigned char)229,      (unsigned char)173,      (unsigned char)11, 
        (unsigned char)77,      (unsigned char)69,      (unsigned char)13,      (unsigned char)171, 
        (unsigned char)234,      (unsigned char)226,      (unsigned char)170,      (unsigned char)0, 
        (unsigned char)74,      (unsigned char)66,      (unsigned char)10,      (unsigned char)160, 
        (unsigned char)232,      (unsigned char)224,      (unsigned char)168,      (unsigned char)2, 
        (unsigned char)72,      (unsigned char)64,      (unsigned char)8,      (unsigned char)162, 
        (unsigned char)62,      (unsigned char)54,      (unsigned char)126,      (unsigned char)20, 
        (unsigned char)94,      (unsigned char)86,      (unsigned char)30,      (unsigned char)116, 
        (unsigned char)60,      (unsigned char)52,      (unsigned char)124,      (unsigned char)22, 
        (unsigned char)92,      (unsigned char)84,      (unsigned char)28,      (unsigned char)118, 
        (unsigned char)106,      (unsigned char)98,      (unsigned char)42,      (unsigned char)128, 
        (unsigned char)202,      (unsigned char)194,      (unsigned char)138,      (unsigned char)32, 
        (unsigned char)104,      (unsigned char)96,      (unsigned char)40,      (unsigned char)130, 
        (unsigned char)200,      (unsigned char)192,      (unsigned char)136,      (unsigned char)34, 
        (unsigned char)238,      (unsigned char)230,      (unsigned char)174,      (unsigned char)4, 
        (unsigned char)78,      (unsigned char)70,      (unsigned char)14,      (unsigned char)164, 
        (unsigned char)236,      (unsigned char)228,      (unsigned char)172,      (unsigned char)6, 
        (unsigned char)76,      (unsigned char)68,      (unsigned char)12,      (unsigned char)166, 
        (unsigned char)231,      (unsigned char)239,      (unsigned char)167,      (unsigned char)1, 
        (unsigned char)71,      (unsigned char)79,      (unsigned char)7,      (unsigned char)161, 
        (unsigned char)233,      (unsigned char)225,      (unsigned char)169,      (unsigned char)15, 
        (unsigned char)73,      (unsigned char)65,      (unsigned char)9,      (unsigned char)175, 
        (unsigned char)99,      (unsigned char)107,      (unsigned char)35,      (unsigned char)133, 
        (unsigned char)195,      (unsigned char)203,      (unsigned char)131,      (unsigned char)37, 
        (unsigned char)109,      (unsigned char)101,      (unsigned char)45,      (unsigned char)139, 
        (unsigned char)205,      (unsigned char)197,      (unsigned char)141,      (unsigned char)43, 
        (unsigned char)55,      (unsigned char)63,      (unsigned char)119,      (unsigned char)17, 
        (unsigned char)87,      (unsigned char)95,      (unsigned char)23,      (unsigned char)113, 
        (unsigned char)57,      (unsigned char)49,      (unsigned char)121,      (unsigned char)31, 
        (unsigned char)89,      (unsigned char)81,      (unsigned char)25,      (unsigned char)127, 
        (unsigned char)179,      (unsigned char)187,      (unsigned char)243,      (unsigned char)149, 
        (unsigned char)211,      (unsigned char)219,      (unsigned char)147,      (unsigned char)245, 
        (unsigned char)189,      (unsigned char)181,      (unsigned char)253,      (unsigned char)155, 
        (unsigned char)221,      (unsigned char)213,      (unsigned char)157,      (unsigned char)251, 
        (unsigned char)186,      (unsigned char)178,      (unsigned char)250,      (unsigned char)144, 
        (unsigned char)218,      (unsigned char)210,      (unsigned char)154,      (unsigned char)240, 
        (unsigned char)184,      (unsigned char)176,      (unsigned char)248,      (unsigned char)146, 
        (unsigned char)216,      (unsigned char)208,      (unsigned char)152,      (unsigned char)242, 
        (unsigned char)110,      (unsigned char)102,      (unsigned char)46,      (unsigned char)132, 
        (unsigned char)206,      (unsigned char)198,      (unsigned char)142,      (unsigned char)36, 
        (unsigned char)108,      (unsigned char)100,      (unsigned char)44,      (unsigned char)134, 
        (unsigned char)204,      (unsigned char)196,      (unsigned char)140,      (unsigned char)38, 
        (unsigned char)58,      (unsigned char)50,      (unsigned char)122,      (unsigned char)16, 
        (unsigned char)90,      (unsigned char)82,      (unsigned char)26,      (unsigned char)112, 
        (unsigned char)56,      (unsigned char)48,      (unsigned char)120,      (unsigned char)18, 
        (unsigned char)88,      (unsigned char)80,      (unsigned char)24,      (unsigned char)114, 
        (unsigned char)190,      (unsigned char)182,      (unsigned char)254,      (unsigned char)148, 
        (unsigned char)222,      (unsigned char)214,      (unsigned char)158,      (unsigned char)244, 
        (unsigned char)188,      (unsigned char)180,      (unsigned char)252,      (unsigned char)150, 
        (unsigned char)220,      (unsigned char)212,      (unsigned char)156,      (unsigned char)246, 
        (unsigned char)183,      (unsigned char)191,      (unsigned char)247,      (unsigned char)145, 
        (unsigned char)215,      (unsigned char)223,      (unsigned char)151,      (unsigned char)241, 
        (unsigned char)185,      (unsigned char)177,      (unsigned char)249,      (unsigned char)159, 
        (unsigned char)217,      (unsigned char)209,      (unsigned char)153,      (unsigned char)255};
#line 97 "acss.c"
static unsigned char reverse[256]  = 
#line 97
  {      (unsigned char)0,      (unsigned char)128,      (unsigned char)64,      (unsigned char)192, 
        (unsigned char)32,      (unsigned char)160,      (unsigned char)96,      (unsigned char)224, 
        (unsigned char)16,      (unsigned char)144,      (unsigned char)80,      (unsigned char)208, 
        (unsigned char)48,      (unsigned char)176,      (unsigned char)112,      (unsigned char)240, 
        (unsigned char)8,      (unsigned char)136,      (unsigned char)72,      (unsigned char)200, 
        (unsigned char)40,      (unsigned char)168,      (unsigned char)104,      (unsigned char)232, 
        (unsigned char)24,      (unsigned char)152,      (unsigned char)88,      (unsigned char)216, 
        (unsigned char)56,      (unsigned char)184,      (unsigned char)120,      (unsigned char)248, 
        (unsigned char)4,      (unsigned char)132,      (unsigned char)68,      (unsigned char)196, 
        (unsigned char)36,      (unsigned char)164,      (unsigned char)100,      (unsigned char)228, 
        (unsigned char)20,      (unsigned char)148,      (unsigned char)84,      (unsigned char)212, 
        (unsigned char)52,      (unsigned char)180,      (unsigned char)116,      (unsigned char)244, 
        (unsigned char)12,      (unsigned char)140,      (unsigned char)76,      (unsigned char)204, 
        (unsigned char)44,      (unsigned char)172,      (unsigned char)108,      (unsigned char)236, 
        (unsigned char)28,      (unsigned char)156,      (unsigned char)92,      (unsigned char)220, 
        (unsigned char)60,      (unsigned char)188,      (unsigned char)124,      (unsigned char)252, 
        (unsigned char)2,      (unsigned char)130,      (unsigned char)66,      (unsigned char)194, 
        (unsigned char)34,      (unsigned char)162,      (unsigned char)98,      (unsigned char)226, 
        (unsigned char)18,      (unsigned char)146,      (unsigned char)82,      (unsigned char)210, 
        (unsigned char)50,      (unsigned char)178,      (unsigned char)114,      (unsigned char)242, 
        (unsigned char)10,      (unsigned char)138,      (unsigned char)74,      (unsigned char)202, 
        (unsigned char)42,      (unsigned char)170,      (unsigned char)106,      (unsigned char)234, 
        (unsigned char)26,      (unsigned char)154,      (unsigned char)90,      (unsigned char)218, 
        (unsigned char)58,      (unsigned char)186,      (unsigned char)122,      (unsigned char)250, 
        (unsigned char)6,      (unsigned char)134,      (unsigned char)70,      (unsigned char)198, 
        (unsigned char)38,      (unsigned char)166,      (unsigned char)102,      (unsigned char)230, 
        (unsigned char)22,      (unsigned char)150,      (unsigned char)86,      (unsigned char)214, 
        (unsigned char)54,      (unsigned char)182,      (unsigned char)118,      (unsigned char)246, 
        (unsigned char)14,      (unsigned char)142,      (unsigned char)78,      (unsigned char)206, 
        (unsigned char)46,      (unsigned char)174,      (unsigned char)110,      (unsigned char)238, 
        (unsigned char)30,      (unsigned char)158,      (unsigned char)94,      (unsigned char)222, 
        (unsigned char)62,      (unsigned char)190,      (unsigned char)126,      (unsigned char)254, 
        (unsigned char)1,      (unsigned char)129,      (unsigned char)65,      (unsigned char)193, 
        (unsigned char)33,      (unsigned char)161,      (unsigned char)97,      (unsigned char)225, 
        (unsigned char)17,      (unsigned char)145,      (unsigned char)81,      (unsigned char)209, 
        (unsigned char)49,      (unsigned char)177,      (unsigned char)113,      (unsigned char)241, 
        (unsigned char)9,      (unsigned char)137,      (unsigned char)73,      (unsigned char)201, 
        (unsigned char)41,      (unsigned char)169,      (unsigned char)105,      (unsigned char)233, 
        (unsigned char)25,      (unsigned char)153,      (unsigned char)89,      (unsigned char)217, 
        (unsigned char)57,      (unsigned char)185,      (unsigned char)121,      (unsigned char)249, 
        (unsigned char)5,      (unsigned char)133,      (unsigned char)69,      (unsigned char)197, 
        (unsigned char)37,      (unsigned char)165,      (unsigned char)101,      (unsigned char)229, 
        (unsigned char)21,      (unsigned char)149,      (unsigned char)85,      (unsigned char)213, 
        (unsigned char)53,      (unsigned char)181,      (unsigned char)117,      (unsigned char)245, 
        (unsigned char)13,      (unsigned char)141,      (unsigned char)77,      (unsigned char)205, 
        (unsigned char)45,      (unsigned char)173,      (unsigned char)109,      (unsigned char)237, 
        (unsigned char)29,      (unsigned char)157,      (unsigned char)93,      (unsigned char)221, 
        (unsigned char)61,      (unsigned char)189,      (unsigned char)125,      (unsigned char)253, 
        (unsigned char)3,      (unsigned char)131,      (unsigned char)67,      (unsigned char)195, 
        (unsigned char)35,      (unsigned char)163,      (unsigned char)99,      (unsigned char)227, 
        (unsigned char)19,      (unsigned char)147,      (unsigned char)83,      (unsigned char)211, 
        (unsigned char)51,      (unsigned char)179,      (unsigned char)115,      (unsigned char)243, 
        (unsigned char)11,      (unsigned char)139,      (unsigned char)75,      (unsigned char)203, 
        (unsigned char)43,      (unsigned char)171,      (unsigned char)107,      (unsigned char)235, 
        (unsigned char)27,      (unsigned char)155,      (unsigned char)91,      (unsigned char)219, 
        (unsigned char)59,      (unsigned char)187,      (unsigned char)123,      (unsigned char)251, 
        (unsigned char)7,      (unsigned char)135,      (unsigned char)71,      (unsigned char)199, 
        (unsigned char)39,      (unsigned char)167,      (unsigned char)103,      (unsigned char)231, 
        (unsigned char)23,      (unsigned char)151,      (unsigned char)87,      (unsigned char)215, 
        (unsigned char)55,      (unsigned char)183,      (unsigned char)119,      (unsigned char)247, 
        (unsigned char)15,      (unsigned char)143,      (unsigned char)79,      (unsigned char)207, 
        (unsigned char)47,      (unsigned char)175,      (unsigned char)111,      (unsigned char)239, 
        (unsigned char)31,      (unsigned char)159,      (unsigned char)95,      (unsigned char)223, 
        (unsigned char)63,      (unsigned char)191,      (unsigned char)127,      (unsigned char)255};
#line 159 "acss.c"
int acss(ACSS_KEY *key , unsigned long len , unsigned char const   *in , unsigned char *out ) 
{ unsigned long i ;
  unsigned long lfsr17tmp ;
  unsigned long lfsr25tmp ;
  unsigned long lfsrsumtmp ;

  {
#line 166
  lfsr25tmp = 0UL;
#line 166
  lfsr17tmp = lfsr25tmp;
#line 166
  lfsrsumtmp = lfsr17tmp;
#line 169
  i = 0UL;
#line 169
  while (i < len) {
#line 170
    lfsr17tmp = (unsigned long )(key->lfsr17 ^ (key->lfsr17 >> 14));
#line 171
    key->lfsr17 = (unsigned int )((((unsigned long )(key->lfsr17 >> 8) ^ (lfsr17tmp << 9)) ^ (lfsr17tmp << 12)) ^ (lfsr17tmp << 15));
#line 175
    key->lfsr17 &= 131071U;
#line 177
    lfsr25tmp = (unsigned long )(((key->lfsr25 ^ (key->lfsr25 >> 3)) ^ (key->lfsr25 >> 4)) ^ (key->lfsr25 >> 12));
#line 181
    key->lfsr25 = (unsigned int )((unsigned long )(key->lfsr25 >> 8) ^ (lfsr25tmp << 17));
#line 182
    key->lfsr25 &= 33554431U;
#line 184
    lfsrsumtmp = (unsigned long )key->lfsrsum;
#line 187
    switch (key->mode) {
    case 0: 
    case 3: 
#line 190
    key->lfsrsum = 255U & ~ (key->lfsr17 >> 9);
#line 191
    key->lfsrsum += key->lfsr25 >> 17;
#line 192
    break;
    case 1: 
#line 194
    key->lfsrsum = key->lfsr17 >> 9;
#line 195
    key->lfsrsum += key->lfsr25 >> 17;
#line 196
    break;
    case 2: 
#line 198
    key->lfsrsum = key->lfsr17 >> 9;
#line 199
    key->lfsrsum += 255U & ~ (key->lfsr25 >> 17);
#line 200
    break;
    default: ;
#line 202
    return (1);
    }
#line 204
    key->lfsrsum = (unsigned int )((unsigned long )key->lfsrsum + (lfsrsumtmp >> 8));
#line 206
    if (key->encrypt) {
#line 207
      *(out + i) = sboxenc[((unsigned int )*(in + i) ^ key->lfsrsum) & 255U];
    } else {
#line 209
      *(out + i) = (unsigned char )(((unsigned int )sboxdec[*(in + i)] ^ key->lfsrsum) & 255U);
    }
#line 169
    i ++;
  }
#line 213
  return (0);
}
}
#line 216 "acss.c"
static void acss_seed(ACSS_KEY *key ) 
{ int i ;

  {
#line 222
  if (key->subkey_avilable) {
#line 223
    i = 0;
#line 223
    while (i < 5) {
#line 224
      key->seed[i] = reverse[(int )key->data[i] ^ (int )key->subkey[i]];
#line 223
      i ++;
    }
  } else {
#line 226
    i = 0;
#line 226
    while (i < 5) {
#line 227
      key->seed[i] = reverse[key->data[i]];
#line 226
      i ++;
    }
  }
#line 231
  key->lfsr17 = (unsigned int )(((int )key->seed[1] | ((int )key->seed[0] << 9)) | (1 << 8));
#line 234
  key->lfsr25 = (unsigned int )(((((int )key->seed[4] | ((int )key->seed[3] << 8)) | (((int )key->seed[2] & 31) << 16)) | (((int )key->seed[2] & 224) << 17)) | (1 << 21));
#line 240
  key->lfsrsum = 0U;
#line 241
  return;
}
}
#line 243 "acss.c"
void acss_setkey(ACSS_KEY *key , unsigned char const   *data , int enc , int mode ) 
{ 

  {
#line 246
  memcpy((void * __restrict  )(key->data), (void const   * __restrict  )data, sizeof(key->data));
#line 247
  memset((void *)(key->subkey), 0, sizeof(key->subkey));
#line 249
  if (enc != -1) {
#line 250
    key->encrypt = enc;
  }
#line 251
  key->mode = mode;
#line 252
  key->subkey_avilable = 0;
#line 254
  acss_seed(key);
#line 255
  return;
}
}
#line 257 "acss.c"
void acss_setsubkey(ACSS_KEY *key , unsigned char const   *subkey ) 
{ 

  {
#line 260
  memcpy((void * __restrict  )(key->subkey), (void const   * __restrict  )subkey,
         sizeof(key->subkey));
#line 261
  key->subkey_avilable = 1;
#line 262
  acss_seed(key);
#line 263
  return;
}
}
#line 1 "authfd.o"
#line 76 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 100 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 124
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 29 "./buffer.h"
void buffer_init(Buffer *buffer ) ;
#line 30
void buffer_clear(Buffer *buffer ) ;
#line 31
void buffer_free(Buffer *buffer ) ;
#line 33
u_int buffer_len(Buffer *buffer ) ;
#line 34
void *buffer_ptr(Buffer *buffer ) ;
#line 36
void buffer_append(Buffer *buffer , void const   *data , u_int len ) ;
#line 405 "/usr/include/openssl/bn.h"
extern int BN_num_bits(BIGNUM const   *a ) ;
#line 21 "bufaux.h"
void buffer_put_bignum(Buffer *buffer , BIGNUM const   *value ) ;
#line 22
void buffer_put_bignum2(Buffer *buffer , BIGNUM const   *value ) ;
#line 23
void buffer_get_bignum(Buffer *buffer , BIGNUM *value ) ;
#line 29
u_int buffer_get_int(Buffer *buffer ) ;
#line 30
void buffer_put_int(Buffer *buffer , u_int value ) ;
#line 35
int buffer_get_char(Buffer *buffer ) ;
#line 36
void buffer_put_char(Buffer *buffer , int value ) ;
#line 40
void buffer_put_cstring(Buffer *buffer , char const   *s ) ;
#line 22 "xmalloc.h"
void *xmalloc(size_t size ) ;
#line 24
void xfree(void *ptr ) ;
#line 58 "key.h"
Key *key_new(int type ) ;
#line 74
Key *key_from_blob(u_char const   *blob , u_int blen ) ;
#line 75
int key_to_blob(Key const   *key , u_char **blobp , u_int *lenp ) ;
#line 76
char const   *key_ssh_name(Key const   *k ) ;
#line 71 "authfd.h"
int ssh_agent_present(void) ;
#line 72
int ssh_get_authentication_socket(void) ;
#line 73
void ssh_close_authentication_socket(int sock ) ;
#line 75
AuthenticationConnection *ssh_get_authentication_connection(void) ;
#line 76
void ssh_close_authentication_connection(AuthenticationConnection *auth ) ;
#line 77
int ssh_get_num_identities(AuthenticationConnection *auth , int version ) ;
#line 78
Key *ssh_get_first_identity(AuthenticationConnection *auth , char **comment , int version ) ;
#line 79
Key *ssh_get_next_identity(AuthenticationConnection *auth , char **comment , int version ) ;
#line 80
int ssh_add_identity(AuthenticationConnection *auth , Key *key , char const   *comment ) ;
#line 81
int ssh_add_identity_constrained(AuthenticationConnection *auth , Key *key , char const   *comment ,
                                 u_int life , u_int confirm ) ;
#line 83
int ssh_remove_identity(AuthenticationConnection *auth , Key *key ) ;
#line 84
int ssh_remove_all_identities(AuthenticationConnection *auth , int version ) ;
#line 85
int ssh_lock_agent(AuthenticationConnection *auth , int lock , char const   *password ) ;
#line 86
int ssh_update_card(AuthenticationConnection *auth , int add , char const   *reader_id ,
                    char const   *pin , u_int life , u_int confirm ) ;
#line 89
int ssh_decrypt_challenge(AuthenticationConnection *auth , Key *key , BIGNUM *challenge ,
                          u_char *session_id___0 , u_int response_type , u_char *response ) ;
#line 93
int ssh_agent_sign(AuthenticationConnection *auth , Key *key , u_char **sigp , u_int *lenp ,
                   u_char *data , u_int datalen ) ;
#line 68 "compat.h"
int datafellows ;
#line 57 "log.h"
void ( /* format attribute */  error)(char const   *fmt  , ...) ;
#line 58
void ( /* format attribute */  logit)(char const   *fmt  , ...) ;
#line 31 "atomicio.h"
size_t atomicio(ssize_t (*f)(int  , void * , size_t  ) , int fd , void *_s , size_t n___0 ) ;
#line 56 "authfd.c"
static int agent_present  =    0;
#line 59
int decode_reply(int type ) ;
#line 66 "authfd.c"
int ssh_agent_present(void) 
{ int authfd ;

  {
#line 71
  if (agent_present) {
#line 72
    return (1);
  }
#line 73
  authfd = ssh_get_authentication_socket();
#line 73
  if (authfd == -1) {
#line 74
    return (0);
  } else {
#line 76
    ssh_close_authentication_socket(authfd);
#line 77
    return (1);
  }
}
}
#line 83 "authfd.c"
int ssh_get_authentication_socket(void) 
{ char const   *authsocket ;
  int sock ;
  struct sockaddr_un sunaddr ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 90
  tmp = getenv("SSH_AUTH_SOCK");
#line 90
  authsocket = (char const   *)tmp;
#line 91
  if (! authsocket) {
#line 92
    return (-1);
  }
#line 94
  sunaddr.sun_family = (unsigned short)1;
#line 95
  strlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));
#line 97
  sock = socket(1, 1, 0);
#line 98
  if (sock < 0) {
#line 99
    return (-1);
  }
#line 102
  tmp___0 = fcntl(sock, 2, 1);
#line 102
  if (tmp___0 == -1) {
#line 103
    close(sock);
#line 104
    return (-1);
  }
#line 106
  tmp___1 = connect(sock, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& sunaddr)),
                    sizeof(sunaddr));
#line 106
  if (tmp___1 < 0) {
#line 107
    close(sock);
#line 108
    return (-1);
  }
#line 110
  agent_present = 1;
#line 111
  return (sock);
}
}
#line 114 "authfd.c"
static int ssh_request_reply(AuthenticationConnection *auth , Buffer *request , Buffer *reply ) 
{ u_int l ;
  u_int len ;
  char buf___1[1024] ;
  size_t tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  u_int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
#line 121
  len = buffer_len(request);
#line 122
  while (1) {
#line 122
    buf___1[0] = (char )(len >> 24);
#line 122
    buf___1[1] = (char )(len >> 16);
#line 122
    buf___1[2] = (char )(len >> 8);
#line 122
    buf___1[3] = (char )len;
#line 122
    break;
  }
#line 125
  tmp = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), auth->fd, (void *)(buf___1),
                 4U);
#line 125
  if (tmp != 4U) {
#line 128
    error("Error writing to authentication socket.");
#line 129
    return (0);
  } else {
#line 125
    tmp___0 = buffer_len(request);
#line 125
    tmp___1 = buffer_ptr(request);
#line 125
    tmp___2 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), auth->fd,
                       tmp___1, tmp___0);
#line 125
    tmp___3 = buffer_len(request);
#line 125
    if (tmp___2 != tmp___3) {
#line 128
      error("Error writing to authentication socket.");
#line 129
      return (0);
    }
  }
#line 135
  tmp___4 = atomicio(& read, auth->fd, (void *)(buf___1), 4U);
#line 135
  if (tmp___4 != 4U) {
#line 136
    error("Error reading response length from authentication socket.");
#line 137
    return (0);
  }
#line 141
  len = (unsigned int )(((((unsigned long )((unsigned char )buf___1[0]) << 24) | ((unsigned long )((unsigned char )buf___1[1]) << 16)) | ((unsigned long )((unsigned char )buf___1[2]) << 8)) | (unsigned long )((unsigned char )buf___1[3]));
#line 142
  if (len > 262144U) {
#line 143
    fatal("Authentication response too long: %u", len);
  }
#line 146
  buffer_clear(reply);
#line 147
  while (len > 0U) {
#line 148
    l = len;
#line 149
    if (l > sizeof(buf___1)) {
#line 150
      l = sizeof(buf___1);
    }
#line 151
    tmp___5 = atomicio(& read, auth->fd, (void *)(buf___1), l);
#line 151
    if (tmp___5 != l) {
#line 152
      error("Error reading response from authentication socket.");
#line 153
      return (0);
    }
#line 155
    buffer_append(reply, (void const   *)(buf___1), l);
#line 156
    len -= l;
  }
#line 158
  return (1);
}
}
#line 167 "authfd.c"
void ssh_close_authentication_socket(int sock ) 
{ char *tmp ;

  {
#line 170
  tmp = getenv("SSH_AUTH_SOCK");
#line 170
  if (tmp) {
#line 171
    close(sock);
  }
#line 172
  return;
}
}
#line 182 "authfd.c"
AuthenticationConnection *ssh_get_authentication_connection(void) 
{ AuthenticationConnection *auth ;
  int sock ;
  void *tmp ;

  {
#line 188
  sock = ssh_get_authentication_socket();
#line 194
  if (sock < 0) {
#line 195
    return ((AuthenticationConnection *)((void *)0));
  }
#line 197
  tmp = xmalloc(sizeof(*auth));
#line 197
  auth = (AuthenticationConnection *)tmp;
#line 198
  auth->fd = sock;
#line 199
  buffer_init(& auth->identities);
#line 200
  auth->howmany = 0;
#line 202
  return (auth);
}
}
#line 210 "authfd.c"
void ssh_close_authentication_connection(AuthenticationConnection *auth ) 
{ 

  {
#line 213
  buffer_free(& auth->identities);
#line 214
  close(auth->fd);
#line 215
  xfree((void *)auth);
#line 216
  return;
}
}
#line 219 "authfd.c"
int ssh_lock_agent(AuthenticationConnection *auth , int lock , char const   *password ) 
{ int type ;
  Buffer msg ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 225
  buffer_init(& msg);
#line 226
  if (lock) {
#line 226
    tmp = 22;
  } else {
#line 226
    tmp = 23;
  }
#line 226
  buffer_put_char(& msg, tmp);
#line 227
  buffer_put_cstring(& msg, password);
#line 229
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 229
  if (tmp___0 == 0) {
#line 230
    buffer_free(& msg);
#line 231
    return (0);
  }
#line 233
  type = buffer_get_char(& msg);
#line 234
  buffer_free(& msg);
#line 235
  tmp___1 = decode_reply(type);
#line 235
  return (tmp___1);
}
}
#line 242 "authfd.c"
int ssh_get_num_identities(AuthenticationConnection *auth , int version ) 
{ int type ;
  int code1 ;
  int code2 ;
  Buffer request ;
  int tmp ;
  u_int tmp___0 ;

  {
#line 245
  code1 = 0;
#line 245
  code2 = 0;
#line 248
  switch (version) {
  case 1: 
#line 250
  code1 = 1;
#line 251
  code2 = 2;
#line 252
  break;
  case 2: 
#line 254
  code1 = 11;
#line 255
  code2 = 12;
#line 256
  break;
  default: ;
#line 258
  return (0);
  }
#line 265
  buffer_init(& request);
#line 266
  buffer_put_char(& request, code1);
#line 268
  buffer_clear(& auth->identities);
#line 269
  tmp = ssh_request_reply(auth, & request, & auth->identities);
#line 269
  if (tmp == 0) {
#line 270
    buffer_free(& request);
#line 271
    return (0);
  }
#line 273
  buffer_free(& request);
#line 276
  type = buffer_get_char(& auth->identities);
#line 277
  if (type == 5) {
#line 278
    return (0);
  } else {
#line 277
    if (type == 102) {
#line 278
      return (0);
    } else {
#line 277
      if (type == 30) {
#line 278
        return (0);
      } else {
#line 279
        if (type != code2) {
#line 280
          fatal("Bad authentication reply message type: %d", type);
        }
      }
    }
  }
#line 284
  tmp___0 = buffer_get_int(& auth->identities);
#line 284
  auth->howmany = (int )tmp___0;
#line 285
  if ((unsigned int )auth->howmany > 1024U) {
#line 286
    fatal("Too many identities in authentication reply: %d", auth->howmany);
  }
#line 289
  return (auth->howmany);
}
}
#line 292 "authfd.c"
Key *ssh_get_first_identity(AuthenticationConnection *auth , char **comment , int version ) 
{ Key *tmp ;
  int tmp___0 ;

  {
#line 296
  tmp___0 = ssh_get_num_identities(auth, version);
#line 296
  if (tmp___0 > 0) {
#line 297
    tmp = ssh_get_next_identity(auth, comment, version);
#line 297
    return (tmp);
  }
#line 298
  return ((Key *)((void *)0));
}
}
#line 301 "authfd.c"
Key *ssh_get_next_identity(AuthenticationConnection *auth , char **comment , int version ) 
{ int keybits ;
  u_int bits ;
  u_char *blob ;
  u_int blen ;
  Key *key ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 308
  key = (Key *)((void *)0);
#line 311
  if (auth->howmany <= 0) {
#line 312
    return ((Key *)((void *)0));
  }
#line 318
  switch (version) {
  case 1: 
#line 320
  key = key_new(0);
#line 321
  bits = buffer_get_int(& auth->identities);
#line 322
  buffer_get_bignum(& auth->identities, (key->rsa)->e);
#line 323
  buffer_get_bignum(& auth->identities, (key->rsa)->n);
#line 324
  tmp = buffer_get_string(& auth->identities, (u_int *)((void *)0));
#line 324
  *comment = (char *)tmp;
#line 325
  keybits = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 326
  if (keybits < 0) {
#line 327
    tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 327
    logit("Warning: identity keysize mismatch: actual %d, announced %u", tmp___0,
          bits);
  } else {
#line 326
    if (bits != (unsigned int )keybits) {
#line 327
      tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 327
      logit("Warning: identity keysize mismatch: actual %d, announced %u", tmp___0,
            bits);
    }
  }
#line 329
  break;
  case 2: 
#line 331
  tmp___1 = buffer_get_string(& auth->identities, & blen);
#line 331
  blob = (u_char *)tmp___1;
#line 332
  tmp___2 = buffer_get_string(& auth->identities, (u_int *)((void *)0));
#line 332
  *comment = (char *)tmp___2;
#line 333
  key = key_from_blob((u_char const   *)blob, blen);
#line 334
  xfree((void *)blob);
#line 335
  break;
  default: ;
#line 337
  return ((Key *)((void *)0));
#line 338
  break;
  }
#line 341
  (auth->howmany) --;
#line 342
  return (key);
}
}
#line 353 "authfd.c"
int ssh_decrypt_challenge(AuthenticationConnection *auth , Key *key , BIGNUM *challenge ,
                          u_char *session_id___0 , u_int response_type , u_char *response ) 
{ Buffer buffer ;
  int success ;
  int i ;
  int type ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 361
  success = 0;
#line 365
  if (key->type != 0) {
#line 366
    return (0);
  }
#line 367
  if (response_type == 0U) {
#line 368
    logit("Compatibility with ssh protocol version 1.0 no longer supported.");
#line 369
    return (0);
  }
#line 371
  buffer_init(& buffer);
#line 372
  buffer_put_char(& buffer, 3);
#line 373
  tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 373
  buffer_put_int(& buffer, (unsigned int )tmp);
#line 374
  buffer_put_bignum(& buffer, (BIGNUM const   *)(key->rsa)->e);
#line 375
  buffer_put_bignum(& buffer, (BIGNUM const   *)(key->rsa)->n);
#line 376
  buffer_put_bignum(& buffer, (BIGNUM const   *)challenge);
#line 377
  buffer_append(& buffer, (void const   *)session_id___0, 16U);
#line 378
  buffer_put_int(& buffer, response_type);
#line 380
  tmp___0 = ssh_request_reply(auth, & buffer, & buffer);
#line 380
  if (tmp___0 == 0) {
#line 381
    buffer_free(& buffer);
#line 382
    return (0);
  }
#line 384
  type = buffer_get_char(& buffer);
#line 386
  if (type == 5) {
#line 387
    logit("Agent admitted failure to authenticate using the key.");
  } else {
#line 386
    if (type == 102) {
#line 387
      logit("Agent admitted failure to authenticate using the key.");
    } else {
#line 386
      if (type == 30) {
#line 387
        logit("Agent admitted failure to authenticate using the key.");
      } else {
#line 388
        if (type != 4) {
#line 389
          fatal("Bad authentication response: %d", type);
        } else {
#line 391
          success = 1;
#line 396
          i = 0;
#line 396
          while (i < 16) {
#line 397
            tmp___1 = buffer_get_char(& buffer);
#line 397
            *(response + i) = (unsigned char )tmp___1;
#line 396
            i ++;
          }
        }
      }
    }
  }
#line 399
  buffer_free(& buffer);
#line 400
  return (success);
}
}
#line 404 "authfd.c"
int ssh_agent_sign(AuthenticationConnection *auth , Key *key , u_char **sigp , u_int *lenp ,
                   u_char *data , u_int datalen ) 
{ Buffer msg ;
  u_char *blob ;
  u_int blen ;
  int type ;
  int flags ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 414
  flags = 0;
#line 415
  ret = -1;
#line 417
  tmp = key_to_blob((Key const   *)key, & blob, & blen);
#line 417
  if (tmp == 0) {
#line 418
    return (-1);
  }
#line 420
  if (datafellows & 1) {
#line 421
    flags = 1;
  }
#line 423
  buffer_init(& msg);
#line 424
  buffer_put_char(& msg, 13);
#line 425
  buffer_put_string(& msg, (void const   *)blob, blen);
#line 426
  buffer_put_string(& msg, (void const   *)data, datalen);
#line 427
  buffer_put_int(& msg, (unsigned int )flags);
#line 428
  xfree((void *)blob);
#line 430
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 430
  if (tmp___0 == 0) {
#line 431
    buffer_free(& msg);
#line 432
    return (-1);
  }
#line 434
  type = buffer_get_char(& msg);
#line 435
  if (type == 5) {
#line 436
    logit("Agent admitted failure to sign using the key.");
  } else {
#line 435
    if (type == 102) {
#line 436
      logit("Agent admitted failure to sign using the key.");
    } else {
#line 435
      if (type == 30) {
#line 436
        logit("Agent admitted failure to sign using the key.");
      } else {
#line 437
        if (type != 14) {
#line 438
          fatal("Bad authentication response: %d", type);
        } else {
#line 440
          ret = 0;
#line 441
          tmp___1 = buffer_get_string(& msg, lenp);
#line 441
          *sigp = (u_char *)tmp___1;
        }
      }
    }
  }
#line 443
  buffer_free(& msg);
#line 444
  return (ret);
}
}
#line 449 "authfd.c"
static void ssh_encode_identity_rsa1(Buffer *b , RSA *key , char const   *comment ) 
{ int tmp ;

  {
#line 452
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 452
  buffer_put_int(b, (unsigned int )tmp);
#line 453
  buffer_put_bignum(b, (BIGNUM const   *)key->n);
#line 454
  buffer_put_bignum(b, (BIGNUM const   *)key->e);
#line 455
  buffer_put_bignum(b, (BIGNUM const   *)key->d);
#line 457
  buffer_put_bignum(b, (BIGNUM const   *)key->iqmp);
#line 458
  buffer_put_bignum(b, (BIGNUM const   *)key->q);
#line 459
  buffer_put_bignum(b, (BIGNUM const   *)key->p);
#line 460
  buffer_put_cstring(b, comment);
#line 461
  return;
}
}
#line 463 "authfd.c"
static void ssh_encode_identity_ssh2(Buffer *b , Key *key , char const   *comment ) 
{ char const   *tmp ;

  {
#line 466
  tmp = key_ssh_name((Key const   *)key);
#line 466
  buffer_put_cstring(b, tmp);
#line 467
  switch (key->type) {
  case 1: 
#line 469
  buffer_put_bignum2(b, (BIGNUM const   *)(key->rsa)->n);
#line 470
  buffer_put_bignum2(b, (BIGNUM const   *)(key->rsa)->e);
#line 471
  buffer_put_bignum2(b, (BIGNUM const   *)(key->rsa)->d);
#line 472
  buffer_put_bignum2(b, (BIGNUM const   *)(key->rsa)->iqmp);
#line 473
  buffer_put_bignum2(b, (BIGNUM const   *)(key->rsa)->p);
#line 474
  buffer_put_bignum2(b, (BIGNUM const   *)(key->rsa)->q);
#line 475
  break;
  case 2: 
#line 477
  buffer_put_bignum2(b, (BIGNUM const   *)(key->dsa)->p);
#line 478
  buffer_put_bignum2(b, (BIGNUM const   *)(key->dsa)->q);
#line 479
  buffer_put_bignum2(b, (BIGNUM const   *)(key->dsa)->g);
#line 480
  buffer_put_bignum2(b, (BIGNUM const   *)(key->dsa)->pub_key);
#line 481
  buffer_put_bignum2(b, (BIGNUM const   *)(key->dsa)->priv_key);
#line 482
  break;
  }
#line 484
  buffer_put_cstring(b, comment);
#line 485
  return;
}
}
#line 492 "authfd.c"
int ssh_add_identity_constrained(AuthenticationConnection *auth , Key *key , char const   *comment ,
                                 u_int life , u_int confirm ) 
{ Buffer msg ;
  int type ;
  int constrained ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 497
  if (life) {
#line 497
    tmp = 1;
  } else {
#line 497
    if (confirm) {
#line 497
      tmp = 1;
    } else {
#line 497
      tmp = 0;
    }
  }
#line 497
  constrained = tmp;
#line 499
  buffer_init(& msg);
#line 501
  switch (key->type) {
  case 0: 
#line 503
  if (constrained) {
#line 503
    type = 24;
  } else {
#line 503
    type = 7;
  }
#line 506
  buffer_put_char(& msg, type);
#line 507
  ssh_encode_identity_rsa1(& msg, key->rsa, comment);
#line 508
  break;
  case 1: 
  case 2: 
#line 511
  if (constrained) {
#line 511
    type = 25;
  } else {
#line 511
    type = 17;
  }
#line 514
  buffer_put_char(& msg, type);
#line 515
  ssh_encode_identity_ssh2(& msg, key, comment);
#line 516
  break;
  default: 
#line 518
  buffer_free(& msg);
#line 519
  return (0);
#line 520
  break;
  }
#line 522
  if (constrained) {
#line 523
    if (life != 0U) {
#line 524
      buffer_put_char(& msg, 1);
#line 525
      buffer_put_int(& msg, life);
    }
#line 527
    if (confirm != 0U) {
#line 528
      buffer_put_char(& msg, 2);
    }
  }
#line 530
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 530
  if (tmp___0 == 0) {
#line 531
    buffer_free(& msg);
#line 532
    return (0);
  }
#line 534
  type = buffer_get_char(& msg);
#line 535
  buffer_free(& msg);
#line 536
  tmp___1 = decode_reply(type);
#line 536
  return (tmp___1);
}
}
#line 539 "authfd.c"
int ssh_add_identity(AuthenticationConnection *auth , Key *key , char const   *comment ) 
{ int tmp ;

  {
#line 542
  tmp = ssh_add_identity_constrained(auth, key, comment, 0U, 0U);
#line 542
  return (tmp);
}
}
#line 550 "authfd.c"
int ssh_remove_identity(AuthenticationConnection *auth , Key *key ) 
{ Buffer msg ;
  int type ;
  u_char *blob ;
  u_int blen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 558
  buffer_init(& msg);
#line 560
  if (key->type == 0) {
#line 561
    buffer_put_char(& msg, 8);
#line 562
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 562
    buffer_put_int(& msg, (unsigned int )tmp);
#line 563
    buffer_put_bignum(& msg, (BIGNUM const   *)(key->rsa)->e);
#line 564
    buffer_put_bignum(& msg, (BIGNUM const   *)(key->rsa)->n);
  } else {
#line 565
    if (key->type == 2) {
#line 566
      key_to_blob((Key const   *)key, & blob, & blen);
#line 567
      buffer_put_char(& msg, 18);
#line 568
      buffer_put_string(& msg, (void const   *)blob, blen);
#line 569
      xfree((void *)blob);
    } else {
#line 565
      if (key->type == 1) {
#line 566
        key_to_blob((Key const   *)key, & blob, & blen);
#line 567
        buffer_put_char(& msg, 18);
#line 568
        buffer_put_string(& msg, (void const   *)blob, blen);
#line 569
        xfree((void *)blob);
      } else {
#line 571
        buffer_free(& msg);
#line 572
        return (0);
      }
    }
  }
#line 574
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 574
  if (tmp___0 == 0) {
#line 575
    buffer_free(& msg);
#line 576
    return (0);
  }
#line 578
  type = buffer_get_char(& msg);
#line 579
  buffer_free(& msg);
#line 580
  tmp___1 = decode_reply(type);
#line 580
  return (tmp___1);
}
}
#line 583 "authfd.c"
int ssh_update_card(AuthenticationConnection *auth , int add , char const   *reader_id ,
                    char const   *pin , u_int life , u_int confirm ) 
{ Buffer msg ;
  int type ;
  int constrained ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 588
  if (life) {
#line 588
    tmp = 1;
  } else {
#line 588
    if (confirm) {
#line 588
      tmp = 1;
    } else {
#line 588
      tmp = 0;
    }
  }
#line 588
  constrained = tmp;
#line 590
  if (add) {
#line 591
    if (constrained) {
#line 591
      type = 26;
    } else {
#line 591
      type = 20;
    }
  } else {
#line 595
    type = 21;
  }
#line 597
  buffer_init(& msg);
#line 598
  buffer_put_char(& msg, type);
#line 599
  buffer_put_cstring(& msg, reader_id);
#line 600
  buffer_put_cstring(& msg, pin);
#line 602
  if (constrained) {
#line 603
    if (life != 0U) {
#line 604
      buffer_put_char(& msg, 1);
#line 605
      buffer_put_int(& msg, life);
    }
#line 607
    if (confirm != 0U) {
#line 608
      buffer_put_char(& msg, 2);
    }
  }
#line 611
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 611
  if (tmp___0 == 0) {
#line 612
    buffer_free(& msg);
#line 613
    return (0);
  }
#line 615
  type = buffer_get_char(& msg);
#line 616
  buffer_free(& msg);
#line 617
  tmp___1 = decode_reply(type);
#line 617
  return (tmp___1);
}
}
#line 625 "authfd.c"
int ssh_remove_all_identities(AuthenticationConnection *auth , int version ) 
{ Buffer msg ;
  int type ;
  int code ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 630
  if (version == 1) {
#line 630
    tmp = 9;
  } else {
#line 630
    tmp = 19;
  }
#line 630
  code = tmp;
#line 634
  buffer_init(& msg);
#line 635
  buffer_put_char(& msg, code);
#line 637
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 637
  if (tmp___0 == 0) {
#line 638
    buffer_free(& msg);
#line 639
    return (0);
  }
#line 641
  type = buffer_get_char(& msg);
#line 642
  buffer_free(& msg);
#line 643
  tmp___1 = decode_reply(type);
#line 643
  return (tmp___1);
}
}
#line 646 "authfd.c"
int decode_reply(int type ) 
{ 

  {
#line 649
  switch (type) {
  case 5: 
  case 102: 
  case 30: 
#line 653
  logit("SSH_AGENT_FAILURE");
#line 654
  return (0);
  case 6: 
#line 656
  return (1);
  default: 
#line 658
  fatal("Bad response from authentication agent: %d", type);
  }
#line 661
  return (0);
}
}
#line 1 "authfile.o"
#line 213 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 259
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 280
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 218 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64") __attribute__((__nonnull__(2))) ;
#line 391
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __asm__("__fxstat64") __attribute__((__nonnull__(3))) ;
#line 447
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64") __attribute__((__nonnull__(2))) ;
#line 447 "/usr/include/sys/stat.h"
__inline static int fstat(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
#line 450
  tmp = __fxstat(3, __fd, __statbuf);
#line 450
  return (tmp);
}
}
#line 304 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off64_t lseek(int __fd , __off64_t __offset ,
                                                     int __whence )  __asm__("lseek64")  ;
#line 37 "./buffer.h"
void *buffer_append_space(Buffer *buffer , u_int len ) ;
#line 639 "/usr/include/openssl/evp.h"
extern EVP_CIPHER const   *EVP_des_ede3_cbc(void) ;
#line 749
extern struct rsa_st *EVP_PKEY_get1_RSA(EVP_PKEY *pkey ) ;
#line 754
extern struct dsa_st *EVP_PKEY_get1_DSA(EVP_PKEY *pkey ) ;
#line 763
extern void EVP_PKEY_free(EVP_PKEY *pkey ) ;
#line 298 "/usr/include/openssl/rsa.h"
extern int RSA_blinding_on(RSA *rsa , BN_CTX *ctx ) ;
#line 616 "/usr/include/openssl/pem.h"
extern int PEM_write_RSAPrivateKey(FILE *fp , RSA *x , EVP_CIPHER const   *enc , unsigned char *kstr ,
                                   int klen , pem_password_cb *cb , void *u ) ;
#line 625
extern int PEM_write_DSAPrivateKey(FILE *fp , DSA *x , EVP_CIPHER const   *enc , unsigned char *kstr ,
                                   int klen , pem_password_cb *cb , void *u ) ;
#line 640
extern EVP_PKEY *PEM_read_PrivateKey(FILE *fp , EVP_PKEY **x , pem_password_cb *cb ,
                                     void *u ) ;
#line 73 "cipher.h"
Cipher *cipher_by_number(int id ) ;
#line 79
void cipher_crypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) ;
#line 80
void cipher_cleanup(CipherContext *cc ) ;
#line 81
void cipher_set_key_string(CipherContext *cc , Cipher *cipher , char const   *passphrase ,
                           int do_encrypt ) ;
#line 59 "key.h"
Key *key_new_private(int type ) ;
#line 60
void key_free(Key *k ) ;
#line 65
char const   *key_type(Key const   *k ) ;
#line 67
int key_read(Key *ret , char **cpp ) ;
#line 62 "log.h"
void ( /* format attribute */  debug3)(char const   *fmt  , ...) ;
#line 18 "authfile.h"
int key_save_private(Key *key , char const   *filename , char const   *passphrase ,
                     char const   *comment ) ;
#line 19
Key *key_load_public(char const   *filename , char **commentp ) ;
#line 20
Key *key_load_public_type(int type , char const   *filename , char **commentp ) ;
#line 21
Key *key_load_private(char const   *filename , char const   *passphrase , char **commentp ) ;
#line 22
Key *key_load_private_type(int type , char const   *filename , char const   *passphrase ,
                           char **commentp ) ;
#line 23
Key *key_load_private_pem(int fd , int type , char const   *passphrase , char **commentp ) ;
#line 24 "rsa.h"
void rsa_generate_additional_parameters(RSA *rsa ) ;
#line 56 "misc.h"
int read_keyfile_line(FILE *f , char const   *filename , char *buf___1 , size_t bufsz ,
                      u_long *lineno ) ;
#line 58 "authfile.c"
static char const   authfile_id_string[33]  = 
#line 58 "authfile.c"
  {      (char const   )'S',      (char const   )'S',      (char const   )'H',      (char const   )' ', 
        (char const   )'P',      (char const   )'R',      (char const   )'I',      (char const   )'V', 
        (char const   )'A',      (char const   )'T',      (char const   )'E',      (char const   )' ', 
        (char const   )'K',      (char const   )'E',      (char const   )'Y',      (char const   )' ', 
        (char const   )'F',      (char const   )'I',      (char const   )'L',      (char const   )'E', 
        (char const   )' ',      (char const   )'F',      (char const   )'O',      (char const   )'R', 
        (char const   )'M',      (char const   )'A',      (char const   )'T',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )'\n', 
        (char const   )'\000'};
#line 68 "authfile.c"
static int key_save_private_rsa1(Key *key , char const   *filename , char const   *passphrase ,
                                 char const   *comment ) 
{ Buffer buffer ;
  Buffer encrypted ;
  u_char buf___1[100] ;
  u_char *cp ;
  int fd ;
  int i ;
  int cipher_num ;
  CipherContext ciphercontext ;
  Cipher *cipher ;
  u_int32_t rnd ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  u_int tmp___19 ;
  int tmp___20 ;
  u_int tmp___21 ;
  void *tmp___22 ;
  u_int tmp___23 ;
  void *tmp___24 ;
  int *tmp___25 ;
  char *tmp___26 ;
  int *tmp___27 ;
  char *tmp___28 ;
  u_int tmp___29 ;
  void *tmp___30 ;
  size_t tmp___31 ;
  u_int tmp___32 ;

  {
#line 83
  if (0) {
#line 83
    __s1_len___0 = strlen(passphrase);
#line 83
    __s2_len___0 = strlen("");
#line 83
    if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
      goto _L___2;
    } else {
#line 83
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 83
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 83
          tmp___18 = 1;
        } else {
#line 83
          if (__s2_len___0 >= 4U) {
#line 83
            tmp___18 = 1;
          } else {
#line 83
            tmp___18 = 0;
          }
        }
      } else {
#line 83
        tmp___18 = 0;
      }
    }
#line 83
    if (tmp___18) {
#line 83
      tmp___14 = __builtin_strcmp(passphrase, "");
    } else {
#line 83
      tmp___17 = __builtin_strcmp(passphrase, "");
#line 83
      tmp___14 = tmp___17;
    }
  } else {
#line 83
    tmp___17 = __builtin_strcmp(passphrase, "");
#line 83
    tmp___14 = tmp___17;
  }
#line 83
  if (tmp___14 == 0) {
#line 83
    cipher_num = 0;
  } else {
#line 83
    cipher_num = 3;
  }
#line 85
  cipher = cipher_by_number(cipher_num);
#line 85
  if ((unsigned int )cipher == (unsigned int )((void *)0)) {
#line 86
    fatal("save_private_key_rsa: bad cipher");
  }
#line 89
  buffer_init(& buffer);
#line 92
  rnd = arc4random();
#line 93
  buf___1[0] = (unsigned char )(rnd & 255U);
#line 94
  buf___1[1] = (unsigned char )((rnd >> 8) & 255U);
#line 95
  buf___1[2] = buf___1[0];
#line 96
  buf___1[3] = buf___1[1];
#line 97
  buffer_append(& buffer, (void const   *)(buf___1), 4U);
#line 104
  buffer_put_bignum(& buffer, (BIGNUM const   *)(key->rsa)->d);
#line 105
  buffer_put_bignum(& buffer, (BIGNUM const   *)(key->rsa)->iqmp);
#line 106
  buffer_put_bignum(& buffer, (BIGNUM const   *)(key->rsa)->q);
#line 107
  buffer_put_bignum(& buffer, (BIGNUM const   *)(key->rsa)->p);
#line 110
  while (1) {
#line 110
    tmp___19 = buffer_len(& buffer);
#line 110
    if (! (tmp___19 % 8U != 0U)) {
#line 110
      break;
    }
#line 111
    buffer_put_char(& buffer, 0);
  }
#line 114
  buffer_init(& encrypted);
#line 117
  i = 0;
#line 117
  while (authfile_id_string[i]) {
#line 118
    buffer_put_char(& encrypted, (int )authfile_id_string[i]);
#line 117
    i ++;
  }
#line 119
  buffer_put_char(& encrypted, 0);
#line 122
  buffer_put_char(& encrypted, cipher_num);
#line 123
  buffer_put_int(& encrypted, 0U);
#line 126
  tmp___20 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 126
  buffer_put_int(& encrypted, (unsigned int )tmp___20);
#line 127
  buffer_put_bignum(& encrypted, (BIGNUM const   *)(key->rsa)->n);
#line 128
  buffer_put_bignum(& encrypted, (BIGNUM const   *)(key->rsa)->e);
#line 129
  buffer_put_cstring(& encrypted, comment);
#line 132
  tmp___21 = buffer_len(& buffer);
#line 132
  tmp___22 = buffer_append_space(& encrypted, tmp___21);
#line 132
  cp = (u_char *)tmp___22;
#line 134
  cipher_set_key_string(& ciphercontext, cipher, passphrase, 1);
#line 136
  tmp___23 = buffer_len(& buffer);
#line 136
  tmp___24 = buffer_ptr(& buffer);
#line 136
  cipher_crypt(& ciphercontext, cp, (u_char const   *)tmp___24, tmp___23);
#line 138
  cipher_cleanup(& ciphercontext);
#line 139
  memset((void *)(& ciphercontext), 0, sizeof(ciphercontext));
#line 142
  memset((void *)(buf___1), 0, sizeof(buf___1));
#line 143
  buffer_free(& buffer);
#line 145
  fd = open(filename, 577, 384);
#line 146
  if (fd < 0) {
#line 147
    tmp___25 = __errno_location();
#line 147
    tmp___26 = strerror(*tmp___25);
#line 147
    error("open %s failed: %s.", filename, tmp___26);
#line 148
    buffer_free(& encrypted);
#line 149
    return (0);
  }
#line 151
  tmp___29 = buffer_len(& encrypted);
#line 151
  tmp___30 = buffer_ptr(& encrypted);
#line 151
  tmp___31 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), fd, tmp___30,
                      tmp___29);
#line 151
  tmp___32 = buffer_len(& encrypted);
#line 151
  if (tmp___31 != tmp___32) {
#line 153
    tmp___27 = __errno_location();
#line 153
    tmp___28 = strerror(*tmp___27);
#line 153
    error("write to key file %s failed: %s", filename, tmp___28);
#line 155
    buffer_free(& encrypted);
#line 156
    close(fd);
#line 157
    unlink(filename);
#line 158
    return (0);
  }
#line 160
  close(fd);
#line 161
  buffer_free(& encrypted);
#line 162
  return (1);
}
}
#line 166 "authfile.c"
static int key_save_private_pem(Key *key , char const   *filename , char const   *_passphrase ,
                                char const   *comment ) 
{ FILE *fp ;
  int fd ;
  int success ;
  int len ;
  size_t tmp ;
  u_char *passphrase ;
  u_char *tmp___0 ;
  EVP_CIPHER const   *cipher ;
  EVP_CIPHER const   *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
#line 172
  success = 0;
#line 173
  tmp = strlen(_passphrase);
#line 173
  len = (int )tmp;
#line 174
  if (len > 0) {
#line 174
    tmp___0 = (u_char *)_passphrase;
  } else {
#line 174
    tmp___0 = (u_char *)((void *)0);
  }
#line 174
  passphrase = tmp___0;
#line 175
  if (len > 0) {
#line 175
    tmp___2 = EVP_des_ede3_cbc();
  } else {
#line 175
    tmp___2 = (EVP_CIPHER const   *)((void *)0);
  }
#line 175
  cipher = tmp___2;
#line 177
  if (len > 0) {
#line 177
    if (len <= 4) {
#line 178
      error("passphrase too short: have %d bytes, need > 4", len);
#line 179
      return (0);
    }
  }
#line 181
  fd = open(filename, 577, 384);
#line 182
  if (fd < 0) {
#line 183
    tmp___3 = __errno_location();
#line 183
    tmp___4 = strerror(*tmp___3);
#line 183
    error("open %s failed: %s.", filename, tmp___4);
#line 184
    return (0);
  }
#line 186
  fp = fdopen(fd, "w");
#line 187
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 188
    tmp___5 = __errno_location();
#line 188
    tmp___6 = strerror(*tmp___5);
#line 188
    error("fdopen %s failed: %s.", filename, tmp___6);
#line 189
    close(fd);
#line 190
    return (0);
  }
#line 192
  switch (key->type) {
  case 2: 
#line 194
  success = PEM_write_DSAPrivateKey(fp, key->dsa, cipher, passphrase, len, (pem_password_cb *)((void *)0),
                                    (void *)0);
#line 196
  break;
  case 1: 
#line 198
  success = PEM_write_RSAPrivateKey(fp, key->rsa, cipher, passphrase, len, (pem_password_cb *)((void *)0),
                                    (void *)0);
#line 200
  break;
  }
#line 202
  fclose(fp);
#line 203
  return (success);
}
}
#line 206 "authfile.c"
int key_save_private(Key *key , char const   *filename , char const   *passphrase ,
                     char const   *comment ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 210
  switch (key->type) {
  case 0: 
#line 212
  tmp = key_save_private_rsa1(key, filename, passphrase, comment);
#line 212
  return (tmp);
#line 214
  break;
  case 2: 
  case 1: 
#line 217
  tmp___0 = key_save_private_pem(key, filename, passphrase, comment);
#line 217
  return (tmp___0);
#line 219
  break;
  default: ;
#line 221
  break;
  }
#line 223
  error("key_save_private: cannot save key type %d", key->type);
#line 224
  return (0);
}
}
#line 233 "authfile.c"
static Key *key_load_public_rsa1(int fd , char const   *filename , char **commentp ) 
{ Buffer buffer ;
  Key *pub ;
  struct stat st ;
  char *cp ;
  u_int i ;
  size_t len ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;

  {
#line 243
  tmp___1 = fstat(fd, & st);
#line 243
  if (tmp___1 < 0) {
#line 244
    tmp = __errno_location();
#line 244
    tmp___0 = strerror(*tmp);
#line 244
    error("fstat for key file %.200s failed: %.100s", filename, tmp___0);
#line 246
    return ((Key *)((void *)0));
  }
#line 248
  if (st.st_size > 1048576LL) {
#line 249
    error("key file %.200s too large", filename);
#line 250
    return ((Key *)((void *)0));
  }
#line 252
  len = (unsigned int )st.st_size;
#line 254
  buffer_init(& buffer);
#line 255
  tmp___2 = buffer_append_space(& buffer, len);
#line 255
  cp = (char *)tmp___2;
#line 257
  tmp___5 = atomicio(& read, fd, (void *)cp, len);
#line 257
  if (tmp___5 != len) {
#line 258
    tmp___3 = __errno_location();
#line 258
    tmp___4 = strerror(*tmp___3);
#line 258
    debug("Read from key file %.200s failed: %.100s", filename, tmp___4);
#line 260
    buffer_free(& buffer);
#line 261
    return ((Key *)((void *)0));
  }
#line 265
  if (len < sizeof(authfile_id_string)) {
#line 266
    debug3("Not a RSA1 key file %.200s.", filename);
#line 267
    buffer_free(& buffer);
#line 268
    return ((Key *)((void *)0));
  }
#line 274
  i = 0U;
#line 274
  while (i < sizeof(authfile_id_string)) {
#line 275
    tmp___6 = buffer_get_char(& buffer);
#line 275
    if (tmp___6 != (int )authfile_id_string[i]) {
#line 276
      debug3("Not a RSA1 key file %.200s.", filename);
#line 277
      buffer_free(& buffer);
#line 278
      return ((Key *)((void *)0));
    }
#line 274
    i ++;
  }
#line 281
  buffer_get_char(& buffer);
#line 282
  buffer_get_int(& buffer);
#line 285
  buffer_get_int(& buffer);
#line 286
  pub = key_new(0);
#line 287
  buffer_get_bignum(& buffer, (pub->rsa)->n);
#line 288
  buffer_get_bignum(& buffer, (pub->rsa)->e);
#line 289
  if (commentp) {
#line 290
    tmp___7 = buffer_get_string(& buffer, (u_int *)((void *)0));
#line 290
    *commentp = (char *)tmp___7;
  }
#line 293
  buffer_free(& buffer);
#line 294
  return (pub);
}
}
#line 298 "authfile.c"
Key *key_load_public_type(int type , char const   *filename , char **commentp ) 
{ Key *pub ;
  int fd ;

  {
#line 304
  if (type == 0) {
#line 305
    fd = open(filename, 0);
#line 306
    if (fd < 0) {
#line 307
      return ((Key *)((void *)0));
    }
#line 308
    pub = key_load_public_rsa1(fd, filename, commentp);
#line 309
    close(fd);
#line 310
    return (pub);
  }
#line 312
  return ((Key *)((void *)0));
}
}
#line 322 "authfile.c"
static Key *key_load_private_rsa1(int fd , char const   *filename , char const   *passphrase ,
                                  char **commentp ) 
{ u_int i ;
  int check1 ;
  int check2 ;
  int cipher_type ;
  size_t len ;
  Buffer buffer ;
  Buffer decrypted ;
  u_char *cp ;
  CipherContext ciphercontext ;
  Cipher *cipher ;
  Key *prv ;
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  u_int tmp___9 ;
  void *tmp___10 ;
  u_int tmp___11 ;
  void *tmp___12 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;

  {
#line 333
  prv = (Key *)((void *)0);
#line 336
  tmp___1 = fstat(fd, & st);
#line 336
  if (tmp___1 < 0) {
#line 337
    tmp = __errno_location();
#line 337
    tmp___0 = strerror(*tmp);
#line 337
    error("fstat for key file %.200s failed: %.100s", filename, tmp___0);
#line 339
    close(fd);
#line 340
    return ((Key *)((void *)0));
  }
#line 342
  if (st.st_size > 1048576LL) {
#line 343
    error("key file %.200s too large", filename);
#line 344
    close(fd);
#line 345
    return ((Key *)((void *)0));
  }
#line 347
  len = (unsigned int )st.st_size;
#line 349
  buffer_init(& buffer);
#line 350
  tmp___2 = buffer_append_space(& buffer, len);
#line 350
  cp = (u_char *)tmp___2;
#line 352
  tmp___5 = atomicio(& read, fd, (void *)cp, len);
#line 352
  if (tmp___5 != len) {
#line 353
    tmp___3 = __errno_location();
#line 353
    tmp___4 = strerror(*tmp___3);
#line 353
    debug("Read from key file %.200s failed: %.100s", filename, tmp___4);
#line 355
    buffer_free(& buffer);
#line 356
    close(fd);
#line 357
    return ((Key *)((void *)0));
  }
#line 361
  if (len < sizeof(authfile_id_string)) {
#line 362
    debug3("Not a RSA1 key file %.200s.", filename);
#line 363
    buffer_free(& buffer);
#line 364
    close(fd);
#line 365
    return ((Key *)((void *)0));
  }
#line 371
  i = 0U;
#line 371
  while (i < sizeof(authfile_id_string)) {
#line 372
    tmp___6 = buffer_get_char(& buffer);
#line 372
    if (tmp___6 != (int )authfile_id_string[i]) {
#line 373
      debug3("Not a RSA1 key file %.200s.", filename);
#line 374
      buffer_free(& buffer);
#line 375
      close(fd);
#line 376
      return ((Key *)((void *)0));
    }
#line 371
    i ++;
  }
#line 380
  cipher_type = buffer_get_char(& buffer);
#line 381
  buffer_get_int(& buffer);
#line 384
  buffer_get_int(& buffer);
#line 385
  prv = key_new_private(0);
#line 387
  buffer_get_bignum(& buffer, (prv->rsa)->n);
#line 388
  buffer_get_bignum(& buffer, (prv->rsa)->e);
#line 389
  if (commentp) {
#line 390
    tmp___7 = buffer_get_string(& buffer, (u_int *)((void *)0));
#line 390
    *commentp = (char *)tmp___7;
  } else {
#line 392
    tmp___8 = buffer_get_string(& buffer, (u_int *)((void *)0));
#line 392
    xfree(tmp___8);
  }
#line 395
  cipher = cipher_by_number(cipher_type);
#line 396
  if ((unsigned int )cipher == (unsigned int )((void *)0)) {
#line 397
    debug("Unsupported cipher %d used in key file %.200s.", cipher_type, filename);
#line 399
    buffer_free(& buffer);
    goto fail;
  }
#line 403
  buffer_init(& decrypted);
#line 404
  tmp___9 = buffer_len(& buffer);
#line 404
  tmp___10 = buffer_append_space(& decrypted, tmp___9);
#line 404
  cp = (u_char *)tmp___10;
#line 407
  cipher_set_key_string(& ciphercontext, cipher, passphrase, 0);
#line 409
  tmp___11 = buffer_len(& buffer);
#line 409
  tmp___12 = buffer_ptr(& buffer);
#line 409
  cipher_crypt(& ciphercontext, cp, (u_char const   *)tmp___12, tmp___11);
#line 411
  cipher_cleanup(& ciphercontext);
#line 412
  memset((void *)(& ciphercontext), 0, sizeof(ciphercontext));
#line 413
  buffer_free(& buffer);
#line 415
  check1 = buffer_get_char(& decrypted);
#line 416
  check2 = buffer_get_char(& decrypted);
#line 417
  tmp___23 = buffer_get_char(& decrypted);
#line 417
  if (check1 != tmp___23) {
    goto _L___1;
  } else {
#line 417
    tmp___24 = buffer_get_char(& decrypted);
#line 417
    if (check2 != tmp___24) {
      _L___1: /* CIL Label */ 
#line 419
      if (0) {
#line 419
        __s1_len = strlen(passphrase);
#line 419
        __s2_len = strlen("");
#line 419
        if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
          goto _L___0;
        } else {
#line 419
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 419
            if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 419
              tmp___22 = 1;
            } else {
#line 419
              if (__s2_len >= 4U) {
#line 419
                tmp___22 = 1;
              } else {
#line 419
                tmp___22 = 0;
              }
            }
          } else {
#line 419
            tmp___22 = 0;
          }
        }
#line 419
        if (tmp___22) {
#line 419
          tmp___18 = __builtin_strcmp(passphrase, "");
        } else {
#line 419
          tmp___21 = __builtin_strcmp(passphrase, "");
#line 419
          tmp___18 = tmp___21;
        }
      } else {
#line 419
        tmp___21 = __builtin_strcmp(passphrase, "");
#line 419
        tmp___18 = tmp___21;
      }
#line 419
      if (tmp___18 != 0) {
#line 420
        debug("Bad passphrase supplied for key file %.200s.", filename);
      }
#line 423
      buffer_free(& decrypted);
      goto fail;
    }
  }
#line 427
  buffer_get_bignum(& decrypted, (prv->rsa)->d);
#line 428
  buffer_get_bignum(& decrypted, (prv->rsa)->iqmp);
#line 430
  buffer_get_bignum(& decrypted, (prv->rsa)->q);
#line 431
  buffer_get_bignum(& decrypted, (prv->rsa)->p);
#line 434
  rsa_generate_additional_parameters(prv->rsa);
#line 436
  buffer_free(& decrypted);
#line 439
  tmp___25 = RSA_blinding_on(prv->rsa, (BN_CTX *)((void *)0));
#line 439
  if (tmp___25 != 1) {
#line 440
    error("key_load_private_rsa1: RSA_blinding_on failed");
    goto fail;
  }
#line 443
  close(fd);
#line 444
  return (prv);
  fail: 
#line 447
  if (commentp) {
#line 448
    xfree((void *)*commentp);
  }
#line 449
  close(fd);
#line 450
  key_free(prv);
#line 451
  return ((Key *)((void *)0));
}
}
#line 454 "authfile.c"
Key *key_load_private_pem(int fd , int type , char const   *passphrase , char **commentp ) 
{ FILE *fp ;
  EVP_PKEY *pk ;
  Key *prv ;
  char *name ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___3 ;

  {
#line 459
  pk = (EVP_PKEY *)((void *)0);
#line 460
  prv = (Key *)((void *)0);
#line 461
  name = (char *)"<no key>";
#line 463
  fp = fdopen(fd, "r");
#line 464
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 465
    tmp = __errno_location();
#line 465
    tmp___0 = strerror(*tmp);
#line 465
    error("fdopen failed: %s", tmp___0);
#line 466
    close(fd);
#line 467
    return ((Key *)((void *)0));
  }
#line 469
  pk = PEM_read_PrivateKey(fp, (EVP_PKEY **)((void *)0), (pem_password_cb *)((void *)0),
                           (void *)((char *)passphrase));
#line 470
  if ((unsigned int )pk == (unsigned int )((void *)0)) {
#line 471
    debug("PEM_read_PrivateKey failed");
#line 472
    ERR_get_error();
  } else {
#line 473
    if (pk->type == 6) {
#line 473
      if (type == 3) {
        goto _L___0;
      } else {
#line 473
        if (type == 1) {
          _L___0: /* CIL Label */ 
#line 475
          prv = key_new(3);
#line 476
          prv->rsa = EVP_PKEY_get1_RSA(pk);
#line 477
          prv->type = 1;
#line 478
          name = (char *)"rsa w/o comment";
#line 482
          tmp___1 = RSA_blinding_on(prv->rsa, (BN_CTX *)((void *)0));
#line 482
          if (tmp___1 != 1) {
#line 483
            error("key_load_private_pem: RSA_blinding_on failed");
#line 484
            key_free(prv);
#line 485
            prv = (Key *)((void *)0);
          }
        } else {
          goto _L;
        }
      }
    } else {
      _L: /* CIL Label */ 
#line 487
      if (pk->type == 116) {
#line 487
        if (type == 3) {
#line 489
          prv = key_new(3);
#line 490
          prv->dsa = EVP_PKEY_get1_DSA(pk);
#line 491
          prv->type = 2;
#line 492
          name = (char *)"dsa w/o comment";
        } else {
#line 487
          if (type == 2) {
#line 489
            prv = key_new(3);
#line 490
            prv->dsa = EVP_PKEY_get1_DSA(pk);
#line 491
            prv->type = 2;
#line 492
            name = (char *)"dsa w/o comment";
          } else {
#line 497
            error("PEM_read_PrivateKey: mismatch or unknown EVP_PKEY save_type %d",
                  pk->save_type);
          }
        }
      } else {
#line 497
        error("PEM_read_PrivateKey: mismatch or unknown EVP_PKEY save_type %d", pk->save_type);
      }
    }
  }
#line 500
  fclose(fp);
#line 501
  if ((unsigned int )pk != (unsigned int )((void *)0)) {
#line 502
    EVP_PKEY_free(pk);
  }
#line 503
  if ((unsigned int )prv != (unsigned int )((void *)0)) {
#line 503
    if (commentp) {
#line 504
      *commentp = xstrdup((char const   *)name);
    }
  }
#line 505
  if (prv) {
#line 505
    tmp___3 = key_type((Key const   *)prv);
  } else {
#line 505
    tmp___3 = "<unknown>";
  }
#line 505
  debug("read PEM private key done: type %s", tmp___3);
#line 507
  return (prv);
}
}
#line 510 "authfile.c"
static int key_perm_ok(int fd , char const   *filename ) 
{ struct stat st ;
  int tmp ;
  __uid_t tmp___0 ;

  {
#line 515
  tmp = fstat(fd, & st);
#line 515
  if (tmp < 0) {
#line 516
    return (0);
  }
#line 525
  tmp___0 = getuid();
#line 525
  if (st.st_uid == tmp___0) {
#line 525
    if ((st.st_mode & 63U) != 0U) {
#line 526
      error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 527
      error("@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @");
#line 528
      error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 529
      error("Permissions 0%3.3o for \'%s\' are too open.", st.st_mode & 511U, filename);
#line 531
      error("It is recommended that your private key files are NOT accessible by others.");
#line 532
      error("This private key will be ignored.");
#line 533
      return (0);
    }
  }
#line 535
  return (1);
}
}
#line 538 "authfile.c"
Key *key_load_private_type(int type , char const   *filename , char const   *passphrase ,
                           char **commentp ) 
{ int fd ;
  int tmp ;
  Key *tmp___0 ;
  Key *tmp___1 ;

  {
#line 544
  fd = open(filename, 0);
#line 545
  if (fd < 0) {
#line 546
    return ((Key *)((void *)0));
  }
#line 547
  tmp = key_perm_ok(fd, filename);
#line 547
  if (! tmp) {
#line 548
    error("bad permissions: ignore key: %s", filename);
#line 549
    close(fd);
#line 550
    return ((Key *)((void *)0));
  }
#line 552
  switch (type) {
  case 0: 
#line 554
  tmp___0 = key_load_private_rsa1(fd, filename, passphrase, commentp);
#line 554
  return (tmp___0);
#line 557
  break;
  case 2: 
  case 1: 
  case 3: 
#line 561
  tmp___1 = key_load_private_pem(fd, type, passphrase, commentp);
#line 561
  return (tmp___1);
#line 563
  break;
  default: 
#line 565
  close(fd);
#line 566
  break;
  }
#line 568
  return ((Key *)((void *)0));
}
}
#line 571 "authfile.c"
Key *key_load_private(char const   *filename , char const   *passphrase , char **commentp ) 
{ Key *pub ;
  Key *prv ;
  int fd ;
  int tmp ;

  {
#line 578
  fd = open(filename, 0);
#line 579
  if (fd < 0) {
#line 580
    return ((Key *)((void *)0));
  }
#line 581
  tmp = key_perm_ok(fd, filename);
#line 581
  if (! tmp) {
#line 582
    error("bad permissions: ignore key: %s", filename);
#line 583
    close(fd);
#line 584
    return ((Key *)((void *)0));
  }
#line 586
  pub = key_load_public_rsa1(fd, filename, commentp);
#line 587
  lseek(fd, 0LL, 0);
#line 588
  if ((unsigned int )pub == (unsigned int )((void *)0)) {
#line 590
    prv = key_load_private_pem(fd, 3, passphrase, (char **)((void *)0));
#line 592
    if (commentp) {
#line 592
      if (prv) {
#line 593
        *commentp = xstrdup(filename);
      }
    }
  } else {
#line 596
    key_free(pub);
#line 598
    prv = key_load_private_rsa1(fd, filename, passphrase, (char **)((void *)0));
  }
#line 600
  return (prv);
}
}
#line 603 "authfile.c"
static int key_try_load_public(Key *k , char const   *filename , char **commentp ) 
{ FILE *f ;
  char line[8192] ;
  char *cp ;
  u_long linenum ;
  int tmp ;
  int tmp___0 ;

  {
#line 609
  linenum = (u_long )0;
#line 611
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 612
  if ((unsigned int )f != (unsigned int )((void *)0)) {
#line 613
    while (1) {
#line 613
      tmp___0 = read_keyfile_line(f, filename, line, sizeof(line), & linenum);
#line 613
      if (! (tmp___0 != -1)) {
#line 613
        break;
      }
#line 615
      cp = line;
#line 616
      switch ((int )*cp) {
      case 35: 
      case 10: 
      case 0: 
#line 620
      continue;
      }
#line 623
      while (1) {
#line 623
        if (*cp) {
#line 623
          if (! ((int )*cp == 32)) {
#line 623
            if (! ((int )*cp == 9)) {
#line 623
              break;
            }
          }
        } else {
#line 623
          break;
        }
#line 623
        cp ++;
      }
#line 625
      if (*cp) {
#line 626
        tmp = key_read(k, & cp);
#line 626
        if (tmp == 1) {
#line 627
          if (commentp) {
#line 628
            *commentp = xstrdup(filename);
          }
#line 629
          fclose(f);
#line 630
          return (1);
        }
      }
    }
#line 634
    fclose(f);
  }
#line 636
  return (0);
}
}
#line 640 "authfile.c"
Key *key_load_public(char const   *filename , char **commentp ) 
{ Key *pub ;
  char file___0[4096] ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 647
  pub = key_load_public_type(0, filename, commentp);
#line 648
  if ((unsigned int )pub != (unsigned int )((void *)0)) {
#line 649
    return (pub);
  }
#line 652
  pub = key_new(0);
#line 653
  tmp = key_try_load_public(pub, filename, commentp);
#line 653
  if (tmp == 1) {
#line 654
    return (pub);
  }
#line 655
  key_free(pub);
#line 658
  pub = key_new(3);
#line 659
  tmp___0 = key_try_load_public(pub, filename, commentp);
#line 659
  if (tmp___0 == 1) {
#line 660
    return (pub);
  }
#line 661
  tmp___1 = strlcpy(file___0, filename, sizeof(file___0));
#line 661
  if (tmp___1 < sizeof(file___0)) {
#line 661
    tmp___2 = strlcat(file___0, ".pub", sizeof(file___0));
#line 661
    if (tmp___2 < sizeof(file___0)) {
#line 661
      tmp___3 = key_try_load_public(pub, (char const   *)(file___0), commentp);
#line 661
      if (tmp___3 == 1) {
#line 664
        return (pub);
      }
    }
  }
#line 665
  key_free(pub);
#line 666
  return ((Key *)((void *)0));
}
}
#line 1 "bufaux.o"
#line 46 "./buffer.h"
int buffer_get_ret(Buffer *buffer , void *buf___1 , u_int len ) ;
#line 47
int buffer_consume_ret(Buffer *buffer , u_int bytes ) ;
#line 412 "/usr/include/openssl/bn.h"
extern BIGNUM *BN_bin2bn(unsigned char const   *s , int len , BIGNUM *ret ) ;
#line 413
extern int BN_bn2bin(BIGNUM const   *a , unsigned char *to ) ;
#line 24 "bufaux.h"
void buffer_get_bignum2(Buffer *buffer , BIGNUM *value ) ;
#line 26
u_short buffer_get_short(Buffer *buffer ) ;
#line 27
void buffer_put_short(Buffer *buffer , u_short value ) ;
#line 32
u_int64_t buffer_get_int64(Buffer *buffer ) ;
#line 33
void buffer_put_int64(Buffer *buffer , u_int64_t value ) ;
#line 45
int buffer_put_bignum_ret(Buffer *buffer , BIGNUM const   *value ) ;
#line 46
int buffer_get_bignum_ret(Buffer *buffer , BIGNUM *value ) ;
#line 47
int buffer_put_bignum2_ret(Buffer *buffer , BIGNUM const   *value ) ;
#line 48
int buffer_get_bignum2_ret(Buffer *buffer , BIGNUM *value ) ;
#line 49
int buffer_get_short_ret(u_short *ret , Buffer *buffer ) ;
#line 50
int buffer_get_int_ret(u_int *ret , Buffer *buffer ) ;
#line 51
int buffer_get_int64_ret(u_int64_t *ret , Buffer *buffer ) ;
#line 52
void *buffer_get_string_ret(Buffer *buffer , u_int *length_ptr ) ;
#line 53
int buffer_get_char_ret(char *ret , Buffer *buffer ) ;
#line 52 "bufaux.c"
int buffer_put_bignum_ret(Buffer *buffer , BIGNUM const   *value ) 
{ int bits ;
  int tmp ;
  int bin_size ;
  u_char *buf___1 ;
  void *tmp___0 ;
  int oi ;
  char msg[2] ;

  {
#line 55
  tmp = BN_num_bits(value);
#line 55
  bits = tmp;
#line 56
  bin_size = (bits + 7) / 8;
#line 57
  tmp___0 = xmalloc((unsigned int )bin_size);
#line 57
  buf___1 = (u_char *)tmp___0;
#line 62
  oi = BN_bn2bin(value, buf___1);
#line 63
  if (oi != bin_size) {
#line 64
    error("buffer_put_bignum_ret: BN_bn2bin() failed: oi %d != bin_size %d", oi, bin_size);
#line 66
    xfree((void *)buf___1);
#line 67
    return (-1);
  }
#line 71
  while (1) {
#line 71
    msg[0] = (char )(bits >> 8);
#line 71
    msg[1] = (char )bits;
#line 71
    break;
  }
#line 72
  buffer_append(buffer, (void const   *)(msg), 2U);
#line 74
  buffer_append(buffer, (void const   *)((char *)buf___1), (unsigned int )oi);
#line 76
  memset((void *)buf___1, 0, (unsigned int )bin_size);
#line 77
  xfree((void *)buf___1);
#line 79
  return (0);
}
}
#line 82 "bufaux.c"
void buffer_put_bignum(Buffer *buffer , BIGNUM const   *value ) 
{ int tmp ;

  {
#line 85
  tmp = buffer_put_bignum_ret(buffer, value);
#line 85
  if (tmp == -1) {
#line 86
    fatal("buffer_put_bignum: buffer error");
  }
#line 87
  return;
}
}
#line 92 "bufaux.c"
int buffer_get_bignum_ret(Buffer *buffer , BIGNUM *value ) 
{ u_int bits ;
  u_int bytes ;
  u_char buf___1[2] ;
  u_char *bin ;
  int tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 99
  tmp = buffer_get_ret(buffer, (void *)((char *)(buf___1)), 2U);
#line 99
  if (tmp == -1) {
#line 100
    error("buffer_get_bignum_ret: invalid length");
#line 101
    return (-1);
  }
#line 103
  bits = (unsigned int )(((unsigned long )buf___1[0] << 8) | (unsigned long )buf___1[1]);
#line 105
  bytes = (bits + 7U) / 8U;
#line 106
  if (bytes > 8192U) {
#line 107
    error("buffer_get_bignum_ret: cannot handle BN of size %d", bytes);
#line 108
    return (-1);
  }
#line 110
  tmp___0 = buffer_len(buffer);
#line 110
  if (tmp___0 < bytes) {
#line 111
    error("buffer_get_bignum_ret: input buffer too small");
#line 112
    return (-1);
  }
#line 114
  tmp___1 = buffer_ptr(buffer);
#line 114
  bin = (u_char *)tmp___1;
#line 115
  BN_bin2bn((unsigned char const   *)bin, (int )bytes, value);
#line 116
  tmp___2 = buffer_consume_ret(buffer, bytes);
#line 116
  if (tmp___2 == -1) {
#line 117
    error("buffer_get_bignum_ret: buffer_consume failed");
#line 118
    return (-1);
  }
#line 120
  return (0);
}
}
#line 123 "bufaux.c"
void buffer_get_bignum(Buffer *buffer , BIGNUM *value ) 
{ int tmp ;

  {
#line 126
  tmp = buffer_get_bignum_ret(buffer, value);
#line 126
  if (tmp == -1) {
#line 127
    fatal("buffer_get_bignum: buffer error");
  }
#line 128
  return;
}
}
#line 133 "bufaux.c"
int buffer_put_bignum2_ret(Buffer *buffer , BIGNUM const   *value ) 
{ u_int bytes ;
  u_char *buf___1 ;
  int oi ;
  u_int hasnohigh ;
  int tmp ;
  void *tmp___0 ;

  {
#line 139
  hasnohigh = (u_int )0;
#line 141
  if (value->top == 0) {
#line 142
    buffer_put_int(buffer, 0U);
#line 143
    return (0);
  }
#line 145
  if (value->neg) {
#line 146
    error("buffer_put_bignum2_ret: negative numbers not supported");
#line 147
    return (-1);
  }
#line 149
  tmp = BN_num_bits(value);
#line 149
  bytes = (unsigned int )((tmp + 7) / 8 + 1);
#line 150
  if (bytes < 2U) {
#line 151
    error("buffer_put_bignum2_ret: BN too small");
#line 152
    return (-1);
  }
#line 154
  tmp___0 = xmalloc(bytes);
#line 154
  buf___1 = (u_char *)tmp___0;
#line 155
  *(buf___1 + 0) = (unsigned char)0;
#line 157
  oi = BN_bn2bin(value, buf___1 + 1);
#line 158
  if (oi < 0) {
#line 159
    error("buffer_put_bignum2_ret: BN_bn2bin() failed: oi %d != bin_size %d", oi,
          bytes);
#line 161
    xfree((void *)buf___1);
#line 162
    return (-1);
  } else {
#line 158
    if ((unsigned int )oi != bytes - 1U) {
#line 159
      error("buffer_put_bignum2_ret: BN_bn2bin() failed: oi %d != bin_size %d", oi,
            bytes);
#line 161
      xfree((void *)buf___1);
#line 162
      return (-1);
    }
  }
#line 164
  if ((int )*(buf___1 + 1) & 128) {
#line 164
    hasnohigh = 0U;
  } else {
#line 164
    hasnohigh = 1U;
  }
#line 165
  buffer_put_string(buffer, (void const   *)(buf___1 + hasnohigh), bytes - hasnohigh);
#line 166
  memset((void *)buf___1, 0, bytes);
#line 167
  xfree((void *)buf___1);
#line 168
  return (0);
}
}
#line 171 "bufaux.c"
void buffer_put_bignum2(Buffer *buffer , BIGNUM const   *value ) 
{ int tmp ;

  {
#line 174
  tmp = buffer_put_bignum2_ret(buffer, value);
#line 174
  if (tmp == -1) {
#line 175
    fatal("buffer_put_bignum2: buffer error");
  }
#line 176
  return;
}
}
#line 178 "bufaux.c"
int buffer_get_bignum2_ret(Buffer *buffer , BIGNUM *value ) 
{ u_int len ;
  u_char *bin ;
  void *tmp ;

  {
#line 184
  tmp = buffer_get_string_ret(buffer, & len);
#line 184
  bin = (u_char *)tmp;
#line 184
  if ((unsigned int )bin == (unsigned int )((void *)0)) {
#line 185
    error("buffer_get_bignum2_ret: invalid bignum");
#line 186
    return (-1);
  }
#line 189
  if (len > 0U) {
#line 189
    if ((int )*(bin + 0) & 128) {
#line 190
      error("buffer_get_bignum2_ret: negative numbers not supported");
#line 191
      xfree((void *)bin);
#line 192
      return (-1);
    }
  }
#line 194
  if (len > 8192U) {
#line 195
    error("buffer_get_bignum2_ret: cannot handle BN of size %d", len);
#line 196
    xfree((void *)bin);
#line 197
    return (-1);
  }
#line 199
  BN_bin2bn((unsigned char const   *)bin, (int )len, value);
#line 200
  xfree((void *)bin);
#line 201
  return (0);
}
}
#line 204 "bufaux.c"
void buffer_get_bignum2(Buffer *buffer , BIGNUM *value ) 
{ int tmp ;

  {
#line 207
  tmp = buffer_get_bignum2_ret(buffer, value);
#line 207
  if (tmp == -1) {
#line 208
    fatal("buffer_get_bignum2: buffer error");
  }
#line 209
  return;
}
}
#line 215 "bufaux.c"
int buffer_get_short_ret(u_short *ret , Buffer *buffer ) 
{ u_char buf___1[2] ;
  int tmp ;

  {
#line 220
  tmp = buffer_get_ret(buffer, (void *)((char *)(buf___1)), 2U);
#line 220
  if (tmp == -1) {
#line 221
    return (-1);
  }
#line 222
  *ret = (unsigned short )(((unsigned long )buf___1[0] << 8) | (unsigned long )buf___1[1]);
#line 223
  return (0);
}
}
#line 226 "bufaux.c"
u_short buffer_get_short(Buffer *buffer ) 
{ u_short ret ;
  int tmp ;

  {
#line 231
  tmp = buffer_get_short_ret(& ret, buffer);
#line 231
  if (tmp == -1) {
#line 232
    fatal("buffer_get_short: buffer error");
  }
#line 234
  return (ret);
}
}
#line 237 "bufaux.c"
int buffer_get_int_ret(u_int *ret , Buffer *buffer ) 
{ u_char buf___1[4] ;
  int tmp ;

  {
#line 242
  tmp = buffer_get_ret(buffer, (void *)((char *)(buf___1)), 4U);
#line 242
  if (tmp == -1) {
#line 243
    return (-1);
  }
#line 244
  *ret = (unsigned int )(((((unsigned long )buf___1[0] << 24) | ((unsigned long )buf___1[1] << 16)) | ((unsigned long )buf___1[2] << 8)) | (unsigned long )buf___1[3]);
#line 245
  return (0);
}
}
#line 248 "bufaux.c"
u_int buffer_get_int(Buffer *buffer ) 
{ u_int ret ;
  int tmp ;

  {
#line 253
  tmp = buffer_get_int_ret(& ret, buffer);
#line 253
  if (tmp == -1) {
#line 254
    fatal("buffer_get_int: buffer error");
  }
#line 256
  return (ret);
}
}
#line 259 "bufaux.c"
int buffer_get_int64_ret(u_int64_t *ret , Buffer *buffer ) 
{ u_char buf___1[8] ;
  int tmp ;

  {
#line 264
  tmp = buffer_get_ret(buffer, (void *)((char *)(buf___1)), 8U);
#line 264
  if (tmp == -1) {
#line 265
    return (-1);
  }
#line 266
  *ret = ((((((((unsigned long long )buf___1[0] << 56) | ((unsigned long long )buf___1[1] << 48)) | ((unsigned long long )buf___1[2] << 40)) | ((unsigned long long )buf___1[3] << 32)) | ((unsigned long long )buf___1[4] << 24)) | ((unsigned long long )buf___1[5] << 16)) | ((unsigned long long )buf___1[6] << 8)) | (unsigned long long )buf___1[7];
#line 267
  return (0);
}
}
#line 270 "bufaux.c"
u_int64_t buffer_get_int64(Buffer *buffer ) 
{ u_int64_t ret ;
  int tmp ;

  {
#line 275
  tmp = buffer_get_int64_ret(& ret, buffer);
#line 275
  if (tmp == -1) {
#line 276
    fatal("buffer_get_int: buffer error");
  }
#line 278
  return (ret);
}
}
#line 284 "bufaux.c"
void buffer_put_short(Buffer *buffer , u_short value ) 
{ char buf___1[2] ;

  {
#line 289
  while (1) {
#line 289
    buf___1[0] = (char )((int )value >> 8);
#line 289
    buf___1[1] = (char )value;
#line 289
    break;
  }
#line 290
  buffer_append(buffer, (void const   *)(buf___1), 2U);
#line 291
  return;
}
}
#line 293 "bufaux.c"
void buffer_put_int(Buffer *buffer , u_int value ) 
{ char buf___1[4] ;

  {
#line 298
  while (1) {
#line 298
    buf___1[0] = (char )(value >> 24);
#line 298
    buf___1[1] = (char )(value >> 16);
#line 298
    buf___1[2] = (char )(value >> 8);
#line 298
    buf___1[3] = (char )value;
#line 298
    break;
  }
#line 299
  buffer_append(buffer, (void const   *)(buf___1), 4U);
#line 300
  return;
}
}
#line 302 "bufaux.c"
void buffer_put_int64(Buffer *buffer , u_int64_t value ) 
{ char buf___1[8] ;

  {
#line 307
  while (1) {
#line 307
    buf___1[0] = (char )(value >> 56);
#line 307
    buf___1[1] = (char )(value >> 48);
#line 307
    buf___1[2] = (char )(value >> 40);
#line 307
    buf___1[3] = (char )(value >> 32);
#line 307
    buf___1[4] = (char )(value >> 24);
#line 307
    buf___1[5] = (char )(value >> 16);
#line 307
    buf___1[6] = (char )(value >> 8);
#line 307
    buf___1[7] = (char )value;
#line 307
    break;
  }
#line 308
  buffer_append(buffer, (void const   *)(buf___1), 8U);
#line 309
  return;
}
}
#line 319 "bufaux.c"
void *buffer_get_string_ret(Buffer *buffer , u_int *length_ptr ) 
{ u_char *value ;
  u_int len ;
  void *tmp ;
  int tmp___0 ;

  {
#line 326
  len = buffer_get_int(buffer);
#line 327
  if (len > 262144U) {
#line 328
    error("buffer_get_string_ret: bad string length %u", len);
#line 329
    return ((void *)0);
  }
#line 332
  tmp = xmalloc(len + 1U);
#line 332
  value = (u_char *)tmp;
#line 334
  tmp___0 = buffer_get_ret(buffer, (void *)value, len);
#line 334
  if (tmp___0 == -1) {
#line 335
    error("buffer_get_string_ret: buffer_get failed");
#line 336
    xfree((void *)value);
#line 337
    return ((void *)0);
  }
#line 340
  *(value + len) = (unsigned char)0;
#line 342
  if (length_ptr) {
#line 343
    *length_ptr = len;
  }
#line 344
  return ((void *)value);
}
}
#line 347 "bufaux.c"
void *buffer_get_string(Buffer *buffer , u_int *length_ptr ) 
{ void *ret ;

  {
#line 352
  ret = buffer_get_string_ret(buffer, length_ptr);
#line 352
  if ((unsigned int )ret == (unsigned int )((void *)0)) {
#line 353
    fatal("buffer_get_string: buffer error");
  }
#line 354
  return (ret);
}
}
#line 360 "bufaux.c"
void buffer_put_string(Buffer *buffer , void const   *buf___1 , u_int len ) 
{ 

  {
#line 363
  buffer_put_int(buffer, len);
#line 364
  buffer_append(buffer, buf___1, len);
#line 365
  return;
}
}
#line 366 "bufaux.c"
void buffer_put_cstring(Buffer *buffer , char const   *s ) 
{ size_t tmp ;

  {
#line 369
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 370
    fatal("buffer_put_cstring: s == NULL");
  }
#line 371
  tmp = strlen(s);
#line 371
  buffer_put_string(buffer, (void const   *)s, tmp);
#line 372
  return;
}
}
#line 377 "bufaux.c"
int buffer_get_char_ret(char *ret , Buffer *buffer ) 
{ int tmp ;

  {
#line 380
  tmp = buffer_get_ret(buffer, (void *)ret, 1U);
#line 380
  if (tmp == -1) {
#line 381
    error("buffer_get_char_ret: buffer_get_ret failed");
#line 382
    return (-1);
  }
#line 384
  return (0);
}
}
#line 387 "bufaux.c"
int buffer_get_char(Buffer *buffer ) 
{ char ch ;
  int tmp ;

  {
#line 392
  tmp = buffer_get_char_ret(& ch, buffer);
#line 392
  if (tmp == -1) {
#line 393
    fatal("buffer_get_char: buffer error");
  }
#line 394
  return ((int )((unsigned char )ch));
}
}
#line 400 "bufaux.c"
void buffer_put_char(Buffer *buffer , int value ) 
{ char ch ;

  {
#line 403
  ch = (char )value;
#line 405
  buffer_append(buffer, (void const   *)(& ch), 1U);
#line 406
  return;
}
}
#line 1 "buffer.o"
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 39 "./buffer.h"
void buffer_get(Buffer *buffer , void *buf___1 , u_int len ) ;
#line 41
void buffer_consume(Buffer *buffer , u_int bytes ) ;
#line 42
void buffer_consume_end(Buffer *buffer , u_int bytes ) ;
#line 44
void buffer_dump(Buffer *buffer ) ;
#line 48
int buffer_consume_end_ret(Buffer *buffer , u_int bytes ) ;
#line 23 "xmalloc.h"
void *xrealloc(void *ptr , size_t new_size ) ;
#line 23 "buffer.c"
void buffer_init(Buffer *buffer ) 
{ u_int len ;
  void *tmp ;

  {
#line 26
  len = (u_int )4096;
#line 28
  buffer->alloc = 0U;
#line 29
  tmp = xmalloc(len);
#line 29
  buffer->buf = (u_char *)tmp;
#line 30
  buffer->alloc = len;
#line 31
  buffer->offset = 0U;
#line 32
  buffer->end = 0U;
#line 33
  return;
}
}
#line 37 "buffer.c"
void buffer_free(Buffer *buffer ) 
{ 

  {
#line 40
  if (buffer->alloc > 0U) {
#line 41
    memset((void *)buffer->buf, 0, buffer->alloc);
#line 42
    buffer->alloc = 0U;
#line 43
    xfree((void *)buffer->buf);
  }
#line 45
  return;
}
}
#line 52 "buffer.c"
void buffer_clear(Buffer *buffer ) 
{ 

  {
#line 55
  buffer->offset = 0U;
#line 56
  buffer->end = 0U;
#line 57
  return;
}
}
#line 61 "buffer.c"
void buffer_append(Buffer *buffer , void const   *data , u_int len ) 
{ void *p ;

  {
#line 65
  p = buffer_append_space(buffer, len);
#line 66
  memcpy((void * __restrict  )p, (void const   * __restrict  )data, len);
#line 67
  return;
}
}
#line 75 "buffer.c"
void *buffer_append_space(Buffer *buffer , u_int len ) 
{ u_int newlen ;
  void *p ;
  u_int tmp ;
  void *tmp___0 ;

  {
#line 81
  if (len > 1048576U) {
#line 82
    fatal("buffer_append_space: len %u not supported", len);
  }
#line 85
  if (buffer->offset == buffer->end) {
#line 86
    buffer->offset = 0U;
#line 87
    buffer->end = 0U;
  }
  restart: 
#line 91
  if (buffer->end + len < buffer->alloc) {
#line 92
    p = (void *)(buffer->buf + buffer->end);
#line 93
    buffer->end += len;
#line 94
    return (p);
  }
#line 100
  if (buffer->alloc < 1048576U) {
#line 100
    tmp = buffer->alloc;
  } else {
#line 100
    tmp = 1048576U;
  }
#line 100
  if (buffer->offset > tmp) {
#line 101
    memmove((void *)buffer->buf, (void const   *)(buffer->buf + buffer->offset), buffer->end - buffer->offset);
#line 103
    buffer->end -= buffer->offset;
#line 104
    buffer->offset = 0U;
    goto restart;
  }
#line 109
  newlen = (buffer->alloc + len) + 32768U;
#line 110
  if (newlen > 10485760U) {
#line 111
    fatal("buffer_append_space: alloc %u not supported", newlen);
  }
#line 113
  tmp___0 = xrealloc((void *)buffer->buf, newlen);
#line 113
  buffer->buf = (u_char *)tmp___0;
#line 114
  buffer->alloc = newlen;
  goto restart;
}
}
#line 121 "buffer.c"
u_int buffer_len(Buffer *buffer ) 
{ 

  {
#line 124
  return (buffer->end - buffer->offset);
}
}
#line 129 "buffer.c"
int buffer_get_ret(Buffer *buffer , void *buf___1 , u_int len ) 
{ 

  {
#line 132
  if (len > buffer->end - buffer->offset) {
#line 133
    error("buffer_get_ret: trying to get more bytes %d than in buffer %d", len, buffer->end - buffer->offset);
#line 135
    return (-1);
  }
#line 137
  memcpy((void * __restrict  )buf___1, (void const   * __restrict  )(buffer->buf + buffer->offset),
         len);
#line 138
  buffer->offset += len;
#line 139
  return (0);
}
}
#line 142 "buffer.c"
void buffer_get(Buffer *buffer , void *buf___1 , u_int len ) 
{ int tmp ;

  {
#line 145
  tmp = buffer_get_ret(buffer, buf___1, len);
#line 145
  if (tmp == -1) {
#line 146
    fatal("buffer_get: buffer error");
  }
#line 147
  return;
}
}
#line 151 "buffer.c"
int buffer_consume_ret(Buffer *buffer , u_int bytes ) 
{ 

  {
#line 154
  if (bytes > buffer->end - buffer->offset) {
#line 155
    error("buffer_consume_ret: trying to get more bytes than in buffer");
#line 156
    return (-1);
  }
#line 158
  buffer->offset += bytes;
#line 159
  return (0);
}
}
#line 162 "buffer.c"
void buffer_consume(Buffer *buffer , u_int bytes ) 
{ int tmp ;

  {
#line 165
  tmp = buffer_consume_ret(buffer, bytes);
#line 165
  if (tmp == -1) {
#line 166
    fatal("buffer_consume: buffer error");
  }
#line 167
  return;
}
}
#line 171 "buffer.c"
int buffer_consume_end_ret(Buffer *buffer , u_int bytes ) 
{ 

  {
#line 174
  if (bytes > buffer->end - buffer->offset) {
#line 175
    return (-1);
  }
#line 176
  buffer->end -= bytes;
#line 177
  return (0);
}
}
#line 180 "buffer.c"
void buffer_consume_end(Buffer *buffer , u_int bytes ) 
{ int tmp ;

  {
#line 183
  tmp = buffer_consume_end_ret(buffer, bytes);
#line 183
  if (tmp == -1) {
#line 184
    fatal("buffer_consume_end: trying to get more bytes than in buffer");
  }
#line 185
  return;
}
}
#line 189 "buffer.c"
void *buffer_ptr(Buffer *buffer ) 
{ 

  {
#line 192
  return ((void *)(buffer->buf + buffer->offset));
}
}
#line 197 "buffer.c"
void buffer_dump(Buffer *buffer ) 
{ u_int i ;
  u_char *ucp ;

  {
#line 201
  ucp = buffer->buf;
#line 203
  i = buffer->offset;
#line 203
  while (i < buffer->end) {
#line 204
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%02x", *(ucp + i));
#line 205
    if ((i - buffer->offset) % 16U == 15U) {
#line 206
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\r\n");
    } else {
#line 207
      if ((i - buffer->offset) % 2U == 1U) {
#line 208
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" ");
      }
    }
#line 203
    i ++;
  }
#line 210
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\r\n");
#line 211
  return;
}
}
#line 1 "canohost.o"
#line 116 "/usr/include/ctype.h"
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 401
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 401 "/usr/include/stdlib.h"
__inline static int atoi(char const   *__nptr ) 
{ long tmp ;

  {
#line 404
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 404
  return ((int )tmp);
}
}
#line 128 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int getpeername(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 352 "/usr/include/netdb.h"
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 631
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 637
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
#line 640
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
#line 646
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , unsigned int __flags ) ;
#line 23 "packet.h"
int packet_get_connection_in(void) ;
#line 77
int packet_connection_is_on_socket(void) ;
#line 65 "log.h"
 __attribute__((__noreturn__)) void cleanup_exit(int i ) ;
#line 15 "canohost.h"
char const   *get_canonical_hostname(int use_dns ) ;
#line 16
char const   *get_remote_ipaddr(void) ;
#line 17
char const   *get_remote_name_or_ip(u_int utmp_len___0 , int use_dns ) ;
#line 19
char *get_peer_ipaddr(int sock ) ;
#line 20
int get_peer_port(int sock ) ;
#line 21
char *get_local_ipaddr(int sock ) ;
#line 22
char *get_local_name(int sock ) ;
#line 24
int get_remote_port(void) ;
#line 25
int get_local_port(void) ;
#line 27
void ipv64_normalise_mapped(struct sockaddr_storage *addr , socklen_t *len ) ;
#line 22 "canohost.c"
static void check_ip_options(int sock , char *ipaddr ) ;
#line 29 "canohost.c"
static char *get_remote_hostname(int sock , int use_dns ) 
{ struct sockaddr_storage from ;
  int i ;
  socklen_t fromlen ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char name[1025] ;
  char ntop[1025] ;
  char ntop2[1025] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int __res ;
  __int32_t const   **tmp___10 ;
  unsigned short const   **tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;

  {
#line 39
  fromlen = sizeof(from);
#line 40
  memset((void *)(& from), 0, sizeof(from));
#line 41
  tmp___1 = getpeername(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                        (socklen_t * __restrict  )(& fromlen));
#line 41
  if (tmp___1 < 0) {
#line 42
    tmp = __errno_location();
#line 42
    tmp___0 = strerror(*tmp);
#line 42
    debug("getpeername failed: %.100s", tmp___0);
#line 43
    cleanup_exit(255);
  }
#line 46
  ipv64_normalise_mapped(& from, & fromlen);
#line 48
  if ((int )from.ss_family == 10) {
#line 49
    fromlen = sizeof(struct sockaddr_in6 );
  }
#line 51
  tmp___2 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )((void *)0),
                        0U, 1U);
#line 51
  if (tmp___2 != 0) {
#line 53
    fatal("get_remote_hostname: getnameinfo NI_NUMERICHOST failed");
  }
#line 55
  if ((int )from.ss_family == 2) {
#line 56
    check_ip_options(sock, ntop);
  }
#line 58
  if (! use_dns) {
#line 59
    tmp___3 = xstrdup((char const   *)(ntop));
#line 59
    return (tmp___3);
  }
#line 61
  debug3("Trying to reverse map address %.100s.", ntop);
#line 63
  tmp___5 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )(name), sizeof(name), (char * __restrict  )((void *)0),
                        0U, 8U);
#line 63
  if (tmp___5 != 0) {
#line 66
    tmp___4 = xstrdup((char const   *)(ntop));
#line 66
    return (tmp___4);
  }
#line 74
  memset((void *)(& hints), 0, sizeof(hints));
#line 75
  hints.ai_socktype = 2;
#line 76
  hints.ai_flags = 4;
#line 77
  tmp___7 = getaddrinfo((char const   * __restrict  )(name), (char const   * __restrict  )"0",
                        (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& ai));
#line 77
  if (tmp___7 == 0) {
#line 78
    logit("Nasty PTR record \"%s\" is set up for %s, ignoring", name, ntop);
#line 80
    freeaddrinfo(ai);
#line 81
    tmp___6 = xstrdup((char const   *)(ntop));
#line 81
    return (tmp___6);
  }
#line 88
  i = 0;
#line 88
  while (name[i]) {
#line 89
    tmp___11 = __ctype_b_loc();
#line 89
    if ((int const   )*(*tmp___11 + (int )name[i]) & 256) {
#line 90
      if (sizeof(name[i]) > 1U) {
#line 90
        __res = tolower((int )name[i]);
      } else {
#line 90
        tmp___10 = __ctype_tolower_loc();
#line 90
        __res = (int )*(*tmp___10 + (int )name[i]);
      }
#line 90
      name[i] = (char )__res;
    }
#line 88
    i ++;
  }
#line 100
  memset((void *)(& hints), 0, sizeof(hints));
#line 101
  hints.ai_family = (int )from.ss_family;
#line 102
  hints.ai_socktype = 1;
#line 103
  tmp___13 = getaddrinfo((char const   * __restrict  )(name), (char const   * __restrict  )((void *)0),
                         (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 103
  if (tmp___13 != 0) {
#line 104
    logit("reverse mapping checking getaddrinfo for %.700s failed - POSSIBLE BREAK-IN ATTEMPT!",
          name);
#line 106
    tmp___12 = xstrdup((char const   *)(ntop));
#line 106
    return (tmp___12);
  }
#line 109
  ai = aitop;
#line 109
  while (ai) {
#line 110
    tmp___14 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                           (char * __restrict  )(ntop2), sizeof(ntop2), (char * __restrict  )((void *)0),
                           0U, 1U);
#line 112
    if (tmp___14 == 0) {
#line 112
      if (0) {
#line 112
        __s1_len = strlen((char const   *)(ntop));
#line 112
        __s2_len = strlen((char const   *)(ntop2));
#line 112
        if (! ((unsigned int )((void const   *)(ntop + 1)) - (unsigned int )((void const   *)(ntop)) == 1U)) {
          goto _L___0;
        } else {
#line 112
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 112
            if (! ((unsigned int )((void const   *)(ntop2 + 1)) - (unsigned int )((void const   *)(ntop2)) == 1U)) {
#line 112
              tmp___24 = 1;
            } else {
#line 112
              if (__s2_len >= 4U) {
#line 112
                tmp___24 = 1;
              } else {
#line 112
                tmp___24 = 0;
              }
            }
          } else {
#line 112
            tmp___24 = 0;
          }
        }
#line 112
        if (tmp___24) {
#line 112
          tmp___20 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
        } else {
#line 112
          tmp___23 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
#line 112
          tmp___20 = tmp___23;
        }
      } else {
#line 112
        tmp___23 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
#line 112
        tmp___20 = tmp___23;
      }
#line 112
      if (tmp___20 == 0) {
#line 113
        break;
      }
    }
#line 109
    ai = ai->ai_next;
  }
#line 115
  freeaddrinfo(aitop);
#line 117
  if (! ai) {
#line 119
    logit("Address %.100s maps to %.600s, but this does not map back to the address - POSSIBLE BREAK-IN ATTEMPT!",
          ntop, name);
#line 122
    tmp___25 = xstrdup((char const   *)(ntop));
#line 122
    return (tmp___25);
  }
#line 124
  tmp___26 = xstrdup((char const   *)(name));
#line 124
  return (tmp___26);
}
}
#line 139 "canohost.c"
static void check_ip_options(int sock , char *ipaddr ) 
{ u_char options___0[200] ;
  char text[sizeof(options___0) * 3U + 1U] ;
  socklen_t option_size ;
  u_int i ;
  int ipproto ;
  struct protoent *ip ;
  int tmp ;

  {
#line 150
  ip = getprotobyname("ip");
#line 150
  if ((unsigned int )ip != (unsigned int )((void *)0)) {
#line 151
    ipproto = ip->p_proto;
  } else {
#line 153
    ipproto = 0;
  }
#line 154
  option_size = sizeof(options___0);
#line 155
  tmp = getsockopt(sock, ipproto, 4, (void * __restrict  )(options___0), (socklen_t * __restrict  )(& option_size));
#line 155
  if (tmp >= 0) {
#line 155
    if (option_size != 0U) {
#line 157
      text[0] = (char )'\000';
#line 158
      i = 0U;
#line 158
      while (i < option_size) {
#line 159
        snprintf((char * __restrict  )(text + i * 3U), sizeof(text) - i * 3U, (char const   * __restrict  )" %2.2x",
                 options___0[i]);
#line 158
        i ++;
      }
#line 161
      fatal("Connection from %.100s with IP options:%.800s", ipaddr, text);
    }
  }
#line 165
  return;
}
}
#line 167 "canohost.c"
void ipv64_normalise_mapped(struct sockaddr_storage *addr , socklen_t *len ) 
{ struct sockaddr_in6 *a6 ;
  struct sockaddr_in *a4 ;
  struct in_addr inaddr ;
  u_int16_t port___0 ;
  register unsigned int __v ;
  register unsigned int __x ;

  {
#line 170
  a6 = (struct sockaddr_in6 *)addr;
#line 171
  a4 = (struct sockaddr_in *)addr;
#line 176
  if ((int )addr->ss_family != 10) {
#line 177
    return;
  } else {
#line 176
    if (*((uint32_t const   *)(& a6->sin6_addr) + 0) == 0U) {
#line 176
      if (*((uint32_t const   *)(& a6->sin6_addr) + 1) == 0U) {
#line 176
        __x = 65535U;
#line 176
        __asm__  ("rorw $8, %w0;"
                  "rorl $16, %0;"
                  "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 176
        if (! (*((uint32_t const   *)(& a6->sin6_addr) + 2) == (uint32_t const   )__v)) {
#line 177
          return;
        }
      } else {
#line 177
        return;
      }
    } else {
#line 177
      return;
    }
  }
#line 179
  debug3("Normalising mapped IPv4 in IPv6 address");
#line 181
  memcpy((void * __restrict  )(& inaddr), (void const   * __restrict  )((char *)(& a6->sin6_addr) + 12),
         sizeof(inaddr));
#line 182
  port___0 = a6->sin6_port;
#line 184
  memset((void *)addr, 0, sizeof(*a4));
#line 186
  a4->sin_family = (unsigned short)2;
#line 187
  *len = sizeof(*a4);
#line 188
  memcpy((void * __restrict  )(& a4->sin_addr), (void const   * __restrict  )(& inaddr),
         sizeof(inaddr));
#line 189
  a4->sin_port = port___0;
#line 190
  return;
}
}
#line 202 "canohost.c"
static char *canonical_host_name  =    (char *)((void *)0);
#line 203 "canohost.c"
static char *remote_ip  =    (char *)((void *)0);
#line 198 "canohost.c"
char const   *get_canonical_hostname(int use_dns ) 
{ char *host ;
  int tmp ;
  int tmp___0 ;

  {
#line 206
  if (use_dns) {
#line 206
    if ((unsigned int )canonical_host_name != (unsigned int )((void *)0)) {
#line 207
      return ((char const   *)canonical_host_name);
    }
  }
#line 208
  if (! use_dns) {
#line 208
    if ((unsigned int )remote_ip != (unsigned int )((void *)0)) {
#line 209
      return ((char const   *)remote_ip);
    }
  }
#line 212
  tmp___0 = packet_connection_is_on_socket();
#line 212
  if (tmp___0) {
#line 213
    tmp = packet_get_connection_in();
#line 213
    host = get_remote_hostname(tmp, use_dns);
  } else {
#line 215
    host = (char *)"UNKNOWN";
  }
#line 217
  if (use_dns) {
#line 218
    canonical_host_name = host;
  } else {
#line 220
    remote_ip = host;
  }
#line 221
  return ((char const   *)host);
}
}
#line 228 "canohost.c"
static char *get_socket_address(int sock , int remote___0 , int flags ) 
{ struct sockaddr_storage addr ;
  socklen_t addrlen ;
  char ntop[1025] ;
  int r ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 237
  addrlen = sizeof(addr);
#line 238
  memset((void *)(& addr), 0, sizeof(addr));
#line 240
  if (remote___0) {
#line 241
    tmp = getpeername(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& addr)),
                      (socklen_t * __restrict  )(& addrlen));
#line 241
    if (tmp < 0) {
#line 243
      return ((char *)((void *)0));
    }
  } else {
#line 245
    tmp___0 = getsockname(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& addr)),
                          (socklen_t * __restrict  )(& addrlen));
#line 245
    if (tmp___0 < 0) {
#line 247
      return ((char *)((void *)0));
    }
  }
#line 251
  if ((int )addr.ss_family == 10) {
#line 252
    addrlen = sizeof(struct sockaddr_in6 );
  }
#line 254
  ipv64_normalise_mapped(& addr, & addrlen);
#line 257
  r = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& addr)),
                  addrlen, (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )((void *)0),
                  0U, (unsigned int )flags);
#line 257
  if (r != 0) {
#line 259
    if (r == -11) {
#line 259
      tmp___5 = __errno_location();
#line 259
      tmp___6 = strerror(*tmp___5);
#line 259
      tmp___4 = (char const   *)tmp___6;
    } else {
#line 259
      tmp___4 = gai_strerror(r);
    }
#line 259
    error("get_socket_address: getnameinfo %d failed: %s", flags, tmp___4);
#line 261
    return ((char *)((void *)0));
  }
#line 263
  tmp___7 = xstrdup((char const   *)(ntop));
#line 263
  return (tmp___7);
}
}
#line 266 "canohost.c"
char *get_peer_ipaddr(int sock ) 
{ char *p ;
  char *tmp ;

  {
#line 271
  p = get_socket_address(sock, 1, 1);
#line 271
  if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 272
    return (p);
  }
#line 273
  tmp = xstrdup("UNKNOWN");
#line 273
  return (tmp);
}
}
#line 276 "canohost.c"
char *get_local_ipaddr(int sock ) 
{ char *p ;
  char *tmp ;

  {
#line 281
  p = get_socket_address(sock, 0, 1);
#line 281
  if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 282
    return (p);
  }
#line 283
  tmp = xstrdup("UNKNOWN");
#line 283
  return (tmp);
}
}
#line 286 "canohost.c"
char *get_local_name(int sock ) 
{ char *tmp ;

  {
#line 289
  tmp = get_socket_address(sock, 0, 8);
#line 289
  return (tmp);
}
}
#line 300 "canohost.c"
static char *canonical_host_ip  =    (char *)((void *)0);
#line 297 "canohost.c"
char const   *get_remote_ipaddr(void) 
{ int tmp ;
  int tmp___0 ;

  {
#line 303
  if ((unsigned int )canonical_host_ip == (unsigned int )((void *)0)) {
#line 304
    tmp___0 = packet_connection_is_on_socket();
#line 304
    if (tmp___0) {
#line 305
      tmp = packet_get_connection_in();
#line 305
      canonical_host_ip = get_peer_ipaddr(tmp);
#line 307
      if ((unsigned int )canonical_host_ip == (unsigned int )((void *)0)) {
#line 308
        cleanup_exit(255);
      }
    } else {
#line 311
      canonical_host_ip = xstrdup("UNKNOWN");
    }
  }
#line 314
  return ((char const   *)canonical_host_ip);
}
}
#line 320 "canohost.c"
static char const   *remote  =    "";
#line 317 "canohost.c"
char const   *get_remote_name_or_ip(u_int utmp_len___0 , int use_dns ) 
{ size_t tmp ;

  {
#line 321
  if (utmp_len___0 > 0U) {
#line 322
    remote = get_canonical_hostname(use_dns);
  }
#line 323
  if (utmp_len___0 == 0U) {
#line 324
    remote = get_remote_ipaddr();
  } else {
#line 323
    tmp = strlen(remote);
#line 323
    if (tmp > utmp_len___0) {
#line 324
      remote = get_remote_ipaddr();
    }
  }
#line 325
  return (remote);
}
}
#line 330 "canohost.c"
static int get_sock_port(int sock , int local ) 
{ struct sockaddr_storage from ;
  socklen_t fromlen ;
  char strport[32] ;
  int r ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
#line 339
  fromlen = sizeof(from);
#line 340
  memset((void *)(& from), 0, sizeof(from));
#line 341
  if (local) {
#line 342
    tmp___1 = getsockname(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 342
    if (tmp___1 < 0) {
#line 343
      tmp = __errno_location();
#line 343
      tmp___0 = strerror(*tmp);
#line 343
      error("getsockname failed: %.100s", tmp___0);
#line 344
      return (0);
    }
  } else {
#line 347
    tmp___4 = getpeername(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 347
    if (tmp___4 < 0) {
#line 348
      tmp___2 = __errno_location();
#line 348
      tmp___3 = strerror(*tmp___2);
#line 348
      debug("getpeername failed: %.100s", tmp___3);
#line 349
      return (-1);
    }
  }
#line 354
  if ((int )from.ss_family == 10) {
#line 355
    fromlen = sizeof(struct sockaddr_in6 );
  }
#line 358
  r = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                  fromlen, (char * __restrict  )((void *)0), 0U, (char * __restrict  )(strport),
                  sizeof(strport), 2U);
#line 358
  if (r != 0) {
#line 360
    if (r == -11) {
#line 360
      tmp___9 = __errno_location();
#line 360
      tmp___10 = strerror(*tmp___9);
#line 360
      tmp___8 = (char const   *)tmp___10;
    } else {
#line 360
      tmp___8 = gai_strerror(r);
    }
#line 360
    fatal("get_sock_port: getnameinfo NI_NUMERICSERV failed: %s", tmp___8);
  }
#line 362
  tmp___11 = atoi((char const   *)(strport));
#line 362
  return (tmp___11);
}
}
#line 367 "canohost.c"
static int get_port(int local ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 374
  tmp = packet_connection_is_on_socket();
#line 374
  if (! tmp) {
#line 375
    return (65535);
  }
#line 378
  tmp___0 = packet_get_connection_in();
#line 378
  tmp___1 = get_sock_port(tmp___0, local);
#line 378
  return (tmp___1);
}
}
#line 381 "canohost.c"
int get_peer_port(int sock ) 
{ int tmp ;

  {
#line 384
  tmp = get_sock_port(sock, 0);
#line 384
  return (tmp);
}
}
#line 390 "canohost.c"
static int port  =    -1;
#line 387 "canohost.c"
int get_remote_port(void) 
{ 

  {
#line 393
  if (port == -1) {
#line 394
    port = get_port(0);
  }
#line 396
  return (port);
}
}
#line 399 "canohost.c"
int get_local_port(void) 
{ int tmp ;

  {
#line 402
  tmp = get_port(1);
#line 402
  return (tmp);
}
}
#line 1 "channels.o"
#line 407 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 102 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 170
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 745 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 192 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 199
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 209
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 218
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
#line 54 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
#line 65
extern  __attribute__((__nothrow__)) char const   *inet_ntop(int __af , void const   * __restrict  __cp ,
                                                             char * __restrict  __buf ,
                                                             socklen_t __len ) ;
#line 164 "./channels.h"
Channel *channel_by_id(int id ) ;
#line 165
Channel *channel_lookup(int id ) ;
#line 166
Channel *channel_new(char *ctype , int type , int rfd , int wfd , int efd , u_int window ,
                     u_int maxpack , int extusage , char *remote_name , int nonblock ) ;
#line 167
void channel_set_fds(int id , int rfd , int wfd , int efd , int extusage , int nonblock ,
                     u_int window_max ) ;
#line 168
void channel_free(Channel *c ) ;
#line 169
void channel_free_all(void) ;
#line 170
void channel_stop_listening(void) ;
#line 172
void channel_send_open(int id ) ;
#line 173
void channel_request_start(int id , char *service , int wantconfirm ) ;
#line 174
void channel_register_cleanup(int id , channel_callback_fn *fn , int do_close ) ;
#line 175
void channel_register_confirm(int id , channel_callback_fn *fn , void *ctx ) ;
#line 176
void channel_register_filter(int id , channel_infilter_fn *ifn , channel_outfilter_fn *ofn ) ;
#line 177
void channel_cancel_cleanup(int id ) ;
#line 178
int channel_close_fd(int *fdp ) ;
#line 179
void channel_send_window_changes(void) ;
#line 183
void channel_input_close(int type , u_int32_t seq , void *ctxt ) ;
#line 184
void channel_input_close_confirmation(int type , u_int32_t seq , void *ctxt ) ;
#line 185
void channel_input_data(int type , u_int32_t seq , void *ctxt ) ;
#line 186
void channel_input_extended_data(int type , u_int32_t seq , void *ctxt ) ;
#line 187
void channel_input_ieof(int type , u_int32_t seq , void *ctxt ) ;
#line 188
void channel_input_oclose(int type , u_int32_t seq , void *ctxt ) ;
#line 189
void channel_input_open_confirmation(int type , u_int32_t seq , void *ctxt ) ;
#line 190
void channel_input_open_failure(int type , u_int32_t seq , void *ctxt ) ;
#line 191
void channel_input_port_open(int type , u_int32_t seq , void *ctxt ) ;
#line 192
void channel_input_window_adjust(int type , u_int32_t seq , void *ctxt ) ;
#line 196
void channel_prepare_select(fd_set **readsetp , fd_set **writesetp , int *maxfdp ,
                            u_int *nallocp , int rekeying___0 ) ;
#line 197
void channel_after_select(fd_set *readset , fd_set *writeset ) ;
#line 198
void channel_output_poll(void) ;
#line 200
int channel_not_very_much_buffered_data(void) ;
#line 201
void channel_close_all(void) ;
#line 202
int channel_still_open(void) ;
#line 203
char *channel_open_message(void) ;
#line 204
int channel_find_open(void) ;
#line 207
void channel_set_af(int af ) ;
#line 208
void channel_permit_all_opens(void) ;
#line 209
void channel_add_permitted_opens(char *host , int port___0 ) ;
#line 210
void channel_clear_permitted_opens(void) ;
#line 211
void channel_input_port_forward_request(int is_root , int gateway_ports ) ;
#line 212
int channel_connect_to(char const   *host , u_short port___0 ) ;
#line 213
int channel_connect_by_listen_address(u_short listen_port ) ;
#line 214
void channel_request_remote_forwarding(char const   *listen_host , u_short listen_port ,
                                       char const   *host_to_connect , u_short port_to_connect ) ;
#line 216
int channel_setup_local_fwd_listener(char const   *listen_host , u_short listen_port ,
                                     char const   *host_to_connect , u_short port_to_connect ,
                                     int gateway_ports ) ;
#line 218
void channel_request_rforward_cancel(char const   *host , u_short port___0 ) ;
#line 219
int channel_setup_remote_fwd_listener(char const   *listen_address , u_short listen_port ,
                                      int gateway_ports ) ;
#line 220
int channel_cancel_rport_listener(char const   *host , u_short port___0 ) ;
#line 224
int x11_connect_display(void) ;
#line 225
int x11_create_display_inet(int x11_display_offset , int x11_use_localhost , int single_connection ,
                            u_int *display_numberp , int **chanids ) ;
#line 226
void x11_input_open(int type , u_int32_t seq , void *ctxt ) ;
#line 227
void x11_request_forwarding_with_spoofing(int client_session_id , char const   *disp ,
                                          char const   *proto , char const   *data ) ;
#line 229
void deny_input_open(int type , u_int32_t seq , void *ctxt ) ;
#line 233
void auth_request_forwarding(void) ;
#line 237
int chan_is_dead(Channel *c , int do_send ) ;
#line 238
void chan_mark_dead(Channel *c ) ;
#line 242
void chan_rcvd_oclose(Channel *c ) ;
#line 243
void chan_read_failed(Channel *c ) ;
#line 244
void chan_ibuf_empty(Channel *c ) ;
#line 246
void chan_rcvd_ieof(Channel *c ) ;
#line 247
void chan_write_failed(Channel *c ) ;
#line 248
void chan_obuf_empty(Channel *c ) ;
#line 29 "packet.h"
u_int packet_get_protocol_flags(void) ;
#line 32
int packet_is_interactive(void) ;
#line 36
void packet_start(u_char type ) ;
#line 37
void packet_put_char(int value ) ;
#line 38
void packet_put_int(u_int value ) ;
#line 41
void packet_put_string(void const   *buf___1 , u_int len ) ;
#line 42
void packet_put_cstring(char const   *str ) ;
#line 44
void packet_send(void) ;
#line 46
int packet_read(void) ;
#line 54
u_int packet_get_int(void) ;
#line 58
void *packet_get_string(u_int *length_ptr ) ;
#line 59
void ( /* format attribute */  packet_disconnect)(char const   *fmt  , ...) ;
#line 73
void packet_write_wait(void) ;
#line 79
int packet_remaining(void) ;
#line 80
void packet_send_ignore(int nbytes ) ;
#line 86
u_int max_packet_size ;
#line 59 "log.h"
void ( /* format attribute */  verbose)(char const   *fmt  , ...) ;
#line 61
void ( /* format attribute */  debug2)(char const   *fmt  , ...) ;
#line 19 "misc.h"
int set_nonblock(int fd ) ;
#line 21
void set_nodelay(int fd ) ;
#line 30
char *tohex(u_char const   *d , u_int l ) ;
#line 66 "compat.h"
int compat13 ;
#line 67
int compat20 ;
#line 65 "channels.c"
static Channel **channels  =    (Channel **)((void *)0);
#line 71 "channels.c"
static u_int channels_alloc  =    (u_int )0;
#line 77 "channels.c"
static int channel_max_fd  =    0;
#line 95 "channels.c"
static ForwardPermission permitted_opens[100]  ;
#line 98 "channels.c"
static int num_permitted_opens  =    0;
#line 104 "channels.c"
static int all_opens_permitted  =    0;
#line 113 "channels.c"
static char *x11_saved_display  =    (char *)((void *)0);
#line 116 "channels.c"
static char *x11_saved_proto  =    (char *)((void *)0);
#line 119 "channels.c"
static char *x11_saved_data  =    (char *)((void *)0);
#line 120 "channels.c"
static u_int x11_saved_data_len  =    (u_int )0;
#line 126 "channels.c"
static char *x11_fake_data  =    (char *)((void *)0);
#line 127 "channels.c"
static u_int x11_fake_data_len  ;
#line 135 "channels.c"
static int IPv4or6  =    0;
#line 138
static void port_open_helper(Channel *c , char *rtype ) ;
#line 142 "channels.c"
Channel *channel_by_id(int id ) 
{ Channel *c ;

  {
#line 147
  if (id < 0) {
#line 148
    logit("channel_by_id: %d: bad id", id);
#line 149
    return ((Channel *)((void *)0));
  } else {
#line 147
    if ((unsigned int )id >= channels_alloc) {
#line 148
      logit("channel_by_id: %d: bad id", id);
#line 149
      return ((Channel *)((void *)0));
    }
  }
#line 151
  c = *(channels + id);
#line 152
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 153
    logit("channel_by_id: %d: bad id: channel free", id);
#line 154
    return ((Channel *)((void *)0));
  }
#line 156
  return (c);
}
}
#line 163 "channels.c"
Channel *channel_lookup(int id ) 
{ Channel *c ;

  {
#line 168
  c = channel_by_id(id);
#line 168
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 169
    return ((Channel *)((void *)0));
  }
#line 171
  switch (c->type) {
  case 7: 
  case 10: 
  case 12: 
  case 13: 
  case 3: 
  case 4: 
  case 8: 
  case 9: 
#line 180
  return (c);
#line 181
  break;
  }
#line 183
  logit("Non-public channel %d, type %d.", id, c->type);
#line 184
  return ((Channel *)((void *)0));
}
}
#line 192 "channels.c"
static void channel_register_fds(Channel *c , int rfd , int wfd , int efd , int extusage ,
                                 int nonblock ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 197
  if (channel_max_fd > rfd) {
#line 197
    channel_max_fd = channel_max_fd;
  } else {
#line 197
    channel_max_fd = rfd;
  }
#line 198
  if (channel_max_fd > wfd) {
#line 198
    channel_max_fd = channel_max_fd;
  } else {
#line 198
    channel_max_fd = wfd;
  }
#line 199
  if (channel_max_fd > efd) {
#line 199
    channel_max_fd = channel_max_fd;
  } else {
#line 199
    channel_max_fd = efd;
  }
#line 203
  c->rfd = rfd;
#line 204
  c->wfd = wfd;
#line 205
  if (rfd == wfd) {
#line 205
    c->sock = rfd;
  } else {
#line 205
    c->sock = -1;
  }
#line 206
  c->ctl_fd = -1;
#line 207
  c->efd = efd;
#line 208
  c->extended_usage = extusage;
#line 211
  if (nonblock) {
#line 211
    tmp___0 = isatty(c->rfd);
#line 211
    if (tmp___0) {
#line 212
      debug2("channel %d: rfd %d isatty", c->self, c->rfd);
#line 213
      c->isatty = 1;
#line 214
      tmp = isatty(c->wfd);
#line 214
      if (! tmp) {
#line 215
        error("channel %d: wfd %d is not a tty?", c->self, c->wfd);
      }
    } else {
#line 219
      c->isatty = 0;
    }
  } else {
#line 219
    c->isatty = 0;
  }
#line 221
  c->wfd_isatty = isatty(c->wfd);
#line 224
  if (nonblock) {
#line 225
    if (rfd != -1) {
#line 226
      set_nonblock(rfd);
    }
#line 227
    if (wfd != -1) {
#line 228
      set_nonblock(wfd);
    }
#line 229
    if (efd != -1) {
#line 230
      set_nonblock(efd);
    }
  }
#line 232
  return;
}
}
#line 239 "channels.c"
Channel *channel_new(char *ctype , int type , int rfd , int wfd , int efd , u_int window ,
                     u_int maxpack , int extusage , char *remote_name , int nonblock ) 
{ int found ;
  u_int i ;
  Channel *c ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 248
  if (channels_alloc == 0U) {
#line 249
    channels_alloc = 10U;
#line 250
    tmp = xmalloc(channels_alloc * sizeof(Channel *));
#line 250
    channels = (Channel **)tmp;
#line 251
    i = 0U;
#line 251
    while (i < channels_alloc) {
#line 252
      *(channels + i) = (Channel *)((void *)0);
#line 251
      i ++;
    }
  }
#line 255
  found = -1;
#line 255
  i = 0U;
#line 255
  while (i < channels_alloc) {
#line 256
    if ((unsigned int )*(channels + i) == (unsigned int )((void *)0)) {
#line 258
      found = (int )i;
#line 259
      break;
    }
#line 255
    i ++;
  }
#line 261
  if (found < 0) {
#line 263
    found = (int )channels_alloc;
#line 264
    if (channels_alloc > 10000U) {
#line 265
      fatal("channel_new: internal error: channels_alloc %d too big.", channels_alloc);
    }
#line 267
    tmp___0 = xrealloc((void *)channels, (channels_alloc + 10U) * sizeof(Channel *));
#line 267
    channels = (Channel **)tmp___0;
#line 269
    channels_alloc += 10U;
#line 270
    debug2("channel: expanding %d", channels_alloc);
#line 271
    i = (unsigned int )found;
#line 271
    while (i < channels_alloc) {
#line 272
      *(channels + i) = (Channel *)((void *)0);
#line 271
      i ++;
    }
  }
#line 275
  tmp___1 = xmalloc(sizeof(Channel ));
#line 275
  *(channels + found) = (Channel *)tmp___1;
#line 275
  c = *(channels + found);
#line 276
  memset((void *)c, 0, sizeof(Channel ));
#line 277
  buffer_init(& c->input);
#line 278
  buffer_init(& c->output);
#line 279
  buffer_init(& c->extended);
#line 280
  c->ostate = 0U;
#line 281
  c->istate = 0U;
#line 282
  c->flags = 0;
#line 283
  channel_register_fds(c, rfd, wfd, efd, extusage, nonblock);
#line 284
  c->self = found;
#line 285
  c->type = type;
#line 286
  c->ctype = ctype;
#line 287
  c->local_window = window;
#line 288
  c->local_window_max = window;
#line 289
  c->local_consumed = 0U;
#line 290
  c->local_maxpacket = maxpack;
#line 291
  c->remote_id = -1;
#line 292
  c->remote_name = xstrdup((char const   *)remote_name);
#line 293
  c->remote_window = 0U;
#line 294
  c->remote_maxpacket = 0U;
#line 295
  c->force_drain = 0;
#line 296
  c->single_connection = 0;
#line 297
  c->detach_user = (channel_callback_fn *)((void *)0);
#line 298
  c->detach_close = 0;
#line 299
  c->confirm = (channel_callback_fn *)((void *)0);
#line 300
  c->confirm_ctx = (void *)0;
#line 301
  c->input_filter = (channel_infilter_fn *)((void *)0);
#line 302
  c->output_filter = (channel_outfilter_fn *)((void *)0);
#line 303
  debug("channel %d: new [%s]", found, remote_name);
#line 304
  return (c);
}
}
#line 307 "channels.c"
static int channel_find_maxfd(void) 
{ u_int i ;
  int max ;
  Channel *c ;

  {
#line 311
  max = 0;
#line 314
  i = 0U;
#line 314
  while (i < channels_alloc) {
#line 315
    c = *(channels + i);
#line 316
    if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 317
      if (max > c->rfd) {
#line 317
        max = max;
      } else {
#line 317
        max = c->rfd;
      }
#line 318
      if (max > c->wfd) {
#line 318
        max = max;
      } else {
#line 318
        max = c->wfd;
      }
#line 319
      if (max > c->efd) {
#line 319
        max = max;
      } else {
#line 319
        max = c->efd;
      }
    }
#line 314
    i ++;
  }
#line 322
  return (max);
}
}
#line 325 "channels.c"
int channel_close_fd(int *fdp ) 
{ int ret ;
  int fd ;

  {
#line 328
  ret = 0;
#line 328
  fd = *fdp;
#line 330
  if (fd != -1) {
#line 331
    ret = close(fd);
#line 332
    *fdp = -1;
#line 333
    if (fd == channel_max_fd) {
#line 334
      channel_max_fd = channel_find_maxfd();
    }
  }
#line 336
  return (ret);
}
}
#line 341 "channels.c"
static void channel_close_fds(Channel *c ) 
{ 

  {
#line 344
  debug3("channel %d: close_fds r %d w %d e %d c %d", c->self, c->rfd, c->wfd, c->efd,
         c->ctl_fd);
#line 347
  channel_close_fd(& c->sock);
#line 348
  channel_close_fd(& c->ctl_fd);
#line 349
  channel_close_fd(& c->rfd);
#line 350
  channel_close_fd(& c->wfd);
#line 351
  channel_close_fd(& c->efd);
#line 352
  return;
}
}
#line 356 "channels.c"
void channel_free(Channel *c ) 
{ char *s ;
  u_int i ;
  u_int n___0 ;
  char const   *tmp ;

  {
#line 362
  n___0 = 0U;
#line 362
  i = 0U;
#line 362
  while (i < channels_alloc) {
#line 363
    if (*(channels + i)) {
#line 364
      n___0 ++;
    }
#line 362
    i ++;
  }
#line 365
  if (c->remote_name) {
#line 365
    tmp = (char const   *)c->remote_name;
  } else {
#line 365
    tmp = "???";
  }
#line 365
  debug("channel %d: free: %s, nchannels %u", c->self, tmp, n___0);
#line 368
  s = channel_open_message();
#line 369
  debug3("channel %d: status: %s", c->self, s);
#line 370
  xfree((void *)s);
#line 372
  if (c->sock != -1) {
#line 373
    shutdown(c->sock, 2);
  }
#line 374
  if (c->ctl_fd != -1) {
#line 375
    shutdown(c->ctl_fd, 2);
  }
#line 376
  channel_close_fds(c);
#line 377
  buffer_free(& c->input);
#line 378
  buffer_free(& c->output);
#line 379
  buffer_free(& c->extended);
#line 380
  if (c->remote_name) {
#line 381
    xfree((void *)c->remote_name);
#line 382
    c->remote_name = (char *)((void *)0);
  }
#line 384
  *(channels + c->self) = (Channel *)((void *)0);
#line 385
  xfree((void *)c);
#line 386
  return;
}
}
#line 388 "channels.c"
void channel_free_all(void) 
{ u_int i ;

  {
#line 393
  i = 0U;
#line 393
  while (i < channels_alloc) {
#line 394
    if ((unsigned int )*(channels + i) != (unsigned int )((void *)0)) {
#line 395
      channel_free(*(channels + i));
    }
#line 393
    i ++;
  }
#line 396
  return;
}
}
#line 403 "channels.c"
void channel_close_all(void) 
{ u_int i ;

  {
#line 408
  i = 0U;
#line 408
  while (i < channels_alloc) {
#line 409
    if ((unsigned int )*(channels + i) != (unsigned int )((void *)0)) {
#line 410
      channel_close_fds(*(channels + i));
    }
#line 408
    i ++;
  }
#line 411
  return;
}
}
#line 417 "channels.c"
void channel_stop_listening(void) 
{ u_int i ;
  Channel *c ;

  {
#line 423
  i = 0U;
#line 423
  while (i < channels_alloc) {
#line 424
    c = *(channels + i);
#line 425
    if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 426
      switch (c->type) {
      case 6: 
      case 2: 
      case 11: 
      case 1: 
#line 431
      channel_close_fd(& c->sock);
#line 432
      channel_free(c);
#line 433
      break;
      }
    }
#line 423
    i ++;
  }
#line 437
  return;
}
}
#line 444 "channels.c"
int channel_not_very_much_buffered_data(void) 
{ u_int i ;
  Channel *c ;
  u_int tmp ;
  u_int tmp___0 ;

  {
#line 450
  i = 0U;
#line 450
  while (i < channels_alloc) {
#line 451
    c = *(channels + i);
#line 452
    if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 452
      if (c->type == 4) {
#line 461
        tmp___0 = buffer_len(& c->output);
#line 461
        if (tmp___0 > max_packet_size) {
#line 462
          tmp = buffer_len(& c->output);
#line 462
          debug2("channel %d: big output buffer %u > %u", c->self, tmp, max_packet_size);
#line 465
          return (0);
        }
      }
    }
#line 450
    i ++;
  }
#line 469
  return (1);
}
}
#line 474 "channels.c"
int channel_still_open(void) 
{ u_int i ;
  Channel *c ;

  {
#line 480
  i = 0U;
#line 480
  while (i < channels_alloc) {
#line 481
    c = *(channels + i);
#line 482
    if ((unsigned int )c == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 484
    switch (c->type) {
    case 1: 
    case 2: 
    case 11: 
    case 5: 
    case 6: 
    case 13: 
    case 12: 
    case 14: 
    goto __Cont;
    case 10: 
#line 495
    if (! compat20) {
#line 496
      fatal("cannot happen: SSH_CHANNEL_LARVAL");
    }
    goto __Cont;
    case 3: 
    case 4: 
    case 7: 
#line 501
    return (1);
    case 8: 
    case 9: 
#line 504
    if (! compat13) {
#line 505
      fatal("cannot happen: OUT_DRAIN");
    }
#line 506
    return (1);
    default: 
#line 508
    fatal("channel_still_open: bad channel type %d", c->type);
    }
    __Cont: /* CIL Label */ 
#line 480
    i ++;
  }
#line 512
  return (0);
}
}
#line 517 "channels.c"
int channel_find_open(void) 
{ u_int i ;
  Channel *c ;

  {
#line 523
  i = 0U;
#line 523
  while (i < channels_alloc) {
#line 524
    c = *(channels + i);
#line 525
    if ((unsigned int )c == (unsigned int )((void *)0)) {
      goto __Cont;
    } else {
#line 525
      if (c->remote_id < 0) {
        goto __Cont;
      }
    }
#line 527
    switch (c->type) {
    case 5: 
    case 13: 
    case 1: 
    case 2: 
    case 11: 
    case 3: 
    case 12: 
    case 14: 
    goto __Cont;
    case 10: 
    case 6: 
    case 4: 
    case 7: 
#line 541
    return ((int )i);
    case 8: 
    case 9: 
#line 544
    if (! compat13) {
#line 545
      fatal("cannot happen: OUT_DRAIN");
    }
#line 546
    return ((int )i);
    default: 
#line 548
    fatal("channel_find_open: bad channel type %d", c->type);
    }
    __Cont: /* CIL Label */ 
#line 523
    i ++;
  }
#line 552
  return (-1);
}
}
#line 562 "channels.c"
char *channel_open_message(void) 
{ Buffer buffer ;
  Channel *c ;
  char buf___1[1024] ;
  char *cp ;
  u_int i ;
  size_t tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
#line 570
  buffer_init(& buffer);
#line 571
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"The following connections are open:\r\n");
#line 572
  tmp = strlen((char const   *)(buf___1));
#line 572
  buffer_append(& buffer, (void const   *)(buf___1), tmp);
#line 573
  i = 0U;
#line 573
  while (i < channels_alloc) {
#line 574
    c = *(channels + i);
#line 575
    if ((unsigned int )c == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 577
    switch (c->type) {
    case 1: 
    case 2: 
    case 11: 
    case 5: 
    case 6: 
    case 14: 
    goto __Cont;
    case 10: 
    case 3: 
    case 12: 
    case 13: 
    case 4: 
    case 7: 
    case 8: 
    case 9: 
#line 593
    tmp___0 = buffer_len(& c->output);
#line 593
    tmp___1 = buffer_len(& c->input);
#line 593
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"  #%d %.300s (t%d r%d i%d/%d o%d/%d fd %d/%d cfd %d)\r\n",
             c->self, c->remote_name, c->type, c->remote_id, c->istate, tmp___1, c->ostate,
             tmp___0, c->rfd, c->wfd, c->ctl_fd);
#line 600
    tmp___2 = strlen((char const   *)(buf___1));
#line 600
    buffer_append(& buffer, (void const   *)(buf___1), tmp___2);
    goto __Cont;
    default: 
#line 603
    fatal("channel_open_message: bad channel type %d", c->type);
    }
    __Cont: /* CIL Label */ 
#line 573
    i ++;
  }
#line 607
  buffer_append(& buffer, (void const   *)"\000", 1U);
#line 608
  tmp___3 = buffer_ptr(& buffer);
#line 608
  cp = xstrdup((char const   *)tmp___3);
#line 609
  buffer_free(& buffer);
#line 610
  return (cp);
}
}
#line 613 "channels.c"
void channel_send_open(int id ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 616
  tmp = channel_lookup(id);
#line 616
  c = tmp;
#line 618
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 619
    logit("channel_send_open: %d: bad id", id);
#line 620
    return;
  }
#line 622
  debug2("channel %d: send open", id);
#line 623
  packet_start((unsigned char)90);
#line 624
  packet_put_cstring((char const   *)c->ctype);
#line 625
  packet_put_int((unsigned int )c->self);
#line 626
  packet_put_int(c->local_window);
#line 627
  packet_put_int(c->local_maxpacket);
#line 628
  packet_send();
#line 629
  return;
}
}
#line 631 "channels.c"
void channel_request_start(int id , char *service , int wantconfirm ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 634
  tmp = channel_lookup(id);
#line 634
  c = tmp;
#line 636
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 637
    logit("channel_request_start: %d: unknown channel id", id);
#line 638
    return;
  }
#line 640
  debug2("channel %d: request %s confirm %d", id, service, wantconfirm);
#line 641
  packet_start((unsigned char)98);
#line 642
  packet_put_int((unsigned int )c->remote_id);
#line 643
  packet_put_cstring((char const   *)service);
#line 644
  packet_put_char(wantconfirm);
#line 645
  return;
}
}
#line 646 "channels.c"
void channel_register_confirm(int id , channel_callback_fn *fn , void *ctx ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 649
  tmp = channel_lookup(id);
#line 649
  c = tmp;
#line 651
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 652
    logit("channel_register_comfirm: %d: bad id", id);
#line 653
    return;
  }
#line 655
  c->confirm = fn;
#line 656
  c->confirm_ctx = ctx;
#line 657
  return;
}
}
#line 658 "channels.c"
void channel_register_cleanup(int id , channel_callback_fn *fn , int do_close ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 661
  tmp = channel_by_id(id);
#line 661
  c = tmp;
#line 663
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 664
    logit("channel_register_cleanup: %d: bad id", id);
#line 665
    return;
  }
#line 667
  c->detach_user = fn;
#line 668
  c->detach_close = do_close;
#line 669
  return;
}
}
#line 670 "channels.c"
void channel_cancel_cleanup(int id ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 673
  tmp = channel_by_id(id);
#line 673
  c = tmp;
#line 675
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 676
    logit("channel_cancel_cleanup: %d: bad id", id);
#line 677
    return;
  }
#line 679
  c->detach_user = (channel_callback_fn *)((void *)0);
#line 680
  c->detach_close = 0;
#line 681
  return;
}
}
#line 682 "channels.c"
void channel_register_filter(int id , channel_infilter_fn *ifn , channel_outfilter_fn *ofn ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 686
  tmp = channel_lookup(id);
#line 686
  c = tmp;
#line 688
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 689
    logit("channel_register_filter: %d: bad id", id);
#line 690
    return;
  }
#line 692
  c->input_filter = ifn;
#line 693
  c->output_filter = ofn;
#line 694
  return;
}
}
#line 696 "channels.c"
void channel_set_fds(int id , int rfd , int wfd , int efd , int extusage , int nonblock ,
                     u_int window_max ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 700
  tmp = channel_lookup(id);
#line 700
  c = tmp;
#line 702
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 703
    fatal("channel_activate for non-larval channel %d.", id);
  } else {
#line 702
    if (c->type != 10) {
#line 703
      fatal("channel_activate for non-larval channel %d.", id);
    }
  }
#line 704
  channel_register_fds(c, rfd, wfd, efd, extusage, nonblock);
#line 705
  c->type = 4;
#line 706
  c->local_window_max = window_max;
#line 706
  c->local_window = c->local_window_max;
#line 707
  packet_start((unsigned char)93);
#line 708
  packet_put_int((unsigned int )c->remote_id);
#line 709
  packet_put_int(c->local_window);
#line 710
  packet_send();
#line 711
  return;
}
}
#line 722 "channels.c"
chan_fn *channel_pre[15]  ;
#line 723 "channels.c"
chan_fn *channel_post[15]  ;
#line 725 "channels.c"
static void channel_pre_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 728
  __asm__  volatile   ("btsl %1,%0": "=m" (readset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 729
  return;
}
}
#line 731 "channels.c"
static void channel_pre_connecting(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 734
  debug3("channel %d: waiting for connection", c->self);
#line 735
  __asm__  volatile   ("btsl %1,%0": "=m" (writeset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 736
  return;
}
}
#line 738 "channels.c"
static void channel_pre_open_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int tmp ;
  u_int tmp___0 ;

  {
#line 741
  tmp = buffer_len(& c->input);
#line 741
  if (tmp < max_packet_size) {
#line 742
    __asm__  volatile   ("btsl %1,%0": "=m" (readset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 743
  tmp___0 = buffer_len(& c->output);
#line 743
  if (tmp___0 > 0U) {
#line 744
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 745
  return;
}
}
#line 747 "channels.c"
static void channel_pre_open(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int limit ;
  u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;

  {
#line 750
  if (compat20) {
#line 750
    tmp = c->remote_window;
  } else {
#line 750
    tmp = max_packet_size;
  }
#line 750
  limit = tmp;
#line 753
  if (limit < 9420800U) {
#line 753
    limit = limit;
  } else {
#line 753
    limit = 9420800U;
  }
#line 755
  if (c->istate == 0U) {
#line 755
    if (limit > 0U) {
#line 755
      tmp___0 = buffer_len(& c->input);
#line 755
      if (tmp___0 < limit) {
#line 758
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->fds_bits[(unsigned int )c->rfd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->rfd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
  }
#line 759
  if (c->ostate == 0U) {
    goto _L;
  } else {
#line 759
    if (c->ostate == 1U) {
      _L: /* CIL Label */ 
#line 761
      tmp___3 = buffer_len(& c->output);
#line 761
      if (tmp___3 > 0U) {
#line 762
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->fds_bits[(unsigned int )c->wfd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->wfd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      } else {
#line 763
        if (c->ostate == 1U) {
#line 764
          if (compat20) {
#line 764
            if (c->extended_usage == 2) {
#line 764
              if (c->efd != -1) {
#line 764
                if (! (c->flags & 10)) {
#line 765
                  tmp___1 = buffer_len(& c->extended);
#line 765
                  debug2("channel %d: obuf_empty delayed efd %d/(%d)", c->self, c->efd,
                         tmp___1);
                } else {
#line 764
                  tmp___2 = buffer_len(& c->extended);
#line 764
                  if (tmp___2 > 0U) {
#line 765
                    tmp___1 = buffer_len(& c->extended);
#line 765
                    debug2("channel %d: obuf_empty delayed efd %d/(%d)", c->self,
                           c->efd, tmp___1);
                  } else {
#line 768
                    chan_obuf_empty(c);
                  }
                }
              } else {
#line 768
                chan_obuf_empty(c);
              }
            } else {
#line 768
              chan_obuf_empty(c);
            }
          } else {
#line 768
            chan_obuf_empty(c);
          }
        }
      }
    }
  }
#line 772
  if (compat20) {
#line 772
    if (c->efd != -1) {
#line 773
      if (c->extended_usage == 2) {
#line 773
        tmp___5 = buffer_len(& c->extended);
#line 773
        if (tmp___5 > 0U) {
#line 775
          __asm__  volatile   ("btsl %1,%0": "=m" (writeset->fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 776
        if (! (c->flags & 4)) {
#line 776
          if (c->extended_usage == 1) {
#line 776
            tmp___4 = buffer_len(& c->extended);
#line 776
            if (tmp___4 < c->remote_window) {
#line 779
              __asm__  volatile   ("btsl %1,%0": "=m" (readset->fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))): "cc",
                                   "memory");
            }
          }
        }
      }
    }
  }
#line 782
  if (compat20) {
#line 782
    if (c->ctl_fd != -1) {
#line 782
      if (c->istate == 0U) {
#line 782
        if (c->ostate == 0U) {
#line 784
          __asm__  volatile   ("btsl %1,%0": "=m" (readset->fds_bits[(unsigned int )c->ctl_fd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->ctl_fd % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        }
      }
    }
  }
#line 785
  return;
}
}
#line 787 "channels.c"
static void channel_pre_input_draining(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int tmp ;

  {
#line 790
  tmp = buffer_len(& c->input);
#line 790
  if (tmp == 0U) {
#line 791
    packet_start((unsigned char)24);
#line 792
    packet_put_int((unsigned int )c->remote_id);
#line 793
    packet_send();
#line 794
    c->type = 5;
#line 795
    debug2("channel %d: closing after input drain.", c->self);
  }
#line 797
  return;
}
}
#line 799 "channels.c"
static void channel_pre_output_draining(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int tmp ;

  {
#line 802
  tmp = buffer_len(& c->output);
#line 802
  if (tmp == 0U) {
#line 803
    chan_mark_dead(c);
  } else {
#line 805
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 806
  return;
}
}
#line 817 "channels.c"
static int x11_open_helper(Buffer *b ) 
{ u_char *ucp ;
  u_int proto_len ;
  u_int data_len ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 824
  tmp = buffer_len(b);
#line 824
  if (tmp < 12U) {
#line 825
    return (0);
  }
#line 828
  tmp___0 = buffer_ptr(b);
#line 828
  ucp = (u_char *)tmp___0;
#line 829
  if ((int )*(ucp + 0) == 66) {
#line 830
    proto_len = (unsigned int )(256 * (int )*(ucp + 6) + (int )*(ucp + 7));
#line 831
    data_len = (unsigned int )(256 * (int )*(ucp + 8) + (int )*(ucp + 9));
  } else {
#line 832
    if ((int )*(ucp + 0) == 108) {
#line 833
      proto_len = (unsigned int )((int )*(ucp + 6) + 256 * (int )*(ucp + 7));
#line 834
      data_len = (unsigned int )((int )*(ucp + 8) + 256 * (int )*(ucp + 9));
    } else {
#line 836
      debug2("Initial X11 packet contains bad byte order byte: 0x%x", *(ucp + 0));
#line 838
      return (-1);
    }
  }
#line 842
  tmp___1 = buffer_len(b);
#line 842
  if (tmp___1 < (12U + ((proto_len + 3U) & 4294967292U)) + ((data_len + 3U) & 4294967292U)) {
#line 844
    return (0);
  }
#line 847
  tmp___2 = strlen((char const   *)x11_saved_proto);
#line 847
  if (proto_len != tmp___2) {
#line 849
    debug2("X11 connection uses different authentication protocol.");
#line 850
    return (-1);
  } else {
#line 847
    tmp___3 = memcmp((void const   *)(ucp + 12), (void const   *)x11_saved_proto,
                     proto_len);
#line 847
    if (tmp___3 != 0) {
#line 849
      debug2("X11 connection uses different authentication protocol.");
#line 850
      return (-1);
    }
  }
#line 853
  if (data_len != x11_fake_data_len) {
#line 856
    debug2("X11 auth data does not match fake data.");
#line 857
    return (-1);
  } else {
#line 853
    tmp___4 = memcmp((void const   *)((ucp + 12) + ((proto_len + 3U) & 4294967292U)),
                     (void const   *)x11_fake_data, x11_fake_data_len);
#line 853
    if (tmp___4 != 0) {
#line 856
      debug2("X11 auth data does not match fake data.");
#line 857
      return (-1);
    }
  }
#line 860
  if (x11_fake_data_len != x11_saved_data_len) {
#line 861
    error("X11 fake_data_len %d != saved_data_len %d", x11_fake_data_len, x11_saved_data_len);
#line 863
    return (-1);
  }
#line 870
  memcpy((void * __restrict  )((ucp + 12) + ((proto_len + 3U) & 4294967292U)), (void const   * __restrict  )x11_saved_data,
         x11_saved_data_len);
#line 872
  return (1);
}
}
#line 875 "channels.c"
static void channel_pre_x11_open_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int ret ;
  int tmp ;

  {
#line 878
  tmp = x11_open_helper(& c->output);
#line 878
  ret = tmp;
#line 880
  if (ret == 1) {
#line 882
    c->type = 4;
#line 883
    channel_pre_open_13(c, readset, writeset);
  } else {
#line 884
    if (ret == -1) {
#line 889
      logit("X11 connection rejected because of wrong authentication.");
#line 890
      buffer_clear(& c->input);
#line 891
      buffer_clear(& c->output);
#line 892
      channel_close_fd(& c->sock);
#line 893
      c->sock = -1;
#line 894
      c->type = 5;
#line 895
      packet_start((unsigned char)24);
#line 896
      packet_put_int((unsigned int )c->remote_id);
#line 897
      packet_send();
    }
  }
#line 899
  return;
}
}
#line 901 "channels.c"
static void channel_pre_x11_open(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int ret ;
  int tmp ;

  {
#line 904
  tmp = x11_open_helper(& c->output);
#line 904
  ret = tmp;
#line 908
  if (ret == 1) {
#line 909
    c->type = 4;
#line 910
    channel_pre_open(c, readset, writeset);
  } else {
#line 911
    if (ret == -1) {
#line 912
      logit("X11 connection rejected because of wrong authentication.");
#line 913
      debug2("X11 rejected %d i%d/o%d", c->self, c->istate, c->ostate);
#line 914
      chan_read_failed(c);
#line 915
      buffer_clear(& c->input);
#line 916
      chan_ibuf_empty(c);
#line 917
      buffer_clear(& c->output);
#line 919
      if (compat20) {
#line 920
        chan_write_failed(c);
      } else {
#line 922
        c->type = 4;
      }
#line 923
      debug2("X11 closed %d i%d/o%d", c->self, c->istate, c->ostate);
    }
  }
#line 925
  return;
}
}
#line 928 "channels.c"
static int channel_decode_socks4(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char *p ;
  char *host ;
  u_int len ;
  u_int have ;
  u_int i ;
  u_int found ;
  char username[256] ;
  struct __anonstruct_s4_req_82 s4_req ;
  struct __anonstruct_s4_req_82 s4_rsp ;
  void *tmp ;
  void *tmp___0 ;
  register unsigned short __v ;
  register unsigned short __x ;

  {
#line 941
  debug2("channel %d: decode socks4", c->self);
#line 943
  have = buffer_len(& c->input);
#line 944
  len = sizeof(s4_req);
#line 945
  if (have < len) {
#line 946
    return (0);
  }
#line 947
  tmp = buffer_ptr(& c->input);
#line 947
  p = (char *)tmp;
#line 948
  found = 0U;
#line 948
  i = len;
#line 948
  while (i < have) {
#line 949
    if ((int )*(p + i) == 0) {
#line 950
      found = 1U;
#line 951
      break;
    }
#line 953
    if (i > 1024U) {
#line 955
      debug("channel %d: decode socks4: too long", c->self);
#line 957
      return (-1);
    }
#line 948
    i ++;
  }
#line 960
  if (! found) {
#line 961
    return (0);
  }
#line 962
  buffer_get(& c->input, (void *)((char *)(& s4_req.version)), 1U);
#line 963
  buffer_get(& c->input, (void *)((char *)(& s4_req.command)), 1U);
#line 964
  buffer_get(& c->input, (void *)((char *)(& s4_req.dest_port)), 2U);
#line 965
  buffer_get(& c->input, (void *)((char *)(& s4_req.dest_addr)), 4U);
#line 966
  have = buffer_len(& c->input);
#line 967
  tmp___0 = buffer_ptr(& c->input);
#line 967
  p = (char *)tmp___0;
#line 968
  len = strlen((char const   *)p);
#line 969
  debug2("channel %d: decode socks4: user %s/%d", c->self, p, len);
#line 970
  if (len > have) {
#line 971
    fatal("channel %d: decode socks4: len %d > have %d", c->self, len, have);
  }
#line 973
  strlcpy(username, (char const   *)p, sizeof(username));
#line 974
  buffer_consume(& c->input, len);
#line 975
  buffer_consume(& c->input, 1U);
#line 977
  host = inet_ntoa(s4_req.dest_addr);
#line 978
  strlcpy(c->path, (char const   *)host, sizeof(c->path));
#line 979
  __x = s4_req.dest_port;
#line 979
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 979
  c->host_port = (int )__v;
#line 981
  debug2("channel %d: dynamic request: socks4 host %s port %u command %u", c->self,
         host, c->host_port, s4_req.command);
#line 984
  if ((int )s4_req.command != 1) {
#line 985
    debug("channel %d: cannot handle: socks4 cn %d", c->self, s4_req.command);
#line 987
    return (-1);
  }
#line 989
  s4_rsp.version = (unsigned char)0;
#line 990
  s4_rsp.command = (unsigned char)90;
#line 991
  s4_rsp.dest_port = (unsigned short)0;
#line 992
  s4_rsp.dest_addr.s_addr = 0U;
#line 993
  buffer_append(& c->output, (void const   *)((char *)(& s4_rsp)), sizeof(s4_rsp));
#line 994
  return (1);
}
}
#line 1006 "channels.c"
static int channel_decode_socks5(Channel *c , fd_set *readset , fd_set *writeset ) 
{ struct __anonstruct_s5_req_83 s5_req ;
  struct __anonstruct_s5_req_83 s5_rsp ;
  u_int16_t dest_port ;
  u_char *p ;
  u_char dest_addr[256] ;
  u_int have ;
  u_int i ;
  u_int found ;
  u_int nmethods ;
  u_int addrlen ;
  u_int af ;
  void *tmp ;
  char const   *tmp___0 ;
  register unsigned short __v ;
  register unsigned short __x ;

  {
#line 1019
  debug2("channel %d: decode socks5", c->self);
#line 1020
  tmp = buffer_ptr(& c->input);
#line 1020
  p = (u_char *)tmp;
#line 1021
  if ((int )*(p + 0) != 5) {
#line 1022
    return (-1);
  }
#line 1023
  have = buffer_len(& c->input);
#line 1024
  if (! (c->flags & 4096)) {
#line 1026
    if (have < 2U) {
#line 1027
      return (0);
    }
#line 1028
    nmethods = (unsigned int )*(p + 1);
#line 1029
    if (have < nmethods + 2U) {
#line 1030
      return (0);
    }
#line 1032
    found = 0U;
#line 1032
    i = 2U;
#line 1032
    while (i < nmethods + 2U) {
#line 1033
      if ((int )*(p + i) == 0) {
#line 1034
        found = 1U;
#line 1035
        break;
      }
#line 1032
      i ++;
    }
#line 1038
    if (! found) {
#line 1039
      debug("channel %d: method SSH_SOCKS5_NOAUTH not found", c->self);
#line 1041
      return (-1);
    }
#line 1043
    buffer_consume(& c->input, nmethods + 2U);
#line 1044
    buffer_put_char(& c->output, 5);
#line 1045
    buffer_put_char(& c->output, 0);
#line 1046
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 1047
    c->flags |= 4096;
#line 1048
    debug2("channel %d: socks5 auth done", c->self);
#line 1049
    return (0);
  }
#line 1051
  debug2("channel %d: socks5 post auth", c->self);
#line 1052
  if (have < sizeof(s5_req) + 1U) {
#line 1053
    return (0);
  }
#line 1054
  memcpy((void * __restrict  )((char *)(& s5_req)), (void const   * __restrict  )p,
         sizeof(s5_req));
#line 1055
  if ((int )s5_req.version != 5) {
#line 1058
    debug2("channel %d: only socks5 connect supported", c->self);
#line 1059
    return (-1);
  } else {
#line 1055
    if ((int )s5_req.command != 1) {
#line 1058
      debug2("channel %d: only socks5 connect supported", c->self);
#line 1059
      return (-1);
    } else {
#line 1055
      if ((int )s5_req.reserved != 0) {
#line 1058
        debug2("channel %d: only socks5 connect supported", c->self);
#line 1059
        return (-1);
      }
    }
  }
#line 1061
  switch ((int )s5_req.atyp) {
  case 1: 
#line 1063
  addrlen = 4U;
#line 1064
  af = 2U;
#line 1065
  break;
  case 3: 
#line 1067
  addrlen = (unsigned int )*(p + sizeof(s5_req));
#line 1068
  af = 4294967295U;
#line 1069
  break;
  case 4: 
#line 1071
  addrlen = 16U;
#line 1072
  af = 10U;
#line 1073
  break;
  default: 
#line 1075
  debug2("channel %d: bad socks5 atyp %d", c->self, s5_req.atyp);
#line 1076
  return (-1);
  }
#line 1078
  if (have < (4U + addrlen) + 2U) {
#line 1079
    return (0);
  }
#line 1080
  buffer_consume(& c->input, sizeof(s5_req));
#line 1081
  if ((int )s5_req.atyp == 3) {
#line 1082
    buffer_consume(& c->input, 1U);
  }
#line 1083
  buffer_get(& c->input, (void *)((char *)(& dest_addr)), addrlen);
#line 1084
  buffer_get(& c->input, (void *)((char *)(& dest_port)), 2U);
#line 1085
  dest_addr[addrlen] = (unsigned char )'\000';
#line 1086
  if ((int )s5_req.atyp == 3) {
#line 1087
    strlcpy(c->path, (char const   *)((char *)(dest_addr)), sizeof(c->path));
  } else {
#line 1088
    tmp___0 = inet_ntop((int )af, (void const   * __restrict  )(dest_addr), (char * __restrict  )(c->path),
                        sizeof(c->path));
#line 1088
    if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
#line 1089
      return (-1);
    }
  }
#line 1090
  __x = dest_port;
#line 1090
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 1090
  c->host_port = (int )__v;
#line 1092
  debug2("channel %d: dynamic request: socks5 host %s port %u command %u", c->self,
         c->path, c->host_port, s5_req.command);
#line 1095
  s5_rsp.version = (unsigned char)5;
#line 1096
  s5_rsp.command = (unsigned char)0;
#line 1097
  s5_rsp.reserved = (unsigned char)0;
#line 1098
  s5_rsp.atyp = (unsigned char)1;
#line 1099
  ((struct in_addr *)(& dest_addr))->s_addr = 0U;
#line 1100
  dest_port = (unsigned short)0;
#line 1102
  buffer_append(& c->output, (void const   *)((char *)(& s5_rsp)), sizeof(s5_rsp));
#line 1103
  buffer_append(& c->output, (void const   *)((char *)(& dest_addr)), sizeof(struct in_addr ));
#line 1104
  buffer_append(& c->output, (void const   *)((char *)(& dest_port)), sizeof(dest_port));
#line 1105
  return (1);
}
}
#line 1109 "channels.c"
static void channel_pre_dynamic(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_char *p ;
  u_int have ;
  int ret ;
  void *tmp ;

  {
#line 1116
  have = buffer_len(& c->input);
#line 1117
  c->delayed = 0;
#line 1118
  debug2("channel %d: pre_dynamic: have %d", c->self, have);
#line 1121
  if (have < 3U) {
#line 1123
    __asm__  volatile   ("btsl %1,%0": "=m" (readset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 1124
    return;
  }
#line 1127
  tmp = buffer_ptr(& c->input);
#line 1127
  p = (u_char *)tmp;
#line 1128
  switch ((int )*(p + 0)) {
  case 4: 
#line 1130
  ret = channel_decode_socks4(c, readset, writeset);
#line 1131
  break;
  case 5: 
#line 1133
  ret = channel_decode_socks5(c, readset, writeset);
#line 1134
  break;
  default: 
#line 1136
  ret = -1;
#line 1137
  break;
  }
#line 1139
  if (ret < 0) {
#line 1140
    chan_mark_dead(c);
  } else {
#line 1141
    if (ret == 0) {
#line 1142
      debug2("channel %d: pre_dynamic: need more", c->self);
#line 1144
      __asm__  volatile   ("btsl %1,%0": "=m" (readset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    } else {
#line 1147
      c->type = 3;
#line 1148
      port_open_helper(c, (char *)"direct-tcpip");
    }
  }
#line 1150
  return;
}
}
#line 1153 "channels.c"
static void channel_post_x11_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ Channel *nc ;
  struct sockaddr addr ;
  int newsock ;
  socklen_t addrlen ;
  char buf___1[16384] ;
  char *remote_ipaddr ;
  int remote_port ;
  int *tmp ;
  char *tmp___0 ;
  u_int tmp___1 ;
  register char __result ;

  {
#line 1163
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 1163
  if (__result) {
#line 1164
    debug("X11 connection requested.");
#line 1165
    addrlen = sizeof(addr);
#line 1166
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 1167
    if (c->single_connection) {
#line 1168
      debug2("single_connection: closing X11 listener.");
#line 1169
      channel_close_fd(& c->sock);
#line 1170
      chan_mark_dead(c);
    }
#line 1172
    if (newsock < 0) {
#line 1173
      tmp = __errno_location();
#line 1173
      tmp___0 = strerror(*tmp);
#line 1173
      error("accept: %.100s", tmp___0);
#line 1174
      return;
    }
#line 1176
    set_nodelay(newsock);
#line 1177
    remote_ipaddr = get_peer_ipaddr(newsock);
#line 1178
    remote_port = get_peer_port(newsock);
#line 1179
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"X11 connection from %.200s port %d",
             remote_ipaddr, remote_port);
#line 1182
    nc = channel_new((char *)"accepted x11 socket", 3, newsock, newsock, -1, c->local_window_max,
                     c->local_maxpacket, 0, buf___1, 1);
#line 1185
    if (compat20) {
#line 1186
      packet_start((unsigned char)90);
#line 1187
      packet_put_cstring("x11");
#line 1188
      packet_put_int((unsigned int )nc->self);
#line 1189
      packet_put_int(nc->local_window_max);
#line 1190
      packet_put_int(nc->local_maxpacket);
#line 1192
      packet_put_cstring((char const   *)remote_ipaddr);
#line 1193
      if (datafellows & 8) {
#line 1194
        debug2("ssh2 x11 bug compat mode");
      } else {
#line 1196
        packet_put_int((unsigned int )remote_port);
      }
#line 1198
      packet_send();
    } else {
#line 1200
      packet_start((unsigned char)27);
#line 1201
      packet_put_int((unsigned int )nc->self);
#line 1202
      tmp___1 = packet_get_protocol_flags();
#line 1202
      if (tmp___1 & 2U) {
#line 1204
        packet_put_cstring((char const   *)(buf___1));
      }
#line 1205
      packet_send();
    }
#line 1207
    xfree((void *)remote_ipaddr);
  }
#line 1209
  return;
}
}
#line 1211 "channels.c"
static void port_open_helper(Channel *c , char *rtype ) 
{ int direct ;
  char buf___1[1024] ;
  char *remote_ipaddr ;
  char *tmp ;
  int remote_port ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  u_int tmp___11 ;

  {
#line 1216
  tmp = get_peer_ipaddr(c->sock);
#line 1216
  remote_ipaddr = tmp;
#line 1217
  tmp___0 = get_peer_port(c->sock);
#line 1217
  remote_port = tmp___0;
#line 1219
  if (0) {
#line 1219
    __s1_len = strlen((char const   *)rtype);
#line 1219
    __s2_len = strlen("direct-tcpip");
#line 1219
    if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
      goto _L___0;
    } else {
#line 1219
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1219
        if (! ((unsigned int )((void const   *)("direct-tcpip" + 1)) - (unsigned int )((void const   *)"direct-tcpip") == 1U)) {
#line 1219
          tmp___10 = 1;
        } else {
#line 1219
          if (__s2_len >= 4U) {
#line 1219
            tmp___10 = 1;
          } else {
#line 1219
            tmp___10 = 0;
          }
        }
      } else {
#line 1219
        tmp___10 = 0;
      }
    }
#line 1219
    if (tmp___10) {
#line 1219
      tmp___6 = __builtin_strcmp((char const   *)rtype, "direct-tcpip");
    } else {
#line 1219
      tmp___9 = __builtin_strcmp((char const   *)rtype, "direct-tcpip");
#line 1219
      tmp___6 = tmp___9;
    }
  } else {
#line 1219
    tmp___9 = __builtin_strcmp((char const   *)rtype, "direct-tcpip");
#line 1219
    tmp___6 = tmp___9;
  }
#line 1219
  direct = tmp___6 == 0;
#line 1221
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%s: listening port %d for %.100s port %d, connect from %.200s port %d",
           rtype, c->listening_port, c->path, c->host_port, remote_ipaddr, remote_port);
#line 1227
  xfree((void *)c->remote_name);
#line 1228
  c->remote_name = xstrdup((char const   *)(buf___1));
#line 1230
  if (compat20) {
#line 1231
    packet_start((unsigned char)90);
#line 1232
    packet_put_cstring((char const   *)rtype);
#line 1233
    packet_put_int((unsigned int )c->self);
#line 1234
    packet_put_int(c->local_window_max);
#line 1235
    packet_put_int(c->local_maxpacket);
#line 1236
    if (direct) {
#line 1238
      packet_put_cstring((char const   *)(c->path));
#line 1239
      packet_put_int((unsigned int )c->host_port);
    } else {
#line 1242
      packet_put_cstring((char const   *)(c->path));
#line 1243
      packet_put_int((unsigned int )c->listening_port);
    }
#line 1246
    packet_put_cstring((char const   *)remote_ipaddr);
#line 1247
    packet_put_int((unsigned int )remote_port);
#line 1248
    packet_send();
  } else {
#line 1250
    packet_start((unsigned char)29);
#line 1251
    packet_put_int((unsigned int )c->self);
#line 1252
    packet_put_cstring((char const   *)(c->path));
#line 1253
    packet_put_int((unsigned int )c->host_port);
#line 1254
    tmp___11 = packet_get_protocol_flags();
#line 1254
    if (tmp___11 & 2U) {
#line 1256
      packet_put_cstring((char const   *)c->remote_name);
    }
#line 1257
    packet_send();
  }
#line 1259
  xfree((void *)remote_ipaddr);
#line 1260
  return;
}
}
#line 1262 "channels.c"
static void channel_set_reuseaddr(int fd ) 
{ int on ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1265
  on = 1;
#line 1271
  tmp___1 = setsockopt(fd, 1, 2, (void const   *)(& on), sizeof(on));
#line 1271
  if (tmp___1 == -1) {
#line 1272
    tmp = __errno_location();
#line 1272
    tmp___0 = strerror(*tmp);
#line 1272
    error("setsockopt SO_REUSEADDR fd %d: %s", fd, tmp___0);
  }
#line 1273
  return;
}
}
#line 1278 "channels.c"
static void channel_post_port_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ Channel *nc ;
  struct sockaddr addr ;
  int newsock ;
  int nextstate ;
  socklen_t addrlen ;
  char *rtype ;
  int *tmp ;
  char *tmp___0 ;
  register char __result ;

  {
#line 1287
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 1287
  if (__result) {
#line 1288
    debug("Connection to port %d forwarding to %.100s port %d requested.", c->listening_port,
          c->path, c->host_port);
#line 1292
    if (c->type == 11) {
#line 1293
      nextstate = 3;
#line 1294
      rtype = (char *)"forwarded-tcpip";
    } else {
#line 1296
      if (c->host_port == 0) {
#line 1297
        nextstate = 13;
#line 1298
        rtype = (char *)"dynamic-tcpip";
      } else {
#line 1300
        nextstate = 3;
#line 1301
        rtype = (char *)"direct-tcpip";
      }
    }
#line 1305
    addrlen = sizeof(addr);
#line 1306
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 1307
    if (newsock < 0) {
#line 1308
      tmp = __errno_location();
#line 1308
      tmp___0 = strerror(*tmp);
#line 1308
      error("accept: %.100s", tmp___0);
#line 1309
      return;
    }
#line 1311
    set_nodelay(newsock);
#line 1312
    nc = channel_new(rtype, nextstate, newsock, newsock, -1, c->local_window_max,
                     c->local_maxpacket, 0, rtype, 1);
#line 1314
    nc->listening_port = c->listening_port;
#line 1315
    nc->host_port = c->host_port;
#line 1316
    strlcpy(nc->path, (char const   *)(c->path), sizeof(nc->path));
#line 1318
    if (nextstate == 13) {
#line 1324
      nc->delayed = 1;
    } else {
#line 1326
      port_open_helper(nc, rtype);
    }
  }
#line 1329
  return;
}
}
#line 1335 "channels.c"
static void channel_post_auth_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ Channel *nc ;
  int newsock ;
  struct sockaddr addr ;
  socklen_t addrlen ;
  int *tmp ;
  char *tmp___0 ;
  register char __result ;

  {
#line 1343
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 1343
  if (__result) {
#line 1344
    addrlen = sizeof(addr);
#line 1345
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 1346
    if (newsock < 0) {
#line 1347
      tmp = __errno_location();
#line 1347
      tmp___0 = strerror(*tmp);
#line 1347
      error("accept from auth socket: %.100s", tmp___0);
#line 1348
      return;
    }
#line 1350
    nc = channel_new((char *)"accepted auth socket", 3, newsock, newsock, -1, c->local_window_max,
                     c->local_maxpacket, 0, (char *)"accepted auth socket", 1);
#line 1354
    if (compat20) {
#line 1355
      packet_start((unsigned char)90);
#line 1356
      packet_put_cstring("auth-agent@openssh.com");
#line 1357
      packet_put_int((unsigned int )nc->self);
#line 1358
      packet_put_int(c->local_window_max);
#line 1359
      packet_put_int(c->local_maxpacket);
    } else {
#line 1361
      packet_start((unsigned char)31);
#line 1362
      packet_put_int((unsigned int )nc->self);
    }
#line 1364
    packet_send();
  }
#line 1366
  return;
}
}
#line 1368 "channels.c"
static void channel_post_connecting(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int err ;
  socklen_t sz ;
  int *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  register char __result ;

  {
#line 1371
  err = 0;
#line 1372
  sz = sizeof(err);
#line 1374
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 1374
  if (__result) {
#line 1375
    tmp___0 = getsockopt(c->sock, 1, 4, (void * __restrict  )(& err), (socklen_t * __restrict  )(& sz));
#line 1375
    if (tmp___0 < 0) {
#line 1376
      tmp = __errno_location();
#line 1376
      err = *tmp;
#line 1377
      error("getsockopt SO_ERROR failed");
    }
#line 1379
    if (err == 0) {
#line 1380
      debug("channel %d: connected", c->self);
#line 1381
      c->type = 4;
#line 1382
      if (compat20) {
#line 1383
        packet_start((unsigned char)91);
#line 1384
        packet_put_int((unsigned int )c->remote_id);
#line 1385
        packet_put_int((unsigned int )c->self);
#line 1386
        packet_put_int(c->local_window);
#line 1387
        packet_put_int(c->local_maxpacket);
      } else {
#line 1389
        packet_start((unsigned char)21);
#line 1390
        packet_put_int((unsigned int )c->remote_id);
#line 1391
        packet_put_int((unsigned int )c->self);
      }
    } else {
#line 1394
      tmp___1 = strerror(err);
#line 1394
      debug("channel %d: not connected: %s", c->self, tmp___1);
#line 1396
      if (compat20) {
#line 1397
        packet_start((unsigned char)92);
#line 1398
        packet_put_int((unsigned int )c->remote_id);
#line 1399
        packet_put_int(2U);
#line 1400
        if (! (datafellows & 131072)) {
#line 1401
          tmp___2 = strerror(err);
#line 1401
          packet_put_cstring((char const   *)tmp___2);
#line 1402
          packet_put_cstring("");
        }
      } else {
#line 1405
        packet_start((unsigned char)22);
#line 1406
        packet_put_int((unsigned int )c->remote_id);
      }
#line 1408
      chan_mark_dead(c);
    }
#line 1410
    packet_send();
  }
#line 1412
  return;
}
}
#line 1414 "channels.c"
static int channel_handle_rfd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char buf___1[16384] ;
  int len ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  register char __result ;

  {
#line 1421
  if (c->rfd != -1) {
#line 1421
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->rfd % (8U * sizeof(__fd_mask ))),
                         "m" (readset->fds_bits[(unsigned int )c->rfd / (8U * sizeof(__fd_mask ))]): "cc");
#line 1421
    if (__result) {
#line 1422
      len = read(c->rfd, (void *)(buf___1), sizeof(buf___1));
#line 1423
      if (len < 0) {
#line 1423
        tmp = __errno_location();
#line 1423
        if (*tmp == 4) {
#line 1424
          return (1);
        } else {
#line 1423
          tmp___0 = __errno_location();
#line 1423
          if (*tmp___0 == 11) {
#line 1424
            return (1);
          }
        }
      }
#line 1425
      if (len <= 0) {
#line 1426
        debug2("channel %d: read<=0 rfd %d len %d", c->self, c->rfd, len);
#line 1428
        if (c->type != 4) {
#line 1429
          debug2("channel %d: not open", c->self);
#line 1430
          chan_mark_dead(c);
#line 1431
          return (-1);
        } else {
#line 1432
          if (compat13) {
#line 1433
            buffer_clear(& c->output);
#line 1434
            c->type = 8;
#line 1435
            debug2("channel %d: input draining.", c->self);
          } else {
#line 1437
            chan_read_failed(c);
          }
        }
#line 1439
        return (-1);
      }
#line 1441
      if ((unsigned int )c->input_filter != (unsigned int )((void *)0)) {
#line 1442
        tmp___1 = (*(c->input_filter))(c, buf___1, len);
#line 1442
        if (tmp___1 == -1) {
#line 1443
          debug2("channel %d: filter stops", c->self);
#line 1444
          chan_read_failed(c);
        }
      } else {
#line 1446
        if (c->datagram) {
#line 1447
          buffer_put_string(& c->input, (void const   *)(buf___1), (unsigned int )len);
        } else {
#line 1449
          buffer_append(& c->input, (void const   *)(buf___1), (unsigned int )len);
        }
      }
    }
  }
#line 1452
  return (1);
}
}
#line 1454 "channels.c"
static int channel_handle_wfd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ struct termios tio ;
  u_char *data ;
  u_char *buf___1 ;
  u_int dlen ;
  int len ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  register char __result ;
  u_int tmp___6 ;

  {
#line 1458
  data = (u_char *)((void *)0);
#line 1464
  if (c->wfd != -1) {
#line 1464
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->wfd % (8U * sizeof(__fd_mask ))),
                         "m" (writeset->fds_bits[(unsigned int )c->wfd / (8U * sizeof(__fd_mask ))]): "cc");
#line 1464
    if (__result) {
#line 1464
      tmp___6 = buffer_len(& c->output);
#line 1464
      if (tmp___6 > 0U) {
#line 1466
        if ((unsigned int )c->output_filter != (unsigned int )((void *)0)) {
#line 1467
          buf___1 = (*(c->output_filter))(c, & data, & dlen);
#line 1467
          if ((unsigned int )buf___1 == (unsigned int )((void *)0)) {
#line 1468
            debug2("channel %d: filter stops", c->self);
#line 1469
            if (c->type != 4) {
#line 1470
              chan_mark_dead(c);
            } else {
#line 1472
              chan_write_failed(c);
            }
#line 1473
            return (-1);
          }
        } else {
#line 1475
          if (c->datagram) {
#line 1476
            tmp = buffer_get_string(& c->output, & dlen);
#line 1476
            data = (u_char *)tmp;
#line 1476
            buf___1 = data;
          } else {
#line 1478
            tmp___0 = buffer_ptr(& c->output);
#line 1478
            data = (u_char *)tmp___0;
#line 1478
            buf___1 = data;
#line 1479
            dlen = buffer_len(& c->output);
          }
        }
#line 1482
        if (c->datagram) {
#line 1484
          c->local_consumed += dlen + 4U;
#line 1485
          len = write(c->wfd, (void const   *)buf___1, dlen);
#line 1486
          xfree((void *)data);
#line 1487
          if (len < 0) {
#line 1487
            tmp___1 = __errno_location();
#line 1487
            if (*tmp___1 == 4) {
#line 1488
              return (1);
            } else {
#line 1487
              tmp___2 = __errno_location();
#line 1487
              if (*tmp___2 == 11) {
#line 1488
                return (1);
              }
            }
          }
#line 1489
          if (len <= 0) {
#line 1490
            if (c->type != 4) {
#line 1491
              chan_mark_dead(c);
            } else {
#line 1493
              chan_write_failed(c);
            }
#line 1494
            return (-1);
          }
#line 1496
          return (1);
        }
#line 1504
        len = write(c->wfd, (void const   *)buf___1, dlen);
#line 1505
        if (len < 0) {
#line 1505
          tmp___3 = __errno_location();
#line 1505
          if (*tmp___3 == 4) {
#line 1506
            return (1);
          } else {
#line 1505
            tmp___4 = __errno_location();
#line 1505
            if (*tmp___4 == 11) {
#line 1506
              return (1);
            }
          }
        }
#line 1507
        if (len <= 0) {
#line 1508
          if (c->type != 4) {
#line 1509
            debug2("channel %d: not open", c->self);
#line 1510
            chan_mark_dead(c);
#line 1511
            return (-1);
          } else {
#line 1512
            if (compat13) {
#line 1513
              buffer_clear(& c->output);
#line 1514
              debug2("channel %d: input draining.", c->self);
#line 1515
              c->type = 8;
            } else {
#line 1517
              chan_write_failed(c);
            }
          }
#line 1519
          return (-1);
        }
#line 1521
        if (compat20) {
#line 1521
          if (c->isatty) {
#line 1521
            if (dlen >= 1U) {
#line 1521
              if ((int )*(buf___1 + 0) != 13) {
#line 1522
                tmp___5 = tcgetattr(c->wfd, & tio);
#line 1522
                if (tmp___5 == 0) {
#line 1522
                  if (! (tio.c_lflag & 8U)) {
#line 1522
                    if (tio.c_lflag & 2U) {
#line 1530
                      packet_send_ignore(4 + len);
#line 1531
                      packet_send();
                    }
                  }
                }
              }
            }
          }
        }
#line 1534
        buffer_consume(& c->output, (unsigned int )len);
#line 1535
        if (compat20) {
#line 1535
          if (len > 0) {
#line 1536
            c->local_consumed += (u_int )len;
          }
        }
      }
    }
  }
#line 1539
  return (1);
}
}
#line 1541 "channels.c"
static int channel_handle_efd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char buf___1[16384] ;
  int len ;
  u_int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  register char __result ;
  register char __result___0 ;
  u_int tmp___5 ;

  {
#line 1548
  if (c->efd != -1) {
#line 1550
    if (c->extended_usage == 2) {
#line 1550
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))),
                           "m" (writeset->fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "cc");
#line 1550
      if (__result___0) {
#line 1550
        tmp___5 = buffer_len(& c->extended);
#line 1550
        if (tmp___5 > 0U) {
#line 1552
          tmp = buffer_len(& c->extended);
#line 1552
          tmp___0 = buffer_ptr(& c->extended);
#line 1552
          len = write(c->efd, (void const   *)tmp___0, tmp);
#line 1554
          debug2("channel %d: written %d to efd %d", c->self, len, c->efd);
#line 1556
          if (len < 0) {
#line 1556
            tmp___1 = __errno_location();
#line 1556
            if (*tmp___1 == 4) {
#line 1557
              return (1);
            } else {
#line 1556
              tmp___2 = __errno_location();
#line 1556
              if (*tmp___2 == 11) {
#line 1557
                return (1);
              }
            }
          }
#line 1558
          if (len <= 0) {
#line 1559
            debug2("channel %d: closing write-efd %d", c->self, c->efd);
#line 1561
            channel_close_fd(& c->efd);
          } else {
#line 1563
            buffer_consume(& c->extended, (unsigned int )len);
#line 1564
            c->local_consumed += (u_int )len;
          }
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 1567
      if (c->extended_usage == 1) {
#line 1567
        __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))),
                             "m" (readset->fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "cc");
#line 1567
        if (__result) {
#line 1568
          len = read(c->efd, (void *)(buf___1), sizeof(buf___1));
#line 1569
          debug2("channel %d: read %d from efd %d", c->self, len, c->efd);
#line 1571
          if (len < 0) {
#line 1571
            tmp___3 = __errno_location();
#line 1571
            if (*tmp___3 == 4) {
#line 1572
              return (1);
            } else {
#line 1571
              tmp___4 = __errno_location();
#line 1571
              if (*tmp___4 == 11) {
#line 1572
                return (1);
              }
            }
          }
#line 1573
          if (len <= 0) {
#line 1574
            debug2("channel %d: closing read-efd %d", c->self, c->efd);
#line 1576
            channel_close_fd(& c->efd);
          } else {
#line 1578
            buffer_append(& c->extended, (void const   *)(buf___1), (unsigned int )len);
          }
        }
      }
    }
  }
#line 1582
  return (1);
}
}
#line 1584 "channels.c"
static int channel_handle_ctl(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char buf___1[16] ;
  int len ;
  int *tmp ;
  int *tmp___0 ;
  register char __result ;

  {
#line 1591
  if (c->ctl_fd != -1) {
#line 1591
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->ctl_fd % (8U * sizeof(__fd_mask ))),
                         "m" (readset->fds_bits[(unsigned int )c->ctl_fd / (8U * sizeof(__fd_mask ))]): "cc");
#line 1591
    if (__result) {
#line 1592
      len = read(c->ctl_fd, (void *)(buf___1), sizeof(buf___1));
#line 1593
      if (len < 0) {
#line 1593
        tmp = __errno_location();
#line 1593
        if (*tmp == 4) {
#line 1594
          return (1);
        } else {
#line 1593
          tmp___0 = __errno_location();
#line 1593
          if (*tmp___0 == 11) {
#line 1594
            return (1);
          }
        }
      }
#line 1595
      if (len <= 0) {
#line 1596
        debug2("channel %d: ctl read<=0", c->self);
#line 1597
        if (c->type != 4) {
#line 1598
          debug2("channel %d: not open", c->self);
#line 1599
          chan_mark_dead(c);
#line 1600
          return (-1);
        } else {
#line 1602
          chan_read_failed(c);
#line 1603
          chan_write_failed(c);
        }
#line 1605
        return (-1);
      } else {
#line 1607
        fatal("%s: unexpected data on ctl fd", "channel_handle_ctl");
      }
    }
  }
#line 1609
  return (1);
}
}
#line 1611 "channels.c"
static int channel_check_window(Channel *c ) 
{ 

  {
#line 1614
  if (c->type == 4) {
#line 1614
    if (! (c->flags & 3)) {
#line 1614
      if (c->local_window < c->local_window_max / 2U) {
#line 1614
        if (c->local_consumed > 0U) {
#line 1618
          packet_start((unsigned char)93);
#line 1619
          packet_put_int((unsigned int )c->remote_id);
#line 1620
          packet_put_int(c->local_consumed);
#line 1621
          packet_send();
#line 1622
          debug2("channel %d: window %d sent adjust %d", c->self, c->local_window,
                 c->local_consumed);
#line 1625
          c->local_window += c->local_consumed;
#line 1626
          c->local_consumed = 0U;
        }
      }
    }
  }
#line 1628
  return (1);
}
}
#line 1631 "channels.c"
static void channel_post_open(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 1634
  if (c->delayed) {
#line 1635
    return;
  }
#line 1636
  channel_handle_rfd(c, readset, writeset);
#line 1637
  channel_handle_wfd(c, readset, writeset);
#line 1638
  if (! compat20) {
#line 1639
    return;
  }
#line 1640
  channel_handle_efd(c, readset, writeset);
#line 1641
  channel_handle_ctl(c, readset, writeset);
#line 1642
  channel_check_window(c);
#line 1643
  return;
}
}
#line 1645 "channels.c"
static void channel_post_output_drain_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int len ;
  u_int tmp ;
  void *tmp___0 ;
  register char __result ;
  u_int tmp___1 ;

  {
#line 1651
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 1651
  if (__result) {
#line 1651
    tmp___1 = buffer_len(& c->output);
#line 1651
    if (tmp___1 > 0U) {
#line 1652
      tmp = buffer_len(& c->output);
#line 1652
      tmp___0 = buffer_ptr(& c->output);
#line 1652
      len = write(c->sock, (void const   *)tmp___0, tmp);
#line 1654
      if (len <= 0) {
#line 1655
        buffer_clear(& c->output);
      } else {
#line 1657
        buffer_consume(& c->output, (unsigned int )len);
      }
    }
  }
#line 1659
  return;
}
}
#line 1661 "channels.c"
static void channel_handler_init_20(void) 
{ 

  {
#line 1664
  channel_pre[4] = & channel_pre_open;
#line 1665
  channel_pre[7] = & channel_pre_x11_open;
#line 1666
  channel_pre[2] = & channel_pre_listener;
#line 1667
  channel_pre[11] = & channel_pre_listener;
#line 1668
  channel_pre[1] = & channel_pre_listener;
#line 1669
  channel_pre[6] = & channel_pre_listener;
#line 1670
  channel_pre[12] = & channel_pre_connecting;
#line 1671
  channel_pre[13] = & channel_pre_dynamic;
#line 1673
  channel_post[4] = & channel_post_open;
#line 1674
  channel_post[2] = & channel_post_port_listener;
#line 1675
  channel_post[11] = & channel_post_port_listener;
#line 1676
  channel_post[1] = & channel_post_x11_listener;
#line 1677
  channel_post[6] = & channel_post_auth_listener;
#line 1678
  channel_post[12] = & channel_post_connecting;
#line 1679
  channel_post[13] = & channel_post_open;
#line 1680
  return;
}
}
#line 1682 "channels.c"
static void channel_handler_init_13(void) 
{ 

  {
#line 1685
  channel_pre[4] = & channel_pre_open_13;
#line 1686
  channel_pre[7] = & channel_pre_x11_open_13;
#line 1687
  channel_pre[1] = & channel_pre_listener;
#line 1688
  channel_pre[2] = & channel_pre_listener;
#line 1689
  channel_pre[6] = & channel_pre_listener;
#line 1690
  channel_pre[8] = & channel_pre_input_draining;
#line 1691
  channel_pre[9] = & channel_pre_output_draining;
#line 1692
  channel_pre[12] = & channel_pre_connecting;
#line 1693
  channel_pre[13] = & channel_pre_dynamic;
#line 1695
  channel_post[4] = & channel_post_open;
#line 1696
  channel_post[1] = & channel_post_x11_listener;
#line 1697
  channel_post[2] = & channel_post_port_listener;
#line 1698
  channel_post[6] = & channel_post_auth_listener;
#line 1699
  channel_post[9] = & channel_post_output_drain_13;
#line 1700
  channel_post[12] = & channel_post_connecting;
#line 1701
  channel_post[13] = & channel_post_open;
#line 1702
  return;
}
}
#line 1704 "channels.c"
static void channel_handler_init_15(void) 
{ 

  {
#line 1707
  channel_pre[4] = & channel_pre_open;
#line 1708
  channel_pre[7] = & channel_pre_x11_open;
#line 1709
  channel_pre[1] = & channel_pre_listener;
#line 1710
  channel_pre[2] = & channel_pre_listener;
#line 1711
  channel_pre[6] = & channel_pre_listener;
#line 1712
  channel_pre[12] = & channel_pre_connecting;
#line 1713
  channel_pre[13] = & channel_pre_dynamic;
#line 1715
  channel_post[1] = & channel_post_x11_listener;
#line 1716
  channel_post[2] = & channel_post_port_listener;
#line 1717
  channel_post[6] = & channel_post_auth_listener;
#line 1718
  channel_post[4] = & channel_post_open;
#line 1719
  channel_post[12] = & channel_post_connecting;
#line 1720
  channel_post[13] = & channel_post_open;
#line 1721
  return;
}
}
#line 1723 "channels.c"
static void channel_handler_init(void) 
{ int i ;

  {
#line 1728
  i = 0;
#line 1728
  while (i < 15) {
#line 1729
    channel_pre[i] = (chan_fn *)((void *)0);
#line 1730
    channel_post[i] = (chan_fn *)((void *)0);
#line 1728
    i ++;
  }
#line 1732
  if (compat20) {
#line 1733
    channel_handler_init_20();
  } else {
#line 1734
    if (compat13) {
#line 1735
      channel_handler_init_13();
    } else {
#line 1737
      channel_handler_init_15();
    }
  }
#line 1738
  return;
}
}
#line 1741 "channels.c"
static void channel_garbage_collect(Channel *c ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 1744
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1745
    return;
  }
#line 1746
  if ((unsigned int )c->detach_user != (unsigned int )((void *)0)) {
#line 1747
    tmp = chan_is_dead(c, c->detach_close);
#line 1747
    if (! tmp) {
#line 1748
      return;
    }
#line 1749
    debug2("channel %d: gc: notify user", c->self);
#line 1750
    (*(c->detach_user))(c->self, (void *)0);
#line 1752
    if ((unsigned int )c->detach_user != (unsigned int )((void *)0)) {
#line 1753
      return;
    }
#line 1754
    debug2("channel %d: gc: user detached", c->self);
  }
#line 1756
  tmp___0 = chan_is_dead(c, 1);
#line 1756
  if (! tmp___0) {
#line 1757
    return;
  }
#line 1758
  debug2("channel %d: garbage collecting", c->self);
#line 1759
  channel_free(c);
#line 1760
  return;
}
}
#line 1765
static void channel_handler(chan_fn **ftab , fd_set *readset , fd_set *writeset ) ;
#line 1765 "channels.c"
static int did_init  =    0;
#line 1762 "channels.c"
static void channel_handler(chan_fn **ftab , fd_set *readset , fd_set *writeset ) 
{ u_int i ;
  Channel *c ;

  {
#line 1769
  if (! did_init) {
#line 1770
    channel_handler_init();
#line 1771
    did_init = 1;
  }
#line 1773
  i = 0U;
#line 1773
  while (i < channels_alloc) {
#line 1774
    c = *(channels + i);
#line 1775
    if ((unsigned int )c == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 1777
    if ((unsigned int )*(ftab + c->type) != (unsigned int )((void *)0)) {
#line 1778
      (*(*(ftab + c->type)))(c, readset, writeset);
    }
#line 1779
    channel_garbage_collect(c);
    __Cont: /* CIL Label */ 
#line 1773
    i ++;
  }
#line 1781
  return;
}
}
#line 1787 "channels.c"
void channel_prepare_select(fd_set **readsetp , fd_set **writesetp , int *maxfdp ,
                            u_int *nallocp , int rekeying___0 ) 
{ u_int n___0 ;
  u_int sz ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1793
  if (*maxfdp > channel_max_fd) {
#line 1793
    n___0 = (unsigned int )*maxfdp;
  } else {
#line 1793
    n___0 = (unsigned int )channel_max_fd;
  }
#line 1795
  sz = (((n___0 + 1U) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask );
#line 1797
  if ((unsigned int )*readsetp == (unsigned int )((void *)0)) {
#line 1798
    tmp = xrealloc((void *)*readsetp, sz);
#line 1798
    *readsetp = (fd_set *)tmp;
#line 1799
    tmp___0 = xrealloc((void *)*writesetp, sz);
#line 1799
    *writesetp = (fd_set *)tmp___0;
#line 1800
    *nallocp = sz;
  } else {
#line 1797
    if (sz > *nallocp) {
#line 1798
      tmp = xrealloc((void *)*readsetp, sz);
#line 1798
      *readsetp = (fd_set *)tmp;
#line 1799
      tmp___0 = xrealloc((void *)*writesetp, sz);
#line 1799
      *writesetp = (fd_set *)tmp___0;
#line 1800
      *nallocp = sz;
    }
  }
#line 1802
  *maxfdp = (int )n___0;
#line 1803
  memset((void *)*readsetp, 0, sz);
#line 1804
  memset((void *)*writesetp, 0, sz);
#line 1806
  if (! rekeying___0) {
#line 1807
    channel_handler(channel_pre, *readsetp, *writesetp);
  }
#line 1808
  return;
}
}
#line 1814 "channels.c"
void channel_after_select(fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 1817
  channel_handler(channel_post, readset, writeset);
#line 1818
  return;
}
}
#line 1823 "channels.c"
void channel_output_poll(void) 
{ Channel *c ;
  u_int i ;
  u_int len ;
  u_char *data ;
  u_int dlen ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  u_int tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  void *tmp___6 ;

  {
#line 1829
  i = 0U;
#line 1829
  while (i < channels_alloc) {
#line 1830
    c = *(channels + i);
#line 1831
    if ((unsigned int )c == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 1838
    if (compat13) {
#line 1839
      if (c->type != 4) {
#line 1839
        if (c->type != 8) {
          goto __Cont;
        }
      }
    } else {
#line 1843
      if (c->type != 4) {
        goto __Cont;
      }
    }
#line 1846
    if (compat20) {
#line 1846
      if (c->flags & 3) {
#line 1849
        debug3("channel %d: will not send data after close", c->self);
        goto __Cont;
      }
    }
#line 1854
    if (c->istate == 0U) {
      goto _L___0;
    } else {
#line 1854
      if (c->istate == 1U) {
        _L___0: /* CIL Label */ 
#line 1854
        len = buffer_len(& c->input);
#line 1854
        if (len > 0U) {
#line 1857
          if (c->datagram) {
#line 1858
            if (len > 0U) {
#line 1862
              tmp = buffer_get_string(& c->input, & dlen);
#line 1862
              data = (u_char *)tmp;
#line 1864
              packet_start((unsigned char)94);
#line 1865
              packet_put_int((unsigned int )c->remote_id);
#line 1866
              packet_put_string((void const   *)data, dlen);
#line 1867
              packet_send();
#line 1868
              c->remote_window -= dlen + 4U;
#line 1869
              xfree((void *)data);
            }
            goto __Cont;
          }
#line 1877
          if (compat20) {
#line 1878
            if (len > c->remote_window) {
#line 1879
              len = c->remote_window;
            }
#line 1880
            if (len > c->remote_maxpacket) {
#line 1881
              len = c->remote_maxpacket;
            }
          } else {
#line 1883
            tmp___0 = packet_is_interactive();
#line 1883
            if (tmp___0) {
#line 1884
              if (len > 1024U) {
#line 1885
                len = 512U;
              }
            } else {
#line 1888
              if (len > max_packet_size / 2U) {
#line 1889
                len = max_packet_size / 2U;
              }
            }
          }
#line 1892
          if (len > 0U) {
#line 1893
            if (compat20) {
#line 1893
              tmp___1 = 94;
            } else {
#line 1893
              tmp___1 = 23;
            }
#line 1893
            packet_start((unsigned char )tmp___1);
#line 1895
            packet_put_int((unsigned int )c->remote_id);
#line 1896
            tmp___2 = buffer_ptr(& c->input);
#line 1896
            packet_put_string((void const   *)tmp___2, len);
#line 1897
            packet_send();
#line 1898
            buffer_consume(& c->input, len);
#line 1899
            c->remote_window -= len;
          }
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 1901
        if (c->istate == 1U) {
#line 1902
          if (compat13) {
#line 1903
            fatal("cannot happen: istate == INPUT_WAIT_DRAIN for proto 1.3");
          }
#line 1909
          if (compat20) {
#line 1909
            if (c->extended_usage == 1) {
#line 1909
              if (c->efd != -1) {
#line 1910
                tmp___3 = buffer_len(& c->extended);
#line 1910
                debug2("channel %d: ibuf_empty delayed efd %d/(%d)", c->self, c->efd,
                       tmp___3);
              } else {
#line 1909
                tmp___4 = buffer_len(& c->extended);
#line 1909
                if (tmp___4 > 0U) {
#line 1910
                  tmp___3 = buffer_len(& c->extended);
#line 1910
                  debug2("channel %d: ibuf_empty delayed efd %d/(%d)", c->self, c->efd,
                         tmp___3);
                } else {
#line 1913
                  chan_ibuf_empty(c);
                }
              }
            } else {
#line 1913
              chan_ibuf_empty(c);
            }
          } else {
#line 1913
            chan_ibuf_empty(c);
          }
        }
      }
    }
#line 1916
    if (compat20) {
#line 1916
      if (! (c->flags & 4)) {
#line 1916
        if (c->remote_window > 0U) {
#line 1916
          len = buffer_len(& c->extended);
#line 1916
          if (len > 0U) {
#line 1916
            if (c->extended_usage == 1) {
#line 1921
              tmp___5 = buffer_len(& c->extended);
#line 1921
              debug2("channel %d: rwin %u elen %u euse %d", c->self, c->remote_window,
                     tmp___5, c->extended_usage);
#line 1924
              if (len > c->remote_window) {
#line 1925
                len = c->remote_window;
              }
#line 1926
              if (len > c->remote_maxpacket) {
#line 1927
                len = c->remote_maxpacket;
              }
#line 1928
              packet_start((unsigned char)95);
#line 1929
              packet_put_int((unsigned int )c->remote_id);
#line 1930
              packet_put_int(1U);
#line 1931
              tmp___6 = buffer_ptr(& c->extended);
#line 1931
              packet_put_string((void const   *)tmp___6, len);
#line 1932
              packet_send();
#line 1933
              buffer_consume(& c->extended, len);
#line 1934
              c->remote_window -= len;
#line 1935
              debug2("channel %d: sent ext data %d", c->self, len);
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1829
    i ++;
  }
#line 1938
  return;
}
}
#line 1943 "channels.c"
void channel_input_data(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  char *data ;
  u_int data_len ;
  Channel *c ;
  u_int tmp ;
  void *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1952
  tmp = packet_get_int();
#line 1952
  id = (int )tmp;
#line 1953
  c = channel_lookup(id);
#line 1954
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1955
    packet_disconnect("Received data for nonexistent channel %d.", id);
  }
#line 1958
  if (c->type != 4) {
#line 1958
    if (c->type != 7) {
#line 1960
      return;
    }
  }
#line 1963
  tmp___0 = packet_get_string(& data_len);
#line 1963
  data = (char *)tmp___0;
#line 1972
  if (! compat13) {
#line 1972
    if (c->ostate != 0U) {
#line 1973
      if (compat20) {
#line 1974
        c->local_window -= data_len;
#line 1975
        c->local_consumed += data_len;
      }
#line 1977
      xfree((void *)data);
#line 1978
      return;
    }
  }
#line 1981
  if (compat20) {
#line 1982
    if (data_len > c->local_maxpacket) {
#line 1983
      logit("channel %d: rcvd big packet %d, maxpack %d", c->self, data_len, c->local_maxpacket);
    }
#line 1986
    if (data_len > c->local_window) {
#line 1987
      logit("channel %d: rcvd too much data %d, win %d", c->self, data_len, c->local_window);
#line 1989
      xfree((void *)data);
#line 1990
      return;
    }
#line 1992
    c->local_window -= data_len;
  }
#line 1994
  while (1) {
#line 1994
    tmp___1 = packet_remaining();
#line 1994
    _len = tmp___1;
#line 1994
    if (_len > 0) {
#line 1994
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            1994);
#line 1994
      packet_disconnect("Packet integrity error.");
    }
#line 1994
    break;
  }
#line 1995
  if (c->datagram) {
#line 1996
    buffer_put_string(& c->output, (void const   *)data, data_len);
  } else {
#line 1998
    buffer_append(& c->output, (void const   *)data, data_len);
  }
#line 1999
  xfree((void *)data);
#line 2000
  return;
}
}
#line 2002 "channels.c"
void channel_input_extended_data(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  char *data ;
  u_int data_len ;
  u_int tcode ;
  Channel *c ;
  u_int tmp ;
  void *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 2011
  tmp = packet_get_int();
#line 2011
  id = (int )tmp;
#line 2012
  c = channel_lookup(id);
#line 2014
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2015
    packet_disconnect("Received extended_data for bad channel %d.", id);
  }
#line 2016
  if (c->type != 4) {
#line 2017
    logit("channel %d: ext data for non open", id);
#line 2018
    return;
  }
#line 2020
  if (c->flags & 8) {
#line 2021
    if (datafellows & 2097152) {
#line 2022
      debug("channel %d: accepting ext data after eof", id);
    } else {
#line 2024
      packet_disconnect("Received extended_data after EOF on channel %d.", id);
    }
  }
#line 2027
  tcode = packet_get_int();
#line 2028
  if (c->efd == -1) {
#line 2031
    logit("channel %d: bad ext data", c->self);
#line 2032
    return;
  } else {
#line 2028
    if (c->extended_usage != 2) {
#line 2031
      logit("channel %d: bad ext data", c->self);
#line 2032
      return;
    } else {
#line 2028
      if (tcode != 1U) {
#line 2031
        logit("channel %d: bad ext data", c->self);
#line 2032
        return;
      }
    }
  }
#line 2034
  tmp___0 = packet_get_string(& data_len);
#line 2034
  data = (char *)tmp___0;
#line 2035
  while (1) {
#line 2035
    tmp___1 = packet_remaining();
#line 2035
    _len = tmp___1;
#line 2035
    if (_len > 0) {
#line 2035
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2035);
#line 2035
      packet_disconnect("Packet integrity error.");
    }
#line 2035
    break;
  }
#line 2036
  if (data_len > c->local_window) {
#line 2037
    logit("channel %d: rcvd too much extended_data %d, win %d", c->self, data_len,
          c->local_window);
#line 2039
    xfree((void *)data);
#line 2040
    return;
  }
#line 2042
  debug2("channel %d: rcvd ext data %d", c->self, data_len);
#line 2043
  c->local_window -= data_len;
#line 2044
  buffer_append(& c->extended, (void const   *)data, data_len);
#line 2045
  xfree((void *)data);
#line 2046
  return;
}
}
#line 2048 "channels.c"
void channel_input_ieof(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  Channel *c ;
  u_int tmp ;
  int _len ;
  int tmp___0 ;
  u_int tmp___1 ;

  {
#line 2054
  tmp = packet_get_int();
#line 2054
  id = (int )tmp;
#line 2055
  while (1) {
#line 2055
    tmp___0 = packet_remaining();
#line 2055
    _len = tmp___0;
#line 2055
    if (_len > 0) {
#line 2055
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2055);
#line 2055
      packet_disconnect("Packet integrity error.");
    }
#line 2055
    break;
  }
#line 2056
  c = channel_lookup(id);
#line 2057
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2058
    packet_disconnect("Received ieof for nonexistent channel %d.", id);
  }
#line 2059
  chan_rcvd_ieof(c);
#line 2062
  if (c->force_drain) {
#line 2062
    if (c->istate == 0U) {
#line 2063
      debug("channel %d: FORCE input drain", c->self);
#line 2064
      c->istate = 1U;
#line 2065
      tmp___1 = buffer_len(& c->input);
#line 2065
      if (tmp___1 == 0U) {
#line 2066
        chan_ibuf_empty(c);
      }
    }
  }
#line 2069
  return;
}
}
#line 2071 "channels.c"
void channel_input_close(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  Channel *c ;
  u_int tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 2077
  tmp = packet_get_int();
#line 2077
  id = (int )tmp;
#line 2078
  while (1) {
#line 2078
    tmp___0 = packet_remaining();
#line 2078
    _len = tmp___0;
#line 2078
    if (_len > 0) {
#line 2078
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2078);
#line 2078
      packet_disconnect("Packet integrity error.");
    }
#line 2078
    break;
  }
#line 2079
  c = channel_lookup(id);
#line 2080
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2081
    packet_disconnect("Received close for nonexistent channel %d.", id);
  }
#line 2087
  packet_start((unsigned char)25);
#line 2088
  packet_put_int((unsigned int )c->remote_id);
#line 2089
  packet_send();
#line 2098
  if (c->type != 5) {
#line 2103
    buffer_clear(& c->input);
#line 2104
    c->type = 9;
  }
#line 2106
  return;
}
}
#line 2109 "channels.c"
void channel_input_oclose(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  u_int tmp ;
  Channel *c ;
  Channel *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 2112
  tmp = packet_get_int();
#line 2112
  id = (int )tmp;
#line 2113
  tmp___0 = channel_lookup(id);
#line 2113
  c = tmp___0;
#line 2115
  while (1) {
#line 2115
    tmp___1 = packet_remaining();
#line 2115
    _len = tmp___1;
#line 2115
    if (_len > 0) {
#line 2115
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2115);
#line 2115
      packet_disconnect("Packet integrity error.");
    }
#line 2115
    break;
  }
#line 2116
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2117
    packet_disconnect("Received oclose for nonexistent channel %d.", id);
  }
#line 2118
  chan_rcvd_oclose(c);
#line 2119
  return;
}
}
#line 2121 "channels.c"
void channel_input_close_confirmation(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  u_int tmp ;
  Channel *c ;
  Channel *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 2124
  tmp = packet_get_int();
#line 2124
  id = (int )tmp;
#line 2125
  tmp___0 = channel_lookup(id);
#line 2125
  c = tmp___0;
#line 2127
  while (1) {
#line 2127
    tmp___1 = packet_remaining();
#line 2127
    _len = tmp___1;
#line 2127
    if (_len > 0) {
#line 2127
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2127);
#line 2127
      packet_disconnect("Packet integrity error.");
    }
#line 2127
    break;
  }
#line 2128
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2129
    packet_disconnect("Received close confirmation for out-of-range channel %d.",
                      id);
  }
#line 2131
  if (c->type != 5) {
#line 2132
    packet_disconnect("Received close confirmation for non-closed channel %d (type %d).",
                      id, c->type);
  }
#line 2134
  channel_free(c);
#line 2135
  return;
}
}
#line 2137 "channels.c"
void channel_input_open_confirmation(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  int remote_id ;
  Channel *c ;
  u_int tmp ;
  u_int tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 2143
  tmp = packet_get_int();
#line 2143
  id = (int )tmp;
#line 2144
  c = channel_lookup(id);
#line 2146
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2147
    packet_disconnect("Received open confirmation for non-opening channel %d.", id);
  } else {
#line 2146
    if (c->type != 3) {
#line 2147
      packet_disconnect("Received open confirmation for non-opening channel %d.",
                        id);
    }
  }
#line 2149
  tmp___0 = packet_get_int();
#line 2149
  remote_id = (int )tmp___0;
#line 2151
  c->remote_id = remote_id;
#line 2152
  c->type = 4;
#line 2154
  if (compat20) {
#line 2155
    c->remote_window = packet_get_int();
#line 2156
    c->remote_maxpacket = packet_get_int();
#line 2157
    if (c->confirm) {
#line 2158
      debug2("callback start");
#line 2159
      (*(c->confirm))(c->self, c->confirm_ctx);
#line 2160
      debug2("callback done");
    }
#line 2162
    debug2("channel %d: open confirm rwindow %u rmax %u", c->self, c->remote_window,
           c->remote_maxpacket);
  }
#line 2165
  while (1) {
#line 2165
    tmp___1 = packet_remaining();
#line 2165
    _len = tmp___1;
#line 2165
    if (_len > 0) {
#line 2165
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2165);
#line 2165
      packet_disconnect("Packet integrity error.");
    }
#line 2165
    break;
  }
#line 2166
  return;
}
}
#line 2168 "channels.c"
static char *reason2txt(int reason ) 
{ 

  {
#line 2171
  switch (reason) {
  case 1: 
#line 2173
  return ((char *)"administratively prohibited");
  case 2: 
#line 2175
  return ((char *)"connect failed");
  case 3: 
#line 2177
  return ((char *)"unknown channel type");
  case 4: 
#line 2179
  return ((char *)"resource shortage");
  }
#line 2181
  return ((char *)"unknown reason");
}
}
#line 2184 "channels.c"
void channel_input_open_failure(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  int reason ;
  char *msg ;
  char *lang ;
  Channel *c ;
  u_int tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  int _len ;
  int tmp___6 ;

  {
#line 2188
  msg = (char *)((void *)0);
#line 2188
  lang = (char *)((void *)0);
#line 2191
  tmp = packet_get_int();
#line 2191
  id = (int )tmp;
#line 2192
  c = channel_lookup(id);
#line 2194
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2195
    packet_disconnect("Received open failure for non-opening channel %d.", id);
  } else {
#line 2194
    if (c->type != 3) {
#line 2195
      packet_disconnect("Received open failure for non-opening channel %d.", id);
    }
  }
#line 2197
  if (compat20) {
#line 2198
    tmp___0 = packet_get_int();
#line 2198
    reason = (int )tmp___0;
#line 2199
    if (! (datafellows & 131072)) {
#line 2200
      tmp___1 = packet_get_string((u_int *)((void *)0));
#line 2200
      msg = (char *)tmp___1;
#line 2201
      tmp___2 = packet_get_string((u_int *)((void *)0));
#line 2201
      lang = (char *)tmp___2;
    }
#line 2203
    if (msg) {
#line 2203
      tmp___3 = (char const   *)msg;
    } else {
#line 2203
      tmp___3 = "";
    }
#line 2203
    if (msg) {
#line 2203
      tmp___4 = ": ";
    } else {
#line 2203
      tmp___4 = "";
    }
#line 2203
    tmp___5 = reason2txt(reason);
#line 2203
    logit("channel %d: open failed: %s%s%s", id, tmp___5, tmp___4, tmp___3);
#line 2205
    if ((unsigned int )msg != (unsigned int )((void *)0)) {
#line 2206
      xfree((void *)msg);
    }
#line 2207
    if ((unsigned int )lang != (unsigned int )((void *)0)) {
#line 2208
      xfree((void *)lang);
    }
  }
#line 2210
  while (1) {
#line 2210
    tmp___6 = packet_remaining();
#line 2210
    _len = tmp___6;
#line 2210
    if (_len > 0) {
#line 2210
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2210);
#line 2210
      packet_disconnect("Packet integrity error.");
    }
#line 2210
    break;
  }
#line 2212
  channel_free(c);
#line 2213
  return;
}
}
#line 2215 "channels.c"
void channel_input_window_adjust(int type , u_int32_t seq , void *ctxt ) 
{ Channel *c ;
  int id ;
  u_int adjust ;
  u_int tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 2222
  if (! compat20) {
#line 2223
    return;
  }
#line 2226
  tmp = packet_get_int();
#line 2226
  id = (int )tmp;
#line 2227
  c = channel_lookup(id);
#line 2229
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2230
    logit("Received window adjust for non-open channel %d.", id);
#line 2231
    return;
  }
#line 2233
  adjust = packet_get_int();
#line 2234
  while (1) {
#line 2234
    tmp___0 = packet_remaining();
#line 2234
    _len = tmp___0;
#line 2234
    if (_len > 0) {
#line 2234
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2234);
#line 2234
      packet_disconnect("Packet integrity error.");
    }
#line 2234
    break;
  }
#line 2235
  debug2("channel %d: rcvd adjust %u", id, adjust);
#line 2236
  c->remote_window += adjust;
#line 2237
  return;
}
}
#line 2239 "channels.c"
void channel_input_port_open(int type , u_int32_t seq , void *ctxt ) 
{ Channel *c ;
  u_short host_port ;
  char *host ;
  char *originator_string ;
  int remote_id ;
  int sock ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  u_int tmp___3 ;
  int _len ;
  int tmp___4 ;

  {
#line 2242
  c = (Channel *)((void *)0);
#line 2245
  sock = -1;
#line 2247
  tmp = packet_get_int();
#line 2247
  remote_id = (int )tmp;
#line 2248
  tmp___0 = packet_get_string((u_int *)((void *)0));
#line 2248
  host = (char *)tmp___0;
#line 2249
  tmp___1 = packet_get_int();
#line 2249
  host_port = (unsigned short )tmp___1;
#line 2251
  tmp___3 = packet_get_protocol_flags();
#line 2251
  if (tmp___3 & 2U) {
#line 2252
    tmp___2 = packet_get_string((u_int *)((void *)0));
#line 2252
    originator_string = (char *)tmp___2;
  } else {
#line 2254
    originator_string = xstrdup("unknown (remote did not supply name)");
  }
#line 2256
  while (1) {
#line 2256
    tmp___4 = packet_remaining();
#line 2256
    _len = tmp___4;
#line 2256
    if (_len > 0) {
#line 2256
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2256);
#line 2256
      packet_disconnect("Packet integrity error.");
    }
#line 2256
    break;
  }
#line 2257
  sock = channel_connect_to((char const   *)host, host_port);
#line 2258
  if (sock != -1) {
#line 2259
    c = channel_new((char *)"connected socket", 12, sock, sock, -1, 0U, 0U, 0, originator_string,
                    1);
#line 2262
    c->remote_id = remote_id;
  }
#line 2264
  xfree((void *)originator_string);
#line 2265
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2266
    packet_start((unsigned char)22);
#line 2267
    packet_put_int((unsigned int )remote_id);
#line 2268
    packet_send();
  }
#line 2270
  xfree((void *)host);
#line 2271
  return;
}
}
#line 2276 "channels.c"
void channel_set_af(int af ) 
{ 

  {
#line 2279
  IPv4or6 = af;
#line 2280
  return;
}
}
#line 2282 "channels.c"
static int channel_setup_fwd_listener(int type , char const   *listen_addr , u_short listen_port ,
                                      char const   *host_to_connect , u_short port_to_connect ,
                                      int gateway_ports ) 
{ Channel *c ;
  int sock ;
  int r ;
  int success ;
  int wildcard ;
  int is_client ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char const   *host ;
  char const   *addr ;
  char ntop[1025] ;
  char strport[32] ;
  size_t tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___25 ;
  int tmp___28 ;
  int tmp___29 ;
  char const   *tmp___30 ;
  char const   *tmp___31 ;
  char const   *tmp___32 ;
  int tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  int *tmp___36 ;
  char *tmp___37 ;
  int *tmp___38 ;
  char *tmp___39 ;
  int tmp___40 ;
  int *tmp___41 ;
  char *tmp___42 ;
  int tmp___43 ;

  {
#line 2287
  success = 0;
#line 2287
  wildcard = 0;
#line 2292
  if (type == 11) {
#line 2292
    host = listen_addr;
  } else {
#line 2292
    host = host_to_connect;
  }
#line 2294
  is_client = type == 2;
#line 2296
  if ((unsigned int )host == (unsigned int )((void *)0)) {
#line 2297
    error("No forward host name.");
#line 2298
    return (0);
  }
#line 2300
  tmp = strlen(host);
#line 2300
  if (tmp > 255U) {
#line 2301
    error("Forward host name too long.");
#line 2302
    return (0);
  }
#line 2320
  addr = (char const   *)((void *)0);
#line 2321
  if ((unsigned int )listen_addr == (unsigned int )((void *)0)) {
#line 2323
    if (gateway_ports) {
#line 2324
      wildcard = 1;
    }
  } else {
#line 2325
    if (gateway_ports) {
      goto _L___7;
    } else {
#line 2325
      if (is_client) {
        _L___7: /* CIL Label */ 
#line 2328
        if (datafellows & 16777216) {
#line 2327
          if (0) {
#line 2327
            __s1_len___0 = strlen(listen_addr);
#line 2327
            __s2_len___0 = strlen("0.0.0.0");
#line 2327
            if (! ((unsigned int )((void const   *)(listen_addr + 1)) - (unsigned int )((void const   *)listen_addr) == 1U)) {
              goto _L___2;
            } else {
#line 2327
              if (__s1_len___0 >= 4U) {
                _L___2: /* CIL Label */ 
#line 2327
                if (! ((unsigned int )((void const   *)("0.0.0.0" + 1)) - (unsigned int )((void const   *)"0.0.0.0") == 1U)) {
#line 2327
                  tmp___19 = 1;
                } else {
#line 2327
                  if (__s2_len___0 >= 4U) {
#line 2327
                    tmp___19 = 1;
                  } else {
#line 2327
                    tmp___19 = 0;
                  }
                }
              } else {
#line 2327
                tmp___19 = 0;
              }
            }
#line 2327
            if (tmp___19) {
#line 2327
              tmp___15 = __builtin_strcmp(listen_addr, "0.0.0.0");
            } else {
#line 2327
              tmp___18 = __builtin_strcmp(listen_addr, "0.0.0.0");
#line 2327
              tmp___15 = tmp___18;
            }
          } else {
#line 2327
            tmp___18 = __builtin_strcmp(listen_addr, "0.0.0.0");
#line 2327
            tmp___15 = tmp___18;
          }
#line 2328
          if (tmp___15 == 0) {
#line 2330
            wildcard = 1;
          } else {
            goto _L___6;
          }
        } else {
          _L___6: /* CIL Label */ 
#line 2328
          if ((int const   )*listen_addr == 0) {
#line 2330
            wildcard = 1;
          } else {
#line 2328
            if (0) {
#line 2328
              __s1_len___1 = strlen(listen_addr);
#line 2328
              __s2_len___1 = strlen("*");
#line 2328
              if (! ((unsigned int )((void const   *)(listen_addr + 1)) - (unsigned int )((void const   *)listen_addr) == 1U)) {
                goto _L___4;
              } else {
#line 2328
                if (__s1_len___1 >= 4U) {
                  _L___4: /* CIL Label */ 
#line 2328
                  if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") == 1U)) {
#line 2328
                    tmp___29 = 1;
                  } else {
#line 2328
                    if (__s2_len___1 >= 4U) {
#line 2328
                      tmp___29 = 1;
                    } else {
#line 2328
                      tmp___29 = 0;
                    }
                  }
                } else {
#line 2328
                  tmp___29 = 0;
                }
              }
#line 2328
              if (tmp___29) {
#line 2328
                tmp___25 = __builtin_strcmp(listen_addr, "*");
              } else {
#line 2328
                tmp___28 = __builtin_strcmp(listen_addr, "*");
#line 2328
                tmp___25 = tmp___28;
              }
            } else {
#line 2328
              tmp___28 = __builtin_strcmp(listen_addr, "*");
#line 2328
              tmp___25 = tmp___28;
            }
#line 2328
            if (tmp___25 == 0) {
#line 2330
              wildcard = 1;
            } else {
#line 2328
              if (! is_client) {
#line 2328
                if (gateway_ports == 1) {
#line 2330
                  wildcard = 1;
                } else {
                  goto _L___5;
                }
              } else {
                _L___5: /* CIL Label */ 
#line 2331
                if (0) {
#line 2331
                  __s1_len = strlen(listen_addr);
#line 2331
                  __s2_len = strlen("localhost");
#line 2331
                  if (! ((unsigned int )((void const   *)(listen_addr + 1)) - (unsigned int )((void const   *)listen_addr) == 1U)) {
                    goto _L___0;
                  } else {
#line 2331
                    if (__s1_len >= 4U) {
                      _L___0: /* CIL Label */ 
#line 2331
                      if (! ((unsigned int )((void const   *)("localhost" + 1)) - (unsigned int )((void const   *)"localhost") == 1U)) {
#line 2331
                        tmp___9 = 1;
                      } else {
#line 2331
                        if (__s2_len >= 4U) {
#line 2331
                          tmp___9 = 1;
                        } else {
#line 2331
                          tmp___9 = 0;
                        }
                      }
                    } else {
#line 2331
                      tmp___9 = 0;
                    }
                  }
#line 2331
                  if (tmp___9) {
#line 2331
                    tmp___5 = __builtin_strcmp(listen_addr, "localhost");
                  } else {
#line 2331
                    tmp___8 = __builtin_strcmp(listen_addr, "localhost");
#line 2331
                    tmp___5 = tmp___8;
                  }
                } else {
#line 2331
                  tmp___8 = __builtin_strcmp(listen_addr, "localhost");
#line 2331
                  tmp___5 = tmp___8;
                }
#line 2331
                if (tmp___5 != 0) {
#line 2332
                  addr = listen_addr;
                }
              }
            }
          }
        }
      }
    }
  }
#line 2335
  if ((unsigned int )addr == (unsigned int )((void *)0)) {
#line 2335
    tmp___30 = "NULL";
  } else {
#line 2335
    tmp___30 = addr;
  }
#line 2335
  debug3("channel_setup_fwd_listener: type %d wildcard %d addr %s", type, wildcard,
         tmp___30);
#line 2342
  memset((void *)(& hints), 0, sizeof(hints));
#line 2343
  hints.ai_family = IPv4or6;
#line 2344
  if (wildcard) {
#line 2344
    hints.ai_flags = 1;
  } else {
#line 2344
    hints.ai_flags = 0;
  }
#line 2345
  hints.ai_socktype = 1;
#line 2346
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           listen_port);
#line 2347
  r = getaddrinfo((char const   * __restrict  )addr, (char const   * __restrict  )(strport),
                  (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 2347
  if (r != 0) {
#line 2348
    if ((unsigned int )addr == (unsigned int )((void *)0)) {
#line 2350
      tmp___31 = gai_strerror(r);
#line 2350
      packet_disconnect("getaddrinfo: fatal error: %s", tmp___31);
    } else {
#line 2353
      tmp___32 = gai_strerror(r);
#line 2353
      error("channel_setup_fwd_listener: getaddrinfo(%.64s): %s", addr, tmp___32);
    }
#line 2356
    return (0);
  }
#line 2359
  ai = aitop;
#line 2359
  while (ai) {
#line 2360
    if (ai->ai_family != 2) {
#line 2360
      if (ai->ai_family != 10) {
        goto __Cont;
      }
    }
#line 2362
    tmp___33 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                           (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )(strport),
                           sizeof(strport), 3U);
#line 2362
    if (tmp___33 != 0) {
#line 2364
      error("channel_setup_fwd_listener: getnameinfo failed");
      goto __Cont;
    }
#line 2368
    sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
#line 2369
    if (sock < 0) {
#line 2371
      tmp___34 = __errno_location();
#line 2371
      tmp___35 = strerror(*tmp___34);
#line 2371
      verbose("socket: %.100s", tmp___35);
      goto __Cont;
    }
#line 2375
    channel_set_reuseaddr(sock);
#line 2377
    debug("Local forwarding listening on %s port %s.", ntop, strport);
#line 2380
    tmp___40 = bind(sock, (struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen);
#line 2380
    if (tmp___40 < 0) {
#line 2382
      if (! ai->ai_next) {
#line 2383
        tmp___36 = __errno_location();
#line 2383
        tmp___37 = strerror(*tmp___36);
#line 2383
        error("bind: %.100s", tmp___37);
      } else {
#line 2385
        tmp___38 = __errno_location();
#line 2385
        tmp___39 = strerror(*tmp___38);
#line 2385
        verbose("bind: %.100s", tmp___39);
      }
#line 2387
      close(sock);
      goto __Cont;
    }
#line 2391
    tmp___43 = listen(sock, 128);
#line 2391
    if (tmp___43 < 0) {
#line 2392
      tmp___41 = __errno_location();
#line 2392
      tmp___42 = strerror(*tmp___41);
#line 2392
      error("listen: %.100s", tmp___42);
#line 2393
      close(sock);
      goto __Cont;
    }
#line 2397
    c = channel_new((char *)"port listener", type, sock, sock, -1, 131072U, 32768U,
                    0, (char *)"port listener", 1);
#line 2400
    strlcpy(c->path, host, sizeof(c->path));
#line 2401
    c->host_port = (int )port_to_connect;
#line 2402
    c->listening_port = (int )listen_port;
#line 2403
    success = 1;
    __Cont: /* CIL Label */ 
#line 2359
    ai = ai->ai_next;
  }
#line 2405
  if (success == 0) {
#line 2406
    error("channel_setup_fwd_listener: cannot listen to port: %d", listen_port);
  }
#line 2408
  freeaddrinfo(aitop);
#line 2409
  return (success);
}
}
#line 2412 "channels.c"
int channel_cancel_rport_listener(char const   *host , u_short port___0 ) 
{ u_int i ;
  int found ;
  Channel *c ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 2416
  found = 0;
#line 2418
  i = 0U;
#line 2418
  while (i < channels_alloc) {
#line 2419
    c = *(channels + i);
#line 2422
    if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 2422
      if (c->type == 11) {
#line 2422
        if (0) {
#line 2422
          if (0) {
#line 2422
            __s1_len___0 = strlen((char const   *)(c->path));
#line 2422
            __s2_len___0 = strlen(host);
#line 2422
            if (! ((unsigned int )((void const   *)(c->path + 1)) - (unsigned int )((void const   *)(c->path)) == 1U)) {
              goto _L___2;
            } else {
#line 2422
              if (__s1_len___0 >= 4U) {
                _L___2: /* CIL Label */ 
#line 2422
                if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
#line 2422
                  tmp___22 = 1;
                } else {
#line 2422
                  if (__s2_len___0 >= 4U) {
#line 2422
                    tmp___22 = 1;
                  } else {
#line 2422
                    tmp___22 = 0;
                  }
                }
              } else {
#line 2422
                tmp___22 = 0;
              }
            }
#line 2422
            if (tmp___22) {
#line 2422
              tmp___18 = __builtin_strcmp((char const   *)(c->path), host);
            } else {
#line 2422
              tmp___21 = __builtin_strcmp((char const   *)(c->path), host);
#line 2422
              tmp___18 = tmp___21;
            }
          } else {
#line 2422
            tmp___21 = __builtin_strcmp((char const   *)(c->path), host);
#line 2422
            tmp___18 = tmp___21;
          }
#line 2422
          tmp___12 = tmp___18;
        } else {
#line 2422
          tmp___12 = strncmp((char const   *)(c->path), host, sizeof(c->path));
        }
#line 2422
        if (tmp___12 == 0) {
#line 2422
          if (c->listening_port == (int )port___0) {
#line 2424
            debug2("%s: close channel %d", "channel_cancel_rport_listener", i);
#line 2425
            channel_free(c);
#line 2426
            found = 1;
          }
        }
      }
    }
#line 2418
    i ++;
  }
#line 2430
  return (found);
}
}
#line 2434 "channels.c"
int channel_setup_local_fwd_listener(char const   *listen_host , u_short listen_port ,
                                     char const   *host_to_connect , u_short port_to_connect ,
                                     int gateway_ports ) 
{ int tmp ;

  {
#line 2438
  tmp = channel_setup_fwd_listener(2, listen_host, listen_port, host_to_connect, port_to_connect,
                                   gateway_ports);
#line 2438
  return (tmp);
}
}
#line 2444 "channels.c"
int channel_setup_remote_fwd_listener(char const   *listen_address , u_short listen_port ,
                                      int gateway_ports ) 
{ int tmp ;

  {
#line 2448
  tmp = channel_setup_fwd_listener(11, listen_address, listen_port, (char const   *)((void *)0),
                                   (unsigned short)0, gateway_ports);
#line 2448
  return (tmp);
}
}
#line 2457 "channels.c"
void channel_request_remote_forwarding(char const   *listen_host , u_short listen_port ,
                                       char const   *host_to_connect , u_short port_to_connect ) 
{ int type ;
  int success ;
  char const   *address_to_bind ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 2461
  success = 0;
#line 2464
  if (num_permitted_opens >= 100) {
#line 2465
    fatal("channel_request_remote_forwarding: too many forwards");
  }
#line 2468
  if (compat20) {
#line 2470
    if ((unsigned int )listen_host == (unsigned int )((void *)0)) {
#line 2471
      address_to_bind = "localhost";
    } else {
#line 2472
      if ((int const   )*listen_host == 0) {
#line 2473
        address_to_bind = "";
      } else {
#line 2472
        if (0) {
#line 2472
          __s1_len = strlen(listen_host);
#line 2472
          __s2_len = strlen("*");
#line 2472
          if (! ((unsigned int )((void const   *)(listen_host + 1)) - (unsigned int )((void const   *)listen_host) == 1U)) {
            goto _L___0;
          } else {
#line 2472
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 2472
              if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") == 1U)) {
#line 2472
                tmp___8 = 1;
              } else {
#line 2472
                if (__s2_len >= 4U) {
#line 2472
                  tmp___8 = 1;
                } else {
#line 2472
                  tmp___8 = 0;
                }
              }
            } else {
#line 2472
              tmp___8 = 0;
            }
          }
#line 2472
          if (tmp___8) {
#line 2472
            tmp___4 = __builtin_strcmp(listen_host, "*");
          } else {
#line 2472
            tmp___7 = __builtin_strcmp(listen_host, "*");
#line 2472
            tmp___4 = tmp___7;
          }
        } else {
#line 2472
          tmp___7 = __builtin_strcmp(listen_host, "*");
#line 2472
          tmp___4 = tmp___7;
        }
#line 2472
        if (tmp___4 == 0) {
#line 2473
          address_to_bind = "";
        } else {
#line 2475
          address_to_bind = listen_host;
        }
      }
    }
#line 2477
    packet_start((unsigned char)80);
#line 2478
    packet_put_cstring("tcpip-forward");
#line 2479
    packet_put_char(1);
#line 2480
    packet_put_cstring(address_to_bind);
#line 2481
    packet_put_int((unsigned int )listen_port);
#line 2482
    packet_send();
#line 2483
    packet_write_wait();
#line 2485
    success = 1;
  } else {
#line 2487
    packet_start((unsigned char)28);
#line 2488
    packet_put_int((unsigned int )listen_port);
#line 2489
    packet_put_cstring(host_to_connect);
#line 2490
    packet_put_int((unsigned int )port_to_connect);
#line 2491
    packet_send();
#line 2492
    packet_write_wait();
#line 2495
    type = packet_read();
#line 2496
    switch (type) {
    case 14: 
#line 2498
    success = 1;
#line 2499
    break;
    case 15: 
#line 2501
    logit("Warning: Server denied remote port forwarding.");
#line 2502
    break;
    default: 
#line 2505
    packet_disconnect("Protocol error for port forward request:received packet type %d.",
                      type);
    }
  }
#line 2509
  if (success) {
#line 2510
    permitted_opens[num_permitted_opens].host_to_connect = xstrdup(host_to_connect);
#line 2511
    permitted_opens[num_permitted_opens].port_to_connect = port_to_connect;
#line 2512
    permitted_opens[num_permitted_opens].listen_port = listen_port;
#line 2513
    num_permitted_opens ++;
  }
#line 2515
  return;
}
}
#line 2521 "channels.c"
void channel_request_rforward_cancel(char const   *host , u_short port___0 ) 
{ int i ;
  char const   *tmp ;

  {
#line 2526
  if (! compat20) {
#line 2527
    return;
  }
#line 2529
  i = 0;
#line 2529
  while (i < num_permitted_opens) {
#line 2530
    if ((unsigned int )permitted_opens[i].host_to_connect != (unsigned int )((void *)0)) {
#line 2530
      if ((int )permitted_opens[i].listen_port == (int )port___0) {
#line 2532
        break;
      }
    }
#line 2529
    i ++;
  }
#line 2534
  if (i >= num_permitted_opens) {
#line 2535
    debug("%s: requested forward not found", "channel_request_rforward_cancel");
#line 2536
    return;
  }
#line 2538
  packet_start((unsigned char)80);
#line 2539
  packet_put_cstring("cancel-tcpip-forward");
#line 2540
  packet_put_char(0);
#line 2541
  if ((unsigned int )host == (unsigned int )((void *)0)) {
#line 2541
    tmp = "";
  } else {
#line 2541
    tmp = host;
  }
#line 2541
  packet_put_cstring(tmp);
#line 2542
  packet_put_int((unsigned int )port___0);
#line 2543
  packet_send();
#line 2545
  permitted_opens[i].listen_port = (unsigned short)0;
#line 2546
  permitted_opens[i].port_to_connect = (unsigned short)0;
#line 2547
  xfree((void *)permitted_opens[i].host_to_connect);
#line 2548
  permitted_opens[i].host_to_connect = (char *)((void *)0);
#line 2549
  return;
}
}
#line 2557 "channels.c"
void channel_input_port_forward_request(int is_root , int gateway_ports ) 
{ u_short port___0 ;
  u_short host_port ;
  char *hostname ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;

  {
#line 2564
  tmp = packet_get_int();
#line 2564
  port___0 = (unsigned short )tmp;
#line 2565
  tmp___0 = packet_get_string((u_int *)((void *)0));
#line 2565
  hostname = (char *)tmp___0;
#line 2566
  tmp___1 = packet_get_int();
#line 2566
  host_port = (unsigned short )tmp___1;
#line 2573
  if ((int )port___0 < 1024) {
#line 2573
    if (! is_root) {
#line 2574
      packet_disconnect("Requested forwarding of port %d but user is not root.", port___0);
    }
  }
#line 2577
  if ((int )host_port == 0) {
#line 2578
    packet_disconnect("Dynamic forwarding denied.");
  }
#line 2582
  channel_setup_local_fwd_listener((char const   *)((void *)0), port___0, (char const   *)hostname,
                                   host_port, gateway_ports);
#line 2586
  xfree((void *)hostname);
#line 2587
  return;
}
}
#line 2594 "channels.c"
void channel_permit_all_opens(void) 
{ 

  {
#line 2597
  if (num_permitted_opens == 0) {
#line 2598
    all_opens_permitted = 1;
  }
#line 2599
  return;
}
}
#line 2601 "channels.c"
void channel_add_permitted_opens(char *host , int port___0 ) 
{ 

  {
#line 2604
  if (num_permitted_opens >= 100) {
#line 2605
    fatal("channel_request_remote_forwarding: too many forwards");
  }
#line 2606
  debug("allow port forwarding to host %s port %d", host, port___0);
#line 2608
  permitted_opens[num_permitted_opens].host_to_connect = xstrdup((char const   *)host);
#line 2609
  permitted_opens[num_permitted_opens].port_to_connect = (unsigned short )port___0;
#line 2610
  num_permitted_opens ++;
#line 2612
  all_opens_permitted = 0;
#line 2613
  return;
}
}
#line 2615 "channels.c"
void channel_clear_permitted_opens(void) 
{ int i ;

  {
#line 2620
  i = 0;
#line 2620
  while (i < num_permitted_opens) {
#line 2621
    if ((unsigned int )permitted_opens[i].host_to_connect != (unsigned int )((void *)0)) {
#line 2622
      xfree((void *)permitted_opens[i].host_to_connect);
    }
#line 2620
    i ++;
  }
#line 2623
  num_permitted_opens = 0;
#line 2625
  return;
}
}
#line 2629 "channels.c"
static int connect_to(char const   *host , u_short port___0 ) 
{ struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char ntop[1025] ;
  char strport[32] ;
  int gaierr ;
  int sock ;
  char const   *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;

  {
#line 2635
  sock = -1;
#line 2637
  memset((void *)(& hints), 0, sizeof(hints));
#line 2638
  hints.ai_family = IPv4or6;
#line 2639
  hints.ai_socktype = 1;
#line 2640
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           port___0);
#line 2641
  gaierr = getaddrinfo((char const   * __restrict  )host, (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 2641
  if (gaierr != 0) {
#line 2642
    tmp = gai_strerror(gaierr);
#line 2642
    error("connect_to %.100s: unknown host (%s)", host, tmp);
#line 2644
    return (-1);
  }
#line 2646
  ai = aitop;
#line 2646
  while (ai) {
#line 2647
    if (ai->ai_family != 2) {
#line 2647
      if (ai->ai_family != 10) {
        goto __Cont;
      }
    }
#line 2649
    tmp___0 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                          (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )(strport),
                          sizeof(strport), 3U);
#line 2649
    if (tmp___0 != 0) {
#line 2651
      error("connect_to: getnameinfo failed");
      goto __Cont;
    }
#line 2654
    sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
#line 2655
    if (sock < 0) {
#line 2656
      if ((unsigned int )ai->ai_next == (unsigned int )((void *)0)) {
#line 2657
        tmp___1 = __errno_location();
#line 2657
        tmp___2 = strerror(*tmp___1);
#line 2657
        error("socket: %.100s", tmp___2);
      } else {
#line 2659
        tmp___3 = __errno_location();
#line 2659
        tmp___4 = strerror(*tmp___3);
#line 2659
        verbose("socket: %.100s", tmp___4);
      }
      goto __Cont;
    }
#line 2662
    tmp___5 = set_nonblock(sock);
#line 2662
    if (tmp___5 == -1) {
#line 2663
      fatal("%s: set_nonblock(%d)", "connect_to", sock);
    }
#line 2664
    tmp___8 = connect(sock, (struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen);
#line 2664
    if (tmp___8 < 0) {
#line 2664
      tmp___9 = __errno_location();
#line 2664
      if (*tmp___9 != 115) {
#line 2666
        tmp___6 = __errno_location();
#line 2666
        tmp___7 = strerror(*tmp___6);
#line 2666
        error("connect_to %.100s port %s: %.100s", ntop, strport, tmp___7);
#line 2668
        close(sock);
        goto __Cont;
      }
    }
#line 2671
    break;
    __Cont: /* CIL Label */ 
#line 2646
    ai = ai->ai_next;
  }
#line 2674
  freeaddrinfo(aitop);
#line 2675
  if (! ai) {
#line 2676
    error("connect_to %.100s port %d: failed.", host, port___0);
#line 2677
    return (-1);
  }
#line 2680
  set_nodelay(sock);
#line 2681
  return (sock);
}
}
#line 2684 "channels.c"
int channel_connect_by_listen_address(u_short listen_port ) 
{ int i ;
  int tmp ;

  {
#line 2689
  i = 0;
#line 2689
  while (i < num_permitted_opens) {
#line 2690
    if ((unsigned int )permitted_opens[i].host_to_connect != (unsigned int )((void *)0)) {
#line 2690
      if ((int )permitted_opens[i].listen_port == (int )listen_port) {
#line 2692
        tmp = connect_to((char const   *)permitted_opens[i].host_to_connect, permitted_opens[i].port_to_connect);
#line 2692
        return (tmp);
      }
    }
#line 2689
    i ++;
  }
#line 2695
  error("WARNING: Server requests forwarding for unknown listen_port %d", listen_port);
#line 2697
  return (-1);
}
}
#line 2701 "channels.c"
int channel_connect_to(char const   *host , u_short port___0 ) 
{ int i ;
  int permit ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 2706
  permit = all_opens_permitted;
#line 2707
  if (! permit) {
#line 2708
    i = 0;
#line 2708
    while (i < num_permitted_opens) {
#line 2711
      if ((unsigned int )permitted_opens[i].host_to_connect != (unsigned int )((void *)0)) {
#line 2711
        if ((int )permitted_opens[i].port_to_connect == (int )port___0) {
#line 2711
          if (0) {
#line 2711
            __s1_len = strlen((char const   *)permitted_opens[i].host_to_connect);
#line 2711
            __s2_len = strlen(host);
#line 2711
            if (! ((unsigned int )((void const   *)(permitted_opens[i].host_to_connect + 1)) - (unsigned int )((void const   *)permitted_opens[i].host_to_connect) == 1U)) {
              goto _L___0;
            } else {
#line 2711
              if (__s1_len >= 4U) {
                _L___0: /* CIL Label */ 
#line 2711
                if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
#line 2711
                  tmp___8 = 1;
                } else {
#line 2711
                  if (__s2_len >= 4U) {
#line 2711
                    tmp___8 = 1;
                  } else {
#line 2711
                    tmp___8 = 0;
                  }
                }
              } else {
#line 2711
                tmp___8 = 0;
              }
            }
#line 2711
            if (tmp___8) {
#line 2711
              tmp___4 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                         host);
            } else {
#line 2711
              tmp___7 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                         host);
#line 2711
              tmp___4 = tmp___7;
            }
          } else {
#line 2711
            tmp___7 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                       host);
#line 2711
            tmp___4 = tmp___7;
          }
#line 2711
          if (tmp___4 == 0) {
#line 2712
            permit = 1;
          }
        }
      }
#line 2708
      i ++;
    }
  }
#line 2715
  if (! permit) {
#line 2716
    logit("Received request to connect to host %.100s port %d, but the request was denied.",
          host, port___0);
#line 2718
    return (-1);
  }
#line 2720
  tmp___9 = connect_to(host, port___0);
#line 2720
  return (tmp___9);
}
}
#line 2723 "channels.c"
void channel_send_window_changes(void) 
{ u_int i ;
  struct winsize ws ;
  int tmp ;

  {
#line 2729
  i = 0U;
#line 2729
  while (i < channels_alloc) {
#line 2730
    if ((unsigned int )*(channels + i) == (unsigned int )((void *)0)) {
      goto __Cont;
    } else {
#line 2730
      if (! (*(channels + i))->client_tty) {
        goto __Cont;
      } else {
#line 2730
        if ((*(channels + i))->type != 4) {
          goto __Cont;
        }
      }
    }
#line 2733
    tmp = ioctl((*(channels + i))->rfd, 21523UL, & ws);
#line 2733
    if (tmp < 0) {
      goto __Cont;
    }
#line 2735
    channel_request_start((int )i, (char *)"window-change", 0);
#line 2736
    packet_put_int((unsigned int )ws.ws_col);
#line 2737
    packet_put_int((unsigned int )ws.ws_row);
#line 2738
    packet_put_int((unsigned int )ws.ws_xpixel);
#line 2739
    packet_put_int((unsigned int )ws.ws_ypixel);
#line 2740
    packet_send();
    __Cont: /* CIL Label */ 
#line 2729
    i ++;
  }
#line 2742
  return;
}
}
#line 2751 "channels.c"
int x11_create_display_inet(int x11_display_offset , int x11_use_localhost , int single_connection ,
                            u_int *display_numberp , int **chanids ) 
{ Channel *nc ;
  int display_number ;
  int sock ;
  u_short port___0 ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  int n___0 ;
  int num_socks ;
  int socks[10] ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int on ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  void *tmp___14 ;

  {
#line 2755
  nc = (Channel *)((void *)0);
#line 2760
  num_socks = 0;
#line 2762
  if ((unsigned int )chanids == (unsigned int )((void *)0)) {
#line 2763
    return (-1);
  }
#line 2765
  display_number = x11_display_offset;
#line 2765
  while (display_number < 1000) {
#line 2768
    port___0 = (unsigned short )(6000 + display_number);
#line 2769
    memset((void *)(& hints), 0, sizeof(hints));
#line 2770
    hints.ai_family = IPv4or6;
#line 2771
    if (x11_use_localhost) {
#line 2771
      hints.ai_flags = 0;
    } else {
#line 2771
      hints.ai_flags = 1;
    }
#line 2772
    hints.ai_socktype = 1;
#line 2773
    snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
             port___0);
#line 2774
    gaierr = getaddrinfo((char const   * __restrict  )((void *)0), (char const   * __restrict  )(strport),
                         (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 2774
    if (gaierr != 0) {
#line 2775
      tmp = gai_strerror(gaierr);
#line 2775
      error("getaddrinfo: %.100s", tmp);
#line 2776
      return (-1);
    }
#line 2778
    ai = aitop;
#line 2778
    while (ai) {
#line 2779
      if (ai->ai_family != 2) {
#line 2779
        if (ai->ai_family != 10) {
          goto __Cont;
        }
      }
#line 2781
      sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
#line 2783
      if (sock < 0) {
#line 2784
        tmp___2 = __errno_location();
#line 2784
        if (*tmp___2 != 22) {
#line 2784
          tmp___3 = __errno_location();
#line 2784
          if (*tmp___3 != 97) {
#line 2785
            tmp___0 = __errno_location();
#line 2785
            tmp___1 = strerror(*tmp___0);
#line 2785
            error("socket: %.100s", tmp___1);
#line 2786
            freeaddrinfo(aitop);
#line 2787
            return (-1);
          } else {
#line 2789
            debug("x11_create_display_inet: Socket family %d not supported", ai->ai_family);
            goto __Cont;
          }
        } else {
#line 2789
          debug("x11_create_display_inet: Socket family %d not supported", ai->ai_family);
          goto __Cont;
        }
      }
#line 2795
      if (ai->ai_family == 10) {
#line 2796
        on = 1;
#line 2797
        tmp___6 = setsockopt(sock, 41, 26, (void const   *)(& on), sizeof(on));
#line 2797
        if (tmp___6 < 0) {
#line 2798
          tmp___4 = __errno_location();
#line 2798
          tmp___5 = strerror(*tmp___4);
#line 2798
          error("setsockopt IPV6_V6ONLY: %.100s", tmp___5);
        }
      }
#line 2801
      channel_set_reuseaddr(sock);
#line 2802
      tmp___9 = bind(sock, (struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen);
#line 2802
      if (tmp___9 < 0) {
#line 2803
        tmp___7 = __errno_location();
#line 2803
        tmp___8 = strerror(*tmp___7);
#line 2803
        debug2("bind port %d: %.100s", port___0, tmp___8);
#line 2804
        close(sock);
#line 2806
        if (ai->ai_next) {
          goto __Cont;
        }
#line 2809
        n___0 = 0;
#line 2809
        while (n___0 < num_socks) {
#line 2810
          close(socks[n___0]);
#line 2809
          n___0 ++;
        }
#line 2812
        num_socks = 0;
#line 2813
        break;
      }
#line 2815
      tmp___10 = num_socks;
#line 2815
      num_socks ++;
#line 2815
      socks[tmp___10] = sock;
#line 2820
      if (x11_use_localhost) {
#line 2821
        if (num_socks == 10) {
#line 2822
          break;
        }
      } else {
#line 2824
        break;
      }
      __Cont: /* CIL Label */ 
#line 2778
      ai = ai->ai_next;
    }
#line 2828
    freeaddrinfo(aitop);
#line 2829
    if (num_socks > 0) {
#line 2830
      break;
    }
#line 2765
    display_number ++;
  }
#line 2832
  if (display_number >= 1000) {
#line 2833
    error("Failed to allocate internet-domain X11 display socket.");
#line 2834
    return (-1);
  }
#line 2837
  n___0 = 0;
#line 2837
  while (n___0 < num_socks) {
#line 2838
    sock = socks[n___0];
#line 2839
    tmp___13 = listen(sock, 128);
#line 2839
    if (tmp___13 < 0) {
#line 2840
      tmp___11 = __errno_location();
#line 2840
      tmp___12 = strerror(*tmp___11);
#line 2840
      error("listen: %.100s", tmp___12);
#line 2841
      close(sock);
#line 2842
      return (-1);
    }
#line 2837
    n___0 ++;
  }
#line 2847
  tmp___14 = xmalloc(sizeof(*(*chanids)) * (unsigned int )(num_socks + 1));
#line 2847
  *chanids = (int *)tmp___14;
#line 2848
  n___0 = 0;
#line 2848
  while (n___0 < num_socks) {
#line 2849
    sock = socks[n___0];
#line 2850
    nc = channel_new((char *)"x11 listener", 1, sock, sock, -1, 65536U, 16384U, 0,
                     (char *)"X11 inet listener", 1);
#line 2854
    nc->single_connection = single_connection;
#line 2855
    *(*chanids + n___0) = nc->self;
#line 2848
    n___0 ++;
  }
#line 2857
  *(*chanids + n___0) = -1;
#line 2860
  *display_numberp = (unsigned int )display_number;
#line 2861
  return (0);
}
}
#line 2864 "channels.c"
static int connect_local_xsocket(u_int dnr ) 
{ int sock ;
  struct sockaddr_un addr ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 2870
  sock = socket(1, 1, 0);
#line 2871
  if (sock < 0) {
#line 2872
    tmp = __errno_location();
#line 2872
    tmp___0 = strerror(*tmp);
#line 2872
    error("socket: %.100s", tmp___0);
  }
#line 2873
  memset((void *)(& addr), 0, sizeof(addr));
#line 2874
  addr.sun_family = (unsigned short)1;
#line 2875
  snprintf((char * __restrict  )(addr.sun_path), sizeof(addr.sun_path), (char const   * __restrict  )"/tmp/.X11-unix/X%u",
           dnr);
#line 2876
  tmp___1 = connect(sock, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& addr)),
                    sizeof(addr));
#line 2876
  if (tmp___1 == 0) {
#line 2877
    return (sock);
  }
#line 2878
  close(sock);
#line 2879
  tmp___2 = __errno_location();
#line 2879
  tmp___3 = strerror(*tmp___2);
#line 2879
  error("connect %.100s: %.100s", addr.sun_path, tmp___3);
#line 2880
  return (-1);
}
}
#line 2883 "channels.c"
int x11_connect_display(void) 
{ int display_number ;
  int sock ;
  char const   *display ;
  char buf___1[1024] ;
  char *cp ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___29 ;
  int tmp___30 ;
  char const   *tmp___31 ;
  int *tmp___32 ;
  char *tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  int *tmp___37 ;
  char *tmp___38 ;

  {
#line 2886
  sock = 0;
#line 2894
  tmp = getenv("DISPLAY");
#line 2894
  display = (char const   *)tmp;
#line 2895
  if (! display) {
#line 2896
    error("DISPLAY not set.");
#line 2897
    return (-1);
  }
#line 2908
  if (0) {
#line 2908
    if (0) {
#line 2908
      __s1_len___0 = strlen(display);
#line 2908
      __s2_len___0 = strlen("unix:");
#line 2908
      if (! ((unsigned int )((void const   *)(display + 1)) - (unsigned int )((void const   *)display) == 1U)) {
        goto _L___2;
      } else {
#line 2908
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 2908
          if (! ((unsigned int )((void const   *)("unix:" + 1)) - (unsigned int )((void const   *)"unix:") == 1U)) {
#line 2908
            tmp___25 = 1;
          } else {
#line 2908
            if (__s2_len___0 >= 4U) {
#line 2908
              tmp___25 = 1;
            } else {
#line 2908
              tmp___25 = 0;
            }
          }
        } else {
#line 2908
          tmp___25 = 0;
        }
      }
#line 2908
      if (tmp___25) {
#line 2908
        tmp___21 = __builtin_strcmp(display, "unix:");
      } else {
#line 2908
        tmp___24 = __builtin_strcmp(display, "unix:");
#line 2908
        tmp___21 = tmp___24;
      }
    } else {
#line 2908
      tmp___24 = __builtin_strcmp(display, "unix:");
#line 2908
      tmp___21 = tmp___24;
    }
#line 2908
    tmp___15 = tmp___21;
  } else {
#line 2908
    tmp___15 = strncmp(display, "unix:", 5U);
  }
#line 2908
  if (tmp___15 == 0) {
    goto _L___3;
  } else {
#line 2908
    if ((int const   )*(display + 0) == 58) {
      _L___3: /* CIL Label */ 
#line 2911
      tmp___0 = strrchr(display, ':');
#line 2911
      tmp___1 = sscanf((char const   * __restrict  )(tmp___0 + 1), (char const   * __restrict  )"%d",
                       & display_number);
#line 2911
      if (tmp___1 != 1) {
#line 2912
        error("Could not parse display number from DISPLAY: %.100s", display);
#line 2914
        return (-1);
      }
#line 2917
      sock = connect_local_xsocket((unsigned int )display_number);
#line 2918
      if (sock < 0) {
#line 2919
        return (-1);
      }
#line 2922
      return (sock);
    }
  }
#line 2928
  strlcpy(buf___1, display, sizeof(buf___1));
#line 2929
  tmp___29 = __builtin_strchr(buf___1, ':');
#line 2929
  cp = tmp___29;
#line 2930
  if (! cp) {
#line 2931
    error("Could not find \':\' in DISPLAY: %.100s", display);
#line 2932
    return (-1);
  }
#line 2934
  *cp = (char)0;
#line 2936
  tmp___30 = sscanf((char const   * __restrict  )(cp + 1), (char const   * __restrict  )"%d",
                    & display_number);
#line 2936
  if (tmp___30 != 1) {
#line 2937
    error("Could not parse display number from DISPLAY: %.100s", display);
#line 2939
    return (-1);
  }
#line 2943
  memset((void *)(& hints), 0, sizeof(hints));
#line 2944
  hints.ai_family = IPv4or6;
#line 2945
  hints.ai_socktype = 1;
#line 2946
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           6000 + display_number);
#line 2947
  gaierr = getaddrinfo((char const   * __restrict  )(buf___1), (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 2947
  if (gaierr != 0) {
#line 2948
    tmp___31 = gai_strerror(gaierr);
#line 2948
    error("%.100s: unknown host. (%s)", buf___1, tmp___31);
#line 2949
    return (-1);
  }
#line 2951
  ai = aitop;
#line 2951
  while (ai) {
#line 2953
    sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
#line 2954
    if (sock < 0) {
#line 2955
      tmp___32 = __errno_location();
#line 2955
      tmp___33 = strerror(*tmp___32);
#line 2955
      debug2("socket: %.100s", tmp___33);
      goto __Cont;
    }
#line 2959
    tmp___36 = connect(sock, (struct sockaddr  const  * __restrict  )ai->ai_addr,
                       ai->ai_addrlen);
#line 2959
    if (tmp___36 < 0) {
#line 2960
      tmp___34 = __errno_location();
#line 2960
      tmp___35 = strerror(*tmp___34);
#line 2960
      debug2("connect %.100s port %d: %.100s", buf___1, 6000 + display_number, tmp___35);
#line 2962
      close(sock);
      goto __Cont;
    }
#line 2966
    break;
    __Cont: /* CIL Label */ 
#line 2951
    ai = ai->ai_next;
  }
#line 2968
  freeaddrinfo(aitop);
#line 2969
  if (! ai) {
#line 2970
    tmp___37 = __errno_location();
#line 2970
    tmp___38 = strerror(*tmp___37);
#line 2970
    error("connect %.100s port %d: %.100s", buf___1, 6000 + display_number, tmp___38);
#line 2972
    return (-1);
  }
#line 2974
  set_nodelay(sock);
#line 2975
  return (sock);
}
}
#line 2984 "channels.c"
void x11_input_open(int type , u_int32_t seq , void *ctxt ) 
{ Channel *c ;
  int remote_id ;
  int sock ;
  char *remote_host ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  int _len ;
  int tmp___2 ;

  {
#line 2987
  c = (Channel *)((void *)0);
#line 2988
  sock = 0;
#line 2991
  debug("Received X11 open request.");
#line 2993
  tmp = packet_get_int();
#line 2993
  remote_id = (int )tmp;
#line 2995
  tmp___1 = packet_get_protocol_flags();
#line 2995
  if (tmp___1 & 2U) {
#line 2996
    tmp___0 = packet_get_string((u_int *)((void *)0));
#line 2996
    remote_host = (char *)tmp___0;
  } else {
#line 2998
    remote_host = xstrdup("unknown (remote did not supply name)");
  }
#line 3000
  while (1) {
#line 3000
    tmp___2 = packet_remaining();
#line 3000
    _len = tmp___2;
#line 3000
    if (_len > 0) {
#line 3000
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            3000);
#line 3000
      packet_disconnect("Packet integrity error.");
    }
#line 3000
    break;
  }
#line 3003
  sock = x11_connect_display();
#line 3004
  if (sock != -1) {
#line 3006
    c = channel_new((char *)"connected x11 socket", 7, sock, sock, -1, 0U, 0U, 0,
                    remote_host, 1);
#line 3009
    c->remote_id = remote_id;
#line 3010
    c->force_drain = 1;
  }
#line 3012
  xfree((void *)remote_host);
#line 3013
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 3015
    packet_start((unsigned char)22);
#line 3016
    packet_put_int((unsigned int )remote_id);
  } else {
#line 3019
    packet_start((unsigned char)21);
#line 3020
    packet_put_int((unsigned int )remote_id);
#line 3021
    packet_put_int((unsigned int )c->self);
  }
#line 3023
  packet_send();
#line 3024
  return;
}
}
#line 3027 "channels.c"
void deny_input_open(int type , u_int32_t seq , void *ctxt ) 
{ int rchan ;
  u_int tmp ;

  {
#line 3030
  tmp = packet_get_int();
#line 3030
  rchan = (int )tmp;
#line 3032
  switch (type) {
  case 31: 
#line 3034
  error("Warning: ssh server tried agent forwarding.");
#line 3035
  break;
  case 27: 
#line 3037
  error("Warning: ssh server tried X11 forwarding.");
#line 3038
  break;
  default: 
#line 3040
  error("deny_input_open: type %d", type);
#line 3041
  break;
  }
#line 3043
  error("Warning: this is probably a break-in attempt by a malicious server.");
#line 3044
  packet_start((unsigned char)22);
#line 3045
  packet_put_int((unsigned int )rchan);
#line 3046
  packet_send();
#line 3047
  return;
}
}
#line 3054 "channels.c"
void x11_request_forwarding_with_spoofing(int client_session_id , char const   *disp ,
                                          char const   *proto , char const   *data ) 
{ u_int data_len ;
  size_t tmp ;
  u_int i ;
  u_int value ;
  char *new_data ;
  int screen_number ;
  char const   *cp ;
  u_int32_t rnd ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___11 ;
  char *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  int tmp___16 ;

  {
#line 3058
  tmp = strlen(data);
#line 3058
  data_len = tmp / 2U;
#line 3063
  rnd = (u_int32_t )0;
#line 3065
  if ((unsigned int )x11_saved_display == (unsigned int )((void *)0)) {
#line 3066
    x11_saved_display = xstrdup(disp);
  } else {
#line 3067
    if (0) {
#line 3067
      __s1_len = strlen(disp);
#line 3067
      __s2_len = strlen((char const   *)x11_saved_display);
#line 3067
      if (! ((unsigned int )((void const   *)(disp + 1)) - (unsigned int )((void const   *)disp) == 1U)) {
        goto _L___0;
      } else {
#line 3067
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 3067
          if (! ((unsigned int )((void const   *)(x11_saved_display + 1)) - (unsigned int )((void const   *)x11_saved_display) == 1U)) {
#line 3067
            tmp___9 = 1;
          } else {
#line 3067
            if (__s2_len >= 4U) {
#line 3067
              tmp___9 = 1;
            } else {
#line 3067
              tmp___9 = 0;
            }
          }
        } else {
#line 3067
          tmp___9 = 0;
        }
      }
#line 3067
      if (tmp___9) {
#line 3067
        tmp___5 = __builtin_strcmp(disp, (char const   *)x11_saved_display);
      } else {
#line 3067
        tmp___8 = __builtin_strcmp(disp, (char const   *)x11_saved_display);
#line 3067
        tmp___5 = tmp___8;
      }
    } else {
#line 3067
      tmp___8 = __builtin_strcmp(disp, (char const   *)x11_saved_display);
#line 3067
      tmp___5 = tmp___8;
    }
#line 3067
    if (tmp___5 != 0) {
#line 3068
      error("x11_request_forwarding_with_spoofing: different $DISPLAY already forwarded");
#line 3070
      return;
    }
  }
#line 3073
  cp = disp;
#line 3074
  if (disp) {
#line 3075
    tmp___11 = __builtin_strchr((char *)disp, ':');
#line 3075
    cp = (char const   *)tmp___11;
  }
#line 3076
  if (cp) {
#line 3077
    tmp___13 = __builtin_strchr((char *)cp, '.');
#line 3077
    cp = (char const   *)tmp___13;
  }
#line 3078
  if (cp) {
#line 3079
    screen_number = atoi(cp + 1);
  } else {
#line 3081
    screen_number = 0;
  }
#line 3083
  if ((unsigned int )x11_saved_proto == (unsigned int )((void *)0)) {
#line 3085
    x11_saved_proto = xstrdup(proto);
#line 3090
    tmp___14 = xmalloc(data_len);
#line 3090
    x11_saved_data = (char *)tmp___14;
#line 3091
    tmp___15 = xmalloc(data_len);
#line 3091
    x11_fake_data = (char *)tmp___15;
#line 3092
    i = 0U;
#line 3092
    while (i < data_len) {
#line 3093
      tmp___16 = sscanf((char const   * __restrict  )(data + 2U * i), (char const   * __restrict  )"%2x",
                        & value);
#line 3093
      if (tmp___16 != 1) {
#line 3094
        fatal("x11_request_forwarding: bad authentication data: %.100s", data);
      }
#line 3096
      if (i % 4U == 0U) {
#line 3097
        rnd = arc4random();
      }
#line 3098
      *(x11_saved_data + i) = (char )value;
#line 3099
      *(x11_fake_data + i) = (char )(rnd & 255U);
#line 3100
      rnd >>= 8;
#line 3092
      i ++;
    }
#line 3102
    x11_saved_data_len = data_len;
#line 3103
    x11_fake_data_len = data_len;
  }
#line 3107
  new_data = tohex((u_char const   *)x11_fake_data, data_len);
#line 3110
  if (compat20) {
#line 3111
    channel_request_start(client_session_id, (char *)"x11-req", 0);
#line 3112
    packet_put_char(0);
  } else {
#line 3114
    packet_start((unsigned char)34);
  }
#line 3116
  packet_put_cstring(proto);
#line 3117
  packet_put_cstring((char const   *)new_data);
#line 3118
  packet_put_int((unsigned int )screen_number);
#line 3119
  packet_send();
#line 3120
  packet_write_wait();
#line 3121
  xfree((void *)new_data);
#line 3122
  return;
}
}
#line 3129 "channels.c"
void auth_request_forwarding(void) 
{ 

  {
#line 3132
  packet_start((unsigned char)30);
#line 3133
  packet_send();
#line 3134
  packet_write_wait();
#line 3135
  return;
}
}
#line 1 "cipher.o"
#line 325 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 1205 "/usr/include/bits/string2.h"
extern char *__strsep_g(char **__stringp , char const   *__delim ) ;
#line 527 "/usr/include/openssl/evp.h"
extern int EVP_CipherInit(EVP_CIPHER_CTX *ctx , EVP_CIPHER const   *cipher , unsigned char const   *key ,
                          unsigned char const   *iv , int enc ) ;
#line 567
extern void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *a ) ;
#line 568
extern int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *a ) ;
#line 571
extern int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x , int keylen ) ;
#line 613
extern EVP_CIPHER const   *EVP_enc_null(void) ;
#line 637
extern EVP_CIPHER const   *EVP_des_cbc(void) ;
#line 652
extern EVP_CIPHER const   *EVP_rc4(void) ;
#line 666
extern EVP_CIPHER const   *EVP_bf_cbc(void) ;
#line 673
extern EVP_CIPHER const   *EVP_cast5_cbc(void) ;
#line 71 "cipher.h"
u_int cipher_mask_ssh1(int client ) ;
#line 72
Cipher *cipher_by_name(char const   *name ) ;
#line 74
int cipher_number(char const   *name ) ;
#line 75
char *cipher_name(int id ) ;
#line 76
int ciphers_valid(char const   *names ) ;
#line 77
void cipher_init(CipherContext *cc , Cipher *cipher , u_char const   *key , u_int keylen ,
                 u_char const   *iv , u_int ivlen , int do_encrypt ) ;
#line 82
u_int cipher_blocksize(Cipher const   *c ) ;
#line 83
u_int cipher_keylen(Cipher const   *c ) ;
#line 85
u_int cipher_get_number(Cipher const   *c ) ;
#line 86
void cipher_get_keyiv(CipherContext *cc , u_char *iv , u_int len ) ;
#line 87
void cipher_set_keyiv(CipherContext *cc , u_char *iv ) ;
#line 88
int cipher_get_keyiv_len(CipherContext const   *cc ) ;
#line 89
int cipher_get_keycontext(CipherContext const   *cc , u_char *dat ) ;
#line 90
void cipher_set_keycontext(CipherContext *cc , u_char *dat ) ;
#line 107 "/usr/include/openssl/md5.h"
extern int MD5_Init(MD5_CTX *c ) ;
#line 108
extern int MD5_Update(MD5_CTX *c , void const   *data , size_t len ) ;
#line 109
extern int MD5_Final(unsigned char *md , MD5_CTX *c ) ;
#line 35 "openbsd-compat/openssl-compat.h"
EVP_CIPHER const   *evp_rijndael(void) ;
#line 36
void ssh_rijndael_iv(EVP_CIPHER_CTX *evp , int doset , u_char *iv , u_int len ) ;
#line 42
EVP_CIPHER const   *evp_acss(void) ;
#line 49 "cipher.c"
EVP_CIPHER const   *evp_ssh1_bf(void) ;
#line 50
EVP_CIPHER const   *evp_ssh1_3des(void) ;
#line 51
void ssh1_3des_iv(EVP_CIPHER_CTX *evp , int doset , u_char *iv , int len ) ;
#line 52
EVP_CIPHER const   *evp_aes_128_ctr(void) ;
#line 53
void ssh_aes_ctr_iv(EVP_CIPHER_CTX *evp , int doset , u_char *iv , u_int len ) ;
#line 55 "cipher.c"
struct Cipher ciphers[19]  = 
#line 55
  {      {(char *)"none", 0, (u_int )8, (u_int )0, (u_int )0, & EVP_enc_null}, 
        {(char *)"des", 2, (u_int )8, (u_int )8, (u_int )0, & EVP_des_cbc}, 
        {(char *)"3des", 3, (u_int )8, (u_int )16, (u_int )0, & evp_ssh1_3des}, 
        {(char *)"blowfish", 6, (u_int )8, (u_int )32, (u_int )0, & evp_ssh1_bf}, 
        {(char *)"3des-cbc", -3, (u_int )8, (u_int )24, (u_int )0, & EVP_des_ede3_cbc}, 
        {(char *)"blowfish-cbc",
      -3, (u_int )8, (u_int )16, (u_int )0, & EVP_bf_cbc}, 
        {(char *)"cast128-cbc", -3, (u_int )8, (u_int )16, (u_int )0, & EVP_cast5_cbc}, 
        {(char *)"arcfour",
      -3, (u_int )8, (u_int )16, (u_int )0, & EVP_rc4}, 
        {(char *)"arcfour128", -3, (u_int )8, (u_int )16, (u_int )1536, & EVP_rc4}, 
        {(char *)"arcfour256", -3, (u_int )8, (u_int )32, (u_int )1536, & EVP_rc4}, 
        {(char *)"aes128-cbc", -3, (u_int )16, (u_int )16, (u_int )0, & evp_rijndael}, 
        {(char *)"aes192-cbc",
      -3, (u_int )16, (u_int )24, (u_int )0, & evp_rijndael}, 
        {(char *)"aes256-cbc", -3, (u_int )16, (u_int )32, (u_int )0, & evp_rijndael}, 
        {(char *)"rijndael-cbc@lysator.liu.se",
      -3, (u_int )16, (u_int )32, (u_int )0, & evp_rijndael}, 
        {(char *)"aes128-ctr", -3, (u_int )16, (u_int )16, (u_int )0, & evp_aes_128_ctr}, 
        {(char *)"aes192-ctr",
      -3, (u_int )16, (u_int )24, (u_int )0, & evp_aes_128_ctr}, 
        {(char *)"aes256-ctr", -3, (u_int )16, (u_int )32, (u_int )0, & evp_aes_128_ctr}, 
        {(char *)"acss@openssh.org",
      -3, (u_int )16, (u_int )5, (u_int )0, & evp_acss}, 
        {(char *)((void *)0), -2, (u_int )0, (u_int )0, (u_int )0, (EVP_CIPHER const   *(*)(void))((void *)0)}};
#line 90 "cipher.c"
u_int cipher_blocksize(Cipher const   *c ) 
{ 

  {
#line 93
  return ((unsigned int )c->block_size);
}
}
#line 96 "cipher.c"
u_int cipher_keylen(Cipher const   *c ) 
{ 

  {
#line 99
  return ((unsigned int )c->key_len);
}
}
#line 102 "cipher.c"
u_int cipher_get_number(Cipher const   *c ) 
{ 

  {
#line 105
  return ((unsigned int )c->number);
}
}
#line 108 "cipher.c"
u_int cipher_mask_ssh1(int client ) 
{ u_int mask ;

  {
#line 111
  mask = (u_int )0;
#line 112
  mask |= (unsigned int )(1 << 3);
#line 113
  mask |= (unsigned int )(1 << 6);
#line 114
  if (client) {
#line 115
    mask |= (unsigned int )(1 << 2);
  }
#line 117
  return (mask);
}
}
#line 120 "cipher.c"
Cipher *cipher_by_name(char const   *name ) 
{ Cipher *c ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 124
  c = ciphers;
#line 124
  while ((unsigned int )c->name != (unsigned int )((void *)0)) {
#line 125
    if (0) {
#line 125
      __s1_len = strlen((char const   *)c->name);
#line 125
      __s2_len = strlen(name);
#line 125
      if (! ((unsigned int )((void const   *)(c->name + 1)) - (unsigned int )((void const   *)c->name) == 1U)) {
        goto _L___0;
      } else {
#line 125
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 125
          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
#line 125
            tmp___8 = 1;
          } else {
#line 125
            if (__s2_len >= 4U) {
#line 125
              tmp___8 = 1;
            } else {
#line 125
              tmp___8 = 0;
            }
          }
        } else {
#line 125
          tmp___8 = 0;
        }
      }
#line 125
      if (tmp___8) {
#line 125
        tmp___4 = __builtin_strcmp((char const   *)c->name, name);
      } else {
#line 125
        tmp___7 = __builtin_strcmp((char const   *)c->name, name);
#line 125
        tmp___4 = tmp___7;
      }
    } else {
#line 125
      tmp___7 = __builtin_strcmp((char const   *)c->name, name);
#line 125
      tmp___4 = tmp___7;
    }
#line 125
    if (tmp___4 == 0) {
#line 126
      return (c);
    }
#line 124
    c ++;
  }
#line 127
  return ((Cipher *)((void *)0));
}
}
#line 130 "cipher.c"
Cipher *cipher_by_number(int id ) 
{ Cipher *c ;

  {
#line 134
  c = ciphers;
#line 134
  while ((unsigned int )c->name != (unsigned int )((void *)0)) {
#line 135
    if (c->number == id) {
#line 136
      return (c);
    }
#line 134
    c ++;
  }
#line 137
  return ((Cipher *)((void *)0));
}
}
#line 141 "cipher.c"
int ciphers_valid(char const   *names ) 
{ Cipher *c ;
  char *cipher_list ;
  char *cp ;
  char *p ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___24 ;
  char *tmp___40 ;

  {
#line 148
  if ((unsigned int )names == (unsigned int )((void *)0)) {
#line 149
    return (0);
  } else {
#line 148
    if (0) {
#line 148
      __s1_len = strlen(names);
#line 148
      __s2_len = strlen("");
#line 148
      if (! ((unsigned int )((void const   *)(names + 1)) - (unsigned int )((void const   *)names) == 1U)) {
        goto _L___0;
      } else {
#line 148
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 148
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 148
            tmp___8 = 1;
          } else {
#line 148
            if (__s2_len >= 4U) {
#line 148
              tmp___8 = 1;
            } else {
#line 148
              tmp___8 = 0;
            }
          }
        } else {
#line 148
          tmp___8 = 0;
        }
      }
#line 148
      if (tmp___8) {
#line 148
        tmp___4 = __builtin_strcmp(names, "");
      } else {
#line 148
        tmp___7 = __builtin_strcmp(names, "");
#line 148
        tmp___4 = tmp___7;
      }
    } else {
#line 148
      tmp___7 = __builtin_strcmp(names, "");
#line 148
      tmp___4 = tmp___7;
    }
#line 148
    if (tmp___4 == 0) {
#line 149
      return (0);
    }
  }
#line 150
  cp = xstrdup(names);
#line 150
  cipher_list = cp;
#line 151
  tmp___24 = __strsep_g(& cp, ",");
#line 151
  p = tmp___24;
#line 151
  while (1) {
#line 151
    if (p) {
#line 151
      if (! ((int )*p != 0)) {
#line 151
        break;
      }
    } else {
#line 151
      break;
    }
#line 153
    c = cipher_by_name((char const   *)p);
#line 154
    if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 155
      debug("bad cipher %s [%s]", p, names);
#line 156
      xfree((void *)cipher_list);
#line 157
      return (0);
    } else {
#line 154
      if (c->number != -3) {
#line 155
        debug("bad cipher %s [%s]", p, names);
#line 156
        xfree((void *)cipher_list);
#line 157
        return (0);
      } else {
#line 159
        debug3("cipher ok: %s [%s]", p, names);
      }
    }
#line 152
    tmp___40 = __strsep_g(& cp, ",");
#line 152
    p = tmp___40;
  }
#line 162
  debug3("ciphers ok: [%s]", names);
#line 163
  xfree((void *)cipher_list);
#line 164
  return (1);
}
}
#line 172 "cipher.c"
int cipher_number(char const   *name ) 
{ Cipher *c ;
  int tmp ;

  {
#line 176
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 177
    return (-1);
  }
#line 178
  c = ciphers;
#line 178
  while ((unsigned int )c->name != (unsigned int )((void *)0)) {
#line 179
    tmp = strcasecmp((char const   *)c->name, name);
#line 179
    if (tmp == 0) {
#line 180
      return (c->number);
    }
#line 178
    c ++;
  }
#line 181
  return (-1);
}
}
#line 184 "cipher.c"
char *cipher_name(int id ) 
{ Cipher *c ;
  Cipher *tmp ;
  char const   *tmp___0 ;

  {
#line 187
  tmp = cipher_by_number(id);
#line 187
  c = tmp;
#line 188
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 188
    tmp___0 = "<unknown>";
  } else {
#line 188
    tmp___0 = (char const   *)c->name;
  }
#line 188
  return ((char *)tmp___0);
}
}
#line 196 "cipher.c"
static int dowarn  =    1;
#line 191 "cipher.c"
void cipher_init(CipherContext *cc , Cipher *cipher , u_char const   *key , u_int keylen ,
                 u_char const   *iv , u_int ivlen , int do_encrypt ) 
{ EVP_CIPHER const   *type ;
  int klen ;
  u_char *junk ;
  u_char *discard ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
#line 205
  if (cipher->number == 2) {
#line 206
    if (dowarn) {
#line 207
      error("Warning: use of DES is strongly discouraged due to cryptographic weaknesses");
#line 209
      dowarn = 0;
    }
#line 211
    if (keylen > 8U) {
#line 212
      keylen = 8U;
    }
  }
#line 214
  cc->plaintext = cipher->number == 0;
#line 216
  if (keylen < cipher->key_len) {
#line 217
    fatal("cipher_init: key length %d is insufficient for %s.", keylen, cipher->name);
  }
#line 219
  if ((unsigned int )iv != (unsigned int )((void *)0)) {
#line 219
    if (ivlen < cipher->block_size) {
#line 220
      fatal("cipher_init: iv length %d is insufficient for %s.", ivlen, cipher->name);
    }
  }
#line 222
  cc->cipher = cipher;
#line 224
  type = (*(cipher->evptype))();
#line 226
  EVP_CIPHER_CTX_init(& cc->evp);
#line 236
  tmp = EVP_CipherInit(& cc->evp, type, (unsigned char const   *)((void *)0), (unsigned char const   *)((u_char *)iv),
                       do_encrypt == 1);
#line 236
  if (tmp == 0) {
#line 238
    fatal("cipher_init: EVP_CipherInit failed for %s", cipher->name);
  }
#line 240
  klen = cc->evp.key_len;
#line 241
  if (klen > 0) {
#line 241
    if (keylen != (unsigned int )klen) {
#line 242
      debug2("cipher_init: set keylen (%d -> %d)", klen, keylen);
#line 243
      tmp___0 = EVP_CIPHER_CTX_set_key_length(& cc->evp, (int )keylen);
#line 243
      if (tmp___0 == 0) {
#line 244
        fatal("cipher_init: set keylen failed (%d -> %d)", klen, keylen);
      }
    }
  }
#line 247
  tmp___1 = EVP_CipherInit(& cc->evp, (EVP_CIPHER const   *)((void *)0), (unsigned char const   *)((u_char *)key),
                           (unsigned char const   *)((void *)0), -1);
#line 247
  if (tmp___1 == 0) {
#line 248
    fatal("cipher_init: EVP_CipherInit: set key failed for %s", cipher->name);
  }
#line 252
  if (cipher->discard_len > 0U) {
#line 253
    tmp___2 = xmalloc(cipher->discard_len);
#line 253
    junk = (u_char *)tmp___2;
#line 254
    tmp___3 = xmalloc(cipher->discard_len);
#line 254
    discard = (u_char *)tmp___3;
#line 255
    tmp___4 = (*((cc->evp.cipher)->do_cipher))(& cc->evp, discard, (unsigned char const   *)junk,
                                               cipher->discard_len);
#line 255
    if (tmp___4 == 0) {
#line 257
      fatal("evp_crypt: EVP_Cipher failed during discard");
    }
#line 258
    memset((void *)discard, 0, cipher->discard_len);
#line 259
    xfree((void *)junk);
#line 260
    xfree((void *)discard);
  }
#line 262
  return;
}
}
#line 264 "cipher.c"
void cipher_crypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ int tmp ;

  {
#line 267
  if (len % (cc->cipher)->block_size) {
#line 268
    fatal("cipher_encrypt: bad plaintext length %d", len);
  }
#line 269
  tmp = (*((cc->evp.cipher)->do_cipher))(& cc->evp, dest, (unsigned char const   *)((u_char *)src),
                                         len);
#line 269
  if (tmp == 0) {
#line 270
    fatal("evp_crypt: EVP_Cipher failed");
  }
#line 271
  return;
}
}
#line 273 "cipher.c"
void cipher_cleanup(CipherContext *cc ) 
{ int tmp ;

  {
#line 276
  tmp = EVP_CIPHER_CTX_cleanup(& cc->evp);
#line 276
  if (tmp == 0) {
#line 277
    error("cipher_cleanup: EVP_CIPHER_CTX_cleanup failed");
  }
#line 278
  return;
}
}
#line 285 "cipher.c"
void cipher_set_key_string(CipherContext *cc , Cipher *cipher , char const   *passphrase ,
                           int do_encrypt ) 
{ MD5_CTX md ;
  u_char digest___1[16] ;
  size_t tmp ;

  {
#line 292
  MD5_Init(& md);
#line 293
  tmp = strlen(passphrase);
#line 293
  MD5_Update(& md, (void const   *)((u_char const   *)passphrase), tmp);
#line 294
  MD5_Final(digest___1, & md);
#line 296
  cipher_init(cc, cipher, (u_char const   *)(digest___1), 16U, (u_char const   *)((void *)0),
              0U, do_encrypt);
#line 298
  memset((void *)(digest___1), 0, sizeof(digest___1));
#line 299
  memset((void *)(& md), 0, sizeof(md));
#line 300
  return;
}
}
#line 308 "cipher.c"
int cipher_get_keyiv_len(CipherContext const   *cc ) 
{ Cipher *c ;
  int ivlen ;

  {
#line 311
  c = (Cipher *)cc->cipher;
#line 314
  if (c->number == 3) {
#line 315
    ivlen = 24;
  } else {
#line 317
    ivlen = (int )(cc->evp.cipher)->iv_len;
  }
#line 318
  return (ivlen);
}
}
#line 321 "cipher.c"
void cipher_get_keyiv(CipherContext *cc , u_char *iv , u_int len ) 
{ Cipher *c ;
  int evplen ;

  {
#line 324
  c = cc->cipher;
#line 327
  switch (c->number) {
  case -3: 
  case 2: 
  case 6: 
#line 331
  evplen = (int )(cc->evp.cipher)->iv_len;
#line 332
  if (evplen <= 0) {
#line 333
    return;
  }
#line 334
  if ((unsigned int )evplen != len) {
#line 335
    fatal("%s: wrong iv length %d != %d", "cipher_get_keyiv", evplen, len);
  }
#line 338
  if ((unsigned int )c->evptype == (unsigned int )(& evp_rijndael)) {
#line 339
    ssh_rijndael_iv(& cc->evp, 0, iv, len);
  } else {
#line 342
    if ((unsigned int )c->evptype == (unsigned int )(& evp_aes_128_ctr)) {
#line 343
      ssh_aes_ctr_iv(& cc->evp, 0, iv, len);
    } else {
#line 345
      memcpy((void * __restrict  )iv, (void const   * __restrict  )(cc->evp.iv), len);
    }
  }
#line 346
  break;
  case 3: 
#line 348
  ssh1_3des_iv(& cc->evp, 0, iv, 24);
#line 349
  break;
  default: 
#line 351
  fatal("%s: bad cipher %d", "cipher_get_keyiv", c->number);
  }
#line 353
  return;
}
}
#line 355 "cipher.c"
void cipher_set_keyiv(CipherContext *cc , u_char *iv ) 
{ Cipher *c ;
  int evplen ;

  {
#line 358
  c = cc->cipher;
#line 359
  evplen = 0;
#line 361
  switch (c->number) {
  case -3: 
  case 2: 
  case 6: 
#line 365
  evplen = (int )(cc->evp.cipher)->iv_len;
#line 366
  if (evplen == 0) {
#line 367
    return;
  }
#line 369
  if ((unsigned int )c->evptype == (unsigned int )(& evp_rijndael)) {
#line 370
    ssh_rijndael_iv(& cc->evp, 1, iv, (unsigned int )evplen);
  } else {
#line 373
    if ((unsigned int )c->evptype == (unsigned int )(& evp_aes_128_ctr)) {
#line 374
      ssh_aes_ctr_iv(& cc->evp, 1, iv, (unsigned int )evplen);
    } else {
#line 376
      memcpy((void * __restrict  )(cc->evp.iv), (void const   * __restrict  )iv, (unsigned int )evplen);
    }
  }
#line 377
  break;
  case 3: 
#line 379
  ssh1_3des_iv(& cc->evp, 1, iv, 24);
#line 380
  break;
  default: 
#line 382
  fatal("%s: bad cipher %d", "cipher_set_keyiv", c->number);
  }
#line 384
  return;
}
}
#line 394 "cipher.c"
int cipher_get_keycontext(CipherContext const   *cc , u_char *dat ) 
{ Cipher *c ;
  int plen ;

  {
#line 397
  c = (Cipher *)cc->cipher;
#line 398
  plen = 0;
#line 400
  if ((unsigned int )c->evptype == (unsigned int )(& EVP_rc4)) {
    goto _L;
  } else {
#line 400
    if ((unsigned int )c->evptype == (unsigned int )(& evp_acss)) {
      _L: /* CIL Label */ 
#line 401
      plen = (int )(cc->evp.cipher)->ctx_size;
#line 402
      if ((unsigned int )dat == (unsigned int )((void *)0)) {
#line 403
        return (plen);
      }
#line 404
      memcpy((void * __restrict  )dat, (void const   * __restrict  )cc->evp.cipher_data,
             (unsigned int )plen);
    }
  }
#line 406
  return (plen);
}
}
#line 409 "cipher.c"
void cipher_set_keycontext(CipherContext *cc , u_char *dat ) 
{ Cipher *c ;
  int plen ;

  {
#line 412
  c = cc->cipher;
#line 415
  if ((unsigned int )c->evptype == (unsigned int )(& EVP_rc4)) {
#line 416
    plen = (int )(cc->evp.cipher)->ctx_size;
#line 417
    memcpy((void * __restrict  )cc->evp.cipher_data, (void const   * __restrict  )dat,
           (unsigned int )plen);
  } else {
#line 415
    if ((unsigned int )c->evptype == (unsigned int )(& evp_acss)) {
#line 416
      plen = (int )(cc->evp.cipher)->ctx_size;
#line 417
      memcpy((void * __restrict  )cc->evp.cipher_data, (void const   * __restrict  )dat,
             (unsigned int )plen);
    }
  }
#line 419
  return;
}
}
#line 1 "cipher-acss.o"
#line 35 "cipher-acss.c"
static int acss_init_key(EVP_CIPHER_CTX *ctx , unsigned char const   *key , unsigned char const   *iv ,
                         int enc ) 
{ 

  {
#line 39
  acss_setkey(& ((EVP_ACSS_KEY *)ctx->cipher_data)->ks, key, enc, 3);
#line 40
  return (1);
}
}
#line 43 "cipher-acss.c"
static int acss_ciph(EVP_CIPHER_CTX *ctx , unsigned char *out , unsigned char const   *in ,
                     unsigned int inl ) 
{ 

  {
#line 47
  acss(& ((EVP_ACSS_KEY *)ctx->cipher_data)->ks, (unsigned long )inl, in, out);
#line 48
  return (1);
}
}
#line 51 "cipher-acss.c"
static int acss_ctrl(EVP_CIPHER_CTX *ctx , int type , int arg , void *ptr ) 
{ 

  {
#line 54
  switch (type) {
  case 65286: 
#line 56
  ((EVP_ACSS_KEY *)ctx->cipher_data)->ks.mode = arg;
#line 57
  return (1);
  case 65287: 
#line 59
  acss_setsubkey(& ((EVP_ACSS_KEY *)ctx->cipher_data)->ks, (unsigned char const   *)((unsigned char *)ptr));
#line 60
  return (1);
  default: ;
#line 62
  return (-1);
  }
}
}
#line 69 "cipher-acss.c"
static EVP_CIPHER acss_cipher  ;
#line 66 "cipher-acss.c"
EVP_CIPHER const   *evp_acss(void) 
{ 

  {
#line 71
  memset((void *)(& acss_cipher), 0, sizeof(EVP_CIPHER ));
#line 73
  acss_cipher.nid = 0;
#line 74
  acss_cipher.block_size = 1;
#line 75
  acss_cipher.key_len = 5;
#line 76
  acss_cipher.init = & acss_init_key;
#line 77
  acss_cipher.do_cipher = & acss_ciph;
#line 78
  acss_cipher.ctx_size = (int )sizeof(EVP_ACSS_KEY );
#line 79
  acss_cipher.ctrl = & acss_ctrl;
#line 81
  return ((EVP_CIPHER const   *)(& acss_cipher));
}
}
#line 1 "cipher-aes.o"
#line 47 "rijndael.h"
void rijndael_set_key(rijndael_ctx *ctx , u_char *key , int bits , int do_encrypt ) ;
#line 48
void rijndael_decrypt(rijndael_ctx *ctx , u_char *src , u_char *dst ) ;
#line 49
void rijndael_encrypt(rijndael_ctx *ctx , u_char *src , u_char *dst ) ;
#line 48 "cipher-aes.c"
static int ssh_rijndael_init(EVP_CIPHER_CTX *ctx , u_char const   *key , u_char const   *iv ,
                             int enc ) 
{ struct ssh_rijndael_ctx *c ;
  void *tmp ;

  {
#line 54
  c = (struct ssh_rijndael_ctx *)ctx->app_data;
#line 54
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 55
    tmp = xmalloc(sizeof(*c));
#line 55
    c = (struct ssh_rijndael_ctx *)tmp;
#line 56
    ctx->app_data = (void *)((char *)c);
  }
#line 58
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 59
    if (enc == -1) {
#line 60
      enc = ctx->encrypt;
    }
#line 61
    rijndael_set_key(& c->r_ctx, (u_char *)key, 8 * ctx->key_len, enc);
  }
#line 64
  if ((unsigned int )iv != (unsigned int )((void *)0)) {
#line 65
    memcpy((void * __restrict  )(c->r_iv), (void const   * __restrict  )iv, 16U);
  }
#line 66
  return (1);
}
}
#line 69 "cipher-aes.c"
static int ssh_rijndael_cbc(EVP_CIPHER_CTX *ctx , u_char *dest , u_char const   *src ,
                            u_int len ) 
{ struct ssh_rijndael_ctx *c ;
  u_char buf___1[16] ;
  u_char *cprev ;
  u_char *cnow ;
  u_char *plain ;
  u_char *ivp ;
  int i ;
  int j ;
  int blocks ;

  {
#line 76
  blocks = (int )(len / 16U);
#line 78
  if (len == 0U) {
#line 79
    return (1);
  }
#line 80
  if (len % 16U) {
#line 81
    fatal("ssh_rijndael_cbc: bad len %d", len);
  }
#line 82
  c = (struct ssh_rijndael_ctx *)ctx->app_data;
#line 82
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 83
    error("ssh_rijndael_cbc: no context");
#line 84
    return (0);
  }
#line 86
  if (ctx->encrypt) {
#line 87
    cnow = dest;
#line 88
    plain = (u_char *)src;
#line 89
    cprev = c->r_iv;
#line 90
    i = 0;
#line 90
    while (i < blocks) {
#line 92
      j = 0;
#line 92
      while (j < 16) {
#line 93
        buf___1[j] = (unsigned char )((int )*(plain + j) ^ (int )*(cprev + j));
#line 92
        j ++;
      }
#line 94
      rijndael_encrypt(& c->r_ctx, buf___1, cnow);
#line 95
      cprev = cnow;
#line 90
      i ++;
#line 90
      plain += 16;
#line 90
      cnow += 16;
    }
#line 97
    memcpy((void * __restrict  )(c->r_iv), (void const   * __restrict  )cprev, 16U);
  } else {
#line 99
    cnow = (u_char *)((src + len) - 16);
#line 100
    plain = (dest + len) - 16;
#line 102
    memcpy((void * __restrict  )(buf___1), (void const   * __restrict  )cnow, 16U);
#line 103
    i = blocks;
#line 103
    while (i > 0) {
#line 105
      rijndael_decrypt(& c->r_ctx, cnow, plain);
#line 106
      if (i == 1) {
#line 106
        ivp = c->r_iv;
      } else {
#line 106
        ivp = cnow - 16;
      }
#line 107
      j = 0;
#line 107
      while (j < 16) {
#line 108
        *(plain + j) = (unsigned char )((int )*(plain + j) ^ (int )*(ivp + j));
#line 107
        j ++;
      }
#line 103
      i --;
#line 103
      cnow -= 16;
#line 103
      plain -= 16;
    }
#line 110
    memcpy((void * __restrict  )(c->r_iv), (void const   * __restrict  )(buf___1),
           16U);
  }
#line 112
  return (1);
}
}
#line 115 "cipher-aes.c"
static int ssh_rijndael_cleanup(EVP_CIPHER_CTX *ctx ) 
{ struct ssh_rijndael_ctx *c ;

  {
#line 120
  c = (struct ssh_rijndael_ctx *)ctx->app_data;
#line 120
  if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 121
    memset((void *)c, 0, sizeof(*c));
#line 122
    xfree((void *)c);
#line 123
    ctx->app_data = (void *)((char *)((void *)0));
  }
#line 125
  return (1);
}
}
#line 128 "cipher-aes.c"
void ssh_rijndael_iv(EVP_CIPHER_CTX *evp , int doset , u_char *iv , u_int len ) 
{ struct ssh_rijndael_ctx *c ;

  {
#line 133
  c = (struct ssh_rijndael_ctx *)evp->app_data;
#line 133
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 134
    fatal("ssh_rijndael_iv: no context");
  }
#line 135
  if (doset) {
#line 136
    memcpy((void * __restrict  )(c->r_iv), (void const   * __restrict  )iv, len);
  } else {
#line 138
    memcpy((void * __restrict  )iv, (void const   * __restrict  )(c->r_iv), len);
  }
#line 139
  return;
}
}
#line 144 "cipher-aes.c"
static EVP_CIPHER rijndal_cbc  ;
#line 141 "cipher-aes.c"
EVP_CIPHER const   *evp_rijndael(void) 
{ 

  {
#line 146
  memset((void *)(& rijndal_cbc), 0, sizeof(EVP_CIPHER ));
#line 147
  rijndal_cbc.nid = 0;
#line 148
  rijndal_cbc.block_size = 16;
#line 149
  rijndal_cbc.iv_len = 16;
#line 150
  rijndal_cbc.key_len = 16;
#line 151
  rijndal_cbc.init = & ssh_rijndael_init;
#line 152
  rijndal_cbc.cleanup = & ssh_rijndael_cleanup;
#line 153
  rijndal_cbc.do_cipher = & ssh_rijndael_cbc;
#line 155
  rijndal_cbc.flags = 58UL;
#line 158
  return ((EVP_CIPHER const   *)(& rijndal_cbc));
}
}
#line 1 "cipher-bf1.o"
#line 43 "cipher-bf1.c"
static void swap_bytes(u_char const   *src , u_char *dst , int n___0 ) 
{ u_char c[4] ;
  u_char const   *tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  u_char const   *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  u_char *tmp___6 ;

  {
#line 49
  n___0 /= 4;
#line 49
  while (n___0 > 0) {
#line 50
    tmp = src;
#line 50
    src ++;
#line 50
    c[3] = (unsigned char )*tmp;
#line 51
    tmp___0 = src;
#line 51
    src ++;
#line 51
    c[2] = (unsigned char )*tmp___0;
#line 52
    tmp___1 = src;
#line 52
    src ++;
#line 52
    c[1] = (unsigned char )*tmp___1;
#line 53
    tmp___2 = src;
#line 53
    src ++;
#line 53
    c[0] = (unsigned char )*tmp___2;
#line 55
    tmp___3 = dst;
#line 55
    dst ++;
#line 55
    *tmp___3 = c[0];
#line 56
    tmp___4 = dst;
#line 56
    dst ++;
#line 56
    *tmp___4 = c[1];
#line 57
    tmp___5 = dst;
#line 57
    dst ++;
#line 57
    *tmp___5 = c[2];
#line 58
    tmp___6 = dst;
#line 58
    dst ++;
#line 58
    *tmp___6 = c[3];
#line 49
    n___0 --;
  }
#line 60
  return;
}
}
#line 75 "cipher-bf1.c"
static int (*orig_bf)(EVP_CIPHER_CTX * , u_char * , u_char const   * , u_int  )  =    (int (*)(EVP_CIPHER_CTX * ,
            u_char * , u_char const   * , u_int  ))((void *)0);
#line 77 "cipher-bf1.c"
static int bf_ssh1_cipher(EVP_CIPHER_CTX *ctx , u_char *out , u_char const   *in ,
                          u_int len ) 
{ int ret ;

  {
#line 82
  swap_bytes(in, out, (int )len);
#line 83
  ret = (*orig_bf)(ctx, out, (u_char const   *)out, len);
#line 84
  swap_bytes((u_char const   *)out, out, (int )len);
#line 85
  return (ret);
}
}
#line 91 "cipher-bf1.c"
static EVP_CIPHER ssh1_bf  ;
#line 88 "cipher-bf1.c"
EVP_CIPHER const   *evp_ssh1_bf(void) 
{ EVP_CIPHER const   *tmp ;

  {
#line 93
  tmp = EVP_bf_cbc();
#line 93
  memcpy((void * __restrict  )(& ssh1_bf), (void const   * __restrict  )tmp, sizeof(EVP_CIPHER ));
#line 94
  orig_bf = ssh1_bf.do_cipher;
#line 95
  ssh1_bf.nid = 0;
#line 99
  ssh1_bf.do_cipher = & bf_ssh1_cipher;
#line 100
  ssh1_bf.key_len = 32;
#line 101
  return ((EVP_CIPHER const   *)(& ssh1_bf));
}
}
#line 1 "cipher-ctr.o"
#line 51 "cipher-ctr.c"
static void ssh_ctr_inc(u_char *ctr , u_int len ) 
{ int i ;

  {
#line 56
  i = (int )(len - 1U);
#line 56
  while (i >= 0) {
#line 57
    *(ctr + i) = (u_char )((int )*(ctr + i) + 1);
#line 57
    if (*(ctr + i)) {
#line 58
      return;
    }
#line 56
    i --;
  }
#line 59
  return;
}
}
#line 61 "cipher-ctr.c"
static int ssh_aes_ctr(EVP_CIPHER_CTX *ctx , u_char *dest , u_char const   *src ,
                       u_int len ) 
{ struct ssh_aes_ctr_ctx *c ;
  u_int n___0 ;
  u_char buf___1[16] ;
  u_char *tmp ;
  u_char const   *tmp___0 ;
  u_int tmp___1 ;

  {
#line 66
  n___0 = (u_int )0;
#line 69
  if (len == 0U) {
#line 70
    return (1);
  }
#line 71
  c = (struct ssh_aes_ctr_ctx *)ctx->app_data;
#line 71
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 72
    return (0);
  }
#line 74
  while (1) {
#line 74
    tmp___1 = len;
#line 74
    len --;
#line 74
    if (! (tmp___1 > 0U)) {
#line 74
      break;
    }
#line 75
    if (n___0 == 0U) {
#line 76
      rijndael_encrypt(& c->aes_ctx, c->aes_counter, buf___1);
#line 77
      ssh_ctr_inc(c->aes_counter, 16U);
    }
#line 79
    tmp = dest;
#line 79
    dest ++;
#line 79
    tmp___0 = src;
#line 79
    src ++;
#line 79
    *tmp = (unsigned char )((int const   )*tmp___0 ^ (int const   )buf___1[n___0]);
#line 80
    n___0 = (n___0 + 1U) % 16U;
  }
#line 82
  return (1);
}
}
#line 85 "cipher-ctr.c"
static int ssh_aes_ctr_init(EVP_CIPHER_CTX *ctx , u_char const   *key , u_char const   *iv ,
                            int enc ) 
{ struct ssh_aes_ctr_ctx *c ;
  void *tmp ;

  {
#line 91
  c = (struct ssh_aes_ctr_ctx *)ctx->app_data;
#line 91
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 92
    tmp = xmalloc(sizeof(*c));
#line 92
    c = (struct ssh_aes_ctr_ctx *)tmp;
#line 93
    ctx->app_data = (void *)((char *)c);
  }
#line 95
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 96
    rijndael_set_key(& c->aes_ctx, (u_char *)((char *)key), ctx->key_len * 8, 1);
  }
#line 98
  if ((unsigned int )iv != (unsigned int )((void *)0)) {
#line 99
    memcpy((void * __restrict  )(c->aes_counter), (void const   * __restrict  )iv,
           16U);
  }
#line 100
  return (1);
}
}
#line 103 "cipher-ctr.c"
static int ssh_aes_ctr_cleanup(EVP_CIPHER_CTX *ctx ) 
{ struct ssh_aes_ctr_ctx *c ;

  {
#line 108
  c = (struct ssh_aes_ctr_ctx *)ctx->app_data;
#line 108
  if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 109
    memset((void *)c, 0, sizeof(*c));
#line 110
    xfree((void *)c);
#line 111
    ctx->app_data = (void *)((char *)((void *)0));
  }
#line 113
  return (1);
}
}
#line 116 "cipher-ctr.c"
void ssh_aes_ctr_iv(EVP_CIPHER_CTX *evp , int doset , u_char *iv , u_int len ) 
{ struct ssh_aes_ctr_ctx *c ;

  {
#line 121
  c = (struct ssh_aes_ctr_ctx *)evp->app_data;
#line 121
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 122
    fatal("ssh_aes_ctr_iv: no context");
  }
#line 123
  if (doset) {
#line 124
    memcpy((void * __restrict  )(c->aes_counter), (void const   * __restrict  )iv,
           len);
  } else {
#line 126
    memcpy((void * __restrict  )iv, (void const   * __restrict  )(c->aes_counter),
           len);
  }
#line 127
  return;
}
}
#line 132 "cipher-ctr.c"
static EVP_CIPHER aes_ctr  ;
#line 129 "cipher-ctr.c"
EVP_CIPHER const   *evp_aes_128_ctr(void) 
{ 

  {
#line 134
  memset((void *)(& aes_ctr), 0, sizeof(EVP_CIPHER ));
#line 135
  aes_ctr.nid = 0;
#line 136
  aes_ctr.block_size = 16;
#line 137
  aes_ctr.iv_len = 16;
#line 138
  aes_ctr.key_len = 16;
#line 139
  aes_ctr.init = & ssh_aes_ctr_init;
#line 140
  aes_ctr.cleanup = & ssh_aes_ctr_cleanup;
#line 141
  aes_ctr.do_cipher = & ssh_aes_ctr;
#line 143
  aes_ctr.flags = 58UL;
#line 146
  return ((EVP_CIPHER const   *)(& aes_ctr));
}
}
#line 1 "cipher-3des1.o"
#line 58 "cipher-3des1.c"
static int ssh1_3des_init(EVP_CIPHER_CTX *ctx , u_char const   *key , u_char const   *iv ,
                          int enc ) 
{ struct ssh1_3des_ctx *c ;
  u_char *k1 ;
  u_char *k2 ;
  u_char *k3 ;
  void *tmp ;
  EVP_CIPHER const   *tmp___0 ;
  int tmp___1 ;
  EVP_CIPHER const   *tmp___2 ;
  int tmp___3 ;
  EVP_CIPHER const   *tmp___4 ;
  int tmp___5 ;

  {
#line 65
  c = (struct ssh1_3des_ctx *)ctx->app_data;
#line 65
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 66
    tmp = xmalloc(sizeof(*c));
#line 66
    c = (struct ssh1_3des_ctx *)tmp;
#line 67
    ctx->app_data = (void *)((char *)c);
  }
#line 69
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 70
    return (1);
  }
#line 71
  if (enc == -1) {
#line 72
    enc = ctx->encrypt;
  }
#line 73
  k3 = (u_char *)key;
#line 73
  k2 = k3;
#line 73
  k1 = k2;
#line 74
  k2 += 8;
#line 75
  if (ctx->key_len >= 24) {
#line 76
    if (enc) {
#line 77
      k3 += 16;
    } else {
#line 79
      k1 += 16;
    }
  }
#line 81
  EVP_CIPHER_CTX_init(& c->k1);
#line 82
  EVP_CIPHER_CTX_init(& c->k2);
#line 83
  EVP_CIPHER_CTX_init(& c->k3);
#line 89
  tmp___0 = EVP_des_cbc();
#line 89
  tmp___1 = EVP_CipherInit(& c->k1, tmp___0, (unsigned char const   *)k1, (unsigned char const   *)((void *)0),
                           enc);
#line 89
  if (tmp___1 == 0) {
#line 92
    memset((void *)c, 0, sizeof(*c));
#line 93
    xfree((void *)c);
#line 94
    ctx->app_data = (void *)((char *)((void *)0));
#line 95
    return (0);
  } else {
#line 89
    tmp___2 = EVP_des_cbc();
#line 89
    tmp___3 = EVP_CipherInit(& c->k2, tmp___2, (unsigned char const   *)k2, (unsigned char const   *)((void *)0),
                             ! enc);
#line 89
    if (tmp___3 == 0) {
#line 92
      memset((void *)c, 0, sizeof(*c));
#line 93
      xfree((void *)c);
#line 94
      ctx->app_data = (void *)((char *)((void *)0));
#line 95
      return (0);
    } else {
#line 89
      tmp___4 = EVP_des_cbc();
#line 89
      tmp___5 = EVP_CipherInit(& c->k3, tmp___4, (unsigned char const   *)k3, (unsigned char const   *)((void *)0),
                               enc);
#line 89
      if (tmp___5 == 0) {
#line 92
        memset((void *)c, 0, sizeof(*c));
#line 93
        xfree((void *)c);
#line 94
        ctx->app_data = (void *)((char *)((void *)0));
#line 95
        return (0);
      }
    }
  }
#line 98
  return (1);
}
}
#line 101 "cipher-3des1.c"
static int ssh1_3des_cbc(EVP_CIPHER_CTX *ctx , u_char *dest , u_char const   *src ,
                         u_int len ) 
{ struct ssh1_3des_ctx *c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 106
  c = (struct ssh1_3des_ctx *)ctx->app_data;
#line 106
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 107
    error("ssh1_3des_cbc: no context");
#line 108
    return (0);
  }
#line 115
  tmp = (*((c->k1.cipher)->do_cipher))(& c->k1, dest, (unsigned char const   *)((u_char *)src),
                                       len);
#line 115
  if (tmp == 0) {
#line 118
    return (0);
  } else {
#line 115
    tmp___0 = (*((c->k2.cipher)->do_cipher))(& c->k2, dest, (unsigned char const   *)dest,
                                             len);
#line 115
    if (tmp___0 == 0) {
#line 118
      return (0);
    } else {
#line 115
      tmp___1 = (*((c->k3.cipher)->do_cipher))(& c->k3, dest, (unsigned char const   *)dest,
                                               len);
#line 115
      if (tmp___1 == 0) {
#line 118
        return (0);
      }
    }
  }
#line 120
  return (1);
}
}
#line 123 "cipher-3des1.c"
static int ssh1_3des_cleanup(EVP_CIPHER_CTX *ctx ) 
{ struct ssh1_3des_ctx *c ;

  {
#line 128
  c = (struct ssh1_3des_ctx *)ctx->app_data;
#line 128
  if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 129
    EVP_CIPHER_CTX_cleanup(& c->k1);
#line 130
    EVP_CIPHER_CTX_cleanup(& c->k2);
#line 131
    EVP_CIPHER_CTX_cleanup(& c->k3);
#line 132
    memset((void *)c, 0, sizeof(*c));
#line 133
    xfree((void *)c);
#line 134
    ctx->app_data = (void *)((char *)((void *)0));
  }
#line 136
  return (1);
}
}
#line 139 "cipher-3des1.c"
void ssh1_3des_iv(EVP_CIPHER_CTX *evp , int doset , u_char *iv , int len ) 
{ struct ssh1_3des_ctx *c ;

  {
#line 144
  if (len != 24) {
#line 145
    fatal("%s: bad 3des iv length: %d", "ssh1_3des_iv", len);
  }
#line 146
  c = (struct ssh1_3des_ctx *)evp->app_data;
#line 146
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 147
    fatal("%s: no 3des context", "ssh1_3des_iv");
  }
#line 148
  if (doset) {
#line 149
    debug3("%s: Installed 3DES IV", "ssh1_3des_iv");
#line 150
    memcpy((void * __restrict  )(c->k1.iv), (void const   * __restrict  )iv, 8U);
#line 151
    memcpy((void * __restrict  )(c->k2.iv), (void const   * __restrict  )(iv + 8),
           8U);
#line 152
    memcpy((void * __restrict  )(c->k3.iv), (void const   * __restrict  )(iv + 16),
           8U);
  } else {
#line 154
    debug3("%s: Copying 3DES IV", "ssh1_3des_iv");
#line 155
    memcpy((void * __restrict  )iv, (void const   * __restrict  )(c->k1.iv), 8U);
#line 156
    memcpy((void * __restrict  )(iv + 8), (void const   * __restrict  )(c->k2.iv),
           8U);
#line 157
    memcpy((void * __restrict  )(iv + 16), (void const   * __restrict  )(c->k3.iv),
           8U);
  }
#line 159
  return;
}
}
#line 164 "cipher-3des1.c"
static EVP_CIPHER ssh1_3des  ;
#line 161 "cipher-3des1.c"
EVP_CIPHER const   *evp_ssh1_3des(void) 
{ 

  {
#line 166
  memset((void *)(& ssh1_3des), 0, sizeof(EVP_CIPHER ));
#line 167
  ssh1_3des.nid = 0;
#line 168
  ssh1_3des.block_size = 8;
#line 169
  ssh1_3des.iv_len = 0;
#line 170
  ssh1_3des.key_len = 16;
#line 171
  ssh1_3des.init = & ssh1_3des_init;
#line 172
  ssh1_3des.cleanup = & ssh1_3des_cleanup;
#line 173
  ssh1_3des.do_cipher = & ssh1_3des_cbc;
#line 175
  ssh1_3des.flags = 10UL;
#line 177
  return ((EVP_CIPHER const   *)(& ssh1_3des));
}
}
#line 1 "cleanup.o"
#line 548 "/usr/include/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 22 "cleanup.c"
 __attribute__((__noreturn__)) void cleanup_exit(int i ) ;
#line 22 "cleanup.c"
void cleanup_exit(int i ) 
{ 

  {
#line 25
  _exit(i);
}
}
#line 1 "compat.o"
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 60 "compat.h"
void enable_compat13(void) ;
#line 61
void enable_compat20(void) ;
#line 62
void compat_datafellows(char const   *version ) ;
#line 63
int proto_spec(char const   *spec ) ;
#line 64
char *compat_cipher_proposal(char *cipher_prop ) ;
#line 18 "match.h"
int match_pattern_list(char const   *string , char const   *pattern , u_int len ,
                       int dolower ) ;
#line 35 "compat.c"
int compat13  =    0;
#line 36 "compat.c"
int compat20  =    0;
#line 37 "compat.c"
int datafellows  =    0;
#line 39 "compat.c"
void enable_compat20(void) 
{ 

  {
#line 42
  debug("Enabling compatibility mode for protocol 2.0");
#line 43
  compat20 = 1;
#line 44
  return;
}
}
#line 45 "compat.c"
void enable_compat13(void) 
{ 

  {
#line 48
  debug("Enabling compatibility mode for protocol 1.3");
#line 49
  compat13 = 1;
#line 50
  return;
}
}
#line 56 "compat.c"
static struct __anonstruct_check_78 check[30]  = 
#line 56
  {      {(char *)"OpenSSH-2.0*,OpenSSH-2.1*,OpenSSH_2.1*,OpenSSH_2.2*", 18923664}, 
        {(char *)"OpenSSH_2.3.0*", 18927744}, 
        {(char *)"OpenSSH_2.3.*", 18927616}, 
        {(char *)"OpenSSH_2.5.0p1*,OpenSSH_2.5.1p1*", 18927616}, 
        {(char *)"OpenSSH_2.5.0*,OpenSSH_2.5.1*,OpenSSH_2.5.2*", 18923520}, 
        {(char *)"OpenSSH_2.5.3*", 18907136}, 
        {(char *)"OpenSSH_2.*,OpenSSH_3.0*,OpenSSH_3.1*", 18874368}, 
        {(char *)"OpenSSH_3.*", 16777216}, 
        {(char *)"Sun_SSH_1.0*", 2129920}, 
        {(char *)"OpenSSH*", 0}, 
        {(char *)"*MindTerm*", 0}, 
        {(char *)"2.1.0*", 8462421}, 
        {(char *)"2.1 *", 8462421}, 
        {(char *)"2.0.13*,2.0.14*,2.0.15*,2.0.16*,2.0.17*,2.0.18*,2.0.19*", 9642591}, 
        {(char *)"2.0.11*,2.0.12*",
      9577087}, 
        {(char *)"2.0.*", 9839231}, 
        {(char *)"2.2.0*,2.3.0*", 8396868}, 
        {(char *)"2.3.*", 8396864}, 
        {(char *)"2.4", 16}, 
        {(char *)"2.*", 8388672}, 
        {(char *)"3.0.*", 64}, 
        {(char *)"3.0 SecureCRT*", 16}, 
        {(char *)"1.7 SecureFX*", 16}, 
        {(char *)"1.2.18*,1.2.19*,1.2.20*,1.2.21*,1.2.22*", 256}, 
        {(char *)"1.3.2*", 256}, 
        {(char *)"*SSH Compatible Server*", 1024}, 
        {(char *)"*OSU_0*,OSU_1.0*,OSU_1.1*,OSU_1.2*,OSU_1.3*,OSU_1.4*,OSU_1.5alpha1*,OSU_1.5alpha2*,OSU_1.5alpha3*",
      1024}, 
        {(char *)"*SSH_Version_Mapper*", 2048}, 
        {(char *)"Probe-*", 4194304}, 
        {(char *)((void *)0), 0}};
#line 52 "compat.c"
void compat_datafellows(char const   *version ) 
{ int i ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 160
  i = 0;
#line 160
  while (check[i].pat) {
#line 161
    tmp = strlen((char const   *)check[i].pat);
#line 161
    tmp___0 = match_pattern_list(version, (char const   *)check[i].pat, tmp, 0);
#line 161
    if (tmp___0 == 1) {
#line 163
      debug("match: %s pat %s", version, check[i].pat);
#line 164
      datafellows = check[i].bugs;
#line 165
      return;
    }
#line 160
    i ++;
  }
#line 168
  debug("no match: %s", version);
#line 169
  return;
}
}
#line 172 "compat.c"
int proto_spec(char const   *spec ) 
{ char *s ;
  char *p ;
  char *q ;
  int ret ;
  char *tmp___14 ;
  char *tmp___30 ;
  int tmp___31 ;

  {
#line 176
  ret = 0;
#line 178
  if ((unsigned int )spec == (unsigned int )((void *)0)) {
#line 179
    return (ret);
  }
#line 180
  s = xstrdup(spec);
#line 180
  q = s;
#line 181
  tmp___14 = __strsep_g(& q, ",");
#line 181
  p = tmp___14;
#line 181
  while (1) {
#line 181
    if (p) {
#line 181
      if (! ((int )*p != 0)) {
#line 181
        break;
      }
    } else {
#line 181
      break;
    }
#line 182
    tmp___31 = atoi((char const   *)p);
#line 182
    switch (tmp___31) {
    case 1: 
#line 184
    if (ret == 0) {
#line 185
      ret |= 2;
    }
#line 186
    ret |= 1;
#line 187
    break;
    case 2: 
#line 189
    ret |= 4;
#line 190
    break;
    default: 
#line 192
    logit("ignoring bad proto spec: \'%s\'.", p);
#line 193
    break;
    }
#line 181
    tmp___30 = __strsep_g(& q, ",");
#line 181
    p = tmp___30;
  }
#line 196
  xfree((void *)s);
#line 197
  return (ret);
}
}
#line 200 "compat.c"
char *compat_cipher_proposal(char *cipher_prop ) 
{ Buffer b ;
  char *orig_prop ;
  char *fix_ciphers ;
  char *cp ;
  char *tmp ;
  u_int tmp___0 ;
  size_t tmp___1 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___43 ;
  void *tmp___44 ;

  {
#line 207
  if (! (datafellows & 4096)) {
#line 208
    return (cipher_prop);
  }
#line 210
  buffer_init(& b);
#line 211
  orig_prop = xstrdup((char const   *)cipher_prop);
#line 211
  tmp = orig_prop;
#line 212
  while (1) {
#line 212
    tmp___43 = __strsep_g(& tmp, ",");
#line 212
    cp = tmp___43;
#line 212
    if (! ((unsigned int )cp != (unsigned int )((void *)0))) {
#line 212
      break;
    }
#line 213
    if (0) {
#line 213
      if (0) {
#line 213
        __s1_len___0 = strlen((char const   *)cp);
#line 213
        __s2_len___0 = strlen("aes");
#line 213
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___2;
        } else {
#line 213
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 213
            if (! ((unsigned int )((void const   *)("aes" + 1)) - (unsigned int )((void const   *)"aes") == 1U)) {
#line 213
              tmp___25 = 1;
            } else {
#line 213
              if (__s2_len___0 >= 4U) {
#line 213
                tmp___25 = 1;
              } else {
#line 213
                tmp___25 = 0;
              }
            }
          } else {
#line 213
            tmp___25 = 0;
          }
        }
#line 213
        if (tmp___25) {
#line 213
          tmp___21 = __builtin_strcmp((char const   *)cp, "aes");
        } else {
#line 213
          tmp___24 = __builtin_strcmp((char const   *)cp, "aes");
#line 213
          tmp___21 = tmp___24;
        }
      } else {
#line 213
        tmp___24 = __builtin_strcmp((char const   *)cp, "aes");
#line 213
        tmp___21 = tmp___24;
      }
#line 213
      tmp___15 = tmp___21;
    } else {
#line 213
      tmp___15 = strncmp((char const   *)cp, "aes", 3U);
    }
#line 213
    if (tmp___15 != 0) {
#line 214
      tmp___0 = buffer_len(& b);
#line 214
      if (tmp___0 > 0U) {
#line 215
        buffer_append(& b, (void const   *)",", 1U);
      }
#line 216
      tmp___1 = strlen((char const   *)cp);
#line 216
      buffer_append(& b, (void const   *)cp, tmp___1);
    }
  }
#line 219
  buffer_append(& b, (void const   *)"\000", 1U);
#line 220
  tmp___44 = buffer_ptr(& b);
#line 220
  fix_ciphers = xstrdup((char const   *)tmp___44);
#line 221
  buffer_free(& b);
#line 222
  xfree((void *)orig_prop);
#line 223
  debug2("Original cipher proposal: %s", cipher_prop);
#line 224
  debug2("Compat cipher proposal: %s", fix_ciphers);
#line 225
  if (! *fix_ciphers) {
#line 226
    fatal("No available ciphers found.");
  }
#line 228
  return (fix_ciphers);
}
}
#line 1 "compress.o"
#line 242 "/usr/include/zlib.h"
extern int deflate(z_streamp strm , int flush ) ;
#line 328
extern int deflateEnd(z_streamp strm ) ;
#line 363
extern int inflate(z_streamp strm , int flush ) ;
#line 462
extern int inflateEnd(z_streamp strm ) ;
#line 1317
extern int deflateInit_(z_streamp strm , int level , char const   *version , int stream_size ) ;
#line 1319
extern int inflateInit_(z_streamp strm , char const   *version , int stream_size ) ;
#line 19 "compress.h"
void buffer_compress_init_send(int level ) ;
#line 20
void buffer_compress_init_recv(void) ;
#line 21
void buffer_compress_uninit(void) ;
#line 22
void buffer_compress(Buffer *input_buffer , Buffer *output_buffer ) ;
#line 23
void buffer_uncompress(Buffer *input_buffer , Buffer *output_buffer ) ;
#line 22 "compress.c"
z_stream incoming_stream  ;
#line 23 "compress.c"
z_stream outgoing_stream  ;
#line 24 "compress.c"
static int compress_init_send_called  =    0;
#line 25 "compress.c"
static int compress_init_recv_called  =    0;
#line 26 "compress.c"
static int inflate_failed  =    0;
#line 27 "compress.c"
static int deflate_failed  =    0;
#line 34 "compress.c"
void buffer_compress_init_send(int level ) 
{ 

  {
#line 37
  if (compress_init_send_called == 1) {
#line 38
    deflateEnd(& outgoing_stream);
  }
#line 39
  compress_init_send_called = 1;
#line 40
  debug("Enabling compression at level %d.", level);
#line 41
  if (level < 1) {
#line 42
    fatal("Bad compression level %d.", level);
  } else {
#line 41
    if (level > 9) {
#line 42
      fatal("Bad compression level %d.", level);
    }
  }
#line 43
  deflateInit_(& outgoing_stream, level, "1.2.3", (int )sizeof(z_stream ));
#line 44
  return;
}
}
#line 45 "compress.c"
void buffer_compress_init_recv(void) 
{ 

  {
#line 48
  if (compress_init_recv_called == 1) {
#line 49
    inflateEnd(& incoming_stream);
  }
#line 50
  compress_init_recv_called = 1;
#line 51
  inflateInit_(& incoming_stream, "1.2.3", (int )sizeof(z_stream ));
#line 52
  return;
}
}
#line 56 "compress.c"
void buffer_compress_uninit(void) 
{ double tmp ;
  double tmp___0 ;

  {
#line 59
  if (outgoing_stream.total_in == 0UL) {
#line 59
    tmp = 0.0;
  } else {
#line 59
    tmp = (double )outgoing_stream.total_out / (double )outgoing_stream.total_in;
  }
#line 59
  debug("compress outgoing: raw data %llu, compressed %llu, factor %.2f", (unsigned long long )outgoing_stream.total_in,
        (unsigned long long )outgoing_stream.total_out, tmp);
#line 64
  if (incoming_stream.total_out == 0UL) {
#line 64
    tmp___0 = 0.0;
  } else {
#line 64
    tmp___0 = (double )incoming_stream.total_in / (double )incoming_stream.total_out;
  }
#line 64
  debug("compress incoming: raw data %llu, compressed %llu, factor %.2f", (unsigned long long )incoming_stream.total_out,
        (unsigned long long )incoming_stream.total_in, tmp___0);
#line 69
  if (compress_init_recv_called == 1) {
#line 69
    if (inflate_failed == 0) {
#line 70
      inflateEnd(& incoming_stream);
    }
  }
#line 71
  if (compress_init_send_called == 1) {
#line 71
    if (deflate_failed == 0) {
#line 72
      deflateEnd(& outgoing_stream);
    }
  }
#line 73
  return;
}
}
#line 84 "compress.c"
void buffer_compress(Buffer *input_buffer , Buffer *output_buffer ) 
{ u_char buf___1[4096] ;
  int status ;
  u_int tmp ;
  void *tmp___0 ;

  {
#line 91
  tmp = buffer_len(input_buffer);
#line 91
  if (tmp == 0U) {
#line 92
    return;
  }
#line 95
  tmp___0 = buffer_ptr(input_buffer);
#line 95
  outgoing_stream.next_in = (Bytef *)tmp___0;
#line 96
  outgoing_stream.avail_in = buffer_len(input_buffer);
#line 99
  while (1) {
#line 101
    outgoing_stream.next_out = buf___1;
#line 102
    outgoing_stream.avail_out = sizeof(buf___1);
#line 105
    status = deflate(& outgoing_stream, 1);
#line 106
    switch (status) {
    case 0: 
#line 109
    buffer_append(output_buffer, (void const   *)(buf___1), sizeof(buf___1) - outgoing_stream.avail_out);
#line 111
    break;
    default: 
#line 113
    deflate_failed = 1;
#line 114
    fatal("buffer_compress: deflate returned %d", status);
    }
#line 99
    if (! (outgoing_stream.avail_out == 0U)) {
#line 99
      break;
    }
  }
#line 118
  return;
}
}
#line 129 "compress.c"
void buffer_uncompress(Buffer *input_buffer , Buffer *output_buffer ) 
{ u_char buf___1[4096] ;
  int status ;
  void *tmp ;

  {
#line 135
  tmp = buffer_ptr(input_buffer);
#line 135
  incoming_stream.next_in = (Bytef *)tmp;
#line 136
  incoming_stream.avail_in = buffer_len(input_buffer);
#line 138
  while (1) {
#line 140
    incoming_stream.next_out = buf___1;
#line 141
    incoming_stream.avail_out = sizeof(buf___1);
#line 143
    status = inflate(& incoming_stream, 1);
#line 144
    switch (status) {
    case 0: 
#line 146
    buffer_append(output_buffer, (void const   *)(buf___1), sizeof(buf___1) - incoming_stream.avail_out);
#line 148
    break;
    case -5: 
#line 155
    return;
    default: 
#line 157
    inflate_failed = 1;
#line 158
    fatal("buffer_uncompress: inflate returned %d", status);
    }
  }
}
}
#line 1 "crc32.o"
#line 29 "crc32.h"
u_int32_t ssh_crc32(u_char const   *buf___1 , u_int32_t size ) ;
#line 29 "crc32.c"
static u_int32_t const   crc32tab[256]  = 
#line 29 "crc32.c"
  {      (u_int32_t const   )0L,      (u_int32_t const   )1996959894L,      (u_int32_t const   )3993919788UL,      (u_int32_t const   )2567524794UL, 
        (u_int32_t const   )124634137L,      (u_int32_t const   )1886057615L,      (u_int32_t const   )3915621685UL,      (u_int32_t const   )2657392035UL, 
        (u_int32_t const   )249268274L,      (u_int32_t const   )2044508324L,      (u_int32_t const   )3772115230UL,      (u_int32_t const   )2547177864UL, 
        (u_int32_t const   )162941995L,      (u_int32_t const   )2125561021L,      (u_int32_t const   )3887607047UL,      (u_int32_t const   )2428444049UL, 
        (u_int32_t const   )498536548L,      (u_int32_t const   )1789927666L,      (u_int32_t const   )4089016648UL,      (u_int32_t const   )2227061214UL, 
        (u_int32_t const   )450548861L,      (u_int32_t const   )1843258603L,      (u_int32_t const   )4107580753UL,      (u_int32_t const   )2211677639UL, 
        (u_int32_t const   )325883990L,      (u_int32_t const   )1684777152L,      (u_int32_t const   )4251122042UL,      (u_int32_t const   )2321926636UL, 
        (u_int32_t const   )335633487L,      (u_int32_t const   )1661365465L,      (u_int32_t const   )4195302755UL,      (u_int32_t const   )2366115317UL, 
        (u_int32_t const   )997073096L,      (u_int32_t const   )1281953886L,      (u_int32_t const   )3579855332UL,      (u_int32_t const   )2724688242UL, 
        (u_int32_t const   )1006888145L,      (u_int32_t const   )1258607687L,      (u_int32_t const   )3524101629UL,      (u_int32_t const   )2768942443UL, 
        (u_int32_t const   )901097722L,      (u_int32_t const   )1119000684L,      (u_int32_t const   )3686517206UL,      (u_int32_t const   )2898065728UL, 
        (u_int32_t const   )853044451L,      (u_int32_t const   )1172266101L,      (u_int32_t const   )3705015759UL,      (u_int32_t const   )2882616665UL, 
        (u_int32_t const   )651767980L,      (u_int32_t const   )1373503546L,      (u_int32_t const   )3369554304UL,      (u_int32_t const   )3218104598UL, 
        (u_int32_t const   )565507253L,      (u_int32_t const   )1454621731L,      (u_int32_t const   )3485111705UL,      (u_int32_t const   )3099436303UL, 
        (u_int32_t const   )671266974L,      (u_int32_t const   )1594198024L,      (u_int32_t const   )3322730930UL,      (u_int32_t const   )2970347812UL, 
        (u_int32_t const   )795835527L,      (u_int32_t const   )1483230225L,      (u_int32_t const   )3244367275UL,      (u_int32_t const   )3060149565UL, 
        (u_int32_t const   )1994146192L,      (u_int32_t const   )31158534L,      (u_int32_t const   )2563907772UL,      (u_int32_t const   )4023717930UL, 
        (u_int32_t const   )1907459465L,      (u_int32_t const   )112637215L,      (u_int32_t const   )2680153253UL,      (u_int32_t const   )3904427059UL, 
        (u_int32_t const   )2013776290L,      (u_int32_t const   )251722036L,      (u_int32_t const   )2517215374UL,      (u_int32_t const   )3775830040UL, 
        (u_int32_t const   )2137656763L,      (u_int32_t const   )141376813L,      (u_int32_t const   )2439277719UL,      (u_int32_t const   )3865271297UL, 
        (u_int32_t const   )1802195444L,      (u_int32_t const   )476864866L,      (u_int32_t const   )2238001368UL,      (u_int32_t const   )4066508878UL, 
        (u_int32_t const   )1812370925L,      (u_int32_t const   )453092731L,      (u_int32_t const   )2181625025UL,      (u_int32_t const   )4111451223UL, 
        (u_int32_t const   )1706088902L,      (u_int32_t const   )314042704L,      (u_int32_t const   )2344532202UL,      (u_int32_t const   )4240017532UL, 
        (u_int32_t const   )1658658271L,      (u_int32_t const   )366619977L,      (u_int32_t const   )2362670323UL,      (u_int32_t const   )4224994405UL, 
        (u_int32_t const   )1303535960L,      (u_int32_t const   )984961486L,      (u_int32_t const   )2747007092UL,      (u_int32_t const   )3569037538UL, 
        (u_int32_t const   )1256170817L,      (u_int32_t const   )1037604311L,      (u_int32_t const   )2765210733UL,      (u_int32_t const   )3554079995UL, 
        (u_int32_t const   )1131014506L,      (u_int32_t const   )879679996L,      (u_int32_t const   )2909243462UL,      (u_int32_t const   )3663771856UL, 
        (u_int32_t const   )1141124467L,      (u_int32_t const   )855842277L,      (u_int32_t const   )2852801631UL,      (u_int32_t const   )3708648649UL, 
        (u_int32_t const   )1342533948L,      (u_int32_t const   )654459306L,      (u_int32_t const   )3188396048UL,      (u_int32_t const   )3373015174UL, 
        (u_int32_t const   )1466479909L,      (u_int32_t const   )544179635L,      (u_int32_t const   )3110523913UL,      (u_int32_t const   )3462522015UL, 
        (u_int32_t const   )1591671054L,      (u_int32_t const   )702138776L,      (u_int32_t const   )2966460450UL,      (u_int32_t const   )3352799412UL, 
        (u_int32_t const   )1504918807L,      (u_int32_t const   )783551873L,      (u_int32_t const   )3082640443UL,      (u_int32_t const   )3233442989UL, 
        (u_int32_t const   )3988292384UL,      (u_int32_t const   )2596254646UL,      (u_int32_t const   )62317068L,      (u_int32_t const   )1957810842L, 
        (u_int32_t const   )3939845945UL,      (u_int32_t const   )2647816111UL,      (u_int32_t const   )81470997L,      (u_int32_t const   )1943803523L, 
        (u_int32_t const   )3814918930UL,      (u_int32_t const   )2489596804UL,      (u_int32_t const   )225274430L,      (u_int32_t const   )2053790376L, 
        (u_int32_t const   )3826175755UL,      (u_int32_t const   )2466906013UL,      (u_int32_t const   )167816743L,      (u_int32_t const   )2097651377L, 
        (u_int32_t const   )4027552580UL,      (u_int32_t const   )2265490386UL,      (u_int32_t const   )503444072L,      (u_int32_t const   )1762050814L, 
        (u_int32_t const   )4150417245UL,      (u_int32_t const   )2154129355UL,      (u_int32_t const   )426522225L,      (u_int32_t const   )1852507879L, 
        (u_int32_t const   )4275313526UL,      (u_int32_t const   )2312317920UL,      (u_int32_t const   )282753626L,      (u_int32_t const   )1742555852L, 
        (u_int32_t const   )4189708143UL,      (u_int32_t const   )2394877945UL,      (u_int32_t const   )397917763L,      (u_int32_t const   )1622183637L, 
        (u_int32_t const   )3604390888UL,      (u_int32_t const   )2714866558UL,      (u_int32_t const   )953729732L,      (u_int32_t const   )1340076626L, 
        (u_int32_t const   )3518719985UL,      (u_int32_t const   )2797360999UL,      (u_int32_t const   )1068828381L,      (u_int32_t const   )1219638859L, 
        (u_int32_t const   )3624741850UL,      (u_int32_t const   )2936675148UL,      (u_int32_t const   )906185462L,      (u_int32_t const   )1090812512L, 
        (u_int32_t const   )3747672003UL,      (u_int32_t const   )2825379669UL,      (u_int32_t const   )829329135L,      (u_int32_t const   )1181335161L, 
        (u_int32_t const   )3412177804UL,      (u_int32_t const   )3160834842UL,      (u_int32_t const   )628085408L,      (u_int32_t const   )1382605366L, 
        (u_int32_t const   )3423369109UL,      (u_int32_t const   )3138078467UL,      (u_int32_t const   )570562233L,      (u_int32_t const   )1426400815L, 
        (u_int32_t const   )3317316542UL,      (u_int32_t const   )2998733608UL,      (u_int32_t const   )733239954L,      (u_int32_t const   )1555261956L, 
        (u_int32_t const   )3268935591UL,      (u_int32_t const   )3050360625UL,      (u_int32_t const   )752459403L,      (u_int32_t const   )1541320221L, 
        (u_int32_t const   )2607071920UL,      (u_int32_t const   )3965973030UL,      (u_int32_t const   )1969922972L,      (u_int32_t const   )40735498L, 
        (u_int32_t const   )2617837225UL,      (u_int32_t const   )3943577151UL,      (u_int32_t const   )1913087877L,      (u_int32_t const   )83908371L, 
        (u_int32_t const   )2512341634UL,      (u_int32_t const   )3803740692UL,      (u_int32_t const   )2075208622L,      (u_int32_t const   )213261112L, 
        (u_int32_t const   )2463272603UL,      (u_int32_t const   )3855990285UL,      (u_int32_t const   )2094854071L,      (u_int32_t const   )198958881L, 
        (u_int32_t const   )2262029012UL,      (u_int32_t const   )4057260610UL,      (u_int32_t const   )1759359992L,      (u_int32_t const   )534414190L, 
        (u_int32_t const   )2176718541UL,      (u_int32_t const   )4139329115UL,      (u_int32_t const   )1873836001L,      (u_int32_t const   )414664567L, 
        (u_int32_t const   )2282248934UL,      (u_int32_t const   )4279200368UL,      (u_int32_t const   )1711684554L,      (u_int32_t const   )285281116L, 
        (u_int32_t const   )2405801727UL,      (u_int32_t const   )4167216745UL,      (u_int32_t const   )1634467795L,      (u_int32_t const   )376229701L, 
        (u_int32_t const   )2685067896UL,      (u_int32_t const   )3608007406UL,      (u_int32_t const   )1308918612L,      (u_int32_t const   )956543938L, 
        (u_int32_t const   )2808555105UL,      (u_int32_t const   )3495958263UL,      (u_int32_t const   )1231636301L,      (u_int32_t const   )1047427035L, 
        (u_int32_t const   )2932959818UL,      (u_int32_t const   )3654703836UL,      (u_int32_t const   )1088359270L,      (u_int32_t const   )936918000L, 
        (u_int32_t const   )2847714899UL,      (u_int32_t const   )3736837829UL,      (u_int32_t const   )1202900863L,      (u_int32_t const   )817233897L, 
        (u_int32_t const   )3183342108UL,      (u_int32_t const   )3401237130UL,      (u_int32_t const   )1404277552L,      (u_int32_t const   )615818150L, 
        (u_int32_t const   )3134207493UL,      (u_int32_t const   )3453421203UL,      (u_int32_t const   )1423857449L,      (u_int32_t const   )601450431L, 
        (u_int32_t const   )3009837614UL,      (u_int32_t const   )3294710456UL,      (u_int32_t const   )1567103746L,      (u_int32_t const   )711928724L, 
        (u_int32_t const   )3020668471UL,      (u_int32_t const   )3272380065UL,      (u_int32_t const   )1510334235L,      (u_int32_t const   )755167117L};
#line 96 "crc32.c"
u_int32_t ssh_crc32(u_char const   *buf___1 , u_int32_t size ) 
{ u_int32_t i ;
  u_int32_t crc ;

  {
#line 101
  crc = 0U;
#line 102
  i = 0U;
#line 102
  while (i < size) {
#line 103
    crc = (unsigned int )(crc32tab[(crc ^ (unsigned int )*(buf___1 + i)) & 255U] ^ (unsigned int const   )(crc >> 8));
#line 102
    i ++;
  }
#line 104
  return (crc);
}
}
#line 1 "deattack.o"
#line 29 "deattack.h"
int detect_attack(u_char *buf___1 , u_int32_t len , u_char *IV ) ;
#line 50 "deattack.c"
static void crc_update(u_int32_t *a , u_int32_t b ) 
{ 

  {
#line 53
  b ^= *a;
#line 54
  *a = ssh_crc32((u_char const   *)((u_char *)(& b)), sizeof(b));
#line 55
  return;
}
}
#line 58 "deattack.c"
static int check_crc(u_char *S , u_char *buf___1 , u_int32_t len , u_char *IV ) 
{ u_int32_t crc ;
  u_char *c ;
  int tmp ;
  int tmp___0 ;

  {
#line 65
  crc = 0U;
#line 66
  if (IV) {
#line 66
    tmp = memcmp((void const   *)S, (void const   *)IV, 8U);
#line 66
    if (! tmp) {
#line 67
      crc_update(& crc, 1U);
#line 68
      crc_update(& crc, 0U);
    }
  }
#line 70
  c = buf___1;
#line 70
  while ((unsigned int )c < (unsigned int )(buf___1 + len)) {
#line 71
    tmp___0 = memcmp((void const   *)S, (void const   *)c, 8U);
#line 71
    if (tmp___0) {
#line 75
      crc_update(& crc, 0U);
#line 76
      crc_update(& crc, 0U);
    } else {
#line 72
      crc_update(& crc, 1U);
#line 73
      crc_update(& crc, 0U);
    }
#line 70
    c += 8;
  }
#line 79
  return (crc == 0U);
}
}
#line 87 "deattack.c"
static u_int16_t *h  =    (u_int16_t *)((void *)0);
#line 88 "deattack.c"
static u_int32_t n  =    (u_int32_t )4096;
#line 84 "deattack.c"
int detect_attack(u_char *buf___1 , u_int32_t len , u_char *IV ) 
{ u_int32_t i ;
  u_int32_t j ;
  u_int32_t l ;
  u_char *c ;
  u_char *d ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 94
  if (len > 262144U) {
#line 96
    fatal("detect_attack: bad length %d", len);
  } else {
#line 94
    if (len % 8U != 0U) {
#line 96
      fatal("detect_attack: bad length %d", len);
    }
  }
#line 98
  l = n;
#line 98
  while (l < ((len / 8U) * 3U) / 2U) {
#line 98
    l <<= 2;
  }
#line 101
  if ((unsigned int )h == (unsigned int )((void *)0)) {
#line 102
    debug("Installing crc compensation attack detector.");
#line 103
    tmp = xmalloc(l * 2U);
#line 103
    h = (u_int16_t *)tmp;
#line 104
    n = l;
  } else {
#line 106
    if (l > n) {
#line 107
      tmp___0 = xrealloc((void *)h, l * 2U);
#line 107
      h = (u_int16_t *)tmp___0;
#line 108
      n = l;
    }
  }
#line 112
  if (len <= 56U) {
#line 113
    c = buf___1;
#line 113
    while ((unsigned int )c < (unsigned int )(buf___1 + len)) {
#line 114
      if (IV) {
#line 114
        tmp___2 = memcmp((void const   *)c, (void const   *)IV, 8U);
#line 114
        if (! tmp___2) {
#line 115
          tmp___1 = check_crc(c, buf___1, len, (u_char *)IV);
#line 115
          if (tmp___1) {
#line 116
            return (1);
          } else {
#line 118
            break;
          }
        }
      }
#line 120
      d = buf___1;
#line 120
      while ((unsigned int )d < (unsigned int )c) {
#line 121
        tmp___4 = memcmp((void const   *)c, (void const   *)d, 8U);
#line 121
        if (! tmp___4) {
#line 122
          tmp___3 = check_crc(c, buf___1, len, (u_char *)IV);
#line 122
          if (tmp___3) {
#line 123
            return (1);
          } else {
#line 125
            break;
          }
        }
#line 120
        d += 8;
      }
#line 113
      c += 8;
    }
#line 129
    return (0);
  }
#line 131
  memset((void *)h, 255, n * 2U);
#line 133
  if (IV) {
#line 134
    *(h + ((((((unsigned long )*(IV + 0) << 24) | ((unsigned long )*(IV + 1) << 16)) | ((unsigned long )*(IV + 2) << 8)) | (unsigned long )*(IV + 3)) & (unsigned long )(n - 1U))) = (unsigned short)65534;
  }
#line 136
  c = buf___1;
#line 136
  j = 0U;
#line 136
  while ((unsigned int )c < (unsigned int )(buf___1 + len)) {
#line 137
    i = (unsigned int )((((((unsigned long )*(c + 0) << 24) | ((unsigned long )*(c + 1) << 16)) | ((unsigned long )*(c + 2) << 8)) | (unsigned long )*(c + 3)) & (unsigned long )(n - 1U));
#line 137
    while ((int )*(h + i) != 65535) {
#line 139
      if ((int )*(h + i) == 65534) {
#line 140
        tmp___6 = memcmp((void const   *)c, (void const   *)IV, 8U);
#line 140
        if (! tmp___6) {
#line 141
          tmp___5 = check_crc(c, buf___1, len, (u_char *)IV);
#line 141
          if (tmp___5) {
#line 142
            return (1);
          } else {
#line 144
            break;
          }
        }
      } else {
#line 146
        tmp___8 = memcmp((void const   *)c, (void const   *)(buf___1 + (int )*(h + i) * 8),
                         8U);
#line 146
        if (! tmp___8) {
#line 147
          tmp___7 = check_crc(c, buf___1, len, (u_char *)IV);
#line 147
          if (tmp___7) {
#line 148
            return (1);
          } else {
#line 150
            break;
          }
        }
      }
#line 137
      i = (i + 1U) & (n - 1U);
    }
#line 153
    *(h + i) = (unsigned short )j;
#line 136
    c += 8;
#line 136
    j ++;
  }
#line 155
  return (0);
}
}
#line 1 "fatal.o"
#line 64 "log.h"
void do_log(LogLevel level , char const   *fmt , va_list args ) ;
#line 32 "fatal.c"
 __attribute__((__noreturn__)) void ( /* format attribute */  fatal)(char const   *fmt 
                                                                     , ...) ;
#line 32 "fatal.c"
void ( /* format attribute */  fatal)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 36
  __builtin_va_start(args, fmt);
#line 37
  do_log(1, fmt, args);
#line 38
  __builtin_va_end(args);
#line 39
  cleanup_exit(255);
}
}
#line 1 "hostfile.o"
#line 532 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 597 "/usr/include/openssl/evp.h"
extern EVP_MD const   *EVP_sha1(void) ;
#line 89 "/usr/include/openssl/hmac.h"
extern void HMAC_CTX_cleanup(HMAC_CTX *ctx ) ;
#line 93
extern void HMAC_Init(HMAC_CTX *ctx , void const   *key , int len , EVP_MD const   *md ) ;
#line 97
extern void HMAC_Update(HMAC_CTX *ctx , unsigned char const   *data , size_t len ) ;
#line 98
extern void HMAC_Final(HMAC_CTX *ctx , unsigned char *md , unsigned int *len ) ;
#line 19 "match.h"
int match_hostname(char const   *host , char const   *pattern , u_int len ) ;
#line 62 "key.h"
int key_equal(Key const   *a , Key const   *b ) ;
#line 66
int key_write(Key const   *key , FILE *f ) ;
#line 68
u_int key_size(Key const   *k ) ;
#line 21 "hostfile.h"
int hostfile_read_key(char **cpp , u_int *bitsp , Key *ret ) ;
#line 22
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , Key const   *key ,
                                  Key *found , int *numret ) ;
#line 24
int add_host_to_hostfile(char const   *filename , char const   *host , Key const   *key ,
                         int store_hash ) ;
#line 25
int lookup_key_in_hostfile_by_type(char const   *filename , char const   *host , int keytype ,
                                   Key *found , int *numret ) ;
#line 31
char *host_hash(char const   *host , char const   *name_from_hostfile , u_int src_len ) ;
#line 52 "hostfile.c"
static int extract_salt(char const   *s , u_int l , char *salt , size_t salt_len ) 
{ char *p ;
  char *b64salt ;
  u_int b64len ;
  int ret ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  void *tmp___25 ;
  void *tmp___26 ;

  {
#line 59
  if (l < sizeof("|1|") - 1U) {
#line 60
    debug2("extract_salt: string too short");
#line 61
    return (-1);
  }
#line 63
  if (0) {
#line 63
    if (0) {
#line 63
      __s1_len___0 = strlen(s);
#line 63
      __s2_len___0 = strlen("|1|");
#line 63
      if (! ((unsigned int )((void const   *)(s + 1)) - (unsigned int )((void const   *)s) == 1U)) {
        goto _L___2;
      } else {
#line 63
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 63
          if (! ((unsigned int )((void const   *)("|1|" + 1)) - (unsigned int )((void const   *)"|1|") == 1U)) {
#line 63
            tmp___22 = 1;
          } else {
#line 63
            if (__s2_len___0 >= 4U) {
#line 63
              tmp___22 = 1;
            } else {
#line 63
              tmp___22 = 0;
            }
          }
        } else {
#line 63
          tmp___22 = 0;
        }
      }
#line 63
      if (tmp___22) {
#line 63
        tmp___18 = __builtin_strcmp(s, "|1|");
      } else {
#line 63
        tmp___21 = __builtin_strcmp(s, "|1|");
#line 63
        tmp___18 = tmp___21;
      }
    } else {
#line 63
      tmp___21 = __builtin_strcmp(s, "|1|");
#line 63
      tmp___18 = tmp___21;
    }
#line 63
    tmp___12 = tmp___18;
  } else {
#line 63
    tmp___12 = strncmp(s, "|1|", sizeof("|1|") - 1U);
  }
#line 63
  if (tmp___12 != 0) {
#line 64
    debug2("extract_salt: invalid magic identifier");
#line 65
    return (-1);
  }
#line 67
  s += sizeof("|1|") - 1U;
#line 68
  l -= sizeof("|1|") - 1U;
#line 69
  tmp___25 = memchr((void const   *)s, '|', l);
#line 69
  p = (char *)tmp___25;
#line 69
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 70
    debug2("extract_salt: missing salt termination character");
#line 71
    return (-1);
  }
#line 74
  b64len = (unsigned int )(p - (char *)s);
#line 76
  if (b64len == 0U) {
#line 77
    debug2("extract_salt: bad encoded salt length %u", b64len);
#line 78
    return (-1);
  } else {
#line 76
    if (b64len > 1024U) {
#line 77
      debug2("extract_salt: bad encoded salt length %u", b64len);
#line 78
      return (-1);
    }
  }
#line 80
  tmp___26 = xmalloc(1U + b64len);
#line 80
  b64salt = (char *)tmp___26;
#line 81
  memcpy((void * __restrict  )b64salt, (void const   * __restrict  )s, b64len);
#line 82
  *(b64salt + b64len) = (char )'\000';
#line 84
  ret = __b64_pton((char const   *)b64salt, (u_char *)salt, salt_len);
#line 85
  xfree((void *)b64salt);
#line 86
  if (ret == -1) {
#line 87
    debug2("extract_salt: salt decode error");
#line 88
    return (-1);
  }
#line 90
  if (ret != 20) {
#line 91
    debug2("extract_salt: expected salt len %d, got %d", 20, ret);
#line 93
    return (-1);
  }
#line 96
  return (0);
}
}
#line 105 "hostfile.c"
static char encoded[1024]  ;
#line 99 "hostfile.c"
char *host_hash(char const   *host , char const   *name_from_hostfile , u_int src_len ) 
{ EVP_MD const   *md ;
  EVP_MD const   *tmp ;
  HMAC_CTX mac_ctx ;
  char salt[256] ;
  char result[256] ;
  char uu_salt[512] ;
  char uu_result[512] ;
  u_int i ;
  u_int len ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 102
  tmp = EVP_sha1();
#line 102
  md = tmp;
#line 108
  len = (unsigned int )md->md_size;
#line 110
  if ((unsigned int )name_from_hostfile == (unsigned int )((void *)0)) {
#line 112
    i = 0U;
#line 112
    while (i < len) {
#line 113
      tmp___0 = arc4random();
#line 113
      salt[i] = (char )tmp___0;
#line 112
      i ++;
    }
  } else {
#line 116
    tmp___1 = extract_salt(name_from_hostfile, src_len, salt, sizeof(salt));
#line 116
    if (tmp___1 == -1) {
#line 118
      return ((char *)((void *)0));
    }
  }
#line 121
  HMAC_Init(& mac_ctx, (void const   *)(salt), (int )len, md);
#line 122
  tmp___2 = strlen(host);
#line 122
  HMAC_Update(& mac_ctx, (unsigned char const   *)host, tmp___2);
#line 123
  HMAC_Final(& mac_ctx, (unsigned char *)(result), (unsigned int *)((void *)0));
#line 124
  HMAC_CTX_cleanup(& mac_ctx);
#line 126
  tmp___3 = __b64_ntop((u_char const   *)(salt), len, uu_salt, sizeof(uu_salt));
#line 126
  if (tmp___3 == -1) {
#line 128
    fatal("host_hash: __b64_ntop failed");
  } else {
#line 126
    tmp___4 = __b64_ntop((u_char const   *)(result), len, uu_result, sizeof(uu_result));
#line 126
    if (tmp___4 == -1) {
#line 128
      fatal("host_hash: __b64_ntop failed");
    }
  }
#line 130
  snprintf((char * __restrict  )(encoded), sizeof(encoded), (char const   * __restrict  )"%s%s%c%s",
           "|1|", uu_salt, '|', uu_result);
#line 133
  return (encoded);
}
}
#line 141 "hostfile.c"
int hostfile_read_key(char **cpp , u_int *bitsp , Key *ret ) 
{ char *cp ;
  int tmp ;

  {
#line 147
  cp = *cpp;
#line 147
  while (1) {
#line 147
    if (! ((int )*cp == 32)) {
#line 147
      if (! ((int )*cp == 9)) {
#line 147
        break;
      }
    }
#line 147
    cp ++;
  }
#line 150
  tmp = key_read(ret, & cp);
#line 150
  if (tmp != 1) {
#line 151
    return (0);
  }
#line 154
  while (1) {
#line 154
    if (! ((int )*cp == 32)) {
#line 154
      if (! ((int )*cp == 9)) {
#line 154
        break;
      }
    }
#line 154
    cp ++;
  }
#line 158
  *cpp = cp;
#line 159
  *bitsp = key_size((Key const   *)ret);
#line 160
  return (1);
}
}
#line 163 "hostfile.c"
static int hostfile_check_key(int bits , Key const   *key , char const   *host , char const   *filename ,
                              int linenum ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 166
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 167
    return (1);
  } else {
#line 166
    if (key->type != 0) {
#line 167
      return (1);
    } else {
#line 166
      if ((unsigned int )key->rsa == (unsigned int )((void *)0)) {
#line 167
        return (1);
      }
    }
  }
#line 168
  tmp___1 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 168
  if (bits != tmp___1) {
#line 169
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 169
    logit("Warning: %s, line %d: keysize mismatch for host %s: actual %d vs. announced %d.",
          filename, linenum, host, tmp, bits);
#line 172
    tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 172
    logit("Warning: replace %d with %d in %s, line %d.", bits, tmp___0, filename,
          linenum);
  }
#line 175
  return (1);
}
}
#line 188 "hostfile.c"
static HostStatus check_host_in_hostfile_by_key_or_type(char const   *filename , char const   *host ,
                                                        Key const   *key , int keytype ,
                                                        Key *found , int *numret ) 
{ FILE *f ;
  char line[8192] ;
  int linenum ;
  u_int kbits ;
  char *cp ;
  char *cp2 ;
  char *hashed_host ;
  HostStatus end_return ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;

  {
#line 194
  linenum = 0;
#line 199
  debug3("check_host_in_hostfile: filename %s", filename);
#line 202
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 203
  if (! f) {
#line 204
    return (1);
  }
#line 211
  end_return = 1;
#line 214
  while (1) {
#line 214
    tmp___29 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 214
    if (! tmp___29) {
#line 214
      break;
    }
#line 215
    cp = line;
#line 216
    linenum ++;
#line 219
    while (1) {
#line 219
      if (! ((int )*cp == 32)) {
#line 219
        if (! ((int )*cp == 9)) {
#line 219
          break;
        }
      }
#line 219
      cp ++;
    }
#line 221
    if (! *cp) {
#line 222
      continue;
    } else {
#line 221
      if ((int )*cp == 35) {
#line 222
        continue;
      } else {
#line 221
        if ((int )*cp == 10) {
#line 222
          continue;
        }
      }
    }
#line 225
    cp2 = cp;
#line 225
    while (1) {
#line 225
      if (*cp2) {
#line 225
        if ((int )*cp2 != 32) {
#line 225
          if (! ((int )*cp2 != 9)) {
#line 225
            break;
          }
        } else {
#line 225
          break;
        }
      } else {
#line 225
        break;
      }
#line 225
      cp2 ++;
    }
#line 229
    tmp___25 = match_hostname(host, (char const   *)cp, (unsigned int )(cp2 - cp));
#line 229
    if (tmp___25 != 1) {
#line 230
      if ((int )*cp != 124) {
#line 231
        continue;
      }
#line 232
      hashed_host = host_hash(host, (char const   *)cp, (unsigned int )(cp2 - cp));
#line 233
      if ((unsigned int )hashed_host == (unsigned int )((void *)0)) {
#line 234
        debug("Invalid hashed host line %d of %s", linenum, filename);
#line 236
        continue;
      }
#line 238
      if (0) {
#line 238
        if (0) {
#line 238
          __s1_len___0 = strlen((char const   *)hashed_host);
#line 238
          __s2_len___0 = strlen((char const   *)cp);
#line 238
          if (! ((unsigned int )((void const   *)(hashed_host + 1)) - (unsigned int )((void const   *)hashed_host) == 1U)) {
            goto _L___2;
          } else {
#line 238
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 238
              if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 238
                tmp___22 = 1;
              } else {
#line 238
                if (__s2_len___0 >= 4U) {
#line 238
                  tmp___22 = 1;
                } else {
#line 238
                  tmp___22 = 0;
                }
              }
            } else {
#line 238
              tmp___22 = 0;
            }
          }
#line 238
          if (tmp___22) {
#line 238
            tmp___18 = __builtin_strcmp((char const   *)hashed_host, (char const   *)cp);
          } else {
#line 238
            tmp___21 = __builtin_strcmp((char const   *)hashed_host, (char const   *)cp);
#line 238
            tmp___18 = tmp___21;
          }
        } else {
#line 238
          tmp___21 = __builtin_strcmp((char const   *)hashed_host, (char const   *)cp);
#line 238
          tmp___18 = tmp___21;
        }
#line 238
        tmp___12 = tmp___18;
      } else {
#line 238
        tmp___12 = strncmp((char const   *)hashed_host, (char const   *)cp, (unsigned int )(cp2 - cp));
      }
#line 238
      if (tmp___12 != 0) {
#line 239
        continue;
      }
    }
#line 243
    cp = cp2;
#line 249
    tmp___26 = hostfile_read_key(& cp, & kbits, found);
#line 249
    if (! tmp___26) {
#line 250
      continue;
    }
#line 252
    if ((unsigned int )numret != (unsigned int )((void *)0)) {
#line 253
      *numret = linenum;
    }
#line 255
    if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 257
      if (found->type == keytype) {
#line 258
        return (3);
      }
#line 259
      continue;
    }
#line 262
    tmp___27 = hostfile_check_key((int )kbits, (Key const   *)found, host, filename,
                                  linenum);
#line 262
    if (! tmp___27) {
#line 263
      continue;
    }
#line 266
    tmp___28 = key_equal(key, (Key const   *)found);
#line 266
    if (tmp___28) {
#line 268
      debug3("check_host_in_hostfile: match line %d", linenum);
#line 269
      fclose(f);
#line 270
      return (0);
    }
#line 277
    end_return = 2;
  }
#line 280
  fclose(f);
#line 286
  return (end_return);
}
}
#line 289 "hostfile.c"
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , Key const   *key ,
                                  Key *found , int *numret ) 
{ HostStatus tmp ;

  {
#line 293
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 294
    fatal("no key to look up");
  }
#line 295
  tmp = check_host_in_hostfile_by_key_or_type(filename, host, key, 0, found, numret);
#line 295
  return (tmp);
}
}
#line 299 "hostfile.c"
int lookup_key_in_hostfile_by_type(char const   *filename , char const   *host , int keytype ,
                                   Key *found , int *numret ) 
{ HostStatus tmp ;

  {
#line 303
  tmp = check_host_in_hostfile_by_key_or_type(filename, host, (Key const   *)((void *)0),
                                              keytype, found, numret);
#line 303
  return ((int )tmp == 3);
}
}
#line 312 "hostfile.c"
int add_host_to_hostfile(char const   *filename , char const   *host , Key const   *key ,
                         int store_hash ) 
{ FILE *f ;
  int success ;
  char *hashed_host ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 317
  success = 0;
#line 318
  hashed_host = (char *)((void *)0);
#line 320
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 321
    return (1);
  }
#line 322
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"a");
#line 323
  if (! f) {
#line 324
    return (0);
  }
#line 326
  if (store_hash) {
#line 327
    hashed_host = host_hash(host, (char const   *)((void *)0), 0U);
#line 327
    if ((unsigned int )hashed_host == (unsigned int )((void *)0)) {
#line 328
      error("add_host_to_hostfile: host_hash failed");
#line 329
      fclose(f);
#line 330
      return (0);
    }
  }
#line 333
  if (store_hash) {
#line 333
    tmp = (char const   *)hashed_host;
  } else {
#line 333
    tmp = host;
  }
#line 333
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s ", tmp);
#line 335
  tmp___0 = key_write(key, f);
#line 335
  if (tmp___0) {
#line 336
    success = 1;
  } else {
#line 338
    error("add_host_to_hostfile: saving key in %s failed", filename);
  }
#line 340
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"\n");
#line 341
  fclose(f);
#line 342
  return (success);
}
}
#line 1 "log.o"
#line 646 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 175 "/usr/include/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 51 "log.h"
void log_init(char *av0 , LogLevel level , SyslogFacility facility , int on_stderr ) ;
#line 53
SyslogFacility log_facility_number(char *name ) ;
#line 54
LogLevel log_level_number(char *name ) ;
#line 47 "log.c"
static LogLevel log_level  =    3;
#line 48 "log.c"
static int log_on_stderr  =    1;
#line 49 "log.c"
static int log_facility  =    4 << 3;
#line 50 "log.c"
static char *argv0  ;
#line 59 "log.c"
static struct __anonstruct_log_facilities_77 log_facilities[13]  = 
#line 59
  {      {"DAEMON", 0}, 
        {"USER", 1}, 
        {"AUTH", 2}, 
        {"AUTHPRIV", 3}, 
        {"LOCAL0", 4}, 
        {"LOCAL1", 5}, 
        {"LOCAL2", 6}, 
        {"LOCAL3", 7}, 
        {"LOCAL4", 8}, 
        {"LOCAL5", 9}, 
        {"LOCAL6", 10}, 
        {"LOCAL7", 11}, 
        {(char const   *)((void *)0), -1}};
#line 80 "log.c"
static struct __anonstruct_log_levels_78 log_levels[10]  = 
#line 80
  {      {"QUIET", 0}, 
        {"FATAL", 1}, 
        {"ERROR", 2}, 
        {"INFO", 3}, 
        {"VERBOSE", 4}, 
        {"DEBUG", 5}, 
        {"DEBUG1", 5}, 
        {"DEBUG2", 6}, 
        {"DEBUG3", 7}, 
        {(char const   *)((void *)0), -1}};
#line 97 "log.c"
SyslogFacility log_facility_number(char *name ) 
{ int i ;
  int tmp ;

  {
#line 102
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 103
    i = 0;
#line 103
    while (log_facilities[i].name) {
#line 104
      tmp = strcasecmp(log_facilities[i].name, (char const   *)name);
#line 104
      if (tmp == 0) {
#line 105
        return (log_facilities[i].val);
      }
#line 103
      i ++;
    }
  }
#line 106
  return (-1);
}
}
#line 109 "log.c"
LogLevel log_level_number(char *name ) 
{ int i ;
  int tmp ;

  {
#line 114
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 115
    i = 0;
#line 115
    while (log_levels[i].name) {
#line 116
      tmp = strcasecmp(log_levels[i].name, (char const   *)name);
#line 116
      if (tmp == 0) {
#line 117
        return (log_levels[i].val);
      }
#line 115
      i ++;
    }
  }
#line 118
  return (-1);
}
}
#line 123 "log.c"
void ( /* format attribute */  error)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 128
  __builtin_va_start(args, fmt);
#line 129
  do_log(2, fmt, args);
#line 130
  __builtin_va_end(args);
#line 131
  return;
}
}
#line 135 "log.c"
void ( /* format attribute */  logit)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 140
  __builtin_va_start(args, fmt);
#line 141
  do_log(3, fmt, args);
#line 142
  __builtin_va_end(args);
#line 143
  return;
}
}
#line 147 "log.c"
void ( /* format attribute */  verbose)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 152
  __builtin_va_start(args, fmt);
#line 153
  do_log(4, fmt, args);
#line 154
  __builtin_va_end(args);
#line 155
  return;
}
}
#line 159 "log.c"
void ( /* format attribute */  debug)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 164
  __builtin_va_start(args, fmt);
#line 165
  do_log(5, fmt, args);
#line 166
  __builtin_va_end(args);
#line 167
  return;
}
}
#line 169 "log.c"
void ( /* format attribute */  debug2)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 174
  __builtin_va_start(args, fmt);
#line 175
  do_log(6, fmt, args);
#line 176
  __builtin_va_end(args);
#line 177
  return;
}
}
#line 179 "log.c"
void ( /* format attribute */  debug3)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 184
  __builtin_va_start(args, fmt);
#line 185
  do_log(7, fmt, args);
#line 186
  __builtin_va_end(args);
#line 187
  return;
}
}
#line 193 "log.c"
void log_init(char *av0 , LogLevel level , SyslogFacility facility , int on_stderr ) 
{ char *tmp ;

  {
#line 200
  argv0 = av0;
#line 202
  switch ((int )level) {
  case 0: 
  case 1: 
  case 2: 
  case 3: 
  case 4: 
  case 5: 
  case 6: 
  case 7: 
#line 211
  log_level = level;
#line 212
  break;
  default: 
#line 214
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized internal syslog level code %d\n",
          (int )level);
#line 216
  exit(1);
  }
#line 219
  log_on_stderr = on_stderr;
#line 220
  if (on_stderr) {
#line 221
    return;
  }
#line 223
  switch ((int )facility) {
  case 0: 
#line 225
  log_facility = 3 << 3;
#line 226
  break;
  case 1: 
#line 228
  log_facility = 1 << 3;
#line 229
  break;
  case 2: 
#line 231
  log_facility = 4 << 3;
#line 232
  break;
  case 3: 
#line 235
  log_facility = 10 << 3;
#line 236
  break;
  case 4: 
#line 239
  log_facility = 16 << 3;
#line 240
  break;
  case 5: 
#line 242
  log_facility = 17 << 3;
#line 243
  break;
  case 6: 
#line 245
  log_facility = 18 << 3;
#line 246
  break;
  case 7: 
#line 248
  log_facility = 19 << 3;
#line 249
  break;
  case 8: 
#line 251
  log_facility = 20 << 3;
#line 252
  break;
  case 9: 
#line 254
  log_facility = 21 << 3;
#line 255
  break;
  case 10: 
#line 257
  log_facility = 22 << 3;
#line 258
  break;
  case 11: 
#line 260
  log_facility = 23 << 3;
#line 261
  break;
  default: 
#line 263
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized internal syslog facility code %d\n",
          (int )facility);
#line 266
  exit(1);
  }
#line 278
  if (argv0) {
#line 278
    tmp = argv0;
  } else {
#line 278
    tmp = __progname;
  }
#line 278
  openlog((char const   *)tmp, 1, log_facility);
#line 279
  closelog();
#line 281
  return;
}
}
#line 285 "log.c"
void do_log(LogLevel level , char const   *fmt , va_list args ) 
{ char msgbuf[1024] ;
  char fmtbuf[1024] ;
  char *txt ;
  int pri ;
  int tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 293
  txt = (char *)((void *)0);
#line 294
  pri = 6;
#line 296
  if ((int )level > (int )log_level) {
#line 297
    return;
  }
#line 299
  switch ((int )level) {
  case 1: 
#line 301
  if (! log_on_stderr) {
#line 302
    txt = (char *)"fatal";
  }
#line 303
  pri = 2;
#line 304
  break;
  case 2: 
#line 306
  if (! log_on_stderr) {
#line 307
    txt = (char *)"error";
  }
#line 308
  pri = 3;
#line 309
  break;
  case 3: 
#line 311
  pri = 6;
#line 312
  break;
  case 4: 
#line 314
  pri = 6;
#line 315
  break;
  case 5: 
#line 317
  txt = (char *)"debug1";
#line 318
  pri = 7;
#line 319
  break;
  case 6: 
#line 321
  txt = (char *)"debug2";
#line 322
  pri = 7;
#line 323
  break;
  case 7: 
#line 325
  txt = (char *)"debug3";
#line 326
  pri = 7;
#line 327
  break;
  default: 
#line 329
  txt = (char *)"internal error";
#line 330
  pri = 3;
#line 331
  break;
  }
#line 333
  if ((unsigned int )txt != (unsigned int )((void *)0)) {
#line 334
    snprintf((char * __restrict  )(fmtbuf), sizeof(fmtbuf), (char const   * __restrict  )"%s: %s",
             txt, fmt);
#line 335
    vsnprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )(fmtbuf),
              args);
  } else {
#line 337
    vsnprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )fmt,
              args);
  }
#line 339
  if (log_on_stderr) {
#line 339
    tmp = 33;
  } else {
#line 339
    tmp = 27;
  }
#line 339
  strnvis(fmtbuf, (char const   *)(msgbuf), sizeof(fmtbuf), tmp);
#line 341
  if (log_on_stderr) {
#line 342
    snprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )"%s\r\n",
             fmtbuf);
#line 343
    tmp___0 = strlen((char const   *)(msgbuf));
#line 343
    write(2, (void const   *)(msgbuf), tmp___0);
  } else {
#line 350
    if (argv0) {
#line 350
      tmp___1 = argv0;
    } else {
#line 350
      tmp___1 = __progname;
    }
#line 350
    openlog((char const   *)tmp___1, 1, log_facility);
#line 351
    syslog(pri, "%.500s", fmtbuf);
#line 352
    closelog();
  }
#line 355
  return;
}
}
#line 1 "match.o"
#line 116 "/usr/include/ctype.h"
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 17 "match.h"
int match_pattern(char const   *s , char const   *pattern ) ;
#line 20
int match_host_and_ip(char const   *host , char const   *ipaddr , char const   *patterns ) ;
#line 21
int match_user(char const   *user , char const   *host , char const   *ipaddr , char const   *pattern ) ;
#line 22
char *match_list(char const   *client , char const   *server , u_int *next ) ;
#line 48 "match.c"
int match_pattern(char const   *s , char const   *pattern ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 51
  while (1) {
#line 53
    if (! *pattern) {
#line 54
      return (! *s);
    }
#line 56
    if ((int const   )*pattern == 42) {
#line 58
      pattern ++;
#line 61
      if (! *pattern) {
#line 62
        return (1);
      }
#line 65
      if ((int const   )*pattern != 63) {
#line 65
        if ((int const   )*pattern != 42) {
#line 71
          while (*s) {
#line 72
            if ((int const   )*s == (int const   )*pattern) {
#line 72
              tmp = match_pattern(s + 1, pattern + 1);
#line 72
              if (tmp) {
#line 74
                return (1);
              }
            }
#line 71
            s ++;
          }
#line 76
          return (0);
        }
      }
#line 82
      while (*s) {
#line 83
        tmp___0 = match_pattern(s, pattern);
#line 83
        if (tmp___0) {
#line 84
          return (1);
        }
#line 82
        s ++;
      }
#line 86
      return (0);
    }
#line 92
    if (! *s) {
#line 93
      return (0);
    }
#line 96
    if ((int const   )*pattern != 63) {
#line 96
      if ((int const   )*pattern != (int const   )*s) {
#line 97
        return (0);
      }
    }
#line 100
    s ++;
#line 101
    pattern ++;
  }
}
}
#line 113 "match.c"
int match_pattern_list(char const   *string , char const   *pattern , u_int len ,
                       int dolower ) 
{ char sub[1024] ;
  int negated ;
  int got_positive ;
  u_int i ;
  u_int subi ;
  int __res___0 ;
  __int32_t const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;

  {
#line 122
  got_positive = 0;
#line 123
  i = 0U;
#line 123
  while (i < len) {
#line 125
    if ((int const   )*(pattern + i) == 33) {
#line 126
      negated = 1;
#line 127
      i ++;
    } else {
#line 129
      negated = 0;
    }
#line 135
    subi = 0U;
#line 135
    while (1) {
#line 135
      if (i < len) {
#line 135
        if (subi < sizeof(sub) - 1U) {
#line 135
          if (! ((int const   )*(pattern + i) != 44)) {
#line 135
            break;
          }
        } else {
#line 135
          break;
        }
      } else {
#line 135
        break;
      }
#line 139
      if (dolower) {
#line 139
        tmp___6 = __ctype_b_loc();
#line 139
        if ((int const   )*(*tmp___6 + (int )*(pattern + i)) & 256) {
#line 139
          if (sizeof(*(pattern + i)) > 1U) {
#line 139
            __res___0 = tolower((int )*(pattern + i));
          } else {
#line 139
            tmp___5 = __ctype_tolower_loc();
#line 139
            __res___0 = (int )*(*tmp___5 + (int )*(pattern + i));
          }
#line 139
          sub[subi] = (char )__res___0;
        } else {
#line 139
          sub[subi] = (char )*(pattern + i);
        }
      } else {
#line 139
        sub[subi] = (char )*(pattern + i);
      }
#line 135
      subi ++;
#line 135
      i ++;
    }
#line 141
    if (subi >= sizeof(sub) - 1U) {
#line 142
      return (0);
    }
#line 145
    if (i < len) {
#line 145
      if ((int const   )*(pattern + i) == 44) {
#line 146
        i ++;
      }
    }
#line 149
    sub[subi] = (char )'\000';
#line 152
    tmp___7 = match_pattern(string, (char const   *)(sub));
#line 152
    if (tmp___7) {
#line 153
      if (negated) {
#line 154
        return (-1);
      } else {
#line 156
        got_positive = 1;
      }
    }
  }
#line 164
  return (got_positive);
}
}
#line 173 "match.c"
int match_hostname(char const   *host , char const   *pattern , u_int len ) 
{ int tmp ;

  {
#line 176
  tmp = match_pattern_list(host, pattern, len, 1);
#line 176
  return (tmp);
}
}
#line 183 "match.c"
int match_host_and_ip(char const   *host , char const   *ipaddr , char const   *patterns ) 
{ int mhost ;
  int mip ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 190
  tmp = strlen(patterns);
#line 190
  mip = match_hostname(ipaddr, patterns, tmp);
#line 190
  if (mip == -1) {
#line 191
    return (0);
  }
#line 193
  tmp___0 = strlen(patterns);
#line 193
  mhost = match_hostname(host, patterns, tmp___0);
#line 193
  if (mhost == -1) {
#line 194
    return (0);
  }
#line 196
  if (mhost == 0) {
#line 196
    if (mip == 0) {
#line 197
      return (0);
    }
  }
#line 198
  return (1);
}
}
#line 204 "match.c"
int match_user(char const   *user , char const   *host , char const   *ipaddr , char const   *pattern ) 
{ char *p ;
  char *pat ;
  int ret ;
  int tmp ;
  char *tmp___1 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 211
  tmp___1 = __builtin_strchr((char *)pattern, '@');
#line 211
  p = tmp___1;
#line 211
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 212
    tmp = match_pattern(user, pattern);
#line 212
    return (tmp);
  }
#line 214
  pat = xstrdup(pattern);
#line 215
  tmp___3 = __builtin_strchr(pat, '@');
#line 215
  p = tmp___3;
#line 216
  tmp___4 = p;
#line 216
  p ++;
#line 216
  *tmp___4 = (char )'\000';
#line 218
  ret = match_pattern(user, (char const   *)pat);
#line 218
  if (ret == 1) {
#line 219
    ret = match_host_and_ip(host, ipaddr, (char const   *)p);
  }
#line 220
  xfree((void *)pat);
#line 222
  return (ret);
}
}
#line 231 "match.c"
char *match_list(char const   *client , char const   *server , u_int *next ) 
{ char *sproposals[40] ;
  char *c ;
  char *s ;
  char *p ;
  char *ret ;
  char *cp ;
  char *sp ;
  int i ;
  int j ;
  int nproposals ;
  char *tmp___14 ;
  char *tmp___30 ;
  char *tmp___46 ;
  char *tmp___62 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___69 ;
  int tmp___72 ;
  int tmp___73 ;

  {
#line 238
  cp = xstrdup(client);
#line 238
  c = cp;
#line 239
  sp = xstrdup(server);
#line 239
  s = sp;
#line 241
  tmp___14 = __strsep_g(& sp, ",");
#line 241
  p = tmp___14;
#line 241
  i = 0;
#line 241
  while (1) {
#line 241
    if (p) {
#line 241
      if (! ((int )*p != 0)) {
#line 241
        break;
      }
    } else {
#line 241
      break;
    }
#line 243
    if (i < 40) {
#line 244
      sproposals[i] = p;
    } else {
#line 246
      break;
    }
#line 242
    tmp___30 = __strsep_g(& sp, ",");
#line 242
    p = tmp___30;
#line 242
    i ++;
  }
#line 248
  nproposals = i;
#line 250
  tmp___46 = __strsep_g(& cp, ",");
#line 250
  p = tmp___46;
#line 250
  i = 0;
#line 250
  while (1) {
#line 250
    if (p) {
#line 250
      if (! ((int )*p != 0)) {
#line 250
        break;
      }
    } else {
#line 250
      break;
    }
#line 252
    j = 0;
#line 252
    while (j < nproposals) {
#line 253
      if (0) {
#line 253
        __s1_len = strlen((char const   *)p);
#line 253
        __s2_len = strlen((char const   *)sproposals[j]);
#line 253
        if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
          goto _L___0;
        } else {
#line 253
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 253
            if (! ((unsigned int )((void const   *)(sproposals[j] + 1)) - (unsigned int )((void const   *)sproposals[j]) == 1U)) {
#line 253
              tmp___73 = 1;
            } else {
#line 253
              if (__s2_len >= 4U) {
#line 253
                tmp___73 = 1;
              } else {
#line 253
                tmp___73 = 0;
              }
            }
          } else {
#line 253
            tmp___73 = 0;
          }
        }
#line 253
        if (tmp___73) {
#line 253
          tmp___69 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
        } else {
#line 253
          tmp___72 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
#line 253
          tmp___69 = tmp___72;
        }
      } else {
#line 253
        tmp___72 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
#line 253
        tmp___69 = tmp___72;
      }
#line 253
      if (tmp___69 == 0) {
#line 254
        ret = xstrdup((char const   *)p);
#line 255
        if ((unsigned int )next != (unsigned int )((void *)0)) {
#line 256
          if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 256
            *next = strlen((char const   *)c);
          } else {
#line 256
            *next = (unsigned int )(cp - c);
          }
        }
#line 258
        xfree((void *)c);
#line 259
        xfree((void *)s);
#line 260
        return (ret);
      }
#line 252
      j ++;
    }
#line 251
    tmp___62 = __strsep_g(& cp, ",");
#line 251
    p = tmp___62;
#line 251
    i ++;
  }
#line 264
  if ((unsigned int )next != (unsigned int )((void *)0)) {
#line 265
    *next = strlen((char const   *)c);
  }
#line 266
  xfree((void *)c);
#line 267
  xfree((void *)s);
#line 268
  return ((char *)((void *)0));
}
}
/* compiler builtin: 
   unsigned int __builtin_strspn(char const   * , char const   * ) ;  */
#line 1 "moduli.o"
#line 218 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 188 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) unsigned long strtoul(char const   * __restrict  __nptr ,
                                                                    char ** __restrict  __endptr ,
                                                                    int __base )  __attribute__((__nonnull__(1))) ;
#line 297
extern  __attribute__((__nothrow__)) unsigned long __strtoul_internal(char const   * __restrict  __nptr ,
                                                                      char ** __restrict  __endptr ,
                                                                      int __base ,
                                                                      int __group )  __attribute__((__nonnull__(1))) ;
#line 338
__inline static  __attribute__((__nothrow__)) unsigned long strtoul(char const   * __restrict  __nptr ,
                                                                    char ** __restrict  __endptr ,
                                                                    int __base )  __attribute__((__nonnull__(1))) ;
#line 338 "/usr/include/stdlib.h"
__inline static unsigned long strtoul(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                      int __base ) 
{ unsigned long tmp ;

  {
#line 342
  tmp = __strtoul_internal(__nptr, __endptr, __base, 0);
#line 342
  return (tmp);
}
}
#line 187 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 232
extern  __attribute__((__nothrow__)) struct tm *gmtime(time_t const   *__timer ) ;
#line 257
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 393 "/usr/include/openssl/bn.h"
extern BN_CTX *BN_CTX_new(void) ;
#line 397
extern void BN_CTX_free(BN_CTX *c ) ;
#line 401
extern int BN_rand(BIGNUM *rnd , int bits , int top , int bottom ) ;
#line 407
extern BIGNUM *BN_new(void) ;
#line 410
extern BIGNUM *BN_copy(BIGNUM *a , BIGNUM const   *b ) ;
#line 419
extern int BN_add(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *b ) ;
#line 449
extern unsigned long BN_mod_word(BIGNUM const   *a , unsigned long w ) ;
#line 452
extern int BN_add_word(BIGNUM *a , unsigned long w ) ;
#line 454
extern int BN_set_word(BIGNUM *a , unsigned long w ) ;
#line 458
extern void BN_free(BIGNUM *a ) ;
#line 460
extern int BN_lshift(BIGNUM *r , BIGNUM const   *a , int n ) ;
#line 480
extern int BN_print_fp(FILE *fp , BIGNUM const   *a ) ;
#line 488
extern int BN_rshift(BIGNUM *r , BIGNUM const   *a , int n ) ;
#line 493
extern int BN_set_bit(BIGNUM *a , int n ) ;
#line 495
extern char *BN_bn2hex(BIGNUM const   *a ) ;
#line 497
extern int BN_hex2bn(BIGNUM **a , char const   *str ) ;
#line 511
extern int BN_is_prime(BIGNUM const   *p , int nchecks , void (*callback)(int  , int  ,
                                                                          void * ) ,
                       BN_CTX *ctx , void *cb_arg ) ;
#line 137 "moduli.c"
static u_int32_t *TinySieve  ;
#line 137 "moduli.c"
static u_int32_t tinybits  ;
#line 140 "moduli.c"
static u_int32_t *SmallSieve  ;
#line 140 "moduli.c"
static u_int32_t smallbits  ;
#line 140 "moduli.c"
static u_int32_t smallbase  ;
#line 143 "moduli.c"
static u_int32_t *LargeSieve  ;
#line 143 "moduli.c"
static u_int32_t largewords  ;
#line 143 "moduli.c"
static u_int32_t largetries  ;
#line 143 "moduli.c"
static u_int32_t largenumbers  ;
#line 144 "moduli.c"
static u_int32_t largebits  ;
#line 144 "moduli.c"
static u_int32_t largememory  ;
#line 145 "moduli.c"
static BIGNUM *largebase  ;
#line 147
int gen_candidates(FILE *out , u_int32_t memory , u_int32_t power , BIGNUM *start___0 ) ;
#line 148
int prime_test(FILE *in , FILE *out , u_int32_t trials , u_int32_t generator_wanted ) ;
#line 153 "moduli.c"
static int qfileout(FILE *ofile , u_int32_t otype , u_int32_t otests , u_int32_t otries ,
                    u_int32_t osize , u_int32_t ogenerator , BIGNUM *omodulus ) 
{ struct tm *gtm ;
  time_t time_now ;
  int res ;
  int tmp ;
  int tmp___0 ;

  {
#line 161
  time(& time_now);
#line 162
  gtm = gmtime((time_t const   *)(& time_now));
#line 164
  res = fprintf((FILE * __restrict  )ofile, (char const   * __restrict  )"%04d%02d%02d%02d%02d%02d %u %u %u %u %x ",
                gtm->tm_year + 1900, gtm->tm_mon + 1, gtm->tm_mday, gtm->tm_hour,
                gtm->tm_min, gtm->tm_sec, otype, otests, otries, osize, ogenerator);
#line 169
  if (res < 0) {
#line 170
    return (-1);
  }
#line 172
  tmp = BN_print_fp(ofile, (BIGNUM const   *)omodulus);
#line 172
  if (tmp < 1) {
#line 173
    return (-1);
  }
#line 175
  res = fprintf((FILE * __restrict  )ofile, (char const   * __restrict  )"\n");
#line 176
  fflush(ofile);
#line 178
  if (res > 0) {
#line 178
    tmp___0 = 0;
  } else {
#line 178
    tmp___0 = -1;
  }
#line 178
  return (tmp___0);
}
}
#line 185 "moduli.c"
static void sieve_large(u_int32_t s ) 
{ u_int32_t r ;
  u_int32_t u ;
  unsigned long tmp ;

  {
#line 190
  debug3("sieve_large %u", s);
#line 191
  largetries ++;
#line 193
  tmp = BN_mod_word((BIGNUM const   *)largebase, (unsigned long )s);
#line 193
  r = (unsigned int )tmp;
#line 194
  if (r == 0U) {
#line 195
    u = 0U;
  } else {
#line 197
    u = s - r;
  }
#line 199
  if (u < largebits * 2U) {
#line 205
    if (u & 1U) {
#line 206
      u += s;
    }
#line 209
    u /= 2U;
#line 209
    while (u < largebits) {
#line 210
      *(LargeSieve + (u >> 5)) = (unsigned int )((unsigned long )*(LargeSieve + (u >> 5)) | (unsigned long )(1L << (u & 31U)));
#line 209
      u += s;
    }
  }
#line 214
  r = (2U * r + 1U) % s;
#line 215
  if (r == 0U) {
#line 216
    u = 0U;
  } else {
#line 218
    u = s - r;
  }
#line 220
  if (u < largebits * 4U) {
#line 226
    while (u & 3U) {
#line 227
      if (4294967295UL - (unsigned long )u < (unsigned long )s) {
#line 228
        return;
      }
#line 229
      u += s;
    }
#line 233
    u /= 4U;
#line 233
    while (u < largebits) {
#line 234
      *(LargeSieve + (u >> 5)) = (unsigned int )((unsigned long )*(LargeSieve + (u >> 5)) | (unsigned long )(1L << (u & 31U)));
#line 233
      u += s;
    }
  }
#line 236
  return;
}
}
#line 243 "moduli.c"
int gen_candidates(FILE *out , u_int32_t memory , u_int32_t power , BIGNUM *start___0 ) 
{ BIGNUM *q ;
  u_int32_t j ;
  u_int32_t r ;
  u_int32_t s ;
  u_int32_t t ;
  u_int32_t smallwords ;
  u_int32_t tinywords ;
  time_t time_start ;
  time_t time_stop ;
  u_int32_t i ;
  int ret ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
#line 248
  smallwords = (u_int32_t )((1UL << 16) >> 6);
#line 249
  tinywords = (u_int32_t )((1UL << 16) >> 6);
#line 252
  ret = 0;
#line 254
  largememory = memory;
#line 256
  if (memory != 0U) {
#line 256
    if ((unsigned long )memory < 8UL) {
#line 258
      error("Invalid memory amount (min %ld, max %ld)", 8UL, 127UL);
#line 260
      return (-1);
    } else {
#line 256
      if ((unsigned long )memory > 127UL) {
#line 258
        error("Invalid memory amount (min %ld, max %ld)", 8UL, 127UL);
#line 260
        return (-1);
      }
    }
  }
#line 267
  if ((unsigned long )power > 1UL << 16) {
#line 268
    error("Too many bits: %u > %lu", power, 1UL << 16);
#line 269
    return (-1);
  } else {
#line 270
    if (power < 512U) {
#line 271
      error("Too few bits: %u < %u", power, 512);
#line 272
      return (-1);
    }
  }
#line 274
  power --;
#line 282
  largewords = power * power >> 2;
#line 288
  if ((unsigned long )largememory > 127UL) {
#line 289
    logit("Limited memory: %u MB; limit %lu MB", largememory, 127UL);
#line 291
    largememory = 127U;
  }
#line 294
  if (largewords <= largememory << 18) {
#line 295
    logit("Increased memory: %u MB; need %u bytes", largememory, largewords << 2);
#line 297
    largewords = largememory << 18;
  } else {
#line 298
    if (largememory > 0U) {
#line 299
      logit("Decreased memory: %u MB; want %u bytes", largememory, largewords << 2);
#line 301
      largewords = largememory << 18;
    }
  }
#line 304
  tmp = calloc(tinywords, sizeof(u_int32_t ));
#line 304
  TinySieve = (u_int32_t *)tmp;
#line 305
  if ((unsigned int )TinySieve == (unsigned int )((void *)0)) {
#line 306
    error("Insufficient memory for tiny sieve: need %u bytes", tinywords << 2);
#line 308
    exit(1);
  }
#line 310
  tinybits = tinywords << 5;
#line 312
  tmp___0 = calloc(smallwords, sizeof(u_int32_t ));
#line 312
  SmallSieve = (u_int32_t *)tmp___0;
#line 313
  if ((unsigned int )SmallSieve == (unsigned int )((void *)0)) {
#line 314
    error("Insufficient memory for small sieve: need %u bytes", smallwords << 2);
#line 316
    xfree((void *)TinySieve);
#line 317
    exit(1);
  }
#line 319
  smallbits = smallwords << 5;
#line 324
  while (1) {
#line 324
    tmp___1 = calloc(largewords, sizeof(u_int32_t ));
#line 324
    LargeSieve = (u_int32_t *)tmp___1;
#line 324
    if (! ((unsigned int )LargeSieve == (unsigned int )((void *)0))) {
#line 324
      break;
    }
#line 325
    largewords = (unsigned int )((unsigned long )largewords - (unsigned long )(1L << 16));
  }
#line 327
  largebits = largewords << 5;
#line 328
  largenumbers = largebits * 2U;
#line 331
  largetries = 0U;
#line 332
  q = BN_new();
#line 338
  largebase = BN_new();
#line 339
  if ((unsigned int )start___0 == (unsigned int )((void *)0)) {
#line 340
    BN_rand(largebase, (int )power, 1, 1);
  } else {
#line 342
    BN_copy(largebase, (BIGNUM const   *)start___0);
  }
#line 345
  BN_set_bit(largebase, 0);
#line 347
  time(& time_start);
#line 349
  tmp___2 = ctime((time_t const   *)(& time_start));
#line 349
  logit("%.24s Sieve next %u plus %u-bit", tmp___2, largenumbers, power);
#line 351
  tmp___3 = BN_bn2hex((BIGNUM const   *)largebase);
#line 351
  debug2("start point: 0x%s", tmp___3);
#line 356
  i = 0U;
#line 356
  while (i < tinybits) {
#line 357
    if ((unsigned long )*(TinySieve + (i >> 5)) & (unsigned long )(1L << (i & 31U))) {
      goto __Cont;
    }
#line 361
    t = 2U * i + 3U;
#line 364
    j = i + t;
#line 364
    while (j < tinybits) {
#line 365
      *(TinySieve + (j >> 5)) = (unsigned int )((unsigned long )*(TinySieve + (j >> 5)) | (unsigned long )(1L << (j & 31U)));
#line 364
      j += t;
    }
#line 367
    sieve_large(t);
    __Cont: /* CIL Label */ 
#line 356
    i ++;
  }
#line 374
  smallbase = (unsigned int )((1UL << 16) + 3UL);
#line 374
  while ((unsigned long )smallbase < 4294967295UL - (1UL << 16)) {
#line 377
    i = 0U;
#line 377
    while (i < tinybits) {
#line 378
      if ((unsigned long )*(TinySieve + (i >> 5)) & (unsigned long )(1L << (i & 31U))) {
        goto __Cont___0;
      }
#line 382
      t = 2U * i + 3U;
#line 383
      r = smallbase % t;
#line 385
      if (r == 0U) {
#line 386
        s = 0U;
      } else {
#line 389
        s = t - r;
      }
#line 397
      if (s & 1U) {
#line 398
        s += t;
      }
#line 401
      s /= 2U;
#line 401
      while (s < smallbits) {
#line 402
        *(SmallSieve + (s >> 5)) = (unsigned int )((unsigned long )*(SmallSieve + (s >> 5)) | (unsigned long )(1L << (s & 31U)));
#line 401
        s += t;
      }
      __Cont___0: /* CIL Label */ 
#line 377
      i ++;
    }
#line 408
    i = 0U;
#line 408
    while (i < smallbits) {
#line 409
      if ((unsigned long )*(SmallSieve + (i >> 5)) & (unsigned long )(1L << (i & 31U))) {
        goto __Cont___1;
      }
#line 413
      sieve_large(2U * i + smallbase);
      __Cont___1: /* CIL Label */ 
#line 408
      i ++;
    }
#line 416
    memset((void *)SmallSieve, 0, smallwords << 2);
#line 374
    smallbase = (unsigned int )((unsigned long )smallbase + (1UL << 16));
  }
#line 419
  time(& time_stop);
#line 421
  tmp___4 = ctime((time_t const   *)(& time_stop));
#line 421
  logit("%.24s Sieved with %u small primes in %ld seconds", tmp___4, largetries, time_stop - time_start);
#line 424
  r = 0U;
#line 424
  j = r;
#line 424
  while (j < largebits) {
#line 425
    if ((unsigned long )*(LargeSieve + (j >> 5)) & (unsigned long )(1L << (j & 31U))) {
      goto __Cont___2;
    }
#line 428
    debug2("test q = largebase+%u", 2U * j);
#line 429
    BN_set_word(q, (unsigned long )(2U * j));
#line 430
    BN_add(q, (BIGNUM const   *)q, (BIGNUM const   *)largebase);
#line 431
    tmp___5 = qfileout(out, 4U, 2U, largetries, power - 1U, 0U, q);
#line 431
    if (tmp___5 == -1) {
#line 433
      ret = -1;
#line 434
      break;
    }
#line 437
    r ++;
    __Cont___2: /* CIL Label */ 
#line 424
    j ++;
  }
#line 440
  time(& time_stop);
#line 442
  xfree((void *)LargeSieve);
#line 443
  xfree((void *)SmallSieve);
#line 444
  xfree((void *)TinySieve);
#line 446
  tmp___6 = ctime((time_t const   *)(& time_stop));
#line 446
  logit("%.24s Found %u candidates", tmp___6, r);
#line 448
  return (ret);
}
}
#line 457 "moduli.c"
int prime_test(FILE *in , FILE *out , u_int32_t trials , u_int32_t generator_wanted ) 
{ BIGNUM *q ;
  BIGNUM *p ;
  BIGNUM *a ;
  BN_CTX *ctx ;
  char *cp ;
  char *lp ;
  u_int32_t count_in ;
  u_int32_t count_out ;
  u_int32_t count_possible ;
  u_int32_t generator_known ;
  u_int32_t in_tests ;
  u_int32_t in_tries ;
  u_int32_t in_type ;
  u_int32_t in_size ;
  time_t time_start ;
  time_t time_stop ;
  int res ;
  char *tmp ;
  void *tmp___0 ;
  int ll ;
  size_t tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned int tmp___38 ;
  int tmp___39 ;
  u_int32_t r ;
  unsigned long tmp___40 ;
  unsigned long tmp___41 ;
  unsigned long tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;

  {
#line 463
  count_in = (u_int32_t )0;
#line 463
  count_out = (u_int32_t )0;
#line 463
  count_possible = (u_int32_t )0;
#line 468
  if (trials < 4U) {
#line 469
    error("Minimum primality trials is %d", 4);
#line 470
    return (-1);
  }
#line 473
  time(& time_start);
#line 475
  p = BN_new();
#line 476
  q = BN_new();
#line 477
  ctx = BN_CTX_new();
#line 479
  tmp = ctime((time_t const   *)(& time_start));
#line 479
  debug2("%.24s Final %u Miller-Rabin trials (%x generator)", tmp, trials, generator_wanted);
#line 482
  res = 0;
#line 483
  tmp___0 = xmalloc(8293U);
#line 483
  lp = (char *)tmp___0;
#line 484
  while (1) {
#line 484
    tmp___47 = fgets((char * __restrict  )lp, 8292, (FILE * __restrict  )in);
#line 484
    if (! ((unsigned int )tmp___47 != (unsigned int )((void *)0))) {
#line 484
      break;
    }
#line 485
    tmp___1 = strlen((char const   *)lp);
#line 485
    ll = (int )tmp___1;
#line 487
    count_in ++;
#line 488
    if (ll < 14) {
#line 489
      debug2("%10u: comment or short line", count_in);
#line 490
      continue;
    } else {
#line 488
      if ((int )*lp == 33) {
#line 489
        debug2("%10u: comment or short line", count_in);
#line 490
        continue;
      } else {
#line 488
        if ((int )*lp == 35) {
#line 489
          debug2("%10u: comment or short line", count_in);
#line 490
          continue;
        }
      }
    }
#line 495
    cp = lp + 14;
#line 498
    tmp___2 = strtoul((char const   * __restrict  )cp, (char ** __restrict  )(& cp),
                      10);
#line 498
    in_type = (unsigned int )tmp___2;
#line 501
    tmp___3 = strtoul((char const   * __restrict  )cp, (char ** __restrict  )(& cp),
                      10);
#line 501
    in_tests = (unsigned int )tmp___3;
#line 503
    if (in_tests & 1U) {
#line 504
      debug2("%10u: known composite", count_in);
#line 505
      continue;
    }
#line 509
    tmp___4 = strtoul((char const   * __restrict  )cp, (char ** __restrict  )(& cp),
                      10);
#line 509
    in_tries = (unsigned int )tmp___4;
#line 512
    tmp___5 = strtoul((char const   * __restrict  )cp, (char ** __restrict  )(& cp),
                      10);
#line 512
    in_size = (unsigned int )tmp___5;
#line 515
    tmp___6 = strtoul((char const   * __restrict  )cp, (char ** __restrict  )(& cp),
                      16);
#line 515
    generator_known = (unsigned int )tmp___6;
#line 518
    tmp___38 = __builtin_strspn((char const   *)cp, " ");
#line 518
    cp += tmp___38;
#line 521
    switch ((int )in_type) {
    case 4: 
#line 523
    debug2("%10u: (%u) Sophie-Germain", count_in, in_type);
#line 524
    a = q;
#line 525
    BN_hex2bn(& a, (char const   *)cp);
#line 527
    BN_lshift(p, (BIGNUM const   *)q, 1);
#line 528
    BN_add_word(p, 1UL);
#line 529
    in_size ++;
#line 530
    generator_known = 0U;
#line 531
    break;
    case 1: 
    case 2: 
    case 3: 
    case 5: 
    case 0: 
#line 537
    debug2("%10u: (%u)", count_in, in_type);
#line 538
    a = p;
#line 539
    BN_hex2bn(& a, (char const   *)cp);
#line 541
    BN_rshift(q, (BIGNUM const   *)p, 1);
#line 542
    break;
    default: 
#line 544
    debug2("Unknown prime type");
#line 545
    break;
    }
#line 552
    tmp___39 = BN_num_bits((BIGNUM const   *)p);
#line 552
    if ((unsigned int )tmp___39 != in_size + 1U) {
#line 553
      debug2("%10u: bit size %u mismatch", count_in, in_size);
#line 554
      continue;
    }
#line 556
    if (in_size < 511U) {
#line 557
      debug2("%10u: bit size %u too short", count_in, in_size);
#line 558
      continue;
    }
#line 561
    if (in_tests & 4U) {
#line 562
      in_tries += trials;
    } else {
#line 564
      in_tries = trials;
    }
#line 569
    if (generator_known == 0U) {
#line 570
      tmp___42 = BN_mod_word((BIGNUM const   *)p, 24UL);
#line 570
      if (tmp___42 == 11UL) {
#line 571
        generator_known = 2U;
      } else {
#line 572
        tmp___41 = BN_mod_word((BIGNUM const   *)p, 12UL);
#line 572
        if (tmp___41 == 5UL) {
#line 573
          generator_known = 3U;
        } else {
#line 575
          tmp___40 = BN_mod_word((BIGNUM const   *)p, 10UL);
#line 575
          r = (u_int32_t )tmp___40;
#line 577
          if (r == 3U) {
#line 578
            generator_known = 5U;
          } else {
#line 577
            if (r == 7U) {
#line 578
              generator_known = 5U;
            }
          }
        }
      }
    }
#line 584
    if (generator_wanted > 0U) {
#line 584
      if (generator_wanted != generator_known) {
#line 586
        debug2("%10u: generator %d != %d", count_in, generator_known, generator_wanted);
#line 588
        continue;
      }
    }
#line 595
    if (generator_known == 0U) {
#line 596
      debug2("%10u: no known generator", count_in);
#line 597
      continue;
    }
#line 600
    count_possible ++;
#line 609
    tmp___43 = BN_is_prime((BIGNUM const   *)q, 1, (void (*)(int  , int  , void * ))((void *)0),
                           ctx, (void *)0);
#line 609
    if (tmp___43 <= 0) {
#line 610
      debug("%10u: q failed first possible prime test", count_in);
#line 612
      continue;
    }
#line 622
    tmp___44 = BN_is_prime((BIGNUM const   *)p, (int )trials, (void (*)(int  , int  ,
                                                                        void * ))((void *)0),
                           ctx, (void *)0);
#line 622
    if (! tmp___44) {
#line 623
      debug("%10u: p is not prime", count_in);
#line 624
      continue;
    }
#line 626
    debug("%10u: p is almost certainly prime", count_in);
#line 629
    tmp___45 = BN_is_prime((BIGNUM const   *)q, (int )(trials - 1U), (void (*)(int  ,
                                                                               int  ,
                                                                               void * ))((void *)0),
                           ctx, (void *)0);
#line 629
    if (! tmp___45) {
#line 630
      debug("%10u: q is not prime", count_in);
#line 631
      continue;
    }
#line 633
    debug("%10u: q is almost certainly prime", count_in);
#line 635
    tmp___46 = qfileout(out, 2U, in_tests | 4U, in_tries, in_size, generator_known,
                        p);
#line 635
    if (tmp___46) {
#line 637
      res = -1;
#line 638
      break;
    }
#line 641
    count_out ++;
  }
#line 644
  time(& time_stop);
#line 645
  xfree((void *)lp);
#line 646
  BN_free(p);
#line 647
  BN_free(q);
#line 648
  BN_CTX_free(ctx);
#line 650
  tmp___48 = ctime((time_t const   *)(& time_stop));
#line 650
  logit("%.24s Found %u safe primes of %u candidates in %ld seconds", tmp___48, count_out,
        count_possible, time_stop - time_start);
#line 654
  return (res);
}
}
#line 1 "nchan.o"
#line 69 "nchan.c"
static void chan_send_ieof1(Channel *c ) ;
#line 70
static void chan_send_oclose1(Channel *c ) ;
#line 71
static void chan_send_close2(Channel *c ) ;
#line 72
static void chan_send_eof2(Channel *c ) ;
#line 75
static void chan_shutdown_write(Channel *c ) ;
#line 76
static void chan_shutdown_read(Channel *c ) ;
#line 78 "nchan.c"
static char *ostates[4]  = {      (char *)"open",      (char *)"drain",      (char *)"wait_ieof",      (char *)"closed"};
#line 79 "nchan.c"
static char *istates[4]  = {      (char *)"open",      (char *)"drain",      (char *)"wait_oclose",      (char *)"closed"};
#line 81 "nchan.c"
static void chan_set_istate(Channel *c , u_int next ) 
{ 

  {
#line 84
  if (c->istate > 3U) {
#line 85
    fatal("chan_set_istate: bad state %d -> %d", c->istate, next);
  } else {
#line 84
    if (next > 3U) {
#line 85
      fatal("chan_set_istate: bad state %d -> %d", c->istate, next);
    }
  }
#line 86
  debug2("channel %d: input %s -> %s", c->self, istates[c->istate], istates[next]);
#line 88
  c->istate = next;
#line 89
  return;
}
}
#line 90 "nchan.c"
static void chan_set_ostate(Channel *c , u_int next ) 
{ 

  {
#line 93
  if (c->ostate > 3U) {
#line 94
    fatal("chan_set_ostate: bad state %d -> %d", c->ostate, next);
  } else {
#line 93
    if (next > 3U) {
#line 94
      fatal("chan_set_ostate: bad state %d -> %d", c->ostate, next);
    }
  }
#line 95
  debug2("channel %d: output %s -> %s", c->self, ostates[c->ostate], ostates[next]);
#line 97
  c->ostate = next;
#line 98
  return;
}
}
#line 104 "nchan.c"
static void chan_rcvd_oclose1(Channel *c ) 
{ 

  {
#line 107
  debug2("channel %d: rcvd oclose", c->self);
#line 108
  switch ((int )c->istate) {
  case 2: 
#line 110
  chan_set_istate(c, 3U);
#line 111
  break;
  case 0: 
#line 113
  chan_shutdown_read(c);
#line 114
  chan_send_ieof1(c);
#line 115
  chan_set_istate(c, 3U);
#line 116
  break;
  case 1: 
#line 119
  chan_send_ieof1(c);
#line 120
  chan_set_istate(c, 3U);
#line 121
  break;
  default: 
#line 123
  error("channel %d: protocol error: rcvd_oclose for istate %d", c->self, c->istate);
#line 125
  return;
  }
#line 127
  return;
}
}
#line 128 "nchan.c"
void chan_read_failed(Channel *c ) 
{ 

  {
#line 131
  debug2("channel %d: read failed", c->self);
#line 132
  switch ((int )c->istate) {
  case 0: 
#line 134
  chan_shutdown_read(c);
#line 135
  chan_set_istate(c, 1U);
#line 136
  break;
  default: 
#line 138
  error("channel %d: chan_read_failed for istate %d", c->self, c->istate);
#line 140
  break;
  }
#line 142
  return;
}
}
#line 143 "nchan.c"
void chan_ibuf_empty(Channel *c ) 
{ u_int tmp ;

  {
#line 146
  debug2("channel %d: ibuf empty", c->self);
#line 147
  tmp = buffer_len(& c->input);
#line 147
  if (tmp) {
#line 148
    error("channel %d: chan_ibuf_empty for non empty buffer", c->self);
#line 150
    return;
  }
#line 152
  switch ((int )c->istate) {
  case 1: 
#line 154
  if (compat20) {
#line 155
    if (! (c->flags & 1)) {
#line 156
      chan_send_eof2(c);
    }
#line 157
    chan_set_istate(c, 3U);
  } else {
#line 159
    chan_send_ieof1(c);
#line 160
    chan_set_istate(c, 2U);
  }
#line 162
  break;
  default: 
#line 164
  error("channel %d: chan_ibuf_empty for istate %d", c->self, c->istate);
#line 166
  break;
  }
#line 168
  return;
}
}
#line 169 "nchan.c"
static void chan_rcvd_ieof1(Channel *c ) 
{ 

  {
#line 172
  debug2("channel %d: rcvd ieof", c->self);
#line 173
  switch ((int )c->ostate) {
  case 0: 
#line 175
  chan_set_ostate(c, 1U);
#line 176
  break;
  case 2: 
#line 178
  chan_set_ostate(c, 3U);
#line 179
  break;
  default: 
#line 181
  error("channel %d: protocol error: rcvd_ieof for ostate %d", c->self, c->ostate);
#line 183
  break;
  }
#line 185
  return;
}
}
#line 186 "nchan.c"
static void chan_write_failed1(Channel *c ) 
{ 

  {
#line 189
  debug2("channel %d: write failed", c->self);
#line 190
  switch ((int )c->ostate) {
  case 0: 
#line 192
  chan_shutdown_write(c);
#line 193
  chan_send_oclose1(c);
#line 194
  chan_set_ostate(c, 2U);
#line 195
  break;
  case 1: 
#line 197
  chan_shutdown_write(c);
#line 198
  chan_send_oclose1(c);
#line 199
  chan_set_ostate(c, 3U);
#line 200
  break;
  default: 
#line 202
  error("channel %d: chan_write_failed for ostate %d", c->self, c->ostate);
#line 204
  break;
  }
#line 206
  return;
}
}
#line 207 "nchan.c"
void chan_obuf_empty(Channel *c ) 
{ u_int tmp ;

  {
#line 210
  debug2("channel %d: obuf empty", c->self);
#line 211
  tmp = buffer_len(& c->output);
#line 211
  if (tmp) {
#line 212
    error("channel %d: chan_obuf_empty for non empty buffer", c->self);
#line 214
    return;
  }
#line 216
  switch ((int )c->ostate) {
  case 1: 
#line 218
  chan_shutdown_write(c);
#line 219
  if (! compat20) {
#line 220
    chan_send_oclose1(c);
  }
#line 221
  chan_set_ostate(c, 3U);
#line 222
  break;
  default: 
#line 224
  error("channel %d: internal error: obuf_empty for ostate %d", c->self, c->ostate);
#line 226
  break;
  }
#line 228
  return;
}
}
#line 229 "nchan.c"
static void chan_send_ieof1(Channel *c ) 
{ 

  {
#line 232
  debug2("channel %d: send ieof", c->self);
#line 233
  switch ((int )c->istate) {
  case 0: 
  case 1: 
#line 236
  packet_start((unsigned char)24);
#line 237
  packet_put_int((unsigned int )c->remote_id);
#line 238
  packet_send();
#line 239
  break;
  default: 
#line 241
  error("channel %d: cannot send ieof for istate %d", c->self, c->istate);
#line 243
  break;
  }
#line 245
  return;
}
}
#line 246 "nchan.c"
static void chan_send_oclose1(Channel *c ) 
{ 

  {
#line 249
  debug2("channel %d: send oclose", c->self);
#line 250
  switch ((int )c->ostate) {
  case 0: 
  case 1: 
#line 253
  buffer_clear(& c->output);
#line 254
  packet_start((unsigned char)25);
#line 255
  packet_put_int((unsigned int )c->remote_id);
#line 256
  packet_send();
#line 257
  break;
  default: 
#line 259
  error("channel %d: cannot send oclose for ostate %d", c->self, c->ostate);
#line 261
  break;
  }
#line 263
  return;
}
}
#line 268 "nchan.c"
static void chan_rcvd_close2(Channel *c ) 
{ 

  {
#line 271
  debug2("channel %d: rcvd close", c->self);
#line 272
  if (c->flags & 2) {
#line 273
    error("channel %d: protocol error: close rcvd twice", c->self);
  }
#line 274
  c->flags |= 2;
#line 275
  if (c->type == 10) {
#line 277
    chan_set_ostate(c, 3U);
#line 278
    chan_set_istate(c, 3U);
#line 279
    return;
  }
#line 281
  switch ((int )c->ostate) {
  case 0: 
#line 287
  chan_set_ostate(c, 1U);
#line 288
  break;
  }
#line 290
  switch ((int )c->istate) {
  case 0: 
#line 292
  chan_shutdown_read(c);
#line 293
  chan_set_istate(c, 3U);
#line 294
  break;
  case 1: 
#line 296
  chan_send_eof2(c);
#line 297
  chan_set_istate(c, 3U);
#line 298
  break;
  }
#line 300
  return;
}
}
#line 301 "nchan.c"
static void chan_rcvd_eof2(Channel *c ) 
{ 

  {
#line 304
  debug2("channel %d: rcvd eof", c->self);
#line 305
  c->flags |= 8;
#line 306
  if (c->ostate == 0U) {
#line 307
    chan_set_ostate(c, 1U);
  }
#line 308
  return;
}
}
#line 309 "nchan.c"
static void chan_write_failed2(Channel *c ) 
{ 

  {
#line 312
  debug2("channel %d: write failed", c->self);
#line 313
  switch ((int )c->ostate) {
  case 0: 
  case 1: 
#line 316
  chan_shutdown_write(c);
#line 317
  chan_set_ostate(c, 3U);
#line 318
  break;
  default: 
#line 320
  error("channel %d: chan_write_failed for ostate %d", c->self, c->ostate);
#line 322
  break;
  }
#line 324
  return;
}
}
#line 325 "nchan.c"
static void chan_send_eof2(Channel *c ) 
{ 

  {
#line 328
  debug2("channel %d: send eof", c->self);
#line 329
  switch ((int )c->istate) {
  case 1: 
#line 331
  packet_start((unsigned char)96);
#line 332
  packet_put_int((unsigned int )c->remote_id);
#line 333
  packet_send();
#line 334
  c->flags |= 4;
#line 335
  break;
  default: 
#line 337
  error("channel %d: cannot send eof for istate %d", c->self, c->istate);
#line 339
  break;
  }
#line 341
  return;
}
}
#line 342 "nchan.c"
static void chan_send_close2(Channel *c ) 
{ 

  {
#line 345
  debug2("channel %d: send close", c->self);
#line 346
  if (c->ostate != 3U) {
#line 348
    error("channel %d: cannot send close for istate/ostate %d/%d", c->self, c->istate,
          c->ostate);
  } else {
#line 346
    if (c->istate != 3U) {
#line 348
      error("channel %d: cannot send close for istate/ostate %d/%d", c->self, c->istate,
            c->ostate);
    } else {
#line 350
      if (c->flags & 1) {
#line 351
        error("channel %d: already sent close", c->self);
      } else {
#line 353
        packet_start((unsigned char)97);
#line 354
        packet_put_int((unsigned int )c->remote_id);
#line 355
        packet_send();
#line 356
        c->flags |= 1;
      }
    }
  }
#line 358
  return;
}
}
#line 362 "nchan.c"
void chan_rcvd_ieof(Channel *c ) 
{ u_int tmp ;
  u_int tmp___0 ;

  {
#line 365
  if (compat20) {
#line 366
    chan_rcvd_eof2(c);
  } else {
#line 368
    chan_rcvd_ieof1(c);
  }
#line 369
  if (c->ostate == 1U) {
#line 369
    tmp = buffer_len(& c->output);
#line 369
    if (tmp == 0U) {
#line 369
      if (compat20) {
#line 369
        if (c->extended_usage == 2) {
#line 369
          if (c->efd != -1) {
#line 369
            if (! (! (c->flags & 10))) {
#line 369
              tmp___0 = buffer_len(& c->extended);
#line 369
              if (! (tmp___0 > 0U)) {
#line 372
                chan_obuf_empty(c);
              }
            }
          } else {
#line 372
            chan_obuf_empty(c);
          }
        } else {
#line 372
          chan_obuf_empty(c);
        }
      } else {
#line 372
        chan_obuf_empty(c);
      }
    }
  }
#line 373
  return;
}
}
#line 374 "nchan.c"
void chan_rcvd_oclose(Channel *c ) 
{ 

  {
#line 377
  if (compat20) {
#line 378
    chan_rcvd_close2(c);
  } else {
#line 380
    chan_rcvd_oclose1(c);
  }
#line 381
  return;
}
}
#line 382 "nchan.c"
void chan_write_failed(Channel *c ) 
{ 

  {
#line 385
  if (compat20) {
#line 386
    chan_write_failed2(c);
  } else {
#line 388
    chan_write_failed1(c);
  }
#line 389
  return;
}
}
#line 391 "nchan.c"
void chan_mark_dead(Channel *c ) 
{ 

  {
#line 394
  c->type = 14;
#line 395
  return;
}
}
#line 397 "nchan.c"
int chan_is_dead(Channel *c , int do_send ) 
{ u_int tmp ;
  u_int tmp___0 ;

  {
#line 400
  if (c->type == 14) {
#line 401
    debug2("channel %d: zombie", c->self);
#line 402
    return (1);
  }
#line 404
  if (c->istate != 3U) {
#line 405
    return (0);
  } else {
#line 404
    if (c->ostate != 3U) {
#line 405
      return (0);
    }
  }
#line 406
  if (! compat20) {
#line 407
    debug2("channel %d: is dead", c->self);
#line 408
    return (1);
  }
#line 410
  if (datafellows & 2097152) {
#line 410
    if (c->extended_usage == 2) {
#line 410
      if (c->efd != -1) {
#line 410
        tmp___0 = buffer_len(& c->extended);
#line 410
        if (tmp___0 > 0U) {
#line 414
          tmp = buffer_len(& c->extended);
#line 414
          debug2("channel %d: active efd: %d len %d", c->self, c->efd, tmp);
#line 416
          return (0);
        }
      }
    }
  }
#line 418
  if (! (c->flags & 1)) {
#line 419
    if (do_send) {
#line 420
      chan_send_close2(c);
    } else {
#line 423
      if (c->flags & 2) {
#line 424
        debug2("channel %d: almost dead", c->self);
#line 426
        return (1);
      }
    }
  }
#line 430
  if (c->flags & 1) {
#line 430
    if (c->flags & 2) {
#line 432
      debug2("channel %d: is dead", c->self);
#line 433
      return (1);
    }
  }
#line 435
  return (0);
}
}
#line 439 "nchan.c"
static void chan_shutdown_write(Channel *c ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 442
  buffer_clear(& c->output);
#line 443
  if (compat20) {
#line 443
    if (c->type == 10) {
#line 444
      return;
    }
  }
#line 446
  debug2("channel %d: close_write", c->self);
#line 447
  if (c->sock != -1) {
#line 448
    tmp___1 = shutdown(c->sock, 1);
#line 448
    if (tmp___1 < 0) {
#line 449
      tmp = __errno_location();
#line 449
      tmp___0 = strerror(*tmp);
#line 449
      debug2("channel %d: chan_shutdown_write: shutdown() failed for fd%d: %.100s",
             c->self, c->sock, tmp___0);
    }
  } else {
#line 453
    tmp___4 = channel_close_fd(& c->wfd);
#line 453
    if (tmp___4 < 0) {
#line 454
      tmp___2 = __errno_location();
#line 454
      tmp___3 = strerror(*tmp___2);
#line 454
      logit("channel %d: chan_shutdown_write: close() failed for fd%d: %.100s", c->self,
            c->wfd, tmp___3);
    }
  }
#line 458
  return;
}
}
#line 459 "nchan.c"
static void chan_shutdown_read(Channel *c ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 462
  if (compat20) {
#line 462
    if (c->type == 10) {
#line 463
      return;
    }
  }
#line 464
  debug2("channel %d: close_read", c->self);
#line 465
  if (c->sock != -1) {
#line 471
    tmp___1 = shutdown(c->sock, 0);
#line 471
    if (tmp___1 < 0) {
#line 471
      tmp___2 = __errno_location();
#line 471
      if (*tmp___2 != 107) {
#line 473
        tmp = __errno_location();
#line 473
        tmp___0 = strerror(*tmp);
#line 473
        error("channel %d: chan_shutdown_read: shutdown() failed for fd%d [i%d o%d]: %.100s",
              c->self, c->sock, c->istate, c->ostate, tmp___0);
      }
    }
  } else {
#line 478
    tmp___5 = channel_close_fd(& c->rfd);
#line 478
    if (tmp___5 < 0) {
#line 479
      tmp___3 = __errno_location();
#line 479
      tmp___4 = strerror(*tmp___3);
#line 479
      logit("channel %d: chan_shutdown_read: close() failed for fd%d: %.100s", c->self,
            c->rfd, tmp___4);
    }
  }
#line 483
  return;
}
}
#line 1 "packet.o"
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 21 "packet.h"
void packet_set_connection(int fd_in , int fd_out ) ;
#line 22
void packet_set_nonblocking(void) ;
#line 24
int packet_get_connection_out(void) ;
#line 25
void packet_close(void) ;
#line 26
void packet_set_encryption_key(u_char const   *key , u_int keylen , int number ) ;
#line 27
u_int packet_get_encryption_key(u_char *key ) ;
#line 28
void packet_set_protocol_flags(u_int protocol_flags ) ;
#line 30
void packet_start_compression(int level ) ;
#line 31
void packet_set_interactive(int interactive ) ;
#line 33
void packet_set_server(void) ;
#line 34
void packet_set_authenticated(void) ;
#line 39
void packet_put_bignum(BIGNUM *value ) ;
#line 40
void packet_put_bignum2(BIGNUM *value ) ;
#line 43
void packet_put_raw(void const   *buf___1 , u_int len ) ;
#line 47
void packet_read_expect(int expected_type ) ;
#line 48
int packet_read_poll(void) ;
#line 49
void packet_process_incoming(char const   *buf___1 , u_int len ) ;
#line 50
int packet_read_seqnr(u_int32_t *seqnr_p ) ;
#line 51
int packet_read_poll_seqnr(u_int32_t *seqnr_p ) ;
#line 53
u_int packet_get_char(void) ;
#line 55
void packet_get_bignum(BIGNUM *value ) ;
#line 56
void packet_get_bignum2(BIGNUM *value ) ;
#line 57
void *packet_get_raw(u_int *length_ptr ) ;
#line 60
void ( /* format attribute */  packet_send_debug)(char const   *fmt  , ...) ;
#line 62
void set_newkeys(int mode ) ;
#line 63
int packet_get_keyiv_len(int mode ) ;
#line 64
void packet_get_keyiv(int mode , u_char *iv , u_int len ) ;
#line 65
int packet_get_keycontext(int mode , u_char *dat ) ;
#line 66
void packet_set_keycontext(int mode , u_char *dat ) ;
#line 67
void packet_get_state(int mode , u_int32_t *seqnr , u_int64_t *blocks , u_int32_t *packets ) ;
#line 68
void packet_set_state(int mode , u_int32_t seqnr , u_int64_t blocks , u_int32_t packets ) ;
#line 69
int packet_get_ssh1_cipher(void) ;
#line 70
void packet_set_iv(int mode , u_char *dat ) ;
#line 72
void packet_write_poll(void) ;
#line 74
int packet_have_data_to_write(void) ;
#line 75
int packet_not_very_much_data_to_write(void) ;
#line 78
int packet_connection_is_ipv4(void) ;
#line 81
void packet_add_padding(u_char pad ) ;
#line 87
int packet_set_maxsize(u_int s ) ;
#line 101
int packet_need_rekeying(void) ;
#line 102
void packet_set_rekey_limit(u_int32_t bytes ) ;
#line 133 "kex.h"
Newkeys *kex_get_newkeys(int mode ) ;
#line 28 "mac.h"
u_char *mac_compute(Mac *mac , u_int32_t seqno , u_char *data , int datalen ) ;
#line 79 "packet.c"
static int connection_in  =    -1;
#line 80 "packet.c"
static int connection_out  =    -1;
#line 83 "packet.c"
static u_int remote_protocol_flags  =    (u_int )0;
#line 86 "packet.c"
static CipherContext receive_context  ;
#line 89 "packet.c"
static CipherContext send_context  ;
#line 92 "packet.c"
Buffer input  ;
#line 95 "packet.c"
Buffer output  ;
#line 98 "packet.c"
static Buffer outgoing_packet  ;
#line 101 "packet.c"
static Buffer incoming_packet  ;
#line 104 "packet.c"
static Buffer compression_buffer  ;
#line 105 "packet.c"
static int compression_buffer_ready  =    0;
#line 108 "packet.c"
static int packet_compression  =    0;
#line 111 "packet.c"
u_int max_packet_size  =    (u_int )32768;
#line 114 "packet.c"
static int initialized  =    0;
#line 117 "packet.c"
static int interactive_mode  =    0;
#line 120 "packet.c"
static int server_side  =    0;
#line 123 "packet.c"
static int after_authentication  =    0;
#line 126 "packet.c"
Newkeys *newkeys[2]  ;
#line 127 "packet.c"
static struct packet_state p_read  ;
#line 127 "packet.c"
static struct packet_state p_send  ;
#line 133 "packet.c"
static u_int64_t max_blocks_in  ;
#line 133 "packet.c"
static u_int64_t max_blocks_out  ;
#line 134 "packet.c"
static u_int32_t rekey_limit  ;
#line 137 "packet.c"
static u_char ssh1_key[32]  ;
#line 138 "packet.c"
static u_int ssh1_keylen  ;
#line 141 "packet.c"
static u_char extra_pad  =    (u_char )0;
#line 148 "packet.c"
struct __anonstruct_outgoing_82 outgoing  ;
#line 154 "packet.c"
void packet_set_connection(int fd_in , int fd_out ) 
{ Cipher *none ;
  Cipher *tmp ;

  {
#line 157
  tmp = cipher_by_name("none");
#line 157
  none = tmp;
#line 159
  if ((unsigned int )none == (unsigned int )((void *)0)) {
#line 160
    fatal("packet_set_connection: cannot load cipher \'none\'");
  }
#line 161
  connection_in = fd_in;
#line 162
  connection_out = fd_out;
#line 163
  cipher_init(& send_context, none, (u_char const   *)"", 0U, (u_char const   *)((void *)0),
              0U, 1);
#line 165
  cipher_init(& receive_context, none, (u_char const   *)"", 0U, (u_char const   *)((void *)0),
              0U, 0);
#line 167
  newkeys[1] = (Newkeys *)((void *)0);
#line 167
  newkeys[0] = newkeys[1];
#line 168
  if (! initialized) {
#line 169
    initialized = 1;
#line 170
    buffer_init(& input);
#line 171
    buffer_init(& output);
#line 172
    buffer_init(& outgoing_packet);
#line 173
    buffer_init(& incoming_packet);
#line 174
    while (1) {
#line 174
      outgoing.tqh_first = (struct packet *)((void *)0);
#line 174
      outgoing.tqh_last = & outgoing.tqh_first;
#line 174
      break;
    }
  }
#line 176
  return;
}
}
#line 180 "packet.c"
int packet_connection_is_on_socket(void) 
{ struct sockaddr_storage from ;
  struct sockaddr_storage to ;
  socklen_t fromlen ;
  socklen_t tolen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 187
  if (connection_in == connection_out) {
#line 188
    return (1);
  }
#line 189
  fromlen = sizeof(from);
#line 190
  memset((void *)(& from), 0, sizeof(from));
#line 191
  tmp = getpeername(connection_in, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                    (socklen_t * __restrict  )(& fromlen));
#line 191
  if (tmp < 0) {
#line 192
    return (0);
  }
#line 193
  tolen = sizeof(to);
#line 194
  memset((void *)(& to), 0, sizeof(to));
#line 195
  tmp___0 = getpeername(connection_out, (struct sockaddr * __restrict  )((struct sockaddr *)(& to)),
                        (socklen_t * __restrict  )(& tolen));
#line 195
  if (tmp___0 < 0) {
#line 196
    return (0);
  }
#line 197
  if (fromlen != tolen) {
#line 198
    return (0);
  } else {
#line 197
    tmp___1 = memcmp((void const   *)(& from), (void const   *)(& to), fromlen);
#line 197
    if (tmp___1 != 0) {
#line 198
      return (0);
    }
  }
#line 199
  if ((int )from.ss_family != 2) {
#line 199
    if ((int )from.ss_family != 10) {
#line 200
      return (0);
    }
  }
#line 201
  return (1);
}
}
#line 210 "packet.c"
void packet_get_keyiv(int mode , u_char *iv , u_int len ) 
{ CipherContext *cc ;

  {
#line 215
  if (mode == 1) {
#line 216
    cc = & send_context;
  } else {
#line 218
    cc = & receive_context;
  }
#line 220
  cipher_get_keyiv(cc, iv, len);
#line 221
  return;
}
}
#line 223 "packet.c"
int packet_get_keycontext(int mode , u_char *dat ) 
{ CipherContext *cc ;
  int tmp ;

  {
#line 228
  if (mode == 1) {
#line 229
    cc = & send_context;
  } else {
#line 231
    cc = & receive_context;
  }
#line 233
  tmp = cipher_get_keycontext((CipherContext const   *)cc, dat);
#line 233
  return (tmp);
}
}
#line 236 "packet.c"
void packet_set_keycontext(int mode , u_char *dat ) 
{ CipherContext *cc ;

  {
#line 241
  if (mode == 1) {
#line 242
    cc = & send_context;
  } else {
#line 244
    cc = & receive_context;
  }
#line 246
  cipher_set_keycontext(cc, dat);
#line 247
  return;
}
}
#line 249 "packet.c"
int packet_get_keyiv_len(int mode ) 
{ CipherContext *cc ;
  int tmp ;

  {
#line 254
  if (mode == 1) {
#line 255
    cc = & send_context;
  } else {
#line 257
    cc = & receive_context;
  }
#line 259
  tmp = cipher_get_keyiv_len((CipherContext const   *)cc);
#line 259
  return (tmp);
}
}
#line 261 "packet.c"
void packet_set_iv(int mode , u_char *dat ) 
{ CipherContext *cc ;

  {
#line 266
  if (mode == 1) {
#line 267
    cc = & send_context;
  } else {
#line 269
    cc = & receive_context;
  }
#line 271
  cipher_set_keyiv(cc, dat);
#line 272
  return;
}
}
#line 273 "packet.c"
int packet_get_ssh1_cipher(void) 
{ u_int tmp ;

  {
#line 276
  tmp = cipher_get_number((Cipher const   *)receive_context.cipher);
#line 276
  return ((int )tmp);
}
}
#line 279 "packet.c"
void packet_get_state(int mode , u_int32_t *seqnr , u_int64_t *blocks , u_int32_t *packets ) 
{ struct packet_state *state ;

  {
#line 284
  if (mode == 0) {
#line 284
    state = & p_read;
  } else {
#line 284
    state = & p_send;
  }
#line 285
  *seqnr = state->seqnr;
#line 286
  *blocks = state->blocks;
#line 287
  *packets = state->packets;
#line 288
  return;
}
}
#line 290 "packet.c"
void packet_set_state(int mode , u_int32_t seqnr , u_int64_t blocks , u_int32_t packets ) 
{ struct packet_state *state ;

  {
#line 295
  if (mode == 0) {
#line 295
    state = & p_read;
  } else {
#line 295
    state = & p_send;
  }
#line 296
  state->seqnr = seqnr;
#line 297
  state->blocks = blocks;
#line 298
  state->packets = packets;
#line 299
  return;
}
}
#line 303 "packet.c"
int packet_connection_is_ipv4(void) 
{ struct sockaddr_storage to ;
  socklen_t tolen ;
  int tmp ;
  register unsigned int __v ;
  register unsigned int __x ;

  {
#line 307
  tolen = sizeof(to);
#line 309
  memset((void *)(& to), 0, sizeof(to));
#line 310
  tmp = getsockname(connection_out, (struct sockaddr * __restrict  )((struct sockaddr *)(& to)),
                    (socklen_t * __restrict  )(& tolen));
#line 310
  if (tmp < 0) {
#line 311
    return (0);
  }
#line 312
  if ((int )to.ss_family == 2) {
#line 313
    return (1);
  }
#line 316
  if ((int )to.ss_family == 10) {
#line 316
    if (*((uint32_t const   *)(& ((struct sockaddr_in6 *)(& to))->sin6_addr) + 0) == 0U) {
#line 316
      if (*((uint32_t const   *)(& ((struct sockaddr_in6 *)(& to))->sin6_addr) + 1) == 0U) {
#line 316
        __x = 65535U;
#line 316
        __asm__  ("rorw $8, %w0;"
                  "rorl $16, %0;"
                  "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 316
        if (*((uint32_t const   *)(& ((struct sockaddr_in6 *)(& to))->sin6_addr) + 2) == (uint32_t const   )__v) {
#line 317
          return (1);
        }
      }
    }
  }
#line 319
  return (0);
}
}
#line 324 "packet.c"
void packet_set_nonblocking(void) 
{ 

  {
#line 328
  set_nonblock(connection_in);
#line 330
  if (connection_out != connection_in) {
#line 331
    set_nonblock(connection_out);
  }
#line 332
  return;
}
}
#line 336 "packet.c"
int packet_get_connection_in(void) 
{ 

  {
#line 339
  return (connection_in);
}
}
#line 344 "packet.c"
int packet_get_connection_out(void) 
{ 

  {
#line 347
  return (connection_out);
}
}
#line 352 "packet.c"
void packet_close(void) 
{ 

  {
#line 355
  if (! initialized) {
#line 356
    return;
  }
#line 357
  initialized = 0;
#line 358
  if (connection_in == connection_out) {
#line 359
    shutdown(connection_out, 2);
#line 360
    close(connection_out);
  } else {
#line 362
    close(connection_in);
#line 363
    close(connection_out);
  }
#line 365
  buffer_free(& input);
#line 366
  buffer_free(& output);
#line 367
  buffer_free(& outgoing_packet);
#line 368
  buffer_free(& incoming_packet);
#line 369
  if (compression_buffer_ready) {
#line 370
    buffer_free(& compression_buffer);
#line 371
    buffer_compress_uninit();
  }
#line 373
  cipher_cleanup(& send_context);
#line 374
  cipher_cleanup(& receive_context);
#line 375
  return;
}
}
#line 379 "packet.c"
void packet_set_protocol_flags(u_int protocol_flags ) 
{ 

  {
#line 382
  remote_protocol_flags = protocol_flags;
#line 383
  return;
}
}
#line 387 "packet.c"
u_int packet_get_protocol_flags(void) 
{ 

  {
#line 390
  return (remote_protocol_flags);
}
}
#line 398 "packet.c"
static void packet_init_compression(void) 
{ 

  {
#line 401
  if (compression_buffer_ready == 1) {
#line 402
    return;
  }
#line 403
  compression_buffer_ready = 1;
#line 404
  buffer_init(& compression_buffer);
#line 405
  return;
}
}
#line 407 "packet.c"
void packet_start_compression(int level ) 
{ 

  {
#line 410
  if (packet_compression) {
#line 410
    if (! compat20) {
#line 411
      fatal("Compression already enabled.");
    }
  }
#line 412
  packet_compression = 1;
#line 413
  packet_init_compression();
#line 414
  buffer_compress_init_send(level);
#line 415
  buffer_compress_init_recv();
#line 416
  return;
}
}
#line 424 "packet.c"
void packet_set_encryption_key(u_char const   *key , u_int keylen , int number ) 
{ Cipher *cipher ;
  Cipher *tmp ;

  {
#line 428
  tmp = cipher_by_number(number);
#line 428
  cipher = tmp;
#line 430
  if ((unsigned int )cipher == (unsigned int )((void *)0)) {
#line 431
    fatal("packet_set_encryption_key: unknown cipher number %d", number);
  }
#line 432
  if (keylen < 20U) {
#line 433
    fatal("packet_set_encryption_key: keylen too small: %d", keylen);
  }
#line 434
  if (keylen > 32U) {
#line 435
    fatal("packet_set_encryption_key: keylen too big: %d", keylen);
  }
#line 436
  memcpy((void * __restrict  )(ssh1_key), (void const   * __restrict  )key, keylen);
#line 437
  ssh1_keylen = keylen;
#line 438
  cipher_init(& send_context, cipher, key, keylen, (u_char const   *)((void *)0),
              0U, 1);
#line 439
  cipher_init(& receive_context, cipher, key, keylen, (u_char const   *)((void *)0),
              0U, 0);
#line 440
  return;
}
}
#line 442 "packet.c"
u_int packet_get_encryption_key(u_char *key ) 
{ 

  {
#line 445
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 446
    return (ssh1_keylen);
  }
#line 447
  memcpy((void * __restrict  )key, (void const   * __restrict  )(ssh1_key), ssh1_keylen);
#line 448
  return (ssh1_keylen);
}
}
#line 452 "packet.c"
void packet_start(u_char type ) 
{ u_char buf___1[9] ;
  int len ;

  {
#line 459
  if (compat20) {
#line 459
    len = 6;
  } else {
#line 459
    len = 9;
  }
#line 460
  memset((void *)(buf___1), 0, (unsigned int )(len - 1));
#line 461
  buf___1[len - 1] = type;
#line 462
  buffer_clear(& outgoing_packet);
#line 463
  buffer_append(& outgoing_packet, (void const   *)(buf___1), (unsigned int )len);
#line 464
  return;
}
}
#line 467 "packet.c"
void packet_put_char(int value ) 
{ char ch ;

  {
#line 470
  ch = (char )value;
#line 472
  buffer_append(& outgoing_packet, (void const   *)(& ch), 1U);
#line 473
  return;
}
}
#line 474 "packet.c"
void packet_put_int(u_int value ) 
{ 

  {
#line 477
  buffer_put_int(& outgoing_packet, value);
#line 478
  return;
}
}
#line 479 "packet.c"
void packet_put_string(void const   *buf___1 , u_int len ) 
{ 

  {
#line 482
  buffer_put_string(& outgoing_packet, buf___1, len);
#line 483
  return;
}
}
#line 484 "packet.c"
void packet_put_cstring(char const   *str ) 
{ 

  {
#line 487
  buffer_put_cstring(& outgoing_packet, str);
#line 488
  return;
}
}
#line 489 "packet.c"
void packet_put_raw(void const   *buf___1 , u_int len ) 
{ 

  {
#line 492
  buffer_append(& outgoing_packet, buf___1, len);
#line 493
  return;
}
}
#line 494 "packet.c"
void packet_put_bignum(BIGNUM *value ) 
{ 

  {
#line 497
  buffer_put_bignum(& outgoing_packet, (BIGNUM const   *)value);
#line 498
  return;
}
}
#line 499 "packet.c"
void packet_put_bignum2(BIGNUM *value ) 
{ 

  {
#line 502
  buffer_put_bignum2(& outgoing_packet, (BIGNUM const   *)value);
#line 503
  return;
}
}
#line 510 "packet.c"
static void packet_send1(void) 
{ u_char buf___1[8] ;
  u_char *cp ;
  int i ;
  int padding ;
  int len ;
  u_int checksum ;
  u_int32_t rnd ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  u_int tmp___3 ;
  void *tmp___4 ;
  u_int tmp___5 ;
  void *tmp___6 ;
  u_int tmp___7 ;
  void *tmp___8 ;

  {
#line 516
  rnd = (u_int32_t )0;
#line 522
  if (packet_compression) {
#line 523
    buffer_clear(& compression_buffer);
#line 525
    buffer_consume(& outgoing_packet, 8U);
#line 527
    buffer_append(& compression_buffer, (void const   *)"\000\000\000\000\000\000\000\000",
                  8U);
#line 528
    buffer_compress(& outgoing_packet, & compression_buffer);
#line 529
    buffer_clear(& outgoing_packet);
#line 530
    tmp = buffer_len(& compression_buffer);
#line 530
    tmp___0 = buffer_ptr(& compression_buffer);
#line 530
    buffer_append(& outgoing_packet, (void const   *)tmp___0, tmp);
  }
#line 534
  tmp___1 = buffer_len(& outgoing_packet);
#line 534
  len = (int )((tmp___1 + 4U) - 8U);
#line 537
  padding = 8 - len % 8;
#line 538
  if (! send_context.plaintext) {
#line 539
    tmp___2 = buffer_ptr(& outgoing_packet);
#line 539
    cp = (u_char *)tmp___2;
#line 540
    i = 0;
#line 540
    while (i < padding) {
#line 541
      if (i % 4 == 0) {
#line 542
        rnd = arc4random();
      }
#line 543
      *(cp + (7 - i)) = (unsigned char )(rnd & 255U);
#line 544
      rnd >>= 8;
#line 540
      i ++;
    }
  }
#line 547
  buffer_consume(& outgoing_packet, (unsigned int )(8 - padding));
#line 550
  tmp___3 = buffer_len(& outgoing_packet);
#line 550
  tmp___4 = buffer_ptr(& outgoing_packet);
#line 550
  checksum = ssh_crc32((u_char const   *)tmp___4, tmp___3);
#line 552
  while (1) {
#line 552
    buf___1[0] = (unsigned char )(checksum >> 24);
#line 552
    buf___1[1] = (unsigned char )(checksum >> 16);
#line 552
    buf___1[2] = (unsigned char )(checksum >> 8);
#line 552
    buf___1[3] = (unsigned char )checksum;
#line 552
    break;
  }
#line 553
  buffer_append(& outgoing_packet, (void const   *)(buf___1), 4U);
#line 561
  while (1) {
#line 561
    buf___1[0] = (unsigned char )(len >> 24);
#line 561
    buf___1[1] = (unsigned char )(len >> 16);
#line 561
    buf___1[2] = (unsigned char )(len >> 8);
#line 561
    buf___1[3] = (unsigned char )len;
#line 561
    break;
  }
#line 562
  buffer_append(& output, (void const   *)(buf___1), 4U);
#line 563
  tmp___5 = buffer_len(& outgoing_packet);
#line 563
  tmp___6 = buffer_append_space(& output, tmp___5);
#line 563
  cp = (u_char *)tmp___6;
#line 564
  tmp___7 = buffer_len(& outgoing_packet);
#line 564
  tmp___8 = buffer_ptr(& outgoing_packet);
#line 564
  cipher_crypt(& send_context, cp, (u_char const   *)tmp___8, tmp___7);
#line 572
  buffer_clear(& outgoing_packet);
#line 579
  return;
}
}
#line 581 "packet.c"
void set_newkeys(int mode ) 
{ Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  CipherContext *cc ;
  u_int64_t *max_blocks ;
  int crypt_type ;

  {
#line 591
  debug2("set_newkeys: mode %d", mode);
#line 593
  if (mode == 1) {
#line 594
    cc = & send_context;
#line 595
    crypt_type = 1;
#line 596
    p_send.blocks = 0ULL;
#line 596
    p_send.packets = (unsigned int )p_send.blocks;
#line 597
    max_blocks = & max_blocks_out;
  } else {
#line 599
    cc = & receive_context;
#line 600
    crypt_type = 0;
#line 601
    p_read.blocks = 0ULL;
#line 601
    p_read.packets = (unsigned int )p_read.blocks;
#line 602
    max_blocks = & max_blocks_in;
  }
#line 604
  if ((unsigned int )newkeys[mode] != (unsigned int )((void *)0)) {
#line 605
    debug("set_newkeys: rekeying");
#line 606
    cipher_cleanup(cc);
#line 607
    enc = & (newkeys[mode])->enc;
#line 608
    mac = & (newkeys[mode])->mac;
#line 609
    comp = & (newkeys[mode])->comp;
#line 610
    memset((void *)mac->key, 0, mac->key_len);
#line 611
    xfree((void *)enc->name);
#line 612
    xfree((void *)enc->iv);
#line 613
    xfree((void *)enc->key);
#line 614
    xfree((void *)mac->name);
#line 615
    xfree((void *)mac->key);
#line 616
    xfree((void *)comp->name);
#line 617
    xfree((void *)newkeys[mode]);
  }
#line 619
  newkeys[mode] = kex_get_newkeys(mode);
#line 620
  if ((unsigned int )newkeys[mode] == (unsigned int )((void *)0)) {
#line 621
    fatal("newkeys: no keys for mode %d", mode);
  }
#line 622
  enc = & (newkeys[mode])->enc;
#line 623
  mac = & (newkeys[mode])->mac;
#line 624
  comp = & (newkeys[mode])->comp;
#line 625
  if ((unsigned int )mac->md != (unsigned int )((void *)0)) {
#line 626
    mac->enabled = 1;
  }
#line 628
  cipher_init(cc, enc->cipher, (u_char const   *)enc->key, enc->key_len, (u_char const   *)enc->iv,
              enc->block_size, crypt_type);
#line 633
  if (comp->type == 1) {
    goto _L;
  } else {
#line 633
    if (comp->type == 2) {
#line 633
      if (after_authentication) {
        _L: /* CIL Label */ 
#line 633
        if (comp->enabled == 0) {
#line 636
          packet_init_compression();
#line 637
          if (mode == 1) {
#line 638
            buffer_compress_init_send(6);
          } else {
#line 640
            buffer_compress_init_recv();
          }
#line 641
          comp->enabled = 1;
        }
      }
    }
  }
#line 647
  if (enc->block_size >= 16U) {
#line 648
    *max_blocks = 1ULL << enc->block_size * 2U;
  } else {
#line 650
    *max_blocks = (1ULL << 30) / (unsigned long long )enc->block_size;
  }
#line 651
  if (rekey_limit) {
#line 652
    if (*max_blocks < (u_int64_t )(rekey_limit / enc->block_size)) {
#line 652
      *max_blocks = *max_blocks;
    } else {
#line 652
      *max_blocks = (unsigned long long )(rekey_limit / enc->block_size);
    }
  }
#line 653
  return;
}
}
#line 660 "packet.c"
static void packet_enable_delayed_compress(void) 
{ Comp *comp ;
  int mode ;

  {
#line 663
  comp = (Comp *)((void *)0);
#line 670
  after_authentication = 1;
#line 671
  mode = 0;
#line 671
  while (mode < 2) {
#line 672
    comp = & (newkeys[mode])->comp;
#line 673
    if (comp) {
#line 673
      if (! comp->enabled) {
#line 673
        if (comp->type == 2) {
#line 674
          packet_init_compression();
#line 675
          if (mode == 1) {
#line 676
            buffer_compress_init_send(6);
          } else {
#line 678
            buffer_compress_init_recv();
          }
#line 679
          comp->enabled = 1;
        }
      }
    }
#line 671
    mode ++;
  }
#line 682
  return;
}
}
#line 687 "packet.c"
static void packet_send2_wrapped(void) 
{ u_char type ;
  u_char *cp ;
  u_char *macbuf ;
  u_char padlen ;
  u_char pad ;
  u_int packet_length___0 ;
  u_int i ;
  u_int len ;
  u_int32_t rnd ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  int block_size ;
  void *tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  u_int tmp___3 ;
  void *tmp___4 ;
  u_int tmp___5 ;
  void *tmp___6 ;
  u_int tmp___7 ;
  void *tmp___8 ;
  u_int tmp___9 ;
  void *tmp___10 ;

  {
#line 690
  macbuf = (u_char *)((void *)0);
#line 692
  packet_length___0 = (u_int )0;
#line 694
  rnd = (u_int32_t )0;
#line 695
  enc = (Enc *)((void *)0);
#line 696
  mac = (Mac *)((void *)0);
#line 697
  comp = (Comp *)((void *)0);
#line 700
  if ((unsigned int )newkeys[1] != (unsigned int )((void *)0)) {
#line 701
    enc = & (newkeys[1])->enc;
#line 702
    mac = & (newkeys[1])->mac;
#line 703
    comp = & (newkeys[1])->comp;
  }
#line 705
  if (enc) {
#line 705
    block_size = (int )enc->block_size;
  } else {
#line 705
    block_size = 8;
  }
#line 707
  tmp = buffer_ptr(& outgoing_packet);
#line 707
  cp = (u_char *)tmp;
#line 708
  type = *(cp + 5);
#line 715
  if (comp) {
#line 715
    if (comp->enabled) {
#line 716
      len = buffer_len(& outgoing_packet);
#line 718
      buffer_consume(& outgoing_packet, 5U);
#line 719
      buffer_clear(& compression_buffer);
#line 720
      buffer_compress(& outgoing_packet, & compression_buffer);
#line 721
      buffer_clear(& outgoing_packet);
#line 722
      buffer_append(& outgoing_packet, (void const   *)"\000\000\000\000\000", 5U);
#line 723
      tmp___0 = buffer_len(& compression_buffer);
#line 723
      tmp___1 = buffer_ptr(& compression_buffer);
#line 723
      buffer_append(& outgoing_packet, (void const   *)tmp___1, tmp___0);
    }
  }
#line 730
  len = buffer_len(& outgoing_packet);
#line 736
  padlen = (unsigned char )((unsigned int )block_size - len % (unsigned int )block_size);
#line 737
  if ((int )padlen < 4) {
#line 738
    padlen = (unsigned char )((int )padlen + block_size);
  }
#line 739
  if (extra_pad) {
#line 741
    extra_pad = (unsigned char )((((int )extra_pad + (block_size - 1)) / block_size) * block_size);
#line 742
    pad = (unsigned char )((unsigned int )extra_pad - (len + (u_int )padlen) % (unsigned int )extra_pad);
#line 743
    debug3("packet_send2: adding %d (len %d padlen %d extra_pad %d)", pad, len, padlen,
           extra_pad);
#line 745
    padlen = (unsigned char )((int )padlen + (int )pad);
#line 746
    extra_pad = (unsigned char)0;
  }
#line 748
  tmp___2 = buffer_append_space(& outgoing_packet, (unsigned int )padlen);
#line 748
  cp = (u_char *)tmp___2;
#line 749
  if (enc) {
#line 749
    if (! send_context.plaintext) {
#line 751
      i = 0U;
#line 751
      while (i < (u_int )padlen) {
#line 752
        if (i % 4U == 0U) {
#line 753
          rnd = arc4random();
        }
#line 754
        *(cp + i) = (unsigned char )(rnd & 255U);
#line 755
        rnd >>= 8;
#line 751
        i ++;
      }
    } else {
#line 759
      memset((void *)cp, 0, (unsigned int )padlen);
    }
  } else {
#line 759
    memset((void *)cp, 0, (unsigned int )padlen);
  }
#line 762
  tmp___3 = buffer_len(& outgoing_packet);
#line 762
  packet_length___0 = tmp___3 - 4U;
#line 763
  tmp___4 = buffer_ptr(& outgoing_packet);
#line 763
  cp = (u_char *)tmp___4;
#line 764
  while (1) {
#line 764
    *(cp + 0) = (unsigned char )(packet_length___0 >> 24);
#line 764
    *(cp + 1) = (unsigned char )(packet_length___0 >> 16);
#line 764
    *(cp + 2) = (unsigned char )(packet_length___0 >> 8);
#line 764
    *(cp + 3) = (unsigned char )packet_length___0;
#line 764
    break;
  }
#line 765
  *(cp + 4) = padlen;
#line 769
  if (mac) {
#line 769
    if (mac->enabled) {
#line 770
      tmp___5 = buffer_len(& outgoing_packet);
#line 770
      tmp___6 = buffer_ptr(& outgoing_packet);
#line 770
      macbuf = mac_compute(mac, p_send.seqnr, (u_char *)tmp___6, (int )tmp___5);
    }
  }
#line 776
  tmp___7 = buffer_len(& outgoing_packet);
#line 776
  tmp___8 = buffer_append_space(& output, tmp___7);
#line 776
  cp = (u_char *)tmp___8;
#line 777
  tmp___9 = buffer_len(& outgoing_packet);
#line 777
  tmp___10 = buffer_ptr(& outgoing_packet);
#line 777
  cipher_crypt(& send_context, cp, (u_char const   *)tmp___10, tmp___9);
#line 780
  if (mac) {
#line 780
    if (mac->enabled) {
#line 781
      buffer_append(& output, (void const   *)((char *)macbuf), mac->mac_len);
    }
  }
#line 787
  (p_send.seqnr) ++;
#line 787
  if (p_send.seqnr == 0U) {
#line 788
    logit("outgoing seqnr wraps around");
  }
#line 789
  (p_send.packets) ++;
#line 789
  if (p_send.packets == 0U) {
#line 790
    if (! (datafellows & 32768)) {
#line 791
      fatal("XXX too many packets with same key");
    }
  }
#line 792
  p_send.blocks += (u_int64_t )((packet_length___0 + 4U) / (u_int )block_size);
#line 793
  buffer_clear(& outgoing_packet);
#line 795
  if ((int )type == 21) {
#line 796
    set_newkeys(1);
  } else {
#line 797
    if ((int )type == 52) {
#line 797
      if (server_side) {
#line 798
        packet_enable_delayed_compress();
      }
    }
  }
#line 799
  return;
}
}
#line 804
static void packet_send2(void) ;
#line 804 "packet.c"
static int rekeying  =    0;
#line 801 "packet.c"
static void packet_send2(void) 
{ struct packet *p ;
  u_char type ;
  u_char *cp ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 808
  tmp = buffer_ptr(& outgoing_packet);
#line 808
  cp = (u_char *)tmp;
#line 809
  type = *(cp + 5);
#line 812
  if (rekeying) {
#line 813
    if ((int )type >= 1) {
#line 813
      if (! ((int )type <= 49)) {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 815
      debug("enqueue packet: %u", type);
#line 816
      tmp___0 = xmalloc(sizeof(*p));
#line 816
      p = (struct packet *)tmp___0;
#line 817
      p->type = type;
#line 818
      memcpy((void * __restrict  )(& p->payload), (void const   * __restrict  )(& outgoing_packet),
             sizeof(Buffer ));
#line 819
      buffer_init(& outgoing_packet);
#line 820
      while (1) {
#line 820
        p->next.tqe_next = (struct packet *)((void *)0);
#line 820
        p->next.tqe_prev = outgoing.tqh_last;
#line 820
        *(outgoing.tqh_last) = p;
#line 820
        outgoing.tqh_last = & p->next.tqe_next;
#line 820
        break;
      }
#line 821
      return;
    }
  }
#line 826
  if ((int )type == 20) {
#line 827
    rekeying = 1;
  }
#line 829
  packet_send2_wrapped();
#line 832
  if ((int )type == 21) {
#line 833
    rekeying = 0;
#line 834
    while (1) {
#line 834
      p = outgoing.tqh_first;
#line 834
      if (! p) {
#line 834
        break;
      }
#line 835
      type = p->type;
#line 836
      debug("dequeue packet: %u", type);
#line 837
      buffer_free(& outgoing_packet);
#line 838
      memcpy((void * __restrict  )(& outgoing_packet), (void const   * __restrict  )(& p->payload),
             sizeof(Buffer ));
#line 840
      while (1) {
#line 840
        if ((unsigned int )p->next.tqe_next != (unsigned int )((void *)0)) {
#line 840
          (p->next.tqe_next)->next.tqe_prev = p->next.tqe_prev;
        } else {
#line 840
          outgoing.tqh_last = p->next.tqe_prev;
        }
#line 840
        *(p->next.tqe_prev) = p->next.tqe_next;
#line 840
        break;
      }
#line 841
      xfree((void *)p);
#line 842
      packet_send2_wrapped();
    }
  }
#line 845
  return;
}
}
#line 847 "packet.c"
void packet_send(void) 
{ 

  {
#line 850
  if (compat20) {
#line 851
    packet_send2();
  } else {
#line 853
    packet_send1();
  }
#line 855
  return;
}
}
#line 863 "packet.c"
int packet_read_seqnr(u_int32_t *seqnr_p ) 
{ int type ;
  int len ;
  fd_set *setp ;
  char buf___1[8192] ;
  void *tmp ;
  int _len ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char const   *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
#line 871
  tmp = xmalloc((((unsigned int )(connection_in + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 871
  setp = (fd_set *)tmp;
#line 875
  packet_write_wait();
#line 878
  while (1) {
#line 880
    type = packet_read_poll_seqnr(seqnr_p);
#line 881
    if (! compat20) {
#line 881
      if (type == 14) {
        goto _L;
      } else {
#line 881
        if (type == 15) {
          goto _L;
        } else {
#line 881
          if (type == 19) {
            goto _L;
          } else {
#line 881
            if (type == 33) {
              _L: /* CIL Label */ 
#line 886
              while (1) {
#line 886
                tmp___0 = packet_remaining();
#line 886
                _len = tmp___0;
#line 886
                if (_len > 0) {
#line 886
                  logit("Packet integrity error (%d bytes remaining) at %s:%d", _len,
                        "packet.c", 886);
#line 886
                  packet_disconnect("Packet integrity error.");
                }
#line 886
                break;
              }
            }
          }
        }
      }
    }
#line 888
    if (type != 0) {
#line 889
      xfree((void *)setp);
#line 890
      return (type);
    }
#line 896
    memset((void *)setp, 0, (((unsigned int )(connection_in + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 898
    __asm__  volatile   ("btsl %1,%0": "=m" (setp->fds_bits[(unsigned int )connection_in / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 901
    while (1) {
#line 901
      tmp___1 = select(connection_in + 1, (fd_set * __restrict  )setp, (fd_set * __restrict  )((void *)0),
                       (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 901
      if (tmp___1 == -1) {
#line 901
        tmp___2 = __errno_location();
#line 901
        if (! (*tmp___2 == 11)) {
#line 901
          tmp___3 = __errno_location();
#line 901
          if (! (*tmp___3 == 4)) {
#line 901
            break;
          }
        }
      } else {
#line 901
        break;
      }
    }
#line 906
    len = read(connection_in, (void *)(buf___1), sizeof(buf___1));
#line 907
    if (len == 0) {
#line 908
      tmp___4 = get_remote_ipaddr();
#line 908
      logit("Connection closed by %.200s", tmp___4);
#line 909
      cleanup_exit(255);
    }
#line 911
    if (len < 0) {
#line 912
      tmp___5 = __errno_location();
#line 912
      tmp___6 = strerror(*tmp___5);
#line 912
      fatal("Read from socket failed: %.100s", tmp___6);
    }
#line 914
    packet_process_incoming((char const   *)(buf___1), (unsigned int )len);
  }
}
}
#line 919 "packet.c"
int packet_read(void) 
{ int tmp ;

  {
#line 922
  tmp = packet_read_seqnr((u_int32_t *)((void *)0));
#line 922
  return (tmp);
}
}
#line 930 "packet.c"
void packet_read_expect(int expected_type ) 
{ int type ;

  {
#line 935
  type = packet_read();
#line 936
  if (type != expected_type) {
#line 937
    packet_disconnect("Protocol error: expected packet type %d, got %d", expected_type,
                      type);
  }
#line 939
  return;
}
}
#line 950 "packet.c"
static int packet_read_poll1(void) 
{ u_int len ;
  u_int padded_len ;
  u_char *cp ;
  u_char type ;
  u_int checksum ;
  u_int stored_checksum ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  u_int tmp___6 ;
  void *tmp___7 ;
  u_int tmp___8 ;
  u_int tmp___9 ;
  void *tmp___10 ;
  u_int tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;

  {
#line 958
  tmp = buffer_len(& input);
#line 958
  if (tmp < 12U) {
#line 959
    return (0);
  }
#line 961
  tmp___0 = buffer_ptr(& input);
#line 961
  cp = (u_char *)tmp___0;
#line 962
  len = (unsigned int )(((((unsigned long )*(cp + 0) << 24) | ((unsigned long )*(cp + 1) << 16)) | ((unsigned long )*(cp + 2) << 8)) | (unsigned long )*(cp + 3));
#line 963
  if (len < 5U) {
#line 964
    packet_disconnect("Bad packet length %u.", len);
  } else {
#line 963
    if (len > 262144U) {
#line 964
      packet_disconnect("Bad packet length %u.", len);
    }
  }
#line 965
  padded_len = (len + 8U) & 4294967288U;
#line 968
  tmp___1 = buffer_len(& input);
#line 968
  if (tmp___1 < 4U + padded_len) {
#line 969
    return (0);
  }
#line 974
  buffer_consume(& input, 4U);
#line 981
  if (! receive_context.plaintext) {
#line 981
    tmp___2 = buffer_ptr(& input);
#line 981
    tmp___3 = detect_attack((u_char *)tmp___2, padded_len, (u_char *)((void *)0));
#line 981
    if (tmp___3 == 1) {
#line 983
      packet_disconnect("crc32 compensation attack: network attack detected");
    }
  }
#line 986
  buffer_clear(& incoming_packet);
#line 987
  tmp___4 = buffer_append_space(& incoming_packet, padded_len);
#line 987
  cp = (u_char *)tmp___4;
#line 988
  tmp___5 = buffer_ptr(& input);
#line 988
  cipher_crypt(& receive_context, cp, (u_char const   *)tmp___5, padded_len);
#line 990
  buffer_consume(& input, padded_len);
#line 998
  tmp___6 = buffer_len(& incoming_packet);
#line 998
  tmp___7 = buffer_ptr(& incoming_packet);
#line 998
  checksum = ssh_crc32((u_char const   *)tmp___7, tmp___6 - 4U);
#line 1002
  buffer_consume(& incoming_packet, 8U - len % 8U);
#line 1005
  tmp___9 = buffer_len(& incoming_packet);
#line 1005
  if (len != tmp___9) {
#line 1006
    tmp___8 = buffer_len(& incoming_packet);
#line 1006
    packet_disconnect("packet_read_poll1: len %d != buffer_len %d.", len, tmp___8);
  }
#line 1009
  tmp___10 = buffer_ptr(& incoming_packet);
#line 1009
  cp = ((u_char *)tmp___10 + len) - 4;
#line 1010
  stored_checksum = (unsigned int )(((((unsigned long )*(cp + 0) << 24) | ((unsigned long )*(cp + 1) << 16)) | ((unsigned long )*(cp + 2) << 8)) | (unsigned long )*(cp + 3));
#line 1011
  if (checksum != stored_checksum) {
#line 1012
    packet_disconnect("Corrupted check bytes on input.");
  }
#line 1013
  buffer_consume_end(& incoming_packet, 4U);
#line 1015
  if (packet_compression) {
#line 1016
    buffer_clear(& compression_buffer);
#line 1017
    buffer_uncompress(& incoming_packet, & compression_buffer);
#line 1018
    buffer_clear(& incoming_packet);
#line 1019
    tmp___11 = buffer_len(& compression_buffer);
#line 1019
    tmp___12 = buffer_ptr(& compression_buffer);
#line 1019
    buffer_append(& incoming_packet, (void const   *)tmp___12, tmp___11);
  }
#line 1022
  tmp___13 = buffer_get_char(& incoming_packet);
#line 1022
  type = (unsigned char )tmp___13;
#line 1023
  if ((int )type < 1) {
#line 1024
    packet_disconnect("Invalid ssh1 packet type: %d", type);
  } else {
#line 1023
    if ((int )type > 254) {
#line 1024
      packet_disconnect("Invalid ssh1 packet type: %d", type);
    }
  }
#line 1025
  return ((int )type);
}
}
#line 1031
static int packet_read_poll2(u_int32_t *seqnr_p ) ;
#line 1031 "packet.c"
static u_int packet_length  =    (u_int )0;
#line 1028 "packet.c"
static int packet_read_poll2(u_int32_t *seqnr_p ) 
{ u_int padlen ;
  u_int need ;
  u_char *macbuf ;
  u_char *cp ;
  u_char type ;
  u_int maclen ;
  u_int block_size ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  u_int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  u_int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;
  u_int tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;

  {
#line 1035
  enc = (Enc *)((void *)0);
#line 1036
  mac = (Mac *)((void *)0);
#line 1037
  comp = (Comp *)((void *)0);
#line 1039
  if ((unsigned int )newkeys[0] != (unsigned int )((void *)0)) {
#line 1040
    enc = & (newkeys[0])->enc;
#line 1041
    mac = & (newkeys[0])->mac;
#line 1042
    comp = & (newkeys[0])->comp;
  }
#line 1044
  if (mac) {
#line 1044
    if (mac->enabled) {
#line 1044
      maclen = mac->mac_len;
    } else {
#line 1044
      maclen = 0U;
    }
  } else {
#line 1044
    maclen = 0U;
  }
#line 1045
  if (enc) {
#line 1045
    block_size = enc->block_size;
  } else {
#line 1045
    block_size = 8U;
  }
#line 1047
  if (packet_length == 0U) {
#line 1052
    tmp = buffer_len(& input);
#line 1052
    if (tmp < block_size) {
#line 1053
      return (0);
    }
#line 1054
    buffer_clear(& incoming_packet);
#line 1055
    tmp___0 = buffer_append_space(& incoming_packet, block_size);
#line 1055
    cp = (u_char *)tmp___0;
#line 1056
    tmp___1 = buffer_ptr(& input);
#line 1056
    cipher_crypt(& receive_context, cp, (u_char const   *)tmp___1, block_size);
#line 1058
    tmp___2 = buffer_ptr(& incoming_packet);
#line 1058
    cp = (u_char *)tmp___2;
#line 1059
    packet_length = (unsigned int )(((((unsigned long )*(cp + 0) << 24) | ((unsigned long )*(cp + 1) << 16)) | ((unsigned long )*(cp + 2) << 8)) | (unsigned long )*(cp + 3));
#line 1060
    if (packet_length < 5U) {
#line 1064
      packet_disconnect("Bad packet length %u.", packet_length);
    } else {
#line 1060
      if (packet_length > 262144U) {
#line 1064
        packet_disconnect("Bad packet length %u.", packet_length);
      }
    }
#line 1067
    buffer_consume(& input, block_size);
  }
#line 1070
  need = (4U + packet_length) - block_size;
#line 1073
  if (need % block_size != 0U) {
#line 1074
    fatal("padding error: need %d block %d mod %d", need, block_size, need % block_size);
  }
#line 1080
  tmp___3 = buffer_len(& input);
#line 1080
  if (tmp___3 < need + maclen) {
#line 1081
    return (0);
  }
#line 1086
  tmp___4 = buffer_append_space(& incoming_packet, need);
#line 1086
  cp = (u_char *)tmp___4;
#line 1087
  tmp___5 = buffer_ptr(& input);
#line 1087
  cipher_crypt(& receive_context, cp, (u_char const   *)tmp___5, need);
#line 1088
  buffer_consume(& input, need);
#line 1093
  if (mac) {
#line 1093
    if (mac->enabled) {
#line 1094
      tmp___6 = buffer_len(& incoming_packet);
#line 1094
      tmp___7 = buffer_ptr(& incoming_packet);
#line 1094
      macbuf = mac_compute(mac, p_read.seqnr, (u_char *)tmp___7, (int )tmp___6);
#line 1097
      tmp___8 = buffer_ptr(& input);
#line 1097
      tmp___9 = memcmp((void const   *)macbuf, (void const   *)tmp___8, mac->mac_len);
#line 1097
      if (tmp___9 != 0) {
#line 1098
        packet_disconnect("Corrupted MAC on input.");
      }
#line 1100
      buffer_consume(& input, mac->mac_len);
    }
  }
#line 1102
  if ((unsigned int )seqnr_p != (unsigned int )((void *)0)) {
#line 1103
    *seqnr_p = p_read.seqnr;
  }
#line 1104
  (p_read.seqnr) ++;
#line 1104
  if (p_read.seqnr == 0U) {
#line 1105
    logit("incoming seqnr wraps around");
  }
#line 1106
  (p_read.packets) ++;
#line 1106
  if (p_read.packets == 0U) {
#line 1107
    if (! (datafellows & 32768)) {
#line 1108
      fatal("XXX too many packets with same key");
    }
  }
#line 1109
  p_read.blocks += (u_int64_t )((packet_length + 4U) / block_size);
#line 1112
  tmp___10 = buffer_ptr(& incoming_packet);
#line 1112
  cp = (u_char *)tmp___10;
#line 1113
  padlen = (unsigned int )*(cp + 4);
#line 1115
  if (padlen < 4U) {
#line 1116
    packet_disconnect("Corrupted padlen %d on input.", padlen);
  }
#line 1119
  buffer_consume(& incoming_packet, 5U);
#line 1120
  buffer_consume_end(& incoming_packet, padlen);
#line 1123
  if (comp) {
#line 1123
    if (comp->enabled) {
#line 1124
      buffer_clear(& compression_buffer);
#line 1125
      buffer_uncompress(& incoming_packet, & compression_buffer);
#line 1126
      buffer_clear(& incoming_packet);
#line 1127
      tmp___11 = buffer_len(& compression_buffer);
#line 1127
      tmp___12 = buffer_ptr(& compression_buffer);
#line 1127
      buffer_append(& incoming_packet, (void const   *)tmp___12, tmp___11);
    }
  }
#line 1136
  tmp___13 = buffer_get_char(& incoming_packet);
#line 1136
  type = (unsigned char )tmp___13;
#line 1137
  if ((int )type < 1) {
#line 1138
    packet_disconnect("Invalid ssh2 packet type: %d", type);
  } else {
#line 1137
    if ((int )type >= 192) {
#line 1138
      packet_disconnect("Invalid ssh2 packet type: %d", type);
    }
  }
#line 1139
  if ((int )type == 21) {
#line 1140
    set_newkeys(0);
  } else {
#line 1141
    if ((int )type == 52) {
#line 1141
      if (! server_side) {
#line 1142
        packet_enable_delayed_compress();
      }
    }
  }
#line 1148
  packet_length = 0U;
#line 1149
  return ((int )type);
}
}
#line 1152 "packet.c"
int packet_read_poll_seqnr(u_int32_t *seqnr_p ) 
{ u_int reason ;
  u_int seqnr ;
  u_char type ;
  char *msg ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  char const   *tmp___7 ;

  {
#line 1159
  while (1) {
#line 1160
    if (compat20) {
#line 1161
      tmp = packet_read_poll2(seqnr_p);
#line 1161
      type = (unsigned char )tmp;
#line 1162
      if (type) {

      }
#line 1164
      switch ((int )type) {
      case 2: 
#line 1166
      break;
      case 4: 
#line 1168
      packet_get_char();
#line 1169
      tmp___0 = packet_get_string((u_int *)((void *)0));
#line 1169
      msg = (char *)tmp___0;
#line 1170
      debug("Remote: %.900s", msg);
#line 1171
      xfree((void *)msg);
#line 1172
      tmp___1 = packet_get_string((u_int *)((void *)0));
#line 1172
      msg = (char *)tmp___1;
#line 1173
      xfree((void *)msg);
#line 1174
      break;
      case 1: 
#line 1176
      reason = packet_get_int();
#line 1177
      tmp___2 = packet_get_string((u_int *)((void *)0));
#line 1177
      msg = (char *)tmp___2;
#line 1178
      tmp___3 = get_remote_ipaddr();
#line 1178
      logit("Received disconnect from %s: %u: %.400s", tmp___3, reason, msg);
#line 1180
      xfree((void *)msg);
#line 1181
      cleanup_exit(255);
#line 1182
      break;
      case 3: 
#line 1184
      seqnr = packet_get_int();
#line 1185
      debug("Received SSH2_MSG_UNIMPLEMENTED for %u", seqnr);
#line 1187
      break;
      default: ;
#line 1189
      return ((int )type);
#line 1190
      break;
      }
    } else {
#line 1193
      tmp___4 = packet_read_poll1();
#line 1193
      type = (unsigned char )tmp___4;
#line 1194
      switch ((int )type) {
      case 32: 
#line 1196
      break;
      case 36: 
#line 1198
      tmp___5 = packet_get_string((u_int *)((void *)0));
#line 1198
      msg = (char *)tmp___5;
#line 1199
      debug("Remote: %.900s", msg);
#line 1200
      xfree((void *)msg);
#line 1201
      break;
      case 1: 
#line 1203
      tmp___6 = packet_get_string((u_int *)((void *)0));
#line 1203
      msg = (char *)tmp___6;
#line 1204
      tmp___7 = get_remote_ipaddr();
#line 1204
      logit("Received disconnect from %s: %.400s", tmp___7, msg);
#line 1206
      cleanup_exit(255);
#line 1207
      xfree((void *)msg);
#line 1208
      break;
      default: ;
#line 1210
      if (type) {

      }
#line 1212
      return ((int )type);
#line 1213
      break;
      }
    }
  }
}
}
#line 1219 "packet.c"
int packet_read_poll(void) 
{ int tmp ;

  {
#line 1222
  tmp = packet_read_poll_seqnr((u_int32_t *)((void *)0));
#line 1222
  return (tmp);
}
}
#line 1230 "packet.c"
void packet_process_incoming(char const   *buf___1 , u_int len ) 
{ 

  {
#line 1233
  buffer_append(& input, (void const   *)buf___1, len);
#line 1234
  return;
}
}
#line 1238 "packet.c"
u_int packet_get_char(void) 
{ char ch ;

  {
#line 1243
  buffer_get(& incoming_packet, (void *)(& ch), 1U);
#line 1244
  return ((unsigned int )((unsigned char )ch));
}
}
#line 1249 "packet.c"
u_int packet_get_int(void) 
{ u_int tmp ;

  {
#line 1252
  tmp = buffer_get_int(& incoming_packet);
#line 1252
  return (tmp);
}
}
#line 1260 "packet.c"
void packet_get_bignum(BIGNUM *value ) 
{ 

  {
#line 1263
  buffer_get_bignum(& incoming_packet, value);
#line 1264
  return;
}
}
#line 1266 "packet.c"
void packet_get_bignum2(BIGNUM *value ) 
{ 

  {
#line 1269
  buffer_get_bignum2(& incoming_packet, value);
#line 1270
  return;
}
}
#line 1272 "packet.c"
void *packet_get_raw(u_int *length_ptr ) 
{ u_int bytes ;
  u_int tmp ;
  void *tmp___0 ;

  {
#line 1275
  tmp = buffer_len(& incoming_packet);
#line 1275
  bytes = tmp;
#line 1277
  if ((unsigned int )length_ptr != (unsigned int )((void *)0)) {
#line 1278
    *length_ptr = bytes;
  }
#line 1279
  tmp___0 = buffer_ptr(& incoming_packet);
#line 1279
  return (tmp___0);
}
}
#line 1282 "packet.c"
int packet_remaining(void) 
{ u_int tmp ;

  {
#line 1285
  tmp = buffer_len(& incoming_packet);
#line 1285
  return ((int )tmp);
}
}
#line 1295 "packet.c"
void *packet_get_string(u_int *length_ptr ) 
{ void *tmp ;

  {
#line 1298
  tmp = buffer_get_string(& incoming_packet, length_ptr);
#line 1298
  return (tmp);
}
}
#line 1310 "packet.c"
void ( /* format attribute */  packet_send_debug)(char const   *fmt  , ...) 
{ char buf___1[1024] ;
  va_list args ;

  {
#line 1316
  if (compat20) {
#line 1316
    if (datafellows & 64) {
#line 1317
      return;
    }
  }
#line 1319
  __builtin_va_start(args, fmt);
#line 1320
  vsnprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )fmt,
            args);
#line 1321
  __builtin_va_end(args);
#line 1323
  if (compat20) {
#line 1324
    packet_start((unsigned char)4);
#line 1325
    packet_put_char(0);
#line 1326
    packet_put_cstring((char const   *)(buf___1));
#line 1327
    packet_put_cstring("");
  } else {
#line 1329
    packet_start((unsigned char)36);
#line 1330
    packet_put_cstring((char const   *)(buf___1));
  }
#line 1332
  packet_send();
#line 1333
  packet_write_wait();
#line 1334
  return;
}
}
#line 1348 "packet.c"
static int disconnecting  =    0;
#line 1343 "packet.c"
void ( /* format attribute */  packet_disconnect)(char const   *fmt  , ...) 
{ char buf___1[1024] ;
  va_list args ;

  {
#line 1350
  if (disconnecting) {
#line 1351
    fatal("packet_disconnect called recursively.");
  }
#line 1352
  disconnecting = 1;
#line 1358
  __builtin_va_start(args, fmt);
#line 1359
  vsnprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )fmt,
            args);
#line 1360
  __builtin_va_end(args);
#line 1363
  logit("Disconnecting: %.100s", buf___1);
#line 1366
  if (compat20) {
#line 1367
    packet_start((unsigned char)1);
#line 1368
    packet_put_int(2U);
#line 1369
    packet_put_cstring((char const   *)(buf___1));
#line 1370
    packet_put_cstring("");
  } else {
#line 1372
    packet_start((unsigned char)1);
#line 1373
    packet_put_cstring((char const   *)(buf___1));
  }
#line 1375
  packet_send();
#line 1376
  packet_write_wait();
#line 1379
  channel_close_all();
#line 1382
  packet_close();
#line 1383
  cleanup_exit(255);
}
}
#line 1388 "packet.c"
void packet_write_poll(void) 
{ int len ;
  u_int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
#line 1391
  tmp = buffer_len(& output);
#line 1391
  len = (int )tmp;
#line 1393
  if (len > 0) {
#line 1394
    tmp___0 = buffer_ptr(& output);
#line 1394
    len = write(connection_out, (void const   *)tmp___0, (unsigned int )len);
#line 1395
    if (len <= 0) {
#line 1396
      tmp___3 = __errno_location();
#line 1396
      if (*tmp___3 == 11) {
#line 1397
        return;
      } else {
#line 1399
        tmp___1 = __errno_location();
#line 1399
        tmp___2 = strerror(*tmp___1);
#line 1399
        fatal("Write failed: %.100s", tmp___2);
      }
    }
#line 1401
    buffer_consume(& output, (unsigned int )len);
  }
#line 1403
  return;
}
}
#line 1410 "packet.c"
void packet_write_wait(void) 
{ fd_set *setp ;
  void *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
#line 1415
  tmp = xmalloc((((unsigned int )(connection_out + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 1415
  setp = (fd_set *)tmp;
#line 1417
  packet_write_poll();
#line 1418
  while (1) {
#line 1418
    tmp___3 = packet_have_data_to_write();
#line 1418
    if (! tmp___3) {
#line 1418
      break;
    }
#line 1419
    memset((void *)setp, 0, (((unsigned int )(connection_out + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 1421
    __asm__  volatile   ("btsl %1,%0": "=m" (setp->fds_bits[(unsigned int )connection_out / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 1422
    while (1) {
#line 1422
      tmp___0 = select(connection_out + 1, (fd_set * __restrict  )((void *)0), (fd_set * __restrict  )setp,
                       (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 1422
      if (tmp___0 == -1) {
#line 1422
        tmp___1 = __errno_location();
#line 1422
        if (! (*tmp___1 == 11)) {
#line 1422
          tmp___2 = __errno_location();
#line 1422
          if (! (*tmp___2 == 4)) {
#line 1422
            break;
          }
        }
      } else {
#line 1422
        break;
      }
    }
#line 1425
    packet_write_poll();
  }
#line 1427
  xfree((void *)setp);
#line 1428
  return;
}
}
#line 1432 "packet.c"
int packet_have_data_to_write(void) 
{ u_int tmp ;

  {
#line 1435
  tmp = buffer_len(& output);
#line 1435
  return (tmp != 0U);
}
}
#line 1440 "packet.c"
int packet_not_very_much_data_to_write(void) 
{ u_int tmp ;
  u_int tmp___0 ;

  {
#line 1443
  if (interactive_mode) {
#line 1444
    tmp = buffer_len(& output);
#line 1444
    return (tmp < 16384U);
  } else {
#line 1446
    tmp___0 = buffer_len(& output);
#line 1446
    return (tmp___0 < 131072U);
  }
}
}
#line 1450 "packet.c"
static void packet_set_tos(int interactive ) 
{ int tos ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 1454
  if (interactive) {
#line 1454
    tmp = 16;
  } else {
#line 1454
    tmp = 8;
  }
#line 1454
  tos = tmp;
#line 1456
  tmp___0 = packet_connection_is_on_socket();
#line 1456
  if (tmp___0) {
#line 1456
    tmp___1 = packet_connection_is_ipv4();
#line 1456
    if (! tmp___1) {
#line 1458
      return;
    }
  } else {
#line 1458
    return;
  }
#line 1459
  tmp___4 = setsockopt(connection_in, 0, 1, (void const   *)(& tos), sizeof(tos));
#line 1459
  if (tmp___4 < 0) {
#line 1461
    tmp___2 = __errno_location();
#line 1461
    tmp___3 = strerror(*tmp___2);
#line 1461
    error("setsockopt IP_TOS %d: %.100s:", tos, tmp___3);
  }
#line 1464
  return;
}
}
#line 1471 "packet.c"
static int called  =    0;
#line 1468 "packet.c"
void packet_set_interactive(int interactive ) 
{ int tmp ;

  {
#line 1473
  if (called) {
#line 1474
    return;
  }
#line 1475
  called = 1;
#line 1478
  interactive_mode = interactive;
#line 1481
  tmp = packet_connection_is_on_socket();
#line 1481
  if (! tmp) {
#line 1482
    return;
  }
#line 1483
  if (interactive) {
#line 1484
    set_nodelay(connection_in);
  }
#line 1485
  packet_set_tos(interactive);
#line 1486
  return;
}
}
#line 1490 "packet.c"
int packet_is_interactive(void) 
{ 

  {
#line 1493
  return (interactive_mode);
}
}
#line 1499 "packet.c"
static int called___0  =    0;
#line 1496 "packet.c"
int packet_set_maxsize(u_int s ) 
{ 

  {
#line 1501
  if (called___0) {
#line 1502
    logit("packet_set_maxsize: called twice: old %d new %d", max_packet_size, s);
#line 1504
    return (-1);
  }
#line 1506
  if (s < 4096U) {
#line 1507
    logit("packet_set_maxsize: bad size %d", s);
#line 1508
    return (-1);
  } else {
#line 1506
    if (s > 1048576U) {
#line 1507
      logit("packet_set_maxsize: bad size %d", s);
#line 1508
      return (-1);
    }
  }
#line 1510
  called___0 = 1;
#line 1511
  debug("packet_set_maxsize: setting to %d", s);
#line 1512
  max_packet_size = s;
#line 1513
  return ((int )s);
}
}
#line 1517 "packet.c"
void packet_add_padding(u_char pad ) 
{ 

  {
#line 1520
  extra_pad = pad;
#line 1521
  return;
}
}
#line 1534 "packet.c"
void packet_send_ignore(int nbytes ) 
{ u_int32_t rnd ;
  int i ;
  int tmp ;

  {
#line 1537
  rnd = (u_int32_t )0;
#line 1540
  if (compat20) {
#line 1540
    tmp = 2;
  } else {
#line 1540
    tmp = 32;
  }
#line 1540
  packet_start((unsigned char )tmp);
#line 1541
  packet_put_int((unsigned int )nbytes);
#line 1542
  i = 0;
#line 1542
  while (i < nbytes) {
#line 1543
    if (i % 4 == 0) {
#line 1544
      rnd = arc4random();
    }
#line 1545
    packet_put_char((int )(rnd & 255U));
#line 1546
    rnd >>= 8;
#line 1542
    i ++;
  }
#line 1548
  return;
}
}
#line 1551 "packet.c"
int packet_need_rekeying(void) 
{ int tmp ;

  {
#line 1554
  if (datafellows & 32768) {
#line 1555
    return (0);
  }
#line 1556
  if (p_send.packets > 1U << 31) {
#line 1556
    tmp = 1;
  } else {
#line 1556
    if (p_read.packets > 1U << 31) {
#line 1556
      tmp = 1;
    } else {
#line 1556
      if (max_blocks_out) {
#line 1556
        if (p_send.blocks > max_blocks_out) {
#line 1556
          tmp = 1;
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 1556
        if (max_blocks_in) {
#line 1556
          if (p_read.blocks > max_blocks_in) {
#line 1556
            tmp = 1;
          } else {
#line 1556
            tmp = 0;
          }
        } else {
#line 1556
          tmp = 0;
        }
      }
    }
  }
#line 1556
  return (tmp);
}
}
#line 1563 "packet.c"
void packet_set_rekey_limit(u_int32_t bytes ) 
{ 

  {
#line 1566
  rekey_limit = bytes;
#line 1567
  return;
}
}
#line 1569 "packet.c"
void packet_set_server(void) 
{ 

  {
#line 1572
  server_side = 1;
#line 1573
  return;
}
}
#line 1575 "packet.c"
void packet_set_authenticated(void) 
{ 

  {
#line 1578
  after_authentication = 1;
#line 1579
  return;
}
}
/* compiler builtin: 
   unsigned int __builtin_strcspn(char const   * , char const   * ) ;  */
#line 1 "readpass.o"
#line 143 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 384 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 493
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 537
extern  __attribute__((__nothrow__)) int execlp(char const   *__file , char const   *__arg 
                                                , ...)  __attribute__((__nonnull__(1))) ;
#line 667
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 677
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 723
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 54 "misc.h"
char *read_passphrase(char const   *prompt , int flags ) ;
#line 55
int ( /* format attribute */  ask_permission)(char const   *fmt  , ...) ;
#line 34 "readpass.c"
static char *ssh_askpass(char *askpass , char const   *msg ) 
{ pid_t pid ;
  size_t len ;
  char *pass ;
  int p[2] ;
  int status ;
  int ret ;
  char buf___1[1024] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  __uid_t tmp___7 ;
  __uid_t tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  __pid_t tmp___16 ;
  union __anonunion___u_77 __u ;
  union __anonunion___u_78 __u___0 ;
  unsigned int tmp___49 ;

  {
#line 43
  tmp___1 = fflush(stdout);
#line 43
  if (tmp___1 != 0) {
#line 44
    tmp = __errno_location();
#line 44
    tmp___0 = strerror(*tmp);
#line 44
    error("ssh_askpass: fflush: %s", tmp___0);
  }
#line 45
  if ((unsigned int )askpass == (unsigned int )((void *)0)) {
#line 46
    fatal("internal error: askpass undefined");
  }
#line 47
  tmp___4 = pipe((int *)(p));
#line 47
  if (tmp___4 < 0) {
#line 48
    tmp___2 = __errno_location();
#line 48
    tmp___3 = strerror(*tmp___2);
#line 48
    error("ssh_askpass: pipe: %s", tmp___3);
#line 49
    return ((char *)((void *)0));
  }
#line 51
  pid = fork();
#line 51
  if (pid < 0) {
#line 52
    tmp___5 = __errno_location();
#line 52
    tmp___6 = strerror(*tmp___5);
#line 52
    error("ssh_askpass: fork: %s", tmp___6);
#line 53
    return ((char *)((void *)0));
  }
#line 55
  if (pid == 0) {
#line 56
    tmp___7 = getuid();
#line 56
    seteuid(tmp___7);
#line 57
    tmp___8 = getuid();
#line 57
    setuid(tmp___8);
#line 58
    close(p[0]);
#line 59
    tmp___11 = dup2(p[1], 1);
#line 59
    if (tmp___11 < 0) {
#line 60
      tmp___9 = __errno_location();
#line 60
      tmp___10 = strerror(*tmp___9);
#line 60
      fatal("ssh_askpass: dup2: %s", tmp___10);
    }
#line 61
    execlp((char const   *)askpass, (char const   *)askpass, msg, (char *)0);
#line 62
    tmp___12 = __errno_location();
#line 62
    tmp___13 = strerror(*tmp___12);
#line 62
    fatal("ssh_askpass: exec(%s): %s", askpass, tmp___13);
  }
#line 64
  close(p[1]);
#line 66
  ret = 0;
#line 66
  len = (unsigned int )ret;
#line 67
  while (1) {
#line 68
    ret = read(p[0], (void *)(buf___1 + len), (sizeof(buf___1) - 1U) - len);
#line 69
    if (ret == -1) {
#line 69
      tmp___14 = __errno_location();
#line 69
      if (*tmp___14 == 4) {
        goto __Cont;
      }
    }
#line 71
    if (ret <= 0) {
#line 72
      break;
    }
#line 73
    len += (size_t )ret;
    __Cont: /* CIL Label */ 
#line 67
    if (! ((sizeof(buf___1) - 1U) - len > 0U)) {
#line 67
      break;
    }
  }
#line 75
  buf___1[len] = (char )'\000';
#line 77
  close(p[0]);
#line 78
  while (1) {
#line 78
    tmp___16 = waitpid(pid, & status, 0);
#line 78
    if (! (tmp___16 < 0)) {
#line 78
      break;
    }
#line 79
    tmp___15 = __errno_location();
#line 79
    if (*tmp___15 != 4) {
#line 80
      break;
    }
  }
#line 82
  __u.__in = status;
#line 82
  if ((__u.__i & 127) == 0) {
#line 82
    __u___0.__in = status;
#line 82
    if ((__u___0.__i & 65280) >> 8 != 0) {
#line 83
      memset((void *)(buf___1), 0, sizeof(buf___1));
#line 84
      return ((char *)((void *)0));
    }
  } else {
#line 83
    memset((void *)(buf___1), 0, sizeof(buf___1));
#line 84
    return ((char *)((void *)0));
  }
#line 87
  tmp___49 = __builtin_strcspn((char const   *)(buf___1), "\r\n");
#line 87
  buf___1[tmp___49] = (char )'\000';
#line 88
  pass = xstrdup((char const   *)(buf___1));
#line 89
  memset((void *)(buf___1), 0, sizeof(buf___1));
#line 90
  return (pass);
}
}
#line 99 "readpass.c"
char *read_passphrase(char const   *prompt , int flags ) 
{ char *askpass ;
  char *ret ;
  char buf___1[1024] ;
  int rppflags ;
  int use_askpass ;
  int ttyfd ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
#line 102
  askpass = (char *)((void *)0);
#line 103
  use_askpass = 0;
#line 105
  if (flags & 1) {
#line 105
    rppflags = 1;
  } else {
#line 105
    rppflags = 0;
  }
#line 106
  if (flags & 8) {
#line 107
    use_askpass = 1;
  } else {
#line 108
    if (flags & 2) {
#line 109
      tmp = isatty(0);
#line 109
      if (! tmp) {
#line 110
        debug("read_passphrase: stdin is not a tty");
#line 111
        use_askpass = 1;
      }
    } else {
#line 114
      rppflags |= 2;
#line 115
      ttyfd = open("/dev/tty", 2);
#line 116
      if (ttyfd >= 0) {
#line 117
        close(ttyfd);
      } else {
#line 119
        tmp___0 = __errno_location();
#line 119
        tmp___1 = strerror(*tmp___0);
#line 119
        debug("read_passphrase: can\'t open %s: %s", "/dev/tty", tmp___1);
#line 121
        use_askpass = 1;
      }
    }
  }
#line 125
  if (flags & 8) {
#line 125
    tmp___4 = getenv("DISPLAY");
#line 125
    if ((unsigned int )tmp___4 == (unsigned int )((void *)0)) {
#line 126
      if (flags & 4) {
#line 126
        tmp___3 = (char *)((void *)0);
      } else {
#line 126
        tmp___3 = xstrdup("");
      }
#line 126
      return (tmp___3);
    }
  }
#line 128
  if (use_askpass) {
#line 128
    tmp___7 = getenv("DISPLAY");
#line 128
    if (tmp___7) {
#line 129
      tmp___5 = getenv("SSH_ASKPASS");
#line 129
      if (tmp___5) {
#line 130
        askpass = getenv("SSH_ASKPASS");
      } else {
#line 132
        askpass = (char *)"/usr/local/libexec/ssh-askpass";
      }
#line 133
      ret = ssh_askpass(askpass, prompt);
#line 133
      if ((unsigned int )ret == (unsigned int )((void *)0)) {
#line 134
        if (! (flags & 4)) {
#line 135
          tmp___6 = xstrdup("");
#line 135
          return (tmp___6);
        }
      }
#line 136
      return (ret);
    }
  }
#line 139
  tmp___9 = readpassphrase(prompt, buf___1, sizeof(buf___1), rppflags);
#line 139
  if ((unsigned int )tmp___9 == (unsigned int )((void *)0)) {
#line 140
    if (flags & 4) {
#line 141
      return ((char *)((void *)0));
    }
#line 142
    tmp___8 = xstrdup("");
#line 142
    return (tmp___8);
  }
#line 145
  ret = xstrdup((char const   *)(buf___1));
#line 146
  memset((void *)(buf___1), 'x', sizeof(buf___1));
#line 147
  return (ret);
}
}
#line 150 "readpass.c"
int ( /* format attribute */  ask_permission)(char const   *fmt  , ...) 
{ va_list args ;
  char *p ;
  char prompt[1024] ;
  int allowed ;
  int tmp ;

  {
#line 155
  allowed = 0;
#line 157
  __builtin_va_start(args, fmt);
#line 158
  vsnprintf((char * __restrict  )(prompt), sizeof(prompt), (char const   * __restrict  )fmt,
            args);
#line 159
  __builtin_va_end(args);
#line 161
  p = read_passphrase((char const   *)(prompt), 12);
#line 162
  if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 167
    if ((int )*p == 0) {
#line 169
      allowed = 1;
    } else {
#line 167
      if ((int )*p == 10) {
#line 169
        allowed = 1;
      } else {
#line 167
        tmp = strcasecmp((char const   *)p, "yes");
#line 167
        if (tmp == 0) {
#line 169
          allowed = 1;
        }
      }
    }
#line 170
    xfree((void *)p);
  }
#line 173
  return (allowed);
}
}
#line 1 "rsa.o"
#line 391 "/usr/include/openssl/bn.h"
extern BIGNUM const   *BN_value_one(void) ;
#line 409
extern void BN_clear_free(BIGNUM *a ) ;
#line 416
extern int BN_sub(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *b ) ;
#line 433
extern int BN_div(BIGNUM *dv , BIGNUM *rem , BIGNUM const   *m , BIGNUM const   *d ,
                  BN_CTX *ctx ) ;
#line 230 "/usr/include/openssl/rsa.h"
extern int RSA_public_encrypt(int flen , unsigned char const   *from , unsigned char *to ,
                              RSA *rsa , int padding ) ;
#line 236
extern int RSA_private_decrypt(int flen , unsigned char const   *from , unsigned char *to ,
                               RSA *rsa , int padding ) ;
#line 22 "rsa.h"
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 23
int rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 69 "rsa.c"
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ u_char *inbuf ;
  u_char *outbuf ;
  int len ;
  int ilen ;
  int olen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 75
  tmp = BN_num_bits((BIGNUM const   *)key->e);
#line 75
  if (tmp < 2) {
#line 76
    fatal("rsa_public_encrypt() exponent too small or not odd");
  } else {
#line 75
    if ((key->e)->top > 0) {
#line 75
      if (! (*((key->e)->d + 0) & 1UL)) {
#line 76
        fatal("rsa_public_encrypt() exponent too small or not odd");
      }
    } else {
#line 76
      fatal("rsa_public_encrypt() exponent too small or not odd");
    }
  }
#line 78
  tmp___0 = BN_num_bits((BIGNUM const   *)key->n);
#line 78
  olen = (tmp___0 + 7) / 8;
#line 79
  tmp___1 = xmalloc((unsigned int )olen);
#line 79
  outbuf = (u_char *)tmp___1;
#line 81
  tmp___2 = BN_num_bits((BIGNUM const   *)in);
#line 81
  ilen = (tmp___2 + 7) / 8;
#line 82
  tmp___3 = xmalloc((unsigned int )ilen);
#line 82
  inbuf = (u_char *)tmp___3;
#line 83
  BN_bn2bin((BIGNUM const   *)in, inbuf);
#line 85
  len = RSA_public_encrypt(ilen, (unsigned char const   *)inbuf, outbuf, key, 1);
#line 85
  if (len <= 0) {
#line 87
    fatal("rsa_public_encrypt() failed");
  }
#line 89
  BN_bin2bn((unsigned char const   *)outbuf, len, out);
#line 91
  memset((void *)outbuf, 0, (unsigned int )olen);
#line 92
  memset((void *)inbuf, 0, (unsigned int )ilen);
#line 93
  xfree((void *)outbuf);
#line 94
  xfree((void *)inbuf);
#line 95
  return;
}
}
#line 97 "rsa.c"
int rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ u_char *inbuf ;
  u_char *outbuf ;
  int len ;
  int ilen ;
  int olen ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 103
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 103
  olen = (tmp + 7) / 8;
#line 104
  tmp___0 = xmalloc((unsigned int )olen);
#line 104
  outbuf = (u_char *)tmp___0;
#line 106
  tmp___1 = BN_num_bits((BIGNUM const   *)in);
#line 106
  ilen = (tmp___1 + 7) / 8;
#line 107
  tmp___2 = xmalloc((unsigned int )ilen);
#line 107
  inbuf = (u_char *)tmp___2;
#line 108
  BN_bn2bin((BIGNUM const   *)in, inbuf);
#line 110
  len = RSA_private_decrypt(ilen, (unsigned char const   *)inbuf, outbuf, key, 1);
#line 110
  if (len <= 0) {
#line 112
    error("rsa_private_decrypt() failed");
  } else {
#line 114
    BN_bin2bn((unsigned char const   *)outbuf, len, out);
  }
#line 116
  memset((void *)outbuf, 0, (unsigned int )olen);
#line 117
  memset((void *)inbuf, 0, (unsigned int )ilen);
#line 118
  xfree((void *)outbuf);
#line 119
  xfree((void *)inbuf);
#line 120
  return (len);
}
}
#line 124 "rsa.c"
void rsa_generate_additional_parameters(RSA *rsa ) 
{ BIGNUM *aux ;
  BN_CTX *ctx ;
  BIGNUM const   *tmp ;
  BIGNUM const   *tmp___0 ;

  {
#line 130
  aux = BN_new();
#line 130
  if ((unsigned int )aux == (unsigned int )((void *)0)) {
#line 131
    fatal("rsa_generate_additional_parameters: BN_new failed");
  }
#line 132
  ctx = BN_CTX_new();
#line 132
  if ((unsigned int )ctx == (unsigned int )((void *)0)) {
#line 133
    fatal("rsa_generate_additional_parameters: BN_CTX_new failed");
  }
#line 135
  tmp = BN_value_one();
#line 135
  BN_sub(aux, (BIGNUM const   *)rsa->q, tmp);
#line 136
  BN_div((BIGNUM *)((void *)0), rsa->dmq1, (BIGNUM const   *)rsa->d, (BIGNUM const   *)aux,
         ctx);
#line 138
  tmp___0 = BN_value_one();
#line 138
  BN_sub(aux, (BIGNUM const   *)rsa->p, tmp___0);
#line 139
  BN_div((BIGNUM *)((void *)0), rsa->dmp1, (BIGNUM const   *)rsa->d, (BIGNUM const   *)aux,
         ctx);
#line 141
  BN_clear_free(aux);
#line 142
  BN_CTX_free(ctx);
#line 143
  return;
}
}
#line 1 "ttymodes.o"
#line 49 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) speed_t cfgetospeed(struct termios  const  *__termios_p ) ;
#line 52
extern  __attribute__((__nothrow__)) speed_t cfgetispeed(struct termios  const  *__termios_p ) ;
#line 55
extern  __attribute__((__nothrow__)) int cfsetospeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 58
extern  __attribute__((__nothrow__)) int cfsetispeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 83 "packet.h"
void tty_make_modes(int fd , struct termios *tiop ) ;
#line 84
void tty_parse_modes(int fd , int *n_bytes_ptr ) ;
#line 68 "ttymodes.c"
static int speed_to_baud(speed_t speed ) 
{ 

  {
#line 71
  switch ((int )speed) {
  case 0: 
#line 73
  return (0);
  case 1: 
#line 75
  return (50);
  case 2: 
#line 77
  return (75);
  case 3: 
#line 79
  return (110);
  case 4: 
#line 81
  return (134);
  case 5: 
#line 83
  return (150);
  case 6: 
#line 85
  return (200);
  case 7: 
#line 87
  return (300);
  case 8: 
#line 89
  return (600);
  case 9: 
#line 91
  return (1200);
  case 10: 
#line 93
  return (1800);
  case 11: 
#line 95
  return (2400);
  case 12: 
#line 97
  return (4800);
  case 13: 
#line 99
  return (9600);
  case 14: 
#line 103
  return (19200);
  case 15: 
#line 113
  return (38400);
  case 4097: 
#line 135
  return (57600);
  case 4098: 
#line 143
  return (115200);
  case 4099: 
#line 147
  return (230400);
  default: ;
#line 150
  return (9600);
  }
}
}
#line 157 "ttymodes.c"
static speed_t baud_to_speed(int baud ) 
{ 

  {
#line 160
  switch (baud) {
  case 0: 
#line 162
  return (0U);
  case 50: 
#line 164
  return (1U);
  case 75: 
#line 166
  return (2U);
  case 110: 
#line 168
  return (3U);
  case 134: 
#line 170
  return (4U);
  case 150: 
#line 172
  return (5U);
  case 200: 
#line 174
  return (6U);
  case 300: 
#line 176
  return (7U);
  case 600: 
#line 178
  return (8U);
  case 1200: 
#line 180
  return (9U);
  case 1800: 
#line 182
  return (10U);
  case 2400: 
#line 184
  return (11U);
  case 4800: 
#line 186
  return (12U);
  case 9600: 
#line 188
  return (13U);
  case 19200: 
#line 192
  return (14U);
  case 38400: 
#line 202
  return (15U);
  case 57600: 
#line 224
  return (4097U);
  case 115200: 
#line 232
  return (4098U);
  case 230400: 
#line 236
  return (4099U);
  default: ;
#line 239
  return (13U);
  }
}
}
#line 246 "ttymodes.c"
static u_int special_char_encode(cc_t c ) 
{ 

  {
#line 250
  if ((int )c == 0) {
#line 251
    return (255U);
  }
#line 253
  return ((unsigned int )c);
}
}
#line 259 "ttymodes.c"
static cc_t special_char_decode(u_int c ) 
{ 

  {
#line 263
  if (c == 255U) {
#line 264
    return ((unsigned char )'\000');
  }
#line 266
  return ((unsigned char )c);
}
}
#line 274 "ttymodes.c"
void tty_make_modes(int fd , struct termios *tiop ) 
{ struct termios tio ;
  int baud ;
  Buffer buf___1 ;
  int tty_op_ospeed ;
  int tty_op_ispeed ;
  void (*put_arg)(Buffer * , u_int  ) ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  speed_t tmp___2 ;
  speed_t tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  u_int tmp___6 ;
  u_int tmp___7 ;
  u_int tmp___8 ;
  u_int tmp___9 ;
  u_int tmp___10 ;
  u_int tmp___11 ;
  u_int tmp___12 ;
  u_int tmp___13 ;
  u_int tmp___14 ;
  u_int tmp___15 ;
  u_int tmp___16 ;
  u_int tmp___17 ;
  u_int tmp___18 ;
  void *tmp___19 ;
  u_int tmp___20 ;
  void *tmp___21 ;

  {
#line 283
  buffer_init(& buf___1);
#line 284
  if (compat20) {
#line 285
    tty_op_ospeed = 129;
#line 286
    tty_op_ispeed = 128;
#line 287
    put_arg = & buffer_put_int;
  } else {
#line 289
    tty_op_ospeed = 193;
#line 290
    tty_op_ispeed = 192;
#line 291
    put_arg = (void (*)(Buffer * , u_int  ))(& buffer_put_char);
  }
#line 294
  if ((unsigned int )tiop == (unsigned int )((void *)0)) {
#line 295
    tmp___1 = tcgetattr(fd, & tio);
#line 295
    if (tmp___1 == -1) {
#line 296
      tmp = __errno_location();
#line 296
      tmp___0 = strerror(*tmp);
#line 296
      logit("tcgetattr: %.100s", tmp___0);
      goto end;
    }
  } else {
#line 300
    tio = *tiop;
  }
#line 303
  tmp___2 = cfgetospeed((struct termios  const  *)(& tio));
#line 303
  baud = speed_to_baud(tmp___2);
#line 304
  debug3("tty_make_modes: ospeed %d", baud);
#line 305
  buffer_put_char(& buf___1, tty_op_ospeed);
#line 306
  buffer_put_int(& buf___1, (unsigned int )baud);
#line 307
  tmp___3 = cfgetispeed((struct termios  const  *)(& tio));
#line 307
  baud = speed_to_baud(tmp___3);
#line 308
  debug3("tty_make_modes: ispeed %d", baud);
#line 309
  buffer_put_char(& buf___1, tty_op_ispeed);
#line 310
  buffer_put_int(& buf___1, (unsigned int )baud);
#line 70 "ttymodes.h"
  debug3("tty_make_modes: %d %d", 1, tio.c_cc[0]);
#line 70
  buffer_put_char(& buf___1, 1);
#line 70
  tmp___4 = special_char_encode(tio.c_cc[0]);
#line 70
  (*put_arg)(& buf___1, tmp___4);
#line 71
  debug3("tty_make_modes: %d %d", 2, tio.c_cc[1]);
#line 71
  buffer_put_char(& buf___1, 2);
#line 71
  tmp___5 = special_char_encode(tio.c_cc[1]);
#line 71
  (*put_arg)(& buf___1, tmp___5);
#line 72
  debug3("tty_make_modes: %d %d", 3, tio.c_cc[2]);
#line 72
  buffer_put_char(& buf___1, 3);
#line 72
  tmp___6 = special_char_encode(tio.c_cc[2]);
#line 72
  (*put_arg)(& buf___1, tmp___6);
#line 74
  debug3("tty_make_modes: %d %d", 4, tio.c_cc[3]);
#line 74
  buffer_put_char(& buf___1, 4);
#line 74
  tmp___7 = special_char_encode(tio.c_cc[3]);
#line 74
  (*put_arg)(& buf___1, tmp___7);
#line 76
  debug3("tty_make_modes: %d %d", 5, tio.c_cc[4]);
#line 76
  buffer_put_char(& buf___1, 5);
#line 76
  tmp___8 = special_char_encode(tio.c_cc[4]);
#line 76
  (*put_arg)(& buf___1, tmp___8);
#line 78
  debug3("tty_make_modes: %d %d", 6, tio.c_cc[11]);
#line 78
  buffer_put_char(& buf___1, 6);
#line 78
  tmp___9 = special_char_encode(tio.c_cc[11]);
#line 78
  (*put_arg)(& buf___1, tmp___9);
#line 81
  debug3("tty_make_modes: %d %d", 7, tio.c_cc[16]);
#line 81
  buffer_put_char(& buf___1, 7);
#line 81
  tmp___10 = special_char_encode(tio.c_cc[16]);
#line 81
  (*put_arg)(& buf___1, tmp___10);
#line 83
  debug3("tty_make_modes: %d %d", 8, tio.c_cc[8]);
#line 83
  buffer_put_char(& buf___1, 8);
#line 83
  tmp___11 = special_char_encode(tio.c_cc[8]);
#line 83
  (*put_arg)(& buf___1, tmp___11);
#line 84
  debug3("tty_make_modes: %d %d", 9, tio.c_cc[9]);
#line 84
  buffer_put_char(& buf___1, 9);
#line 84
  tmp___12 = special_char_encode(tio.c_cc[9]);
#line 84
  (*put_arg)(& buf___1, tmp___12);
#line 86
  debug3("tty_make_modes: %d %d", 10, tio.c_cc[10]);
#line 86
  buffer_put_char(& buf___1, 10);
#line 86
  tmp___13 = special_char_encode(tio.c_cc[10]);
#line 86
  (*put_arg)(& buf___1, tmp___13);
#line 92
  debug3("tty_make_modes: %d %d", 12, tio.c_cc[12]);
#line 92
  buffer_put_char(& buf___1, 12);
#line 92
  tmp___14 = special_char_encode(tio.c_cc[12]);
#line 92
  (*put_arg)(& buf___1, tmp___14);
#line 95
  debug3("tty_make_modes: %d %d", 13, tio.c_cc[14]);
#line 95
  buffer_put_char(& buf___1, 13);
#line 95
  tmp___15 = special_char_encode(tio.c_cc[14]);
#line 95
  (*put_arg)(& buf___1, tmp___15);
#line 98
  debug3("tty_make_modes: %d %d", 14, tio.c_cc[15]);
#line 98
  buffer_put_char(& buf___1, 14);
#line 98
  tmp___16 = special_char_encode(tio.c_cc[15]);
#line 98
  (*put_arg)(& buf___1, tmp___16);
#line 110
  debug3("tty_make_modes: %d %d", 18, tio.c_cc[13]);
#line 110
  buffer_put_char(& buf___1, 18);
#line 110
  tmp___17 = special_char_encode(tio.c_cc[13]);
#line 110
  (*put_arg)(& buf___1, tmp___17);
#line 114
  debug3("tty_make_modes: %d %d", 30, (tio.c_iflag & 4U) != 0U);
#line 114
  buffer_put_char(& buf___1, 30);
#line 114
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 4U) != 0U));
#line 115
  debug3("tty_make_modes: %d %d", 31, (tio.c_iflag & 8U) != 0U);
#line 115
  buffer_put_char(& buf___1, 31);
#line 115
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 8U) != 0U));
#line 116
  debug3("tty_make_modes: %d %d", 32, (tio.c_iflag & 16U) != 0U);
#line 116
  buffer_put_char(& buf___1, 32);
#line 116
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 16U) != 0U));
#line 117
  debug3("tty_make_modes: %d %d", 33, (tio.c_iflag & 32U) != 0U);
#line 117
  buffer_put_char(& buf___1, 33);
#line 117
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 32U) != 0U));
#line 118
  debug3("tty_make_modes: %d %d", 34, (tio.c_iflag & 64U) != 0U);
#line 118
  buffer_put_char(& buf___1, 34);
#line 118
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 64U) != 0U));
#line 119
  debug3("tty_make_modes: %d %d", 35, (tio.c_iflag & 128U) != 0U);
#line 119
  buffer_put_char(& buf___1, 35);
#line 119
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 128U) != 0U));
#line 120
  debug3("tty_make_modes: %d %d", 36, (tio.c_iflag & 256U) != 0U);
#line 120
  buffer_put_char(& buf___1, 36);
#line 120
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 256U) != 0U));
#line 122
  debug3("tty_make_modes: %d %d", 37, (tio.c_iflag & 512U) != 0U);
#line 122
  buffer_put_char(& buf___1, 37);
#line 122
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 512U) != 0U));
#line 124
  debug3("tty_make_modes: %d %d", 38, (tio.c_iflag & 1024U) != 0U);
#line 124
  buffer_put_char(& buf___1, 38);
#line 124
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 1024U) != 0U));
#line 125
  debug3("tty_make_modes: %d %d", 39, (tio.c_iflag & 2048U) != 0U);
#line 125
  buffer_put_char(& buf___1, 39);
#line 125
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 2048U) != 0U));
#line 126
  debug3("tty_make_modes: %d %d", 40, (tio.c_iflag & 4096U) != 0U);
#line 126
  buffer_put_char(& buf___1, 40);
#line 126
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 4096U) != 0U));
#line 128
  debug3("tty_make_modes: %d %d", 41, (tio.c_iflag & 8192U) != 0U);
#line 128
  buffer_put_char(& buf___1, 41);
#line 128
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 8192U) != 0U));
#line 131
  debug3("tty_make_modes: %d %d", 50, (tio.c_lflag & 1U) != 0U);
#line 131
  buffer_put_char(& buf___1, 50);
#line 131
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 1U) != 0U));
#line 132
  debug3("tty_make_modes: %d %d", 51, (tio.c_lflag & 2U) != 0U);
#line 132
  buffer_put_char(& buf___1, 51);
#line 132
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 2U) != 0U));
#line 134
  debug3("tty_make_modes: %d %d", 52, (tio.c_lflag & 4U) != 0U);
#line 134
  buffer_put_char(& buf___1, 52);
#line 134
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 4U) != 0U));
#line 136
  debug3("tty_make_modes: %d %d", 53, (tio.c_lflag & 8U) != 0U);
#line 136
  buffer_put_char(& buf___1, 53);
#line 136
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 8U) != 0U));
#line 137
  debug3("tty_make_modes: %d %d", 54, (tio.c_lflag & 16U) != 0U);
#line 137
  buffer_put_char(& buf___1, 54);
#line 137
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 16U) != 0U));
#line 138
  debug3("tty_make_modes: %d %d", 55, (tio.c_lflag & 32U) != 0U);
#line 138
  buffer_put_char(& buf___1, 55);
#line 138
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 32U) != 0U));
#line 139
  debug3("tty_make_modes: %d %d", 56, (tio.c_lflag & 64U) != 0U);
#line 139
  buffer_put_char(& buf___1, 56);
#line 139
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 64U) != 0U));
#line 140
  debug3("tty_make_modes: %d %d", 57, (tio.c_lflag & 128U) != 0U);
#line 140
  buffer_put_char(& buf___1, 57);
#line 140
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 128U) != 0U));
#line 141
  debug3("tty_make_modes: %d %d", 58, (tio.c_lflag & 256U) != 0U);
#line 141
  buffer_put_char(& buf___1, 58);
#line 141
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 256U) != 0U));
#line 143
  debug3("tty_make_modes: %d %d", 59, (tio.c_lflag & 32768U) != 0U);
#line 143
  buffer_put_char(& buf___1, 59);
#line 143
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 32768U) != 0U));
#line 146
  debug3("tty_make_modes: %d %d", 60, (tio.c_lflag & 512U) != 0U);
#line 146
  buffer_put_char(& buf___1, 60);
#line 146
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 512U) != 0U));
#line 149
  debug3("tty_make_modes: %d %d", 61, (tio.c_lflag & 2048U) != 0U);
#line 149
  buffer_put_char(& buf___1, 61);
#line 149
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 2048U) != 0U));
#line 152
  debug3("tty_make_modes: %d %d", 62, (tio.c_lflag & 16384U) != 0U);
#line 152
  buffer_put_char(& buf___1, 62);
#line 152
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 16384U) != 0U));
#line 155
  debug3("tty_make_modes: %d %d", 70, (tio.c_oflag & 1U) != 0U);
#line 155
  buffer_put_char(& buf___1, 70);
#line 155
  (*put_arg)(& buf___1, (unsigned int )((tio.c_oflag & 1U) != 0U));
#line 157
  debug3("tty_make_modes: %d %d", 71, (tio.c_oflag & 2U) != 0U);
#line 157
  buffer_put_char(& buf___1, 71);
#line 157
  (*put_arg)(& buf___1, (unsigned int )((tio.c_oflag & 2U) != 0U));
#line 160
  debug3("tty_make_modes: %d %d", 72, (tio.c_oflag & 4U) != 0U);
#line 160
  buffer_put_char(& buf___1, 72);
#line 160
  (*put_arg)(& buf___1, (unsigned int )((tio.c_oflag & 4U) != 0U));
#line 163
  debug3("tty_make_modes: %d %d", 73, (tio.c_oflag & 8U) != 0U);
#line 163
  buffer_put_char(& buf___1, 73);
#line 163
  (*put_arg)(& buf___1, (unsigned int )((tio.c_oflag & 8U) != 0U));
#line 166
  debug3("tty_make_modes: %d %d", 74, (tio.c_oflag & 16U) != 0U);
#line 166
  buffer_put_char(& buf___1, 74);
#line 166
  (*put_arg)(& buf___1, (unsigned int )((tio.c_oflag & 16U) != 0U));
#line 169
  debug3("tty_make_modes: %d %d", 75, (tio.c_oflag & 32U) != 0U);
#line 169
  buffer_put_char(& buf___1, 75);
#line 169
  (*put_arg)(& buf___1, (unsigned int )((tio.c_oflag & 32U) != 0U));
#line 172
  debug3("tty_make_modes: %d %d", 90, (tio.c_cflag & 32U) != 0U);
#line 172
  buffer_put_char(& buf___1, 90);
#line 172
  (*put_arg)(& buf___1, (unsigned int )((tio.c_cflag & 32U) != 0U));
#line 173
  debug3("tty_make_modes: %d %d", 91, (tio.c_cflag & 48U) != 0U);
#line 173
  buffer_put_char(& buf___1, 91);
#line 173
  (*put_arg)(& buf___1, (unsigned int )((tio.c_cflag & 48U) != 0U));
#line 174
  debug3("tty_make_modes: %d %d", 92, (tio.c_cflag & 256U) != 0U);
#line 174
  buffer_put_char(& buf___1, 92);
#line 174
  (*put_arg)(& buf___1, (unsigned int )((tio.c_cflag & 256U) != 0U));
#line 175
  debug3("tty_make_modes: %d %d", 93, (tio.c_cflag & 512U) != 0U);
#line 175
  buffer_put_char(& buf___1, 93);
#line 175
  (*put_arg)(& buf___1, (unsigned int )((tio.c_cflag & 512U) != 0U));
  end: 
#line 330 "ttymodes.c"
  buffer_put_char(& buf___1, 0);
#line 331
  if (compat20) {
#line 332
    tmp___18 = buffer_len(& buf___1);
#line 332
    tmp___19 = buffer_ptr(& buf___1);
#line 332
    packet_put_string((void const   *)tmp___19, tmp___18);
  } else {
#line 334
    tmp___20 = buffer_len(& buf___1);
#line 334
    tmp___21 = buffer_ptr(& buf___1);
#line 334
    packet_put_raw((void const   *)tmp___21, tmp___20);
  }
#line 335
  buffer_free(& buf___1);
#line 336
  return;
}
}
#line 342 "ttymodes.c"
void tty_parse_modes(int fd , int *n_bytes_ptr ) 
{ struct termios tio ;
  int opcode ;
  int baud ;
  int n_bytes ;
  int failure ;
  u_int (*get_arg)(void) ;
  int arg ;
  int arg_size ;
  u_int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  u_int tmp___3 ;
  u_int tmp___4 ;
  speed_t tmp___5 ;
  int tmp___6 ;
  u_int tmp___7 ;
  speed_t tmp___8 ;
  int tmp___9 ;
  u_int tmp___10 ;
  u_int tmp___11 ;
  u_int tmp___12 ;
  u_int tmp___13 ;
  u_int tmp___14 ;
  u_int tmp___15 ;
  u_int tmp___16 ;
  u_int tmp___17 ;
  u_int tmp___18 ;
  u_int tmp___19 ;
  u_int tmp___20 ;
  u_int tmp___21 ;
  u_int tmp___22 ;
  u_int tmp___23 ;
  u_int tmp___24 ;
  u_int tmp___25 ;
  u_int tmp___26 ;
  u_int tmp___27 ;
  u_int tmp___28 ;
  u_int tmp___29 ;
  u_int tmp___30 ;
  u_int tmp___31 ;
  u_int tmp___32 ;
  u_int tmp___33 ;
  u_int tmp___34 ;
  u_int tmp___35 ;
  u_int tmp___36 ;
  u_int tmp___37 ;
  u_int tmp___38 ;
  u_int tmp___39 ;
  u_int tmp___40 ;
  u_int tmp___41 ;
  u_int tmp___42 ;
  u_int tmp___43 ;
  u_int tmp___44 ;
  u_int tmp___45 ;
  u_int tmp___46 ;
  u_int tmp___47 ;
  u_int tmp___48 ;
  u_int tmp___49 ;
  u_int tmp___50 ;
  u_int tmp___51 ;
  u_int tmp___52 ;
  u_int tmp___53 ;
  u_int tmp___54 ;
  u_int tmp___55 ;
  u_int tmp___56 ;
  u_int tmp___57 ;
  u_int tmp___58 ;
  int *tmp___59 ;
  char *tmp___60 ;
  int tmp___61 ;

  {
#line 347
  n_bytes = 0;
#line 348
  failure = 0;
#line 352
  if (compat20) {
#line 353
    tmp = packet_get_int();
#line 353
    *n_bytes_ptr = (int )tmp;
#line 354
    debug3("tty_parse_modes: SSH2 n_bytes %d", *n_bytes_ptr);
#line 355
    if (*n_bytes_ptr == 0) {
#line 356
      return;
    }
#line 357
    get_arg = & packet_get_int;
#line 358
    arg_size = 4;
  } else {
#line 360
    get_arg = & packet_get_char;
#line 361
    arg_size = 1;
  }
#line 369
  tmp___2 = tcgetattr(fd, & tio);
#line 369
  if (tmp___2 == -1) {
#line 370
    tmp___0 = __errno_location();
#line 370
    tmp___1 = strerror(*tmp___0);
#line 370
    logit("tcgetattr: %.100s", tmp___1);
#line 371
    failure = -1;
  }
#line 374
  while (1) {
#line 375
    n_bytes ++;
#line 376
    tmp___3 = packet_get_char();
#line 376
    opcode = (int )tmp___3;
#line 377
    switch (opcode) {
    case 0: 
    goto set;
    case 192: 
    case 128: 
#line 384
    n_bytes += 4;
#line 385
    tmp___4 = packet_get_int();
#line 385
    baud = (int )tmp___4;
#line 386
    debug3("tty_parse_modes: ispeed %d", baud);
#line 387
    if (failure != -1) {
#line 387
      tmp___5 = baud_to_speed(baud);
#line 387
      tmp___6 = cfsetispeed(& tio, tmp___5);
#line 387
      if (tmp___6 == -1) {
#line 388
        error("cfsetispeed failed for %d", baud);
      }
    }
#line 389
    break;
    case 193: 
    case 129: 
#line 394
    n_bytes += 4;
#line 395
    tmp___7 = packet_get_int();
#line 395
    baud = (int )tmp___7;
#line 396
    debug3("tty_parse_modes: ospeed %d", baud);
#line 397
    if (failure != -1) {
#line 397
      tmp___8 = baud_to_speed(baud);
#line 397
      tmp___9 = cfsetospeed(& tio, tmp___8);
#line 397
      if (tmp___9 == -1) {
#line 398
        error("cfsetospeed failed for %d", baud);
      }
    }
#line 399
    break;
    case 1: 
#line 70 "ttymodes.h"
    n_bytes += arg_size;
#line 70
    tmp___10 = (*get_arg)();
#line 70
    tio.c_cc[0] = special_char_decode(tmp___10);
#line 70
    debug3("tty_parse_modes: %d %d", 1, tio.c_cc[0]);
#line 70
    break;
    case 2: 
#line 71
    n_bytes += arg_size;
#line 71
    tmp___11 = (*get_arg)();
#line 71
    tio.c_cc[1] = special_char_decode(tmp___11);
#line 71
    debug3("tty_parse_modes: %d %d", 2, tio.c_cc[1]);
#line 71
    break;
    case 3: 
#line 72
    n_bytes += arg_size;
#line 72
    tmp___12 = (*get_arg)();
#line 72
    tio.c_cc[2] = special_char_decode(tmp___12);
#line 72
    debug3("tty_parse_modes: %d %d", 3, tio.c_cc[2]);
#line 72
    break;
    case 4: 
#line 74
    n_bytes += arg_size;
#line 74
    tmp___13 = (*get_arg)();
#line 74
    tio.c_cc[3] = special_char_decode(tmp___13);
#line 74
    debug3("tty_parse_modes: %d %d", 4, tio.c_cc[3]);
#line 74
    break;
    case 5: 
#line 76
    n_bytes += arg_size;
#line 76
    tmp___14 = (*get_arg)();
#line 76
    tio.c_cc[4] = special_char_decode(tmp___14);
#line 76
    debug3("tty_parse_modes: %d %d", 5, tio.c_cc[4]);
#line 76
    break;
    case 6: 
#line 78
    n_bytes += arg_size;
#line 78
    tmp___15 = (*get_arg)();
#line 78
    tio.c_cc[11] = special_char_decode(tmp___15);
#line 78
    debug3("tty_parse_modes: %d %d", 6, tio.c_cc[11]);
#line 78
    break;
    case 7: 
#line 81
    n_bytes += arg_size;
#line 81
    tmp___16 = (*get_arg)();
#line 81
    tio.c_cc[16] = special_char_decode(tmp___16);
#line 81
    debug3("tty_parse_modes: %d %d", 7, tio.c_cc[16]);
#line 81
    break;
    case 8: 
#line 83
    n_bytes += arg_size;
#line 83
    tmp___17 = (*get_arg)();
#line 83
    tio.c_cc[8] = special_char_decode(tmp___17);
#line 83
    debug3("tty_parse_modes: %d %d", 8, tio.c_cc[8]);
#line 83
    break;
    case 9: 
#line 84
    n_bytes += arg_size;
#line 84
    tmp___18 = (*get_arg)();
#line 84
    tio.c_cc[9] = special_char_decode(tmp___18);
#line 84
    debug3("tty_parse_modes: %d %d", 9, tio.c_cc[9]);
#line 84
    break;
    case 10: 
#line 86
    n_bytes += arg_size;
#line 86
    tmp___19 = (*get_arg)();
#line 86
    tio.c_cc[10] = special_char_decode(tmp___19);
#line 86
    debug3("tty_parse_modes: %d %d", 10, tio.c_cc[10]);
#line 86
    break;
    case 12: 
#line 92
    n_bytes += arg_size;
#line 92
    tmp___20 = (*get_arg)();
#line 92
    tio.c_cc[12] = special_char_decode(tmp___20);
#line 92
    debug3("tty_parse_modes: %d %d", 12, tio.c_cc[12]);
#line 92
    break;
    case 13: 
#line 95
    n_bytes += arg_size;
#line 95
    tmp___21 = (*get_arg)();
#line 95
    tio.c_cc[14] = special_char_decode(tmp___21);
#line 95
    debug3("tty_parse_modes: %d %d", 13, tio.c_cc[14]);
#line 95
    break;
    case 14: 
#line 98
    n_bytes += arg_size;
#line 98
    tmp___22 = (*get_arg)();
#line 98
    tio.c_cc[15] = special_char_decode(tmp___22);
#line 98
    debug3("tty_parse_modes: %d %d", 14, tio.c_cc[15]);
#line 98
    break;
    case 18: 
#line 110
    n_bytes += arg_size;
#line 110
    tmp___23 = (*get_arg)();
#line 110
    tio.c_cc[13] = special_char_decode(tmp___23);
#line 110
    debug3("tty_parse_modes: %d %d", 18, tio.c_cc[13]);
#line 110
    break;
    case 30: 
#line 114
    n_bytes += arg_size;
#line 114
    tmp___24 = (*get_arg)();
#line 114
    arg = (int )tmp___24;
#line 114
    if (arg) {
#line 114
      tio.c_iflag |= 4U;
    } else {
#line 114
      tio.c_iflag &= 4294967291U;
    }
#line 114
    debug3("tty_parse_modes: %d %d", 30, arg);
#line 114
    break;
    case 31: 
#line 115
    n_bytes += arg_size;
#line 115
    tmp___25 = (*get_arg)();
#line 115
    arg = (int )tmp___25;
#line 115
    if (arg) {
#line 115
      tio.c_iflag |= 8U;
    } else {
#line 115
      tio.c_iflag &= 4294967287U;
    }
#line 115
    debug3("tty_parse_modes: %d %d", 31, arg);
#line 115
    break;
    case 32: 
#line 116
    n_bytes += arg_size;
#line 116
    tmp___26 = (*get_arg)();
#line 116
    arg = (int )tmp___26;
#line 116
    if (arg) {
#line 116
      tio.c_iflag |= 16U;
    } else {
#line 116
      tio.c_iflag &= 4294967279U;
    }
#line 116
    debug3("tty_parse_modes: %d %d", 32, arg);
#line 116
    break;
    case 33: 
#line 117
    n_bytes += arg_size;
#line 117
    tmp___27 = (*get_arg)();
#line 117
    arg = (int )tmp___27;
#line 117
    if (arg) {
#line 117
      tio.c_iflag |= 32U;
    } else {
#line 117
      tio.c_iflag &= 4294967263U;
    }
#line 117
    debug3("tty_parse_modes: %d %d", 33, arg);
#line 117
    break;
    case 34: 
#line 118
    n_bytes += arg_size;
#line 118
    tmp___28 = (*get_arg)();
#line 118
    arg = (int )tmp___28;
#line 118
    if (arg) {
#line 118
      tio.c_iflag |= 64U;
    } else {
#line 118
      tio.c_iflag &= 4294967231U;
    }
#line 118
    debug3("tty_parse_modes: %d %d", 34, arg);
#line 118
    break;
    case 35: 
#line 119
    n_bytes += arg_size;
#line 119
    tmp___29 = (*get_arg)();
#line 119
    arg = (int )tmp___29;
#line 119
    if (arg) {
#line 119
      tio.c_iflag |= 128U;
    } else {
#line 119
      tio.c_iflag &= 4294967167U;
    }
#line 119
    debug3("tty_parse_modes: %d %d", 35, arg);
#line 119
    break;
    case 36: 
#line 120
    n_bytes += arg_size;
#line 120
    tmp___30 = (*get_arg)();
#line 120
    arg = (int )tmp___30;
#line 120
    if (arg) {
#line 120
      tio.c_iflag |= 256U;
    } else {
#line 120
      tio.c_iflag &= 4294967039U;
    }
#line 120
    debug3("tty_parse_modes: %d %d", 36, arg);
#line 120
    break;
    case 37: 
#line 122
    n_bytes += arg_size;
#line 122
    tmp___31 = (*get_arg)();
#line 122
    arg = (int )tmp___31;
#line 122
    if (arg) {
#line 122
      tio.c_iflag |= 512U;
    } else {
#line 122
      tio.c_iflag &= 4294966783U;
    }
#line 122
    debug3("tty_parse_modes: %d %d", 37, arg);
#line 122
    break;
    case 38: 
#line 124
    n_bytes += arg_size;
#line 124
    tmp___32 = (*get_arg)();
#line 124
    arg = (int )tmp___32;
#line 124
    if (arg) {
#line 124
      tio.c_iflag |= 1024U;
    } else {
#line 124
      tio.c_iflag &= 4294966271U;
    }
#line 124
    debug3("tty_parse_modes: %d %d", 38, arg);
#line 124
    break;
    case 39: 
#line 125
    n_bytes += arg_size;
#line 125
    tmp___33 = (*get_arg)();
#line 125
    arg = (int )tmp___33;
#line 125
    if (arg) {
#line 125
      tio.c_iflag |= 2048U;
    } else {
#line 125
      tio.c_iflag &= 4294965247U;
    }
#line 125
    debug3("tty_parse_modes: %d %d", 39, arg);
#line 125
    break;
    case 40: 
#line 126
    n_bytes += arg_size;
#line 126
    tmp___34 = (*get_arg)();
#line 126
    arg = (int )tmp___34;
#line 126
    if (arg) {
#line 126
      tio.c_iflag |= 4096U;
    } else {
#line 126
      tio.c_iflag &= 4294963199U;
    }
#line 126
    debug3("tty_parse_modes: %d %d", 40, arg);
#line 126
    break;
    case 41: 
#line 128
    n_bytes += arg_size;
#line 128
    tmp___35 = (*get_arg)();
#line 128
    arg = (int )tmp___35;
#line 128
    if (arg) {
#line 128
      tio.c_iflag |= 8192U;
    } else {
#line 128
      tio.c_iflag &= 4294959103U;
    }
#line 128
    debug3("tty_parse_modes: %d %d", 41, arg);
#line 128
    break;
    case 50: 
#line 131
    n_bytes += arg_size;
#line 131
    tmp___36 = (*get_arg)();
#line 131
    arg = (int )tmp___36;
#line 131
    if (arg) {
#line 131
      tio.c_lflag |= 1U;
    } else {
#line 131
      tio.c_lflag &= 4294967294U;
    }
#line 131
    debug3("tty_parse_modes: %d %d", 50, arg);
#line 131
    break;
    case 51: 
#line 132
    n_bytes += arg_size;
#line 132
    tmp___37 = (*get_arg)();
#line 132
    arg = (int )tmp___37;
#line 132
    if (arg) {
#line 132
      tio.c_lflag |= 2U;
    } else {
#line 132
      tio.c_lflag &= 4294967293U;
    }
#line 132
    debug3("tty_parse_modes: %d %d", 51, arg);
#line 132
    break;
    case 52: 
#line 134
    n_bytes += arg_size;
#line 134
    tmp___38 = (*get_arg)();
#line 134
    arg = (int )tmp___38;
#line 134
    if (arg) {
#line 134
      tio.c_lflag |= 4U;
    } else {
#line 134
      tio.c_lflag &= 4294967291U;
    }
#line 134
    debug3("tty_parse_modes: %d %d", 52, arg);
#line 134
    break;
    case 53: 
#line 136
    n_bytes += arg_size;
#line 136
    tmp___39 = (*get_arg)();
#line 136
    arg = (int )tmp___39;
#line 136
    if (arg) {
#line 136
      tio.c_lflag |= 8U;
    } else {
#line 136
      tio.c_lflag &= 4294967287U;
    }
#line 136
    debug3("tty_parse_modes: %d %d", 53, arg);
#line 136
    break;
    case 54: 
#line 137
    n_bytes += arg_size;
#line 137
    tmp___40 = (*get_arg)();
#line 137
    arg = (int )tmp___40;
#line 137
    if (arg) {
#line 137
      tio.c_lflag |= 16U;
    } else {
#line 137
      tio.c_lflag &= 4294967279U;
    }
#line 137
    debug3("tty_parse_modes: %d %d", 54, arg);
#line 137
    break;
    case 55: 
#line 138
    n_bytes += arg_size;
#line 138
    tmp___41 = (*get_arg)();
#line 138
    arg = (int )tmp___41;
#line 138
    if (arg) {
#line 138
      tio.c_lflag |= 32U;
    } else {
#line 138
      tio.c_lflag &= 4294967263U;
    }
#line 138
    debug3("tty_parse_modes: %d %d", 55, arg);
#line 138
    break;
    case 56: 
#line 139
    n_bytes += arg_size;
#line 139
    tmp___42 = (*get_arg)();
#line 139
    arg = (int )tmp___42;
#line 139
    if (arg) {
#line 139
      tio.c_lflag |= 64U;
    } else {
#line 139
      tio.c_lflag &= 4294967231U;
    }
#line 139
    debug3("tty_parse_modes: %d %d", 56, arg);
#line 139
    break;
    case 57: 
#line 140
    n_bytes += arg_size;
#line 140
    tmp___43 = (*get_arg)();
#line 140
    arg = (int )tmp___43;
#line 140
    if (arg) {
#line 140
      tio.c_lflag |= 128U;
    } else {
#line 140
      tio.c_lflag &= 4294967167U;
    }
#line 140
    debug3("tty_parse_modes: %d %d", 57, arg);
#line 140
    break;
    case 58: 
#line 141
    n_bytes += arg_size;
#line 141
    tmp___44 = (*get_arg)();
#line 141
    arg = (int )tmp___44;
#line 141
    if (arg) {
#line 141
      tio.c_lflag |= 256U;
    } else {
#line 141
      tio.c_lflag &= 4294967039U;
    }
#line 141
    debug3("tty_parse_modes: %d %d", 58, arg);
#line 141
    break;
    case 59: 
#line 143
    n_bytes += arg_size;
#line 143
    tmp___45 = (*get_arg)();
#line 143
    arg = (int )tmp___45;
#line 143
    if (arg) {
#line 143
      tio.c_lflag |= 32768U;
    } else {
#line 143
      tio.c_lflag &= 4294934527U;
    }
#line 143
    debug3("tty_parse_modes: %d %d", 59, arg);
#line 143
    break;
    case 60: 
#line 146
    n_bytes += arg_size;
#line 146
    tmp___46 = (*get_arg)();
#line 146
    arg = (int )tmp___46;
#line 146
    if (arg) {
#line 146
      tio.c_lflag |= 512U;
    } else {
#line 146
      tio.c_lflag &= 4294966783U;
    }
#line 146
    debug3("tty_parse_modes: %d %d", 60, arg);
#line 146
    break;
    case 61: 
#line 149
    n_bytes += arg_size;
#line 149
    tmp___47 = (*get_arg)();
#line 149
    arg = (int )tmp___47;
#line 149
    if (arg) {
#line 149
      tio.c_lflag |= 2048U;
    } else {
#line 149
      tio.c_lflag &= 4294965247U;
    }
#line 149
    debug3("tty_parse_modes: %d %d", 61, arg);
#line 149
    break;
    case 62: 
#line 152
    n_bytes += arg_size;
#line 152
    tmp___48 = (*get_arg)();
#line 152
    arg = (int )tmp___48;
#line 152
    if (arg) {
#line 152
      tio.c_lflag |= 16384U;
    } else {
#line 152
      tio.c_lflag &= 4294950911U;
    }
#line 152
    debug3("tty_parse_modes: %d %d", 62, arg);
#line 152
    break;
    case 70: 
#line 155
    n_bytes += arg_size;
#line 155
    tmp___49 = (*get_arg)();
#line 155
    arg = (int )tmp___49;
#line 155
    if (arg) {
#line 155
      tio.c_oflag |= 1U;
    } else {
#line 155
      tio.c_oflag &= 4294967294U;
    }
#line 155
    debug3("tty_parse_modes: %d %d", 70, arg);
#line 155
    break;
    case 71: 
#line 157
    n_bytes += arg_size;
#line 157
    tmp___50 = (*get_arg)();
#line 157
    arg = (int )tmp___50;
#line 157
    if (arg) {
#line 157
      tio.c_oflag |= 2U;
    } else {
#line 157
      tio.c_oflag &= 4294967293U;
    }
#line 157
    debug3("tty_parse_modes: %d %d", 71, arg);
#line 157
    break;
    case 72: 
#line 160
    n_bytes += arg_size;
#line 160
    tmp___51 = (*get_arg)();
#line 160
    arg = (int )tmp___51;
#line 160
    if (arg) {
#line 160
      tio.c_oflag |= 4U;
    } else {
#line 160
      tio.c_oflag &= 4294967291U;
    }
#line 160
    debug3("tty_parse_modes: %d %d", 72, arg);
#line 160
    break;
    case 73: 
#line 163
    n_bytes += arg_size;
#line 163
    tmp___52 = (*get_arg)();
#line 163
    arg = (int )tmp___52;
#line 163
    if (arg) {
#line 163
      tio.c_oflag |= 8U;
    } else {
#line 163
      tio.c_oflag &= 4294967287U;
    }
#line 163
    debug3("tty_parse_modes: %d %d", 73, arg);
#line 163
    break;
    case 74: 
#line 166
    n_bytes += arg_size;
#line 166
    tmp___53 = (*get_arg)();
#line 166
    arg = (int )tmp___53;
#line 166
    if (arg) {
#line 166
      tio.c_oflag |= 16U;
    } else {
#line 166
      tio.c_oflag &= 4294967279U;
    }
#line 166
    debug3("tty_parse_modes: %d %d", 74, arg);
#line 166
    break;
    case 75: 
#line 169
    n_bytes += arg_size;
#line 169
    tmp___54 = (*get_arg)();
#line 169
    arg = (int )tmp___54;
#line 169
    if (arg) {
#line 169
      tio.c_oflag |= 32U;
    } else {
#line 169
      tio.c_oflag &= 4294967263U;
    }
#line 169
    debug3("tty_parse_modes: %d %d", 75, arg);
#line 169
    break;
    case 90: 
#line 172
    n_bytes += arg_size;
#line 172
    tmp___55 = (*get_arg)();
#line 172
    arg = (int )tmp___55;
#line 172
    if (arg) {
#line 172
      tio.c_cflag |= 32U;
    } else {
#line 172
      tio.c_cflag &= 4294967263U;
    }
#line 172
    debug3("tty_parse_modes: %d %d", 90, arg);
#line 172
    break;
    case 91: 
#line 173
    n_bytes += arg_size;
#line 173
    tmp___56 = (*get_arg)();
#line 173
    arg = (int )tmp___56;
#line 173
    if (arg) {
#line 173
      tio.c_cflag |= 48U;
    } else {
#line 173
      tio.c_cflag &= 4294967247U;
    }
#line 173
    debug3("tty_parse_modes: %d %d", 91, arg);
#line 173
    break;
    case 92: 
#line 174
    n_bytes += arg_size;
#line 174
    tmp___57 = (*get_arg)();
#line 174
    arg = (int )tmp___57;
#line 174
    if (arg) {
#line 174
      tio.c_cflag |= 256U;
    } else {
#line 174
      tio.c_cflag &= 4294967039U;
    }
#line 174
    debug3("tty_parse_modes: %d %d", 92, arg);
#line 174
    break;
    case 93: 
#line 175
    n_bytes += arg_size;
#line 175
    tmp___58 = (*get_arg)();
#line 175
    arg = (int )tmp___58;
#line 175
    if (arg) {
#line 175
      tio.c_cflag |= 512U;
    } else {
#line 175
      tio.c_cflag &= 4294966783U;
    }
#line 175
    debug3("tty_parse_modes: %d %d", 93, arg);
#line 175
    break;
    default: 
#line 423 "ttymodes.c"
    debug("Ignoring unsupported tty mode opcode %d (0x%x)", opcode, opcode);
#line 425
    if (! compat20) {
#line 433
      if (opcode > 0) {
#line 433
        if (opcode < 128) {
#line 434
          n_bytes ++;
#line 435
          packet_get_char();
#line 436
          break;
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 437
        if (opcode >= 128) {
#line 437
          if (opcode < 160) {
#line 438
            n_bytes += 4;
#line 439
            packet_get_int();
#line 440
            break;
          } else {
#line 449
            logit("parse_tty_modes: unknown opcode %d", opcode);
            goto set;
          }
        } else {
#line 449
          logit("parse_tty_modes: unknown opcode %d", opcode);
          goto set;
        }
      }
    } else {
#line 460
      if (opcode > 0) {
#line 460
        if (opcode < 160) {
#line 461
          n_bytes += 4;
#line 462
          packet_get_int();
#line 463
          break;
        } else {
#line 465
          logit("parse_tty_modes: unknown opcode %d", opcode);
          goto set;
        }
      } else {
#line 465
        logit("parse_tty_modes: unknown opcode %d", opcode);
        goto set;
      }
    }
    }
  }
  set: 
#line 473
  if (*n_bytes_ptr != n_bytes) {
#line 474
    *n_bytes_ptr = n_bytes;
#line 475
    logit("parse_tty_modes: n_bytes_ptr != n_bytes: %d %d", *n_bytes_ptr, n_bytes);
#line 477
    return;
  }
#line 479
  if (failure == -1) {
#line 480
    return;
  }
#line 483
  tmp___61 = tcsetattr(fd, 0, (struct termios  const  *)(& tio));
#line 483
  if (tmp___61 == -1) {
#line 484
    tmp___59 = __errno_location();
#line 484
    tmp___60 = strerror(*tmp___59);
#line 484
    logit("Setting tty modes failed: %.100s", tmp___60);
  }
#line 485
  return;
}
}
#line 1 "xmalloc.o"
#line 21 "xmalloc.c"
void *xmalloc(size_t size ) 
{ void *ptr ;

  {
#line 26
  if (size == 0U) {
#line 27
    fatal("xmalloc: zero size");
  }
#line 28
  ptr = malloc(size);
#line 29
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 30
    fatal("xmalloc: out of memory (allocating %lu bytes)", (unsigned long )size);
  }
#line 31
  return (ptr);
}
}
#line 34 "xmalloc.c"
void *xrealloc(void *ptr , size_t new_size ) 
{ void *new_ptr ;

  {
#line 39
  if (new_size == 0U) {
#line 40
    fatal("xrealloc: zero size");
  }
#line 41
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 42
    new_ptr = malloc(new_size);
  } else {
#line 44
    new_ptr = realloc(ptr, new_size);
  }
#line 45
  if ((unsigned int )new_ptr == (unsigned int )((void *)0)) {
#line 46
    fatal("xrealloc: out of memory (new_size %lu bytes)", (unsigned long )new_size);
  }
#line 47
  return (new_ptr);
}
}
#line 50 "xmalloc.c"
void xfree(void *ptr ) 
{ 

  {
#line 53
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 54
    fatal("xfree: NULL pointer given as argument");
  }
#line 55
  free(ptr);
#line 56
  return;
}
}
#line 58 "xmalloc.c"
char *xstrdup(char const   *str ) 
{ size_t len ;
  char *cp ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 64
  tmp = strlen(str);
#line 64
  len = tmp + 1U;
#line 65
  tmp___0 = xmalloc(len);
#line 65
  cp = (char *)tmp___0;
#line 66
  strlcpy(cp, str, len);
#line 67
  return (cp);
}
}
#line 1 "atomicio.o"
#line 35 "atomicio.c"
size_t atomicio(ssize_t (*f)(int  , void * , size_t  ) , int fd , void *_s , size_t n___0 ) 
{ char *s ;
  size_t pos ;
  ssize_t res ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 42
  s = (char *)_s;
#line 43
  pos = (size_t )0;
#line 46
  while (n___0 > pos) {
#line 47
    res = (*f)(fd, (void *)(s + pos), n___0 - pos);
#line 48
    switch (res) {
    case -1: 
#line 51
    tmp = __errno_location();
#line 51
    if (*tmp == 4) {
#line 55
      continue;
    } else {
#line 51
      tmp___0 = __errno_location();
#line 51
      if (*tmp___0 == 11) {
#line 55
        continue;
      } else {
#line 51
        tmp___1 = __errno_location();
#line 51
        if (*tmp___1 == 11) {
#line 55
          continue;
        }
      }
    }
#line 56
    return (0U);
    case 0: 
#line 58
    tmp___2 = __errno_location();
#line 58
    *tmp___2 = 32;
#line 59
    return (pos);
    default: 
#line 61
    pos += (unsigned int )res;
    }
  }
#line 64
  return (pos);
}
}
#line 1 "key.o"
#line 470 "/usr/include/openssl/crypto.h"
extern void CRYPTO_free(void * ) ;
#line 457 "/usr/include/openssl/bn.h"
extern int BN_cmp(BIGNUM const   *a , BIGNUM const   *b ) ;
#line 491
extern BIGNUM *BN_dup(BIGNUM const   *a ) ;
#line 496
extern char *BN_bn2dec(BIGNUM const   *a ) ;
#line 498
extern int BN_dec2bn(BIGNUM **a , char const   *str ) ;
#line 491 "/usr/include/openssl/evp.h"
extern int EVP_DigestUpdate(EVP_MD_CTX *ctx , void const   *d , size_t cnt ) ;
#line 498
extern int EVP_DigestInit(EVP_MD_CTX *ctx , EVP_MD const   *type ) ;
#line 499
extern int EVP_DigestFinal(EVP_MD_CTX *ctx , unsigned char *md , unsigned int *s ) ;
#line 593
extern EVP_MD const   *EVP_md5(void) ;
#line 215 "/usr/include/openssl/rsa.h"
extern RSA *RSA_new(void) ;
#line 221
extern RSA *RSA_generate_key(int bits , unsigned long e , void (*callback)(int  ,
                                                                           int  ,
                                                                           void * ) ,
                             void *cb_arg ) ;
#line 238
extern void RSA_free(RSA *r ) ;
#line 190 "/usr/include/openssl/dsa.h"
extern DSA *DSA_new(void) ;
#line 192
extern void DSA_free(DSA *r ) ;
#line 213
extern DSA *DSA_generate_parameters(int bits , unsigned char *seed , int seed_len ,
                                    int *counter_ret , unsigned long *h_ret , void (*callback)(int  ,
                                                                                               int  ,
                                                                                               void * ) ,
                                    void *cb_arg ) ;
#line 224
extern int DSA_generate_key(DSA *a ) ;
#line 61 "key.h"
Key *key_demote(Key const   *k ) ;
#line 63
char *key_fingerprint(Key const   *k , enum fp_type dgst_type , enum fp_rep dgst_rep ) ;
#line 64
u_char *key_fingerprint_raw(Key const   *k , enum fp_type dgst_type , u_int *dgst_raw_length ) ;
#line 70
Key *key_generate(int type , u_int bits ) ;
#line 71
Key *key_from_private(Key const   *k ) ;
#line 72
int key_type_from_name(char *name ) ;
#line 77
int key_names_valid2(char const   *names ) ;
#line 79
int key_sign(Key const   *key , u_char **sigp , u_int *lenp , u_char const   *data ,
             u_int datalen ) ;
#line 80
int key_verify(Key const   *key , u_char const   *signature , u_int signaturelen ,
               u_char const   *data , u_int datalen ) ;
#line 82
int ssh_dss_sign(Key const   *key , u_char **sigp , u_int *lenp , u_char const   *data ,
                 u_int datalen ) ;
#line 83
int ssh_dss_verify(Key const   *key , u_char const   *signature , u_int signaturelen ,
                   u_char const   *data , u_int datalen ) ;
#line 84
int ssh_rsa_sign(Key const   *key , u_char **sigp , u_int *lenp , u_char const   *data ,
                 u_int datalen ) ;
#line 85
int ssh_rsa_verify(Key const   *key , u_char const   *signature , u_int signaturelen ,
                   u_char const   *data , u_int datalen ) ;
#line 29 "uuencode.h"
int uuencode(u_char const   *src , u_int srclength , char *target , size_t targsize ) ;
#line 30
int uudecode(char const   *src , u_char *target , size_t targsize ) ;
#line 47 "key.c"
Key *key_new(int type ) 
{ Key *k ;
  RSA *rsa ;
  DSA *dsa ;
  void *tmp ;

  {
#line 53
  tmp = xmalloc(sizeof(*k));
#line 53
  k = (Key *)tmp;
#line 54
  k->type = type;
#line 55
  k->flags = 0;
#line 56
  k->dsa = (DSA *)((void *)0);
#line 57
  k->rsa = (RSA *)((void *)0);
#line 58
  switch (k->type) {
  case 0: 
  case 1: 
#line 61
  rsa = RSA_new();
#line 61
  if ((unsigned int )rsa == (unsigned int )((void *)0)) {
#line 62
    fatal("key_new: RSA_new failed");
  }
#line 63
  rsa->n = BN_new();
#line 63
  if ((unsigned int )rsa->n == (unsigned int )((void *)0)) {
#line 64
    fatal("key_new: BN_new failed");
  }
#line 65
  rsa->e = BN_new();
#line 65
  if ((unsigned int )rsa->e == (unsigned int )((void *)0)) {
#line 66
    fatal("key_new: BN_new failed");
  }
#line 67
  k->rsa = rsa;
#line 68
  break;
  case 2: 
#line 70
  dsa = DSA_new();
#line 70
  if ((unsigned int )dsa == (unsigned int )((void *)0)) {
#line 71
    fatal("key_new: DSA_new failed");
  }
#line 72
  dsa->p = BN_new();
#line 72
  if ((unsigned int )dsa->p == (unsigned int )((void *)0)) {
#line 73
    fatal("key_new: BN_new failed");
  }
#line 74
  dsa->q = BN_new();
#line 74
  if ((unsigned int )dsa->q == (unsigned int )((void *)0)) {
#line 75
    fatal("key_new: BN_new failed");
  }
#line 76
  dsa->g = BN_new();
#line 76
  if ((unsigned int )dsa->g == (unsigned int )((void *)0)) {
#line 77
    fatal("key_new: BN_new failed");
  }
#line 78
  dsa->pub_key = BN_new();
#line 78
  if ((unsigned int )dsa->pub_key == (unsigned int )((void *)0)) {
#line 79
    fatal("key_new: BN_new failed");
  }
#line 80
  k->dsa = dsa;
#line 81
  break;
  case 3: 
#line 83
  break;
  default: 
#line 85
  fatal("key_new: bad key type %d", k->type);
#line 86
  break;
  }
#line 88
  return (k);
}
}
#line 91 "key.c"
Key *key_new_private(int type ) 
{ Key *k ;
  Key *tmp ;

  {
#line 94
  tmp = key_new(type);
#line 94
  k = tmp;
#line 95
  switch (k->type) {
  case 0: 
  case 1: 
#line 98
  (k->rsa)->d = BN_new();
#line 98
  if ((unsigned int )(k->rsa)->d == (unsigned int )((void *)0)) {
#line 99
    fatal("key_new_private: BN_new failed");
  }
#line 100
  (k->rsa)->iqmp = BN_new();
#line 100
  if ((unsigned int )(k->rsa)->iqmp == (unsigned int )((void *)0)) {
#line 101
    fatal("key_new_private: BN_new failed");
  }
#line 102
  (k->rsa)->q = BN_new();
#line 102
  if ((unsigned int )(k->rsa)->q == (unsigned int )((void *)0)) {
#line 103
    fatal("key_new_private: BN_new failed");
  }
#line 104
  (k->rsa)->p = BN_new();
#line 104
  if ((unsigned int )(k->rsa)->p == (unsigned int )((void *)0)) {
#line 105
    fatal("key_new_private: BN_new failed");
  }
#line 106
  (k->rsa)->dmq1 = BN_new();
#line 106
  if ((unsigned int )(k->rsa)->dmq1 == (unsigned int )((void *)0)) {
#line 107
    fatal("key_new_private: BN_new failed");
  }
#line 108
  (k->rsa)->dmp1 = BN_new();
#line 108
  if ((unsigned int )(k->rsa)->dmp1 == (unsigned int )((void *)0)) {
#line 109
    fatal("key_new_private: BN_new failed");
  }
#line 110
  break;
  case 2: 
#line 112
  (k->dsa)->priv_key = BN_new();
#line 112
  if ((unsigned int )(k->dsa)->priv_key == (unsigned int )((void *)0)) {
#line 113
    fatal("key_new_private: BN_new failed");
  }
#line 114
  break;
  case 3: 
#line 116
  break;
  default: ;
#line 118
  break;
  }
#line 120
  return (k);
}
}
#line 123 "key.c"
void key_free(Key *k ) 
{ 

  {
#line 126
  switch (k->type) {
  case 0: 
  case 1: 
#line 129
  if ((unsigned int )k->rsa != (unsigned int )((void *)0)) {
#line 130
    RSA_free(k->rsa);
  }
#line 131
  k->rsa = (RSA *)((void *)0);
#line 132
  break;
  case 2: 
#line 134
  if ((unsigned int )k->dsa != (unsigned int )((void *)0)) {
#line 135
    DSA_free(k->dsa);
  }
#line 136
  k->dsa = (DSA *)((void *)0);
#line 137
  break;
  case 3: 
#line 139
  break;
  default: 
#line 141
  fatal("key_free: bad key type %d", k->type);
#line 142
  break;
  }
#line 144
  xfree((void *)k);
#line 145
  return;
}
}
#line 147 "key.c"
int key_equal(Key const   *a , Key const   *b ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 150
  if ((unsigned int )a == (unsigned int )((void *)0)) {
#line 151
    return (0);
  } else {
#line 150
    if ((unsigned int )b == (unsigned int )((void *)0)) {
#line 151
      return (0);
    } else {
#line 150
      if (a->type != b->type) {
#line 151
        return (0);
      }
    }
  }
#line 152
  switch ((int )a->type) {
  case 0: 
  case 1: 
#line 155
  if ((unsigned int )a->rsa != (unsigned int )((void *)0)) {
#line 155
    if ((unsigned int )b->rsa != (unsigned int )((void *)0)) {
#line 155
      tmp = BN_cmp((BIGNUM const   *)(a->rsa)->e, (BIGNUM const   *)(b->rsa)->e);
#line 155
      if (tmp == 0) {
#line 155
        tmp___0 = BN_cmp((BIGNUM const   *)(a->rsa)->n, (BIGNUM const   *)(b->rsa)->n);
#line 155
        if (tmp___0 == 0) {
#line 155
          tmp___1 = 1;
        } else {
#line 155
          tmp___1 = 0;
        }
      } else {
#line 155
        tmp___1 = 0;
      }
    } else {
#line 155
      tmp___1 = 0;
    }
  } else {
#line 155
    tmp___1 = 0;
  }
#line 155
  return (tmp___1);
#line 158
  break;
  case 2: 
#line 160
  if ((unsigned int )a->dsa != (unsigned int )((void *)0)) {
#line 160
    if ((unsigned int )b->dsa != (unsigned int )((void *)0)) {
#line 160
      tmp___2 = BN_cmp((BIGNUM const   *)(a->dsa)->p, (BIGNUM const   *)(b->dsa)->p);
#line 160
      if (tmp___2 == 0) {
#line 160
        tmp___3 = BN_cmp((BIGNUM const   *)(a->dsa)->q, (BIGNUM const   *)(b->dsa)->q);
#line 160
        if (tmp___3 == 0) {
#line 160
          tmp___4 = BN_cmp((BIGNUM const   *)(a->dsa)->g, (BIGNUM const   *)(b->dsa)->g);
#line 160
          if (tmp___4 == 0) {
#line 160
            tmp___5 = BN_cmp((BIGNUM const   *)(a->dsa)->pub_key, (BIGNUM const   *)(b->dsa)->pub_key);
#line 160
            if (tmp___5 == 0) {
#line 160
              tmp___6 = 1;
            } else {
#line 160
              tmp___6 = 0;
            }
          } else {
#line 160
            tmp___6 = 0;
          }
        } else {
#line 160
          tmp___6 = 0;
        }
      } else {
#line 160
        tmp___6 = 0;
      }
    } else {
#line 160
      tmp___6 = 0;
    }
  } else {
#line 160
    tmp___6 = 0;
  }
#line 160
  return (tmp___6);
#line 165
  break;
  default: 
#line 167
  fatal("key_equal: bad key type %d", a->type);
#line 168
  break;
  }
#line 170
  return (0);
}
}
#line 173 "key.c"
u_char *key_fingerprint_raw(Key const   *k , enum fp_type dgst_type , u_int *dgst_raw_length ) 
{ EVP_MD const   *md ;
  EVP_MD_CTX ctx ;
  u_char *blob ;
  u_char *retval ;
  u_int len ;
  int nlen ;
  int elen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 177
  md = (EVP_MD const   *)((void *)0);
#line 179
  blob = (u_char *)((void *)0);
#line 180
  retval = (u_char *)((void *)0);
#line 181
  len = (u_int )0;
#line 184
  *dgst_raw_length = 0U;
#line 186
  switch ((int )dgst_type) {
  case 1: 
#line 188
  md = EVP_md5();
#line 189
  break;
  case 0: 
#line 191
  md = EVP_sha1();
#line 192
  break;
  default: 
#line 194
  fatal("key_fingerprint_raw: bad digest type %d", dgst_type);
  }
#line 197
  switch ((int )k->type) {
  case 0: 
#line 199
  tmp = BN_num_bits((BIGNUM const   *)(k->rsa)->n);
#line 199
  nlen = (tmp + 7) / 8;
#line 200
  tmp___0 = BN_num_bits((BIGNUM const   *)(k->rsa)->e);
#line 200
  elen = (tmp___0 + 7) / 8;
#line 201
  len = (unsigned int )(nlen + elen);
#line 202
  tmp___1 = xmalloc(len);
#line 202
  blob = (u_char *)tmp___1;
#line 203
  BN_bn2bin((BIGNUM const   *)(k->rsa)->n, blob);
#line 204
  BN_bn2bin((BIGNUM const   *)(k->rsa)->e, blob + nlen);
#line 205
  break;
  case 2: 
  case 1: 
#line 208
  key_to_blob(k, & blob, & len);
#line 209
  break;
  case 3: 
#line 211
  return (retval);
#line 212
  break;
  default: 
#line 214
  fatal("key_fingerprint_raw: bad key type %d", k->type);
#line 215
  break;
  }
#line 217
  if ((unsigned int )blob != (unsigned int )((void *)0)) {
#line 218
    tmp___2 = xmalloc(64U);
#line 218
    retval = (u_char *)tmp___2;
#line 219
    EVP_DigestInit(& ctx, md);
#line 220
    EVP_DigestUpdate(& ctx, (void const   *)blob, len);
#line 221
    EVP_DigestFinal(& ctx, retval, dgst_raw_length);
#line 222
    memset((void *)blob, 0, len);
#line 223
    xfree((void *)blob);
  } else {
#line 225
    fatal("key_fingerprint_raw: blob is null");
  }
#line 227
  return (retval);
}
}
#line 230 "key.c"
static char *key_fingerprint_hex(u_char *dgst_raw , u_int dgst_raw_len ) 
{ char *retval ;
  u_int i ;
  void *tmp ;
  char hex[4] ;

  {
#line 236
  tmp = xmalloc(dgst_raw_len * 3U + 1U);
#line 236
  retval = (char *)tmp;
#line 237
  *(retval + 0) = (char )'\000';
#line 238
  i = 0U;
#line 238
  while (i < dgst_raw_len) {
#line 240
    snprintf((char * __restrict  )(hex), sizeof(hex), (char const   * __restrict  )"%02x:",
             *(dgst_raw + i));
#line 241
    strlcat(retval, (char const   *)(hex), dgst_raw_len * 3U + 1U);
#line 238
    i ++;
  }
#line 245
  *(retval + (dgst_raw_len * 3U - 1U)) = (char )'\000';
#line 246
  return (retval);
}
}
#line 249 "key.c"
static char *key_fingerprint_bubblebabble(u_char *dgst_raw , u_int dgst_raw_len ) 
{ char vowels[6] ;
  char consonants[17] ;
  u_int i ;
  u_int j ;
  u_int rounds ;
  u_int seed ;
  char *retval ;
  void *tmp ;
  u_int tmp___0 ;
  u_int idx0 ;
  u_int idx1 ;
  u_int idx2 ;
  u_int idx3 ;
  u_int idx4 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  u_int tmp___6 ;
  u_int tmp___7 ;
  u_int tmp___8 ;
  u_int tmp___9 ;
  u_int tmp___10 ;
  u_int tmp___11 ;

  {
#line 252
  vowels[0] = (char )'a';
#line 252
  vowels[1] = (char )'e';
#line 252
  vowels[2] = (char )'i';
#line 252
  vowels[3] = (char )'o';
#line 252
  vowels[4] = (char )'u';
#line 252
  vowels[5] = (char )'y';
#line 253
  consonants[0] = (char )'b';
#line 253
  consonants[1] = (char )'c';
#line 253
  consonants[2] = (char )'d';
#line 253
  consonants[3] = (char )'f';
#line 253
  consonants[4] = (char )'g';
#line 253
  consonants[5] = (char )'h';
#line 253
  consonants[6] = (char )'k';
#line 253
  consonants[7] = (char )'l';
#line 253
  consonants[8] = (char )'m';
#line 253
  consonants[9] = (char )'n';
#line 253
  consonants[10] = (char )'p';
#line 253
  consonants[11] = (char )'r';
#line 253
  consonants[12] = (char )'s';
#line 253
  consonants[13] = (char )'t';
#line 253
  consonants[14] = (char )'v';
#line 253
  consonants[15] = (char )'z';
#line 253
  consonants[16] = (char )'x';
#line 255
  j = (u_int )0;
#line 255
  seed = (u_int )1;
#line 258
  rounds = dgst_raw_len / 2U + 1U;
#line 259
  tmp = xmalloc(sizeof(char ) * (rounds * 6U));
#line 259
  retval = (char *)tmp;
#line 260
  tmp___0 = j;
#line 260
  j ++;
#line 260
  *(retval + tmp___0) = (char )'x';
#line 261
  i = 0U;
#line 261
  while (i < rounds) {
#line 263
    if (i + 1U < rounds) {
      goto _L;
    } else {
#line 263
      if (dgst_raw_len % 2U != 0U) {
        _L: /* CIL Label */ 
#line 264
        idx0 = ((((unsigned int )*(dgst_raw + 2U * i) >> 6) & 3U) + seed) % 6U;
#line 266
        idx1 = ((unsigned int )*(dgst_raw + 2U * i) >> 2) & 15U;
#line 267
        idx2 = (((unsigned int )*(dgst_raw + 2U * i) & 3U) + seed / 6U) % 6U;
#line 269
        tmp___1 = j;
#line 269
        j ++;
#line 269
        *(retval + tmp___1) = vowels[idx0];
#line 270
        tmp___2 = j;
#line 270
        j ++;
#line 270
        *(retval + tmp___2) = consonants[idx1];
#line 271
        tmp___3 = j;
#line 271
        j ++;
#line 271
        *(retval + tmp___3) = vowels[idx2];
#line 272
        if (i + 1U < rounds) {
#line 273
          idx3 = ((unsigned int )*(dgst_raw + (2U * i + 1U)) >> 4) & 15U;
#line 274
          idx4 = (unsigned int )*(dgst_raw + (2U * i + 1U)) & 15U;
#line 275
          tmp___4 = j;
#line 275
          j ++;
#line 275
          *(retval + tmp___4) = consonants[idx3];
#line 276
          tmp___5 = j;
#line 276
          j ++;
#line 276
          *(retval + tmp___5) = (char )'-';
#line 277
          tmp___6 = j;
#line 277
          j ++;
#line 277
          *(retval + tmp___6) = consonants[idx4];
#line 278
          seed = (seed * 5U + ((unsigned int )*(dgst_raw + 2U * i) * 7U + (unsigned int )*(dgst_raw + (2U * i + 1U)))) % 36U;
        }
      } else {
#line 283
        idx0 = seed % 6U;
#line 284
        idx1 = 16U;
#line 285
        idx2 = seed / 6U;
#line 286
        tmp___7 = j;
#line 286
        j ++;
#line 286
        *(retval + tmp___7) = vowels[idx0];
#line 287
        tmp___8 = j;
#line 287
        j ++;
#line 287
        *(retval + tmp___8) = consonants[idx1];
#line 288
        tmp___9 = j;
#line 288
        j ++;
#line 288
        *(retval + tmp___9) = vowels[idx2];
      }
    }
#line 261
    i ++;
  }
#line 291
  tmp___10 = j;
#line 291
  j ++;
#line 291
  *(retval + tmp___10) = (char )'x';
#line 292
  tmp___11 = j;
#line 292
  j ++;
#line 292
  *(retval + tmp___11) = (char )'\000';
#line 293
  return (retval);
}
}
#line 296 "key.c"
char *key_fingerprint(Key const   *k , enum fp_type dgst_type , enum fp_rep dgst_rep ) 
{ char *retval ;
  u_char *dgst_raw ;
  u_int dgst_raw_len ;

  {
#line 299
  retval = (char *)((void *)0);
#line 303
  dgst_raw = key_fingerprint_raw(k, dgst_type, & dgst_raw_len);
#line 304
  if (! dgst_raw) {
#line 305
    fatal("key_fingerprint: null from key_fingerprint_raw()");
  }
#line 306
  switch ((int )dgst_rep) {
  case 0: 
#line 308
  retval = key_fingerprint_hex(dgst_raw, dgst_raw_len);
#line 309
  break;
  case 1: 
#line 311
  retval = key_fingerprint_bubblebabble(dgst_raw, dgst_raw_len);
#line 312
  break;
  default: 
#line 314
  fatal("key_fingerprint_ex: bad digest representation %d", dgst_rep);
#line 316
  break;
  }
#line 318
  memset((void *)dgst_raw, 0, dgst_raw_len);
#line 319
  xfree((void *)dgst_raw);
#line 320
  return (retval);
}
}
#line 330 "key.c"
static int read_bignum(char **cpp , BIGNUM *value ) 
{ char *cp ;
  int old ;
  int tmp ;

  {
#line 333
  cp = *cpp;
#line 337
  while (1) {
#line 337
    if (! ((int )*cp == 32)) {
#line 337
      if (! ((int )*cp == 9)) {
#line 337
        break;
      }
    }
#line 337
    cp ++;
  }
#line 341
  if ((int )*cp < 48) {
#line 342
    return (0);
  } else {
#line 341
    if ((int )*cp > 57) {
#line 342
      return (0);
    }
  }
#line 345
  *cpp = cp;
#line 348
  while (1) {
#line 348
    if ((int )*cp >= 48) {
#line 348
      if (! ((int )*cp <= 57)) {
#line 348
        break;
      }
    } else {
#line 348
      break;
    }
#line 348
    cp ++;
  }
#line 352
  old = (int )*cp;
#line 353
  *cp = (char)0;
#line 356
  tmp = BN_dec2bn(& value, (char const   *)*cpp);
#line 356
  if (tmp == 0) {
#line 357
    return (0);
  }
#line 360
  *cp = (char )old;
#line 363
  *cpp = cp;
#line 364
  return (1);
}
}
#line 367 "key.c"
static int write_bignum(FILE *f , BIGNUM *num ) 
{ char *buf___1 ;
  char *tmp ;

  {
#line 370
  tmp = BN_bn2dec((BIGNUM const   *)num);
#line 370
  buf___1 = tmp;
#line 371
  if ((unsigned int )buf___1 == (unsigned int )((void *)0)) {
#line 372
    error("write_bignum: BN_bn2dec() failed");
#line 373
    return (0);
  }
#line 375
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )" %s", buf___1);
#line 376
  CRYPTO_free((void *)buf___1);
#line 377
  return (1);
}
}
#line 381 "key.c"
int key_read(Key *ret , char **cpp ) 
{ Key *k ;
  int success ;
  char *cp ;
  char *space ;
  int len ;
  int n___0 ;
  int type ;
  u_int bits ;
  u_char *blob ;
  int tmp ;
  int tmp___0 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
#line 385
  success = -1;
#line 391
  cp = *cpp;
#line 393
  switch (ret->type) {
  case 0: 
#line 396
  if ((int )*cp < 48) {
#line 397
    return (-1);
  } else {
#line 396
    if ((int )*cp > 57) {
#line 397
      return (-1);
    }
  }
#line 398
  bits = 0U;
#line 398
  while (1) {
#line 398
    if ((int )*cp >= 48) {
#line 398
      if (! ((int )*cp <= 57)) {
#line 398
        break;
      }
    } else {
#line 398
      break;
    }
#line 399
    bits = (10U * bits + (u_int )*cp) - 48U;
#line 398
    cp ++;
  }
#line 400
  if (bits == 0U) {
#line 401
    return (-1);
  }
#line 402
  *cpp = cp;
#line 404
  tmp = read_bignum(cpp, (ret->rsa)->e);
#line 404
  if (! tmp) {
#line 405
    return (-1);
  }
#line 406
  tmp___0 = read_bignum(cpp, (ret->rsa)->n);
#line 406
  if (! tmp___0) {
#line 407
    return (-1);
  }
#line 408
  success = 1;
#line 409
  break;
  case 3: 
  case 1: 
  case 2: 
#line 413
  tmp___2 = __builtin_strchr(cp, ' ');
#line 413
  space = tmp___2;
#line 414
  if ((unsigned int )space == (unsigned int )((void *)0)) {
#line 415
    debug3("key_read: missing whitespace");
#line 416
    return (-1);
  }
#line 418
  *space = (char )'\000';
#line 419
  type = key_type_from_name(cp);
#line 420
  *space = (char )' ';
#line 421
  if (type == 3) {
#line 422
    debug3("key_read: missing keytype");
#line 423
    return (-1);
  }
#line 425
  cp = space + 1;
#line 426
  if ((int )*cp == 0) {
#line 427
    debug3("key_read: short string");
#line 428
    return (-1);
  }
#line 430
  if (ret->type == 3) {
#line 431
    ret->type = type;
  } else {
#line 432
    if (ret->type != type) {
#line 434
      debug3("key_read: type mismatch");
#line 435
      return (-1);
    }
  }
#line 437
  tmp___3 = strlen((char const   *)cp);
#line 437
  len = (int )(2U * tmp___3);
#line 438
  tmp___4 = xmalloc((unsigned int )len);
#line 438
  blob = (u_char *)tmp___4;
#line 439
  n___0 = uudecode((char const   *)cp, blob, (unsigned int )len);
#line 440
  if (n___0 < 0) {
#line 441
    error("key_read: uudecode %s failed", cp);
#line 442
    xfree((void *)blob);
#line 443
    return (-1);
  }
#line 445
  k = key_from_blob((u_char const   *)blob, (unsigned int )n___0);
#line 446
  xfree((void *)blob);
#line 447
  if ((unsigned int )k == (unsigned int )((void *)0)) {
#line 448
    error("key_read: key_from_blob %s failed", cp);
#line 449
    return (-1);
  }
#line 451
  if (k->type != type) {
#line 452
    error("key_read: type mismatch: encoding error");
#line 453
    key_free(k);
#line 454
    return (-1);
  }
#line 457
  if (ret->type == 1) {
#line 458
    if ((unsigned int )ret->rsa != (unsigned int )((void *)0)) {
#line 459
      RSA_free(ret->rsa);
    }
#line 460
    ret->rsa = k->rsa;
#line 461
    k->rsa = (RSA *)((void *)0);
#line 462
    success = 1;
  } else {
#line 467
    if ((unsigned int )ret->dsa != (unsigned int )((void *)0)) {
#line 468
      DSA_free(ret->dsa);
    }
#line 469
    ret->dsa = k->dsa;
#line 470
    k->dsa = (DSA *)((void *)0);
#line 471
    success = 1;
  }
#line 477
  key_free(k);
#line 478
  if (success != 1) {
#line 479
    break;
  }
#line 481
  while (1) {
#line 481
    if (! ((int )*cp == 32)) {
#line 481
      if (! ((int )*cp == 9)) {
#line 481
        break;
      }
    }
#line 482
    cp ++;
  }
#line 483
  while (1) {
#line 483
    if ((int )*cp != 0) {
#line 483
      if ((int )*cp != 32) {
#line 483
        if (! ((int )*cp != 9)) {
#line 483
          break;
        }
      } else {
#line 483
        break;
      }
    } else {
#line 483
      break;
    }
#line 484
    cp ++;
  }
#line 485
  *cpp = cp;
#line 486
  break;
  default: 
#line 488
  fatal("key_read: bad key type: %d", ret->type);
#line 489
  break;
  }
#line 491
  return (success);
}
}
#line 494 "key.c"
int key_write(Key const   *key , FILE *f ) 
{ int n___0 ;
  int success ;
  u_int len ;
  u_int bits ;
  u_char *blob ;
  char *uu ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 497
  success = 0;
#line 498
  bits = (u_int )0;
#line 502
  if (key->type == 0) {
#line 502
    if ((unsigned int )key->rsa != (unsigned int )((void *)0)) {
#line 504
      tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 504
      bits = (unsigned int )tmp;
#line 505
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%u", bits);
#line 506
      tmp___0 = write_bignum(f, (key->rsa)->e);
#line 506
      if (tmp___0) {
#line 506
        tmp___1 = write_bignum(f, (key->rsa)->n);
#line 506
        if (tmp___1) {
#line 508
          success = 1;
        } else {
#line 510
          error("key_write: failed for RSA key");
        }
      } else {
#line 510
        error("key_write: failed for RSA key");
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 512
    if (key->type == 2) {
#line 512
      if ((unsigned int )key->dsa != (unsigned int )((void *)0)) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 512
      if (key->type == 1) {
#line 512
        if ((unsigned int )key->rsa != (unsigned int )((void *)0)) {
          _L: /* CIL Label */ 
#line 514
          key_to_blob(key, & blob, & len);
#line 515
          tmp___2 = xmalloc(2U * len);
#line 515
          uu = (char *)tmp___2;
#line 516
          n___0 = uuencode((u_char const   *)blob, len, uu, 2U * len);
#line 517
          if (n___0 > 0) {
#line 518
            tmp___3 = key_ssh_name(key);
#line 518
            fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s",
                    tmp___3, uu);
#line 519
            success = 1;
          }
#line 521
          xfree((void *)blob);
#line 522
          xfree((void *)uu);
        }
      }
    }
  }
#line 524
  return (success);
}
}
#line 527 "key.c"
char const   *key_type(Key const   *k ) 
{ 

  {
#line 530
  switch ((int )k->type) {
  case 0: 
#line 532
  return ("RSA1");
#line 533
  break;
  case 1: 
#line 535
  return ("RSA");
#line 536
  break;
  case 2: 
#line 538
  return ("DSA");
#line 539
  break;
  }
#line 541
  return ("unknown");
}
}
#line 544 "key.c"
char const   *key_ssh_name(Key const   *k ) 
{ 

  {
#line 547
  switch ((int )k->type) {
  case 1: 
#line 549
  return ("ssh-rsa");
#line 550
  break;
  case 2: 
#line 552
  return ("ssh-dss");
#line 553
  break;
  }
#line 555
  return ("ssh-unknown");
}
}
#line 558 "key.c"
u_int key_size(Key const   *k ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 561
  switch ((int )k->type) {
  case 0: 
  case 1: 
#line 564
  tmp = BN_num_bits((BIGNUM const   *)(k->rsa)->n);
#line 564
  return ((unsigned int )tmp);
#line 565
  break;
  case 2: 
#line 567
  tmp___0 = BN_num_bits((BIGNUM const   *)(k->dsa)->p);
#line 567
  return ((unsigned int )tmp___0);
#line 568
  break;
  }
#line 570
  return (0U);
}
}
#line 573 "key.c"
static RSA *rsa_generate_private_key(u_int bits ) 
{ RSA *private ;

  {
#line 577
  private = RSA_generate_key((int )bits, 35UL, (void (*)(int  , int  , void * ))((void *)0),
                             (void *)0);
#line 578
  if ((unsigned int )private == (unsigned int )((void *)0)) {
#line 579
    fatal("rsa_generate_private_key: key generation failed.");
  }
#line 580
  return (private);
}
}
#line 583 "key.c"
static DSA *dsa_generate_private_key(u_int bits ) 
{ DSA *private ;
  DSA *tmp ;
  int tmp___0 ;

  {
#line 586
  tmp = DSA_generate_parameters((int )bits, (unsigned char *)((void *)0), 0, (int *)((void *)0),
                                (unsigned long *)((void *)0), (void (*)(int  , int  ,
                                                                        void * ))((void *)0),
                                (void *)0);
#line 586
  private = tmp;
#line 587
  if ((unsigned int )private == (unsigned int )((void *)0)) {
#line 588
    fatal("dsa_generate_private_key: DSA_generate_parameters failed");
  }
#line 589
  tmp___0 = DSA_generate_key(private);
#line 589
  if (! tmp___0) {
#line 590
    fatal("dsa_generate_private_key: DSA_generate_key failed.");
  }
#line 591
  if ((unsigned int )private == (unsigned int )((void *)0)) {
#line 592
    fatal("dsa_generate_private_key: NULL.");
  }
#line 593
  return (private);
}
}
#line 596 "key.c"
Key *key_generate(int type , u_int bits ) 
{ Key *k ;
  Key *tmp ;

  {
#line 599
  tmp = key_new(3);
#line 599
  k = tmp;
#line 600
  switch (type) {
  case 2: 
#line 602
  k->dsa = dsa_generate_private_key(bits);
#line 603
  break;
  case 1: 
  case 0: 
#line 606
  k->rsa = rsa_generate_private_key(bits);
#line 607
  break;
  default: 
#line 609
  fatal("key_generate: unknown type %d", type);
  }
#line 611
  k->type = type;
#line 612
  return (k);
}
}
#line 615 "key.c"
Key *key_from_private(Key const   *k ) 
{ Key *n___0 ;

  {
#line 618
  n___0 = (Key *)((void *)0);
#line 619
  switch ((int )k->type) {
  case 2: 
#line 621
  n___0 = key_new((int )k->type);
#line 622
  BN_copy((n___0->dsa)->p, (BIGNUM const   *)(k->dsa)->p);
#line 623
  BN_copy((n___0->dsa)->q, (BIGNUM const   *)(k->dsa)->q);
#line 624
  BN_copy((n___0->dsa)->g, (BIGNUM const   *)(k->dsa)->g);
#line 625
  BN_copy((n___0->dsa)->pub_key, (BIGNUM const   *)(k->dsa)->pub_key);
#line 626
  break;
  case 1: 
  case 0: 
#line 629
  n___0 = key_new((int )k->type);
#line 630
  BN_copy((n___0->rsa)->n, (BIGNUM const   *)(k->rsa)->n);
#line 631
  BN_copy((n___0->rsa)->e, (BIGNUM const   *)(k->rsa)->e);
#line 632
  break;
  default: 
#line 634
  fatal("key_from_private: unknown type %d", k->type);
#line 635
  break;
  }
#line 637
  return (n___0);
}
}
#line 640 "key.c"
int key_type_from_name(char *name ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;

  {
#line 643
  if (0) {
#line 643
    __s1_len___3 = strlen((char const   *)name);
#line 643
    __s2_len___3 = strlen("rsa1");
#line 643
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___8;
    } else {
#line 643
      if (__s1_len___3 >= 4U) {
        _L___8: /* CIL Label */ 
#line 643
        if (! ((unsigned int )((void const   *)("rsa1" + 1)) - (unsigned int )((void const   *)"rsa1") == 1U)) {
#line 643
          tmp___48 = 1;
        } else {
#line 643
          if (__s2_len___3 >= 4U) {
#line 643
            tmp___48 = 1;
          } else {
#line 643
            tmp___48 = 0;
          }
        }
      } else {
#line 643
        tmp___48 = 0;
      }
    }
#line 643
    if (tmp___48) {
#line 643
      tmp___44 = __builtin_strcmp((char const   *)name, "rsa1");
    } else {
#line 643
      tmp___47 = __builtin_strcmp((char const   *)name, "rsa1");
#line 643
      tmp___44 = tmp___47;
    }
  } else {
#line 643
    tmp___47 = __builtin_strcmp((char const   *)name, "rsa1");
#line 643
    tmp___44 = tmp___47;
  }
#line 643
  if (tmp___44 == 0) {
#line 644
    return (0);
  } else {
#line 645
    if (0) {
#line 645
      __s1_len___2 = strlen((char const   *)name);
#line 645
      __s2_len___2 = strlen("rsa");
#line 645
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___6;
      } else {
#line 645
        if (__s1_len___2 >= 4U) {
          _L___6: /* CIL Label */ 
#line 645
          if (! ((unsigned int )((void const   *)("rsa" + 1)) - (unsigned int )((void const   *)"rsa") == 1U)) {
#line 645
            tmp___38 = 1;
          } else {
#line 645
            if (__s2_len___2 >= 4U) {
#line 645
              tmp___38 = 1;
            } else {
#line 645
              tmp___38 = 0;
            }
          }
        } else {
#line 645
          tmp___38 = 0;
        }
      }
#line 645
      if (tmp___38) {
#line 645
        tmp___34 = __builtin_strcmp((char const   *)name, "rsa");
      } else {
#line 645
        tmp___37 = __builtin_strcmp((char const   *)name, "rsa");
#line 645
        tmp___34 = tmp___37;
      }
    } else {
#line 645
      tmp___37 = __builtin_strcmp((char const   *)name, "rsa");
#line 645
      tmp___34 = tmp___37;
    }
#line 645
    if (tmp___34 == 0) {
#line 646
      return (1);
    } else {
#line 647
      if (0) {
#line 647
        __s1_len___1 = strlen((char const   *)name);
#line 647
        __s2_len___1 = strlen("dsa");
#line 647
        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
          goto _L___4;
        } else {
#line 647
          if (__s1_len___1 >= 4U) {
            _L___4: /* CIL Label */ 
#line 647
            if (! ((unsigned int )((void const   *)("dsa" + 1)) - (unsigned int )((void const   *)"dsa") == 1U)) {
#line 647
              tmp___28 = 1;
            } else {
#line 647
              if (__s2_len___1 >= 4U) {
#line 647
                tmp___28 = 1;
              } else {
#line 647
                tmp___28 = 0;
              }
            }
          } else {
#line 647
            tmp___28 = 0;
          }
        }
#line 647
        if (tmp___28) {
#line 647
          tmp___24 = __builtin_strcmp((char const   *)name, "dsa");
        } else {
#line 647
          tmp___27 = __builtin_strcmp((char const   *)name, "dsa");
#line 647
          tmp___24 = tmp___27;
        }
      } else {
#line 647
        tmp___27 = __builtin_strcmp((char const   *)name, "dsa");
#line 647
        tmp___24 = tmp___27;
      }
#line 647
      if (tmp___24 == 0) {
#line 648
        return (2);
      } else {
#line 649
        if (0) {
#line 649
          __s1_len___0 = strlen((char const   *)name);
#line 649
          __s2_len___0 = strlen("ssh-rsa");
#line 649
          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
            goto _L___2;
          } else {
#line 649
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 649
              if (! ((unsigned int )((void const   *)("ssh-rsa" + 1)) - (unsigned int )((void const   *)"ssh-rsa") == 1U)) {
#line 649
                tmp___18 = 1;
              } else {
#line 649
                if (__s2_len___0 >= 4U) {
#line 649
                  tmp___18 = 1;
                } else {
#line 649
                  tmp___18 = 0;
                }
              }
            } else {
#line 649
              tmp___18 = 0;
            }
          }
#line 649
          if (tmp___18) {
#line 649
            tmp___14 = __builtin_strcmp((char const   *)name, "ssh-rsa");
          } else {
#line 649
            tmp___17 = __builtin_strcmp((char const   *)name, "ssh-rsa");
#line 649
            tmp___14 = tmp___17;
          }
        } else {
#line 649
          tmp___17 = __builtin_strcmp((char const   *)name, "ssh-rsa");
#line 649
          tmp___14 = tmp___17;
        }
#line 649
        if (tmp___14 == 0) {
#line 650
          return (1);
        } else {
#line 651
          if (0) {
#line 651
            __s1_len = strlen((char const   *)name);
#line 651
            __s2_len = strlen("ssh-dss");
#line 651
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
              goto _L___0;
            } else {
#line 651
              if (__s1_len >= 4U) {
                _L___0: /* CIL Label */ 
#line 651
                if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
#line 651
                  tmp___8 = 1;
                } else {
#line 651
                  if (__s2_len >= 4U) {
#line 651
                    tmp___8 = 1;
                  } else {
#line 651
                    tmp___8 = 0;
                  }
                }
              } else {
#line 651
                tmp___8 = 0;
              }
            }
#line 651
            if (tmp___8) {
#line 651
              tmp___4 = __builtin_strcmp((char const   *)name, "ssh-dss");
            } else {
#line 651
              tmp___7 = __builtin_strcmp((char const   *)name, "ssh-dss");
#line 651
              tmp___4 = tmp___7;
            }
          } else {
#line 651
            tmp___7 = __builtin_strcmp((char const   *)name, "ssh-dss");
#line 651
            tmp___4 = tmp___7;
          }
#line 651
          if (tmp___4 == 0) {
#line 652
            return (2);
          }
        }
      }
    }
  }
#line 654
  debug2("key_type_from_name: unknown key type \'%s\'", name);
#line 655
  return (3);
}
}
#line 658 "key.c"
int key_names_valid2(char const   *names ) 
{ char *s ;
  char *cp ;
  char *p ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___24 ;
  char *tmp___40 ;
  int tmp___41 ;

  {
#line 663
  if ((unsigned int )names == (unsigned int )((void *)0)) {
#line 664
    return (0);
  } else {
#line 663
    if (0) {
#line 663
      __s1_len = strlen(names);
#line 663
      __s2_len = strlen("");
#line 663
      if (! ((unsigned int )((void const   *)(names + 1)) - (unsigned int )((void const   *)names) == 1U)) {
        goto _L___0;
      } else {
#line 663
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 663
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 663
            tmp___8 = 1;
          } else {
#line 663
            if (__s2_len >= 4U) {
#line 663
              tmp___8 = 1;
            } else {
#line 663
              tmp___8 = 0;
            }
          }
        } else {
#line 663
          tmp___8 = 0;
        }
      }
#line 663
      if (tmp___8) {
#line 663
        tmp___4 = __builtin_strcmp(names, "");
      } else {
#line 663
        tmp___7 = __builtin_strcmp(names, "");
#line 663
        tmp___4 = tmp___7;
      }
    } else {
#line 663
      tmp___7 = __builtin_strcmp(names, "");
#line 663
      tmp___4 = tmp___7;
    }
#line 663
    if (tmp___4 == 0) {
#line 664
      return (0);
    }
  }
#line 665
  cp = xstrdup(names);
#line 665
  s = cp;
#line 666
  tmp___24 = __strsep_g(& cp, ",");
#line 666
  p = tmp___24;
#line 666
  while (1) {
#line 666
    if (p) {
#line 666
      if (! ((int )*p != 0)) {
#line 666
        break;
      }
    } else {
#line 666
      break;
    }
#line 668
    tmp___41 = key_type_from_name(p);
#line 668
    switch (tmp___41) {
    case 0: 
    case 3: 
#line 671
    xfree((void *)s);
#line 672
    return (0);
    }
#line 667
    tmp___40 = __strsep_g(& cp, ",");
#line 667
    p = tmp___40;
  }
#line 675
  debug3("key names ok: [%s]", names);
#line 676
  xfree((void *)s);
#line 677
  return (1);
}
}
#line 680 "key.c"
Key *key_from_blob(u_char const   *blob , u_int blen ) 
{ Buffer b ;
  int rlen ;
  int type ;
  char *ktype ;
  Key *key ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  u_int tmp___6 ;

  {
#line 685
  ktype = (char *)((void *)0);
#line 686
  key = (Key *)((void *)0);
#line 691
  buffer_init(& b);
#line 692
  buffer_append(& b, (void const   *)blob, blen);
#line 693
  tmp = buffer_get_string_ret(& b, (u_int *)((void *)0));
#line 693
  ktype = (char *)tmp;
#line 693
  if ((unsigned int )ktype == (unsigned int )((void *)0)) {
#line 694
    error("key_from_blob: can\'t read key type");
    goto out;
  }
#line 698
  type = key_type_from_name(ktype);
#line 700
  switch (type) {
  case 1: 
#line 702
  key = key_new(type);
#line 703
  tmp___0 = buffer_get_bignum2_ret(& b, (key->rsa)->e);
#line 703
  if (tmp___0 == -1) {
#line 705
    error("key_from_blob: can\'t read rsa key");
#line 706
    key_free(key);
#line 707
    key = (Key *)((void *)0);
    goto out;
  } else {
#line 703
    tmp___1 = buffer_get_bignum2_ret(& b, (key->rsa)->n);
#line 703
    if (tmp___1 == -1) {
#line 705
      error("key_from_blob: can\'t read rsa key");
#line 706
      key_free(key);
#line 707
      key = (Key *)((void *)0);
      goto out;
    }
  }
#line 713
  break;
  case 2: 
#line 715
  key = key_new(type);
#line 716
  tmp___2 = buffer_get_bignum2_ret(& b, (key->dsa)->p);
#line 716
  if (tmp___2 == -1) {
#line 720
    error("key_from_blob: can\'t read dsa key");
#line 721
    key_free(key);
#line 722
    key = (Key *)((void *)0);
    goto out;
  } else {
#line 716
    tmp___3 = buffer_get_bignum2_ret(& b, (key->dsa)->q);
#line 716
    if (tmp___3 == -1) {
#line 720
      error("key_from_blob: can\'t read dsa key");
#line 721
      key_free(key);
#line 722
      key = (Key *)((void *)0);
      goto out;
    } else {
#line 716
      tmp___4 = buffer_get_bignum2_ret(& b, (key->dsa)->g);
#line 716
      if (tmp___4 == -1) {
#line 720
        error("key_from_blob: can\'t read dsa key");
#line 721
        key_free(key);
#line 722
        key = (Key *)((void *)0);
        goto out;
      } else {
#line 716
        tmp___5 = buffer_get_bignum2_ret(& b, (key->dsa)->pub_key);
#line 716
        if (tmp___5 == -1) {
#line 720
          error("key_from_blob: can\'t read dsa key");
#line 721
          key_free(key);
#line 722
          key = (Key *)((void *)0);
          goto out;
        }
      }
    }
  }
#line 728
  break;
  case 3: 
#line 730
  key = key_new(type);
#line 731
  break;
  default: 
#line 733
  error("key_from_blob: cannot handle type %s", ktype);
  goto out;
  }
#line 736
  tmp___6 = buffer_len(& b);
#line 736
  rlen = (int )tmp___6;
#line 737
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 737
    if (rlen != 0) {
#line 738
      error("key_from_blob: remaining bytes in key blob %d", rlen);
    }
  }
  out: 
#line 740
  if ((unsigned int )ktype != (unsigned int )((void *)0)) {
#line 741
    xfree((void *)ktype);
  }
#line 742
  buffer_free(& b);
#line 743
  return (key);
}
}
#line 746 "key.c"
int key_to_blob(Key const   *key , u_char **blobp , u_int *lenp ) 
{ Buffer b ;
  int len ;
  char const   *tmp ;
  char const   *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 752
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 753
    error("key_to_blob: key == NULL");
#line 754
    return (0);
  }
#line 756
  buffer_init(& b);
#line 757
  switch ((int )key->type) {
  case 2: 
#line 759
  tmp = key_ssh_name(key);
#line 759
  buffer_put_cstring(& b, tmp);
#line 760
  buffer_put_bignum2(& b, (BIGNUM const   *)(key->dsa)->p);
#line 761
  buffer_put_bignum2(& b, (BIGNUM const   *)(key->dsa)->q);
#line 762
  buffer_put_bignum2(& b, (BIGNUM const   *)(key->dsa)->g);
#line 763
  buffer_put_bignum2(& b, (BIGNUM const   *)(key->dsa)->pub_key);
#line 764
  break;
  case 1: 
#line 766
  tmp___0 = key_ssh_name(key);
#line 766
  buffer_put_cstring(& b, tmp___0);
#line 767
  buffer_put_bignum2(& b, (BIGNUM const   *)(key->rsa)->e);
#line 768
  buffer_put_bignum2(& b, (BIGNUM const   *)(key->rsa)->n);
#line 769
  break;
  default: 
#line 771
  error("key_to_blob: unsupported key type %d", key->type);
#line 772
  buffer_free(& b);
#line 773
  return (0);
  }
#line 775
  tmp___1 = buffer_len(& b);
#line 775
  len = (int )tmp___1;
#line 776
  if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 777
    *lenp = (unsigned int )len;
  }
#line 778
  if ((unsigned int )blobp != (unsigned int )((void *)0)) {
#line 779
    tmp___2 = xmalloc((unsigned int )len);
#line 779
    *blobp = (u_char *)tmp___2;
#line 780
    tmp___3 = buffer_ptr(& b);
#line 780
    memcpy((void * __restrict  )*blobp, (void const   * __restrict  )tmp___3, (unsigned int )len);
  }
#line 782
  tmp___4 = buffer_ptr(& b);
#line 782
  memset(tmp___4, 0, (unsigned int )len);
#line 783
  buffer_free(& b);
#line 784
  return (len);
}
}
#line 787 "key.c"
int key_sign(Key const   *key , u_char **sigp , u_int *lenp , u_char const   *data ,
             u_int datalen ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 793
  switch ((int )key->type) {
  case 2: 
#line 795
  tmp = ssh_dss_sign(key, sigp, lenp, data, datalen);
#line 795
  return (tmp);
#line 796
  break;
  case 1: 
#line 798
  tmp___0 = ssh_rsa_sign(key, sigp, lenp, data, datalen);
#line 798
  return (tmp___0);
#line 799
  break;
  default: 
#line 801
  error("key_sign: invalid key type %d", key->type);
#line 802
  return (-1);
#line 803
  break;
  }
#line 805
  return (0);
}
}
#line 811 "key.c"
int key_verify(Key const   *key , u_char const   *signature , u_int signaturelen ,
               u_char const   *data , u_int datalen ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 817
  if (signaturelen == 0U) {
#line 818
    return (-1);
  }
#line 820
  switch ((int )key->type) {
  case 2: 
#line 822
  tmp = ssh_dss_verify(key, signature, signaturelen, data, datalen);
#line 822
  return (tmp);
#line 823
  break;
  case 1: 
#line 825
  tmp___0 = ssh_rsa_verify(key, signature, signaturelen, data, datalen);
#line 825
  return (tmp___0);
#line 826
  break;
  default: 
#line 828
  error("key_verify: invalid key type %d", key->type);
#line 829
  return (-1);
#line 830
  break;
  }
#line 832
  return (0);
}
}
#line 835 "key.c"
Key *key_demote(Key const   *k ) 
{ Key *pk ;
  void *tmp ;

  {
#line 840
  tmp = xmalloc(sizeof(*pk));
#line 840
  pk = (Key *)tmp;
#line 841
  pk->type = (int )k->type;
#line 842
  pk->flags = (int )k->flags;
#line 843
  pk->dsa = (DSA *)((void *)0);
#line 844
  pk->rsa = (RSA *)((void *)0);
#line 846
  switch ((int )k->type) {
  case 0: 
  case 1: 
#line 849
  pk->rsa = RSA_new();
#line 849
  if ((unsigned int )pk->rsa == (unsigned int )((void *)0)) {
#line 850
    fatal("key_demote: RSA_new failed");
  }
#line 851
  (pk->rsa)->e = BN_dup((BIGNUM const   *)(k->rsa)->e);
#line 851
  if ((unsigned int )(pk->rsa)->e == (unsigned int )((void *)0)) {
#line 852
    fatal("key_demote: BN_dup failed");
  }
#line 853
  (pk->rsa)->n = BN_dup((BIGNUM const   *)(k->rsa)->n);
#line 853
  if ((unsigned int )(pk->rsa)->n == (unsigned int )((void *)0)) {
#line 854
    fatal("key_demote: BN_dup failed");
  }
#line 855
  break;
  case 2: 
#line 857
  pk->dsa = DSA_new();
#line 857
  if ((unsigned int )pk->dsa == (unsigned int )((void *)0)) {
#line 858
    fatal("key_demote: DSA_new failed");
  }
#line 859
  (pk->dsa)->p = BN_dup((BIGNUM const   *)(k->dsa)->p);
#line 859
  if ((unsigned int )(pk->dsa)->p == (unsigned int )((void *)0)) {
#line 860
    fatal("key_demote: BN_dup failed");
  }
#line 861
  (pk->dsa)->q = BN_dup((BIGNUM const   *)(k->dsa)->q);
#line 861
  if ((unsigned int )(pk->dsa)->q == (unsigned int )((void *)0)) {
#line 862
    fatal("key_demote: BN_dup failed");
  }
#line 863
  (pk->dsa)->g = BN_dup((BIGNUM const   *)(k->dsa)->g);
#line 863
  if ((unsigned int )(pk->dsa)->g == (unsigned int )((void *)0)) {
#line 864
    fatal("key_demote: BN_dup failed");
  }
#line 865
  (pk->dsa)->pub_key = BN_dup((BIGNUM const   *)(k->dsa)->pub_key);
#line 865
  if ((unsigned int )(pk->dsa)->pub_key == (unsigned int )((void *)0)) {
#line 866
    fatal("key_demote: BN_dup failed");
  }
#line 867
  break;
  default: 
#line 869
  fatal("key_free: bad key type %d", k->type);
#line 870
  break;
  }
#line 873
  return (pk);
}
}
#line 1 "dispatch.o"
#line 33 "dispatch.h"
void dispatch_init(dispatch_fn *dflt ) ;
#line 34
void dispatch_set(int type , dispatch_fn *fn ) ;
#line 35
void dispatch_range(u_int from , u_int to , dispatch_fn *fn ) ;
#line 36
void dispatch_run(int mode , int *done , void *ctxt ) ;
#line 37
void dispatch_protocol_error(int type , u_int32_t seq , void *ctxt ) ;
#line 38
void dispatch_protocol_ignore(int type , u_int32_t seq , void *ctxt ) ;
#line 37 "dispatch.c"
dispatch_fn *dispatch[255]  ;
#line 39 "dispatch.c"
void dispatch_protocol_error(int type , u_int32_t seq , void *ctxt ) 
{ 

  {
#line 42
  logit("dispatch_protocol_error: type %d seq %u", type, seq);
#line 43
  if (! compat20) {
#line 44
    fatal("protocol error");
  }
#line 45
  packet_start((unsigned char)3);
#line 46
  packet_put_int(seq);
#line 47
  packet_send();
#line 48
  packet_write_wait();
#line 49
  return;
}
}
#line 50 "dispatch.c"
void dispatch_protocol_ignore(int type , u_int32_t seq , void *ctxt ) 
{ 

  {
#line 53
  logit("dispatch_protocol_ignore: type %d seq %u", type, seq);
#line 54
  return;
}
}
#line 55 "dispatch.c"
void dispatch_init(dispatch_fn *dflt ) 
{ u_int i ;

  {
#line 59
  i = 0U;
#line 59
  while (i < 255U) {
#line 60
    dispatch[i] = dflt;
#line 59
    i ++;
  }
#line 61
  return;
}
}
#line 62 "dispatch.c"
void dispatch_range(u_int from , u_int to , dispatch_fn *fn ) 
{ u_int i ;

  {
#line 67
  i = from;
#line 67
  while (i <= to) {
#line 68
    if (i >= 255U) {
#line 69
      break;
    }
#line 70
    dispatch[i] = fn;
#line 67
    i ++;
  }
#line 72
  return;
}
}
#line 73 "dispatch.c"
void dispatch_set(int type , dispatch_fn *fn ) 
{ 

  {
#line 76
  dispatch[type] = fn;
#line 77
  return;
}
}
#line 78 "dispatch.c"
void dispatch_run(int mode , int *done , void *ctxt ) 
{ int type ;
  u_int32_t seqnr ;

  {
#line 81
  while (1) {
#line 85
    if (mode == 0) {
#line 86
      type = packet_read_seqnr(& seqnr);
    } else {
#line 88
      type = packet_read_poll_seqnr(& seqnr);
#line 89
      if (type == 0) {
#line 90
        return;
      }
    }
#line 92
    if (type > 0) {
#line 92
      if (type < 255) {
#line 92
        if ((unsigned int )dispatch[type] != (unsigned int )((void *)0)) {
#line 93
          (*(dispatch[type]))(type, seqnr, ctxt);
        } else {
#line 95
          packet_disconnect("protocol error: rcvd type %d", type);
        }
      } else {
#line 95
        packet_disconnect("protocol error: rcvd type %d", type);
      }
    } else {
#line 95
      packet_disconnect("protocol error: rcvd type %d", type);
    }
#line 96
    if ((unsigned int )done != (unsigned int )((void *)0)) {
#line 96
      if (*done) {
#line 97
        return;
      }
    }
  }
}
}
#line 1 "kex.o"
#line 126 "kex.h"
Kex *kex_setup(char **proposal ) ;
#line 127
void kex_finish(Kex *kex ) ;
#line 129
void kex_send_kexinit(Kex *kex ) ;
#line 130
void kex_input_kexinit(int type , u_int32_t seq , void *ctxt ) ;
#line 131
void kex_derive_keys(Kex *kex , u_char *hash , u_int hashlen , BIGNUM *shared_secret ) ;
#line 148
void derive_ssh1_session_id(BIGNUM *host_modulus , BIGNUM *server_modulus , u_int8_t *cookie ,
                            u_int8_t *id ) ;
#line 27 "mac.h"
int mac_init(Mac *mac , char *name ) ;
#line 48 "kex.c"
static void kex_kexinit_finish(Kex *kex ) ;
#line 49
static void kex_choose_conf(Kex *kex ) ;
#line 52 "kex.c"
static void kex_prop2buf(Buffer *b , char **proposal ) 
{ u_int i ;

  {
#line 57
  buffer_clear(b);
#line 62
  i = 0U;
#line 62
  while (i < 16U) {
#line 63
    buffer_put_char(b, 0);
#line 62
    i ++;
  }
#line 64
  i = 0U;
#line 64
  while (i < 10U) {
#line 65
    buffer_put_cstring(b, (char const   *)*(proposal + i));
#line 64
    i ++;
  }
#line 66
  buffer_put_char(b, 0);
#line 67
  buffer_put_int(b, 0U);
#line 68
  return;
}
}
#line 71 "kex.c"
static char **kex_buf2prop(Buffer *raw , int *first_kex_follows ) 
{ Buffer b ;
  int i ;
  char **proposal ;
  void *tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  u_int tmp___3 ;

  {
#line 78
  tmp = xmalloc(10U * sizeof(char *));
#line 78
  proposal = (char **)tmp;
#line 80
  buffer_init(& b);
#line 81
  tmp___0 = buffer_len(raw);
#line 81
  tmp___1 = buffer_ptr(raw);
#line 81
  buffer_append(& b, (void const   *)tmp___1, tmp___0);
#line 83
  i = 0;
#line 83
  while (i < 16) {
#line 84
    buffer_get_char(& b);
#line 83
    i ++;
  }
#line 86
  i = 0;
#line 86
  while (i < 10) {
#line 87
    tmp___2 = buffer_get_string(& b, (u_int *)((void *)0));
#line 87
    *(proposal + i) = (char *)tmp___2;
#line 88
    debug2("kex_parse_kexinit: %s", *(proposal + i));
#line 86
    i ++;
  }
#line 91
  i = buffer_get_char(& b);
#line 92
  if ((unsigned int )first_kex_follows != (unsigned int )((void *)0)) {
#line 93
    *first_kex_follows = i;
  }
#line 94
  debug2("kex_parse_kexinit: first_kex_follows %d ", i);
#line 95
  tmp___3 = buffer_get_int(& b);
#line 95
  i = (int )tmp___3;
#line 96
  debug2("kex_parse_kexinit: reserved %d ", i);
#line 97
  buffer_free(& b);
#line 98
  return (proposal);
}
}
#line 101 "kex.c"
static void kex_prop_free(char **proposal ) 
{ u_int i ;

  {
#line 106
  i = 0U;
#line 106
  while (i < 10U) {
#line 107
    xfree((void *)*(proposal + i));
#line 106
    i ++;
  }
#line 108
  xfree((void *)proposal);
#line 109
  return;
}
}
#line 111 "kex.c"
static void kex_protocol_error(int type , u_int32_t seq , void *ctxt ) 
{ 

  {
#line 114
  error("Hm, kex protocol error: type %d seq %u", type, seq);
#line 115
  return;
}
}
#line 117 "kex.c"
static void kex_reset_dispatch(void) 
{ 

  {
#line 120
  dispatch_range(1U, 49U, & kex_protocol_error);
#line 122
  dispatch_set(20, & kex_input_kexinit);
#line 123
  return;
}
}
#line 125 "kex.c"
void kex_finish(Kex *kex ) 
{ int _len ;
  int tmp ;

  {
#line 128
  kex_reset_dispatch();
#line 130
  packet_start((unsigned char)21);
#line 131
  packet_send();
#line 133
  debug("SSH2_MSG_NEWKEYS sent");
#line 135
  debug("expecting SSH2_MSG_NEWKEYS");
#line 136
  packet_read_expect(21);
#line 137
  while (1) {
#line 137
    tmp = packet_remaining();
#line 137
    _len = tmp;
#line 137
    if (_len > 0) {
#line 137
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kex.c",
            137);
#line 137
      packet_disconnect("Packet integrity error.");
    }
#line 137
    break;
  }
#line 138
  debug("SSH2_MSG_NEWKEYS received");
#line 140
  kex->done = 1;
#line 141
  buffer_clear(& kex->peer);
#line 143
  kex->flags &= -2;
#line 144
  xfree((void *)kex->name);
#line 145
  kex->name = (char *)((void *)0);
#line 146
  return;
}
}
#line 148 "kex.c"
void kex_send_kexinit(Kex *kex ) 
{ u_int32_t rnd ;
  u_char *cookie ;
  u_int i ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;

  {
#line 151
  rnd = (u_int32_t )0;
#line 155
  if ((unsigned int )kex == (unsigned int )((void *)0)) {
#line 156
    error("kex_send_kexinit: no kex, cannot rekey");
#line 157
    return;
  }
#line 159
  if (kex->flags & 1) {
#line 160
    debug("KEX_INIT_SENT");
#line 161
    return;
  }
#line 163
  kex->done = 0;
#line 166
  tmp = buffer_len(& kex->my);
#line 166
  if (tmp < 16U) {
#line 167
    fatal("kex_send_kexinit: kex proposal too short");
  }
#line 168
  tmp___0 = buffer_ptr(& kex->my);
#line 168
  cookie = (u_char *)tmp___0;
#line 169
  i = 0U;
#line 169
  while (i < 16U) {
#line 170
    if (i % 4U == 0U) {
#line 171
      rnd = arc4random();
    }
#line 172
    *(cookie + i) = (unsigned char )rnd;
#line 173
    rnd >>= 8;
#line 169
    i ++;
  }
#line 175
  packet_start((unsigned char)20);
#line 176
  tmp___1 = buffer_len(& kex->my);
#line 176
  tmp___2 = buffer_ptr(& kex->my);
#line 176
  packet_put_raw((void const   *)tmp___2, tmp___1);
#line 177
  packet_send();
#line 178
  debug("SSH2_MSG_KEXINIT sent");
#line 179
  kex->flags |= 1;
#line 180
  return;
}
}
#line 182 "kex.c"
void kex_input_kexinit(int type , u_int32_t seq , void *ctxt ) 
{ char *ptr ;
  u_int i ;
  u_int dlen ;
  Kex *kex ;
  void *tmp ;
  void *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 187
  kex = (Kex *)ctxt;
#line 189
  debug("SSH2_MSG_KEXINIT received");
#line 190
  if ((unsigned int )kex == (unsigned int )((void *)0)) {
#line 191
    fatal("kex_input_kexinit: no kex, cannot rekey");
  }
#line 193
  tmp = packet_get_raw(& dlen);
#line 193
  ptr = (char *)tmp;
#line 194
  buffer_append(& kex->peer, (void const   *)ptr, dlen);
#line 197
  i = 0U;
#line 197
  while (i < 16U) {
#line 198
    packet_get_char();
#line 197
    i ++;
  }
#line 199
  i = 0U;
#line 199
  while (i < 10U) {
#line 200
    tmp___0 = packet_get_string((u_int *)((void *)0));
#line 200
    xfree(tmp___0);
#line 199
    i ++;
  }
#line 201
  packet_get_char();
#line 202
  packet_get_int();
#line 203
  while (1) {
#line 203
    tmp___1 = packet_remaining();
#line 203
    _len = tmp___1;
#line 203
    if (_len > 0) {
#line 203
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kex.c",
            203);
#line 203
      packet_disconnect("Packet integrity error.");
    }
#line 203
    break;
  }
#line 205
  kex_kexinit_finish(kex);
#line 206
  return;
}
}
#line 208 "kex.c"
Kex *kex_setup(char **proposal ) 
{ Kex *kex ;
  void *tmp ;

  {
#line 213
  tmp = xmalloc(sizeof(*kex));
#line 213
  kex = (Kex *)tmp;
#line 214
  memset((void *)kex, 0, sizeof(*kex));
#line 215
  buffer_init(& kex->peer);
#line 216
  buffer_init(& kex->my);
#line 217
  kex_prop2buf(& kex->my, proposal);
#line 218
  kex->done = 0;
#line 220
  kex_send_kexinit(kex);
#line 221
  kex_reset_dispatch();
#line 223
  return (kex);
}
}
#line 226 "kex.c"
static void kex_kexinit_finish(Kex *kex ) 
{ 

  {
#line 229
  if (! (kex->flags & 1)) {
#line 230
    kex_send_kexinit(kex);
  }
#line 232
  kex_choose_conf(kex);
#line 234
  if (kex->kex_type >= 0) {
#line 234
    if (kex->kex_type < 3) {
#line 234
      if ((unsigned int )kex->kex[kex->kex_type] != (unsigned int )((void *)0)) {
#line 236
        (*(kex->kex[kex->kex_type]))(kex);
      } else {
#line 238
        fatal("Unsupported key exchange %d", kex->kex_type);
      }
    } else {
#line 238
      fatal("Unsupported key exchange %d", kex->kex_type);
    }
  } else {
#line 238
    fatal("Unsupported key exchange %d", kex->kex_type);
  }
#line 240
  return;
}
}
#line 242 "kex.c"
static void choose_enc(Enc *enc , char *client , char *server ) 
{ char *name ;
  char *tmp ;

  {
#line 245
  tmp = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 245
  name = tmp;
#line 246
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 247
    fatal("no matching cipher found: client %s server %s", client, server);
  }
#line 248
  enc->cipher = cipher_by_name((char const   *)name);
#line 248
  if ((unsigned int )enc->cipher == (unsigned int )((void *)0)) {
#line 249
    fatal("matching cipher is not supported: %s", name);
  }
#line 250
  enc->name = name;
#line 251
  enc->enabled = 0;
#line 252
  enc->iv = (u_char *)((void *)0);
#line 253
  enc->key = (u_char *)((void *)0);
#line 254
  enc->key_len = cipher_keylen((Cipher const   *)enc->cipher);
#line 255
  enc->block_size = cipher_blocksize((Cipher const   *)enc->cipher);
#line 256
  return;
}
}
#line 257 "kex.c"
static void choose_mac(Mac *mac , char *client , char *server ) 
{ char *name ;
  char *tmp ;
  int tmp___0 ;

  {
#line 260
  tmp = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 260
  name = tmp;
#line 261
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 262
    fatal("no matching mac found: client %s server %s", client, server);
  }
#line 263
  tmp___0 = mac_init(mac, name);
#line 263
  if (tmp___0 < 0) {
#line 264
    fatal("unsupported mac %s", name);
  }
#line 266
  if (datafellows & 4) {
#line 267
    mac->key_len = 16U;
  }
#line 268
  mac->name = name;
#line 269
  mac->key = (u_char *)((void *)0);
#line 270
  mac->enabled = 0;
#line 271
  return;
}
}
#line 272 "kex.c"
static void choose_comp(Comp *comp , char *client , char *server ) 
{ char *name ;
  char *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___25 ;
  int tmp___28 ;
  int tmp___29 ;

  {
#line 275
  tmp = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 275
  name = tmp;
#line 276
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 277
    fatal("no matching comp found: client %s server %s", client, server);
  }
#line 278
  if (0) {
#line 278
    __s1_len___1 = strlen((char const   *)name);
#line 278
    __s2_len___1 = strlen("zlib@openssh.com");
#line 278
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___4;
    } else {
#line 278
      if (__s1_len___1 >= 4U) {
        _L___4: /* CIL Label */ 
#line 278
        if (! ((unsigned int )((void const   *)("zlib@openssh.com" + 1)) - (unsigned int )((void const   *)"zlib@openssh.com") == 1U)) {
#line 278
          tmp___29 = 1;
        } else {
#line 278
          if (__s2_len___1 >= 4U) {
#line 278
            tmp___29 = 1;
          } else {
#line 278
            tmp___29 = 0;
          }
        }
      } else {
#line 278
        tmp___29 = 0;
      }
    }
#line 278
    if (tmp___29) {
#line 278
      tmp___25 = __builtin_strcmp((char const   *)name, "zlib@openssh.com");
    } else {
#line 278
      tmp___28 = __builtin_strcmp((char const   *)name, "zlib@openssh.com");
#line 278
      tmp___25 = tmp___28;
    }
  } else {
#line 278
    tmp___28 = __builtin_strcmp((char const   *)name, "zlib@openssh.com");
#line 278
    tmp___25 = tmp___28;
  }
#line 278
  if (tmp___25 == 0) {
#line 279
    comp->type = 2;
  } else {
#line 280
    if (0) {
#line 280
      __s1_len___0 = strlen((char const   *)name);
#line 280
      __s2_len___0 = strlen("zlib");
#line 280
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___2;
      } else {
#line 280
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 280
          if (! ((unsigned int )((void const   *)("zlib" + 1)) - (unsigned int )((void const   *)"zlib") == 1U)) {
#line 280
            tmp___19 = 1;
          } else {
#line 280
            if (__s2_len___0 >= 4U) {
#line 280
              tmp___19 = 1;
            } else {
#line 280
              tmp___19 = 0;
            }
          }
        } else {
#line 280
          tmp___19 = 0;
        }
      }
#line 280
      if (tmp___19) {
#line 280
        tmp___15 = __builtin_strcmp((char const   *)name, "zlib");
      } else {
#line 280
        tmp___18 = __builtin_strcmp((char const   *)name, "zlib");
#line 280
        tmp___15 = tmp___18;
      }
    } else {
#line 280
      tmp___18 = __builtin_strcmp((char const   *)name, "zlib");
#line 280
      tmp___15 = tmp___18;
    }
#line 280
    if (tmp___15 == 0) {
#line 281
      comp->type = 1;
    } else {
#line 282
      if (0) {
#line 282
        __s1_len = strlen((char const   *)name);
#line 282
        __s2_len = strlen("none");
#line 282
        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
          goto _L___0;
        } else {
#line 282
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 282
            if (! ((unsigned int )((void const   *)("none" + 1)) - (unsigned int )((void const   *)"none") == 1U)) {
#line 282
              tmp___9 = 1;
            } else {
#line 282
              if (__s2_len >= 4U) {
#line 282
                tmp___9 = 1;
              } else {
#line 282
                tmp___9 = 0;
              }
            }
          } else {
#line 282
            tmp___9 = 0;
          }
        }
#line 282
        if (tmp___9) {
#line 282
          tmp___5 = __builtin_strcmp((char const   *)name, "none");
        } else {
#line 282
          tmp___8 = __builtin_strcmp((char const   *)name, "none");
#line 282
          tmp___5 = tmp___8;
        }
      } else {
#line 282
        tmp___8 = __builtin_strcmp((char const   *)name, "none");
#line 282
        tmp___5 = tmp___8;
      }
#line 282
      if (tmp___5 == 0) {
#line 283
        comp->type = 0;
      } else {
#line 285
        fatal("unsupported comp %s", name);
      }
    }
  }
#line 287
  comp->name = name;
#line 288
  return;
}
}
#line 289 "kex.c"
static void choose_kex(Kex *k , char *client , char *server ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;

  {
#line 292
  k->name = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 293
  if ((unsigned int )k->name == (unsigned int )((void *)0)) {
#line 294
    fatal("no kex alg");
  }
#line 295
  if (0) {
#line 295
    __s1_len___1 = strlen((char const   *)k->name);
#line 295
    __s2_len___1 = strlen("diffie-hellman-group1-sha1");
#line 295
    if (! ((unsigned int )((void const   *)(k->name + 1)) - (unsigned int )((void const   *)k->name) == 1U)) {
      goto _L___4;
    } else {
#line 295
      if (__s1_len___1 >= 4U) {
        _L___4: /* CIL Label */ 
#line 295
        if (! ((unsigned int )((void const   *)("diffie-hellman-group1-sha1" + 1)) - (unsigned int )((void const   *)"diffie-hellman-group1-sha1") == 1U)) {
#line 295
          tmp___28 = 1;
        } else {
#line 295
          if (__s2_len___1 >= 4U) {
#line 295
            tmp___28 = 1;
          } else {
#line 295
            tmp___28 = 0;
          }
        }
      } else {
#line 295
        tmp___28 = 0;
      }
    }
#line 295
    if (tmp___28) {
#line 295
      tmp___24 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
    } else {
#line 295
      tmp___27 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
#line 295
      tmp___24 = tmp___27;
    }
  } else {
#line 295
    tmp___27 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
#line 295
    tmp___24 = tmp___27;
  }
#line 295
  if (tmp___24 == 0) {
#line 296
    k->kex_type = 0;
#line 297
    k->evp_md = EVP_sha1();
  } else {
#line 298
    if (0) {
#line 298
      __s1_len___0 = strlen((char const   *)k->name);
#line 298
      __s2_len___0 = strlen("diffie-hellman-group14-sha1");
#line 298
      if (! ((unsigned int )((void const   *)(k->name + 1)) - (unsigned int )((void const   *)k->name) == 1U)) {
        goto _L___2;
      } else {
#line 298
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 298
          if (! ((unsigned int )((void const   *)("diffie-hellman-group14-sha1" + 1)) - (unsigned int )((void const   *)"diffie-hellman-group14-sha1") == 1U)) {
#line 298
            tmp___18 = 1;
          } else {
#line 298
            if (__s2_len___0 >= 4U) {
#line 298
              tmp___18 = 1;
            } else {
#line 298
              tmp___18 = 0;
            }
          }
        } else {
#line 298
          tmp___18 = 0;
        }
      }
#line 298
      if (tmp___18) {
#line 298
        tmp___14 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group14-sha1");
      } else {
#line 298
        tmp___17 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group14-sha1");
#line 298
        tmp___14 = tmp___17;
      }
    } else {
#line 298
      tmp___17 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group14-sha1");
#line 298
      tmp___14 = tmp___17;
    }
#line 298
    if (tmp___14 == 0) {
#line 299
      k->kex_type = 1;
#line 300
      k->evp_md = EVP_sha1();
    } else {
#line 301
      if (0) {
#line 301
        __s1_len = strlen((char const   *)k->name);
#line 301
        __s2_len = strlen("diffie-hellman-group-exchange-sha1");
#line 301
        if (! ((unsigned int )((void const   *)(k->name + 1)) - (unsigned int )((void const   *)k->name) == 1U)) {
          goto _L___0;
        } else {
#line 301
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 301
            if (! ((unsigned int )((void const   *)("diffie-hellman-group-exchange-sha1" + 1)) - (unsigned int )((void const   *)"diffie-hellman-group-exchange-sha1") == 1U)) {
#line 301
              tmp___8 = 1;
            } else {
#line 301
              if (__s2_len >= 4U) {
#line 301
                tmp___8 = 1;
              } else {
#line 301
                tmp___8 = 0;
              }
            }
          } else {
#line 301
            tmp___8 = 0;
          }
        }
#line 301
        if (tmp___8) {
#line 301
          tmp___4 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha1");
        } else {
#line 301
          tmp___7 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha1");
#line 301
          tmp___4 = tmp___7;
        }
      } else {
#line 301
        tmp___7 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha1");
#line 301
        tmp___4 = tmp___7;
      }
#line 301
      if (tmp___4 == 0) {
#line 302
        k->kex_type = 2;
#line 303
        k->evp_md = EVP_sha1();
      } else {
#line 305
        fatal("bad kex alg %s", k->name);
      }
    }
  }
#line 306
  return;
}
}
#line 308 "kex.c"
static void choose_hostkeyalg(Kex *k , char *client , char *server ) 
{ char *hostkeyalg ;
  char *tmp ;

  {
#line 311
  tmp = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 311
  hostkeyalg = tmp;
#line 312
  if ((unsigned int )hostkeyalg == (unsigned int )((void *)0)) {
#line 313
    fatal("no hostkey alg");
  }
#line 314
  k->hostkey_type = key_type_from_name(hostkeyalg);
#line 315
  if (k->hostkey_type == 3) {
#line 316
    fatal("bad hostkey alg \'%s\'", hostkeyalg);
  }
#line 317
  xfree((void *)hostkeyalg);
#line 318
  return;
}
}
#line 323
static int proposals_match(char **my , char **peer ) ;
#line 323 "kex.c"
static int check___0[3]  = {      0,      1,      -1};
#line 320 "kex.c"
static int proposals_match(char **my , char **peer ) 
{ int *idx ;
  char *p ;
  char *tmp___0 ;
  char *tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 329
  idx = check___0;
#line 329
  while (*idx != -1) {
#line 330
    tmp___0 = __builtin_strchr(*(my + *idx), ',');
#line 330
    p = tmp___0;
#line 330
    if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 331
      *p = (char )'\000';
    }
#line 332
    tmp___2 = __builtin_strchr(*(peer + *idx), ',');
#line 332
    p = tmp___2;
#line 332
    if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 333
      *p = (char )'\000';
    }
#line 334
    if (0) {
#line 334
      __s1_len = strlen((char const   *)*(my + *idx));
#line 334
      __s2_len = strlen((char const   *)*(peer + *idx));
#line 334
      if (! ((unsigned int )((void const   *)(*(my + *idx) + 1)) - (unsigned int )((void const   *)*(my + *idx)) == 1U)) {
        goto _L___0;
      } else {
#line 334
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 334
          if (! ((unsigned int )((void const   *)(*(peer + *idx) + 1)) - (unsigned int )((void const   *)*(peer + *idx)) == 1U)) {
#line 334
            tmp___12 = 1;
          } else {
#line 334
            if (__s2_len >= 4U) {
#line 334
              tmp___12 = 1;
            } else {
#line 334
              tmp___12 = 0;
            }
          }
        } else {
#line 334
          tmp___12 = 0;
        }
      }
#line 334
      if (tmp___12) {
#line 334
        tmp___8 = __builtin_strcmp((char const   *)*(my + *idx), (char const   *)*(peer + *idx));
      } else {
#line 334
        tmp___11 = __builtin_strcmp((char const   *)*(my + *idx), (char const   *)*(peer + *idx));
#line 334
        tmp___8 = tmp___11;
      }
    } else {
#line 334
      tmp___11 = __builtin_strcmp((char const   *)*(my + *idx), (char const   *)*(peer + *idx));
#line 334
      tmp___8 = tmp___11;
    }
#line 334
    if (tmp___8 != 0) {
#line 335
      debug2("proposal mismatch: my %s peer %s", *(my + *idx), *(peer + *idx));
#line 337
      return (0);
    }
#line 329
    idx ++;
  }
#line 340
  debug2("proposals match");
#line 341
  return (1);
}
}
#line 344 "kex.c"
static void kex_choose_conf(Kex *kex ) 
{ Newkeys *newkeys___0 ;
  char **my ;
  char **peer ;
  char **cprop ;
  char **sprop ;
  int nenc ;
  int nmac ;
  int ncomp ;
  u_int mode ;
  u_int ctos ;
  u_int need ;
  int first_kex_follows ;
  int type ;
  void *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 354
  my = kex_buf2prop(& kex->my, (int *)((void *)0));
#line 355
  peer = kex_buf2prop(& kex->peer, & first_kex_follows);
#line 357
  if (kex->server) {
#line 358
    cprop = peer;
#line 359
    sprop = my;
  } else {
#line 361
    cprop = my;
#line 362
    sprop = peer;
  }
#line 366
  mode = 0U;
#line 366
  while (mode < 2U) {
#line 367
    tmp = xmalloc(sizeof(*newkeys___0));
#line 367
    newkeys___0 = (Newkeys *)tmp;
#line 368
    memset((void *)newkeys___0, 0, sizeof(*newkeys___0));
#line 369
    kex->newkeys[mode] = newkeys___0;
#line 370
    if (! kex->server) {
#line 370
      if (mode == 1U) {
#line 370
        tmp___0 = 1;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 370
      if (kex->server) {
#line 370
        if (mode == 0U) {
#line 370
          tmp___0 = 1;
        } else {
#line 370
          tmp___0 = 0;
        }
      } else {
#line 370
        tmp___0 = 0;
      }
    }
#line 370
    ctos = (unsigned int )tmp___0;
#line 371
    if (ctos) {
#line 371
      nenc = 2;
    } else {
#line 371
      nenc = 3;
    }
#line 372
    if (ctos) {
#line 372
      nmac = 4;
    } else {
#line 372
      nmac = 5;
    }
#line 373
    if (ctos) {
#line 373
      ncomp = 6;
    } else {
#line 373
      ncomp = 7;
    }
#line 374
    choose_enc(& newkeys___0->enc, *(cprop + nenc), *(sprop + nenc));
#line 375
    choose_mac(& newkeys___0->mac, *(cprop + nmac), *(sprop + nmac));
#line 376
    choose_comp(& newkeys___0->comp, *(cprop + ncomp), *(sprop + ncomp));
#line 377
    if (ctos) {
#line 377
      tmp___1 = "client->server";
    } else {
#line 377
      tmp___1 = "server->client";
    }
#line 377
    debug("kex: %s %s %s %s", tmp___1, newkeys___0->enc.name, newkeys___0->mac.name,
          newkeys___0->comp.name);
#line 366
    mode ++;
  }
#line 383
  choose_kex(kex, *(cprop + 0), *(sprop + 0));
#line 384
  choose_hostkeyalg(kex, *(cprop + 1), *(sprop + 1));
#line 386
  need = 0U;
#line 387
  mode = 0U;
#line 387
  while (mode < 2U) {
#line 388
    newkeys___0 = kex->newkeys[mode];
#line 389
    if (need < newkeys___0->enc.key_len) {
#line 390
      need = newkeys___0->enc.key_len;
    }
#line 391
    if (need < newkeys___0->enc.block_size) {
#line 392
      need = newkeys___0->enc.block_size;
    }
#line 393
    if (need < newkeys___0->mac.key_len) {
#line 394
      need = newkeys___0->mac.key_len;
    }
#line 387
    mode ++;
  }
#line 397
  kex->we_need = need;
#line 400
  if (first_kex_follows) {
#line 400
    tmp___2 = proposals_match((char **)my, (char **)peer);
#line 400
    if (! tmp___2) {
#line 400
      if (! (datafellows & 8388608)) {
#line 402
        type = packet_read();
#line 403
        debug2("skipping next packet (type %u)", type);
      }
    }
  }
#line 406
  kex_prop_free(my);
#line 407
  kex_prop_free(peer);
#line 408
  return;
}
}
#line 410 "kex.c"
static u_char *derive_key(Kex *kex , int id , u_int need , u_char *hash , u_int hashlen ,
                          BIGNUM *shared_secret ) 
{ Buffer b ;
  EVP_MD_CTX md ;
  char c ;
  u_int have ;
  int mdsz ;
  u_char *digest___1 ;
  void *tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  u_int tmp___2 ;
  void *tmp___3 ;

  {
#line 416
  c = (char )id;
#line 421
  mdsz = (int )(kex->evp_md)->md_size;
#line 421
  if (mdsz <= 0) {
#line 422
    fatal("bad kex md size %d", mdsz);
  }
#line 423
  tmp = xmalloc(((need + (u_int )(mdsz - 1)) / (u_int )mdsz) * (u_int )mdsz);
#line 423
  digest___1 = (u_char *)tmp;
#line 425
  buffer_init(& b);
#line 426
  buffer_put_bignum2(& b, (BIGNUM const   *)shared_secret);
#line 429
  EVP_DigestInit(& md, kex->evp_md);
#line 430
  if (! (datafellows & 262144)) {
#line 431
    tmp___0 = buffer_len(& b);
#line 431
    tmp___1 = buffer_ptr(& b);
#line 431
    EVP_DigestUpdate(& md, (void const   *)tmp___1, tmp___0);
  }
#line 432
  EVP_DigestUpdate(& md, (void const   *)hash, hashlen);
#line 433
  EVP_DigestUpdate(& md, (void const   *)(& c), 1U);
#line 434
  EVP_DigestUpdate(& md, (void const   *)kex->session_id, kex->session_id_len);
#line 435
  EVP_DigestFinal(& md, digest___1, (unsigned int *)((void *)0));
#line 442
  have = (unsigned int )mdsz;
#line 442
  while (need > have) {
#line 443
    EVP_DigestInit(& md, kex->evp_md);
#line 444
    if (! (datafellows & 262144)) {
#line 445
      tmp___2 = buffer_len(& b);
#line 445
      tmp___3 = buffer_ptr(& b);
#line 445
      EVP_DigestUpdate(& md, (void const   *)tmp___3, tmp___2);
    }
#line 446
    EVP_DigestUpdate(& md, (void const   *)hash, hashlen);
#line 447
    EVP_DigestUpdate(& md, (void const   *)digest___1, have);
#line 448
    EVP_DigestFinal(& md, digest___1 + have, (unsigned int *)((void *)0));
#line 442
    have += (u_int )mdsz;
  }
#line 450
  buffer_free(& b);
#line 455
  return (digest___1);
}
}
#line 458 "kex.c"
Newkeys *current_keys[2]  ;
#line 461 "kex.c"
void kex_derive_keys(Kex *kex , u_char *hash , u_int hashlen , BIGNUM *shared_secret ) 
{ u_char *keys[6] ;
  u_int i ;
  u_int mode ;
  u_int ctos ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 467
  i = 0U;
#line 467
  while (i < 6U) {
#line 468
    keys[i] = derive_key(kex, (int )(65U + i), kex->we_need, hash, hashlen, shared_secret);
#line 467
    i ++;
  }
#line 472
  debug2("kex_derive_keys");
#line 473
  mode = 0U;
#line 473
  while (mode < 2U) {
#line 474
    current_keys[mode] = kex->newkeys[mode];
#line 475
    kex->newkeys[mode] = (Newkeys *)((void *)0);
#line 476
    if (! kex->server) {
#line 476
      if (mode == 1U) {
#line 476
        tmp = 1;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 476
      if (kex->server) {
#line 476
        if (mode == 0U) {
#line 476
          tmp = 1;
        } else {
#line 476
          tmp = 0;
        }
      } else {
#line 476
        tmp = 0;
      }
    }
#line 476
    ctos = (unsigned int )tmp;
#line 477
    if (ctos) {
#line 477
      tmp___0 = 0;
    } else {
#line 477
      tmp___0 = 1;
    }
#line 477
    (current_keys[mode])->enc.iv = keys[tmp___0];
#line 478
    if (ctos) {
#line 478
      tmp___1 = 2;
    } else {
#line 478
      tmp___1 = 3;
    }
#line 478
    (current_keys[mode])->enc.key = keys[tmp___1];
#line 479
    if (ctos) {
#line 479
      tmp___2 = 4;
    } else {
#line 479
      tmp___2 = 5;
    }
#line 479
    (current_keys[mode])->mac.key = keys[tmp___2];
#line 473
    mode ++;
  }
#line 481
  return;
}
}
#line 483 "kex.c"
Newkeys *kex_get_newkeys(int mode ) 
{ Newkeys *ret ;

  {
#line 488
  ret = current_keys[mode];
#line 489
  current_keys[mode] = (Newkeys *)((void *)0);
#line 490
  return (ret);
}
}
#line 493 "kex.c"
void derive_ssh1_session_id(BIGNUM *host_modulus , BIGNUM *server_modulus , u_int8_t *cookie ,
                            u_int8_t *id ) 
{ EVP_MD const   *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  u_int8_t nbuf[2048] ;
  u_int8_t obuf[64] ;
  int len ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 497
  tmp = EVP_md5();
#line 497
  evp_md = tmp;
#line 502
  EVP_DigestInit(& md, evp_md);
#line 504
  tmp___0 = BN_num_bits((BIGNUM const   *)host_modulus);
#line 504
  len = (tmp___0 + 7) / 8;
#line 505
  if (len < 64) {
#line 506
    fatal("%s: bad host modulus (len %d)", "derive_ssh1_session_id", len);
  } else {
#line 505
    if ((unsigned int )len > sizeof(nbuf)) {
#line 506
      fatal("%s: bad host modulus (len %d)", "derive_ssh1_session_id", len);
    }
  }
#line 507
  BN_bn2bin((BIGNUM const   *)host_modulus, nbuf);
#line 508
  EVP_DigestUpdate(& md, (void const   *)(nbuf), (unsigned int )len);
#line 510
  tmp___1 = BN_num_bits((BIGNUM const   *)server_modulus);
#line 510
  len = (tmp___1 + 7) / 8;
#line 511
  if (len < 64) {
#line 512
    fatal("%s: bad server modulus (len %d)", "derive_ssh1_session_id", len);
  } else {
#line 511
    if ((unsigned int )len > sizeof(nbuf)) {
#line 512
      fatal("%s: bad server modulus (len %d)", "derive_ssh1_session_id", len);
    }
  }
#line 513
  BN_bn2bin((BIGNUM const   *)server_modulus, nbuf);
#line 514
  EVP_DigestUpdate(& md, (void const   *)(nbuf), (unsigned int )len);
#line 516
  EVP_DigestUpdate(& md, (void const   *)cookie, 8U);
#line 518
  EVP_DigestFinal(& md, obuf, (unsigned int *)((void *)0));
#line 519
  memcpy((void * __restrict  )id, (void const   * __restrict  )(obuf), 16U);
#line 521
  memset((void *)(nbuf), 0, sizeof(nbuf));
#line 522
  memset((void *)(obuf), 0, sizeof(obuf));
#line 523
  memset((void *)(& md), 0, sizeof(md));
#line 524
  return;
}
}
#line 1 "mac.o"
#line 611 "/usr/include/openssl/evp.h"
extern EVP_MD const   *EVP_ripemd160(void) ;
#line 26 "mac.h"
int mac_valid(char const   *names ) ;
#line 37 "mac.c"
struct __anonstruct_macs_81 macs[7]  = {      {(char *)"hmac-sha1", & EVP_sha1, 0}, 
        {(char *)"hmac-sha1-96", & EVP_sha1, 96}, 
        {(char *)"hmac-md5", & EVP_md5, 0}, 
        {(char *)"hmac-md5-96", & EVP_md5, 96}, 
        {(char *)"hmac-ripemd160", & EVP_ripemd160, 0}, 
        {(char *)"hmac-ripemd160@openssh.com", & EVP_ripemd160, 0}, 
        {(char *)((void *)0), (EVP_MD const   *(*)(void))((void *)0), 0}};
#line 51 "mac.c"
int mac_init(Mac *mac , char *name ) 
{ int i ;
  int evp_len ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 56
  i = 0;
#line 56
  while (macs[i].name) {
#line 57
    if (0) {
#line 57
      __s1_len = strlen((char const   *)name);
#line 57
      __s2_len = strlen((char const   *)macs[i].name);
#line 57
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___0;
      } else {
#line 57
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 57
          if (! ((unsigned int )((void const   *)(macs[i].name + 1)) - (unsigned int )((void const   *)macs[i].name) == 1U)) {
#line 57
            tmp___8 = 1;
          } else {
#line 57
            if (__s2_len >= 4U) {
#line 57
              tmp___8 = 1;
            } else {
#line 57
              tmp___8 = 0;
            }
          }
        } else {
#line 57
          tmp___8 = 0;
        }
      }
#line 57
      if (tmp___8) {
#line 57
        tmp___4 = __builtin_strcmp((char const   *)name, (char const   *)macs[i].name);
      } else {
#line 57
        tmp___7 = __builtin_strcmp((char const   *)name, (char const   *)macs[i].name);
#line 57
        tmp___4 = tmp___7;
      }
    } else {
#line 57
      tmp___7 = __builtin_strcmp((char const   *)name, (char const   *)macs[i].name);
#line 57
      tmp___4 = tmp___7;
    }
#line 57
    if (tmp___4 == 0) {
#line 58
      if ((unsigned int )mac != (unsigned int )((void *)0)) {
#line 59
        mac->md = (*(macs[i].mdfunc))();
#line 60
        evp_len = (int )(mac->md)->md_size;
#line 60
        if (evp_len <= 0) {
#line 61
          fatal("mac %s len %d", name, evp_len);
        }
#line 62
        mac->mac_len = (unsigned int )evp_len;
#line 62
        mac->key_len = mac->mac_len;
#line 63
        if (macs[i].truncatebits != 0) {
#line 64
          mac->mac_len = (unsigned int )(macs[i].truncatebits / 8);
        }
      }
#line 66
      debug2("mac_init: found %s", name);
#line 67
      return (0);
    }
#line 56
    i ++;
  }
#line 70
  debug2("mac_init: unknown %s", name);
#line 71
  return (-1);
}
}
#line 78 "mac.c"
static u_char m[64]  ;
#line 74 "mac.c"
u_char *mac_compute(Mac *mac , u_int32_t seqno , u_char *data , int datalen ) 
{ HMAC_CTX c ;
  u_char b[4] ;

  {
#line 81
  if ((unsigned int )mac->key == (unsigned int )((void *)0)) {
#line 82
    fatal("mac_compute: no key");
  }
#line 83
  if (mac->mac_len > sizeof(m)) {
#line 84
    fatal("mac_compute: mac too long");
  }
#line 85
  HMAC_Init(& c, (void const   *)mac->key, (int )mac->key_len, mac->md);
#line 86
  while (1) {
#line 86
    b[0] = (unsigned char )(seqno >> 24);
#line 86
    b[1] = (unsigned char )(seqno >> 16);
#line 86
    b[2] = (unsigned char )(seqno >> 8);
#line 86
    b[3] = (unsigned char )seqno;
#line 86
    break;
  }
#line 87
  HMAC_Update(& c, (unsigned char const   *)(b), sizeof(b));
#line 88
  HMAC_Update(& c, (unsigned char const   *)data, (unsigned int )datalen);
#line 89
  HMAC_Final(& c, m, (unsigned int *)((void *)0));
#line 90
  HMAC_CTX_cleanup(& c);
#line 91
  return (m);
}
}
#line 96 "mac.c"
int mac_valid(char const   *names ) 
{ char *maclist ;
  char *cp ;
  char *p ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___24 ;
  char *tmp___40 ;
  int tmp___41 ;

  {
#line 101
  if ((unsigned int )names == (unsigned int )((void *)0)) {
#line 102
    return (0);
  } else {
#line 101
    if (0) {
#line 101
      __s1_len = strlen(names);
#line 101
      __s2_len = strlen("");
#line 101
      if (! ((unsigned int )((void const   *)(names + 1)) - (unsigned int )((void const   *)names) == 1U)) {
        goto _L___0;
      } else {
#line 101
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 101
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 101
            tmp___8 = 1;
          } else {
#line 101
            if (__s2_len >= 4U) {
#line 101
              tmp___8 = 1;
            } else {
#line 101
              tmp___8 = 0;
            }
          }
        } else {
#line 101
          tmp___8 = 0;
        }
      }
#line 101
      if (tmp___8) {
#line 101
        tmp___4 = __builtin_strcmp(names, "");
      } else {
#line 101
        tmp___7 = __builtin_strcmp(names, "");
#line 101
        tmp___4 = tmp___7;
      }
    } else {
#line 101
      tmp___7 = __builtin_strcmp(names, "");
#line 101
      tmp___4 = tmp___7;
    }
#line 101
    if (tmp___4 == 0) {
#line 102
      return (0);
    }
  }
#line 103
  cp = xstrdup(names);
#line 103
  maclist = cp;
#line 104
  tmp___24 = __strsep_g(& cp, ",");
#line 104
  p = tmp___24;
#line 104
  while (1) {
#line 104
    if (p) {
#line 104
      if (! ((int )*p != 0)) {
#line 104
        break;
      }
    } else {
#line 104
      break;
    }
#line 106
    tmp___41 = mac_init((Mac *)((void *)0), p);
#line 106
    if (tmp___41 < 0) {
#line 107
      debug("bad mac %s [%s]", p, names);
#line 108
      xfree((void *)maclist);
#line 109
      return (0);
    } else {
#line 111
      debug3("mac ok: %s [%s]", p, names);
    }
#line 105
    tmp___40 = __strsep_g(& cp, ",");
#line 105
    p = tmp___40;
  }
#line 114
  debug3("macs ok: [%s]", names);
#line 115
  xfree((void *)maclist);
#line 116
  return (1);
}
}
#line 1 "uidswap.o"
#line 178 "/usr/include/grp.h"
extern  __attribute__((__nothrow__)) int setgroups(size_t __n , __gid_t const   *__groups ) ;
#line 199
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 648 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
#line 651
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 656
extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t *__list ) ;
#line 684
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 694
extern  __attribute__((__nothrow__)) int setegid(__gid_t __gid ) ;
#line 710
extern  __attribute__((__nothrow__)) int setresuid(__uid_t __ruid , __uid_t __euid ,
                                                   __uid_t __suid ) ;
#line 715
extern  __attribute__((__nothrow__)) int setresgid(__gid_t __rgid , __gid_t __egid ,
                                                   __gid_t __sgid ) ;
#line 18 "uidswap.h"
void temporarily_use_uid(struct passwd *pw ) ;
#line 19
void restore_uid(void) ;
#line 20
void permanently_set_uid(struct passwd *pw ) ;
#line 35 "uidswap.c"
static uid_t saved_euid  =    (uid_t )0;
#line 36 "uidswap.c"
static gid_t saved_egid  =    (gid_t )0;
#line 40 "uidswap.c"
static int privileged  =    0;
#line 41 "uidswap.c"
static int temporarily_use_uid_effective  =    0;
#line 42 "uidswap.c"
static gid_t *saved_egroups  =    (gid_t *)((void *)0);
#line 42 "uidswap.c"
static gid_t *user_groups  =    (gid_t *)((void *)0);
#line 43 "uidswap.c"
static int saved_egroupslen  =    -1;
#line 43 "uidswap.c"
static int user_groupslen  =    -1;
#line 49 "uidswap.c"
void temporarily_use_uid(struct passwd *pw ) 
{ int *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  void *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;

  {
#line 54
  saved_euid = geteuid();
#line 55
  saved_egid = getegid();
#line 56
  debug("temporarily_use_uid: %u/%u (e=%u/%u)", pw->pw_uid, pw->pw_gid, saved_euid,
        saved_egid);
#line 60
  if (saved_euid != 0U) {
#line 61
    privileged = 0;
#line 62
    return;
  }
#line 72
  privileged = 1;
#line 73
  temporarily_use_uid_effective = 1;
#line 75
  saved_egroupslen = getgroups(0, (__gid_t *)((void *)0));
#line 76
  if (saved_egroupslen < 0) {
#line 77
    tmp = __errno_location();
#line 77
    tmp___0 = strerror(*tmp);
#line 77
    fatal("getgroups: %.100s", tmp___0);
  }
#line 78
  if (saved_egroupslen > 0) {
#line 79
    tmp___1 = xrealloc((void *)saved_egroups, (unsigned int )saved_egroupslen * sizeof(gid_t ));
#line 79
    saved_egroups = (gid_t *)tmp___1;
#line 81
    tmp___4 = getgroups(saved_egroupslen, saved_egroups);
#line 81
    if (tmp___4 < 0) {
#line 82
      tmp___2 = __errno_location();
#line 82
      tmp___3 = strerror(*tmp___2);
#line 82
      fatal("getgroups: %.100s", tmp___3);
    }
  } else {
#line 84
    if ((unsigned int )saved_egroups != (unsigned int )((void *)0)) {
#line 85
      xfree((void *)saved_egroups);
    }
  }
#line 89
  if (user_groupslen == -1) {
#line 90
    tmp___7 = initgroups((char const   *)pw->pw_name, pw->pw_gid);
#line 90
    if (tmp___7 < 0) {
#line 91
      tmp___5 = __errno_location();
#line 91
      tmp___6 = strerror(*tmp___5);
#line 91
      fatal("initgroups: %s: %.100s", pw->pw_name, tmp___6);
    }
#line 94
    user_groupslen = getgroups(0, (__gid_t *)((void *)0));
#line 95
    if (user_groupslen < 0) {
#line 96
      tmp___8 = __errno_location();
#line 96
      tmp___9 = strerror(*tmp___8);
#line 96
      fatal("getgroups: %.100s", tmp___9);
    }
#line 97
    if (user_groupslen > 0) {
#line 98
      tmp___10 = xrealloc((void *)user_groups, (unsigned int )user_groupslen * sizeof(gid_t ));
#line 98
      user_groups = (gid_t *)tmp___10;
#line 100
      tmp___13 = getgroups(user_groupslen, user_groups);
#line 100
      if (tmp___13 < 0) {
#line 101
        tmp___11 = __errno_location();
#line 101
        tmp___12 = strerror(*tmp___11);
#line 101
        fatal("getgroups: %.100s", tmp___12);
      }
    } else {
#line 103
      if (user_groups) {
#line 104
        xfree((void *)user_groups);
      }
    }
  }
#line 108
  tmp___16 = setgroups((unsigned int )user_groupslen, (__gid_t const   *)user_groups);
#line 108
  if (tmp___16 < 0) {
#line 109
    tmp___14 = __errno_location();
#line 109
    tmp___15 = strerror(*tmp___14);
#line 109
    fatal("setgroups: %.100s", tmp___15);
  }
#line 118
  tmp___19 = setegid(pw->pw_gid);
#line 118
  if (tmp___19 < 0) {
#line 119
    tmp___17 = __errno_location();
#line 119
    tmp___18 = strerror(*tmp___17);
#line 119
    fatal("setegid %u: %.100s", pw->pw_gid, tmp___18);
  }
#line 121
  tmp___22 = seteuid(pw->pw_uid);
#line 121
  if (tmp___22 == -1) {
#line 122
    tmp___20 = __errno_location();
#line 122
    tmp___21 = strerror(*tmp___20);
#line 122
    fatal("seteuid %u: %.100s", pw->pw_uid, tmp___21);
  }
#line 124
  return;
}
}
#line 129 "uidswap.c"
void restore_uid(void) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
#line 133
  if (! privileged) {
#line 134
    debug("restore_uid: (unprivileged)");
#line 135
    return;
  }
#line 137
  if (! temporarily_use_uid_effective) {
#line 138
    fatal("restore_uid: temporarily_use_uid not effective");
  }
#line 141
  debug("restore_uid: %u/%u", saved_euid, saved_egid);
#line 143
  tmp___1 = seteuid(saved_euid);
#line 143
  if (tmp___1 < 0) {
#line 144
    tmp = __errno_location();
#line 144
    tmp___0 = strerror(*tmp);
#line 144
    fatal("seteuid %u: %.100s", saved_euid, tmp___0);
  }
#line 145
  tmp___4 = setegid(saved_egid);
#line 145
  if (tmp___4 < 0) {
#line 146
    tmp___2 = __errno_location();
#line 146
    tmp___3 = strerror(*tmp___2);
#line 146
    fatal("setegid %u: %.100s", saved_egid, tmp___3);
  }
#line 157
  tmp___7 = setgroups((unsigned int )saved_egroupslen, (__gid_t const   *)saved_egroups);
#line 157
  if (tmp___7 < 0) {
#line 158
    tmp___5 = __errno_location();
#line 158
    tmp___6 = strerror(*tmp___5);
#line 158
    fatal("setgroups: %.100s", tmp___6);
  }
#line 159
  temporarily_use_uid_effective = 0;
#line 160
  return;
}
}
#line 166 "uidswap.c"
void permanently_set_uid(struct passwd *pw ) 
{ uid_t old_uid ;
  __uid_t tmp ;
  gid_t old_gid ;
  __gid_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __gid_t tmp___9 ;
  __gid_t tmp___10 ;
  __gid_t tmp___11 ;
  __gid_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  __uid_t tmp___15 ;
  __uid_t tmp___16 ;
  __uid_t tmp___17 ;
  __uid_t tmp___18 ;

  {
#line 169
  tmp = getuid();
#line 169
  old_uid = tmp;
#line 170
  tmp___0 = getgid();
#line 170
  old_gid = tmp___0;
#line 172
  if (temporarily_use_uid_effective) {
#line 173
    fatal("permanently_set_uid: temporarily_use_uid effective");
  }
#line 174
  debug("permanently_set_uid: %u/%u", pw->pw_uid, pw->pw_gid);
#line 178
  tmp___3 = setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid);
#line 178
  if (tmp___3 < 0) {
#line 179
    tmp___1 = __errno_location();
#line 179
    tmp___2 = strerror(*tmp___1);
#line 179
    fatal("setresgid %u: %.100s", pw->pw_gid, tmp___2);
  }
#line 191
  tmp___6 = setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid);
#line 191
  if (tmp___6 < 0) {
#line 192
    tmp___4 = __errno_location();
#line 192
    tmp___5 = strerror(*tmp___4);
#line 192
    fatal("setresuid %u: %.100s", pw->pw_uid, tmp___5);
  }
#line 207
  if (old_gid != pw->pw_gid) {
#line 207
    if (pw->pw_uid != 0U) {
#line 207
      tmp___7 = setgid(old_gid);
#line 207
      if (tmp___7 != -1) {
#line 209
        fatal("%s: was able to restore old [e]gid", "permanently_set_uid");
      } else {
#line 207
        tmp___8 = setegid(old_gid);
#line 207
        if (tmp___8 != -1) {
#line 209
          fatal("%s: was able to restore old [e]gid", "permanently_set_uid");
        }
      }
    }
  }
#line 213
  tmp___11 = getgid();
#line 213
  if (tmp___11 != pw->pw_gid) {
#line 214
    tmp___9 = getegid();
#line 214
    tmp___10 = getgid();
#line 214
    fatal("%s: egid incorrect gid:%u egid:%u (should be %u)", "permanently_set_uid",
          tmp___10, tmp___9, pw->pw_gid);
  } else {
#line 213
    tmp___12 = getegid();
#line 213
    if (tmp___12 != pw->pw_gid) {
#line 214
      tmp___9 = getegid();
#line 214
      tmp___10 = getgid();
#line 214
      fatal("%s: egid incorrect gid:%u egid:%u (should be %u)", "permanently_set_uid",
            tmp___10, tmp___9, pw->pw_gid);
    }
  }
#line 221
  if (old_uid != pw->pw_uid) {
#line 221
    tmp___13 = setuid(old_uid);
#line 221
    if (tmp___13 != -1) {
#line 223
      fatal("%s: was able to restore old [e]uid", "permanently_set_uid");
    } else {
#line 221
      tmp___14 = seteuid(old_uid);
#line 221
      if (tmp___14 != -1) {
#line 223
        fatal("%s: was able to restore old [e]uid", "permanently_set_uid");
      }
    }
  }
#line 227
  tmp___17 = getuid();
#line 227
  if (tmp___17 != pw->pw_uid) {
#line 228
    tmp___15 = geteuid();
#line 228
    tmp___16 = getuid();
#line 228
    fatal("%s: euid incorrect uid:%u euid:%u (should be %u)", "permanently_set_uid",
          tmp___16, tmp___15, pw->pw_uid);
  } else {
#line 227
    tmp___18 = geteuid();
#line 227
    if (tmp___18 != pw->pw_uid) {
#line 228
      tmp___15 = geteuid();
#line 228
      tmp___16 = getuid();
#line 228
      fatal("%s: euid incorrect uid:%u euid:%u (should be %u)", "permanently_set_uid",
            tmp___16, tmp___15, pw->pw_uid);
    }
  }
#line 232
  return;
}
}
#line 1 "uuencode.o"
#line 31 "uuencode.h"
void dump_base64(FILE *fp , u_char *data , u_int len ) ;
#line 31 "uuencode.c"
int uuencode(u_char const   *src , u_int srclength , char *target , size_t targsize ) 
{ int tmp ;

  {
#line 35
  tmp = __b64_ntop(src, srclength, target, targsize);
#line 35
  return (tmp);
}
}
#line 38 "uuencode.c"
int uudecode(char const   *src , u_char *target , size_t targsize ) 
{ int len ;
  char *encoded___0 ;
  char *p ;

  {
#line 45
  encoded___0 = xstrdup(src);
#line 47
  p = encoded___0;
#line 47
  while (1) {
#line 47
    if (! ((int )*p == 32)) {
#line 47
      if (! ((int )*p == 9)) {
#line 47
        break;
      }
    }
#line 47
    p ++;
  }
#line 49
  while (1) {
#line 49
    if ((int )*p != 0) {
#line 49
      if ((int )*p != 32) {
#line 49
        if (! ((int )*p != 9)) {
#line 49
          break;
        }
      } else {
#line 49
        break;
      }
    } else {
#line 49
      break;
    }
#line 49
    p ++;
  }
#line 52
  *p = (char )'\000';
#line 53
  len = __b64_pton((char const   *)encoded___0, target, targsize);
#line 54
  xfree((void *)encoded___0);
#line 55
  return (len);
}
}
#line 58 "uuencode.c"
void dump_base64(FILE *fp , u_char *data , u_int len ) 
{ char *buf___1 ;
  void *tmp ;
  int i ;
  int n___0 ;

  {
#line 61
  tmp = xmalloc(2U * len);
#line 61
  buf___1 = (char *)tmp;
#line 64
  n___0 = uuencode((u_char const   *)data, len, buf___1, 2U * len);
#line 65
  i = 0;
#line 65
  while (i < n___0) {
#line 66
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%c", *(buf___1 + i));
#line 67
    if (i % 70 == 69) {
#line 68
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
    }
#line 65
    i ++;
  }
#line 70
  if (i % 70 != 69) {
#line 71
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  }
#line 72
  xfree((void *)buf___1);
#line 73
  return;
}
}
/* compiler builtin: 
   char *__builtin_strpbrk(char const   * , char const   * ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned int  , void * ) ;  */
#line 1 "misc.o"
#line 370 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vasprintf)(char ** __restrict  __ptr ,
                                                                              char const   * __restrict  __f ,
                                                                              __gnuc_va_list __arg ) ;
#line 441
extern int fgetc(FILE *__stream ) ;
#line 729
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 184 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 17 "misc.h"
char *chop(char *s ) ;
#line 18
char *strdelim(char **s ) ;
#line 20
int unset_nonblock(int fd ) ;
#line 22
int a2port(char const   *s ) ;
#line 23
int a2tun(char const   *s , int *remote___0 ) ;
#line 24
char *hpdelim(char **cp ) ;
#line 25
char *cleanhostname(char *host ) ;
#line 26
char *colon(char *cp ) ;
#line 27
long convtime(char const   *s ) ;
#line 28
char *tilde_expand_filename(char const   *filename , uid_t uid ) ;
#line 29
char *percent_expand(char const   *string  , ...) ;
#line 31
void sanitise_stdfd(void) ;
#line 33
struct passwd *pwcopy(struct passwd *pw ) ;
#line 41
void ( /* format attribute */  addargs)(arglist *args , char *fmt  , ...) ;
#line 43
void ( /* format attribute */  replacearg)(arglist *args , u_int which , char *fmt 
                                           , ...) ;
#line 45
void freeargs(arglist *args ) ;
#line 58
int tun_open(int tun , int mode ) ;
#line 38 "misc.c"
char *chop(char *s ) 
{ char *t ;

  {
#line 41
  t = s;
#line 42
  while (*t) {
#line 43
    if ((int )*t == 10) {
#line 44
      *t = (char )'\000';
#line 45
      return (s);
    } else {
#line 43
      if ((int )*t == 13) {
#line 44
        *t = (char )'\000';
#line 45
        return (s);
      }
    }
#line 47
    t ++;
  }
#line 49
  return (s);
}
}
#line 54 "misc.c"
int set_nonblock(int fd ) 
{ int val ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 59
  val = fcntl(fd, 3, 0);
#line 60
  if (val < 0) {
#line 61
    tmp = __errno_location();
#line 61
    tmp___0 = strerror(*tmp);
#line 61
    error("fcntl(%d, F_GETFL, 0): %s", fd, tmp___0);
#line 62
    return (-1);
  }
#line 64
  if (val & 2048) {
#line 65
    debug3("fd %d is O_NONBLOCK", fd);
#line 66
    return (0);
  }
#line 68
  debug2("fd %d setting O_NONBLOCK", fd);
#line 69
  val |= 2048;
#line 70
  tmp___3 = fcntl(fd, 4, val);
#line 70
  if (tmp___3 == -1) {
#line 71
    tmp___1 = __errno_location();
#line 71
    tmp___2 = strerror(*tmp___1);
#line 71
    debug("fcntl(%d, F_SETFL, O_NONBLOCK): %s", fd, tmp___2);
#line 73
    return (-1);
  }
#line 75
  return (0);
}
}
#line 78 "misc.c"
int unset_nonblock(int fd ) 
{ int val ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 83
  val = fcntl(fd, 3, 0);
#line 84
  if (val < 0) {
#line 85
    tmp = __errno_location();
#line 85
    tmp___0 = strerror(*tmp);
#line 85
    error("fcntl(%d, F_GETFL, 0): %s", fd, tmp___0);
#line 86
    return (-1);
  }
#line 88
  if (! (val & 2048)) {
#line 89
    debug3("fd %d is not O_NONBLOCK", fd);
#line 90
    return (0);
  }
#line 92
  debug("fd %d clearing O_NONBLOCK", fd);
#line 93
  val &= -2049;
#line 94
  tmp___3 = fcntl(fd, 4, val);
#line 94
  if (tmp___3 == -1) {
#line 95
    tmp___1 = __errno_location();
#line 95
    tmp___2 = strerror(*tmp___1);
#line 95
    debug("fcntl(%d, F_SETFL, ~O_NONBLOCK): %s", fd, tmp___2);
#line 97
    return (-1);
  }
#line 99
  return (0);
}
}
#line 103 "misc.c"
void set_nodelay(int fd ) 
{ int opt ;
  socklen_t optlen ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 109
  optlen = sizeof(opt);
#line 110
  tmp___1 = getsockopt(fd, 6, 1, (void * __restrict  )(& opt), (socklen_t * __restrict  )(& optlen));
#line 110
  if (tmp___1 == -1) {
#line 111
    tmp = __errno_location();
#line 111
    tmp___0 = strerror(*tmp);
#line 111
    debug("getsockopt TCP_NODELAY: %.100s", tmp___0);
#line 112
    return;
  }
#line 114
  if (opt == 1) {
#line 115
    debug2("fd %d is TCP_NODELAY", fd);
#line 116
    return;
  }
#line 118
  opt = 1;
#line 119
  debug2("fd %d setting TCP_NODELAY", fd);
#line 120
  tmp___4 = setsockopt(fd, 6, 1, (void const   *)(& opt), sizeof(opt));
#line 120
  if (tmp___4 == -1) {
#line 121
    tmp___2 = __errno_location();
#line 121
    tmp___3 = strerror(*tmp___2);
#line 121
    error("setsockopt TCP_NODELAY: %.100s", tmp___3);
  }
#line 122
  return;
}
}
#line 128 "misc.c"
char *strdelim(char **s ) 
{ char *old ;
  int wspace ;
  char *tmp___30 ;
  unsigned int tmp___62 ;
  unsigned int tmp___94 ;

  {
#line 132
  wspace = 0;
#line 134
  if ((unsigned int )*s == (unsigned int )((void *)0)) {
#line 135
    return ((char *)((void *)0));
  }
#line 137
  old = *s;
#line 139
  tmp___30 = __builtin_strpbrk((char const   *)*s, " \t\r\n=");
#line 139
  *s = tmp___30;
#line 140
  if ((unsigned int )*s == (unsigned int )((void *)0)) {
#line 141
    return (old);
  }
#line 144
  if ((int )*(*(s + 0)) == 61) {
#line 145
    wspace = 1;
  }
#line 146
  *(*(s + 0)) = (char )'\000';
#line 148
  tmp___62 = __builtin_strspn((char const   *)(*s + 1), " \t\r\n");
#line 148
  *s += tmp___62 + 1U;
#line 149
  if ((int )*(*(s + 0)) == 61) {
#line 149
    if (! wspace) {
#line 150
      tmp___94 = __builtin_strspn((char const   *)(*s + 1), " \t\r\n");
#line 150
      *s += tmp___94 + 1U;
    }
  }
#line 152
  return (old);
}
}
#line 155 "misc.c"
struct passwd *pwcopy(struct passwd *pw ) 
{ struct passwd *copy ;
  void *tmp ;

  {
#line 158
  tmp = xmalloc(sizeof(*copy));
#line 158
  copy = (struct passwd *)tmp;
#line 160
  memset((void *)copy, 0, sizeof(*copy));
#line 161
  copy->pw_name = xstrdup((char const   *)pw->pw_name);
#line 162
  copy->pw_passwd = xstrdup((char const   *)pw->pw_passwd);
#line 163
  copy->pw_gecos = xstrdup((char const   *)pw->pw_gecos);
#line 164
  copy->pw_uid = pw->pw_uid;
#line 165
  copy->pw_gid = pw->pw_gid;
#line 175
  copy->pw_dir = xstrdup((char const   *)pw->pw_dir);
#line 176
  copy->pw_shell = xstrdup((char const   *)pw->pw_shell);
#line 177
  return (copy);
}
}
#line 185 "misc.c"
int a2port(char const   *s ) 
{ long port___0 ;
  char *endp ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 191
  tmp = __errno_location();
#line 191
  *tmp = 0;
#line 192
  port___0 = strtol((char const   * __restrict  )s, (char ** __restrict  )(& endp),
                    0);
#line 193
  if ((unsigned int )s == (unsigned int )endp) {
#line 196
    return (0);
  } else {
#line 193
    if ((int )*endp != 0) {
#line 196
      return (0);
    } else {
#line 193
      tmp___0 = __errno_location();
#line 193
      if (*tmp___0 == 34) {
#line 193
        if (port___0 == (-0x7FFFFFFF-1)) {
#line 196
          return (0);
        } else {
#line 193
          if (port___0 == 2147483647L) {
#line 196
            return (0);
          } else {
            goto _L;
          }
        }
      } else {
        _L: /* CIL Label */ 
#line 193
        if (port___0 <= 0L) {
#line 196
          return (0);
        } else {
#line 193
          if (port___0 > 65535L) {
#line 196
            return (0);
          }
        }
      }
    }
  }
#line 198
  return ((int )port___0);
}
}
#line 201 "misc.c"
int a2tun(char const   *s , int *remote___0 ) 
{ char const   *errstr ;
  char *sp ;
  char *ep ;
  int tun ;
  int tmp ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long long tmp___4 ;

  {
#line 204
  errstr = (char const   *)((void *)0);
#line 208
  if ((unsigned int )remote___0 != (unsigned int )((void *)0)) {
#line 209
    *remote___0 = 2147483647;
#line 210
    sp = xstrdup(s);
#line 211
    tmp___1 = __builtin_strchr(sp, ':');
#line 211
    ep = tmp___1;
#line 211
    if ((unsigned int )ep == (unsigned int )((void *)0)) {
#line 212
      xfree((void *)sp);
#line 213
      tmp = a2tun(s, (int *)((void *)0));
#line 213
      return (tmp);
    }
#line 215
    *(ep + 0) = (char )'\000';
#line 215
    ep ++;
#line 216
    *remote___0 = a2tun((char const   *)ep, (int *)((void *)0));
#line 217
    tun = a2tun((char const   *)sp, (int *)((void *)0));
#line 218
    xfree((void *)sp);
#line 219
    if (*remote___0 == 2147483646) {
#line 219
      tmp___2 = *remote___0;
    } else {
#line 219
      tmp___2 = tun;
    }
#line 219
    return (tmp___2);
  }
#line 222
  tmp___3 = strcasecmp(s, "any");
#line 222
  if (tmp___3 == 0) {
#line 223
    return (2147483647);
  }
#line 225
  tmp___4 = strtonum(s, 0LL, 2147483645LL, & errstr);
#line 225
  tun = (int )tmp___4;
#line 226
  if ((unsigned int )errstr != (unsigned int )((void *)0)) {
#line 227
    return (2147483646);
  }
#line 229
  return (tun);
}
}
#line 259 "misc.c"
long convtime(char const   *s ) 
{ long total ;
  long secs ;
  char const   *p ;
  char *endp ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 266
  tmp = __errno_location();
#line 266
  *tmp = 0;
#line 267
  total = 0L;
#line 268
  p = s;
#line 270
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 271
    return (-1L);
  } else {
#line 270
    if ((int const   )*p == 0) {
#line 271
      return (-1L);
    }
  }
#line 273
  while (*p) {
#line 274
    secs = strtol((char const   * __restrict  )p, (char ** __restrict  )(& endp),
                  10);
#line 275
    if ((unsigned int )p == (unsigned int )endp) {
#line 278
      return (-1L);
    } else {
#line 275
      tmp___0 = __errno_location();
#line 275
      if (*tmp___0 == 34) {
#line 275
        if (secs == (-0x7FFFFFFF-1)) {
#line 278
          return (-1L);
        } else {
#line 275
          if (secs == 2147483647L) {
#line 278
            return (-1L);
          } else {
            goto _L;
          }
        }
      } else {
        _L: /* CIL Label */ 
#line 275
        if (secs < 0L) {
#line 278
          return (-1L);
        }
      }
    }
#line 280
    tmp___1 = endp;
#line 280
    endp ++;
#line 280
    switch ((int )*tmp___1) {
    case 0: 
#line 282
    endp --;
    case 115: 
    case 83: 
#line 285
    break;
    case 109: 
    case 77: 
#line 288
    secs *= 60L;
#line 289
    break;
    case 104: 
    case 72: 
#line 292
    secs *= 3600L;
#line 293
    break;
    case 100: 
    case 68: 
#line 296
    secs *= 86400L;
#line 297
    break;
    case 119: 
    case 87: 
#line 300
    secs *= 604800L;
#line 301
    break;
    default: ;
#line 303
    return (-1L);
    }
#line 305
    total += secs;
#line 306
    if (total < 0L) {
#line 307
      return (-1L);
    }
#line 308
    p = (char const   *)endp;
  }
#line 311
  return (total);
}
}
#line 321 "misc.c"
char *hpdelim(char **cp ) 
{ char *s ;
  char *old ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___33 ;

  {
#line 326
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 327
    return ((char *)((void *)0));
  } else {
#line 326
    if ((unsigned int )*cp == (unsigned int )((void *)0)) {
#line 327
      return ((char *)((void *)0));
    }
  }
#line 329
  s = *cp;
#line 329
  old = s;
#line 330
  if ((int )*s == 91) {
#line 331
    tmp___0 = __builtin_strchr(s, ']');
#line 331
    s = tmp___0;
#line 331
    if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 332
      return ((char *)((void *)0));
    } else {
#line 334
      s ++;
    }
  } else {
#line 335
    tmp___33 = __builtin_strpbrk((char const   *)s, ":/");
#line 335
    s = tmp___33;
#line 335
    if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 336
      tmp___1 = strlen((char const   *)*cp);
#line 336
      s = *cp + tmp___1;
    }
  }
#line 338
  switch ((int )*s) {
  case 0: 
#line 340
  *cp = (char *)((void *)0);
#line 341
  break;
  case 58: 
  case 47: 
#line 345
  *s = (char )'\000';
#line 346
  *cp = s + 1;
#line 347
  break;
  default: ;
#line 350
  return ((char *)((void *)0));
  }
#line 353
  return (old);
}
}
#line 356 "misc.c"
char *cleanhostname(char *host ) 
{ size_t tmp ;
  size_t tmp___0 ;

  {
#line 359
  if ((int )*host == 91) {
#line 359
    tmp___0 = strlen((char const   *)host);
#line 359
    if ((int )*(host + (tmp___0 - 1U)) == 93) {
#line 360
      tmp = strlen((char const   *)host);
#line 360
      *(host + (tmp - 1U)) = (char )'\000';
#line 361
      return (host + 1);
    } else {
#line 363
      return (host);
    }
  } else {
#line 363
    return (host);
  }
}
}
#line 366 "misc.c"
char *colon(char *cp ) 
{ int flag ;

  {
#line 369
  flag = 0;
#line 371
  if ((int )*cp == 58) {
#line 372
    return ((char *)0);
  }
#line 373
  if ((int )*cp == 91) {
#line 374
    flag = 1;
  }
#line 376
  while (*cp) {
#line 377
    if ((int )*cp == 64) {
#line 377
      if ((int )*(cp + 1) == 91) {
#line 378
        flag = 1;
      }
    }
#line 379
    if ((int )*cp == 93) {
#line 379
      if ((int )*(cp + 1) == 58) {
#line 379
        if (flag) {
#line 380
          return (cp + 1);
        }
      }
    }
#line 381
    if ((int )*cp == 58) {
#line 381
      if (! flag) {
#line 382
        return (cp);
      }
    }
#line 383
    if ((int )*cp == 47) {
#line 384
      return ((char *)0);
    }
#line 376
    cp ++;
  }
#line 386
  return ((char *)0);
}
}
#line 390 "misc.c"
void ( /* format attribute */  addargs)(arglist *args , char *fmt  , ...) 
{ va_list ap ;
  char *cp ;
  u_int nalloc ;
  int r ;
  void *tmp ;
  u_int tmp___0 ;

  {
#line 398
  __builtin_va_start(ap, fmt);
#line 399
  r = vasprintf((char ** __restrict  )(& cp), (char const   * __restrict  )fmt, ap);
#line 400
  __builtin_va_end(ap);
#line 401
  if (r == -1) {
#line 402
    fatal("addargs: argument too long");
  }
#line 404
  nalloc = args->nalloc;
#line 405
  if ((unsigned int )args->list == (unsigned int )((void *)0)) {
#line 406
    nalloc = 32U;
#line 407
    args->num = 0U;
  } else {
#line 408
    if (args->num + 2U >= nalloc) {
#line 409
      nalloc *= 2U;
    }
  }
#line 411
  tmp = xrealloc((void *)args->list, nalloc * sizeof(char *));
#line 411
  args->list = (char **)tmp;
#line 412
  args->nalloc = nalloc;
#line 413
  tmp___0 = args->num;
#line 413
  (args->num) ++;
#line 413
  *(args->list + tmp___0) = cp;
#line 414
  *(args->list + args->num) = (char *)((void *)0);
#line 415
  return;
}
}
#line 417 "misc.c"
void ( /* format attribute */  replacearg)(arglist *args , u_int which , char *fmt 
                                           , ...) 
{ va_list ap ;
  char *cp ;
  int r ;

  {
#line 424
  __builtin_va_start(ap, fmt);
#line 425
  r = vasprintf((char ** __restrict  )(& cp), (char const   * __restrict  )fmt, ap);
#line 426
  __builtin_va_end(ap);
#line 427
  if (r == -1) {
#line 428
    fatal("replacearg: argument too long");
  }
#line 430
  if (which >= args->num) {
#line 431
    fatal("replacearg: tried to replace invalid arg %d >= %d", which, args->num);
  }
#line 433
  xfree((void *)*(args->list + which));
#line 434
  *(args->list + which) = cp;
#line 435
  return;
}
}
#line 437 "misc.c"
void freeargs(arglist *args ) 
{ u_int i ;

  {
#line 442
  if ((unsigned int )args->list != (unsigned int )((void *)0)) {
#line 443
    i = 0U;
#line 443
    while (i < args->num) {
#line 444
      xfree((void *)*(args->list + i));
#line 443
      i ++;
    }
#line 445
    xfree((void *)args->list);
#line 446
    args->num = 0U;
#line 446
    args->nalloc = args->num;
#line 447
    args->list = (char **)((void *)0);
  }
#line 449
  return;
}
}
#line 455 "misc.c"
char *tilde_expand_filename(char const   *filename , uid_t uid ) 
{ char const   *path ;
  char user[128] ;
  char ret[4096] ;
  struct passwd *pw ;
  u_int len ;
  u_int slash ;
  char *tmp ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;

  {
#line 463
  if ((int const   )*filename != 126) {
#line 464
    tmp = xstrdup(filename);
#line 464
    return (tmp);
  }
#line 465
  filename ++;
#line 467
  tmp___1 = __builtin_strchr((char *)filename, '/');
#line 467
  path = (char const   *)tmp___1;
#line 468
  if ((unsigned int )path != (unsigned int )((void *)0)) {
#line 468
    if ((unsigned int )path > (unsigned int )filename) {
#line 469
      slash = (unsigned int )(path - filename);
#line 470
      if (slash > sizeof(user) - 1U) {
#line 471
        fatal("tilde_expand_filename: ~username too long");
      }
#line 472
      memcpy((void * __restrict  )(user), (void const   * __restrict  )filename, slash);
#line 473
      user[slash] = (char )'\000';
#line 474
      pw = getpwnam((char const   *)(user));
#line 474
      if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 475
        fatal("tilde_expand_filename: No such user %s", user);
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 476
    pw = getpwuid(uid);
#line 476
    if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 477
      fatal("tilde_expand_filename: No such uid %d", uid);
    }
  }
#line 479
  tmp___2 = strlcpy(ret, (char const   *)pw->pw_dir, sizeof(ret));
#line 479
  if (tmp___2 >= sizeof(ret)) {
#line 480
    fatal("tilde_expand_filename: Path too long");
  }
#line 483
  len = strlen((char const   *)pw->pw_dir);
#line 484
  if (len == 0U) {
    goto _L___0;
  } else {
#line 484
    if ((int )*(pw->pw_dir + (len - 1U)) != 47) {
      _L___0: /* CIL Label */ 
#line 484
      tmp___3 = strlcat(ret, "/", sizeof(ret));
#line 484
      if (tmp___3 >= sizeof(ret)) {
#line 486
        fatal("tilde_expand_filename: Path too long");
      }
    }
  }
#line 489
  if ((unsigned int )path != (unsigned int )((void *)0)) {
#line 490
    filename = path + 1;
  }
#line 491
  tmp___4 = strlcat(ret, filename, sizeof(ret));
#line 491
  if (tmp___4 >= sizeof(ret)) {
#line 492
    fatal("tilde_expand_filename: Path too long");
  }
#line 494
  tmp___5 = xstrdup((char const   *)(ret));
#line 494
  return (tmp___5);
}
}
#line 503 "misc.c"
char *percent_expand(char const   *string  , ...) 
{ struct __anonstruct_keys_77 keys[16] ;
  u_int num_keys ;
  u_int i ;
  u_int j ;
  char buf___1[4096] ;
  va_list ap ;
  u_int tmp ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 516
  __builtin_va_start(ap, string);
#line 517
  num_keys = 0U;
#line 517
  while (num_keys < 16U) {
#line 518
    keys[num_keys].key = __builtin_va_arg(ap, char *);
#line 519
    if ((unsigned int )keys[num_keys].key == (unsigned int )((void *)0)) {
#line 520
      break;
    }
#line 521
    keys[num_keys].repl = __builtin_va_arg(ap, char *);
#line 522
    if ((unsigned int )keys[num_keys].repl == (unsigned int )((void *)0)) {
#line 523
      fatal("percent_expand: NULL replacement");
    }
#line 517
    num_keys ++;
  }
#line 525
  __builtin_va_end(ap);
#line 527
  if (num_keys >= 16U) {
#line 528
    fatal("percent_expand: too many keys");
  }
#line 531
  buf___1[0] = (char )'\000';
#line 532
  i = 0U;
#line 532
  while ((int const   )*string != 0) {
#line 533
    if ((int const   )*string != 37) {
      append: 
#line 535
      tmp = i;
#line 535
      i ++;
#line 535
      buf___1[tmp] = (char )*string;
#line 536
      if (i >= sizeof(buf___1)) {
#line 537
        fatal("percent_expand: string too long");
      }
#line 538
      buf___1[i] = (char )'\000';
      goto __Cont;
    }
#line 541
    string ++;
#line 542
    if ((int const   )*string == 37) {
      goto append;
    }
#line 544
    j = 0U;
#line 544
    while (j < num_keys) {
#line 545
      tmp___1 = __builtin_strchr((char *)keys[j].key, (int )*string);
#line 545
      if ((unsigned int )tmp___1 != (unsigned int )((void *)0)) {
#line 546
        i = strlcat(buf___1, keys[j].repl, sizeof(buf___1));
#line 547
        if (i >= sizeof(buf___1)) {
#line 548
          fatal("percent_expand: string too long");
        }
#line 549
        break;
      }
#line 544
      j ++;
    }
#line 552
    if (j >= num_keys) {
#line 553
      fatal("percent_expand: unknown key %%%c", *string);
    }
    __Cont: /* CIL Label */ 
#line 532
    string ++;
  }
#line 555
  tmp___2 = xstrdup((char const   *)(buf___1));
#line 555
  return (tmp___2);
}
}
#line 563 "misc.c"
int read_keyfile_line(FILE *f , char const   *filename , char *buf___1 , size_t bufsz ,
                      u_long *lineno ) 
{ int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 567
  while (1) {
#line 567
    tmp___3 = fgets((char * __restrict  )buf___1, (int )bufsz, (FILE * __restrict  )f);
#line 567
    if (! ((unsigned int )tmp___3 != (unsigned int )((void *)0))) {
#line 567
      break;
    }
#line 568
    (*lineno) ++;
#line 569
    tmp___1 = strlen((char const   *)buf___1);
#line 569
    if ((int )*(buf___1 + (tmp___1 - 1U)) == 10) {
#line 570
      return (0);
    } else {
#line 569
      tmp___2 = feof(f);
#line 569
      if (tmp___2) {
#line 570
        return (0);
      } else {
#line 572
        debug("%s: %s line %lu exceeds size limit", "read_keyfile_line", filename,
              *lineno);
#line 575
        while (1) {
#line 575
          tmp = fgetc(f);
#line 575
          if (tmp != 10) {
#line 575
            tmp___0 = feof(f);
#line 575
            if (tmp___0) {
#line 575
              break;
            }
          } else {
#line 575
            break;
          }
        }
      }
    }
  }
#line 579
  return (-1);
}
}
#line 582 "misc.c"
int tun_open(int tun , int mode ) 
{ int tmp ;

  {
#line 586
  tmp = sys_tun_open(tun, mode);
#line 586
  return (tmp);
}
}
#line 653 "misc.c"
void sanitise_stdfd(void) 
{ int nullfd ;
  int dupfd ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 658
  dupfd = open("/dev/null", 2);
#line 658
  nullfd = dupfd;
#line 658
  if (nullfd == -1) {
#line 659
    tmp = __errno_location();
#line 659
    tmp___0 = strerror(*tmp);
#line 659
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Couldn\'t open /dev/null: %s",
            tmp___0);
#line 660
    exit(1);
  }
#line 662
  while (1) {
#line 662
    dupfd ++;
#line 662
    if (! (dupfd <= 2)) {
#line 662
      break;
    }
#line 664
    tmp___1 = fcntl(dupfd, 3, 0);
#line 664
    if (tmp___1 >= 0) {
#line 665
      continue;
    }
#line 666
    tmp___4 = dup2(nullfd, dupfd);
#line 666
    if (tmp___4 == -1) {
#line 667
      tmp___2 = __errno_location();
#line 667
      tmp___3 = strerror(*tmp___2);
#line 667
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"dup2: %s",
              tmp___3);
#line 668
      exit(1);
    }
  }
#line 671
  if (nullfd > 2) {
#line 672
    close(nullfd);
  }
#line 673
  return;
}
}
#line 675 "misc.c"
char *tohex(u_char const   *d , u_int l ) 
{ char b[3] ;
  char *r ;
  u_int i ;
  u_int hl ;
  void *tmp ;

  {
#line 681
  hl = l * 2U + 1U;
#line 682
  tmp = xmalloc(hl);
#line 682
  r = (char *)tmp;
#line 683
  *r = (char )'\000';
#line 684
  i = 0U;
#line 684
  while (i < l) {
#line 685
    snprintf((char * __restrict  )(b), sizeof(b), (char const   * __restrict  )"%02x",
             *(d + i));
#line 686
    strlcat(r, (char const   *)(b), hl);
#line 684
    i ++;
  }
#line 688
  return (r);
}
}
#line 1 "monitor_fdpass.o"
#line 171 "/usr/include/sys/socket.h"
extern ssize_t sendmsg(int __fd , struct msghdr  const  *__message , int __flags ) ;
#line 179
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 31 "monitor_fdpass.h"
void mm_send_fd(int sock , int fd ) ;
#line 32
int mm_receive_fd(int sock ) ;
#line 34 "monitor_fdpass.c"
void mm_send_fd(int sock , int fd ) 
{ struct msghdr msg ;
  struct iovec vec ;
  char ch ;
  ssize_t n___0 ;
  char tmp[(((sizeof(int ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U))] ;
  struct cmsghdr *cmsg ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 40
  ch = (char )'\000';
#line 47
  memset((void *)(& msg), 0, sizeof(msg));
#line 52
  msg.msg_control = (void *)(tmp);
#line 53
  msg.msg_controllen = (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U)) + sizeof(int );
#line 54
  if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 54
    cmsg = (struct cmsghdr *)msg.msg_control;
  } else {
#line 54
    cmsg = (struct cmsghdr *)((void *)0);
  }
#line 55
  cmsg->cmsg_len = (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U)) + sizeof(int );
#line 56
  cmsg->cmsg_level = 1;
#line 57
  cmsg->cmsg_type = 1;
#line 58
  *((int *)(cmsg->__cmsg_data)) = fd;
#line 61
  vec.iov_base = (void *)(& ch);
#line 62
  vec.iov_len = 1U;
#line 63
  msg.msg_iov = & vec;
#line 64
  msg.msg_iovlen = 1U;
#line 66
  n___0 = sendmsg(sock, (struct msghdr  const  *)(& msg), 0);
#line 66
  if (n___0 == -1) {
#line 67
    tmp___0 = __errno_location();
#line 67
    tmp___1 = strerror(*tmp___0);
#line 67
    fatal("%s: sendmsg(%d): %s", "mm_send_fd", fd, tmp___1);
  }
#line 69
  if (n___0 != 1) {
#line 70
    fatal("%s: sendmsg: expected sent 1 got %ld", "mm_send_fd", (long )n___0);
  }
#line 76
  return;
}
}
#line 78 "monitor_fdpass.c"
int mm_receive_fd(int sock ) 
{ struct msghdr msg ;
  struct iovec vec ;
  ssize_t n___0 ;
  char ch ;
  int fd ;
  char tmp[(((sizeof(int ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U))] ;
  struct cmsghdr *cmsg ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 92
  memset((void *)(& msg), 0, sizeof(msg));
#line 93
  vec.iov_base = (void *)(& ch);
#line 94
  vec.iov_len = 1U;
#line 95
  msg.msg_iov = & vec;
#line 96
  msg.msg_iovlen = 1U;
#line 101
  msg.msg_control = (void *)(tmp);
#line 102
  msg.msg_controllen = sizeof(tmp);
#line 105
  n___0 = recvmsg(sock, & msg, 0);
#line 105
  if (n___0 == -1) {
#line 106
    tmp___0 = __errno_location();
#line 106
    tmp___1 = strerror(*tmp___0);
#line 106
    fatal("%s: recvmsg: %s", "mm_receive_fd", tmp___1);
  }
#line 107
  if (n___0 != 1) {
#line 108
    fatal("%s: recvmsg: expected received 1 got %ld", "mm_receive_fd", (long )n___0);
  }
#line 115
  if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 115
    cmsg = (struct cmsghdr *)msg.msg_control;
  } else {
#line 115
    cmsg = (struct cmsghdr *)((void *)0);
  }
#line 116
  if ((unsigned int )cmsg == (unsigned int )((void *)0)) {
#line 117
    fatal("%s: no message header", "mm_receive_fd");
  }
#line 119
  if (cmsg->cmsg_type != 1) {
#line 120
    fatal("%s: expected type %d got %d", "mm_receive_fd", 1, cmsg->cmsg_type);
  }
#line 123
  fd = *((int *)(cmsg->__cmsg_data));
#line 125
  return (fd);
}
}
#line 1 "rijndael.o"
#line 51 "rijndael.c"
static u32 const   Te0[256]  = 
#line 51 "rijndael.c"
  {      (u32 const   )3328402341U,      (u32 const   )4168907908U,      (u32 const   )4000806809U,      (u32 const   )4135287693U, 
        (u32 const   )4294111757U,      (u32 const   )3597364157U,      (u32 const   )3731845041U,      (u32 const   )2445657428U, 
        (u32 const   )1613770832U,      (u32 const   )33620227U,      (u32 const   )3462883241U,      (u32 const   )1445669757U, 
        (u32 const   )3892248089U,      (u32 const   )3050821474U,      (u32 const   )1303096294U,      (u32 const   )3967186586U, 
        (u32 const   )2412431941U,      (u32 const   )528646813U,      (u32 const   )2311702848U,      (u32 const   )4202528135U, 
        (u32 const   )4026202645U,      (u32 const   )2992200171U,      (u32 const   )2387036105U,      (u32 const   )4226871307U, 
        (u32 const   )1101901292U,      (u32 const   )3017069671U,      (u32 const   )1604494077U,      (u32 const   )1169141738U, 
        (u32 const   )597466303U,      (u32 const   )1403299063U,      (u32 const   )3832705686U,      (u32 const   )2613100635U, 
        (u32 const   )1974974402U,      (u32 const   )3791519004U,      (u32 const   )1033081774U,      (u32 const   )1277568618U, 
        (u32 const   )1815492186U,      (u32 const   )2118074177U,      (u32 const   )4126668546U,      (u32 const   )2211236943U, 
        (u32 const   )1748251740U,      (u32 const   )1369810420U,      (u32 const   )3521504564U,      (u32 const   )4193382664U, 
        (u32 const   )3799085459U,      (u32 const   )2883115123U,      (u32 const   )1647391059U,      (u32 const   )706024767U, 
        (u32 const   )134480908U,      (u32 const   )2512897874U,      (u32 const   )1176707941U,      (u32 const   )2646852446U, 
        (u32 const   )806885416U,      (u32 const   )932615841U,      (u32 const   )168101135U,      (u32 const   )798661301U, 
        (u32 const   )235341577U,      (u32 const   )605164086U,      (u32 const   )461406363U,      (u32 const   )3756188221U, 
        (u32 const   )3454790438U,      (u32 const   )1311188841U,      (u32 const   )2142417613U,      (u32 const   )3933566367U, 
        (u32 const   )302582043U,      (u32 const   )495158174U,      (u32 const   )1479289972U,      (u32 const   )874125870U, 
        (u32 const   )907746093U,      (u32 const   )3698224818U,      (u32 const   )3025820398U,      (u32 const   )1537253627U, 
        (u32 const   )2756858614U,      (u32 const   )1983593293U,      (u32 const   )3084310113U,      (u32 const   )2108928974U, 
        (u32 const   )1378429307U,      (u32 const   )3722699582U,      (u32 const   )1580150641U,      (u32 const   )327451799U, 
        (u32 const   )2790478837U,      (u32 const   )3117535592U,      (u32 const   )0U,      (u32 const   )3253595436U, 
        (u32 const   )1075847264U,      (u32 const   )3825007647U,      (u32 const   )2041688520U,      (u32 const   )3059440621U, 
        (u32 const   )3563743934U,      (u32 const   )2378943302U,      (u32 const   )1740553945U,      (u32 const   )1916352843U, 
        (u32 const   )2487896798U,      (u32 const   )2555137236U,      (u32 const   )2958579944U,      (u32 const   )2244988746U, 
        (u32 const   )3151024235U,      (u32 const   )3320835882U,      (u32 const   )1336584933U,      (u32 const   )3992714006U, 
        (u32 const   )2252555205U,      (u32 const   )2588757463U,      (u32 const   )1714631509U,      (u32 const   )293963156U, 
        (u32 const   )2319795663U,      (u32 const   )3925473552U,      (u32 const   )67240454U,      (u32 const   )4269768577U, 
        (u32 const   )2689618160U,      (u32 const   )2017213508U,      (u32 const   )631218106U,      (u32 const   )1269344483U, 
        (u32 const   )2723238387U,      (u32 const   )1571005438U,      (u32 const   )2151694528U,      (u32 const   )93294474U, 
        (u32 const   )1066570413U,      (u32 const   )563977660U,      (u32 const   )1882732616U,      (u32 const   )4059428100U, 
        (u32 const   )1673313503U,      (u32 const   )2008463041U,      (u32 const   )2950355573U,      (u32 const   )1109467491U, 
        (u32 const   )537923632U,      (u32 const   )3858759450U,      (u32 const   )4260623118U,      (u32 const   )3218264685U, 
        (u32 const   )2177748300U,      (u32 const   )403442708U,      (u32 const   )638784309U,      (u32 const   )3287084079U, 
        (u32 const   )3193921505U,      (u32 const   )899127202U,      (u32 const   )2286175436U,      (u32 const   )773265209U, 
        (u32 const   )2479146071U,      (u32 const   )1437050866U,      (u32 const   )4236148354U,      (u32 const   )2050833735U, 
        (u32 const   )3362022572U,      (u32 const   )3126681063U,      (u32 const   )840505643U,      (u32 const   )3866325909U, 
        (u32 const   )3227541664U,      (u32 const   )427917720U,      (u32 const   )2655997905U,      (u32 const   )2749160575U, 
        (u32 const   )1143087718U,      (u32 const   )1412049534U,      (u32 const   )999329963U,      (u32 const   )193497219U, 
        (u32 const   )2353415882U,      (u32 const   )3354324521U,      (u32 const   )1807268051U,      (u32 const   )672404540U, 
        (u32 const   )2816401017U,      (u32 const   )3160301282U,      (u32 const   )369822493U,      (u32 const   )2916866934U, 
        (u32 const   )3688947771U,      (u32 const   )1681011286U,      (u32 const   )1949973070U,      (u32 const   )336202270U, 
        (u32 const   )2454276571U,      (u32 const   )201721354U,      (u32 const   )1210328172U,      (u32 const   )3093060836U, 
        (u32 const   )2680341085U,      (u32 const   )3184776046U,      (u32 const   )1135389935U,      (u32 const   )3294782118U, 
        (u32 const   )965841320U,      (u32 const   )831886756U,      (u32 const   )3554993207U,      (u32 const   )4068047243U, 
        (u32 const   )3588745010U,      (u32 const   )2345191491U,      (u32 const   )1849112409U,      (u32 const   )3664604599U, 
        (u32 const   )26054028U,      (u32 const   )2983581028U,      (u32 const   )2622377682U,      (u32 const   )1235855840U, 
        (u32 const   )3630984372U,      (u32 const   )2891339514U,      (u32 const   )4092916743U,      (u32 const   )3488279077U, 
        (u32 const   )3395642799U,      (u32 const   )4101667470U,      (u32 const   )1202630377U,      (u32 const   )268961816U, 
        (u32 const   )1874508501U,      (u32 const   )4034427016U,      (u32 const   )1243948399U,      (u32 const   )1546530418U, 
        (u32 const   )941366308U,      (u32 const   )1470539505U,      (u32 const   )1941222599U,      (u32 const   )2546386513U, 
        (u32 const   )3421038627U,      (u32 const   )2715671932U,      (u32 const   )3899946140U,      (u32 const   )1042226977U, 
        (u32 const   )2521517021U,      (u32 const   )1639824860U,      (u32 const   )227249030U,      (u32 const   )260737669U, 
        (u32 const   )3765465232U,      (u32 const   )2084453954U,      (u32 const   )1907733956U,      (u32 const   )3429263018U, 
        (u32 const   )2420656344U,      (u32 const   )100860677U,      (u32 const   )4160157185U,      (u32 const   )470683154U, 
        (u32 const   )3261161891U,      (u32 const   )1781871967U,      (u32 const   )2924959737U,      (u32 const   )1773779408U, 
        (u32 const   )394692241U,      (u32 const   )2579611992U,      (u32 const   )974986535U,      (u32 const   )664706745U, 
        (u32 const   )3655459128U,      (u32 const   )3958962195U,      (u32 const   )731420851U,      (u32 const   )571543859U, 
        (u32 const   )3530123707U,      (u32 const   )2849626480U,      (u32 const   )126783113U,      (u32 const   )865375399U, 
        (u32 const   )765172662U,      (u32 const   )1008606754U,      (u32 const   )361203602U,      (u32 const   )3387549984U, 
        (u32 const   )2278477385U,      (u32 const   )2857719295U,      (u32 const   )1344809080U,      (u32 const   )2782912378U, 
        (u32 const   )59542671U,      (u32 const   )1503764984U,      (u32 const   )160008576U,      (u32 const   )437062935U, 
        (u32 const   )1707065306U,      (u32 const   )3622233649U,      (u32 const   )2218934982U,      (u32 const   )3496503480U, 
        (u32 const   )2185314755U,      (u32 const   )697932208U,      (u32 const   )1512910199U,      (u32 const   )504303377U, 
        (u32 const   )2075177163U,      (u32 const   )2824099068U,      (u32 const   )1841019862U,      (u32 const   )739644986U};
#line 117 "rijndael.c"
static u32 const   Te1[256]  = 
#line 117
  {      (u32 const   )2781242211U,      (u32 const   )2230877308U,      (u32 const   )2582542199U,      (u32 const   )2381740923U, 
        (u32 const   )234877682U,      (u32 const   )3184946027U,      (u32 const   )2984144751U,      (u32 const   )1418839493U, 
        (u32 const   )1348481072U,      (u32 const   )50462977U,      (u32 const   )2848876391U,      (u32 const   )2102799147U, 
        (u32 const   )434634494U,      (u32 const   )1656084439U,      (u32 const   )3863849899U,      (u32 const   )2599188086U, 
        (u32 const   )1167051466U,      (u32 const   )2636087938U,      (u32 const   )1082771913U,      (u32 const   )2281340285U, 
        (u32 const   )368048890U,      (u32 const   )3954334041U,      (u32 const   )3381544775U,      (u32 const   )201060592U, 
        (u32 const   )3963727277U,      (u32 const   )1739838676U,      (u32 const   )4250903202U,      (u32 const   )3930435503U, 
        (u32 const   )3206782108U,      (u32 const   )4149453988U,      (u32 const   )2531553906U,      (u32 const   )1536934080U, 
        (u32 const   )3262494647U,      (u32 const   )484572669U,      (u32 const   )2923271059U,      (u32 const   )1783375398U, 
        (u32 const   )1517041206U,      (u32 const   )1098792767U,      (u32 const   )49674231U,      (u32 const   )1334037708U, 
        (u32 const   )1550332980U,      (u32 const   )4098991525U,      (u32 const   )886171109U,      (u32 const   )150598129U, 
        (u32 const   )2481090929U,      (u32 const   )1940642008U,      (u32 const   )1398944049U,      (u32 const   )1059722517U, 
        (u32 const   )201851908U,      (u32 const   )1385547719U,      (u32 const   )1699095331U,      (u32 const   )1587397571U, 
        (u32 const   )674240536U,      (u32 const   )2704774806U,      (u32 const   )252314885U,      (u32 const   )3039795866U, 
        (u32 const   )151914247U,      (u32 const   )908333586U,      (u32 const   )2602270848U,      (u32 const   )1038082786U, 
        (u32 const   )651029483U,      (u32 const   )1766729511U,      (u32 const   )3447698098U,      (u32 const   )2682942837U, 
        (u32 const   )454166793U,      (u32 const   )2652734339U,      (u32 const   )1951935532U,      (u32 const   )775166490U, 
        (u32 const   )758520603U,      (u32 const   )3000790638U,      (u32 const   )4004797018U,      (u32 const   )4217086112U, 
        (u32 const   )4137964114U,      (u32 const   )1299594043U,      (u32 const   )1639438038U,      (u32 const   )3464344499U, 
        (u32 const   )2068982057U,      (u32 const   )1054729187U,      (u32 const   )1901997871U,      (u32 const   )2534638724U, 
        (u32 const   )4121318227U,      (u32 const   )1757008337U,      (u32 const   )0U,      (u32 const   )750906861U, 
        (u32 const   )1614815264U,      (u32 const   )535035132U,      (u32 const   )3363418545U,      (u32 const   )3988151131U, 
        (u32 const   )3201591914U,      (u32 const   )1183697867U,      (u32 const   )3647454910U,      (u32 const   )1265776953U, 
        (u32 const   )3734260298U,      (u32 const   )3566750796U,      (u32 const   )3903871064U,      (u32 const   )1250283471U, 
        (u32 const   )1807470800U,      (u32 const   )717615087U,      (u32 const   )3847203498U,      (u32 const   )384695291U, 
        (u32 const   )3313910595U,      (u32 const   )3617213773U,      (u32 const   )1432761139U,      (u32 const   )2484176261U, 
        (u32 const   )3481945413U,      (u32 const   )283769337U,      (u32 const   )100925954U,      (u32 const   )2180939647U, 
        (u32 const   )4037038160U,      (u32 const   )1148730428U,      (u32 const   )3123027871U,      (u32 const   )3813386408U, 
        (u32 const   )4087501137U,      (u32 const   )4267549603U,      (u32 const   )3229630528U,      (u32 const   )2315620239U, 
        (u32 const   )2906624658U,      (u32 const   )3156319645U,      (u32 const   )1215313976U,      (u32 const   )82966005U, 
        (u32 const   )3747855548U,      (u32 const   )3245848246U,      (u32 const   )1974459098U,      (u32 const   )1665278241U, 
        (u32 const   )807407632U,      (u32 const   )451280895U,      (u32 const   )251524083U,      (u32 const   )1841287890U, 
        (u32 const   )1283575245U,      (u32 const   )337120268U,      (u32 const   )891687699U,      (u32 const   )801369324U, 
        (u32 const   )3787349855U,      (u32 const   )2721421207U,      (u32 const   )3431482436U,      (u32 const   )959321879U, 
        (u32 const   )1469301956U,      (u32 const   )4065699751U,      (u32 const   )2197585534U,      (u32 const   )1199193405U, 
        (u32 const   )2898814052U,      (u32 const   )3887750493U,      (u32 const   )724703513U,      (u32 const   )2514908019U, 
        (u32 const   )2696962144U,      (u32 const   )2551808385U,      (u32 const   )3516813135U,      (u32 const   )2141445340U, 
        (u32 const   )1715741218U,      (u32 const   )2119445034U,      (u32 const   )2872807568U,      (u32 const   )2198571144U, 
        (u32 const   )3398190662U,      (u32 const   )700968686U,      (u32 const   )3547052216U,      (u32 const   )1009259540U, 
        (u32 const   )2041044702U,      (u32 const   )3803995742U,      (u32 const   )487983883U,      (u32 const   )1991105499U, 
        (u32 const   )1004265696U,      (u32 const   )1449407026U,      (u32 const   )1316239930U,      (u32 const   )504629770U, 
        (u32 const   )3683797321U,      (u32 const   )168560134U,      (u32 const   )1816667172U,      (u32 const   )3837287516U, 
        (u32 const   )1570751170U,      (u32 const   )1857934291U,      (u32 const   )4014189740U,      (u32 const   )2797888098U, 
        (u32 const   )2822345105U,      (u32 const   )2754712981U,      (u32 const   )936633572U,      (u32 const   )2347923833U, 
        (u32 const   )852879335U,      (u32 const   )1133234376U,      (u32 const   )1500395319U,      (u32 const   )3084545389U, 
        (u32 const   )2348912013U,      (u32 const   )1689376213U,      (u32 const   )3533459022U,      (u32 const   )3762923945U, 
        (u32 const   )3034082412U,      (u32 const   )4205598294U,      (u32 const   )133428468U,      (u32 const   )634383082U, 
        (u32 const   )2949277029U,      (u32 const   )2398386810U,      (u32 const   )3913789102U,      (u32 const   )403703816U, 
        (u32 const   )3580869306U,      (u32 const   )2297460856U,      (u32 const   )1867130149U,      (u32 const   )1918643758U, 
        (u32 const   )607656988U,      (u32 const   )4049053350U,      (u32 const   )3346248884U,      (u32 const   )1368901318U, 
        (u32 const   )600565992U,      (u32 const   )2090982877U,      (u32 const   )2632479860U,      (u32 const   )557719327U, 
        (u32 const   )3717614411U,      (u32 const   )3697393085U,      (u32 const   )2249034635U,      (u32 const   )2232388234U, 
        (u32 const   )2430627952U,      (u32 const   )1115438654U,      (u32 const   )3295786421U,      (u32 const   )2865522278U, 
        (u32 const   )3633334344U,      (u32 const   )84280067U,      (u32 const   )33027830U,      (u32 const   )303828494U, 
        (u32 const   )2747425121U,      (u32 const   )1600795957U,      (u32 const   )4188952407U,      (u32 const   )3496589753U, 
        (u32 const   )2434238086U,      (u32 const   )1486471617U,      (u32 const   )658119965U,      (u32 const   )3106381470U, 
        (u32 const   )953803233U,      (u32 const   )334231800U,      (u32 const   )3005978776U,      (u32 const   )857870609U, 
        (u32 const   )3151128937U,      (u32 const   )1890179545U,      (u32 const   )2298973838U,      (u32 const   )2805175444U, 
        (u32 const   )3056442267U,      (u32 const   )574365214U,      (u32 const   )2450884487U,      (u32 const   )550103529U, 
        (u32 const   )1233637070U,      (u32 const   )4289353045U,      (u32 const   )2018519080U,      (u32 const   )2057691103U, 
        (u32 const   )2399374476U,      (u32 const   )4166623649U,      (u32 const   )2148108681U,      (u32 const   )387583245U, 
        (u32 const   )3664101311U,      (u32 const   )836232934U,      (u32 const   )3330556482U,      (u32 const   )3100665960U, 
        (u32 const   )3280093505U,      (u32 const   )2955516313U,      (u32 const   )2002398509U,      (u32 const   )287182607U, 
        (u32 const   )3413881008U,      (u32 const   )4238890068U,      (u32 const   )3597515707U,      (u32 const   )975967766U};
#line 183 "rijndael.c"
static u32 const   Te2[256]  = 
#line 183
  {      (u32 const   )1671808611U,      (u32 const   )2089089148U,      (u32 const   )2006576759U,      (u32 const   )2072901243U, 
        (u32 const   )4061003762U,      (u32 const   )1807603307U,      (u32 const   )1873927791U,      (u32 const   )3310653893U, 
        (u32 const   )810573872U,      (u32 const   )16974337U,      (u32 const   )1739181671U,      (u32 const   )729634347U, 
        (u32 const   )4263110654U,      (u32 const   )3613570519U,      (u32 const   )2883997099U,      (u32 const   )1989864566U, 
        (u32 const   )3393556426U,      (u32 const   )2191335298U,      (u32 const   )3376449993U,      (u32 const   )2106063485U, 
        (u32 const   )4195741690U,      (u32 const   )1508618841U,      (u32 const   )1204391495U,      (u32 const   )4027317232U, 
        (u32 const   )2917941677U,      (u32 const   )3563566036U,      (u32 const   )2734514082U,      (u32 const   )2951366063U, 
        (u32 const   )2629772188U,      (u32 const   )2767672228U,      (u32 const   )1922491506U,      (u32 const   )3227229120U, 
        (u32 const   )3082974647U,      (u32 const   )4246528509U,      (u32 const   )2477669779U,      (u32 const   )644500518U, 
        (u32 const   )911895606U,      (u32 const   )1061256767U,      (u32 const   )4144166391U,      (u32 const   )3427763148U, 
        (u32 const   )878471220U,      (u32 const   )2784252325U,      (u32 const   )3845444069U,      (u32 const   )4043897329U, 
        (u32 const   )1905517169U,      (u32 const   )3631459288U,      (u32 const   )827548209U,      (u32 const   )356461077U, 
        (u32 const   )67897348U,      (u32 const   )3344078279U,      (u32 const   )593839651U,      (u32 const   )3277757891U, 
        (u32 const   )405286936U,      (u32 const   )2527147926U,      (u32 const   )84871685U,      (u32 const   )2595565466U, 
        (u32 const   )118033927U,      (u32 const   )305538066U,      (u32 const   )2157648768U,      (u32 const   )3795705826U, 
        (u32 const   )3945188843U,      (u32 const   )661212711U,      (u32 const   )2999812018U,      (u32 const   )1973414517U, 
        (u32 const   )152769033U,      (u32 const   )2208177539U,      (u32 const   )745822252U,      (u32 const   )439235610U, 
        (u32 const   )455947803U,      (u32 const   )1857215598U,      (u32 const   )1525593178U,      (u32 const   )2700827552U, 
        (u32 const   )1391895634U,      (u32 const   )994932283U,      (u32 const   )3596728278U,      (u32 const   )3016654259U, 
        (u32 const   )695947817U,      (u32 const   )3812548067U,      (u32 const   )795958831U,      (u32 const   )2224493444U, 
        (u32 const   )1408607827U,      (u32 const   )3513301457U,      (u32 const   )0U,      (u32 const   )3979133421U, 
        (u32 const   )543178784U,      (u32 const   )4229948412U,      (u32 const   )2982705585U,      (u32 const   )1542305371U, 
        (u32 const   )1790891114U,      (u32 const   )3410398667U,      (u32 const   )3201918910U,      (u32 const   )961245753U, 
        (u32 const   )1256100938U,      (u32 const   )1289001036U,      (u32 const   )1491644504U,      (u32 const   )3477767631U, 
        (u32 const   )3496721360U,      (u32 const   )4012557807U,      (u32 const   )2867154858U,      (u32 const   )4212583931U, 
        (u32 const   )1137018435U,      (u32 const   )1305975373U,      (u32 const   )861234739U,      (u32 const   )2241073541U, 
        (u32 const   )1171229253U,      (u32 const   )4178635257U,      (u32 const   )33948674U,      (u32 const   )2139225727U, 
        (u32 const   )1357946960U,      (u32 const   )1011120188U,      (u32 const   )2679776671U,      (u32 const   )2833468328U, 
        (u32 const   )1374921297U,      (u32 const   )2751356323U,      (u32 const   )1086357568U,      (u32 const   )2408187279U, 
        (u32 const   )2460827538U,      (u32 const   )2646352285U,      (u32 const   )944271416U,      (u32 const   )4110742005U, 
        (u32 const   )3168756668U,      (u32 const   )3066132406U,      (u32 const   )3665145818U,      (u32 const   )560153121U, 
        (u32 const   )271589392U,      (u32 const   )4279952895U,      (u32 const   )4077846003U,      (u32 const   )3530407890U, 
        (u32 const   )3444343245U,      (u32 const   )202643468U,      (u32 const   )322250259U,      (u32 const   )3962553324U, 
        (u32 const   )1608629855U,      (u32 const   )2543990167U,      (u32 const   )1154254916U,      (u32 const   )389623319U, 
        (u32 const   )3294073796U,      (u32 const   )2817676711U,      (u32 const   )2122513534U,      (u32 const   )1028094525U, 
        (u32 const   )1689045092U,      (u32 const   )1575467613U,      (u32 const   )422261273U,      (u32 const   )1939203699U, 
        (u32 const   )1621147744U,      (u32 const   )2174228865U,      (u32 const   )1339137615U,      (u32 const   )3699352540U, 
        (u32 const   )577127458U,      (u32 const   )712922154U,      (u32 const   )2427141008U,      (u32 const   )2290289544U, 
        (u32 const   )1187679302U,      (u32 const   )3995715566U,      (u32 const   )3100863416U,      (u32 const   )339486740U, 
        (u32 const   )3732514782U,      (u32 const   )1591917662U,      (u32 const   )186455563U,      (u32 const   )3681988059U, 
        (u32 const   )3762019296U,      (u32 const   )844522546U,      (u32 const   )978220090U,      (u32 const   )169743370U, 
        (u32 const   )1239126601U,      (u32 const   )101321734U,      (u32 const   )611076132U,      (u32 const   )1558493276U, 
        (u32 const   )3260915650U,      (u32 const   )3547250131U,      (u32 const   )2901361580U,      (u32 const   )1655096418U, 
        (u32 const   )2443721105U,      (u32 const   )2510565781U,      (u32 const   )3828863972U,      (u32 const   )2039214713U, 
        (u32 const   )3878868455U,      (u32 const   )3359869896U,      (u32 const   )928607799U,      (u32 const   )1840765549U, 
        (u32 const   )2374762893U,      (u32 const   )3580146133U,      (u32 const   )1322425422U,      (u32 const   )2850048425U, 
        (u32 const   )1823791212U,      (u32 const   )1459268694U,      (u32 const   )4094161908U,      (u32 const   )3928346602U, 
        (u32 const   )1706019429U,      (u32 const   )2056189050U,      (u32 const   )2934523822U,      (u32 const   )135794696U, 
        (u32 const   )3134549946U,      (u32 const   )2022240376U,      (u32 const   )628050469U,      (u32 const   )779246638U, 
        (u32 const   )472135708U,      (u32 const   )2800834470U,      (u32 const   )3032970164U,      (u32 const   )3327236038U, 
        (u32 const   )3894660072U,      (u32 const   )3715932637U,      (u32 const   )1956440180U,      (u32 const   )522272287U, 
        (u32 const   )1272813131U,      (u32 const   )3185336765U,      (u32 const   )2340818315U,      (u32 const   )2323976074U, 
        (u32 const   )1888542832U,      (u32 const   )1044544574U,      (u32 const   )3049550261U,      (u32 const   )1722469478U, 
        (u32 const   )1222152264U,      (u32 const   )50660867U,      (u32 const   )4127324150U,      (u32 const   )236067854U, 
        (u32 const   )1638122081U,      (u32 const   )895445557U,      (u32 const   )1475980887U,      (u32 const   )3117443513U, 
        (u32 const   )2257655686U,      (u32 const   )3243809217U,      (u32 const   )489110045U,      (u32 const   )2662934430U, 
        (u32 const   )3778599393U,      (u32 const   )4162055160U,      (u32 const   )2561878936U,      (u32 const   )288563729U, 
        (u32 const   )1773916777U,      (u32 const   )3648039385U,      (u32 const   )2391345038U,      (u32 const   )2493985684U, 
        (u32 const   )2612407707U,      (u32 const   )505560094U,      (u32 const   )2274497927U,      (u32 const   )3911240169U, 
        (u32 const   )3460925390U,      (u32 const   )1442818645U,      (u32 const   )678973480U,      (u32 const   )3749357023U, 
        (u32 const   )2358182796U,      (u32 const   )2717407649U,      (u32 const   )2306869641U,      (u32 const   )219617805U, 
        (u32 const   )3218761151U,      (u32 const   )3862026214U,      (u32 const   )1120306242U,      (u32 const   )1756942440U, 
        (u32 const   )1103331905U,      (u32 const   )2578459033U,      (u32 const   )762796589U,      (u32 const   )252780047U, 
        (u32 const   )2966125488U,      (u32 const   )1425844308U,      (u32 const   )3151392187U,      (u32 const   )372911126U};
#line 249 "rijndael.c"
static u32 const   Te3[256]  = 
#line 249
  {      (u32 const   )1667474886U,      (u32 const   )2088535288U,      (u32 const   )2004326894U,      (u32 const   )2071694838U, 
        (u32 const   )4075949567U,      (u32 const   )1802223062U,      (u32 const   )1869591006U,      (u32 const   )3318043793U, 
        (u32 const   )808472672U,      (u32 const   )16843522U,      (u32 const   )1734846926U,      (u32 const   )724270422U, 
        (u32 const   )4278065639U,      (u32 const   )3621216949U,      (u32 const   )2880169549U,      (u32 const   )1987484396U, 
        (u32 const   )3402253711U,      (u32 const   )2189597983U,      (u32 const   )3385409673U,      (u32 const   )2105378810U, 
        (u32 const   )4210693615U,      (u32 const   )1499065266U,      (u32 const   )1195886990U,      (u32 const   )4042263547U, 
        (u32 const   )2913856577U,      (u32 const   )3570689971U,      (u32 const   )2728590687U,      (u32 const   )2947541573U, 
        (u32 const   )2627518243U,      (u32 const   )2762274643U,      (u32 const   )1920112356U,      (u32 const   )3233831835U, 
        (u32 const   )3082273397U,      (u32 const   )4261223649U,      (u32 const   )2475929149U,      (u32 const   )640051788U, 
        (u32 const   )909531756U,      (u32 const   )1061110142U,      (u32 const   )4160160501U,      (u32 const   )3435941763U, 
        (u32 const   )875846760U,      (u32 const   )2779116625U,      (u32 const   )3857003729U,      (u32 const   )4059105529U, 
        (u32 const   )1903268834U,      (u32 const   )3638064043U,      (u32 const   )825316194U,      (u32 const   )353713962U, 
        (u32 const   )67374088U,      (u32 const   )3351728789U,      (u32 const   )589522246U,      (u32 const   )3284360861U, 
        (u32 const   )404236336U,      (u32 const   )2526454071U,      (u32 const   )84217610U,      (u32 const   )2593830191U, 
        (u32 const   )117901582U,      (u32 const   )303183396U,      (u32 const   )2155911963U,      (u32 const   )3806477791U, 
        (u32 const   )3958056653U,      (u32 const   )656894286U,      (u32 const   )2998062463U,      (u32 const   )1970642922U, 
        (u32 const   )151591698U,      (u32 const   )2206440989U,      (u32 const   )741110872U,      (u32 const   )437923380U, 
        (u32 const   )454765878U,      (u32 const   )1852748508U,      (u32 const   )1515908788U,      (u32 const   )2694904667U, 
        (u32 const   )1381168804U,      (u32 const   )993742198U,      (u32 const   )3604373943U,      (u32 const   )3014905469U, 
        (u32 const   )690584402U,      (u32 const   )3823320797U,      (u32 const   )791638366U,      (u32 const   )2223281939U, 
        (u32 const   )1398011302U,      (u32 const   )3520161977U,      (u32 const   )0U,      (u32 const   )3991743681U, 
        (u32 const   )538992704U,      (u32 const   )4244381667U,      (u32 const   )2981218425U,      (u32 const   )1532751286U, 
        (u32 const   )1785380564U,      (u32 const   )3419096717U,      (u32 const   )3200178535U,      (u32 const   )960056178U, 
        (u32 const   )1246420628U,      (u32 const   )1280103576U,      (u32 const   )1482221744U,      (u32 const   )3486468741U, 
        (u32 const   )3503319995U,      (u32 const   )4025428677U,      (u32 const   )2863326543U,      (u32 const   )4227536621U, 
        (u32 const   )1128514950U,      (u32 const   )1296947098U,      (u32 const   )859002214U,      (u32 const   )2240123921U, 
        (u32 const   )1162203018U,      (u32 const   )4193849577U,      (u32 const   )33687044U,      (u32 const   )2139062782U, 
        (u32 const   )1347481760U,      (u32 const   )1010582648U,      (u32 const   )2678045221U,      (u32 const   )2829640523U, 
        (u32 const   )1364325282U,      (u32 const   )2745433693U,      (u32 const   )1077985408U,      (u32 const   )2408548869U, 
        (u32 const   )2459086143U,      (u32 const   )2644360225U,      (u32 const   )943212656U,      (u32 const   )4126475505U, 
        (u32 const   )3166494563U,      (u32 const   )3065430391U,      (u32 const   )3671750063U,      (u32 const   )555836226U, 
        (u32 const   )269496352U,      (u32 const   )4294908645U,      (u32 const   )4092792573U,      (u32 const   )3537006015U, 
        (u32 const   )3452783745U,      (u32 const   )202118168U,      (u32 const   )320025894U,      (u32 const   )3974901699U, 
        (u32 const   )1600119230U,      (u32 const   )2543297077U,      (u32 const   )1145359496U,      (u32 const   )387397934U, 
        (u32 const   )3301201811U,      (u32 const   )2812801621U,      (u32 const   )2122220284U,      (u32 const   )1027426170U, 
        (u32 const   )1684319432U,      (u32 const   )1566435258U,      (u32 const   )421079858U,      (u32 const   )1936954854U, 
        (u32 const   )1616945344U,      (u32 const   )2172753945U,      (u32 const   )1330631070U,      (u32 const   )3705438115U, 
        (u32 const   )572679748U,      (u32 const   )707427924U,      (u32 const   )2425400123U,      (u32 const   )2290647819U, 
        (u32 const   )1179044492U,      (u32 const   )4008585671U,      (u32 const   )3099120491U,      (u32 const   )336870440U, 
        (u32 const   )3739122087U,      (u32 const   )1583276732U,      (u32 const   )185277718U,      (u32 const   )3688593069U, 
        (u32 const   )3772791771U,      (u32 const   )842159716U,      (u32 const   )976899700U,      (u32 const   )168435220U, 
        (u32 const   )1229577106U,      (u32 const   )101059084U,      (u32 const   )606366792U,      (u32 const   )1549591736U, 
        (u32 const   )3267517855U,      (u32 const   )3553849021U,      (u32 const   )2897014595U,      (u32 const   )1650632388U, 
        (u32 const   )2442242105U,      (u32 const   )2509612081U,      (u32 const   )3840161747U,      (u32 const   )2038008818U, 
        (u32 const   )3890688725U,      (u32 const   )3368567691U,      (u32 const   )926374254U,      (u32 const   )1835907034U, 
        (u32 const   )2374863873U,      (u32 const   )3587531953U,      (u32 const   )1313788572U,      (u32 const   )2846482505U, 
        (u32 const   )1819063512U,      (u32 const   )1448540844U,      (u32 const   )4109633523U,      (u32 const   )3941213647U, 
        (u32 const   )1701162954U,      (u32 const   )2054852340U,      (u32 const   )2930698567U,      (u32 const   )134748176U, 
        (u32 const   )3132806511U,      (u32 const   )2021165296U,      (u32 const   )623210314U,      (u32 const   )774795868U, 
        (u32 const   )471606328U,      (u32 const   )2795958615U,      (u32 const   )3031746419U,      (u32 const   )3334885783U, 
        (u32 const   )3907527627U,      (u32 const   )3722280097U,      (u32 const   )1953799400U,      (u32 const   )522133822U, 
        (u32 const   )1263263126U,      (u32 const   )3183336545U,      (u32 const   )2341176845U,      (u32 const   )2324333839U, 
        (u32 const   )1886425312U,      (u32 const   )1044267644U,      (u32 const   )3048588401U,      (u32 const   )1718004428U, 
        (u32 const   )1212733584U,      (u32 const   )50529542U,      (u32 const   )4143317495U,      (u32 const   )235803164U, 
        (u32 const   )1633788866U,      (u32 const   )892690282U,      (u32 const   )1465383342U,      (u32 const   )3115962473U, 
        (u32 const   )2256965911U,      (u32 const   )3250673817U,      (u32 const   )488449850U,      (u32 const   )2661202215U, 
        (u32 const   )3789633753U,      (u32 const   )4177007595U,      (u32 const   )2560144171U,      (u32 const   )286339874U, 
        (u32 const   )1768537042U,      (u32 const   )3654906025U,      (u32 const   )2391705863U,      (u32 const   )2492770099U, 
        (u32 const   )2610673197U,      (u32 const   )505291324U,      (u32 const   )2273808917U,      (u32 const   )3924369609U, 
        (u32 const   )3469625735U,      (u32 const   )1431699370U,      (u32 const   )673740880U,      (u32 const   )3755965093U, 
        (u32 const   )2358021891U,      (u32 const   )2711746649U,      (u32 const   )2307489801U,      (u32 const   )218961690U, 
        (u32 const   )3217021541U,      (u32 const   )3873845719U,      (u32 const   )1111672452U,      (u32 const   )1751693520U, 
        (u32 const   )1094828930U,      (u32 const   )2576986153U,      (u32 const   )757954394U,      (u32 const   )252645662U, 
        (u32 const   )2964376443U,      (u32 const   )1414855848U,      (u32 const   )3149649517U,      (u32 const   )370555436U};
#line 316 "rijndael.c"
static u32 const   Te4[256]  = 
#line 316
  {      (u32 const   )1667457891U,      (u32 const   )2088533116U,      (u32 const   )2004318071U,      (u32 const   )2071690107U, 
        (u32 const   )4076008178U,      (u32 const   )1802201963U,      (u32 const   )1869573999U,      (u32 const   )3318072773U, 
        (u32 const   )808464432U,      (u32 const   )16843009U,      (u32 const   )1734829927U,      (u32 const   )724249387U, 
        (u32 const   )4278124286U,      (u32 const   )3621246935U,      (u32 const   )2880154539U,      (u32 const   )1987475062U, 
        (u32 const   )3402287818U,      (u32 const   )2189591170U,      (u32 const   )3385444809U,      (u32 const   )2105376125U, 
        (u32 const   )4210752250U,      (u32 const   )1499027801U,      (u32 const   )1195853639U,      (u32 const   )4042322160U, 
        (u32 const   )2913840557U,      (u32 const   )3570717908U,      (u32 const   )2728567458U,      (u32 const   )2947526575U, 
        (u32 const   )2627509404U,      (u32 const   )2762253476U,      (u32 const   )1920103026U,      (u32 const   )3233857728U, 
        (u32 const   )3082270647U,      (u32 const   )4261281277U,      (u32 const   )2475922323U,      (u32 const   )640034342U, 
        (u32 const   )909522486U,      (u32 const   )1061109567U,      (u32 const   )4160223223U,      (u32 const   )3435973836U, 
        (u32 const   )875836468U,      (u32 const   )2779096485U,      (u32 const   )3857049061U,      (u32 const   )4059165169U, 
        (u32 const   )1903260017U,      (u32 const   )3638089944U,      (u32 const   )825307441U,      (u32 const   )353703189U, 
        (u32 const   )67372036U,      (u32 const   )3351758791U,      (u32 const   )589505315U,      (u32 const   )3284386755U, 
        (u32 const   )404232216U,      (u32 const   )2526451350U,      (u32 const   )84215045U,      (u32 const   )2593823386U, 
        (u32 const   )117901063U,      (u32 const   )303174162U,      (u32 const   )2155905152U,      (u32 const   )3806520034U, 
        (u32 const   )3958107115U,      (u32 const   )656877351U,      (u32 const   )2998055602U,      (u32 const   )1970632053U, 
        (u32 const   )151587081U,      (u32 const   )2206434179U,      (u32 const   )741092396U,      (u32 const   )437918234U, 
        (u32 const   )454761243U,      (u32 const   )1852730990U,      (u32 const   )1515870810U,      (u32 const   )2694881440U, 
        (u32 const   )1381126738U,      (u32 const   )993737531U,      (u32 const   )3604403926U,      (u32 const   )3014898611U, 
        (u32 const   )690563369U,      (u32 const   )3823363043U,      (u32 const   )791621423U,      (u32 const   )2223277188U, 
        (u32 const   )1397969747U,      (u32 const   )3520188881U,      (u32 const   )0U,      (u32 const   )3991793133U, 
        (u32 const   )538976288U,      (u32 const   )4244438268U,      (u32 const   )2981212593U,      (u32 const   )1532713819U, 
        (u32 const   )1785358954U,      (u32 const   )3419130827U,      (u32 const   )3200171710U,      (u32 const   )960051513U, 
        (u32 const   )1246382666U,      (u32 const   )1280068684U,      (u32 const   )1482184792U,      (u32 const   )3486502863U, 
        (u32 const   )3503345872U,      (u32 const   )4025479151U,      (u32 const   )2863311530U,      (u32 const   )4227595259U, 
        (u32 const   )1128481603U,      (u32 const   )1296911693U,      (u32 const   )858993459U,      (u32 const   )2240120197U, 
        (u32 const   )1162167621U,      (u32 const   )4193909241U,      (u32 const   )33686018U,      (u32 const   )2139062143U, 
        (u32 const   )1347440720U,      (u32 const   )1010580540U,      (u32 const   )2678038431U,      (u32 const   )2829625512U, 
        (u32 const   )1364283729U,      (u32 const   )2745410467U,      (u32 const   )1077952576U,      (u32 const   )2408550287U, 
        (u32 const   )2459079314U,      (u32 const   )2644352413U,      (u32 const   )943208504U,      (u32 const   )4126537205U, 
        (u32 const   )3166485692U,      (u32 const   )3065427638U,      (u32 const   )3671775962U,      (u32 const   )555819297U, 
        (u32 const   )269488144U,      (u32 const   )4294967295U,      (u32 const   )4092851187U,      (u32 const   )3537031890U, 
        (u32 const   )3452816845U,      (u32 const   )202116108U,      (u32 const   )320017171U,      (u32 const   )3974950124U, 
        (u32 const   )1600085855U,      (u32 const   )2543294359U,      (u32 const   )1145324612U,      (u32 const   )387389207U, 
        (u32 const   )3301229764U,      (u32 const   )2812782503U,      (u32 const   )2122219134U,      (u32 const   )1027423549U, 
        (u32 const   )1684300900U,      (u32 const   )1566399837U,      (u32 const   )421075225U,      (u32 const   )1936946035U, 
        (u32 const   )1616928864U,      (u32 const   )2172748161U,      (u32 const   )1330597711U,      (u32 const   )3705461980U, 
        (u32 const   )572662306U,      (u32 const   )707406378U,      (u32 const   )2425393296U,      (u32 const   )2290649224U, 
        (u32 const   )1179010630U,      (u32 const   )4008636142U,      (u32 const   )3099113656U,      (u32 const   )336860180U, 
        (u32 const   )3739147998U,      (u32 const   )1583242846U,      (u32 const   )185273099U,      (u32 const   )3688618971U, 
        (u32 const   )3772834016U,      (u32 const   )842150450U,      (u32 const   )976894522U,      (u32 const   )168430090U, 
        (u32 const   )1229539657U,      (u32 const   )101058054U,      (u32 const   )606348324U,      (u32 const   )1549556828U, 
        (u32 const   )3267543746U,      (u32 const   )3553874899U,      (u32 const   )2896997548U,      (u32 const   )1650614882U, 
        (u32 const   )2442236305U,      (u32 const   )2509608341U,      (u32 const   )3840206052U,      (u32 const   )2038004089U, 
        (u32 const   )3890735079U,      (u32 const   )3368601800U,      (u32 const   )926365495U,      (u32 const   )1835887981U, 
        (u32 const   )2374864269U,      (u32 const   )3587560917U,      (u32 const   )1313754702U,      (u32 const   )2846468521U, 
        (u32 const   )1819044972U,      (u32 const   )1448498774U,      (u32 const   )4109694196U,      (u32 const   )3941264106U, 
        (u32 const   )1701143909U,      (u32 const   )2054847098U,      (u32 const   )2930683566U,      (u32 const   )134744072U, 
        (u32 const   )3132799674U,      (u32 const   )2021161080U,      (u32 const   )623191333U,      (u32 const   )774778414U, 
        (u32 const   )471604252U,      (u32 const   )2795939494U,      (u32 const   )3031741620U,      (u32 const   )3334915782U, 
        (u32 const   )3907578088U,      (u32 const   )3722304989U,      (u32 const   )1953789044U,      (u32 const   )522133279U, 
        (u32 const   )1263225675U,      (u32 const   )3183328701U,      (u32 const   )2341178251U,      (u32 const   )2324335242U, 
        (u32 const   )1886417008U,      (u32 const   )1044266558U,      (u32 const   )3048584629U,      (u32 const   )1717986918U, 
        (u32 const   )1212696648U,      (u32 const   )50529027U,      (u32 const   )4143380214U,      (u32 const   )235802126U, 
        (u32 const   )1633771873U,      (u32 const   )892679477U,      (u32 const   )1465341783U,      (u32 const   )3115956665U, 
        (u32 const   )2256963206U,      (u32 const   )3250700737U,      (u32 const   )488447261U,      (u32 const   )2661195422U, 
        (u32 const   )3789677025U,      (u32 const   )4177066232U,      (u32 const   )2560137368U,      (u32 const   )286331153U, 
        (u32 const   )1768515945U,      (u32 const   )3654932953U,      (u32 const   )2391707278U,      (u32 const   )2492765332U, 
        (u32 const   )2610666395U,      (u32 const   )505290270U,      (u32 const   )2273806215U,      (u32 const   )3924421097U, 
        (u32 const   )3469659854U,      (u32 const   )1431655765U,      (u32 const   )673720360U,      (u32 const   )3755991007U, 
        (u32 const   )2358021260U,      (u32 const   )2711724449U,      (u32 const   )2307492233U,      (u32 const   )218959117U, 
        (u32 const   )3217014719U,      (u32 const   )3873892070U,      (u32 const   )1111638594U,      (u32 const   )1751672936U, 
        (u32 const   )1094795585U,      (u32 const   )2576980377U,      (u32 const   )757935405U,      (u32 const   )252645135U, 
        (u32 const   )2964369584U,      (u32 const   )1414812756U,      (u32 const   )3149642683U,      (u32 const   )370546198U};
#line 382 "rijndael.c"
static u32 const   Td0[256]  = 
#line 382
  {      (u32 const   )1374988112U,      (u32 const   )2118214995U,      (u32 const   )437757123U,      (u32 const   )975658646U, 
        (u32 const   )1001089995U,      (u32 const   )530400753U,      (u32 const   )2902087851U,      (u32 const   )1273168787U, 
        (u32 const   )540080725U,      (u32 const   )2910219766U,      (u32 const   )2295101073U,      (u32 const   )4110568485U, 
        (u32 const   )1340463100U,      (u32 const   )3307916247U,      (u32 const   )641025152U,      (u32 const   )3043140495U, 
        (u32 const   )3736164937U,      (u32 const   )632953703U,      (u32 const   )1172967064U,      (u32 const   )1576976609U, 
        (u32 const   )3274667266U,      (u32 const   )2169303058U,      (u32 const   )2370213795U,      (u32 const   )1809054150U, 
        (u32 const   )59727847U,      (u32 const   )361929877U,      (u32 const   )3211623147U,      (u32 const   )2505202138U, 
        (u32 const   )3569255213U,      (u32 const   )1484005843U,      (u32 const   )1239443753U,      (u32 const   )2395588676U, 
        (u32 const   )1975683434U,      (u32 const   )4102977912U,      (u32 const   )2572697195U,      (u32 const   )666464733U, 
        (u32 const   )3202437046U,      (u32 const   )4035489047U,      (u32 const   )3374361702U,      (u32 const   )2110667444U, 
        (u32 const   )1675577880U,      (u32 const   )3843699074U,      (u32 const   )2538681184U,      (u32 const   )1649639237U, 
        (u32 const   )2976151520U,      (u32 const   )3144396420U,      (u32 const   )4269907996U,      (u32 const   )4178062228U, 
        (u32 const   )1883793496U,      (u32 const   )2403728665U,      (u32 const   )2497604743U,      (u32 const   )1383856311U, 
        (u32 const   )2876494627U,      (u32 const   )1917518562U,      (u32 const   )3810496343U,      (u32 const   )1716890410U, 
        (u32 const   )3001755655U,      (u32 const   )800440835U,      (u32 const   )2261089178U,      (u32 const   )3543599269U, 
        (u32 const   )807962610U,      (u32 const   )599762354U,      (u32 const   )33778362U,      (u32 const   )3977675356U, 
        (u32 const   )2328828971U,      (u32 const   )2809771154U,      (u32 const   )4077384432U,      (u32 const   )1315562145U, 
        (u32 const   )1708848333U,      (u32 const   )101039829U,      (u32 const   )3509871135U,      (u32 const   )3299278474U, 
        (u32 const   )875451293U,      (u32 const   )2733856160U,      (u32 const   )92987698U,      (u32 const   )2767645557U, 
        (u32 const   )193195065U,      (u32 const   )1080094634U,      (u32 const   )1584504582U,      (u32 const   )3178106961U, 
        (u32 const   )1042385657U,      (u32 const   )2531067453U,      (u32 const   )3711829422U,      (u32 const   )1306967366U, 
        (u32 const   )2438237621U,      (u32 const   )1908694277U,      (u32 const   )67556463U,      (u32 const   )1615861247U, 
        (u32 const   )429456164U,      (u32 const   )3602770327U,      (u32 const   )2302690252U,      (u32 const   )1742315127U, 
        (u32 const   )2968011453U,      (u32 const   )126454664U,      (u32 const   )3877198648U,      (u32 const   )2043211483U, 
        (u32 const   )2709260871U,      (u32 const   )2084704233U,      (u32 const   )4169408201U,      (u32 const   )0U, 
        (u32 const   )159417987U,      (u32 const   )841739592U,      (u32 const   )504459436U,      (u32 const   )1817866830U, 
        (u32 const   )4245618683U,      (u32 const   )260388950U,      (u32 const   )1034867998U,      (u32 const   )908933415U, 
        (u32 const   )168810852U,      (u32 const   )1750902305U,      (u32 const   )2606453969U,      (u32 const   )607530554U, 
        (u32 const   )202008497U,      (u32 const   )2472011535U,      (u32 const   )3035535058U,      (u32 const   )463180190U, 
        (u32 const   )2160117071U,      (u32 const   )1641816226U,      (u32 const   )1517767529U,      (u32 const   )470948374U, 
        (u32 const   )3801332234U,      (u32 const   )3231722213U,      (u32 const   )1008918595U,      (u32 const   )303765277U, 
        (u32 const   )235474187U,      (u32 const   )4069246893U,      (u32 const   )766945465U,      (u32 const   )337553864U, 
        (u32 const   )1475418501U,      (u32 const   )2943682380U,      (u32 const   )4003061179U,      (u32 const   )2743034109U, 
        (u32 const   )4144047775U,      (u32 const   )1551037884U,      (u32 const   )1147550661U,      (u32 const   )1543208500U, 
        (u32 const   )2336434550U,      (u32 const   )3408119516U,      (u32 const   )3069049960U,      (u32 const   )3102011747U, 
        (u32 const   )3610369226U,      (u32 const   )1113818384U,      (u32 const   )328671808U,      (u32 const   )2227573024U, 
        (u32 const   )2236228733U,      (u32 const   )3535486456U,      (u32 const   )2935566865U,      (u32 const   )3341394285U, 
        (u32 const   )496906059U,      (u32 const   )3702665459U,      (u32 const   )226906860U,      (u32 const   )2009195472U, 
        (u32 const   )733156972U,      (u32 const   )2842737049U,      (u32 const   )294930682U,      (u32 const   )1206477858U, 
        (u32 const   )2835123396U,      (u32 const   )2700099354U,      (u32 const   )1451044056U,      (u32 const   )573804783U, 
        (u32 const   )2269728455U,      (u32 const   )3644379585U,      (u32 const   )2362090238U,      (u32 const   )2564033334U, 
        (u32 const   )2801107407U,      (u32 const   )2776292904U,      (u32 const   )3669462566U,      (u32 const   )1068351396U, 
        (u32 const   )742039012U,      (u32 const   )1350078989U,      (u32 const   )1784663195U,      (u32 const   )1417561698U, 
        (u32 const   )4136440770U,      (u32 const   )2430122216U,      (u32 const   )775550814U,      (u32 const   )2193862645U, 
        (u32 const   )2673705150U,      (u32 const   )1775276924U,      (u32 const   )1876241833U,      (u32 const   )3475313331U, 
        (u32 const   )3366754619U,      (u32 const   )270040487U,      (u32 const   )3902563182U,      (u32 const   )3678124923U, 
        (u32 const   )3441850377U,      (u32 const   )1851332852U,      (u32 const   )3969562369U,      (u32 const   )2203032232U, 
        (u32 const   )3868552805U,      (u32 const   )2868897406U,      (u32 const   )566021896U,      (u32 const   )4011190502U, 
        (u32 const   )3135740889U,      (u32 const   )1248802510U,      (u32 const   )3936291284U,      (u32 const   )699432150U, 
        (u32 const   )832877231U,      (u32 const   )708780849U,      (u32 const   )3332740144U,      (u32 const   )899835584U, 
        (u32 const   )1951317047U,      (u32 const   )4236429990U,      (u32 const   )3767586992U,      (u32 const   )866637845U, 
        (u32 const   )4043610186U,      (u32 const   )1106041591U,      (u32 const   )2144161806U,      (u32 const   )395441711U, 
        (u32 const   )1984812685U,      (u32 const   )1139781709U,      (u32 const   )3433712980U,      (u32 const   )3835036895U, 
        (u32 const   )2664543715U,      (u32 const   )1282050075U,      (u32 const   )3240894392U,      (u32 const   )1181045119U, 
        (u32 const   )2640243204U,      (u32 const   )25965917U,      (u32 const   )4203181171U,      (u32 const   )4211818798U, 
        (u32 const   )3009879386U,      (u32 const   )2463879762U,      (u32 const   )3910161971U,      (u32 const   )1842759443U, 
        (u32 const   )2597806476U,      (u32 const   )933301370U,      (u32 const   )1509430414U,      (u32 const   )3943906441U, 
        (u32 const   )3467192302U,      (u32 const   )3076639029U,      (u32 const   )3776767469U,      (u32 const   )2051518780U, 
        (u32 const   )2631065433U,      (u32 const   )1441952575U,      (u32 const   )404016761U,      (u32 const   )1942435775U, 
        (u32 const   )1408749034U,      (u32 const   )1610459739U,      (u32 const   )3745345300U,      (u32 const   )2017778566U, 
        (u32 const   )3400528769U,      (u32 const   )3110650942U,      (u32 const   )941896748U,      (u32 const   )3265478751U, 
        (u32 const   )371049330U,      (u32 const   )3168937228U,      (u32 const   )675039627U,      (u32 const   )4279080257U, 
        (u32 const   )967311729U,      (u32 const   )135050206U,      (u32 const   )3635733660U,      (u32 const   )1683407248U, 
        (u32 const   )2076935265U,      (u32 const   )3576870512U,      (u32 const   )1215061108U,      (u32 const   )3501741890U};
#line 448 "rijndael.c"
static u32 const   Td1[256]  = 
#line 448
  {      (u32 const   )1347548327U,      (u32 const   )1400783205U,      (u32 const   )3273267108U,      (u32 const   )2520393566U, 
        (u32 const   )3409685355U,      (u32 const   )4045380933U,      (u32 const   )2880240216U,      (u32 const   )2471224067U, 
        (u32 const   )1428173050U,      (u32 const   )4138563181U,      (u32 const   )2441661558U,      (u32 const   )636813900U, 
        (u32 const   )4233094615U,      (u32 const   )3620022987U,      (u32 const   )2149987652U,      (u32 const   )2411029155U, 
        (u32 const   )1239331162U,      (u32 const   )1730525723U,      (u32 const   )2554718734U,      (u32 const   )3781033664U, 
        (u32 const   )46346101U,      (u32 const   )310463728U,      (u32 const   )2743944855U,      (u32 const   )3328955385U, 
        (u32 const   )3875770207U,      (u32 const   )2501218972U,      (u32 const   )3955191162U,      (u32 const   )3667219033U, 
        (u32 const   )768917123U,      (u32 const   )3545789473U,      (u32 const   )692707433U,      (u32 const   )1150208456U, 
        (u32 const   )1786102409U,      (u32 const   )2029293177U,      (u32 const   )1805211710U,      (u32 const   )3710368113U, 
        (u32 const   )3065962831U,      (u32 const   )401639597U,      (u32 const   )1724457132U,      (u32 const   )3028143674U, 
        (u32 const   )409198410U,      (u32 const   )2196052529U,      (u32 const   )1620529459U,      (u32 const   )1164071807U, 
        (u32 const   )3769721975U,      (u32 const   )2226875310U,      (u32 const   )486441376U,      (u32 const   )2499348523U, 
        (u32 const   )1483753576U,      (u32 const   )428819965U,      (u32 const   )2274680428U,      (u32 const   )3075636216U, 
        (u32 const   )598438867U,      (u32 const   )3799141122U,      (u32 const   )1474502543U,      (u32 const   )711349675U, 
        (u32 const   )129166120U,      (u32 const   )53458370U,      (u32 const   )2592523643U,      (u32 const   )2782082824U, 
        (u32 const   )4063242375U,      (u32 const   )2988687269U,      (u32 const   )3120694122U,      (u32 const   )1559041666U, 
        (u32 const   )730517276U,      (u32 const   )2460449204U,      (u32 const   )4042459122U,      (u32 const   )2706270690U, 
        (u32 const   )3446004468U,      (u32 const   )3573941694U,      (u32 const   )533804130U,      (u32 const   )2328143614U, 
        (u32 const   )2637442643U,      (u32 const   )2695033685U,      (u32 const   )839224033U,      (u32 const   )1973745387U, 
        (u32 const   )957055980U,      (u32 const   )2856345839U,      (u32 const   )106852767U,      (u32 const   )1371368976U, 
        (u32 const   )4181598602U,      (u32 const   )1033297158U,      (u32 const   )2933734917U,      (u32 const   )1179510461U, 
        (u32 const   )3046200461U,      (u32 const   )91341917U,      (u32 const   )1862534868U,      (u32 const   )4284502037U, 
        (u32 const   )605657339U,      (u32 const   )2547432937U,      (u32 const   )3431546947U,      (u32 const   )2003294622U, 
        (u32 const   )3182487618U,      (u32 const   )2282195339U,      (u32 const   )954669403U,      (u32 const   )3682191598U, 
        (u32 const   )1201765386U,      (u32 const   )3917234703U,      (u32 const   )3388507166U,      (u32 const   )0U, 
        (u32 const   )2198438022U,      (u32 const   )1211247597U,      (u32 const   )2887651696U,      (u32 const   )1315723890U, 
        (u32 const   )4227665663U,      (u32 const   )1443857720U,      (u32 const   )507358933U,      (u32 const   )657861945U, 
        (u32 const   )1678381017U,      (u32 const   )560487590U,      (u32 const   )3516619604U,      (u32 const   )975451694U, 
        (u32 const   )2970356327U,      (u32 const   )261314535U,      (u32 const   )3535072918U,      (u32 const   )2652609425U, 
        (u32 const   )1333838021U,      (u32 const   )2724322336U,      (u32 const   )1767536459U,      (u32 const   )370938394U, 
        (u32 const   )182621114U,      (u32 const   )3854606378U,      (u32 const   )1128014560U,      (u32 const   )487725847U, 
        (u32 const   )185469197U,      (u32 const   )2918353863U,      (u32 const   )3106780840U,      (u32 const   )3356761769U, 
        (u32 const   )2237133081U,      (u32 const   )1286567175U,      (u32 const   )3152976349U,      (u32 const   )4255350624U, 
        (u32 const   )2683765030U,      (u32 const   )3160175349U,      (u32 const   )3309594171U,      (u32 const   )878443390U, 
        (u32 const   )1988838185U,      (u32 const   )3704300486U,      (u32 const   )1756818940U,      (u32 const   )1673061617U, 
        (u32 const   )3403100636U,      (u32 const   )272786309U,      (u32 const   )1075025698U,      (u32 const   )545572369U, 
        (u32 const   )2105887268U,      (u32 const   )4174560061U,      (u32 const   )296679730U,      (u32 const   )1841768865U, 
        (u32 const   )1260232239U,      (u32 const   )4091327024U,      (u32 const   )3960309330U,      (u32 const   )3497509347U, 
        (u32 const   )1814803222U,      (u32 const   )2578018489U,      (u32 const   )4195456072U,      (u32 const   )575138148U, 
        (u32 const   )3299409036U,      (u32 const   )446754879U,      (u32 const   )3629546796U,      (u32 const   )4011996048U, 
        (u32 const   )3347532110U,      (u32 const   )3252238545U,      (u32 const   )4270639778U,      (u32 const   )915985419U, 
        (u32 const   )3483825537U,      (u32 const   )681933534U,      (u32 const   )651868046U,      (u32 const   )2755636671U, 
        (u32 const   )3828103837U,      (u32 const   )223377554U,      (u32 const   )2607439820U,      (u32 const   )1649704518U, 
        (u32 const   )3270937875U,      (u32 const   )3901806776U,      (u32 const   )1580087799U,      (u32 const   )4118987695U, 
        (u32 const   )3198115200U,      (u32 const   )2087309459U,      (u32 const   )2842678573U,      (u32 const   )3016697106U, 
        (u32 const   )1003007129U,      (u32 const   )2802849917U,      (u32 const   )1860738147U,      (u32 const   )2077965243U, 
        (u32 const   )164439672U,      (u32 const   )4100872472U,      (u32 const   )32283319U,      (u32 const   )2827177882U, 
        (u32 const   )1709610350U,      (u32 const   )2125135846U,      (u32 const   )136428751U,      (u32 const   )3874428392U, 
        (u32 const   )3652904859U,      (u32 const   )3460984630U,      (u32 const   )3572145929U,      (u32 const   )3593056380U, 
        (u32 const   )2939266226U,      (u32 const   )824852259U,      (u32 const   )818324884U,      (u32 const   )3224740454U, 
        (u32 const   )930369212U,      (u32 const   )2801566410U,      (u32 const   )2967507152U,      (u32 const   )355706840U, 
        (u32 const   )1257309336U,      (u32 const   )4148292826U,      (u32 const   )243256656U,      (u32 const   )790073846U, 
        (u32 const   )2373340630U,      (u32 const   )1296297904U,      (u32 const   )1422699085U,      (u32 const   )3756299780U, 
        (u32 const   )3818836405U,      (u32 const   )457992840U,      (u32 const   )3099667487U,      (u32 const   )2135319889U, 
        (u32 const   )77422314U,      (u32 const   )1560382517U,      (u32 const   )1945798516U,      (u32 const   )788204353U, 
        (u32 const   )1521706781U,      (u32 const   )1385356242U,      (u32 const   )870912086U,      (u32 const   )325965383U, 
        (u32 const   )2358957921U,      (u32 const   )2050466060U,      (u32 const   )2388260884U,      (u32 const   )2313884476U, 
        (u32 const   )4006521127U,      (u32 const   )901210569U,      (u32 const   )3990953189U,      (u32 const   )1014646705U, 
        (u32 const   )1503449823U,      (u32 const   )1062597235U,      (u32 const   )2031621326U,      (u32 const   )3212035895U, 
        (u32 const   )3931371469U,      (u32 const   )1533017514U,      (u32 const   )350174575U,      (u32 const   )2256028891U, 
        (u32 const   )2177544179U,      (u32 const   )1052338372U,      (u32 const   )741876788U,      (u32 const   )1606591296U, 
        (u32 const   )1914052035U,      (u32 const   )213705253U,      (u32 const   )2334669897U,      (u32 const   )1107234197U, 
        (u32 const   )1899603969U,      (u32 const   )3725069491U,      (u32 const   )2631447780U,      (u32 const   )2422494913U, 
        (u32 const   )1635502980U,      (u32 const   )1893020342U,      (u32 const   )1950903388U,      (u32 const   )1120974935U};
#line 514 "rijndael.c"
static u32 const   Td2[256]  = 
#line 514
  {      (u32 const   )2807058932U,      (u32 const   )1699970625U,      (u32 const   )2764249623U,      (u32 const   )1586903591U, 
        (u32 const   )1808481195U,      (u32 const   )1173430173U,      (u32 const   )1487645946U,      (u32 const   )59984867U, 
        (u32 const   )4199882800U,      (u32 const   )1844882806U,      (u32 const   )1989249228U,      (u32 const   )1277555970U, 
        (u32 const   )3623636965U,      (u32 const   )3419915562U,      (u32 const   )1149249077U,      (u32 const   )2744104290U, 
        (u32 const   )1514790577U,      (u32 const   )459744698U,      (u32 const   )244860394U,      (u32 const   )3235995134U, 
        (u32 const   )1963115311U,      (u32 const   )4027744588U,      (u32 const   )2544078150U,      (u32 const   )4190530515U, 
        (u32 const   )1608975247U,      (u32 const   )2627016082U,      (u32 const   )2062270317U,      (u32 const   )1507497298U, 
        (u32 const   )2200818878U,      (u32 const   )567498868U,      (u32 const   )1764313568U,      (u32 const   )3359936201U, 
        (u32 const   )2305455554U,      (u32 const   )2037970062U,      (u32 const   )1047239000U,      (u32 const   )1910319033U, 
        (u32 const   )1337376481U,      (u32 const   )2904027272U,      (u32 const   )2892417312U,      (u32 const   )984907214U, 
        (u32 const   )1243112415U,      (u32 const   )830661914U,      (u32 const   )861968209U,      (u32 const   )2135253587U, 
        (u32 const   )2011214180U,      (u32 const   )2927934315U,      (u32 const   )2686254721U,      (u32 const   )731183368U, 
        (u32 const   )1750626376U,      (u32 const   )4246310725U,      (u32 const   )1820824798U,      (u32 const   )4172763771U, 
        (u32 const   )3542330227U,      (u32 const   )48394827U,      (u32 const   )2404901663U,      (u32 const   )2871682645U, 
        (u32 const   )671593195U,      (u32 const   )3254988725U,      (u32 const   )2073724613U,      (u32 const   )145085239U, 
        (u32 const   )2280796200U,      (u32 const   )2779915199U,      (u32 const   )1790575107U,      (u32 const   )2187128086U, 
        (u32 const   )472615631U,      (u32 const   )3029510009U,      (u32 const   )4075877127U,      (u32 const   )3802222185U, 
        (u32 const   )4107101658U,      (u32 const   )3201631749U,      (u32 const   )1646252340U,      (u32 const   )4270507174U, 
        (u32 const   )1402811438U,      (u32 const   )1436590835U,      (u32 const   )3778151818U,      (u32 const   )3950355702U, 
        (u32 const   )3963161475U,      (u32 const   )4020912224U,      (u32 const   )2667994737U,      (u32 const   )273792366U, 
        (u32 const   )2331590177U,      (u32 const   )104699613U,      (u32 const   )95345982U,      (u32 const   )3175501286U, 
        (u32 const   )2377486676U,      (u32 const   )1560637892U,      (u32 const   )3564045318U,      (u32 const   )369057872U, 
        (u32 const   )4213447064U,      (u32 const   )3919042237U,      (u32 const   )1137477952U,      (u32 const   )2658625497U, 
        (u32 const   )1119727848U,      (u32 const   )2340947849U,      (u32 const   )1530455833U,      (u32 const   )4007360968U, 
        (u32 const   )172466556U,      (u32 const   )266959938U,      (u32 const   )516552836U,      (u32 const   )0U, 
        (u32 const   )2256734592U,      (u32 const   )3980931627U,      (u32 const   )1890328081U,      (u32 const   )1917742170U, 
        (u32 const   )4294704398U,      (u32 const   )945164165U,      (u32 const   )3575528878U,      (u32 const   )958871085U, 
        (u32 const   )3647212047U,      (u32 const   )2787207260U,      (u32 const   )1423022939U,      (u32 const   )775562294U, 
        (u32 const   )1739656202U,      (u32 const   )3876557655U,      (u32 const   )2530391278U,      (u32 const   )2443058075U, 
        (u32 const   )3310321856U,      (u32 const   )547512796U,      (u32 const   )1265195639U,      (u32 const   )437656594U, 
        (u32 const   )3121275539U,      (u32 const   )719700128U,      (u32 const   )3762502690U,      (u32 const   )387781147U, 
        (u32 const   )218828297U,      (u32 const   )3350065803U,      (u32 const   )2830708150U,      (u32 const   )2848461854U, 
        (u32 const   )428169201U,      (u32 const   )122466165U,      (u32 const   )3720081049U,      (u32 const   )1627235199U, 
        (u32 const   )648017665U,      (u32 const   )4122762354U,      (u32 const   )1002783846U,      (u32 const   )2117360635U, 
        (u32 const   )695634755U,      (u32 const   )3336358691U,      (u32 const   )4234721005U,      (u32 const   )4049844452U, 
        (u32 const   )3704280881U,      (u32 const   )2232435299U,      (u32 const   )574624663U,      (u32 const   )287343814U, 
        (u32 const   )612205898U,      (u32 const   )1039717051U,      (u32 const   )840019705U,      (u32 const   )2708326185U, 
        (u32 const   )793451934U,      (u32 const   )821288114U,      (u32 const   )1391201670U,      (u32 const   )3822090177U, 
        (u32 const   )376187827U,      (u32 const   )3113855344U,      (u32 const   )1224348052U,      (u32 const   )1679968233U, 
        (u32 const   )2361698556U,      (u32 const   )1058709744U,      (u32 const   )752375421U,      (u32 const   )2431590963U, 
        (u32 const   )1321699145U,      (u32 const   )3519142200U,      (u32 const   )2734591178U,      (u32 const   )188127444U, 
        (u32 const   )2177869557U,      (u32 const   )3727205754U,      (u32 const   )2384911031U,      (u32 const   )3215212461U, 
        (u32 const   )2648976442U,      (u32 const   )2450346104U,      (u32 const   )3432737375U,      (u32 const   )1180849278U, 
        (u32 const   )331544205U,      (u32 const   )3102249176U,      (u32 const   )4150144569U,      (u32 const   )2952102595U, 
        (u32 const   )2159976285U,      (u32 const   )2474404304U,      (u32 const   )766078933U,      (u32 const   )313773861U, 
        (u32 const   )2570832044U,      (u32 const   )2108100632U,      (u32 const   )1668212892U,      (u32 const   )3145456443U, 
        (u32 const   )2013908262U,      (u32 const   )418672217U,      (u32 const   )3070356634U,      (u32 const   )2594734927U, 
        (u32 const   )1852171925U,      (u32 const   )3867060991U,      (u32 const   )3473416636U,      (u32 const   )3907448597U, 
        (u32 const   )2614737639U,      (u32 const   )919489135U,      (u32 const   )164948639U,      (u32 const   )2094410160U, 
        (u32 const   )2997825956U,      (u32 const   )590424639U,      (u32 const   )2486224549U,      (u32 const   )1723872674U, 
        (u32 const   )3157750862U,      (u32 const   )3399941250U,      (u32 const   )3501252752U,      (u32 const   )3625268135U, 
        (u32 const   )2555048196U,      (u32 const   )3673637356U,      (u32 const   )1343127501U,      (u32 const   )4130281361U, 
        (u32 const   )3599595085U,      (u32 const   )2957853679U,      (u32 const   )1297403050U,      (u32 const   )81781910U, 
        (u32 const   )3051593425U,      (u32 const   )2283490410U,      (u32 const   )532201772U,      (u32 const   )1367295589U, 
        (u32 const   )3926170974U,      (u32 const   )895287692U,      (u32 const   )1953757831U,      (u32 const   )1093597963U, 
        (u32 const   )492483431U,      (u32 const   )3528626907U,      (u32 const   )1446242576U,      (u32 const   )1192455638U, 
        (u32 const   )1636604631U,      (u32 const   )209336225U,      (u32 const   )344873464U,      (u32 const   )1015671571U, 
        (u32 const   )669961897U,      (u32 const   )3375740769U,      (u32 const   )3857572124U,      (u32 const   )2973530695U, 
        (u32 const   )3747192018U,      (u32 const   )1933530610U,      (u32 const   )3464042516U,      (u32 const   )935293895U, 
        (u32 const   )3454686199U,      (u32 const   )2858115069U,      (u32 const   )1863638845U,      (u32 const   )3683022916U, 
        (u32 const   )4085369519U,      (u32 const   )3292445032U,      (u32 const   )875313188U,      (u32 const   )1080017571U, 
        (u32 const   )3279033885U,      (u32 const   )621591778U,      (u32 const   )1233856572U,      (u32 const   )2504130317U, 
        (u32 const   )24197544U,      (u32 const   )3017672716U,      (u32 const   )3835484340U,      (u32 const   )3247465558U, 
        (u32 const   )2220981195U,      (u32 const   )3060847922U,      (u32 const   )1551124588U,      (u32 const   )1463996600U};
#line 581 "rijndael.c"
static u32 const   Td3[256]  = 
#line 581
  {      (u32 const   )4104605777U,      (u32 const   )1097159550U,      (u32 const   )396673818U,      (u32 const   )660510266U, 
        (u32 const   )2875968315U,      (u32 const   )2638606623U,      (u32 const   )4200115116U,      (u32 const   )3808662347U, 
        (u32 const   )821712160U,      (u32 const   )1986918061U,      (u32 const   )3430322568U,      (u32 const   )38544885U, 
        (u32 const   )3856137295U,      (u32 const   )718002117U,      (u32 const   )893681702U,      (u32 const   )1654886325U, 
        (u32 const   )2975484382U,      (u32 const   )3122358053U,      (u32 const   )3926825029U,      (u32 const   )4274053469U, 
        (u32 const   )796197571U,      (u32 const   )1290801793U,      (u32 const   )1184342925U,      (u32 const   )3556361835U, 
        (u32 const   )2405426947U,      (u32 const   )2459735317U,      (u32 const   )1836772287U,      (u32 const   )1381620373U, 
        (u32 const   )3196267988U,      (u32 const   )1948373848U,      (u32 const   )3764988233U,      (u32 const   )3385345166U, 
        (u32 const   )3263785589U,      (u32 const   )2390325492U,      (u32 const   )1480485785U,      (u32 const   )3111247143U, 
        (u32 const   )3780097726U,      (u32 const   )2293045232U,      (u32 const   )548169417U,      (u32 const   )3459953789U, 
        (u32 const   )3746175075U,      (u32 const   )439452389U,      (u32 const   )1362321559U,      (u32 const   )1400849762U, 
        (u32 const   )1685577905U,      (u32 const   )1806599355U,      (u32 const   )2174754046U,      (u32 const   )137073913U, 
        (u32 const   )1214797936U,      (u32 const   )1174215055U,      (u32 const   )3731654548U,      (u32 const   )2079897426U, 
        (u32 const   )1943217067U,      (u32 const   )1258480242U,      (u32 const   )529487843U,      (u32 const   )1437280870U, 
        (u32 const   )3945269170U,      (u32 const   )3049390895U,      (u32 const   )3313212038U,      (u32 const   )923313619U, 
        (u32 const   )679998000U,      (u32 const   )3215307299U,      (u32 const   )57326082U,      (u32 const   )377642221U, 
        (u32 const   )3474729866U,      (u32 const   )2041877159U,      (u32 const   )133361907U,      (u32 const   )1776460110U, 
        (u32 const   )3673476453U,      (u32 const   )96392454U,      (u32 const   )878845905U,      (u32 const   )2801699524U, 
        (u32 const   )777231668U,      (u32 const   )4082475170U,      (u32 const   )2330014213U,      (u32 const   )4142626212U, 
        (u32 const   )2213296395U,      (u32 const   )1626319424U,      (u32 const   )1906247262U,      (u32 const   )1846563261U, 
        (u32 const   )562755902U,      (u32 const   )3708173718U,      (u32 const   )1040559837U,      (u32 const   )3871163981U, 
        (u32 const   )1418573201U,      (u32 const   )3294430577U,      (u32 const   )114585348U,      (u32 const   )1343618912U, 
        (u32 const   )2566595609U,      (u32 const   )3186202582U,      (u32 const   )1078185097U,      (u32 const   )3651041127U, 
        (u32 const   )3896688048U,      (u32 const   )2307622919U,      (u32 const   )425408743U,      (u32 const   )3371096953U, 
        (u32 const   )2081048481U,      (u32 const   )1108339068U,      (u32 const   )2216610296U,      (u32 const   )0U, 
        (u32 const   )2156299017U,      (u32 const   )736970802U,      (u32 const   )292596766U,      (u32 const   )1517440620U, 
        (u32 const   )251657213U,      (u32 const   )2235061775U,      (u32 const   )2933202493U,      (u32 const   )758720310U, 
        (u32 const   )265905162U,      (u32 const   )1554391400U,      (u32 const   )1532285339U,      (u32 const   )908999204U, 
        (u32 const   )174567692U,      (u32 const   )1474760595U,      (u32 const   )4002861748U,      (u32 const   )2610011675U, 
        (u32 const   )3234156416U,      (u32 const   )3693126241U,      (u32 const   )2001430874U,      (u32 const   )303699484U, 
        (u32 const   )2478443234U,      (u32 const   )2687165888U,      (u32 const   )585122620U,      (u32 const   )454499602U, 
        (u32 const   )151849742U,      (u32 const   )2345119218U,      (u32 const   )3064510765U,      (u32 const   )514443284U, 
        (u32 const   )4044981591U,      (u32 const   )1963412655U,      (u32 const   )2581445614U,      (u32 const   )2137062819U, 
        (u32 const   )19308535U,      (u32 const   )1928707164U,      (u32 const   )1715193156U,      (u32 const   )4219352155U, 
        (u32 const   )1126790795U,      (u32 const   )600235211U,      (u32 const   )3992742070U,      (u32 const   )3841024952U, 
        (u32 const   )836553431U,      (u32 const   )1669664834U,      (u32 const   )2535604243U,      (u32 const   )3323011204U, 
        (u32 const   )1243905413U,      (u32 const   )3141400786U,      (u32 const   )4180808110U,      (u32 const   )698445255U, 
        (u32 const   )2653899549U,      (u32 const   )2989552604U,      (u32 const   )2253581325U,      (u32 const   )3252932727U, 
        (u32 const   )3004591147U,      (u32 const   )1891211689U,      (u32 const   )2487810577U,      (u32 const   )3915653703U, 
        (u32 const   )4237083816U,      (u32 const   )4030667424U,      (u32 const   )2100090966U,      (u32 const   )865136418U, 
        (u32 const   )1229899655U,      (u32 const   )953270745U,      (u32 const   )3399679628U,      (u32 const   )3557504664U, 
        (u32 const   )4118925222U,      (u32 const   )2061379749U,      (u32 const   )3079546586U,      (u32 const   )2915017791U, 
        (u32 const   )983426092U,      (u32 const   )2022837584U,      (u32 const   )1607244650U,      (u32 const   )2118541908U, 
        (u32 const   )2366882550U,      (u32 const   )3635996816U,      (u32 const   )972512814U,      (u32 const   )3283088770U, 
        (u32 const   )1568718495U,      (u32 const   )3499326569U,      (u32 const   )3576539503U,      (u32 const   )621982671U, 
        (u32 const   )2895723464U,      (u32 const   )410887952U,      (u32 const   )2623762152U,      (u32 const   )1002142683U, 
        (u32 const   )645401037U,      (u32 const   )1494807662U,      (u32 const   )2595684844U,      (u32 const   )1335535747U, 
        (u32 const   )2507040230U,      (u32 const   )4293295786U,      (u32 const   )3167684641U,      (u32 const   )367585007U, 
        (u32 const   )3885750714U,      (u32 const   )1865862730U,      (u32 const   )2668221674U,      (u32 const   )2960971305U, 
        (u32 const   )2763173681U,      (u32 const   )1059270954U,      (u32 const   )2777952454U,      (u32 const   )2724642869U, 
        (u32 const   )1320957812U,      (u32 const   )2194319100U,      (u32 const   )2429595872U,      (u32 const   )2815956275U, 
        (u32 const   )77089521U,      (u32 const   )3973773121U,      (u32 const   )3444575871U,      (u32 const   )2448830231U, 
        (u32 const   )1305906550U,      (u32 const   )4021308739U,      (u32 const   )2857194700U,      (u32 const   )2516901860U, 
        (u32 const   )3518358430U,      (u32 const   )1787304780U,      (u32 const   )740276417U,      (u32 const   )1699839814U, 
        (u32 const   )1592394909U,      (u32 const   )2352307457U,      (u32 const   )2272556026U,      (u32 const   )188821243U, 
        (u32 const   )1729977011U,      (u32 const   )3687994002U,      (u32 const   )274084841U,      (u32 const   )3594982253U, 
        (u32 const   )3613494426U,      (u32 const   )2701949495U,      (u32 const   )4162096729U,      (u32 const   )322734571U, 
        (u32 const   )2837966542U,      (u32 const   )1640576439U,      (u32 const   )484830689U,      (u32 const   )1202797690U, 
        (u32 const   )3537852828U,      (u32 const   )4067639125U,      (u32 const   )349075736U,      (u32 const   )3342319475U, 
        (u32 const   )4157467219U,      (u32 const   )4255800159U,      (u32 const   )1030690015U,      (u32 const   )1155237496U, 
        (u32 const   )2951971274U,      (u32 const   )1757691577U,      (u32 const   )607398968U,      (u32 const   )2738905026U, 
        (u32 const   )499347990U,      (u32 const   )3794078908U,      (u32 const   )1011452712U,      (u32 const   )227885567U, 
        (u32 const   )2818666809U,      (u32 const   )213114376U,      (u32 const   )3034881240U,      (u32 const   )1455525988U, 
        (u32 const   )3414450555U,      (u32 const   )850817237U,      (u32 const   )1817998408U,      (u32 const   )3092726480U};
#line 647 "rijndael.c"
static u32 const   Td4[256]  = 
#line 647
  {      (u32 const   )1381126738U,      (u32 const   )151587081U,      (u32 const   )1785358954U,      (u32 const   )3587560917U, 
        (u32 const   )808464432U,      (u32 const   )909522486U,      (u32 const   )2779096485U,      (u32 const   )943208504U, 
        (u32 const   )3217014719U,      (u32 const   )1077952576U,      (u32 const   )2745410467U,      (u32 const   )2661195422U, 
        (u32 const   )2172748161U,      (u32 const   )4092851187U,      (u32 const   )3621246935U,      (u32 const   )4227595259U, 
        (u32 const   )2088533116U,      (u32 const   )3823363043U,      (u32 const   )960051513U,      (u32 const   )2189591170U, 
        (u32 const   )2610666395U,      (u32 const   )791621423U,      (u32 const   )4294967295U,      (u32 const   )2273806215U, 
        (u32 const   )875836468U,      (u32 const   )2391707278U,      (u32 const   )1128481603U,      (u32 const   )1145324612U, 
        (u32 const   )3301229764U,      (u32 const   )3739147998U,      (u32 const   )3924421097U,      (u32 const   )3419130827U, 
        (u32 const   )1414812756U,      (u32 const   )2071690107U,      (u32 const   )2492765332U,      (u32 const   )842150450U, 
        (u32 const   )2795939494U,      (u32 const   )3267543746U,      (u32 const   )589505315U,      (u32 const   )1027423549U, 
        (u32 const   )4008636142U,      (u32 const   )1280068684U,      (u32 const   )2509608341U,      (u32 const   )185273099U, 
        (u32 const   )1111638594U,      (u32 const   )4210752250U,      (u32 const   )3284386755U,      (u32 const   )1313754702U, 
        (u32 const   )134744072U,      (u32 const   )774778414U,      (u32 const   )2711724449U,      (u32 const   )1717986918U, 
        (u32 const   )673720360U,      (u32 const   )3654932953U,      (u32 const   )606348324U,      (u32 const   )2998055602U, 
        (u32 const   )1987475062U,      (u32 const   )1532713819U,      (u32 const   )2728567458U,      (u32 const   )1229539657U, 
        (u32 const   )1835887981U,      (u32 const   )2341178251U,      (u32 const   )3520188881U,      (u32 const   )623191333U, 
        (u32 const   )1920103026U,      (u32 const   )4177066232U,      (u32 const   )4143380214U,      (u32 const   )1684300900U, 
        (u32 const   )2256963206U,      (u32 const   )1751672936U,      (u32 const   )2560137368U,      (u32 const   )370546198U, 
        (u32 const   )3570717908U,      (u32 const   )2762253476U,      (u32 const   )1549556828U,      (u32 const   )3435973836U, 
        (u32 const   )1566399837U,      (u32 const   )1701143909U,      (u32 const   )3065427638U,      (u32 const   )2459079314U, 
        (u32 const   )1819044972U,      (u32 const   )1886417008U,      (u32 const   )1212696648U,      (u32 const   )1347440720U, 
        (u32 const   )4261281277U,      (u32 const   )3991793133U,      (u32 const   )3115956665U,      (u32 const   )3671775962U, 
        (u32 const   )1583242846U,      (u32 const   )353703189U,      (u32 const   )1179010630U,      (u32 const   )1465341783U, 
        (u32 const   )2812782503U,      (u32 const   )2374864269U,      (u32 const   )2644352413U,      (u32 const   )2223277188U, 
        (u32 const   )2425393296U,      (u32 const   )3638089944U,      (u32 const   )2880154539U,      (u32 const   )0U, 
        (u32 const   )2358021260U,      (u32 const   )3166485692U,      (u32 const   )3553874899U,      (u32 const   )168430090U, 
        (u32 const   )4160223223U,      (u32 const   )3840206052U,      (u32 const   )1482184792U,      (u32 const   )84215045U, 
        (u32 const   )3099113656U,      (u32 const   )3014898611U,      (u32 const   )1162167621U,      (u32 const   )101058054U, 
        (u32 const   )3503345872U,      (u32 const   )741092396U,      (u32 const   )505290270U,      (u32 const   )2408550287U, 
        (u32 const   )3402287818U,      (u32 const   )1061109567U,      (u32 const   )252645135U,      (u32 const   )33686018U, 
        (u32 const   )3250700737U,      (u32 const   )2947526575U,      (u32 const   )3183328701U,      (u32 const   )50529027U, 
        (u32 const   )16843009U,      (u32 const   )320017171U,      (u32 const   )2324335242U,      (u32 const   )1802201963U, 
        (u32 const   )976894522U,      (u32 const   )2442236305U,      (u32 const   )286331153U,      (u32 const   )1094795585U, 
        (u32 const   )1330597711U,      (u32 const   )1734829927U,      (u32 const   )3705461980U,      (u32 const   )3941264106U, 
        (u32 const   )2543294359U,      (u32 const   )4076008178U,      (u32 const   )3486502863U,      (u32 const   )3469659854U, 
        (u32 const   )4042322160U,      (u32 const   )3031741620U,      (u32 const   )3873892070U,      (u32 const   )1936946035U, 
        (u32 const   )2526451350U,      (u32 const   )2896997548U,      (u32 const   )1953789044U,      (u32 const   )572662306U, 
        (u32 const   )3890735079U,      (u32 const   )2913840557U,      (u32 const   )892679477U,      (u32 const   )2240120197U, 
        (u32 const   )3806520034U,      (u32 const   )4193909241U,      (u32 const   )926365495U,      (u32 const   )3907578088U, 
        (u32 const   )471604252U,      (u32 const   )1970632053U,      (u32 const   )3755991007U,      (u32 const   )1852730990U, 
        (u32 const   )1195853639U,      (u32 const   )4059165169U,      (u32 const   )437918234U,      (u32 const   )1903260017U, 
        (u32 const   )488447261U,      (u32 const   )690563369U,      (u32 const   )3318072773U,      (u32 const   )2307492233U, 
        (u32 const   )1869573999U,      (u32 const   )3082270647U,      (u32 const   )1650614882U,      (u32 const   )235802126U, 
        (u32 const   )2863311530U,      (u32 const   )404232216U,      (u32 const   )3200171710U,      (u32 const   )454761243U, 
        (u32 const   )4244438268U,      (u32 const   )1448498774U,      (u32 const   )1044266558U,      (u32 const   )1263225675U, 
        (u32 const   )3334915782U,      (u32 const   )3537031890U,      (u32 const   )2038004089U,      (u32 const   )538976288U, 
        (u32 const   )2593823386U,      (u32 const   )3688618971U,      (u32 const   )3233857728U,      (u32 const   )4278124286U, 
        (u32 const   )2021161080U,      (u32 const   )3452816845U,      (u32 const   )1515870810U,      (u32 const   )4109694196U, 
        (u32 const   )522133279U,      (u32 const   )3722304989U,      (u32 const   )2829625512U,      (u32 const   )858993459U, 
        (u32 const   )2290649224U,      (u32 const   )117901063U,      (u32 const   )3351758791U,      (u32 const   )825307441U, 
        (u32 const   )2981212593U,      (u32 const   )303174162U,      (u32 const   )269488144U,      (u32 const   )1499027801U, 
        (u32 const   )656877351U,      (u32 const   )2155905152U,      (u32 const   )3974950124U,      (u32 const   )1600085855U, 
        (u32 const   )1616928864U,      (u32 const   )1364283729U,      (u32 const   )2139062143U,      (u32 const   )2846468521U, 
        (u32 const   )421075225U,      (u32 const   )3048584629U,      (u32 const   )1246382666U,      (u32 const   )218959117U, 
        (u32 const   )757935405U,      (u32 const   )3857049061U,      (u32 const   )2054847098U,      (u32 const   )2678038431U, 
        (u32 const   )2475922323U,      (u32 const   )3385444809U,      (u32 const   )2627509404U,      (u32 const   )4025479151U, 
        (u32 const   )2694881440U,      (u32 const   )3772834016U,      (u32 const   )993737531U,      (u32 const   )1296911693U, 
        (u32 const   )2930683566U,      (u32 const   )707406378U,      (u32 const   )4126537205U,      (u32 const   )2964369584U, 
        (u32 const   )3368601800U,      (u32 const   )3958107115U,      (u32 const   )3149642683U,      (u32 const   )1010580540U, 
        (u32 const   )2206434179U,      (u32 const   )1397969747U,      (u32 const   )2576980377U,      (u32 const   )1633771873U, 
        (u32 const   )387389207U,      (u32 const   )724249387U,      (u32 const   )67372036U,      (u32 const   )2122219134U, 
        (u32 const   )3132799674U,      (u32 const   )2004318071U,      (u32 const   )3604403926U,      (u32 const   )640034342U, 
        (u32 const   )3789677025U,      (u32 const   )1768515945U,      (u32 const   )336860180U,      (u32 const   )1667457891U, 
        (u32 const   )1431655765U,      (u32 const   )555819297U,      (u32 const   )202116108U,      (u32 const   )2105376125U};
#line 713 "rijndael.c"
static u32 const   rcon[10]  = 
#line 713
  {      (u32 const   )16777216,      (u32 const   )33554432,      (u32 const   )67108864,      (u32 const   )134217728, 
        (u32 const   )268435456,      (u32 const   )536870912,      (u32 const   )1073741824,      (u32 const   )2147483648U, 
        (u32 const   )452984832,      (u32 const   )905969664};
#line 727 "rijndael.c"
static int rijndaelKeySetupEnc(u32 *rk , u8 const   *cipherKey , int keyBits ) 
{ int i ;
  u32 temp ;

  {
#line 728
  i = 0;
#line 731
  *(rk + 0) = ((((unsigned int )*(cipherKey + 0) << 24) ^ ((unsigned int )*(cipherKey + 1) << 16)) ^ ((unsigned int )*(cipherKey + 2) << 8)) ^ (unsigned int )*(cipherKey + 3);
#line 732
  *(rk + 1) = ((((unsigned int )*((cipherKey + 4) + 0) << 24) ^ ((unsigned int )*((cipherKey + 4) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 4) + 2) << 8)) ^ (unsigned int )*((cipherKey + 4) + 3);
#line 733
  *(rk + 2) = ((((unsigned int )*((cipherKey + 8) + 0) << 24) ^ ((unsigned int )*((cipherKey + 8) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 8) + 2) << 8)) ^ (unsigned int )*((cipherKey + 8) + 3);
#line 734
  *(rk + 3) = ((((unsigned int )*((cipherKey + 12) + 0) << 24) ^ ((unsigned int )*((cipherKey + 12) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 12) + 2) << 8)) ^ (unsigned int )*((cipherKey + 12) + 3);
#line 735
  if (keyBits == 128) {
#line 736
    while (1) {
#line 737
      temp = *(rk + 3);
#line 738
      *(rk + 4) = ((((*(rk + 0) ^ (unsigned int )(Te4[(temp >> 16) & 255U] & 4278190080U)) ^ (unsigned int )(Te4[(temp >> 8) & 255U] & 16711680U)) ^ (unsigned int )(Te4[temp & 255U] & 65280U)) ^ (unsigned int )(Te4[temp >> 24] & 255U)) ^ (unsigned int )rcon[i];
#line 744
      *(rk + 5) = *(rk + 1) ^ *(rk + 4);
#line 745
      *(rk + 6) = *(rk + 2) ^ *(rk + 5);
#line 746
      *(rk + 7) = *(rk + 3) ^ *(rk + 6);
#line 747
      i ++;
#line 747
      if (i == 10) {
#line 748
        return (10);
      }
#line 750
      rk += 4;
    }
  }
#line 753
  *(rk + 4) = ((((unsigned int )*((cipherKey + 16) + 0) << 24) ^ ((unsigned int )*((cipherKey + 16) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 16) + 2) << 8)) ^ (unsigned int )*((cipherKey + 16) + 3);
#line 754
  *(rk + 5) = ((((unsigned int )*((cipherKey + 20) + 0) << 24) ^ ((unsigned int )*((cipherKey + 20) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 20) + 2) << 8)) ^ (unsigned int )*((cipherKey + 20) + 3);
#line 755
  if (keyBits == 192) {
#line 756
    while (1) {
#line 757
      temp = *(rk + 5);
#line 758
      *(rk + 6) = ((((*(rk + 0) ^ (unsigned int )(Te4[(temp >> 16) & 255U] & 4278190080U)) ^ (unsigned int )(Te4[(temp >> 8) & 255U] & 16711680U)) ^ (unsigned int )(Te4[temp & 255U] & 65280U)) ^ (unsigned int )(Te4[temp >> 24] & 255U)) ^ (unsigned int )rcon[i];
#line 764
      *(rk + 7) = *(rk + 1) ^ *(rk + 6);
#line 765
      *(rk + 8) = *(rk + 2) ^ *(rk + 7);
#line 766
      *(rk + 9) = *(rk + 3) ^ *(rk + 8);
#line 767
      i ++;
#line 767
      if (i == 8) {
#line 768
        return (12);
      }
#line 770
      *(rk + 10) = *(rk + 4) ^ *(rk + 9);
#line 771
      *(rk + 11) = *(rk + 5) ^ *(rk + 10);
#line 772
      rk += 6;
    }
  }
#line 775
  *(rk + 6) = ((((unsigned int )*((cipherKey + 24) + 0) << 24) ^ ((unsigned int )*((cipherKey + 24) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 24) + 2) << 8)) ^ (unsigned int )*((cipherKey + 24) + 3);
#line 776
  *(rk + 7) = ((((unsigned int )*((cipherKey + 28) + 0) << 24) ^ ((unsigned int )*((cipherKey + 28) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 28) + 2) << 8)) ^ (unsigned int )*((cipherKey + 28) + 3);
#line 777
  if (keyBits == 256) {
#line 778
    while (1) {
#line 779
      temp = *(rk + 7);
#line 780
      *(rk + 8) = ((((*(rk + 0) ^ (unsigned int )(Te4[(temp >> 16) & 255U] & 4278190080U)) ^ (unsigned int )(Te4[(temp >> 8) & 255U] & 16711680U)) ^ (unsigned int )(Te4[temp & 255U] & 65280U)) ^ (unsigned int )(Te4[temp >> 24] & 255U)) ^ (unsigned int )rcon[i];
#line 786
      *(rk + 9) = *(rk + 1) ^ *(rk + 8);
#line 787
      *(rk + 10) = *(rk + 2) ^ *(rk + 9);
#line 788
      *(rk + 11) = *(rk + 3) ^ *(rk + 10);
#line 789
      i ++;
#line 789
      if (i == 7) {
#line 790
        return (14);
      }
#line 792
      temp = *(rk + 11);
#line 793
      *(rk + 12) = (((*(rk + 4) ^ (unsigned int )(Te4[temp >> 24] & 4278190080U)) ^ (unsigned int )(Te4[(temp >> 16) & 255U] & 16711680U)) ^ (unsigned int )(Te4[(temp >> 8) & 255U] & 65280U)) ^ (unsigned int )(Te4[temp & 255U] & 255U);
#line 798
      *(rk + 13) = *(rk + 5) ^ *(rk + 12);
#line 799
      *(rk + 14) = *(rk + 6) ^ *(rk + 13);
#line 800
      *(rk + 15) = *(rk + 7) ^ *(rk + 14);
#line 801
      rk += 8;
    }
  }
#line 804
  return (0);
}
}
#line 812 "rijndael.c"
static int rijndaelKeySetupDec(u32 *rk , u8 const   *cipherKey , int keyBits , int have_encrypt ) 
{ int Nr ;
  int i ;
  int j ;
  u32 temp ;

  {
#line 818
  if (have_encrypt) {
#line 819
    Nr = have_encrypt;
  } else {
#line 822
    Nr = rijndaelKeySetupEnc(rk, cipherKey, keyBits);
  }
#line 825
  i = 0;
#line 825
  j = 4 * Nr;
#line 825
  while (i < j) {
#line 826
    temp = *(rk + i);
#line 826
    *(rk + i) = *(rk + j);
#line 826
    *(rk + j) = temp;
#line 827
    temp = *(rk + (i + 1));
#line 827
    *(rk + (i + 1)) = *(rk + (j + 1));
#line 827
    *(rk + (j + 1)) = temp;
#line 828
    temp = *(rk + (i + 2));
#line 828
    *(rk + (i + 2)) = *(rk + (j + 2));
#line 828
    *(rk + (j + 2)) = temp;
#line 829
    temp = *(rk + (i + 3));
#line 829
    *(rk + (i + 3)) = *(rk + (j + 3));
#line 829
    *(rk + (j + 3)) = temp;
#line 825
    i += 4;
#line 825
    j -= 4;
  }
#line 832
  i = 1;
#line 832
  while (i < Nr) {
#line 833
    rk += 4;
#line 834
    *(rk + 0) = (unsigned int )(((Td0[Te4[*(rk + 0) >> 24] & 255U] ^ Td1[Te4[(*(rk + 0) >> 16) & 255U] & 255U]) ^ Td2[Te4[(*(rk + 0) >> 8) & 255U] & 255U]) ^ Td3[Te4[*(rk + 0) & 255U] & 255U]);
#line 839
    *(rk + 1) = (unsigned int )(((Td0[Te4[*(rk + 1) >> 24] & 255U] ^ Td1[Te4[(*(rk + 1) >> 16) & 255U] & 255U]) ^ Td2[Te4[(*(rk + 1) >> 8) & 255U] & 255U]) ^ Td3[Te4[*(rk + 1) & 255U] & 255U]);
#line 844
    *(rk + 2) = (unsigned int )(((Td0[Te4[*(rk + 2) >> 24] & 255U] ^ Td1[Te4[(*(rk + 2) >> 16) & 255U] & 255U]) ^ Td2[Te4[(*(rk + 2) >> 8) & 255U] & 255U]) ^ Td3[Te4[*(rk + 2) & 255U] & 255U]);
#line 849
    *(rk + 3) = (unsigned int )(((Td0[Te4[*(rk + 3) >> 24] & 255U] ^ Td1[Te4[(*(rk + 3) >> 16) & 255U] & 255U]) ^ Td2[Te4[(*(rk + 3) >> 8) & 255U] & 255U]) ^ Td3[Te4[*(rk + 3) & 255U] & 255U]);
#line 832
    i ++;
  }
#line 855
  return (Nr);
}
}
#line 858 "rijndael.c"
static void rijndaelEncrypt(u32 const   *rk , int Nr , u8 const   *pt , u8 *ct ) 
{ u32 s0 ;
  u32 s1 ;
  u32 s2 ;
  u32 s3 ;
  u32 t0 ;
  u32 t1 ;
  u32 t2 ;
  u32 t3 ;

  {
#line 868
  s0 = (((((unsigned int )*(pt + 0) << 24) ^ ((unsigned int )*(pt + 1) << 16)) ^ ((unsigned int )*(pt + 2) << 8)) ^ (unsigned int )*(pt + 3)) ^ (unsigned int )*(rk + 0);
#line 869
  s1 = (((((unsigned int )*((pt + 4) + 0) << 24) ^ ((unsigned int )*((pt + 4) + 1) << 16)) ^ ((unsigned int )*((pt + 4) + 2) << 8)) ^ (unsigned int )*((pt + 4) + 3)) ^ (unsigned int )*(rk + 1);
#line 870
  s2 = (((((unsigned int )*((pt + 8) + 0) << 24) ^ ((unsigned int )*((pt + 8) + 1) << 16)) ^ ((unsigned int )*((pt + 8) + 2) << 8)) ^ (unsigned int )*((pt + 8) + 3)) ^ (unsigned int )*(rk + 2);
#line 871
  s3 = (((((unsigned int )*((pt + 12) + 0) << 24) ^ ((unsigned int )*((pt + 12) + 1) << 16)) ^ ((unsigned int )*((pt + 12) + 2) << 8)) ^ (unsigned int )*((pt + 12) + 3)) ^ (unsigned int )*(rk + 3);
#line 874
  t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 4));
#line 875
  t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 5));
#line 876
  t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 6));
#line 877
  t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 7));
#line 879
  s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 8));
#line 880
  s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 9));
#line 881
  s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 10));
#line 882
  s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 11));
#line 884
  t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 12));
#line 885
  t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 13));
#line 886
  t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 14));
#line 887
  t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 15));
#line 889
  s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 16));
#line 890
  s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 17));
#line 891
  s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 18));
#line 892
  s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 19));
#line 894
  t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 20));
#line 895
  t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 21));
#line 896
  t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 22));
#line 897
  t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 23));
#line 899
  s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 24));
#line 900
  s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 25));
#line 901
  s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 26));
#line 902
  s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 27));
#line 904
  t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 28));
#line 905
  t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 29));
#line 906
  t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 30));
#line 907
  t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 31));
#line 909
  s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 32));
#line 910
  s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 33));
#line 911
  s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 34));
#line 912
  s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 35));
#line 914
  t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 36));
#line 915
  t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 37));
#line 916
  t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 38));
#line 917
  t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 39));
#line 918
  if (Nr > 10) {
#line 920
    s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 40));
#line 921
    s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 41));
#line 922
    s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 42));
#line 923
    s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 43));
#line 925
    t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 44));
#line 926
    t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 45));
#line 927
    t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 46));
#line 928
    t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 47));
#line 929
    if (Nr > 12) {
#line 931
      s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 48));
#line 932
      s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 49));
#line 933
      s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 50));
#line 934
      s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 51));
#line 936
      t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 52));
#line 937
      t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 53));
#line 938
      t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 54));
#line 939
      t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 55));
    }
  }
#line 942
  rk += Nr << 2;
#line 1009
  s0 = (unsigned int )(((((Te4[t0 >> 24] & 4278190080U) ^ (Te4[(t1 >> 16) & 255U] & 16711680U)) ^ (Te4[(t2 >> 8) & 255U] & 65280U)) ^ (Te4[t3 & 255U] & 255U)) ^ *(rk + 0));
#line 1015
  *(ct + 0) = (unsigned char )(s0 >> 24);
#line 1015
  *(ct + 1) = (unsigned char )(s0 >> 16);
#line 1015
  *(ct + 2) = (unsigned char )(s0 >> 8);
#line 1015
  *(ct + 3) = (unsigned char )s0;
#line 1016
  s1 = (unsigned int )(((((Te4[t1 >> 24] & 4278190080U) ^ (Te4[(t2 >> 16) & 255U] & 16711680U)) ^ (Te4[(t3 >> 8) & 255U] & 65280U)) ^ (Te4[t0 & 255U] & 255U)) ^ *(rk + 1));
#line 1022
  *((ct + 4) + 0) = (unsigned char )(s1 >> 24);
#line 1022
  *((ct + 4) + 1) = (unsigned char )(s1 >> 16);
#line 1022
  *((ct + 4) + 2) = (unsigned char )(s1 >> 8);
#line 1022
  *((ct + 4) + 3) = (unsigned char )s1;
#line 1023
  s2 = (unsigned int )(((((Te4[t2 >> 24] & 4278190080U) ^ (Te4[(t3 >> 16) & 255U] & 16711680U)) ^ (Te4[(t0 >> 8) & 255U] & 65280U)) ^ (Te4[t1 & 255U] & 255U)) ^ *(rk + 2));
#line 1029
  *((ct + 8) + 0) = (unsigned char )(s2 >> 24);
#line 1029
  *((ct + 8) + 1) = (unsigned char )(s2 >> 16);
#line 1029
  *((ct + 8) + 2) = (unsigned char )(s2 >> 8);
#line 1029
  *((ct + 8) + 3) = (unsigned char )s2;
#line 1030
  s3 = (unsigned int )(((((Te4[t3 >> 24] & 4278190080U) ^ (Te4[(t0 >> 16) & 255U] & 16711680U)) ^ (Te4[(t1 >> 8) & 255U] & 65280U)) ^ (Te4[t2 & 255U] & 255U)) ^ *(rk + 3));
#line 1036
  *((ct + 12) + 0) = (unsigned char )(s3 >> 24);
#line 1036
  *((ct + 12) + 1) = (unsigned char )(s3 >> 16);
#line 1036
  *((ct + 12) + 2) = (unsigned char )(s3 >> 8);
#line 1036
  *((ct + 12) + 3) = (unsigned char )s3;
#line 1037
  return;
}
}
#line 1039 "rijndael.c"
static void rijndaelDecrypt(u32 const   *rk , int Nr , u8 const   *ct , u8 *pt ) 
{ u32 s0 ;
  u32 s1 ;
  u32 s2 ;
  u32 s3 ;
  u32 t0 ;
  u32 t1 ;
  u32 t2 ;
  u32 t3 ;

  {
#line 1049
  s0 = (((((unsigned int )*(ct + 0) << 24) ^ ((unsigned int )*(ct + 1) << 16)) ^ ((unsigned int )*(ct + 2) << 8)) ^ (unsigned int )*(ct + 3)) ^ (unsigned int )*(rk + 0);
#line 1050
  s1 = (((((unsigned int )*((ct + 4) + 0) << 24) ^ ((unsigned int )*((ct + 4) + 1) << 16)) ^ ((unsigned int )*((ct + 4) + 2) << 8)) ^ (unsigned int )*((ct + 4) + 3)) ^ (unsigned int )*(rk + 1);
#line 1051
  s2 = (((((unsigned int )*((ct + 8) + 0) << 24) ^ ((unsigned int )*((ct + 8) + 1) << 16)) ^ ((unsigned int )*((ct + 8) + 2) << 8)) ^ (unsigned int )*((ct + 8) + 3)) ^ (unsigned int )*(rk + 2);
#line 1052
  s3 = (((((unsigned int )*((ct + 12) + 0) << 24) ^ ((unsigned int )*((ct + 12) + 1) << 16)) ^ ((unsigned int )*((ct + 12) + 2) << 8)) ^ (unsigned int )*((ct + 12) + 3)) ^ (unsigned int )*(rk + 3);
#line 1055
  t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 4));
#line 1056
  t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 5));
#line 1057
  t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 6));
#line 1058
  t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 7));
#line 1060
  s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 8));
#line 1061
  s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 9));
#line 1062
  s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 10));
#line 1063
  s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 11));
#line 1065
  t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 12));
#line 1066
  t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 13));
#line 1067
  t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 14));
#line 1068
  t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 15));
#line 1070
  s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 16));
#line 1071
  s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 17));
#line 1072
  s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 18));
#line 1073
  s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 19));
#line 1075
  t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 20));
#line 1076
  t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 21));
#line 1077
  t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 22));
#line 1078
  t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 23));
#line 1080
  s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 24));
#line 1081
  s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 25));
#line 1082
  s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 26));
#line 1083
  s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 27));
#line 1085
  t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 28));
#line 1086
  t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 29));
#line 1087
  t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 30));
#line 1088
  t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 31));
#line 1090
  s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 32));
#line 1091
  s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 33));
#line 1092
  s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 34));
#line 1093
  s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 35));
#line 1095
  t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 36));
#line 1096
  t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 37));
#line 1097
  t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 38));
#line 1098
  t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 39));
#line 1099
  if (Nr > 10) {
#line 1101
    s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 40));
#line 1102
    s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 41));
#line 1103
    s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 42));
#line 1104
    s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 43));
#line 1106
    t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 44));
#line 1107
    t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 45));
#line 1108
    t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 46));
#line 1109
    t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 47));
#line 1110
    if (Nr > 12) {
#line 1112
      s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 48));
#line 1113
      s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 49));
#line 1114
      s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 50));
#line 1115
      s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 51));
#line 1117
      t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 52));
#line 1118
      t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 53));
#line 1119
      t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 54));
#line 1120
      t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 55));
    }
  }
#line 1123
  rk += Nr << 2;
#line 1190
  s0 = (unsigned int )(((((Td4[t0 >> 24] & 4278190080U) ^ (Td4[(t3 >> 16) & 255U] & 16711680U)) ^ (Td4[(t2 >> 8) & 255U] & 65280U)) ^ (Td4[t1 & 255U] & 255U)) ^ *(rk + 0));
#line 1196
  *(pt + 0) = (unsigned char )(s0 >> 24);
#line 1196
  *(pt + 1) = (unsigned char )(s0 >> 16);
#line 1196
  *(pt + 2) = (unsigned char )(s0 >> 8);
#line 1196
  *(pt + 3) = (unsigned char )s0;
#line 1197
  s1 = (unsigned int )(((((Td4[t1 >> 24] & 4278190080U) ^ (Td4[(t0 >> 16) & 255U] & 16711680U)) ^ (Td4[(t3 >> 8) & 255U] & 65280U)) ^ (Td4[t2 & 255U] & 255U)) ^ *(rk + 1));
#line 1203
  *((pt + 4) + 0) = (unsigned char )(s1 >> 24);
#line 1203
  *((pt + 4) + 1) = (unsigned char )(s1 >> 16);
#line 1203
  *((pt + 4) + 2) = (unsigned char )(s1 >> 8);
#line 1203
  *((pt + 4) + 3) = (unsigned char )s1;
#line 1204
  s2 = (unsigned int )(((((Td4[t2 >> 24] & 4278190080U) ^ (Td4[(t1 >> 16) & 255U] & 16711680U)) ^ (Td4[(t0 >> 8) & 255U] & 65280U)) ^ (Td4[t3 & 255U] & 255U)) ^ *(rk + 2));
#line 1210
  *((pt + 8) + 0) = (unsigned char )(s2 >> 24);
#line 1210
  *((pt + 8) + 1) = (unsigned char )(s2 >> 16);
#line 1210
  *((pt + 8) + 2) = (unsigned char )(s2 >> 8);
#line 1210
  *((pt + 8) + 3) = (unsigned char )s2;
#line 1211
  s3 = (unsigned int )(((((Td4[t3 >> 24] & 4278190080U) ^ (Td4[(t2 >> 16) & 255U] & 16711680U)) ^ (Td4[(t1 >> 8) & 255U] & 65280U)) ^ (Td4[t0 & 255U] & 255U)) ^ *(rk + 3));
#line 1217
  *((pt + 12) + 0) = (unsigned char )(s3 >> 24);
#line 1217
  *((pt + 12) + 1) = (unsigned char )(s3 >> 16);
#line 1217
  *((pt + 12) + 2) = (unsigned char )(s3 >> 8);
#line 1217
  *((pt + 12) + 3) = (unsigned char )s3;
#line 1218
  return;
}
}
#line 1220 "rijndael.c"
void rijndael_set_key(rijndael_ctx *ctx , u_char *key , int bits , int do_encrypt ) 
{ 

  {
#line 1223
  ctx->Nr = rijndaelKeySetupEnc(ctx->ek, (u8 const   *)key, bits);
#line 1224
  if (do_encrypt) {
#line 1225
    ctx->decrypt = 0;
#line 1226
    memset((void *)(ctx->dk), 0, sizeof(ctx->dk));
  } else {
#line 1228
    ctx->decrypt = 1;
#line 1229
    memcpy((void * __restrict  )(ctx->dk), (void const   * __restrict  )(ctx->ek),
           sizeof(ctx->dk));
#line 1230
    rijndaelKeySetupDec(ctx->dk, (u8 const   *)key, bits, ctx->Nr);
  }
#line 1232
  return;
}
}
#line 1234 "rijndael.c"
void rijndael_decrypt(rijndael_ctx *ctx , u_char *src , u_char *dst ) 
{ 

  {
#line 1237
  rijndaelDecrypt((u32 const   *)(ctx->dk), ctx->Nr, (u8 const   *)src, (u8 *)dst);
#line 1238
  return;
}
}
#line 1240 "rijndael.c"
void rijndael_encrypt(rijndael_ctx *ctx , u_char *src , u_char *dst ) 
{ 

  {
#line 1243
  rijndaelEncrypt((u32 const   *)(ctx->ek), ctx->Nr, (u8 const   *)src, (u8 *)dst);
#line 1244
  return;
}
}
#line 1 "ssh-dss.o"
#line 175 "/usr/include/openssl/dsa.h"
extern DSA_SIG *DSA_SIG_new(void) ;
#line 176
extern void DSA_SIG_free(DSA_SIG *a ) ;
#line 180
extern DSA_SIG *DSA_do_sign(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
#line 181
extern int DSA_do_verify(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                         DSA *dsa ) ;
#line 41 "ssh-dss.c"
int ssh_dss_sign(Key const   *key , u_char **sigp , u_int *lenp , u_char const   *data ,
                 u_int datalen ) 
{ DSA_SIG *sig ;
  EVP_MD const   *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  u_char digest___1[64] ;
  u_char sigblob[40] ;
  u_int rlen ;
  u_int slen ;
  u_int len ;
  u_int dlen ;
  Buffer b ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 46
  tmp = EVP_sha1();
#line 46
  evp_md = tmp;
#line 52
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 53
    error("ssh_dss_sign: no DSA key");
#line 54
    return (-1);
  } else {
#line 52
    if (key->type != 2) {
#line 53
      error("ssh_dss_sign: no DSA key");
#line 54
      return (-1);
    } else {
#line 52
      if ((unsigned int )key->dsa == (unsigned int )((void *)0)) {
#line 53
        error("ssh_dss_sign: no DSA key");
#line 54
        return (-1);
      }
    }
  }
#line 56
  EVP_DigestInit(& md, evp_md);
#line 57
  EVP_DigestUpdate(& md, (void const   *)data, datalen);
#line 58
  EVP_DigestFinal(& md, digest___1, & dlen);
#line 60
  sig = DSA_do_sign((unsigned char const   *)(digest___1), (int )dlen, (DSA *)key->dsa);
#line 61
  memset((void *)(digest___1), 'd', sizeof(digest___1));
#line 63
  if ((unsigned int )sig == (unsigned int )((void *)0)) {
#line 64
    error("ssh_dss_sign: sign failed");
#line 65
    return (-1);
  }
#line 68
  tmp___0 = BN_num_bits((BIGNUM const   *)sig->r);
#line 68
  rlen = (unsigned int )((tmp___0 + 7) / 8);
#line 69
  tmp___1 = BN_num_bits((BIGNUM const   *)sig->s);
#line 69
  slen = (unsigned int )((tmp___1 + 7) / 8);
#line 70
  if (rlen > 20U) {
#line 71
    error("bad sig size %u %u", rlen, slen);
#line 72
    DSA_SIG_free(sig);
#line 73
    return (-1);
  } else {
#line 70
    if (slen > 20U) {
#line 71
      error("bad sig size %u %u", rlen, slen);
#line 72
      DSA_SIG_free(sig);
#line 73
      return (-1);
    }
  }
#line 75
  memset((void *)(sigblob), 0, 40U);
#line 76
  BN_bn2bin((BIGNUM const   *)sig->r, ((sigblob + 40) - 20) - rlen);
#line 77
  BN_bn2bin((BIGNUM const   *)sig->s, (sigblob + 40) - slen);
#line 78
  DSA_SIG_free(sig);
#line 80
  if (datafellows & 1) {
#line 81
    if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 82
      *lenp = 40U;
    }
#line 83
    if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 84
      tmp___2 = xmalloc(40U);
#line 84
      *sigp = (u_char *)tmp___2;
#line 85
      memcpy((void * __restrict  )*sigp, (void const   * __restrict  )(sigblob), 40U);
    }
  } else {
#line 89
    buffer_init(& b);
#line 90
    buffer_put_cstring(& b, "ssh-dss");
#line 91
    buffer_put_string(& b, (void const   *)(sigblob), 40U);
#line 92
    len = buffer_len(& b);
#line 93
    if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 94
      *lenp = len;
    }
#line 95
    if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 96
      tmp___3 = xmalloc(len);
#line 96
      *sigp = (u_char *)tmp___3;
#line 97
      tmp___4 = buffer_ptr(& b);
#line 97
      memcpy((void * __restrict  )*sigp, (void const   * __restrict  )tmp___4, len);
    }
#line 99
    buffer_free(& b);
  }
#line 101
  return (0);
}
}
#line 103 "ssh-dss.c"
int ssh_dss_verify(Key const   *key , u_char const   *signature , u_int signaturelen ,
                   u_char const   *data , u_int datalen ) 
{ DSA_SIG *sig ;
  EVP_MD const   *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  u_char digest___1[64] ;
  u_char *sigblob ;
  u_int len ;
  u_int dlen ;
  int rlen ;
  int ret ;
  Buffer b ;
  void *tmp___0 ;
  char *ktype ;
  void *tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;
  u_int tmp___13 ;
  char const   *tmp___15 ;

  {
#line 108
  tmp = EVP_sha1();
#line 108
  evp_md = tmp;
#line 115
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 116
    error("ssh_dss_verify: no DSA key");
#line 117
    return (-1);
  } else {
#line 115
    if (key->type != 2) {
#line 116
      error("ssh_dss_verify: no DSA key");
#line 117
      return (-1);
    } else {
#line 115
      if ((unsigned int )key->dsa == (unsigned int )((void *)0)) {
#line 116
        error("ssh_dss_verify: no DSA key");
#line 117
        return (-1);
      }
    }
  }
#line 121
  if (datafellows & 1) {
#line 122
    tmp___0 = xmalloc(signaturelen);
#line 122
    sigblob = (u_char *)tmp___0;
#line 123
    memcpy((void * __restrict  )sigblob, (void const   * __restrict  )signature, signaturelen);
#line 124
    len = signaturelen;
  } else {
#line 128
    buffer_init(& b);
#line 129
    buffer_append(& b, (void const   *)signature, signaturelen);
#line 130
    tmp___1 = buffer_get_string(& b, (u_int *)((void *)0));
#line 130
    ktype = (char *)tmp___1;
#line 131
    if (0) {
#line 131
      __s1_len = strlen("ssh-dss");
#line 131
      __s2_len = strlen((char const   *)ktype);
#line 131
      if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
        goto _L___0;
      } else {
#line 131
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 131
          if (! ((unsigned int )((void const   *)(ktype + 1)) - (unsigned int )((void const   *)ktype) == 1U)) {
#line 131
            tmp___11 = 1;
          } else {
#line 131
            if (__s2_len >= 4U) {
#line 131
              tmp___11 = 1;
            } else {
#line 131
              tmp___11 = 0;
            }
          }
        } else {
#line 131
          tmp___11 = 0;
        }
      }
#line 131
      if (tmp___11) {
#line 131
        tmp___7 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
      } else {
#line 131
        tmp___10 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
#line 131
        tmp___7 = tmp___10;
      }
    } else {
#line 131
      tmp___10 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
#line 131
      tmp___7 = tmp___10;
    }
#line 131
    if (tmp___7 != 0) {
#line 132
      error("ssh_dss_verify: cannot handle type %s", ktype);
#line 133
      buffer_free(& b);
#line 134
      xfree((void *)ktype);
#line 135
      return (-1);
    }
#line 137
    xfree((void *)ktype);
#line 138
    tmp___12 = buffer_get_string(& b, & len);
#line 138
    sigblob = (u_char *)tmp___12;
#line 139
    tmp___13 = buffer_len(& b);
#line 139
    rlen = (int )tmp___13;
#line 140
    buffer_free(& b);
#line 141
    if (rlen != 0) {
#line 142
      error("ssh_dss_verify: remaining bytes in signature %d", rlen);
#line 144
      xfree((void *)sigblob);
#line 145
      return (-1);
    }
  }
#line 149
  if (len != 40U) {
#line 150
    fatal("bad sigbloblen %u != SIGBLOB_LEN", len);
  }
#line 154
  sig = DSA_SIG_new();
#line 154
  if ((unsigned int )sig == (unsigned int )((void *)0)) {
#line 155
    fatal("ssh_dss_verify: DSA_SIG_new failed");
  }
#line 156
  sig->r = BN_new();
#line 156
  if ((unsigned int )sig->r == (unsigned int )((void *)0)) {
#line 157
    fatal("ssh_dss_verify: BN_new failed");
  }
#line 158
  sig->s = BN_new();
#line 158
  if ((unsigned int )sig->s == (unsigned int )((void *)0)) {
#line 159
    fatal("ssh_dss_verify: BN_new failed");
  }
#line 160
  BN_bin2bn((unsigned char const   *)sigblob, 20, sig->r);
#line 161
  BN_bin2bn((unsigned char const   *)(sigblob + 20), 20, sig->s);
#line 164
  memset((void *)sigblob, 0, len);
#line 165
  xfree((void *)sigblob);
#line 168
  EVP_DigestInit(& md, evp_md);
#line 169
  EVP_DigestUpdate(& md, (void const   *)data, datalen);
#line 170
  EVP_DigestFinal(& md, digest___1, & dlen);
#line 172
  ret = DSA_do_verify((unsigned char const   *)(digest___1), (int )dlen, sig, (DSA *)key->dsa);
#line 173
  memset((void *)(digest___1), 'd', sizeof(digest___1));
#line 175
  DSA_SIG_free(sig);
#line 177
  if (ret == 1) {
#line 177
    tmp___15 = "correct";
  } else {
#line 177
    if (ret == 0) {
#line 177
      tmp___15 = "incorrect";
    } else {
#line 177
      tmp___15 = "error";
    }
  }
#line 177
  debug("ssh_dss_verify: signature %s", tmp___15);
#line 179
  return (ret);
}
}
#line 1 "ssh-rsa.o"
#line 1006 "/usr/include/openssl/objects.h"
extern char const   *OBJ_nid2sn(int n ) ;
#line 732 "/usr/include/openssl/evp.h"
extern EVP_MD const   *EVP_get_digestbyname(char const   *name ) ;
#line 271 "/usr/include/openssl/err.h"
extern char *ERR_error_string(unsigned long e , char *buf ) ;
#line 217 "/usr/include/openssl/rsa.h"
extern int RSA_size(RSA const   * ) ;
#line 234
extern int RSA_public_decrypt(int flen , unsigned char const   *from , unsigned char *to ,
                              RSA *rsa , int padding ) ;
#line 284
extern int RSA_sign(int type , unsigned char const   *m , unsigned int m_length ,
                    unsigned char *sigret , unsigned int *siglen , RSA *rsa ) ;
#line 30 "ssh-rsa.c"
static int openssh_RSA_verify(int type , u_char *hash , u_int hashlen , u_char *sigbuf ,
                              u_int siglen , RSA *rsa ) ;
#line 33 "ssh-rsa.c"
int ssh_rsa_sign(Key const   *key , u_char **sigp , u_int *lenp , u_char const   *data ,
                 u_int datalen ) 
{ EVP_MD const   *evp_md ;
  EVP_MD_CTX md ;
  u_char digest___1[64] ;
  u_char *sig ;
  u_int slen ;
  u_int dlen ;
  u_int len ;
  int ok ;
  int nid ;
  Buffer b ;
  char const   *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int ecode ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  u_int diff ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
#line 44
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 45
    error("ssh_rsa_sign: no RSA key");
#line 46
    return (-1);
  } else {
#line 44
    if (key->type != 1) {
#line 45
      error("ssh_rsa_sign: no RSA key");
#line 46
      return (-1);
    } else {
#line 44
      if ((unsigned int )key->rsa == (unsigned int )((void *)0)) {
#line 45
        error("ssh_rsa_sign: no RSA key");
#line 46
        return (-1);
      }
    }
  }
#line 48
  if (datafellows & 8192) {
#line 48
    nid = 4;
  } else {
#line 48
    nid = 64;
  }
#line 49
  tmp = OBJ_nid2sn(nid);
#line 49
  evp_md = EVP_get_digestbyname(tmp);
#line 49
  if ((unsigned int )evp_md == (unsigned int )((void *)0)) {
#line 50
    error("ssh_rsa_sign: EVP_get_digestbynid %d failed", nid);
#line 51
    return (-1);
  }
#line 53
  EVP_DigestInit(& md, evp_md);
#line 54
  EVP_DigestUpdate(& md, (void const   *)data, datalen);
#line 55
  EVP_DigestFinal(& md, digest___1, & dlen);
#line 57
  tmp___0 = RSA_size((RSA const   *)key->rsa);
#line 57
  slen = (unsigned int )tmp___0;
#line 58
  tmp___1 = xmalloc(slen);
#line 58
  sig = (u_char *)tmp___1;
#line 60
  ok = RSA_sign(nid, (unsigned char const   *)(digest___1), dlen, sig, & len, (RSA *)key->rsa);
#line 61
  memset((void *)(digest___1), 'd', sizeof(digest___1));
#line 63
  if (ok != 1) {
#line 64
    tmp___2 = ERR_get_error();
#line 64
    ecode = (int )tmp___2;
#line 65
    tmp___3 = ERR_error_string((unsigned long )ecode, (char *)((void *)0));
#line 65
    error("ssh_rsa_sign: RSA_sign failed: %s", tmp___3);
#line 67
    xfree((void *)sig);
#line 68
    return (-1);
  }
#line 70
  if (len < slen) {
#line 71
    diff = slen - len;
#line 72
    debug("slen %u > len %u", slen, len);
#line 73
    memmove((void *)(sig + diff), (void const   *)sig, len);
#line 74
    memset((void *)sig, 0, diff);
  } else {
#line 75
    if (len > slen) {
#line 76
      error("ssh_rsa_sign: slen %u slen2 %u", slen, len);
#line 77
      xfree((void *)sig);
#line 78
      return (-1);
    }
  }
#line 81
  buffer_init(& b);
#line 82
  buffer_put_cstring(& b, "ssh-rsa");
#line 83
  buffer_put_string(& b, (void const   *)sig, slen);
#line 84
  len = buffer_len(& b);
#line 85
  if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 86
    *lenp = len;
  }
#line 87
  if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 88
    tmp___4 = xmalloc(len);
#line 88
    *sigp = (u_char *)tmp___4;
#line 89
    tmp___5 = buffer_ptr(& b);
#line 89
    memcpy((void * __restrict  )*sigp, (void const   * __restrict  )tmp___5, len);
  }
#line 91
  buffer_free(& b);
#line 92
  memset((void *)sig, 's', slen);
#line 93
  xfree((void *)sig);
#line 95
  return (0);
}
}
#line 98 "ssh-rsa.c"
int ssh_rsa_verify(Key const   *key , u_char const   *signature , u_int signaturelen ,
                   u_char const   *data , u_int datalen ) 
{ Buffer b ;
  EVP_MD const   *evp_md ;
  EVP_MD_CTX md ;
  char *ktype ;
  u_char digest___1[64] ;
  u_char *sigblob ;
  u_int len ;
  u_int dlen ;
  u_int modlen ;
  int rlen ;
  int ret ;
  int nid ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;
  u_int tmp___13 ;
  int tmp___14 ;
  u_int diff ;
  void *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;

  {
#line 110
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 111
    error("ssh_rsa_verify: no RSA key");
#line 112
    return (-1);
  } else {
#line 110
    if (key->type != 1) {
#line 111
      error("ssh_rsa_verify: no RSA key");
#line 112
      return (-1);
    } else {
#line 110
      if ((unsigned int )key->rsa == (unsigned int )((void *)0)) {
#line 111
        error("ssh_rsa_verify: no RSA key");
#line 112
        return (-1);
      }
    }
  }
#line 114
  tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 114
  if (tmp___0 < 768) {
#line 115
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 115
    error("ssh_rsa_verify: RSA modulus too small: %d < minimum %d bits", tmp, 768);
#line 117
    return (-1);
  }
#line 119
  buffer_init(& b);
#line 120
  buffer_append(& b, (void const   *)signature, signaturelen);
#line 121
  tmp___1 = buffer_get_string(& b, (u_int *)((void *)0));
#line 121
  ktype = (char *)tmp___1;
#line 122
  if (0) {
#line 122
    __s1_len = strlen("ssh-rsa");
#line 122
    __s2_len = strlen((char const   *)ktype);
#line 122
    if (! ((unsigned int )((void const   *)("ssh-rsa" + 1)) - (unsigned int )((void const   *)"ssh-rsa") == 1U)) {
      goto _L___0;
    } else {
#line 122
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 122
        if (! ((unsigned int )((void const   *)(ktype + 1)) - (unsigned int )((void const   *)ktype) == 1U)) {
#line 122
          tmp___11 = 1;
        } else {
#line 122
          if (__s2_len >= 4U) {
#line 122
            tmp___11 = 1;
          } else {
#line 122
            tmp___11 = 0;
          }
        }
      } else {
#line 122
        tmp___11 = 0;
      }
    }
#line 122
    if (tmp___11) {
#line 122
      tmp___7 = __builtin_strcmp("ssh-rsa", (char const   *)ktype);
    } else {
#line 122
      tmp___10 = __builtin_strcmp("ssh-rsa", (char const   *)ktype);
#line 122
      tmp___7 = tmp___10;
    }
  } else {
#line 122
    tmp___10 = __builtin_strcmp("ssh-rsa", (char const   *)ktype);
#line 122
    tmp___7 = tmp___10;
  }
#line 122
  if (tmp___7 != 0) {
#line 123
    error("ssh_rsa_verify: cannot handle type %s", ktype);
#line 124
    buffer_free(& b);
#line 125
    xfree((void *)ktype);
#line 126
    return (-1);
  }
#line 128
  xfree((void *)ktype);
#line 129
  tmp___12 = buffer_get_string(& b, & len);
#line 129
  sigblob = (u_char *)tmp___12;
#line 130
  tmp___13 = buffer_len(& b);
#line 130
  rlen = (int )tmp___13;
#line 131
  buffer_free(& b);
#line 132
  if (rlen != 0) {
#line 133
    error("ssh_rsa_verify: remaining bytes in signature %d", rlen);
#line 134
    xfree((void *)sigblob);
#line 135
    return (-1);
  }
#line 138
  tmp___14 = RSA_size((RSA const   *)key->rsa);
#line 138
  modlen = (unsigned int )tmp___14;
#line 139
  if (len > modlen) {
#line 140
    error("ssh_rsa_verify: len %u > modlen %u", len, modlen);
#line 141
    xfree((void *)sigblob);
#line 142
    return (-1);
  } else {
#line 143
    if (len < modlen) {
#line 144
      diff = modlen - len;
#line 145
      debug("ssh_rsa_verify: add padding: modlen %u > len %u", modlen, len);
#line 147
      tmp___15 = xrealloc((void *)sigblob, modlen);
#line 147
      sigblob = (u_char *)tmp___15;
#line 148
      memmove((void *)(sigblob + diff), (void const   *)sigblob, len);
#line 149
      memset((void *)sigblob, 0, diff);
#line 150
      len = modlen;
    }
  }
#line 152
  if (datafellows & 8192) {
#line 152
    nid = 4;
  } else {
#line 152
    nid = 64;
  }
#line 153
  tmp___16 = OBJ_nid2sn(nid);
#line 153
  evp_md = EVP_get_digestbyname(tmp___16);
#line 153
  if ((unsigned int )evp_md == (unsigned int )((void *)0)) {
#line 154
    error("ssh_rsa_verify: EVP_get_digestbynid %d failed", nid);
#line 155
    xfree((void *)sigblob);
#line 156
    return (-1);
  }
#line 158
  EVP_DigestInit(& md, evp_md);
#line 159
  EVP_DigestUpdate(& md, (void const   *)data, datalen);
#line 160
  EVP_DigestFinal(& md, digest___1, & dlen);
#line 162
  ret = openssh_RSA_verify(nid, digest___1, dlen, sigblob, len, (RSA *)key->rsa);
#line 163
  memset((void *)(digest___1), 'd', sizeof(digest___1));
#line 164
  memset((void *)sigblob, 's', len);
#line 165
  xfree((void *)sigblob);
#line 166
  if (ret == 0) {
#line 166
    tmp___17 = "in";
  } else {
#line 166
    tmp___17 = "";
  }
#line 166
  debug("ssh_rsa_verify: signature %scorrect", tmp___17);
#line 167
  return (ret);
}
}
#line 179 "ssh-rsa.c"
static u_char const   id_sha1[15]  = 
#line 179
  {      (u_char const   )48,      (u_char const   )33,      (u_char const   )48,      (u_char const   )9, 
        (u_char const   )6,      (u_char const   )5,      (u_char const   )43,      (u_char const   )14, 
        (u_char const   )3,      (u_char const   )2,      (u_char const   )26,      (u_char const   )5, 
        (u_char const   )0,      (u_char const   )4,      (u_char const   )20};
#line 191 "ssh-rsa.c"
static u_char const   id_md5[18]  = 
#line 191
  {      (u_char const   )48,      (u_char const   )32,      (u_char const   )48,      (u_char const   )12, 
        (u_char const   )6,      (u_char const   )8,      (u_char const   )42,      (u_char const   )134, 
        (u_char const   )72,      (u_char const   )134,      (u_char const   )247,      (u_char const   )13, 
        (u_char const   )2,      (u_char const   )5,      (u_char const   )5,      (u_char const   )0, 
        (u_char const   )4,      (u_char const   )16};
#line 200 "ssh-rsa.c"
static int openssh_RSA_verify(int type , u_char *hash , u_int hashlen , u_char *sigbuf ,
                              u_int siglen , RSA *rsa ) 
{ u_int ret ;
  u_int rsasize ;
  u_int oidlen ;
  u_int hlen ;
  int len ;
  u_char const   *oid ;
  u_char *decrypted ;
  int tmp ;
  void *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 204
  oidlen = (u_int )0;
#line 204
  hlen = (u_int )0;
#line 206
  oid = (u_char const   *)((void *)0);
#line 207
  decrypted = (u_char *)((void *)0);
#line 209
  ret = 0U;
#line 210
  switch (type) {
  case 64: 
#line 212
  oid = id_sha1;
#line 213
  oidlen = sizeof(id_sha1);
#line 214
  hlen = 20U;
#line 215
  break;
  case 4: 
#line 217
  oid = id_md5;
#line 218
  oidlen = sizeof(id_md5);
#line 219
  hlen = 16U;
#line 220
  break;
  default: ;
  goto done;
#line 223
  break;
  }
#line 225
  if (hashlen != hlen) {
#line 226
    error("bad hashlen");
    goto done;
  }
#line 229
  tmp = RSA_size((RSA const   *)rsa);
#line 229
  rsasize = (unsigned int )tmp;
#line 230
  if (siglen == 0U) {
#line 231
    error("bad siglen");
    goto done;
  } else {
#line 230
    if (siglen > rsasize) {
#line 231
      error("bad siglen");
      goto done;
    }
  }
#line 234
  tmp___0 = xmalloc(rsasize);
#line 234
  decrypted = (u_char *)tmp___0;
#line 235
  len = RSA_public_decrypt((int )siglen, (unsigned char const   *)sigbuf, decrypted,
                           rsa, 1);
#line 235
  if (len < 0) {
#line 237
    tmp___1 = ERR_get_error();
#line 237
    tmp___2 = ERR_error_string(tmp___1, (char *)((void *)0));
#line 237
    error("RSA_public_decrypt failed: %s", tmp___2);
    goto done;
  }
#line 241
  if (len < 0) {
#line 242
    error("bad decrypted len: %d != %d + %d", len, hlen, oidlen);
    goto done;
  } else {
#line 241
    if ((unsigned int )len != hlen + oidlen) {
#line 242
      error("bad decrypted len: %d != %d + %d", len, hlen, oidlen);
      goto done;
    }
  }
#line 245
  tmp___3 = memcmp((void const   *)decrypted, (void const   *)oid, oidlen);
#line 245
  if (tmp___3 != 0) {
#line 246
    error("oid mismatch");
    goto done;
  }
#line 249
  tmp___4 = memcmp((void const   *)(decrypted + oidlen), (void const   *)hash, hlen);
#line 249
  if (tmp___4 != 0) {
#line 250
    error("hash mismatch");
    goto done;
  }
#line 253
  ret = 1U;
  done: 
#line 255
  if (decrypted) {
#line 256
    xfree((void *)decrypted);
  }
#line 257
  return ((int )ret);
}
}
#line 1 "dh.o"
#line 660 "/usr/include/stdio.h"
extern void rewind(FILE *__stream ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 459 "/usr/include/openssl/bn.h"
extern int BN_is_bit_set(BIGNUM const   *a , int n ) ;
#line 173 "/usr/include/openssl/dh.h"
extern DH *DH_new(void) ;
#line 193
extern int DH_generate_key(DH *dh ) ;
#line 35 "dh.h"
DH *choose_dh(int min , int wantbits , int max ) ;
#line 36
DH *dh_new_group_asc(char const   *gen___1 , char const   *modulus ) ;
#line 37
DH *dh_new_group(BIGNUM *gen___1 , BIGNUM *modulus ) ;
#line 38
DH *dh_new_group1(void) ;
#line 39
DH *dh_new_group14(void) ;
#line 41
void dh_gen_key(DH *dh , int need ) ;
#line 42
int dh_pub_is_valid(DH *dh , BIGNUM *dh_pub ) ;
#line 44
int dh_estimate(int bits ) ;
#line 42 "dh.c"
static int parse_prime(int linenum , char *line , struct dhgroup *dhg ) 
{ char *cp ;
  char *arg ;
  char *strsize ;
  char *gen___1 ;
  char *prime ;
  char *tmp___14 ;
  char *tmp___30 ;
  char *tmp___46 ;
  char *tmp___62 ;
  char *tmp___78 ;
  char *tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;

  {
#line 48
  cp = line;
#line 49
  arg = strdelim(& cp);
#line 51
  if ((int )*arg == 0) {
#line 52
    arg = strdelim(& cp);
  }
#line 53
  if (! arg) {
#line 54
    return (0);
  } else {
#line 53
    if (! *arg) {
#line 54
      return (0);
    } else {
#line 53
      if ((int )*arg == 35) {
#line 54
        return (0);
      }
    }
  }
#line 57
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 57
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 59
  tmp___14 = __strsep_g(& cp, " ");
#line 59
  arg = tmp___14;
#line 60
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 60
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 62
  tmp___30 = __strsep_g(& cp, " ");
#line 62
  arg = tmp___30;
#line 63
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 63
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 65
  tmp___46 = __strsep_g(& cp, " ");
#line 65
  arg = tmp___46;
#line 66
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 66
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 68
  tmp___62 = __strsep_g(& cp, " ");
#line 68
  strsize = tmp___62;
#line 69
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 69
    if ((int )*strsize == 0) {
      goto fail;
    } else {
#line 69
      dhg->size = atoi((char const   *)strsize);
#line 69
      if (dhg->size == 0) {
        goto fail;
      }
    }
  }
#line 73
  (dhg->size) ++;
#line 74
  tmp___78 = __strsep_g(& cp, " ");
#line 74
  gen___1 = tmp___78;
#line 75
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 75
    if ((int )*gen___1 == 0) {
      goto fail;
    }
  }
#line 77
  tmp___94 = __strsep_g(& cp, " ");
#line 77
  prime = tmp___94;
#line 78
  if ((unsigned int )cp != (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 78
    if ((int )*prime == 0) {
      goto fail;
    }
  }
#line 81
  dhg->g = BN_new();
#line 81
  if ((unsigned int )dhg->g == (unsigned int )((void *)0)) {
#line 82
    fatal("parse_prime: BN_new failed");
  }
#line 83
  dhg->p = BN_new();
#line 83
  if ((unsigned int )dhg->p == (unsigned int )((void *)0)) {
#line 84
    fatal("parse_prime: BN_new failed");
  }
#line 85
  tmp___95 = BN_hex2bn(& dhg->g, (char const   *)gen___1);
#line 85
  if (tmp___95 == 0) {
    goto failclean;
  }
#line 88
  tmp___96 = BN_hex2bn(& dhg->p, (char const   *)prime);
#line 88
  if (tmp___96 == 0) {
    goto failclean;
  }
#line 91
  tmp___97 = BN_num_bits((BIGNUM const   *)dhg->p);
#line 91
  if (tmp___97 != dhg->size) {
    goto failclean;
  }
#line 94
  if ((dhg->g)->top == 0) {
    goto failclean;
  } else {
#line 94
    if ((dhg->g)->top == 1) {
#line 94
      if (*((dhg->g)->d + 0) == 1UL) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 94
      if (0) {
        _L: /* CIL Label */ 
#line 94
        if (! (dhg->g)->neg) {
          goto failclean;
        }
      }
    }
  }
#line 97
  return (1);
  failclean: 
#line 100
  BN_clear_free(dhg->g);
#line 101
  BN_clear_free(dhg->p);
  fail: 
#line 103
  error("Bad prime description in line %d", linenum);
#line 104
  return (0);
}
}
#line 107 "dh.c"
DH *choose_dh(int min , int wantbits , int max ) 
{ FILE *f ;
  char line[4096] ;
  int best ;
  int bestcount ;
  int which ;
  int linenum ;
  struct dhgroup dhg ;
  DH *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  DH *tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  DH *tmp___7 ;

  {
#line 116
  f = fopen((char const   * __restrict  )"/usr/local/etc/moduli", (char const   * __restrict  )"r");
#line 116
  if ((unsigned int )f == (unsigned int )((void *)0)) {
#line 116
    f = fopen((char const   * __restrict  )"/usr/local/etc/primes", (char const   * __restrict  )"r");
#line 116
    if ((unsigned int )f == (unsigned int )((void *)0)) {
#line 118
      logit("WARNING: %s does not exist, using fixed modulus", "/usr/local/etc/moduli");
#line 120
      tmp = dh_new_group14();
#line 120
      return (tmp);
    }
  }
#line 123
  linenum = 0;
#line 124
  bestcount = 0;
#line 124
  best = bestcount;
#line 125
  while (1) {
#line 125
    tmp___1 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 125
    if (! tmp___1) {
#line 125
      break;
    }
#line 126
    linenum ++;
#line 127
    tmp___0 = parse_prime(linenum, line, & dhg);
#line 127
    if (! tmp___0) {
#line 128
      continue;
    }
#line 129
    BN_clear_free(dhg.g);
#line 130
    BN_clear_free(dhg.p);
#line 132
    if (dhg.size > max) {
#line 133
      continue;
    } else {
#line 132
      if (dhg.size < min) {
#line 133
        continue;
      }
    }
#line 135
    if (dhg.size > wantbits) {
#line 135
      if (dhg.size < best) {
#line 137
        best = dhg.size;
#line 138
        bestcount = 0;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 135
      if (dhg.size > best) {
#line 135
        if (best < wantbits) {
#line 137
          best = dhg.size;
#line 138
          bestcount = 0;
        }
      }
    }
#line 140
    if (dhg.size == best) {
#line 141
      bestcount ++;
    }
  }
#line 143
  rewind(f);
#line 145
  if (bestcount == 0) {
#line 146
    fclose(f);
#line 147
    logit("WARNING: no suitable primes in %s", "/usr/local/etc/primes");
#line 148
    tmp___2 = dh_new_group14();
#line 148
    return (tmp___2);
  }
#line 151
  linenum = 0;
#line 152
  tmp___3 = arc4random();
#line 152
  which = (int )(tmp___3 % (unsigned int )bestcount);
#line 153
  while (1) {
#line 153
    tmp___6 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 153
    if (! tmp___6) {
#line 153
      break;
    }
#line 154
    tmp___4 = parse_prime(linenum, line, & dhg);
#line 154
    if (! tmp___4) {
#line 155
      continue;
    }
#line 156
    if (dhg.size > max) {
#line 159
      BN_clear_free(dhg.g);
#line 160
      BN_clear_free(dhg.p);
#line 161
      continue;
    } else {
#line 156
      if (dhg.size < min) {
#line 159
        BN_clear_free(dhg.g);
#line 160
        BN_clear_free(dhg.p);
#line 161
        continue;
      } else {
#line 156
        if (dhg.size != best) {
#line 159
          BN_clear_free(dhg.g);
#line 160
          BN_clear_free(dhg.p);
#line 161
          continue;
        } else {
#line 156
          tmp___5 = linenum;
#line 156
          linenum ++;
#line 156
          if (tmp___5 != which) {
#line 159
            BN_clear_free(dhg.g);
#line 160
            BN_clear_free(dhg.p);
#line 161
            continue;
          }
        }
      }
    }
#line 163
    break;
  }
#line 165
  fclose(f);
#line 166
  if (linenum != which + 1) {
#line 167
    fatal("WARNING: line %d disappeared in %s, giving up", which, "/usr/local/etc/primes");
  }
#line 170
  tmp___7 = dh_new_group(dhg.g, dhg.p);
#line 170
  return (tmp___7);
}
}
#line 175 "dh.c"
int dh_pub_is_valid(DH *dh , BIGNUM *dh_pub ) 
{ int i ;
  int n___0 ;
  int tmp ;
  int bits_set ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 179
  tmp = BN_num_bits((BIGNUM const   *)dh_pub);
#line 179
  n___0 = tmp;
#line 180
  bits_set = 0;
#line 182
  if (dh_pub->neg) {
#line 183
    logit("invalid public DH value: negativ");
#line 184
    return (0);
  }
#line 186
  i = 0;
#line 186
  while (i <= n___0) {
#line 187
    tmp___0 = BN_is_bit_set((BIGNUM const   *)dh_pub, i);
#line 187
    if (tmp___0) {
#line 188
      bits_set ++;
    }
#line 186
    i ++;
  }
#line 189
  tmp___1 = BN_num_bits((BIGNUM const   *)dh->p);
#line 189
  debug2("bits set: %d/%d", bits_set, tmp___1);
#line 192
  if (bits_set > 1) {
#line 192
    tmp___2 = BN_cmp((BIGNUM const   *)dh_pub, (BIGNUM const   *)dh->p);
#line 192
    if (tmp___2 == -1) {
#line 193
      return (1);
    }
  }
#line 194
  tmp___3 = BN_num_bits((BIGNUM const   *)dh->p);
#line 194
  logit("invalid public DH value (%d/%d)", bits_set, tmp___3);
#line 195
  return (0);
}
}
#line 198 "dh.c"
void dh_gen_key(DH *dh , int need ) 
{ int i ;
  int bits_set ;
  int tries ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 201
  tries = 0;
#line 203
  if ((unsigned int )dh->p == (unsigned int )((void *)0)) {
#line 204
    fatal("dh_gen_key: dh->p == NULL");
  }
#line 205
  if (need > 1073741823) {
#line 206
    tmp = BN_num_bits((BIGNUM const   *)dh->p);
#line 206
    fatal("dh_gen_key: group too small: %d (2*need %d)", tmp, 2 * need);
  } else {
#line 205
    tmp___0 = BN_num_bits((BIGNUM const   *)dh->p);
#line 205
    if (2 * need >= tmp___0) {
#line 206
      tmp = BN_num_bits((BIGNUM const   *)dh->p);
#line 206
      fatal("dh_gen_key: group too small: %d (2*need %d)", tmp, 2 * need);
    }
  }
#line 208
  while (1) {
#line 209
    if ((unsigned int )dh->priv_key != (unsigned int )((void *)0)) {
#line 210
      BN_clear_free(dh->priv_key);
    }
#line 211
    dh->priv_key = BN_new();
#line 211
    if ((unsigned int )dh->priv_key == (unsigned int )((void *)0)) {
#line 212
      fatal("dh_gen_key: BN_new failed");
    }
#line 214
    tmp___1 = BN_rand(dh->priv_key, 2 * need, 0, 0);
#line 214
    if (! tmp___1) {
#line 215
      fatal("dh_gen_key: BN_rand failed");
    }
#line 216
    tmp___2 = DH_generate_key(dh);
#line 216
    if (tmp___2 == 0) {
#line 217
      fatal("DH_generate_key");
    }
#line 218
    i = 0;
#line 218
    bits_set = 0;
#line 218
    while (1) {
#line 218
      tmp___4 = BN_num_bits((BIGNUM const   *)dh->priv_key);
#line 218
      if (! (i <= tmp___4)) {
#line 218
        break;
      }
#line 219
      tmp___3 = BN_is_bit_set((BIGNUM const   *)dh->priv_key, i);
#line 219
      if (tmp___3) {
#line 220
        bits_set ++;
      }
#line 218
      i ++;
    }
#line 221
    tmp___5 = BN_num_bits((BIGNUM const   *)dh->priv_key);
#line 221
    debug2("dh_gen_key: priv key bits set: %d/%d", bits_set, tmp___5);
#line 223
    tmp___6 = tries;
#line 223
    tries ++;
#line 223
    if (tmp___6 > 10) {
#line 224
      fatal("dh_gen_key: too many bad keys: giving up");
    }
#line 208
    tmp___7 = dh_pub_is_valid(dh, dh->pub_key);
#line 208
    if (tmp___7) {
#line 208
      break;
    }
  }
#line 226
  return;
}
}
#line 228 "dh.c"
DH *dh_new_group_asc(char const   *gen___1 , char const   *modulus ) 
{ DH *dh ;
  int tmp ;
  int tmp___0 ;

  {
#line 233
  dh = DH_new();
#line 233
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 234
    fatal("dh_new_group_asc: DH_new");
  }
#line 236
  tmp = BN_hex2bn(& dh->p, modulus);
#line 236
  if (tmp == 0) {
#line 237
    fatal("BN_hex2bn p");
  }
#line 238
  tmp___0 = BN_hex2bn(& dh->g, gen___1);
#line 238
  if (tmp___0 == 0) {
#line 239
    fatal("BN_hex2bn g");
  }
#line 241
  return (dh);
}
}
#line 249 "dh.c"
DH *dh_new_group(BIGNUM *gen___1 , BIGNUM *modulus ) 
{ DH *dh ;

  {
#line 254
  dh = DH_new();
#line 254
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 255
    fatal("dh_new_group: DH_new");
  }
#line 256
  dh->p = modulus;
#line 257
  dh->g = gen___1;
#line 259
  return (dh);
}
}
#line 265 "dh.c"
static char *gen  =    (char *)"2";
#line 265 "dh.c"
static char *group1  =    (char *)"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF";
#line 262 "dh.c"
DH *dh_new_group1(void) 
{ DH *tmp ;

  {
#line 273
  tmp = dh_new_group_asc((char const   *)gen, (char const   *)group1);
#line 273
  return (tmp);
}
}
#line 279 "dh.c"
static char *gen___0  =    (char *)"2";
#line 279 "dh.c"
static char *group14  =    (char *)"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AACAA68FFFFFFFFFFFFFFFF";
#line 276 "dh.c"
DH *dh_new_group14(void) 
{ DH *tmp ;

  {
#line 292
  tmp = dh_new_group_asc((char const   *)gen___0, (char const   *)group14);
#line 292
  return (tmp);
}
}
#line 301 "dh.c"
int dh_estimate(int bits ) 
{ 

  {
#line 305
  if (bits <= 128) {
#line 306
    return (1024);
  }
#line 307
  if (bits <= 192) {
#line 308
    return (2048);
  }
#line 309
  return (4096);
}
}
#line 1 "kexdh.o"
#line 140 "kex.h"
void kex_dh_hash(char *client_version_string___0 , char *server_version_string___0 ,
                 char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                 u_char *serverhostkeyblob , int sbloblen , BIGNUM *client_dh_pub ,
                 BIGNUM *server_dh_pub , BIGNUM *shared_secret , u_char **hash , u_int *hashlen ) ;
#line 48 "kexdh.c"
static u_char digest[64]  ;
#line 35 "kexdh.c"
void kex_dh_hash(char *client_version_string___0 , char *server_version_string___0 ,
                 char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                 u_char *serverhostkeyblob , int sbloblen , BIGNUM *client_dh_pub ,
                 BIGNUM *server_dh_pub , BIGNUM *shared_secret , u_char **hash , u_int *hashlen ) 
{ Buffer b ;
  EVP_MD const   *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  u_int tmp___0 ;
  void *tmp___1 ;

  {
#line 49
  tmp = EVP_sha1();
#line 49
  evp_md = tmp;
#line 52
  buffer_init(& b);
#line 53
  buffer_put_cstring(& b, (char const   *)client_version_string___0);
#line 54
  buffer_put_cstring(& b, (char const   *)server_version_string___0);
#line 57
  buffer_put_int(& b, (unsigned int )(ckexinitlen + 1));
#line 58
  buffer_put_char(& b, 20);
#line 59
  buffer_append(& b, (void const   *)ckexinit, (unsigned int )ckexinitlen);
#line 60
  buffer_put_int(& b, (unsigned int )(skexinitlen + 1));
#line 61
  buffer_put_char(& b, 20);
#line 62
  buffer_append(& b, (void const   *)skexinit, (unsigned int )skexinitlen);
#line 64
  buffer_put_string(& b, (void const   *)serverhostkeyblob, (unsigned int )sbloblen);
#line 65
  buffer_put_bignum2(& b, (BIGNUM const   *)client_dh_pub);
#line 66
  buffer_put_bignum2(& b, (BIGNUM const   *)server_dh_pub);
#line 67
  buffer_put_bignum2(& b, (BIGNUM const   *)shared_secret);
#line 72
  EVP_DigestInit(& md, evp_md);
#line 73
  tmp___0 = buffer_len(& b);
#line 73
  tmp___1 = buffer_ptr(& b);
#line 73
  EVP_DigestUpdate(& md, (void const   *)tmp___1, tmp___0);
#line 74
  EVP_DigestFinal(& md, digest, (unsigned int *)((void *)0));
#line 76
  buffer_free(& b);
#line 81
  *hash = digest;
#line 82
  *hashlen = (unsigned int )evp_md->md_size;
#line 83
  return;
}
}
#line 1 "kexgex.o"
#line 143 "kex.h"
void kexgex_hash(EVP_MD const   *evp_md , char *client_version_string___0 , char *server_version_string___0 ,
                 char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                 u_char *serverhostkeyblob , int sbloblen , int min , int wantbits ,
                 int max , BIGNUM *prime , BIGNUM *gen___1 , BIGNUM *client_dh_pub ,
                 BIGNUM *server_dh_pub , BIGNUM *shared_secret , u_char **hash , u_int *hashlen ) ;
#line 51 "kexgex.c"
static u_char digest___0[64]  ;
#line 36 "kexgex.c"
void kexgex_hash(EVP_MD const   *evp_md , char *client_version_string___0 , char *server_version_string___0 ,
                 char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                 u_char *serverhostkeyblob , int sbloblen , int min , int wantbits ,
                 int max , BIGNUM *prime , BIGNUM *gen___1 , BIGNUM *client_dh_pub ,
                 BIGNUM *server_dh_pub , BIGNUM *shared_secret , u_char **hash , u_int *hashlen ) 
{ Buffer b ;
  EVP_MD_CTX md ;
  u_int tmp ;
  void *tmp___0 ;

  {
#line 54
  buffer_init(& b);
#line 55
  buffer_put_cstring(& b, (char const   *)client_version_string___0);
#line 56
  buffer_put_cstring(& b, (char const   *)server_version_string___0);
#line 59
  buffer_put_int(& b, (unsigned int )(ckexinitlen + 1));
#line 60
  buffer_put_char(& b, 20);
#line 61
  buffer_append(& b, (void const   *)ckexinit, (unsigned int )ckexinitlen);
#line 62
  buffer_put_int(& b, (unsigned int )(skexinitlen + 1));
#line 63
  buffer_put_char(& b, 20);
#line 64
  buffer_append(& b, (void const   *)skexinit, (unsigned int )skexinitlen);
#line 66
  buffer_put_string(& b, (void const   *)serverhostkeyblob, (unsigned int )sbloblen);
#line 67
  if (min == -1) {
#line 68
    buffer_put_int(& b, (unsigned int )wantbits);
  } else {
#line 67
    if (max == -1) {
#line 68
      buffer_put_int(& b, (unsigned int )wantbits);
    } else {
#line 70
      buffer_put_int(& b, (unsigned int )min);
#line 71
      buffer_put_int(& b, (unsigned int )wantbits);
#line 72
      buffer_put_int(& b, (unsigned int )max);
    }
  }
#line 74
  buffer_put_bignum2(& b, (BIGNUM const   *)prime);
#line 75
  buffer_put_bignum2(& b, (BIGNUM const   *)gen___1);
#line 76
  buffer_put_bignum2(& b, (BIGNUM const   *)client_dh_pub);
#line 77
  buffer_put_bignum2(& b, (BIGNUM const   *)server_dh_pub);
#line 78
  buffer_put_bignum2(& b, (BIGNUM const   *)shared_secret);
#line 84
  EVP_DigestInit(& md, evp_md);
#line 85
  tmp = buffer_len(& b);
#line 85
  tmp___0 = buffer_ptr(& b);
#line 85
  EVP_DigestUpdate(& md, (void const   *)tmp___0, tmp);
#line 86
  EVP_DigestFinal(& md, digest___0, (unsigned int *)((void *)0));
#line 88
  buffer_free(& b);
#line 89
  *hash = digest___0;
#line 90
  *hashlen = (unsigned int )evp_md->md_size;
#line 94
  return;
}
}
#line 1 "kexdhc.o"
#line 174 "/usr/include/openssl/dh.h"
extern void DH_free(DH *dh ) ;
#line 176
extern int DH_size(DH const   *dh ) ;
#line 194
extern int DH_compute_key(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
#line 135 "kex.h"
void kexdh_client(Kex *kex ) ;
#line 36 "kexdhc.c"
void kexdh_client(Kex *kex ) 
{ BIGNUM *dh_server_pub ;
  BIGNUM *shared_secret ;
  DH *dh ;
  Key *server_host_key ;
  u_char *server_host_key_blob ;
  u_char *signature ;
  u_char *kbuf ;
  u_char *hash ;
  u_int klen ;
  u_int kout ;
  u_int slen ;
  u_int sbloblen ;
  u_int hashlen ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int _len ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  u_int tmp___7 ;
  void *tmp___8 ;
  u_int tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;

  {
#line 39
  dh_server_pub = (BIGNUM *)((void *)0);
#line 39
  shared_secret = (BIGNUM *)((void *)0);
#line 42
  server_host_key_blob = (u_char *)((void *)0);
#line 42
  signature = (u_char *)((void *)0);
#line 47
  switch (kex->kex_type) {
  case 0: 
#line 49
  dh = dh_new_group1();
#line 50
  break;
  case 1: 
#line 52
  dh = dh_new_group14();
#line 53
  break;
  default: 
#line 55
  fatal("%s: Unexpected KEX type %d", "kexdh_client", kex->kex_type);
  }
#line 57
  dh_gen_key(dh, (int )(kex->we_need * 8U));
#line 58
  packet_start((unsigned char)30);
#line 59
  packet_put_bignum2(dh->pub_key);
#line 60
  packet_send();
#line 62
  debug("sending SSH2_MSG_KEXDH_INIT");
#line 70
  debug("expecting SSH2_MSG_KEXDH_REPLY");
#line 71
  packet_read_expect(31);
#line 74
  tmp = packet_get_string(& sbloblen);
#line 74
  server_host_key_blob = (u_char *)tmp;
#line 75
  server_host_key = key_from_blob((u_char const   *)server_host_key_blob, sbloblen);
#line 76
  if ((unsigned int )server_host_key == (unsigned int )((void *)0)) {
#line 77
    fatal("cannot decode server_host_key_blob");
  }
#line 78
  if (server_host_key->type != kex->hostkey_type) {
#line 79
    fatal("type mismatch for decoded server_host_key_blob");
  }
#line 80
  if ((unsigned int )kex->verify_host_key == (unsigned int )((void *)0)) {
#line 81
    fatal("cannot verify server_host_key");
  }
#line 82
  tmp___0 = (*(kex->verify_host_key))(server_host_key);
#line 82
  if (tmp___0 == -1) {
#line 83
    fatal("server_host_key verification failed");
  }
#line 86
  dh_server_pub = BN_new();
#line 86
  if ((unsigned int )dh_server_pub == (unsigned int )((void *)0)) {
#line 87
    fatal("dh_server_pub == NULL");
  }
#line 88
  packet_get_bignum2(dh_server_pub);
#line 98
  tmp___1 = packet_get_string(& slen);
#line 98
  signature = (u_char *)tmp___1;
#line 99
  while (1) {
#line 99
    tmp___2 = packet_remaining();
#line 99
    _len = tmp___2;
#line 99
    if (_len > 0) {
#line 99
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kexdhc.c",
            99);
#line 99
      packet_disconnect("Packet integrity error.");
    }
#line 99
    break;
  }
#line 101
  tmp___3 = dh_pub_is_valid(dh, dh_server_pub);
#line 101
  if (! tmp___3) {
#line 102
    packet_disconnect("bad server public DH value");
  }
#line 104
  tmp___4 = DH_size((DH const   *)dh);
#line 104
  klen = (unsigned int )tmp___4;
#line 105
  tmp___5 = xmalloc(klen);
#line 105
  kbuf = (u_char *)tmp___5;
#line 106
  tmp___6 = DH_compute_key(kbuf, (BIGNUM const   *)dh_server_pub, dh);
#line 106
  kout = (unsigned int )tmp___6;
#line 110
  shared_secret = BN_new();
#line 110
  if ((unsigned int )shared_secret == (unsigned int )((void *)0)) {
#line 111
    fatal("kexdh_client: BN_new failed");
  }
#line 112
  BN_bin2bn((unsigned char const   *)kbuf, (int )kout, shared_secret);
#line 113
  memset((void *)kbuf, 0, klen);
#line 114
  xfree((void *)kbuf);
#line 117
  tmp___7 = buffer_len(& kex->peer);
#line 117
  tmp___8 = buffer_ptr(& kex->peer);
#line 117
  tmp___9 = buffer_len(& kex->my);
#line 117
  tmp___10 = buffer_ptr(& kex->my);
#line 117
  kex_dh_hash(kex->client_version_string, kex->server_version_string, (char *)tmp___10,
              (int )tmp___9, (char *)tmp___8, (int )tmp___7, server_host_key_blob,
              (int )sbloblen, dh->pub_key, dh_server_pub, shared_secret, & hash, & hashlen);
#line 128
  xfree((void *)server_host_key_blob);
#line 129
  BN_clear_free(dh_server_pub);
#line 130
  DH_free(dh);
#line 132
  tmp___11 = key_verify((Key const   *)server_host_key, (u_char const   *)signature,
                        slen, (u_char const   *)hash, hashlen);
#line 132
  if (tmp___11 != 1) {
#line 133
    fatal("key_verify failed for server_host_key");
  }
#line 134
  key_free(server_host_key);
#line 135
  xfree((void *)signature);
#line 138
  if ((unsigned int )kex->session_id == (unsigned int )((void *)0)) {
#line 139
    kex->session_id_len = hashlen;
#line 140
    tmp___12 = xmalloc(kex->session_id_len);
#line 140
    kex->session_id = (u_char *)tmp___12;
#line 141
    memcpy((void * __restrict  )kex->session_id, (void const   * __restrict  )hash,
           kex->session_id_len);
  }
#line 144
  kex_derive_keys(kex, hash, hashlen, shared_secret);
#line 145
  BN_clear_free(shared_secret);
#line 146
  kex_finish(kex);
#line 147
  return;
}
}
#line 1 "kexgexc.o"
#line 137 "kex.h"
void kexgex_client(Kex *kex ) ;
#line 38 "kexgexc.c"
void kexgex_client(Kex *kex ) 
{ BIGNUM *dh_server_pub ;
  BIGNUM *shared_secret ;
  BIGNUM *p ;
  BIGNUM *g ;
  Key *server_host_key ;
  u_char *kbuf ;
  u_char *hash ;
  u_char *signature ;
  u_char *server_host_key_blob ;
  u_int klen ;
  u_int kout ;
  u_int slen ;
  u_int sbloblen ;
  u_int hashlen ;
  int min ;
  int max ;
  int nbits ;
  DH *dh ;
  int _len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int _len___0 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  u_int tmp___11 ;
  void *tmp___12 ;
  u_int tmp___13 ;
  void *tmp___14 ;
  int tmp___15 ;
  void *tmp___16 ;

  {
#line 41
  dh_server_pub = (BIGNUM *)((void *)0);
#line 41
  shared_secret = (BIGNUM *)((void *)0);
#line 42
  p = (BIGNUM *)((void *)0);
#line 42
  g = (BIGNUM *)((void *)0);
#line 44
  signature = (u_char *)((void *)0);
#line 44
  server_host_key_blob = (u_char *)((void *)0);
#line 49
  nbits = dh_estimate((int )(kex->we_need * 8U));
#line 51
  if (datafellows & 16384) {
#line 53
    packet_start((unsigned char)30);
#line 54
    packet_put_int((unsigned int )nbits);
#line 55
    min = 1024;
#line 56
    max = 8192;
#line 58
    debug("SSH2_MSG_KEX_DH_GEX_REQUEST_OLD(%u) sent", nbits);
  } else {
#line 61
    min = 1024;
#line 62
    max = 8192;
#line 63
    packet_start((unsigned char)34);
#line 64
    packet_put_int((unsigned int )min);
#line 65
    packet_put_int((unsigned int )nbits);
#line 66
    packet_put_int((unsigned int )max);
#line 68
    debug("SSH2_MSG_KEX_DH_GEX_REQUEST(%u<%u<%u) sent", min, nbits, max);
  }
#line 75
  packet_send();
#line 77
  debug("expecting SSH2_MSG_KEX_DH_GEX_GROUP");
#line 78
  packet_read_expect(31);
#line 80
  p = BN_new();
#line 80
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 81
    fatal("BN_new");
  }
#line 82
  packet_get_bignum2(p);
#line 83
  g = BN_new();
#line 83
  if ((unsigned int )g == (unsigned int )((void *)0)) {
#line 84
    fatal("BN_new");
  }
#line 85
  packet_get_bignum2(g);
#line 86
  while (1) {
#line 86
    tmp = packet_remaining();
#line 86
    _len = tmp;
#line 86
    if (_len > 0) {
#line 86
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kexgexc.c",
            86);
#line 86
      packet_disconnect("Packet integrity error.");
    }
#line 86
    break;
  }
#line 88
  tmp___1 = BN_num_bits((BIGNUM const   *)p);
#line 88
  if (tmp___1 < min) {
#line 89
    tmp___0 = BN_num_bits((BIGNUM const   *)p);
#line 89
    fatal("DH_GEX group out of range: %d !< %d !< %d", min, tmp___0, max);
  } else {
#line 88
    tmp___2 = BN_num_bits((BIGNUM const   *)p);
#line 88
    if (tmp___2 > max) {
#line 89
      tmp___0 = BN_num_bits((BIGNUM const   *)p);
#line 89
      fatal("DH_GEX group out of range: %d !< %d !< %d", min, tmp___0, max);
    }
  }
#line 92
  dh = dh_new_group(g, p);
#line 93
  dh_gen_key(dh, (int )(kex->we_need * 8U));
#line 102
  debug("SSH2_MSG_KEX_DH_GEX_INIT sent");
#line 104
  packet_start((unsigned char)32);
#line 105
  packet_put_bignum2(dh->pub_key);
#line 106
  packet_send();
#line 108
  debug("expecting SSH2_MSG_KEX_DH_GEX_REPLY");
#line 109
  packet_read_expect(33);
#line 112
  tmp___3 = packet_get_string(& sbloblen);
#line 112
  server_host_key_blob = (u_char *)tmp___3;
#line 113
  server_host_key = key_from_blob((u_char const   *)server_host_key_blob, sbloblen);
#line 114
  if ((unsigned int )server_host_key == (unsigned int )((void *)0)) {
#line 115
    fatal("cannot decode server_host_key_blob");
  }
#line 116
  if (server_host_key->type != kex->hostkey_type) {
#line 117
    fatal("type mismatch for decoded server_host_key_blob");
  }
#line 118
  if ((unsigned int )kex->verify_host_key == (unsigned int )((void *)0)) {
#line 119
    fatal("cannot verify server_host_key");
  }
#line 120
  tmp___4 = (*(kex->verify_host_key))(server_host_key);
#line 120
  if (tmp___4 == -1) {
#line 121
    fatal("server_host_key verification failed");
  }
#line 124
  dh_server_pub = BN_new();
#line 124
  if ((unsigned int )dh_server_pub == (unsigned int )((void *)0)) {
#line 125
    fatal("dh_server_pub == NULL");
  }
#line 126
  packet_get_bignum2(dh_server_pub);
#line 136
  tmp___5 = packet_get_string(& slen);
#line 136
  signature = (u_char *)tmp___5;
#line 137
  while (1) {
#line 137
    tmp___6 = packet_remaining();
#line 137
    _len___0 = tmp___6;
#line 137
    if (_len___0 > 0) {
#line 137
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "kexgexc.c",
            137);
#line 137
      packet_disconnect("Packet integrity error.");
    }
#line 137
    break;
  }
#line 139
  tmp___7 = dh_pub_is_valid(dh, dh_server_pub);
#line 139
  if (! tmp___7) {
#line 140
    packet_disconnect("bad server public DH value");
  }
#line 142
  tmp___8 = DH_size((DH const   *)dh);
#line 142
  klen = (unsigned int )tmp___8;
#line 143
  tmp___9 = xmalloc(klen);
#line 143
  kbuf = (u_char *)tmp___9;
#line 144
  tmp___10 = DH_compute_key(kbuf, (BIGNUM const   *)dh_server_pub, dh);
#line 144
  kout = (unsigned int )tmp___10;
#line 148
  shared_secret = BN_new();
#line 148
  if ((unsigned int )shared_secret == (unsigned int )((void *)0)) {
#line 149
    fatal("kexgex_client: BN_new failed");
  }
#line 150
  BN_bin2bn((unsigned char const   *)kbuf, (int )kout, shared_secret);
#line 151
  memset((void *)kbuf, 0, klen);
#line 152
  xfree((void *)kbuf);
#line 154
  if (datafellows & 16384) {
#line 155
    max = -1;
#line 155
    min = max;
  }
#line 158
  tmp___11 = buffer_len(& kex->peer);
#line 158
  tmp___12 = buffer_ptr(& kex->peer);
#line 158
  tmp___13 = buffer_len(& kex->my);
#line 158
  tmp___14 = buffer_ptr(& kex->my);
#line 158
  kexgex_hash(kex->evp_md, kex->client_version_string, kex->server_version_string,
              (char *)tmp___14, (int )tmp___13, (char *)tmp___12, (int )tmp___11,
              server_host_key_blob, (int )sbloblen, min, nbits, max, dh->p, dh->g,
              dh->pub_key, dh_server_pub, shared_secret, & hash, & hashlen);
#line 174
  DH_free(dh);
#line 175
  xfree((void *)server_host_key_blob);
#line 176
  BN_clear_free(dh_server_pub);
#line 178
  tmp___15 = key_verify((Key const   *)server_host_key, (u_char const   *)signature,
                        slen, (u_char const   *)hash, hashlen);
#line 178
  if (tmp___15 != 1) {
#line 179
    fatal("key_verify failed for server_host_key");
  }
#line 180
  key_free(server_host_key);
#line 181
  xfree((void *)signature);
#line 184
  if ((unsigned int )kex->session_id == (unsigned int )((void *)0)) {
#line 185
    kex->session_id_len = hashlen;
#line 186
    tmp___16 = xmalloc(kex->session_id_len);
#line 186
    kex->session_id = (u_char *)tmp___16;
#line 187
    memcpy((void * __restrict  )kex->session_id, (void const   * __restrict  )hash,
           kex->session_id_len);
  }
#line 189
  kex_derive_keys(kex, hash, hashlen, shared_secret);
#line 190
  BN_clear_free(shared_secret);
#line 192
  kex_finish(kex);
#line 193
  return;
}
}
#line 1 "scard.o"
#line 1 "msg.o"
#line 28 "msg.h"
int ssh_msg_send(int fd , u_char type , Buffer *m___0 ) ;
#line 29
int ssh_msg_recv(int fd , Buffer *m___0 ) ;
#line 33 "msg.c"
int ssh_msg_send(int fd , u_char type , Buffer *m___0 ) 
{ u_char buf___1[5] ;
  u_int mlen ;
  u_int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
#line 37
  tmp = buffer_len(m___0);
#line 37
  mlen = tmp;
#line 39
  debug3("ssh_msg_send: type %u", (unsigned int )type & 255U);
#line 41
  while (1) {
#line 41
    buf___1[0] = (unsigned char )((mlen + 1U) >> 24);
#line 41
    buf___1[1] = (unsigned char )((mlen + 1U) >> 16);
#line 41
    buf___1[2] = (unsigned char )((mlen + 1U) >> 8);
#line 41
    buf___1[3] = (unsigned char )(mlen + 1U);
#line 41
    break;
  }
#line 42
  buf___1[4] = type;
#line 43
  tmp___0 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), fd, (void *)(buf___1),
                     sizeof(buf___1));
#line 43
  if (tmp___0 != sizeof(buf___1)) {
#line 44
    error("ssh_msg_send: write");
#line 45
    return (-1);
  }
#line 47
  tmp___1 = buffer_ptr(m___0);
#line 47
  tmp___2 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), fd, tmp___1,
                     mlen);
#line 47
  if (tmp___2 != mlen) {
#line 48
    error("ssh_msg_send: write");
#line 49
    return (-1);
  }
#line 51
  return (0);
}
}
#line 54 "msg.c"
int ssh_msg_recv(int fd , Buffer *m___0 ) 
{ u_char buf___1[4] ;
  u_int msg_len ;
  int *tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;

  {
#line 60
  debug3("ssh_msg_recv entering");
#line 62
  tmp___0 = atomicio(& read, fd, (void *)(buf___1), sizeof(buf___1));
#line 62
  if (tmp___0 != sizeof(buf___1)) {
#line 63
    tmp = __errno_location();
#line 63
    if (*tmp != 32) {
#line 64
      error("ssh_msg_recv: read: header");
    }
#line 65
    return (-1);
  }
#line 67
  msg_len = (unsigned int )(((((unsigned long )buf___1[0] << 24) | ((unsigned long )buf___1[1] << 16)) | ((unsigned long )buf___1[2] << 8)) | (unsigned long )buf___1[3]);
#line 68
  if (msg_len > 262144U) {
#line 69
    error("ssh_msg_recv: read: bad msg_len %u", msg_len);
#line 70
    return (-1);
  }
#line 72
  buffer_clear(m___0);
#line 73
  buffer_append_space(m___0, msg_len);
#line 74
  tmp___3 = buffer_ptr(m___0);
#line 74
  tmp___4 = atomicio(& read, fd, tmp___3, msg_len);
#line 74
  if (tmp___4 != msg_len) {
#line 75
    tmp___1 = __errno_location();
#line 75
    tmp___2 = strerror(*tmp___1);
#line 75
    error("ssh_msg_recv: read: %s", tmp___2);
#line 76
    return (-1);
  }
#line 78
  return (0);
}
}
#line 1 "progressmeter.o"
#line 393 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 581
extern  __attribute__((__nothrow__)) __pid_t getpgrp(void) ;
#line 805
extern  __attribute__((__nothrow__)) __pid_t tcgetpgrp(int __fd ) ;
#line 26 "progressmeter.h"
void start_progress_meter(char *f , off_t filesize , off_t *ctr ) ;
#line 27
void stop_progress_meter(void) ;
#line 39 "progressmeter.c"
static int can_output(void) ;
#line 42
static void format_size(char *buf___1 , int size , off_t bytes ) ;
#line 43
static void format_rate(char *buf___1 , int size , off_t bytes ) ;
#line 46
static void sig_winch(int sig ) ;
#line 47
static void setscreensize(void) ;
#line 50
void refresh_progress_meter(void) ;
#line 53
static void update_progress_meter(int ignore ) ;
#line 55 "progressmeter.c"
static time_t start  ;
#line 56 "progressmeter.c"
static time_t last_update  ;
#line 57 "progressmeter.c"
static char *file  ;
#line 58 "progressmeter.c"
static off_t end_pos  ;
#line 59 "progressmeter.c"
static off_t cur_pos  ;
#line 60 "progressmeter.c"
static off_t volatile   *counter  ;
#line 61 "progressmeter.c"
static long stalled  ;
#line 62 "progressmeter.c"
static int bytes_per_second  ;
#line 63 "progressmeter.c"
static int win_size  ;
#line 64 "progressmeter.c"
static sig_atomic_t volatile   win_resized  ;
#line 67 "progressmeter.c"
static char const   unit[6]  = {      (char const   )' ',      (char const   )'K',      (char const   )'M',      (char const   )'G', 
        (char const   )'T',      (char const   )'\000'};
#line 69 "progressmeter.c"
static int can_output(void) 
{ __pid_t tmp ;
  __pid_t tmp___0 ;

  {
#line 72
  tmp = getpgrp();
#line 72
  tmp___0 = tcgetpgrp(1);
#line 72
  return (tmp == tmp___0);
}
}
#line 75 "progressmeter.c"
static void format_rate(char *buf___1 , int size , off_t bytes ) 
{ int i ;
  char const   *tmp ;

  {
#line 80
  bytes *= 100LL;
#line 81
  i = 0;
#line 81
  while (1) {
#line 81
    if (bytes >= 100000LL) {
#line 81
      if (! ((int const   )unit[i] != 84)) {
#line 81
        break;
      }
    } else {
#line 81
      break;
    }
#line 82
    bytes = (bytes + 512LL) / 1024LL;
#line 81
    i ++;
  }
#line 83
  if (i == 0) {
#line 84
    i ++;
#line 85
    bytes = (bytes + 512LL) / 1024LL;
  }
#line 87
  if (i) {
#line 87
    tmp = "B";
  } else {
#line 87
    tmp = " ";
  }
#line 87
  snprintf((char * __restrict  )buf___1, (unsigned int )size, (char const   * __restrict  )"%3lld.%1lld%c%s",
           (bytes + 5LL) / 100LL, ((bytes + 5LL) / 10LL) % 10LL, unit[i], tmp);
#line 92
  return;
}
}
#line 94 "progressmeter.c"
static void format_size(char *buf___1 , int size , off_t bytes ) 
{ int i ;
  char const   *tmp ;

  {
#line 99
  i = 0;
#line 99
  while (1) {
#line 99
    if (bytes >= 10000LL) {
#line 99
      if (! ((int const   )unit[i] != 84)) {
#line 99
        break;
      }
    } else {
#line 99
      break;
    }
#line 100
    bytes = (bytes + 512LL) / 1024LL;
#line 99
    i ++;
  }
#line 101
  if (i) {
#line 101
    tmp = "B";
  } else {
#line 101
    tmp = " ";
  }
#line 101
  snprintf((char * __restrict  )buf___1, (unsigned int )size, (char const   * __restrict  )"%4lld%c%s",
           bytes, unit[i], tmp);
#line 105
  return;
}
}
#line 107 "progressmeter.c"
void refresh_progress_meter(void) 
{ char buf___1[513] ;
  time_t now ;
  off_t transferred ;
  double elapsed ;
  int percent ;
  off_t bytes_left ;
  int cur_speed ;
  int hours ;
  int minutes ;
  int seconds ;
  int i ;
  int len ;
  int file_len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
#line 121
  transferred = (long long )(*counter - (off_t volatile   )cur_pos);
#line 122
  cur_pos = (long long )*counter;
#line 123
  now = time((time_t *)((void *)0));
#line 124
  bytes_left = end_pos - cur_pos;
#line 126
  if (bytes_left > 0LL) {
#line 127
    elapsed = (double )(now - last_update);
  } else {
#line 129
    elapsed = (double )(now - start);
#line 131
    transferred = end_pos;
#line 132
    bytes_per_second = 0;
  }
#line 136
  if (elapsed != (double )0) {
#line 137
    cur_speed = (int )((double )transferred / elapsed);
  } else {
#line 139
    cur_speed = (int )transferred;
  }
#line 142
  if (bytes_per_second != 0) {
#line 143
    bytes_per_second = (int )((double )bytes_per_second * 0.9 + (double )cur_speed * (1.0 - 0.9));
  } else {
#line 146
    bytes_per_second = cur_speed;
  }
#line 149
  buf___1[0] = (char )'\000';
#line 150
  file_len = win_size - 35;
#line 151
  if (file_len > 0) {
#line 152
    len = snprintf((char * __restrict  )(buf___1), (unsigned int )(file_len + 1),
                   (char const   * __restrict  )"\r%s", file);
#line 153
    if (len < 0) {
#line 154
      len = 0;
    }
#line 155
    if (len >= file_len + 1) {
#line 156
      len = file_len;
    }
#line 157
    i = len;
#line 157
    while (i < file_len) {
#line 158
      buf___1[i] = (char )' ';
#line 157
      i ++;
    }
#line 159
    buf___1[file_len] = (char )'\000';
  }
#line 163
  if (end_pos != 0LL) {
#line 164
    percent = (int )(((float )cur_pos / (float )end_pos) * (float )100);
  } else {
#line 166
    percent = 100;
  }
#line 167
  tmp = strlen((char const   *)(buf___1));
#line 167
  tmp___0 = strlen((char const   *)(buf___1));
#line 167
  snprintf((char * __restrict  )(buf___1 + tmp___0), (size_t )win_size - tmp, (char const   * __restrict  )" %3d%% ",
           percent);
#line 171
  tmp___1 = strlen((char const   *)(buf___1));
#line 171
  tmp___2 = strlen((char const   *)(buf___1));
#line 171
  format_size(buf___1 + tmp___2, (int )((size_t )win_size - tmp___1), cur_pos);
#line 173
  strlcat(buf___1, " ", (unsigned int )win_size);
#line 176
  tmp___3 = strlen((char const   *)(buf___1));
#line 176
  tmp___4 = strlen((char const   *)(buf___1));
#line 176
  format_rate(buf___1 + tmp___4, (int )((size_t )win_size - tmp___3), (long long )bytes_per_second);
#line 178
  strlcat(buf___1, "/s ", (unsigned int )win_size);
#line 181
  if (! transferred) {
#line 182
    stalled = (long )((double )stalled + elapsed);
  } else {
#line 184
    stalled = 0L;
  }
#line 186
  if (stalled >= 5L) {
#line 187
    strlcat(buf___1, "- stalled -", (unsigned int )win_size);
  } else {
#line 188
    if (bytes_per_second == 0) {
#line 188
      if (bytes_left) {
#line 189
        strlcat(buf___1, "  --:-- ETA", (unsigned int )win_size);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 191
      if (bytes_left > 0LL) {
#line 192
        seconds = (int )(bytes_left / (off_t )bytes_per_second);
      } else {
#line 194
        seconds = (int )elapsed;
      }
#line 196
      hours = seconds / 3600;
#line 197
      seconds -= hours * 3600;
#line 198
      minutes = seconds / 60;
#line 199
      seconds -= minutes * 60;
#line 201
      if (hours != 0) {
#line 202
        tmp___5 = strlen((char const   *)(buf___1));
#line 202
        tmp___6 = strlen((char const   *)(buf___1));
#line 202
        snprintf((char * __restrict  )(buf___1 + tmp___6), (size_t )win_size - tmp___5,
                 (char const   * __restrict  )"%d:%02d:%02d", hours, minutes, seconds);
      } else {
#line 205
        tmp___7 = strlen((char const   *)(buf___1));
#line 205
        tmp___8 = strlen((char const   *)(buf___1));
#line 205
        snprintf((char * __restrict  )(buf___1 + tmp___8), (size_t )win_size - tmp___7,
                 (char const   * __restrict  )"  %02d:%02d", minutes, seconds);
      }
#line 208
      if (bytes_left > 0LL) {
#line 209
        strlcat(buf___1, " ETA", (unsigned int )win_size);
      } else {
#line 211
        strlcat(buf___1, "    ", (unsigned int )win_size);
      }
    }
  }
#line 214
  atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), 1, (void *)(buf___1),
           (unsigned int )(win_size - 1));
#line 215
  last_update = now;
#line 216
  return;
}
}
#line 218 "progressmeter.c"
static void update_progress_meter(int ignore ) 
{ int save_errno ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
#line 223
  tmp = __errno_location();
#line 223
  save_errno = *tmp;
#line 225
  if (win_resized) {
#line 226
    setscreensize();
#line 227
    win_resized = (int volatile   )0;
  }
#line 229
  tmp___0 = can_output();
#line 229
  if (tmp___0) {
#line 230
    refresh_progress_meter();
  }
#line 232
  mysignal(14, & update_progress_meter);
#line 233
  alarm(1U);
#line 234
  tmp___1 = __errno_location();
#line 234
  *tmp___1 = save_errno;
#line 235
  return;
}
}
#line 237 "progressmeter.c"
void start_progress_meter(char *f , off_t filesize , off_t *ctr ) 
{ int tmp ;

  {
#line 240
  last_update = time((time_t *)((void *)0));
#line 240
  start = last_update;
#line 241
  file = f;
#line 242
  end_pos = filesize;
#line 243
  cur_pos = 0LL;
#line 244
  counter = (off_t volatile   *)ctr;
#line 245
  stalled = 0L;
#line 246
  bytes_per_second = 0;
#line 248
  setscreensize();
#line 249
  tmp = can_output();
#line 249
  if (tmp) {
#line 250
    refresh_progress_meter();
  }
#line 252
  mysignal(14, & update_progress_meter);
#line 253
  mysignal(28, & sig_winch);
#line 254
  alarm(1U);
#line 255
  return;
}
}
#line 257 "progressmeter.c"
void stop_progress_meter(void) 
{ int tmp ;

  {
#line 260
  alarm(0U);
#line 262
  tmp = can_output();
#line 262
  if (! tmp) {
#line 263
    return;
  }
#line 266
  if (cur_pos != end_pos) {
#line 267
    refresh_progress_meter();
  }
#line 269
  atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), 1, (void *)"\n", 1U);
#line 270
  return;
}
}
#line 272 "progressmeter.c"
static void sig_winch(int sig ) 
{ 

  {
#line 275
  win_resized = (int volatile   )1;
#line 276
  return;
}
}
#line 278 "progressmeter.c"
static void setscreensize(void) 
{ struct winsize winsize ;
  int tmp ;

  {
#line 283
  tmp = ioctl(1, 21523UL, & winsize);
#line 283
  if (tmp != -1) {
#line 283
    if ((int )winsize.ws_col != 0) {
#line 285
      if ((int )winsize.ws_col > 512) {
#line 286
        win_size = 512;
      } else {
#line 288
        win_size = (int )winsize.ws_col;
      }
    } else {
#line 290
      win_size = 80;
    }
  } else {
#line 290
    win_size = 80;
  }
#line 291
  win_size ++;
#line 292
  return;
}
}
#line 1 "dns.o"
#line 51 "dns.h"
int verify_host_key_dns(char const   *hostname , struct sockaddr *address , Key const   *hostkey ,
                        int *flags ) ;
#line 52
int export_dns_rr(char const   *hostname , Key const   *key , FILE *f , int generic ) ;
#line 38 "dns.c"
static char const   *errset_text[6]  = {      "success",      "out of memory",      "general failure",      "invalid parameter", 
        "name does not exist",      "data does not exist"};
#line 47 "dns.c"
static char const   *dns_result_totext(unsigned int res ) 
{ 

  {
#line 50
  switch ((int )res) {
  case 0: 
#line 52
  return (errset_text[0]);
  case 1: 
#line 54
  return (errset_text[1]);
  case 2: 
#line 56
  return (errset_text[2]);
  case 3: 
#line 58
  return (errset_text[3]);
  case 4: 
#line 60
  return (errset_text[4]);
  case 5: 
#line 62
  return (errset_text[5]);
  default: ;
#line 64
  return ("unknown error");
  }
}
}
#line 71 "dns.c"
static int dns_read_key(u_int8_t *algorithm , u_int8_t *digest_type , u_char **digest___1 ,
                        u_int *digest_len , Key const   *key ) 
{ int success ;

  {
#line 75
  success = 0;
#line 77
  switch ((int )key->type) {
  case 1: 
#line 79
  *algorithm = (unsigned char)1;
#line 80
  break;
  case 2: 
#line 82
  *algorithm = (unsigned char)2;
#line 83
  break;
  default: 
#line 85
  *algorithm = (unsigned char)0;
  }
#line 88
  if (*algorithm) {
#line 89
    *digest_type = (unsigned char)1;
#line 90
    *digest___1 = key_fingerprint_raw(key, 0, digest_len);
#line 91
    if ((unsigned int )*digest___1 == (unsigned int )((void *)0)) {
#line 92
      fatal("dns_read_key: null from key_fingerprint_raw()");
    }
#line 93
    success = 1;
  } else {
#line 95
    *digest_type = (unsigned char)0;
#line 96
    *digest___1 = (u_char *)((void *)0);
#line 97
    *digest_len = 0U;
#line 98
    success = 0;
  }
#line 101
  return (success);
}
}
#line 107 "dns.c"
static int dns_read_rdata(u_int8_t *algorithm , u_int8_t *digest_type , u_char **digest___1 ,
                          u_int *digest_len , u_char *rdata , int rdata_len ) 
{ int success ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 111
  success = 0;
#line 113
  *algorithm = (unsigned char)0;
#line 114
  *digest_type = (unsigned char)0;
#line 116
  if (rdata_len >= 2) {
#line 117
    *algorithm = *(rdata + 0);
#line 118
    *digest_type = *(rdata + 1);
#line 119
    *digest_len = (unsigned int )(rdata_len - 2);
#line 121
    if (*digest_len > 0U) {
#line 122
      tmp = xmalloc(*digest_len);
#line 122
      *digest___1 = (u_char *)tmp;
#line 123
      memcpy((void * __restrict  )*digest___1, (void const   * __restrict  )(rdata + 2),
             *digest_len);
    } else {
#line 125
      tmp___0 = xstrdup("");
#line 125
      *digest___1 = (u_char *)tmp___0;
    }
#line 128
    success = 1;
  }
#line 131
  return (success);
}
}
#line 138 "dns.c"
static int is_numeric_hostname(char const   *hostname ) 
{ struct addrinfo hints ;
  struct addrinfo *ai ;
  int tmp ;

  {
#line 143
  memset((void *)(& hints), 0, sizeof(hints));
#line 144
  hints.ai_socktype = 2;
#line 145
  hints.ai_flags = 4;
#line 147
  tmp = getaddrinfo((char const   * __restrict  )hostname, (char const   * __restrict  )"0",
                    (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& ai));
#line 147
  if (tmp == 0) {
#line 148
    freeaddrinfo(ai);
#line 149
    return (-1);
  }
#line 152
  return (0);
}
}
#line 159 "dns.c"
int verify_host_key_dns(char const   *hostname , struct sockaddr *address , Key const   *hostkey ,
                        int *flags ) 
{ u_int counter___0 ;
  int result ;
  struct rrsetinfo *fingerprints ;
  u_int8_t hostkey_algorithm ;
  u_int8_t hostkey_digest_type ;
  u_char *hostkey_digest ;
  u_int hostkey_digest_len ;
  u_int8_t dnskey_algorithm ;
  u_int8_t dnskey_digest_type ;
  u_char *dnskey_digest ;
  u_int dnskey_digest_len ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 165
  fingerprints = (struct rrsetinfo *)((void *)0);
#line 177
  *flags = 0;
#line 179
  debug3("verify_host_key_dns");
#line 180
  if ((unsigned int )hostkey == (unsigned int )((void *)0)) {
#line 181
    fatal("No key to look up!");
  }
#line 183
  tmp = is_numeric_hostname(hostname);
#line 183
  if (tmp) {
#line 184
    debug("skipped DNS lookup for numerical hostname");
#line 185
    return (-1);
  }
#line 188
  result = getrrsetbyname(hostname, 1U, 44U, 0U, & fingerprints);
#line 190
  if (result) {
#line 191
    tmp___0 = dns_result_totext((unsigned int )result);
#line 191
    verbose("DNS lookup error: %s", tmp___0);
#line 192
    return (-1);
  }
#line 195
  if (fingerprints->rri_flags & 1U) {
#line 196
    *flags |= 4;
#line 197
    debug("found %d secure fingerprints in DNS", fingerprints->rri_nrdatas);
  } else {
#line 200
    debug("found %d insecure fingerprints in DNS", fingerprints->rri_nrdatas);
  }
#line 205
  tmp___1 = dns_read_key(& hostkey_algorithm, & hostkey_digest_type, & hostkey_digest,
                         & hostkey_digest_len, hostkey);
#line 205
  if (! tmp___1) {
#line 207
    error("Error calculating host key fingerprint.");
#line 208
    freerrset(fingerprints);
#line 209
    return (-1);
  }
#line 212
  if (fingerprints->rri_nrdatas) {
#line 213
    *flags |= 1;
  }
#line 215
  counter___0 = 0U;
#line 215
  while (counter___0 < fingerprints->rri_nrdatas) {
#line 220
    tmp___2 = dns_read_rdata(& dnskey_algorithm, & dnskey_digest_type, & dnskey_digest,
                             & dnskey_digest_len, (fingerprints->rri_rdatas + counter___0)->rdi_data,
                             (int )(fingerprints->rri_rdatas + counter___0)->rdi_length);
#line 220
    if (! tmp___2) {
#line 224
      verbose("Error parsing fingerprint from DNS.");
      goto __Cont;
    }
#line 229
    if ((int )hostkey_algorithm == (int )dnskey_algorithm) {
#line 229
      if ((int )hostkey_digest_type == (int )dnskey_digest_type) {
#line 232
        if (hostkey_digest_len == dnskey_digest_len) {
#line 232
          tmp___3 = memcmp((void const   *)hostkey_digest, (void const   *)dnskey_digest,
                           hostkey_digest_len);
#line 232
          if (tmp___3 == 0) {
#line 236
            *flags |= 2;
          }
        }
      }
    }
#line 239
    xfree((void *)dnskey_digest);
    __Cont: /* CIL Label */ 
#line 215
    counter___0 ++;
  }
#line 242
  xfree((void *)hostkey_digest);
#line 243
  freerrset(fingerprints);
#line 245
  if (*flags & 1) {
#line 246
    if (*flags & 2) {
#line 247
      debug("matching host key fingerprint found in DNS");
    } else {
#line 249
      debug("mismatching host key fingerprint found in DNS");
    }
  } else {
#line 251
    debug("no host key fingerprint found in DNS");
  }
#line 253
  return (0);
}
}
#line 259 "dns.c"
int export_dns_rr(char const   *hostname , Key const   *key , FILE *f , int generic ) 
{ u_int8_t rdata_pubkey_algorithm ;
  u_int8_t rdata_digest_type ;
  u_char *rdata_digest ;
  u_int rdata_digest_len ;
  u_int i ;
  int success ;
  int tmp ;

  {
#line 262
  rdata_pubkey_algorithm = (u_int8_t )0;
#line 263
  rdata_digest_type = (u_int8_t )1;
#line 268
  success = 0;
#line 270
  tmp = dns_read_key(& rdata_pubkey_algorithm, & rdata_digest_type, & rdata_digest,
                     & rdata_digest_len, key);
#line 270
  if (tmp) {
#line 273
    if (generic) {
#line 274
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s IN TYPE%d \\# %d %02x %02x ",
              hostname, 44, 2U + rdata_digest_len, rdata_pubkey_algorithm, rdata_digest_type);
    } else {
#line 278
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s IN SSHFP %d %d ",
              hostname, rdata_pubkey_algorithm, rdata_digest_type);
    }
#line 281
    i = 0U;
#line 281
    while (i < rdata_digest_len) {
#line 282
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%02x", *(rdata_digest + i));
#line 281
      i ++;
    }
#line 283
    fprintf((FILE * __restrict  )f, (char const   * __restrict  )"\n");
#line 284
    xfree((void *)rdata_digest);
#line 285
    success = 1;
  } else {
#line 287
    error("export_dns_rr: unsupported algorithm");
  }
#line 290
  return (success);
}
}
#line 1 "entropy.o"
#line 33 "entropy.h"
void init_rng(void) ;
#line 109 "/usr/include/openssl/rand.h"
extern int RAND_status(void) ;
#line 381 "/usr/include/openssl/crypto.h"
extern unsigned long SSLeay(void) ;
#line 58 "entropy.c"
void seed_rng(void) 
{ int tmp ;

  {
#line 135
  tmp = RAND_status();
#line 135
  if (tmp != 1) {
#line 136
    fatal("PRNG is not seeded");
  }
#line 137
  return;
}
}
#line 139 "entropy.c"
void init_rng(void) 
{ unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 146
  tmp___0 = SSLeay();
#line 146
  if ((tmp___0 ^ 9469999UL) & 4294963215UL) {
#line 147
    tmp = SSLeay();
#line 147
    fatal("OpenSSL version mismatch. Built against %lx, you have %lx", 9469999L, tmp);
  }
#line 154
  return;
}
}
#line 1 "scard-opensc.o"
#line 1 "gss-genr.o"
#line 1 "sshd.o"
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 682
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 79 "/usr/include/pwd.h"
extern void endpwent(void) ;
#line 457 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int chdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 490
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 516
extern  __attribute__((__nothrow__)) int execv(char const   *__path , char * const  *__argv )  __attribute__((__nonnull__(1))) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 903
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
#line 910
extern  __attribute__((__nothrow__)) int chroot(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 106 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socketpair(int __domain , int __type , int __protocol ,
                                                    int *__fds ) ;
#line 380 "/usr/include/openssl/crypto.h"
extern char const   *SSLeay_version(int type ) ;
#line 478 "/usr/include/openssl/bn.h"
extern int BN_mask_bits(BIGNUM *a , int n ) ;
#line 104 "/usr/include/openssl/rand.h"
extern void RAND_seed(void const   *buf , int num ) ;
#line 142 "servconf.h"
void initialize_server_options(ServerOptions *options___0 ) ;
#line 143
void fill_default_server_options(ServerOptions *options___0 ) ;
#line 144
int process_server_config_line(ServerOptions *options___0 , char *line , char const   *filename ,
                               int linenum ) ;
#line 145
void load_server_config(char const   *filename , Buffer *conf ) ;
#line 146
void parse_server_config(ServerOptions *options___0 , char const   *filename , Buffer *conf ) ;
#line 711 "/usr/include/openssl/evp.h"
extern void OPENSSL_add_all_algorithms_noconf(void) ;
#line 136 "kex.h"
void kexdh_server(Kex *kex ) ;
#line 138
void kexgex_server(Kex *kex ) ;
#line 43 "myproposal.h"
static char *myproposal[10]  = 
#line 43 "myproposal.h"
  {      (char *)"diffie-hellman-group-exchange-sha1,diffie-hellman-group14-sha1,diffie-hellman-group1-sha1",      (char *)"ssh-rsa,ssh-dss",      (char *)"aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,arcfour128,arcfour256,arcfour,aes192-cbc,aes256-cbc,rijndael-cbc@lysator.liu.se,aes128-ctr,aes192-ctr,aes256-ctr",      (char *)"aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,arcfour128,arcfour256,arcfour,aes192-cbc,aes256-cbc,rijndael-cbc@lysator.liu.se,aes128-ctr,aes192-ctr,aes256-ctr", 
        (char *)"hmac-md5,hmac-sha1,hmac-ripemd160,hmac-ripemd160@openssh.com,hmac-sha1-96,hmac-md5-96",      (char *)"hmac-md5,hmac-sha1,hmac-ripemd160,hmac-ripemd160@openssh.com,hmac-sha1-96,hmac-md5-96",      (char *)"none,zlib@openssh.com,zlib",      (char *)"none,zlib@openssh.com,zlib", 
        (char *)"",      (char *)""};
#line 140 "auth.h"
void do_authentication(Authctxt *authctxt___0 ) ;
#line 141
void do_authentication2(Authctxt *authctxt___0 ) ;
#line 150
void privsep_challenge_enable(void) ;
#line 177
Key *get_hostkey_by_index(int ind ) ;
#line 178
Key *get_hostkey_by_type(int type ) ;
#line 179
int get_hostkey_index(Key *key ) ;
#line 180
int ssh1_session_key(BIGNUM *session_key_int ) ;
#line 61 "session.h"
void do_authenticated(Authctxt *authctxt___0 ) ;
#line 62
void do_cleanup(Authctxt *authctxt___0 ) ;
#line 74
void do_setusercontext(struct passwd *pw ) ;
#line 76 "monitor.h"
struct monitor *monitor_init(void) ;
#line 77
void monitor_reinit(struct monitor *mon ) ;
#line 78
void monitor_sync(struct monitor *pmonitor___0 ) ;
#line 81
void monitor_child_preauth(struct Authctxt *_authctxt , struct monitor *pmonitor___0 ) ;
#line 82
void monitor_child_postauth(struct monitor *pmonitor___0 ) ;
#line 33 "monitor_wrap.h"
int use_privsep  ;
#line 84
void mm_terminate(void) ;
#line 89
void mm_ssh1_session_id(u_char *session_id___0 ) ;
#line 90
int mm_ssh1_session_key(BIGNUM *num ) ;
#line 96
void monitor_apply_keystate(struct monitor *pmonitor___0 ) ;
#line 98
void mm_send_keystate(struct monitor *monitor ) ;
#line 109 "sshd.c"
ServerOptions options  ;
#line 112 "sshd.c"
char *config_file_name  =    (char *)"/usr/local/etc/sshd_config";
#line 120 "sshd.c"
int debug_flag  =    0;
#line 123 "sshd.c"
int test_flag  =    0;
#line 126 "sshd.c"
int inetd_flag  =    0;
#line 129 "sshd.c"
int no_daemon_flag  =    0;
#line 132 "sshd.c"
int log_stderr  =    0;
#line 135 "sshd.c"
char **saved_argv  ;
#line 136 "sshd.c"
int saved_argc  ;
#line 139 "sshd.c"
int rexeced_flag  =    0;
#line 140 "sshd.c"
int rexec_flag  =    1;
#line 141 "sshd.c"
int rexec_argc  =    0;
#line 142 "sshd.c"
char **rexec_argv  ;
#line 149 "sshd.c"
int listen_socks[16]  ;
#line 150 "sshd.c"
int num_listen_socks  =    0;
#line 156 "sshd.c"
char *client_version_string  =    (char *)((void *)0);
#line 157 "sshd.c"
char *server_version_string  =    (char *)((void *)0);
#line 160 "sshd.c"
Kex *xxx_kex  ;
#line 170 "sshd.c"
struct __anonstruct_sensitive_data_86 sensitive_data  ;
#line 183 "sshd.c"
static int volatile   key_do_regen  =    (sig_atomic_t volatile   )0;
#line 186 "sshd.c"
static int volatile   received_sighup  =    (sig_atomic_t volatile   )0;
#line 187 "sshd.c"
static int volatile   received_sigterm  =    (sig_atomic_t volatile   )0;
#line 190 "sshd.c"
u_char session_id[16]  ;
#line 193 "sshd.c"
u_char *session_id2  =    (u_char *)((void *)0);
#line 194 "sshd.c"
u_int session_id2_len  =    (u_int )0;
#line 197 "sshd.c"
u_int utmp_len  =    (u_int )64;
#line 200 "sshd.c"
int *startup_pipes  =    (int *)((void *)0);
#line 201 "sshd.c"
int startup_pipe  ;
#line 205 "sshd.c"
struct monitor *pmonitor  =    (struct monitor *)((void *)0);
#line 208 "sshd.c"
Authctxt *the_authctxt  =    (Authctxt *)((void *)0);
#line 211 "sshd.c"
Buffer loginmsg  ;
#line 214
void destroy_sensitive_data(void) ;
#line 215
void demote_sensitive_data(void) ;
#line 217
static void do_ssh1_kex(void) ;
#line 218
static void do_ssh2_kex(void) ;
#line 223 "sshd.c"
static void close_listen_socks(void) 
{ int i ;

  {
#line 228
  i = 0;
#line 228
  while (i < num_listen_socks) {
#line 229
    close(listen_socks[i]);
#line 228
    i ++;
  }
#line 230
  num_listen_socks = -1;
#line 231
  return;
}
}
#line 233 "sshd.c"
static void close_startup_pipes(void) 
{ int i ;

  {
#line 238
  if (startup_pipes) {
#line 239
    i = 0;
#line 239
    while (i < options.max_startups) {
#line 240
      if (*(startup_pipes + i) != -1) {
#line 241
        close(*(startup_pipes + i));
      }
#line 239
      i ++;
    }
  }
#line 242
  return;
}
}
#line 249 "sshd.c"
static void sighup_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 252
  tmp = __errno_location();
#line 252
  save_errno = *tmp;
#line 254
  received_sighup = (int volatile   )1;
#line 255
  mysignal(1, & sighup_handler);
#line 256
  tmp___0 = __errno_location();
#line 256
  *tmp___0 = save_errno;
#line 257
  return;
}
}
#line 263 "sshd.c"
static void sighup_restart(void) 
{ int *tmp ;
  char *tmp___0 ;

  {
#line 266
  logit("Received SIGHUP; restarting.");
#line 267
  close_listen_socks();
#line 268
  close_startup_pipes();
#line 269
  execv((char const   *)*(saved_argv + 0), (char * const  *)saved_argv);
#line 270
  tmp = __errno_location();
#line 270
  tmp___0 = strerror(*tmp);
#line 270
  logit("RESTART FAILED: av[0]=\'%.100s\', error: %.100s.", *(saved_argv + 0), tmp___0);
#line 272
  exit(1);
}
}
#line 278 "sshd.c"
static void sigterm_handler(int sig ) 
{ 

  {
#line 281
  received_sigterm = (int volatile   )sig;
#line 282
  return;
}
}
#line 288 "sshd.c"
static void main_sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  pid_t pid ;
  int status ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 291
  tmp = __errno_location();
#line 291
  save_errno = *tmp;
#line 295
  while (1) {
#line 295
    pid = waitpid(-1, & status, 1);
#line 295
    if (! (pid > 0)) {
#line 295
      if (pid < 0) {
#line 295
        tmp___0 = __errno_location();
#line 295
        if (! (*tmp___0 == 4)) {
#line 295
          break;
        }
      } else {
#line 295
        break;
      }
    }
  }
#line 299
  mysignal(17, & main_sigchld_handler);
#line 300
  tmp___1 = __errno_location();
#line 300
  *tmp___1 = save_errno;
#line 301
  return;
}
}
#line 306 "sshd.c"
static void grace_alarm_handler(int sig ) 
{ char const   *tmp ;

  {
#line 311
  if (use_privsep) {
#line 311
    if ((unsigned int )pmonitor != (unsigned int )((void *)0)) {
#line 311
      if (pmonitor->m_pid > 0) {
#line 312
        kill(pmonitor->m_pid, 14);
      }
    }
  }
#line 315
  tmp = get_remote_ipaddr();
#line 315
  fatal("Timeout before authentication for %s", tmp);
}
}
#line 325 "sshd.c"
static void generate_ephemeral_server_key(void) 
{ u_int32_t rnd ;
  int i ;
  char const   *tmp ;

  {
#line 328
  rnd = (u_int32_t )0;
#line 331
  if (sensitive_data.server_key) {
#line 331
    tmp = "new ";
  } else {
#line 331
    tmp = "";
  }
#line 331
  verbose("Generating %s%d bit RSA key.", tmp, options.server_key_bits);
#line 333
  if ((unsigned int )sensitive_data.server_key != (unsigned int )((void *)0)) {
#line 334
    key_free(sensitive_data.server_key);
  }
#line 335
  sensitive_data.server_key = key_generate(0, (unsigned int )options.server_key_bits);
#line 337
  verbose("RSA key generation complete.");
#line 339
  i = 0;
#line 339
  while (i < 32) {
#line 340
    if (i % 4 == 0) {
#line 341
      rnd = arc4random();
    }
#line 342
    sensitive_data.ssh1_cookie[i] = (unsigned char )(rnd & 255U);
#line 343
    rnd >>= 8;
#line 339
    i ++;
  }
#line 345
  arc4random_stir();
#line 346
  return;
}
}
#line 348 "sshd.c"
static void key_regeneration_alarm(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 351
  tmp = __errno_location();
#line 351
  save_errno = *tmp;
#line 353
  mysignal(14, (void (*)(int  ))0);
#line 354
  tmp___0 = __errno_location();
#line 354
  *tmp___0 = save_errno;
#line 355
  key_do_regen = (int volatile   )1;
#line 356
  return;
}
}
#line 358 "sshd.c"
static void sshd_exchange_identification(int sock_in , int sock_out ) 
{ u_int i ;
  int mismatch ;
  int remote_major ;
  int remote_minor ;
  int major ;
  int minor ;
  char *s ;
  char buf___1[256] ;
  char remote_version[256] ;
  char const   *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char const   *tmp___3 ;
  size_t tmp___4 ;
  int tmp___18 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t tmp___31 ;
  char const   *tmp___32 ;
  int tmp___33 ;
  char const   *tmp___34 ;
  char const   *tmp___35 ;
  size_t tmp___36 ;
  char const   *tmp___37 ;

  {
#line 369
  if (options.protocol & 1) {
#line 369
    if (options.protocol & 4) {
#line 371
      major = 1;
#line 372
      minor = 99;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 373
    if (options.protocol & 4) {
#line 374
      major = 2;
#line 375
      minor = 0;
    } else {
#line 377
      major = 1;
#line 378
      minor = 5;
    }
  }
#line 380
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"SSH-%d.%d-%.100s\n",
           major, minor, "OpenSSH_4.3");
#line 381
  server_version_string = xstrdup((char const   *)(buf___1));
#line 384
  tmp___0 = strlen((char const   *)server_version_string);
#line 384
  tmp___1 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), sock_out, (void *)server_version_string,
                     tmp___0);
#line 384
  tmp___2 = strlen((char const   *)server_version_string);
#line 384
  if (tmp___1 != tmp___2) {
#line 387
    tmp = get_remote_ipaddr();
#line 387
    logit("Could not write ident string to %s", tmp);
#line 388
    cleanup_exit(255);
  }
#line 392
  memset((void *)(buf___1), 0, sizeof(buf___1));
#line 393
  i = 0U;
#line 393
  while (i < sizeof(buf___1) - 1U) {
#line 394
    tmp___4 = atomicio(& read, sock_in, (void *)(& buf___1[i]), 1U);
#line 394
    if (tmp___4 != 1U) {
#line 395
      tmp___3 = get_remote_ipaddr();
#line 395
      logit("Did not receive identification string from %s", tmp___3);
#line 397
      cleanup_exit(255);
    }
#line 399
    if ((int )buf___1[i] == 13) {
#line 400
      buf___1[i] = (char)0;
#line 403
      if (i == 12U) {
#line 403
        if (0) {
#line 403
          if (0) {
#line 403
            __s1_len___0 = strlen((char const   *)(buf___1));
#line 403
            __s2_len___0 = strlen("SSH-1.5-W1.0");
#line 403
            if (! ((unsigned int )((void const   *)(buf___1 + 1)) - (unsigned int )((void const   *)(buf___1)) == 1U)) {
              goto _L___3;
            } else {
#line 403
              if (__s1_len___0 >= 4U) {
                _L___3: /* CIL Label */ 
#line 403
                if (! ((unsigned int )((void const   *)("SSH-1.5-W1.0" + 1)) - (unsigned int )((void const   *)"SSH-1.5-W1.0") == 1U)) {
#line 403
                  tmp___28 = 1;
                } else {
#line 403
                  if (__s2_len___0 >= 4U) {
#line 403
                    tmp___28 = 1;
                  } else {
#line 403
                    tmp___28 = 0;
                  }
                }
              } else {
#line 403
                tmp___28 = 0;
              }
            }
#line 403
            if (tmp___28) {
#line 403
              tmp___24 = __builtin_strcmp((char const   *)(buf___1), "SSH-1.5-W1.0");
            } else {
#line 403
              tmp___27 = __builtin_strcmp((char const   *)(buf___1), "SSH-1.5-W1.0");
#line 403
              tmp___24 = tmp___27;
            }
          } else {
#line 403
            tmp___27 = __builtin_strcmp((char const   *)(buf___1), "SSH-1.5-W1.0");
#line 403
            tmp___24 = tmp___27;
          }
#line 403
          tmp___18 = tmp___24;
        } else {
#line 403
          tmp___18 = strncmp((char const   *)(buf___1), "SSH-1.5-W1.0", 12U);
        }
#line 403
        if (tmp___18 == 0) {
#line 404
          break;
        }
      }
      goto __Cont;
    }
#line 407
    if ((int )buf___1[i] == 10) {
#line 408
      buf___1[i] = (char)0;
#line 409
      break;
    }
    __Cont: /* CIL Label */ 
#line 393
    i ++;
  }
#line 412
  buf___1[sizeof(buf___1) - 1U] = (char)0;
#line 413
  client_version_string = xstrdup((char const   *)(buf___1));
#line 419
  tmp___33 = sscanf((char const   * __restrict  )client_version_string, (char const   * __restrict  )"SSH-%d.%d-%[^\n]\n",
                    & remote_major, & remote_minor, remote_version);
#line 419
  if (tmp___33 != 3) {
#line 421
    s = (char *)"Protocol mismatch.\n";
#line 422
    tmp___31 = strlen((char const   *)s);
#line 422
    atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), sock_out, (void *)s,
             tmp___31);
#line 423
    close(sock_in);
#line 424
    close(sock_out);
#line 425
    tmp___32 = get_remote_ipaddr();
#line 425
    logit("Bad protocol version identification \'%.100s\' from %s", client_version_string,
          tmp___32);
#line 427
    cleanup_exit(255);
  }
#line 429
  debug("Client protocol version %d.%d; client software version %.100s", remote_major,
        remote_minor, remote_version);
#line 432
  compat_datafellows((char const   *)(remote_version));
#line 434
  if (datafellows & 4194304) {
#line 435
    tmp___34 = get_remote_ipaddr();
#line 435
    logit("probed from %s with %s.  Don\'t panic.", tmp___34, client_version_string);
#line 437
    cleanup_exit(255);
  }
#line 440
  if (datafellows & 2048) {
#line 441
    tmp___35 = get_remote_ipaddr();
#line 441
    logit("scanned from %s with %s.  Don\'t panic.", tmp___35, client_version_string);
#line 443
    cleanup_exit(255);
  }
#line 446
  mismatch = 0;
#line 447
  switch (remote_major) {
  case 1: 
#line 449
  if (remote_minor == 99) {
#line 450
    if (options.protocol & 4) {
#line 451
      enable_compat20();
    } else {
#line 453
      mismatch = 1;
    }
#line 454
    break;
  }
#line 456
  if (! (options.protocol & 1)) {
#line 457
    mismatch = 1;
#line 458
    break;
  }
#line 460
  if (remote_minor < 3) {
#line 461
    packet_disconnect("Your ssh version is too old and is no longer supported.  Please install a newer version.");
  } else {
#line 463
    if (remote_minor == 3) {
#line 465
      enable_compat13();
    }
  }
#line 467
  break;
  case 2: 
#line 469
  if (options.protocol & 4) {
#line 470
    enable_compat20();
#line 471
    break;
  }
  default: 
#line 475
  mismatch = 1;
#line 476
  break;
  }
#line 478
  chop(server_version_string);
#line 479
  debug("Local version string %.200s", server_version_string);
#line 481
  if (mismatch) {
#line 482
    s = (char *)"Protocol major versions differ.\n";
#line 483
    tmp___36 = strlen((char const   *)s);
#line 483
    atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), sock_out, (void *)s,
             tmp___36);
#line 484
    close(sock_in);
#line 485
    close(sock_out);
#line 486
    tmp___37 = get_remote_ipaddr();
#line 486
    logit("Protocol major versions differ for %s: %.200s vs. %.200s", tmp___37, server_version_string,
          client_version_string);
#line 489
    cleanup_exit(255);
  }
#line 491
  return;
}
}
#line 494 "sshd.c"
void destroy_sensitive_data(void) 
{ int i ;

  {
#line 499
  if (sensitive_data.server_key) {
#line 500
    key_free(sensitive_data.server_key);
#line 501
    sensitive_data.server_key = (Key *)((void *)0);
  }
#line 503
  i = 0;
#line 503
  while (i < options.num_host_key_files) {
#line 504
    if (*(sensitive_data.host_keys + i)) {
#line 505
      key_free(*(sensitive_data.host_keys + i));
#line 506
      *(sensitive_data.host_keys + i) = (Key *)((void *)0);
    }
#line 503
    i ++;
  }
#line 509
  sensitive_data.ssh1_host_key = (Key *)((void *)0);
#line 510
  memset((void *)(sensitive_data.ssh1_cookie), 0, 32U);
#line 511
  return;
}
}
#line 514 "sshd.c"
void demote_sensitive_data(void) 
{ Key *tmp ;
  int i ;

  {
#line 520
  if (sensitive_data.server_key) {
#line 521
    tmp = key_demote((Key const   *)sensitive_data.server_key);
#line 522
    key_free(sensitive_data.server_key);
#line 523
    sensitive_data.server_key = tmp;
  }
#line 526
  i = 0;
#line 526
  while (i < options.num_host_key_files) {
#line 527
    if (*(sensitive_data.host_keys + i)) {
#line 528
      tmp = key_demote((Key const   *)*(sensitive_data.host_keys + i));
#line 529
      key_free(*(sensitive_data.host_keys + i));
#line 530
      *(sensitive_data.host_keys + i) = tmp;
#line 531
      if (tmp->type == 0) {
#line 532
        sensitive_data.ssh1_host_key = tmp;
      }
    }
#line 526
    i ++;
  }
#line 537
  return;
}
}
#line 539 "sshd.c"
static void privsep_preauth_child(void) 
{ u_int32_t rnd[256] ;
  gid_t gidset[1] ;
  struct passwd *pw ;
  int i ;
  size_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
#line 548
  privsep_challenge_enable();
#line 550
  i = 0;
#line 550
  while (i < 256) {
#line 551
    rnd[i] = arc4random();
#line 550
    i ++;
  }
#line 552
  RAND_seed((void const   *)(rnd), (int )sizeof(rnd));
#line 555
  demote_sensitive_data();
#line 557
  pw = getpwnam("sshd");
#line 557
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 558
    fatal("Privilege separation user %s does not exist", "sshd");
  }
#line 560
  tmp = strlen((char const   *)pw->pw_passwd);
#line 560
  memset((void *)pw->pw_passwd, 0, tmp);
#line 561
  endpwent();
#line 564
  tmp___2 = chroot("/var/empty");
#line 564
  if (tmp___2 == -1) {
#line 565
    tmp___0 = __errno_location();
#line 565
    tmp___1 = strerror(*tmp___0);
#line 565
    fatal("chroot(\"%s\"): %s", "/var/empty", tmp___1);
  }
#line 567
  tmp___5 = chdir("/");
#line 567
  if (tmp___5 == -1) {
#line 568
    tmp___3 = __errno_location();
#line 568
    tmp___4 = strerror(*tmp___3);
#line 568
    fatal("chdir(\"/\"): %s", tmp___4);
  }
#line 571
  debug3("privsep user:group %u:%u", pw->pw_uid, pw->pw_gid);
#line 577
  gidset[0] = pw->pw_gid;
#line 578
  tmp___8 = setgroups(1U, (__gid_t const   *)(gidset));
#line 578
  if (tmp___8 < 0) {
#line 579
    tmp___6 = __errno_location();
#line 579
    tmp___7 = strerror(*tmp___6);
#line 579
    fatal("setgroups: %.100s", tmp___7);
  }
#line 580
  permanently_set_uid(pw);
#line 582
  return;
}
}
#line 584 "sshd.c"
static int privsep_preauth(Authctxt *authctxt___0 ) 
{ int status ;
  pid_t pid ;
  int *tmp ;
  __pid_t tmp___0 ;
  __uid_t tmp___1 ;
  __uid_t tmp___2 ;

  {
#line 591
  pmonitor = monitor_init();
#line 593
  pmonitor->m_pkex = & xxx_kex;
#line 595
  pid = fork();
#line 596
  if (pid == -1) {
#line 597
    fatal("fork of unprivileged child failed");
  } else {
#line 598
    if (pid != 0) {
#line 599
      debug2("Network child is on pid %ld", (long )pid);
#line 601
      close(pmonitor->m_recvfd);
#line 602
      pmonitor->m_pid = pid;
#line 603
      monitor_child_preauth(authctxt___0, pmonitor);
#line 604
      close(pmonitor->m_sendfd);
#line 607
      monitor_sync(pmonitor);
#line 610
      while (1) {
#line 610
        tmp___0 = waitpid(pid, & status, 0);
#line 610
        if (! (tmp___0 < 0)) {
#line 610
          break;
        }
#line 611
        tmp = __errno_location();
#line 611
        if (*tmp != 4) {
#line 612
          break;
        }
      }
#line 613
      return (1);
    } else {
#line 617
      close(pmonitor->m_sendfd);
#line 620
      tmp___1 = getuid();
#line 620
      if (tmp___1 == 0U) {
#line 621
        privsep_preauth_child();
      } else {
#line 620
        tmp___2 = geteuid();
#line 620
        if (tmp___2 == 0U) {
#line 621
          privsep_preauth_child();
        }
      }
#line 622
      setproctitle("%s", "[net]");
    }
  }
#line 624
  return (0);
}
}
#line 627 "sshd.c"
static void privsep_postauth(Authctxt *authctxt___0 ) 
{ 

  {
#line 633
  if ((authctxt___0->pw)->pw_uid == 0U) {
#line 636
    use_privsep = 0;
    goto skip;
  } else {
#line 633
    if (options.use_login) {
#line 636
      use_privsep = 0;
      goto skip;
    }
  }
#line 641
  monitor_reinit(pmonitor);
#line 643
  pmonitor->m_pid = fork();
#line 644
  if (pmonitor->m_pid == -1) {
#line 645
    fatal("fork of unprivileged child failed");
  } else {
#line 646
    if (pmonitor->m_pid != 0) {
#line 647
      debug2("User child is on pid %ld", (long )pmonitor->m_pid);
#line 648
      close(pmonitor->m_recvfd);
#line 649
      buffer_clear(& loginmsg);
#line 650
      monitor_child_postauth(pmonitor);
#line 653
      exit(0);
    }
  }
#line 656
  close(pmonitor->m_sendfd);
#line 659
  demote_sensitive_data();
#line 662
  do_setusercontext(authctxt___0->pw);
  skip: 
#line 666
  monitor_apply_keystate(pmonitor);
#line 672
  packet_set_authenticated();
#line 673
  return;
}
}
#line 675 "sshd.c"
static char *list_hostkey_types(void) 
{ Buffer b ;
  char const   *p ;
  char *ret ;
  int i ;
  Key *key ;
  u_int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 683
  buffer_init(& b);
#line 684
  i = 0;
#line 684
  while (i < options.num_host_key_files) {
#line 685
    key = *(sensitive_data.host_keys + i);
#line 686
    if ((unsigned int )key == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 688
    switch (key->type) {
    case 1: 
    case 2: 
#line 691
    tmp = buffer_len(& b);
#line 691
    if (tmp > 0U) {
#line 692
      buffer_append(& b, (void const   *)",", 1U);
    }
#line 693
    p = key_ssh_name((Key const   *)key);
#line 694
    tmp___0 = strlen(p);
#line 694
    buffer_append(& b, (void const   *)p, tmp___0);
#line 695
    break;
    }
    __Cont: /* CIL Label */ 
#line 684
    i ++;
  }
#line 698
  buffer_append(& b, (void const   *)"\000", 1U);
#line 699
  tmp___1 = buffer_ptr(& b);
#line 699
  ret = xstrdup((char const   *)tmp___1);
#line 700
  buffer_free(& b);
#line 701
  debug("list_hostkey_types: %s", ret);
#line 702
  return (ret);
}
}
#line 705 "sshd.c"
Key *get_hostkey_by_type(int type ) 
{ int i ;
  Key *key ;

  {
#line 710
  i = 0;
#line 710
  while (i < options.num_host_key_files) {
#line 711
    key = *(sensitive_data.host_keys + i);
#line 712
    if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 712
      if (key->type == type) {
#line 713
        return (key);
      }
    }
#line 710
    i ++;
  }
#line 715
  return ((Key *)((void *)0));
}
}
#line 718 "sshd.c"
Key *get_hostkey_by_index(int ind ) 
{ 

  {
#line 721
  if (ind < 0) {
#line 722
    return ((Key *)((void *)0));
  } else {
#line 721
    if (ind >= options.num_host_key_files) {
#line 722
      return ((Key *)((void *)0));
    }
  }
#line 723
  return (*(sensitive_data.host_keys + ind));
}
}
#line 726 "sshd.c"
int get_hostkey_index(Key *key ) 
{ int i ;

  {
#line 731
  i = 0;
#line 731
  while (i < options.num_host_key_files) {
#line 732
    if ((unsigned int )key == (unsigned int )*(sensitive_data.host_keys + i)) {
#line 733
      return (i);
    }
#line 731
    i ++;
  }
#line 735
  return (-1);
}
}
#line 744 "sshd.c"
static int drop_connection(int startups ) 
{ int p ;
  int r ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 749
  if (startups < options.max_startups_begin) {
#line 750
    return (0);
  }
#line 751
  if (startups >= options.max_startups) {
#line 752
    return (1);
  }
#line 753
  if (options.max_startups_rate == 100) {
#line 754
    return (1);
  }
#line 756
  p = 100 - options.max_startups_rate;
#line 757
  p *= startups - options.max_startups_begin;
#line 758
  p /= options.max_startups - options.max_startups_begin;
#line 759
  p += options.max_startups_rate;
#line 760
  tmp = arc4random();
#line 760
  r = (int )(tmp % 100U);
#line 762
  debug("drop_connection: p %d, r %d", p, r);
#line 763
  if (r < p) {
#line 763
    tmp___0 = 1;
  } else {
#line 763
    tmp___0 = 0;
  }
#line 763
  return (tmp___0);
}
}
#line 766 "sshd.c"
static void usage(void) 
{ char const   *tmp ;

  {
#line 769
  tmp = SSLeay_version(0);
#line 769
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s, %s\n", "OpenSSH_4.3p1",
          tmp);
#line 771
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"usage: sshd [-46Ddeiqt] [-b bits] [-f config_file] [-g login_grace_time]\n            [-h host_key_file] [-k key_gen_time] [-o option] [-p port] [-u len]\n");
#line 775
  exit(1);
}
}
#line 778 "sshd.c"
static void send_rexec_state(int fd , Buffer *conf ) 
{ Buffer m___0 ;
  u_int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 783
  tmp = buffer_len(conf);
#line 783
  debug3("%s: entering fd = %d config len %d", "send_rexec_state", fd, tmp);
#line 798
  buffer_init(& m___0);
#line 799
  tmp___0 = buffer_ptr(conf);
#line 799
  buffer_put_cstring(& m___0, (char const   *)tmp___0);
#line 801
  if ((unsigned int )sensitive_data.server_key != (unsigned int )((void *)0)) {
#line 801
    if ((sensitive_data.server_key)->type == 0) {
#line 803
      buffer_put_int(& m___0, 1U);
#line 804
      buffer_put_bignum(& m___0, (BIGNUM const   *)((sensitive_data.server_key)->rsa)->e);
#line 805
      buffer_put_bignum(& m___0, (BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 806
      buffer_put_bignum(& m___0, (BIGNUM const   *)((sensitive_data.server_key)->rsa)->d);
#line 807
      buffer_put_bignum(& m___0, (BIGNUM const   *)((sensitive_data.server_key)->rsa)->iqmp);
#line 808
      buffer_put_bignum(& m___0, (BIGNUM const   *)((sensitive_data.server_key)->rsa)->p);
#line 809
      buffer_put_bignum(& m___0, (BIGNUM const   *)((sensitive_data.server_key)->rsa)->q);
    } else {
#line 811
      buffer_put_int(& m___0, 0U);
    }
  } else {
#line 811
    buffer_put_int(& m___0, 0U);
  }
#line 817
  tmp___1 = ssh_msg_send(fd, (unsigned char)0, & m___0);
#line 817
  if (tmp___1 == -1) {
#line 818
    fatal("%s: ssh_msg_send failed", "send_rexec_state");
  }
#line 820
  buffer_free(& m___0);
#line 822
  debug3("%s: done", "send_rexec_state");
#line 823
  return;
}
}
#line 825 "sshd.c"
static void recv_rexec_state(int fd , Buffer *conf ) 
{ Buffer m___0 ;
  char *cp ;
  u_int len ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  u_int tmp___2 ;

  {
#line 832
  debug3("%s: entering fd = %d", "recv_rexec_state", fd);
#line 834
  buffer_init(& m___0);
#line 836
  tmp = ssh_msg_recv(fd, & m___0);
#line 836
  if (tmp == -1) {
#line 837
    fatal("%s: ssh_msg_recv failed", "recv_rexec_state");
  }
#line 838
  tmp___0 = buffer_get_char(& m___0);
#line 838
  if (tmp___0 != 0) {
#line 839
    fatal("%s: rexec version mismatch", "recv_rexec_state");
  }
#line 841
  tmp___1 = buffer_get_string(& m___0, & len);
#line 841
  cp = (char *)tmp___1;
#line 842
  if ((unsigned int )conf != (unsigned int )((void *)0)) {
#line 843
    buffer_append(conf, (void const   *)cp, len + 1U);
  }
#line 844
  xfree((void *)cp);
#line 846
  tmp___2 = buffer_get_int(& m___0);
#line 846
  if (tmp___2) {
#line 847
    if ((unsigned int )sensitive_data.server_key != (unsigned int )((void *)0)) {
#line 848
      key_free(sensitive_data.server_key);
    }
#line 849
    sensitive_data.server_key = key_new_private(0);
#line 850
    buffer_get_bignum(& m___0, ((sensitive_data.server_key)->rsa)->e);
#line 851
    buffer_get_bignum(& m___0, ((sensitive_data.server_key)->rsa)->n);
#line 852
    buffer_get_bignum(& m___0, ((sensitive_data.server_key)->rsa)->d);
#line 853
    buffer_get_bignum(& m___0, ((sensitive_data.server_key)->rsa)->iqmp);
#line 854
    buffer_get_bignum(& m___0, ((sensitive_data.server_key)->rsa)->p);
#line 855
    buffer_get_bignum(& m___0, ((sensitive_data.server_key)->rsa)->q);
#line 856
    rsa_generate_additional_parameters((sensitive_data.server_key)->rsa);
  }
#line 864
  buffer_free(& m___0);
#line 866
  debug3("%s: done", "recv_rexec_state");
#line 867
  return;
}
}
#line 872 "sshd.c"
int main(int ac , char **av ) 
{ int opt ;
  int j ;
  int i ;
  int fdsetsz ;
  int on ;
  int sock_in ;
  int sock_out ;
  int newsock ;
  pid_t pid ;
  socklen_t fromlen ;
  fd_set *fdset ;
  struct sockaddr_storage from ;
  char const   *remote_ip___0 ;
  int remote_port ;
  FILE *f ;
  struct addrinfo *ai ;
  char ntop[1025] ;
  char strport[32] ;
  char *line ;
  int listen_sock ;
  int maxfd ;
  int startup_p[2] ;
  int config_s[2] ;
  int startups ;
  Key *key ;
  Authctxt *authctxt___0 ;
  int ret ;
  int key_used ;
  Buffer cfg ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  __uid_t tmp___2 ;
  int tmp___3 ;
  u_int tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  char const   *tmp___15 ;
  void *tmp___16 ;
  char const   *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  struct passwd *pw ;
  struct stat st ;
  int tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  void *tmp___25 ;
  int fd ;
  int *tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  int fd___0 ;
  char const   *tmp___32 ;
  int *tmp___33 ;
  char *tmp___34 ;
  int *tmp___35 ;
  char *tmp___36 ;
  int tmp___37 ;
  int *tmp___38 ;
  char *tmp___39 ;
  int tmp___40 ;
  int *tmp___41 ;
  char *tmp___42 ;
  int tmp___43 ;
  int *tmp___44 ;
  char *tmp___45 ;
  int tmp___46 ;
  int *tmp___47 ;
  char *tmp___48 ;
  __pid_t tmp___49 ;
  void *tmp___50 ;
  void *tmp___51 ;
  int *tmp___52 ;
  char *tmp___53 ;
  int *tmp___54 ;
  register char __result ;
  register char __result___0 ;
  int *tmp___55 ;
  char *tmp___56 ;
  int *tmp___57 ;
  int *tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int *tmp___62 ;
  char *tmp___63 ;
  int tmp___64 ;
  int *tmp___65 ;
  char *tmp___66 ;
  int *tmp___67 ;
  char *tmp___68 ;
  __pid_t tmp___69 ;
  int fd___1 ;
  int *tmp___70 ;
  char *tmp___71 ;
  int *tmp___72 ;
  char *tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  void *tmp___76 ;
  int tmp___77 ;

  {
#line 877
  on = 1;
#line 878
  sock_in = -1;
#line 878
  sock_out = -1;
#line 878
  newsock = -1;
#line 890
  startup_p[0] = -1;
#line 890
  startup_p[1] = -1;
#line 890
  config_s[0] = -1;
#line 890
  config_s[1] = -1;
#line 891
  startups = 0;
#line 894
  key_used = 0;
#line 900
  __progname = ssh_get_progname(*(av + 0));
#line 901
  init_rng();
#line 904
  saved_argc = ac;
#line 905
  rexec_argc = ac;
#line 906
  tmp = xmalloc(sizeof(*saved_argv) * (unsigned int )(ac + 1));
#line 906
  saved_argv = (char **)tmp;
#line 907
  i = 0;
#line 907
  while (i < ac) {
#line 908
    *(saved_argv + i) = xstrdup((char const   *)*(av + i));
#line 907
    i ++;
  }
#line 909
  *(saved_argv + i) = (char *)((void *)0);
#line 913
  compat_init_setproctitle(ac, av);
#line 914
  av = saved_argv;
#line 917
  tmp___2 = geteuid();
#line 917
  if (tmp___2 == 0U) {
#line 917
    tmp___3 = setgroups(0U, (__gid_t const   *)((void *)0));
#line 917
    if (tmp___3 == -1) {
#line 918
      tmp___0 = __errno_location();
#line 918
      tmp___1 = strerror(*tmp___0);
#line 918
      debug("setgroups(): %.200s", tmp___1);
    }
  }
#line 921
  sanitise_stdfd();
#line 924
  initialize_server_options(& options);
#line 927
  while (1) {
#line 927
    opt = BSDgetopt(ac, (char * const  *)av, "f:p:b:k:h:g:u:o:dDeiqrtQR46");
#line 927
    if (! (opt != -1)) {
#line 927
      break;
    }
#line 928
    switch (opt) {
    case 52: 
#line 930
    options.address_family = 2;
#line 931
    break;
    case 54: 
#line 933
    options.address_family = 10;
#line 934
    break;
    case 102: 
#line 936
    config_file_name = BSDoptarg;
#line 937
    break;
    case 100: 
#line 939
    if (debug_flag == 0) {
#line 940
      debug_flag = 1;
#line 941
      options.log_level = 5;
    } else {
#line 942
      if ((int )options.log_level < 7) {
#line 943
        options.log_level = (LogLevel )((int )options.log_level + 1);
      }
    }
#line 944
    break;
    case 68: 
#line 946
    no_daemon_flag = 1;
#line 947
    break;
    case 101: 
#line 949
    log_stderr = 1;
#line 950
    break;
    case 105: 
#line 952
    inetd_flag = 1;
#line 953
    break;
    case 114: 
#line 955
    rexec_flag = 0;
#line 956
    break;
    case 82: 
#line 958
    rexeced_flag = 1;
#line 959
    inetd_flag = 1;
#line 960
    break;
    case 81: 
#line 963
    break;
    case 113: 
#line 965
    options.log_level = 0;
#line 966
    break;
    case 98: 
#line 968
    options.server_key_bits = atoi((char const   *)BSDoptarg);
#line 969
    break;
    case 112: 
#line 971
    options.ports_from_cmdline = 1U;
#line 972
    if (options.num_ports >= 256U) {
#line 973
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"too many ports.\n");
#line 974
      exit(1);
    }
#line 976
    tmp___4 = options.num_ports;
#line 976
    (options.num_ports) ++;
#line 976
    tmp___5 = a2port((char const   *)BSDoptarg);
#line 976
    options.ports[tmp___4] = (unsigned short )tmp___5;
#line 977
    if ((int )options.ports[options.num_ports - 1U] == 0) {
#line 978
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad port number.\n");
#line 979
      exit(1);
    }
#line 981
    break;
    case 103: 
#line 983
    tmp___6 = convtime((char const   *)BSDoptarg);
#line 983
    options.login_grace_time = (int )tmp___6;
#line 983
    if (options.login_grace_time == -1) {
#line 984
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid login grace time.\n");
#line 985
      exit(1);
    }
#line 987
    break;
    case 107: 
#line 989
    tmp___7 = convtime((char const   *)BSDoptarg);
#line 989
    options.key_regeneration_time = (int )tmp___7;
#line 989
    if (options.key_regeneration_time == -1) {
#line 990
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid key regeneration interval.\n");
#line 991
      exit(1);
    }
#line 993
    break;
    case 104: 
#line 995
    if (options.num_host_key_files >= 256) {
#line 996
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"too many host keys.\n");
#line 997
      exit(1);
    }
#line 999
    tmp___8 = options.num_host_key_files;
#line 999
    (options.num_host_key_files) ++;
#line 999
    options.host_key_files[tmp___8] = BSDoptarg;
#line 1000
    break;
    case 116: 
#line 1002
    test_flag = 1;
#line 1003
    break;
    case 117: 
#line 1005
    tmp___9 = atoi((char const   *)BSDoptarg);
#line 1005
    utmp_len = (unsigned int )tmp___9;
#line 1006
    if (utmp_len > 64U) {
#line 1007
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid utmp length.\n");
#line 1008
      exit(1);
    }
#line 1010
    break;
    case 111: 
#line 1012
    line = xstrdup((char const   *)BSDoptarg);
#line 1013
    tmp___10 = process_server_config_line(& options, line, "command-line", 0);
#line 1013
    if (tmp___10 != 0) {
#line 1015
      exit(1);
    }
#line 1016
    xfree((void *)line);
#line 1017
    break;
    case 63: 
    default: 
#line 1020
    usage();
#line 1021
    break;
    }
  }
#line 1024
  if (rexeced_flag) {
#line 1025
    rexec_flag = 0;
  } else {
#line 1024
    if (inetd_flag) {
#line 1025
      rexec_flag = 0;
    }
  }
#line 1026
  if (rexec_flag) {
#line 1026
    if ((unsigned int )*(av + 0) == (unsigned int )((void *)0)) {
#line 1027
      fatal("sshd re-exec requires execution with an absolute path");
    } else {
#line 1026
      if ((int )*(*(av + 0)) != 47) {
#line 1027
        fatal("sshd re-exec requires execution with an absolute path");
      }
    }
  }
#line 1028
  if (rexeced_flag) {
#line 1029
    closefrom(6);
  } else {
#line 1031
    closefrom(3);
  }
#line 1033
  OPENSSL_add_all_algorithms_noconf();
#line 1039
  if (log_stderr) {
#line 1039
    tmp___11 = 1;
  } else {
#line 1039
    if (! inetd_flag) {
#line 1039
      tmp___11 = 1;
    } else {
#line 1039
      tmp___11 = 0;
    }
  }
#line 1039
  if ((int )options.log_facility == -1) {
#line 1039
    tmp___12 = 2;
  } else {
#line 1039
    tmp___12 = (int )options.log_facility;
  }
#line 1039
  if ((int )options.log_level == -1) {
#line 1039
    tmp___13 = 3;
  } else {
#line 1039
    tmp___13 = (int )options.log_level;
  }
#line 1039
  log_init(__progname, (enum __anonenum_LogLevel_76 )tmp___13, (enum __anonenum_SyslogFacility_75 )tmp___12,
           tmp___11);
#line 1050
  tmp___14 = getenv("KRB5CCNAME");
#line 1050
  if ((unsigned int )tmp___14 != (unsigned int )((void *)0)) {
#line 1051
    unsetenv("KRB5CCNAME");
  }
#line 1060
  sensitive_data.server_key = (Key *)((void *)0);
#line 1061
  sensitive_data.ssh1_host_key = (Key *)((void *)0);
#line 1062
  sensitive_data.have_ssh1_key = 0;
#line 1063
  sensitive_data.have_ssh2_key = 0;
#line 1066
  buffer_init(& cfg);
#line 1067
  if (rexeced_flag) {
#line 1068
    recv_rexec_state(5, & cfg);
  } else {
#line 1070
    load_server_config((char const   *)config_file_name, & cfg);
  }
#line 1072
  if (rexeced_flag) {
#line 1072
    tmp___15 = "rexec";
  } else {
#line 1072
    tmp___15 = (char const   *)config_file_name;
  }
#line 1072
  parse_server_config(& options, tmp___15, & cfg);
#line 1075
  if (! rexec_flag) {
#line 1076
    buffer_free(& cfg);
  }
#line 1078
  seed_rng();
#line 1081
  fill_default_server_options(& options);
#line 1084
  channel_set_af(options.address_family);
#line 1087
  if (BSDoptind < ac) {
#line 1088
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Extra argument %s.\n",
            *(av + BSDoptind));
#line 1089
    exit(1);
  }
#line 1092
  debug("sshd version %.100s", "OpenSSH_4.3p1");
#line 1095
  tmp___16 = xmalloc((unsigned int )options.num_host_key_files * sizeof(Key *));
#line 1095
  sensitive_data.host_keys = (Key **)tmp___16;
#line 1097
  i = 0;
#line 1097
  while (i < options.num_host_key_files) {
#line 1098
    *(sensitive_data.host_keys + i) = (Key *)((void *)0);
#line 1097
    i ++;
  }
#line 1100
  i = 0;
#line 1100
  while (i < options.num_host_key_files) {
#line 1101
    key = key_load_private((char const   *)options.host_key_files[i], "", (char **)((void *)0));
#line 1102
    *(sensitive_data.host_keys + i) = key;
#line 1103
    if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 1104
      error("Could not load host key: %s", options.host_key_files[i]);
#line 1106
      *(sensitive_data.host_keys + i) = (Key *)((void *)0);
      goto __Cont;
    }
#line 1109
    switch (key->type) {
    case 0: 
#line 1111
    sensitive_data.ssh1_host_key = key;
#line 1112
    sensitive_data.have_ssh1_key = 1;
#line 1113
    break;
    case 1: 
    case 2: 
#line 1116
    sensitive_data.have_ssh2_key = 1;
#line 1117
    break;
    }
#line 1119
    tmp___17 = key_type((Key const   *)key);
#line 1119
    debug("private host key: #%d type %d %s", i, key->type, tmp___17);
    __Cont: /* CIL Label */ 
#line 1100
    i ++;
  }
#line 1122
  if (options.protocol & 1) {
#line 1122
    if (! sensitive_data.have_ssh1_key) {
#line 1123
      logit("Disabling protocol version 1. Could not load host key");
#line 1124
      options.protocol &= -2;
    }
  }
#line 1126
  if (options.protocol & 4) {
#line 1126
    if (! sensitive_data.have_ssh2_key) {
#line 1127
      logit("Disabling protocol version 2. Could not load host key");
#line 1128
      options.protocol &= -5;
    }
  }
#line 1130
  if (! (options.protocol & 5)) {
#line 1131
    logit("sshd: no hostkeys available -- exiting.");
#line 1132
    exit(1);
  }
#line 1136
  if (options.protocol & 1) {
#line 1137
    if (options.server_key_bits < 512) {
#line 1139
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 1140
      exit(1);
    } else {
#line 1137
      if (options.server_key_bits > 32768) {
#line 1139
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 1140
        exit(1);
      }
    }
#line 1147
    tmp___19 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1147
    if (options.server_key_bits > tmp___19 - 128) {
#line 1147
      tmp___20 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1147
      if (options.server_key_bits < tmp___20 + 128) {
#line 1152
        tmp___18 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1152
        options.server_key_bits = tmp___18 + 128;
#line 1155
        debug("Forcing server key to %d bits to make it differ from host key.", options.server_key_bits);
      }
    }
  }
#line 1160
  if (use_privsep) {
#line 1164
    pw = getpwnam("sshd");
#line 1164
    if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 1165
      fatal("Privilege separation user %s does not exist", "sshd");
    }
#line 1167
    tmp___21 = stat((char const   * __restrict  )"/var/empty", (struct stat * __restrict  )(& st));
#line 1167
    if (tmp___21 == -1) {
#line 1169
      fatal("Missing privilege separation directory: %s", "/var/empty");
    } else {
#line 1167
      if (((st.st_mode & 61440U) == 16384U) == 0) {
#line 1169
        fatal("Missing privilege separation directory: %s", "/var/empty");
      }
    }
#line 1177
    if (st.st_uid != 0U) {
#line 1179
      fatal("%s must be owned by root and not group or world-writable.", "/var/empty");
    } else {
#line 1177
      if ((st.st_mode & (unsigned int )((128 >> 3) | ((128 >> 3) >> 3))) != 0U) {
#line 1179
        fatal("%s must be owned by root and not group or world-writable.", "/var/empty");
      }
    }
  }
#line 1184
  if (test_flag) {
#line 1185
    exit(0);
  }
#line 1194
  tmp___24 = setgroups(0U, (__gid_t const   *)((void *)0));
#line 1194
  if (tmp___24 < 0) {
#line 1195
    tmp___22 = __errno_location();
#line 1195
    tmp___23 = strerror(*tmp___22);
#line 1195
    debug("setgroups() failed: %.200s", tmp___23);
  }
#line 1197
  if (rexec_flag) {
#line 1198
    tmp___25 = xmalloc(sizeof(char *) * (unsigned int )(rexec_argc + 2));
#line 1198
    rexec_argv = (char **)tmp___25;
#line 1199
    i = 0;
#line 1199
    while (i < rexec_argc) {
#line 1200
      debug("rexec_argv[%d]=\'%s\'", i, *(saved_argv + i));
#line 1201
      *(rexec_argv + i) = *(saved_argv + i);
#line 1199
      i ++;
    }
#line 1203
    *(rexec_argv + rexec_argc) = (char *)"-R";
#line 1204
    *(rexec_argv + (rexec_argc + 1)) = (char *)((void *)0);
  }
#line 1208
  if (debug_flag) {
#line 1208
    if (! inetd_flag) {
#line 1209
      log_stderr = 1;
    } else {
#line 1208
      if (rexeced_flag) {
#line 1209
        log_stderr = 1;
      }
    }
  }
#line 1210
  log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 1217
  if (! debug_flag) {
#line 1217
    if (! inetd_flag) {
#line 1217
      if (! no_daemon_flag) {
#line 1221
        tmp___28 = daemon(0, 0);
#line 1221
        if (tmp___28 < 0) {
#line 1222
          tmp___26 = __errno_location();
#line 1222
          tmp___27 = strerror(*tmp___26);
#line 1222
          fatal("daemon() failed: %.200s", tmp___27);
        }
#line 1226
        fd = open("/dev/tty", 258);
#line 1227
        if (fd >= 0) {
#line 1228
          ioctl(fd, 21538UL, (void *)0);
#line 1229
          close(fd);
        }
      }
    }
  }
#line 1234
  log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 1237
  arc4random_stir();
#line 1241
  chdir("/");
#line 1244
  mysignal(13, (void (*)(int  ))1);
#line 1247
  if (inetd_flag) {
#line 1250
    startup_pipe = -1;
#line 1251
    if (rexeced_flag) {
#line 1252
      close(5);
#line 1253
      sock_out = dup(0);
#line 1253
      sock_in = sock_out;
#line 1254
      if (! debug_flag) {
#line 1255
        startup_pipe = dup(4);
#line 1256
        close(4);
      }
    } else {
#line 1259
      sock_in = dup(0);
#line 1260
      sock_out = dup(1);
    }
#line 1267
    fd___0 = open("/dev/null", 2, 0);
#line 1267
    if (fd___0 != -1) {
#line 1268
      dup2(fd___0, 0);
#line 1269
      dup2(fd___0, 1);
#line 1270
      if (fd___0 > 1) {
#line 1271
        close(fd___0);
      }
    }
#line 1273
    debug("inetd sockets after dupping: %d, %d", sock_in, sock_out);
#line 1274
    if (options.protocol & 1) {
#line 1274
      if ((unsigned int )sensitive_data.server_key == (unsigned int )((void *)0)) {
#line 1276
        generate_ephemeral_server_key();
      }
    }
  } else {
#line 1278
    ai = options.listen_addrs;
#line 1278
    while (ai) {
#line 1279
      if (ai->ai_family != 2) {
#line 1279
        if (ai->ai_family != 10) {
          goto __Cont___0;
        }
      }
#line 1281
      if (num_listen_socks >= 16) {
#line 1282
        fatal("Too many listen sockets. Enlarge MAX_LISTEN_SOCKS");
      }
#line 1284
      ret = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                        (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )(strport),
                        sizeof(strport), 3U);
#line 1284
      if (ret != 0) {
#line 1287
        if (ret != -11) {
#line 1287
          tmp___32 = gai_strerror(ret);
        } else {
#line 1287
          tmp___33 = __errno_location();
#line 1287
          tmp___34 = strerror(*tmp___33);
#line 1287
          tmp___32 = (char const   *)tmp___34;
        }
#line 1287
        error("getnameinfo failed: %.100s", tmp___32);
        goto __Cont___0;
      }
#line 1293
      listen_sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
#line 1295
      if (listen_sock < 0) {
#line 1297
        tmp___35 = __errno_location();
#line 1297
        tmp___36 = strerror(*tmp___35);
#line 1297
        verbose("socket: %.100s", tmp___36);
        goto __Cont___0;
      }
#line 1300
      tmp___37 = set_nonblock(listen_sock);
#line 1300
      if (tmp___37 == -1) {
#line 1301
        close(listen_sock);
        goto __Cont___0;
      }
#line 1308
      tmp___40 = setsockopt(listen_sock, 1, 2, (void const   *)(& on), sizeof(on));
#line 1308
      if (tmp___40 == -1) {
#line 1310
        tmp___38 = __errno_location();
#line 1310
        tmp___39 = strerror(*tmp___38);
#line 1310
        error("setsockopt SO_REUSEADDR: %s", tmp___39);
      }
#line 1312
      debug("Bind to port %s on %s.", strport, ntop);
#line 1315
      tmp___43 = bind(listen_sock, (struct sockaddr  const  * __restrict  )ai->ai_addr,
                      ai->ai_addrlen);
#line 1315
      if (tmp___43 < 0) {
#line 1316
        if (! ai->ai_next) {
#line 1317
          tmp___41 = __errno_location();
#line 1317
          tmp___42 = strerror(*tmp___41);
#line 1317
          error("Bind to port %s on %s failed: %.200s.", strport, ntop, tmp___42);
        }
#line 1319
        close(listen_sock);
        goto __Cont___0;
      }
#line 1322
      listen_socks[num_listen_socks] = listen_sock;
#line 1323
      num_listen_socks ++;
#line 1326
      logit("Server listening on %s port %s.", ntop, strport);
#line 1327
      tmp___46 = listen(listen_sock, 128);
#line 1327
      if (tmp___46 < 0) {
#line 1328
        tmp___44 = __errno_location();
#line 1328
        tmp___45 = strerror(*tmp___44);
#line 1328
        fatal("listen: %.100s", tmp___45);
      }
      __Cont___0: /* CIL Label */ 
#line 1278
      ai = ai->ai_next;
    }
#line 1331
    freeaddrinfo(options.listen_addrs);
#line 1333
    if (! num_listen_socks) {
#line 1334
      fatal("Cannot bind any address.");
    }
#line 1336
    if (options.protocol & 1) {
#line 1337
      generate_ephemeral_server_key();
    }
#line 1343
    mysignal(1, & sighup_handler);
#line 1345
    mysignal(15, & sigterm_handler);
#line 1346
    mysignal(3, & sigterm_handler);
#line 1349
    mysignal(17, & main_sigchld_handler);
#line 1352
    if (! debug_flag) {
#line 1360
      f = fopen((char const   * __restrict  )options.pid_file, (char const   * __restrict  )"wb");
#line 1361
      if ((unsigned int )f == (unsigned int )((void *)0)) {
#line 1362
        tmp___47 = __errno_location();
#line 1362
        tmp___48 = strerror(*tmp___47);
#line 1362
        error("Couldn\'t create pid file \"%s\": %s", options.pid_file, tmp___48);
      } else {
#line 1365
        tmp___49 = getpid();
#line 1365
        fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%ld\n", (long )tmp___49);
#line 1366
        fclose(f);
      }
    }
#line 1371
    fdset = (fd_set *)((void *)0);
#line 1372
    maxfd = 0;
#line 1373
    i = 0;
#line 1373
    while (i < num_listen_socks) {
#line 1374
      if (listen_socks[i] > maxfd) {
#line 1375
        maxfd = listen_socks[i];
      }
#line 1373
      i ++;
    }
#line 1377
    tmp___50 = xmalloc((unsigned int )options.max_startups * sizeof(int ));
#line 1377
    startup_pipes = (int *)tmp___50;
#line 1378
    i = 0;
#line 1378
    while (i < options.max_startups) {
#line 1379
      *(startup_pipes + i) = -1;
#line 1378
      i ++;
    }
#line 1385
    while (1) {
#line 1386
      if (received_sighup) {
#line 1387
        sighup_restart();
      }
#line 1388
      if ((unsigned int )fdset != (unsigned int )((void *)0)) {
#line 1389
        xfree((void *)fdset);
      }
#line 1390
      fdsetsz = (int )((((unsigned int )(maxfd + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 1391
      tmp___51 = xmalloc((unsigned int )fdsetsz);
#line 1391
      fdset = (fd_set *)tmp___51;
#line 1392
      memset((void *)fdset, 0, (unsigned int )fdsetsz);
#line 1394
      i = 0;
#line 1394
      while (i < num_listen_socks) {
#line 1395
        __asm__  volatile   ("btsl %1,%0": "=m" (fdset->fds_bits[(unsigned int )listen_socks[i] / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )listen_socks[i] % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
#line 1394
        i ++;
      }
#line 1396
      i = 0;
#line 1396
      while (i < options.max_startups) {
#line 1397
        if (*(startup_pipes + i) != -1) {
#line 1398
          __asm__  volatile   ("btsl %1,%0": "=m" (fdset->fds_bits[(unsigned int )*(startup_pipes + i) / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )*(startup_pipes + i) % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        }
#line 1396
        i ++;
      }
#line 1401
      ret = select(maxfd + 1, (fd_set * __restrict  )fdset, (fd_set * __restrict  )((void *)0),
                   (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 1402
      if (ret < 0) {
#line 1402
        tmp___54 = __errno_location();
#line 1402
        if (*tmp___54 != 4) {
#line 1403
          tmp___52 = __errno_location();
#line 1403
          tmp___53 = strerror(*tmp___52);
#line 1403
          error("select: %.100s", tmp___53);
        }
      }
#line 1404
      if (received_sigterm) {
#line 1405
        logit("Received signal %d; terminating.", (int )received_sigterm);
#line 1407
        close_listen_socks();
#line 1408
        unlink((char const   *)options.pid_file);
#line 1409
        exit(255);
      }
#line 1411
      if (key_used) {
#line 1411
        if (key_do_regen) {
#line 1412
          generate_ephemeral_server_key();
#line 1413
          key_used = 0;
#line 1414
          key_do_regen = (int volatile   )0;
        }
      }
#line 1416
      if (ret < 0) {
        goto __Cont___1;
      }
#line 1419
      i = 0;
#line 1419
      while (i < options.max_startups) {
#line 1421
        if (*(startup_pipes + i) != -1) {
#line 1421
          __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )*(startup_pipes + i) % (8U * sizeof(__fd_mask ))),
                               "m" (fdset->fds_bits[(unsigned int )*(startup_pipes + i) / (8U * sizeof(__fd_mask ))]): "cc");
#line 1421
          if (__result) {
#line 1428
            close(*(startup_pipes + i));
#line 1429
            *(startup_pipes + i) = -1;
#line 1430
            startups --;
          }
        }
#line 1419
        i ++;
      }
#line 1432
      i = 0;
#line 1432
      while (i < num_listen_socks) {
#line 1433
        __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )listen_socks[i] % (8U * sizeof(__fd_mask ))),
                             "m" (fdset->fds_bits[(unsigned int )listen_socks[i] / (8U * sizeof(__fd_mask ))]): "cc");
#line 1433
        if (! __result___0) {
          goto __Cont___2;
        }
#line 1435
        fromlen = sizeof(from);
#line 1436
        newsock = accept(listen_socks[i], (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                         (socklen_t * __restrict  )(& fromlen));
#line 1438
        if (newsock < 0) {
#line 1439
          tmp___57 = __errno_location();
#line 1439
          if (*tmp___57 != 4) {
#line 1439
            tmp___58 = __errno_location();
#line 1439
            if (*tmp___58 != 11) {
#line 1440
              tmp___55 = __errno_location();
#line 1440
              tmp___56 = strerror(*tmp___55);
#line 1440
              error("accept: %.100s", tmp___56);
            }
          }
          goto __Cont___2;
        }
#line 1443
        tmp___59 = unset_nonblock(newsock);
#line 1443
        if (tmp___59 == -1) {
#line 1444
          close(newsock);
          goto __Cont___2;
        }
#line 1447
        tmp___60 = drop_connection(startups);
#line 1447
        if (tmp___60 == 1) {
#line 1448
          debug("drop connection #%d", startups);
#line 1449
          close(newsock);
          goto __Cont___2;
        }
#line 1452
        tmp___61 = pipe((int *)(startup_p));
#line 1452
        if (tmp___61 == -1) {
#line 1453
          close(newsock);
          goto __Cont___2;
        }
#line 1457
        if (rexec_flag) {
#line 1457
          tmp___64 = socketpair(1, 1, 0, (int *)(config_s));
#line 1457
          if (tmp___64 == -1) {
#line 1459
            tmp___62 = __errno_location();
#line 1459
            tmp___63 = strerror(*tmp___62);
#line 1459
            error("reexec socketpair: %s", tmp___63);
#line 1461
            close(newsock);
#line 1462
            close(startup_p[0]);
#line 1463
            close(startup_p[1]);
            goto __Cont___2;
          }
        }
#line 1467
        j = 0;
#line 1467
        while (j < options.max_startups) {
#line 1468
          if (*(startup_pipes + j) == -1) {
#line 1469
            *(startup_pipes + j) = startup_p[0];
#line 1470
            if (maxfd < startup_p[0]) {
#line 1471
              maxfd = startup_p[0];
            }
#line 1472
            startups ++;
#line 1473
            break;
          }
#line 1467
          j ++;
        }
#line 1480
        if (debug_flag) {
#line 1486
          debug("Server will not fork when running in debugging mode.");
#line 1487
          close_listen_socks();
#line 1488
          sock_in = newsock;
#line 1489
          sock_out = newsock;
#line 1490
          close(startup_p[0]);
#line 1491
          close(startup_p[1]);
#line 1492
          startup_pipe = -1;
#line 1493
          pid = getpid();
#line 1494
          if (rexec_flag) {
#line 1495
            send_rexec_state(config_s[0], & cfg);
#line 1497
            close(config_s[0]);
          }
#line 1499
          break;
        } else {
#line 1506
          pid = fork();
#line 1506
          if (pid == 0) {
#line 1514
            startup_pipe = startup_p[1];
#line 1515
            close_startup_pipes();
#line 1516
            close_listen_socks();
#line 1517
            sock_in = newsock;
#line 1518
            sock_out = newsock;
#line 1519
            log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 1520
            if (rexec_flag) {
#line 1521
              close(config_s[0]);
            }
#line 1522
            break;
          }
        }
#line 1527
        if (pid < 0) {
#line 1528
          tmp___65 = __errno_location();
#line 1528
          tmp___66 = strerror(*tmp___65);
#line 1528
          error("fork: %.100s", tmp___66);
        } else {
#line 1530
          debug("Forked child %ld.", (long )pid);
        }
#line 1532
        close(startup_p[1]);
#line 1534
        if (rexec_flag) {
#line 1535
          send_rexec_state(config_s[0], & cfg);
#line 1536
          close(config_s[0]);
#line 1537
          close(config_s[1]);
        }
#line 1541
        if (options.protocol & 1) {
#line 1541
          if (key_used == 0) {
#line 1544
            mysignal(14, & key_regeneration_alarm);
#line 1545
            alarm((unsigned int )options.key_regeneration_time);
#line 1546
            key_used = 1;
          }
        }
#line 1549
        arc4random_stir();
#line 1552
        close(newsock);
        __Cont___2: /* CIL Label */ 
#line 1432
        i ++;
      }
#line 1555
      if (num_listen_socks < 0) {
#line 1556
        break;
      }
      __Cont___1: /* CIL Label */ ;
    }
  }
#line 1561
  setproctitle("%s", "[accepted]");
#line 1574
  if (! debug_flag) {
#line 1574
    if (! inetd_flag) {
#line 1574
      tmp___69 = setsid();
#line 1574
      if (tmp___69 < 0) {
#line 1575
        tmp___67 = __errno_location();
#line 1575
        tmp___68 = strerror(*tmp___67);
#line 1575
        error("setsid: %.100s", tmp___68);
      }
    }
  }
#line 1578
  if (rexec_flag) {
#line 1581
    debug("rexec start in %d out %d newsock %d pipe %d sock %d", sock_in, sock_out,
          newsock, startup_pipe, config_s[0]);
#line 1583
    dup2(newsock, 0);
#line 1584
    dup2(0, 1);
#line 1585
    if (startup_pipe == -1) {
#line 1586
      close(4);
    } else {
#line 1588
      dup2(startup_pipe, 4);
    }
#line 1590
    dup2(config_s[1], 5);
#line 1591
    close(config_s[1]);
#line 1592
    if (startup_pipe != -1) {
#line 1593
      close(startup_pipe);
    }
#line 1595
    execv((char const   *)*(rexec_argv + 0), (char * const  *)rexec_argv);
#line 1598
    tmp___70 = __errno_location();
#line 1598
    tmp___71 = strerror(*tmp___70);
#line 1598
    error("rexec of %s failed: %s", *(rexec_argv + 0), tmp___71);
#line 1599
    recv_rexec_state(5, (Buffer *)((void *)0));
#line 1600
    log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 1604
    startup_pipe = 4;
#line 1605
    close(config_s[1]);
#line 1606
    close(5);
#line 1607
    sock_in = dup(0);
#line 1607
    sock_out = sock_in;
#line 1607
    newsock = sock_out;
#line 1608
    fd___1 = open("/dev/null", 2, 0);
#line 1608
    if (fd___1 != -1) {
#line 1609
      dup2(fd___1, 0);
#line 1610
      dup2(fd___1, 1);
#line 1611
      if (fd___1 > 2) {
#line 1612
        close(fd___1);
      }
    }
#line 1614
    debug("rexec cleanup in %d out %d newsock %d pipe %d sock %d", sock_in, sock_out,
          newsock, startup_pipe, config_s[0]);
  }
#line 1623
  alarm(0U);
#line 1624
  mysignal(14, (void (*)(int  ))0);
#line 1625
  mysignal(1, (void (*)(int  ))0);
#line 1626
  mysignal(15, (void (*)(int  ))0);
#line 1627
  mysignal(3, (void (*)(int  ))0);
#line 1628
  mysignal(17, (void (*)(int  ))0);
#line 1629
  mysignal(2, (void (*)(int  ))0);
#line 1635
  packet_set_connection(sock_in, sock_out);
#line 1636
  packet_set_server();
#line 1639
  if (options.tcp_keep_alive) {
#line 1639
    tmp___74 = packet_connection_is_on_socket();
#line 1639
    if (tmp___74) {
#line 1639
      tmp___75 = setsockopt(sock_in, 1, 9, (void const   *)(& on), sizeof(on));
#line 1639
      if (tmp___75 < 0) {
#line 1641
        tmp___72 = __errno_location();
#line 1641
        tmp___73 = strerror(*tmp___72);
#line 1641
        error("setsockopt SO_KEEPALIVE: %.100s", tmp___73);
      }
    }
  }
#line 1643
  remote_port = get_remote_port();
#line 1643
  if (remote_port < 0) {
#line 1644
    debug("get_remote_port failed");
#line 1645
    cleanup_exit(255);
  }
#line 1652
  remote_ip___0 = get_canonical_hostname(0);
#line 1675
  verbose("Connection from %.500s port %d", remote_ip___0, remote_port);
#line 1685
  mysignal(14, & grace_alarm_handler);
#line 1686
  if (! debug_flag) {
#line 1687
    alarm((unsigned int )options.login_grace_time);
  }
#line 1689
  sshd_exchange_identification(sock_in, sock_out);
#line 1691
  packet_set_nonblocking();
#line 1694
  tmp___76 = xmalloc(sizeof(*authctxt___0));
#line 1694
  authctxt___0 = (Authctxt *)tmp___76;
#line 1695
  memset((void *)authctxt___0, 0, sizeof(*authctxt___0));
#line 1697
  authctxt___0->loginmsg = & loginmsg;
#line 1700
  the_authctxt = authctxt___0;
#line 1703
  buffer_init(& loginmsg);
#line 1705
  if (use_privsep) {
#line 1706
    tmp___77 = privsep_preauth(authctxt___0);
#line 1706
    if (tmp___77 == 1) {
      goto authenticated;
    }
  }
#line 1711
  if (compat20) {
#line 1712
    do_ssh2_kex();
#line 1713
    do_authentication2(authctxt___0);
  } else {
#line 1715
    do_ssh1_kex();
#line 1716
    do_authentication(authctxt___0);
  }
#line 1722
  if (use_privsep) {
#line 1723
    mm_send_keystate(pmonitor);
#line 1724
    exit(0);
  }
  authenticated: 
#line 1732
  alarm(0U);
#line 1733
  mysignal(14, (void (*)(int  ))0);
#line 1734
  if (startup_pipe != -1) {
#line 1735
    close(startup_pipe);
#line 1736
    startup_pipe = -1;
  }
#line 1747
  if (use_privsep) {
#line 1748
    privsep_postauth(authctxt___0);
#line 1750
    if (! compat20) {
#line 1751
      destroy_sensitive_data();
    }
  }
#line 1755
  do_authenticated(authctxt___0);
#line 1758
  verbose("Closing connection to %.100s", remote_ip___0);
#line 1769
  packet_close();
#line 1771
  if (use_privsep) {
#line 1772
    mm_terminate();
  }
#line 1774
  exit(0);
}
}
#line 1781 "sshd.c"
int ssh1_session_key(BIGNUM *session_key_int ) 
{ int rsafail ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 1784
  rsafail = 0;
#line 1786
  tmp___13 = BN_cmp((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n, (BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1786
  if (tmp___13 > 0) {
#line 1788
    tmp___2 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1788
    tmp___3 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1788
    if (tmp___2 < tmp___3 + 128) {
#line 1790
      tmp = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1790
      tmp___0 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1790
      tmp___1 = get_remote_ipaddr();
#line 1790
      fatal("do_connection: %s: server_key %d < host_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___1, tmp___0, tmp, 128);
    }
#line 1796
    tmp___4 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.server_key)->rsa);
#line 1796
    if (tmp___4 <= 0) {
#line 1798
      rsafail ++;
    }
#line 1799
    tmp___5 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.ssh1_host_key)->rsa);
#line 1799
    if (tmp___5 <= 0) {
#line 1801
      rsafail ++;
    }
  } else {
#line 1804
    tmp___9 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1804
    tmp___10 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1804
    if (tmp___9 < tmp___10 + 128) {
#line 1806
      tmp___6 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1806
      tmp___7 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1806
      tmp___8 = get_remote_ipaddr();
#line 1806
      fatal("do_connection: %s: host_key %d < server_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___8, tmp___7, tmp___6, 128);
    }
#line 1812
    tmp___11 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.ssh1_host_key)->rsa);
#line 1812
    if (tmp___11 < 0) {
#line 1814
      rsafail ++;
    }
#line 1815
    tmp___12 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.server_key)->rsa);
#line 1815
    if (tmp___12 < 0) {
#line 1817
      rsafail ++;
    }
  }
#line 1819
  return (rsafail);
}
}
#line 1824 "sshd.c"
static void do_ssh1_kex(void) 
{ int i ;
  int len ;
  int rsafail ;
  BIGNUM *session_key_int ;
  u_char session_key[32] ;
  u_char cookie[8] ;
  u_int cipher_type ;
  u_int auth_mask ;
  u_int protocol_flags ;
  u_int32_t rnd ;
  int tmp ;
  int tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  char *tmp___6 ;
  int _len ;
  int tmp___7 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  int bytes ;
  int tmp___12 ;
  u_char *buf___1 ;
  void *tmp___13 ;
  MD5_CTX md ;

  {
#line 1828
  rsafail = 0;
#line 1833
  rnd = (u_int32_t )0;
#line 1844
  i = 0;
#line 1844
  while (i < 8) {
#line 1845
    if (i % 4 == 0) {
#line 1846
      rnd = arc4random();
    }
#line 1847
    cookie[i] = (unsigned char )(rnd & 255U);
#line 1848
    rnd >>= 8;
#line 1844
    i ++;
  }
#line 1856
  packet_start((unsigned char)2);
#line 1857
  i = 0;
#line 1857
  while (i < 8) {
#line 1858
    packet_put_char((int )cookie[i]);
#line 1857
    i ++;
  }
#line 1861
  tmp = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1861
  packet_put_int((unsigned int )tmp);
#line 1862
  packet_put_bignum(((sensitive_data.server_key)->rsa)->e);
#line 1863
  packet_put_bignum(((sensitive_data.server_key)->rsa)->n);
#line 1866
  tmp___0 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1866
  packet_put_int((unsigned int )tmp___0);
#line 1867
  packet_put_bignum(((sensitive_data.ssh1_host_key)->rsa)->e);
#line 1868
  packet_put_bignum(((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1871
  packet_put_int(2U);
#line 1874
  tmp___1 = cipher_mask_ssh1(0);
#line 1874
  packet_put_int(tmp___1);
#line 1877
  auth_mask = 0U;
#line 1878
  if (options.rhosts_rsa_authentication) {
#line 1879
    auth_mask |= (unsigned int )(1 << 4);
  }
#line 1880
  if (options.rsa_authentication) {
#line 1881
    auth_mask |= (unsigned int )(1 << 2);
  }
#line 1882
  if (options.challenge_response_authentication == 1) {
#line 1883
    auth_mask |= (unsigned int )(1 << 5);
  }
#line 1884
  if (options.password_authentication) {
#line 1885
    auth_mask |= (unsigned int )(1 << 3);
  }
#line 1886
  packet_put_int(auth_mask);
#line 1889
  packet_send();
#line 1890
  packet_write_wait();
#line 1892
  tmp___2 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1892
  tmp___3 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1892
  debug("Sent %d bit server key and %d bit host key.", tmp___3, tmp___2);
#line 1897
  packet_read_expect(3);
#line 1900
  cipher_type = packet_get_char();
#line 1902
  tmp___4 = cipher_mask_ssh1(0);
#line 1902
  if (! (tmp___4 & (unsigned int )(1 << cipher_type))) {
#line 1903
    packet_disconnect("Warning: client selects unsupported cipher.");
  }
#line 1907
  i = 0;
#line 1907
  while (i < 8) {
#line 1908
    tmp___5 = packet_get_char();
#line 1908
    if ((u_int )cookie[i] != tmp___5) {
#line 1909
      packet_disconnect("IP Spoofing check bytes do not match.");
    }
#line 1907
    i ++;
  }
#line 1911
  tmp___6 = cipher_name((int )cipher_type);
#line 1911
  debug("Encryption type: %.200s", tmp___6);
#line 1914
  session_key_int = BN_new();
#line 1914
  if ((unsigned int )session_key_int == (unsigned int )((void *)0)) {
#line 1915
    fatal("do_ssh1_kex: BN_new failed");
  }
#line 1916
  packet_get_bignum(session_key_int);
#line 1918
  protocol_flags = packet_get_int();
#line 1919
  packet_set_protocol_flags(protocol_flags);
#line 1920
  while (1) {
#line 1920
    tmp___7 = packet_remaining();
#line 1920
    _len = tmp___7;
#line 1920
    if (_len > 0) {
#line 1920
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "sshd.c",
            1920);
#line 1920
      packet_disconnect("Packet integrity error.");
    }
#line 1920
    break;
  }
#line 1923
  if (use_privsep) {
#line 1923
    rsafail = mm_ssh1_session_key(session_key_int);
  } else {
#line 1923
    rsafail = ssh1_session_key(session_key_int);
  }
#line 1930
  if (! rsafail) {
#line 1931
    BN_mask_bits(session_key_int, (int )(sizeof(session_key) * 8U));
#line 1932
    tmp___10 = BN_num_bits((BIGNUM const   *)session_key_int);
#line 1932
    len = (tmp___10 + 7) / 8;
#line 1933
    if (len < 0) {
#line 1934
      tmp___11 = get_remote_ipaddr();
#line 1934
      error("do_connection: bad session key len from %s: session_key_int %d > sizeof(session_key) %lu",
            tmp___11, len, (unsigned long )sizeof(session_key));
#line 1937
      rsafail ++;
    } else {
#line 1933
      if ((unsigned int )len > sizeof(session_key)) {
#line 1934
        tmp___11 = get_remote_ipaddr();
#line 1934
        error("do_connection: bad session key len from %s: session_key_int %d > sizeof(session_key) %lu",
              tmp___11, len, (unsigned long )sizeof(session_key));
#line 1937
        rsafail ++;
      } else {
#line 1939
        memset((void *)(session_key), 0, sizeof(session_key));
#line 1940
        BN_bn2bin((BIGNUM const   *)session_key_int, (session_key + sizeof(session_key)) - len);
#line 1943
        derive_ssh1_session_id(((sensitive_data.ssh1_host_key)->rsa)->n, ((sensitive_data.server_key)->rsa)->n,
                               (u_int8_t *)(cookie), (u_int8_t *)(session_id));
#line 1951
        i = 0;
#line 1951
        while (i < 16) {
#line 1952
          session_key[i] = (unsigned char )((int )session_key[i] ^ (int )session_id[i]);
#line 1951
          i ++;
        }
      }
    }
  }
#line 1955
  if (rsafail) {
#line 1956
    tmp___12 = BN_num_bits((BIGNUM const   *)session_key_int);
#line 1956
    bytes = (tmp___12 + 7) / 8;
#line 1957
    tmp___13 = xmalloc((unsigned int )bytes);
#line 1957
    buf___1 = (u_char *)tmp___13;
#line 1960
    logit("do_connection: generating a fake encryption key");
#line 1961
    BN_bn2bin((BIGNUM const   *)session_key_int, buf___1);
#line 1962
    MD5_Init(& md);
#line 1963
    MD5_Update(& md, (void const   *)buf___1, (unsigned int )bytes);
#line 1964
    MD5_Update(& md, (void const   *)(sensitive_data.ssh1_cookie), 32U);
#line 1965
    MD5_Final(session_key, & md);
#line 1966
    MD5_Init(& md);
#line 1967
    MD5_Update(& md, (void const   *)(session_key), 16U);
#line 1968
    MD5_Update(& md, (void const   *)buf___1, (unsigned int )bytes);
#line 1969
    MD5_Update(& md, (void const   *)(sensitive_data.ssh1_cookie), 32U);
#line 1970
    MD5_Final(session_key + 16, & md);
#line 1971
    memset((void *)buf___1, 0, (unsigned int )bytes);
#line 1972
    xfree((void *)buf___1);
#line 1973
    i = 0;
#line 1973
    while (i < 16) {
#line 1974
      session_id[i] = (unsigned char )((int )session_key[i] ^ (int )session_key[i + 16]);
#line 1973
      i ++;
    }
  }
#line 1977
  destroy_sensitive_data();
#line 1979
  if (use_privsep) {
#line 1980
    mm_ssh1_session_id(session_id);
  }
#line 1983
  BN_clear_free(session_key_int);
#line 1986
  packet_set_encryption_key((u_char const   *)(session_key), 32U, (int )cipher_type);
#line 1989
  memset((void *)(session_key), 0, sizeof(session_key));
#line 1991
  debug("Received session key; encryption turned on.");
#line 1994
  packet_start((unsigned char)14);
#line 1995
  packet_send();
#line 1996
  packet_write_wait();
#line 1997
  return;
}
}
#line 2002 "sshd.c"
static void do_ssh2_kex(void) 
{ Kex *kex ;

  {
#line 2007
  if ((unsigned int )options.ciphers != (unsigned int )((void *)0)) {
#line 2008
    myproposal[3] = options.ciphers;
#line 2008
    myproposal[2] = myproposal[3];
  }
#line 2011
  myproposal[2] = compat_cipher_proposal(myproposal[2]);
#line 2013
  myproposal[3] = compat_cipher_proposal(myproposal[3]);
#line 2016
  if ((unsigned int )options.macs != (unsigned int )((void *)0)) {
#line 2017
    myproposal[5] = options.macs;
#line 2017
    myproposal[4] = myproposal[5];
  }
#line 2020
  if (options.compression == 0) {
#line 2021
    myproposal[7] = (char *)"none";
#line 2021
    myproposal[6] = myproposal[7];
  } else {
#line 2023
    if (options.compression == 2) {
#line 2024
      myproposal[7] = (char *)"none,zlib@openssh.com";
#line 2024
      myproposal[6] = myproposal[7];
    }
  }
#line 2028
  myproposal[1] = list_hostkey_types();
#line 2031
  kex = kex_setup((char **)(myproposal));
#line 2032
  kex->kex[0] = & kexdh_server;
#line 2033
  kex->kex[1] = & kexdh_server;
#line 2034
  kex->kex[2] = & kexgex_server;
#line 2035
  kex->server = 1;
#line 2036
  kex->client_version_string = client_version_string;
#line 2037
  kex->server_version_string = server_version_string;
#line 2038
  kex->load_host_key = & get_hostkey_by_type;
#line 2039
  kex->host_key_index = & get_hostkey_index;
#line 2041
  xxx_kex = kex;
#line 2043
  dispatch_run(0, & kex->done, (void *)kex);
#line 2045
  session_id2 = kex->session_id;
#line 2046
  session_id2_len = kex->session_id_len;
#line 2055
  debug("KEX done");
#line 2056
  return;
}
}
#line 1 "auth-rhosts.o"
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 418 "/usr/include/netdb.h"
extern int innetgr(char const   *__netgroup , char const   *__host , char const   *__user ,
                   char const   *domain ) ;
#line 105 "auth.h"
int auth_rhosts(struct passwd *pw , char const   *client_user___0 ) ;
#line 106
int auth_rhosts2(struct passwd *pw , char const   *client_user___0 , char const   *hostname ,
                 char const   *ipaddr ) ;
#line 183
void ( /* format attribute */  auth_debug_add)(char const   *fmt  , ...) ;
#line 184
void auth_debug_send(void) ;
#line 185
void auth_debug_reset(void) ;
#line 37 "auth-rhosts.c"
static int check_rhosts_file(char const   *filename , char const   *hostname , char const   *ipaddr ,
                             char const   *client_user___0 , char const   *server_user ) 
{ FILE *f ;
  char buf___1[1024] ;
  char hostbuf[1024] ;
  char userbuf[1024] ;
  char dummy[1024] ;
  char *host ;
  char *user ;
  char *cp ;
  int negated ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___45 ;
  int tmp___48 ;
  int tmp___49 ;
  char *tmp___50 ;

  {
#line 46
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 47
  if (! f) {
#line 48
    return (0);
  }
#line 50
  while (1) {
#line 50
    tmp___50 = fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )f);
#line 50
    if (! tmp___50) {
#line 50
      break;
    }
#line 55
    cp = buf___1;
#line 55
    while (1) {
#line 55
      if (! ((int )*cp == 32)) {
#line 55
        if (! ((int )*cp == 9)) {
#line 55
          break;
        }
      }
#line 55
      cp ++;
    }
#line 57
    if ((int )*cp == 35) {
#line 58
      continue;
    } else {
#line 57
      if ((int )*cp == 10) {
#line 58
        continue;
      } else {
#line 57
        if (! *cp) {
#line 58
          continue;
        }
      }
    }
#line 64
    if (0) {
#line 64
      if (0) {
#line 64
        __s1_len___0 = strlen((char const   *)cp);
#line 64
        __s2_len___0 = strlen("NO_PLUS");
#line 64
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___2;
        } else {
#line 64
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 64
            if (! ((unsigned int )((void const   *)("NO_PLUS" + 1)) - (unsigned int )((void const   *)"NO_PLUS") == 1U)) {
#line 64
              tmp___22 = 1;
            } else {
#line 64
              if (__s2_len___0 >= 4U) {
#line 64
                tmp___22 = 1;
              } else {
#line 64
                tmp___22 = 0;
              }
            }
          } else {
#line 64
            tmp___22 = 0;
          }
        }
#line 64
        if (tmp___22) {
#line 64
          tmp___18 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
        } else {
#line 64
          tmp___21 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 64
          tmp___18 = tmp___21;
        }
      } else {
#line 64
        tmp___21 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 64
        tmp___18 = tmp___21;
      }
#line 64
      tmp___12 = tmp___18;
    } else {
#line 64
      tmp___12 = strncmp((char const   *)cp, "NO_PLUS", 7U);
    }
#line 64
    if (tmp___12 == 0) {
#line 65
      continue;
    }
#line 71
    tmp___25 = sscanf((char const   * __restrict  )(buf___1), (char const   * __restrict  )"%1023s %1023s %1023s",
                      hostbuf, userbuf, dummy);
#line 71
    switch (tmp___25) {
    case 0: 
#line 74
    auth_debug_add("Found empty line in %.100s.", filename);
#line 75
    continue;
    case 1: 
#line 78
    strlcpy(userbuf, server_user, sizeof(userbuf));
#line 79
    break;
    case 2: 
#line 82
    break;
    case 3: 
#line 84
    auth_debug_add("Found garbage in %.100s.", filename);
#line 85
    continue;
    default: ;
#line 88
    continue;
    }
#line 91
    host = hostbuf;
#line 92
    user = userbuf;
#line 93
    negated = 0;
#line 96
    if ((int )*(host + 0) == 45) {
#line 97
      negated = 1;
#line 98
      host ++;
    } else {
#line 99
      if ((int )*(host + 0) == 43) {
#line 100
        host ++;
      }
    }
#line 102
    if ((int )*(user + 0) == 45) {
#line 103
      negated = 1;
#line 104
      user ++;
    } else {
#line 105
      if ((int )*(user + 0) == 43) {
#line 106
        user ++;
      }
    }
#line 109
    if (! *(host + 0)) {
#line 111
      auth_debug_add("Ignoring wild host/user names in %.100s.", filename);
#line 113
      continue;
    } else {
#line 109
      if (! *(user + 0)) {
#line 111
        auth_debug_add("Ignoring wild host/user names in %.100s.", filename);
#line 113
        continue;
      }
    }
#line 116
    if ((int )*(host + 0) == 64) {
#line 117
      tmp___26 = innetgr((char const   *)(host + 1), hostname, (char const   *)((void *)0),
                         (char const   *)((void *)0));
#line 117
      if (! tmp___26) {
#line 117
        tmp___27 = innetgr((char const   *)(host + 1), ipaddr, (char const   *)((void *)0),
                           (char const   *)((void *)0));
#line 117
        if (! tmp___27) {
#line 119
          continue;
        }
      }
    } else {
#line 120
      tmp___28 = strcasecmp((char const   *)host, hostname);
#line 120
      if (tmp___28) {
#line 120
        if (0) {
#line 120
          __s1_len___1 = strlen((char const   *)host);
#line 120
          __s2_len___1 = strlen(ipaddr);
#line 120
          if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
            goto _L___4;
          } else {
#line 120
            if (__s1_len___1 >= 4U) {
              _L___4: /* CIL Label */ 
#line 120
              if (! ((unsigned int )((void const   *)(ipaddr + 1)) - (unsigned int )((void const   *)ipaddr) == 1U)) {
#line 120
                tmp___38 = 1;
              } else {
#line 120
                if (__s2_len___1 >= 4U) {
#line 120
                  tmp___38 = 1;
                } else {
#line 120
                  tmp___38 = 0;
                }
              }
            } else {
#line 120
              tmp___38 = 0;
            }
          }
#line 120
          if (tmp___38) {
#line 120
            tmp___34 = __builtin_strcmp((char const   *)host, ipaddr);
          } else {
#line 120
            tmp___37 = __builtin_strcmp((char const   *)host, ipaddr);
#line 120
            tmp___34 = tmp___37;
          }
        } else {
#line 120
          tmp___37 = __builtin_strcmp((char const   *)host, ipaddr);
#line 120
          tmp___34 = tmp___37;
        }
#line 120
        if (tmp___34 != 0) {
#line 121
          continue;
        }
      }
    }
#line 124
    if ((int )*(user + 0) == 64) {
#line 125
      tmp___39 = innetgr((char const   *)(user + 1), (char const   *)((void *)0),
                         client_user___0, (char const   *)((void *)0));
#line 125
      if (! tmp___39) {
#line 126
        continue;
      }
    } else {
#line 127
      if (0) {
#line 127
        __s1_len___2 = strlen((char const   *)user);
#line 127
        __s2_len___2 = strlen(client_user___0);
#line 127
        if (! ((unsigned int )((void const   *)(user + 1)) - (unsigned int )((void const   *)user) == 1U)) {
          goto _L___6;
        } else {
#line 127
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 127
            if (! ((unsigned int )((void const   *)(client_user___0 + 1)) - (unsigned int )((void const   *)client_user___0) == 1U)) {
#line 127
              tmp___49 = 1;
            } else {
#line 127
              if (__s2_len___2 >= 4U) {
#line 127
                tmp___49 = 1;
              } else {
#line 127
                tmp___49 = 0;
              }
            }
          } else {
#line 127
            tmp___49 = 0;
          }
        }
#line 127
        if (tmp___49) {
#line 127
          tmp___45 = __builtin_strcmp((char const   *)user, client_user___0);
        } else {
#line 127
          tmp___48 = __builtin_strcmp((char const   *)user, client_user___0);
#line 127
          tmp___45 = tmp___48;
        }
      } else {
#line 127
        tmp___48 = __builtin_strcmp((char const   *)user, client_user___0);
#line 127
        tmp___45 = tmp___48;
      }
#line 127
      if (tmp___45 != 0) {
#line 128
        continue;
      }
    }
#line 131
    fclose(f);
#line 134
    if (negated) {
#line 135
      auth_debug_add("Matched negative entry in %.100s.", filename);
#line 137
      return (0);
    }
#line 140
    return (1);
  }
#line 144
  fclose(f);
#line 145
  return (0);
}
}
#line 154 "auth-rhosts.c"
int auth_rhosts(struct passwd *pw , char const   *client_user___0 ) 
{ char const   *hostname ;
  char const   *ipaddr ;
  int tmp ;

  {
#line 159
  hostname = get_canonical_hostname(options.use_dns);
#line 160
  ipaddr = get_remote_ipaddr();
#line 161
  tmp = auth_rhosts2(pw, client_user___0, hostname, ipaddr);
#line 161
  return (tmp);
}
}
#line 170
static int auth_rhosts2_raw(struct passwd *pw , char const   *client_user___0 , char const   *hostname ,
                            char const   *ipaddr ) ;
#line 170 "auth-rhosts.c"
static char const   *rhosts_files[3]  = {      ".shosts",      ".rhosts",      (char const   *)((void *)0)};
#line 164 "auth-rhosts.c"
static int auth_rhosts2_raw(struct passwd *pw , char const   *client_user___0 , char const   *hostname ,
                            char const   *ipaddr ) 
{ char buf___1[1024] ;
  struct stat st ;
  u_int rhosts_file_index ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 173
  debug2("auth_rhosts2: clientuser %s hostname %s ipaddr %s", client_user___0, hostname,
         ipaddr);
#line 177
  temporarily_use_uid(pw);
#line 183
  rhosts_file_index = 0U;
#line 183
  while (rhosts_files[rhosts_file_index]) {
#line 186
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.500s/%.100s",
             pw->pw_dir, rhosts_files[rhosts_file_index]);
#line 188
    tmp = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )(& st));
#line 188
    if (tmp >= 0) {
#line 189
      break;
    }
#line 183
    rhosts_file_index ++;
  }
#line 192
  restore_uid();
#line 195
  if (! rhosts_files[rhosts_file_index]) {
#line 195
    tmp___0 = stat((char const   * __restrict  )"/etc/hosts.equiv", (struct stat * __restrict  )(& st));
#line 195
    if (tmp___0 < 0) {
#line 195
      tmp___1 = stat((char const   * __restrict  )"/usr/local/etc/shosts.equiv", (struct stat * __restrict  )(& st));
#line 195
      if (tmp___1 < 0) {
#line 198
        return (0);
      }
    }
  }
#line 201
  if (pw->pw_uid != 0U) {
#line 202
    tmp___2 = check_rhosts_file("/etc/hosts.equiv", hostname, ipaddr, client_user___0,
                                (char const   *)pw->pw_name);
#line 202
    if (tmp___2) {
#line 204
      auth_debug_add("Accepted for %.100s [%.100s] by /etc/hosts.equiv.", hostname,
                     ipaddr);
#line 206
      return (1);
    }
#line 208
    tmp___3 = check_rhosts_file("/usr/local/etc/shosts.equiv", hostname, ipaddr, client_user___0,
                                (char const   *)pw->pw_name);
#line 208
    if (tmp___3) {
#line 210
      auth_debug_add("Accepted for %.100s [%.100s] by %.100s.", hostname, ipaddr,
                     "/usr/local/etc/shosts.equiv");
#line 212
      return (1);
    }
  }
#line 219
  tmp___4 = stat((char const   * __restrict  )pw->pw_dir, (struct stat * __restrict  )(& st));
#line 219
  if (tmp___4 < 0) {
#line 220
    logit("Rhosts authentication refused for %.100s: no home directory %.200s", pw->pw_name,
          pw->pw_dir);
#line 222
    auth_debug_add("Rhosts authentication refused for %.100s: no home directory %.200s",
                   pw->pw_name, pw->pw_dir);
#line 224
    return (0);
  }
#line 226
  if (options.strict_modes) {
#line 226
    if (st.st_uid != 0U) {
#line 226
      if (st.st_uid != pw->pw_uid) {
#line 229
        logit("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
              pw->pw_name);
#line 231
        auth_debug_add("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                       pw->pw_name);
#line 233
        return (0);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 226
      if ((st.st_mode & 18U) != 0U) {
#line 229
        logit("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
              pw->pw_name);
#line 231
        auth_debug_add("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                       pw->pw_name);
#line 233
        return (0);
      }
    }
  }
#line 236
  temporarily_use_uid(pw);
#line 239
  rhosts_file_index = 0U;
#line 239
  while (rhosts_files[rhosts_file_index]) {
#line 242
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.500s/%.100s",
             pw->pw_dir, rhosts_files[rhosts_file_index]);
#line 244
    tmp___5 = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )(& st));
#line 244
    if (tmp___5 < 0) {
      goto __Cont;
    }
#line 253
    if (options.strict_modes) {
#line 253
      if (st.st_uid != 0U) {
#line 253
        if (st.st_uid != pw->pw_uid) {
#line 256
          logit("Rhosts authentication refused for %.100s: bad modes for %.200s",
                pw->pw_name, buf___1);
#line 258
          auth_debug_add("Bad file modes for %.200s", buf___1);
          goto __Cont;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 253
        if ((st.st_mode & 18U) != 0U) {
#line 256
          logit("Rhosts authentication refused for %.100s: bad modes for %.200s",
                pw->pw_name, buf___1);
#line 258
          auth_debug_add("Bad file modes for %.200s", buf___1);
          goto __Cont;
        }
      }
    }
#line 262
    if (options.ignore_rhosts) {
#line 263
      auth_debug_add("Server has been configured to ignore %.100s.", rhosts_files[rhosts_file_index]);
      goto __Cont;
    }
#line 268
    tmp___6 = check_rhosts_file((char const   *)(buf___1), hostname, ipaddr, client_user___0,
                                (char const   *)pw->pw_name);
#line 268
    if (tmp___6) {
#line 269
      auth_debug_add("Accepted by %.100s.", rhosts_files[rhosts_file_index]);
#line 272
      restore_uid();
#line 273
      auth_debug_add("Accepted host %s ip %s client_user %s server_user %s", hostname,
                     ipaddr, client_user___0, pw->pw_name);
#line 275
      return (1);
    }
    __Cont: /* CIL Label */ 
#line 239
    rhosts_file_index ++;
  }
#line 280
  restore_uid();
#line 281
  return (0);
}
}
#line 284 "auth-rhosts.c"
int auth_rhosts2(struct passwd *pw , char const   *client_user___0 , char const   *hostname ,
                 char const   *ipaddr ) 
{ int ret ;

  {
#line 290
  auth_debug_reset();
#line 291
  ret = auth_rhosts2_raw(pw, client_user___0, hostname, ipaddr);
#line 292
  if (! use_privsep) {
#line 293
    auth_debug_send();
  }
#line 294
  return (ret);
}
}
#line 1 "auth-passwd.o"
#line 110 "auth.h"
int auth_password(Authctxt *authctxt___0 , char const   *password ) ;
#line 131
int auth_shadow_pwexpired(Authctxt *ctxt ) ;
#line 138
void disable_forwarding(void) ;
#line 189
int sys_auth_passwd(Authctxt *authctxt___0 , char const   *password ) ;
#line 25 "auth-options.h"
int no_port_forwarding_flag ;
#line 26
int no_agent_forwarding_flag ;
#line 27
int no_x11_forwarding_flag ;
#line 59 "auth-passwd.c"
void disable_forwarding(void) 
{ 

  {
#line 62
  no_port_forwarding_flag = 1;
#line 63
  no_agent_forwarding_flag = 1;
#line 64
  no_x11_forwarding_flag = 1;
#line 65
  return;
}
}
#line 77 "auth-passwd.c"
static int expire_checked  =    0;
#line 71 "auth-passwd.c"
int auth_password(Authctxt *authctxt___0 , char const   *password ) 
{ struct passwd *pw ;
  int result ;
  int ok ;
  int tmp ;
  int tmp___0 ;

  {
#line 74
  pw = authctxt___0->pw;
#line 75
  ok = authctxt___0->valid;
#line 81
  if (pw->pw_uid == 0U) {
#line 81
    if (options.permit_root_login != 3) {
#line 82
      ok = 0;
    }
  }
#line 84
  if ((int const   )*password == 0) {
#line 84
    if (options.permit_empty_passwd == 0) {
#line 85
      return (0);
    }
  }
#line 110
  if (! expire_checked) {
#line 111
    expire_checked = 1;
#line 112
    tmp = auth_shadow_pwexpired(authctxt___0);
#line 112
    if (tmp) {
#line 113
      authctxt___0->force_pwchange = 1;
    }
  }
#line 116
  result = sys_auth_passwd(authctxt___0, password);
#line 117
  if (authctxt___0->force_pwchange) {
#line 118
    disable_forwarding();
  }
#line 119
  if (result) {
#line 119
    if (ok) {
#line 119
      tmp___0 = 1;
    } else {
#line 119
      tmp___0 = 0;
    }
  } else {
#line 119
    tmp___0 = 0;
  }
#line 119
  return (tmp___0);
}
}
#line 182 "auth-passwd.c"
int sys_auth_passwd(Authctxt *authctxt___0 , char const   *password ) 
{ struct passwd *pw ;
  char *encrypted_password ;
  char *pw_password ;
  char *tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___16 ;
  int tmp___19 ;
  int tmp___20 ;
  char const   *tmp___21 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___27 ;
  int tmp___30 ;
  int tmp___31 ;

  {
#line 185
  pw = authctxt___0->pw;
#line 189
  if (authctxt___0->valid) {
#line 189
    tmp___0 = shadow_pw(pw);
  } else {
#line 189
    tmp___0 = pw->pw_passwd;
  }
#line 189
  pw_password = tmp___0;
#line 192
  if (0) {
#line 192
    __s1_len = strlen((char const   *)pw_password);
#line 192
    __s2_len = strlen("");
#line 192
    if (! ((unsigned int )((void const   *)(pw_password + 1)) - (unsigned int )((void const   *)pw_password) == 1U)) {
      goto _L___0;
    } else {
#line 192
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 192
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 192
          tmp___10 = 1;
        } else {
#line 192
          if (__s2_len >= 4U) {
#line 192
            tmp___10 = 1;
          } else {
#line 192
            tmp___10 = 0;
          }
        }
      } else {
#line 192
        tmp___10 = 0;
      }
    }
#line 192
    if (tmp___10) {
#line 192
      tmp___6 = __builtin_strcmp((char const   *)pw_password, "");
    } else {
#line 192
      tmp___9 = __builtin_strcmp((char const   *)pw_password, "");
#line 192
      tmp___6 = tmp___9;
    }
  } else {
#line 192
    tmp___9 = __builtin_strcmp((char const   *)pw_password, "");
#line 192
    tmp___6 = tmp___9;
  }
#line 192
  if (tmp___6 == 0) {
#line 192
    if (0) {
#line 192
      __s1_len___0 = strlen(password);
#line 192
      __s2_len___0 = strlen("");
#line 192
      if (! ((unsigned int )((void const   *)(password + 1)) - (unsigned int )((void const   *)password) == 1U)) {
        goto _L___2;
      } else {
#line 192
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 192
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 192
            tmp___20 = 1;
          } else {
#line 192
            if (__s2_len___0 >= 4U) {
#line 192
              tmp___20 = 1;
            } else {
#line 192
              tmp___20 = 0;
            }
          }
        } else {
#line 192
          tmp___20 = 0;
        }
      }
#line 192
      if (tmp___20) {
#line 192
        tmp___16 = __builtin_strcmp(password, "");
      } else {
#line 192
        tmp___19 = __builtin_strcmp(password, "");
#line 192
        tmp___16 = tmp___19;
      }
    } else {
#line 192
      tmp___19 = __builtin_strcmp(password, "");
#line 192
      tmp___16 = tmp___19;
    }
#line 192
    if (tmp___16 == 0) {
#line 193
      return (1);
    }
  }
#line 196
  if (*(pw_password + 0)) {
#line 196
    if (*(pw_password + 1)) {
#line 196
      tmp___21 = (char const   *)pw_password;
    } else {
#line 196
      tmp___21 = "xx";
    }
  } else {
#line 196
    tmp___21 = "xx";
  }
#line 196
  encrypted_password = xcrypt(password, tmp___21);
#line 203
  if (0) {
#line 203
    __s1_len___1 = strlen((char const   *)encrypted_password);
#line 203
    __s2_len___1 = strlen((char const   *)pw_password);
#line 203
    if (! ((unsigned int )((void const   *)(encrypted_password + 1)) - (unsigned int )((void const   *)encrypted_password) == 1U)) {
      goto _L___4;
    } else {
#line 203
      if (__s1_len___1 >= 4U) {
        _L___4: /* CIL Label */ 
#line 203
        if (! ((unsigned int )((void const   *)(pw_password + 1)) - (unsigned int )((void const   *)pw_password) == 1U)) {
#line 203
          tmp___31 = 1;
        } else {
#line 203
          if (__s2_len___1 >= 4U) {
#line 203
            tmp___31 = 1;
          } else {
#line 203
            tmp___31 = 0;
          }
        }
      } else {
#line 203
        tmp___31 = 0;
      }
    }
#line 203
    if (tmp___31) {
#line 203
      tmp___27 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)pw_password);
    } else {
#line 203
      tmp___30 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)pw_password);
#line 203
      tmp___27 = tmp___30;
    }
  } else {
#line 203
    tmp___30 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)pw_password);
#line 203
    tmp___27 = tmp___30;
  }
#line 203
  return (tmp___27 == 0);
}
}
#line 1 "auth-rsa.o"
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 33 "auth-options.h"
int auth_parse_options(struct passwd *pw , char *opts , char *file___0 , u_long linenum ) ;
#line 34
void auth_clear_options(void) ;
#line 111 "auth.h"
int auth_rsa(Authctxt *authctxt___0 , BIGNUM *client_n ) ;
#line 112
int auth_rsa_challenge_dialog(Key *key ) ;
#line 113
BIGNUM *auth_rsa_generate_challenge(Key *key ) ;
#line 114
int auth_rsa_verify_response(Key *key , BIGNUM *challenge , u_char *response ) ;
#line 115
int auth_rsa_key_allowed(struct passwd *pw , BIGNUM *client_n , Key **rkey ) ;
#line 166
char *authorized_keys_file(struct passwd *pw ) ;
#line 169
int secure_filename(FILE *f , char const   *file___0 , struct passwd *pw , char *err ,
                    size_t errlen ) ;
#line 55 "monitor_wrap.h"
int mm_auth_rsa_key_allowed(struct passwd *pw , BIGNUM *client_n , Key **rkey ) ;
#line 56
int mm_auth_rsa_verify_response(Key *key , BIGNUM *p , u_char *response ) ;
#line 57
BIGNUM *mm_auth_rsa_generate_challenge(Key *key ) ;
#line 57 "auth-rsa.c"
BIGNUM *auth_rsa_generate_challenge(Key *key ) 
{ BIGNUM *challenge ;
  BN_CTX *ctx ;

  {
#line 63
  challenge = BN_new();
#line 63
  if ((unsigned int )challenge == (unsigned int )((void *)0)) {
#line 64
    fatal("auth_rsa_generate_challenge: BN_new() failed");
  }
#line 66
  BN_rand(challenge, 256, 0, 0);
#line 67
  ctx = BN_CTX_new();
#line 67
  if ((unsigned int )ctx == (unsigned int )((void *)0)) {
#line 68
    fatal("auth_rsa_generate_challenge: BN_CTX_new() failed");
  }
#line 69
  BN_div((BIGNUM *)((void *)0), challenge, (BIGNUM const   *)challenge, (BIGNUM const   *)(key->rsa)->n,
         ctx);
#line 70
  BN_CTX_free(ctx);
#line 72
  return (challenge);
}
}
#line 75 "auth-rsa.c"
int auth_rsa_verify_response(Key *key , BIGNUM *challenge , u_char *response ) 
{ u_char buf___1[32] ;
  u_char mdbuf[16] ;
  MD5_CTX md ;
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 83
  tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 83
  if (tmp___0 < 768) {
#line 84
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 84
    error("auth_rsa_verify_response: RSA modulus too small: %d < minimum %d bits",
          tmp, 768);
#line 86
    return (0);
  }
#line 90
  tmp___1 = BN_num_bits((BIGNUM const   *)challenge);
#line 90
  len = (tmp___1 + 7) / 8;
#line 91
  if (len <= 0) {
#line 92
    fatal("auth_rsa_verify_response: bad challenge length %d", len);
  } else {
#line 91
    if (len > 32) {
#line 92
      fatal("auth_rsa_verify_response: bad challenge length %d", len);
    }
  }
#line 93
  memset((void *)(buf___1), 0, 32U);
#line 94
  BN_bn2bin((BIGNUM const   *)challenge, (buf___1 + 32) - len);
#line 95
  MD5_Init(& md);
#line 96
  MD5_Update(& md, (void const   *)(buf___1), 32U);
#line 97
  MD5_Update(& md, (void const   *)(session_id), 16U);
#line 98
  MD5_Final(mdbuf, & md);
#line 101
  tmp___2 = memcmp((void const   *)response, (void const   *)(mdbuf), 16U);
#line 101
  if (tmp___2 != 0) {
#line 103
    return (0);
  }
#line 106
  return (1);
}
}
#line 115 "auth-rsa.c"
int auth_rsa_challenge_dialog(Key *key ) 
{ BIGNUM *challenge ;
  BIGNUM *encrypted_challenge ;
  u_char response[16] ;
  int i ;
  int success ;
  u_int tmp___1 ;
  int _len ;
  int tmp___2 ;

  {
#line 122
  encrypted_challenge = BN_new();
#line 122
  if ((unsigned int )encrypted_challenge == (unsigned int )((void *)0)) {
#line 123
    fatal("auth_rsa_challenge_dialog: BN_new() failed");
  }
#line 125
  if (use_privsep) {
#line 125
    challenge = mm_auth_rsa_generate_challenge(key);
  } else {
#line 125
    challenge = auth_rsa_generate_challenge(key);
  }
#line 128
  rsa_public_encrypt(encrypted_challenge, challenge, key->rsa);
#line 131
  packet_start((unsigned char)7);
#line 132
  packet_put_bignum(encrypted_challenge);
#line 133
  packet_send();
#line 134
  BN_clear_free(encrypted_challenge);
#line 135
  packet_write_wait();
#line 138
  packet_read_expect(8);
#line 139
  i = 0;
#line 139
  while (i < 16) {
#line 140
    tmp___1 = packet_get_char();
#line 140
    response[i] = (unsigned char )tmp___1;
#line 139
    i ++;
  }
#line 141
  while (1) {
#line 141
    tmp___2 = packet_remaining();
#line 141
    _len = tmp___2;
#line 141
    if (_len > 0) {
#line 141
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth-rsa.c",
            141);
#line 141
      packet_disconnect("Packet integrity error.");
    }
#line 141
    break;
  }
#line 143
  if (use_privsep) {
#line 143
    success = mm_auth_rsa_verify_response(key, challenge, response);
  } else {
#line 143
    success = auth_rsa_verify_response(key, challenge, (u_char *)(response));
  }
#line 144
  BN_clear_free(challenge);
#line 145
  return (success);
}
}
#line 153 "auth-rsa.c"
int auth_rsa_key_allowed(struct passwd *pw , BIGNUM *client_n , Key **rkey ) 
{ char line[8192] ;
  char *file___0 ;
  int allowed ;
  u_int bits ;
  FILE *f ;
  u_long linenum ;
  struct stat st ;
  Key *key ;
  int tmp ;
  int tmp___0 ;
  char *cp ;
  char *key_options ;
  int keybits ;
  int quoted ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 157
  allowed = 0;
#line 160
  linenum = (u_long )0;
#line 165
  temporarily_use_uid(pw);
#line 168
  file___0 = authorized_keys_file(pw);
#line 169
  debug("trying public RSA key file %s", file___0);
#line 172
  tmp = stat((char const   * __restrict  )file___0, (struct stat * __restrict  )(& st));
#line 172
  if (tmp < 0) {
#line 174
    restore_uid();
#line 175
    xfree((void *)file___0);
#line 176
    return (0);
  }
#line 179
  f = fopen((char const   * __restrict  )file___0, (char const   * __restrict  )"r");
#line 180
  if (! f) {
#line 182
    restore_uid();
#line 183
    xfree((void *)file___0);
#line 184
    return (0);
  }
#line 186
  if (options.strict_modes) {
#line 186
    tmp___0 = secure_filename(f, (char const   *)file___0, pw, line, sizeof(line));
#line 186
    if (tmp___0 != 0) {
#line 188
      xfree((void *)file___0);
#line 189
      fclose(f);
#line 190
      logit("Authentication refused: %s", line);
#line 191
      restore_uid();
#line 192
      return (0);
    }
  }
#line 196
  allowed = 0;
#line 198
  key = key_new(0);
#line 205
  while (1) {
#line 205
    tmp___5 = read_keyfile_line(f, (char const   *)file___0, line, sizeof(line), & linenum);
#line 205
    if (! (tmp___5 != -1)) {
#line 205
      break;
    }
#line 211
    cp = line;
#line 211
    while (1) {
#line 211
      if (! ((int )*cp == 32)) {
#line 211
        if (! ((int )*cp == 9)) {
#line 211
          break;
        }
      }
#line 211
      cp ++;
    }
#line 213
    if (! *cp) {
#line 214
      continue;
    } else {
#line 213
      if ((int )*cp == 10) {
#line 214
        continue;
      } else {
#line 213
        if ((int )*cp == 35) {
#line 214
          continue;
        }
      }
    }
#line 222
    if ((int )*cp < 48) {
      goto _L___0;
    } else {
#line 222
      if ((int )*cp > 57) {
        _L___0: /* CIL Label */ 
#line 223
        quoted = 0;
#line 224
        key_options = cp;
#line 225
        while (1) {
#line 225
          if (*cp) {
#line 225
            if (! quoted) {
#line 225
              if ((int )*cp != 32) {
#line 225
                if (! ((int )*cp != 9)) {
#line 225
                  break;
                }
              } else {
#line 225
                break;
              }
            }
          } else {
#line 225
            break;
          }
#line 226
          if ((int )*cp == 92) {
#line 226
            if ((int )*(cp + 1) == 34) {
#line 227
              cp ++;
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 228
            if ((int )*cp == 34) {
#line 229
              quoted = ! quoted;
            }
          }
#line 225
          cp ++;
        }
      } else {
#line 232
        key_options = (char *)((void *)0);
      }
    }
#line 235
    tmp___1 = hostfile_read_key(& cp, & bits, key);
#line 235
    if (tmp___1 == 0) {
#line 236
      debug("%.100s, line %lu: non ssh1 key syntax", file___0, linenum);
#line 238
      continue;
    }
#line 243
    tmp___2 = BN_cmp((BIGNUM const   *)(key->rsa)->n, (BIGNUM const   *)client_n);
#line 243
    if (tmp___2 != 0) {
#line 244
      continue;
    }
#line 247
    keybits = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 248
    if (keybits < 0) {
#line 249
      tmp___3 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 249
      logit("Warning: %s, line %lu: keysize mismatch: actual %d vs. announced %d.",
            file___0, linenum, tmp___3, bits);
    } else {
#line 248
      if (bits != (unsigned int )keybits) {
#line 249
        tmp___3 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 249
        logit("Warning: %s, line %lu: keysize mismatch: actual %d vs. announced %d.",
              file___0, linenum, tmp___3, bits);
      }
    }
#line 258
    tmp___4 = auth_parse_options(pw, key_options, file___0, linenum);
#line 258
    if (! tmp___4) {
#line 259
      continue;
    }
#line 262
    allowed = 1;
#line 263
    break;
  }
#line 267
  restore_uid();
#line 270
  xfree((void *)file___0);
#line 271
  fclose(f);
#line 274
  if (allowed) {
#line 274
    if ((unsigned int )rkey != (unsigned int )((void *)0)) {
#line 275
      *rkey = key;
    } else {
#line 277
      key_free(key);
    }
  } else {
#line 277
    key_free(key);
  }
#line 278
  return (allowed);
}
}
#line 286 "auth-rsa.c"
int auth_rsa(Authctxt *authctxt___0 , BIGNUM *client_n ) 
{ Key *key ;
  char *fp ;
  struct passwd *pw ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;

  {
#line 291
  pw = authctxt___0->pw;
#line 294
  if (! authctxt___0->valid) {
#line 295
    return (0);
  }
#line 297
  if (use_privsep) {
#line 297
    tmp___1 = mm_auth_rsa_key_allowed(pw, client_n, & key);
  } else {
#line 297
    tmp___1 = auth_rsa_key_allowed(pw, client_n, & key);
  }
#line 297
  if (! tmp___1) {
#line 298
    auth_clear_options();
#line 299
    return (0);
  }
#line 303
  tmp___2 = auth_rsa_challenge_dialog(key);
#line 303
  if (! tmp___2) {
#line 305
    verbose("Wrong response to RSA authentication challenge.");
#line 306
    packet_send_debug("Wrong response to RSA authentication challenge.");
#line 311
    key_free(key);
#line 312
    return (0);
  }
#line 320
  fp = key_fingerprint((Key const   *)key, 1, 0);
#line 321
  tmp___3 = key_type((Key const   *)key);
#line 321
  verbose("Found matching %s key: %s", tmp___3, fp);
#line 323
  xfree((void *)fp);
#line 324
  key_free(key);
#line 326
  packet_send_debug("RSA authentication accepted.");
#line 327
  return (1);
}
}
#line 1 "auth-rh-rsa.o"
#line 109 "auth.h"
int auth_rhosts_rsa(Authctxt *authctxt___0 , char *cuser , Key *client_host_key ) ;
#line 117
int auth_rhosts_rsa_key_allowed(struct passwd *pw , char *cuser , char *chost , Key *client_host_key ) ;
#line 172
HostStatus check_key_in_hostfiles(struct passwd *pw , Key *key , char const   *host ,
                                  char const   *sysfile , char const   *userfile ) ;
#line 53 "monitor_wrap.h"
int mm_auth_rhosts_rsa_key_allowed(struct passwd *pw , char *user , char *host , Key *key ) ;
#line 33 "auth-rh-rsa.c"
int auth_rhosts_rsa_key_allowed(struct passwd *pw , char *cuser , char *chost , Key *client_host_key ) 
{ HostStatus host_status ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 40
  tmp = auth_rhosts(pw, (char const   *)cuser);
#line 40
  if (! tmp) {
#line 41
    return (0);
  }
#line 43
  if (options.ignore_user_known_hosts) {
#line 43
    tmp___0 = (char const   *)((void *)0);
  } else {
#line 43
    tmp___0 = "~/.ssh/known_hosts";
  }
#line 43
  host_status = check_key_in_hostfiles(pw, client_host_key, (char const   *)chost,
                                       "/usr/local/etc/ssh_known_hosts", tmp___0);
#line 47
  return ((int )host_status == 0);
}
}
#line 54 "auth-rh-rsa.c"
int auth_rhosts_rsa(Authctxt *authctxt___0 , char *cuser , Key *client_host_key ) 
{ char *chost ;
  struct passwd *pw ;
  char const   *tmp ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 58
  pw = authctxt___0->pw;
#line 60
  debug("Trying rhosts with RSA host authentication for client user %.100s", cuser);
#line 63
  if (! authctxt___0->valid) {
#line 65
    return (0);
  } else {
#line 63
    if ((unsigned int )client_host_key == (unsigned int )((void *)0)) {
#line 65
      return (0);
    } else {
#line 63
      if ((unsigned int )client_host_key->rsa == (unsigned int )((void *)0)) {
#line 65
        return (0);
      }
    }
  }
#line 67
  tmp = get_canonical_hostname(options.use_dns);
#line 67
  chost = (char *)tmp;
#line 68
  debug("Rhosts RSA authentication: canonical host %.900s", chost);
#line 70
  if (use_privsep) {
#line 70
    tmp___2 = mm_auth_rhosts_rsa_key_allowed(pw, cuser, chost, client_host_key);
  } else {
#line 70
    tmp___2 = auth_rhosts_rsa_key_allowed(pw, cuser, chost, client_host_key);
  }
#line 70
  if (! tmp___2) {
#line 71
    debug("Rhosts with RSA host authentication denied: unknown or invalid host key");
#line 72
    packet_send_debug("Your host key cannot be verified: unknown or invalid host key.");
#line 73
    return (0);
  }
#line 78
  tmp___3 = auth_rsa_challenge_dialog(client_host_key);
#line 78
  if (! tmp___3) {
#line 79
    logit("Client on %.800s failed to respond correctly to host authentication.",
          chost);
#line 81
    return (0);
  }
#line 88
  verbose("Rhosts with RSA host authentication accepted for %.100s, %.100s on %.700s.",
          pw->pw_name, cuser, chost);
#line 90
  packet_send_debug("Rhosts with RSA host authentication accepted.");
#line 91
  return (1);
}
}
#line 1 "sshpty.o"
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 280
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 109 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 433 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group )  __attribute__((__nonnull__(1))) ;
#line 736
extern  __attribute__((__nothrow__)) char *ttyname(int __fd ) ;
#line 872
extern  __attribute__((__nothrow__)) int vhangup(void) ;
#line 24 "sshpty.h"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) ;
#line 25
void pty_release(char const   *tty ) ;
#line 26
void pty_make_controlling_tty(int *ttyfd , char const   *tty ) ;
#line 27
void pty_change_window_size(int ptyfd , int row , int col , int xpixel , int ypixel ) ;
#line 28
void pty_setowner(struct passwd *pw , char const   *tty ) ;
#line 34 "/usr/include/pty.h"
extern  __attribute__((__nothrow__)) int openpty(int *__amaster , int *__aslave ,
                                                 char *__name , struct termios *__termp ,
                                                 struct winsize *__winp ) ;
#line 40 "sshpty.c"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) 
{ char *name ;
  int i ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 47
  i = openpty(ptyfd, ttyfd, (char *)((void *)0), (struct termios *)((void *)0), (struct winsize *)((void *)0));
#line 48
  if (i < 0) {
#line 49
    tmp = __errno_location();
#line 49
    tmp___0 = strerror(*tmp);
#line 49
    error("openpty: %.100s", tmp___0);
#line 50
    return (0);
  }
#line 52
  name = ttyname(*ttyfd);
#line 53
  if (! name) {
#line 54
    fatal("openpty returns device for which ttyname fails.");
  }
#line 56
  strlcpy(namebuf, (char const   *)name, (unsigned int )namebuflen);
#line 57
  return (1);
}
}
#line 62 "sshpty.c"
void pty_release(char const   *tty ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 65
  tmp___1 = chown(tty, 0U, 0U);
#line 65
  if (tmp___1 < 0) {
#line 66
    tmp = __errno_location();
#line 66
    tmp___0 = strerror(*tmp);
#line 66
    error("chown %.100s 0 0 failed: %.100s", tty, tmp___0);
  }
#line 67
  tmp___4 = chmod(tty, 438U);
#line 67
  if (tmp___4 < 0) {
#line 68
    tmp___2 = __errno_location();
#line 68
    tmp___3 = strerror(*tmp___2);
#line 68
    error("chmod %.100s 0666 failed: %.100s", tty, tmp___3);
  }
#line 69
  return;
}
}
#line 73 "sshpty.c"
void pty_make_controlling_tty(int *ttyfd , char const   *tty ) 
{ int fd ;
  void *old ;
  int *tmp ;
  char *tmp___0 ;
  __pid_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  mysig_t tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;

  {
#line 107
  fd = open("/dev/tty", 258);
#line 108
  if (fd >= 0) {
#line 109
    ioctl(fd, 21538UL, (void *)0);
#line 110
    close(fd);
  }
#line 113
  tmp___1 = setsid();
#line 113
  if (tmp___1 < 0) {
#line 114
    tmp = __errno_location();
#line 114
    tmp___0 = strerror(*tmp);
#line 114
    error("setsid: %.100s", tmp___0);
  }
#line 120
  fd = open("/dev/tty", 258);
#line 121
  if (fd >= 0) {
#line 122
    error("Failed to disconnect from controlling tty.");
#line 123
    close(fd);
  }
#line 127
  debug("Setting controlling tty using TIOCSCTTY.");
#line 128
  tmp___4 = ioctl(*ttyfd, 21518UL, (void *)0);
#line 128
  if (tmp___4 < 0) {
#line 129
    tmp___2 = __errno_location();
#line 129
    tmp___3 = strerror(*tmp___2);
#line 129
    error("ioctl(TIOCSCTTY): %.100s", tmp___3);
  }
#line 136
  tmp___5 = mysignal(1, (void (*)(int  ))1);
#line 136
  old = (void *)tmp___5;
#line 137
  vhangup();
#line 138
  mysignal(1, (void (*)(int  ))old);
#line 140
  fd = open(tty, 2);
#line 141
  if (fd < 0) {
#line 142
    tmp___6 = __errno_location();
#line 142
    tmp___7 = strerror(*tmp___6);
#line 142
    error("%.100s: %.100s", tty, tmp___7);
  } else {
#line 145
    close(*ttyfd);
#line 146
    *ttyfd = fd;
  }
#line 152
  fd = open("/dev/tty", 1);
#line 153
  if (fd < 0) {
#line 154
    tmp___8 = __errno_location();
#line 154
    tmp___9 = strerror(*tmp___8);
#line 154
    error("open /dev/tty failed - could not set controlling tty: %.100s", tmp___9);
  } else {
#line 157
    close(fd);
  }
#line 159
  return;
}
}
#line 163 "sshpty.c"
void pty_change_window_size(int ptyfd , int row , int col , int xpixel , int ypixel ) 
{ struct winsize w ;

  {
#line 169
  w.ws_row = (unsigned short )row;
#line 170
  w.ws_col = (unsigned short )col;
#line 171
  w.ws_xpixel = (unsigned short )xpixel;
#line 172
  w.ws_ypixel = (unsigned short )ypixel;
#line 173
  ioctl(ptyfd, 21524UL, & w);
#line 174
  return;
}
}
#line 176 "sshpty.c"
void pty_setowner(struct passwd *pw , char const   *tty ) 
{ struct group *grp ;
  gid_t gid ;
  mode_t mode ;
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;

  {
#line 185
  grp = getgrnam("tty");
#line 186
  if (grp) {
#line 187
    gid = grp->gr_gid;
#line 188
    mode = (unsigned int )(384 | (128 >> 3));
  } else {
#line 190
    gid = pw->pw_gid;
#line 191
    mode = (unsigned int )((384 | (128 >> 3)) | ((128 >> 3) >> 3));
  }
#line 199
  tmp___1 = stat((char const   * __restrict  )tty, (struct stat * __restrict  )(& st));
#line 199
  if (tmp___1) {
#line 200
    tmp = __errno_location();
#line 200
    tmp___0 = strerror(*tmp);
#line 200
    fatal("stat(%.100s) failed: %.100s", tty, tmp___0);
  }
#line 203
  if (st.st_uid != pw->pw_uid) {
    goto _L;
  } else {
#line 203
    if (st.st_gid != gid) {
      _L: /* CIL Label */ 
#line 204
      tmp___7 = chown(tty, pw->pw_uid, gid);
#line 204
      if (tmp___7 < 0) {
#line 205
        tmp___6 = __errno_location();
#line 205
        if (*tmp___6 == 30) {
#line 205
          if (st.st_uid == pw->pw_uid) {
#line 207
            tmp___2 = __errno_location();
#line 207
            tmp___3 = strerror(*tmp___2);
#line 207
            debug("chown(%.100s, %u, %u) failed: %.100s", tty, pw->pw_uid, gid, tmp___3);
          } else {
#line 205
            if (st.st_uid == 0U) {
#line 207
              tmp___2 = __errno_location();
#line 207
              tmp___3 = strerror(*tmp___2);
#line 207
              debug("chown(%.100s, %u, %u) failed: %.100s", tty, pw->pw_uid, gid,
                    tmp___3);
            } else {
#line 211
              tmp___4 = __errno_location();
#line 211
              tmp___5 = strerror(*tmp___4);
#line 211
              fatal("chown(%.100s, %u, %u) failed: %.100s", tty, pw->pw_uid, gid,
                    tmp___5);
            }
          }
        } else {
#line 211
          tmp___4 = __errno_location();
#line 211
          tmp___5 = strerror(*tmp___4);
#line 211
          fatal("chown(%.100s, %u, %u) failed: %.100s", tty, pw->pw_uid, gid, tmp___5);
        }
      }
    }
  }
#line 217
  if ((st.st_mode & (unsigned int )((448 | (448 >> 3)) | ((448 >> 3) >> 3))) != mode) {
#line 218
    tmp___13 = chmod(tty, mode);
#line 218
    if (tmp___13 < 0) {
#line 219
      tmp___12 = __errno_location();
#line 219
      if (*tmp___12 == 30) {
#line 219
        if ((st.st_mode & (unsigned int )((256 >> 3) | ((256 >> 3) >> 3))) == 0U) {
#line 221
          tmp___8 = __errno_location();
#line 221
          tmp___9 = strerror(*tmp___8);
#line 221
          debug("chmod(%.100s, 0%o) failed: %.100s", tty, mode, tmp___9);
        } else {
#line 224
          tmp___10 = __errno_location();
#line 224
          tmp___11 = strerror(*tmp___10);
#line 224
          fatal("chmod(%.100s, 0%o) failed: %.100s", tty, mode, tmp___11);
        }
      } else {
#line 224
        tmp___10 = __errno_location();
#line 224
        tmp___11 = strerror(*tmp___10);
#line 224
        fatal("chmod(%.100s, 0%o) failed: %.100s", tty, mode, tmp___11);
      }
    }
  }
#line 228
  return;
}
}
#line 1 "sshlogin.o"
#line 95 "loginrec.h"
struct logininfo *login_alloc_entry(int pid , char const   *username , char const   *hostname ,
                                    char const   *line ) ;
#line 98
void login_free_entry(struct logininfo *li ) ;
#line 106
int login_login(struct logininfo *li ) ;
#line 107
int login_logout(struct logininfo *li ) ;
#line 119
void login_set_addr(struct logininfo *li , struct sockaddr  const  *sa , unsigned int sa_size ) ;
#line 126
struct logininfo *login_get_lastlog(struct logininfo *li , int uid ) ;
#line 57 "sshlogin.c"
u_long get_last_login_time(uid_t uid , char const   *logname , char *buf___1 , u_int bufsize ) 
{ struct logininfo li ;

  {
#line 63
  login_get_lastlog(& li, (int )uid);
#line 64
  strlcpy(buf___1, (char const   *)(li.hostname), bufsize);
#line 65
  return ((unsigned long )li.tv_sec);
}
}
#line 72 "sshlogin.c"
static void store_lastlog_message(char const   *user , uid_t uid ) 
{ char *time_string ;
  char hostname[64] ;
  char buf___1[512] ;
  time_t last_login_time ;
  u_long tmp ;
  char *tmp___1 ;
  char *tmp___3 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___9 ;
  int tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;

  {
#line 75
  hostname[0] = (char )'\000';
#line 79
  if (! options.print_lastlog) {
#line 80
    return;
  }
#line 82
  tmp = get_last_login_time(uid, user, hostname, sizeof(hostname));
#line 82
  last_login_time = (long )tmp;
#line 85
  if (last_login_time != 0L) {
#line 86
    time_string = ctime((time_t const   *)(& last_login_time));
#line 87
    tmp___3 = __builtin_strchr(time_string, '\n');
#line 87
    if (tmp___3) {
#line 88
      tmp___1 = __builtin_strchr(time_string, '\n');
#line 88
      *tmp___1 = (char )'\000';
    }
#line 89
    if (0) {
#line 89
      __s1_len = strlen((char const   *)(hostname));
#line 89
      __s2_len = strlen("");
#line 89
      if (! ((unsigned int )((void const   *)(hostname + 1)) - (unsigned int )((void const   *)(hostname)) == 1U)) {
        goto _L___0;
      } else {
#line 89
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 89
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 89
            tmp___13 = 1;
          } else {
#line 89
            if (__s2_len >= 4U) {
#line 89
              tmp___13 = 1;
            } else {
#line 89
              tmp___13 = 0;
            }
          }
        } else {
#line 89
          tmp___13 = 0;
        }
      }
#line 89
      if (tmp___13) {
#line 89
        tmp___9 = __builtin_strcmp((char const   *)(hostname), "");
      } else {
#line 89
        tmp___12 = __builtin_strcmp((char const   *)(hostname), "");
#line 89
        tmp___9 = tmp___12;
      }
    } else {
#line 89
      tmp___12 = __builtin_strcmp((char const   *)(hostname), "");
#line 89
      tmp___9 = tmp___12;
    }
#line 89
    if (tmp___9 == 0) {
#line 90
      snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"Last login: %s\r\n",
               time_string);
    } else {
#line 93
      snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"Last login: %s from %s\r\n",
               time_string, hostname);
    }
#line 95
    tmp___14 = strlen((char const   *)(buf___1));
#line 95
    buffer_append(& loginmsg, (void const   *)(buf___1), tmp___14);
  }
#line 98
  return;
}
}
#line 104 "sshlogin.c"
void record_login(pid_t pid , char const   *tty , char const   *user , uid_t uid ,
                  char const   *host , struct sockaddr *addr , socklen_t addrlen ) 
{ struct logininfo *li ;

  {
#line 111
  store_lastlog_message(user, uid);
#line 113
  li = login_alloc_entry(pid, user, host, tty);
#line 114
  login_set_addr(li, (struct sockaddr  const  *)addr, addrlen);
#line 115
  login_login(li);
#line 116
  login_free_entry(li);
#line 117
  return;
}
}
#line 134 "sshlogin.c"
void record_logout(pid_t pid , char const   *tty , char const   *user ) 
{ struct logininfo *li ;

  {
#line 139
  li = login_alloc_entry(pid, user, (char const   *)((void *)0), tty);
#line 140
  login_logout(li);
#line 141
  login_free_entry(li);
#line 142
  return;
}
}
#line 1 "servconf.o"
#line 747 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 26 "servconf.c"
static void add_listen_addr(ServerOptions *options___0 , char *addr , u_short port___0 ) ;
#line 27
static void add_one_listen_addr(ServerOptions *options___0 , char *addr , u_short port___0 ) ;
#line 34 "servconf.c"
void initialize_server_options(ServerOptions *options___0 ) 
{ 

  {
#line 37
  memset((void *)options___0, 0, sizeof(*options___0));
#line 40
  options___0->use_pam = -1;
#line 43
  options___0->num_ports = 0U;
#line 44
  options___0->ports_from_cmdline = 0U;
#line 45
  options___0->listen_addrs = (struct addrinfo *)((void *)0);
#line 46
  options___0->address_family = -1;
#line 47
  options___0->num_host_key_files = 0;
#line 48
  options___0->pid_file = (char *)((void *)0);
#line 49
  options___0->server_key_bits = -1;
#line 50
  options___0->login_grace_time = -1;
#line 51
  options___0->key_regeneration_time = -1;
#line 52
  options___0->permit_root_login = -1;
#line 53
  options___0->ignore_rhosts = -1;
#line 54
  options___0->ignore_user_known_hosts = -1;
#line 55
  options___0->print_motd = -1;
#line 56
  options___0->print_lastlog = -1;
#line 57
  options___0->x11_forwarding = -1;
#line 58
  options___0->x11_display_offset = -1;
#line 59
  options___0->x11_use_localhost = -1;
#line 60
  options___0->xauth_location = (char *)((void *)0);
#line 61
  options___0->strict_modes = -1;
#line 62
  options___0->tcp_keep_alive = -1;
#line 63
  options___0->log_facility = -1;
#line 64
  options___0->log_level = -1;
#line 65
  options___0->rhosts_rsa_authentication = -1;
#line 66
  options___0->hostbased_authentication = -1;
#line 67
  options___0->hostbased_uses_name_from_packet_only = -1;
#line 68
  options___0->rsa_authentication = -1;
#line 69
  options___0->pubkey_authentication = -1;
#line 70
  options___0->kerberos_authentication = -1;
#line 71
  options___0->kerberos_or_local_passwd = -1;
#line 72
  options___0->kerberos_ticket_cleanup = -1;
#line 73
  options___0->kerberos_get_afs_token = -1;
#line 74
  options___0->gss_authentication = -1;
#line 75
  options___0->gss_cleanup_creds = -1;
#line 76
  options___0->password_authentication = -1;
#line 77
  options___0->kbd_interactive_authentication = -1;
#line 78
  options___0->challenge_response_authentication = -1;
#line 79
  options___0->permit_empty_passwd = -1;
#line 80
  options___0->permit_user_env = -1;
#line 81
  options___0->use_login = -1;
#line 82
  options___0->compression = -1;
#line 83
  options___0->allow_tcp_forwarding = -1;
#line 84
  options___0->num_allow_users = 0U;
#line 85
  options___0->num_deny_users = 0U;
#line 86
  options___0->num_allow_groups = 0U;
#line 87
  options___0->num_deny_groups = 0U;
#line 88
  options___0->ciphers = (char *)((void *)0);
#line 89
  options___0->macs = (char *)((void *)0);
#line 90
  options___0->protocol = 0;
#line 91
  options___0->gateway_ports = -1;
#line 92
  options___0->num_subsystems = 0U;
#line 93
  options___0->max_startups_begin = -1;
#line 94
  options___0->max_startups_rate = -1;
#line 95
  options___0->max_startups = -1;
#line 96
  options___0->max_authtries = -1;
#line 97
  options___0->banner = (char *)((void *)0);
#line 98
  options___0->use_dns = -1;
#line 99
  options___0->client_alive_interval = -1;
#line 100
  options___0->client_alive_count_max = -1;
#line 101
  options___0->authorized_keys_file = (char *)((void *)0);
#line 102
  options___0->authorized_keys_file2 = (char *)((void *)0);
#line 103
  options___0->num_accept_env = 0U;
#line 104
  options___0->permit_tun = -1;
#line 107
  use_privsep = -1;
#line 108
  return;
}
}
#line 110 "servconf.c"
void fill_default_server_options(ServerOptions *options___0 ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  u_int tmp___2 ;

  {
#line 114
  if (options___0->use_pam == -1) {
#line 115
    options___0->use_pam = 0;
  }
#line 118
  if (options___0->protocol == 0) {
#line 119
    options___0->protocol = 5;
  }
#line 120
  if (options___0->num_host_key_files == 0) {
#line 122
    if (options___0->protocol & 1) {
#line 123
      tmp = options___0->num_host_key_files;
#line 123
      (options___0->num_host_key_files) ++;
#line 123
      options___0->host_key_files[tmp] = (char *)"/usr/local/etc/ssh_host_key";
    }
#line 125
    if (options___0->protocol & 4) {
#line 126
      tmp___0 = options___0->num_host_key_files;
#line 126
      (options___0->num_host_key_files) ++;
#line 126
      options___0->host_key_files[tmp___0] = (char *)"/usr/local/etc/ssh_host_rsa_key";
#line 128
      tmp___1 = options___0->num_host_key_files;
#line 128
      (options___0->num_host_key_files) ++;
#line 128
      options___0->host_key_files[tmp___1] = (char *)"/usr/local/etc/ssh_host_dsa_key";
    }
  }
#line 132
  if (options___0->num_ports == 0U) {
#line 133
    tmp___2 = options___0->num_ports;
#line 133
    (options___0->num_ports) ++;
#line 133
    options___0->ports[tmp___2] = (unsigned short)22;
  }
#line 134
  if ((unsigned int )options___0->listen_addrs == (unsigned int )((void *)0)) {
#line 135
    add_listen_addr(options___0, (char *)((void *)0), (unsigned short)0);
  }
#line 136
  if ((unsigned int )options___0->pid_file == (unsigned int )((void *)0)) {
#line 137
    options___0->pid_file = (char *)"/var/run/sshd.pid";
  }
#line 138
  if (options___0->server_key_bits == -1) {
#line 139
    options___0->server_key_bits = 768;
  }
#line 140
  if (options___0->login_grace_time == -1) {
#line 141
    options___0->login_grace_time = 120;
  }
#line 142
  if (options___0->key_regeneration_time == -1) {
#line 143
    options___0->key_regeneration_time = 3600;
  }
#line 144
  if (options___0->permit_root_login == -1) {
#line 145
    options___0->permit_root_login = 3;
  }
#line 146
  if (options___0->ignore_rhosts == -1) {
#line 147
    options___0->ignore_rhosts = 1;
  }
#line 148
  if (options___0->ignore_user_known_hosts == -1) {
#line 149
    options___0->ignore_user_known_hosts = 0;
  }
#line 150
  if (options___0->print_motd == -1) {
#line 151
    options___0->print_motd = 1;
  }
#line 152
  if (options___0->print_lastlog == -1) {
#line 153
    options___0->print_lastlog = 1;
  }
#line 154
  if (options___0->x11_forwarding == -1) {
#line 155
    options___0->x11_forwarding = 0;
  }
#line 156
  if (options___0->x11_display_offset == -1) {
#line 157
    options___0->x11_display_offset = 10;
  }
#line 158
  if (options___0->x11_use_localhost == -1) {
#line 159
    options___0->x11_use_localhost = 1;
  }
#line 160
  if ((unsigned int )options___0->xauth_location == (unsigned int )((void *)0)) {
#line 161
    options___0->xauth_location = (char *)"/usr/bin//xauth";
  }
#line 162
  if (options___0->strict_modes == -1) {
#line 163
    options___0->strict_modes = 1;
  }
#line 164
  if (options___0->tcp_keep_alive == -1) {
#line 165
    options___0->tcp_keep_alive = 1;
  }
#line 166
  if ((int )options___0->log_facility == -1) {
#line 167
    options___0->log_facility = 2;
  }
#line 168
  if ((int )options___0->log_level == -1) {
#line 169
    options___0->log_level = 3;
  }
#line 170
  if (options___0->rhosts_rsa_authentication == -1) {
#line 171
    options___0->rhosts_rsa_authentication = 0;
  }
#line 172
  if (options___0->hostbased_authentication == -1) {
#line 173
    options___0->hostbased_authentication = 0;
  }
#line 174
  if (options___0->hostbased_uses_name_from_packet_only == -1) {
#line 175
    options___0->hostbased_uses_name_from_packet_only = 0;
  }
#line 176
  if (options___0->rsa_authentication == -1) {
#line 177
    options___0->rsa_authentication = 1;
  }
#line 178
  if (options___0->pubkey_authentication == -1) {
#line 179
    options___0->pubkey_authentication = 1;
  }
#line 180
  if (options___0->kerberos_authentication == -1) {
#line 181
    options___0->kerberos_authentication = 0;
  }
#line 182
  if (options___0->kerberos_or_local_passwd == -1) {
#line 183
    options___0->kerberos_or_local_passwd = 1;
  }
#line 184
  if (options___0->kerberos_ticket_cleanup == -1) {
#line 185
    options___0->kerberos_ticket_cleanup = 1;
  }
#line 186
  if (options___0->kerberos_get_afs_token == -1) {
#line 187
    options___0->kerberos_get_afs_token = 0;
  }
#line 188
  if (options___0->gss_authentication == -1) {
#line 189
    options___0->gss_authentication = 0;
  }
#line 190
  if (options___0->gss_cleanup_creds == -1) {
#line 191
    options___0->gss_cleanup_creds = 1;
  }
#line 192
  if (options___0->password_authentication == -1) {
#line 193
    options___0->password_authentication = 1;
  }
#line 194
  if (options___0->kbd_interactive_authentication == -1) {
#line 195
    options___0->kbd_interactive_authentication = 0;
  }
#line 196
  if (options___0->challenge_response_authentication == -1) {
#line 197
    options___0->challenge_response_authentication = 1;
  }
#line 198
  if (options___0->permit_empty_passwd == -1) {
#line 199
    options___0->permit_empty_passwd = 0;
  }
#line 200
  if (options___0->permit_user_env == -1) {
#line 201
    options___0->permit_user_env = 0;
  }
#line 202
  if (options___0->use_login == -1) {
#line 203
    options___0->use_login = 0;
  }
#line 204
  if (options___0->compression == -1) {
#line 205
    options___0->compression = 2;
  }
#line 206
  if (options___0->allow_tcp_forwarding == -1) {
#line 207
    options___0->allow_tcp_forwarding = 1;
  }
#line 208
  if (options___0->gateway_ports == -1) {
#line 209
    options___0->gateway_ports = 0;
  }
#line 210
  if (options___0->max_startups == -1) {
#line 211
    options___0->max_startups = 10;
  }
#line 212
  if (options___0->max_startups_rate == -1) {
#line 213
    options___0->max_startups_rate = 100;
  }
#line 214
  if (options___0->max_startups_begin == -1) {
#line 215
    options___0->max_startups_begin = options___0->max_startups;
  }
#line 216
  if (options___0->max_authtries == -1) {
#line 217
    options___0->max_authtries = 6;
  }
#line 218
  if (options___0->use_dns == -1) {
#line 219
    options___0->use_dns = 1;
  }
#line 220
  if (options___0->client_alive_interval == -1) {
#line 221
    options___0->client_alive_interval = 0;
  }
#line 222
  if (options___0->client_alive_count_max == -1) {
#line 223
    options___0->client_alive_count_max = 3;
  }
#line 224
  if ((unsigned int )options___0->authorized_keys_file2 == (unsigned int )((void *)0)) {
#line 226
    if ((unsigned int )options___0->authorized_keys_file != (unsigned int )((void *)0)) {
#line 227
      options___0->authorized_keys_file2 = options___0->authorized_keys_file;
    } else {
#line 229
      options___0->authorized_keys_file2 = (char *)".ssh/authorized_keys2";
    }
  }
#line 231
  if ((unsigned int )options___0->authorized_keys_file == (unsigned int )((void *)0)) {
#line 232
    options___0->authorized_keys_file = (char *)".ssh/authorized_keys";
  }
#line 233
  if (options___0->permit_tun == -1) {
#line 234
    options___0->permit_tun = 0;
  }
#line 237
  if (use_privsep == -1) {
#line 238
    use_privsep = 1;
  }
#line 249
  return;
}
}
#line 282 "servconf.c"
static struct __anonstruct_keywords_83 keywords[73]  = 
#line 282
  {      {"usepam", 64}, 
        {"pamauthenticationviakbdint", 63}, 
        {"port", 2}, 
        {"hostkey", 3}, 
        {"hostdsakey", 3}, 
        {"pidfile", 43}, 
        {"serverkeybits", 4}, 
        {"logingracetime", 5}, 
        {"keyregenerationinterval", 6}, 
        {"permitrootlogin", 7}, 
        {"syslogfacility", 8}, 
        {"loglevel", 9}, 
        {"rhostsauthentication", 63}, 
        {"rhostsrsaauthentication", 10}, 
        {"hostbasedauthentication", 52}, 
        {"hostbasedusesnamefrompacketonly", 53}, 
        {"rsaauthentication", 11}, 
        {"pubkeyauthentication", 45}, 
        {"dsaauthentication", 45}, 
        {"kerberosauthentication", 64}, 
        {"kerberosorlocalpasswd", 64}, 
        {"kerberosticketcleanup", 64}, 
        {"kerberosgetafstoken", 64}, 
        {"kerberostgtpassing", 64}, 
        {"afstokenpassing", 64}, 
        {"gssapiauthentication", 64}, 
        {"gssapicleanupcredentials", 64}, 
        {"passwordauthentication", 18}, 
        {"kbdinteractiveauthentication", 19}, 
        {"challengeresponseauthentication", 17}, 
        {"skeyauthentication", 17}, 
        {"checkmail", 63}, 
        {"listenaddress", 20}, 
        {"addressfamily", 21}, 
        {"printmotd", 22}, 
        {"printlastlog", 23}, 
        {"ignorerhosts", 24}, 
        {"ignoreuserknownhosts", 39}, 
        {"x11forwarding", 25}, 
        {"x11displayoffset", 26}, 
        {"x11uselocalhost", 27}, 
        {"xauthlocation", 46}, 
        {"strictmodes", 28}, 
        {"permitemptypasswords", 29}, 
        {"permituserenvironment", 31}, 
        {"uselogin", 32}, 
        {"compression", 34}, 
        {"tcpkeepalive", 30}, 
        {"keepalive", 30}, 
        {"allowtcpforwarding", 33}, 
        {"allowusers", 35}, 
        {"denyusers", 36}, 
        {"allowgroups", 37}, 
        {"denygroups", 38}, 
        {"ciphers", 40}, 
        {"macs", 41}, 
        {"protocol", 42}, 
        {"gatewayports", 44}, 
        {"subsystem", 47}, 
        {"maxstartups", 48}, 
        {"maxauthtries", 49}, 
        {"banner", 50}, 
        {"usedns", 51}, 
        {"verifyreversemapping", 63}, 
        {"reversemappingcheck", 63}, 
        {"clientaliveinterval", 54}, 
        {"clientalivecountmax", 55}, 
        {"authorizedkeysfile", 56}, 
        {"authorizedkeysfile2", 57}, 
        {"useprivilegeseparation", 62}, 
        {"acceptenv", 60}, 
        {"permittunnel", 61}, 
        {(char const   *)((void *)0), 0}};
#line 387 "servconf.c"
static ServerOpCodes parse_token(char const   *cp , char const   *filename , int linenum ) 
{ u_int i ;
  int tmp ;

  {
#line 393
  i = 0U;
#line 393
  while (keywords[i].name) {
#line 394
    tmp = strcasecmp(cp, keywords[i].name);
#line 394
    if (tmp == 0) {
#line 395
      return (keywords[i].opcode);
    }
#line 393
    i ++;
  }
#line 397
  error("%s: line %d: Bad configuration option: %s", filename, linenum, cp);
#line 399
  return (0);
}
}
#line 402 "servconf.c"
static void add_listen_addr(ServerOptions *options___0 , char *addr , u_short port___0 ) 
{ u_int i ;
  u_int tmp ;

  {
#line 407
  if (options___0->num_ports == 0U) {
#line 408
    tmp = options___0->num_ports;
#line 408
    (options___0->num_ports) ++;
#line 408
    options___0->ports[tmp] = (unsigned short)22;
  }
#line 409
  if (options___0->address_family == -1) {
#line 410
    options___0->address_family = 0;
  }
#line 411
  if ((int )port___0 == 0) {
#line 412
    i = 0U;
#line 412
    while (i < options___0->num_ports) {
#line 413
      add_one_listen_addr(options___0, addr, options___0->ports[i]);
#line 412
      i ++;
    }
  } else {
#line 415
    add_one_listen_addr(options___0, addr, port___0);
  }
#line 416
  return;
}
}
#line 418 "servconf.c"
static void add_one_listen_addr(ServerOptions *options___0 , char *addr , u_short port___0 ) 
{ struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 425
  memset((void *)(& hints), 0, sizeof(hints));
#line 426
  hints.ai_family = options___0->address_family;
#line 427
  hints.ai_socktype = 1;
#line 428
  if ((unsigned int )addr == (unsigned int )((void *)0)) {
#line 428
    hints.ai_flags = 1;
  } else {
#line 428
    hints.ai_flags = 0;
  }
#line 429
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%u",
           port___0);
#line 430
  gaierr = getaddrinfo((char const   * __restrict  )addr, (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 430
  if (gaierr != 0) {
#line 431
    tmp = gai_strerror(gaierr);
#line 431
    if (addr) {
#line 431
      tmp___0 = (char const   *)addr;
    } else {
#line 431
      tmp___0 = "<NULL>";
    }
#line 431
    fatal("bad addr or host: %s (%s)", tmp___0, tmp);
  }
#line 434
  ai = aitop;
#line 434
  while (ai->ai_next) {
#line 434
    ai = ai->ai_next;
  }
#line 436
  ai->ai_next = options___0->listen_addrs;
#line 437
  options___0->listen_addrs = aitop;
#line 438
  return;
}
}
#line 440 "servconf.c"
int process_server_config_line(ServerOptions *options___0 , char *line , char const   *filename ,
                               int linenum ) 
{ char *cp ;
  char **charptr ;
  char *arg ;
  char *p ;
  int *intptr ;
  int value ;
  int n___0 ;
  ServerOpCodes opcode ;
  u_short port___0 ;
  u_int i ;
  u_int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  char *tmp___3 ;
  char *tmp___5 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  __uid_t tmp___12 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___28 ;
  int tmp___31 ;
  int tmp___32 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___38 ;
  int tmp___41 ;
  int tmp___42 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___48 ;
  int tmp___51 ;
  int tmp___52 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___58 ;
  int tmp___61 ;
  int tmp___62 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___68 ;
  int tmp___71 ;
  int tmp___72 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___78 ;
  int tmp___81 ;
  int tmp___82 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___88 ;
  int tmp___91 ;
  int tmp___92 ;
  size_t __s1_len___7 ;
  size_t __s2_len___7 ;
  int tmp___98 ;
  int tmp___101 ;
  int tmp___102 ;
  size_t __s1_len___8 ;
  size_t __s2_len___8 ;
  int tmp___108 ;
  int tmp___111 ;
  int tmp___112 ;
  size_t __s1_len___9 ;
  size_t __s2_len___9 ;
  int tmp___118 ;
  int tmp___121 ;
  int tmp___122 ;
  size_t __s1_len___10 ;
  size_t __s2_len___10 ;
  int tmp___128 ;
  int tmp___131 ;
  int tmp___132 ;
  SyslogFacility tmp___133 ;
  char const   *tmp___134 ;
  LogLevel tmp___135 ;
  char const   *tmp___136 ;
  u_int tmp___137 ;
  u_int tmp___138 ;
  u_int tmp___139 ;
  u_int tmp___140 ;
  char const   *tmp___141 ;
  int tmp___142 ;
  char const   *tmp___143 ;
  int tmp___144 ;
  char const   *tmp___145 ;
  size_t __s1_len___11 ;
  size_t __s2_len___11 ;
  int tmp___151 ;
  int tmp___154 ;
  int tmp___155 ;
  char *tmp___157 ;
  u_int tmp___158 ;
  int tmp___159 ;
  int tmp___160 ;
  int tmp___161 ;
  int tmp___162 ;

  {
#line 450
  cp = line;
#line 451
  arg = strdelim(& cp);
#line 453
  if ((int )*arg == 0) {
#line 454
    arg = strdelim(& cp);
  }
#line 455
  if (! arg) {
#line 456
    return (0);
  } else {
#line 455
    if (! *arg) {
#line 456
      return (0);
    } else {
#line 455
      if ((int )*arg == 35) {
#line 456
        return (0);
      }
    }
  }
#line 457
  intptr = (int *)((void *)0);
#line 458
  charptr = (char **)((void *)0);
#line 459
  opcode = parse_token((char const   *)arg, filename, linenum);
#line 460
  switch ((int )opcode) {
  case 1: 
#line 463
  intptr = & options___0->use_pam;
  goto parse_flag;
  case 0: 
#line 468
  return (-1);
  case 2: 
#line 471
  if (options___0->ports_from_cmdline) {
#line 472
    return (0);
  }
#line 473
  if ((unsigned int )options___0->listen_addrs != (unsigned int )((void *)0)) {
#line 474
    fatal("%s line %d: ports must be specified before ListenAddress.", filename, linenum);
  }
#line 476
  if (options___0->num_ports >= 256U) {
#line 477
    fatal("%s line %d: too many ports.", filename, linenum);
  }
#line 479
  arg = strdelim(& cp);
#line 480
  if (! arg) {
#line 481
    fatal("%s line %d: missing port number.", filename, linenum);
  } else {
#line 480
    if ((int )*arg == 0) {
#line 481
      fatal("%s line %d: missing port number.", filename, linenum);
    }
  }
#line 483
  tmp = options___0->num_ports;
#line 483
  (options___0->num_ports) ++;
#line 483
  tmp___0 = a2port((char const   *)arg);
#line 483
  options___0->ports[tmp] = (unsigned short )tmp___0;
#line 484
  if ((int )options___0->ports[options___0->num_ports - 1U] == 0) {
#line 485
    fatal("%s line %d: Badly formatted port number.", filename, linenum);
  }
#line 487
  break;
  case 4: 
#line 490
  intptr = & options___0->server_key_bits;
  parse_int: 
#line 492
  arg = strdelim(& cp);
#line 493
  if (! arg) {
#line 494
    fatal("%s line %d: missing integer value.", filename, linenum);
  } else {
#line 493
    if ((int )*arg == 0) {
#line 494
      fatal("%s line %d: missing integer value.", filename, linenum);
    }
  }
#line 496
  value = atoi((char const   *)arg);
#line 497
  if (*intptr == -1) {
#line 498
    *intptr = value;
  }
#line 499
  break;
  case 5: 
#line 502
  intptr = & options___0->login_grace_time;
  parse_time: 
#line 504
  arg = strdelim(& cp);
#line 505
  if (! arg) {
#line 506
    fatal("%s line %d: missing time value.", filename, linenum);
  } else {
#line 505
    if ((int )*arg == 0) {
#line 506
      fatal("%s line %d: missing time value.", filename, linenum);
    }
  }
#line 508
  tmp___1 = convtime((char const   *)arg);
#line 508
  value = (int )tmp___1;
#line 508
  if (value == -1) {
#line 509
    fatal("%s line %d: invalid time value.", filename, linenum);
  }
#line 511
  if (*intptr == -1) {
#line 512
    *intptr = value;
  }
#line 513
  break;
  case 6: 
#line 516
  intptr = & options___0->key_regeneration_time;
  goto parse_time;
  case 20: 
#line 520
  arg = strdelim(& cp);
#line 521
  if ((unsigned int )arg == (unsigned int )((void *)0)) {
#line 522
    fatal("%s line %d: missing address", filename, linenum);
  } else {
#line 521
    if ((int )*arg == 0) {
#line 522
      fatal("%s line %d: missing address", filename, linenum);
    }
  }
#line 525
  tmp___3 = __builtin_strchr(arg, '[');
#line 525
  if ((unsigned int )tmp___3 == (unsigned int )((void *)0)) {
#line 525
    tmp___5 = __builtin_strchr(arg, ':');
#line 525
    p = tmp___5;
#line 525
    if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 525
      tmp___7 = __builtin_strchr(p + 1, ':');
#line 525
      if ((unsigned int )tmp___7 != (unsigned int )((void *)0)) {
#line 527
        add_listen_addr(options___0, arg, (unsigned short)0);
#line 528
        break;
      }
    }
  }
#line 530
  p = hpdelim(& arg);
#line 531
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 532
    fatal("%s line %d: bad address:port usage", filename, linenum);
  }
#line 534
  p = cleanhostname(p);
#line 535
  if ((unsigned int )arg == (unsigned int )((void *)0)) {
#line 536
    port___0 = (unsigned short)0;
  } else {
#line 537
    tmp___8 = a2port((char const   *)arg);
#line 537
    port___0 = (unsigned short )tmp___8;
#line 537
    if ((int )port___0 == 0) {
#line 538
      fatal("%s line %d: bad port number", filename, linenum);
    }
  }
#line 540
  add_listen_addr(options___0, p, port___0);
#line 542
  break;
  case 21: 
#line 545
  arg = strdelim(& cp);
#line 546
  if (! arg) {
#line 547
    fatal("%s line %d: missing address family.", filename, linenum);
  } else {
#line 546
    if ((int )*arg == 0) {
#line 547
      fatal("%s line %d: missing address family.", filename, linenum);
    }
  }
#line 549
  intptr = & options___0->address_family;
#line 550
  if ((unsigned int )options___0->listen_addrs != (unsigned int )((void *)0)) {
#line 551
    fatal("%s line %d: address family must be specified before ListenAddress.", filename,
          linenum);
  }
#line 553
  tmp___11 = strcasecmp((char const   *)arg, "inet");
#line 553
  if (tmp___11 == 0) {
#line 554
    value = 2;
  } else {
#line 555
    tmp___10 = strcasecmp((char const   *)arg, "inet6");
#line 555
    if (tmp___10 == 0) {
#line 556
      value = 10;
    } else {
#line 557
      tmp___9 = strcasecmp((char const   *)arg, "any");
#line 557
      if (tmp___9 == 0) {
#line 558
        value = 0;
      } else {
#line 560
        fatal("%s line %d: unsupported address family \"%s\".", filename, linenum,
              arg);
      }
    }
  }
#line 562
  if (*intptr == -1) {
#line 563
    *intptr = value;
  }
#line 564
  break;
  case 3: 
#line 567
  intptr = & options___0->num_host_key_files;
#line 568
  if (*intptr >= 256) {
#line 569
    fatal("%s line %d: too many host keys specified (max %d).", filename, linenum,
          256);
  }
#line 571
  charptr = & options___0->host_key_files[*intptr];
  parse_filename: 
#line 573
  arg = strdelim(& cp);
#line 574
  if (! arg) {
#line 575
    fatal("%s line %d: missing file name.", filename, linenum);
  } else {
#line 574
    if ((int )*arg == 0) {
#line 575
      fatal("%s line %d: missing file name.", filename, linenum);
    }
  }
#line 577
  if ((unsigned int )*charptr == (unsigned int )((void *)0)) {
#line 578
    tmp___12 = getuid();
#line 578
    *charptr = tilde_expand_filename((char const   *)arg, tmp___12);
#line 580
    if ((unsigned int )intptr != (unsigned int )((void *)0)) {
#line 581
      (*intptr) ++;
    }
  }
#line 583
  break;
  case 43: 
#line 586
  charptr = & options___0->pid_file;
  goto parse_filename;
  case 7: 
#line 590
  intptr = & options___0->permit_root_login;
#line 591
  arg = strdelim(& cp);
#line 592
  if (! arg) {
#line 593
    fatal("%s line %d: missing yes/without-password/forced-commands-only/no argument.",
          filename, linenum);
  } else {
#line 592
    if ((int )*arg == 0) {
#line 593
      fatal("%s line %d: missing yes/without-password/forced-commands-only/no argument.",
            filename, linenum);
    }
  }
#line 596
  value = 0;
#line 597
  if (0) {
#line 597
    __s1_len___2 = strlen((char const   *)arg);
#line 597
    __s2_len___2 = strlen("without-password");
#line 597
    if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
      goto _L___6;
    } else {
#line 597
      if (__s1_len___2 >= 4U) {
        _L___6: /* CIL Label */ 
#line 597
        if (! ((unsigned int )((void const   *)("without-password" + 1)) - (unsigned int )((void const   *)"without-password") == 1U)) {
#line 597
          tmp___52 = 1;
        } else {
#line 597
          if (__s2_len___2 >= 4U) {
#line 597
            tmp___52 = 1;
          } else {
#line 597
            tmp___52 = 0;
          }
        }
      } else {
#line 597
        tmp___52 = 0;
      }
    }
#line 597
    if (tmp___52) {
#line 597
      tmp___48 = __builtin_strcmp((char const   *)arg, "without-password");
    } else {
#line 597
      tmp___51 = __builtin_strcmp((char const   *)arg, "without-password");
#line 597
      tmp___48 = tmp___51;
    }
  } else {
#line 597
    tmp___51 = __builtin_strcmp((char const   *)arg, "without-password");
#line 597
    tmp___48 = tmp___51;
  }
#line 597
  if (tmp___48 == 0) {
#line 598
    value = 2;
  } else {
#line 599
    if (0) {
#line 599
      __s1_len___1 = strlen((char const   *)arg);
#line 599
      __s2_len___1 = strlen("forced-commands-only");
#line 599
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___4;
      } else {
#line 599
        if (__s1_len___1 >= 4U) {
          _L___4: /* CIL Label */ 
#line 599
          if (! ((unsigned int )((void const   *)("forced-commands-only" + 1)) - (unsigned int )((void const   *)"forced-commands-only") == 1U)) {
#line 599
            tmp___42 = 1;
          } else {
#line 599
            if (__s2_len___1 >= 4U) {
#line 599
              tmp___42 = 1;
            } else {
#line 599
              tmp___42 = 0;
            }
          }
        } else {
#line 599
          tmp___42 = 0;
        }
      }
#line 599
      if (tmp___42) {
#line 599
        tmp___38 = __builtin_strcmp((char const   *)arg, "forced-commands-only");
      } else {
#line 599
        tmp___41 = __builtin_strcmp((char const   *)arg, "forced-commands-only");
#line 599
        tmp___38 = tmp___41;
      }
    } else {
#line 599
      tmp___41 = __builtin_strcmp((char const   *)arg, "forced-commands-only");
#line 599
      tmp___38 = tmp___41;
    }
#line 599
    if (tmp___38 == 0) {
#line 600
      value = 1;
    } else {
#line 601
      if (0) {
#line 601
        __s1_len___0 = strlen((char const   *)arg);
#line 601
        __s2_len___0 = strlen("yes");
#line 601
        if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
          goto _L___2;
        } else {
#line 601
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 601
            if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 601
              tmp___32 = 1;
            } else {
#line 601
              if (__s2_len___0 >= 4U) {
#line 601
                tmp___32 = 1;
              } else {
#line 601
                tmp___32 = 0;
              }
            }
          } else {
#line 601
            tmp___32 = 0;
          }
        }
#line 601
        if (tmp___32) {
#line 601
          tmp___28 = __builtin_strcmp((char const   *)arg, "yes");
        } else {
#line 601
          tmp___31 = __builtin_strcmp((char const   *)arg, "yes");
#line 601
          tmp___28 = tmp___31;
        }
      } else {
#line 601
        tmp___31 = __builtin_strcmp((char const   *)arg, "yes");
#line 601
        tmp___28 = tmp___31;
      }
#line 601
      if (tmp___28 == 0) {
#line 602
        value = 3;
      } else {
#line 603
        if (0) {
#line 603
          __s1_len = strlen((char const   *)arg);
#line 603
          __s2_len = strlen("no");
#line 603
          if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
            goto _L___0;
          } else {
#line 603
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 603
              if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 603
                tmp___22 = 1;
              } else {
#line 603
                if (__s2_len >= 4U) {
#line 603
                  tmp___22 = 1;
                } else {
#line 603
                  tmp___22 = 0;
                }
              }
            } else {
#line 603
              tmp___22 = 0;
            }
          }
#line 603
          if (tmp___22) {
#line 603
            tmp___18 = __builtin_strcmp((char const   *)arg, "no");
          } else {
#line 603
            tmp___21 = __builtin_strcmp((char const   *)arg, "no");
#line 603
            tmp___18 = tmp___21;
          }
        } else {
#line 603
          tmp___21 = __builtin_strcmp((char const   *)arg, "no");
#line 603
          tmp___18 = tmp___21;
        }
#line 603
        if (tmp___18 == 0) {
#line 604
          value = 0;
        } else {
#line 606
          fatal("%s line %d: Bad yes/without-password/forced-commands-only/no argument: %s",
                filename, linenum, arg);
        }
      }
    }
  }
#line 609
  if (*intptr == -1) {
#line 610
    *intptr = value;
  }
#line 611
  break;
  case 24: 
#line 614
  intptr = & options___0->ignore_rhosts;
  parse_flag: 
#line 616
  arg = strdelim(& cp);
#line 617
  if (! arg) {
#line 618
    fatal("%s line %d: missing yes/no argument.", filename, linenum);
  } else {
#line 617
    if ((int )*arg == 0) {
#line 618
      fatal("%s line %d: missing yes/no argument.", filename, linenum);
    }
  }
#line 620
  value = 0;
#line 621
  if (0) {
#line 621
    __s1_len___4 = strlen((char const   *)arg);
#line 621
    __s2_len___4 = strlen("yes");
#line 621
    if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
      goto _L___10;
    } else {
#line 621
      if (__s1_len___4 >= 4U) {
        _L___10: /* CIL Label */ 
#line 621
        if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 621
          tmp___72 = 1;
        } else {
#line 621
          if (__s2_len___4 >= 4U) {
#line 621
            tmp___72 = 1;
          } else {
#line 621
            tmp___72 = 0;
          }
        }
      } else {
#line 621
        tmp___72 = 0;
      }
    }
#line 621
    if (tmp___72) {
#line 621
      tmp___68 = __builtin_strcmp((char const   *)arg, "yes");
    } else {
#line 621
      tmp___71 = __builtin_strcmp((char const   *)arg, "yes");
#line 621
      tmp___68 = tmp___71;
    }
  } else {
#line 621
    tmp___71 = __builtin_strcmp((char const   *)arg, "yes");
#line 621
    tmp___68 = tmp___71;
  }
#line 621
  if (tmp___68 == 0) {
#line 622
    value = 1;
  } else {
#line 623
    if (0) {
#line 623
      __s1_len___3 = strlen((char const   *)arg);
#line 623
      __s2_len___3 = strlen("no");
#line 623
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___8;
      } else {
#line 623
        if (__s1_len___3 >= 4U) {
          _L___8: /* CIL Label */ 
#line 623
          if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 623
            tmp___62 = 1;
          } else {
#line 623
            if (__s2_len___3 >= 4U) {
#line 623
              tmp___62 = 1;
            } else {
#line 623
              tmp___62 = 0;
            }
          }
        } else {
#line 623
          tmp___62 = 0;
        }
      }
#line 623
      if (tmp___62) {
#line 623
        tmp___58 = __builtin_strcmp((char const   *)arg, "no");
      } else {
#line 623
        tmp___61 = __builtin_strcmp((char const   *)arg, "no");
#line 623
        tmp___58 = tmp___61;
      }
    } else {
#line 623
      tmp___61 = __builtin_strcmp((char const   *)arg, "no");
#line 623
      tmp___58 = tmp___61;
    }
#line 623
    if (tmp___58 == 0) {
#line 624
      value = 0;
    } else {
#line 626
      fatal("%s line %d: Bad yes/no argument: %s", filename, linenum, arg);
    }
  }
#line 628
  if (*intptr == -1) {
#line 629
    *intptr = value;
  }
#line 630
  break;
  case 39: 
#line 633
  intptr = & options___0->ignore_user_known_hosts;
  goto parse_flag;
  case 10: 
#line 637
  intptr = & options___0->rhosts_rsa_authentication;
  goto parse_flag;
  case 52: 
#line 641
  intptr = & options___0->hostbased_authentication;
  goto parse_flag;
  case 53: 
#line 645
  intptr = & options___0->hostbased_uses_name_from_packet_only;
  goto parse_flag;
  case 11: 
#line 649
  intptr = & options___0->rsa_authentication;
  goto parse_flag;
  case 45: 
#line 653
  intptr = & options___0->pubkey_authentication;
  goto parse_flag;
  case 12: 
#line 657
  intptr = & options___0->kerberos_authentication;
  goto parse_flag;
  case 13: 
#line 661
  intptr = & options___0->kerberos_or_local_passwd;
  goto parse_flag;
  case 14: 
#line 665
  intptr = & options___0->kerberos_ticket_cleanup;
  goto parse_flag;
  case 15: 
#line 669
  intptr = & options___0->kerberos_get_afs_token;
  goto parse_flag;
  case 58: 
#line 673
  intptr = & options___0->gss_authentication;
  goto parse_flag;
  case 59: 
#line 677
  intptr = & options___0->gss_cleanup_creds;
  goto parse_flag;
  case 18: 
#line 681
  intptr = & options___0->password_authentication;
  goto parse_flag;
  case 19: 
#line 685
  intptr = & options___0->kbd_interactive_authentication;
  goto parse_flag;
  case 17: 
#line 689
  intptr = & options___0->challenge_response_authentication;
  goto parse_flag;
  case 22: 
#line 693
  intptr = & options___0->print_motd;
  goto parse_flag;
  case 23: 
#line 697
  intptr = & options___0->print_lastlog;
  goto parse_flag;
  case 25: 
#line 701
  intptr = & options___0->x11_forwarding;
  goto parse_flag;
  case 26: 
#line 705
  intptr = & options___0->x11_display_offset;
  goto parse_int;
  case 27: 
#line 709
  intptr = & options___0->x11_use_localhost;
  goto parse_flag;
  case 46: 
#line 713
  charptr = & options___0->xauth_location;
  goto parse_filename;
  case 28: 
#line 717
  intptr = & options___0->strict_modes;
  goto parse_flag;
  case 30: 
#line 721
  intptr = & options___0->tcp_keep_alive;
  goto parse_flag;
  case 29: 
#line 725
  intptr = & options___0->permit_empty_passwd;
  goto parse_flag;
  case 31: 
#line 729
  intptr = & options___0->permit_user_env;
  goto parse_flag;
  case 32: 
#line 733
  intptr = & options___0->use_login;
  goto parse_flag;
  case 34: 
#line 737
  intptr = & options___0->compression;
#line 738
  arg = strdelim(& cp);
#line 739
  if (! arg) {
#line 740
    fatal("%s line %d: missing yes/no/delayed argument.", filename, linenum);
  } else {
#line 739
    if ((int )*arg == 0) {
#line 740
      fatal("%s line %d: missing yes/no/delayed argument.", filename, linenum);
    }
  }
#line 742
  value = 0;
#line 743
  if (0) {
#line 743
    __s1_len___7 = strlen((char const   *)arg);
#line 743
    __s2_len___7 = strlen("delayed");
#line 743
    if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
      goto _L___16;
    } else {
#line 743
      if (__s1_len___7 >= 4U) {
        _L___16: /* CIL Label */ 
#line 743
        if (! ((unsigned int )((void const   *)("delayed" + 1)) - (unsigned int )((void const   *)"delayed") == 1U)) {
#line 743
          tmp___102 = 1;
        } else {
#line 743
          if (__s2_len___7 >= 4U) {
#line 743
            tmp___102 = 1;
          } else {
#line 743
            tmp___102 = 0;
          }
        }
      } else {
#line 743
        tmp___102 = 0;
      }
    }
#line 743
    if (tmp___102) {
#line 743
      tmp___98 = __builtin_strcmp((char const   *)arg, "delayed");
    } else {
#line 743
      tmp___101 = __builtin_strcmp((char const   *)arg, "delayed");
#line 743
      tmp___98 = tmp___101;
    }
  } else {
#line 743
    tmp___101 = __builtin_strcmp((char const   *)arg, "delayed");
#line 743
    tmp___98 = tmp___101;
  }
#line 743
  if (tmp___98 == 0) {
#line 744
    value = 2;
  } else {
#line 745
    if (0) {
#line 745
      __s1_len___6 = strlen((char const   *)arg);
#line 745
      __s2_len___6 = strlen("yes");
#line 745
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___14;
      } else {
#line 745
        if (__s1_len___6 >= 4U) {
          _L___14: /* CIL Label */ 
#line 745
          if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 745
            tmp___92 = 1;
          } else {
#line 745
            if (__s2_len___6 >= 4U) {
#line 745
              tmp___92 = 1;
            } else {
#line 745
              tmp___92 = 0;
            }
          }
        } else {
#line 745
          tmp___92 = 0;
        }
      }
#line 745
      if (tmp___92) {
#line 745
        tmp___88 = __builtin_strcmp((char const   *)arg, "yes");
      } else {
#line 745
        tmp___91 = __builtin_strcmp((char const   *)arg, "yes");
#line 745
        tmp___88 = tmp___91;
      }
    } else {
#line 745
      tmp___91 = __builtin_strcmp((char const   *)arg, "yes");
#line 745
      tmp___88 = tmp___91;
    }
#line 745
    if (tmp___88 == 0) {
#line 746
      value = 1;
    } else {
#line 747
      if (0) {
#line 747
        __s1_len___5 = strlen((char const   *)arg);
#line 747
        __s2_len___5 = strlen("no");
#line 747
        if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
          goto _L___12;
        } else {
#line 747
          if (__s1_len___5 >= 4U) {
            _L___12: /* CIL Label */ 
#line 747
            if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 747
              tmp___82 = 1;
            } else {
#line 747
              if (__s2_len___5 >= 4U) {
#line 747
                tmp___82 = 1;
              } else {
#line 747
                tmp___82 = 0;
              }
            }
          } else {
#line 747
            tmp___82 = 0;
          }
        }
#line 747
        if (tmp___82) {
#line 747
          tmp___78 = __builtin_strcmp((char const   *)arg, "no");
        } else {
#line 747
          tmp___81 = __builtin_strcmp((char const   *)arg, "no");
#line 747
          tmp___78 = tmp___81;
        }
      } else {
#line 747
        tmp___81 = __builtin_strcmp((char const   *)arg, "no");
#line 747
        tmp___78 = tmp___81;
      }
#line 747
      if (tmp___78 == 0) {
#line 748
        value = 0;
      } else {
#line 750
        fatal("%s line %d: Bad yes/no/delayed argument: %s", filename, linenum, arg);
      }
    }
  }
#line 752
  if (*intptr == -1) {
#line 753
    *intptr = value;
  }
#line 754
  break;
  case 44: 
#line 757
  intptr = & options___0->gateway_ports;
#line 758
  arg = strdelim(& cp);
#line 759
  if (! arg) {
#line 760
    fatal("%s line %d: missing yes/no/clientspecified argument.", filename, linenum);
  } else {
#line 759
    if ((int )*arg == 0) {
#line 760
      fatal("%s line %d: missing yes/no/clientspecified argument.", filename, linenum);
    }
  }
#line 762
  value = 0;
#line 763
  if (0) {
#line 763
    __s1_len___10 = strlen((char const   *)arg);
#line 763
    __s2_len___10 = strlen("clientspecified");
#line 763
    if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
      goto _L___22;
    } else {
#line 763
      if (__s1_len___10 >= 4U) {
        _L___22: /* CIL Label */ 
#line 763
        if (! ((unsigned int )((void const   *)("clientspecified" + 1)) - (unsigned int )((void const   *)"clientspecified") == 1U)) {
#line 763
          tmp___132 = 1;
        } else {
#line 763
          if (__s2_len___10 >= 4U) {
#line 763
            tmp___132 = 1;
          } else {
#line 763
            tmp___132 = 0;
          }
        }
      } else {
#line 763
        tmp___132 = 0;
      }
    }
#line 763
    if (tmp___132) {
#line 763
      tmp___128 = __builtin_strcmp((char const   *)arg, "clientspecified");
    } else {
#line 763
      tmp___131 = __builtin_strcmp((char const   *)arg, "clientspecified");
#line 763
      tmp___128 = tmp___131;
    }
  } else {
#line 763
    tmp___131 = __builtin_strcmp((char const   *)arg, "clientspecified");
#line 763
    tmp___128 = tmp___131;
  }
#line 763
  if (tmp___128 == 0) {
#line 764
    value = 2;
  } else {
#line 765
    if (0) {
#line 765
      __s1_len___9 = strlen((char const   *)arg);
#line 765
      __s2_len___9 = strlen("yes");
#line 765
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___20;
      } else {
#line 765
        if (__s1_len___9 >= 4U) {
          _L___20: /* CIL Label */ 
#line 765
          if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 765
            tmp___122 = 1;
          } else {
#line 765
            if (__s2_len___9 >= 4U) {
#line 765
              tmp___122 = 1;
            } else {
#line 765
              tmp___122 = 0;
            }
          }
        } else {
#line 765
          tmp___122 = 0;
        }
      }
#line 765
      if (tmp___122) {
#line 765
        tmp___118 = __builtin_strcmp((char const   *)arg, "yes");
      } else {
#line 765
        tmp___121 = __builtin_strcmp((char const   *)arg, "yes");
#line 765
        tmp___118 = tmp___121;
      }
    } else {
#line 765
      tmp___121 = __builtin_strcmp((char const   *)arg, "yes");
#line 765
      tmp___118 = tmp___121;
    }
#line 765
    if (tmp___118 == 0) {
#line 766
      value = 1;
    } else {
#line 767
      if (0) {
#line 767
        __s1_len___8 = strlen((char const   *)arg);
#line 767
        __s2_len___8 = strlen("no");
#line 767
        if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
          goto _L___18;
        } else {
#line 767
          if (__s1_len___8 >= 4U) {
            _L___18: /* CIL Label */ 
#line 767
            if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 767
              tmp___112 = 1;
            } else {
#line 767
              if (__s2_len___8 >= 4U) {
#line 767
                tmp___112 = 1;
              } else {
#line 767
                tmp___112 = 0;
              }
            }
          } else {
#line 767
            tmp___112 = 0;
          }
        }
#line 767
        if (tmp___112) {
#line 767
          tmp___108 = __builtin_strcmp((char const   *)arg, "no");
        } else {
#line 767
          tmp___111 = __builtin_strcmp((char const   *)arg, "no");
#line 767
          tmp___108 = tmp___111;
        }
      } else {
#line 767
        tmp___111 = __builtin_strcmp((char const   *)arg, "no");
#line 767
        tmp___108 = tmp___111;
      }
#line 767
      if (tmp___108 == 0) {
#line 768
        value = 0;
      } else {
#line 770
        fatal("%s line %d: Bad yes/no/clientspecified argument: %s", filename, linenum,
              arg);
      }
    }
  }
#line 772
  if (*intptr == -1) {
#line 773
    *intptr = value;
  }
#line 774
  break;
  case 51: 
#line 777
  intptr = & options___0->use_dns;
  goto parse_flag;
  case 8: 
#line 781
  intptr = (int *)(& options___0->log_facility);
#line 782
  arg = strdelim(& cp);
#line 783
  tmp___133 = log_facility_number(arg);
#line 783
  value = (int )tmp___133;
#line 784
  if (value == -1) {
#line 785
    if (arg) {
#line 785
      tmp___134 = (char const   *)arg;
    } else {
#line 785
      tmp___134 = "<NONE>";
    }
#line 785
    fatal("%.200s line %d: unsupported log facility \'%s\'", filename, linenum, tmp___134);
  }
#line 787
  if (*intptr == -1) {
#line 788
    *intptr = (int )((enum __anonenum_SyslogFacility_75 )value);
  }
#line 789
  break;
  case 9: 
#line 792
  intptr = (int *)(& options___0->log_level);
#line 793
  arg = strdelim(& cp);
#line 794
  tmp___135 = log_level_number(arg);
#line 794
  value = (int )tmp___135;
#line 795
  if (value == -1) {
#line 796
    if (arg) {
#line 796
      tmp___136 = (char const   *)arg;
    } else {
#line 796
      tmp___136 = "<NONE>";
    }
#line 796
    fatal("%.200s line %d: unsupported log level \'%s\'", filename, linenum, tmp___136);
  }
#line 798
  if (*intptr == -1) {
#line 799
    *intptr = (int )((enum __anonenum_LogLevel_76 )value);
  }
#line 800
  break;
  case 33: 
#line 803
  intptr = & options___0->allow_tcp_forwarding;
  goto parse_flag;
  case 62: 
#line 807
  intptr = & use_privsep;
  goto parse_flag;
  case 35: 
#line 811
  while (1) {
#line 811
    arg = strdelim(& cp);
#line 811
    if (arg) {
#line 811
      if (! ((int )*arg != 0)) {
#line 811
        break;
      }
    } else {
#line 811
      break;
    }
#line 812
    if (options___0->num_allow_users >= 256U) {
#line 813
      fatal("%s line %d: too many allow users.", filename, linenum);
    }
#line 815
    tmp___137 = options___0->num_allow_users;
#line 815
    (options___0->num_allow_users) ++;
#line 815
    options___0->allow_users[tmp___137] = xstrdup((char const   *)arg);
  }
#line 818
  break;
  case 36: 
#line 821
  while (1) {
#line 821
    arg = strdelim(& cp);
#line 821
    if (arg) {
#line 821
      if (! ((int )*arg != 0)) {
#line 821
        break;
      }
    } else {
#line 821
      break;
    }
#line 822
    if (options___0->num_deny_users >= 256U) {
#line 823
      fatal("%s line %d: too many deny users.", filename, linenum);
    }
#line 825
    tmp___138 = options___0->num_deny_users;
#line 825
    (options___0->num_deny_users) ++;
#line 825
    options___0->deny_users[tmp___138] = xstrdup((char const   *)arg);
  }
#line 828
  break;
  case 37: 
#line 831
  while (1) {
#line 831
    arg = strdelim(& cp);
#line 831
    if (arg) {
#line 831
      if (! ((int )*arg != 0)) {
#line 831
        break;
      }
    } else {
#line 831
      break;
    }
#line 832
    if (options___0->num_allow_groups >= 256U) {
#line 833
      fatal("%s line %d: too many allow groups.", filename, linenum);
    }
#line 835
    tmp___139 = options___0->num_allow_groups;
#line 835
    (options___0->num_allow_groups) ++;
#line 835
    options___0->allow_groups[tmp___139] = xstrdup((char const   *)arg);
  }
#line 838
  break;
  case 38: 
#line 841
  while (1) {
#line 841
    arg = strdelim(& cp);
#line 841
    if (arg) {
#line 841
      if (! ((int )*arg != 0)) {
#line 841
        break;
      }
    } else {
#line 841
      break;
    }
#line 842
    if (options___0->num_deny_groups >= 256U) {
#line 843
      fatal("%s line %d: too many deny groups.", filename, linenum);
    }
#line 845
    tmp___140 = options___0->num_deny_groups;
#line 845
    (options___0->num_deny_groups) ++;
#line 845
    options___0->deny_groups[tmp___140] = xstrdup((char const   *)arg);
  }
#line 847
  break;
  case 40: 
#line 850
  arg = strdelim(& cp);
#line 851
  if (! arg) {
#line 852
    fatal("%s line %d: Missing argument.", filename, linenum);
  } else {
#line 851
    if ((int )*arg == 0) {
#line 852
      fatal("%s line %d: Missing argument.", filename, linenum);
    }
  }
#line 853
  tmp___142 = ciphers_valid((char const   *)arg);
#line 853
  if (! tmp___142) {
#line 854
    if (arg) {
#line 854
      tmp___141 = (char const   *)arg;
    } else {
#line 854
      tmp___141 = "<NONE>";
    }
#line 854
    fatal("%s line %d: Bad SSH2 cipher spec \'%s\'.", filename, linenum, tmp___141);
  }
#line 856
  if ((unsigned int )options___0->ciphers == (unsigned int )((void *)0)) {
#line 857
    options___0->ciphers = xstrdup((char const   *)arg);
  }
#line 858
  break;
  case 41: 
#line 861
  arg = strdelim(& cp);
#line 862
  if (! arg) {
#line 863
    fatal("%s line %d: Missing argument.", filename, linenum);
  } else {
#line 862
    if ((int )*arg == 0) {
#line 863
      fatal("%s line %d: Missing argument.", filename, linenum);
    }
  }
#line 864
  tmp___144 = mac_valid((char const   *)arg);
#line 864
  if (! tmp___144) {
#line 865
    if (arg) {
#line 865
      tmp___143 = (char const   *)arg;
    } else {
#line 865
      tmp___143 = "<NONE>";
    }
#line 865
    fatal("%s line %d: Bad SSH2 mac spec \'%s\'.", filename, linenum, tmp___143);
  }
#line 867
  if ((unsigned int )options___0->macs == (unsigned int )((void *)0)) {
#line 868
    options___0->macs = xstrdup((char const   *)arg);
  }
#line 869
  break;
  case 42: 
#line 872
  intptr = & options___0->protocol;
#line 873
  arg = strdelim(& cp);
#line 874
  if (! arg) {
#line 875
    fatal("%s line %d: Missing argument.", filename, linenum);
  } else {
#line 874
    if ((int )*arg == 0) {
#line 875
      fatal("%s line %d: Missing argument.", filename, linenum);
    }
  }
#line 876
  value = proto_spec((char const   *)arg);
#line 877
  if (value == 0) {
#line 878
    if (arg) {
#line 878
      tmp___145 = (char const   *)arg;
    } else {
#line 878
      tmp___145 = "<NONE>";
    }
#line 878
    fatal("%s line %d: Bad protocol spec \'%s\'.", filename, linenum, tmp___145);
  }
#line 880
  if (*intptr == 0) {
#line 881
    *intptr = value;
  }
#line 882
  break;
  case 47: 
#line 885
  if (options___0->num_subsystems >= 256U) {
#line 886
    fatal("%s line %d: too many subsystems defined.", filename, linenum);
  }
#line 889
  arg = strdelim(& cp);
#line 890
  if (! arg) {
#line 891
    fatal("%s line %d: Missing subsystem name.", filename, linenum);
  } else {
#line 890
    if ((int )*arg == 0) {
#line 891
      fatal("%s line %d: Missing subsystem name.", filename, linenum);
    }
  }
#line 893
  i = 0U;
#line 893
  while (i < options___0->num_subsystems) {
#line 894
    if (0) {
#line 894
      __s1_len___11 = strlen((char const   *)arg);
#line 894
      __s2_len___11 = strlen((char const   *)options___0->subsystem_name[i]);
#line 894
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___24;
      } else {
#line 894
        if (__s1_len___11 >= 4U) {
          _L___24: /* CIL Label */ 
#line 894
          if (! ((unsigned int )((void const   *)(options___0->subsystem_name[i] + 1)) - (unsigned int )((void const   *)options___0->subsystem_name[i]) == 1U)) {
#line 894
            tmp___155 = 1;
          } else {
#line 894
            if (__s2_len___11 >= 4U) {
#line 894
              tmp___155 = 1;
            } else {
#line 894
              tmp___155 = 0;
            }
          }
        } else {
#line 894
          tmp___155 = 0;
        }
      }
#line 894
      if (tmp___155) {
#line 894
        tmp___151 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
      } else {
#line 894
        tmp___154 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
#line 894
        tmp___151 = tmp___154;
      }
    } else {
#line 894
      tmp___154 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
#line 894
      tmp___151 = tmp___154;
    }
#line 894
    if (tmp___151 == 0) {
#line 895
      fatal("%s line %d: Subsystem \'%s\' already defined.", filename, linenum, arg);
    }
#line 893
    i ++;
  }
#line 897
  options___0->subsystem_name[options___0->num_subsystems] = xstrdup((char const   *)arg);
#line 898
  arg = strdelim(& cp);
#line 899
  if (! arg) {
#line 900
    fatal("%s line %d: Missing subsystem command.", filename, linenum);
  } else {
#line 899
    if ((int )*arg == 0) {
#line 900
      fatal("%s line %d: Missing subsystem command.", filename, linenum);
    }
  }
#line 902
  options___0->subsystem_command[options___0->num_subsystems] = xstrdup((char const   *)arg);
#line 903
  (options___0->num_subsystems) ++;
#line 904
  break;
  case 48: 
#line 907
  arg = strdelim(& cp);
#line 908
  if (! arg) {
#line 909
    fatal("%s line %d: Missing MaxStartups spec.", filename, linenum);
  } else {
#line 908
    if ((int )*arg == 0) {
#line 909
      fatal("%s line %d: Missing MaxStartups spec.", filename, linenum);
    }
  }
#line 911
  n___0 = sscanf((char const   * __restrict  )arg, (char const   * __restrict  )"%d:%d:%d",
                 & options___0->max_startups_begin, & options___0->max_startups_rate,
                 & options___0->max_startups);
#line 911
  if (n___0 == 3) {
#line 915
    if (options___0->max_startups_begin > options___0->max_startups) {
#line 919
      fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
    } else {
#line 915
      if (options___0->max_startups_rate > 100) {
#line 919
        fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
      } else {
#line 915
        if (options___0->max_startups_rate < 1) {
#line 919
          fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
        }
      }
    }
  } else {
#line 921
    if (n___0 != 1) {
#line 922
      fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
    } else {
#line 925
      options___0->max_startups = options___0->max_startups_begin;
    }
  }
#line 926
  break;
  case 49: 
#line 929
  intptr = & options___0->max_authtries;
  goto parse_int;
  case 50: 
#line 933
  charptr = & options___0->banner;
  goto parse_filename;
  case 56: 
  case 57: 
#line 943
  if ((int )opcode == 56) {
#line 943
    charptr = & options___0->authorized_keys_file;
  } else {
#line 943
    charptr = & options___0->authorized_keys_file2;
  }
  goto parse_filename;
  case 54: 
#line 949
  intptr = & options___0->client_alive_interval;
  goto parse_time;
  case 55: 
#line 953
  intptr = & options___0->client_alive_count_max;
  goto parse_int;
  case 60: 
#line 957
  while (1) {
#line 957
    arg = strdelim(& cp);
#line 957
    if (arg) {
#line 957
      if (! ((int )*arg != 0)) {
#line 957
        break;
      }
    } else {
#line 957
      break;
    }
#line 958
    tmp___157 = __builtin_strchr(arg, '=');
#line 958
    if ((unsigned int )tmp___157 != (unsigned int )((void *)0)) {
#line 959
      fatal("%s line %d: Invalid environment name.", filename, linenum);
    }
#line 961
    if (options___0->num_accept_env >= 256U) {
#line 962
      fatal("%s line %d: too many allow env.", filename, linenum);
    }
#line 964
    tmp___158 = options___0->num_accept_env;
#line 964
    (options___0->num_accept_env) ++;
#line 964
    options___0->accept_env[tmp___158] = xstrdup((char const   *)arg);
  }
#line 967
  break;
  case 61: 
#line 970
  intptr = & options___0->permit_tun;
#line 971
  arg = strdelim(& cp);
#line 972
  if (! arg) {
#line 973
    fatal("%s line %d: Missing yes/point-to-point/ethernet/no argument.", filename,
          linenum);
  } else {
#line 972
    if ((int )*arg == 0) {
#line 973
      fatal("%s line %d: Missing yes/point-to-point/ethernet/no argument.", filename,
            linenum);
    }
  }
#line 975
  value = 0;
#line 976
  tmp___162 = strcasecmp((char const   *)arg, "ethernet");
#line 976
  if (tmp___162 == 0) {
#line 977
    value = 2;
  } else {
#line 978
    tmp___161 = strcasecmp((char const   *)arg, "point-to-point");
#line 978
    if (tmp___161 == 0) {
#line 979
      value = 1;
    } else {
#line 980
      tmp___160 = strcasecmp((char const   *)arg, "yes");
#line 980
      if (tmp___160 == 0) {
#line 981
        value = 3;
      } else {
#line 982
        tmp___159 = strcasecmp((char const   *)arg, "no");
#line 982
        if (tmp___159 == 0) {
#line 983
          value = 0;
        } else {
#line 985
          fatal("%s line %d: Bad yes/point-to-point/ethernet/no argument: %s", filename,
                linenum, arg);
        }
      }
    }
  }
#line 987
  if (*intptr == -1) {
#line 988
    *intptr = value;
  }
#line 989
  break;
  case 63: 
#line 992
  logit("%s line %d: Deprecated option %s", filename, linenum, arg);
#line 994
  while (arg) {
#line 995
    arg = strdelim(& cp);
  }
#line 996
  break;
  case 64: 
#line 999
  logit("%s line %d: Unsupported option %s", filename, linenum, arg);
#line 1001
  while (arg) {
#line 1002
    arg = strdelim(& cp);
  }
#line 1003
  break;
  default: 
#line 1006
  fatal("%s line %d: Missing handler for opcode %s (%d)", filename, linenum, arg,
        opcode);
  }
#line 1009
  arg = strdelim(& cp);
#line 1009
  if ((unsigned int )arg != (unsigned int )((void *)0)) {
#line 1009
    if ((int )*arg != 0) {
#line 1010
      fatal("%s line %d: garbage at end of line; \"%.200s\".", filename, linenum,
            arg);
    }
  }
#line 1012
  return (0);
}
}
#line 1017 "servconf.c"
void load_server_config(char const   *filename , Buffer *conf ) 
{ char line[1024] ;
  char *cp ;
  FILE *f ;
  char *tmp___0 ;
  unsigned int tmp___32 ;
  size_t tmp___33 ;
  char *tmp___34 ;
  u_int tmp___35 ;

  {
#line 1023
  debug2("%s: filename %s", "load_server_config", filename);
#line 1024
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 1024
  if ((unsigned int )f == (unsigned int )((void *)0)) {
#line 1025
    perror(filename);
#line 1026
    exit(1);
  }
#line 1028
  buffer_clear(conf);
#line 1029
  while (1) {
#line 1029
    tmp___34 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 1029
    if (! tmp___34) {
#line 1029
      break;
    }
#line 1035
    tmp___0 = __builtin_strchr(line, '#');
#line 1035
    cp = tmp___0;
#line 1035
    if ((unsigned int )cp != (unsigned int )((void *)0)) {
#line 1036
      memcpy((void * __restrict  )cp, (void const   * __restrict  )"\n", 2U);
    }
#line 1037
    tmp___32 = __builtin_strspn((char const   *)(line), " \t\r");
#line 1037
    cp = line + tmp___32;
#line 1039
    tmp___33 = strlen((char const   *)cp);
#line 1039
    buffer_append(conf, (void const   *)cp, tmp___33);
  }
#line 1041
  buffer_append(conf, (void const   *)"\000", 1U);
#line 1042
  fclose(f);
#line 1043
  tmp___35 = buffer_len(conf);
#line 1043
  debug2("%s: done config len = %d", "load_server_config", tmp___35);
#line 1044
  return;
}
}
#line 1046 "servconf.c"
void parse_server_config(ServerOptions *options___0 , char const   *filename , Buffer *conf ) 
{ int linenum ;
  int bad_options ;
  char *cp ;
  char *obuf ;
  char *cbuf ;
  u_int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___18 ;

  {
#line 1049
  bad_options = 0;
#line 1052
  tmp = buffer_len(conf);
#line 1052
  debug2("%s: config %s len %d", "parse_server_config", filename, tmp);
#line 1054
  tmp___0 = buffer_ptr(conf);
#line 1054
  cbuf = xstrdup((char const   *)tmp___0);
#line 1054
  obuf = cbuf;
#line 1055
  linenum = 1;
#line 1056
  while (1) {
#line 1056
    tmp___18 = __strsep_g(& cbuf, "\n");
#line 1056
    cp = tmp___18;
#line 1056
    if (! ((unsigned int )cp != (unsigned int )((void *)0))) {
#line 1056
      break;
    }
#line 1057
    tmp___1 = linenum;
#line 1057
    linenum ++;
#line 1057
    tmp___2 = process_server_config_line(options___0, cp, filename, tmp___1);
#line 1057
    if (tmp___2 != 0) {
#line 1059
      bad_options ++;
    }
  }
#line 1061
  xfree((void *)obuf);
#line 1062
  if (bad_options > 0) {
#line 1063
    fatal("%s: terminating, %d bad configuration options", filename, bad_options);
  }
#line 1065
  return;
}
}
#line 1 "serverloop.o"
#line 222 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo )  __attribute__((__nonnull__(1))) ;
#line 249
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
#line 64 "session.h"
int session_open(Authctxt *authctxt___0 , int chanid ) ;
#line 65
int session_input_channel_req(Channel *c , char const   *rtype ) ;
#line 66
void session_close_by_pid(pid_t pid , int status ) ;
#line 67
void session_close_by_channel(int id , void *arg ) ;
#line 68
void session_destroy_all(void (*closefunc)(Session * ) ) ;
#line 31 "auth-options.h"
int forced_tun_device ;
#line 24 "serverloop.h"
void server_loop(pid_t pid , int fdin_arg , int fdout_arg , int fderr_arg ) ;
#line 25
void server_loop2(Authctxt *authctxt___0 ) ;
#line 66 "serverloop.c"
static Buffer stdin_buffer  ;
#line 67 "serverloop.c"
static Buffer stdout_buffer  ;
#line 68 "serverloop.c"
static Buffer stderr_buffer  ;
#line 69 "serverloop.c"
static int fdin  ;
#line 70 "serverloop.c"
static int fdout  ;
#line 72 "serverloop.c"
static int fderr  ;
#line 73 "serverloop.c"
static long stdin_bytes  =    0L;
#line 74 "serverloop.c"
static long stdout_bytes  =    0L;
#line 75 "serverloop.c"
static long stderr_bytes  =    0L;
#line 76 "serverloop.c"
static long fdout_bytes  =    0L;
#line 77 "serverloop.c"
static int stdin_eof  =    0;
#line 78 "serverloop.c"
static int fdout_eof  =    0;
#line 79 "serverloop.c"
static int fderr_eof  =    0;
#line 80 "serverloop.c"
static int fdin_is_tty  =    0;
#line 81 "serverloop.c"
static int connection_in___0  ;
#line 82 "serverloop.c"
static int connection_out___0  ;
#line 83 "serverloop.c"
static int connection_closed  =    0;
#line 84 "serverloop.c"
static u_int buffer_high  ;
#line 85 "serverloop.c"
static int client_alive_timeouts  =    0;
#line 92 "serverloop.c"
static int volatile   child_terminated  =    (sig_atomic_t volatile   )0;
#line 95 "serverloop.c"
static int volatile   received_sigterm___0  =    (sig_atomic_t volatile   )0;
#line 98
static void server_init_dispatch(void) ;
#line 104 "serverloop.c"
static int notify_pipe[2]  ;
#line 105 "serverloop.c"
static void notify_setup(void) 
{ int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 108
  tmp___5 = pipe((int *)(notify_pipe));
#line 108
  if (tmp___5 < 0) {
#line 109
    tmp = __errno_location();
#line 109
    tmp___0 = strerror(*tmp);
#line 109
    error("pipe(notify_pipe) failed %s", tmp___0);
  } else {
#line 110
    tmp___3 = fcntl(notify_pipe[0], 2, 1);
#line 110
    if (tmp___3 == -1) {
#line 112
      tmp___1 = __errno_location();
#line 112
      tmp___2 = strerror(*tmp___1);
#line 112
      error("fcntl(notify_pipe, F_SETFD) failed %s", tmp___2);
#line 113
      close(notify_pipe[0]);
#line 114
      close(notify_pipe[1]);
    } else {
#line 110
      tmp___4 = fcntl(notify_pipe[1], 2, 1);
#line 110
      if (tmp___4 == -1) {
#line 112
        tmp___1 = __errno_location();
#line 112
        tmp___2 = strerror(*tmp___1);
#line 112
        error("fcntl(notify_pipe, F_SETFD) failed %s", tmp___2);
#line 113
        close(notify_pipe[0]);
#line 114
        close(notify_pipe[1]);
      } else {
#line 116
        set_nonblock(notify_pipe[0]);
#line 117
        set_nonblock(notify_pipe[1]);
#line 118
        return;
      }
    }
  }
#line 120
  notify_pipe[0] = -1;
#line 121
  notify_pipe[1] = -1;
#line 122
  return;
}
}
#line 123 "serverloop.c"
static void notify_parent(void) 
{ 

  {
#line 126
  if (notify_pipe[1] != -1) {
#line 127
    write(notify_pipe[1], (void const   *)"", 1U);
  }
#line 128
  return;
}
}
#line 129 "serverloop.c"
static void notify_prepare(fd_set *readset ) 
{ 

  {
#line 132
  if (notify_pipe[0] != -1) {
#line 133
    __asm__  volatile   ("btsl %1,%0": "=m" (readset->fds_bits[(unsigned int )notify_pipe[0] / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )notify_pipe[0] % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 134
  return;
}
}
#line 135 "serverloop.c"
static void notify_done(fd_set *readset ) 
{ char c ;
  ssize_t tmp ;
  register char __result ;

  {
#line 140
  if (notify_pipe[0] != -1) {
#line 140
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )notify_pipe[0] % (8U * sizeof(__fd_mask ))),
                         "m" (readset->fds_bits[(unsigned int )notify_pipe[0] / (8U * sizeof(__fd_mask ))]): "cc");
#line 140
    if (__result) {
#line 141
      while (1) {
#line 141
        tmp = read(notify_pipe[0], (void *)(& c), 1U);
#line 141
        if (! (tmp != -1)) {
#line 141
          break;
        }
#line 142
        debug2("notify_done: reading");
      }
    }
  }
#line 143
  return;
}
}
#line 145 "serverloop.c"
static void sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 148
  tmp = __errno_location();
#line 148
  save_errno = *tmp;
#line 149
  debug("Received SIGCHLD.");
#line 150
  child_terminated = (int volatile   )1;
#line 152
  mysignal(17, & sigchld_handler);
#line 154
  notify_parent();
#line 155
  tmp___0 = __errno_location();
#line 155
  *tmp___0 = save_errno;
#line 156
  return;
}
}
#line 158 "serverloop.c"
static void sigterm_handler___0(int sig ) 
{ 

  {
#line 161
  received_sigterm___0 = (int volatile   )sig;
#line 162
  return;
}
}
#line 168 "serverloop.c"
static void make_packets_from_stderr_data(void) 
{ u_int len ;
  int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;

  {
#line 174
  while (1) {
#line 174
    tmp___1 = buffer_len(& stderr_buffer);
#line 174
    if (tmp___1 > 0U) {
#line 174
      tmp___2 = packet_not_very_much_data_to_write();
#line 174
      if (! tmp___2) {
#line 174
        break;
      }
    } else {
#line 174
      break;
    }
#line 176
    len = buffer_len(& stderr_buffer);
#line 177
    tmp = packet_is_interactive();
#line 177
    if (tmp) {
#line 178
      if (len > 512U) {
#line 179
        len = 512U;
      }
    } else {
#line 182
      if (len > max_packet_size) {
#line 183
        len = max_packet_size;
      }
    }
#line 185
    packet_start((unsigned char)18);
#line 186
    tmp___0 = buffer_ptr(& stderr_buffer);
#line 186
    packet_put_string((void const   *)tmp___0, len);
#line 187
    packet_send();
#line 188
    buffer_consume(& stderr_buffer, len);
#line 189
    stderr_bytes = (long )((unsigned long )stderr_bytes + (unsigned long )len);
  }
#line 191
  return;
}
}
#line 197 "serverloop.c"
static void make_packets_from_stdout_data(void) 
{ u_int len ;
  int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;

  {
#line 203
  while (1) {
#line 203
    tmp___1 = buffer_len(& stdout_buffer);
#line 203
    if (tmp___1 > 0U) {
#line 203
      tmp___2 = packet_not_very_much_data_to_write();
#line 203
      if (! tmp___2) {
#line 203
        break;
      }
    } else {
#line 203
      break;
    }
#line 205
    len = buffer_len(& stdout_buffer);
#line 206
    tmp = packet_is_interactive();
#line 206
    if (tmp) {
#line 207
      if (len > 512U) {
#line 208
        len = 512U;
      }
    } else {
#line 211
      if (len > max_packet_size) {
#line 212
        len = max_packet_size;
      }
    }
#line 214
    packet_start((unsigned char)17);
#line 215
    tmp___0 = buffer_ptr(& stdout_buffer);
#line 215
    packet_put_string((void const   *)tmp___0, len);
#line 216
    packet_send();
#line 217
    buffer_consume(& stdout_buffer, len);
#line 218
    stdout_bytes = (long )((unsigned long )stdout_bytes + (unsigned long )len);
  }
#line 220
  return;
}
}
#line 222 "serverloop.c"
static void client_alive_check(void) 
{ int channel_id ;

  {
#line 228
  client_alive_timeouts ++;
#line 228
  if (client_alive_timeouts > options.client_alive_count_max) {
#line 229
    packet_disconnect("Timeout, your session not responding.");
  }
#line 235
  channel_id = channel_find_open();
#line 235
  if (channel_id == -1) {
#line 236
    packet_start((unsigned char)80);
#line 237
    packet_put_cstring("keepalive@openssh.com");
#line 238
    packet_put_char(1);
  } else {
#line 240
    channel_request_start(channel_id, (char *)"keepalive@openssh.com", 1);
  }
#line 242
  packet_send();
#line 243
  return;
}
}
#line 251 "serverloop.c"
static void wait_until_can_do_something(fd_set **readsetp , fd_set **writesetp , int *maxfdp ,
                                        u_int *nallocp , u_int max_time_milliseconds ) 
{ struct timeval tv ;
  struct timeval *tvp ;
  int ret ;
  int client_alive_scheduled ;
  u_int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  u_int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;

  {
#line 257
  client_alive_scheduled = 0;
#line 267
  if (compat20) {
#line 267
    if (max_time_milliseconds == 0U) {
#line 267
      if (options.client_alive_interval) {
#line 269
        client_alive_scheduled = 1;
#line 270
        max_time_milliseconds = (unsigned int )(options.client_alive_interval * 1000);
      }
    }
  }
#line 274
  channel_prepare_select(readsetp, writesetp, maxfdp, nallocp, 0);
#line 276
  if (compat20) {
#line 281
    __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  } else {
#line 287
    tmp = buffer_len(& stdin_buffer);
#line 287
    if (tmp < buffer_high) {
#line 287
      tmp___0 = channel_not_very_much_buffered_data();
#line 287
      if (tmp___0) {
#line 289
        __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
#line 294
    tmp___1 = packet_not_very_much_data_to_write();
#line 294
    if (tmp___1) {
#line 295
      if (! fdout_eof) {
#line 296
        __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
#line 297
      if (! fderr_eof) {
#line 298
        __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
#line 304
    if (fdin != -1) {
#line 304
      tmp___2 = buffer_len(& stdin_buffer);
#line 304
      if (tmp___2 > 0U) {
#line 305
        __asm__  volatile   ("btsl %1,%0": "=m" ((*writesetp)->fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
  }
#line 307
  notify_prepare(*readsetp);
#line 313
  tmp___3 = packet_have_data_to_write();
#line 313
  if (tmp___3) {
#line 314
    __asm__  volatile   ("btsl %1,%0": "=m" ((*writesetp)->fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 320
  if (child_terminated) {
#line 320
    tmp___4 = packet_not_very_much_data_to_write();
#line 320
    if (tmp___4) {
#line 321
      if (max_time_milliseconds == 0U) {
#line 322
        max_time_milliseconds = 100U;
      } else {
#line 321
        if (client_alive_scheduled) {
#line 322
          max_time_milliseconds = 100U;
        }
      }
    }
  }
#line 324
  if (max_time_milliseconds == 0U) {
#line 325
    tvp = (struct timeval *)((void *)0);
  } else {
#line 327
    tv.tv_sec = (long )(max_time_milliseconds / 1000U);
#line 328
    tv.tv_usec = (long )(1000U * (max_time_milliseconds % 1000U));
#line 329
    tvp = & tv;
  }
#line 333
  ret = select(*maxfdp + 1, (fd_set * __restrict  )*readsetp, (fd_set * __restrict  )*writesetp,
               (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )tvp);
#line 335
  if (ret == -1) {
#line 336
    memset((void *)*readsetp, 0, *nallocp);
#line 337
    memset((void *)*writesetp, 0, *nallocp);
#line 338
    tmp___7 = __errno_location();
#line 338
    if (*tmp___7 != 4) {
#line 339
      tmp___5 = __errno_location();
#line 339
      tmp___6 = strerror(*tmp___5);
#line 339
      error("select: %.100s", tmp___6);
    }
  } else {
#line 340
    if (ret == 0) {
#line 340
      if (client_alive_scheduled) {
#line 341
        client_alive_check();
      }
    }
  }
#line 343
  notify_done(*readsetp);
#line 344
  return;
}
}
#line 350 "serverloop.c"
static void process_input(fd_set *readset ) 
{ int len ;
  char buf___1[16384] ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  register char __result ;
  int *tmp___5 ;
  int *tmp___6 ;
  register char __result___0 ;
  int *tmp___7 ;
  int *tmp___8 ;
  register char __result___1 ;

  {
#line 357
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))),
                       "m" (readset->fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 357
  if (__result) {
#line 358
    len = read(connection_in___0, (void *)(buf___1), sizeof(buf___1));
#line 359
    if (len == 0) {
#line 360
      tmp = get_remote_ipaddr();
#line 360
      verbose("Connection closed by %.100s", tmp);
#line 362
      connection_closed = 1;
#line 363
      if (compat20) {
#line 364
        return;
      }
#line 365
      cleanup_exit(255);
    } else {
#line 366
      if (len < 0) {
#line 367
        tmp___3 = __errno_location();
#line 367
        if (*tmp___3 != 4) {
#line 367
          tmp___4 = __errno_location();
#line 367
          if (*tmp___4 != 11) {
#line 368
            tmp___0 = __errno_location();
#line 368
            tmp___1 = strerror(*tmp___0);
#line 368
            tmp___2 = get_remote_ipaddr();
#line 368
            verbose("Read error from remote host %.100s: %.100s", tmp___2, tmp___1);
#line 371
            cleanup_exit(255);
          }
        }
      } else {
#line 375
        packet_process_incoming((char const   *)(buf___1), (unsigned int )len);
      }
    }
  }
#line 378
  if (compat20) {
#line 379
    return;
  }
#line 382
  if (! fdout_eof) {
#line 382
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))),
                         "m" (readset->fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "cc");
#line 382
    if (__result___0) {
#line 383
      len = read(fdout, (void *)(buf___1), sizeof(buf___1));
#line 384
      if (len < 0) {
#line 384
        tmp___5 = __errno_location();
#line 384
        if (! (*tmp___5 == 4)) {
#line 384
          tmp___6 = __errno_location();
#line 384
          if (! (*tmp___6 == 11)) {
            goto _L;
          }
        }
      } else {
        _L: /* CIL Label */ 
#line 386
        if (len <= 0) {
#line 387
          fdout_eof = 1;
        } else {
#line 389
          buffer_append(& stdout_buffer, (void const   *)(buf___1), (unsigned int )len);
#line 390
          fdout_bytes += (long )len;
        }
      }
    }
  }
#line 394
  if (! fderr_eof) {
#line 394
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___1): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))),
                         "m" (readset->fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "cc");
#line 394
    if (__result___1) {
#line 395
      len = read(fderr, (void *)(buf___1), sizeof(buf___1));
#line 396
      if (len < 0) {
#line 396
        tmp___7 = __errno_location();
#line 396
        if (! (*tmp___7 == 4)) {
#line 396
          tmp___8 = __errno_location();
#line 396
          if (! (*tmp___8 == 11)) {
            goto _L___0;
          }
        }
      } else {
        _L___0: /* CIL Label */ 
#line 398
        if (len <= 0) {
#line 399
          fderr_eof = 1;
        } else {
#line 401
          buffer_append(& stderr_buffer, (void const   *)(buf___1), (unsigned int )len);
        }
      }
    }
  }
#line 404
  return;
}
}
#line 409 "serverloop.c"
static void process_output(fd_set *writeset ) 
{ struct termios tio ;
  u_char *data ;
  u_int dlen ;
  int len ;
  void *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  register char __result ;
  register char __result___0 ;

  {
#line 418
  if (! compat20) {
#line 418
    if (fdin != -1) {
#line 418
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))),
                           "m" (writeset->fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "cc");
#line 418
      if (__result) {
#line 419
        tmp = buffer_ptr(& stdin_buffer);
#line 419
        data = (u_char *)tmp;
#line 420
        dlen = buffer_len(& stdin_buffer);
#line 421
        len = write(fdin, (void const   *)data, dlen);
#line 422
        if (len < 0) {
#line 422
          tmp___1 = __errno_location();
#line 422
          if (! (*tmp___1 == 4)) {
#line 422
            tmp___2 = __errno_location();
#line 422
            if (! (*tmp___2 == 11)) {
              goto _L;
            }
          }
        } else {
          _L: /* CIL Label */ 
#line 424
          if (len <= 0) {
#line 425
            if (fdin != fdout) {
#line 426
              close(fdin);
            } else {
#line 428
              shutdown(fdin, 1);
            }
#line 429
            fdin = -1;
          } else {
#line 432
            if (fdin_is_tty) {
#line 432
              if (dlen >= 1U) {
#line 432
                if ((int )*(data + 0) != 13) {
#line 432
                  tmp___0 = tcgetattr(fdin, & tio);
#line 432
                  if (tmp___0 == 0) {
#line 432
                    if (! (tio.c_lflag & 8U)) {
#line 432
                      if (tio.c_lflag & 2U) {
#line 439
                        packet_send_ignore(len);
#line 440
                        packet_send();
                      }
                    }
                  }
                }
              }
            }
#line 443
            buffer_consume(& stdin_buffer, (unsigned int )len);
#line 445
            stdin_bytes += (long )len;
          }
        }
      }
    }
  }
#line 449
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 449
  if (__result___0) {
#line 450
    packet_write_poll();
  }
#line 451
  return;
}
}
#line 457 "serverloop.c"
static void drain_output(void) 
{ u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  void *tmp___4 ;
  u_int tmp___5 ;
  u_int tmp___6 ;

  {
#line 461
  tmp___2 = buffer_len(& stdout_buffer);
#line 461
  if (tmp___2 > 0U) {
#line 462
    packet_start((unsigned char)17);
#line 463
    tmp = buffer_len(& stdout_buffer);
#line 463
    tmp___0 = buffer_ptr(& stdout_buffer);
#line 463
    packet_put_string((void const   *)tmp___0, tmp);
#line 465
    packet_send();
#line 467
    tmp___1 = buffer_len(& stdout_buffer);
#line 467
    stdout_bytes = (long )((unsigned long )stdout_bytes + (unsigned long )tmp___1);
  }
#line 470
  tmp___6 = buffer_len(& stderr_buffer);
#line 470
  if (tmp___6 > 0U) {
#line 471
    packet_start((unsigned char)18);
#line 472
    tmp___3 = buffer_len(& stderr_buffer);
#line 472
    tmp___4 = buffer_ptr(& stderr_buffer);
#line 472
    packet_put_string((void const   *)tmp___4, tmp___3);
#line 474
    packet_send();
#line 476
    tmp___5 = buffer_len(& stderr_buffer);
#line 476
    stderr_bytes = (long )((unsigned long )stderr_bytes + (unsigned long )tmp___5);
  }
#line 479
  packet_write_wait();
#line 480
  return;
}
}
#line 482 "serverloop.c"
static void process_buffered_input_packets(void) 
{ Kex *tmp ;

  {
#line 485
  if (compat20) {
#line 485
    tmp = xxx_kex;
  } else {
#line 485
    tmp = (Kex *)((void *)0);
  }
#line 485
  dispatch_run(1, (int *)((void *)0), (void *)tmp);
#line 486
  return;
}
}
#line 495 "serverloop.c"
void server_loop(pid_t pid , int fdin_arg , int fdout_arg , int fderr_arg ) 
{ fd_set *readset ;
  fd_set *writeset ;
  int max_fd ;
  u_int nalloc ;
  int wait_status ;
  pid_t wait_pid ;
  int waiting_termination ;
  u_int max_time_milliseconds ;
  u_int previous_stdout_buffer_bytes ;
  u_int stdout_buffer_bytes ;
  int type ;
  int tmp ;
  int tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *s ;
  char *cp ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  u_int tmp___7 ;
  u_int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  union __anonunion___u_85 __u ;
  union __anonunion___u_86 __u___0 ;
  union __anonunion___u_87 __u___1 ;
  union __anonunion___u_88 __u___2 ;
  union __anonunion___u_89 __u___3 ;

  {
#line 498
  readset = (fd_set *)((void *)0);
#line 498
  writeset = (fd_set *)((void *)0);
#line 499
  max_fd = 0;
#line 500
  nalloc = (u_int )0;
#line 503
  waiting_termination = 0;
#line 509
  debug("Entering interactive session.");
#line 512
  child_terminated = (int volatile   )0;
#line 513
  mysignal(17, & sigchld_handler);
#line 515
  if (! use_privsep) {
#line 516
    mysignal(15, & sigterm_handler___0);
#line 517
    mysignal(2, & sigterm_handler___0);
#line 518
    mysignal(3, & sigterm_handler___0);
  }
#line 522
  fdin = fdin_arg;
#line 523
  fdout = fdout_arg;
#line 524
  fderr = fderr_arg;
#line 527
  set_nonblock(fdin);
#line 528
  set_nonblock(fdout);
#line 530
  if (fderr != -1) {
#line 531
    set_nonblock(fderr);
  }
#line 533
  if (! (datafellows & 256)) {
#line 533
    tmp = isatty(fdin);
#line 533
    if (tmp) {
#line 534
      fdin_is_tty = 1;
    }
  }
#line 536
  connection_in___0 = packet_get_connection_in();
#line 537
  connection_out___0 = packet_get_connection_out();
#line 539
  notify_setup();
#line 541
  previous_stdout_buffer_bytes = 0U;
#line 544
  tmp___0 = packet_is_interactive();
#line 544
  if (tmp___0) {
#line 545
    buffer_high = 4096U;
  } else {
#line 547
    buffer_high = 65536U;
  }
#line 559
  buffer_init(& stdin_buffer);
#line 560
  buffer_init(& stdout_buffer);
#line 561
  buffer_init(& stderr_buffer);
#line 569
  if (fderr == -1) {
#line 570
    fderr_eof = 1;
  }
#line 572
  server_init_dispatch();
#line 575
  while (1) {
#line 578
    process_buffered_input_packets();
#line 584
    if (stdin_eof) {
#line 584
      if (fdin != -1) {
#line 584
        tmp___1 = buffer_len(& stdin_buffer);
#line 584
        if (tmp___1 == 0U) {
#line 585
          if (fdin != fdout) {
#line 586
            close(fdin);
          } else {
#line 588
            shutdown(fdin, 1);
          }
#line 589
          fdin = -1;
        }
      }
    }
#line 592
    make_packets_from_stderr_data();
#line 601
    max_time_milliseconds = 0U;
#line 602
    stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 603
    if (stdout_buffer_bytes != 0U) {
#line 603
      if (stdout_buffer_bytes < 256U) {
#line 603
        if (stdout_buffer_bytes != previous_stdout_buffer_bytes) {
#line 606
          max_time_milliseconds = 10U;
        } else {
#line 609
          make_packets_from_stdout_data();
        }
      } else {
#line 609
        make_packets_from_stdout_data();
      }
    } else {
#line 609
      make_packets_from_stdout_data();
    }
#line 611
    previous_stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 614
    tmp___2 = packet_not_very_much_data_to_write();
#line 614
    if (tmp___2) {
#line 615
      channel_output_poll();
    }
#line 622
    if (fdout_eof) {
#line 622
      if (fderr_eof) {
#line 622
        tmp___6 = packet_have_data_to_write();
#line 622
        if (! tmp___6) {
#line 622
          tmp___7 = buffer_len(& stdout_buffer);
#line 622
          if (tmp___7 == 0U) {
#line 622
            tmp___8 = buffer_len(& stderr_buffer);
#line 622
            if (tmp___8 == 0U) {
#line 624
              tmp___3 = channel_still_open();
#line 624
              if (! tmp___3) {
#line 625
                break;
              }
#line 626
              if (! waiting_termination) {
#line 627
                s = "Waiting for forwarded connections to terminate...\r\n";
#line 629
                waiting_termination = 1;
#line 630
                tmp___4 = strlen(s);
#line 630
                buffer_append(& stderr_buffer, (void const   *)s, tmp___4);
#line 633
                cp = channel_open_message();
#line 634
                tmp___5 = strlen((char const   *)cp);
#line 634
                buffer_append(& stderr_buffer, (void const   *)cp, tmp___5);
#line 635
                xfree((void *)cp);
              }
            }
          }
        }
      }
    }
#line 638
    if (connection_in___0 > connection_out___0) {
#line 638
      max_fd = connection_in___0;
    } else {
#line 638
      max_fd = connection_out___0;
    }
#line 639
    if (max_fd > fdin) {
#line 639
      max_fd = max_fd;
    } else {
#line 639
      max_fd = fdin;
    }
#line 640
    if (max_fd > fdout) {
#line 640
      max_fd = max_fd;
    } else {
#line 640
      max_fd = fdout;
    }
#line 641
    if (max_fd > fderr) {
#line 641
      max_fd = max_fd;
    } else {
#line 641
      max_fd = fderr;
    }
#line 642
    if (max_fd > notify_pipe[0]) {
#line 642
      max_fd = max_fd;
    } else {
#line 642
      max_fd = notify_pipe[0];
    }
#line 645
    wait_until_can_do_something(& readset, & writeset, & max_fd, & nalloc, max_time_milliseconds);
#line 648
    if (received_sigterm___0) {
#line 649
      logit("Exiting on signal %d", received_sigterm___0);
#line 651
      cleanup_exit(255);
    }
#line 655
    channel_after_select(readset, writeset);
#line 658
    process_input(readset);
#line 661
    process_output(writeset);
  }
#line 663
  if (readset) {
#line 664
    xfree((void *)readset);
  }
#line 665
  if (writeset) {
#line 666
    xfree((void *)writeset);
  }
#line 671
  drain_output();
#line 673
  debug("End of interactive session; stdin %ld, stdout (read %ld, sent %ld), stderr %ld bytes.",
        stdin_bytes, fdout_bytes, stdout_bytes, stderr_bytes);
#line 677
  buffer_free(& stdin_buffer);
#line 678
  buffer_free(& stdout_buffer);
#line 679
  buffer_free(& stderr_buffer);
#line 682
  if (fdout != -1) {
#line 683
    close(fdout);
  }
#line 684
  fdout = -1;
#line 685
  fdout_eof = 1;
#line 686
  if (fderr != -1) {
#line 687
    close(fderr);
  }
#line 688
  fderr = -1;
#line 689
  fderr_eof = 1;
#line 690
  if (fdin != -1) {
#line 691
    close(fdin);
  }
#line 692
  fdin = -1;
#line 694
  channel_free_all();
#line 697
  mysignal(17, (void (*)(int  ))0);
#line 699
  while (1) {
#line 699
    wait_pid = waitpid(-1, & wait_status, 0);
#line 699
    if (! (wait_pid < 0)) {
#line 699
      break;
    }
#line 700
    tmp___11 = __errno_location();
#line 700
    if (*tmp___11 != 4) {
#line 701
      tmp___9 = __errno_location();
#line 701
      tmp___10 = strerror(*tmp___9);
#line 701
      packet_disconnect("wait: %.100s", tmp___10);
    }
  }
#line 702
  if (wait_pid != pid) {
#line 703
    error("Strange, wait returned pid %ld, expected %ld", (long )wait_pid, (long )pid);
  }
#line 707
  __u___1.__in = wait_status;
#line 707
  if ((__u___1.__i & 127) == 0) {
#line 709
    __u.__in = wait_status;
#line 709
    debug("Command exited with status %d.", (__u.__i & 65280) >> 8);
#line 710
    packet_start((unsigned char)20);
#line 711
    __u___0.__in = wait_status;
#line 711
    packet_put_int((unsigned int )((__u___0.__i & 65280) >> 8));
#line 712
    packet_send();
#line 713
    packet_write_wait();
#line 722
    while (1) {
#line 723
      type = packet_read();
#line 722
      if (! (type != 33)) {
#line 722
        break;
      }
    }
#line 727
    debug("Received exit confirmation.");
#line 728
    return;
  }
#line 731
  __u___3.__in = wait_status;
#line 731
  if ((int )((signed char )((__u___3.__i & 127) + 1)) >> 1 > 0) {
#line 733
    __u___2.__in = wait_status;
#line 733
    packet_disconnect("Command terminated on signal %d.", __u___2.__i & 127);
  }
#line 736
  packet_disconnect("wait returned status %04x.", wait_status);
#line 738
  return;
}
}
#line 740 "serverloop.c"
static void collect_children(void) 
{ pid_t pid ;
  sigset_t oset ;
  sigset_t nset ;
  int status ;
  int *tmp ;

  {
#line 748
  sigemptyset(& nset);
#line 749
  sigaddset(& nset, 17);
#line 750
  sigprocmask(0, (sigset_t const   * __restrict  )(& nset), (sigset_t * __restrict  )(& oset));
#line 751
  if (child_terminated) {
#line 752
    while (1) {
#line 752
      pid = waitpid(-1, & status, 1);
#line 752
      if (! (pid > 0)) {
#line 752
        if (pid < 0) {
#line 752
          tmp = __errno_location();
#line 752
          if (! (*tmp == 4)) {
#line 752
            break;
          }
        } else {
#line 752
          break;
        }
      }
#line 754
      if (pid > 0) {
#line 755
        session_close_by_pid(pid, status);
      }
    }
#line 756
    child_terminated = (int volatile   )0;
  }
#line 758
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((void *)0));
#line 759
  return;
}
}
#line 761 "serverloop.c"
void server_loop2(Authctxt *authctxt___0 ) 
{ fd_set *readset ;
  fd_set *writeset ;
  int rekeying___0 ;
  int max_fd ;
  int nalloc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 764
  readset = (fd_set *)((void *)0);
#line 764
  writeset = (fd_set *)((void *)0);
#line 765
  rekeying___0 = 0;
#line 765
  nalloc = 0;
#line 767
  debug("Entering interactive session for SSH2.");
#line 769
  mysignal(17, & sigchld_handler);
#line 770
  child_terminated = (int volatile   )0;
#line 771
  connection_in___0 = packet_get_connection_in();
#line 772
  connection_out___0 = packet_get_connection_out();
#line 774
  if (! use_privsep) {
#line 775
    mysignal(15, & sigterm_handler___0);
#line 776
    mysignal(2, & sigterm_handler___0);
#line 777
    mysignal(3, & sigterm_handler___0);
  }
#line 780
  notify_setup();
#line 782
  if (connection_in___0 > connection_out___0) {
#line 782
    max_fd = connection_in___0;
  } else {
#line 782
    max_fd = connection_out___0;
  }
#line 783
  if (max_fd > notify_pipe[0]) {
#line 783
    max_fd = max_fd;
  } else {
#line 783
    max_fd = notify_pipe[0];
  }
#line 785
  server_init_dispatch();
#line 787
  while (1) {
#line 788
    process_buffered_input_packets();
#line 790
    if ((unsigned int )xxx_kex != (unsigned int )((void *)0)) {
#line 790
      if (! xxx_kex->done) {
#line 790
        tmp = 1;
      } else {
#line 790
        tmp = 0;
      }
    } else {
#line 790
      tmp = 0;
    }
#line 790
    rekeying___0 = tmp;
#line 792
    if (! rekeying___0) {
#line 792
      tmp___0 = packet_not_very_much_data_to_write();
#line 792
      if (tmp___0) {
#line 793
        channel_output_poll();
      }
    }
#line 794
    wait_until_can_do_something(& readset, & writeset, & max_fd, (u_int *)(& nalloc),
                                0U);
#line 797
    if (received_sigterm___0) {
#line 798
      logit("Exiting on signal %d", received_sigterm___0);
#line 800
      cleanup_exit(255);
    }
#line 803
    collect_children();
#line 804
    if (! rekeying___0) {
#line 805
      channel_after_select(readset, writeset);
#line 806
      tmp___1 = packet_need_rekeying();
#line 806
      if (tmp___1) {
#line 807
        debug("need rekeying");
#line 808
        xxx_kex->done = 0;
#line 809
        kex_send_kexinit(xxx_kex);
      }
    }
#line 812
    process_input(readset);
#line 813
    if (connection_closed) {
#line 814
      break;
    }
#line 815
    process_output(writeset);
  }
#line 817
  collect_children();
#line 819
  if (readset) {
#line 820
    xfree((void *)readset);
  }
#line 821
  if (writeset) {
#line 822
    xfree((void *)writeset);
  }
#line 825
  channel_free_all();
#line 828
  session_destroy_all((void (*)(Session * ))((void *)0));
#line 829
  return;
}
}
#line 831 "serverloop.c"
static void server_input_keep_alive(int type , u_int32_t seq , void *ctxt ) 
{ 

  {
#line 834
  debug("Got %d/%u for keepalive", type, seq);
#line 840
  client_alive_timeouts = 0;
#line 841
  return;
}
}
#line 843 "serverloop.c"
static void server_input_stdin_data(int type , u_int32_t seq , void *ctxt ) 
{ char *data ;
  u_int data_len ;
  void *tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 851
  if (fdin == -1) {
#line 852
    return;
  }
#line 853
  tmp = packet_get_string(& data_len);
#line 853
  data = (char *)tmp;
#line 854
  while (1) {
#line 854
    tmp___0 = packet_remaining();
#line 854
    _len = tmp___0;
#line 854
    if (_len > 0) {
#line 854
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
            854);
#line 854
      packet_disconnect("Packet integrity error.");
    }
#line 854
    break;
  }
#line 855
  buffer_append(& stdin_buffer, (void const   *)data, data_len);
#line 856
  memset((void *)data, 0, data_len);
#line 857
  xfree((void *)data);
#line 858
  return;
}
}
#line 860 "serverloop.c"
static void server_input_eof(int type , u_int32_t seq , void *ctxt ) 
{ int _len ;
  int tmp ;

  {
#line 868
  debug("EOF received for stdin.");
#line 869
  while (1) {
#line 869
    tmp = packet_remaining();
#line 869
    _len = tmp;
#line 869
    if (_len > 0) {
#line 869
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
            869);
#line 869
      packet_disconnect("Packet integrity error.");
    }
#line 869
    break;
  }
#line 870
  stdin_eof = 1;
#line 871
  return;
}
}
#line 873 "serverloop.c"
static void server_input_window_size(int type , u_int32_t seq , void *ctxt ) 
{ int row ;
  u_int tmp ;
  int col ;
  u_int tmp___0 ;
  int xpixel ;
  u_int tmp___1 ;
  int ypixel ;
  u_int tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 876
  tmp = packet_get_int();
#line 876
  row = (int )tmp;
#line 877
  tmp___0 = packet_get_int();
#line 877
  col = (int )tmp___0;
#line 878
  tmp___1 = packet_get_int();
#line 878
  xpixel = (int )tmp___1;
#line 879
  tmp___2 = packet_get_int();
#line 879
  ypixel = (int )tmp___2;
#line 881
  debug("Window change received.");
#line 882
  while (1) {
#line 882
    tmp___3 = packet_remaining();
#line 882
    _len = tmp___3;
#line 882
    if (_len > 0) {
#line 882
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
            882);
#line 882
      packet_disconnect("Packet integrity error.");
    }
#line 882
    break;
  }
#line 883
  if (fdin != -1) {
#line 884
    pty_change_window_size(fdin, row, col, xpixel, ypixel);
  }
#line 885
  return;
}
}
#line 887 "serverloop.c"
static Channel *server_request_direct_tcpip(void) 
{ Channel *c ;
  int sock ;
  char *target ;
  char *originator ;
  int target_port ;
  int originator_port ;
  void *tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  u_int tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 895
  tmp = packet_get_string((u_int *)((void *)0));
#line 895
  target = (char *)tmp;
#line 896
  tmp___0 = packet_get_int();
#line 896
  target_port = (int )tmp___0;
#line 897
  tmp___1 = packet_get_string((u_int *)((void *)0));
#line 897
  originator = (char *)tmp___1;
#line 898
  tmp___2 = packet_get_int();
#line 898
  originator_port = (int )tmp___2;
#line 899
  while (1) {
#line 899
    tmp___3 = packet_remaining();
#line 899
    _len = tmp___3;
#line 899
    if (_len > 0) {
#line 899
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
            899);
#line 899
      packet_disconnect("Packet integrity error.");
    }
#line 899
    break;
  }
#line 901
  debug("server_request_direct_tcpip: originator %s port %d, target %s port %d", originator,
        originator_port, target, target_port);
#line 905
  sock = channel_connect_to((char const   *)target, (unsigned short )target_port);
#line 906
  xfree((void *)target);
#line 907
  xfree((void *)originator);
#line 908
  if (sock < 0) {
#line 909
    return ((Channel *)((void *)0));
  }
#line 910
  c = channel_new((char *)"direct-tcpip", 12, sock, sock, -1, 131072U, 32768U, 0,
                  (char *)"direct-tcpip", 1);
#line 913
  return (c);
}
}
#line 916 "serverloop.c"
static Channel *server_request_tun(void) 
{ Channel *c ;
  int mode ;
  int tun ;
  int sock ;
  u_int tmp ;
  u_int tmp___0 ;

  {
#line 919
  c = (Channel *)((void *)0);
#line 923
  tmp = packet_get_int();
#line 923
  mode = (int )tmp;
#line 924
  switch (mode) {
  case 1: 
  case 2: 
#line 927
  break;
  default: 
#line 929
  packet_send_debug("Unsupported tunnel device mode.");
#line 930
  return ((Channel *)((void *)0));
  }
#line 932
  if ((options.permit_tun & mode) == 0) {
#line 933
    packet_send_debug("Server has rejected tunnel device forwarding");
#line 935
    return ((Channel *)((void *)0));
  }
#line 938
  tmp___0 = packet_get_int();
#line 938
  tun = (int )tmp___0;
#line 939
  if (forced_tun_device != -1) {
#line 940
    if (tun != 2147483647) {
#line 940
      if (forced_tun_device != tun) {
        goto done;
      }
    }
#line 942
    tun = forced_tun_device;
  }
#line 944
  sock = tun_open(tun, mode);
#line 945
  if (sock < 0) {
    goto done;
  }
#line 947
  c = channel_new((char *)"tun", 4, sock, sock, -1, 131072U, 32768U, 0, (char *)"tun",
                  1);
#line 949
  c->datagram = 1;
#line 951
  if (mode == 1) {
#line 952
    channel_register_filter(c->self, & sys_tun_infilter, & sys_tun_outfilter);
  }
  done: 
#line 957
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 958
    packet_send_debug("Failed to open the tunnel device.");
  }
#line 959
  return (c);
}
}
#line 962 "serverloop.c"
static Channel *server_request_session(void) 
{ Channel *c ;
  int _len ;
  int tmp ;
  int tmp___0 ;

  {
#line 967
  debug("input_session_request");
#line 968
  while (1) {
#line 968
    tmp = packet_remaining();
#line 968
    _len = tmp;
#line 968
    if (_len > 0) {
#line 968
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
            968);
#line 968
      packet_disconnect("Packet integrity error.");
    }
#line 968
    break;
  }
#line 975
  c = channel_new((char *)"session", 10, -1, -1, -1, 0U, 32768U, 0, (char *)"server-session",
                  1);
#line 978
  tmp___0 = session_open(the_authctxt, c->self);
#line 978
  if (tmp___0 != 1) {
#line 979
    debug("session open failed, free channel %d", c->self);
#line 980
    channel_free(c);
#line 981
    return ((Channel *)((void *)0));
  }
#line 983
  channel_register_cleanup(c->self, & session_close_by_channel, 0);
#line 984
  return (c);
}
}
#line 987 "serverloop.c"
static void server_input_channel_open(int type , u_int32_t seq , void *ctxt ) 
{ Channel *c ;
  char *ctype ;
  int rchan ;
  u_int rmaxpack ;
  u_int rwindow ;
  u_int len ;
  void *tmp ;
  u_int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___16 ;
  int tmp___19 ;
  int tmp___20 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___26 ;
  int tmp___29 ;
  int tmp___30 ;

  {
#line 990
  c = (Channel *)((void *)0);
#line 995
  tmp = packet_get_string(& len);
#line 995
  ctype = (char *)tmp;
#line 996
  tmp___0 = packet_get_int();
#line 996
  rchan = (int )tmp___0;
#line 997
  rwindow = packet_get_int();
#line 998
  rmaxpack = packet_get_int();
#line 1000
  debug("server_input_channel_open: ctype %s rchan %d win %d max %d", ctype, rchan,
        rwindow, rmaxpack);
#line 1003
  if (0) {
#line 1003
    __s1_len___1 = strlen((char const   *)ctype);
#line 1003
    __s2_len___1 = strlen("session");
#line 1003
    if (! ((unsigned int )((void const   *)(ctype + 1)) - (unsigned int )((void const   *)ctype) == 1U)) {
      goto _L___4;
    } else {
#line 1003
      if (__s1_len___1 >= 4U) {
        _L___4: /* CIL Label */ 
#line 1003
        if (! ((unsigned int )((void const   *)("session" + 1)) - (unsigned int )((void const   *)"session") == 1U)) {
#line 1003
          tmp___30 = 1;
        } else {
#line 1003
          if (__s2_len___1 >= 4U) {
#line 1003
            tmp___30 = 1;
          } else {
#line 1003
            tmp___30 = 0;
          }
        }
      } else {
#line 1003
        tmp___30 = 0;
      }
    }
#line 1003
    if (tmp___30) {
#line 1003
      tmp___26 = __builtin_strcmp((char const   *)ctype, "session");
    } else {
#line 1003
      tmp___29 = __builtin_strcmp((char const   *)ctype, "session");
#line 1003
      tmp___26 = tmp___29;
    }
  } else {
#line 1003
    tmp___29 = __builtin_strcmp((char const   *)ctype, "session");
#line 1003
    tmp___26 = tmp___29;
  }
#line 1003
  if (tmp___26 == 0) {
#line 1004
    c = server_request_session();
  } else {
#line 1005
    if (0) {
#line 1005
      __s1_len___0 = strlen((char const   *)ctype);
#line 1005
      __s2_len___0 = strlen("direct-tcpip");
#line 1005
      if (! ((unsigned int )((void const   *)(ctype + 1)) - (unsigned int )((void const   *)ctype) == 1U)) {
        goto _L___2;
      } else {
#line 1005
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 1005
          if (! ((unsigned int )((void const   *)("direct-tcpip" + 1)) - (unsigned int )((void const   *)"direct-tcpip") == 1U)) {
#line 1005
            tmp___20 = 1;
          } else {
#line 1005
            if (__s2_len___0 >= 4U) {
#line 1005
              tmp___20 = 1;
            } else {
#line 1005
              tmp___20 = 0;
            }
          }
        } else {
#line 1005
          tmp___20 = 0;
        }
      }
#line 1005
      if (tmp___20) {
#line 1005
        tmp___16 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
      } else {
#line 1005
        tmp___19 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
#line 1005
        tmp___16 = tmp___19;
      }
    } else {
#line 1005
      tmp___19 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
#line 1005
      tmp___16 = tmp___19;
    }
#line 1005
    if (tmp___16 == 0) {
#line 1006
      c = server_request_direct_tcpip();
    } else {
#line 1007
      if (0) {
#line 1007
        __s1_len = strlen((char const   *)ctype);
#line 1007
        __s2_len = strlen("tun@openssh.com");
#line 1007
        if (! ((unsigned int )((void const   *)(ctype + 1)) - (unsigned int )((void const   *)ctype) == 1U)) {
          goto _L___0;
        } else {
#line 1007
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 1007
            if (! ((unsigned int )((void const   *)("tun@openssh.com" + 1)) - (unsigned int )((void const   *)"tun@openssh.com") == 1U)) {
#line 1007
              tmp___10 = 1;
            } else {
#line 1007
              if (__s2_len >= 4U) {
#line 1007
                tmp___10 = 1;
              } else {
#line 1007
                tmp___10 = 0;
              }
            }
          } else {
#line 1007
            tmp___10 = 0;
          }
        }
#line 1007
        if (tmp___10) {
#line 1007
          tmp___6 = __builtin_strcmp((char const   *)ctype, "tun@openssh.com");
        } else {
#line 1007
          tmp___9 = __builtin_strcmp((char const   *)ctype, "tun@openssh.com");
#line 1007
          tmp___6 = tmp___9;
        }
      } else {
#line 1007
        tmp___9 = __builtin_strcmp((char const   *)ctype, "tun@openssh.com");
#line 1007
        tmp___6 = tmp___9;
      }
#line 1007
      if (tmp___6 == 0) {
#line 1008
        c = server_request_tun();
      }
    }
  }
#line 1010
  if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 1011
    debug("server_input_channel_open: confirm %s", ctype);
#line 1012
    c->remote_id = rchan;
#line 1013
    c->remote_window = rwindow;
#line 1014
    c->remote_maxpacket = rmaxpack;
#line 1015
    if (c->type != 12) {
#line 1016
      packet_start((unsigned char)91);
#line 1017
      packet_put_int((unsigned int )c->remote_id);
#line 1018
      packet_put_int((unsigned int )c->self);
#line 1019
      packet_put_int(c->local_window);
#line 1020
      packet_put_int(c->local_maxpacket);
#line 1021
      packet_send();
    }
  } else {
#line 1024
    debug("server_input_channel_open: failure %s", ctype);
#line 1025
    packet_start((unsigned char)92);
#line 1026
    packet_put_int((unsigned int )rchan);
#line 1027
    packet_put_int(1U);
#line 1028
    if (! (datafellows & 131072)) {
#line 1029
      packet_put_cstring("open failed");
#line 1030
      packet_put_cstring("");
    }
#line 1032
    packet_send();
  }
#line 1034
  xfree((void *)ctype);
#line 1035
  return;
}
}
#line 1037 "serverloop.c"
static void server_input_global_request(int type , u_int32_t seq , void *ctxt ) 
{ char *rtype ;
  int want_reply ;
  int success ;
  void *tmp ;
  u_int tmp___0 ;
  struct passwd *pw ;
  char *listen_address ;
  u_short listen_port ;
  void *tmp___1 ;
  u_int tmp___2 ;
  char *cancel_address ;
  u_short cancel_port ;
  void *tmp___3 ;
  u_int tmp___4 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___10 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;

  {
#line 1042
  success = 0;
#line 1044
  tmp = packet_get_string((u_int *)((void *)0));
#line 1044
  rtype = (char *)tmp;
#line 1045
  tmp___0 = packet_get_char();
#line 1045
  want_reply = (int )tmp___0;
#line 1046
  debug("server_input_global_request: rtype %s want_reply %d", rtype, want_reply);
#line 1049
  if (0) {
#line 1049
    __s1_len___0 = strlen((char const   *)rtype);
#line 1049
    __s2_len___0 = strlen("tcpip-forward");
#line 1049
    if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
      goto _L___2;
    } else {
#line 1049
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 1049
        if (! ((unsigned int )((void const   *)("tcpip-forward" + 1)) - (unsigned int )((void const   *)"tcpip-forward") == 1U)) {
#line 1049
          tmp___24 = 1;
        } else {
#line 1049
          if (__s2_len___0 >= 4U) {
#line 1049
            tmp___24 = 1;
          } else {
#line 1049
            tmp___24 = 0;
          }
        }
      } else {
#line 1049
        tmp___24 = 0;
      }
    }
#line 1049
    if (tmp___24) {
#line 1049
      tmp___20 = __builtin_strcmp((char const   *)rtype, "tcpip-forward");
    } else {
#line 1049
      tmp___23 = __builtin_strcmp((char const   *)rtype, "tcpip-forward");
#line 1049
      tmp___20 = tmp___23;
    }
  } else {
#line 1049
    tmp___23 = __builtin_strcmp((char const   *)rtype, "tcpip-forward");
#line 1049
    tmp___20 = tmp___23;
  }
#line 1049
  if (tmp___20 == 0) {
#line 1054
    pw = the_authctxt->pw;
#line 1055
    if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 1056
      fatal("server_input_global_request: no/invalid user");
    } else {
#line 1055
      if (! the_authctxt->valid) {
#line 1056
        fatal("server_input_global_request: no/invalid user");
      }
    }
#line 1057
    tmp___1 = packet_get_string((u_int *)((void *)0));
#line 1057
    listen_address = (char *)tmp___1;
#line 1058
    tmp___2 = packet_get_int();
#line 1058
    listen_port = (unsigned short )tmp___2;
#line 1059
    debug("server_input_global_request: tcpip-forward listen %s port %d", listen_address,
          listen_port);
#line 1063
    if (! options.allow_tcp_forwarding) {
#line 1069
      success = 0;
#line 1070
      packet_send_debug("Server has disabled port forwarding.");
    } else {
#line 1063
      if (no_port_forwarding_flag) {
#line 1069
        success = 0;
#line 1070
        packet_send_debug("Server has disabled port forwarding.");
      } else {
#line 1063
        if ((int )listen_port < 1024) {
#line 1063
          if (pw->pw_uid != 0U) {
#line 1069
            success = 0;
#line 1070
            packet_send_debug("Server has disabled port forwarding.");
          } else {
#line 1073
            success = channel_setup_remote_fwd_listener((char const   *)listen_address,
                                                        listen_port, options.gateway_ports);
          }
        } else {
#line 1073
          success = channel_setup_remote_fwd_listener((char const   *)listen_address,
                                                      listen_port, options.gateway_ports);
        }
      }
    }
#line 1076
    xfree((void *)listen_address);
  } else {
#line 1077
    if (0) {
#line 1077
      __s1_len = strlen((char const   *)rtype);
#line 1077
      __s2_len = strlen("cancel-tcpip-forward");
#line 1077
      if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
        goto _L___0;
      } else {
#line 1077
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 1077
          if (! ((unsigned int )((void const   *)("cancel-tcpip-forward" + 1)) - (unsigned int )((void const   *)"cancel-tcpip-forward") == 1U)) {
#line 1077
            tmp___14 = 1;
          } else {
#line 1077
            if (__s2_len >= 4U) {
#line 1077
              tmp___14 = 1;
            } else {
#line 1077
              tmp___14 = 0;
            }
          }
        } else {
#line 1077
          tmp___14 = 0;
        }
      }
#line 1077
      if (tmp___14) {
#line 1077
        tmp___10 = __builtin_strcmp((char const   *)rtype, "cancel-tcpip-forward");
      } else {
#line 1077
        tmp___13 = __builtin_strcmp((char const   *)rtype, "cancel-tcpip-forward");
#line 1077
        tmp___10 = tmp___13;
      }
    } else {
#line 1077
      tmp___13 = __builtin_strcmp((char const   *)rtype, "cancel-tcpip-forward");
#line 1077
      tmp___10 = tmp___13;
    }
#line 1077
    if (tmp___10 == 0) {
#line 1081
      tmp___3 = packet_get_string((u_int *)((void *)0));
#line 1081
      cancel_address = (char *)tmp___3;
#line 1082
      tmp___4 = packet_get_int();
#line 1082
      cancel_port = (unsigned short )tmp___4;
#line 1083
      debug("%s: cancel-tcpip-forward addr %s port %d", "server_input_global_request",
            cancel_address, cancel_port);
#line 1086
      success = channel_cancel_rport_listener((char const   *)cancel_address, cancel_port);
    }
  }
#line 1089
  if (want_reply) {
#line 1090
    if (success) {
#line 1090
      tmp___25 = 81;
    } else {
#line 1090
      tmp___25 = 82;
    }
#line 1090
    packet_start((unsigned char )tmp___25);
#line 1092
    packet_send();
#line 1093
    packet_write_wait();
  }
#line 1095
  xfree((void *)rtype);
#line 1096
  return;
}
}
#line 1097 "serverloop.c"
static void server_input_channel_req(int type , u_int32_t seq , void *ctxt ) 
{ Channel *c ;
  int id ;
  int reply ;
  int success ;
  char *rtype ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;

  {
#line 1101
  success = 0;
#line 1104
  tmp = packet_get_int();
#line 1104
  id = (int )tmp;
#line 1105
  tmp___0 = packet_get_string((u_int *)((void *)0));
#line 1105
  rtype = (char *)tmp___0;
#line 1106
  tmp___1 = packet_get_char();
#line 1106
  reply = (int )tmp___1;
#line 1108
  debug("server_input_channel_req: channel %d request %s reply %d", id, rtype, reply);
#line 1111
  c = channel_lookup(id);
#line 1111
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1112
    packet_disconnect("server_input_channel_req: unknown channel %d", id);
  }
#line 1114
  if (c->type == 10) {
#line 1115
    success = session_input_channel_req(c, (char const   *)rtype);
  } else {
#line 1114
    if (c->type == 4) {
#line 1115
      success = session_input_channel_req(c, (char const   *)rtype);
    }
  }
#line 1116
  if (reply) {
#line 1117
    if (success) {
#line 1117
      tmp___2 = 99;
    } else {
#line 1117
      tmp___2 = 100;
    }
#line 1117
    packet_start((unsigned char )tmp___2);
#line 1119
    packet_put_int((unsigned int )c->remote_id);
#line 1120
    packet_send();
  }
#line 1122
  xfree((void *)rtype);
#line 1123
  return;
}
}
#line 1125 "serverloop.c"
static void server_init_dispatch_20(void) 
{ 

  {
#line 1128
  debug("server_init_dispatch_20");
#line 1129
  dispatch_init(& dispatch_protocol_error);
#line 1130
  dispatch_set(97, & channel_input_oclose);
#line 1131
  dispatch_set(94, & channel_input_data);
#line 1132
  dispatch_set(96, & channel_input_ieof);
#line 1133
  dispatch_set(95, & channel_input_extended_data);
#line 1134
  dispatch_set(90, & server_input_channel_open);
#line 1135
  dispatch_set(91, & channel_input_open_confirmation);
#line 1136
  dispatch_set(92, & channel_input_open_failure);
#line 1137
  dispatch_set(98, & server_input_channel_req);
#line 1138
  dispatch_set(93, & channel_input_window_adjust);
#line 1139
  dispatch_set(80, & server_input_global_request);
#line 1141
  dispatch_set(100, & server_input_keep_alive);
#line 1142
  dispatch_set(81, & server_input_keep_alive);
#line 1143
  dispatch_set(82, & server_input_keep_alive);
#line 1145
  dispatch_set(20, & kex_input_kexinit);
#line 1146
  return;
}
}
#line 1147 "serverloop.c"
static void server_init_dispatch_13(void) 
{ 

  {
#line 1150
  debug("server_init_dispatch_13");
#line 1151
  dispatch_init((dispatch_fn *)((void *)0));
#line 1152
  dispatch_set(19, & server_input_eof);
#line 1153
  dispatch_set(16, & server_input_stdin_data);
#line 1154
  dispatch_set(11, & server_input_window_size);
#line 1155
  dispatch_set(24, & channel_input_close);
#line 1156
  dispatch_set(25, & channel_input_close_confirmation);
#line 1157
  dispatch_set(23, & channel_input_data);
#line 1158
  dispatch_set(21, & channel_input_open_confirmation);
#line 1159
  dispatch_set(22, & channel_input_open_failure);
#line 1160
  dispatch_set(29, & channel_input_port_open);
#line 1161
  return;
}
}
#line 1162 "serverloop.c"
static void server_init_dispatch_15(void) 
{ 

  {
#line 1165
  server_init_dispatch_13();
#line 1166
  debug("server_init_dispatch_15");
#line 1167
  dispatch_set(24, & channel_input_ieof);
#line 1168
  dispatch_set(25, & channel_input_oclose);
#line 1169
  return;
}
}
#line 1170 "serverloop.c"
static void server_init_dispatch(void) 
{ 

  {
#line 1173
  if (compat20) {
#line 1174
    server_init_dispatch_20();
  } else {
#line 1175
    if (compat13) {
#line 1176
      server_init_dispatch_13();
    } else {
#line 1178
      server_init_dispatch_15();
    }
  }
#line 1179
  return;
}
}
#line 1 "auth.o"
#line 759 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 218
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64") __attribute__((__nonnull__(2))) ;
#line 756 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *realpath(char const   * __restrict  __name ,
                                                    char * __restrict  __resolved ) ;
#line 27 "/usr/include/libgen.h"
extern  __attribute__((__nothrow__)) char *dirname(char *__path ) ;
#line 32 "groupaccess.h"
int ga_init(char const   *user , gid_t base ) ;
#line 33
int ga_match(char * const  *groups , int n___0 ) ;
#line 34
void ga_free(void) ;
#line 130 "auth.h"
int auth_shadow_acctexpired(struct spwd *spw ) ;
#line 143
void auth_log(Authctxt *authctxt___0 , int authenticated , char *method , char *info ) ;
#line 146
int auth_root_allowed(char *method ) ;
#line 159
int allowed_user(struct passwd *pw ) ;
#line 160
struct passwd *getpwnamallow(char const   *user ) ;
#line 167
char *authorized_keys_file2(struct passwd *pw ) ;
#line 187
struct passwd *fakepw(void) ;
#line 29 "auth-options.h"
char *forced_command ;
#line 135 "loginrec.h"
void record_failed_login(char const   *username , char const   *hostname , char const   *ttyn ) ;
#line 61 "auth.c"
Buffer auth_debug  ;
#line 62 "auth.c"
int auth_debug_init  ;
#line 73 "auth.c"
int allowed_user(struct passwd *pw ) 
{ struct stat st ;
  char const   *hostname ;
  char const   *ipaddr ;
  char const   *passwd ;
  char *shell ;
  u_int i ;
  struct spwd *spw ;
  int tmp ;
  int locked ;
  int tmp___17 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___23 ;
  int tmp___26 ;
  int tmp___27 ;
  size_t tmp___28 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;

  {
#line 77
  hostname = (char const   *)((void *)0);
#line 77
  ipaddr = (char const   *)((void *)0);
#line 77
  passwd = (char const   *)((void *)0);
#line 81
  spw = (struct spwd *)((void *)0);
#line 85
  if (! pw) {
#line 86
    return (0);
  } else {
#line 85
    if (! pw->pw_name) {
#line 86
      return (0);
    }
  }
#line 89
  if (! options.use_pam) {
#line 90
    spw = getspnam((char const   *)pw->pw_name);
  }
#line 92
  if (! options.use_pam) {
#line 92
    if ((unsigned int )spw != (unsigned int )((void *)0)) {
#line 92
      tmp = auth_shadow_acctexpired(spw);
#line 92
      if (tmp) {
#line 93
        return (0);
      }
    }
  }
#line 99
  if ((unsigned int )spw != (unsigned int )((void *)0)) {
#line 103
    passwd = (char const   *)spw->sp_pwdp;
  }
#line 110
  if (! options.use_pam) {
#line 110
    if (passwd) {
#line 110
      if (*passwd) {
#line 111
        locked = 0;
#line 118
        if (0) {
#line 118
          if (0) {
#line 118
            __s1_len___0 = strlen(passwd);
#line 118
            __s2_len___0 = strlen("!");
#line 118
            if (! ((unsigned int )((void const   *)(passwd + 1)) - (unsigned int )((void const   *)passwd) == 1U)) {
              goto _L___2;
            } else {
#line 118
              if (__s1_len___0 >= 4U) {
                _L___2: /* CIL Label */ 
#line 118
                if (! ((unsigned int )((void const   *)("!" + 1)) - (unsigned int )((void const   *)"!") == 1U)) {
#line 118
                  tmp___27 = 1;
                } else {
#line 118
                  if (__s2_len___0 >= 4U) {
#line 118
                    tmp___27 = 1;
                  } else {
#line 118
                    tmp___27 = 0;
                  }
                }
              } else {
#line 118
                tmp___27 = 0;
              }
            }
#line 118
            if (tmp___27) {
#line 118
              tmp___23 = __builtin_strcmp(passwd, "!");
            } else {
#line 118
              tmp___26 = __builtin_strcmp(passwd, "!");
#line 118
              tmp___23 = tmp___26;
            }
          } else {
#line 118
            tmp___26 = __builtin_strcmp(passwd, "!");
#line 118
            tmp___23 = tmp___26;
          }
#line 118
          tmp___17 = tmp___23;
        } else {
#line 118
          tmp___28 = strlen("!");
#line 118
          tmp___17 = strncmp(passwd, "!", tmp___28);
        }
#line 118
        if (tmp___17 == 0) {
#line 120
          locked = 1;
        }
#line 129
        if (locked) {
#line 130
          logit("User %.100s not allowed because account is locked", pw->pw_name);
#line 132
          return (0);
        }
      }
    }
  }
#line 140
  if ((int )*(pw->pw_shell + 0) == 0) {
#line 140
    shell = (char *)"/bin/sh";
  } else {
#line 140
    shell = pw->pw_shell;
  }
#line 143
  tmp___34 = stat((char const   * __restrict  )shell, (struct stat * __restrict  )(& st));
#line 143
  if (tmp___34 != 0) {
#line 144
    logit("User %.100s not allowed because shell %.100s does not exist", pw->pw_name,
          shell);
#line 146
    return (0);
  }
#line 148
  if (((st.st_mode & 61440U) == 32768U) == 0) {
#line 150
    logit("User %.100s not allowed because shell %.100s is not executable", pw->pw_name,
          shell);
#line 152
    return (0);
  } else {
#line 148
    if ((st.st_mode & (unsigned int )((((64 >> 3) >> 3) | 64) | (64 >> 3))) == 0U) {
#line 150
      logit("User %.100s not allowed because shell %.100s is not executable", pw->pw_name,
            shell);
#line 152
      return (0);
    }
  }
#line 155
  if (options.num_deny_users > 0U) {
#line 157
    hostname = get_canonical_hostname(options.use_dns);
#line 158
    ipaddr = get_remote_ipaddr();
  } else {
#line 155
    if (options.num_allow_users > 0U) {
#line 157
      hostname = get_canonical_hostname(options.use_dns);
#line 158
      ipaddr = get_remote_ipaddr();
    } else {
#line 155
      if (options.num_deny_groups > 0U) {
#line 157
        hostname = get_canonical_hostname(options.use_dns);
#line 158
        ipaddr = get_remote_ipaddr();
      } else {
#line 155
        if (options.num_allow_groups > 0U) {
#line 157
          hostname = get_canonical_hostname(options.use_dns);
#line 158
          ipaddr = get_remote_ipaddr();
        }
      }
    }
  }
#line 162
  if (options.num_deny_users > 0U) {
#line 163
    i = 0U;
#line 163
    while (i < options.num_deny_users) {
#line 164
      tmp___35 = match_user((char const   *)pw->pw_name, hostname, ipaddr, (char const   *)options.deny_users[i]);
#line 164
      if (tmp___35) {
#line 166
        logit("User %.100s from %.100s not allowed because listed in DenyUsers", pw->pw_name,
              hostname);
#line 169
        return (0);
      }
#line 163
      i ++;
    }
  }
#line 173
  if (options.num_allow_users > 0U) {
#line 174
    i = 0U;
#line 174
    while (i < options.num_allow_users) {
#line 175
      tmp___36 = match_user((char const   *)pw->pw_name, hostname, ipaddr, (char const   *)options.allow_users[i]);
#line 175
      if (tmp___36) {
#line 177
        break;
      }
#line 174
      i ++;
    }
#line 179
    if (i >= options.num_allow_users) {
#line 180
      logit("User %.100s from %.100s not allowed because not listed in AllowUsers",
            pw->pw_name, hostname);
#line 182
      return (0);
    }
  }
#line 185
  if (options.num_deny_groups > 0U) {
    goto _L___3;
  } else {
#line 185
    if (options.num_allow_groups > 0U) {
      _L___3: /* CIL Label */ 
#line 187
      tmp___37 = ga_init((char const   *)pw->pw_name, pw->pw_gid);
#line 187
      if (tmp___37 == 0) {
#line 188
        logit("User %.100s from %.100s not allowed because not in any group", pw->pw_name,
              hostname);
#line 190
        return (0);
      }
#line 194
      if (options.num_deny_groups > 0U) {
#line 195
        tmp___38 = ga_match((char * const  *)(options.deny_groups), (int )options.num_deny_groups);
#line 195
        if (tmp___38) {
#line 197
          ga_free();
#line 198
          logit("User %.100s from %.100s not allowed because a group is listed in DenyGroups",
                pw->pw_name, hostname);
#line 201
          return (0);
        }
      }
#line 207
      if (options.num_allow_groups > 0U) {
#line 208
        tmp___39 = ga_match((char * const  *)(options.allow_groups), (int )options.num_allow_groups);
#line 208
        if (! tmp___39) {
#line 210
          ga_free();
#line 211
          logit("User %.100s from %.100s not allowed because none of user\'s groups are listed in AllowGroups",
                pw->pw_name, hostname);
#line 214
          return (0);
        }
      }
#line 216
      ga_free();
    }
  }
#line 225
  return (1);
}
}
#line 228 "auth.c"
void auth_log(Authctxt *authctxt___0 , int authenticated , char *method , char *info ) 
{ void (*authlog)(char const   *fmt  , ...) ;
  char *authmsg ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___36 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___42 ;
  int tmp___45 ;
  int tmp___46 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___54 ;
  int tmp___57 ;
  int tmp___58 ;

  {
#line 231
  authlog = (void (*)(char const   *fmt  , ...))(& verbose);
#line 238
  if (authenticated == 1) {
#line 239
    authlog = (void (*)(char const   *fmt  , ...))(& logit);
  } else {
#line 238
    if (! authctxt___0->valid) {
#line 239
      authlog = (void (*)(char const   *fmt  , ...))(& logit);
    } else {
#line 238
      if (authctxt___0->failures >= options.max_authtries / 2) {
#line 239
        authlog = (void (*)(char const   *fmt  , ...))(& logit);
      } else {
#line 238
        if (0) {
#line 238
          __s1_len = strlen((char const   *)method);
#line 238
          __s2_len = strlen("password");
#line 238
          if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
            goto _L___0;
          } else {
#line 238
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 238
              if (! ((unsigned int )((void const   *)("password" + 1)) - (unsigned int )((void const   *)"password") == 1U)) {
#line 238
                tmp___8 = 1;
              } else {
#line 238
                if (__s2_len >= 4U) {
#line 238
                  tmp___8 = 1;
                } else {
#line 238
                  tmp___8 = 0;
                }
              }
            } else {
#line 238
              tmp___8 = 0;
            }
          }
#line 238
          if (tmp___8) {
#line 238
            tmp___4 = __builtin_strcmp((char const   *)method, "password");
          } else {
#line 238
            tmp___7 = __builtin_strcmp((char const   *)method, "password");
#line 238
            tmp___4 = tmp___7;
          }
        } else {
#line 238
          tmp___7 = __builtin_strcmp((char const   *)method, "password");
#line 238
          tmp___4 = tmp___7;
        }
#line 238
        if (tmp___4 == 0) {
#line 239
          authlog = (void (*)(char const   *fmt  , ...))(& logit);
        }
      }
    }
  }
#line 241
  if (authctxt___0->postponed) {
#line 242
    authmsg = (char *)"Postponed";
  } else {
#line 244
    if (authenticated) {
#line 244
      authmsg = (char *)"Accepted";
    } else {
#line 244
      authmsg = (char *)"Failed";
    }
  }
#line 246
  tmp___9 = get_remote_port();
#line 246
  tmp___10 = get_remote_ipaddr();
#line 246
  if (authctxt___0->valid) {
#line 246
    tmp___11 = "";
  } else {
#line 246
    tmp___11 = "invalid user ";
  }
#line 246
  (*authlog)("%s %s for %s%.100s from %.200s port %d%s", authmsg, method, tmp___11,
             authctxt___0->user, tmp___10, tmp___9, info);
#line 259
  if (authenticated == 0) {
#line 259
    if (! authctxt___0->postponed) {
#line 257
      if (0) {
#line 257
        __s1_len___0 = strlen((char const   *)method);
#line 257
        __s2_len___0 = strlen("password");
#line 257
        if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
          goto _L___2;
        } else {
#line 257
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 257
            if (! ((unsigned int )((void const   *)("password" + 1)) - (unsigned int )((void const   *)"password") == 1U)) {
#line 257
              tmp___22 = 1;
            } else {
#line 257
              if (__s2_len___0 >= 4U) {
#line 257
                tmp___22 = 1;
              } else {
#line 257
                tmp___22 = 0;
              }
            }
          } else {
#line 257
            tmp___22 = 0;
          }
        }
#line 257
        if (tmp___22) {
#line 257
          tmp___18 = __builtin_strcmp((char const   *)method, "password");
        } else {
#line 257
          tmp___21 = __builtin_strcmp((char const   *)method, "password");
#line 257
          tmp___18 = tmp___21;
        }
      } else {
#line 257
        tmp___21 = __builtin_strcmp((char const   *)method, "password");
#line 257
        tmp___18 = tmp___21;
      }
#line 259
      if (tmp___18 == 0) {
#line 260
        tmp___12 = get_canonical_hostname(options.use_dns);
#line 260
        record_failed_login((char const   *)authctxt___0->user, tmp___12, "ssh");
      } else {
#line 258
        if (0) {
#line 258
          if (0) {
#line 258
            __s1_len___2 = strlen((char const   *)method);
#line 258
            __s2_len___2 = strlen("keyboard-interactive");
#line 258
            if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
              goto _L___6;
            } else {
#line 258
              if (__s1_len___2 >= 4U) {
                _L___6: /* CIL Label */ 
#line 258
                if (! ((unsigned int )((void const   *)("keyboard-interactive" + 1)) - (unsigned int )((void const   *)"keyboard-interactive") == 1U)) {
#line 258
                  tmp___46 = 1;
                } else {
#line 258
                  if (__s2_len___2 >= 4U) {
#line 258
                    tmp___46 = 1;
                  } else {
#line 258
                    tmp___46 = 0;
                  }
                }
              } else {
#line 258
                tmp___46 = 0;
              }
            }
#line 258
            if (tmp___46) {
#line 258
              tmp___42 = __builtin_strcmp((char const   *)method, "keyboard-interactive");
            } else {
#line 258
              tmp___45 = __builtin_strcmp((char const   *)method, "keyboard-interactive");
#line 258
              tmp___42 = tmp___45;
            }
          } else {
#line 258
            tmp___45 = __builtin_strcmp((char const   *)method, "keyboard-interactive");
#line 258
            tmp___42 = tmp___45;
          }
#line 258
          tmp___36 = tmp___42;
        } else {
#line 258
          tmp___36 = strncmp((char const   *)method, "keyboard-interactive", 20U);
        }
#line 259
        if (tmp___36 == 0) {
#line 260
          tmp___12 = get_canonical_hostname(options.use_dns);
#line 260
          record_failed_login((char const   *)authctxt___0->user, tmp___12, "ssh");
        } else {
#line 259
          if (0) {
#line 259
            __s1_len___3 = strlen((char const   *)method);
#line 259
            __s2_len___3 = strlen("challenge-response");
#line 259
            if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
              goto _L___8;
            } else {
#line 259
              if (__s1_len___3 >= 4U) {
                _L___8: /* CIL Label */ 
#line 259
                if (! ((unsigned int )((void const   *)("challenge-response" + 1)) - (unsigned int )((void const   *)"challenge-response") == 1U)) {
#line 259
                  tmp___58 = 1;
                } else {
#line 259
                  if (__s2_len___3 >= 4U) {
#line 259
                    tmp___58 = 1;
                  } else {
#line 259
                    tmp___58 = 0;
                  }
                }
              } else {
#line 259
                tmp___58 = 0;
              }
            }
#line 259
            if (tmp___58) {
#line 259
              tmp___54 = __builtin_strcmp((char const   *)method, "challenge-response");
            } else {
#line 259
              tmp___57 = __builtin_strcmp((char const   *)method, "challenge-response");
#line 259
              tmp___54 = tmp___57;
            }
          } else {
#line 259
            tmp___57 = __builtin_strcmp((char const   *)method, "challenge-response");
#line 259
            tmp___54 = tmp___57;
          }
#line 259
          if (tmp___54 == 0) {
#line 260
            tmp___12 = get_canonical_hostname(options.use_dns);
#line 260
            record_failed_login((char const   *)authctxt___0->user, tmp___12, "ssh");
          }
        }
      }
    }
  }
#line 301
  return;
}
}
#line 306 "auth.c"
int auth_root_allowed(char *method ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;

  {
#line 309
  switch (options.permit_root_login) {
  case 3: 
#line 311
  return (1);
#line 312
  break;
  case 2: 
#line 314
  if (0) {
#line 314
    __s1_len = strlen((char const   *)method);
#line 314
    __s2_len = strlen("password");
#line 314
    if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
      goto _L___0;
    } else {
#line 314
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 314
        if (! ((unsigned int )((void const   *)("password" + 1)) - (unsigned int )((void const   *)"password") == 1U)) {
#line 314
          tmp___8 = 1;
        } else {
#line 314
          if (__s2_len >= 4U) {
#line 314
            tmp___8 = 1;
          } else {
#line 314
            tmp___8 = 0;
          }
        }
      } else {
#line 314
        tmp___8 = 0;
      }
    }
#line 314
    if (tmp___8) {
#line 314
      tmp___4 = __builtin_strcmp((char const   *)method, "password");
    } else {
#line 314
      tmp___7 = __builtin_strcmp((char const   *)method, "password");
#line 314
      tmp___4 = tmp___7;
    }
  } else {
#line 314
    tmp___7 = __builtin_strcmp((char const   *)method, "password");
#line 314
    tmp___4 = tmp___7;
  }
#line 314
  if (tmp___4 != 0) {
#line 315
    return (1);
  }
#line 316
  break;
  case 1: 
#line 318
  if (forced_command) {
#line 319
    logit("Root login accepted for forced command.");
#line 320
    return (1);
  }
#line 322
  break;
  }
#line 324
  tmp___9 = get_remote_ipaddr();
#line 324
  logit("ROOT LOGIN REFUSED FROM %.200s", tmp___9);
#line 325
  return (0);
}
}
#line 336 "auth.c"
static char *expand_authorized_keys(char const   *filename , struct passwd *pw ) 
{ char *file___0 ;
  char *ret ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 341
  file___0 = percent_expand(filename, "h", pw->pw_dir, "u", pw->pw_name, (char *)((void *)0));
#line 348
  if ((int )*file___0 == 47) {
#line 349
    return (file___0);
  }
#line 351
  tmp = xmalloc(4096U);
#line 351
  ret = (char *)tmp;
#line 352
  tmp___0 = strlcpy(ret, (char const   *)pw->pw_dir, 4096U);
#line 352
  if (tmp___0 >= 4096U) {
#line 355
    fatal("expand_authorized_keys: path too long");
  } else {
#line 352
    tmp___1 = strlcat(ret, "/", 4096U);
#line 352
    if (tmp___1 >= 4096U) {
#line 355
      fatal("expand_authorized_keys: path too long");
    } else {
#line 352
      tmp___2 = strlcat(ret, (char const   *)file___0, 4096U);
#line 352
      if (tmp___2 >= 4096U) {
#line 355
        fatal("expand_authorized_keys: path too long");
      }
    }
  }
#line 357
  xfree((void *)file___0);
#line 358
  return (ret);
}
}
#line 361 "auth.c"
char *authorized_keys_file(struct passwd *pw ) 
{ char *tmp ;

  {
#line 364
  tmp = expand_authorized_keys((char const   *)options.authorized_keys_file, pw);
#line 364
  return (tmp);
}
}
#line 367 "auth.c"
char *authorized_keys_file2(struct passwd *pw ) 
{ char *tmp ;

  {
#line 370
  tmp = expand_authorized_keys((char const   *)options.authorized_keys_file2, pw);
#line 370
  return (tmp);
}
}
#line 374 "auth.c"
HostStatus check_key_in_hostfiles(struct passwd *pw , Key *key , char const   *host ,
                                  char const   *sysfile , char const   *userfile ) 
{ Key *found ;
  char *user_hostfile ;
  struct stat st ;
  HostStatus host_status ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 384
  found = key_new(key->type);
#line 385
  host_status = check_host_in_hostfile(sysfile, host, (Key const   *)key, found, (int *)((void *)0));
#line 387
  if ((int )host_status != 0) {
#line 387
    if ((unsigned int )userfile != (unsigned int )((void *)0)) {
#line 388
      user_hostfile = tilde_expand_filename(userfile, pw->pw_uid);
#line 389
      if (options.strict_modes) {
#line 389
        tmp = stat((char const   * __restrict  )user_hostfile, (struct stat * __restrict  )(& st));
#line 389
        if (tmp == 0) {
#line 389
          if (st.st_uid != 0U) {
#line 389
            if (st.st_uid != pw->pw_uid) {
#line 393
              logit("Authentication refused for %.100s: bad owner or modes for %.200s",
                    pw->pw_name, user_hostfile);
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 389
            if ((st.st_mode & 18U) != 0U) {
#line 393
              logit("Authentication refused for %.100s: bad owner or modes for %.200s",
                    pw->pw_name, user_hostfile);
            } else {
#line 397
              temporarily_use_uid(pw);
#line 398
              host_status = check_host_in_hostfile((char const   *)user_hostfile,
                                                   host, (Key const   *)key, found,
                                                   (int *)((void *)0));
#line 400
              restore_uid();
            }
          }
        } else {
#line 397
          temporarily_use_uid(pw);
#line 398
          host_status = check_host_in_hostfile((char const   *)user_hostfile, host,
                                               (Key const   *)key, found, (int *)((void *)0));
#line 400
          restore_uid();
        }
      } else {
#line 397
        temporarily_use_uid(pw);
#line 398
        host_status = check_host_in_hostfile((char const   *)user_hostfile, host,
                                             (Key const   *)key, found, (int *)((void *)0));
#line 400
        restore_uid();
      }
#line 402
      xfree((void *)user_hostfile);
    }
  }
#line 404
  key_free(found);
#line 406
  if ((int )host_status == 0) {
#line 406
    tmp___0 = "ok";
  } else {
#line 406
    tmp___0 = "not found";
  }
#line 406
  debug2("check_key_in_hostfiles: key %s for %s", tmp___0, host);
#line 408
  return (host_status);
}
}
#line 424 "auth.c"
int secure_filename(FILE *f , char const   *file___0 , struct passwd *pw , char *err ,
                    size_t errlen ) 
{ uid_t uid ;
  char buf___1[4096] ;
  char homedir[4096] ;
  char *cp ;
  int comparehome ;
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___11 ;
  int tmp___14 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___31 ;
  int tmp___34 ;
  int tmp___35 ;

  {
#line 428
  uid = pw->pw_uid;
#line 431
  comparehome = 0;
#line 434
  tmp___1 = realpath((char const   * __restrict  )file___0, (char * __restrict  )(buf___1));
#line 434
  if ((unsigned int )tmp___1 == (unsigned int )((void *)0)) {
#line 435
    tmp = __errno_location();
#line 435
    tmp___0 = strerror(*tmp);
#line 435
    snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"realpath %s failed: %s",
             file___0, tmp___0);
#line 437
    return (-1);
  }
#line 439
  tmp___2 = realpath((char const   * __restrict  )pw->pw_dir, (char * __restrict  )(homedir));
#line 439
  if ((unsigned int )tmp___2 != (unsigned int )((void *)0)) {
#line 440
    comparehome = 1;
  }
#line 443
  tmp___3 = fileno(f);
#line 443
  tmp___4 = fstat(tmp___3, & st);
#line 443
  if (tmp___4 < 0) {
#line 446
    snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for file %s",
             buf___1);
#line 448
    return (-1);
  } else {
#line 443
    if (st.st_uid != 0U) {
#line 443
      if (st.st_uid != uid) {
#line 446
        snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for file %s",
                 buf___1);
#line 448
        return (-1);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 443
      if ((st.st_mode & 18U) != 0U) {
#line 446
        snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for file %s",
                 buf___1);
#line 448
        return (-1);
      }
    }
  }
#line 452
  while (1) {
#line 453
    cp = dirname(buf___1);
#line 453
    if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 454
      snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"dirname() failed");
#line 455
      return (-1);
    }
#line 457
    strlcpy(buf___1, (char const   *)cp, sizeof(buf___1));
#line 459
    debug3("secure_filename: checking \'%s\'", buf___1);
#line 460
    tmp___5 = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )(& st));
#line 460
    if (tmp___5 < 0) {
#line 463
      snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for directory %s",
               buf___1);
#line 465
      return (-1);
    } else {
#line 460
      if (st.st_uid != 0U) {
#line 460
        if (st.st_uid != uid) {
#line 463
          snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for directory %s",
                   buf___1);
#line 465
          return (-1);
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 460
        if ((st.st_mode & 18U) != 0U) {
#line 463
          snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for directory %s",
                   buf___1);
#line 465
          return (-1);
        }
      }
    }
#line 469
    if (comparehome) {
#line 469
      if (0) {
#line 469
        __s1_len = strlen((char const   *)(homedir));
#line 469
        __s2_len = strlen((char const   *)(buf___1));
#line 469
        if (! ((unsigned int )((void const   *)(homedir + 1)) - (unsigned int )((void const   *)(homedir)) == 1U)) {
          goto _L___2;
        } else {
#line 469
          if (__s1_len >= 4U) {
            _L___2: /* CIL Label */ 
#line 469
            if (! ((unsigned int )((void const   *)(buf___1 + 1)) - (unsigned int )((void const   *)(buf___1)) == 1U)) {
#line 469
              tmp___15 = 1;
            } else {
#line 469
              if (__s2_len >= 4U) {
#line 469
                tmp___15 = 1;
              } else {
#line 469
                tmp___15 = 0;
              }
            }
          } else {
#line 469
            tmp___15 = 0;
          }
        }
#line 469
        if (tmp___15) {
#line 469
          tmp___11 = __builtin_strcmp((char const   *)(homedir), (char const   *)(buf___1));
        } else {
#line 469
          tmp___14 = __builtin_strcmp((char const   *)(homedir), (char const   *)(buf___1));
#line 469
          tmp___11 = tmp___14;
        }
      } else {
#line 469
        tmp___14 = __builtin_strcmp((char const   *)(homedir), (char const   *)(buf___1));
#line 469
        tmp___11 = tmp___14;
      }
#line 469
      if (tmp___11 == 0) {
#line 470
        debug3("secure_filename: terminating check at \'%s\'", buf___1);
#line 472
        break;
      }
    }
#line 478
    if (0) {
#line 478
      __s1_len___0 = strlen("/");
#line 478
      __s2_len___0 = strlen((char const   *)(buf___1));
#line 478
      if (! ((unsigned int )((void const   *)("/" + 1)) - (unsigned int )((void const   *)"/") == 1U)) {
        goto _L___4;
      } else {
#line 478
        if (__s1_len___0 >= 4U) {
          _L___4: /* CIL Label */ 
#line 478
          if (! ((unsigned int )((void const   *)(buf___1 + 1)) - (unsigned int )((void const   *)(buf___1)) == 1U)) {
#line 478
            tmp___25 = 1;
          } else {
#line 478
            if (__s2_len___0 >= 4U) {
#line 478
              tmp___25 = 1;
            } else {
#line 478
              tmp___25 = 0;
            }
          }
        } else {
#line 478
          tmp___25 = 0;
        }
      }
#line 478
      if (tmp___25) {
#line 478
        tmp___21 = __builtin_strcmp("/", (char const   *)(buf___1));
      } else {
#line 478
        tmp___24 = __builtin_strcmp("/", (char const   *)(buf___1));
#line 478
        tmp___21 = tmp___24;
      }
    } else {
#line 478
      tmp___24 = __builtin_strcmp("/", (char const   *)(buf___1));
#line 478
      tmp___21 = tmp___24;
    }
#line 478
    if (tmp___21 == 0) {
#line 479
      break;
    } else {
#line 478
      if (0) {
#line 478
        __s1_len___1 = strlen(".");
#line 478
        __s2_len___1 = strlen((char const   *)(buf___1));
#line 478
        if (! ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") == 1U)) {
          goto _L___6;
        } else {
#line 478
          if (__s1_len___1 >= 4U) {
            _L___6: /* CIL Label */ 
#line 478
            if (! ((unsigned int )((void const   *)(buf___1 + 1)) - (unsigned int )((void const   *)(buf___1)) == 1U)) {
#line 478
              tmp___35 = 1;
            } else {
#line 478
              if (__s2_len___1 >= 4U) {
#line 478
                tmp___35 = 1;
              } else {
#line 478
                tmp___35 = 0;
              }
            }
          } else {
#line 478
            tmp___35 = 0;
          }
        }
#line 478
        if (tmp___35) {
#line 478
          tmp___31 = __builtin_strcmp(".", (char const   *)(buf___1));
        } else {
#line 478
          tmp___34 = __builtin_strcmp(".", (char const   *)(buf___1));
#line 478
          tmp___31 = tmp___34;
        }
      } else {
#line 478
        tmp___34 = __builtin_strcmp(".", (char const   *)(buf___1));
#line 478
        tmp___31 = tmp___34;
      }
#line 478
      if (tmp___31 == 0) {
#line 479
        break;
      }
    }
  }
#line 481
  return (0);
}
}
#line 484 "auth.c"
struct passwd *getpwnamallow(char const   *user ) 
{ struct passwd *pw ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  struct passwd *tmp___2 ;

  {
#line 495
  pw = getpwnam(user);
#line 496
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 497
    tmp = get_remote_ipaddr();
#line 497
    logit("Invalid user %.100s from %.100s", user, tmp);
#line 500
    tmp___0 = get_canonical_hostname(options.use_dns);
#line 500
    record_failed_login(user, tmp___0, "ssh");
#line 506
    return ((struct passwd *)((void *)0));
  }
#line 508
  tmp___1 = allowed_user(pw);
#line 508
  if (! tmp___1) {
#line 509
    return ((struct passwd *)((void *)0));
  }
#line 525
  if ((unsigned int )pw != (unsigned int )((void *)0)) {
#line 526
    tmp___2 = pwcopy(pw);
#line 526
    return (tmp___2);
  }
#line 527
  return ((struct passwd *)((void *)0));
}
}
#line 530 "auth.c"
void ( /* format attribute */  auth_debug_add)(char const   *fmt  , ...) 
{ char buf___1[1024] ;
  va_list args ;

  {
#line 536
  if (! auth_debug_init) {
#line 537
    return;
  }
#line 539
  __builtin_va_start(args, fmt);
#line 540
  vsnprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )fmt,
            args);
#line 541
  __builtin_va_end(args);
#line 542
  buffer_put_cstring(& auth_debug, (char const   *)(buf___1));
#line 543
  return;
}
}
#line 545 "auth.c"
void auth_debug_send(void) 
{ char *msg ;
  void *tmp ;
  u_int tmp___0 ;

  {
#line 550
  if (! auth_debug_init) {
#line 551
    return;
  }
#line 552
  while (1) {
#line 552
    tmp___0 = buffer_len(& auth_debug);
#line 552
    if (! tmp___0) {
#line 552
      break;
    }
#line 553
    tmp = buffer_get_string(& auth_debug, (u_int *)((void *)0));
#line 553
    msg = (char *)tmp;
#line 554
    packet_send_debug("%s", msg);
#line 555
    xfree((void *)msg);
  }
#line 557
  return;
}
}
#line 559 "auth.c"
void auth_debug_reset(void) 
{ 

  {
#line 562
  if (auth_debug_init) {
#line 563
    buffer_clear(& auth_debug);
  } else {
#line 565
    buffer_init(& auth_debug);
#line 566
    auth_debug_init = 1;
  }
#line 568
  return;
}
}
#line 573 "auth.c"
static struct passwd fake  ;
#line 570 "auth.c"
struct passwd *fakepw(void) 
{ 

  {
#line 575
  memset((void *)(& fake), 0, sizeof(fake));
#line 576
  fake.pw_name = (char *)"NOUSER";
#line 577
  fake.pw_passwd = (char *)"$2a$06$r3.juUaHZDlIbQaO2dS9FuYxL1W9M81R1Tc92PoSNmzvpEqLkLGrK";
#line 579
  fake.pw_gecos = (char *)"NOUSER";
#line 580
  fake.pw_uid = 4294967295U;
#line 581
  fake.pw_gid = 4294967295U;
#line 585
  fake.pw_dir = (char *)"/nonexist";
#line 586
  fake.pw_shell = (char *)"/nonexist";
#line 588
  return (& fake);
}
}
#line 1 "auth1.o"
#line 162 "auth.h"
char *get_challenge(Authctxt *authctxt___0 ) ;
#line 163
int verify_response(Authctxt *authctxt___0 , char const   *response ) ;
#line 164
void abandon_challenge_response(Authctxt *authctxt___0 ) ;
#line 47 "monitor_wrap.h"
struct passwd *mm_getpwnamallow(char const   *username ) ;
#line 49
int mm_auth_password(struct Authctxt *authctxt___0 , char *password ) ;
#line 34 "auth1.c"
static int auth1_process_password(Authctxt *authctxt___0 , char *info , size_t infolen ) ;
#line 35
static int auth1_process_rsa(Authctxt *authctxt___0 , char *info , size_t infolen ) ;
#line 36
static int auth1_process_rhosts_rsa(Authctxt *authctxt___0 , char *info , size_t infolen ) ;
#line 37
static int auth1_process_tis_challenge(Authctxt *authctxt___0 , char *info , size_t infolen ) ;
#line 38
static int auth1_process_tis_response(Authctxt *authctxt___0 , char *info , size_t infolen ) ;
#line 40 "auth1.c"
static char *client_user  =    (char *)((void *)0);
#line 49 "auth1.c"
struct AuthMethod1  const  auth1_methods[6]  = {      {9, (char *)"password", & options.password_authentication, & auth1_process_password}, 
        {6,
      (char *)"rsa", & options.rsa_authentication, & auth1_process_rsa}, 
        {35, (char *)"rhosts-rsa", & options.rhosts_rsa_authentication, & auth1_process_rhosts_rsa}, 
        {39,
      (char *)"challenge-response", & options.challenge_response_authentication, & auth1_process_tis_challenge}, 
        {41,
      (char *)"challenge-response", & options.challenge_response_authentication, & auth1_process_tis_response}, 
        {-1,
      (char *)((void *)0), (int *)((void *)0), (int (*)(Authctxt * , char * , size_t  ))((void *)0)}};
#line 75 "auth1.c"
static struct AuthMethod1  const  *lookup_authmethod1(int type ) 
{ int i ;

  {
#line 80
  i = 0;
#line 80
  while ((unsigned int )auth1_methods[i].name != (unsigned int )((void *)0)) {
#line 81
    if (auth1_methods[i].type == (int const   )type) {
#line 82
      return (& auth1_methods[i]);
    }
#line 80
    i ++;
  }
#line 84
  return ((struct AuthMethod1  const  *)((void *)0));
}
}
#line 91 "auth1.c"
static char buf[64]  ;
#line 87 "auth1.c"
static char *get_authname(int type ) 
{ struct AuthMethod1  const  *a ;

  {
#line 93
  a = lookup_authmethod1(type);
#line 93
  if ((unsigned int )a != (unsigned int )((void *)0)) {
#line 94
    return ((char *)a->name);
  }
#line 95
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"bad-auth-msg-%d",
           type);
#line 96
  return (buf);
}
}
#line 99 "auth1.c"
static int auth1_process_password(Authctxt *authctxt___0 , char *info , size_t infolen ) 
{ int authenticated ;
  char *password ;
  u_int dlen ;
  void *tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 102
  authenticated = 0;
#line 111
  tmp = packet_get_string(& dlen);
#line 111
  password = (char *)tmp;
#line 112
  while (1) {
#line 112
    tmp___0 = packet_remaining();
#line 112
    _len = tmp___0;
#line 112
    if (_len > 0) {
#line 112
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth1.c",
            112);
#line 112
      packet_disconnect("Packet integrity error.");
    }
#line 112
    break;
  }
#line 115
  if (use_privsep) {
#line 115
    authenticated = mm_auth_password(authctxt___0, password);
  } else {
#line 115
    authenticated = auth_password(authctxt___0, (char const   *)password);
  }
#line 117
  memset((void *)password, 0, dlen);
#line 118
  xfree((void *)password);
#line 120
  return (authenticated);
}
}
#line 123 "auth1.c"
static int auth1_process_rsa(Authctxt *authctxt___0 , char *info , size_t infolen ) 
{ int authenticated ;
  BIGNUM *n___0 ;
  int _len ;
  int tmp ;

  {
#line 126
  authenticated = 0;
#line 130
  n___0 = BN_new();
#line 130
  if ((unsigned int )n___0 == (unsigned int )((void *)0)) {
#line 131
    fatal("do_authloop: BN_new failed");
  }
#line 132
  packet_get_bignum(n___0);
#line 133
  while (1) {
#line 133
    tmp = packet_remaining();
#line 133
    _len = tmp;
#line 133
    if (_len > 0) {
#line 133
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth1.c",
            133);
#line 133
      packet_disconnect("Packet integrity error.");
    }
#line 133
    break;
  }
#line 134
  authenticated = auth_rsa(authctxt___0, n___0);
#line 135
  BN_clear_free(n___0);
#line 137
  return (authenticated);
}
}
#line 140 "auth1.c"
static int auth1_process_rhosts_rsa(Authctxt *authctxt___0 , char *info , size_t infolen ) 
{ int keybits ;
  int authenticated ;
  u_int bits ;
  Key *client_host_key ;
  u_int ulen ;
  void *tmp ;
  int tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 143
  authenticated = 0;
#line 153
  tmp = packet_get_string(& ulen);
#line 153
  client_user = (char *)tmp;
#line 156
  client_host_key = key_new(0);
#line 157
  bits = packet_get_int();
#line 158
  packet_get_bignum((client_host_key->rsa)->e);
#line 159
  packet_get_bignum((client_host_key->rsa)->n);
#line 161
  keybits = BN_num_bits((BIGNUM const   *)(client_host_key->rsa)->n);
#line 162
  if (keybits < 0) {
#line 163
    tmp___0 = BN_num_bits((BIGNUM const   *)(client_host_key->rsa)->n);
#line 163
    verbose("Warning: keysize mismatch for client_host_key: actual %d, announced %d",
            tmp___0, bits);
  } else {
#line 162
    if (bits != (unsigned int )keybits) {
#line 163
      tmp___0 = BN_num_bits((BIGNUM const   *)(client_host_key->rsa)->n);
#line 163
      verbose("Warning: keysize mismatch for client_host_key: actual %d, announced %d",
              tmp___0, bits);
    }
  }
#line 167
  while (1) {
#line 167
    tmp___1 = packet_remaining();
#line 167
    _len = tmp___1;
#line 167
    if (_len > 0) {
#line 167
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth1.c",
            167);
#line 167
      packet_disconnect("Packet integrity error.");
    }
#line 167
    break;
  }
#line 169
  authenticated = auth_rhosts_rsa(authctxt___0, client_user, client_host_key);
#line 171
  key_free(client_host_key);
#line 173
  snprintf((char * __restrict  )info, infolen, (char const   * __restrict  )" ruser %.100s",
           client_user);
#line 175
  return (authenticated);
}
}
#line 178 "auth1.c"
static int auth1_process_tis_challenge(Authctxt *authctxt___0 , char *info , size_t infolen ) 
{ char *challenge ;

  {
#line 183
  challenge = get_challenge(authctxt___0);
#line 183
  if ((unsigned int )challenge == (unsigned int )((void *)0)) {
#line 184
    return (0);
  }
#line 186
  debug("sending challenge \'%s\'", challenge);
#line 187
  packet_start((unsigned char)40);
#line 188
  packet_put_cstring((char const   *)challenge);
#line 189
  xfree((void *)challenge);
#line 190
  packet_send();
#line 191
  packet_write_wait();
#line 193
  return (-1);
}
}
#line 196 "auth1.c"
static int auth1_process_tis_response(Authctxt *authctxt___0 , char *info , size_t infolen ) 
{ int authenticated ;
  char *response ;
  u_int dlen ;
  void *tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 199
  authenticated = 0;
#line 203
  tmp = packet_get_string(& dlen);
#line 203
  response = (char *)tmp;
#line 204
  while (1) {
#line 204
    tmp___0 = packet_remaining();
#line 204
    _len = tmp___0;
#line 204
    if (_len > 0) {
#line 204
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth1.c",
            204);
#line 204
      packet_disconnect("Packet integrity error.");
    }
#line 204
    break;
  }
#line 205
  authenticated = verify_response(authctxt___0, (char const   *)response);
#line 206
  memset((void *)response, 'r', dlen);
#line 207
  xfree((void *)response);
#line 209
  return (authenticated);
}
}
#line 216 "auth1.c"
static void do_authloop(Authctxt *authctxt___0 ) 
{ int authenticated ;
  char info[1024] ;
  int prev ;
  int type ;
  struct AuthMethod1  const  *meth ;
  char const   *tmp ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 219
  authenticated = 0;
#line 221
  prev = 0;
#line 221
  type = 0;
#line 224
  if (authctxt___0->valid) {
#line 224
    tmp = "";
  } else {
#line 224
    tmp = "invalid user ";
  }
#line 224
  debug("Attempting authentication for %s%.100s.", tmp, authctxt___0->user);
#line 228
  if (options.password_authentication) {
#line 228
    if (use_privsep) {
#line 228
      tmp___2 = mm_auth_password(authctxt___0, (char *)"");
    } else {
#line 228
      tmp___2 = auth_password(authctxt___0, "");
    }
#line 228
    if (tmp___2) {
#line 237
      auth_log(authctxt___0, 1, (char *)"without authentication", (char *)"");
#line 238
      return;
    }
  }
#line 243
  packet_start((unsigned char)15);
#line 244
  packet_send();
#line 245
  packet_write_wait();
#line 247
  while (1) {
#line 249
    authenticated = 0;
#line 251
    info[0] = (char )'\000';
#line 254
    prev = type;
#line 255
    type = packet_read();
#line 264
    if (prev == 39) {
#line 264
      if (type != 41) {
#line 266
        abandon_challenge_response(authctxt___0);
      }
    }
#line 268
    meth = lookup_authmethod1(type);
#line 268
    if ((unsigned int )meth == (unsigned int )((void *)0)) {
#line 269
      logit("Unknown message during authentication: type %d", type);
      goto skip;
    }
#line 274
    if (! *(meth->enabled)) {
#line 275
      verbose("%s authentication disabled.", meth->name);
      goto skip;
    }
#line 279
    authenticated = (*(meth->method))(authctxt___0, info, sizeof(info));
#line 280
    if (authenticated == -1) {
      goto __Cont;
    }
#line 289
    if (! authctxt___0->valid) {
#line 289
      if (authenticated) {
#line 290
        fatal("INTERNAL ERROR: authenticated invalid user %s", authctxt___0->user);
      }
    }
#line 310
    if (authenticated) {
#line 310
      if ((authctxt___0->pw)->pw_uid == 0U) {
#line 310
        tmp___3 = auth_root_allowed((char *)meth->name);
#line 310
        if (! tmp___3) {
#line 312
          authenticated = 0;
        }
      }
    }
    skip: 
#line 342
    tmp___4 = get_authname(type);
#line 342
    auth_log(authctxt___0, authenticated, tmp___4, info);
#line 344
    if ((unsigned int )client_user != (unsigned int )((void *)0)) {
#line 345
      xfree((void *)client_user);
#line 346
      client_user = (char *)((void *)0);
    }
#line 349
    if (authenticated) {
#line 350
      return;
    }
#line 352
    tmp___5 = authctxt___0->failures;
#line 352
    (authctxt___0->failures) ++;
#line 352
    if (tmp___5 > options.max_authtries) {
#line 356
      packet_disconnect("Too many authentication failures for %.100s", authctxt___0->user);
    }
#line 359
    packet_start((unsigned char)15);
#line 360
    packet_send();
#line 361
    packet_write_wait();
    __Cont: /* CIL Label */ ;
  }
}
}
#line 369 "auth1.c"
void do_authentication(Authctxt *authctxt___0 ) 
{ u_int ulen ;
  char *user ;
  char *style ;
  void *tmp ;
  int _len ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___3 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  __uid_t tmp___8 ;
  __uid_t tmp___9 ;

  {
#line 373
  style = (char *)((void *)0);
#line 376
  packet_read_expect(4);
#line 379
  tmp = packet_get_string(& ulen);
#line 379
  user = (char *)tmp;
#line 380
  while (1) {
#line 380
    tmp___0 = packet_remaining();
#line 380
    _len = tmp___0;
#line 380
    if (_len > 0) {
#line 380
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth1.c",
            380);
#line 380
      packet_disconnect("Packet integrity error.");
    }
#line 380
    break;
  }
#line 382
  tmp___3 = __builtin_strchr(user, ':');
#line 382
  style = tmp___3;
#line 382
  if ((unsigned int )style != (unsigned int )((void *)0)) {
#line 383
    tmp___1 = style;
#line 383
    style ++;
#line 383
    *tmp___1 = (char )'\000';
  }
#line 385
  authctxt___0->user = user;
#line 386
  authctxt___0->style = style;
#line 389
  if (use_privsep) {
#line 389
    authctxt___0->pw = mm_getpwnamallow((char const   *)user);
  } else {
#line 389
    authctxt___0->pw = getpwnamallow((char const   *)user);
  }
#line 389
  if ((unsigned int )authctxt___0->pw != (unsigned int )((void *)0)) {
#line 390
    authctxt___0->valid = 1;
  } else {
#line 392
    debug("do_authentication: invalid user %s", user);
#line 393
    authctxt___0->pw = fakepw();
  }
#line 396
  if (use_privsep) {
#line 396
    tmp___6 = " [net]";
  } else {
#line 396
    tmp___6 = "";
  }
#line 396
  if (authctxt___0->valid) {
#line 396
    tmp___7 = (char const   *)user;
  } else {
#line 396
    tmp___7 = "unknown";
  }
#line 396
  setproctitle("%s%s", tmp___7, tmp___6);
#line 409
  if (! use_privsep) {
#line 409
    tmp___8 = getuid();
#line 409
    if (tmp___8 != 0U) {
#line 409
      if (authctxt___0->pw) {
#line 409
        tmp___9 = getuid();
#line 409
        if ((authctxt___0->pw)->pw_uid != tmp___9) {
#line 411
          packet_disconnect("Cannot change user when server not running as root.");
        }
      }
    }
  }
#line 418
  do_authloop(authctxt___0);
#line 421
  packet_start((unsigned char)14);
#line 422
  packet_send();
#line 423
  packet_write_wait();
#line 424
  return;
}
}
#line 1 "auth2.o"
#line 144 "auth.h"
void userauth_finish(Authctxt *authctxt___0 , int authenticated , char *method ) ;
#line 153
void auth2_challenge_stop(Authctxt *authctxt___0 ) ;
#line 46 "monitor_wrap.h"
void mm_inform_authserv(char *service , char *style ) ;
#line 52 "auth2.c"
Authmethod method_none ;
#line 53
Authmethod method_pubkey ;
#line 54
Authmethod method_passwd ;
#line 55
Authmethod method_kbdint ;
#line 56
Authmethod method_hostbased ;
#line 61 "auth2.c"
Authmethod *authmethods[6]  = {      & method_none,      & method_pubkey,      & method_passwd,      & method_kbdint, 
        & method_hostbased,      (Authmethod *)((void *)0)};
#line 75
static void input_service_request(int type , u_int32_t seq , void *ctxt ) ;
#line 76
static void input_userauth_request(int type , u_int32_t seq , void *ctxt ) ;
#line 79
static Authmethod *authmethod_lookup(char const   *name ) ;
#line 80
static char *authmethods_get(void) ;
#line 87 "auth2.c"
void do_authentication2(Authctxt *authctxt___0 ) 
{ 

  {
#line 91
  if (options.challenge_response_authentication) {
#line 92
    options.kbd_interactive_authentication = 1;
  }
#line 94
  dispatch_init(& dispatch_protocol_error);
#line 95
  dispatch_set(5, & input_service_request);
#line 96
  dispatch_run(0, & authctxt___0->success, (void *)authctxt___0);
#line 97
  return;
}
}
#line 99 "auth2.c"
static void input_service_request(int type , u_int32_t seq , void *ctxt ) 
{ Authctxt *authctxt___0 ;
  u_int len ;
  int acceptit ;
  char *service ;
  void *tmp ;
  int _len ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 102
  authctxt___0 = (Authctxt *)ctxt;
#line 104
  acceptit = 0;
#line 105
  tmp = packet_get_string(& len);
#line 105
  service = (char *)tmp;
#line 106
  while (1) {
#line 106
    tmp___0 = packet_remaining();
#line 106
    _len = tmp___0;
#line 106
    if (_len > 0) {
#line 106
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
            106);
#line 106
      packet_disconnect("Packet integrity error.");
    }
#line 106
    break;
  }
#line 108
  if ((unsigned int )authctxt___0 == (unsigned int )((void *)0)) {
#line 109
    fatal("input_service_request: no authctxt");
  }
#line 111
  if (0) {
#line 111
    __s1_len = strlen((char const   *)service);
#line 111
    __s2_len = strlen("ssh-userauth");
#line 111
    if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
      goto _L___0;
    } else {
#line 111
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 111
        if (! ((unsigned int )((void const   *)("ssh-userauth" + 1)) - (unsigned int )((void const   *)"ssh-userauth") == 1U)) {
#line 111
          tmp___10 = 1;
        } else {
#line 111
          if (__s2_len >= 4U) {
#line 111
            tmp___10 = 1;
          } else {
#line 111
            tmp___10 = 0;
          }
        }
      } else {
#line 111
        tmp___10 = 0;
      }
    }
#line 111
    if (tmp___10) {
#line 111
      tmp___6 = __builtin_strcmp((char const   *)service, "ssh-userauth");
    } else {
#line 111
      tmp___9 = __builtin_strcmp((char const   *)service, "ssh-userauth");
#line 111
      tmp___6 = tmp___9;
    }
  } else {
#line 111
    tmp___9 = __builtin_strcmp((char const   *)service, "ssh-userauth");
#line 111
    tmp___6 = tmp___9;
  }
#line 111
  if (tmp___6 == 0) {
#line 112
    if (! authctxt___0->success) {
#line 113
      acceptit = 1;
#line 115
      dispatch_set(50, & input_userauth_request);
    }
  }
#line 120
  if (acceptit) {
#line 121
    packet_start((unsigned char)6);
#line 122
    packet_put_cstring((char const   *)service);
#line 123
    packet_send();
#line 124
    packet_write_wait();
  } else {
#line 126
    debug("bad service request %s", service);
#line 127
    packet_disconnect("bad service request %s", service);
  }
#line 129
  xfree((void *)service);
#line 130
  return;
}
}
#line 132 "auth2.c"
static void input_userauth_request(int type , u_int32_t seq , void *ctxt ) 
{ Authctxt *authctxt___0 ;
  Authmethod *m___0 ;
  char *user ;
  char *service ;
  char *method ;
  char *style ;
  int authenticated ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___4 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___12 ;
  int tmp___15 ;
  int tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___25 ;
  int tmp___28 ;
  int tmp___29 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___35 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;

  {
#line 135
  authctxt___0 = (Authctxt *)ctxt;
#line 136
  m___0 = (Authmethod *)((void *)0);
#line 137
  style = (char *)((void *)0);
#line 138
  authenticated = 0;
#line 140
  if ((unsigned int )authctxt___0 == (unsigned int )((void *)0)) {
#line 141
    fatal("input_userauth_request: no authctxt");
  }
#line 143
  tmp = packet_get_string((u_int *)((void *)0));
#line 143
  user = (char *)tmp;
#line 144
  tmp___0 = packet_get_string((u_int *)((void *)0));
#line 144
  service = (char *)tmp___0;
#line 145
  tmp___1 = packet_get_string((u_int *)((void *)0));
#line 145
  method = (char *)tmp___1;
#line 146
  debug("userauth-request for user %s service %s method %s", user, service, method);
#line 147
  debug("attempt %d failures %d", authctxt___0->attempt, authctxt___0->failures);
#line 149
  tmp___4 = __builtin_strchr(user, ':');
#line 149
  style = tmp___4;
#line 149
  if ((unsigned int )style != (unsigned int )((void *)0)) {
#line 150
    tmp___2 = style;
#line 150
    style ++;
#line 150
    *tmp___2 = (char)0;
  }
#line 152
  tmp___40 = authctxt___0->attempt;
#line 152
  (authctxt___0->attempt) ++;
#line 152
  if (tmp___40 == 0) {
#line 154
    if (use_privsep) {
#line 154
      authctxt___0->pw = mm_getpwnamallow((char const   *)user);
    } else {
#line 154
      authctxt___0->pw = getpwnamallow((char const   *)user);
    }
#line 155
    authctxt___0->user = xstrdup((char const   *)user);
#line 156
    if (authctxt___0->pw) {
#line 156
      if (0) {
#line 156
        __s1_len = strlen((char const   *)service);
#line 156
        __s2_len = strlen("ssh-connection");
#line 156
        if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
          goto _L___0;
        } else {
#line 156
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 156
            if (! ((unsigned int )((void const   *)("ssh-connection" + 1)) - (unsigned int )((void const   *)"ssh-connection") == 1U)) {
#line 156
              tmp___16 = 1;
            } else {
#line 156
              if (__s2_len >= 4U) {
#line 156
                tmp___16 = 1;
              } else {
#line 156
                tmp___16 = 0;
              }
            }
          } else {
#line 156
            tmp___16 = 0;
          }
        }
#line 156
        if (tmp___16) {
#line 156
          tmp___12 = __builtin_strcmp((char const   *)service, "ssh-connection");
        } else {
#line 156
          tmp___15 = __builtin_strcmp((char const   *)service, "ssh-connection");
#line 156
          tmp___12 = tmp___15;
        }
      } else {
#line 156
        tmp___15 = __builtin_strcmp((char const   *)service, "ssh-connection");
#line 156
        tmp___12 = tmp___15;
      }
#line 156
      if (tmp___12 == 0) {
#line 157
        authctxt___0->valid = 1;
#line 158
        debug2("input_userauth_request: setting up authctxt for %s", user);
      } else {
#line 160
        logit("input_userauth_request: invalid user %s", user);
#line 161
        authctxt___0->pw = fakepw();
      }
    } else {
#line 160
      logit("input_userauth_request: invalid user %s", user);
#line 161
      authctxt___0->pw = fakepw();
    }
#line 170
    if (use_privsep) {
#line 170
      tmp___17 = " [net]";
    } else {
#line 170
      tmp___17 = "";
    }
#line 170
    if (authctxt___0->valid) {
#line 170
      tmp___18 = (char const   *)user;
    } else {
#line 170
      tmp___18 = "unknown";
    }
#line 170
    setproctitle("%s%s", tmp___18, tmp___17);
#line 172
    authctxt___0->service = xstrdup((char const   *)service);
#line 173
    if (style) {
#line 173
      authctxt___0->style = xstrdup((char const   *)style);
    } else {
#line 173
      authctxt___0->style = (char *)((void *)0);
    }
#line 174
    if (use_privsep) {
#line 175
      mm_inform_authserv(service, style);
    }
  } else {
#line 176
    if (0) {
#line 176
      __s1_len___0 = strlen((char const   *)user);
#line 176
      __s2_len___0 = strlen((char const   *)authctxt___0->user);
#line 176
      if (! ((unsigned int )((void const   *)(user + 1)) - (unsigned int )((void const   *)user) == 1U)) {
        goto _L___2;
      } else {
#line 176
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 176
          if (! ((unsigned int )((void const   *)(authctxt___0->user + 1)) - (unsigned int )((void const   *)authctxt___0->user) == 1U)) {
#line 176
            tmp___29 = 1;
          } else {
#line 176
            if (__s2_len___0 >= 4U) {
#line 176
              tmp___29 = 1;
            } else {
#line 176
              tmp___29 = 0;
            }
          }
        } else {
#line 176
          tmp___29 = 0;
        }
      }
#line 176
      if (tmp___29) {
#line 176
        tmp___25 = __builtin_strcmp((char const   *)user, (char const   *)authctxt___0->user);
      } else {
#line 176
        tmp___28 = __builtin_strcmp((char const   *)user, (char const   *)authctxt___0->user);
#line 176
        tmp___25 = tmp___28;
      }
    } else {
#line 176
      tmp___28 = __builtin_strcmp((char const   *)user, (char const   *)authctxt___0->user);
#line 176
      tmp___25 = tmp___28;
    }
#line 177
    if (tmp___25 != 0) {
#line 178
      packet_disconnect("Change of username or service not allowed: (%s,%s) -> (%s,%s)",
                        authctxt___0->user, authctxt___0->service, user, service);
    } else {
#line 177
      if (0) {
#line 177
        __s1_len___1 = strlen((char const   *)service);
#line 177
        __s2_len___1 = strlen((char const   *)authctxt___0->service);
#line 177
        if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
          goto _L___4;
        } else {
#line 177
          if (__s1_len___1 >= 4U) {
            _L___4: /* CIL Label */ 
#line 177
            if (! ((unsigned int )((void const   *)(authctxt___0->service + 1)) - (unsigned int )((void const   *)authctxt___0->service) == 1U)) {
#line 177
              tmp___39 = 1;
            } else {
#line 177
              if (__s2_len___1 >= 4U) {
#line 177
                tmp___39 = 1;
              } else {
#line 177
                tmp___39 = 0;
              }
            }
          } else {
#line 177
            tmp___39 = 0;
          }
        }
#line 177
        if (tmp___39) {
#line 177
          tmp___35 = __builtin_strcmp((char const   *)service, (char const   *)authctxt___0->service);
        } else {
#line 177
          tmp___38 = __builtin_strcmp((char const   *)service, (char const   *)authctxt___0->service);
#line 177
          tmp___35 = tmp___38;
        }
      } else {
#line 177
        tmp___38 = __builtin_strcmp((char const   *)service, (char const   *)authctxt___0->service);
#line 177
        tmp___35 = tmp___38;
      }
#line 177
      if (tmp___35 != 0) {
#line 178
        packet_disconnect("Change of username or service not allowed: (%s,%s) -> (%s,%s)",
                          authctxt___0->user, authctxt___0->service, user, service);
      }
    }
  }
#line 183
  auth2_challenge_stop(authctxt___0);
#line 190
  authctxt___0->postponed = 0;
#line 193
  m___0 = authmethod_lookup((char const   *)method);
#line 194
  if ((unsigned int )m___0 != (unsigned int )((void *)0)) {
#line 195
    debug2("input_userauth_request: try method %s", method);
#line 196
    authenticated = (*(m___0->userauth))(authctxt___0);
  }
#line 198
  userauth_finish(authctxt___0, authenticated, method);
#line 200
  xfree((void *)service);
#line 201
  xfree((void *)user);
#line 202
  xfree((void *)method);
#line 203
  return;
}
}
#line 205 "auth2.c"
void userauth_finish(Authctxt *authctxt___0 , int authenticated , char *method ) 
{ char *methods ;
  int tmp ;
  int tmp___0 ;

  {
#line 210
  if (! authctxt___0->valid) {
#line 210
    if (authenticated) {
#line 211
      fatal("INTERNAL ERROR: authenticated invalid user %s", authctxt___0->user);
    }
  }
#line 215
  if (authenticated) {
#line 215
    if ((authctxt___0->pw)->pw_uid == 0U) {
#line 215
      tmp = auth_root_allowed(method);
#line 215
      if (! tmp) {
#line 217
        authenticated = 0;
      }
    }
  }
#line 246
  auth_log(authctxt___0, authenticated, method, (char *)" ssh2");
#line 248
  if (authctxt___0->postponed) {
#line 249
    return;
  }
#line 252
  if (authenticated == 1) {
#line 254
    dispatch_set(50, & dispatch_protocol_ignore);
#line 255
    packet_start((unsigned char)52);
#line 256
    packet_send();
#line 257
    packet_write_wait();
#line 259
    authctxt___0->success = 1;
  } else {
#line 261
    tmp___0 = authctxt___0->failures;
#line 261
    (authctxt___0->failures) ++;
#line 261
    if (tmp___0 > options.max_authtries) {
#line 265
      packet_disconnect("Too many authentication failures for %.100s", authctxt___0->user);
    }
#line 267
    methods = authmethods_get();
#line 268
    packet_start((unsigned char)51);
#line 269
    packet_put_cstring((char const   *)methods);
#line 270
    packet_put_char(0);
#line 271
    packet_send();
#line 272
    packet_write_wait();
#line 273
    xfree((void *)methods);
  }
#line 275
  return;
}
}
#line 279 "auth2.c"
static char *authmethods_get(void) 
{ Buffer b ;
  char *list ;
  int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  u_int tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;

  {
#line 286
  buffer_init(& b);
#line 287
  i = 0;
#line 287
  while ((unsigned int )authmethods[i] != (unsigned int )((void *)0)) {
#line 288
    if (0) {
#line 288
      __s1_len = strlen((char const   *)(authmethods[i])->name);
#line 288
      __s2_len = strlen("none");
#line 288
      if (! ((unsigned int )((void const   *)((authmethods[i])->name + 1)) - (unsigned int )((void const   *)(authmethods[i])->name) == 1U)) {
        goto _L___0;
      } else {
#line 288
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 288
          if (! ((unsigned int )((void const   *)("none" + 1)) - (unsigned int )((void const   *)"none") == 1U)) {
#line 288
            tmp___8 = 1;
          } else {
#line 288
            if (__s2_len >= 4U) {
#line 288
              tmp___8 = 1;
            } else {
#line 288
              tmp___8 = 0;
            }
          }
        } else {
#line 288
          tmp___8 = 0;
        }
      }
#line 288
      if (tmp___8) {
#line 288
        tmp___4 = __builtin_strcmp((char const   *)(authmethods[i])->name, "none");
      } else {
#line 288
        tmp___7 = __builtin_strcmp((char const   *)(authmethods[i])->name, "none");
#line 288
        tmp___4 = tmp___7;
      }
    } else {
#line 288
      tmp___7 = __builtin_strcmp((char const   *)(authmethods[i])->name, "none");
#line 288
      tmp___4 = tmp___7;
    }
#line 288
    if (tmp___4 == 0) {
      goto __Cont;
    }
#line 290
    if ((unsigned int )(authmethods[i])->enabled != (unsigned int )((void *)0)) {
#line 290
      if (*((authmethods[i])->enabled) != 0) {
#line 292
        tmp___9 = buffer_len(& b);
#line 292
        if (tmp___9 > 0U) {
#line 293
          buffer_append(& b, (void const   *)",", 1U);
        }
#line 294
        tmp___10 = strlen((char const   *)(authmethods[i])->name);
#line 294
        buffer_append(& b, (void const   *)(authmethods[i])->name, tmp___10);
      }
    }
    __Cont: /* CIL Label */ 
#line 287
    i ++;
  }
#line 298
  buffer_append(& b, (void const   *)"\000", 1U);
#line 299
  tmp___11 = buffer_ptr(& b);
#line 299
  list = xstrdup((char const   *)tmp___11);
#line 300
  buffer_free(& b);
#line 301
  return (list);
}
}
#line 304 "auth2.c"
static Authmethod *authmethod_lookup(char const   *name ) 
{ int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;

  {
#line 309
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 310
    i = 0;
#line 310
    while ((unsigned int )authmethods[i] != (unsigned int )((void *)0)) {
#line 313
      if ((unsigned int )(authmethods[i])->enabled != (unsigned int )((void *)0)) {
#line 313
        if (*((authmethods[i])->enabled) != 0) {
#line 313
          if (0) {
#line 313
            __s1_len = strlen(name);
#line 313
            __s2_len = strlen((char const   *)(authmethods[i])->name);
#line 313
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
              goto _L___0;
            } else {
#line 313
              if (__s1_len >= 4U) {
                _L___0: /* CIL Label */ 
#line 313
                if (! ((unsigned int )((void const   *)((authmethods[i])->name + 1)) - (unsigned int )((void const   *)(authmethods[i])->name) == 1U)) {
#line 313
                  tmp___8 = 1;
                } else {
#line 313
                  if (__s2_len >= 4U) {
#line 313
                    tmp___8 = 1;
                  } else {
#line 313
                    tmp___8 = 0;
                  }
                }
              } else {
#line 313
                tmp___8 = 0;
              }
            }
#line 313
            if (tmp___8) {
#line 313
              tmp___4 = __builtin_strcmp(name, (char const   *)(authmethods[i])->name);
            } else {
#line 313
              tmp___7 = __builtin_strcmp(name, (char const   *)(authmethods[i])->name);
#line 313
              tmp___4 = tmp___7;
            }
          } else {
#line 313
            tmp___7 = __builtin_strcmp(name, (char const   *)(authmethods[i])->name);
#line 313
            tmp___4 = tmp___7;
          }
#line 313
          if (tmp___4 == 0) {
#line 314
            return (authmethods[i]);
          }
        }
      }
#line 310
      i ++;
    }
  }
#line 315
  if (name) {
#line 315
    tmp___9 = name;
  } else {
#line 315
    tmp___9 = "NULL";
  }
#line 315
  debug2("Unrecognized authentication method name: %s", tmp___9);
#line 317
  return ((Authmethod *)((void *)0));
}
}
#line 1 "auth-options.o"
#line 329 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 28 "auth-options.h"
int no_pty_flag ;
#line 30
struct envstring *custom_environment ;
#line 27 "auth-options.c"
int no_port_forwarding_flag  =    0;
#line 28 "auth-options.c"
int no_agent_forwarding_flag  =    0;
#line 29 "auth-options.c"
int no_x11_forwarding_flag  =    0;
#line 30 "auth-options.c"
int no_pty_flag  =    0;
#line 33 "auth-options.c"
char *forced_command  =    (char *)((void *)0);
#line 36 "auth-options.c"
struct envstring *custom_environment  =    (struct envstring *)((void *)0);
#line 39 "auth-options.c"
int forced_tun_device  =    -1;
#line 43 "auth-options.c"
void auth_clear_options(void) 
{ struct envstring *ce ;

  {
#line 46
  no_agent_forwarding_flag = 0;
#line 47
  no_port_forwarding_flag = 0;
#line 48
  no_pty_flag = 0;
#line 49
  no_x11_forwarding_flag = 0;
#line 50
  while (custom_environment) {
#line 51
    ce = custom_environment;
#line 52
    custom_environment = ce->next;
#line 53
    xfree((void *)ce->s);
#line 54
    xfree((void *)ce);
  }
#line 56
  if (forced_command) {
#line 57
    xfree((void *)forced_command);
#line 58
    forced_command = (char *)((void *)0);
  }
#line 60
  forced_tun_device = -1;
#line 61
  channel_clear_permitted_opens();
#line 62
  auth_debug_reset();
#line 63
  return;
}
}
#line 69 "auth-options.c"
int auth_parse_options(struct passwd *pw , char *opts , char *file___0 , u_long linenum ) 
{ char const   *cp ;
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  size_t tmp___17 ;
  int tmp___18 ;
  char *s ;
  struct envstring *new_envstring ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  void *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  void *tmp___25 ;
  size_t tmp___26 ;
  int tmp___27 ;
  char const   *remote_ip___0 ;
  char const   *tmp___28 ;
  char const   *remote_host ;
  char const   *tmp___29 ;
  char *patterns ;
  size_t tmp___30 ;
  void *tmp___31 ;
  size_t tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  size_t tmp___37 ;
  int tmp___38 ;
  char *host ;
  char *p ;
  u_short port___0 ;
  char *patterns___0 ;
  size_t tmp___39 ;
  void *tmp___40 ;
  size_t tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  char *tmp___44 ;
  size_t tmp___45 ;
  char const   *tmp___46 ;
  int tmp___47 ;
  size_t tmp___48 ;
  int tmp___49 ;
  char *tun ;
  size_t tmp___50 ;
  size_t tmp___51 ;
  void *tmp___52 ;
  int tmp___53 ;
  char *tmp___54 ;
  size_t tmp___55 ;
  int tmp___56 ;

  {
#line 76
  auth_clear_options();
#line 78
  if (! opts) {
#line 79
    return (1);
  }
#line 81
  while (1) {
#line 81
    if (*opts) {
#line 81
      if ((int )*opts != 32) {
#line 81
        if (! ((int )*opts != 9)) {
#line 81
          break;
        }
      } else {
#line 81
        break;
      }
    } else {
#line 81
      break;
    }
#line 82
    cp = "no-port-forwarding";
#line 83
    tmp___0 = strlen(cp);
#line 83
    tmp___1 = strncasecmp((char const   *)opts, cp, tmp___0);
#line 83
    if (tmp___1 == 0) {
#line 84
      auth_debug_add("Port forwarding disabled.");
#line 85
      no_port_forwarding_flag = 1;
#line 86
      tmp = strlen(cp);
#line 86
      opts += tmp;
      goto next_option;
    }
#line 89
    cp = "no-agent-forwarding";
#line 90
    tmp___3 = strlen(cp);
#line 90
    tmp___4 = strncasecmp((char const   *)opts, cp, tmp___3);
#line 90
    if (tmp___4 == 0) {
#line 91
      auth_debug_add("Agent forwarding disabled.");
#line 92
      no_agent_forwarding_flag = 1;
#line 93
      tmp___2 = strlen(cp);
#line 93
      opts += tmp___2;
      goto next_option;
    }
#line 96
    cp = "no-X11-forwarding";
#line 97
    tmp___6 = strlen(cp);
#line 97
    tmp___7 = strncasecmp((char const   *)opts, cp, tmp___6);
#line 97
    if (tmp___7 == 0) {
#line 98
      auth_debug_add("X11 forwarding disabled.");
#line 99
      no_x11_forwarding_flag = 1;
#line 100
      tmp___5 = strlen(cp);
#line 100
      opts += tmp___5;
      goto next_option;
    }
#line 103
    cp = "no-pty";
#line 104
    tmp___9 = strlen(cp);
#line 104
    tmp___10 = strncasecmp((char const   *)opts, cp, tmp___9);
#line 104
    if (tmp___10 == 0) {
#line 105
      auth_debug_add("Pty allocation disabled.");
#line 106
      no_pty_flag = 1;
#line 107
      tmp___8 = strlen(cp);
#line 107
      opts += tmp___8;
      goto next_option;
    }
#line 110
    cp = "command=\"";
#line 111
    tmp___17 = strlen(cp);
#line 111
    tmp___18 = strncasecmp((char const   *)opts, cp, tmp___17);
#line 111
    if (tmp___18 == 0) {
#line 112
      tmp___11 = strlen(cp);
#line 112
      opts += tmp___11;
#line 113
      tmp___12 = strlen((char const   *)opts);
#line 113
      tmp___13 = xmalloc(tmp___12 + 1U);
#line 113
      forced_command = (char *)tmp___13;
#line 114
      i = 0;
#line 115
      while (*opts) {
#line 116
        if ((int )*opts == 34) {
#line 117
          break;
        }
#line 118
        if ((int )*opts == 92) {
#line 118
          if ((int )*(opts + 1) == 34) {
#line 119
            opts += 2;
#line 120
            tmp___14 = i;
#line 120
            i ++;
#line 120
            *(forced_command + tmp___14) = (char )'\"';
#line 121
            continue;
          }
        }
#line 123
        tmp___15 = i;
#line 123
        i ++;
#line 123
        tmp___16 = opts;
#line 123
        opts ++;
#line 123
        *(forced_command + tmp___15) = *tmp___16;
      }
#line 125
      if (! *opts) {
#line 126
        debug("%.100s, line %lu: missing end quote", file___0, linenum);
#line 128
        auth_debug_add("%.100s, line %lu: missing end quote", file___0, linenum);
#line 130
        xfree((void *)forced_command);
#line 131
        forced_command = (char *)((void *)0);
        goto bad_option;
      }
#line 134
      *(forced_command + i) = (char)0;
#line 135
      auth_debug_add("Forced command: %.900s", forced_command);
#line 136
      opts ++;
      goto next_option;
    }
#line 139
    cp = "environment=\"";
#line 140
    if (options.permit_user_env) {
#line 140
      tmp___26 = strlen(cp);
#line 140
      tmp___27 = strncasecmp((char const   *)opts, cp, tmp___26);
#line 140
      if (tmp___27 == 0) {
#line 145
        tmp___19 = strlen(cp);
#line 145
        opts += tmp___19;
#line 146
        tmp___20 = strlen((char const   *)opts);
#line 146
        tmp___21 = xmalloc(tmp___20 + 1U);
#line 146
        s = (char *)tmp___21;
#line 147
        i = 0;
#line 148
        while (*opts) {
#line 149
          if ((int )*opts == 34) {
#line 150
            break;
          }
#line 151
          if ((int )*opts == 92) {
#line 151
            if ((int )*(opts + 1) == 34) {
#line 152
              opts += 2;
#line 153
              tmp___22 = i;
#line 153
              i ++;
#line 153
              *(s + tmp___22) = (char )'\"';
#line 154
              continue;
            }
          }
#line 156
          tmp___23 = i;
#line 156
          i ++;
#line 156
          tmp___24 = opts;
#line 156
          opts ++;
#line 156
          *(s + tmp___23) = *tmp___24;
        }
#line 158
        if (! *opts) {
#line 159
          debug("%.100s, line %lu: missing end quote", file___0, linenum);
#line 161
          auth_debug_add("%.100s, line %lu: missing end quote", file___0, linenum);
#line 163
          xfree((void *)s);
          goto bad_option;
        }
#line 166
        *(s + i) = (char)0;
#line 167
        auth_debug_add("Adding to environment: %.900s", s);
#line 168
        debug("Adding to environment: %.900s", s);
#line 169
        opts ++;
#line 170
        tmp___25 = xmalloc(sizeof(struct envstring ));
#line 170
        new_envstring = (struct envstring *)tmp___25;
#line 171
        new_envstring->s = s;
#line 172
        new_envstring->next = custom_environment;
#line 173
        custom_environment = new_envstring;
        goto next_option;
      }
    }
#line 176
    cp = "from=\"";
#line 177
    tmp___37 = strlen(cp);
#line 177
    tmp___38 = strncasecmp((char const   *)opts, cp, tmp___37);
#line 177
    if (tmp___38 == 0) {
#line 178
      tmp___28 = get_remote_ipaddr();
#line 178
      remote_ip___0 = tmp___28;
#line 179
      tmp___29 = get_canonical_hostname(options.use_dns);
#line 179
      remote_host = tmp___29;
#line 181
      tmp___30 = strlen((char const   *)opts);
#line 181
      tmp___31 = xmalloc(tmp___30 + 1U);
#line 181
      patterns = (char *)tmp___31;
#line 183
      tmp___32 = strlen(cp);
#line 183
      opts += tmp___32;
#line 184
      i = 0;
#line 185
      while (*opts) {
#line 186
        if ((int )*opts == 34) {
#line 187
          break;
        }
#line 188
        if ((int )*opts == 92) {
#line 188
          if ((int )*(opts + 1) == 34) {
#line 189
            opts += 2;
#line 190
            tmp___33 = i;
#line 190
            i ++;
#line 190
            *(patterns + tmp___33) = (char )'\"';
#line 191
            continue;
          }
        }
#line 193
        tmp___34 = i;
#line 193
        i ++;
#line 193
        tmp___35 = opts;
#line 193
        opts ++;
#line 193
        *(patterns + tmp___34) = *tmp___35;
      }
#line 195
      if (! *opts) {
#line 196
        debug("%.100s, line %lu: missing end quote", file___0, linenum);
#line 198
        auth_debug_add("%.100s, line %lu: missing end quote", file___0, linenum);
#line 200
        xfree((void *)patterns);
        goto bad_option;
      }
#line 203
      *(patterns + i) = (char)0;
#line 204
      opts ++;
#line 205
      tmp___36 = match_host_and_ip(remote_host, remote_ip___0, (char const   *)patterns);
#line 205
      if (tmp___36 != 1) {
#line 207
        xfree((void *)patterns);
#line 208
        logit("Authentication tried for %.100s with correct key but not from a permitted host (host=%.200s, ip=%.200s).",
              pw->pw_name, remote_host, remote_ip___0);
#line 212
        auth_debug_add("Your host \'%.200s\' is not permitted to use this key for login.",
                       remote_host);
#line 216
        return (0);
      }
#line 218
      xfree((void *)patterns);
      goto next_option;
    }
#line 222
    cp = "permitopen=\"";
#line 223
    tmp___48 = strlen(cp);
#line 223
    tmp___49 = strncasecmp((char const   *)opts, cp, tmp___48);
#line 223
    if (tmp___49 == 0) {
#line 226
      tmp___39 = strlen((char const   *)opts);
#line 226
      tmp___40 = xmalloc(tmp___39 + 1U);
#line 226
      patterns___0 = (char *)tmp___40;
#line 228
      tmp___41 = strlen(cp);
#line 228
      opts += tmp___41;
#line 229
      i = 0;
#line 230
      while (*opts) {
#line 231
        if ((int )*opts == 34) {
#line 232
          break;
        }
#line 233
        if ((int )*opts == 92) {
#line 233
          if ((int )*(opts + 1) == 34) {
#line 234
            opts += 2;
#line 235
            tmp___42 = i;
#line 235
            i ++;
#line 235
            *(patterns___0 + tmp___42) = (char )'\"';
#line 236
            continue;
          }
        }
#line 238
        tmp___43 = i;
#line 238
        i ++;
#line 238
        tmp___44 = opts;
#line 238
        opts ++;
#line 238
        *(patterns___0 + tmp___43) = *tmp___44;
      }
#line 240
      if (! *opts) {
#line 241
        debug("%.100s, line %lu: missing end quote", file___0, linenum);
#line 243
        auth_debug_add("%.100s, line %lu: missing end quote", file___0, linenum);
#line 245
        xfree((void *)patterns___0);
        goto bad_option;
      }
#line 248
      *(patterns___0 + i) = (char)0;
#line 249
      opts ++;
#line 250
      p = patterns___0;
#line 251
      host = hpdelim(& p);
#line 252
      if ((unsigned int )host == (unsigned int )((void *)0)) {
#line 253
        debug("%.100s, line %lu: Bad permitopen specification <%.100s>", file___0,
              linenum, patterns___0);
#line 256
        auth_debug_add("%.100s, line %lu: Bad permitopen specification", file___0,
                       linenum);
#line 259
        xfree((void *)patterns___0);
        goto bad_option;
      } else {
#line 252
        tmp___45 = strlen((char const   *)host);
#line 252
        if (tmp___45 >= 1025U) {
#line 253
          debug("%.100s, line %lu: Bad permitopen specification <%.100s>", file___0,
                linenum, patterns___0);
#line 256
          auth_debug_add("%.100s, line %lu: Bad permitopen specification", file___0,
                         linenum);
#line 259
          xfree((void *)patterns___0);
          goto bad_option;
        }
      }
#line 262
      host = cleanhostname(host);
#line 263
      if ((unsigned int )p == (unsigned int )((void *)0)) {
        goto _L;
      } else {
#line 263
        tmp___47 = a2port((char const   *)p);
#line 263
        port___0 = (unsigned short )tmp___47;
#line 263
        if ((int )port___0 == 0) {
          _L: /* CIL Label */ 
#line 264
          if (p) {
#line 264
            tmp___46 = (char const   *)p;
          } else {
#line 264
            tmp___46 = "";
          }
#line 264
          debug("%.100s, line %lu: Bad permitopen port <%.100s>", file___0, linenum,
                tmp___46);
#line 266
          auth_debug_add("%.100s, line %lu: Bad permitopen port", file___0, linenum);
#line 268
          xfree((void *)patterns___0);
          goto bad_option;
        }
      }
#line 271
      if (options.allow_tcp_forwarding) {
#line 272
        channel_add_permitted_opens(host, (int )port___0);
      }
#line 273
      xfree((void *)patterns___0);
      goto next_option;
    }
#line 276
    cp = "tunnel=\"";
#line 277
    tmp___55 = strlen(cp);
#line 277
    tmp___56 = strncasecmp((char const   *)opts, cp, tmp___55);
#line 277
    if (tmp___56 == 0) {
#line 278
      tun = (char *)((void *)0);
#line 279
      tmp___50 = strlen(cp);
#line 279
      opts += tmp___50;
#line 280
      tmp___51 = strlen((char const   *)opts);
#line 280
      tmp___52 = xmalloc(tmp___51 + 1U);
#line 280
      tun = (char *)tmp___52;
#line 281
      i = 0;
#line 282
      while (*opts) {
#line 283
        if ((int )*opts == 34) {
#line 284
          break;
        }
#line 285
        tmp___53 = i;
#line 285
        i ++;
#line 285
        tmp___54 = opts;
#line 285
        opts ++;
#line 285
        *(tun + tmp___53) = *tmp___54;
      }
#line 287
      if (! *opts) {
#line 288
        debug("%.100s, line %lu: missing end quote", file___0, linenum);
#line 290
        auth_debug_add("%.100s, line %lu: missing end quote", file___0, linenum);
#line 292
        xfree((void *)tun);
#line 293
        forced_tun_device = -1;
        goto bad_option;
      }
#line 296
      *(tun + i) = (char)0;
#line 297
      forced_tun_device = a2tun((char const   *)tun, (int *)((void *)0));
#line 298
      xfree((void *)tun);
#line 299
      if (forced_tun_device == 2147483646) {
#line 300
        debug("%.100s, line %lu: invalid tun device", file___0, linenum);
#line 302
        auth_debug_add("%.100s, line %lu: invalid tun device", file___0, linenum);
#line 304
        forced_tun_device = -1;
        goto bad_option;
      }
#line 307
      auth_debug_add("Forced tun device: %d", forced_tun_device);
#line 308
      opts ++;
      goto next_option;
    }
    next_option: 
#line 316
    if (! *opts) {
#line 317
      fatal("Bugs in auth-options.c option processing.");
    }
#line 318
    if ((int )*opts == 32) {
#line 319
      break;
    } else {
#line 318
      if ((int )*opts == 9) {
#line 319
        break;
      }
    }
#line 320
    if ((int )*opts != 44) {
      goto bad_option;
    }
#line 322
    opts ++;
  }
#line 326
  if (! use_privsep) {
#line 327
    auth_debug_send();
  }
#line 330
  return (1);
  bad_option: 
#line 333
  logit("Bad options in %.100s file, line %lu: %.50s", file___0, linenum, opts);
#line 335
  auth_debug_add("Bad options in %.100s file, line %lu: %.50s", file___0, linenum,
                 opts);
#line 338
  if (! use_privsep) {
#line 339
    auth_debug_send();
  }
#line 342
  return (0);
}
}
#line 1 "session.o"
#line 333 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 590
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 774
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 780
extern int pclose(FILE *__stream ) ;
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 194 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 69 "/usr/include/grp.h"
extern void endgrent(void) ;
#line 504 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int execve(char const   *__path , char * const  *__argv ,
                                                char * const  *__envp )  __attribute__((__nonnull__(1))) ;
#line 526
extern  __attribute__((__nothrow__)) int execl(char const   *__path , char const   *__arg 
                                               , ...)  __attribute__((__nonnull__(1))) ;
#line 801
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 845
extern  __attribute__((__nothrow__)) int gethostname(char *__name , size_t __len )  __attribute__((__nonnull__(1))) ;
#line 81 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcsendbreak(int __fd , int __duration ) ;
#line 69 "session.h"
void session_pty_cleanup2(Session *s ) ;
#line 71
Session *session_new(void) ;
#line 72
Session *session_by_tty(char *tty ) ;
#line 73
void session_close(Session *s ) ;
#line 75
void child_set_env(char ***envp , u_int *envsizep , char const   *name , char const   *value ) ;
#line 43 "monitor_wrap.h"
int mm_is_monitor(void) ;
#line 85
int mm_pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) ;
#line 86
void mm_session_pty_cleanup2(struct Session *s ) ;
#line 73 "session.c"
void session_set_fds(Session *s , int fdin___0 , int fdout___0 , int fderr___0 ) ;
#line 74
void session_pty_cleanup(Session *s ) ;
#line 75
void session_proctitle(Session *s ) ;
#line 76
int session_setup_x11fwd(Session *s ) ;
#line 77
void do_exec_pty(Session *s , char const   *command ) ;
#line 78
void do_exec_no_pty(Session *s , char const   *command ) ;
#line 79
void do_exec(Session *s , char const   *command ) ;
#line 80
void do_login(Session *s , char const   *command ) ;
#line 84
void do_child(Session *s , char const   *command ) ;
#line 85
void do_motd(void) ;
#line 86
int check_quietlogin(Session *s , char const   *command ) ;
#line 88
static void do_authenticated1(Authctxt *authctxt___0 ) ;
#line 89
static void do_authenticated2(Authctxt *authctxt___0 ) ;
#line 91
static int session_pty_req(Session *s ) ;
#line 104 "session.c"
char const   *original_command  =    (char const   *)((void *)0);
#line 108 "session.c"
Session sessions[10]  ;
#line 114 "session.c"
static int is_child  =    0;
#line 117 "session.c"
static char *auth_sock_name  =    (char *)((void *)0);
#line 118 "session.c"
static char *auth_sock_dir  =    (char *)((void *)0);
#line 122 "session.c"
static void auth_sock_cleanup_proc(struct passwd *pw ) 
{ 

  {
#line 125
  if ((unsigned int )auth_sock_name != (unsigned int )((void *)0)) {
#line 126
    temporarily_use_uid(pw);
#line 127
    unlink((char const   *)auth_sock_name);
#line 128
    rmdir((char const   *)auth_sock_dir);
#line 129
    auth_sock_name = (char *)((void *)0);
#line 130
    restore_uid();
  }
#line 132
  return;
}
}
#line 134 "session.c"
static int auth_input_request_forwarding(struct passwd *pw ) 
{ Channel *nc ;
  int sock ;
  struct sockaddr_un sunaddr ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  __pid_t tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
#line 141
  if ((unsigned int )auth_sock_name != (unsigned int )((void *)0)) {
#line 142
    error("authentication forwarding requested twice.");
#line 143
    return (0);
  }
#line 147
  temporarily_use_uid(pw);
#line 150
  tmp = xmalloc(4096U);
#line 150
  auth_sock_name = (char *)tmp;
#line 151
  tmp___0 = xmalloc(4096U);
#line 151
  auth_sock_dir = (char *)tmp___0;
#line 152
  strlcpy(auth_sock_dir, "/tmp/ssh-XXXXXXXXXX", 4096U);
#line 155
  tmp___3 = mkdtemp(auth_sock_dir);
#line 155
  if ((unsigned int )tmp___3 == (unsigned int )((void *)0)) {
#line 156
    tmp___1 = __errno_location();
#line 156
    tmp___2 = strerror(*tmp___1);
#line 156
    packet_send_debug("Agent forwarding disabled: mkdtemp() failed: %.100s", tmp___2);
#line 158
    restore_uid();
#line 159
    xfree((void *)auth_sock_name);
#line 160
    xfree((void *)auth_sock_dir);
#line 161
    auth_sock_name = (char *)((void *)0);
#line 162
    auth_sock_dir = (char *)((void *)0);
#line 163
    return (0);
  }
#line 165
  tmp___4 = getpid();
#line 165
  snprintf((char * __restrict  )auth_sock_name, 4096U, (char const   * __restrict  )"%s/agent.%ld",
           auth_sock_dir, (long )tmp___4);
#line 169
  sock = socket(1, 1, 0);
#line 170
  if (sock < 0) {
#line 171
    tmp___5 = __errno_location();
#line 171
    tmp___6 = strerror(*tmp___5);
#line 171
    packet_disconnect("socket: %.100s", tmp___6);
  }
#line 174
  memset((void *)(& sunaddr), 0, sizeof(sunaddr));
#line 175
  sunaddr.sun_family = (unsigned short)1;
#line 176
  strlcpy(sunaddr.sun_path, (char const   *)auth_sock_name, sizeof(sunaddr.sun_path));
#line 178
  tmp___9 = bind(sock, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& sunaddr)),
                 sizeof(sunaddr));
#line 178
  if (tmp___9 < 0) {
#line 179
    tmp___7 = __errno_location();
#line 179
    tmp___8 = strerror(*tmp___7);
#line 179
    packet_disconnect("bind: %.100s", tmp___8);
  }
#line 182
  restore_uid();
#line 185
  tmp___12 = listen(sock, 128);
#line 185
  if (tmp___12 < 0) {
#line 186
    tmp___10 = __errno_location();
#line 186
    tmp___11 = strerror(*tmp___10);
#line 186
    packet_disconnect("listen: %.100s", tmp___11);
  }
#line 189
  nc = channel_new((char *)"auth socket", 6, sock, sock, -1, 65536U, 16384U, 0, (char *)"auth socket",
                   1);
#line 193
  strlcpy(nc->path, (char const   *)auth_sock_name, sizeof(nc->path));
#line 194
  return (1);
}
}
#line 197 "session.c"
static void display_loginmsg(void) 
{ void *tmp ;
  u_int tmp___0 ;

  {
#line 200
  tmp___0 = buffer_len(& loginmsg);
#line 200
  if (tmp___0 > 0U) {
#line 201
    buffer_append(& loginmsg, (void const   *)"\000", 1U);
#line 202
    tmp = buffer_ptr(& loginmsg);
#line 202
    printf((char const   * __restrict  )"%s", (char *)tmp);
#line 203
    buffer_clear(& loginmsg);
  }
#line 205
  return;
}
}
#line 207 "session.c"
void do_authenticated(Authctxt *authctxt___0 ) 
{ 

  {
#line 210
  setproctitle("%s", (authctxt___0->pw)->pw_name);
#line 213
  if (! no_port_forwarding_flag) {
#line 213
    if (options.allow_tcp_forwarding) {
#line 214
      channel_permit_all_opens();
    }
  }
#line 216
  if (compat20) {
#line 217
    do_authenticated2(authctxt___0);
  } else {
#line 219
    do_authenticated1(authctxt___0);
  }
#line 221
  do_cleanup(authctxt___0);
#line 222
  return;
}
}
#line 230 "session.c"
static void do_authenticated1(Authctxt *authctxt___0 ) 
{ Session *s ;
  char *command ;
  int success ;
  int type ;
  int screen_flag ;
  int enable_compression_after_reply ;
  u_int proto_len ;
  u_int data_len ;
  u_int dlen ;
  u_int compression_level ;
  int _len ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  u_int tmp___2 ;
  int tmp___3 ;
  int _len___0 ;
  int tmp___4 ;
  u_int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  int _len___1 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 236
  enable_compression_after_reply = 0;
#line 237
  compression_level = (u_int )0;
#line 239
  s = session_new();
#line 240
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 241
    error("no more sessions");
#line 242
    return;
  }
#line 244
  s->authctxt = authctxt___0;
#line 245
  s->pw = authctxt___0->pw;
#line 251
  while (1) {
#line 252
    success = 0;
#line 255
    type = packet_read();
#line 258
    switch (type) {
    case 37: 
#line 260
    compression_level = packet_get_int();
#line 261
    while (1) {
#line 261
      tmp = packet_remaining();
#line 261
      _len = tmp;
#line 261
      if (_len > 0) {
#line 261
        logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
              261);
#line 261
        packet_disconnect("Packet integrity error.");
      }
#line 261
      break;
    }
#line 262
    if (compression_level < 1U) {
#line 263
      packet_send_debug("Received invalid compression level %d.", compression_level);
#line 265
      break;
    } else {
#line 262
      if (compression_level > 9U) {
#line 263
        packet_send_debug("Received invalid compression level %d.", compression_level);
#line 265
        break;
      }
    }
#line 267
    if (options.compression == 0) {
#line 268
      debug2("compression disabled");
#line 269
      break;
    }
#line 272
    enable_compression_after_reply = 1;
#line 273
    success = 1;
#line 274
    break;
    case 10: 
#line 277
    success = session_pty_req(s);
#line 278
    break;
    case 34: 
#line 281
    tmp___0 = packet_get_string(& proto_len);
#line 281
    s->auth_proto = (char *)tmp___0;
#line 282
    tmp___1 = packet_get_string(& data_len);
#line 282
    s->auth_data = (char *)tmp___1;
#line 284
    tmp___2 = packet_get_protocol_flags();
#line 284
    screen_flag = (int )(tmp___2 & 1U);
#line 286
    debug2("SSH_PROTOFLAG_SCREEN_NUMBER: %d", screen_flag);
#line 288
    tmp___3 = packet_remaining();
#line 288
    if (tmp___3 == 4) {
#line 289
      if (! screen_flag) {
#line 290
        debug2("Buggy client: X11 screen flag missing");
      }
#line 292
      s->screen = packet_get_int();
    } else {
#line 294
      s->screen = 0U;
    }
#line 296
    while (1) {
#line 296
      tmp___4 = packet_remaining();
#line 296
      _len___0 = tmp___4;
#line 296
      if (_len___0 > 0) {
#line 296
        logit("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "session.c",
              296);
#line 296
        packet_disconnect("Packet integrity error.");
      }
#line 296
      break;
    }
#line 297
    success = session_setup_x11fwd(s);
#line 298
    if (! success) {
#line 299
      xfree((void *)s->auth_proto);
#line 300
      xfree((void *)s->auth_data);
#line 301
      s->auth_proto = (char *)((void *)0);
#line 302
      s->auth_data = (char *)((void *)0);
    }
#line 304
    break;
    case 30: 
#line 307
    if (no_agent_forwarding_flag) {
#line 308
      debug("Authentication agent forwarding not permitted for this authentication.");
#line 309
      break;
    } else {
#line 307
      if (compat13) {
#line 308
        debug("Authentication agent forwarding not permitted for this authentication.");
#line 309
        break;
      }
    }
#line 311
    debug("Received authentication agent forwarding request.");
#line 312
    success = auth_input_request_forwarding(s->pw);
#line 313
    break;
    case 28: 
#line 316
    if (no_port_forwarding_flag) {
#line 317
      debug("Port forwarding not permitted for this authentication.");
#line 318
      break;
    }
#line 320
    if (! options.allow_tcp_forwarding) {
#line 321
      debug("Port forwarding not permitted.");
#line 322
      break;
    }
#line 324
    debug("Received TCP/IP port forwarding request.");
#line 325
    channel_input_port_forward_request((s->pw)->pw_uid == 0U, options.gateway_ports);
#line 326
    success = 1;
#line 327
    break;
    case 38: 
#line 330
    tmp___5 = packet_get_int();
#line 330
    tmp___6 = packet_set_maxsize(tmp___5);
#line 330
    if (tmp___6 > 0) {
#line 331
      success = 1;
    }
#line 332
    break;
    case 12: 
    case 13: 
#line 336
    if (type == 13) {
#line 337
      tmp___7 = packet_get_string(& dlen);
#line 337
      command = (char *)tmp___7;
#line 338
      debug("Exec command \'%.500s\'", command);
#line 339
      do_exec(s, (char const   *)command);
#line 340
      xfree((void *)command);
    } else {
#line 342
      do_exec(s, (char const   *)((void *)0));
    }
#line 344
    while (1) {
#line 344
      tmp___8 = packet_remaining();
#line 344
      _len___1 = tmp___8;
#line 344
      if (_len___1 > 0) {
#line 344
        logit("Packet integrity error (%d bytes remaining) at %s:%d", _len___1, "session.c",
              344);
#line 344
        packet_disconnect("Packet integrity error.");
      }
#line 344
      break;
    }
#line 345
    session_close(s);
#line 346
    return;
    default: 
#line 353
    logit("Unknown packet type received after authentication: %d", type);
    }
#line 355
    if (success) {
#line 355
      tmp___9 = 14;
    } else {
#line 355
      tmp___9 = 15;
    }
#line 355
    packet_start((unsigned char )tmp___9);
#line 356
    packet_send();
#line 357
    packet_write_wait();
#line 360
    if (enable_compression_after_reply) {
#line 361
      enable_compression_after_reply = 0;
#line 362
      packet_start_compression((int )compression_level);
    }
  }
}
}
#line 372 "session.c"
void do_exec_no_pty(Session *s , char const   *command ) 
{ pid_t pid ;
  int inout[2] ;
  int err[2] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  __pid_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
#line 386
  tmp___1 = socketpair(1, 1, 0, (int *)(inout));
#line 386
  if (tmp___1 < 0) {
#line 388
    tmp = __errno_location();
#line 388
    tmp___0 = strerror(*tmp);
#line 388
    packet_disconnect("Could not create socket pairs: %.100s", tmp___0);
  } else {
#line 386
    tmp___2 = socketpair(1, 1, 0, (int *)(err));
#line 386
    if (tmp___2 < 0) {
#line 388
      tmp = __errno_location();
#line 388
      tmp___0 = strerror(*tmp);
#line 388
      packet_disconnect("Could not create socket pairs: %.100s", tmp___0);
    }
  }
#line 391
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 392
    fatal("do_exec_no_pty: no session");
  }
#line 394
  session_proctitle(s);
#line 402
  pid = fork();
#line 402
  if (pid == 0) {
#line 403
    is_child = 1;
#line 406
    log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 412
    tmp___5 = setsid();
#line 412
    if (tmp___5 < 0) {
#line 413
      tmp___3 = __errno_location();
#line 413
      tmp___4 = strerror(*tmp___3);
#line 413
      error("setsid failed: %.100s", tmp___4);
    }
#line 442
    close(inout[1]);
#line 443
    close(err[1]);
#line 444
    tmp___6 = dup2(inout[0], 0);
#line 444
    if (tmp___6 < 0) {
#line 445
      perror("dup2 stdin");
    }
#line 446
    tmp___7 = dup2(inout[0], 1);
#line 446
    if (tmp___7 < 0) {
#line 447
      perror("dup2 stdout");
    }
#line 448
    tmp___8 = dup2(err[0], 2);
#line 448
    if (tmp___8 < 0) {
#line 449
      perror("dup2 stderr");
    }
#line 457
    do_child(s, command);
  }
#line 467
  if (pid < 0) {
#line 468
    tmp___9 = __errno_location();
#line 468
    tmp___10 = strerror(*tmp___9);
#line 468
    packet_disconnect("fork failed: %.100s", tmp___10);
  }
#line 469
  s->pid = pid;
#line 471
  packet_set_interactive((unsigned int )s->display != (unsigned int )((void *)0));
#line 491
  close(inout[0]);
#line 492
  close(err[0]);
#line 499
  buffer_clear(& loginmsg);
#line 505
  if (compat20) {
#line 506
    if (s->is_subsystem) {
#line 506
      tmp___11 = -1;
    } else {
#line 506
      tmp___11 = err[1];
    }
#line 506
    session_set_fds(s, inout[1], inout[1], tmp___11);
  } else {
#line 508
    server_loop(pid, inout[1], inout[1], err[1]);
  }
#line 512
  return;
}
}
#line 520 "session.c"
void do_exec_pty(Session *s , char const   *command ) 
{ int fdout___0 ;
  int ptyfd ;
  int ttyfd ;
  int ptymaster ;
  pid_t pid ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;

  {
#line 526
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 527
    fatal("do_exec_pty: no session");
  }
#line 528
  ptyfd = s->ptyfd;
#line 529
  ttyfd = s->ttyfd;
#line 540
  pid = fork();
#line 540
  if (pid == 0) {
#line 541
    is_child = 1;
#line 544
    log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 546
    close(ptyfd);
#line 549
    pty_make_controlling_tty(& ttyfd, (char const   *)(s->tty));
#line 552
    tmp___1 = dup2(ttyfd, 0);
#line 552
    if (tmp___1 < 0) {
#line 553
      tmp = __errno_location();
#line 553
      tmp___0 = strerror(*tmp);
#line 553
      error("dup2 stdin: %s", tmp___0);
    }
#line 554
    tmp___4 = dup2(ttyfd, 1);
#line 554
    if (tmp___4 < 0) {
#line 555
      tmp___2 = __errno_location();
#line 555
      tmp___3 = strerror(*tmp___2);
#line 555
      error("dup2 stdout: %s", tmp___3);
    }
#line 556
    tmp___7 = dup2(ttyfd, 2);
#line 556
    if (tmp___7 < 0) {
#line 557
      tmp___5 = __errno_location();
#line 557
      tmp___6 = strerror(*tmp___5);
#line 557
      error("dup2 stderr: %s", tmp___6);
    }
#line 560
    close(ttyfd);
#line 564
    if (options.use_login) {
#line 564
      if (! ((unsigned int )command == (unsigned int )((void *)0))) {
#line 568
        do_login(s, command);
      }
    } else {
#line 568
      do_login(s, command);
    }
#line 577
    do_child(s, command);
  }
#line 587
  if (pid < 0) {
#line 588
    tmp___8 = __errno_location();
#line 588
    tmp___9 = strerror(*tmp___8);
#line 588
    packet_disconnect("fork failed: %.100s", tmp___9);
  }
#line 589
  s->pid = pid;
#line 592
  close(ttyfd);
#line 599
  fdout___0 = dup(ptyfd);
#line 600
  if (fdout___0 < 0) {
#line 601
    tmp___10 = __errno_location();
#line 601
    tmp___11 = strerror(*tmp___10);
#line 601
    packet_disconnect("dup #1 failed: %.100s", tmp___11);
  }
#line 604
  ptymaster = dup(ptyfd);
#line 605
  if (ptymaster < 0) {
#line 606
    tmp___12 = __errno_location();
#line 606
    tmp___13 = strerror(*tmp___12);
#line 606
    packet_disconnect("dup #2 failed: %.100s", tmp___13);
  }
#line 607
  s->ptymaster = ptymaster;
#line 610
  packet_set_interactive(1);
#line 611
  if (compat20) {
#line 612
    session_set_fds(s, ptyfd, fdout___0, -1);
  } else {
#line 614
    server_loop(pid, ptyfd, fdout___0, -1);
  }
#line 617
  return;
}
}
#line 651 "session.c"
void do_exec(Session *s , char const   *command ) 
{ 

  {
#line 654
  if (forced_command) {
#line 655
    original_command = command;
#line 656
    command = (char const   *)forced_command;
#line 657
    debug("Forced command \'%.900s\'", command);
  }
#line 672
  if (s->ttyfd != -1) {
#line 673
    do_exec_pty(s, command);
  } else {
#line 675
    do_exec_no_pty(s, command);
  }
#line 677
  original_command = (char const   *)((void *)0);
#line 684
  buffer_clear(& loginmsg);
#line 685
  return;
}
}
#line 688 "session.c"
void do_login(Session *s , char const   *command ) 
{ socklen_t fromlen ;
  struct sockaddr_storage from ;
  struct passwd *pw ;
  pid_t pid ;
  __pid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;

  {
#line 693
  pw = s->pw;
#line 694
  tmp = getpid();
#line 694
  pid = tmp;
#line 700
  memset((void *)(& from), 0, sizeof(from));
#line 701
  fromlen = sizeof(from);
#line 702
  tmp___4 = packet_connection_is_on_socket();
#line 702
  if (tmp___4) {
#line 703
    tmp___2 = packet_get_connection_in();
#line 703
    tmp___3 = getpeername(tmp___2, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 703
    if (tmp___3 < 0) {
#line 705
      tmp___0 = __errno_location();
#line 705
      tmp___1 = strerror(*tmp___0);
#line 705
      debug("getpeername: %.100s", tmp___1);
#line 706
      cleanup_exit(255);
    }
  }
#line 711
  if (! use_privsep) {
#line 712
    tmp___5 = get_remote_name_or_ip(utmp_len, options.use_dns);
#line 712
    record_login(pid, (char const   *)(s->tty), (char const   *)pw->pw_name, pw->pw_uid,
                 tmp___5, (struct sockaddr *)(& from), fromlen);
  }
#line 730
  tmp___6 = check_quietlogin(s, command);
#line 730
  if (tmp___6) {
#line 731
    return;
  }
#line 733
  display_loginmsg();
#line 735
  do_motd();
#line 736
  return;
}
}
#line 741 "session.c"
void do_motd(void) 
{ FILE *f ;
  char buf___1[256] ;
  char *tmp ;

  {
#line 747
  if (options.print_motd) {
#line 752
    f = fopen((char const   * __restrict  )"/etc/motd", (char const   * __restrict  )"r");
#line 754
    if (f) {
#line 755
      while (1) {
#line 755
        tmp = fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )f);
#line 755
        if (! tmp) {
#line 755
          break;
        }
#line 756
        fputs((char const   * __restrict  )(buf___1), (FILE * __restrict  )stdout);
      }
#line 757
      fclose(f);
    }
  }
#line 760
  return;
}
}
#line 766 "session.c"
int check_quietlogin(Session *s , char const   *command ) 
{ char buf___1[256] ;
  struct passwd *pw ;
  struct stat st ;
  int tmp ;

  {
#line 770
  pw = s->pw;
#line 774
  if ((unsigned int )command != (unsigned int )((void *)0)) {
#line 775
    return (1);
  }
#line 776
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.200s/.hushlogin",
           pw->pw_dir);
#line 781
  tmp = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )(& st));
#line 781
  if (tmp >= 0) {
#line 782
    return (1);
  }
#line 784
  return (0);
}
}
#line 791 "session.c"
void child_set_env(char ***envp , u_int *envsizep , char const   *name , char const   *value ) 
{ char **env ;
  u_int envsize ;
  u_int i ;
  u_int namelen ;
  void *tmp ;
  int tmp___13 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___19 ;
  int tmp___22 ;
  int tmp___23 ;
  void *tmp___26 ;
  size_t tmp___27 ;
  size_t tmp___28 ;
  void *tmp___29 ;
  size_t tmp___30 ;
  size_t tmp___31 ;

  {
#line 803
  if ((unsigned int )*envp == (unsigned int )((void *)0)) {
#line 803
    if (*envsizep == 0U) {
#line 804
      tmp = xmalloc(sizeof(char *));
#line 804
      *envp = (char **)tmp;
#line 805
      *(*(envp + 0)) = (char *)((void *)0);
#line 806
      *envsizep = 1U;
    }
  }
#line 814
  env = *envp;
#line 815
  namelen = strlen(name);
#line 816
  i = 0U;
#line 816
  while (*(env + i)) {
#line 817
    if (0) {
#line 817
      if (0) {
#line 817
        __s1_len___0 = strlen((char const   *)*(env + i));
#line 817
        __s2_len___0 = strlen(name);
#line 817
        if (! ((unsigned int )((void const   *)(*(env + i) + 1)) - (unsigned int )((void const   *)*(env + i)) == 1U)) {
          goto _L___2;
        } else {
#line 817
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 817
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
#line 817
              tmp___23 = 1;
            } else {
#line 817
              if (__s2_len___0 >= 4U) {
#line 817
                tmp___23 = 1;
              } else {
#line 817
                tmp___23 = 0;
              }
            }
          } else {
#line 817
            tmp___23 = 0;
          }
        }
#line 817
        if (tmp___23) {
#line 817
          tmp___19 = __builtin_strcmp((char const   *)*(env + i), name);
        } else {
#line 817
          tmp___22 = __builtin_strcmp((char const   *)*(env + i), name);
#line 817
          tmp___19 = tmp___22;
        }
      } else {
#line 817
        tmp___22 = __builtin_strcmp((char const   *)*(env + i), name);
#line 817
        tmp___19 = tmp___22;
      }
#line 817
      tmp___13 = tmp___19;
    } else {
#line 817
      tmp___13 = strncmp((char const   *)*(env + i), name, namelen);
    }
#line 817
    if (tmp___13 == 0) {
#line 817
      if ((int )*(*(env + i) + namelen) == 61) {
#line 818
        break;
      }
    }
#line 816
    i ++;
  }
#line 819
  if (*(env + i)) {
#line 821
    xfree((void *)*(env + i));
  } else {
#line 824
    envsize = *envsizep;
#line 825
    if (i >= envsize - 1U) {
#line 826
      if (envsize >= 1000U) {
#line 827
        fatal("child_set_env: too many env vars");
      }
#line 828
      envsize += 50U;
#line 829
      tmp___26 = xrealloc((void *)env, envsize * sizeof(char *));
#line 829
      *envp = (char **)tmp___26;
#line 829
      env = *envp;
#line 830
      *envsizep = envsize;
    }
#line 833
    *(env + (i + 1U)) = (char *)((void *)0);
  }
#line 837
  tmp___27 = strlen(name);
#line 837
  tmp___28 = strlen(value);
#line 837
  tmp___29 = xmalloc(((tmp___27 + 1U) + tmp___28) + 1U);
#line 837
  *(env + i) = (char *)tmp___29;
#line 838
  tmp___30 = strlen(name);
#line 838
  tmp___31 = strlen(value);
#line 838
  snprintf((char * __restrict  )*(env + i), ((tmp___30 + 1U) + tmp___31) + 1U, (char const   * __restrict  )"%s=%s",
           name, value);
#line 839
  return;
}
}
#line 847 "session.c"
static void read_environment_file(char ***env , u_int *envsize , char const   *filename ) 
{ FILE *f ;
  char buf___1[4096] ;
  char *cp ;
  char *value ;
  u_int lineno ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 854
  lineno = (u_int )0;
#line 856
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 857
  if (! f) {
#line 858
    return;
  }
#line 860
  while (1) {
#line 860
    tmp___5 = fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )f);
#line 860
    if (! tmp___5) {
#line 860
      break;
    }
#line 861
    lineno ++;
#line 861
    if (lineno > 1000U) {
#line 862
      fatal("Too many lines in environment file %s", filename);
    }
#line 863
    cp = buf___1;
#line 863
    while (1) {
#line 863
      if (! ((int )*cp == 32)) {
#line 863
        if (! ((int )*cp == 9)) {
#line 863
          break;
        }
      }
#line 863
      cp ++;
    }
#line 865
    if (! *cp) {
#line 866
      continue;
    } else {
#line 865
      if ((int )*cp == 35) {
#line 866
        continue;
      } else {
#line 865
        if ((int )*cp == 10) {
#line 866
          continue;
        }
      }
    }
#line 867
    tmp___2 = __builtin_strchr(cp, '\n');
#line 867
    if (tmp___2) {
#line 868
      tmp___0 = __builtin_strchr(cp, '\n');
#line 868
      *tmp___0 = (char )'\000';
    }
#line 869
    tmp___4 = __builtin_strchr(cp, '=');
#line 869
    value = tmp___4;
#line 870
    if ((unsigned int )value == (unsigned int )((void *)0)) {
#line 871
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad line %u in %.100s\n",
              lineno, filename);
#line 873
      continue;
    }
#line 879
    *value = (char )'\000';
#line 880
    value ++;
#line 881
    child_set_env(env, envsize, (char const   *)cp, (char const   *)value);
  }
#line 883
  fclose(f);
#line 884
  return;
}
}
#line 941 "session.c"
void copy_environment(char **source , char ***env , u_int *envsize ) 
{ char *var_name ;
  char *var_val ;
  int i ;
  char *tmp ;

  {
#line 947
  if ((unsigned int )source == (unsigned int )((void *)0)) {
#line 948
    return;
  }
#line 950
  i = 0;
#line 950
  while ((unsigned int )*(source + i) != (unsigned int )((void *)0)) {
#line 951
    var_name = xstrdup((char const   *)*(source + i));
#line 952
    var_val = strstr((char const   *)var_name, "=");
#line 952
    if ((unsigned int )var_val == (unsigned int )((void *)0)) {
#line 953
      xfree((void *)var_name);
      goto __Cont;
    }
#line 956
    tmp = var_val;
#line 956
    var_val ++;
#line 956
    *tmp = (char )'\000';
#line 958
    debug3("Copy environment: %s=%s", var_name, var_val);
#line 959
    child_set_env(env, envsize, (char const   *)var_name, (char const   *)var_val);
#line 961
    xfree((void *)var_name);
    __Cont: /* CIL Label */ 
#line 950
    i ++;
  }
#line 963
  return;
}
}
#line 965 "session.c"
static char **do_setup_env(Session *s , char const   *shell ) 
{ char buf___1[256] ;
  u_int i ;
  u_int envsize ;
  char **env ;
  char *laddr ;
  char *path ;
  struct passwd *pw ;
  void *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  struct envstring *ce ;
  char *str ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char *cp ;
  char const   *tmp___20 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___26 ;
  int tmp___29 ;
  int tmp___30 ;

  {
#line 970
  path = (char *)((void *)0);
#line 971
  pw = s->pw;
#line 974
  envsize = 100U;
#line 975
  tmp = xmalloc(envsize * sizeof(char *));
#line 975
  env = (char **)tmp;
#line 976
  *(env + 0) = (char *)((void *)0);
#line 999
  if (! options.use_login) {
#line 1001
    i = 0U;
#line 1001
    while (i < s->num_env) {
#line 1002
      child_set_env(& env, & envsize, (char const   *)(s->env + i)->name, (char const   *)(s->env + i)->val);
#line 1001
      i ++;
    }
#line 1005
    child_set_env(& env, & envsize, "USER", (char const   *)pw->pw_name);
#line 1006
    child_set_env(& env, & envsize, "LOGNAME", (char const   *)pw->pw_name);
#line 1010
    child_set_env(& env, & envsize, "HOME", (char const   *)pw->pw_dir);
#line 1028
    if ((unsigned int )path == (unsigned int )((void *)0)) {
      goto _L;
    } else {
#line 1028
      if ((int )*path == 0) {
        _L: /* CIL Label */ 
#line 1029
        if ((s->pw)->pw_uid == 0U) {
#line 1029
          tmp___0 = "/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin";
        } else {
#line 1029
          tmp___0 = "/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin";
        }
#line 1029
        child_set_env(& env, & envsize, "PATH", tmp___0);
      }
    }
#line 1036
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.200s/%.50s",
             "/var/mail", pw->pw_name);
#line 1038
    child_set_env(& env, & envsize, "MAIL", (char const   *)(buf___1));
#line 1041
    child_set_env(& env, & envsize, "SHELL", shell);
  }
#line 1043
  tmp___2 = getenv("TZ");
#line 1043
  if (tmp___2) {
#line 1044
    tmp___1 = getenv("TZ");
#line 1044
    child_set_env(& env, & envsize, "TZ", (char const   *)tmp___1);
  }
#line 1047
  if (! options.use_login) {
#line 1048
    while (custom_environment) {
#line 1049
      ce = custom_environment;
#line 1050
      str = ce->s;
#line 1052
      i = 0U;
#line 1052
      while (1) {
#line 1052
        if ((int )*(str + i) != 61) {
#line 1052
          if (! *(str + i)) {
#line 1052
            break;
          }
        } else {
#line 1052
          break;
        }
#line 1052
        i ++;
      }
#line 1054
      if ((int )*(str + i) == 61) {
#line 1055
        *(str + i) = (char)0;
#line 1056
        child_set_env(& env, & envsize, (char const   *)str, (char const   *)((str + i) + 1));
      }
#line 1058
      custom_environment = ce->next;
#line 1059
      xfree((void *)ce->s);
#line 1060
      xfree((void *)ce);
    }
  }
#line 1065
  tmp___3 = get_local_port();
#line 1065
  tmp___4 = get_remote_port();
#line 1065
  tmp___5 = get_remote_ipaddr();
#line 1065
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.50s %d %d",
           tmp___5, tmp___4, tmp___3);
#line 1067
  child_set_env(& env, & envsize, "SSH_CLIENT", (char const   *)(buf___1));
#line 1069
  tmp___6 = packet_get_connection_in();
#line 1069
  laddr = get_local_ipaddr(tmp___6);
#line 1070
  tmp___7 = get_local_port();
#line 1070
  tmp___8 = get_remote_port();
#line 1070
  tmp___9 = get_remote_ipaddr();
#line 1070
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.50s %d %.50s %d",
           tmp___9, tmp___8, laddr, tmp___7);
#line 1072
  xfree((void *)laddr);
#line 1073
  child_set_env(& env, & envsize, "SSH_CONNECTION", (char const   *)(buf___1));
#line 1075
  if (s->ttyfd != -1) {
#line 1076
    child_set_env(& env, & envsize, "SSH_TTY", (char const   *)(s->tty));
  }
#line 1077
  if (s->term) {
#line 1078
    child_set_env(& env, & envsize, "TERM", (char const   *)s->term);
  }
#line 1079
  if (s->display) {
#line 1080
    child_set_env(& env, & envsize, "DISPLAY", (char const   *)s->display);
  }
#line 1081
  if (original_command) {
#line 1082
    child_set_env(& env, & envsize, "SSH_ORIGINAL_COMMAND", original_command);
  }
#line 1098
  cp = getenv("KRB5CCNAME");
#line 1098
  if ((unsigned int )cp != (unsigned int )((void *)0)) {
#line 1099
    child_set_env(& env, & envsize, "KRB5CCNAME", (char const   *)cp);
  }
#line 1134
  if ((unsigned int )auth_sock_name != (unsigned int )((void *)0)) {
#line 1135
    child_set_env(& env, & envsize, "SSH_AUTH_SOCK", (char const   *)auth_sock_name);
  }
#line 1139
  if (options.permit_user_env) {
#line 1139
    if (! options.use_login) {
#line 1141
      if (0) {
#line 1141
        __s1_len___0 = strlen((char const   *)pw->pw_dir);
#line 1141
        __s2_len___0 = strlen("/");
#line 1141
        if (! ((unsigned int )((void const   *)(pw->pw_dir + 1)) - (unsigned int )((void const   *)pw->pw_dir) == 1U)) {
          goto _L___3;
        } else {
#line 1141
          if (__s1_len___0 >= 4U) {
            _L___3: /* CIL Label */ 
#line 1141
            if (! ((unsigned int )((void const   *)("/" + 1)) - (unsigned int )((void const   *)"/") == 1U)) {
#line 1141
              tmp___30 = 1;
            } else {
#line 1141
              if (__s2_len___0 >= 4U) {
#line 1141
                tmp___30 = 1;
              } else {
#line 1141
                tmp___30 = 0;
              }
            }
          } else {
#line 1141
            tmp___30 = 0;
          }
        }
#line 1141
        if (tmp___30) {
#line 1141
          tmp___26 = __builtin_strcmp((char const   *)pw->pw_dir, "/");
        } else {
#line 1141
          tmp___29 = __builtin_strcmp((char const   *)pw->pw_dir, "/");
#line 1141
          tmp___26 = tmp___29;
        }
      } else {
#line 1141
        tmp___29 = __builtin_strcmp((char const   *)pw->pw_dir, "/");
#line 1141
        tmp___26 = tmp___29;
      }
#line 1141
      if (tmp___26) {
#line 1141
        tmp___20 = (char const   *)pw->pw_dir;
      } else {
#line 1141
        tmp___20 = "";
      }
#line 1141
      snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.200s/.ssh/environment",
               tmp___20);
#line 1142
      read_environment_file(& env, & envsize, (char const   *)(buf___1));
    }
  }
#line 1144
  if (debug_flag) {
#line 1146
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Environment:\n");
#line 1147
    i = 0U;
#line 1147
    while (*(env + i)) {
#line 1148
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  %.200s\n",
              *(env + i));
#line 1147
      i ++;
    }
  }
#line 1150
  return (env);
}
}
#line 1157 "session.c"
static void do_rc_files(Session *s , char const   *shell ) 
{ FILE *f ;
  char cmd[1024] ;
  int do_xauth ;
  struct stat st ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1160
  f = (FILE *)((void *)0);
#line 1165
  if ((unsigned int )s->display != (unsigned int )((void *)0)) {
#line 1165
    if ((unsigned int )s->auth_proto != (unsigned int )((void *)0)) {
#line 1165
      if ((unsigned int )s->auth_data != (unsigned int )((void *)0)) {
#line 1165
        tmp = 1;
      } else {
#line 1165
        tmp = 0;
      }
    } else {
#line 1165
      tmp = 0;
    }
  } else {
#line 1165
    tmp = 0;
  }
#line 1165
  do_xauth = tmp;
#line 1169
  if (! s->is_subsystem) {
#line 1169
    tmp___1 = stat((char const   * __restrict  )".ssh/rc", (struct stat * __restrict  )(& st));
#line 1169
    if (tmp___1 >= 0) {
#line 1170
      snprintf((char * __restrict  )(cmd), sizeof(cmd), (char const   * __restrict  )"%s -c \'%s %s\'",
               shell, "/bin/sh", ".ssh/rc");
#line 1172
      if (debug_flag) {
#line 1173
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %s\n",
                cmd);
      }
#line 1174
      f = popen((char const   *)(cmd), "w");
#line 1175
      if (f) {
#line 1176
        if (do_xauth) {
#line 1177
          fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                  s->auth_proto, s->auth_data);
        }
#line 1179
        pclose(f);
      } else {
#line 1181
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                ".ssh/rc");
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1183
    tmp___0 = stat((char const   * __restrict  )"/usr/local/etc/sshrc", (struct stat * __restrict  )(& st));
#line 1183
    if (tmp___0 >= 0) {
#line 1184
      if (debug_flag) {
#line 1185
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %s %s\n",
                "/bin/sh", "/usr/local/etc/sshrc");
      }
#line 1187
      f = popen("/bin/sh /usr/local/etc/sshrc", "w");
#line 1188
      if (f) {
#line 1189
        if (do_xauth) {
#line 1190
          fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                  s->auth_proto, s->auth_data);
        }
#line 1192
        pclose(f);
      } else {
#line 1194
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                "/usr/local/etc/sshrc");
      }
    } else {
#line 1196
      if (do_xauth) {
#line 1196
        if ((unsigned int )options.xauth_location != (unsigned int )((void *)0)) {
#line 1198
          if (debug_flag) {
#line 1199
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %.500s remove %.100s\n",
                    options.xauth_location, s->auth_display);
#line 1202
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%.500s add %.100s %.100s %.100s\n",
                    options.xauth_location, s->auth_display, s->auth_proto, s->auth_data);
          }
#line 1207
          snprintf((char * __restrict  )(cmd), sizeof(cmd), (char const   * __restrict  )"%s -q -",
                   options.xauth_location);
#line 1209
          f = popen((char const   *)(cmd), "w");
#line 1210
          if (f) {
#line 1211
            fprintf((FILE * __restrict  )f, (char const   * __restrict  )"remove %s\n",
                    s->auth_display);
#line 1213
            fprintf((FILE * __restrict  )f, (char const   * __restrict  )"add %s %s %s\n",
                    s->auth_display, s->auth_proto, s->auth_data);
#line 1216
            pclose(f);
          } else {
#line 1218
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                    cmd);
          }
        }
      }
    }
  }
#line 1222
  return;
}
}
#line 1224 "session.c"
static void do_nologin(struct passwd *pw ) 
{ FILE *f ;
  char buf___1[1024] ;
  char *tmp ;

  {
#line 1227
  f = (FILE *)((void *)0);
#line 1235
  if (pw->pw_uid) {
#line 1236
    f = fopen((char const   * __restrict  )"/etc/nologin", (char const   * __restrict  )"r");
  }
#line 1238
  if (f) {
#line 1240
    logit("User %.100s not allowed because %s exists", pw->pw_name, "/etc/nologin");
#line 1242
    while (1) {
#line 1242
      tmp = fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )f);
#line 1242
      if (! tmp) {
#line 1242
        break;
      }
#line 1243
      fputs((char const   * __restrict  )(buf___1), (FILE * __restrict  )stderr);
    }
#line 1244
    fclose(f);
#line 1245
    fflush((FILE *)((void *)0));
#line 1246
    exit(254);
  }
#line 1248
  return;
}
}
#line 1251 "session.c"
void do_setusercontext(struct passwd *pw ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  __uid_t tmp___4 ;
  __uid_t tmp___5 ;
  __uid_t tmp___6 ;
  __uid_t tmp___7 ;

  {
#line 1255
  tmp___4 = getuid();
#line 1255
  if (tmp___4 == 0U) {
    goto _L;
  } else {
#line 1255
    tmp___5 = geteuid();
#line 1255
    if (tmp___5 == 0U) {
      _L: /* CIL Label */ 
#line 1292
      tmp___1 = setlogin((char const   *)pw->pw_name);
#line 1292
      if (tmp___1 < 0) {
#line 1293
        tmp = __errno_location();
#line 1293
        tmp___0 = strerror(*tmp);
#line 1293
        error("setlogin failed: %s", tmp___0);
      }
#line 1294
      tmp___2 = setgid(pw->pw_gid);
#line 1294
      if (tmp___2 < 0) {
#line 1295
        perror("setgid");
#line 1296
        exit(1);
      }
#line 1299
      tmp___3 = initgroups((char const   *)pw->pw_name, pw->pw_gid);
#line 1299
      if (tmp___3 < 0) {
#line 1300
        perror("initgroups");
#line 1301
        exit(1);
      }
#line 1303
      endgrent();
#line 1334
      permanently_set_uid(pw);
    }
  }
#line 1341
  tmp___6 = getuid();
#line 1341
  if (tmp___6 != pw->pw_uid) {
#line 1342
    fatal("Failed to set uids to %u.", pw->pw_uid);
  } else {
#line 1341
    tmp___7 = geteuid();
#line 1341
    if (tmp___7 != pw->pw_uid) {
#line 1342
      fatal("Failed to set uids to %u.", pw->pw_uid);
    }
  }
#line 1343
  return;
}
}
#line 1345 "session.c"
static void do_pwchange(Session *s ) 
{ 

  {
#line 1348
  fflush((FILE *)((void *)0));
#line 1349
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"WARNING: Your password has expired.\n");
#line 1350
  if (s->ttyfd != -1) {
#line 1351
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"You must change your password now and login again!\n");
#line 1357
    execl("/usr/bin//passwd", "passwd", (char *)((void *)0));
#line 1359
    perror("passwd");
  } else {
#line 1361
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Password change required but no TTY available.\n");
  }
#line 1364
  exit(1);
}
}
#line 1367 "session.c"
static void launch_login(struct passwd *pw , char const   *hostname ) 
{ 

  {
#line 1372
  execl("/bin/login", "login", "-h", hostname, "-p", "-f", "--", pw->pw_name, (char *)((void *)0));
#line 1384
  perror("login");
#line 1385
  exit(1);
}
}
#line 1388 "session.c"
static void child_close_fds(void) 
{ int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1393
  tmp___2 = packet_get_connection_in();
#line 1393
  tmp___3 = packet_get_connection_out();
#line 1393
  if (tmp___2 == tmp___3) {
#line 1394
    tmp = packet_get_connection_in();
#line 1394
    close(tmp);
  } else {
#line 1396
    tmp___0 = packet_get_connection_in();
#line 1396
    close(tmp___0);
#line 1397
    tmp___1 = packet_get_connection_out();
#line 1397
    close(tmp___1);
  }
#line 1404
  channel_close_all();
#line 1410
  endpwent();
#line 1418
  i = 3;
#line 1418
  while (i < 64) {
#line 1419
    close(i);
#line 1418
    i ++;
  }
#line 1420
  return;
}
}
#line 1427 "session.c"
void do_child(Session *s , char const   *command ) 
{ char **env ;
  char *argv[10] ;
  char const   *shell ;
  char const   *shell0 ;
  char const   *hostname ;
  struct passwd *pw ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char argv0___0[256] ;
  int *tmp___4 ;
  size_t tmp___5 ;

  {
#line 1433
  hostname = (char const   *)((void *)0);
#line 1434
  pw = s->pw;
#line 1437
  destroy_sensitive_data();
#line 1440
  if ((s->authctxt)->force_pwchange) {
#line 1441
    do_setusercontext(pw);
#line 1442
    child_close_fds();
#line 1443
    do_pwchange(s);
#line 1444
    exit(1);
  }
#line 1448
  if (options.use_login) {
#line 1448
    if ((unsigned int )command != (unsigned int )((void *)0)) {
#line 1449
      options.use_login = 0;
    }
  }
#line 1459
  if (! options.use_login) {
#line 1466
    if (! options.use_pam) {
#line 1467
      do_nologin(pw);
    }
#line 1468
    do_setusercontext(pw);
#line 1474
    tmp = check_quietlogin(s, command);
#line 1474
    if (! tmp) {
#line 1475
      display_loginmsg();
    }
  }
#line 1491
  if ((int )*(pw->pw_shell + 0) == 0) {
#line 1491
    shell = "/bin/sh";
  } else {
#line 1491
    shell = (char const   *)pw->pw_shell;
  }
#line 1497
  env = do_setup_env(s, shell);
#line 1504
  if (options.use_login) {
#line 1505
    hostname = get_remote_name_or_ip(utmp_len, options.use_dns);
  }
#line 1514
  child_close_fds();
#line 1520
  environ = env;
#line 1549
  tmp___2 = chdir((char const   *)pw->pw_dir);
#line 1549
  if (tmp___2 < 0) {
#line 1550
    tmp___0 = __errno_location();
#line 1550
    tmp___1 = strerror(*tmp___0);
#line 1550
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not chdir to home directory %s: %s\n",
            pw->pw_dir, tmp___1);
  }
#line 1558
  if (! options.use_login) {
#line 1559
    do_rc_files(s, shell);
  }
#line 1562
  mysignal(13, (void (*)(int  ))0);
#line 1564
  if (options.use_login) {
#line 1565
    launch_login(pw, hostname);
  }
#line 1570
  tmp___3 = strrchr(shell, '/');
#line 1570
  shell0 = (char const   *)tmp___3;
#line 1570
  if ((unsigned int )shell0 != (unsigned int )((void *)0)) {
#line 1571
    shell0 ++;
  } else {
#line 1573
    shell0 = shell;
  }
#line 1580
  if (! command) {
#line 1584
    argv0___0[0] = (char )'-';
#line 1586
    tmp___5 = strlcpy(argv0___0 + 1, shell0, sizeof(argv0___0) - 1U);
#line 1586
    if (tmp___5 >= sizeof(argv0___0) - 1U) {
#line 1588
      tmp___4 = __errno_location();
#line 1588
      *tmp___4 = 22;
#line 1589
      perror(shell);
#line 1590
      exit(1);
    }
#line 1594
    argv[0] = argv0___0;
#line 1595
    argv[1] = (char *)((void *)0);
#line 1596
    execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 1599
    perror(shell);
#line 1600
    exit(1);
  }
#line 1606
  argv[0] = (char *)shell0;
#line 1607
  argv[1] = (char *)"-c";
#line 1608
  argv[2] = (char *)command;
#line 1609
  argv[3] = (char *)((void *)0);
#line 1610
  execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 1611
  perror(shell);
#line 1612
  exit(1);
}
}
#line 1619 "session.c"
static int did_init___0  =    0;
#line 1615 "session.c"
Session *session_new(void) 
{ int i ;
  Session *s ;

  {
#line 1620
  if (! did_init___0) {
#line 1621
    debug("session_new: init");
#line 1622
    i = 0;
#line 1622
    while (i < 10) {
#line 1623
      sessions[i].used = 0;
#line 1622
      i ++;
    }
#line 1625
    did_init___0 = 1;
  }
#line 1627
  i = 0;
#line 1627
  while (i < 10) {
#line 1628
    s = & sessions[i];
#line 1629
    if (! s->used) {
#line 1630
      memset((void *)s, 0, sizeof(*s));
#line 1631
      s->chanid = -1;
#line 1632
      s->ptyfd = -1;
#line 1633
      s->ttyfd = -1;
#line 1634
      s->used = 1;
#line 1635
      s->self = i;
#line 1636
      s->x11_chanids = (int *)((void *)0);
#line 1637
      debug("session_new: session %d", i);
#line 1638
      return (s);
    }
#line 1627
    i ++;
  }
#line 1641
  return ((Session *)((void *)0));
}
}
#line 1644 "session.c"
static void session_dump(void) 
{ int i ;
  Session *s ;

  {
#line 1648
  i = 0;
#line 1648
  while (i < 10) {
#line 1649
    s = & sessions[i];
#line 1650
    debug("dump: used %d session %d %p channel %d pid %ld", s->used, s->self, s, s->chanid,
          (long )s->pid);
#line 1648
    i ++;
  }
#line 1657
  return;
}
}
#line 1659 "session.c"
int session_open(Authctxt *authctxt___0 , int chanid ) 
{ Session *s ;
  Session *tmp ;

  {
#line 1662
  tmp = session_new();
#line 1662
  s = tmp;
#line 1663
  debug("session_open: channel %d", chanid);
#line 1664
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1665
    error("no more sessions");
#line 1666
    return (0);
  }
#line 1668
  s->authctxt = authctxt___0;
#line 1669
  s->pw = authctxt___0->pw;
#line 1670
  if ((unsigned int )s->pw == (unsigned int )((void *)0)) {
#line 1671
    fatal("no user for session %d", s->self);
  } else {
#line 1670
    if (! authctxt___0->valid) {
#line 1671
      fatal("no user for session %d", s->self);
    }
  }
#line 1672
  debug("session_open: session %d: link with channel %d", s->self, chanid);
#line 1673
  s->chanid = chanid;
#line 1674
  return (1);
}
}
#line 1677 "session.c"
Session *session_by_tty(char *tty ) 
{ int i ;
  Session *s ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1681
  i = 0;
#line 1681
  while (i < 10) {
#line 1682
    s = & sessions[i];
#line 1683
    if (s->used) {
#line 1683
      if (s->ttyfd != -1) {
#line 1683
        if (0) {
#line 1683
          __s1_len = strlen((char const   *)(s->tty));
#line 1683
          __s2_len = strlen((char const   *)tty);
#line 1683
          if (! ((unsigned int )((void const   *)(s->tty + 1)) - (unsigned int )((void const   *)(s->tty)) == 1U)) {
            goto _L___0;
          } else {
#line 1683
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 1683
              if (! ((unsigned int )((void const   *)(tty + 1)) - (unsigned int )((void const   *)tty) == 1U)) {
#line 1683
                tmp___8 = 1;
              } else {
#line 1683
                if (__s2_len >= 4U) {
#line 1683
                  tmp___8 = 1;
                } else {
#line 1683
                  tmp___8 = 0;
                }
              }
            } else {
#line 1683
              tmp___8 = 0;
            }
          }
#line 1683
          if (tmp___8) {
#line 1683
            tmp___4 = __builtin_strcmp((char const   *)(s->tty), (char const   *)tty);
          } else {
#line 1683
            tmp___7 = __builtin_strcmp((char const   *)(s->tty), (char const   *)tty);
#line 1683
            tmp___4 = tmp___7;
          }
        } else {
#line 1683
          tmp___7 = __builtin_strcmp((char const   *)(s->tty), (char const   *)tty);
#line 1683
          tmp___4 = tmp___7;
        }
#line 1683
        if (tmp___4 == 0) {
#line 1684
          debug("session_by_tty: session %d tty %s", i, tty);
#line 1685
          return (s);
        }
      }
    }
#line 1681
    i ++;
  }
#line 1688
  debug("session_by_tty: unknown tty %.100s", tty);
#line 1689
  session_dump();
#line 1690
  return ((Session *)((void *)0));
}
}
#line 1693 "session.c"
static Session *session_by_channel(int id ) 
{ int i ;
  Session *s ;

  {
#line 1697
  i = 0;
#line 1697
  while (i < 10) {
#line 1698
    s = & sessions[i];
#line 1699
    if (s->used) {
#line 1699
      if (s->chanid == id) {
#line 1700
        debug("session_by_channel: session %d channel %d", i, id);
#line 1701
        return (s);
      }
    }
#line 1697
    i ++;
  }
#line 1704
  debug("session_by_channel: unknown channel %d", id);
#line 1705
  session_dump();
#line 1706
  return ((Session *)((void *)0));
}
}
#line 1709 "session.c"
static Session *session_by_x11_channel(int id ) 
{ int i ;
  int j ;
  Session *s ;

  {
#line 1714
  i = 0;
#line 1714
  while (i < 10) {
#line 1715
    s = & sessions[i];
#line 1717
    if ((unsigned int )s->x11_chanids == (unsigned int )((void *)0)) {
      goto __Cont;
    } else {
#line 1717
      if (! s->used) {
        goto __Cont;
      }
    }
#line 1719
    j = 0;
#line 1719
    while (*(s->x11_chanids + j) != -1) {
#line 1720
      if (*(s->x11_chanids + j) == id) {
#line 1721
        debug("session_by_x11_channel: session %d channel %d", s->self, id);
#line 1723
        return (s);
      }
#line 1719
      j ++;
    }
    __Cont: /* CIL Label */ 
#line 1714
    i ++;
  }
#line 1727
  debug("session_by_x11_channel: unknown channel %d", id);
#line 1728
  session_dump();
#line 1729
  return ((Session *)((void *)0));
}
}
#line 1732 "session.c"
static Session *session_by_pid(pid_t pid ) 
{ int i ;
  Session *s ;

  {
#line 1736
  debug("session_by_pid: pid %ld", (long )pid);
#line 1737
  i = 0;
#line 1737
  while (i < 10) {
#line 1738
    s = & sessions[i];
#line 1739
    if (s->used) {
#line 1739
      if (s->pid == pid) {
#line 1740
        return (s);
      }
    }
#line 1737
    i ++;
  }
#line 1742
  error("session_by_pid: unknown pid %ld", (long )pid);
#line 1743
  session_dump();
#line 1744
  return ((Session *)((void *)0));
}
}
#line 1747 "session.c"
static int session_window_change_req(Session *s ) 
{ int _len ;
  int tmp ;

  {
#line 1750
  s->col = packet_get_int();
#line 1751
  s->row = packet_get_int();
#line 1752
  s->xpixel = packet_get_int();
#line 1753
  s->ypixel = packet_get_int();
#line 1754
  while (1) {
#line 1754
    tmp = packet_remaining();
#line 1754
    _len = tmp;
#line 1754
    if (_len > 0) {
#line 1754
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            1754);
#line 1754
      packet_disconnect("Packet integrity error.");
    }
#line 1754
    break;
  }
#line 1755
  pty_change_window_size(s->ptyfd, (int )s->row, (int )s->col, (int )s->xpixel, (int )s->ypixel);
#line 1756
  return (1);
}
}
#line 1759 "session.c"
static int session_pty_req(Session *s ) 
{ u_int len ;
  int n_bytes ;
  void *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___12 ;
  int _len ;
  int tmp___13 ;

  {
#line 1765
  if (no_pty_flag) {
#line 1766
    debug("Allocating a pty not permitted for this authentication.");
#line 1767
    return (0);
  }
#line 1769
  if (s->ttyfd != -1) {
#line 1770
    packet_disconnect("Protocol error: you already have a pty.");
#line 1771
    return (0);
  }
#line 1774
  tmp = packet_get_string(& len);
#line 1774
  s->term = (char *)tmp;
#line 1776
  if (compat20) {
#line 1777
    s->col = packet_get_int();
#line 1778
    s->row = packet_get_int();
  } else {
#line 1780
    s->row = packet_get_int();
#line 1781
    s->col = packet_get_int();
  }
#line 1783
  s->xpixel = packet_get_int();
#line 1784
  s->ypixel = packet_get_int();
#line 1786
  if (0) {
#line 1786
    __s1_len = strlen((char const   *)s->term);
#line 1786
    __s2_len = strlen("");
#line 1786
    if (! ((unsigned int )((void const   *)(s->term + 1)) - (unsigned int )((void const   *)s->term) == 1U)) {
      goto _L___0;
    } else {
#line 1786
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1786
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 1786
          tmp___9 = 1;
        } else {
#line 1786
          if (__s2_len >= 4U) {
#line 1786
            tmp___9 = 1;
          } else {
#line 1786
            tmp___9 = 0;
          }
        }
      } else {
#line 1786
        tmp___9 = 0;
      }
    }
#line 1786
    if (tmp___9) {
#line 1786
      tmp___5 = __builtin_strcmp((char const   *)s->term, "");
    } else {
#line 1786
      tmp___8 = __builtin_strcmp((char const   *)s->term, "");
#line 1786
      tmp___5 = tmp___8;
    }
  } else {
#line 1786
    tmp___8 = __builtin_strcmp((char const   *)s->term, "");
#line 1786
    tmp___5 = tmp___8;
  }
#line 1786
  if (tmp___5 == 0) {
#line 1787
    xfree((void *)s->term);
#line 1788
    s->term = (char *)((void *)0);
  }
#line 1792
  debug("Allocating pty.");
#line 1793
  if (use_privsep) {
#line 1793
    tmp___12 = mm_pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, (int )sizeof(s->tty));
  } else {
#line 1793
    tmp___12 = pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, (int )sizeof(s->tty));
  }
#line 1793
  if (! tmp___12) {
#line 1794
    if (s->term) {
#line 1795
      xfree((void *)s->term);
    }
#line 1796
    s->term = (char *)((void *)0);
#line 1797
    s->ptyfd = -1;
#line 1798
    s->ttyfd = -1;
#line 1799
    error("session_pty_req: session %d alloc failed", s->self);
#line 1800
    return (0);
  }
#line 1802
  debug("session_pty_req: session %d alloc %s", s->self, s->tty);
#line 1805
  if (! compat20) {
#line 1806
    n_bytes = packet_remaining();
  }
#line 1807
  tty_parse_modes(s->ttyfd, & n_bytes);
#line 1809
  if (! use_privsep) {
#line 1810
    pty_setowner(s->pw, (char const   *)(s->tty));
  }
#line 1813
  pty_change_window_size(s->ptyfd, (int )s->row, (int )s->col, (int )s->xpixel, (int )s->ypixel);
#line 1815
  while (1) {
#line 1815
    tmp___13 = packet_remaining();
#line 1815
    _len = tmp___13;
#line 1815
    if (_len > 0) {
#line 1815
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            1815);
#line 1815
      packet_disconnect("Packet integrity error.");
    }
#line 1815
    break;
  }
#line 1816
  session_proctitle(s);
#line 1817
  return (1);
}
}
#line 1820 "session.c"
static int session_subsystem_req(Session *s ) 
{ struct stat st ;
  u_int len ;
  int success ;
  char *cmd ;
  char *subsys ;
  void *tmp ;
  u_int i ;
  int _len ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___9 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 1825
  success = 0;
#line 1826
  tmp = packet_get_string(& len);
#line 1826
  subsys = (char *)tmp;
#line 1829
  while (1) {
#line 1829
    tmp___0 = packet_remaining();
#line 1829
    _len = tmp___0;
#line 1829
    if (_len > 0) {
#line 1829
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            1829);
#line 1829
      packet_disconnect("Packet integrity error.");
    }
#line 1829
    break;
  }
#line 1830
  logit("subsystem request for %.100s", subsys);
#line 1832
  i = 0U;
#line 1832
  while (i < options.num_subsystems) {
#line 1833
    if (0) {
#line 1833
      __s1_len = strlen((char const   *)subsys);
#line 1833
      __s2_len = strlen((char const   *)options.subsystem_name[i]);
#line 1833
      if (! ((unsigned int )((void const   *)(subsys + 1)) - (unsigned int )((void const   *)subsys) == 1U)) {
        goto _L___0;
      } else {
#line 1833
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 1833
          if (! ((unsigned int )((void const   *)(options.subsystem_name[i] + 1)) - (unsigned int )((void const   *)options.subsystem_name[i]) == 1U)) {
#line 1833
            tmp___13 = 1;
          } else {
#line 1833
            if (__s2_len >= 4U) {
#line 1833
              tmp___13 = 1;
            } else {
#line 1833
              tmp___13 = 0;
            }
          }
        } else {
#line 1833
          tmp___13 = 0;
        }
      }
#line 1833
      if (tmp___13) {
#line 1833
        tmp___9 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
      } else {
#line 1833
        tmp___12 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
#line 1833
        tmp___9 = tmp___12;
      }
    } else {
#line 1833
      tmp___12 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
#line 1833
      tmp___9 = tmp___12;
    }
#line 1833
    if (tmp___9 == 0) {
#line 1834
      cmd = options.subsystem_command[i];
#line 1835
      tmp___3 = stat((char const   * __restrict  )cmd, (struct stat * __restrict  )(& st));
#line 1835
      if (tmp___3 < 0) {
#line 1836
        tmp___1 = __errno_location();
#line 1836
        tmp___2 = strerror(*tmp___1);
#line 1836
        error("subsystem: cannot stat %s: %s", cmd, tmp___2);
#line 1838
        break;
      }
#line 1840
      debug("subsystem: exec() %s", cmd);
#line 1841
      s->is_subsystem = 1;
#line 1842
      do_exec(s, (char const   *)cmd);
#line 1843
      success = 1;
#line 1844
      break;
    }
#line 1832
    i ++;
  }
#line 1848
  if (! success) {
#line 1849
    logit("subsystem request for %.100s failed, subsystem not found", subsys);
  }
#line 1852
  xfree((void *)subsys);
#line 1853
  return (success);
}
}
#line 1856 "session.c"
static int session_x11_req(Session *s ) 
{ int success ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int _len ;
  int tmp___2 ;

  {
#line 1861
  if ((unsigned int )s->auth_proto != (unsigned int )((void *)0)) {
#line 1862
    error("session_x11_req: session %d: x11 forwarding already active", s->self);
#line 1864
    return (0);
  } else {
#line 1861
    if ((unsigned int )s->auth_data != (unsigned int )((void *)0)) {
#line 1862
      error("session_x11_req: session %d: x11 forwarding already active", s->self);
#line 1864
      return (0);
    }
  }
#line 1866
  tmp = packet_get_char();
#line 1866
  s->single_connection = (int )tmp;
#line 1867
  tmp___0 = packet_get_string((u_int *)((void *)0));
#line 1867
  s->auth_proto = (char *)tmp___0;
#line 1868
  tmp___1 = packet_get_string((u_int *)((void *)0));
#line 1868
  s->auth_data = (char *)tmp___1;
#line 1869
  s->screen = packet_get_int();
#line 1870
  while (1) {
#line 1870
    tmp___2 = packet_remaining();
#line 1870
    _len = tmp___2;
#line 1870
    if (_len > 0) {
#line 1870
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            1870);
#line 1870
      packet_disconnect("Packet integrity error.");
    }
#line 1870
    break;
  }
#line 1872
  success = session_setup_x11fwd(s);
#line 1873
  if (! success) {
#line 1874
    xfree((void *)s->auth_proto);
#line 1875
    xfree((void *)s->auth_data);
#line 1876
    s->auth_proto = (char *)((void *)0);
#line 1877
    s->auth_data = (char *)((void *)0);
  }
#line 1879
  return (success);
}
}
#line 1882 "session.c"
static int session_shell_req(Session *s ) 
{ int _len ;
  int tmp ;

  {
#line 1885
  while (1) {
#line 1885
    tmp = packet_remaining();
#line 1885
    _len = tmp;
#line 1885
    if (_len > 0) {
#line 1885
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            1885);
#line 1885
      packet_disconnect("Packet integrity error.");
    }
#line 1885
    break;
  }
#line 1886
  do_exec(s, (char const   *)((void *)0));
#line 1887
  return (1);
}
}
#line 1890 "session.c"
static int session_exec_req(Session *s ) 
{ u_int len ;
  char *command ;
  void *tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 1894
  tmp = packet_get_string(& len);
#line 1894
  command = (char *)tmp;
#line 1895
  while (1) {
#line 1895
    tmp___0 = packet_remaining();
#line 1895
    _len = tmp___0;
#line 1895
    if (_len > 0) {
#line 1895
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            1895);
#line 1895
      packet_disconnect("Packet integrity error.");
    }
#line 1895
    break;
  }
#line 1896
  do_exec(s, (char const   *)command);
#line 1897
  xfree((void *)command);
#line 1898
  return (1);
}
}
#line 1901 "session.c"
static int session_break_req(Session *s ) 
{ int _len ;
  int tmp ;
  int tmp___0 ;

  {
#line 1905
  packet_get_int();
#line 1906
  while (1) {
#line 1906
    tmp = packet_remaining();
#line 1906
    _len = tmp;
#line 1906
    if (_len > 0) {
#line 1906
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            1906);
#line 1906
      packet_disconnect("Packet integrity error.");
    }
#line 1906
    break;
  }
#line 1908
  if (s->ttyfd == -1) {
#line 1910
    return (0);
  } else {
#line 1908
    tmp___0 = tcsendbreak(s->ttyfd, 0);
#line 1908
    if (tmp___0 < 0) {
#line 1910
      return (0);
    }
  }
#line 1911
  return (1);
}
}
#line 1914 "session.c"
static int session_env_req(Session *s ) 
{ char *name ;
  char *val ;
  u_int name_len ;
  u_int val_len ;
  u_int i ;
  void *tmp ;
  void *tmp___0 ;
  int _len ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 1920
  tmp = packet_get_string(& name_len);
#line 1920
  name = (char *)tmp;
#line 1921
  tmp___0 = packet_get_string(& val_len);
#line 1921
  val = (char *)tmp___0;
#line 1922
  while (1) {
#line 1922
    tmp___1 = packet_remaining();
#line 1922
    _len = tmp___1;
#line 1922
    if (_len > 0) {
#line 1922
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            1922);
#line 1922
      packet_disconnect("Packet integrity error.");
    }
#line 1922
    break;
  }
#line 1925
  if (s->num_env > 128U) {
#line 1926
    debug2("Ignoring env request %s: too many env vars", name);
    goto fail;
  }
#line 1930
  i = 0U;
#line 1930
  while (i < options.num_accept_env) {
#line 1931
    tmp___3 = match_pattern((char const   *)name, (char const   *)options.accept_env[i]);
#line 1931
    if (tmp___3) {
#line 1932
      debug2("Setting env %d: %s=%s", s->num_env, name, val);
#line 1933
      tmp___2 = xrealloc((void *)s->env, sizeof(*(s->env)) * (s->num_env + 1U));
#line 1933
      s->env = (struct __anonstruct_env_82 *)tmp___2;
#line 1935
      (s->env + s->num_env)->name = name;
#line 1936
      (s->env + s->num_env)->val = val;
#line 1937
      (s->num_env) ++;
#line 1938
      return (1);
    }
#line 1930
    i ++;
  }
#line 1941
  debug2("Ignoring env request %s: disallowed name", name);
  fail: 
#line 1944
  xfree((void *)name);
#line 1945
  xfree((void *)val);
#line 1946
  return (0);
}
}
#line 1952
static int session_auth_agent_req(Session *s ) ;
#line 1952 "session.c"
static int called___1  =    0;
#line 1949 "session.c"
static int session_auth_agent_req(Session *s ) 
{ int _len ;
  int tmp ;
  int tmp___0 ;

  {
#line 1953
  while (1) {
#line 1953
    tmp = packet_remaining();
#line 1953
    _len = tmp;
#line 1953
    if (_len > 0) {
#line 1953
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            1953);
#line 1953
      packet_disconnect("Packet integrity error.");
    }
#line 1953
    break;
  }
#line 1954
  if (no_agent_forwarding_flag) {
#line 1955
    debug("session_auth_agent_req: no_agent_forwarding_flag");
#line 1956
    return (0);
  }
#line 1958
  if (called___1) {
#line 1959
    return (0);
  } else {
#line 1961
    called___1 = 1;
#line 1962
    tmp___0 = auth_input_request_forwarding(s->pw);
#line 1962
    return (tmp___0);
  }
}
}
#line 1966 "session.c"
int session_input_channel_req(Channel *c , char const   *rtype ) 
{ int success ;
  Session *s ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___54 ;
  int tmp___57 ;
  int tmp___58 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___64 ;
  int tmp___67 ;
  int tmp___68 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___74 ;
  int tmp___77 ;
  int tmp___78 ;
  size_t __s1_len___7 ;
  size_t __s2_len___7 ;
  int tmp___84 ;
  int tmp___87 ;
  int tmp___88 ;

  {
#line 1969
  success = 0;
#line 1972
  s = session_by_channel(c->self);
#line 1972
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1973
    logit("session_input_channel_req: no session %d req %.100s", c->self, rtype);
#line 1975
    return (0);
  }
#line 1977
  debug("session_input_channel_req: session %d req %s", s->self, rtype);
#line 1983
  if (c->type == 10) {
#line 1984
    if (0) {
#line 1984
      __s1_len___5 = strlen(rtype);
#line 1984
      __s2_len___5 = strlen("shell");
#line 1984
      if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
        goto _L___12;
      } else {
#line 1984
        if (__s1_len___5 >= 4U) {
          _L___12: /* CIL Label */ 
#line 1984
          if (! ((unsigned int )((void const   *)("shell" + 1)) - (unsigned int )((void const   *)"shell") == 1U)) {
#line 1984
            tmp___68 = 1;
          } else {
#line 1984
            if (__s2_len___5 >= 4U) {
#line 1984
              tmp___68 = 1;
            } else {
#line 1984
              tmp___68 = 0;
            }
          }
        } else {
#line 1984
          tmp___68 = 0;
        }
      }
#line 1984
      if (tmp___68) {
#line 1984
        tmp___64 = __builtin_strcmp(rtype, "shell");
      } else {
#line 1984
        tmp___67 = __builtin_strcmp(rtype, "shell");
#line 1984
        tmp___64 = tmp___67;
      }
    } else {
#line 1984
      tmp___67 = __builtin_strcmp(rtype, "shell");
#line 1984
      tmp___64 = tmp___67;
    }
#line 1984
    if (tmp___64 == 0) {
#line 1985
      success = session_shell_req(s);
    } else {
#line 1986
      if (0) {
#line 1986
        __s1_len___4 = strlen(rtype);
#line 1986
        __s2_len___4 = strlen("exec");
#line 1986
        if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
          goto _L___10;
        } else {
#line 1986
          if (__s1_len___4 >= 4U) {
            _L___10: /* CIL Label */ 
#line 1986
            if (! ((unsigned int )((void const   *)("exec" + 1)) - (unsigned int )((void const   *)"exec") == 1U)) {
#line 1986
              tmp___58 = 1;
            } else {
#line 1986
              if (__s2_len___4 >= 4U) {
#line 1986
                tmp___58 = 1;
              } else {
#line 1986
                tmp___58 = 0;
              }
            }
          } else {
#line 1986
            tmp___58 = 0;
          }
        }
#line 1986
        if (tmp___58) {
#line 1986
          tmp___54 = __builtin_strcmp(rtype, "exec");
        } else {
#line 1986
          tmp___57 = __builtin_strcmp(rtype, "exec");
#line 1986
          tmp___54 = tmp___57;
        }
      } else {
#line 1986
        tmp___57 = __builtin_strcmp(rtype, "exec");
#line 1986
        tmp___54 = tmp___57;
      }
#line 1986
      if (tmp___54 == 0) {
#line 1987
        success = session_exec_req(s);
      } else {
#line 1988
        if (0) {
#line 1988
          __s1_len___3 = strlen(rtype);
#line 1988
          __s2_len___3 = strlen("pty-req");
#line 1988
          if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
            goto _L___8;
          } else {
#line 1988
            if (__s1_len___3 >= 4U) {
              _L___8: /* CIL Label */ 
#line 1988
              if (! ((unsigned int )((void const   *)("pty-req" + 1)) - (unsigned int )((void const   *)"pty-req") == 1U)) {
#line 1988
                tmp___48 = 1;
              } else {
#line 1988
                if (__s2_len___3 >= 4U) {
#line 1988
                  tmp___48 = 1;
                } else {
#line 1988
                  tmp___48 = 0;
                }
              }
            } else {
#line 1988
              tmp___48 = 0;
            }
          }
#line 1988
          if (tmp___48) {
#line 1988
            tmp___44 = __builtin_strcmp(rtype, "pty-req");
          } else {
#line 1988
            tmp___47 = __builtin_strcmp(rtype, "pty-req");
#line 1988
            tmp___44 = tmp___47;
          }
        } else {
#line 1988
          tmp___47 = __builtin_strcmp(rtype, "pty-req");
#line 1988
          tmp___44 = tmp___47;
        }
#line 1988
        if (tmp___44 == 0) {
#line 1989
          success = session_pty_req(s);
        } else {
#line 1990
          if (0) {
#line 1990
            __s1_len___2 = strlen(rtype);
#line 1990
            __s2_len___2 = strlen("x11-req");
#line 1990
            if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
              goto _L___6;
            } else {
#line 1990
              if (__s1_len___2 >= 4U) {
                _L___6: /* CIL Label */ 
#line 1990
                if (! ((unsigned int )((void const   *)("x11-req" + 1)) - (unsigned int )((void const   *)"x11-req") == 1U)) {
#line 1990
                  tmp___38 = 1;
                } else {
#line 1990
                  if (__s2_len___2 >= 4U) {
#line 1990
                    tmp___38 = 1;
                  } else {
#line 1990
                    tmp___38 = 0;
                  }
                }
              } else {
#line 1990
                tmp___38 = 0;
              }
            }
#line 1990
            if (tmp___38) {
#line 1990
              tmp___34 = __builtin_strcmp(rtype, "x11-req");
            } else {
#line 1990
              tmp___37 = __builtin_strcmp(rtype, "x11-req");
#line 1990
              tmp___34 = tmp___37;
            }
          } else {
#line 1990
            tmp___37 = __builtin_strcmp(rtype, "x11-req");
#line 1990
            tmp___34 = tmp___37;
          }
#line 1990
          if (tmp___34 == 0) {
#line 1991
            success = session_x11_req(s);
          } else {
#line 1992
            if (0) {
#line 1992
              __s1_len___1 = strlen(rtype);
#line 1992
              __s2_len___1 = strlen("auth-agent-req@openssh.com");
#line 1992
              if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
                goto _L___4;
              } else {
#line 1992
                if (__s1_len___1 >= 4U) {
                  _L___4: /* CIL Label */ 
#line 1992
                  if (! ((unsigned int )((void const   *)("auth-agent-req@openssh.com" + 1)) - (unsigned int )((void const   *)"auth-agent-req@openssh.com") == 1U)) {
#line 1992
                    tmp___28 = 1;
                  } else {
#line 1992
                    if (__s2_len___1 >= 4U) {
#line 1992
                      tmp___28 = 1;
                    } else {
#line 1992
                      tmp___28 = 0;
                    }
                  }
                } else {
#line 1992
                  tmp___28 = 0;
                }
              }
#line 1992
              if (tmp___28) {
#line 1992
                tmp___24 = __builtin_strcmp(rtype, "auth-agent-req@openssh.com");
              } else {
#line 1992
                tmp___27 = __builtin_strcmp(rtype, "auth-agent-req@openssh.com");
#line 1992
                tmp___24 = tmp___27;
              }
            } else {
#line 1992
              tmp___27 = __builtin_strcmp(rtype, "auth-agent-req@openssh.com");
#line 1992
              tmp___24 = tmp___27;
            }
#line 1992
            if (tmp___24 == 0) {
#line 1993
              success = session_auth_agent_req(s);
            } else {
#line 1994
              if (0) {
#line 1994
                __s1_len___0 = strlen(rtype);
#line 1994
                __s2_len___0 = strlen("subsystem");
#line 1994
                if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
                  goto _L___2;
                } else {
#line 1994
                  if (__s1_len___0 >= 4U) {
                    _L___2: /* CIL Label */ 
#line 1994
                    if (! ((unsigned int )((void const   *)("subsystem" + 1)) - (unsigned int )((void const   *)"subsystem") == 1U)) {
#line 1994
                      tmp___18 = 1;
                    } else {
#line 1994
                      if (__s2_len___0 >= 4U) {
#line 1994
                        tmp___18 = 1;
                      } else {
#line 1994
                        tmp___18 = 0;
                      }
                    }
                  } else {
#line 1994
                    tmp___18 = 0;
                  }
                }
#line 1994
                if (tmp___18) {
#line 1994
                  tmp___14 = __builtin_strcmp(rtype, "subsystem");
                } else {
#line 1994
                  tmp___17 = __builtin_strcmp(rtype, "subsystem");
#line 1994
                  tmp___14 = tmp___17;
                }
              } else {
#line 1994
                tmp___17 = __builtin_strcmp(rtype, "subsystem");
#line 1994
                tmp___14 = tmp___17;
              }
#line 1994
              if (tmp___14 == 0) {
#line 1995
                success = session_subsystem_req(s);
              } else {
#line 1996
                if (0) {
#line 1996
                  __s1_len = strlen(rtype);
#line 1996
                  __s2_len = strlen("env");
#line 1996
                  if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
                    goto _L___0;
                  } else {
#line 1996
                    if (__s1_len >= 4U) {
                      _L___0: /* CIL Label */ 
#line 1996
                      if (! ((unsigned int )((void const   *)("env" + 1)) - (unsigned int )((void const   *)"env") == 1U)) {
#line 1996
                        tmp___8 = 1;
                      } else {
#line 1996
                        if (__s2_len >= 4U) {
#line 1996
                          tmp___8 = 1;
                        } else {
#line 1996
                          tmp___8 = 0;
                        }
                      }
                    } else {
#line 1996
                      tmp___8 = 0;
                    }
                  }
#line 1996
                  if (tmp___8) {
#line 1996
                    tmp___4 = __builtin_strcmp(rtype, "env");
                  } else {
#line 1996
                    tmp___7 = __builtin_strcmp(rtype, "env");
#line 1996
                    tmp___4 = tmp___7;
                  }
                } else {
#line 1996
                  tmp___7 = __builtin_strcmp(rtype, "env");
#line 1996
                  tmp___4 = tmp___7;
                }
#line 1996
                if (tmp___4 == 0) {
#line 1997
                  success = session_env_req(s);
                }
              }
            }
          }
        }
      }
    }
  }
#line 2000
  if (0) {
#line 2000
    __s1_len___7 = strlen(rtype);
#line 2000
    __s2_len___7 = strlen("window-change");
#line 2000
    if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
      goto _L___16;
    } else {
#line 2000
      if (__s1_len___7 >= 4U) {
        _L___16: /* CIL Label */ 
#line 2000
        if (! ((unsigned int )((void const   *)("window-change" + 1)) - (unsigned int )((void const   *)"window-change") == 1U)) {
#line 2000
          tmp___88 = 1;
        } else {
#line 2000
          if (__s2_len___7 >= 4U) {
#line 2000
            tmp___88 = 1;
          } else {
#line 2000
            tmp___88 = 0;
          }
        }
      } else {
#line 2000
        tmp___88 = 0;
      }
    }
#line 2000
    if (tmp___88) {
#line 2000
      tmp___84 = __builtin_strcmp(rtype, "window-change");
    } else {
#line 2000
      tmp___87 = __builtin_strcmp(rtype, "window-change");
#line 2000
      tmp___84 = tmp___87;
    }
  } else {
#line 2000
    tmp___87 = __builtin_strcmp(rtype, "window-change");
#line 2000
    tmp___84 = tmp___87;
  }
#line 2000
  if (tmp___84 == 0) {
#line 2001
    success = session_window_change_req(s);
  } else {
#line 2002
    if (0) {
#line 2002
      __s1_len___6 = strlen(rtype);
#line 2002
      __s2_len___6 = strlen("break");
#line 2002
      if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
        goto _L___14;
      } else {
#line 2002
        if (__s1_len___6 >= 4U) {
          _L___14: /* CIL Label */ 
#line 2002
          if (! ((unsigned int )((void const   *)("break" + 1)) - (unsigned int )((void const   *)"break") == 1U)) {
#line 2002
            tmp___78 = 1;
          } else {
#line 2002
            if (__s2_len___6 >= 4U) {
#line 2002
              tmp___78 = 1;
            } else {
#line 2002
              tmp___78 = 0;
            }
          }
        } else {
#line 2002
          tmp___78 = 0;
        }
      }
#line 2002
      if (tmp___78) {
#line 2002
        tmp___74 = __builtin_strcmp(rtype, "break");
      } else {
#line 2002
        tmp___77 = __builtin_strcmp(rtype, "break");
#line 2002
        tmp___74 = tmp___77;
      }
    } else {
#line 2002
      tmp___77 = __builtin_strcmp(rtype, "break");
#line 2002
      tmp___74 = tmp___77;
    }
#line 2002
    if (tmp___74 == 0) {
#line 2003
      success = session_break_req(s);
    }
  }
#line 2006
  return (success);
}
}
#line 2009 "session.c"
void session_set_fds(Session *s , int fdin___0 , int fdout___0 , int fderr___0 ) 
{ int tmp ;

  {
#line 2012
  if (! compat20) {
#line 2013
    fatal("session_set_fds: called for proto != 2.0");
  }
#line 2018
  if (s->chanid == -1) {
#line 2019
    fatal("no channel for session %d", s->self);
  }
#line 2020
  if (fderr___0 == -1) {
#line 2020
    tmp = 0;
  } else {
#line 2020
    tmp = 1;
  }
#line 2020
  channel_set_fds(s->chanid, fdout___0, fdin___0, fderr___0, tmp, 1, 131072U);
#line 2025
  return;
}
}
#line 2031 "session.c"
void session_pty_cleanup2(Session *s ) 
{ __uid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 2034
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 2035
    error("session_pty_cleanup: no session");
#line 2036
    return;
  }
#line 2038
  if (s->ttyfd == -1) {
#line 2039
    return;
  }
#line 2041
  debug("session_pty_cleanup: session %d release %s", s->self, s->tty);
#line 2044
  if (s->pid != 0) {
#line 2045
    record_logout(s->pid, (char const   *)(s->tty), (char const   *)(s->pw)->pw_name);
  }
#line 2048
  tmp = getuid();
#line 2048
  if (tmp == 0U) {
#line 2049
    pty_release((char const   *)(s->tty));
  }
#line 2056
  tmp___2 = close(s->ptymaster);
#line 2056
  if (tmp___2 < 0) {
#line 2057
    tmp___0 = __errno_location();
#line 2057
    tmp___1 = strerror(*tmp___0);
#line 2057
    error("close(s->ptymaster/%d): %s", s->ptymaster, tmp___1);
  }
#line 2060
  s->ttyfd = -1;
#line 2061
  return;
}
}
#line 2063 "session.c"
void session_pty_cleanup(Session *s ) 
{ 

  {
#line 2066
  if (use_privsep) {
#line 2066
    mm_session_pty_cleanup2(s);
  } else {
#line 2066
    session_pty_cleanup2(s);
  }
#line 2067
  return;
}
}
#line 2069 "session.c"
static char *sig2name(int sig ) 
{ 

  {
#line 2073
  if (sig == 6) {
#line 2073
    return ((char *)"ABRT");
  }
#line 2074
  if (sig == 14) {
#line 2074
    return ((char *)"ALRM");
  }
#line 2075
  if (sig == 8) {
#line 2075
    return ((char *)"FPE");
  }
#line 2076
  if (sig == 1) {
#line 2076
    return ((char *)"HUP");
  }
#line 2077
  if (sig == 4) {
#line 2077
    return ((char *)"ILL");
  }
#line 2078
  if (sig == 2) {
#line 2078
    return ((char *)"INT");
  }
#line 2079
  if (sig == 9) {
#line 2079
    return ((char *)"KILL");
  }
#line 2080
  if (sig == 13) {
#line 2080
    return ((char *)"PIPE");
  }
#line 2081
  if (sig == 3) {
#line 2081
    return ((char *)"QUIT");
  }
#line 2082
  if (sig == 11) {
#line 2082
    return ((char *)"SEGV");
  }
#line 2083
  if (sig == 15) {
#line 2083
    return ((char *)"TERM");
  }
#line 2084
  if (sig == 10) {
#line 2084
    return ((char *)"USR1");
  }
#line 2085
  if (sig == 12) {
#line 2085
    return ((char *)"USR2");
  }
#line 2087
  return ((char *)"SIG@openssh.com");
}
}
#line 2090 "session.c"
static void session_close_x11(int id ) 
{ Channel *c ;

  {
#line 2095
  c = channel_by_id(id);
#line 2095
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2096
    debug("session_close_x11: x11 channel %d missing", id);
  } else {
#line 2099
    debug("session_close_x11: detach x11 channel %d", id);
#line 2100
    channel_cancel_cleanup(id);
#line 2101
    if (c->ostate != 3U) {
#line 2102
      chan_mark_dead(c);
    }
  }
#line 2104
  return;
}
}
#line 2106 "session.c"
static void session_close_single_x11(int id , void *arg ) 
{ Session *s ;
  u_int i ;

  {
#line 2112
  debug3("session_close_single_x11: channel %d", id);
#line 2113
  channel_cancel_cleanup(id);
#line 2114
  s = session_by_x11_channel(id);
#line 2114
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 2115
    fatal("session_close_single_x11: no x11 channel %d", id);
  }
#line 2116
  i = 0U;
#line 2116
  while (*(s->x11_chanids + i) != -1) {
#line 2117
    debug("session_close_single_x11: session %d: closing channel %d", s->self, *(s->x11_chanids + i));
#line 2123
    if (*(s->x11_chanids + i) != id) {
#line 2124
      session_close_x11(*(s->x11_chanids + i));
    }
#line 2116
    i ++;
  }
#line 2126
  xfree((void *)s->x11_chanids);
#line 2127
  s->x11_chanids = (int *)((void *)0);
#line 2128
  if (s->display) {
#line 2129
    xfree((void *)s->display);
#line 2130
    s->display = (char *)((void *)0);
  }
#line 2132
  if (s->auth_proto) {
#line 2133
    xfree((void *)s->auth_proto);
#line 2134
    s->auth_proto = (char *)((void *)0);
  }
#line 2136
  if (s->auth_data) {
#line 2137
    xfree((void *)s->auth_data);
#line 2138
    s->auth_data = (char *)((void *)0);
  }
#line 2140
  if (s->auth_display) {
#line 2141
    xfree((void *)s->auth_display);
#line 2142
    s->auth_display = (char *)((void *)0);
  }
#line 2144
  return;
}
}
#line 2146 "session.c"
static void session_exit_message(Session *s , int status ) 
{ Channel *c ;
  union __anonunion___u_84 __u ;
  union __anonunion___u_85___0 __u___0 ;
  char *tmp ;
  union __anonunion___u_86___0 __u___1 ;
  union __anonunion___u_87___0 __u___2 ;
  union __anonunion___u_88___0 __u___3 ;

  {
#line 2151
  c = channel_lookup(s->chanid);
#line 2151
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2152
    fatal("session_exit_message: session %d: no channel %d", s->self, s->chanid);
  }
#line 2154
  debug("session_exit_message: session %d channel %d pid %ld", s->self, s->chanid,
        (long )s->pid);
#line 2157
  __u___3.__in = status;
#line 2157
  if ((__u___3.__i & 127) == 0) {
#line 2158
    channel_request_start(s->chanid, (char *)"exit-status", 0);
#line 2159
    __u.__in = status;
#line 2159
    packet_put_int((unsigned int )((__u.__i & 65280) >> 8));
#line 2160
    packet_send();
  } else {
#line 2161
    __u___2.__in = status;
#line 2161
    if ((int )((signed char )((__u___2.__i & 127) + 1)) >> 1 > 0) {
#line 2162
      channel_request_start(s->chanid, (char *)"exit-signal", 0);
#line 2163
      __u___0.__in = status;
#line 2163
      tmp = sig2name(__u___0.__i & 127);
#line 2163
      packet_put_cstring((char const   *)tmp);
#line 2165
      __u___1.__in = status;
#line 2165
      packet_put_char(__u___1.__i & 128);
#line 2169
      packet_put_cstring("");
#line 2170
      packet_put_cstring("");
#line 2171
      packet_send();
    } else {
#line 2174
      packet_disconnect("wait returned status %04x.", status);
    }
  }
#line 2178
  debug("session_exit_message: release channel %d", s->chanid);
#line 2179
  s->pid = 0;
#line 2186
  channel_register_cleanup(c->self, & session_close_by_channel, 1);
#line 2194
  if (c->ostate != 3U) {
#line 2195
    chan_write_failed(c);
  }
#line 2196
  return;
}
}
#line 2198 "session.c"
void session_close(Session *s ) 
{ u_int i ;

  {
#line 2203
  debug("session_close: session %d pid %ld", s->self, (long )s->pid);
#line 2204
  if (s->ttyfd != -1) {
#line 2205
    session_pty_cleanup(s);
  }
#line 2206
  if (s->term) {
#line 2207
    xfree((void *)s->term);
  }
#line 2208
  if (s->display) {
#line 2209
    xfree((void *)s->display);
  }
#line 2210
  if (s->x11_chanids) {
#line 2211
    xfree((void *)s->x11_chanids);
  }
#line 2212
  if (s->auth_display) {
#line 2213
    xfree((void *)s->auth_display);
  }
#line 2214
  if (s->auth_data) {
#line 2215
    xfree((void *)s->auth_data);
  }
#line 2216
  if (s->auth_proto) {
#line 2217
    xfree((void *)s->auth_proto);
  }
#line 2218
  s->used = 0;
#line 2219
  i = 0U;
#line 2219
  while (i < s->num_env) {
#line 2220
    xfree((void *)(s->env + i)->name);
#line 2221
    xfree((void *)(s->env + i)->val);
#line 2219
    i ++;
  }
#line 2223
  if ((unsigned int )s->env != (unsigned int )((void *)0)) {
#line 2224
    xfree((void *)s->env);
  }
#line 2225
  session_proctitle(s);
#line 2226
  return;
}
}
#line 2228 "session.c"
void session_close_by_pid(pid_t pid , int status ) 
{ Session *s ;
  Session *tmp ;

  {
#line 2231
  tmp = session_by_pid(pid);
#line 2231
  s = tmp;
#line 2232
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 2233
    debug("session_close_by_pid: no session for pid %ld", (long )pid);
#line 2235
    return;
  }
#line 2237
  if (s->chanid != -1) {
#line 2238
    session_exit_message(s, status);
  }
#line 2239
  if (s->ttyfd != -1) {
#line 2240
    session_pty_cleanup(s);
  }
#line 2241
  return;
}
}
#line 2247 "session.c"
void session_close_by_channel(int id , void *arg ) 
{ Session *s ;
  Session *tmp ;
  u_int i ;

  {
#line 2250
  tmp = session_by_channel(id);
#line 2250
  s = tmp;
#line 2253
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 2254
    debug("session_close_by_channel: no session for id %d", id);
#line 2255
    return;
  }
#line 2257
  debug("session_close_by_channel: channel %d child %ld", id, (long )s->pid);
#line 2259
  if (s->pid != 0) {
#line 2260
    debug("session_close_by_channel: channel %d: has child", id);
#line 2265
    if (s->ttyfd != -1) {
#line 2266
      session_pty_cleanup(s);
    }
#line 2267
    return;
  }
#line 2270
  channel_cancel_cleanup(s->chanid);
#line 2273
  if ((unsigned int )s->x11_chanids != (unsigned int )((void *)0)) {
#line 2274
    i = 0U;
#line 2274
    while (*(s->x11_chanids + i) != -1) {
#line 2275
      session_close_x11(*(s->x11_chanids + i));
#line 2276
      *(s->x11_chanids + i) = -1;
#line 2274
      i ++;
    }
  }
#line 2280
  s->chanid = -1;
#line 2281
  session_close(s);
#line 2282
  return;
}
}
#line 2284 "session.c"
void session_destroy_all(void (*closefunc)(Session * ) ) 
{ int i ;
  Session *s ;

  {
#line 2288
  i = 0;
#line 2288
  while (i < 10) {
#line 2289
    s = & sessions[i];
#line 2290
    if (s->used) {
#line 2291
      if ((unsigned int )closefunc != (unsigned int )((void *)0)) {
#line 2292
        (*closefunc)(s);
      } else {
#line 2294
        session_close(s);
      }
    }
#line 2288
    i ++;
  }
#line 2297
  return;
}
}
#line 2302 "session.c"
static char buf___0[1024]  ;
#line 2299 "session.c"
static char *session_tty_list(void) 
{ int i ;
  char *cp ;
  Session *s ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 2306
  buf___0[0] = (char )'\000';
#line 2307
  i = 0;
#line 2307
  while (i < 10) {
#line 2308
    s = & sessions[i];
#line 2309
    if (s->used) {
#line 2309
      if (s->ttyfd != -1) {
#line 2311
        if (0) {
#line 2311
          if (0) {
#line 2311
            __s1_len___0 = strlen((char const   *)(s->tty));
#line 2311
            __s2_len___0 = strlen("/dev/");
#line 2311
            if (! ((unsigned int )((void const   *)(s->tty + 1)) - (unsigned int )((void const   *)(s->tty)) == 1U)) {
              goto _L___2;
            } else {
#line 2311
              if (__s1_len___0 >= 4U) {
                _L___2: /* CIL Label */ 
#line 2311
                if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 2311
                  tmp___22 = 1;
                } else {
#line 2311
                  if (__s2_len___0 >= 4U) {
#line 2311
                    tmp___22 = 1;
                  } else {
#line 2311
                    tmp___22 = 0;
                  }
                }
              } else {
#line 2311
                tmp___22 = 0;
              }
            }
#line 2311
            if (tmp___22) {
#line 2311
              tmp___18 = __builtin_strcmp((char const   *)(s->tty), "/dev/");
            } else {
#line 2311
              tmp___21 = __builtin_strcmp((char const   *)(s->tty), "/dev/");
#line 2311
              tmp___18 = tmp___21;
            }
          } else {
#line 2311
            tmp___21 = __builtin_strcmp((char const   *)(s->tty), "/dev/");
#line 2311
            tmp___18 = tmp___21;
          }
#line 2311
          tmp___12 = tmp___18;
        } else {
#line 2311
          tmp___12 = strncmp((char const   *)(s->tty), "/dev/", 5U);
        }
#line 2311
        if (tmp___12 != 0) {
#line 2312
          cp = strrchr((char const   *)(s->tty), '/');
#line 2313
          if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 2313
            cp = s->tty;
          } else {
#line 2313
            cp ++;
          }
        } else {
#line 2315
          cp = s->tty + 5;
        }
#line 2317
        if ((int )buf___0[0] != 0) {
#line 2318
          strlcat(buf___0, ",", sizeof(buf___0));
        }
#line 2319
        strlcat(buf___0, (char const   *)cp, sizeof(buf___0));
      }
    }
#line 2307
    i ++;
  }
#line 2322
  if ((int )buf___0[0] == 0) {
#line 2323
    strlcpy(buf___0, "notty", sizeof(buf___0));
  }
#line 2324
  return (buf___0);
}
}
#line 2327 "session.c"
void session_proctitle(Session *s ) 
{ char *tmp ;

  {
#line 2330
  if ((unsigned int )s->pw == (unsigned int )((void *)0)) {
#line 2331
    error("no user for session %d", s->self);
  } else {
#line 2333
    tmp = session_tty_list();
#line 2333
    setproctitle("%s@%s", (s->pw)->pw_name, tmp);
  }
#line 2334
  return;
}
}
#line 2336 "session.c"
int session_setup_x11fwd(Session *s ) 
{ struct stat st ;
  char display[512] ;
  char auth_display[512] ;
  char hostname[64] ;
  u_int i ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 2344
  if (no_x11_forwarding_flag) {
#line 2345
    packet_send_debug("X11 forwarding disabled in user configuration file.");
#line 2346
    return (0);
  }
#line 2348
  if (! options.x11_forwarding) {
#line 2349
    debug("X11 forwarding disabled in server configuration file.");
#line 2350
    return (0);
  }
#line 2352
  if (! options.xauth_location) {
#line 2354
    packet_send_debug("No xauth program; cannot forward with spoofing.");
#line 2355
    return (0);
  } else {
#line 2352
    tmp = stat((char const   * __restrict  )options.xauth_location, (struct stat * __restrict  )(& st));
#line 2352
    if (tmp == -1) {
#line 2354
      packet_send_debug("No xauth program; cannot forward with spoofing.");
#line 2355
      return (0);
    }
  }
#line 2357
  if (options.use_login) {
#line 2358
    packet_send_debug("X11 forwarding disabled; not compatible with UseLogin=yes.");
#line 2360
    return (0);
  }
#line 2362
  if ((unsigned int )s->display != (unsigned int )((void *)0)) {
#line 2363
    debug("X11 display already set.");
#line 2364
    return (0);
  }
#line 2366
  tmp___0 = x11_create_display_inet(options.x11_display_offset, options.x11_use_localhost,
                                    s->single_connection, & s->display_number, & s->x11_chanids);
#line 2366
  if (tmp___0 == -1) {
#line 2369
    debug("x11_create_display_inet failed.");
#line 2370
    return (0);
  }
#line 2372
  i = 0U;
#line 2372
  while (*(s->x11_chanids + i) != -1) {
#line 2373
    channel_register_cleanup(*(s->x11_chanids + i), & session_close_single_x11, 0);
#line 2372
    i ++;
  }
#line 2378
  tmp___3 = gethostname(hostname, sizeof(hostname));
#line 2378
  if (tmp___3 < 0) {
#line 2379
    tmp___1 = __errno_location();
#line 2379
    tmp___2 = strerror(*tmp___1);
#line 2379
    fatal("gethostname: %.100s", tmp___2);
  }
#line 2385
  if (options.x11_use_localhost) {
#line 2386
    snprintf((char * __restrict  )(display), sizeof(display), (char const   * __restrict  )"localhost:%u.%u",
             s->display_number, s->screen);
#line 2388
    snprintf((char * __restrict  )(auth_display), sizeof(auth_display), (char const   * __restrict  )"unix:%u.%u",
             s->display_number, s->screen);
#line 2390
    s->display = xstrdup((char const   *)(display));
#line 2391
    s->auth_display = xstrdup((char const   *)(auth_display));
  } else {
#line 2407
    snprintf((char * __restrict  )(display), sizeof(display), (char const   * __restrict  )"%.400s:%u.%u",
             hostname, s->display_number, s->screen);
#line 2410
    s->display = xstrdup((char const   *)(display));
#line 2411
    s->auth_display = xstrdup((char const   *)(display));
  }
#line 2414
  return (1);
}
}
#line 2417 "session.c"
static void do_authenticated2(Authctxt *authctxt___0 ) 
{ 

  {
#line 2420
  server_loop2(authctxt___0);
#line 2421
  return;
}
}
#line 2426 "session.c"
static int called___2  =    0;
#line 2423 "session.c"
void do_cleanup(Authctxt *authctxt___0 ) 
{ int tmp ;

  {
#line 2428
  debug("do_cleanup");
#line 2431
  if (is_child) {
#line 2432
    return;
  }
#line 2435
  if (called___2) {
#line 2436
    return;
  }
#line 2437
  called___2 = 1;
#line 2439
  if ((unsigned int )authctxt___0 == (unsigned int )((void *)0)) {
#line 2440
    return;
  }
#line 2460
  auth_sock_cleanup_proc(authctxt___0->pw);
#line 2466
  if (! use_privsep) {
#line 2467
    session_destroy_all(& session_pty_cleanup2);
  } else {
#line 2466
    tmp = mm_is_monitor();
#line 2466
    if (tmp) {
#line 2467
      session_destroy_all(& session_pty_cleanup2);
    }
  }
#line 2468
  return;
}
}
#line 1 "auth-chall.o"
#line 35 "auth-chall.c"
KbdintDevice *devices[1] ;
#line 36 "auth-chall.c"
static KbdintDevice *device  ;
#line 39 "auth-chall.c"
char *get_challenge(Authctxt *authctxt___0 ) 
{ char *challenge ;
  char *name ;
  char *info ;
  char **prompts ;
  u_int i ;
  u_int numprompts ;
  u_int *echo_on ;
  int tmp ;

  {
#line 51
  device = devices[0];
#line 52
  if ((unsigned int )device == (unsigned int )((void *)0)) {
#line 53
    return ((char *)((void *)0));
  }
#line 54
  authctxt___0->kbdintctxt = (*(device->init_ctx))(authctxt___0);
#line 54
  if ((unsigned int )authctxt___0->kbdintctxt == (unsigned int )((void *)0)) {
#line 55
    return ((char *)((void *)0));
  }
#line 56
  tmp = (*(device->query))(authctxt___0->kbdintctxt, & name, & info, & numprompts,
                           & prompts, & echo_on);
#line 56
  if (tmp) {
#line 58
    (*(device->free_ctx))(authctxt___0->kbdintctxt);
#line 59
    authctxt___0->kbdintctxt = (void *)0;
#line 60
    return ((char *)((void *)0));
  }
#line 62
  if (numprompts < 1U) {
#line 63
    fatal("get_challenge: numprompts < 1");
  }
#line 64
  challenge = xstrdup((char const   *)*(prompts + 0));
#line 65
  i = 0U;
#line 65
  while (i < numprompts) {
#line 66
    xfree((void *)*(prompts + i));
#line 65
    i ++;
  }
#line 67
  xfree((void *)prompts);
#line 68
  xfree((void *)name);
#line 69
  xfree((void *)echo_on);
#line 70
  xfree((void *)info);
#line 72
  return (challenge);
}
}
#line 74 "auth-chall.c"
int verify_response(Authctxt *authctxt___0 , char const   *response ) 
{ char *resp[1] ;
  char *name ;
  char *info ;
  char **prompts ;
  u_int i ;
  u_int numprompts ;
  u_int *echo_on ;
  int authenticated ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 79
  authenticated = 0;
#line 81
  if ((unsigned int )device == (unsigned int )((void *)0)) {
#line 82
    return (0);
  }
#line 83
  if ((unsigned int )authctxt___0->kbdintctxt == (unsigned int )((void *)0)) {
#line 84
    return (0);
  }
#line 85
  resp[0] = (char *)response;
#line 86
  tmp = (*(device->respond))(authctxt___0->kbdintctxt, 1U, resp);
#line 86
  switch (tmp) {
  case 0: 
#line 88
  authenticated = 1;
#line 89
  break;
  case 1: 
#line 91
  tmp___0 = (*(device->query))(authctxt___0->kbdintctxt, & name, & info, & numprompts,
                               & prompts, & echo_on);
#line 91
  if (tmp___0 != 0) {
#line 93
    break;
  }
#line 94
  if (numprompts == 0U) {
#line 94
    tmp___1 = (*(device->respond))(authctxt___0->kbdintctxt, 0U, resp);
#line 94
    if (tmp___1 == 0) {
#line 96
      authenticated = 1;
    }
  }
#line 98
  i = 0U;
#line 98
  while (i < numprompts) {
#line 99
    xfree((void *)*(prompts + i));
#line 98
    i ++;
  }
#line 100
  xfree((void *)prompts);
#line 101
  xfree((void *)name);
#line 102
  xfree((void *)echo_on);
#line 103
  xfree((void *)info);
#line 104
  break;
  }
#line 106
  (*(device->free_ctx))(authctxt___0->kbdintctxt);
#line 107
  authctxt___0->kbdintctxt = (void *)0;
#line 108
  return (authenticated);
}
}
#line 110 "auth-chall.c"
void abandon_challenge_response(Authctxt *authctxt___0 ) 
{ 

  {
#line 113
  if ((unsigned int )authctxt___0->kbdintctxt != (unsigned int )((void *)0)) {
#line 114
    (*(device->free_ctx))(authctxt___0->kbdintctxt);
#line 115
    authctxt___0->kbdintctxt = (void *)0;
  }
#line 117
  return;
}
}
#line 1 "auth2-chall.o"
#line 152 "auth.h"
int auth2_challenge(Authctxt *authctxt___0 , char *devs ) ;
#line 40 "auth2-chall.c"
static int auth2_challenge_start(Authctxt *authctxt___0 ) ;
#line 41
static int send_userauth_info_request(Authctxt *authctxt___0 ) ;
#line 42
static void input_userauth_info_response(int type , u_int32_t seq , void *ctxt ) ;
#line 55 "auth2-chall.c"
KbdintDevice *devices[1]  = {      (KbdintDevice *)((void *)0)};
#line 93 "auth2-chall.c"
static KbdintAuthctxt *kbdint_alloc(char const   *devs ) 
{ KbdintAuthctxt *kbdintctxt ;
  Buffer b ;
  int i ;
  void *tmp ;
  u_int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 105
  tmp = xmalloc(sizeof(KbdintAuthctxt ));
#line 105
  kbdintctxt = (KbdintAuthctxt *)tmp;
#line 106
  if (0) {
#line 106
    __s1_len = strlen(devs);
#line 106
    __s2_len = strlen("");
#line 106
    if (! ((unsigned int )((void const   *)(devs + 1)) - (unsigned int )((void const   *)devs) == 1U)) {
      goto _L___0;
    } else {
#line 106
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 106
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 106
          tmp___12 = 1;
        } else {
#line 106
          if (__s2_len >= 4U) {
#line 106
            tmp___12 = 1;
          } else {
#line 106
            tmp___12 = 0;
          }
        }
      } else {
#line 106
        tmp___12 = 0;
      }
    }
#line 106
    if (tmp___12) {
#line 106
      tmp___8 = __builtin_strcmp(devs, "");
    } else {
#line 106
      tmp___11 = __builtin_strcmp(devs, "");
#line 106
      tmp___8 = tmp___11;
    }
  } else {
#line 106
    tmp___11 = __builtin_strcmp(devs, "");
#line 106
    tmp___8 = tmp___11;
  }
#line 106
  if (tmp___8 == 0) {
#line 107
    buffer_init(& b);
#line 108
    i = 0;
#line 108
    while (devices[i]) {
#line 109
      tmp___0 = buffer_len(& b);
#line 109
      if (tmp___0 > 0U) {
#line 110
        buffer_append(& b, (void const   *)",", 1U);
      }
#line 111
      tmp___1 = strlen((devices[i])->name);
#line 111
      buffer_append(& b, (void const   *)(devices[i])->name, tmp___1);
#line 108
      i ++;
    }
#line 114
    buffer_append(& b, (void const   *)"\000", 1U);
#line 115
    tmp___2 = buffer_ptr(& b);
#line 115
    kbdintctxt->devices = xstrdup((char const   *)tmp___2);
#line 116
    buffer_free(& b);
  } else {
#line 118
    kbdintctxt->devices = xstrdup(devs);
  }
#line 120
  debug("kbdint_alloc: devices \'%s\'", kbdintctxt->devices);
#line 121
  kbdintctxt->ctxt = (void *)0;
#line 122
  kbdintctxt->device = (KbdintDevice *)((void *)0);
#line 123
  kbdintctxt->nreq = 0U;
#line 125
  return (kbdintctxt);
}
}
#line 127 "auth2-chall.c"
static void kbdint_reset_device(KbdintAuthctxt *kbdintctxt ) 
{ 

  {
#line 130
  if (kbdintctxt->ctxt) {
#line 131
    (*((kbdintctxt->device)->free_ctx))(kbdintctxt->ctxt);
#line 132
    kbdintctxt->ctxt = (void *)0;
  }
#line 134
  kbdintctxt->device = (KbdintDevice *)((void *)0);
#line 135
  return;
}
}
#line 136 "auth2-chall.c"
static void kbdint_free(KbdintAuthctxt *kbdintctxt ) 
{ 

  {
#line 139
  if (kbdintctxt->device) {
#line 140
    kbdint_reset_device(kbdintctxt);
  }
#line 141
  if (kbdintctxt->devices) {
#line 142
    xfree((void *)kbdintctxt->devices);
#line 143
    kbdintctxt->devices = (char *)((void *)0);
  }
#line 145
  xfree((void *)kbdintctxt);
#line 146
  return;
}
}
#line 148 "auth2-chall.c"
static int kbdint_next_device(KbdintAuthctxt *kbdintctxt ) 
{ size_t len ;
  char *t ;
  int i ;
  unsigned int tmp___64 ;
  int tmp___78 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___84 ;
  int tmp___87 ;
  int tmp___88 ;
  char const   *tmp___92 ;
  int tmp___93 ;

  {
#line 155
  if (kbdintctxt->device) {
#line 156
    kbdint_reset_device(kbdintctxt);
  }
#line 157
  while (1) {
#line 159
    if (kbdintctxt->devices) {
#line 159
      tmp___64 = __builtin_strcspn((char const   *)kbdintctxt->devices, ",");
#line 159
      len = tmp___64;
    } else {
#line 159
      len = 0U;
    }
#line 161
    if (len == 0U) {
#line 162
      break;
    }
#line 163
    i = 0;
#line 163
    while (devices[i]) {
#line 164
      if (0) {
#line 164
        if (0) {
#line 164
          __s1_len___0 = strlen((char const   *)kbdintctxt->devices);
#line 164
          __s2_len___0 = strlen((devices[i])->name);
#line 164
          if (! ((unsigned int )((void const   *)(kbdintctxt->devices + 1)) - (unsigned int )((void const   *)kbdintctxt->devices) == 1U)) {
            goto _L___2;
          } else {
#line 164
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 164
              if (! ((unsigned int )((void const   *)((devices[i])->name + 1)) - (unsigned int )((void const   *)(devices[i])->name) == 1U)) {
#line 164
                tmp___88 = 1;
              } else {
#line 164
                if (__s2_len___0 >= 4U) {
#line 164
                  tmp___88 = 1;
                } else {
#line 164
                  tmp___88 = 0;
                }
              }
            } else {
#line 164
              tmp___88 = 0;
            }
          }
#line 164
          if (tmp___88) {
#line 164
            tmp___84 = __builtin_strcmp((char const   *)kbdintctxt->devices, (devices[i])->name);
          } else {
#line 164
            tmp___87 = __builtin_strcmp((char const   *)kbdintctxt->devices, (devices[i])->name);
#line 164
            tmp___84 = tmp___87;
          }
        } else {
#line 164
          tmp___87 = __builtin_strcmp((char const   *)kbdintctxt->devices, (devices[i])->name);
#line 164
          tmp___84 = tmp___87;
        }
#line 164
        tmp___78 = tmp___84;
      } else {
#line 164
        tmp___78 = strncmp((char const   *)kbdintctxt->devices, (devices[i])->name,
                           len);
      }
#line 164
      if (tmp___78 == 0) {
#line 165
        kbdintctxt->device = devices[i];
      }
#line 163
      i ++;
    }
#line 166
    t = kbdintctxt->devices;
#line 167
    if (*(t + len)) {
#line 167
      kbdintctxt->devices = xstrdup((char const   *)((t + len) + 1));
    } else {
#line 167
      kbdintctxt->devices = (char *)((void *)0);
    }
#line 168
    xfree((void *)t);
#line 169
    if (kbdintctxt->devices) {
#line 169
      tmp___92 = (char const   *)kbdintctxt->devices;
    } else {
#line 169
      tmp___92 = "<empty>";
    }
#line 169
    debug2("kbdint_next_device: devices %s", tmp___92);
#line 157
    if (kbdintctxt->devices) {
#line 157
      if (! (! kbdintctxt->device)) {
#line 157
        break;
      }
    } else {
#line 157
      break;
    }
  }
#line 173
  if (kbdintctxt->device) {
#line 173
    tmp___93 = 1;
  } else {
#line 173
    tmp___93 = 0;
  }
#line 173
  return (tmp___93);
}
}
#line 180 "auth2-chall.c"
int auth2_challenge(Authctxt *authctxt___0 , char *devs ) 
{ char const   *tmp ;
  char const   *tmp___0 ;
  KbdintAuthctxt *tmp___1 ;
  int tmp___2 ;

  {
#line 183
  if (devs) {
#line 183
    tmp = (char const   *)devs;
  } else {
#line 183
    tmp = "<no devs>";
  }
#line 183
  if (authctxt___0->user) {
#line 183
    tmp___0 = (char const   *)authctxt___0->user;
  } else {
#line 183
    tmp___0 = "<nouser>";
  }
#line 183
  debug("auth2_challenge: user=%s devs=%s", tmp___0, tmp);
#line 187
  if ((unsigned int )authctxt___0->user == (unsigned int )((void *)0)) {
#line 188
    return (0);
  } else {
#line 187
    if (! devs) {
#line 188
      return (0);
    }
  }
#line 189
  if ((unsigned int )authctxt___0->kbdintctxt == (unsigned int )((void *)0)) {
#line 190
    tmp___1 = kbdint_alloc((char const   *)devs);
#line 190
    authctxt___0->kbdintctxt = (void *)tmp___1;
  }
#line 191
  tmp___2 = auth2_challenge_start(authctxt___0);
#line 191
  return (tmp___2);
}
}
#line 195 "auth2-chall.c"
void auth2_challenge_stop(Authctxt *authctxt___0 ) 
{ 

  {
#line 199
  dispatch_set(61, (dispatch_fn *)((void *)0));
#line 200
  if ((unsigned int )authctxt___0->kbdintctxt != (unsigned int )((void *)0)) {
#line 201
    kbdint_free((KbdintAuthctxt *)authctxt___0->kbdintctxt);
#line 202
    authctxt___0->kbdintctxt = (void *)0;
  }
#line 204
  return;
}
}
#line 207 "auth2-chall.c"
static int auth2_challenge_start(Authctxt *authctxt___0 ) 
{ KbdintAuthctxt *kbdintctxt ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 210
  kbdintctxt = (KbdintAuthctxt *)authctxt___0->kbdintctxt;
#line 212
  if (kbdintctxt->devices) {
#line 212
    tmp = (char const   *)kbdintctxt->devices;
  } else {
#line 212
    tmp = "<empty>";
  }
#line 212
  debug2("auth2_challenge_start: devices %s", tmp);
#line 215
  tmp___0 = kbdint_next_device(kbdintctxt);
#line 215
  if (tmp___0 == 0) {
#line 216
    auth2_challenge_stop(authctxt___0);
#line 217
    return (0);
  }
#line 219
  debug("auth2_challenge_start: trying authentication method \'%s\'", (kbdintctxt->device)->name);
#line 222
  kbdintctxt->ctxt = (*((kbdintctxt->device)->init_ctx))(authctxt___0);
#line 222
  if ((unsigned int )kbdintctxt->ctxt == (unsigned int )((void *)0)) {
#line 223
    auth2_challenge_stop(authctxt___0);
#line 224
    return (0);
  }
#line 226
  tmp___1 = send_userauth_info_request(authctxt___0);
#line 226
  if (tmp___1 == 0) {
#line 227
    auth2_challenge_stop(authctxt___0);
#line 228
    return (0);
  }
#line 230
  dispatch_set(61, & input_userauth_info_response);
#line 233
  authctxt___0->postponed = 1;
#line 234
  return (0);
}
}
#line 237 "auth2-chall.c"
static int send_userauth_info_request(Authctxt *authctxt___0 ) 
{ KbdintAuthctxt *kbdintctxt ;
  char *name ;
  char *instr ;
  char **prompts ;
  u_int i ;
  u_int *echo_on ;
  int tmp ;

  {
#line 244
  kbdintctxt = (KbdintAuthctxt *)authctxt___0->kbdintctxt;
#line 245
  tmp = (*((kbdintctxt->device)->query))(kbdintctxt->ctxt, & name, & instr, & kbdintctxt->nreq,
                                         & prompts, & echo_on);
#line 245
  if (tmp) {
#line 247
    return (0);
  }
#line 249
  packet_start((unsigned char)60);
#line 250
  packet_put_cstring((char const   *)name);
#line 251
  packet_put_cstring((char const   *)instr);
#line 252
  packet_put_cstring("");
#line 253
  packet_put_int(kbdintctxt->nreq);
#line 254
  i = 0U;
#line 254
  while (i < kbdintctxt->nreq) {
#line 255
    packet_put_cstring((char const   *)*(prompts + i));
#line 256
    packet_put_char((int )*(echo_on + i));
#line 254
    i ++;
  }
#line 258
  packet_send();
#line 259
  packet_write_wait();
#line 261
  i = 0U;
#line 261
  while (i < kbdintctxt->nreq) {
#line 262
    xfree((void *)*(prompts + i));
#line 261
    i ++;
  }
#line 263
  xfree((void *)prompts);
#line 264
  xfree((void *)echo_on);
#line 265
  xfree((void *)name);
#line 266
  xfree((void *)instr);
#line 267
  return (1);
}
}
#line 270 "auth2-chall.c"
static void input_userauth_info_response(int type , u_int32_t seq , void *ctxt ) 
{ Authctxt *authctxt___0 ;
  KbdintAuthctxt *kbdintctxt ;
  int authenticated ;
  int res ;
  int len ;
  u_int i ;
  u_int nresp ;
  char **response ;
  char *method ;
  void *tmp ;
  void *tmp___0 ;
  int _len ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;

  {
#line 273
  authctxt___0 = (Authctxt *)ctxt;
#line 275
  authenticated = 0;
#line 277
  response = (char **)((void *)0);
#line 279
  if ((unsigned int )authctxt___0 == (unsigned int )((void *)0)) {
#line 280
    fatal("input_userauth_info_response: no authctxt");
  }
#line 281
  kbdintctxt = (KbdintAuthctxt *)authctxt___0->kbdintctxt;
#line 282
  if ((unsigned int )kbdintctxt == (unsigned int )((void *)0)) {
#line 283
    fatal("input_userauth_info_response: no kbdintctxt");
  } else {
#line 282
    if ((unsigned int )kbdintctxt->ctxt == (unsigned int )((void *)0)) {
#line 283
      fatal("input_userauth_info_response: no kbdintctxt");
    }
  }
#line 284
  if ((unsigned int )kbdintctxt->device == (unsigned int )((void *)0)) {
#line 285
    fatal("input_userauth_info_response: no device");
  }
#line 287
  authctxt___0->postponed = 0;
#line 288
  nresp = packet_get_int();
#line 289
  if (nresp != kbdintctxt->nreq) {
#line 290
    fatal("input_userauth_info_response: wrong number of replies");
  }
#line 291
  if (nresp > 100U) {
#line 292
    fatal("input_userauth_info_response: too many replies");
  }
#line 293
  if (nresp > 0U) {
#line 294
    tmp = xmalloc(nresp * sizeof(char *));
#line 294
    response = (char **)tmp;
#line 295
    i = 0U;
#line 295
    while (i < nresp) {
#line 296
      tmp___0 = packet_get_string((u_int *)((void *)0));
#line 296
      *(response + i) = (char *)tmp___0;
#line 295
      i ++;
    }
  }
#line 298
  while (1) {
#line 298
    tmp___1 = packet_remaining();
#line 298
    _len = tmp___1;
#line 298
    if (_len > 0) {
#line 298
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2-chall.c",
            298);
#line 298
      packet_disconnect("Packet integrity error.");
    }
#line 298
    break;
  }
#line 300
  res = (*((kbdintctxt->device)->respond))(kbdintctxt->ctxt, nresp, response);
#line 302
  i = 0U;
#line 302
  while (i < nresp) {
#line 303
    tmp___2 = strlen((char const   *)*(response + i));
#line 303
    memset((void *)*(response + i), 'r', tmp___2);
#line 304
    xfree((void *)*(response + i));
#line 302
    i ++;
  }
#line 306
  if (response) {
#line 307
    xfree((void *)response);
  }
#line 309
  switch (res) {
  case 0: 
#line 312
  if (authctxt___0->valid) {
#line 312
    authenticated = 1;
  } else {
#line 312
    authenticated = 0;
  }
#line 313
  break;
  case 1: 
#line 316
  tmp___3 = send_userauth_info_request(authctxt___0);
#line 316
  if (tmp___3 == 1) {
#line 317
    authctxt___0->postponed = 1;
  }
#line 318
  break;
  default: ;
#line 321
  break;
  }
#line 324
  tmp___4 = strlen("keyboard-interactive");
#line 324
  tmp___5 = strlen((kbdintctxt->device)->name);
#line 324
  len = (int )((tmp___4 + 2U) + tmp___5);
#line 326
  tmp___6 = xmalloc((unsigned int )len);
#line 326
  method = (char *)tmp___6;
#line 327
  snprintf((char * __restrict  )method, (unsigned int )len, (char const   * __restrict  )"keyboard-interactive/%s",
           (kbdintctxt->device)->name);
#line 330
  if (! authctxt___0->postponed) {
#line 331
    if (authenticated) {
#line 332
      auth2_challenge_stop(authctxt___0);
    } else {
#line 336
      auth2_challenge_start(authctxt___0);
    }
  }
#line 339
  userauth_finish(authctxt___0, authenticated, method);
#line 340
  xfree((void *)method);
#line 341
  return;
}
}
#line 343 "auth2-chall.c"
void privsep_challenge_enable(void) 
{ 

  {
#line 369
  return;
}
}
#line 1 "groupaccess.o"
#line 103 "/usr/include/grp.h"
extern struct group *getgrgid(__gid_t __gid ) ;
#line 188
extern int getgrouplist(char const   *__user , __gid_t __group , __gid_t *__groups ,
                        int *__ngroups ) ;
#line 33 "groupaccess.c"
static int ngroups  ;
#line 34 "groupaccess.c"
static char **groups_byname  ;
#line 40 "groupaccess.c"
int ga_init(char const   *user , gid_t base ) 
{ gid_t *groups_bygid ;
  int i ;
  int j ;
  struct group *gr ;
  long tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 47
  if (ngroups > 0) {
#line 48
    ga_free();
  }
#line 50
  ngroups = 65536;
#line 52
  tmp___2 = sysconf(3);
#line 52
  if (65536L > tmp___2) {
#line 52
    ngroups = 65536;
  } else {
#line 52
    tmp___1 = sysconf(3);
#line 52
    ngroups = (int )tmp___1;
  }
#line 55
  tmp___3 = xmalloc((unsigned int )ngroups * sizeof(*groups_bygid));
#line 55
  groups_bygid = (gid_t *)tmp___3;
#line 56
  tmp___4 = xmalloc((unsigned int )ngroups * sizeof(*groups_byname));
#line 56
  groups_byname = (char **)tmp___4;
#line 58
  tmp___5 = getgrouplist(user, base, groups_bygid, & ngroups);
#line 58
  if (tmp___5 == -1) {
#line 59
    logit("getgrouplist: groups list too small");
  }
#line 60
  i = 0;
#line 60
  j = 0;
#line 60
  while (i < ngroups) {
#line 61
    gr = getgrgid(*(groups_bygid + i));
#line 61
    if ((unsigned int )gr != (unsigned int )((void *)0)) {
#line 62
      tmp___6 = j;
#line 62
      j ++;
#line 62
      *(groups_byname + tmp___6) = xstrdup((char const   *)gr->gr_name);
    }
#line 60
    i ++;
  }
#line 63
  xfree((void *)groups_bygid);
#line 64
  ngroups = j;
#line 64
  return (ngroups);
}
}
#line 71 "groupaccess.c"
int ga_match(char * const  *groups , int n___0 ) 
{ int i ;
  int j ;
  int tmp ;

  {
#line 76
  i = 0;
#line 76
  while (i < ngroups) {
#line 77
    j = 0;
#line 77
    while (j < n___0) {
#line 78
      tmp = match_pattern((char const   *)*(groups_byname + i), (char const   *)*(groups + j));
#line 78
      if (tmp) {
#line 79
        return (1);
      }
#line 77
      j ++;
    }
#line 76
    i ++;
  }
#line 80
  return (0);
}
}
#line 86 "groupaccess.c"
void ga_free(void) 
{ int i ;

  {
#line 91
  if (ngroups > 0) {
#line 92
    i = 0;
#line 92
    while (i < ngroups) {
#line 93
      xfree((void *)*(groups_byname + i));
#line 92
      i ++;
    }
#line 94
    ngroups = 0;
#line 95
    xfree((void *)groups_byname);
  }
#line 97
  return;
}
}
#line 1 "auth-skey.o"
#line 1 "auth-bsdauth.o"
#line 1 "auth2-hostbased.o"
#line 118 "auth.h"
int hostbased_key_allowed(struct passwd *pw , char const   *cuser , char *chost ,
                          Key *key ) ;
#line 52 "monitor_wrap.h"
int mm_hostbased_key_allowed(struct passwd *pw , char *user , char *host , Key *key ) ;
#line 54
int mm_key_verify(Key *key , u_char *sig , u_int siglen , u_char *data , u_int datalen ) ;
#line 47 "auth2-hostbased.c"
static int userauth_hostbased(Authctxt *authctxt___0 ) 
{ Buffer b ;
  Key *key ;
  char *pkalg ;
  char *cuser ;
  char *chost ;
  char *service ;
  u_char *pkblob ;
  u_char *sig ;
  u_int alen ;
  u_int blen ;
  u_int slen ;
  int pktype ;
  int authenticated ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___6 ;
  int tmp___13 ;
  u_int tmp___14 ;
  void *tmp___15 ;
  u_int tmp___16 ;
  void *tmp___17 ;

  {
#line 51
  key = (Key *)((void *)0);
#line 56
  authenticated = 0;
#line 58
  if (! authctxt___0->valid) {
#line 59
    debug2("userauth_hostbased: disabled because of invalid user");
#line 60
    return (0);
  }
#line 62
  tmp = packet_get_string(& alen);
#line 62
  pkalg = (char *)tmp;
#line 63
  tmp___0 = packet_get_string(& blen);
#line 63
  pkblob = (u_char *)tmp___0;
#line 64
  tmp___1 = packet_get_string((u_int *)((void *)0));
#line 64
  chost = (char *)tmp___1;
#line 65
  tmp___2 = packet_get_string((u_int *)((void *)0));
#line 65
  cuser = (char *)tmp___2;
#line 66
  tmp___3 = packet_get_string(& slen);
#line 66
  sig = (u_char *)tmp___3;
#line 68
  debug("userauth_hostbased: cuser %s chost %s pkalg %s slen %d", cuser, chost, pkalg,
        slen);
#line 77
  pktype = key_type_from_name(pkalg);
#line 78
  if (pktype == 3) {
#line 80
    logit("userauth_hostbased: unsupported public key algorithm: %s", pkalg);
    goto done;
  }
#line 84
  key = key_from_blob((u_char const   *)pkblob, blen);
#line 85
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 86
    error("userauth_hostbased: cannot decode key: %s", pkalg);
    goto done;
  }
#line 89
  if (key->type != pktype) {
#line 90
    error("userauth_hostbased: type mismatch for decoded key (received %d, expected %d)",
          key->type, pktype);
    goto done;
  }
#line 94
  if (datafellows & 65536) {
#line 94
    service = (char *)"ssh-userauth";
  } else {
#line 94
    service = authctxt___0->service;
  }
#line 96
  buffer_init(& b);
#line 97
  buffer_put_string(& b, (void const   *)session_id2, session_id2_len);
#line 99
  buffer_put_char(& b, 50);
#line 100
  buffer_put_cstring(& b, (char const   *)authctxt___0->user);
#line 101
  buffer_put_cstring(& b, (char const   *)service);
#line 102
  buffer_put_cstring(& b, "hostbased");
#line 103
  buffer_put_string(& b, (void const   *)pkalg, alen);
#line 104
  buffer_put_string(& b, (void const   *)pkblob, blen);
#line 105
  buffer_put_cstring(& b, (char const   *)chost);
#line 106
  buffer_put_cstring(& b, (char const   *)cuser);
#line 111
  authenticated = 0;
#line 112
  if (use_privsep) {
#line 112
    tmp___6 = mm_hostbased_key_allowed(authctxt___0->pw, cuser, chost, key);
  } else {
#line 112
    tmp___6 = hostbased_key_allowed(authctxt___0->pw, (char const   *)cuser, chost,
                                    key);
  }
#line 112
  if (tmp___6) {
#line 112
    if (use_privsep) {
#line 112
      tmp___14 = buffer_len(& b);
#line 112
      tmp___15 = buffer_ptr(& b);
#line 112
      tmp___13 = mm_key_verify(key, sig, slen, (u_char *)tmp___15, tmp___14);
    } else {
#line 112
      tmp___16 = buffer_len(& b);
#line 112
      tmp___17 = buffer_ptr(& b);
#line 112
      tmp___13 = key_verify((Key const   *)key, (u_char const   *)sig, slen, (u_char const   *)tmp___17,
                            tmp___16);
    }
#line 112
    if (tmp___13 == 1) {
#line 115
      authenticated = 1;
    }
  }
#line 117
  buffer_free(& b);
  done: 
#line 119
  debug2("userauth_hostbased: authenticated %d", authenticated);
#line 120
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 121
    key_free(key);
  }
#line 122
  xfree((void *)pkalg);
#line 123
  xfree((void *)pkblob);
#line 124
  xfree((void *)cuser);
#line 125
  xfree((void *)chost);
#line 126
  xfree((void *)sig);
#line 127
  return (authenticated);
}
}
#line 131 "auth2-hostbased.c"
int hostbased_key_allowed(struct passwd *pw , char const   *cuser , char *chost ,
                          Key *key ) 
{ char const   *resolvedname ;
  char const   *ipaddr ;
  char const   *lookup ;
  HostStatus host_status ;
  int len ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
#line 139
  resolvedname = get_canonical_hostname(options.use_dns);
#line 140
  ipaddr = get_remote_ipaddr();
#line 142
  debug2("userauth_hostbased: chost %s resolvedname %s ipaddr %s", chost, resolvedname,
         ipaddr);
#line 145
  if (options.hostbased_uses_name_from_packet_only) {
#line 146
    tmp = auth_rhosts2(pw, cuser, (char const   *)chost, (char const   *)chost);
#line 146
    if (tmp == 0) {
#line 147
      return (0);
    }
#line 148
    lookup = (char const   *)chost;
  } else {
#line 150
    tmp___0 = strlen((char const   *)chost);
#line 150
    len = (int )tmp___0;
#line 150
    if (len > 0) {
#line 150
      if ((int )*(chost + (len - 1)) == 46) {
#line 151
        debug2("stripping trailing dot from chost %s", chost);
#line 152
        *(chost + (len - 1)) = (char )'\000';
      }
    }
#line 154
    tmp___1 = strcasecmp(resolvedname, (char const   *)chost);
#line 154
    if (tmp___1 != 0) {
#line 155
      logit("userauth_hostbased mismatch: client sends %s, but we resolve %s to %s",
            chost, ipaddr, resolvedname);
    }
#line 158
    tmp___2 = auth_rhosts2(pw, cuser, resolvedname, ipaddr);
#line 158
    if (tmp___2 == 0) {
#line 159
      return (0);
    }
#line 160
    lookup = resolvedname;
  }
#line 162
  debug2("userauth_hostbased: access allowed by auth_rhosts2");
#line 164
  if (options.ignore_user_known_hosts) {
#line 164
    tmp___3 = (char const   *)((void *)0);
  } else {
#line 164
    tmp___3 = "~/.ssh/known_hosts";
  }
#line 164
  host_status = check_key_in_hostfiles(pw, key, lookup, "/usr/local/etc/ssh_known_hosts",
                                       tmp___3);
#line 169
  if ((int )host_status == 1) {
#line 170
    if (options.ignore_user_known_hosts) {
#line 170
      tmp___4 = (char const   *)((void *)0);
    } else {
#line 170
      tmp___4 = "~/.ssh/known_hosts2";
    }
#line 170
    host_status = check_key_in_hostfiles(pw, key, lookup, "/usr/local/etc/ssh_known_hosts2",
                                         tmp___4);
  }
#line 175
  return ((int )host_status == 0);
}
}
#line 178 "auth2-hostbased.c"
Authmethod method_hostbased  =    {(char *)"hostbased", & userauth_hostbased, & options.hostbased_authentication};
#line 1 "auth2-kbdint.o"
#line 37 "auth2-kbdint.c"
static int userauth_kbdint(Authctxt *authctxt___0 ) 
{ int authenticated ;
  char *lang ;
  char *devs ;
  void *tmp ;
  void *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 40
  authenticated = 0;
#line 43
  tmp = packet_get_string((u_int *)((void *)0));
#line 43
  lang = (char *)tmp;
#line 44
  tmp___0 = packet_get_string((u_int *)((void *)0));
#line 44
  devs = (char *)tmp___0;
#line 45
  while (1) {
#line 45
    tmp___1 = packet_remaining();
#line 45
    _len = tmp___1;
#line 45
    if (_len > 0) {
#line 45
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2-kbdint.c",
            45);
#line 45
      packet_disconnect("Packet integrity error.");
    }
#line 45
    break;
  }
#line 47
  debug("keyboard-interactive devs %s", devs);
#line 49
  if (options.challenge_response_authentication) {
#line 50
    authenticated = auth2_challenge(authctxt___0, devs);
  }
#line 52
  xfree((void *)devs);
#line 53
  xfree((void *)lang);
#line 58
  return (authenticated);
}
}
#line 61 "auth2-kbdint.c"
Authmethod method_kbdint  =    {(char *)"keyboard-interactive", & userauth_kbdint, & options.kbd_interactive_authentication};
#line 1 "auth2-none.o"
#line 218 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64") __attribute__((__nonnull__(2))) ;
#line 145 "auth.h"
void userauth_send_banner(char const   *msg ) ;
#line 148
char *auth2_read_banner(void) ;
#line 48 "monitor_wrap.h"
char *mm_auth2_read_banner(void) ;
#line 42 "auth2-none.c"
static int none_enabled  =    1;
#line 44 "auth2-none.c"
char *auth2_read_banner(void) 
{ struct stat st ;
  char *banner ;
  size_t len ;
  size_t n___0 ;
  int fd ;
  int tmp ;
  void *tmp___0 ;

  {
#line 48
  banner = (char *)((void *)0);
#line 52
  fd = open((char const   *)options.banner, 0);
#line 52
  if (fd == -1) {
#line 53
    return ((char *)((void *)0));
  }
#line 54
  tmp = fstat(fd, & st);
#line 54
  if (tmp == -1) {
#line 55
    close(fd);
#line 56
    return ((char *)((void *)0));
  }
#line 58
  if (st.st_size > 1048576LL) {
#line 59
    close(fd);
#line 60
    return ((char *)((void *)0));
  }
#line 63
  len = (unsigned int )st.st_size;
#line 64
  tmp___0 = xmalloc(len + 1U);
#line 64
  banner = (char *)tmp___0;
#line 65
  n___0 = atomicio(& read, fd, (void *)banner, len);
#line 66
  close(fd);
#line 68
  if (n___0 != len) {
#line 69
    xfree((void *)banner);
#line 70
    return ((char *)((void *)0));
  }
#line 72
  *(banner + n___0) = (char )'\000';
#line 74
  return (banner);
}
}
#line 77 "auth2-none.c"
void userauth_send_banner(char const   *msg ) 
{ 

  {
#line 80
  if (datafellows & 128) {
#line 81
    return;
  }
#line 83
  packet_start((unsigned char)53);
#line 84
  packet_put_cstring(msg);
#line 85
  packet_put_cstring("");
#line 86
  packet_send();
#line 87
  debug("%s: sent", "userauth_send_banner");
#line 88
  return;
}
}
#line 90 "auth2-none.c"
static void userauth_banner(void) 
{ char *banner ;

  {
#line 93
  banner = (char *)((void *)0);
#line 95
  if ((unsigned int )options.banner == (unsigned int )((void *)0)) {
#line 96
    return;
  } else {
#line 95
    if (datafellows & 128) {
#line 96
      return;
    }
  }
#line 98
  if (use_privsep) {
#line 98
    banner = mm_auth2_read_banner();
  } else {
#line 98
    banner = auth2_read_banner();
  }
#line 98
  if ((unsigned int )banner == (unsigned int )((void *)0)) {
    goto done;
  }
#line 100
  userauth_send_banner((char const   *)banner);
  done: 
#line 103
  if (banner) {
#line 104
    xfree((void *)banner);
  }
#line 105
  return;
}
}
#line 107 "auth2-none.c"
static int userauth_none(Authctxt *authctxt___0 ) 
{ int _len ;
  int tmp ;
  int tmp___2 ;

  {
#line 110
  none_enabled = 0;
#line 111
  while (1) {
#line 111
    tmp = packet_remaining();
#line 111
    _len = tmp;
#line 111
    if (_len > 0) {
#line 111
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2-none.c",
            111);
#line 111
      packet_disconnect("Packet integrity error.");
    }
#line 111
    break;
  }
#line 112
  userauth_banner();
#line 117
  if (options.password_authentication) {
#line 118
    if (use_privsep) {
#line 118
      tmp___2 = mm_auth_password(authctxt___0, (char *)"");
    } else {
#line 118
      tmp___2 = auth_password(authctxt___0, "");
    }
#line 118
    return (tmp___2);
  }
#line 119
  return (0);
}
}
#line 122 "auth2-none.c"
Authmethod method_none  =    {(char *)"none", & userauth_none, & none_enabled};
#line 1 "auth2-passwd.o"
#line 38 "auth2-passwd.c"
static int userauth_passwd(Authctxt *authctxt___0 ) 
{ char *password ;
  char *newpass ;
  int authenticated ;
  int change ;
  u_int len ;
  u_int newlen ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int _len ;
  int tmp___2 ;
  int tmp___5 ;

  {
#line 42
  authenticated = 0;
#line 46
  tmp = packet_get_char();
#line 46
  change = (int )tmp;
#line 47
  tmp___0 = packet_get_string(& len);
#line 47
  password = (char *)tmp___0;
#line 48
  if (change) {
#line 50
    tmp___1 = packet_get_string(& newlen);
#line 50
    newpass = (char *)tmp___1;
#line 51
    memset((void *)newpass, 0, newlen);
#line 52
    xfree((void *)newpass);
  }
#line 54
  while (1) {
#line 54
    tmp___2 = packet_remaining();
#line 54
    _len = tmp___2;
#line 54
    if (_len > 0) {
#line 54
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2-passwd.c",
            54);
#line 54
      packet_disconnect("Packet integrity error.");
    }
#line 54
    break;
  }
#line 56
  if (change) {
#line 57
    logit("password change not supported");
  } else {
#line 58
    if (use_privsep) {
#line 58
      tmp___5 = mm_auth_password(authctxt___0, password);
    } else {
#line 58
      tmp___5 = auth_password(authctxt___0, (char const   *)password);
    }
#line 58
    if (tmp___5 == 1) {
#line 59
      authenticated = 1;
    }
  }
#line 64
  memset((void *)password, 0, len);
#line 65
  xfree((void *)password);
#line 66
  return (authenticated);
}
}
#line 69 "auth2-passwd.c"
Authmethod method_passwd  =    {(char *)"password", & userauth_passwd, & options.password_authentication};
#line 1 "auth2-pubkey.o"
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 119 "auth.h"
int user_key_allowed(struct passwd *pw , Key *key ) ;
#line 51 "monitor_wrap.h"
int mm_user_key_allowed(struct passwd *pw , Key *key ) ;
#line 51 "auth2-pubkey.c"
static int userauth_pubkey(Authctxt *authctxt___0 ) 
{ Buffer b ;
  Key *key ;
  char *pkalg ;
  u_char *pkblob ;
  u_char *sig ;
  u_int alen ;
  u_int blen ;
  u_int slen ;
  int have_sig ;
  int pktype ;
  int authenticated ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int _len ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int tmp___9 ;
  int tmp___16 ;
  u_int tmp___17 ;
  void *tmp___18 ;
  u_int tmp___19 ;
  void *tmp___20 ;
  int _len___0 ;
  int tmp___21 ;
  int tmp___24 ;

  {
#line 55
  key = (Key *)((void *)0);
#line 60
  authenticated = 0;
#line 62
  if (! authctxt___0->valid) {
#line 63
    debug2("userauth_pubkey: disabled because of invalid user");
#line 64
    return (0);
  }
#line 66
  tmp = packet_get_char();
#line 66
  have_sig = (int )tmp;
#line 67
  if (datafellows & 32) {
#line 68
    debug2("userauth_pubkey: SSH_BUG_PKAUTH");
#line 70
    tmp___0 = packet_get_string(& blen);
#line 70
    pkblob = (u_char *)tmp___0;
#line 71
    buffer_init(& b);
#line 72
    buffer_append(& b, (void const   *)pkblob, blen);
#line 74
    tmp___1 = buffer_get_string(& b, & alen);
#line 74
    pkalg = (char *)tmp___1;
#line 75
    buffer_free(& b);
  } else {
#line 77
    tmp___2 = packet_get_string(& alen);
#line 77
    pkalg = (char *)tmp___2;
#line 78
    tmp___3 = packet_get_string(& blen);
#line 78
    pkblob = (u_char *)tmp___3;
  }
#line 80
  pktype = key_type_from_name(pkalg);
#line 81
  if (pktype == 3) {
#line 83
    logit("userauth_pubkey: unsupported public key algorithm: %s", pkalg);
    goto done;
  }
#line 87
  key = key_from_blob((u_char const   *)pkblob, blen);
#line 88
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 89
    error("userauth_pubkey: cannot decode key: %s", pkalg);
    goto done;
  }
#line 92
  if (key->type != pktype) {
#line 93
    error("userauth_pubkey: type mismatch for decoded key (received %d, expected %d)",
          key->type, pktype);
    goto done;
  }
#line 97
  if (have_sig) {
#line 98
    tmp___4 = packet_get_string(& slen);
#line 98
    sig = (u_char *)tmp___4;
#line 99
    while (1) {
#line 99
      tmp___5 = packet_remaining();
#line 99
      _len = tmp___5;
#line 99
      if (_len > 0) {
#line 99
        logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2-pubkey.c",
              99);
#line 99
        packet_disconnect("Packet integrity error.");
      }
#line 99
      break;
    }
#line 100
    buffer_init(& b);
#line 101
    if (datafellows & 16) {
#line 102
      buffer_append(& b, (void const   *)session_id2, session_id2_len);
    } else {
#line 104
      buffer_put_string(& b, (void const   *)session_id2, session_id2_len);
    }
#line 107
    buffer_put_char(& b, 50);
#line 108
    buffer_put_cstring(& b, (char const   *)authctxt___0->user);
#line 109
    if (datafellows & 2) {
#line 109
      tmp___6 = "ssh-userauth";
    } else {
#line 109
      tmp___6 = (char const   *)authctxt___0->service;
    }
#line 109
    buffer_put_cstring(& b, tmp___6);
#line 113
    if (datafellows & 32) {
#line 114
      buffer_put_char(& b, have_sig);
    } else {
#line 116
      buffer_put_cstring(& b, "publickey");
#line 117
      buffer_put_char(& b, have_sig);
#line 118
      buffer_put_cstring(& b, (char const   *)pkalg);
    }
#line 120
    buffer_put_string(& b, (void const   *)pkblob, blen);
#line 125
    authenticated = 0;
#line 126
    if (use_privsep) {
#line 126
      tmp___9 = mm_user_key_allowed(authctxt___0->pw, key);
    } else {
#line 126
      tmp___9 = user_key_allowed(authctxt___0->pw, key);
    }
#line 126
    if (tmp___9) {
#line 126
      if (use_privsep) {
#line 126
        tmp___17 = buffer_len(& b);
#line 126
        tmp___18 = buffer_ptr(& b);
#line 126
        tmp___16 = mm_key_verify(key, sig, slen, (u_char *)tmp___18, tmp___17);
      } else {
#line 126
        tmp___19 = buffer_len(& b);
#line 126
        tmp___20 = buffer_ptr(& b);
#line 126
        tmp___16 = key_verify((Key const   *)key, (u_char const   *)sig, slen, (u_char const   *)tmp___20,
                              tmp___19);
      }
#line 126
      if (tmp___16 == 1) {
#line 129
        authenticated = 1;
      }
    }
#line 130
    buffer_free(& b);
#line 131
    xfree((void *)sig);
  } else {
#line 133
    debug("test whether pkalg/pkblob are acceptable");
#line 134
    while (1) {
#line 134
      tmp___21 = packet_remaining();
#line 134
      _len___0 = tmp___21;
#line 134
      if (_len___0 > 0) {
#line 134
        logit("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "auth2-pubkey.c",
              134);
#line 134
        packet_disconnect("Packet integrity error.");
      }
#line 134
      break;
    }
#line 144
    if (use_privsep) {
#line 144
      tmp___24 = mm_user_key_allowed(authctxt___0->pw, key);
    } else {
#line 144
      tmp___24 = user_key_allowed(authctxt___0->pw, key);
    }
#line 144
    if (tmp___24) {
#line 145
      packet_start((unsigned char)60);
#line 146
      packet_put_string((void const   *)pkalg, alen);
#line 147
      packet_put_string((void const   *)pkblob, blen);
#line 148
      packet_send();
#line 149
      packet_write_wait();
#line 150
      authctxt___0->postponed = 1;
    }
  }
#line 153
  if (authenticated != 1) {
#line 154
    auth_clear_options();
  }
  done: 
#line 156
  debug2("userauth_pubkey: authenticated %d pkalg %s", authenticated, pkalg);
#line 157
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 158
    key_free(key);
  }
#line 159
  xfree((void *)pkalg);
#line 160
  xfree((void *)pkblob);
#line 165
  return (authenticated);
}
}
#line 169 "auth2-pubkey.c"
static int user_key_allowed2(struct passwd *pw , Key *key , char *file___0 ) 
{ char line[8192] ;
  int found_key ;
  FILE *f ;
  u_long linenum ;
  struct stat st ;
  Key *found ;
  char *fp ;
  int tmp ;
  int tmp___0 ;
  char *cp ;
  char *key_options ;
  int quoted ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 173
  found_key = 0;
#line 175
  linenum = (u_long )0;
#line 181
  temporarily_use_uid(pw);
#line 183
  debug("trying public key file %s", file___0);
#line 186
  tmp = stat((char const   * __restrict  )file___0, (struct stat * __restrict  )(& st));
#line 186
  if (tmp < 0) {
#line 188
    restore_uid();
#line 189
    return (0);
  }
#line 192
  f = fopen((char const   * __restrict  )file___0, (char const   * __restrict  )"r");
#line 193
  if (! f) {
#line 195
    restore_uid();
#line 196
    return (0);
  }
#line 198
  if (options.strict_modes) {
#line 198
    tmp___0 = secure_filename(f, (char const   *)file___0, pw, line, sizeof(line));
#line 198
    if (tmp___0 != 0) {
#line 200
      fclose(f);
#line 201
      logit("Authentication refused: %s", line);
#line 202
      restore_uid();
#line 203
      return (0);
    }
  }
#line 206
  found_key = 0;
#line 207
  found = key_new(key->type);
#line 209
  while (1) {
#line 209
    tmp___6 = read_keyfile_line(f, (char const   *)file___0, line, sizeof(line), & linenum);
#line 209
    if (! (tmp___6 != -1)) {
#line 209
      break;
    }
#line 210
    key_options = (char *)((void *)0);
#line 213
    cp = line;
#line 213
    while (1) {
#line 213
      if (! ((int )*cp == 32)) {
#line 213
        if (! ((int )*cp == 9)) {
#line 213
          break;
        }
      }
#line 213
      cp ++;
    }
#line 215
    if (! *cp) {
#line 216
      continue;
    } else {
#line 215
      if ((int )*cp == 10) {
#line 216
        continue;
      } else {
#line 215
        if ((int )*cp == 35) {
#line 216
          continue;
        }
      }
    }
#line 218
    tmp___2 = key_read(found, & cp);
#line 218
    if (tmp___2 != 1) {
#line 220
      quoted = 0;
#line 221
      debug2("user_key_allowed: check options: \'%s\'", cp);
#line 222
      key_options = cp;
#line 223
      while (1) {
#line 223
        if (*cp) {
#line 223
          if (! quoted) {
#line 223
            if ((int )*cp != 32) {
#line 223
              if (! ((int )*cp != 9)) {
#line 223
                break;
              }
            } else {
#line 223
              break;
            }
          }
        } else {
#line 223
          break;
        }
#line 224
        if ((int )*cp == 92) {
#line 224
          if ((int )*(cp + 1) == 34) {
#line 225
            cp ++;
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 226
          if ((int )*cp == 34) {
#line 227
            quoted = ! quoted;
          }
        }
#line 223
        cp ++;
      }
#line 230
      while (1) {
#line 230
        if (! ((int )*cp == 32)) {
#line 230
          if (! ((int )*cp == 9)) {
#line 230
            break;
          }
        }
#line 230
        cp ++;
      }
#line 232
      tmp___1 = key_read(found, & cp);
#line 232
      if (tmp___1 != 1) {
#line 233
        debug2("user_key_allowed: advance: \'%s\'", cp);
#line 235
        continue;
      }
    }
#line 238
    tmp___4 = key_equal((Key const   *)found, (Key const   *)key);
#line 238
    if (tmp___4) {
#line 238
      tmp___5 = auth_parse_options(pw, key_options, file___0, linenum);
#line 238
      if (tmp___5 == 1) {
#line 240
        found_key = 1;
#line 241
        debug("matching key found: file %s, line %lu", file___0, linenum);
#line 243
        fp = key_fingerprint((Key const   *)found, 1, 0);
#line 244
        tmp___3 = key_type((Key const   *)found);
#line 244
        verbose("Found matching %s key: %s", tmp___3, fp);
#line 246
        xfree((void *)fp);
#line 247
        break;
      }
    }
  }
#line 250
  restore_uid();
#line 251
  fclose(f);
#line 252
  key_free(found);
#line 253
  if (! found_key) {
#line 254
    debug2("key not found");
  }
#line 255
  return (found_key);
}
}
#line 259 "auth2-pubkey.c"
int user_key_allowed(struct passwd *pw , Key *key ) 
{ int success ;
  char *file___0 ;

  {
#line 265
  file___0 = authorized_keys_file(pw);
#line 266
  success = user_key_allowed2(pw, key, file___0);
#line 267
  xfree((void *)file___0);
#line 268
  if (success) {
#line 269
    return (success);
  }
#line 272
  file___0 = authorized_keys_file2(pw);
#line 273
  success = user_key_allowed2(pw, key, file___0);
#line 274
  xfree((void *)file___0);
#line 275
  return (success);
}
}
#line 278 "auth2-pubkey.c"
Authmethod method_pubkey  =    {(char *)"publickey", & userauth_pubkey, & options.pubkey_authentication};
#line 1 "monitor_mm.o"
#line 77 "/usr/include/sys/mman.h"
extern  __attribute__((__nothrow__)) int munmap(void *__addr , size_t __len ) ;
#line 50 "monitor_mm.h"
void mmtree_RB_INSERT_COLOR(struct mmtree *head , struct mm_share *elm ) ;
#line 50
void mmtree_RB_REMOVE_COLOR(struct mmtree *head , struct mm_share *parent , struct mm_share *elm ) ;
#line 50
struct mm_share *mmtree_RB_REMOVE(struct mmtree *head , struct mm_share *elm ) ;
#line 50
struct mm_share *mmtree_RB_INSERT(struct mmtree *head , struct mm_share *elm ) ;
#line 50
struct mm_share *mmtree_RB_FIND(struct mmtree *head , struct mm_share *elm ) ;
#line 50
struct mm_share *mmtree_RB_NEXT(struct mmtree *head , struct mm_share *elm ) ;
#line 50
struct mm_share *mmtree_RB_MINMAX(struct mmtree *head , int val ) ;
#line 56
struct mm_master *mm_create(struct mm_master *mmalloc , size_t size ) ;
#line 57
void mm_destroy(struct mm_master *mm ) ;
#line 59
void mm_share_sync(struct mm_master **pmm , struct mm_master **pmmalloc ) ;
#line 61
void *mm_malloc(struct mm_master *mm , size_t size ) ;
#line 62
void *mm_xmalloc(struct mm_master *mm , size_t size ) ;
#line 63
void mm_free(struct mm_master *mm , void *address ) ;
#line 65
void mm_memvalid(struct mm_master *mm , void *address , size_t size ) ;
#line 38 "monitor_mm.c"
static int mm_compare(struct mm_share *a , struct mm_share *b ) 
{ long diff ;

  {
#line 41
  diff = (long )((char *)a->address - (char *)b->address);
#line 43
  if (diff == 0L) {
#line 44
    return (0);
  } else {
#line 45
    if (diff < 0L) {
#line 46
      return (-1);
    } else {
#line 48
      return (1);
    }
  }
}
}
#line 51 "monitor_mm.c"
void mmtree_RB_INSERT_COLOR(struct mmtree *head , struct mm_share *elm ) 
{ struct mm_share *parent ;
  struct mm_share *gparent ;
  struct mm_share *tmp ;

  {
#line 51
  while (1) {
#line 51
    parent = elm->next.rbe_parent;
#line 51
    if (parent) {
#line 51
      if (! (parent->next.rbe_color == 1)) {
#line 51
        break;
      }
    } else {
#line 51
      break;
    }
#line 51
    gparent = parent->next.rbe_parent;
#line 51
    if ((unsigned int )parent == (unsigned int )gparent->next.rbe_left) {
#line 51
      tmp = gparent->next.rbe_right;
#line 51
      if (tmp) {
#line 51
        if (tmp->next.rbe_color == 1) {
#line 51
          tmp->next.rbe_color = 0;
#line 51
          while (1) {
#line 51
            parent->next.rbe_color = 0;
#line 51
            gparent->next.rbe_color = 1;
#line 51
            break;
          }
#line 51
          elm = gparent;
#line 51
          continue;
        }
      }
#line 51
      if ((unsigned int )parent->next.rbe_right == (unsigned int )elm) {
#line 51
        while (1) {
#line 51
          tmp = parent->next.rbe_right;
#line 51
          parent->next.rbe_right = tmp->next.rbe_left;
#line 51
          if (parent->next.rbe_right) {
#line 51
            (tmp->next.rbe_left)->next.rbe_parent = parent;
          }
#line 51
          tmp->next.rbe_parent = parent->next.rbe_parent;
#line 51
          if (tmp->next.rbe_parent) {
#line 51
            if ((unsigned int )parent == (unsigned int )(parent->next.rbe_parent)->next.rbe_left) {
#line 51
              (parent->next.rbe_parent)->next.rbe_left = tmp;
            } else {
#line 51
              (parent->next.rbe_parent)->next.rbe_right = tmp;
            }
          } else {
#line 51
            head->rbh_root = tmp;
          }
#line 51
          tmp->next.rbe_left = parent;
#line 51
          parent->next.rbe_parent = tmp;
#line 51
          if (tmp->next.rbe_parent) {

          }
#line 51
          break;
        }
#line 51
        tmp = parent;
#line 51
        parent = elm;
#line 51
        elm = tmp;
      }
#line 51
      while (1) {
#line 51
        parent->next.rbe_color = 0;
#line 51
        gparent->next.rbe_color = 1;
#line 51
        break;
      }
#line 51
      while (1) {
#line 51
        tmp = gparent->next.rbe_left;
#line 51
        gparent->next.rbe_left = tmp->next.rbe_right;
#line 51
        if (gparent->next.rbe_left) {
#line 51
          (tmp->next.rbe_right)->next.rbe_parent = gparent;
        }
#line 51
        tmp->next.rbe_parent = gparent->next.rbe_parent;
#line 51
        if (tmp->next.rbe_parent) {
#line 51
          if ((unsigned int )gparent == (unsigned int )(gparent->next.rbe_parent)->next.rbe_left) {
#line 51
            (gparent->next.rbe_parent)->next.rbe_left = tmp;
          } else {
#line 51
            (gparent->next.rbe_parent)->next.rbe_right = tmp;
          }
        } else {
#line 51
          head->rbh_root = tmp;
        }
#line 51
        tmp->next.rbe_right = gparent;
#line 51
        gparent->next.rbe_parent = tmp;
#line 51
        if (tmp->next.rbe_parent) {

        }
#line 51
        break;
      }
    } else {
#line 51
      tmp = gparent->next.rbe_left;
#line 51
      if (tmp) {
#line 51
        if (tmp->next.rbe_color == 1) {
#line 51
          tmp->next.rbe_color = 0;
#line 51
          while (1) {
#line 51
            parent->next.rbe_color = 0;
#line 51
            gparent->next.rbe_color = 1;
#line 51
            break;
          }
#line 51
          elm = gparent;
#line 51
          continue;
        }
      }
#line 51
      if ((unsigned int )parent->next.rbe_left == (unsigned int )elm) {
#line 51
        while (1) {
#line 51
          tmp = parent->next.rbe_left;
#line 51
          parent->next.rbe_left = tmp->next.rbe_right;
#line 51
          if (parent->next.rbe_left) {
#line 51
            (tmp->next.rbe_right)->next.rbe_parent = parent;
          }
#line 51
          tmp->next.rbe_parent = parent->next.rbe_parent;
#line 51
          if (tmp->next.rbe_parent) {
#line 51
            if ((unsigned int )parent == (unsigned int )(parent->next.rbe_parent)->next.rbe_left) {
#line 51
              (parent->next.rbe_parent)->next.rbe_left = tmp;
            } else {
#line 51
              (parent->next.rbe_parent)->next.rbe_right = tmp;
            }
          } else {
#line 51
            head->rbh_root = tmp;
          }
#line 51
          tmp->next.rbe_right = parent;
#line 51
          parent->next.rbe_parent = tmp;
#line 51
          if (tmp->next.rbe_parent) {

          }
#line 51
          break;
        }
#line 51
        tmp = parent;
#line 51
        parent = elm;
#line 51
        elm = tmp;
      }
#line 51
      while (1) {
#line 51
        parent->next.rbe_color = 0;
#line 51
        gparent->next.rbe_color = 1;
#line 51
        break;
      }
#line 51
      while (1) {
#line 51
        tmp = gparent->next.rbe_right;
#line 51
        gparent->next.rbe_right = tmp->next.rbe_left;
#line 51
        if (gparent->next.rbe_right) {
#line 51
          (tmp->next.rbe_left)->next.rbe_parent = gparent;
        }
#line 51
        tmp->next.rbe_parent = gparent->next.rbe_parent;
#line 51
        if (tmp->next.rbe_parent) {
#line 51
          if ((unsigned int )gparent == (unsigned int )(gparent->next.rbe_parent)->next.rbe_left) {
#line 51
            (gparent->next.rbe_parent)->next.rbe_left = tmp;
          } else {
#line 51
            (gparent->next.rbe_parent)->next.rbe_right = tmp;
          }
        } else {
#line 51
          head->rbh_root = tmp;
        }
#line 51
        tmp->next.rbe_left = gparent;
#line 51
        gparent->next.rbe_parent = tmp;
#line 51
        if (tmp->next.rbe_parent) {

        }
#line 51
        break;
      }
    }
  }
#line 51
  (head->rbh_root)->next.rbe_color = 0;
#line 51
  return;
}
}
#line 51 "monitor_mm.c"
void mmtree_RB_REMOVE_COLOR(struct mmtree *head , struct mm_share *parent , struct mm_share *elm ) 
{ struct mm_share *tmp ;
  struct mm_share *oleft ;
  struct mm_share *oright ;

  {
#line 51
  while (1) {
#line 51
    if ((unsigned int )elm == (unsigned int )((void *)0)) {
      goto _L___5;
    } else {
#line 51
      if (elm->next.rbe_color == 0) {
        _L___5: /* CIL Label */ 
#line 51
        if (! ((unsigned int )elm != (unsigned int )head->rbh_root)) {
#line 51
          break;
        }
      } else {
#line 51
        break;
      }
    }
#line 51
    if ((unsigned int )parent->next.rbe_left == (unsigned int )elm) {
#line 51
      tmp = parent->next.rbe_right;
#line 51
      if (tmp->next.rbe_color == 1) {
#line 51
        while (1) {
#line 51
          tmp->next.rbe_color = 0;
#line 51
          parent->next.rbe_color = 1;
#line 51
          break;
        }
#line 51
        while (1) {
#line 51
          tmp = parent->next.rbe_right;
#line 51
          parent->next.rbe_right = tmp->next.rbe_left;
#line 51
          if (parent->next.rbe_right) {
#line 51
            (tmp->next.rbe_left)->next.rbe_parent = parent;
          }
#line 51
          tmp->next.rbe_parent = parent->next.rbe_parent;
#line 51
          if (tmp->next.rbe_parent) {
#line 51
            if ((unsigned int )parent == (unsigned int )(parent->next.rbe_parent)->next.rbe_left) {
#line 51
              (parent->next.rbe_parent)->next.rbe_left = tmp;
            } else {
#line 51
              (parent->next.rbe_parent)->next.rbe_right = tmp;
            }
          } else {
#line 51
            head->rbh_root = tmp;
          }
#line 51
          tmp->next.rbe_left = parent;
#line 51
          parent->next.rbe_parent = tmp;
#line 51
          if (tmp->next.rbe_parent) {

          }
#line 51
          break;
        }
#line 51
        tmp = parent->next.rbe_right;
      }
#line 51
      if ((unsigned int )tmp->next.rbe_left == (unsigned int )((void *)0)) {
        goto _L___1;
      } else {
#line 51
        if ((tmp->next.rbe_left)->next.rbe_color == 0) {
          _L___1: /* CIL Label */ 
#line 51
          if ((unsigned int )tmp->next.rbe_right == (unsigned int )((void *)0)) {
#line 51
            tmp->next.rbe_color = 1;
#line 51
            elm = parent;
#line 51
            parent = elm->next.rbe_parent;
          } else {
#line 51
            if ((tmp->next.rbe_right)->next.rbe_color == 0) {
#line 51
              tmp->next.rbe_color = 1;
#line 51
              elm = parent;
#line 51
              parent = elm->next.rbe_parent;
            } else {
              goto _L___0;
            }
          }
        } else {
          _L___0: /* CIL Label */ 
#line 51
          if ((unsigned int )tmp->next.rbe_right == (unsigned int )((void *)0)) {
            goto _L;
          } else {
#line 51
            if ((tmp->next.rbe_right)->next.rbe_color == 0) {
              _L: /* CIL Label */ 
#line 51
              oleft = tmp->next.rbe_left;
#line 51
              if (oleft) {
#line 51
                oleft->next.rbe_color = 0;
              }
#line 51
              tmp->next.rbe_color = 1;
#line 51
              while (1) {
#line 51
                oleft = tmp->next.rbe_left;
#line 51
                tmp->next.rbe_left = oleft->next.rbe_right;
#line 51
                if (tmp->next.rbe_left) {
#line 51
                  (oleft->next.rbe_right)->next.rbe_parent = tmp;
                }
#line 51
                oleft->next.rbe_parent = tmp->next.rbe_parent;
#line 51
                if (oleft->next.rbe_parent) {
#line 51
                  if ((unsigned int )tmp == (unsigned int )(tmp->next.rbe_parent)->next.rbe_left) {
#line 51
                    (tmp->next.rbe_parent)->next.rbe_left = oleft;
                  } else {
#line 51
                    (tmp->next.rbe_parent)->next.rbe_right = oleft;
                  }
                } else {
#line 51
                  head->rbh_root = oleft;
                }
#line 51
                oleft->next.rbe_right = tmp;
#line 51
                tmp->next.rbe_parent = oleft;
#line 51
                if (oleft->next.rbe_parent) {

                }
#line 51
                break;
              }
#line 51
              tmp = parent->next.rbe_right;
            }
          }
#line 51
          tmp->next.rbe_color = parent->next.rbe_color;
#line 51
          parent->next.rbe_color = 0;
#line 51
          if (tmp->next.rbe_right) {
#line 51
            (tmp->next.rbe_right)->next.rbe_color = 0;
          }
#line 51
          while (1) {
#line 51
            tmp = parent->next.rbe_right;
#line 51
            parent->next.rbe_right = tmp->next.rbe_left;
#line 51
            if (parent->next.rbe_right) {
#line 51
              (tmp->next.rbe_left)->next.rbe_parent = parent;
            }
#line 51
            tmp->next.rbe_parent = parent->next.rbe_parent;
#line 51
            if (tmp->next.rbe_parent) {
#line 51
              if ((unsigned int )parent == (unsigned int )(parent->next.rbe_parent)->next.rbe_left) {
#line 51
                (parent->next.rbe_parent)->next.rbe_left = tmp;
              } else {
#line 51
                (parent->next.rbe_parent)->next.rbe_right = tmp;
              }
            } else {
#line 51
              head->rbh_root = tmp;
            }
#line 51
            tmp->next.rbe_left = parent;
#line 51
            parent->next.rbe_parent = tmp;
#line 51
            if (tmp->next.rbe_parent) {

            }
#line 51
            break;
          }
#line 51
          elm = head->rbh_root;
#line 51
          break;
        }
      }
    } else {
#line 51
      tmp = parent->next.rbe_left;
#line 51
      if (tmp->next.rbe_color == 1) {
#line 51
        while (1) {
#line 51
          tmp->next.rbe_color = 0;
#line 51
          parent->next.rbe_color = 1;
#line 51
          break;
        }
#line 51
        while (1) {
#line 51
          tmp = parent->next.rbe_left;
#line 51
          parent->next.rbe_left = tmp->next.rbe_right;
#line 51
          if (parent->next.rbe_left) {
#line 51
            (tmp->next.rbe_right)->next.rbe_parent = parent;
          }
#line 51
          tmp->next.rbe_parent = parent->next.rbe_parent;
#line 51
          if (tmp->next.rbe_parent) {
#line 51
            if ((unsigned int )parent == (unsigned int )(parent->next.rbe_parent)->next.rbe_left) {
#line 51
              (parent->next.rbe_parent)->next.rbe_left = tmp;
            } else {
#line 51
              (parent->next.rbe_parent)->next.rbe_right = tmp;
            }
          } else {
#line 51
            head->rbh_root = tmp;
          }
#line 51
          tmp->next.rbe_right = parent;
#line 51
          parent->next.rbe_parent = tmp;
#line 51
          if (tmp->next.rbe_parent) {

          }
#line 51
          break;
        }
#line 51
        tmp = parent->next.rbe_left;
      }
#line 51
      if ((unsigned int )tmp->next.rbe_left == (unsigned int )((void *)0)) {
        goto _L___4;
      } else {
#line 51
        if ((tmp->next.rbe_left)->next.rbe_color == 0) {
          _L___4: /* CIL Label */ 
#line 51
          if ((unsigned int )tmp->next.rbe_right == (unsigned int )((void *)0)) {
#line 51
            tmp->next.rbe_color = 1;
#line 51
            elm = parent;
#line 51
            parent = elm->next.rbe_parent;
          } else {
#line 51
            if ((tmp->next.rbe_right)->next.rbe_color == 0) {
#line 51
              tmp->next.rbe_color = 1;
#line 51
              elm = parent;
#line 51
              parent = elm->next.rbe_parent;
            } else {
              goto _L___3;
            }
          }
        } else {
          _L___3: /* CIL Label */ 
#line 51
          if ((unsigned int )tmp->next.rbe_left == (unsigned int )((void *)0)) {
            goto _L___2;
          } else {
#line 51
            if ((tmp->next.rbe_left)->next.rbe_color == 0) {
              _L___2: /* CIL Label */ 
#line 51
              oright = tmp->next.rbe_right;
#line 51
              if (oright) {
#line 51
                oright->next.rbe_color = 0;
              }
#line 51
              tmp->next.rbe_color = 1;
#line 51
              while (1) {
#line 51
                oright = tmp->next.rbe_right;
#line 51
                tmp->next.rbe_right = oright->next.rbe_left;
#line 51
                if (tmp->next.rbe_right) {
#line 51
                  (oright->next.rbe_left)->next.rbe_parent = tmp;
                }
#line 51
                oright->next.rbe_parent = tmp->next.rbe_parent;
#line 51
                if (oright->next.rbe_parent) {
#line 51
                  if ((unsigned int )tmp == (unsigned int )(tmp->next.rbe_parent)->next.rbe_left) {
#line 51
                    (tmp->next.rbe_parent)->next.rbe_left = oright;
                  } else {
#line 51
                    (tmp->next.rbe_parent)->next.rbe_right = oright;
                  }
                } else {
#line 51
                  head->rbh_root = oright;
                }
#line 51
                oright->next.rbe_left = tmp;
#line 51
                tmp->next.rbe_parent = oright;
#line 51
                if (oright->next.rbe_parent) {

                }
#line 51
                break;
              }
#line 51
              tmp = parent->next.rbe_left;
            }
          }
#line 51
          tmp->next.rbe_color = parent->next.rbe_color;
#line 51
          parent->next.rbe_color = 0;
#line 51
          if (tmp->next.rbe_left) {
#line 51
            (tmp->next.rbe_left)->next.rbe_color = 0;
          }
#line 51
          while (1) {
#line 51
            tmp = parent->next.rbe_left;
#line 51
            parent->next.rbe_left = tmp->next.rbe_right;
#line 51
            if (parent->next.rbe_left) {
#line 51
              (tmp->next.rbe_right)->next.rbe_parent = parent;
            }
#line 51
            tmp->next.rbe_parent = parent->next.rbe_parent;
#line 51
            if (tmp->next.rbe_parent) {
#line 51
              if ((unsigned int )parent == (unsigned int )(parent->next.rbe_parent)->next.rbe_left) {
#line 51
                (parent->next.rbe_parent)->next.rbe_left = tmp;
              } else {
#line 51
                (parent->next.rbe_parent)->next.rbe_right = tmp;
              }
            } else {
#line 51
              head->rbh_root = tmp;
            }
#line 51
            tmp->next.rbe_right = parent;
#line 51
            parent->next.rbe_parent = tmp;
#line 51
            if (tmp->next.rbe_parent) {

            }
#line 51
            break;
          }
#line 51
          elm = head->rbh_root;
#line 51
          break;
        }
      }
    }
  }
#line 51
  if (elm) {
#line 51
    elm->next.rbe_color = 0;
  }
#line 51
  return;
}
}
#line 51 "monitor_mm.c"
struct mm_share *mmtree_RB_REMOVE(struct mmtree *head , struct mm_share *elm ) 
{ struct mm_share *child ;
  struct mm_share *parent ;
  struct mm_share *old ;
  int color ;
  struct mm_share *left ;

  {
#line 51
  old = elm;
#line 51
  if ((unsigned int )elm->next.rbe_left == (unsigned int )((void *)0)) {
#line 51
    child = elm->next.rbe_right;
  } else {
#line 51
    if ((unsigned int )elm->next.rbe_right == (unsigned int )((void *)0)) {
#line 51
      child = elm->next.rbe_left;
    } else {
#line 51
      elm = elm->next.rbe_right;
#line 51
      while (1) {
#line 51
        left = elm->next.rbe_left;
#line 51
        if (! left) {
#line 51
          break;
        }
#line 51
        elm = left;
      }
#line 51
      child = elm->next.rbe_right;
#line 51
      parent = elm->next.rbe_parent;
#line 51
      color = elm->next.rbe_color;
#line 51
      if (child) {
#line 51
        child->next.rbe_parent = parent;
      }
#line 51
      if (parent) {
#line 51
        if ((unsigned int )parent->next.rbe_left == (unsigned int )elm) {
#line 51
          parent->next.rbe_left = child;
        } else {
#line 51
          parent->next.rbe_right = child;
        }
      } else {
#line 51
        head->rbh_root = child;
      }
#line 51
      if ((unsigned int )elm->next.rbe_parent == (unsigned int )old) {
#line 51
        parent = elm;
      }
#line 51
      elm->next = old->next;
#line 51
      if (old->next.rbe_parent) {
#line 51
        if ((unsigned int )(old->next.rbe_parent)->next.rbe_left == (unsigned int )old) {
#line 51
          (old->next.rbe_parent)->next.rbe_left = elm;
        } else {
#line 51
          (old->next.rbe_parent)->next.rbe_right = elm;
        }
      } else {
#line 51
        head->rbh_root = elm;
      }
#line 51
      (old->next.rbe_left)->next.rbe_parent = elm;
#line 51
      if (old->next.rbe_right) {
#line 51
        (old->next.rbe_right)->next.rbe_parent = elm;
      }
#line 51
      if (parent) {
#line 51
        left = parent;
#line 51
        while (1) {
#line 51
          left = left->next.rbe_parent;
#line 51
          if (! left) {
#line 51
            break;
          }
        }
      }
      goto color;
    }
  }
#line 51
  parent = elm->next.rbe_parent;
#line 51
  color = elm->next.rbe_color;
#line 51
  if (child) {
#line 51
    child->next.rbe_parent = parent;
  }
#line 51
  if (parent) {
#line 51
    if ((unsigned int )parent->next.rbe_left == (unsigned int )elm) {
#line 51
      parent->next.rbe_left = child;
    } else {
#line 51
      parent->next.rbe_right = child;
    }
  } else {
#line 51
    head->rbh_root = child;
  }
  color: 
#line 51
  if (color == 0) {
#line 51
    mmtree_RB_REMOVE_COLOR(head, parent, child);
  }
#line 51
  return (old);
}
}
#line 51 "monitor_mm.c"
struct mm_share *mmtree_RB_INSERT(struct mmtree *head , struct mm_share *elm ) 
{ struct mm_share *tmp ;
  struct mm_share *parent ;
  int comp ;

  {
#line 51
  parent = (struct mm_share *)((void *)0);
#line 51
  comp = 0;
#line 51
  tmp = head->rbh_root;
#line 51
  while (tmp) {
#line 51
    parent = tmp;
#line 51
    comp = mm_compare(elm, parent);
#line 51
    if (comp < 0) {
#line 51
      tmp = tmp->next.rbe_left;
    } else {
#line 51
      if (comp > 0) {
#line 51
        tmp = tmp->next.rbe_right;
      } else {
#line 51
        return (tmp);
      }
    }
  }
#line 51
  while (1) {
#line 51
    elm->next.rbe_parent = parent;
#line 51
    elm->next.rbe_right = (struct mm_share *)((void *)0);
#line 51
    elm->next.rbe_left = elm->next.rbe_right;
#line 51
    elm->next.rbe_color = 1;
#line 51
    break;
  }
#line 51
  if ((unsigned int )parent != (unsigned int )((void *)0)) {
#line 51
    if (comp < 0) {
#line 51
      parent->next.rbe_left = elm;
    } else {
#line 51
      parent->next.rbe_right = elm;
    }
  } else {
#line 51
    head->rbh_root = elm;
  }
#line 51
  mmtree_RB_INSERT_COLOR(head, elm);
#line 51
  return ((struct mm_share *)((void *)0));
}
}
#line 51 "monitor_mm.c"
struct mm_share *mmtree_RB_FIND(struct mmtree *head , struct mm_share *elm ) 
{ struct mm_share *tmp ;
  int comp ;

  {
#line 51
  tmp = head->rbh_root;
#line 51
  while (tmp) {
#line 51
    comp = mm_compare(elm, tmp);
#line 51
    if (comp < 0) {
#line 51
      tmp = tmp->next.rbe_left;
    } else {
#line 51
      if (comp > 0) {
#line 51
        tmp = tmp->next.rbe_right;
      } else {
#line 51
        return (tmp);
      }
    }
  }
#line 51
  return ((struct mm_share *)((void *)0));
}
}
#line 51 "monitor_mm.c"
struct mm_share *mmtree_RB_NEXT(struct mmtree *head , struct mm_share *elm ) 
{ 

  {
#line 51
  if (elm->next.rbe_right) {
#line 51
    elm = elm->next.rbe_right;
#line 51
    while (elm->next.rbe_left) {
#line 51
      elm = elm->next.rbe_left;
    }
  } else {
#line 51
    if (elm->next.rbe_parent) {
#line 51
      if ((unsigned int )elm == (unsigned int )(elm->next.rbe_parent)->next.rbe_left) {
#line 51
        elm = elm->next.rbe_parent;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 51
      while (1) {
#line 51
        if (elm->next.rbe_parent) {
#line 51
          if (! ((unsigned int )elm == (unsigned int )(elm->next.rbe_parent)->next.rbe_right)) {
#line 51
            break;
          }
        } else {
#line 51
          break;
        }
#line 51
        elm = elm->next.rbe_parent;
      }
#line 51
      elm = elm->next.rbe_parent;
    }
  }
#line 51
  return (elm);
}
}
#line 51 "monitor_mm.c"
struct mm_share *mmtree_RB_MINMAX(struct mmtree *head , int val ) 
{ struct mm_share *tmp ;
  struct mm_share *parent ;

  {
#line 51
  tmp = head->rbh_root;
#line 51
  parent = (struct mm_share *)((void *)0);
#line 51
  while (tmp) {
#line 51
    parent = tmp;
#line 51
    if (val < 0) {
#line 51
      tmp = tmp->next.rbe_left;
    } else {
#line 51
      tmp = tmp->next.rbe_right;
    }
  }
#line 51
  return (parent);
}
}
#line 53 "monitor_mm.c"
static struct mm_share *mm_make_entry(struct mm_master *mm , struct mmtree *head ,
                                      void *address , size_t size ) 
{ struct mm_share *tmp ;
  struct mm_share *tmp2 ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 59
  if ((unsigned int )mm->mmalloc == (unsigned int )((void *)0)) {
#line 60
    tmp___0 = xmalloc(sizeof(struct mm_share ));
#line 60
    tmp = (struct mm_share *)tmp___0;
  } else {
#line 62
    tmp___1 = mm_xmalloc(mm->mmalloc, sizeof(struct mm_share ));
#line 62
    tmp = (struct mm_share *)tmp___1;
  }
#line 63
  tmp->address = address;
#line 64
  tmp->size = size;
#line 66
  tmp2 = mmtree_RB_INSERT(head, tmp);
#line 67
  if ((unsigned int )tmp2 != (unsigned int )((void *)0)) {
#line 68
    fatal("mm_make_entry(%p): double address %p->%p(%lu)", mm, tmp2, address, (unsigned long )size);
  }
#line 71
  return (tmp);
}
}
#line 76 "monitor_mm.c"
struct mm_master *mm_create(struct mm_master *mmalloc , size_t size ) 
{ void *address ;
  struct mm_master *mm ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
#line 82
  if ((unsigned int )mmalloc == (unsigned int )((void *)0)) {
#line 83
    tmp = xmalloc(sizeof(struct mm_master ));
#line 83
    mm = (struct mm_master *)tmp;
  } else {
#line 85
    tmp___0 = mm_xmalloc(mmalloc, sizeof(struct mm_master ));
#line 85
    mm = (struct mm_master *)tmp___0;
  }
#line 92
  mm->mmalloc = mmalloc;
#line 94
  address = xmmap(size);
#line 95
  if ((unsigned int )address == (unsigned int )((void *)-1)) {
#line 96
    tmp___1 = __errno_location();
#line 96
    tmp___2 = strerror(*tmp___1);
#line 96
    fatal("mmap(%lu): %s", (unsigned long )size, tmp___2);
  }
#line 98
  mm->address = address;
#line 99
  mm->size = size;
#line 101
  while (1) {
#line 101
    mm->rb_free.rbh_root = (struct mm_share *)((void *)0);
#line 101
    break;
  }
#line 102
  while (1) {
#line 102
    mm->rb_allocated.rbh_root = (struct mm_share *)((void *)0);
#line 102
    break;
  }
#line 104
  mm_make_entry(mm, & mm->rb_free, address, size);
#line 106
  return (mm);
}
}
#line 111 "monitor_mm.c"
static void mm_freelist(struct mm_master *mmalloc , struct mmtree *head ) 
{ struct mm_share *mms ;
  struct mm_share *next ;

  {
#line 116
  mms = head->rbh_root;
#line 116
  while (mms) {
#line 117
    next = mmtree_RB_NEXT(head, mms);
#line 118
    mmtree_RB_REMOVE(head, mms);
#line 119
    if ((unsigned int )mmalloc == (unsigned int )((void *)0)) {
#line 120
      xfree((void *)mms);
    } else {
#line 122
      mm_free(mmalloc, (void *)mms);
    }
#line 116
    mms = next;
  }
#line 124
  return;
}
}
#line 128 "monitor_mm.c"
void mm_destroy(struct mm_master *mm ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 131
  mm_freelist(mm->mmalloc, & mm->rb_free);
#line 132
  mm_freelist(mm->mmalloc, & mm->rb_allocated);
#line 135
  tmp___1 = munmap(mm->address, mm->size);
#line 135
  if (tmp___1 == -1) {
#line 136
    tmp = __errno_location();
#line 136
    tmp___0 = strerror(*tmp);
#line 136
    fatal("munmap(%p, %lu): %s", mm->address, (unsigned long )mm->size, tmp___0);
  }
#line 142
  if ((unsigned int )mm->mmalloc == (unsigned int )((void *)0)) {
#line 143
    xfree((void *)mm);
  } else {
#line 145
    mm_free(mm->mmalloc, (void *)mm);
  }
#line 146
  return;
}
}
#line 148 "monitor_mm.c"
void *mm_xmalloc(struct mm_master *mm , size_t size ) 
{ void *address ;

  {
#line 153
  address = mm_malloc(mm, size);
#line 154
  if ((unsigned int )address == (unsigned int )((void *)0)) {
#line 155
    fatal("%s: mm_malloc(%lu)", "mm_xmalloc", (unsigned long )size);
  }
#line 156
  return (address);
}
}
#line 162 "monitor_mm.c"
void *mm_malloc(struct mm_master *mm , size_t size ) 
{ struct mm_share *mms ;
  struct mm_share *tmp ;

  {
#line 167
  if (size == 0U) {
#line 168
    fatal("mm_malloc: try to allocate 0 space");
  }
#line 169
  if ((unsigned long )size > 4294967168UL) {
#line 170
    fatal("mm_malloc: size too big");
  }
#line 172
  size = ((size + 127U) / 128U) * 128U;
#line 174
  mms = mmtree_RB_MINMAX(& mm->rb_free, -1);
#line 174
  while ((unsigned int )mms != (unsigned int )((void *)0)) {
#line 175
    if (mms->size >= size) {
#line 176
      break;
    }
#line 174
    mms = mmtree_RB_NEXT(& mm->rb_free, mms);
  }
#line 179
  if ((unsigned int )mms == (unsigned int )((void *)0)) {
#line 180
    return ((void *)0);
  }
#line 183
  memset(mms->address, 208, size);
#line 185
  tmp = mm_make_entry(mm, & mm->rb_allocated, mms->address, size);
#line 188
  mms->size -= size;
#line 189
  mms->address = (void *)((u_char *)mms->address + size);
#line 191
  if (mms->size == 0U) {
#line 192
    mmtree_RB_REMOVE(& mm->rb_free, mms);
#line 193
    if ((unsigned int )mm->mmalloc == (unsigned int )((void *)0)) {
#line 194
      xfree((void *)mms);
    } else {
#line 196
      mm_free(mm->mmalloc, (void *)mms);
    }
  }
#line 199
  return (tmp->address);
}
}
#line 204 "monitor_mm.c"
void mm_free(struct mm_master *mm , void *address ) 
{ struct mm_share *mms ;
  struct mm_share *prev ;
  struct mm_share tmp ;
  struct mm_share *tmp___0 ;

  {
#line 209
  tmp.address = address;
#line 210
  mms = mmtree_RB_FIND(& mm->rb_allocated, & tmp);
#line 211
  if ((unsigned int )mms == (unsigned int )((void *)0)) {
#line 212
    fatal("mm_free(%p): can not find %p", mm, address);
  }
#line 215
  memset(mms->address, 208, mms->size);
#line 218
  mmtree_RB_REMOVE(& mm->rb_allocated, mms);
#line 219
  tmp___0 = mmtree_RB_INSERT(& mm->rb_free, mms);
#line 219
  if ((unsigned int )tmp___0 != (unsigned int )((void *)0)) {
#line 220
    fatal("mm_free(%p): double address %p", mm, address);
  }
#line 223
  prev = mms;
#line 224
  if (prev->next.rbe_left) {
#line 225
    prev = prev->next.rbe_left;
#line 226
    while (prev->next.rbe_right) {
#line 227
      prev = prev->next.rbe_right;
    }
  } else {
#line 229
    if (prev->next.rbe_parent) {
#line 229
      if ((unsigned int )prev == (unsigned int )(prev->next.rbe_parent)->next.rbe_right) {
#line 231
        prev = prev->next.rbe_parent;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 233
      while (1) {
#line 233
        if (prev->next.rbe_parent) {
#line 233
          if (! ((unsigned int )prev == (unsigned int )(prev->next.rbe_parent)->next.rbe_left)) {
#line 233
            break;
          }
        } else {
#line 233
          break;
        }
#line 235
        prev = prev->next.rbe_parent;
      }
#line 236
      prev = prev->next.rbe_parent;
    }
  }
#line 241
  if ((unsigned int )prev != (unsigned int )((void *)0)) {
#line 241
    if ((unsigned int )((void *)((u_char *)prev->address + prev->size)) > (unsigned int )address) {
#line 242
      fatal("mm_free: memory corruption: %p(%lu) > %p", prev->address, (unsigned long )prev->size,
            address);
    }
  }
#line 246
  if ((unsigned int )prev != (unsigned int )((void *)0)) {
#line 246
    if ((unsigned int )((void *)((u_char *)prev->address + prev->size)) == (unsigned int )address) {
#line 247
      prev->size += mms->size;
#line 248
      mmtree_RB_REMOVE(& mm->rb_free, mms);
#line 249
      if ((unsigned int )mm->mmalloc == (unsigned int )((void *)0)) {
#line 250
        xfree((void *)mms);
      } else {
#line 252
        mm_free(mm->mmalloc, (void *)mms);
      }
    } else {
#line 254
      prev = mms;
    }
  } else {
#line 254
    prev = mms;
  }
#line 256
  if ((unsigned int )prev == (unsigned int )((void *)0)) {
#line 257
    return;
  }
#line 260
  mms = mmtree_RB_NEXT(& mm->rb_free, prev);
#line 261
  if ((unsigned int )mms == (unsigned int )((void *)0)) {
#line 262
    return;
  }
#line 264
  if ((unsigned int )((void *)((u_char *)prev->address + prev->size)) > (unsigned int )mms->address) {
#line 265
    fatal("mm_free: memory corruption: %p < %p(%lu)", mms->address, prev->address,
          (unsigned long )prev->size);
  }
#line 267
  if ((unsigned int )((void *)((u_char *)prev->address + prev->size)) != (unsigned int )mms->address) {
#line 268
    return;
  }
#line 270
  prev->size += mms->size;
#line 271
  mmtree_RB_REMOVE(& mm->rb_free, mms);
#line 273
  if ((unsigned int )mm->mmalloc == (unsigned int )((void *)0)) {
#line 274
    xfree((void *)mms);
  } else {
#line 276
    mm_free(mm->mmalloc, (void *)mms);
  }
#line 277
  return;
}
}
#line 279 "monitor_mm.c"
static void mm_sync_list(struct mmtree *oldtree , struct mmtree *newtree , struct mm_master *mm ,
                         struct mm_master *mmold ) 
{ struct mm_master *mmalloc ;
  struct mm_share *mms ;
  struct mm_share *new ;
  void *tmp ;

  {
#line 283
  mmalloc = mm->mmalloc;
#line 287
  mms = mmtree_RB_MINMAX(oldtree, -1);
#line 287
  while ((unsigned int )mms != (unsigned int )((void *)0)) {
#line 289
    mm_memvalid(mmold, (void *)mms, sizeof(struct mm_share ));
#line 290
    mm_memvalid(mm, mms->address, mms->size);
#line 292
    tmp = mm_xmalloc(mmalloc, sizeof(struct mm_share ));
#line 292
    new = (struct mm_share *)tmp;
#line 293
    memcpy((void * __restrict  )new, (void const   * __restrict  )mms, sizeof(struct mm_share ));
#line 294
    mmtree_RB_INSERT(newtree, new);
#line 287
    mms = mmtree_RB_NEXT(oldtree, mms);
  }
#line 296
  return;
}
}
#line 298 "monitor_mm.c"
void mm_share_sync(struct mm_master **pmm , struct mm_master **pmmalloc ) 
{ struct mm_master *mm ;
  struct mm_master *mmalloc ;
  struct mm_master *mmold ;
  struct mmtree rb_free ;
  struct mmtree rb_allocated ;
  void *tmp ;

  {
#line 306
  debug3("%s: Share sync", "mm_share_sync");
#line 308
  mm = *pmm;
#line 309
  mmold = mm->mmalloc;
#line 310
  mm_memvalid(mmold, (void *)mm, sizeof(*mm));
#line 312
  mmalloc = mm_create((struct mm_master *)((void *)0), mm->size);
#line 313
  tmp = mm_xmalloc(mmalloc, sizeof(struct mm_master ));
#line 313
  mm = (struct mm_master *)tmp;
#line 314
  memcpy((void * __restrict  )mm, (void const   * __restrict  )*pmm, sizeof(struct mm_master ));
#line 315
  mm->mmalloc = mmalloc;
#line 317
  rb_free = mm->rb_free;
#line 318
  rb_allocated = mm->rb_allocated;
#line 320
  while (1) {
#line 320
    mm->rb_free.rbh_root = (struct mm_share *)((void *)0);
#line 320
    break;
  }
#line 321
  while (1) {
#line 321
    mm->rb_allocated.rbh_root = (struct mm_share *)((void *)0);
#line 321
    break;
  }
#line 323
  mm_sync_list(& rb_free, & mm->rb_free, mm, mmold);
#line 324
  mm_sync_list(& rb_allocated, & mm->rb_allocated, mm, mmold);
#line 326
  mm_destroy(mmold);
#line 328
  *pmm = mm;
#line 329
  *pmmalloc = mmalloc;
#line 331
  debug3("%s: Share sync end", "mm_share_sync");
#line 332
  return;
}
}
#line 334 "monitor_mm.c"
void mm_memvalid(struct mm_master *mm , void *address , size_t size ) 
{ void *end ;

  {
#line 337
  end = (void *)((u_char *)address + size);
#line 339
  if ((unsigned int )address < (unsigned int )mm->address) {
#line 340
    fatal("mm_memvalid: address too small: %p", address);
  }
#line 341
  if ((unsigned int )end < (unsigned int )address) {
#line 342
    fatal("mm_memvalid: end < address: %p < %p", end, address);
  }
#line 343
  if ((unsigned int )end > (unsigned int )((void *)((u_char *)mm->address + mm->size))) {
#line 344
    fatal("mm_memvalid: address too large: %p", address);
  }
#line 345
  return;
}
}
#line 1 "monitor.o"
#line 85 "monitor.h"
int monitor_read(struct monitor *pmonitor___0 , struct mon_table *ent , struct mon_table **pent ) ;
#line 88
void mm_request_send(int sock , enum monitor_reqtype type , Buffer *m___0 ) ;
#line 89
void mm_request_receive(int sock , Buffer *m___0 ) ;
#line 90
void mm_request_receive_expect(int sock , enum monitor_reqtype type , Buffer *m___0 ) ;
#line 93 "monitor_wrap.h"
struct Newkeys *mm_newkeys_from_blob(u_char *blob , int blen ) ;
#line 97
void mm_get_keystate(struct monitor *pmonitor___0 ) ;
#line 110
void *mm_zalloc(struct mm_master *mm , u_int ncount , u_int size ) ;
#line 111
void mm_zfree(struct mm_master *mm , void *address ) ;
#line 112
void mm_init_compression(struct mm_master *mm ) ;
#line 86 "monitor.c"
struct __anonstruct_child_state_85 child_state  ;
#line 109
int mm_answer_moduli(int sock , Buffer *m___0 ) ;
#line 110
int mm_answer_sign(int sock , Buffer *m___0 ) ;
#line 111
int mm_answer_pwnamallow(int sock , Buffer *m___0 ) ;
#line 112
int mm_answer_auth2_read_banner(int sock , Buffer *m___0 ) ;
#line 113
int mm_answer_authserv(int sock , Buffer *m___0 ) ;
#line 114
int mm_answer_authpassword(int sock , Buffer *m___0 ) ;
#line 119
int mm_answer_keyallowed(int sock , Buffer *m___0 ) ;
#line 120
int mm_answer_keyverify(int sock , Buffer *m___0 ) ;
#line 121
int mm_answer_pty(int sock , Buffer *m___0 ) ;
#line 122
int mm_answer_pty_cleanup(int sock , Buffer *m___0 ) ;
#line 123
int mm_answer_term(int sock , Buffer *req ) ;
#line 124
int mm_answer_rsa_keyallowed(int sock , Buffer *m___0 ) ;
#line 125
int mm_answer_rsa_challenge(int sock , Buffer *m___0 ) ;
#line 126
int mm_answer_rsa_response(int sock , Buffer *m___0 ) ;
#line 127
int mm_answer_sesskey(int sock , Buffer *m___0 ) ;
#line 128
int mm_answer_sessid(int sock , Buffer *m___0 ) ;
#line 151 "monitor.c"
static Authctxt *authctxt  ;
#line 152 "monitor.c"
static BIGNUM *ssh1_challenge  =    (BIGNUM *)((void *)0);
#line 155 "monitor.c"
static u_char *key_blob  =    (u_char *)((void *)0);
#line 156 "monitor.c"
static u_int key_bloblen  =    (u_int )0;
#line 157 "monitor.c"
static int key_blobtype  =    0;
#line 158 "monitor.c"
static char *hostbased_cuser  =    (char *)((void *)0);
#line 159 "monitor.c"
static char *hostbased_chost  =    (char *)((void *)0);
#line 160 "monitor.c"
static char *auth_method  =    (char *)"unknown";
#line 161 "monitor.c"
static u_int session_id2_len___0  =    (u_int )0;
#line 162 "monitor.c"
static u_char *session_id2___0  =    (u_char *)((void *)0);
#line 163 "monitor.c"
static pid_t monitor_child_pid  ;
#line 179 "monitor.c"
struct mon_table mon_dispatch_proto20[9]  = 
#line 179
  {      {0, 16, & mm_answer_moduli}, 
        {4, 16, & mm_answer_sign}, 
        {6, 16, & mm_answer_pwnamallow}, 
        {3, 16, & mm_answer_authserv}, 
        {8, 16, & mm_answer_auth2_read_banner}, 
        {10, 12, & mm_answer_authpassword}, 
        {20, 4, & mm_answer_keyallowed}, 
        {22, 12, & mm_answer_keyverify}, 
        {(enum monitor_reqtype )0, 0, (int (*)(int  , Buffer * ))((void *)0)}};
#line 216 "monitor.c"
struct mon_table mon_dispatch_postauth20[6]  = {      {0, 0, & mm_answer_moduli}, 
        {4, 0, & mm_answer_sign}, 
        {25, 0, & mm_answer_pty}, 
        {27, 0, & mm_answer_pty_cleanup}, 
        {58, 0, & mm_answer_term}, 
        {(enum monitor_reqtype )0, 0, (int (*)(int  , Buffer * ))((void *)0)}};
#line 229 "monitor.c"
struct mon_table mon_dispatch_proto15[9]  = 
#line 229
  {      {6, 16, & mm_answer_pwnamallow}, 
        {28, 16, & mm_answer_sesskey}, 
        {30, 16, & mm_answer_sessid}, 
        {10, 12, & mm_answer_authpassword}, 
        {31, 4, & mm_answer_rsa_keyallowed}, 
        {20, 4, & mm_answer_keyallowed}, 
        {33, 16, & mm_answer_rsa_challenge}, 
        {35, 24, & mm_answer_rsa_response}, 
        {(enum monitor_reqtype )0, 0, (int (*)(int  , Buffer * ))((void *)0)}};
#line 260 "monitor.c"
struct mon_table mon_dispatch_postauth15[4]  = {      {25, 16, & mm_answer_pty}, 
        {27, 16, & mm_answer_pty_cleanup}, 
        {58, 0, & mm_answer_term}, 
        {(enum monitor_reqtype )0, 0, (int (*)(int  , Buffer * ))((void *)0)}};
#line 271 "monitor.c"
struct mon_table *mon_dispatch  ;
#line 275 "monitor.c"
static void monitor_permit(struct mon_table *ent , enum monitor_reqtype type , int permit ) 
{ int tmp ;

  {
#line 278
  while ((unsigned int )ent->f != (unsigned int )((void *)0)) {
#line 279
    if ((int )ent->type == (int )type) {
#line 280
      ent->flags &= -4097;
#line 281
      if (permit) {
#line 281
        tmp = 4096;
      } else {
#line 281
        tmp = 0;
      }
#line 281
      ent->flags |= tmp;
#line 282
      return;
    }
#line 284
    ent ++;
  }
#line 286
  return;
}
}
#line 288 "monitor.c"
static void monitor_permit_authentications(int permit ) 
{ struct mon_table *ent ;
  int tmp ;

  {
#line 291
  ent = mon_dispatch;
#line 293
  while ((unsigned int )ent->f != (unsigned int )((void *)0)) {
#line 294
    if (ent->flags & 12) {
#line 295
      ent->flags &= -4097;
#line 296
      if (permit) {
#line 296
        tmp = 4096;
      } else {
#line 296
        tmp = 0;
      }
#line 296
      ent->flags |= tmp;
    }
#line 298
    ent ++;
  }
#line 300
  return;
}
}
#line 302 "monitor.c"
void monitor_child_preauth(struct Authctxt *_authctxt , struct monitor *pmonitor___0 ) 
{ struct mon_table *ent ;
  int authenticated ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 306
  authenticated = 0;
#line 308
  debug3("preauth child monitor started");
#line 310
  authctxt = _authctxt;
#line 311
  memset((void *)authctxt, 0, sizeof(*authctxt));
#line 313
  authctxt->loginmsg = & loginmsg;
#line 315
  if (compat20) {
#line 316
    mon_dispatch = mon_dispatch_proto20;
#line 319
    monitor_permit(mon_dispatch, 0, 1);
#line 320
    monitor_permit(mon_dispatch, 4, 1);
  } else {
#line 322
    mon_dispatch = mon_dispatch_proto15;
#line 324
    monitor_permit(mon_dispatch, 28, 1);
  }
#line 328
  while (! authenticated) {
#line 329
    authenticated = monitor_read(pmonitor___0, mon_dispatch, & ent);
#line 330
    if (authenticated) {
#line 331
      if (! (ent->flags & 8)) {
#line 332
        fatal("%s: unexpected authentication from %d", "monitor_child_preauth", ent->type);
      }
#line 334
      if ((authctxt->pw)->pw_uid == 0U) {
#line 334
        tmp = auth_root_allowed(auth_method);
#line 334
        if (! tmp) {
#line 336
          authenticated = 0;
        }
      }
    }
#line 351
    if (ent->flags & 8) {
#line 352
      if (compat20) {
#line 352
        tmp___0 = " ssh2";
      } else {
#line 352
        tmp___0 = "";
      }
#line 352
      auth_log(authctxt, authenticated, auth_method, (char *)tmp___0);
#line 354
      if (! authenticated) {
#line 355
        (authctxt->failures) ++;
      }
    }
  }
#line 359
  if (! authctxt->valid) {
#line 360
    fatal("%s: authenticated invalid user", "monitor_child_preauth");
  }
#line 362
  debug("%s: %s has been authenticated by privileged process", "monitor_child_preauth",
        authctxt->user);
#line 365
  mm_get_keystate(pmonitor___0);
#line 366
  return;
}
}
#line 368 "monitor.c"
static void monitor_set_child_handler(pid_t pid ) 
{ 

  {
#line 371
  monitor_child_pid = pid;
#line 372
  return;
}
}
#line 374 "monitor.c"
static void monitor_child_handler(int sig ) 
{ 

  {
#line 377
  kill(monitor_child_pid, sig);
#line 378
  return;
}
}
#line 380 "monitor.c"
void monitor_child_postauth(struct monitor *pmonitor___0 ) 
{ 

  {
#line 383
  monitor_set_child_handler(pmonitor___0->m_pid);
#line 384
  mysignal(1, & monitor_child_handler);
#line 385
  mysignal(15, & monitor_child_handler);
#line 387
  if (compat20) {
#line 388
    mon_dispatch = mon_dispatch_postauth20;
#line 391
    monitor_permit(mon_dispatch, 0, 1);
#line 392
    monitor_permit(mon_dispatch, 4, 1);
#line 393
    monitor_permit(mon_dispatch, 58, 1);
  } else {
#line 395
    mon_dispatch = mon_dispatch_postauth15;
#line 396
    monitor_permit(mon_dispatch, 58, 1);
  }
#line 398
  if (! no_pty_flag) {
#line 399
    monitor_permit(mon_dispatch, 25, 1);
#line 400
    monitor_permit(mon_dispatch, 27, 1);
  }
#line 403
  while (1) {
#line 404
    monitor_read(pmonitor___0, mon_dispatch, (struct mon_table **)((void *)0));
  }
}
}
#line 407 "monitor.c"
void monitor_sync(struct monitor *pmonitor___0 ) 
{ 

  {
#line 410
  if (options.compression) {
#line 412
    mm_share_sync(& pmonitor___0->m_zlib, & pmonitor___0->m_zback);
  }
#line 414
  return;
}
}
#line 416 "monitor.c"
int monitor_read(struct monitor *pmonitor___0 , struct mon_table *ent , struct mon_table **pent ) 
{ Buffer m___0 ;
  int ret ;
  u_char type ;
  int tmp ;

  {
#line 424
  buffer_init(& m___0);
#line 426
  mm_request_receive(pmonitor___0->m_sendfd, & m___0);
#line 427
  tmp = buffer_get_char(& m___0);
#line 427
  type = (unsigned char )tmp;
#line 429
  debug3("%s: checking request %d", "monitor_read", type);
#line 431
  while ((unsigned int )ent->f != (unsigned int )((void *)0)) {
#line 432
    if ((int )ent->type == (int )type) {
#line 433
      break;
    }
#line 434
    ent ++;
  }
#line 437
  if ((unsigned int )ent->f != (unsigned int )((void *)0)) {
#line 438
    if (! (ent->flags & 4096)) {
#line 439
      fatal("%s: unpermitted request %d", "monitor_read", type);
    }
#line 441
    ret = (*(ent->f))(pmonitor___0->m_sendfd, & m___0);
#line 442
    buffer_free(& m___0);
#line 445
    if (ent->flags & 16) {
#line 446
      debug2("%s: %d used once, disabling now", "monitor_read", type);
#line 448
      ent->flags &= -4097;
    }
#line 451
    if ((unsigned int )pent != (unsigned int )((void *)0)) {
#line 452
      *pent = ent;
    }
#line 454
    return (ret);
  }
#line 457
  fatal("%s: unsupported request: %d", "monitor_read", type);
#line 460
  return (-1);
}
}
#line 464 "monitor.c"
static int monitor_allowed_key(u_char *blob , u_int bloblen ) 
{ int tmp ;

  {
#line 468
  if ((unsigned int )key_blob == (unsigned int )((void *)0)) {
#line 470
    return (0);
  } else {
#line 468
    if (key_bloblen != bloblen) {
#line 470
      return (0);
    } else {
#line 468
      tmp = memcmp((void const   *)key_blob, (void const   *)blob, key_bloblen);
#line 468
      if (tmp) {
#line 470
        return (0);
      }
    }
  }
#line 471
  return (1);
}
}
#line 474 "monitor.c"
static void monitor_reset_key_state(void) 
{ 

  {
#line 478
  if ((unsigned int )key_blob != (unsigned int )((void *)0)) {
#line 479
    xfree((void *)key_blob);
  }
#line 480
  if ((unsigned int )hostbased_cuser != (unsigned int )((void *)0)) {
#line 481
    xfree((void *)hostbased_cuser);
  }
#line 482
  if ((unsigned int )hostbased_chost != (unsigned int )((void *)0)) {
#line 483
    xfree((void *)hostbased_chost);
  }
#line 484
  key_blob = (u_char *)((void *)0);
#line 485
  key_bloblen = 0U;
#line 486
  key_blobtype = 0;
#line 487
  hostbased_cuser = (char *)((void *)0);
#line 488
  hostbased_chost = (char *)((void *)0);
#line 489
  return;
}
}
#line 491 "monitor.c"
int mm_answer_moduli(int sock , Buffer *m___0 ) 
{ DH *dh ;
  int min ;
  int want ;
  int max ;
  u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;

  {
#line 497
  tmp = buffer_get_int(m___0);
#line 497
  min = (int )tmp;
#line 498
  tmp___0 = buffer_get_int(m___0);
#line 498
  want = (int )tmp___0;
#line 499
  tmp___1 = buffer_get_int(m___0);
#line 499
  max = (int )tmp___1;
#line 501
  debug3("%s: got parameters: %d %d %d", "mm_answer_moduli", min, want, max);
#line 504
  if (max < min) {
#line 505
    fatal("%s: bad parameters: %d %d %d", "mm_answer_moduli", min, want, max);
  } else {
#line 504
    if (want < min) {
#line 505
      fatal("%s: bad parameters: %d %d %d", "mm_answer_moduli", min, want, max);
    } else {
#line 504
      if (max < want) {
#line 505
        fatal("%s: bad parameters: %d %d %d", "mm_answer_moduli", min, want, max);
      }
    }
  }
#line 508
  buffer_clear(m___0);
#line 510
  dh = choose_dh(min, want, max);
#line 511
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 512
    buffer_put_char(m___0, 0);
#line 513
    return (0);
  } else {
#line 516
    buffer_put_char(m___0, 1);
#line 517
    buffer_put_bignum2(m___0, (BIGNUM const   *)dh->p);
#line 518
    buffer_put_bignum2(m___0, (BIGNUM const   *)dh->g);
#line 520
    DH_free(dh);
  }
#line 522
  mm_request_send(sock, 1, m___0);
#line 523
  return (0);
}
}
#line 526 "monitor.c"
int mm_answer_sign(int sock , Buffer *m___0 ) 
{ Key *key ;
  u_char *p ;
  u_char *signature ;
  u_int siglen ;
  u_int datlen ;
  int keyid ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 535
  debug3("%s", "mm_answer_sign");
#line 537
  tmp = buffer_get_int(m___0);
#line 537
  keyid = (int )tmp;
#line 538
  tmp___0 = buffer_get_string(m___0, & datlen);
#line 538
  p = (u_char *)tmp___0;
#line 540
  if (datlen != 20U) {
#line 541
    fatal("%s: data length incorrect: %u", "mm_answer_sign", datlen);
  }
#line 544
  if (session_id2_len___0 == 0U) {
#line 545
    session_id2_len___0 = datlen;
#line 546
    tmp___1 = xmalloc(session_id2_len___0);
#line 546
    session_id2___0 = (u_char *)tmp___1;
#line 547
    memcpy((void * __restrict  )session_id2___0, (void const   * __restrict  )p, session_id2_len___0);
  }
#line 550
  key = get_hostkey_by_index(keyid);
#line 550
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 551
    fatal("%s: no hostkey from index %d", "mm_answer_sign", keyid);
  }
#line 552
  tmp___2 = key_sign((Key const   *)key, & signature, & siglen, (u_char const   *)p,
                     datlen);
#line 552
  if (tmp___2 < 0) {
#line 553
    fatal("%s: key_sign failed", "mm_answer_sign");
  }
#line 555
  debug3("%s: signature %p(%u)", "mm_answer_sign", signature, siglen);
#line 557
  buffer_clear(m___0);
#line 558
  buffer_put_string(m___0, (void const   *)signature, siglen);
#line 560
  xfree((void *)p);
#line 561
  xfree((void *)signature);
#line 563
  mm_request_send(sock, 5, m___0);
#line 566
  monitor_permit(mon_dispatch, 6, 1);
#line 568
  return (0);
}
}
#line 573 "monitor.c"
int mm_answer_pwnamallow(int sock , Buffer *m___0 ) 
{ char *username ;
  struct passwd *pwent ;
  int allowed ;
  int tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 578
  allowed = 0;
#line 580
  debug3("%s", "mm_answer_pwnamallow");
#line 582
  tmp = authctxt->attempt;
#line 582
  (authctxt->attempt) ++;
#line 582
  if (tmp != 0) {
#line 583
    fatal("%s: multiple attempts for getpwnam", "mm_answer_pwnamallow");
  }
#line 585
  tmp___0 = buffer_get_string(m___0, (u_int *)((void *)0));
#line 585
  username = (char *)tmp___0;
#line 587
  pwent = getpwnamallow((char const   *)username);
#line 589
  authctxt->user = xstrdup((char const   *)username);
#line 590
  if (pwent) {
#line 590
    tmp___1 = (char const   *)username;
  } else {
#line 590
    tmp___1 = "unknown";
  }
#line 590
  setproctitle("%s [priv]", tmp___1);
#line 591
  xfree((void *)username);
#line 593
  buffer_clear(m___0);
#line 595
  if ((unsigned int )pwent == (unsigned int )((void *)0)) {
#line 596
    buffer_put_char(m___0, 0);
#line 597
    authctxt->pw = fakepw();
    goto out;
  }
#line 601
  allowed = 1;
#line 602
  authctxt->pw = pwent;
#line 603
  authctxt->valid = 1;
#line 605
  buffer_put_char(m___0, 1);
#line 606
  buffer_put_string(m___0, (void const   *)pwent, sizeof(struct passwd ));
#line 607
  buffer_put_cstring(m___0, (char const   *)pwent->pw_name);
#line 608
  buffer_put_cstring(m___0, "*");
#line 609
  buffer_put_cstring(m___0, (char const   *)pwent->pw_gecos);
#line 613
  buffer_put_cstring(m___0, (char const   *)pwent->pw_dir);
#line 614
  buffer_put_cstring(m___0, (char const   *)pwent->pw_shell);
  out: 
#line 617
  debug3("%s: sending MONITOR_ANS_PWNAM: %d", "mm_answer_pwnamallow", allowed);
#line 618
  mm_request_send(sock, 7, m___0);
#line 621
  if (! compat20) {
#line 622
    monitor_permit_authentications(1);
  } else {
#line 625
    monitor_permit(mon_dispatch, 3, 1);
#line 626
    monitor_permit(mon_dispatch, 8, 1);
  }
#line 637
  return (0);
}
}
#line 640 "monitor.c"
int mm_answer_auth2_read_banner(int sock , Buffer *m___0 ) 
{ char *banner ;
  char const   *tmp ;

  {
#line 644
  buffer_clear(m___0);
#line 645
  banner = auth2_read_banner();
#line 646
  if ((unsigned int )banner != (unsigned int )((void *)0)) {
#line 646
    tmp = (char const   *)banner;
  } else {
#line 646
    tmp = "";
  }
#line 646
  buffer_put_cstring(m___0, tmp);
#line 647
  mm_request_send(sock, 9, m___0);
#line 649
  if ((unsigned int )banner != (unsigned int )((void *)0)) {
#line 650
    xfree((void *)banner);
  }
#line 652
  return (0);
}
}
#line 655 "monitor.c"
int mm_answer_authserv(int sock , Buffer *m___0 ) 
{ void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
#line 658
  monitor_permit_authentications(1);
#line 660
  tmp = buffer_get_string(m___0, (u_int *)((void *)0));
#line 660
  authctxt->service = (char *)tmp;
#line 661
  tmp___0 = buffer_get_string(m___0, (u_int *)((void *)0));
#line 661
  authctxt->style = (char *)tmp___0;
#line 662
  debug3("%s: service=%s, style=%s", "mm_answer_authserv", authctxt->service, authctxt->style);
#line 665
  tmp___1 = strlen((char const   *)authctxt->style);
#line 665
  if (tmp___1 == 0U) {
#line 666
    xfree((void *)authctxt->style);
#line 667
    authctxt->style = (char *)((void *)0);
  }
#line 670
  return (0);
}
}
#line 676 "monitor.c"
static int call_count  ;
#line 673 "monitor.c"
int mm_answer_authpassword(int sock , Buffer *m___0 ) 
{ char *passwd ;
  int authenticated ;
  u_int plen ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
#line 681
  tmp = buffer_get_string(m___0, & plen);
#line 681
  passwd = (char *)tmp;
#line 683
  if (options.password_authentication) {
#line 683
    tmp___0 = auth_password(authctxt, (char const   *)passwd);
#line 683
    if (tmp___0) {
#line 683
      tmp___1 = 1;
    } else {
#line 683
      tmp___1 = 0;
    }
  } else {
#line 683
    tmp___1 = 0;
  }
#line 683
  authenticated = tmp___1;
#line 685
  tmp___2 = strlen((char const   *)passwd);
#line 685
  memset((void *)passwd, 0, tmp___2);
#line 686
  xfree((void *)passwd);
#line 688
  buffer_clear(m___0);
#line 689
  buffer_put_int(m___0, (unsigned int )authenticated);
#line 691
  debug3("%s: sending result %d", "mm_answer_authpassword", authenticated);
#line 692
  mm_request_send(sock, 11, m___0);
#line 694
  call_count ++;
#line 695
  if (plen == 0U) {
#line 695
    if (call_count == 1) {
#line 696
      auth_method = (char *)"none";
    } else {
#line 698
      auth_method = (char *)"password";
    }
  } else {
#line 698
    auth_method = (char *)"password";
  }
#line 701
  return (authenticated);
}
}
#line 942 "monitor.c"
static void mm_append_debug(Buffer *m___0 ) 
{ u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;

  {
#line 945
  if (auth_debug_init) {
#line 945
    tmp___1 = buffer_len(& auth_debug);
#line 945
    if (tmp___1) {
#line 946
      debug3("%s: Appending debug messages for child", "mm_append_debug");
#line 947
      tmp = buffer_len(& auth_debug);
#line 947
      tmp___0 = buffer_ptr(& auth_debug);
#line 947
      buffer_append(m___0, (void const   *)tmp___0, tmp);
#line 949
      buffer_clear(& auth_debug);
    }
  }
#line 951
  return;
}
}
#line 953 "monitor.c"
int mm_answer_keyallowed(int sock , Buffer *m___0 ) 
{ Key *key ;
  char *cuser ;
  char *chost ;
  u_char *blob ;
  u_int bloblen ;
  enum mm_keytype type ;
  int allowed ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;

  {
#line 960
  type = (enum mm_keytype )0;
#line 961
  allowed = 0;
#line 963
  debug3("%s entering", "mm_answer_keyallowed");
#line 965
  tmp = buffer_get_int(m___0);
#line 965
  type = (enum mm_keytype )tmp;
#line 966
  tmp___0 = buffer_get_string(m___0, (u_int *)((void *)0));
#line 966
  cuser = (char *)tmp___0;
#line 967
  tmp___1 = buffer_get_string(m___0, (u_int *)((void *)0));
#line 967
  chost = (char *)tmp___1;
#line 968
  tmp___2 = buffer_get_string(m___0, & bloblen);
#line 968
  blob = (u_char *)tmp___2;
#line 970
  key = key_from_blob((u_char const   *)blob, bloblen);
#line 972
  if (compat20) {
#line 972
    if ((int )type == 3) {
#line 974
      fatal("%s: key type and protocol mismatch", "mm_answer_keyallowed");
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 972
    if (! compat20) {
#line 972
      if ((int )type != 3) {
#line 974
        fatal("%s: key type and protocol mismatch", "mm_answer_keyallowed");
      }
    }
  }
#line 976
  debug3("%s: key_from_blob: %p", "mm_answer_keyallowed", key);
#line 978
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 978
    if (authctxt->valid) {
#line 979
      switch ((int )type) {
      case 2: 
#line 981
      if (options.pubkey_authentication) {
#line 981
        tmp___3 = user_key_allowed(authctxt->pw, key);
#line 981
        if (tmp___3) {
#line 981
          tmp___4 = 1;
        } else {
#line 981
          tmp___4 = 0;
        }
      } else {
#line 981
        tmp___4 = 0;
      }
#line 981
      allowed = tmp___4;
#line 983
      break;
      case 1: 
#line 985
      if (options.hostbased_authentication) {
#line 985
        tmp___5 = hostbased_key_allowed(authctxt->pw, (char const   *)cuser, chost,
                                        key);
#line 985
        if (tmp___5) {
#line 985
          tmp___6 = 1;
        } else {
#line 985
          tmp___6 = 0;
        }
      } else {
#line 985
        tmp___6 = 0;
      }
#line 985
      allowed = tmp___6;
#line 988
      break;
      case 3: 
#line 990
      key->type = 0;
#line 991
      if (options.rhosts_rsa_authentication) {
#line 991
        tmp___7 = auth_rhosts_rsa_key_allowed(authctxt->pw, cuser, chost, key);
#line 991
        if (tmp___7) {
#line 991
          tmp___8 = 1;
        } else {
#line 991
          tmp___8 = 0;
        }
      } else {
#line 991
        tmp___8 = 0;
      }
#line 991
      allowed = tmp___8;
#line 994
      break;
      default: 
#line 996
      fatal("%s: unknown key type %d", "mm_answer_keyallowed", type);
#line 997
      break;
      }
    }
  }
#line 1000
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 1001
    key_free(key);
  }
#line 1004
  monitor_reset_key_state();
#line 1006
  if (allowed) {
#line 1008
    key_blob = blob;
#line 1009
    key_bloblen = bloblen;
#line 1010
    key_blobtype = (int )type;
#line 1011
    hostbased_cuser = cuser;
#line 1012
    hostbased_chost = chost;
  }
#line 1015
  if (allowed) {
#line 1015
    tmp___9 = "allowed";
  } else {
#line 1015
    tmp___9 = "disallowed";
  }
#line 1015
  debug3("%s: key %p is %s", "mm_answer_keyallowed", key, tmp___9);
#line 1018
  buffer_clear(m___0);
#line 1019
  buffer_put_int(m___0, (unsigned int )allowed);
#line 1020
  buffer_put_int(m___0, (unsigned int )((unsigned int )forced_command != (unsigned int )((void *)0)));
#line 1022
  mm_append_debug(m___0);
#line 1024
  mm_request_send(sock, 21, m___0);
#line 1026
  if ((int )type == 3) {
#line 1027
    monitor_permit(mon_dispatch, 33, allowed);
  }
#line 1029
  return (0);
}
}
#line 1032 "monitor.c"
static int monitor_valid_userblob(u_char *data , u_int datalen ) 
{ Buffer b ;
  char *p ;
  u_int len ;
  int fail ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___10 ;
  int tmp___13 ;
  int tmp___14 ;
  u_int l ;
  u_int tmp___15 ;
  int tmp___16 ;
  void *tmp___17 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___23 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  u_int l___0 ;
  u_int tmp___29 ;
  u_int l___1 ;
  u_int tmp___30 ;
  u_int tmp___31 ;

  {
#line 1038
  fail = 0;
#line 1040
  buffer_init(& b);
#line 1041
  buffer_append(& b, (void const   *)data, datalen);
#line 1043
  if (datafellows & 16) {
#line 1044
    tmp = buffer_ptr(& b);
#line 1044
    p = (char *)tmp;
#line 1045
    len = buffer_len(& b);
#line 1046
    if ((unsigned int )session_id2___0 == (unsigned int )((void *)0)) {
#line 1049
      fail ++;
    } else {
#line 1046
      if (len < session_id2_len___0) {
#line 1049
        fail ++;
      } else {
#line 1046
        tmp___0 = memcmp((void const   *)p, (void const   *)session_id2___0, session_id2_len___0);
#line 1046
        if (tmp___0 != 0) {
#line 1049
          fail ++;
        }
      }
    }
#line 1050
    buffer_consume(& b, session_id2_len___0);
  } else {
#line 1052
    tmp___1 = buffer_get_string(& b, & len);
#line 1052
    p = (char *)tmp___1;
#line 1053
    if ((unsigned int )session_id2___0 == (unsigned int )((void *)0)) {
#line 1056
      fail ++;
    } else {
#line 1053
      if (len != session_id2_len___0) {
#line 1056
        fail ++;
      } else {
#line 1053
        tmp___2 = memcmp((void const   *)p, (void const   *)session_id2___0, session_id2_len___0);
#line 1053
        if (tmp___2 != 0) {
#line 1056
          fail ++;
        }
      }
    }
#line 1057
    xfree((void *)p);
  }
#line 1059
  tmp___3 = buffer_get_char(& b);
#line 1059
  if (tmp___3 != 50) {
#line 1060
    fail ++;
  }
#line 1061
  tmp___4 = buffer_get_string(& b, (u_int *)((void *)0));
#line 1061
  p = (char *)tmp___4;
#line 1062
  if (0) {
#line 1062
    __s1_len = strlen((char const   *)authctxt->user);
#line 1062
    __s2_len = strlen((char const   *)p);
#line 1062
    if (! ((unsigned int )((void const   *)(authctxt->user + 1)) - (unsigned int )((void const   *)authctxt->user) == 1U)) {
      goto _L___0;
    } else {
#line 1062
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1062
        if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
#line 1062
          tmp___14 = 1;
        } else {
#line 1062
          if (__s2_len >= 4U) {
#line 1062
            tmp___14 = 1;
          } else {
#line 1062
            tmp___14 = 0;
          }
        }
      } else {
#line 1062
        tmp___14 = 0;
      }
    }
#line 1062
    if (tmp___14) {
#line 1062
      tmp___10 = __builtin_strcmp((char const   *)authctxt->user, (char const   *)p);
    } else {
#line 1062
      tmp___13 = __builtin_strcmp((char const   *)authctxt->user, (char const   *)p);
#line 1062
      tmp___10 = tmp___13;
    }
  } else {
#line 1062
    tmp___13 = __builtin_strcmp((char const   *)authctxt->user, (char const   *)p);
#line 1062
    tmp___10 = tmp___13;
  }
#line 1062
  if (tmp___10 != 0) {
#line 1063
    logit("wrong user name passed to monitor: expected %s != %.100s", authctxt->user,
          p);
#line 1065
    fail ++;
  }
#line 1067
  xfree((void *)p);
#line 1068
  while (1) {
#line 1068
    tmp___15 = buffer_get_int(& b);
#line 1068
    l = tmp___15;
#line 1068
    buffer_consume(& b, l);
#line 1068
    break;
  }
#line 1069
  if (datafellows & 32) {
#line 1070
    tmp___16 = buffer_get_char(& b);
#line 1070
    if (! tmp___16) {
#line 1071
      fail ++;
    }
  } else {
#line 1073
    tmp___17 = buffer_get_string(& b, (u_int *)((void *)0));
#line 1073
    p = (char *)tmp___17;
#line 1074
    if (0) {
#line 1074
      __s1_len___0 = strlen("publickey");
#line 1074
      __s2_len___0 = strlen((char const   *)p);
#line 1074
      if (! ((unsigned int )((void const   *)("publickey" + 1)) - (unsigned int )((void const   *)"publickey") == 1U)) {
        goto _L___2;
      } else {
#line 1074
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 1074
          if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
#line 1074
            tmp___27 = 1;
          } else {
#line 1074
            if (__s2_len___0 >= 4U) {
#line 1074
              tmp___27 = 1;
            } else {
#line 1074
              tmp___27 = 0;
            }
          }
        } else {
#line 1074
          tmp___27 = 0;
        }
      }
#line 1074
      if (tmp___27) {
#line 1074
        tmp___23 = __builtin_strcmp("publickey", (char const   *)p);
      } else {
#line 1074
        tmp___26 = __builtin_strcmp("publickey", (char const   *)p);
#line 1074
        tmp___23 = tmp___26;
      }
    } else {
#line 1074
      tmp___26 = __builtin_strcmp("publickey", (char const   *)p);
#line 1074
      tmp___23 = tmp___26;
    }
#line 1074
    if (tmp___23 != 0) {
#line 1075
      fail ++;
    }
#line 1076
    xfree((void *)p);
#line 1077
    tmp___28 = buffer_get_char(& b);
#line 1077
    if (! tmp___28) {
#line 1078
      fail ++;
    }
#line 1079
    while (1) {
#line 1079
      tmp___29 = buffer_get_int(& b);
#line 1079
      l___0 = tmp___29;
#line 1079
      buffer_consume(& b, l___0);
#line 1079
      break;
    }
  }
#line 1081
  while (1) {
#line 1081
    tmp___30 = buffer_get_int(& b);
#line 1081
    l___1 = tmp___30;
#line 1081
    buffer_consume(& b, l___1);
#line 1081
    break;
  }
#line 1082
  tmp___31 = buffer_len(& b);
#line 1082
  if (tmp___31 != 0U) {
#line 1083
    fail ++;
  }
#line 1084
  buffer_free(& b);
#line 1085
  return (fail == 0);
}
}
#line 1088 "monitor.c"
static int monitor_valid_hostbasedblob(u_char *data , u_int datalen , char *cuser ,
                                       char *chost ) 
{ Buffer b ;
  char *p ;
  u_int len ;
  int fail ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  u_int l ;
  u_int tmp___13 ;
  void *tmp___14 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  u_int l___0 ;
  u_int tmp___25 ;
  u_int l___1 ;
  u_int tmp___26 ;
  void *tmp___27 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___33 ;
  int tmp___36 ;
  int tmp___37 ;
  void *tmp___38 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;
  u_int tmp___49 ;

  {
#line 1095
  fail = 0;
#line 1097
  buffer_init(& b);
#line 1098
  buffer_append(& b, (void const   *)data, datalen);
#line 1100
  tmp = buffer_get_string(& b, & len);
#line 1100
  p = (char *)tmp;
#line 1101
  if ((unsigned int )session_id2___0 == (unsigned int )((void *)0)) {
#line 1104
    fail ++;
  } else {
#line 1101
    if (len != session_id2_len___0) {
#line 1104
      fail ++;
    } else {
#line 1101
      tmp___0 = memcmp((void const   *)p, (void const   *)session_id2___0, session_id2_len___0);
#line 1101
      if (tmp___0 != 0) {
#line 1104
        fail ++;
      }
    }
  }
#line 1105
  xfree((void *)p);
#line 1107
  tmp___1 = buffer_get_char(& b);
#line 1107
  if (tmp___1 != 50) {
#line 1108
    fail ++;
  }
#line 1109
  tmp___2 = buffer_get_string(& b, (u_int *)((void *)0));
#line 1109
  p = (char *)tmp___2;
#line 1110
  if (0) {
#line 1110
    __s1_len = strlen((char const   *)authctxt->user);
#line 1110
    __s2_len = strlen((char const   *)p);
#line 1110
    if (! ((unsigned int )((void const   *)(authctxt->user + 1)) - (unsigned int )((void const   *)authctxt->user) == 1U)) {
      goto _L___0;
    } else {
#line 1110
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1110
        if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
#line 1110
          tmp___12 = 1;
        } else {
#line 1110
          if (__s2_len >= 4U) {
#line 1110
            tmp___12 = 1;
          } else {
#line 1110
            tmp___12 = 0;
          }
        }
      } else {
#line 1110
        tmp___12 = 0;
      }
    }
#line 1110
    if (tmp___12) {
#line 1110
      tmp___8 = __builtin_strcmp((char const   *)authctxt->user, (char const   *)p);
    } else {
#line 1110
      tmp___11 = __builtin_strcmp((char const   *)authctxt->user, (char const   *)p);
#line 1110
      tmp___8 = tmp___11;
    }
  } else {
#line 1110
    tmp___11 = __builtin_strcmp((char const   *)authctxt->user, (char const   *)p);
#line 1110
    tmp___8 = tmp___11;
  }
#line 1110
  if (tmp___8 != 0) {
#line 1111
    logit("wrong user name passed to monitor: expected %s != %.100s", authctxt->user,
          p);
#line 1113
    fail ++;
  }
#line 1115
  xfree((void *)p);
#line 1116
  while (1) {
#line 1116
    tmp___13 = buffer_get_int(& b);
#line 1116
    l = tmp___13;
#line 1116
    buffer_consume(& b, l);
#line 1116
    break;
  }
#line 1117
  tmp___14 = buffer_get_string(& b, (u_int *)((void *)0));
#line 1117
  p = (char *)tmp___14;
#line 1118
  if (0) {
#line 1118
    __s1_len___0 = strlen((char const   *)p);
#line 1118
    __s2_len___0 = strlen("hostbased");
#line 1118
    if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
      goto _L___2;
    } else {
#line 1118
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 1118
        if (! ((unsigned int )((void const   *)("hostbased" + 1)) - (unsigned int )((void const   *)"hostbased") == 1U)) {
#line 1118
          tmp___24 = 1;
        } else {
#line 1118
          if (__s2_len___0 >= 4U) {
#line 1118
            tmp___24 = 1;
          } else {
#line 1118
            tmp___24 = 0;
          }
        }
      } else {
#line 1118
        tmp___24 = 0;
      }
    }
#line 1118
    if (tmp___24) {
#line 1118
      tmp___20 = __builtin_strcmp((char const   *)p, "hostbased");
    } else {
#line 1118
      tmp___23 = __builtin_strcmp((char const   *)p, "hostbased");
#line 1118
      tmp___20 = tmp___23;
    }
  } else {
#line 1118
    tmp___23 = __builtin_strcmp((char const   *)p, "hostbased");
#line 1118
    tmp___20 = tmp___23;
  }
#line 1118
  if (tmp___20 != 0) {
#line 1119
    fail ++;
  }
#line 1120
  xfree((void *)p);
#line 1121
  while (1) {
#line 1121
    tmp___25 = buffer_get_int(& b);
#line 1121
    l___0 = tmp___25;
#line 1121
    buffer_consume(& b, l___0);
#line 1121
    break;
  }
#line 1122
  while (1) {
#line 1122
    tmp___26 = buffer_get_int(& b);
#line 1122
    l___1 = tmp___26;
#line 1122
    buffer_consume(& b, l___1);
#line 1122
    break;
  }
#line 1125
  tmp___27 = buffer_get_string(& b, (u_int *)((void *)0));
#line 1125
  p = (char *)tmp___27;
#line 1126
  len = strlen((char const   *)p);
#line 1126
  if (len > 0U) {
#line 1126
    if ((int )*(p + (len - 1U)) == 46) {
#line 1127
      *(p + (len - 1U)) = (char )'\000';
    }
  }
#line 1128
  if (0) {
#line 1128
    __s1_len___1 = strlen((char const   *)p);
#line 1128
    __s2_len___1 = strlen((char const   *)chost);
#line 1128
    if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
      goto _L___4;
    } else {
#line 1128
      if (__s1_len___1 >= 4U) {
        _L___4: /* CIL Label */ 
#line 1128
        if (! ((unsigned int )((void const   *)(chost + 1)) - (unsigned int )((void const   *)chost) == 1U)) {
#line 1128
          tmp___37 = 1;
        } else {
#line 1128
          if (__s2_len___1 >= 4U) {
#line 1128
            tmp___37 = 1;
          } else {
#line 1128
            tmp___37 = 0;
          }
        }
      } else {
#line 1128
        tmp___37 = 0;
      }
    }
#line 1128
    if (tmp___37) {
#line 1128
      tmp___33 = __builtin_strcmp((char const   *)p, (char const   *)chost);
    } else {
#line 1128
      tmp___36 = __builtin_strcmp((char const   *)p, (char const   *)chost);
#line 1128
      tmp___33 = tmp___36;
    }
  } else {
#line 1128
    tmp___36 = __builtin_strcmp((char const   *)p, (char const   *)chost);
#line 1128
    tmp___33 = tmp___36;
  }
#line 1128
  if (tmp___33 != 0) {
#line 1129
    fail ++;
  }
#line 1130
  xfree((void *)p);
#line 1133
  tmp___38 = buffer_get_string(& b, (u_int *)((void *)0));
#line 1133
  p = (char *)tmp___38;
#line 1134
  if (0) {
#line 1134
    __s1_len___2 = strlen((char const   *)p);
#line 1134
    __s2_len___2 = strlen((char const   *)cuser);
#line 1134
    if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
      goto _L___6;
    } else {
#line 1134
      if (__s1_len___2 >= 4U) {
        _L___6: /* CIL Label */ 
#line 1134
        if (! ((unsigned int )((void const   *)(cuser + 1)) - (unsigned int )((void const   *)cuser) == 1U)) {
#line 1134
          tmp___48 = 1;
        } else {
#line 1134
          if (__s2_len___2 >= 4U) {
#line 1134
            tmp___48 = 1;
          } else {
#line 1134
            tmp___48 = 0;
          }
        }
      } else {
#line 1134
        tmp___48 = 0;
      }
    }
#line 1134
    if (tmp___48) {
#line 1134
      tmp___44 = __builtin_strcmp((char const   *)p, (char const   *)cuser);
    } else {
#line 1134
      tmp___47 = __builtin_strcmp((char const   *)p, (char const   *)cuser);
#line 1134
      tmp___44 = tmp___47;
    }
  } else {
#line 1134
    tmp___47 = __builtin_strcmp((char const   *)p, (char const   *)cuser);
#line 1134
    tmp___44 = tmp___47;
  }
#line 1134
  if (tmp___44 != 0) {
#line 1135
    fail ++;
  }
#line 1136
  xfree((void *)p);
#line 1138
  tmp___49 = buffer_len(& b);
#line 1138
  if (tmp___49 != 0U) {
#line 1139
    fail ++;
  }
#line 1140
  buffer_free(& b);
#line 1141
  return (fail == 0);
}
}
#line 1144 "monitor.c"
int mm_answer_keyverify(int sock , Buffer *m___0 ) 
{ Key *key ;
  u_char *signature ;
  u_char *data ;
  u_char *blob ;
  u_int signaturelen ;
  u_int datalen ;
  u_int bloblen ;
  int verified ;
  int valid_data ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;

  {
#line 1150
  verified = 0;
#line 1151
  valid_data = 0;
#line 1153
  tmp = buffer_get_string(m___0, & bloblen);
#line 1153
  blob = (u_char *)tmp;
#line 1154
  tmp___0 = buffer_get_string(m___0, & signaturelen);
#line 1154
  signature = (u_char *)tmp___0;
#line 1155
  tmp___1 = buffer_get_string(m___0, & datalen);
#line 1155
  data = (u_char *)tmp___1;
#line 1157
  if ((unsigned int )hostbased_cuser == (unsigned int )((void *)0)) {
#line 1159
    fatal("%s: bad key, not previously allowed", "mm_answer_keyverify");
  } else {
#line 1157
    if ((unsigned int )hostbased_chost == (unsigned int )((void *)0)) {
#line 1159
      fatal("%s: bad key, not previously allowed", "mm_answer_keyverify");
    } else {
#line 1157
      tmp___2 = monitor_allowed_key(blob, bloblen);
#line 1157
      if (! tmp___2) {
#line 1159
        fatal("%s: bad key, not previously allowed", "mm_answer_keyverify");
      }
    }
  }
#line 1161
  key = key_from_blob((u_char const   *)blob, bloblen);
#line 1162
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 1163
    fatal("%s: bad public key blob", "mm_answer_keyverify");
  }
#line 1165
  switch (key_blobtype) {
  case 2: 
#line 1167
  valid_data = monitor_valid_userblob(data, datalen);
#line 1168
  break;
  case 1: 
#line 1170
  valid_data = monitor_valid_hostbasedblob(data, datalen, hostbased_cuser, hostbased_chost);
#line 1172
  break;
  default: 
#line 1174
  valid_data = 0;
#line 1175
  break;
  }
#line 1177
  if (! valid_data) {
#line 1178
    fatal("%s: bad signature data blob", "mm_answer_keyverify");
  }
#line 1180
  verified = key_verify((Key const   *)key, (u_char const   *)signature, signaturelen,
                        (u_char const   *)data, datalen);
#line 1181
  if (verified) {
#line 1181
    tmp___3 = "verified";
  } else {
#line 1181
    tmp___3 = "unverified";
  }
#line 1181
  debug3("%s: key %p signature %s", "mm_answer_keyverify", key, tmp___3);
#line 1184
  key_free(key);
#line 1185
  xfree((void *)blob);
#line 1186
  xfree((void *)signature);
#line 1187
  xfree((void *)data);
#line 1189
  if (key_blobtype == 2) {
#line 1189
    auth_method = (char *)"publickey";
  } else {
#line 1189
    auth_method = (char *)"hostbased";
  }
#line 1191
  monitor_reset_key_state();
#line 1193
  buffer_clear(m___0);
#line 1194
  buffer_put_int(m___0, (unsigned int )verified);
#line 1195
  mm_request_send(sock, 23, m___0);
#line 1197
  return (verified);
}
}
#line 1200 "monitor.c"
static void mm_record_login(Session *s , struct passwd *pw ) 
{ socklen_t fromlen ;
  struct sockaddr_storage from ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;

  {
#line 1210
  memset((void *)(& from), 0, sizeof(from));
#line 1211
  fromlen = sizeof(from);
#line 1212
  tmp___3 = packet_connection_is_on_socket();
#line 1212
  if (tmp___3) {
#line 1213
    tmp___1 = packet_get_connection_in();
#line 1213
    tmp___2 = getpeername(tmp___1, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 1213
    if (tmp___2 < 0) {
#line 1215
      tmp = __errno_location();
#line 1215
      tmp___0 = strerror(*tmp);
#line 1215
      debug("getpeername: %.100s", tmp___0);
#line 1216
      cleanup_exit(255);
    }
  }
#line 1220
  tmp___4 = get_remote_name_or_ip(utmp_len, options.use_dns);
#line 1220
  record_login(s->pid, (char const   *)(s->tty), (char const   *)pw->pw_name, pw->pw_uid,
               tmp___4, (struct sockaddr *)(& from), fromlen);
#line 1223
  return;
}
}
#line 1225 "monitor.c"
static void mm_session_close(Session *s ) 
{ 

  {
#line 1228
  debug3("%s: session %d pid %ld", "mm_session_close", s->self, (long )s->pid);
#line 1229
  if (s->ttyfd != -1) {
#line 1230
    debug3("%s: tty %s ptyfd %d", "mm_session_close", s->tty, s->ptyfd);
#line 1231
    session_pty_cleanup2(s);
  }
#line 1233
  s->used = 0;
#line 1234
  return;
}
}
#line 1236 "monitor.c"
int mm_answer_pty(int sock , Buffer *m___0 ) 
{ Session *s ;
  int res ;
  int fd0 ;
  int tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 1243
  debug3("%s entering", "mm_answer_pty");
#line 1245
  buffer_clear(m___0);
#line 1246
  s = session_new();
#line 1247
  if ((unsigned int )s == (unsigned int )((void *)0)) {
    goto error;
  }
#line 1249
  s->authctxt = authctxt;
#line 1250
  s->pw = authctxt->pw;
#line 1251
  s->pid = pmonitor->m_pid;
#line 1252
  res = pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, (int )sizeof(s->tty));
#line 1253
  if (res == 0) {
    goto error;
  }
#line 1255
  pty_setowner(authctxt->pw, (char const   *)(s->tty));
#line 1257
  buffer_put_int(m___0, 1U);
#line 1258
  buffer_put_cstring(m___0, (char const   *)(s->tty));
#line 1261
  tmp = dup2(s->ttyfd, 0);
#line 1261
  if (tmp == -1) {
#line 1262
    fatal("%s: dup2", "mm_answer_pty");
  }
#line 1264
  mm_record_login(s, authctxt->pw);
#line 1267
  close(0);
#line 1270
  tmp___0 = buffer_len(& loginmsg);
#line 1270
  tmp___1 = buffer_ptr(& loginmsg);
#line 1270
  buffer_put_string(m___0, (void const   *)tmp___1, tmp___0);
#line 1271
  buffer_clear(& loginmsg);
#line 1273
  mm_request_send(sock, 26, m___0);
#line 1275
  mm_send_fd(sock, s->ptyfd);
#line 1276
  mm_send_fd(sock, s->ttyfd);
#line 1279
  fd0 = open("/dev/null", 0);
#line 1279
  if (fd0 < 0) {
#line 1280
    tmp___2 = __errno_location();
#line 1280
    tmp___3 = strerror(*tmp___2);
#line 1280
    fatal("%s: open(/dev/null): %s", "mm_answer_pty", tmp___3);
  }
#line 1281
  if (fd0 != 0) {
#line 1282
    error("%s: fd0 %d != 0", "mm_answer_pty", fd0);
  }
#line 1285
  close(s->ttyfd);
#line 1286
  s->ttyfd = s->ptyfd;
#line 1288
  s->ptymaster = s->ptyfd;
#line 1290
  debug3("%s: tty %s ptyfd %d", "mm_answer_pty", s->tty, s->ttyfd);
#line 1292
  return (0);
  error: 
#line 1295
  if ((unsigned int )s != (unsigned int )((void *)0)) {
#line 1296
    mm_session_close(s);
  }
#line 1297
  buffer_put_int(m___0, 0U);
#line 1298
  mm_request_send(sock, 26, m___0);
#line 1299
  return (0);
}
}
#line 1302 "monitor.c"
int mm_answer_pty_cleanup(int sock , Buffer *m___0 ) 
{ Session *s ;
  char *tty ;
  void *tmp ;

  {
#line 1308
  debug3("%s entering", "mm_answer_pty_cleanup");
#line 1310
  tmp = buffer_get_string(m___0, (u_int *)((void *)0));
#line 1310
  tty = (char *)tmp;
#line 1311
  s = session_by_tty(tty);
#line 1311
  if ((unsigned int )s != (unsigned int )((void *)0)) {
#line 1312
    mm_session_close(s);
  }
#line 1313
  buffer_clear(m___0);
#line 1314
  xfree((void *)tty);
#line 1315
  return (0);
}
}
#line 1318 "monitor.c"
int mm_answer_sesskey(int sock , Buffer *m___0 ) 
{ BIGNUM *p ;
  int rsafail ;

  {
#line 1325
  monitor_permit(mon_dispatch, 28, 0);
#line 1327
  p = BN_new();
#line 1327
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 1328
    fatal("%s: BN_new", "mm_answer_sesskey");
  }
#line 1330
  buffer_get_bignum2(m___0, p);
#line 1332
  rsafail = ssh1_session_key(p);
#line 1334
  buffer_clear(m___0);
#line 1335
  buffer_put_int(m___0, (unsigned int )rsafail);
#line 1336
  buffer_put_bignum2(m___0, (BIGNUM const   *)p);
#line 1338
  BN_clear_free(p);
#line 1340
  mm_request_send(sock, 29, m___0);
#line 1343
  monitor_permit(mon_dispatch, 30, 1);
#line 1345
  return (0);
}
}
#line 1348 "monitor.c"
int mm_answer_sessid(int sock , Buffer *m___0 ) 
{ int i ;
  u_int tmp ;
  int tmp___0 ;

  {
#line 1353
  debug3("%s entering", "mm_answer_sessid");
#line 1355
  tmp = buffer_len(m___0);
#line 1355
  if (tmp != 16U) {
#line 1356
    fatal("%s: bad ssh1 session id", "mm_answer_sessid");
  }
#line 1357
  i = 0;
#line 1357
  while (i < 16) {
#line 1358
    tmp___0 = buffer_get_char(m___0);
#line 1358
    session_id[i] = (unsigned char )tmp___0;
#line 1357
    i ++;
  }
#line 1361
  monitor_permit(mon_dispatch, 6, 1);
#line 1363
  return (0);
}
}
#line 1366 "monitor.c"
int mm_answer_rsa_keyallowed(int sock , Buffer *m___0 ) 
{ BIGNUM *client_n ;
  Key *key ;
  u_char *blob ;
  u_int blen ;
  int allowed ;
  int tmp ;

  {
#line 1370
  key = (Key *)((void *)0);
#line 1371
  blob = (u_char *)((void *)0);
#line 1372
  blen = (u_int )0;
#line 1373
  allowed = 0;
#line 1375
  debug3("%s entering", "mm_answer_rsa_keyallowed");
#line 1377
  if (options.rsa_authentication) {
#line 1377
    if (authctxt->valid) {
#line 1378
      client_n = BN_new();
#line 1378
      if ((unsigned int )client_n == (unsigned int )((void *)0)) {
#line 1379
        fatal("%s: BN_new", "mm_answer_rsa_keyallowed");
      }
#line 1380
      buffer_get_bignum2(m___0, client_n);
#line 1381
      allowed = auth_rsa_key_allowed(authctxt->pw, client_n, & key);
#line 1382
      BN_clear_free(client_n);
    }
  }
#line 1384
  buffer_clear(m___0);
#line 1385
  buffer_put_int(m___0, (unsigned int )allowed);
#line 1386
  buffer_put_int(m___0, (unsigned int )((unsigned int )forced_command != (unsigned int )((void *)0)));
#line 1389
  monitor_reset_key_state();
#line 1391
  if (allowed) {
#line 1391
    if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 1392
      key->type = 1;
#line 1393
      tmp = key_to_blob((Key const   *)key, & blob, & blen);
#line 1393
      if (tmp == 0) {
#line 1394
        fatal("%s: key_to_blob failed", "mm_answer_rsa_keyallowed");
      }
#line 1395
      buffer_put_string(m___0, (void const   *)blob, blen);
#line 1398
      key_blob = blob;
#line 1399
      key_bloblen = blen;
#line 1400
      key_blobtype = 4;
    }
  }
#line 1402
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 1403
    key_free(key);
  }
#line 1405
  mm_append_debug(m___0);
#line 1407
  mm_request_send(sock, 32, m___0);
#line 1409
  monitor_permit(mon_dispatch, 33, allowed);
#line 1410
  monitor_permit(mon_dispatch, 35, 0);
#line 1411
  return (0);
}
}
#line 1414 "monitor.c"
int mm_answer_rsa_challenge(int sock , Buffer *m___0 ) 
{ Key *key ;
  u_char *blob ;
  u_int blen ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1417
  key = (Key *)((void *)0);
#line 1421
  debug3("%s entering", "mm_answer_rsa_challenge");
#line 1423
  if (! authctxt->valid) {
#line 1424
    fatal("%s: authctxt not valid", "mm_answer_rsa_challenge");
  }
#line 1425
  tmp = buffer_get_string(m___0, & blen);
#line 1425
  blob = (u_char *)tmp;
#line 1426
  tmp___0 = monitor_allowed_key(blob, blen);
#line 1426
  if (! tmp___0) {
#line 1427
    fatal("%s: bad key, not previously allowed", "mm_answer_rsa_challenge");
  }
#line 1428
  if (key_blobtype != 4) {
#line 1428
    if (key_blobtype != 3) {
#line 1429
      fatal("%s: key type mismatch", "mm_answer_rsa_challenge");
    }
  }
#line 1430
  key = key_from_blob((u_char const   *)blob, blen);
#line 1430
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 1431
    fatal("%s: received bad key", "mm_answer_rsa_challenge");
  }
#line 1433
  if (ssh1_challenge) {
#line 1434
    BN_clear_free(ssh1_challenge);
  }
#line 1435
  ssh1_challenge = auth_rsa_generate_challenge(key);
#line 1437
  buffer_clear(m___0);
#line 1438
  buffer_put_bignum2(m___0, (BIGNUM const   *)ssh1_challenge);
#line 1440
  debug3("%s sending reply", "mm_answer_rsa_challenge");
#line 1441
  mm_request_send(sock, 34, m___0);
#line 1443
  monitor_permit(mon_dispatch, 35, 1);
#line 1445
  xfree((void *)blob);
#line 1446
  key_free(key);
#line 1447
  return (0);
}
}
#line 1450 "monitor.c"
int mm_answer_rsa_response(int sock , Buffer *m___0 ) 
{ Key *key ;
  u_char *blob ;
  u_char *response ;
  u_int blen ;
  u_int len ;
  int success ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 1453
  key = (Key *)((void *)0);
#line 1458
  debug3("%s entering", "mm_answer_rsa_response");
#line 1460
  if (! authctxt->valid) {
#line 1461
    fatal("%s: authctxt not valid", "mm_answer_rsa_response");
  }
#line 1462
  if ((unsigned int )ssh1_challenge == (unsigned int )((void *)0)) {
#line 1463
    fatal("%s: no ssh1_challenge", "mm_answer_rsa_response");
  }
#line 1465
  tmp = buffer_get_string(m___0, & blen);
#line 1465
  blob = (u_char *)tmp;
#line 1466
  tmp___0 = monitor_allowed_key(blob, blen);
#line 1466
  if (! tmp___0) {
#line 1467
    fatal("%s: bad key, not previously allowed", "mm_answer_rsa_response");
  }
#line 1468
  if (key_blobtype != 4) {
#line 1468
    if (key_blobtype != 3) {
#line 1469
      fatal("%s: key type mismatch: %d", "mm_answer_rsa_response", key_blobtype);
    }
  }
#line 1470
  key = key_from_blob((u_char const   *)blob, blen);
#line 1470
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 1471
    fatal("%s: received bad key", "mm_answer_rsa_response");
  }
#line 1472
  tmp___1 = buffer_get_string(m___0, & len);
#line 1472
  response = (u_char *)tmp___1;
#line 1473
  if (len != 16U) {
#line 1474
    fatal("%s: received bad response to challenge", "mm_answer_rsa_response");
  }
#line 1475
  success = auth_rsa_verify_response(key, ssh1_challenge, response);
#line 1477
  xfree((void *)blob);
#line 1478
  key_free(key);
#line 1479
  xfree((void *)response);
#line 1481
  if (key_blobtype == 4) {
#line 1481
    auth_method = (char *)"rsa";
  } else {
#line 1481
    auth_method = (char *)"rhosts-rsa";
  }
#line 1484
  BN_clear_free(ssh1_challenge);
#line 1485
  ssh1_challenge = (BIGNUM *)((void *)0);
#line 1486
  monitor_reset_key_state();
#line 1488
  buffer_clear(m___0);
#line 1489
  buffer_put_int(m___0, (unsigned int )success);
#line 1490
  mm_request_send(sock, 36, m___0);
#line 1492
  return (success);
}
}
#line 1495 "monitor.c"
int mm_answer_term(int sock , Buffer *req ) 
{ int res ;
  int status ;
  int *tmp ;
  __pid_t tmp___0 ;
  union __anonunion___u_88___1 __u___1 ;
  union __anonunion___u_89___0 __u___2 ;

  {
#line 1501
  debug3("%s: tearing down sessions", "mm_answer_term");
#line 1504
  session_destroy_all(& mm_session_close);
#line 1506
  while (1) {
#line 1506
    tmp___0 = waitpid(pmonitor->m_pid, & status, 0);
#line 1506
    if (! (tmp___0 == -1)) {
#line 1506
      break;
    }
#line 1507
    tmp = __errno_location();
#line 1507
    if (*tmp != 4) {
#line 1508
      exit(1);
    }
  }
#line 1510
  __u___2.__in = status;
#line 1510
  if ((__u___2.__i & 127) == 0) {
#line 1510
    __u___1.__in = status;
#line 1510
    res = (__u___1.__i & 65280) >> 8;
  } else {
#line 1510
    res = 1;
  }
#line 1513
  exit(res);
}
}
#line 1558 "monitor.c"
void monitor_apply_keystate(struct monitor *pmonitor___0 ) 
{ 

  {
#line 1561
  if (compat20) {
#line 1562
    set_newkeys(0);
#line 1563
    set_newkeys(1);
  } else {
#line 1565
    packet_set_protocol_flags((unsigned int )child_state.ssh1protoflags);
#line 1566
    packet_set_encryption_key((u_char const   *)child_state.ssh1key, child_state.ssh1keylen,
                              child_state.ssh1cipher);
#line 1568
    xfree((void *)child_state.ssh1key);
  }
#line 1572
  packet_set_keycontext(1, child_state.keyout);
#line 1573
  xfree((void *)child_state.keyout);
#line 1574
  packet_set_keycontext(0, child_state.keyin);
#line 1575
  xfree((void *)child_state.keyin);
#line 1577
  if (! compat20) {
#line 1578
    packet_set_iv(1, child_state.ivout);
#line 1579
    xfree((void *)child_state.ivout);
#line 1580
    packet_set_iv(0, child_state.ivin);
#line 1581
    xfree((void *)child_state.ivin);
  }
#line 1584
  memcpy((void * __restrict  )(& incoming_stream), (void const   * __restrict  )(& child_state.incoming),
         sizeof(incoming_stream));
#line 1586
  memcpy((void * __restrict  )(& outgoing_stream), (void const   * __restrict  )(& child_state.outgoing),
         sizeof(outgoing_stream));
#line 1590
  if (options.compression) {
#line 1591
    mm_init_compression(pmonitor___0->m_zlib);
  }
#line 1595
  buffer_clear(& input);
#line 1596
  buffer_append(& input, (void const   *)child_state.input, child_state.ilen);
#line 1597
  memset((void *)child_state.input, 0, child_state.ilen);
#line 1598
  xfree((void *)child_state.input);
#line 1600
  buffer_clear(& output);
#line 1601
  buffer_append(& output, (void const   *)child_state.output, child_state.olen);
#line 1602
  memset((void *)child_state.output, 0, child_state.olen);
#line 1603
  xfree((void *)child_state.output);
#line 1604
  return;
}
}
#line 1606 "monitor.c"
static Kex *mm_get_kex(Buffer *m___0 ) 
{ Kex *kex ;
  void *blob ;
  u_int bloblen ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  u_int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 1613
  tmp = xmalloc(sizeof(*kex));
#line 1613
  kex = (Kex *)tmp;
#line 1614
  memset((void *)kex, 0, sizeof(*kex));
#line 1615
  tmp___0 = buffer_get_string(m___0, & kex->session_id_len);
#line 1615
  kex->session_id = (u_char *)tmp___0;
#line 1616
  if ((unsigned int )session_id2___0 == (unsigned int )((void *)0)) {
#line 1619
    fatal("mm_get_get: internal error: bad session id");
  } else {
#line 1616
    if (kex->session_id_len != session_id2_len___0) {
#line 1619
      fatal("mm_get_get: internal error: bad session id");
    } else {
#line 1616
      tmp___1 = memcmp((void const   *)kex->session_id, (void const   *)session_id2___0,
                       session_id2_len___0);
#line 1616
      if (tmp___1 != 0) {
#line 1619
        fatal("mm_get_get: internal error: bad session id");
      }
    }
  }
#line 1620
  kex->we_need = buffer_get_int(m___0);
#line 1621
  kex->kex[0] = & kexdh_server;
#line 1622
  kex->kex[1] = & kexdh_server;
#line 1623
  kex->kex[2] = & kexgex_server;
#line 1624
  kex->server = 1;
#line 1625
  tmp___2 = buffer_get_int(m___0);
#line 1625
  kex->hostkey_type = (int )tmp___2;
#line 1626
  tmp___3 = buffer_get_int(m___0);
#line 1626
  kex->kex_type = (int )tmp___3;
#line 1627
  blob = buffer_get_string(m___0, & bloblen);
#line 1628
  buffer_init(& kex->my);
#line 1629
  buffer_append(& kex->my, (void const   *)blob, bloblen);
#line 1630
  xfree(blob);
#line 1631
  blob = buffer_get_string(m___0, & bloblen);
#line 1632
  buffer_init(& kex->peer);
#line 1633
  buffer_append(& kex->peer, (void const   *)blob, bloblen);
#line 1634
  xfree(blob);
#line 1635
  kex->done = 1;
#line 1636
  tmp___4 = buffer_get_int(m___0);
#line 1636
  kex->flags = (int )tmp___4;
#line 1637
  tmp___5 = buffer_get_string(m___0, (u_int *)((void *)0));
#line 1637
  kex->client_version_string = (char *)tmp___5;
#line 1638
  tmp___6 = buffer_get_string(m___0, (u_int *)((void *)0));
#line 1638
  kex->server_version_string = (char *)tmp___6;
#line 1639
  kex->load_host_key = & get_hostkey_by_type;
#line 1640
  kex->host_key_index = & get_hostkey_index;
#line 1642
  return (kex);
}
}
#line 1647 "monitor.c"
void mm_get_keystate(struct monitor *pmonitor___0 ) 
{ Buffer m___0 ;
  u_char *blob ;
  u_char *p ;
  u_int bloblen ;
  u_int plen ;
  u_int32_t seqnr ;
  u_int32_t packets ;
  u_int64_t blocks ;
  u_int tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;

  {
#line 1656
  debug3("%s: Waiting for new keys", "mm_get_keystate");
#line 1658
  buffer_init(& m___0);
#line 1659
  mm_request_receive_expect(pmonitor___0->m_sendfd, 24, & m___0);
#line 1660
  if (! compat20) {
#line 1661
    tmp = buffer_get_int(& m___0);
#line 1661
    child_state.ssh1protoflags = (int )tmp;
#line 1662
    tmp___0 = buffer_get_int(& m___0);
#line 1662
    child_state.ssh1cipher = (int )tmp___0;
#line 1663
    tmp___1 = buffer_get_string(& m___0, & child_state.ssh1keylen);
#line 1663
    child_state.ssh1key = (u_char *)tmp___1;
#line 1665
    tmp___2 = buffer_get_string(& m___0, & child_state.ivoutlen);
#line 1665
    child_state.ivout = (u_char *)tmp___2;
#line 1667
    tmp___3 = buffer_get_string(& m___0, & child_state.ivinlen);
#line 1667
    child_state.ivin = (u_char *)tmp___3;
    goto skip;
  } else {
#line 1671
    *(pmonitor___0->m_pkex) = mm_get_kex(& m___0);
  }
#line 1674
  tmp___4 = buffer_get_string(& m___0, & bloblen);
#line 1674
  blob = (u_char *)tmp___4;
#line 1675
  current_keys[1] = mm_newkeys_from_blob(blob, (int )bloblen);
#line 1676
  xfree((void *)blob);
#line 1678
  debug3("%s: Waiting for second key", "mm_get_keystate");
#line 1679
  tmp___5 = buffer_get_string(& m___0, & bloblen);
#line 1679
  blob = (u_char *)tmp___5;
#line 1680
  current_keys[0] = mm_newkeys_from_blob(blob, (int )bloblen);
#line 1681
  xfree((void *)blob);
#line 1684
  seqnr = buffer_get_int(& m___0);
#line 1685
  blocks = buffer_get_int64(& m___0);
#line 1686
  packets = buffer_get_int(& m___0);
#line 1687
  packet_set_state(1, seqnr, blocks, packets);
#line 1688
  seqnr = buffer_get_int(& m___0);
#line 1689
  blocks = buffer_get_int64(& m___0);
#line 1690
  packets = buffer_get_int(& m___0);
#line 1691
  packet_set_state(0, seqnr, blocks, packets);
  skip: 
#line 1695
  tmp___6 = buffer_get_string(& m___0, & child_state.keyoutlen);
#line 1695
  child_state.keyout = (u_char *)tmp___6;
#line 1696
  tmp___7 = buffer_get_string(& m___0, & child_state.keyinlen);
#line 1696
  child_state.keyin = (u_char *)tmp___7;
#line 1698
  debug3("%s: Getting compression state", "mm_get_keystate");
#line 1700
  tmp___8 = buffer_get_string(& m___0, & plen);
#line 1700
  p = (u_char *)tmp___8;
#line 1701
  if (plen != sizeof(child_state.outgoing)) {
#line 1702
    fatal("%s: bad request size", "mm_get_keystate");
  }
#line 1703
  memcpy((void * __restrict  )(& child_state.outgoing), (void const   * __restrict  )p,
         sizeof(child_state.outgoing));
#line 1704
  xfree((void *)p);
#line 1706
  tmp___9 = buffer_get_string(& m___0, & plen);
#line 1706
  p = (u_char *)tmp___9;
#line 1707
  if (plen != sizeof(child_state.incoming)) {
#line 1708
    fatal("%s: bad request size", "mm_get_keystate");
  }
#line 1709
  memcpy((void * __restrict  )(& child_state.incoming), (void const   * __restrict  )p,
         sizeof(child_state.incoming));
#line 1710
  xfree((void *)p);
#line 1713
  debug3("%s: Getting Network I/O buffers", "mm_get_keystate");
#line 1714
  tmp___10 = buffer_get_string(& m___0, & child_state.ilen);
#line 1714
  child_state.input = (u_char *)tmp___10;
#line 1715
  tmp___11 = buffer_get_string(& m___0, & child_state.olen);
#line 1715
  child_state.output = (u_char *)tmp___11;
#line 1717
  buffer_free(& m___0);
#line 1718
  return;
}
}
#line 1722 "monitor.c"
void *mm_zalloc(struct mm_master *mm , u_int ncount , u_int size ) 
{ size_t len ;
  void *address ;

  {
#line 1725
  len = size * ncount;
#line 1728
  if (len == 0U) {
#line 1729
    fatal("%s: mm_zalloc(%u, %u)", "mm_zalloc", ncount, size);
  } else {
#line 1728
    if ((unsigned long )ncount > 4294967295UL / (unsigned long )size) {
#line 1729
      fatal("%s: mm_zalloc(%u, %u)", "mm_zalloc", ncount, size);
    }
  }
#line 1731
  address = mm_malloc(mm, len);
#line 1733
  return (address);
}
}
#line 1736 "monitor.c"
void mm_zfree(struct mm_master *mm , void *address ) 
{ 

  {
#line 1739
  mm_free(mm, address);
#line 1740
  return;
}
}
#line 1742 "monitor.c"
void mm_init_compression(struct mm_master *mm ) 
{ 

  {
#line 1745
  outgoing_stream.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))(& mm_zalloc);
#line 1746
  outgoing_stream.zfree = (void (*)(voidpf opaque , voidpf address ))(& mm_zfree);
#line 1747
  outgoing_stream.opaque = (void *)mm;
#line 1749
  incoming_stream.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))(& mm_zalloc);
#line 1750
  incoming_stream.zfree = (void (*)(voidpf opaque , voidpf address ))(& mm_zfree);
#line 1751
  incoming_stream.opaque = (void *)mm;
#line 1752
  return;
}
}
#line 1761 "monitor.c"
static void monitor_socketpair(int *pair ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1765
  tmp = socketpair(1, 1, 0, (int *)pair);
#line 1765
  if (tmp == -1) {
#line 1766
    fatal("%s: socketpair", "monitor_socketpair");
  }
#line 1771
  while (1) {
#line 1771
    tmp___0 = fcntl(*(pair + 0), 2, 1);
#line 1771
    if (tmp___0 == -1) {
#line 1771
      fatal("fcntl(%d, F_SETFD)", *(pair + 0));
    }
#line 1771
    break;
  }
#line 1772
  while (1) {
#line 1772
    tmp___1 = fcntl(*(pair + 1), 2, 1);
#line 1772
    if (tmp___1 == -1) {
#line 1772
      fatal("fcntl(%d, F_SETFD)", *(pair + 1));
    }
#line 1772
    break;
  }
#line 1773
  return;
}
}
#line 1777 "monitor.c"
struct monitor *monitor_init(void) 
{ struct monitor *mon ;
  int pair[2] ;
  void *tmp ;

  {
#line 1783
  tmp = xmalloc(sizeof(*mon));
#line 1783
  mon = (struct monitor *)tmp;
#line 1785
  mon->m_pid = 0;
#line 1786
  monitor_socketpair(pair);
#line 1788
  mon->m_recvfd = pair[0];
#line 1789
  mon->m_sendfd = pair[1];
#line 1792
  if (options.compression) {
#line 1793
    mon->m_zback = mm_create((struct mm_master *)((void *)0), 65536U);
#line 1794
    mon->m_zlib = mm_create(mon->m_zback, 1310720U);
#line 1797
    mm_init_compression(mon->m_zlib);
  }
#line 1800
  return (mon);
}
}
#line 1803 "monitor.c"
void monitor_reinit(struct monitor *mon ) 
{ int pair[2] ;

  {
#line 1808
  monitor_socketpair(pair);
#line 1810
  mon->m_recvfd = pair[0];
#line 1811
  mon->m_sendfd = pair[1];
#line 1812
  return;
}
}
#line 1 "monitor_wrap.o"
#line 44 "monitor_wrap.h"
DH *mm_choose_dh(int min , int nbits , int max ) ;
#line 45
int mm_key_sign(Key *key , u_char **sigp , u_int *lenp , u_char *data , u_int datalen ) ;
#line 50
int mm_key_allowed(enum mm_keytype type , char *user , char *host , Key *key ) ;
#line 94
int mm_newkeys_to_blob(int mode , u_char **blobp , u_int *lenp ) ;
#line 101
int mm_bsdauth_query(void *ctx , char **name , char **infotxt , u_int *numprompts ,
                     char ***prompts , u_int **echo_on ) ;
#line 102
int mm_bsdauth_respond(void *ctx , u_int numresponses , char **responses ) ;
#line 76 "monitor_wrap.c"
int mm_is_monitor(void) 
{ int tmp ;

  {
#line 83
  if (pmonitor) {
#line 83
    if (pmonitor->m_pid > 0) {
#line 83
      tmp = 1;
    } else {
#line 83
      tmp = 0;
    }
  } else {
#line 83
    tmp = 0;
  }
#line 83
  return (tmp);
}
}
#line 86 "monitor_wrap.c"
void mm_request_send(int sock , enum monitor_reqtype type , Buffer *m___0 ) 
{ u_int mlen ;
  u_int tmp ;
  u_char buf___1[5] ;
  int *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;

  {
#line 89
  tmp = buffer_len(m___0);
#line 89
  mlen = tmp;
#line 92
  debug3("%s entering: type %d", "mm_request_send", type);
#line 94
  while (1) {
#line 94
    buf___1[0] = (unsigned char )((mlen + 1U) >> 24);
#line 94
    buf___1[1] = (unsigned char )((mlen + 1U) >> 16);
#line 94
    buf___1[2] = (unsigned char )((mlen + 1U) >> 8);
#line 94
    buf___1[3] = (unsigned char )(mlen + 1U);
#line 94
    break;
  }
#line 95
  buf___1[4] = (unsigned char )type;
#line 96
  tmp___2 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), sock, (void *)(buf___1),
                     sizeof(buf___1));
#line 96
  if (tmp___2 != sizeof(buf___1)) {
#line 97
    tmp___0 = __errno_location();
#line 97
    tmp___1 = strerror(*tmp___0);
#line 97
    fatal("%s: write: %s", "mm_request_send", tmp___1);
  }
#line 98
  tmp___5 = buffer_ptr(m___0);
#line 98
  tmp___6 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), sock, tmp___5,
                     mlen);
#line 98
  if (tmp___6 != mlen) {
#line 99
    tmp___3 = __errno_location();
#line 99
    tmp___4 = strerror(*tmp___3);
#line 99
    fatal("%s: write: %s", "mm_request_send", tmp___4);
  }
#line 100
  return;
}
}
#line 102 "monitor_wrap.c"
void mm_request_receive(int sock , Buffer *m___0 ) 
{ u_char buf___1[4] ;
  u_int msg_len ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;

  {
#line 108
  debug3("%s entering", "mm_request_receive");
#line 110
  tmp___2 = atomicio(& read, sock, (void *)(buf___1), sizeof(buf___1));
#line 110
  if (tmp___2 != sizeof(buf___1)) {
#line 111
    tmp = __errno_location();
#line 111
    if (*tmp == 32) {
#line 112
      cleanup_exit(255);
    }
#line 113
    tmp___0 = __errno_location();
#line 113
    tmp___1 = strerror(*tmp___0);
#line 113
    fatal("%s: read: %s", "mm_request_receive", tmp___1);
  }
#line 115
  msg_len = (unsigned int )(((((unsigned long )buf___1[0] << 24) | ((unsigned long )buf___1[1] << 16)) | ((unsigned long )buf___1[2] << 8)) | (unsigned long )buf___1[3]);
#line 116
  if (msg_len > 262144U) {
#line 117
    fatal("%s: read: bad msg_len %d", "mm_request_receive", msg_len);
  }
#line 118
  buffer_clear(m___0);
#line 119
  buffer_append_space(m___0, msg_len);
#line 120
  tmp___5 = buffer_ptr(m___0);
#line 120
  tmp___6 = atomicio(& read, sock, tmp___5, msg_len);
#line 120
  if (tmp___6 != msg_len) {
#line 121
    tmp___3 = __errno_location();
#line 121
    tmp___4 = strerror(*tmp___3);
#line 121
    fatal("%s: read: %s", "mm_request_receive", tmp___4);
  }
#line 122
  return;
}
}
#line 124 "monitor_wrap.c"
void mm_request_receive_expect(int sock , enum monitor_reqtype type , Buffer *m___0 ) 
{ u_char rtype ;
  int tmp ;

  {
#line 129
  debug3("%s entering: type %d", "mm_request_receive_expect", type);
#line 131
  mm_request_receive(sock, m___0);
#line 132
  tmp = buffer_get_char(m___0);
#line 132
  rtype = (unsigned char )tmp;
#line 133
  if ((int )rtype != (int )type) {
#line 134
    fatal("%s: read: rtype %d != type %d", "mm_request_receive_expect", rtype, type);
  }
#line 136
  return;
}
}
#line 138 "monitor_wrap.c"
DH *mm_choose_dh(int min , int nbits , int max ) 
{ BIGNUM *p ;
  BIGNUM *g ;
  int success ;
  Buffer m___0 ;
  u_int tmp ;
  DH *tmp___0 ;

  {
#line 142
  success = 0;
#line 145
  buffer_init(& m___0);
#line 146
  buffer_put_int(& m___0, (unsigned int )min);
#line 147
  buffer_put_int(& m___0, (unsigned int )nbits);
#line 148
  buffer_put_int(& m___0, (unsigned int )max);
#line 150
  mm_request_send(pmonitor->m_recvfd, 0, & m___0);
#line 152
  debug3("%s: waiting for MONITOR_ANS_MODULI", "mm_choose_dh");
#line 153
  mm_request_receive_expect(pmonitor->m_recvfd, 1, & m___0);
#line 155
  success = buffer_get_char(& m___0);
#line 156
  if (success == 0) {
#line 157
    fatal("%s: MONITOR_ANS_MODULI failed", "mm_choose_dh");
  }
#line 159
  p = BN_new();
#line 159
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 160
    fatal("%s: BN_new failed", "mm_choose_dh");
  }
#line 161
  g = BN_new();
#line 161
  if ((unsigned int )g == (unsigned int )((void *)0)) {
#line 162
    fatal("%s: BN_new failed", "mm_choose_dh");
  }
#line 163
  buffer_get_bignum2(& m___0, p);
#line 164
  buffer_get_bignum2(& m___0, g);
#line 166
  tmp = buffer_len(& m___0);
#line 166
  debug3("%s: remaining %d", "mm_choose_dh", tmp);
#line 167
  buffer_free(& m___0);
#line 169
  tmp___0 = dh_new_group(g, p);
#line 169
  return (tmp___0);
}
}
#line 172 "monitor_wrap.c"
int mm_key_sign(Key *key , u_char **sigp , u_int *lenp , u_char *data , u_int datalen ) 
{ Kex *kex ;
  Buffer m___0 ;
  int tmp ;
  void *tmp___0 ;

  {
#line 175
  kex = *(pmonitor->m_pkex);
#line 178
  debug3("%s entering", "mm_key_sign");
#line 180
  buffer_init(& m___0);
#line 181
  tmp = (*(kex->host_key_index))(key);
#line 181
  buffer_put_int(& m___0, (unsigned int )tmp);
#line 182
  buffer_put_string(& m___0, (void const   *)data, datalen);
#line 184
  mm_request_send(pmonitor->m_recvfd, 4, & m___0);
#line 186
  debug3("%s: waiting for MONITOR_ANS_SIGN", "mm_key_sign");
#line 187
  mm_request_receive_expect(pmonitor->m_recvfd, 5, & m___0);
#line 188
  tmp___0 = buffer_get_string(& m___0, lenp);
#line 188
  *sigp = (u_char *)tmp___0;
#line 189
  buffer_free(& m___0);
#line 191
  return (0);
}
}
#line 194 "monitor_wrap.c"
struct passwd *mm_getpwnamallow(char const   *username ) 
{ Buffer m___0 ;
  struct passwd *pw ;
  u_int pwlen ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
#line 201
  debug3("%s entering", "mm_getpwnamallow");
#line 203
  buffer_init(& m___0);
#line 204
  buffer_put_cstring(& m___0, username);
#line 206
  mm_request_send(pmonitor->m_recvfd, 6, & m___0);
#line 208
  debug3("%s: waiting for MONITOR_ANS_PWNAM", "mm_getpwnamallow");
#line 209
  mm_request_receive_expect(pmonitor->m_recvfd, 7, & m___0);
#line 211
  tmp = buffer_get_char(& m___0);
#line 211
  if (tmp == 0) {
#line 212
    buffer_free(& m___0);
#line 213
    return ((struct passwd *)((void *)0));
  }
#line 215
  tmp___0 = buffer_get_string(& m___0, & pwlen);
#line 215
  pw = (struct passwd *)tmp___0;
#line 216
  if (pwlen != sizeof(struct passwd )) {
#line 217
    fatal("%s: struct passwd size mismatch", "mm_getpwnamallow");
  }
#line 218
  tmp___1 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 218
  pw->pw_name = (char *)tmp___1;
#line 219
  tmp___2 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 219
  pw->pw_passwd = (char *)tmp___2;
#line 220
  tmp___3 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 220
  pw->pw_gecos = (char *)tmp___3;
#line 224
  tmp___4 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 224
  pw->pw_dir = (char *)tmp___4;
#line 225
  tmp___5 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 225
  pw->pw_shell = (char *)tmp___5;
#line 226
  buffer_free(& m___0);
#line 228
  return (pw);
}
}
#line 231 "monitor_wrap.c"
char *mm_auth2_read_banner(void) 
{ Buffer m___0 ;
  char *banner ;
  void *tmp ;
  size_t tmp___0 ;

  {
#line 237
  debug3("%s entering", "mm_auth2_read_banner");
#line 239
  buffer_init(& m___0);
#line 240
  mm_request_send(pmonitor->m_recvfd, 8, & m___0);
#line 241
  buffer_clear(& m___0);
#line 243
  mm_request_receive_expect(pmonitor->m_recvfd, 9, & m___0);
#line 245
  tmp = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 245
  banner = (char *)tmp;
#line 246
  buffer_free(& m___0);
#line 249
  tmp___0 = strlen((char const   *)banner);
#line 249
  if (tmp___0 == 0U) {
#line 250
    xfree((void *)banner);
#line 251
    banner = (char *)((void *)0);
  }
#line 253
  return (banner);
}
}
#line 258 "monitor_wrap.c"
void mm_inform_authserv(char *service , char *style ) 
{ Buffer m___0 ;
  char const   *tmp ;

  {
#line 263
  debug3("%s entering", "mm_inform_authserv");
#line 265
  buffer_init(& m___0);
#line 266
  buffer_put_cstring(& m___0, (char const   *)service);
#line 267
  if (style) {
#line 267
    tmp = (char const   *)style;
  } else {
#line 267
    tmp = "";
  }
#line 267
  buffer_put_cstring(& m___0, tmp);
#line 269
  mm_request_send(pmonitor->m_recvfd, 3, & m___0);
#line 271
  buffer_free(& m___0);
#line 272
  return;
}
}
#line 275 "monitor_wrap.c"
int mm_auth_password(struct Authctxt *authctxt___0 , char *password ) 
{ Buffer m___0 ;
  int authenticated ;
  u_int tmp ;
  char const   *tmp___0 ;

  {
#line 279
  authenticated = 0;
#line 281
  debug3("%s entering", "mm_auth_password");
#line 283
  buffer_init(& m___0);
#line 284
  buffer_put_cstring(& m___0, (char const   *)password);
#line 285
  mm_request_send(pmonitor->m_recvfd, 10, & m___0);
#line 287
  debug3("%s: waiting for MONITOR_ANS_AUTHPASSWORD", "mm_auth_password");
#line 288
  mm_request_receive_expect(pmonitor->m_recvfd, 11, & m___0);
#line 290
  tmp = buffer_get_int(& m___0);
#line 290
  authenticated = (int )tmp;
#line 292
  buffer_free(& m___0);
#line 294
  if (authenticated) {
#line 294
    tmp___0 = "";
  } else {
#line 294
    tmp___0 = "not ";
  }
#line 294
  debug3("%s: user %sauthenticated", "mm_auth_password", tmp___0);
#line 296
  return (authenticated);
}
}
#line 299 "monitor_wrap.c"
int mm_user_key_allowed(struct passwd *pw , Key *key ) 
{ int tmp ;

  {
#line 302
  tmp = mm_key_allowed(2, (char *)((void *)0), (char *)((void *)0), key);
#line 302
  return (tmp);
}
}
#line 305 "monitor_wrap.c"
int mm_hostbased_key_allowed(struct passwd *pw , char *user , char *host , Key *key ) 
{ int tmp ;

  {
#line 309
  tmp = mm_key_allowed(1, user, host, key);
#line 309
  return (tmp);
}
}
#line 312 "monitor_wrap.c"
int mm_auth_rhosts_rsa_key_allowed(struct passwd *pw , char *user , char *host , Key *key ) 
{ int ret ;

  {
#line 318
  key->type = 1;
#line 319
  ret = mm_key_allowed(3, user, host, key);
#line 320
  key->type = 0;
#line 321
  return (ret);
}
}
#line 324 "monitor_wrap.c"
static void mm_send_debug(Buffer *m___0 ) 
{ char *msg ;
  void *tmp ;
  u_int tmp___0 ;

  {
#line 329
  while (1) {
#line 329
    tmp___0 = buffer_len(m___0);
#line 329
    if (! tmp___0) {
#line 329
      break;
    }
#line 330
    tmp = buffer_get_string(m___0, (u_int *)((void *)0));
#line 330
    msg = (char *)tmp;
#line 331
    debug3("%s: Sending debug: %s", "mm_send_debug", msg);
#line 332
    packet_send_debug("%s", msg);
#line 333
    xfree((void *)msg);
  }
#line 335
  return;
}
}
#line 337 "monitor_wrap.c"
int mm_key_allowed(enum mm_keytype type , char *user , char *host , Key *key ) 
{ Buffer m___0 ;
  u_char *blob ;
  u_int len ;
  int allowed ;
  int have_forced ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;

  {
#line 343
  allowed = 0;
#line 343
  have_forced = 0;
#line 345
  debug3("%s entering", "mm_key_allowed");
#line 348
  tmp = key_to_blob((Key const   *)key, & blob, & len);
#line 348
  if (! tmp) {
#line 349
    return (0);
  }
#line 351
  buffer_init(& m___0);
#line 352
  buffer_put_int(& m___0, (unsigned int )type);
#line 353
  if (user) {
#line 353
    tmp___0 = (char const   *)user;
  } else {
#line 353
    tmp___0 = "";
  }
#line 353
  buffer_put_cstring(& m___0, tmp___0);
#line 354
  if (host) {
#line 354
    tmp___1 = (char const   *)host;
  } else {
#line 354
    tmp___1 = "";
  }
#line 354
  buffer_put_cstring(& m___0, tmp___1);
#line 355
  buffer_put_string(& m___0, (void const   *)blob, len);
#line 356
  xfree((void *)blob);
#line 358
  mm_request_send(pmonitor->m_recvfd, 20, & m___0);
#line 360
  debug3("%s: waiting for MONITOR_ANS_KEYALLOWED", "mm_key_allowed");
#line 361
  mm_request_receive_expect(pmonitor->m_recvfd, 21, & m___0);
#line 363
  tmp___2 = buffer_get_int(& m___0);
#line 363
  allowed = (int )tmp___2;
#line 366
  auth_clear_options();
#line 367
  tmp___3 = buffer_get_int(& m___0);
#line 367
  have_forced = (int )tmp___3;
#line 368
  if (have_forced) {
#line 368
    forced_command = xstrdup("true");
  } else {
#line 368
    forced_command = (char *)((void *)0);
  }
#line 371
  mm_send_debug(& m___0);
#line 373
  buffer_free(& m___0);
#line 375
  return (allowed);
}
}
#line 384 "monitor_wrap.c"
int mm_key_verify(Key *key , u_char *sig , u_int siglen , u_char *data , u_int datalen ) 
{ Buffer m___0 ;
  u_char *blob ;
  u_int len ;
  int verified ;
  int tmp ;
  u_int tmp___0 ;

  {
#line 390
  verified = 0;
#line 392
  debug3("%s entering", "mm_key_verify");
#line 395
  tmp = key_to_blob((Key const   *)key, & blob, & len);
#line 395
  if (! tmp) {
#line 396
    return (0);
  }
#line 398
  buffer_init(& m___0);
#line 399
  buffer_put_string(& m___0, (void const   *)blob, len);
#line 400
  buffer_put_string(& m___0, (void const   *)sig, siglen);
#line 401
  buffer_put_string(& m___0, (void const   *)data, datalen);
#line 402
  xfree((void *)blob);
#line 404
  mm_request_send(pmonitor->m_recvfd, 22, & m___0);
#line 406
  debug3("%s: waiting for MONITOR_ANS_KEYVERIFY", "mm_key_verify");
#line 407
  mm_request_receive_expect(pmonitor->m_recvfd, 23, & m___0);
#line 409
  tmp___0 = buffer_get_int(& m___0);
#line 409
  verified = (int )tmp___0;
#line 411
  buffer_free(& m___0);
#line 413
  return (verified);
}
}
#line 417 "monitor_wrap.c"
struct Newkeys *mm_newkeys_from_blob(u_char *blob , int blen ) 
{ Buffer b ;
  u_int len ;
  Newkeys *newkey ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  void *tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  Cipher *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  u_int tmp___7 ;
  void *tmp___8 ;
  u_int tmp___9 ;
  u_int tmp___10 ;
  void *tmp___11 ;

  {
#line 422
  newkey = (Newkeys *)((void *)0);
#line 427
  debug3("%s: %p(%d)", "mm_newkeys_from_blob", blob, blen);
#line 431
  buffer_init(& b);
#line 432
  buffer_append(& b, (void const   *)blob, (unsigned int )blen);
#line 434
  tmp = xmalloc(sizeof(*newkey));
#line 434
  newkey = (Newkeys *)tmp;
#line 435
  enc = & newkey->enc;
#line 436
  mac = & newkey->mac;
#line 437
  comp = & newkey->comp;
#line 440
  tmp___0 = buffer_get_string(& b, (u_int *)((void *)0));
#line 440
  enc->name = (char *)tmp___0;
#line 441
  buffer_get(& b, (void *)(& enc->cipher), sizeof(enc->cipher));
#line 442
  tmp___1 = buffer_get_int(& b);
#line 442
  enc->enabled = (int )tmp___1;
#line 443
  enc->block_size = buffer_get_int(& b);
#line 444
  tmp___2 = buffer_get_string(& b, & enc->key_len);
#line 444
  enc->key = (u_char *)tmp___2;
#line 445
  tmp___3 = buffer_get_string(& b, & len);
#line 445
  enc->iv = (u_char *)tmp___3;
#line 446
  if (len != enc->block_size) {
#line 447
    fatal("%s: bad ivlen: expected %u != %u", "mm_newkeys_from_blob", enc->block_size,
          len);
  }
#line 450
  if ((unsigned int )enc->name == (unsigned int )((void *)0)) {
#line 451
    fatal("%s: bad cipher name %s or pointer %p", "mm_newkeys_from_blob", enc->name,
          enc->cipher);
  } else {
#line 450
    tmp___4 = cipher_by_name((char const   *)enc->name);
#line 450
    if ((unsigned int )tmp___4 != (unsigned int )enc->cipher) {
#line 451
      fatal("%s: bad cipher name %s or pointer %p", "mm_newkeys_from_blob", enc->name,
            enc->cipher);
    }
  }
#line 455
  tmp___5 = buffer_get_string(& b, (u_int *)((void *)0));
#line 455
  mac->name = (char *)tmp___5;
#line 456
  if ((unsigned int )mac->name == (unsigned int )((void *)0)) {
#line 457
    fatal("%s: can not init mac %s", "mm_newkeys_from_blob", mac->name);
  } else {
#line 456
    tmp___6 = mac_init(mac, mac->name);
#line 456
    if (tmp___6 == -1) {
#line 457
      fatal("%s: can not init mac %s", "mm_newkeys_from_blob", mac->name);
    }
  }
#line 458
  tmp___7 = buffer_get_int(& b);
#line 458
  mac->enabled = (int )tmp___7;
#line 459
  tmp___8 = buffer_get_string(& b, & len);
#line 459
  mac->key = (u_char *)tmp___8;
#line 460
  if (len > mac->key_len) {
#line 461
    fatal("%s: bad mac key length: %u > %d", "mm_newkeys_from_blob", len, mac->key_len);
  }
#line 463
  mac->key_len = len;
#line 466
  tmp___9 = buffer_get_int(& b);
#line 466
  comp->type = (int )tmp___9;
#line 467
  tmp___10 = buffer_get_int(& b);
#line 467
  comp->enabled = (int )tmp___10;
#line 468
  tmp___11 = buffer_get_string(& b, (u_int *)((void *)0));
#line 468
  comp->name = (char *)tmp___11;
#line 470
  len = buffer_len(& b);
#line 471
  if (len != 0U) {
#line 472
    error("newkeys_from_blob: remaining bytes in blob %u", len);
  }
#line 473
  buffer_free(& b);
#line 474
  return (newkey);
}
}
#line 477 "monitor_wrap.c"
int mm_newkeys_to_blob(int mode , u_char **blobp , u_int *lenp ) 
{ Buffer b ;
  int len ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  Newkeys *newkey ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 485
  newkey = newkeys[mode];
#line 487
  debug3("%s: converting %p", "mm_newkeys_to_blob", newkey);
#line 489
  if ((unsigned int )newkey == (unsigned int )((void *)0)) {
#line 490
    error("%s: newkey == NULL", "mm_newkeys_to_blob");
#line 491
    return (0);
  }
#line 493
  enc = & newkey->enc;
#line 494
  mac = & newkey->mac;
#line 495
  comp = & newkey->comp;
#line 497
  buffer_init(& b);
#line 499
  buffer_put_cstring(& b, (char const   *)enc->name);
#line 501
  buffer_append(& b, (void const   *)(& enc->cipher), sizeof(enc->cipher));
#line 502
  buffer_put_int(& b, (unsigned int )enc->enabled);
#line 503
  buffer_put_int(& b, enc->block_size);
#line 504
  buffer_put_string(& b, (void const   *)enc->key, enc->key_len);
#line 505
  packet_get_keyiv(mode, enc->iv, enc->block_size);
#line 506
  buffer_put_string(& b, (void const   *)enc->iv, enc->block_size);
#line 509
  buffer_put_cstring(& b, (char const   *)mac->name);
#line 510
  buffer_put_int(& b, (unsigned int )mac->enabled);
#line 511
  buffer_put_string(& b, (void const   *)mac->key, mac->key_len);
#line 514
  buffer_put_int(& b, (unsigned int )comp->type);
#line 515
  buffer_put_int(& b, (unsigned int )comp->enabled);
#line 516
  buffer_put_cstring(& b, (char const   *)comp->name);
#line 518
  tmp = buffer_len(& b);
#line 518
  len = (int )tmp;
#line 519
  if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 520
    *lenp = (unsigned int )len;
  }
#line 521
  if ((unsigned int )blobp != (unsigned int )((void *)0)) {
#line 522
    tmp___0 = xmalloc((unsigned int )len);
#line 522
    *blobp = (u_char *)tmp___0;
#line 523
    tmp___1 = buffer_ptr(& b);
#line 523
    memcpy((void * __restrict  )*blobp, (void const   * __restrict  )tmp___1, (unsigned int )len);
  }
#line 525
  tmp___2 = buffer_ptr(& b);
#line 525
  memset(tmp___2, 0, (unsigned int )len);
#line 526
  buffer_free(& b);
#line 527
  return (len);
}
}
#line 530 "monitor_wrap.c"
static void mm_send_kex(Buffer *m___0 , Kex *kex ) 
{ u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;

  {
#line 533
  buffer_put_string(m___0, (void const   *)kex->session_id, kex->session_id_len);
#line 534
  buffer_put_int(m___0, kex->we_need);
#line 535
  buffer_put_int(m___0, (unsigned int )kex->hostkey_type);
#line 536
  buffer_put_int(m___0, (unsigned int )kex->kex_type);
#line 537
  tmp = buffer_len(& kex->my);
#line 537
  tmp___0 = buffer_ptr(& kex->my);
#line 537
  buffer_put_string(m___0, (void const   *)tmp___0, tmp);
#line 538
  tmp___1 = buffer_len(& kex->peer);
#line 538
  tmp___2 = buffer_ptr(& kex->peer);
#line 538
  buffer_put_string(m___0, (void const   *)tmp___2, tmp___1);
#line 539
  buffer_put_int(m___0, (unsigned int )kex->flags);
#line 540
  buffer_put_cstring(m___0, (char const   *)kex->client_version_string);
#line 541
  buffer_put_cstring(m___0, (char const   *)kex->server_version_string);
#line 542
  return;
}
}
#line 544 "monitor_wrap.c"
void mm_send_keystate(struct monitor *monitor ) 
{ Buffer m___0 ;
  u_char *blob ;
  u_char *p ;
  u_int bloblen ;
  u_int plen ;
  u_int32_t seqnr ;
  u_int32_t packets ;
  u_int64_t blocks ;
  u_char iv[24] ;
  u_char *key ;
  u_int ivlen ;
  u_int keylen ;
  u_int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  u_int tmp___10 ;
  void *tmp___11 ;
  u_int tmp___12 ;
  void *tmp___13 ;

  {
#line 553
  buffer_init(& m___0);
#line 555
  if (! compat20) {
#line 560
    tmp = packet_get_protocol_flags();
#line 560
    buffer_put_int(& m___0, tmp);
#line 562
    tmp___0 = packet_get_ssh1_cipher();
#line 562
    buffer_put_int(& m___0, (unsigned int )tmp___0);
#line 564
    debug3("%s: Sending ssh1 KEY+IV", "mm_send_keystate");
#line 565
    keylen = packet_get_encryption_key((u_char *)((void *)0));
#line 566
    tmp___1 = xmalloc(keylen + 1U);
#line 566
    key = (u_char *)tmp___1;
#line 567
    keylen = packet_get_encryption_key(key);
#line 568
    buffer_put_string(& m___0, (void const   *)key, keylen);
#line 569
    memset((void *)key, 0, keylen);
#line 570
    xfree((void *)key);
#line 572
    tmp___2 = packet_get_keyiv_len(1);
#line 572
    ivlen = (unsigned int )tmp___2;
#line 573
    packet_get_keyiv(1, iv, ivlen);
#line 574
    buffer_put_string(& m___0, (void const   *)(iv), ivlen);
#line 575
    tmp___3 = packet_get_keyiv_len(1);
#line 575
    ivlen = (unsigned int )tmp___3;
#line 576
    packet_get_keyiv(0, iv, ivlen);
#line 577
    buffer_put_string(& m___0, (void const   *)(iv), ivlen);
    goto skip;
  } else {
#line 581
    mm_send_kex(& m___0, *(monitor->m_pkex));
  }
#line 584
  debug3("%s: Sending new keys: %p %p", "mm_send_keystate", newkeys[1], newkeys[0]);
#line 588
  tmp___4 = mm_newkeys_to_blob(1, & blob, & bloblen);
#line 588
  if (! tmp___4) {
#line 589
    fatal("%s: conversion of newkeys failed", "mm_send_keystate");
  }
#line 591
  buffer_put_string(& m___0, (void const   *)blob, bloblen);
#line 592
  xfree((void *)blob);
#line 594
  tmp___5 = mm_newkeys_to_blob(0, & blob, & bloblen);
#line 594
  if (! tmp___5) {
#line 595
    fatal("%s: conversion of newkeys failed", "mm_send_keystate");
  }
#line 597
  buffer_put_string(& m___0, (void const   *)blob, bloblen);
#line 598
  xfree((void *)blob);
#line 600
  packet_get_state(1, & seqnr, & blocks, & packets);
#line 601
  buffer_put_int(& m___0, seqnr);
#line 602
  buffer_put_int64(& m___0, blocks);
#line 603
  buffer_put_int(& m___0, packets);
#line 604
  packet_get_state(0, & seqnr, & blocks, & packets);
#line 605
  buffer_put_int(& m___0, seqnr);
#line 606
  buffer_put_int64(& m___0, blocks);
#line 607
  buffer_put_int(& m___0, packets);
#line 609
  debug3("%s: New keys have been sent", "mm_send_keystate");
  skip: 
#line 612
  tmp___6 = packet_get_keycontext(1, (u_char *)((void *)0));
#line 612
  plen = (unsigned int )tmp___6;
#line 613
  tmp___7 = xmalloc(plen + 1U);
#line 613
  p = (u_char *)tmp___7;
#line 614
  packet_get_keycontext(1, p);
#line 615
  buffer_put_string(& m___0, (void const   *)p, plen);
#line 616
  xfree((void *)p);
#line 618
  tmp___8 = packet_get_keycontext(0, (u_char *)((void *)0));
#line 618
  plen = (unsigned int )tmp___8;
#line 619
  tmp___9 = xmalloc(plen + 1U);
#line 619
  p = (u_char *)tmp___9;
#line 620
  packet_get_keycontext(0, p);
#line 621
  buffer_put_string(& m___0, (void const   *)p, plen);
#line 622
  xfree((void *)p);
#line 625
  debug3("%s: Sending compression state", "mm_send_keystate");
#line 626
  buffer_put_string(& m___0, (void const   *)(& outgoing_stream), sizeof(outgoing_stream));
#line 627
  buffer_put_string(& m___0, (void const   *)(& incoming_stream), sizeof(incoming_stream));
#line 630
  tmp___10 = buffer_len(& input);
#line 630
  tmp___11 = buffer_ptr(& input);
#line 630
  buffer_put_string(& m___0, (void const   *)tmp___11, tmp___10);
#line 631
  tmp___12 = buffer_len(& output);
#line 631
  tmp___13 = buffer_ptr(& output);
#line 631
  buffer_put_string(& m___0, (void const   *)tmp___13, tmp___12);
#line 633
  mm_request_send(monitor->m_recvfd, 24, & m___0);
#line 634
  debug3("%s: Finished sending state", "mm_send_keystate");
#line 636
  buffer_free(& m___0);
#line 637
  return;
}
}
#line 639 "monitor_wrap.c"
int mm_pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) 
{ Buffer m___0 ;
  char *p ;
  char *msg ;
  int success ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
#line 644
  success = 0;
#line 646
  buffer_init(& m___0);
#line 647
  mm_request_send(pmonitor->m_recvfd, 25, & m___0);
#line 649
  debug3("%s: waiting for MONITOR_ANS_PTY", "mm_pty_allocate");
#line 650
  mm_request_receive_expect(pmonitor->m_recvfd, 26, & m___0);
#line 652
  tmp = buffer_get_int(& m___0);
#line 652
  success = (int )tmp;
#line 653
  if (success == 0) {
#line 654
    debug3("%s: pty alloc failed", "mm_pty_allocate");
#line 655
    buffer_free(& m___0);
#line 656
    return (0);
  }
#line 658
  tmp___0 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 658
  p = (char *)tmp___0;
#line 659
  tmp___1 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 659
  msg = (char *)tmp___1;
#line 660
  buffer_free(& m___0);
#line 662
  strlcpy(namebuf, (char const   *)p, (unsigned int )namebuflen);
#line 663
  xfree((void *)p);
#line 665
  tmp___2 = strlen((char const   *)msg);
#line 665
  buffer_append(& loginmsg, (void const   *)msg, tmp___2);
#line 666
  xfree((void *)msg);
#line 668
  *ptyfd = mm_receive_fd(pmonitor->m_recvfd);
#line 669
  *ttyfd = mm_receive_fd(pmonitor->m_recvfd);
#line 672
  return (1);
}
}
#line 675 "monitor_wrap.c"
void mm_session_pty_cleanup2(struct Session *s ) 
{ Buffer m___0 ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 680
  if (s->ttyfd == -1) {
#line 681
    return;
  }
#line 682
  buffer_init(& m___0);
#line 683
  buffer_put_cstring(& m___0, (char const   *)(s->tty));
#line 684
  mm_request_send(pmonitor->m_recvfd, 27, & m___0);
#line 685
  buffer_free(& m___0);
#line 688
  tmp___1 = close(s->ptymaster);
#line 688
  if (tmp___1 < 0) {
#line 689
    tmp = __errno_location();
#line 689
    tmp___0 = strerror(*tmp);
#line 689
    error("close(s->ptymaster): %s", tmp___0);
  }
#line 692
  s->ttyfd = -1;
#line 693
  return;
}
}
#line 826 "monitor_wrap.c"
void mm_terminate(void) 
{ Buffer m___0 ;

  {
#line 831
  buffer_init(& m___0);
#line 832
  mm_request_send(pmonitor->m_recvfd, 58, & m___0);
#line 833
  buffer_free(& m___0);
#line 834
  return;
}
}
#line 836 "monitor_wrap.c"
int mm_ssh1_session_key(BIGNUM *num ) 
{ int rsafail ;
  Buffer m___0 ;
  u_int tmp ;

  {
#line 842
  buffer_init(& m___0);
#line 843
  buffer_put_bignum2(& m___0, (BIGNUM const   *)num);
#line 844
  mm_request_send(pmonitor->m_recvfd, 28, & m___0);
#line 846
  mm_request_receive_expect(pmonitor->m_recvfd, 29, & m___0);
#line 848
  tmp = buffer_get_int(& m___0);
#line 848
  rsafail = (int )tmp;
#line 849
  buffer_get_bignum2(& m___0, num);
#line 851
  buffer_free(& m___0);
#line 853
  return (rsafail);
}
}
#line 856 "monitor_wrap.c"
static void mm_chall_setup(char **name , char **infotxt , u_int *numprompts , char ***prompts ,
                           u_int **echo_on ) 
{ void *tmp ;
  void *tmp___0 ;

  {
#line 860
  *name = xstrdup("");
#line 861
  *infotxt = xstrdup("");
#line 862
  *numprompts = 1U;
#line 863
  tmp = xmalloc(*numprompts * sizeof(char *));
#line 863
  *prompts = (char **)tmp;
#line 864
  tmp___0 = xmalloc(*numprompts * sizeof(u_int ));
#line 864
  *echo_on = (u_int *)tmp___0;
#line 865
  *(*echo_on + 0) = 0U;
#line 866
  return;
}
}
#line 868 "monitor_wrap.c"
int mm_bsdauth_query(void *ctx , char **name , char **infotxt , u_int *numprompts ,
                     char ***prompts , u_int **echo_on ) 
{ Buffer m___0 ;
  u_int success ;
  char *challenge ;
  void *tmp ;

  {
#line 876
  debug3("%s: entering", "mm_bsdauth_query");
#line 878
  buffer_init(& m___0);
#line 879
  mm_request_send(pmonitor->m_recvfd, 12, & m___0);
#line 881
  mm_request_receive_expect(pmonitor->m_recvfd, 13, & m___0);
#line 883
  success = buffer_get_int(& m___0);
#line 884
  if (success == 0U) {
#line 885
    debug3("%s: no challenge", "mm_bsdauth_query");
#line 886
    buffer_free(& m___0);
#line 887
    return (-1);
  }
#line 891
  tmp = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 891
  challenge = (char *)tmp;
#line 892
  buffer_free(& m___0);
#line 894
  mm_chall_setup(name, infotxt, numprompts, prompts, echo_on);
#line 895
  *(*prompts + 0) = challenge;
#line 897
  debug3("%s: received challenge: %s", "mm_bsdauth_query", challenge);
#line 899
  return (0);
}
}
#line 902 "monitor_wrap.c"
int mm_bsdauth_respond(void *ctx , u_int numresponses , char **responses ) 
{ Buffer m___0 ;
  int authok ;
  u_int tmp ;
  int tmp___0 ;

  {
#line 908
  debug3("%s: entering", "mm_bsdauth_respond");
#line 909
  if (numresponses != 1U) {
#line 910
    return (-1);
  }
#line 912
  buffer_init(& m___0);
#line 913
  buffer_put_cstring(& m___0, (char const   *)*(responses + 0));
#line 914
  mm_request_send(pmonitor->m_recvfd, 14, & m___0);
#line 916
  mm_request_receive_expect(pmonitor->m_recvfd, 15, & m___0);
#line 919
  tmp = buffer_get_int(& m___0);
#line 919
  authok = (int )tmp;
#line 920
  buffer_free(& m___0);
#line 922
  if (authok == 0) {
#line 922
    tmp___0 = -1;
  } else {
#line 922
    tmp___0 = 0;
  }
#line 922
  return (tmp___0);
}
}
#line 991 "monitor_wrap.c"
void mm_ssh1_session_id(u_char *session_id___0 ) 
{ Buffer m___0 ;
  int i ;

  {
#line 997
  debug3("%s entering", "mm_ssh1_session_id");
#line 999
  buffer_init(& m___0);
#line 1000
  i = 0;
#line 1000
  while (i < 16) {
#line 1001
    buffer_put_char(& m___0, (int )*(session_id___0 + i));
#line 1000
    i ++;
  }
#line 1003
  mm_request_send(pmonitor->m_recvfd, 30, & m___0);
#line 1004
  buffer_free(& m___0);
#line 1005
  return;
}
}
#line 1007 "monitor_wrap.c"
int mm_auth_rsa_key_allowed(struct passwd *pw , BIGNUM *client_n , Key **rkey ) 
{ Buffer m___0 ;
  Key *key ;
  u_char *blob ;
  u_int blen ;
  int allowed ;
  int have_forced ;
  u_int tmp ;
  u_int tmp___0 ;
  void *tmp___2 ;

  {
#line 1014
  allowed = 0;
#line 1014
  have_forced = 0;
#line 1016
  debug3("%s entering", "mm_auth_rsa_key_allowed");
#line 1018
  buffer_init(& m___0);
#line 1019
  buffer_put_bignum2(& m___0, (BIGNUM const   *)client_n);
#line 1021
  mm_request_send(pmonitor->m_recvfd, 31, & m___0);
#line 1022
  mm_request_receive_expect(pmonitor->m_recvfd, 32, & m___0);
#line 1024
  tmp = buffer_get_int(& m___0);
#line 1024
  allowed = (int )tmp;
#line 1027
  auth_clear_options();
#line 1028
  tmp___0 = buffer_get_int(& m___0);
#line 1028
  have_forced = (int )tmp___0;
#line 1029
  if (have_forced) {
#line 1029
    forced_command = xstrdup("true");
  } else {
#line 1029
    forced_command = (char *)((void *)0);
  }
#line 1031
  if (allowed) {
#line 1031
    if ((unsigned int )rkey != (unsigned int )((void *)0)) {
#line 1032
      tmp___2 = buffer_get_string(& m___0, & blen);
#line 1032
      blob = (u_char *)tmp___2;
#line 1033
      key = key_from_blob((u_char const   *)blob, blen);
#line 1033
      if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 1034
        fatal("%s: key_from_blob failed", "mm_auth_rsa_key_allowed");
      }
#line 1035
      *rkey = key;
#line 1036
      xfree((void *)blob);
    }
  }
#line 1038
  mm_send_debug(& m___0);
#line 1039
  buffer_free(& m___0);
#line 1041
  return (allowed);
}
}
#line 1044 "monitor_wrap.c"
BIGNUM *mm_auth_rsa_generate_challenge(Key *key ) 
{ Buffer m___0 ;
  BIGNUM *challenge ;
  u_char *blob ;
  u_int blen ;
  int tmp ;

  {
#line 1052
  debug3("%s entering", "mm_auth_rsa_generate_challenge");
#line 1054
  challenge = BN_new();
#line 1054
  if ((unsigned int )challenge == (unsigned int )((void *)0)) {
#line 1055
    fatal("%s: BN_new failed", "mm_auth_rsa_generate_challenge");
  }
#line 1057
  key->type = 1;
#line 1058
  tmp = key_to_blob((Key const   *)key, & blob, & blen);
#line 1058
  if (tmp == 0) {
#line 1059
    fatal("%s: key_to_blob failed", "mm_auth_rsa_generate_challenge");
  }
#line 1060
  key->type = 0;
#line 1062
  buffer_init(& m___0);
#line 1063
  buffer_put_string(& m___0, (void const   *)blob, blen);
#line 1064
  xfree((void *)blob);
#line 1066
  mm_request_send(pmonitor->m_recvfd, 33, & m___0);
#line 1067
  mm_request_receive_expect(pmonitor->m_recvfd, 34, & m___0);
#line 1069
  buffer_get_bignum2(& m___0, challenge);
#line 1070
  buffer_free(& m___0);
#line 1072
  return (challenge);
}
}
#line 1075 "monitor_wrap.c"
int mm_auth_rsa_verify_response(Key *key , BIGNUM *p , u_char *response ) 
{ Buffer m___0 ;
  u_char *blob ;
  u_int blen ;
  int success ;
  int tmp ;
  u_int tmp___0 ;

  {
#line 1081
  success = 0;
#line 1083
  debug3("%s entering", "mm_auth_rsa_verify_response");
#line 1085
  key->type = 1;
#line 1086
  tmp = key_to_blob((Key const   *)key, & blob, & blen);
#line 1086
  if (tmp == 0) {
#line 1087
    fatal("%s: key_to_blob failed", "mm_auth_rsa_verify_response");
  }
#line 1088
  key->type = 0;
#line 1090
  buffer_init(& m___0);
#line 1091
  buffer_put_string(& m___0, (void const   *)blob, blen);
#line 1092
  buffer_put_string(& m___0, (void const   *)response, 16U);
#line 1093
  xfree((void *)blob);
#line 1095
  mm_request_send(pmonitor->m_recvfd, 35, & m___0);
#line 1096
  mm_request_receive_expect(pmonitor->m_recvfd, 36, & m___0);
#line 1098
  tmp___0 = buffer_get_int(& m___0);
#line 1098
  success = (int )tmp___0;
#line 1099
  buffer_free(& m___0);
#line 1101
  return (success);
}
}
#line 1 "kexdhs.o"
#line 37 "kexdhs.c"
void kexdh_server(Kex *kex ) 
{ BIGNUM *shared_secret ;
  BIGNUM *dh_client_pub ;
  DH *dh ;
  Key *server_host_key ;
  u_char *kbuf ;
  u_char *hash ;
  u_char *signature ;
  u_char *server_host_key_blob ;
  u_int sbloblen ;
  u_int klen ;
  u_int kout ;
  u_int hashlen ;
  u_int slen ;
  int _len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  u_int tmp___4 ;
  void *tmp___5 ;
  u_int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;

  {
#line 40
  shared_secret = (BIGNUM *)((void *)0);
#line 40
  dh_client_pub = (BIGNUM *)((void *)0);
#line 43
  signature = (u_char *)((void *)0);
#line 43
  server_host_key_blob = (u_char *)((void *)0);
#line 48
  switch (kex->kex_type) {
  case 0: 
#line 50
  dh = dh_new_group1();
#line 51
  break;
  case 1: 
#line 53
  dh = dh_new_group14();
#line 54
  break;
  default: 
#line 56
  fatal("%s: Unexpected KEX type %d", "kexdh_server", kex->kex_type);
  }
#line 58
  dh_gen_key(dh, (int )(kex->we_need * 8U));
#line 60
  debug("expecting SSH2_MSG_KEXDH_INIT");
#line 61
  packet_read_expect(30);
#line 63
  if ((unsigned int )kex->load_host_key == (unsigned int )((void *)0)) {
#line 64
    fatal("Cannot load hostkey");
  }
#line 65
  server_host_key = (*(kex->load_host_key))(kex->hostkey_type);
#line 66
  if ((unsigned int )server_host_key == (unsigned int )((void *)0)) {
#line 67
    fatal("Unsupported hostkey type %d", kex->hostkey_type);
  }
#line 70
  dh_client_pub = BN_new();
#line 70
  if ((unsigned int )dh_client_pub == (unsigned int )((void *)0)) {
#line 71
    fatal("dh_client_pub == NULL");
  }
#line 72
  packet_get_bignum2(dh_client_pub);
#line 73
  while (1) {
#line 73
    tmp = packet_remaining();
#line 73
    _len = tmp;
#line 73
    if (_len > 0) {
#line 73
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kexdhs.c",
            73);
#line 73
      packet_disconnect("Packet integrity error.");
    }
#line 73
    break;
  }
#line 88
  tmp___0 = dh_pub_is_valid(dh, dh_client_pub);
#line 88
  if (! tmp___0) {
#line 89
    packet_disconnect("bad client public DH value");
  }
#line 91
  tmp___1 = DH_size((DH const   *)dh);
#line 91
  klen = (unsigned int )tmp___1;
#line 92
  tmp___2 = xmalloc(klen);
#line 92
  kbuf = (u_char *)tmp___2;
#line 93
  tmp___3 = DH_compute_key(kbuf, (BIGNUM const   *)dh_client_pub, dh);
#line 93
  kout = (unsigned int )tmp___3;
#line 97
  shared_secret = BN_new();
#line 97
  if ((unsigned int )shared_secret == (unsigned int )((void *)0)) {
#line 98
    fatal("kexdh_server: BN_new failed");
  }
#line 99
  BN_bin2bn((unsigned char const   *)kbuf, (int )kout, shared_secret);
#line 100
  memset((void *)kbuf, 0, klen);
#line 101
  xfree((void *)kbuf);
#line 103
  key_to_blob((Key const   *)server_host_key, & server_host_key_blob, & sbloblen);
#line 106
  tmp___4 = buffer_len(& kex->my);
#line 106
  tmp___5 = buffer_ptr(& kex->my);
#line 106
  tmp___6 = buffer_len(& kex->peer);
#line 106
  tmp___7 = buffer_ptr(& kex->peer);
#line 106
  kex_dh_hash(kex->client_version_string, kex->server_version_string, (char *)tmp___7,
              (int )tmp___6, (char *)tmp___5, (int )tmp___4, server_host_key_blob,
              (int )sbloblen, dh_client_pub, dh->pub_key, shared_secret, & hash, & hashlen);
#line 117
  BN_clear_free(dh_client_pub);
#line 120
  if ((unsigned int )kex->session_id == (unsigned int )((void *)0)) {
#line 121
    kex->session_id_len = hashlen;
#line 122
    tmp___8 = xmalloc(kex->session_id_len);
#line 122
    kex->session_id = (u_char *)tmp___8;
#line 123
    memcpy((void * __restrict  )kex->session_id, (void const   * __restrict  )hash,
           kex->session_id_len);
  }
#line 127
  if (use_privsep) {
#line 127
    mm_key_sign(server_host_key, & signature, & slen, hash, hashlen);
  } else {
#line 127
    key_sign((Key const   *)server_host_key, & signature, & slen, (u_char const   *)hash,
             hashlen);
  }
#line 132
  packet_start((unsigned char)31);
#line 133
  packet_put_string((void const   *)server_host_key_blob, sbloblen);
#line 134
  packet_put_bignum2(dh->pub_key);
#line 135
  packet_put_string((void const   *)signature, slen);
#line 136
  packet_send();
#line 138
  xfree((void *)signature);
#line 139
  xfree((void *)server_host_key_blob);
#line 141
  DH_free(dh);
#line 143
  kex_derive_keys(kex, hash, hashlen, shared_secret);
#line 144
  BN_clear_free(shared_secret);
#line 145
  kex_finish(kex);
#line 146
  return;
}
}
#line 1 "kexgexs.o"
#line 39 "kexgexs.c"
void kexgex_server(Kex *kex ) 
{ BIGNUM *shared_secret ;
  BIGNUM *dh_client_pub ;
  Key *server_host_key ;
  DH *dh ;
  u_char *kbuf ;
  u_char *hash ;
  u_char *signature ;
  u_char *server_host_key_blob ;
  u_int sbloblen ;
  u_int klen ;
  u_int kout ;
  u_int slen ;
  u_int hashlen ;
  int min ;
  int max ;
  int nbits ;
  int type ;
  u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  int _len ;
  int tmp___3 ;
  int _len___0 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  u_int tmp___11 ;
  void *tmp___12 ;
  u_int tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;

  {
#line 42
  shared_secret = (BIGNUM *)((void *)0);
#line 42
  dh_client_pub = (BIGNUM *)((void *)0);
#line 45
  signature = (u_char *)((void *)0);
#line 45
  server_host_key_blob = (u_char *)((void *)0);
#line 47
  min = -1;
#line 47
  max = -1;
#line 47
  nbits = -1;
#line 49
  if ((unsigned int )kex->load_host_key == (unsigned int )((void *)0)) {
#line 50
    fatal("Cannot load hostkey");
  }
#line 51
  server_host_key = (*(kex->load_host_key))(kex->hostkey_type);
#line 52
  if ((unsigned int )server_host_key == (unsigned int )((void *)0)) {
#line 53
    fatal("Unsupported hostkey type %d", kex->hostkey_type);
  }
#line 55
  type = packet_read();
#line 56
  switch (type) {
  case 34: 
#line 58
  debug("SSH2_MSG_KEX_DH_GEX_REQUEST received");
#line 59
  tmp = packet_get_int();
#line 59
  min = (int )tmp;
#line 60
  tmp___0 = packet_get_int();
#line 60
  nbits = (int )tmp___0;
#line 61
  tmp___1 = packet_get_int();
#line 61
  max = (int )tmp___1;
#line 62
  if (1024 > min) {
#line 62
    min = 1024;
  } else {
#line 62
    min = min;
  }
#line 63
  if (8192 < max) {
#line 63
    max = 8192;
  } else {
#line 63
    max = max;
  }
#line 64
  break;
  case 30: 
#line 66
  debug("SSH2_MSG_KEX_DH_GEX_REQUEST_OLD received");
#line 67
  tmp___2 = packet_get_int();
#line 67
  nbits = (int )tmp___2;
#line 68
  min = 1024;
#line 69
  max = 8192;
#line 71
  break;
  default: 
#line 73
  fatal("protocol error during kex, no DH_GEX_REQUEST: %d", type);
  }
#line 75
  while (1) {
#line 75
    tmp___3 = packet_remaining();
#line 75
    _len = tmp___3;
#line 75
    if (_len > 0) {
#line 75
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kexgexs.c",
            75);
#line 75
      packet_disconnect("Packet integrity error.");
    }
#line 75
    break;
  }
#line 77
  if (max < min) {
#line 78
    fatal("DH_GEX_REQUEST, bad parameters: %d !< %d !< %d", min, nbits, max);
  } else {
#line 77
    if (nbits < min) {
#line 78
      fatal("DH_GEX_REQUEST, bad parameters: %d !< %d !< %d", min, nbits, max);
    } else {
#line 77
      if (max < nbits) {
#line 78
        fatal("DH_GEX_REQUEST, bad parameters: %d !< %d !< %d", min, nbits, max);
      }
    }
  }
#line 82
  if (use_privsep) {
#line 82
    dh = mm_choose_dh(min, nbits, max);
  } else {
#line 82
    dh = choose_dh(min, nbits, max);
  }
#line 83
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 84
    packet_disconnect("Protocol error: no matching DH grp found");
  }
#line 86
  debug("SSH2_MSG_KEX_DH_GEX_GROUP sent");
#line 87
  packet_start((unsigned char)31);
#line 88
  packet_put_bignum2(dh->p);
#line 89
  packet_put_bignum2(dh->g);
#line 90
  packet_send();
#line 93
  packet_write_wait();
#line 96
  dh_gen_key(dh, (int )(kex->we_need * 8U));
#line 98
  debug("expecting SSH2_MSG_KEX_DH_GEX_INIT");
#line 99
  packet_read_expect(32);
#line 102
  dh_client_pub = BN_new();
#line 102
  if ((unsigned int )dh_client_pub == (unsigned int )((void *)0)) {
#line 103
    fatal("dh_client_pub == NULL");
  }
#line 104
  packet_get_bignum2(dh_client_pub);
#line 105
  while (1) {
#line 105
    tmp___6 = packet_remaining();
#line 105
    _len___0 = tmp___6;
#line 105
    if (_len___0 > 0) {
#line 105
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "kexgexs.c",
            105);
#line 105
      packet_disconnect("Packet integrity error.");
    }
#line 105
    break;
  }
#line 120
  tmp___7 = dh_pub_is_valid(dh, dh_client_pub);
#line 120
  if (! tmp___7) {
#line 121
    packet_disconnect("bad client public DH value");
  }
#line 123
  tmp___8 = DH_size((DH const   *)dh);
#line 123
  klen = (unsigned int )tmp___8;
#line 124
  tmp___9 = xmalloc(klen);
#line 124
  kbuf = (u_char *)tmp___9;
#line 125
  tmp___10 = DH_compute_key(kbuf, (BIGNUM const   *)dh_client_pub, dh);
#line 125
  kout = (unsigned int )tmp___10;
#line 129
  shared_secret = BN_new();
#line 129
  if ((unsigned int )shared_secret == (unsigned int )((void *)0)) {
#line 130
    fatal("kexgex_server: BN_new failed");
  }
#line 131
  BN_bin2bn((unsigned char const   *)kbuf, (int )kout, shared_secret);
#line 132
  memset((void *)kbuf, 0, klen);
#line 133
  xfree((void *)kbuf);
#line 135
  key_to_blob((Key const   *)server_host_key, & server_host_key_blob, & sbloblen);
#line 137
  if (type == 30) {
#line 138
    max = -1;
#line 138
    min = max;
  }
#line 141
  tmp___11 = buffer_len(& kex->my);
#line 141
  tmp___12 = buffer_ptr(& kex->my);
#line 141
  tmp___13 = buffer_len(& kex->peer);
#line 141
  tmp___14 = buffer_ptr(& kex->peer);
#line 141
  kexgex_hash(kex->evp_md, kex->client_version_string, kex->server_version_string,
              (char *)tmp___14, (int )tmp___13, (char *)tmp___12, (int )tmp___11,
              server_host_key_blob, (int )sbloblen, min, nbits, max, dh->p, dh->g,
              dh_client_pub, dh->pub_key, shared_secret, & hash, & hashlen);
#line 155
  BN_clear_free(dh_client_pub);
#line 158
  if ((unsigned int )kex->session_id == (unsigned int )((void *)0)) {
#line 159
    kex->session_id_len = hashlen;
#line 160
    tmp___15 = xmalloc(kex->session_id_len);
#line 160
    kex->session_id = (u_char *)tmp___15;
#line 161
    memcpy((void * __restrict  )kex->session_id, (void const   * __restrict  )hash,
           kex->session_id_len);
  }
#line 165
  if (use_privsep) {
#line 165
    mm_key_sign(server_host_key, & signature, & slen, hash, hashlen);
  } else {
#line 165
    key_sign((Key const   *)server_host_key, & signature, & slen, (u_char const   *)hash,
             hashlen);
  }
#line 170
  debug("SSH2_MSG_KEX_DH_GEX_REPLY sent");
#line 171
  packet_start((unsigned char)33);
#line 172
  packet_put_string((void const   *)server_host_key_blob, sbloblen);
#line 173
  packet_put_bignum2(dh->pub_key);
#line 174
  packet_put_string((void const   *)signature, slen);
#line 175
  packet_send();
#line 177
  xfree((void *)signature);
#line 178
  xfree((void *)server_host_key_blob);
#line 180
  DH_free(dh);
#line 182
  kex_derive_keys(kex, hash, hashlen, shared_secret);
#line 183
  BN_clear_free(shared_secret);
#line 185
  kex_finish(kex);
#line 186
  return;
}
}
#line 1 "auth-krb5.o"
#line 1 "auth2-gss.o"
#line 1 "gss-serv.o"
#line 1 "gss-serv-krb5.o"
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned int  ) ;  */
#line 1 "loginrec.o"
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 218
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64") __attribute__((__nonnull__(2))) ;
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval * __restrict  __tv ,
                                                      __timezone_ptr_t __tz )  __attribute__((__nonnull__(1))) ;
#line 46 "/usr/include/utmp.h"
extern  __attribute__((__nothrow__)) void login(struct utmp  const  *__entry ) ;
#line 49
extern  __attribute__((__nothrow__)) int logout(char const   *__ut_line ) ;
#line 52
extern  __attribute__((__nothrow__)) void logwtmp(char const   *__ut_line , char const   *__ut_name ,
                                                  char const   *__ut_host ) ;
#line 100 "loginrec.h"
int login_init_entry(struct logininfo *li , int pid , char const   *username , char const   *hostname ,
                     char const   *line ) ;
#line 103
void login_set_current_time(struct logininfo *li ) ;
#line 115
int login_write(struct logininfo *li ) ;
#line 128
unsigned int login_get_lastlog_time(int uid ) ;
#line 131
char *line_fullname(char *dst , char const   *src , u_int dstsize ) ;
#line 132
char *line_stripname(char *dst , char const   *src , int dstsize ) ;
#line 133
char *line_abbrevname(char *dst , char const   *src , int dstsize ) ;
#line 175 "loginrec.c"
void set_utmp_time(struct logininfo *li , struct utmp *ut ) ;
#line 176
void construct_utmp(struct logininfo *li , struct utmp *ut ) ;
#line 188
int lastlog_write_entry(struct logininfo *li ) ;
#line 189
int syslogin_write_entry(struct logininfo *li ) ;
#line 191
int getlast_entry(struct logininfo *li ) ;
#line 192
int lastlog_get_entry(struct logininfo *li ) ;
#line 215 "loginrec.c"
int login_login(struct logininfo *li ) 
{ int tmp ;

  {
#line 218
  li->type = (short)7;
#line 219
  tmp = login_write(li);
#line 219
  return (tmp);
}
}
#line 232 "loginrec.c"
int login_logout(struct logininfo *li ) 
{ int tmp ;

  {
#line 235
  li->type = (short)8;
#line 236
  tmp = login_write(li);
#line 236
  return (tmp);
}
}
#line 257 "loginrec.c"
unsigned int login_get_lastlog_time(int uid ) 
{ struct logininfo li ;
  struct logininfo *tmp ;

  {
#line 262
  tmp = login_get_lastlog(& li, uid);
#line 262
  if (tmp) {
#line 263
    return (li.tv_sec);
  } else {
#line 265
    return (0U);
  }
}
}
#line 281 "loginrec.c"
struct logininfo *login_get_lastlog(struct logininfo *li , int uid ) 
{ struct passwd *pw ;
  int tmp ;

  {
#line 286
  memset((void *)li, '\000', sizeof(*li));
#line 287
  li->uid = uid;
#line 294
  pw = getpwuid((unsigned int )uid);
#line 295
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 296
    fatal("%s: Cannot find account for uid %i", "login_get_lastlog", uid);
  }
#line 300
  strlcpy(li->username, (char const   *)pw->pw_name, sizeof(li->username));
#line 302
  tmp = getlast_entry(li);
#line 302
  if (tmp) {
#line 303
    return (li);
  } else {
#line 305
    return ((struct logininfo *)((void *)0));
  }
}
}
#line 319 "loginrec.c"
struct logininfo *login_alloc_entry(int pid , char const   *username , char const   *hostname ,
                                    char const   *line ) 
{ struct logininfo *newli ;
  void *tmp ;

  {
#line 325
  tmp = xmalloc(sizeof(*newli));
#line 325
  newli = (struct logininfo *)tmp;
#line 326
  login_init_entry(newli, pid, username, hostname, line);
#line 327
  return (newli);
}
}
#line 332 "loginrec.c"
void login_free_entry(struct logininfo *li ) 
{ 

  {
#line 335
  xfree((void *)li);
#line 336
  return;
}
}
#line 347 "loginrec.c"
int login_init_entry(struct logininfo *li , int pid , char const   *username , char const   *hostname ,
                     char const   *line ) 
{ struct passwd *pw ;

  {
#line 353
  memset((void *)li, 0, sizeof(*li));
#line 355
  li->pid = pid;
#line 358
  if (line) {
#line 359
    line_fullname(li->line, line, sizeof(li->line));
  }
#line 361
  if (username) {
#line 362
    strlcpy(li->username, username, sizeof(li->username));
#line 363
    pw = getpwnam((char const   *)(li->username));
#line 364
    if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 365
      fatal("%s: Cannot find user \"%s\"", "login_init_entry", li->username);
    }
#line 368
    li->uid = (int )pw->pw_uid;
  }
#line 371
  if (hostname) {
#line 372
    strlcpy(li->hostname, hostname, sizeof(li->hostname));
  }
#line 374
  return (1);
}
}
#line 384 "loginrec.c"
void login_set_current_time(struct logininfo *li ) 
{ struct timeval tv ;

  {
#line 389
  gettimeofday((struct timeval * __restrict  )(& tv), (struct timezone * __restrict  )((void *)0));
#line 391
  li->tv_sec = (unsigned int )tv.tv_sec;
#line 392
  li->tv_usec = (unsigned int )tv.tv_usec;
#line 393
  return;
}
}
#line 396 "loginrec.c"
void login_set_addr(struct logininfo *li , struct sockaddr  const  *sa , unsigned int sa_size ) 
{ unsigned int bufsize ;

  {
#line 400
  bufsize = sa_size;
#line 403
  if (sizeof(li->hostaddr) < sa_size) {
#line 404
    bufsize = sizeof(li->hostaddr);
  }
#line 406
  memcpy((void * __restrict  )(& li->hostaddr.sa), (void const   * __restrict  )sa,
         bufsize);
#line 407
  return;
}
}
#line 414 "loginrec.c"
int login_write(struct logininfo *li ) 
{ __uid_t tmp ;

  {
#line 418
  tmp = geteuid();
#line 418
  if (tmp != 0U) {
#line 419
    logit("Attempt to write login records by non-root user (aborting)");
#line 420
    return (1);
  }
#line 425
  login_set_current_time(li);
#line 427
  syslogin_write_entry(li);
#line 430
  if ((int )li->type == 7) {
#line 431
    lastlog_write_entry(li);
  }
#line 457
  return (0);
}
}
#line 488 "loginrec.c"
int getlast_entry(struct logininfo *li ) 
{ int tmp ;

  {
#line 492
  tmp = lastlog_get_entry(li);
#line 492
  return (tmp);
}
}
#line 537 "loginrec.c"
char *line_fullname(char *dst , char const   *src , u_int dstsize ) 
{ int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  size_t tmp___25 ;

  {
#line 540
  memset((void *)dst, '\000', dstsize);
#line 541
  if (0) {
#line 541
    if (0) {
#line 541
      __s1_len___0 = strlen(src);
#line 541
      __s2_len___0 = strlen("/dev/");
#line 541
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 541
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 541
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 541
            tmp___22 = 1;
          } else {
#line 541
            if (__s2_len___0 >= 4U) {
#line 541
              tmp___22 = 1;
            } else {
#line 541
              tmp___22 = 0;
            }
          }
        } else {
#line 541
          tmp___22 = 0;
        }
      }
#line 541
      if (tmp___22) {
#line 541
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 541
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 541
        tmp___18 = tmp___21;
      }
    } else {
#line 541
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 541
      tmp___18 = tmp___21;
    }
#line 541
    tmp___12 = tmp___18;
  } else {
#line 541
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 541
  if (tmp___12 == 0) {
#line 542
    strlcpy(dst, src, dstsize);
  } else {
#line 541
    tmp___25 = strlen(src);
#line 541
    if (dstsize < tmp___25 + 5U) {
#line 542
      strlcpy(dst, src, dstsize);
    } else {
#line 544
      strlcpy(dst, "/dev/", dstsize);
#line 545
      strlcat(dst, src, dstsize);
    }
  }
#line 547
  return (dst);
}
}
#line 551 "loginrec.c"
char *line_stripname(char *dst , char const   *src , int dstsize ) 
{ int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 554
  memset((void *)dst, '\000', (unsigned int )dstsize);
#line 555
  if (0) {
#line 555
    if (0) {
#line 555
      __s1_len___0 = strlen(src);
#line 555
      __s2_len___0 = strlen("/dev/");
#line 555
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 555
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 555
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 555
            tmp___22 = 1;
          } else {
#line 555
            if (__s2_len___0 >= 4U) {
#line 555
              tmp___22 = 1;
            } else {
#line 555
              tmp___22 = 0;
            }
          }
        } else {
#line 555
          tmp___22 = 0;
        }
      }
#line 555
      if (tmp___22) {
#line 555
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 555
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 555
        tmp___18 = tmp___21;
      }
    } else {
#line 555
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 555
      tmp___18 = tmp___21;
    }
#line 555
    tmp___12 = tmp___18;
  } else {
#line 555
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 555
  if (tmp___12 == 0) {
#line 556
    strlcpy(dst, src + 5, (unsigned int )dstsize);
  } else {
#line 558
    strlcpy(dst, src, (unsigned int )dstsize);
  }
#line 559
  return (dst);
}
}
#line 570 "loginrec.c"
char *line_abbrevname(char *dst , char const   *src , int dstsize ) 
{ size_t len ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 575
  memset((void *)dst, '\000', (unsigned int )dstsize);
#line 578
  if (0) {
#line 578
    if (0) {
#line 578
      __s1_len___0 = strlen(src);
#line 578
      __s2_len___0 = strlen("/dev/");
#line 578
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 578
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 578
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 578
            tmp___22 = 1;
          } else {
#line 578
            if (__s2_len___0 >= 4U) {
#line 578
              tmp___22 = 1;
            } else {
#line 578
              tmp___22 = 0;
            }
          }
        } else {
#line 578
          tmp___22 = 0;
        }
      }
#line 578
      if (tmp___22) {
#line 578
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 578
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 578
        tmp___18 = tmp___21;
      }
    } else {
#line 578
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 578
      tmp___18 = tmp___21;
    }
#line 578
    tmp___12 = tmp___18;
  } else {
#line 578
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 578
  if (tmp___12 == 0) {
#line 579
    src += 5;
  }
#line 586
  len = strlen(src);
#line 588
  if (len > 0U) {
#line 589
    if ((int )len - dstsize > 0) {
#line 590
      src += (int )len - dstsize;
    }
#line 593
    __builtin_strncpy(dst, src, (unsigned int )dstsize);
  }
#line 596
  return (dst);
}
}
#line 609 "loginrec.c"
void set_utmp_time(struct logininfo *li , struct utmp *ut ) 
{ 

  {
#line 613
  ut->ut_tv.tv_sec = (long )li->tv_sec;
#line 614
  ut->ut_tv.tv_usec = (long )li->tv_usec;
#line 618
  return;
}
}
#line 620 "loginrec.c"
void construct_utmp(struct logininfo *li , struct utmp *ut ) 
{ struct sockaddr_in6 *sa6 ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  register unsigned int __v ;
  register unsigned int __x ;

  {
#line 628
  memset((void *)ut, '\000', sizeof(*ut));
#line 633
  line_abbrevname(ut->ut_id, (char const   *)(li->line), (int )sizeof(ut->ut_id));
#line 638
  switch ((int )li->type) {
  case 7: 
#line 640
  ut->ut_type = (short)7;
#line 644
  break;
  case 8: 
#line 646
  ut->ut_type = (short)8;
#line 650
  break;
  }
#line 653
  set_utmp_time(li, ut);
#line 655
  line_stripname(ut->ut_line, (char const   *)(li->line), (int )sizeof(ut->ut_line));
#line 658
  ut->ut_pid = li->pid;
#line 662
  if ((int )li->type == 8) {
#line 663
    return;
  }
#line 671
  if (sizeof(ut->ut_user) < sizeof(li->username)) {
#line 671
    tmp = sizeof(ut->ut_user);
  } else {
#line 671
    tmp = sizeof(li->username);
  }
#line 671
  __builtin_strncpy(ut->ut_user, (char const   *)(li->username), tmp);
#line 674
  if (sizeof(ut->ut_host) < sizeof(li->hostname)) {
#line 674
    tmp___0 = sizeof(ut->ut_host);
  } else {
#line 674
    tmp___0 = sizeof(li->hostname);
  }
#line 674
  __builtin_strncpy(ut->ut_host, (char const   *)(li->hostname), tmp___0);
#line 679
  if ((int )li->hostaddr.sa.sa_family == 2) {
#line 680
    ut->ut_addr_v6[0] = (int )li->hostaddr.sa_in.sin_addr.s_addr;
  }
#line 684
  if ((int )li->hostaddr.sa.sa_family == 10) {
#line 685
    sa6 = (struct sockaddr_in6 *)(& li->hostaddr.sa);
#line 686
    memcpy((void * __restrict  )(ut->ut_addr_v6), (void const   * __restrict  )(sa6->sin6_addr.in6_u.u6_addr8),
           16U);
#line 687
    if (*((uint32_t const   *)(& sa6->sin6_addr) + 0) == 0U) {
#line 687
      if (*((uint32_t const   *)(& sa6->sin6_addr) + 1) == 0U) {
#line 687
        __x = 65535U;
#line 687
        __asm__  ("rorw $8, %w0;"
                  "rorl $16, %0;"
                  "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 687
        if (*((uint32_t const   *)(& sa6->sin6_addr) + 2) == (uint32_t const   )__v) {
#line 688
          ut->ut_addr_v6[0] = ut->ut_addr_v6[3];
#line 689
          ut->ut_addr_v6[1] = 0;
#line 690
          ut->ut_addr_v6[2] = 0;
#line 691
          ut->ut_addr_v6[3] = 0;
        }
      }
    }
  }
#line 695
  return;
}
}
#line 1385 "loginrec.c"
static int syslogin_perform_login(struct logininfo *li ) 
{ struct utmp *ut ;
  void *tmp ;

  {
#line 1390
  tmp = xmalloc(sizeof(*ut));
#line 1390
  ut = (struct utmp *)tmp;
#line 1391
  construct_utmp(li, ut);
#line 1392
  login((struct utmp  const  *)ut);
#line 1393
  free((void *)ut);
#line 1395
  return (1);
}
}
#line 1398 "loginrec.c"
static int syslogin_perform_logout(struct logininfo *li ) 
{ char line[32] ;
  int tmp ;

  {
#line 1404
  line_stripname(line, (char const   *)(li->line), (int )sizeof(line));
#line 1406
  tmp = logout((char const   *)(line));
#line 1406
  if (tmp) {
#line 1410
    logwtmp((char const   *)(line), "", "");
  } else {
#line 1407
    logit("%s: logout() returned an error", "syslogin_perform_logout");
  }
#line 1417
  return (1);
}
}
#line 1420 "loginrec.c"
int syslogin_write_entry(struct logininfo *li ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 1423
  switch ((int )li->type) {
  case 7: 
#line 1425
  tmp = syslogin_perform_login(li);
#line 1425
  return (tmp);
  case 8: 
#line 1427
  tmp___0 = syslogin_perform_logout(li);
#line 1427
  return (tmp___0);
  default: 
#line 1429
  logit("%s: Invalid type field", "syslogin_write_entry");
#line 1430
  return (0);
  }
}
}
#line 1446 "loginrec.c"
static void lastlog_construct(struct logininfo *li , struct lastlog *last ) 
{ unsigned int tmp ;

  {
#line 1450
  memset((void *)last, '\000', sizeof(*last));
#line 1452
  line_stripname(last->ll_line, (char const   *)(li->line), (int )sizeof(last->ll_line));
#line 1453
  if (sizeof(last->ll_host) < sizeof(li->hostname)) {
#line 1453
    tmp = sizeof(last->ll_host);
  } else {
#line 1453
    tmp = sizeof(li->hostname);
  }
#line 1453
  strlcpy(last->ll_host, (char const   *)(li->hostname), tmp);
#line 1455
  last->ll_time = (long )li->tv_sec;
#line 1456
  return;
}
}
#line 1458 "loginrec.c"
static int lastlog_filetype(char *filename ) 
{ struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1463
  tmp___1 = stat((char const   * __restrict  )"/var/log/lastlog", (struct stat * __restrict  )(& st));
#line 1463
  if (tmp___1 != 0) {
#line 1464
    tmp = __errno_location();
#line 1464
    tmp___0 = strerror(*tmp);
#line 1464
    logit("%s: Couldn\'t stat %s: %s", "lastlog_filetype", "/var/log/lastlog", tmp___0);
#line 1466
    return (0);
  }
#line 1468
  if ((st.st_mode & 61440U) == 16384U) {
#line 1469
    return (2);
  } else {
#line 1470
    if ((st.st_mode & 61440U) == 32768U) {
#line 1471
      return (1);
    } else {
#line 1473
      return (3);
    }
  }
}
}
#line 1478 "loginrec.c"
static int lastlog_openseek(struct logininfo *li , int *fd , int filemode ) 
{ off_t offset ;
  int type ;
  char lastlog_file[1024] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  __off64_t tmp___3 ;

  {
#line 1485
  type = lastlog_filetype((char *)"/var/log/lastlog");
#line 1486
  switch (type) {
  case 1: 
#line 1488
  strlcpy(lastlog_file, "/var/log/lastlog", sizeof(lastlog_file));
#line 1490
  break;
  case 2: 
#line 1492
  snprintf((char * __restrict  )(lastlog_file), sizeof(lastlog_file), (char const   * __restrict  )"%s/%s",
           "/var/log/lastlog", li->username);
#line 1494
  break;
  default: 
#line 1496
  logit("%s: %.100s is not a file or directory!", "lastlog_openseek", "/var/log/lastlog");
#line 1498
  return (0);
  }
#line 1501
  *fd = open((char const   *)(lastlog_file), filemode, 384);
#line 1502
  if (*fd < 0) {
#line 1503
    tmp = __errno_location();
#line 1503
    tmp___0 = strerror(*tmp);
#line 1503
    debug("%s: Couldn\'t open %s: %s", "lastlog_openseek", lastlog_file, tmp___0);
#line 1505
    return (0);
  }
#line 1508
  if (type == 1) {
#line 1510
    offset = (long long )((unsigned long )((long )li->uid) * (unsigned long )sizeof(struct lastlog ));
#line 1512
    tmp___3 = lseek(*fd, offset, 0);
#line 1512
    if (tmp___3 != offset) {
#line 1513
      tmp___1 = __errno_location();
#line 1513
      tmp___2 = strerror(*tmp___1);
#line 1513
      logit("%s: %s->lseek(): %s", "lastlog_openseek", lastlog_file, tmp___2);
#line 1515
      return (0);
    }
  }
#line 1519
  return (1);
}
}
#line 1522 "loginrec.c"
static int lastlog_perform_login(struct logininfo *li ) 
{ struct lastlog last ;
  int fd ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;

  {
#line 1529
  lastlog_construct(li, & last);
#line 1531
  tmp = lastlog_openseek(li, & fd, 66);
#line 1531
  if (! tmp) {
#line 1532
    return (0);
  }
#line 1535
  tmp___2 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), fd, (void *)(& last),
                     sizeof(last));
#line 1535
  if (tmp___2 != sizeof(last)) {
#line 1536
    close(fd);
#line 1537
    tmp___0 = __errno_location();
#line 1537
    tmp___1 = strerror(*tmp___0);
#line 1537
    logit("%s: Error writing to %s: %s", "lastlog_perform_login", "/var/log/lastlog",
          tmp___1);
#line 1539
    return (0);
  }
#line 1542
  close(fd);
#line 1543
  return (1);
}
}
#line 1546 "loginrec.c"
int lastlog_write_entry(struct logininfo *li ) 
{ int tmp ;

  {
#line 1549
  switch ((int )li->type) {
  case 7: 
#line 1551
  tmp = lastlog_perform_login(li);
#line 1551
  return (tmp);
  default: 
#line 1553
  logit("%s: Invalid type field", "lastlog_write_entry");
#line 1554
  return (0);
  }
}
}
#line 1558 "loginrec.c"
static void lastlog_populate_entry(struct logininfo *li , struct lastlog *last ) 
{ unsigned int tmp ;

  {
#line 1561
  line_fullname(li->line, (char const   *)(last->ll_line), sizeof(li->line));
#line 1562
  if (sizeof(li->hostname) < sizeof(last->ll_host)) {
#line 1562
    tmp = sizeof(li->hostname);
  } else {
#line 1562
    tmp = sizeof(last->ll_host);
  }
#line 1562
  strlcpy(li->hostname, (char const   *)(last->ll_host), tmp);
#line 1564
  li->tv_sec = (unsigned int )last->ll_time;
#line 1565
  return;
}
}
#line 1567 "loginrec.c"
int lastlog_get_entry(struct logininfo *li ) 
{ struct lastlog last ;
  int fd ;
  int ret ;
  int tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
#line 1573
  tmp = lastlog_openseek(li, & fd, 0);
#line 1573
  if (! tmp) {
#line 1574
    return (0);
  }
#line 1576
  tmp___0 = atomicio(& read, fd, (void *)(& last), sizeof(last));
#line 1576
  ret = (int )tmp___0;
#line 1577
  close(fd);
#line 1579
  switch (ret) {
  case 0: 
#line 1581
  memset((void *)(& last), '\000', sizeof(last));
  case sizeof(last): 
#line 1584
  lastlog_populate_entry(li, & last);
#line 1585
  return (1);
  case -1: 
#line 1587
  tmp___1 = __errno_location();
#line 1587
  tmp___2 = strerror(*tmp___1);
#line 1587
  error("%s: Error reading from %s: %s", "lastlog_get_entry", "/var/log/lastlog",
        tmp___2);
#line 1589
  return (0);
  default: 
#line 1591
  error("%s: Error reading from %s: Expecting %d, got %d", "lastlog_get_entry", "/var/log/lastlog",
        (int )sizeof(last), ret);
#line 1593
  return (0);
  }
#line 1597
  return (0);
}
}
#line 1609 "loginrec.c"
void record_failed_login(char const   *username , char const   *hostname , char const   *ttyn ) 
{ int fd ;
  struct utmp ut ;
  struct sockaddr_storage from ;
  socklen_t fromlen ;
  struct sockaddr_in *a4 ;
  struct sockaddr_in6 *a6 ;
  time_t t ;
  struct stat fst ;
  __uid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;

  {
#line 1616
  fromlen = sizeof(from);
#line 1622
  tmp = geteuid();
#line 1622
  if (tmp != 0U) {
#line 1623
    return;
  }
#line 1624
  fd = open("/var/log/btmp", 1025);
#line 1624
  if (fd < 0) {
#line 1625
    tmp___0 = __errno_location();
#line 1625
    tmp___1 = strerror(*tmp___0);
#line 1625
    debug("Unable to open the btmp file %s: %s", "/var/log/btmp", tmp___1);
#line 1627
    return;
  }
#line 1629
  tmp___4 = fstat(fd, & fst);
#line 1629
  if (tmp___4 < 0) {
#line 1630
    tmp___2 = __errno_location();
#line 1630
    tmp___3 = strerror(*tmp___2);
#line 1630
    logit("%s: fstat of %s failed: %s", "record_failed_login", "/var/log/btmp", tmp___3);
    goto out;
  }
#line 1634
  if (fst.st_mode & (unsigned int )((448 >> 3) | ((448 >> 3) >> 3))) {
#line 1635
    logit("Excess permission or bad ownership on file %s", "/var/log/btmp");
    goto out;
  } else {
#line 1634
    if (fst.st_uid != 0U) {
#line 1635
      logit("Excess permission or bad ownership on file %s", "/var/log/btmp");
      goto out;
    }
  }
#line 1640
  memset((void *)(& ut), 0, sizeof(ut));
#line 1642
  __builtin_strncpy(ut.ut_user, username, sizeof(ut.ut_user));
#line 1643
  strlcpy(ut.ut_line, "ssh:notty", sizeof(ut.ut_line));
#line 1645
  time(& t);
#line 1646
  ut.ut_tv.tv_sec = t;
#line 1647
  ut.ut_type = (short)6;
#line 1648
  ut.ut_pid = getpid();
#line 1651
  __builtin_strncpy(ut.ut_host, hostname, sizeof(ut.ut_host));
#line 1653
  tmp___7 = packet_connection_is_on_socket();
#line 1653
  if (tmp___7) {
#line 1653
    tmp___8 = packet_get_connection_in();
#line 1653
    tmp___9 = getpeername(tmp___8, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 1653
    if (tmp___9 == 0) {
#line 1656
      ipv64_normalise_mapped(& from, & fromlen);
#line 1657
      if ((int )from.ss_family == 2) {
#line 1658
        a4 = (struct sockaddr_in *)(& from);
#line 1659
        if (sizeof(ut.ut_addr_v6[0]) < sizeof(a4->sin_addr)) {
#line 1659
          tmp___5 = sizeof(ut.ut_addr_v6[0]);
        } else {
#line 1659
          tmp___5 = sizeof(a4->sin_addr);
        }
#line 1659
        memcpy((void * __restrict  )(& ut.ut_addr_v6[0]), (void const   * __restrict  )(& a4->sin_addr),
               tmp___5);
      }
#line 1663
      if ((int )from.ss_family == 10) {
#line 1664
        a6 = (struct sockaddr_in6 *)(& from);
#line 1665
        if (sizeof(ut.ut_addr_v6) < sizeof(a6->sin6_addr)) {
#line 1665
          tmp___6 = sizeof(ut.ut_addr_v6);
        } else {
#line 1665
          tmp___6 = sizeof(a6->sin6_addr);
        }
#line 1665
        memcpy((void * __restrict  )(& ut.ut_addr_v6), (void const   * __restrict  )(& a6->sin6_addr),
               tmp___6);
      }
    }
  }
#line 1671
  tmp___12 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), fd, (void *)(& ut),
                      sizeof(ut));
#line 1671
  if (tmp___12 != sizeof(ut)) {
#line 1672
    tmp___10 = __errno_location();
#line 1672
    tmp___11 = strerror(*tmp___10);
#line 1672
    error("Failed to write to %s: %s", "/var/log/btmp", tmp___11);
  }
  out: 
#line 1676
  close(fd);
#line 1677
  return;
}
}
#line 1 "auth-pam.o"
#line 1 "auth-shadow.o"
#line 51 "auth-shadow.c"
int auth_shadow_acctexpired(struct spwd *spw ) 
{ time_t today ;
  int daysleft ;
  char buf___1[256] ;
  time_t tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;

  {
#line 58
  tmp = time((time_t *)((void *)0));
#line 58
  today = tmp / 86400L;
#line 59
  daysleft = (int )(spw->sp_expire - today);
#line 60
  debug3("%s: today %d sp_expire %d days left %d", "auth_shadow_acctexpired", (int )today,
         (int )spw->sp_expire, daysleft);
#line 63
  if (spw->sp_expire == -1L) {
#line 64
    debug3("account expiration disabled");
  } else {
#line 65
    if (daysleft < 0) {
#line 66
      logit("Account %.100s has expired", spw->sp_namp);
#line 67
      return (1);
    } else {
#line 68
      if ((long )daysleft <= spw->sp_warn) {
#line 69
        debug3("account will expire in %d days", daysleft);
#line 70
        if (daysleft == 1) {
#line 70
          tmp___0 = "";
        } else {
#line 70
          tmp___0 = "s";
        }
#line 70
        snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"Your account will expire in %d day%s.\n",
                 daysleft, tmp___0);
#line 73
        tmp___1 = strlen((char const   *)(buf___1));
#line 73
        buffer_append(& loginmsg, (void const   *)(buf___1), tmp___1);
      }
    }
  }
#line 76
  return (0);
}
}
#line 83 "auth-shadow.c"
int auth_shadow_pwexpired(Authctxt *ctxt ) 
{ struct spwd *spw ;
  char const   *user ;
  char buf___1[256] ;
  time_t today ;
  int daysleft ;
  int disabled ;
  time_t tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;

  {
#line 86
  spw = (struct spwd *)((void *)0);
#line 87
  user = (char const   *)(ctxt->pw)->pw_name;
#line 90
  disabled = 0;
#line 92
  spw = getspnam((char const   *)((char *)user));
#line 92
  if ((unsigned int )spw == (unsigned int )((void *)0)) {
#line 93
    error("Could not get shadow information for %.100s", user);
#line 94
    return (0);
  }
#line 97
  tmp = time((time_t *)((void *)0));
#line 97
  today = tmp / 86400L;
#line 98
  debug3("%s: today %d sp_lstchg %d sp_max %d", "auth_shadow_pwexpired", (int )today,
         (int )spw->sp_lstchg, (int )spw->sp_max);
#line 117
  daysleft = (int )((spw->sp_lstchg + spw->sp_max) - today);
#line 118
  if (disabled) {
#line 119
    debug3("password expiration disabled");
  } else {
#line 120
    if (spw->sp_lstchg == 0L) {
#line 121
      logit("User %.100s password has expired (root forced)", user);
#line 122
      return (1);
    } else {
#line 123
      if (spw->sp_max == -1L) {
#line 124
        debug3("password expiration disabled");
      } else {
#line 125
        if (daysleft < 0) {
#line 126
          logit("User %.100s password has expired (password aged)", user);
#line 127
          return (1);
        } else {
#line 128
          if ((long )daysleft <= spw->sp_warn) {
#line 129
            debug3("password will expire in %d days", daysleft);
#line 130
            if (daysleft == 1) {
#line 130
              tmp___0 = "";
            } else {
#line 130
              tmp___0 = "s";
            }
#line 130
            snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"Your password will expire in %d day%s.\n",
                     daysleft, tmp___0);
#line 133
            tmp___1 = strlen((char const   *)(buf___1));
#line 133
            buffer_append(& loginmsg, (void const   *)(buf___1), tmp___1);
          }
        }
      }
    }
  }
#line 136
  return (0);
}
}
#line 1 "auth-sia.o"
#line 1 "md5crypt.o"
#line 1 "audit.o"
#line 1 "audit-bsm.o"
