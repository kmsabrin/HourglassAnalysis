/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

#line 214 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stddef.h"
typedef unsigned int size_t;
#line 183 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 195 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 36 "/usr/include/bits/socket.h"
typedef __socklen_t socklen_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 145 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 107 "/usr/include/openssl/ossl_typ.h"
struct bignum_st;
#line 107 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_st BIGNUM;
#line 108
struct bignum_ctx;
#line 108 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_ctx BN_CTX;
#line 109
struct bn_blinding_st;
#line 109 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_blinding_st BN_BLINDING;
#line 110
struct bn_mont_ctx_st;
#line 110 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_mont_ctx_st BN_MONT_CTX;
#line 112
struct bn_gencb_st;
#line 112 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_gencb_st BN_GENCB;
#line 128
struct rsa_st;
#line 128 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_st RSA;
#line 129
struct rsa_meth_st;
#line 129 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_meth_st RSA_METHOD;
#line 154
struct engine_st;
#line 154 "/usr/include/openssl/ossl_typ.h"
typedef struct engine_st ENGINE;
#line 165
struct crypto_ex_data_st;
#line 165 "/usr/include/openssl/ossl_typ.h"
typedef struct crypto_ex_data_st CRYPTO_EX_DATA;
#line 285 "/usr/include/openssl/bn.h"
struct bignum_st {
   unsigned long *d ;
   int top ;
   int dmax ;
   int neg ;
   int flags ;
};
#line 296 "/usr/include/openssl/bn.h"
struct bn_mont_ctx_st {
   int ri ;
   BIGNUM RR ;
   BIGNUM N ;
   BIGNUM Ni ;
   unsigned long n0 ;
   int flags ;
};
#line 320 "/usr/include/openssl/bn.h"
union __anonunion_cb_62 {
   void (*cb_1)(int  , int  , void * ) ;
   int (*cb_2)(int  , int  , BN_GENCB * ) ;
};
#line 320 "/usr/include/openssl/bn.h"
struct bn_gencb_st {
   unsigned int ver ;
   void *arg ;
   union __anonunion_cb_62 cb ;
};
#line 66 "/usr/include/openssl/stack.h"
struct stack_st {
   int num ;
   char **data ;
   int sorted ;
   int num_alloc ;
   int (*comp)(char const   * const  * , char const   * const  * ) ;
};
#line 66 "/usr/include/openssl/stack.h"
typedef struct stack_st STACK;
#line 283 "/usr/include/openssl/crypto.h"
struct crypto_ex_data_st {
   STACK *sk ;
   int dummy ;
};
#line 85 "/usr/include/openssl/rsa.h"
struct rsa_meth_st {
   char const   *name ;
   int (*rsa_pub_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_pub_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_priv_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_priv_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_mod_exp)(BIGNUM *r0 , BIGNUM const   *I , RSA *rsa , BN_CTX *ctx ) ;
   int (*bn_mod_exp)(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(RSA *rsa ) ;
   int (*finish)(RSA *rsa ) ;
   int flags ;
   char *app_data ;
   int (*rsa_sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
                   unsigned int *siglen , RSA const   *rsa ) ;
   int (*rsa_verify)(int dtype , unsigned char const   *m , unsigned int m_length ,
                     unsigned char *sigbuf , unsigned int siglen , RSA const   *rsa ) ;
   int (*rsa_keygen)(RSA *rsa , int bits , BIGNUM *e , BN_GENCB *cb ) ;
};
#line 128 "/usr/include/openssl/rsa.h"
struct rsa_st {
   int pad ;
   long version ;
   RSA_METHOD const   *meth ;
   ENGINE *engine ;
   BIGNUM *n ;
   BIGNUM *e ;
   BIGNUM *d ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *dmp1 ;
   BIGNUM *dmq1 ;
   BIGNUM *iqmp ;
   CRYPTO_EX_DATA ex_data ;
   int references ;
   int flags ;
   BN_MONT_CTX *_method_mod_n ;
   BN_MONT_CTX *_method_mod_p ;
   BN_MONT_CTX *_method_mod_q ;
   char *bignum_data ;
   BN_BLINDING *blinding ;
   BN_BLINDING *mt_blinding ;
};
#line 21 "buffer.h"
struct __anonstruct_Buffer_75 {
   char *buf ;
   unsigned int alloc ;
   unsigned int offset ;
   unsigned int end ;
};
#line 21 "buffer.h"
typedef struct __anonstruct_Buffer_75 Buffer;
#line 34 "authfd.h"
struct __anonstruct_AuthenticationConnection_76 {
   int fd ;
   Buffer packet ;
   Buffer identities ;
   int howmany ;
};
#line 34 "authfd.h"
typedef struct __anonstruct_AuthenticationConnection_76 AuthenticationConnection;
#line 59 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 144 "/usr/include/bits/types.h"
typedef long __off_t;
#line 145 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 177 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 183 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 268 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t )] ;
};
#line 59 "rc4.h"
struct __anonstruct_rc4_t_29 {
   unsigned int s[256] ;
   int i ;
   int j ;
};
#line 59 "rc4.h"
typedef struct __anonstruct_rc4_t_29 rc4_t;
#line 60 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 137 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 143 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 152 "/usr/include/bits/types.h"
typedef long __time_t;
#line 167 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 172 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 88 "/usr/include/sys/types.h"
typedef __off_t off_t;
#line 203 "/usr/include/sys/types.h"
typedef unsigned int u_int32_t;
#line 121 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 78 "/usr/include/openssl/des.h"
typedef unsigned char DES_cblock[8];
#line 83 "/usr/include/openssl/des.h"
union __anonunion_ks_64 {
   DES_cblock cblock ;
   unsigned long deslong[2] ;
};
#line 83 "/usr/include/openssl/des.h"
struct DES_ks {
   union __anonunion_ks_64 ks[16] ;
};
#line 83 "/usr/include/openssl/des.h"
typedef struct DES_ks DES_key_schedule;
#line 101 "/usr/include/openssl/blowfish.h"
struct bf_key_st {
   unsigned int P[18] ;
   unsigned int S[1024] ;
};
#line 33 "cipher.h"
struct __anonstruct_des3_69 {
   DES_key_schedule key1 ;
   DES_key_schedule key2 ;
   DES_cblock iv2 ;
   DES_key_schedule key3 ;
   DES_cblock iv3 ;
};
#line 33 "cipher.h"
struct __anonstruct_bf_70 {
   struct bf_key_st key ;
   unsigned char iv[8] ;
};
#line 33 "cipher.h"
union __anonunion_u_68 {
   struct __anonstruct_des3_69 des3 ;
   struct __anonstruct_bf_70 bf ;
};
#line 33 "cipher.h"
struct __anonstruct_CipherContext_67 {
   unsigned int type ;
   union __anonunion_u_68 u ;
};
#line 33 "cipher.h"
typedef struct __anonstruct_CipherContext_67 CipherContext;
#line 44 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 92 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 136 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 137 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 219 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 96 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 321 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 146 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024U / (8U * sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 357 "ssh.h"
enum __anonenum_SyslogFacility_74 {
    SYSLOG_FACILITY_DAEMON = 0,
    SYSLOG_FACILITY_USER = 1,
    SYSLOG_FACILITY_AUTH = 2,
    SYSLOG_FACILITY_LOCAL0 = 3,
    SYSLOG_FACILITY_LOCAL1 = 4,
    SYSLOG_FACILITY_LOCAL2 = 5,
    SYSLOG_FACILITY_LOCAL3 = 6,
    SYSLOG_FACILITY_LOCAL4 = 7,
    SYSLOG_FACILITY_LOCAL5 = 8,
    SYSLOG_FACILITY_LOCAL6 = 9,
    SYSLOG_FACILITY_LOCAL7 = 10
} ;
#line 357 "ssh.h"
typedef enum __anonenum_SyslogFacility_74 SyslogFacility;
#line 26 "servconf.h"
struct __anonstruct_ServerOptions_77 {
   int port ;
   struct in_addr listen_addr ;
   char *host_key_file ;
   int server_key_bits ;
   int login_grace_time ;
   int key_regeneration_time ;
   int permit_root_login ;
   int ignore_rhosts ;
   int quiet_mode ;
   int fascist_logging ;
   int print_motd ;
   int check_mail ;
   int x11_forwarding ;
   int x11_display_offset ;
   int strict_modes ;
   int keepalives ;
   SyslogFacility log_facility ;
   int rhosts_authentication ;
   int rhosts_rsa_authentication ;
   int rsa_authentication ;
   int password_authentication ;
   int permit_empty_passwd ;
   int use_login ;
   unsigned int num_allow_users ;
   char *allow_users[256] ;
   unsigned int num_deny_users ;
   char *deny_users[256] ;
   unsigned int num_allow_groups ;
   char *allow_groups[256] ;
   unsigned int num_deny_groups ;
   char *deny_groups[256] ;
};
#line 26 "servconf.h"
typedef struct __anonstruct_ServerOptions_77 ServerOptions;
#line 23 "channels.h"
struct Channel {
   int type ;
   int self ;
   int remote_id ;
   int istate ;
   int ostate ;
   int x11 ;
   int sock ;
   Buffer input ;
   Buffer output ;
   char path[200] ;
   int listening_port ;
   int host_port ;
   char *remote_name ;
};
#line 23 "channels.h"
typedef struct Channel Channel;
#line 72 "channels.c"
struct __anonstruct_ForwardPermission_78 {
   char *host ;
   int port ;
};
#line 72 "channels.c"
typedef struct __anonstruct_ForwardPermission_78 ForwardPermission;
#line 79 "/usr/include/openssl/des.h"
typedef unsigned char const_DES_cblock[8];
#line 101 "/usr/include/openssl/blowfish.h"
typedef struct bf_key_st BF_KEY;
#line 99 "/usr/include/openssl/md5.h"
struct MD5state_st {
   unsigned int A ;
   unsigned int B ;
   unsigned int C ;
   unsigned int D ;
   unsigned int Nl ;
   unsigned int Nh ;
   unsigned int data[16] ;
   unsigned int num ;
};
#line 99 "/usr/include/openssl/md5.h"
typedef struct MD5state_st MD5_CTX;
#line 85 "cipher.c"
union __anonunion_t_75 {
   u_int32_t i ;
   char c[4] ;
};
#line 261 "/usr/include/zconf.h"
typedef unsigned char Byte;
#line 263 "/usr/include/zconf.h"
typedef unsigned int uInt;
#line 264 "/usr/include/zconf.h"
typedef unsigned long uLong;
#line 270 "/usr/include/zconf.h"
typedef Byte Bytef;
#line 279 "/usr/include/zconf.h"
typedef void *voidpf;
#line 80 "/usr/include/zlib.h"
struct internal_state;
#line 82 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 82 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 103 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 1346 "/usr/include/zlib.h"
struct internal_state {
   int dummy ;
};
#line 202 "/usr/include/sys/types.h"
typedef unsigned short u_int16_t;
#line 311 "ssh.h"
enum __anonenum_HostStatus_73 {
    HOST_OK = 0,
    HOST_NEW = 1,
    HOST_CHANGED = 2
} ;
#line 311 "ssh.h"
typedef enum __anonenum_HostStatus_73 HostStatus;
#line 154 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 43 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 105 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 75 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 25 "/usr/include/bits/termios.h"
typedef unsigned char cc_t;
#line 26 "/usr/include/bits/termios.h"
typedef unsigned int speed_t;
#line 27 "/usr/include/bits/termios.h"
typedef unsigned int tcflag_t;
#line 30 "/usr/include/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 77 "/usr/include/time.h"
typedef __time_t time_t;
#line 314 "/usr/include/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 63 "/usr/include/sys/wait.h"
union wait;
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_terminated_40 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_stopped_41 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_40 __wait_terminated ;
   struct __anonstruct___wait_stopped_41 __wait_stopped ;
};
#line 43 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 557 "ssh.h"
struct envstring {
   struct envstring *next ;
   char *s ;
};
#line 105 "sshd.c"
struct __anonstruct_sensitive_data_77 {
   RSA *private_key ;
   RSA *host_key ;
};
#line 1844 "sshd.c"
struct pty_cleanup_context {
   char const   *ttyname ;
   int pid ;
};
#line 28 "/usr/include/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 141 "log-server.c"
struct fatal_cleanup {
   struct fatal_cleanup *next ;
   void (*proc)(void * ) ;
   void *context ;
};
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 38 "/usr/include/bits/utmp.h"
struct lastlog {
   __time_t ll_time ;
   char ll_line[32] ;
   char ll_host[256] ;
};
#line 52 "/usr/include/bits/utmp.h"
struct exit_status {
   short e_termination ;
   short e_exit ;
};
#line 60 "/usr/include/bits/utmp.h"
struct utmp {
   short ut_type ;
   pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct exit_status ut_exit ;
   long ut_session ;
   struct timeval ut_tv ;
   int32_t ut_addr_v6[4] ;
   char __unused[20] ;
};
#line 251 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 145 "servconf.c"
enum __anonenum_ServerOpCodes_76 {
    sPort = 0,
    sHostKeyFile = 1,
    sServerKeyBits = 2,
    sLoginGraceTime = 3,
    sKeyRegenerationTime = 4,
    sPermitRootLogin = 5,
    sQuietMode = 6,
    sFascistLogging = 7,
    sLogFacility = 8,
    sRhostsAuthentication = 9,
    sRhostsRSAAuthentication = 10,
    sRSAAuthentication = 11,
    sPasswordAuthentication = 12,
    sListenAddress = 13,
    sPrintMotd = 14,
    sIgnoreRhosts = 15,
    sX11Forwarding = 16,
    sX11DisplayOffset = 17,
    sStrictModes = 18,
    sEmptyPasswd = 19,
    sRandomSeedFile = 20,
    sKeepAlives = 21,
    sCheckMail = 22,
    sUseLogin = 23,
    sAllowUsers = 24,
    sDenyUsers = 25,
    sAllowGroups = 26,
    sDenyGroups = 27
} ;
#line 145 "servconf.c"
typedef enum __anonenum_ServerOpCodes_76 ServerOpCodes;
#line 167 "servconf.c"
struct __anonstruct_keywords_77 {
   char const   *name ;
   ServerOpCodes opcode ;
};
#line 216 "servconf.c"
struct __anonstruct_log_facilities_78 {
   char const   *name ;
   SyslogFacility facility ;
};
#line 61 "serverloop.c"
union __anonunion_77 {
   int volatile   __in ;
   int __i ;
};
#line 61 "serverloop.c"
union __anonunion_78 {
   int volatile   __in ;
   int __i ;
};
#line 614 "serverloop.c"
union __anonunion_79 {
   int __in ;
   int __i ;
};
#line 616 "serverloop.c"
union __anonunion_80 {
   int __in ;
   int __i ;
};
#line 611 "serverloop.c"
union __anonunion_81 {
   int __in ;
   int __i ;
};
#line 637 "serverloop.c"
union __anonunion_82 {
   int __in ;
   int __i ;
};
#line 636 "serverloop.c"
union __anonunion_83 {
   int __in ;
   int __i ;
};
#line 1 "authfd.o"
#line 100 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 124
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 242 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 256
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 660 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 320 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 327
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 333
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 39 "helper.h"
void strlcpy(char *dst , char const   *src , int len ) ;
#line 405 "/usr/include/openssl/bn.h"
extern int BN_num_bits(BIGNUM const   *a ) ;
#line 381 "ssh.h"
void log(char const   *fmt  , ...) ;
#line 391
void error(char const   *fmt  , ...) ;
#line 397
void fatal(char const   *fmt  , ...) ;
#line 30 "buffer.h"
void buffer_init(Buffer *buffer ) ;
#line 33
void buffer_free(Buffer *buffer ) ;
#line 37
void buffer_clear(Buffer *buffer ) ;
#line 40
void buffer_append(Buffer *buffer , char const   *data , unsigned int len ) ;
#line 48
unsigned int buffer_len(Buffer *buffer ) ;
#line 51
void buffer_get(Buffer *buffer , char *buf , unsigned int len ) ;
#line 60
char *buffer_ptr(Buffer *buffer ) ;
#line 43 "authfd.h"
int ssh_get_authentication_socket(void) ;
#line 48
void ssh_close_authentication_socket(int sock ) ;
#line 54
AuthenticationConnection *ssh_get_authentication_connection(void) ;
#line 58
void ssh_close_authentication_connection(AuthenticationConnection *ac ) ;
#line 64
int ssh_get_first_identity(AuthenticationConnection *auth , int *bitsp , BIGNUM *e ,
                           BIGNUM *n___0 , char **comment ) ;
#line 71
int ssh_get_next_identity(AuthenticationConnection *auth , int *bitsp , BIGNUM *e ,
                          BIGNUM *n___0 , char **comment ) ;
#line 76
int ssh_decrypt_challenge(AuthenticationConnection *auth , int bits , BIGNUM *e ,
                          BIGNUM *n___0 , BIGNUM *challenge , unsigned char *session_id___0 ,
                          unsigned int response_type , unsigned char *response ) ;
#line 85
int ssh_add_identity(AuthenticationConnection *auth , RSA *key , char const   *comment ) ;
#line 91
int ssh_remove_identity(AuthenticationConnection *auth , RSA *key ) ;
#line 97
int ssh_remove_all_identities(AuthenticationConnection *auth ) ;
#line 23 "bufaux.h"
void buffer_put_bignum(Buffer *buffer , BIGNUM *value ) ;
#line 26
int buffer_get_bignum(Buffer *buffer , BIGNUM *value ) ;
#line 29
unsigned int buffer_get_int(Buffer *buffer ) ;
#line 32
void buffer_put_int(Buffer *buffer , unsigned int value ) ;
#line 35
int buffer_get_char(Buffer *buffer ) ;
#line 38
void buffer_put_char(Buffer *buffer , int value ) ;
#line 46
char *buffer_get_string(Buffer *buffer , unsigned int *length_ptr ) ;
#line 49
void buffer_put_string(Buffer *buffer , void const   *buf , unsigned int len ) ;
#line 23 "xmalloc.h"
void *xmalloc(size_t size ) ;
#line 29
void xfree(void *ptr ) ;
#line 31 "authfd.c"
int ssh_get_authentication_socket(void) 
{ char const   *authsocket ;
  int sock ;
  struct sockaddr_un sunaddr ;
  char *tmp ;
  int tmp___0 ;

  {
#line 38
  tmp = getenv("SSH_AUTH_SOCK");
#line 38
  authsocket = (char const   *)tmp;
#line 39
  if (! authsocket) {
#line 40
    return (-1);
  }
#line 42
  sunaddr.sun_family = (unsigned short)1;
#line 43
  strlcpy(sunaddr.sun_path, authsocket, (int )sizeof(sunaddr.sun_path));
#line 45
  sock = socket(1, 1, 0);
#line 46
  if (sock < 0) {
#line 47
    return (-1);
  }
#line 49
  tmp___0 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sunaddr)),
                    sizeof(sunaddr));
#line 49
  if (tmp___0 < 0) {
#line 51
    close(sock);
#line 52
    return (-1);
  }
#line 55
  return (sock);
}
}
#line 62 "authfd.c"
void ssh_close_authentication_socket(int sock ) 
{ char *tmp ;

  {
#line 64
  tmp = getenv("SSH_AUTH_SOCK");
#line 64
  if (tmp) {
#line 65
    close(sock);
  }
#line 66
  return;
}
}
#line 74 "authfd.c"
AuthenticationConnection *ssh_get_authentication_connection(void) 
{ AuthenticationConnection *auth ;
  int sock ;
  void *tmp ;

  {
#line 79
  sock = ssh_get_authentication_socket();
#line 83
  if (sock < 0) {
#line 84
    return ((AuthenticationConnection *)((void *)0));
  }
#line 87
  tmp = xmalloc(sizeof(*auth));
#line 87
  auth = (AuthenticationConnection *)tmp;
#line 88
  auth->fd = sock;
#line 89
  buffer_init(& auth->packet);
#line 90
  buffer_init(& auth->identities);
#line 91
  auth->howmany = 0;
#line 93
  return (auth);
}
}
#line 99 "authfd.c"
void ssh_close_authentication_connection(AuthenticationConnection *ac ) 
{ 

  {
#line 101
  buffer_free(& ac->packet);
#line 102
  buffer_free(& ac->identities);
#line 103
  close(ac->fd);
#line 105
  xfree((void *)ac);
#line 106
  return;
}
}
#line 113 "authfd.c"
int ssh_get_first_identity(AuthenticationConnection *auth , int *bitsp , BIGNUM *e ,
                           BIGNUM *n___0 , char **comment ) 
{ unsigned char msg[8192] ;
  int len ;
  int l ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;

  {
#line 122
  msg[0] = (unsigned char)0;
#line 123
  msg[1] = (unsigned char)0;
#line 124
  msg[2] = (unsigned char)0;
#line 125
  msg[3] = (unsigned char)1;
#line 126
  msg[4] = (unsigned char)1;
#line 127
  tmp___1 = write(auth->fd, (void const   *)(msg), 5U);
#line 127
  if (tmp___1 != 5) {
#line 129
    tmp = __errno_location();
#line 129
    tmp___0 = strerror(*tmp);
#line 129
    error("write auth->fd: %.100s", tmp___0);
#line 130
    return (0);
  }
#line 134
  len = 4;
#line 135
  while (len > 0) {
#line 137
    l = read(auth->fd, (void *)((msg + 4) - len), (unsigned int )len);
#line 138
    if (l <= 0) {
#line 140
      tmp___2 = __errno_location();
#line 140
      tmp___3 = strerror(*tmp___2);
#line 140
      error("read auth->fd: %.100s", tmp___3);
#line 141
      return (0);
    }
#line 143
    len -= l;
  }
#line 148
  len = (int )(((((unsigned long )msg[0] << 24) | ((unsigned long )msg[1] << 16)) | ((unsigned long )msg[2] << 8)) | (unsigned long )msg[3]);
#line 149
  if (len < 1) {
#line 150
    fatal("Authentication reply message too long: %d\n", len);
  } else {
#line 149
    if (len > 262144) {
#line 150
      fatal("Authentication reply message too long: %d\n", len);
    }
  }
#line 153
  buffer_clear(& auth->identities);
#line 154
  while (len > 0) {
#line 156
    l = len;
#line 157
    if ((unsigned int )l > sizeof(msg)) {
#line 158
      l = (int )sizeof(msg);
    }
#line 159
    l = read(auth->fd, (void *)(msg), (unsigned int )l);
#line 160
    if (l <= 0) {
#line 161
      fatal("Incomplete authentication reply.");
    }
#line 162
    buffer_append(& auth->identities, (char const   *)((char *)(msg)), (unsigned int )l);
#line 163
    len -= l;
  }
#line 167
  buffer_get(& auth->identities, (char *)(msg), 1U);
#line 168
  if ((int )msg[0] != 2) {
#line 169
    fatal("Bad authentication reply message type: %d", msg[0]);
  }
#line 172
  tmp___4 = buffer_get_int(& auth->identities);
#line 172
  auth->howmany = (int )tmp___4;
#line 173
  if (auth->howmany > 1024) {
#line 174
    fatal("Too many identities in authentication reply: %d\n", auth->howmany);
  }
#line 177
  tmp___5 = ssh_get_next_identity(auth, bitsp, e, n___0, comment);
#line 177
  return (tmp___5);
}
}
#line 185 "authfd.c"
int ssh_get_next_identity(AuthenticationConnection *auth , int *bitsp , BIGNUM *e ,
                          BIGNUM *n___0 , char **comment ) 
{ unsigned int tmp ;

  {
#line 190
  if (auth->howmany <= 0) {
#line 191
    return (0);
  }
#line 195
  tmp = buffer_get_int(& auth->identities);
#line 195
  *bitsp = (int )tmp;
#line 196
  buffer_get_bignum(& auth->identities, e);
#line 197
  buffer_get_bignum(& auth->identities, n___0);
#line 198
  *comment = buffer_get_string(& auth->identities, (unsigned int *)((void *)0));
#line 201
  (auth->howmany) --;
#line 203
  return (1);
}
}
#line 212 "authfd.c"
int ssh_decrypt_challenge(AuthenticationConnection *auth , int bits , BIGNUM *e ,
                          BIGNUM *n___0 , BIGNUM *challenge , unsigned char *session_id___0 ,
                          unsigned int response_type , unsigned char *response ) 
{ Buffer buffer ;
  unsigned char buf[8192] ;
  int len ;
  int l ;
  int i ;
  unsigned int tmp ;
  ssize_t tmp___0 ;
  unsigned int tmp___1 ;
  char *tmp___2 ;
  ssize_t tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;

  {
#line 224
  if (response_type == 0U) {
#line 225
    fatal("Compatibility with ssh protocol version 1.0 no longer supported.");
  }
#line 228
  buf[0] = (unsigned char)3;
#line 229
  buffer_init(& buffer);
#line 230
  buffer_append(& buffer, (char const   *)((char *)(buf)), 1U);
#line 231
  buffer_put_int(& buffer, (unsigned int )bits);
#line 232
  buffer_put_bignum(& buffer, e);
#line 233
  buffer_put_bignum(& buffer, n___0);
#line 234
  buffer_put_bignum(& buffer, challenge);
#line 235
  buffer_append(& buffer, (char const   *)((char *)session_id___0), 16U);
#line 236
  buffer_put_int(& buffer, response_type);
#line 239
  tmp = buffer_len(& buffer);
#line 239
  len = (int )tmp;
#line 240
  while (1) {
#line 240
    buf[0] = (unsigned char )(len >> 24);
#line 240
    buf[1] = (unsigned char )(len >> 16);
#line 240
    buf[2] = (unsigned char )(len >> 8);
#line 240
    buf[3] = (unsigned char )len;
#line 240
    break;
  }
#line 243
  tmp___0 = write(auth->fd, (void const   *)(buf), 4U);
#line 243
  if (tmp___0 != 4) {
    goto _L;
  } else {
#line 243
    tmp___1 = buffer_len(& buffer);
#line 243
    tmp___2 = buffer_ptr(& buffer);
#line 243
    tmp___3 = write(auth->fd, (void const   *)tmp___2, tmp___1);
#line 243
    tmp___4 = buffer_len(& buffer);
#line 243
    if ((unsigned int )tmp___3 != tmp___4) {
      _L: /* CIL Label */ 
#line 247
      error("Error writing to authentication socket.");
      error_cleanup: 
#line 249
      buffer_free(& buffer);
#line 250
      return (0);
    }
  }
#line 255
  len = 4;
#line 256
  while (len > 0) {
#line 258
    l = read(auth->fd, (void *)((buf + 4) - len), (unsigned int )len);
#line 259
    if (l <= 0) {
#line 261
      error("Error reading response length from authentication socket.");
      goto error_cleanup;
    }
#line 264
    len -= l;
  }
#line 268
  len = (int )(((((unsigned long )buf[0] << 24) | ((unsigned long )buf[1] << 16)) | ((unsigned long )buf[2] << 8)) | (unsigned long )buf[3]);
#line 269
  if (len > 262144) {
#line 270
    fatal("Authentication response too long: %d", len);
  }
#line 273
  buffer_clear(& buffer);
#line 274
  while (len > 0) {
#line 276
    l = len;
#line 277
    if ((unsigned int )l > sizeof(buf)) {
#line 278
      l = (int )sizeof(buf);
    }
#line 279
    l = read(auth->fd, (void *)(buf), (unsigned int )l);
#line 280
    if (l <= 0) {
#line 282
      error("Error reading response from authentication socket.");
      goto error_cleanup;
    }
#line 285
    buffer_append(& buffer, (char const   *)((char *)(buf)), (unsigned int )l);
#line 286
    len -= l;
  }
#line 290
  buffer_get(& buffer, (char *)(buf), 1U);
#line 293
  if ((int )buf[0] == 5) {
#line 295
    log("Agent admitted failure to authenticate using the key.");
    goto error_cleanup;
  }
#line 300
  if ((int )buf[0] != 4) {
#line 301
    fatal("Bad authentication response: %d", buf[0]);
  }
#line 305
  i = 0;
#line 305
  while (i < 16) {
#line 306
    tmp___5 = buffer_get_char(& buffer);
#line 306
    *(response + i) = (unsigned char )tmp___5;
#line 305
    i ++;
  }
#line 309
  buffer_free(& buffer);
#line 312
  return (1);
}
}
#line 318 "authfd.c"
int ssh_add_identity(AuthenticationConnection *auth , RSA *key , char const   *comment ) 
{ Buffer buffer ;
  unsigned char buf[8192] ;
  int len ;
  int l ;
  int type ;
  int tmp ;
  size_t tmp___0 ;
  unsigned int tmp___1 ;
  ssize_t tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  ssize_t tmp___5 ;
  unsigned int tmp___6 ;

  {
#line 326
  buffer_init(& buffer);
#line 327
  buffer_put_char(& buffer, 7);
#line 328
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 328
  buffer_put_int(& buffer, (unsigned int )tmp);
#line 329
  buffer_put_bignum(& buffer, key->n);
#line 330
  buffer_put_bignum(& buffer, key->e);
#line 331
  buffer_put_bignum(& buffer, key->d);
#line 333
  buffer_put_bignum(& buffer, key->iqmp);
#line 334
  buffer_put_bignum(& buffer, key->q);
#line 335
  buffer_put_bignum(& buffer, key->p);
#line 336
  tmp___0 = strlen(comment);
#line 336
  buffer_put_string(& buffer, (void const   *)comment, tmp___0);
#line 339
  tmp___1 = buffer_len(& buffer);
#line 339
  len = (int )tmp___1;
#line 340
  while (1) {
#line 340
    buf[0] = (unsigned char )(len >> 24);
#line 340
    buf[1] = (unsigned char )(len >> 16);
#line 340
    buf[2] = (unsigned char )(len >> 8);
#line 340
    buf[3] = (unsigned char )len;
#line 340
    break;
  }
#line 343
  tmp___2 = write(auth->fd, (void const   *)(buf), 4U);
#line 343
  if (tmp___2 != 4) {
    goto _L;
  } else {
#line 343
    tmp___3 = buffer_len(& buffer);
#line 343
    tmp___4 = buffer_ptr(& buffer);
#line 343
    tmp___5 = write(auth->fd, (void const   *)tmp___4, tmp___3);
#line 343
    tmp___6 = buffer_len(& buffer);
#line 343
    if ((unsigned int )tmp___5 != tmp___6) {
      _L: /* CIL Label */ 
#line 347
      error("Error writing to authentication socket.");
      error_cleanup: 
#line 349
      buffer_free(& buffer);
#line 350
      return (0);
    }
  }
#line 355
  len = 4;
#line 356
  while (len > 0) {
#line 358
    l = read(auth->fd, (void *)((buf + 4) - len), (unsigned int )len);
#line 359
    if (l <= 0) {
#line 361
      error("Error reading response length from authentication socket.");
      goto error_cleanup;
    }
#line 364
    len -= l;
  }
#line 368
  len = (int )(((((unsigned long )buf[0] << 24) | ((unsigned long )buf[1] << 16)) | ((unsigned long )buf[2] << 8)) | (unsigned long )buf[3]);
#line 369
  if (len > 262144) {
#line 370
    fatal("Add identity response too long: %d", len);
  }
#line 373
  buffer_clear(& buffer);
#line 374
  while (len > 0) {
#line 376
    l = len;
#line 377
    if ((unsigned int )l > sizeof(buf)) {
#line 378
      l = (int )sizeof(buf);
    }
#line 379
    l = read(auth->fd, (void *)(buf), (unsigned int )l);
#line 380
    if (l <= 0) {
#line 382
      error("Error reading response from authentication socket.");
      goto error_cleanup;
    }
#line 385
    buffer_append(& buffer, (char const   *)((char *)(buf)), (unsigned int )l);
#line 386
    len -= l;
  }
#line 390
  type = buffer_get_char(& buffer);
#line 391
  switch (type) {
  case 5: 
#line 394
  buffer_free(& buffer);
#line 395
  return (0);
  case 6: 
#line 397
  buffer_free(& buffer);
#line 398
  return (1);
  default: 
#line 400
  fatal("Bad response to add identity from authentication agent: %d", type);
  }
#line 404
  return (0);
}
}
#line 410 "authfd.c"
int ssh_remove_identity(AuthenticationConnection *auth , RSA *key ) 
{ Buffer buffer ;
  unsigned char buf[8192] ;
  int len ;
  int l ;
  int type ;
  int tmp ;
  unsigned int tmp___0 ;
  ssize_t tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  ssize_t tmp___4 ;
  unsigned int tmp___5 ;

  {
#line 417
  buffer_init(& buffer);
#line 418
  buffer_put_char(& buffer, 8);
#line 419
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 419
  buffer_put_int(& buffer, (unsigned int )tmp);
#line 420
  buffer_put_bignum(& buffer, key->e);
#line 421
  buffer_put_bignum(& buffer, key->n);
#line 424
  tmp___0 = buffer_len(& buffer);
#line 424
  len = (int )tmp___0;
#line 425
  while (1) {
#line 425
    buf[0] = (unsigned char )(len >> 24);
#line 425
    buf[1] = (unsigned char )(len >> 16);
#line 425
    buf[2] = (unsigned char )(len >> 8);
#line 425
    buf[3] = (unsigned char )len;
#line 425
    break;
  }
#line 428
  tmp___1 = write(auth->fd, (void const   *)(buf), 4U);
#line 428
  if (tmp___1 != 4) {
    goto _L;
  } else {
#line 428
    tmp___2 = buffer_len(& buffer);
#line 428
    tmp___3 = buffer_ptr(& buffer);
#line 428
    tmp___4 = write(auth->fd, (void const   *)tmp___3, tmp___2);
#line 428
    tmp___5 = buffer_len(& buffer);
#line 428
    if ((unsigned int )tmp___4 != tmp___5) {
      _L: /* CIL Label */ 
#line 432
      error("Error writing to authentication socket.");
      error_cleanup: 
#line 434
      buffer_free(& buffer);
#line 435
      return (0);
    }
  }
#line 440
  len = 4;
#line 441
  while (len > 0) {
#line 443
    l = read(auth->fd, (void *)((buf + 4) - len), (unsigned int )len);
#line 444
    if (l <= 0) {
#line 446
      error("Error reading response length from authentication socket.");
      goto error_cleanup;
    }
#line 449
    len -= l;
  }
#line 453
  len = (int )(((((unsigned long )buf[0] << 24) | ((unsigned long )buf[1] << 16)) | ((unsigned long )buf[2] << 8)) | (unsigned long )buf[3]);
#line 454
  if (len > 262144) {
#line 455
    fatal("Remove identity response too long: %d", len);
  }
#line 458
  buffer_clear(& buffer);
#line 459
  while (len > 0) {
#line 461
    l = len;
#line 462
    if ((unsigned int )l > sizeof(buf)) {
#line 463
      l = (int )sizeof(buf);
    }
#line 464
    l = read(auth->fd, (void *)(buf), (unsigned int )l);
#line 465
    if (l <= 0) {
#line 467
      error("Error reading response from authentication socket.");
      goto error_cleanup;
    }
#line 470
    buffer_append(& buffer, (char const   *)((char *)(buf)), (unsigned int )l);
#line 471
    len -= l;
  }
#line 475
  type = buffer_get_char(& buffer);
#line 476
  switch (type) {
  case 5: 
#line 479
  buffer_free(& buffer);
#line 480
  return (0);
  case 6: 
#line 482
  buffer_free(& buffer);
#line 483
  return (1);
  default: 
#line 485
  fatal("Bad response to remove identity from authentication agent: %d", type);
  }
#line 489
  return (0);
}
}
#line 495 "authfd.c"
int ssh_remove_all_identities(AuthenticationConnection *auth ) 
{ Buffer buffer ;
  unsigned char buf[8192] ;
  int len ;
  int l ;
  int type ;
  ssize_t tmp ;

  {
#line 502
  while (1) {
#line 502
    buf[0] = (unsigned char )(1 >> 24);
#line 502
    buf[1] = (unsigned char )(1 >> 16);
#line 502
    buf[2] = (unsigned char )(1 >> 8);
#line 502
    buf[3] = (unsigned char)1;
#line 502
    break;
  }
#line 503
  buf[4] = (unsigned char)9;
#line 506
  tmp = write(auth->fd, (void const   *)(buf), 5U);
#line 506
  if (tmp != 5) {
#line 508
    error("Error writing to authentication socket.");
#line 509
    return (0);
  }
#line 514
  len = 4;
#line 515
  while (len > 0) {
#line 517
    l = read(auth->fd, (void *)((buf + 4) - len), (unsigned int )len);
#line 518
    if (l <= 0) {
#line 520
      error("Error reading response length from authentication socket.");
#line 521
      return (0);
    }
#line 523
    len -= l;
  }
#line 527
  len = (int )(((((unsigned long )buf[0] << 24) | ((unsigned long )buf[1] << 16)) | ((unsigned long )buf[2] << 8)) | (unsigned long )buf[3]);
#line 528
  if (len > 262144) {
#line 529
    fatal("Remove identity response too long: %d", len);
  }
#line 532
  buffer_init(& buffer);
#line 533
  while (len > 0) {
#line 535
    l = len;
#line 536
    if ((unsigned int )l > sizeof(buf)) {
#line 537
      l = (int )sizeof(buf);
    }
#line 538
    l = read(auth->fd, (void *)(buf), (unsigned int )l);
#line 539
    if (l <= 0) {
#line 541
      error("Error reading response from authentication socket.");
#line 542
      buffer_free(& buffer);
#line 543
      return (0);
    }
#line 545
    buffer_append(& buffer, (char const   *)((char *)(buf)), (unsigned int )l);
#line 546
    len -= l;
  }
#line 550
  type = buffer_get_char(& buffer);
#line 551
  switch (type) {
  case 5: 
#line 554
  buffer_free(& buffer);
#line 555
  return (0);
  case 6: 
#line 557
  buffer_free(& buffer);
#line 558
  return (1);
  default: 
#line 560
  fatal("Bad response to remove identity from authentication agent: %d", type);
  }
#line 564
  return (0);
}
}
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned int  ) ;  */
#line 1 "helper.o"
#line 144 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 327
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 646 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 729
 __attribute__((__nothrow__)) char *mkdtemp(char *template )  __attribute__((__nonnull__(1))) ;
#line 316 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int mkdir(char const   *__path , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 85 "/usr/include/fcntl.h"
extern int open(char const   *__file , int __oflag  , ...)  __attribute__((__nonnull__(1))) ;
#line 81 "rc4.h"
void rc4_key(rc4_t *r , unsigned char *key , int len ) ;
#line 108
void rc4_getbytes(rc4_t *r , unsigned char *buffer , int len ) ;
#line 40 "helper.h"
unsigned char arc4random(void) ;
#line 41
void arc4random_stir(void) ;
#line 43
void setproctitle(char const   *fmt  , ...) ;
#line 51 "helper.c"
void get_random_bytes(unsigned char *buf , int len ) ;
#line 53 "helper.c"
static rc4_t *rc4  =    (rc4_t *)((void *)0);
#line 55 "helper.c"
char const   mkdtemp_chars[63]  = 
#line 55
  {      (char const   )'a',      (char const   )'b',      (char const   )'c',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'g',      (char const   )'h', 
        (char const   )'i',      (char const   )'j',      (char const   )'k',      (char const   )'l', 
        (char const   )'m',      (char const   )'n',      (char const   )'o',      (char const   )'p', 
        (char const   )'q',      (char const   )'r',      (char const   )'s',      (char const   )'t', 
        (char const   )'u',      (char const   )'v',      (char const   )'w',      (char const   )'x', 
        (char const   )'z',      (char const   )'y',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'G',      (char const   )'H',      (char const   )'I',      (char const   )'J', 
        (char const   )'K',      (char const   )'L',      (char const   )'M',      (char const   )'N', 
        (char const   )'O',      (char const   )'P',      (char const   )'Q',      (char const   )'R', 
        (char const   )'S',      (char const   )'T',      (char const   )'U',      (char const   )'V', 
        (char const   )'W',      (char const   )'X',      (char const   )'Z',      (char const   )'Y', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'\000'};
#line 58 "helper.c"
void setproctitle(char const   *fmt  , ...) 
{ 

  {
#line 61
  return;
}
}
#line 63 "helper.c"
void strlcpy(char *dst , char const   *src , int len ) 
{ 

  {
#line 65
  __builtin_strncpy(dst, src, (unsigned int )(len - 1));
#line 66
  *(dst + (len - 1)) = (char )'\000';
#line 67
  return;
}
}
#line 69
 __attribute__((__nothrow__)) char *mkdtemp(char *template )  __attribute__((__nonnull__(1))) ;
#line 69 "helper.c"
char *mkdtemp(char *template ) 
{ int offset ;
  size_t tmp ;
  unsigned char tmp___0 ;
  int tmp___1 ;

  {
#line 73
  tmp = strlen((char const   *)template);
#line 73
  offset = (int )(tmp - 1U);
#line 75
  if (offset < 0) {
#line 77
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Empty string passed to mkdtemp.");
#line 78
    exit(1);
  }
#line 82
  while (1) {
#line 82
    if (offset >= 0) {
#line 82
      if (! ((int )*(template + offset) == 88)) {
#line 82
        break;
      }
    } else {
#line 82
      break;
    }
#line 84
    tmp___0 = arc4random();
#line 84
    *(template + offset) = (char )mkdtemp_chars[(int )tmp___0 % 62];
#line 85
    offset --;
  }
#line 88
  tmp___1 = mkdir((char const   *)template, 448U);
#line 88
  if (tmp___1 == -1) {
#line 89
    return ((char *)((void *)0));
  }
#line 91
  return (template);
}
}
#line 94 "helper.c"
unsigned char arc4random(void) 
{ unsigned char r ;

  {
#line 98
  if ((unsigned int )rc4 == (unsigned int )((void *)0)) {
#line 99
    arc4random_stir();
  }
#line 101
  rc4_getbytes(rc4, & r, 1);
#line 103
  return (r);
}
}
#line 106 "helper.c"
void arc4random_stir(void) 
{ unsigned char rand_buf[256] ;
  void *tmp ;

  {
#line 110
  if ((unsigned int )rc4 == (unsigned int )((void *)0)) {
#line 111
    tmp = xmalloc(sizeof(*rc4));
#line 111
    rc4 = (rc4_t *)tmp;
  }
#line 113
  get_random_bytes(rand_buf, (int )sizeof(rand_buf));
#line 114
  rc4_key(rc4, rand_buf, (int )sizeof(rand_buf));
#line 115
  return;
}
}
#line 117 "helper.c"
void get_random_bytes(unsigned char *buf , int len ) 
{ int urandom ;
  int c ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
#line 122
  urandom = open("/dev/urandom", 0);
#line 123
  if (urandom == -1) {
#line 125
    tmp = __errno_location();
#line 125
    tmp___0 = strerror(*tmp);
#line 125
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Couldn\'t open /dev/urandom: %s",
            tmp___0);
#line 126
    exit(1);
  }
#line 129
  c = read(urandom, (void *)buf, (unsigned int )len);
#line 130
  if (c == -1) {
#line 132
    tmp___1 = __errno_location();
#line 132
    tmp___2 = strerror(*tmp___1);
#line 132
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Couldn\'t read from /dev/urandom: %s",
            tmp___2);
#line 133
    exit(1);
  }
#line 136
  if (c != len) {
#line 138
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Short read from /dev/urandom");
#line 139
    exit(1);
  }
#line 141
  return;
}
}
#line 1 "rc4.o"
#line 96 "rc4.h"
void rc4_crypt(rc4_t *r , unsigned char *plaintext , int len ) ;
#line 47 "rc4.c"
void rc4_key(rc4_t *r , unsigned char *key , int len ) 
{ int t ;

  {
#line 51
  r->i = 0;
#line 51
  while (r->i < 256) {
#line 52
    r->s[r->i] = (unsigned int )r->i;
#line 51
    (r->i) ++;
  }
#line 54
  r->j = 0;
#line 55
  r->i = 0;
#line 55
  while (r->i < 256) {
#line 57
    r->j = (int )((((unsigned int )r->j + r->s[r->i]) + (unsigned int )*(key + r->i % len)) % 256U);
#line 58
    t = (int )r->s[r->i];
#line 59
    r->s[r->i] = r->s[r->j];
#line 60
    r->s[r->j] = (unsigned int )t;
#line 55
    (r->i) ++;
  }
#line 62
  r->j = 0;
#line 62
  r->i = r->j;
#line 63
  return;
}
}
#line 65 "rc4.c"
void rc4_crypt(rc4_t *r , unsigned char *plaintext , int len ) 
{ int t ;
  int c ;

  {
#line 70
  c = 0;
#line 71
  while (c < len) {
#line 73
    r->i = (r->i + 1) % 256;
#line 74
    r->j = (int )(((unsigned int )r->j + r->s[r->i]) % 256U);
#line 75
    t = (int )r->s[r->i];
#line 76
    r->s[r->i] = r->s[r->j];
#line 77
    r->s[r->j] = (unsigned int )t;
#line 79
    t = (int )((r->s[r->i] + r->s[r->j]) % 256U);
#line 81
    *(plaintext + c) = (unsigned char )((unsigned int )*(plaintext + c) ^ r->s[t]);
#line 82
    c ++;
  }
#line 84
  return;
}
}
#line 86 "rc4.c"
void rc4_getbytes(rc4_t *r , unsigned char *buffer , int len ) 
{ int t ;
  int c ;

  {
#line 91
  c = 0;
#line 92
  while (c < len) {
#line 94
    r->i = (r->i + 1) % 256;
#line 95
    r->j = (int )(((unsigned int )r->j + r->s[r->i]) % 256U);
#line 96
    t = (int )r->s[r->i];
#line 97
    r->s[r->i] = r->s[r->j];
#line 98
    r->s[r->j] = (unsigned int )t;
#line 100
    t = (int )((r->s[r->i] + r->s[r->j]) % 256U);
#line 102
    *(buffer + c) = (unsigned char )r->s[t];
#line 103
    c ++;
  }
#line 105
  return;
}
}
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
#line 1 "authfile.o"
#line 212 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 380
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __attribute__((__nonnull__(3))) ;
#line 447
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 447 "/usr/include/sys/stat.h"
__inline static int fstat(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
#line 450
  tmp = __fxstat(3, __fd, __statbuf);
#line 450
  return (tmp);
}
}
#line 59 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 154 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 301 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 642
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 391 "/usr/include/openssl/bn.h"
extern BIGNUM const   *BN_value_one(void) ;
#line 393
extern BN_CTX *BN_CTX_new(void) ;
#line 397
extern void BN_CTX_free(BN_CTX *c ) ;
#line 407
extern BIGNUM *BN_new(void) ;
#line 409
extern void BN_clear_free(BIGNUM *a ) ;
#line 416
extern int BN_sub(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *b ) ;
#line 433
extern int BN_div(BIGNUM *dv , BIGNUM *rem , BIGNUM const   *m , BIGNUM const   *d ,
                  BN_CTX *ctx ) ;
#line 45 "buffer.h"
void buffer_append_space(Buffer *buffer , char **datap , unsigned int len ) ;
#line 53 "cipher.h"
unsigned int cipher_mask(void) ;
#line 56
char const   *cipher_name(int cipher ) ;
#line 69
void cipher_set_key_string(CipherContext *context , int cipher , char const   *passphrase ,
                           int for_encryption ) ;
#line 73
void cipher_encrypt(CipherContext *context , unsigned char *dest , unsigned char const   *src ,
                    unsigned int len ) ;
#line 77
void cipher_decrypt(CipherContext *context , unsigned char *dest , unsigned char const   *src ,
                    unsigned int len ) ;
#line 336 "ssh.h"
int save_private_key(char const   *filename , char const   *passphrase , RSA *key ,
                     char const   *comment ) ;
#line 343
int load_public_key(char const   *filename , RSA *pub , char **comment_return ) ;
#line 351
int load_private_key(char const   *filename , char const   *passphrase , RSA *prv ,
                     char **comment_return ) ;
#line 386
void debug(char const   *fmt  , ...) ;
#line 35 "authfile.c"
int save_private_key(char const   *filename , char const   *passphrase , RSA *key ,
                     char const   *comment ) 
{ Buffer buffer ;
  Buffer encrypted ;
  char buf[100] ;
  char *cp ;
  int f ;
  int i ;
  CipherContext cipher ;
  int cipher_type___0 ;
  u_int32_t rand___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned char tmp___9 ;
  unsigned int tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  char *tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  unsigned int tmp___18 ;
  char *tmp___19 ;
  ssize_t tmp___20 ;
  unsigned int tmp___21 ;

  {
#line 48
  if (0) {
#line 48
    __s1_len = strlen(passphrase);
#line 48
    __s2_len = strlen("");
#line 48
    if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
      goto _L___0;
    } else {
#line 48
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 48
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 48
          tmp___8 = 1;
        } else {
#line 48
          if (__s2_len >= 4U) {
#line 48
            tmp___8 = 1;
          } else {
#line 48
            tmp___8 = 0;
          }
        }
      } else {
#line 48
        tmp___8 = 0;
      }
    }
#line 48
    if (tmp___8) {
#line 48
      tmp___4 = __builtin_strcmp(passphrase, "");
    } else {
#line 48
      tmp___7 = __builtin_strcmp(passphrase, "");
#line 48
      tmp___4 = tmp___7;
    }
  } else {
#line 48
    tmp___7 = __builtin_strcmp(passphrase, "");
#line 48
    tmp___4 = tmp___7;
  }
#line 48
  if (tmp___4 == 0) {
#line 49
    cipher_type___0 = 0;
  } else {
#line 51
    cipher_type___0 = 3;
  }
#line 54
  buffer_init(& buffer);
#line 57
  tmp___9 = arc4random();
#line 57
  rand___0 = (unsigned int )tmp___9;
#line 58
  buf[0] = (char )(rand___0 & 255U);
#line 59
  buf[1] = (char )((rand___0 >> 8) & 255U);
#line 60
  buf[2] = buf[0];
#line 61
  buf[3] = buf[1];
#line 62
  buffer_append(& buffer, (char const   *)(buf), 4U);
#line 67
  buffer_put_bignum(& buffer, key->d);
#line 68
  buffer_put_bignum(& buffer, key->iqmp);
#line 69
  buffer_put_bignum(& buffer, key->q);
#line 70
  buffer_put_bignum(& buffer, key->p);
#line 73
  while (1) {
#line 73
    tmp___10 = buffer_len(& buffer);
#line 73
    if (! (tmp___10 % 8U != 0U)) {
#line 73
      break;
    }
#line 74
    buffer_put_char(& buffer, 0);
  }
#line 77
  buffer_init(& encrypted);
#line 80
  cp = (char *)"SSH PRIVATE KEY FILE FORMAT 1.1\n";
#line 81
  i = 0;
#line 81
  while (*(cp + i)) {
#line 82
    buffer_put_char(& encrypted, (int )*(cp + i));
#line 81
    i ++;
  }
#line 83
  buffer_put_char(& encrypted, 0);
#line 86
  buffer_put_char(& encrypted, cipher_type___0);
#line 87
  buffer_put_int(& encrypted, 0U);
#line 90
  tmp___11 = BN_num_bits((BIGNUM const   *)key->n);
#line 90
  buffer_put_int(& encrypted, (unsigned int )tmp___11);
#line 91
  buffer_put_bignum(& encrypted, key->n);
#line 92
  buffer_put_bignum(& encrypted, key->e);
#line 93
  tmp___12 = strlen(comment);
#line 93
  buffer_put_string(& encrypted, (void const   *)comment, tmp___12);
#line 96
  tmp___13 = buffer_len(& buffer);
#line 96
  buffer_append_space(& encrypted, & cp, tmp___13);
#line 98
  cipher_set_key_string(& cipher, cipher_type___0, passphrase, 1);
#line 99
  tmp___14 = buffer_len(& buffer);
#line 99
  tmp___15 = buffer_ptr(& buffer);
#line 99
  cipher_encrypt(& cipher, (unsigned char *)cp, (unsigned char const   *)((unsigned char *)tmp___15),
                 tmp___14);
#line 102
  memset((void *)(& cipher), 0, sizeof(cipher));
#line 105
  memset((void *)(buf), 0, sizeof(buf));
#line 106
  buffer_free(& buffer);
#line 109
  f = open(filename, 577, 384);
#line 110
  if (f < 0) {
#line 111
    return (0);
  }
#line 113
  tmp___18 = buffer_len(& encrypted);
#line 113
  tmp___19 = buffer_ptr(& encrypted);
#line 113
  tmp___20 = write(f, (void const   *)tmp___19, tmp___18);
#line 113
  tmp___21 = buffer_len(& encrypted);
#line 113
  if ((unsigned int )tmp___20 != tmp___21) {
#line 116
    tmp___16 = __errno_location();
#line 116
    tmp___17 = strerror(*tmp___16);
#line 116
    debug("Write to key file %.200s failed: %.100s", filename, tmp___17);
#line 118
    buffer_free(& encrypted);
#line 119
    close(f);
#line 120
    remove(filename);
#line 121
    return (0);
  }
#line 123
  close(f);
#line 124
  buffer_free(& encrypted);
#line 125
  return (1);
}
}
#line 132 "authfile.c"
int load_public_key(char const   *filename , RSA *pub , char **comment_return ) 
{ int f ;
  int i ;
  off_t len ;
  Buffer buffer ;
  char *cp ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
#line 142
  f = open(filename, 0);
#line 143
  if (f < 0) {
#line 144
    return (0);
  }
#line 146
  len = lseek(f, 0L, 2);
#line 147
  lseek(f, 0L, 0);
#line 149
  buffer_init(& buffer);
#line 150
  buffer_append_space(& buffer, & cp, (unsigned int )len);
#line 152
  tmp___1 = read(f, (void *)cp, (unsigned int )len);
#line 152
  if ((unsigned int )tmp___1 != (unsigned int )len) {
#line 154
    tmp = __errno_location();
#line 154
    tmp___0 = strerror(*tmp);
#line 154
    debug("Read from key file %.200s failed: %.100s", filename, tmp___0);
#line 156
    buffer_free(& buffer);
#line 157
    close(f);
#line 158
    return (0);
  }
#line 160
  close(f);
#line 163
  tmp___2 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 163
  if ((unsigned long )len < (unsigned long )(tmp___2 + 1U)) {
#line 165
    debug("Bad key file %.200s.", filename);
#line 166
    buffer_free(& buffer);
#line 167
    return (0);
  }
#line 172
  i = 0;
#line 172
  while (1) {
#line 172
    tmp___4 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 172
    if (! ((unsigned int )i < tmp___4 + 1U)) {
#line 172
      break;
    }
#line 173
    tmp___3 = buffer_get_char(& buffer);
#line 173
    if (tmp___3 != (int )((unsigned char )*("SSH PRIVATE KEY FILE FORMAT 1.1\n" + i))) {
#line 175
      debug("Bad key file %.200s.", filename);
#line 176
      buffer_free(& buffer);
#line 177
      return (0);
    }
#line 172
    i ++;
  }
#line 181
  buffer_get_char(& buffer);
#line 182
  buffer_get_int(& buffer);
#line 185
  buffer_get_int(& buffer);
#line 186
  pub->n = BN_new();
#line 187
  buffer_get_bignum(& buffer, pub->n);
#line 188
  pub->e = BN_new();
#line 189
  buffer_get_bignum(& buffer, pub->e);
#line 190
  if (comment_return) {
#line 191
    *comment_return = buffer_get_string(& buffer, (unsigned int *)((void *)0));
  }
#line 194
  buffer_free(& buffer);
#line 196
  return (1);
}
}
#line 203 "authfile.c"
int load_private_key(char const   *filename , char const   *passphrase , RSA *prv ,
                     char **comment_return ) 
{ int f ;
  int i ;
  int check1 ;
  int check2 ;
  int cipher_type___0 ;
  off_t len ;
  Buffer buffer ;
  Buffer decrypted ;
  char *cp ;
  CipherContext cipher ;
  BN_CTX *ctx ;
  BIGNUM *aux ;
  struct stat st ;
  int tmp ;
  __uid_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  ssize_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  char *tmp___12 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  BIGNUM const   *tmp___25 ;
  BIGNUM const   *tmp___26 ;

  {
#line 217
  f = open(filename, 0);
#line 218
  if (f < 0) {
#line 219
    return (0);
  }
#line 222
  tmp = fstat(f, & st);
#line 222
  if (tmp < 0) {
    goto _L;
  } else {
#line 222
    if (st.st_uid != 0U) {
#line 222
      tmp___0 = getuid();
#line 222
      if (st.st_uid != tmp___0) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 222
      if ((st.st_mode & 63U) != 0U) {
        _L: /* CIL Label */ 
#line 225
        error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 226
        error("@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @");
#line 227
        error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 228
        error("Bad ownership or mode(0%3.3o) for \'%s\'.", st.st_mode & 511U, filename);
#line 230
        error("It is recommended that your private key files are NOT accessible by others.");
#line 231
        return (0);
      }
    }
  }
#line 234
  len = lseek(f, 0L, 2);
#line 235
  lseek(f, 0L, 0);
#line 237
  buffer_init(& buffer);
#line 238
  buffer_append_space(& buffer, & cp, (unsigned int )len);
#line 240
  tmp___3 = read(f, (void *)cp, (unsigned int )len);
#line 240
  if ((unsigned int )tmp___3 != (unsigned int )len) {
#line 242
    tmp___1 = __errno_location();
#line 242
    tmp___2 = strerror(*tmp___1);
#line 242
    debug("Read from key file %.200s failed: %.100s", filename, tmp___2);
#line 244
    buffer_free(& buffer);
#line 245
    close(f);
#line 246
    return (0);
  }
#line 248
  close(f);
#line 251
  tmp___4 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 251
  if ((unsigned long )len < (unsigned long )(tmp___4 + 1U)) {
#line 253
    debug("Bad key file %.200s.", filename);
#line 254
    buffer_free(& buffer);
#line 255
    return (0);
  }
#line 260
  i = 0;
#line 260
  while (1) {
#line 260
    tmp___6 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 260
    if (! ((unsigned int )i < tmp___6 + 1U)) {
#line 260
      break;
    }
#line 261
    tmp___5 = buffer_get_char(& buffer);
#line 261
    if (tmp___5 != (int )((unsigned char )*("SSH PRIVATE KEY FILE FORMAT 1.1\n" + i))) {
#line 263
      debug("Bad key file %.200s.", filename);
#line 264
      buffer_free(& buffer);
#line 265
      return (0);
    }
#line 260
    i ++;
  }
#line 269
  cipher_type___0 = buffer_get_char(& buffer);
#line 270
  buffer_get_int(& buffer);
#line 273
  buffer_get_int(& buffer);
#line 274
  prv->n = BN_new();
#line 275
  buffer_get_bignum(& buffer, prv->n);
#line 276
  prv->e = BN_new();
#line 277
  buffer_get_bignum(& buffer, prv->e);
#line 278
  if (comment_return) {
#line 279
    *comment_return = buffer_get_string(& buffer, (unsigned int *)((void *)0));
  } else {
#line 281
    tmp___7 = buffer_get_string(& buffer, (unsigned int *)((void *)0));
#line 281
    xfree((void *)tmp___7);
  }
#line 284
  tmp___9 = cipher_mask();
#line 284
  if (((tmp___9 | 3U) & (unsigned int )(1 << cipher_type___0)) == 0U) {
#line 287
    tmp___8 = cipher_name(cipher_type___0);
#line 287
    debug("Unsupported cipher %.100s used in key file %.200s.", tmp___8, filename);
#line 289
    buffer_free(& buffer);
    goto fail;
  }
#line 294
  buffer_init(& decrypted);
#line 295
  tmp___10 = buffer_len(& buffer);
#line 295
  buffer_append_space(& decrypted, & cp, tmp___10);
#line 298
  cipher_set_key_string(& cipher, cipher_type___0, passphrase, 0);
#line 299
  tmp___11 = buffer_len(& buffer);
#line 299
  tmp___12 = buffer_ptr(& buffer);
#line 299
  cipher_decrypt(& cipher, (unsigned char *)cp, (unsigned char const   *)((unsigned char *)tmp___12),
                 tmp___11);
#line 303
  buffer_free(& buffer);
#line 305
  check1 = buffer_get_char(& decrypted);
#line 306
  check2 = buffer_get_char(& decrypted);
#line 307
  tmp___23 = buffer_get_char(& decrypted);
#line 307
  if (check1 != tmp___23) {
    goto _L___3;
  } else {
#line 307
    tmp___24 = buffer_get_char(& decrypted);
#line 307
    if (check2 != tmp___24) {
      _L___3: /* CIL Label */ 
#line 310
      if (0) {
#line 310
        __s1_len = strlen(passphrase);
#line 310
        __s2_len = strlen("");
#line 310
        if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
          goto _L___2;
        } else {
#line 310
          if (__s1_len >= 4U) {
            _L___2: /* CIL Label */ 
#line 310
            if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 310
              tmp___22 = 1;
            } else {
#line 310
              if (__s2_len >= 4U) {
#line 310
                tmp___22 = 1;
              } else {
#line 310
                tmp___22 = 0;
              }
            }
          } else {
#line 310
            tmp___22 = 0;
          }
        }
#line 310
        if (tmp___22) {
#line 310
          tmp___18 = __builtin_strcmp(passphrase, "");
        } else {
#line 310
          tmp___21 = __builtin_strcmp(passphrase, "");
#line 310
          tmp___18 = tmp___21;
        }
      } else {
#line 310
        tmp___21 = __builtin_strcmp(passphrase, "");
#line 310
        tmp___18 = tmp___21;
      }
#line 310
      if (tmp___18 != 0) {
#line 311
        debug("Bad passphrase supplied for key file %.200s.", filename);
      }
#line 313
      buffer_free(& decrypted);
      fail: 
#line 315
      BN_clear_free(prv->n);
#line 316
      BN_clear_free(prv->e);
#line 317
      if (comment_return) {
#line 318
        xfree((void *)*comment_return);
      }
#line 319
      return (0);
    }
  }
#line 323
  prv->d = BN_new();
#line 324
  buffer_get_bignum(& decrypted, prv->d);
#line 325
  prv->iqmp = BN_new();
#line 326
  buffer_get_bignum(& decrypted, prv->iqmp);
#line 328
  prv->q = BN_new();
#line 329
  buffer_get_bignum(& decrypted, prv->q);
#line 330
  prv->p = BN_new();
#line 331
  buffer_get_bignum(& decrypted, prv->p);
#line 333
  ctx = BN_CTX_new();
#line 334
  aux = BN_new();
#line 336
  tmp___25 = BN_value_one();
#line 336
  BN_sub(aux, (BIGNUM const   *)prv->q, tmp___25);
#line 337
  prv->dmq1 = BN_new();
#line 338
  BN_div((BIGNUM *)((void *)0), prv->dmq1, (BIGNUM const   *)prv->d, (BIGNUM const   *)aux,
         ctx);
#line 340
  tmp___26 = BN_value_one();
#line 340
  BN_sub(aux, (BIGNUM const   *)prv->p, tmp___26);
#line 341
  prv->dmp1 = BN_new();
#line 342
  BN_div((BIGNUM *)((void *)0), prv->dmp1, (BIGNUM const   *)prv->d, (BIGNUM const   *)aux,
         ctx);
#line 344
  BN_clear_free(aux);
#line 345
  BN_CTX_free(ctx);
#line 347
  buffer_free(& decrypted);
#line 349
  return (1);
}
}
#line 1 "bufaux.o"
#line 68 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
#line 412 "/usr/include/openssl/bn.h"
extern BIGNUM *BN_bin2bn(unsigned char const   *s , int len , BIGNUM *ret ) ;
#line 413
extern int BN_bn2bin(BIGNUM const   *a , unsigned char *to ) ;
#line 29 "bufaux.c"
void buffer_put_bignum(Buffer *buffer , BIGNUM *value ) 
{ int bits ;
  int tmp ;
  int bin_size ;
  char *buf ;
  void *tmp___0 ;
  int oi ;
  char msg[2] ;

  {
#line 32
  tmp = BN_num_bits((BIGNUM const   *)value);
#line 32
  bits = tmp;
#line 33
  bin_size = (bits + 7) / 8;
#line 34
  tmp___0 = xmalloc((unsigned int )bin_size);
#line 34
  buf = (char *)tmp___0;
#line 39
  oi = BN_bn2bin((BIGNUM const   *)value, (unsigned char *)buf);
#line 40
  if (! (oi == bin_size)) {
#line 40
    __assert_fail("oi == bin_size", "bufaux.c", 40U, "buffer_put_bignum");
  }
#line 43
  while (1) {
#line 43
    msg[0] = (char )(bits >> 8);
#line 43
    msg[1] = (char )bits;
#line 43
    break;
  }
#line 44
  buffer_append(buffer, (char const   *)(msg), 2U);
#line 46
  buffer_append(buffer, (char const   *)buf, (unsigned int )oi);
#line 48
  memset((void *)buf, 0, (unsigned int )bin_size);
#line 49
  xfree((void *)buf);
#line 50
  return;
}
}
#line 54 "bufaux.c"
int buffer_get_bignum(Buffer *buffer , BIGNUM *value ) 
{ int bits ;
  int bytes ;
  unsigned char buf[2] ;
  unsigned char *bin ;
  void *tmp ;

  {
#line 61
  buffer_get(buffer, (char *)(buf), 2U);
#line 62
  bits = (int )(((unsigned long )buf[0] << 8) | (unsigned long )buf[1]);
#line 64
  bytes = (bits + 7) / 8;
#line 65
  tmp = xmalloc((unsigned int )bytes);
#line 65
  bin = (unsigned char *)tmp;
#line 66
  buffer_get(buffer, (char *)bin, (unsigned int )bytes);
#line 67
  BN_bin2bn((unsigned char const   *)bin, bytes, value);
#line 68
  xfree((void *)bin);
#line 70
  return (2 + bytes);
}
}
#line 75 "bufaux.c"
unsigned int buffer_get_int(Buffer *buffer ) 
{ unsigned char buf[4] ;

  {
#line 78
  buffer_get(buffer, (char *)(buf), 4U);
#line 79
  return ((unsigned int )(((((unsigned long )buf[0] << 24) | ((unsigned long )buf[1] << 16)) | ((unsigned long )buf[2] << 8)) | (unsigned long )buf[3]));
}
}
#line 84 "bufaux.c"
void buffer_put_int(Buffer *buffer , unsigned int value ) 
{ char buf[4] ;

  {
#line 87
  while (1) {
#line 87
    buf[0] = (char )(value >> 24);
#line 87
    buf[1] = (char )(value >> 16);
#line 87
    buf[2] = (char )(value >> 8);
#line 87
    buf[3] = (char )value;
#line 87
    break;
  }
#line 88
  buffer_append(buffer, (char const   *)(buf), 4U);
#line 89
  return;
}
}
#line 98 "bufaux.c"
char *buffer_get_string(Buffer *buffer , unsigned int *length_ptr ) 
{ unsigned int len ;
  char *value ;
  void *tmp ;

  {
#line 103
  len = buffer_get_int(buffer);
#line 104
  if (len > 262144U) {
#line 105
    fatal("Received packet with bad string length %d", len);
  }
#line 107
  tmp = xmalloc(len + 1U);
#line 107
  value = (char *)tmp;
#line 109
  buffer_get(buffer, value, len);
#line 111
  *(value + len) = (char)0;
#line 113
  if (length_ptr) {
#line 114
    *length_ptr = len;
  }
#line 115
  return (value);
}
}
#line 120 "bufaux.c"
void buffer_put_string(Buffer *buffer , void const   *buf , unsigned int len ) 
{ 

  {
#line 122
  buffer_put_int(buffer, len);
#line 123
  buffer_append(buffer, (char const   *)buf, len);
#line 124
  return;
}
}
#line 128 "bufaux.c"
int buffer_get_char(Buffer *buffer ) 
{ char ch ;

  {
#line 131
  buffer_get(buffer, & ch, 1U);
#line 132
  return ((int )((unsigned char )ch));
}
}
#line 137 "bufaux.c"
void buffer_put_char(Buffer *buffer , int value ) 
{ char ch ;

  {
#line 139
  ch = (char )value;
#line 140
  buffer_append(buffer, (char const   *)(& ch), 1U);
#line 141
  return;
}
}
#line 1 "buffer.o"
#line 38 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                  size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 43
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 26 "xmalloc.h"
void *xrealloc(void *ptr , size_t new_size ) ;
#line 54 "buffer.h"
void buffer_consume(Buffer *buffer , unsigned int bytes ) ;
#line 57
void buffer_consume_end(Buffer *buffer , unsigned int bytes ) ;
#line 64
void buffer_dump(Buffer *buffer ) ;
#line 25 "buffer.c"
void buffer_init(Buffer *buffer ) 
{ void *tmp ;

  {
#line 27
  buffer->alloc = 4096U;
#line 28
  tmp = xmalloc(buffer->alloc);
#line 28
  buffer->buf = (char *)tmp;
#line 29
  buffer->offset = 0U;
#line 30
  buffer->end = 0U;
#line 31
  return;
}
}
#line 35 "buffer.c"
void buffer_free(Buffer *buffer ) 
{ 

  {
#line 37
  memset((void *)buffer->buf, 0, buffer->alloc);
#line 38
  xfree((void *)buffer->buf);
#line 39
  return;
}
}
#line 44 "buffer.c"
void buffer_clear(Buffer *buffer ) 
{ 

  {
#line 46
  buffer->offset = 0U;
#line 47
  buffer->end = 0U;
#line 48
  return;
}
}
#line 52 "buffer.c"
void buffer_append(Buffer *buffer , char const   *data , unsigned int len ) 
{ char *cp ;

  {
#line 55
  buffer_append_space(buffer, & cp, len);
#line 56
  memcpy((void * __restrict  )cp, (void const   * __restrict  )data, len);
#line 57
  return;
}
}
#line 63 "buffer.c"
void buffer_append_space(Buffer *buffer , char **datap , unsigned int len ) 
{ void *tmp ;

  {
#line 66
  if (buffer->offset == buffer->end) {
#line 68
    buffer->offset = 0U;
#line 69
    buffer->end = 0U;
  }
  restart: 
#line 74
  if (buffer->end + len < buffer->alloc) {
#line 76
    *datap = buffer->buf + buffer->end;
#line 77
    buffer->end += len;
#line 78
    return;
  }
#line 83
  if (buffer->offset > buffer->alloc / 2U) {
#line 85
    memmove((void *)buffer->buf, (void const   *)(buffer->buf + buffer->offset), buffer->end - buffer->offset);
#line 87
    buffer->end -= buffer->offset;
#line 88
    buffer->offset = 0U;
    goto restart;
  }
#line 93
  buffer->alloc += len + 32768U;
#line 94
  tmp = xrealloc((void *)buffer->buf, buffer->alloc);
#line 94
  buffer->buf = (char *)tmp;
  goto restart;
}
}
#line 100 "buffer.c"
unsigned int buffer_len(Buffer *buffer ) 
{ 

  {
#line 102
  return (buffer->end - buffer->offset);
}
}
#line 107 "buffer.c"
void buffer_get(Buffer *buffer , char *buf , unsigned int len ) 
{ 

  {
#line 109
  if (len > buffer->end - buffer->offset) {
#line 110
    fatal("buffer_get trying to get more bytes than in buffer");
  }
#line 111
  memcpy((void * __restrict  )buf, (void const   * __restrict  )(buffer->buf + buffer->offset),
         len);
#line 112
  buffer->offset += len;
#line 113
  return;
}
}
#line 117 "buffer.c"
void buffer_consume(Buffer *buffer , unsigned int bytes ) 
{ 

  {
#line 119
  if (bytes > buffer->end - buffer->offset) {
#line 120
    fatal("buffer_get trying to get more bytes than in buffer");
  }
#line 121
  buffer->offset += bytes;
#line 122
  return;
}
}
#line 126 "buffer.c"
void buffer_consume_end(Buffer *buffer , unsigned int bytes ) 
{ 

  {
#line 128
  if (bytes > buffer->end - buffer->offset) {
#line 129
    fatal("buffer_get trying to get more bytes than in buffer");
  }
#line 130
  buffer->end -= bytes;
#line 131
  return;
}
}
#line 135 "buffer.c"
char *buffer_ptr(Buffer *buffer ) 
{ 

  {
#line 137
  return (buffer->buf + buffer->offset);
}
}
#line 142 "buffer.c"
void buffer_dump(Buffer *buffer ) 
{ int i ;
  unsigned char *ucp ;

  {
#line 145
  ucp = (unsigned char *)buffer->buf;
#line 147
  i = (int )buffer->offset;
#line 147
  while ((unsigned int )i < buffer->end) {
#line 148
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" %02x", *(ucp + i));
#line 147
    i ++;
  }
#line 149
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 150
  return;
}
}
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
#line 1 "canohost.o"
#line 128 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int getpeername(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 185
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
#line 62 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 54 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
#line 131 "/usr/include/netdb.h"
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 138
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 352
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 335 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 83
extern __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 116
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 190
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 190 "/usr/include/ctype.h"
__inline static int tolower(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
#line 193
  if (__c >= -128) {
#line 193
    if (__c < 256) {
#line 193
      tmp___1 = __ctype_tolower_loc();
#line 193
      tmp___0 = *(*tmp___1 + __c);
    } else {
#line 193
      tmp___0 = (int const   )__c;
    }
  } else {
#line 193
    tmp___0 = (int const   )__c;
  }
#line 193
  return ((int )tmp___0);
}
}
#line 33 "packet.h"
int packet_get_connection_in(void) ;
#line 36
int packet_get_connection_out(void) ;
#line 125
void packet_disconnect(char const   *fmt  , ...) ;
#line 32 "xmalloc.h"
char *xstrdup(char const   *str ) ;
#line 284 "ssh.h"
char *get_remote_hostname(int socket___0 ) ;
#line 289
char const   *get_canonical_hostname(void) ;
#line 293
char const   *get_remote_ipaddr(void) ;
#line 296
int get_peer_port(int sock ) ;
#line 299
int get_remote_port(void) ;
#line 26 "canohost.c"
char *get_remote_hostname(int socket___0 ) 
{ struct sockaddr_in from ;
  int fromlen ;
  int i ;
  struct hostent *hp ;
  char name[64] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___3 ;
  char *tmp___5 ;
  int __res ;
  __int32_t const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  unsigned char options___0[200] ;
  unsigned char *ucp ;
  char text[1024] ;
  char *cp ;
  int option_size ;
  int ipproto ;
  struct protoent *ip ;
  char *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;

  {
#line 34
  fromlen = (int )sizeof(from);
#line 35
  memset((void *)(& from), 0, sizeof(from));
#line 36
  tmp___1 = getpeername(socket___0, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                        (socklen_t * __restrict  )(& fromlen));
#line 36
  if (tmp___1 < 0) {
#line 38
    tmp = __errno_location();
#line 38
    tmp___0 = strerror(*tmp);
#line 38
    error("getpeername failed: %.100s", tmp___0);
#line 39
    strlcpy(name, "UNKNOWN", (int )sizeof(name));
    goto check_ip_options;
  }
#line 44
  hp = gethostbyaddr((void const   *)((char *)(& from.sin_addr)), sizeof(struct in_addr ),
                     (int )from.sin_family);
#line 46
  if (hp) {
#line 49
    tmp___5 = __builtin_strchr(hp->h_name, '.');
#line 49
    if ((unsigned int )tmp___5 != (unsigned int )((char *)0)) {
#line 50
      strlcpy(name, (char const   *)hp->h_name, (int )sizeof(name));
    } else {
#line 51
      if ((unsigned int )hp->h_aliases != (unsigned int )((char **)0)) {
#line 51
        if ((unsigned int )*(hp->h_aliases + 0) != (unsigned int )((char *)0)) {
#line 51
          tmp___3 = __builtin_strchr(*(hp->h_aliases + 0), '.');
#line 51
          if ((unsigned int )tmp___3 != (unsigned int )((char *)0)) {
#line 54
            strlcpy(name, (char const   *)*(hp->h_aliases + 0), (int )sizeof(name));
          } else {
#line 56
            strlcpy(name, (char const   *)hp->h_name, (int )sizeof(name));
          }
        } else {
#line 56
          strlcpy(name, (char const   *)hp->h_name, (int )sizeof(name));
        }
      } else {
#line 56
        strlcpy(name, (char const   *)hp->h_name, (int )sizeof(name));
      }
    }
#line 60
    i = 0;
#line 60
    while (name[i]) {
#line 61
      tmp___9 = __ctype_b_loc();
#line 61
      if ((int const   )*(*tmp___9 + (int )name[i]) & 256) {
#line 62
        if (sizeof(name[i]) > 1U) {
#line 62
          __res = tolower((int )name[i]);
        } else {
#line 62
          tmp___8 = __ctype_tolower_loc();
#line 62
          __res = (int )*(*tmp___8 + (int )name[i]);
        }
#line 62
        name[i] = (char )__res;
      }
#line 60
      i ++;
    }
#line 70
    hp = gethostbyname((char const   *)(name));
#line 71
    if (! hp) {
#line 73
      log("reverse mapping checking gethostbyname for %.700s failed - POSSIBLE BREAKIN ATTEMPT!",
          name);
#line 74
      tmp___10 = inet_ntoa(from.sin_addr);
#line 74
      strlcpy(name, (char const   *)tmp___10, (int )sizeof(name));
      goto check_ip_options;
    }
#line 78
    i = 0;
#line 78
    while (*(hp->h_addr_list + i)) {
#line 79
      tmp___11 = memcmp((void const   *)*(hp->h_addr_list + i), (void const   *)(& from.sin_addr),
                        sizeof(from.sin_addr));
#line 79
      if (tmp___11 == 0) {
#line 81
        break;
      }
#line 78
      i ++;
    }
#line 83
    if (! *(hp->h_addr_list + i)) {
#line 86
      tmp___12 = inet_ntoa(from.sin_addr);
#line 86
      log("Address %.100s maps to %.600s, but this does not map back to the address - POSSIBLE BREAKIN ATTEMPT!",
          tmp___12, name);
#line 88
      tmp___13 = inet_ntoa(from.sin_addr);
#line 88
      strlcpy(name, (char const   *)tmp___13, (int )sizeof(name));
      goto check_ip_options;
    }
  } else {
#line 96
    tmp___14 = inet_ntoa(from.sin_addr);
#line 96
    strlcpy(name, (char const   *)tmp___14, (int )sizeof(name));
#line 97
    log("Could not reverse map address %.100s.", name);
  }
  check_ip_options: 
#line 116
  ip = getprotobyname("ip");
#line 116
  if ((unsigned int )ip != (unsigned int )((void *)0)) {
#line 117
    ipproto = ip->p_proto;
  } else {
#line 119
    ipproto = 0;
  }
#line 120
  option_size = (int )sizeof(options___0);
#line 121
  tmp___17 = getsockopt(0, ipproto, 4, (void * __restrict  )((char *)(options___0)),
                        (socklen_t * __restrict  )(& option_size));
#line 121
  if (tmp___17 >= 0) {
#line 121
    if (option_size != 0) {
#line 124
      cp = text;
#line 126
      ucp = options___0;
#line 126
      while (option_size > 0) {
#line 127
        sprintf((char * __restrict  )cp, (char const   * __restrict  )" %2.2x", *ucp);
#line 126
        ucp ++;
#line 126
        option_size --;
#line 126
        cp += 3;
      }
#line 128
      tmp___15 = inet_ntoa(from.sin_addr);
#line 128
      log("Connection from %.100s with IP options:%.800s", tmp___15, text);
#line 130
      tmp___16 = inet_ntoa(from.sin_addr);
#line 130
      packet_disconnect("Connection from %.100s with IP options:%.800s", tmp___16,
                        text);
    }
  }
#line 135
  tmp___18 = xstrdup((char const   *)(name));
#line 135
  return (tmp___18);
}
}
#line 138 "canohost.c"
static char *canonical_host_name  =    (char *)((void *)0);
#line 139 "canohost.c"
static char *canonical_host_ip  =    (char *)((void *)0);
#line 145 "canohost.c"
char const   *get_canonical_hostname(void) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 148
  if ((unsigned int )canonical_host_name != (unsigned int )((void *)0)) {
#line 149
    return ((char const   *)canonical_host_name);
  }
#line 152
  tmp___0 = packet_get_connection_in();
#line 152
  tmp___1 = packet_get_connection_out();
#line 152
  if (tmp___0 == tmp___1) {
#line 153
    tmp = packet_get_connection_in();
#line 153
    canonical_host_name = get_remote_hostname(tmp);
  } else {
#line 155
    canonical_host_name = xstrdup("UNKNOWN");
  }
#line 157
  return ((char const   *)canonical_host_name);
}
}
#line 163 "canohost.c"
char const   *get_remote_ipaddr(void) 
{ struct sockaddr_in from ;
  int fromlen ;
  int socket___0 ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
#line 169
  if ((unsigned int )canonical_host_ip != (unsigned int )((void *)0)) {
#line 170
    return ((char const   *)canonical_host_ip);
  }
#line 173
  tmp = packet_get_connection_in();
#line 173
  tmp___0 = packet_get_connection_out();
#line 173
  if (tmp != tmp___0) {
#line 175
    canonical_host_ip = xstrdup("UNKNOWN");
#line 176
    return ((char const   *)canonical_host_ip);
  }
#line 180
  socket___0 = packet_get_connection_in();
#line 183
  fromlen = (int )sizeof(from);
#line 184
  memset((void *)(& from), 0, sizeof(from));
#line 185
  tmp___3 = getpeername(socket___0, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                        (socklen_t * __restrict  )(& fromlen));
#line 185
  if (tmp___3 < 0) {
#line 187
    tmp___1 = __errno_location();
#line 187
    tmp___2 = strerror(*tmp___1);
#line 187
    error("getpeername failed: %.100s", tmp___2);
#line 188
    return ((char const   *)((void *)0));
  }
#line 192
  tmp___4 = inet_ntoa(from.sin_addr);
#line 192
  canonical_host_ip = xstrdup((char const   *)tmp___4);
#line 195
  return ((char const   *)canonical_host_ip);
}
}
#line 200 "canohost.c"
int get_peer_port(int sock ) 
{ struct sockaddr_in from ;
  int fromlen ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  register unsigned short __v ;
  register unsigned short __x ;

  {
#line 206
  fromlen = (int )sizeof(from);
#line 207
  memset((void *)(& from), 0, sizeof(from));
#line 208
  tmp___1 = getpeername(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                        (socklen_t * __restrict  )(& fromlen));
#line 208
  if (tmp___1 < 0) {
#line 210
    tmp = __errno_location();
#line 210
    tmp___0 = strerror(*tmp);
#line 210
    error("getpeername failed: %.100s", tmp___0);
#line 211
    return (0);
  }
#line 215
  __x = from.sin_port;
#line 215
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 215
  return ((int )__v);
}
}
#line 220 "canohost.c"
int get_remote_port(void) 
{ int socket___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 226
  tmp = packet_get_connection_in();
#line 226
  tmp___0 = packet_get_connection_out();
#line 226
  if (tmp != tmp___0) {
#line 227
    return (65535);
  }
#line 230
  socket___0 = packet_get_connection_in();
#line 233
  tmp___1 = get_peer_port(socket___0);
#line 233
  return (tmp___1);
}
}
#line 1 "channels.o"
#line 110 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  *__addr ,
                                              socklen_t __len ) ;
#line 199
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 209
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 218
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
#line 84 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strcpy(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 102
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 170
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 35 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t inet_addr(char const   *__cp ) ;
#line 357 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 407
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 290
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   * __restrict  __nptr ,
                                                            char ** __restrict  __endptr ,
                                                            int __base , int __group )  __attribute__((__nonnull__(1))) ;
#line 332
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 332 "/usr/include/stdlib.h"
__inline static long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                            int __base ) 
{ long tmp ;

  {
#line 336
  tmp = __strtol_internal(__nptr, __endptr, __base, 0);
#line 336
  return (tmp);
}
}
#line 401
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 401 "/usr/include/stdlib.h"
__inline static int atoi(char const   *__nptr ) 
{ long tmp ;

  {
#line 404
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 404
  return ((int )tmp);
}
}
#line 632
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) )  __attribute__((__nonnull__(1))) ;
#line 573 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 801
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 845
extern  __attribute__((__nothrow__)) int gethostname(char *__name , size_t __len )  __attribute__((__nonnull__(1))) ;
#line 402 "ssh.h"
void fatal_add_cleanup(void (*proc)(void *context ) , void *context ) ;
#line 410
void channel_set_options(int hostname_in_open ) ;
#line 415
int channel_allocate(int type , int sock , char *remote_name ) ;
#line 418
void channel_free(int channel ) ;
#line 421
void channel_prepare_select(fd_set *readset , fd_set *writeset ) ;
#line 425
void channel_after_select(fd_set *readset , fd_set *writeset ) ;
#line 428
void channel_output_poll(void) ;
#line 433
void channel_input_data(int payload_len ) ;
#line 436
int channel_not_very_much_buffered_data(void) ;
#line 439
void channel_input_close(void) ;
#line 442
void channel_input_close_confirmation(void) ;
#line 445
void channel_input_open_confirmation(void) ;
#line 448
void channel_input_open_failure(void) ;
#line 452
void channel_stop_listening(void) ;
#line 456
void channel_close_all(void) ;
#line 459
int channel_max_fd(void) ;
#line 462
int channel_still_open(void) ;
#line 467
char *channel_open_message(void) ;
#line 472
void channel_request_local_forwarding(int port , char const   *host , int host_port ) ;
#line 479
void channel_request_remote_forwarding(int port , char const   *host , int remote_port ) ;
#line 485
void channel_permit_all_opens(void) ;
#line 491
void channel_input_port_forward_request(int is_root ) ;
#line 496
void channel_input_port_open(int payload_len ) ;
#line 505
char *x11_create_display_inet(int screen_number ) ;
#line 510
void x11_input_open(int payload_len ) ;
#line 518
void x11_request_forwarding_with_spoofing(char const   *proto , char const   *data ) ;
#line 524
void auth_request_forwarding(void) ;
#line 529
char *auth_get_socket_name(void) ;
#line 533
void auth_input_request_forwarding(struct passwd *pw ) ;
#line 536
void auth_input_open_request(void) ;
#line 64 "packet.h"
int packet_is_interactive(void) ;
#line 67
void packet_start(int type ) ;
#line 73
void packet_put_int(unsigned int value ) ;
#line 79
void packet_put_string(char const   *buf , unsigned int len ) ;
#line 83
void packet_send(void) ;
#line 90
void packet_read_expect(int *payload_len_ptr , int expected_type ) ;
#line 109
unsigned int packet_get_int(void) ;
#line 119
char *packet_get_string(unsigned int *length_ptr ) ;
#line 142
void packet_write_wait(void) ;
#line 20 "uidswap.h"
void temporarily_use_uid(uid_t uid ) ;
#line 24
void restore_uid(void) ;
#line 47 "nchan.h"
void chan_rcvd_oclose(Channel *c ) ;
#line 48
void chan_read_failed(Channel *c ) ;
#line 49
void chan_ibuf_empty(Channel *c ) ;
#line 52
void chan_rcvd_ieof(Channel *c ) ;
#line 53
void chan_write_failed(Channel *c ) ;
#line 54
void chan_obuf_empty(Channel *c ) ;
#line 56
void chan_init_iostates(Channel *c ) ;
#line 6 "compat.h"
int compat13 ;
#line 41 "channels.c"
static Channel *channels  =    (Channel *)((void *)0);
#line 46 "channels.c"
static int channels_alloc  =    0;
#line 50 "channels.c"
static int channel_max_fd_value  =    0;
#line 53 "channels.c"
static char *channel_forwarded_auth_socket_name  =    (char *)((void *)0);
#line 54 "channels.c"
static char *channel_forwarded_auth_socket_dir  =    (char *)((void *)0);
#line 57 "channels.c"
char *x11_saved_proto  =    (char *)((void *)0);
#line 60 "channels.c"
char *x11_saved_data  =    (char *)((void *)0);
#line 61 "channels.c"
unsigned int x11_saved_data_len  =    0U;
#line 65 "channels.c"
char *x11_fake_data  =    (char *)((void *)0);
#line 66 "channels.c"
unsigned int x11_fake_data_len  ;
#line 79 "channels.c"
static ForwardPermission permitted_opens[100]  ;
#line 81 "channels.c"
static int num_permitted_opens  =    0;
#line 85 "channels.c"
static int all_opens_permitted  =    0;
#line 88 "channels.c"
static int have_hostname_in_open  =    0;
#line 92 "channels.c"
void channel_set_options(int hostname_in_open ) 
{ 

  {
#line 94
  have_hostname_in_open = hostname_in_open;
#line 95
  return;
}
}
#line 101 "channels.c"
void channel_permit_all_opens(void) 
{ 

  {
#line 103
  all_opens_permitted = 1;
#line 104
  return;
}
}
#line 109 "channels.c"
int channel_allocate(int type , int sock , char *remote_name ) 
{ int i ;
  int old_channels ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 114
  if (sock > channel_max_fd_value) {
#line 115
    channel_max_fd_value = sock;
  }
#line 118
  if (channels_alloc == 0) {
#line 120
    channels_alloc = 10;
#line 121
    tmp = xmalloc((unsigned int )channels_alloc * sizeof(Channel ));
#line 121
    channels = (Channel *)tmp;
#line 122
    i = 0;
#line 122
    while (i < channels_alloc) {
#line 123
      (channels + i)->type = 0;
#line 122
      i ++;
    }
#line 127
    fatal_add_cleanup((void (*)(void * ))(& channel_stop_listening), (void *)0);
  }
#line 131
  i = 0;
#line 131
  while (i < channels_alloc) {
#line 132
    if ((channels + i)->type == 0) {
#line 135
      buffer_init(& (channels + i)->input);
#line 136
      buffer_init(& (channels + i)->output);
#line 137
      (channels + i)->self = i;
#line 138
      (channels + i)->type = type;
#line 139
      (channels + i)->x11 = 0;
#line 140
      (channels + i)->sock = sock;
#line 141
      (channels + i)->remote_id = -1;
#line 142
      (channels + i)->remote_name = remote_name;
#line 143
      chan_init_iostates(channels + i);
#line 144
      return (i);
    }
#line 131
    i ++;
  }
#line 148
  old_channels = channels_alloc;
#line 149
  channels_alloc += 10;
#line 150
  tmp___0 = xrealloc((void *)channels, (unsigned int )channels_alloc * sizeof(Channel ));
#line 150
  channels = (Channel *)tmp___0;
#line 151
  i = old_channels;
#line 151
  while (i < channels_alloc) {
#line 152
    (channels + i)->type = 0;
#line 151
    i ++;
  }
#line 156
  buffer_init(& (channels + old_channels)->input);
#line 157
  buffer_init(& (channels + old_channels)->output);
#line 158
  (channels + old_channels)->self = old_channels;
#line 159
  (channels + old_channels)->type = type;
#line 160
  (channels + old_channels)->x11 = 0;
#line 161
  (channels + old_channels)->sock = sock;
#line 162
  (channels + old_channels)->remote_id = -1;
#line 163
  (channels + old_channels)->remote_name = remote_name;
#line 164
  chan_init_iostates(channels + old_channels);
#line 165
  return (old_channels);
}
}
#line 170 "channels.c"
void channel_free(int channel ) 
{ 

  {
#line 172
  if (channel >= 0) {
#line 172
    if (channel < channels_alloc) {
#line 172
      if (! ((channels + channel)->type != 0)) {
#line 172
        __assert_fail("channel >= 0 && channel < channels_alloc && channels[channel].type != 0",
                      "channels.c", 173U, "channel_free");
      }
    } else {
#line 172
      __assert_fail("channel >= 0 && channel < channels_alloc && channels[channel].type != 0",
                    "channels.c", 173U, "channel_free");
    }
  } else {
#line 172
    __assert_fail("channel >= 0 && channel < channels_alloc && channels[channel].type != 0",
                  "channels.c", 173U, "channel_free");
  }
#line 174
  if (compat13) {
#line 175
    shutdown((channels + channel)->sock, 2);
  }
#line 176
  close((channels + channel)->sock);
#line 177
  buffer_free(& (channels + channel)->input);
#line 178
  buffer_free(& (channels + channel)->output);
#line 179
  (channels + channel)->type = 0;
#line 180
  if ((channels + channel)->remote_name) {
#line 182
    xfree((void *)(channels + channel)->remote_name);
#line 183
    (channels + channel)->remote_name = (char *)((void *)0);
  }
#line 185
  return;
}
}
#line 190 "channels.c"
void channel_prepare_select(fd_set *readset , fd_set *writeset ) 
{ int i ;
  Channel *ch ;
  unsigned char *ucp ;
  unsigned int proto_len ;
  unsigned int data_len ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  char *tmp___6 ;
  unsigned int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 197
  i = 0;
#line 197
  while (i < channels_alloc) {
#line 199
    ch = channels + i;
    redo: 
#line 201
    switch (ch->type) {
    case 1: 
    case 2: 
    case 7: 
#line 206
    __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 207
    break;
    case 4: 
#line 210
    if (compat13) {
#line 211
      tmp = buffer_len(& ch->input);
#line 211
      if (tmp < 32768U) {
#line 212
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
#line 213
      tmp___0 = buffer_len(& ch->output);
#line 213
      if (tmp___0 > 0U) {
#line 214
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
#line 215
      break;
    }
#line 218
    if (ch->istate == 1) {
#line 219
      tmp___1 = buffer_len(& ch->input);
#line 219
      if (tmp___1 < 32768U) {
#line 220
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
#line 221
    if (ch->ostate == 16) {
      goto _L;
    } else {
#line 221
      if (ch->ostate == 32) {
        _L: /* CIL Label */ 
#line 222
        tmp___2 = buffer_len(& ch->output);
#line 222
        if (tmp___2 > 0U) {
#line 223
          __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        } else {
#line 224
          if (ch->ostate == 32) {
#line 225
            chan_obuf_empty(ch);
          }
        }
      }
    }
#line 228
    break;
    case 10: 
#line 231
    if (! compat13) {
#line 232
      fatal("cannot happen: IN_DRAIN");
    }
#line 233
    tmp___3 = buffer_len(& ch->input);
#line 233
    if (tmp___3 == 0U) {
#line 235
      packet_start(24);
#line 236
      packet_put_int((unsigned int )ch->remote_id);
#line 237
      packet_send();
#line 238
      ch->type = 5;
#line 239
      debug("Closing channel %d after input drain.", i);
#line 240
      break;
    }
#line 242
    break;
    case 11: 
#line 245
    if (! compat13) {
#line 246
      fatal("cannot happen: OUT_DRAIN");
    }
#line 247
    tmp___4 = buffer_len(& ch->output);
#line 247
    if (tmp___4 == 0U) {
#line 250
      channel_free(i);
#line 251
      break;
    }
#line 253
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 254
    break;
    case 9: 
#line 265
    tmp___5 = buffer_len(& ch->output);
#line 265
    if (tmp___5 < 12U) {
#line 266
      break;
    }
#line 269
    tmp___6 = buffer_ptr(& ch->output);
#line 269
    ucp = (unsigned char *)tmp___6;
#line 270
    if ((int )*(ucp + 0) == 66) {
#line 272
      proto_len = (unsigned int )(256 * (int )*(ucp + 6) + (int )*(ucp + 7));
#line 273
      data_len = (unsigned int )(256 * (int )*(ucp + 8) + (int )*(ucp + 9));
    } else {
#line 276
      if ((int )*(ucp + 0) == 108) {
#line 278
        proto_len = (unsigned int )((int )*(ucp + 6) + 256 * (int )*(ucp + 7));
#line 279
        data_len = (unsigned int )((int )*(ucp + 8) + 256 * (int )*(ucp + 9));
      } else {
#line 283
        debug("Initial X11 packet contains bad byte order byte: 0x%x", *(ucp + 0));
#line 285
        ch->type = 4;
        goto reject;
      }
    }
#line 290
    tmp___7 = buffer_len(& ch->output);
#line 290
    if (tmp___7 < (12U + ((proto_len + 3U) & 4294967292U)) + ((data_len + 3U) & 4294967292U)) {
#line 292
      break;
    }
#line 295
    tmp___8 = strlen((char const   *)x11_saved_proto);
#line 295
    if (proto_len != tmp___8) {
#line 298
      debug("X11 connection uses different authentication protocol.");
#line 299
      ch->type = 4;
      goto reject;
    } else {
#line 295
      tmp___9 = memcmp((void const   *)(ucp + 12), (void const   *)x11_saved_proto,
                       proto_len);
#line 295
      if (tmp___9 != 0) {
#line 298
        debug("X11 connection uses different authentication protocol.");
#line 299
        ch->type = 4;
        goto reject;
      }
    }
#line 304
    if (data_len != x11_fake_data_len) {
#line 308
      debug("X11 auth data does not match fake data.");
#line 309
      ch->type = 4;
      goto reject;
    } else {
#line 304
      tmp___10 = memcmp((void const   *)((ucp + 12) + ((proto_len + 3U) & 4294967292U)),
                        (void const   *)x11_fake_data, x11_fake_data_len);
#line 304
      if (tmp___10 != 0) {
#line 308
        debug("X11 auth data does not match fake data.");
#line 309
        ch->type = 4;
        goto reject;
      }
    }
#line 315
    if (! (x11_fake_data_len == x11_saved_data_len)) {
#line 315
      __assert_fail("x11_fake_data_len == x11_saved_data_len", "channels.c", 315U,
                    "channel_prepare_select");
    }
#line 316
    memcpy((void * __restrict  )((ucp + 12) + ((proto_len + 3U) & 4294967292U)), (void const   * __restrict  )x11_saved_data,
           x11_saved_data_len);
#line 320
    ch->type = 4;
#line 322
    ch->x11 = 1;
    goto redo;
    reject: 
#line 328
    log("X11 connection rejected because of wrong authentication.\r\n");
#line 329
    buffer_clear(& ch->input);
#line 330
    buffer_clear(& ch->output);
#line 331
    if (compat13) {
#line 332
      close(ch->sock);
#line 333
      ch->sock = -1;
#line 334
      ch->type = 5;
#line 335
      packet_start(24);
#line 336
      packet_put_int((unsigned int )ch->remote_id);
#line 337
      packet_send();
    } else {
#line 339
      debug("X11 rejected %d 0x%x 0x%x", ch->self, ch->istate, ch->ostate);
#line 340
      chan_read_failed(ch);
#line 341
      chan_write_failed(ch);
#line 342
      debug("X11 rejected %d 0x%x 0x%x", ch->self, ch->istate, ch->ostate);
    }
#line 344
    break;
    case 0: 
    default: ;
    goto __Cont;
    }
    __Cont: /* CIL Label */ 
#line 197
    i ++;
  }
#line 351
  return;
}
}
#line 356 "channels.c"
void channel_after_select(fd_set *readset , fd_set *writeset ) 
{ struct sockaddr addr ;
  int addrlen ;
  int newsock ;
  int i ;
  int newch ;
  int len ;
  Channel *ch ;
  char buf[16384] ;
  char *remote_hostname ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  register char __result ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  register char __result___0 ;
  int nchan ;
  int *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  register char __result___1 ;
  unsigned int tmp___13 ;
  register char __result___2 ;
  unsigned int tmp___14 ;
  char *tmp___15 ;
  unsigned int tmp___16 ;
  register char __result___3 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  char *tmp___19 ;
  unsigned int tmp___20 ;
  register char __result___4 ;
  unsigned int tmp___21 ;

  {
#line 364
  i = 0;
#line 364
  while (i < channels_alloc) {
#line 366
    ch = channels + i;
#line 367
    switch (ch->type) {
    case 1: 
#line 371
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 371
    if (__result) {
#line 373
      debug("X11 connection requested.");
#line 374
      addrlen = (int )sizeof(addr);
#line 375
      newsock = accept(ch->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 376
      if (newsock < 0) {
#line 378
        tmp = __errno_location();
#line 378
        tmp___0 = strerror(*tmp);
#line 378
        error("accept: %.100s", tmp___0);
#line 379
        break;
      }
#line 381
      remote_hostname = get_remote_hostname(newsock);
#line 382
      tmp___1 = get_peer_port(newsock);
#line 382
      snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"X11 connection from %.200s port %d",
               remote_hostname, tmp___1);
#line 384
      xfree((void *)remote_hostname);
#line 385
      tmp___2 = xstrdup((char const   *)(buf));
#line 385
      newch = channel_allocate(3, newsock, tmp___2);
#line 387
      packet_start(27);
#line 388
      packet_put_int((unsigned int )newch);
#line 389
      if (have_hostname_in_open) {
#line 390
        tmp___3 = strlen((char const   *)(buf));
#line 390
        packet_put_string((char const   *)(buf), tmp___3);
      }
#line 391
      packet_send();
    }
#line 393
    break;
    case 2: 
#line 398
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 398
    if (__result___0) {
#line 400
      debug("Connection to port %d forwarding to %.100s:%d requested.", ch->listening_port,
            ch->path, ch->host_port);
#line 402
      addrlen = (int )sizeof(addr);
#line 403
      newsock = accept(ch->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 404
      if (newsock < 0) {
#line 406
        tmp___4 = __errno_location();
#line 406
        tmp___5 = strerror(*tmp___4);
#line 406
        error("accept: %.100s", tmp___5);
#line 407
        break;
      }
#line 409
      remote_hostname = get_remote_hostname(newsock);
#line 410
      tmp___6 = get_peer_port(newsock);
#line 410
      snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"port %d, connection from %.200s port %d",
               ch->listening_port, remote_hostname, tmp___6);
#line 413
      xfree((void *)remote_hostname);
#line 414
      tmp___7 = xstrdup((char const   *)(buf));
#line 414
      newch = channel_allocate(3, newsock, tmp___7);
#line 416
      packet_start(29);
#line 417
      packet_put_int((unsigned int )newch);
#line 418
      tmp___8 = strlen((char const   *)(ch->path));
#line 418
      packet_put_string((char const   *)(ch->path), tmp___8);
#line 419
      packet_put_int((unsigned int )ch->host_port);
#line 420
      if (have_hostname_in_open) {
#line 421
        tmp___9 = strlen((char const   *)(buf));
#line 421
        packet_put_string((char const   *)(buf), tmp___9);
      }
#line 422
      packet_send();
    }
#line 424
    break;
    case 7: 
#line 429
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___1): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 429
    if (__result___1) {
#line 432
      len = (int )sizeof(addr);
#line 433
      newsock = accept(ch->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& len));
#line 434
      if (newsock < 0) {
#line 436
        tmp___10 = __errno_location();
#line 436
        tmp___11 = strerror(*tmp___10);
#line 436
        error("accept from auth socket: %.100s", tmp___11);
#line 437
        break;
      }
#line 440
      tmp___12 = xstrdup("accepted auth socket");
#line 440
      nchan = channel_allocate(3, newsock, tmp___12);
#line 442
      packet_start(31);
#line 443
      packet_put_int((unsigned int )nchan);
#line 444
      packet_send();
    }
#line 446
    break;
    case 4: 
#line 455
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___2): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 455
    if (__result___2) {
#line 457
      len = read(ch->sock, (void *)(buf), sizeof(buf));
#line 458
      if (len <= 0) {
#line 460
        if (compat13) {
#line 461
          tmp___13 = buffer_len(& ch->output);
#line 461
          buffer_consume(& ch->output, tmp___13);
#line 462
          ch->type = 10;
#line 463
          debug("Channel %d status set to input draining.", i);
        } else {
#line 465
          chan_read_failed(ch);
        }
#line 467
        break;
      }
#line 469
      buffer_append(& ch->input, (char const   *)(buf), (unsigned int )len);
    }
#line 472
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___3): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))),
                         "m" (writeset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 472
    if (__result___3) {
#line 472
      tmp___17 = buffer_len(& ch->output);
#line 472
      if (tmp___17 > 0U) {
#line 474
        tmp___14 = buffer_len(& ch->output);
#line 474
        tmp___15 = buffer_ptr(& ch->output);
#line 474
        len = write(ch->sock, (void const   *)tmp___15, tmp___14);
#line 476
        if (len <= 0) {
#line 478
          if (compat13) {
#line 479
            tmp___16 = buffer_len(& ch->output);
#line 479
            buffer_consume(& ch->output, tmp___16);
#line 480
            debug("Channel %d status set to input draining.", i);
#line 481
            ch->type = 10;
          } else {
#line 483
            chan_write_failed(ch);
          }
#line 485
          break;
        }
#line 487
        buffer_consume(& ch->output, (unsigned int )len);
      }
    }
#line 489
    break;
    case 11: 
#line 492
    if (! compat13) {
#line 493
      fatal("cannot happen: OUT_DRAIN");
    }
#line 495
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___4): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))),
                         "m" (writeset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 495
    if (__result___4) {
#line 495
      tmp___21 = buffer_len(& ch->output);
#line 495
      if (tmp___21 > 0U) {
#line 497
        tmp___18 = buffer_len(& ch->output);
#line 497
        tmp___19 = buffer_ptr(& ch->output);
#line 497
        len = write(ch->sock, (void const   *)tmp___19, tmp___18);
#line 499
        if (len <= 0) {
#line 500
          tmp___20 = buffer_len(& ch->output);
#line 500
          buffer_consume(& ch->output, tmp___20);
        } else {
#line 502
          buffer_consume(& ch->output, (unsigned int )len);
        }
      }
    }
#line 504
    break;
    case 9: 
    case 0: 
    default: ;
    goto __Cont;
    }
    __Cont: /* CIL Label */ 
#line 364
    i ++;
  }
#line 512
  return;
}
}
#line 516 "channels.c"
void channel_output_poll(void) 
{ int len ;
  int i ;
  Channel *ch ;
  unsigned int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 521
  i = 0;
#line 521
  while (i < channels_alloc) {
#line 523
    ch = channels + i;
#line 526
    if (ch->type != 4) {
#line 526
      if (ch->type != 10) {
        goto __Cont;
      }
    }
#line 531
    tmp = buffer_len(& ch->input);
#line 531
    len = (int )tmp;
#line 532
    if (len > 0) {
#line 535
      tmp___0 = packet_is_interactive();
#line 535
      if (tmp___0) {
#line 537
        if (len > 1024) {
#line 538
          len = 512;
        }
      } else {
#line 542
        if (len > 16384) {
#line 543
          len = 16384;
        }
      }
#line 545
      packet_start(23);
#line 546
      packet_put_int((unsigned int )ch->remote_id);
#line 547
      tmp___1 = buffer_ptr(& ch->input);
#line 547
      packet_put_string((char const   *)tmp___1, (unsigned int )len);
#line 548
      packet_send();
#line 549
      buffer_consume(& ch->input, (unsigned int )len);
    } else {
#line 551
      if (ch->istate == 2) {
#line 553
        if (compat13) {
#line 554
          fatal("cannot happen: istate == INPUT_WAIT_DRAIN for proto 1.3");
        }
#line 557
        chan_ibuf_empty(ch);
      }
    }
    __Cont: /* CIL Label */ 
#line 521
    i ++;
  }
#line 560
  return;
}
}
#line 566 "channels.c"
void channel_input_data(int payload_len ) 
{ int channel ;
  char *data ;
  unsigned int data_len ;
  unsigned int tmp ;
  int _p ;
  int _e ;

  {
#line 573
  tmp = packet_get_int();
#line 573
  channel = (int )tmp;
#line 574
  if (channel < 0) {
#line 576
    packet_disconnect("Received data for nonexistent channel %d.", channel);
  } else {
#line 574
    if (channel >= channels_alloc) {
#line 576
      packet_disconnect("Received data for nonexistent channel %d.", channel);
    } else {
#line 574
      if ((channels + channel)->type == 0) {
#line 576
        packet_disconnect("Received data for nonexistent channel %d.", channel);
      }
    }
  }
#line 579
  if ((channels + channel)->type != 4) {
#line 579
    if ((channels + channel)->type != 9) {
#line 581
      return;
    }
  }
#line 584
  data = packet_get_string(& data_len);
#line 585
  while (1) {
#line 585
    _p = payload_len;
#line 585
    _e = (int )(8U + data_len);
#line 585
    if (_p != _e) {
#line 585
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 585);
#line 585
      packet_disconnect("Packet integrity error. (%d)", 23);
    }
#line 585
    break;
  }
#line 586
  buffer_append(& (channels + channel)->output, (char const   *)data, data_len);
#line 587
  xfree((void *)data);
#line 588
  return;
}
}
#line 593 "channels.c"
int channel_not_very_much_buffered_data(void) 
{ unsigned int i ;
  Channel *ch ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 598
  i = 0U;
#line 598
  while (i < (unsigned int )channels_alloc) {
#line 600
    ch = channels + i;
#line 601
    switch (ch->type) {
    case 1: 
    case 2: 
    case 7: 
    goto __Cont;
    case 4: 
#line 608
    tmp = buffer_len(& ch->input);
#line 608
    if (tmp > 32768U) {
#line 609
      return (0);
    }
#line 610
    tmp___0 = buffer_len(& ch->output);
#line 610
    if (tmp___0 > 32768U) {
#line 611
      return (0);
    }
    goto __Cont;
    case 10: 
    case 11: 
    case 9: 
    case 0: 
    default: ;
    goto __Cont;
    }
    __Cont: /* CIL Label */ 
#line 598
    i ++;
  }
#line 621
  return (1);
}
}
#line 626 "channels.c"
void channel_input_close(void) 
{ int channel ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 631
  tmp = packet_get_int();
#line 631
  channel = (int )tmp;
#line 632
  if (channel < 0) {
#line 634
    packet_disconnect("Received data for nonexistent channel %d.", channel);
  } else {
#line 632
    if (channel >= channels_alloc) {
#line 634
      packet_disconnect("Received data for nonexistent channel %d.", channel);
    } else {
#line 632
      if ((channels + channel)->type == 0) {
#line 634
        packet_disconnect("Received data for nonexistent channel %d.", channel);
      }
    }
  }
#line 636
  if (! compat13) {
#line 638
    chan_rcvd_ieof(channels + channel);
#line 639
    return;
  }
#line 644
  packet_start(25);
#line 645
  packet_put_int((unsigned int )(channels + channel)->remote_id);
#line 646
  packet_send();
#line 653
  if ((channels + channel)->type != 5) {
#line 657
    tmp___0 = buffer_len(& (channels + channel)->input);
#line 657
    buffer_consume(& (channels + channel)->input, tmp___0);
#line 659
    (channels + channel)->type = 11;
  }
#line 663
  return;
}
}
#line 667 "channels.c"
void channel_input_close_confirmation(void) 
{ int channel ;
  unsigned int tmp ;

  {
#line 672
  tmp = packet_get_int();
#line 672
  channel = (int )tmp;
#line 673
  if (channel < 0) {
#line 674
    packet_disconnect("Received close confirmation for out-of-range channel %d.",
                      channel);
  } else {
#line 673
    if (channel >= channels_alloc) {
#line 674
      packet_disconnect("Received close confirmation for out-of-range channel %d.",
                        channel);
    }
  }
#line 677
  if (! compat13) {
#line 679
    chan_rcvd_oclose(channels + channel);
#line 680
    return;
  }
#line 683
  if ((channels + channel)->type != 5) {
#line 684
    packet_disconnect("Received close confirmation for non-closed channel %d (type %d).",
                      channel, (channels + channel)->type);
  }
#line 688
  channel_free(channel);
#line 689
  return;
}
}
#line 693 "channels.c"
void channel_input_open_confirmation(void) 
{ int channel ;
  int remote_channel ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 698
  tmp = packet_get_int();
#line 698
  channel = (int )tmp;
#line 699
  if (channel < 0) {
#line 701
    packet_disconnect("Received open confirmation for non-opening channel %d.", channel);
  } else {
#line 699
    if (channel >= channels_alloc) {
#line 701
      packet_disconnect("Received open confirmation for non-opening channel %d.",
                        channel);
    } else {
#line 699
      if ((channels + channel)->type != 3) {
#line 701
        packet_disconnect("Received open confirmation for non-opening channel %d.",
                          channel);
      }
    }
  }
#line 705
  tmp___0 = packet_get_int();
#line 705
  remote_channel = (int )tmp___0;
#line 708
  (channels + channel)->remote_id = remote_channel;
#line 709
  (channels + channel)->type = 4;
#line 710
  return;
}
}
#line 714 "channels.c"
void channel_input_open_failure(void) 
{ int channel ;
  unsigned int tmp ;

  {
#line 719
  tmp = packet_get_int();
#line 719
  channel = (int )tmp;
#line 720
  if (channel < 0) {
#line 722
    packet_disconnect("Received open failure for non-opening channel %d.", channel);
  } else {
#line 720
    if (channel >= channels_alloc) {
#line 722
      packet_disconnect("Received open failure for non-opening channel %d.", channel);
    } else {
#line 720
      if ((channels + channel)->type != 3) {
#line 722
        packet_disconnect("Received open failure for non-opening channel %d.", channel);
      }
    }
  }
#line 726
  channel_free(channel);
#line 727
  return;
}
}
#line 732 "channels.c"
void channel_stop_listening(void) 
{ int i ;

  {
#line 735
  i = 0;
#line 735
  while (i < channels_alloc) {
#line 737
    switch ((channels + i)->type) {
    case 7: 
#line 740
    close((channels + i)->sock);
#line 741
    remove((char const   *)((channels + i)->path));
#line 742
    channel_free(i);
#line 743
    break;
    case 2: 
    case 1: 
#line 746
    close((channels + i)->sock);
#line 747
    channel_free(i);
#line 748
    break;
    default: ;
#line 750
    break;
    }
#line 735
    i ++;
  }
#line 753
  return;
}
}
#line 758 "channels.c"
void channel_close_all(void) 
{ int i ;

  {
#line 761
  i = 0;
#line 761
  while (i < channels_alloc) {
#line 763
    if ((channels + i)->type != 0) {
#line 764
      close((channels + i)->sock);
    }
#line 761
    i ++;
  }
#line 766
  return;
}
}
#line 770 "channels.c"
int channel_max_fd(void) 
{ 

  {
#line 772
  return (channel_max_fd_value);
}
}
#line 777 "channels.c"
int channel_still_open(void) 
{ unsigned int i ;

  {
#line 780
  i = 0U;
#line 780
  while (i < (unsigned int )channels_alloc) {
#line 781
    switch ((channels + i)->type) {
    case 0: 
    case 1: 
    case 2: 
    case 5: 
    case 7: 
    goto __Cont;
    case 3: 
    case 4: 
    case 9: 
#line 792
    return (1);
    case 10: 
    case 11: 
#line 795
    if (! compat13) {
#line 796
      fatal("cannot happen: OUT_DRAIN");
    }
#line 797
    return (1);
    default: 
#line 799
    fatal("channel_still_open: bad channel type %d", (channels + i)->type);
    }
    __Cont: /* CIL Label */ 
#line 780
    i ++;
  }
#line 802
  return (0);
}
}
#line 809 "channels.c"
char *channel_open_message(void) 
{ Buffer buffer ;
  int i ;
  char buf[512] ;
  char *cp ;
  size_t tmp ;
  Channel *c ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 815
  buffer_init(& buffer);
#line 816
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"The following connections are open:\r\n");
#line 817
  tmp = strlen((char const   *)(buf));
#line 817
  buffer_append(& buffer, (char const   *)(buf), tmp);
#line 818
  i = 0;
#line 818
  while (i < channels_alloc) {
#line 819
    c = channels + i;
#line 820
    switch (c->type) {
    case 0: 
    case 1: 
    case 2: 
    case 5: 
    case 7: 
    goto __Cont;
    case 3: 
    case 4: 
    case 9: 
    case 10: 
    case 11: 
#line 833
    snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"  #%d/%d %.300s\r\n",
             c->self, c->type, c->remote_name);
#line 835
    tmp___0 = strlen((char const   *)(buf));
#line 835
    buffer_append(& buffer, (char const   *)(buf), tmp___0);
    goto __Cont;
    default: 
#line 838
    fatal("channel_still_open: bad channel type %d", c->type);
    }
    __Cont: /* CIL Label */ 
#line 818
    i ++;
  }
#line 842
  buffer_append(& buffer, "\000", 1U);
#line 843
  tmp___1 = buffer_ptr(& buffer);
#line 843
  cp = xstrdup((char const   *)tmp___1);
#line 844
  buffer_free(& buffer);
#line 845
  return (cp);
}
}
#line 851 "channels.c"
void channel_request_local_forwarding(int port , char const   *host , int host_port ) 
{ int ch ;
  int sock ;
  struct sockaddr_in sin ;
  size_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  register unsigned short __v ;
  register unsigned short __x ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;

  {
#line 858
  tmp = strlen(host);
#line 858
  if (tmp > sizeof((channels + 0)->path) - 1U) {
#line 859
    packet_disconnect("Forward host name too long.");
  }
#line 862
  sock = socket(2, 1, 0);
#line 863
  if (sock < 0) {
#line 864
    tmp___0 = __errno_location();
#line 864
    tmp___1 = strerror(*tmp___0);
#line 864
    packet_disconnect("socket: %.100s", tmp___1);
  }
#line 867
  memset((void *)(& sin), 0, sizeof(sin));
#line 868
  sin.sin_family = (unsigned short)2;
#line 873
  __x = (unsigned short )port;
#line 873
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 873
  sin.sin_port = __v;
#line 876
  tmp___4 = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sin)), sizeof(sin));
#line 876
  if (tmp___4 < 0) {
#line 877
    tmp___2 = __errno_location();
#line 877
    tmp___3 = strerror(*tmp___2);
#line 877
    packet_disconnect("bind: %.100s", tmp___3);
  }
#line 880
  tmp___7 = listen(sock, 5);
#line 880
  if (tmp___7 < 0) {
#line 881
    tmp___5 = __errno_location();
#line 881
    tmp___6 = strerror(*tmp___5);
#line 881
    packet_disconnect("listen: %.100s", tmp___6);
  }
#line 884
  tmp___8 = xstrdup("port listener");
#line 884
  ch = channel_allocate(2, sock, tmp___8);
#line 886
  strcpy((char * __restrict  )((channels + ch)->path), (char const   * __restrict  )host);
#line 887
  (channels + ch)->host_port = host_port;
#line 888
  (channels + ch)->listening_port = port;
#line 889
  return;
}
}
#line 894 "channels.c"
void channel_request_remote_forwarding(int port , char const   *host , int remote_port ) 
{ int payload_len ;
  size_t tmp ;

  {
#line 899
  if (num_permitted_opens >= 100) {
#line 900
    fatal("channel_request_remote_forwarding: too many forwards");
  }
#line 901
  permitted_opens[num_permitted_opens].host = xstrdup(host);
#line 902
  permitted_opens[num_permitted_opens].port = remote_port;
#line 903
  num_permitted_opens ++;
#line 906
  packet_start(28);
#line 907
  packet_put_int((unsigned int )port);
#line 908
  tmp = strlen(host);
#line 908
  packet_put_string(host, tmp);
#line 909
  packet_put_int((unsigned int )remote_port);
#line 910
  packet_send();
#line 911
  packet_write_wait();
#line 915
  packet_read_expect(& payload_len, 14);
#line 916
  return;
}
}
#line 923 "channels.c"
void channel_input_port_forward_request(int is_root ) 
{ int port ;
  int host_port ;
  char *hostname ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 929
  tmp = packet_get_int();
#line 929
  port = (int )tmp;
#line 930
  hostname = packet_get_string((unsigned int *)((void *)0));
#line 931
  tmp___0 = packet_get_int();
#line 931
  host_port = (int )tmp___0;
#line 934
  if ((port & 65535) != port) {
#line 935
    packet_disconnect("Requested forwarding of nonexistent port %d.", port);
  }
#line 939
  if (port < 1024) {
#line 939
    if (! is_root) {
#line 940
      packet_disconnect("Requested forwarding of port %d but user is not root.", port);
    }
  }
#line 944
  channel_request_local_forwarding(port, (char const   *)hostname, host_port);
#line 947
  xfree((void *)hostname);
#line 948
  return;
}
}
#line 954 "channels.c"
void channel_input_port_open(int payload_len ) 
{ int remote_channel ;
  int sock ;
  int newch ;
  int host_port ;
  int i ;
  struct sockaddr_in sin ;
  char *host ;
  char *originator_string ;
  struct hostent *hp ;
  int host_len ;
  int originator_len ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int _p ;
  int _e ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  register unsigned short __v ;
  register unsigned short __x ;
  int *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;

  {
#line 963
  tmp = packet_get_int();
#line 963
  remote_channel = (int )tmp;
#line 966
  host = packet_get_string((unsigned int *)(& host_len));
#line 969
  tmp___0 = packet_get_int();
#line 969
  host_port = (int )tmp___0;
#line 972
  if (have_hostname_in_open) {
#line 973
    originator_string = packet_get_string((unsigned int *)(& originator_len));
  } else {
#line 975
    originator_string = xstrdup("unknown (remote did not supply name)");
  }
#line 977
  while (1) {
#line 977
    _p = payload_len;
#line 977
    _e = (((8 + host_len) + 4) + 4) + originator_len;
#line 977
    if (_p != _e) {
#line 977
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 979);
#line 977
      packet_disconnect("Packet integrity error. (%d)", 29);
    }
#line 977
    break;
  }
#line 982
  if (! all_opens_permitted) {
#line 985
    i = 0;
#line 985
    while (i < num_permitted_opens) {
#line 987
      if (permitted_opens[i].port == host_port) {
#line 987
        if (0) {
#line 987
          __s1_len = strlen((char const   *)permitted_opens[i].host);
#line 987
          __s2_len = strlen((char const   *)host);
#line 987
          if (! ((unsigned int )((void const   *)(permitted_opens[i].host + 1)) - (unsigned int )((void const   *)permitted_opens[i].host) == 1U)) {
            goto _L___0;
          } else {
#line 987
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 987
              if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
#line 987
                tmp___10 = 1;
              } else {
#line 987
                if (__s2_len >= 4U) {
#line 987
                  tmp___10 = 1;
                } else {
#line 987
                  tmp___10 = 0;
                }
              }
            } else {
#line 987
              tmp___10 = 0;
            }
          }
#line 987
          if (tmp___10) {
#line 987
            tmp___6 = __builtin_strcmp((char const   *)permitted_opens[i].host, (char const   *)host);
          } else {
#line 987
            tmp___9 = __builtin_strcmp((char const   *)permitted_opens[i].host, (char const   *)host);
#line 987
            tmp___6 = tmp___9;
          }
        } else {
#line 987
          tmp___9 = __builtin_strcmp((char const   *)permitted_opens[i].host, (char const   *)host);
#line 987
          tmp___6 = tmp___9;
        }
#line 987
        if (tmp___6 == 0) {
#line 988
          break;
        }
      }
#line 985
      i ++;
    }
#line 991
    if (i >= num_permitted_opens) {
#line 994
      log("Received request to connect to %.100s:%d, but the request was denied.",
          host, host_port);
#line 996
      packet_start(22);
#line 997
      packet_put_int((unsigned int )remote_channel);
#line 998
      packet_send();
    }
  }
#line 1002
  memset((void *)(& sin), 0, sizeof(sin));
#line 1003
  sin.sin_addr.s_addr = inet_addr((char const   *)host);
#line 1004
  if ((sin.sin_addr.s_addr & 4294967295U) != 4294967295U) {
#line 1007
    sin.sin_family = (unsigned short)2;
  } else {
#line 1012
    hp = gethostbyname((char const   *)host);
#line 1013
    if (! hp) {
#line 1015
      error("%.100s: unknown host.", host);
      goto fail;
    }
#line 1018
    if (! *(hp->h_addr_list + 0)) {
#line 1020
      error("%.100s: host has no IP address.", host);
      goto fail;
    }
#line 1023
    sin.sin_family = (unsigned short )hp->h_addrtype;
#line 1024
    memcpy((void * __restrict  )(& sin.sin_addr), (void const   * __restrict  )*(hp->h_addr_list + 0),
           sizeof(sin.sin_addr));
  }
#line 1027
  __x = (unsigned short )host_port;
#line 1027
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 1027
  sin.sin_port = __v;
#line 1030
  sock = socket((int )sin.sin_family, 1, 0);
#line 1031
  if (sock < 0) {
#line 1033
    tmp___11 = __errno_location();
#line 1033
    tmp___12 = strerror(*tmp___11);
#line 1033
    error("socket: %.100s", tmp___12);
    goto fail;
  }
#line 1038
  tmp___15 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sin)),
                     sizeof(sin));
#line 1038
  if (tmp___15 < 0) {
#line 1040
    tmp___13 = __errno_location();
#line 1040
    tmp___14 = strerror(*tmp___13);
#line 1040
    error("connect %.100s:%d: %.100s", host, host_port, tmp___14);
#line 1042
    close(sock);
    goto fail;
  }
#line 1049
  newch = channel_allocate(4, sock, originator_string);
#line 1050
  (channels + newch)->remote_id = remote_channel;
#line 1053
  packet_start(21);
#line 1054
  packet_put_int((unsigned int )remote_channel);
#line 1055
  packet_put_int((unsigned int )newch);
#line 1056
  packet_send();
#line 1059
  xfree((void *)host);
#line 1061
  return;
  fail: 
#line 1065
  xfree((void *)host);
#line 1068
  packet_start(22);
#line 1069
  packet_put_int((unsigned int )remote_channel);
#line 1070
  packet_send();
#line 1071
  return;
}
}
#line 1079
ServerOptions options ;
#line 1077 "channels.c"
char *x11_create_display_inet(int screen_number ) 
{ int display_number ;
  int port ;
  int sock ;
  struct sockaddr_in sin ;
  char buf[512] ;
  char hostname[64] ;
  register unsigned int __v ;
  register unsigned int __x ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
#line 1085
  display_number = options.x11_display_offset;
#line 1085
  while (display_number < 1000) {
#line 1087
    port = 6000 + display_number;
#line 1088
    memset((void *)(& sin), 0, sizeof(sin));
#line 1089
    sin.sin_family = (unsigned short)2;
#line 1090
    __x = 0U;
#line 1090
    __asm__  ("rorw $8, %w0;"
              "rorl $16, %0;"
              "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 1090
    sin.sin_addr.s_addr = __v;
#line 1091
    __x___0 = (unsigned short )port;
#line 1091
    __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 1091
    sin.sin_port = __v___0;
#line 1093
    sock = socket(2, 1, 0);
#line 1094
    if (sock < 0) {
#line 1096
      tmp = __errno_location();
#line 1096
      tmp___0 = strerror(*tmp);
#line 1096
      error("socket: %.100s", tmp___0);
#line 1097
      return ((char *)((void *)0));
    }
#line 1100
    tmp___3 = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sin)),
                   sizeof(sin));
#line 1100
    if (tmp___3 < 0) {
#line 1102
      tmp___1 = __errno_location();
#line 1102
      tmp___2 = strerror(*tmp___1);
#line 1102
      debug("bind port %d: %.100s", port, tmp___2);
#line 1103
      shutdown(sock, 2);
#line 1104
      close(sock);
      goto __Cont;
    }
#line 1107
    break;
    __Cont: /* CIL Label */ 
#line 1085
    display_number ++;
  }
#line 1109
  if (display_number >= 1000) {
#line 1111
    error("Failed to allocate internet-domain X11 display socket.");
#line 1112
    return ((char *)((void *)0));
  }
#line 1116
  tmp___6 = listen(sock, 5);
#line 1116
  if (tmp___6 < 0) {
#line 1118
    tmp___4 = __errno_location();
#line 1118
    tmp___5 = strerror(*tmp___4);
#line 1118
    error("listen: %.100s", tmp___5);
#line 1119
    shutdown(sock, 2);
#line 1120
    close(sock);
#line 1121
    return ((char *)((void *)0));
  }
#line 1125
  tmp___9 = gethostname(hostname, sizeof(hostname));
#line 1125
  if (tmp___9 < 0) {
#line 1126
    tmp___7 = __errno_location();
#line 1126
    tmp___8 = strerror(*tmp___7);
#line 1126
    fatal("gethostname: %.100s", tmp___8);
  }
#line 1127
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%.400s:%d.%d",
           hostname, display_number, screen_number);
#line 1131
  tmp___10 = xstrdup("X11 inet listener");
#line 1131
  channel_allocate(1, sock, tmp___10);
#line 1135
  tmp___11 = xstrdup((char const   *)(buf));
#line 1135
  return (tmp___11);
}
}
#line 1146
static int connect_local_xsocket(unsigned int dnr ) ;
#line 1146 "channels.c"
static char const   * const  x_sockets[4]  = {      (char const   * const  )"/tmp/.X11-unix/X%u",      (char const   * const  )"/var/X/.X11-unix/X%u",      (char const   * const  )"/usr/spool/sockets/X11/%u",      (char const   * const  )((void *)0)};
#line 1142 "channels.c"
static int connect_local_xsocket(unsigned int dnr ) 
{ int sock ;
  struct sockaddr_un addr ;
  char const   * const  *path ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 1156
  path = x_sockets;
#line 1156
  while (*path) {
#line 1158
    sock = socket(1, 1, 0);
#line 1159
    if (sock < 0) {
#line 1160
      tmp = __errno_location();
#line 1160
      tmp___0 = strerror(*tmp);
#line 1160
      error("socket: %.100s", tmp___0);
    }
#line 1161
    memset((void *)(& addr), 0, sizeof(addr));
#line 1162
    addr.sun_family = (unsigned short)1;
#line 1163
    snprintf((char * __restrict  )(addr.sun_path), sizeof(addr.sun_path), (char const   * __restrict  )*path,
             dnr);
#line 1164
    tmp___1 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& addr)),
                      sizeof(addr));
#line 1164
    if (tmp___1 == 0) {
#line 1165
      return (sock);
    }
#line 1166
    close(sock);
#line 1156
    path ++;
  }
#line 1168
  tmp___2 = __errno_location();
#line 1168
  tmp___3 = strerror(*tmp___2);
#line 1168
  error("connect %.100s: %.100s", addr.sun_path, tmp___3);
#line 1169
  return (-1);
}
}
#line 1177 "channels.c"
void x11_input_open(int payload_len ) 
{ int remote_channel ;
  int display_number ;
  int sock ;
  int newch ;
  char const   *display ;
  struct sockaddr_in sin ;
  char buf[1024] ;
  char *cp ;
  char *remote_host ;
  struct hostent *hp ;
  int remote_len ;
  unsigned int tmp ;
  int _p ;
  int _e ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___16 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  char *tmp___30 ;
  int tmp___31 ;
  register unsigned short __v ;
  register unsigned short __x ;
  int *tmp___32 ;
  char *tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;

  {
#line 1187
  tmp = packet_get_int();
#line 1187
  remote_channel = (int )tmp;
#line 1190
  if (have_hostname_in_open) {
#line 1191
    remote_host = packet_get_string((unsigned int *)(& remote_len));
  } else {
#line 1193
    remote_host = xstrdup("unknown (remote did not supply name)");
  }
#line 1195
  debug("Received X11 open request.");
#line 1196
  while (1) {
#line 1196
    _p = payload_len;
#line 1196
    _e = 8 + remote_len;
#line 1196
    if (_p != _e) {
#line 1196
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1196);
#line 1196
      packet_disconnect("Packet integrity error. (%d)", 27);
    }
#line 1196
    break;
  }
#line 1199
  tmp___0 = getenv("DISPLAY");
#line 1199
  display = (char const   *)tmp___0;
#line 1200
  if (! display) {
#line 1202
    error("DISPLAY not set.");
    goto fail;
  }
#line 1211
  if (0) {
#line 1211
    if (0) {
#line 1211
      __s1_len___0 = strlen(display);
#line 1211
      __s2_len___0 = strlen("unix:");
#line 1211
      if (! ((unsigned int )((void const   *)(display + 1)) - (unsigned int )((void const   *)display) == 1U)) {
        goto _L___2;
      } else {
#line 1211
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 1211
          if (! ((unsigned int )((void const   *)("unix:" + 1)) - (unsigned int )((void const   *)"unix:") == 1U)) {
#line 1211
            tmp___26 = 1;
          } else {
#line 1211
            if (__s2_len___0 >= 4U) {
#line 1211
              tmp___26 = 1;
            } else {
#line 1211
              tmp___26 = 0;
            }
          }
        } else {
#line 1211
          tmp___26 = 0;
        }
      }
#line 1211
      if (tmp___26) {
#line 1211
        tmp___22 = __builtin_strcmp(display, "unix:");
      } else {
#line 1211
        tmp___25 = __builtin_strcmp(display, "unix:");
#line 1211
        tmp___22 = tmp___25;
      }
    } else {
#line 1211
      tmp___25 = __builtin_strcmp(display, "unix:");
#line 1211
      tmp___22 = tmp___25;
    }
#line 1211
    tmp___16 = tmp___22;
  } else {
#line 1211
    tmp___16 = strncmp(display, "unix:", 5U);
  }
#line 1211
  if (tmp___16 == 0) {
    goto _L___3;
  } else {
#line 1211
    if ((int const   )*(display + 0) == 58) {
      _L___3: /* CIL Label */ 
#line 1215
      tmp___1 = strrchr(display, ':');
#line 1215
      tmp___2 = sscanf((char const   * __restrict  )(tmp___1 + 1), (char const   * __restrict  )"%d",
                       & display_number);
#line 1215
      if (tmp___2 != 1) {
#line 1217
        error("Could not parse display number from DISPLAY: %.100s", display);
        goto fail;
      }
#line 1222
      sock = connect_local_xsocket((unsigned int )display_number);
#line 1223
      if (sock < 0) {
        goto fail;
      }
      goto success;
    }
  }
#line 1232
  __builtin_strncpy(buf, display, sizeof(buf));
#line 1233
  buf[sizeof(buf) - 1U] = (char)0;
#line 1234
  tmp___30 = __builtin_strchr(buf, ':');
#line 1234
  cp = tmp___30;
#line 1235
  if (! cp) {
#line 1237
    error("Could not find \':\' in DISPLAY: %.100s", display);
    goto fail;
  }
#line 1240
  *cp = (char)0;
#line 1242
  tmp___31 = sscanf((char const   * __restrict  )(cp + 1), (char const   * __restrict  )"%d",
                    & display_number);
#line 1242
  if (tmp___31 != 1) {
#line 1244
    error("Could not parse display number from DISPLAY: %.100s", display);
    goto fail;
  }
#line 1250
  memset((void *)(& sin), 0, sizeof(sin));
#line 1251
  sin.sin_addr.s_addr = inet_addr((char const   *)(buf));
#line 1252
  if ((sin.sin_addr.s_addr & 4294967295U) != 4294967295U) {
#line 1255
    sin.sin_family = (unsigned short)2;
  } else {
#line 1261
    hp = gethostbyname((char const   *)(buf));
#line 1262
    if (! hp) {
#line 1264
      error("%.100s: unknown host.", buf);
      goto fail;
    }
#line 1267
    if (! *(hp->h_addr_list + 0)) {
#line 1269
      error("%.100s: host has no IP address.", buf);
      goto fail;
    }
#line 1272
    sin.sin_family = (unsigned short )hp->h_addrtype;
#line 1273
    memcpy((void * __restrict  )(& sin.sin_addr), (void const   * __restrict  )*(hp->h_addr_list + 0),
           sizeof(sin.sin_addr));
  }
#line 1277
  __x = (unsigned short )(6000 + display_number);
#line 1277
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 1277
  sin.sin_port = __v;
#line 1280
  sock = socket((int )sin.sin_family, 1, 0);
#line 1281
  if (sock < 0) {
#line 1283
    tmp___32 = __errno_location();
#line 1283
    tmp___33 = strerror(*tmp___32);
#line 1283
    error("socket: %.100s", tmp___33);
    goto fail;
  }
#line 1287
  tmp___36 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sin)),
                     sizeof(sin));
#line 1287
  if (tmp___36 < 0) {
#line 1289
    tmp___34 = __errno_location();
#line 1289
    tmp___35 = strerror(*tmp___34);
#line 1289
    error("connect %.100s:%d: %.100s", buf, 6000 + display_number, tmp___35);
#line 1291
    close(sock);
    goto fail;
  }
  success: 
#line 1299
  if ((unsigned int )x11_saved_proto == (unsigned int )((void *)0)) {
#line 1300
    newch = channel_allocate(4, sock, remote_host);
  } else {
#line 1302
    newch = channel_allocate(9, sock, remote_host);
  }
#line 1303
  (channels + newch)->remote_id = remote_channel;
#line 1306
  packet_start(21);
#line 1307
  packet_put_int((unsigned int )remote_channel);
#line 1308
  packet_put_int((unsigned int )newch);
#line 1309
  packet_send();
#line 1311
  return;
  fail: 
#line 1315
  packet_start(22);
#line 1316
  packet_put_int((unsigned int )remote_channel);
#line 1317
  packet_send();
#line 1318
  return;
}
}
#line 1323 "channels.c"
void x11_request_forwarding_with_spoofing(char const   *proto , char const   *data ) 
{ unsigned int data_len ;
  size_t tmp ;
  unsigned int i ;
  unsigned int value ;
  char *new_data ;
  int screen_number ;
  char const   *cp ;
  u_int32_t rand___0 ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  unsigned char tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;

  {
#line 1325
  tmp = strlen(data);
#line 1325
  data_len = tmp / 2U;
#line 1330
  rand___0 = (u_int32_t )0;
#line 1332
  tmp___0 = getenv("DISPLAY");
#line 1332
  cp = (char const   *)tmp___0;
#line 1333
  if (cp) {
#line 1334
    tmp___2 = __builtin_strchr((char *)cp, ':');
#line 1334
    cp = (char const   *)tmp___2;
  }
#line 1335
  if (cp) {
#line 1336
    tmp___4 = __builtin_strchr((char *)cp, '.');
#line 1336
    cp = (char const   *)tmp___4;
  }
#line 1337
  if (cp) {
#line 1338
    screen_number = atoi(cp + 1);
  } else {
#line 1340
    screen_number = 0;
  }
#line 1343
  x11_saved_proto = xstrdup(proto);
#line 1347
  tmp___5 = xmalloc(data_len);
#line 1347
  x11_saved_data = (char *)tmp___5;
#line 1348
  tmp___6 = xmalloc(data_len);
#line 1348
  x11_fake_data = (char *)tmp___6;
#line 1349
  i = 0U;
#line 1349
  while (i < data_len) {
#line 1351
    tmp___7 = sscanf((char const   * __restrict  )(data + 2U * i), (char const   * __restrict  )"%2x",
                     & value);
#line 1351
    if (tmp___7 != 1) {
#line 1352
      fatal("x11_request_forwarding: bad authentication data: %.100s", data);
    }
#line 1353
    if (i % 4U == 0U) {
#line 1354
      tmp___8 = arc4random();
#line 1354
      rand___0 = (unsigned int )tmp___8;
    }
#line 1355
    *(x11_saved_data + i) = (char )value;
#line 1356
    *(x11_fake_data + i) = (char )(rand___0 & 255U);
#line 1357
    rand___0 >>= 8;
#line 1349
    i ++;
  }
#line 1359
  x11_saved_data_len = data_len;
#line 1360
  x11_fake_data_len = data_len;
#line 1363
  tmp___9 = xmalloc(2U * data_len + 1U);
#line 1363
  new_data = (char *)tmp___9;
#line 1364
  i = 0U;
#line 1364
  while (i < data_len) {
#line 1365
    sprintf((char * __restrict  )(new_data + 2U * i), (char const   * __restrict  )"%02x",
            (unsigned char )*(x11_fake_data + i));
#line 1364
    i ++;
  }
#line 1368
  packet_start(34);
#line 1369
  tmp___10 = strlen(proto);
#line 1369
  packet_put_string(proto, tmp___10);
#line 1370
  tmp___11 = strlen((char const   *)new_data);
#line 1370
  packet_put_string((char const   *)new_data, tmp___11);
#line 1371
  packet_put_int((unsigned int )screen_number);
#line 1372
  packet_send();
#line 1373
  packet_write_wait();
#line 1374
  xfree((void *)new_data);
#line 1375
  return;
}
}
#line 1379 "channels.c"
void auth_request_forwarding(void) 
{ 

  {
#line 1381
  packet_start(30);
#line 1382
  packet_send();
#line 1383
  packet_write_wait();
#line 1384
  return;
}
}
#line 1390 "channels.c"
char *auth_get_socket_name(void) 
{ 

  {
#line 1392
  return (channel_forwarded_auth_socket_name);
}
}
#line 1397 "channels.c"
void cleanup_socket(void) 
{ 

  {
#line 1398
  remove((char const   *)channel_forwarded_auth_socket_name);
#line 1399
  rmdir((char const   *)channel_forwarded_auth_socket_dir);
#line 1400
  return;
}
}
#line 1405 "channels.c"
void auth_input_request_forwarding(struct passwd *pw ) 
{ int sock ;
  int newch ;
  struct sockaddr_un sunaddr ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  __pid_t tmp___5 ;
  int saved ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;

  {
#line 1410
  tmp = auth_get_socket_name();
#line 1410
  if ((unsigned int )tmp != (unsigned int )((void *)0)) {
#line 1411
    fatal("Protocol error: authentication forwarding requested twice.");
  }
#line 1414
  temporarily_use_uid(pw->pw_uid);
#line 1417
  tmp___0 = xmalloc(100U);
#line 1417
  channel_forwarded_auth_socket_name = (char *)tmp___0;
#line 1418
  tmp___1 = xmalloc(100U);
#line 1418
  channel_forwarded_auth_socket_dir = (char *)tmp___1;
#line 1419
  strlcpy(channel_forwarded_auth_socket_dir, "/tmp/ssh-XXXXXXXX", 100);
#line 1422
  tmp___4 = mkdtemp(channel_forwarded_auth_socket_dir);
#line 1422
  if ((unsigned int )tmp___4 == (unsigned int )((void *)0)) {
#line 1423
    tmp___2 = __errno_location();
#line 1423
    tmp___3 = strerror(*tmp___2);
#line 1423
    packet_disconnect("mkdtemp: %.100s", tmp___3);
  }
#line 1424
  tmp___5 = getpid();
#line 1424
  snprintf((char * __restrict  )channel_forwarded_auth_socket_name, 100U, (char const   * __restrict  )"%s/agent.%d",
           channel_forwarded_auth_socket_dir, tmp___5);
#line 1427
  tmp___8 = atexit(& cleanup_socket);
#line 1427
  if (tmp___8 < 0) {
#line 1428
    tmp___6 = __errno_location();
#line 1428
    saved = *tmp___6;
#line 1429
    cleanup_socket();
#line 1430
    tmp___7 = strerror(saved);
#line 1430
    packet_disconnect("socket: %.100s", tmp___7);
  }
#line 1434
  sock = socket(1, 1, 0);
#line 1435
  if (sock < 0) {
#line 1436
    tmp___9 = __errno_location();
#line 1436
    tmp___10 = strerror(*tmp___9);
#line 1436
    packet_disconnect("socket: %.100s", tmp___10);
  }
#line 1439
  memset((void *)(& sunaddr), 0, sizeof(sunaddr));
#line 1440
  sunaddr.sun_family = (unsigned short)1;
#line 1441
  __builtin_strncpy(sunaddr.sun_path, (char const   *)channel_forwarded_auth_socket_name,
                    sizeof(sunaddr.sun_path));
#line 1444
  tmp___13 = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sunaddr)),
                  sizeof(sunaddr));
#line 1444
  if (tmp___13 < 0) {
#line 1445
    tmp___11 = __errno_location();
#line 1445
    tmp___12 = strerror(*tmp___11);
#line 1445
    packet_disconnect("bind: %.100s", tmp___12);
  }
#line 1448
  restore_uid();
#line 1451
  tmp___16 = listen(sock, 5);
#line 1451
  if (tmp___16 < 0) {
#line 1452
    tmp___14 = __errno_location();
#line 1452
    tmp___15 = strerror(*tmp___14);
#line 1452
    packet_disconnect("listen: %.100s", tmp___15);
  }
#line 1455
  tmp___17 = xstrdup("auth socket");
#line 1455
  newch = channel_allocate(7, sock, tmp___17);
#line 1457
  strcpy((char * __restrict  )((channels + newch)->path), (char const   * __restrict  )channel_forwarded_auth_socket_name);
#line 1458
  return;
}
}
#line 1462 "channels.c"
void auth_input_open_request(void) 
{ int remch ;
  int sock ;
  int newch ;
  char *dummyname ;
  unsigned int tmp ;

  {
#line 1468
  tmp = packet_get_int();
#line 1468
  remch = (int )tmp;
#line 1472
  sock = ssh_get_authentication_socket();
#line 1478
  if (sock < 0) {
#line 1479
    packet_start(22);
#line 1480
    packet_put_int((unsigned int )remch);
#line 1481
    packet_send();
#line 1482
    return;
  }
#line 1485
  debug("Forwarding authentication connection.");
#line 1490
  dummyname = xstrdup("authentication agent connection");
#line 1492
  newch = channel_allocate(4, sock, dummyname);
#line 1493
  (channels + newch)->remote_id = remch;
#line 1496
  packet_start(21);
#line 1497
  packet_put_int((unsigned int )remch);
#line 1498
  packet_put_int((unsigned int )newch);
#line 1499
  packet_send();
#line 1500
  return;
}
}
#line 1 "cipher.o"
#line 138 "/usr/include/openssl/des.h"
extern void DES_cbc_encrypt(unsigned char const   *input , unsigned char *output ,
                            long length , DES_key_schedule *schedule , DES_cblock *ivec ,
                            int enc ) ;
#line 222
extern int DES_set_key(const_DES_cblock *key , DES_key_schedule *schedule ) ;
#line 108 "/usr/include/openssl/blowfish.h"
extern void BF_set_key(BF_KEY *key , int len , unsigned char const   *data ) ;
#line 115
extern void BF_cbc_encrypt(unsigned char const   *in , unsigned char *out , long length ,
                           BF_KEY const   *schedule , unsigned char *ivec , int enc ) ;
#line 60 "cipher.h"
int cipher_number(char const   *name ) ;
#line 64
void cipher_set_key(CipherContext *context , int cipher , unsigned char const   *key ,
                    int keylen , int for_encryption ) ;
#line 82
void (*cipher_attack_detected)(char const   *fmt  , ...) ;
#line 107 "/usr/include/openssl/md5.h"
extern int MD5_Init(MD5_CTX *c ) ;
#line 108
extern int MD5_Update(MD5_CTX *c , void const   *data , size_t len ) ;
#line 109
extern int MD5_Final(unsigned char *md , MD5_CTX *c ) ;
#line 34 "cipher.c"
void SSH_3CBC_ENCRYPT(DES_key_schedule ks1 , DES_key_schedule ks2 , DES_cblock *iv2 ,
                      DES_key_schedule ks3 , DES_cblock *iv3 , void *dest , void *src ,
                      unsigned int len ) 
{ DES_cblock iv1 ;

  {
#line 43
  memcpy((void * __restrict  )(& iv1), (void const   * __restrict  )iv2, 8U);
#line 45
  DES_cbc_encrypt((unsigned char const   *)src, (unsigned char *)dest, (long )len,
                  & ks1, & iv1, 1);
#line 46
  memcpy((void * __restrict  )(& iv1), (void const   * __restrict  )((dest + len) - 8),
         8U);
#line 48
  DES_cbc_encrypt((unsigned char const   *)dest, (unsigned char *)dest, (long )len,
                  & ks2, iv2, 0);
#line 49
  memcpy((void * __restrict  )iv2, (void const   * __restrict  )(& iv1), 8U);
#line 51
  DES_cbc_encrypt((unsigned char const   *)dest, (unsigned char *)dest, (long )len,
                  & ks3, iv3, 1);
#line 52
  memcpy((void * __restrict  )iv3, (void const   * __restrict  )((dest + len) - 8),
         8U);
#line 53
  return;
}
}
#line 55 "cipher.c"
void SSH_3CBC_DECRYPT(DES_key_schedule ks1 , DES_key_schedule ks2 , DES_cblock *iv2 ,
                      DES_key_schedule ks3 , DES_cblock *iv3 , void *dest , void *src ,
                      unsigned int len ) 
{ DES_cblock iv1 ;

  {
#line 64
  memcpy((void * __restrict  )(& iv1), (void const   * __restrict  )iv2, 8U);
#line 66
  DES_cbc_encrypt((unsigned char const   *)src, (unsigned char *)dest, (long )len,
                  & ks3, iv3, 0);
#line 67
  memcpy((void * __restrict  )iv3, (void const   * __restrict  )((src + len) - 8),
         8U);
#line 69
  DES_cbc_encrypt((unsigned char const   *)dest, (unsigned char *)dest, (long )len,
                  & ks2, iv2, 1);
#line 70
  memcpy((void * __restrict  )iv2, (void const   * __restrict  )((dest + len) - 8),
         8U);
#line 72
  DES_cbc_encrypt((unsigned char const   *)dest, (unsigned char *)dest, (long )len,
                  & ks1, & iv1, 0);
#line 74
  return;
}
}
#line 80 "cipher.c"
static void swap_bytes(unsigned char const   *src , unsigned char *dst_ , int n___0 ) 
{ u_int32_t *dst ;
  union __anonunion_t_75 t ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  u_int32_t *tmp___3 ;
  unsigned char const   *tmp___4 ;
  unsigned char const   *tmp___5 ;
  unsigned char const   *tmp___6 ;
  unsigned char const   *tmp___7 ;
  u_int32_t *tmp___8 ;

  {
#line 84
  dst = (u_int32_t *)dst_;
#line 93
  n___0 /= 8;
#line 93
  while (n___0 > 0) {
#line 95
    tmp = src;
#line 95
    src ++;
#line 95
    t.c[3] = (char )*tmp;
#line 96
    tmp___0 = src;
#line 96
    src ++;
#line 96
    t.c[2] = (char )*tmp___0;
#line 97
    tmp___1 = src;
#line 97
    src ++;
#line 97
    t.c[1] = (char )*tmp___1;
#line 98
    tmp___2 = src;
#line 98
    src ++;
#line 98
    t.c[0] = (char )*tmp___2;
#line 99
    tmp___3 = dst;
#line 99
    dst ++;
#line 99
    *tmp___3 = t.i;
#line 101
    tmp___4 = src;
#line 101
    src ++;
#line 101
    t.c[3] = (char )*tmp___4;
#line 102
    tmp___5 = src;
#line 102
    src ++;
#line 102
    t.c[2] = (char )*tmp___5;
#line 103
    tmp___6 = src;
#line 103
    src ++;
#line 103
    t.c[1] = (char )*tmp___6;
#line 104
    tmp___7 = src;
#line 104
    src ++;
#line 104
    t.c[0] = (char )*tmp___7;
#line 105
    tmp___8 = dst;
#line 105
    dst ++;
#line 105
    *tmp___8 = t.i;
#line 93
    n___0 --;
  }
#line 107
  return;
}
}
#line 109 "cipher.c"
void (*cipher_attack_detected)(char const   *fmt  , ...)  =    & fatal;
#line 111 "cipher.c"
__inline static void detect_cbc_attack(unsigned char const   *src , unsigned int len ) 
{ 

  {
#line 116
  return;
#line 118
  log("CRC-32 CBC insertion attack detected");
#line 119
  (*cipher_attack_detected)("CRC-32 CBC insertion attack detected");
}
}
#line 124 "cipher.c"
static char *cipher_names[7]  = {      (char *)"none",      (char *)"idea",      (char *)"des",      (char *)"3des", 
        (char *)"tss",      (char *)"rc4",      (char *)"blowfish"};
#line 139 "cipher.c"
unsigned int cipher_mask(void) 
{ unsigned int mask ;

  {
#line 141
  mask = 0U;
#line 142
  mask |= (unsigned int )(1 << 3);
#line 143
  mask |= (unsigned int )(1 << 6);
#line 144
  return (mask);
}
}
#line 149 "cipher.c"
char const   *cipher_name(int cipher ) 
{ 

  {
#line 152
  if (cipher < 0) {
#line 154
    fatal("cipher_name: bad cipher number: %d", cipher);
  } else {
#line 152
    if ((unsigned int )cipher >= sizeof(cipher_names) / sizeof(cipher_names[0])) {
#line 154
      fatal("cipher_name: bad cipher number: %d", cipher);
    } else {
#line 152
      if ((unsigned int )cipher_names[cipher] == (unsigned int )((void *)0)) {
#line 154
        fatal("cipher_name: bad cipher number: %d", cipher);
      }
    }
  }
#line 155
  return ((char const   *)cipher_names[cipher]);
}
}
#line 161 "cipher.c"
int cipher_number(char const   *name ) 
{ int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 165
  i = 0;
#line 165
  while ((unsigned int )i < sizeof(cipher_names) / sizeof(cipher_names[0])) {
#line 166
    if (0) {
#line 166
      __s1_len = strlen((char const   *)cipher_names[i]);
#line 166
      __s2_len = strlen(name);
#line 166
      if (! ((unsigned int )((void const   *)(cipher_names[i] + 1)) - (unsigned int )((void const   *)cipher_names[i]) == 1U)) {
        goto _L___0;
      } else {
#line 166
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 166
          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
#line 166
            tmp___8 = 1;
          } else {
#line 166
            if (__s2_len >= 4U) {
#line 166
              tmp___8 = 1;
            } else {
#line 166
              tmp___8 = 0;
            }
          }
        } else {
#line 166
          tmp___8 = 0;
        }
      }
#line 166
      if (tmp___8) {
#line 166
        tmp___4 = __builtin_strcmp((char const   *)cipher_names[i], name);
      } else {
#line 166
        tmp___7 = __builtin_strcmp((char const   *)cipher_names[i], name);
#line 166
        tmp___4 = tmp___7;
      }
    } else {
#line 166
      tmp___7 = __builtin_strcmp((char const   *)cipher_names[i], name);
#line 166
      tmp___4 = tmp___7;
    }
#line 166
    if (tmp___4 == 0) {
#line 166
      tmp___9 = cipher_mask();
#line 166
      if (tmp___9 & (unsigned int )(1 << i)) {
#line 168
        return (i);
      }
    }
#line 165
    i ++;
  }
#line 169
  return (-1);
}
}
#line 175 "cipher.c"
void cipher_set_key_string(CipherContext *context , int cipher , char const   *passphrase ,
                           int for_encryption ) 
{ MD5_CTX md ;
  unsigned char digest[16] ;
  size_t tmp ;

  {
#line 181
  MD5_Init(& md);
#line 182
  tmp = strlen(passphrase);
#line 182
  MD5_Update(& md, (void const   *)((unsigned char const   *)passphrase), tmp);
#line 183
  MD5_Final(digest, & md);
#line 185
  cipher_set_key(context, cipher, (unsigned char const   *)(digest), 16, for_encryption);
#line 187
  memset((void *)(digest), 0, sizeof(digest));
#line 188
  memset((void *)(& md), 0, sizeof(md));
#line 189
  return;
}
}
#line 193 "cipher.c"
void cipher_set_key(CipherContext *context , int cipher , unsigned char const   *key ,
                    int keylen , int for_encryption ) 
{ unsigned char padded[32] ;
  unsigned int tmp ;

  {
#line 199
  context->type = (unsigned int )cipher;
#line 203
  memset((void *)(padded), 0, sizeof(padded));
#line 204
  if ((unsigned int )keylen < sizeof(padded)) {
#line 204
    tmp = (unsigned int )keylen;
  } else {
#line 204
    tmp = sizeof(padded);
  }
#line 204
  memcpy((void * __restrict  )(padded), (void const   * __restrict  )key, tmp);
#line 207
  switch (cipher) {
  case 0: 
#line 211
  break;
  case 3: 
#line 217
  if (keylen < 16) {
#line 218
    error("Key length %d is insufficient for 3DES.", keylen);
  }
#line 219
  DES_set_key((const_DES_cblock *)((void *)(padded)), & context->u.des3.key1);
#line 220
  DES_set_key((const_DES_cblock *)((void *)(padded + 8)), & context->u.des3.key2);
#line 221
  if (keylen <= 16) {
#line 222
    DES_set_key((const_DES_cblock *)((void *)(padded)), & context->u.des3.key3);
  } else {
#line 224
    DES_set_key((const_DES_cblock *)((void *)(padded + 16)), & context->u.des3.key3);
  }
#line 225
  memset((void *)(context->u.des3.iv2), 0, sizeof(context->u.des3.iv2));
#line 226
  memset((void *)(context->u.des3.iv3), 0, sizeof(context->u.des3.iv3));
#line 227
  break;
  case 6: 
#line 230
  BF_set_key(& context->u.bf.key, keylen, (unsigned char const   *)(padded));
#line 231
  memset((void *)(context->u.bf.iv), 0, 8U);
#line 232
  break;
  default: 
#line 235
  fatal("cipher_set_key: unknown cipher: %d", cipher);
  }
#line 237
  memset((void *)(padded), 0, sizeof(padded));
#line 238
  return;
}
}
#line 242 "cipher.c"
void cipher_encrypt(CipherContext *context , unsigned char *dest , unsigned char const   *src ,
                    unsigned int len ) 
{ 

  {
#line 245
  if (! ((len & 7U) == 0U)) {
#line 245
    __assert_fail("(len & 7) == 0", "cipher.c", 245U, "cipher_encrypt");
  }
#line 247
  switch ((int )context->type) {
  case 0: 
#line 250
  memcpy((void * __restrict  )dest, (void const   * __restrict  )src, len);
#line 251
  break;
  case 3: 
#line 254
  SSH_3CBC_ENCRYPT(context->u.des3.key1, context->u.des3.key2, & context->u.des3.iv2,
                   context->u.des3.key3, & context->u.des3.iv3, (void *)dest, (void *)src,
                   len);
#line 258
  break;
  case 6: 
#line 261
  swap_bytes(src, dest, (int )len);
#line 262
  BF_cbc_encrypt((unsigned char const   *)dest, dest, (long )len, (BF_KEY const   *)(& context->u.bf.key),
                 context->u.bf.iv, 1);
#line 264
  swap_bytes((unsigned char const   *)dest, dest, (int )len);
#line 265
  break;
  default: 
#line 268
  fatal("cipher_encrypt: unknown cipher: %d", context->type);
  }
#line 270
  return;
}
}
#line 274 "cipher.c"
void cipher_decrypt(CipherContext *context , unsigned char *dest , unsigned char const   *src ,
                    unsigned int len ) 
{ 

  {
#line 277
  if (! ((len & 7U) == 0U)) {
#line 277
    __assert_fail("(len & 7) == 0", "cipher.c", 277U, "cipher_decrypt");
  }
#line 279
  switch ((int )context->type) {
  case 0: 
#line 282
  memcpy((void * __restrict  )dest, (void const   * __restrict  )src, len);
#line 283
  break;
  case 3: 
#line 287
  SSH_3CBC_DECRYPT(context->u.des3.key1, context->u.des3.key2, & context->u.des3.iv2,
                   context->u.des3.key3, & context->u.des3.iv3, (void *)dest, (void *)src,
                   len);
#line 291
  break;
  case 6: 
#line 294
  detect_cbc_attack(src, len);
#line 295
  swap_bytes(src, dest, (int )len);
#line 296
  BF_cbc_encrypt((unsigned char const   *)((void *)dest), dest, (long )len, (BF_KEY const   *)(& context->u.bf.key),
                 context->u.bf.iv, 0);
#line 298
  swap_bytes((unsigned char const   *)dest, dest, (int )len);
#line 299
  break;
  default: 
#line 302
  fatal("cipher_decrypt: unknown cipher: %d", context->type);
  }
#line 304
  return;
}
}
#line 1 "compat.o"
#line 6 "compat.c"
int compat13  =    0;
#line 7 "compat.c"
void enable_compat13(void) 
{ 

  {
#line 8
  log("Enabling compatibility mode for protocol 1.3");
#line 9
  compat13 = 1;
#line 10
  return;
}
}
#line 1 "compress.o"
#line 242 "/usr/include/zlib.h"
extern int deflate(z_streamp strm , int flush ) ;
#line 328
extern int deflateEnd(z_streamp strm ) ;
#line 363
extern int inflate(z_streamp strm , int flush ) ;
#line 462
extern int inflateEnd(z_streamp strm ) ;
#line 1317
extern int deflateInit_(z_streamp strm , int level , char const   *version , int stream_size ) ;
#line 1319
extern int inflateInit_(z_streamp strm , char const   *version , int stream_size ) ;
#line 23 "compress.c"
static z_stream incoming_stream  ;
#line 24 "compress.c"
static z_stream outgoing_stream  ;
#line 29 "compress.c"
void buffer_compress_init(int level ) 
{ 

  {
#line 31
  debug("Enabling compression at level %d.", level);
#line 32
  if (level < 1) {
#line 33
    fatal("Bad compression level %d.", level);
  } else {
#line 32
    if (level > 9) {
#line 33
      fatal("Bad compression level %d.", level);
    }
  }
#line 34
  inflateInit_(& incoming_stream, "1.2.3", (int )sizeof(z_stream ));
#line 35
  deflateInit_(& outgoing_stream, level, "1.2.3", (int )sizeof(z_stream ));
#line 36
  return;
}
}
#line 40 "compress.c"
void buffer_compress_uninit(void) 
{ double tmp ;
  double tmp___0 ;

  {
#line 42
  if (outgoing_stream.total_in == 0UL) {
#line 42
    tmp = 0.0;
  } else {
#line 42
    tmp = (double )outgoing_stream.total_out / (double )outgoing_stream.total_in;
  }
#line 42
  debug("compress outgoing: raw data %lu, compressed %lu, factor %.2f", outgoing_stream.total_in,
        outgoing_stream.total_out, tmp);
#line 46
  if (incoming_stream.total_out == 0UL) {
#line 46
    tmp___0 = 0.0;
  } else {
#line 46
    tmp___0 = (double )incoming_stream.total_in / (double )incoming_stream.total_out;
  }
#line 46
  debug("compress incoming: raw data %lu, compressed %lu, factor %.2f", incoming_stream.total_out,
        incoming_stream.total_in, tmp___0);
#line 50
  inflateEnd(& incoming_stream);
#line 51
  deflateEnd(& outgoing_stream);
#line 52
  return;
}
}
#line 62 "compress.c"
void buffer_compress(Buffer *input_buffer , Buffer *output_buffer ) 
{ char buf[4096] ;
  int status ;
  unsigned int tmp ;
  char *tmp___0 ;

  {
#line 68
  tmp = buffer_len(input_buffer);
#line 68
  if (tmp == 0U) {
#line 69
    return;
  }
#line 72
  tmp___0 = buffer_ptr(input_buffer);
#line 72
  outgoing_stream.next_in = (Bytef *)tmp___0;
#line 73
  outgoing_stream.avail_in = buffer_len(input_buffer);
#line 76
  while (1) {
#line 79
    outgoing_stream.next_out = (Bytef *)(buf);
#line 80
    outgoing_stream.avail_out = sizeof(buf);
#line 83
    status = deflate(& outgoing_stream, 1);
#line 84
    switch (status) {
    case 0: 
#line 88
    buffer_append(output_buffer, (char const   *)(buf), sizeof(buf) - outgoing_stream.avail_out);
#line 90
    break;
    case 1: 
#line 92
    fatal("buffer_compress: deflate returned Z_STREAM_END");
    case -2: 
#line 95
    fatal("buffer_compress: deflate returned Z_STREAM_ERROR");
    case -5: 
#line 98
    fatal("buffer_compress: deflate returned Z_BUF_ERROR");
    default: 
#line 101
    fatal("buffer_compress: deflate returned %d", status);
    }
#line 76
    if (! (outgoing_stream.avail_out == 0U)) {
#line 76
      break;
    }
  }
#line 106
  return;
}
}
#line 116 "compress.c"
void buffer_uncompress(Buffer *input_buffer , Buffer *output_buffer ) 
{ char buf[4096] ;
  int status ;
  char *tmp ;

  {
#line 121
  tmp = buffer_ptr(input_buffer);
#line 121
  incoming_stream.next_in = (Bytef *)tmp;
#line 122
  incoming_stream.avail_in = buffer_len(input_buffer);
#line 124
  incoming_stream.next_out = (Bytef *)(buf);
#line 125
  incoming_stream.avail_out = sizeof(buf);
#line 127
  while (1) {
#line 129
    status = inflate(& incoming_stream, 1);
#line 130
    switch (status) {
    case 0: 
#line 133
    buffer_append(output_buffer, (char const   *)(buf), sizeof(buf) - incoming_stream.avail_out);
#line 135
    incoming_stream.next_out = (Bytef *)(buf);
#line 136
    incoming_stream.avail_out = sizeof(buf);
#line 137
    break;
    case 1: 
#line 139
    fatal("buffer_uncompress: inflate returned Z_STREAM_END");
    case -3: 
#line 142
    fatal("buffer_uncompress: inflate returned Z_DATA_ERROR");
    case -2: 
#line 145
    fatal("buffer_uncompress: inflate returned Z_STREAM_ERROR");
    case -5: 
#line 151
    return;
    case -4: 
#line 153
    fatal("buffer_uncompress: inflate returned Z_MEM_ERROR");
    default: 
#line 156
    fatal("buffer_uncompress: inflate returned %d", status);
    }
  }
}
}
#line 1 "crc32.o"
#line 23 "crc32.h"
unsigned int crc32(unsigned char const   *s , unsigned int len ) ;
#line 50 "crc32.c"
static unsigned int crc32_tab[256]  = 
#line 50 "crc32.c"
  {      0U,      1996959894U,      3993919788U,      2567524794U, 
        124634137U,      1886057615U,      3915621685U,      2657392035U, 
        249268274U,      2044508324U,      3772115230U,      2547177864U, 
        162941995U,      2125561021U,      3887607047U,      2428444049U, 
        498536548U,      1789927666U,      4089016648U,      2227061214U, 
        450548861U,      1843258603U,      4107580753U,      2211677639U, 
        325883990U,      1684777152U,      4251122042U,      2321926636U, 
        335633487U,      1661365465U,      4195302755U,      2366115317U, 
        997073096U,      1281953886U,      3579855332U,      2724688242U, 
        1006888145U,      1258607687U,      3524101629U,      2768942443U, 
        901097722U,      1119000684U,      3686517206U,      2898065728U, 
        853044451U,      1172266101U,      3705015759U,      2882616665U, 
        651767980U,      1373503546U,      3369554304U,      3218104598U, 
        565507253U,      1454621731U,      3485111705U,      3099436303U, 
        671266974U,      1594198024U,      3322730930U,      2970347812U, 
        795835527U,      1483230225U,      3244367275U,      3060149565U, 
        1994146192U,      31158534U,      2563907772U,      4023717930U, 
        1907459465U,      112637215U,      2680153253U,      3904427059U, 
        2013776290U,      251722036U,      2517215374U,      3775830040U, 
        2137656763U,      141376813U,      2439277719U,      3865271297U, 
        1802195444U,      476864866U,      2238001368U,      4066508878U, 
        1812370925U,      453092731U,      2181625025U,      4111451223U, 
        1706088902U,      314042704U,      2344532202U,      4240017532U, 
        1658658271U,      366619977U,      2362670323U,      4224994405U, 
        1303535960U,      984961486U,      2747007092U,      3569037538U, 
        1256170817U,      1037604311U,      2765210733U,      3554079995U, 
        1131014506U,      879679996U,      2909243462U,      3663771856U, 
        1141124467U,      855842277U,      2852801631U,      3708648649U, 
        1342533948U,      654459306U,      3188396048U,      3373015174U, 
        1466479909U,      544179635U,      3110523913U,      3462522015U, 
        1591671054U,      702138776U,      2966460450U,      3352799412U, 
        1504918807U,      783551873U,      3082640443U,      3233442989U, 
        3988292384U,      2596254646U,      62317068U,      1957810842U, 
        3939845945U,      2647816111U,      81470997U,      1943803523U, 
        3814918930U,      2489596804U,      225274430U,      2053790376U, 
        3826175755U,      2466906013U,      167816743U,      2097651377U, 
        4027552580U,      2265490386U,      503444072U,      1762050814U, 
        4150417245U,      2154129355U,      426522225U,      1852507879U, 
        4275313526U,      2312317920U,      282753626U,      1742555852U, 
        4189708143U,      2394877945U,      397917763U,      1622183637U, 
        3604390888U,      2714866558U,      953729732U,      1340076626U, 
        3518719985U,      2797360999U,      1068828381U,      1219638859U, 
        3624741850U,      2936675148U,      906185462U,      1090812512U, 
        3747672003U,      2825379669U,      829329135U,      1181335161U, 
        3412177804U,      3160834842U,      628085408U,      1382605366U, 
        3423369109U,      3138078467U,      570562233U,      1426400815U, 
        3317316542U,      2998733608U,      733239954U,      1555261956U, 
        3268935591U,      3050360625U,      752459403U,      1541320221U, 
        2607071920U,      3965973030U,      1969922972U,      40735498U, 
        2617837225U,      3943577151U,      1913087877U,      83908371U, 
        2512341634U,      3803740692U,      2075208622U,      213261112U, 
        2463272603U,      3855990285U,      2094854071U,      198958881U, 
        2262029012U,      4057260610U,      1759359992U,      534414190U, 
        2176718541U,      4139329115U,      1873836001U,      414664567U, 
        2282248934U,      4279200368U,      1711684554U,      285281116U, 
        2405801727U,      4167216745U,      1634467795U,      376229701U, 
        2685067896U,      3608007406U,      1308918612U,      956543938U, 
        2808555105U,      3495958263U,      1231636301U,      1047427035U, 
        2932959818U,      3654703836U,      1088359270U,      936918000U, 
        2847714899U,      3736837829U,      1202900863U,      817233897U, 
        3183342108U,      3401237130U,      1404277552U,      615818150U, 
        3134207493U,      3453421203U,      1423857449U,      601450431U, 
        3009837614U,      3294710456U,      1567103746U,      711928724U, 
        3020668471U,      3272380065U,      1510334235U,      755167117U};
#line 107 "crc32.c"
unsigned int crc32(unsigned char const   *s , unsigned int len ) 
{ unsigned int i ;
  unsigned int crc32val ;

  {
#line 112
  crc32val = 0U;
#line 113
  i = 0U;
#line 113
  while (i < len) {
#line 115
    crc32val = crc32_tab[(crc32val ^ (unsigned int )*(s + i)) & 255U] ^ (crc32val >> 8);
#line 113
    i ++;
  }
#line 119
  return (crc32val);
}
}
#line 1 "deattack.o"
#line 26 "deattack.h"
int detect_attack(unsigned char *buf , u_int32_t len , unsigned char *IV ) ;
#line 48 "deattack.c"
void crc_update(u_int32_t *a , u_int32_t b ) 
{ 

  {
#line 51
  b ^= *a;
#line 52
  *a = crc32((unsigned char const   *)((unsigned char *)(& b)), sizeof(b));
#line 53
  return;
}
}
#line 60 "deattack.c"
int check_crc(unsigned char *S , unsigned char *buf , u_int32_t len , unsigned char *IV ) 
{ u_int32_t crc ;
  unsigned char *c ;
  int tmp ;
  int tmp___0 ;

  {
#line 66
  crc = 0U;
#line 67
  if (IV) {
#line 67
    tmp = memcmp((void const   *)S, (void const   *)IV, 8U);
#line 67
    if (! tmp) {
#line 69
      crc_update(& crc, 1U);
#line 70
      crc_update(& crc, 0U);
    }
  }
#line 72
  c = buf;
#line 72
  while ((unsigned int )c < (unsigned int )(buf + len)) {
#line 74
    tmp___0 = memcmp((void const   *)S, (void const   *)c, 8U);
#line 74
    if (tmp___0) {
#line 80
      crc_update(& crc, 0U);
#line 81
      crc_update(& crc, 0U);
    } else {
#line 76
      crc_update(& crc, 1U);
#line 77
      crc_update(& crc, 0U);
    }
#line 72
    c += 8;
  }
#line 85
  return (crc == 0U);
}
}
#line 96 "deattack.c"
static u_int16_t *h  =    (u_int16_t *)((void *)0);
#line 97 "deattack.c"
static u_int16_t n  =    (u_int16_t )4096;
#line 93 "deattack.c"
int detect_attack(unsigned char *buf , u_int32_t len , unsigned char *IV ) 
{ register u_int32_t i ;
  register u_int32_t j ;
  u_int32_t l ;
  register unsigned char *c ;
  unsigned char *d ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 104
  if (! (len <= 262144U)) {
#line 104
    __assert_fail("len <= ((32 * 1024) * (8))", "deattack.c", 104U, "detect_attack");
  }
#line 105
  if (! (len % 8U == 0U)) {
#line 105
    __assert_fail("len % (8) == 0", "deattack.c", 105U, "detect_attack");
  }
#line 107
  l = (unsigned int )n;
#line 107
  while (l < ((len / 8U) * 3U) / 2U) {
#line 107
    l <<= 2;
  }
#line 109
  if ((unsigned int )h == (unsigned int )((void *)0)) {
#line 111
    debug("Installing crc compensation attack detector.");
#line 112
    n = (unsigned short )l;
#line 113
    tmp = xmalloc((unsigned int )((int )n * 2));
#line 113
    h = (u_int16_t *)tmp;
  } else {
#line 116
    if (l > (u_int32_t )n) {
#line 118
      n = (unsigned short )l;
#line 119
      tmp___0 = xrealloc((void *)h, (unsigned int )((int )n * 2));
#line 119
      h = (u_int16_t *)tmp___0;
    }
  }
#line 124
  if (len <= 56U) {
#line 126
    c = buf;
#line 126
    while ((unsigned int )c < (unsigned int )(buf + len)) {
#line 128
      if (IV) {
#line 128
        tmp___2 = memcmp((void const   *)c, (void const   *)IV, 8U);
#line 128
        if (! tmp___2) {
#line 130
          tmp___1 = check_crc(c, buf, len, (unsigned char *)IV);
#line 130
          if (tmp___1) {
#line 131
            return (1);
          } else {
#line 133
            break;
          }
        }
      }
#line 135
      d = buf;
#line 135
      while ((unsigned int )d < (unsigned int )c) {
#line 137
        tmp___4 = memcmp((void const   *)c, (void const   *)d, 8U);
#line 137
        if (! tmp___4) {
#line 139
          tmp___3 = check_crc(c, buf, len, (unsigned char *)IV);
#line 139
          if (tmp___3) {
#line 140
            return (1);
          } else {
#line 142
            break;
          }
        }
#line 135
        d += 8;
      }
#line 126
      c += 8;
    }
#line 146
    return (0);
  }
#line 148
  memset((void *)h, 255, (unsigned int )((int )n * 2));
#line 150
  if (IV) {
#line 151
    *(h + ((((((unsigned long )*(IV + 0) << 24) | ((unsigned long )*(IV + 1) << 16)) | ((unsigned long )*(IV + 2) << 8)) | (unsigned long )*(IV + 3)) & (unsigned long )((int )n - 1))) = (unsigned short)65534;
  }
#line 154
  c = buf;
#line 154
  j = 0U;
#line 154
  while ((unsigned int )c < (unsigned int )(buf + len)) {
#line 156
    i = (unsigned int )((((((unsigned long )*(c + 0) << 24) | ((unsigned long )*(c + 1) << 16)) | ((unsigned long )*(c + 2) << 8)) | (unsigned long )*(c + 3)) & (unsigned long )((int )n - 1));
#line 156
    while ((int )*(h + i) != 65535) {
#line 159
      if ((int )*(h + i) == 65534) {
#line 161
        tmp___6 = memcmp((void const   *)c, (void const   *)IV, 8U);
#line 161
        if (! tmp___6) {
#line 163
          tmp___5 = check_crc(c, buf, len, (unsigned char *)IV);
#line 163
          if (tmp___5) {
#line 164
            return (1);
          } else {
#line 166
            break;
          }
        }
      } else {
#line 168
        tmp___8 = memcmp((void const   *)c, (void const   *)(buf + (int )*(h + i) * 8),
                         8U);
#line 168
        if (! tmp___8) {
#line 170
          tmp___7 = check_crc(c, buf, len, (unsigned char *)IV);
#line 170
          if (tmp___7) {
#line 171
            return (1);
          } else {
#line 173
            break;
          }
        }
      }
#line 156
      i = (i + 1U) & (unsigned int )((int )n - 1);
    }
#line 176
    *(h + i) = (unsigned short )j;
#line 154
    c += 8;
#line 154
    j ++;
  }
#line 179
  return (0);
}
}
#line 1 "hostfile.o"
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 382
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
#line 433
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 433 "/usr/include/sys/stat.h"
__inline static int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
#line 436
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
#line 436
  return (tmp);
}
}
#line 213 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 248
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 532
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 116 "/usr/include/ctype.h"
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 603 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 457 "/usr/include/openssl/bn.h"
extern int BN_cmp(BIGNUM const   *a , BIGNUM const   *b ) ;
#line 496
extern char *BN_bn2dec(BIGNUM const   *a ) ;
#line 498
extern int BN_dec2bn(BIGNUM **a , char const   *str ) ;
#line 135 "packet.h"
void packet_send_debug(char const   *fmt  , ...) ;
#line 280 "ssh.h"
int auth_rsa_read_key(char **cpp , unsigned int *bitsp , BIGNUM *e , BIGNUM *n___0 ) ;
#line 305
int match_hostname(char const   *host , char const   *pattern , unsigned int len ) ;
#line 312
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , unsigned int bits ,
                                  BIGNUM *e , BIGNUM *n___0 , BIGNUM *ke , BIGNUM *kn ) ;
#line 319
int add_host_to_hostfile(char const   *filename , char const   *host , unsigned int bits ,
                         BIGNUM *e , BIGNUM *n___0 ) ;
#line 540
int match_pattern(char const   *s , char const   *pattern ) ;
#line 28 "hostfile.c"
int auth_rsa_read_bignum(char **cpp , BIGNUM *value ) 
{ char *cp ;
  int len ;
  int old ;
  int tmp ;

  {
#line 31
  cp = *cpp;
#line 35
  while (1) {
#line 35
    if (! ((int )*cp == 32)) {
#line 35
      if (! ((int )*cp == 9)) {
#line 35
        break;
      }
    }
#line 35
    cp ++;
  }
#line 39
  if ((int )*cp < 48) {
#line 40
    return (0);
  } else {
#line 39
    if ((int )*cp > 57) {
#line 40
      return (0);
    }
  }
#line 43
  *cpp = cp;
#line 46
  while (1) {
#line 46
    if ((int )*cp >= 48) {
#line 46
      if (! ((int )*cp <= 57)) {
#line 46
        break;
      }
    } else {
#line 46
      break;
    }
#line 46
    cp ++;
  }
#line 50
  len = cp - *cpp;
#line 53
  old = (int )*cp;
#line 54
  *cp = (char)0;
#line 58
  tmp = BN_dec2bn(& value, (char const   *)*cpp);
#line 58
  if (tmp == 0) {
#line 59
    return (0);
  }
#line 62
  *cp = (char )old;
#line 65
  *cpp = cp;
#line 66
  return (1);
}
}
#line 72 "hostfile.c"
int auth_rsa_read_key(char **cpp , unsigned int *bitsp , BIGNUM *e , BIGNUM *n___0 ) 
{ unsigned int bits ;
  char *cp ;
  int tmp ;
  int tmp___0 ;

  {
#line 79
  cp = *cpp;
#line 79
  while (1) {
#line 79
    if (! ((int )*cp == 32)) {
#line 79
      if (! ((int )*cp == 9)) {
#line 79
        break;
      }
    }
#line 79
    cp ++;
  }
#line 83
  if ((int )*cp < 48) {
#line 84
    return (0);
  } else {
#line 83
    if ((int )*cp > 57) {
#line 84
      return (0);
    }
  }
#line 85
  bits = 0U;
#line 85
  while (1) {
#line 85
    if ((int )*cp >= 48) {
#line 85
      if (! ((int )*cp <= 57)) {
#line 85
        break;
      }
    } else {
#line 85
      break;
    }
#line 86
    bits = (10U * bits + (unsigned int )*cp) - 48U;
#line 85
    cp ++;
  }
#line 89
  tmp = auth_rsa_read_bignum(& cp, e);
#line 89
  if (! tmp) {
#line 90
    return (0);
  }
#line 93
  tmp___0 = auth_rsa_read_bignum(& cp, n___0);
#line 93
  if (! tmp___0) {
#line 94
    return (0);
  }
#line 97
  while (1) {
#line 97
    if (! ((int )*cp == 32)) {
#line 97
      if (! ((int )*cp == 9)) {
#line 97
        break;
      }
    }
#line 97
    cp ++;
  }
#line 101
  *cpp = cp;
#line 102
  *bitsp = bits;
#line 103
  return (1);
}
}
#line 111 "hostfile.c"
int match_hostname(char const   *host , char const   *pattern , unsigned int len ) 
{ char sub[1024] ;
  int negated ;
  int got_positive ;
  unsigned int i ;
  unsigned int subi ;
  int __res___0 ;
  __int32_t const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;

  {
#line 119
  got_positive = 0;
#line 120
  i = 0U;
#line 120
  while (i < len) {
#line 123
    if ((int const   )*(pattern + i) == 33) {
#line 125
      negated = 1;
#line 126
      i ++;
    } else {
#line 129
      negated = 0;
    }
#line 133
    subi = 0U;
#line 133
    while (1) {
#line 133
      if (i < len) {
#line 133
        if (subi < sizeof(sub) - 1U) {
#line 133
          if (! ((int const   )*(pattern + i) != 44)) {
#line 133
            break;
          }
        } else {
#line 133
          break;
        }
      } else {
#line 133
        break;
      }
#line 136
      tmp___6 = __ctype_b_loc();
#line 136
      if ((int const   )*(*tmp___6 + (int )*(pattern + i)) & 256) {
#line 136
        if (sizeof(*(pattern + i)) > 1U) {
#line 136
          __res___0 = tolower((int )*(pattern + i));
        } else {
#line 136
          tmp___5 = __ctype_tolower_loc();
#line 136
          __res___0 = (int )*(*tmp___5 + (int )*(pattern + i));
        }
#line 136
        sub[subi] = (char )__res___0;
      } else {
#line 136
        sub[subi] = (char )*(pattern + i);
      }
#line 133
      subi ++;
#line 133
      i ++;
    }
#line 138
    if (subi >= sizeof(sub) - 1U) {
#line 139
      return (0);
    }
#line 142
    if (i < len) {
#line 142
      if ((int const   )*(pattern + i) == 44) {
#line 143
        i ++;
      }
    }
#line 146
    sub[subi] = (char )'\000';
#line 149
    tmp___7 = match_pattern(host, (char const   *)(sub));
#line 149
    if (tmp___7) {
#line 150
      if (negated) {
#line 151
        return (0);
      } else {
#line 153
        got_positive = 1;
      }
    }
  }
#line 159
  return (got_positive);
}
}
#line 168 "hostfile.c"
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , unsigned int bits ,
                                  BIGNUM *e , BIGNUM *n___0 , BIGNUM *ke , BIGNUM *kn ) 
{ FILE *f ;
  char line[8192] ;
  unsigned int kbits ;
  unsigned int hostlen ;
  char *cp ;
  char *cp2 ;
  HostStatus end_return ;
  struct stat st ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
#line 182
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 183
  if (! f) {
#line 185
    tmp = stat((char const   * __restrict  )filename, (struct stat * __restrict  )(& st));
#line 185
    if (tmp >= 0) {
#line 187
      packet_send_debug("Could not open %.900s for reading.", filename);
#line 188
      packet_send_debug("If your home directory is on an NFS volume, it may need to be world-readable.");
    }
#line 190
    return (1);
  }
#line 194
  hostlen = strlen(host);
#line 199
  end_return = 1;
#line 202
  while (1) {
#line 202
    tmp___4 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 202
    if (! tmp___4) {
#line 202
      break;
    }
#line 204
    cp = line;
#line 207
    while (1) {
#line 207
      if (! ((int )*cp == 32)) {
#line 207
        if (! ((int )*cp == 9)) {
#line 207
          break;
        }
      }
#line 207
      cp ++;
    }
#line 211
    if (! *cp) {
#line 212
      continue;
    } else {
#line 211
      if ((int )*cp == 35) {
#line 212
        continue;
      } else {
#line 211
        if ((int )*cp == 10) {
#line 212
          continue;
        }
      }
    }
#line 215
    cp2 = cp;
#line 215
    while (1) {
#line 215
      if (*cp2) {
#line 215
        if ((int )*cp2 != 32) {
#line 215
          if (! ((int )*cp2 != 9)) {
#line 215
            break;
          }
        } else {
#line 215
          break;
        }
      } else {
#line 215
        break;
      }
#line 215
      cp2 ++;
    }
#line 219
    tmp___0 = match_hostname(host, (char const   *)cp, (unsigned int )(cp2 - cp));
#line 219
    if (! tmp___0) {
#line 220
      continue;
    }
#line 223
    cp = cp2;
#line 227
    tmp___1 = auth_rsa_read_key(& cp, & kbits, ke, kn);
#line 227
    if (! tmp___1) {
#line 228
      continue;
    }
#line 231
    if (kbits == bits) {
#line 231
      tmp___2 = BN_cmp((BIGNUM const   *)ke, (BIGNUM const   *)e);
#line 231
      if (tmp___2 == 0) {
#line 231
        tmp___3 = BN_cmp((BIGNUM const   *)kn, (BIGNUM const   *)n___0);
#line 231
        if (tmp___3 == 0) {
#line 234
          fclose(f);
#line 235
          return (0);
        }
      }
    }
#line 240
    end_return = 2;
  }
#line 243
  fclose(f);
#line 247
  return (end_return);
}
}
#line 253 "hostfile.c"
int add_host_to_hostfile(char const   *filename , char const   *host , unsigned int bits ,
                         BIGNUM *e , BIGNUM *n___0 ) 
{ FILE *f ;
  char *buf ;

  {
#line 261
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"a");
#line 262
  if (! f) {
#line 263
    return (0);
  }
#line 266
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %u ", host, bits);
#line 267
  buf = BN_bn2dec((BIGNUM const   *)e);
#line 268
  if (! ((unsigned int )buf != (unsigned int )((void *)0))) {
#line 268
    __assert_fail("buf != ((void *)0)", "hostfile.c", 268U, "add_host_to_hostfile");
  }
#line 269
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s ", buf);
#line 270
  free((void *)buf);
#line 271
  buf = BN_bn2dec((BIGNUM const   *)n___0);
#line 272
  if (! ((unsigned int )buf != (unsigned int )((void *)0))) {
#line 272
    __assert_fail("buf != ((void *)0)", "hostfile.c", 272U, "add_host_to_hostfile");
  }
#line 273
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s\n", buf);
#line 274
  free((void *)buf);
#line 277
  fclose(f);
#line 278
  return (1);
}
}
#line 1 "match.o"
#line 24 "match.c"
int match_pattern(char const   *s , char const   *pattern ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 26
  while (1) {
#line 29
    if (! *pattern) {
#line 30
      return (! *s);
    }
#line 33
    if ((int const   )*pattern == 42) {
#line 36
      pattern ++;
#line 39
      if (! *pattern) {
#line 40
        return (1);
      }
#line 43
      if ((int const   )*pattern != 63) {
#line 43
        if ((int const   )*pattern != 42) {
#line 47
          while (*s) {
#line 48
            if ((int const   )*s == (int const   )*pattern) {
#line 48
              tmp = match_pattern(s + 1, pattern + 1);
#line 48
              if (tmp) {
#line 50
                return (1);
              }
            }
#line 47
            s ++;
          }
#line 52
          return (0);
        }
      }
#line 57
      while (*s) {
#line 58
        tmp___0 = match_pattern(s, pattern);
#line 58
        if (tmp___0) {
#line 59
          return (1);
        }
#line 57
        s ++;
      }
#line 61
      return (0);
    }
#line 66
    if (! *s) {
#line 67
      return (0);
    }
#line 70
    if ((int const   )*pattern != 63) {
#line 70
      if ((int const   )*pattern != (int const   )*s) {
#line 71
        return (0);
      }
    }
#line 74
    s ++;
#line 75
    pattern ++;
  }
}
}
#line 1 "mpaux.o"
#line 26 "mpaux.c"
void compute_session_id(unsigned char *session_id___0 , unsigned char *cookie , unsigned int host_key_bits ,
                        BIGNUM *host_key_n , unsigned int session_key_bits , BIGNUM *session_key_n ) 
{ unsigned int bytes ;
  unsigned char *buf ;
  void *tmp ;
  MD5_CTX md ;

  {
#line 34
  bytes = ((host_key_bits + 7U) / 8U + (session_key_bits + 7U) / 8U) + 8U;
#line 35
  tmp = xmalloc(bytes);
#line 35
  buf = (unsigned char *)tmp;
#line 38
  BN_bn2bin((BIGNUM const   *)host_key_n, buf);
#line 39
  BN_bn2bin((BIGNUM const   *)session_key_n, buf + (host_key_bits + 7U) / 8U);
#line 40
  memcpy((void * __restrict  )((buf + (host_key_bits + 7U) / 8U) + (session_key_bits + 7U) / 8U),
         (void const   * __restrict  )cookie, 8U);
#line 42
  MD5_Init(& md);
#line 43
  MD5_Update(& md, (void const   *)buf, bytes);
#line 44
  MD5_Final((unsigned char *)session_id___0, & md);
#line 45
  xfree((void *)buf);
#line 46
  return;
}
}
#line 1 "nchan.o"
#line 11 "nchan.c"
static void chan_send_ieof(Channel *c ) ;
#line 12
static void chan_send_oclose(Channel *c ) ;
#line 13
static void chan_shutdown_write(Channel *c ) ;
#line 14
static void chan_shutdown_read(Channel *c ) ;
#line 15
static void chan_delele_if_full_closed(Channel *c ) ;
#line 22 "nchan.c"
void chan_rcvd_oclose(Channel *c ) 
{ 

  {
#line 24
  switch (c->istate) {
  case 4: 
#line 26
  debug("channel %d: INPUT_WAIT_OCLOSE -> INPUT_CLOSED [rcvd OCLOSE]", c->self);
#line 27
  c->istate = 8;
#line 28
  chan_delele_if_full_closed(c);
#line 29
  break;
  case 1: 
#line 31
  debug("channel %d: INPUT_OPEN -> INPUT_CLOSED [rvcd OCLOSE, send IEOF]", c->self);
#line 32
  chan_shutdown_read(c);
#line 33
  chan_send_ieof(c);
#line 34
  c->istate = 8;
#line 35
  chan_delele_if_full_closed(c);
#line 36
  break;
  default: 
#line 38
  debug("protocol error: chan_rcvd_oclose %d for istate %d", c->self, c->istate);
#line 39
  break;
  }
#line 41
  return;
}
}
#line 42 "nchan.c"
void chan_read_failed(Channel *c ) 
{ 

  {
#line 44
  switch (c->istate) {
  case 1: 
#line 46
  debug("channel %d: INPUT_OPEN -> INPUT_WAIT_DRAIN [read failed]", c->self);
#line 47
  chan_shutdown_read(c);
#line 48
  c->istate = 2;
#line 49
  break;
  default: 
#line 51
  debug("internal error: we do not read, but chan_read_failed %d for istate %d", c->self,
        c->istate);
#line 53
  break;
  }
#line 55
  return;
}
}
#line 56 "nchan.c"
void chan_ibuf_empty(Channel *c ) 
{ unsigned int tmp ;

  {
#line 58
  tmp = buffer_len(& c->input);
#line 58
  if (tmp) {
#line 59
    debug("internal error: chan_ibuf_empty %d for non empty buffer", c->self);
#line 60
    return;
  }
#line 62
  switch (c->istate) {
  case 2: 
#line 64
  debug("channel %d: INPUT_WAIT_DRAIN -> INPUT_WAIT_OCLOSE [inbuf empty, send IEOF]",
        c->self);
#line 65
  chan_send_ieof(c);
#line 66
  c->istate = 4;
#line 67
  break;
  default: 
#line 69
  debug("internal error: chan_ibuf_empty %d for istate %d", c->self, c->istate);
#line 70
  break;
  }
#line 72
  return;
}
}
#line 74 "nchan.c"
void chan_rcvd_ieof(Channel *c ) 
{ 

  {
#line 76
  switch (c->ostate) {
  case 16: 
#line 78
  debug("channel %d: OUTPUT_OPEN -> OUTPUT_WAIT_DRAIN [rvcd IEOF]", c->self);
#line 79
  c->ostate = 32;
#line 80
  break;
  case 64: 
#line 82
  debug("channel %d: OUTPUT_WAIT_IEOF -> OUTPUT_CLOSED [rvcd IEOF]", c->self);
#line 83
  c->ostate = 128;
#line 84
  chan_delele_if_full_closed(c);
#line 85
  break;
  default: 
#line 87
  debug("protocol error: chan_rcvd_ieof %d for ostate %d", c->self, c->ostate);
#line 88
  break;
  }
#line 90
  return;
}
}
#line 91 "nchan.c"
void chan_write_failed(Channel *c ) 
{ 

  {
#line 93
  switch (c->ostate) {
  case 16: 
#line 95
  debug("channel %d: OUTPUT_OPEN -> OUTPUT_WAIT_IEOF [write failed]", c->self);
#line 96
  chan_send_oclose(c);
#line 97
  c->ostate = 64;
#line 98
  break;
  case 32: 
#line 100
  debug("channel %d: OUTPUT_WAIT_DRAIN -> OUTPUT_CLOSED [write failed]", c->self);
#line 101
  chan_send_oclose(c);
#line 102
  c->ostate = 128;
#line 103
  chan_delele_if_full_closed(c);
#line 104
  break;
  default: 
#line 106
  debug("internal error: chan_write_failed %d for ostate %d", c->self, c->ostate);
#line 107
  break;
  }
#line 109
  return;
}
}
#line 110 "nchan.c"
void chan_obuf_empty(Channel *c ) 
{ unsigned int tmp ;

  {
#line 112
  tmp = buffer_len(& c->output);
#line 112
  if (tmp) {
#line 113
    debug("internal error: chan_obuf_empty %d for non empty buffer", c->self);
#line 114
    return;
  }
#line 116
  switch (c->ostate) {
  case 32: 
#line 118
  debug("channel %d: OUTPUT_WAIT_DRAIN -> OUTPUT_CLOSED [obuf empty, send OCLOSE]",
        c->self);
#line 119
  chan_send_oclose(c);
#line 120
  c->ostate = 128;
#line 121
  chan_delele_if_full_closed(c);
#line 122
  break;
  default: 
#line 124
  debug("internal error: chan_obuf_empty %d for ostate %d", c->self, c->ostate);
#line 125
  break;
  }
#line 127
  return;
}
}
#line 131 "nchan.c"
static void chan_send_ieof(Channel *c ) 
{ 

  {
#line 133
  switch (c->istate) {
  case 1: 
  case 2: 
#line 136
  packet_start(24);
#line 137
  packet_put_int((unsigned int )c->remote_id);
#line 138
  packet_send();
#line 139
  break;
  default: 
#line 141
  debug("internal error: channel %d: cannot send IEOF for istate %d", c->self, c->istate);
#line 142
  break;
  }
#line 144
  return;
}
}
#line 145 "nchan.c"
static void chan_send_oclose(Channel *c ) 
{ unsigned int tmp ;

  {
#line 147
  switch (c->ostate) {
  case 16: 
  case 32: 
#line 150
  chan_shutdown_write(c);
#line 151
  tmp = buffer_len(& c->output);
#line 151
  buffer_consume(& c->output, tmp);
#line 152
  packet_start(25);
#line 153
  packet_put_int((unsigned int )c->remote_id);
#line 154
  packet_send();
#line 155
  break;
  default: 
#line 157
  debug("internal error: channel %d: cannot send OCLOSE for ostate %d", c->self, c->istate);
#line 158
  break;
  }
#line 160
  return;
}
}
#line 162 "nchan.c"
static void chan_shutdown_write(Channel *c ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 164
  debug("channel %d: shutdown_write", c->self);
#line 165
  tmp___1 = shutdown(c->sock, 1);
#line 165
  if (tmp___1 < 0) {
#line 166
    tmp = __errno_location();
#line 166
    tmp___0 = strerror(*tmp);
#line 166
    error("chan_shutdown_write failed for #%d/fd%d: %.100s", c->self, c->sock, tmp___0);
  }
#line 168
  return;
}
}
#line 169 "nchan.c"
static void chan_shutdown_read(Channel *c ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 171
  debug("channel %d: shutdown_read", c->self);
#line 172
  tmp___1 = shutdown(c->sock, 0);
#line 172
  if (tmp___1 < 0) {
#line 173
    tmp = __errno_location();
#line 173
    tmp___0 = strerror(*tmp);
#line 173
    error("chan_shutdown_read failed for #%d/fd%d: %.100s", c->self, c->sock, tmp___0);
  }
#line 175
  return;
}
}
#line 176 "nchan.c"
static void chan_delele_if_full_closed(Channel *c ) 
{ 

  {
#line 178
  if (c->istate == 8) {
#line 178
    if (c->ostate == 128) {
#line 179
      debug("channel %d: closing", c->self);
#line 180
      channel_free(c->self);
    }
  }
#line 182
  return;
}
}
#line 183 "nchan.c"
void chan_init_iostates(Channel *c ) 
{ 

  {
#line 185
  c->ostate = 16;
#line 186
  c->istate = 1;
#line 187
  return;
}
}
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 1 "packet.o"
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 192 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 361 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 76 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 27 "packet.h"
void packet_set_connection(int fd_in , int fd_out ) ;
#line 30
void packet_set_nonblocking(void) ;
#line 40
void packet_close(void) ;
#line 46
void packet_set_encryption_key(unsigned char const   *key , unsigned int keylen ,
                               int cipher , int is_client ) ;
#line 51
void packet_set_protocol_flags(unsigned int protocol_flags ) ;
#line 54
unsigned int packet_get_protocol_flags(void) ;
#line 57
void packet_start_compression(int level ) ;
#line 61
void packet_set_interactive(int interactive , int keepalives ) ;
#line 70
void packet_put_char(int value ) ;
#line 76
void packet_put_bignum(BIGNUM *value ) ;
#line 86
int packet_read(int *payload_len_ptr ) ;
#line 99
int packet_read_poll(int *payload_len_ptr ) ;
#line 103
void packet_process_incoming(char const   *buf , unsigned int len ) ;
#line 106
unsigned int packet_get_char(void) ;
#line 113
void packet_get_bignum(BIGNUM *value , int *length_ptr ) ;
#line 139
void packet_write_poll(void) ;
#line 145
int packet_have_data_to_write(void) ;
#line 148
int packet_not_very_much_data_to_write(void) ;
#line 36 "packet.c"
static int connection_in  =    -1;
#line 37 "packet.c"
static int connection_out  =    -1;
#line 41 "packet.c"
static int cipher_type  =    0;
#line 44 "packet.c"
static unsigned int remote_protocol_flags  =    0U;
#line 47 "packet.c"
static CipherContext receive_context  ;
#line 49 "packet.c"
static CipherContext send_context  ;
#line 52 "packet.c"
static Buffer input  ;
#line 55 "packet.c"
static Buffer output  ;
#line 58 "packet.c"
static Buffer outgoing_packet  ;
#line 61 "packet.c"
static Buffer incoming_packet  ;
#line 64 "packet.c"
static Buffer compression_buffer  ;
#line 67 "packet.c"
static int packet_compression  =    0;
#line 70 "packet.c"
static int initialized  =    0;
#line 73 "packet.c"
static int interactive_mode  =    0;
#line 78 "packet.c"
void packet_set_connection(int fd_in , int fd_out ) 
{ 

  {
#line 81
  connection_in = fd_in;
#line 82
  connection_out = fd_out;
#line 83
  cipher_type = 0;
#line 84
  cipher_set_key(& send_context, 0, (unsigned char const   *)((unsigned char *)""),
                 0, 1);
#line 85
  cipher_set_key(& receive_context, 0, (unsigned char const   *)((unsigned char *)""),
                 0, 0);
#line 86
  if (! initialized) {
#line 88
    initialized = 1;
#line 89
    buffer_init(& input);
#line 90
    buffer_init(& output);
#line 91
    buffer_init(& outgoing_packet);
#line 92
    buffer_init(& incoming_packet);
  }
#line 96
  fatal_add_cleanup((void (*)(void * ))(& packet_close), (void *)0);
#line 97
  return;
}
}
#line 101 "packet.c"
void packet_set_nonblocking(void) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 105
  tmp___1 = fcntl(connection_in, 4, 2048);
#line 105
  if (tmp___1 < 0) {
#line 106
    tmp = __errno_location();
#line 106
    tmp___0 = strerror(*tmp);
#line 106
    error("fcntl O_NONBLOCK: %.100s", tmp___0);
  }
#line 108
  if (connection_out != connection_in) {
#line 110
    tmp___4 = fcntl(connection_out, 4, 2048);
#line 110
    if (tmp___4 < 0) {
#line 111
      tmp___2 = __errno_location();
#line 111
      tmp___3 = strerror(*tmp___2);
#line 111
      error("fcntl O_NONBLOCK: %.100s", tmp___3);
    }
  }
#line 113
  return;
}
}
#line 117 "packet.c"
int packet_get_connection_in(void) 
{ 

  {
#line 120
  return (connection_in);
}
}
#line 125 "packet.c"
int packet_get_connection_out(void) 
{ 

  {
#line 128
  return (connection_out);
}
}
#line 133 "packet.c"
void packet_close(void) 
{ 

  {
#line 136
  if (! initialized) {
#line 137
    return;
  }
#line 138
  initialized = 0;
#line 139
  if (connection_in == connection_out) {
#line 141
    shutdown(connection_out, 2);
#line 142
    close(connection_out);
  } else {
#line 146
    close(connection_in);
#line 147
    close(connection_out);
  }
#line 149
  buffer_free(& input);
#line 150
  buffer_free(& output);
#line 151
  buffer_free(& outgoing_packet);
#line 152
  buffer_free(& incoming_packet);
#line 153
  if (packet_compression) {
#line 155
    buffer_free(& compression_buffer);
#line 156
    buffer_compress_uninit();
  }
#line 158
  return;
}
}
#line 162 "packet.c"
void packet_set_protocol_flags(unsigned int protocol_flags ) 
{ 

  {
#line 165
  remote_protocol_flags = protocol_flags;
#line 166
  channel_set_options((protocol_flags & 2U) != 0U);
#line 167
  return;
}
}
#line 171 "packet.c"
unsigned int packet_get_protocol_flags(void) 
{ 

  {
#line 174
  return (remote_protocol_flags);
}
}
#line 180 "packet.c"
void packet_start_compression(int level ) 
{ 

  {
#line 183
  if (packet_compression) {
#line 184
    fatal("Compression already enabled.");
  }
#line 185
  packet_compression = 1;
#line 186
  buffer_init(& compression_buffer);
#line 187
  buffer_compress_init(level);
#line 188
  return;
}
}
#line 193 "packet.c"
void packet_encrypt(CipherContext *cc , void *dest , void *src , unsigned int bytes ) 
{ 

  {
#line 197
  if (! (bytes % 8U == 0U)) {
#line 197
    __assert_fail("(bytes % 8) == 0", "packet.c", 197U, "packet_encrypt");
  }
#line 198
  cipher_encrypt(cc, (unsigned char *)dest, (unsigned char const   *)src, bytes);
#line 199
  return;
}
}
#line 204 "packet.c"
void packet_decrypt(CipherContext *cc , void *dest , void *src , unsigned int bytes ) 
{ int i ;

  {
#line 210
  if (! (bytes % 8U == 0U)) {
#line 210
    __assert_fail("(bytes % 8) == 0", "packet.c", 210U, "packet_decrypt");
  }
#line 217
  switch ((int )cc->type) {
  case 0: 
#line 220
  i = 0;
#line 221
  break;
  default: 
#line 223
  i = detect_attack((unsigned char *)src, bytes, (unsigned char *)((void *)0));
#line 224
  break;
  }
#line 227
  if (i == 1) {
#line 228
    packet_disconnect("crc32 compensation attack: network attack detected");
  }
#line 230
  cipher_decrypt(cc, (unsigned char *)dest, (unsigned char const   *)src, bytes);
#line 231
  return;
}
}
#line 237 "packet.c"
void packet_set_encryption_key(unsigned char const   *key , unsigned int keylen ,
                               int cipher , int is_client ) 
{ 

  {
#line 241
  cipher_type = cipher;
#line 242
  if (cipher == 5) {
#line 244
    if (is_client) {
#line 246
      cipher_set_key(& receive_context, cipher, key, (int )(keylen / 2U), 0);
#line 247
      cipher_set_key(& send_context, cipher, key + keylen / 2U, (int )(keylen / 2U),
                     1);
    } else {
#line 252
      cipher_set_key(& receive_context, cipher, key + keylen / 2U, (int )(keylen / 2U),
                     0);
#line 254
      cipher_set_key(& send_context, cipher, key, (int )(keylen / 2U), 1);
    }
  } else {
#line 260
    cipher_set_key(& receive_context, cipher, key, (int )keylen, 0);
#line 261
    cipher_set_key(& send_context, cipher, key, (int )keylen, 1);
  }
#line 263
  return;
}
}
#line 267 "packet.c"
void packet_start(int type ) 
{ char buf[9] ;

  {
#line 272
  buffer_clear(& outgoing_packet);
#line 273
  memset((void *)(buf), 0, 8U);
#line 274
  buf[8] = (char )type;
#line 275
  buffer_append(& outgoing_packet, (char const   *)(buf), 9U);
#line 276
  return;
}
}
#line 280 "packet.c"
void packet_put_char(int value ) 
{ char ch ;

  {
#line 283
  ch = (char )value;
#line 284
  buffer_append(& outgoing_packet, (char const   *)(& ch), 1U);
#line 285
  return;
}
}
#line 289 "packet.c"
void packet_put_int(unsigned int value ) 
{ 

  {
#line 292
  buffer_put_int(& outgoing_packet, value);
#line 293
  return;
}
}
#line 297 "packet.c"
void packet_put_string(char const   *buf , unsigned int len ) 
{ 

  {
#line 300
  buffer_put_string(& outgoing_packet, (void const   *)buf, len);
#line 301
  return;
}
}
#line 305 "packet.c"
void packet_put_bignum(BIGNUM *value ) 
{ 

  {
#line 308
  buffer_put_bignum(& outgoing_packet, value);
#line 309
  return;
}
}
#line 314 "packet.c"
void packet_send(void) 
{ char buf[8] ;
  char *cp ;
  int i ;
  int padding ;
  int len ;
  unsigned int checksum ;
  u_int32_t rand___0 ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned char tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;

  {
#line 320
  rand___0 = (u_int32_t )0;
#line 324
  if (packet_compression) {
#line 326
    buffer_clear(& compression_buffer);
#line 327
    buffer_consume(& outgoing_packet, 8U);
#line 328
    buffer_append(& compression_buffer, "\000\000\000\000\000\000\000\000", 8U);
#line 329
    buffer_compress(& outgoing_packet, & compression_buffer);
#line 330
    buffer_clear(& outgoing_packet);
#line 331
    tmp = buffer_len(& compression_buffer);
#line 331
    tmp___0 = buffer_ptr(& compression_buffer);
#line 331
    buffer_append(& outgoing_packet, (char const   *)tmp___0, tmp);
  }
#line 336
  tmp___1 = buffer_len(& outgoing_packet);
#line 336
  len = (int )((tmp___1 + 4U) - 8U);
#line 339
  padding = 8 - len % 8;
#line 340
  if (cipher_type != 0) {
#line 342
    cp = buffer_ptr(& outgoing_packet);
#line 343
    i = 0;
#line 343
    while (i < padding) {
#line 344
      if (i % 4 == 0) {
#line 345
        tmp___2 = arc4random();
#line 345
        rand___0 = (unsigned int )tmp___2;
      }
#line 346
      *(cp + (7 - i)) = (char )(rand___0 & 255U);
#line 347
      rand___0 >>= 8;
#line 343
      i ++;
    }
  }
#line 350
  buffer_consume(& outgoing_packet, (unsigned int )(8 - padding));
#line 353
  tmp___3 = buffer_len(& outgoing_packet);
#line 353
  tmp___4 = buffer_ptr(& outgoing_packet);
#line 353
  checksum = crc32((unsigned char const   *)((unsigned char *)tmp___4), tmp___3);
#line 355
  while (1) {
#line 355
    buf[0] = (char )(checksum >> 24);
#line 355
    buf[1] = (char )(checksum >> 16);
#line 355
    buf[2] = (char )(checksum >> 8);
#line 355
    buf[3] = (char )checksum;
#line 355
    break;
  }
#line 356
  buffer_append(& outgoing_packet, (char const   *)(buf), 4U);
#line 364
  while (1) {
#line 364
    buf[0] = (char )(len >> 24);
#line 364
    buf[1] = (char )(len >> 16);
#line 364
    buf[2] = (char )(len >> 8);
#line 364
    buf[3] = (char )len;
#line 364
    break;
  }
#line 365
  buffer_append(& output, (char const   *)(buf), 4U);
#line 366
  tmp___5 = buffer_len(& outgoing_packet);
#line 366
  buffer_append_space(& output, & cp, tmp___5);
#line 367
  tmp___6 = buffer_len(& outgoing_packet);
#line 367
  tmp___7 = buffer_ptr(& outgoing_packet);
#line 367
  packet_encrypt(& send_context, (void *)cp, (void *)tmp___7, tmp___6);
#line 374
  buffer_clear(& outgoing_packet);
#line 378
  return;
}
}
#line 384 "packet.c"
int packet_read(int *payload_len_ptr ) 
{ int type ;
  int len ;
  fd_set set ;
  char buf[8192] ;
  int _p ;
  int _e ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 392
  packet_write_wait();
#line 395
  while (1) {
#line 398
    type = packet_read_poll(payload_len_ptr);
#line 399
    if (type == 14) {
      goto _L;
    } else {
#line 399
      if (type == 15) {
        goto _L;
      } else {
#line 399
        if (type == 19) {
          goto _L;
        } else {
#line 399
          if (type == 33) {
            _L: /* CIL Label */ 
#line 403
            while (1) {
#line 403
              _p = *payload_len_ptr;
#line 403
              _e = 0;
#line 403
              if (_p != _e) {
#line 403
                log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "packet.c",
                    403);
#line 403
                packet_disconnect("Packet integrity error. (%d)", type);
              }
#line 403
              break;
            }
          }
        }
      }
    }
#line 405
    if (type != 0) {
#line 406
      return (type);
    }
#line 409
    while (1) {
#line 409
      __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& set.__fds_bits[0]): "memory");
#line 409
      break;
    }
#line 410
    __asm__  volatile   ("btsl %1,%0": "=m" (set.__fds_bits[(unsigned int )connection_in / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 412
    select(connection_in + 1, (fd_set * __restrict  )(& set), (fd_set * __restrict  )((void *)0),
           (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 414
    len = read(connection_in, (void *)(buf), sizeof(buf));
#line 415
    if (len == 0) {
#line 416
      fatal("Connection closed by remote host.");
    }
#line 417
    if (len < 0) {
#line 418
      tmp = __errno_location();
#line 418
      tmp___0 = strerror(*tmp);
#line 418
      fatal("Read from socket failed: %.100s", tmp___0);
    }
#line 420
    packet_process_incoming((char const   *)(buf), (unsigned int )len);
  }
}
}
#line 428 "packet.c"
void packet_read_expect(int *payload_len_ptr , int expected_type ) 
{ int type ;

  {
#line 433
  type = packet_read(payload_len_ptr);
#line 434
  if (type != expected_type) {
#line 435
    packet_disconnect("Protocol error: expected packet type %d, got %d", expected_type,
                      type);
  }
#line 437
  return;
}
}
#line 456 "packet.c"
int packet_read_poll(int *payload_len_ptr ) 
{ unsigned int len ;
  unsigned int padded_len ;
  unsigned char *ucp ;
  char buf[8] ;
  char *cp ;
  unsigned int checksum ;
  unsigned int stored_checksum ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  char *tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  unsigned int tmp___5 ;
  char *tmp___6 ;
  unsigned int tmp___7 ;
  char *tmp___8 ;
  unsigned int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
  restart: 
#line 467
  tmp = buffer_len(& input);
#line 467
  if (tmp < 12U) {
#line 468
    return (0);
  }
#line 470
  tmp___0 = buffer_ptr(& input);
#line 470
  ucp = (unsigned char *)tmp___0;
#line 471
  len = (unsigned int )(((((unsigned long )*(ucp + 0) << 24) | ((unsigned long )*(ucp + 1) << 16)) | ((unsigned long )*(ucp + 2) << 8)) | (unsigned long )*(ucp + 3));
#line 472
  if (len < 5U) {
#line 473
    packet_disconnect("Bad packet length %d.", len);
  } else {
#line 472
    if (len > 262144U) {
#line 473
      packet_disconnect("Bad packet length %d.", len);
    }
  }
#line 474
  padded_len = (len + 8U) & 4294967288U;
#line 477
  tmp___1 = buffer_len(& input);
#line 477
  if (tmp___1 < 4U + padded_len) {
#line 478
    return (0);
  }
#line 483
  buffer_consume(& input, 4U);
#line 486
  buffer_clear(& incoming_packet);
#line 487
  buffer_append_space(& incoming_packet, & cp, padded_len);
#line 488
  tmp___2 = buffer_ptr(& input);
#line 488
  packet_decrypt(& receive_context, (void *)cp, (void *)tmp___2, padded_len);
#line 489
  buffer_consume(& input, padded_len);
#line 496
  tmp___3 = buffer_len(& incoming_packet);
#line 496
  tmp___4 = buffer_ptr(& incoming_packet);
#line 496
  checksum = crc32((unsigned char const   *)((unsigned char *)tmp___4), tmp___3 - 4U);
#line 500
  buffer_consume(& incoming_packet, 8U - len % 8U);
#line 503
  tmp___5 = buffer_len(& incoming_packet);
#line 503
  if (! (len == tmp___5)) {
#line 503
    __assert_fail("len == buffer_len(&incoming_packet)", "packet.c", 503U, "packet_read_poll");
  }
#line 504
  tmp___6 = buffer_ptr(& incoming_packet);
#line 504
  ucp = ((unsigned char *)tmp___6 + len) - 4;
#line 505
  stored_checksum = (unsigned int )(((((unsigned long )*(ucp + 0) << 24) | ((unsigned long )*(ucp + 1) << 16)) | ((unsigned long )*(ucp + 2) << 8)) | (unsigned long )*(ucp + 3));
#line 506
  if (checksum != stored_checksum) {
#line 507
    packet_disconnect("Corrupted check bytes on input.");
  }
#line 508
  buffer_consume_end(& incoming_packet, 4U);
#line 511
  if (packet_compression) {
#line 513
    buffer_clear(& compression_buffer);
#line 514
    buffer_uncompress(& incoming_packet, & compression_buffer);
#line 515
    buffer_clear(& incoming_packet);
#line 516
    tmp___7 = buffer_len(& compression_buffer);
#line 516
    tmp___8 = buffer_ptr(& compression_buffer);
#line 516
    buffer_append(& incoming_packet, (char const   *)tmp___8, tmp___7);
  }
#line 521
  buffer_get(& incoming_packet, buf, 1U);
#line 524
  tmp___9 = buffer_len(& incoming_packet);
#line 524
  *payload_len_ptr = (int )tmp___9;
#line 527
  if ((int )((unsigned char )buf[0]) == 1) {
#line 528
    tmp___10 = packet_get_string((unsigned int *)((void *)0));
#line 528
    fatal("%.900s", tmp___10);
  }
#line 531
  if ((int )((unsigned char )buf[0]) == 32) {
    goto restart;
  }
#line 535
  if ((int )((unsigned char )buf[0]) == 36) {
#line 537
    tmp___11 = packet_get_string((unsigned int *)((void *)0));
#line 537
    debug("Remote: %.900s", tmp___11);
    goto restart;
  }
#line 542
  return ((int )((unsigned char )buf[0]));
}
}
#line 548 "packet.c"
void packet_process_incoming(char const   *buf , unsigned int len ) 
{ 

  {
#line 551
  buffer_append(& input, buf, len);
#line 552
  return;
}
}
#line 556 "packet.c"
unsigned int packet_get_char(void) 
{ char ch ;

  {
#line 560
  buffer_get(& incoming_packet, & ch, 1U);
#line 561
  return ((unsigned int )((unsigned char )ch));
}
}
#line 566 "packet.c"
unsigned int packet_get_int(void) 
{ unsigned int tmp ;

  {
#line 569
  tmp = buffer_get_int(& incoming_packet);
#line 569
  return (tmp);
}
}
#line 575 "packet.c"
void packet_get_bignum(BIGNUM *value , int *length_ptr ) 
{ 

  {
#line 578
  *length_ptr = buffer_get_bignum(& incoming_packet, value);
#line 579
  return;
}
}
#line 586 "packet.c"
char *packet_get_string(unsigned int *length_ptr ) 
{ char *tmp ;

  {
#line 589
  tmp = buffer_get_string(& incoming_packet, length_ptr);
#line 589
  return (tmp);
}
}
#line 600 "packet.c"
void packet_send_debug(char const   *fmt  , ...) 
{ char buf[1024] ;
  va_list args ;
  size_t tmp ;

  {
#line 606
  __builtin_va_start(args, fmt);
#line 607
  vsnprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )fmt,
            args);
#line 608
  __builtin_va_end(args);
#line 610
  packet_start(36);
#line 611
  tmp = strlen((char const   *)(buf));
#line 611
  packet_put_string((char const   *)(buf), tmp);
#line 612
  packet_send();
#line 613
  packet_write_wait();
#line 614
  return;
}
}
#line 626 "packet.c"
static int disconnecting  =    0;
#line 621 "packet.c"
void packet_disconnect(char const   *fmt  , ...) 
{ char buf[1024] ;
  va_list args ;
  size_t tmp ;

  {
#line 627
  if (disconnecting) {
#line 628
    fatal("packet_disconnect called recursively.");
  }
#line 629
  disconnecting = 1;
#line 633
  __builtin_va_start(args, fmt);
#line 634
  vsnprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )fmt,
            args);
#line 635
  __builtin_va_end(args);
#line 639
  packet_start(1);
#line 640
  tmp = strlen((char const   *)(buf));
#line 640
  packet_put_string((char const   *)(buf), tmp);
#line 641
  packet_send();
#line 642
  packet_write_wait();
#line 645
  channel_stop_listening();
#line 648
  packet_close();
#line 651
  fatal("Local: %.100s", buf);
#line 652
  return;
}
}
#line 657 "packet.c"
void packet_write_poll(void) 
{ int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
#line 660
  tmp = buffer_len(& output);
#line 660
  len = (int )tmp;
#line 661
  if (len > 0) {
#line 663
    tmp___0 = buffer_ptr(& output);
#line 663
    len = write(connection_out, (void const   *)tmp___0, (unsigned int )len);
#line 664
    if (len <= 0) {
#line 665
      tmp___3 = __errno_location();
#line 665
      if (*tmp___3 == 11) {
#line 666
        return;
      } else {
#line 668
        tmp___1 = __errno_location();
#line 668
        tmp___2 = strerror(*tmp___1);
#line 668
        fatal("Write failed: %.100s", tmp___2);
      }
    }
#line 670
    buffer_consume(& output, (unsigned int )len);
  }
#line 672
  return;
}
}
#line 677 "packet.c"
void packet_write_wait(void) 
{ fd_set set ;
  int __d0 ;
  int __d1 ;
  int tmp ;

  {
#line 680
  packet_write_poll();
#line 681
  while (1) {
#line 681
    tmp = packet_have_data_to_write();
#line 681
    if (! tmp) {
#line 681
      break;
    }
#line 684
    while (1) {
#line 684
      __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& set.__fds_bits[0]): "memory");
#line 684
      break;
    }
#line 685
    __asm__  volatile   ("btsl %1,%0": "=m" (set.__fds_bits[(unsigned int )connection_out / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 686
    select(connection_out + 1, (fd_set * __restrict  )((void *)0), (fd_set * __restrict  )(& set),
           (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 687
    packet_write_poll();
  }
#line 689
  return;
}
}
#line 693 "packet.c"
int packet_have_data_to_write(void) 
{ unsigned int tmp ;

  {
#line 696
  tmp = buffer_len(& output);
#line 696
  return (tmp != 0U);
}
}
#line 701 "packet.c"
int packet_not_very_much_data_to_write(void) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 704
  if (interactive_mode) {
#line 705
    tmp = buffer_len(& output);
#line 705
    return (tmp < 16384U);
  } else {
#line 707
    tmp___0 = buffer_len(& output);
#line 707
    return (tmp___0 < 131072U);
  }
}
}
#line 712 "packet.c"
void packet_set_interactive(int interactive , int keepalives ) 
{ int on ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int lowdelay ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int throughput ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
#line 715
  on = 1;
#line 718
  interactive_mode = interactive;
#line 722
  if (connection_in != connection_out) {
#line 723
    return;
  }
#line 725
  if (keepalives) {
#line 728
    tmp___1 = setsockopt(connection_in, 1, 9, (void const   *)((void *)(& on)), sizeof(on));
#line 728
    if (tmp___1 < 0) {
#line 730
      tmp = __errno_location();
#line 730
      tmp___0 = strerror(*tmp);
#line 730
      error("setsockopt SO_KEEPALIVE: %.100s", tmp___0);
    }
  }
#line 733
  if (interactive) {
#line 737
    lowdelay = 16;
#line 738
    tmp___4 = setsockopt(connection_in, 0, 1, (void const   *)((void *)(& lowdelay)),
                         sizeof(lowdelay));
#line 738
    if (tmp___4 < 0) {
#line 740
      tmp___2 = __errno_location();
#line 740
      tmp___3 = strerror(*tmp___2);
#line 740
      error("setsockopt IPTOS_LOWDELAY: %.100s", tmp___3);
    }
#line 741
    tmp___7 = setsockopt(connection_in, 6, 1, (void const   *)((void *)(& on)), sizeof(on));
#line 741
    if (tmp___7 < 0) {
#line 743
      tmp___5 = __errno_location();
#line 743
      tmp___6 = strerror(*tmp___5);
#line 743
      error("setsockopt TCP_NODELAY: %.100s", tmp___6);
    }
  } else {
#line 749
    throughput = 8;
#line 750
    tmp___10 = setsockopt(connection_in, 0, 1, (void const   *)((void *)(& throughput)),
                          sizeof(throughput));
#line 750
    if (tmp___10 < 0) {
#line 752
      tmp___8 = __errno_location();
#line 752
      tmp___9 = strerror(*tmp___8);
#line 752
      error("setsockopt IPTOS_THROUGHPUT: %.100s", tmp___9);
    }
  }
#line 754
  return;
}
}
#line 758 "packet.c"
int packet_is_interactive(void) 
{ 

  {
#line 761
  return (interactive_mode);
}
}
#line 1 "readpass.o"
#line 92 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 117
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 142 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 143
extern struct _IO_FILE *stdout ;
#line 218
extern int fflush(FILE *__stream ) ;
#line 759
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 67 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 71
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
#line 330 "ssh.h"
char *read_passphrase(char const   *prompt , int from_stdin ) ;
#line 23 "readpass.c"
static struct termios saved_tio  ;
#line 26 "readpass.c"
static void (*old_handler)(int sig )  =    (void (*)(int sig ))((void *)0);
#line 30 "readpass.c"
void intr_handler(int sig ) 
{ int tmp ;
  __pid_t tmp___0 ;

  {
#line 33
  tmp = fileno(stdin);
#line 33
  tcsetattr(tmp, 0, (struct termios  const  *)(& saved_tio));
#line 35
  signal(sig, old_handler);
#line 37
  tmp___0 = getpid();
#line 37
  kill(tmp___0, sig);
#line 38
  return;
}
}
#line 45 "readpass.c"
char *read_passphrase(char const   *prompt , int from_stdin ) 
{ char buf[1024] ;
  char *cp ;
  struct termios tio ;
  FILE *f ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___5 ;
  char *tmp___7 ;

  {
#line 51
  if (from_stdin) {
#line 52
    f = stdin;
  } else {
#line 57
    f = fopen((char const   * __restrict  )"/dev/tty", (char const   * __restrict  )"r");
#line 58
    if (! f) {
#line 61
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"You have no controlling tty and no DISPLAY.  Cannot read passphrase.\n");
#line 62
      exit(1);
    }
  }
#line 67
  fflush(stdout);
#line 68
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", prompt);
#line 69
  fflush(stderr);
#line 72
  tmp = fileno(f);
#line 72
  tcgetattr(tmp, & tio);
#line 73
  saved_tio = tio;
#line 75
  old_handler = signal(2, & intr_handler);
#line 78
  tio.c_lflag &= 4294967175U;
#line 79
  tmp___0 = fileno(f);
#line 79
  tcsetattr(tmp___0, 0, (struct termios  const  *)(& tio));
#line 82
  tmp___2 = fgets((char * __restrict  )(buf), (int )sizeof(buf), (FILE * __restrict  )f);
#line 82
  if ((unsigned int )tmp___2 == (unsigned int )((void *)0)) {
#line 86
    tmp___1 = fileno(f);
#line 86
    tcsetattr(tmp___1, 0, (struct termios  const  *)(& saved_tio));
#line 88
    signal(2, old_handler);
#line 90
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 92
    if ((unsigned int )f != (unsigned int )stdin) {
#line 93
      fclose(f);
    }
#line 94
    exit(1);
  }
#line 97
  tmp___3 = fileno(f);
#line 97
  tcsetattr(tmp___3, 0, (struct termios  const  *)(& saved_tio));
#line 99
  signal(2, old_handler);
#line 101
  tmp___7 = __builtin_strchr(buf, '\n');
#line 101
  if (tmp___7) {
#line 102
    tmp___5 = __builtin_strchr(buf, '\n');
#line 102
    *tmp___5 = (char)0;
  }
#line 104
  cp = xstrdup((char const   *)(buf));
#line 107
  memset((void *)(buf), 0, sizeof(buf));
#line 109
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 111
  if ((unsigned int )f != (unsigned int )stdin) {
#line 112
    fclose(f);
  }
#line 113
  return (cp);
}
}
#line 1 "rsa.o"
#line 333 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 410 "/usr/include/openssl/bn.h"
extern BIGNUM *BN_copy(BIGNUM *a , BIGNUM const   *b ) ;
#line 221 "/usr/include/openssl/rsa.h"
extern RSA *RSA_generate_key(int bits , unsigned long e , void (*callback)(int  ,
                                                                           int  ,
                                                                           void * ) ,
                             void *cb_arg ) ;
#line 230
extern int RSA_public_encrypt(int flen , unsigned char const   *from , unsigned char *to ,
                              RSA *rsa , int padding ) ;
#line 236
extern int RSA_private_decrypt(int flen , unsigned char const   *from , unsigned char *to ,
                               RSA *rsa , int padding ) ;
#line 238
extern void RSA_free(RSA *r ) ;
#line 25 "rsa.h"
void rsa_generate_key(RSA *prv , RSA *pub , unsigned int bits ) ;
#line 29
void rsa_set_verbose(int verbose ) ;
#line 31
int rsa_alive(void) ;
#line 33
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 34
void rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 44 "rsa.c"
int rsa_verbose  =    1;
#line 46 "rsa.c"
int rsa_alive(void) 
{ RSA *key ;

  {
#line 51
  key = RSA_generate_key(32, 3UL, (void (*)(int  , int  , void * ))((void *)0), (void *)0);
#line 52
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 53
    return (0);
  }
#line 54
  RSA_free(key);
#line 55
  return (1);
}
}
#line 62 "rsa.c"
void rsa_generate_key(RSA *prv , RSA *pub , unsigned int bits ) 
{ RSA *key ;

  {
#line 67
  if (rsa_verbose) {
#line 68
    printf((char const   * __restrict  )"Generating RSA keys:  ");
#line 69
    fflush(stdout);
  }
#line 72
  key = RSA_generate_key((int )bits, 35UL, (void (*)(int  , int  , void * ))((void *)0),
                         (void *)0);
#line 74
  if (! ((unsigned int )key != (unsigned int )((void *)0))) {
#line 74
    __assert_fail("key != ((void *)0)", "rsa.c", 74U, "rsa_generate_key");
  }
#line 77
  pub->n = BN_new();
#line 78
  BN_copy(pub->n, (BIGNUM const   *)key->n);
#line 79
  pub->e = BN_new();
#line 80
  BN_copy(pub->e, (BIGNUM const   *)key->e);
#line 83
  prv->n = BN_new();
#line 84
  BN_copy(prv->n, (BIGNUM const   *)key->n);
#line 85
  prv->e = BN_new();
#line 86
  BN_copy(prv->e, (BIGNUM const   *)key->e);
#line 87
  prv->d = BN_new();
#line 88
  BN_copy(prv->d, (BIGNUM const   *)key->d);
#line 89
  prv->p = BN_new();
#line 90
  BN_copy(prv->p, (BIGNUM const   *)key->p);
#line 91
  prv->q = BN_new();
#line 92
  BN_copy(prv->q, (BIGNUM const   *)key->q);
#line 94
  prv->dmp1 = BN_new();
#line 95
  BN_copy(prv->dmp1, (BIGNUM const   *)key->dmp1);
#line 97
  prv->dmq1 = BN_new();
#line 98
  BN_copy(prv->dmq1, (BIGNUM const   *)key->dmq1);
#line 100
  prv->iqmp = BN_new();
#line 101
  BN_copy(prv->iqmp, (BIGNUM const   *)key->iqmp);
#line 103
  RSA_free(key);
#line 105
  if (rsa_verbose) {
#line 106
    printf((char const   * __restrict  )"Key generation complete.\n");
  }
#line 107
  return;
}
}
#line 109 "rsa.c"
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ char *inbuf ;
  char *outbuf ;
  int len ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 115
  tmp = BN_num_bits((BIGNUM const   *)key->e);
#line 115
  if (tmp < 2) {
#line 116
    fatal("rsa_public_encrypt() exponent too small or not odd");
  } else {
#line 115
    if ((key->e)->top > 0) {
#line 115
      if (! (*((key->e)->d + 0) & 1UL)) {
#line 116
        fatal("rsa_public_encrypt() exponent too small or not odd");
      }
    } else {
#line 116
      fatal("rsa_public_encrypt() exponent too small or not odd");
    }
  }
#line 118
  tmp___0 = BN_num_bits((BIGNUM const   *)key->n);
#line 118
  len = (tmp___0 + 7) / 8;
#line 119
  tmp___1 = xmalloc((unsigned int )len);
#line 119
  outbuf = (char *)tmp___1;
#line 121
  tmp___2 = BN_num_bits((BIGNUM const   *)in);
#line 121
  len = (tmp___2 + 7) / 8;
#line 122
  tmp___3 = xmalloc((unsigned int )len);
#line 122
  inbuf = (char *)tmp___3;
#line 123
  BN_bn2bin((BIGNUM const   *)in, (unsigned char *)inbuf);
#line 125
  len = RSA_public_encrypt(len, (unsigned char const   *)inbuf, (unsigned char *)outbuf,
                           key, 1);
#line 125
  if (len <= 0) {
#line 127
    fatal("rsa_public_encrypt() failed");
  }
#line 129
  BN_bin2bn((unsigned char const   *)outbuf, len, out);
#line 131
  xfree((void *)outbuf);
#line 132
  xfree((void *)inbuf);
#line 133
  return;
}
}
#line 135 "rsa.c"
void rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ char *inbuf ;
  char *outbuf ;
  int len ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 141
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 141
  len = (tmp + 7) / 8;
#line 142
  tmp___0 = xmalloc((unsigned int )len);
#line 142
  outbuf = (char *)tmp___0;
#line 144
  tmp___1 = BN_num_bits((BIGNUM const   *)in);
#line 144
  len = (tmp___1 + 7) / 8;
#line 145
  tmp___2 = xmalloc((unsigned int )len);
#line 145
  inbuf = (char *)tmp___2;
#line 146
  BN_bn2bin((BIGNUM const   *)in, (unsigned char *)inbuf);
#line 148
  len = RSA_private_decrypt(len, (unsigned char const   *)inbuf, (unsigned char *)outbuf,
                            key, 2);
#line 148
  if (len <= 0) {
#line 150
    fatal("rsa_private_decrypt() failed");
  }
#line 152
  BN_bin2bn((unsigned char const   *)outbuf, len, out);
#line 154
  xfree((void *)outbuf);
#line 155
  xfree((void *)inbuf);
#line 156
  return;
}
}
#line 160 "rsa.c"
void rsa_set_verbose(int verbose ) 
{ 

  {
#line 163
  rsa_verbose = verbose;
#line 164
  return;
}
}
#line 1 "tildexpand.o"
#line 111 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 117
extern struct passwd *getpwnam(char const   *__name ) ;
#line 544 "ssh.h"
char *tilde_expand_filename(char const   *filename , uid_t my_uid ) ;
#line 23 "tildexpand.c"
char *tilde_expand_filename(char const   *filename , uid_t my_uid ) 
{ char const   *cp ;
  unsigned int userlen ;
  char *expanded ;
  struct passwd *pw ;
  char user[100] ;
  char *tmp ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;

  {
#line 32
  if ((int const   )*(filename + 0) != 126) {
#line 33
    tmp = xstrdup(filename);
#line 33
    return (tmp);
  }
#line 36
  filename ++;
#line 39
  tmp___1 = __builtin_strchr((char *)filename, '/');
#line 39
  cp = (char const   *)tmp___1;
#line 40
  if (cp) {
#line 41
    userlen = (unsigned int )(cp - filename);
  } else {
#line 43
    userlen = strlen(filename);
  }
#line 44
  if (userlen == 0U) {
#line 45
    pw = getpwuid(my_uid);
  } else {
#line 49
    if (userlen > sizeof(user) - 1U) {
#line 50
      fatal("User name after tilde too long.");
    }
#line 51
    memcpy((void * __restrict  )(user), (void const   * __restrict  )filename, userlen);
#line 52
    user[userlen] = (char)0;
#line 53
    pw = getpwnam((char const   *)(user));
  }
#line 57
  if (! pw) {
#line 58
    fatal("Unknown user %100s.", user);
  }
#line 61
  if (! cp) {
#line 63
    tmp___2 = xstrdup((char const   *)pw->pw_dir);
#line 63
    return (tmp___2);
  }
#line 67
  tmp___3 = strlen((char const   *)pw->pw_dir);
#line 67
  tmp___4 = strlen(cp + 1);
#line 67
  tmp___5 = xmalloc((tmp___3 + tmp___4) + 2U);
#line 67
  expanded = (char *)tmp___5;
#line 68
  sprintf((char * __restrict  )expanded, (char const   * __restrict  )"%s/%s", pw->pw_dir,
          cp + 1);
#line 69
  return (expanded);
}
}
#line 1 "ttymodes.o"
#line 49 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) speed_t cfgetospeed(struct termios  const  *__termios_p ) ;
#line 52
extern  __attribute__((__nothrow__)) speed_t cfgetispeed(struct termios  const  *__termios_p ) ;
#line 55
extern  __attribute__((__nothrow__)) int cfsetospeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 58
extern  __attribute__((__nothrow__)) int cfsetispeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 151 "packet.h"
void tty_make_modes(int fd ) ;
#line 154
void tty_parse_modes(int fd , int *n_bytes_ptr ) ;
#line 32 "ttymodes.c"
static int speed_to_baud(speed_t speed ) 
{ 

  {
#line 34
  switch ((int )speed) {
  case 0: 
#line 37
  return (0);
  case 1: 
#line 39
  return (50);
  case 2: 
#line 41
  return (75);
  case 3: 
#line 43
  return (110);
  case 4: 
#line 45
  return (134);
  case 5: 
#line 47
  return (150);
  case 6: 
#line 49
  return (200);
  case 7: 
#line 51
  return (300);
  case 8: 
#line 53
  return (600);
  case 9: 
#line 55
  return (1200);
  case 10: 
#line 57
  return (1800);
  case 11: 
#line 59
  return (2400);
  case 12: 
#line 61
  return (4800);
  case 13: 
#line 63
  return (9600);
  case 14: 
#line 67
  return (19200);
  case 15: 
#line 77
  return (38400);
  case 4097: 
#line 99
  return (57600);
  case 4098: 
#line 107
  return (115200);
  case 4099: 
#line 111
  return (230400);
  default: ;
#line 114
  return (9600);
  }
}
}
#line 120 "ttymodes.c"
static speed_t baud_to_speed(int baud ) 
{ 

  {
#line 122
  switch (baud) {
  case 0: 
#line 125
  return (0U);
  case 50: 
#line 127
  return (1U);
  case 75: 
#line 129
  return (2U);
  case 110: 
#line 131
  return (3U);
  case 134: 
#line 133
  return (4U);
  case 150: 
#line 135
  return (5U);
  case 200: 
#line 137
  return (6U);
  case 300: 
#line 139
  return (7U);
  case 600: 
#line 141
  return (8U);
  case 1200: 
#line 143
  return (9U);
  case 1800: 
#line 145
  return (10U);
  case 2400: 
#line 147
  return (11U);
  case 4800: 
#line 149
  return (12U);
  case 9600: 
#line 151
  return (13U);
  case 19200: 
#line 155
  return (14U);
  case 38400: 
#line 165
  return (15U);
  case 57600: 
#line 187
  return (4097U);
  case 115200: 
#line 195
  return (4098U);
  case 230400: 
#line 199
  return (4099U);
  default: ;
#line 202
  return (13U);
  }
}
}
#line 209 "ttymodes.c"
void tty_make_modes(int fd ) 
{ struct termios tio ;
  int baud ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  speed_t tmp___2 ;
  speed_t tmp___3 ;

  {
#line 215
  tmp___1 = tcgetattr(fd, & tio);
#line 215
  if (tmp___1 < 0) {
#line 217
    packet_put_char(0);
#line 218
    tmp = __errno_location();
#line 218
    tmp___0 = strerror(*tmp);
#line 218
    log("tcgetattr: %.100s", tmp___0);
#line 219
    return;
  }
#line 223
  tmp___2 = cfgetospeed((struct termios  const  *)(& tio));
#line 223
  baud = speed_to_baud(tmp___2);
#line 224
  packet_put_char(193);
#line 225
  packet_put_int((unsigned int )baud);
#line 226
  tmp___3 = cfgetispeed((struct termios  const  *)(& tio));
#line 226
  baud = speed_to_baud(tmp___3);
#line 227
  packet_put_char(192);
#line 228
  packet_put_int((unsigned int )baud);
#line 34 "ttymodes.h"
  packet_put_char(1);
#line 34
  packet_put_char((int )tio.c_cc[0]);
#line 35
  packet_put_char(2);
#line 35
  packet_put_char((int )tio.c_cc[1]);
#line 36
  packet_put_char(3);
#line 36
  packet_put_char((int )tio.c_cc[2]);
#line 38
  packet_put_char(4);
#line 38
  packet_put_char((int )tio.c_cc[3]);
#line 40
  packet_put_char(5);
#line 40
  packet_put_char((int )tio.c_cc[4]);
#line 42
  packet_put_char(6);
#line 42
  packet_put_char((int )tio.c_cc[11]);
#line 45
  packet_put_char(7);
#line 45
  packet_put_char((int )tio.c_cc[16]);
#line 47
  packet_put_char(8);
#line 47
  packet_put_char((int )tio.c_cc[8]);
#line 48
  packet_put_char(9);
#line 48
  packet_put_char((int )tio.c_cc[9]);
#line 50
  packet_put_char(10);
#line 50
  packet_put_char((int )tio.c_cc[10]);
#line 56
  packet_put_char(12);
#line 56
  packet_put_char((int )tio.c_cc[12]);
#line 59
  packet_put_char(13);
#line 59
  packet_put_char((int )tio.c_cc[14]);
#line 62
  packet_put_char(14);
#line 62
  packet_put_char((int )tio.c_cc[15]);
#line 74
  packet_put_char(18);
#line 74
  packet_put_char((int )tio.c_cc[13]);
#line 78
  packet_put_char(30);
#line 78
  packet_put_char((tio.c_iflag & 4U) != 0U);
#line 79
  packet_put_char(31);
#line 79
  packet_put_char((tio.c_iflag & 8U) != 0U);
#line 80
  packet_put_char(32);
#line 80
  packet_put_char((tio.c_iflag & 16U) != 0U);
#line 81
  packet_put_char(33);
#line 81
  packet_put_char((tio.c_iflag & 32U) != 0U);
#line 82
  packet_put_char(34);
#line 82
  packet_put_char((tio.c_iflag & 64U) != 0U);
#line 83
  packet_put_char(35);
#line 83
  packet_put_char((tio.c_iflag & 128U) != 0U);
#line 84
  packet_put_char(36);
#line 84
  packet_put_char((tio.c_iflag & 256U) != 0U);
#line 86
  packet_put_char(37);
#line 86
  packet_put_char((tio.c_iflag & 512U) != 0U);
#line 88
  packet_put_char(38);
#line 88
  packet_put_char((tio.c_iflag & 1024U) != 0U);
#line 89
  packet_put_char(39);
#line 89
  packet_put_char((tio.c_iflag & 2048U) != 0U);
#line 90
  packet_put_char(40);
#line 90
  packet_put_char((tio.c_iflag & 4096U) != 0U);
#line 92
  packet_put_char(41);
#line 92
  packet_put_char((tio.c_iflag & 8192U) != 0U);
#line 95
  packet_put_char(50);
#line 95
  packet_put_char((tio.c_lflag & 1U) != 0U);
#line 96
  packet_put_char(51);
#line 96
  packet_put_char((tio.c_lflag & 2U) != 0U);
#line 98
  packet_put_char(52);
#line 98
  packet_put_char((tio.c_lflag & 4U) != 0U);
#line 100
  packet_put_char(53);
#line 100
  packet_put_char((tio.c_lflag & 8U) != 0U);
#line 101
  packet_put_char(54);
#line 101
  packet_put_char((tio.c_lflag & 16U) != 0U);
#line 102
  packet_put_char(55);
#line 102
  packet_put_char((tio.c_lflag & 32U) != 0U);
#line 103
  packet_put_char(56);
#line 103
  packet_put_char((tio.c_lflag & 64U) != 0U);
#line 104
  packet_put_char(57);
#line 104
  packet_put_char((tio.c_lflag & 128U) != 0U);
#line 105
  packet_put_char(58);
#line 105
  packet_put_char((tio.c_lflag & 256U) != 0U);
#line 107
  packet_put_char(59);
#line 107
  packet_put_char((tio.c_lflag & 32768U) != 0U);
#line 110
  packet_put_char(60);
#line 110
  packet_put_char((tio.c_lflag & 512U) != 0U);
#line 113
  packet_put_char(61);
#line 113
  packet_put_char((tio.c_lflag & 2048U) != 0U);
#line 116
  packet_put_char(62);
#line 116
  packet_put_char((tio.c_lflag & 16384U) != 0U);
#line 119
  packet_put_char(70);
#line 119
  packet_put_char((tio.c_oflag & 1U) != 0U);
#line 121
  packet_put_char(71);
#line 121
  packet_put_char((tio.c_oflag & 2U) != 0U);
#line 123
  packet_put_char(72);
#line 123
  packet_put_char((tio.c_oflag & 4U) != 0U);
#line 125
  packet_put_char(73);
#line 125
  packet_put_char((tio.c_oflag & 8U) != 0U);
#line 128
  packet_put_char(74);
#line 128
  packet_put_char((tio.c_oflag & 16U) != 0U);
#line 131
  packet_put_char(75);
#line 131
  packet_put_char((tio.c_oflag & 32U) != 0U);
#line 134
  packet_put_char(90);
#line 134
  packet_put_char((tio.c_cflag & 32U) != 0U);
#line 135
  packet_put_char(91);
#line 135
  packet_put_char((tio.c_cflag & 48U) != 0U);
#line 136
  packet_put_char(92);
#line 136
  packet_put_char((tio.c_cflag & 256U) != 0U);
#line 137
  packet_put_char(93);
#line 137
  packet_put_char((tio.c_cflag & 512U) != 0U);
#line 248 "ttymodes.c"
  packet_put_char(0);
#line 249
  return;
}
}
#line 254 "ttymodes.c"
void tty_parse_modes(int fd , int *n_bytes_ptr ) 
{ struct termios tio ;
  int opcode ;
  int baud ;
  int n_bytes ;
  int failure ;
  int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  speed_t tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  speed_t tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;
  unsigned int tmp___22 ;
  unsigned int tmp___23 ;
  unsigned int tmp___24 ;
  unsigned int tmp___25 ;
  unsigned int tmp___26 ;
  unsigned int tmp___27 ;
  unsigned int tmp___28 ;
  unsigned int tmp___29 ;
  unsigned int tmp___30 ;
  unsigned int tmp___31 ;
  unsigned int tmp___32 ;
  unsigned int tmp___33 ;
  unsigned int tmp___34 ;
  unsigned int tmp___35 ;
  unsigned int tmp___36 ;
  unsigned int tmp___37 ;
  unsigned int tmp___38 ;
  unsigned int tmp___39 ;
  unsigned int tmp___40 ;
  unsigned int tmp___41 ;
  unsigned int tmp___42 ;
  unsigned int tmp___43 ;
  unsigned int tmp___44 ;
  unsigned int tmp___45 ;
  unsigned int tmp___46 ;
  unsigned int tmp___47 ;
  unsigned int tmp___48 ;
  unsigned int tmp___49 ;
  unsigned int tmp___50 ;
  unsigned int tmp___51 ;
  unsigned int tmp___52 ;
  unsigned int tmp___53 ;
  unsigned int tmp___54 ;
  unsigned int tmp___55 ;
  int _p ;
  int _e ;
  int *tmp___56 ;
  char *tmp___57 ;
  int tmp___58 ;

  {
#line 258
  n_bytes = 0;
#line 259
  failure = 0;
#line 264
  tmp = tcgetattr(fd, & tio);
#line 264
  if (tmp < 0) {
#line 265
    failure = -1;
  }
#line 267
  while (1) {
#line 269
    n_bytes ++;
#line 270
    tmp___0 = packet_get_char();
#line 270
    opcode = (int )tmp___0;
#line 271
    switch (opcode) {
    case 0: 
    goto set;
    case 192: 
#line 277
    n_bytes += 4;
#line 278
    tmp___1 = packet_get_int();
#line 278
    baud = (int )tmp___1;
#line 279
    if (failure != -1) {
#line 279
      tmp___2 = baud_to_speed(baud);
#line 279
      tmp___3 = cfsetispeed(& tio, tmp___2);
#line 279
      if (tmp___3 < 0) {
#line 280
        error("cfsetispeed failed for %d", baud);
      }
    }
#line 281
    break;
    case 193: 
#line 284
    n_bytes += 4;
#line 285
    tmp___4 = packet_get_int();
#line 285
    baud = (int )tmp___4;
#line 286
    if (failure != -1) {
#line 286
      tmp___5 = baud_to_speed(baud);
#line 286
      tmp___6 = cfsetospeed(& tio, tmp___5);
#line 286
      if (tmp___6 < 0) {
#line 287
        error("cfsetospeed failed for %d", baud);
      }
    }
#line 288
    break;
    case 1: 
#line 34 "ttymodes.h"
    n_bytes ++;
#line 34
    tmp___7 = packet_get_char();
#line 34
    tio.c_cc[0] = (unsigned char )tmp___7;
#line 34
    break;
    case 2: 
#line 35
    n_bytes ++;
#line 35
    tmp___8 = packet_get_char();
#line 35
    tio.c_cc[1] = (unsigned char )tmp___8;
#line 35
    break;
    case 3: 
#line 36
    n_bytes ++;
#line 36
    tmp___9 = packet_get_char();
#line 36
    tio.c_cc[2] = (unsigned char )tmp___9;
#line 36
    break;
    case 4: 
#line 38
    n_bytes ++;
#line 38
    tmp___10 = packet_get_char();
#line 38
    tio.c_cc[3] = (unsigned char )tmp___10;
#line 38
    break;
    case 5: 
#line 40
    n_bytes ++;
#line 40
    tmp___11 = packet_get_char();
#line 40
    tio.c_cc[4] = (unsigned char )tmp___11;
#line 40
    break;
    case 6: 
#line 42
    n_bytes ++;
#line 42
    tmp___12 = packet_get_char();
#line 42
    tio.c_cc[11] = (unsigned char )tmp___12;
#line 42
    break;
    case 7: 
#line 45
    n_bytes ++;
#line 45
    tmp___13 = packet_get_char();
#line 45
    tio.c_cc[16] = (unsigned char )tmp___13;
#line 45
    break;
    case 8: 
#line 47
    n_bytes ++;
#line 47
    tmp___14 = packet_get_char();
#line 47
    tio.c_cc[8] = (unsigned char )tmp___14;
#line 47
    break;
    case 9: 
#line 48
    n_bytes ++;
#line 48
    tmp___15 = packet_get_char();
#line 48
    tio.c_cc[9] = (unsigned char )tmp___15;
#line 48
    break;
    case 10: 
#line 50
    n_bytes ++;
#line 50
    tmp___16 = packet_get_char();
#line 50
    tio.c_cc[10] = (unsigned char )tmp___16;
#line 50
    break;
    case 12: 
#line 56
    n_bytes ++;
#line 56
    tmp___17 = packet_get_char();
#line 56
    tio.c_cc[12] = (unsigned char )tmp___17;
#line 56
    break;
    case 13: 
#line 59
    n_bytes ++;
#line 59
    tmp___18 = packet_get_char();
#line 59
    tio.c_cc[14] = (unsigned char )tmp___18;
#line 59
    break;
    case 14: 
#line 62
    n_bytes ++;
#line 62
    tmp___19 = packet_get_char();
#line 62
    tio.c_cc[15] = (unsigned char )tmp___19;
#line 62
    break;
    case 18: 
#line 74
    n_bytes ++;
#line 74
    tmp___20 = packet_get_char();
#line 74
    tio.c_cc[13] = (unsigned char )tmp___20;
#line 74
    break;
    case 30: 
#line 78
    n_bytes ++;
#line 78
    tmp___21 = packet_get_char();
#line 78
    if (tmp___21) {
#line 78
      tio.c_iflag |= 4U;
    } else {
#line 78
      tio.c_iflag &= 4294967291U;
    }
#line 78
    break;
    case 31: 
#line 79
    n_bytes ++;
#line 79
    tmp___22 = packet_get_char();
#line 79
    if (tmp___22) {
#line 79
      tio.c_iflag |= 8U;
    } else {
#line 79
      tio.c_iflag &= 4294967287U;
    }
#line 79
    break;
    case 32: 
#line 80
    n_bytes ++;
#line 80
    tmp___23 = packet_get_char();
#line 80
    if (tmp___23) {
#line 80
      tio.c_iflag |= 16U;
    } else {
#line 80
      tio.c_iflag &= 4294967279U;
    }
#line 80
    break;
    case 33: 
#line 81
    n_bytes ++;
#line 81
    tmp___24 = packet_get_char();
#line 81
    if (tmp___24) {
#line 81
      tio.c_iflag |= 32U;
    } else {
#line 81
      tio.c_iflag &= 4294967263U;
    }
#line 81
    break;
    case 34: 
#line 82
    n_bytes ++;
#line 82
    tmp___25 = packet_get_char();
#line 82
    if (tmp___25) {
#line 82
      tio.c_iflag |= 64U;
    } else {
#line 82
      tio.c_iflag &= 4294967231U;
    }
#line 82
    break;
    case 35: 
#line 83
    n_bytes ++;
#line 83
    tmp___26 = packet_get_char();
#line 83
    if (tmp___26) {
#line 83
      tio.c_iflag |= 128U;
    } else {
#line 83
      tio.c_iflag &= 4294967167U;
    }
#line 83
    break;
    case 36: 
#line 84
    n_bytes ++;
#line 84
    tmp___27 = packet_get_char();
#line 84
    if (tmp___27) {
#line 84
      tio.c_iflag |= 256U;
    } else {
#line 84
      tio.c_iflag &= 4294967039U;
    }
#line 84
    break;
    case 37: 
#line 86
    n_bytes ++;
#line 86
    tmp___28 = packet_get_char();
#line 86
    if (tmp___28) {
#line 86
      tio.c_iflag |= 512U;
    } else {
#line 86
      tio.c_iflag &= 4294966783U;
    }
#line 86
    break;
    case 38: 
#line 88
    n_bytes ++;
#line 88
    tmp___29 = packet_get_char();
#line 88
    if (tmp___29) {
#line 88
      tio.c_iflag |= 1024U;
    } else {
#line 88
      tio.c_iflag &= 4294966271U;
    }
#line 88
    break;
    case 39: 
#line 89
    n_bytes ++;
#line 89
    tmp___30 = packet_get_char();
#line 89
    if (tmp___30) {
#line 89
      tio.c_iflag |= 2048U;
    } else {
#line 89
      tio.c_iflag &= 4294965247U;
    }
#line 89
    break;
    case 40: 
#line 90
    n_bytes ++;
#line 90
    tmp___31 = packet_get_char();
#line 90
    if (tmp___31) {
#line 90
      tio.c_iflag |= 4096U;
    } else {
#line 90
      tio.c_iflag &= 4294963199U;
    }
#line 90
    break;
    case 41: 
#line 92
    n_bytes ++;
#line 92
    tmp___32 = packet_get_char();
#line 92
    if (tmp___32) {
#line 92
      tio.c_iflag |= 8192U;
    } else {
#line 92
      tio.c_iflag &= 4294959103U;
    }
#line 92
    break;
    case 50: 
#line 95
    n_bytes ++;
#line 95
    tmp___33 = packet_get_char();
#line 95
    if (tmp___33) {
#line 95
      tio.c_lflag |= 1U;
    } else {
#line 95
      tio.c_lflag &= 4294967294U;
    }
#line 95
    break;
    case 51: 
#line 96
    n_bytes ++;
#line 96
    tmp___34 = packet_get_char();
#line 96
    if (tmp___34) {
#line 96
      tio.c_lflag |= 2U;
    } else {
#line 96
      tio.c_lflag &= 4294967293U;
    }
#line 96
    break;
    case 52: 
#line 98
    n_bytes ++;
#line 98
    tmp___35 = packet_get_char();
#line 98
    if (tmp___35) {
#line 98
      tio.c_lflag |= 4U;
    } else {
#line 98
      tio.c_lflag &= 4294967291U;
    }
#line 98
    break;
    case 53: 
#line 100
    n_bytes ++;
#line 100
    tmp___36 = packet_get_char();
#line 100
    if (tmp___36) {
#line 100
      tio.c_lflag |= 8U;
    } else {
#line 100
      tio.c_lflag &= 4294967287U;
    }
#line 100
    break;
    case 54: 
#line 101
    n_bytes ++;
#line 101
    tmp___37 = packet_get_char();
#line 101
    if (tmp___37) {
#line 101
      tio.c_lflag |= 16U;
    } else {
#line 101
      tio.c_lflag &= 4294967279U;
    }
#line 101
    break;
    case 55: 
#line 102
    n_bytes ++;
#line 102
    tmp___38 = packet_get_char();
#line 102
    if (tmp___38) {
#line 102
      tio.c_lflag |= 32U;
    } else {
#line 102
      tio.c_lflag &= 4294967263U;
    }
#line 102
    break;
    case 56: 
#line 103
    n_bytes ++;
#line 103
    tmp___39 = packet_get_char();
#line 103
    if (tmp___39) {
#line 103
      tio.c_lflag |= 64U;
    } else {
#line 103
      tio.c_lflag &= 4294967231U;
    }
#line 103
    break;
    case 57: 
#line 104
    n_bytes ++;
#line 104
    tmp___40 = packet_get_char();
#line 104
    if (tmp___40) {
#line 104
      tio.c_lflag |= 128U;
    } else {
#line 104
      tio.c_lflag &= 4294967167U;
    }
#line 104
    break;
    case 58: 
#line 105
    n_bytes ++;
#line 105
    tmp___41 = packet_get_char();
#line 105
    if (tmp___41) {
#line 105
      tio.c_lflag |= 256U;
    } else {
#line 105
      tio.c_lflag &= 4294967039U;
    }
#line 105
    break;
    case 59: 
#line 107
    n_bytes ++;
#line 107
    tmp___42 = packet_get_char();
#line 107
    if (tmp___42) {
#line 107
      tio.c_lflag |= 32768U;
    } else {
#line 107
      tio.c_lflag &= 4294934527U;
    }
#line 107
    break;
    case 60: 
#line 110
    n_bytes ++;
#line 110
    tmp___43 = packet_get_char();
#line 110
    if (tmp___43) {
#line 110
      tio.c_lflag |= 512U;
    } else {
#line 110
      tio.c_lflag &= 4294966783U;
    }
#line 110
    break;
    case 61: 
#line 113
    n_bytes ++;
#line 113
    tmp___44 = packet_get_char();
#line 113
    if (tmp___44) {
#line 113
      tio.c_lflag |= 2048U;
    } else {
#line 113
      tio.c_lflag &= 4294965247U;
    }
#line 113
    break;
    case 62: 
#line 116
    n_bytes ++;
#line 116
    tmp___45 = packet_get_char();
#line 116
    if (tmp___45) {
#line 116
      tio.c_lflag |= 16384U;
    } else {
#line 116
      tio.c_lflag &= 4294950911U;
    }
#line 116
    break;
    case 70: 
#line 119
    n_bytes ++;
#line 119
    tmp___46 = packet_get_char();
#line 119
    if (tmp___46) {
#line 119
      tio.c_oflag |= 1U;
    } else {
#line 119
      tio.c_oflag &= 4294967294U;
    }
#line 119
    break;
    case 71: 
#line 121
    n_bytes ++;
#line 121
    tmp___47 = packet_get_char();
#line 121
    if (tmp___47) {
#line 121
      tio.c_oflag |= 2U;
    } else {
#line 121
      tio.c_oflag &= 4294967293U;
    }
#line 121
    break;
    case 72: 
#line 123
    n_bytes ++;
#line 123
    tmp___48 = packet_get_char();
#line 123
    if (tmp___48) {
#line 123
      tio.c_oflag |= 4U;
    } else {
#line 123
      tio.c_oflag &= 4294967291U;
    }
#line 123
    break;
    case 73: 
#line 125
    n_bytes ++;
#line 125
    tmp___49 = packet_get_char();
#line 125
    if (tmp___49) {
#line 125
      tio.c_oflag |= 8U;
    } else {
#line 125
      tio.c_oflag &= 4294967287U;
    }
#line 125
    break;
    case 74: 
#line 128
    n_bytes ++;
#line 128
    tmp___50 = packet_get_char();
#line 128
    if (tmp___50) {
#line 128
      tio.c_oflag |= 16U;
    } else {
#line 128
      tio.c_oflag &= 4294967279U;
    }
#line 128
    break;
    case 75: 
#line 131
    n_bytes ++;
#line 131
    tmp___51 = packet_get_char();
#line 131
    if (tmp___51) {
#line 131
      tio.c_oflag |= 32U;
    } else {
#line 131
      tio.c_oflag &= 4294967263U;
    }
#line 131
    break;
    case 90: 
#line 134
    n_bytes ++;
#line 134
    tmp___52 = packet_get_char();
#line 134
    if (tmp___52) {
#line 134
      tio.c_cflag |= 32U;
    } else {
#line 134
      tio.c_cflag &= 4294967263U;
    }
#line 134
    break;
    case 91: 
#line 135
    n_bytes ++;
#line 135
    tmp___53 = packet_get_char();
#line 135
    if (tmp___53) {
#line 135
      tio.c_cflag |= 48U;
    } else {
#line 135
      tio.c_cflag &= 4294967247U;
    }
#line 135
    break;
    case 92: 
#line 136
    n_bytes ++;
#line 136
    tmp___54 = packet_get_char();
#line 136
    if (tmp___54) {
#line 136
      tio.c_cflag |= 256U;
    } else {
#line 136
      tio.c_cflag &= 4294967039U;
    }
#line 136
    break;
    case 93: 
#line 137
    n_bytes ++;
#line 137
    tmp___55 = packet_get_char();
#line 137
    if (tmp___55) {
#line 137
      tio.c_cflag |= 512U;
    } else {
#line 137
      tio.c_cflag &= 4294966783U;
    }
#line 137
    break;
    default: 
#line 316 "ttymodes.c"
    debug("Ignoring unsupported tty mode opcode %d (0x%x)", opcode, opcode);
#line 319
    if (opcode >= 0) {
#line 319
      if (opcode < 128) {
#line 321
        n_bytes ++;
#line 322
        packet_get_char();
#line 323
        break;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 328
      if (opcode >= 128) {
#line 328
        if (opcode < 160) {
#line 330
          n_bytes += 4;
#line 331
          packet_get_int();
#line 332
          break;
        }
      }
    }
#line 339
    log("parse_tty_modes: unknown opcode %d", opcode);
#line 340
    while (1) {
#line 340
      _p = 0;
#line 340
      _e = 1;
#line 340
      if (_p != _e) {
#line 340
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "ttymodes.c", 340);
#line 340
        packet_disconnect("Packet integrity error. (%d)", 10);
      }
#line 340
      break;
    }
    goto set;
    }
  }
  set: 
#line 346
  if (*n_bytes_ptr != n_bytes) {
#line 348
    *n_bytes_ptr = n_bytes;
#line 349
    return;
  }
#line 352
  if (failure == -1) {
#line 353
    return;
  }
#line 356
  tmp___58 = tcsetattr(fd, 0, (struct termios  const  *)(& tio));
#line 356
  if (tmp___58 < 0) {
#line 357
    tmp___56 = __errno_location();
#line 357
    tmp___57 = strerror(*tmp___56);
#line 357
    log("Setting tty modes failed: %.100s", tmp___57);
  }
#line 358
  return;
}
}
#line 1 "uidswap.o"
#line 645 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 667
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 677
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 28 "uidswap.h"
void permanently_set_uid(uid_t uid ) ;
#line 38 "uidswap.c"
static uid_t saved_euid  =    (uid_t )0;
#line 43 "uidswap.c"
void temporarily_use_uid(uid_t uid ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 48
  saved_euid = geteuid();
#line 51
  tmp___1 = seteuid(uid);
#line 51
  if (tmp___1 == -1) {
#line 52
    tmp = __errno_location();
#line 52
    tmp___0 = strerror(*tmp);
#line 52
    debug("seteuid %d: %.100s", (int )uid, tmp___0);
  }
#line 66
  return;
}
}
#line 70 "uidswap.c"
void restore_uid(void) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 75
  tmp___1 = seteuid(saved_euid);
#line 75
  if (tmp___1 < 0) {
#line 76
    tmp = __errno_location();
#line 76
    tmp___0 = strerror(*tmp);
#line 76
    debug("seteuid %d: %.100s", (int )saved_euid, tmp___0);
  }
#line 86
  return;
}
}
#line 91 "uidswap.c"
void permanently_set_uid(uid_t uid ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 93
  tmp___1 = setuid(uid);
#line 93
  if (tmp___1 < 0) {
#line 94
    tmp = __errno_location();
#line 94
    tmp___0 = strerror(*tmp);
#line 94
    debug("setuid %d: %.100s", (int )uid, tmp___0);
  }
#line 95
  return;
}
}
#line 1 "xmalloc.o"
#line 589 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 600
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__warn_unused_result__,
__malloc__)) ;
#line 22 "xmalloc.c"
void *xmalloc(size_t size ) 
{ void *ptr ;
  void *tmp ;

  {
#line 24
  tmp = malloc(size);
#line 24
  ptr = tmp;
#line 25
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 26
    fatal("xmalloc: out of memory (allocating %d bytes)", (int )size);
  }
#line 27
  return (ptr);
}
}
#line 30 "xmalloc.c"
void *xrealloc(void *ptr , size_t new_size ) 
{ void *new_ptr ;

  {
#line 34
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 35
    fatal("xrealloc: NULL pointer given as argument");
  }
#line 36
  new_ptr = realloc(ptr, new_size);
#line 37
  if ((unsigned int )new_ptr == (unsigned int )((void *)0)) {
#line 38
    fatal("xrealloc: out of memory (new_size %d bytes)", (int )new_size);
  }
#line 39
  return (new_ptr);
}
}
#line 42 "xmalloc.c"
void xfree(void *ptr ) 
{ 

  {
#line 44
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 45
    fatal("xfree: NULL pointer given as argument");
  }
#line 46
  free(ptr);
#line 47
  return;
}
}
#line 49 "xmalloc.c"
char *xstrdup(char const   *str ) 
{ int len ;
  size_t tmp ;
  char *cp ;
  void *tmp___0 ;

  {
#line 51
  tmp = strlen(str);
#line 51
  len = (int )(tmp + 1U);
#line 53
  tmp___0 = xmalloc((unsigned int )len);
#line 53
  cp = (char *)tmp___0;
#line 54
  strlcpy(cp, str, len);
#line 55
  return (cp);
}
}
#line 1 "sshd.o"
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 280
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 116 "/usr/include/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 117 "/usr/include/netdb.h"
extern void endhostent(void) ;
#line 590 "/usr/include/stdio.h"
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 747
extern void perror(char const   *__s ) ;
#line 774
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 780
extern int pclose(FILE *__stream ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 628
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 709
extern int mkstemp(char *__template )  __attribute__((__nonnull__(1))) ;
#line 79 "/usr/include/pwd.h"
extern void endpwent(void) ;
#line 69 "/usr/include/grp.h"
extern void endgrent(void) ;
#line 103
extern struct group *getgrgid(__gid_t __gid ) ;
#line 109
extern struct group *getgrnam(char const   *__name ) ;
#line 199
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 384 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 393
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 433
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group )  __attribute__((__nonnull__(1))) ;
#line 438
extern  __attribute__((__nothrow__)) int fchown(int __fd , __uid_t __owner , __gid_t __group ) ;
#line 457
extern  __attribute__((__nothrow__)) int chdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 490
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 493
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 504
extern  __attribute__((__nothrow__)) int execve(char const   *__path , char * const  *__argv ,
                                                char * const  *__envp )  __attribute__((__nonnull__(1))) ;
#line 516
extern  __attribute__((__nothrow__)) int execv(char const   *__path , char * const  *__argv )  __attribute__((__nonnull__(1))) ;
#line 526
extern  __attribute__((__nothrow__)) int execl(char const   *__path , char const   *__arg 
                                               , ...)  __attribute__((__nonnull__(1))) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 684
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 723
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 792
extern  __attribute__((__nothrow__)) int unlink(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 828
extern  __attribute__((__nothrow__)) int setlogin(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 73
extern int optind ;
#line 152
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 903 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
#line 257 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 478 "/usr/include/openssl/bn.h"
extern int BN_mask_bits(BIGNUM *a , int n ) ;
#line 215 "/usr/include/openssl/rsa.h"
extern RSA *RSA_new(void) ;
#line 216 "ssh.h"
unsigned long get_last_login_time(uid_t uid , char const   *logname , char *buf ,
                                  unsigned int bufsize ) ;
#line 221
void record_login(int pid , char const   *ttyname___0 , char const   *user , uid_t uid ,
                  char const   *host , struct sockaddr_in *addr ) ;
#line 226
void record_logout(int pid , char const   *ttyname___0 ) ;
#line 259
int auth_rhosts(struct passwd *pw , char const   *client_user , int ignore_rhosts ,
                int strict_modes ) ;
#line 264
int auth_rhosts_rsa(struct passwd *pw , char const   *client_user , unsigned int client_host_key_bits ,
                    BIGNUM *client_host_key_e , BIGNUM *client_host_key_n , int ignore_rhosts ,
                    int strict_modes ) ;
#line 271
int auth_password(struct passwd *pw , char const   *password ) ;
#line 276
int auth_rsa(struct passwd *pw , BIGNUM *client_n , int strict_modes ) ;
#line 375
void log_init(char *av0___0 , int on_stderr , int debug___0 , int quiet , SyslogFacility facility ) ;
#line 405
void fatal_remove_cleanup(void (*proc)(void *context ) , void *context ) ;
#line 521
char *xauthfile ;
#line 551
void server_loop(int pid , int fdin_arg , int fdout_arg , int fderr_arg ) ;
#line 26 "pty.h"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf ) ;
#line 30
void pty_release(char const   *ttyname___0 ) ;
#line 34
void pty_make_controlling_tty(int *ttyfd , char const   *ttyname___0 ) ;
#line 37
void pty_change_window_size(int ptyfd , int row , int col , int xpixel , int ypixel ) ;
#line 77 "servconf.h"
void initialize_server_options(ServerOptions *options___0 ) ;
#line 81
void read_server_config(ServerOptions *options___0 , char const   *filename ) ;
#line 84
void fill_default_server_options(ServerOptions *options___0 ) ;
#line 59 "sshd.c"
char *xauthfile  =    (char *)((void *)0);
#line 62 "sshd.c"
ServerOptions options  ;
#line 65 "sshd.c"
char *config_file_name  =    (char *)"/usr/local/etc/sshd_config";
#line 71 "sshd.c"
int debug_flag  =    0;
#line 74 "sshd.c"
int inetd_flag  =    0;
#line 77 "sshd.c"
char *av0  ;
#line 80 "sshd.c"
char **saved_argv  ;
#line 84 "sshd.c"
int listen_sock  ;
#line 88 "sshd.c"
int no_port_forwarding_flag  =    0;
#line 89 "sshd.c"
int no_agent_forwarding_flag  =    0;
#line 90 "sshd.c"
int no_x11_forwarding_flag  =    0;
#line 91 "sshd.c"
int no_pty_flag  =    0;
#line 92 "sshd.c"
char *forced_command  =    (char *)((void *)0);
#line 93 "sshd.c"
struct envstring *custom_environment  =    (struct envstring *)((void *)0);
#line 97 "sshd.c"
unsigned char session_id[16]  ;
#line 105 "sshd.c"
struct __anonstruct_sensitive_data_77 sensitive_data  ;
#line 116 "sshd.c"
int key_used  =    0;
#line 119 "sshd.c"
int received_sighup  =    0;
#line 123 "sshd.c"
RSA *public_key  ;
#line 126
void do_connection(int privileged_port ) ;
#line 127
void do_authentication(char *user , int privileged_port ) ;
#line 128
void do_authenticated(struct passwd *pw ) ;
#line 129
void do_exec_pty(char const   *command , int ptyfd , int ttyfd , char const   *ttyname___0 ,
                 struct passwd *pw , char const   *term , char const   *display ,
                 char const   *auth_proto , char const   *auth_data ) ;
#line 133
void do_exec_no_pty(char const   *command , struct passwd *pw , char const   *display ,
                    char const   *auth_proto , char const   *auth_data ) ;
#line 136
void do_child(char const   *command , struct passwd *pw , char const   *term , char const   *display ,
              char const   *auth_proto , char const   *auth_data , char const   *ttyname___0 ) ;
#line 212 "sshd.c"
void sighup_handler(int sig ) 
{ 

  {
#line 214
  received_sighup = 1;
#line 215
  signal(1, & sighup_handler);
#line 216
  return;
}
}
#line 221 "sshd.c"
void sighup_restart(void) 
{ int *tmp ;
  char *tmp___0 ;

  {
#line 223
  log("Received SIGHUP; restarting.");
#line 224
  close(listen_sock);
#line 225
  execv((char const   *)*(saved_argv + 0), (char * const  *)saved_argv);
#line 226
  tmp = __errno_location();
#line 226
  tmp___0 = strerror(*tmp);
#line 226
  log("RESTART FAILED: av0=\'%s\', error: %s.", av0, tmp___0);
#line 227
  exit(1);
}
}
#line 234 "sshd.c"
void sigterm_handler(int sig ) 
{ 

  {
#line 236
  log("Received signal %d; terminating.", sig);
#line 237
  close(listen_sock);
#line 238
  exit(255);
}
}
#line 244 "sshd.c"
void main_sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  int status ;
  int *tmp___0 ;

  {
#line 246
  tmp = __errno_location();
#line 246
  save_errno = *tmp;
#line 248
  wait((union wait *)(& status));
#line 249
  signal(17, & main_sigchld_handler);
#line 250
  tmp___0 = __errno_location();
#line 250
  *tmp___0 = save_errno;
#line 251
  return;
}
}
#line 255 "sshd.c"
void grace_alarm_handler(int sig ) 
{ 

  {
#line 258
  packet_close();
#line 261
  fatal("Timeout before authentication.");
#line 262
  return;
}
}
#line 269 "sshd.c"
void key_regeneration_alarm(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 271
  tmp = __errno_location();
#line 271
  save_errno = *tmp;
#line 274
  if (key_used) {
#line 277
    log("Generating new %d bit RSA key.", options.server_key_bits);
#line 279
    if ((unsigned int )sensitive_data.private_key != (unsigned int )((void *)0)) {
#line 280
      RSA_free(sensitive_data.private_key);
    }
#line 281
    sensitive_data.private_key = RSA_new();
#line 283
    if ((unsigned int )public_key != (unsigned int )((void *)0)) {
#line 284
      RSA_free(public_key);
    }
#line 285
    public_key = RSA_new();
#line 287
    rsa_generate_key(sensitive_data.private_key, public_key, (unsigned int )options.server_key_bits);
#line 289
    arc4random_stir();
#line 290
    key_used = 0;
#line 291
    log("RSA key generation complete.");
  }
#line 295
  signal(14, & key_regeneration_alarm);
#line 296
  alarm((unsigned int )options.key_regeneration_time);
#line 297
  tmp___0 = __errno_location();
#line 297
  *tmp___0 = save_errno;
#line 298
  return;
}
}
#line 302 "sshd.c"
int main(int ac , char **av ) 
{ int opt ;
  int aux ;
  int sock_in ;
  int sock_out ;
  int newsock ;
  int i ;
  int pid ;
  int on ;
  int remote_major ;
  int remote_minor ;
  int silentrsa ;
  struct sockaddr_in sin ;
  char buf[100] ;
  char remote_version[100] ;
  char *comment ;
  FILE *f ;
  struct linger linger ;
  char *tmp ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int err ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int fd ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int s1 ;
  int s2 ;
  int *tmp___18 ;
  char *tmp___19 ;
  register unsigned short __v ;
  register unsigned short __x ;
  int *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  __pid_t tmp___23 ;
  int *tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  int *tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int *tmp___32 ;
  char *tmp___33 ;
  int tmp___34 ;
  char const   *tmp___35 ;
  size_t tmp___36 ;
  ssize_t tmp___37 ;
  size_t tmp___38 ;
  ssize_t tmp___39 ;
  char const   *s ;
  size_t tmp___40 ;
  int tmp___41 ;
  char const   *s___0 ;
  size_t tmp___42 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___48 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  char *tmp___54 ;

  {
#line 307
  on = 1;
#line 309
  silentrsa = 0;
#line 318
  saved_argv = av;
#line 319
  tmp___1 = __builtin_strchr(*(av + 0), '/');
#line 319
  if (tmp___1) {
#line 320
    tmp = strrchr((char const   *)*(av + 0), '/');
#line 320
    av0 = tmp + 1;
  } else {
#line 322
    av0 = *(av + 0);
  }
#line 325
  initialize_server_options(& options);
#line 328
  while (1) {
#line 328
    opt = getopt(ac, (char * const  *)av, "f:p:b:k:h:g:diqQ");
#line 328
    if (! (opt != -1)) {
#line 328
      break;
    }
#line 330
    switch (opt) {
    case 102: 
#line 333
    config_file_name = optarg;
#line 334
    break;
    case 100: 
#line 336
    debug_flag = 1;
#line 337
    break;
    case 105: 
#line 339
    inetd_flag = 1;
#line 340
    break;
    case 81: 
#line 342
    silentrsa = 1;
#line 343
    break;
    case 113: 
#line 345
    options.quiet_mode = 1;
#line 346
    break;
    case 98: 
#line 348
    options.server_key_bits = atoi((char const   *)optarg);
#line 349
    break;
    case 112: 
#line 351
    options.port = atoi((char const   *)optarg);
#line 352
    break;
    case 103: 
#line 354
    options.login_grace_time = atoi((char const   *)optarg);
#line 355
    break;
    case 107: 
#line 357
    options.key_regeneration_time = atoi((char const   *)optarg);
#line 358
    break;
    case 104: 
#line 360
    options.host_key_file = optarg;
#line 361
    break;
    case 63: 
    default: 
#line 364
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"sshd version %s\n",
            "OpenSSH-1.2");
#line 365
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: %s [options]\n",
            av0);
#line 366
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Options:\n");
#line 367
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -f file    Configuration file (default %s/sshd_config)\n",
            "/usr/local/etc");
#line 368
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -d         Debugging mode\n");
#line 369
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -i         Started from inetd\n");
#line 370
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -q         Quiet (no logging)\n");
#line 371
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -p port    Listen on the specified port (default: 22)\n");
#line 372
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -k seconds Regenerate server key every this many seconds (default: 3600)\n");
#line 373
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -g seconds Grace period for authentication (default: 300)\n");
#line 374
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -b bits    Size of server RSA key (default: 768 bits)\n");
#line 375
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -h file    File from which to read host key (default: %s)\n",
            "/usr/local/etc/ssh_host_key");
#line 377
    exit(1);
    }
  }
#line 382
  tmp___2 = rsa_alive();
#line 382
  if (tmp___2 == 0) {
#line 383
    if (silentrsa == 0) {
#line 384
      printf((char const   * __restrict  )"sshd: no RSA support in libssl and libcrypto -- exiting.  See ssl(8)\n");
    }
#line 385
    log("no RSA support in libssl and libcrypto -- exiting.  See ssl(8)");
#line 386
    exit(1);
  }
#line 390
  read_server_config(& options, (char const   *)config_file_name);
#line 393
  fill_default_server_options(& options);
#line 396
  if (options.server_key_bits < 512) {
#line 399
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 400
    exit(1);
  } else {
#line 396
    if (options.server_key_bits > 32768) {
#line 399
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 400
      exit(1);
    }
  }
#line 402
  if (options.port < 1) {
#line 404
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad port number.\n");
#line 405
    exit(1);
  } else {
#line 402
    if (options.port > 65535) {
#line 404
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad port number.\n");
#line 405
      exit(1);
    }
  }
#line 409
  if (optind < ac) {
#line 411
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Extra argument %s.\n",
            *(av + optind));
#line 412
    exit(1);
  }
#line 416
  if (debug_flag) {
#line 416
    tmp___3 = 1;
  } else {
#line 416
    if (options.fascist_logging) {
#line 416
      tmp___3 = 1;
    } else {
#line 416
      tmp___3 = 0;
    }
  }
#line 416
  if (debug_flag) {
#line 416
    if (! inetd_flag) {
#line 416
      tmp___4 = 1;
    } else {
#line 416
      tmp___4 = 0;
    }
  } else {
#line 416
    tmp___4 = 0;
  }
#line 416
  log_init(av0, tmp___4, tmp___3, options.quiet_mode, options.log_facility);
#line 420
  debug("sshd version %.100s", "OpenSSH-1.2");
#line 422
  sensitive_data.host_key = RSA_new();
#line 424
  tmp___9 = load_private_key((char const   *)options.host_key_file, "", sensitive_data.host_key,
                             & comment);
#line 424
  if (! tmp___9) {
#line 427
    if (debug_flag) {
#line 428
      tmp___5 = __errno_location();
#line 428
      tmp___6 = strerror(*tmp___5);
#line 428
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not load host key: %s: %s\n",
              options.host_key_file, tmp___6);
    } else {
#line 432
      tmp___7 = __errno_location();
#line 432
      err = *tmp___7;
#line 433
      log_init(av0, ! inetd_flag, 1, 0, options.log_facility);
#line 434
      tmp___8 = strerror(err);
#line 434
      error("Could not load host key: %.200s: %.100s", options.host_key_file, tmp___8);
    }
#line 437
    exit(1);
  }
#line 439
  xfree((void *)comment);
#line 443
  if (! debug_flag) {
#line 443
    if (! inetd_flag) {
#line 448
      tmp___12 = daemon(0, 0);
#line 448
      if (tmp___12 < 0) {
#line 449
        tmp___10 = __errno_location();
#line 449
        tmp___11 = strerror(*tmp___10);
#line 449
        fatal("daemon() failed: %.200s", tmp___11);
      }
#line 453
      fd = open("/dev/tty", 258);
#line 454
      if (fd >= 0) {
#line 456
        ioctl(fd, 21538UL, (void *)0);
#line 457
        close(fd);
      }
    }
  }
#line 463
  if (debug_flag) {
#line 463
    tmp___13 = 1;
  } else {
#line 463
    if (options.fascist_logging) {
#line 463
      tmp___13 = 1;
    } else {
#line 463
      tmp___13 = 0;
    }
  }
#line 463
  if (debug_flag) {
#line 463
    if (! inetd_flag) {
#line 463
      tmp___14 = 1;
    } else {
#line 463
      tmp___14 = 0;
    }
  } else {
#line 463
    tmp___14 = 0;
  }
#line 463
  log_init(av0, tmp___14, tmp___13, options.quiet_mode, options.log_facility);
#line 470
  tmp___16 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 470
  if (options.server_key_bits > tmp___16 - 128) {
#line 470
    tmp___17 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 470
    if (options.server_key_bits < tmp___17 + 128) {
#line 475
      tmp___15 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 475
      options.server_key_bits = tmp___15 + 128;
#line 477
      debug("Forcing server key to %d bits to make it differ from host key.", options.server_key_bits);
    }
  }
#line 482
  rsa_set_verbose(0);
#line 485
  arc4random_stir();
#line 489
  chdir("/");
#line 492
  cipher_attack_detected = & packet_disconnect;
#line 495
  if (inetd_flag) {
#line 498
    s1 = dup(0);
#line 499
    s2 = dup(s1);
#line 500
    sock_in = dup(0);
#line 501
    sock_out = dup(1);
#line 505
    debug("inetd sockets after dupping: %d, %d", sock_in, sock_out);
#line 507
    public_key = RSA_new();
#line 508
    sensitive_data.private_key = RSA_new();
#line 510
    log("Generating %d bit RSA key.", options.server_key_bits);
#line 511
    rsa_generate_key(sensitive_data.private_key, public_key, (unsigned int )options.server_key_bits);
#line 513
    arc4random_stir();
#line 514
    log("RSA key generation complete.");
  } else {
#line 519
    listen_sock = socket(2, 1, 0);
#line 520
    if (listen_sock < 0) {
#line 521
      tmp___18 = __errno_location();
#line 521
      tmp___19 = strerror(*tmp___18);
#line 521
      fatal("socket: %.100s", tmp___19);
    }
#line 526
    setsockopt(listen_sock, 1, 2, (void const   *)((void *)(& on)), sizeof(on));
#line 528
    linger.l_onoff = 1;
#line 529
    linger.l_linger = 5;
#line 530
    setsockopt(listen_sock, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 534
    memset((void *)(& sin), 0, sizeof(sin));
#line 535
    sin.sin_family = (unsigned short)2;
#line 536
    sin.sin_addr = options.listen_addr;
#line 537
    __x = (unsigned short )options.port;
#line 537
    __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 537
    sin.sin_port = __v;
#line 540
    tmp___22 = bind(listen_sock, (struct sockaddr  const  *)((struct sockaddr *)(& sin)),
                    sizeof(sin));
#line 540
    if (tmp___22 < 0) {
#line 542
      tmp___20 = __errno_location();
#line 542
      tmp___21 = strerror(*tmp___20);
#line 542
      error("bind: %.100s", tmp___21);
#line 543
      shutdown(listen_sock, 2);
#line 544
      close(listen_sock);
#line 545
      fatal("Bind to port %d failed.", options.port);
    }
#line 548
    if (! debug_flag) {
#line 554
      f = fopen((char const   * __restrict  )"/var/run/sshd.pid", (char const   * __restrict  )"w");
#line 555
      if (f) {
#line 557
        tmp___23 = getpid();
#line 557
        fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%u\n", (unsigned int )tmp___23);
#line 558
        fclose(f);
      }
    }
#line 563
    log("Server listening on port %d.", options.port);
#line 564
    tmp___26 = listen(listen_sock, 5);
#line 564
    if (tmp___26 < 0) {
#line 565
      tmp___24 = __errno_location();
#line 565
      tmp___25 = strerror(*tmp___24);
#line 565
      fatal("listen: %.100s", tmp___25);
    }
#line 567
    public_key = RSA_new();
#line 568
    sensitive_data.private_key = RSA_new();
#line 570
    log("Generating %d bit RSA key.", options.server_key_bits);
#line 571
    rsa_generate_key(sensitive_data.private_key, public_key, (unsigned int )options.server_key_bits);
#line 573
    arc4random_stir();
#line 574
    log("RSA key generation complete.");
#line 577
    signal(14, & key_regeneration_alarm);
#line 578
    alarm((unsigned int )options.key_regeneration_time);
#line 581
    signal(1, & sighup_handler);
#line 582
    signal(15, & sigterm_handler);
#line 583
    signal(3, & sigterm_handler);
#line 586
    signal(17, & main_sigchld_handler);
#line 590
    while (1) {
#line 592
      if (received_sighup) {
#line 593
        sighup_restart();
      }
#line 595
      aux = (int )sizeof(sin);
#line 596
      newsock = accept(listen_sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& sin)),
                       (socklen_t * __restrict  )(& aux));
#line 597
      if (received_sighup) {
#line 598
        sighup_restart();
      }
#line 599
      if (newsock < 0) {
#line 601
        tmp___27 = __errno_location();
#line 601
        if (*tmp___27 == 4) {
          goto __Cont;
        }
#line 603
        tmp___28 = __errno_location();
#line 603
        tmp___29 = strerror(*tmp___28);
#line 603
        error("accept: %.100s", tmp___29);
        goto __Cont;
      }
#line 609
      if (debug_flag) {
#line 613
        debug("Server will not fork when running in debugging mode.");
#line 614
        close(listen_sock);
#line 615
        sock_in = newsock;
#line 616
        sock_out = newsock;
#line 617
        pid = getpid();
#line 618
        break;
      } else {
#line 624
        pid = fork();
#line 624
        if (pid == 0) {
#line 630
          close(listen_sock);
#line 631
          sock_in = newsock;
#line 632
          sock_out = newsock;
#line 633
          if (options.fascist_logging) {
#line 633
            tmp___30 = 1;
          } else {
#line 633
            if (debug_flag) {
#line 633
              tmp___30 = 1;
            } else {
#line 633
              tmp___30 = 0;
            }
          }
#line 633
          if (debug_flag) {
#line 633
            if (! inetd_flag) {
#line 633
              tmp___31 = 1;
            } else {
#line 633
              tmp___31 = 0;
            }
          } else {
#line 633
            tmp___31 = 0;
          }
#line 633
          log_init(av0, tmp___31, tmp___30, options.quiet_mode, options.log_facility);
#line 636
          break;
        }
      }
#line 641
      if (pid < 0) {
#line 642
        tmp___32 = __errno_location();
#line 642
        tmp___33 = strerror(*tmp___32);
#line 642
        error("fork: %.100s", tmp___33);
      } else {
#line 644
        debug("Forked child %d.", pid);
      }
#line 647
      key_used = 1;
#line 649
      arc4random_stir();
#line 652
      close(newsock);
      __Cont: /* CIL Label */ ;
    }
  }
#line 661
  alarm(0U);
#line 662
  signal(14, (void (*)(int  ))0);
#line 663
  signal(1, (void (*)(int  ))0);
#line 664
  signal(15, (void (*)(int  ))0);
#line 665
  signal(3, (void (*)(int  ))0);
#line 666
  signal(17, (void (*)(int  ))0);
#line 672
  linger.l_onoff = 1;
#line 673
  linger.l_linger = 5;
#line 674
  setsockopt(sock_in, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 678
  packet_set_connection(sock_in, sock_out);
#line 698
  tmp___34 = get_remote_port();
#line 698
  tmp___35 = get_remote_ipaddr();
#line 698
  log("Connection from %.100s port %d", tmp___35, tmp___34);
#line 707
  signal(14, & grace_alarm_handler);
#line 708
  if (! debug_flag) {
#line 709
    alarm((unsigned int )options.login_grace_time);
  }
#line 712
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"SSH-%d.%d-%.100s\n",
           1, 5, "OpenSSH-1.2");
#line 714
  tmp___36 = strlen((char const   *)(buf));
#line 714
  tmp___37 = write(sock_out, (void const   *)(buf), tmp___36);
#line 714
  tmp___38 = strlen((char const   *)(buf));
#line 714
  if ((size_t )tmp___37 != tmp___38) {
#line 715
    fatal("Could not write ident string.");
  }
#line 718
  i = 0;
#line 718
  while ((unsigned int )i < sizeof(buf) - 1U) {
#line 720
    tmp___39 = read(sock_in, (void *)(& buf[i]), 1U);
#line 720
    if (tmp___39 != 1) {
#line 721
      fatal("Did not receive ident string.");
    }
#line 722
    if ((int )buf[i] == 13) {
#line 724
      buf[i] = (char )'\n';
#line 725
      buf[i + 1] = (char)0;
#line 726
      break;
    }
#line 728
    if ((int )buf[i] == 10) {
#line 731
      buf[i + 1] = (char)0;
#line 732
      break;
    }
#line 718
    i ++;
  }
#line 735
  buf[sizeof(buf) - 1U] = (char)0;
#line 739
  tmp___41 = sscanf((char const   * __restrict  )(buf), (char const   * __restrict  )"SSH-%d.%d-%[^\n]\n",
                    & remote_major, & remote_minor, remote_version);
#line 739
  if (tmp___41 != 3) {
#line 742
    s = "Protocol mismatch.\n";
#line 743
    tmp___40 = strlen(s);
#line 743
    write(sock_out, (void const   *)s, tmp___40);
#line 744
    close(sock_in);
#line 745
    close(sock_out);
#line 746
    fatal("Bad protocol version identification: %.100s", buf);
  }
#line 748
  debug("Client protocol version %d.%d; client software version %.100s", remote_major,
        remote_minor, remote_version);
#line 750
  if (remote_major != 1) {
#line 752
    s___0 = "Protocol major versions differ.\n";
#line 753
    tmp___42 = strlen(s___0);
#line 753
    write(sock_out, (void const   *)s___0, tmp___42);
#line 754
    close(sock_in);
#line 755
    close(sock_out);
#line 756
    fatal("Protocol major versions differ: %d vs. %d", 1, remote_major);
  }
#line 761
  if (remote_major == 1) {
#line 761
    if (remote_minor < 3) {
#line 762
      packet_disconnect("Your ssh version is too old and is no longer supported.  Please install a newer version.");
    }
  }
#line 764
  if (remote_major == 1) {
#line 764
    if (remote_minor == 3) {
#line 765
      enable_compat13();
#line 766
      if (0) {
#line 766
        __s1_len = strlen((char const   *)(remote_version));
#line 766
        __s2_len = strlen("OpenSSH-1.1");
#line 766
        if (! ((unsigned int )((void const   *)(remote_version + 1)) - (unsigned int )((void const   *)(remote_version)) == 1U)) {
          goto _L___0;
        } else {
#line 766
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 766
            if (! ((unsigned int )((void const   *)("OpenSSH-1.1" + 1)) - (unsigned int )((void const   *)"OpenSSH-1.1") == 1U)) {
#line 766
              tmp___52 = 1;
            } else {
#line 766
              if (__s2_len >= 4U) {
#line 766
                tmp___52 = 1;
              } else {
#line 766
                tmp___52 = 0;
              }
            }
          } else {
#line 766
            tmp___52 = 0;
          }
        }
#line 766
        if (tmp___52) {
#line 766
          tmp___48 = __builtin_strcmp((char const   *)(remote_version), "OpenSSH-1.1");
        } else {
#line 766
          tmp___51 = __builtin_strcmp((char const   *)(remote_version), "OpenSSH-1.1");
#line 766
          tmp___48 = tmp___51;
        }
      } else {
#line 766
        tmp___51 = __builtin_strcmp((char const   *)(remote_version), "OpenSSH-1.1");
#line 766
        tmp___48 = tmp___51;
      }
#line 766
      if (tmp___48 != 0) {
#line 767
        debug("Agent forwarding disabled, remote version is not compatible.");
#line 768
        no_agent_forwarding_flag = 1;
      }
    }
  }
#line 772
  packet_set_nonblocking();
#line 776
  tmp___53 = get_remote_port();
#line 776
  do_connection(tmp___53 < 1024);
#line 785
  if (xauthfile) {
#line 785
    unlink((char const   *)xauthfile);
  }
#line 788
  tmp___54 = inet_ntoa(sin.sin_addr);
#line 788
  log("Closing connection to %.100s", tmp___54);
#line 800
  packet_close();
#line 802
  exit(0);
}
}
#line 809 "sshd.c"
void do_connection(int privileged_port ) 
{ int i ;
  BIGNUM *session_key_int ;
  unsigned char session_key[32] ;
  unsigned char check_bytes[8] ;
  char *user ;
  unsigned int cipher_type___0 ;
  unsigned int auth_mask ;
  unsigned int protocol_flags ;
  int plen ;
  int slen ;
  u_int32_t rand___0 ;
  unsigned char tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  char const   *tmp___6 ;
  int _p ;
  int _e ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int ulen ;
  int _p___0 ;
  int _e___0 ;

  {
#line 818
  rand___0 = (u_int32_t )0;
#line 827
  i = 0;
#line 827
  while (i < 8) {
#line 828
    if (i % 4 == 0) {
#line 829
      tmp = arc4random();
#line 829
      rand___0 = (unsigned int )tmp;
    }
#line 830
    check_bytes[i] = (unsigned char )(rand___0 & 255U);
#line 831
    rand___0 >>= 8;
#line 827
    i ++;
  }
#line 836
  packet_start(2);
#line 837
  i = 0;
#line 837
  while (i < 8) {
#line 838
    packet_put_char((int )check_bytes[i]);
#line 837
    i ++;
  }
#line 841
  tmp___0 = BN_num_bits((BIGNUM const   *)public_key->n);
#line 841
  packet_put_int((unsigned int )tmp___0);
#line 842
  packet_put_bignum(public_key->e);
#line 843
  packet_put_bignum(public_key->n);
#line 846
  tmp___1 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 846
  packet_put_int((unsigned int )tmp___1);
#line 847
  packet_put_bignum((sensitive_data.host_key)->e);
#line 848
  packet_put_bignum((sensitive_data.host_key)->n);
#line 851
  packet_put_int(2U);
#line 854
  tmp___2 = cipher_mask();
#line 854
  packet_put_int(tmp___2);
#line 857
  auth_mask = 0U;
#line 858
  if (options.rhosts_authentication) {
#line 859
    auth_mask |= (unsigned int )(1 << 1);
  }
#line 860
  if (options.rhosts_rsa_authentication) {
#line 861
    auth_mask |= (unsigned int )(1 << 4);
  }
#line 862
  if (options.rsa_authentication) {
#line 863
    auth_mask |= (unsigned int )(1 << 2);
  }
#line 874
  if (options.password_authentication) {
#line 875
    auth_mask |= (unsigned int )(1 << 3);
  }
#line 876
  packet_put_int(auth_mask);
#line 879
  packet_send();
#line 880
  packet_write_wait();
#line 882
  tmp___3 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 882
  tmp___4 = BN_num_bits((BIGNUM const   *)public_key->n);
#line 882
  debug("Sent %d bit public key and %d bit host key.", tmp___4, tmp___3);
#line 886
  packet_read_expect(& plen, 3);
#line 889
  cipher_type___0 = packet_get_char();
#line 893
  i = 0;
#line 893
  while (i < 8) {
#line 894
    tmp___5 = packet_get_char();
#line 894
    if ((unsigned int )check_bytes[i] != tmp___5) {
#line 895
      packet_disconnect("IP Spoofing check bytes do not match.");
    }
#line 893
    i ++;
  }
#line 897
  tmp___6 = cipher_name((int )cipher_type___0);
#line 897
  debug("Encryption type: %.200s", tmp___6);
#line 900
  session_key_int = BN_new();
#line 901
  packet_get_bignum(session_key_int, & slen);
#line 904
  protocol_flags = packet_get_int();
#line 905
  packet_set_protocol_flags(protocol_flags);
#line 907
  while (1) {
#line 907
    _p = plen;
#line 907
    _e = (9 + slen) + 4;
#line 907
    if (_p != _e) {
#line 907
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "sshd.c", 907);
#line 907
      packet_disconnect("Packet integrity error. (%d)", 3);
    }
#line 907
    break;
  }
#line 911
  tmp___11 = BN_cmp((BIGNUM const   *)(sensitive_data.private_key)->n, (BIGNUM const   *)(sensitive_data.host_key)->n);
#line 911
  if (tmp___11 > 0) {
#line 914
    tmp___7 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 914
    tmp___8 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 914
    if (! (tmp___7 >= tmp___8 + 128)) {
#line 914
      __assert_fail("BN_num_bits(sensitive_data.private_key->n) >= BN_num_bits(sensitive_data.host_key->n) + 128",
                    "sshd.c", 915U, "do_connection");
    }
#line 916
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.private_key);
#line 918
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.host_key);
  } else {
#line 924
    tmp___9 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 924
    tmp___10 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 924
    if (! (tmp___9 >= tmp___10 + 128)) {
#line 924
      __assert_fail("BN_num_bits(sensitive_data.host_key->n) >= BN_num_bits(sensitive_data.private_key->n) + 128",
                    "sshd.c", 926U, "do_connection");
    }
#line 927
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.host_key);
#line 929
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.private_key);
  }
#line 934
  tmp___12 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 934
  tmp___13 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 934
  compute_session_id((unsigned char *)(session_id), (unsigned char *)(check_bytes),
                     (unsigned int )tmp___13, (sensitive_data.host_key)->n, (unsigned int )tmp___12,
                     (sensitive_data.private_key)->n);
#line 943
  BN_mask_bits(session_key_int, (int )(sizeof(session_key) * 8U));
#line 944
  tmp___14 = BN_num_bits((BIGNUM const   *)session_key_int);
#line 944
  if (! ((unsigned int )((tmp___14 + 7) / 8) == sizeof(session_key))) {
#line 944
    __assert_fail("((BN_num_bits(session_key_int)+7)/8) == sizeof(session_key)", "sshd.c",
                  944U, "do_connection");
  }
#line 945
  BN_bn2bin((BIGNUM const   *)session_key_int, session_key);
#line 948
  i = 0;
#line 948
  while (i < 16) {
#line 949
    session_key[i] = (unsigned char )((int )session_key[i] ^ (int )session_id[i]);
#line 948
    i ++;
  }
#line 952
  BN_clear_free(session_key_int);
#line 956
  packet_set_encryption_key((unsigned char const   *)(session_key), 32U, (int )cipher_type___0,
                            0);
#line 960
  memset((void *)(session_key), 0, sizeof(session_key));
#line 962
  debug("Received session key; encryption turned on.");
#line 966
  packet_start(14);
#line 967
  packet_send();
#line 968
  packet_write_wait();
#line 971
  packet_read_expect(& plen, 4);
#line 976
  user = packet_get_string((unsigned int *)(& ulen));
#line 977
  while (1) {
#line 977
    _p___0 = plen;
#line 977
    _e___0 = 4 + ulen;
#line 977
    if (_p___0 != _e___0) {
#line 977
      log("Packet integrity error (%d != %d) at %s:%d", _p___0, _e___0, "sshd.c",
          977);
#line 977
      packet_disconnect("Packet integrity error. (%d)", 4);
    }
#line 977
    break;
  }
#line 981
  RSA_free(public_key);
#line 982
  RSA_free(sensitive_data.private_key);
#line 983
  RSA_free(sensitive_data.host_key);
#line 985
  setproctitle("%s", user);
#line 987
  do_authentication(user, privileged_port);
#line 988
  return;
}
}
#line 997 "sshd.c"
static int allowed_user(struct passwd *pw ) 
{ struct group *grp ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1004
  if (! pw) {
#line 1005
    return (0);
  }
#line 1010
  if (options.num_deny_users > 0U) {
#line 1012
    if (! pw->pw_name) {
#line 1013
      return (0);
    }
#line 1014
    i = 0;
#line 1014
    while ((unsigned int )i < options.num_deny_users) {
#line 1015
      tmp = match_pattern((char const   *)pw->pw_name, (char const   *)options.deny_users[i]);
#line 1015
      if (tmp) {
#line 1016
        return (0);
      }
#line 1014
      i ++;
    }
  }
#line 1020
  if (options.num_allow_users > 0U) {
#line 1022
    if (! pw->pw_name) {
#line 1023
      return (0);
    }
#line 1024
    i = 0;
#line 1024
    while ((unsigned int )i < options.num_allow_users) {
#line 1025
      tmp___0 = match_pattern((char const   *)pw->pw_name, (char const   *)options.allow_users[i]);
#line 1025
      if (tmp___0) {
#line 1026
        break;
      }
#line 1024
      i ++;
    }
#line 1028
    if ((unsigned int )i >= options.num_allow_users) {
#line 1029
      return (0);
    }
  }
#line 1033
  if (options.num_deny_groups > 0U) {
    goto _L;
  } else {
#line 1033
    if (options.num_allow_groups > 0U) {
      _L: /* CIL Label */ 
#line 1035
      grp = getgrgid(pw->pw_gid);
#line 1036
      if (! grp) {
#line 1037
        return (0);
      }
#line 1040
      if (options.num_deny_groups > 0U) {
#line 1042
        if (! grp->gr_name) {
#line 1043
          return (0);
        }
#line 1044
        i = 0;
#line 1044
        while ((unsigned int )i < options.num_deny_groups) {
#line 1045
          tmp___1 = match_pattern((char const   *)grp->gr_name, (char const   *)options.deny_groups[i]);
#line 1045
          if (tmp___1) {
#line 1046
            return (0);
          }
#line 1044
          i ++;
        }
      }
#line 1051
      if (options.num_allow_groups > 0U) {
#line 1053
        if (! grp->gr_name) {
#line 1054
          return (0);
        }
#line 1055
        i = 0;
#line 1055
        while ((unsigned int )i < options.num_allow_groups) {
#line 1056
          tmp___2 = match_pattern((char const   *)grp->gr_name, (char const   *)options.allow_groups[i]);
#line 1056
          if (tmp___2) {
#line 1057
            break;
          }
#line 1055
          i ++;
        }
#line 1059
        if ((unsigned int )i >= options.num_allow_groups) {
#line 1060
          return (0);
        }
      }
    }
  }
#line 1065
  return (1);
}
}
#line 1075 "sshd.c"
void do_authentication(char *user , int privileged_port ) 
{ int type ;
  int authenticated ;
  int authentication_failures ;
  char *password ;
  struct passwd *pw ;
  struct passwd pwcopy ;
  char *client_user ;
  unsigned int client_host_key_bits ;
  BIGNUM *client_host_key_e ;
  BIGNUM *client_host_key_n ;
  int plen ;
  int type___0 ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  __uid_t tmp___2 ;
  __uid_t tmp___3 ;
  int tmp___4 ;
  int plen___0 ;
  int dlen ;
  int _p ;
  int _e ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int ulen ;
  int elen ;
  int nlen ;
  int _p___0 ;
  int _e___0 ;
  int tmp___7 ;
  int nlen___0 ;
  BIGNUM *n___0 ;
  int _p___1 ;
  int _e___1 ;
  int tmp___8 ;
  int passw_len ;
  int _p___2 ;
  int _e___2 ;
  size_t tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;

  {
#line 1079
  authenticated = 0;
#line 1080
  authentication_failures = 0;
#line 1099
  pw = getpwnam((char const   *)user);
#line 1113
  if (! pw) {
    goto _L;
  } else {
#line 1113
    tmp___1 = allowed_user(pw);
#line 1113
    if (! tmp___1) {
      _L: /* CIL Label */ 
#line 1118
      packet_start(15);
#line 1119
      packet_send();
#line 1120
      packet_write_wait();
#line 1124
      while (1) {
#line 1128
        tmp = packet_read(& plen);
#line 1128
        type___0 = tmp;
#line 1145
        packet_start(15);
#line 1146
        packet_send();
#line 1147
        packet_write_wait();
#line 1148
        authentication_failures ++;
#line 1148
        if (authentication_failures >= 5) {
#line 1149
          tmp___0 = get_canonical_hostname();
#line 1149
          packet_disconnect("Too many authentication failures for %.100s from %.200s",
                            user, tmp___0);
        }
      }
#line 1154
      abort();
    }
  }
#line 1158
  memset((void *)(& pwcopy), 0, sizeof(pwcopy));
#line 1159
  pwcopy.pw_name = xstrdup((char const   *)pw->pw_name);
#line 1160
  pwcopy.pw_passwd = xstrdup((char const   *)pw->pw_passwd);
#line 1161
  pwcopy.pw_uid = pw->pw_uid;
#line 1162
  pwcopy.pw_gid = pw->pw_gid;
#line 1163
  pwcopy.pw_dir = xstrdup((char const   *)pw->pw_dir);
#line 1164
  pwcopy.pw_shell = xstrdup((char const   *)pw->pw_shell);
#line 1165
  pw = & pwcopy;
#line 1169
  tmp___2 = getuid();
#line 1169
  if (tmp___2 != 0U) {
#line 1169
    tmp___3 = getuid();
#line 1169
    if (pw->pw_uid != tmp___3) {
#line 1170
      packet_disconnect("Cannot change user when server not running as root.");
    }
  }
#line 1172
  debug("Attempting authentication for %.100s.", user);
#line 1175
  if (options.password_authentication) {
#line 1175
    tmp___4 = auth_password(pw, "");
#line 1175
    if (tmp___4) {
#line 1182
      debug("Login for user %.100s accepted without authentication.", user);
#line 1184
      authenticated = 1;
    } else {
#line 1190
      packet_start(15);
#line 1191
      packet_send();
#line 1192
      packet_write_wait();
    }
  } else {
#line 1190
    packet_start(15);
#line 1191
    packet_send();
#line 1192
    packet_write_wait();
  }
#line 1196
  while (! authenticated) {
#line 1200
    type = packet_read(& plen___0);
#line 1203
    switch (type) {
    case 5: 
#line 1279
    if (! options.rhosts_authentication) {
#line 1281
      log("Rhosts authentication disabled.");
#line 1282
      break;
    }
#line 1286
    if (! privileged_port) {
#line 1288
      log("Rhosts authentication not available for connections from unprivileged port.");
#line 1289
      break;
    }
#line 1297
    client_user = packet_get_string((unsigned int *)(& dlen));
#line 1298
    while (1) {
#line 1298
      _p = plen___0;
#line 1298
      _e = 4 + dlen;
#line 1298
      if (_p != _e) {
#line 1298
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "sshd.c", 1298);
#line 1298
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1298
      break;
    }
#line 1302
    tmp___6 = auth_rhosts(pw, (char const   *)client_user, options.ignore_rhosts,
                          options.strict_modes);
#line 1302
    if (tmp___6) {
#line 1306
      tmp___5 = get_canonical_hostname();
#line 1306
      log("Rhosts authentication accepted for %.100s, remote %.100s on %.700s.", user,
          client_user, tmp___5);
#line 1308
      authenticated = 1;
#line 1309
      xfree((void *)client_user);
#line 1310
      break;
    }
#line 1312
    log("Rhosts authentication failed for %.100s, remote %.100s.", user, client_user);
#line 1314
    xfree((void *)client_user);
#line 1315
    break;
    case 35: 
#line 1318
    if (! options.rhosts_rsa_authentication) {
#line 1320
      log("Rhosts with RSA authentication disabled.");
#line 1321
      break;
    }
#line 1326
    if (! privileged_port) {
#line 1328
      log("Rhosts authentication not available for connections from unprivileged port.");
#line 1329
      break;
    }
#line 1337
    client_user = packet_get_string((unsigned int *)(& ulen));
#line 1340
    client_host_key_e = BN_new();
#line 1341
    client_host_key_n = BN_new();
#line 1342
    client_host_key_bits = packet_get_int();
#line 1343
    packet_get_bignum(client_host_key_e, & elen);
#line 1344
    packet_get_bignum(client_host_key_n, & nlen);
#line 1346
    while (1) {
#line 1346
      _p___0 = plen___0;
#line 1346
      _e___0 = (((4 + ulen) + 4) + elen) + nlen;
#line 1346
      if (_p___0 != _e___0) {
#line 1346
        log("Packet integrity error (%d != %d) at %s:%d", _p___0, _e___0, "sshd.c",
            1346);
#line 1346
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1346
      break;
    }
#line 1350
    tmp___7 = auth_rhosts_rsa(pw, (char const   *)client_user, client_host_key_bits,
                              client_host_key_e, client_host_key_n, options.ignore_rhosts,
                              options.strict_modes);
#line 1350
    if (tmp___7) {
#line 1356
      authenticated = 1;
#line 1357
      xfree((void *)client_user);
#line 1358
      BN_clear_free(client_host_key_e);
#line 1359
      BN_clear_free(client_host_key_n);
#line 1360
      break;
    }
#line 1362
    log("Rhosts authentication failed for %.100s, remote %.100s.", user, client_user);
#line 1364
    xfree((void *)client_user);
#line 1365
    BN_clear_free(client_host_key_e);
#line 1366
    BN_clear_free(client_host_key_n);
#line 1367
    break;
    case 6: 
#line 1370
    if (! options.rsa_authentication) {
#line 1372
      log("RSA authentication disabled.");
#line 1373
      break;
    }
#line 1380
    n___0 = BN_new();
#line 1381
    packet_get_bignum(n___0, & nlen___0);
#line 1383
    while (1) {
#line 1383
      _p___1 = plen___0;
#line 1383
      _e___1 = nlen___0;
#line 1383
      if (_p___1 != _e___1) {
#line 1383
        log("Packet integrity error (%d != %d) at %s:%d", _p___1, _e___1, "sshd.c",
            1383);
#line 1383
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1383
      break;
    }
#line 1385
    tmp___8 = auth_rsa(pw, n___0, options.strict_modes);
#line 1385
    if (tmp___8) {
#line 1388
      BN_clear_free(n___0);
#line 1389
      log("RSA authentication for %.100s accepted.", user);
#line 1390
      authenticated = 1;
#line 1391
      break;
    }
#line 1393
    BN_clear_free(n___0);
#line 1394
    log("RSA authentication for %.100s failed.", user);
#line 1396
    break;
    case 9: 
#line 1399
    if (! options.password_authentication) {
#line 1401
      log("Password authentication disabled.");
#line 1402
      break;
    }
#line 1411
    password = packet_get_string((unsigned int *)(& passw_len));
#line 1412
    while (1) {
#line 1412
      _p___2 = plen___0;
#line 1412
      _e___2 = 4 + passw_len;
#line 1412
      if (_p___2 != _e___2) {
#line 1412
        log("Packet integrity error (%d != %d) at %s:%d", _p___2, _e___2, "sshd.c",
            1412);
#line 1412
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1412
      break;
    }
#line 1416
    tmp___10 = auth_password(pw, (char const   *)password);
#line 1416
    if (tmp___10) {
#line 1420
      tmp___9 = strlen((char const   *)password);
#line 1420
      memset((void *)password, 0, tmp___9);
#line 1421
      xfree((void *)password);
#line 1422
      log("Password authentication for %.100s accepted.", user);
#line 1423
      authenticated = 1;
#line 1424
      break;
    }
#line 1426
    log("Password authentication for %.100s failed.", user);
#line 1427
    tmp___11 = strlen((char const   *)password);
#line 1427
    memset((void *)password, 0, tmp___11);
#line 1428
    xfree((void *)password);
#line 1429
    break;
    case 39: 
#line 1433
    log("TIS authentication disabled.");
#line 1434
    break;
    default: 
#line 1439
    log("Unknown message during authentication: type %d", type);
#line 1440
    break;
    }
#line 1443
    if (authenticated) {
#line 1444
      break;
    }
#line 1447
    packet_start(15);
#line 1448
    packet_send();
#line 1449
    packet_write_wait();
#line 1451
    authentication_failures ++;
#line 1451
    if (authentication_failures >= 5) {
#line 1452
      tmp___12 = get_canonical_hostname();
#line 1452
      packet_disconnect("Too many authentication failures for %.100s from %.200s",
                        pw->pw_name, tmp___12);
    }
  }
#line 1458
  if (pw->pw_uid == 0U) {
#line 1458
    if (! options.permit_root_login) {
#line 1460
      if (forced_command) {
#line 1461
        log("Root login accepted for forced command.", forced_command);
      } else {
#line 1463
        tmp___13 = get_canonical_hostname();
#line 1463
        packet_disconnect("ROOT LOGIN REFUSED FROM %.200s", tmp___13);
      }
    }
  }
#line 1468
  packet_start(14);
#line 1469
  packet_send();
#line 1470
  packet_write_wait();
#line 1473
  do_authenticated(pw);
#line 1474
  return;
}
}
#line 1481 "sshd.c"
void do_authenticated(struct passwd *pw ) 
{ int type ;
  int compression_level ;
  int enable_compression_after_reply ;
  int have_pty ;
  int ptyfd ;
  int ttyfd ;
  int xauthfd ;
  int row ;
  int col ;
  int xpixel ;
  int ypixel ;
  int screen ;
  char ttyname___0[64] ;
  char *command ;
  char *term ;
  char *display ;
  char *proto ;
  char *data ;
  struct group *grp ;
  gid_t tty_gid ;
  mode_t tty_mode ;
  int n_bytes ;
  int plen ;
  int dlen ;
  int _p ;
  int _e ;
  unsigned int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int _p___0 ;
  int _e___0 ;
  size_t tmp___7 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___13 ;
  int tmp___16 ;
  int tmp___17 ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;
  int _p___1 ;
  int _e___1 ;
  int proto_len ;
  int data_len ;
  int _p___2 ;
  int _e___2 ;
  unsigned int tmp___22 ;
  unsigned int tmp___23 ;
  void *tmp___24 ;
  int tmp___25 ;
  int _p___3 ;
  int _e___3 ;
  int tmp___26 ;
  int dlen___0 ;
  int _p___4 ;
  int _e___4 ;

  {
#line 1484
  compression_level = 0;
#line 1484
  enable_compression_after_reply = 0;
#line 1485
  have_pty = 0;
#line 1485
  ptyfd = -1;
#line 1485
  ttyfd = -1;
#line 1485
  xauthfd = -1;
#line 1488
  term = (char *)((void *)0);
#line 1488
  display = (char *)((void *)0);
#line 1488
  proto = (char *)((void *)0);
#line 1488
  data = (char *)((void *)0);
#line 1495
  alarm(0U);
#line 1502
  channel_permit_all_opens();
#line 1506
  while (1) {
#line 1511
    type = packet_read(& plen);
#line 1514
    switch (type) {
    case 37: 
#line 1517
    while (1) {
#line 1517
      _p = plen;
#line 1517
      _e = 4;
#line 1517
      if (_p != _e) {
#line 1517
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "sshd.c", 1517);
#line 1517
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1517
      break;
    }
#line 1518
    tmp = packet_get_int();
#line 1518
    compression_level = (int )tmp;
#line 1519
    if (compression_level < 1) {
#line 1521
      packet_send_debug("Received illegal compression level %d.", compression_level);
      goto fail;
    } else {
#line 1519
      if (compression_level > 9) {
#line 1521
        packet_send_debug("Received illegal compression level %d.", compression_level);
        goto fail;
      }
    }
#line 1526
    enable_compression_after_reply = 1;
#line 1527
    break;
    case 10: 
#line 1530
    if (no_pty_flag) {
#line 1532
      debug("Allocating a pty not permitted for this authentication.");
      goto fail;
    }
#line 1535
    if (have_pty) {
#line 1536
      packet_disconnect("Protocol error: you already have a pty.");
    }
#line 1538
    debug("Allocating pty.");
#line 1541
    tmp___0 = pty_allocate(& ptyfd, & ttyfd, ttyname___0);
#line 1541
    if (! tmp___0) {
#line 1543
      error("Failed to allocate pty.");
      goto fail;
    }
#line 1548
    grp = getgrnam("tty");
#line 1549
    if (grp) {
#line 1551
      tty_gid = grp->gr_gid;
#line 1552
      tty_mode = (unsigned int )(384 | (128 >> 3));
    } else {
#line 1556
      tty_gid = pw->pw_gid;
#line 1557
      tty_mode = (unsigned int )((384 | (128 >> 3)) | ((128 >> 3) >> 3));
    }
#line 1561
    tmp___3 = chown((char const   *)(ttyname___0), pw->pw_uid, tty_gid);
#line 1561
    if (tmp___3 < 0) {
#line 1562
      tmp___1 = __errno_location();
#line 1562
      tmp___2 = strerror(*tmp___1);
#line 1562
      fatal("chown(%.100s, %d, %d) failed: %.100s", ttyname___0, pw->pw_uid, tty_gid,
            tmp___2);
    }
#line 1564
    tmp___6 = chmod((char const   *)(ttyname___0), tty_mode);
#line 1564
    if (tmp___6 < 0) {
#line 1565
      tmp___4 = __errno_location();
#line 1565
      tmp___5 = strerror(*tmp___4);
#line 1565
      fatal("chmod(%.100s, 0%o) failed: %.100s", ttyname___0, tty_mode, tmp___5);
    }
#line 1571
    term = packet_get_string((unsigned int *)(& dlen));
#line 1572
    while (1) {
#line 1572
      _p___0 = dlen;
#line 1572
      tmp___7 = strlen((char const   *)term);
#line 1572
      _e___0 = (int )tmp___7;
#line 1572
      if (_p___0 != _e___0) {
#line 1572
        log("Packet integrity error (%d != %d) at %s:%d", _p___0, _e___0, "sshd.c",
            1572);
#line 1572
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1572
      break;
    }
#line 1575
    n_bytes = plen - ((4 + dlen) + 16);
#line 1577
    if (0) {
#line 1577
      __s1_len = strlen((char const   *)term);
#line 1577
      __s2_len = strlen("");
#line 1577
      if (! ((unsigned int )((void const   *)(term + 1)) - (unsigned int )((void const   *)term) == 1U)) {
        goto _L___0;
      } else {
#line 1577
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 1577
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 1577
            tmp___17 = 1;
          } else {
#line 1577
            if (__s2_len >= 4U) {
#line 1577
              tmp___17 = 1;
            } else {
#line 1577
              tmp___17 = 0;
            }
          }
        } else {
#line 1577
          tmp___17 = 0;
        }
      }
#line 1577
      if (tmp___17) {
#line 1577
        tmp___13 = __builtin_strcmp((char const   *)term, "");
      } else {
#line 1577
        tmp___16 = __builtin_strcmp((char const   *)term, "");
#line 1577
        tmp___13 = tmp___16;
      }
    } else {
#line 1577
      tmp___16 = __builtin_strcmp((char const   *)term, "");
#line 1577
      tmp___13 = tmp___16;
    }
#line 1577
    if (tmp___13 == 0) {
#line 1578
      term = (char *)((void *)0);
    }
#line 1581
    tmp___18 = packet_get_int();
#line 1581
    row = (int )tmp___18;
#line 1582
    tmp___19 = packet_get_int();
#line 1582
    col = (int )tmp___19;
#line 1583
    tmp___20 = packet_get_int();
#line 1583
    xpixel = (int )tmp___20;
#line 1584
    tmp___21 = packet_get_int();
#line 1584
    ypixel = (int )tmp___21;
#line 1585
    pty_change_window_size(ptyfd, row, col, xpixel, ypixel);
#line 1588
    tty_parse_modes(ttyfd, & n_bytes);
#line 1589
    while (1) {
#line 1589
      _p___1 = plen;
#line 1589
      _e___1 = ((4 + dlen) + 16) + n_bytes;
#line 1589
      if (_p___1 != _e___1) {
#line 1589
        log("Packet integrity error (%d != %d) at %s:%d", _p___1, _e___1, "sshd.c",
            1589);
#line 1589
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1589
      break;
    }
#line 1592
    have_pty = 1;
#line 1593
    break;
    case 34: 
#line 1596
    if (! options.x11_forwarding) {
#line 1598
      packet_send_debug("X11 forwarding disabled in server configuration file.");
      goto fail;
    }
#line 1602
    if (no_x11_forwarding_flag) {
#line 1604
      packet_send_debug("X11 forwarding not permitted for this authentication.");
      goto fail;
    }
#line 1607
    debug("Received request for X11 forwarding with auth spoofing.");
#line 1608
    if (display) {
#line 1609
      packet_disconnect("Protocol error: X11 display already set.");
    }
#line 1612
    proto = packet_get_string((unsigned int *)(& proto_len));
#line 1613
    data = packet_get_string((unsigned int *)(& data_len));
#line 1614
    while (1) {
#line 1614
      _p___2 = plen;
#line 1614
      _e___2 = (((4 + proto_len) + 4) + data_len) + 4;
#line 1614
      if (_p___2 != _e___2) {
#line 1614
        log("Packet integrity error (%d != %d) at %s:%d", _p___2, _e___2, "sshd.c",
            1614);
#line 1614
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1614
      break;
    }
#line 1616
    tmp___23 = packet_get_protocol_flags();
#line 1616
    if (tmp___23 & 1U) {
#line 1617
      tmp___22 = packet_get_int();
#line 1617
      screen = (int )tmp___22;
    } else {
#line 1619
      screen = 0;
    }
#line 1620
    display = x11_create_display_inet(screen);
#line 1621
    if (! display) {
      goto fail;
    }
#line 1625
    tmp___24 = xmalloc(4096U);
#line 1625
    xauthfile = (char *)tmp___24;
#line 1626
    snprintf((char * __restrict  )xauthfile, 4096U, (char const   * __restrict  )"/tmp/XauthXXXXXX");
#line 1628
    xauthfd = mkstemp(xauthfile);
#line 1628
    if (xauthfd != -1) {
#line 1629
      fchown(xauthfd, pw->pw_uid, pw->pw_gid);
#line 1630
      close(xauthfd);
    } else {
#line 1633
      xfree((void *)xauthfile);
#line 1634
      xauthfile = (char *)((void *)0);
    }
#line 1636
    break;
    case 30: 
#line 1644
    if (no_agent_forwarding_flag) {
#line 1646
      debug("Authentication agent forwarding not permitted for this authentication.");
      goto fail;
    }
#line 1649
    debug("Received authentication agent forwarding request.");
#line 1650
    auth_input_request_forwarding(pw);
#line 1651
    break;
    case 28: 
#line 1654
    if (no_port_forwarding_flag) {
#line 1656
      debug("Port forwarding not permitted for this authentication.");
      goto fail;
    }
#line 1659
    debug("Received TCP/IP port forwarding request.");
#line 1660
    channel_input_port_forward_request(pw->pw_uid == 0U);
#line 1661
    break;
    case 12: 
#line 1665
    if (have_pty) {
#line 1665
      tmp___25 = 1;
    } else {
#line 1665
      if ((unsigned int )display != (unsigned int )((void *)0)) {
#line 1665
        tmp___25 = 1;
      } else {
#line 1665
        tmp___25 = 0;
      }
    }
#line 1665
    packet_set_interactive(tmp___25, options.keepalives);
#line 1668
    if ((unsigned int )forced_command != (unsigned int )((void *)0)) {
      goto do_forced_command;
    }
#line 1670
    debug("Forking shell.");
#line 1671
    while (1) {
#line 1671
      _p___3 = plen;
#line 1671
      _e___3 = 0;
#line 1671
      if (_p___3 != _e___3) {
#line 1671
        log("Packet integrity error (%d != %d) at %s:%d", _p___3, _e___3, "sshd.c",
            1671);
#line 1671
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1671
      break;
    }
#line 1672
    if (have_pty) {
#line 1673
      do_exec_pty((char const   *)((void *)0), ptyfd, ttyfd, (char const   *)(ttyname___0),
                  pw, (char const   *)term, (char const   *)display, (char const   *)proto,
                  (char const   *)data);
    } else {
#line 1676
      do_exec_no_pty((char const   *)((void *)0), pw, (char const   *)display, (char const   *)proto,
                     (char const   *)data);
    }
#line 1677
    return;
    case 13: 
#line 1681
    if (have_pty) {
#line 1681
      tmp___26 = 1;
    } else {
#line 1681
      if ((unsigned int )display != (unsigned int )((void *)0)) {
#line 1681
        tmp___26 = 1;
      } else {
#line 1681
        tmp___26 = 0;
      }
    }
#line 1681
    packet_set_interactive(tmp___26, options.keepalives);
#line 1684
    if ((unsigned int )forced_command != (unsigned int )((void *)0)) {
      goto do_forced_command;
    }
#line 1689
    command = packet_get_string((unsigned int *)(& dlen___0));
#line 1690
    debug("Executing command \'%.500s\'", command);
#line 1691
    while (1) {
#line 1691
      _p___4 = plen;
#line 1691
      _e___4 = 4 + dlen___0;
#line 1691
      if (_p___4 != _e___4) {
#line 1691
        log("Packet integrity error (%d != %d) at %s:%d", _p___4, _e___4, "sshd.c",
            1691);
#line 1691
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1691
      break;
    }
#line 1693
    if (have_pty) {
#line 1694
      do_exec_pty((char const   *)command, ptyfd, ttyfd, (char const   *)(ttyname___0),
                  pw, (char const   *)term, (char const   *)display, (char const   *)proto,
                  (char const   *)data);
    } else {
#line 1697
      do_exec_no_pty((char const   *)command, pw, (char const   *)display, (char const   *)proto,
                     (char const   *)data);
    }
#line 1698
    xfree((void *)command);
#line 1699
    return;
    case 38: 
#line 1702
    debug("The server does not support limiting packet size.");
    goto fail;
    default: 
#line 1708
    log("Unknown packet type received after authentication: %d", type);
    goto fail;
    }
#line 1713
    packet_start(14);
#line 1714
    packet_send();
#line 1715
    packet_write_wait();
#line 1718
    if (enable_compression_after_reply) {
#line 1720
      enable_compression_after_reply = 0;
#line 1721
      packet_start_compression(compression_level);
    }
#line 1724
    continue;
    fail: 
#line 1728
    packet_start(15);
#line 1729
    packet_send();
#line 1730
    packet_write_wait();
#line 1731
    continue;
    do_forced_command: 
#line 1735
    debug("Executing forced command: %.900s", forced_command);
#line 1736
    if (have_pty) {
#line 1737
      do_exec_pty((char const   *)forced_command, ptyfd, ttyfd, (char const   *)(ttyname___0),
                  pw, (char const   *)term, (char const   *)display, (char const   *)proto,
                  (char const   *)data);
    } else {
#line 1740
      do_exec_no_pty((char const   *)forced_command, pw, (char const   *)display,
                     (char const   *)proto, (char const   *)data);
    }
#line 1741
    return;
  }
}
}
#line 1749 "sshd.c"
void do_exec_no_pty(char const   *command , struct passwd *pw , char const   *display ,
                    char const   *auth_proto , char const   *auth_data ) 
{ int pid ;
  int pin[2] ;
  int pout[2] ;
  int perr[2] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  __pid_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;

  {
#line 1758
  tmp___1 = pipe((int *)(pin));
#line 1758
  if (tmp___1 < 0) {
#line 1759
    tmp = __errno_location();
#line 1759
    tmp___0 = strerror(*tmp);
#line 1759
    packet_disconnect("Could not create pipes: %.100s", tmp___0);
  } else {
#line 1758
    tmp___2 = pipe((int *)(pout));
#line 1758
    if (tmp___2 < 0) {
#line 1759
      tmp = __errno_location();
#line 1759
      tmp___0 = strerror(*tmp);
#line 1759
      packet_disconnect("Could not create pipes: %.100s", tmp___0);
    } else {
#line 1758
      tmp___3 = pipe((int *)(perr));
#line 1758
      if (tmp___3 < 0) {
#line 1759
        tmp = __errno_location();
#line 1759
        tmp___0 = strerror(*tmp);
#line 1759
        packet_disconnect("Could not create pipes: %.100s", tmp___0);
      }
    }
  }
#line 1770
  setproctitle("%s@notty", pw->pw_name);
#line 1773
  pid = fork();
#line 1773
  if (pid == 0) {
#line 1776
    if (debug_flag) {
#line 1776
      if (! inetd_flag) {
#line 1776
        tmp___4 = 1;
      } else {
#line 1776
        tmp___4 = 0;
      }
    } else {
#line 1776
      tmp___4 = 0;
    }
#line 1776
    log_init(av0, tmp___4, debug_flag, options.quiet_mode, options.log_facility);
#line 1781
    tmp___7 = setsid();
#line 1781
    if (tmp___7 < 0) {
#line 1782
      tmp___5 = __errno_location();
#line 1782
      tmp___6 = strerror(*tmp___5);
#line 1782
      error("setsid failed: %.100s", tmp___6);
    }
#line 1787
    close(pin[1]);
#line 1788
    tmp___8 = dup2(pin[0], 0);
#line 1788
    if (tmp___8 < 0) {
#line 1789
      perror("dup2 stdin");
    }
#line 1790
    close(pin[0]);
#line 1793
    close(pout[0]);
#line 1794
    tmp___9 = dup2(pout[1], 1);
#line 1794
    if (tmp___9 < 0) {
#line 1795
      perror("dup2 stdout");
    }
#line 1796
    close(pout[1]);
#line 1799
    close(perr[0]);
#line 1800
    tmp___10 = dup2(perr[1], 2);
#line 1800
    if (tmp___10 < 0) {
#line 1801
      perror("dup2 stderr");
    }
#line 1802
    close(perr[1]);
#line 1818
    do_child(command, pw, (char const   *)((void *)0), display, auth_proto, auth_data,
             (char const   *)((void *)0));
  }
#line 1821
  if (pid < 0) {
#line 1822
    tmp___11 = __errno_location();
#line 1822
    tmp___12 = strerror(*tmp___11);
#line 1822
    packet_disconnect("fork failed: %.100s", tmp___12);
  }
#line 1825
  close(pin[0]);
#line 1826
  close(pout[1]);
#line 1827
  close(perr[1]);
#line 1830
  server_loop(pid, pin[1], pout[0], perr[0]);
#line 1842
  return;
}
}
#line 1853 "sshd.c"
void pty_cleanup_proc(void *context ) 
{ struct pty_cleanup_context *cu ;

  {
#line 1855
  cu = (struct pty_cleanup_context *)context;
#line 1857
  debug("pty_cleanup_proc called");
#line 1865
  record_logout(cu->pid, cu->ttyname);
#line 1868
  pty_release(cu->ttyname);
#line 1869
  return;
}
}
#line 1876 "sshd.c"
void do_exec_pty(char const   *command , int ptyfd , int ttyfd , char const   *ttyname___0 ,
                 struct passwd *pw , char const   *term , char const   *display ,
                 char const   *auth_proto , char const   *auth_data ) 
{ int pid ;
  int fdout___0 ;
  char const   *hostname ;
  time_t last_login_time ;
  char buf[100] ;
  char *time_string ;
  FILE *f ;
  char line[256] ;
  struct stat st ;
  int quiet_login ;
  struct sockaddr_in from ;
  int fromlen ;
  struct pty_cleanup_context cleanup_context ;
  unsigned long tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char *tmp___22 ;
  char *tmp___24 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___30 ;
  int tmp___33 ;
  int tmp___34 ;
  char *tmp___35 ;
  int *tmp___36 ;
  char *tmp___37 ;
  int *tmp___38 ;
  char *tmp___39 ;

  {
#line 1894
  hostname = get_canonical_hostname();
#line 1898
  if (! options.use_login) {
#line 1899
    tmp = get_last_login_time(pw->pw_uid, (char const   *)pw->pw_name, buf, sizeof(buf));
#line 1899
    last_login_time = (long )tmp;
  }
#line 1903
  tmp___0 = strrchr(ttyname___0, '/');
#line 1903
  setproctitle("%s@%s", pw->pw_name, tmp___0 + 1);
#line 1906
  pid = fork();
#line 1906
  if (pid == 0) {
#line 1908
    pid = getpid();
#line 1911
    if (debug_flag) {
#line 1911
      if (! inetd_flag) {
#line 1911
        tmp___1 = 1;
      } else {
#line 1911
        tmp___1 = 0;
      }
    } else {
#line 1911
      tmp___1 = 0;
    }
#line 1911
    log_init(av0, tmp___1, debug_flag, options.quiet_mode, options.log_facility);
#line 1915
    close(ptyfd);
#line 1918
    pty_make_controlling_tty(& ttyfd, ttyname___0);
#line 1921
    tmp___4 = fileno(stdin);
#line 1921
    tmp___5 = dup2(ttyfd, tmp___4);
#line 1921
    if (tmp___5 < 0) {
#line 1922
      tmp___2 = __errno_location();
#line 1922
      tmp___3 = strerror(*tmp___2);
#line 1922
      error("dup2 stdin failed: %.100s", tmp___3);
    }
#line 1925
    tmp___8 = fileno(stdout);
#line 1925
    tmp___9 = dup2(ttyfd, tmp___8);
#line 1925
    if (tmp___9 < 0) {
#line 1926
      tmp___6 = __errno_location();
#line 1926
      tmp___7 = strerror(*tmp___6);
#line 1926
      error("dup2 stdin failed: %.100s", tmp___7);
    }
#line 1929
    tmp___12 = fileno(stderr);
#line 1929
    tmp___13 = dup2(ttyfd, tmp___12);
#line 1929
    if (tmp___13 < 0) {
#line 1930
      tmp___10 = __errno_location();
#line 1930
      tmp___11 = strerror(*tmp___10);
#line 1930
      error("dup2 stdin failed: %.100s", tmp___11);
    }
#line 1933
    close(ttyfd);
#line 1938
    memset((void *)(& from), 0, sizeof(from));
#line 1939
    tmp___18 = packet_get_connection_in();
#line 1939
    tmp___19 = packet_get_connection_out();
#line 1939
    if (tmp___18 == tmp___19) {
#line 1941
      fromlen = (int )sizeof(from);
#line 1942
      tmp___16 = packet_get_connection_in();
#line 1942
      tmp___17 = getpeername(tmp___16, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                             (socklen_t * __restrict  )(& fromlen));
#line 1942
      if (tmp___17 < 0) {
#line 1944
        tmp___14 = __errno_location();
#line 1944
        tmp___15 = strerror(*tmp___14);
#line 1944
        fatal("getpeername: %.100s", tmp___15);
      }
    }
#line 1948
    record_login(pid, ttyname___0, (char const   *)pw->pw_name, pw->pw_uid, hostname,
                 & from);
#line 1952
    snprintf((char * __restrict  )(line), sizeof(line), (char const   * __restrict  )"%.200s/.hushlogin",
             pw->pw_dir);
#line 1953
    tmp___20 = stat((char const   * __restrict  )(line), (struct stat * __restrict  )(& st));
#line 1953
    quiet_login = tmp___20 >= 0;
#line 1960
    if ((unsigned int )command == (unsigned int )((void *)0)) {
#line 1960
      if (last_login_time != 0L) {
#line 1960
        if (! quiet_login) {
#line 1960
          if (! options.use_login) {
#line 1964
            time_string = ctime((time_t const   *)(& last_login_time));
#line 1966
            tmp___24 = __builtin_strchr(time_string, '\n');
#line 1966
            if (tmp___24) {
#line 1967
              tmp___22 = __builtin_strchr(time_string, '\n');
#line 1967
              *tmp___22 = (char)0;
            }
#line 1969
            if (0) {
#line 1969
              __s1_len = strlen((char const   *)(buf));
#line 1969
              __s2_len = strlen("");
#line 1969
              if (! ((unsigned int )((void const   *)(buf + 1)) - (unsigned int )((void const   *)(buf)) == 1U)) {
                goto _L___0;
              } else {
#line 1969
                if (__s1_len >= 4U) {
                  _L___0: /* CIL Label */ 
#line 1969
                  if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 1969
                    tmp___34 = 1;
                  } else {
#line 1969
                    if (__s2_len >= 4U) {
#line 1969
                      tmp___34 = 1;
                    } else {
#line 1969
                      tmp___34 = 0;
                    }
                  }
                } else {
#line 1969
                  tmp___34 = 0;
                }
              }
#line 1969
              if (tmp___34) {
#line 1969
                tmp___30 = __builtin_strcmp((char const   *)(buf), "");
              } else {
#line 1969
                tmp___33 = __builtin_strcmp((char const   *)(buf), "");
#line 1969
                tmp___30 = tmp___33;
              }
            } else {
#line 1969
              tmp___33 = __builtin_strcmp((char const   *)(buf), "");
#line 1969
              tmp___30 = tmp___33;
            }
#line 1969
            if (tmp___30 == 0) {
#line 1970
              printf((char const   * __restrict  )"Last login: %s\r\n", time_string);
            } else {
#line 1972
              printf((char const   * __restrict  )"Last login: %s from %s\r\n", time_string,
                     buf);
            }
          }
        }
      }
    }
#line 1978
    if ((unsigned int )command == (unsigned int )((void *)0)) {
#line 1978
      if (options.print_motd) {
#line 1978
        if (! quiet_login) {
#line 1978
          if (! options.use_login) {
#line 1982
            f = fopen((char const   * __restrict  )"/etc/motd", (char const   * __restrict  )"r");
#line 1983
            if (f) {
#line 1985
              while (1) {
#line 1985
                tmp___35 = fgets((char * __restrict  )(line), (int )sizeof(line),
                                 (FILE * __restrict  )f);
#line 1985
                if (! tmp___35) {
#line 1985
                  break;
                }
#line 1986
                fputs((char const   * __restrict  )(line), (FILE * __restrict  )stdout);
              }
#line 1987
              fclose(f);
            }
          }
        }
      }
    }
#line 1992
    do_child(command, pw, term, display, auth_proto, auth_data, ttyname___0);
  }
#line 1995
  if (pid < 0) {
#line 1996
    tmp___36 = __errno_location();
#line 1996
    tmp___37 = strerror(*tmp___36);
#line 1996
    packet_disconnect("fork failed: %.100s", tmp___37);
  }
#line 1998
  close(ttyfd);
#line 2003
  fdout___0 = dup(ptyfd);
#line 2004
  if (fdout___0 < 0) {
#line 2005
    tmp___38 = __errno_location();
#line 2005
    tmp___39 = strerror(*tmp___38);
#line 2005
    packet_disconnect("dup failed: %.100s", tmp___39);
  }
#line 2009
  cleanup_context.pid = pid;
#line 2010
  cleanup_context.ttyname = ttyname___0;
#line 2011
  fatal_add_cleanup(& pty_cleanup_proc, (void *)(& cleanup_context));
#line 2014
  server_loop(pid, ptyfd, fdout___0, -1);
#line 2018
  fatal_remove_cleanup(& pty_cleanup_proc, (void *)(& cleanup_context));
#line 2021
  record_logout(pid, ttyname___0);
#line 2024
  pty_release(ttyname___0);
#line 2029
  close(ptyfd);
#line 2030
  close(fdout___0);
#line 2031
  return;
}
}
#line 2036 "sshd.c"
void child_set_env(char ***envp , unsigned int *envsizep , char const   *name , char const   *value ) 
{ unsigned int i ;
  unsigned int namelen ;
  char **env ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  void *tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  void *tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;

  {
#line 2045
  env = *envp;
#line 2046
  namelen = strlen(name);
#line 2047
  i = 0U;
#line 2047
  while (*(env + i)) {
#line 2048
    if (0) {
#line 2048
      if (0) {
#line 2048
        __s1_len___0 = strlen((char const   *)*(env + i));
#line 2048
        __s2_len___0 = strlen(name);
#line 2048
        if (! ((unsigned int )((void const   *)(*(env + i) + 1)) - (unsigned int )((void const   *)*(env + i)) == 1U)) {
          goto _L___2;
        } else {
#line 2048
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 2048
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
#line 2048
              tmp___22 = 1;
            } else {
#line 2048
              if (__s2_len___0 >= 4U) {
#line 2048
                tmp___22 = 1;
              } else {
#line 2048
                tmp___22 = 0;
              }
            }
          } else {
#line 2048
            tmp___22 = 0;
          }
        }
#line 2048
        if (tmp___22) {
#line 2048
          tmp___18 = __builtin_strcmp((char const   *)*(env + i), name);
        } else {
#line 2048
          tmp___21 = __builtin_strcmp((char const   *)*(env + i), name);
#line 2048
          tmp___18 = tmp___21;
        }
      } else {
#line 2048
        tmp___21 = __builtin_strcmp((char const   *)*(env + i), name);
#line 2048
        tmp___18 = tmp___21;
      }
#line 2048
      tmp___12 = tmp___18;
    } else {
#line 2048
      tmp___12 = strncmp((char const   *)*(env + i), name, namelen);
    }
#line 2048
    if (tmp___12 == 0) {
#line 2048
      if ((int )*(*(env + i) + namelen) == 61) {
#line 2049
        break;
      }
    }
#line 2047
    i ++;
  }
#line 2050
  if (*(env + i)) {
#line 2053
    xfree((void *)*(env + i));
  } else {
#line 2058
    if (i >= *envsizep - 1U) {
#line 2060
      *envsizep += 50U;
#line 2061
      tmp___25 = xrealloc((void *)env, *envsizep * sizeof(char *));
#line 2061
      *envp = (char **)tmp___25;
#line 2061
      env = *envp;
    }
#line 2066
    *(env + (i + 1U)) = (char *)((void *)0);
  }
#line 2070
  tmp___26 = strlen(name);
#line 2070
  tmp___27 = strlen(value);
#line 2070
  tmp___28 = xmalloc(((tmp___26 + 1U) + tmp___27) + 1U);
#line 2070
  *(env + i) = (char *)tmp___28;
#line 2071
  tmp___29 = strlen(name);
#line 2071
  tmp___30 = strlen(value);
#line 2071
  snprintf((char * __restrict  )*(env + i), ((tmp___29 + 1U) + tmp___30) + 1U, (char const   * __restrict  )"%s=%s",
           name, value);
#line 2072
  return;
}
}
#line 2079 "sshd.c"
void read_environment_file(char ***env , unsigned int *envsize , char const   *filename ) 
{ FILE *f ;
  char buf[4096] ;
  char *cp ;
  char *value ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 2087
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 2088
  if (! f) {
#line 2089
    return;
  }
#line 2092
  while (1) {
#line 2092
    tmp___5 = fgets((char * __restrict  )(buf), (int )sizeof(buf), (FILE * __restrict  )f);
#line 2092
    if (! tmp___5) {
#line 2092
      break;
    }
#line 2095
    cp = buf;
#line 2095
    while (1) {
#line 2095
      if (! ((int )*cp == 32)) {
#line 2095
        if (! ((int )*cp == 9)) {
#line 2095
          break;
        }
      }
#line 2095
      cp ++;
    }
#line 2099
    if (! *cp) {
#line 2100
      continue;
    } else {
#line 2099
      if ((int )*cp == 35) {
#line 2100
        continue;
      } else {
#line 2099
        if ((int )*cp == 10) {
#line 2100
          continue;
        }
      }
    }
#line 2103
    tmp___2 = __builtin_strchr(cp, '\n');
#line 2103
    if (tmp___2) {
#line 2104
      tmp___0 = __builtin_strchr(cp, '\n');
#line 2104
      *tmp___0 = (char )'\000';
    }
#line 2107
    tmp___4 = __builtin_strchr(cp, '=');
#line 2107
    value = tmp___4;
#line 2108
    if ((unsigned int )value == (unsigned int )((void *)0)) {
#line 2110
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad line in %.100s: %.200s\n",
              filename, buf);
#line 2111
      continue;
    }
#line 2116
    *value = (char )'\000';
#line 2117
    value ++;
#line 2120
    child_set_env(env, envsize, (char const   *)cp, (char const   *)value);
  }
#line 2123
  fclose(f);
#line 2124
  return;
}
}
#line 2139
extern char **environ ;
#line 2130 "sshd.c"
void do_child(char const   *command , struct passwd *pw , char const   *term , char const   *display ,
              char const   *auth_proto , char const   *auth_data , char const   *ttyname___0 ) 
{ char const   *shell ;
  char const   *cp ;
  char buf[256] ;
  FILE *f ;
  unsigned int envsize ;
  unsigned int i ;
  char **env ;
  struct stat st ;
  char *argv[10] ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  __uid_t tmp___5 ;
  __uid_t tmp___6 ;
  __uid_t tmp___7 ;
  __uid_t tmp___8 ;
  void *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  struct envstring *ce ;
  char *s ;
  int i___0 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  char buf___0[256] ;
  char *mailbox ;
  struct stat mailstat ;
  int tmp___27 ;
  char const   *tmp___28 ;

  {
#line 2134
  cp = (char const   *)((void *)0);
#line 2144
  f = fopen((char const   * __restrict  )"/etc/nologin", (char const   * __restrict  )"r");
#line 2145
  if (f) {
#line 2147
    while (1) {
#line 2147
      tmp = fgets((char * __restrict  )(buf), (int )sizeof(buf), (FILE * __restrict  )f);
#line 2147
      if (! tmp) {
#line 2147
        break;
      }
#line 2148
      fputs((char const   * __restrict  )(buf), (FILE * __restrict  )stderr);
    }
#line 2149
    fclose(f);
#line 2150
    if (pw->pw_uid != 0U) {
#line 2151
      exit(254);
    }
  }
#line 2155
  tmp___2 = setlogin((char const   *)pw->pw_name);
#line 2155
  if (tmp___2 < 0) {
#line 2156
    tmp___0 = __errno_location();
#line 2156
    tmp___1 = strerror(*tmp___0);
#line 2156
    error("setlogin failed: %s", tmp___1);
  }
#line 2161
  if (! options.use_login) {
#line 2162
    tmp___5 = getuid();
#line 2162
    if (tmp___5 == 0U) {
      goto _L;
    } else {
#line 2162
      tmp___6 = geteuid();
#line 2162
      if (tmp___6 == 0U) {
        _L: /* CIL Label */ 
#line 2164
        tmp___3 = setgid(pw->pw_gid);
#line 2164
        if (tmp___3 < 0) {
#line 2166
          perror("setgid");
#line 2167
          exit(1);
        }
#line 2170
        tmp___4 = initgroups((char const   *)pw->pw_name, pw->pw_gid);
#line 2170
        if (tmp___4 < 0) {
#line 2172
          perror("initgroups");
#line 2173
          exit(1);
        }
#line 2175
        endgrent();
#line 2178
        permanently_set_uid(pw->pw_uid);
      }
    }
#line 2181
    tmp___7 = getuid();
#line 2181
    if (tmp___7 != pw->pw_uid) {
#line 2182
      fatal("Failed to set uids to %d.", (int )pw->pw_uid);
    } else {
#line 2181
      tmp___8 = geteuid();
#line 2181
      if (tmp___8 != pw->pw_uid) {
#line 2182
        fatal("Failed to set uids to %d.", (int )pw->pw_uid);
      }
    }
  }
#line 2187
  if ((int )*(pw->pw_shell + 0) == 0) {
#line 2187
    shell = "/bin/sh";
  } else {
#line 2187
    shell = (char const   *)pw->pw_shell;
  }
#line 2203
  envsize = 100U;
#line 2204
  tmp___9 = xmalloc(envsize * sizeof(char *));
#line 2204
  env = (char **)tmp___9;
#line 2205
  *(env + 0) = (char *)((void *)0);
#line 2207
  if (! options.use_login) {
#line 2209
    child_set_env(& env, & envsize, "USER", (char const   *)pw->pw_name);
#line 2210
    child_set_env(& env, & envsize, "LOGNAME", (char const   *)pw->pw_name);
#line 2211
    child_set_env(& env, & envsize, "HOME", (char const   *)pw->pw_dir);
#line 2212
    child_set_env(& env, & envsize, "PATH", "/usr/bin:/bin:/usr/sbin:/sbin");
#line 2214
    snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%.200s/%.50s",
             "/var/mail", pw->pw_name);
#line 2216
    child_set_env(& env, & envsize, "MAIL", (char const   *)(buf));
#line 2219
    child_set_env(& env, & envsize, "SHELL", shell);
  }
#line 2223
  tmp___11 = getenv("TZ");
#line 2223
  if (tmp___11) {
#line 2224
    tmp___10 = getenv("TZ");
#line 2224
    child_set_env(& env, & envsize, "TZ", (char const   *)tmp___10);
  }
#line 2227
  while (custom_environment) {
#line 2229
    ce = custom_environment;
#line 2230
    s = ce->s;
#line 2232
    i___0 = 0;
#line 2232
    while (1) {
#line 2232
      if ((int )*(s + i___0) != 61) {
#line 2232
        if (! *(s + i___0)) {
#line 2232
          break;
        }
      } else {
#line 2232
        break;
      }
#line 2232
      i___0 ++;
    }
#line 2234
    if ((int )*(s + i___0) == 61) {
#line 2236
      *(s + i___0) = (char)0;
#line 2237
      child_set_env(& env, & envsize, (char const   *)s, (char const   *)((s + i___0) + 1));
    }
#line 2239
    custom_environment = ce->next;
#line 2240
    xfree((void *)ce->s);
#line 2241
    xfree((void *)ce);
  }
#line 2245
  tmp___12 = get_remote_port();
#line 2245
  tmp___13 = get_remote_ipaddr();
#line 2245
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%.50s %d %d",
           tmp___13, tmp___12, options.port);
#line 2247
  child_set_env(& env, & envsize, "SSH_CLIENT", (char const   *)(buf));
#line 2250
  if (ttyname___0) {
#line 2251
    child_set_env(& env, & envsize, "SSH_TTY", ttyname___0);
  }
#line 2254
  if (term) {
#line 2255
    child_set_env(& env, & envsize, "TERM", term);
  }
#line 2258
  if (display) {
#line 2259
    child_set_env(& env, & envsize, "DISPLAY", display);
  }
#line 2267
  if (xauthfile) {
#line 2268
    child_set_env(& env, & envsize, "XAUTHORITY", (char const   *)xauthfile);
  }
#line 2271
  tmp___15 = auth_get_socket_name();
#line 2271
  if ((unsigned int )tmp___15 != (unsigned int )((void *)0)) {
#line 2272
    tmp___14 = auth_get_socket_name();
#line 2272
    child_set_env(& env, & envsize, "SSH_AUTH_SOCK", (char const   *)tmp___14);
  }
#line 2276
  if (! options.use_login) {
#line 2277
    snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%.200s/.ssh/environment",
             pw->pw_dir);
#line 2278
    read_environment_file(& env, & envsize, (char const   *)(buf));
  }
#line 2282
  if (debug_flag) {
#line 2284
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Environment:\n");
#line 2285
    i = 0U;
#line 2285
    while (*(env + i)) {
#line 2286
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  %.200s\n",
              *(env + i));
#line 2285
      i ++;
    }
  }
#line 2293
  tmp___19 = packet_get_connection_in();
#line 2293
  tmp___20 = packet_get_connection_out();
#line 2293
  if (tmp___19 == tmp___20) {
#line 2294
    tmp___16 = packet_get_connection_in();
#line 2294
    close(tmp___16);
  } else {
#line 2297
    tmp___17 = packet_get_connection_in();
#line 2297
    close(tmp___17);
#line 2298
    tmp___18 = packet_get_connection_out();
#line 2298
    close(tmp___18);
  }
#line 2302
  channel_close_all();
#line 2306
  endpwent();
#line 2307
  endhostent();
#line 2313
  i = 3U;
#line 2313
  while (i < 64U) {
#line 2314
    close((int )i);
#line 2313
    i ++;
  }
#line 2317
  tmp___23 = chdir((char const   *)pw->pw_dir);
#line 2317
  if (tmp___23 < 0) {
#line 2318
    tmp___21 = __errno_location();
#line 2318
    tmp___22 = strerror(*tmp___21);
#line 2318
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not chdir to home directory %s: %s\n",
            pw->pw_dir, tmp___22);
  }
#line 2323
  environ = env;
#line 2327
  if (! options.use_login) {
#line 2328
    tmp___25 = stat((char const   * __restrict  )".ssh/rc", (struct stat * __restrict  )(& st));
#line 2328
    if (tmp___25 >= 0) {
#line 2330
      if (debug_flag) {
#line 2331
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running /bin/sh %s\n",
                ".ssh/rc");
      }
#line 2333
      f = popen("/bin/sh .ssh/rc", "w");
#line 2334
      if (f) {
#line 2336
        if ((unsigned int )auth_proto != (unsigned int )((void *)0)) {
#line 2336
          if ((unsigned int )auth_data != (unsigned int )((void *)0)) {
#line 2337
            fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                    auth_proto, auth_data);
          }
        }
#line 2338
        pclose(f);
      } else {
#line 2341
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                ".ssh/rc");
      }
    } else {
#line 2344
      tmp___24 = stat((char const   * __restrict  )"/usr/local/etc/sshrc", (struct stat * __restrict  )(& st));
#line 2344
      if (tmp___24 >= 0) {
#line 2346
        if (debug_flag) {
#line 2347
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running /bin/sh %s\n",
                  "/usr/local/etc/sshrc");
        }
#line 2349
        f = popen("/bin/sh /usr/local/etc/sshrc", "w");
#line 2350
        if (f) {
#line 2352
          if ((unsigned int )auth_proto != (unsigned int )((void *)0)) {
#line 2352
            if ((unsigned int )auth_data != (unsigned int )((void *)0)) {
#line 2353
              fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                      auth_proto, auth_data);
            }
          }
#line 2354
          pclose(f);
        } else {
#line 2357
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                  "/usr/local/etc/sshrc");
        }
      } else {
#line 2363
        if ((unsigned int )auth_proto != (unsigned int )((void *)0)) {
#line 2363
          if ((unsigned int )auth_data != (unsigned int )((void *)0)) {
#line 2365
            if (debug_flag) {
#line 2366
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %.100s add %.100s %.100s %.100s\n",
                      "/usr/X11R6/bin/xauth", display, auth_proto, auth_data);
            }
#line 2369
            f = popen("/usr/X11R6/bin/xauth -q -", "w");
#line 2370
            if (f) {
#line 2372
              fprintf((FILE * __restrict  )f, (char const   * __restrict  )"add %s %s %s\n",
                      display, auth_proto, auth_data);
#line 2373
              fclose(f);
            } else {
#line 2376
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s -q -\n",
                      "/usr/X11R6/bin/xauth");
            }
          }
        }
      }
    }
#line 2382
    tmp___26 = strrchr(shell, '/');
#line 2382
    cp = (char const   *)tmp___26;
#line 2383
    if (cp) {
#line 2384
      cp ++;
    } else {
#line 2386
      cp = shell;
    }
  }
#line 2392
  if (! command) {
#line 2394
    if (! options.use_login) {
#line 2398
      if (ttyname___0) {
#line 2398
        if (options.check_mail) {
#line 2401
          mailbox = getenv("MAIL");
#line 2402
          if ((unsigned int )mailbox != (unsigned int )((void *)0)) {
#line 2403
            tmp___27 = stat((char const   * __restrict  )mailbox, (struct stat * __restrict  )(& mailstat));
#line 2403
            if (tmp___27 != 0) {
#line 2404
              printf((char const   * __restrict  )"No mail.\n");
            } else {
#line 2403
              if (mailstat.st_size == 0L) {
#line 2404
                printf((char const   * __restrict  )"No mail.\n");
              } else {
#line 2405
                if (mailstat.st_mtim.tv_sec < mailstat.st_atim.tv_sec) {
#line 2406
                  printf((char const   * __restrict  )"You have mail.\n");
                } else {
#line 2408
                  printf((char const   * __restrict  )"You have new mail.\n");
                }
              }
            }
          }
        }
      }
#line 2413
      buf___0[0] = (char )'-';
#line 2414
      __builtin_strncpy(buf___0 + 1, cp, sizeof(buf___0) - 1U);
#line 2415
      buf___0[sizeof(buf___0) - 1U] = (char)0;
#line 2417
      argv[0] = buf___0;
#line 2418
      argv[1] = (char *)((void *)0);
#line 2419
      execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 2421
      perror(shell);
#line 2422
      exit(1);
    } else {
#line 2427
      tmp___28 = get_remote_ipaddr();
#line 2427
      execl("/usr/bin/login", "login", "-h", tmp___28, "-p", "-f", "--", pw->pw_name,
            (void *)0);
#line 2431
      perror("login");
#line 2432
      exit(1);
    }
  }
#line 2438
  argv[0] = (char *)cp;
#line 2439
  argv[1] = (char *)"-c";
#line 2440
  argv[2] = (char *)command;
#line 2441
  argv[3] = (char *)((void *)0);
#line 2442
  execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 2443
  perror(shell);
#line 2444
  exit(1);
}
}
#line 1 "auth-rhosts.o"
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 325 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 418 "/usr/include/netdb.h"
extern int innetgr(char const   *__netgroup , char const   *__host , char const   *__user ,
                   char const   *domain ) ;
#line 30 "auth-rhosts.c"
int check_rhosts_file(char const   *filename , char const   *hostname , char const   *ipaddr ,
                      char const   *client_user , char const   *server_user ) 
{ FILE *f ;
  char buf[1024] ;
  char hostbuf[1024] ;
  char userbuf[1024] ;
  char dummy[1024] ;
  char *host ;
  char *user ;
  char *cp ;
  int negated ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___45 ;
  int tmp___48 ;
  int tmp___49 ;
  char *tmp___50 ;

  {
#line 38
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 39
  if (! f) {
#line 40
    return (0);
  }
#line 43
  while (1) {
#line 43
    tmp___50 = fgets((char * __restrict  )(buf), (int )sizeof(buf), (FILE * __restrict  )f);
#line 43
    if (! tmp___50) {
#line 43
      break;
    }
#line 49
    cp = buf;
#line 49
    while (1) {
#line 49
      if (! ((int )*cp == 32)) {
#line 49
        if (! ((int )*cp == 9)) {
#line 49
          break;
        }
      }
#line 49
      cp ++;
    }
#line 51
    if ((int )*cp == 35) {
#line 52
      continue;
    } else {
#line 51
      if ((int )*cp == 10) {
#line 52
        continue;
      } else {
#line 51
        if (! *cp) {
#line 52
          continue;
        }
      }
    }
#line 56
    if (0) {
#line 56
      if (0) {
#line 56
        __s1_len___0 = strlen((char const   *)cp);
#line 56
        __s2_len___0 = strlen("NO_PLUS");
#line 56
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___2;
        } else {
#line 56
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 56
            if (! ((unsigned int )((void const   *)("NO_PLUS" + 1)) - (unsigned int )((void const   *)"NO_PLUS") == 1U)) {
#line 56
              tmp___22 = 1;
            } else {
#line 56
              if (__s2_len___0 >= 4U) {
#line 56
                tmp___22 = 1;
              } else {
#line 56
                tmp___22 = 0;
              }
            }
          } else {
#line 56
            tmp___22 = 0;
          }
        }
#line 56
        if (tmp___22) {
#line 56
          tmp___18 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
        } else {
#line 56
          tmp___21 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 56
          tmp___18 = tmp___21;
        }
      } else {
#line 56
        tmp___21 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 56
        tmp___18 = tmp___21;
      }
#line 56
      tmp___12 = tmp___18;
    } else {
#line 56
      tmp___12 = strncmp((char const   *)cp, "NO_PLUS", 7U);
    }
#line 56
    if (tmp___12 == 0) {
#line 57
      continue;
    }
#line 61
    tmp___25 = sscanf((char const   * __restrict  )(buf), (char const   * __restrict  )"%s %s %s",
                      hostbuf, userbuf, dummy);
#line 61
    switch (tmp___25) {
    case 0: 
#line 64
    packet_send_debug("Found empty line in %.100s.", filename);
#line 65
    continue;
    case 1: 
#line 68
    strlcpy(userbuf, server_user, (int )sizeof(userbuf));
#line 69
    break;
    case 2: 
#line 72
    break;
    case 3: 
#line 74
    packet_send_debug("Found garbage in %.100s.", filename);
#line 75
    continue;
    default: ;
#line 77
    continue;
    }
#line 80
    host = hostbuf;
#line 81
    user = userbuf;
#line 82
    negated = 0;
#line 85
    if ((int )*(host + 0) == 45) {
#line 87
      negated = 1;
#line 88
      host ++;
    } else {
#line 91
      if ((int )*(host + 0) == 43) {
#line 92
        host ++;
      }
    }
#line 94
    if ((int )*(user + 0) == 45) {
#line 96
      negated = 1;
#line 97
      user ++;
    } else {
#line 100
      if ((int )*(user + 0) == 43) {
#line 101
        user ++;
      }
    }
#line 104
    if (! *(host + 0)) {
#line 107
      packet_send_debug("Ignoring wild host/user names in %.100s.", filename);
#line 109
      continue;
    } else {
#line 104
      if (! *(user + 0)) {
#line 107
        packet_send_debug("Ignoring wild host/user names in %.100s.", filename);
#line 109
        continue;
      }
    }
#line 113
    if ((int )*(host + 0) == 64) {
#line 115
      tmp___26 = innetgr((char const   *)(host + 1), hostname, (char const   *)((void *)0),
                         (char const   *)((void *)0));
#line 115
      if (! tmp___26) {
#line 115
        tmp___27 = innetgr((char const   *)(host + 1), ipaddr, (char const   *)((void *)0),
                           (char const   *)((void *)0));
#line 115
        if (! tmp___27) {
#line 117
          continue;
        }
      }
    } else {
#line 120
      tmp___28 = strcasecmp((char const   *)host, hostname);
#line 120
      if (tmp___28) {
#line 120
        if (0) {
#line 120
          __s1_len___1 = strlen((char const   *)host);
#line 120
          __s2_len___1 = strlen(ipaddr);
#line 120
          if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
            goto _L___4;
          } else {
#line 120
            if (__s1_len___1 >= 4U) {
              _L___4: /* CIL Label */ 
#line 120
              if (! ((unsigned int )((void const   *)(ipaddr + 1)) - (unsigned int )((void const   *)ipaddr) == 1U)) {
#line 120
                tmp___38 = 1;
              } else {
#line 120
                if (__s2_len___1 >= 4U) {
#line 120
                  tmp___38 = 1;
                } else {
#line 120
                  tmp___38 = 0;
                }
              }
            } else {
#line 120
              tmp___38 = 0;
            }
          }
#line 120
          if (tmp___38) {
#line 120
            tmp___34 = __builtin_strcmp((char const   *)host, ipaddr);
          } else {
#line 120
            tmp___37 = __builtin_strcmp((char const   *)host, ipaddr);
#line 120
            tmp___34 = tmp___37;
          }
        } else {
#line 120
          tmp___37 = __builtin_strcmp((char const   *)host, ipaddr);
#line 120
          tmp___34 = tmp___37;
        }
#line 120
        if (tmp___34 != 0) {
#line 121
          continue;
        }
      }
    }
#line 124
    if ((int )*(user + 0) == 64) {
#line 126
      tmp___39 = innetgr((char const   *)(user + 1), (char const   *)((void *)0),
                         client_user, (char const   *)((void *)0));
#line 126
      if (! tmp___39) {
#line 127
        continue;
      }
    } else {
#line 130
      if (0) {
#line 130
        __s1_len___2 = strlen((char const   *)user);
#line 130
        __s2_len___2 = strlen(client_user);
#line 130
        if (! ((unsigned int )((void const   *)(user + 1)) - (unsigned int )((void const   *)user) == 1U)) {
          goto _L___6;
        } else {
#line 130
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 130
            if (! ((unsigned int )((void const   *)(client_user + 1)) - (unsigned int )((void const   *)client_user) == 1U)) {
#line 130
              tmp___49 = 1;
            } else {
#line 130
              if (__s2_len___2 >= 4U) {
#line 130
                tmp___49 = 1;
              } else {
#line 130
                tmp___49 = 0;
              }
            }
          } else {
#line 130
            tmp___49 = 0;
          }
        }
#line 130
        if (tmp___49) {
#line 130
          tmp___45 = __builtin_strcmp((char const   *)user, client_user);
        } else {
#line 130
          tmp___48 = __builtin_strcmp((char const   *)user, client_user);
#line 130
          tmp___45 = tmp___48;
        }
      } else {
#line 130
        tmp___48 = __builtin_strcmp((char const   *)user, client_user);
#line 130
        tmp___45 = tmp___48;
      }
#line 130
      if (tmp___45 != 0) {
#line 131
        continue;
      }
    }
#line 134
    fclose(f);
#line 137
    if (negated) {
#line 139
      packet_send_debug("Matched negative entry in %.100s.", filename);
#line 141
      return (0);
    }
#line 145
    return (1);
  }
#line 149
  fclose(f);
#line 150
  return (0);
}
}
#line 165 "auth-rhosts.c"
static char const   *rhosts_files[3]  = {      ".shosts",      ".rhosts",      (char const   *)((void *)0)};
#line 158 "auth-rhosts.c"
int auth_rhosts(struct passwd *pw , char const   *client_user , int ignore_rhosts ,
                int strict_modes ) 
{ char buf[1024] ;
  char const   *hostname ;
  char const   *ipaddr ;
  int port ;
  struct stat st ;
  unsigned int rhosts_file_index ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 171
  temporarily_use_uid(pw->pw_uid);
#line 172
  rhosts_file_index = 0U;
#line 172
  while (rhosts_files[rhosts_file_index]) {
#line 176
    snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%.500s/%.100s",
             pw->pw_dir, rhosts_files[rhosts_file_index]);
#line 178
    tmp = stat((char const   * __restrict  )(buf), (struct stat * __restrict  )(& st));
#line 178
    if (tmp >= 0) {
#line 179
      break;
    }
#line 172
    rhosts_file_index ++;
  }
#line 182
  restore_uid();
#line 184
  if (! rhosts_files[rhosts_file_index]) {
#line 184
    tmp___0 = stat((char const   * __restrict  )"/etc/hosts.equiv", (struct stat * __restrict  )(& st));
#line 184
    if (tmp___0 < 0) {
#line 184
      tmp___1 = stat((char const   * __restrict  )"/usr/local/etc/shosts.equiv", (struct stat * __restrict  )(& st));
#line 184
      if (tmp___1 < 0) {
#line 186
        return (0);
      }
    }
  }
#line 190
  hostname = get_canonical_hostname();
#line 191
  ipaddr = get_remote_ipaddr();
#line 192
  port = get_remote_port();
#line 199
  if (port >= 1024) {
#line 202
    log("Connection from %.100s from nonpriviledged port %d", hostname, port);
#line 204
    packet_send_debug("Your ssh client is not running as root.");
#line 205
    return (0);
  } else {
#line 199
    if (port < 512) {
#line 202
      log("Connection from %.100s from nonpriviledged port %d", hostname, port);
#line 204
      packet_send_debug("Your ssh client is not running as root.");
#line 205
      return (0);
    }
  }
#line 209
  if (pw->pw_uid != 0U) {
#line 211
    tmp___2 = check_rhosts_file("/etc/hosts.equiv", hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 211
    if (tmp___2) {
#line 214
      packet_send_debug("Accepted for %.100s [%.100s] by /etc/hosts.equiv.", hostname,
                        ipaddr);
#line 216
      return (1);
    }
#line 218
    tmp___3 = check_rhosts_file("/usr/local/etc/shosts.equiv", hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 218
    if (tmp___3) {
#line 221
      packet_send_debug("Accepted for %.100s [%.100s] by %.100s.", hostname, ipaddr,
                        "/usr/local/etc/shosts.equiv");
#line 223
      return (1);
    }
  }
#line 229
  tmp___4 = stat((char const   * __restrict  )pw->pw_dir, (struct stat * __restrict  )(& st));
#line 229
  if (tmp___4 < 0) {
#line 231
    log("Rhosts authentication refused for %.100: no home directory %.200s", pw->pw_name,
        pw->pw_dir);
#line 233
    packet_send_debug("Rhosts authentication refused for %.100: no home directory %.200s",
                      pw->pw_name, pw->pw_dir);
#line 235
    return (0);
  }
#line 237
  if (strict_modes) {
#line 237
    if (st.st_uid != 0U) {
#line 237
      if (st.st_uid != pw->pw_uid) {
#line 241
        log("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
            pw->pw_name);
#line 243
        packet_send_debug("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                          pw->pw_name);
#line 245
        return (0);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 237
      if ((st.st_mode & 18U) != 0U) {
#line 241
        log("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
            pw->pw_name);
#line 243
        packet_send_debug("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                          pw->pw_name);
#line 245
        return (0);
      }
    }
  }
#line 250
  temporarily_use_uid(pw->pw_uid);
#line 251
  rhosts_file_index = 0U;
#line 251
  while (rhosts_files[rhosts_file_index]) {
#line 255
    snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%.500s/%.100s",
             pw->pw_dir, rhosts_files[rhosts_file_index]);
#line 257
    tmp___5 = stat((char const   * __restrict  )(buf), (struct stat * __restrict  )(& st));
#line 257
    if (tmp___5 < 0) {
      goto __Cont;
    }
#line 264
    if (strict_modes) {
#line 264
      if (st.st_uid != 0U) {
#line 264
        if (st.st_uid != pw->pw_uid) {
#line 268
          log("Rhosts authentication refused for %.100s: bad modes for %.200s", pw->pw_name,
              buf);
#line 270
          packet_send_debug("Bad file modes for %.200s", buf);
          goto __Cont;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 264
        if ((st.st_mode & 18U) != 0U) {
#line 268
          log("Rhosts authentication refused for %.100s: bad modes for %.200s", pw->pw_name,
              buf);
#line 270
          packet_send_debug("Bad file modes for %.200s", buf);
          goto __Cont;
        }
      }
    }
#line 276
    if (ignore_rhosts) {
#line 278
      packet_send_debug("Server has been configured to ignore %.100s.", rhosts_files[rhosts_file_index]);
      goto __Cont;
    }
#line 284
    tmp___6 = check_rhosts_file((char const   *)(buf), hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 284
    if (tmp___6) {
#line 286
      packet_send_debug("Accepted by %.100s.", rhosts_files[rhosts_file_index]);
#line 289
      restore_uid();
#line 290
      return (1);
    }
    __Cont: /* CIL Label */ 
#line 251
    rhosts_file_index ++;
  }
#line 296
  restore_uid();
#line 297
  return (0);
}
}
#line 1 "auth-passwd.o"
#line 202 "auth-passwd.c"
extern int ( /* missing proto */  crypt)() ;
#line 40 "auth-passwd.c"
int auth_password(struct passwd *pw , char const   *password ) 
{ char *encrypted_password ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  char const   *tmp___19 ;
  int tmp___20 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___26 ;
  int tmp___29 ;
  int tmp___30 ;

  {
#line 45
  if (pw->pw_uid == 0U) {
#line 45
    if (options.permit_root_login == 2) {
#line 48
      return (0);
    }
  }
#line 51
  if ((int const   )*password == 0) {
#line 51
    if (options.permit_empty_passwd == 0) {
#line 54
      return (0);
    }
  }
#line 58
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 59
    return (0);
  }
#line 195
  if (0) {
#line 195
    __s1_len = strlen(password);
#line 195
    __s2_len = strlen("");
#line 195
    if (! ((unsigned int )((void const   *)(password + 1)) - (unsigned int )((void const   *)password) == 1U)) {
      goto _L___0;
    } else {
#line 195
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 195
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 195
          tmp___8 = 1;
        } else {
#line 195
          if (__s2_len >= 4U) {
#line 195
            tmp___8 = 1;
          } else {
#line 195
            tmp___8 = 0;
          }
        }
      } else {
#line 195
        tmp___8 = 0;
      }
    }
#line 195
    if (tmp___8) {
#line 195
      tmp___4 = __builtin_strcmp(password, "");
    } else {
#line 195
      tmp___7 = __builtin_strcmp(password, "");
#line 195
      tmp___4 = tmp___7;
    }
  } else {
#line 195
    tmp___7 = __builtin_strcmp(password, "");
#line 195
    tmp___4 = tmp___7;
  }
#line 195
  if (tmp___4 == 0) {
#line 195
    if (0) {
#line 195
      __s1_len___0 = strlen((char const   *)pw->pw_passwd);
#line 195
      __s2_len___0 = strlen("");
#line 195
      if (! ((unsigned int )((void const   *)(pw->pw_passwd + 1)) - (unsigned int )((void const   *)pw->pw_passwd) == 1U)) {
        goto _L___2;
      } else {
#line 195
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 195
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 195
            tmp___18 = 1;
          } else {
#line 195
            if (__s2_len___0 >= 4U) {
#line 195
              tmp___18 = 1;
            } else {
#line 195
              tmp___18 = 0;
            }
          }
        } else {
#line 195
          tmp___18 = 0;
        }
      }
#line 195
      if (tmp___18) {
#line 195
        tmp___14 = __builtin_strcmp((char const   *)pw->pw_passwd, "");
      } else {
#line 195
        tmp___17 = __builtin_strcmp((char const   *)pw->pw_passwd, "");
#line 195
        tmp___14 = tmp___17;
      }
    } else {
#line 195
      tmp___17 = __builtin_strcmp((char const   *)pw->pw_passwd, "");
#line 195
      tmp___14 = tmp___17;
    }
#line 195
    if (tmp___14 == 0) {
#line 197
      packet_send_debug("Login permitted without a password because the account has no password.");
#line 198
      return (1);
    }
  }
#line 202
  if (*(pw->pw_passwd + 0)) {
#line 202
    if (*(pw->pw_passwd + 1)) {
#line 202
      tmp___19 = (char const   *)pw->pw_passwd;
    } else {
#line 202
      tmp___19 = "xx";
    }
  } else {
#line 202
    tmp___19 = "xx";
  }
#line 202
  tmp___20 = crypt(password, tmp___19);
#line 202
  encrypted_password = (char *)tmp___20;
#line 207
  if (0) {
#line 207
    __s1_len___1 = strlen((char const   *)encrypted_password);
#line 207
    __s2_len___1 = strlen((char const   *)pw->pw_passwd);
#line 207
    if (! ((unsigned int )((void const   *)(encrypted_password + 1)) - (unsigned int )((void const   *)encrypted_password) == 1U)) {
      goto _L___4;
    } else {
#line 207
      if (__s1_len___1 >= 4U) {
        _L___4: /* CIL Label */ 
#line 207
        if (! ((unsigned int )((void const   *)(pw->pw_passwd + 1)) - (unsigned int )((void const   *)pw->pw_passwd) == 1U)) {
#line 207
          tmp___30 = 1;
        } else {
#line 207
          if (__s2_len___1 >= 4U) {
#line 207
            tmp___30 = 1;
          } else {
#line 207
            tmp___30 = 0;
          }
        }
      } else {
#line 207
        tmp___30 = 0;
      }
    }
#line 207
    if (tmp___30) {
#line 207
      tmp___26 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)pw->pw_passwd);
    } else {
#line 207
      tmp___29 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)pw->pw_passwd);
#line 207
      tmp___26 = tmp___29;
    }
  } else {
#line 207
    tmp___29 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)pw->pw_passwd);
#line 207
    tmp___26 = tmp___29;
  }
#line 207
  return (tmp___26 == 0);
}
}
#line 1 "auth-rsa.o"
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 212
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 401 "/usr/include/openssl/bn.h"
extern int BN_rand(BIGNUM *rnd , int bits , int top , int bottom ) ;
#line 325 "ssh.h"
int auth_rsa_challenge_dialog(unsigned int bits , BIGNUM *e , BIGNUM *n___0 ) ;
#line 56 "auth-rsa.c"
int auth_rsa_challenge_dialog(unsigned int bits , BIGNUM *e , BIGNUM *n___0 ) 
{ BIGNUM *challenge ;
  BIGNUM *encrypted_challenge ;
  BIGNUM *aux ;
  RSA *pk ;
  BN_CTX *ctx ;
  BN_CTX *tmp ;
  unsigned char buf[32] ;
  unsigned char mdbuf[16] ;
  unsigned char response[16] ;
  MD5_CTX md ;
  unsigned int i ;
  int plen ;
  int len ;
  int tmp___0 ;
  int _p ;
  int _e ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
#line 61
  tmp = BN_CTX_new();
#line 61
  ctx = tmp;
#line 67
  encrypted_challenge = BN_new();
#line 68
  challenge = BN_new();
#line 69
  aux = BN_new();
#line 72
  BN_rand(challenge, 256, 0, 0);
#line 73
  BN_div((BIGNUM *)((void *)0), challenge, (BIGNUM const   *)challenge, (BIGNUM const   *)n___0,
         ctx);
#line 76
  pk = RSA_new();
#line 77
  pk->e = BN_new();
#line 78
  BN_copy(pk->e, (BIGNUM const   *)e);
#line 79
  pk->n = BN_new();
#line 80
  BN_copy(pk->n, (BIGNUM const   *)n___0);
#line 83
  rsa_public_encrypt(encrypted_challenge, challenge, pk);
#line 84
  RSA_free(pk);
#line 87
  packet_start(7);
#line 88
  packet_put_bignum(encrypted_challenge);
#line 89
  packet_send();
#line 90
  packet_write_wait();
#line 93
  tmp___0 = BN_num_bits((BIGNUM const   *)challenge);
#line 93
  len = (tmp___0 + 7) / 8;
#line 94
  if (len <= 32) {
#line 94
    if (! len) {
#line 94
      __assert_fail("len <= 32 && len", "auth-rsa.c", 94U, "auth_rsa_challenge_dialog");
    }
  } else {
#line 94
    __assert_fail("len <= 32 && len", "auth-rsa.c", 94U, "auth_rsa_challenge_dialog");
  }
#line 95
  memset((void *)(buf), 0, 32U);
#line 96
  BN_bn2bin((BIGNUM const   *)challenge, (buf + 32) - len);
#line 97
  MD5_Init(& md);
#line 98
  MD5_Update(& md, (void const   *)(buf), 32U);
#line 99
  MD5_Update(& md, (void const   *)(session_id), 16U);
#line 100
  MD5_Final(mdbuf, & md);
#line 103
  BN_clear_free(encrypted_challenge);
#line 104
  BN_clear_free(challenge);
#line 105
  BN_clear_free(aux);
#line 106
  BN_CTX_free(ctx);
#line 109
  packet_read_expect(& plen, 8);
#line 110
  while (1) {
#line 110
    _p = plen;
#line 110
    _e = 16;
#line 110
    if (_p != _e) {
#line 110
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "auth-rsa.c", 110);
#line 110
      packet_disconnect("Packet integrity error. (%d)", 8);
    }
#line 110
    break;
  }
#line 111
  i = 0U;
#line 111
  while (i < 16U) {
#line 112
    tmp___1 = packet_get_char();
#line 112
    response[i] = (unsigned char )tmp___1;
#line 111
    i ++;
  }
#line 115
  tmp___2 = memcmp((void const   *)(response), (void const   *)(mdbuf), 16U);
#line 115
  if (tmp___2 != 0) {
#line 118
    return (0);
  }
#line 122
  return (1);
}
}
#line 179 "auth-rsa.c"
static char const   *check[3]  = {      "",      ".ssh",      (char const   *)((void *)0)};
#line 129 "auth-rsa.c"
int auth_rsa(struct passwd *pw , BIGNUM *client_n , int strict_modes ) 
{ char line[8192] ;
  int authenticated ;
  unsigned int bits ;
  FILE *f ;
  unsigned long linenum ;
  struct stat st ;
  BIGNUM *e ;
  BIGNUM *n___0 ;
  int tmp ;
  int fail ;
  char buf[1024] ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *cp ;
  char *options___0 ;
  int quoted ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___24 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___30 ;
  int tmp___33 ;
  int tmp___34 ;
  size_t tmp___35 ;
  size_t tmp___41 ;
  int tmp___59 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___65 ;
  int tmp___68 ;
  int tmp___69 ;
  size_t tmp___70 ;
  size_t tmp___76 ;
  int tmp___94 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___100 ;
  int tmp___103 ;
  int tmp___104 ;
  size_t tmp___105 ;
  size_t tmp___111 ;
  int tmp___129 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___135 ;
  int tmp___138 ;
  int tmp___139 ;
  size_t tmp___140 ;
  int i___0 ;
  size_t tmp___146 ;
  size_t tmp___147 ;
  void *tmp___148 ;
  int tmp___149 ;
  int tmp___150 ;
  char *tmp___151 ;
  int tmp___169 ;
  size_t __s1_len___8 ;
  size_t __s2_len___8 ;
  int tmp___175 ;
  int tmp___178 ;
  int tmp___179 ;
  size_t tmp___180 ;
  int i___1 ;
  char *s ;
  struct envstring *new_envstring ;
  size_t tmp___186 ;
  size_t tmp___187 ;
  void *tmp___188 ;
  int tmp___189 ;
  int tmp___190 ;
  char *tmp___191 ;
  void *tmp___192 ;
  int tmp___210 ;
  size_t __s1_len___10 ;
  size_t __s2_len___10 ;
  int tmp___216 ;
  int tmp___219 ;
  int tmp___220 ;
  size_t tmp___221 ;
  char *patterns ;
  size_t tmp___227 ;
  void *tmp___228 ;
  int i___2 ;
  size_t tmp___229 ;
  int tmp___230 ;
  int tmp___231 ;
  char *tmp___232 ;
  char const   *tmp___233 ;
  char const   *tmp___234 ;
  char const   *tmp___235 ;
  size_t tmp___236 ;
  char const   *tmp___237 ;
  int tmp___238 ;
  size_t tmp___239 ;
  char const   *tmp___240 ;
  int tmp___241 ;
  int tmp___259 ;
  size_t __s1_len___12 ;
  size_t __s2_len___12 ;
  int tmp___265 ;
  int tmp___268 ;
  int tmp___269 ;
  size_t tmp___270 ;
  char *tmp___276 ;

  {
#line 136
  linenum = 0UL;
#line 141
  temporarily_use_uid(pw->pw_uid);
#line 144
  snprintf((char * __restrict  )(line), sizeof(line), (char const   * __restrict  )"%.500s/%.100s",
           pw->pw_dir, ".ssh/authorized_keys");
#line 148
  tmp = stat((char const   * __restrict  )(line), (struct stat * __restrict  )(& st));
#line 148
  if (tmp < 0) {
#line 151
    restore_uid();
#line 152
    return (0);
  }
#line 156
  f = fopen((char const   * __restrict  )(line), (char const   * __restrict  )"r");
#line 157
  if (! f) {
#line 160
    restore_uid();
#line 161
    packet_send_debug("Could not open %.900s for reading.", line);
#line 162
    packet_send_debug("If your home is on an NFS volume, it may need to be world-readable.");
#line 163
    return (0);
  }
#line 166
  if (strict_modes) {
#line 167
    fail = 0;
#line 170
    tmp___1 = fileno(f);
#line 170
    tmp___2 = fstat(tmp___1, & st);
#line 170
    if (tmp___2 < 0) {
#line 173
      snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
               pw->pw_name, line);
#line 175
      fail = 1;
    } else {
#line 170
      if (st.st_uid != 0U) {
#line 170
        if (st.st_uid != pw->pw_uid) {
#line 173
          snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   pw->pw_name, line);
#line 175
          fail = 1;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 170
        if ((st.st_mode & 18U) != 0U) {
#line 173
          snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   pw->pw_name, line);
#line 175
          fail = 1;
        } else {
#line 182
          i = 0;
#line 182
          while (check[i]) {
#line 183
            snprintf((char * __restrict  )(line), sizeof(line), (char const   * __restrict  )"%.500s/%.100s",
                     pw->pw_dir, check[i]);
#line 184
            tmp___0 = stat((char const   * __restrict  )(line), (struct stat * __restrict  )(& st));
#line 184
            if (tmp___0 < 0) {
#line 187
              snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                       pw->pw_name, line);
#line 189
              fail = 1;
#line 190
              break;
            } else {
#line 184
              if (st.st_uid != 0U) {
#line 184
                if (st.st_uid != pw->pw_uid) {
#line 187
                  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           pw->pw_name, line);
#line 189
                  fail = 1;
#line 190
                  break;
                } else {
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
#line 184
                if ((st.st_mode & 18U) != 0U) {
#line 187
                  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           pw->pw_name, line);
#line 189
                  fail = 1;
#line 190
                  break;
                }
              }
            }
#line 182
            i ++;
          }
        }
      }
    }
#line 194
    if (fail) {
#line 195
      log((char const   *)(buf));
#line 196
      packet_send_debug((char const   *)(buf));
#line 197
      restore_uid();
#line 198
      return (0);
    }
  }
#line 203
  authenticated = 0;
#line 206
  e = BN_new();
#line 207
  n___0 = BN_new();
#line 212
  while (1) {
#line 212
    tmp___276 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 212
    if (! tmp___276) {
#line 212
      break;
    }
#line 217
    linenum ++;
#line 220
    cp = line;
#line 220
    while (1) {
#line 220
      if (! ((int )*cp == 32)) {
#line 220
        if (! ((int )*cp == 9)) {
#line 220
          break;
        }
      }
#line 220
      cp ++;
    }
#line 224
    if (! *cp) {
#line 225
      continue;
    } else {
#line 224
      if ((int )*cp == 10) {
#line 225
        continue;
      } else {
#line 224
        if ((int )*cp == 35) {
#line 225
          continue;
        }
      }
    }
#line 230
    if ((int )*cp < 48) {
      goto _L___2;
    } else {
#line 230
      if ((int )*cp > 57) {
        _L___2: /* CIL Label */ 
#line 232
        quoted = 0;
#line 233
        options___0 = cp;
#line 234
        while (1) {
#line 234
          if (*cp) {
#line 234
            if (! quoted) {
#line 234
              if ((int )*cp != 32) {
#line 234
                if (! ((int )*cp != 9)) {
#line 234
                  break;
                }
              } else {
#line 234
                break;
              }
            }
          } else {
#line 234
            break;
          }
#line 236
          if ((int )*cp == 92) {
#line 236
            if ((int )*(cp + 1) == 34) {
#line 237
              cp ++;
            } else {
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
#line 239
            if ((int )*cp == 34) {
#line 240
              quoted = ! quoted;
            }
          }
#line 234
          cp ++;
        }
      } else {
#line 244
        options___0 = (char *)((void *)0);
      }
    }
#line 247
    tmp___3 = auth_rsa_read_key(& cp, & bits, e, n___0);
#line 247
    if (! tmp___3) {
#line 249
      debug("%.100s, line %lu: bad key syntax", ".ssh/authorized_keys", linenum);
#line 251
      packet_send_debug("%.100s, line %lu: bad key syntax", ".ssh/authorized_keys",
                        linenum);
#line 253
      continue;
    }
#line 259
    tmp___4 = BN_cmp((BIGNUM const   *)n___0, (BIGNUM const   *)client_n);
#line 259
    if (tmp___4 != 0) {
#line 260
      continue;
    }
#line 265
    tmp___5 = auth_rsa_challenge_dialog(bits, e, n___0);
#line 265
    if (! tmp___5) {
#line 268
      log("Wrong response to RSA authentication challenge.");
#line 269
      packet_send_debug("Wrong response to RSA authentication challenge.");
#line 270
      continue;
    }
#line 276
    authenticated = 1;
#line 279
    if (options___0) {
#line 281
      while (1) {
#line 281
        if (*options___0) {
#line 281
          if ((int )*options___0 != 32) {
#line 281
            if (! ((int )*options___0 != 9)) {
#line 281
              break;
            }
          } else {
#line 281
            break;
          }
        } else {
#line 281
          break;
        }
#line 283
        cp = (char *)"no-port-forwarding";
#line 284
        if (0) {
#line 284
          if (0) {
#line 284
            __s1_len___0 = strlen((char const   *)options___0);
#line 284
            __s2_len___0 = strlen((char const   *)cp);
#line 284
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___6;
            } else {
#line 284
              if (__s1_len___0 >= 4U) {
                _L___6: /* CIL Label */ 
#line 284
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 284
                  tmp___34 = 1;
                } else {
#line 284
                  if (__s2_len___0 >= 4U) {
#line 284
                    tmp___34 = 1;
                  } else {
#line 284
                    tmp___34 = 0;
                  }
                }
              } else {
#line 284
                tmp___34 = 0;
              }
            }
#line 284
            if (tmp___34) {
#line 284
              tmp___30 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 284
              tmp___33 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 284
              tmp___30 = tmp___33;
            }
          } else {
#line 284
            tmp___33 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 284
            tmp___30 = tmp___33;
          }
#line 284
          tmp___24 = tmp___30;
        } else {
#line 284
          tmp___35 = strlen((char const   *)cp);
#line 284
          tmp___24 = strncmp((char const   *)options___0, (char const   *)cp, tmp___35);
        }
#line 284
        if (tmp___24 == 0) {
#line 286
          packet_send_debug("Port forwarding disabled.");
#line 287
          no_port_forwarding_flag = 1;
#line 288
          tmp___6 = strlen((char const   *)cp);
#line 288
          options___0 += tmp___6;
          goto next_option;
        }
#line 291
        cp = (char *)"no-agent-forwarding";
#line 292
        if (0) {
#line 292
          if (0) {
#line 292
            __s1_len___2 = strlen((char const   *)options___0);
#line 292
            __s2_len___2 = strlen((char const   *)cp);
#line 292
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___10;
            } else {
#line 292
              if (__s1_len___2 >= 4U) {
                _L___10: /* CIL Label */ 
#line 292
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 292
                  tmp___69 = 1;
                } else {
#line 292
                  if (__s2_len___2 >= 4U) {
#line 292
                    tmp___69 = 1;
                  } else {
#line 292
                    tmp___69 = 0;
                  }
                }
              } else {
#line 292
                tmp___69 = 0;
              }
            }
#line 292
            if (tmp___69) {
#line 292
              tmp___65 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 292
              tmp___68 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 292
              tmp___65 = tmp___68;
            }
          } else {
#line 292
            tmp___68 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 292
            tmp___65 = tmp___68;
          }
#line 292
          tmp___59 = tmp___65;
        } else {
#line 292
          tmp___70 = strlen((char const   *)cp);
#line 292
          tmp___59 = strncmp((char const   *)options___0, (char const   *)cp, tmp___70);
        }
#line 292
        if (tmp___59 == 0) {
#line 294
          packet_send_debug("Agent forwarding disabled.");
#line 295
          no_agent_forwarding_flag = 1;
#line 296
          tmp___41 = strlen((char const   *)cp);
#line 296
          options___0 += tmp___41;
          goto next_option;
        }
#line 299
        cp = (char *)"no-X11-forwarding";
#line 300
        if (0) {
#line 300
          if (0) {
#line 300
            __s1_len___4 = strlen((char const   *)options___0);
#line 300
            __s2_len___4 = strlen((char const   *)cp);
#line 300
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___14;
            } else {
#line 300
              if (__s1_len___4 >= 4U) {
                _L___14: /* CIL Label */ 
#line 300
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 300
                  tmp___104 = 1;
                } else {
#line 300
                  if (__s2_len___4 >= 4U) {
#line 300
                    tmp___104 = 1;
                  } else {
#line 300
                    tmp___104 = 0;
                  }
                }
              } else {
#line 300
                tmp___104 = 0;
              }
            }
#line 300
            if (tmp___104) {
#line 300
              tmp___100 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 300
              tmp___103 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 300
              tmp___100 = tmp___103;
            }
          } else {
#line 300
            tmp___103 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 300
            tmp___100 = tmp___103;
          }
#line 300
          tmp___94 = tmp___100;
        } else {
#line 300
          tmp___105 = strlen((char const   *)cp);
#line 300
          tmp___94 = strncmp((char const   *)options___0, (char const   *)cp, tmp___105);
        }
#line 300
        if (tmp___94 == 0) {
#line 302
          packet_send_debug("X11 forwarding disabled.");
#line 303
          no_x11_forwarding_flag = 1;
#line 304
          tmp___76 = strlen((char const   *)cp);
#line 304
          options___0 += tmp___76;
          goto next_option;
        }
#line 307
        cp = (char *)"no-pty";
#line 308
        if (0) {
#line 308
          if (0) {
#line 308
            __s1_len___6 = strlen((char const   *)options___0);
#line 308
            __s2_len___6 = strlen((char const   *)cp);
#line 308
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___18;
            } else {
#line 308
              if (__s1_len___6 >= 4U) {
                _L___18: /* CIL Label */ 
#line 308
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 308
                  tmp___139 = 1;
                } else {
#line 308
                  if (__s2_len___6 >= 4U) {
#line 308
                    tmp___139 = 1;
                  } else {
#line 308
                    tmp___139 = 0;
                  }
                }
              } else {
#line 308
                tmp___139 = 0;
              }
            }
#line 308
            if (tmp___139) {
#line 308
              tmp___135 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 308
              tmp___138 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 308
              tmp___135 = tmp___138;
            }
          } else {
#line 308
            tmp___138 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 308
            tmp___135 = tmp___138;
          }
#line 308
          tmp___129 = tmp___135;
        } else {
#line 308
          tmp___140 = strlen((char const   *)cp);
#line 308
          tmp___129 = strncmp((char const   *)options___0, (char const   *)cp, tmp___140);
        }
#line 308
        if (tmp___129 == 0) {
#line 310
          packet_send_debug("Pty allocation disabled.");
#line 311
          no_pty_flag = 1;
#line 312
          tmp___111 = strlen((char const   *)cp);
#line 312
          options___0 += tmp___111;
          goto next_option;
        }
#line 315
        cp = (char *)"command=\"";
#line 316
        if (0) {
#line 316
          if (0) {
#line 316
            __s1_len___8 = strlen((char const   *)options___0);
#line 316
            __s2_len___8 = strlen((char const   *)cp);
#line 316
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___22;
            } else {
#line 316
              if (__s1_len___8 >= 4U) {
                _L___22: /* CIL Label */ 
#line 316
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 316
                  tmp___179 = 1;
                } else {
#line 316
                  if (__s2_len___8 >= 4U) {
#line 316
                    tmp___179 = 1;
                  } else {
#line 316
                    tmp___179 = 0;
                  }
                }
              } else {
#line 316
                tmp___179 = 0;
              }
            }
#line 316
            if (tmp___179) {
#line 316
              tmp___175 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 316
              tmp___178 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 316
              tmp___175 = tmp___178;
            }
          } else {
#line 316
            tmp___178 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 316
            tmp___175 = tmp___178;
          }
#line 316
          tmp___169 = tmp___175;
        } else {
#line 316
          tmp___180 = strlen((char const   *)cp);
#line 316
          tmp___169 = strncmp((char const   *)options___0, (char const   *)cp, tmp___180);
        }
#line 316
        if (tmp___169 == 0) {
#line 319
          tmp___146 = strlen((char const   *)cp);
#line 319
          options___0 += tmp___146;
#line 320
          tmp___147 = strlen((char const   *)options___0);
#line 320
          tmp___148 = xmalloc(tmp___147 + 1U);
#line 320
          forced_command = (char *)tmp___148;
#line 321
          i___0 = 0;
#line 322
          while (*options___0) {
#line 324
            if ((int )*options___0 == 34) {
#line 325
              break;
            }
#line 326
            if ((int )*options___0 == 92) {
#line 326
              if ((int )*(options___0 + 1) == 34) {
#line 328
                options___0 += 2;
#line 329
                tmp___149 = i___0;
#line 329
                i___0 ++;
#line 329
                *(forced_command + tmp___149) = (char )'\"';
#line 330
                continue;
              }
            }
#line 332
            tmp___150 = i___0;
#line 332
            i___0 ++;
#line 332
            tmp___151 = options___0;
#line 332
            options___0 ++;
#line 332
            *(forced_command + tmp___150) = *tmp___151;
          }
#line 334
          if (! *options___0) {
#line 336
            debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys", linenum);
#line 338
            packet_send_debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys",
                              linenum);
#line 340
            continue;
          }
#line 342
          *(forced_command + i___0) = (char)0;
#line 343
          packet_send_debug("Forced command: %.900s", forced_command);
#line 344
          options___0 ++;
          goto next_option;
        }
#line 347
        cp = (char *)"environment=\"";
#line 348
        if (0) {
#line 348
          if (0) {
#line 348
            __s1_len___10 = strlen((char const   *)options___0);
#line 348
            __s2_len___10 = strlen((char const   *)cp);
#line 348
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___26;
            } else {
#line 348
              if (__s1_len___10 >= 4U) {
                _L___26: /* CIL Label */ 
#line 348
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 348
                  tmp___220 = 1;
                } else {
#line 348
                  if (__s2_len___10 >= 4U) {
#line 348
                    tmp___220 = 1;
                  } else {
#line 348
                    tmp___220 = 0;
                  }
                }
              } else {
#line 348
                tmp___220 = 0;
              }
            }
#line 348
            if (tmp___220) {
#line 348
              tmp___216 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 348
              tmp___219 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 348
              tmp___216 = tmp___219;
            }
          } else {
#line 348
            tmp___219 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 348
            tmp___216 = tmp___219;
          }
#line 348
          tmp___210 = tmp___216;
        } else {
#line 348
          tmp___221 = strlen((char const   *)cp);
#line 348
          tmp___210 = strncmp((char const   *)options___0, (char const   *)cp, tmp___221);
        }
#line 348
        if (tmp___210 == 0) {
#line 353
          tmp___186 = strlen((char const   *)cp);
#line 353
          options___0 += tmp___186;
#line 354
          tmp___187 = strlen((char const   *)options___0);
#line 354
          tmp___188 = xmalloc(tmp___187 + 1U);
#line 354
          s = (char *)tmp___188;
#line 355
          i___1 = 0;
#line 356
          while (*options___0) {
#line 358
            if ((int )*options___0 == 34) {
#line 359
              break;
            }
#line 360
            if ((int )*options___0 == 92) {
#line 360
              if ((int )*(options___0 + 1) == 34) {
#line 362
                options___0 += 2;
#line 363
                tmp___189 = i___1;
#line 363
                i___1 ++;
#line 363
                *(s + tmp___189) = (char )'\"';
#line 364
                continue;
              }
            }
#line 366
            tmp___190 = i___1;
#line 366
            i___1 ++;
#line 366
            tmp___191 = options___0;
#line 366
            options___0 ++;
#line 366
            *(s + tmp___190) = *tmp___191;
          }
#line 368
          if (! *options___0) {
#line 370
            debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys", linenum);
#line 372
            packet_send_debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys",
                              linenum);
#line 374
            continue;
          }
#line 376
          *(s + i___1) = (char)0;
#line 377
          packet_send_debug("Adding to environment: %.900s", s);
#line 378
          debug("Adding to environment: %.900s", s);
#line 379
          options___0 ++;
#line 380
          tmp___192 = xmalloc(sizeof(struct envstring ));
#line 380
          new_envstring = (struct envstring *)tmp___192;
#line 381
          new_envstring->s = s;
#line 382
          new_envstring->next = custom_environment;
#line 383
          custom_environment = new_envstring;
          goto next_option;
        }
#line 386
        cp = (char *)"from=\"";
#line 387
        if (0) {
#line 387
          if (0) {
#line 387
            __s1_len___12 = strlen((char const   *)options___0);
#line 387
            __s2_len___12 = strlen((char const   *)cp);
#line 387
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___30;
            } else {
#line 387
              if (__s1_len___12 >= 4U) {
                _L___30: /* CIL Label */ 
#line 387
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 387
                  tmp___269 = 1;
                } else {
#line 387
                  if (__s2_len___12 >= 4U) {
#line 387
                    tmp___269 = 1;
                  } else {
#line 387
                    tmp___269 = 0;
                  }
                }
              } else {
#line 387
                tmp___269 = 0;
              }
            }
#line 387
            if (tmp___269) {
#line 387
              tmp___265 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 387
              tmp___268 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 387
              tmp___265 = tmp___268;
            }
          } else {
#line 387
            tmp___268 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 387
            tmp___265 = tmp___268;
          }
#line 387
          tmp___259 = tmp___265;
        } else {
#line 387
          tmp___270 = strlen((char const   *)cp);
#line 387
          tmp___259 = strncmp((char const   *)options___0, (char const   *)cp, tmp___270);
        }
#line 387
        if (tmp___259 == 0) {
#line 389
          tmp___227 = strlen((char const   *)options___0);
#line 389
          tmp___228 = xmalloc(tmp___227 + 1U);
#line 389
          patterns = (char *)tmp___228;
#line 391
          tmp___229 = strlen((char const   *)cp);
#line 391
          options___0 += tmp___229;
#line 392
          i___2 = 0;
#line 393
          while (*options___0) {
#line 395
            if ((int )*options___0 == 34) {
#line 396
              break;
            }
#line 397
            if ((int )*options___0 == 92) {
#line 397
              if ((int )*(options___0 + 1) == 34) {
#line 399
                options___0 += 2;
#line 400
                tmp___230 = i___2;
#line 400
                i___2 ++;
#line 400
                *(patterns + tmp___230) = (char )'\"';
#line 401
                continue;
              }
            }
#line 403
            tmp___231 = i___2;
#line 403
            i___2 ++;
#line 403
            tmp___232 = options___0;
#line 403
            options___0 ++;
#line 403
            *(patterns + tmp___231) = *tmp___232;
          }
#line 405
          if (! *options___0) {
#line 407
            debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys", linenum);
#line 409
            packet_send_debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys",
                              linenum);
#line 411
            continue;
          }
#line 413
          *(patterns + i___2) = (char)0;
#line 414
          options___0 ++;
#line 415
          tmp___236 = strlen((char const   *)patterns);
#line 415
          tmp___237 = get_canonical_hostname();
#line 415
          tmp___238 = match_hostname(tmp___237, (char const   *)patterns, tmp___236);
#line 415
          if (! tmp___238) {
#line 415
            tmp___239 = strlen((char const   *)patterns);
#line 415
            tmp___240 = get_remote_ipaddr();
#line 415
            tmp___241 = match_hostname(tmp___240, (char const   *)patterns, tmp___239);
#line 415
            if (! tmp___241) {
#line 420
              tmp___233 = get_remote_ipaddr();
#line 420
              tmp___234 = get_canonical_hostname();
#line 420
              log("RSA authentication tried for %.100s with correct key but not from a permitted host (host=%.200s, ip=%.200s).",
                  pw->pw_name, tmp___234, tmp___233);
#line 423
              tmp___235 = get_canonical_hostname();
#line 423
              packet_send_debug("Your host \'%.200s\' is not permitted to use this key for login.",
                                tmp___235);
#line 425
              xfree((void *)patterns);
#line 426
              authenticated = 0;
#line 427
              break;
            }
          }
#line 429
          xfree((void *)patterns);
          goto next_option;
        }
        bad_option: 
#line 435
        log("Bad options in %.100s file, line %lu: %.50s", ".ssh/authorized_keys",
            linenum, options___0);
#line 437
        packet_send_debug("Bad options in %.100s file, line %lu: %.50s", ".ssh/authorized_keys",
                          linenum, options___0);
#line 439
        authenticated = 0;
#line 440
        break;
        next_option: 
#line 445
        if (! *options___0) {
#line 446
          fatal("Bugs in auth-rsa.c option processing.");
        }
#line 447
        if ((int )*options___0 == 32) {
#line 448
          break;
        } else {
#line 447
          if ((int )*options___0 == 9) {
#line 448
            break;
          }
        }
#line 449
        if ((int )*options___0 != 44) {
          goto bad_option;
        }
#line 451
        options___0 ++;
#line 453
        continue;
      }
    }
#line 459
    if (authenticated) {
#line 460
      break;
    }
  }
#line 464
  restore_uid();
#line 467
  fclose(f);
#line 470
  BN_clear_free(n___0);
#line 471
  BN_clear_free(e);
#line 473
  if (authenticated) {
#line 474
    packet_send_debug("RSA authentication accepted.");
  }
#line 477
  return (authenticated);
}
}
#line 1 "auth-rh-rsa.o"
#line 458 "/usr/include/openssl/bn.h"
extern void BN_free(BIGNUM *a ) ;
#line 29 "auth-rh-rsa.c"
int auth_rhosts_rsa(struct passwd *pw , char const   *client_user , unsigned int client_host_key_bits ,
                    BIGNUM *client_host_key_e , BIGNUM *client_host_key_n , int ignore_rhosts ,
                    int strict_modes ) 
{ char const   *canonical_hostname ;
  HostStatus host_status ;
  BIGNUM *ke ;
  BIGNUM *kn ;
  int tmp ;
  int tmp___0 ;

  {
#line 38
  debug("Trying rhosts with RSA host authentication for %.100s", client_user);
#line 41
  tmp = auth_rhosts(pw, client_user, ignore_rhosts, strict_modes);
#line 41
  if (! tmp) {
#line 42
    return (0);
  }
#line 44
  canonical_hostname = get_canonical_hostname();
#line 46
  debug("Rhosts RSA authentication: canonical host %.900s", canonical_hostname);
#line 51
  ke = BN_new();
#line 52
  kn = BN_new();
#line 53
  host_status = check_host_in_hostfile("/usr/local/etc/ssh_known_hosts", canonical_hostname,
                                       client_host_key_bits, client_host_key_e, client_host_key_n,
                                       ke, kn);
#line 56
  BN_free(ke);
#line 57
  BN_free(kn);
#line 58
  if ((int )host_status != 0) {
#line 60
    debug("Rhosts with RSA host authentication denied: unknown or invalid host key");
#line 61
    packet_send_debug("Your host key cannot be verified: unknown or invalid host key.");
#line 62
    return (0);
  }
#line 68
  tmp___0 = auth_rsa_challenge_dialog(client_host_key_bits, client_host_key_e, client_host_key_n);
#line 68
  if (! tmp___0) {
#line 71
    log("Client on %.800s failed to respond correctly to host authentication.", canonical_hostname);
#line 73
    return (0);
  }
#line 79
  log("Rhosts with RSA host authentication accepted for %.100s, %.100s on %.700s.",
      pw->pw_name, client_user, canonical_hostname);
#line 81
  packet_send_debug("Rhosts with RSA host authentication accepted.");
#line 82
  return (1);
}
}
#line 1 "pty.o"
#line 36 "pty.c"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf ) 
{ char buf[64] ;
  int i ;
  char const   *ptymajors ;
  char const   *ptyminors ;
  int num_minors ;
  size_t tmp ;
  int num_ptys ;
  size_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
#line 158
  ptymajors = "pqrstuvwxyzabcdefghijklmnoABCDEFGHIJKLMNOPQRSTUVWXYZ";
#line 160
  ptyminors = "0123456789abcdef";
#line 161
  tmp = strlen(ptyminors);
#line 161
  num_minors = (int )tmp;
#line 162
  tmp___0 = strlen(ptymajors);
#line 162
  num_ptys = (int )(tmp___0 * (size_t )num_minors);
#line 164
  i = 0;
#line 164
  while (i < num_ptys) {
#line 166
    snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"/dev/pty%c%c",
             *(ptymajors + i / num_minors), *(ptyminors + i % num_minors));
#line 168
    *ptyfd = open((char const   *)(buf), 258);
#line 169
    if (*ptyfd < 0) {
      goto __Cont;
    }
#line 171
    snprintf((char * __restrict  )namebuf, sizeof(buf), (char const   * __restrict  )"/dev/tty%c%c",
             *(ptymajors + i / num_minors), *(ptyminors + i % num_minors));
#line 175
    *ttyfd = open((char const   *)namebuf, 258);
#line 176
    if (*ttyfd < 0) {
#line 178
      tmp___1 = __errno_location();
#line 178
      tmp___2 = strerror(*tmp___1);
#line 178
      error("%.100s: %.100s", namebuf, tmp___2);
#line 179
      close(*ptyfd);
#line 180
      return (0);
    }
#line 182
    return (1);
    __Cont: /* CIL Label */ 
#line 164
    i ++;
  }
#line 184
  return (0);
}
}
#line 194 "pty.c"
void pty_release(char const   *ttyname___0 ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 196
  tmp___1 = chown(ttyname___0, 0U, 0U);
#line 196
  if (tmp___1 < 0) {
#line 197
    tmp = __errno_location();
#line 197
    tmp___0 = strerror(*tmp);
#line 197
    debug("chown %.100s 0 0 failed: %.100s", ttyname___0, tmp___0);
  }
#line 198
  tmp___4 = chmod(ttyname___0, 438U);
#line 198
  if (tmp___4 < 0) {
#line 199
    tmp___2 = __errno_location();
#line 199
    tmp___3 = strerror(*tmp___2);
#line 199
    debug("chmod %.100s 0666 failed: %.100s", ttyname___0, tmp___3);
  }
#line 200
  return;
}
}
#line 204 "pty.c"
void pty_make_controlling_tty(int *ttyfd , char const   *ttyname___0 ) 
{ int fd ;
  int *tmp ;
  char *tmp___0 ;
  __pid_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
#line 210
  fd = open("/dev/tty", 258);
#line 211
  if (fd >= 0) {
#line 213
    ioctl(fd, 21538UL, (void *)0);
#line 214
    close(fd);
  }
#line 217
  tmp___1 = setsid();
#line 217
  if (tmp___1 < 0) {
#line 218
    tmp = __errno_location();
#line 218
    tmp___0 = strerror(*tmp);
#line 218
    error("setsid: %.100s", tmp___0);
  }
#line 221
  fd = open("/dev/tty", 258);
#line 222
  if (fd >= 0) {
#line 224
    error("Failed to disconnect from controlling tty.");
#line 225
    close(fd);
  }
#line 230
  debug("Setting controlling tty using TIOCSCTTY.");
#line 233
  ioctl(*ttyfd, 21518UL, (void *)0);
#line 235
  fd = open(ttyname___0, 2);
#line 236
  if (fd < 0) {
#line 237
    tmp___2 = __errno_location();
#line 237
    tmp___3 = strerror(*tmp___2);
#line 237
    error("%.100s: %.100s", ttyname___0, tmp___3);
  } else {
#line 239
    close(fd);
  }
#line 242
  fd = open("/dev/tty", 1);
#line 243
  if (fd < 0) {
#line 244
    tmp___4 = __errno_location();
#line 244
    tmp___5 = strerror(*tmp___4);
#line 244
    error("open /dev/tty failed - could not set controlling tty: %.100s", tmp___5);
  } else {
#line 248
    close(fd);
  }
#line 250
  return;
}
}
#line 254 "pty.c"
void pty_change_window_size(int ptyfd , int row , int col , int xpixel , int ypixel ) 
{ struct winsize w ;

  {
#line 258
  w.ws_row = (unsigned short )row;
#line 259
  w.ws_col = (unsigned short )col;
#line 260
  w.ws_xpixel = (unsigned short )xpixel;
#line 261
  w.ws_ypixel = (unsigned short )ypixel;
#line 262
  ioctl(ptyfd, 21524UL, & w);
#line 263
  return;
}
}
#line 1 "log-server.o"
#line 175 "/usr/include/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 25 "log-server.c"
static int log_debug  =    0;
#line 26 "log-server.c"
static int log_quiet  =    0;
#line 27 "log-server.c"
static int log_on_stderr  =    0;
#line 36 "log-server.c"
void log_init(char *av0___0 , int on_stderr , int debug___0 , int quiet , SyslogFacility facility ) 
{ int log_facility ;

  {
#line 41
  switch ((int )facility) {
  case 0: 
#line 44
  log_facility = 3 << 3;
#line 45
  break;
  case 1: 
#line 47
  log_facility = 1 << 3;
#line 48
  break;
  case 2: 
#line 50
  log_facility = 4 << 3;
#line 51
  break;
  case 3: 
#line 53
  log_facility = 16 << 3;
#line 54
  break;
  case 4: 
#line 56
  log_facility = 17 << 3;
#line 57
  break;
  case 5: 
#line 59
  log_facility = 18 << 3;
#line 60
  break;
  case 6: 
#line 62
  log_facility = 19 << 3;
#line 63
  break;
  case 7: 
#line 65
  log_facility = 20 << 3;
#line 66
  break;
  case 8: 
#line 68
  log_facility = 21 << 3;
#line 69
  break;
  case 9: 
#line 71
  log_facility = 22 << 3;
#line 72
  break;
  case 10: 
#line 74
  log_facility = 23 << 3;
#line 75
  break;
  default: 
#line 77
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized internal syslog facility code %d\n",
          (int )facility);
#line 79
  exit(1);
  }
#line 82
  log_debug = debug___0;
#line 83
  log_quiet = quiet;
#line 84
  log_on_stderr = on_stderr;
#line 85
  closelog();
#line 86
  openlog((char const   *)av0___0, 1, log_facility);
#line 87
  return;
}
}
#line 95 "log-server.c"
void log(char const   *fmt  , ...) 
{ va_list args ;
  char msgbuf[1024] ;

  {
#line 99
  if (log_quiet) {
#line 100
    return;
  }
#line 101
  __builtin_va_start(args, fmt);
#line 102
  vsnprintf((char * __restrict  )(msgbuf), 1024U, (char const   * __restrict  )fmt,
            args);
#line 103
  __builtin_va_end(args);
#line 104
  if (log_on_stderr) {
#line 105
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"log: %s\n",
            msgbuf);
  }
#line 106
  syslog(6, "log: %.500s", msgbuf);
#line 107
  return;
}
}
#line 111 "log-server.c"
void debug(char const   *fmt  , ...) 
{ va_list args ;
  char msgbuf[1024] ;

  {
#line 115
  if (! log_debug) {
#line 116
    return;
  } else {
#line 115
    if (log_quiet) {
#line 116
      return;
    }
  }
#line 117
  __builtin_va_start(args, fmt);
#line 118
  vsnprintf((char * __restrict  )(msgbuf), 1024U, (char const   * __restrict  )fmt,
            args);
#line 119
  __builtin_va_end(args);
#line 120
  if (log_on_stderr) {
#line 121
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"debug: %s\n",
            msgbuf);
  }
#line 122
  syslog(7, "debug: %.500s", msgbuf);
#line 123
  return;
}
}
#line 127 "log-server.c"
void error(char const   *fmt  , ...) 
{ va_list args ;
  char msgbuf[1024] ;

  {
#line 131
  if (log_quiet) {
#line 132
    return;
  }
#line 133
  __builtin_va_start(args, fmt);
#line 134
  vsnprintf((char * __restrict  )(msgbuf), 1024U, (char const   * __restrict  )fmt,
            args);
#line 135
  __builtin_va_end(args);
#line 136
  if (log_on_stderr) {
#line 137
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"error: %s\n",
            msgbuf);
  }
#line 138
  syslog(3, "error: %.500s", msgbuf);
#line 139
  return;
}
}
#line 148 "log-server.c"
static struct fatal_cleanup *fatal_cleanups  =    (struct fatal_cleanup *)((void *)0);
#line 152 "log-server.c"
void fatal_add_cleanup(void (*proc)(void *context ) , void *context ) 
{ struct fatal_cleanup *cu ;
  void *tmp ;

  {
#line 156
  tmp = xmalloc(sizeof(*cu));
#line 156
  cu = (struct fatal_cleanup *)tmp;
#line 157
  cu->proc = proc;
#line 158
  cu->context = context;
#line 159
  cu->next = fatal_cleanups;
#line 160
  fatal_cleanups = cu;
#line 161
  return;
}
}
#line 165 "log-server.c"
void fatal_remove_cleanup(void (*proc)(void *context ) , void *context ) 
{ struct fatal_cleanup **cup ;
  struct fatal_cleanup *cu ;

  {
#line 169
  cup = & fatal_cleanups;
#line 169
  while (*cup) {
#line 171
    cu = *cup;
#line 172
    if ((unsigned int )cu->proc == (unsigned int )proc) {
#line 172
      if ((unsigned int )cu->context == (unsigned int )context) {
#line 174
        *cup = cu->next;
#line 175
        xfree((void *)cu);
#line 176
        return;
      }
    }
#line 169
    cup = & cu->next;
  }
#line 179
  fatal("fatal_remove_cleanup: no such cleanup function: 0x%lx 0x%lx\n", (unsigned long )proc,
        (unsigned long )context);
#line 181
  return;
}
}
#line 189 "log-server.c"
static int fatal_called  =    0;
#line 185 "log-server.c"
void fatal(char const   *fmt  , ...) 
{ va_list args ;
  struct fatal_cleanup *cu ;
  struct fatal_cleanup *next_cu ;
  char msgbuf[1024] ;

  {
#line 195
  if (log_quiet) {
#line 196
    exit(1);
  }
#line 197
  __builtin_va_start(args, fmt);
#line 198
  vsnprintf((char * __restrict  )(msgbuf), 1024U, (char const   * __restrict  )fmt,
            args);
#line 199
  __builtin_va_end(args);
#line 200
  if (log_on_stderr) {
#line 201
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"fatal: %s\n",
            msgbuf);
  }
#line 202
  syslog(3, "fatal: %.500s", msgbuf);
#line 204
  if (fatal_called) {
#line 205
    exit(1);
  }
#line 206
  fatal_called = 1;
#line 209
  cu = fatal_cleanups;
#line 209
  while (cu) {
#line 211
    next_cu = cu->next;
#line 212
    debug("Calling cleanup 0x%lx(0x%lx)", (unsigned long )cu->proc, (unsigned long )cu->context);
#line 214
    (*(cu->proc))(cu->context);
#line 209
    cu = next_cu;
  }
#line 230
  if (xauthfile) {
#line 230
    unlink((char const   *)xauthfile);
  }
#line 232
  exit(1);
}
}
#line 1 "login.o"
#line 187 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 46 "/usr/include/utmp.h"
extern  __attribute__((__nothrow__)) void login(struct utmp  const  *__entry ) ;
#line 49
extern  __attribute__((__nothrow__)) int logout(char const   *__ut_line ) ;
#line 52
extern  __attribute__((__nothrow__)) void logwtmp(char const   *__ut_line , char const   *__ut_name ,
                                                  char const   *__ut_host ) ;
#line 33 "login.c"
unsigned long get_last_login_time(uid_t uid , char const   *logname , char *buf ,
                                  unsigned int bufsize ) 
{ struct lastlog ll ;
  char *lastlog ;
  int fd ;
  ssize_t tmp ;

  {
#line 40
  lastlog = (char *)"/var/log/lastlog";
#line 42
  *(buf + 0) = (char )'\000';
#line 44
  fd = open((char const   *)lastlog, 0);
#line 45
  if (fd < 0) {
#line 46
    return (0UL);
  }
#line 47
  lseek(fd, (long )((unsigned long )((long )uid) * (unsigned long )sizeof(ll)), 0);
#line 48
  tmp = read(fd, (void *)(& ll), sizeof(ll));
#line 48
  if ((unsigned int )tmp != sizeof(ll)) {
#line 50
    close(fd);
#line 51
    return (0UL);
  }
#line 53
  close(fd);
#line 54
  if (bufsize > sizeof(ll.ll_host) + 1U) {
#line 55
    bufsize = sizeof(ll.ll_host) + 1U;
  }
#line 56
  __builtin_strncpy(buf, (char const   *)(ll.ll_host), bufsize - 1U);
#line 57
  *(buf + (bufsize - 1U)) = (char)0;
#line 58
  return ((unsigned long )ll.ll_time);
}
}
#line 64 "login.c"
void record_login(int pid , char const   *ttyname___0 , char const   *user , uid_t uid ,
                  char const   *host , struct sockaddr_in *addr ) 
{ int fd ;
  struct lastlog ll ;
  char *lastlog ;
  struct utmp u ;
  char const   *utmp ;
  char const   *wtmp ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 75
  memset((void *)(& u), 0, sizeof(u));
#line 76
  __builtin_strncpy(u.ut_line, ttyname___0 + 5, sizeof(u.ut_line));
#line 77
  u.ut_tv.tv_sec = time((time_t *)((void *)0));
#line 78
  __builtin_strncpy(u.ut_user, user, sizeof(u.ut_user));
#line 79
  __builtin_strncpy(u.ut_host, host, sizeof(u.ut_host));
#line 82
  utmp = "/var/run/utmp";
#line 83
  wtmp = "/var/log/wtmp";
#line 85
  login((struct utmp  const  *)(& u));
#line 87
  lastlog = (char *)"/var/log/lastlog";
#line 90
  if (0) {
#line 90
    __s1_len = strlen(user);
#line 90
    __s2_len = strlen("");
#line 90
    if (! ((unsigned int )((void const   *)(user + 1)) - (unsigned int )((void const   *)user) == 1U)) {
      goto _L___0;
    } else {
#line 90
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 90
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 90
          tmp___11 = 1;
        } else {
#line 90
          if (__s2_len >= 4U) {
#line 90
            tmp___11 = 1;
          } else {
#line 90
            tmp___11 = 0;
          }
        }
      } else {
#line 90
        tmp___11 = 0;
      }
    }
#line 90
    if (tmp___11) {
#line 90
      tmp___7 = __builtin_strcmp(user, "");
    } else {
#line 90
      tmp___10 = __builtin_strcmp(user, "");
#line 90
      tmp___7 = tmp___10;
    }
  } else {
#line 90
    tmp___10 = __builtin_strcmp(user, "");
#line 90
    tmp___7 = tmp___10;
  }
#line 90
  if (tmp___7 != 0) {
#line 94
    memset((void *)(& ll), 0, sizeof(ll));
#line 97
    ll.ll_time = time((time_t *)((void *)0));
#line 98
    __builtin_strncpy(ll.ll_line, ttyname___0 + 5, sizeof(ll.ll_line));
#line 99
    __builtin_strncpy(ll.ll_host, host, sizeof(ll.ll_host));
#line 100
    fd = open((char const   *)lastlog, 2);
#line 101
    if (fd >= 0) {
#line 103
      lseek(fd, (long )((unsigned long )((long )uid) * (unsigned long )sizeof(ll)),
            0);
#line 104
      tmp___1 = write(fd, (void const   *)(& ll), sizeof(ll));
#line 104
      if ((unsigned int )tmp___1 != sizeof(ll)) {
#line 105
        tmp = __errno_location();
#line 105
        tmp___0 = strerror(*tmp);
#line 105
        log("Could not write %.100s: %.100s", lastlog, tmp___0);
      }
#line 106
      close(fd);
    }
  }
#line 109
  return;
}
}
#line 113 "login.c"
void record_logout(int pid , char const   *ttyname___0 ) 
{ char const   *line ;
  int tmp ;

  {
#line 115
  line = ttyname___0 + 5;
#line 116
  tmp = logout(line);
#line 116
  if (tmp) {
#line 117
    logwtmp(line, "", "");
  }
#line 118
  return;
}
}
/* compiler builtin: 
   unsigned int __builtin_strspn(char const   * , char const   * ) ;  */
#line 1 "servconf.o"
#line 199 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strtok(char * __restrict  __s , char const   * __restrict  __delim )  __attribute__((__nonnull__(2))) ;
#line 270 "/usr/include/netdb.h"
extern void endservent(void) ;
#line 284
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 23 "servconf.c"
void initialize_server_options(ServerOptions *options___0 ) 
{ register unsigned int __v ;
  register unsigned int __x ;

  {
#line 25
  memset((void *)options___0, 0, sizeof(*options___0));
#line 26
  options___0->port = -1;
#line 27
  __x = 0U;
#line 27
  __asm__  ("rorw $8, %w0;"
            "rorl $16, %0;"
            "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 27
  options___0->listen_addr.s_addr = __v;
#line 28
  options___0->host_key_file = (char *)((void *)0);
#line 29
  options___0->server_key_bits = -1;
#line 30
  options___0->login_grace_time = -1;
#line 31
  options___0->key_regeneration_time = -1;
#line 32
  options___0->permit_root_login = -1;
#line 33
  options___0->ignore_rhosts = -1;
#line 34
  options___0->quiet_mode = -1;
#line 35
  options___0->fascist_logging = -1;
#line 36
  options___0->print_motd = -1;
#line 37
  options___0->check_mail = -1;
#line 38
  options___0->x11_forwarding = -1;
#line 39
  options___0->x11_display_offset = -1;
#line 40
  options___0->strict_modes = -1;
#line 41
  options___0->keepalives = -1;
#line 42
  options___0->log_facility = (enum __anonenum_SyslogFacility_74 )-1;
#line 43
  options___0->rhosts_authentication = -1;
#line 44
  options___0->rhosts_rsa_authentication = -1;
#line 45
  options___0->rsa_authentication = -1;
#line 55
  options___0->password_authentication = -1;
#line 59
  options___0->permit_empty_passwd = -1;
#line 60
  options___0->use_login = -1;
#line 61
  options___0->num_allow_users = 0U;
#line 62
  options___0->num_deny_users = 0U;
#line 63
  options___0->num_allow_groups = 0U;
#line 64
  options___0->num_deny_groups = 0U;
#line 65
  return;
}
}
#line 67 "servconf.c"
void fill_default_server_options(ServerOptions *options___0 ) 
{ struct servent *sp ;
  register unsigned short __v ;
  register unsigned short __x ;

  {
#line 69
  if (options___0->port == -1) {
#line 73
    sp = getservbyname("ssh", "tcp");
#line 74
    if (sp) {
#line 75
      __x = (unsigned short )sp->s_port;
#line 75
      __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 75
      options___0->port = (int )__v;
    } else {
#line 77
      options___0->port = 22;
    }
#line 78
    endservent();
  }
#line 80
  if ((unsigned int )options___0->host_key_file == (unsigned int )((void *)0)) {
#line 81
    options___0->host_key_file = (char *)"/usr/local/etc/ssh_host_key";
  }
#line 82
  if (options___0->server_key_bits == -1) {
#line 83
    options___0->server_key_bits = 768;
  }
#line 84
  if (options___0->login_grace_time == -1) {
#line 85
    options___0->login_grace_time = 600;
  }
#line 86
  if (options___0->key_regeneration_time == -1) {
#line 87
    options___0->key_regeneration_time = 3600;
  }
#line 88
  if (options___0->permit_root_login == -1) {
#line 89
    options___0->permit_root_login = 1;
  }
#line 90
  if (options___0->ignore_rhosts == -1) {
#line 91
    options___0->ignore_rhosts = 0;
  }
#line 92
  if (options___0->quiet_mode == -1) {
#line 93
    options___0->quiet_mode = 0;
  }
#line 94
  if (options___0->check_mail == -1) {
#line 95
    options___0->check_mail = 0;
  }
#line 96
  if (options___0->fascist_logging == -1) {
#line 97
    options___0->fascist_logging = 1;
  }
#line 98
  if (options___0->print_motd == -1) {
#line 99
    options___0->print_motd = 1;
  }
#line 100
  if (options___0->x11_forwarding == -1) {
#line 101
    options___0->x11_forwarding = 1;
  }
#line 102
  if (options___0->x11_display_offset == -1) {
#line 103
    options___0->x11_display_offset = 1;
  }
#line 104
  if (options___0->strict_modes == -1) {
#line 105
    options___0->strict_modes = 1;
  }
#line 106
  if (options___0->keepalives == -1) {
#line 107
    options___0->keepalives = 1;
  }
#line 108
  if ((int )options___0->log_facility == (int )((enum __anonenum_SyslogFacility_74 )-1)) {
#line 109
    options___0->log_facility = 2;
  }
#line 110
  if (options___0->rhosts_authentication == -1) {
#line 111
    options___0->rhosts_authentication = 0;
  }
#line 112
  if (options___0->rhosts_rsa_authentication == -1) {
#line 113
    options___0->rhosts_rsa_authentication = 1;
  }
#line 114
  if (options___0->rsa_authentication == -1) {
#line 115
    options___0->rsa_authentication = 1;
  }
#line 130
  if (options___0->password_authentication == -1) {
#line 131
    options___0->password_authentication = 1;
  }
#line 136
  if (options___0->permit_empty_passwd == -1) {
#line 137
    options___0->permit_empty_passwd = 1;
  }
#line 138
  if (options___0->use_login == -1) {
#line 139
    options___0->use_login = 0;
  }
#line 140
  return;
}
}
#line 167 "servconf.c"
static struct __anonstruct_keywords_77 keywords[29]  = 
#line 167
  {      {"port", 0}, 
        {"hostkey", 1}, 
        {"serverkeybits", 2}, 
        {"logingracetime", 3}, 
        {"keyregenerationinterval", 4}, 
        {"permitrootlogin", 5}, 
        {"quietmode", 6}, 
        {"fascistlogging", 7}, 
        {"syslogfacility", 8}, 
        {"rhostsauthentication", 9}, 
        {"rhostsrsaauthentication", 10}, 
        {"rsaauthentication", 11}, 
        {"passwordauthentication", 12}, 
        {"checkmail", 22}, 
        {"listenaddress", 13}, 
        {"printmotd", 14}, 
        {"ignorerhosts", 15}, 
        {"x11forwarding", 16}, 
        {"x11displayoffset", 17}, 
        {"strictmodes", 18}, 
        {"permitemptypasswords", 19}, 
        {"uselogin", 23}, 
        {"randomseed", 20}, 
        {"keepalive", 21}, 
        {"allowusers", 24}, 
        {"denyusers", 25}, 
        {"allowgroups", 26}, 
        {"denygroups", 27}, 
        {(char const   *)((void *)0), (ServerOpCodes )0}};
#line 216 "servconf.c"
static struct __anonstruct_log_facilities_78 log_facilities[12]  = 
#line 216
  {      {"DAEMON", 0}, 
        {"USER", 1}, 
        {"AUTH", 2}, 
        {"LOCAL0", 3}, 
        {"LOCAL1", 4}, 
        {"LOCAL2", 5}, 
        {"LOCAL3", 6}, 
        {"LOCAL4", 7}, 
        {"LOCAL5", 8}, 
        {"LOCAL6", 9}, 
        {"LOCAL7", 10}, 
        {(char const   *)((void *)0), (SyslogFacility )0}};
#line 239 "servconf.c"
static ServerOpCodes parse_token(char const   *cp , char const   *filename , int linenum ) 
{ unsigned int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 244
  i = 0U;
#line 244
  while (keywords[i].name) {
#line 245
    if (0) {
#line 245
      __s1_len = strlen(cp);
#line 245
      __s2_len = strlen(keywords[i].name);
#line 245
      if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
        goto _L___0;
      } else {
#line 245
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 245
          if (! ((unsigned int )((void const   *)(keywords[i].name + 1)) - (unsigned int )((void const   *)keywords[i].name) == 1U)) {
#line 245
            tmp___8 = 1;
          } else {
#line 245
            if (__s2_len >= 4U) {
#line 245
              tmp___8 = 1;
            } else {
#line 245
              tmp___8 = 0;
            }
          }
        } else {
#line 245
          tmp___8 = 0;
        }
      }
#line 245
      if (tmp___8) {
#line 245
        tmp___4 = __builtin_strcmp(cp, keywords[i].name);
      } else {
#line 245
        tmp___7 = __builtin_strcmp(cp, keywords[i].name);
#line 245
        tmp___4 = tmp___7;
      }
    } else {
#line 245
      tmp___7 = __builtin_strcmp(cp, keywords[i].name);
#line 245
      tmp___4 = tmp___7;
    }
#line 245
    if (tmp___4 == 0) {
#line 246
      return (keywords[i].opcode);
    }
#line 244
    i ++;
  }
#line 248
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: Bad configuration option: %s\n",
          filename, linenum, cp);
#line 250
  exit(1);
}
}
#line 255 "servconf.c"
void read_server_config(ServerOptions *options___0 , char const   *filename ) 
{ FILE *f ;
  char line[1024] ;
  char *cp ;
  char **charptr ;
  int linenum ;
  int *intptr ;
  int i ;
  int value ;
  ServerOpCodes opcode ;
  unsigned int tmp___30 ;
  char *t ;
  __uid_t tmp___31 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___37 ;
  int tmp___40 ;
  int tmp___41 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___47 ;
  int tmp___50 ;
  int tmp___51 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___57 ;
  int tmp___60 ;
  int tmp___61 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___67 ;
  int tmp___70 ;
  int tmp___71 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___77 ;
  int tmp___80 ;
  int tmp___81 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___87 ;
  int tmp___90 ;
  int tmp___91 ;
  unsigned int tmp___92 ;
  unsigned int tmp___93 ;
  unsigned int tmp___94 ;
  unsigned int tmp___95 ;
  char *tmp___96 ;
  char *tmp___97 ;

  {
#line 263
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 264
  if (! f) {
#line 266
    perror(filename);
#line 267
    exit(1);
  }
#line 270
  linenum = 0;
#line 271
  while (1) {
#line 271
    tmp___97 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 271
    if (! tmp___97) {
#line 271
      break;
    }
#line 273
    linenum ++;
#line 274
    tmp___30 = __builtin_strspn((char const   *)(line), " \t\r\n");
#line 274
    cp = line + tmp___30;
#line 275
    if (! *cp) {
#line 276
      continue;
    } else {
#line 275
      if ((int )*cp == 35) {
#line 276
        continue;
      }
    }
#line 277
    cp = strtok((char * __restrict  )cp, (char const   * __restrict  )" \t\r\n");
#line 279
    t = cp;
#line 280
    while ((int )*t != 0) {
#line 281
      if (65 <= (int )*t) {
#line 281
        if ((int )*t <= 90) {
#line 282
          *t = (char )(((int )*t - 65) + 97);
        }
      }
#line 280
      t ++;
    }
#line 285
    opcode = parse_token((char const   *)cp, filename, linenum);
#line 286
    switch ((int )opcode) {
    case 0: 
#line 289
    intptr = & options___0->port;
    parse_int: 
#line 291
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 292
    if (! cp) {
#line 294
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing integer value.\n",
              filename, linenum);
#line 296
      exit(1);
    }
#line 298
    value = atoi((char const   *)cp);
#line 299
    if (*intptr == -1) {
#line 300
      *intptr = value;
    }
#line 301
    break;
    case 2: 
#line 304
    intptr = & options___0->server_key_bits;
    goto parse_int;
    case 3: 
#line 308
    intptr = & options___0->login_grace_time;
    goto parse_int;
    case 4: 
#line 312
    intptr = & options___0->key_regeneration_time;
    goto parse_int;
    case 13: 
#line 316
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 317
    if (! cp) {
#line 319
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing inet addr.\n",
              filename, linenum);
#line 321
      exit(1);
    }
#line 323
    options___0->listen_addr.s_addr = inet_addr((char const   *)cp);
#line 324
    break;
    case 1: 
#line 327
    charptr = & options___0->host_key_file;
#line 328
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 329
    if (! cp) {
#line 331
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing file name.\n",
              filename, linenum);
#line 333
      exit(1);
    }
#line 335
    if ((unsigned int )*charptr == (unsigned int )((void *)0)) {
#line 336
      tmp___31 = getuid();
#line 336
      *charptr = tilde_expand_filename((char const   *)cp, tmp___31);
    }
#line 337
    break;
    case 20: 
#line 340
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: \"randomseed\" option is obsolete.\n",
            filename, linenum);
#line 342
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 343
    break;
    case 5: 
#line 346
    intptr = & options___0->permit_root_login;
#line 347
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 348
    if (! cp) {
#line 350
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing yes/without-password/no argument.\n",
              filename, linenum);
#line 352
      exit(1);
    }
#line 354
    if (0) {
#line 354
      __s1_len___1 = strlen((char const   *)cp);
#line 354
      __s2_len___1 = strlen("without-password");
#line 354
      if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
        goto _L___4;
      } else {
#line 354
        if (__s1_len___1 >= 4U) {
          _L___4: /* CIL Label */ 
#line 354
          if (! ((unsigned int )((void const   *)("without-password" + 1)) - (unsigned int )((void const   *)"without-password") == 1U)) {
#line 354
            tmp___61 = 1;
          } else {
#line 354
            if (__s2_len___1 >= 4U) {
#line 354
              tmp___61 = 1;
            } else {
#line 354
              tmp___61 = 0;
            }
          }
        } else {
#line 354
          tmp___61 = 0;
        }
      }
#line 354
      if (tmp___61) {
#line 354
        tmp___57 = __builtin_strcmp((char const   *)cp, "without-password");
      } else {
#line 354
        tmp___60 = __builtin_strcmp((char const   *)cp, "without-password");
#line 354
        tmp___57 = tmp___60;
      }
    } else {
#line 354
      tmp___60 = __builtin_strcmp((char const   *)cp, "without-password");
#line 354
      tmp___57 = tmp___60;
    }
#line 354
    if (tmp___57 == 0) {
#line 355
      value = 2;
    } else {
#line 356
      if (0) {
#line 356
        __s1_len___0 = strlen((char const   *)cp);
#line 356
        __s2_len___0 = strlen("yes");
#line 356
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___2;
        } else {
#line 356
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 356
            if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 356
              tmp___51 = 1;
            } else {
#line 356
              if (__s2_len___0 >= 4U) {
#line 356
                tmp___51 = 1;
              } else {
#line 356
                tmp___51 = 0;
              }
            }
          } else {
#line 356
            tmp___51 = 0;
          }
        }
#line 356
        if (tmp___51) {
#line 356
          tmp___47 = __builtin_strcmp((char const   *)cp, "yes");
        } else {
#line 356
          tmp___50 = __builtin_strcmp((char const   *)cp, "yes");
#line 356
          tmp___47 = tmp___50;
        }
      } else {
#line 356
        tmp___50 = __builtin_strcmp((char const   *)cp, "yes");
#line 356
        tmp___47 = tmp___50;
      }
#line 356
      if (tmp___47 == 0) {
#line 357
        value = 1;
      } else {
#line 358
        if (0) {
#line 358
          __s1_len = strlen((char const   *)cp);
#line 358
          __s2_len = strlen("no");
#line 358
          if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
            goto _L___0;
          } else {
#line 358
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 358
              if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 358
                tmp___41 = 1;
              } else {
#line 358
                if (__s2_len >= 4U) {
#line 358
                  tmp___41 = 1;
                } else {
#line 358
                  tmp___41 = 0;
                }
              }
            } else {
#line 358
              tmp___41 = 0;
            }
          }
#line 358
          if (tmp___41) {
#line 358
            tmp___37 = __builtin_strcmp((char const   *)cp, "no");
          } else {
#line 358
            tmp___40 = __builtin_strcmp((char const   *)cp, "no");
#line 358
            tmp___37 = tmp___40;
          }
        } else {
#line 358
          tmp___40 = __builtin_strcmp((char const   *)cp, "no");
#line 358
          tmp___37 = tmp___40;
        }
#line 358
        if (tmp___37 == 0) {
#line 359
          value = 0;
        } else {
#line 362
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: Bad yes/without-password/no argument: %s\n",
                  filename, linenum, cp);
#line 364
          exit(1);
        }
      }
    }
#line 366
    if (*intptr == -1) {
#line 367
      *intptr = value;
    }
#line 368
    break;
    case 15: 
#line 371
    intptr = & options___0->ignore_rhosts;
    parse_flag: 
#line 373
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 374
    if (! cp) {
#line 376
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing yes/no argument.\n",
              filename, linenum);
#line 378
      exit(1);
    }
#line 380
    if (0) {
#line 380
      __s1_len___3 = strlen((char const   *)cp);
#line 380
      __s2_len___3 = strlen("yes");
#line 380
      if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
        goto _L___8;
      } else {
#line 380
        if (__s1_len___3 >= 4U) {
          _L___8: /* CIL Label */ 
#line 380
          if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 380
            tmp___81 = 1;
          } else {
#line 380
            if (__s2_len___3 >= 4U) {
#line 380
              tmp___81 = 1;
            } else {
#line 380
              tmp___81 = 0;
            }
          }
        } else {
#line 380
          tmp___81 = 0;
        }
      }
#line 380
      if (tmp___81) {
#line 380
        tmp___77 = __builtin_strcmp((char const   *)cp, "yes");
      } else {
#line 380
        tmp___80 = __builtin_strcmp((char const   *)cp, "yes");
#line 380
        tmp___77 = tmp___80;
      }
    } else {
#line 380
      tmp___80 = __builtin_strcmp((char const   *)cp, "yes");
#line 380
      tmp___77 = tmp___80;
    }
#line 380
    if (tmp___77 == 0) {
#line 381
      value = 1;
    } else {
#line 383
      if (0) {
#line 383
        __s1_len___2 = strlen((char const   *)cp);
#line 383
        __s2_len___2 = strlen("no");
#line 383
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___6;
        } else {
#line 383
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 383
            if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 383
              tmp___71 = 1;
            } else {
#line 383
              if (__s2_len___2 >= 4U) {
#line 383
                tmp___71 = 1;
              } else {
#line 383
                tmp___71 = 0;
              }
            }
          } else {
#line 383
            tmp___71 = 0;
          }
        }
#line 383
        if (tmp___71) {
#line 383
          tmp___67 = __builtin_strcmp((char const   *)cp, "no");
        } else {
#line 383
          tmp___70 = __builtin_strcmp((char const   *)cp, "no");
#line 383
          tmp___67 = tmp___70;
        }
      } else {
#line 383
        tmp___70 = __builtin_strcmp((char const   *)cp, "no");
#line 383
        tmp___67 = tmp___70;
      }
#line 383
      if (tmp___67 == 0) {
#line 384
        value = 0;
      } else {
#line 387
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: Bad yes/no argument: %s\n",
                filename, linenum, cp);
#line 389
        exit(1);
      }
    }
#line 391
    if (*intptr == -1) {
#line 392
      *intptr = value;
    }
#line 393
    break;
    case 6: 
#line 396
    intptr = & options___0->quiet_mode;
    goto parse_flag;
    case 7: 
#line 400
    intptr = & options___0->fascist_logging;
    goto parse_flag;
    case 9: 
#line 404
    intptr = & options___0->rhosts_authentication;
    goto parse_flag;
    case 10: 
#line 408
    intptr = & options___0->rhosts_rsa_authentication;
    goto parse_flag;
    case 11: 
#line 412
    intptr = & options___0->rsa_authentication;
    goto parse_flag;
    case 12: 
#line 440
    intptr = & options___0->password_authentication;
    goto parse_flag;
    case 22: 
#line 444
    intptr = & options___0->check_mail;
    goto parse_flag;
    case 14: 
#line 454
    intptr = & options___0->print_motd;
    goto parse_flag;
    case 16: 
#line 458
    intptr = & options___0->x11_forwarding;
    goto parse_flag;
    case 17: 
#line 462
    intptr = & options___0->x11_display_offset;
    goto parse_int;
    case 18: 
#line 466
    intptr = & options___0->strict_modes;
    goto parse_flag;
    case 21: 
#line 470
    intptr = & options___0->keepalives;
    goto parse_flag;
    case 19: 
#line 474
    intptr = & options___0->permit_empty_passwd;
    goto parse_flag;
    case 23: 
#line 478
    intptr = & options___0->use_login;
    goto parse_flag;
    case 8: 
#line 482
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 483
    if (! cp) {
#line 485
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing facility name.\n",
              filename, linenum);
#line 487
      exit(1);
    }
#line 489
    i = 0;
#line 489
    while (log_facilities[i].name) {
#line 490
      if (0) {
#line 490
        __s1_len___4 = strlen(log_facilities[i].name);
#line 490
        __s2_len___4 = strlen((char const   *)cp);
#line 490
        if (! ((unsigned int )((void const   *)(log_facilities[i].name + 1)) - (unsigned int )((void const   *)log_facilities[i].name) == 1U)) {
          goto _L___10;
        } else {
#line 490
          if (__s1_len___4 >= 4U) {
            _L___10: /* CIL Label */ 
#line 490
            if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 490
              tmp___91 = 1;
            } else {
#line 490
              if (__s2_len___4 >= 4U) {
#line 490
                tmp___91 = 1;
              } else {
#line 490
                tmp___91 = 0;
              }
            }
          } else {
#line 490
            tmp___91 = 0;
          }
        }
#line 490
        if (tmp___91) {
#line 490
          tmp___87 = __builtin_strcmp(log_facilities[i].name, (char const   *)cp);
        } else {
#line 490
          tmp___90 = __builtin_strcmp(log_facilities[i].name, (char const   *)cp);
#line 490
          tmp___87 = tmp___90;
        }
      } else {
#line 490
        tmp___90 = __builtin_strcmp(log_facilities[i].name, (char const   *)cp);
#line 490
        tmp___87 = tmp___90;
      }
#line 490
      if (tmp___87 == 0) {
#line 491
        break;
      }
#line 489
      i ++;
    }
#line 492
    if (! log_facilities[i].name) {
#line 494
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: unsupported log facility %s\n",
              filename, linenum, cp);
#line 496
      exit(1);
    }
#line 498
    if ((int )options___0->log_facility == (int )((enum __anonenum_SyslogFacility_74 )-1)) {
#line 499
      options___0->log_facility = log_facilities[i].facility;
    }
#line 500
    break;
    case 24: 
#line 503
    while (1) {
#line 503
      cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 503
      if (! cp) {
#line 503
        break;
      }
#line 505
      if (options___0->num_allow_users >= 256U) {
#line 507
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: too many allow users.\n",
                filename, linenum);
#line 509
        exit(1);
      }
#line 511
      tmp___92 = options___0->num_allow_users;
#line 511
      (options___0->num_allow_users) ++;
#line 511
      options___0->allow_users[tmp___92] = xstrdup((char const   *)cp);
    }
#line 513
    break;
    case 25: 
#line 516
    while (1) {
#line 516
      cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 516
      if (! cp) {
#line 516
        break;
      }
#line 518
      if (options___0->num_deny_users >= 256U) {
#line 520
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: too many deny users.\n",
                filename, linenum);
#line 522
        exit(1);
      }
#line 524
      tmp___93 = options___0->num_deny_users;
#line 524
      (options___0->num_deny_users) ++;
#line 524
      options___0->deny_users[tmp___93] = xstrdup((char const   *)cp);
    }
#line 526
    break;
    case 26: 
#line 529
    while (1) {
#line 529
      cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 529
      if (! cp) {
#line 529
        break;
      }
#line 531
      if (options___0->num_allow_groups >= 256U) {
#line 533
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: too many allow groups.\n",
                filename, linenum);
#line 535
        exit(1);
      }
#line 537
      tmp___94 = options___0->num_allow_groups;
#line 537
      (options___0->num_allow_groups) ++;
#line 537
      options___0->allow_groups[tmp___94] = xstrdup((char const   *)cp);
    }
#line 539
    break;
    case 27: 
#line 542
    while (1) {
#line 542
      cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 542
      if (! cp) {
#line 542
        break;
      }
#line 544
      if (options___0->num_deny_groups >= 256U) {
#line 546
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: too many deny groups.\n",
                filename, linenum);
#line 548
        exit(1);
      }
#line 550
      tmp___95 = options___0->num_deny_groups;
#line 550
      (options___0->num_deny_groups) ++;
#line 550
      options___0->deny_groups[tmp___95] = xstrdup((char const   *)cp);
    }
#line 552
    break;
    default: 
#line 555
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: Missing handler for opcode %s (%d)\n",
            filename, linenum, cp, opcode);
#line 557
    exit(1);
    }
#line 559
    tmp___96 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 559
    if ((unsigned int )tmp___96 != (unsigned int )((void *)0)) {
#line 561
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: garbage at end of line.\n",
              filename, linenum);
#line 563
      exit(1);
    }
  }
#line 566
  fclose(f);
#line 567
  return;
}
}
#line 1 "serverloop.o"
#line 24 "serverloop.c"
static Buffer stdin_buffer  ;
#line 25 "serverloop.c"
static Buffer stdout_buffer  ;
#line 26 "serverloop.c"
static Buffer stderr_buffer  ;
#line 27 "serverloop.c"
static int fdin  ;
#line 28 "serverloop.c"
static int fdout  ;
#line 30 "serverloop.c"
static int fderr  ;
#line 31 "serverloop.c"
static long stdin_bytes  =    0L;
#line 32 "serverloop.c"
static long stdout_bytes  =    0L;
#line 33 "serverloop.c"
static long stderr_bytes  =    0L;
#line 34 "serverloop.c"
static long fdout_bytes  =    0L;
#line 35 "serverloop.c"
static int stdin_eof  =    0;
#line 36 "serverloop.c"
static int fdout_eof  =    0;
#line 37 "serverloop.c"
static int fderr_eof  =    0;
#line 38 "serverloop.c"
static int connection_in___0  ;
#line 39 "serverloop.c"
static int connection_out___0  ;
#line 40 "serverloop.c"
static unsigned int buffer_high  ;
#line 41 "serverloop.c"
static int max_fd  ;
#line 46 "serverloop.c"
static int child_pid  ;
#line 47 "serverloop.c"
static int volatile   child_terminated  ;
#line 48 "serverloop.c"
static int volatile   child_wait_status  ;
#line 50 "serverloop.c"
void sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  int wait_pid ;
  union __anonunion_77 __constr_expr_0 ;
  union __anonunion_78 __constr_expr_1 ;
  int *tmp___0 ;

  {
#line 52
  tmp = __errno_location();
#line 52
  save_errno = *tmp;
#line 54
  debug("Received SIGCHLD.");
#line 55
  wait_pid = wait((union wait *)((int *)(& child_wait_status)));
#line 56
  if (wait_pid != -1) {
#line 58
    if (wait_pid != child_pid) {
#line 59
      error("Strange, got SIGCHLD and wait returned pid %d but child is %d", wait_pid,
            child_pid);
    }
#line 61
    __constr_expr_0.__in = child_wait_status;
#line 61
    if ((__constr_expr_0.__i & 127) == 0) {
#line 63
      child_terminated = (int volatile   )1;
    } else {
#line 61
      __constr_expr_1.__in = child_wait_status;
#line 61
      if ((int )((signed char )((__constr_expr_1.__i & 127) + 1)) >> 1 > 0) {
#line 63
        child_terminated = (int volatile   )1;
      }
    }
  }
#line 65
  signal(17, & sigchld_handler);
#line 66
  tmp___0 = __errno_location();
#line 66
  *tmp___0 = save_errno;
#line 67
  return;
}
}
#line 71 "serverloop.c"
void process_buffered_input_packets(void) 
{ int type ;
  char *data ;
  unsigned int data_len ;
  int row ;
  int col ;
  int xpixel ;
  int ypixel ;
  int payload_len ;
  int _p ;
  int _e ;
  int _p___0 ;
  int _e___0 ;
  int _p___1 ;
  int _e___1 ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int _p___2 ;
  int _e___2 ;
  int _p___3 ;
  int _e___3 ;
  int _p___4 ;
  int _e___4 ;
  int _p___5 ;
  int _e___5 ;

  {
#line 80
  while (1) {
#line 80
    type = packet_read_poll(& payload_len);
#line 80
    if (! (type != 0)) {
#line 80
      break;
    }
#line 82
    switch (type) {
    case 16: 
#line 86
    if (fdin == -1) {
#line 87
      break;
    }
#line 88
    data = packet_get_string(& data_len);
#line 89
    while (1) {
#line 89
      _p = payload_len;
#line 89
      _e = (int )(4U + data_len);
#line 89
      if (_p != _e) {
#line 89
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "serverloop.c",
            89);
#line 89
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 89
      break;
    }
#line 90
    buffer_append(& stdin_buffer, (char const   *)data, data_len);
#line 91
    memset((void *)data, 0, data_len);
#line 92
    xfree((void *)data);
#line 93
    break;
    case 19: 
#line 98
    debug("EOF received for stdin.");
#line 99
    while (1) {
#line 99
      _p___0 = payload_len;
#line 99
      _e___0 = 0;
#line 99
      if (_p___0 != _e___0) {
#line 99
        log("Packet integrity error (%d != %d) at %s:%d", _p___0, _e___0, "serverloop.c",
            99);
#line 99
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 99
      break;
    }
#line 100
    stdin_eof = 1;
#line 101
    break;
    case 11: 
#line 104
    debug("Window change received.");
#line 105
    while (1) {
#line 105
      _p___1 = payload_len;
#line 105
      _e___1 = 16;
#line 105
      if (_p___1 != _e___1) {
#line 105
        log("Packet integrity error (%d != %d) at %s:%d", _p___1, _e___1, "serverloop.c",
            105);
#line 105
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 105
      break;
    }
#line 106
    tmp = packet_get_int();
#line 106
    row = (int )tmp;
#line 107
    tmp___0 = packet_get_int();
#line 107
    col = (int )tmp___0;
#line 108
    tmp___1 = packet_get_int();
#line 108
    xpixel = (int )tmp___1;
#line 109
    tmp___2 = packet_get_int();
#line 109
    ypixel = (int )tmp___2;
#line 110
    if (fdin != -1) {
#line 111
      pty_change_window_size(fdin, row, col, xpixel, ypixel);
    }
#line 112
    break;
    case 29: 
#line 115
    debug("Received port open request.");
#line 116
    channel_input_port_open(payload_len);
#line 117
    break;
    case 21: 
#line 120
    debug("Received channel open confirmation.");
#line 121
    while (1) {
#line 121
      _p___2 = payload_len;
#line 121
      _e___2 = 8;
#line 121
      if (_p___2 != _e___2) {
#line 121
        log("Packet integrity error (%d != %d) at %s:%d", _p___2, _e___2, "serverloop.c",
            121);
#line 121
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 121
      break;
    }
#line 122
    channel_input_open_confirmation();
#line 123
    break;
    case 22: 
#line 126
    debug("Received channel open failure.");
#line 127
    while (1) {
#line 127
      _p___3 = payload_len;
#line 127
      _e___3 = 4;
#line 127
      if (_p___3 != _e___3) {
#line 127
        log("Packet integrity error (%d != %d) at %s:%d", _p___3, _e___3, "serverloop.c",
            127);
#line 127
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 127
      break;
    }
#line 128
    channel_input_open_failure();
#line 129
    break;
    case 23: 
#line 132
    channel_input_data(payload_len);
#line 133
    break;
    case 24: 
#line 136
    debug("Received channel close.");
#line 137
    while (1) {
#line 137
      _p___4 = payload_len;
#line 137
      _e___4 = 4;
#line 137
      if (_p___4 != _e___4) {
#line 137
        log("Packet integrity error (%d != %d) at %s:%d", _p___4, _e___4, "serverloop.c",
            137);
#line 137
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 137
      break;
    }
#line 138
    channel_input_close();
#line 139
    break;
    case 25: 
#line 142
    debug("Received channel close confirmation.");
#line 143
    while (1) {
#line 143
      _p___5 = payload_len;
#line 143
      _e___5 = 4;
#line 143
      if (_p___5 != _e___5) {
#line 143
        log("Packet integrity error (%d != %d) at %s:%d", _p___5, _e___5, "serverloop.c",
            143);
#line 143
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 143
      break;
    }
#line 144
    channel_input_close_confirmation();
#line 145
    break;
    default: 
#line 154
    packet_disconnect("Protocol error during session: type %d", type);
    }
  }
#line 158
  return;
}
}
#line 163 "serverloop.c"
void make_packets_from_stderr_data(void) 
{ int len ;
  unsigned int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
#line 168
  while (1) {
#line 168
    tmp___2 = buffer_len(& stderr_buffer);
#line 168
    if (tmp___2 > 0U) {
#line 168
      tmp___3 = packet_not_very_much_data_to_write();
#line 168
      if (! tmp___3) {
#line 168
        break;
      }
    } else {
#line 168
      break;
    }
#line 171
    tmp = buffer_len(& stderr_buffer);
#line 171
    len = (int )tmp;
#line 172
    tmp___0 = packet_is_interactive();
#line 172
    if (tmp___0) {
#line 174
      if (len > 512) {
#line 175
        len = 512;
      }
    } else {
#line 179
      if (len > 32768) {
#line 180
        len = 32768;
      }
    }
#line 182
    packet_start(18);
#line 183
    tmp___1 = buffer_ptr(& stderr_buffer);
#line 183
    packet_put_string((char const   *)tmp___1, (unsigned int )len);
#line 184
    packet_send();
#line 185
    buffer_consume(& stderr_buffer, (unsigned int )len);
#line 186
    stderr_bytes += (long )len;
  }
#line 188
  return;
}
}
#line 193 "serverloop.c"
void make_packets_from_stdout_data(void) 
{ int len ;
  unsigned int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
#line 198
  while (1) {
#line 198
    tmp___2 = buffer_len(& stdout_buffer);
#line 198
    if (tmp___2 > 0U) {
#line 198
      tmp___3 = packet_not_very_much_data_to_write();
#line 198
      if (! tmp___3) {
#line 198
        break;
      }
    } else {
#line 198
      break;
    }
#line 201
    tmp = buffer_len(& stdout_buffer);
#line 201
    len = (int )tmp;
#line 202
    tmp___0 = packet_is_interactive();
#line 202
    if (tmp___0) {
#line 204
      if (len > 512) {
#line 205
        len = 512;
      }
    } else {
#line 209
      if (len > 32768) {
#line 210
        len = 32768;
      }
    }
#line 212
    packet_start(17);
#line 213
    tmp___1 = buffer_ptr(& stdout_buffer);
#line 213
    packet_put_string((char const   *)tmp___1, (unsigned int )len);
#line 214
    packet_send();
#line 215
    buffer_consume(& stdout_buffer, (unsigned int )len);
#line 216
    stdout_bytes += (long )len;
  }
#line 218
  return;
}
}
#line 225 "serverloop.c"
void wait_until_can_do_something(fd_set *readset , fd_set *writeset , unsigned int max_time_milliseconds ) 
{ struct timeval tv ;
  struct timeval *tvp ;
  int ret ;
  int __d0 ;
  int __d1 ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int __d0___0 ;
  int __d1___0 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;

  {
  retry_select: 
#line 235
  while (1) {
#line 235
    __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readset->__fds_bits[0]): "memory");
#line 235
    break;
  }
#line 239
  tmp = buffer_len(& stdin_buffer);
#line 239
  if (tmp < 4096U) {
#line 239
    tmp___0 = channel_not_very_much_buffered_data();
#line 239
    if (tmp___0) {
#line 241
      __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
  }
#line 245
  tmp___1 = packet_not_very_much_data_to_write();
#line 245
  if (tmp___1) {
#line 247
    if (! fdout_eof) {
#line 248
      __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
#line 249
    if (! fderr_eof) {
#line 250
      __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
  }
#line 253
  while (1) {
#line 253
    __asm__  volatile   ("cld; rep; stosl": "=c" (__d0___0), "=D" (__d1___0): "a" (0),
                         "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& writeset->__fds_bits[0]): "memory");
#line 253
    break;
  }
#line 256
  channel_prepare_select(readset, writeset);
#line 260
  tmp___2 = packet_have_data_to_write();
#line 260
  if (tmp___2) {
#line 261
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 265
  if (fdin != -1) {
#line 265
    tmp___3 = buffer_len(& stdin_buffer);
#line 265
    if (tmp___3 > 0U) {
#line 266
      __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
  }
#line 269
  tmp___4 = channel_max_fd();
#line 269
  if (tmp___4 > max_fd) {
#line 270
    max_fd = channel_max_fd();
  }
#line 273
  if (child_terminated) {
#line 274
    if (max_time_milliseconds == 0U) {
#line 275
      max_time_milliseconds = 100U;
    }
  }
#line 277
  if (max_time_milliseconds == 0U) {
#line 278
    tvp = (struct timeval *)((void *)0);
  } else {
#line 281
    tv.tv_sec = (long )(max_time_milliseconds / 1000U);
#line 282
    tv.tv_usec = (long )(1000U * (max_time_milliseconds % 1000U));
#line 283
    tvp = & tv;
  }
#line 287
  ret = select(max_fd + 1, (fd_set * __restrict  )readset, (fd_set * __restrict  )writeset,
               (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )tvp);
#line 289
  if (ret < 0) {
#line 291
    tmp___7 = __errno_location();
#line 291
    if (*tmp___7 != 4) {
#line 292
      tmp___5 = __errno_location();
#line 292
      tmp___6 = strerror(*tmp___5);
#line 292
      error("select: %.100s", tmp___6);
    } else {
      goto retry_select;
    }
  }
#line 296
  return;
}
}
#line 301 "serverloop.c"
void process_input(fd_set *readset ) 
{ int len ;
  char buf[16384] ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  register char __result ;
  register char __result___0 ;
  register char __result___1 ;

  {
#line 307
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 307
  if (__result) {
#line 309
    len = read(connection_in___0, (void *)(buf), sizeof(buf));
#line 310
    if (len == 0) {
#line 311
      fatal("Connection closed by remote host.");
    }
#line 315
    if (len < 0) {
#line 315
      tmp = __errno_location();
#line 315
      if (*tmp == 11) {
#line 316
        len = 0;
      }
    }
#line 318
    if (len < 0) {
#line 319
      tmp___0 = __errno_location();
#line 319
      tmp___1 = strerror(*tmp___0);
#line 319
      fatal("Read error from remote host: %.100s", tmp___1);
    }
#line 322
    packet_process_incoming((char const   *)(buf), (unsigned int )len);
  }
#line 326
  if (! fdout_eof) {
#line 326
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "cc");
#line 326
    if (__result___0) {
#line 328
      len = read(fdout, (void *)(buf), sizeof(buf));
#line 329
      if (len <= 0) {
#line 330
        fdout_eof = 1;
      } else {
#line 333
        buffer_append(& stdout_buffer, (char const   *)(buf), (unsigned int )len);
#line 334
        fdout_bytes += (long )len;
      }
    }
  }
#line 339
  if (! fderr_eof) {
#line 339
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___1): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "cc");
#line 339
    if (__result___1) {
#line 341
      len = read(fderr, (void *)(buf), sizeof(buf));
#line 342
      if (len <= 0) {
#line 343
        fderr_eof = 1;
      } else {
#line 345
        buffer_append(& stderr_buffer, (char const   *)(buf), (unsigned int )len);
      }
    }
  }
#line 347
  return;
}
}
#line 351 "serverloop.c"
void process_output(fd_set *writeset ) 
{ int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  register char __result ;
  register char __result___0 ;

  {
#line 356
  if (fdin != -1) {
#line 356
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))),
                         "m" (writeset->__fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "cc");
#line 356
    if (__result) {
#line 358
      tmp = buffer_len(& stdin_buffer);
#line 358
      tmp___0 = buffer_ptr(& stdin_buffer);
#line 358
      len = write(fdin, (void const   *)tmp___0, tmp);
#line 360
      if (len <= 0) {
#line 363
        close(fdin);
#line 370
        fdin = -1;
      } else {
#line 375
        buffer_consume(& stdin_buffer, (unsigned int )len);
#line 377
        stdin_bytes += (long )len;
      }
    }
  }
#line 382
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->__fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 382
  if (__result___0) {
#line 383
    packet_write_poll();
  }
#line 384
  return;
}
}
#line 389 "serverloop.c"
void drain_output(void) 
{ unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;

  {
#line 392
  tmp___2 = buffer_len(& stdout_buffer);
#line 392
  if (tmp___2 > 0U) {
#line 394
    packet_start(17);
#line 395
    tmp = buffer_len(& stdout_buffer);
#line 395
    tmp___0 = buffer_ptr(& stdout_buffer);
#line 395
    packet_put_string((char const   *)tmp___0, tmp);
#line 397
    packet_send();
#line 399
    tmp___1 = buffer_len(& stdout_buffer);
#line 399
    stdout_bytes = (long )((unsigned long )stdout_bytes + (unsigned long )tmp___1);
  }
#line 403
  tmp___6 = buffer_len(& stderr_buffer);
#line 403
  if (tmp___6 > 0U) {
#line 405
    packet_start(18);
#line 406
    tmp___3 = buffer_len(& stderr_buffer);
#line 406
    tmp___4 = buffer_ptr(& stderr_buffer);
#line 406
    packet_put_string((char const   *)tmp___4, tmp___3);
#line 408
    packet_send();
#line 410
    tmp___5 = buffer_len(& stderr_buffer);
#line 410
    stderr_bytes = (long )((unsigned long )stderr_bytes + (unsigned long )tmp___5);
  }
#line 414
  packet_write_wait();
#line 415
  return;
}
}
#line 423 "serverloop.c"
void server_loop(int pid , int fdin_arg , int fdout_arg , int fderr_arg ) 
{ int wait_status ;
  int wait_pid ;
  int waiting_termination ;
  unsigned int max_time_milliseconds ;
  unsigned int previous_stdout_buffer_bytes ;
  unsigned int stdout_buffer_bytes ;
  int type ;
  int tmp ;
  fd_set readset ;
  fd_set writeset ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *s ;
  char *cp ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  union __anonunion_79 __constr_expr_0 ;
  union __anonunion_80 __constr_expr_1 ;
  int plen ;
  union __anonunion_81 __constr_expr_2 ;
  union __anonunion_82 __constr_expr_3 ;
  union __anonunion_83 __constr_expr_4 ;

  {
#line 426
  waiting_termination = 0;
#line 432
  debug("Entering interactive session.");
#line 435
  child_pid = pid;
#line 436
  child_terminated = (int volatile   )0;
#line 437
  signal(17, & sigchld_handler);
#line 440
  fdin = fdin_arg;
#line 441
  fdout = fdout_arg;
#line 442
  fderr = fderr_arg;
#line 443
  connection_in___0 = packet_get_connection_in();
#line 444
  connection_out___0 = packet_get_connection_out();
#line 446
  previous_stdout_buffer_bytes = 0U;
#line 449
  tmp = packet_is_interactive();
#line 449
  if (tmp) {
#line 450
    buffer_high = 4096U;
  } else {
#line 452
    buffer_high = 65536U;
  }
#line 455
  max_fd = fdin;
#line 456
  if (fdout > max_fd) {
#line 457
    max_fd = fdout;
  }
#line 458
  if (fderr != -1) {
#line 458
    if (fderr > max_fd) {
#line 459
      max_fd = fderr;
    }
  }
#line 460
  if (connection_in___0 > max_fd) {
#line 461
    max_fd = connection_in___0;
  }
#line 462
  if (connection_out___0 > max_fd) {
#line 463
    max_fd = connection_out___0;
  }
#line 466
  buffer_init(& stdin_buffer);
#line 467
  buffer_init(& stdout_buffer);
#line 468
  buffer_init(& stderr_buffer);
#line 474
  if (fderr == -1) {
#line 475
    fderr_eof = 1;
  }
#line 478
  while (1) {
#line 483
    process_buffered_input_packets();
#line 487
    if (stdin_eof) {
#line 487
      if (fdin != -1) {
#line 487
        tmp___0 = buffer_len(& stdin_buffer);
#line 487
        if (tmp___0 == 0U) {
#line 490
          close(fdin);
#line 497
          fdin = -1;
        }
      }
    }
#line 501
    make_packets_from_stderr_data();
#line 508
    max_time_milliseconds = 0U;
#line 509
    stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 510
    if (stdout_buffer_bytes != 0U) {
#line 510
      if (stdout_buffer_bytes < 256U) {
#line 510
        if (stdout_buffer_bytes != previous_stdout_buffer_bytes) {
#line 512
          max_time_milliseconds = 10U;
        } else {
#line 514
          make_packets_from_stdout_data();
        }
      } else {
#line 514
        make_packets_from_stdout_data();
      }
    } else {
#line 514
      make_packets_from_stdout_data();
    }
#line 515
    previous_stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 518
    tmp___1 = packet_not_very_much_data_to_write();
#line 518
    if (tmp___1) {
#line 519
      channel_output_poll();
    }
#line 524
    if (fdout_eof) {
#line 524
      if (fderr_eof) {
#line 524
        tmp___5 = packet_have_data_to_write();
#line 524
        if (! tmp___5) {
#line 524
          tmp___6 = buffer_len(& stdout_buffer);
#line 524
          if (tmp___6 == 0U) {
#line 524
            tmp___7 = buffer_len(& stderr_buffer);
#line 524
            if (tmp___7 == 0U) {
#line 527
              tmp___2 = channel_still_open();
#line 527
              if (! tmp___2) {
                goto quit;
              }
#line 529
              if (! waiting_termination) {
#line 531
                s = "Waiting for forwarded connections to terminate...\r\n";
#line 534
                waiting_termination = 1;
#line 535
                tmp___3 = strlen(s);
#line 535
                buffer_append(& stderr_buffer, s, tmp___3);
#line 538
                cp = channel_open_message();
#line 539
                tmp___4 = strlen((char const   *)cp);
#line 539
                buffer_append(& stderr_buffer, (char const   *)cp, tmp___4);
#line 540
                xfree((void *)cp);
              }
            }
          }
        }
      }
    }
#line 545
    wait_until_can_do_something(& readset, & writeset, max_time_milliseconds);
#line 549
    channel_after_select(& readset, & writeset);
#line 552
    process_input(& readset);
#line 555
    process_output(& writeset);
  }
  quit: 
#line 562
  drain_output();
#line 564
  debug("End of interactive session; stdin %ld, stdout (read %ld, sent %ld), stderr %ld bytes.",
        stdin_bytes, fdout_bytes, stdout_bytes, stderr_bytes);
#line 568
  buffer_free(& stdin_buffer);
#line 569
  buffer_free(& stdout_buffer);
#line 570
  buffer_free(& stderr_buffer);
#line 573
  if (fdout != -1) {
#line 574
    close(fdout);
  }
#line 575
  fdout = -1;
#line 576
  fdout_eof = 1;
#line 577
  if (fderr != -1) {
#line 578
    close(fderr);
  }
#line 579
  fderr = -1;
#line 580
  fderr_eof = 1;
#line 581
  if (fdin != -1) {
#line 582
    close(fdin);
  }
#line 583
  fdin = -1;
#line 586
  channel_stop_listening();
#line 589
  wait_pid = wait((union wait *)(& wait_status));
#line 590
  if (wait_pid < 0) {
#line 595
    if (child_terminated) {
#line 596
      wait_status = (int )child_wait_status;
    } else {
#line 598
      tmp___8 = __errno_location();
#line 598
      tmp___9 = strerror(*tmp___8);
#line 598
      packet_disconnect("wait: %.100s", tmp___9);
    }
  } else {
#line 603
    if (wait_pid != pid) {
#line 604
      error("Strange, wait returned pid %d, expected %d", wait_pid, pid);
    }
  }
#line 608
  signal(17, (void (*)(int  ))0);
#line 611
  __constr_expr_2.__in = wait_status;
#line 611
  if ((__constr_expr_2.__i & 127) == 0) {
#line 614
    __constr_expr_0.__in = wait_status;
#line 614
    debug("Command exited with status %d.", (__constr_expr_0.__i & 65280) >> 8);
#line 615
    packet_start(20);
#line 616
    __constr_expr_1.__in = wait_status;
#line 616
    packet_put_int((unsigned int )((__constr_expr_1.__i & 65280) >> 8));
#line 617
    packet_send();
#line 618
    packet_write_wait();
#line 624
    while (1) {
#line 627
      type = packet_read(& plen);
#line 624
      if (! (type != 33)) {
#line 624
        break;
      }
    }
#line 631
    debug("Received exit confirmation.");
#line 632
    return;
  }
#line 636
  __constr_expr_4.__in = wait_status;
#line 636
  if ((int )((signed char )((__constr_expr_4.__i & 127) + 1)) >> 1 > 0) {
#line 637
    __constr_expr_3.__in = wait_status;
#line 637
    packet_disconnect("Command terminated on signal %d.", __constr_expr_3.__i & 127);
  }
#line 641
  packet_disconnect("wait returned status %04x.", wait_status);
#line 643
  return;
}
}
