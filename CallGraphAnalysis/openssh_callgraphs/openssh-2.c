/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

#line 214 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stddef.h"
typedef unsigned int size_t;
#line 183 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 195 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 36 "/usr/include/bits/socket.h"
typedef __socklen_t socklen_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 145 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 107 "/usr/include/openssl/ossl_typ.h"
struct bignum_st;
#line 107 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_st BIGNUM;
#line 108
struct bignum_ctx;
#line 108 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_ctx BN_CTX;
#line 109
struct bn_blinding_st;
#line 109 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_blinding_st BN_BLINDING;
#line 110
struct bn_mont_ctx_st;
#line 110 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_mont_ctx_st BN_MONT_CTX;
#line 112
struct bn_gencb_st;
#line 112 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_gencb_st BN_GENCB;
#line 128
struct rsa_st;
#line 128 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_st RSA;
#line 129
struct rsa_meth_st;
#line 129 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_meth_st RSA_METHOD;
#line 154
struct engine_st;
#line 154 "/usr/include/openssl/ossl_typ.h"
typedef struct engine_st ENGINE;
#line 165
struct crypto_ex_data_st;
#line 165 "/usr/include/openssl/ossl_typ.h"
typedef struct crypto_ex_data_st CRYPTO_EX_DATA;
#line 285 "/usr/include/openssl/bn.h"
struct bignum_st {
   unsigned long *d ;
   int top ;
   int dmax ;
   int neg ;
   int flags ;
};
#line 296 "/usr/include/openssl/bn.h"
struct bn_mont_ctx_st {
   int ri ;
   BIGNUM RR ;
   BIGNUM N ;
   BIGNUM Ni ;
   unsigned long n0 ;
   int flags ;
};
#line 320 "/usr/include/openssl/bn.h"
union __anonunion_cb_62 {
   void (*cb_1)(int  , int  , void * ) ;
   int (*cb_2)(int  , int  , BN_GENCB * ) ;
};
#line 320 "/usr/include/openssl/bn.h"
struct bn_gencb_st {
   unsigned int ver ;
   void *arg ;
   union __anonunion_cb_62 cb ;
};
#line 66 "/usr/include/openssl/stack.h"
struct stack_st {
   int num ;
   char **data ;
   int sorted ;
   int num_alloc ;
   int (*comp)(char const   * const  * , char const   * const  * ) ;
};
#line 66 "/usr/include/openssl/stack.h"
typedef struct stack_st STACK;
#line 283 "/usr/include/openssl/crypto.h"
struct crypto_ex_data_st {
   STACK *sk ;
   int dummy ;
};
#line 85 "/usr/include/openssl/rsa.h"
struct rsa_meth_st {
   char const   *name ;
   int (*rsa_pub_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_pub_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_priv_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_priv_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_mod_exp)(BIGNUM *r0 , BIGNUM const   *I , RSA *rsa , BN_CTX *ctx ) ;
   int (*bn_mod_exp)(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(RSA *rsa ) ;
   int (*finish)(RSA *rsa ) ;
   int flags ;
   char *app_data ;
   int (*rsa_sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
                   unsigned int *siglen , RSA const   *rsa ) ;
   int (*rsa_verify)(int dtype , unsigned char const   *m , unsigned int m_length ,
                     unsigned char *sigbuf , unsigned int siglen , RSA const   *rsa ) ;
   int (*rsa_keygen)(RSA *rsa , int bits , BIGNUM *e , BN_GENCB *cb ) ;
};
#line 128 "/usr/include/openssl/rsa.h"
struct rsa_st {
   int pad ;
   long version ;
   RSA_METHOD const   *meth ;
   ENGINE *engine ;
   BIGNUM *n ;
   BIGNUM *e ;
   BIGNUM *d ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *dmp1 ;
   BIGNUM *dmq1 ;
   BIGNUM *iqmp ;
   CRYPTO_EX_DATA ex_data ;
   int references ;
   int flags ;
   BN_MONT_CTX *_method_mod_n ;
   BN_MONT_CTX *_method_mod_p ;
   BN_MONT_CTX *_method_mod_q ;
   char *bignum_data ;
   BN_BLINDING *blinding ;
   BN_BLINDING *mt_blinding ;
};
#line 21 "buffer.h"
struct __anonstruct_Buffer_75 {
   char *buf ;
   unsigned int alloc ;
   unsigned int offset ;
   unsigned int end ;
};
#line 21 "buffer.h"
typedef struct __anonstruct_Buffer_75 Buffer;
#line 34 "authfd.h"
struct __anonstruct_AuthenticationConnection_76 {
   int fd ;
   Buffer packet ;
   Buffer identities ;
   int howmany ;
};
#line 34 "authfd.h"
typedef struct __anonstruct_AuthenticationConnection_76 AuthenticationConnection;
#line 60 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 137 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 143 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 144 "/usr/include/bits/types.h"
typedef long __off_t;
#line 152 "/usr/include/bits/types.h"
typedef long __time_t;
#line 167 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 172 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 88 "/usr/include/sys/types.h"
typedef __off_t off_t;
#line 203 "/usr/include/sys/types.h"
typedef unsigned int u_int32_t;
#line 121 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 78 "/usr/include/openssl/des.h"
typedef unsigned char DES_cblock[8];
#line 83 "/usr/include/openssl/des.h"
union __anonunion_ks_64 {
   DES_cblock cblock ;
   unsigned long deslong[2] ;
};
#line 83 "/usr/include/openssl/des.h"
struct DES_ks {
   union __anonunion_ks_64 ks[16] ;
};
#line 83 "/usr/include/openssl/des.h"
typedef struct DES_ks DES_key_schedule;
#line 101 "/usr/include/openssl/blowfish.h"
struct bf_key_st {
   unsigned int P[18] ;
   unsigned int S[1024] ;
};
#line 41 "cipher.h"
struct __anonstruct_des3_69 {
   DES_key_schedule key1 ;
   DES_key_schedule key2 ;
   DES_cblock iv2 ;
   DES_key_schedule key3 ;
   DES_cblock iv3 ;
};
#line 41 "cipher.h"
struct __anonstruct_bf_70 {
   struct bf_key_st key ;
   unsigned char iv[8] ;
};
#line 41 "cipher.h"
union __anonunion_u_68 {
   struct __anonstruct_des3_69 des3 ;
   struct __anonstruct_bf_70 bf ;
};
#line 41 "cipher.h"
struct __anonstruct_CipherContext_67 {
   unsigned int type ;
   union __anonunion_u_68 u ;
};
#line 41 "cipher.h"
typedef struct __anonstruct_CipherContext_67 CipherContext;
#line 59 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 145 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 177 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 183 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 268 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t )] ;
};
#line 44 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 92 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 136 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 137 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 219 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 96 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 321 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 146 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024U / (8U * sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 385 "ssh.h"
enum __anonenum_SyslogFacility_74 {
    SYSLOG_FACILITY_DAEMON = 0,
    SYSLOG_FACILITY_USER = 1,
    SYSLOG_FACILITY_AUTH = 2,
    SYSLOG_FACILITY_LOCAL0 = 3,
    SYSLOG_FACILITY_LOCAL1 = 4,
    SYSLOG_FACILITY_LOCAL2 = 5,
    SYSLOG_FACILITY_LOCAL3 = 6,
    SYSLOG_FACILITY_LOCAL4 = 7,
    SYSLOG_FACILITY_LOCAL5 = 8,
    SYSLOG_FACILITY_LOCAL6 = 9,
    SYSLOG_FACILITY_LOCAL7 = 10
} ;
#line 385 "ssh.h"
typedef enum __anonenum_SyslogFacility_74 SyslogFacility;
#line 26 "servconf.h"
struct __anonstruct_ServerOptions_77 {
   int port ;
   struct in_addr listen_addr ;
   char *host_key_file ;
   int server_key_bits ;
   int login_grace_time ;
   int key_regeneration_time ;
   int permit_root_login ;
   int ignore_rhosts ;
   int quiet_mode ;
   int fascist_logging ;
   int print_motd ;
   int check_mail ;
   int x11_forwarding ;
   int x11_display_offset ;
   int strict_modes ;
   int keepalives ;
   SyslogFacility log_facility ;
   int rhosts_authentication ;
   int rhosts_rsa_authentication ;
   int rsa_authentication ;
   int password_authentication ;
   int permit_empty_passwd ;
   int use_login ;
   unsigned int num_allow_users ;
   char *allow_users[256] ;
   unsigned int num_deny_users ;
   char *deny_users[256] ;
   unsigned int num_allow_groups ;
   char *allow_groups[256] ;
   unsigned int num_deny_groups ;
   char *deny_groups[256] ;
};
#line 26 "servconf.h"
typedef struct __anonstruct_ServerOptions_77 ServerOptions;
#line 23 "channels.h"
struct Channel {
   int type ;
   int self ;
   int remote_id ;
   int istate ;
   int ostate ;
   int sock ;
   Buffer input ;
   Buffer output ;
   char path[200] ;
   int listening_port ;
   int host_port ;
   char *remote_name ;
};
#line 23 "channels.h"
typedef struct Channel Channel;
#line 72 "channels.c"
struct __anonstruct_ForwardPermission_78 {
   char *host ;
   int port ;
};
#line 72 "channels.c"
typedef struct __anonstruct_ForwardPermission_78 ForwardPermission;
#line 79 "/usr/include/openssl/des.h"
typedef unsigned char const_DES_cblock[8];
#line 101 "/usr/include/openssl/blowfish.h"
typedef struct bf_key_st BF_KEY;
#line 99 "/usr/include/openssl/md5.h"
struct MD5state_st {
   unsigned int A ;
   unsigned int B ;
   unsigned int C ;
   unsigned int D ;
   unsigned int Nl ;
   unsigned int Nh ;
   unsigned int data[16] ;
   unsigned int num ;
};
#line 99 "/usr/include/openssl/md5.h"
typedef struct MD5state_st MD5_CTX;
#line 91 "cipher.c"
union __anonunion_t_75 {
   u_int32_t i ;
   char c[4] ;
};
#line 261 "/usr/include/zconf.h"
typedef unsigned char Byte;
#line 263 "/usr/include/zconf.h"
typedef unsigned int uInt;
#line 264 "/usr/include/zconf.h"
typedef unsigned long uLong;
#line 270 "/usr/include/zconf.h"
typedef Byte Bytef;
#line 279 "/usr/include/zconf.h"
typedef void *voidpf;
#line 80 "/usr/include/zlib.h"
struct internal_state;
#line 82 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 82 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 103 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 1346 "/usr/include/zlib.h"
struct internal_state {
   int dummy ;
};
#line 202 "/usr/include/sys/types.h"
typedef unsigned short u_int16_t;
#line 339 "ssh.h"
enum __anonenum_HostStatus_73 {
    HOST_OK = 0,
    HOST_NEW = 1,
    HOST_CHANGED = 2
} ;
#line 339 "ssh.h"
typedef enum __anonenum_HostStatus_73 HostStatus;
#line 154 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 43 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 105 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 75 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 25 "/usr/include/bits/termios.h"
typedef unsigned char cc_t;
#line 26 "/usr/include/bits/termios.h"
typedef unsigned int speed_t;
#line 27 "/usr/include/bits/termios.h"
typedef unsigned int tcflag_t;
#line 30 "/usr/include/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 62 "rc4.h"
struct __anonstruct_rc4_t_29 {
   unsigned int s[256] ;
   int i ;
   int j ;
};
#line 62 "rc4.h"
typedef struct __anonstruct_rc4_t_29 rc4_t;
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 77 "/usr/include/time.h"
typedef __time_t time_t;
#line 314 "/usr/include/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 63 "/usr/include/sys/wait.h"
union wait;
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_terminated_40 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_stopped_41 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_40 __wait_terminated ;
   struct __anonstruct___wait_stopped_41 __wait_stopped ;
};
#line 43 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 18 "/usr/include/security/_pam_types.h"
struct pam_handle;
#line 18 "/usr/include/security/_pam_types.h"
typedef struct pam_handle pam_handle_t;
#line 244 "/usr/include/security/_pam_types.h"
struct pam_message {
   int msg_style ;
   char const   *msg ;
};
#line 269 "/usr/include/security/_pam_types.h"
struct pam_response {
   char *resp ;
   int resp_retcode ;
};
#line 276 "/usr/include/security/_pam_types.h"
struct pam_conv {
   int (*conv)(int num_msg , struct pam_message  const  **msg , struct pam_response **resp ,
               void *appdata_ptr ) ;
   void *appdata_ptr ;
};
#line 585 "ssh.h"
struct envstring {
   struct envstring *next ;
   char *s ;
};
#line 97 "sshd.c"
struct __anonstruct_sensitive_data_77 {
   RSA *private_key ;
   RSA *host_key ;
};
#line 143
struct pam_handle_t;
#line 1976 "sshd.c"
struct pty_cleanup_context {
   char const   *ttyname ;
   int pid ;
};
#line 28 "/usr/include/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 141 "log-server.c"
struct fatal_cleanup {
   struct fatal_cleanup *next ;
   void (*proc)(void * ) ;
   void *context ;
};
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 38 "/usr/include/bits/utmp.h"
struct lastlog {
   __time_t ll_time ;
   char ll_line[32] ;
   char ll_host[256] ;
};
#line 52 "/usr/include/bits/utmp.h"
struct exit_status {
   short e_termination ;
   short e_exit ;
};
#line 60 "/usr/include/bits/utmp.h"
struct utmp {
   short ut_type ;
   pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct exit_status ut_exit ;
   long ut_session ;
   struct timeval ut_tv ;
   int32_t ut_addr_v6[4] ;
   char __unused[20] ;
};
#line 251 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 145 "servconf.c"
enum __anonenum_ServerOpCodes_76 {
    sPort = 0,
    sHostKeyFile = 1,
    sServerKeyBits = 2,
    sLoginGraceTime = 3,
    sKeyRegenerationTime = 4,
    sPermitRootLogin = 5,
    sQuietMode = 6,
    sFascistLogging = 7,
    sLogFacility = 8,
    sRhostsAuthentication = 9,
    sRhostsRSAAuthentication = 10,
    sRSAAuthentication = 11,
    sPasswordAuthentication = 12,
    sListenAddress = 13,
    sPrintMotd = 14,
    sIgnoreRhosts = 15,
    sX11Forwarding = 16,
    sX11DisplayOffset = 17,
    sStrictModes = 18,
    sEmptyPasswd = 19,
    sRandomSeedFile = 20,
    sKeepAlives = 21,
    sCheckMail = 22,
    sUseLogin = 23,
    sAllowUsers = 24,
    sDenyUsers = 25,
    sAllowGroups = 26,
    sDenyGroups = 27
} ;
#line 145 "servconf.c"
typedef enum __anonenum_ServerOpCodes_76 ServerOpCodes;
#line 167 "servconf.c"
struct __anonstruct_keywords_77 {
   char const   *name ;
   ServerOpCodes opcode ;
};
#line 216 "servconf.c"
struct __anonstruct_log_facilities_78 {
   char const   *name ;
   SyslogFacility facility ;
};
#line 61 "serverloop.c"
union __anonunion_77 {
   int volatile   __in ;
   int __i ;
};
#line 61 "serverloop.c"
union __anonunion_78 {
   int volatile   __in ;
   int __i ;
};
#line 614 "serverloop.c"
union __anonunion_79 {
   int __in ;
   int __i ;
};
#line 616 "serverloop.c"
union __anonunion_80 {
   int __in ;
   int __i ;
};
#line 611 "serverloop.c"
union __anonunion_81 {
   int __in ;
   int __i ;
};
#line 637 "serverloop.c"
union __anonunion_82 {
   int __in ;
   int __i ;
};
#line 636 "serverloop.c"
union __anonunion_83 {
   int __in ;
   int __i ;
};
#line 1 "authfd.o"
#pragma merger(0,"./authfd.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 100 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 124
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 242 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 256
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 660 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 320 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 327
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 333
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 6 "strlcpy.h"
size_t strlcpy(char *dst , char const   *src , size_t siz ) ;
#line 405 "/usr/include/openssl/bn.h"
extern int BN_num_bits(BIGNUM const   *a ) ;
#line 409 "ssh.h"
void log(char const   *fmt  , ...) ;
#line 419
void error(char const   *fmt  , ...) ;
#line 425
void fatal(char const   *fmt  , ...) ;
#line 30 "buffer.h"
void buffer_init(Buffer *buffer ) ;
#line 33
void buffer_free(Buffer *buffer ) ;
#line 37
void buffer_clear(Buffer *buffer ) ;
#line 40
void buffer_append(Buffer *buffer , char const   *data , unsigned int len ) ;
#line 48
unsigned int buffer_len(Buffer *buffer ) ;
#line 51
void buffer_get(Buffer *buffer , char *buf , unsigned int len ) ;
#line 60
char *buffer_ptr(Buffer *buffer ) ;
#line 43 "authfd.h"
int ssh_get_authentication_socket(void) ;
#line 48
void ssh_close_authentication_socket(int sock ) ;
#line 54
AuthenticationConnection *ssh_get_authentication_connection(void) ;
#line 58
void ssh_close_authentication_connection(AuthenticationConnection *ac ) ;
#line 64
int ssh_get_first_identity(AuthenticationConnection *auth , int *bitsp , BIGNUM *e ,
                           BIGNUM *n___0 , char **comment ) ;
#line 71
int ssh_get_next_identity(AuthenticationConnection *auth , int *bitsp , BIGNUM *e ,
                          BIGNUM *n___0 , char **comment ) ;
#line 76
int ssh_decrypt_challenge(AuthenticationConnection *auth , int bits , BIGNUM *e ,
                          BIGNUM *n___0 , BIGNUM *challenge , unsigned char *session_id___0 ,
                          unsigned int response_type , unsigned char *response ) ;
#line 85
int ssh_add_identity(AuthenticationConnection *auth , RSA *key , char const   *comment ) ;
#line 91
int ssh_remove_identity(AuthenticationConnection *auth , RSA *key ) ;
#line 97
int ssh_remove_all_identities(AuthenticationConnection *auth ) ;
#line 23 "bufaux.h"
void buffer_put_bignum(Buffer *buffer , BIGNUM *value ) ;
#line 26
int buffer_get_bignum(Buffer *buffer , BIGNUM *value ) ;
#line 29
unsigned int buffer_get_int(Buffer *buffer ) ;
#line 32
void buffer_put_int(Buffer *buffer , unsigned int value ) ;
#line 35
int buffer_get_char(Buffer *buffer ) ;
#line 38
void buffer_put_char(Buffer *buffer , int value ) ;
#line 46
char *buffer_get_string(Buffer *buffer , unsigned int *length_ptr ) ;
#line 49
void buffer_put_string(Buffer *buffer , void const   *buf , unsigned int len ) ;
#line 23 "xmalloc.h"
void *xmalloc(size_t size ) ;
#line 29
void xfree(void *ptr ) ;
#line 37 "authfd.c"
int ssh_get_authentication_socket(void) 
{ char const   *authsocket ;
  int sock ;
  struct sockaddr_un sunaddr ;
  char *tmp ;
  int tmp___0 ;

  {
#line 44
  tmp = getenv("SSH_AUTH_SOCK");
#line 44
  authsocket = (char const   *)tmp;
#line 45
  if (! authsocket) {
#line 46
    return (-1);
  }
#line 48
  sunaddr.sun_family = (unsigned short)1;
#line 49
  strlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));
#line 51
  sock = socket(1, 1, 0);
#line 52
  if (sock < 0) {
#line 53
    return (-1);
  }
#line 55
  tmp___0 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sunaddr)),
                    sizeof(sunaddr));
#line 55
  if (tmp___0 < 0) {
#line 57
    close(sock);
#line 58
    return (-1);
  }
#line 61
  return (sock);
}
}
#line 68 "authfd.c"
void ssh_close_authentication_socket(int sock ) 
{ char *tmp ;

  {
#line 70
  tmp = getenv("SSH_AUTH_SOCK");
#line 70
  if (tmp) {
#line 71
    close(sock);
  }
#line 72
  return;
}
}
#line 80 "authfd.c"
AuthenticationConnection *ssh_get_authentication_connection(void) 
{ AuthenticationConnection *auth ;
  int sock ;
  void *tmp ;

  {
#line 85
  sock = ssh_get_authentication_socket();
#line 89
  if (sock < 0) {
#line 90
    return ((AuthenticationConnection *)((void *)0));
  }
#line 93
  tmp = xmalloc(sizeof(*auth));
#line 93
  auth = (AuthenticationConnection *)tmp;
#line 94
  auth->fd = sock;
#line 95
  buffer_init(& auth->packet);
#line 96
  buffer_init(& auth->identities);
#line 97
  auth->howmany = 0;
#line 99
  return (auth);
}
}
#line 105 "authfd.c"
void ssh_close_authentication_connection(AuthenticationConnection *ac ) 
{ 

  {
#line 107
  buffer_free(& ac->packet);
#line 108
  buffer_free(& ac->identities);
#line 109
  close(ac->fd);
#line 111
  xfree((void *)ac);
#line 112
  return;
}
}
#line 119 "authfd.c"
int ssh_get_first_identity(AuthenticationConnection *auth , int *bitsp , BIGNUM *e ,
                           BIGNUM *n___0 , char **comment ) 
{ unsigned char msg[8192] ;
  int len ;
  int l ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;

  {
#line 128
  msg[0] = (unsigned char)0;
#line 129
  msg[1] = (unsigned char)0;
#line 130
  msg[2] = (unsigned char)0;
#line 131
  msg[3] = (unsigned char)1;
#line 132
  msg[4] = (unsigned char)1;
#line 133
  tmp___1 = write(auth->fd, (void const   *)(msg), 5U);
#line 133
  if (tmp___1 != 5) {
#line 135
    tmp = __errno_location();
#line 135
    tmp___0 = strerror(*tmp);
#line 135
    error("write auth->fd: %.100s", tmp___0);
#line 136
    return (0);
  }
#line 140
  len = 4;
#line 141
  while (len > 0) {
#line 143
    l = read(auth->fd, (void *)((msg + 4) - len), (unsigned int )len);
#line 144
    if (l <= 0) {
#line 146
      tmp___2 = __errno_location();
#line 146
      tmp___3 = strerror(*tmp___2);
#line 146
      error("read auth->fd: %.100s", tmp___3);
#line 147
      return (0);
    }
#line 149
    len -= l;
  }
#line 154
  len = (int )(((((unsigned long )msg[0] << 24) | ((unsigned long )msg[1] << 16)) | ((unsigned long )msg[2] << 8)) | (unsigned long )msg[3]);
#line 155
  if (len < 1) {
#line 156
    fatal("Authentication reply message too long: %d\n", len);
  } else {
#line 155
    if (len > 262144) {
#line 156
      fatal("Authentication reply message too long: %d\n", len);
    }
  }
#line 159
  buffer_clear(& auth->identities);
#line 160
  while (len > 0) {
#line 162
    l = len;
#line 163
    if ((unsigned int )l > sizeof(msg)) {
#line 164
      l = (int )sizeof(msg);
    }
#line 165
    l = read(auth->fd, (void *)(msg), (unsigned int )l);
#line 166
    if (l <= 0) {
#line 167
      fatal("Incomplete authentication reply.");
    }
#line 168
    buffer_append(& auth->identities, (char const   *)((char *)(msg)), (unsigned int )l);
#line 169
    len -= l;
  }
#line 173
  buffer_get(& auth->identities, (char *)(msg), 1U);
#line 174
  if ((int )msg[0] != 2) {
#line 175
    fatal("Bad authentication reply message type: %d", msg[0]);
  }
#line 178
  tmp___4 = buffer_get_int(& auth->identities);
#line 178
  auth->howmany = (int )tmp___4;
#line 179
  if (auth->howmany > 1024) {
#line 180
    fatal("Too many identities in authentication reply: %d\n", auth->howmany);
  }
#line 183
  tmp___5 = ssh_get_next_identity(auth, bitsp, e, n___0, comment);
#line 183
  return (tmp___5);
}
}
#line 191 "authfd.c"
int ssh_get_next_identity(AuthenticationConnection *auth , int *bitsp , BIGNUM *e ,
                          BIGNUM *n___0 , char **comment ) 
{ unsigned int tmp ;

  {
#line 196
  if (auth->howmany <= 0) {
#line 197
    return (0);
  }
#line 201
  tmp = buffer_get_int(& auth->identities);
#line 201
  *bitsp = (int )tmp;
#line 202
  buffer_get_bignum(& auth->identities, e);
#line 203
  buffer_get_bignum(& auth->identities, n___0);
#line 204
  *comment = buffer_get_string(& auth->identities, (unsigned int *)((void *)0));
#line 207
  (auth->howmany) --;
#line 209
  return (1);
}
}
#line 218 "authfd.c"
int ssh_decrypt_challenge(AuthenticationConnection *auth , int bits , BIGNUM *e ,
                          BIGNUM *n___0 , BIGNUM *challenge , unsigned char *session_id___0 ,
                          unsigned int response_type , unsigned char *response ) 
{ Buffer buffer ;
  unsigned char buf[8192] ;
  int len ;
  int l ;
  int i ;
  unsigned int tmp ;
  ssize_t tmp___0 ;
  unsigned int tmp___1 ;
  char *tmp___2 ;
  ssize_t tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;

  {
#line 230
  if (response_type == 0U) {
#line 231
    fatal("Compatibility with ssh protocol version 1.0 no longer supported.");
  }
#line 234
  buf[0] = (unsigned char)3;
#line 235
  buffer_init(& buffer);
#line 236
  buffer_append(& buffer, (char const   *)((char *)(buf)), 1U);
#line 237
  buffer_put_int(& buffer, (unsigned int )bits);
#line 238
  buffer_put_bignum(& buffer, e);
#line 239
  buffer_put_bignum(& buffer, n___0);
#line 240
  buffer_put_bignum(& buffer, challenge);
#line 241
  buffer_append(& buffer, (char const   *)((char *)session_id___0), 16U);
#line 242
  buffer_put_int(& buffer, response_type);
#line 245
  tmp = buffer_len(& buffer);
#line 245
  len = (int )tmp;
#line 246
  while (1) {
#line 246
    buf[0] = (unsigned char )(len >> 24);
#line 246
    buf[1] = (unsigned char )(len >> 16);
#line 246
    buf[2] = (unsigned char )(len >> 8);
#line 246
    buf[3] = (unsigned char )len;
#line 246
    break;
  }
#line 249
  tmp___0 = write(auth->fd, (void const   *)(buf), 4U);
#line 249
  if (tmp___0 != 4) {
    goto _L;
  } else {
#line 249
    tmp___1 = buffer_len(& buffer);
#line 249
    tmp___2 = buffer_ptr(& buffer);
#line 249
    tmp___3 = write(auth->fd, (void const   *)tmp___2, tmp___1);
#line 249
    tmp___4 = buffer_len(& buffer);
#line 249
    if ((unsigned int )tmp___3 != tmp___4) {
      _L: /* CIL Label */ 
#line 253
      error("Error writing to authentication socket.");
      error_cleanup: 
#line 255
      buffer_free(& buffer);
#line 256
      return (0);
    }
  }
#line 261
  len = 4;
#line 262
  while (len > 0) {
#line 264
    l = read(auth->fd, (void *)((buf + 4) - len), (unsigned int )len);
#line 265
    if (l <= 0) {
#line 267
      error("Error reading response length from authentication socket.");
      goto error_cleanup;
    }
#line 270
    len -= l;
  }
#line 274
  len = (int )(((((unsigned long )buf[0] << 24) | ((unsigned long )buf[1] << 16)) | ((unsigned long )buf[2] << 8)) | (unsigned long )buf[3]);
#line 275
  if (len > 262144) {
#line 276
    fatal("Authentication response too long: %d", len);
  }
#line 279
  buffer_clear(& buffer);
#line 280
  while (len > 0) {
#line 282
    l = len;
#line 283
    if ((unsigned int )l > sizeof(buf)) {
#line 284
      l = (int )sizeof(buf);
    }
#line 285
    l = read(auth->fd, (void *)(buf), (unsigned int )l);
#line 286
    if (l <= 0) {
#line 288
      error("Error reading response from authentication socket.");
      goto error_cleanup;
    }
#line 291
    buffer_append(& buffer, (char const   *)((char *)(buf)), (unsigned int )l);
#line 292
    len -= l;
  }
#line 296
  buffer_get(& buffer, (char *)(buf), 1U);
#line 299
  if ((int )buf[0] == 5) {
#line 301
    log("Agent admitted failure to authenticate using the key.");
    goto error_cleanup;
  }
#line 306
  if ((int )buf[0] != 4) {
#line 307
    fatal("Bad authentication response: %d", buf[0]);
  }
#line 311
  i = 0;
#line 311
  while (i < 16) {
#line 312
    tmp___5 = buffer_get_char(& buffer);
#line 312
    *(response + i) = (unsigned char )tmp___5;
#line 311
    i ++;
  }
#line 315
  buffer_free(& buffer);
#line 318
  return (1);
}
}
#line 324 "authfd.c"
int ssh_add_identity(AuthenticationConnection *auth , RSA *key , char const   *comment ) 
{ Buffer buffer ;
  unsigned char buf[8192] ;
  int len ;
  int l ;
  int type ;
  int tmp ;
  size_t tmp___0 ;
  unsigned int tmp___1 ;
  ssize_t tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  ssize_t tmp___5 ;
  unsigned int tmp___6 ;

  {
#line 332
  buffer_init(& buffer);
#line 333
  buffer_put_char(& buffer, 7);
#line 334
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 334
  buffer_put_int(& buffer, (unsigned int )tmp);
#line 335
  buffer_put_bignum(& buffer, key->n);
#line 336
  buffer_put_bignum(& buffer, key->e);
#line 337
  buffer_put_bignum(& buffer, key->d);
#line 339
  buffer_put_bignum(& buffer, key->iqmp);
#line 340
  buffer_put_bignum(& buffer, key->q);
#line 341
  buffer_put_bignum(& buffer, key->p);
#line 342
  tmp___0 = strlen(comment);
#line 342
  buffer_put_string(& buffer, (void const   *)comment, tmp___0);
#line 345
  tmp___1 = buffer_len(& buffer);
#line 345
  len = (int )tmp___1;
#line 346
  while (1) {
#line 346
    buf[0] = (unsigned char )(len >> 24);
#line 346
    buf[1] = (unsigned char )(len >> 16);
#line 346
    buf[2] = (unsigned char )(len >> 8);
#line 346
    buf[3] = (unsigned char )len;
#line 346
    break;
  }
#line 349
  tmp___2 = write(auth->fd, (void const   *)(buf), 4U);
#line 349
  if (tmp___2 != 4) {
    goto _L;
  } else {
#line 349
    tmp___3 = buffer_len(& buffer);
#line 349
    tmp___4 = buffer_ptr(& buffer);
#line 349
    tmp___5 = write(auth->fd, (void const   *)tmp___4, tmp___3);
#line 349
    tmp___6 = buffer_len(& buffer);
#line 349
    if ((unsigned int )tmp___5 != tmp___6) {
      _L: /* CIL Label */ 
#line 353
      error("Error writing to authentication socket.");
      error_cleanup: 
#line 355
      buffer_free(& buffer);
#line 356
      return (0);
    }
  }
#line 361
  len = 4;
#line 362
  while (len > 0) {
#line 364
    l = read(auth->fd, (void *)((buf + 4) - len), (unsigned int )len);
#line 365
    if (l <= 0) {
#line 367
      error("Error reading response length from authentication socket.");
      goto error_cleanup;
    }
#line 370
    len -= l;
  }
#line 374
  len = (int )(((((unsigned long )buf[0] << 24) | ((unsigned long )buf[1] << 16)) | ((unsigned long )buf[2] << 8)) | (unsigned long )buf[3]);
#line 375
  if (len > 262144) {
#line 376
    fatal("Add identity response too long: %d", len);
  }
#line 379
  buffer_clear(& buffer);
#line 380
  while (len > 0) {
#line 382
    l = len;
#line 383
    if ((unsigned int )l > sizeof(buf)) {
#line 384
      l = (int )sizeof(buf);
    }
#line 385
    l = read(auth->fd, (void *)(buf), (unsigned int )l);
#line 386
    if (l <= 0) {
#line 388
      error("Error reading response from authentication socket.");
      goto error_cleanup;
    }
#line 391
    buffer_append(& buffer, (char const   *)((char *)(buf)), (unsigned int )l);
#line 392
    len -= l;
  }
#line 396
  type = buffer_get_char(& buffer);
#line 397
  switch (type) {
  case 5: 
#line 400
  buffer_free(& buffer);
#line 401
  return (0);
  case 6: 
#line 403
  buffer_free(& buffer);
#line 404
  return (1);
  default: 
#line 406
  fatal("Bad response to add identity from authentication agent: %d", type);
  }
#line 410
  return (0);
}
}
#line 416 "authfd.c"
int ssh_remove_identity(AuthenticationConnection *auth , RSA *key ) 
{ Buffer buffer ;
  unsigned char buf[8192] ;
  int len ;
  int l ;
  int type ;
  int tmp ;
  unsigned int tmp___0 ;
  ssize_t tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  ssize_t tmp___4 ;
  unsigned int tmp___5 ;

  {
#line 423
  buffer_init(& buffer);
#line 424
  buffer_put_char(& buffer, 8);
#line 425
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 425
  buffer_put_int(& buffer, (unsigned int )tmp);
#line 426
  buffer_put_bignum(& buffer, key->e);
#line 427
  buffer_put_bignum(& buffer, key->n);
#line 430
  tmp___0 = buffer_len(& buffer);
#line 430
  len = (int )tmp___0;
#line 431
  while (1) {
#line 431
    buf[0] = (unsigned char )(len >> 24);
#line 431
    buf[1] = (unsigned char )(len >> 16);
#line 431
    buf[2] = (unsigned char )(len >> 8);
#line 431
    buf[3] = (unsigned char )len;
#line 431
    break;
  }
#line 434
  tmp___1 = write(auth->fd, (void const   *)(buf), 4U);
#line 434
  if (tmp___1 != 4) {
    goto _L;
  } else {
#line 434
    tmp___2 = buffer_len(& buffer);
#line 434
    tmp___3 = buffer_ptr(& buffer);
#line 434
    tmp___4 = write(auth->fd, (void const   *)tmp___3, tmp___2);
#line 434
    tmp___5 = buffer_len(& buffer);
#line 434
    if ((unsigned int )tmp___4 != tmp___5) {
      _L: /* CIL Label */ 
#line 438
      error("Error writing to authentication socket.");
      error_cleanup: 
#line 440
      buffer_free(& buffer);
#line 441
      return (0);
    }
  }
#line 446
  len = 4;
#line 447
  while (len > 0) {
#line 449
    l = read(auth->fd, (void *)((buf + 4) - len), (unsigned int )len);
#line 450
    if (l <= 0) {
#line 452
      error("Error reading response length from authentication socket.");
      goto error_cleanup;
    }
#line 455
    len -= l;
  }
#line 459
  len = (int )(((((unsigned long )buf[0] << 24) | ((unsigned long )buf[1] << 16)) | ((unsigned long )buf[2] << 8)) | (unsigned long )buf[3]);
#line 460
  if (len > 262144) {
#line 461
    fatal("Remove identity response too long: %d", len);
  }
#line 464
  buffer_clear(& buffer);
#line 465
  while (len > 0) {
#line 467
    l = len;
#line 468
    if ((unsigned int )l > sizeof(buf)) {
#line 469
      l = (int )sizeof(buf);
    }
#line 470
    l = read(auth->fd, (void *)(buf), (unsigned int )l);
#line 471
    if (l <= 0) {
#line 473
      error("Error reading response from authentication socket.");
      goto error_cleanup;
    }
#line 476
    buffer_append(& buffer, (char const   *)((char *)(buf)), (unsigned int )l);
#line 477
    len -= l;
  }
#line 481
  type = buffer_get_char(& buffer);
#line 482
  switch (type) {
  case 5: 
#line 485
  buffer_free(& buffer);
#line 486
  return (0);
  case 6: 
#line 488
  buffer_free(& buffer);
#line 489
  return (1);
  default: 
#line 491
  fatal("Bad response to remove identity from authentication agent: %d", type);
  }
#line 495
  return (0);
}
}
#line 501 "authfd.c"
int ssh_remove_all_identities(AuthenticationConnection *auth ) 
{ Buffer buffer ;
  unsigned char buf[8192] ;
  int len ;
  int l ;
  int type ;
  ssize_t tmp ;

  {
#line 508
  while (1) {
#line 508
    buf[0] = (unsigned char )(1 >> 24);
#line 508
    buf[1] = (unsigned char )(1 >> 16);
#line 508
    buf[2] = (unsigned char )(1 >> 8);
#line 508
    buf[3] = (unsigned char)1;
#line 508
    break;
  }
#line 509
  buf[4] = (unsigned char)9;
#line 512
  tmp = write(auth->fd, (void const   *)(buf), 5U);
#line 512
  if (tmp != 5) {
#line 514
    error("Error writing to authentication socket.");
#line 515
    return (0);
  }
#line 520
  len = 4;
#line 521
  while (len > 0) {
#line 523
    l = read(auth->fd, (void *)((buf + 4) - len), (unsigned int )len);
#line 524
    if (l <= 0) {
#line 526
      error("Error reading response length from authentication socket.");
#line 527
      return (0);
    }
#line 529
    len -= l;
  }
#line 533
  len = (int )(((((unsigned long )buf[0] << 24) | ((unsigned long )buf[1] << 16)) | ((unsigned long )buf[2] << 8)) | (unsigned long )buf[3]);
#line 534
  if (len > 262144) {
#line 535
    fatal("Remove identity response too long: %d", len);
  }
#line 538
  buffer_init(& buffer);
#line 539
  while (len > 0) {
#line 541
    l = len;
#line 542
    if ((unsigned int )l > sizeof(buf)) {
#line 543
      l = (int )sizeof(buf);
    }
#line 544
    l = read(auth->fd, (void *)(buf), (unsigned int )l);
#line 545
    if (l <= 0) {
#line 547
      error("Error reading response from authentication socket.");
#line 548
      buffer_free(& buffer);
#line 549
      return (0);
    }
#line 551
    buffer_append(& buffer, (char const   *)((char *)(buf)), (unsigned int )l);
#line 552
    len -= l;
  }
#line 556
  type = buffer_get_char(& buffer);
#line 557
  switch (type) {
  case 5: 
#line 560
  buffer_free(& buffer);
#line 561
  return (0);
  case 6: 
#line 563
  buffer_free(& buffer);
#line 564
  return (1);
  default: 
#line 566
  fatal("Bad response to remove identity from authentication agent: %d", type);
  }
#line 570
  return (0);
}
}
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
#line 1 "authfile.o"
#pragma merger(0,"./authfile.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 212 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 380
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __attribute__((__nonnull__(3))) ;
#line 447
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 447 "/usr/include/sys/stat.h"
__inline static int fstat(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
#line 450
  tmp = __fxstat(3, __fd, __statbuf);
#line 450
  return (tmp);
}
}
#line 59 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 154 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 85 "/usr/include/fcntl.h"
extern int open(char const   *__file , int __oflag  , ...)  __attribute__((__nonnull__(1))) ;
#line 301 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 642
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 42 "helper.h"
unsigned int arc4random(void) ;
#line 391 "/usr/include/openssl/bn.h"
extern BIGNUM const   *BN_value_one(void) ;
#line 393
extern BN_CTX *BN_CTX_new(void) ;
#line 397
extern void BN_CTX_free(BN_CTX *c ) ;
#line 407
extern BIGNUM *BN_new(void) ;
#line 409
extern void BN_clear_free(BIGNUM *a ) ;
#line 416
extern int BN_sub(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *b ) ;
#line 433
extern int BN_div(BIGNUM *dv , BIGNUM *rem , BIGNUM const   *m , BIGNUM const   *d ,
                  BN_CTX *ctx ) ;
#line 45 "buffer.h"
void buffer_append_space(Buffer *buffer , char **datap , unsigned int len ) ;
#line 61 "cipher.h"
unsigned int cipher_mask(void) ;
#line 64
char const   *cipher_name(int cipher ) ;
#line 77
void cipher_set_key_string(CipherContext *context , int cipher , char const   *passphrase ,
                           int for_encryption ) ;
#line 81
void cipher_encrypt(CipherContext *context , unsigned char *dest , unsigned char const   *src ,
                    unsigned int len ) ;
#line 85
void cipher_decrypt(CipherContext *context , unsigned char *dest , unsigned char const   *src ,
                    unsigned int len ) ;
#line 364 "ssh.h"
int save_private_key(char const   *filename , char const   *passphrase , RSA *key ,
                     char const   *comment ) ;
#line 371
int load_public_key(char const   *filename , RSA *pub , char **comment_return ) ;
#line 379
int load_private_key(char const   *filename , char const   *passphrase , RSA *prv ,
                     char **comment_return ) ;
#line 414
void debug(char const   *fmt  , ...) ;
#line 42 "authfile.c"
int save_private_key(char const   *filename , char const   *passphrase , RSA *key ,
                     char const   *comment ) 
{ Buffer buffer ;
  Buffer encrypted ;
  char buf[100] ;
  char *cp ;
  int f ;
  int i ;
  CipherContext cipher ;
  int cipher_type___0 ;
  u_int32_t rand___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  unsigned int tmp___17 ;
  char *tmp___18 ;
  ssize_t tmp___19 ;
  unsigned int tmp___20 ;

  {
#line 55
  if (0) {
#line 55
    __s1_len = strlen(passphrase);
#line 55
    __s2_len = strlen("");
#line 55
    if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
      goto _L___0;
    } else {
#line 55
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 55
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 55
          tmp___8 = 1;
        } else {
#line 55
          if (__s2_len >= 4U) {
#line 55
            tmp___8 = 1;
          } else {
#line 55
            tmp___8 = 0;
          }
        }
      } else {
#line 55
        tmp___8 = 0;
      }
    }
#line 55
    if (tmp___8) {
#line 55
      tmp___4 = __builtin_strcmp(passphrase, "");
    } else {
#line 55
      tmp___7 = __builtin_strcmp(passphrase, "");
#line 55
      tmp___4 = tmp___7;
    }
  } else {
#line 55
    tmp___7 = __builtin_strcmp(passphrase, "");
#line 55
    tmp___4 = tmp___7;
  }
#line 55
  if (tmp___4 == 0) {
#line 56
    cipher_type___0 = 0;
  } else {
#line 58
    cipher_type___0 = 3;
  }
#line 61
  buffer_init(& buffer);
#line 64
  rand___0 = arc4random();
#line 65
  buf[0] = (char )(rand___0 & 255U);
#line 66
  buf[1] = (char )((rand___0 >> 8) & 255U);
#line 67
  buf[2] = buf[0];
#line 68
  buf[3] = buf[1];
#line 69
  buffer_append(& buffer, (char const   *)(buf), 4U);
#line 74
  buffer_put_bignum(& buffer, key->d);
#line 75
  buffer_put_bignum(& buffer, key->iqmp);
#line 76
  buffer_put_bignum(& buffer, key->q);
#line 77
  buffer_put_bignum(& buffer, key->p);
#line 80
  while (1) {
#line 80
    tmp___9 = buffer_len(& buffer);
#line 80
    if (! (tmp___9 % 8U != 0U)) {
#line 80
      break;
    }
#line 81
    buffer_put_char(& buffer, 0);
  }
#line 84
  buffer_init(& encrypted);
#line 87
  cp = (char *)"SSH PRIVATE KEY FILE FORMAT 1.1\n";
#line 88
  i = 0;
#line 88
  while (*(cp + i)) {
#line 89
    buffer_put_char(& encrypted, (int )*(cp + i));
#line 88
    i ++;
  }
#line 90
  buffer_put_char(& encrypted, 0);
#line 93
  buffer_put_char(& encrypted, cipher_type___0);
#line 94
  buffer_put_int(& encrypted, 0U);
#line 97
  tmp___10 = BN_num_bits((BIGNUM const   *)key->n);
#line 97
  buffer_put_int(& encrypted, (unsigned int )tmp___10);
#line 98
  buffer_put_bignum(& encrypted, key->n);
#line 99
  buffer_put_bignum(& encrypted, key->e);
#line 100
  tmp___11 = strlen(comment);
#line 100
  buffer_put_string(& encrypted, (void const   *)comment, tmp___11);
#line 103
  tmp___12 = buffer_len(& buffer);
#line 103
  buffer_append_space(& encrypted, & cp, tmp___12);
#line 105
  cipher_set_key_string(& cipher, cipher_type___0, passphrase, 1);
#line 106
  tmp___13 = buffer_len(& buffer);
#line 106
  tmp___14 = buffer_ptr(& buffer);
#line 106
  cipher_encrypt(& cipher, (unsigned char *)cp, (unsigned char const   *)((unsigned char *)tmp___14),
                 tmp___13);
#line 109
  memset((void *)(& cipher), 0, sizeof(cipher));
#line 112
  memset((void *)(buf), 0, sizeof(buf));
#line 113
  buffer_free(& buffer);
#line 116
  f = open(filename, 577, 384);
#line 117
  if (f < 0) {
#line 118
    return (0);
  }
#line 120
  tmp___17 = buffer_len(& encrypted);
#line 120
  tmp___18 = buffer_ptr(& encrypted);
#line 120
  tmp___19 = write(f, (void const   *)tmp___18, tmp___17);
#line 120
  tmp___20 = buffer_len(& encrypted);
#line 120
  if ((unsigned int )tmp___19 != tmp___20) {
#line 123
    tmp___15 = __errno_location();
#line 123
    tmp___16 = strerror(*tmp___15);
#line 123
    debug("Write to key file %.200s failed: %.100s", filename, tmp___16);
#line 125
    buffer_free(& encrypted);
#line 126
    close(f);
#line 127
    remove(filename);
#line 128
    return (0);
  }
#line 130
  close(f);
#line 131
  buffer_free(& encrypted);
#line 132
  return (1);
}
}
#line 139 "authfile.c"
int load_public_key(char const   *filename , RSA *pub , char **comment_return ) 
{ int f ;
  int i ;
  off_t len ;
  Buffer buffer ;
  char *cp ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
#line 149
  f = open(filename, 0);
#line 150
  if (f < 0) {
#line 151
    return (0);
  }
#line 153
  len = lseek(f, 0L, 2);
#line 154
  lseek(f, 0L, 0);
#line 156
  buffer_init(& buffer);
#line 157
  buffer_append_space(& buffer, & cp, (unsigned int )len);
#line 159
  tmp___1 = read(f, (void *)cp, (unsigned int )len);
#line 159
  if ((unsigned int )tmp___1 != (unsigned int )len) {
#line 161
    tmp = __errno_location();
#line 161
    tmp___0 = strerror(*tmp);
#line 161
    debug("Read from key file %.200s failed: %.100s", filename, tmp___0);
#line 163
    buffer_free(& buffer);
#line 164
    close(f);
#line 165
    return (0);
  }
#line 167
  close(f);
#line 170
  tmp___2 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 170
  if ((unsigned long )len < (unsigned long )(tmp___2 + 1U)) {
#line 172
    debug("Bad key file %.200s.", filename);
#line 173
    buffer_free(& buffer);
#line 174
    return (0);
  }
#line 179
  i = 0;
#line 179
  while (1) {
#line 179
    tmp___4 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 179
    if (! ((unsigned int )i < tmp___4 + 1U)) {
#line 179
      break;
    }
#line 180
    tmp___3 = buffer_get_char(& buffer);
#line 180
    if (tmp___3 != (int )((unsigned char )*("SSH PRIVATE KEY FILE FORMAT 1.1\n" + i))) {
#line 182
      debug("Bad key file %.200s.", filename);
#line 183
      buffer_free(& buffer);
#line 184
      return (0);
    }
#line 179
    i ++;
  }
#line 188
  buffer_get_char(& buffer);
#line 189
  buffer_get_int(& buffer);
#line 192
  buffer_get_int(& buffer);
#line 193
  pub->n = BN_new();
#line 194
  buffer_get_bignum(& buffer, pub->n);
#line 195
  pub->e = BN_new();
#line 196
  buffer_get_bignum(& buffer, pub->e);
#line 197
  if (comment_return) {
#line 198
    *comment_return = buffer_get_string(& buffer, (unsigned int *)((void *)0));
  }
#line 201
  buffer_free(& buffer);
#line 203
  return (1);
}
}
#line 210 "authfile.c"
int load_private_key(char const   *filename , char const   *passphrase , RSA *prv ,
                     char **comment_return ) 
{ int f ;
  int i ;
  int check1 ;
  int check2 ;
  int cipher_type___0 ;
  off_t len ;
  Buffer buffer ;
  Buffer decrypted ;
  char *cp ;
  CipherContext cipher ;
  BN_CTX *ctx ;
  BIGNUM *aux ;
  struct stat st ;
  int tmp ;
  __uid_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  ssize_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  char *tmp___12 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  BIGNUM const   *tmp___25 ;
  BIGNUM const   *tmp___26 ;

  {
#line 224
  f = open(filename, 0);
#line 225
  if (f < 0) {
#line 226
    return (0);
  }
#line 229
  tmp = fstat(f, & st);
#line 229
  if (tmp < 0) {
    goto _L;
  } else {
#line 229
    if (st.st_uid != 0U) {
#line 229
      tmp___0 = getuid();
#line 229
      if (st.st_uid != tmp___0) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 229
      if ((st.st_mode & 63U) != 0U) {
        _L: /* CIL Label */ 
#line 232
        error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 233
        error("@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @");
#line 234
        error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 235
        error("Bad ownership or mode(0%3.3o) for \'%s\'.", st.st_mode & 511U, filename);
#line 237
        error("It is recommended that your private key files are NOT accessible by others.");
#line 238
        return (0);
      }
    }
  }
#line 241
  len = lseek(f, 0L, 2);
#line 242
  lseek(f, 0L, 0);
#line 244
  buffer_init(& buffer);
#line 245
  buffer_append_space(& buffer, & cp, (unsigned int )len);
#line 247
  tmp___3 = read(f, (void *)cp, (unsigned int )len);
#line 247
  if ((unsigned int )tmp___3 != (unsigned int )len) {
#line 249
    tmp___1 = __errno_location();
#line 249
    tmp___2 = strerror(*tmp___1);
#line 249
    debug("Read from key file %.200s failed: %.100s", filename, tmp___2);
#line 251
    buffer_free(& buffer);
#line 252
    close(f);
#line 253
    return (0);
  }
#line 255
  close(f);
#line 258
  tmp___4 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 258
  if ((unsigned long )len < (unsigned long )(tmp___4 + 1U)) {
#line 260
    debug("Bad key file %.200s.", filename);
#line 261
    buffer_free(& buffer);
#line 262
    return (0);
  }
#line 267
  i = 0;
#line 267
  while (1) {
#line 267
    tmp___6 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 267
    if (! ((unsigned int )i < tmp___6 + 1U)) {
#line 267
      break;
    }
#line 268
    tmp___5 = buffer_get_char(& buffer);
#line 268
    if (tmp___5 != (int )((unsigned char )*("SSH PRIVATE KEY FILE FORMAT 1.1\n" + i))) {
#line 270
      debug("Bad key file %.200s.", filename);
#line 271
      buffer_free(& buffer);
#line 272
      return (0);
    }
#line 267
    i ++;
  }
#line 276
  cipher_type___0 = buffer_get_char(& buffer);
#line 277
  buffer_get_int(& buffer);
#line 280
  buffer_get_int(& buffer);
#line 281
  prv->n = BN_new();
#line 282
  buffer_get_bignum(& buffer, prv->n);
#line 283
  prv->e = BN_new();
#line 284
  buffer_get_bignum(& buffer, prv->e);
#line 285
  if (comment_return) {
#line 286
    *comment_return = buffer_get_string(& buffer, (unsigned int *)((void *)0));
  } else {
#line 288
    tmp___7 = buffer_get_string(& buffer, (unsigned int *)((void *)0));
#line 288
    xfree((void *)tmp___7);
  }
#line 291
  tmp___9 = cipher_mask();
#line 291
  if (((tmp___9 | 3U) & (unsigned int )(1 << cipher_type___0)) == 0U) {
#line 294
    tmp___8 = cipher_name(cipher_type___0);
#line 294
    debug("Unsupported cipher %.100s used in key file %.200s.", tmp___8, filename);
#line 296
    buffer_free(& buffer);
    goto fail;
  }
#line 301
  buffer_init(& decrypted);
#line 302
  tmp___10 = buffer_len(& buffer);
#line 302
  buffer_append_space(& decrypted, & cp, tmp___10);
#line 305
  cipher_set_key_string(& cipher, cipher_type___0, passphrase, 0);
#line 306
  tmp___11 = buffer_len(& buffer);
#line 306
  tmp___12 = buffer_ptr(& buffer);
#line 306
  cipher_decrypt(& cipher, (unsigned char *)cp, (unsigned char const   *)((unsigned char *)tmp___12),
                 tmp___11);
#line 310
  buffer_free(& buffer);
#line 312
  check1 = buffer_get_char(& decrypted);
#line 313
  check2 = buffer_get_char(& decrypted);
#line 314
  tmp___23 = buffer_get_char(& decrypted);
#line 314
  if (check1 != tmp___23) {
    goto _L___3;
  } else {
#line 314
    tmp___24 = buffer_get_char(& decrypted);
#line 314
    if (check2 != tmp___24) {
      _L___3: /* CIL Label */ 
#line 317
      if (0) {
#line 317
        __s1_len = strlen(passphrase);
#line 317
        __s2_len = strlen("");
#line 317
        if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
          goto _L___2;
        } else {
#line 317
          if (__s1_len >= 4U) {
            _L___2: /* CIL Label */ 
#line 317
            if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 317
              tmp___22 = 1;
            } else {
#line 317
              if (__s2_len >= 4U) {
#line 317
                tmp___22 = 1;
              } else {
#line 317
                tmp___22 = 0;
              }
            }
          } else {
#line 317
            tmp___22 = 0;
          }
        }
#line 317
        if (tmp___22) {
#line 317
          tmp___18 = __builtin_strcmp(passphrase, "");
        } else {
#line 317
          tmp___21 = __builtin_strcmp(passphrase, "");
#line 317
          tmp___18 = tmp___21;
        }
      } else {
#line 317
        tmp___21 = __builtin_strcmp(passphrase, "");
#line 317
        tmp___18 = tmp___21;
      }
#line 317
      if (tmp___18 != 0) {
#line 318
        debug("Bad passphrase supplied for key file %.200s.", filename);
      }
#line 320
      buffer_free(& decrypted);
      fail: 
#line 322
      BN_clear_free(prv->n);
#line 323
      BN_clear_free(prv->e);
#line 324
      if (comment_return) {
#line 325
        xfree((void *)*comment_return);
      }
#line 326
      return (0);
    }
  }
#line 330
  prv->d = BN_new();
#line 331
  buffer_get_bignum(& decrypted, prv->d);
#line 332
  prv->iqmp = BN_new();
#line 333
  buffer_get_bignum(& decrypted, prv->iqmp);
#line 335
  prv->q = BN_new();
#line 336
  buffer_get_bignum(& decrypted, prv->q);
#line 337
  prv->p = BN_new();
#line 338
  buffer_get_bignum(& decrypted, prv->p);
#line 340
  ctx = BN_CTX_new();
#line 341
  aux = BN_new();
#line 343
  tmp___25 = BN_value_one();
#line 343
  BN_sub(aux, (BIGNUM const   *)prv->q, tmp___25);
#line 344
  prv->dmq1 = BN_new();
#line 345
  BN_div((BIGNUM *)((void *)0), prv->dmq1, (BIGNUM const   *)prv->d, (BIGNUM const   *)aux,
         ctx);
#line 347
  tmp___26 = BN_value_one();
#line 347
  BN_sub(aux, (BIGNUM const   *)prv->p, tmp___26);
#line 348
  prv->dmp1 = BN_new();
#line 349
  BN_div((BIGNUM *)((void *)0), prv->dmp1, (BIGNUM const   *)prv->d, (BIGNUM const   *)aux,
         ctx);
#line 351
  BN_clear_free(aux);
#line 352
  BN_CTX_free(ctx);
#line 354
  buffer_free(& decrypted);
#line 356
  return (1);
}
}
#line 1 "bufaux.o"
#pragma merger(0,"./bufaux.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 412 "/usr/include/openssl/bn.h"
extern BIGNUM *BN_bin2bn(unsigned char const   *s , int len , BIGNUM *ret ) ;
#line 413
extern int BN_bn2bin(BIGNUM const   *a , unsigned char *to ) ;
#line 37 "bufaux.c"
void buffer_put_bignum(Buffer *buffer , BIGNUM *value ) 
{ int bits ;
  int tmp ;
  int bin_size ;
  char *buf ;
  void *tmp___0 ;
  int oi ;
  char msg[2] ;

  {
#line 40
  tmp = BN_num_bits((BIGNUM const   *)value);
#line 40
  bits = tmp;
#line 41
  bin_size = (bits + 7) / 8;
#line 42
  tmp___0 = xmalloc((unsigned int )bin_size);
#line 42
  buf = (char *)tmp___0;
#line 47
  oi = BN_bn2bin((BIGNUM const   *)value, (unsigned char *)buf);
#line 48
  if (oi != bin_size) {
#line 49
    fatal("buffer_put_bignum: BN_bn2bin() failed: oi %d != bin_size %d", oi, bin_size);
  }
#line 53
  while (1) {
#line 53
    msg[0] = (char )(bits >> 8);
#line 53
    msg[1] = (char )bits;
#line 53
    break;
  }
#line 54
  buffer_append(buffer, (char const   *)(msg), 2U);
#line 56
  buffer_append(buffer, (char const   *)buf, (unsigned int )oi);
#line 58
  memset((void *)buf, 0, (unsigned int )bin_size);
#line 59
  xfree((void *)buf);
#line 60
  return;
}
}
#line 64 "bufaux.c"
int buffer_get_bignum(Buffer *buffer , BIGNUM *value ) 
{ int bits ;
  int bytes ;
  unsigned char buf[2] ;
  unsigned char *bin ;
  void *tmp ;

  {
#line 71
  buffer_get(buffer, (char *)(buf), 2U);
#line 72
  bits = (int )(((unsigned long )buf[0] << 8) | (unsigned long )buf[1]);
#line 74
  bytes = (bits + 7) / 8;
#line 75
  tmp = xmalloc((unsigned int )bytes);
#line 75
  bin = (unsigned char *)tmp;
#line 76
  buffer_get(buffer, (char *)bin, (unsigned int )bytes);
#line 77
  BN_bin2bn((unsigned char const   *)bin, bytes, value);
#line 78
  xfree((void *)bin);
#line 80
  return (2 + bytes);
}
}
#line 85 "bufaux.c"
unsigned int buffer_get_int(Buffer *buffer ) 
{ unsigned char buf[4] ;

  {
#line 88
  buffer_get(buffer, (char *)(buf), 4U);
#line 89
  return ((unsigned int )(((((unsigned long )buf[0] << 24) | ((unsigned long )buf[1] << 16)) | ((unsigned long )buf[2] << 8)) | (unsigned long )buf[3]));
}
}
#line 94 "bufaux.c"
void buffer_put_int(Buffer *buffer , unsigned int value ) 
{ char buf[4] ;

  {
#line 97
  while (1) {
#line 97
    buf[0] = (char )(value >> 24);
#line 97
    buf[1] = (char )(value >> 16);
#line 97
    buf[2] = (char )(value >> 8);
#line 97
    buf[3] = (char )value;
#line 97
    break;
  }
#line 98
  buffer_append(buffer, (char const   *)(buf), 4U);
#line 99
  return;
}
}
#line 108 "bufaux.c"
char *buffer_get_string(Buffer *buffer , unsigned int *length_ptr ) 
{ unsigned int len ;
  char *value ;
  void *tmp ;

  {
#line 113
  len = buffer_get_int(buffer);
#line 114
  if (len > 262144U) {
#line 115
    fatal("Received packet with bad string length %d", len);
  }
#line 117
  tmp = xmalloc(len + 1U);
#line 117
  value = (char *)tmp;
#line 119
  buffer_get(buffer, value, len);
#line 121
  *(value + len) = (char)0;
#line 123
  if (length_ptr) {
#line 124
    *length_ptr = len;
  }
#line 125
  return (value);
}
}
#line 130 "bufaux.c"
void buffer_put_string(Buffer *buffer , void const   *buf , unsigned int len ) 
{ 

  {
#line 132
  buffer_put_int(buffer, len);
#line 133
  buffer_append(buffer, (char const   *)buf, len);
#line 134
  return;
}
}
#line 138 "bufaux.c"
int buffer_get_char(Buffer *buffer ) 
{ char ch ;

  {
#line 141
  buffer_get(buffer, & ch, 1U);
#line 142
  return ((int )((unsigned char )ch));
}
}
#line 147 "bufaux.c"
void buffer_put_char(Buffer *buffer , int value ) 
{ char ch ;

  {
#line 149
  ch = (char )value;
#line 150
  buffer_append(buffer, (char const   *)(& ch), 1U);
#line 151
  return;
}
}
#line 1 "buffer.o"
#pragma merger(0,"./buffer.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 38 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                  size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 43
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 144 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 327
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 26 "xmalloc.h"
void *xrealloc(void *ptr , size_t new_size ) ;
#line 54 "buffer.h"
void buffer_consume(Buffer *buffer , unsigned int bytes ) ;
#line 57
void buffer_consume_end(Buffer *buffer , unsigned int bytes ) ;
#line 64
void buffer_dump(Buffer *buffer ) ;
#line 25 "buffer.c"
void buffer_init(Buffer *buffer ) 
{ void *tmp ;

  {
#line 27
  buffer->alloc = 4096U;
#line 28
  tmp = xmalloc(buffer->alloc);
#line 28
  buffer->buf = (char *)tmp;
#line 29
  buffer->offset = 0U;
#line 30
  buffer->end = 0U;
#line 31
  return;
}
}
#line 35 "buffer.c"
void buffer_free(Buffer *buffer ) 
{ 

  {
#line 37
  memset((void *)buffer->buf, 0, buffer->alloc);
#line 38
  xfree((void *)buffer->buf);
#line 39
  return;
}
}
#line 44 "buffer.c"
void buffer_clear(Buffer *buffer ) 
{ 

  {
#line 46
  buffer->offset = 0U;
#line 47
  buffer->end = 0U;
#line 48
  return;
}
}
#line 52 "buffer.c"
void buffer_append(Buffer *buffer , char const   *data , unsigned int len ) 
{ char *cp ;

  {
#line 55
  buffer_append_space(buffer, & cp, len);
#line 56
  memcpy((void * __restrict  )cp, (void const   * __restrict  )data, len);
#line 57
  return;
}
}
#line 63 "buffer.c"
void buffer_append_space(Buffer *buffer , char **datap , unsigned int len ) 
{ void *tmp ;

  {
#line 66
  if (buffer->offset == buffer->end) {
#line 68
    buffer->offset = 0U;
#line 69
    buffer->end = 0U;
  }
  restart: 
#line 74
  if (buffer->end + len < buffer->alloc) {
#line 76
    *datap = buffer->buf + buffer->end;
#line 77
    buffer->end += len;
#line 78
    return;
  }
#line 83
  if (buffer->offset > buffer->alloc / 2U) {
#line 85
    memmove((void *)buffer->buf, (void const   *)(buffer->buf + buffer->offset), buffer->end - buffer->offset);
#line 87
    buffer->end -= buffer->offset;
#line 88
    buffer->offset = 0U;
    goto restart;
  }
#line 93
  buffer->alloc += len + 32768U;
#line 94
  tmp = xrealloc((void *)buffer->buf, buffer->alloc);
#line 94
  buffer->buf = (char *)tmp;
  goto restart;
}
}
#line 100 "buffer.c"
unsigned int buffer_len(Buffer *buffer ) 
{ 

  {
#line 102
  return (buffer->end - buffer->offset);
}
}
#line 107 "buffer.c"
void buffer_get(Buffer *buffer , char *buf , unsigned int len ) 
{ 

  {
#line 109
  if (len > buffer->end - buffer->offset) {
#line 110
    fatal("buffer_get trying to get more bytes than in buffer");
  }
#line 111
  memcpy((void * __restrict  )buf, (void const   * __restrict  )(buffer->buf + buffer->offset),
         len);
#line 112
  buffer->offset += len;
#line 113
  return;
}
}
#line 117 "buffer.c"
void buffer_consume(Buffer *buffer , unsigned int bytes ) 
{ 

  {
#line 119
  if (bytes > buffer->end - buffer->offset) {
#line 120
    fatal("buffer_get trying to get more bytes than in buffer");
  }
#line 121
  buffer->offset += bytes;
#line 122
  return;
}
}
#line 126 "buffer.c"
void buffer_consume_end(Buffer *buffer , unsigned int bytes ) 
{ 

  {
#line 128
  if (bytes > buffer->end - buffer->offset) {
#line 129
    fatal("buffer_get trying to get more bytes than in buffer");
  }
#line 130
  buffer->end -= bytes;
#line 131
  return;
}
}
#line 135 "buffer.c"
char *buffer_ptr(Buffer *buffer ) 
{ 

  {
#line 137
  return (buffer->buf + buffer->offset);
}
}
#line 142 "buffer.c"
void buffer_dump(Buffer *buffer ) 
{ int i ;
  unsigned char *ucp ;

  {
#line 145
  ucp = (unsigned char *)buffer->buf;
#line 147
  i = (int )buffer->offset;
#line 147
  while ((unsigned int )i < buffer->end) {
#line 148
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" %02x", *(ucp + i));
#line 147
    i ++;
  }
#line 149
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 150
  return;
}
}
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
#line 1 "canohost.o"
#pragma merger(0,"./canohost.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 128 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int getpeername(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 185
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
#line 62 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 54 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
#line 131 "/usr/include/netdb.h"
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 138
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 352
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 335 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 83
extern __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 116
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 190
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 190 "/usr/include/ctype.h"
__inline static int tolower(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
#line 193
  if (__c >= -128) {
#line 193
    if (__c < 256) {
#line 193
      tmp___1 = __ctype_tolower_loc();
#line 193
      tmp___0 = *(*tmp___1 + __c);
    } else {
#line 193
      tmp___0 = (int const   )__c;
    }
  } else {
#line 193
    tmp___0 = (int const   )__c;
  }
#line 193
  return ((int )tmp___0);
}
}
#line 39 "packet.h"
int packet_get_connection_in(void) ;
#line 42
int packet_get_connection_out(void) ;
#line 131
void packet_disconnect(char const   *fmt  , ...) ;
#line 32 "xmalloc.h"
char *xstrdup(char const   *str ) ;
#line 312 "ssh.h"
char *get_remote_hostname(int socket___0 ) ;
#line 317
char const   *get_canonical_hostname(void) ;
#line 321
char const   *get_remote_ipaddr(void) ;
#line 324
int get_peer_port(int sock ) ;
#line 327
int get_remote_port(void) ;
#line 26 "canohost.c"
char *get_remote_hostname(int socket___0 ) 
{ struct sockaddr_in from ;
  int fromlen ;
  int i ;
  struct hostent *hp ;
  char name[64] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___3 ;
  char *tmp___5 ;
  int __res ;
  __int32_t const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  unsigned char options___0[200] ;
  unsigned char *ucp ;
  char text[1024] ;
  char *cp ;
  int option_size ;
  int ipproto ;
  struct protoent *ip ;
  char *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;

  {
#line 34
  fromlen = (int )sizeof(from);
#line 35
  memset((void *)(& from), 0, sizeof(from));
#line 36
  tmp___1 = getpeername(socket___0, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                        (socklen_t * __restrict  )(& fromlen));
#line 36
  if (tmp___1 < 0) {
#line 38
    tmp = __errno_location();
#line 38
    tmp___0 = strerror(*tmp);
#line 38
    error("getpeername failed: %.100s", tmp___0);
#line 39
    strlcpy(name, "UNKNOWN", sizeof(name));
    goto check_ip_options;
  }
#line 44
  hp = gethostbyaddr((void const   *)((char *)(& from.sin_addr)), sizeof(struct in_addr ),
                     (int )from.sin_family);
#line 46
  if (hp) {
#line 49
    tmp___5 = __builtin_strchr(hp->h_name, '.');
#line 49
    if ((unsigned int )tmp___5 != (unsigned int )((char *)0)) {
#line 50
      strlcpy(name, (char const   *)hp->h_name, sizeof(name));
    } else {
#line 51
      if ((unsigned int )hp->h_aliases != (unsigned int )((char **)0)) {
#line 51
        if ((unsigned int )*(hp->h_aliases + 0) != (unsigned int )((char *)0)) {
#line 51
          tmp___3 = __builtin_strchr(*(hp->h_aliases + 0), '.');
#line 51
          if ((unsigned int )tmp___3 != (unsigned int )((char *)0)) {
#line 54
            strlcpy(name, (char const   *)*(hp->h_aliases + 0), sizeof(name));
          } else {
#line 56
            strlcpy(name, (char const   *)hp->h_name, sizeof(name));
          }
        } else {
#line 56
          strlcpy(name, (char const   *)hp->h_name, sizeof(name));
        }
      } else {
#line 56
        strlcpy(name, (char const   *)hp->h_name, sizeof(name));
      }
    }
#line 60
    i = 0;
#line 60
    while (name[i]) {
#line 61
      tmp___9 = __ctype_b_loc();
#line 61
      if ((int const   )*(*tmp___9 + (int )name[i]) & 256) {
#line 62
        if (sizeof(name[i]) > 1U) {
#line 62
          __res = tolower((int )name[i]);
        } else {
#line 62
          tmp___8 = __ctype_tolower_loc();
#line 62
          __res = (int )*(*tmp___8 + (int )name[i]);
        }
#line 62
        name[i] = (char )__res;
      }
#line 60
      i ++;
    }
#line 70
    hp = gethostbyname((char const   *)(name));
#line 71
    if (! hp) {
#line 73
      log("reverse mapping checking gethostbyname for %.700s failed - POSSIBLE BREAKIN ATTEMPT!",
          name);
#line 74
      tmp___10 = inet_ntoa(from.sin_addr);
#line 74
      strlcpy(name, (char const   *)tmp___10, sizeof(name));
      goto check_ip_options;
    }
#line 78
    i = 0;
#line 78
    while (*(hp->h_addr_list + i)) {
#line 79
      tmp___11 = memcmp((void const   *)*(hp->h_addr_list + i), (void const   *)(& from.sin_addr),
                        sizeof(from.sin_addr));
#line 79
      if (tmp___11 == 0) {
#line 81
        break;
      }
#line 78
      i ++;
    }
#line 83
    if (! *(hp->h_addr_list + i)) {
#line 86
      tmp___12 = inet_ntoa(from.sin_addr);
#line 86
      log("Address %.100s maps to %.600s, but this does not map back to the address - POSSIBLE BREAKIN ATTEMPT!",
          tmp___12, name);
#line 88
      tmp___13 = inet_ntoa(from.sin_addr);
#line 88
      strlcpy(name, (char const   *)tmp___13, sizeof(name));
      goto check_ip_options;
    }
  } else {
#line 96
    tmp___14 = inet_ntoa(from.sin_addr);
#line 96
    strlcpy(name, (char const   *)tmp___14, sizeof(name));
#line 97
    log("Could not reverse map address %.100s.", name);
  }
  check_ip_options: 
#line 116
  ip = getprotobyname("ip");
#line 116
  if ((unsigned int )ip != (unsigned int )((void *)0)) {
#line 117
    ipproto = ip->p_proto;
  } else {
#line 119
    ipproto = 0;
  }
#line 120
  option_size = (int )sizeof(options___0);
#line 121
  tmp___17 = getsockopt(0, ipproto, 4, (void * __restrict  )((char *)(options___0)),
                        (socklen_t * __restrict  )(& option_size));
#line 121
  if (tmp___17 >= 0) {
#line 121
    if (option_size != 0) {
#line 124
      cp = text;
#line 126
      ucp = options___0;
#line 126
      while (option_size > 0) {
#line 127
        sprintf((char * __restrict  )cp, (char const   * __restrict  )" %2.2x", *ucp);
#line 126
        ucp ++;
#line 126
        option_size --;
#line 126
        cp += 3;
      }
#line 128
      tmp___15 = inet_ntoa(from.sin_addr);
#line 128
      log("Connection from %.100s with IP options:%.800s", tmp___15, text);
#line 130
      tmp___16 = inet_ntoa(from.sin_addr);
#line 130
      packet_disconnect("Connection from %.100s with IP options:%.800s", tmp___16,
                        text);
    }
  }
#line 135
  tmp___18 = xstrdup((char const   *)(name));
#line 135
  return (tmp___18);
}
}
#line 138 "canohost.c"
static char *canonical_host_name  =    (char *)((void *)0);
#line 139 "canohost.c"
static char *canonical_host_ip  =    (char *)((void *)0);
#line 145 "canohost.c"
char const   *get_canonical_hostname(void) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 148
  if ((unsigned int )canonical_host_name != (unsigned int )((void *)0)) {
#line 149
    return ((char const   *)canonical_host_name);
  }
#line 152
  tmp___0 = packet_get_connection_in();
#line 152
  tmp___1 = packet_get_connection_out();
#line 152
  if (tmp___0 == tmp___1) {
#line 153
    tmp = packet_get_connection_in();
#line 153
    canonical_host_name = get_remote_hostname(tmp);
  } else {
#line 155
    canonical_host_name = xstrdup("UNKNOWN");
  }
#line 157
  return ((char const   *)canonical_host_name);
}
}
#line 163 "canohost.c"
char const   *get_remote_ipaddr(void) 
{ struct sockaddr_in from ;
  int fromlen ;
  int socket___0 ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
#line 169
  if ((unsigned int )canonical_host_ip != (unsigned int )((void *)0)) {
#line 170
    return ((char const   *)canonical_host_ip);
  }
#line 173
  tmp = packet_get_connection_in();
#line 173
  tmp___0 = packet_get_connection_out();
#line 173
  if (tmp != tmp___0) {
#line 175
    canonical_host_ip = xstrdup("UNKNOWN");
#line 176
    return ((char const   *)canonical_host_ip);
  }
#line 180
  socket___0 = packet_get_connection_in();
#line 183
  fromlen = (int )sizeof(from);
#line 184
  memset((void *)(& from), 0, sizeof(from));
#line 185
  tmp___3 = getpeername(socket___0, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                        (socklen_t * __restrict  )(& fromlen));
#line 185
  if (tmp___3 < 0) {
#line 187
    tmp___1 = __errno_location();
#line 187
    tmp___2 = strerror(*tmp___1);
#line 187
    error("getpeername failed: %.100s", tmp___2);
#line 188
    return ((char const   *)((void *)0));
  }
#line 192
  tmp___4 = inet_ntoa(from.sin_addr);
#line 192
  canonical_host_ip = xstrdup((char const   *)tmp___4);
#line 195
  return ((char const   *)canonical_host_ip);
}
}
#line 200 "canohost.c"
int get_peer_port(int sock ) 
{ struct sockaddr_in from ;
  int fromlen ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  register unsigned short __v ;
  register unsigned short __x ;

  {
#line 206
  fromlen = (int )sizeof(from);
#line 207
  memset((void *)(& from), 0, sizeof(from));
#line 208
  tmp___1 = getpeername(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                        (socklen_t * __restrict  )(& fromlen));
#line 208
  if (tmp___1 < 0) {
#line 210
    tmp = __errno_location();
#line 210
    tmp___0 = strerror(*tmp);
#line 210
    error("getpeername failed: %.100s", tmp___0);
#line 211
    return (0);
  }
#line 215
  __x = from.sin_port;
#line 215
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 215
  return ((int )__v);
}
}
#line 220 "canohost.c"
int get_remote_port(void) 
{ int socket___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 226
  tmp = packet_get_connection_in();
#line 226
  tmp___0 = packet_get_connection_out();
#line 226
  if (tmp != tmp___0) {
#line 227
    return (65535);
  }
#line 230
  socket___0 = packet_get_connection_in();
#line 233
  tmp___1 = get_peer_port(socket___0);
#line 233
  return (tmp___1);
}
}
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned int  ) ;  */
#line 1 "channels.o"
#pragma merger(0,"./channels.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 110 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  *__addr ,
                                              socklen_t __len ) ;
#line 199
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 209
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 218
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
#line 84 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strcpy(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 102
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 170
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 35 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t inet_addr(char const   *__cp ) ;
#line 357 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 407
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 290
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   * __restrict  __nptr ,
                                                            char ** __restrict  __endptr ,
                                                            int __base , int __group )  __attribute__((__nonnull__(1))) ;
#line 332
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 332 "/usr/include/stdlib.h"
__inline static long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                            int __base ) 
{ long tmp ;

  {
#line 336
  tmp = __strtol_internal(__nptr, __endptr, __base, 0);
#line 336
  return (tmp);
}
}
#line 401
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 401 "/usr/include/stdlib.h"
__inline static int atoi(char const   *__nptr ) 
{ long tmp ;

  {
#line 404
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 404
  return ((int )tmp);
}
}
#line 632
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) )  __attribute__((__nonnull__(1))) ;
#line 729
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template )  __attribute__((__nonnull__(1))) ;
#line 573 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 801
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 845
extern  __attribute__((__nothrow__)) int gethostname(char *__name , size_t __len )  __attribute__((__nonnull__(1))) ;
#line 430 "ssh.h"
void fatal_add_cleanup(void (*proc)(void *context ) , void *context ) ;
#line 438
void channel_set_options(int hostname_in_open ) ;
#line 443
int channel_allocate(int type , int sock , char *remote_name ) ;
#line 446
void channel_free(int channel ) ;
#line 449
void channel_prepare_select(fd_set *readset , fd_set *writeset ) ;
#line 453
void channel_after_select(fd_set *readset , fd_set *writeset ) ;
#line 456
void channel_output_poll(void) ;
#line 461
void channel_input_data(int payload_len ) ;
#line 464
int channel_not_very_much_buffered_data(void) ;
#line 467
void channel_input_close(void) ;
#line 470
void channel_input_close_confirmation(void) ;
#line 473
void channel_input_open_confirmation(void) ;
#line 476
void channel_input_open_failure(void) ;
#line 480
void channel_stop_listening(void) ;
#line 484
void channel_close_all(void) ;
#line 487
int channel_max_fd(void) ;
#line 490
int channel_still_open(void) ;
#line 495
char *channel_open_message(void) ;
#line 500
void channel_request_local_forwarding(int port , char const   *host , int host_port ) ;
#line 507
void channel_request_remote_forwarding(int port , char const   *host , int remote_port ) ;
#line 513
void channel_permit_all_opens(void) ;
#line 519
void channel_input_port_forward_request(int is_root ) ;
#line 524
void channel_input_port_open(int payload_len ) ;
#line 533
char *x11_create_display_inet(int screen_number ) ;
#line 538
void x11_input_open(int payload_len ) ;
#line 546
void x11_request_forwarding_with_spoofing(char const   *proto , char const   *data ) ;
#line 552
void auth_request_forwarding(void) ;
#line 557
char *auth_get_socket_name(void) ;
#line 561
void auth_input_request_forwarding(struct passwd *pw ) ;
#line 564
void auth_input_open_request(void) ;
#line 70 "packet.h"
int packet_is_interactive(void) ;
#line 73
void packet_start(int type ) ;
#line 79
void packet_put_int(unsigned int value ) ;
#line 85
void packet_put_string(char const   *buf , unsigned int len ) ;
#line 89
void packet_send(void) ;
#line 96
void packet_read_expect(int *payload_len_ptr , int expected_type ) ;
#line 115
unsigned int packet_get_int(void) ;
#line 125
char *packet_get_string(unsigned int *length_ptr ) ;
#line 148
void packet_write_wait(void) ;
#line 20 "uidswap.h"
void temporarily_use_uid(uid_t uid ) ;
#line 24
void restore_uid(void) ;
#line 47 "nchan.h"
void chan_rcvd_oclose(Channel *c ) ;
#line 48
void chan_read_failed(Channel *c ) ;
#line 49
void chan_ibuf_empty(Channel *c ) ;
#line 52
void chan_rcvd_ieof(Channel *c ) ;
#line 53
void chan_write_failed(Channel *c ) ;
#line 54
void chan_obuf_empty(Channel *c ) ;
#line 56
void chan_init_iostates(Channel *c ) ;
#line 6 "compat.h"
int compat13 ;
#line 41 "channels.c"
static Channel *channels  =    (Channel *)((void *)0);
#line 46 "channels.c"
static int channels_alloc  =    0;
#line 50 "channels.c"
static int channel_max_fd_value  =    0;
#line 53 "channels.c"
static char *channel_forwarded_auth_socket_name  =    (char *)((void *)0);
#line 54 "channels.c"
static char *channel_forwarded_auth_socket_dir  =    (char *)((void *)0);
#line 57 "channels.c"
char *x11_saved_proto  =    (char *)((void *)0);
#line 60 "channels.c"
char *x11_saved_data  =    (char *)((void *)0);
#line 61 "channels.c"
unsigned int x11_saved_data_len  =    0U;
#line 65 "channels.c"
char *x11_fake_data  =    (char *)((void *)0);
#line 66 "channels.c"
unsigned int x11_fake_data_len  ;
#line 79 "channels.c"
static ForwardPermission permitted_opens[100]  ;
#line 81 "channels.c"
static int num_permitted_opens  =    0;
#line 85 "channels.c"
static int all_opens_permitted  =    0;
#line 88 "channels.c"
static int have_hostname_in_open  =    0;
#line 92 "channels.c"
void channel_set_options(int hostname_in_open ) 
{ 

  {
#line 94
  have_hostname_in_open = hostname_in_open;
#line 95
  return;
}
}
#line 101 "channels.c"
void channel_permit_all_opens(void) 
{ 

  {
#line 103
  all_opens_permitted = 1;
#line 104
  return;
}
}
#line 109 "channels.c"
int channel_allocate(int type , int sock , char *remote_name ) 
{ int i ;
  int found ;
  Channel *c ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 115
  if (sock > channel_max_fd_value) {
#line 116
    channel_max_fd_value = sock;
  }
#line 119
  if (channels_alloc == 0) {
#line 121
    channels_alloc = 10;
#line 122
    tmp = xmalloc((unsigned int )channels_alloc * sizeof(Channel ));
#line 122
    channels = (Channel *)tmp;
#line 123
    i = 0;
#line 123
    while (i < channels_alloc) {
#line 124
      (channels + i)->type = 0;
#line 123
      i ++;
    }
#line 128
    fatal_add_cleanup((void (*)(void * ))(& channel_stop_listening), (void *)0);
  }
#line 132
  found = -1;
#line 132
  i = 0;
#line 132
  while (i < channels_alloc) {
#line 133
    if ((channels + i)->type == 0) {
#line 136
      found = i;
#line 137
      break;
    }
#line 132
    i ++;
  }
#line 140
  if (found == -1) {
#line 143
    found = channels_alloc;
#line 144
    channels_alloc += 10;
#line 145
    debug("channel: expanding %d", channels_alloc);
#line 146
    tmp___0 = xrealloc((void *)channels, (unsigned int )channels_alloc * sizeof(Channel ));
#line 146
    channels = (Channel *)tmp___0;
#line 147
    i = found;
#line 147
    while (i < channels_alloc) {
#line 148
      (channels + i)->type = 0;
#line 147
      i ++;
    }
  }
#line 152
  c = channels + found;
#line 153
  buffer_init(& c->input);
#line 154
  buffer_init(& c->output);
#line 155
  chan_init_iostates(c);
#line 156
  c->self = found;
#line 157
  c->type = type;
#line 158
  c->sock = sock;
#line 159
  c->remote_id = -1;
#line 160
  c->remote_name = remote_name;
#line 161
  debug("channel %d: new [%s]", found, remote_name);
#line 162
  return (found);
}
}
#line 167 "channels.c"
void channel_free(int channel ) 
{ 

  {
#line 169
  if (channel < 0) {
#line 171
    packet_disconnect("channel free: bad local channel %d", channel);
  } else {
#line 169
    if (channel >= channels_alloc) {
#line 171
      packet_disconnect("channel free: bad local channel %d", channel);
    } else {
#line 169
      if ((channels + channel)->type == 0) {
#line 171
        packet_disconnect("channel free: bad local channel %d", channel);
      }
    }
  }
#line 173
  if (compat13) {
#line 174
    shutdown((channels + channel)->sock, 2);
  }
#line 175
  close((channels + channel)->sock);
#line 176
  buffer_free(& (channels + channel)->input);
#line 177
  buffer_free(& (channels + channel)->output);
#line 178
  (channels + channel)->type = 0;
#line 179
  if ((channels + channel)->remote_name) {
#line 181
    xfree((void *)(channels + channel)->remote_name);
#line 182
    (channels + channel)->remote_name = (char *)((void *)0);
  }
#line 184
  return;
}
}
#line 189 "channels.c"
void channel_prepare_select(fd_set *readset , fd_set *writeset ) 
{ int i ;
  Channel *ch ;
  unsigned char *ucp ;
  unsigned int proto_len ;
  unsigned int data_len ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  char *tmp___6 ;
  unsigned int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 196
  i = 0;
#line 196
  while (i < channels_alloc) {
#line 198
    ch = channels + i;
    redo: 
#line 200
    switch (ch->type) {
    case 1: 
    case 2: 
    case 7: 
#line 205
    __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 206
    break;
    case 4: 
#line 209
    if (compat13) {
#line 210
      tmp = buffer_len(& ch->input);
#line 210
      if (tmp < 32768U) {
#line 211
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
#line 212
      tmp___0 = buffer_len(& ch->output);
#line 212
      if (tmp___0 > 0U) {
#line 213
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
#line 214
      break;
    }
#line 217
    if (ch->istate == 1) {
#line 218
      tmp___1 = buffer_len(& ch->input);
#line 218
      if (tmp___1 < 32768U) {
#line 219
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
#line 220
    if (ch->ostate == 16) {
      goto _L;
    } else {
#line 220
      if (ch->ostate == 32) {
        _L: /* CIL Label */ 
#line 221
        tmp___2 = buffer_len(& ch->output);
#line 221
        if (tmp___2 > 0U) {
#line 222
          __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        } else {
#line 223
          if (ch->ostate == 32) {
#line 224
            chan_obuf_empty(ch);
          }
        }
      }
    }
#line 227
    break;
    case 10: 
#line 230
    if (! compat13) {
#line 231
      fatal("cannot happen: IN_DRAIN");
    }
#line 232
    tmp___3 = buffer_len(& ch->input);
#line 232
    if (tmp___3 == 0U) {
#line 234
      packet_start(24);
#line 235
      packet_put_int((unsigned int )ch->remote_id);
#line 236
      packet_send();
#line 237
      ch->type = 5;
#line 238
      debug("Closing channel %d after input drain.", i);
#line 239
      break;
    }
#line 241
    break;
    case 11: 
#line 244
    if (! compat13) {
#line 245
      fatal("cannot happen: OUT_DRAIN");
    }
#line 246
    tmp___4 = buffer_len(& ch->output);
#line 246
    if (tmp___4 == 0U) {
#line 249
      channel_free(i);
#line 250
      break;
    }
#line 252
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 253
    break;
    case 9: 
#line 264
    tmp___5 = buffer_len(& ch->output);
#line 264
    if (tmp___5 < 12U) {
#line 265
      break;
    }
#line 268
    tmp___6 = buffer_ptr(& ch->output);
#line 268
    ucp = (unsigned char *)tmp___6;
#line 269
    if ((int )*(ucp + 0) == 66) {
#line 271
      proto_len = (unsigned int )(256 * (int )*(ucp + 6) + (int )*(ucp + 7));
#line 272
      data_len = (unsigned int )(256 * (int )*(ucp + 8) + (int )*(ucp + 9));
    } else {
#line 275
      if ((int )*(ucp + 0) == 108) {
#line 277
        proto_len = (unsigned int )((int )*(ucp + 6) + 256 * (int )*(ucp + 7));
#line 278
        data_len = (unsigned int )((int )*(ucp + 8) + 256 * (int )*(ucp + 9));
      } else {
#line 282
        debug("Initial X11 packet contains bad byte order byte: 0x%x", *(ucp + 0));
#line 284
        ch->type = 4;
        goto reject;
      }
    }
#line 289
    tmp___7 = buffer_len(& ch->output);
#line 289
    if (tmp___7 < (12U + ((proto_len + 3U) & 4294967292U)) + ((data_len + 3U) & 4294967292U)) {
#line 291
      break;
    }
#line 294
    tmp___8 = strlen((char const   *)x11_saved_proto);
#line 294
    if (proto_len != tmp___8) {
#line 297
      debug("X11 connection uses different authentication protocol.");
#line 298
      ch->type = 4;
      goto reject;
    } else {
#line 294
      tmp___9 = memcmp((void const   *)(ucp + 12), (void const   *)x11_saved_proto,
                       proto_len);
#line 294
      if (tmp___9 != 0) {
#line 297
        debug("X11 connection uses different authentication protocol.");
#line 298
        ch->type = 4;
        goto reject;
      }
    }
#line 303
    if (data_len != x11_fake_data_len) {
#line 307
      debug("X11 auth data does not match fake data.");
#line 308
      ch->type = 4;
      goto reject;
    } else {
#line 303
      tmp___10 = memcmp((void const   *)((ucp + 12) + ((proto_len + 3U) & 4294967292U)),
                        (void const   *)x11_fake_data, x11_fake_data_len);
#line 303
      if (tmp___10 != 0) {
#line 307
        debug("X11 auth data does not match fake data.");
#line 308
        ch->type = 4;
        goto reject;
      }
    }
#line 313
    if (x11_fake_data_len != x11_saved_data_len) {
#line 315
      error("X11 fake_data_len %d != saved_data_len %d", x11_fake_data_len, x11_saved_data_len);
#line 317
      ch->type = 4;
      goto reject;
    }
#line 323
    memcpy((void * __restrict  )((ucp + 12) + ((proto_len + 3U) & 4294967292U)), (void const   * __restrict  )x11_saved_data,
           x11_saved_data_len);
#line 327
    ch->type = 4;
    goto redo;
    reject: 
#line 333
    log("X11 connection rejected because of wrong authentication.\r\n");
#line 334
    buffer_clear(& ch->input);
#line 335
    buffer_clear(& ch->output);
#line 336
    if (compat13) {
#line 337
      close(ch->sock);
#line 338
      ch->sock = -1;
#line 339
      ch->type = 5;
#line 340
      packet_start(24);
#line 341
      packet_put_int((unsigned int )ch->remote_id);
#line 342
      packet_send();
    } else {
#line 344
      debug("X11 rejected %d i%d/o%d", ch->self, ch->istate, ch->ostate);
#line 345
      chan_read_failed(ch);
#line 346
      chan_write_failed(ch);
#line 347
      debug("X11 rejected %d i%d/o%d", ch->self, ch->istate, ch->ostate);
    }
#line 349
    break;
    case 0: 
    default: ;
    goto __Cont;
    }
    __Cont: /* CIL Label */ 
#line 196
    i ++;
  }
#line 356
  return;
}
}
#line 361 "channels.c"
void channel_after_select(fd_set *readset , fd_set *writeset ) 
{ struct sockaddr addr ;
  int addrlen ;
  int newsock ;
  int i ;
  int newch ;
  int len ;
  Channel *ch ;
  char buf[16384] ;
  char *remote_hostname ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  register char __result ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  register char __result___0 ;
  int nchan ;
  int *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  register char __result___1 ;
  unsigned int tmp___13 ;
  register char __result___2 ;
  unsigned int tmp___14 ;
  char *tmp___15 ;
  unsigned int tmp___16 ;
  register char __result___3 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  char *tmp___19 ;
  unsigned int tmp___20 ;
  register char __result___4 ;
  unsigned int tmp___21 ;

  {
#line 369
  i = 0;
#line 369
  while (i < channels_alloc) {
#line 371
    ch = channels + i;
#line 372
    switch (ch->type) {
    case 1: 
#line 376
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 376
    if (__result) {
#line 378
      debug("X11 connection requested.");
#line 379
      addrlen = (int )sizeof(addr);
#line 380
      newsock = accept(ch->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 381
      if (newsock < 0) {
#line 383
        tmp = __errno_location();
#line 383
        tmp___0 = strerror(*tmp);
#line 383
        error("accept: %.100s", tmp___0);
#line 384
        break;
      }
#line 386
      remote_hostname = get_remote_hostname(newsock);
#line 387
      tmp___1 = get_peer_port(newsock);
#line 387
      snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"X11 connection from %.200s port %d",
               remote_hostname, tmp___1);
#line 389
      xfree((void *)remote_hostname);
#line 390
      tmp___2 = xstrdup((char const   *)(buf));
#line 390
      newch = channel_allocate(3, newsock, tmp___2);
#line 392
      packet_start(27);
#line 393
      packet_put_int((unsigned int )newch);
#line 394
      if (have_hostname_in_open) {
#line 395
        tmp___3 = strlen((char const   *)(buf));
#line 395
        packet_put_string((char const   *)(buf), tmp___3);
      }
#line 396
      packet_send();
    }
#line 398
    break;
    case 2: 
#line 403
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 403
    if (__result___0) {
#line 405
      debug("Connection to port %d forwarding to %.100s:%d requested.", ch->listening_port,
            ch->path, ch->host_port);
#line 407
      addrlen = (int )sizeof(addr);
#line 408
      newsock = accept(ch->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 409
      if (newsock < 0) {
#line 411
        tmp___4 = __errno_location();
#line 411
        tmp___5 = strerror(*tmp___4);
#line 411
        error("accept: %.100s", tmp___5);
#line 412
        break;
      }
#line 414
      remote_hostname = get_remote_hostname(newsock);
#line 415
      tmp___6 = get_peer_port(newsock);
#line 415
      snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"listen port %d:%.100s:%d, connect from %.200s:%d",
               ch->listening_port, ch->path, ch->host_port, remote_hostname, tmp___6);
#line 418
      xfree((void *)remote_hostname);
#line 419
      tmp___7 = xstrdup((char const   *)(buf));
#line 419
      newch = channel_allocate(3, newsock, tmp___7);
#line 421
      packet_start(29);
#line 422
      packet_put_int((unsigned int )newch);
#line 423
      tmp___8 = strlen((char const   *)(ch->path));
#line 423
      packet_put_string((char const   *)(ch->path), tmp___8);
#line 424
      packet_put_int((unsigned int )ch->host_port);
#line 425
      if (have_hostname_in_open) {
#line 426
        tmp___9 = strlen((char const   *)(buf));
#line 426
        packet_put_string((char const   *)(buf), tmp___9);
      }
#line 427
      packet_send();
    }
#line 429
    break;
    case 7: 
#line 434
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___1): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 434
    if (__result___1) {
#line 437
      len = (int )sizeof(addr);
#line 438
      newsock = accept(ch->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& len));
#line 439
      if (newsock < 0) {
#line 441
        tmp___10 = __errno_location();
#line 441
        tmp___11 = strerror(*tmp___10);
#line 441
        error("accept from auth socket: %.100s", tmp___11);
#line 442
        break;
      }
#line 445
      tmp___12 = xstrdup("accepted auth socket");
#line 445
      nchan = channel_allocate(3, newsock, tmp___12);
#line 447
      packet_start(31);
#line 448
      packet_put_int((unsigned int )nchan);
#line 449
      packet_send();
    }
#line 451
    break;
    case 4: 
#line 460
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___2): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 460
    if (__result___2) {
#line 462
      len = read(ch->sock, (void *)(buf), sizeof(buf));
#line 463
      if (len <= 0) {
#line 465
        if (compat13) {
#line 466
          tmp___13 = buffer_len(& ch->output);
#line 466
          buffer_consume(& ch->output, tmp___13);
#line 467
          ch->type = 10;
#line 468
          debug("Channel %d status set to input draining.", i);
        } else {
#line 470
          chan_read_failed(ch);
        }
#line 472
        break;
      }
#line 474
      buffer_append(& ch->input, (char const   *)(buf), (unsigned int )len);
    }
#line 477
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___3): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))),
                         "m" (writeset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 477
    if (__result___3) {
#line 477
      tmp___17 = buffer_len(& ch->output);
#line 477
      if (tmp___17 > 0U) {
#line 479
        tmp___14 = buffer_len(& ch->output);
#line 479
        tmp___15 = buffer_ptr(& ch->output);
#line 479
        len = write(ch->sock, (void const   *)tmp___15, tmp___14);
#line 481
        if (len <= 0) {
#line 483
          if (compat13) {
#line 484
            tmp___16 = buffer_len(& ch->output);
#line 484
            buffer_consume(& ch->output, tmp___16);
#line 485
            debug("Channel %d status set to input draining.", i);
#line 486
            ch->type = 10;
          } else {
#line 488
            chan_write_failed(ch);
          }
#line 490
          break;
        }
#line 492
        buffer_consume(& ch->output, (unsigned int )len);
      }
    }
#line 494
    break;
    case 11: 
#line 497
    if (! compat13) {
#line 498
      fatal("cannot happen: OUT_DRAIN");
    }
#line 500
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___4): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))),
                         "m" (writeset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 500
    if (__result___4) {
#line 500
      tmp___21 = buffer_len(& ch->output);
#line 500
      if (tmp___21 > 0U) {
#line 502
        tmp___18 = buffer_len(& ch->output);
#line 502
        tmp___19 = buffer_ptr(& ch->output);
#line 502
        len = write(ch->sock, (void const   *)tmp___19, tmp___18);
#line 504
        if (len <= 0) {
#line 505
          tmp___20 = buffer_len(& ch->output);
#line 505
          buffer_consume(& ch->output, tmp___20);
        } else {
#line 507
          buffer_consume(& ch->output, (unsigned int )len);
        }
      }
    }
#line 509
    break;
    case 9: 
    case 0: 
    default: ;
    goto __Cont;
    }
    __Cont: /* CIL Label */ 
#line 369
    i ++;
  }
#line 517
  return;
}
}
#line 521 "channels.c"
void channel_output_poll(void) 
{ int len ;
  int i ;
  Channel *ch ;
  unsigned int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 526
  i = 0;
#line 526
  while (i < channels_alloc) {
#line 528
    ch = channels + i;
#line 531
    if (ch->type != 4) {
#line 531
      if (ch->type != 10) {
        goto __Cont;
      }
    }
#line 536
    tmp = buffer_len(& ch->input);
#line 536
    len = (int )tmp;
#line 537
    if (len > 0) {
#line 540
      tmp___0 = packet_is_interactive();
#line 540
      if (tmp___0) {
#line 542
        if (len > 1024) {
#line 543
          len = 512;
        }
      } else {
#line 547
        if (len > 16384) {
#line 548
          len = 16384;
        }
      }
#line 550
      packet_start(23);
#line 551
      packet_put_int((unsigned int )ch->remote_id);
#line 552
      tmp___1 = buffer_ptr(& ch->input);
#line 552
      packet_put_string((char const   *)tmp___1, (unsigned int )len);
#line 553
      packet_send();
#line 554
      buffer_consume(& ch->input, (unsigned int )len);
    } else {
#line 556
      if (ch->istate == 2) {
#line 558
        if (compat13) {
#line 559
          fatal("cannot happen: istate == INPUT_WAIT_DRAIN for proto 1.3");
        }
#line 562
        chan_ibuf_empty(ch);
      }
    }
    __Cont: /* CIL Label */ 
#line 526
    i ++;
  }
#line 565
  return;
}
}
#line 571 "channels.c"
void channel_input_data(int payload_len ) 
{ int channel ;
  char *data ;
  unsigned int data_len ;
  unsigned int tmp ;
  int _p ;
  int _e ;

  {
#line 578
  tmp = packet_get_int();
#line 578
  channel = (int )tmp;
#line 579
  if (channel < 0) {
#line 581
    packet_disconnect("Received data for nonexistent channel %d.", channel);
  } else {
#line 579
    if (channel >= channels_alloc) {
#line 581
      packet_disconnect("Received data for nonexistent channel %d.", channel);
    } else {
#line 579
      if ((channels + channel)->type == 0) {
#line 581
        packet_disconnect("Received data for nonexistent channel %d.", channel);
      }
    }
  }
#line 584
  if ((channels + channel)->type != 4) {
#line 584
    if ((channels + channel)->type != 9) {
#line 586
      return;
    }
  }
#line 589
  data = packet_get_string(& data_len);
#line 590
  while (1) {
#line 590
    _p = payload_len;
#line 590
    _e = (int )(8U + data_len);
#line 590
    if (_p != _e) {
#line 590
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 590);
#line 590
      packet_disconnect("Packet integrity error. (%d)", 23);
    }
#line 590
    break;
  }
#line 591
  buffer_append(& (channels + channel)->output, (char const   *)data, data_len);
#line 592
  xfree((void *)data);
#line 593
  return;
}
}
#line 598 "channels.c"
int channel_not_very_much_buffered_data(void) 
{ unsigned int i ;
  Channel *ch ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 603
  i = 0U;
#line 603
  while (i < (unsigned int )channels_alloc) {
#line 605
    ch = channels + i;
#line 606
    switch (ch->type) {
    case 1: 
    case 2: 
    case 7: 
    goto __Cont;
    case 4: 
#line 613
    tmp = buffer_len(& ch->input);
#line 613
    if (tmp > 32768U) {
#line 614
      return (0);
    }
#line 615
    tmp___0 = buffer_len(& ch->output);
#line 615
    if (tmp___0 > 32768U) {
#line 616
      return (0);
    }
    goto __Cont;
    case 10: 
    case 11: 
    case 9: 
    case 0: 
    default: ;
    goto __Cont;
    }
    __Cont: /* CIL Label */ 
#line 603
    i ++;
  }
#line 626
  return (1);
}
}
#line 631 "channels.c"
void channel_input_close(void) 
{ int channel ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 636
  tmp = packet_get_int();
#line 636
  channel = (int )tmp;
#line 637
  if (channel < 0) {
#line 639
    packet_disconnect("Received data for nonexistent channel %d.", channel);
  } else {
#line 637
    if (channel >= channels_alloc) {
#line 639
      packet_disconnect("Received data for nonexistent channel %d.", channel);
    } else {
#line 637
      if ((channels + channel)->type == 0) {
#line 639
        packet_disconnect("Received data for nonexistent channel %d.", channel);
      }
    }
  }
#line 641
  if (! compat13) {
#line 643
    chan_rcvd_ieof(channels + channel);
#line 644
    return;
  }
#line 649
  packet_start(25);
#line 650
  packet_put_int((unsigned int )(channels + channel)->remote_id);
#line 651
  packet_send();
#line 658
  if ((channels + channel)->type != 5) {
#line 662
    tmp___0 = buffer_len(& (channels + channel)->input);
#line 662
    buffer_consume(& (channels + channel)->input, tmp___0);
#line 664
    (channels + channel)->type = 11;
  }
#line 668
  return;
}
}
#line 672 "channels.c"
void channel_input_close_confirmation(void) 
{ int channel ;
  unsigned int tmp ;

  {
#line 677
  tmp = packet_get_int();
#line 677
  channel = (int )tmp;
#line 678
  if (channel < 0) {
#line 679
    packet_disconnect("Received close confirmation for out-of-range channel %d.",
                      channel);
  } else {
#line 678
    if (channel >= channels_alloc) {
#line 679
      packet_disconnect("Received close confirmation for out-of-range channel %d.",
                        channel);
    }
  }
#line 682
  if (! compat13) {
#line 684
    chan_rcvd_oclose(channels + channel);
#line 685
    return;
  }
#line 688
  if ((channels + channel)->type != 5) {
#line 689
    packet_disconnect("Received close confirmation for non-closed channel %d (type %d).",
                      channel, (channels + channel)->type);
  }
#line 693
  channel_free(channel);
#line 694
  return;
}
}
#line 698 "channels.c"
void channel_input_open_confirmation(void) 
{ int channel ;
  int remote_channel ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 703
  tmp = packet_get_int();
#line 703
  channel = (int )tmp;
#line 704
  if (channel < 0) {
#line 706
    packet_disconnect("Received open confirmation for non-opening channel %d.", channel);
  } else {
#line 704
    if (channel >= channels_alloc) {
#line 706
      packet_disconnect("Received open confirmation for non-opening channel %d.",
                        channel);
    } else {
#line 704
      if ((channels + channel)->type != 3) {
#line 706
        packet_disconnect("Received open confirmation for non-opening channel %d.",
                          channel);
      }
    }
  }
#line 710
  tmp___0 = packet_get_int();
#line 710
  remote_channel = (int )tmp___0;
#line 713
  (channels + channel)->remote_id = remote_channel;
#line 714
  (channels + channel)->type = 4;
#line 715
  return;
}
}
#line 719 "channels.c"
void channel_input_open_failure(void) 
{ int channel ;
  unsigned int tmp ;

  {
#line 724
  tmp = packet_get_int();
#line 724
  channel = (int )tmp;
#line 725
  if (channel < 0) {
#line 727
    packet_disconnect("Received open failure for non-opening channel %d.", channel);
  } else {
#line 725
    if (channel >= channels_alloc) {
#line 727
      packet_disconnect("Received open failure for non-opening channel %d.", channel);
    } else {
#line 725
      if ((channels + channel)->type != 3) {
#line 727
        packet_disconnect("Received open failure for non-opening channel %d.", channel);
      }
    }
  }
#line 731
  channel_free(channel);
#line 732
  return;
}
}
#line 737 "channels.c"
void channel_stop_listening(void) 
{ int i ;

  {
#line 740
  i = 0;
#line 740
  while (i < channels_alloc) {
#line 742
    switch ((channels + i)->type) {
    case 7: 
#line 745
    close((channels + i)->sock);
#line 746
    remove((char const   *)((channels + i)->path));
#line 747
    channel_free(i);
#line 748
    break;
    case 2: 
    case 1: 
#line 751
    close((channels + i)->sock);
#line 752
    channel_free(i);
#line 753
    break;
    default: ;
#line 755
    break;
    }
#line 740
    i ++;
  }
#line 758
  return;
}
}
#line 763 "channels.c"
void channel_close_all(void) 
{ int i ;

  {
#line 766
  i = 0;
#line 766
  while (i < channels_alloc) {
#line 768
    if ((channels + i)->type != 0) {
#line 769
      close((channels + i)->sock);
    }
#line 766
    i ++;
  }
#line 771
  return;
}
}
#line 775 "channels.c"
int channel_max_fd(void) 
{ 

  {
#line 777
  return (channel_max_fd_value);
}
}
#line 782 "channels.c"
int channel_still_open(void) 
{ unsigned int i ;

  {
#line 785
  i = 0U;
#line 785
  while (i < (unsigned int )channels_alloc) {
#line 786
    switch ((channels + i)->type) {
    case 0: 
    case 1: 
    case 2: 
    case 5: 
    case 7: 
    goto __Cont;
    case 3: 
    case 4: 
    case 9: 
#line 797
    return (1);
    case 10: 
    case 11: 
#line 800
    if (! compat13) {
#line 801
      fatal("cannot happen: OUT_DRAIN");
    }
#line 802
    return (1);
    default: 
#line 804
    fatal("channel_still_open: bad channel type %d", (channels + i)->type);
    }
    __Cont: /* CIL Label */ 
#line 785
    i ++;
  }
#line 807
  return (0);
}
}
#line 814 "channels.c"
char *channel_open_message(void) 
{ Buffer buffer ;
  int i ;
  char buf[512] ;
  char *cp ;
  size_t tmp ;
  Channel *c ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 820
  buffer_init(& buffer);
#line 821
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"The following connections are open:\r\n");
#line 822
  tmp = strlen((char const   *)(buf));
#line 822
  buffer_append(& buffer, (char const   *)(buf), tmp);
#line 823
  i = 0;
#line 823
  while (i < channels_alloc) {
#line 824
    c = channels + i;
#line 825
    switch (c->type) {
    case 0: 
    case 1: 
    case 2: 
    case 5: 
    case 7: 
    goto __Cont;
    case 3: 
    case 4: 
    case 9: 
    case 10: 
    case 11: 
#line 838
    snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"  #%d %.300s (t%d r%d i%d o%d)\r\n",
             c->self, c->remote_name, c->type, c->remote_id, c->istate, c->ostate);
#line 841
    tmp___0 = strlen((char const   *)(buf));
#line 841
    buffer_append(& buffer, (char const   *)(buf), tmp___0);
    goto __Cont;
    default: 
#line 844
    fatal("channel_still_open: bad channel type %d", c->type);
    }
    __Cont: /* CIL Label */ 
#line 823
    i ++;
  }
#line 848
  buffer_append(& buffer, "\000", 1U);
#line 849
  tmp___1 = buffer_ptr(& buffer);
#line 849
  cp = xstrdup((char const   *)tmp___1);
#line 850
  buffer_free(& buffer);
#line 851
  return (cp);
}
}
#line 857 "channels.c"
void channel_request_local_forwarding(int port , char const   *host , int host_port ) 
{ int ch ;
  int sock ;
  struct sockaddr_in sin ;
  size_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  register unsigned short __v ;
  register unsigned short __x ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;

  {
#line 864
  tmp = strlen(host);
#line 864
  if (tmp > sizeof((channels + 0)->path) - 1U) {
#line 865
    packet_disconnect("Forward host name too long.");
  }
#line 868
  sock = socket(2, 1, 0);
#line 869
  if (sock < 0) {
#line 870
    tmp___0 = __errno_location();
#line 870
    tmp___1 = strerror(*tmp___0);
#line 870
    packet_disconnect("socket: %.100s", tmp___1);
  }
#line 873
  memset((void *)(& sin), 0, sizeof(sin));
#line 874
  sin.sin_family = (unsigned short)2;
#line 879
  __x = (unsigned short )port;
#line 879
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 879
  sin.sin_port = __v;
#line 882
  tmp___4 = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sin)), sizeof(sin));
#line 882
  if (tmp___4 < 0) {
#line 883
    tmp___2 = __errno_location();
#line 883
    tmp___3 = strerror(*tmp___2);
#line 883
    packet_disconnect("bind: %.100s", tmp___3);
  }
#line 886
  tmp___7 = listen(sock, 5);
#line 886
  if (tmp___7 < 0) {
#line 887
    tmp___5 = __errno_location();
#line 887
    tmp___6 = strerror(*tmp___5);
#line 887
    packet_disconnect("listen: %.100s", tmp___6);
  }
#line 890
  tmp___8 = xstrdup("port listener");
#line 890
  ch = channel_allocate(2, sock, tmp___8);
#line 892
  strcpy((char * __restrict  )((channels + ch)->path), (char const   * __restrict  )host);
#line 893
  (channels + ch)->host_port = host_port;
#line 894
  (channels + ch)->listening_port = port;
#line 895
  return;
}
}
#line 900 "channels.c"
void channel_request_remote_forwarding(int port , char const   *host , int remote_port ) 
{ int payload_len ;
  size_t tmp ;

  {
#line 905
  if (num_permitted_opens >= 100) {
#line 906
    fatal("channel_request_remote_forwarding: too many forwards");
  }
#line 907
  permitted_opens[num_permitted_opens].host = xstrdup(host);
#line 908
  permitted_opens[num_permitted_opens].port = remote_port;
#line 909
  num_permitted_opens ++;
#line 912
  packet_start(28);
#line 913
  packet_put_int((unsigned int )port);
#line 914
  tmp = strlen(host);
#line 914
  packet_put_string(host, tmp);
#line 915
  packet_put_int((unsigned int )remote_port);
#line 916
  packet_send();
#line 917
  packet_write_wait();
#line 921
  packet_read_expect(& payload_len, 14);
#line 922
  return;
}
}
#line 929 "channels.c"
void channel_input_port_forward_request(int is_root ) 
{ int port ;
  int host_port ;
  char *hostname ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 935
  tmp = packet_get_int();
#line 935
  port = (int )tmp;
#line 936
  hostname = packet_get_string((unsigned int *)((void *)0));
#line 937
  tmp___0 = packet_get_int();
#line 937
  host_port = (int )tmp___0;
#line 940
  if ((port & 65535) != port) {
#line 941
    packet_disconnect("Requested forwarding of nonexistent port %d.", port);
  }
#line 945
  if (port < 1024) {
#line 945
    if (! is_root) {
#line 946
      packet_disconnect("Requested forwarding of port %d but user is not root.", port);
    }
  }
#line 950
  channel_request_local_forwarding(port, (char const   *)hostname, host_port);
#line 953
  xfree((void *)hostname);
#line 954
  return;
}
}
#line 960 "channels.c"
void channel_input_port_open(int payload_len ) 
{ int remote_channel ;
  int sock ;
  int newch ;
  int host_port ;
  int i ;
  struct sockaddr_in sin ;
  char *host ;
  char *originator_string ;
  struct hostent *hp ;
  int host_len ;
  int originator_len ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int _p ;
  int _e ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  register unsigned short __v ;
  register unsigned short __x ;
  int *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;

  {
#line 969
  tmp = packet_get_int();
#line 969
  remote_channel = (int )tmp;
#line 972
  host = packet_get_string((unsigned int *)(& host_len));
#line 975
  tmp___0 = packet_get_int();
#line 975
  host_port = (int )tmp___0;
#line 978
  if (have_hostname_in_open) {
#line 979
    originator_string = packet_get_string((unsigned int *)(& originator_len));
  } else {
#line 981
    originator_string = xstrdup("unknown (remote did not supply name)");
  }
#line 983
  while (1) {
#line 983
    _p = payload_len;
#line 983
    _e = (((8 + host_len) + 4) + 4) + originator_len;
#line 983
    if (_p != _e) {
#line 983
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 985);
#line 983
      packet_disconnect("Packet integrity error. (%d)", 29);
    }
#line 983
    break;
  }
#line 988
  if (! all_opens_permitted) {
#line 991
    i = 0;
#line 991
    while (i < num_permitted_opens) {
#line 993
      if (permitted_opens[i].port == host_port) {
#line 993
        if (0) {
#line 993
          __s1_len = strlen((char const   *)permitted_opens[i].host);
#line 993
          __s2_len = strlen((char const   *)host);
#line 993
          if (! ((unsigned int )((void const   *)(permitted_opens[i].host + 1)) - (unsigned int )((void const   *)permitted_opens[i].host) == 1U)) {
            goto _L___0;
          } else {
#line 993
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 993
              if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
#line 993
                tmp___10 = 1;
              } else {
#line 993
                if (__s2_len >= 4U) {
#line 993
                  tmp___10 = 1;
                } else {
#line 993
                  tmp___10 = 0;
                }
              }
            } else {
#line 993
              tmp___10 = 0;
            }
          }
#line 993
          if (tmp___10) {
#line 993
            tmp___6 = __builtin_strcmp((char const   *)permitted_opens[i].host, (char const   *)host);
          } else {
#line 993
            tmp___9 = __builtin_strcmp((char const   *)permitted_opens[i].host, (char const   *)host);
#line 993
            tmp___6 = tmp___9;
          }
        } else {
#line 993
          tmp___9 = __builtin_strcmp((char const   *)permitted_opens[i].host, (char const   *)host);
#line 993
          tmp___6 = tmp___9;
        }
#line 993
        if (tmp___6 == 0) {
#line 994
          break;
        }
      }
#line 991
      i ++;
    }
#line 997
    if (i >= num_permitted_opens) {
#line 1000
      log("Received request to connect to %.100s:%d, but the request was denied.",
          host, host_port);
#line 1002
      packet_start(22);
#line 1003
      packet_put_int((unsigned int )remote_channel);
#line 1004
      packet_send();
    }
  }
#line 1008
  memset((void *)(& sin), 0, sizeof(sin));
#line 1009
  sin.sin_addr.s_addr = inet_addr((char const   *)host);
#line 1010
  if ((sin.sin_addr.s_addr & 4294967295U) != 4294967295U) {
#line 1013
    sin.sin_family = (unsigned short)2;
  } else {
#line 1018
    hp = gethostbyname((char const   *)host);
#line 1019
    if (! hp) {
#line 1021
      error("%.100s: unknown host.", host);
      goto fail;
    }
#line 1024
    if (! *(hp->h_addr_list + 0)) {
#line 1026
      error("%.100s: host has no IP address.", host);
      goto fail;
    }
#line 1029
    sin.sin_family = (unsigned short )hp->h_addrtype;
#line 1030
    memcpy((void * __restrict  )(& sin.sin_addr), (void const   * __restrict  )*(hp->h_addr_list + 0),
           sizeof(sin.sin_addr));
  }
#line 1033
  __x = (unsigned short )host_port;
#line 1033
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 1033
  sin.sin_port = __v;
#line 1036
  sock = socket((int )sin.sin_family, 1, 0);
#line 1037
  if (sock < 0) {
#line 1039
    tmp___11 = __errno_location();
#line 1039
    tmp___12 = strerror(*tmp___11);
#line 1039
    error("socket: %.100s", tmp___12);
    goto fail;
  }
#line 1044
  tmp___15 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sin)),
                     sizeof(sin));
#line 1044
  if (tmp___15 < 0) {
#line 1046
    tmp___13 = __errno_location();
#line 1046
    tmp___14 = strerror(*tmp___13);
#line 1046
    error("connect %.100s:%d: %.100s", host, host_port, tmp___14);
#line 1048
    close(sock);
    goto fail;
  }
#line 1055
  newch = channel_allocate(4, sock, originator_string);
#line 1056
  (channels + newch)->remote_id = remote_channel;
#line 1059
  packet_start(21);
#line 1060
  packet_put_int((unsigned int )remote_channel);
#line 1061
  packet_put_int((unsigned int )newch);
#line 1062
  packet_send();
#line 1065
  xfree((void *)host);
#line 1067
  return;
  fail: 
#line 1071
  xfree((void *)host);
#line 1074
  packet_start(22);
#line 1075
  packet_put_int((unsigned int )remote_channel);
#line 1076
  packet_send();
#line 1077
  return;
}
}
#line 1085
ServerOptions options ;
#line 1083 "channels.c"
char *x11_create_display_inet(int screen_number ) 
{ int display_number ;
  int port ;
  int sock ;
  struct sockaddr_in sin ;
  char buf[512] ;
  char hostname[64] ;
  register unsigned int __v ;
  register unsigned int __x ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
#line 1091
  display_number = options.x11_display_offset;
#line 1091
  while (display_number < 1000) {
#line 1093
    port = 6000 + display_number;
#line 1094
    memset((void *)(& sin), 0, sizeof(sin));
#line 1095
    sin.sin_family = (unsigned short)2;
#line 1096
    __x = 0U;
#line 1096
    __asm__  ("rorw $8, %w0;"
              "rorl $16, %0;"
              "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 1096
    sin.sin_addr.s_addr = __v;
#line 1097
    __x___0 = (unsigned short )port;
#line 1097
    __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 1097
    sin.sin_port = __v___0;
#line 1099
    sock = socket(2, 1, 0);
#line 1100
    if (sock < 0) {
#line 1102
      tmp = __errno_location();
#line 1102
      tmp___0 = strerror(*tmp);
#line 1102
      error("socket: %.100s", tmp___0);
#line 1103
      return ((char *)((void *)0));
    }
#line 1106
    tmp___3 = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sin)),
                   sizeof(sin));
#line 1106
    if (tmp___3 < 0) {
#line 1108
      tmp___1 = __errno_location();
#line 1108
      tmp___2 = strerror(*tmp___1);
#line 1108
      debug("bind port %d: %.100s", port, tmp___2);
#line 1109
      shutdown(sock, 2);
#line 1110
      close(sock);
      goto __Cont;
    }
#line 1113
    break;
    __Cont: /* CIL Label */ 
#line 1091
    display_number ++;
  }
#line 1115
  if (display_number >= 1000) {
#line 1117
    error("Failed to allocate internet-domain X11 display socket.");
#line 1118
    return ((char *)((void *)0));
  }
#line 1122
  tmp___6 = listen(sock, 5);
#line 1122
  if (tmp___6 < 0) {
#line 1124
    tmp___4 = __errno_location();
#line 1124
    tmp___5 = strerror(*tmp___4);
#line 1124
    error("listen: %.100s", tmp___5);
#line 1125
    shutdown(sock, 2);
#line 1126
    close(sock);
#line 1127
    return ((char *)((void *)0));
  }
#line 1131
  tmp___9 = gethostname(hostname, sizeof(hostname));
#line 1131
  if (tmp___9 < 0) {
#line 1132
    tmp___7 = __errno_location();
#line 1132
    tmp___8 = strerror(*tmp___7);
#line 1132
    fatal("gethostname: %.100s", tmp___8);
  }
#line 1133
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%.400s:%d.%d",
           hostname, display_number, screen_number);
#line 1137
  tmp___10 = xstrdup("X11 inet listener");
#line 1137
  channel_allocate(1, sock, tmp___10);
#line 1141
  tmp___11 = xstrdup((char const   *)(buf));
#line 1141
  return (tmp___11);
}
}
#line 1152
static int connect_local_xsocket(unsigned int dnr ) ;
#line 1152 "channels.c"
static char const   * const  x_sockets[4]  = {      (char const   * const  )"/tmp/.X11-unix/X%u",      (char const   * const  )"/var/X/.X11-unix/X%u",      (char const   * const  )"/usr/spool/sockets/X11/%u",      (char const   * const  )((void *)0)};
#line 1148 "channels.c"
static int connect_local_xsocket(unsigned int dnr ) 
{ int sock ;
  struct sockaddr_un addr ;
  char const   * const  *path ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 1162
  path = x_sockets;
#line 1162
  while (*path) {
#line 1164
    sock = socket(1, 1, 0);
#line 1165
    if (sock < 0) {
#line 1166
      tmp = __errno_location();
#line 1166
      tmp___0 = strerror(*tmp);
#line 1166
      error("socket: %.100s", tmp___0);
    }
#line 1167
    memset((void *)(& addr), 0, sizeof(addr));
#line 1168
    addr.sun_family = (unsigned short)1;
#line 1169
    snprintf((char * __restrict  )(addr.sun_path), sizeof(addr.sun_path), (char const   * __restrict  )*path,
             dnr);
#line 1170
    tmp___1 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& addr)),
                      sizeof(addr));
#line 1170
    if (tmp___1 == 0) {
#line 1171
      return (sock);
    }
#line 1172
    close(sock);
#line 1162
    path ++;
  }
#line 1174
  tmp___2 = __errno_location();
#line 1174
  tmp___3 = strerror(*tmp___2);
#line 1174
  error("connect %.100s: %.100s", addr.sun_path, tmp___3);
#line 1175
  return (-1);
}
}
#line 1183 "channels.c"
void x11_input_open(int payload_len ) 
{ int remote_channel ;
  int display_number ;
  int sock ;
  int newch ;
  char const   *display ;
  struct sockaddr_in sin ;
  char buf[1024] ;
  char *cp ;
  char *remote_host ;
  struct hostent *hp ;
  int remote_len ;
  unsigned int tmp ;
  int _p ;
  int _e ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___16 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  char *tmp___30 ;
  int tmp___31 ;
  register unsigned short __v ;
  register unsigned short __x ;
  int *tmp___32 ;
  char *tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;

  {
#line 1193
  tmp = packet_get_int();
#line 1193
  remote_channel = (int )tmp;
#line 1196
  if (have_hostname_in_open) {
#line 1197
    remote_host = packet_get_string((unsigned int *)(& remote_len));
  } else {
#line 1199
    remote_host = xstrdup("unknown (remote did not supply name)");
  }
#line 1201
  debug("Received X11 open request.");
#line 1202
  while (1) {
#line 1202
    _p = payload_len;
#line 1202
    _e = 8 + remote_len;
#line 1202
    if (_p != _e) {
#line 1202
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1202);
#line 1202
      packet_disconnect("Packet integrity error. (%d)", 27);
    }
#line 1202
    break;
  }
#line 1205
  tmp___0 = getenv("DISPLAY");
#line 1205
  display = (char const   *)tmp___0;
#line 1206
  if (! display) {
#line 1208
    error("DISPLAY not set.");
    goto fail;
  }
#line 1217
  if (0) {
#line 1217
    if (0) {
#line 1217
      __s1_len___0 = strlen(display);
#line 1217
      __s2_len___0 = strlen("unix:");
#line 1217
      if (! ((unsigned int )((void const   *)(display + 1)) - (unsigned int )((void const   *)display) == 1U)) {
        goto _L___2;
      } else {
#line 1217
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 1217
          if (! ((unsigned int )((void const   *)("unix:" + 1)) - (unsigned int )((void const   *)"unix:") == 1U)) {
#line 1217
            tmp___26 = 1;
          } else {
#line 1217
            if (__s2_len___0 >= 4U) {
#line 1217
              tmp___26 = 1;
            } else {
#line 1217
              tmp___26 = 0;
            }
          }
        } else {
#line 1217
          tmp___26 = 0;
        }
      }
#line 1217
      if (tmp___26) {
#line 1217
        tmp___22 = __builtin_strcmp(display, "unix:");
      } else {
#line 1217
        tmp___25 = __builtin_strcmp(display, "unix:");
#line 1217
        tmp___22 = tmp___25;
      }
    } else {
#line 1217
      tmp___25 = __builtin_strcmp(display, "unix:");
#line 1217
      tmp___22 = tmp___25;
    }
#line 1217
    tmp___16 = tmp___22;
  } else {
#line 1217
    tmp___16 = strncmp(display, "unix:", 5U);
  }
#line 1217
  if (tmp___16 == 0) {
    goto _L___3;
  } else {
#line 1217
    if ((int const   )*(display + 0) == 58) {
      _L___3: /* CIL Label */ 
#line 1221
      tmp___1 = strrchr(display, ':');
#line 1221
      tmp___2 = sscanf((char const   * __restrict  )(tmp___1 + 1), (char const   * __restrict  )"%d",
                       & display_number);
#line 1221
      if (tmp___2 != 1) {
#line 1223
        error("Could not parse display number from DISPLAY: %.100s", display);
        goto fail;
      }
#line 1228
      sock = connect_local_xsocket((unsigned int )display_number);
#line 1229
      if (sock < 0) {
        goto fail;
      }
      goto success;
    }
  }
#line 1238
  __builtin_strncpy(buf, display, sizeof(buf));
#line 1239
  buf[sizeof(buf) - 1U] = (char)0;
#line 1240
  tmp___30 = __builtin_strchr(buf, ':');
#line 1240
  cp = tmp___30;
#line 1241
  if (! cp) {
#line 1243
    error("Could not find \':\' in DISPLAY: %.100s", display);
    goto fail;
  }
#line 1246
  *cp = (char)0;
#line 1248
  tmp___31 = sscanf((char const   * __restrict  )(cp + 1), (char const   * __restrict  )"%d",
                    & display_number);
#line 1248
  if (tmp___31 != 1) {
#line 1250
    error("Could not parse display number from DISPLAY: %.100s", display);
    goto fail;
  }
#line 1256
  memset((void *)(& sin), 0, sizeof(sin));
#line 1257
  sin.sin_addr.s_addr = inet_addr((char const   *)(buf));
#line 1258
  if ((sin.sin_addr.s_addr & 4294967295U) != 4294967295U) {
#line 1261
    sin.sin_family = (unsigned short)2;
  } else {
#line 1267
    hp = gethostbyname((char const   *)(buf));
#line 1268
    if (! hp) {
#line 1270
      error("%.100s: unknown host.", buf);
      goto fail;
    }
#line 1273
    if (! *(hp->h_addr_list + 0)) {
#line 1275
      error("%.100s: host has no IP address.", buf);
      goto fail;
    }
#line 1278
    sin.sin_family = (unsigned short )hp->h_addrtype;
#line 1279
    memcpy((void * __restrict  )(& sin.sin_addr), (void const   * __restrict  )*(hp->h_addr_list + 0),
           sizeof(sin.sin_addr));
  }
#line 1283
  __x = (unsigned short )(6000 + display_number);
#line 1283
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 1283
  sin.sin_port = __v;
#line 1286
  sock = socket((int )sin.sin_family, 1, 0);
#line 1287
  if (sock < 0) {
#line 1289
    tmp___32 = __errno_location();
#line 1289
    tmp___33 = strerror(*tmp___32);
#line 1289
    error("socket: %.100s", tmp___33);
    goto fail;
  }
#line 1293
  tmp___36 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sin)),
                     sizeof(sin));
#line 1293
  if (tmp___36 < 0) {
#line 1295
    tmp___34 = __errno_location();
#line 1295
    tmp___35 = strerror(*tmp___34);
#line 1295
    error("connect %.100s:%d: %.100s", buf, 6000 + display_number, tmp___35);
#line 1297
    close(sock);
    goto fail;
  }
  success: 
#line 1305
  if ((unsigned int )x11_saved_proto == (unsigned int )((void *)0)) {
#line 1306
    newch = channel_allocate(4, sock, remote_host);
  } else {
#line 1308
    newch = channel_allocate(9, sock, remote_host);
  }
#line 1309
  (channels + newch)->remote_id = remote_channel;
#line 1312
  packet_start(21);
#line 1313
  packet_put_int((unsigned int )remote_channel);
#line 1314
  packet_put_int((unsigned int )newch);
#line 1315
  packet_send();
#line 1317
  return;
  fail: 
#line 1321
  packet_start(22);
#line 1322
  packet_put_int((unsigned int )remote_channel);
#line 1323
  packet_send();
#line 1324
  return;
}
}
#line 1329 "channels.c"
void x11_request_forwarding_with_spoofing(char const   *proto , char const   *data ) 
{ unsigned int data_len ;
  size_t tmp ;
  unsigned int i ;
  unsigned int value ;
  char *new_data ;
  int screen_number ;
  char const   *cp ;
  u_int32_t rand___0 ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;

  {
#line 1331
  tmp = strlen(data);
#line 1331
  data_len = tmp / 2U;
#line 1336
  rand___0 = (u_int32_t )0;
#line 1338
  tmp___0 = getenv("DISPLAY");
#line 1338
  cp = (char const   *)tmp___0;
#line 1339
  if (cp) {
#line 1340
    tmp___2 = __builtin_strchr((char *)cp, ':');
#line 1340
    cp = (char const   *)tmp___2;
  }
#line 1341
  if (cp) {
#line 1342
    tmp___4 = __builtin_strchr((char *)cp, '.');
#line 1342
    cp = (char const   *)tmp___4;
  }
#line 1343
  if (cp) {
#line 1344
    screen_number = atoi(cp + 1);
  } else {
#line 1346
    screen_number = 0;
  }
#line 1349
  x11_saved_proto = xstrdup(proto);
#line 1353
  tmp___5 = xmalloc(data_len);
#line 1353
  x11_saved_data = (char *)tmp___5;
#line 1354
  tmp___6 = xmalloc(data_len);
#line 1354
  x11_fake_data = (char *)tmp___6;
#line 1355
  i = 0U;
#line 1355
  while (i < data_len) {
#line 1357
    tmp___7 = sscanf((char const   * __restrict  )(data + 2U * i), (char const   * __restrict  )"%2x",
                     & value);
#line 1357
    if (tmp___7 != 1) {
#line 1358
      fatal("x11_request_forwarding: bad authentication data: %.100s", data);
    }
#line 1359
    if (i % 4U == 0U) {
#line 1360
      rand___0 = arc4random();
    }
#line 1361
    *(x11_saved_data + i) = (char )value;
#line 1362
    *(x11_fake_data + i) = (char )(rand___0 & 255U);
#line 1363
    rand___0 >>= 8;
#line 1355
    i ++;
  }
#line 1365
  x11_saved_data_len = data_len;
#line 1366
  x11_fake_data_len = data_len;
#line 1369
  tmp___8 = xmalloc(2U * data_len + 1U);
#line 1369
  new_data = (char *)tmp___8;
#line 1370
  i = 0U;
#line 1370
  while (i < data_len) {
#line 1371
    sprintf((char * __restrict  )(new_data + 2U * i), (char const   * __restrict  )"%02x",
            (unsigned char )*(x11_fake_data + i));
#line 1370
    i ++;
  }
#line 1374
  packet_start(34);
#line 1375
  tmp___9 = strlen(proto);
#line 1375
  packet_put_string(proto, tmp___9);
#line 1376
  tmp___10 = strlen((char const   *)new_data);
#line 1376
  packet_put_string((char const   *)new_data, tmp___10);
#line 1377
  packet_put_int((unsigned int )screen_number);
#line 1378
  packet_send();
#line 1379
  packet_write_wait();
#line 1380
  xfree((void *)new_data);
#line 1381
  return;
}
}
#line 1385 "channels.c"
void auth_request_forwarding(void) 
{ 

  {
#line 1387
  packet_start(30);
#line 1388
  packet_send();
#line 1389
  packet_write_wait();
#line 1390
  return;
}
}
#line 1396 "channels.c"
char *auth_get_socket_name(void) 
{ 

  {
#line 1398
  return (channel_forwarded_auth_socket_name);
}
}
#line 1403 "channels.c"
void cleanup_socket(void) 
{ 

  {
#line 1404
  remove((char const   *)channel_forwarded_auth_socket_name);
#line 1405
  rmdir((char const   *)channel_forwarded_auth_socket_dir);
#line 1406
  return;
}
}
#line 1411 "channels.c"
void auth_input_request_forwarding(struct passwd *pw ) 
{ int sock ;
  int newch ;
  struct sockaddr_un sunaddr ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  __pid_t tmp___5 ;
  int saved ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;

  {
#line 1416
  tmp = auth_get_socket_name();
#line 1416
  if ((unsigned int )tmp != (unsigned int )((void *)0)) {
#line 1417
    fatal("Protocol error: authentication forwarding requested twice.");
  }
#line 1420
  temporarily_use_uid(pw->pw_uid);
#line 1423
  tmp___0 = xmalloc(100U);
#line 1423
  channel_forwarded_auth_socket_name = (char *)tmp___0;
#line 1424
  tmp___1 = xmalloc(100U);
#line 1424
  channel_forwarded_auth_socket_dir = (char *)tmp___1;
#line 1425
  strlcpy(channel_forwarded_auth_socket_dir, "/tmp/ssh-XXXXXXXX", 100U);
#line 1428
  tmp___4 = mkdtemp(channel_forwarded_auth_socket_dir);
#line 1428
  if ((unsigned int )tmp___4 == (unsigned int )((void *)0)) {
#line 1429
    tmp___2 = __errno_location();
#line 1429
    tmp___3 = strerror(*tmp___2);
#line 1429
    packet_disconnect("mkdtemp: %.100s", tmp___3);
  }
#line 1430
  tmp___5 = getpid();
#line 1430
  snprintf((char * __restrict  )channel_forwarded_auth_socket_name, 100U, (char const   * __restrict  )"%s/agent.%d",
           channel_forwarded_auth_socket_dir, tmp___5);
#line 1433
  tmp___8 = atexit(& cleanup_socket);
#line 1433
  if (tmp___8 < 0) {
#line 1434
    tmp___6 = __errno_location();
#line 1434
    saved = *tmp___6;
#line 1435
    cleanup_socket();
#line 1436
    tmp___7 = strerror(saved);
#line 1436
    packet_disconnect("socket: %.100s", tmp___7);
  }
#line 1440
  sock = socket(1, 1, 0);
#line 1441
  if (sock < 0) {
#line 1442
    tmp___9 = __errno_location();
#line 1442
    tmp___10 = strerror(*tmp___9);
#line 1442
    packet_disconnect("socket: %.100s", tmp___10);
  }
#line 1445
  memset((void *)(& sunaddr), 0, sizeof(sunaddr));
#line 1446
  sunaddr.sun_family = (unsigned short)1;
#line 1447
  __builtin_strncpy(sunaddr.sun_path, (char const   *)channel_forwarded_auth_socket_name,
                    sizeof(sunaddr.sun_path));
#line 1450
  tmp___13 = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sunaddr)),
                  sizeof(sunaddr));
#line 1450
  if (tmp___13 < 0) {
#line 1451
    tmp___11 = __errno_location();
#line 1451
    tmp___12 = strerror(*tmp___11);
#line 1451
    packet_disconnect("bind: %.100s", tmp___12);
  }
#line 1454
  restore_uid();
#line 1457
  tmp___16 = listen(sock, 5);
#line 1457
  if (tmp___16 < 0) {
#line 1458
    tmp___14 = __errno_location();
#line 1458
    tmp___15 = strerror(*tmp___14);
#line 1458
    packet_disconnect("listen: %.100s", tmp___15);
  }
#line 1461
  tmp___17 = xstrdup("auth socket");
#line 1461
  newch = channel_allocate(7, sock, tmp___17);
#line 1463
  strcpy((char * __restrict  )((channels + newch)->path), (char const   * __restrict  )channel_forwarded_auth_socket_name);
#line 1464
  return;
}
}
#line 1468 "channels.c"
void auth_input_open_request(void) 
{ int remch ;
  int sock ;
  int newch ;
  char *dummyname ;
  unsigned int tmp ;

  {
#line 1474
  tmp = packet_get_int();
#line 1474
  remch = (int )tmp;
#line 1478
  sock = ssh_get_authentication_socket();
#line 1484
  if (sock < 0) {
#line 1485
    packet_start(22);
#line 1486
    packet_put_int((unsigned int )remch);
#line 1487
    packet_send();
#line 1488
    return;
  }
#line 1491
  debug("Forwarding authentication connection.");
#line 1496
  dummyname = xstrdup("authentication agent connection");
#line 1498
  newch = channel_allocate(4, sock, dummyname);
#line 1499
  (channels + newch)->remote_id = remch;
#line 1502
  packet_start(21);
#line 1503
  packet_put_int((unsigned int )remch);
#line 1504
  packet_put_int((unsigned int )newch);
#line 1505
  packet_send();
#line 1506
  return;
}
}
#line 1 "cipher.o"
#pragma merger(0,"./cipher.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 138 "/usr/include/openssl/des.h"
extern void DES_cbc_encrypt(unsigned char const   *input , unsigned char *output ,
                            long length , DES_key_schedule *schedule , DES_cblock *ivec ,
                            int enc ) ;
#line 222
extern int DES_set_key(const_DES_cblock *key , DES_key_schedule *schedule ) ;
#line 108 "/usr/include/openssl/blowfish.h"
extern void BF_set_key(BF_KEY *key , int len , unsigned char const   *data ) ;
#line 115
extern void BF_cbc_encrypt(unsigned char const   *in , unsigned char *out , long length ,
                           BF_KEY const   *schedule , unsigned char *ivec , int enc ) ;
#line 68 "cipher.h"
int cipher_number(char const   *name ) ;
#line 72
void cipher_set_key(CipherContext *context , int cipher , unsigned char const   *key ,
                    int keylen , int for_encryption ) ;
#line 90
void (*cipher_attack_detected)(char const   *fmt  , ...) ;
#line 107 "/usr/include/openssl/md5.h"
extern int MD5_Init(MD5_CTX *c ) ;
#line 108
extern int MD5_Update(MD5_CTX *c , void const   *data , size_t len ) ;
#line 109
extern int MD5_Final(unsigned char *md , MD5_CTX *c ) ;
#line 40 "cipher.c"
void SSH_3CBC_ENCRYPT(DES_key_schedule ks1 , DES_key_schedule ks2 , DES_cblock *iv2 ,
                      DES_key_schedule ks3 , DES_cblock *iv3 , void *dest , void *src ,
                      unsigned int len ) 
{ DES_cblock iv1 ;

  {
#line 49
  memcpy((void * __restrict  )(& iv1), (void const   * __restrict  )iv2, 8U);
#line 51
  DES_cbc_encrypt((unsigned char const   *)src, (unsigned char *)dest, (long )len,
                  & ks1, & iv1, 1);
#line 52
  memcpy((void * __restrict  )(& iv1), (void const   * __restrict  )((dest + len) - 8),
         8U);
#line 54
  DES_cbc_encrypt((unsigned char const   *)dest, (unsigned char *)dest, (long )len,
                  & ks2, iv2, 0);
#line 55
  memcpy((void * __restrict  )iv2, (void const   * __restrict  )(& iv1), 8U);
#line 57
  DES_cbc_encrypt((unsigned char const   *)dest, (unsigned char *)dest, (long )len,
                  & ks3, iv3, 1);
#line 58
  memcpy((void * __restrict  )iv3, (void const   * __restrict  )((dest + len) - 8),
         8U);
#line 59
  return;
}
}
#line 61 "cipher.c"
void SSH_3CBC_DECRYPT(DES_key_schedule ks1 , DES_key_schedule ks2 , DES_cblock *iv2 ,
                      DES_key_schedule ks3 , DES_cblock *iv3 , void *dest , void *src ,
                      unsigned int len ) 
{ DES_cblock iv1 ;

  {
#line 70
  memcpy((void * __restrict  )(& iv1), (void const   * __restrict  )iv2, 8U);
#line 72
  DES_cbc_encrypt((unsigned char const   *)src, (unsigned char *)dest, (long )len,
                  & ks3, iv3, 0);
#line 73
  memcpy((void * __restrict  )iv3, (void const   * __restrict  )((src + len) - 8),
         8U);
#line 75
  DES_cbc_encrypt((unsigned char const   *)dest, (unsigned char *)dest, (long )len,
                  & ks2, iv2, 1);
#line 76
  memcpy((void * __restrict  )iv2, (void const   * __restrict  )((dest + len) - 8),
         8U);
#line 78
  DES_cbc_encrypt((unsigned char const   *)dest, (unsigned char *)dest, (long )len,
                  & ks1, & iv1, 0);
#line 80
  return;
}
}
#line 86 "cipher.c"
static void swap_bytes(unsigned char const   *src , unsigned char *dst_ , int n___0 ) 
{ u_int32_t *dst ;
  union __anonunion_t_75 t ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  u_int32_t *tmp___3 ;
  unsigned char const   *tmp___4 ;
  unsigned char const   *tmp___5 ;
  unsigned char const   *tmp___6 ;
  unsigned char const   *tmp___7 ;
  u_int32_t *tmp___8 ;

  {
#line 90
  dst = (u_int32_t *)dst_;
#line 97
  n___0 /= 8;
#line 97
  while (n___0 > 0) {
#line 99
    tmp = src;
#line 99
    src ++;
#line 99
    t.c[3] = (char )*tmp;
#line 100
    tmp___0 = src;
#line 100
    src ++;
#line 100
    t.c[2] = (char )*tmp___0;
#line 101
    tmp___1 = src;
#line 101
    src ++;
#line 101
    t.c[1] = (char )*tmp___1;
#line 102
    tmp___2 = src;
#line 102
    src ++;
#line 102
    t.c[0] = (char )*tmp___2;
#line 103
    tmp___3 = dst;
#line 103
    dst ++;
#line 103
    *tmp___3 = t.i;
#line 105
    tmp___4 = src;
#line 105
    src ++;
#line 105
    t.c[3] = (char )*tmp___4;
#line 106
    tmp___5 = src;
#line 106
    src ++;
#line 106
    t.c[2] = (char )*tmp___5;
#line 107
    tmp___6 = src;
#line 107
    src ++;
#line 107
    t.c[1] = (char )*tmp___6;
#line 108
    tmp___7 = src;
#line 108
    src ++;
#line 108
    t.c[0] = (char )*tmp___7;
#line 109
    tmp___8 = dst;
#line 109
    dst ++;
#line 109
    *tmp___8 = t.i;
#line 97
    n___0 --;
  }
#line 111
  return;
}
}
#line 113 "cipher.c"
void (*cipher_attack_detected)(char const   *fmt  , ...)  =    & fatal;
#line 115 "cipher.c"
__inline static void detect_cbc_attack(unsigned char const   *src , unsigned int len ) 
{ 

  {
#line 120
  return;
#line 122
  log("CRC-32 CBC insertion attack detected");
#line 123
  (*cipher_attack_detected)("CRC-32 CBC insertion attack detected");
}
}
#line 128 "cipher.c"
static char *cipher_names[7]  = {      (char *)"none",      (char *)"idea",      (char *)"des",      (char *)"3des", 
        (char *)"tss",      (char *)"rc4",      (char *)"blowfish"};
#line 143 "cipher.c"
unsigned int cipher_mask(void) 
{ unsigned int mask ;

  {
#line 145
  mask = 0U;
#line 146
  mask |= (unsigned int )(1 << 3);
#line 147
  mask |= (unsigned int )(1 << 6);
#line 148
  return (mask);
}
}
#line 153 "cipher.c"
char const   *cipher_name(int cipher ) 
{ 

  {
#line 156
  if (cipher < 0) {
#line 158
    fatal("cipher_name: bad cipher number: %d", cipher);
  } else {
#line 156
    if ((unsigned int )cipher >= sizeof(cipher_names) / sizeof(cipher_names[0])) {
#line 158
      fatal("cipher_name: bad cipher number: %d", cipher);
    } else {
#line 156
      if ((unsigned int )cipher_names[cipher] == (unsigned int )((void *)0)) {
#line 158
        fatal("cipher_name: bad cipher number: %d", cipher);
      }
    }
  }
#line 159
  return ((char const   *)cipher_names[cipher]);
}
}
#line 165 "cipher.c"
int cipher_number(char const   *name ) 
{ int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 169
  i = 0;
#line 169
  while ((unsigned int )i < sizeof(cipher_names) / sizeof(cipher_names[0])) {
#line 170
    if (0) {
#line 170
      __s1_len = strlen((char const   *)cipher_names[i]);
#line 170
      __s2_len = strlen(name);
#line 170
      if (! ((unsigned int )((void const   *)(cipher_names[i] + 1)) - (unsigned int )((void const   *)cipher_names[i]) == 1U)) {
        goto _L___0;
      } else {
#line 170
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 170
          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
#line 170
            tmp___8 = 1;
          } else {
#line 170
            if (__s2_len >= 4U) {
#line 170
              tmp___8 = 1;
            } else {
#line 170
              tmp___8 = 0;
            }
          }
        } else {
#line 170
          tmp___8 = 0;
        }
      }
#line 170
      if (tmp___8) {
#line 170
        tmp___4 = __builtin_strcmp((char const   *)cipher_names[i], name);
      } else {
#line 170
        tmp___7 = __builtin_strcmp((char const   *)cipher_names[i], name);
#line 170
        tmp___4 = tmp___7;
      }
    } else {
#line 170
      tmp___7 = __builtin_strcmp((char const   *)cipher_names[i], name);
#line 170
      tmp___4 = tmp___7;
    }
#line 170
    if (tmp___4 == 0) {
#line 170
      tmp___9 = cipher_mask();
#line 170
      if (tmp___9 & (unsigned int )(1 << i)) {
#line 172
        return (i);
      }
    }
#line 169
    i ++;
  }
#line 173
  return (-1);
}
}
#line 179 "cipher.c"
void cipher_set_key_string(CipherContext *context , int cipher , char const   *passphrase ,
                           int for_encryption ) 
{ MD5_CTX md ;
  unsigned char digest[16] ;
  size_t tmp ;

  {
#line 185
  MD5_Init(& md);
#line 186
  tmp = strlen(passphrase);
#line 186
  MD5_Update(& md, (void const   *)((unsigned char const   *)passphrase), tmp);
#line 187
  MD5_Final(digest, & md);
#line 189
  cipher_set_key(context, cipher, (unsigned char const   *)(digest), 16, for_encryption);
#line 191
  memset((void *)(digest), 0, sizeof(digest));
#line 192
  memset((void *)(& md), 0, sizeof(md));
#line 193
  return;
}
}
#line 197 "cipher.c"
void cipher_set_key(CipherContext *context , int cipher , unsigned char const   *key ,
                    int keylen , int for_encryption ) 
{ unsigned char padded[32] ;
  unsigned int tmp ;

  {
#line 203
  context->type = (unsigned int )cipher;
#line 207
  memset((void *)(padded), 0, sizeof(padded));
#line 208
  if ((unsigned int )keylen < sizeof(padded)) {
#line 208
    tmp = (unsigned int )keylen;
  } else {
#line 208
    tmp = sizeof(padded);
  }
#line 208
  memcpy((void * __restrict  )(padded), (void const   * __restrict  )key, tmp);
#line 211
  switch (cipher) {
  case 0: 
#line 215
  break;
  case 3: 
#line 221
  if (keylen < 16) {
#line 222
    error("Key length %d is insufficient for 3DES.", keylen);
  }
#line 223
  DES_set_key((const_DES_cblock *)((void *)(padded)), & context->u.des3.key1);
#line 224
  DES_set_key((const_DES_cblock *)((void *)(padded + 8)), & context->u.des3.key2);
#line 225
  if (keylen <= 16) {
#line 226
    DES_set_key((const_DES_cblock *)((void *)(padded)), & context->u.des3.key3);
  } else {
#line 228
    DES_set_key((const_DES_cblock *)((void *)(padded + 16)), & context->u.des3.key3);
  }
#line 229
  memset((void *)(context->u.des3.iv2), 0, sizeof(context->u.des3.iv2));
#line 230
  memset((void *)(context->u.des3.iv3), 0, sizeof(context->u.des3.iv3));
#line 231
  break;
  case 6: 
#line 234
  BF_set_key(& context->u.bf.key, keylen, (unsigned char const   *)(padded));
#line 235
  memset((void *)(context->u.bf.iv), 0, 8U);
#line 236
  break;
  default: 
#line 239
  fatal("cipher_set_key: unknown cipher: %d", cipher);
  }
#line 241
  memset((void *)(padded), 0, sizeof(padded));
#line 242
  return;
}
}
#line 246 "cipher.c"
void cipher_encrypt(CipherContext *context , unsigned char *dest , unsigned char const   *src ,
                    unsigned int len ) 
{ 

  {
#line 249
  if ((len & 7U) != 0U) {
#line 250
    fatal("cipher_encrypt: bad plaintext length %d", len);
  }
#line 252
  switch ((int )context->type) {
  case 0: 
#line 255
  memcpy((void * __restrict  )dest, (void const   * __restrict  )src, len);
#line 256
  break;
  case 3: 
#line 259
  SSH_3CBC_ENCRYPT(context->u.des3.key1, context->u.des3.key2, & context->u.des3.iv2,
                   context->u.des3.key3, & context->u.des3.iv3, (void *)dest, (void *)src,
                   len);
#line 263
  break;
  case 6: 
#line 266
  swap_bytes(src, dest, (int )len);
#line 267
  BF_cbc_encrypt((unsigned char const   *)dest, dest, (long )len, (BF_KEY const   *)(& context->u.bf.key),
                 context->u.bf.iv, 1);
#line 269
  swap_bytes((unsigned char const   *)dest, dest, (int )len);
#line 270
  break;
  default: 
#line 273
  fatal("cipher_encrypt: unknown cipher: %d", context->type);
  }
#line 275
  return;
}
}
#line 279 "cipher.c"
void cipher_decrypt(CipherContext *context , unsigned char *dest , unsigned char const   *src ,
                    unsigned int len ) 
{ 

  {
#line 282
  if ((len & 7U) != 0U) {
#line 283
    fatal("cipher_decrypt: bad ciphertext length %d", len);
  }
#line 285
  switch ((int )context->type) {
  case 0: 
#line 288
  memcpy((void * __restrict  )dest, (void const   * __restrict  )src, len);
#line 289
  break;
  case 3: 
#line 293
  SSH_3CBC_DECRYPT(context->u.des3.key1, context->u.des3.key2, & context->u.des3.iv2,
                   context->u.des3.key3, & context->u.des3.iv3, (void *)dest, (void *)src,
                   len);
#line 297
  break;
  case 6: 
#line 300
  detect_cbc_attack(src, len);
#line 301
  swap_bytes(src, dest, (int )len);
#line 302
  BF_cbc_encrypt((unsigned char const   *)((void *)dest), dest, (long )len, (BF_KEY const   *)(& context->u.bf.key),
                 context->u.bf.iv, 0);
#line 304
  swap_bytes((unsigned char const   *)dest, dest, (int )len);
#line 305
  break;
  default: 
#line 308
  fatal("cipher_decrypt: unknown cipher: %d", context->type);
  }
#line 310
  return;
}
}
#line 1 "compat.o"
#pragma merger(0,"./compat.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 6 "compat.c"
int compat13  =    0;
#line 7 "compat.c"
void enable_compat13(void) 
{ 

  {
#line 8
  log("Enabling compatibility mode for protocol 1.3");
#line 9
  compat13 = 1;
#line 10
  return;
}
}
#line 1 "compress.o"
#pragma merger(0,"./compress.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 242 "/usr/include/zlib.h"
extern int deflate(z_streamp strm , int flush ) ;
#line 328
extern int deflateEnd(z_streamp strm ) ;
#line 363
extern int inflate(z_streamp strm , int flush ) ;
#line 462
extern int inflateEnd(z_streamp strm ) ;
#line 1317
extern int deflateInit_(z_streamp strm , int level , char const   *version , int stream_size ) ;
#line 1319
extern int inflateInit_(z_streamp strm , char const   *version , int stream_size ) ;
#line 23 "compress.c"
static z_stream incoming_stream  ;
#line 24 "compress.c"
static z_stream outgoing_stream  ;
#line 29 "compress.c"
void buffer_compress_init(int level ) 
{ 

  {
#line 31
  debug("Enabling compression at level %d.", level);
#line 32
  if (level < 1) {
#line 33
    fatal("Bad compression level %d.", level);
  } else {
#line 32
    if (level > 9) {
#line 33
      fatal("Bad compression level %d.", level);
    }
  }
#line 34
  inflateInit_(& incoming_stream, "1.2.3", (int )sizeof(z_stream ));
#line 35
  deflateInit_(& outgoing_stream, level, "1.2.3", (int )sizeof(z_stream ));
#line 36
  return;
}
}
#line 40 "compress.c"
void buffer_compress_uninit(void) 
{ double tmp ;
  double tmp___0 ;

  {
#line 42
  if (outgoing_stream.total_in == 0UL) {
#line 42
    tmp = 0.0;
  } else {
#line 42
    tmp = (double )outgoing_stream.total_out / (double )outgoing_stream.total_in;
  }
#line 42
  debug("compress outgoing: raw data %lu, compressed %lu, factor %.2f", outgoing_stream.total_in,
        outgoing_stream.total_out, tmp);
#line 46
  if (incoming_stream.total_out == 0UL) {
#line 46
    tmp___0 = 0.0;
  } else {
#line 46
    tmp___0 = (double )incoming_stream.total_in / (double )incoming_stream.total_out;
  }
#line 46
  debug("compress incoming: raw data %lu, compressed %lu, factor %.2f", incoming_stream.total_out,
        incoming_stream.total_in, tmp___0);
#line 50
  inflateEnd(& incoming_stream);
#line 51
  deflateEnd(& outgoing_stream);
#line 52
  return;
}
}
#line 62 "compress.c"
void buffer_compress(Buffer *input_buffer , Buffer *output_buffer ) 
{ char buf[4096] ;
  int status ;
  unsigned int tmp ;
  char *tmp___0 ;

  {
#line 68
  tmp = buffer_len(input_buffer);
#line 68
  if (tmp == 0U) {
#line 69
    return;
  }
#line 72
  tmp___0 = buffer_ptr(input_buffer);
#line 72
  outgoing_stream.next_in = (Bytef *)tmp___0;
#line 73
  outgoing_stream.avail_in = buffer_len(input_buffer);
#line 76
  while (1) {
#line 79
    outgoing_stream.next_out = (Bytef *)(buf);
#line 80
    outgoing_stream.avail_out = sizeof(buf);
#line 83
    status = deflate(& outgoing_stream, 1);
#line 84
    switch (status) {
    case 0: 
#line 88
    buffer_append(output_buffer, (char const   *)(buf), sizeof(buf) - outgoing_stream.avail_out);
#line 90
    break;
    case 1: 
#line 92
    fatal("buffer_compress: deflate returned Z_STREAM_END");
    case -2: 
#line 95
    fatal("buffer_compress: deflate returned Z_STREAM_ERROR");
    case -5: 
#line 98
    fatal("buffer_compress: deflate returned Z_BUF_ERROR");
    default: 
#line 101
    fatal("buffer_compress: deflate returned %d", status);
    }
#line 76
    if (! (outgoing_stream.avail_out == 0U)) {
#line 76
      break;
    }
  }
#line 106
  return;
}
}
#line 116 "compress.c"
void buffer_uncompress(Buffer *input_buffer , Buffer *output_buffer ) 
{ char buf[4096] ;
  int status ;
  char *tmp ;

  {
#line 121
  tmp = buffer_ptr(input_buffer);
#line 121
  incoming_stream.next_in = (Bytef *)tmp;
#line 122
  incoming_stream.avail_in = buffer_len(input_buffer);
#line 124
  incoming_stream.next_out = (Bytef *)(buf);
#line 125
  incoming_stream.avail_out = sizeof(buf);
#line 127
  while (1) {
#line 129
    status = inflate(& incoming_stream, 1);
#line 130
    switch (status) {
    case 0: 
#line 133
    buffer_append(output_buffer, (char const   *)(buf), sizeof(buf) - incoming_stream.avail_out);
#line 135
    incoming_stream.next_out = (Bytef *)(buf);
#line 136
    incoming_stream.avail_out = sizeof(buf);
#line 137
    break;
    case 1: 
#line 139
    fatal("buffer_uncompress: inflate returned Z_STREAM_END");
    case -3: 
#line 142
    fatal("buffer_uncompress: inflate returned Z_DATA_ERROR");
    case -2: 
#line 145
    fatal("buffer_uncompress: inflate returned Z_STREAM_ERROR");
    case -5: 
#line 151
    return;
    case -4: 
#line 153
    fatal("buffer_uncompress: inflate returned Z_MEM_ERROR");
    default: 
#line 156
    fatal("buffer_uncompress: inflate returned %d", status);
    }
  }
}
}
#line 1 "crc32.o"
#pragma merger(0,"./crc32.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 23 "crc32.h"
unsigned int crc32(unsigned char const   *s , unsigned int len ) ;
#line 50 "crc32.c"
static unsigned int crc32_tab[256]  = 
#line 50 "crc32.c"
  {      0U,      1996959894U,      3993919788U,      2567524794U, 
        124634137U,      1886057615U,      3915621685U,      2657392035U, 
        249268274U,      2044508324U,      3772115230U,      2547177864U, 
        162941995U,      2125561021U,      3887607047U,      2428444049U, 
        498536548U,      1789927666U,      4089016648U,      2227061214U, 
        450548861U,      1843258603U,      4107580753U,      2211677639U, 
        325883990U,      1684777152U,      4251122042U,      2321926636U, 
        335633487U,      1661365465U,      4195302755U,      2366115317U, 
        997073096U,      1281953886U,      3579855332U,      2724688242U, 
        1006888145U,      1258607687U,      3524101629U,      2768942443U, 
        901097722U,      1119000684U,      3686517206U,      2898065728U, 
        853044451U,      1172266101U,      3705015759U,      2882616665U, 
        651767980U,      1373503546U,      3369554304U,      3218104598U, 
        565507253U,      1454621731U,      3485111705U,      3099436303U, 
        671266974U,      1594198024U,      3322730930U,      2970347812U, 
        795835527U,      1483230225U,      3244367275U,      3060149565U, 
        1994146192U,      31158534U,      2563907772U,      4023717930U, 
        1907459465U,      112637215U,      2680153253U,      3904427059U, 
        2013776290U,      251722036U,      2517215374U,      3775830040U, 
        2137656763U,      141376813U,      2439277719U,      3865271297U, 
        1802195444U,      476864866U,      2238001368U,      4066508878U, 
        1812370925U,      453092731U,      2181625025U,      4111451223U, 
        1706088902U,      314042704U,      2344532202U,      4240017532U, 
        1658658271U,      366619977U,      2362670323U,      4224994405U, 
        1303535960U,      984961486U,      2747007092U,      3569037538U, 
        1256170817U,      1037604311U,      2765210733U,      3554079995U, 
        1131014506U,      879679996U,      2909243462U,      3663771856U, 
        1141124467U,      855842277U,      2852801631U,      3708648649U, 
        1342533948U,      654459306U,      3188396048U,      3373015174U, 
        1466479909U,      544179635U,      3110523913U,      3462522015U, 
        1591671054U,      702138776U,      2966460450U,      3352799412U, 
        1504918807U,      783551873U,      3082640443U,      3233442989U, 
        3988292384U,      2596254646U,      62317068U,      1957810842U, 
        3939845945U,      2647816111U,      81470997U,      1943803523U, 
        3814918930U,      2489596804U,      225274430U,      2053790376U, 
        3826175755U,      2466906013U,      167816743U,      2097651377U, 
        4027552580U,      2265490386U,      503444072U,      1762050814U, 
        4150417245U,      2154129355U,      426522225U,      1852507879U, 
        4275313526U,      2312317920U,      282753626U,      1742555852U, 
        4189708143U,      2394877945U,      397917763U,      1622183637U, 
        3604390888U,      2714866558U,      953729732U,      1340076626U, 
        3518719985U,      2797360999U,      1068828381U,      1219638859U, 
        3624741850U,      2936675148U,      906185462U,      1090812512U, 
        3747672003U,      2825379669U,      829329135U,      1181335161U, 
        3412177804U,      3160834842U,      628085408U,      1382605366U, 
        3423369109U,      3138078467U,      570562233U,      1426400815U, 
        3317316542U,      2998733608U,      733239954U,      1555261956U, 
        3268935591U,      3050360625U,      752459403U,      1541320221U, 
        2607071920U,      3965973030U,      1969922972U,      40735498U, 
        2617837225U,      3943577151U,      1913087877U,      83908371U, 
        2512341634U,      3803740692U,      2075208622U,      213261112U, 
        2463272603U,      3855990285U,      2094854071U,      198958881U, 
        2262029012U,      4057260610U,      1759359992U,      534414190U, 
        2176718541U,      4139329115U,      1873836001U,      414664567U, 
        2282248934U,      4279200368U,      1711684554U,      285281116U, 
        2405801727U,      4167216745U,      1634467795U,      376229701U, 
        2685067896U,      3608007406U,      1308918612U,      956543938U, 
        2808555105U,      3495958263U,      1231636301U,      1047427035U, 
        2932959818U,      3654703836U,      1088359270U,      936918000U, 
        2847714899U,      3736837829U,      1202900863U,      817233897U, 
        3183342108U,      3401237130U,      1404277552U,      615818150U, 
        3134207493U,      3453421203U,      1423857449U,      601450431U, 
        3009837614U,      3294710456U,      1567103746U,      711928724U, 
        3020668471U,      3272380065U,      1510334235U,      755167117U};
#line 107 "crc32.c"
unsigned int crc32(unsigned char const   *s , unsigned int len ) 
{ unsigned int i ;
  unsigned int crc32val ;

  {
#line 112
  crc32val = 0U;
#line 113
  i = 0U;
#line 113
  while (i < len) {
#line 115
    crc32val = crc32_tab[(crc32val ^ (unsigned int )*(s + i)) & 255U] ^ (crc32val >> 8);
#line 113
    i ++;
  }
#line 119
  return (crc32val);
}
}
#line 1 "deattack.o"
#pragma merger(0,"./deattack.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 26 "deattack.h"
int detect_attack(unsigned char *buf , u_int32_t len , unsigned char *IV ) ;
#line 48 "deattack.c"
void crc_update(u_int32_t *a , u_int32_t b ) 
{ 

  {
#line 51
  b ^= *a;
#line 52
  *a = crc32((unsigned char const   *)((unsigned char *)(& b)), sizeof(b));
#line 53
  return;
}
}
#line 60 "deattack.c"
int check_crc(unsigned char *S , unsigned char *buf , u_int32_t len , unsigned char *IV ) 
{ u_int32_t crc ;
  unsigned char *c ;
  int tmp ;
  int tmp___0 ;

  {
#line 66
  crc = 0U;
#line 67
  if (IV) {
#line 67
    tmp = memcmp((void const   *)S, (void const   *)IV, 8U);
#line 67
    if (! tmp) {
#line 69
      crc_update(& crc, 1U);
#line 70
      crc_update(& crc, 0U);
    }
  }
#line 72
  c = buf;
#line 72
  while ((unsigned int )c < (unsigned int )(buf + len)) {
#line 74
    tmp___0 = memcmp((void const   *)S, (void const   *)c, 8U);
#line 74
    if (tmp___0) {
#line 80
      crc_update(& crc, 0U);
#line 81
      crc_update(& crc, 0U);
    } else {
#line 76
      crc_update(& crc, 1U);
#line 77
      crc_update(& crc, 0U);
    }
#line 72
    c += 8;
  }
#line 85
  return (crc == 0U);
}
}
#line 96 "deattack.c"
static u_int16_t *h  =    (u_int16_t *)((void *)0);
#line 97 "deattack.c"
static u_int16_t n  =    (u_int16_t )4096;
#line 93 "deattack.c"
int detect_attack(unsigned char *buf , u_int32_t len , unsigned char *IV ) 
{ register u_int32_t i ;
  register u_int32_t j ;
  u_int32_t l ;
  register unsigned char *c ;
  unsigned char *d ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 103
  if (len > 262144U) {
#line 105
    fatal("detect_attack: bad length %d", len);
  } else {
#line 103
    if (len % 8U != 0U) {
#line 105
      fatal("detect_attack: bad length %d", len);
    }
  }
#line 108
  l = (unsigned int )n;
#line 108
  while (l < ((len / 8U) * 3U) / 2U) {
#line 108
    l <<= 2;
  }
#line 110
  if ((unsigned int )h == (unsigned int )((void *)0)) {
#line 112
    debug("Installing crc compensation attack detector.");
#line 113
    n = (unsigned short )l;
#line 114
    tmp = xmalloc((unsigned int )((int )n * 2));
#line 114
    h = (u_int16_t *)tmp;
  } else {
#line 117
    if (l > (u_int32_t )n) {
#line 119
      n = (unsigned short )l;
#line 120
      tmp___0 = xrealloc((void *)h, (unsigned int )((int )n * 2));
#line 120
      h = (u_int16_t *)tmp___0;
    }
  }
#line 125
  if (len <= 56U) {
#line 127
    c = buf;
#line 127
    while ((unsigned int )c < (unsigned int )(buf + len)) {
#line 129
      if (IV) {
#line 129
        tmp___2 = memcmp((void const   *)c, (void const   *)IV, 8U);
#line 129
        if (! tmp___2) {
#line 131
          tmp___1 = check_crc(c, buf, len, (unsigned char *)IV);
#line 131
          if (tmp___1) {
#line 132
            return (1);
          } else {
#line 134
            break;
          }
        }
      }
#line 136
      d = buf;
#line 136
      while ((unsigned int )d < (unsigned int )c) {
#line 138
        tmp___4 = memcmp((void const   *)c, (void const   *)d, 8U);
#line 138
        if (! tmp___4) {
#line 140
          tmp___3 = check_crc(c, buf, len, (unsigned char *)IV);
#line 140
          if (tmp___3) {
#line 141
            return (1);
          } else {
#line 143
            break;
          }
        }
#line 136
        d += 8;
      }
#line 127
      c += 8;
    }
#line 147
    return (0);
  }
#line 149
  memset((void *)h, 255, (unsigned int )((int )n * 2));
#line 151
  if (IV) {
#line 152
    *(h + ((((((unsigned long )*(IV + 0) << 24) | ((unsigned long )*(IV + 1) << 16)) | ((unsigned long )*(IV + 2) << 8)) | (unsigned long )*(IV + 3)) & (unsigned long )((int )n - 1))) = (unsigned short)65534;
  }
#line 155
  c = buf;
#line 155
  j = 0U;
#line 155
  while ((unsigned int )c < (unsigned int )(buf + len)) {
#line 157
    i = (unsigned int )((((((unsigned long )*(c + 0) << 24) | ((unsigned long )*(c + 1) << 16)) | ((unsigned long )*(c + 2) << 8)) | (unsigned long )*(c + 3)) & (unsigned long )((int )n - 1));
#line 157
    while ((int )*(h + i) != 65535) {
#line 160
      if ((int )*(h + i) == 65534) {
#line 162
        tmp___6 = memcmp((void const   *)c, (void const   *)IV, 8U);
#line 162
        if (! tmp___6) {
#line 164
          tmp___5 = check_crc(c, buf, len, (unsigned char *)IV);
#line 164
          if (tmp___5) {
#line 165
            return (1);
          } else {
#line 167
            break;
          }
        }
      } else {
#line 169
        tmp___8 = memcmp((void const   *)c, (void const   *)(buf + (int )*(h + i) * 8),
                         8U);
#line 169
        if (! tmp___8) {
#line 171
          tmp___7 = check_crc(c, buf, len, (unsigned char *)IV);
#line 171
          if (tmp___7) {
#line 172
            return (1);
          } else {
#line 174
            break;
          }
        }
      }
#line 157
      i = (i + 1U) & (unsigned int )((int )n - 1);
    }
#line 177
    *(h + i) = (unsigned short )j;
#line 155
    c += 8;
#line 155
    j ++;
  }
#line 180
  return (0);
}
}
#line 1 "hostfile.o"
#pragma merger(0,"./hostfile.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 382
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
#line 433
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 433 "/usr/include/sys/stat.h"
__inline static int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
#line 436
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
#line 436
  return (tmp);
}
}
#line 213 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 248
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 532
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 116 "/usr/include/ctype.h"
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 603 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 457 "/usr/include/openssl/bn.h"
extern int BN_cmp(BIGNUM const   *a , BIGNUM const   *b ) ;
#line 496
extern char *BN_bn2dec(BIGNUM const   *a ) ;
#line 498
extern int BN_dec2bn(BIGNUM **a , char const   *str ) ;
#line 141 "packet.h"
void packet_send_debug(char const   *fmt  , ...) ;
#line 308 "ssh.h"
int auth_rsa_read_key(char **cpp , unsigned int *bitsp , BIGNUM *e , BIGNUM *n___0 ) ;
#line 333
int match_hostname(char const   *host , char const   *pattern , unsigned int len ) ;
#line 340
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , unsigned int bits ,
                                  BIGNUM *e , BIGNUM *n___0 , BIGNUM *ke , BIGNUM *kn ) ;
#line 347
int add_host_to_hostfile(char const   *filename , char const   *host , unsigned int bits ,
                         BIGNUM *e , BIGNUM *n___0 ) ;
#line 568
int match_pattern(char const   *s , char const   *pattern ) ;
#line 28 "hostfile.c"
int auth_rsa_read_bignum(char **cpp , BIGNUM *value ) 
{ char *cp ;
  int len ;
  int old ;
  int tmp ;

  {
#line 31
  cp = *cpp;
#line 35
  while (1) {
#line 35
    if (! ((int )*cp == 32)) {
#line 35
      if (! ((int )*cp == 9)) {
#line 35
        break;
      }
    }
#line 35
    cp ++;
  }
#line 39
  if ((int )*cp < 48) {
#line 40
    return (0);
  } else {
#line 39
    if ((int )*cp > 57) {
#line 40
      return (0);
    }
  }
#line 43
  *cpp = cp;
#line 46
  while (1) {
#line 46
    if ((int )*cp >= 48) {
#line 46
      if (! ((int )*cp <= 57)) {
#line 46
        break;
      }
    } else {
#line 46
      break;
    }
#line 46
    cp ++;
  }
#line 50
  len = cp - *cpp;
#line 53
  old = (int )*cp;
#line 54
  *cp = (char)0;
#line 58
  tmp = BN_dec2bn(& value, (char const   *)*cpp);
#line 58
  if (tmp == 0) {
#line 59
    return (0);
  }
#line 62
  *cp = (char )old;
#line 65
  *cpp = cp;
#line 66
  return (1);
}
}
#line 72 "hostfile.c"
int auth_rsa_read_key(char **cpp , unsigned int *bitsp , BIGNUM *e , BIGNUM *n___0 ) 
{ unsigned int bits ;
  char *cp ;
  int tmp ;
  int tmp___0 ;

  {
#line 79
  cp = *cpp;
#line 79
  while (1) {
#line 79
    if (! ((int )*cp == 32)) {
#line 79
      if (! ((int )*cp == 9)) {
#line 79
        break;
      }
    }
#line 79
    cp ++;
  }
#line 83
  if ((int )*cp < 48) {
#line 84
    return (0);
  } else {
#line 83
    if ((int )*cp > 57) {
#line 84
      return (0);
    }
  }
#line 85
  bits = 0U;
#line 85
  while (1) {
#line 85
    if ((int )*cp >= 48) {
#line 85
      if (! ((int )*cp <= 57)) {
#line 85
        break;
      }
    } else {
#line 85
      break;
    }
#line 86
    bits = (10U * bits + (unsigned int )*cp) - 48U;
#line 85
    cp ++;
  }
#line 89
  tmp = auth_rsa_read_bignum(& cp, e);
#line 89
  if (! tmp) {
#line 90
    return (0);
  }
#line 93
  tmp___0 = auth_rsa_read_bignum(& cp, n___0);
#line 93
  if (! tmp___0) {
#line 94
    return (0);
  }
#line 97
  while (1) {
#line 97
    if (! ((int )*cp == 32)) {
#line 97
      if (! ((int )*cp == 9)) {
#line 97
        break;
      }
    }
#line 97
    cp ++;
  }
#line 101
  *cpp = cp;
#line 102
  *bitsp = bits;
#line 103
  return (1);
}
}
#line 111 "hostfile.c"
int match_hostname(char const   *host , char const   *pattern , unsigned int len ) 
{ char sub[1024] ;
  int negated ;
  int got_positive ;
  unsigned int i ;
  unsigned int subi ;
  int __res___0 ;
  __int32_t const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;

  {
#line 119
  got_positive = 0;
#line 120
  i = 0U;
#line 120
  while (i < len) {
#line 123
    if ((int const   )*(pattern + i) == 33) {
#line 125
      negated = 1;
#line 126
      i ++;
    } else {
#line 129
      negated = 0;
    }
#line 133
    subi = 0U;
#line 133
    while (1) {
#line 133
      if (i < len) {
#line 133
        if (subi < sizeof(sub) - 1U) {
#line 133
          if (! ((int const   )*(pattern + i) != 44)) {
#line 133
            break;
          }
        } else {
#line 133
          break;
        }
      } else {
#line 133
        break;
      }
#line 136
      tmp___6 = __ctype_b_loc();
#line 136
      if ((int const   )*(*tmp___6 + (int )*(pattern + i)) & 256) {
#line 136
        if (sizeof(*(pattern + i)) > 1U) {
#line 136
          __res___0 = tolower((int )*(pattern + i));
        } else {
#line 136
          tmp___5 = __ctype_tolower_loc();
#line 136
          __res___0 = (int )*(*tmp___5 + (int )*(pattern + i));
        }
#line 136
        sub[subi] = (char )__res___0;
      } else {
#line 136
        sub[subi] = (char )*(pattern + i);
      }
#line 133
      subi ++;
#line 133
      i ++;
    }
#line 138
    if (subi >= sizeof(sub) - 1U) {
#line 139
      return (0);
    }
#line 142
    if (i < len) {
#line 142
      if ((int const   )*(pattern + i) == 44) {
#line 143
        i ++;
      }
    }
#line 146
    sub[subi] = (char )'\000';
#line 149
    tmp___7 = match_pattern(host, (char const   *)(sub));
#line 149
    if (tmp___7) {
#line 150
      if (negated) {
#line 151
        return (0);
      } else {
#line 153
        got_positive = 1;
      }
    }
  }
#line 159
  return (got_positive);
}
}
#line 168 "hostfile.c"
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , unsigned int bits ,
                                  BIGNUM *e , BIGNUM *n___0 , BIGNUM *ke , BIGNUM *kn ) 
{ FILE *f ;
  char line[8192] ;
  unsigned int kbits ;
  unsigned int hostlen ;
  char *cp ;
  char *cp2 ;
  HostStatus end_return ;
  struct stat st ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
#line 182
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 183
  if (! f) {
#line 185
    tmp = stat((char const   * __restrict  )filename, (struct stat * __restrict  )(& st));
#line 185
    if (tmp >= 0) {
#line 187
      packet_send_debug("Could not open %.900s for reading.", filename);
#line 188
      packet_send_debug("If your home directory is on an NFS volume, it may need to be world-readable.");
    }
#line 190
    return (1);
  }
#line 194
  hostlen = strlen(host);
#line 199
  end_return = 1;
#line 202
  while (1) {
#line 202
    tmp___4 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 202
    if (! tmp___4) {
#line 202
      break;
    }
#line 204
    cp = line;
#line 207
    while (1) {
#line 207
      if (! ((int )*cp == 32)) {
#line 207
        if (! ((int )*cp == 9)) {
#line 207
          break;
        }
      }
#line 207
      cp ++;
    }
#line 211
    if (! *cp) {
#line 212
      continue;
    } else {
#line 211
      if ((int )*cp == 35) {
#line 212
        continue;
      } else {
#line 211
        if ((int )*cp == 10) {
#line 212
          continue;
        }
      }
    }
#line 215
    cp2 = cp;
#line 215
    while (1) {
#line 215
      if (*cp2) {
#line 215
        if ((int )*cp2 != 32) {
#line 215
          if (! ((int )*cp2 != 9)) {
#line 215
            break;
          }
        } else {
#line 215
          break;
        }
      } else {
#line 215
        break;
      }
#line 215
      cp2 ++;
    }
#line 219
    tmp___0 = match_hostname(host, (char const   *)cp, (unsigned int )(cp2 - cp));
#line 219
    if (! tmp___0) {
#line 220
      continue;
    }
#line 223
    cp = cp2;
#line 227
    tmp___1 = auth_rsa_read_key(& cp, & kbits, ke, kn);
#line 227
    if (! tmp___1) {
#line 228
      continue;
    }
#line 231
    if (kbits == bits) {
#line 231
      tmp___2 = BN_cmp((BIGNUM const   *)ke, (BIGNUM const   *)e);
#line 231
      if (tmp___2 == 0) {
#line 231
        tmp___3 = BN_cmp((BIGNUM const   *)kn, (BIGNUM const   *)n___0);
#line 231
        if (tmp___3 == 0) {
#line 234
          fclose(f);
#line 235
          return (0);
        }
      }
    }
#line 240
    end_return = 2;
  }
#line 243
  fclose(f);
#line 247
  return (end_return);
}
}
#line 253 "hostfile.c"
int add_host_to_hostfile(char const   *filename , char const   *host , unsigned int bits ,
                         BIGNUM *e , BIGNUM *n___0 ) 
{ FILE *f ;
  char *buf ;

  {
#line 261
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"a");
#line 262
  if (! f) {
#line 263
    return (0);
  }
#line 266
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %u ", host, bits);
#line 267
  buf = BN_bn2dec((BIGNUM const   *)e);
#line 268
  if ((unsigned int )buf == (unsigned int )((void *)0)) {
#line 269
    error("add_host_to_hostfile: BN_bn2dec #1 failed");
#line 270
    fclose(f);
#line 271
    return (0);
  }
#line 273
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s ", buf);
#line 274
  free((void *)buf);
#line 275
  buf = BN_bn2dec((BIGNUM const   *)n___0);
#line 276
  if ((unsigned int )buf == (unsigned int )((void *)0)) {
#line 277
    error("add_host_to_hostfile: BN_bn2dec #2 failed");
#line 278
    fclose(f);
#line 279
    return (0);
  }
#line 281
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s\n", buf);
#line 282
  free((void *)buf);
#line 285
  fclose(f);
#line 286
  return (1);
}
}
#line 1 "match.o"
#pragma merger(0,"./match.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 24 "match.c"
int match_pattern(char const   *s , char const   *pattern ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 26
  while (1) {
#line 29
    if (! *pattern) {
#line 30
      return (! *s);
    }
#line 33
    if ((int const   )*pattern == 42) {
#line 36
      pattern ++;
#line 39
      if (! *pattern) {
#line 40
        return (1);
      }
#line 43
      if ((int const   )*pattern != 63) {
#line 43
        if ((int const   )*pattern != 42) {
#line 47
          while (*s) {
#line 48
            if ((int const   )*s == (int const   )*pattern) {
#line 48
              tmp = match_pattern(s + 1, pattern + 1);
#line 48
              if (tmp) {
#line 50
                return (1);
              }
            }
#line 47
            s ++;
          }
#line 52
          return (0);
        }
      }
#line 57
      while (*s) {
#line 58
        tmp___0 = match_pattern(s, pattern);
#line 58
        if (tmp___0) {
#line 59
          return (1);
        }
#line 57
        s ++;
      }
#line 61
      return (0);
    }
#line 66
    if (! *s) {
#line 67
      return (0);
    }
#line 70
    if ((int const   )*pattern != 63) {
#line 70
      if ((int const   )*pattern != (int const   )*s) {
#line 71
        return (0);
      }
    }
#line 74
    s ++;
#line 75
    pattern ++;
  }
}
}
#line 1 "mpaux.o"
#pragma merger(0,"./mpaux.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 34 "mpaux.c"
void compute_session_id(unsigned char *session_id___0 , unsigned char *cookie , unsigned int host_key_bits ,
                        BIGNUM *host_key_n , unsigned int session_key_bits , BIGNUM *session_key_n ) 
{ unsigned int bytes ;
  unsigned char *buf ;
  void *tmp ;
  MD5_CTX md ;

  {
#line 42
  bytes = ((host_key_bits + 7U) / 8U + (session_key_bits + 7U) / 8U) + 8U;
#line 43
  tmp = xmalloc(bytes);
#line 43
  buf = (unsigned char *)tmp;
#line 46
  BN_bn2bin((BIGNUM const   *)host_key_n, buf);
#line 47
  BN_bn2bin((BIGNUM const   *)session_key_n, buf + (host_key_bits + 7U) / 8U);
#line 48
  memcpy((void * __restrict  )((buf + (host_key_bits + 7U) / 8U) + (session_key_bits + 7U) / 8U),
         (void const   * __restrict  )cookie, 8U);
#line 50
  MD5_Init(& md);
#line 51
  MD5_Update(& md, (void const   *)buf, bytes);
#line 52
  MD5_Final((unsigned char *)session_id___0, & md);
#line 53
  xfree((void *)buf);
#line 54
  return;
}
}
#line 1 "nchan.o"
#pragma merger(0,"./nchan.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 11 "nchan.c"
static void chan_send_ieof(Channel *c ) ;
#line 12
static void chan_send_oclose(Channel *c ) ;
#line 13
static void chan_shutdown_write(Channel *c ) ;
#line 14
static void chan_shutdown_read(Channel *c ) ;
#line 15
static void chan_delele_if_full_closed(Channel *c ) ;
#line 22 "nchan.c"
void chan_rcvd_oclose(Channel *c ) 
{ 

  {
#line 24
  switch (c->istate) {
  case 4: 
#line 26
  debug("channel %d: INPUT_WAIT_OCLOSE -> INPUT_CLOSED [rcvd OCLOSE]", c->self);
#line 27
  c->istate = 8;
#line 28
  chan_delele_if_full_closed(c);
#line 29
  break;
  case 1: 
#line 31
  debug("channel %d: INPUT_OPEN -> INPUT_CLOSED [rvcd OCLOSE, send IEOF]", c->self);
#line 32
  chan_shutdown_read(c);
#line 33
  chan_send_ieof(c);
#line 34
  c->istate = 8;
#line 35
  chan_delele_if_full_closed(c);
#line 36
  break;
  default: 
#line 38
  debug("protocol error: chan_rcvd_oclose %d for istate %d", c->self, c->istate);
#line 39
  break;
  }
#line 41
  return;
}
}
#line 42 "nchan.c"
void chan_read_failed(Channel *c ) 
{ 

  {
#line 44
  switch (c->istate) {
  case 1: 
#line 46
  debug("channel %d: INPUT_OPEN -> INPUT_WAIT_DRAIN [read failed]", c->self);
#line 47
  chan_shutdown_read(c);
#line 48
  c->istate = 2;
#line 49
  break;
  default: 
#line 51
  debug("internal error: we do not read, but chan_read_failed %d for istate %d", c->self,
        c->istate);
#line 53
  break;
  }
#line 55
  return;
}
}
#line 56 "nchan.c"
void chan_ibuf_empty(Channel *c ) 
{ unsigned int tmp ;

  {
#line 58
  tmp = buffer_len(& c->input);
#line 58
  if (tmp) {
#line 59
    debug("internal error: chan_ibuf_empty %d for non empty buffer", c->self);
#line 60
    return;
  }
#line 62
  switch (c->istate) {
  case 2: 
#line 64
  debug("channel %d: INPUT_WAIT_DRAIN -> INPUT_WAIT_OCLOSE [inbuf empty, send IEOF]",
        c->self);
#line 65
  chan_send_ieof(c);
#line 66
  c->istate = 4;
#line 67
  break;
  default: 
#line 69
  debug("internal error: chan_ibuf_empty %d for istate %d", c->self, c->istate);
#line 70
  break;
  }
#line 72
  return;
}
}
#line 74 "nchan.c"
void chan_rcvd_ieof(Channel *c ) 
{ 

  {
#line 76
  switch (c->ostate) {
  case 16: 
#line 78
  debug("channel %d: OUTPUT_OPEN -> OUTPUT_WAIT_DRAIN [rvcd IEOF]", c->self);
#line 79
  c->ostate = 32;
#line 80
  break;
  case 64: 
#line 82
  debug("channel %d: OUTPUT_WAIT_IEOF -> OUTPUT_CLOSED [rvcd IEOF]", c->self);
#line 83
  c->ostate = 128;
#line 84
  chan_delele_if_full_closed(c);
#line 85
  break;
  default: 
#line 87
  debug("protocol error: chan_rcvd_ieof %d for ostate %d", c->self, c->ostate);
#line 88
  break;
  }
#line 90
  return;
}
}
#line 91 "nchan.c"
void chan_write_failed(Channel *c ) 
{ 

  {
#line 93
  switch (c->ostate) {
  case 16: 
#line 95
  debug("channel %d: OUTPUT_OPEN -> OUTPUT_WAIT_IEOF [write failed]", c->self);
#line 96
  chan_send_oclose(c);
#line 97
  c->ostate = 64;
#line 98
  break;
  case 32: 
#line 100
  debug("channel %d: OUTPUT_WAIT_DRAIN -> OUTPUT_CLOSED [write failed]", c->self);
#line 101
  chan_send_oclose(c);
#line 102
  c->ostate = 128;
#line 103
  chan_delele_if_full_closed(c);
#line 104
  break;
  default: 
#line 106
  debug("internal error: chan_write_failed %d for ostate %d", c->self, c->ostate);
#line 107
  break;
  }
#line 109
  return;
}
}
#line 110 "nchan.c"
void chan_obuf_empty(Channel *c ) 
{ unsigned int tmp ;

  {
#line 112
  tmp = buffer_len(& c->output);
#line 112
  if (tmp) {
#line 113
    debug("internal error: chan_obuf_empty %d for non empty buffer", c->self);
#line 114
    return;
  }
#line 116
  switch (c->ostate) {
  case 32: 
#line 118
  debug("channel %d: OUTPUT_WAIT_DRAIN -> OUTPUT_CLOSED [obuf empty, send OCLOSE]",
        c->self);
#line 119
  chan_send_oclose(c);
#line 120
  c->ostate = 128;
#line 121
  chan_delele_if_full_closed(c);
#line 122
  break;
  default: 
#line 124
  debug("internal error: chan_obuf_empty %d for ostate %d", c->self, c->ostate);
#line 125
  break;
  }
#line 127
  return;
}
}
#line 131 "nchan.c"
static void chan_send_ieof(Channel *c ) 
{ 

  {
#line 133
  switch (c->istate) {
  case 1: 
  case 2: 
#line 136
  packet_start(24);
#line 137
  packet_put_int((unsigned int )c->remote_id);
#line 138
  packet_send();
#line 139
  break;
  default: 
#line 141
  debug("internal error: channel %d: cannot send IEOF for istate %d", c->self, c->istate);
#line 142
  break;
  }
#line 144
  return;
}
}
#line 145 "nchan.c"
static void chan_send_oclose(Channel *c ) 
{ unsigned int tmp ;

  {
#line 147
  switch (c->ostate) {
  case 16: 
  case 32: 
#line 150
  chan_shutdown_write(c);
#line 151
  tmp = buffer_len(& c->output);
#line 151
  buffer_consume(& c->output, tmp);
#line 152
  packet_start(25);
#line 153
  packet_put_int((unsigned int )c->remote_id);
#line 154
  packet_send();
#line 155
  break;
  default: 
#line 157
  debug("internal error: channel %d: cannot send OCLOSE for ostate %d", c->self, c->istate);
#line 158
  break;
  }
#line 160
  return;
}
}
#line 162 "nchan.c"
static void chan_shutdown_write(Channel *c ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 164
  debug("channel %d: shutdown_write", c->self);
#line 165
  tmp___1 = shutdown(c->sock, 1);
#line 165
  if (tmp___1 < 0) {
#line 166
    tmp = __errno_location();
#line 166
    tmp___0 = strerror(*tmp);
#line 166
    error("chan_shutdown_write failed for #%d/fd%d: %.100s", c->self, c->sock, tmp___0);
  }
#line 168
  return;
}
}
#line 169 "nchan.c"
static void chan_shutdown_read(Channel *c ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 171
  debug("channel %d: shutdown_read", c->self);
#line 172
  tmp___1 = shutdown(c->sock, 0);
#line 172
  if (tmp___1 < 0) {
#line 173
    tmp = __errno_location();
#line 173
    tmp___0 = strerror(*tmp);
#line 173
    error("chan_shutdown_read failed for #%d/fd%d: %.100s", c->self, c->sock, tmp___0);
  }
#line 175
  return;
}
}
#line 176 "nchan.c"
static void chan_delele_if_full_closed(Channel *c ) 
{ 

  {
#line 178
  if (c->istate == 8) {
#line 178
    if (c->ostate == 128) {
#line 179
      debug("channel %d: closing", c->self);
#line 180
      channel_free(c->self);
    }
  }
#line 182
  return;
}
}
#line 183 "nchan.c"
void chan_init_iostates(Channel *c ) 
{ 

  {
#line 185
  c->ostate = 16;
#line 186
  c->istate = 1;
#line 187
  return;
}
}
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 1 "packet.o"
#pragma merger(0,"./packet.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 192 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 361 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 76 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 33 "packet.h"
void packet_set_connection(int fd_in , int fd_out ) ;
#line 36
void packet_set_nonblocking(void) ;
#line 46
void packet_close(void) ;
#line 52
void packet_set_encryption_key(unsigned char const   *key , unsigned int keylen ,
                               int cipher , int is_client ) ;
#line 57
void packet_set_protocol_flags(unsigned int protocol_flags ) ;
#line 60
unsigned int packet_get_protocol_flags(void) ;
#line 63
void packet_start_compression(int level ) ;
#line 67
void packet_set_interactive(int interactive , int keepalives ) ;
#line 76
void packet_put_char(int value ) ;
#line 82
void packet_put_bignum(BIGNUM *value ) ;
#line 92
int packet_read(int *payload_len_ptr ) ;
#line 105
int packet_read_poll(int *payload_len_ptr ) ;
#line 109
void packet_process_incoming(char const   *buf , unsigned int len ) ;
#line 112
unsigned int packet_get_char(void) ;
#line 119
void packet_get_bignum(BIGNUM *value , int *length_ptr ) ;
#line 145
void packet_write_poll(void) ;
#line 151
int packet_have_data_to_write(void) ;
#line 154
int packet_not_very_much_data_to_write(void) ;
#line 36 "packet.c"
static int connection_in  =    -1;
#line 37 "packet.c"
static int connection_out  =    -1;
#line 41 "packet.c"
static int cipher_type  =    0;
#line 44 "packet.c"
static unsigned int remote_protocol_flags  =    0U;
#line 47 "packet.c"
static CipherContext receive_context  ;
#line 49 "packet.c"
static CipherContext send_context  ;
#line 52 "packet.c"
static Buffer input  ;
#line 55 "packet.c"
static Buffer output  ;
#line 58 "packet.c"
static Buffer outgoing_packet  ;
#line 61 "packet.c"
static Buffer incoming_packet  ;
#line 64 "packet.c"
static Buffer compression_buffer  ;
#line 67 "packet.c"
static int packet_compression  =    0;
#line 70 "packet.c"
static int initialized  =    0;
#line 73 "packet.c"
static int interactive_mode  =    0;
#line 78 "packet.c"
void packet_set_connection(int fd_in , int fd_out ) 
{ 

  {
#line 81
  connection_in = fd_in;
#line 82
  connection_out = fd_out;
#line 83
  cipher_type = 0;
#line 84
  cipher_set_key(& send_context, 0, (unsigned char const   *)((unsigned char *)""),
                 0, 1);
#line 85
  cipher_set_key(& receive_context, 0, (unsigned char const   *)((unsigned char *)""),
                 0, 0);
#line 86
  if (! initialized) {
#line 88
    initialized = 1;
#line 89
    buffer_init(& input);
#line 90
    buffer_init(& output);
#line 91
    buffer_init(& outgoing_packet);
#line 92
    buffer_init(& incoming_packet);
  }
#line 96
  fatal_add_cleanup((void (*)(void * ))(& packet_close), (void *)0);
#line 97
  return;
}
}
#line 101 "packet.c"
void packet_set_nonblocking(void) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 105
  tmp___1 = fcntl(connection_in, 4, 2048);
#line 105
  if (tmp___1 < 0) {
#line 106
    tmp = __errno_location();
#line 106
    tmp___0 = strerror(*tmp);
#line 106
    error("fcntl O_NONBLOCK: %.100s", tmp___0);
  }
#line 108
  if (connection_out != connection_in) {
#line 110
    tmp___4 = fcntl(connection_out, 4, 2048);
#line 110
    if (tmp___4 < 0) {
#line 111
      tmp___2 = __errno_location();
#line 111
      tmp___3 = strerror(*tmp___2);
#line 111
      error("fcntl O_NONBLOCK: %.100s", tmp___3);
    }
  }
#line 113
  return;
}
}
#line 117 "packet.c"
int packet_get_connection_in(void) 
{ 

  {
#line 120
  return (connection_in);
}
}
#line 125 "packet.c"
int packet_get_connection_out(void) 
{ 

  {
#line 128
  return (connection_out);
}
}
#line 133 "packet.c"
void packet_close(void) 
{ 

  {
#line 136
  if (! initialized) {
#line 137
    return;
  }
#line 138
  initialized = 0;
#line 139
  if (connection_in == connection_out) {
#line 141
    shutdown(connection_out, 2);
#line 142
    close(connection_out);
  } else {
#line 146
    close(connection_in);
#line 147
    close(connection_out);
  }
#line 149
  buffer_free(& input);
#line 150
  buffer_free(& output);
#line 151
  buffer_free(& outgoing_packet);
#line 152
  buffer_free(& incoming_packet);
#line 153
  if (packet_compression) {
#line 155
    buffer_free(& compression_buffer);
#line 156
    buffer_compress_uninit();
  }
#line 158
  return;
}
}
#line 162 "packet.c"
void packet_set_protocol_flags(unsigned int protocol_flags ) 
{ 

  {
#line 165
  remote_protocol_flags = protocol_flags;
#line 166
  channel_set_options((protocol_flags & 2U) != 0U);
#line 167
  return;
}
}
#line 171 "packet.c"
unsigned int packet_get_protocol_flags(void) 
{ 

  {
#line 174
  return (remote_protocol_flags);
}
}
#line 180 "packet.c"
void packet_start_compression(int level ) 
{ 

  {
#line 183
  if (packet_compression) {
#line 184
    fatal("Compression already enabled.");
  }
#line 185
  packet_compression = 1;
#line 186
  buffer_init(& compression_buffer);
#line 187
  buffer_compress_init(level);
#line 188
  return;
}
}
#line 193 "packet.c"
void packet_encrypt(CipherContext *cc , void *dest , void *src , unsigned int bytes ) 
{ 

  {
#line 197
  cipher_encrypt(cc, (unsigned char *)dest, (unsigned char const   *)src, bytes);
#line 198
  return;
}
}
#line 203 "packet.c"
void packet_decrypt(CipherContext *cc , void *dest , void *src , unsigned int bytes ) 
{ int i ;

  {
#line 209
  if (bytes % 8U != 0U) {
#line 210
    fatal("packet_decrypt: bad ciphertext length %d", bytes);
  }
#line 217
  switch ((int )cc->type) {
  case 0: 
#line 220
  i = 0;
#line 221
  break;
  default: 
#line 223
  i = detect_attack((unsigned char *)src, bytes, (unsigned char *)((void *)0));
#line 224
  break;
  }
#line 227
  if (i == 1) {
#line 228
    packet_disconnect("crc32 compensation attack: network attack detected");
  }
#line 230
  cipher_decrypt(cc, (unsigned char *)dest, (unsigned char const   *)src, bytes);
#line 231
  return;
}
}
#line 237 "packet.c"
void packet_set_encryption_key(unsigned char const   *key , unsigned int keylen ,
                               int cipher , int is_client ) 
{ 

  {
#line 241
  cipher_type = cipher;
#line 242
  if (cipher == 5) {
#line 244
    if (is_client) {
#line 246
      cipher_set_key(& receive_context, cipher, key, (int )(keylen / 2U), 0);
#line 247
      cipher_set_key(& send_context, cipher, key + keylen / 2U, (int )(keylen / 2U),
                     1);
    } else {
#line 252
      cipher_set_key(& receive_context, cipher, key + keylen / 2U, (int )(keylen / 2U),
                     0);
#line 254
      cipher_set_key(& send_context, cipher, key, (int )(keylen / 2U), 1);
    }
  } else {
#line 260
    cipher_set_key(& receive_context, cipher, key, (int )keylen, 0);
#line 261
    cipher_set_key(& send_context, cipher, key, (int )keylen, 1);
  }
#line 263
  return;
}
}
#line 267 "packet.c"
void packet_start(int type ) 
{ char buf[9] ;

  {
#line 272
  buffer_clear(& outgoing_packet);
#line 273
  memset((void *)(buf), 0, 8U);
#line 274
  buf[8] = (char )type;
#line 275
  buffer_append(& outgoing_packet, (char const   *)(buf), 9U);
#line 276
  return;
}
}
#line 280 "packet.c"
void packet_put_char(int value ) 
{ char ch ;

  {
#line 283
  ch = (char )value;
#line 284
  buffer_append(& outgoing_packet, (char const   *)(& ch), 1U);
#line 285
  return;
}
}
#line 289 "packet.c"
void packet_put_int(unsigned int value ) 
{ 

  {
#line 292
  buffer_put_int(& outgoing_packet, value);
#line 293
  return;
}
}
#line 297 "packet.c"
void packet_put_string(char const   *buf , unsigned int len ) 
{ 

  {
#line 300
  buffer_put_string(& outgoing_packet, (void const   *)buf, len);
#line 301
  return;
}
}
#line 305 "packet.c"
void packet_put_bignum(BIGNUM *value ) 
{ 

  {
#line 308
  buffer_put_bignum(& outgoing_packet, value);
#line 309
  return;
}
}
#line 314 "packet.c"
void packet_send(void) 
{ char buf[8] ;
  char *cp ;
  int i ;
  int padding ;
  int len ;
  unsigned int checksum ;
  u_int32_t rand___0 ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  char *tmp___6 ;

  {
#line 320
  rand___0 = (u_int32_t )0;
#line 324
  if (packet_compression) {
#line 326
    buffer_clear(& compression_buffer);
#line 327
    buffer_consume(& outgoing_packet, 8U);
#line 328
    buffer_append(& compression_buffer, "\000\000\000\000\000\000\000\000", 8U);
#line 329
    buffer_compress(& outgoing_packet, & compression_buffer);
#line 330
    buffer_clear(& outgoing_packet);
#line 331
    tmp = buffer_len(& compression_buffer);
#line 331
    tmp___0 = buffer_ptr(& compression_buffer);
#line 331
    buffer_append(& outgoing_packet, (char const   *)tmp___0, tmp);
  }
#line 336
  tmp___1 = buffer_len(& outgoing_packet);
#line 336
  len = (int )((tmp___1 + 4U) - 8U);
#line 339
  padding = 8 - len % 8;
#line 340
  if (cipher_type != 0) {
#line 342
    cp = buffer_ptr(& outgoing_packet);
#line 343
    i = 0;
#line 343
    while (i < padding) {
#line 344
      if (i % 4 == 0) {
#line 345
        rand___0 = arc4random();
      }
#line 346
      *(cp + (7 - i)) = (char )(rand___0 & 255U);
#line 347
      rand___0 >>= 8;
#line 343
      i ++;
    }
  }
#line 350
  buffer_consume(& outgoing_packet, (unsigned int )(8 - padding));
#line 353
  tmp___2 = buffer_len(& outgoing_packet);
#line 353
  tmp___3 = buffer_ptr(& outgoing_packet);
#line 353
  checksum = crc32((unsigned char const   *)((unsigned char *)tmp___3), tmp___2);
#line 355
  while (1) {
#line 355
    buf[0] = (char )(checksum >> 24);
#line 355
    buf[1] = (char )(checksum >> 16);
#line 355
    buf[2] = (char )(checksum >> 8);
#line 355
    buf[3] = (char )checksum;
#line 355
    break;
  }
#line 356
  buffer_append(& outgoing_packet, (char const   *)(buf), 4U);
#line 364
  while (1) {
#line 364
    buf[0] = (char )(len >> 24);
#line 364
    buf[1] = (char )(len >> 16);
#line 364
    buf[2] = (char )(len >> 8);
#line 364
    buf[3] = (char )len;
#line 364
    break;
  }
#line 365
  buffer_append(& output, (char const   *)(buf), 4U);
#line 366
  tmp___4 = buffer_len(& outgoing_packet);
#line 366
  buffer_append_space(& output, & cp, tmp___4);
#line 367
  tmp___5 = buffer_len(& outgoing_packet);
#line 367
  tmp___6 = buffer_ptr(& outgoing_packet);
#line 367
  packet_encrypt(& send_context, (void *)cp, (void *)tmp___6, tmp___5);
#line 374
  buffer_clear(& outgoing_packet);
#line 378
  return;
}
}
#line 384 "packet.c"
int packet_read(int *payload_len_ptr ) 
{ int type ;
  int len ;
  fd_set set ;
  char buf[8192] ;
  int _p ;
  int _e ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 392
  packet_write_wait();
#line 395
  while (1) {
#line 398
    type = packet_read_poll(payload_len_ptr);
#line 399
    if (type == 14) {
      goto _L;
    } else {
#line 399
      if (type == 15) {
        goto _L;
      } else {
#line 399
        if (type == 19) {
          goto _L;
        } else {
#line 399
          if (type == 33) {
            _L: /* CIL Label */ 
#line 403
            while (1) {
#line 403
              _p = *payload_len_ptr;
#line 403
              _e = 0;
#line 403
              if (_p != _e) {
#line 403
                log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "packet.c",
                    403);
#line 403
                packet_disconnect("Packet integrity error. (%d)", type);
              }
#line 403
              break;
            }
          }
        }
      }
    }
#line 405
    if (type != 0) {
#line 406
      return (type);
    }
#line 409
    while (1) {
#line 409
      __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& set.__fds_bits[0]): "memory");
#line 409
      break;
    }
#line 410
    __asm__  volatile   ("btsl %1,%0": "=m" (set.__fds_bits[(unsigned int )connection_in / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 412
    select(connection_in + 1, (fd_set * __restrict  )(& set), (fd_set * __restrict  )((void *)0),
           (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 414
    len = read(connection_in, (void *)(buf), sizeof(buf));
#line 415
    if (len == 0) {
#line 416
      fatal("Connection closed by remote host.");
    }
#line 417
    if (len < 0) {
#line 418
      tmp = __errno_location();
#line 418
      tmp___0 = strerror(*tmp);
#line 418
      fatal("Read from socket failed: %.100s", tmp___0);
    }
#line 420
    packet_process_incoming((char const   *)(buf), (unsigned int )len);
  }
}
}
#line 428 "packet.c"
void packet_read_expect(int *payload_len_ptr , int expected_type ) 
{ int type ;

  {
#line 433
  type = packet_read(payload_len_ptr);
#line 434
  if (type != expected_type) {
#line 435
    packet_disconnect("Protocol error: expected packet type %d, got %d", expected_type,
                      type);
  }
#line 437
  return;
}
}
#line 456 "packet.c"
int packet_read_poll(int *payload_len_ptr ) 
{ unsigned int len ;
  unsigned int padded_len ;
  unsigned char *ucp ;
  char buf[8] ;
  char *cp ;
  unsigned int checksum ;
  unsigned int stored_checksum ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  char *tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  unsigned int tmp___8 ;
  char *tmp___9 ;
  unsigned int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;

  {
  restart: 
#line 467
  tmp = buffer_len(& input);
#line 467
  if (tmp < 12U) {
#line 468
    return (0);
  }
#line 470
  tmp___0 = buffer_ptr(& input);
#line 470
  ucp = (unsigned char *)tmp___0;
#line 471
  len = (unsigned int )(((((unsigned long )*(ucp + 0) << 24) | ((unsigned long )*(ucp + 1) << 16)) | ((unsigned long )*(ucp + 2) << 8)) | (unsigned long )*(ucp + 3));
#line 472
  if (len < 5U) {
#line 473
    packet_disconnect("Bad packet length %d.", len);
  } else {
#line 472
    if (len > 262144U) {
#line 473
      packet_disconnect("Bad packet length %d.", len);
    }
  }
#line 474
  padded_len = (len + 8U) & 4294967288U;
#line 477
  tmp___1 = buffer_len(& input);
#line 477
  if (tmp___1 < 4U + padded_len) {
#line 478
    return (0);
  }
#line 483
  buffer_consume(& input, 4U);
#line 486
  buffer_clear(& incoming_packet);
#line 487
  buffer_append_space(& incoming_packet, & cp, padded_len);
#line 488
  tmp___2 = buffer_ptr(& input);
#line 488
  packet_decrypt(& receive_context, (void *)cp, (void *)tmp___2, padded_len);
#line 489
  buffer_consume(& input, padded_len);
#line 496
  tmp___3 = buffer_len(& incoming_packet);
#line 496
  tmp___4 = buffer_ptr(& incoming_packet);
#line 496
  checksum = crc32((unsigned char const   *)((unsigned char *)tmp___4), tmp___3 - 4U);
#line 500
  buffer_consume(& incoming_packet, 8U - len % 8U);
#line 504
  tmp___6 = buffer_len(& incoming_packet);
#line 504
  if (len != tmp___6) {
#line 505
    tmp___5 = buffer_len(& incoming_packet);
#line 505
    packet_disconnect("packet_read_poll: len %d != buffer_len %d.", len, tmp___5);
  }
#line 508
  tmp___7 = buffer_ptr(& incoming_packet);
#line 508
  ucp = ((unsigned char *)tmp___7 + len) - 4;
#line 509
  stored_checksum = (unsigned int )(((((unsigned long )*(ucp + 0) << 24) | ((unsigned long )*(ucp + 1) << 16)) | ((unsigned long )*(ucp + 2) << 8)) | (unsigned long )*(ucp + 3));
#line 510
  if (checksum != stored_checksum) {
#line 511
    packet_disconnect("Corrupted check bytes on input.");
  }
#line 512
  buffer_consume_end(& incoming_packet, 4U);
#line 515
  if (packet_compression) {
#line 517
    buffer_clear(& compression_buffer);
#line 518
    buffer_uncompress(& incoming_packet, & compression_buffer);
#line 519
    buffer_clear(& incoming_packet);
#line 520
    tmp___8 = buffer_len(& compression_buffer);
#line 520
    tmp___9 = buffer_ptr(& compression_buffer);
#line 520
    buffer_append(& incoming_packet, (char const   *)tmp___9, tmp___8);
  }
#line 525
  buffer_get(& incoming_packet, buf, 1U);
#line 528
  tmp___10 = buffer_len(& incoming_packet);
#line 528
  *payload_len_ptr = (int )tmp___10;
#line 531
  if ((int )((unsigned char )buf[0]) == 1) {
#line 532
    tmp___11 = packet_get_string((unsigned int *)((void *)0));
#line 532
    fatal("%.900s", tmp___11);
  }
#line 535
  if ((int )((unsigned char )buf[0]) == 32) {
    goto restart;
  }
#line 539
  if ((int )((unsigned char )buf[0]) == 36) {
#line 541
    tmp___12 = packet_get_string((unsigned int *)((void *)0));
#line 541
    debug("Remote: %.900s", tmp___12);
    goto restart;
  }
#line 546
  return ((int )((unsigned char )buf[0]));
}
}
#line 552 "packet.c"
void packet_process_incoming(char const   *buf , unsigned int len ) 
{ 

  {
#line 555
  buffer_append(& input, buf, len);
#line 556
  return;
}
}
#line 560 "packet.c"
unsigned int packet_get_char(void) 
{ char ch ;

  {
#line 564
  buffer_get(& incoming_packet, & ch, 1U);
#line 565
  return ((unsigned int )((unsigned char )ch));
}
}
#line 570 "packet.c"
unsigned int packet_get_int(void) 
{ unsigned int tmp ;

  {
#line 573
  tmp = buffer_get_int(& incoming_packet);
#line 573
  return (tmp);
}
}
#line 579 "packet.c"
void packet_get_bignum(BIGNUM *value , int *length_ptr ) 
{ 

  {
#line 582
  *length_ptr = buffer_get_bignum(& incoming_packet, value);
#line 583
  return;
}
}
#line 590 "packet.c"
char *packet_get_string(unsigned int *length_ptr ) 
{ char *tmp ;

  {
#line 593
  tmp = buffer_get_string(& incoming_packet, length_ptr);
#line 593
  return (tmp);
}
}
#line 604 "packet.c"
void packet_send_debug(char const   *fmt  , ...) 
{ char buf[1024] ;
  va_list args ;
  size_t tmp ;

  {
#line 610
  __builtin_va_start(args, fmt);
#line 611
  vsnprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )fmt,
            args);
#line 612
  __builtin_va_end(args);
#line 614
  packet_start(36);
#line 615
  tmp = strlen((char const   *)(buf));
#line 615
  packet_put_string((char const   *)(buf), tmp);
#line 616
  packet_send();
#line 617
  packet_write_wait();
#line 618
  return;
}
}
#line 630 "packet.c"
static int disconnecting  =    0;
#line 625 "packet.c"
void packet_disconnect(char const   *fmt  , ...) 
{ char buf[1024] ;
  va_list args ;
  size_t tmp ;

  {
#line 631
  if (disconnecting) {
#line 632
    fatal("packet_disconnect called recursively.");
  }
#line 633
  disconnecting = 1;
#line 637
  __builtin_va_start(args, fmt);
#line 638
  vsnprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )fmt,
            args);
#line 639
  __builtin_va_end(args);
#line 643
  packet_start(1);
#line 644
  tmp = strlen((char const   *)(buf));
#line 644
  packet_put_string((char const   *)(buf), tmp);
#line 645
  packet_send();
#line 646
  packet_write_wait();
#line 649
  channel_stop_listening();
#line 652
  packet_close();
#line 655
  fatal("Local: %.100s", buf);
#line 656
  return;
}
}
#line 661 "packet.c"
void packet_write_poll(void) 
{ int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
#line 664
  tmp = buffer_len(& output);
#line 664
  len = (int )tmp;
#line 665
  if (len > 0) {
#line 667
    tmp___0 = buffer_ptr(& output);
#line 667
    len = write(connection_out, (void const   *)tmp___0, (unsigned int )len);
#line 668
    if (len <= 0) {
#line 669
      tmp___3 = __errno_location();
#line 669
      if (*tmp___3 == 11) {
#line 670
        return;
      } else {
#line 672
        tmp___1 = __errno_location();
#line 672
        tmp___2 = strerror(*tmp___1);
#line 672
        fatal("Write failed: %.100s", tmp___2);
      }
    }
#line 674
    buffer_consume(& output, (unsigned int )len);
  }
#line 676
  return;
}
}
#line 681 "packet.c"
void packet_write_wait(void) 
{ fd_set set ;
  int __d0 ;
  int __d1 ;
  int tmp ;

  {
#line 684
  packet_write_poll();
#line 685
  while (1) {
#line 685
    tmp = packet_have_data_to_write();
#line 685
    if (! tmp) {
#line 685
      break;
    }
#line 688
    while (1) {
#line 688
      __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& set.__fds_bits[0]): "memory");
#line 688
      break;
    }
#line 689
    __asm__  volatile   ("btsl %1,%0": "=m" (set.__fds_bits[(unsigned int )connection_out / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 690
    select(connection_out + 1, (fd_set * __restrict  )((void *)0), (fd_set * __restrict  )(& set),
           (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 691
    packet_write_poll();
  }
#line 693
  return;
}
}
#line 697 "packet.c"
int packet_have_data_to_write(void) 
{ unsigned int tmp ;

  {
#line 700
  tmp = buffer_len(& output);
#line 700
  return (tmp != 0U);
}
}
#line 705 "packet.c"
int packet_not_very_much_data_to_write(void) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 708
  if (interactive_mode) {
#line 709
    tmp = buffer_len(& output);
#line 709
    return (tmp < 16384U);
  } else {
#line 711
    tmp___0 = buffer_len(& output);
#line 711
    return (tmp___0 < 131072U);
  }
}
}
#line 716 "packet.c"
void packet_set_interactive(int interactive , int keepalives ) 
{ int on ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int lowdelay ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int throughput ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
#line 719
  on = 1;
#line 722
  interactive_mode = interactive;
#line 726
  if (connection_in != connection_out) {
#line 727
    return;
  }
#line 729
  if (keepalives) {
#line 732
    tmp___1 = setsockopt(connection_in, 1, 9, (void const   *)((void *)(& on)), sizeof(on));
#line 732
    if (tmp___1 < 0) {
#line 734
      tmp = __errno_location();
#line 734
      tmp___0 = strerror(*tmp);
#line 734
      error("setsockopt SO_KEEPALIVE: %.100s", tmp___0);
    }
  }
#line 737
  if (interactive) {
#line 741
    lowdelay = 16;
#line 742
    tmp___4 = setsockopt(connection_in, 0, 1, (void const   *)((void *)(& lowdelay)),
                         sizeof(lowdelay));
#line 742
    if (tmp___4 < 0) {
#line 744
      tmp___2 = __errno_location();
#line 744
      tmp___3 = strerror(*tmp___2);
#line 744
      error("setsockopt IPTOS_LOWDELAY: %.100s", tmp___3);
    }
#line 745
    tmp___7 = setsockopt(connection_in, 6, 1, (void const   *)((void *)(& on)), sizeof(on));
#line 745
    if (tmp___7 < 0) {
#line 747
      tmp___5 = __errno_location();
#line 747
      tmp___6 = strerror(*tmp___5);
#line 747
      error("setsockopt TCP_NODELAY: %.100s", tmp___6);
    }
  } else {
#line 753
    throughput = 8;
#line 754
    tmp___10 = setsockopt(connection_in, 0, 1, (void const   *)((void *)(& throughput)),
                          sizeof(throughput));
#line 754
    if (tmp___10 < 0) {
#line 756
      tmp___8 = __errno_location();
#line 756
      tmp___9 = strerror(*tmp___8);
#line 756
      error("setsockopt IPTOS_THROUGHPUT: %.100s", tmp___9);
    }
  }
#line 758
  return;
}
}
#line 762 "packet.c"
int packet_is_interactive(void) 
{ 

  {
#line 765
  return (interactive_mode);
}
}
#line 1 "readpass.o"
#pragma merger(0,"./readpass.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 92 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 117
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 142 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 143
extern struct _IO_FILE *stdout ;
#line 218
extern int fflush(FILE *__stream ) ;
#line 759
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 67 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 71
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
#line 646 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 358 "ssh.h"
char *read_passphrase(char const   *prompt , int from_stdin ) ;
#line 23 "readpass.c"
static struct termios saved_tio  ;
#line 26 "readpass.c"
static void (*old_handler)(int sig )  =    (void (*)(int sig ))((void *)0);
#line 30 "readpass.c"
void intr_handler(int sig ) 
{ int tmp ;
  __pid_t tmp___0 ;

  {
#line 33
  tmp = fileno(stdin);
#line 33
  tcsetattr(tmp, 0, (struct termios  const  *)(& saved_tio));
#line 35
  signal(sig, old_handler);
#line 37
  tmp___0 = getpid();
#line 37
  kill(tmp___0, sig);
#line 38
  return;
}
}
#line 45 "readpass.c"
char *read_passphrase(char const   *prompt , int from_stdin ) 
{ char buf[1024] ;
  char *cp ;
  struct termios tio ;
  FILE *f ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___5 ;
  char *tmp___7 ;

  {
#line 51
  if (from_stdin) {
#line 52
    f = stdin;
  } else {
#line 57
    f = fopen((char const   * __restrict  )"/dev/tty", (char const   * __restrict  )"r");
#line 58
    if (! f) {
#line 61
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"You have no controlling tty and no DISPLAY.  Cannot read passphrase.\n");
#line 62
      exit(1);
    }
  }
#line 67
  fflush(stdout);
#line 68
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", prompt);
#line 69
  fflush(stderr);
#line 72
  tmp = fileno(f);
#line 72
  tcgetattr(tmp, & tio);
#line 73
  saved_tio = tio;
#line 75
  old_handler = signal(2, & intr_handler);
#line 78
  tio.c_lflag &= 4294967175U;
#line 79
  tmp___0 = fileno(f);
#line 79
  tcsetattr(tmp___0, 0, (struct termios  const  *)(& tio));
#line 82
  tmp___2 = fgets((char * __restrict  )(buf), (int )sizeof(buf), (FILE * __restrict  )f);
#line 82
  if ((unsigned int )tmp___2 == (unsigned int )((void *)0)) {
#line 86
    tmp___1 = fileno(f);
#line 86
    tcsetattr(tmp___1, 0, (struct termios  const  *)(& saved_tio));
#line 88
    signal(2, old_handler);
#line 90
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 92
    if ((unsigned int )f != (unsigned int )stdin) {
#line 93
      fclose(f);
    }
#line 94
    exit(1);
  }
#line 97
  tmp___3 = fileno(f);
#line 97
  tcsetattr(tmp___3, 0, (struct termios  const  *)(& saved_tio));
#line 99
  signal(2, old_handler);
#line 101
  tmp___7 = __builtin_strchr(buf, '\n');
#line 101
  if (tmp___7) {
#line 102
    tmp___5 = __builtin_strchr(buf, '\n');
#line 102
    *tmp___5 = (char)0;
  }
#line 104
  cp = xstrdup((char const   *)(buf));
#line 107
  memset((void *)(buf), 0, sizeof(buf));
#line 109
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 111
  if ((unsigned int )f != (unsigned int )stdin) {
#line 112
    fclose(f);
  }
#line 113
  return (cp);
}
}
#line 1 "rsa.o"
#pragma merger(0,"./rsa.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 333 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 410 "/usr/include/openssl/bn.h"
extern BIGNUM *BN_copy(BIGNUM *a , BIGNUM const   *b ) ;
#line 221 "/usr/include/openssl/rsa.h"
extern RSA *RSA_generate_key(int bits , unsigned long e , void (*callback)(int  ,
                                                                           int  ,
                                                                           void * ) ,
                             void *cb_arg ) ;
#line 230
extern int RSA_public_encrypt(int flen , unsigned char const   *from , unsigned char *to ,
                              RSA *rsa , int padding ) ;
#line 236
extern int RSA_private_decrypt(int flen , unsigned char const   *from , unsigned char *to ,
                               RSA *rsa , int padding ) ;
#line 238
extern void RSA_free(RSA *r ) ;
#line 33 "rsa.h"
void rsa_generate_key(RSA *prv , RSA *pub , unsigned int bits ) ;
#line 37
void rsa_set_verbose(int verbose ) ;
#line 39
int rsa_alive(void) ;
#line 41
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 42
void rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 44 "rsa.c"
int rsa_verbose  =    1;
#line 46 "rsa.c"
int rsa_alive(void) 
{ RSA *key ;

  {
#line 51
  key = RSA_generate_key(32, 3UL, (void (*)(int  , int  , void * ))((void *)0), (void *)0);
#line 52
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 53
    return (0);
  }
#line 54
  RSA_free(key);
#line 55
  return (1);
}
}
#line 62 "rsa.c"
void rsa_generate_key(RSA *prv , RSA *pub , unsigned int bits ) 
{ RSA *key ;

  {
#line 67
  if (rsa_verbose) {
#line 68
    printf((char const   * __restrict  )"Generating RSA keys:  ");
#line 69
    fflush(stdout);
  }
#line 72
  key = RSA_generate_key((int )bits, 35UL, (void (*)(int  , int  , void * ))((void *)0),
                         (void *)0);
#line 73
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 74
    fatal("rsa_generate_key: key generation failed.");
  }
#line 77
  pub->n = BN_new();
#line 78
  BN_copy(pub->n, (BIGNUM const   *)key->n);
#line 79
  pub->e = BN_new();
#line 80
  BN_copy(pub->e, (BIGNUM const   *)key->e);
#line 83
  prv->n = BN_new();
#line 84
  BN_copy(prv->n, (BIGNUM const   *)key->n);
#line 85
  prv->e = BN_new();
#line 86
  BN_copy(prv->e, (BIGNUM const   *)key->e);
#line 87
  prv->d = BN_new();
#line 88
  BN_copy(prv->d, (BIGNUM const   *)key->d);
#line 89
  prv->p = BN_new();
#line 90
  BN_copy(prv->p, (BIGNUM const   *)key->p);
#line 91
  prv->q = BN_new();
#line 92
  BN_copy(prv->q, (BIGNUM const   *)key->q);
#line 94
  prv->dmp1 = BN_new();
#line 95
  BN_copy(prv->dmp1, (BIGNUM const   *)key->dmp1);
#line 97
  prv->dmq1 = BN_new();
#line 98
  BN_copy(prv->dmq1, (BIGNUM const   *)key->dmq1);
#line 100
  prv->iqmp = BN_new();
#line 101
  BN_copy(prv->iqmp, (BIGNUM const   *)key->iqmp);
#line 103
  RSA_free(key);
#line 105
  if (rsa_verbose) {
#line 106
    printf((char const   * __restrict  )"Key generation complete.\n");
  }
#line 107
  return;
}
}
#line 109 "rsa.c"
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ char *inbuf ;
  char *outbuf ;
  int len ;
  int ilen ;
  int olen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 115
  tmp = BN_num_bits((BIGNUM const   *)key->e);
#line 115
  if (tmp < 2) {
#line 116
    fatal("rsa_public_encrypt() exponent too small or not odd");
  } else {
#line 115
    if ((key->e)->top > 0) {
#line 115
      if (! (*((key->e)->d + 0) & 1UL)) {
#line 116
        fatal("rsa_public_encrypt() exponent too small or not odd");
      }
    } else {
#line 116
      fatal("rsa_public_encrypt() exponent too small or not odd");
    }
  }
#line 118
  tmp___0 = BN_num_bits((BIGNUM const   *)key->n);
#line 118
  olen = (tmp___0 + 7) / 8;
#line 119
  tmp___1 = xmalloc((unsigned int )olen);
#line 119
  outbuf = (char *)tmp___1;
#line 121
  tmp___2 = BN_num_bits((BIGNUM const   *)in);
#line 121
  ilen = (tmp___2 + 7) / 8;
#line 122
  tmp___3 = xmalloc((unsigned int )ilen);
#line 122
  inbuf = (char *)tmp___3;
#line 123
  BN_bn2bin((BIGNUM const   *)in, (unsigned char *)inbuf);
#line 125
  len = RSA_public_encrypt(ilen, (unsigned char const   *)inbuf, (unsigned char *)outbuf,
                           key, 1);
#line 125
  if (len <= 0) {
#line 127
    fatal("rsa_public_encrypt() failed");
  }
#line 129
  BN_bin2bn((unsigned char const   *)outbuf, len, out);
#line 131
  memset((void *)outbuf, 0, (unsigned int )olen);
#line 132
  memset((void *)inbuf, 0, (unsigned int )ilen);
#line 133
  xfree((void *)outbuf);
#line 134
  xfree((void *)inbuf);
#line 135
  return;
}
}
#line 137 "rsa.c"
void rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ char *inbuf ;
  char *outbuf ;
  int len ;
  int ilen ;
  int olen ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 143
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 143
  olen = (tmp + 7) / 8;
#line 144
  tmp___0 = xmalloc((unsigned int )olen);
#line 144
  outbuf = (char *)tmp___0;
#line 146
  tmp___1 = BN_num_bits((BIGNUM const   *)in);
#line 146
  ilen = (tmp___1 + 7) / 8;
#line 147
  tmp___2 = xmalloc((unsigned int )ilen);
#line 147
  inbuf = (char *)tmp___2;
#line 148
  BN_bn2bin((BIGNUM const   *)in, (unsigned char *)inbuf);
#line 150
  len = RSA_private_decrypt(ilen, (unsigned char const   *)inbuf, (unsigned char *)outbuf,
                            key, 2);
#line 150
  if (len <= 0) {
#line 152
    fatal("rsa_private_decrypt() failed");
  }
#line 154
  BN_bin2bn((unsigned char const   *)outbuf, len, out);
#line 156
  memset((void *)outbuf, 0, (unsigned int )olen);
#line 157
  memset((void *)inbuf, 0, (unsigned int )ilen);
#line 158
  xfree((void *)outbuf);
#line 159
  xfree((void *)inbuf);
#line 160
  return;
}
}
#line 164 "rsa.c"
void rsa_set_verbose(int verbose ) 
{ 

  {
#line 167
  rsa_verbose = verbose;
#line 168
  return;
}
}
#line 1 "tildexpand.o"
#pragma merger(0,"./tildexpand.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 111 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 117
extern struct passwd *getpwnam(char const   *__name ) ;
#line 572 "ssh.h"
char *tilde_expand_filename(char const   *filename , uid_t my_uid ) ;
#line 23 "tildexpand.c"
char *tilde_expand_filename(char const   *filename , uid_t my_uid ) 
{ char const   *cp ;
  unsigned int userlen ;
  char *expanded ;
  struct passwd *pw ;
  char user[100] ;
  char *tmp ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;

  {
#line 32
  if ((int const   )*(filename + 0) != 126) {
#line 33
    tmp = xstrdup(filename);
#line 33
    return (tmp);
  }
#line 36
  filename ++;
#line 39
  tmp___1 = __builtin_strchr((char *)filename, '/');
#line 39
  cp = (char const   *)tmp___1;
#line 40
  if (cp) {
#line 41
    userlen = (unsigned int )(cp - filename);
  } else {
#line 43
    userlen = strlen(filename);
  }
#line 44
  if (userlen == 0U) {
#line 45
    pw = getpwuid(my_uid);
  } else {
#line 49
    if (userlen > sizeof(user) - 1U) {
#line 50
      fatal("User name after tilde too long.");
    }
#line 51
    memcpy((void * __restrict  )(user), (void const   * __restrict  )filename, userlen);
#line 52
    user[userlen] = (char)0;
#line 53
    pw = getpwnam((char const   *)(user));
  }
#line 57
  if (! pw) {
#line 58
    fatal("Unknown user %100s.", user);
  }
#line 61
  if (! cp) {
#line 63
    tmp___2 = xstrdup((char const   *)pw->pw_dir);
#line 63
    return (tmp___2);
  }
#line 67
  tmp___3 = strlen((char const   *)pw->pw_dir);
#line 67
  tmp___4 = strlen(cp + 1);
#line 67
  tmp___5 = xmalloc((tmp___3 + tmp___4) + 2U);
#line 67
  expanded = (char *)tmp___5;
#line 68
  sprintf((char * __restrict  )expanded, (char const   * __restrict  )"%s/%s", pw->pw_dir,
          cp + 1);
#line 69
  return (expanded);
}
}
#line 1 "ttymodes.o"
#pragma merger(0,"./ttymodes.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 49 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) speed_t cfgetospeed(struct termios  const  *__termios_p ) ;
#line 52
extern  __attribute__((__nothrow__)) speed_t cfgetispeed(struct termios  const  *__termios_p ) ;
#line 55
extern  __attribute__((__nothrow__)) int cfsetospeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 58
extern  __attribute__((__nothrow__)) int cfsetispeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 157 "packet.h"
void tty_make_modes(int fd ) ;
#line 160
void tty_parse_modes(int fd , int *n_bytes_ptr ) ;
#line 32 "ttymodes.c"
static int speed_to_baud(speed_t speed ) 
{ 

  {
#line 34
  switch ((int )speed) {
  case 0: 
#line 37
  return (0);
  case 1: 
#line 39
  return (50);
  case 2: 
#line 41
  return (75);
  case 3: 
#line 43
  return (110);
  case 4: 
#line 45
  return (134);
  case 5: 
#line 47
  return (150);
  case 6: 
#line 49
  return (200);
  case 7: 
#line 51
  return (300);
  case 8: 
#line 53
  return (600);
  case 9: 
#line 55
  return (1200);
  case 10: 
#line 57
  return (1800);
  case 11: 
#line 59
  return (2400);
  case 12: 
#line 61
  return (4800);
  case 13: 
#line 63
  return (9600);
  case 14: 
#line 67
  return (19200);
  case 15: 
#line 77
  return (38400);
  case 4097: 
#line 99
  return (57600);
  case 4098: 
#line 107
  return (115200);
  case 4099: 
#line 111
  return (230400);
  default: ;
#line 114
  return (9600);
  }
}
}
#line 120 "ttymodes.c"
static speed_t baud_to_speed(int baud ) 
{ 

  {
#line 122
  switch (baud) {
  case 0: 
#line 125
  return (0U);
  case 50: 
#line 127
  return (1U);
  case 75: 
#line 129
  return (2U);
  case 110: 
#line 131
  return (3U);
  case 134: 
#line 133
  return (4U);
  case 150: 
#line 135
  return (5U);
  case 200: 
#line 137
  return (6U);
  case 300: 
#line 139
  return (7U);
  case 600: 
#line 141
  return (8U);
  case 1200: 
#line 143
  return (9U);
  case 1800: 
#line 145
  return (10U);
  case 2400: 
#line 147
  return (11U);
  case 4800: 
#line 149
  return (12U);
  case 9600: 
#line 151
  return (13U);
  case 19200: 
#line 155
  return (14U);
  case 38400: 
#line 165
  return (15U);
  case 57600: 
#line 187
  return (4097U);
  case 115200: 
#line 195
  return (4098U);
  case 230400: 
#line 199
  return (4099U);
  default: ;
#line 202
  return (13U);
  }
}
}
#line 209 "ttymodes.c"
void tty_make_modes(int fd ) 
{ struct termios tio ;
  int baud ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  speed_t tmp___2 ;
  speed_t tmp___3 ;

  {
#line 215
  tmp___1 = tcgetattr(fd, & tio);
#line 215
  if (tmp___1 < 0) {
#line 217
    packet_put_char(0);
#line 218
    tmp = __errno_location();
#line 218
    tmp___0 = strerror(*tmp);
#line 218
    log("tcgetattr: %.100s", tmp___0);
#line 219
    return;
  }
#line 223
  tmp___2 = cfgetospeed((struct termios  const  *)(& tio));
#line 223
  baud = speed_to_baud(tmp___2);
#line 224
  packet_put_char(193);
#line 225
  packet_put_int((unsigned int )baud);
#line 226
  tmp___3 = cfgetispeed((struct termios  const  *)(& tio));
#line 226
  baud = speed_to_baud(tmp___3);
#line 227
  packet_put_char(192);
#line 228
  packet_put_int((unsigned int )baud);
#line 34 "ttymodes.h"
  packet_put_char(1);
#line 34
  packet_put_char((int )tio.c_cc[0]);
#line 35
  packet_put_char(2);
#line 35
  packet_put_char((int )tio.c_cc[1]);
#line 36
  packet_put_char(3);
#line 36
  packet_put_char((int )tio.c_cc[2]);
#line 38
  packet_put_char(4);
#line 38
  packet_put_char((int )tio.c_cc[3]);
#line 40
  packet_put_char(5);
#line 40
  packet_put_char((int )tio.c_cc[4]);
#line 42
  packet_put_char(6);
#line 42
  packet_put_char((int )tio.c_cc[11]);
#line 45
  packet_put_char(7);
#line 45
  packet_put_char((int )tio.c_cc[16]);
#line 47
  packet_put_char(8);
#line 47
  packet_put_char((int )tio.c_cc[8]);
#line 48
  packet_put_char(9);
#line 48
  packet_put_char((int )tio.c_cc[9]);
#line 50
  packet_put_char(10);
#line 50
  packet_put_char((int )tio.c_cc[10]);
#line 56
  packet_put_char(12);
#line 56
  packet_put_char((int )tio.c_cc[12]);
#line 59
  packet_put_char(13);
#line 59
  packet_put_char((int )tio.c_cc[14]);
#line 62
  packet_put_char(14);
#line 62
  packet_put_char((int )tio.c_cc[15]);
#line 74
  packet_put_char(18);
#line 74
  packet_put_char((int )tio.c_cc[13]);
#line 78
  packet_put_char(30);
#line 78
  packet_put_char((tio.c_iflag & 4U) != 0U);
#line 79
  packet_put_char(31);
#line 79
  packet_put_char((tio.c_iflag & 8U) != 0U);
#line 80
  packet_put_char(32);
#line 80
  packet_put_char((tio.c_iflag & 16U) != 0U);
#line 81
  packet_put_char(33);
#line 81
  packet_put_char((tio.c_iflag & 32U) != 0U);
#line 82
  packet_put_char(34);
#line 82
  packet_put_char((tio.c_iflag & 64U) != 0U);
#line 83
  packet_put_char(35);
#line 83
  packet_put_char((tio.c_iflag & 128U) != 0U);
#line 84
  packet_put_char(36);
#line 84
  packet_put_char((tio.c_iflag & 256U) != 0U);
#line 86
  packet_put_char(37);
#line 86
  packet_put_char((tio.c_iflag & 512U) != 0U);
#line 88
  packet_put_char(38);
#line 88
  packet_put_char((tio.c_iflag & 1024U) != 0U);
#line 89
  packet_put_char(39);
#line 89
  packet_put_char((tio.c_iflag & 2048U) != 0U);
#line 90
  packet_put_char(40);
#line 90
  packet_put_char((tio.c_iflag & 4096U) != 0U);
#line 92
  packet_put_char(41);
#line 92
  packet_put_char((tio.c_iflag & 8192U) != 0U);
#line 95
  packet_put_char(50);
#line 95
  packet_put_char((tio.c_lflag & 1U) != 0U);
#line 96
  packet_put_char(51);
#line 96
  packet_put_char((tio.c_lflag & 2U) != 0U);
#line 98
  packet_put_char(52);
#line 98
  packet_put_char((tio.c_lflag & 4U) != 0U);
#line 100
  packet_put_char(53);
#line 100
  packet_put_char((tio.c_lflag & 8U) != 0U);
#line 101
  packet_put_char(54);
#line 101
  packet_put_char((tio.c_lflag & 16U) != 0U);
#line 102
  packet_put_char(55);
#line 102
  packet_put_char((tio.c_lflag & 32U) != 0U);
#line 103
  packet_put_char(56);
#line 103
  packet_put_char((tio.c_lflag & 64U) != 0U);
#line 104
  packet_put_char(57);
#line 104
  packet_put_char((tio.c_lflag & 128U) != 0U);
#line 105
  packet_put_char(58);
#line 105
  packet_put_char((tio.c_lflag & 256U) != 0U);
#line 107
  packet_put_char(59);
#line 107
  packet_put_char((tio.c_lflag & 32768U) != 0U);
#line 110
  packet_put_char(60);
#line 110
  packet_put_char((tio.c_lflag & 512U) != 0U);
#line 113
  packet_put_char(61);
#line 113
  packet_put_char((tio.c_lflag & 2048U) != 0U);
#line 116
  packet_put_char(62);
#line 116
  packet_put_char((tio.c_lflag & 16384U) != 0U);
#line 119
  packet_put_char(70);
#line 119
  packet_put_char((tio.c_oflag & 1U) != 0U);
#line 121
  packet_put_char(71);
#line 121
  packet_put_char((tio.c_oflag & 2U) != 0U);
#line 123
  packet_put_char(72);
#line 123
  packet_put_char((tio.c_oflag & 4U) != 0U);
#line 125
  packet_put_char(73);
#line 125
  packet_put_char((tio.c_oflag & 8U) != 0U);
#line 128
  packet_put_char(74);
#line 128
  packet_put_char((tio.c_oflag & 16U) != 0U);
#line 131
  packet_put_char(75);
#line 131
  packet_put_char((tio.c_oflag & 32U) != 0U);
#line 134
  packet_put_char(90);
#line 134
  packet_put_char((tio.c_cflag & 32U) != 0U);
#line 135
  packet_put_char(91);
#line 135
  packet_put_char((tio.c_cflag & 48U) != 0U);
#line 136
  packet_put_char(92);
#line 136
  packet_put_char((tio.c_cflag & 256U) != 0U);
#line 137
  packet_put_char(93);
#line 137
  packet_put_char((tio.c_cflag & 512U) != 0U);
#line 248 "ttymodes.c"
  packet_put_char(0);
#line 249
  return;
}
}
#line 254 "ttymodes.c"
void tty_parse_modes(int fd , int *n_bytes_ptr ) 
{ struct termios tio ;
  int opcode ;
  int baud ;
  int n_bytes ;
  int failure ;
  int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  speed_t tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  speed_t tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;
  unsigned int tmp___22 ;
  unsigned int tmp___23 ;
  unsigned int tmp___24 ;
  unsigned int tmp___25 ;
  unsigned int tmp___26 ;
  unsigned int tmp___27 ;
  unsigned int tmp___28 ;
  unsigned int tmp___29 ;
  unsigned int tmp___30 ;
  unsigned int tmp___31 ;
  unsigned int tmp___32 ;
  unsigned int tmp___33 ;
  unsigned int tmp___34 ;
  unsigned int tmp___35 ;
  unsigned int tmp___36 ;
  unsigned int tmp___37 ;
  unsigned int tmp___38 ;
  unsigned int tmp___39 ;
  unsigned int tmp___40 ;
  unsigned int tmp___41 ;
  unsigned int tmp___42 ;
  unsigned int tmp___43 ;
  unsigned int tmp___44 ;
  unsigned int tmp___45 ;
  unsigned int tmp___46 ;
  unsigned int tmp___47 ;
  unsigned int tmp___48 ;
  unsigned int tmp___49 ;
  unsigned int tmp___50 ;
  unsigned int tmp___51 ;
  unsigned int tmp___52 ;
  unsigned int tmp___53 ;
  unsigned int tmp___54 ;
  unsigned int tmp___55 ;
  int _p ;
  int _e ;
  int *tmp___56 ;
  char *tmp___57 ;
  int tmp___58 ;

  {
#line 258
  n_bytes = 0;
#line 259
  failure = 0;
#line 264
  tmp = tcgetattr(fd, & tio);
#line 264
  if (tmp < 0) {
#line 265
    failure = -1;
  }
#line 267
  while (1) {
#line 269
    n_bytes ++;
#line 270
    tmp___0 = packet_get_char();
#line 270
    opcode = (int )tmp___0;
#line 271
    switch (opcode) {
    case 0: 
    goto set;
    case 192: 
#line 277
    n_bytes += 4;
#line 278
    tmp___1 = packet_get_int();
#line 278
    baud = (int )tmp___1;
#line 279
    if (failure != -1) {
#line 279
      tmp___2 = baud_to_speed(baud);
#line 279
      tmp___3 = cfsetispeed(& tio, tmp___2);
#line 279
      if (tmp___3 < 0) {
#line 280
        error("cfsetispeed failed for %d", baud);
      }
    }
#line 281
    break;
    case 193: 
#line 284
    n_bytes += 4;
#line 285
    tmp___4 = packet_get_int();
#line 285
    baud = (int )tmp___4;
#line 286
    if (failure != -1) {
#line 286
      tmp___5 = baud_to_speed(baud);
#line 286
      tmp___6 = cfsetospeed(& tio, tmp___5);
#line 286
      if (tmp___6 < 0) {
#line 287
        error("cfsetospeed failed for %d", baud);
      }
    }
#line 288
    break;
    case 1: 
#line 34 "ttymodes.h"
    n_bytes ++;
#line 34
    tmp___7 = packet_get_char();
#line 34
    tio.c_cc[0] = (unsigned char )tmp___7;
#line 34
    break;
    case 2: 
#line 35
    n_bytes ++;
#line 35
    tmp___8 = packet_get_char();
#line 35
    tio.c_cc[1] = (unsigned char )tmp___8;
#line 35
    break;
    case 3: 
#line 36
    n_bytes ++;
#line 36
    tmp___9 = packet_get_char();
#line 36
    tio.c_cc[2] = (unsigned char )tmp___9;
#line 36
    break;
    case 4: 
#line 38
    n_bytes ++;
#line 38
    tmp___10 = packet_get_char();
#line 38
    tio.c_cc[3] = (unsigned char )tmp___10;
#line 38
    break;
    case 5: 
#line 40
    n_bytes ++;
#line 40
    tmp___11 = packet_get_char();
#line 40
    tio.c_cc[4] = (unsigned char )tmp___11;
#line 40
    break;
    case 6: 
#line 42
    n_bytes ++;
#line 42
    tmp___12 = packet_get_char();
#line 42
    tio.c_cc[11] = (unsigned char )tmp___12;
#line 42
    break;
    case 7: 
#line 45
    n_bytes ++;
#line 45
    tmp___13 = packet_get_char();
#line 45
    tio.c_cc[16] = (unsigned char )tmp___13;
#line 45
    break;
    case 8: 
#line 47
    n_bytes ++;
#line 47
    tmp___14 = packet_get_char();
#line 47
    tio.c_cc[8] = (unsigned char )tmp___14;
#line 47
    break;
    case 9: 
#line 48
    n_bytes ++;
#line 48
    tmp___15 = packet_get_char();
#line 48
    tio.c_cc[9] = (unsigned char )tmp___15;
#line 48
    break;
    case 10: 
#line 50
    n_bytes ++;
#line 50
    tmp___16 = packet_get_char();
#line 50
    tio.c_cc[10] = (unsigned char )tmp___16;
#line 50
    break;
    case 12: 
#line 56
    n_bytes ++;
#line 56
    tmp___17 = packet_get_char();
#line 56
    tio.c_cc[12] = (unsigned char )tmp___17;
#line 56
    break;
    case 13: 
#line 59
    n_bytes ++;
#line 59
    tmp___18 = packet_get_char();
#line 59
    tio.c_cc[14] = (unsigned char )tmp___18;
#line 59
    break;
    case 14: 
#line 62
    n_bytes ++;
#line 62
    tmp___19 = packet_get_char();
#line 62
    tio.c_cc[15] = (unsigned char )tmp___19;
#line 62
    break;
    case 18: 
#line 74
    n_bytes ++;
#line 74
    tmp___20 = packet_get_char();
#line 74
    tio.c_cc[13] = (unsigned char )tmp___20;
#line 74
    break;
    case 30: 
#line 78
    n_bytes ++;
#line 78
    tmp___21 = packet_get_char();
#line 78
    if (tmp___21) {
#line 78
      tio.c_iflag |= 4U;
    } else {
#line 78
      tio.c_iflag &= 4294967291U;
    }
#line 78
    break;
    case 31: 
#line 79
    n_bytes ++;
#line 79
    tmp___22 = packet_get_char();
#line 79
    if (tmp___22) {
#line 79
      tio.c_iflag |= 8U;
    } else {
#line 79
      tio.c_iflag &= 4294967287U;
    }
#line 79
    break;
    case 32: 
#line 80
    n_bytes ++;
#line 80
    tmp___23 = packet_get_char();
#line 80
    if (tmp___23) {
#line 80
      tio.c_iflag |= 16U;
    } else {
#line 80
      tio.c_iflag &= 4294967279U;
    }
#line 80
    break;
    case 33: 
#line 81
    n_bytes ++;
#line 81
    tmp___24 = packet_get_char();
#line 81
    if (tmp___24) {
#line 81
      tio.c_iflag |= 32U;
    } else {
#line 81
      tio.c_iflag &= 4294967263U;
    }
#line 81
    break;
    case 34: 
#line 82
    n_bytes ++;
#line 82
    tmp___25 = packet_get_char();
#line 82
    if (tmp___25) {
#line 82
      tio.c_iflag |= 64U;
    } else {
#line 82
      tio.c_iflag &= 4294967231U;
    }
#line 82
    break;
    case 35: 
#line 83
    n_bytes ++;
#line 83
    tmp___26 = packet_get_char();
#line 83
    if (tmp___26) {
#line 83
      tio.c_iflag |= 128U;
    } else {
#line 83
      tio.c_iflag &= 4294967167U;
    }
#line 83
    break;
    case 36: 
#line 84
    n_bytes ++;
#line 84
    tmp___27 = packet_get_char();
#line 84
    if (tmp___27) {
#line 84
      tio.c_iflag |= 256U;
    } else {
#line 84
      tio.c_iflag &= 4294967039U;
    }
#line 84
    break;
    case 37: 
#line 86
    n_bytes ++;
#line 86
    tmp___28 = packet_get_char();
#line 86
    if (tmp___28) {
#line 86
      tio.c_iflag |= 512U;
    } else {
#line 86
      tio.c_iflag &= 4294966783U;
    }
#line 86
    break;
    case 38: 
#line 88
    n_bytes ++;
#line 88
    tmp___29 = packet_get_char();
#line 88
    if (tmp___29) {
#line 88
      tio.c_iflag |= 1024U;
    } else {
#line 88
      tio.c_iflag &= 4294966271U;
    }
#line 88
    break;
    case 39: 
#line 89
    n_bytes ++;
#line 89
    tmp___30 = packet_get_char();
#line 89
    if (tmp___30) {
#line 89
      tio.c_iflag |= 2048U;
    } else {
#line 89
      tio.c_iflag &= 4294965247U;
    }
#line 89
    break;
    case 40: 
#line 90
    n_bytes ++;
#line 90
    tmp___31 = packet_get_char();
#line 90
    if (tmp___31) {
#line 90
      tio.c_iflag |= 4096U;
    } else {
#line 90
      tio.c_iflag &= 4294963199U;
    }
#line 90
    break;
    case 41: 
#line 92
    n_bytes ++;
#line 92
    tmp___32 = packet_get_char();
#line 92
    if (tmp___32) {
#line 92
      tio.c_iflag |= 8192U;
    } else {
#line 92
      tio.c_iflag &= 4294959103U;
    }
#line 92
    break;
    case 50: 
#line 95
    n_bytes ++;
#line 95
    tmp___33 = packet_get_char();
#line 95
    if (tmp___33) {
#line 95
      tio.c_lflag |= 1U;
    } else {
#line 95
      tio.c_lflag &= 4294967294U;
    }
#line 95
    break;
    case 51: 
#line 96
    n_bytes ++;
#line 96
    tmp___34 = packet_get_char();
#line 96
    if (tmp___34) {
#line 96
      tio.c_lflag |= 2U;
    } else {
#line 96
      tio.c_lflag &= 4294967293U;
    }
#line 96
    break;
    case 52: 
#line 98
    n_bytes ++;
#line 98
    tmp___35 = packet_get_char();
#line 98
    if (tmp___35) {
#line 98
      tio.c_lflag |= 4U;
    } else {
#line 98
      tio.c_lflag &= 4294967291U;
    }
#line 98
    break;
    case 53: 
#line 100
    n_bytes ++;
#line 100
    tmp___36 = packet_get_char();
#line 100
    if (tmp___36) {
#line 100
      tio.c_lflag |= 8U;
    } else {
#line 100
      tio.c_lflag &= 4294967287U;
    }
#line 100
    break;
    case 54: 
#line 101
    n_bytes ++;
#line 101
    tmp___37 = packet_get_char();
#line 101
    if (tmp___37) {
#line 101
      tio.c_lflag |= 16U;
    } else {
#line 101
      tio.c_lflag &= 4294967279U;
    }
#line 101
    break;
    case 55: 
#line 102
    n_bytes ++;
#line 102
    tmp___38 = packet_get_char();
#line 102
    if (tmp___38) {
#line 102
      tio.c_lflag |= 32U;
    } else {
#line 102
      tio.c_lflag &= 4294967263U;
    }
#line 102
    break;
    case 56: 
#line 103
    n_bytes ++;
#line 103
    tmp___39 = packet_get_char();
#line 103
    if (tmp___39) {
#line 103
      tio.c_lflag |= 64U;
    } else {
#line 103
      tio.c_lflag &= 4294967231U;
    }
#line 103
    break;
    case 57: 
#line 104
    n_bytes ++;
#line 104
    tmp___40 = packet_get_char();
#line 104
    if (tmp___40) {
#line 104
      tio.c_lflag |= 128U;
    } else {
#line 104
      tio.c_lflag &= 4294967167U;
    }
#line 104
    break;
    case 58: 
#line 105
    n_bytes ++;
#line 105
    tmp___41 = packet_get_char();
#line 105
    if (tmp___41) {
#line 105
      tio.c_lflag |= 256U;
    } else {
#line 105
      tio.c_lflag &= 4294967039U;
    }
#line 105
    break;
    case 59: 
#line 107
    n_bytes ++;
#line 107
    tmp___42 = packet_get_char();
#line 107
    if (tmp___42) {
#line 107
      tio.c_lflag |= 32768U;
    } else {
#line 107
      tio.c_lflag &= 4294934527U;
    }
#line 107
    break;
    case 60: 
#line 110
    n_bytes ++;
#line 110
    tmp___43 = packet_get_char();
#line 110
    if (tmp___43) {
#line 110
      tio.c_lflag |= 512U;
    } else {
#line 110
      tio.c_lflag &= 4294966783U;
    }
#line 110
    break;
    case 61: 
#line 113
    n_bytes ++;
#line 113
    tmp___44 = packet_get_char();
#line 113
    if (tmp___44) {
#line 113
      tio.c_lflag |= 2048U;
    } else {
#line 113
      tio.c_lflag &= 4294965247U;
    }
#line 113
    break;
    case 62: 
#line 116
    n_bytes ++;
#line 116
    tmp___45 = packet_get_char();
#line 116
    if (tmp___45) {
#line 116
      tio.c_lflag |= 16384U;
    } else {
#line 116
      tio.c_lflag &= 4294950911U;
    }
#line 116
    break;
    case 70: 
#line 119
    n_bytes ++;
#line 119
    tmp___46 = packet_get_char();
#line 119
    if (tmp___46) {
#line 119
      tio.c_oflag |= 1U;
    } else {
#line 119
      tio.c_oflag &= 4294967294U;
    }
#line 119
    break;
    case 71: 
#line 121
    n_bytes ++;
#line 121
    tmp___47 = packet_get_char();
#line 121
    if (tmp___47) {
#line 121
      tio.c_oflag |= 2U;
    } else {
#line 121
      tio.c_oflag &= 4294967293U;
    }
#line 121
    break;
    case 72: 
#line 123
    n_bytes ++;
#line 123
    tmp___48 = packet_get_char();
#line 123
    if (tmp___48) {
#line 123
      tio.c_oflag |= 4U;
    } else {
#line 123
      tio.c_oflag &= 4294967291U;
    }
#line 123
    break;
    case 73: 
#line 125
    n_bytes ++;
#line 125
    tmp___49 = packet_get_char();
#line 125
    if (tmp___49) {
#line 125
      tio.c_oflag |= 8U;
    } else {
#line 125
      tio.c_oflag &= 4294967287U;
    }
#line 125
    break;
    case 74: 
#line 128
    n_bytes ++;
#line 128
    tmp___50 = packet_get_char();
#line 128
    if (tmp___50) {
#line 128
      tio.c_oflag |= 16U;
    } else {
#line 128
      tio.c_oflag &= 4294967279U;
    }
#line 128
    break;
    case 75: 
#line 131
    n_bytes ++;
#line 131
    tmp___51 = packet_get_char();
#line 131
    if (tmp___51) {
#line 131
      tio.c_oflag |= 32U;
    } else {
#line 131
      tio.c_oflag &= 4294967263U;
    }
#line 131
    break;
    case 90: 
#line 134
    n_bytes ++;
#line 134
    tmp___52 = packet_get_char();
#line 134
    if (tmp___52) {
#line 134
      tio.c_cflag |= 32U;
    } else {
#line 134
      tio.c_cflag &= 4294967263U;
    }
#line 134
    break;
    case 91: 
#line 135
    n_bytes ++;
#line 135
    tmp___53 = packet_get_char();
#line 135
    if (tmp___53) {
#line 135
      tio.c_cflag |= 48U;
    } else {
#line 135
      tio.c_cflag &= 4294967247U;
    }
#line 135
    break;
    case 92: 
#line 136
    n_bytes ++;
#line 136
    tmp___54 = packet_get_char();
#line 136
    if (tmp___54) {
#line 136
      tio.c_cflag |= 256U;
    } else {
#line 136
      tio.c_cflag &= 4294967039U;
    }
#line 136
    break;
    case 93: 
#line 137
    n_bytes ++;
#line 137
    tmp___55 = packet_get_char();
#line 137
    if (tmp___55) {
#line 137
      tio.c_cflag |= 512U;
    } else {
#line 137
      tio.c_cflag &= 4294966783U;
    }
#line 137
    break;
    default: 
#line 316 "ttymodes.c"
    debug("Ignoring unsupported tty mode opcode %d (0x%x)", opcode, opcode);
#line 319
    if (opcode >= 0) {
#line 319
      if (opcode < 128) {
#line 321
        n_bytes ++;
#line 322
        packet_get_char();
#line 323
        break;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 328
      if (opcode >= 128) {
#line 328
        if (opcode < 160) {
#line 330
          n_bytes += 4;
#line 331
          packet_get_int();
#line 332
          break;
        }
      }
    }
#line 339
    log("parse_tty_modes: unknown opcode %d", opcode);
#line 340
    while (1) {
#line 340
      _p = 0;
#line 340
      _e = 1;
#line 340
      if (_p != _e) {
#line 340
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "ttymodes.c", 340);
#line 340
        packet_disconnect("Packet integrity error. (%d)", 10);
      }
#line 340
      break;
    }
    goto set;
    }
  }
  set: 
#line 346
  if (*n_bytes_ptr != n_bytes) {
#line 348
    *n_bytes_ptr = n_bytes;
#line 349
    return;
  }
#line 352
  if (failure == -1) {
#line 353
    return;
  }
#line 356
  tmp___58 = tcsetattr(fd, 0, (struct termios  const  *)(& tio));
#line 356
  if (tmp___58 < 0) {
#line 357
    tmp___56 = __errno_location();
#line 357
    tmp___57 = strerror(*tmp___56);
#line 357
    log("Setting tty modes failed: %.100s", tmp___57);
  }
#line 358
  return;
}
}
#line 1 "uidswap.o"
#pragma merger(0,"./uidswap.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 645 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 667
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 677
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 28 "uidswap.h"
void permanently_set_uid(uid_t uid ) ;
#line 38 "uidswap.c"
static uid_t saved_euid  =    (uid_t )0;
#line 43 "uidswap.c"
void temporarily_use_uid(uid_t uid ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 48
  saved_euid = geteuid();
#line 51
  tmp___1 = seteuid(uid);
#line 51
  if (tmp___1 == -1) {
#line 52
    tmp = __errno_location();
#line 52
    tmp___0 = strerror(*tmp);
#line 52
    debug("seteuid %d: %.100s", (int )uid, tmp___0);
  }
#line 66
  return;
}
}
#line 70 "uidswap.c"
void restore_uid(void) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 75
  tmp___1 = seteuid(saved_euid);
#line 75
  if (tmp___1 < 0) {
#line 76
    tmp = __errno_location();
#line 76
    tmp___0 = strerror(*tmp);
#line 76
    debug("seteuid %d: %.100s", (int )saved_euid, tmp___0);
  }
#line 86
  return;
}
}
#line 91 "uidswap.c"
void permanently_set_uid(uid_t uid ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 93
  tmp___1 = setuid(uid);
#line 93
  if (tmp___1 < 0) {
#line 94
    tmp = __errno_location();
#line 94
    tmp___0 = strerror(*tmp);
#line 94
    debug("setuid %d: %.100s", (int )uid, tmp___0);
  }
#line 95
  return;
}
}
#line 1 "xmalloc.o"
#pragma merger(0,"./xmalloc.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 589 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 600
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__warn_unused_result__,
__malloc__)) ;
#line 22 "xmalloc.c"
void *xmalloc(size_t size ) 
{ void *ptr ;
  void *tmp ;

  {
#line 24
  tmp = malloc(size);
#line 24
  ptr = tmp;
#line 25
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 26
    fatal("xmalloc: out of memory (allocating %d bytes)", (int )size);
  }
#line 27
  return (ptr);
}
}
#line 30 "xmalloc.c"
void *xrealloc(void *ptr , size_t new_size ) 
{ void *new_ptr ;

  {
#line 34
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 35
    fatal("xrealloc: NULL pointer given as argument");
  }
#line 36
  new_ptr = realloc(ptr, new_size);
#line 37
  if ((unsigned int )new_ptr == (unsigned int )((void *)0)) {
#line 38
    fatal("xrealloc: out of memory (new_size %d bytes)", (int )new_size);
  }
#line 39
  return (new_ptr);
}
}
#line 42 "xmalloc.c"
void xfree(void *ptr ) 
{ 

  {
#line 44
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 45
    fatal("xfree: NULL pointer given as argument");
  }
#line 46
  free(ptr);
#line 47
  return;
}
}
#line 49 "xmalloc.c"
char *xstrdup(char const   *str ) 
{ int len ;
  size_t tmp ;
  char *cp ;
  void *tmp___0 ;

  {
#line 51
  tmp = strlen(str);
#line 51
  len = (int )(tmp + 1U);
#line 53
  tmp___0 = xmalloc((unsigned int )len);
#line 53
  cp = (char *)tmp___0;
#line 54
  strlcpy(cp, str, (unsigned int )len);
#line 55
  return (cp);
}
}
#line 1 "helper.o"
#pragma merger(0,"./helper.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 84 "rc4.h"
void rc4_key(rc4_t *r , unsigned char *key , int len ) ;
#line 111
void rc4_getbytes(rc4_t *r , unsigned char *buffer , int len ) ;
#line 43 "helper.h"
void arc4random_stir(void) ;
#line 47
void setproctitle(char const   *fmt  , ...) ;
#line 53 "helper.c"
void get_random_bytes(unsigned char *buf , int len ) ;
#line 55 "helper.c"
static rc4_t *rc4  =    (rc4_t *)((void *)0);
#line 57 "helper.c"
unsigned int arc4random(void) 
{ unsigned int r ;

  {
#line 61
  if ((unsigned int )rc4 == (unsigned int )((void *)0)) {
#line 62
    arc4random_stir();
  }
#line 64
  rc4_getbytes(rc4, (unsigned char *)(& r), (int )sizeof(r));
#line 66
  return (r);
}
}
#line 69 "helper.c"
void arc4random_stir(void) 
{ unsigned char rand_buf[32] ;
  void *tmp ;

  {
#line 73
  if ((unsigned int )rc4 == (unsigned int )((void *)0)) {
#line 74
    tmp = xmalloc(sizeof(*rc4));
#line 74
    rc4 = (rc4_t *)tmp;
  }
#line 76
  get_random_bytes(rand_buf, (int )sizeof(rand_buf));
#line 77
  rc4_key(rc4, rand_buf, (int )sizeof(rand_buf));
#line 78
  return;
}
}
#line 80 "helper.c"
void get_random_bytes(unsigned char *buf , int len ) 
{ int urandom ;
  int c ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
#line 85
  urandom = open("/dev/urandom", 0);
#line 86
  if (urandom == -1) {
#line 88
    tmp = __errno_location();
#line 88
    tmp___0 = strerror(*tmp);
#line 88
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Couldn\'t open /dev/urandom: %s",
            tmp___0);
#line 89
    exit(1);
  }
#line 92
  c = read(urandom, (void *)buf, (unsigned int )len);
#line 93
  if (c == -1) {
#line 95
    tmp___1 = __errno_location();
#line 95
    tmp___2 = strerror(*tmp___1);
#line 95
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Couldn\'t read from /dev/urandom: %s",
            tmp___2);
#line 96
    exit(1);
  }
#line 99
  if (c != len) {
#line 101
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Short read from /dev/urandom");
#line 102
    exit(1);
  }
#line 104
  return;
}
}
#line 108 "helper.c"
void setproctitle(char const   *fmt  , ...) 
{ 

  {
#line 111
  return;
}
}
/* compiler builtin: 
   char *__builtin_strncat(char * , char const   * , unsigned int  ) ;  */
#line 1 "sshd.o"
#pragma merger(0,"./sshd.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 280
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 116 "/usr/include/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 194 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 117 "/usr/include/netdb.h"
extern void endhostent(void) ;
#line 590 "/usr/include/stdio.h"
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 747
extern void perror(char const   *__s ) ;
#line 774
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 780
extern int pclose(FILE *__stream ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 628
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 709
extern int mkstemp(char *__template )  __attribute__((__nonnull__(1))) ;
#line 79 "/usr/include/pwd.h"
extern void endpwent(void) ;
#line 69 "/usr/include/grp.h"
extern void endgrent(void) ;
#line 103
extern struct group *getgrgid(__gid_t __gid ) ;
#line 109
extern struct group *getgrnam(char const   *__name ) ;
#line 199
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 384 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 393
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 433
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group )  __attribute__((__nonnull__(1))) ;
#line 438
extern  __attribute__((__nothrow__)) int fchown(int __fd , __uid_t __owner , __gid_t __group ) ;
#line 457
extern  __attribute__((__nothrow__)) int chdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 490
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 493
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 504
extern  __attribute__((__nothrow__)) int execve(char const   *__path , char * const  *__argv ,
                                                char * const  *__envp )  __attribute__((__nonnull__(1))) ;
#line 516
extern  __attribute__((__nothrow__)) int execv(char const   *__path , char * const  *__argv )  __attribute__((__nonnull__(1))) ;
#line 526
extern  __attribute__((__nothrow__)) int execl(char const   *__path , char const   *__arg 
                                               , ...)  __attribute__((__nonnull__(1))) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 684
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 723
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 792
extern  __attribute__((__nothrow__)) int unlink(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 73
extern int optind ;
#line 152
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 903 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
#line 257 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 167 "/usr/include/security/_pam_types.h"
extern int __attribute__((__nonnull__(1)))  pam_set_item(pam_handle_t *pamh , int item_type ,
                                                         void const   *item ) ;
#line 173
extern char const   *pam_strerror(pam_handle_t *pamh , int errnum ) ;
#line 182
extern char ** __attribute__((__nonnull__(1))) pam_getenvlist(pam_handle_t *pamh ) ;
#line 22 "/usr/include/security/pam_appl.h"
extern int __attribute__((__nonnull__(1,3,4)))  pam_start(char const   *service_name ,
                                                          char const   *user , struct pam_conv  const  *pam_conversation ,
                                                          pam_handle_t **pamh ) ;
#line 27
extern int __attribute__((__nonnull__(1)))  pam_end(pam_handle_t *pamh , int pam_status ) ;
#line 32
extern int __attribute__((__nonnull__(1)))  pam_authenticate(pam_handle_t *pamh ,
                                                             int flags ) ;
#line 40
extern int __attribute__((__nonnull__(1)))  pam_acct_mgmt(pam_handle_t *pamh , int flags ) ;
#line 45
extern int __attribute__((__nonnull__(1)))  pam_open_session(pam_handle_t *pamh ,
                                                             int flags ) ;
#line 48
extern int __attribute__((__nonnull__(1)))  pam_close_session(pam_handle_t *pamh ,
                                                              int flags ) ;
#line 478 "/usr/include/openssl/bn.h"
extern int BN_mask_bits(BIGNUM *a , int n ) ;
#line 215 "/usr/include/openssl/rsa.h"
extern RSA *RSA_new(void) ;
#line 244 "ssh.h"
unsigned long get_last_login_time(uid_t uid , char const   *logname , char *buf ,
                                  unsigned int bufsize ) ;
#line 249
void record_login(int pid , char const   *ttyname___0 , char const   *user , uid_t uid ,
                  char const   *host , struct sockaddr_in *addr ) ;
#line 254
void record_logout(int pid , char const   *ttyname___0 ) ;
#line 287
int auth_rhosts(struct passwd *pw , char const   *client_user , int ignore_rhosts ,
                int strict_modes ) ;
#line 292
int auth_rhosts_rsa(struct passwd *pw , char const   *client_user , unsigned int client_host_key_bits ,
                    BIGNUM *client_host_key_e , BIGNUM *client_host_key_n , int ignore_rhosts ,
                    int strict_modes ) ;
#line 299
int auth_password(struct passwd *pw , char const   *password ) ;
#line 304
int auth_rsa(struct passwd *pw , BIGNUM *client_n , int strict_modes ) ;
#line 403
void log_init(char *av0___0 , int on_stderr , int debug___0 , int quiet , SyslogFacility facility ) ;
#line 433
void fatal_remove_cleanup(void (*proc)(void *context ) , void *context ) ;
#line 549
char *xauthfile ;
#line 579
void server_loop(int pid , int fdin_arg , int fdout_arg , int fderr_arg ) ;
#line 26 "pty.h"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf ) ;
#line 30
void pty_release(char const   *ttyname___0 ) ;
#line 34
void pty_make_controlling_tty(int *ttyfd , char const   *ttyname___0 ) ;
#line 37
void pty_change_window_size(int ptyfd , int row , int col , int xpixel , int ypixel ) ;
#line 77 "servconf.h"
void initialize_server_options(ServerOptions *options___0 ) ;
#line 81
void read_server_config(ServerOptions *options___0 , char const   *filename ) ;
#line 84
void fill_default_server_options(ServerOptions *options___0 ) ;
#line 51 "sshd.c"
char *xauthfile  =    (char *)((void *)0);
#line 54 "sshd.c"
ServerOptions options  ;
#line 57 "sshd.c"
char *config_file_name  =    (char *)"/usr/local/etc/sshd_config";
#line 63 "sshd.c"
int debug_flag  =    0;
#line 66 "sshd.c"
int inetd_flag  =    0;
#line 69 "sshd.c"
char *av0  ;
#line 72 "sshd.c"
char **saved_argv  ;
#line 76 "sshd.c"
int listen_sock  ;
#line 80 "sshd.c"
int no_port_forwarding_flag  =    0;
#line 81 "sshd.c"
int no_agent_forwarding_flag  =    0;
#line 82 "sshd.c"
int no_x11_forwarding_flag  =    0;
#line 83 "sshd.c"
int no_pty_flag  =    0;
#line 84 "sshd.c"
char *forced_command  =    (char *)((void *)0);
#line 85 "sshd.c"
struct envstring *custom_environment  =    (struct envstring *)((void *)0);
#line 89 "sshd.c"
unsigned char session_id[16]  ;
#line 97 "sshd.c"
struct __anonstruct_sensitive_data_77 sensitive_data  ;
#line 108 "sshd.c"
int key_used  =    0;
#line 111 "sshd.c"
int received_sighup  =    0;
#line 115 "sshd.c"
RSA *public_key  ;
#line 118
void do_connection(int privileged_port ) ;
#line 119
void do_authentication(char *user , int privileged_port ) ;
#line 120
void eat_packets_and_disconnect(char const   *user ) ;
#line 121
void do_authenticated(struct passwd *pw ) ;
#line 122
void do_exec_pty(char const   *command , int ptyfd , int ttyfd , char const   *ttyname___0 ,
                 struct passwd *pw , char const   *term , char const   *display ,
                 char const   *auth_proto , char const   *auth_data ) ;
#line 126
void do_exec_no_pty(char const   *command , struct passwd *pw , char const   *display ,
                    char const   *auth_proto , char const   *auth_data ) ;
#line 129
void do_child(char const   *command , struct passwd *pw , char const   *term , char const   *display ,
              char const   *auth_proto , char const   *auth_data , char const   *ttyname___0 ) ;
#line 133
static int pamconv(int num_msg , struct pam_message  const  **msg , struct pam_response **resp ,
                   void *appdata_ptr ) ;
#line 135
void do_pam_account_and_session(char const   *username , char const   *password ,
                                char const   *remote_user , char const   *remote_host ) ;
#line 137
void pam_cleanup_proc(void *context ) ;
#line 139 "sshd.c"
static struct pam_conv conv  =    {& pamconv, (void *)0};
#line 143 "sshd.c"
struct pam_handle_t *pamh  =    (struct pam_handle_t *)((void *)0);
#line 144 "sshd.c"
char const   *pampasswd  =    (char const   *)((void *)0);
#line 145 "sshd.c"
char *pamconv_msg  =    (char *)((void *)0);
#line 147 "sshd.c"
static int pamconv(int num_msg , struct pam_message  const  **msg , struct pam_response **resp ,
                   void *appdata_ptr ) 
{ int count ;
  struct pam_response *reply ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;

  {
#line 150
  count = 0;
#line 151
  reply = (struct pam_response *)((void *)0);
#line 154
  tmp = malloc((unsigned int )num_msg * sizeof(*reply));
#line 154
  reply = (struct pam_response *)tmp;
#line 155
  if ((unsigned int )reply == (unsigned int )((void *)0)) {
#line 156
    return (19);
  }
#line 158
  count = 0;
#line 158
  while (count < num_msg) {
#line 160
    switch ((int )(*(msg + count))->msg_style) {
    case 1: 
#line 163
    if ((unsigned int )pampasswd == (unsigned int )((void *)0)) {
#line 165
      free((void *)reply);
#line 166
      return (19);
    }
#line 168
    (reply + count)->resp_retcode = 0;
#line 169
    (reply + count)->resp = xstrdup(pampasswd);
#line 170
    break;
    case 4: 
#line 173
    (reply + count)->resp_retcode = 0;
#line 174
    (reply + count)->resp = xstrdup("");
#line 176
    if ((unsigned int )(*(msg + count))->msg == (unsigned int )((void *)0)) {
#line 176
      break;
    }
#line 177
    debug("Adding PAM message: %s", (*(msg + count))->msg);
#line 178
    if ((unsigned int )pamconv_msg == (unsigned int )((void *)0)) {
#line 180
      tmp___0 = strlen((char const   *)(*(msg + count))->msg);
#line 180
      tmp___1 = malloc(tmp___0 + 2U);
#line 180
      pamconv_msg = (char *)tmp___1;
#line 182
      if ((unsigned int )pamconv_msg == (unsigned int )((void *)0)) {
#line 183
        return (19);
      }
#line 185
      tmp___2 = strlen((char const   *)(*(msg + count))->msg);
#line 185
      __builtin_strncpy(pamconv_msg, (char const   *)(*(msg + count))->msg, tmp___2);
#line 186
      tmp___3 = strlen((char const   *)(*(msg + count))->msg);
#line 186
      *(pamconv_msg + tmp___3) = (char )'\n';
#line 187
      tmp___4 = strlen((char const   *)(*(msg + count))->msg);
#line 187
      *(pamconv_msg + (tmp___4 + 1U)) = (char )'\000';
    } else {
#line 190
      tmp___5 = strlen((char const   *)pamconv_msg);
#line 190
      tmp___6 = strlen((char const   *)(*(msg + count))->msg);
#line 190
      tmp___7 = realloc((void *)pamconv_msg, (tmp___5 + tmp___6) + 2U);
#line 190
      pamconv_msg = (char *)tmp___7;
#line 191
      tmp___8 = strlen((char const   *)(*(msg + count))->msg);
#line 191
      __builtin_strncat(pamconv_msg, (char const   *)(*(msg + count))->msg, tmp___8);
#line 192
      tmp___9 = strlen((char const   *)pamconv_msg);
#line 192
      *(pamconv_msg + tmp___9) = (char )'\n';
#line 193
      tmp___10 = strlen((char const   *)pamconv_msg);
#line 193
      *(pamconv_msg + (tmp___10 + 1U)) = (char )'\000';
    }
#line 195
    break;
    case 2: 
    case 3: 
    default: 
#line 200
    free((void *)reply);
#line 201
    return (19);
    }
#line 158
    count ++;
  }
#line 205
  *resp = reply;
#line 207
  return (0);
}
}
#line 210 "sshd.c"
void pam_cleanup_proc(void *context ) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1)))  tmp ;
  char const   *tmp___0 ;
  int __attribute__((__nonnull__(1)))  tmp___1 ;
  char const   *tmp___2 ;

  {
#line 214
  if ((unsigned int )pamh != (unsigned int )((void *)0)) {
#line 216
    tmp = pam_close_session((pam_handle_t *)pamh, 0);
#line 216
    pam_retval = (int )tmp;
#line 217
    if (pam_retval != 0) {
#line 219
      tmp___0 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 219
      log("Cannot close PAM session: %.200s", tmp___0);
    }
#line 223
    tmp___1 = pam_end((pam_handle_t *)pamh, pam_retval);
#line 223
    pam_retval = (int )tmp___1;
#line 224
    if (pam_retval != 0) {
#line 226
      tmp___2 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 226
      log("Cannot release PAM authentication: %.200s", tmp___2);
    }
  }
#line 230
  return;
}
}
#line 232 "sshd.c"
void do_pam_account_and_session(char const   *username , char const   *password ,
                                char const   *remote_user , char const   *remote_host ) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1)))  tmp ;
  char const   *tmp___0 ;
  int __attribute__((__nonnull__(1)))  tmp___1 ;
  char const   *tmp___2 ;
  int __attribute__((__nonnull__(1)))  tmp___3 ;
  char const   *tmp___4 ;
  int __attribute__((__nonnull__(1)))  tmp___5 ;
  char const   *tmp___6 ;

  {
#line 236
  if ((unsigned int )remote_host != (unsigned int )((void *)0)) {
#line 238
    debug("PAM setting rhost to \"%.200s\"", remote_host);
#line 239
    tmp = pam_set_item((pam_handle_t *)pamh, 4, (void const   *)remote_host);
#line 239
    pam_retval = (int )tmp;
#line 240
    if (pam_retval != 0) {
#line 242
      tmp___0 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 242
      log("PAM set rhost failed: %.200s", tmp___0);
#line 243
      eat_packets_and_disconnect(username);
    }
  }
#line 247
  if ((unsigned int )remote_user != (unsigned int )((void *)0)) {
#line 249
    debug("PAM setting ruser to \"%.200s\"", remote_user);
#line 250
    tmp___1 = pam_set_item((pam_handle_t *)pamh, 8, (void const   *)remote_user);
#line 250
    pam_retval = (int )tmp___1;
#line 251
    if (pam_retval != 0) {
#line 253
      tmp___2 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 253
      log("PAM set ruser failed: %.200s", tmp___2);
#line 254
      eat_packets_and_disconnect(username);
    }
  }
#line 258
  tmp___3 = pam_acct_mgmt((pam_handle_t *)pamh, 0);
#line 258
  pam_retval = (int )tmp___3;
#line 259
  if (pam_retval != 0) {
#line 261
    tmp___4 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 261
    log("PAM rejected by account configuration: %.200s", tmp___4);
#line 262
    eat_packets_and_disconnect(username);
  }
#line 265
  tmp___5 = pam_open_session((pam_handle_t *)pamh, 0);
#line 265
  pam_retval = (int )tmp___5;
#line 266
  if (pam_retval != 0) {
#line 268
    tmp___6 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 268
    log("PAM session setup failed: %.200s", tmp___6);
#line 269
    eat_packets_and_disconnect(username);
  }
#line 271
  return;
}
}
#line 278 "sshd.c"
void sighup_handler(int sig ) 
{ 

  {
#line 280
  received_sighup = 1;
#line 281
  signal(1, & sighup_handler);
#line 282
  return;
}
}
#line 287 "sshd.c"
void sighup_restart(void) 
{ int *tmp ;
  char *tmp___0 ;

  {
#line 289
  log("Received SIGHUP; restarting.");
#line 290
  close(listen_sock);
#line 291
  execv((char const   *)*(saved_argv + 0), (char * const  *)saved_argv);
#line 292
  tmp = __errno_location();
#line 292
  tmp___0 = strerror(*tmp);
#line 292
  log("RESTART FAILED: av0=\'%s\', error: %s.", av0, tmp___0);
#line 293
  exit(1);
}
}
#line 300 "sshd.c"
void sigterm_handler(int sig ) 
{ 

  {
#line 302
  log("Received signal %d; terminating.", sig);
#line 303
  close(listen_sock);
#line 304
  exit(255);
}
}
#line 310 "sshd.c"
void main_sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  int status ;
  int *tmp___0 ;

  {
#line 312
  tmp = __errno_location();
#line 312
  save_errno = *tmp;
#line 314
  wait((union wait *)(& status));
#line 315
  signal(17, & main_sigchld_handler);
#line 316
  tmp___0 = __errno_location();
#line 316
  *tmp___0 = save_errno;
#line 317
  return;
}
}
#line 321 "sshd.c"
void grace_alarm_handler(int sig ) 
{ 

  {
#line 324
  packet_close();
#line 327
  fatal("Timeout before authentication.");
#line 328
  return;
}
}
#line 335 "sshd.c"
void key_regeneration_alarm(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 337
  tmp = __errno_location();
#line 337
  save_errno = *tmp;
#line 340
  if (key_used) {
#line 343
    log("Generating new %d bit RSA key.", options.server_key_bits);
#line 345
    if ((unsigned int )sensitive_data.private_key != (unsigned int )((void *)0)) {
#line 346
      RSA_free(sensitive_data.private_key);
    }
#line 347
    sensitive_data.private_key = RSA_new();
#line 349
    if ((unsigned int )public_key != (unsigned int )((void *)0)) {
#line 350
      RSA_free(public_key);
    }
#line 351
    public_key = RSA_new();
#line 353
    rsa_generate_key(sensitive_data.private_key, public_key, (unsigned int )options.server_key_bits);
#line 355
    arc4random_stir();
#line 356
    key_used = 0;
#line 357
    log("RSA key generation complete.");
  }
#line 361
  signal(14, & key_regeneration_alarm);
#line 362
  alarm((unsigned int )options.key_regeneration_time);
#line 363
  tmp___0 = __errno_location();
#line 363
  *tmp___0 = save_errno;
#line 364
  return;
}
}
#line 368 "sshd.c"
int main(int ac , char **av ) 
{ int opt ;
  int aux ;
  int sock_in ;
  int sock_out ;
  int newsock ;
  int i ;
  int pid ;
  int on ;
  int remote_major ;
  int remote_minor ;
  int silentrsa ;
  struct sockaddr_in sin ;
  char buf[100] ;
  char remote_version[100] ;
  char *comment ;
  FILE *f ;
  struct linger linger ;
  char *tmp ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int err ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int fd ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int s1 ;
  int s2 ;
  int *tmp___18 ;
  char *tmp___19 ;
  register unsigned short __v ;
  register unsigned short __x ;
  int *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  __pid_t tmp___23 ;
  int *tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  int *tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int *tmp___32 ;
  char *tmp___33 ;
  int tmp___34 ;
  char const   *tmp___35 ;
  size_t tmp___36 ;
  ssize_t tmp___37 ;
  size_t tmp___38 ;
  ssize_t tmp___39 ;
  char const   *s ;
  size_t tmp___40 ;
  int tmp___41 ;
  char const   *s___0 ;
  size_t tmp___42 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___48 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  char *tmp___54 ;
  int retval ;
  int __attribute__((__nonnull__(1)))  tmp___55 ;
  int __attribute__((__nonnull__(1)))  tmp___56 ;

  {
#line 373
  on = 1;
#line 375
  silentrsa = 0;
#line 384
  saved_argv = av;
#line 385
  tmp___1 = __builtin_strchr(*(av + 0), '/');
#line 385
  if (tmp___1) {
#line 386
    tmp = strrchr((char const   *)*(av + 0), '/');
#line 386
    av0 = tmp + 1;
  } else {
#line 388
    av0 = *(av + 0);
  }
#line 391
  initialize_server_options(& options);
#line 394
  while (1) {
#line 394
    opt = getopt(ac, (char * const  *)av, "f:p:b:k:h:g:diqQ");
#line 394
    if (! (opt != -1)) {
#line 394
      break;
    }
#line 396
    switch (opt) {
    case 102: 
#line 399
    config_file_name = optarg;
#line 400
    break;
    case 100: 
#line 402
    debug_flag = 1;
#line 403
    break;
    case 105: 
#line 405
    inetd_flag = 1;
#line 406
    break;
    case 81: 
#line 408
    silentrsa = 1;
#line 409
    break;
    case 113: 
#line 411
    options.quiet_mode = 1;
#line 412
    break;
    case 98: 
#line 414
    options.server_key_bits = atoi((char const   *)optarg);
#line 415
    break;
    case 112: 
#line 417
    options.port = atoi((char const   *)optarg);
#line 418
    break;
    case 103: 
#line 420
    options.login_grace_time = atoi((char const   *)optarg);
#line 421
    break;
    case 107: 
#line 423
    options.key_regeneration_time = atoi((char const   *)optarg);
#line 424
    break;
    case 104: 
#line 426
    options.host_key_file = optarg;
#line 427
    break;
    case 63: 
    default: 
#line 430
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"sshd version %s\n",
            "OpenSSH-1.2");
#line 431
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: %s [options]\n",
            av0);
#line 432
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Options:\n");
#line 433
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -f file    Configuration file (default %s/sshd_config)\n",
            "/usr/local/etc");
#line 434
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -d         Debugging mode\n");
#line 435
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -i         Started from inetd\n");
#line 436
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -q         Quiet (no logging)\n");
#line 437
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -p port    Listen on the specified port (default: 22)\n");
#line 438
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -k seconds Regenerate server key every this many seconds (default: 3600)\n");
#line 439
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -g seconds Grace period for authentication (default: 300)\n");
#line 440
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -b bits    Size of server RSA key (default: 768 bits)\n");
#line 441
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -h file    File from which to read host key (default: %s)\n",
            "/usr/local/etc/ssh_host_key");
#line 443
    exit(1);
    }
  }
#line 448
  tmp___2 = rsa_alive();
#line 448
  if (tmp___2 == 0) {
#line 449
    if (silentrsa == 0) {
#line 450
      printf((char const   * __restrict  )"sshd: no RSA support in libssl and libcrypto -- exiting.  See ssl(8)\n");
    }
#line 451
    log("no RSA support in libssl and libcrypto -- exiting.  See ssl(8)");
#line 452
    exit(1);
  }
#line 456
  read_server_config(& options, (char const   *)config_file_name);
#line 459
  fill_default_server_options(& options);
#line 462
  if (options.server_key_bits < 512) {
#line 465
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 466
    exit(1);
  } else {
#line 462
    if (options.server_key_bits > 32768) {
#line 465
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 466
      exit(1);
    }
  }
#line 468
  if (options.port < 1) {
#line 470
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad port number.\n");
#line 471
    exit(1);
  } else {
#line 468
    if (options.port > 65535) {
#line 470
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad port number.\n");
#line 471
      exit(1);
    }
  }
#line 475
  if (optind < ac) {
#line 477
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Extra argument %s.\n",
            *(av + optind));
#line 478
    exit(1);
  }
#line 482
  if (debug_flag) {
#line 482
    tmp___3 = 1;
  } else {
#line 482
    if (options.fascist_logging) {
#line 482
      tmp___3 = 1;
    } else {
#line 482
      tmp___3 = 0;
    }
  }
#line 482
  if (debug_flag) {
#line 482
    if (! inetd_flag) {
#line 482
      tmp___4 = 1;
    } else {
#line 482
      tmp___4 = 0;
    }
  } else {
#line 482
    tmp___4 = 0;
  }
#line 482
  log_init(av0, tmp___4, tmp___3, options.quiet_mode, options.log_facility);
#line 486
  debug("sshd version %.100s", "OpenSSH-1.2");
#line 488
  sensitive_data.host_key = RSA_new();
#line 490
  tmp___9 = load_private_key((char const   *)options.host_key_file, "", sensitive_data.host_key,
                             & comment);
#line 490
  if (! tmp___9) {
#line 493
    if (debug_flag) {
#line 494
      tmp___5 = __errno_location();
#line 494
      tmp___6 = strerror(*tmp___5);
#line 494
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not load host key: %s: %s\n",
              options.host_key_file, tmp___6);
    } else {
#line 498
      tmp___7 = __errno_location();
#line 498
      err = *tmp___7;
#line 499
      log_init(av0, ! inetd_flag, 1, 0, options.log_facility);
#line 500
      tmp___8 = strerror(err);
#line 500
      error("Could not load host key: %.200s: %.100s", options.host_key_file, tmp___8);
    }
#line 503
    exit(1);
  }
#line 505
  xfree((void *)comment);
#line 509
  if (! debug_flag) {
#line 509
    if (! inetd_flag) {
#line 514
      tmp___12 = daemon(0, 0);
#line 514
      if (tmp___12 < 0) {
#line 515
        tmp___10 = __errno_location();
#line 515
        tmp___11 = strerror(*tmp___10);
#line 515
        fatal("daemon() failed: %.200s", tmp___11);
      }
#line 519
      fd = open("/dev/tty", 258);
#line 520
      if (fd >= 0) {
#line 522
        ioctl(fd, 21538UL, (void *)0);
#line 523
        close(fd);
      }
    }
  }
#line 529
  if (debug_flag) {
#line 529
    tmp___13 = 1;
  } else {
#line 529
    if (options.fascist_logging) {
#line 529
      tmp___13 = 1;
    } else {
#line 529
      tmp___13 = 0;
    }
  }
#line 529
  if (debug_flag) {
#line 529
    if (! inetd_flag) {
#line 529
      tmp___14 = 1;
    } else {
#line 529
      tmp___14 = 0;
    }
  } else {
#line 529
    tmp___14 = 0;
  }
#line 529
  log_init(av0, tmp___14, tmp___13, options.quiet_mode, options.log_facility);
#line 536
  tmp___16 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 536
  if (options.server_key_bits > tmp___16 - 128) {
#line 536
    tmp___17 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 536
    if (options.server_key_bits < tmp___17 + 128) {
#line 541
      tmp___15 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 541
      options.server_key_bits = tmp___15 + 128;
#line 543
      debug("Forcing server key to %d bits to make it differ from host key.", options.server_key_bits);
    }
  }
#line 548
  rsa_set_verbose(0);
#line 551
  arc4random_stir();
#line 555
  chdir("/");
#line 558
  cipher_attack_detected = & packet_disconnect;
#line 561
  if (inetd_flag) {
#line 564
    s1 = dup(0);
#line 565
    s2 = dup(s1);
#line 566
    sock_in = dup(0);
#line 567
    sock_out = dup(1);
#line 571
    debug("inetd sockets after dupping: %d, %d", sock_in, sock_out);
#line 573
    public_key = RSA_new();
#line 574
    sensitive_data.private_key = RSA_new();
#line 576
    log("Generating %d bit RSA key.", options.server_key_bits);
#line 577
    rsa_generate_key(sensitive_data.private_key, public_key, (unsigned int )options.server_key_bits);
#line 579
    arc4random_stir();
#line 580
    log("RSA key generation complete.");
  } else {
#line 585
    listen_sock = socket(2, 1, 0);
#line 586
    if (listen_sock < 0) {
#line 587
      tmp___18 = __errno_location();
#line 587
      tmp___19 = strerror(*tmp___18);
#line 587
      fatal("socket: %.100s", tmp___19);
    }
#line 592
    setsockopt(listen_sock, 1, 2, (void const   *)((void *)(& on)), sizeof(on));
#line 594
    linger.l_onoff = 1;
#line 595
    linger.l_linger = 5;
#line 596
    setsockopt(listen_sock, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 600
    memset((void *)(& sin), 0, sizeof(sin));
#line 601
    sin.sin_family = (unsigned short)2;
#line 602
    sin.sin_addr = options.listen_addr;
#line 603
    __x = (unsigned short )options.port;
#line 603
    __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 603
    sin.sin_port = __v;
#line 606
    tmp___22 = bind(listen_sock, (struct sockaddr  const  *)((struct sockaddr *)(& sin)),
                    sizeof(sin));
#line 606
    if (tmp___22 < 0) {
#line 608
      tmp___20 = __errno_location();
#line 608
      tmp___21 = strerror(*tmp___20);
#line 608
      error("bind: %.100s", tmp___21);
#line 609
      shutdown(listen_sock, 2);
#line 610
      close(listen_sock);
#line 611
      fatal("Bind to port %d failed.", options.port);
    }
#line 614
    if (! debug_flag) {
#line 620
      f = fopen((char const   * __restrict  )"/var/run/sshd.pid", (char const   * __restrict  )"w");
#line 621
      if (f) {
#line 623
        tmp___23 = getpid();
#line 623
        fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%u\n", (unsigned int )tmp___23);
#line 624
        fclose(f);
      }
    }
#line 629
    log("Server listening on port %d.", options.port);
#line 630
    tmp___26 = listen(listen_sock, 5);
#line 630
    if (tmp___26 < 0) {
#line 631
      tmp___24 = __errno_location();
#line 631
      tmp___25 = strerror(*tmp___24);
#line 631
      fatal("listen: %.100s", tmp___25);
    }
#line 633
    public_key = RSA_new();
#line 634
    sensitive_data.private_key = RSA_new();
#line 636
    log("Generating %d bit RSA key.", options.server_key_bits);
#line 637
    rsa_generate_key(sensitive_data.private_key, public_key, (unsigned int )options.server_key_bits);
#line 639
    arc4random_stir();
#line 640
    log("RSA key generation complete.");
#line 643
    signal(14, & key_regeneration_alarm);
#line 644
    alarm((unsigned int )options.key_regeneration_time);
#line 647
    signal(1, & sighup_handler);
#line 648
    signal(15, & sigterm_handler);
#line 649
    signal(3, & sigterm_handler);
#line 652
    signal(17, & main_sigchld_handler);
#line 656
    while (1) {
#line 658
      if (received_sighup) {
#line 659
        sighup_restart();
      }
#line 661
      aux = (int )sizeof(sin);
#line 662
      newsock = accept(listen_sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& sin)),
                       (socklen_t * __restrict  )(& aux));
#line 663
      if (received_sighup) {
#line 664
        sighup_restart();
      }
#line 665
      if (newsock < 0) {
#line 667
        tmp___27 = __errno_location();
#line 667
        if (*tmp___27 == 4) {
          goto __Cont;
        }
#line 669
        tmp___28 = __errno_location();
#line 669
        tmp___29 = strerror(*tmp___28);
#line 669
        error("accept: %.100s", tmp___29);
        goto __Cont;
      }
#line 675
      if (debug_flag) {
#line 679
        debug("Server will not fork when running in debugging mode.");
#line 680
        close(listen_sock);
#line 681
        sock_in = newsock;
#line 682
        sock_out = newsock;
#line 683
        pid = getpid();
#line 684
        break;
      } else {
#line 690
        pid = fork();
#line 690
        if (pid == 0) {
#line 696
          close(listen_sock);
#line 697
          sock_in = newsock;
#line 698
          sock_out = newsock;
#line 699
          if (options.fascist_logging) {
#line 699
            tmp___30 = 1;
          } else {
#line 699
            if (debug_flag) {
#line 699
              tmp___30 = 1;
            } else {
#line 699
              tmp___30 = 0;
            }
          }
#line 699
          if (debug_flag) {
#line 699
            if (! inetd_flag) {
#line 699
              tmp___31 = 1;
            } else {
#line 699
              tmp___31 = 0;
            }
          } else {
#line 699
            tmp___31 = 0;
          }
#line 699
          log_init(av0, tmp___31, tmp___30, options.quiet_mode, options.log_facility);
#line 702
          break;
        }
      }
#line 707
      if (pid < 0) {
#line 708
        tmp___32 = __errno_location();
#line 708
        tmp___33 = strerror(*tmp___32);
#line 708
        error("fork: %.100s", tmp___33);
      } else {
#line 710
        debug("Forked child %d.", pid);
      }
#line 713
      key_used = 1;
#line 715
      arc4random_stir();
#line 718
      close(newsock);
      __Cont: /* CIL Label */ ;
    }
  }
#line 727
  alarm(0U);
#line 728
  signal(14, (void (*)(int  ))0);
#line 729
  signal(1, (void (*)(int  ))0);
#line 730
  signal(15, (void (*)(int  ))0);
#line 731
  signal(3, (void (*)(int  ))0);
#line 732
  signal(17, (void (*)(int  ))0);
#line 738
  linger.l_onoff = 1;
#line 739
  linger.l_linger = 5;
#line 740
  setsockopt(sock_in, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 744
  packet_set_connection(sock_in, sock_out);
#line 764
  tmp___34 = get_remote_port();
#line 764
  tmp___35 = get_remote_ipaddr();
#line 764
  log("Connection from %.100s port %d", tmp___35, tmp___34);
#line 773
  signal(14, & grace_alarm_handler);
#line 774
  if (! debug_flag) {
#line 775
    alarm((unsigned int )options.login_grace_time);
  }
#line 778
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"SSH-%d.%d-%.100s\n",
           1, 5, "OpenSSH-1.2");
#line 780
  tmp___36 = strlen((char const   *)(buf));
#line 780
  tmp___37 = write(sock_out, (void const   *)(buf), tmp___36);
#line 780
  tmp___38 = strlen((char const   *)(buf));
#line 780
  if ((size_t )tmp___37 != tmp___38) {
#line 781
    fatal("Could not write ident string.");
  }
#line 784
  i = 0;
#line 784
  while ((unsigned int )i < sizeof(buf) - 1U) {
#line 786
    tmp___39 = read(sock_in, (void *)(& buf[i]), 1U);
#line 786
    if (tmp___39 != 1) {
#line 787
      fatal("Did not receive ident string.");
    }
#line 788
    if ((int )buf[i] == 13) {
#line 790
      buf[i] = (char )'\n';
#line 791
      buf[i + 1] = (char)0;
#line 792
      break;
    }
#line 794
    if ((int )buf[i] == 10) {
#line 797
      buf[i + 1] = (char)0;
#line 798
      break;
    }
#line 784
    i ++;
  }
#line 801
  buf[sizeof(buf) - 1U] = (char)0;
#line 805
  tmp___41 = sscanf((char const   * __restrict  )(buf), (char const   * __restrict  )"SSH-%d.%d-%[^\n]\n",
                    & remote_major, & remote_minor, remote_version);
#line 805
  if (tmp___41 != 3) {
#line 808
    s = "Protocol mismatch.\n";
#line 809
    tmp___40 = strlen(s);
#line 809
    write(sock_out, (void const   *)s, tmp___40);
#line 810
    close(sock_in);
#line 811
    close(sock_out);
#line 812
    fatal("Bad protocol version identification: %.100s", buf);
  }
#line 814
  debug("Client protocol version %d.%d; client software version %.100s", remote_major,
        remote_minor, remote_version);
#line 816
  if (remote_major != 1) {
#line 818
    s___0 = "Protocol major versions differ.\n";
#line 819
    tmp___42 = strlen(s___0);
#line 819
    write(sock_out, (void const   *)s___0, tmp___42);
#line 820
    close(sock_in);
#line 821
    close(sock_out);
#line 822
    fatal("Protocol major versions differ: %d vs. %d", 1, remote_major);
  }
#line 827
  if (remote_major == 1) {
#line 827
    if (remote_minor < 3) {
#line 828
      packet_disconnect("Your ssh version is too old and is no longer supported.  Please install a newer version.");
    }
  }
#line 830
  if (remote_major == 1) {
#line 830
    if (remote_minor == 3) {
#line 831
      enable_compat13();
#line 832
      if (0) {
#line 832
        __s1_len = strlen((char const   *)(remote_version));
#line 832
        __s2_len = strlen("OpenSSH-1.1");
#line 832
        if (! ((unsigned int )((void const   *)(remote_version + 1)) - (unsigned int )((void const   *)(remote_version)) == 1U)) {
          goto _L___0;
        } else {
#line 832
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 832
            if (! ((unsigned int )((void const   *)("OpenSSH-1.1" + 1)) - (unsigned int )((void const   *)"OpenSSH-1.1") == 1U)) {
#line 832
              tmp___52 = 1;
            } else {
#line 832
              if (__s2_len >= 4U) {
#line 832
                tmp___52 = 1;
              } else {
#line 832
                tmp___52 = 0;
              }
            }
          } else {
#line 832
            tmp___52 = 0;
          }
        }
#line 832
        if (tmp___52) {
#line 832
          tmp___48 = __builtin_strcmp((char const   *)(remote_version), "OpenSSH-1.1");
        } else {
#line 832
          tmp___51 = __builtin_strcmp((char const   *)(remote_version), "OpenSSH-1.1");
#line 832
          tmp___48 = tmp___51;
        }
      } else {
#line 832
        tmp___51 = __builtin_strcmp((char const   *)(remote_version), "OpenSSH-1.1");
#line 832
        tmp___48 = tmp___51;
      }
#line 832
      if (tmp___48 != 0) {
#line 833
        debug("Agent forwarding disabled, remote version is not compatible.");
#line 834
        no_agent_forwarding_flag = 1;
      }
    }
  }
#line 838
  packet_set_nonblocking();
#line 842
  tmp___53 = get_remote_port();
#line 842
  do_connection(tmp___53 < 1024);
#line 851
  if (xauthfile) {
#line 851
    unlink((char const   *)xauthfile);
  }
#line 854
  tmp___54 = inet_ntoa(sin.sin_addr);
#line 854
  log("Closing connection to %.100s", tmp___54);
#line 860
  if ((unsigned int )pamh != (unsigned int )((void *)0)) {
#line 862
    debug("Closing PAM session.");
#line 863
    tmp___55 = pam_close_session((pam_handle_t *)pamh, 0);
#line 863
    retval = (int )tmp___55;
#line 865
    debug("Terminating PAM library.");
#line 866
    tmp___56 = pam_end((pam_handle_t *)pamh, retval);
#line 866
    if (tmp___56 != (int __attribute__((__nonnull__(1)))  )0) {
#line 867
      log("Cannot release PAM authentication.");
    }
#line 869
    fatal_remove_cleanup(& pam_cleanup_proc, (void *)0);
  }
#line 874
  packet_close();
#line 876
  exit(0);
}
}
#line 883 "sshd.c"
void do_connection(int privileged_port ) 
{ int i ;
  BIGNUM *session_key_int ;
  unsigned char session_key[32] ;
  unsigned char check_bytes[8] ;
  char *user ;
  unsigned int cipher_type___0 ;
  unsigned int auth_mask ;
  unsigned int protocol_flags ;
  int plen ;
  int slen ;
  u_int32_t rand___0 ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  char const   *tmp___5 ;
  int _p ;
  int _e ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int ulen ;
  int _p___0 ;
  int _e___0 ;

  {
#line 892
  rand___0 = (u_int32_t )0;
#line 901
  i = 0;
#line 901
  while (i < 8) {
#line 902
    if (i % 4 == 0) {
#line 903
      rand___0 = arc4random();
    }
#line 904
    check_bytes[i] = (unsigned char )(rand___0 & 255U);
#line 905
    rand___0 >>= 8;
#line 901
    i ++;
  }
#line 910
  packet_start(2);
#line 911
  i = 0;
#line 911
  while (i < 8) {
#line 912
    packet_put_char((int )check_bytes[i]);
#line 911
    i ++;
  }
#line 915
  tmp = BN_num_bits((BIGNUM const   *)public_key->n);
#line 915
  packet_put_int((unsigned int )tmp);
#line 916
  packet_put_bignum(public_key->e);
#line 917
  packet_put_bignum(public_key->n);
#line 920
  tmp___0 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 920
  packet_put_int((unsigned int )tmp___0);
#line 921
  packet_put_bignum((sensitive_data.host_key)->e);
#line 922
  packet_put_bignum((sensitive_data.host_key)->n);
#line 925
  packet_put_int(2U);
#line 928
  tmp___1 = cipher_mask();
#line 928
  packet_put_int(tmp___1);
#line 931
  auth_mask = 0U;
#line 932
  if (options.rhosts_authentication) {
#line 933
    auth_mask |= (unsigned int )(1 << 1);
  }
#line 934
  if (options.rhosts_rsa_authentication) {
#line 935
    auth_mask |= (unsigned int )(1 << 4);
  }
#line 936
  if (options.rsa_authentication) {
#line 937
    auth_mask |= (unsigned int )(1 << 2);
  }
#line 948
  if (options.password_authentication) {
#line 949
    auth_mask |= (unsigned int )(1 << 3);
  }
#line 950
  packet_put_int(auth_mask);
#line 953
  packet_send();
#line 954
  packet_write_wait();
#line 956
  tmp___2 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 956
  tmp___3 = BN_num_bits((BIGNUM const   *)public_key->n);
#line 956
  debug("Sent %d bit public key and %d bit host key.", tmp___3, tmp___2);
#line 960
  packet_read_expect(& plen, 3);
#line 963
  cipher_type___0 = packet_get_char();
#line 967
  i = 0;
#line 967
  while (i < 8) {
#line 968
    tmp___4 = packet_get_char();
#line 968
    if ((unsigned int )check_bytes[i] != tmp___4) {
#line 969
      packet_disconnect("IP Spoofing check bytes do not match.");
    }
#line 967
    i ++;
  }
#line 971
  tmp___5 = cipher_name((int )cipher_type___0);
#line 971
  debug("Encryption type: %.200s", tmp___5);
#line 974
  session_key_int = BN_new();
#line 975
  packet_get_bignum(session_key_int, & slen);
#line 978
  protocol_flags = packet_get_int();
#line 979
  packet_set_protocol_flags(protocol_flags);
#line 981
  while (1) {
#line 981
    _p = plen;
#line 981
    _e = (9 + slen) + 4;
#line 981
    if (_p != _e) {
#line 981
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "sshd.c", 981);
#line 981
      packet_disconnect("Packet integrity error. (%d)", 3);
    }
#line 981
    break;
  }
#line 985
  tmp___14 = BN_cmp((BIGNUM const   *)(sensitive_data.private_key)->n, (BIGNUM const   *)(sensitive_data.host_key)->n);
#line 985
  if (tmp___14 > 0) {
#line 988
    tmp___8 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 988
    tmp___9 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 988
    if (tmp___8 < tmp___9 + 128) {
#line 990
      tmp___6 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 990
      tmp___7 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 990
      fatal("do_connection: private_key %d < host_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___7, tmp___6, 128);
    }
#line 996
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.private_key);
#line 998
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.host_key);
  } else {
#line 1004
    tmp___12 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1004
    tmp___13 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 1004
    if (tmp___12 < tmp___13 + 128) {
#line 1006
      tmp___10 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 1006
      tmp___11 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1006
      fatal("do_connection: host_key %d < private_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___11, tmp___10, 128);
    }
#line 1011
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.host_key);
#line 1013
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.private_key);
  }
#line 1018
  tmp___15 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 1018
  tmp___16 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1018
  compute_session_id((unsigned char *)(session_id), (unsigned char *)(check_bytes),
                     (unsigned int )tmp___16, (sensitive_data.host_key)->n, (unsigned int )tmp___15,
                     (sensitive_data.private_key)->n);
#line 1027
  BN_mask_bits(session_key_int, (int )(sizeof(session_key) * 8U));
#line 1028
  tmp___18 = BN_num_bits((BIGNUM const   *)session_key_int);
#line 1028
  if ((unsigned int )((tmp___18 + 7) / 8) != sizeof(session_key)) {
#line 1029
    tmp___17 = BN_num_bits((BIGNUM const   *)session_key_int);
#line 1029
    fatal("do_connection: session_key_int %d != sizeof(session_key) %d", (tmp___17 + 7) / 8,
          sizeof(session_key));
  }
#line 1032
  BN_bn2bin((BIGNUM const   *)session_key_int, session_key);
#line 1035
  i = 0;
#line 1035
  while (i < 16) {
#line 1036
    session_key[i] = (unsigned char )((int )session_key[i] ^ (int )session_id[i]);
#line 1035
    i ++;
  }
#line 1039
  BN_clear_free(session_key_int);
#line 1043
  packet_set_encryption_key((unsigned char const   *)(session_key), 32U, (int )cipher_type___0,
                            0);
#line 1047
  memset((void *)(session_key), 0, sizeof(session_key));
#line 1049
  debug("Received session key; encryption turned on.");
#line 1053
  packet_start(14);
#line 1054
  packet_send();
#line 1055
  packet_write_wait();
#line 1058
  packet_read_expect(& plen, 4);
#line 1063
  user = packet_get_string((unsigned int *)(& ulen));
#line 1064
  while (1) {
#line 1064
    _p___0 = plen;
#line 1064
    _e___0 = 4 + ulen;
#line 1064
    if (_p___0 != _e___0) {
#line 1064
      log("Packet integrity error (%d != %d) at %s:%d", _p___0, _e___0, "sshd.c",
          1064);
#line 1064
      packet_disconnect("Packet integrity error. (%d)", 4);
    }
#line 1064
    break;
  }
#line 1068
  RSA_free(public_key);
#line 1069
  RSA_free(sensitive_data.private_key);
#line 1070
  RSA_free(sensitive_data.host_key);
#line 1072
  setproctitle("%s", user);
#line 1074
  do_authentication(user, privileged_port);
#line 1075
  return;
}
}
#line 1084 "sshd.c"
static int allowed_user(struct passwd *pw ) 
{ struct group *grp ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1091
  if (! pw) {
#line 1092
    return (0);
  }
#line 1097
  if (options.num_deny_users > 0U) {
#line 1099
    if (! pw->pw_name) {
#line 1100
      return (0);
    }
#line 1101
    i = 0;
#line 1101
    while ((unsigned int )i < options.num_deny_users) {
#line 1102
      tmp = match_pattern((char const   *)pw->pw_name, (char const   *)options.deny_users[i]);
#line 1102
      if (tmp) {
#line 1103
        return (0);
      }
#line 1101
      i ++;
    }
  }
#line 1107
  if (options.num_allow_users > 0U) {
#line 1109
    if (! pw->pw_name) {
#line 1110
      return (0);
    }
#line 1111
    i = 0;
#line 1111
    while ((unsigned int )i < options.num_allow_users) {
#line 1112
      tmp___0 = match_pattern((char const   *)pw->pw_name, (char const   *)options.allow_users[i]);
#line 1112
      if (tmp___0) {
#line 1113
        break;
      }
#line 1111
      i ++;
    }
#line 1115
    if ((unsigned int )i >= options.num_allow_users) {
#line 1116
      return (0);
    }
  }
#line 1120
  if (options.num_deny_groups > 0U) {
    goto _L;
  } else {
#line 1120
    if (options.num_allow_groups > 0U) {
      _L: /* CIL Label */ 
#line 1122
      grp = getgrgid(pw->pw_gid);
#line 1123
      if (! grp) {
#line 1124
        return (0);
      }
#line 1127
      if (options.num_deny_groups > 0U) {
#line 1129
        if (! grp->gr_name) {
#line 1130
          return (0);
        }
#line 1131
        i = 0;
#line 1131
        while ((unsigned int )i < options.num_deny_groups) {
#line 1132
          tmp___1 = match_pattern((char const   *)grp->gr_name, (char const   *)options.deny_groups[i]);
#line 1132
          if (tmp___1) {
#line 1133
            return (0);
          }
#line 1131
          i ++;
        }
      }
#line 1138
      if (options.num_allow_groups > 0U) {
#line 1140
        if (! grp->gr_name) {
#line 1141
          return (0);
        }
#line 1142
        i = 0;
#line 1142
        while ((unsigned int )i < options.num_allow_groups) {
#line 1143
          tmp___2 = match_pattern((char const   *)grp->gr_name, (char const   *)options.allow_groups[i]);
#line 1143
          if (tmp___2) {
#line 1144
            break;
          }
#line 1142
          i ++;
        }
#line 1146
        if ((unsigned int )i >= options.num_allow_groups) {
#line 1147
          return (0);
        }
      }
    }
  }
#line 1152
  return (1);
}
}
#line 1162 "sshd.c"
void do_authentication(char *user , int privileged_port ) 
{ int type ;
  int authenticated ;
  int authentication_failures ;
  char *password ;
  struct passwd *pw ;
  struct passwd pwcopy ;
  char *client_user ;
  unsigned int client_host_key_bits ;
  BIGNUM *client_host_key_e ;
  BIGNUM *client_host_key_n ;
  int pam_retval ;
  int tmp ;
  int __attribute__((__nonnull__(1,3,4)))  tmp___0 ;
  char const   *tmp___1 ;
  __uid_t tmp___2 ;
  __uid_t tmp___3 ;
  int tmp___4 ;
  int plen ;
  int dlen ;
  int _p ;
  int _e ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int ulen ;
  int elen ;
  int nlen ;
  int _p___0 ;
  int _e___0 ;
  int tmp___7 ;
  int nlen___0 ;
  BIGNUM *n___0 ;
  int _p___1 ;
  int _e___1 ;
  int tmp___8 ;
  int passw_len ;
  int _p___2 ;
  int _e___2 ;
  int __attribute__((__nonnull__(1)))  tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  size_t tmp___14 ;

  {
#line 1166
  authenticated = 0;
#line 1167
  authentication_failures = 0;
#line 1168
  password = (char *)((void *)0);
#line 1170
  client_user = (char *)((void *)0);
#line 1186
  pw = getpwnam((char const   *)user);
#line 1187
  if (! pw) {
#line 1188
    eat_packets_and_disconnect((char const   *)user);
  } else {
#line 1187
    tmp = allowed_user(pw);
#line 1187
    if (! tmp) {
#line 1188
      eat_packets_and_disconnect((char const   *)user);
    }
  }
#line 1191
  memset((void *)(& pwcopy), 0, sizeof(pwcopy));
#line 1192
  pwcopy.pw_name = xstrdup((char const   *)pw->pw_name);
#line 1193
  pwcopy.pw_passwd = xstrdup((char const   *)pw->pw_passwd);
#line 1194
  pwcopy.pw_uid = pw->pw_uid;
#line 1195
  pwcopy.pw_gid = pw->pw_gid;
#line 1196
  pwcopy.pw_dir = xstrdup((char const   *)pw->pw_dir);
#line 1197
  pwcopy.pw_shell = xstrdup((char const   *)pw->pw_shell);
#line 1198
  pw = & pwcopy;
#line 1201
  debug("Starting up PAM with username \"%.200s\"", pw->pw_name);
#line 1202
  tmp___0 = pam_start("sshd", (char const   *)pw->pw_name, (struct pam_conv  const  *)(& conv),
                      (pam_handle_t **)(& pamh));
#line 1202
  pam_retval = (int )tmp___0;
#line 1203
  if (pam_retval != 0) {
#line 1205
    tmp___1 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 1205
    log("PAM initialisation failed: %.200s", tmp___1);
#line 1206
    eat_packets_and_disconnect((char const   *)user);
  }
#line 1208
  fatal_add_cleanup(& pam_cleanup_proc, (void *)0);
#line 1213
  tmp___2 = getuid();
#line 1213
  if (tmp___2 != 0U) {
#line 1213
    tmp___3 = getuid();
#line 1213
    if (pw->pw_uid != tmp___3) {
#line 1214
      packet_disconnect("Cannot change user when server not running as root.");
    }
  }
#line 1216
  debug("Attempting authentication for %.100s.", user);
#line 1219
  if (options.password_authentication) {
#line 1219
    tmp___4 = auth_password(pw, "");
#line 1219
    if (tmp___4) {
#line 1226
      debug("Login for user %.100s accepted without authentication.", user);
#line 1228
      authenticated = 1;
    } else {
#line 1234
      packet_start(15);
#line 1235
      packet_send();
#line 1236
      packet_write_wait();
    }
  } else {
#line 1234
    packet_start(15);
#line 1235
    packet_send();
#line 1236
    packet_write_wait();
  }
#line 1240
  while (! authenticated) {
#line 1244
    type = packet_read(& plen);
#line 1247
    switch (type) {
    case 5: 
#line 1323
    if (! options.rhosts_authentication) {
#line 1325
      log("Rhosts authentication disabled.");
#line 1326
      break;
    }
#line 1330
    if (! privileged_port) {
#line 1332
      log("Rhosts authentication not available for connections from unprivileged port.");
#line 1333
      break;
    }
#line 1341
    client_user = packet_get_string((unsigned int *)(& dlen));
#line 1342
    while (1) {
#line 1342
      _p = plen;
#line 1342
      _e = 4 + dlen;
#line 1342
      if (_p != _e) {
#line 1342
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "sshd.c", 1342);
#line 1342
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1342
      break;
    }
#line 1346
    tmp___6 = auth_rhosts(pw, (char const   *)client_user, options.ignore_rhosts,
                          options.strict_modes);
#line 1346
    if (tmp___6) {
#line 1350
      tmp___5 = get_canonical_hostname();
#line 1350
      log("Rhosts authentication accepted for %.100s, remote %.100s on %.700s.", user,
          client_user, tmp___5);
#line 1352
      authenticated = 1;
#line 1356
      break;
    }
#line 1358
    log("Rhosts authentication failed for %.100s, remote %.100s.", user, client_user);
#line 1363
    break;
    case 35: 
#line 1366
    if (! options.rhosts_rsa_authentication) {
#line 1368
      log("Rhosts with RSA authentication disabled.");
#line 1369
      break;
    }
#line 1374
    if (! privileged_port) {
#line 1376
      log("Rhosts authentication not available for connections from unprivileged port.");
#line 1377
      break;
    }
#line 1385
    client_user = packet_get_string((unsigned int *)(& ulen));
#line 1388
    client_host_key_e = BN_new();
#line 1389
    client_host_key_n = BN_new();
#line 1390
    client_host_key_bits = packet_get_int();
#line 1391
    packet_get_bignum(client_host_key_e, & elen);
#line 1392
    packet_get_bignum(client_host_key_n, & nlen);
#line 1394
    while (1) {
#line 1394
      _p___0 = plen;
#line 1394
      _e___0 = (((4 + ulen) + 4) + elen) + nlen;
#line 1394
      if (_p___0 != _e___0) {
#line 1394
        log("Packet integrity error (%d != %d) at %s:%d", _p___0, _e___0, "sshd.c",
            1394);
#line 1394
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1394
      break;
    }
#line 1398
    tmp___7 = auth_rhosts_rsa(pw, (char const   *)client_user, client_host_key_bits,
                              client_host_key_e, client_host_key_n, options.ignore_rhosts,
                              options.strict_modes);
#line 1398
    if (tmp___7) {
#line 1404
      authenticated = 1;
#line 1408
      BN_clear_free(client_host_key_e);
#line 1409
      BN_clear_free(client_host_key_n);
#line 1410
      break;
    }
#line 1412
    log("Rhosts authentication failed for %.100s, remote %.100s.", user, client_user);
#line 1417
    BN_clear_free(client_host_key_e);
#line 1418
    BN_clear_free(client_host_key_n);
#line 1419
    break;
    case 6: 
#line 1422
    if (! options.rsa_authentication) {
#line 1424
      log("RSA authentication disabled.");
#line 1425
      break;
    }
#line 1432
    n___0 = BN_new();
#line 1433
    packet_get_bignum(n___0, & nlen___0);
#line 1435
    while (1) {
#line 1435
      _p___1 = plen;
#line 1435
      _e___1 = nlen___0;
#line 1435
      if (_p___1 != _e___1) {
#line 1435
        log("Packet integrity error (%d != %d) at %s:%d", _p___1, _e___1, "sshd.c",
            1435);
#line 1435
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1435
      break;
    }
#line 1437
    tmp___8 = auth_rsa(pw, n___0, options.strict_modes);
#line 1437
    if (tmp___8) {
#line 1440
      BN_clear_free(n___0);
#line 1441
      log("RSA authentication for %.100s accepted.", user);
#line 1442
      authenticated = 1;
#line 1443
      break;
    }
#line 1445
    BN_clear_free(n___0);
#line 1446
    log("RSA authentication for %.100s failed.", user);
#line 1448
    break;
    case 9: 
#line 1451
    if (! options.password_authentication) {
#line 1453
      log("Password authentication disabled.");
#line 1454
      break;
    }
#line 1463
    password = packet_get_string((unsigned int *)(& passw_len));
#line 1464
    while (1) {
#line 1464
      _p___2 = plen;
#line 1464
      _e___2 = 4 + passw_len;
#line 1464
      if (_p___2 != _e___2) {
#line 1464
        log("Packet integrity error (%d != %d) at %s:%d", _p___2, _e___2, "sshd.c",
            1464);
#line 1464
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1464
      break;
    }
#line 1468
    pampasswd = (char const   *)password;
#line 1470
    tmp___9 = pam_authenticate((pam_handle_t *)pamh, 0);
#line 1470
    pam_retval = (int )tmp___9;
#line 1471
    if (pam_retval == 0) {
#line 1473
      log("PAM Password authentication accepted for \"%.100s\"", user);
#line 1474
      authenticated = 1;
#line 1475
      break;
    } else {
#line 1478
      tmp___10 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 1478
      log("PAM Password authentication for \"%.100s\" failed: %s", user, tmp___10);
#line 1480
      break;
    }
    case 39: 
#line 1502
    log("TIS authentication disabled.");
#line 1503
    break;
    default: 
#line 1508
    log("Unknown message during authentication: type %d", type);
#line 1509
    break;
    }
#line 1512
    if (authenticated) {
#line 1513
      break;
    }
#line 1515
    authentication_failures ++;
#line 1515
    if (authentication_failures >= 5) {
#line 1516
      tmp___11 = get_canonical_hostname();
#line 1516
      packet_disconnect("Too many authentication failures for %.100s from %.200s",
                        pw->pw_name, tmp___11);
    }
#line 1521
    packet_start(15);
#line 1522
    packet_send();
#line 1523
    packet_write_wait();
  }
#line 1527
  if (pw->pw_uid == 0U) {
#line 1527
    if (! options.permit_root_login) {
#line 1529
      if (forced_command) {
#line 1530
        log("Root login accepted for forced command.");
      } else {
#line 1532
        tmp___12 = get_canonical_hostname();
#line 1532
        packet_disconnect("ROOT LOGIN REFUSED FROM %.200s", tmp___12);
      }
    }
  }
#line 1537
  tmp___13 = get_canonical_hostname();
#line 1537
  do_pam_account_and_session((char const   *)pw->pw_name, (char const   *)password,
                             (char const   *)client_user, tmp___13);
#line 1540
  if ((unsigned int )client_user != (unsigned int )((void *)0)) {
#line 1541
    xfree((void *)client_user);
  }
#line 1543
  if ((unsigned int )password != (unsigned int )((void *)0)) {
#line 1545
    tmp___14 = strlen((char const   *)password);
#line 1545
    memset((void *)password, 0, tmp___14);
#line 1546
    xfree((void *)password);
  }
#line 1551
  packet_start(14);
#line 1552
  packet_send();
#line 1553
  packet_write_wait();
#line 1556
  do_authenticated(pw);
#line 1557
  return;
}
}
#line 1561 "sshd.c"
void eat_packets_and_disconnect(char const   *user ) 
{ int authentication_failures ;
  int plen ;
  char const   *tmp ;

  {
#line 1563
  authentication_failures = 0;
#line 1565
  packet_start(15);
#line 1566
  packet_send();
#line 1567
  packet_write_wait();
#line 1571
  while (1) {
#line 1576
    packet_read(& plen);
#line 1593
    authentication_failures ++;
#line 1593
    if (authentication_failures >= 5) {
#line 1595
      tmp = get_canonical_hostname();
#line 1595
      packet_disconnect("Too many authentication failures for %.100s from %.200s",
                        user, tmp);
    }
#line 1600
    packet_start(15);
#line 1601
    packet_send();
#line 1602
    packet_write_wait();
  }
#line 1605
  abort();
}
}
#line 1613 "sshd.c"
void do_authenticated(struct passwd *pw ) 
{ int type ;
  int compression_level ;
  int enable_compression_after_reply ;
  int have_pty ;
  int ptyfd ;
  int ttyfd ;
  int xauthfd ;
  int row ;
  int col ;
  int xpixel ;
  int ypixel ;
  int screen ;
  char ttyname___0[64] ;
  char *command ;
  char *term ;
  char *display ;
  char *proto ;
  char *data ;
  struct group *grp ;
  gid_t tty_gid ;
  mode_t tty_mode ;
  int n_bytes ;
  int plen ;
  int dlen ;
  int _p ;
  int _e ;
  unsigned int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int _p___0 ;
  int _e___0 ;
  size_t tmp___7 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___13 ;
  int tmp___16 ;
  int tmp___17 ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;
  int _p___1 ;
  int _e___1 ;
  int proto_len ;
  int data_len ;
  int _p___2 ;
  int _e___2 ;
  unsigned int tmp___22 ;
  unsigned int tmp___23 ;
  void *tmp___24 ;
  int tmp___25 ;
  int _p___3 ;
  int _e___3 ;
  int tmp___26 ;
  int dlen___0 ;
  int _p___4 ;
  int _e___4 ;

  {
#line 1616
  compression_level = 0;
#line 1616
  enable_compression_after_reply = 0;
#line 1617
  have_pty = 0;
#line 1617
  ptyfd = -1;
#line 1617
  ttyfd = -1;
#line 1617
  xauthfd = -1;
#line 1620
  term = (char *)((void *)0);
#line 1620
  display = (char *)((void *)0);
#line 1620
  proto = (char *)((void *)0);
#line 1620
  data = (char *)((void *)0);
#line 1627
  alarm(0U);
#line 1634
  channel_permit_all_opens();
#line 1638
  while (1) {
#line 1643
    type = packet_read(& plen);
#line 1646
    switch (type) {
    case 37: 
#line 1649
    while (1) {
#line 1649
      _p = plen;
#line 1649
      _e = 4;
#line 1649
      if (_p != _e) {
#line 1649
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "sshd.c", 1649);
#line 1649
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1649
      break;
    }
#line 1650
    tmp = packet_get_int();
#line 1650
    compression_level = (int )tmp;
#line 1651
    if (compression_level < 1) {
#line 1653
      packet_send_debug("Received illegal compression level %d.", compression_level);
      goto fail;
    } else {
#line 1651
      if (compression_level > 9) {
#line 1653
        packet_send_debug("Received illegal compression level %d.", compression_level);
        goto fail;
      }
    }
#line 1658
    enable_compression_after_reply = 1;
#line 1659
    break;
    case 10: 
#line 1662
    if (no_pty_flag) {
#line 1664
      debug("Allocating a pty not permitted for this authentication.");
      goto fail;
    }
#line 1667
    if (have_pty) {
#line 1668
      packet_disconnect("Protocol error: you already have a pty.");
    }
#line 1670
    debug("Allocating pty.");
#line 1673
    tmp___0 = pty_allocate(& ptyfd, & ttyfd, ttyname___0);
#line 1673
    if (! tmp___0) {
#line 1675
      error("Failed to allocate pty.");
      goto fail;
    }
#line 1680
    grp = getgrnam("tty");
#line 1681
    if (grp) {
#line 1683
      tty_gid = grp->gr_gid;
#line 1684
      tty_mode = (unsigned int )(384 | (128 >> 3));
    } else {
#line 1688
      tty_gid = pw->pw_gid;
#line 1689
      tty_mode = (unsigned int )((384 | (128 >> 3)) | ((128 >> 3) >> 3));
    }
#line 1693
    tmp___3 = chown((char const   *)(ttyname___0), pw->pw_uid, tty_gid);
#line 1693
    if (tmp___3 < 0) {
#line 1694
      tmp___1 = __errno_location();
#line 1694
      tmp___2 = strerror(*tmp___1);
#line 1694
      fatal("chown(%.100s, %d, %d) failed: %.100s", ttyname___0, pw->pw_uid, tty_gid,
            tmp___2);
    }
#line 1696
    tmp___6 = chmod((char const   *)(ttyname___0), tty_mode);
#line 1696
    if (tmp___6 < 0) {
#line 1697
      tmp___4 = __errno_location();
#line 1697
      tmp___5 = strerror(*tmp___4);
#line 1697
      fatal("chmod(%.100s, 0%o) failed: %.100s", ttyname___0, tty_mode, tmp___5);
    }
#line 1703
    term = packet_get_string((unsigned int *)(& dlen));
#line 1704
    while (1) {
#line 1704
      _p___0 = dlen;
#line 1704
      tmp___7 = strlen((char const   *)term);
#line 1704
      _e___0 = (int )tmp___7;
#line 1704
      if (_p___0 != _e___0) {
#line 1704
        log("Packet integrity error (%d != %d) at %s:%d", _p___0, _e___0, "sshd.c",
            1704);
#line 1704
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1704
      break;
    }
#line 1707
    n_bytes = plen - ((4 + dlen) + 16);
#line 1709
    if (0) {
#line 1709
      __s1_len = strlen((char const   *)term);
#line 1709
      __s2_len = strlen("");
#line 1709
      if (! ((unsigned int )((void const   *)(term + 1)) - (unsigned int )((void const   *)term) == 1U)) {
        goto _L___0;
      } else {
#line 1709
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 1709
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 1709
            tmp___17 = 1;
          } else {
#line 1709
            if (__s2_len >= 4U) {
#line 1709
              tmp___17 = 1;
            } else {
#line 1709
              tmp___17 = 0;
            }
          }
        } else {
#line 1709
          tmp___17 = 0;
        }
      }
#line 1709
      if (tmp___17) {
#line 1709
        tmp___13 = __builtin_strcmp((char const   *)term, "");
      } else {
#line 1709
        tmp___16 = __builtin_strcmp((char const   *)term, "");
#line 1709
        tmp___13 = tmp___16;
      }
    } else {
#line 1709
      tmp___16 = __builtin_strcmp((char const   *)term, "");
#line 1709
      tmp___13 = tmp___16;
    }
#line 1709
    if (tmp___13 == 0) {
#line 1710
      term = (char *)((void *)0);
    }
#line 1713
    tmp___18 = packet_get_int();
#line 1713
    row = (int )tmp___18;
#line 1714
    tmp___19 = packet_get_int();
#line 1714
    col = (int )tmp___19;
#line 1715
    tmp___20 = packet_get_int();
#line 1715
    xpixel = (int )tmp___20;
#line 1716
    tmp___21 = packet_get_int();
#line 1716
    ypixel = (int )tmp___21;
#line 1717
    pty_change_window_size(ptyfd, row, col, xpixel, ypixel);
#line 1720
    tty_parse_modes(ttyfd, & n_bytes);
#line 1721
    while (1) {
#line 1721
      _p___1 = plen;
#line 1721
      _e___1 = ((4 + dlen) + 16) + n_bytes;
#line 1721
      if (_p___1 != _e___1) {
#line 1721
        log("Packet integrity error (%d != %d) at %s:%d", _p___1, _e___1, "sshd.c",
            1721);
#line 1721
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1721
      break;
    }
#line 1724
    have_pty = 1;
#line 1725
    break;
    case 34: 
#line 1728
    if (! options.x11_forwarding) {
#line 1730
      packet_send_debug("X11 forwarding disabled in server configuration file.");
      goto fail;
    }
#line 1734
    if (no_x11_forwarding_flag) {
#line 1736
      packet_send_debug("X11 forwarding not permitted for this authentication.");
      goto fail;
    }
#line 1739
    debug("Received request for X11 forwarding with auth spoofing.");
#line 1740
    if (display) {
#line 1741
      packet_disconnect("Protocol error: X11 display already set.");
    }
#line 1744
    proto = packet_get_string((unsigned int *)(& proto_len));
#line 1745
    data = packet_get_string((unsigned int *)(& data_len));
#line 1746
    while (1) {
#line 1746
      _p___2 = plen;
#line 1746
      _e___2 = (((4 + proto_len) + 4) + data_len) + 4;
#line 1746
      if (_p___2 != _e___2) {
#line 1746
        log("Packet integrity error (%d != %d) at %s:%d", _p___2, _e___2, "sshd.c",
            1746);
#line 1746
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1746
      break;
    }
#line 1748
    tmp___23 = packet_get_protocol_flags();
#line 1748
    if (tmp___23 & 1U) {
#line 1749
      tmp___22 = packet_get_int();
#line 1749
      screen = (int )tmp___22;
    } else {
#line 1751
      screen = 0;
    }
#line 1752
    display = x11_create_display_inet(screen);
#line 1753
    if (! display) {
      goto fail;
    }
#line 1757
    tmp___24 = xmalloc(4096U);
#line 1757
    xauthfile = (char *)tmp___24;
#line 1758
    snprintf((char * __restrict  )xauthfile, 4096U, (char const   * __restrict  )"/tmp/XauthXXXXXX");
#line 1760
    xauthfd = mkstemp(xauthfile);
#line 1760
    if (xauthfd != -1) {
#line 1761
      fchown(xauthfd, pw->pw_uid, pw->pw_gid);
#line 1762
      close(xauthfd);
    } else {
#line 1765
      xfree((void *)xauthfile);
#line 1766
      xauthfile = (char *)((void *)0);
    }
#line 1768
    break;
    case 30: 
#line 1776
    if (no_agent_forwarding_flag) {
#line 1778
      debug("Authentication agent forwarding not permitted for this authentication.");
      goto fail;
    }
#line 1781
    debug("Received authentication agent forwarding request.");
#line 1782
    auth_input_request_forwarding(pw);
#line 1783
    break;
    case 28: 
#line 1786
    if (no_port_forwarding_flag) {
#line 1788
      debug("Port forwarding not permitted for this authentication.");
      goto fail;
    }
#line 1791
    debug("Received TCP/IP port forwarding request.");
#line 1792
    channel_input_port_forward_request(pw->pw_uid == 0U);
#line 1793
    break;
    case 12: 
#line 1797
    if (have_pty) {
#line 1797
      tmp___25 = 1;
    } else {
#line 1797
      if ((unsigned int )display != (unsigned int )((void *)0)) {
#line 1797
        tmp___25 = 1;
      } else {
#line 1797
        tmp___25 = 0;
      }
    }
#line 1797
    packet_set_interactive(tmp___25, options.keepalives);
#line 1800
    if ((unsigned int )forced_command != (unsigned int )((void *)0)) {
      goto do_forced_command;
    }
#line 1802
    debug("Forking shell.");
#line 1803
    while (1) {
#line 1803
      _p___3 = plen;
#line 1803
      _e___3 = 0;
#line 1803
      if (_p___3 != _e___3) {
#line 1803
        log("Packet integrity error (%d != %d) at %s:%d", _p___3, _e___3, "sshd.c",
            1803);
#line 1803
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1803
      break;
    }
#line 1804
    if (have_pty) {
#line 1805
      do_exec_pty((char const   *)((void *)0), ptyfd, ttyfd, (char const   *)(ttyname___0),
                  pw, (char const   *)term, (char const   *)display, (char const   *)proto,
                  (char const   *)data);
    } else {
#line 1808
      do_exec_no_pty((char const   *)((void *)0), pw, (char const   *)display, (char const   *)proto,
                     (char const   *)data);
    }
#line 1809
    return;
    case 13: 
#line 1813
    if (have_pty) {
#line 1813
      tmp___26 = 1;
    } else {
#line 1813
      if ((unsigned int )display != (unsigned int )((void *)0)) {
#line 1813
        tmp___26 = 1;
      } else {
#line 1813
        tmp___26 = 0;
      }
    }
#line 1813
    packet_set_interactive(tmp___26, options.keepalives);
#line 1816
    if ((unsigned int )forced_command != (unsigned int )((void *)0)) {
      goto do_forced_command;
    }
#line 1821
    command = packet_get_string((unsigned int *)(& dlen___0));
#line 1822
    debug("Executing command \'%.500s\'", command);
#line 1823
    while (1) {
#line 1823
      _p___4 = plen;
#line 1823
      _e___4 = 4 + dlen___0;
#line 1823
      if (_p___4 != _e___4) {
#line 1823
        log("Packet integrity error (%d != %d) at %s:%d", _p___4, _e___4, "sshd.c",
            1823);
#line 1823
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1823
      break;
    }
#line 1825
    if (have_pty) {
#line 1826
      do_exec_pty((char const   *)command, ptyfd, ttyfd, (char const   *)(ttyname___0),
                  pw, (char const   *)term, (char const   *)display, (char const   *)proto,
                  (char const   *)data);
    } else {
#line 1829
      do_exec_no_pty((char const   *)command, pw, (char const   *)display, (char const   *)proto,
                     (char const   *)data);
    }
#line 1830
    xfree((void *)command);
#line 1831
    return;
    case 38: 
#line 1834
    debug("The server does not support limiting packet size.");
    goto fail;
    default: 
#line 1840
    log("Unknown packet type received after authentication: %d", type);
    goto fail;
    }
#line 1845
    packet_start(14);
#line 1846
    packet_send();
#line 1847
    packet_write_wait();
#line 1850
    if (enable_compression_after_reply) {
#line 1852
      enable_compression_after_reply = 0;
#line 1853
      packet_start_compression(compression_level);
    }
#line 1856
    continue;
    fail: 
#line 1860
    packet_start(15);
#line 1861
    packet_send();
#line 1862
    packet_write_wait();
#line 1863
    continue;
    do_forced_command: 
#line 1867
    debug("Executing forced command: %.900s", forced_command);
#line 1868
    if (have_pty) {
#line 1869
      do_exec_pty((char const   *)forced_command, ptyfd, ttyfd, (char const   *)(ttyname___0),
                  pw, (char const   *)term, (char const   *)display, (char const   *)proto,
                  (char const   *)data);
    } else {
#line 1872
      do_exec_no_pty((char const   *)forced_command, pw, (char const   *)display,
                     (char const   *)proto, (char const   *)data);
    }
#line 1873
    return;
  }
}
}
#line 1881 "sshd.c"
void do_exec_no_pty(char const   *command , struct passwd *pw , char const   *display ,
                    char const   *auth_proto , char const   *auth_data ) 
{ int pid ;
  int pin[2] ;
  int pout[2] ;
  int perr[2] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  __pid_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;

  {
#line 1890
  tmp___1 = pipe((int *)(pin));
#line 1890
  if (tmp___1 < 0) {
#line 1891
    tmp = __errno_location();
#line 1891
    tmp___0 = strerror(*tmp);
#line 1891
    packet_disconnect("Could not create pipes: %.100s", tmp___0);
  } else {
#line 1890
    tmp___2 = pipe((int *)(pout));
#line 1890
    if (tmp___2 < 0) {
#line 1891
      tmp = __errno_location();
#line 1891
      tmp___0 = strerror(*tmp);
#line 1891
      packet_disconnect("Could not create pipes: %.100s", tmp___0);
    } else {
#line 1890
      tmp___3 = pipe((int *)(perr));
#line 1890
      if (tmp___3 < 0) {
#line 1891
        tmp = __errno_location();
#line 1891
        tmp___0 = strerror(*tmp);
#line 1891
        packet_disconnect("Could not create pipes: %.100s", tmp___0);
      }
    }
  }
#line 1902
  setproctitle("%s@notty", pw->pw_name);
#line 1905
  pid = fork();
#line 1905
  if (pid == 0) {
#line 1908
    if (debug_flag) {
#line 1908
      if (! inetd_flag) {
#line 1908
        tmp___4 = 1;
      } else {
#line 1908
        tmp___4 = 0;
      }
    } else {
#line 1908
      tmp___4 = 0;
    }
#line 1908
    log_init(av0, tmp___4, debug_flag, options.quiet_mode, options.log_facility);
#line 1913
    tmp___7 = setsid();
#line 1913
    if (tmp___7 < 0) {
#line 1914
      tmp___5 = __errno_location();
#line 1914
      tmp___6 = strerror(*tmp___5);
#line 1914
      error("setsid failed: %.100s", tmp___6);
    }
#line 1919
    close(pin[1]);
#line 1920
    tmp___8 = dup2(pin[0], 0);
#line 1920
    if (tmp___8 < 0) {
#line 1921
      perror("dup2 stdin");
    }
#line 1922
    close(pin[0]);
#line 1925
    close(pout[0]);
#line 1926
    tmp___9 = dup2(pout[1], 1);
#line 1926
    if (tmp___9 < 0) {
#line 1927
      perror("dup2 stdout");
    }
#line 1928
    close(pout[1]);
#line 1931
    close(perr[0]);
#line 1932
    tmp___10 = dup2(perr[1], 2);
#line 1932
    if (tmp___10 < 0) {
#line 1933
      perror("dup2 stderr");
    }
#line 1934
    close(perr[1]);
#line 1950
    do_child(command, pw, (char const   *)((void *)0), display, auth_proto, auth_data,
             (char const   *)((void *)0));
  }
#line 1953
  if (pid < 0) {
#line 1954
    tmp___11 = __errno_location();
#line 1954
    tmp___12 = strerror(*tmp___11);
#line 1954
    packet_disconnect("fork failed: %.100s", tmp___12);
  }
#line 1957
  close(pin[0]);
#line 1958
  close(pout[1]);
#line 1959
  close(perr[1]);
#line 1962
  server_loop(pid, pin[1], pout[0], perr[0]);
#line 1974
  return;
}
}
#line 1985 "sshd.c"
void pty_cleanup_proc(void *context ) 
{ struct pty_cleanup_context *cu ;

  {
#line 1987
  cu = (struct pty_cleanup_context *)context;
#line 1989
  debug("pty_cleanup_proc called");
#line 1997
  record_logout(cu->pid, cu->ttyname);
#line 2000
  pty_release(cu->ttyname);
#line 2001
  return;
}
}
#line 2008 "sshd.c"
void do_exec_pty(char const   *command , int ptyfd , int ttyfd , char const   *ttyname___0 ,
                 struct passwd *pw , char const   *term , char const   *display ,
                 char const   *auth_proto , char const   *auth_data ) 
{ int pid ;
  int fdout___0 ;
  char const   *hostname ;
  time_t last_login_time ;
  char buf[100] ;
  char *time_string ;
  FILE *f ;
  char line[256] ;
  struct stat st ;
  int quiet_login ;
  struct sockaddr_in from ;
  int fromlen ;
  struct pty_cleanup_context cleanup_context ;
  unsigned long tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char *tmp___22 ;
  char *tmp___24 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___30 ;
  int tmp___33 ;
  int tmp___34 ;
  char *tmp___35 ;
  int *tmp___36 ;
  char *tmp___37 ;
  int *tmp___38 ;
  char *tmp___39 ;

  {
#line 2026
  hostname = get_canonical_hostname();
#line 2030
  if (! options.use_login) {
#line 2031
    tmp = get_last_login_time(pw->pw_uid, (char const   *)pw->pw_name, buf, sizeof(buf));
#line 2031
    last_login_time = (long )tmp;
  }
#line 2035
  tmp___0 = strrchr(ttyname___0, '/');
#line 2035
  setproctitle("%s@%s", pw->pw_name, tmp___0 + 1);
#line 2038
  pid = fork();
#line 2038
  if (pid == 0) {
#line 2040
    pid = getpid();
#line 2043
    if (debug_flag) {
#line 2043
      if (! inetd_flag) {
#line 2043
        tmp___1 = 1;
      } else {
#line 2043
        tmp___1 = 0;
      }
    } else {
#line 2043
      tmp___1 = 0;
    }
#line 2043
    log_init(av0, tmp___1, debug_flag, options.quiet_mode, options.log_facility);
#line 2047
    close(ptyfd);
#line 2050
    pty_make_controlling_tty(& ttyfd, ttyname___0);
#line 2053
    tmp___4 = fileno(stdin);
#line 2053
    tmp___5 = dup2(ttyfd, tmp___4);
#line 2053
    if (tmp___5 < 0) {
#line 2054
      tmp___2 = __errno_location();
#line 2054
      tmp___3 = strerror(*tmp___2);
#line 2054
      error("dup2 stdin failed: %.100s", tmp___3);
    }
#line 2057
    tmp___8 = fileno(stdout);
#line 2057
    tmp___9 = dup2(ttyfd, tmp___8);
#line 2057
    if (tmp___9 < 0) {
#line 2058
      tmp___6 = __errno_location();
#line 2058
      tmp___7 = strerror(*tmp___6);
#line 2058
      error("dup2 stdin failed: %.100s", tmp___7);
    }
#line 2061
    tmp___12 = fileno(stderr);
#line 2061
    tmp___13 = dup2(ttyfd, tmp___12);
#line 2061
    if (tmp___13 < 0) {
#line 2062
      tmp___10 = __errno_location();
#line 2062
      tmp___11 = strerror(*tmp___10);
#line 2062
      error("dup2 stdin failed: %.100s", tmp___11);
    }
#line 2065
    close(ttyfd);
#line 2070
    memset((void *)(& from), 0, sizeof(from));
#line 2071
    tmp___18 = packet_get_connection_in();
#line 2071
    tmp___19 = packet_get_connection_out();
#line 2071
    if (tmp___18 == tmp___19) {
#line 2073
      fromlen = (int )sizeof(from);
#line 2074
      tmp___16 = packet_get_connection_in();
#line 2074
      tmp___17 = getpeername(tmp___16, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                             (socklen_t * __restrict  )(& fromlen));
#line 2074
      if (tmp___17 < 0) {
#line 2076
        tmp___14 = __errno_location();
#line 2076
        tmp___15 = strerror(*tmp___14);
#line 2076
        fatal("getpeername: %.100s", tmp___15);
      }
    }
#line 2080
    record_login(pid, ttyname___0, (char const   *)pw->pw_name, pw->pw_uid, hostname,
                 & from);
#line 2084
    snprintf((char * __restrict  )(line), sizeof(line), (char const   * __restrict  )"%.200s/.hushlogin",
             pw->pw_dir);
#line 2085
    tmp___20 = stat((char const   * __restrict  )(line), (struct stat * __restrict  )(& st));
#line 2085
    quiet_login = tmp___20 >= 0;
#line 2089
    if (! quiet_login) {
#line 2089
      if ((unsigned int )pamconv_msg != (unsigned int )((void *)0)) {
#line 2090
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )pamconv_msg);
      }
    }
#line 2098
    if ((unsigned int )command == (unsigned int )((void *)0)) {
#line 2098
      if (last_login_time != 0L) {
#line 2098
        if (! quiet_login) {
#line 2098
          if (! options.use_login) {
#line 2102
            time_string = ctime((time_t const   *)(& last_login_time));
#line 2104
            tmp___24 = __builtin_strchr(time_string, '\n');
#line 2104
            if (tmp___24) {
#line 2105
              tmp___22 = __builtin_strchr(time_string, '\n');
#line 2105
              *tmp___22 = (char)0;
            }
#line 2107
            if (0) {
#line 2107
              __s1_len = strlen((char const   *)(buf));
#line 2107
              __s2_len = strlen("");
#line 2107
              if (! ((unsigned int )((void const   *)(buf + 1)) - (unsigned int )((void const   *)(buf)) == 1U)) {
                goto _L___0;
              } else {
#line 2107
                if (__s1_len >= 4U) {
                  _L___0: /* CIL Label */ 
#line 2107
                  if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 2107
                    tmp___34 = 1;
                  } else {
#line 2107
                    if (__s2_len >= 4U) {
#line 2107
                      tmp___34 = 1;
                    } else {
#line 2107
                      tmp___34 = 0;
                    }
                  }
                } else {
#line 2107
                  tmp___34 = 0;
                }
              }
#line 2107
              if (tmp___34) {
#line 2107
                tmp___30 = __builtin_strcmp((char const   *)(buf), "");
              } else {
#line 2107
                tmp___33 = __builtin_strcmp((char const   *)(buf), "");
#line 2107
                tmp___30 = tmp___33;
              }
            } else {
#line 2107
              tmp___33 = __builtin_strcmp((char const   *)(buf), "");
#line 2107
              tmp___30 = tmp___33;
            }
#line 2107
            if (tmp___30 == 0) {
#line 2108
              printf((char const   * __restrict  )"Last login: %s\r\n", time_string);
            } else {
#line 2110
              printf((char const   * __restrict  )"Last login: %s from %s\r\n", time_string,
                     buf);
            }
          }
        }
      }
    }
#line 2116
    if ((unsigned int )command == (unsigned int )((void *)0)) {
#line 2116
      if (options.print_motd) {
#line 2116
        if (! quiet_login) {
#line 2116
          if (! options.use_login) {
#line 2120
            f = fopen((char const   * __restrict  )"/etc/motd", (char const   * __restrict  )"r");
#line 2121
            if (f) {
#line 2123
              while (1) {
#line 2123
                tmp___35 = fgets((char * __restrict  )(line), (int )sizeof(line),
                                 (FILE * __restrict  )f);
#line 2123
                if (! tmp___35) {
#line 2123
                  break;
                }
#line 2124
                fputs((char const   * __restrict  )(line), (FILE * __restrict  )stdout);
              }
#line 2125
              fclose(f);
            }
          }
        }
      }
    }
#line 2130
    do_child(command, pw, term, display, auth_proto, auth_data, ttyname___0);
  }
#line 2133
  if (pid < 0) {
#line 2134
    tmp___36 = __errno_location();
#line 2134
    tmp___37 = strerror(*tmp___36);
#line 2134
    packet_disconnect("fork failed: %.100s", tmp___37);
  }
#line 2136
  close(ttyfd);
#line 2141
  fdout___0 = dup(ptyfd);
#line 2142
  if (fdout___0 < 0) {
#line 2143
    tmp___38 = __errno_location();
#line 2143
    tmp___39 = strerror(*tmp___38);
#line 2143
    packet_disconnect("dup failed: %.100s", tmp___39);
  }
#line 2147
  cleanup_context.pid = pid;
#line 2148
  cleanup_context.ttyname = ttyname___0;
#line 2149
  fatal_add_cleanup(& pty_cleanup_proc, (void *)(& cleanup_context));
#line 2152
  server_loop(pid, ptyfd, fdout___0, -1);
#line 2156
  fatal_remove_cleanup(& pty_cleanup_proc, (void *)(& cleanup_context));
#line 2159
  record_logout(pid, ttyname___0);
#line 2162
  pty_release(ttyname___0);
#line 2167
  close(ptyfd);
#line 2168
  close(fdout___0);
#line 2169
  return;
}
}
#line 2174 "sshd.c"
void child_set_env(char ***envp , unsigned int *envsizep , char const   *name , char const   *value ) 
{ unsigned int i ;
  unsigned int namelen ;
  char **env ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  void *tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  void *tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;

  {
#line 2183
  env = *envp;
#line 2184
  namelen = strlen(name);
#line 2185
  i = 0U;
#line 2185
  while (*(env + i)) {
#line 2186
    if (0) {
#line 2186
      if (0) {
#line 2186
        __s1_len___0 = strlen((char const   *)*(env + i));
#line 2186
        __s2_len___0 = strlen(name);
#line 2186
        if (! ((unsigned int )((void const   *)(*(env + i) + 1)) - (unsigned int )((void const   *)*(env + i)) == 1U)) {
          goto _L___2;
        } else {
#line 2186
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 2186
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
#line 2186
              tmp___22 = 1;
            } else {
#line 2186
              if (__s2_len___0 >= 4U) {
#line 2186
                tmp___22 = 1;
              } else {
#line 2186
                tmp___22 = 0;
              }
            }
          } else {
#line 2186
            tmp___22 = 0;
          }
        }
#line 2186
        if (tmp___22) {
#line 2186
          tmp___18 = __builtin_strcmp((char const   *)*(env + i), name);
        } else {
#line 2186
          tmp___21 = __builtin_strcmp((char const   *)*(env + i), name);
#line 2186
          tmp___18 = tmp___21;
        }
      } else {
#line 2186
        tmp___21 = __builtin_strcmp((char const   *)*(env + i), name);
#line 2186
        tmp___18 = tmp___21;
      }
#line 2186
      tmp___12 = tmp___18;
    } else {
#line 2186
      tmp___12 = strncmp((char const   *)*(env + i), name, namelen);
    }
#line 2186
    if (tmp___12 == 0) {
#line 2186
      if ((int )*(*(env + i) + namelen) == 61) {
#line 2187
        break;
      }
    }
#line 2185
    i ++;
  }
#line 2188
  if (*(env + i)) {
#line 2191
    xfree((void *)*(env + i));
  } else {
#line 2196
    if (i >= *envsizep - 1U) {
#line 2198
      *envsizep += 50U;
#line 2199
      tmp___25 = xrealloc((void *)env, *envsizep * sizeof(char *));
#line 2199
      *envp = (char **)tmp___25;
#line 2199
      env = *envp;
    }
#line 2204
    *(env + (i + 1U)) = (char *)((void *)0);
  }
#line 2208
  tmp___26 = strlen(name);
#line 2208
  tmp___27 = strlen(value);
#line 2208
  tmp___28 = xmalloc(((tmp___26 + 1U) + tmp___27) + 1U);
#line 2208
  *(env + i) = (char *)tmp___28;
#line 2209
  tmp___29 = strlen(name);
#line 2209
  tmp___30 = strlen(value);
#line 2209
  snprintf((char * __restrict  )*(env + i), ((tmp___29 + 1U) + tmp___30) + 1U, (char const   * __restrict  )"%s=%s",
           name, value);
#line 2210
  return;
}
}
#line 2217 "sshd.c"
void read_environment_file(char ***env , unsigned int *envsize , char const   *filename ) 
{ FILE *f ;
  char buf[4096] ;
  char *cp ;
  char *value ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 2225
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 2226
  if (! f) {
#line 2227
    return;
  }
#line 2230
  while (1) {
#line 2230
    tmp___5 = fgets((char * __restrict  )(buf), (int )sizeof(buf), (FILE * __restrict  )f);
#line 2230
    if (! tmp___5) {
#line 2230
      break;
    }
#line 2233
    cp = buf;
#line 2233
    while (1) {
#line 2233
      if (! ((int )*cp == 32)) {
#line 2233
        if (! ((int )*cp == 9)) {
#line 2233
          break;
        }
      }
#line 2233
      cp ++;
    }
#line 2237
    if (! *cp) {
#line 2238
      continue;
    } else {
#line 2237
      if ((int )*cp == 35) {
#line 2238
        continue;
      } else {
#line 2237
        if ((int )*cp == 10) {
#line 2238
          continue;
        }
      }
    }
#line 2241
    tmp___2 = __builtin_strchr(cp, '\n');
#line 2241
    if (tmp___2) {
#line 2242
      tmp___0 = __builtin_strchr(cp, '\n');
#line 2242
      *tmp___0 = (char )'\000';
    }
#line 2245
    tmp___4 = __builtin_strchr(cp, '=');
#line 2245
    value = tmp___4;
#line 2246
    if ((unsigned int )value == (unsigned int )((void *)0)) {
#line 2248
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad line in %.100s: %.200s\n",
              filename, buf);
#line 2249
      continue;
    }
#line 2254
    *value = (char )'\000';
#line 2255
    value ++;
#line 2258
    child_set_env(env, envsize, (char const   *)cp, (char const   *)value);
  }
#line 2261
  fclose(f);
#line 2262
  return;
}
}
#line 2277
extern char **environ ;
#line 2268 "sshd.c"
void do_child(char const   *command , struct passwd *pw , char const   *term , char const   *display ,
              char const   *auth_proto , char const   *auth_data , char const   *ttyname___0 ) 
{ char const   *shell ;
  char const   *cp ;
  char buf[256] ;
  FILE *f ;
  unsigned int envsize ;
  unsigned int i ;
  char **env ;
  struct stat st ;
  char *argv[10] ;
  int tmp ;
  int tmp___0 ;
  __uid_t tmp___1 ;
  __uid_t tmp___2 ;
  __uid_t tmp___3 ;
  __uid_t tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  struct envstring *ce ;
  char *s ;
  int i___0 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char *equal_sign ;
  char var_name[256] ;
  char var_val[256] ;
  long this_var ;
  char **pam_env ;
  char ** __attribute__((__nonnull__(1))) tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  char buf___0[256] ;
  char *mailbox ;
  struct stat mailstat ;
  int tmp___25 ;
  char const   *tmp___26 ;

  {
#line 2272
  cp = (char const   *)((void *)0);
#line 2297
  if (! options.use_login) {
#line 2298
    tmp___1 = getuid();
#line 2298
    if (tmp___1 == 0U) {
      goto _L;
    } else {
#line 2298
      tmp___2 = geteuid();
#line 2298
      if (tmp___2 == 0U) {
        _L: /* CIL Label */ 
#line 2300
        tmp = setgid(pw->pw_gid);
#line 2300
        if (tmp < 0) {
#line 2302
          perror("setgid");
#line 2303
          exit(1);
        }
#line 2306
        tmp___0 = initgroups((char const   *)pw->pw_name, pw->pw_gid);
#line 2306
        if (tmp___0 < 0) {
#line 2308
          perror("initgroups");
#line 2309
          exit(1);
        }
#line 2311
        endgrent();
#line 2314
        permanently_set_uid(pw->pw_uid);
      }
    }
#line 2317
    tmp___3 = getuid();
#line 2317
    if (tmp___3 != pw->pw_uid) {
#line 2318
      fatal("Failed to set uids to %d.", (int )pw->pw_uid);
    } else {
#line 2317
      tmp___4 = geteuid();
#line 2317
      if (tmp___4 != pw->pw_uid) {
#line 2318
        fatal("Failed to set uids to %d.", (int )pw->pw_uid);
      }
    }
  }
#line 2323
  if ((int )*(pw->pw_shell + 0) == 0) {
#line 2323
    shell = "/bin/sh";
  } else {
#line 2323
    shell = (char const   *)pw->pw_shell;
  }
#line 2339
  envsize = 100U;
#line 2340
  tmp___5 = xmalloc(envsize * sizeof(char *));
#line 2340
  env = (char **)tmp___5;
#line 2341
  *(env + 0) = (char *)((void *)0);
#line 2343
  if (! options.use_login) {
#line 2345
    child_set_env(& env, & envsize, "USER", (char const   *)pw->pw_name);
#line 2346
    child_set_env(& env, & envsize, "LOGNAME", (char const   *)pw->pw_name);
#line 2347
    child_set_env(& env, & envsize, "HOME", (char const   *)pw->pw_dir);
#line 2348
    child_set_env(& env, & envsize, "PATH", "/usr/bin:/bin:/usr/sbin:/sbin");
#line 2350
    snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%.200s/%.50s",
             "/var/mail", pw->pw_name);
#line 2352
    child_set_env(& env, & envsize, "MAIL", (char const   *)(buf));
#line 2355
    child_set_env(& env, & envsize, "SHELL", shell);
  }
#line 2359
  tmp___7 = getenv("TZ");
#line 2359
  if (tmp___7) {
#line 2360
    tmp___6 = getenv("TZ");
#line 2360
    child_set_env(& env, & envsize, "TZ", (char const   *)tmp___6);
  }
#line 2363
  while (custom_environment) {
#line 2365
    ce = custom_environment;
#line 2366
    s = ce->s;
#line 2368
    i___0 = 0;
#line 2368
    while (1) {
#line 2368
      if ((int )*(s + i___0) != 61) {
#line 2368
        if (! *(s + i___0)) {
#line 2368
          break;
        }
      } else {
#line 2368
        break;
      }
#line 2368
      i___0 ++;
    }
#line 2370
    if ((int )*(s + i___0) == 61) {
#line 2372
      *(s + i___0) = (char)0;
#line 2373
      child_set_env(& env, & envsize, (char const   *)s, (char const   *)((s + i___0) + 1));
    }
#line 2375
    custom_environment = ce->next;
#line 2376
    xfree((void *)ce->s);
#line 2377
    xfree((void *)ce);
  }
#line 2381
  tmp___8 = get_remote_port();
#line 2381
  tmp___9 = get_remote_ipaddr();
#line 2381
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%.50s %d %d",
           tmp___9, tmp___8, options.port);
#line 2383
  child_set_env(& env, & envsize, "SSH_CLIENT", (char const   *)(buf));
#line 2386
  if (ttyname___0) {
#line 2387
    child_set_env(& env, & envsize, "SSH_TTY", ttyname___0);
  }
#line 2390
  if (term) {
#line 2391
    child_set_env(& env, & envsize, "TERM", term);
  }
#line 2394
  if (display) {
#line 2395
    child_set_env(& env, & envsize, "DISPLAY", display);
  }
#line 2407
  tmp___10 = pam_getenvlist((pam_handle_t *)pamh);
#line 2407
  pam_env = (char **)tmp___10;
#line 2408
  this_var = 0L;
#line 2408
  while (1) {
#line 2408
    if (pam_env) {
#line 2408
      if (! *(pam_env + this_var)) {
#line 2408
        break;
      }
    } else {
#line 2408
      break;
    }
#line 2410
    tmp___11 = strlen((char const   *)*(pam_env + this_var));
#line 2410
    if (tmp___11 < sizeof(var_name) - 1U) {
#line 2411
      equal_sign = strstr((char const   *)*(pam_env + this_var), "=");
#line 2411
      if ((unsigned int )equal_sign != (unsigned int )((void *)0)) {
#line 2413
        memset((void *)(var_name), 0, sizeof(var_name));
#line 2414
        memset((void *)(var_val), 0, sizeof(var_val));
#line 2415
        __builtin_strncpy(var_name, (char const   *)*(pam_env + this_var), (unsigned int )(equal_sign - *(pam_env + this_var)));
#line 2417
        strcpy((char * __restrict  )(var_val), (char const   * __restrict  )(equal_sign + 1));
#line 2418
        child_set_env(& env, & envsize, (char const   *)(var_name), (char const   *)(var_val));
      }
    }
#line 2408
    this_var ++;
  }
#line 2425
  if (xauthfile) {
#line 2426
    child_set_env(& env, & envsize, "XAUTHORITY", (char const   *)xauthfile);
  }
#line 2429
  tmp___13 = auth_get_socket_name();
#line 2429
  if ((unsigned int )tmp___13 != (unsigned int )((void *)0)) {
#line 2430
    tmp___12 = auth_get_socket_name();
#line 2430
    child_set_env(& env, & envsize, "SSH_AUTH_SOCK", (char const   *)tmp___12);
  }
#line 2434
  if (! options.use_login) {
#line 2435
    snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%.200s/.ssh/environment",
             pw->pw_dir);
#line 2436
    read_environment_file(& env, & envsize, (char const   *)(buf));
  }
#line 2440
  if (debug_flag) {
#line 2442
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Environment:\n");
#line 2443
    i = 0U;
#line 2443
    while (*(env + i)) {
#line 2444
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  %.200s\n",
              *(env + i));
#line 2443
      i ++;
    }
  }
#line 2451
  tmp___17 = packet_get_connection_in();
#line 2451
  tmp___18 = packet_get_connection_out();
#line 2451
  if (tmp___17 == tmp___18) {
#line 2452
    tmp___14 = packet_get_connection_in();
#line 2452
    close(tmp___14);
  } else {
#line 2455
    tmp___15 = packet_get_connection_in();
#line 2455
    close(tmp___15);
#line 2456
    tmp___16 = packet_get_connection_out();
#line 2456
    close(tmp___16);
  }
#line 2460
  channel_close_all();
#line 2464
  endpwent();
#line 2465
  endhostent();
#line 2471
  i = 3U;
#line 2471
  while (i < 64U) {
#line 2472
    close((int )i);
#line 2471
    i ++;
  }
#line 2475
  tmp___21 = chdir((char const   *)pw->pw_dir);
#line 2475
  if (tmp___21 < 0) {
#line 2476
    tmp___19 = __errno_location();
#line 2476
    tmp___20 = strerror(*tmp___19);
#line 2476
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not chdir to home directory %s: %s\n",
            pw->pw_dir, tmp___20);
  }
#line 2481
  environ = env;
#line 2485
  if (! options.use_login) {
#line 2486
    tmp___23 = stat((char const   * __restrict  )".ssh/rc", (struct stat * __restrict  )(& st));
#line 2486
    if (tmp___23 >= 0) {
#line 2488
      if (debug_flag) {
#line 2489
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running /bin/sh %s\n",
                ".ssh/rc");
      }
#line 2491
      f = popen("/bin/sh .ssh/rc", "w");
#line 2492
      if (f) {
#line 2494
        if ((unsigned int )auth_proto != (unsigned int )((void *)0)) {
#line 2494
          if ((unsigned int )auth_data != (unsigned int )((void *)0)) {
#line 2495
            fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                    auth_proto, auth_data);
          }
        }
#line 2496
        pclose(f);
      } else {
#line 2499
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                ".ssh/rc");
      }
    } else {
#line 2502
      tmp___22 = stat((char const   * __restrict  )"/usr/local/etc/sshrc", (struct stat * __restrict  )(& st));
#line 2502
      if (tmp___22 >= 0) {
#line 2504
        if (debug_flag) {
#line 2505
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running /bin/sh %s\n",
                  "/usr/local/etc/sshrc");
        }
#line 2507
        f = popen("/bin/sh /usr/local/etc/sshrc", "w");
#line 2508
        if (f) {
#line 2510
          if ((unsigned int )auth_proto != (unsigned int )((void *)0)) {
#line 2510
            if ((unsigned int )auth_data != (unsigned int )((void *)0)) {
#line 2511
              fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                      auth_proto, auth_data);
            }
          }
#line 2512
          pclose(f);
        } else {
#line 2515
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                  "/usr/local/etc/sshrc");
        }
      } else {
#line 2521
        if ((unsigned int )auth_proto != (unsigned int )((void *)0)) {
#line 2521
          if ((unsigned int )auth_data != (unsigned int )((void *)0)) {
#line 2523
            if (debug_flag) {
#line 2524
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %.100s add %.100s %.100s %.100s\n",
                      "/usr/X11R6/bin/xauth", display, auth_proto, auth_data);
            }
#line 2527
            f = popen("/usr/X11R6/bin/xauth -q -", "w");
#line 2528
            if (f) {
#line 2530
              fprintf((FILE * __restrict  )f, (char const   * __restrict  )"add %s %s %s\n",
                      display, auth_proto, auth_data);
#line 2531
              fclose(f);
            } else {
#line 2534
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s -q -\n",
                      "/usr/X11R6/bin/xauth");
            }
          }
        }
      }
    }
#line 2540
    tmp___24 = strrchr(shell, '/');
#line 2540
    cp = (char const   *)tmp___24;
#line 2541
    if (cp) {
#line 2542
      cp ++;
    } else {
#line 2544
      cp = shell;
    }
  }
#line 2550
  if (! command) {
#line 2552
    if (! options.use_login) {
#line 2556
      if (ttyname___0) {
#line 2556
        if (options.check_mail) {
#line 2559
          mailbox = getenv("MAIL");
#line 2560
          if ((unsigned int )mailbox != (unsigned int )((void *)0)) {
#line 2561
            tmp___25 = stat((char const   * __restrict  )mailbox, (struct stat * __restrict  )(& mailstat));
#line 2561
            if (tmp___25 != 0) {
#line 2562
              printf((char const   * __restrict  )"No mail.\n");
            } else {
#line 2561
              if (mailstat.st_size == 0L) {
#line 2562
                printf((char const   * __restrict  )"No mail.\n");
              } else {
#line 2563
                if (mailstat.st_mtim.tv_sec < mailstat.st_atim.tv_sec) {
#line 2564
                  printf((char const   * __restrict  )"You have mail.\n");
                } else {
#line 2566
                  printf((char const   * __restrict  )"You have new mail.\n");
                }
              }
            }
          }
        }
      }
#line 2572
      buf___0[0] = (char )'-';
#line 2573
      __builtin_strncpy(buf___0 + 1, cp, sizeof(buf___0) - 1U);
#line 2574
      buf___0[sizeof(buf___0) - 1U] = (char)0;
#line 2576
      argv[0] = buf___0;
#line 2577
      argv[1] = (char *)((void *)0);
#line 2578
      execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 2580
      perror(shell);
#line 2581
      exit(1);
    } else {
#line 2586
      tmp___26 = get_remote_ipaddr();
#line 2586
      execl("/usr/bin/login", "login", "-h", tmp___26, "-p", "-f", "--", pw->pw_name,
            (void *)0);
#line 2590
      perror("login");
#line 2591
      exit(1);
    }
  }
#line 2597
  argv[0] = (char *)cp;
#line 2598
  argv[1] = (char *)"-c";
#line 2599
  argv[2] = (char *)command;
#line 2600
  argv[3] = (char *)((void *)0);
#line 2601
  execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 2602
  perror(shell);
#line 2603
  exit(1);
}
}
#line 1 "auth-rhosts.o"
#pragma merger(0,"./auth-rhosts.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 325 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 418 "/usr/include/netdb.h"
extern int innetgr(char const   *__netgroup , char const   *__host , char const   *__user ,
                   char const   *domain ) ;
#line 30 "auth-rhosts.c"
int check_rhosts_file(char const   *filename , char const   *hostname , char const   *ipaddr ,
                      char const   *client_user , char const   *server_user ) 
{ FILE *f ;
  char buf[1024] ;
  char hostbuf[1024] ;
  char userbuf[1024] ;
  char dummy[1024] ;
  char *host ;
  char *user ;
  char *cp ;
  int negated ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___45 ;
  int tmp___48 ;
  int tmp___49 ;
  char *tmp___50 ;

  {
#line 38
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 39
  if (! f) {
#line 40
    return (0);
  }
#line 43
  while (1) {
#line 43
    tmp___50 = fgets((char * __restrict  )(buf), (int )sizeof(buf), (FILE * __restrict  )f);
#line 43
    if (! tmp___50) {
#line 43
      break;
    }
#line 49
    cp = buf;
#line 49
    while (1) {
#line 49
      if (! ((int )*cp == 32)) {
#line 49
        if (! ((int )*cp == 9)) {
#line 49
          break;
        }
      }
#line 49
      cp ++;
    }
#line 51
    if ((int )*cp == 35) {
#line 52
      continue;
    } else {
#line 51
      if ((int )*cp == 10) {
#line 52
        continue;
      } else {
#line 51
        if (! *cp) {
#line 52
          continue;
        }
      }
    }
#line 56
    if (0) {
#line 56
      if (0) {
#line 56
        __s1_len___0 = strlen((char const   *)cp);
#line 56
        __s2_len___0 = strlen("NO_PLUS");
#line 56
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___2;
        } else {
#line 56
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 56
            if (! ((unsigned int )((void const   *)("NO_PLUS" + 1)) - (unsigned int )((void const   *)"NO_PLUS") == 1U)) {
#line 56
              tmp___22 = 1;
            } else {
#line 56
              if (__s2_len___0 >= 4U) {
#line 56
                tmp___22 = 1;
              } else {
#line 56
                tmp___22 = 0;
              }
            }
          } else {
#line 56
            tmp___22 = 0;
          }
        }
#line 56
        if (tmp___22) {
#line 56
          tmp___18 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
        } else {
#line 56
          tmp___21 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 56
          tmp___18 = tmp___21;
        }
      } else {
#line 56
        tmp___21 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 56
        tmp___18 = tmp___21;
      }
#line 56
      tmp___12 = tmp___18;
    } else {
#line 56
      tmp___12 = strncmp((char const   *)cp, "NO_PLUS", 7U);
    }
#line 56
    if (tmp___12 == 0) {
#line 57
      continue;
    }
#line 61
    tmp___25 = sscanf((char const   * __restrict  )(buf), (char const   * __restrict  )"%s %s %s",
                      hostbuf, userbuf, dummy);
#line 61
    switch (tmp___25) {
    case 0: 
#line 64
    packet_send_debug("Found empty line in %.100s.", filename);
#line 65
    continue;
    case 1: 
#line 68
    strlcpy(userbuf, server_user, sizeof(userbuf));
#line 69
    break;
    case 2: 
#line 72
    break;
    case 3: 
#line 74
    packet_send_debug("Found garbage in %.100s.", filename);
#line 75
    continue;
    default: ;
#line 77
    continue;
    }
#line 80
    host = hostbuf;
#line 81
    user = userbuf;
#line 82
    negated = 0;
#line 85
    if ((int )*(host + 0) == 45) {
#line 87
      negated = 1;
#line 88
      host ++;
    } else {
#line 91
      if ((int )*(host + 0) == 43) {
#line 92
        host ++;
      }
    }
#line 94
    if ((int )*(user + 0) == 45) {
#line 96
      negated = 1;
#line 97
      user ++;
    } else {
#line 100
      if ((int )*(user + 0) == 43) {
#line 101
        user ++;
      }
    }
#line 104
    if (! *(host + 0)) {
#line 107
      packet_send_debug("Ignoring wild host/user names in %.100s.", filename);
#line 109
      continue;
    } else {
#line 104
      if (! *(user + 0)) {
#line 107
        packet_send_debug("Ignoring wild host/user names in %.100s.", filename);
#line 109
        continue;
      }
    }
#line 113
    if ((int )*(host + 0) == 64) {
#line 115
      tmp___26 = innetgr((char const   *)(host + 1), hostname, (char const   *)((void *)0),
                         (char const   *)((void *)0));
#line 115
      if (! tmp___26) {
#line 115
        tmp___27 = innetgr((char const   *)(host + 1), ipaddr, (char const   *)((void *)0),
                           (char const   *)((void *)0));
#line 115
        if (! tmp___27) {
#line 117
          continue;
        }
      }
    } else {
#line 120
      tmp___28 = strcasecmp((char const   *)host, hostname);
#line 120
      if (tmp___28) {
#line 120
        if (0) {
#line 120
          __s1_len___1 = strlen((char const   *)host);
#line 120
          __s2_len___1 = strlen(ipaddr);
#line 120
          if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
            goto _L___4;
          } else {
#line 120
            if (__s1_len___1 >= 4U) {
              _L___4: /* CIL Label */ 
#line 120
              if (! ((unsigned int )((void const   *)(ipaddr + 1)) - (unsigned int )((void const   *)ipaddr) == 1U)) {
#line 120
                tmp___38 = 1;
              } else {
#line 120
                if (__s2_len___1 >= 4U) {
#line 120
                  tmp___38 = 1;
                } else {
#line 120
                  tmp___38 = 0;
                }
              }
            } else {
#line 120
              tmp___38 = 0;
            }
          }
#line 120
          if (tmp___38) {
#line 120
            tmp___34 = __builtin_strcmp((char const   *)host, ipaddr);
          } else {
#line 120
            tmp___37 = __builtin_strcmp((char const   *)host, ipaddr);
#line 120
            tmp___34 = tmp___37;
          }
        } else {
#line 120
          tmp___37 = __builtin_strcmp((char const   *)host, ipaddr);
#line 120
          tmp___34 = tmp___37;
        }
#line 120
        if (tmp___34 != 0) {
#line 121
          continue;
        }
      }
    }
#line 124
    if ((int )*(user + 0) == 64) {
#line 126
      tmp___39 = innetgr((char const   *)(user + 1), (char const   *)((void *)0),
                         client_user, (char const   *)((void *)0));
#line 126
      if (! tmp___39) {
#line 127
        continue;
      }
    } else {
#line 130
      if (0) {
#line 130
        __s1_len___2 = strlen((char const   *)user);
#line 130
        __s2_len___2 = strlen(client_user);
#line 130
        if (! ((unsigned int )((void const   *)(user + 1)) - (unsigned int )((void const   *)user) == 1U)) {
          goto _L___6;
        } else {
#line 130
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 130
            if (! ((unsigned int )((void const   *)(client_user + 1)) - (unsigned int )((void const   *)client_user) == 1U)) {
#line 130
              tmp___49 = 1;
            } else {
#line 130
              if (__s2_len___2 >= 4U) {
#line 130
                tmp___49 = 1;
              } else {
#line 130
                tmp___49 = 0;
              }
            }
          } else {
#line 130
            tmp___49 = 0;
          }
        }
#line 130
        if (tmp___49) {
#line 130
          tmp___45 = __builtin_strcmp((char const   *)user, client_user);
        } else {
#line 130
          tmp___48 = __builtin_strcmp((char const   *)user, client_user);
#line 130
          tmp___45 = tmp___48;
        }
      } else {
#line 130
        tmp___48 = __builtin_strcmp((char const   *)user, client_user);
#line 130
        tmp___45 = tmp___48;
      }
#line 130
      if (tmp___45 != 0) {
#line 131
        continue;
      }
    }
#line 134
    fclose(f);
#line 137
    if (negated) {
#line 139
      packet_send_debug("Matched negative entry in %.100s.", filename);
#line 141
      return (0);
    }
#line 145
    return (1);
  }
#line 149
  fclose(f);
#line 150
  return (0);
}
}
#line 165 "auth-rhosts.c"
static char const   *rhosts_files[3]  = {      ".shosts",      ".rhosts",      (char const   *)((void *)0)};
#line 158 "auth-rhosts.c"
int auth_rhosts(struct passwd *pw , char const   *client_user , int ignore_rhosts ,
                int strict_modes ) 
{ char buf[1024] ;
  char const   *hostname ;
  char const   *ipaddr ;
  int port ;
  struct stat st ;
  unsigned int rhosts_file_index ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 171
  temporarily_use_uid(pw->pw_uid);
#line 172
  rhosts_file_index = 0U;
#line 172
  while (rhosts_files[rhosts_file_index]) {
#line 176
    snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%.500s/%.100s",
             pw->pw_dir, rhosts_files[rhosts_file_index]);
#line 178
    tmp = stat((char const   * __restrict  )(buf), (struct stat * __restrict  )(& st));
#line 178
    if (tmp >= 0) {
#line 179
      break;
    }
#line 172
    rhosts_file_index ++;
  }
#line 182
  restore_uid();
#line 184
  if (! rhosts_files[rhosts_file_index]) {
#line 184
    tmp___0 = stat((char const   * __restrict  )"/etc/hosts.equiv", (struct stat * __restrict  )(& st));
#line 184
    if (tmp___0 < 0) {
#line 184
      tmp___1 = stat((char const   * __restrict  )"/usr/local/etc/shosts.equiv", (struct stat * __restrict  )(& st));
#line 184
      if (tmp___1 < 0) {
#line 186
        return (0);
      }
    }
  }
#line 190
  hostname = get_canonical_hostname();
#line 191
  ipaddr = get_remote_ipaddr();
#line 192
  port = get_remote_port();
#line 199
  if (port >= 1024) {
#line 202
    log("Connection from %.100s from nonpriviledged port %d", hostname, port);
#line 204
    packet_send_debug("Your ssh client is not running as root.");
#line 205
    return (0);
  } else {
#line 199
    if (port < 512) {
#line 202
      log("Connection from %.100s from nonpriviledged port %d", hostname, port);
#line 204
      packet_send_debug("Your ssh client is not running as root.");
#line 205
      return (0);
    }
  }
#line 209
  if (pw->pw_uid != 0U) {
#line 211
    tmp___2 = check_rhosts_file("/etc/hosts.equiv", hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 211
    if (tmp___2) {
#line 214
      packet_send_debug("Accepted for %.100s [%.100s] by /etc/hosts.equiv.", hostname,
                        ipaddr);
#line 216
      return (1);
    }
#line 218
    tmp___3 = check_rhosts_file("/usr/local/etc/shosts.equiv", hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 218
    if (tmp___3) {
#line 221
      packet_send_debug("Accepted for %.100s [%.100s] by %.100s.", hostname, ipaddr,
                        "/usr/local/etc/shosts.equiv");
#line 223
      return (1);
    }
  }
#line 229
  tmp___4 = stat((char const   * __restrict  )pw->pw_dir, (struct stat * __restrict  )(& st));
#line 229
  if (tmp___4 < 0) {
#line 231
    log("Rhosts authentication refused for %.100: no home directory %.200s", pw->pw_name,
        pw->pw_dir);
#line 233
    packet_send_debug("Rhosts authentication refused for %.100: no home directory %.200s",
                      pw->pw_name, pw->pw_dir);
#line 235
    return (0);
  }
#line 237
  if (strict_modes) {
#line 237
    if (st.st_uid != 0U) {
#line 237
      if (st.st_uid != pw->pw_uid) {
#line 241
        log("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
            pw->pw_name);
#line 243
        packet_send_debug("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                          pw->pw_name);
#line 245
        return (0);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 237
      if ((st.st_mode & 18U) != 0U) {
#line 241
        log("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
            pw->pw_name);
#line 243
        packet_send_debug("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                          pw->pw_name);
#line 245
        return (0);
      }
    }
  }
#line 250
  temporarily_use_uid(pw->pw_uid);
#line 251
  rhosts_file_index = 0U;
#line 251
  while (rhosts_files[rhosts_file_index]) {
#line 255
    snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%.500s/%.100s",
             pw->pw_dir, rhosts_files[rhosts_file_index]);
#line 257
    tmp___5 = stat((char const   * __restrict  )(buf), (struct stat * __restrict  )(& st));
#line 257
    if (tmp___5 < 0) {
      goto __Cont;
    }
#line 264
    if (strict_modes) {
#line 264
      if (st.st_uid != 0U) {
#line 264
        if (st.st_uid != pw->pw_uid) {
#line 268
          log("Rhosts authentication refused for %.100s: bad modes for %.200s", pw->pw_name,
              buf);
#line 270
          packet_send_debug("Bad file modes for %.200s", buf);
          goto __Cont;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 264
        if ((st.st_mode & 18U) != 0U) {
#line 268
          log("Rhosts authentication refused for %.100s: bad modes for %.200s", pw->pw_name,
              buf);
#line 270
          packet_send_debug("Bad file modes for %.200s", buf);
          goto __Cont;
        }
      }
    }
#line 276
    if (ignore_rhosts) {
#line 278
      packet_send_debug("Server has been configured to ignore %.100s.", rhosts_files[rhosts_file_index]);
      goto __Cont;
    }
#line 284
    tmp___6 = check_rhosts_file((char const   *)(buf), hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 284
    if (tmp___6) {
#line 286
      packet_send_debug("Accepted by %.100s.", rhosts_files[rhosts_file_index]);
#line 289
      restore_uid();
#line 290
      return (1);
    }
    __Cont: /* CIL Label */ 
#line 251
    rhosts_file_index ++;
  }
#line 296
  restore_uid();
#line 297
  return (0);
}
}
#line 1 "auth-passwd.o"
#pragma merger(0,"./auth-passwd.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 174 "auth-passwd.c"
extern int ( /* missing proto */  crypt)() ;
#line 32 "auth-passwd.c"
int auth_password(struct passwd *pw , char const   *password ) 
{ char *encrypted_password ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  char const   *tmp___19 ;
  int tmp___20 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___26 ;
  int tmp___29 ;
  int tmp___30 ;

  {
#line 37
  if (pw->pw_uid == 0U) {
#line 37
    if (options.permit_root_login == 2) {
#line 40
      return (0);
    }
  }
#line 43
  if ((int const   )*password == 0) {
#line 43
    if (options.permit_empty_passwd == 0) {
#line 46
      return (0);
    }
  }
#line 50
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 51
    return (0);
  }
#line 167
  if (0) {
#line 167
    __s1_len = strlen(password);
#line 167
    __s2_len = strlen("");
#line 167
    if (! ((unsigned int )((void const   *)(password + 1)) - (unsigned int )((void const   *)password) == 1U)) {
      goto _L___0;
    } else {
#line 167
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 167
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 167
          tmp___8 = 1;
        } else {
#line 167
          if (__s2_len >= 4U) {
#line 167
            tmp___8 = 1;
          } else {
#line 167
            tmp___8 = 0;
          }
        }
      } else {
#line 167
        tmp___8 = 0;
      }
    }
#line 167
    if (tmp___8) {
#line 167
      tmp___4 = __builtin_strcmp(password, "");
    } else {
#line 167
      tmp___7 = __builtin_strcmp(password, "");
#line 167
      tmp___4 = tmp___7;
    }
  } else {
#line 167
    tmp___7 = __builtin_strcmp(password, "");
#line 167
    tmp___4 = tmp___7;
  }
#line 167
  if (tmp___4 == 0) {
#line 167
    if (0) {
#line 167
      __s1_len___0 = strlen((char const   *)pw->pw_passwd);
#line 167
      __s2_len___0 = strlen("");
#line 167
      if (! ((unsigned int )((void const   *)(pw->pw_passwd + 1)) - (unsigned int )((void const   *)pw->pw_passwd) == 1U)) {
        goto _L___2;
      } else {
#line 167
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 167
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 167
            tmp___18 = 1;
          } else {
#line 167
            if (__s2_len___0 >= 4U) {
#line 167
              tmp___18 = 1;
            } else {
#line 167
              tmp___18 = 0;
            }
          }
        } else {
#line 167
          tmp___18 = 0;
        }
      }
#line 167
      if (tmp___18) {
#line 167
        tmp___14 = __builtin_strcmp((char const   *)pw->pw_passwd, "");
      } else {
#line 167
        tmp___17 = __builtin_strcmp((char const   *)pw->pw_passwd, "");
#line 167
        tmp___14 = tmp___17;
      }
    } else {
#line 167
      tmp___17 = __builtin_strcmp((char const   *)pw->pw_passwd, "");
#line 167
      tmp___14 = tmp___17;
    }
#line 167
    if (tmp___14 == 0) {
#line 169
      packet_send_debug("Login permitted without a password because the account has no password.");
#line 170
      return (1);
    }
  }
#line 174
  if (*(pw->pw_passwd + 0)) {
#line 174
    if (*(pw->pw_passwd + 1)) {
#line 174
      tmp___19 = (char const   *)pw->pw_passwd;
    } else {
#line 174
      tmp___19 = "xx";
    }
  } else {
#line 174
    tmp___19 = "xx";
  }
#line 174
  tmp___20 = crypt(password, tmp___19);
#line 174
  encrypted_password = (char *)tmp___20;
#line 179
  if (0) {
#line 179
    __s1_len___1 = strlen((char const   *)encrypted_password);
#line 179
    __s2_len___1 = strlen((char const   *)pw->pw_passwd);
#line 179
    if (! ((unsigned int )((void const   *)(encrypted_password + 1)) - (unsigned int )((void const   *)encrypted_password) == 1U)) {
      goto _L___4;
    } else {
#line 179
      if (__s1_len___1 >= 4U) {
        _L___4: /* CIL Label */ 
#line 179
        if (! ((unsigned int )((void const   *)(pw->pw_passwd + 1)) - (unsigned int )((void const   *)pw->pw_passwd) == 1U)) {
#line 179
          tmp___30 = 1;
        } else {
#line 179
          if (__s2_len___1 >= 4U) {
#line 179
            tmp___30 = 1;
          } else {
#line 179
            tmp___30 = 0;
          }
        }
      } else {
#line 179
        tmp___30 = 0;
      }
    }
#line 179
    if (tmp___30) {
#line 179
      tmp___26 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)pw->pw_passwd);
    } else {
#line 179
      tmp___29 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)pw->pw_passwd);
#line 179
      tmp___26 = tmp___29;
    }
  } else {
#line 179
    tmp___29 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)pw->pw_passwd);
#line 179
    tmp___26 = tmp___29;
  }
#line 179
  return (tmp___26 == 0);
}
}
#line 1 "auth-rsa.o"
#pragma merger(0,"./auth-rsa.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 212
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 401 "/usr/include/openssl/bn.h"
extern int BN_rand(BIGNUM *rnd , int bits , int top , int bottom ) ;
#line 353 "ssh.h"
int auth_rsa_challenge_dialog(unsigned int bits , BIGNUM *e , BIGNUM *n___0 ) ;
#line 63 "auth-rsa.c"
int auth_rsa_challenge_dialog(unsigned int bits , BIGNUM *e , BIGNUM *n___0 ) 
{ BIGNUM *challenge ;
  BIGNUM *encrypted_challenge ;
  BIGNUM *aux ;
  RSA *pk ;
  BN_CTX *ctx ;
  BN_CTX *tmp ;
  unsigned char buf[32] ;
  unsigned char mdbuf[16] ;
  unsigned char response[16] ;
  MD5_CTX md ;
  unsigned int i ;
  int plen ;
  int len ;
  int tmp___0 ;
  int _p ;
  int _e ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
#line 68
  tmp = BN_CTX_new();
#line 68
  ctx = tmp;
#line 74
  encrypted_challenge = BN_new();
#line 75
  challenge = BN_new();
#line 76
  aux = BN_new();
#line 79
  BN_rand(challenge, 256, 0, 0);
#line 80
  BN_div((BIGNUM *)((void *)0), challenge, (BIGNUM const   *)challenge, (BIGNUM const   *)n___0,
         ctx);
#line 83
  pk = RSA_new();
#line 84
  pk->e = BN_new();
#line 85
  BN_copy(pk->e, (BIGNUM const   *)e);
#line 86
  pk->n = BN_new();
#line 87
  BN_copy(pk->n, (BIGNUM const   *)n___0);
#line 90
  rsa_public_encrypt(encrypted_challenge, challenge, pk);
#line 91
  RSA_free(pk);
#line 94
  packet_start(7);
#line 95
  packet_put_bignum(encrypted_challenge);
#line 96
  packet_send();
#line 97
  packet_write_wait();
#line 100
  tmp___0 = BN_num_bits((BIGNUM const   *)challenge);
#line 100
  len = (tmp___0 + 7) / 8;
#line 101
  if (len <= 0) {
#line 102
    fatal("auth_rsa_challenge_dialog: bad challenge length %d", len);
  } else {
#line 101
    if (len > 32) {
#line 102
      fatal("auth_rsa_challenge_dialog: bad challenge length %d", len);
    }
  }
#line 104
  memset((void *)(buf), 0, 32U);
#line 105
  BN_bn2bin((BIGNUM const   *)challenge, (buf + 32) - len);
#line 106
  MD5_Init(& md);
#line 107
  MD5_Update(& md, (void const   *)(buf), 32U);
#line 108
  MD5_Update(& md, (void const   *)(session_id), 16U);
#line 109
  MD5_Final(mdbuf, & md);
#line 112
  BN_clear_free(encrypted_challenge);
#line 113
  BN_clear_free(challenge);
#line 114
  BN_clear_free(aux);
#line 115
  BN_CTX_free(ctx);
#line 118
  packet_read_expect(& plen, 8);
#line 119
  while (1) {
#line 119
    _p = plen;
#line 119
    _e = 16;
#line 119
    if (_p != _e) {
#line 119
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "auth-rsa.c", 119);
#line 119
      packet_disconnect("Packet integrity error. (%d)", 8);
    }
#line 119
    break;
  }
#line 120
  i = 0U;
#line 120
  while (i < 16U) {
#line 121
    tmp___1 = packet_get_char();
#line 121
    response[i] = (unsigned char )tmp___1;
#line 120
    i ++;
  }
#line 124
  tmp___2 = memcmp((void const   *)(response), (void const   *)(mdbuf), 16U);
#line 124
  if (tmp___2 != 0) {
#line 127
    return (0);
  }
#line 131
  return (1);
}
}
#line 188 "auth-rsa.c"
static char const   *check[3]  = {      "",      ".ssh",      (char const   *)((void *)0)};
#line 138 "auth-rsa.c"
int auth_rsa(struct passwd *pw , BIGNUM *client_n , int strict_modes ) 
{ char line[8192] ;
  int authenticated ;
  unsigned int bits ;
  FILE *f ;
  unsigned long linenum ;
  struct stat st ;
  BIGNUM *e ;
  BIGNUM *n___0 ;
  int tmp ;
  int fail ;
  char buf[1024] ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *cp ;
  char *options___0 ;
  int quoted ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___24 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___30 ;
  int tmp___33 ;
  int tmp___34 ;
  size_t tmp___35 ;
  size_t tmp___41 ;
  int tmp___59 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___65 ;
  int tmp___68 ;
  int tmp___69 ;
  size_t tmp___70 ;
  size_t tmp___76 ;
  int tmp___94 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___100 ;
  int tmp___103 ;
  int tmp___104 ;
  size_t tmp___105 ;
  size_t tmp___111 ;
  int tmp___129 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___135 ;
  int tmp___138 ;
  int tmp___139 ;
  size_t tmp___140 ;
  int i___0 ;
  size_t tmp___146 ;
  size_t tmp___147 ;
  void *tmp___148 ;
  int tmp___149 ;
  int tmp___150 ;
  char *tmp___151 ;
  int tmp___169 ;
  size_t __s1_len___8 ;
  size_t __s2_len___8 ;
  int tmp___175 ;
  int tmp___178 ;
  int tmp___179 ;
  size_t tmp___180 ;
  int i___1 ;
  char *s ;
  struct envstring *new_envstring ;
  size_t tmp___186 ;
  size_t tmp___187 ;
  void *tmp___188 ;
  int tmp___189 ;
  int tmp___190 ;
  char *tmp___191 ;
  void *tmp___192 ;
  int tmp___210 ;
  size_t __s1_len___10 ;
  size_t __s2_len___10 ;
  int tmp___216 ;
  int tmp___219 ;
  int tmp___220 ;
  size_t tmp___221 ;
  char *patterns ;
  size_t tmp___227 ;
  void *tmp___228 ;
  int i___2 ;
  size_t tmp___229 ;
  int tmp___230 ;
  int tmp___231 ;
  char *tmp___232 ;
  char const   *tmp___233 ;
  char const   *tmp___234 ;
  char const   *tmp___235 ;
  size_t tmp___236 ;
  char const   *tmp___237 ;
  int tmp___238 ;
  size_t tmp___239 ;
  char const   *tmp___240 ;
  int tmp___241 ;
  int tmp___259 ;
  size_t __s1_len___12 ;
  size_t __s2_len___12 ;
  int tmp___265 ;
  int tmp___268 ;
  int tmp___269 ;
  size_t tmp___270 ;
  char *tmp___276 ;

  {
#line 145
  linenum = 0UL;
#line 150
  temporarily_use_uid(pw->pw_uid);
#line 153
  snprintf((char * __restrict  )(line), sizeof(line), (char const   * __restrict  )"%.500s/%.100s",
           pw->pw_dir, ".ssh/authorized_keys");
#line 157
  tmp = stat((char const   * __restrict  )(line), (struct stat * __restrict  )(& st));
#line 157
  if (tmp < 0) {
#line 160
    restore_uid();
#line 161
    return (0);
  }
#line 165
  f = fopen((char const   * __restrict  )(line), (char const   * __restrict  )"r");
#line 166
  if (! f) {
#line 169
    restore_uid();
#line 170
    packet_send_debug("Could not open %.900s for reading.", line);
#line 171
    packet_send_debug("If your home is on an NFS volume, it may need to be world-readable.");
#line 172
    return (0);
  }
#line 175
  if (strict_modes) {
#line 176
    fail = 0;
#line 179
    tmp___1 = fileno(f);
#line 179
    tmp___2 = fstat(tmp___1, & st);
#line 179
    if (tmp___2 < 0) {
#line 182
      snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
               pw->pw_name, line);
#line 184
      fail = 1;
    } else {
#line 179
      if (st.st_uid != 0U) {
#line 179
        if (st.st_uid != pw->pw_uid) {
#line 182
          snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   pw->pw_name, line);
#line 184
          fail = 1;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 179
        if ((st.st_mode & 18U) != 0U) {
#line 182
          snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   pw->pw_name, line);
#line 184
          fail = 1;
        } else {
#line 191
          i = 0;
#line 191
          while (check[i]) {
#line 192
            snprintf((char * __restrict  )(line), sizeof(line), (char const   * __restrict  )"%.500s/%.100s",
                     pw->pw_dir, check[i]);
#line 193
            tmp___0 = stat((char const   * __restrict  )(line), (struct stat * __restrict  )(& st));
#line 193
            if (tmp___0 < 0) {
#line 196
              snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                       pw->pw_name, line);
#line 198
              fail = 1;
#line 199
              break;
            } else {
#line 193
              if (st.st_uid != 0U) {
#line 193
                if (st.st_uid != pw->pw_uid) {
#line 196
                  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           pw->pw_name, line);
#line 198
                  fail = 1;
#line 199
                  break;
                } else {
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
#line 193
                if ((st.st_mode & 18U) != 0U) {
#line 196
                  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           pw->pw_name, line);
#line 198
                  fail = 1;
#line 199
                  break;
                }
              }
            }
#line 191
            i ++;
          }
        }
      }
    }
#line 203
    if (fail) {
#line 204
      log((char const   *)(buf));
#line 205
      packet_send_debug((char const   *)(buf));
#line 206
      restore_uid();
#line 207
      return (0);
    }
  }
#line 212
  authenticated = 0;
#line 215
  e = BN_new();
#line 216
  n___0 = BN_new();
#line 221
  while (1) {
#line 221
    tmp___276 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 221
    if (! tmp___276) {
#line 221
      break;
    }
#line 226
    linenum ++;
#line 229
    cp = line;
#line 229
    while (1) {
#line 229
      if (! ((int )*cp == 32)) {
#line 229
        if (! ((int )*cp == 9)) {
#line 229
          break;
        }
      }
#line 229
      cp ++;
    }
#line 233
    if (! *cp) {
#line 234
      continue;
    } else {
#line 233
      if ((int )*cp == 10) {
#line 234
        continue;
      } else {
#line 233
        if ((int )*cp == 35) {
#line 234
          continue;
        }
      }
    }
#line 239
    if ((int )*cp < 48) {
      goto _L___2;
    } else {
#line 239
      if ((int )*cp > 57) {
        _L___2: /* CIL Label */ 
#line 241
        quoted = 0;
#line 242
        options___0 = cp;
#line 243
        while (1) {
#line 243
          if (*cp) {
#line 243
            if (! quoted) {
#line 243
              if ((int )*cp != 32) {
#line 243
                if (! ((int )*cp != 9)) {
#line 243
                  break;
                }
              } else {
#line 243
                break;
              }
            }
          } else {
#line 243
            break;
          }
#line 245
          if ((int )*cp == 92) {
#line 245
            if ((int )*(cp + 1) == 34) {
#line 246
              cp ++;
            } else {
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
#line 248
            if ((int )*cp == 34) {
#line 249
              quoted = ! quoted;
            }
          }
#line 243
          cp ++;
        }
      } else {
#line 253
        options___0 = (char *)((void *)0);
      }
    }
#line 256
    tmp___3 = auth_rsa_read_key(& cp, & bits, e, n___0);
#line 256
    if (! tmp___3) {
#line 258
      debug("%.100s, line %lu: bad key syntax", ".ssh/authorized_keys", linenum);
#line 260
      packet_send_debug("%.100s, line %lu: bad key syntax", ".ssh/authorized_keys",
                        linenum);
#line 262
      continue;
    }
#line 268
    tmp___4 = BN_cmp((BIGNUM const   *)n___0, (BIGNUM const   *)client_n);
#line 268
    if (tmp___4 != 0) {
#line 269
      continue;
    }
#line 274
    tmp___5 = auth_rsa_challenge_dialog(bits, e, n___0);
#line 274
    if (! tmp___5) {
#line 277
      log("Wrong response to RSA authentication challenge.");
#line 278
      packet_send_debug("Wrong response to RSA authentication challenge.");
#line 279
      continue;
    }
#line 285
    authenticated = 1;
#line 288
    if (options___0) {
#line 290
      while (1) {
#line 290
        if (*options___0) {
#line 290
          if ((int )*options___0 != 32) {
#line 290
            if (! ((int )*options___0 != 9)) {
#line 290
              break;
            }
          } else {
#line 290
            break;
          }
        } else {
#line 290
          break;
        }
#line 292
        cp = (char *)"no-port-forwarding";
#line 293
        if (0) {
#line 293
          if (0) {
#line 293
            __s1_len___0 = strlen((char const   *)options___0);
#line 293
            __s2_len___0 = strlen((char const   *)cp);
#line 293
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___6;
            } else {
#line 293
              if (__s1_len___0 >= 4U) {
                _L___6: /* CIL Label */ 
#line 293
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 293
                  tmp___34 = 1;
                } else {
#line 293
                  if (__s2_len___0 >= 4U) {
#line 293
                    tmp___34 = 1;
                  } else {
#line 293
                    tmp___34 = 0;
                  }
                }
              } else {
#line 293
                tmp___34 = 0;
              }
            }
#line 293
            if (tmp___34) {
#line 293
              tmp___30 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 293
              tmp___33 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 293
              tmp___30 = tmp___33;
            }
          } else {
#line 293
            tmp___33 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 293
            tmp___30 = tmp___33;
          }
#line 293
          tmp___24 = tmp___30;
        } else {
#line 293
          tmp___35 = strlen((char const   *)cp);
#line 293
          tmp___24 = strncmp((char const   *)options___0, (char const   *)cp, tmp___35);
        }
#line 293
        if (tmp___24 == 0) {
#line 295
          packet_send_debug("Port forwarding disabled.");
#line 296
          no_port_forwarding_flag = 1;
#line 297
          tmp___6 = strlen((char const   *)cp);
#line 297
          options___0 += tmp___6;
          goto next_option;
        }
#line 300
        cp = (char *)"no-agent-forwarding";
#line 301
        if (0) {
#line 301
          if (0) {
#line 301
            __s1_len___2 = strlen((char const   *)options___0);
#line 301
            __s2_len___2 = strlen((char const   *)cp);
#line 301
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___10;
            } else {
#line 301
              if (__s1_len___2 >= 4U) {
                _L___10: /* CIL Label */ 
#line 301
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 301
                  tmp___69 = 1;
                } else {
#line 301
                  if (__s2_len___2 >= 4U) {
#line 301
                    tmp___69 = 1;
                  } else {
#line 301
                    tmp___69 = 0;
                  }
                }
              } else {
#line 301
                tmp___69 = 0;
              }
            }
#line 301
            if (tmp___69) {
#line 301
              tmp___65 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 301
              tmp___68 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 301
              tmp___65 = tmp___68;
            }
          } else {
#line 301
            tmp___68 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 301
            tmp___65 = tmp___68;
          }
#line 301
          tmp___59 = tmp___65;
        } else {
#line 301
          tmp___70 = strlen((char const   *)cp);
#line 301
          tmp___59 = strncmp((char const   *)options___0, (char const   *)cp, tmp___70);
        }
#line 301
        if (tmp___59 == 0) {
#line 303
          packet_send_debug("Agent forwarding disabled.");
#line 304
          no_agent_forwarding_flag = 1;
#line 305
          tmp___41 = strlen((char const   *)cp);
#line 305
          options___0 += tmp___41;
          goto next_option;
        }
#line 308
        cp = (char *)"no-X11-forwarding";
#line 309
        if (0) {
#line 309
          if (0) {
#line 309
            __s1_len___4 = strlen((char const   *)options___0);
#line 309
            __s2_len___4 = strlen((char const   *)cp);
#line 309
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___14;
            } else {
#line 309
              if (__s1_len___4 >= 4U) {
                _L___14: /* CIL Label */ 
#line 309
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 309
                  tmp___104 = 1;
                } else {
#line 309
                  if (__s2_len___4 >= 4U) {
#line 309
                    tmp___104 = 1;
                  } else {
#line 309
                    tmp___104 = 0;
                  }
                }
              } else {
#line 309
                tmp___104 = 0;
              }
            }
#line 309
            if (tmp___104) {
#line 309
              tmp___100 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 309
              tmp___103 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 309
              tmp___100 = tmp___103;
            }
          } else {
#line 309
            tmp___103 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 309
            tmp___100 = tmp___103;
          }
#line 309
          tmp___94 = tmp___100;
        } else {
#line 309
          tmp___105 = strlen((char const   *)cp);
#line 309
          tmp___94 = strncmp((char const   *)options___0, (char const   *)cp, tmp___105);
        }
#line 309
        if (tmp___94 == 0) {
#line 311
          packet_send_debug("X11 forwarding disabled.");
#line 312
          no_x11_forwarding_flag = 1;
#line 313
          tmp___76 = strlen((char const   *)cp);
#line 313
          options___0 += tmp___76;
          goto next_option;
        }
#line 316
        cp = (char *)"no-pty";
#line 317
        if (0) {
#line 317
          if (0) {
#line 317
            __s1_len___6 = strlen((char const   *)options___0);
#line 317
            __s2_len___6 = strlen((char const   *)cp);
#line 317
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___18;
            } else {
#line 317
              if (__s1_len___6 >= 4U) {
                _L___18: /* CIL Label */ 
#line 317
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 317
                  tmp___139 = 1;
                } else {
#line 317
                  if (__s2_len___6 >= 4U) {
#line 317
                    tmp___139 = 1;
                  } else {
#line 317
                    tmp___139 = 0;
                  }
                }
              } else {
#line 317
                tmp___139 = 0;
              }
            }
#line 317
            if (tmp___139) {
#line 317
              tmp___135 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 317
              tmp___138 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 317
              tmp___135 = tmp___138;
            }
          } else {
#line 317
            tmp___138 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 317
            tmp___135 = tmp___138;
          }
#line 317
          tmp___129 = tmp___135;
        } else {
#line 317
          tmp___140 = strlen((char const   *)cp);
#line 317
          tmp___129 = strncmp((char const   *)options___0, (char const   *)cp, tmp___140);
        }
#line 317
        if (tmp___129 == 0) {
#line 319
          packet_send_debug("Pty allocation disabled.");
#line 320
          no_pty_flag = 1;
#line 321
          tmp___111 = strlen((char const   *)cp);
#line 321
          options___0 += tmp___111;
          goto next_option;
        }
#line 324
        cp = (char *)"command=\"";
#line 325
        if (0) {
#line 325
          if (0) {
#line 325
            __s1_len___8 = strlen((char const   *)options___0);
#line 325
            __s2_len___8 = strlen((char const   *)cp);
#line 325
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___22;
            } else {
#line 325
              if (__s1_len___8 >= 4U) {
                _L___22: /* CIL Label */ 
#line 325
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 325
                  tmp___179 = 1;
                } else {
#line 325
                  if (__s2_len___8 >= 4U) {
#line 325
                    tmp___179 = 1;
                  } else {
#line 325
                    tmp___179 = 0;
                  }
                }
              } else {
#line 325
                tmp___179 = 0;
              }
            }
#line 325
            if (tmp___179) {
#line 325
              tmp___175 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 325
              tmp___178 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 325
              tmp___175 = tmp___178;
            }
          } else {
#line 325
            tmp___178 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 325
            tmp___175 = tmp___178;
          }
#line 325
          tmp___169 = tmp___175;
        } else {
#line 325
          tmp___180 = strlen((char const   *)cp);
#line 325
          tmp___169 = strncmp((char const   *)options___0, (char const   *)cp, tmp___180);
        }
#line 325
        if (tmp___169 == 0) {
#line 328
          tmp___146 = strlen((char const   *)cp);
#line 328
          options___0 += tmp___146;
#line 329
          tmp___147 = strlen((char const   *)options___0);
#line 329
          tmp___148 = xmalloc(tmp___147 + 1U);
#line 329
          forced_command = (char *)tmp___148;
#line 330
          i___0 = 0;
#line 331
          while (*options___0) {
#line 333
            if ((int )*options___0 == 34) {
#line 334
              break;
            }
#line 335
            if ((int )*options___0 == 92) {
#line 335
              if ((int )*(options___0 + 1) == 34) {
#line 337
                options___0 += 2;
#line 338
                tmp___149 = i___0;
#line 338
                i___0 ++;
#line 338
                *(forced_command + tmp___149) = (char )'\"';
#line 339
                continue;
              }
            }
#line 341
            tmp___150 = i___0;
#line 341
            i___0 ++;
#line 341
            tmp___151 = options___0;
#line 341
            options___0 ++;
#line 341
            *(forced_command + tmp___150) = *tmp___151;
          }
#line 343
          if (! *options___0) {
#line 345
            debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys", linenum);
#line 347
            packet_send_debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys",
                              linenum);
#line 349
            continue;
          }
#line 351
          *(forced_command + i___0) = (char)0;
#line 352
          packet_send_debug("Forced command: %.900s", forced_command);
#line 353
          options___0 ++;
          goto next_option;
        }
#line 356
        cp = (char *)"environment=\"";
#line 357
        if (0) {
#line 357
          if (0) {
#line 357
            __s1_len___10 = strlen((char const   *)options___0);
#line 357
            __s2_len___10 = strlen((char const   *)cp);
#line 357
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___26;
            } else {
#line 357
              if (__s1_len___10 >= 4U) {
                _L___26: /* CIL Label */ 
#line 357
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 357
                  tmp___220 = 1;
                } else {
#line 357
                  if (__s2_len___10 >= 4U) {
#line 357
                    tmp___220 = 1;
                  } else {
#line 357
                    tmp___220 = 0;
                  }
                }
              } else {
#line 357
                tmp___220 = 0;
              }
            }
#line 357
            if (tmp___220) {
#line 357
              tmp___216 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 357
              tmp___219 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 357
              tmp___216 = tmp___219;
            }
          } else {
#line 357
            tmp___219 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 357
            tmp___216 = tmp___219;
          }
#line 357
          tmp___210 = tmp___216;
        } else {
#line 357
          tmp___221 = strlen((char const   *)cp);
#line 357
          tmp___210 = strncmp((char const   *)options___0, (char const   *)cp, tmp___221);
        }
#line 357
        if (tmp___210 == 0) {
#line 362
          tmp___186 = strlen((char const   *)cp);
#line 362
          options___0 += tmp___186;
#line 363
          tmp___187 = strlen((char const   *)options___0);
#line 363
          tmp___188 = xmalloc(tmp___187 + 1U);
#line 363
          s = (char *)tmp___188;
#line 364
          i___1 = 0;
#line 365
          while (*options___0) {
#line 367
            if ((int )*options___0 == 34) {
#line 368
              break;
            }
#line 369
            if ((int )*options___0 == 92) {
#line 369
              if ((int )*(options___0 + 1) == 34) {
#line 371
                options___0 += 2;
#line 372
                tmp___189 = i___1;
#line 372
                i___1 ++;
#line 372
                *(s + tmp___189) = (char )'\"';
#line 373
                continue;
              }
            }
#line 375
            tmp___190 = i___1;
#line 375
            i___1 ++;
#line 375
            tmp___191 = options___0;
#line 375
            options___0 ++;
#line 375
            *(s + tmp___190) = *tmp___191;
          }
#line 377
          if (! *options___0) {
#line 379
            debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys", linenum);
#line 381
            packet_send_debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys",
                              linenum);
#line 383
            continue;
          }
#line 385
          *(s + i___1) = (char)0;
#line 386
          packet_send_debug("Adding to environment: %.900s", s);
#line 387
          debug("Adding to environment: %.900s", s);
#line 388
          options___0 ++;
#line 389
          tmp___192 = xmalloc(sizeof(struct envstring ));
#line 389
          new_envstring = (struct envstring *)tmp___192;
#line 390
          new_envstring->s = s;
#line 391
          new_envstring->next = custom_environment;
#line 392
          custom_environment = new_envstring;
          goto next_option;
        }
#line 395
        cp = (char *)"from=\"";
#line 396
        if (0) {
#line 396
          if (0) {
#line 396
            __s1_len___12 = strlen((char const   *)options___0);
#line 396
            __s2_len___12 = strlen((char const   *)cp);
#line 396
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___30;
            } else {
#line 396
              if (__s1_len___12 >= 4U) {
                _L___30: /* CIL Label */ 
#line 396
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 396
                  tmp___269 = 1;
                } else {
#line 396
                  if (__s2_len___12 >= 4U) {
#line 396
                    tmp___269 = 1;
                  } else {
#line 396
                    tmp___269 = 0;
                  }
                }
              } else {
#line 396
                tmp___269 = 0;
              }
            }
#line 396
            if (tmp___269) {
#line 396
              tmp___265 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 396
              tmp___268 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 396
              tmp___265 = tmp___268;
            }
          } else {
#line 396
            tmp___268 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 396
            tmp___265 = tmp___268;
          }
#line 396
          tmp___259 = tmp___265;
        } else {
#line 396
          tmp___270 = strlen((char const   *)cp);
#line 396
          tmp___259 = strncmp((char const   *)options___0, (char const   *)cp, tmp___270);
        }
#line 396
        if (tmp___259 == 0) {
#line 398
          tmp___227 = strlen((char const   *)options___0);
#line 398
          tmp___228 = xmalloc(tmp___227 + 1U);
#line 398
          patterns = (char *)tmp___228;
#line 400
          tmp___229 = strlen((char const   *)cp);
#line 400
          options___0 += tmp___229;
#line 401
          i___2 = 0;
#line 402
          while (*options___0) {
#line 404
            if ((int )*options___0 == 34) {
#line 405
              break;
            }
#line 406
            if ((int )*options___0 == 92) {
#line 406
              if ((int )*(options___0 + 1) == 34) {
#line 408
                options___0 += 2;
#line 409
                tmp___230 = i___2;
#line 409
                i___2 ++;
#line 409
                *(patterns + tmp___230) = (char )'\"';
#line 410
                continue;
              }
            }
#line 412
            tmp___231 = i___2;
#line 412
            i___2 ++;
#line 412
            tmp___232 = options___0;
#line 412
            options___0 ++;
#line 412
            *(patterns + tmp___231) = *tmp___232;
          }
#line 414
          if (! *options___0) {
#line 416
            debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys", linenum);
#line 418
            packet_send_debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys",
                              linenum);
#line 420
            continue;
          }
#line 422
          *(patterns + i___2) = (char)0;
#line 423
          options___0 ++;
#line 424
          tmp___236 = strlen((char const   *)patterns);
#line 424
          tmp___237 = get_canonical_hostname();
#line 424
          tmp___238 = match_hostname(tmp___237, (char const   *)patterns, tmp___236);
#line 424
          if (! tmp___238) {
#line 424
            tmp___239 = strlen((char const   *)patterns);
#line 424
            tmp___240 = get_remote_ipaddr();
#line 424
            tmp___241 = match_hostname(tmp___240, (char const   *)patterns, tmp___239);
#line 424
            if (! tmp___241) {
#line 429
              tmp___233 = get_remote_ipaddr();
#line 429
              tmp___234 = get_canonical_hostname();
#line 429
              log("RSA authentication tried for %.100s with correct key but not from a permitted host (host=%.200s, ip=%.200s).",
                  pw->pw_name, tmp___234, tmp___233);
#line 432
              tmp___235 = get_canonical_hostname();
#line 432
              packet_send_debug("Your host \'%.200s\' is not permitted to use this key for login.",
                                tmp___235);
#line 434
              xfree((void *)patterns);
#line 435
              authenticated = 0;
#line 436
              break;
            }
          }
#line 438
          xfree((void *)patterns);
          goto next_option;
        }
        bad_option: 
#line 444
        log("Bad options in %.100s file, line %lu: %.50s", ".ssh/authorized_keys",
            linenum, options___0);
#line 446
        packet_send_debug("Bad options in %.100s file, line %lu: %.50s", ".ssh/authorized_keys",
                          linenum, options___0);
#line 448
        authenticated = 0;
#line 449
        break;
        next_option: 
#line 454
        if (! *options___0) {
#line 455
          fatal("Bugs in auth-rsa.c option processing.");
        }
#line 456
        if ((int )*options___0 == 32) {
#line 457
          break;
        } else {
#line 456
          if ((int )*options___0 == 9) {
#line 457
            break;
          }
        }
#line 458
        if ((int )*options___0 != 44) {
          goto bad_option;
        }
#line 460
        options___0 ++;
#line 462
        continue;
      }
    }
#line 468
    if (authenticated) {
#line 469
      break;
    }
  }
#line 473
  restore_uid();
#line 476
  fclose(f);
#line 479
  BN_clear_free(n___0);
#line 480
  BN_clear_free(e);
#line 482
  if (authenticated) {
#line 483
    packet_send_debug("RSA authentication accepted.");
  }
#line 486
  return (authenticated);
}
}
#line 1 "auth-rh-rsa.o"
#pragma merger(0,"./auth-rh-rsa.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 458 "/usr/include/openssl/bn.h"
extern void BN_free(BIGNUM *a ) ;
#line 29 "auth-rh-rsa.c"
int auth_rhosts_rsa(struct passwd *pw , char const   *client_user , unsigned int client_host_key_bits ,
                    BIGNUM *client_host_key_e , BIGNUM *client_host_key_n , int ignore_rhosts ,
                    int strict_modes ) 
{ char const   *canonical_hostname ;
  HostStatus host_status ;
  BIGNUM *ke ;
  BIGNUM *kn ;
  int tmp ;
  int tmp___0 ;

  {
#line 38
  debug("Trying rhosts with RSA host authentication for %.100s", client_user);
#line 41
  tmp = auth_rhosts(pw, client_user, ignore_rhosts, strict_modes);
#line 41
  if (! tmp) {
#line 42
    return (0);
  }
#line 44
  canonical_hostname = get_canonical_hostname();
#line 46
  debug("Rhosts RSA authentication: canonical host %.900s", canonical_hostname);
#line 51
  ke = BN_new();
#line 52
  kn = BN_new();
#line 53
  host_status = check_host_in_hostfile("/usr/local/etc/ssh_known_hosts", canonical_hostname,
                                       client_host_key_bits, client_host_key_e, client_host_key_n,
                                       ke, kn);
#line 56
  BN_free(ke);
#line 57
  BN_free(kn);
#line 58
  if ((int )host_status != 0) {
#line 60
    debug("Rhosts with RSA host authentication denied: unknown or invalid host key");
#line 61
    packet_send_debug("Your host key cannot be verified: unknown or invalid host key.");
#line 62
    return (0);
  }
#line 68
  tmp___0 = auth_rsa_challenge_dialog(client_host_key_bits, client_host_key_e, client_host_key_n);
#line 68
  if (! tmp___0) {
#line 71
    log("Client on %.800s failed to respond correctly to host authentication.", canonical_hostname);
#line 73
    return (0);
  }
#line 79
  log("Rhosts with RSA host authentication accepted for %.100s, %.100s on %.700s.",
      pw->pw_name, client_user, canonical_hostname);
#line 81
  packet_send_debug("Rhosts with RSA host authentication accepted.");
#line 82
  return (1);
}
}
#line 1 "pty.o"
#pragma merger(0,"./pty.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 49 "pty.c"
extern int ( /* missing proto */  openpty)() ;
#line 41 "pty.c"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf ) 
{ int i ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 49
  i = openpty(ptyfd, ttyfd, namebuf, (void *)0, (void *)0);
#line 51
  if (i < 0) {
#line 53
    tmp = __errno_location();
#line 53
    tmp___0 = strerror(*tmp);
#line 53
    error("openpty: %.100s", tmp___0);
#line 54
    return (0);
  }
#line 57
  return (1);
}
}
#line 199 "pty.c"
void pty_release(char const   *ttyname___0 ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 201
  tmp___1 = chown(ttyname___0, 0U, 0U);
#line 201
  if (tmp___1 < 0) {
#line 202
    tmp = __errno_location();
#line 202
    tmp___0 = strerror(*tmp);
#line 202
    debug("chown %.100s 0 0 failed: %.100s", ttyname___0, tmp___0);
  }
#line 203
  tmp___4 = chmod(ttyname___0, 438U);
#line 203
  if (tmp___4 < 0) {
#line 204
    tmp___2 = __errno_location();
#line 204
    tmp___3 = strerror(*tmp___2);
#line 204
    debug("chmod %.100s 0666 failed: %.100s", ttyname___0, tmp___3);
  }
#line 205
  return;
}
}
#line 209 "pty.c"
void pty_make_controlling_tty(int *ttyfd , char const   *ttyname___0 ) 
{ int fd ;
  int *tmp ;
  char *tmp___0 ;
  __pid_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
#line 215
  fd = open("/dev/tty", 258);
#line 216
  if (fd >= 0) {
#line 218
    ioctl(fd, 21538UL, (void *)0);
#line 219
    close(fd);
  }
#line 222
  tmp___1 = setsid();
#line 222
  if (tmp___1 < 0) {
#line 223
    tmp = __errno_location();
#line 223
    tmp___0 = strerror(*tmp);
#line 223
    error("setsid: %.100s", tmp___0);
  }
#line 226
  fd = open("/dev/tty", 258);
#line 227
  if (fd >= 0) {
#line 229
    error("Failed to disconnect from controlling tty.");
#line 230
    close(fd);
  }
#line 235
  debug("Setting controlling tty using TIOCSCTTY.");
#line 238
  ioctl(*ttyfd, 21518UL, (void *)0);
#line 240
  fd = open(ttyname___0, 2);
#line 241
  if (fd < 0) {
#line 242
    tmp___2 = __errno_location();
#line 242
    tmp___3 = strerror(*tmp___2);
#line 242
    error("%.100s: %.100s", ttyname___0, tmp___3);
  } else {
#line 244
    close(fd);
  }
#line 247
  fd = open("/dev/tty", 1);
#line 248
  if (fd < 0) {
#line 249
    tmp___4 = __errno_location();
#line 249
    tmp___5 = strerror(*tmp___4);
#line 249
    error("open /dev/tty failed - could not set controlling tty: %.100s", tmp___5);
  } else {
#line 253
    close(fd);
  }
#line 255
  return;
}
}
#line 259 "pty.c"
void pty_change_window_size(int ptyfd , int row , int col , int xpixel , int ypixel ) 
{ struct winsize w ;

  {
#line 263
  w.ws_row = (unsigned short )row;
#line 264
  w.ws_col = (unsigned short )col;
#line 265
  w.ws_xpixel = (unsigned short )xpixel;
#line 266
  w.ws_ypixel = (unsigned short )ypixel;
#line 267
  ioctl(ptyfd, 21524UL, & w);
#line 268
  return;
}
}
#line 1 "log-server.o"
#pragma merger(0,"./log-server.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 175 "/usr/include/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 25 "log-server.c"
static int log_debug  =    0;
#line 26 "log-server.c"
static int log_quiet  =    0;
#line 27 "log-server.c"
static int log_on_stderr  =    0;
#line 36 "log-server.c"
void log_init(char *av0___0 , int on_stderr , int debug___0 , int quiet , SyslogFacility facility ) 
{ int log_facility ;

  {
#line 41
  switch ((int )facility) {
  case 0: 
#line 44
  log_facility = 3 << 3;
#line 45
  break;
  case 1: 
#line 47
  log_facility = 1 << 3;
#line 48
  break;
  case 2: 
#line 50
  log_facility = 4 << 3;
#line 51
  break;
  case 3: 
#line 53
  log_facility = 16 << 3;
#line 54
  break;
  case 4: 
#line 56
  log_facility = 17 << 3;
#line 57
  break;
  case 5: 
#line 59
  log_facility = 18 << 3;
#line 60
  break;
  case 6: 
#line 62
  log_facility = 19 << 3;
#line 63
  break;
  case 7: 
#line 65
  log_facility = 20 << 3;
#line 66
  break;
  case 8: 
#line 68
  log_facility = 21 << 3;
#line 69
  break;
  case 9: 
#line 71
  log_facility = 22 << 3;
#line 72
  break;
  case 10: 
#line 74
  log_facility = 23 << 3;
#line 75
  break;
  default: 
#line 77
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized internal syslog facility code %d\n",
          (int )facility);
#line 79
  exit(1);
  }
#line 82
  log_debug = debug___0;
#line 83
  log_quiet = quiet;
#line 84
  log_on_stderr = on_stderr;
#line 85
  closelog();
#line 86
  openlog((char const   *)av0___0, 1, log_facility);
#line 87
  return;
}
}
#line 95 "log-server.c"
void log(char const   *fmt  , ...) 
{ va_list args ;
  char msgbuf[1024] ;

  {
#line 99
  if (log_quiet) {
#line 100
    return;
  }
#line 101
  __builtin_va_start(args, fmt);
#line 102
  vsnprintf((char * __restrict  )(msgbuf), 1024U, (char const   * __restrict  )fmt,
            args);
#line 103
  __builtin_va_end(args);
#line 104
  if (log_on_stderr) {
#line 105
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"log: %s\n",
            msgbuf);
  }
#line 106
  syslog(6, "log: %.500s", msgbuf);
#line 107
  return;
}
}
#line 111 "log-server.c"
void debug(char const   *fmt  , ...) 
{ va_list args ;
  char msgbuf[1024] ;

  {
#line 115
  if (! log_debug) {
#line 116
    return;
  } else {
#line 115
    if (log_quiet) {
#line 116
      return;
    }
  }
#line 117
  __builtin_va_start(args, fmt);
#line 118
  vsnprintf((char * __restrict  )(msgbuf), 1024U, (char const   * __restrict  )fmt,
            args);
#line 119
  __builtin_va_end(args);
#line 120
  if (log_on_stderr) {
#line 121
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"debug: %s\n",
            msgbuf);
  }
#line 122
  syslog(7, "debug: %.500s", msgbuf);
#line 123
  return;
}
}
#line 127 "log-server.c"
void error(char const   *fmt  , ...) 
{ va_list args ;
  char msgbuf[1024] ;

  {
#line 131
  if (log_quiet) {
#line 132
    return;
  }
#line 133
  __builtin_va_start(args, fmt);
#line 134
  vsnprintf((char * __restrict  )(msgbuf), 1024U, (char const   * __restrict  )fmt,
            args);
#line 135
  __builtin_va_end(args);
#line 136
  if (log_on_stderr) {
#line 137
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"error: %s\n",
            msgbuf);
  }
#line 138
  syslog(3, "error: %.500s", msgbuf);
#line 139
  return;
}
}
#line 148 "log-server.c"
static struct fatal_cleanup *fatal_cleanups  =    (struct fatal_cleanup *)((void *)0);
#line 152 "log-server.c"
void fatal_add_cleanup(void (*proc)(void *context ) , void *context ) 
{ struct fatal_cleanup *cu ;
  void *tmp ;

  {
#line 156
  tmp = xmalloc(sizeof(*cu));
#line 156
  cu = (struct fatal_cleanup *)tmp;
#line 157
  cu->proc = proc;
#line 158
  cu->context = context;
#line 159
  cu->next = fatal_cleanups;
#line 160
  fatal_cleanups = cu;
#line 161
  return;
}
}
#line 165 "log-server.c"
void fatal_remove_cleanup(void (*proc)(void *context ) , void *context ) 
{ struct fatal_cleanup **cup ;
  struct fatal_cleanup *cu ;

  {
#line 169
  cup = & fatal_cleanups;
#line 169
  while (*cup) {
#line 171
    cu = *cup;
#line 172
    if ((unsigned int )cu->proc == (unsigned int )proc) {
#line 172
      if ((unsigned int )cu->context == (unsigned int )context) {
#line 174
        *cup = cu->next;
#line 175
        xfree((void *)cu);
#line 176
        return;
      }
    }
#line 169
    cup = & cu->next;
  }
#line 179
  fatal("fatal_remove_cleanup: no such cleanup function: 0x%lx 0x%lx\n", (unsigned long )proc,
        (unsigned long )context);
#line 181
  return;
}
}
#line 189 "log-server.c"
static int fatal_called  =    0;
#line 185 "log-server.c"
void fatal(char const   *fmt  , ...) 
{ va_list args ;
  struct fatal_cleanup *cu ;
  struct fatal_cleanup *next_cu ;
  char msgbuf[1024] ;

  {
#line 195
  if (log_quiet) {
#line 196
    exit(1);
  }
#line 197
  __builtin_va_start(args, fmt);
#line 198
  vsnprintf((char * __restrict  )(msgbuf), 1024U, (char const   * __restrict  )fmt,
            args);
#line 199
  __builtin_va_end(args);
#line 200
  if (log_on_stderr) {
#line 201
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"fatal: %s\n",
            msgbuf);
  }
#line 202
  syslog(3, "fatal: %.500s", msgbuf);
#line 204
  if (fatal_called) {
#line 205
    exit(1);
  }
#line 206
  fatal_called = 1;
#line 209
  cu = fatal_cleanups;
#line 209
  while (cu) {
#line 211
    next_cu = cu->next;
#line 212
    debug("Calling cleanup 0x%lx(0x%lx)", (unsigned long )cu->proc, (unsigned long )cu->context);
#line 214
    (*(cu->proc))(cu->context);
#line 209
    cu = next_cu;
  }
#line 230
  if (xauthfile) {
#line 230
    unlink((char const   *)xauthfile);
  }
#line 232
  exit(1);
}
}
#line 1 "login.o"
#pragma merger(0,"./login.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 187 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 46 "/usr/include/utmp.h"
extern  __attribute__((__nothrow__)) void login(struct utmp  const  *__entry ) ;
#line 49
extern  __attribute__((__nothrow__)) int logout(char const   *__ut_line ) ;
#line 52
extern  __attribute__((__nothrow__)) void logwtmp(char const   *__ut_line , char const   *__ut_name ,
                                                  char const   *__ut_host ) ;
#line 33 "login.c"
unsigned long get_last_login_time(uid_t uid , char const   *logname , char *buf ,
                                  unsigned int bufsize ) 
{ struct lastlog ll ;
  char *lastlog ;
  int fd ;
  ssize_t tmp ;

  {
#line 40
  lastlog = (char *)"/var/log/lastlog";
#line 42
  *(buf + 0) = (char )'\000';
#line 44
  fd = open((char const   *)lastlog, 0);
#line 45
  if (fd < 0) {
#line 46
    return (0UL);
  }
#line 47
  lseek(fd, (long )((unsigned long )((long )uid) * (unsigned long )sizeof(ll)), 0);
#line 48
  tmp = read(fd, (void *)(& ll), sizeof(ll));
#line 48
  if ((unsigned int )tmp != sizeof(ll)) {
#line 50
    close(fd);
#line 51
    return (0UL);
  }
#line 53
  close(fd);
#line 54
  if (bufsize > sizeof(ll.ll_host) + 1U) {
#line 55
    bufsize = sizeof(ll.ll_host) + 1U;
  }
#line 56
  __builtin_strncpy(buf, (char const   *)(ll.ll_host), bufsize - 1U);
#line 57
  *(buf + (bufsize - 1U)) = (char)0;
#line 58
  return ((unsigned long )ll.ll_time);
}
}
#line 64 "login.c"
void record_login(int pid , char const   *ttyname___0 , char const   *user , uid_t uid ,
                  char const   *host , struct sockaddr_in *addr ) 
{ int fd ;
  struct lastlog ll ;
  char *lastlog ;
  struct utmp u ;
  char const   *utmp ;
  char const   *wtmp ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 75
  memset((void *)(& u), 0, sizeof(u));
#line 76
  __builtin_strncpy(u.ut_line, ttyname___0 + 5, sizeof(u.ut_line));
#line 77
  u.ut_tv.tv_sec = time((time_t *)((void *)0));
#line 78
  __builtin_strncpy(u.ut_user, user, sizeof(u.ut_user));
#line 79
  __builtin_strncpy(u.ut_host, host, sizeof(u.ut_host));
#line 82
  utmp = "/var/run/utmp";
#line 83
  wtmp = "/var/log/wtmp";
#line 85
  login((struct utmp  const  *)(& u));
#line 87
  lastlog = (char *)"/var/log/lastlog";
#line 90
  if (0) {
#line 90
    __s1_len = strlen(user);
#line 90
    __s2_len = strlen("");
#line 90
    if (! ((unsigned int )((void const   *)(user + 1)) - (unsigned int )((void const   *)user) == 1U)) {
      goto _L___0;
    } else {
#line 90
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 90
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 90
          tmp___11 = 1;
        } else {
#line 90
          if (__s2_len >= 4U) {
#line 90
            tmp___11 = 1;
          } else {
#line 90
            tmp___11 = 0;
          }
        }
      } else {
#line 90
        tmp___11 = 0;
      }
    }
#line 90
    if (tmp___11) {
#line 90
      tmp___7 = __builtin_strcmp(user, "");
    } else {
#line 90
      tmp___10 = __builtin_strcmp(user, "");
#line 90
      tmp___7 = tmp___10;
    }
  } else {
#line 90
    tmp___10 = __builtin_strcmp(user, "");
#line 90
    tmp___7 = tmp___10;
  }
#line 90
  if (tmp___7 != 0) {
#line 94
    memset((void *)(& ll), 0, sizeof(ll));
#line 97
    ll.ll_time = time((time_t *)((void *)0));
#line 98
    __builtin_strncpy(ll.ll_line, ttyname___0 + 5, sizeof(ll.ll_line));
#line 99
    __builtin_strncpy(ll.ll_host, host, sizeof(ll.ll_host));
#line 100
    fd = open((char const   *)lastlog, 2);
#line 101
    if (fd >= 0) {
#line 103
      lseek(fd, (long )((unsigned long )((long )uid) * (unsigned long )sizeof(ll)),
            0);
#line 104
      tmp___1 = write(fd, (void const   *)(& ll), sizeof(ll));
#line 104
      if ((unsigned int )tmp___1 != sizeof(ll)) {
#line 105
        tmp = __errno_location();
#line 105
        tmp___0 = strerror(*tmp);
#line 105
        log("Could not write %.100s: %.100s", lastlog, tmp___0);
      }
#line 106
      close(fd);
    }
  }
#line 109
  return;
}
}
#line 113 "login.c"
void record_logout(int pid , char const   *ttyname___0 ) 
{ char const   *line ;
  int tmp ;

  {
#line 115
  line = ttyname___0 + 5;
#line 116
  tmp = logout(line);
#line 116
  if (tmp) {
#line 117
    logwtmp(line, "", "");
  }
#line 118
  return;
}
}
/* compiler builtin: 
   unsigned int __builtin_strspn(char const   * , char const   * ) ;  */
#line 1 "servconf.o"
#pragma merger(0,"./servconf.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 199 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strtok(char * __restrict  __s , char const   * __restrict  __delim )  __attribute__((__nonnull__(2))) ;
#line 270 "/usr/include/netdb.h"
extern void endservent(void) ;
#line 284
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 23 "servconf.c"
void initialize_server_options(ServerOptions *options___0 ) 
{ register unsigned int __v ;
  register unsigned int __x ;

  {
#line 25
  memset((void *)options___0, 0, sizeof(*options___0));
#line 26
  options___0->port = -1;
#line 27
  __x = 0U;
#line 27
  __asm__  ("rorw $8, %w0;"
            "rorl $16, %0;"
            "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 27
  options___0->listen_addr.s_addr = __v;
#line 28
  options___0->host_key_file = (char *)((void *)0);
#line 29
  options___0->server_key_bits = -1;
#line 30
  options___0->login_grace_time = -1;
#line 31
  options___0->key_regeneration_time = -1;
#line 32
  options___0->permit_root_login = -1;
#line 33
  options___0->ignore_rhosts = -1;
#line 34
  options___0->quiet_mode = -1;
#line 35
  options___0->fascist_logging = -1;
#line 36
  options___0->print_motd = -1;
#line 37
  options___0->check_mail = -1;
#line 38
  options___0->x11_forwarding = -1;
#line 39
  options___0->x11_display_offset = -1;
#line 40
  options___0->strict_modes = -1;
#line 41
  options___0->keepalives = -1;
#line 42
  options___0->log_facility = (enum __anonenum_SyslogFacility_74 )-1;
#line 43
  options___0->rhosts_authentication = -1;
#line 44
  options___0->rhosts_rsa_authentication = -1;
#line 45
  options___0->rsa_authentication = -1;
#line 55
  options___0->password_authentication = -1;
#line 59
  options___0->permit_empty_passwd = -1;
#line 60
  options___0->use_login = -1;
#line 61
  options___0->num_allow_users = 0U;
#line 62
  options___0->num_deny_users = 0U;
#line 63
  options___0->num_allow_groups = 0U;
#line 64
  options___0->num_deny_groups = 0U;
#line 65
  return;
}
}
#line 67 "servconf.c"
void fill_default_server_options(ServerOptions *options___0 ) 
{ struct servent *sp ;
  register unsigned short __v ;
  register unsigned short __x ;

  {
#line 69
  if (options___0->port == -1) {
#line 73
    sp = getservbyname("ssh", "tcp");
#line 74
    if (sp) {
#line 75
      __x = (unsigned short )sp->s_port;
#line 75
      __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 75
      options___0->port = (int )__v;
    } else {
#line 77
      options___0->port = 22;
    }
#line 78
    endservent();
  }
#line 80
  if ((unsigned int )options___0->host_key_file == (unsigned int )((void *)0)) {
#line 81
    options___0->host_key_file = (char *)"/usr/local/etc/ssh_host_key";
  }
#line 82
  if (options___0->server_key_bits == -1) {
#line 83
    options___0->server_key_bits = 768;
  }
#line 84
  if (options___0->login_grace_time == -1) {
#line 85
    options___0->login_grace_time = 600;
  }
#line 86
  if (options___0->key_regeneration_time == -1) {
#line 87
    options___0->key_regeneration_time = 3600;
  }
#line 88
  if (options___0->permit_root_login == -1) {
#line 89
    options___0->permit_root_login = 1;
  }
#line 90
  if (options___0->ignore_rhosts == -1) {
#line 91
    options___0->ignore_rhosts = 0;
  }
#line 92
  if (options___0->quiet_mode == -1) {
#line 93
    options___0->quiet_mode = 0;
  }
#line 94
  if (options___0->check_mail == -1) {
#line 95
    options___0->check_mail = 0;
  }
#line 96
  if (options___0->fascist_logging == -1) {
#line 97
    options___0->fascist_logging = 1;
  }
#line 98
  if (options___0->print_motd == -1) {
#line 99
    options___0->print_motd = 1;
  }
#line 100
  if (options___0->x11_forwarding == -1) {
#line 101
    options___0->x11_forwarding = 1;
  }
#line 102
  if (options___0->x11_display_offset == -1) {
#line 103
    options___0->x11_display_offset = 1;
  }
#line 104
  if (options___0->strict_modes == -1) {
#line 105
    options___0->strict_modes = 1;
  }
#line 106
  if (options___0->keepalives == -1) {
#line 107
    options___0->keepalives = 1;
  }
#line 108
  if ((int )options___0->log_facility == (int )((enum __anonenum_SyslogFacility_74 )-1)) {
#line 109
    options___0->log_facility = 2;
  }
#line 110
  if (options___0->rhosts_authentication == -1) {
#line 111
    options___0->rhosts_authentication = 0;
  }
#line 112
  if (options___0->rhosts_rsa_authentication == -1) {
#line 113
    options___0->rhosts_rsa_authentication = 1;
  }
#line 114
  if (options___0->rsa_authentication == -1) {
#line 115
    options___0->rsa_authentication = 1;
  }
#line 130
  if (options___0->password_authentication == -1) {
#line 131
    options___0->password_authentication = 1;
  }
#line 136
  if (options___0->permit_empty_passwd == -1) {
#line 137
    options___0->permit_empty_passwd = 1;
  }
#line 138
  if (options___0->use_login == -1) {
#line 139
    options___0->use_login = 0;
  }
#line 140
  return;
}
}
#line 167 "servconf.c"
static struct __anonstruct_keywords_77 keywords[29]  = 
#line 167
  {      {"port", 0}, 
        {"hostkey", 1}, 
        {"serverkeybits", 2}, 
        {"logingracetime", 3}, 
        {"keyregenerationinterval", 4}, 
        {"permitrootlogin", 5}, 
        {"quietmode", 6}, 
        {"fascistlogging", 7}, 
        {"syslogfacility", 8}, 
        {"rhostsauthentication", 9}, 
        {"rhostsrsaauthentication", 10}, 
        {"rsaauthentication", 11}, 
        {"passwordauthentication", 12}, 
        {"checkmail", 22}, 
        {"listenaddress", 13}, 
        {"printmotd", 14}, 
        {"ignorerhosts", 15}, 
        {"x11forwarding", 16}, 
        {"x11displayoffset", 17}, 
        {"strictmodes", 18}, 
        {"permitemptypasswords", 19}, 
        {"uselogin", 23}, 
        {"randomseed", 20}, 
        {"keepalive", 21}, 
        {"allowusers", 24}, 
        {"denyusers", 25}, 
        {"allowgroups", 26}, 
        {"denygroups", 27}, 
        {(char const   *)((void *)0), (ServerOpCodes )0}};
#line 216 "servconf.c"
static struct __anonstruct_log_facilities_78 log_facilities[12]  = 
#line 216
  {      {"DAEMON", 0}, 
        {"USER", 1}, 
        {"AUTH", 2}, 
        {"LOCAL0", 3}, 
        {"LOCAL1", 4}, 
        {"LOCAL2", 5}, 
        {"LOCAL3", 6}, 
        {"LOCAL4", 7}, 
        {"LOCAL5", 8}, 
        {"LOCAL6", 9}, 
        {"LOCAL7", 10}, 
        {(char const   *)((void *)0), (SyslogFacility )0}};
#line 239 "servconf.c"
static ServerOpCodes parse_token(char const   *cp , char const   *filename , int linenum ) 
{ unsigned int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 244
  i = 0U;
#line 244
  while (keywords[i].name) {
#line 245
    if (0) {
#line 245
      __s1_len = strlen(cp);
#line 245
      __s2_len = strlen(keywords[i].name);
#line 245
      if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
        goto _L___0;
      } else {
#line 245
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 245
          if (! ((unsigned int )((void const   *)(keywords[i].name + 1)) - (unsigned int )((void const   *)keywords[i].name) == 1U)) {
#line 245
            tmp___8 = 1;
          } else {
#line 245
            if (__s2_len >= 4U) {
#line 245
              tmp___8 = 1;
            } else {
#line 245
              tmp___8 = 0;
            }
          }
        } else {
#line 245
          tmp___8 = 0;
        }
      }
#line 245
      if (tmp___8) {
#line 245
        tmp___4 = __builtin_strcmp(cp, keywords[i].name);
      } else {
#line 245
        tmp___7 = __builtin_strcmp(cp, keywords[i].name);
#line 245
        tmp___4 = tmp___7;
      }
    } else {
#line 245
      tmp___7 = __builtin_strcmp(cp, keywords[i].name);
#line 245
      tmp___4 = tmp___7;
    }
#line 245
    if (tmp___4 == 0) {
#line 246
      return (keywords[i].opcode);
    }
#line 244
    i ++;
  }
#line 248
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: Bad configuration option: %s\n",
          filename, linenum, cp);
#line 250
  exit(1);
}
}
#line 255 "servconf.c"
void read_server_config(ServerOptions *options___0 , char const   *filename ) 
{ FILE *f ;
  char line[1024] ;
  char *cp ;
  char **charptr ;
  int linenum ;
  int *intptr ;
  int i ;
  int value ;
  ServerOpCodes opcode ;
  unsigned int tmp___30 ;
  char *t ;
  __uid_t tmp___31 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___37 ;
  int tmp___40 ;
  int tmp___41 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___47 ;
  int tmp___50 ;
  int tmp___51 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___57 ;
  int tmp___60 ;
  int tmp___61 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___67 ;
  int tmp___70 ;
  int tmp___71 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___77 ;
  int tmp___80 ;
  int tmp___81 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___87 ;
  int tmp___90 ;
  int tmp___91 ;
  unsigned int tmp___92 ;
  unsigned int tmp___93 ;
  unsigned int tmp___94 ;
  unsigned int tmp___95 ;
  char *tmp___96 ;
  char *tmp___97 ;

  {
#line 263
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 264
  if (! f) {
#line 266
    perror(filename);
#line 267
    exit(1);
  }
#line 270
  linenum = 0;
#line 271
  while (1) {
#line 271
    tmp___97 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 271
    if (! tmp___97) {
#line 271
      break;
    }
#line 273
    linenum ++;
#line 274
    tmp___30 = __builtin_strspn((char const   *)(line), " \t\r\n");
#line 274
    cp = line + tmp___30;
#line 275
    if (! *cp) {
#line 276
      continue;
    } else {
#line 275
      if ((int )*cp == 35) {
#line 276
        continue;
      }
    }
#line 277
    cp = strtok((char * __restrict  )cp, (char const   * __restrict  )" \t\r\n");
#line 279
    t = cp;
#line 280
    while ((int )*t != 0) {
#line 281
      if (65 <= (int )*t) {
#line 281
        if ((int )*t <= 90) {
#line 282
          *t = (char )(((int )*t - 65) + 97);
        }
      }
#line 280
      t ++;
    }
#line 285
    opcode = parse_token((char const   *)cp, filename, linenum);
#line 286
    switch ((int )opcode) {
    case 0: 
#line 289
    intptr = & options___0->port;
    parse_int: 
#line 291
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 292
    if (! cp) {
#line 294
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing integer value.\n",
              filename, linenum);
#line 296
      exit(1);
    }
#line 298
    value = atoi((char const   *)cp);
#line 299
    if (*intptr == -1) {
#line 300
      *intptr = value;
    }
#line 301
    break;
    case 2: 
#line 304
    intptr = & options___0->server_key_bits;
    goto parse_int;
    case 3: 
#line 308
    intptr = & options___0->login_grace_time;
    goto parse_int;
    case 4: 
#line 312
    intptr = & options___0->key_regeneration_time;
    goto parse_int;
    case 13: 
#line 316
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 317
    if (! cp) {
#line 319
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing inet addr.\n",
              filename, linenum);
#line 321
      exit(1);
    }
#line 323
    options___0->listen_addr.s_addr = inet_addr((char const   *)cp);
#line 324
    break;
    case 1: 
#line 327
    charptr = & options___0->host_key_file;
#line 328
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 329
    if (! cp) {
#line 331
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing file name.\n",
              filename, linenum);
#line 333
      exit(1);
    }
#line 335
    if ((unsigned int )*charptr == (unsigned int )((void *)0)) {
#line 336
      tmp___31 = getuid();
#line 336
      *charptr = tilde_expand_filename((char const   *)cp, tmp___31);
    }
#line 337
    break;
    case 20: 
#line 340
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: \"randomseed\" option is obsolete.\n",
            filename, linenum);
#line 342
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 343
    break;
    case 5: 
#line 346
    intptr = & options___0->permit_root_login;
#line 347
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 348
    if (! cp) {
#line 350
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing yes/without-password/no argument.\n",
              filename, linenum);
#line 352
      exit(1);
    }
#line 354
    if (0) {
#line 354
      __s1_len___1 = strlen((char const   *)cp);
#line 354
      __s2_len___1 = strlen("without-password");
#line 354
      if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
        goto _L___4;
      } else {
#line 354
        if (__s1_len___1 >= 4U) {
          _L___4: /* CIL Label */ 
#line 354
          if (! ((unsigned int )((void const   *)("without-password" + 1)) - (unsigned int )((void const   *)"without-password") == 1U)) {
#line 354
            tmp___61 = 1;
          } else {
#line 354
            if (__s2_len___1 >= 4U) {
#line 354
              tmp___61 = 1;
            } else {
#line 354
              tmp___61 = 0;
            }
          }
        } else {
#line 354
          tmp___61 = 0;
        }
      }
#line 354
      if (tmp___61) {
#line 354
        tmp___57 = __builtin_strcmp((char const   *)cp, "without-password");
      } else {
#line 354
        tmp___60 = __builtin_strcmp((char const   *)cp, "without-password");
#line 354
        tmp___57 = tmp___60;
      }
    } else {
#line 354
      tmp___60 = __builtin_strcmp((char const   *)cp, "without-password");
#line 354
      tmp___57 = tmp___60;
    }
#line 354
    if (tmp___57 == 0) {
#line 355
      value = 2;
    } else {
#line 356
      if (0) {
#line 356
        __s1_len___0 = strlen((char const   *)cp);
#line 356
        __s2_len___0 = strlen("yes");
#line 356
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___2;
        } else {
#line 356
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 356
            if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 356
              tmp___51 = 1;
            } else {
#line 356
              if (__s2_len___0 >= 4U) {
#line 356
                tmp___51 = 1;
              } else {
#line 356
                tmp___51 = 0;
              }
            }
          } else {
#line 356
            tmp___51 = 0;
          }
        }
#line 356
        if (tmp___51) {
#line 356
          tmp___47 = __builtin_strcmp((char const   *)cp, "yes");
        } else {
#line 356
          tmp___50 = __builtin_strcmp((char const   *)cp, "yes");
#line 356
          tmp___47 = tmp___50;
        }
      } else {
#line 356
        tmp___50 = __builtin_strcmp((char const   *)cp, "yes");
#line 356
        tmp___47 = tmp___50;
      }
#line 356
      if (tmp___47 == 0) {
#line 357
        value = 1;
      } else {
#line 358
        if (0) {
#line 358
          __s1_len = strlen((char const   *)cp);
#line 358
          __s2_len = strlen("no");
#line 358
          if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
            goto _L___0;
          } else {
#line 358
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 358
              if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 358
                tmp___41 = 1;
              } else {
#line 358
                if (__s2_len >= 4U) {
#line 358
                  tmp___41 = 1;
                } else {
#line 358
                  tmp___41 = 0;
                }
              }
            } else {
#line 358
              tmp___41 = 0;
            }
          }
#line 358
          if (tmp___41) {
#line 358
            tmp___37 = __builtin_strcmp((char const   *)cp, "no");
          } else {
#line 358
            tmp___40 = __builtin_strcmp((char const   *)cp, "no");
#line 358
            tmp___37 = tmp___40;
          }
        } else {
#line 358
          tmp___40 = __builtin_strcmp((char const   *)cp, "no");
#line 358
          tmp___37 = tmp___40;
        }
#line 358
        if (tmp___37 == 0) {
#line 359
          value = 0;
        } else {
#line 362
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: Bad yes/without-password/no argument: %s\n",
                  filename, linenum, cp);
#line 364
          exit(1);
        }
      }
    }
#line 366
    if (*intptr == -1) {
#line 367
      *intptr = value;
    }
#line 368
    break;
    case 15: 
#line 371
    intptr = & options___0->ignore_rhosts;
    parse_flag: 
#line 373
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 374
    if (! cp) {
#line 376
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing yes/no argument.\n",
              filename, linenum);
#line 378
      exit(1);
    }
#line 380
    if (0) {
#line 380
      __s1_len___3 = strlen((char const   *)cp);
#line 380
      __s2_len___3 = strlen("yes");
#line 380
      if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
        goto _L___8;
      } else {
#line 380
        if (__s1_len___3 >= 4U) {
          _L___8: /* CIL Label */ 
#line 380
          if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 380
            tmp___81 = 1;
          } else {
#line 380
            if (__s2_len___3 >= 4U) {
#line 380
              tmp___81 = 1;
            } else {
#line 380
              tmp___81 = 0;
            }
          }
        } else {
#line 380
          tmp___81 = 0;
        }
      }
#line 380
      if (tmp___81) {
#line 380
        tmp___77 = __builtin_strcmp((char const   *)cp, "yes");
      } else {
#line 380
        tmp___80 = __builtin_strcmp((char const   *)cp, "yes");
#line 380
        tmp___77 = tmp___80;
      }
    } else {
#line 380
      tmp___80 = __builtin_strcmp((char const   *)cp, "yes");
#line 380
      tmp___77 = tmp___80;
    }
#line 380
    if (tmp___77 == 0) {
#line 381
      value = 1;
    } else {
#line 383
      if (0) {
#line 383
        __s1_len___2 = strlen((char const   *)cp);
#line 383
        __s2_len___2 = strlen("no");
#line 383
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___6;
        } else {
#line 383
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 383
            if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 383
              tmp___71 = 1;
            } else {
#line 383
              if (__s2_len___2 >= 4U) {
#line 383
                tmp___71 = 1;
              } else {
#line 383
                tmp___71 = 0;
              }
            }
          } else {
#line 383
            tmp___71 = 0;
          }
        }
#line 383
        if (tmp___71) {
#line 383
          tmp___67 = __builtin_strcmp((char const   *)cp, "no");
        } else {
#line 383
          tmp___70 = __builtin_strcmp((char const   *)cp, "no");
#line 383
          tmp___67 = tmp___70;
        }
      } else {
#line 383
        tmp___70 = __builtin_strcmp((char const   *)cp, "no");
#line 383
        tmp___67 = tmp___70;
      }
#line 383
      if (tmp___67 == 0) {
#line 384
        value = 0;
      } else {
#line 387
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: Bad yes/no argument: %s\n",
                filename, linenum, cp);
#line 389
        exit(1);
      }
    }
#line 391
    if (*intptr == -1) {
#line 392
      *intptr = value;
    }
#line 393
    break;
    case 6: 
#line 396
    intptr = & options___0->quiet_mode;
    goto parse_flag;
    case 7: 
#line 400
    intptr = & options___0->fascist_logging;
    goto parse_flag;
    case 9: 
#line 404
    intptr = & options___0->rhosts_authentication;
    goto parse_flag;
    case 10: 
#line 408
    intptr = & options___0->rhosts_rsa_authentication;
    goto parse_flag;
    case 11: 
#line 412
    intptr = & options___0->rsa_authentication;
    goto parse_flag;
    case 12: 
#line 440
    intptr = & options___0->password_authentication;
    goto parse_flag;
    case 22: 
#line 444
    intptr = & options___0->check_mail;
    goto parse_flag;
    case 14: 
#line 454
    intptr = & options___0->print_motd;
    goto parse_flag;
    case 16: 
#line 458
    intptr = & options___0->x11_forwarding;
    goto parse_flag;
    case 17: 
#line 462
    intptr = & options___0->x11_display_offset;
    goto parse_int;
    case 18: 
#line 466
    intptr = & options___0->strict_modes;
    goto parse_flag;
    case 21: 
#line 470
    intptr = & options___0->keepalives;
    goto parse_flag;
    case 19: 
#line 474
    intptr = & options___0->permit_empty_passwd;
    goto parse_flag;
    case 23: 
#line 478
    intptr = & options___0->use_login;
    goto parse_flag;
    case 8: 
#line 482
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 483
    if (! cp) {
#line 485
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing facility name.\n",
              filename, linenum);
#line 487
      exit(1);
    }
#line 489
    i = 0;
#line 489
    while (log_facilities[i].name) {
#line 490
      if (0) {
#line 490
        __s1_len___4 = strlen(log_facilities[i].name);
#line 490
        __s2_len___4 = strlen((char const   *)cp);
#line 490
        if (! ((unsigned int )((void const   *)(log_facilities[i].name + 1)) - (unsigned int )((void const   *)log_facilities[i].name) == 1U)) {
          goto _L___10;
        } else {
#line 490
          if (__s1_len___4 >= 4U) {
            _L___10: /* CIL Label */ 
#line 490
            if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 490
              tmp___91 = 1;
            } else {
#line 490
              if (__s2_len___4 >= 4U) {
#line 490
                tmp___91 = 1;
              } else {
#line 490
                tmp___91 = 0;
              }
            }
          } else {
#line 490
            tmp___91 = 0;
          }
        }
#line 490
        if (tmp___91) {
#line 490
          tmp___87 = __builtin_strcmp(log_facilities[i].name, (char const   *)cp);
        } else {
#line 490
          tmp___90 = __builtin_strcmp(log_facilities[i].name, (char const   *)cp);
#line 490
          tmp___87 = tmp___90;
        }
      } else {
#line 490
        tmp___90 = __builtin_strcmp(log_facilities[i].name, (char const   *)cp);
#line 490
        tmp___87 = tmp___90;
      }
#line 490
      if (tmp___87 == 0) {
#line 491
        break;
      }
#line 489
      i ++;
    }
#line 492
    if (! log_facilities[i].name) {
#line 494
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: unsupported log facility %s\n",
              filename, linenum, cp);
#line 496
      exit(1);
    }
#line 498
    if ((int )options___0->log_facility == (int )((enum __anonenum_SyslogFacility_74 )-1)) {
#line 499
      options___0->log_facility = log_facilities[i].facility;
    }
#line 500
    break;
    case 24: 
#line 503
    while (1) {
#line 503
      cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 503
      if (! cp) {
#line 503
        break;
      }
#line 505
      if (options___0->num_allow_users >= 256U) {
#line 507
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: too many allow users.\n",
                filename, linenum);
#line 509
        exit(1);
      }
#line 511
      tmp___92 = options___0->num_allow_users;
#line 511
      (options___0->num_allow_users) ++;
#line 511
      options___0->allow_users[tmp___92] = xstrdup((char const   *)cp);
    }
#line 513
    break;
    case 25: 
#line 516
    while (1) {
#line 516
      cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 516
      if (! cp) {
#line 516
        break;
      }
#line 518
      if (options___0->num_deny_users >= 256U) {
#line 520
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: too many deny users.\n",
                filename, linenum);
#line 522
        exit(1);
      }
#line 524
      tmp___93 = options___0->num_deny_users;
#line 524
      (options___0->num_deny_users) ++;
#line 524
      options___0->deny_users[tmp___93] = xstrdup((char const   *)cp);
    }
#line 526
    break;
    case 26: 
#line 529
    while (1) {
#line 529
      cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 529
      if (! cp) {
#line 529
        break;
      }
#line 531
      if (options___0->num_allow_groups >= 256U) {
#line 533
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: too many allow groups.\n",
                filename, linenum);
#line 535
        exit(1);
      }
#line 537
      tmp___94 = options___0->num_allow_groups;
#line 537
      (options___0->num_allow_groups) ++;
#line 537
      options___0->allow_groups[tmp___94] = xstrdup((char const   *)cp);
    }
#line 539
    break;
    case 27: 
#line 542
    while (1) {
#line 542
      cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 542
      if (! cp) {
#line 542
        break;
      }
#line 544
      if (options___0->num_deny_groups >= 256U) {
#line 546
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: too many deny groups.\n",
                filename, linenum);
#line 548
        exit(1);
      }
#line 550
      tmp___95 = options___0->num_deny_groups;
#line 550
      (options___0->num_deny_groups) ++;
#line 550
      options___0->deny_groups[tmp___95] = xstrdup((char const   *)cp);
    }
#line 552
    break;
    default: 
#line 555
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: Missing handler for opcode %s (%d)\n",
            filename, linenum, cp, opcode);
#line 557
    exit(1);
    }
#line 559
    tmp___96 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 559
    if ((unsigned int )tmp___96 != (unsigned int )((void *)0)) {
#line 561
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: garbage at end of line.\n",
              filename, linenum);
#line 563
      exit(1);
    }
  }
#line 566
  fclose(f);
#line 567
  return;
}
}
#line 1 "serverloop.o"
#pragma merger(0,"./serverloop.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 24 "serverloop.c"
static Buffer stdin_buffer  ;
#line 25 "serverloop.c"
static Buffer stdout_buffer  ;
#line 26 "serverloop.c"
static Buffer stderr_buffer  ;
#line 27 "serverloop.c"
static int fdin  ;
#line 28 "serverloop.c"
static int fdout  ;
#line 30 "serverloop.c"
static int fderr  ;
#line 31 "serverloop.c"
static long stdin_bytes  =    0L;
#line 32 "serverloop.c"
static long stdout_bytes  =    0L;
#line 33 "serverloop.c"
static long stderr_bytes  =    0L;
#line 34 "serverloop.c"
static long fdout_bytes  =    0L;
#line 35 "serverloop.c"
static int stdin_eof  =    0;
#line 36 "serverloop.c"
static int fdout_eof  =    0;
#line 37 "serverloop.c"
static int fderr_eof  =    0;
#line 38 "serverloop.c"
static int connection_in___0  ;
#line 39 "serverloop.c"
static int connection_out___0  ;
#line 40 "serverloop.c"
static unsigned int buffer_high  ;
#line 41 "serverloop.c"
static int max_fd  ;
#line 46 "serverloop.c"
static int child_pid  ;
#line 47 "serverloop.c"
static int volatile   child_terminated  ;
#line 48 "serverloop.c"
static int volatile   child_wait_status  ;
#line 50 "serverloop.c"
void sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  int wait_pid ;
  union __anonunion_77 __constr_expr_0 ;
  union __anonunion_78 __constr_expr_1 ;
  int *tmp___0 ;

  {
#line 52
  tmp = __errno_location();
#line 52
  save_errno = *tmp;
#line 54
  debug("Received SIGCHLD.");
#line 55
  wait_pid = wait((union wait *)((int *)(& child_wait_status)));
#line 56
  if (wait_pid != -1) {
#line 58
    if (wait_pid != child_pid) {
#line 59
      error("Strange, got SIGCHLD and wait returned pid %d but child is %d", wait_pid,
            child_pid);
    }
#line 61
    __constr_expr_0.__in = child_wait_status;
#line 61
    if ((__constr_expr_0.__i & 127) == 0) {
#line 63
      child_terminated = (int volatile   )1;
    } else {
#line 61
      __constr_expr_1.__in = child_wait_status;
#line 61
      if ((int )((signed char )((__constr_expr_1.__i & 127) + 1)) >> 1 > 0) {
#line 63
        child_terminated = (int volatile   )1;
      }
    }
  }
#line 65
  signal(17, & sigchld_handler);
#line 66
  tmp___0 = __errno_location();
#line 66
  *tmp___0 = save_errno;
#line 67
  return;
}
}
#line 71 "serverloop.c"
void process_buffered_input_packets(void) 
{ int type ;
  char *data ;
  unsigned int data_len ;
  int row ;
  int col ;
  int xpixel ;
  int ypixel ;
  int payload_len ;
  int _p ;
  int _e ;
  int _p___0 ;
  int _e___0 ;
  int _p___1 ;
  int _e___1 ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int _p___2 ;
  int _e___2 ;
  int _p___3 ;
  int _e___3 ;
  int _p___4 ;
  int _e___4 ;
  int _p___5 ;
  int _e___5 ;

  {
#line 80
  while (1) {
#line 80
    type = packet_read_poll(& payload_len);
#line 80
    if (! (type != 0)) {
#line 80
      break;
    }
#line 82
    switch (type) {
    case 16: 
#line 86
    if (fdin == -1) {
#line 87
      break;
    }
#line 88
    data = packet_get_string(& data_len);
#line 89
    while (1) {
#line 89
      _p = payload_len;
#line 89
      _e = (int )(4U + data_len);
#line 89
      if (_p != _e) {
#line 89
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "serverloop.c",
            89);
#line 89
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 89
      break;
    }
#line 90
    buffer_append(& stdin_buffer, (char const   *)data, data_len);
#line 91
    memset((void *)data, 0, data_len);
#line 92
    xfree((void *)data);
#line 93
    break;
    case 19: 
#line 98
    debug("EOF received for stdin.");
#line 99
    while (1) {
#line 99
      _p___0 = payload_len;
#line 99
      _e___0 = 0;
#line 99
      if (_p___0 != _e___0) {
#line 99
        log("Packet integrity error (%d != %d) at %s:%d", _p___0, _e___0, "serverloop.c",
            99);
#line 99
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 99
      break;
    }
#line 100
    stdin_eof = 1;
#line 101
    break;
    case 11: 
#line 104
    debug("Window change received.");
#line 105
    while (1) {
#line 105
      _p___1 = payload_len;
#line 105
      _e___1 = 16;
#line 105
      if (_p___1 != _e___1) {
#line 105
        log("Packet integrity error (%d != %d) at %s:%d", _p___1, _e___1, "serverloop.c",
            105);
#line 105
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 105
      break;
    }
#line 106
    tmp = packet_get_int();
#line 106
    row = (int )tmp;
#line 107
    tmp___0 = packet_get_int();
#line 107
    col = (int )tmp___0;
#line 108
    tmp___1 = packet_get_int();
#line 108
    xpixel = (int )tmp___1;
#line 109
    tmp___2 = packet_get_int();
#line 109
    ypixel = (int )tmp___2;
#line 110
    if (fdin != -1) {
#line 111
      pty_change_window_size(fdin, row, col, xpixel, ypixel);
    }
#line 112
    break;
    case 29: 
#line 115
    debug("Received port open request.");
#line 116
    channel_input_port_open(payload_len);
#line 117
    break;
    case 21: 
#line 120
    debug("Received channel open confirmation.");
#line 121
    while (1) {
#line 121
      _p___2 = payload_len;
#line 121
      _e___2 = 8;
#line 121
      if (_p___2 != _e___2) {
#line 121
        log("Packet integrity error (%d != %d) at %s:%d", _p___2, _e___2, "serverloop.c",
            121);
#line 121
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 121
      break;
    }
#line 122
    channel_input_open_confirmation();
#line 123
    break;
    case 22: 
#line 126
    debug("Received channel open failure.");
#line 127
    while (1) {
#line 127
      _p___3 = payload_len;
#line 127
      _e___3 = 4;
#line 127
      if (_p___3 != _e___3) {
#line 127
        log("Packet integrity error (%d != %d) at %s:%d", _p___3, _e___3, "serverloop.c",
            127);
#line 127
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 127
      break;
    }
#line 128
    channel_input_open_failure();
#line 129
    break;
    case 23: 
#line 132
    channel_input_data(payload_len);
#line 133
    break;
    case 24: 
#line 136
    debug("Received channel close.");
#line 137
    while (1) {
#line 137
      _p___4 = payload_len;
#line 137
      _e___4 = 4;
#line 137
      if (_p___4 != _e___4) {
#line 137
        log("Packet integrity error (%d != %d) at %s:%d", _p___4, _e___4, "serverloop.c",
            137);
#line 137
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 137
      break;
    }
#line 138
    channel_input_close();
#line 139
    break;
    case 25: 
#line 142
    debug("Received channel close confirmation.");
#line 143
    while (1) {
#line 143
      _p___5 = payload_len;
#line 143
      _e___5 = 4;
#line 143
      if (_p___5 != _e___5) {
#line 143
        log("Packet integrity error (%d != %d) at %s:%d", _p___5, _e___5, "serverloop.c",
            143);
#line 143
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 143
      break;
    }
#line 144
    channel_input_close_confirmation();
#line 145
    break;
    default: 
#line 154
    packet_disconnect("Protocol error during session: type %d", type);
    }
  }
#line 158
  return;
}
}
#line 163 "serverloop.c"
void make_packets_from_stderr_data(void) 
{ int len ;
  unsigned int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
#line 168
  while (1) {
#line 168
    tmp___2 = buffer_len(& stderr_buffer);
#line 168
    if (tmp___2 > 0U) {
#line 168
      tmp___3 = packet_not_very_much_data_to_write();
#line 168
      if (! tmp___3) {
#line 168
        break;
      }
    } else {
#line 168
      break;
    }
#line 171
    tmp = buffer_len(& stderr_buffer);
#line 171
    len = (int )tmp;
#line 172
    tmp___0 = packet_is_interactive();
#line 172
    if (tmp___0) {
#line 174
      if (len > 512) {
#line 175
        len = 512;
      }
    } else {
#line 179
      if (len > 32768) {
#line 180
        len = 32768;
      }
    }
#line 182
    packet_start(18);
#line 183
    tmp___1 = buffer_ptr(& stderr_buffer);
#line 183
    packet_put_string((char const   *)tmp___1, (unsigned int )len);
#line 184
    packet_send();
#line 185
    buffer_consume(& stderr_buffer, (unsigned int )len);
#line 186
    stderr_bytes += (long )len;
  }
#line 188
  return;
}
}
#line 193 "serverloop.c"
void make_packets_from_stdout_data(void) 
{ int len ;
  unsigned int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
#line 198
  while (1) {
#line 198
    tmp___2 = buffer_len(& stdout_buffer);
#line 198
    if (tmp___2 > 0U) {
#line 198
      tmp___3 = packet_not_very_much_data_to_write();
#line 198
      if (! tmp___3) {
#line 198
        break;
      }
    } else {
#line 198
      break;
    }
#line 201
    tmp = buffer_len(& stdout_buffer);
#line 201
    len = (int )tmp;
#line 202
    tmp___0 = packet_is_interactive();
#line 202
    if (tmp___0) {
#line 204
      if (len > 512) {
#line 205
        len = 512;
      }
    } else {
#line 209
      if (len > 32768) {
#line 210
        len = 32768;
      }
    }
#line 212
    packet_start(17);
#line 213
    tmp___1 = buffer_ptr(& stdout_buffer);
#line 213
    packet_put_string((char const   *)tmp___1, (unsigned int )len);
#line 214
    packet_send();
#line 215
    buffer_consume(& stdout_buffer, (unsigned int )len);
#line 216
    stdout_bytes += (long )len;
  }
#line 218
  return;
}
}
#line 225 "serverloop.c"
void wait_until_can_do_something(fd_set *readset , fd_set *writeset , unsigned int max_time_milliseconds ) 
{ struct timeval tv ;
  struct timeval *tvp ;
  int ret ;
  int __d0 ;
  int __d1 ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int __d0___0 ;
  int __d1___0 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;

  {
  retry_select: 
#line 235
  while (1) {
#line 235
    __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readset->__fds_bits[0]): "memory");
#line 235
    break;
  }
#line 239
  tmp = buffer_len(& stdin_buffer);
#line 239
  if (tmp < 4096U) {
#line 239
    tmp___0 = channel_not_very_much_buffered_data();
#line 239
    if (tmp___0) {
#line 241
      __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
  }
#line 245
  tmp___1 = packet_not_very_much_data_to_write();
#line 245
  if (tmp___1) {
#line 247
    if (! fdout_eof) {
#line 248
      __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
#line 249
    if (! fderr_eof) {
#line 250
      __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
  }
#line 253
  while (1) {
#line 253
    __asm__  volatile   ("cld; rep; stosl": "=c" (__d0___0), "=D" (__d1___0): "a" (0),
                         "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& writeset->__fds_bits[0]): "memory");
#line 253
    break;
  }
#line 256
  channel_prepare_select(readset, writeset);
#line 260
  tmp___2 = packet_have_data_to_write();
#line 260
  if (tmp___2) {
#line 261
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 265
  if (fdin != -1) {
#line 265
    tmp___3 = buffer_len(& stdin_buffer);
#line 265
    if (tmp___3 > 0U) {
#line 266
      __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
  }
#line 269
  tmp___4 = channel_max_fd();
#line 269
  if (tmp___4 > max_fd) {
#line 270
    max_fd = channel_max_fd();
  }
#line 273
  if (child_terminated) {
#line 274
    if (max_time_milliseconds == 0U) {
#line 275
      max_time_milliseconds = 100U;
    }
  }
#line 277
  if (max_time_milliseconds == 0U) {
#line 278
    tvp = (struct timeval *)((void *)0);
  } else {
#line 281
    tv.tv_sec = (long )(max_time_milliseconds / 1000U);
#line 282
    tv.tv_usec = (long )(1000U * (max_time_milliseconds % 1000U));
#line 283
    tvp = & tv;
  }
#line 287
  ret = select(max_fd + 1, (fd_set * __restrict  )readset, (fd_set * __restrict  )writeset,
               (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )tvp);
#line 289
  if (ret < 0) {
#line 291
    tmp___7 = __errno_location();
#line 291
    if (*tmp___7 != 4) {
#line 292
      tmp___5 = __errno_location();
#line 292
      tmp___6 = strerror(*tmp___5);
#line 292
      error("select: %.100s", tmp___6);
    } else {
      goto retry_select;
    }
  }
#line 296
  return;
}
}
#line 301 "serverloop.c"
void process_input(fd_set *readset ) 
{ int len ;
  char buf[16384] ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  register char __result ;
  register char __result___0 ;
  register char __result___1 ;

  {
#line 307
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 307
  if (__result) {
#line 309
    len = read(connection_in___0, (void *)(buf), sizeof(buf));
#line 310
    if (len == 0) {
#line 311
      fatal("Connection closed by remote host.");
    }
#line 315
    if (len < 0) {
#line 315
      tmp = __errno_location();
#line 315
      if (*tmp == 11) {
#line 316
        len = 0;
      }
    }
#line 318
    if (len < 0) {
#line 319
      tmp___0 = __errno_location();
#line 319
      tmp___1 = strerror(*tmp___0);
#line 319
      fatal("Read error from remote host: %.100s", tmp___1);
    }
#line 322
    packet_process_incoming((char const   *)(buf), (unsigned int )len);
  }
#line 326
  if (! fdout_eof) {
#line 326
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "cc");
#line 326
    if (__result___0) {
#line 328
      len = read(fdout, (void *)(buf), sizeof(buf));
#line 329
      if (len <= 0) {
#line 330
        fdout_eof = 1;
      } else {
#line 333
        buffer_append(& stdout_buffer, (char const   *)(buf), (unsigned int )len);
#line 334
        fdout_bytes += (long )len;
      }
    }
  }
#line 339
  if (! fderr_eof) {
#line 339
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___1): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "cc");
#line 339
    if (__result___1) {
#line 341
      len = read(fderr, (void *)(buf), sizeof(buf));
#line 342
      if (len <= 0) {
#line 343
        fderr_eof = 1;
      } else {
#line 345
        buffer_append(& stderr_buffer, (char const   *)(buf), (unsigned int )len);
      }
    }
  }
#line 347
  return;
}
}
#line 351 "serverloop.c"
void process_output(fd_set *writeset ) 
{ int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  register char __result ;
  register char __result___0 ;

  {
#line 356
  if (fdin != -1) {
#line 356
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))),
                         "m" (writeset->__fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "cc");
#line 356
    if (__result) {
#line 358
      tmp = buffer_len(& stdin_buffer);
#line 358
      tmp___0 = buffer_ptr(& stdin_buffer);
#line 358
      len = write(fdin, (void const   *)tmp___0, tmp);
#line 360
      if (len <= 0) {
#line 363
        close(fdin);
#line 370
        fdin = -1;
      } else {
#line 375
        buffer_consume(& stdin_buffer, (unsigned int )len);
#line 377
        stdin_bytes += (long )len;
      }
    }
  }
#line 382
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->__fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 382
  if (__result___0) {
#line 383
    packet_write_poll();
  }
#line 384
  return;
}
}
#line 389 "serverloop.c"
void drain_output(void) 
{ unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;

  {
#line 392
  tmp___2 = buffer_len(& stdout_buffer);
#line 392
  if (tmp___2 > 0U) {
#line 394
    packet_start(17);
#line 395
    tmp = buffer_len(& stdout_buffer);
#line 395
    tmp___0 = buffer_ptr(& stdout_buffer);
#line 395
    packet_put_string((char const   *)tmp___0, tmp);
#line 397
    packet_send();
#line 399
    tmp___1 = buffer_len(& stdout_buffer);
#line 399
    stdout_bytes = (long )((unsigned long )stdout_bytes + (unsigned long )tmp___1);
  }
#line 403
  tmp___6 = buffer_len(& stderr_buffer);
#line 403
  if (tmp___6 > 0U) {
#line 405
    packet_start(18);
#line 406
    tmp___3 = buffer_len(& stderr_buffer);
#line 406
    tmp___4 = buffer_ptr(& stderr_buffer);
#line 406
    packet_put_string((char const   *)tmp___4, tmp___3);
#line 408
    packet_send();
#line 410
    tmp___5 = buffer_len(& stderr_buffer);
#line 410
    stderr_bytes = (long )((unsigned long )stderr_bytes + (unsigned long )tmp___5);
  }
#line 414
  packet_write_wait();
#line 415
  return;
}
}
#line 423 "serverloop.c"
void server_loop(int pid , int fdin_arg , int fdout_arg , int fderr_arg ) 
{ int wait_status ;
  int wait_pid ;
  int waiting_termination ;
  unsigned int max_time_milliseconds ;
  unsigned int previous_stdout_buffer_bytes ;
  unsigned int stdout_buffer_bytes ;
  int type ;
  int tmp ;
  fd_set readset ;
  fd_set writeset ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *s ;
  char *cp ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  union __anonunion_79 __constr_expr_0 ;
  union __anonunion_80 __constr_expr_1 ;
  int plen ;
  union __anonunion_81 __constr_expr_2 ;
  union __anonunion_82 __constr_expr_3 ;
  union __anonunion_83 __constr_expr_4 ;

  {
#line 426
  waiting_termination = 0;
#line 432
  debug("Entering interactive session.");
#line 435
  child_pid = pid;
#line 436
  child_terminated = (int volatile   )0;
#line 437
  signal(17, & sigchld_handler);
#line 440
  fdin = fdin_arg;
#line 441
  fdout = fdout_arg;
#line 442
  fderr = fderr_arg;
#line 443
  connection_in___0 = packet_get_connection_in();
#line 444
  connection_out___0 = packet_get_connection_out();
#line 446
  previous_stdout_buffer_bytes = 0U;
#line 449
  tmp = packet_is_interactive();
#line 449
  if (tmp) {
#line 450
    buffer_high = 4096U;
  } else {
#line 452
    buffer_high = 65536U;
  }
#line 455
  max_fd = fdin;
#line 456
  if (fdout > max_fd) {
#line 457
    max_fd = fdout;
  }
#line 458
  if (fderr != -1) {
#line 458
    if (fderr > max_fd) {
#line 459
      max_fd = fderr;
    }
  }
#line 460
  if (connection_in___0 > max_fd) {
#line 461
    max_fd = connection_in___0;
  }
#line 462
  if (connection_out___0 > max_fd) {
#line 463
    max_fd = connection_out___0;
  }
#line 466
  buffer_init(& stdin_buffer);
#line 467
  buffer_init(& stdout_buffer);
#line 468
  buffer_init(& stderr_buffer);
#line 474
  if (fderr == -1) {
#line 475
    fderr_eof = 1;
  }
#line 478
  while (1) {
#line 483
    process_buffered_input_packets();
#line 487
    if (stdin_eof) {
#line 487
      if (fdin != -1) {
#line 487
        tmp___0 = buffer_len(& stdin_buffer);
#line 487
        if (tmp___0 == 0U) {
#line 490
          close(fdin);
#line 497
          fdin = -1;
        }
      }
    }
#line 501
    make_packets_from_stderr_data();
#line 508
    max_time_milliseconds = 0U;
#line 509
    stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 510
    if (stdout_buffer_bytes != 0U) {
#line 510
      if (stdout_buffer_bytes < 256U) {
#line 510
        if (stdout_buffer_bytes != previous_stdout_buffer_bytes) {
#line 512
          max_time_milliseconds = 10U;
        } else {
#line 514
          make_packets_from_stdout_data();
        }
      } else {
#line 514
        make_packets_from_stdout_data();
      }
    } else {
#line 514
      make_packets_from_stdout_data();
    }
#line 515
    previous_stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 518
    tmp___1 = packet_not_very_much_data_to_write();
#line 518
    if (tmp___1) {
#line 519
      channel_output_poll();
    }
#line 524
    if (fdout_eof) {
#line 524
      if (fderr_eof) {
#line 524
        tmp___5 = packet_have_data_to_write();
#line 524
        if (! tmp___5) {
#line 524
          tmp___6 = buffer_len(& stdout_buffer);
#line 524
          if (tmp___6 == 0U) {
#line 524
            tmp___7 = buffer_len(& stderr_buffer);
#line 524
            if (tmp___7 == 0U) {
#line 527
              tmp___2 = channel_still_open();
#line 527
              if (! tmp___2) {
                goto quit;
              }
#line 529
              if (! waiting_termination) {
#line 531
                s = "Waiting for forwarded connections to terminate...\r\n";
#line 534
                waiting_termination = 1;
#line 535
                tmp___3 = strlen(s);
#line 535
                buffer_append(& stderr_buffer, s, tmp___3);
#line 538
                cp = channel_open_message();
#line 539
                tmp___4 = strlen((char const   *)cp);
#line 539
                buffer_append(& stderr_buffer, (char const   *)cp, tmp___4);
#line 540
                xfree((void *)cp);
              }
            }
          }
        }
      }
    }
#line 545
    wait_until_can_do_something(& readset, & writeset, max_time_milliseconds);
#line 549
    channel_after_select(& readset, & writeset);
#line 552
    process_input(& readset);
#line 555
    process_output(& writeset);
  }
  quit: 
#line 562
  drain_output();
#line 564
  debug("End of interactive session; stdin %ld, stdout (read %ld, sent %ld), stderr %ld bytes.",
        stdin_bytes, fdout_bytes, stdout_bytes, stderr_bytes);
#line 568
  buffer_free(& stdin_buffer);
#line 569
  buffer_free(& stdout_buffer);
#line 570
  buffer_free(& stderr_buffer);
#line 573
  if (fdout != -1) {
#line 574
    close(fdout);
  }
#line 575
  fdout = -1;
#line 576
  fdout_eof = 1;
#line 577
  if (fderr != -1) {
#line 578
    close(fderr);
  }
#line 579
  fderr = -1;
#line 580
  fderr_eof = 1;
#line 581
  if (fdin != -1) {
#line 582
    close(fdin);
  }
#line 583
  fdin = -1;
#line 586
  channel_stop_listening();
#line 589
  wait_pid = wait((union wait *)(& wait_status));
#line 590
  if (wait_pid < 0) {
#line 595
    if (child_terminated) {
#line 596
      wait_status = (int )child_wait_status;
    } else {
#line 598
      tmp___8 = __errno_location();
#line 598
      tmp___9 = strerror(*tmp___8);
#line 598
      packet_disconnect("wait: %.100s", tmp___9);
    }
  } else {
#line 603
    if (wait_pid != pid) {
#line 604
      error("Strange, wait returned pid %d, expected %d", wait_pid, pid);
    }
  }
#line 608
  signal(17, (void (*)(int  ))0);
#line 611
  __constr_expr_2.__in = wait_status;
#line 611
  if ((__constr_expr_2.__i & 127) == 0) {
#line 614
    __constr_expr_0.__in = wait_status;
#line 614
    debug("Command exited with status %d.", (__constr_expr_0.__i & 65280) >> 8);
#line 615
    packet_start(20);
#line 616
    __constr_expr_1.__in = wait_status;
#line 616
    packet_put_int((unsigned int )((__constr_expr_1.__i & 65280) >> 8));
#line 617
    packet_send();
#line 618
    packet_write_wait();
#line 624
    while (1) {
#line 627
      type = packet_read(& plen);
#line 624
      if (! (type != 33)) {
#line 624
        break;
      }
    }
#line 631
    debug("Received exit confirmation.");
#line 632
    return;
  }
#line 636
  __constr_expr_4.__in = wait_status;
#line 636
  if ((int )((signed char )((__constr_expr_4.__i & 127) + 1)) >> 1 > 0) {
#line 637
    __constr_expr_3.__in = wait_status;
#line 637
    packet_disconnect("Command terminated on signal %d.", __constr_expr_3.__i & 127);
  }
#line 641
  packet_disconnect("wait returned status %04x.", wait_status);
#line 643
  return;
}
}
#line 1 "strlcpy.o"
#pragma merger(0,"./strlcpy.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 45 "strlcpy.c"
size_t strlcpy(char *dst , char const   *src , size_t siz ) 
{ register char *d ;
  register char const   *s ;
  register size_t n___0 ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 50
  d = dst;
#line 51
  s = src;
#line 52
  n___0 = siz;
#line 55
  if (n___0 != 0U) {
#line 55
    n___0 --;
#line 55
    if (n___0 != 0U) {
#line 56
      while (1) {
#line 57
        tmp = d;
#line 57
        d ++;
#line 57
        tmp___0 = s;
#line 57
        s ++;
#line 57
        *tmp = (char )*tmp___0;
#line 57
        if ((int )*tmp == 0) {
#line 58
          break;
        }
#line 56
        n___0 --;
#line 56
        if (! (n___0 != 0U)) {
#line 56
          break;
        }
      }
    }
  }
#line 63
  if (n___0 == 0U) {
#line 64
    if (siz != 0U) {
#line 65
      *d = (char )'\000';
    }
#line 66
    while (1) {
#line 66
      tmp___1 = s;
#line 66
      s ++;
#line 66
      if (! *tmp___1) {
#line 66
        break;
      }
    }
  }
#line 70
  return ((unsigned int )((s - src) - 1));
}
}
#line 1 "rc4.o"
#pragma merger(0,"./rc4.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 99 "rc4.h"
void rc4_crypt(rc4_t *r , unsigned char *plaintext , int len ) ;
#line 50 "rc4.c"
void rc4_key(rc4_t *r , unsigned char *key , int len ) 
{ int t ;

  {
#line 54
  r->i = 0;
#line 54
  while (r->i < 256) {
#line 55
    r->s[r->i] = (unsigned int )r->i;
#line 54
    (r->i) ++;
  }
#line 57
  r->j = 0;
#line 58
  r->i = 0;
#line 58
  while (r->i < 256) {
#line 60
    r->j = (int )((((unsigned int )r->j + r->s[r->i]) + (unsigned int )*(key + r->i % len)) % 256U);
#line 61
    t = (int )r->s[r->i];
#line 62
    r->s[r->i] = r->s[r->j];
#line 63
    r->s[r->j] = (unsigned int )t;
#line 58
    (r->i) ++;
  }
#line 65
  r->j = 0;
#line 65
  r->i = r->j;
#line 66
  return;
}
}
#line 68 "rc4.c"
void rc4_crypt(rc4_t *r , unsigned char *plaintext , int len ) 
{ int t ;
  int c ;

  {
#line 73
  c = 0;
#line 74
  while (c < len) {
#line 76
    r->i = (r->i + 1) % 256;
#line 77
    r->j = (int )(((unsigned int )r->j + r->s[r->i]) % 256U);
#line 78
    t = (int )r->s[r->i];
#line 79
    r->s[r->i] = r->s[r->j];
#line 80
    r->s[r->j] = (unsigned int )t;
#line 82
    t = (int )((r->s[r->i] + r->s[r->j]) % 256U);
#line 84
    *(plaintext + c) = (unsigned char )((unsigned int )*(plaintext + c) ^ r->s[t]);
#line 85
    c ++;
  }
#line 87
  return;
}
}
#line 89 "rc4.c"
void rc4_getbytes(rc4_t *r , unsigned char *buffer , int len ) 
{ int t ;
  int c ;

  {
#line 94
  c = 0;
#line 95
  while (c < len) {
#line 97
    r->i = (r->i + 1) % 256;
#line 98
    r->j = (int )(((unsigned int )r->j + r->s[r->i]) % 256U);
#line 99
    t = (int )r->s[r->i];
#line 100
    r->s[r->i] = r->s[r->j];
#line 101
    r->s[r->j] = (unsigned int )t;
#line 103
    t = (int )((r->s[r->i] + r->s[r->j]) % 256U);
#line 105
    *(buffer + c) = (unsigned char )r->s[t];
#line 106
    c ++;
  }
#line 108
  return;
}
}
