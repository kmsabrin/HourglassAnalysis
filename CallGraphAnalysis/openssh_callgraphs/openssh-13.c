/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

#line 214 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stddef.h"
typedef unsigned int size_t;
#line 71 "/usr/include/openssl/rc4.h"
struct rc4_key_st {
   unsigned int x ;
   unsigned int y ;
   unsigned int data[256] ;
};
#line 71 "/usr/include/openssl/rc4.h"
typedef struct rc4_key_st RC4_KEY;
#line 34 "/usr/include/bits/types.h"
typedef unsigned char __u_char;
#line 35 "/usr/include/sys/types.h"
typedef __u_char u_char;
#line 45 "/usr/include/bits/types.h"
typedef unsigned int __uint32_t;
#line 195 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 202 "/usr/include/sys/types.h"
typedef unsigned short u_int16_t;
#line 36 "/usr/include/bits/socket.h"
typedef __socklen_t socklen_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 145 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 162 "/usr/include/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   __uint32_t __ss_align ;
   char __ss_padding[128U - 2U * sizeof(__uint32_t )] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 92 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 136 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 137 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 193 "/usr/include/netinet/in.h"
union __anonunion_in6_u_21 {
   uint8_t u6_addr8[16] ;
   uint16_t u6_addr16[8] ;
   uint32_t u6_addr32[4] ;
};
#line 193 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion_in6_u_21 in6_u ;
};
#line 219 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 233 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 35 "/usr/include/bits/types.h"
typedef unsigned short __u_short;
#line 36 "/usr/include/bits/types.h"
typedef unsigned int __u_int;
#line 60 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 137 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 143 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 144 "/usr/include/bits/types.h"
typedef long __off_t;
#line 152 "/usr/include/bits/types.h"
typedef long __time_t;
#line 167 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 172 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 36 "/usr/include/sys/types.h"
typedef __u_short u_short;
#line 37 "/usr/include/sys/types.h"
typedef __u_int u_int;
#line 121 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 49 "./openbsd-compat/glob.h"
struct __anonstruct_glob_t_62 {
   int gl_pathc ;
   int gl_matchc ;
   int gl_offs ;
   int gl_flags ;
   char **gl_pathv ;
   int (*gl_errfunc)(char const   * , int  ) ;
   void (*gl_closedir)(void * ) ;
   struct dirent *(*gl_readdir)(void * ) ;
   void *(*gl_opendir)(char const   * ) ;
   int (*gl_lstat)(char const   * , struct stat * ) ;
   int (*gl_stat)(char const   * , struct stat * ) ;
};
#line 49 "./openbsd-compat/glob.h"
typedef struct __anonstruct_glob_t_62 glob_t;
#line 114 "openbsd-compat/glob.c"
typedef u_short Char;
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 183 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 30 "/usr/include/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 107 "/usr/include/openssl/ossl_typ.h"
struct bignum_st;
#line 107 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_st BIGNUM;
#line 108
struct bignum_ctx;
#line 108 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_ctx BN_CTX;
#line 109
struct bn_blinding_st;
#line 109 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_blinding_st BN_BLINDING;
#line 110
struct bn_mont_ctx_st;
#line 110 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_mont_ctx_st BN_MONT_CTX;
#line 112
struct bn_gencb_st;
#line 112 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_gencb_st BN_GENCB;
#line 125
struct dsa_st;
#line 125 "/usr/include/openssl/ossl_typ.h"
typedef struct dsa_st DSA;
#line 126
struct dsa_method;
#line 126 "/usr/include/openssl/ossl_typ.h"
typedef struct dsa_method DSA_METHOD;
#line 128
struct rsa_st;
#line 128 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_st RSA;
#line 129
struct rsa_meth_st;
#line 129 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_meth_st RSA_METHOD;
#line 154
struct engine_st;
#line 154 "/usr/include/openssl/ossl_typ.h"
typedef struct engine_st ENGINE;
#line 165
struct crypto_ex_data_st;
#line 165 "/usr/include/openssl/ossl_typ.h"
typedef struct crypto_ex_data_st CRYPTO_EX_DATA;
#line 66 "/usr/include/openssl/stack.h"
struct stack_st {
   int num ;
   char **data ;
   int sorted ;
   int num_alloc ;
   int (*comp)(char const   * const  * , char const   * const  * ) ;
};
#line 66 "/usr/include/openssl/stack.h"
typedef struct stack_st STACK;
#line 283 "/usr/include/openssl/crypto.h"
struct crypto_ex_data_st {
   STACK *sk ;
   int dummy ;
};
#line 285 "/usr/include/openssl/bn.h"
struct bignum_st {
   unsigned long *d ;
   int top ;
   int dmax ;
   int neg ;
   int flags ;
};
#line 296 "/usr/include/openssl/bn.h"
struct bn_mont_ctx_st {
   int ri ;
   BIGNUM RR ;
   BIGNUM N ;
   BIGNUM Ni ;
   unsigned long n0 ;
   int flags ;
};
#line 320 "/usr/include/openssl/bn.h"
union __anonunion_cb_64 {
   void (*cb_1)(int  , int  , void * ) ;
   int (*cb_2)(int  , int  , BN_GENCB * ) ;
};
#line 320 "/usr/include/openssl/bn.h"
struct bn_gencb_st {
   unsigned int ver ;
   void *arg ;
   union __anonunion_cb_64 cb ;
};
#line 85 "/usr/include/openssl/rsa.h"
struct rsa_meth_st {
   char const   *name ;
   int (*rsa_pub_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_pub_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_priv_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_priv_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_mod_exp)(BIGNUM *r0 , BIGNUM const   *I , RSA *rsa , BN_CTX *ctx ) ;
   int (*bn_mod_exp)(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(RSA *rsa ) ;
   int (*finish)(RSA *rsa ) ;
   int flags ;
   char *app_data ;
   int (*rsa_sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
                   unsigned int *siglen , RSA const   *rsa ) ;
   int (*rsa_verify)(int dtype , unsigned char const   *m , unsigned int m_length ,
                     unsigned char *sigbuf , unsigned int siglen , RSA const   *rsa ) ;
   int (*rsa_keygen)(RSA *rsa , int bits , BIGNUM *e , BN_GENCB *cb ) ;
};
#line 128 "/usr/include/openssl/rsa.h"
struct rsa_st {
   int pad ;
   long version ;
   RSA_METHOD const   *meth ;
   ENGINE *engine ;
   BIGNUM *n ;
   BIGNUM *e ;
   BIGNUM *d ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *dmp1 ;
   BIGNUM *dmq1 ;
   BIGNUM *iqmp ;
   CRYPTO_EX_DATA ex_data ;
   int references ;
   int flags ;
   BN_MONT_CTX *_method_mod_n ;
   BN_MONT_CTX *_method_mod_p ;
   BN_MONT_CTX *_method_mod_q ;
   char *bignum_data ;
   BN_BLINDING *blinding ;
   BN_BLINDING *mt_blinding ;
};
#line 19 "buffer.h"
struct __anonstruct_Buffer_67 {
   char *buf ;
   u_int alloc ;
   u_int offset ;
   u_int end ;
};
#line 19 "buffer.h"
typedef struct __anonstruct_Buffer_67 Buffer;
#line 106 "/usr/include/openssl/dsa.h"
struct DSA_SIG_st {
   BIGNUM *r ;
   BIGNUM *s ;
};
#line 106 "/usr/include/openssl/dsa.h"
typedef struct DSA_SIG_st DSA_SIG;
#line 112 "/usr/include/openssl/dsa.h"
struct dsa_method {
   char const   *name ;
   DSA_SIG *(*dsa_do_sign)(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
   int (*dsa_sign_setup)(DSA *dsa , BN_CTX *ctx_in , BIGNUM **kinvp , BIGNUM **rp ) ;
   int (*dsa_do_verify)(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                        DSA *dsa ) ;
   int (*dsa_mod_exp)(DSA *dsa , BIGNUM *rr , BIGNUM *a1 , BIGNUM *p1 , BIGNUM *a2 ,
                      BIGNUM *p2 , BIGNUM *m , BN_CTX *ctx , BN_MONT_CTX *in_mont ) ;
   int (*bn_mod_exp)(DSA *dsa , BIGNUM *r , BIGNUM *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DSA *dsa ) ;
   int (*finish)(DSA *dsa ) ;
   int flags ;
   char *app_data ;
   int (*dsa_paramgen)(DSA *dsa , int bits , unsigned char *seed , int seed_len ,
                       int *counter_ret , unsigned long *h_ret , BN_GENCB *cb ) ;
   int (*dsa_keygen)(DSA *dsa ) ;
};
#line 139 "/usr/include/openssl/dsa.h"
struct dsa_st {
   int pad ;
   long version ;
   int write_params ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *g ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   BIGNUM *kinv ;
   BIGNUM *r ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DSA_METHOD const   *meth ;
   ENGINE *engine ;
};
#line 32 "key.h"
struct Key;
#line 32 "key.h"
typedef struct Key Key;
#line 47 "key.h"
struct Key {
   int type ;
   RSA *rsa ;
   DSA *dsa ;
};
#line 47 "authfd.h"
struct __anonstruct_AuthenticationConnection_68 {
   int fd ;
   Buffer identities ;
   int howmany ;
};
#line 47 "authfd.h"
typedef struct __anonstruct_AuthenticationConnection_68 AuthenticationConnection;
#line 59 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 145 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 88 "/usr/include/sys/types.h"
typedef __off_t off_t;
#line 203 "/usr/include/sys/types.h"
typedef unsigned int u_int32_t;
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 177 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 183 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 268 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/openssl/ossl_typ.h"
struct asn1_string_st;
#line 79 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_INTEGER;
#line 80 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_ENUMERATED;
#line 81 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_BIT_STRING;
#line 82 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_OCTET_STRING;
#line 83 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_PRINTABLESTRING;
#line 84 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_T61STRING;
#line 85 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_IA5STRING;
#line 86 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_GENERALSTRING;
#line 87 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UNIVERSALSTRING;
#line 88 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_BMPSTRING;
#line 89 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UTCTIME;
#line 91 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_GENERALIZEDTIME;
#line 92 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_VISIBLESTRING;
#line 93 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UTF8STRING;
#line 94 "/usr/include/openssl/ossl_typ.h"
typedef int ASN1_BOOLEAN;
#line 116
struct evp_cipher_st;
#line 116 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_cipher_st EVP_CIPHER;
#line 117
struct evp_cipher_ctx_st;
#line 117 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_cipher_ctx_st EVP_CIPHER_CTX;
#line 120
struct evp_pkey_st;
#line 120 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_pkey_st EVP_PKEY;
#line 122
struct dh_st;
#line 122 "/usr/include/openssl/ossl_typ.h"
typedef struct dh_st DH;
#line 123
struct dh_method;
#line 123 "/usr/include/openssl/ossl_typ.h"
typedef struct dh_method DH_METHOD;
#line 206 "/usr/include/openssl/asn1.h"
struct asn1_object_st {
   char const   *sn ;
   char const   *ln ;
   int nid ;
   int length ;
   unsigned char *data ;
   int flags ;
};
#line 206 "/usr/include/openssl/asn1.h"
typedef struct asn1_object_st ASN1_OBJECT;
#line 222 "/usr/include/openssl/asn1.h"
struct asn1_string_st {
   int length ;
   int type ;
   unsigned char *data ;
   long flags ;
};
#line 222 "/usr/include/openssl/asn1.h"
typedef struct asn1_string_st ASN1_STRING;
#line 488 "/usr/include/openssl/asn1.h"
union __anonunion_value_65 {
   char *ptr ;
   ASN1_BOOLEAN boolean ;
   ASN1_STRING *asn1_string ;
   ASN1_OBJECT *object ;
   ASN1_INTEGER *integer ;
   ASN1_ENUMERATED *enumerated ;
   ASN1_BIT_STRING *bit_string ;
   ASN1_OCTET_STRING *octet_string ;
   ASN1_PRINTABLESTRING *printablestring ;
   ASN1_T61STRING *t61string ;
   ASN1_IA5STRING *ia5string ;
   ASN1_GENERALSTRING *generalstring ;
   ASN1_BMPSTRING *bmpstring ;
   ASN1_UNIVERSALSTRING *universalstring ;
   ASN1_UTCTIME *utctime ;
   ASN1_GENERALIZEDTIME *generalizedtime ;
   ASN1_VISIBLESTRING *visiblestring ;
   ASN1_UTF8STRING *utf8string ;
   ASN1_STRING *set ;
   ASN1_STRING *sequence ;
};
#line 488 "/usr/include/openssl/asn1.h"
struct asn1_type_st {
   int type ;
   union __anonunion_value_65 value ;
};
#line 488 "/usr/include/openssl/asn1.h"
typedef struct asn1_type_st ASN1_TYPE;
#line 126 "/usr/include/openssl/evp.h"
union __anonunion_pkey_66 {
   char *ptr ;
   struct rsa_st *rsa ;
   struct dsa_st *dsa ;
   struct dh_st *dh ;
};
#line 126 "/usr/include/openssl/evp.h"
struct evp_pkey_st {
   int type ;
   int save_type ;
   int references ;
   union __anonunion_pkey_66 pkey ;
   int save_parameters ;
   STACK *attributes ;
};
#line 297 "/usr/include/openssl/evp.h"
struct evp_cipher_st {
   int nid ;
   int block_size ;
   int key_len ;
   int iv_len ;
   unsigned long flags ;
   int (*init)(EVP_CIPHER_CTX *ctx , unsigned char const   *key , unsigned char const   *iv ,
               int enc ) ;
   int (*do_cipher)(EVP_CIPHER_CTX *ctx , unsigned char *out , unsigned char const   *in ,
                    unsigned int inl ) ;
   int (*cleanup)(EVP_CIPHER_CTX * ) ;
   int ctx_size ;
   int (*set_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*get_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*ctrl)(EVP_CIPHER_CTX * , int type , int arg , void *ptr ) ;
   void *app_data ;
};
#line 357 "/usr/include/openssl/evp.h"
struct evp_cipher_ctx_st {
   EVP_CIPHER const   *cipher ;
   ENGINE *engine ;
   int encrypt ;
   int buf_len ;
   unsigned char oiv[16] ;
   unsigned char iv[16] ;
   unsigned char buf[32] ;
   int num ;
   void *app_data ;
   int key_len ;
   unsigned long flags ;
   void *cipher_data ;
   int final_used ;
   int block_mask ;
   unsigned char final[32] ;
};
#line 95 "/usr/include/openssl/dh.h"
struct dh_method {
   char const   *name ;
   int (*generate_key)(DH *dh ) ;
   int (*compute_key)(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
   int (*bn_mod_exp)(DH const   *dh , BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p ,
                     BIGNUM const   *m , BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DH *dh ) ;
   int (*finish)(DH *dh ) ;
   int flags ;
   char *app_data ;
   int (*generate_params)(DH *dh , int prime_len , int generator , BN_GENCB *cb ) ;
};
#line 113 "/usr/include/openssl/dh.h"
struct dh_st {
   int pad ;
   int version ;
   BIGNUM *p ;
   BIGNUM *g ;
   long length ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   BIGNUM *q ;
   BIGNUM *j ;
   unsigned char *seed ;
   int seedlen ;
   BIGNUM *counter ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DH_METHOD const   *meth ;
   ENGINE *engine ;
};
#line 529 "/usr/include/openssl/pem.h"
typedef int pem_password_cb(char *buf , int size , int rwflag , void *userdata );
#line 78 "/usr/include/openssl/des.h"
typedef unsigned char DES_cblock[8];
#line 83 "/usr/include/openssl/des.h"
union __anonunion_ks_73 {
   DES_cblock cblock ;
   unsigned long deslong[2] ;
};
#line 83 "/usr/include/openssl/des.h"
struct DES_ks {
   union __anonunion_ks_73 ks[16] ;
};
#line 83 "/usr/include/openssl/des.h"
typedef struct DES_ks DES_key_schedule;
#line 101 "/usr/include/openssl/blowfish.h"
struct bf_key_st {
   unsigned int P[18] ;
   unsigned int S[1024] ;
};
#line 80 "/usr/include/openssl/cast.h"
struct cast_key_st {
   unsigned long data[32] ;
   int short_key ;
};
#line 80 "/usr/include/openssl/cast.h"
typedef struct cast_key_st CAST_KEY;
#line 26 "rijndael.h"
typedef u_int32_t u4byte;
#line 32 "rijndael.h"
struct _rijndael_ctx {
   u4byte k_len ;
   int decrypt ;
   u4byte e_key[64] ;
   u4byte d_key[64] ;
};
#line 32 "rijndael.h"
typedef struct _rijndael_ctx rijndael_ctx;
#line 62 "cipher.h"
struct Cipher;
#line 62 "cipher.h"
typedef struct Cipher Cipher;
#line 63
struct CipherContext;
#line 63 "cipher.h"
typedef struct CipherContext CipherContext;
#line 65 "cipher.h"
struct __anonstruct_des_76 {
   DES_key_schedule key ;
   DES_cblock iv ;
};
#line 65 "cipher.h"
struct __anonstruct_des3_77 {
   DES_key_schedule key1 ;
   DES_key_schedule key2 ;
   DES_cblock iv2 ;
   DES_key_schedule key3 ;
   DES_cblock iv3 ;
};
#line 65 "cipher.h"
struct __anonstruct_bf_78 {
   struct bf_key_st key ;
   u_char iv[8] ;
};
#line 65 "cipher.h"
struct __anonstruct_cast_79 {
   CAST_KEY key ;
   u_char iv[8] ;
};
#line 65 "cipher.h"
struct __anonstruct_rijndael_80 {
   u4byte iv[4] ;
   rijndael_ctx enc ;
   rijndael_ctx dec ;
};
#line 65 "cipher.h"
union __anonunion_u_75 {
   struct __anonstruct_des_76 des ;
   struct __anonstruct_des3_77 des3 ;
   struct __anonstruct_bf_78 bf ;
   struct __anonstruct_cast_79 cast ;
   struct __anonstruct_rijndael_80 rijndael ;
   RC4_KEY rc4 ;
};
#line 65 "cipher.h"
struct CipherContext {
   union __anonunion_u_75 u ;
   Cipher *cipher ;
};
#line 95 "cipher.h"
struct Cipher {
   char *name ;
   int number ;
   u_int block_size ;
   u_int key_len ;
   void (*setkey)(CipherContext * , u_char const   * , u_int  ) ;
   void (*setiv)(CipherContext * , u_char const   * , u_int  ) ;
   void (*encrypt)(CipherContext * , u_char * , u_char const   * , u_int  ) ;
   void (*decrypt)(CipherContext * , u_char * , u_char const   * , u_int  ) ;
};
#line 204 "/usr/include/sys/types.h"
typedef unsigned long long u_int64_t;
#line 44 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 321 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 538 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 146 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 201 "/usr/include/sys/types.h"
typedef unsigned char u_int8_t;
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024U / (8U * sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 85 "/usr/include/sys/select.h"
typedef __fd_mask fd_mask;
#line 314 "/usr/include/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 25 "/usr/include/bits/termios.h"
typedef unsigned char cc_t;
#line 26 "/usr/include/bits/termios.h"
typedef unsigned int speed_t;
#line 27 "/usr/include/bits/termios.h"
typedef unsigned int tcflag_t;
#line 30 "/usr/include/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 63 "channels.h"
struct Channel;
#line 64 "channels.h"
typedef struct Channel Channel;
#line 66 "channels.h"
typedef void channel_callback_fn(int id , void *arg );
#line 67 "channels.h"
typedef int channel_filter_fn(struct Channel *c , char *buf , int len );
#line 69 "channels.h"
struct Channel {
   int type ;
   int self ;
   int remote_id ;
   int istate ;
   int ostate ;
   int flags ;
   int rfd ;
   int wfd ;
   int efd ;
   int sock ;
   int isatty ;
   Buffer input ;
   Buffer output ;
   Buffer extended ;
   char path[200] ;
   int listening_port ;
   int host_port ;
   char *remote_name ;
   int remote_window ;
   int remote_maxpacket ;
   int local_window ;
   int local_window_max ;
   int local_consumed ;
   int local_maxpacket ;
   int extended_usage ;
   char *ctype ;
   channel_callback_fn *cb_fn ;
   void *cb_arg ;
   int cb_event ;
   channel_callback_fn *dettach_user ;
   channel_filter_fn *input_filter ;
};
#line 75 "nchan.h"
typedef void chan_event_fn(Channel *c );
#line 114 "channels.c"
struct __anonstruct_ForwardPermission_70 {
   char *host_to_connect ;
   u_short port_to_connect ;
   u_short listen_port ;
};
#line 114 "channels.c"
typedef struct __anonstruct_ForwardPermission_70 ForwardPermission;
#line 346 "channels.c"
typedef void chan_fn(Channel *c , fd_set *readset , fd_set *writeset );
#line 552 "channels.c"
struct __anonstruct_s4_req_71 {
   u_int8_t version ;
   u_int8_t command ;
   u_int16_t dest_port ;
   struct in_addr dest_addr ;
};
#line 79 "/usr/include/openssl/des.h"
typedef unsigned char const_DES_cblock[8];
#line 101 "/usr/include/openssl/blowfish.h"
typedef struct bf_key_st BF_KEY;
#line 99 "/usr/include/openssl/md5.h"
struct MD5state_st {
   unsigned int A ;
   unsigned int B ;
   unsigned int C ;
   unsigned int D ;
   unsigned int Nl ;
   unsigned int Nh ;
   unsigned int data[16] ;
   unsigned int num ;
};
#line 99 "/usr/include/openssl/md5.h"
typedef struct MD5state_st MD5_CTX;
#line 148 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 28 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024U / (8U * sizeof(unsigned long ))] ;
};
#line 28 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 33 "/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__kill_26 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__timer_27 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__rt_28 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_29 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_30 {
   void *si_addr ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_31 {
   long si_band ;
   int si_fd ;
};
#line 51 "/usr/include/bits/siginfo.h"
union __anonunion__sifields_25 {
   int _pad[128U / sizeof(int ) - 3U] ;
   struct __anonstruct__kill_26 _kill ;
   struct __anonstruct__timer_27 _timer ;
   struct __anonstruct__rt_28 _rt ;
   struct __anonstruct__sigchld_29 _sigchld ;
   struct __anonstruct__sigfault_30 _sigfault ;
   struct __anonstruct__sigpoll_31 _sigpoll ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_25 _sifields ;
};
#line 51 "/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 25 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_43 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_43 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 44 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 343 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *buffer ;
   unsigned long allocated ;
   unsigned long used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 407 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 410 "/usr/include/regex.h"
typedef int regoff_t;
#line 434 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_64 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 434 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_64 regmatch_t;
#line 66 "compat.c"
struct __anonstruct_check_68 {
   char *pat ;
   int bugs ;
};
#line 261 "/usr/include/zconf.h"
typedef unsigned char Byte;
#line 263 "/usr/include/zconf.h"
typedef unsigned int uInt;
#line 264 "/usr/include/zconf.h"
typedef unsigned long uLong;
#line 270 "/usr/include/zconf.h"
typedef Byte Bytef;
#line 279 "/usr/include/zconf.h"
typedef void *voidpf;
#line 80 "/usr/include/zlib.h"
struct internal_state;
#line 82 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 82 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 103 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 1346 "/usr/include/zlib.h"
struct internal_state {
   int dummy ;
};
#line 29 "dh.h"
struct dhgroup {
   int size ;
   BIGNUM *g ;
   BIGNUM *p ;
};
#line 31 "dispatch.h"
typedef void dispatch_fn(int type , int plen , void *ctxt );
#line 118 "/usr/include/openssl/ossl_typ.h"
struct env_md_st;
#line 118 "/usr/include/openssl/ossl_typ.h"
typedef struct env_md_st EVP_MD;
#line 119
struct env_md_ctx_st;
#line 119 "/usr/include/openssl/ossl_typ.h"
typedef struct env_md_ctx_st EVP_MD_CTX;
#line 220 "/usr/include/openssl/evp.h"
struct env_md_st {
   int type ;
   int pkey_type ;
   int md_size ;
   unsigned long flags ;
   int (*init)(EVP_MD_CTX *ctx ) ;
   int (*update)(EVP_MD_CTX *ctx , void const   *data , size_t count ) ;
   int (*final)(EVP_MD_CTX *ctx , unsigned char *md ) ;
   int (*copy)(EVP_MD_CTX *to , EVP_MD_CTX const   *from ) ;
   int (*cleanup)(EVP_MD_CTX *ctx ) ;
   int (*sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
               unsigned int *siglen , void *key ) ;
   int (*verify)(int type , unsigned char const   *m , unsigned int m_length , unsigned char const   *sigbuf ,
                 unsigned int siglen , void *key ) ;
   int required_pkey_type[5] ;
   int block_size ;
   int ctx_size ;
};
#line 280 "/usr/include/openssl/evp.h"
struct env_md_ctx_st {
   EVP_MD const   *digest ;
   ENGINE *engine ;
   unsigned long flags ;
   void *md_data ;
};
#line 75 "/usr/include/openssl/hmac.h"
struct hmac_ctx_st {
   EVP_MD const   *md ;
   EVP_MD_CTX md_ctx ;
   EVP_MD_CTX i_ctx ;
   EVP_MD_CTX o_ctx ;
   unsigned int key_length ;
   unsigned char key[128] ;
};
#line 75 "/usr/include/openssl/hmac.h"
typedef struct hmac_ctx_st HMAC_CTX;
#line 65 "kex.h"
struct Mac;
#line 65 "kex.h"
typedef struct Mac Mac;
#line 77 "kex.h"
struct Mac {
   char *name ;
   int enabled ;
   EVP_MD *md ;
   int mac_len ;
   u_char *key ;
   int key_len ;
};
#line 37 "mac.c"
struct __anonstruct_macs_78 {
   char *name ;
   EVP_MD *(*mdfunc)(void) ;
   int truncatebits ;
};
#line 26 "hostfile.h"
enum __anonenum_HostStatus_66 {
    HOST_OK = 0,
    HOST_NEW = 1,
    HOST_CHANGED = 2
} ;
#line 26 "hostfile.h"
typedef enum __anonenum_HostStatus_66 HostStatus;
#line 39 "key.h"
enum fp_type {
    SSH_FP_SHA1 = 0,
    SSH_FP_MD5 = 1
} ;
#line 43
enum fp_rep {
    SSH_FP_HEX = 0,
    SSH_FP_BUBBLEBABBLE = 1
} ;
#line 64 "kex.h"
struct Kex;
#line 64 "kex.h"
typedef struct Kex Kex;
#line 66
struct Comp;
#line 66 "kex.h"
typedef struct Comp Comp;
#line 67
struct Enc;
#line 67 "kex.h"
typedef struct Enc Enc;
#line 68
struct Newkeys;
#line 68 "kex.h"
typedef struct Newkeys Newkeys;
#line 70 "kex.h"
struct Enc {
   char *name ;
   Cipher *cipher ;
   int enabled ;
   u_char *key ;
   u_char *iv ;
};
#line 85 "kex.h"
struct Comp {
   int type ;
   int enabled ;
   char *name ;
};
#line 90 "kex.h"
struct Newkeys {
   Enc enc ;
   Mac mac ;
   Comp comp ;
};
#line 95 "kex.h"
struct Kex {
   u_char *session_id ;
   int session_id_len ;
   Newkeys *newkeys[2] ;
   int we_need ;
   int server ;
   char *name ;
   int hostkey_type ;
   int kex_type ;
   Buffer my ;
   Buffer peer ;
   int done ;
   int flags ;
   char *client_version_string ;
   char *server_version_string ;
   int (*check_host_key)(Key *hostkey ) ;
   Key *(*load_host_key)(int type ) ;
};
#line 43 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 105 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 21 "log.h"
enum __anonenum_SyslogFacility_63 {
    SYSLOG_FACILITY_DAEMON = 0,
    SYSLOG_FACILITY_USER = 1,
    SYSLOG_FACILITY_AUTH = 2,
    SYSLOG_FACILITY_AUTHPRIV = 3,
    SYSLOG_FACILITY_LOCAL0 = 4,
    SYSLOG_FACILITY_LOCAL1 = 5,
    SYSLOG_FACILITY_LOCAL2 = 6,
    SYSLOG_FACILITY_LOCAL3 = 7,
    SYSLOG_FACILITY_LOCAL4 = 8,
    SYSLOG_FACILITY_LOCAL5 = 9,
    SYSLOG_FACILITY_LOCAL6 = 10,
    SYSLOG_FACILITY_LOCAL7 = 11
} ;
#line 21 "log.h"
typedef enum __anonenum_SyslogFacility_63 SyslogFacility;
#line 38
enum __anonenum_LogLevel_64 {
    SYSLOG_LEVEL_QUIET = 0,
    SYSLOG_LEVEL_FATAL = 1,
    SYSLOG_LEVEL_ERROR = 2,
    SYSLOG_LEVEL_INFO = 3,
    SYSLOG_LEVEL_VERBOSE = 4,
    SYSLOG_LEVEL_DEBUG1 = 5,
    SYSLOG_LEVEL_DEBUG2 = 6,
    SYSLOG_LEVEL_DEBUG3 = 7
} ;
#line 38 "log.h"
typedef enum __anonenum_LogLevel_64 LogLevel;
#line 53 "log.c"
struct __anonstruct_log_facilities_65 {
   char const   *name ;
   SyslogFacility val ;
};
#line 74 "log.c"
struct __anonstruct_log_levels_66 {
   char const   *name ;
   LogLevel val ;
};
#line 188 "log.c"
struct fatal_cleanup {
   struct fatal_cleanup *next ;
   void (*proc)(void * ) ;
   void *context ;
};
#line 33 "misc.h"
typedef void (*mysig_t)(int  );
#line 154 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 24 "rijndael.h"
typedef u_int8_t u1byte;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 75 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 36 "servconf.h"
struct __anonstruct_ServerOptions_68 {
   u_int num_ports ;
   u_int ports_from_cmdline ;
   u_short ports[256] ;
   char *listen_addr ;
   struct addrinfo *listen_addrs ;
   char *host_key_files[256] ;
   int num_host_key_files ;
   char *pid_file ;
   int server_key_bits ;
   int login_grace_time ;
   int key_regeneration_time ;
   int permit_root_login ;
   int ignore_rhosts ;
   int ignore_user_known_hosts ;
   int print_motd ;
   int print_lastlog ;
   int check_mail ;
   int x11_forwarding ;
   int x11_display_offset ;
   char *xauth_location ;
   int strict_modes ;
   int keepalives ;
   char *ciphers ;
   char *macs ;
   int protocol ;
   int gateway_ports ;
   SyslogFacility log_facility ;
   LogLevel log_level ;
   int rhosts_authentication ;
   int rhosts_rsa_authentication ;
   int hostbased_authentication ;
   int hostbased_uses_name_from_packet_only ;
   int rsa_authentication ;
   int pubkey_authentication ;
   int password_authentication ;
   int kbd_interactive_authentication ;
   int challenge_reponse_authentication ;
   int permit_empty_passwd ;
   int use_login ;
   int allow_tcp_forwarding ;
   u_int num_allow_users ;
   char *allow_users[256] ;
   u_int num_deny_users ;
   char *deny_users[256] ;
   u_int num_allow_groups ;
   char *allow_groups[256] ;
   u_int num_deny_groups ;
   char *deny_groups[256] ;
   u_int num_subsystems ;
   char *subsystem_name[256] ;
   char *subsystem_command[256] ;
   int max_startups_begin ;
   int max_startups_rate ;
   int max_startups ;
   char *banner ;
   int reverse_mapping_check ;
   int client_alive_interval ;
   int client_alive_count_max ;
   int pam_authentication_via_kbd_int ;
};
#line 36 "servconf.h"
typedef struct __anonstruct_ServerOptions_68 ServerOptions;
#line 155 "sshd.c"
struct __anonstruct_sensitive_data_80 {
   Key *server_key ;
   Key *ssh1_host_key ;
   Key **host_keys ;
   int have_ssh1_key ;
   int have_ssh2_key ;
   u_char ssh1_cookie[32] ;
};
#line 77 "/usr/include/time.h"
typedef __time_t time_t;
#line 40 "/usr/include/shadow.h"
struct spwd {
   char *sp_namp ;
   char *sp_pwdp ;
   long sp_lstchg ;
   long sp_min ;
   long sp_max ;
   long sp_warn ;
   long sp_inact ;
   long sp_expire ;
   unsigned long sp_flag ;
};
#line 38 "auth.h"
struct Authctxt;
#line 38 "auth.h"
typedef struct Authctxt Authctxt;
#line 39 "auth.h"
struct Authctxt {
   int success ;
   int postponed ;
   int valid ;
   int attempt ;
   int failures ;
   char *user ;
   char *service ;
   struct passwd *pw ;
   char *style ;
};
#line 37 "/usr/include/bits/types.h"
typedef unsigned long __u_long;
#line 38 "/usr/include/sys/types.h"
typedef __u_long u_long;
#line 67 "auth2.c"
struct Authmethod;
#line 67 "auth2.c"
typedef struct Authmethod Authmethod;
#line 68 "auth2.c"
struct Authmethod {
   char *name ;
   int (*userauth)(Authctxt *authctxt ) ;
   int *enabled ;
};
#line 20 "auth-options.h"
struct envstring {
   struct envstring *next ;
   char *s ;
};
#line 28 "/usr/include/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 43 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 53 "loginrec.h"
union login_netinfo {
   struct sockaddr sa ;
   struct sockaddr_in sa_in ;
   struct sockaddr_storage sa_storage ;
};
#line 73 "loginrec.h"
struct logininfo {
   char progname[64] ;
   int progname_null ;
   short type ;
   int pid ;
   int uid ;
   char line[64] ;
   char username[64] ;
   char hostname[256] ;
   int exit ;
   int termination ;
   unsigned int tv_sec ;
   unsigned int tv_usec ;
   union login_netinfo hostaddr ;
};
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 38 "/usr/include/bits/utmp.h"
struct lastlog {
   __time_t ll_time ;
   char ll_line[32] ;
   char ll_host[256] ;
};
#line 52 "/usr/include/bits/utmp.h"
struct exit_status {
   short e_termination ;
   short e_exit ;
};
#line 60 "/usr/include/bits/utmp.h"
struct utmp {
   short ut_type ;
   pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct exit_status ut_exit ;
   long ut_session ;
   struct timeval ut_tv ;
   int32_t ut_addr_v6[4] ;
   char __unused[20] ;
};
#line 216 "servconf.c"
enum __anonenum_ServerOpCodes_79 {
    sBadOption = 0,
    sPort = 1,
    sHostKeyFile = 2,
    sServerKeyBits = 3,
    sLoginGraceTime = 4,
    sKeyRegenerationTime = 5,
    sPermitRootLogin = 6,
    sLogFacility = 7,
    sLogLevel = 8,
    sRhostsAuthentication = 9,
    sRhostsRSAAuthentication = 10,
    sRSAAuthentication = 11,
    sChallengeResponseAuthentication = 12,
    sPasswordAuthentication = 13,
    sKbdInteractiveAuthentication = 14,
    sListenAddress = 15,
    sPrintMotd = 16,
    sPrintLastLog = 17,
    sIgnoreRhosts = 18,
    sX11Forwarding = 19,
    sX11DisplayOffset = 20,
    sStrictModes = 21,
    sEmptyPasswd = 22,
    sKeepAlives = 23,
    sCheckMail = 24,
    sUseLogin = 25,
    sAllowTcpForwarding = 26,
    sAllowUsers = 27,
    sDenyUsers = 28,
    sAllowGroups = 29,
    sDenyGroups = 30,
    sIgnoreUserKnownHosts = 31,
    sCiphers = 32,
    sMacs = 33,
    sProtocol = 34,
    sPidFile = 35,
    sGatewayPorts = 36,
    sPubkeyAuthentication = 37,
    sXAuthLocation = 38,
    sSubsystem = 39,
    sMaxStartups = 40,
    sBanner = 41,
    sReverseMappingCheck = 42,
    sHostbasedAuthentication = 43,
    sHostbasedUsesNameFromPacketOnly = 44,
    sClientAliveInterval = 45,
    sClientAliveCountMax = 46,
    sPAMAuthenticationViaKbdInt = 47
} ;
#line 216 "servconf.c"
typedef enum __anonenum_ServerOpCodes_79 ServerOpCodes;
#line 242 "servconf.c"
struct __anonstruct_keywords_80 {
   char const   *name ;
   ServerOpCodes opcode ;
};
#line 63 "/usr/include/sys/wait.h"
union wait;
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_terminated_46 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_stopped_47 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_46 __wait_terminated ;
   struct __anonstruct___wait_stopped_47 __wait_stopped ;
};
#line 108 "serverloop.c"
union __anonunion_80 {
   int volatile   __in ;
   int __i ;
};
#line 108 "serverloop.c"
union __anonunion_81 {
   int volatile   __in ;
   int __i ;
};
#line 662 "serverloop.c"
union __anonunion_82 {
   int __in ;
   int __i ;
};
#line 664 "serverloop.c"
union __anonunion_83 {
   int __in ;
   int __i ;
};
#line 660 "serverloop.c"
union __anonunion_84 {
   int __in ;
   int __i ;
};
#line 686 "serverloop.c"
union __anonunion_85 {
   int __in ;
   int __i ;
};
#line 685 "serverloop.c"
union __anonunion_86 {
   int __in ;
   int __i ;
};
#line 99 "session.c"
struct Session;
#line 99 "session.c"
typedef struct Session Session;
#line 100 "session.c"
struct Session {
   int used ;
   int self ;
   struct passwd *pw ;
   pid_t pid ;
   char *term ;
   int ptyfd ;
   int ttyfd ;
   int ptymaster ;
   int row ;
   int col ;
   int xpixel ;
   int ypixel ;
   char tty[64] ;
   char *display ;
   int screen ;
   char *auth_proto ;
   char *auth_data ;
   int single_connection ;
   int chanid ;
   int is_subsystem ;
};
#line 1933 "session.c"
union __anonunion_70 {
   int __in ;
   int __i ;
};
#line 1938 "session.c"
union __anonunion_71 {
   int __in ;
   int __i ;
};
#line 1940 "session.c"
union __anonunion_72 {
   int __in ;
   int __i ;
};
#line 1935 "session.c"
union __anonunion_73 {
   int __in ;
   int __i ;
};
#line 1930 "session.c"
union __anonunion_74 {
   int __in ;
   int __i ;
};
#line 1 "bsd-arc4random.o"
#pragma merger(0,"./bsd-arc4random.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 59 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 33 "./openbsd-compat/bsd-arc4random.h"
unsigned int arc4random(void) ;
#line 34
void arc4random_stir(void) ;
#line 30 "./entropy.h"
void seed_rng(void) ;
#line 59 "./log.h"
void ( /* format attribute */  fatal)(char const   *fmt  , ...) ;
#line 102 "/usr/include/openssl/rand.h"
extern int RAND_bytes(unsigned char *buf , int num ) ;
#line 79 "/usr/include/openssl/rc4.h"
extern void RC4_set_key(RC4_KEY *key , int len , unsigned char const   *data ) ;
#line 80
extern void RC4(RC4_KEY *key , unsigned long len , unsigned char const   *indata ,
                unsigned char *outdata ) ;
#line 258 "/usr/include/openssl/err.h"
extern unsigned long ERR_get_error(void) ;
#line 42 "openbsd-compat/bsd-arc4random.c"
static int rc4_ready  =    0;
#line 43 "openbsd-compat/bsd-arc4random.c"
static RC4_KEY rc4  ;
#line 48 "openbsd-compat/bsd-arc4random.c"
static int first_time  =    1;
#line 45 "openbsd-compat/bsd-arc4random.c"
unsigned int arc4random(void) 
{ unsigned int r ;

  {
#line 47
  r = 0U;
#line 50
  if (rc4_ready <= 0) {
#line 51
    if (! first_time) {
#line 52
      seed_rng();
    }
#line 53
    first_time = 0;
#line 54
    arc4random_stir();
  }
#line 57
  RC4(& rc4, (unsigned long )sizeof(r), (unsigned char const   *)((unsigned char *)(& r)),
      (unsigned char *)(& r));
#line 59
  rc4_ready = (int )((unsigned int )rc4_ready - sizeof(r));
#line 61
  return (r);
}
}
#line 64 "openbsd-compat/bsd-arc4random.c"
void arc4random_stir(void) 
{ unsigned char rand_buf[20] ;
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 68
  memset((void *)(& rc4), 0, sizeof(rc4));
#line 69
  tmp___0 = RAND_bytes(rand_buf, (int )sizeof(rand_buf));
#line 69
  if (! tmp___0) {
#line 70
    tmp = ERR_get_error();
#line 70
    fatal("Couldn\'t obtain random bytes (error %ld)", tmp);
  }
#line 72
  RC4_set_key(& rc4, (int )sizeof(rand_buf), (unsigned char const   *)(rand_buf));
#line 73
  memset((void *)(rand_buf), 0, sizeof(rand_buf));
#line 75
  rc4_ready = 1 << 24;
#line 76
  return;
}
}
#line 1 "bsd-cygwin_util.o"
#pragma merger(0,"./bsd-cygwin_util.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "bsd-misc.o"
#pragma merger(0,"./bsd-misc.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 828 "/usr/include/unistd.h"
 __attribute__((__nothrow__)) int setlogin(char const   *name )  __attribute__((__nonnull__(1))) ;
#line 32 "./openbsd-compat/bsd-misc.h"
char *get_progname(char *argv0___0 ) ;
#line 34 "openbsd-compat/bsd-misc.c"
extern char *__progname ;
#line 31 "openbsd-compat/bsd-misc.c"
char *get_progname(char *argv0___0 ) 
{ 

  {
#line 36
  return (__progname);
}
}
#line 52
 __attribute__((__nothrow__)) int setlogin(char const   *name )  __attribute__((__nonnull__(1))) ;
#line 52 "openbsd-compat/bsd-misc.c"
int setlogin(char const   *name ) 
{ 

  {
#line 54
  return (0);
}
}
#line 1 "bsd-nextstep.o"
#pragma merger(0,"./bsd-nextstep.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "bsd-snprintf.o"
#pragma merger(0,"./bsd-snprintf.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "bsd-waitpid.o"
#pragma merger(0,"./bsd-waitpid.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "vis.o"
#pragma merger(0,"./vis.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 31 "./openbsd-compat/vis.h"
char *vis(char *dst , int c , int flag , int nextc ) ;
#line 54 "openbsd-compat/vis.c"
char *vis(char *dst , int c , int flag , int nextc ) 
{ char *tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  unsigned short const   **tmp___33 ;

  {
#line 56
  if ((unsigned int )c <= 255U) {
#line 56
    if (((int )((unsigned char )c) & -128) == 0) {
#line 56
      tmp___1 = __ctype_b_loc();
#line 56
      if ((int const   )*(*tmp___1 + (int )((unsigned char )c)) & 32768) {
        goto _L___0;
      } else {
        goto _L___5;
      }
    } else {
      goto _L___5;
    }
  } else {
    _L___5: /* CIL Label */ 
#line 56
    if ((flag & 4) == 0) {
#line 56
      if (c == 32) {
        goto _L___0;
      } else {
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
#line 56
      if ((flag & 8) == 0) {
#line 56
        if (c == 9) {
          goto _L___0;
        } else {
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
#line 56
        if ((flag & 16) == 0) {
#line 56
          if (c == 10) {
            goto _L___0;
          } else {
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
#line 56
          if (flag & 32) {
#line 56
            if (c == 8) {
              goto _L___0;
            } else {
#line 56
              if (c == 7) {
                goto _L___0;
              } else {
#line 56
                if (c == 13) {
                  _L___0: /* CIL Label */ 
#line 57
                  tmp = dst;
#line 57
                  dst ++;
#line 57
                  *tmp = (char )c;
#line 58
                  if (c == 92) {
#line 58
                    if ((flag & 64) == 0) {
#line 59
                      tmp___0 = dst;
#line 59
                      dst ++;
#line 59
                      *tmp___0 = (char )'\\';
                    }
                  }
#line 60
                  *dst = (char )'\000';
#line 61
                  return (dst);
                }
              }
            }
          }
        }
      }
    }
  }
#line 64
  if (flag & 2) {
#line 65
    switch (c) {
    case 10: 
#line 67
    tmp___2 = dst;
#line 67
    dst ++;
#line 67
    *tmp___2 = (char )'\\';
#line 68
    tmp___3 = dst;
#line 68
    dst ++;
#line 68
    *tmp___3 = (char )'n';
    goto done;
    case 13: 
#line 71
    tmp___4 = dst;
#line 71
    dst ++;
#line 71
    *tmp___4 = (char )'\\';
#line 72
    tmp___5 = dst;
#line 72
    dst ++;
#line 72
    *tmp___5 = (char )'r';
    goto done;
    case 8: 
#line 75
    tmp___6 = dst;
#line 75
    dst ++;
#line 75
    *tmp___6 = (char )'\\';
#line 76
    tmp___7 = dst;
#line 76
    dst ++;
#line 76
    *tmp___7 = (char )'b';
    goto done;
    case 7: 
#line 83
    tmp___8 = dst;
#line 83
    dst ++;
#line 83
    *tmp___8 = (char )'\\';
#line 84
    tmp___9 = dst;
#line 84
    dst ++;
#line 84
    *tmp___9 = (char )'a';
    goto done;
    case 11: 
#line 87
    tmp___10 = dst;
#line 87
    dst ++;
#line 87
    *tmp___10 = (char )'\\';
#line 88
    tmp___11 = dst;
#line 88
    dst ++;
#line 88
    *tmp___11 = (char )'v';
    goto done;
    case 9: 
#line 91
    tmp___12 = dst;
#line 91
    dst ++;
#line 91
    *tmp___12 = (char )'\\';
#line 92
    tmp___13 = dst;
#line 92
    dst ++;
#line 92
    *tmp___13 = (char )'t';
    goto done;
    case 12: 
#line 95
    tmp___14 = dst;
#line 95
    dst ++;
#line 95
    *tmp___14 = (char )'\\';
#line 96
    tmp___15 = dst;
#line 96
    dst ++;
#line 96
    *tmp___15 = (char )'f';
    goto done;
    case 32: 
#line 99
    tmp___16 = dst;
#line 99
    dst ++;
#line 99
    *tmp___16 = (char )'\\';
#line 100
    tmp___17 = dst;
#line 100
    dst ++;
#line 100
    *tmp___17 = (char )'s';
    goto done;
    case 0: 
#line 103
    tmp___18 = dst;
#line 103
    dst ++;
#line 103
    *tmp___18 = (char )'\\';
#line 104
    tmp___19 = dst;
#line 104
    dst ++;
#line 104
    *tmp___19 = (char )'0';
#line 105
    if ((int )((unsigned char )nextc) >= 48) {
#line 105
      if ((int )((unsigned char )nextc) <= 55) {
#line 106
        tmp___20 = dst;
#line 106
        dst ++;
#line 106
        *tmp___20 = (char )'0';
#line 107
        tmp___21 = dst;
#line 107
        dst ++;
#line 107
        *tmp___21 = (char )'0';
      }
    }
    goto done;
    }
  }
#line 112
  if ((c & 127) == 32) {
    goto _L___6;
  } else {
#line 112
    if (flag & 1) {
      _L___6: /* CIL Label */ 
#line 113
      tmp___22 = dst;
#line 113
      dst ++;
#line 113
      *tmp___22 = (char )'\\';
#line 114
      tmp___23 = dst;
#line 114
      dst ++;
#line 114
      *tmp___23 = (char )((((int )((unsigned char )c) >> 6) & 7) + 48);
#line 115
      tmp___24 = dst;
#line 115
      dst ++;
#line 115
      *tmp___24 = (char )((((int )((unsigned char )c) >> 3) & 7) + 48);
#line 116
      tmp___25 = dst;
#line 116
      dst ++;
#line 116
      *tmp___25 = (char )(((int )((unsigned char )c) & 7) + 48);
      goto done;
    }
  }
#line 119
  if ((flag & 64) == 0) {
#line 120
    tmp___26 = dst;
#line 120
    dst ++;
#line 120
    *tmp___26 = (char )'\\';
  }
#line 121
  if (c & 128) {
#line 122
    c &= 127;
#line 123
    tmp___27 = dst;
#line 123
    dst ++;
#line 123
    *tmp___27 = (char )'M';
  }
#line 125
  tmp___33 = __ctype_b_loc();
#line 125
  if ((int const   )*(*tmp___33 + c) & 2) {
#line 126
    tmp___28 = dst;
#line 126
    dst ++;
#line 126
    *tmp___28 = (char )'^';
#line 127
    if (c == 127) {
#line 128
      tmp___29 = dst;
#line 128
      dst ++;
#line 128
      *tmp___29 = (char )'?';
    } else {
#line 130
      tmp___30 = dst;
#line 130
      dst ++;
#line 130
      *tmp___30 = (char )(c + 64);
    }
  } else {
#line 132
    tmp___31 = dst;
#line 132
    dst ++;
#line 132
    *tmp___31 = (char )'-';
#line 133
    tmp___32 = dst;
#line 133
    dst ++;
#line 133
    *tmp___32 = (char )c;
  }
  done: 
#line 136
  *dst = (char )'\000';
#line 137
  return (dst);
}
}
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
#line 1 "base64.o"
#pragma merger(0,"./base64.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 628 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 10 "openbsd-compat/base64.h"
int b64_ntop(u_char const   *src , size_t srclength , char *target , size_t targsize ) ;
#line 12
int b64_pton(char const   *src , u_char *target , size_t targsize ) ;
#line 65 "openbsd-compat/base64.c"
static char const   Base64[65]  = 
#line 65 "openbsd-compat/base64.c"
  {      (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'g',      (char const   )'h',      (char const   )'i',      (char const   )'j', 
        (char const   )'k',      (char const   )'l',      (char const   )'m',      (char const   )'n', 
        (char const   )'o',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'+',      (char const   )'/', 
        (char const   )'\000'};
#line 67 "openbsd-compat/base64.c"
static char const   Pad64  =    (char const   )'=';
#line 132 "openbsd-compat/base64.c"
int b64_ntop(u_char const   *src , size_t srclength , char *target , size_t targsize ) 
{ size_t datalength ;
  u_char input___0[3] ;
  u_char output___0[4] ;
  int i ;
  u_char const   *tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  u_char const   *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;

  {
#line 135
  datalength = (size_t )0;
#line 140
  while (2U < srclength) {
#line 141
    tmp = src;
#line 141
    src ++;
#line 141
    input___0[0] = (unsigned char )*tmp;
#line 142
    tmp___0 = src;
#line 142
    src ++;
#line 142
    input___0[1] = (unsigned char )*tmp___0;
#line 143
    tmp___1 = src;
#line 143
    src ++;
#line 143
    input___0[2] = (unsigned char )*tmp___1;
#line 144
    srclength -= 3U;
#line 146
    output___0[0] = (unsigned char )((int )input___0[0] >> 2);
#line 147
    output___0[1] = (unsigned char )((((int )input___0[0] & 3) << 4) + ((int )input___0[1] >> 4));
#line 148
    output___0[2] = (unsigned char )((((int )input___0[1] & 15) << 2) + ((int )input___0[2] >> 6));
#line 149
    output___0[3] = (unsigned char )((int )input___0[2] & 63);
#line 150
    if (! ((int )output___0[0] < 64)) {
#line 150
      abort();
    }
#line 151
    if (! ((int )output___0[1] < 64)) {
#line 151
      abort();
    }
#line 152
    if (! ((int )output___0[2] < 64)) {
#line 152
      abort();
    }
#line 153
    if (! ((int )output___0[3] < 64)) {
#line 153
      abort();
    }
#line 155
    if (datalength + 4U > targsize) {
#line 156
      return (-1);
    }
#line 157
    tmp___2 = datalength;
#line 157
    datalength ++;
#line 157
    *(target + tmp___2) = (char )Base64[output___0[0]];
#line 158
    tmp___3 = datalength;
#line 158
    datalength ++;
#line 158
    *(target + tmp___3) = (char )Base64[output___0[1]];
#line 159
    tmp___4 = datalength;
#line 159
    datalength ++;
#line 159
    *(target + tmp___4) = (char )Base64[output___0[2]];
#line 160
    tmp___5 = datalength;
#line 160
    datalength ++;
#line 160
    *(target + tmp___5) = (char )Base64[output___0[3]];
  }
#line 164
  if (0U != srclength) {
#line 166
    input___0[2] = (unsigned char )'\000';
#line 166
    input___0[1] = input___0[2];
#line 166
    input___0[0] = input___0[1];
#line 167
    i = 0;
#line 167
    while ((size_t )i < srclength) {
#line 168
      tmp___6 = src;
#line 168
      src ++;
#line 168
      input___0[i] = (unsigned char )*tmp___6;
#line 167
      i ++;
    }
#line 170
    output___0[0] = (unsigned char )((int )input___0[0] >> 2);
#line 171
    output___0[1] = (unsigned char )((((int )input___0[0] & 3) << 4) + ((int )input___0[1] >> 4));
#line 172
    output___0[2] = (unsigned char )((((int )input___0[1] & 15) << 2) + ((int )input___0[2] >> 6));
#line 173
    if (! ((int )output___0[0] < 64)) {
#line 173
      abort();
    }
#line 174
    if (! ((int )output___0[1] < 64)) {
#line 174
      abort();
    }
#line 175
    if (! ((int )output___0[2] < 64)) {
#line 175
      abort();
    }
#line 177
    if (datalength + 4U > targsize) {
#line 178
      return (-1);
    }
#line 179
    tmp___7 = datalength;
#line 179
    datalength ++;
#line 179
    *(target + tmp___7) = (char )Base64[output___0[0]];
#line 180
    tmp___8 = datalength;
#line 180
    datalength ++;
#line 180
    *(target + tmp___8) = (char )Base64[output___0[1]];
#line 181
    if (srclength == 1U) {
#line 182
      tmp___9 = datalength;
#line 182
      datalength ++;
#line 182
      *(target + tmp___9) = (char )Pad64;
    } else {
#line 184
      tmp___10 = datalength;
#line 184
      datalength ++;
#line 184
      *(target + tmp___10) = (char )Base64[output___0[2]];
    }
#line 185
    tmp___11 = datalength;
#line 185
    datalength ++;
#line 185
    *(target + tmp___11) = (char )Pad64;
  }
#line 187
  if (datalength >= targsize) {
#line 188
    return (-1);
  }
#line 189
  *(target + datalength) = (char )'\000';
#line 190
  return ((int )datalength);
}
}
#line 199 "openbsd-compat/base64.c"
int b64_pton(char const   *src , u_char *target , size_t targsize ) 
{ int tarindex ;
  int state ;
  int ch ;
  char *pos ;
  unsigned short const   **tmp ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  unsigned short const   **tmp___8 ;

  {
#line 205
  state = 0;
#line 206
  tarindex = 0;
#line 208
  while (1) {
#line 208
    tmp___2 = src;
#line 208
    src ++;
#line 208
    ch = (int )*tmp___2;
#line 208
    if (! (ch != 0)) {
#line 208
      break;
    }
#line 209
    tmp = __ctype_b_loc();
#line 209
    if ((int const   )*(*tmp + ch) & 8192) {
#line 210
      continue;
    }
#line 212
    if (ch == (int )Pad64) {
#line 213
      break;
    }
#line 215
    tmp___1 = __builtin_strchr((char *)(Base64), ch);
#line 215
    pos = tmp___1;
#line 216
    if ((unsigned int )pos == (unsigned int )((char *)0)) {
#line 217
      return (-1);
    }
#line 219
    switch (state) {
    case 0: 
#line 221
    if (target) {
#line 222
      if ((size_t )tarindex >= targsize) {
#line 223
        return (-1);
      }
#line 224
      *(target + tarindex) = (unsigned char )((pos - (char *)(Base64)) << 2);
    }
#line 226
    state = 1;
#line 227
    break;
    case 1: 
#line 229
    if (target) {
#line 230
      if ((size_t )(tarindex + 1) >= targsize) {
#line 231
        return (-1);
      }
#line 232
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | ((pos - (char *)(Base64)) >> 4));
#line 233
      *(target + (tarindex + 1)) = (unsigned char )(((pos - (char *)(Base64)) & 15) << 4);
    }
#line 236
    tarindex ++;
#line 237
    state = 2;
#line 238
    break;
    case 2: 
#line 240
    if (target) {
#line 241
      if ((size_t )(tarindex + 1) >= targsize) {
#line 242
        return (-1);
      }
#line 243
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | ((pos - (char *)(Base64)) >> 2));
#line 244
      *(target + (tarindex + 1)) = (unsigned char )(((pos - (char *)(Base64)) & 3) << 6);
    }
#line 247
    tarindex ++;
#line 248
    state = 3;
#line 249
    break;
    case 3: 
#line 251
    if (target) {
#line 252
      if ((size_t )tarindex >= targsize) {
#line 253
        return (-1);
      }
#line 254
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | (pos - (char *)(Base64)));
    }
#line 256
    tarindex ++;
#line 257
    state = 0;
#line 258
    break;
    }
  }
#line 267
  if (ch == (int )Pad64) {
#line 268
    tmp___3 = src;
#line 268
    src ++;
#line 268
    ch = (int )*tmp___3;
#line 269
    switch (state) {
    case 0: 
    case 1: 
#line 272
    return (-1);
    case 2: 
#line 276
    while (ch != 0) {
#line 277
      tmp___5 = __ctype_b_loc();
#line 277
      if (! ((int const   )*(*tmp___5 + ch) & 8192)) {
#line 278
        break;
      }
#line 276
      tmp___4 = src;
#line 276
      src ++;
#line 276
      ch = (int )*tmp___4;
    }
#line 280
    if (ch != (int )Pad64) {
#line 281
      return (-1);
    }
#line 282
    tmp___6 = src;
#line 282
    src ++;
#line 282
    ch = (int )*tmp___6;
    case 3: 
#line 291
    while (ch != 0) {
#line 292
      tmp___8 = __ctype_b_loc();
#line 292
      if (! ((int const   )*(*tmp___8 + ch) & 8192)) {
#line 293
        return (-1);
      }
#line 291
      tmp___7 = src;
#line 291
      src ++;
#line 291
      ch = (int )*tmp___7;
    }
#line 301
    if (target) {
#line 301
      if ((int )*(target + tarindex) != 0) {
#line 302
        return (-1);
      }
    }
    }
  } else {
#line 309
    if (state != 0) {
#line 310
      return (-1);
    }
  }
#line 313
  return (tarindex);
}
}
#line 1 "bindresvport.o"
#pragma merger(0,"./bindresvport.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 110 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  *__addr ,
                                              socklen_t __len ) ;
#line 114
extern  __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 9 "./openbsd-compat/bindresvport.h"
int bindresvport_sa(int sd , struct sockaddr *sa ) ;
#line 55 "openbsd-compat/bindresvport.c"
int bindresvport_sa(int sd , struct sockaddr *sa ) 
{ int error___0 ;
  int af ;
  struct sockaddr_storage myaddr ;
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;
  u_int16_t *portp ;
  u_int16_t port ;
  socklen_t salen ;
  int i ;
  int tmp ;
  int *tmp___0 ;
  register unsigned short __v ;
  register unsigned short __x ;
  unsigned int tmp___1 ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 69
  if ((unsigned int )sa == (unsigned int )((void *)0)) {
#line 70
    memset((void *)(& myaddr), 0, sizeof(myaddr));
#line 71
    sa = (struct sockaddr *)(& myaddr);
#line 73
    tmp = getsockname(sd, (struct sockaddr * __restrict  )sa, (socklen_t * __restrict  )(& salen));
#line 73
    if (tmp == -1) {
#line 74
      return (-1);
    }
#line 76
    af = (int )sa->sa_family;
#line 77
    memset((void *)(& myaddr), 0, salen);
  } else {
#line 79
    af = (int )sa->sa_family;
  }
#line 81
  if (af == 2) {
#line 82
    sin = (struct sockaddr_in *)sa;
#line 83
    salen = sizeof(struct sockaddr_in );
#line 84
    portp = & sin->sin_port;
  } else {
#line 85
    if (af == 10) {
#line 86
      sin6 = (struct sockaddr_in6 *)sa;
#line 87
      salen = sizeof(struct sockaddr_in6 );
#line 88
      portp = & sin6->sin6_port;
    } else {
#line 90
      tmp___0 = __errno_location();
#line 90
      *tmp___0 = 96;
#line 91
      return (-1);
    }
  }
#line 93
  sa->sa_family = (unsigned short )af;
#line 95
  __x = *portp;
#line 95
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 95
  port = __v;
#line 96
  if ((int )port == 0) {
#line 97
    tmp___1 = arc4random();
#line 97
    port = (unsigned short )(tmp___1 % 424U + 600U);
  }
#line 100
  error___0 = -1;
#line 102
  i = 0;
#line 102
  while (i < 424) {
#line 103
    __x___0 = port;
#line 103
    __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 103
    *portp = __v___0;
#line 105
    error___0 = bind(sd, (struct sockaddr  const  *)sa, salen);
#line 108
    if (error___0 == 0) {
#line 109
      break;
    }
#line 112
    if (error___0 < 0) {
#line 112
      tmp___2 = __errno_location();
#line 112
      if (! (*tmp___2 == 98)) {
#line 112
        tmp___3 = __errno_location();
#line 112
        if (! (*tmp___3 == 22)) {
#line 113
          break;
        }
      }
    }
#line 115
    port = (u_int16_t )((int )port + 1);
#line 116
    if ((int )port > 1023) {
#line 117
      port = (unsigned short)600;
    }
#line 102
    i ++;
  }
#line 120
  return (error___0);
}
}
#line 1 "daemon.o"
#pragma merger(0,"./daemon.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "getcwd.o"
#pragma merger(0,"./getcwd.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "getgrouplist.o"
#pragma merger(0,"./getgrouplist.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
#line 1 "glob.o"
#pragma merger(0,"./glob.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 84 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strcpy(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 242
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 589 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 259
__inline static  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path ,
                                                        struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 382
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
#line 384
extern  __attribute__((__nothrow__)) int __lxstat(int __ver , char const   *__filename ,
                                                  struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
#line 433
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 433 "/usr/include/sys/stat.h"
__inline static int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
#line 436
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
#line 436
  return (tmp);
}
}
#line 440
__inline static  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path ,
                                                        struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 440 "/usr/include/sys/stat.h"
__inline static int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
#line 443
  tmp = __lxstat(3, (char const   *)__path, (struct stat *)__statbuf);
#line 443
  return (tmp);
}
}
#line 642 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 645
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 600 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__warn_unused_result__,
__malloc__)) ;
#line 603
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 660
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 780
extern void qsort(void *__base , size_t __nmemb , size_t __size , int (*__compar)(void const   * ,
                                                                                  void const   * ) )  __attribute__((__nonnull__(1,4))) ;
#line 111 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 117
extern struct passwd *getpwnam(char const   *__name ) ;
#line 135 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 150
extern int closedir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 163
extern struct dirent *readdir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 94 "./openbsd-compat/glob.h"
int glob(char const   *pattern , int flags , int (*errfunc)(char const   * , int  ) ,
         glob_t *pglob ) ;
#line 95
void globfree(glob_t *pglob ) ;
#line 40 "openbsd-compat/glob.c"
long get_arg_max(void) 
{ 

  {
#line 44
  return (131072L);
}
}
#line 139
static int compare(void const   *p , void const   *q ) ;
#line 140
static int g_Ctoc(Char const   *str , char *buf___2 , u_int len ) ;
#line 141
static int g_lstat(Char *fn , struct stat *sb , glob_t *pglob ) ;
#line 142
static DIR *g_opendir(Char *str , glob_t *pglob ) ;
#line 143
static Char *g_strchr(Char *str , int ch ) ;
#line 144
static int g_stat(Char *fn , struct stat *sb , glob_t *pglob ) ;
#line 145
static int glob0(Char const   *pattern , glob_t *pglob ) ;
#line 146
static int glob1(Char *pattern , Char *pattern_last , glob_t *pglob , size_t *limitp ) ;
#line 147
static int glob2(Char *pathbuf , Char *pathbuf_last , Char *pathend , Char *pathend_last ,
                 Char *pattern , Char *pattern_last , glob_t *pglob , size_t *limitp ) ;
#line 149
static int glob3(Char *pathbuf , Char *pathbuf_last , Char *pathend , Char *pathend_last ,
                 Char *pattern , Char *pattern_last , Char *restpattern , Char *restpattern_last ,
                 glob_t *pglob , size_t *limitp ) ;
#line 151
static int globextend(Char const   *path , glob_t *pglob , size_t *limitp ) ;
#line 152
static Char const   *globtilde(Char const   *pattern , Char *patbuf , size_t patbuf_len ,
                               glob_t *pglob ) ;
#line 154
static int globexp1(Char const   *pattern , glob_t *pglob ) ;
#line 155
static int globexp2(Char const   *ptr , Char const   *pattern , glob_t *pglob , int *rv ) ;
#line 156
static int match(Char *name , Char *pat , Char *patend ) ;
#line 161 "openbsd-compat/glob.c"
int glob(char const   *pattern , int flags , int (*errfunc)(char const   * , int  ) ,
         glob_t *pglob ) 
{ u_char const   *patnext ;
  int c ;
  Char *bufnext ;
  Char *bufend ;
  Char patbuf[4096] ;
  Char *tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  Char *tmp___2 ;
  Char *tmp___3 ;
  u_char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 171
  patnext = (u_char const   *)((u_char *)pattern);
#line 172
  if (! (flags & 1)) {
#line 173
    pglob->gl_pathc = 0;
#line 174
    pglob->gl_pathv = (char **)((void *)0);
#line 175
    if (! (flags & 2)) {
#line 176
      pglob->gl_offs = 0;
    }
  }
#line 178
  pglob->gl_flags = flags & -257;
#line 179
  pglob->gl_errfunc = errfunc;
#line 180
  pglob->gl_matchc = 0;
#line 182
  bufnext = patbuf;
#line 183
  bufend = (bufnext + 4096) - 1;
#line 184
  if (flags & 4096) {
#line 185
    while (1) {
#line 185
      if ((unsigned int )bufnext < (unsigned int )bufend) {
#line 185
        tmp___0 = patnext;
#line 185
        patnext ++;
#line 185
        c = (int )*tmp___0;
#line 185
        if (! (c != 0)) {
#line 185
          break;
        }
      } else {
#line 185
        break;
      }
#line 186
      tmp = bufnext;
#line 186
      bufnext ++;
#line 186
      *tmp = (unsigned short )c;
    }
  } else {
#line 189
    while (1) {
#line 189
      if ((unsigned int )bufnext < (unsigned int )bufend) {
#line 189
        tmp___4 = patnext;
#line 189
        patnext ++;
#line 189
        c = (int )*tmp___4;
#line 189
        if (! (c != 0)) {
#line 189
          break;
        }
      } else {
#line 189
        break;
      }
#line 190
      if (c == 92) {
#line 191
        tmp___1 = patnext;
#line 191
        patnext ++;
#line 191
        c = (int )*tmp___1;
#line 191
        if (c == 0) {
#line 192
          c = '\\';
#line 193
          patnext --;
        }
#line 195
        tmp___2 = bufnext;
#line 195
        bufnext ++;
#line 195
        *tmp___2 = (unsigned short )(c | 16384);
      } else {
#line 197
        tmp___3 = bufnext;
#line 197
        bufnext ++;
#line 197
        *tmp___3 = (unsigned short )c;
      }
    }
  }
#line 199
  *bufnext = (unsigned short )'\000';
#line 201
  if (flags & 128) {
#line 202
    tmp___5 = globexp1((Char const   *)(patbuf), pglob);
#line 202
    return (tmp___5);
  } else {
#line 204
    tmp___6 = glob0((Char const   *)(patbuf), pglob);
#line 204
    return (tmp___6);
  }
}
}
#line 212 "openbsd-compat/glob.c"
static int globexp1(Char const   *pattern , glob_t *pglob ) 
{ Char const   *ptr ;
  int rv ;
  int tmp ;
  int tmp___0 ;
  Char *tmp___1 ;
  int tmp___2 ;

  {
#line 217
  ptr = pattern;
#line 221
  if ((int const   )*(pattern + 0) == 123) {
#line 221
    if ((int const   )*(pattern + 1) == 125) {
#line 221
      if ((int const   )*(pattern + 2) == 0) {
#line 222
        tmp = glob0(pattern, pglob);
#line 222
        return (tmp);
      }
    }
  }
#line 224
  while (1) {
#line 224
    tmp___1 = g_strchr((Char *)ptr, '{');
#line 224
    ptr = (Char const   *)tmp___1;
#line 224
    if (! ((unsigned int )ptr != (unsigned int )((void *)0))) {
#line 224
      break;
    }
#line 225
    tmp___0 = globexp2(ptr, pattern, pglob, & rv);
#line 225
    if (! tmp___0) {
#line 226
      return (rv);
    }
  }
#line 228
  tmp___2 = glob0(pattern, pglob);
#line 228
  return (tmp___2);
}
}
#line 237 "openbsd-compat/glob.c"
static int globexp2(Char const   *ptr , Char const   *pattern , glob_t *pglob , int *rv ) 
{ int i ;
  Char *lm ;
  Char *ls ;
  Char const   *pe ;
  Char const   *pm ;
  Char const   *pl ;
  Char patbuf[4096] ;
  Char *tmp ;
  Char const   *tmp___0 ;
  Char const   *tmp___1 ;
  Char const   *tmp___2 ;
  Char *tmp___3 ;
  Char const   *tmp___4 ;
  Char *tmp___5 ;
  Char const   *tmp___6 ;

  {
#line 249
  lm = patbuf;
#line 249
  pm = pattern;
#line 249
  while ((unsigned int )pm != (unsigned int )ptr) {
#line 249
    tmp = lm;
#line 249
    lm ++;
#line 249
    tmp___0 = pm;
#line 249
    pm ++;
#line 249
    *tmp = (unsigned short )*tmp___0;
  }
#line 251
  *lm = (unsigned short )'\000';
#line 252
  ls = lm;
#line 255
  i = 0;
#line 255
  ptr ++;
#line 255
  pe = ptr;
#line 255
  while (*pe) {
#line 256
    if ((int const   )*pe == 91) {
#line 258
      tmp___1 = pe;
#line 258
      pe ++;
#line 258
      pm = tmp___1;
#line 258
      while (1) {
#line 258
        if ((int const   )*pe != 93) {
#line 258
          if (! ((int const   )*pe != 0)) {
#line 258
            break;
          }
        } else {
#line 258
          break;
        }
#line 258
        pe ++;
      }
#line 260
      if ((int const   )*pe == 0) {
#line 265
        pe = pm;
      }
    } else {
#line 267
      if ((int const   )*pe == 123) {
#line 268
        i ++;
      } else {
#line 269
        if ((int const   )*pe == 125) {
#line 270
          if (i == 0) {
#line 271
            break;
          }
#line 272
          i --;
        }
      }
    }
#line 255
    pe ++;
  }
#line 276
  if (i != 0) {
#line 277
    *rv = glob0((Char const   *)(patbuf), pglob);
#line 278
    return (0);
  } else {
#line 276
    if ((int const   )*pe == 0) {
#line 277
      *rv = glob0((Char const   *)(patbuf), pglob);
#line 278
      return (0);
    }
  }
#line 281
  i = 0;
#line 281
  pm = ptr;
#line 281
  pl = pm;
#line 281
  while ((unsigned int )pm <= (unsigned int )pe) {
#line 282
    switch ((int )*pm) {
    case 91: 
#line 285
    tmp___2 = pm;
#line 285
    pm ++;
#line 285
    pl = tmp___2;
#line 285
    while (1) {
#line 285
      if ((int const   )*pm != 93) {
#line 285
        if (! ((int const   )*pm != 0)) {
#line 285
          break;
        }
      } else {
#line 285
        break;
      }
#line 285
      pm ++;
    }
#line 287
    if ((int const   )*pm == 0) {
#line 292
      pm = pl;
    }
#line 294
    break;
    case 123: 
#line 297
    i ++;
#line 298
    break;
    case 125: 
#line 301
    if (i) {
#line 302
      i --;
#line 303
      break;
    }
    case 44: 
#line 307
    if (i) {
#line 307
      if ((int const   )*pm == 44) {
#line 308
        break;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 311
      lm = ls;
#line 311
      while ((unsigned int )pl < (unsigned int )pm) {
#line 311
        tmp___3 = lm;
#line 311
        lm ++;
#line 311
        tmp___4 = pl;
#line 311
        pl ++;
#line 311
        *tmp___3 = (unsigned short )*tmp___4;
      }
#line 318
      pl = pe + 1;
#line 318
      while (1) {
#line 318
        tmp___5 = lm;
#line 318
        lm ++;
#line 318
        tmp___6 = pl;
#line 318
        pl ++;
#line 318
        *tmp___5 = (unsigned short )*tmp___6;
#line 318
        if (! ((int )*tmp___5 != 0)) {
#line 318
          break;
        }
      }
#line 325
      *rv = globexp1((Char const   *)(patbuf), pglob);
#line 328
      pl = pm + 1;
    }
#line 330
    break;
    default: ;
#line 333
    break;
    }
#line 281
    pm ++;
  }
#line 336
  *rv = 0;
#line 337
  return (0);
}
}
#line 345 "openbsd-compat/glob.c"
static Char const   *globtilde(Char const   *pattern , Char *patbuf , size_t patbuf_len ,
                               glob_t *pglob ) 
{ struct passwd *pwd ;
  char *h___0 ;
  Char const   *p ;
  Char *b ;
  Char *eb ;
  char *tmp ;
  Char const   *tmp___0 ;
  __uid_t tmp___1 ;
  __uid_t tmp___2 ;
  __uid_t tmp___3 ;
  Char *tmp___4 ;
  char *tmp___5 ;
  Char *tmp___6 ;
  Char const   *tmp___7 ;

  {
#line 357
  if ((int const   )*pattern != 126) {
#line 358
    return (pattern);
  } else {
#line 357
    if (! (pglob->gl_flags & 2048)) {
#line 358
      return (pattern);
    }
  }
#line 361
  eb = patbuf + (patbuf_len - 1U);
#line 362
  p = pattern + 1;
#line 362
  h___0 = (char *)patbuf;
#line 362
  while (1) {
#line 362
    if ((unsigned int )h___0 < (unsigned int )((char *)eb)) {
#line 362
      if (*p) {
#line 362
        if (! ((int const   )*p != 47)) {
#line 362
          break;
        }
      } else {
#line 362
        break;
      }
    } else {
#line 362
      break;
    }
#line 362
    tmp = h___0;
#line 362
    h___0 ++;
#line 362
    tmp___0 = p;
#line 362
    p ++;
#line 362
    *tmp = (char )*tmp___0;
  }
#line 366
  *h___0 = (char )'\000';
#line 373
  if ((int )*((char *)patbuf + 0) == 0) {
#line 381
    tmp___2 = getuid();
#line 381
    tmp___3 = geteuid();
#line 381
    if (tmp___2 != tmp___3) {
      goto _L;
    } else {
#line 381
      h___0 = getenv("HOME");
#line 381
      if ((unsigned int )h___0 == (unsigned int )((void *)0)) {
        _L: /* CIL Label */ 
#line 382
        tmp___1 = getuid();
#line 382
        pwd = getpwuid(tmp___1);
#line 382
        if ((unsigned int )pwd == (unsigned int )((void *)0)) {
#line 383
          return (pattern);
        } else {
#line 385
          h___0 = pwd->pw_dir;
        }
      }
    }
  } else {
#line 391
    pwd = getpwnam((char const   *)((char *)patbuf));
#line 391
    if ((unsigned int )pwd == (unsigned int )((void *)0)) {
#line 392
      return (pattern);
    } else {
#line 394
      h___0 = pwd->pw_dir;
    }
  }
#line 398
  b = patbuf;
#line 398
  while (1) {
#line 398
    if ((unsigned int )b < (unsigned int )eb) {
#line 398
      if (! *h___0) {
#line 398
        break;
      }
    } else {
#line 398
      break;
    }
#line 398
    tmp___4 = b;
#line 398
    b ++;
#line 398
    tmp___5 = h___0;
#line 398
    h___0 ++;
#line 398
    *tmp___4 = (unsigned short )*tmp___5;
  }
#line 402
  while (1) {
#line 402
    if ((unsigned int )b < (unsigned int )eb) {
#line 402
      tmp___6 = b;
#line 402
      b ++;
#line 402
      tmp___7 = p;
#line 402
      p ++;
#line 402
      *tmp___6 = (unsigned short )*tmp___7;
#line 402
      if (! ((int )*tmp___6 != 0)) {
#line 402
        break;
      }
    } else {
#line 402
      break;
    }
  }
#line 404
  *b = (unsigned short )'\000';
#line 406
  return ((Char const   *)patbuf);
}
}
#line 417 "openbsd-compat/glob.c"
static int glob0(Char const   *pattern , glob_t *pglob ) 
{ Char const   *qpatnext ;
  int c ;
  int err ;
  int oldpathc ;
  Char *bufnext ;
  Char patbuf[4096] ;
  size_t limit ;
  Char *tmp ;
  Char *tmp___0 ;
  Char *tmp___1 ;
  Char *tmp___2 ;
  Char const   *tmp___3 ;
  Char *tmp___4 ;
  Char *tmp___5 ;
  Char *tmp___6 ;
  Char const   *tmp___7 ;
  Char *tmp___8 ;
  Char *tmp___9 ;
  Char *tmp___10 ;
  Char *tmp___11 ;
  Char const   *tmp___12 ;
  int tmp___13 ;

  {
#line 425
  limit = (size_t )0;
#line 427
  qpatnext = globtilde(pattern, patbuf, 4096U, pglob);
#line 428
  oldpathc = pglob->gl_pathc;
#line 429
  bufnext = patbuf;
#line 432
  while (1) {
#line 432
    tmp___12 = qpatnext;
#line 432
    qpatnext ++;
#line 432
    c = (int )*tmp___12;
#line 432
    if (! (c != 0)) {
#line 432
      break;
    }
#line 433
    switch (c) {
    case 91: 
#line 435
    c = (int )*qpatnext;
#line 436
    if (c == 33) {
#line 437
      qpatnext ++;
    }
#line 438
    if ((int const   )*qpatnext == 0) {
      goto _L;
    } else {
#line 438
      tmp___0 = g_strchr((Char *)qpatnext + 1, ']');
#line 438
      if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
        _L: /* CIL Label */ 
#line 440
        tmp = bufnext;
#line 440
        bufnext ++;
#line 440
        *tmp = (unsigned short )'[';
#line 441
        if (c == 33) {
#line 442
          qpatnext --;
        }
#line 443
        break;
      }
    }
#line 445
    tmp___1 = bufnext;
#line 445
    bufnext ++;
#line 445
    *tmp___1 = (unsigned short)32859;
#line 446
    if (c == 33) {
#line 447
      tmp___2 = bufnext;
#line 447
      bufnext ++;
#line 447
      *tmp___2 = (unsigned short)32801;
    }
#line 448
    tmp___3 = qpatnext;
#line 448
    qpatnext ++;
#line 448
    c = (int )*tmp___3;
#line 449
    while (1) {
#line 450
      tmp___4 = bufnext;
#line 450
      bufnext ++;
#line 450
      *tmp___4 = (unsigned short )(c & 255);
#line 451
      if ((int const   )*qpatnext == 45) {
#line 451
        c = (int )*(qpatnext + 1);
#line 451
        if (c != 93) {
#line 453
          tmp___5 = bufnext;
#line 453
          bufnext ++;
#line 453
          *tmp___5 = (unsigned short)32813;
#line 454
          tmp___6 = bufnext;
#line 454
          bufnext ++;
#line 454
          *tmp___6 = (unsigned short )(c & 255);
#line 455
          qpatnext += 2;
        }
      }
#line 449
      tmp___7 = qpatnext;
#line 449
      qpatnext ++;
#line 449
      c = (int )*tmp___7;
#line 449
      if (! (c != 93)) {
#line 449
        break;
      }
    }
#line 458
    pglob->gl_flags |= 256;
#line 459
    tmp___8 = bufnext;
#line 459
    bufnext ++;
#line 459
    *tmp___8 = (unsigned short)32861;
#line 460
    break;
    case 63: 
#line 462
    pglob->gl_flags |= 256;
#line 463
    tmp___9 = bufnext;
#line 463
    bufnext ++;
#line 463
    *tmp___9 = (unsigned short)32831;
#line 464
    break;
    case 42: 
#line 466
    pglob->gl_flags |= 256;
#line 470
    if ((unsigned int )bufnext == (unsigned int )(patbuf)) {
#line 471
      tmp___10 = bufnext;
#line 471
      bufnext ++;
#line 471
      *tmp___10 = (unsigned short)32810;
    } else {
#line 470
      if ((int )*(bufnext + -1) != 32810) {
#line 471
        tmp___10 = bufnext;
#line 471
        bufnext ++;
#line 471
        *tmp___10 = (unsigned short)32810;
      }
    }
#line 472
    break;
    default: 
#line 474
    tmp___11 = bufnext;
#line 474
    bufnext ++;
#line 474
    *tmp___11 = (unsigned short )(c & 255);
#line 475
    break;
    }
  }
#line 478
  *bufnext = (unsigned short )'\000';
#line 483
  err = glob1(patbuf, (patbuf + 4096) - 1, pglob, & limit);
#line 483
  if (err != 0) {
#line 484
    return (err);
  }
#line 492
  if (pglob->gl_pathc == oldpathc) {
#line 493
    if (pglob->gl_flags & 16) {
#line 496
      tmp___13 = globextend(pattern, pglob, & limit);
#line 496
      return (tmp___13);
    } else {
#line 493
      if (pglob->gl_flags & 512) {
#line 493
        if (! (pglob->gl_flags & 256)) {
#line 496
          tmp___13 = globextend(pattern, pglob, & limit);
#line 496
          return (tmp___13);
        } else {
#line 498
          return (-3);
        }
      } else {
#line 498
        return (-3);
      }
    }
  }
#line 500
  if (! (pglob->gl_flags & 32)) {
#line 501
    qsort((void *)((pglob->gl_pathv + pglob->gl_offs) + oldpathc), (unsigned int )(pglob->gl_pathc - oldpathc),
          sizeof(char *), & compare);
  }
#line 503
  return (0);
}
}
#line 506 "openbsd-compat/glob.c"
static int compare(void const   *p , void const   *q ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 510
  if (0) {
#line 510
    __s1_len = strlen((char const   *)*((char **)p));
#line 510
    __s2_len = strlen((char const   *)*((char **)q));
#line 510
    if (! ((unsigned int )((void const   *)(*((char **)p) + 1)) - (unsigned int )((void const   *)*((char **)p)) == 1U)) {
      goto _L___0;
    } else {
#line 510
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 510
        if (! ((unsigned int )((void const   *)(*((char **)q) + 1)) - (unsigned int )((void const   *)*((char **)q)) == 1U)) {
#line 510
          tmp___8 = 1;
        } else {
#line 510
          if (__s2_len >= 4U) {
#line 510
            tmp___8 = 1;
          } else {
#line 510
            tmp___8 = 0;
          }
        }
      } else {
#line 510
        tmp___8 = 0;
      }
    }
#line 510
    if (tmp___8) {
#line 510
      tmp___4 = __builtin_strcmp((char const   *)*((char **)p), (char const   *)*((char **)q));
    } else {
#line 510
      tmp___7 = __builtin_strcmp((char const   *)*((char **)p), (char const   *)*((char **)q));
#line 510
      tmp___4 = tmp___7;
    }
  } else {
#line 510
    tmp___7 = __builtin_strcmp((char const   *)*((char **)p), (char const   *)*((char **)q));
#line 510
    tmp___4 = tmp___7;
  }
#line 510
  return (tmp___4);
}
}
#line 513 "openbsd-compat/glob.c"
static int glob1(Char *pattern , Char *pattern_last , glob_t *pglob , size_t *limitp ) 
{ Char pathbuf[4096] ;
  int tmp ;

  {
#line 522
  if ((int )*pattern == 0) {
#line 523
    return (0);
  }
#line 524
  tmp = glob2(pathbuf, (pathbuf + 4096) - 1, pathbuf, (pathbuf + 4096) - 1, pattern,
              pattern_last, pglob, limitp);
#line 524
  return (tmp);
}
}
#line 534 "openbsd-compat/glob.c"
static int glob2(Char *pathbuf , Char *pathbuf_last , Char *pathend , Char *pathend_last ,
                 Char *pattern , Char *pattern_last , glob_t *pglob , size_t *limitp ) 
{ struct stat sb ;
  Char *p ;
  Char *q ;
  int anymeta ;
  int tmp ;
  Char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  Char *tmp___3 ;
  Char *tmp___4 ;
  Char *tmp___5 ;
  Char *tmp___6 ;
  int tmp___7 ;

  {
#line 550
  anymeta = 0;
#line 550
  while (1) {
#line 551
    if ((int )*pattern == 0) {
#line 552
      *pathend = (unsigned short )'\000';
#line 553
      tmp = g_lstat(pathbuf, & sb, pglob);
#line 553
      if (tmp) {
#line 554
        return (0);
      }
#line 556
      if (pglob->gl_flags & 8) {
#line 556
        if ((int )*(pathend + -1) != 47) {
#line 556
          if ((sb.st_mode & 61440U) == 16384U) {
            goto _L;
          } else {
#line 556
            if ((sb.st_mode & 61440U) == 40960U) {
#line 556
              tmp___1 = g_stat(pathbuf, & sb, pglob);
#line 556
              if (tmp___1 == 0) {
#line 556
                if ((sb.st_mode & 61440U) == 16384U) {
                  _L: /* CIL Label */ 
#line 561
                  if ((unsigned int )(pathend + 1) > (unsigned int )pathend_last) {
#line 562
                    return (1);
                  }
#line 563
                  tmp___0 = pathend;
#line 563
                  pathend ++;
#line 563
                  *tmp___0 = (unsigned short )'/';
#line 564
                  *pathend = (unsigned short )'\000';
                }
              }
            }
          }
        }
      }
#line 566
      (pglob->gl_matchc) ++;
#line 567
      tmp___2 = globextend((Char const   *)pathbuf, pglob, limitp);
#line 567
      return (tmp___2);
    }
#line 571
    q = pathend;
#line 572
    p = pattern;
#line 573
    while (1) {
#line 573
      if ((int )*p != 0) {
#line 573
        if (! ((int )*p != 47)) {
#line 573
          break;
        }
      } else {
#line 573
        break;
      }
#line 574
      if (((int )*p & 32768) != 0) {
#line 575
        anymeta = 1;
      }
#line 576
      if ((unsigned int )(q + 1) > (unsigned int )pathend_last) {
#line 577
        return (1);
      }
#line 578
      tmp___3 = q;
#line 578
      q ++;
#line 578
      tmp___4 = p;
#line 578
      p ++;
#line 578
      *tmp___3 = *tmp___4;
    }
#line 581
    if (! anymeta) {
#line 582
      pathend = q;
#line 583
      pattern = p;
#line 584
      while ((int )*pattern == 47) {
#line 585
        if ((unsigned int )(pathend + 1) > (unsigned int )pathend_last) {
#line 586
          return (1);
        }
#line 587
        tmp___5 = pathend;
#line 587
        pathend ++;
#line 587
        tmp___6 = pattern;
#line 587
        pattern ++;
#line 587
        *tmp___5 = *tmp___6;
      }
    } else {
#line 591
      tmp___7 = glob3(pathbuf, pathbuf_last, pathend, pathend_last, pattern, pattern_last,
                      p, pattern_last, pglob, limitp);
#line 591
      return (tmp___7);
    }
  }
}
}
#line 598 "openbsd-compat/glob.c"
static int glob3(Char *pathbuf , Char *pathbuf_last , Char *pathend , Char *pathend_last ,
                 Char *pattern , Char *pattern_last , Char *restpattern , Char *restpattern_last ,
                 glob_t *pglob , size_t *limitp ) 
{ register struct dirent *dp ;
  DIR *dirp ;
  int err ;
  char buf___2[4096] ;
  struct dirent *(*readdirfunc)() ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  register u_char *sc ;
  register Char *dc ;
  Char *tmp___3 ;
  u_char *tmp___4 ;
  int tmp___5 ;

  {
#line 619
  if ((unsigned int )pathend > (unsigned int )pathend_last) {
#line 620
    return (1);
  }
#line 621
  *pathend = (unsigned short )'\000';
#line 622
  tmp = __errno_location();
#line 622
  *tmp = 0;
#line 624
  dirp = g_opendir(pathbuf, pglob);
#line 624
  if ((unsigned int )dirp == (unsigned int )((void *)0)) {
#line 626
    if (pglob->gl_errfunc) {
#line 627
      tmp___0 = g_Ctoc((Char const   *)pathbuf, buf___2, sizeof(buf___2));
#line 627
      if (tmp___0) {
#line 628
        return (-2);
      }
#line 629
      tmp___1 = __errno_location();
#line 629
      tmp___2 = (*(pglob->gl_errfunc))((char const   *)(buf___2), *tmp___1);
#line 629
      if (tmp___2) {
#line 631
        return (-2);
      } else {
#line 629
        if (pglob->gl_flags & 4) {
#line 631
          return (-2);
        }
      }
    }
#line 633
    return (0);
  }
#line 636
  err = 0;
#line 639
  if (pglob->gl_flags & 64) {
#line 640
    readdirfunc = (struct dirent *(*)())pglob->gl_readdir;
  } else {
#line 642
    readdirfunc = (struct dirent *(*)())(& readdir);
  }
#line 643
  while (1) {
#line 643
    dp = (*readdirfunc)(dirp);
#line 643
    if (! dp) {
#line 643
      break;
    }
#line 648
    if ((int )dp->d_name[0] == 46) {
#line 648
      if ((int )*pattern != 46) {
#line 649
        continue;
      }
    }
#line 650
    dc = pathend;
#line 651
    sc = (u_char *)(dp->d_name);
#line 652
    while (1) {
#line 652
      if ((unsigned int )dc < (unsigned int )pathend_last) {
#line 652
        tmp___3 = dc;
#line 652
        dc ++;
#line 652
        tmp___4 = sc;
#line 652
        sc ++;
#line 652
        *tmp___3 = (unsigned short )*tmp___4;
#line 652
        if (! ((int )*tmp___3 != 0)) {
#line 652
          break;
        }
      } else {
#line 652
        break;
      }
    }
#line 654
    if ((unsigned int )dc >= (unsigned int )pathend_last) {
#line 655
      *dc = (unsigned short )'\000';
#line 656
      err = 1;
#line 657
      break;
    }
#line 660
    tmp___5 = match(pathend, pattern, restpattern);
#line 660
    if (! tmp___5) {
#line 661
      *pathend = (unsigned short )'\000';
#line 662
      continue;
    }
#line 664
    dc --;
#line 664
    err = glob2(pathbuf, pathbuf_last, dc, pathend_last, restpattern, restpattern_last,
                pglob, limitp);
#line 666
    if (err) {
#line 667
      break;
    }
  }
#line 670
  if (pglob->gl_flags & 64) {
#line 671
    (*(pglob->gl_closedir))((void *)dirp);
  } else {
#line 673
    closedir(dirp);
  }
#line 674
  return (err);
}
}
#line 692 "openbsd-compat/glob.c"
static int globextend(Char const   *path , glob_t *pglob , size_t *limitp ) 
{ register char **pathv ;
  register int i ;
  u_int newsize ;
  u_int len ;
  char *copy ;
  Char const   *p ;
  void *tmp___1 ;
  void *tmp___2 ;
  Char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;

  {
#line 704
  newsize = sizeof(*pathv) * (unsigned int )((2 + pglob->gl_pathc) + pglob->gl_offs);
#line 705
  if (pglob->gl_pathv) {
#line 705
    tmp___1 = realloc((void *)((char *)pglob->gl_pathv), newsize);
#line 705
    pathv = (char **)tmp___1;
  } else {
#line 705
    tmp___2 = malloc(newsize);
#line 705
    pathv = (char **)tmp___2;
  }
#line 707
  if ((unsigned int )pathv == (unsigned int )((void *)0)) {
#line 708
    if (pglob->gl_pathv) {
#line 709
      free((void *)pglob->gl_pathv);
#line 710
      pglob->gl_pathv = (char **)((void *)0);
    }
#line 712
    return (-1);
  }
#line 715
  if ((unsigned int )pglob->gl_pathv == (unsigned int )((void *)0)) {
#line 715
    if (pglob->gl_offs > 0) {
#line 717
      pathv += pglob->gl_offs;
#line 718
      i = pglob->gl_offs;
#line 718
      while (1) {
#line 718
        i --;
#line 718
        if (! (i >= 0)) {
#line 718
          break;
        }
#line 719
        pathv --;
#line 719
        *pathv = (char *)((void *)0);
      }
    }
  }
#line 721
  pglob->gl_pathv = pathv;
#line 723
  p = path;
#line 723
  while (1) {
#line 723
    tmp___3 = p;
#line 723
    p ++;
#line 723
    if (! *tmp___3) {
#line 723
      break;
    }
  }
#line 725
  len = (unsigned int )(p - path);
#line 726
  *limitp += len;
#line 727
  tmp___6 = malloc(len);
#line 727
  copy = (char *)tmp___6;
#line 727
  if ((unsigned int )copy != (unsigned int )((void *)0)) {
#line 728
    tmp___4 = g_Ctoc(path, copy, len);
#line 728
    if (tmp___4) {
#line 729
      free((void *)copy);
#line 730
      return (-1);
    }
#line 732
    tmp___5 = pglob->gl_pathc;
#line 732
    (pglob->gl_pathc) ++;
#line 732
    *(pathv + (pglob->gl_offs + tmp___5)) = copy;
  }
#line 734
  *(pathv + (pglob->gl_offs + pglob->gl_pathc)) = (char *)((void *)0);
#line 736
  if (pglob->gl_flags & 8192) {
#line 736
    tmp___8 = get_arg_max();
#line 736
    if (newsize + *limitp >= (unsigned int )tmp___8) {
#line 738
      tmp___7 = __errno_location();
#line 738
      *tmp___7 = 0;
#line 739
      return (-1);
    }
  }
#line 742
  if ((unsigned int )copy == (unsigned int )((void *)0)) {
#line 742
    tmp___9 = -1;
  } else {
#line 742
    tmp___9 = 0;
  }
#line 742
  return (tmp___9);
}
}
#line 750 "openbsd-compat/glob.c"
static int match(Char *name , Char *pat , Char *patend ) 
{ int ok ;
  int negate_range ;
  Char c ;
  Char k ;
  Char *tmp ;
  int tmp___0 ;
  Char *tmp___1 ;
  Char *tmp___2 ;
  Char *tmp___3 ;
  Char *tmp___4 ;
  Char *tmp___5 ;

  {
#line 757
  while ((unsigned int )pat < (unsigned int )patend) {
#line 758
    tmp = pat;
#line 758
    pat ++;
#line 758
    c = *tmp;
#line 759
    switch ((int )c & 65535) {
    case (unsigned short)32810: 
#line 761
    if ((unsigned int )pat == (unsigned int )patend) {
#line 762
      return (1);
    }
#line 763
    while (1) {
#line 764
      tmp___0 = match(name, pat, patend);
#line 764
      if (tmp___0) {
#line 765
        return (1);
      }
#line 763
      tmp___1 = name;
#line 763
      name ++;
#line 763
      if (! ((int )*tmp___1 != 0)) {
#line 763
        break;
      }
    }
#line 768
    return (0);
    case (unsigned short)32831: 
#line 770
    tmp___2 = name;
#line 770
    name ++;
#line 770
    if ((int )*tmp___2 == 0) {
#line 771
      return (0);
    }
#line 772
    break;
    case (unsigned short)32859: 
#line 774
    ok = 0;
#line 775
    tmp___3 = name;
#line 775
    name ++;
#line 775
    k = *tmp___3;
#line 775
    if ((int )k == 0) {
#line 776
      return (0);
    }
#line 777
    negate_range = ((int )*pat & 65535) == 32801;
#line 777
    if (negate_range != 0) {
#line 778
      pat ++;
    }
#line 779
    while (1) {
#line 779
      tmp___4 = pat;
#line 779
      pat ++;
#line 779
      c = *tmp___4;
#line 779
      if (! (((int )c & 65535) != 32861)) {
#line 779
        break;
      }
#line 780
      if (((int )*pat & 65535) == 32813) {
#line 781
        if ((int )c <= (int )k) {
#line 781
          if ((int )k <= (int )*(pat + 1)) {
#line 782
            ok = 1;
          }
        }
#line 783
        pat += 2;
      } else {
#line 784
        if ((int )c == (int )k) {
#line 785
          ok = 1;
        }
      }
    }
#line 786
    if (ok == negate_range) {
#line 787
      return (0);
    }
#line 788
    break;
    default: 
#line 790
    tmp___5 = name;
#line 790
    name ++;
#line 790
    if ((int )*tmp___5 != (int )c) {
#line 791
      return (0);
    }
#line 792
    break;
    }
  }
#line 795
  return ((int )*name == 0);
}
}
#line 799 "openbsd-compat/glob.c"
void globfree(glob_t *pglob ) 
{ register int i ;
  register char **pp ;
  int tmp ;

  {
#line 806
  if ((unsigned int )pglob->gl_pathv != (unsigned int )((void *)0)) {
#line 807
    pp = pglob->gl_pathv + pglob->gl_offs;
#line 808
    i = pglob->gl_pathc;
#line 808
    while (1) {
#line 808
      tmp = i;
#line 808
      i --;
#line 808
      if (! tmp) {
#line 808
        break;
      }
#line 809
      if (*pp) {
#line 810
        free((void *)*pp);
      }
#line 808
      pp ++;
    }
#line 811
    free((void *)pglob->gl_pathv);
#line 812
    pglob->gl_pathv = (char **)((void *)0);
  }
#line 814
  return;
}
}
#line 816 "openbsd-compat/glob.c"
static DIR *g_opendir(Char *str , glob_t *pglob ) 
{ char buf___2[4096] ;
  int tmp ;
  void *tmp___0 ;
  DIR *tmp___1 ;

  {
#line 823
  if (! *str) {
#line 824
    strcpy((char * __restrict  )(buf___2), (char const   * __restrict  )".");
  } else {
#line 826
    tmp = g_Ctoc((Char const   *)str, buf___2, sizeof(buf___2));
#line 826
    if (tmp) {
#line 827
      return ((DIR *)((void *)0));
    }
  }
#line 830
  if (pglob->gl_flags & 64) {
#line 831
    tmp___0 = (*(pglob->gl_opendir))((char const   *)(buf___2));
#line 831
    return ((DIR *)tmp___0);
  }
#line 833
  tmp___1 = opendir((char const   *)(buf___2));
#line 833
  return (tmp___1);
}
}
#line 836 "openbsd-compat/glob.c"
static int g_lstat(Char *fn , struct stat *sb , glob_t *pglob ) 
{ char buf___2[4096] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 844
  tmp = g_Ctoc((Char const   *)fn, buf___2, sizeof(buf___2));
#line 844
  if (tmp) {
#line 845
    return (-1);
  }
#line 846
  if (pglob->gl_flags & 64) {
#line 847
    tmp___0 = (*(pglob->gl_lstat))((char const   *)(buf___2), sb);
#line 847
    return (tmp___0);
  }
#line 848
  tmp___1 = lstat((char const   * __restrict  )(buf___2), (struct stat * __restrict  )sb);
#line 848
  return (tmp___1);
}
}
#line 851 "openbsd-compat/glob.c"
static int g_stat(Char *fn , struct stat *sb , glob_t *pglob ) 
{ char buf___2[4096] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 859
  tmp = g_Ctoc((Char const   *)fn, buf___2, sizeof(buf___2));
#line 859
  if (tmp) {
#line 860
    return (-1);
  }
#line 861
  if (pglob->gl_flags & 64) {
#line 862
    tmp___0 = (*(pglob->gl_stat))((char const   *)(buf___2), sb);
#line 862
    return (tmp___0);
  }
#line 863
  tmp___1 = stat((char const   * __restrict  )(buf___2), (struct stat * __restrict  )sb);
#line 863
  return (tmp___1);
}
}
#line 866 "openbsd-compat/glob.c"
static Char *g_strchr(Char *str , int ch ) 
{ Char *tmp ;

  {
#line 871
  while (1) {
#line 872
    if ((int )*str == ch) {
#line 873
      return (str);
    }
#line 871
    tmp = str;
#line 871
    str ++;
#line 871
    if (! *tmp) {
#line 871
      break;
    }
  }
#line 875
  return ((Char *)((void *)0));
}
}
#line 878 "openbsd-compat/glob.c"
static int g_Ctoc(Char const   *str , char *buf___2 , u_int len ) 
{ char *tmp ;
  Char const   *tmp___0 ;
  u_int tmp___1 ;

  {
#line 885
  while (1) {
#line 885
    tmp___1 = len;
#line 885
    len --;
#line 885
    if (! tmp___1) {
#line 885
      break;
    }
#line 886
    tmp = buf___2;
#line 886
    buf___2 ++;
#line 886
    tmp___0 = str;
#line 886
    str ++;
#line 886
    *tmp = (char )*tmp___0;
#line 886
    if ((int )*tmp == 0) {
#line 887
      return (0);
    }
  }
#line 889
  return (1);
}
}
#line 1 "inet_aton.o"
#pragma merger(0,"./inet_aton.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "inet_ntoa.o"
#pragma merger(0,"./inet_ntoa.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "inet_ntop.o"
#pragma merger(0,"./inet_ntop.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "mktemp.o"
#pragma merger(0,"./mktemp.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "realpath.o"
#pragma merger(0,"./realpath.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "rresvport.o"
#pragma merger(0,"./rresvport.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "setenv.o"
#pragma merger(0,"./setenv.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "setproctitle.o"
#pragma merger(0,"./setproctitle.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 9 "./openbsd-compat/setproctitle.h"
void setproctitle(char const   *fmt  , ...) ;
#line 71 "openbsd-compat/setproctitle.c"
void setproctitle(char const   *fmt  , ...) 
{ 

  {
#line 101
  return;
}
}
#line 1 "sigact.o"
#pragma merger(0,"./sigact.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "strlcat.o"
#pragma merger(0,"./strlcat.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 47 "openbsd-compat/strlcat.c"
size_t strlcat(char *dst , char const   *src , size_t siz ) 
{ register char *d ;
  register char const   *s ;
  register size_t n___0 ;
  size_t dlen ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 52
  d = dst;
#line 53
  s = src;
#line 54
  n___0 = siz;
#line 58
  while (1) {
#line 58
    tmp = n___0;
#line 58
    n___0 --;
#line 58
    if (tmp != 0U) {
#line 58
      if (! ((int )*d != 0)) {
#line 58
        break;
      }
    } else {
#line 58
      break;
    }
#line 59
    d ++;
  }
#line 60
  dlen = (unsigned int )(d - dst);
#line 61
  n___0 = siz - dlen;
#line 63
  if (n___0 == 0U) {
#line 64
    tmp___0 = strlen(s);
#line 64
    return (dlen + tmp___0);
  }
#line 65
  while ((int const   )*s != 0) {
#line 66
    if (n___0 != 1U) {
#line 67
      tmp___1 = d;
#line 67
      d ++;
#line 67
      *tmp___1 = (char )*s;
#line 68
      n___0 --;
    }
#line 70
    s ++;
  }
#line 72
  *d = (char )'\000';
#line 74
  return (dlen + (size_t )(s - src));
}
}
#line 1 "strlcpy.o"
#pragma merger(0,"./strlcpy.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 45 "openbsd-compat/strlcpy.c"
size_t strlcpy(char *dst , char const   *src , size_t siz ) 
{ register char *d ;
  register char const   *s ;
  register size_t n___0 ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 50
  d = dst;
#line 51
  s = src;
#line 52
  n___0 = siz;
#line 55
  if (n___0 != 0U) {
#line 55
    n___0 --;
#line 55
    if (n___0 != 0U) {
#line 56
      while (1) {
#line 57
        tmp = d;
#line 57
        d ++;
#line 57
        tmp___0 = s;
#line 57
        s ++;
#line 57
        *tmp = (char )*tmp___0;
#line 57
        if ((int )*tmp == 0) {
#line 58
          break;
        }
#line 56
        n___0 --;
#line 56
        if (! (n___0 != 0U)) {
#line 56
          break;
        }
      }
    }
  }
#line 63
  if (n___0 == 0U) {
#line 64
    if (siz != 0U) {
#line 65
      *d = (char )'\000';
    }
#line 66
    while (1) {
#line 66
      tmp___1 = s;
#line 66
      s ++;
#line 66
      if (! *tmp___1) {
#line 66
        break;
      }
    }
  }
#line 70
  return ((unsigned int )((s - src) - 1));
}
}
#line 1 "strmode.o"
#pragma merger(0,"./strmode.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 5 "./openbsd-compat/strmode.h"
void strmode(mode_t mode , char *p ) ;
#line 45 "openbsd-compat/strmode.c"
void strmode(mode_t mode , char *p ) 
{ char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;

  {
#line 51
  switch ((int )(mode & 61440U)) {
  case 16384: 
#line 53
  tmp = p;
#line 53
  p ++;
#line 53
  *tmp = (char )'d';
#line 54
  break;
  case 8192: 
#line 56
  tmp___0 = p;
#line 56
  p ++;
#line 56
  *tmp___0 = (char )'c';
#line 57
  break;
  case 24576: 
#line 59
  tmp___1 = p;
#line 59
  p ++;
#line 59
  *tmp___1 = (char )'b';
#line 60
  break;
  case 32768: 
#line 62
  tmp___2 = p;
#line 62
  p ++;
#line 62
  *tmp___2 = (char )'-';
#line 63
  break;
  case 40960: 
#line 65
  tmp___3 = p;
#line 65
  p ++;
#line 65
  *tmp___3 = (char )'l';
#line 66
  break;
  case 49152: 
#line 69
  tmp___4 = p;
#line 69
  p ++;
#line 69
  *tmp___4 = (char )'s';
#line 70
  break;
  case 4096: 
#line 74
  tmp___5 = p;
#line 74
  p ++;
#line 74
  *tmp___5 = (char )'p';
#line 75
  break;
  default: 
#line 83
  tmp___6 = p;
#line 83
  p ++;
#line 83
  *tmp___6 = (char )'?';
#line 84
  break;
  }
#line 87
  if (mode & 256U) {
#line 88
    tmp___7 = p;
#line 88
    p ++;
#line 88
    *tmp___7 = (char )'r';
  } else {
#line 90
    tmp___8 = p;
#line 90
    p ++;
#line 90
    *tmp___8 = (char )'-';
  }
#line 91
  if (mode & 128U) {
#line 92
    tmp___9 = p;
#line 92
    p ++;
#line 92
    *tmp___9 = (char )'w';
  } else {
#line 94
    tmp___10 = p;
#line 94
    p ++;
#line 94
    *tmp___10 = (char )'-';
  }
#line 95
  switch ((int )(mode & 2112U)) {
  case 0: 
#line 97
  tmp___11 = p;
#line 97
  p ++;
#line 97
  *tmp___11 = (char )'-';
#line 98
  break;
  case 64: 
#line 100
  tmp___12 = p;
#line 100
  p ++;
#line 100
  *tmp___12 = (char )'x';
#line 101
  break;
  case 2048: 
#line 103
  tmp___13 = p;
#line 103
  p ++;
#line 103
  *tmp___13 = (char )'S';
#line 104
  break;
  case 2112: 
#line 106
  tmp___14 = p;
#line 106
  p ++;
#line 106
  *tmp___14 = (char )'s';
#line 107
  break;
  }
#line 110
  if (mode & (unsigned int )(256 >> 3)) {
#line 111
    tmp___15 = p;
#line 111
    p ++;
#line 111
    *tmp___15 = (char )'r';
  } else {
#line 113
    tmp___16 = p;
#line 113
    p ++;
#line 113
    *tmp___16 = (char )'-';
  }
#line 114
  if (mode & (unsigned int )(128 >> 3)) {
#line 115
    tmp___17 = p;
#line 115
    p ++;
#line 115
    *tmp___17 = (char )'w';
  } else {
#line 117
    tmp___18 = p;
#line 117
    p ++;
#line 117
    *tmp___18 = (char )'-';
  }
#line 118
  switch ((int )(mode & (unsigned int )((64 >> 3) | 1024))) {
  case 0: 
#line 120
  tmp___19 = p;
#line 120
  p ++;
#line 120
  *tmp___19 = (char )'-';
#line 121
  break;
  case 64 >> 3: 
#line 123
  tmp___20 = p;
#line 123
  p ++;
#line 123
  *tmp___20 = (char )'x';
#line 124
  break;
  case 1024: 
#line 126
  tmp___21 = p;
#line 126
  p ++;
#line 126
  *tmp___21 = (char )'S';
#line 127
  break;
  case (64 >> 3) | 1024: 
#line 129
  tmp___22 = p;
#line 129
  p ++;
#line 129
  *tmp___22 = (char )'s';
#line 130
  break;
  }
#line 133
  if (mode & (unsigned int )((256 >> 3) >> 3)) {
#line 134
    tmp___23 = p;
#line 134
    p ++;
#line 134
    *tmp___23 = (char )'r';
  } else {
#line 136
    tmp___24 = p;
#line 136
    p ++;
#line 136
    *tmp___24 = (char )'-';
  }
#line 137
  if (mode & (unsigned int )((128 >> 3) >> 3)) {
#line 138
    tmp___25 = p;
#line 138
    p ++;
#line 138
    *tmp___25 = (char )'w';
  } else {
#line 140
    tmp___26 = p;
#line 140
    p ++;
#line 140
    *tmp___26 = (char )'-';
  }
#line 141
  switch ((int )(mode & (unsigned int )(((64 >> 3) >> 3) | 512))) {
  case 0: 
#line 143
  tmp___27 = p;
#line 143
  p ++;
#line 143
  *tmp___27 = (char )'-';
#line 144
  break;
  case (64 >> 3) >> 3: 
#line 146
  tmp___28 = p;
#line 146
  p ++;
#line 146
  *tmp___28 = (char )'x';
#line 147
  break;
  case 512: 
#line 149
  tmp___29 = p;
#line 149
  p ++;
#line 149
  *tmp___29 = (char )'T';
#line 150
  break;
  case ((64 >> 3) >> 3) | 512: 
#line 152
  tmp___30 = p;
#line 152
  p ++;
#line 152
  *tmp___30 = (char )'t';
#line 153
  break;
  }
#line 155
  tmp___31 = p;
#line 155
  p ++;
#line 155
  *tmp___31 = (char )' ';
#line 156
  *p = (char )'\000';
#line 157
  return;
}
}
#line 1 "strsep.o"
#pragma merger(0,"./strsep.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "atomicio.o"
#pragma merger(0,"./atomicio.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 31 "atomicio.h"
ssize_t atomicio(ssize_t (*f)() , int fd , void *_s , size_t n___0 ) ;
#line 35 "atomicio.c"
ssize_t atomicio(ssize_t (*f)() , int fd , void *_s , size_t n___0 ) 
{ char *s ;
  ssize_t res ;
  ssize_t pos ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 42
  s = (char *)_s;
#line 43
  pos = 0;
#line 45
  while (n___0 > (size_t )pos) {
#line 46
    res = (*f)(fd, s + pos, n___0 - (size_t )pos);
#line 47
    switch (res) {
    case -1: 
#line 50
    tmp = __errno_location();
#line 50
    if (*tmp == 4) {
#line 54
      continue;
    } else {
#line 50
      tmp___0 = __errno_location();
#line 50
      if (*tmp___0 == 11) {
#line 54
        continue;
      } else {
#line 50
        tmp___1 = __errno_location();
#line 50
        if (*tmp___1 == 11) {
#line 54
          continue;
        }
      }
    }
    case 0: 
#line 56
    return (res);
    default: 
#line 58
    pos += res;
    }
  }
#line 61
  return (pos);
}
}
#line 1 "authfd.o"
#pragma merger(0,"./authfd.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 100 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 124
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 320 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 327
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 333
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 76 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 405 "/usr/include/openssl/bn.h"
extern int BN_num_bits(BIGNUM const   *a ) ;
#line 26 "buffer.h"
void buffer_init(Buffer *buffer ) ;
#line 29
void buffer_free(Buffer *buffer ) ;
#line 33
void buffer_clear(Buffer *buffer ) ;
#line 36
void buffer_append(Buffer *buffer , char const   *data , u_int len ) ;
#line 46
u_int buffer_len(Buffer *buffer ) ;
#line 58
char *buffer_ptr(Buffer *buffer ) ;
#line 25 "bufaux.h"
void buffer_put_bignum(Buffer *buffer , BIGNUM *value ) ;
#line 26
void buffer_put_bignum2(Buffer *buffer , BIGNUM *value ) ;
#line 29
int buffer_get_bignum(Buffer *buffer , BIGNUM *value ) ;
#line 33
u_int buffer_get_int(Buffer *buffer ) ;
#line 39
void buffer_put_int(Buffer *buffer , u_int value ) ;
#line 45
int buffer_get_char(Buffer *buffer ) ;
#line 48
void buffer_put_char(Buffer *buffer , int value ) ;
#line 58
char *buffer_get_string(Buffer *buffer , u_int *length_ptr ) ;
#line 61
void buffer_put_string(Buffer *buffer , void const   *buf___2 , u_int len ) ;
#line 62
void buffer_put_cstring(Buffer *buffer , char const   *s ) ;
#line 23 "xmalloc.h"
void *xmalloc(size_t size ) ;
#line 29
void xfree(void *ptr ) ;
#line 53 "key.h"
Key *key_new(int type ) ;
#line 67
Key *key_from_blob(char *blob , int blen ) ;
#line 68
int key_to_blob(Key *key , u_char **blobp , u_int *lenp ) ;
#line 69
char *key_ssh_name(Key *k ) ;
#line 54 "authfd.h"
int ssh_get_authentication_socket(void) ;
#line 61
void ssh_close_authentication_socket(int sock ) ;
#line 69
AuthenticationConnection *ssh_get_authentication_connection(void) ;
#line 75
void ssh_close_authentication_connection(AuthenticationConnection *auth ) ;
#line 80
int ssh_get_num_identities(AuthenticationConnection *auth , int version ) ;
#line 87
Key *ssh_get_first_identity(AuthenticationConnection *auth , char **comment , int version ) ;
#line 95
Key *ssh_get_next_identity(AuthenticationConnection *auth , char **comment , int version ) ;
#line 101
int ssh_decrypt_challenge(AuthenticationConnection *auth , Key *key , BIGNUM *challenge ,
                          u_char *session_id___0 , u_int response_type , u_char *response ) ;
#line 109
int ssh_agent_sign(AuthenticationConnection *auth , Key *key , u_char **sigp , int *lenp ,
                   u_char *data , int datalen ) ;
#line 120
int ssh_add_identity(AuthenticationConnection *auth , Key *key , char const   *comment ) ;
#line 129
int ssh_remove_identity(AuthenticationConnection *auth , Key *key ) ;
#line 136
int ssh_remove_all_identities(AuthenticationConnection *auth , int version ) ;
#line 59 "compat.h"
int datafellows ;
#line 60 "log.h"
void ( /* format attribute */  error)(char const   *fmt  , ...) ;
#line 61
void ( /* format attribute */  log)(char const   *fmt  , ...) ;
#line 57 "authfd.c"
int decode_reply(int type ) ;
#line 65 "authfd.c"
int ssh_get_authentication_socket(void) 
{ char const   *authsocket ;
  int sock ;
  int len ;
  struct sockaddr_un sunaddr ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 72
  tmp = getenv("SSH_AUTH_SOCK");
#line 72
  authsocket = (char const   *)tmp;
#line 73
  if (! authsocket) {
#line 74
    return (-1);
  }
#line 76
  sunaddr.sun_family = (unsigned short)1;
#line 77
  strlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));
#line 78
  tmp___0 = strlen((char const   *)(sunaddr.sun_path));
#line 78
  len = (int )(((unsigned int )(((struct sockaddr_un *)0)->sun_path) + tmp___0) + 1U);
#line 83
  sock = socket(1, 1, 0);
#line 84
  if (sock < 0) {
#line 85
    return (-1);
  }
#line 88
  tmp___1 = fcntl(sock, 2, 1);
#line 88
  if (tmp___1 == -1) {
#line 89
    close(sock);
#line 90
    return (-1);
  }
#line 92
  tmp___2 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sunaddr)),
                    (unsigned int )len);
#line 92
  if (tmp___2 < 0) {
#line 93
    close(sock);
#line 94
    return (-1);
  }
#line 96
  return (sock);
}
}
#line 99 "authfd.c"
int ssh_request_reply(AuthenticationConnection *auth , Buffer *request , Buffer *reply ) 
{ int l ;
  int len ;
  char buf___2[1024] ;
  u_int tmp ;
  ssize_t tmp___0 ;
  u_int tmp___1 ;
  char *tmp___2 ;
  ssize_t tmp___3 ;
  u_int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;

  {
#line 106
  tmp = buffer_len(request);
#line 106
  len = (int )tmp;
#line 107
  while (1) {
#line 107
    buf___2[0] = (char )(len >> 24);
#line 107
    buf___2[1] = (char )(len >> 16);
#line 107
    buf___2[2] = (char )(len >> 8);
#line 107
    buf___2[3] = (char )len;
#line 107
    break;
  }
#line 110
  tmp___0 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)(buf___2), 4U);
#line 110
  if (tmp___0 != 4) {
#line 113
    error("Error writing to authentication socket.");
#line 114
    return (0);
  } else {
#line 110
    tmp___1 = buffer_len(request);
#line 110
    tmp___2 = buffer_ptr(request);
#line 110
    tmp___3 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)tmp___2, tmp___1);
#line 110
    tmp___4 = buffer_len(request);
#line 110
    if ((u_int )tmp___3 != tmp___4) {
#line 113
      error("Error writing to authentication socket.");
#line 114
      return (0);
    }
  }
#line 120
  len = 4;
#line 121
  while (len > 0) {
#line 122
    l = read(auth->fd, (void *)((buf___2 + 4) - len), (unsigned int )len);
#line 123
    if (l == -1) {
#line 123
      tmp___5 = __errno_location();
#line 123
      if (*tmp___5 == 11) {
#line 124
        continue;
      } else {
#line 123
        tmp___6 = __errno_location();
#line 123
        if (*tmp___6 == 4) {
#line 124
          continue;
        }
      }
    }
#line 125
    if (l <= 0) {
#line 126
      error("Error reading response length from authentication socket.");
#line 127
      return (0);
    }
#line 129
    len -= l;
  }
#line 133
  len = (int )(((((unsigned long )((unsigned char )buf___2[0]) << 24) | ((unsigned long )((unsigned char )buf___2[1]) << 16)) | ((unsigned long )((unsigned char )buf___2[2]) << 8)) | (unsigned long )((unsigned char )buf___2[3]));
#line 134
  if (len > 262144) {
#line 135
    fatal("Authentication response too long: %d", len);
  }
#line 138
  buffer_clear(reply);
#line 139
  while (len > 0) {
#line 140
    l = len;
#line 141
    if ((unsigned int )l > sizeof(buf___2)) {
#line 142
      l = (int )sizeof(buf___2);
    }
#line 143
    l = read(auth->fd, (void *)(buf___2), (unsigned int )l);
#line 144
    if (l == -1) {
#line 144
      tmp___7 = __errno_location();
#line 144
      if (*tmp___7 == 11) {
#line 145
        continue;
      } else {
#line 144
        tmp___8 = __errno_location();
#line 144
        if (*tmp___8 == 4) {
#line 145
          continue;
        }
      }
    }
#line 146
    if (l <= 0) {
#line 147
      error("Error reading response from authentication socket.");
#line 148
      return (0);
    }
#line 150
    buffer_append(reply, (char const   *)(buf___2), (unsigned int )l);
#line 151
    len -= l;
  }
#line 153
  return (1);
}
}
#line 162 "authfd.c"
void ssh_close_authentication_socket(int sock ) 
{ char *tmp ;

  {
#line 165
  tmp = getenv("SSH_AUTH_SOCK");
#line 165
  if (tmp) {
#line 166
    close(sock);
  }
#line 167
  return;
}
}
#line 177 "authfd.c"
AuthenticationConnection *ssh_get_authentication_connection(void) 
{ AuthenticationConnection *auth ;
  int sock ;
  void *tmp ;

  {
#line 183
  sock = ssh_get_authentication_socket();
#line 189
  if (sock < 0) {
#line 190
    return ((AuthenticationConnection *)((void *)0));
  }
#line 192
  tmp = xmalloc(sizeof(*auth));
#line 192
  auth = (AuthenticationConnection *)tmp;
#line 193
  auth->fd = sock;
#line 194
  buffer_init(& auth->identities);
#line 195
  auth->howmany = 0;
#line 197
  return (auth);
}
}
#line 205 "authfd.c"
void ssh_close_authentication_connection(AuthenticationConnection *auth ) 
{ 

  {
#line 208
  buffer_free(& auth->identities);
#line 209
  close(auth->fd);
#line 210
  xfree((void *)auth);
#line 211
  return;
}
}
#line 217 "authfd.c"
int ssh_get_num_identities(AuthenticationConnection *auth , int version ) 
{ int type ;
  int code1 ;
  int code2 ;
  Buffer request ;
  int tmp ;
  u_int tmp___0 ;

  {
#line 220
  code1 = 0;
#line 220
  code2 = 0;
#line 223
  switch (version) {
  case 1: 
#line 225
  code1 = 1;
#line 226
  code2 = 2;
#line 227
  break;
  case 2: 
#line 229
  code1 = 11;
#line 230
  code2 = 12;
#line 231
  break;
  default: ;
#line 233
  return (0);
  }
#line 240
  buffer_init(& request);
#line 241
  buffer_put_char(& request, code1);
#line 243
  buffer_clear(& auth->identities);
#line 244
  tmp = ssh_request_reply(auth, & request, & auth->identities);
#line 244
  if (tmp == 0) {
#line 245
    buffer_free(& request);
#line 246
    return (0);
  }
#line 248
  buffer_free(& request);
#line 251
  type = buffer_get_char(& auth->identities);
#line 252
  if (type == 5) {
#line 253
    return (0);
  } else {
#line 252
    if (type == 102) {
#line 253
      return (0);
    } else {
#line 254
      if (type != code2) {
#line 255
        fatal("Bad authentication reply message type: %d", type);
      }
    }
  }
#line 259
  tmp___0 = buffer_get_int(& auth->identities);
#line 259
  auth->howmany = (int )tmp___0;
#line 260
  if (auth->howmany > 1024) {
#line 261
    fatal("Too many identities in authentication reply: %d", auth->howmany);
  }
#line 264
  return (auth->howmany);
}
}
#line 267 "authfd.c"
Key *ssh_get_first_identity(AuthenticationConnection *auth , char **comment , int version ) 
{ Key *tmp ;
  int tmp___0 ;

  {
#line 271
  tmp___0 = ssh_get_num_identities(auth, version);
#line 271
  if (tmp___0 > 0) {
#line 272
    tmp = ssh_get_next_identity(auth, comment, version);
#line 272
    return (tmp);
  }
#line 273
  return ((Key *)((void *)0));
}
}
#line 276 "authfd.c"
Key *ssh_get_next_identity(AuthenticationConnection *auth , char **comment , int version ) 
{ u_int bits ;
  u_char *blob ;
  u_int blen ;
  Key *key ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 282
  key = (Key *)((void *)0);
#line 285
  if (auth->howmany <= 0) {
#line 286
    return ((Key *)((void *)0));
  }
#line 292
  switch (version) {
  case 1: 
#line 294
  key = key_new(0);
#line 295
  bits = buffer_get_int(& auth->identities);
#line 296
  buffer_get_bignum(& auth->identities, (key->rsa)->e);
#line 297
  buffer_get_bignum(& auth->identities, (key->rsa)->n);
#line 298
  *comment = buffer_get_string(& auth->identities, (u_int *)((void *)0));
#line 299
  tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 299
  if (bits != (u_int )tmp___0) {
#line 300
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 300
    log("Warning: identity keysize mismatch: actual %d, announced %u", tmp, bits);
  }
#line 302
  break;
  case 2: 
#line 304
  tmp___1 = buffer_get_string(& auth->identities, & blen);
#line 304
  blob = (u_char *)tmp___1;
#line 305
  *comment = buffer_get_string(& auth->identities, (u_int *)((void *)0));
#line 306
  key = key_from_blob((char *)blob, (int )blen);
#line 307
  xfree((void *)blob);
#line 308
  break;
  default: ;
#line 310
  return ((Key *)((void *)0));
#line 311
  break;
  }
#line 314
  (auth->howmany) --;
#line 315
  return (key);
}
}
#line 326 "authfd.c"
int ssh_decrypt_challenge(AuthenticationConnection *auth , Key *key , BIGNUM *challenge ,
                          u_char *session_id___0 , u_int response_type , u_char *response ) 
{ Buffer buffer ;
  int success ;
  int i ;
  int type ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 334
  success = 0;
#line 338
  if (key->type != 0) {
#line 339
    return (0);
  }
#line 340
  if (response_type == 0U) {
#line 341
    log("Compatibility with ssh protocol version 1.0 no longer supported.");
#line 342
    return (0);
  }
#line 344
  buffer_init(& buffer);
#line 345
  buffer_put_char(& buffer, 3);
#line 346
  tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 346
  buffer_put_int(& buffer, (unsigned int )tmp);
#line 347
  buffer_put_bignum(& buffer, (key->rsa)->e);
#line 348
  buffer_put_bignum(& buffer, (key->rsa)->n);
#line 349
  buffer_put_bignum(& buffer, challenge);
#line 350
  buffer_append(& buffer, (char const   *)((char *)session_id___0), 16U);
#line 351
  buffer_put_int(& buffer, response_type);
#line 353
  tmp___0 = ssh_request_reply(auth, & buffer, & buffer);
#line 353
  if (tmp___0 == 0) {
#line 354
    buffer_free(& buffer);
#line 355
    return (0);
  }
#line 357
  type = buffer_get_char(& buffer);
#line 359
  if (type == 5) {
#line 360
    log("Agent admitted failure to authenticate using the key.");
  } else {
#line 359
    if (type == 102) {
#line 360
      log("Agent admitted failure to authenticate using the key.");
    } else {
#line 361
      if (type != 4) {
#line 362
        fatal("Bad authentication response: %d", type);
      } else {
#line 364
        success = 1;
#line 369
        i = 0;
#line 369
        while (i < 16) {
#line 370
          tmp___1 = buffer_get_char(& buffer);
#line 370
          *(response + i) = (unsigned char )tmp___1;
#line 369
          i ++;
        }
      }
    }
  }
#line 372
  buffer_free(& buffer);
#line 373
  return (success);
}
}
#line 377 "authfd.c"
int ssh_agent_sign(AuthenticationConnection *auth , Key *key , u_char **sigp , int *lenp ,
                   u_char *data , int datalen ) 
{ Buffer msg ;
  u_char *blob ;
  u_int blen ;
  int type ;
  int flags ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 387
  flags = 0;
#line 388
  ret = -1;
#line 390
  tmp = key_to_blob(key, & blob, & blen);
#line 390
  if (tmp == 0) {
#line 391
    return (-1);
  }
#line 393
  if (datafellows & 1) {
#line 394
    flags = 1;
  }
#line 396
  buffer_init(& msg);
#line 397
  buffer_put_char(& msg, 13);
#line 398
  buffer_put_string(& msg, (void const   *)blob, blen);
#line 399
  buffer_put_string(& msg, (void const   *)data, (unsigned int )datalen);
#line 400
  buffer_put_int(& msg, (unsigned int )flags);
#line 401
  xfree((void *)blob);
#line 403
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 403
  if (tmp___0 == 0) {
#line 404
    buffer_free(& msg);
#line 405
    return (-1);
  }
#line 407
  type = buffer_get_char(& msg);
#line 408
  if (type == 5) {
#line 409
    log("Agent admitted failure to sign using the key.");
  } else {
#line 408
    if (type == 102) {
#line 409
      log("Agent admitted failure to sign using the key.");
    } else {
#line 410
      if (type != 14) {
#line 411
        fatal("Bad authentication response: %d", type);
      } else {
#line 413
        ret = 0;
#line 414
        tmp___1 = buffer_get_string(& msg, (u_int *)lenp);
#line 414
        *sigp = (u_char *)tmp___1;
      }
    }
  }
#line 416
  buffer_free(& msg);
#line 417
  return (ret);
}
}
#line 422 "authfd.c"
void ssh_encode_identity_rsa1(Buffer *b , RSA *key , char const   *comment ) 
{ int tmp ;
  size_t tmp___0 ;

  {
#line 425
  buffer_clear(b);
#line 426
  buffer_put_char(b, 7);
#line 427
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 427
  buffer_put_int(b, (unsigned int )tmp);
#line 428
  buffer_put_bignum(b, key->n);
#line 429
  buffer_put_bignum(b, key->e);
#line 430
  buffer_put_bignum(b, key->d);
#line 432
  buffer_put_bignum(b, key->iqmp);
#line 433
  buffer_put_bignum(b, key->q);
#line 434
  buffer_put_bignum(b, key->p);
#line 435
  tmp___0 = strlen(comment);
#line 435
  buffer_put_string(b, (void const   *)comment, tmp___0);
#line 436
  return;
}
}
#line 438 "authfd.c"
void ssh_encode_identity_ssh2(Buffer *b , Key *key , char const   *comment ) 
{ char *tmp ;

  {
#line 441
  buffer_clear(b);
#line 442
  buffer_put_char(b, 17);
#line 443
  tmp = key_ssh_name(key);
#line 443
  buffer_put_cstring(b, (char const   *)tmp);
#line 444
  switch (key->type) {
  case 1: 
#line 446
  buffer_put_bignum2(b, (key->rsa)->n);
#line 447
  buffer_put_bignum2(b, (key->rsa)->e);
#line 448
  buffer_put_bignum2(b, (key->rsa)->d);
#line 449
  buffer_put_bignum2(b, (key->rsa)->iqmp);
#line 450
  buffer_put_bignum2(b, (key->rsa)->p);
#line 451
  buffer_put_bignum2(b, (key->rsa)->q);
#line 452
  break;
  case 2: 
#line 454
  buffer_put_bignum2(b, (key->dsa)->p);
#line 455
  buffer_put_bignum2(b, (key->dsa)->q);
#line 456
  buffer_put_bignum2(b, (key->dsa)->g);
#line 457
  buffer_put_bignum2(b, (key->dsa)->pub_key);
#line 458
  buffer_put_bignum2(b, (key->dsa)->priv_key);
#line 459
  break;
  }
#line 461
  buffer_put_cstring(b, comment);
#line 462
  return;
}
}
#line 469 "authfd.c"
int ssh_add_identity(AuthenticationConnection *auth , Key *key , char const   *comment ) 
{ Buffer msg ;
  int type ;
  int tmp ;
  int tmp___0 ;

  {
#line 475
  buffer_init(& msg);
#line 477
  switch (key->type) {
  case 0: 
#line 479
  ssh_encode_identity_rsa1(& msg, key->rsa, comment);
#line 480
  break;
  case 1: 
  case 2: 
#line 483
  ssh_encode_identity_ssh2(& msg, key, comment);
#line 484
  break;
  default: 
#line 486
  buffer_free(& msg);
#line 487
  return (0);
#line 488
  break;
  }
#line 490
  tmp = ssh_request_reply(auth, & msg, & msg);
#line 490
  if (tmp == 0) {
#line 491
    buffer_free(& msg);
#line 492
    return (0);
  }
#line 494
  type = buffer_get_char(& msg);
#line 495
  buffer_free(& msg);
#line 496
  tmp___0 = decode_reply(type);
#line 496
  return (tmp___0);
}
}
#line 504 "authfd.c"
int ssh_remove_identity(AuthenticationConnection *auth , Key *key ) 
{ Buffer msg ;
  int type ;
  u_char *blob ;
  u_int blen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 512
  buffer_init(& msg);
#line 514
  if (key->type == 0) {
#line 515
    buffer_put_char(& msg, 8);
#line 516
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 516
    buffer_put_int(& msg, (unsigned int )tmp);
#line 517
    buffer_put_bignum(& msg, (key->rsa)->e);
#line 518
    buffer_put_bignum(& msg, (key->rsa)->n);
  } else {
#line 519
    if (key->type == 2) {
#line 520
      key_to_blob(key, & blob, & blen);
#line 521
      buffer_put_char(& msg, 18);
#line 522
      buffer_put_string(& msg, (void const   *)blob, blen);
#line 523
      xfree((void *)blob);
    } else {
#line 519
      if (key->type == 1) {
#line 520
        key_to_blob(key, & blob, & blen);
#line 521
        buffer_put_char(& msg, 18);
#line 522
        buffer_put_string(& msg, (void const   *)blob, blen);
#line 523
        xfree((void *)blob);
      } else {
#line 525
        buffer_free(& msg);
#line 526
        return (0);
      }
    }
  }
#line 528
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 528
  if (tmp___0 == 0) {
#line 529
    buffer_free(& msg);
#line 530
    return (0);
  }
#line 532
  type = buffer_get_char(& msg);
#line 533
  buffer_free(& msg);
#line 534
  tmp___1 = decode_reply(type);
#line 534
  return (tmp___1);
}
}
#line 542 "authfd.c"
int ssh_remove_all_identities(AuthenticationConnection *auth , int version ) 
{ Buffer msg ;
  int type ;
  int code ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 547
  if (version == 1) {
#line 547
    tmp = 9;
  } else {
#line 547
    tmp = 19;
  }
#line 547
  code = tmp;
#line 551
  buffer_init(& msg);
#line 552
  buffer_put_char(& msg, code);
#line 554
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 554
  if (tmp___0 == 0) {
#line 555
    buffer_free(& msg);
#line 556
    return (0);
  }
#line 558
  type = buffer_get_char(& msg);
#line 559
  buffer_free(& msg);
#line 560
  tmp___1 = decode_reply(type);
#line 560
  return (tmp___1);
}
}
#line 563 "authfd.c"
int decode_reply(int type ) 
{ 

  {
#line 566
  switch (type) {
  case 5: 
  case 102: 
#line 569
  log("SSH_AGENT_FAILURE");
#line 570
  return (0);
  case 6: 
#line 572
  return (1);
  default: 
#line 574
  fatal("Bad response from authentication agent: %d", type);
  }
#line 577
  return (0);
}
}
#line 1 "authfile.o"
#pragma merger(0,"./authfile.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 256 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 212 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 380
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __attribute__((__nonnull__(3))) ;
#line 447
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 447 "/usr/include/sys/stat.h"
__inline static int fstat(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
#line 450
  tmp = __fxstat(3, __fd, __statbuf);
#line 450
  return (tmp);
}
}
#line 301 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 792
extern  __attribute__((__nothrow__)) int unlink(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 85 "/usr/include/fcntl.h"
extern int open(char const   *__file , int __oflag  , ...)  __attribute__((__nonnull__(1))) ;
#line 213 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 248
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 280
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 532
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 391 "/usr/include/openssl/bn.h"
extern BIGNUM const   *BN_value_one(void) ;
#line 393
extern BN_CTX *BN_CTX_new(void) ;
#line 397
extern void BN_CTX_free(BN_CTX *c ) ;
#line 407
extern BIGNUM *BN_new(void) ;
#line 409
extern void BN_clear_free(BIGNUM *a ) ;
#line 416
extern int BN_sub(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *b ) ;
#line 433
extern int BN_div(BIGNUM *dv , BIGNUM *rem , BIGNUM const   *m , BIGNUM const   *d ,
                  BN_CTX *ctx ) ;
#line 639 "/usr/include/openssl/evp.h"
extern EVP_CIPHER const   *EVP_des_ede3_cbc(void) ;
#line 749
extern struct rsa_st *EVP_PKEY_get1_RSA(EVP_PKEY *pkey ) ;
#line 754
extern struct dsa_st *EVP_PKEY_get1_DSA(EVP_PKEY *pkey ) ;
#line 763
extern void EVP_PKEY_free(EVP_PKEY *pkey ) ;
#line 616 "/usr/include/openssl/pem.h"
extern int PEM_write_RSAPrivateKey(FILE *fp , RSA *x , EVP_CIPHER const   *enc , unsigned char *kstr ,
                                   int klen , pem_password_cb *cb , void *u ) ;
#line 625
extern int PEM_write_DSAPrivateKey(FILE *fp , DSA *x , EVP_CIPHER const   *enc , unsigned char *kstr ,
                                   int klen , pem_password_cb *cb , void *u ) ;
#line 640
extern EVP_PKEY *PEM_read_PrivateKey(FILE *fp , EVP_PKEY **x , pem_password_cb *cb ,
                                     void *u ) ;
#line 108 "cipher.h"
Cipher *cipher_by_number(int id ) ;
#line 113
void cipher_encrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) ;
#line 114
void cipher_decrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) ;
#line 115
void cipher_set_key_string(CipherContext *cc , Cipher *cipher , char const   *passphrase ) ;
#line 32 "xmalloc.h"
char *xstrdup(char const   *str ) ;
#line 43 "buffer.h"
void buffer_append_space(Buffer *buffer , char **datap , u_int len ) ;
#line 54 "key.h"
Key *key_new_private(int type ) ;
#line 55
void key_free(Key *k ) ;
#line 58
char *key_type(Key *k ) ;
#line 60
int key_read(Key *ret , char **cpp ) ;
#line 63 "log.h"
void ( /* format attribute */  debug)(char const   *fmt  , ...) ;
#line 65
void ( /* format attribute */  debug3)(char const   *fmt  , ...) ;
#line 18 "authfile.h"
int key_save_private(Key *key , char const   *filename , char const   *passphrase ,
                     char const   *comment ) ;
#line 22
Key *key_load_public(char const   *filename , char **commentp ) ;
#line 25
Key *key_load_public_type(int type , char const   *filename , char **commentp ) ;
#line 28
Key *key_load_private(char const   *filename , char const   *passphrase , char **commentp ) ;
#line 32
Key *key_load_private_type(int type , char const   *filename , char const   *passphrase ,
                           char **commentp ) ;
#line 55 "authfile.c"
static char const   authfile_id_string[33]  = 
#line 55 "authfile.c"
  {      (char const   )'S',      (char const   )'S',      (char const   )'H',      (char const   )' ', 
        (char const   )'P',      (char const   )'R',      (char const   )'I',      (char const   )'V', 
        (char const   )'A',      (char const   )'T',      (char const   )'E',      (char const   )' ', 
        (char const   )'K',      (char const   )'E',      (char const   )'Y',      (char const   )' ', 
        (char const   )'F',      (char const   )'I',      (char const   )'L',      (char const   )'E', 
        (char const   )' ',      (char const   )'F',      (char const   )'O',      (char const   )'R', 
        (char const   )'M',      (char const   )'A',      (char const   )'T',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )'\n', 
        (char const   )'\000'};
#line 65 "authfile.c"
int key_save_private_rsa1(Key *key , char const   *filename , char const   *passphrase ,
                          char const   *comment ) 
{ Buffer buffer ;
  Buffer encrypted ;
  char buf___2[100] ;
  char *cp ;
  int fd ;
  int i ;
  CipherContext ciphercontext ;
  Cipher *cipher ;
  u_int32_t rand___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  u_int tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  u_int tmp___12 ;
  u_int tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  u_int tmp___19 ;
  char *tmp___20 ;
  ssize_t tmp___21 ;
  u_int tmp___22 ;

  {
#line 80
  if (0) {
#line 80
    __s1_len = strlen(passphrase);
#line 80
    __s2_len = strlen("");
#line 80
    if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
      goto _L___0;
    } else {
#line 80
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 80
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 80
          tmp___8 = 1;
        } else {
#line 80
          if (__s2_len >= 4U) {
#line 80
            tmp___8 = 1;
          } else {
#line 80
            tmp___8 = 0;
          }
        }
      } else {
#line 80
        tmp___8 = 0;
      }
    }
#line 80
    if (tmp___8) {
#line 80
      tmp___4 = __builtin_strcmp(passphrase, "");
    } else {
#line 80
      tmp___7 = __builtin_strcmp(passphrase, "");
#line 80
      tmp___4 = tmp___7;
    }
  } else {
#line 80
    tmp___7 = __builtin_strcmp(passphrase, "");
#line 80
    tmp___4 = tmp___7;
  }
#line 80
  if (tmp___4 == 0) {
#line 81
    cipher = cipher_by_number(0);
  } else {
#line 83
    cipher = cipher_by_number(3);
  }
#line 84
  if ((unsigned int )cipher == (unsigned int )((void *)0)) {
#line 85
    fatal("save_private_key_rsa: bad cipher");
  }
#line 88
  buffer_init(& buffer);
#line 91
  rand___0 = arc4random();
#line 92
  buf___2[0] = (char )(rand___0 & 255U);
#line 93
  buf___2[1] = (char )((rand___0 >> 8) & 255U);
#line 94
  buf___2[2] = buf___2[0];
#line 95
  buf___2[3] = buf___2[1];
#line 96
  buffer_append(& buffer, (char const   *)(buf___2), 4U);
#line 103
  buffer_put_bignum(& buffer, (key->rsa)->d);
#line 104
  buffer_put_bignum(& buffer, (key->rsa)->iqmp);
#line 105
  buffer_put_bignum(& buffer, (key->rsa)->q);
#line 106
  buffer_put_bignum(& buffer, (key->rsa)->p);
#line 109
  while (1) {
#line 109
    tmp___9 = buffer_len(& buffer);
#line 109
    if (! (tmp___9 % 8U != 0U)) {
#line 109
      break;
    }
#line 110
    buffer_put_char(& buffer, 0);
  }
#line 113
  buffer_init(& encrypted);
#line 116
  i = 0;
#line 116
  while (authfile_id_string[i]) {
#line 117
    buffer_put_char(& encrypted, (int )authfile_id_string[i]);
#line 116
    i ++;
  }
#line 118
  buffer_put_char(& encrypted, 0);
#line 121
  buffer_put_char(& encrypted, cipher->number);
#line 122
  buffer_put_int(& encrypted, 0U);
#line 125
  tmp___10 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 125
  buffer_put_int(& encrypted, (unsigned int )tmp___10);
#line 126
  buffer_put_bignum(& encrypted, (key->rsa)->n);
#line 127
  buffer_put_bignum(& encrypted, (key->rsa)->e);
#line 128
  tmp___11 = strlen(comment);
#line 128
  buffer_put_string(& encrypted, (void const   *)comment, tmp___11);
#line 131
  tmp___12 = buffer_len(& buffer);
#line 131
  buffer_append_space(& encrypted, & cp, tmp___12);
#line 133
  cipher_set_key_string(& ciphercontext, cipher, passphrase);
#line 134
  tmp___13 = buffer_len(& buffer);
#line 134
  tmp___14 = buffer_ptr(& buffer);
#line 134
  cipher_encrypt(& ciphercontext, (u_char *)cp, (u_char const   *)((u_char *)tmp___14),
                 tmp___13);
#line 136
  memset((void *)(& ciphercontext), 0, sizeof(ciphercontext));
#line 139
  memset((void *)(buf___2), 0, sizeof(buf___2));
#line 140
  buffer_free(& buffer);
#line 142
  fd = open(filename, 577, 384);
#line 143
  if (fd < 0) {
#line 144
    tmp___15 = __errno_location();
#line 144
    tmp___16 = strerror(*tmp___15);
#line 144
    error("open %s failed: %s.", filename, tmp___16);
#line 145
    return (0);
  }
#line 147
  tmp___19 = buffer_len(& encrypted);
#line 147
  tmp___20 = buffer_ptr(& encrypted);
#line 147
  tmp___21 = write(fd, (void const   *)tmp___20, tmp___19);
#line 147
  tmp___22 = buffer_len(& encrypted);
#line 147
  if ((u_int )tmp___21 != tmp___22) {
#line 149
    tmp___17 = __errno_location();
#line 149
    tmp___18 = strerror(*tmp___17);
#line 149
    error("write to key file %s failed: %s", filename, tmp___18);
#line 151
    buffer_free(& encrypted);
#line 152
    close(fd);
#line 153
    unlink(filename);
#line 154
    return (0);
  }
#line 156
  close(fd);
#line 157
  buffer_free(& encrypted);
#line 158
  return (1);
}
}
#line 162 "authfile.c"
int key_save_private_pem(Key *key , char const   *filename , char const   *_passphrase ,
                         char const   *comment ) 
{ FILE *fp ;
  int fd ;
  int success ;
  int len ;
  size_t tmp ;
  char *passphrase ;
  char *tmp___0 ;
  EVP_CIPHER *cipher ;
  EVP_CIPHER const   *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
#line 168
  success = 0;
#line 169
  tmp = strlen(_passphrase);
#line 169
  len = (int )tmp;
#line 170
  if (len > 0) {
#line 170
    tmp___0 = (char *)_passphrase;
  } else {
#line 170
    tmp___0 = (char *)((void *)0);
  }
#line 170
  passphrase = tmp___0;
#line 171
  if (len > 0) {
#line 171
    tmp___2 = EVP_des_ede3_cbc();
  } else {
#line 171
    tmp___2 = (EVP_CIPHER const   *)((void *)0);
  }
#line 171
  cipher = (EVP_CIPHER *)tmp___2;
#line 173
  if (len > 0) {
#line 173
    if (len <= 4) {
#line 174
      error("passphrase too short: have %d bytes, need > 4", len);
#line 175
      return (0);
    }
  }
#line 177
  fd = open(filename, 577, 384);
#line 178
  if (fd < 0) {
#line 179
    tmp___3 = __errno_location();
#line 179
    tmp___4 = strerror(*tmp___3);
#line 179
    error("open %s failed: %s.", filename, tmp___4);
#line 180
    return (0);
  }
#line 182
  fp = fdopen(fd, "w");
#line 183
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 184
    tmp___5 = __errno_location();
#line 184
    tmp___6 = strerror(*tmp___5);
#line 184
    error("fdopen %s failed: %s.", filename, tmp___6);
#line 185
    close(fd);
#line 186
    return (0);
  }
#line 188
  switch (key->type) {
  case 2: 
#line 190
  success = PEM_write_DSAPrivateKey(fp, key->dsa, (EVP_CIPHER const   *)cipher, (unsigned char *)passphrase,
                                    len, (pem_password_cb *)((void *)0), (void *)0);
#line 192
  break;
  case 1: 
#line 194
  success = PEM_write_RSAPrivateKey(fp, key->rsa, (EVP_CIPHER const   *)cipher, (unsigned char *)passphrase,
                                    len, (pem_password_cb *)((void *)0), (void *)0);
#line 196
  break;
  }
#line 198
  fclose(fp);
#line 199
  return (success);
}
}
#line 202 "authfile.c"
int key_save_private(Key *key , char const   *filename , char const   *passphrase ,
                     char const   *comment ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 206
  switch (key->type) {
  case 0: 
#line 208
  tmp = key_save_private_rsa1(key, filename, passphrase, comment);
#line 208
  return (tmp);
#line 210
  break;
  case 2: 
  case 1: 
#line 213
  tmp___0 = key_save_private_pem(key, filename, passphrase, comment);
#line 213
  return (tmp___0);
#line 215
  break;
  default: ;
#line 217
  break;
  }
#line 219
  error("key_save_private: cannot save key type %d", key->type);
#line 220
  return (0);
}
}
#line 229 "authfile.c"
Key *key_load_public_rsa1(int fd , char const   *filename , char **commentp ) 
{ Buffer buffer ;
  Key *pub ;
  char *cp ;
  int i ;
  off_t len ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;

  {
#line 238
  len = lseek(fd, 0L, 2);
#line 239
  lseek(fd, 0L, 0);
#line 241
  buffer_init(& buffer);
#line 242
  buffer_append_space(& buffer, & cp, (unsigned int )len);
#line 244
  tmp___1 = read(fd, (void *)cp, (unsigned int )len);
#line 244
  if ((unsigned int )tmp___1 != (unsigned int )len) {
#line 245
    tmp = __errno_location();
#line 245
    tmp___0 = strerror(*tmp);
#line 245
    debug("Read from key file %.200s failed: %.100s", filename, tmp___0);
#line 247
    buffer_free(& buffer);
#line 248
    return ((Key *)((void *)0));
  }
#line 252
  if ((unsigned long )len < (unsigned long )sizeof(authfile_id_string)) {
#line 253
    debug3("No RSA1 key file %.200s.", filename);
#line 254
    buffer_free(& buffer);
#line 255
    return ((Key *)((void *)0));
  }
#line 261
  i = 0;
#line 261
  while ((unsigned int )i < sizeof(authfile_id_string)) {
#line 262
    tmp___2 = buffer_get_char(& buffer);
#line 262
    if (tmp___2 != (int )authfile_id_string[i]) {
#line 263
      debug3("No RSA1 key file %.200s.", filename);
#line 264
      buffer_free(& buffer);
#line 265
      return ((Key *)((void *)0));
    }
#line 261
    i ++;
  }
#line 268
  buffer_get_char(& buffer);
#line 269
  buffer_get_int(& buffer);
#line 272
  buffer_get_int(& buffer);
#line 273
  pub = key_new(0);
#line 274
  buffer_get_bignum(& buffer, (pub->rsa)->n);
#line 275
  buffer_get_bignum(& buffer, (pub->rsa)->e);
#line 276
  if (commentp) {
#line 277
    *commentp = buffer_get_string(& buffer, (u_int *)((void *)0));
  }
#line 280
  buffer_free(& buffer);
#line 281
  return (pub);
}
}
#line 285 "authfile.c"
Key *key_load_public_type(int type , char const   *filename , char **commentp ) 
{ Key *pub ;
  int fd ;

  {
#line 291
  if (type == 0) {
#line 292
    fd = open(filename, 0);
#line 293
    if (fd < 0) {
#line 294
      return ((Key *)((void *)0));
    }
#line 295
    pub = key_load_public_rsa1(fd, filename, commentp);
#line 296
    close(fd);
#line 297
    return (pub);
  }
#line 299
  return ((Key *)((void *)0));
}
}
#line 309 "authfile.c"
Key *key_load_private_rsa1(int fd , char const   *filename , char const   *passphrase ,
                           char **commentp ) 
{ int i ;
  int check1 ;
  int check2 ;
  int cipher_type___0 ;
  off_t len ;
  Buffer buffer ;
  Buffer decrypted ;
  char *cp ;
  CipherContext ciphercontext ;
  Cipher *cipher ;
  BN_CTX *ctx ;
  BIGNUM *aux ;
  Key *prv ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  char *tmp___6 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___12 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  BIGNUM const   *tmp___19 ;
  BIGNUM const   *tmp___20 ;

  {
#line 321
  prv = (Key *)((void *)0);
#line 323
  len = lseek(fd, 0L, 2);
#line 324
  lseek(fd, 0L, 0);
#line 326
  buffer_init(& buffer);
#line 327
  buffer_append_space(& buffer, & cp, (unsigned int )len);
#line 329
  tmp___1 = read(fd, (void *)cp, (unsigned int )len);
#line 329
  if ((unsigned int )tmp___1 != (unsigned int )len) {
#line 330
    tmp = __errno_location();
#line 330
    tmp___0 = strerror(*tmp);
#line 330
    debug("Read from key file %.200s failed: %.100s", filename, tmp___0);
#line 332
    buffer_free(& buffer);
#line 333
    close(fd);
#line 334
    return ((Key *)((void *)0));
  }
#line 338
  if ((unsigned long )len < (unsigned long )sizeof(authfile_id_string)) {
#line 339
    debug3("No RSA1 key file %.200s.", filename);
#line 340
    buffer_free(& buffer);
#line 341
    close(fd);
#line 342
    return ((Key *)((void *)0));
  }
#line 348
  i = 0;
#line 348
  while ((unsigned int )i < sizeof(authfile_id_string)) {
#line 349
    tmp___2 = buffer_get_char(& buffer);
#line 349
    if (tmp___2 != (int )authfile_id_string[i]) {
#line 350
      debug3("No RSA1 key file %.200s.", filename);
#line 351
      buffer_free(& buffer);
#line 352
      close(fd);
#line 353
      return ((Key *)((void *)0));
    }
#line 348
    i ++;
  }
#line 357
  cipher_type___0 = buffer_get_char(& buffer);
#line 358
  buffer_get_int(& buffer);
#line 361
  buffer_get_int(& buffer);
#line 362
  prv = key_new_private(0);
#line 364
  buffer_get_bignum(& buffer, (prv->rsa)->n);
#line 365
  buffer_get_bignum(& buffer, (prv->rsa)->e);
#line 366
  if (commentp) {
#line 367
    *commentp = buffer_get_string(& buffer, (u_int *)((void *)0));
  } else {
#line 369
    tmp___3 = buffer_get_string(& buffer, (u_int *)((void *)0));
#line 369
    xfree((void *)tmp___3);
  }
#line 372
  cipher = cipher_by_number(cipher_type___0);
#line 373
  if ((unsigned int )cipher == (unsigned int )((void *)0)) {
#line 374
    debug("Unsupported cipher %d used in key file %.200s.", cipher_type___0, filename);
#line 376
    buffer_free(& buffer);
    goto fail;
  }
#line 380
  buffer_init(& decrypted);
#line 381
  tmp___4 = buffer_len(& buffer);
#line 381
  buffer_append_space(& decrypted, & cp, tmp___4);
#line 384
  cipher_set_key_string(& ciphercontext, cipher, passphrase);
#line 385
  tmp___5 = buffer_len(& buffer);
#line 385
  tmp___6 = buffer_ptr(& buffer);
#line 385
  cipher_decrypt(& ciphercontext, (u_char *)cp, (u_char const   *)((u_char *)tmp___6),
                 tmp___5);
#line 387
  memset((void *)(& ciphercontext), 0, sizeof(ciphercontext));
#line 388
  buffer_free(& buffer);
#line 390
  check1 = buffer_get_char(& decrypted);
#line 391
  check2 = buffer_get_char(& decrypted);
#line 392
  tmp___17 = buffer_get_char(& decrypted);
#line 392
  if (check1 != tmp___17) {
    goto _L___1;
  } else {
#line 392
    tmp___18 = buffer_get_char(& decrypted);
#line 392
    if (check2 != tmp___18) {
      _L___1: /* CIL Label */ 
#line 394
      if (0) {
#line 394
        __s1_len = strlen(passphrase);
#line 394
        __s2_len = strlen("");
#line 394
        if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
          goto _L___0;
        } else {
#line 394
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 394
            if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 394
              tmp___16 = 1;
            } else {
#line 394
              if (__s2_len >= 4U) {
#line 394
                tmp___16 = 1;
              } else {
#line 394
                tmp___16 = 0;
              }
            }
          } else {
#line 394
            tmp___16 = 0;
          }
        }
#line 394
        if (tmp___16) {
#line 394
          tmp___12 = __builtin_strcmp(passphrase, "");
        } else {
#line 394
          tmp___15 = __builtin_strcmp(passphrase, "");
#line 394
          tmp___12 = tmp___15;
        }
      } else {
#line 394
        tmp___15 = __builtin_strcmp(passphrase, "");
#line 394
        tmp___12 = tmp___15;
      }
#line 394
      if (tmp___12 != 0) {
#line 395
        debug("Bad passphrase supplied for key file %.200s.", filename);
      }
#line 398
      buffer_free(& decrypted);
      goto fail;
    }
  }
#line 402
  buffer_get_bignum(& decrypted, (prv->rsa)->d);
#line 403
  buffer_get_bignum(& decrypted, (prv->rsa)->iqmp);
#line 405
  buffer_get_bignum(& decrypted, (prv->rsa)->q);
#line 406
  buffer_get_bignum(& decrypted, (prv->rsa)->p);
#line 409
  ctx = BN_CTX_new();
#line 410
  aux = BN_new();
#line 412
  tmp___19 = BN_value_one();
#line 412
  BN_sub(aux, (BIGNUM const   *)(prv->rsa)->q, tmp___19);
#line 413
  BN_div((BIGNUM *)((void *)0), (prv->rsa)->dmq1, (BIGNUM const   *)(prv->rsa)->d,
         (BIGNUM const   *)aux, ctx);
#line 415
  tmp___20 = BN_value_one();
#line 415
  BN_sub(aux, (BIGNUM const   *)(prv->rsa)->p, tmp___20);
#line 416
  BN_div((BIGNUM *)((void *)0), (prv->rsa)->dmp1, (BIGNUM const   *)(prv->rsa)->d,
         (BIGNUM const   *)aux, ctx);
#line 418
  BN_clear_free(aux);
#line 419
  BN_CTX_free(ctx);
#line 421
  buffer_free(& decrypted);
#line 422
  close(fd);
#line 423
  return (prv);
  fail: 
#line 426
  if (commentp) {
#line 427
    xfree((void *)*commentp);
  }
#line 428
  close(fd);
#line 429
  key_free(prv);
#line 430
  return ((Key *)((void *)0));
}
}
#line 433 "authfile.c"
Key *key_load_private_pem(int fd , int type , char const   *passphrase , char **commentp ) 
{ FILE *fp ;
  EVP_PKEY *pk ;
  Key *prv ;
  char *name ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___2 ;
  char *tmp___3 ;

  {
#line 438
  pk = (EVP_PKEY *)((void *)0);
#line 439
  prv = (Key *)((void *)0);
#line 440
  name = (char *)"<no key>";
#line 442
  fp = fdopen(fd, "r");
#line 443
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 444
    tmp = __errno_location();
#line 444
    tmp___0 = strerror(*tmp);
#line 444
    error("fdopen failed: %s", tmp___0);
#line 445
    close(fd);
#line 446
    return ((Key *)((void *)0));
  }
#line 448
  pk = PEM_read_PrivateKey(fp, (EVP_PKEY **)((void *)0), (pem_password_cb *)((void *)0),
                           (void *)((char *)passphrase));
#line 449
  if ((unsigned int )pk == (unsigned int )((void *)0)) {
#line 450
    debug("PEM_read_PrivateKey failed");
#line 451
    ERR_get_error();
  } else {
#line 452
    if (pk->type == 6) {
#line 452
      if (type == 3) {
#line 454
        prv = key_new(3);
#line 455
        prv->rsa = EVP_PKEY_get1_RSA(pk);
#line 456
        prv->type = 1;
#line 457
        name = (char *)"rsa w/o comment";
      } else {
#line 452
        if (type == 1) {
#line 454
          prv = key_new(3);
#line 455
          prv->rsa = EVP_PKEY_get1_RSA(pk);
#line 456
          prv->type = 1;
#line 457
          name = (char *)"rsa w/o comment";
        } else {
          goto _L;
        }
      }
    } else {
      _L: /* CIL Label */ 
#line 461
      if (pk->type == 116) {
#line 461
        if (type == 3) {
#line 463
          prv = key_new(3);
#line 464
          prv->dsa = EVP_PKEY_get1_DSA(pk);
#line 465
          prv->type = 2;
#line 466
          name = (char *)"dsa w/o comment";
        } else {
#line 461
          if (type == 2) {
#line 463
            prv = key_new(3);
#line 464
            prv->dsa = EVP_PKEY_get1_DSA(pk);
#line 465
            prv->type = 2;
#line 466
            name = (char *)"dsa w/o comment";
          } else {
#line 471
            error("PEM_read_PrivateKey: mismatch or unknown EVP_PKEY save_type %d",
                  pk->save_type);
          }
        }
      } else {
#line 471
        error("PEM_read_PrivateKey: mismatch or unknown EVP_PKEY save_type %d", pk->save_type);
      }
    }
  }
#line 474
  fclose(fp);
#line 475
  if ((unsigned int )pk != (unsigned int )((void *)0)) {
#line 476
    EVP_PKEY_free(pk);
  }
#line 477
  if ((unsigned int )prv != (unsigned int )((void *)0)) {
#line 477
    if (commentp) {
#line 478
      *commentp = xstrdup((char const   *)name);
    }
  }
#line 479
  if (prv) {
#line 479
    tmp___3 = key_type(prv);
#line 479
    tmp___2 = (char const   *)tmp___3;
  } else {
#line 479
    tmp___2 = "<unknown>";
  }
#line 479
  debug("read PEM private key done: type %s", tmp___2);
#line 481
  return (prv);
}
}
#line 484 "authfile.c"
int key_perm_ok(int fd , char const   *filename ) 
{ struct stat st ;
  int tmp ;
  __uid_t tmp___0 ;
  __uid_t tmp___1 ;

  {
#line 493
  tmp = fstat(fd, & st);
#line 493
  if (tmp < 0) {
    goto _L;
  } else {
#line 493
    if (st.st_uid != 0U) {
#line 493
      tmp___0 = getuid();
#line 493
      if (tmp___0 != 0U) {
#line 493
        tmp___1 = getuid();
#line 493
        if (st.st_uid != tmp___1) {
          goto _L;
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 493
      if ((st.st_mode & 63U) != 0U) {
        _L: /* CIL Label */ 
#line 496
        close(fd);
#line 497
        error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 498
        error("@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @");
#line 499
        error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 500
        error("Bad ownership or mode(0%3.3o) for \'%s\'.", st.st_mode & 511U, filename);
#line 502
        error("It is recommended that your private key files are NOT accessible by others.");
#line 503
        error("This private key will be ignored.");
#line 504
        return (0);
      }
    }
  }
#line 506
  return (1);
}
}
#line 509 "authfile.c"
Key *key_load_private_type(int type , char const   *filename , char const   *passphrase ,
                           char **commentp ) 
{ int fd ;
  int tmp ;
  Key *tmp___0 ;
  Key *tmp___1 ;

  {
#line 515
  fd = open(filename, 0);
#line 516
  if (fd < 0) {
#line 517
    return ((Key *)((void *)0));
  }
#line 518
  tmp = key_perm_ok(fd, filename);
#line 518
  if (! tmp) {
#line 519
    error("bad permissions: ignore key: %s", filename);
#line 520
    close(fd);
#line 521
    return ((Key *)((void *)0));
  }
#line 523
  switch (type) {
  case 0: 
#line 525
  tmp___0 = key_load_private_rsa1(fd, filename, passphrase, commentp);
#line 525
  return (tmp___0);
#line 528
  break;
  case 2: 
  case 1: 
  case 3: 
#line 532
  tmp___1 = key_load_private_pem(fd, type, passphrase, commentp);
#line 532
  return (tmp___1);
#line 534
  break;
  default: 
#line 536
  close(fd);
#line 537
  break;
  }
#line 539
  return ((Key *)((void *)0));
}
}
#line 542 "authfile.c"
Key *key_load_private(char const   *filename , char const   *passphrase , char **commentp ) 
{ Key *pub ;
  int fd ;
  int tmp ;
  Key *tmp___0 ;
  Key *tmp___1 ;

  {
#line 549
  fd = open(filename, 0);
#line 550
  if (fd < 0) {
#line 551
    return ((Key *)((void *)0));
  }
#line 552
  tmp = key_perm_ok(fd, filename);
#line 552
  if (! tmp) {
#line 553
    error("bad permissions: ignore key: %s", filename);
#line 554
    close(fd);
#line 555
    return ((Key *)((void *)0));
  }
#line 557
  pub = key_load_public_rsa1(fd, filename, commentp);
#line 558
  lseek(fd, 0L, 0);
#line 559
  if ((unsigned int )pub == (unsigned int )((void *)0)) {
#line 561
    tmp___0 = key_load_private_pem(fd, 3, passphrase, (char **)((void *)0));
#line 561
    return (tmp___0);
  } else {
#line 564
    key_free(pub);
#line 566
    tmp___1 = key_load_private_rsa1(fd, filename, passphrase, (char **)((void *)0));
#line 566
    return (tmp___1);
  }
}
}
#line 570 "authfile.c"
int key_try_load_public(Key *k , char const   *filename , char **commentp ) 
{ FILE *f ;
  char line[4096] ;
  char *cp ;
  int tmp ;
  char *tmp___0 ;

  {
#line 577
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 578
  if ((unsigned int )f != (unsigned int )((void *)0)) {
#line 579
    while (1) {
#line 579
      tmp___0 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 579
      if (! tmp___0) {
#line 579
        break;
      }
#line 580
      line[sizeof(line) - 1U] = (char )'\000';
#line 581
      cp = line;
#line 582
      switch ((int )*cp) {
      case 35: 
      case 10: 
      case 0: 
#line 586
      continue;
      }
#line 589
      while (1) {
#line 589
        if (*cp) {
#line 589
          if (! ((int )*cp == 32)) {
#line 589
            if (! ((int )*cp == 9)) {
#line 589
              break;
            }
          }
        } else {
#line 589
          break;
        }
#line 589
        cp ++;
      }
#line 591
      if (*cp) {
#line 592
        tmp = key_read(k, & cp);
#line 592
        if (tmp == 1) {
#line 593
          if (commentp) {
#line 594
            *commentp = xstrdup(filename);
          }
#line 595
          fclose(f);
#line 596
          return (1);
        }
      }
    }
#line 600
    fclose(f);
  }
#line 602
  return (0);
}
}
#line 606 "authfile.c"
Key *key_load_public(char const   *filename , char **commentp ) 
{ Key *pub ;
  char file[4096] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 612
  pub = key_load_public_type(0, filename, commentp);
#line 613
  if ((unsigned int )pub != (unsigned int )((void *)0)) {
#line 614
    return (pub);
  }
#line 615
  pub = key_new(3);
#line 616
  tmp = key_try_load_public(pub, filename, commentp);
#line 616
  if (tmp == 1) {
#line 617
    return (pub);
  }
#line 618
  tmp___0 = strlcpy(file, filename, sizeof(file));
#line 618
  if (tmp___0 < sizeof(file)) {
#line 618
    tmp___1 = strlcat(file, ".pub", sizeof(file));
#line 618
    if (tmp___1 < sizeof(file)) {
#line 618
      tmp___2 = key_try_load_public(pub, (char const   *)(file), commentp);
#line 618
      if (tmp___2 == 1) {
#line 621
        return (pub);
      }
    }
  }
#line 622
  key_free(pub);
#line 623
  return ((Key *)((void *)0));
}
}
#line 1 "bufaux.o"
#pragma merger(0,"./bufaux.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 412 "/usr/include/openssl/bn.h"
extern BIGNUM *BN_bin2bn(unsigned char const   *s , int len , BIGNUM *ret ) ;
#line 413
extern int BN_bn2bin(BIGNUM const   *a , unsigned char *to ) ;
#line 49 "buffer.h"
void buffer_get(Buffer *buffer , char *buf___2 , u_int len ) ;
#line 52
void buffer_consume(Buffer *buffer , u_int bytes ) ;
#line 30 "bufaux.h"
int buffer_get_bignum2(Buffer *buffer , BIGNUM *value ) ;
#line 35
u_int64_t buffer_get_int64(Buffer *buffer ) ;
#line 41
void buffer_put_int64(Buffer *buffer , u_int64_t value ) ;
#line 52 "bufaux.c"
void buffer_put_bignum(Buffer *buffer , BIGNUM *value ) 
{ int bits ;
  int tmp ;
  int bin_size ;
  u_char *buf___2 ;
  void *tmp___0 ;
  int oi ;
  char msg[2] ;

  {
#line 55
  tmp = BN_num_bits((BIGNUM const   *)value);
#line 55
  bits = tmp;
#line 56
  bin_size = (bits + 7) / 8;
#line 57
  tmp___0 = xmalloc((unsigned int )bin_size);
#line 57
  buf___2 = (u_char *)tmp___0;
#line 62
  oi = BN_bn2bin((BIGNUM const   *)value, buf___2);
#line 63
  if (oi != bin_size) {
#line 64
    fatal("buffer_put_bignum: BN_bn2bin() failed: oi %d != bin_size %d", oi, bin_size);
  }
#line 68
  while (1) {
#line 68
    msg[0] = (char )(bits >> 8);
#line 68
    msg[1] = (char )bits;
#line 68
    break;
  }
#line 69
  buffer_append(buffer, (char const   *)(msg), 2U);
#line 71
  buffer_append(buffer, (char const   *)((char *)buf___2), (unsigned int )oi);
#line 73
  memset((void *)buf___2, 0, (unsigned int )bin_size);
#line 74
  xfree((void *)buf___2);
#line 75
  return;
}
}
#line 80 "bufaux.c"
int buffer_get_bignum(Buffer *buffer , BIGNUM *value ) 
{ int bits ;
  int bytes ;
  u_char buf___2[2] ;
  u_char *bin ;
  u_int tmp ;
  char *tmp___0 ;

  {
#line 87
  buffer_get(buffer, (char *)(buf___2), 2U);
#line 88
  bits = (int )(((unsigned long )buf___2[0] << 8) | (unsigned long )buf___2[1]);
#line 90
  bytes = (bits + 7) / 8;
#line 91
  tmp = buffer_len(buffer);
#line 91
  if (tmp < (u_int )bytes) {
#line 92
    fatal("buffer_get_bignum: input buffer too small");
  }
#line 93
  tmp___0 = buffer_ptr(buffer);
#line 93
  bin = (u_char *)tmp___0;
#line 94
  BN_bin2bn((unsigned char const   *)bin, bytes, value);
#line 95
  buffer_consume(buffer, (unsigned int )bytes);
#line 97
  return (2 + bytes);
}
}
#line 103 "bufaux.c"
void buffer_put_bignum2(Buffer *buffer , BIGNUM *value ) 
{ int bytes ;
  int tmp ;
  u_char *buf___2 ;
  void *tmp___0 ;
  int oi ;
  int hasnohigh ;
  int i ;
  int carry ;
  u_char *uc ;
  int tmp___1 ;

  {
#line 106
  tmp = BN_num_bits((BIGNUM const   *)value);
#line 106
  bytes = (tmp + 7) / 8 + 1;
#line 107
  tmp___0 = xmalloc((unsigned int )bytes);
#line 107
  buf___2 = (u_char *)tmp___0;
#line 109
  hasnohigh = 0;
#line 110
  *(buf___2 + 0) = (unsigned char )'\000';
#line 112
  oi = BN_bn2bin((BIGNUM const   *)value, buf___2 + 1);
#line 113
  if (oi != bytes - 1) {
#line 114
    fatal("buffer_put_bignum: BN_bn2bin() failed: oi %d != bin_size %d", oi, bytes);
  }
#line 116
  if ((int )*(buf___2 + 1) & 128) {
#line 116
    hasnohigh = 0;
  } else {
#line 116
    hasnohigh = 1;
  }
#line 117
  if (value->neg) {
#line 120
    uc = buf___2;
#line 121
    log("negativ!");
#line 122
    i = bytes - 1;
#line 122
    carry = 1;
#line 122
    while (i >= 0) {
#line 123
      *(uc + i) = (unsigned char )((int )*(uc + i) ^ 255);
#line 124
      if (carry) {
#line 125
        *(uc + i) = (u_char )((int )*(uc + i) + 1);
#line 125
        if (*(uc + i)) {
#line 125
          tmp___1 = 0;
        } else {
#line 125
          tmp___1 = 1;
        }
#line 125
        carry = tmp___1;
      }
#line 122
      i --;
    }
  }
#line 128
  buffer_put_string(buffer, (void const   *)(buf___2 + hasnohigh), (unsigned int )(bytes - hasnohigh));
#line 129
  memset((void *)buf___2, 0, (unsigned int )bytes);
#line 130
  xfree((void *)buf___2);
#line 131
  return;
}
}
#line 133 "bufaux.c"
int buffer_get_bignum2(Buffer *buffer , BIGNUM *value ) 
{ int len ;
  u_char *bin ;
  char *tmp ;

  {
#line 138
  tmp = buffer_get_string(buffer, (u_int *)(& len));
#line 138
  bin = (u_char *)tmp;
#line 139
  BN_bin2bn((unsigned char const   *)bin, len, value);
#line 140
  xfree((void *)bin);
#line 141
  return (len);
}
}
#line 147 "bufaux.c"
u_int buffer_get_int(Buffer *buffer ) 
{ u_char buf___2[4] ;

  {
#line 151
  buffer_get(buffer, (char *)(buf___2), 4U);
#line 152
  return ((unsigned int )(((((unsigned long )buf___2[0] << 24) | ((unsigned long )buf___2[1] << 16)) | ((unsigned long )buf___2[2] << 8)) | (unsigned long )buf___2[3]));
}
}
#line 156 "bufaux.c"
u_int64_t buffer_get_int64(Buffer *buffer ) 
{ u_char buf___2[8] ;

  {
#line 160
  buffer_get(buffer, (char *)(buf___2), 8U);
#line 161
  return (((((((((unsigned long long )buf___2[0] << 56) | ((unsigned long long )buf___2[1] << 48)) | ((unsigned long long )buf___2[2] << 40)) | ((unsigned long long )buf___2[3] << 32)) | ((unsigned long long )buf___2[4] << 24)) | ((unsigned long long )buf___2[5] << 16)) | ((unsigned long long )buf___2[6] << 8)) | (unsigned long long )buf___2[7]);
}
}
#line 168 "bufaux.c"
void buffer_put_int(Buffer *buffer , u_int value ) 
{ char buf___2[4] ;

  {
#line 172
  while (1) {
#line 172
    buf___2[0] = (char )(value >> 24);
#line 172
    buf___2[1] = (char )(value >> 16);
#line 172
    buf___2[2] = (char )(value >> 8);
#line 172
    buf___2[3] = (char )value;
#line 172
    break;
  }
#line 173
  buffer_append(buffer, (char const   *)(buf___2), 4U);
#line 174
  return;
}
}
#line 177 "bufaux.c"
void buffer_put_int64(Buffer *buffer , u_int64_t value ) 
{ char buf___2[8] ;

  {
#line 181
  while (1) {
#line 181
    buf___2[0] = (char )(value >> 56);
#line 181
    buf___2[1] = (char )(value >> 48);
#line 181
    buf___2[2] = (char )(value >> 40);
#line 181
    buf___2[3] = (char )(value >> 32);
#line 181
    buf___2[4] = (char )(value >> 24);
#line 181
    buf___2[5] = (char )(value >> 16);
#line 181
    buf___2[6] = (char )(value >> 8);
#line 181
    buf___2[7] = (char )value;
#line 181
    break;
  }
#line 182
  buffer_append(buffer, (char const   *)(buf___2), 8U);
#line 183
  return;
}
}
#line 194 "bufaux.c"
char *buffer_get_string(Buffer *buffer , u_int *length_ptr ) 
{ u_int len ;
  char *value ;
  void *tmp ;

  {
#line 200
  len = buffer_get_int(buffer);
#line 201
  if (len > 262144U) {
#line 202
    fatal("Received packet with bad string length %d", len);
  }
#line 204
  tmp = xmalloc(len + 1U);
#line 204
  value = (char *)tmp;
#line 206
  buffer_get(buffer, value, len);
#line 208
  *(value + len) = (char)0;
#line 210
  if (length_ptr) {
#line 211
    *length_ptr = len;
  }
#line 212
  return (value);
}
}
#line 218 "bufaux.c"
void buffer_put_string(Buffer *buffer , void const   *buf___2 , u_int len ) 
{ 

  {
#line 221
  buffer_put_int(buffer, len);
#line 222
  buffer_append(buffer, (char const   *)buf___2, len);
#line 223
  return;
}
}
#line 224 "bufaux.c"
void buffer_put_cstring(Buffer *buffer , char const   *s ) 
{ size_t tmp ;

  {
#line 227
  tmp = strlen(s);
#line 227
  buffer_put_string(buffer, (void const   *)s, tmp);
#line 228
  return;
}
}
#line 233 "bufaux.c"
int buffer_get_char(Buffer *buffer ) 
{ char ch ;

  {
#line 237
  buffer_get(buffer, & ch, 1U);
#line 238
  return ((int )((unsigned char )ch));
}
}
#line 244 "bufaux.c"
void buffer_put_char(Buffer *buffer , int value ) 
{ char ch ;

  {
#line 247
  ch = (char )value;
#line 248
  buffer_append(buffer, (char const   *)(& ch), 1U);
#line 249
  return;
}
}
#line 1 "buffer.o"
#pragma merger(0,"./buffer.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 38 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                  size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 43
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 144 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 327
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 26 "xmalloc.h"
void *xrealloc(void *ptr , size_t new_size ) ;
#line 55 "buffer.h"
void buffer_consume_end(Buffer *buffer , u_int bytes ) ;
#line 64
void buffer_dump(Buffer *buffer ) ;
#line 23 "buffer.c"
void buffer_init(Buffer *buffer ) 
{ void *tmp ;

  {
#line 26
  buffer->alloc = 4096U;
#line 27
  tmp = xmalloc(buffer->alloc);
#line 27
  buffer->buf = (char *)tmp;
#line 28
  buffer->offset = 0U;
#line 29
  buffer->end = 0U;
#line 30
  return;
}
}
#line 34 "buffer.c"
void buffer_free(Buffer *buffer ) 
{ 

  {
#line 37
  memset((void *)buffer->buf, 0, buffer->alloc);
#line 38
  xfree((void *)buffer->buf);
#line 39
  return;
}
}
#line 46 "buffer.c"
void buffer_clear(Buffer *buffer ) 
{ 

  {
#line 49
  buffer->offset = 0U;
#line 50
  buffer->end = 0U;
#line 51
  return;
}
}
#line 55 "buffer.c"
void buffer_append(Buffer *buffer , char const   *data , u_int len ) 
{ char *cp ;

  {
#line 59
  buffer_append_space(buffer, & cp, len);
#line 60
  memcpy((void * __restrict  )cp, (void const   * __restrict  )data, len);
#line 61
  return;
}
}
#line 69 "buffer.c"
void buffer_append_space(Buffer *buffer , char **datap , u_int len ) 
{ void *tmp ;

  {
#line 73
  if (buffer->offset == buffer->end) {
#line 74
    buffer->offset = 0U;
#line 75
    buffer->end = 0U;
  }
  restart: 
#line 79
  if (buffer->end + len < buffer->alloc) {
#line 80
    *datap = buffer->buf + buffer->end;
#line 81
    buffer->end += len;
#line 82
    return;
  }
#line 88
  if (buffer->offset > buffer->alloc / 2U) {
#line 89
    memmove((void *)buffer->buf, (void const   *)(buffer->buf + buffer->offset), buffer->end - buffer->offset);
#line 91
    buffer->end -= buffer->offset;
#line 92
    buffer->offset = 0U;
    goto restart;
  }
#line 96
  buffer->alloc += len + 32768U;
#line 97
  tmp = xrealloc((void *)buffer->buf, buffer->alloc);
#line 97
  buffer->buf = (char *)tmp;
  goto restart;
}
}
#line 103 "buffer.c"
u_int buffer_len(Buffer *buffer ) 
{ 

  {
#line 106
  return (buffer->end - buffer->offset);
}
}
#line 111 "buffer.c"
void buffer_get(Buffer *buffer , char *buf___2 , u_int len ) 
{ 

  {
#line 114
  if (len > buffer->end - buffer->offset) {
#line 115
    fatal("buffer_get: trying to get more bytes %d than in buffer %d", len, buffer->end - buffer->offset);
  }
#line 117
  memcpy((void * __restrict  )buf___2, (void const   * __restrict  )(buffer->buf + buffer->offset),
         len);
#line 118
  buffer->offset += len;
#line 119
  return;
}
}
#line 123 "buffer.c"
void buffer_consume(Buffer *buffer , u_int bytes ) 
{ 

  {
#line 126
  if (bytes > buffer->end - buffer->offset) {
#line 127
    fatal("buffer_consume: trying to get more bytes than in buffer");
  }
#line 128
  buffer->offset += bytes;
#line 129
  return;
}
}
#line 133 "buffer.c"
void buffer_consume_end(Buffer *buffer , u_int bytes ) 
{ 

  {
#line 136
  if (bytes > buffer->end - buffer->offset) {
#line 137
    fatal("buffer_consume_end: trying to get more bytes than in buffer");
  }
#line 138
  buffer->end -= bytes;
#line 139
  return;
}
}
#line 143 "buffer.c"
char *buffer_ptr(Buffer *buffer ) 
{ 

  {
#line 146
  return (buffer->buf + buffer->offset);
}
}
#line 151 "buffer.c"
void buffer_dump(Buffer *buffer ) 
{ int i ;
  u_char *ucp ;

  {
#line 155
  ucp = (u_char *)buffer->buf;
#line 157
  i = (int )buffer->offset;
#line 157
  while ((u_int )i < buffer->end) {
#line 158
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%02x", *(ucp + i));
#line 159
    if (((u_int )i - buffer->offset) % 16U == 15U) {
#line 160
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\r\n");
    } else {
#line 161
      if (((u_int )i - buffer->offset) % 2U == 1U) {
#line 162
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" ");
      }
    }
#line 157
    i ++;
  }
#line 164
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\r\n");
#line 165
  return;
}
}
#line 1 "canohost.o"
#pragma merger(0,"./canohost.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 128 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int getpeername(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 185
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
#line 357 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 83 "/usr/include/ctype.h"
extern __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 116
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 190
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 190 "/usr/include/ctype.h"
__inline static int tolower(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
#line 193
  if (__c >= -128) {
#line 193
    if (__c < 256) {
#line 193
      tmp___1 = __ctype_tolower_loc();
#line 193
      tmp___0 = *(*tmp___1 + __c);
    } else {
#line 193
      tmp___0 = (int const   )__c;
    }
  } else {
#line 193
    tmp___0 = (int const   )__c;
  }
#line 193
  return ((int )tmp___0);
}
}
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 290
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   * __restrict  __nptr ,
                                                            char ** __restrict  __endptr ,
                                                            int __base , int __group )  __attribute__((__nonnull__(1))) ;
#line 332
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 332 "/usr/include/stdlib.h"
__inline static long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                            int __base ) 
{ long tmp ;

  {
#line 336
  tmp = __strtol_internal(__nptr, __endptr, __base, 0);
#line 336
  return (tmp);
}
}
#line 401
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 401 "/usr/include/stdlib.h"
__inline static int atoi(char const   *__nptr ) 
{ long tmp ;

  {
#line 404
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 404
  return ((int )tmp);
}
}
#line 352 "/usr/include/netdb.h"
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 631
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 637
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
#line 646
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , unsigned int __flags ) ;
#line 32 "packet.h"
int packet_get_connection_in(void) ;
#line 150
void ( /* format attribute */  packet_disconnect)(char const   *fmt  , ...) ;
#line 208
int packet_connection_is_on_socket(void) ;
#line 68 "log.h"
void fatal_cleanup(void) ;
#line 20 "canohost.h"
char const   *get_canonical_hostname(int reverse_mapping_check ) ;
#line 26
char const   *get_remote_ipaddr(void) ;
#line 28
char const   *get_remote_name_or_ip(u_int utmp_len___0 , int reverse_mapping_check ) ;
#line 31
char *get_peer_ipaddr(int socket___0 ) ;
#line 32
int get_peer_port(int sock ) ;
#line 33
char *get_local_ipaddr(int socket___0 ) ;
#line 34
char *get_local_name(int socket___0 ) ;
#line 37
int get_remote_port(void) ;
#line 38
int get_local_port(void) ;
#line 22 "canohost.c"
void check_ip_options(int socket___0 , char *ipaddr ) ;
#line 29 "canohost.c"
char *get_remote_hostname(int socket___0 , int reverse_mapping_check ) 
{ struct sockaddr_storage from ;
  int i ;
  socklen_t fromlen ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char name[1025] ;
  char ntop[1025] ;
  char ntop2[1025] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  struct sockaddr_in6 *from6 ;
  struct sockaddr_in *from4 ;
  struct in_addr addr ;
  u_int16_t port ;
  register unsigned int __v ;
  register unsigned int __x ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int __res ;
  __int32_t const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;

  {
#line 39
  fromlen = sizeof(from);
#line 40
  memset((void *)(& from), 0, sizeof(from));
#line 41
  tmp___1 = getpeername(socket___0, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                        (socklen_t * __restrict  )(& fromlen));
#line 41
  if (tmp___1 < 0) {
#line 42
    tmp = __errno_location();
#line 42
    tmp___0 = strerror(*tmp);
#line 42
    debug("getpeername failed: %.100s", tmp___0);
#line 43
    fatal_cleanup();
  }
#line 46
  if ((int )from.ss_family == 10) {
#line 47
    from6 = (struct sockaddr_in6 *)(& from);
#line 51
    if (*((uint32_t const   *)(& from6->sin6_addr) + 0) == 0U) {
#line 51
      if (*((uint32_t const   *)(& from6->sin6_addr) + 1) == 0U) {
#line 51
        __x = 65535U;
#line 51
        __asm__  ("rorw $8, %w0;"
                  "rorl $16, %0;"
                  "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 51
        if (*((uint32_t const   *)(& from6->sin6_addr) + 2) == (uint32_t const   )__v) {
#line 52
          from4 = (struct sockaddr_in *)(& from);
#line 56
          memcpy((void * __restrict  )(& addr), (void const   * __restrict  )((char *)(& from6->sin6_addr) + 12),
                 sizeof(addr));
#line 57
          port = from6->sin6_port;
#line 59
          memset((void *)(& from), 0, sizeof(from));
#line 61
          from4->sin_family = (unsigned short)2;
#line 62
          memcpy((void * __restrict  )(& from4->sin_addr), (void const   * __restrict  )(& addr),
                 sizeof(addr));
#line 63
          from4->sin_port = port;
        }
      }
    }
  }
#line 67
  if ((int )from.ss_family == 2) {
#line 68
    check_ip_options(socket___0, ntop);
  }
#line 70
  tmp___2 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )((void *)0),
                        0U, 1U);
#line 70
  if (tmp___2 != 0) {
#line 72
    fatal("get_remote_hostname: getnameinfo NI_NUMERICHOST failed");
  }
#line 74
  debug3("Trying to reverse map address %.100s.", ntop);
#line 76
  tmp___4 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )(name), sizeof(name), (char * __restrict  )((void *)0),
                        0U, 8U);
#line 76
  if (tmp___4 != 0) {
#line 79
    log("Could not reverse map address %.100s.", ntop);
#line 80
    tmp___3 = xstrdup((char const   *)(ntop));
#line 80
    return (tmp___3);
  }
#line 84
  name[sizeof(name) - 1U] = (char )'\000';
#line 89
  i = 0;
#line 89
  while (name[i]) {
#line 90
    tmp___8 = __ctype_b_loc();
#line 90
    if ((int const   )*(*tmp___8 + (int )name[i]) & 256) {
#line 91
      if (sizeof(name[i]) > 1U) {
#line 91
        __res = tolower((int )name[i]);
      } else {
#line 91
        tmp___7 = __ctype_tolower_loc();
#line 91
        __res = (int )*(*tmp___7 + (int )name[i]);
      }
#line 91
      name[i] = (char )__res;
    }
#line 89
    i ++;
  }
#line 93
  if (! reverse_mapping_check) {
#line 94
    tmp___9 = xstrdup((char const   *)(name));
#line 94
    return (tmp___9);
  }
#line 104
  memset((void *)(& hints), 0, sizeof(hints));
#line 105
  hints.ai_family = (int )from.ss_family;
#line 106
  hints.ai_socktype = 1;
#line 107
  tmp___11 = getaddrinfo((char const   * __restrict  )(name), (char const   * __restrict  )((void *)0),
                         (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 107
  if (tmp___11 != 0) {
#line 108
    log("reverse mapping checking getaddrinfo for %.700s failed - POSSIBLE BREAKIN ATTEMPT!",
        name);
#line 110
    tmp___10 = xstrdup((char const   *)(ntop));
#line 110
    return (tmp___10);
  }
#line 113
  ai = aitop;
#line 113
  while (ai) {
#line 114
    tmp___12 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                           (char * __restrict  )(ntop2), sizeof(ntop2), (char * __restrict  )((void *)0),
                           0U, 1U);
#line 116
    if (tmp___12 == 0) {
#line 116
      if (0) {
#line 116
        __s1_len = strlen((char const   *)(ntop));
#line 116
        __s2_len = strlen((char const   *)(ntop2));
#line 116
        if (! ((unsigned int )((void const   *)(ntop + 1)) - (unsigned int )((void const   *)(ntop)) == 1U)) {
          goto _L___0;
        } else {
#line 116
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 116
            if (! ((unsigned int )((void const   *)(ntop2 + 1)) - (unsigned int )((void const   *)(ntop2)) == 1U)) {
#line 116
              tmp___22 = 1;
            } else {
#line 116
              if (__s2_len >= 4U) {
#line 116
                tmp___22 = 1;
              } else {
#line 116
                tmp___22 = 0;
              }
            }
          } else {
#line 116
            tmp___22 = 0;
          }
        }
#line 116
        if (tmp___22) {
#line 116
          tmp___18 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
        } else {
#line 116
          tmp___21 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
#line 116
          tmp___18 = tmp___21;
        }
      } else {
#line 116
        tmp___21 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
#line 116
        tmp___18 = tmp___21;
      }
#line 116
      if (tmp___18 == 0) {
#line 117
        break;
      }
    }
#line 113
    ai = ai->ai_next;
  }
#line 119
  freeaddrinfo(aitop);
#line 121
  if (! ai) {
#line 123
    log("Address %.100s maps to %.600s, but this does not map back to the address - POSSIBLE BREAKIN ATTEMPT!",
        ntop, name);
#line 126
    tmp___23 = xstrdup((char const   *)(ntop));
#line 126
    return (tmp___23);
  }
#line 128
  tmp___24 = xstrdup((char const   *)(name));
#line 128
  return (tmp___24);
}
}
#line 143 "canohost.c"
void check_ip_options(int socket___0 , char *ipaddr ) 
{ u_char options___0[200] ;
  char text[sizeof(options___0) * 3U + 1U] ;
  socklen_t option_size ;
  int i ;
  int ipproto ;
  struct protoent *ip ;
  int tmp ;

  {
#line 152
  ip = getprotobyname("ip");
#line 152
  if ((unsigned int )ip != (unsigned int )((void *)0)) {
#line 153
    ipproto = ip->p_proto;
  } else {
#line 155
    ipproto = 0;
  }
#line 156
  option_size = sizeof(options___0);
#line 157
  tmp = getsockopt(socket___0, ipproto, 4, (void * __restrict  )((void *)(options___0)),
                   (socklen_t * __restrict  )(& option_size));
#line 157
  if (tmp >= 0) {
#line 157
    if (option_size != 0U) {
#line 159
      text[0] = (char )'\000';
#line 160
      i = 0;
#line 160
      while ((socklen_t )i < option_size) {
#line 161
        snprintf((char * __restrict  )(text + i * 3), sizeof(text) - (unsigned int )(i * 3),
                 (char const   * __restrict  )" %2.2x", options___0[i]);
#line 160
        i ++;
      }
#line 163
      log("Connection from %.100s with IP options:%.800s", ipaddr, text);
#line 165
      packet_disconnect("Connection from %.100s with IP options:%.800s", ipaddr, text);
    }
  }
#line 168
  return;
}
}
#line 179 "canohost.c"
static char *canonical_host_name  =    (char *)((void *)0);
#line 180 "canohost.c"
static int reverse_mapping_checked  =    0;
#line 176 "canohost.c"
char const   *get_canonical_hostname(int reverse_mapping_check ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 183
  if ((unsigned int )canonical_host_name != (unsigned int )((void *)0)) {
#line 184
    if (reverse_mapping_checked != reverse_mapping_check) {
#line 185
      xfree((void *)canonical_host_name);
    } else {
#line 187
      return ((char const   *)canonical_host_name);
    }
  }
#line 191
  tmp___0 = packet_connection_is_on_socket();
#line 191
  if (tmp___0) {
#line 192
    tmp = packet_get_connection_in();
#line 192
    canonical_host_name = get_remote_hostname(tmp, reverse_mapping_check);
  } else {
#line 195
    canonical_host_name = xstrdup("UNKNOWN");
  }
#line 197
  reverse_mapping_checked = reverse_mapping_check;
#line 198
  return ((char const   *)canonical_host_name);
}
}
#line 205 "canohost.c"
char *get_socket_address(int socket___0 , int remote___0 , int flags ) 
{ struct sockaddr_storage addr ;
  socklen_t addrlen ;
  char ntop[1025] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
#line 213
  addrlen = sizeof(addr);
#line 214
  memset((void *)(& addr), 0, sizeof(addr));
#line 216
  if (remote___0) {
#line 217
    tmp___1 = getpeername(socket___0, (struct sockaddr * __restrict  )((struct sockaddr *)(& addr)),
                          (socklen_t * __restrict  )(& addrlen));
#line 217
    if (tmp___1 < 0) {
#line 219
      tmp = __errno_location();
#line 219
      tmp___0 = strerror(*tmp);
#line 219
      debug("get_socket_ipaddr: getpeername failed: %.100s", tmp___0);
#line 221
      return ((char *)((void *)0));
    }
  } else {
#line 224
    tmp___4 = getsockname(socket___0, (struct sockaddr * __restrict  )((struct sockaddr *)(& addr)),
                          (socklen_t * __restrict  )(& addrlen));
#line 224
    if (tmp___4 < 0) {
#line 226
      tmp___2 = __errno_location();
#line 226
      tmp___3 = strerror(*tmp___2);
#line 226
      debug("get_socket_ipaddr: getsockname failed: %.100s", tmp___3);
#line 228
      return ((char *)((void *)0));
    }
  }
#line 232
  tmp___5 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& addr)),
                        addrlen, (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )((void *)0),
                        0U, (unsigned int )flags);
#line 232
  if (tmp___5 != 0) {
#line 234
    error("get_socket_ipaddr: getnameinfo %d failed", flags);
#line 235
    return ((char *)((void *)0));
  }
#line 237
  tmp___6 = xstrdup((char const   *)(ntop));
#line 237
  return (tmp___6);
}
}
#line 240 "canohost.c"
char *get_peer_ipaddr(int socket___0 ) 
{ char *tmp ;

  {
#line 243
  tmp = get_socket_address(socket___0, 1, 1);
#line 243
  return (tmp);
}
}
#line 246 "canohost.c"
char *get_local_ipaddr(int socket___0 ) 
{ char *tmp ;

  {
#line 249
  tmp = get_socket_address(socket___0, 0, 1);
#line 249
  return (tmp);
}
}
#line 252 "canohost.c"
char *get_local_name(int socket___0 ) 
{ char *tmp ;

  {
#line 255
  tmp = get_socket_address(socket___0, 0, 8);
#line 255
  return (tmp);
}
}
#line 266 "canohost.c"
static char *canonical_host_ip  =    (char *)((void *)0);
#line 263 "canohost.c"
char const   *get_remote_ipaddr(void) 
{ int tmp ;
  int tmp___0 ;

  {
#line 269
  if ((unsigned int )canonical_host_ip == (unsigned int )((void *)0)) {
#line 270
    tmp___0 = packet_connection_is_on_socket();
#line 270
    if (tmp___0) {
#line 271
      tmp = packet_get_connection_in();
#line 271
      canonical_host_ip = get_peer_ipaddr(tmp);
#line 273
      if ((unsigned int )canonical_host_ip == (unsigned int )((void *)0)) {
#line 274
        fatal_cleanup();
      }
    } else {
#line 277
      canonical_host_ip = xstrdup("UNKNOWN");
    }
  }
#line 280
  return ((char const   *)canonical_host_ip);
}
}
#line 286 "canohost.c"
static char const   *remote  =    "";
#line 283 "canohost.c"
char const   *get_remote_name_or_ip(u_int utmp_len___0 , int reverse_mapping_check ) 
{ size_t tmp ;

  {
#line 287
  if (utmp_len___0 > 0U) {
#line 288
    remote = get_canonical_hostname(reverse_mapping_check);
  }
#line 289
  if (utmp_len___0 == 0U) {
#line 290
    remote = get_remote_ipaddr();
  } else {
#line 289
    tmp = strlen(remote);
#line 289
    if (tmp > utmp_len___0) {
#line 290
      remote = get_remote_ipaddr();
    }
  }
#line 291
  return (remote);
}
}
#line 296 "canohost.c"
int get_sock_port(int sock , int local ) 
{ struct sockaddr_storage from ;
  socklen_t fromlen ;
  char strport[32] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 304
  fromlen = sizeof(from);
#line 305
  memset((void *)(& from), 0, sizeof(from));
#line 306
  if (local) {
#line 307
    tmp___1 = getsockname(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 307
    if (tmp___1 < 0) {
#line 308
      tmp = __errno_location();
#line 308
      tmp___0 = strerror(*tmp);
#line 308
      error("getsockname failed: %.100s", tmp___0);
#line 309
      return (0);
    }
  } else {
#line 312
    tmp___4 = getpeername(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 312
    if (tmp___4 < 0) {
#line 313
      tmp___2 = __errno_location();
#line 313
      tmp___3 = strerror(*tmp___2);
#line 313
      debug("getpeername failed: %.100s", tmp___3);
#line 314
      fatal_cleanup();
    }
  }
#line 318
  tmp___5 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )((void *)0), 0U, (char * __restrict  )(strport),
                        sizeof(strport), 2U);
#line 318
  if (tmp___5 != 0) {
#line 320
    fatal("get_sock_port: getnameinfo NI_NUMERICSERV failed");
  }
#line 321
  tmp___6 = atoi((char const   *)(strport));
#line 321
  return (tmp___6);
}
}
#line 326 "canohost.c"
int get_port(int local ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 333
  tmp = packet_connection_is_on_socket();
#line 333
  if (! tmp) {
#line 334
    return (65535);
  }
#line 337
  tmp___0 = packet_get_connection_in();
#line 337
  tmp___1 = get_sock_port(tmp___0, local);
#line 337
  return (tmp___1);
}
}
#line 340 "canohost.c"
int get_peer_port(int sock ) 
{ int tmp ;

  {
#line 343
  tmp = get_sock_port(sock, 0);
#line 343
  return (tmp);
}
}
#line 346 "canohost.c"
int get_remote_port(void) 
{ int tmp ;

  {
#line 349
  tmp = get_port(0);
#line 349
  return (tmp);
}
}
#line 352 "canohost.c"
int get_local_port(void) 
{ int tmp ;

  {
#line 355
  tmp = get_port(1);
#line 355
  return (tmp);
}
}
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned int  ) ;  */
#line 1 "channels.o"
#pragma merger(0,"./channels.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 192 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 199
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 209
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 218
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
#line 62 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 102
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 170
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 573 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 745
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 801
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 845
extern  __attribute__((__nothrow__)) int gethostname(char *__name , size_t __len )  __attribute__((__nonnull__(1))) ;
#line 67 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 54 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
#line 407 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 632
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) )  __attribute__((__nonnull__(1))) ;
#line 729
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template )  __attribute__((__nonnull__(1))) ;
#line 640 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
#line 71 "packet.h"
int packet_is_interactive(void) ;
#line 74
void packet_start(int type ) ;
#line 77
void packet_put_char(int value ) ;
#line 80
void packet_put_int(u_int value ) ;
#line 87
void packet_put_string(char const   *buf___2 , u_int len ) ;
#line 88
void packet_put_cstring(char const   *str ) ;
#line 95
void packet_send(void) ;
#line 98
int packet_read(int *payload_len_ptr ) ;
#line 126
u_int packet_get_int(void) ;
#line 142
char *packet_get_string(u_int *length_ptr ) ;
#line 162
void ( /* format attribute */  packet_send_debug)(char const   *fmt  , ...) ;
#line 168
void packet_write_wait(void) ;
#line 177
int max_packet_size ;
#line 215
int packet_remaining(void) ;
#line 218
void packet_send_ignore(int nbytes ) ;
#line 22 "uidswap.h"
void temporarily_use_uid(struct passwd *pw ) ;
#line 28
void restore_uid(void) ;
#line 62 "log.h"
void ( /* format attribute */  verbose)(char const   *fmt  , ...) ;
#line 64
void ( /* format attribute */  debug2)(char const   *fmt  , ...) ;
#line 75
void fatal_add_cleanup(void (*proc)(void *context ) , void *context ) ;
#line 21 "misc.h"
void set_nonblock(int fd ) ;
#line 126 "channels.h"
void channel_open(int id ) ;
#line 127
void channel_request(int id , char *service , int wantconfirm ) ;
#line 128
void channel_request_start(int id , char *service , int wantconfirm ) ;
#line 129
void channel_register_callback(int id , int mtype , channel_callback_fn *fn , void *arg ) ;
#line 130
void channel_register_cleanup(int id , channel_callback_fn *fn ) ;
#line 131
void channel_register_filter(int id , channel_filter_fn *fn ) ;
#line 132
void channel_cancel_cleanup(int id ) ;
#line 133
Channel *channel_lookup(int id ) ;
#line 135
int channel_new(char *ctype , int type , int rfd , int wfd , int efd , int window ,
                int maxpack , int extusage , char *remote_name , int nonblock ) ;
#line 139
void channel_set_fds(int id , int rfd , int wfd , int efd , int extusage , int nonblock ) ;
#line 143
void deny_input_open(int type , int plen , void *ctxt ) ;
#line 145
void channel_input_channel_request(int type , int plen , void *ctxt ) ;
#line 146
void channel_input_close(int type , int plen , void *ctxt ) ;
#line 147
void channel_input_close_confirmation(int type , int plen , void *ctxt ) ;
#line 148
void channel_input_data(int type , int plen , void *ctxt ) ;
#line 149
void channel_input_extended_data(int type , int plen , void *ctxt ) ;
#line 150
void channel_input_ieof(int type , int plen , void *ctxt ) ;
#line 151
void channel_input_oclose(int type , int plen , void *ctxt ) ;
#line 152
void channel_input_open_confirmation(int type , int plen , void *ctxt ) ;
#line 153
void channel_input_open_failure(int type , int plen , void *ctxt ) ;
#line 154
void channel_input_port_open(int type , int plen , void *ctxt ) ;
#line 155
void channel_input_window_adjust(int type , int plen , void *ctxt ) ;
#line 158
void channel_set_options(int hostname_in_open ) ;
#line 165
int channel_allocate(int type , int sock , char *remote_name ) ;
#line 168
void channel_free(int id ) ;
#line 174
void channel_prepare_select(fd_set **readsetp , fd_set **writesetp , int *maxfdp ,
                            int rekeying ) ;
#line 182
void channel_after_select(fd_set *readset , fd_set *writeset ) ;
#line 185
void channel_output_poll(void) ;
#line 188
int channel_not_very_much_buffered_data(void) ;
#line 192
void channel_stop_listening(void) ;
#line 198
void channel_close_all(void) ;
#line 201
int channel_still_open(void) ;
#line 208
char *channel_open_message(void) ;
#line 214
int channel_request_local_forwarding(u_short listen_port , char const   *host_to_connect ,
                                     u_short port_to_connect , int gateway_ports ) ;
#line 217
int channel_request_forwarding(char const   *listen_address , u_short listen_port ,
                               char const   *host_to_connect , u_short port_to_connect ,
                               int gateway_ports , int remote_fwd ) ;
#line 228
void channel_request_remote_forwarding(u_short listen_port , char const   *host_to_connect ,
                                       u_short port_to_connect ) ;
#line 237
void channel_permit_all_opens(void) ;
#line 240
void channel_add_permitted_opens(char *host , int port ) ;
#line 243
void channel_clear_permitted_opens(void) ;
#line 250
void channel_input_port_forward_request(int is_root , int gateway_ports ) ;
#line 263
char *x11_create_display_inet(int screen_number , int x11_display_offset ) ;
#line 270
void x11_input_open(int type , int plen , void *ctxt ) ;
#line 282
void x11_request_forwarding_with_spoofing(int client_session_id , char const   *proto ,
                                          char const   *data ) ;
#line 287
void auth_request_forwarding(void) ;
#line 294
char *auth_get_socket_name(void) ;
#line 300
int auth_input_request_forwarding(struct passwd *pw ) ;
#line 303
void auth_input_open_request(int type , int plen , void *ctxt ) ;
#line 306
int channel_connect_to(char const   *host , u_short port ) ;
#line 307
int channel_connect_by_listen_adress(u_short listen_port ) ;
#line 308
int x11_connect_display(void) ;
#line 310
int channel_find_open(void) ;
#line 78 "nchan.h"
chan_event_fn *chan_rcvd_oclose ;
#line 79
chan_event_fn *chan_read_failed ;
#line 80
chan_event_fn *chan_ibuf_empty ;
#line 83
chan_event_fn *chan_rcvd_ieof ;
#line 84
chan_event_fn *chan_write_failed ;
#line 85
chan_event_fn *chan_obuf_empty ;
#line 87
int chan_is_dead(Channel *c ) ;
#line 89
void chan_init_iostates(Channel *c ) ;
#line 90
void chan_init(void) ;
#line 57 "compat.h"
int compat13 ;
#line 58
int compat20 ;
#line 75 "channels.c"
static Channel *channels  =    (Channel *)((void *)0);
#line 82 "channels.c"
static int channels_alloc  =    0;
#line 88 "channels.c"
static int channel_max_fd  =    0;
#line 91 "channels.c"
static char *channel_forwarded_auth_socket_name  =    (char *)((void *)0);
#line 92 "channels.c"
static char *channel_forwarded_auth_socket_dir  =    (char *)((void *)0);
#line 95 "channels.c"
char *x11_saved_proto  =    (char *)((void *)0);
#line 98 "channels.c"
char *x11_saved_data  =    (char *)((void *)0);
#line 99 "channels.c"
u_int x11_saved_data_len  =    (u_int )0;
#line 105 "channels.c"
char *x11_fake_data  =    (char *)((void *)0);
#line 106 "channels.c"
u_int x11_fake_data_len  ;
#line 121 "channels.c"
static ForwardPermission permitted_opens[100]  ;
#line 123 "channels.c"
static int num_permitted_opens  =    0;
#line 129 "channels.c"
static int all_opens_permitted  =    0;
#line 132 "channels.c"
static int have_hostname_in_open  =    0;
#line 135
int IPv4or6 ;
#line 137
void port_open_helper(Channel *c , char *rtype ) ;
#line 141 "channels.c"
void channel_set_options(int hostname_in_open ) 
{ 

  {
#line 144
  have_hostname_in_open = hostname_in_open;
#line 145
  return;
}
}
#line 149 "channels.c"
Channel *channel_lookup(int id ) 
{ Channel *c ;

  {
#line 153
  if (id < 0) {
#line 154
    log("channel_lookup: %d: bad id", id);
#line 155
    return ((Channel *)((void *)0));
  } else {
#line 153
    if (id > channels_alloc) {
#line 154
      log("channel_lookup: %d: bad id", id);
#line 155
      return ((Channel *)((void *)0));
    }
  }
#line 157
  c = channels + id;
#line 158
  if (c->type == 0) {
#line 159
    log("channel_lookup: %d: bad id: channel free", id);
#line 160
    return ((Channel *)((void *)0));
  }
#line 162
  return (c);
}
}
#line 170 "channels.c"
void channel_register_fds(Channel *c , int rfd , int wfd , int efd , int extusage ,
                          int nonblock ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 175
  if (channel_max_fd > rfd) {
#line 175
    channel_max_fd = channel_max_fd;
  } else {
#line 175
    channel_max_fd = rfd;
  }
#line 176
  if (channel_max_fd > wfd) {
#line 176
    channel_max_fd = channel_max_fd;
  } else {
#line 176
    channel_max_fd = wfd;
  }
#line 177
  if (channel_max_fd > efd) {
#line 177
    channel_max_fd = channel_max_fd;
  } else {
#line 177
    channel_max_fd = efd;
  }
#line 181
  c->rfd = rfd;
#line 182
  c->wfd = wfd;
#line 183
  if (rfd == wfd) {
#line 183
    c->sock = rfd;
  } else {
#line 183
    c->sock = -1;
  }
#line 184
  c->efd = efd;
#line 185
  c->extended_usage = extusage;
#line 188
  if (nonblock) {
#line 188
    tmp___0 = isatty(c->rfd);
#line 188
    if (tmp___0) {
#line 189
      debug("channel %d: rfd %d isatty", c->self, c->rfd);
#line 190
      c->isatty = 1;
#line 191
      tmp = isatty(c->wfd);
#line 191
      if (! tmp) {
#line 192
        error("channel %d: wfd %d is not a tty?", c->self, c->wfd);
      }
    } else {
#line 196
      c->isatty = 0;
    }
  } else {
#line 196
    c->isatty = 0;
  }
#line 200
  if (nonblock) {
#line 201
    if (rfd != -1) {
#line 202
      set_nonblock(rfd);
    }
#line 203
    if (wfd != -1) {
#line 204
      set_nonblock(wfd);
    }
#line 205
    if (efd != -1) {
#line 206
      set_nonblock(efd);
    }
  }
#line 208
  return;
}
}
#line 215 "channels.c"
int channel_new(char *ctype , int type , int rfd , int wfd , int efd , int window ,
                int maxpack , int extusage , char *remote_name , int nonblock ) 
{ int i ;
  int found ;
  Channel *c ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 223
  if (channels_alloc == 0) {
#line 224
    chan_init();
#line 225
    channels_alloc = 10;
#line 226
    tmp = xmalloc((unsigned int )channels_alloc * sizeof(Channel ));
#line 226
    channels = (Channel *)tmp;
#line 227
    i = 0;
#line 227
    while (i < channels_alloc) {
#line 228
      (channels + i)->type = 0;
#line 227
      i ++;
    }
#line 233
    fatal_add_cleanup((void (*)(void * ))(& channel_stop_listening), (void *)0);
  }
#line 236
  found = -1;
#line 236
  i = 0;
#line 236
  while (i < channels_alloc) {
#line 237
    if ((channels + i)->type == 0) {
#line 239
      found = i;
#line 240
      break;
    }
#line 236
    i ++;
  }
#line 242
  if (found == -1) {
#line 244
    found = channels_alloc;
#line 245
    channels_alloc += 10;
#line 246
    debug2("channel: expanding %d", channels_alloc);
#line 247
    tmp___0 = xrealloc((void *)channels, (unsigned int )channels_alloc * sizeof(Channel ));
#line 247
    channels = (Channel *)tmp___0;
#line 248
    i = found;
#line 248
    while (i < channels_alloc) {
#line 249
      (channels + i)->type = 0;
#line 248
      i ++;
    }
  }
#line 252
  c = channels + found;
#line 253
  buffer_init(& c->input);
#line 254
  buffer_init(& c->output);
#line 255
  buffer_init(& c->extended);
#line 256
  chan_init_iostates(c);
#line 257
  channel_register_fds(c, rfd, wfd, efd, extusage, nonblock);
#line 258
  c->self = found;
#line 259
  c->type = type;
#line 260
  c->ctype = ctype;
#line 261
  c->local_window = window;
#line 262
  c->local_window_max = window;
#line 263
  c->local_consumed = 0;
#line 264
  c->local_maxpacket = maxpack;
#line 265
  c->remote_id = -1;
#line 266
  c->remote_name = remote_name;
#line 267
  c->remote_window = 0;
#line 268
  c->remote_maxpacket = 0;
#line 269
  c->cb_fn = (channel_callback_fn *)((void *)0);
#line 270
  c->cb_arg = (void *)0;
#line 271
  c->cb_event = 0;
#line 272
  c->dettach_user = (channel_callback_fn *)((void *)0);
#line 273
  c->input_filter = (channel_filter_fn *)((void *)0);
#line 274
  debug("channel %d: new [%s]", found, remote_name);
#line 275
  return (found);
}
}
#line 278 "channels.c"
int channel_allocate(int type , int sock , char *remote_name ) 
{ int tmp ;

  {
#line 281
  tmp = channel_new((char *)"", type, sock, sock, -1, 0, 0, 0, remote_name, 1);
#line 281
  return (tmp);
}
}
#line 287 "channels.c"
void channel_close_fds(Channel *c ) 
{ 

  {
#line 290
  if (c->sock != -1) {
#line 291
    close(c->sock);
#line 292
    c->sock = -1;
  }
#line 294
  if (c->rfd != -1) {
#line 295
    close(c->rfd);
#line 296
    c->rfd = -1;
  }
#line 298
  if (c->wfd != -1) {
#line 299
    close(c->wfd);
#line 300
    c->wfd = -1;
  }
#line 302
  if (c->efd != -1) {
#line 303
    close(c->efd);
#line 304
    c->efd = -1;
  }
#line 306
  return;
}
}
#line 310 "channels.c"
void channel_free(int id ) 
{ Channel *c ;
  Channel *tmp ;
  char *s ;
  char *tmp___0 ;

  {
#line 313
  tmp = channel_lookup(id);
#line 313
  c = tmp;
#line 314
  tmp___0 = channel_open_message();
#line 314
  s = tmp___0;
#line 316
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 317
    packet_disconnect("channel free: bad local channel %d", id);
  }
#line 318
  debug("channel_free: channel %d: status: %s", id, s);
#line 319
  xfree((void *)s);
#line 321
  if ((unsigned int )c->dettach_user != (unsigned int )((void *)0)) {
#line 322
    debug("channel_free: channel %d: dettaching channel user", id);
#line 323
    (*(c->dettach_user))(c->self, (void *)0);
  }
#line 325
  if (c->sock != -1) {
#line 326
    shutdown(c->sock, 2);
  }
#line 327
  channel_close_fds(c);
#line 328
  buffer_free(& c->input);
#line 329
  buffer_free(& c->output);
#line 330
  buffer_free(& c->extended);
#line 331
  c->type = 0;
#line 332
  if (c->remote_name) {
#line 333
    xfree((void *)c->remote_name);
#line 334
    c->remote_name = (char *)((void *)0);
  }
#line 336
  return;
}
}
#line 347 "channels.c"
chan_fn *channel_pre[14]  ;
#line 348 "channels.c"
chan_fn *channel_post[14]  ;
#line 350 "channels.c"
void channel_pre_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 353
  __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 354
  return;
}
}
#line 356 "channels.c"
void channel_pre_connecting(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 359
  debug3("channel %d: waiting for connection", c->self);
#line 360
  __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 361
  return;
}
}
#line 363 "channels.c"
void channel_pre_open_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int tmp ;
  u_int tmp___0 ;

  {
#line 366
  tmp = buffer_len(& c->input);
#line 366
  if (tmp < (u_int )max_packet_size) {
#line 367
    __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 368
  tmp___0 = buffer_len(& c->output);
#line 368
  if (tmp___0 > 0U) {
#line 369
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 370
  return;
}
}
#line 372 "channels.c"
void channel_pre_open_15(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int tmp ;
  u_int tmp___0 ;

  {
#line 376
  if (c->istate == 1) {
#line 377
    tmp = buffer_len(& c->input);
#line 377
    if (tmp < (u_int )max_packet_size) {
#line 378
      __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
  }
#line 379
  if (c->ostate == 16) {
    goto _L;
  } else {
#line 379
    if (c->ostate == 32) {
      _L: /* CIL Label */ 
#line 381
      tmp___0 = buffer_len(& c->output);
#line 381
      if (tmp___0 > 0U) {
#line 382
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      } else {
#line 383
        if (c->ostate == 32) {
#line 384
          (*chan_obuf_empty)(c);
        }
      }
    }
  }
#line 387
  return;
}
}
#line 389 "channels.c"
void channel_pre_open_20(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;

  {
#line 392
  if (c->istate == 1) {
#line 392
    if (c->remote_window > 0) {
#line 392
      tmp = buffer_len(& c->input);
#line 392
      if (tmp < (u_int )c->remote_window) {
#line 395
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->rfd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->rfd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
  }
#line 396
  if (c->ostate == 16) {
    goto _L;
  } else {
#line 396
    if (c->ostate == 32) {
      _L: /* CIL Label */ 
#line 398
      tmp___0 = buffer_len(& c->output);
#line 398
      if (tmp___0 > 0U) {
#line 399
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->wfd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->wfd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      } else {
#line 400
        if (c->ostate == 32) {
#line 401
          (*chan_obuf_empty)(c);
        }
      }
    }
  }
#line 405
  if (c->efd != -1) {
#line 406
    if (c->extended_usage == 2) {
#line 406
      tmp___2 = buffer_len(& c->extended);
#line 406
      if (tmp___2 > 0U) {
#line 408
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 409
      if (c->extended_usage == 1) {
#line 409
        tmp___1 = buffer_len(& c->extended);
#line 409
        if (tmp___1 < (u_int )c->remote_window) {
#line 411
          __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        }
      }
    }
  }
#line 413
  return;
}
}
#line 415 "channels.c"
void channel_pre_input_draining(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int tmp ;

  {
#line 418
  tmp = buffer_len(& c->input);
#line 418
  if (tmp == 0U) {
#line 419
    packet_start(24);
#line 420
    packet_put_int((unsigned int )c->remote_id);
#line 421
    packet_send();
#line 422
    c->type = 5;
#line 423
    debug("channel %d: closing after input drain.", c->self);
  }
#line 425
  return;
}
}
#line 427 "channels.c"
void channel_pre_output_draining(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int tmp ;

  {
#line 430
  tmp = buffer_len(& c->output);
#line 430
  if (tmp == 0U) {
#line 431
    channel_free(c->self);
  } else {
#line 433
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 434
  return;
}
}
#line 444 "channels.c"
int x11_open_helper(Channel *c ) 
{ u_char *ucp ;
  u_int proto_len ;
  u_int data_len ;
  u_int tmp ;
  char *tmp___0 ;
  u_int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 451
  tmp = buffer_len(& c->output);
#line 451
  if (tmp < 12U) {
#line 452
    return (0);
  }
#line 455
  tmp___0 = buffer_ptr(& c->output);
#line 455
  ucp = (u_char *)tmp___0;
#line 456
  if ((int )*(ucp + 0) == 66) {
#line 457
    proto_len = (unsigned int )(256 * (int )*(ucp + 6) + (int )*(ucp + 7));
#line 458
    data_len = (unsigned int )(256 * (int )*(ucp + 8) + (int )*(ucp + 9));
  } else {
#line 459
    if ((int )*(ucp + 0) == 108) {
#line 460
      proto_len = (unsigned int )((int )*(ucp + 6) + 256 * (int )*(ucp + 7));
#line 461
      data_len = (unsigned int )((int )*(ucp + 8) + 256 * (int )*(ucp + 9));
    } else {
#line 463
      debug("Initial X11 packet contains bad byte order byte: 0x%x", *(ucp + 0));
#line 465
      return (-1);
    }
  }
#line 469
  tmp___1 = buffer_len(& c->output);
#line 469
  if (tmp___1 < (12U + ((proto_len + 3U) & 4294967292U)) + ((data_len + 3U) & 4294967292U)) {
#line 471
    return (0);
  }
#line 474
  tmp___2 = strlen((char const   *)x11_saved_proto);
#line 474
  if (proto_len != tmp___2) {
#line 476
    debug("X11 connection uses different authentication protocol.");
#line 477
    return (-1);
  } else {
#line 474
    tmp___3 = memcmp((void const   *)(ucp + 12), (void const   *)x11_saved_proto,
                     proto_len);
#line 474
    if (tmp___3 != 0) {
#line 476
      debug("X11 connection uses different authentication protocol.");
#line 477
      return (-1);
    }
  }
#line 480
  if (data_len != x11_fake_data_len) {
#line 483
    debug("X11 auth data does not match fake data.");
#line 484
    return (-1);
  } else {
#line 480
    tmp___4 = memcmp((void const   *)((ucp + 12) + ((proto_len + 3U) & 4294967292U)),
                     (void const   *)x11_fake_data, x11_fake_data_len);
#line 480
    if (tmp___4 != 0) {
#line 483
      debug("X11 auth data does not match fake data.");
#line 484
      return (-1);
    }
  }
#line 487
  if (x11_fake_data_len != x11_saved_data_len) {
#line 488
    error("X11 fake_data_len %d != saved_data_len %d", x11_fake_data_len, x11_saved_data_len);
#line 490
    return (-1);
  }
#line 497
  memcpy((void * __restrict  )((ucp + 12) + ((proto_len + 3U) & 4294967292U)), (void const   * __restrict  )x11_saved_data,
         x11_saved_data_len);
#line 499
  return (1);
}
}
#line 502 "channels.c"
void channel_pre_x11_open_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int ret ;
  int tmp ;

  {
#line 505
  tmp = x11_open_helper(c);
#line 505
  ret = tmp;
#line 506
  if (ret == 1) {
#line 508
    c->type = 4;
#line 509
    channel_pre_open_13(c, readset, writeset);
  } else {
#line 510
    if (ret == -1) {
#line 515
      log("X11 connection rejected because of wrong authentication.");
#line 516
      buffer_clear(& c->input);
#line 517
      buffer_clear(& c->output);
#line 518
      close(c->sock);
#line 519
      c->sock = -1;
#line 520
      c->type = 5;
#line 521
      packet_start(24);
#line 522
      packet_put_int((unsigned int )c->remote_id);
#line 523
      packet_send();
    }
  }
#line 525
  return;
}
}
#line 527 "channels.c"
void channel_pre_x11_open(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int ret ;
  int tmp ;

  {
#line 530
  tmp = x11_open_helper(c);
#line 530
  ret = tmp;
#line 531
  if (ret == 1) {
#line 532
    c->type = 4;
#line 533
    if (compat20) {
#line 534
      channel_pre_open_20(c, readset, writeset);
    } else {
#line 536
      channel_pre_open_15(c, readset, writeset);
    }
  } else {
#line 537
    if (ret == -1) {
#line 538
      debug("X11 rejected %d i%d/o%d", c->self, c->istate, c->ostate);
#line 539
      (*chan_read_failed)(c);
#line 540
      (*chan_write_failed)(c);
#line 541
      debug("X11 closed %d i%d/o%d", c->self, c->istate, c->ostate);
    }
  }
#line 543
  return;
}
}
#line 546 "channels.c"
int channel_decode_socks4(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_char *p ;
  u_char *host ;
  int len ;
  int have ;
  int i ;
  int found ;
  char username[256] ;
  struct __anonstruct_s4_req_71 s4_req ;
  struct __anonstruct_s4_req_71 s4_rsp ;
  u_int tmp ;
  char *tmp___0 ;
  u_int tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  register unsigned short __v ;
  register unsigned short __x ;

  {
#line 559
  debug2("channel %d: decode socks4", c->self);
#line 561
  tmp = buffer_len(& c->input);
#line 561
  have = (int )tmp;
#line 562
  len = (int )sizeof(s4_req);
#line 563
  if (have < len) {
#line 564
    return (0);
  }
#line 565
  tmp___0 = buffer_ptr(& c->input);
#line 565
  p = (u_char *)tmp___0;
#line 566
  found = 0;
#line 566
  i = len;
#line 566
  while (i < have) {
#line 567
    if ((int )*(p + i) == 0) {
#line 568
      found = 1;
#line 569
      break;
    }
#line 571
    if (i > 1024) {
#line 573
      debug("channel %d: decode socks4: too long", c->self);
#line 575
      return (-1);
    }
#line 566
    i ++;
  }
#line 578
  if (! found) {
#line 579
    return (0);
  }
#line 580
  buffer_get(& c->input, (char *)(& s4_req.version), 1U);
#line 581
  buffer_get(& c->input, (char *)(& s4_req.command), 1U);
#line 582
  buffer_get(& c->input, (char *)(& s4_req.dest_port), 2U);
#line 583
  buffer_get(& c->input, (char *)(& s4_req.dest_addr), 4U);
#line 584
  tmp___1 = buffer_len(& c->input);
#line 584
  have = (int )tmp___1;
#line 585
  tmp___2 = buffer_ptr(& c->input);
#line 585
  p = (u_char *)tmp___2;
#line 586
  tmp___3 = strlen((char const   *)p);
#line 586
  len = (int )tmp___3;
#line 587
  debug2("channel %d: decode socks4: user %s/%d", c->self, p, len);
#line 588
  if (len > have) {
#line 589
    fatal("channel %d: decode socks4: len %d > have %d", c->self, len, have);
  }
#line 591
  strlcpy(username, (char const   *)p, sizeof(username));
#line 592
  buffer_consume(& c->input, (unsigned int )len);
#line 593
  buffer_consume(& c->input, 1U);
#line 595
  tmp___4 = inet_ntoa(s4_req.dest_addr);
#line 595
  host = (u_char *)tmp___4;
#line 596
  strlcpy(c->path, (char const   *)host, sizeof(c->path));
#line 597
  __x = s4_req.dest_port;
#line 597
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 597
  c->host_port = (int )__v;
#line 599
  debug("channel %d: dynamic request: socks4 host %s port %u command %u", c->self,
        host, c->host_port, s4_req.command);
#line 602
  if ((int )s4_req.command != 1) {
#line 603
    debug("channel %d: cannot handle: socks4 cn %d", c->self, s4_req.command);
#line 605
    return (-1);
  }
#line 607
  s4_rsp.version = (unsigned char)0;
#line 608
  s4_rsp.command = (unsigned char)90;
#line 609
  s4_rsp.dest_port = (unsigned short)0;
#line 610
  s4_rsp.dest_addr.s_addr = 0U;
#line 611
  buffer_append(& c->output, (char const   *)((char *)(& s4_rsp)), sizeof(s4_rsp));
#line 612
  return (1);
}
}
#line 616 "channels.c"
void channel_pre_dynamic(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_char *p ;
  int have ;
  int ret ;
  u_int tmp ;
  char *tmp___0 ;

  {
#line 622
  tmp = buffer_len(& c->input);
#line 622
  have = (int )tmp;
#line 624
  debug2("channel %d: pre_dynamic: have %d", c->self, have);
#line 627
  if (have < 4) {
#line 629
    __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 630
    return;
  }
#line 633
  tmp___0 = buffer_ptr(& c->input);
#line 633
  p = (u_char *)tmp___0;
#line 634
  switch ((int )*(p + 0)) {
  case 4: 
#line 636
  ret = channel_decode_socks4(c, readset, writeset);
#line 637
  break;
  default: 
#line 639
  ret = -1;
#line 640
  break;
  }
#line 642
  if (ret < 0) {
#line 643
    channel_free(c->self);
  } else {
#line 644
    if (ret == 0) {
#line 645
      debug2("channel %d: pre_dynamic: need more", c->self);
#line 647
      __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    } else {
#line 650
      c->type = 3;
#line 651
      port_open_helper(c, (char *)"direct-tcpip");
    }
  }
#line 653
  return;
}
}
#line 656 "channels.c"
void channel_post_x11_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ struct sockaddr addr ;
  int newsock ;
  int newch ;
  socklen_t addrlen ;
  char buf___2[16384] ;
  char *remote_ipaddr ;
  int remote_port ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  register char __result ;

  {
#line 665
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 665
  if (__result) {
#line 666
    debug("X11 connection requested.");
#line 667
    addrlen = sizeof(addr);
#line 668
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 669
    if (newsock < 0) {
#line 670
      tmp = __errno_location();
#line 670
      tmp___0 = strerror(*tmp);
#line 670
      error("accept: %.100s", tmp___0);
#line 671
      return;
    }
#line 673
    remote_ipaddr = get_peer_ipaddr(newsock);
#line 674
    remote_port = get_peer_port(newsock);
#line 675
    snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"X11 connection from %.200s port %d",
             remote_ipaddr, remote_port);
#line 678
    tmp___1 = xstrdup((char const   *)(buf___2));
#line 678
    newch = channel_new((char *)"x11", 3, newsock, newsock, -1, c->local_window_max,
                        c->local_maxpacket, 0, tmp___1, 1);
#line 682
    if (compat20) {
#line 683
      packet_start(90);
#line 684
      packet_put_cstring("x11");
#line 685
      packet_put_int((unsigned int )newch);
#line 686
      packet_put_int((unsigned int )c->local_window_max);
#line 687
      packet_put_int((unsigned int )c->local_maxpacket);
#line 689
      packet_put_cstring((char const   *)remote_ipaddr);
#line 690
      if (datafellows & 8) {
#line 691
        debug("ssh2 x11 bug compat mode");
      } else {
#line 693
        packet_put_int((unsigned int )remote_port);
      }
#line 695
      packet_send();
    } else {
#line 697
      packet_start(27);
#line 698
      packet_put_int((unsigned int )newch);
#line 699
      if (have_hostname_in_open) {
#line 700
        tmp___2 = strlen((char const   *)(buf___2));
#line 700
        packet_put_string((char const   *)(buf___2), tmp___2);
      }
#line 701
      packet_send();
    }
#line 703
    xfree((void *)remote_ipaddr);
  }
#line 705
  return;
}
}
#line 707 "channels.c"
void port_open_helper(Channel *c , char *rtype ) 
{ int direct ;
  char buf___2[1024] ;
  char *remote_ipaddr ;
  char *tmp ;
  u_short remote_port ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 712
  tmp = get_peer_ipaddr(c->sock);
#line 712
  remote_ipaddr = tmp;
#line 713
  tmp___0 = get_peer_port(c->sock);
#line 713
  remote_port = (u_short )tmp___0;
#line 715
  if (0) {
#line 715
    __s1_len = strlen((char const   *)rtype);
#line 715
    __s2_len = strlen("direct-tcpip");
#line 715
    if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
      goto _L___0;
    } else {
#line 715
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 715
        if (! ((unsigned int )((void const   *)("direct-tcpip" + 1)) - (unsigned int )((void const   *)"direct-tcpip") == 1U)) {
#line 715
          tmp___10 = 1;
        } else {
#line 715
          if (__s2_len >= 4U) {
#line 715
            tmp___10 = 1;
          } else {
#line 715
            tmp___10 = 0;
          }
        }
      } else {
#line 715
        tmp___10 = 0;
      }
    }
#line 715
    if (tmp___10) {
#line 715
      tmp___6 = __builtin_strcmp((char const   *)rtype, "direct-tcpip");
    } else {
#line 715
      tmp___9 = __builtin_strcmp((char const   *)rtype, "direct-tcpip");
#line 715
      tmp___6 = tmp___9;
    }
  } else {
#line 715
    tmp___9 = __builtin_strcmp((char const   *)rtype, "direct-tcpip");
#line 715
    tmp___6 = tmp___9;
  }
#line 715
  direct = tmp___6 == 0;
#line 717
  snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"%s: listening port %d for %.100s port %d, connect from %.200s port %d",
           rtype, c->listening_port, c->path, c->host_port, remote_ipaddr, remote_port);
#line 723
  xfree((void *)c->remote_name);
#line 724
  c->remote_name = xstrdup((char const   *)(buf___2));
#line 726
  if (compat20) {
#line 727
    packet_start(90);
#line 728
    packet_put_cstring((char const   *)rtype);
#line 729
    packet_put_int((unsigned int )c->self);
#line 730
    packet_put_int((unsigned int )c->local_window_max);
#line 731
    packet_put_int((unsigned int )c->local_maxpacket);
#line 732
    if (direct) {
#line 734
      packet_put_cstring((char const   *)(c->path));
#line 735
      packet_put_int((unsigned int )c->host_port);
    } else {
#line 738
      packet_put_cstring((char const   *)(c->path));
#line 739
      packet_put_int((unsigned int )c->listening_port);
    }
#line 742
    packet_put_cstring((char const   *)remote_ipaddr);
#line 743
    packet_put_int((unsigned int )remote_port);
#line 744
    packet_send();
  } else {
#line 746
    packet_start(29);
#line 747
    packet_put_int((unsigned int )c->self);
#line 748
    packet_put_cstring((char const   *)(c->path));
#line 749
    packet_put_int((unsigned int )c->host_port);
#line 750
    if (have_hostname_in_open) {
#line 751
      packet_put_cstring((char const   *)c->remote_name);
    }
#line 752
    packet_send();
  }
#line 754
  xfree((void *)remote_ipaddr);
#line 755
  return;
}
}
#line 760 "channels.c"
void channel_post_port_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ Channel *nc ;
  struct sockaddr addr ;
  int newsock ;
  int newch ;
  int nextstate ;
  socklen_t addrlen ;
  char *rtype ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  register char __result ;

  {
#line 769
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 769
  if (__result) {
#line 770
    debug("Connection to port %d forwarding to %.100s port %d requested.", c->listening_port,
          c->path, c->host_port);
#line 774
    if (c->type == 11) {
#line 774
      rtype = (char *)"forwarded-tcpip";
    } else {
#line 774
      rtype = (char *)"direct-tcpip";
    }
#line 776
    if (c->host_port == 0) {
#line 776
      nextstate = 13;
    } else {
#line 776
      nextstate = 3;
    }
#line 779
    addrlen = sizeof(addr);
#line 780
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 781
    if (newsock < 0) {
#line 782
      tmp = __errno_location();
#line 782
      tmp___0 = strerror(*tmp);
#line 782
      error("accept: %.100s", tmp___0);
#line 783
      return;
    }
#line 785
    tmp___1 = xstrdup((char const   *)rtype);
#line 785
    newch = channel_new(rtype, nextstate, newsock, newsock, -1, c->local_window_max,
                        c->local_maxpacket, 0, tmp___1, 1);
#line 790
    nc = channel_lookup(newch);
#line 791
    if ((unsigned int )nc == (unsigned int )((void *)0)) {
#line 792
      error("xxx: no new channel:");
#line 793
      return;
    }
#line 795
    nc->listening_port = c->listening_port;
#line 796
    nc->host_port = c->host_port;
#line 797
    strlcpy(nc->path, (char const   *)(c->path), sizeof(nc->path));
#line 799
    if (nextstate != 13) {
#line 800
      port_open_helper(nc, rtype);
    }
  }
#line 802
  return;
}
}
#line 808 "channels.c"
void channel_post_auth_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ struct sockaddr addr ;
  int newsock ;
  int newch ;
  socklen_t addrlen ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  register char __result ;

  {
#line 815
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 815
  if (__result) {
#line 816
    addrlen = sizeof(addr);
#line 817
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 818
    if (newsock < 0) {
#line 819
      tmp = __errno_location();
#line 819
      tmp___0 = strerror(*tmp);
#line 819
      error("accept from auth socket: %.100s", tmp___0);
#line 820
      return;
    }
#line 822
    tmp___1 = xstrdup("accepted auth socket");
#line 822
    newch = channel_new((char *)"accepted auth socket", 3, newsock, newsock, -1, c->local_window_max,
                        c->local_maxpacket, 0, tmp___1, 1);
#line 826
    if (compat20) {
#line 827
      packet_start(90);
#line 828
      packet_put_cstring("auth-agent@openssh.com");
#line 829
      packet_put_int((unsigned int )newch);
#line 830
      packet_put_int((unsigned int )c->local_window_max);
#line 831
      packet_put_int((unsigned int )c->local_maxpacket);
    } else {
#line 833
      packet_start(31);
#line 834
      packet_put_int((unsigned int )newch);
    }
#line 836
    packet_send();
  }
#line 838
  return;
}
}
#line 840 "channels.c"
void channel_post_connecting(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int err ;
  int sz ;
  char *tmp ;
  int tmp___0 ;
  register char __result ;

  {
#line 843
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 843
  if (__result) {
#line 844
    err = 0;
#line 845
    sz = (int )sizeof(err);
#line 846
    c->type = 4;
#line 847
    tmp___0 = getsockopt(c->sock, 1, 4, (void * __restrict  )((char *)(& err)), (socklen_t * __restrict  )(& sz));
#line 847
    if (tmp___0 < 0) {
#line 848
      debug("getsockopt SO_ERROR failed");
    } else {
#line 850
      if (err == 0) {
#line 851
        debug("channel %d: connected)", c->self);
      } else {
#line 853
        tmp = strerror(err);
#line 853
        debug("channel %d: not connected: %s", c->self, tmp);
#line 855
        (*chan_read_failed)(c);
#line 856
        (*chan_write_failed)(c);
      }
    }
  }
#line 860
  return;
}
}
#line 862 "channels.c"
int channel_handle_rfd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char buf___2[16384] ;
  int len ;
  int *tmp ;
  int *tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;
  register char __result ;

  {
#line 869
  if (c->rfd != -1) {
#line 869
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->rfd % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )c->rfd / (8U * sizeof(__fd_mask ))]): "cc");
#line 869
    if (__result) {
#line 870
      len = read(c->rfd, (void *)(buf___2), sizeof(buf___2));
#line 871
      if (len < 0) {
#line 871
        tmp = __errno_location();
#line 871
        if (*tmp == 4) {
#line 872
          return (1);
        } else {
#line 871
          tmp___0 = __errno_location();
#line 871
          if (*tmp___0 == 11) {
#line 872
            return (1);
          }
        }
      }
#line 873
      if (len <= 0) {
#line 874
        debug("channel %d: read<=0 rfd %d len %d", c->self, c->rfd, len);
#line 876
        if (c->type != 4) {
#line 877
          debug("channel %d: not open", c->self);
#line 878
          channel_free(c->self);
#line 879
          return (-1);
        } else {
#line 880
          if (compat13) {
#line 881
            tmp___1 = buffer_len(& c->output);
#line 881
            buffer_consume(& c->output, tmp___1);
#line 882
            c->type = 8;
#line 883
            debug("channel %d: status set to input draining.", c->self);
          } else {
#line 885
            (*chan_read_failed)(c);
          }
        }
#line 887
        return (-1);
      }
#line 889
      if ((unsigned int )c->input_filter != (unsigned int )((void *)0)) {
#line 890
        tmp___2 = (*(c->input_filter))(c, buf___2, len);
#line 890
        if (tmp___2 == -1) {
#line 891
          debug("channel %d: filter stops", c->self);
#line 892
          (*chan_read_failed)(c);
        }
      } else {
#line 895
        buffer_append(& c->input, (char const   *)(buf___2), (unsigned int )len);
      }
    }
  }
#line 898
  return (1);
}
}
#line 900 "channels.c"
int channel_handle_wfd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ struct termios tio ;
  int len ;
  u_int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  u_int tmp___3 ;
  int tmp___4 ;
  register char __result ;
  u_int tmp___5 ;

  {
#line 908
  if (c->wfd != -1) {
#line 908
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->wfd % (8U * sizeof(__fd_mask ))),
                         "m" (writeset->__fds_bits[(unsigned int )c->wfd / (8U * sizeof(__fd_mask ))]): "cc");
#line 908
    if (__result) {
#line 908
      tmp___5 = buffer_len(& c->output);
#line 908
      if (tmp___5 > 0U) {
#line 910
        tmp = buffer_len(& c->output);
#line 910
        tmp___0 = buffer_ptr(& c->output);
#line 910
        len = write(c->wfd, (void const   *)tmp___0, tmp);
#line 912
        if (len < 0) {
#line 912
          tmp___1 = __errno_location();
#line 912
          if (*tmp___1 == 4) {
#line 913
            return (1);
          } else {
#line 912
            tmp___2 = __errno_location();
#line 912
            if (*tmp___2 == 11) {
#line 913
              return (1);
            }
          }
        }
#line 914
        if (len <= 0) {
#line 915
          if (c->type != 4) {
#line 916
            debug("channel %d: not open", c->self);
#line 917
            channel_free(c->self);
#line 918
            return (-1);
          } else {
#line 919
            if (compat13) {
#line 920
              tmp___3 = buffer_len(& c->output);
#line 920
              buffer_consume(& c->output, tmp___3);
#line 921
              debug("channel %d: status set to input draining.", c->self);
#line 922
              c->type = 8;
            } else {
#line 924
              (*chan_write_failed)(c);
            }
          }
#line 926
          return (-1);
        }
#line 928
        if (compat20) {
#line 928
          if (c->isatty) {
#line 929
            tmp___4 = tcgetattr(c->wfd, & tio);
#line 929
            if (tmp___4 == 0) {
#line 929
              if (! (tio.c_lflag & 8U)) {
#line 929
                if (tio.c_lflag & 2U) {
#line 937
                  packet_send_ignore(4 + len);
#line 938
                  packet_send();
                }
              }
            }
          }
        }
#line 941
        buffer_consume(& c->output, (unsigned int )len);
#line 942
        if (compat20) {
#line 942
          if (len > 0) {
#line 943
            c->local_consumed += len;
          }
        }
      }
    }
  }
#line 946
  return (1);
}
}
#line 948 "channels.c"
int channel_handle_efd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char buf___2[16384] ;
  int len ;
  u_int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  register char __result ;
  register char __result___0 ;
  u_int tmp___5 ;

  {
#line 955
  if (c->efd != -1) {
#line 957
    if (c->extended_usage == 2) {
#line 957
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))),
                           "m" (writeset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "cc");
#line 957
      if (__result___0) {
#line 957
        tmp___5 = buffer_len(& c->extended);
#line 957
        if (tmp___5 > 0U) {
#line 959
          tmp = buffer_len(& c->extended);
#line 959
          tmp___0 = buffer_ptr(& c->extended);
#line 959
          len = write(c->efd, (void const   *)tmp___0, tmp);
#line 961
          debug2("channel %d: written %d to efd %d", c->self, len, c->efd);
#line 963
          if (len < 0) {
#line 963
            tmp___1 = __errno_location();
#line 963
            if (*tmp___1 == 4) {
#line 964
              return (1);
            } else {
#line 963
              tmp___2 = __errno_location();
#line 963
              if (*tmp___2 == 11) {
#line 964
                return (1);
              }
            }
          }
#line 965
          if (len <= 0) {
#line 966
            debug2("channel %d: closing write-efd %d", c->self, c->efd);
#line 968
            close(c->efd);
#line 969
            c->efd = -1;
          } else {
#line 971
            buffer_consume(& c->extended, (unsigned int )len);
#line 972
            c->local_consumed += len;
          }
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 975
      if (c->extended_usage == 1) {
#line 975
        __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))),
                             "m" (readset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "cc");
#line 975
        if (__result) {
#line 976
          len = read(c->efd, (void *)(buf___2), sizeof(buf___2));
#line 977
          debug2("channel %d: read %d from efd %d", c->self, len, c->efd);
#line 979
          if (len < 0) {
#line 979
            tmp___3 = __errno_location();
#line 979
            if (*tmp___3 == 4) {
#line 980
              return (1);
            } else {
#line 979
              tmp___4 = __errno_location();
#line 979
              if (*tmp___4 == 11) {
#line 980
                return (1);
              }
            }
          }
#line 981
          if (len <= 0) {
#line 982
            debug2("channel %d: closing read-efd %d", c->self, c->efd);
#line 984
            close(c->efd);
#line 985
            c->efd = -1;
          } else {
#line 987
            buffer_append(& c->extended, (char const   *)(buf___2), (unsigned int )len);
          }
        }
      }
    }
  }
#line 991
  return (1);
}
}
#line 993 "channels.c"
int channel_check_window(Channel *c ) 
{ 

  {
#line 996
  if (c->type == 4) {
#line 996
    if (! (c->flags & 3)) {
#line 996
      if (c->local_window < c->local_window_max / 2) {
#line 996
        if (c->local_consumed > 0) {
#line 1000
          packet_start(93);
#line 1001
          packet_put_int((unsigned int )c->remote_id);
#line 1002
          packet_put_int((unsigned int )c->local_consumed);
#line 1003
          packet_send();
#line 1004
          debug2("channel %d: window %d sent adjust %d", c->self, c->local_window,
                 c->local_consumed);
#line 1007
          c->local_window += c->local_consumed;
#line 1008
          c->local_consumed = 0;
        }
      }
    }
  }
#line 1010
  return (1);
}
}
#line 1013 "channels.c"
void channel_post_open_1(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 1016
  channel_handle_rfd(c, readset, writeset);
#line 1017
  channel_handle_wfd(c, readset, writeset);
#line 1018
  return;
}
}
#line 1020 "channels.c"
void channel_post_open_2(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 1023
  channel_handle_rfd(c, readset, writeset);
#line 1024
  channel_handle_wfd(c, readset, writeset);
#line 1025
  channel_handle_efd(c, readset, writeset);
#line 1027
  channel_check_window(c);
#line 1028
  return;
}
}
#line 1030 "channels.c"
void channel_post_output_drain_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int len ;
  u_int tmp ;
  char *tmp___0 ;
  u_int tmp___1 ;
  register char __result ;
  u_int tmp___2 ;

  {
#line 1035
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 1035
  if (__result) {
#line 1035
    tmp___2 = buffer_len(& c->output);
#line 1035
    if (tmp___2 > 0U) {
#line 1036
      tmp = buffer_len(& c->output);
#line 1036
      tmp___0 = buffer_ptr(& c->output);
#line 1036
      len = write(c->sock, (void const   *)tmp___0, tmp);
#line 1038
      if (len <= 0) {
#line 1039
        tmp___1 = buffer_len(& c->output);
#line 1039
        buffer_consume(& c->output, tmp___1);
      } else {
#line 1041
        buffer_consume(& c->output, (unsigned int )len);
      }
    }
  }
#line 1043
  return;
}
}
#line 1045 "channels.c"
void channel_handler_init_20(void) 
{ 

  {
#line 1048
  channel_pre[4] = & channel_pre_open_20;
#line 1049
  channel_pre[7] = & channel_pre_x11_open;
#line 1050
  channel_pre[2] = & channel_pre_listener;
#line 1051
  channel_pre[11] = & channel_pre_listener;
#line 1052
  channel_pre[1] = & channel_pre_listener;
#line 1053
  channel_pre[6] = & channel_pre_listener;
#line 1054
  channel_pre[12] = & channel_pre_connecting;
#line 1055
  channel_pre[13] = & channel_pre_dynamic;
#line 1057
  channel_post[4] = & channel_post_open_2;
#line 1058
  channel_post[2] = & channel_post_port_listener;
#line 1059
  channel_post[11] = & channel_post_port_listener;
#line 1060
  channel_post[1] = & channel_post_x11_listener;
#line 1061
  channel_post[6] = & channel_post_auth_listener;
#line 1062
  channel_post[12] = & channel_post_connecting;
#line 1063
  channel_post[13] = & channel_post_open_2;
#line 1064
  return;
}
}
#line 1066 "channels.c"
void channel_handler_init_13(void) 
{ 

  {
#line 1069
  channel_pre[4] = & channel_pre_open_13;
#line 1070
  channel_pre[7] = & channel_pre_x11_open_13;
#line 1071
  channel_pre[1] = & channel_pre_listener;
#line 1072
  channel_pre[2] = & channel_pre_listener;
#line 1073
  channel_pre[6] = & channel_pre_listener;
#line 1074
  channel_pre[8] = & channel_pre_input_draining;
#line 1075
  channel_pre[9] = & channel_pre_output_draining;
#line 1076
  channel_pre[12] = & channel_pre_connecting;
#line 1077
  channel_pre[13] = & channel_pre_dynamic;
#line 1079
  channel_post[4] = & channel_post_open_1;
#line 1080
  channel_post[1] = & channel_post_x11_listener;
#line 1081
  channel_post[2] = & channel_post_port_listener;
#line 1082
  channel_post[6] = & channel_post_auth_listener;
#line 1083
  channel_post[9] = & channel_post_output_drain_13;
#line 1084
  channel_post[12] = & channel_post_connecting;
#line 1085
  channel_post[13] = & channel_post_open_1;
#line 1086
  return;
}
}
#line 1088 "channels.c"
void channel_handler_init_15(void) 
{ 

  {
#line 1091
  channel_pre[4] = & channel_pre_open_15;
#line 1092
  channel_pre[7] = & channel_pre_x11_open;
#line 1093
  channel_pre[1] = & channel_pre_listener;
#line 1094
  channel_pre[2] = & channel_pre_listener;
#line 1095
  channel_pre[6] = & channel_pre_listener;
#line 1096
  channel_pre[12] = & channel_pre_connecting;
#line 1097
  channel_pre[13] = & channel_pre_dynamic;
#line 1099
  channel_post[1] = & channel_post_x11_listener;
#line 1100
  channel_post[2] = & channel_post_port_listener;
#line 1101
  channel_post[6] = & channel_post_auth_listener;
#line 1102
  channel_post[4] = & channel_post_open_1;
#line 1103
  channel_post[12] = & channel_post_connecting;
#line 1104
  channel_post[13] = & channel_post_open_1;
#line 1105
  return;
}
}
#line 1107 "channels.c"
void channel_handler_init(void) 
{ int i ;

  {
#line 1111
  i = 0;
#line 1111
  while (i < 14) {
#line 1112
    channel_pre[i] = (chan_fn *)((void *)0);
#line 1113
    channel_post[i] = (chan_fn *)((void *)0);
#line 1111
    i ++;
  }
#line 1115
  if (compat20) {
#line 1116
    channel_handler_init_20();
  } else {
#line 1117
    if (compat13) {
#line 1118
      channel_handler_init_13();
    } else {
#line 1120
      channel_handler_init_15();
    }
  }
#line 1121
  return;
}
}
#line 1126
void channel_handler(chan_fn **ftab , fd_set *readset , fd_set *writeset ) ;
#line 1126 "channels.c"
static int did_init  =    0;
#line 1123 "channels.c"
void channel_handler(chan_fn **ftab , fd_set *readset , fd_set *writeset ) 
{ int i ;
  Channel *c ;
  int tmp ;

  {
#line 1130
  if (! did_init) {
#line 1131
    channel_handler_init();
#line 1132
    did_init = 1;
  }
#line 1134
  i = 0;
#line 1134
  while (i < channels_alloc) {
#line 1135
    c = channels + i;
#line 1136
    if (c->type == 0) {
      goto __Cont;
    }
#line 1138
    if ((unsigned int )*(ftab + c->type) == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 1140
    (*(*(ftab + c->type)))(c, readset, writeset);
#line 1141
    tmp = chan_is_dead(c);
#line 1141
    if (tmp) {
#line 1147
      if (c->wfd != -1) {
#line 1148
        __asm__  volatile   ("btrl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->wfd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->wfd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
#line 1149
      if (c->rfd != -1) {
#line 1150
        __asm__  volatile   ("btrl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->rfd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->rfd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
#line 1151
      if (c->efd != -1) {
#line 1152
        if (c->extended_usage == 1) {
#line 1153
          __asm__  volatile   ("btrl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        }
#line 1154
        if (c->extended_usage == 2) {
#line 1155
          __asm__  volatile   ("btrl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        }
      }
#line 1157
      channel_free(c->self);
    }
    __Cont: /* CIL Label */ 
#line 1134
    i ++;
  }
#line 1160
  return;
}
}
#line 1162 "channels.c"
void channel_prepare_select(fd_set **readsetp , fd_set **writesetp , int *maxfdp ,
                            int rekeying ) 
{ int n___0 ;
  u_int sz ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1169
  if (*maxfdp > channel_max_fd) {
#line 1169
    n___0 = *maxfdp;
  } else {
#line 1169
    n___0 = channel_max_fd;
  }
#line 1171
  sz = (((unsigned int )(n___0 + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask );
#line 1172
  if ((unsigned int )*readsetp == (unsigned int )((void *)0)) {
    goto _L;
  } else {
#line 1172
    if (n___0 > *maxfdp) {
      _L: /* CIL Label */ 
#line 1173
      if (*readsetp) {
#line 1174
        xfree((void *)*readsetp);
      }
#line 1175
      if (*writesetp) {
#line 1176
        xfree((void *)*writesetp);
      }
#line 1177
      tmp = xmalloc(sz);
#line 1177
      *readsetp = (fd_set *)tmp;
#line 1178
      tmp___0 = xmalloc(sz);
#line 1178
      *writesetp = (fd_set *)tmp___0;
#line 1179
      *maxfdp = n___0;
    }
  }
#line 1181
  memset((void *)*readsetp, 0, sz);
#line 1182
  memset((void *)*writesetp, 0, sz);
#line 1184
  if (! rekeying) {
#line 1185
    channel_handler(channel_pre, *readsetp, *writesetp);
  }
#line 1186
  return;
}
}
#line 1188 "channels.c"
void channel_after_select(fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 1191
  channel_handler(channel_post, readset, writeset);
#line 1192
  return;
}
}
#line 1196 "channels.c"
void channel_output_poll(void) 
{ int len ;
  int i ;
  Channel *c ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  char *tmp___4 ;
  u_int tmp___5 ;

  {
#line 1202
  i = 0;
#line 1202
  while (i < channels_alloc) {
#line 1203
    c = channels + i;
#line 1206
    if (compat13) {
#line 1207
      if (c->type != 4) {
#line 1207
        if (c->type != 8) {
          goto __Cont;
        }
      }
    } else {
#line 1211
      if (c->type != 4) {
        goto __Cont;
      }
    }
#line 1214
    if (compat20) {
#line 1214
      if (c->flags & 3) {
#line 1217
        debug2("channel %d: no data after CLOSE", c->self);
        goto __Cont;
      }
    }
#line 1222
    if (c->istate == 1) {
      goto _L___0;
    } else {
#line 1222
      if (c->istate == 2) {
        _L___0: /* CIL Label */ 
#line 1222
        tmp___2 = buffer_len(& c->input);
#line 1222
        len = (int )tmp___2;
#line 1222
        if (len > 0) {
#line 1226
          if (compat20) {
#line 1227
            if (len > c->remote_window) {
#line 1228
              len = c->remote_window;
            }
#line 1229
            if (len > c->remote_maxpacket) {
#line 1230
              len = c->remote_maxpacket;
            }
          } else {
#line 1232
            tmp = packet_is_interactive();
#line 1232
            if (tmp) {
#line 1233
              if (len > 1024) {
#line 1234
                len = 512;
              }
            } else {
#line 1237
              if (len > max_packet_size / 2) {
#line 1238
                len = max_packet_size / 2;
              }
            }
          }
#line 1241
          if (len > 0) {
#line 1242
            if (compat20) {
#line 1242
              tmp___0 = 94;
            } else {
#line 1242
              tmp___0 = 23;
            }
#line 1242
            packet_start(tmp___0);
#line 1244
            packet_put_int((unsigned int )c->remote_id);
#line 1245
            tmp___1 = buffer_ptr(& c->input);
#line 1245
            packet_put_string((char const   *)tmp___1, (unsigned int )len);
#line 1246
            packet_send();
#line 1247
            buffer_consume(& c->input, (unsigned int )len);
#line 1248
            c->remote_window -= len;
          }
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 1250
        if (c->istate == 2) {
#line 1251
          if (compat13) {
#line 1252
            fatal("cannot happen: istate == INPUT_WAIT_DRAIN for proto 1.3");
          }
#line 1257
          (*chan_ibuf_empty)(c);
        }
      }
    }
#line 1260
    if (compat20) {
#line 1260
      if (c->remote_window > 0) {
#line 1260
        tmp___5 = buffer_len(& c->extended);
#line 1260
        len = (int )tmp___5;
#line 1260
        if (len > 0) {
#line 1260
          if (c->extended_usage == 1) {
#line 1264
            tmp___3 = buffer_len(& c->extended);
#line 1264
            debug2("channel %d: rwin %d elen %d euse %d", c->self, c->remote_window,
                   tmp___3, c->extended_usage);
#line 1267
            if (len > c->remote_window) {
#line 1268
              len = c->remote_window;
            }
#line 1269
            if (len > c->remote_maxpacket) {
#line 1270
              len = c->remote_maxpacket;
            }
#line 1271
            packet_start(95);
#line 1272
            packet_put_int((unsigned int )c->remote_id);
#line 1273
            packet_put_int(1U);
#line 1274
            tmp___4 = buffer_ptr(& c->extended);
#line 1274
            packet_put_string((char const   *)tmp___4, (unsigned int )len);
#line 1275
            packet_send();
#line 1276
            buffer_consume(& c->extended, (unsigned int )len);
#line 1277
            c->remote_window -= len;
#line 1278
            debug2("channel %d: sent ext data %d", c->self, len);
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1202
    i ++;
  }
#line 1281
  return;
}
}
#line 1289 "channels.c"
void channel_input_data(int type , int plen , void *ctxt ) 
{ int id ;
  char *data ;
  u_int data_len ;
  Channel *c ;
  u_int tmp ;
  int _len ;
  int tmp___0 ;
  int _p ;
  int _e ;

  {
#line 1298
  tmp = packet_get_int();
#line 1298
  id = (int )tmp;
#line 1299
  c = channel_lookup(id);
#line 1300
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1301
    packet_disconnect("Received data for nonexistent channel %d.", id);
  }
#line 1304
  if (c->type != 4) {
#line 1304
    if (c->type != 7) {
#line 1306
      return;
    }
  }
#line 1309
  if (! compat13) {
#line 1309
    if (c->ostate != 16) {
#line 1310
      return;
    }
  }
#line 1313
  data = packet_get_string(& data_len);
#line 1314
  while (1) {
#line 1314
    tmp___0 = packet_remaining();
#line 1314
    _len = tmp___0;
#line 1314
    if (_len > 0) {
#line 1314
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1314);
#line 1314
      packet_disconnect("Packet integrity error.");
    }
#line 1314
    break;
  }
#line 1316
  if (compat20) {
#line 1317
    if (data_len > (u_int )c->local_maxpacket) {
#line 1318
      log("channel %d: rcvd big packet %d, maxpack %d", c->self, data_len, c->local_maxpacket);
    }
#line 1321
    if (data_len > (u_int )c->local_window) {
#line 1322
      log("channel %d: rcvd too much data %d, win %d", c->self, data_len, c->local_window);
#line 1324
      xfree((void *)data);
#line 1325
      return;
    }
#line 1327
    c->local_window = (int )((u_int )c->local_window - data_len);
  } else {
#line 1329
    while (1) {
#line 1329
      _p = plen;
#line 1329
      _e = (int )(8U + data_len);
#line 1329
      if (_p != _e) {
#line 1329
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1329);
#line 1329
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1329
      break;
    }
  }
#line 1331
  buffer_append(& c->output, (char const   *)data, data_len);
#line 1332
  xfree((void *)data);
#line 1333
  return;
}
}
#line 1334 "channels.c"
void channel_input_extended_data(int type , int plen , void *ctxt ) 
{ int id ;
  int tcode ;
  char *data ;
  u_int data_len ;
  Channel *c ;
  u_int tmp ;
  u_int tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1344
  tmp = packet_get_int();
#line 1344
  id = (int )tmp;
#line 1345
  c = channel_lookup(id);
#line 1347
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1348
    packet_disconnect("Received extended_data for bad channel %d.", id);
  }
#line 1349
  if (c->type != 4) {
#line 1350
    log("channel %d: ext data for non open", id);
#line 1351
    return;
  }
#line 1353
  tmp___0 = packet_get_int();
#line 1353
  tcode = (int )tmp___0;
#line 1354
  if (c->efd == -1) {
#line 1357
    log("channel %d: bad ext data", c->self);
#line 1358
    return;
  } else {
#line 1354
    if (c->extended_usage != 2) {
#line 1357
      log("channel %d: bad ext data", c->self);
#line 1358
      return;
    } else {
#line 1354
      if (tcode != 1) {
#line 1357
        log("channel %d: bad ext data", c->self);
#line 1358
        return;
      }
    }
  }
#line 1360
  data = packet_get_string(& data_len);
#line 1361
  while (1) {
#line 1361
    tmp___1 = packet_remaining();
#line 1361
    _len = tmp___1;
#line 1361
    if (_len > 0) {
#line 1361
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1361);
#line 1361
      packet_disconnect("Packet integrity error.");
    }
#line 1361
    break;
  }
#line 1362
  if (data_len > (u_int )c->local_window) {
#line 1363
    log("channel %d: rcvd too much extended_data %d, win %d", c->self, data_len, c->local_window);
#line 1365
    xfree((void *)data);
#line 1366
    return;
  }
#line 1368
  debug2("channel %d: rcvd ext data %d", c->self, data_len);
#line 1369
  c->local_window = (int )((u_int )c->local_window - data_len);
#line 1370
  buffer_append(& c->extended, (char const   *)data, data_len);
#line 1371
  xfree((void *)data);
#line 1372
  return;
}
}
#line 1380 "channels.c"
int channel_not_very_much_buffered_data(void) 
{ u_int i ;
  Channel *c ;
  u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;

  {
#line 1386
  i = 0U;
#line 1386
  while (i < (u_int )channels_alloc) {
#line 1387
    c = channels + i;
#line 1388
    if (c->type == 4) {
#line 1389
      if (! compat20) {
#line 1389
        tmp___0 = buffer_len(& c->input);
#line 1389
        if (tmp___0 > (u_int )max_packet_size) {
#line 1390
          tmp = buffer_len(& c->input);
#line 1390
          debug("channel %d: big input buffer %d", c->self, tmp);
#line 1392
          return (0);
        }
      }
#line 1394
      tmp___2 = buffer_len(& c->output);
#line 1394
      if (tmp___2 > (u_int )max_packet_size) {
#line 1395
        tmp___1 = buffer_len(& c->output);
#line 1395
        debug("channel %d: big output buffer %d", c->self, tmp___1);
#line 1397
        return (0);
      }
    }
#line 1386
    i ++;
  }
#line 1401
  return (1);
}
}
#line 1404 "channels.c"
void channel_input_ieof(int type , int plen , void *ctxt ) 
{ int id ;
  Channel *c ;
  int _p ;
  int _e ;
  u_int tmp ;

  {
#line 1410
  while (1) {
#line 1410
    _p = plen;
#line 1410
    _e = 4;
#line 1410
    if (_p != _e) {
#line 1410
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1410);
#line 1410
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 1410
    break;
  }
#line 1412
  tmp = packet_get_int();
#line 1412
  id = (int )tmp;
#line 1413
  c = channel_lookup(id);
#line 1414
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1415
    packet_disconnect("Received ieof for nonexistent channel %d.", id);
  }
#line 1416
  (*chan_rcvd_ieof)(c);
#line 1417
  return;
}
}
#line 1419 "channels.c"
void channel_input_close(int type , int plen , void *ctxt ) 
{ int id ;
  Channel *c ;
  int _p ;
  int _e ;
  u_int tmp ;
  u_int tmp___0 ;

  {
#line 1425
  while (1) {
#line 1425
    _p = plen;
#line 1425
    _e = 4;
#line 1425
    if (_p != _e) {
#line 1425
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1425);
#line 1425
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 1425
    break;
  }
#line 1427
  tmp = packet_get_int();
#line 1427
  id = (int )tmp;
#line 1428
  c = channel_lookup(id);
#line 1429
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1430
    packet_disconnect("Received close for nonexistent channel %d.", id);
  }
#line 1436
  packet_start(25);
#line 1437
  packet_put_int((unsigned int )c->remote_id);
#line 1438
  packet_send();
#line 1447
  if (c->type != 5) {
#line 1452
    tmp___0 = buffer_len(& c->input);
#line 1452
    buffer_consume(& c->input, tmp___0);
#line 1453
    c->type = 9;
  }
#line 1455
  return;
}
}
#line 1458 "channels.c"
void channel_input_oclose(int type , int plen , void *ctxt ) 
{ int id ;
  u_int tmp ;
  Channel *c ;
  Channel *tmp___0 ;
  int _p ;
  int _e ;

  {
#line 1461
  tmp = packet_get_int();
#line 1461
  id = (int )tmp;
#line 1462
  tmp___0 = channel_lookup(id);
#line 1462
  c = tmp___0;
#line 1463
  while (1) {
#line 1463
    _p = plen;
#line 1463
    _e = 4;
#line 1463
    if (_p != _e) {
#line 1463
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1463);
#line 1463
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 1463
    break;
  }
#line 1464
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1465
    packet_disconnect("Received oclose for nonexistent channel %d.", id);
  }
#line 1466
  (*chan_rcvd_oclose)(c);
#line 1467
  return;
}
}
#line 1469 "channels.c"
void channel_input_close_confirmation(int type , int plen , void *ctxt ) 
{ int id ;
  u_int tmp ;
  Channel *c ;
  Channel *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1472
  tmp = packet_get_int();
#line 1472
  id = (int )tmp;
#line 1473
  tmp___0 = channel_lookup(id);
#line 1473
  c = tmp___0;
#line 1475
  while (1) {
#line 1475
    tmp___1 = packet_remaining();
#line 1475
    _len = tmp___1;
#line 1475
    if (_len > 0) {
#line 1475
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1475);
#line 1475
      packet_disconnect("Packet integrity error.");
    }
#line 1475
    break;
  }
#line 1476
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1477
    packet_disconnect("Received close confirmation for out-of-range channel %d.",
                      id);
  }
#line 1479
  if (c->type != 5) {
#line 1480
    packet_disconnect("Received close confirmation for non-closed channel %d (type %d).",
                      id, c->type);
  }
#line 1482
  channel_free(c->self);
#line 1483
  return;
}
}
#line 1485 "channels.c"
void channel_input_open_confirmation(int type , int plen , void *ctxt ) 
{ int id ;
  int remote_id ;
  Channel *c ;
  int _p ;
  int _e ;
  u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 1491
  if (! compat20) {
#line 1492
    while (1) {
#line 1492
      _p = plen;
#line 1492
      _e = 8;
#line 1492
      if (_p != _e) {
#line 1492
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1492);
#line 1492
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1492
      break;
    }
  }
#line 1494
  tmp = packet_get_int();
#line 1494
  id = (int )tmp;
#line 1495
  c = channel_lookup(id);
#line 1497
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1498
    packet_disconnect("Received open confirmation for non-opening channel %d.", id);
  } else {
#line 1497
    if (c->type != 3) {
#line 1498
      packet_disconnect("Received open confirmation for non-opening channel %d.",
                        id);
    }
  }
#line 1500
  tmp___0 = packet_get_int();
#line 1500
  remote_id = (int )tmp___0;
#line 1502
  c->remote_id = remote_id;
#line 1503
  c->type = 4;
#line 1505
  if (compat20) {
#line 1506
    tmp___1 = packet_get_int();
#line 1506
    c->remote_window = (int )tmp___1;
#line 1507
    tmp___2 = packet_get_int();
#line 1507
    c->remote_maxpacket = (int )tmp___2;
#line 1508
    while (1) {
#line 1508
      tmp___3 = packet_remaining();
#line 1508
      _len = tmp___3;
#line 1508
      if (_len > 0) {
#line 1508
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            1508);
#line 1508
        packet_disconnect("Packet integrity error.");
      }
#line 1508
      break;
    }
#line 1509
    if ((unsigned int )c->cb_fn != (unsigned int )((void *)0)) {
#line 1509
      if (c->cb_event == type) {
#line 1510
        debug2("callback start");
#line 1511
        (*(c->cb_fn))(c->self, c->cb_arg);
#line 1512
        debug2("callback done");
      }
    }
#line 1514
    debug("channel %d: open confirm rwindow %d rmax %d", c->self, c->remote_window,
          c->remote_maxpacket);
  }
#line 1517
  return;
}
}
#line 1519 "channels.c"
void channel_input_open_failure(int type , int plen , void *ctxt ) 
{ int id ;
  int reason ;
  char *msg ;
  char *lang ;
  Channel *c ;
  int _p ;
  int _e ;
  u_int tmp ;
  u_int tmp___0 ;
  int tmp___1 ;
  int _len ;
  int tmp___2 ;
  char const   *tmp___3 ;

  {
#line 1523
  msg = (char *)((void *)0);
#line 1523
  lang = (char *)((void *)0);
#line 1526
  if (! compat20) {
#line 1527
    while (1) {
#line 1527
      _p = plen;
#line 1527
      _e = 4;
#line 1527
      if (_p != _e) {
#line 1527
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1527);
#line 1527
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1527
      break;
    }
  }
#line 1529
  tmp = packet_get_int();
#line 1529
  id = (int )tmp;
#line 1530
  c = channel_lookup(id);
#line 1532
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1533
    packet_disconnect("Received open failure for non-opening channel %d.", id);
  } else {
#line 1532
    if (c->type != 3) {
#line 1533
      packet_disconnect("Received open failure for non-opening channel %d.", id);
    }
  }
#line 1535
  if (compat20) {
#line 1536
    tmp___0 = packet_get_int();
#line 1536
    reason = (int )tmp___0;
#line 1537
    tmp___1 = packet_remaining();
#line 1537
    if (tmp___1 > 0) {
#line 1538
      msg = packet_get_string((u_int *)((void *)0));
#line 1539
      lang = packet_get_string((u_int *)((void *)0));
    }
#line 1541
    while (1) {
#line 1541
      tmp___2 = packet_remaining();
#line 1541
      _len = tmp___2;
#line 1541
      if (_len > 0) {
#line 1541
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            1541);
#line 1541
        packet_disconnect("Packet integrity error.");
      }
#line 1541
      break;
    }
#line 1542
    if (msg) {
#line 1542
      tmp___3 = (char const   *)msg;
    } else {
#line 1542
      tmp___3 = "<no additional info>";
    }
#line 1542
    log("channel_open_failure: %d: reason %d %s", id, reason, tmp___3);
#line 1544
    if ((unsigned int )msg != (unsigned int )((void *)0)) {
#line 1545
      xfree((void *)msg);
    }
#line 1546
    if ((unsigned int )lang != (unsigned int )((void *)0)) {
#line 1547
      xfree((void *)lang);
    }
  }
#line 1550
  channel_free(id);
#line 1551
  return;
}
}
#line 1553 "channels.c"
void channel_input_channel_request(int type , int plen , void *ctxt ) 
{ int id ;
  Channel *c ;
  u_int tmp ;
  char *service ;
  char *tmp___0 ;

  {
#line 1559
  tmp = packet_get_int();
#line 1559
  id = (int )tmp;
#line 1560
  c = channel_lookup(id);
#line 1562
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1564
    packet_disconnect("Received request for non-open channel %d.", id);
  } else {
#line 1562
    if (c->type != 4) {
#line 1562
      if (c->type != 10) {
#line 1564
        packet_disconnect("Received request for non-open channel %d.", id);
      }
    }
  }
#line 1566
  if ((unsigned int )c->cb_fn != (unsigned int )((void *)0)) {
#line 1566
    if (c->cb_event == type) {
#line 1567
      debug2("callback start");
#line 1568
      (*(c->cb_fn))(c->self, c->cb_arg);
#line 1569
      debug2("callback done");
    } else {
#line 1571
      tmp___0 = packet_get_string((u_int *)((void *)0));
#line 1571
      service = tmp___0;
#line 1572
      debug("channel %d: rcvd request for %s", c->self, service);
#line 1573
      debug("cb_fn %p cb_event %d", c->cb_fn, c->cb_event);
#line 1574
      xfree((void *)service);
    }
  } else {
#line 1571
    tmp___0 = packet_get_string((u_int *)((void *)0));
#line 1571
    service = tmp___0;
#line 1572
    debug("channel %d: rcvd request for %s", c->self, service);
#line 1573
    debug("cb_fn %p cb_event %d", c->cb_fn, c->cb_event);
#line 1574
    xfree((void *)service);
  }
#line 1576
  return;
}
}
#line 1578 "channels.c"
void channel_input_window_adjust(int type , int plen , void *ctxt ) 
{ Channel *c ;
  int id ;
  int adjust ;
  u_int tmp ;
  u_int tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1584
  if (! compat20) {
#line 1585
    return;
  }
#line 1588
  tmp = packet_get_int();
#line 1588
  id = (int )tmp;
#line 1589
  c = channel_lookup(id);
#line 1591
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1592
    log("Received window adjust for non-open channel %d.", id);
#line 1594
    return;
  } else {
#line 1591
    if (c->type != 4) {
#line 1592
      log("Received window adjust for non-open channel %d.", id);
#line 1594
      return;
    }
  }
#line 1596
  tmp___0 = packet_get_int();
#line 1596
  adjust = (int )tmp___0;
#line 1597
  while (1) {
#line 1597
    tmp___1 = packet_remaining();
#line 1597
    _len = tmp___1;
#line 1597
    if (_len > 0) {
#line 1597
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1597);
#line 1597
      packet_disconnect("Packet integrity error.");
    }
#line 1597
    break;
  }
#line 1598
  debug2("channel %d: rcvd adjust %d", id, adjust);
#line 1599
  c->remote_window += adjust;
#line 1600
  return;
}
}
#line 1607 "channels.c"
void channel_stop_listening(void) 
{ int i ;

  {
#line 1611
  i = 0;
#line 1611
  while (i < channels_alloc) {
#line 1612
    switch ((channels + i)->type) {
    case 6: 
#line 1614
    close((channels + i)->sock);
#line 1615
    unlink((char const   *)((channels + i)->path));
#line 1616
    channel_free(i);
#line 1617
    break;
    case 2: 
    case 11: 
    case 1: 
#line 1621
    close((channels + i)->sock);
#line 1622
    channel_free(i);
#line 1623
    break;
    default: ;
#line 1625
    break;
    }
#line 1611
    i ++;
  }
#line 1628
  return;
}
}
#line 1635 "channels.c"
void channel_close_all(void) 
{ int i ;

  {
#line 1639
  i = 0;
#line 1639
  while (i < channels_alloc) {
#line 1640
    if ((channels + i)->type != 0) {
#line 1641
      channel_close_fds(channels + i);
    }
#line 1639
    i ++;
  }
#line 1642
  return;
}
}
#line 1646 "channels.c"
int channel_still_open(void) 
{ u_int i ;

  {
#line 1650
  i = 0U;
#line 1650
  while (i < (u_int )channels_alloc) {
#line 1651
    switch ((channels + i)->type) {
    case 0: 
    case 1: 
    case 2: 
    case 11: 
    case 5: 
    case 6: 
    case 13: 
    case 12: 
    goto __Cont;
    case 10: 
#line 1662
    if (! compat20) {
#line 1663
      fatal("cannot happen: SSH_CHANNEL_LARVAL");
    }
    goto __Cont;
    case 3: 
    case 4: 
    case 7: 
#line 1668
    return (1);
    case 8: 
    case 9: 
#line 1671
    if (! compat13) {
#line 1672
      fatal("cannot happen: OUT_DRAIN");
    }
#line 1673
    return (1);
    default: 
#line 1675
    fatal("channel_still_open: bad channel type %d", (channels + i)->type);
    }
    __Cont: /* CIL Label */ 
#line 1650
    i ++;
  }
#line 1678
  return (0);
}
}
#line 1683 "channels.c"
int channel_find_open(void) 
{ u_int i ;

  {
#line 1687
  i = 0U;
#line 1687
  while (i < (u_int )channels_alloc) {
#line 1688
    switch ((channels + i)->type) {
    case 5: 
    case 13: 
    case 0: 
    case 1: 
    case 2: 
    case 11: 
    case 3: 
    goto __Cont;
    case 10: 
    case 6: 
    case 12: 
    case 4: 
    case 7: 
#line 1702
    return ((int )i);
    case 8: 
    case 9: 
#line 1705
    if (! compat13) {
#line 1706
      fatal("cannot happen: OUT_DRAIN");
    }
#line 1707
    return ((int )i);
    default: 
#line 1709
    fatal("channel_find_open: bad channel type %d", (channels + i)->type);
    }
    __Cont: /* CIL Label */ 
#line 1687
    i ++;
  }
#line 1712
  return (-1);
}
}
#line 1722 "channels.c"
char *channel_open_message(void) 
{ Buffer buffer ;
  int i ;
  char buf___2[512] ;
  char *cp ;
  size_t tmp ;
  Channel *c ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;

  {
#line 1729
  buffer_init(& buffer);
#line 1730
  snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"The following connections are open:\r\n");
#line 1731
  tmp = strlen((char const   *)(buf___2));
#line 1731
  buffer_append(& buffer, (char const   *)(buf___2), tmp);
#line 1732
  i = 0;
#line 1732
  while (i < channels_alloc) {
#line 1733
    c = channels + i;
#line 1734
    switch (c->type) {
    case 0: 
    case 1: 
    case 2: 
    case 11: 
    case 5: 
    case 6: 
    goto __Cont;
    case 10: 
    case 3: 
    case 12: 
    case 13: 
    case 4: 
    case 7: 
    case 8: 
    case 9: 
#line 1750
    tmp___0 = buffer_len(& c->output);
#line 1750
    tmp___1 = buffer_len(& c->input);
#line 1750
    snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"  #%d %.300s (t%d r%d i%d/%d o%d/%d fd %d/%d)\r\n",
             c->self, c->remote_name, c->type, c->remote_id, c->istate, tmp___1, c->ostate,
             tmp___0, c->rfd, c->wfd);
#line 1756
    tmp___2 = strlen((char const   *)(buf___2));
#line 1756
    buffer_append(& buffer, (char const   *)(buf___2), tmp___2);
    goto __Cont;
    default: 
#line 1759
    fatal("channel_open_message: bad channel type %d", c->type);
    }
    __Cont: /* CIL Label */ 
#line 1732
    i ++;
  }
#line 1763
  buffer_append(& buffer, "\000", 1U);
#line 1764
  tmp___3 = buffer_ptr(& buffer);
#line 1764
  cp = xstrdup((char const   *)tmp___3);
#line 1765
  buffer_free(& buffer);
#line 1766
  return (cp);
}
}
#line 1773 "channels.c"
int channel_request_local_forwarding(u_short listen_port , char const   *host_to_connect ,
                                     u_short port_to_connect , int gateway_ports ) 
{ int tmp ;

  {
#line 1777
  tmp = channel_request_forwarding((char const   *)((void *)0), listen_port, host_to_connect,
                                   port_to_connect, gateway_ports, 0);
#line 1777
  return (tmp);
}
}
#line 1787 "channels.c"
int channel_request_forwarding(char const   *listen_address , u_short listen_port ,
                               char const   *host_to_connect , u_short port_to_connect ,
                               int gateway_ports , int remote_fwd ) 
{ int success ;
  int ch ;
  int sock ;
  int on ;
  int ctype ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char ntop[1025] ;
  char strport[32] ;
  char const   *host ;
  struct linger linger ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;

  {
#line 1793
  on = 1;
#line 1799
  success = 0;
#line 1801
  if (remote_fwd) {
#line 1802
    host = listen_address;
#line 1803
    ctype = 11;
  } else {
#line 1805
    host = host_to_connect;
#line 1806
    ctype = 2;
  }
#line 1809
  tmp = strlen(host);
#line 1809
  if (tmp > sizeof((channels + 0)->path) - 1U) {
#line 1810
    error("Forward host name too long.");
#line 1811
    return (success);
  }
#line 1819
  memset((void *)(& hints), 0, sizeof(hints));
#line 1820
  hints.ai_family = IPv4or6;
#line 1821
  if (gateway_ports) {
#line 1821
    hints.ai_flags = 1;
  } else {
#line 1821
    hints.ai_flags = 0;
  }
#line 1822
  hints.ai_socktype = 1;
#line 1823
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           listen_port);
#line 1824
  tmp___0 = getaddrinfo((char const   * __restrict  )((void *)0), (char const   * __restrict  )(strport),
                        (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 1824
  if (tmp___0 != 0) {
#line 1825
    packet_disconnect("getaddrinfo: fatal error");
  }
#line 1827
  ai = aitop;
#line 1827
  while (ai) {
#line 1828
    if (ai->ai_family != 2) {
#line 1828
      if (ai->ai_family != 10) {
        goto __Cont;
      }
    }
#line 1830
    tmp___1 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                          (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )(strport),
                          sizeof(strport), 3U);
#line 1830
    if (tmp___1 != 0) {
#line 1832
      error("channel_request_forwarding: getnameinfo failed");
      goto __Cont;
    }
#line 1836
    sock = socket(ai->ai_family, 1, 0);
#line 1837
    if (sock < 0) {
#line 1839
      tmp___2 = __errno_location();
#line 1839
      tmp___3 = strerror(*tmp___2);
#line 1839
      verbose("socket: %.100s", tmp___3);
      goto __Cont;
    }
#line 1846
    setsockopt(sock, 1, 2, (void const   *)((void *)(& on)), sizeof(on));
#line 1847
    linger.l_onoff = 1;
#line 1848
    linger.l_linger = 5;
#line 1849
    setsockopt(sock, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 1850
    debug("Local forwarding listening on %s port %s.", ntop, strport);
#line 1853
    tmp___8 = bind(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 1853
    if (tmp___8 < 0) {
#line 1855
      if (! ai->ai_next) {
#line 1856
        tmp___4 = __errno_location();
#line 1856
        tmp___5 = strerror(*tmp___4);
#line 1856
        error("bind: %.100s", tmp___5);
      } else {
#line 1858
        tmp___6 = __errno_location();
#line 1858
        tmp___7 = strerror(*tmp___6);
#line 1858
        verbose("bind: %.100s", tmp___7);
      }
#line 1860
      close(sock);
      goto __Cont;
    }
#line 1864
    tmp___11 = listen(sock, 5);
#line 1864
    if (tmp___11 < 0) {
#line 1865
      tmp___9 = __errno_location();
#line 1865
      tmp___10 = strerror(*tmp___9);
#line 1865
      error("listen: %.100s", tmp___10);
#line 1866
      close(sock);
      goto __Cont;
    }
#line 1870
    tmp___12 = xstrdup("port listener");
#line 1870
    ch = channel_new((char *)"port listener", ctype, sock, sock, -1, 32768, 16384,
                     0, tmp___12, 1);
#line 1873
    strlcpy((channels + ch)->path, host, sizeof((channels + ch)->path));
#line 1874
    (channels + ch)->host_port = (int )port_to_connect;
#line 1875
    (channels + ch)->listening_port = (int )listen_port;
#line 1876
    success = 1;
    __Cont: /* CIL Label */ 
#line 1827
    ai = ai->ai_next;
  }
#line 1878
  if (success == 0) {
#line 1879
    error("channel_request_forwarding: cannot listen to port: %d", listen_port);
  }
#line 1881
  freeaddrinfo(aitop);
#line 1882
  return (success);
}
}
#line 1890 "channels.c"
void channel_request_remote_forwarding(u_short listen_port , char const   *host_to_connect ,
                                       u_short port_to_connect ) 
{ int payload_len ;
  int type ;
  int success ;
  char const   *address_to_bind ;

  {
#line 1894
  success = 0;
#line 1897
  if (num_permitted_opens >= 100) {
#line 1898
    fatal("channel_request_remote_forwarding: too many forwards");
  }
#line 1901
  if (compat20) {
#line 1902
    address_to_bind = "0.0.0.0";
#line 1903
    packet_start(80);
#line 1904
    packet_put_cstring("tcpip-forward");
#line 1905
    packet_put_char(0);
#line 1906
    packet_put_cstring(address_to_bind);
#line 1907
    packet_put_int((unsigned int )listen_port);
#line 1908
    packet_send();
#line 1909
    packet_write_wait();
#line 1911
    success = 1;
  } else {
#line 1913
    packet_start(28);
#line 1914
    packet_put_int((unsigned int )listen_port);
#line 1915
    packet_put_cstring(host_to_connect);
#line 1916
    packet_put_int((unsigned int )port_to_connect);
#line 1917
    packet_send();
#line 1918
    packet_write_wait();
#line 1921
    type = packet_read(& payload_len);
#line 1922
    switch (type) {
    case 14: 
#line 1924
    success = 1;
#line 1925
    break;
    case 15: 
#line 1927
    log("Warning: Server denied remote port forwarding.");
#line 1928
    break;
    default: 
#line 1931
    packet_disconnect("Protocol error for port forward request:received packet type %d.",
                      type);
    }
  }
#line 1935
  if (success) {
#line 1936
    permitted_opens[num_permitted_opens].host_to_connect = xstrdup(host_to_connect);
#line 1937
    permitted_opens[num_permitted_opens].port_to_connect = port_to_connect;
#line 1938
    permitted_opens[num_permitted_opens].listen_port = listen_port;
#line 1939
    num_permitted_opens ++;
  }
#line 1941
  return;
}
}
#line 1949 "channels.c"
void channel_input_port_forward_request(int is_root , int gateway_ports ) 
{ u_short port ;
  u_short host_port ;
  char *hostname ;
  u_int tmp ;
  u_int tmp___0 ;

  {
#line 1956
  tmp = packet_get_int();
#line 1956
  port = (unsigned short )tmp;
#line 1957
  hostname = packet_get_string((u_int *)((void *)0));
#line 1958
  tmp___0 = packet_get_int();
#line 1958
  host_port = (unsigned short )tmp___0;
#line 1965
  if ((int )port < 1024) {
#line 1965
    if (! is_root) {
#line 1966
      packet_disconnect("Requested forwarding of port %d but user is not root.", port);
    }
  }
#line 1970
  channel_request_local_forwarding(port, (char const   *)hostname, host_port, gateway_ports);
#line 1973
  xfree((void *)hostname);
#line 1974
  return;
}
}
#line 1981 "channels.c"
void channel_permit_all_opens(void) 
{ 

  {
#line 1984
  if (num_permitted_opens == 0) {
#line 1985
    all_opens_permitted = 1;
  }
#line 1986
  return;
}
}
#line 1988 "channels.c"
void channel_add_permitted_opens(char *host , int port ) 
{ 

  {
#line 1991
  if (num_permitted_opens >= 100) {
#line 1992
    fatal("channel_request_remote_forwarding: too many forwards");
  }
#line 1993
  debug("allow port forwarding to host %s port %d", host, port);
#line 1995
  permitted_opens[num_permitted_opens].host_to_connect = xstrdup((char const   *)host);
#line 1996
  permitted_opens[num_permitted_opens].port_to_connect = (unsigned short )port;
#line 1997
  num_permitted_opens ++;
#line 1999
  all_opens_permitted = 0;
#line 2000
  return;
}
}
#line 2002 "channels.c"
void channel_clear_permitted_opens(void) 
{ int i ;

  {
#line 2007
  i = 0;
#line 2007
  while (i < num_permitted_opens) {
#line 2008
    xfree((void *)permitted_opens[i].host_to_connect);
#line 2007
    i ++;
  }
#line 2009
  num_permitted_opens = 0;
#line 2011
  return;
}
}
#line 2015 "channels.c"
int connect_to(char const   *host , u_short port ) 
{ struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char ntop[1025] ;
  char strport[32] ;
  int gaierr ;
  int sock ;
  char const   *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;

  {
#line 2021
  sock = -1;
#line 2023
  memset((void *)(& hints), 0, sizeof(hints));
#line 2024
  hints.ai_family = IPv4or6;
#line 2025
  hints.ai_socktype = 1;
#line 2026
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           port);
#line 2027
  gaierr = getaddrinfo((char const   * __restrict  )host, (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 2027
  if (gaierr != 0) {
#line 2028
    tmp = gai_strerror(gaierr);
#line 2028
    error("connect_to %.100s: unknown host (%s)", host, tmp);
#line 2030
    return (-1);
  }
#line 2032
  ai = aitop;
#line 2032
  while (ai) {
#line 2033
    if (ai->ai_family != 2) {
#line 2033
      if (ai->ai_family != 10) {
        goto __Cont;
      }
    }
#line 2035
    tmp___0 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                          (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )(strport),
                          sizeof(strport), 3U);
#line 2035
    if (tmp___0 != 0) {
#line 2037
      error("connect_to: getnameinfo failed");
      goto __Cont;
    }
#line 2040
    sock = socket(ai->ai_family, 1, 0);
#line 2041
    if (sock < 0) {
#line 2042
      tmp___1 = __errno_location();
#line 2042
      tmp___2 = strerror(*tmp___1);
#line 2042
      error("socket: %.100s", tmp___2);
      goto __Cont;
    }
#line 2045
    tmp___5 = fcntl(sock, 4, 2048);
#line 2045
    if (tmp___5 < 0) {
#line 2046
      tmp___3 = __errno_location();
#line 2046
      tmp___4 = strerror(*tmp___3);
#line 2046
      fatal("connect_to: F_SETFL: %s", tmp___4);
    }
#line 2047
    tmp___8 = connect(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 2047
    if (tmp___8 < 0) {
#line 2047
      tmp___9 = __errno_location();
#line 2047
      if (*tmp___9 != 115) {
#line 2049
        tmp___6 = __errno_location();
#line 2049
        tmp___7 = strerror(*tmp___6);
#line 2049
        error("connect_to %.100s port %s: %.100s", ntop, strport, tmp___7);
#line 2051
        close(sock);
        goto __Cont;
      }
    }
#line 2054
    break;
    __Cont: /* CIL Label */ 
#line 2032
    ai = ai->ai_next;
  }
#line 2057
  freeaddrinfo(aitop);
#line 2058
  if (! ai) {
#line 2059
    error("connect_to %.100s port %d: failed.", host, port);
#line 2060
    return (-1);
  }
#line 2063
  return (sock);
}
}
#line 2066 "channels.c"
int channel_connect_by_listen_adress(u_short listen_port ) 
{ int i ;
  int tmp ;

  {
#line 2071
  i = 0;
#line 2071
  while (i < num_permitted_opens) {
#line 2072
    if ((int )permitted_opens[i].listen_port == (int )listen_port) {
#line 2073
      tmp = connect_to((char const   *)permitted_opens[i].host_to_connect, permitted_opens[i].port_to_connect);
#line 2073
      return (tmp);
    }
#line 2071
    i ++;
  }
#line 2076
  error("WARNING: Server requests forwarding for unknown listen_port %d", listen_port);
#line 2078
  return (-1);
}
}
#line 2082 "channels.c"
int channel_connect_to(char const   *host , u_short port ) 
{ int i ;
  int permit ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 2087
  permit = all_opens_permitted;
#line 2088
  if (! permit) {
#line 2089
    i = 0;
#line 2089
    while (i < num_permitted_opens) {
#line 2091
      if ((int )permitted_opens[i].port_to_connect == (int )port) {
#line 2091
        if (0) {
#line 2091
          __s1_len = strlen((char const   *)permitted_opens[i].host_to_connect);
#line 2091
          __s2_len = strlen(host);
#line 2091
          if (! ((unsigned int )((void const   *)(permitted_opens[i].host_to_connect + 1)) - (unsigned int )((void const   *)permitted_opens[i].host_to_connect) == 1U)) {
            goto _L___0;
          } else {
#line 2091
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 2091
              if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
#line 2091
                tmp___8 = 1;
              } else {
#line 2091
                if (__s2_len >= 4U) {
#line 2091
                  tmp___8 = 1;
                } else {
#line 2091
                  tmp___8 = 0;
                }
              }
            } else {
#line 2091
              tmp___8 = 0;
            }
          }
#line 2091
          if (tmp___8) {
#line 2091
            tmp___4 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                       host);
          } else {
#line 2091
            tmp___7 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                       host);
#line 2091
            tmp___4 = tmp___7;
          }
        } else {
#line 2091
          tmp___7 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                     host);
#line 2091
          tmp___4 = tmp___7;
        }
#line 2091
        if (tmp___4 == 0) {
#line 2092
          permit = 1;
        }
      }
#line 2089
      i ++;
    }
  }
#line 2095
  if (! permit) {
#line 2096
    log("Received request to connect to host %.100s port %d, but the request was denied.",
        host, port);
#line 2098
    return (-1);
  }
#line 2100
  tmp___9 = connect_to(host, port);
#line 2100
  return (tmp___9);
}
}
#line 2109 "channels.c"
void channel_input_port_open(int type , int plen , void *ctxt ) 
{ u_short host_port ;
  char *host ;
  char *originator_string ;
  int remote_channel ;
  int sock ;
  int newch ;
  u_int tmp ;
  u_int tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 2114
  sock = -1;
#line 2116
  tmp = packet_get_int();
#line 2116
  remote_channel = (int )tmp;
#line 2117
  host = packet_get_string((u_int *)((void *)0));
#line 2118
  tmp___0 = packet_get_int();
#line 2118
  host_port = (unsigned short )tmp___0;
#line 2120
  if (have_hostname_in_open) {
#line 2121
    originator_string = packet_get_string((u_int *)((void *)0));
  } else {
#line 2123
    originator_string = xstrdup("unknown (remote did not supply name)");
  }
#line 2125
  while (1) {
#line 2125
    tmp___1 = packet_remaining();
#line 2125
    _len = tmp___1;
#line 2125
    if (_len > 0) {
#line 2125
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          2125);
#line 2125
      packet_disconnect("Packet integrity error.");
    }
#line 2125
    break;
  }
#line 2126
  sock = channel_connect_to((char const   *)host, host_port);
#line 2127
  if (sock != -1) {
#line 2128
    newch = channel_allocate(12, sock, originator_string);
#line 2130
    (channels + newch)->remote_id = remote_channel;
#line 2133
    packet_start(21);
#line 2134
    packet_put_int((unsigned int )remote_channel);
#line 2135
    packet_put_int((unsigned int )newch);
#line 2136
    packet_send();
  } else {
#line 2138
    packet_start(22);
#line 2139
    packet_put_int((unsigned int )remote_channel);
#line 2140
    packet_send();
  }
#line 2142
  xfree((void *)host);
#line 2143
  return;
}
}
#line 2153 "channels.c"
char *x11_create_display_inet(int screen_number , int x11_display_offset ) 
{ int display_number ;
  int sock ;
  u_short port ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  int n___0 ;
  int num_socks ;
  int socks[10] ;
  char display[512] ;
  char hostname[64] ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;

  {
#line 2160
  num_socks = 0;
#line 2164
  display_number = x11_display_offset;
#line 2164
  while (display_number < 1000) {
#line 2167
    port = (unsigned short )(6000 + display_number);
#line 2168
    memset((void *)(& hints), 0, sizeof(hints));
#line 2169
    hints.ai_family = IPv4or6;
#line 2170
    hints.ai_flags = 1;
#line 2171
    hints.ai_socktype = 1;
#line 2172
    snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
             port);
#line 2173
    gaierr = getaddrinfo((char const   * __restrict  )((void *)0), (char const   * __restrict  )(strport),
                         (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 2173
    if (gaierr != 0) {
#line 2174
      tmp = gai_strerror(gaierr);
#line 2174
      error("getaddrinfo: %.100s", tmp);
#line 2175
      return ((char *)((void *)0));
    }
#line 2177
    ai = aitop;
#line 2177
    while (ai) {
#line 2178
      if (ai->ai_family != 2) {
#line 2178
        if (ai->ai_family != 10) {
          goto __Cont;
        }
      }
#line 2180
      sock = socket(ai->ai_family, 1, 0);
#line 2181
      if (sock < 0) {
#line 2182
        tmp___2 = __errno_location();
#line 2182
        if (*tmp___2 != 22) {
#line 2182
          tmp___3 = __errno_location();
#line 2182
          if (*tmp___3 != 97) {
#line 2183
            tmp___0 = __errno_location();
#line 2183
            tmp___1 = strerror(*tmp___0);
#line 2183
            error("socket: %.100s", tmp___1);
#line 2184
            return ((char *)((void *)0));
          } else {
#line 2186
            debug("x11_create_display_inet: Socket family %d not supported", ai->ai_family);
            goto __Cont;
          }
        } else {
#line 2186
          debug("x11_create_display_inet: Socket family %d not supported", ai->ai_family);
          goto __Cont;
        }
      }
#line 2191
      tmp___6 = bind(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 2191
      if (tmp___6 < 0) {
#line 2192
        tmp___4 = __errno_location();
#line 2192
        tmp___5 = strerror(*tmp___4);
#line 2192
        debug("bind port %d: %.100s", port, tmp___5);
#line 2193
        shutdown(sock, 2);
#line 2194
        close(sock);
#line 2196
        if (ai->ai_next) {
          goto __Cont;
        }
#line 2199
        n___0 = 0;
#line 2199
        while (n___0 < num_socks) {
#line 2200
          shutdown(socks[n___0], 2);
#line 2201
          close(socks[n___0]);
#line 2199
          n___0 ++;
        }
#line 2203
        num_socks = 0;
#line 2204
        break;
      }
#line 2206
      tmp___7 = num_socks;
#line 2206
      num_socks ++;
#line 2206
      socks[tmp___7] = sock;
#line 2211
      break;
      __Cont: /* CIL Label */ 
#line 2177
      ai = ai->ai_next;
    }
#line 2214
    freeaddrinfo(aitop);
#line 2215
    if (num_socks > 0) {
#line 2216
      break;
    }
#line 2164
    display_number ++;
  }
#line 2218
  if (display_number >= 1000) {
#line 2219
    error("Failed to allocate internet-domain X11 display socket.");
#line 2220
    return ((char *)((void *)0));
  }
#line 2223
  n___0 = 0;
#line 2223
  while (n___0 < num_socks) {
#line 2224
    sock = socks[n___0];
#line 2225
    tmp___10 = listen(sock, 5);
#line 2225
    if (tmp___10 < 0) {
#line 2226
      tmp___8 = __errno_location();
#line 2226
      tmp___9 = strerror(*tmp___8);
#line 2226
      error("listen: %.100s", tmp___9);
#line 2227
      shutdown(sock, 2);
#line 2228
      close(sock);
#line 2229
      return ((char *)((void *)0));
    }
#line 2223
    n___0 ++;
  }
#line 2234
  tmp___13 = gethostname(hostname, sizeof(hostname));
#line 2234
  if (tmp___13 < 0) {
#line 2235
    tmp___11 = __errno_location();
#line 2235
    tmp___12 = strerror(*tmp___11);
#line 2235
    fatal("gethostname: %.100s", tmp___12);
  }
#line 2272
  snprintf((char * __restrict  )(display), sizeof(display), (char const   * __restrict  )"%.400s:%d.%d",
           hostname, display_number, screen_number);
#line 2277
  n___0 = 0;
#line 2277
  while (n___0 < num_socks) {
#line 2278
    sock = socks[n___0];
#line 2279
    tmp___14 = xstrdup("X11 inet listener");
#line 2279
    channel_new((char *)"x11 listener", 1, sock, sock, -1, 4096, 2048, 0, tmp___14,
                1);
#line 2277
    n___0 ++;
  }
#line 2286
  tmp___15 = xstrdup((char const   *)(display));
#line 2286
  return (tmp___15);
}
}
#line 2297
static int connect_local_xsocket(u_int dnr ) ;
#line 2297 "channels.c"
static char const   * const  x_sockets[4]  = {      (char const   * const  )"/tmp/.X11-unix/X%u",      (char const   * const  )"/var/X/.X11-unix/X%u",      (char const   * const  )"/usr/spool/sockets/X11/%u",      (char const   * const  )((void *)0)};
#line 2293 "channels.c"
static int connect_local_xsocket(u_int dnr ) 
{ int sock ;
  struct sockaddr_un addr ;
  char const   * const  *path ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 2307
  path = x_sockets;
#line 2307
  while (*path) {
#line 2308
    sock = socket(1, 1, 0);
#line 2309
    if (sock < 0) {
#line 2310
      tmp = __errno_location();
#line 2310
      tmp___0 = strerror(*tmp);
#line 2310
      error("socket: %.100s", tmp___0);
    }
#line 2311
    memset((void *)(& addr), 0, sizeof(addr));
#line 2312
    addr.sun_family = (unsigned short)1;
#line 2313
    snprintf((char * __restrict  )(addr.sun_path), sizeof(addr.sun_path), (char const   * __restrict  )*path,
             dnr);
#line 2314
    tmp___1 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& addr)),
                      sizeof(addr));
#line 2314
    if (tmp___1 == 0) {
#line 2315
      return (sock);
    }
#line 2316
    close(sock);
#line 2307
    path ++;
  }
#line 2318
  tmp___2 = __errno_location();
#line 2318
  tmp___3 = strerror(*tmp___2);
#line 2318
  error("connect %.100s: %.100s", addr.sun_path, tmp___3);
#line 2319
  return (-1);
}
}
#line 2322 "channels.c"
int x11_connect_display(void) 
{ int display_number ;
  int sock ;
  char const   *display ;
  char buf___2[1024] ;
  char *cp ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___29 ;
  int tmp___30 ;
  char const   *tmp___31 ;
  int *tmp___32 ;
  char *tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  int *tmp___37 ;
  char *tmp___38 ;

  {
#line 2325
  sock = 0;
#line 2333
  tmp = getenv("DISPLAY");
#line 2333
  display = (char const   *)tmp;
#line 2334
  if (! display) {
#line 2335
    error("DISPLAY not set.");
#line 2336
    return (-1);
  }
#line 2347
  if (0) {
#line 2347
    if (0) {
#line 2347
      __s1_len___0 = strlen(display);
#line 2347
      __s2_len___0 = strlen("unix:");
#line 2347
      if (! ((unsigned int )((void const   *)(display + 1)) - (unsigned int )((void const   *)display) == 1U)) {
        goto _L___2;
      } else {
#line 2347
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 2347
          if (! ((unsigned int )((void const   *)("unix:" + 1)) - (unsigned int )((void const   *)"unix:") == 1U)) {
#line 2347
            tmp___25 = 1;
          } else {
#line 2347
            if (__s2_len___0 >= 4U) {
#line 2347
              tmp___25 = 1;
            } else {
#line 2347
              tmp___25 = 0;
            }
          }
        } else {
#line 2347
          tmp___25 = 0;
        }
      }
#line 2347
      if (tmp___25) {
#line 2347
        tmp___21 = __builtin_strcmp(display, "unix:");
      } else {
#line 2347
        tmp___24 = __builtin_strcmp(display, "unix:");
#line 2347
        tmp___21 = tmp___24;
      }
    } else {
#line 2347
      tmp___24 = __builtin_strcmp(display, "unix:");
#line 2347
      tmp___21 = tmp___24;
    }
#line 2347
    tmp___15 = tmp___21;
  } else {
#line 2347
    tmp___15 = strncmp(display, "unix:", 5U);
  }
#line 2347
  if (tmp___15 == 0) {
    goto _L___3;
  } else {
#line 2347
    if ((int const   )*(display + 0) == 58) {
      _L___3: /* CIL Label */ 
#line 2350
      tmp___0 = strrchr(display, ':');
#line 2350
      tmp___1 = sscanf((char const   * __restrict  )(tmp___0 + 1), (char const   * __restrict  )"%d",
                       & display_number);
#line 2350
      if (tmp___1 != 1) {
#line 2351
        error("Could not parse display number from DISPLAY: %.100s", display);
#line 2353
        return (-1);
      }
#line 2356
      sock = connect_local_xsocket((unsigned int )display_number);
#line 2357
      if (sock < 0) {
#line 2358
        return (-1);
      }
#line 2361
      return (sock);
    }
  }
#line 2367
  __builtin_strncpy(buf___2, display, sizeof(buf___2));
#line 2368
  buf___2[sizeof(buf___2) - 1U] = (char)0;
#line 2369
  tmp___29 = __builtin_strchr(buf___2, ':');
#line 2369
  cp = tmp___29;
#line 2370
  if (! cp) {
#line 2371
    error("Could not find \':\' in DISPLAY: %.100s", display);
#line 2372
    return (-1);
  }
#line 2374
  *cp = (char)0;
#line 2376
  tmp___30 = sscanf((char const   * __restrict  )(cp + 1), (char const   * __restrict  )"%d",
                    & display_number);
#line 2376
  if (tmp___30 != 1) {
#line 2377
    error("Could not parse display number from DISPLAY: %.100s", display);
#line 2379
    return (-1);
  }
#line 2383
  memset((void *)(& hints), 0, sizeof(hints));
#line 2384
  hints.ai_family = IPv4or6;
#line 2385
  hints.ai_socktype = 1;
#line 2386
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           6000 + display_number);
#line 2387
  gaierr = getaddrinfo((char const   * __restrict  )(buf___2), (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 2387
  if (gaierr != 0) {
#line 2388
    tmp___31 = gai_strerror(gaierr);
#line 2388
    error("%.100s: unknown host. (%s)", buf___2, tmp___31);
#line 2389
    return (-1);
  }
#line 2391
  ai = aitop;
#line 2391
  while (ai) {
#line 2393
    sock = socket(ai->ai_family, 1, 0);
#line 2394
    if (sock < 0) {
#line 2395
      tmp___32 = __errno_location();
#line 2395
      tmp___33 = strerror(*tmp___32);
#line 2395
      debug("socket: %.100s", tmp___33);
      goto __Cont;
    }
#line 2399
    tmp___36 = connect(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 2399
    if (tmp___36 < 0) {
#line 2400
      tmp___34 = __errno_location();
#line 2400
      tmp___35 = strerror(*tmp___34);
#line 2400
      debug("connect %.100s port %d: %.100s", buf___2, 6000 + display_number, tmp___35);
#line 2402
      close(sock);
      goto __Cont;
    }
#line 2406
    break;
    __Cont: /* CIL Label */ 
#line 2391
    ai = ai->ai_next;
  }
#line 2408
  freeaddrinfo(aitop);
#line 2409
  if (! ai) {
#line 2410
    tmp___37 = __errno_location();
#line 2410
    tmp___38 = strerror(*tmp___37);
#line 2410
    error("connect %.100s port %d: %.100s", buf___2, 6000 + display_number, tmp___38);
#line 2412
    return (-1);
  }
#line 2414
  return (sock);
}
}
#line 2423 "channels.c"
void x11_input_open(int type , int plen , void *ctxt ) 
{ int remote_channel ;
  int sock ;
  int newch ;
  char *remote_host ;
  u_int remote_len ;
  u_int tmp ;
  int _p ;
  int _e ;
  int tmp___0 ;

  {
#line 2426
  sock = 0;
#line 2431
  tmp = packet_get_int();
#line 2431
  remote_channel = (int )tmp;
#line 2434
  if (have_hostname_in_open) {
#line 2435
    remote_host = packet_get_string(& remote_len);
#line 2436
    remote_len += 4U;
  } else {
#line 2438
    remote_host = xstrdup("unknown (remote did not supply name)");
#line 2439
    remote_len = 0U;
  }
#line 2442
  debug("Received X11 open request.");
#line 2443
  while (1) {
#line 2443
    _p = plen;
#line 2443
    _e = (int )(4U + remote_len);
#line 2443
    if (_p != _e) {
#line 2443
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 2443);
#line 2443
      packet_disconnect("Packet integrity error. (%d)", 27);
    }
#line 2443
    break;
  }
#line 2446
  sock = x11_connect_display();
#line 2447
  if (sock == -1) {
#line 2449
    packet_start(22);
#line 2450
    packet_put_int((unsigned int )remote_channel);
#line 2451
    packet_send();
  } else {
#line 2454
    if ((unsigned int )x11_saved_proto == (unsigned int )((void *)0)) {
#line 2454
      tmp___0 = 4;
    } else {
#line 2454
      tmp___0 = 7;
    }
#line 2454
    newch = channel_allocate(tmp___0, sock, remote_host);
#line 2458
    (channels + newch)->remote_id = remote_channel;
#line 2461
    packet_start(21);
#line 2462
    packet_put_int((unsigned int )remote_channel);
#line 2463
    packet_put_int((unsigned int )newch);
#line 2464
    packet_send();
  }
#line 2466
  return;
}
}
#line 2469 "channels.c"
void deny_input_open(int type , int plen , void *ctxt ) 
{ int rchan ;
  u_int tmp ;

  {
#line 2472
  tmp = packet_get_int();
#line 2472
  rchan = (int )tmp;
#line 2473
  switch (type) {
  case 31: 
#line 2475
  error("Warning: ssh server tried agent forwarding.");
#line 2476
  break;
  case 27: 
#line 2478
  error("Warning: ssh server tried X11 forwarding.");
#line 2479
  break;
  default: 
#line 2481
  error("deny_input_open: type %d plen %d", type, plen);
#line 2482
  break;
  }
#line 2484
  error("Warning: this is probably a break in attempt by a malicious server.");
#line 2485
  packet_start(22);
#line 2486
  packet_put_int((unsigned int )rchan);
#line 2487
  packet_send();
#line 2488
  return;
}
}
#line 2495 "channels.c"
void x11_request_forwarding_with_spoofing(int client_session_id , char const   *proto ,
                                          char const   *data ) 
{ u_int data_len ;
  size_t tmp ;
  u_int i ;
  u_int value ;
  u_int len ;
  char *new_data ;
  int screen_number ;
  char const   *cp ;
  u_int32_t rand___0 ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;

  {
#line 2499
  tmp = strlen(data);
#line 2499
  data_len = tmp / 2U;
#line 2504
  rand___0 = (u_int32_t )0;
#line 2506
  tmp___0 = getenv("DISPLAY");
#line 2506
  cp = (char const   *)tmp___0;
#line 2507
  if (cp) {
#line 2508
    tmp___2 = __builtin_strchr((char *)cp, ':');
#line 2508
    cp = (char const   *)tmp___2;
  }
#line 2509
  if (cp) {
#line 2510
    tmp___4 = __builtin_strchr((char *)cp, '.');
#line 2510
    cp = (char const   *)tmp___4;
  }
#line 2511
  if (cp) {
#line 2512
    screen_number = atoi(cp + 1);
  } else {
#line 2514
    screen_number = 0;
  }
#line 2517
  x11_saved_proto = xstrdup(proto);
#line 2523
  tmp___5 = xmalloc(data_len);
#line 2523
  x11_saved_data = (char *)tmp___5;
#line 2524
  tmp___6 = xmalloc(data_len);
#line 2524
  x11_fake_data = (char *)tmp___6;
#line 2525
  i = 0U;
#line 2525
  while (i < data_len) {
#line 2526
    tmp___7 = sscanf((char const   * __restrict  )(data + 2U * i), (char const   * __restrict  )"%2x",
                     & value);
#line 2526
    if (tmp___7 != 1) {
#line 2527
      fatal("x11_request_forwarding: bad authentication data: %.100s", data);
    }
#line 2528
    if (i % 4U == 0U) {
#line 2529
      rand___0 = arc4random();
    }
#line 2530
    *(x11_saved_data + i) = (char )value;
#line 2531
    *(x11_fake_data + i) = (char )(rand___0 & 255U);
#line 2532
    rand___0 >>= 8;
#line 2525
    i ++;
  }
#line 2534
  x11_saved_data_len = data_len;
#line 2535
  x11_fake_data_len = data_len;
#line 2538
  len = 2U * data_len + 1U;
#line 2539
  tmp___8 = xmalloc(len);
#line 2539
  new_data = (char *)tmp___8;
#line 2540
  i = 0U;
#line 2540
  while (i < data_len) {
#line 2541
    snprintf((char * __restrict  )(new_data + 2U * i), len - 2U * i, (char const   * __restrict  )"%02x",
             (unsigned char )*(x11_fake_data + i));
#line 2540
    i ++;
  }
#line 2545
  if (compat20) {
#line 2546
    channel_request_start(client_session_id, (char *)"x11-req", 0);
#line 2547
    packet_put_char(0);
  } else {
#line 2549
    packet_start(34);
  }
#line 2551
  packet_put_cstring(proto);
#line 2552
  packet_put_cstring((char const   *)new_data);
#line 2553
  packet_put_int((unsigned int )screen_number);
#line 2554
  packet_send();
#line 2555
  packet_write_wait();
#line 2556
  xfree((void *)new_data);
#line 2557
  return;
}
}
#line 2561 "channels.c"
void auth_request_forwarding(void) 
{ 

  {
#line 2564
  packet_start(30);
#line 2565
  packet_send();
#line 2566
  packet_write_wait();
#line 2567
  return;
}
}
#line 2575 "channels.c"
char *auth_get_socket_name(void) 
{ 

  {
#line 2578
  return (channel_forwarded_auth_socket_name);
}
}
#line 2583 "channels.c"
void cleanup_socket(void) 
{ 

  {
#line 2586
  unlink((char const   *)channel_forwarded_auth_socket_name);
#line 2587
  rmdir((char const   *)channel_forwarded_auth_socket_dir);
#line 2588
  return;
}
}
#line 2595 "channels.c"
int auth_input_request_forwarding(struct passwd *pw ) 
{ int sock ;
  int newch ;
  struct sockaddr_un sunaddr ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  __pid_t tmp___5 ;
  int saved ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;

  {
#line 2601
  tmp = auth_get_socket_name();
#line 2601
  if ((unsigned int )tmp != (unsigned int )((void *)0)) {
#line 2602
    fatal("Protocol error: authentication forwarding requested twice.");
  }
#line 2605
  temporarily_use_uid(pw);
#line 2608
  tmp___0 = xmalloc(100U);
#line 2608
  channel_forwarded_auth_socket_name = (char *)tmp___0;
#line 2609
  tmp___1 = xmalloc(100U);
#line 2609
  channel_forwarded_auth_socket_dir = (char *)tmp___1;
#line 2610
  strlcpy(channel_forwarded_auth_socket_dir, "/tmp/ssh-XXXXXXXX", 100U);
#line 2613
  tmp___4 = mkdtemp(channel_forwarded_auth_socket_dir);
#line 2613
  if ((unsigned int )tmp___4 == (unsigned int )((void *)0)) {
#line 2614
    tmp___2 = __errno_location();
#line 2614
    tmp___3 = strerror(*tmp___2);
#line 2614
    packet_send_debug("Agent forwarding disabled: mkdtemp() failed: %.100s", tmp___3);
#line 2616
    restore_uid();
#line 2617
    xfree((void *)channel_forwarded_auth_socket_name);
#line 2618
    xfree((void *)channel_forwarded_auth_socket_dir);
#line 2619
    channel_forwarded_auth_socket_name = (char *)((void *)0);
#line 2620
    channel_forwarded_auth_socket_dir = (char *)((void *)0);
#line 2621
    return (0);
  }
#line 2623
  tmp___5 = getpid();
#line 2623
  snprintf((char * __restrict  )channel_forwarded_auth_socket_name, 100U, (char const   * __restrict  )"%s/agent.%d",
           channel_forwarded_auth_socket_dir, tmp___5);
#line 2626
  tmp___8 = atexit(& cleanup_socket);
#line 2626
  if (tmp___8 < 0) {
#line 2627
    tmp___6 = __errno_location();
#line 2627
    saved = *tmp___6;
#line 2628
    cleanup_socket();
#line 2629
    tmp___7 = strerror(saved);
#line 2629
    packet_disconnect("socket: %.100s", tmp___7);
  }
#line 2632
  sock = socket(1, 1, 0);
#line 2633
  if (sock < 0) {
#line 2634
    tmp___9 = __errno_location();
#line 2634
    tmp___10 = strerror(*tmp___9);
#line 2634
    packet_disconnect("socket: %.100s", tmp___10);
  }
#line 2637
  memset((void *)(& sunaddr), 0, sizeof(sunaddr));
#line 2638
  sunaddr.sun_family = (unsigned short)1;
#line 2639
  __builtin_strncpy(sunaddr.sun_path, (char const   *)channel_forwarded_auth_socket_name,
                    sizeof(sunaddr.sun_path));
#line 2642
  tmp___13 = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sunaddr)),
                  sizeof(sunaddr));
#line 2642
  if (tmp___13 < 0) {
#line 2643
    tmp___11 = __errno_location();
#line 2643
    tmp___12 = strerror(*tmp___11);
#line 2643
    packet_disconnect("bind: %.100s", tmp___12);
  }
#line 2646
  restore_uid();
#line 2649
  tmp___16 = listen(sock, 5);
#line 2649
  if (tmp___16 < 0) {
#line 2650
    tmp___14 = __errno_location();
#line 2650
    tmp___15 = strerror(*tmp___14);
#line 2650
    packet_disconnect("listen: %.100s", tmp___15);
  }
#line 2653
  tmp___17 = xstrdup("auth socket");
#line 2653
  newch = channel_new((char *)"auth socket", 6, sock, sock, -1, 4096, 2048, 0, tmp___17,
                      1);
#line 2658
  strlcpy((channels + newch)->path, (char const   *)channel_forwarded_auth_socket_name,
          sizeof((channels + newch)->path));
#line 2660
  return (1);
}
}
#line 2665 "channels.c"
void auth_input_open_request(int type , int plen , void *ctxt ) 
{ int remch ;
  int sock ;
  int newch ;
  char *dummyname ;
  int _p ;
  int _e ;
  u_int tmp ;

  {
#line 2671
  while (1) {
#line 2671
    _p = plen;
#line 2671
    _e = 4;
#line 2671
    if (_p != _e) {
#line 2671
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 2671);
#line 2671
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 2671
    break;
  }
#line 2674
  tmp = packet_get_int();
#line 2674
  remch = (int )tmp;
#line 2680
  sock = ssh_get_authentication_socket();
#line 2688
  if (sock < 0) {
#line 2689
    packet_start(22);
#line 2690
    packet_put_int((unsigned int )remch);
#line 2691
    packet_send();
#line 2692
    return;
  }
#line 2694
  debug("Forwarding authentication connection.");
#line 2701
  dummyname = xstrdup("authentication agent connection");
#line 2703
  newch = channel_allocate(4, sock, dummyname);
#line 2704
  (channels + newch)->remote_id = remch;
#line 2707
  packet_start(21);
#line 2708
  packet_put_int((unsigned int )remch);
#line 2709
  packet_put_int((unsigned int )newch);
#line 2710
  packet_send();
#line 2711
  return;
}
}
#line 2713 "channels.c"
void channel_start_open(int id ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2716
  tmp = channel_lookup(id);
#line 2716
  c = tmp;
#line 2717
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2718
    log("channel_open: %d: bad id", id);
#line 2719
    return;
  }
#line 2721
  debug("send channel open %d", id);
#line 2722
  packet_start(90);
#line 2723
  packet_put_cstring((char const   *)c->ctype);
#line 2724
  packet_put_int((unsigned int )c->self);
#line 2725
  packet_put_int((unsigned int )c->local_window);
#line 2726
  packet_put_int((unsigned int )c->local_maxpacket);
#line 2727
  return;
}
}
#line 2728 "channels.c"
void channel_open(int id ) 
{ 

  {
#line 2732
  channel_start_open(id);
#line 2733
  packet_send();
#line 2734
  return;
}
}
#line 2735 "channels.c"
void channel_request(int id , char *service , int wantconfirm ) 
{ 

  {
#line 2738
  channel_request_start(id, service, wantconfirm);
#line 2739
  packet_send();
#line 2740
  debug("channel request %d: %s", id, service);
#line 2741
  return;
}
}
#line 2742 "channels.c"
void channel_request_start(int id , char *service , int wantconfirm ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2745
  tmp = channel_lookup(id);
#line 2745
  c = tmp;
#line 2746
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2747
    log("channel_request: %d: bad id", id);
#line 2748
    return;
  }
#line 2750
  packet_start(98);
#line 2751
  packet_put_int((unsigned int )c->remote_id);
#line 2752
  packet_put_cstring((char const   *)service);
#line 2753
  packet_put_char(wantconfirm);
#line 2754
  return;
}
}
#line 2755 "channels.c"
void channel_register_callback(int id , int mtype , channel_callback_fn *fn , void *arg ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2758
  tmp = channel_lookup(id);
#line 2758
  c = tmp;
#line 2759
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2760
    log("channel_register_callback: %d: bad id", id);
#line 2761
    return;
  }
#line 2763
  c->cb_event = mtype;
#line 2764
  c->cb_fn = fn;
#line 2765
  c->cb_arg = arg;
#line 2766
  return;
}
}
#line 2767 "channels.c"
void channel_register_cleanup(int id , channel_callback_fn *fn ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2770
  tmp = channel_lookup(id);
#line 2770
  c = tmp;
#line 2771
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2772
    log("channel_register_cleanup: %d: bad id", id);
#line 2773
    return;
  }
#line 2775
  c->dettach_user = fn;
#line 2776
  return;
}
}
#line 2777 "channels.c"
void channel_cancel_cleanup(int id ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2780
  tmp = channel_lookup(id);
#line 2780
  c = tmp;
#line 2781
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2782
    log("channel_cancel_cleanup: %d: bad id", id);
#line 2783
    return;
  }
#line 2785
  c->dettach_user = (channel_callback_fn *)((void *)0);
#line 2786
  return;
}
}
#line 2787 "channels.c"
void channel_register_filter(int id , channel_filter_fn *fn ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2790
  tmp = channel_lookup(id);
#line 2790
  c = tmp;
#line 2791
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2792
    log("channel_register_filter: %d: bad id", id);
#line 2793
    return;
  }
#line 2795
  c->input_filter = fn;
#line 2796
  return;
}
}
#line 2798 "channels.c"
void channel_set_fds(int id , int rfd , int wfd , int efd , int extusage , int nonblock ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2802
  tmp = channel_lookup(id);
#line 2802
  c = tmp;
#line 2803
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2804
    fatal("channel_activate for non-larval channel %d.", id);
  } else {
#line 2803
    if (c->type != 10) {
#line 2804
      fatal("channel_activate for non-larval channel %d.", id);
    }
  }
#line 2805
  channel_register_fds(c, rfd, wfd, efd, extusage, nonblock);
#line 2806
  c->type = 4;
#line 2808
  c->local_window_max = c->local_maxpacket * 2;
#line 2808
  c->local_window = c->local_window_max;
#line 2809
  packet_start(93);
#line 2810
  packet_put_int((unsigned int )c->remote_id);
#line 2811
  packet_put_int((unsigned int )c->local_window);
#line 2812
  packet_send();
#line 2813
  return;
}
}
#line 1 "cipher.o"
#pragma merger(0,"./cipher.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 325 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 1205 "/usr/include/bits/string2.h"
extern char *__strsep_g(char **__stringp , char const   *__delim ) ;
#line 141 "/usr/include/openssl/des.h"
extern void DES_ncbc_encrypt(unsigned char const   *input , unsigned char *output ,
                             long length , DES_key_schedule *schedule , DES_cblock *ivec ,
                             int enc ) ;
#line 176
extern void DES_ede3_cbc_encrypt(unsigned char const   *input , unsigned char *output ,
                                 long length , DES_key_schedule *ks1 , DES_key_schedule *ks2 ,
                                 DES_key_schedule *ks3 , DES_cblock *ivec , int enc ) ;
#line 222
extern int DES_set_key(const_DES_cblock *key , DES_key_schedule *schedule ) ;
#line 108 "/usr/include/openssl/blowfish.h"
extern void BF_set_key(BF_KEY *key , int len , unsigned char const   *data ) ;
#line 115
extern void BF_cbc_encrypt(unsigned char const   *in , unsigned char *out , long length ,
                           BF_KEY const   *schedule , unsigned char *ivec , int enc ) ;
#line 87 "/usr/include/openssl/cast.h"
extern void CAST_set_key(CAST_KEY *key , int len , unsigned char const   *data ) ;
#line 92
extern void CAST_cbc_encrypt(unsigned char const   *in , unsigned char *out , long length ,
                             CAST_KEY *ks , unsigned char *iv , int enc ) ;
#line 45 "rijndael.h"
rijndael_ctx *rijndael_set_key(rijndael_ctx *ctx , u4byte const   *in_key , u4byte key_len ,
                               int encrypt ) ;
#line 46
void rijndael_encrypt(rijndael_ctx *ctx , u4byte const   *in_blk , u4byte *out_blk ) ;
#line 47
void rijndael_decrypt(rijndael_ctx *ctx , u4byte const   *in_blk , u4byte *out_blk ) ;
#line 106 "cipher.h"
u_int cipher_mask_ssh1(int client ) ;
#line 107
Cipher *cipher_by_name(char const   *name ) ;
#line 109
int cipher_number(char const   *name ) ;
#line 110
char *cipher_name(int id ) ;
#line 111
int ciphers_valid(char const   *names ) ;
#line 112
void cipher_init(CipherContext *cc , Cipher *cipher , u_char const   *key , u_int keylen ,
                 u_char const   *iv , u_int ivlen ) ;
#line 107 "/usr/include/openssl/md5.h"
extern int MD5_Init(MD5_CTX *c ) ;
#line 108
extern int MD5_Update(MD5_CTX *c , void const   *data , size_t len ) ;
#line 109
extern int MD5_Final(unsigned char *md , MD5_CTX *c ) ;
#line 48 "cipher.c"
void none_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) 
{ 

  {
#line 51
  return;
}
}
#line 52 "cipher.c"
void none_setiv(CipherContext *cc , u_char const   *iv , u_int ivlen ) 
{ 

  {
#line 55
  return;
}
}
#line 56 "cipher.c"
void none_crypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 59
  memcpy((void * __restrict  )dest, (void const   * __restrict  )src, len);
#line 60
  return;
}
}
#line 66
void des_ssh1_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) ;
#line 66 "cipher.c"
static int dowarn  =    1;
#line 63 "cipher.c"
void des_ssh1_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) 
{ 

  {
#line 67
  if (dowarn) {
#line 68
    error("Warning: use of DES is strongly discouraged due to cryptographic weaknesses");
#line 70
    dowarn = 0;
  }
#line 72
  DES_set_key((const_DES_cblock *)((void *)key), & cc->u.des.key);
#line 73
  return;
}
}
#line 74 "cipher.c"
void des_ssh1_setiv(CipherContext *cc , u_char const   *iv , u_int ivlen ) 
{ 

  {
#line 77
  memset((void *)(cc->u.des.iv), 0, sizeof(cc->u.des.iv));
#line 78
  return;
}
}
#line 79 "cipher.c"
void des_ssh1_encrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 82
  DES_ncbc_encrypt(src, dest, (long )len, & cc->u.des.key, & cc->u.des.iv, 1);
#line 84
  return;
}
}
#line 85 "cipher.c"
void des_ssh1_decrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 88
  DES_ncbc_encrypt(src, dest, (long )len, & cc->u.des.key, & cc->u.des.iv, 0);
#line 90
  return;
}
}
#line 93 "cipher.c"
void des3_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) 
{ 

  {
#line 96
  DES_set_key((const_DES_cblock *)((void *)key), & cc->u.des3.key1);
#line 97
  DES_set_key((const_DES_cblock *)((void *)(key + 8)), & cc->u.des3.key2);
#line 98
  DES_set_key((const_DES_cblock *)((void *)(key + 16)), & cc->u.des3.key3);
#line 99
  return;
}
}
#line 100 "cipher.c"
void des3_setiv(CipherContext *cc , u_char const   *iv , u_int ivlen ) 
{ 

  {
#line 103
  memset((void *)(cc->u.des3.iv2), 0, sizeof(cc->u.des3.iv2));
#line 104
  memset((void *)(cc->u.des3.iv3), 0, sizeof(cc->u.des3.iv3));
#line 105
  if ((unsigned int )iv == (unsigned int )((void *)0)) {
#line 106
    return;
  }
#line 107
  memcpy((void * __restrict  )(cc->u.des3.iv3), (void const   * __restrict  )((char *)iv),
         8U);
#line 108
  return;
}
}
#line 109 "cipher.c"
void des3_cbc_encrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 112
  DES_ede3_cbc_encrypt(src, dest, (long )len, & cc->u.des3.key1, & cc->u.des3.key2,
                       & cc->u.des3.key3, & cc->u.des3.iv3, 1);
#line 115
  return;
}
}
#line 116 "cipher.c"
void des3_cbc_decrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 119
  DES_ede3_cbc_encrypt(src, dest, (long )len, & cc->u.des3.key1, & cc->u.des3.key2,
                       & cc->u.des3.key3, & cc->u.des3.iv3, 0);
#line 122
  return;
}
}
#line 138 "cipher.c"
void des3_ssh1_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) 
{ 

  {
#line 141
  DES_set_key((const_DES_cblock *)((void *)key), & cc->u.des3.key1);
#line 142
  DES_set_key((const_DES_cblock *)((void *)(key + 8)), & cc->u.des3.key2);
#line 143
  if (keylen <= 16U) {
#line 144
    DES_set_key((const_DES_cblock *)((void *)key), & cc->u.des3.key3);
  } else {
#line 146
    DES_set_key((const_DES_cblock *)((void *)(key + 16)), & cc->u.des3.key3);
  }
#line 147
  return;
}
}
#line 148 "cipher.c"
void des3_ssh1_encrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ DES_cblock iv1 ;
  DES_cblock *iv2 ;
  DES_cblock *iv3 ;

  {
#line 153
  iv2 = & cc->u.des3.iv2;
#line 154
  iv3 = & cc->u.des3.iv3;
#line 156
  memcpy((void * __restrict  )(& iv1), (void const   * __restrict  )iv2, 8U);
#line 158
  DES_ncbc_encrypt(src, dest, (long )len, & cc->u.des3.key1, & iv1, 1);
#line 159
  DES_ncbc_encrypt((unsigned char const   *)dest, dest, (long )len, & cc->u.des3.key2,
                   iv2, 0);
#line 160
  DES_ncbc_encrypt((unsigned char const   *)dest, dest, (long )len, & cc->u.des3.key3,
                   iv3, 1);
#line 161
  return;
}
}
#line 162 "cipher.c"
void des3_ssh1_decrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ DES_cblock iv1 ;
  DES_cblock *iv2 ;
  DES_cblock *iv3 ;

  {
#line 167
  iv2 = & cc->u.des3.iv2;
#line 168
  iv3 = & cc->u.des3.iv3;
#line 170
  memcpy((void * __restrict  )(& iv1), (void const   * __restrict  )iv2, 8U);
#line 172
  DES_ncbc_encrypt(src, dest, (long )len, & cc->u.des3.key3, iv3, 0);
#line 173
  DES_ncbc_encrypt((unsigned char const   *)dest, dest, (long )len, & cc->u.des3.key2,
                   iv2, 1);
#line 174
  DES_ncbc_encrypt((unsigned char const   *)dest, dest, (long )len, & cc->u.des3.key1,
                   & iv1, 0);
#line 175
  return;
}
}
#line 178 "cipher.c"
void blowfish_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) 
{ 

  {
#line 181
  BF_set_key(& cc->u.bf.key, (int )keylen, (unsigned char const   *)((u_char *)key));
#line 182
  return;
}
}
#line 183 "cipher.c"
void blowfish_setiv(CipherContext *cc , u_char const   *iv , u_int ivlen ) 
{ 

  {
#line 186
  if ((unsigned int )iv == (unsigned int )((void *)0)) {
#line 187
    memset((void *)(cc->u.bf.iv), 0, 8U);
  } else {
#line 189
    memcpy((void * __restrict  )(cc->u.bf.iv), (void const   * __restrict  )((char *)iv),
           8U);
  }
#line 190
  return;
}
}
#line 191 "cipher.c"
void blowfish_cbc_encrypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                          u_int len ) 
{ 

  {
#line 195
  BF_cbc_encrypt((unsigned char const   *)((void *)src), dest, (long )len, (BF_KEY const   *)(& cc->u.bf.key),
                 cc->u.bf.iv, 1);
#line 197
  return;
}
}
#line 198 "cipher.c"
void blowfish_cbc_decrypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                          u_int len ) 
{ 

  {
#line 202
  BF_cbc_encrypt((unsigned char const   *)((void *)src), dest, (long )len, (BF_KEY const   *)(& cc->u.bf.key),
                 cc->u.bf.iv, 0);
#line 204
  return;
}
}
#line 210 "cipher.c"
static void swap_bytes(u_char const   *src , u_char *dst , int n___0 ) 
{ char c[4] ;
  u_char const   *tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  u_char const   *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  u_char *tmp___6 ;

  {
#line 216
  n___0 /= 4;
#line 216
  while (n___0 > 0) {
#line 217
    tmp = src;
#line 217
    src ++;
#line 217
    c[3] = (char )*tmp;
#line 218
    tmp___0 = src;
#line 218
    src ++;
#line 218
    c[2] = (char )*tmp___0;
#line 219
    tmp___1 = src;
#line 219
    src ++;
#line 219
    c[1] = (char )*tmp___1;
#line 220
    tmp___2 = src;
#line 220
    src ++;
#line 220
    c[0] = (char )*tmp___2;
#line 222
    tmp___3 = dst;
#line 222
    dst ++;
#line 222
    *tmp___3 = (unsigned char )c[0];
#line 223
    tmp___4 = dst;
#line 223
    dst ++;
#line 223
    *tmp___4 = (unsigned char )c[1];
#line 224
    tmp___5 = dst;
#line 224
    dst ++;
#line 224
    *tmp___5 = (unsigned char )c[2];
#line 225
    tmp___6 = dst;
#line 225
    dst ++;
#line 225
    *tmp___6 = (unsigned char )c[3];
#line 216
    n___0 --;
  }
#line 227
  return;
}
}
#line 229 "cipher.c"
void blowfish_ssh1_encrypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                           u_int len ) 
{ 

  {
#line 233
  swap_bytes(src, dest, (int )len);
#line 234
  BF_cbc_encrypt((unsigned char const   *)((void *)dest), dest, (long )len, (BF_KEY const   *)(& cc->u.bf.key),
                 cc->u.bf.iv, 1);
#line 236
  swap_bytes((u_char const   *)dest, dest, (int )len);
#line 237
  return;
}
}
#line 238 "cipher.c"
void blowfish_ssh1_decrypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                           u_int len ) 
{ 

  {
#line 242
  swap_bytes(src, dest, (int )len);
#line 243
  BF_cbc_encrypt((unsigned char const   *)((void *)dest), dest, (long )len, (BF_KEY const   *)(& cc->u.bf.key),
                 cc->u.bf.iv, 0);
#line 245
  swap_bytes((u_char const   *)dest, dest, (int )len);
#line 246
  return;
}
}
#line 249 "cipher.c"
void arcfour_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) 
{ 

  {
#line 252
  RC4_set_key(& cc->u.rc4, (int )keylen, (unsigned char const   *)((u_char *)key));
#line 253
  return;
}
}
#line 254 "cipher.c"
void arcfour_crypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 257
  RC4(& cc->u.rc4, (unsigned long )len, (unsigned char const   *)((u_char *)src),
      dest);
#line 258
  return;
}
}
#line 261 "cipher.c"
void cast_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) 
{ 

  {
#line 264
  CAST_set_key(& cc->u.cast.key, (int )keylen, (unsigned char const   *)((u_char *)key));
#line 265
  return;
}
}
#line 266 "cipher.c"
void cast_setiv(CipherContext *cc , u_char const   *iv , u_int ivlen ) 
{ 

  {
#line 269
  if ((unsigned int )iv == (unsigned int )((void *)0)) {
#line 270
    fatal("no IV for %s.", (cc->cipher)->name);
  }
#line 271
  memcpy((void * __restrict  )(cc->u.cast.iv), (void const   * __restrict  )((char *)iv),
         8U);
#line 272
  return;
}
}
#line 273 "cipher.c"
void cast_cbc_encrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 276
  CAST_cbc_encrypt(src, dest, (long )len, & cc->u.cast.key, cc->u.cast.iv, 1);
#line 278
  return;
}
}
#line 279 "cipher.c"
void cast_cbc_decrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 282
  CAST_cbc_encrypt(src, dest, (long )len, & cc->u.cast.key, cc->u.cast.iv, 0);
#line 284
  return;
}
}
#line 289 "cipher.c"
void rijndael_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) 
{ 

  {
#line 292
  rijndael_set_key(& cc->u.rijndael.enc, (u4byte const   *)((u4byte *)key), 8U * keylen,
                   1);
#line 293
  rijndael_set_key(& cc->u.rijndael.dec, (u4byte const   *)((u4byte *)key), 8U * keylen,
                   0);
#line 294
  return;
}
}
#line 295 "cipher.c"
void rijndael_setiv(CipherContext *cc , u_char const   *iv , u_int ivlen ) 
{ 

  {
#line 298
  if ((unsigned int )iv == (unsigned int )((void *)0)) {
#line 299
    fatal("no IV for %s.", (cc->cipher)->name);
  }
#line 300
  memcpy((void * __restrict  )((u_char *)(cc->u.rijndael.iv)), (void const   * __restrict  )iv,
         16U);
#line 301
  return;
}
}
#line 302 "cipher.c"
void rijndael_cbc_encrypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                          u_int len ) 
{ rijndael_ctx *ctx ;
  u4byte *iv ;
  u4byte in[4] ;
  u4byte *cprev ;
  u4byte *cnow ;
  u4byte *plain ;
  int i ;
  int blocks ;

  {
#line 306
  ctx = & cc->u.rijndael.enc;
#line 307
  iv = cc->u.rijndael.iv;
#line 310
  blocks = (int )(len / 16U);
#line 311
  if (len == 0U) {
#line 312
    return;
  }
#line 313
  if (len % 16U) {
#line 314
    fatal("rijndael_cbc_encrypt: bad len %d", len);
  }
#line 315
  cnow = (u4byte *)dest;
#line 316
  plain = (u4byte *)src;
#line 317
  cprev = iv;
#line 318
  i = 0;
#line 318
  while (i < blocks) {
#line 319
    in[0] = *(plain + 0) ^ *(cprev + 0);
#line 320
    in[1] = *(plain + 1) ^ *(cprev + 1);
#line 321
    in[2] = *(plain + 2) ^ *(cprev + 2);
#line 322
    in[3] = *(plain + 3) ^ *(cprev + 3);
#line 323
    rijndael_encrypt(ctx, (u4byte const   *)(in), cnow);
#line 324
    cprev = cnow;
#line 318
    i ++;
#line 318
    plain += 4;
#line 318
    cnow += 4;
  }
#line 326
  memcpy((void * __restrict  )iv, (void const   * __restrict  )cprev, 16U);
#line 327
  return;
}
}
#line 329 "cipher.c"
void rijndael_cbc_decrypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                          u_int len ) 
{ rijndael_ctx *ctx ;
  u4byte *iv ;
  u4byte ivsaved[4] ;
  u4byte *cnow ;
  u4byte *plain ;
  u4byte *ivp ;
  int i ;
  int blocks ;

  {
#line 333
  ctx = & cc->u.rijndael.dec;
#line 334
  iv = cc->u.rijndael.iv;
#line 336
  cnow = (u4byte *)((src + len) - 16);
#line 337
  plain = (u4byte *)((dest + len) - 16);
#line 339
  blocks = (int )(len / 16U);
#line 340
  if (len == 0U) {
#line 341
    return;
  }
#line 342
  if (len % 16U) {
#line 343
    fatal("rijndael_cbc_decrypt: bad len %d", len);
  }
#line 344
  memcpy((void * __restrict  )(ivsaved), (void const   * __restrict  )cnow, 16U);
#line 345
  i = blocks;
#line 345
  while (i > 0) {
#line 346
    rijndael_decrypt(ctx, (u4byte const   *)cnow, plain);
#line 347
    if (i == 1) {
#line 347
      ivp = iv;
    } else {
#line 347
      ivp = cnow - 4;
    }
#line 348
    *(plain + 0) ^= *(ivp + 0);
#line 349
    *(plain + 1) ^= *(ivp + 1);
#line 350
    *(plain + 2) ^= *(ivp + 2);
#line 351
    *(plain + 3) ^= *(ivp + 3);
#line 345
    i --;
#line 345
    cnow -= 4;
#line 345
    plain -= 4;
  }
#line 353
  memcpy((void * __restrict  )iv, (void const   * __restrict  )(ivsaved), 16U);
#line 354
  return;
}
}
#line 356 "cipher.c"
Cipher ciphers[16]  = 
#line 356
  {      {(char *)"none", 0, (u_int )8, (u_int )0, & none_setkey, & none_setiv, & none_crypt,
      & none_crypt}, 
        {(char *)"des", 2, (u_int )8, (u_int )8, & des_ssh1_setkey, & des_ssh1_setiv,
      & des_ssh1_encrypt, & des_ssh1_decrypt}, 
        {(char *)"3des", 3, (u_int )8, (u_int )16, & des3_ssh1_setkey, & des3_setiv,
      & des3_ssh1_encrypt, & des3_ssh1_decrypt}, 
        {(char *)"blowfish", 6, (u_int )8, (u_int )16, & blowfish_setkey, & blowfish_setiv,
      & blowfish_ssh1_encrypt, & blowfish_ssh1_decrypt}, 
        {(char *)"3des-cbc", -3, (u_int )8, (u_int )24, & des3_setkey, & des3_setiv,
      & des3_cbc_encrypt, & des3_cbc_decrypt}, 
        {(char *)"blowfish-cbc", -3, (u_int )8, (u_int )16, & blowfish_setkey, & blowfish_setiv,
      & blowfish_cbc_encrypt, & blowfish_cbc_decrypt}, 
        {(char *)"cast128-cbc", -3, (u_int )8, (u_int )16, & cast_setkey, & cast_setiv,
      & cast_cbc_encrypt, & cast_cbc_decrypt}, 
        {(char *)"arcfour", -3, (u_int )8, (u_int )16, & arcfour_setkey, & none_setiv,
      & arcfour_crypt, & arcfour_crypt}, 
        {(char *)"aes128-cbc", -3, (u_int )16, (u_int )16, & rijndael_setkey, & rijndael_setiv,
      & rijndael_cbc_encrypt, & rijndael_cbc_decrypt}, 
        {(char *)"aes192-cbc", -3, (u_int )16, (u_int )24, & rijndael_setkey, & rijndael_setiv,
      & rijndael_cbc_encrypt, & rijndael_cbc_decrypt}, 
        {(char *)"aes256-cbc", -3, (u_int )16, (u_int )32, & rijndael_setkey, & rijndael_setiv,
      & rijndael_cbc_encrypt, & rijndael_cbc_decrypt}, 
        {(char *)"rijndael128-cbc", -3, (u_int )16, (u_int )16, & rijndael_setkey, & rijndael_setiv,
      & rijndael_cbc_encrypt, & rijndael_cbc_decrypt}, 
        {(char *)"rijndael192-cbc", -3, (u_int )16, (u_int )24, & rijndael_setkey, & rijndael_setiv,
      & rijndael_cbc_encrypt, & rijndael_cbc_decrypt}, 
        {(char *)"rijndael256-cbc", -3, (u_int )16, (u_int )32, & rijndael_setkey, & rijndael_setiv,
      & rijndael_cbc_encrypt, & rijndael_cbc_decrypt}, 
        {(char *)"rijndael-cbc@lysator.liu.se", -3, (u_int )16, (u_int )32, & rijndael_setkey,
      & rijndael_setiv, & rijndael_cbc_encrypt, & rijndael_cbc_decrypt}, 
        {(char *)((void *)0), -2, (u_int )0, (u_int )0, (void (*)(CipherContext * , u_char const   * ,
                                                               u_int  ))((void *)0),
      (void (*)(CipherContext * , u_char const   * , u_int  ))((void *)0), (void (*)(CipherContext * ,
                                                                                     u_char * ,
                                                                                     u_char const   * ,
                                                                                     u_int  ))((void *)0),
      (void (*)(CipherContext * , u_char * , u_char const   * , u_int  ))((void *)0)}};
#line 423 "cipher.c"
u_int cipher_mask_ssh1(int client ) 
{ u_int mask ;

  {
#line 426
  mask = (u_int )0;
#line 427
  mask |= (unsigned int )(1 << 3);
#line 428
  mask |= (unsigned int )(1 << 6);
#line 429
  if (client) {
#line 430
    mask |= (unsigned int )(1 << 2);
  }
#line 432
  return (mask);
}
}
#line 435 "cipher.c"
Cipher *cipher_by_name(char const   *name ) 
{ Cipher *c ;
  int tmp ;

  {
#line 439
  c = ciphers;
#line 439
  while ((unsigned int )c->name != (unsigned int )((void *)0)) {
#line 440
    tmp = strcasecmp((char const   *)c->name, name);
#line 440
    if (tmp == 0) {
#line 441
      return (c);
    }
#line 439
    c ++;
  }
#line 442
  return ((Cipher *)((void *)0));
}
}
#line 445 "cipher.c"
Cipher *cipher_by_number(int id ) 
{ Cipher *c ;

  {
#line 449
  c = ciphers;
#line 449
  while ((unsigned int )c->name != (unsigned int )((void *)0)) {
#line 450
    if (c->number == id) {
#line 451
      return (c);
    }
#line 449
    c ++;
  }
#line 452
  return ((Cipher *)((void *)0));
}
}
#line 456 "cipher.c"
int ciphers_valid(char const   *names ) 
{ Cipher *c ;
  char *ciphers___0 ;
  char *cp ;
  char *p ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___24 ;
  char *tmp___40 ;

  {
#line 463
  if ((unsigned int )names == (unsigned int )((void *)0)) {
#line 464
    return (0);
  } else {
#line 463
    if (0) {
#line 463
      __s1_len = strlen(names);
#line 463
      __s2_len = strlen("");
#line 463
      if (! ((unsigned int )((void const   *)(names + 1)) - (unsigned int )((void const   *)names) == 1U)) {
        goto _L___0;
      } else {
#line 463
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 463
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 463
            tmp___8 = 1;
          } else {
#line 463
            if (__s2_len >= 4U) {
#line 463
              tmp___8 = 1;
            } else {
#line 463
              tmp___8 = 0;
            }
          }
        } else {
#line 463
          tmp___8 = 0;
        }
      }
#line 463
      if (tmp___8) {
#line 463
        tmp___4 = __builtin_strcmp(names, "");
      } else {
#line 463
        tmp___7 = __builtin_strcmp(names, "");
#line 463
        tmp___4 = tmp___7;
      }
    } else {
#line 463
      tmp___7 = __builtin_strcmp(names, "");
#line 463
      tmp___4 = tmp___7;
    }
#line 463
    if (tmp___4 == 0) {
#line 464
      return (0);
    }
  }
#line 465
  cp = xstrdup(names);
#line 465
  ciphers___0 = cp;
#line 466
  tmp___24 = __strsep_g(& cp, ",");
#line 466
  p = tmp___24;
#line 466
  while (1) {
#line 466
    if (p) {
#line 466
      if (! ((int )*p != 0)) {
#line 466
        break;
      }
    } else {
#line 466
      break;
    }
#line 468
    c = cipher_by_name((char const   *)p);
#line 469
    if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 470
      debug("bad cipher %s [%s]", p, names);
#line 471
      xfree((void *)ciphers___0);
#line 472
      return (0);
    } else {
#line 469
      if (c->number != -3) {
#line 470
        debug("bad cipher %s [%s]", p, names);
#line 471
        xfree((void *)ciphers___0);
#line 472
        return (0);
      } else {
#line 474
        debug3("cipher ok: %s [%s]", p, names);
      }
    }
#line 467
    tmp___40 = __strsep_g(& cp, ",");
#line 467
    p = tmp___40;
  }
#line 477
  debug3("ciphers ok: [%s]", names);
#line 478
  xfree((void *)ciphers___0);
#line 479
  return (1);
}
}
#line 487 "cipher.c"
int cipher_number(char const   *name ) 
{ Cipher *c ;
  int tmp ;

  {
#line 491
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 492
    return (-1);
  }
#line 493
  c = cipher_by_name(name);
#line 494
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 494
    tmp = -1;
  } else {
#line 494
    tmp = c->number;
  }
#line 494
  return (tmp);
}
}
#line 497 "cipher.c"
char *cipher_name(int id ) 
{ Cipher *c ;
  Cipher *tmp ;
  char const   *tmp___0 ;

  {
#line 500
  tmp = cipher_by_number(id);
#line 500
  c = tmp;
#line 501
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 501
    tmp___0 = "<unknown>";
  } else {
#line 501
    tmp___0 = (char const   *)c->name;
  }
#line 501
  return ((char *)tmp___0);
}
}
#line 504 "cipher.c"
void cipher_init(CipherContext *cc , Cipher *cipher , u_char const   *key , u_int keylen ,
                 u_char const   *iv , u_int ivlen ) 
{ 

  {
#line 508
  if (keylen < cipher->key_len) {
#line 509
    fatal("cipher_init: key length %d is insufficient for %s.", keylen, cipher->name);
  }
#line 511
  if ((unsigned int )iv != (unsigned int )((void *)0)) {
#line 511
    if (ivlen < cipher->block_size) {
#line 512
      fatal("cipher_init: iv length %d is insufficient for %s.", ivlen, cipher->name);
    }
  }
#line 514
  cc->cipher = cipher;
#line 515
  (*(cipher->setkey))(cc, key, keylen);
#line 516
  (*(cipher->setiv))(cc, iv, ivlen);
#line 517
  return;
}
}
#line 519 "cipher.c"
void cipher_encrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 522
  if (len % (cc->cipher)->block_size) {
#line 523
    fatal("cipher_encrypt: bad plaintext length %d", len);
  }
#line 524
  (*((cc->cipher)->encrypt))(cc, dest, src, len);
#line 525
  return;
}
}
#line 527 "cipher.c"
void cipher_decrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 530
  if (len % (cc->cipher)->block_size) {
#line 531
    fatal("cipher_decrypt: bad ciphertext length %d", len);
  }
#line 532
  (*((cc->cipher)->decrypt))(cc, dest, src, len);
#line 533
  return;
}
}
#line 540 "cipher.c"
void cipher_set_key_string(CipherContext *cc , Cipher *cipher , char const   *passphrase ) 
{ MD5_CTX md ;
  u_char digest___1[16] ;
  size_t tmp ;

  {
#line 547
  MD5_Init(& md);
#line 548
  tmp = strlen(passphrase);
#line 548
  MD5_Update(& md, (void const   *)((u_char const   *)passphrase), tmp);
#line 549
  MD5_Final(digest___1, & md);
#line 551
  cipher_init(cc, cipher, (u_char const   *)(digest___1), 16U, (u_char const   *)((void *)0),
              0U);
#line 553
  memset((void *)(digest___1), 0, sizeof(digest___1));
#line 554
  memset((void *)(& md), 0, sizeof(md));
#line 555
  return;
}
}
#line 1 "cli.o"
#pragma merger(0,"./cli.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 71 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
#line 117 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 216
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
#line 222
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo )  __attribute__((__nonnull__(1))) ;
#line 249
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
#line 257
extern int sigsuspend(sigset_t const   *__set )  __attribute__((__nonnull__(1))) ;
#line 260
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 143 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 218
extern int fflush(FILE *__stream ) ;
#line 38 "cli.h"
char *cli_read_passphrase(char const   *prompt , int from_stdin , int echo_enable ) ;
#line 40
char *cli_prompt(char *prompt , int echo_enable ) ;
#line 41
void cli_mesg(char *mesg ) ;
#line 34 "cli.c"
static int cli_input  =    -1;
#line 35 "cli.c"
static int cli_output  =    -1;
#line 36 "cli.c"
static int cli_from_stdin  =    0;
#line 38 "cli.c"
sigset_t oset  ;
#line 39 "cli.c"
sigset_t nset  ;
#line 40 "cli.c"
struct sigaction nsa  ;
#line 41 "cli.c"
struct sigaction osa  ;
#line 42 "cli.c"
struct termios ntio  ;
#line 43 "cli.c"
struct termios otio  ;
#line 44 "cli.c"
int echo_modified  ;
#line 46 "cli.c"
int volatile   intr  ;
#line 48 "cli.c"
static int cli_open(int from_stdin ) 
{ int tmp ;

  {
#line 51
  if (cli_input >= 0) {
#line 51
    if (cli_output >= 0) {
#line 51
      if (cli_from_stdin == from_stdin) {
#line 52
        return (1);
      }
    }
  }
#line 54
  if (from_stdin) {
#line 55
    if (! cli_from_stdin) {
#line 55
      if (cli_input >= 0) {
#line 56
        close(cli_input);
      }
    }
#line 58
    cli_input = 0;
#line 59
    cli_output = 2;
  } else {
#line 61
    cli_output = open("/dev/tty", 2);
#line 61
    cli_input = cli_output;
#line 62
    if (cli_input < 0) {
#line 63
      fatal("You have no controlling tty.  Cannot read passphrase.");
    }
  }
#line 66
  cli_from_stdin = from_stdin;
#line 68
  if (cli_input >= 0) {
#line 68
    if (cli_output >= 0) {
#line 68
      if (cli_from_stdin == from_stdin) {
#line 68
        tmp = 1;
      } else {
#line 68
        tmp = 0;
      }
    } else {
#line 68
      tmp = 0;
    }
  } else {
#line 68
    tmp = 0;
  }
#line 68
  return (tmp);
}
}
#line 71 "cli.c"
static void cli_close(void) 
{ 

  {
#line 74
  if (! cli_from_stdin) {
#line 74
    if (cli_input >= 0) {
#line 75
      close(cli_input);
    }
  }
#line 76
  cli_input = -1;
#line 77
  cli_output = -1;
#line 78
  cli_from_stdin = 0;
#line 79
  return;
}
}
#line 82 "cli.c"
void intrcatch(int sig ) 
{ 

  {
#line 85
  intr = (int volatile   )1;
#line 86
  return;
}
}
#line 88 "cli.c"
static void cli_echo_disable(void) 
{ int tmp ;

  {
#line 91
  sigemptyset(& nset);
#line 92
  sigaddset(& nset, 20);
#line 93
  sigprocmask(0, (sigset_t const   * __restrict  )(& nset), (sigset_t * __restrict  )(& oset));
#line 95
  intr = (int volatile   )0;
#line 97
  memset((void *)(& nsa), 0, sizeof(nsa));
#line 98
  nsa.__sigaction_handler.sa_handler = & intrcatch;
#line 99
  sigaction(2, (struct sigaction  const  * __restrict  )(& nsa), (struct sigaction * __restrict  )(& osa));
#line 101
  echo_modified = 0;
#line 102
  tmp = tcgetattr(cli_input, & otio);
#line 102
  if (tmp == 0) {
#line 102
    if (otio.c_lflag & 8U) {
#line 103
      echo_modified = 1;
#line 104
      ntio = otio;
#line 105
      ntio.c_lflag &= 4294967175U;
#line 106
      tcsetattr(cli_input, 0, (struct termios  const  *)(& ntio));
    }
  }
#line 108
  return;
}
}
#line 111 "cli.c"
static void cli_echo_restore(void) 
{ __pid_t tmp ;

  {
#line 114
  if (echo_modified != 0) {
#line 115
    tcsetattr(cli_input, 0, (struct termios  const  *)(& otio));
#line 116
    echo_modified = 0;
  }
#line 119
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((void *)0));
#line 120
  sigaction(2, (struct sigaction  const  * __restrict  )(& osa), (struct sigaction * __restrict  )((void *)0));
#line 122
  if (intr != (int volatile   )0) {
#line 123
    tmp = getpid();
#line 123
    kill(tmp, 2);
#line 124
    sigemptyset(& nset);
#line 126
    sigsuspend((sigset_t const   *)(& nset));
#line 127
    intr = (int volatile   )0;
  }
#line 129
  return;
}
}
#line 132 "cli.c"
static int cli_read(char *buf___2 , int size , int echo ) 
{ char ch ;
  int i ;
  int n___0 ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 135
  ch = (char)0;
#line 136
  i = 0;
#line 139
  if (! echo) {
#line 140
    cli_echo_disable();
  }
#line 142
  while ((int )ch != 10) {
#line 143
    n___0 = read(cli_input, (void *)(& ch), 1U);
#line 144
    if (n___0 == -1) {
#line 144
      tmp = __errno_location();
#line 144
      if (*tmp == 11) {
#line 145
        continue;
      } else {
#line 144
        tmp___0 = __errno_location();
#line 144
        if (*tmp___0 == 4) {
#line 145
          continue;
        }
      }
    }
#line 146
    if (n___0 != 1) {
#line 147
      break;
    }
#line 148
    if ((int )ch == 10) {
#line 149
      break;
    } else {
#line 148
      if (intr != (int volatile   )0) {
#line 149
        break;
      }
    }
#line 150
    if (i < size) {
#line 151
      tmp___1 = i;
#line 151
      i ++;
#line 151
      *(buf___2 + tmp___1) = ch;
    }
  }
#line 153
  *(buf___2 + i) = (char )'\000';
#line 155
  if (! echo) {
#line 156
    cli_echo_restore();
  }
#line 157
  if (! intr) {
#line 157
    if (! echo) {
#line 158
      write(cli_output, (void const   *)"\n", 1U);
    }
  }
#line 159
  return (i);
}
}
#line 162 "cli.c"
static int cli_write(char const   *buf___2 , int size ) 
{ int i ;
  int len ;
  int pos ;
  int ret ;
  char *output___0 ;
  char *p ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 165
  ret = 0;
#line 168
  tmp = xmalloc((unsigned int )(4 * size));
#line 168
  output___0 = (char *)tmp;
#line 169
  p = output___0;
#line 169
  i = 0;
#line 169
  while (i < size) {
#line 170
    if ((int const   )*(buf___2 + i) == 10) {
#line 171
      tmp___0 = p;
#line 171
      p ++;
#line 171
      *tmp___0 = (char )*(buf___2 + i);
    } else {
#line 170
      if ((int const   )*(buf___2 + i) == 13) {
#line 171
        tmp___0 = p;
#line 171
        p ++;
#line 171
        *tmp___0 = (char )*(buf___2 + i);
      } else {
#line 173
        p = vis(p, (int )*(buf___2 + i), 0, 0);
      }
    }
#line 169
    i ++;
  }
#line 175
  len = p - output___0;
#line 177
  pos = 0;
#line 177
  while (pos < len) {
#line 178
    ret = write(cli_output, (void const   *)(output___0 + pos), (unsigned int )(len - pos));
#line 179
    if (ret == -1) {
#line 180
      xfree((void *)output___0);
#line 181
      return (-1);
    }
#line 177
    pos += ret;
  }
#line 184
  xfree((void *)output___0);
#line 185
  return (0);
}
}
#line 194 "cli.c"
char *cli_read_passphrase(char const   *prompt , int from_stdin , int echo_enable ) 
{ char buf___2[8192] ;
  char *p ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 200
  tmp = cli_open(from_stdin);
#line 200
  if (! tmp) {
#line 201
    fatal("Cannot read passphrase.");
  }
#line 203
  fflush(stdout);
#line 205
  tmp___0 = strlen(prompt);
#line 205
  cli_write(prompt, (int )tmp___0);
#line 206
  cli_read(buf___2, (int )sizeof(buf___2), echo_enable);
#line 208
  cli_close();
#line 210
  p = xstrdup((char const   *)(buf___2));
#line 211
  memset((void *)(buf___2), 0, sizeof(buf___2));
#line 212
  return (p);
}
}
#line 215 "cli.c"
char *cli_prompt(char *prompt , int echo_enable ) 
{ char *tmp ;

  {
#line 218
  tmp = cli_read_passphrase((char const   *)prompt, 0, echo_enable);
#line 218
  return (tmp);
}
}
#line 221 "cli.c"
void cli_mesg(char *mesg ) 
{ size_t tmp ;
  size_t tmp___0 ;

  {
#line 224
  cli_open(0);
#line 225
  tmp = strlen((char const   *)mesg);
#line 225
  cli_write((char const   *)mesg, (int )tmp);
#line 226
  tmp___0 = strlen("\n");
#line 226
  cli_write("\n", (int )tmp___0);
#line 227
  cli_close();
#line 228
  return;
}
}
#line 1 "compat.o"
#pragma merger(0,"./compat.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 537 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 541
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 546
extern size_t regerror(int __errcode , regex_t const   * __restrict  __preg , char * __restrict  __errbuf ,
                       size_t __errbuf_size ) ;
#line 549
extern void regfree(regex_t *__preg ) ;
#line 52 "compat.h"
void enable_compat13(void) ;
#line 53
void enable_compat20(void) ;
#line 54
void compat_datafellows(char const   *version ) ;
#line 55
int proto_spec(char const   *spec ) ;
#line 56
char *compat_cipher_proposal(char *cipher_prop ) ;
#line 43 "compat.c"
int compat13  =    0;
#line 44 "compat.c"
int compat20  =    0;
#line 45 "compat.c"
int datafellows  =    0;
#line 47 "compat.c"
void enable_compat20(void) 
{ 

  {
#line 50
  verbose("Enabling compatibility mode for protocol 2.0");
#line 51
  compat20 = 1;
#line 52
  return;
}
}
#line 53 "compat.c"
void enable_compat13(void) 
{ 

  {
#line 56
  verbose("Enabling compatibility mode for protocol 1.3");
#line 57
  compat13 = 1;
#line 58
  return;
}
}
#line 66 "compat.c"
static struct __anonstruct_check_68 check[27]  = 
#line 66
  {      {(char *)"^OpenSSH[-_]2\\.[012]", 49296}, 
        {(char *)"^OpenSSH_2\\.3\\.0", 53376}, 
        {(char *)"^OpenSSH_2\\.3\\.", 53248}, 
        {(char *)"^OpenSSH_2\\.5\\.[01]p1", 53248}, 
        {(char *)"^OpenSSH_2\\.5\\.[012]", 49152}, 
        {(char *)"^OpenSSH_2\\.5\\.3", 32768}, 
        {(char *)"^OpenSSH", 0}, 
        {(char *)"MindTerm", 0}, 
        {(char *)"^2\\.1\\.0", 73813}, 
        {(char *)"^2\\.1 ", 73813}, 
        {(char *)"^2\\.0\\.1[3-9]", 74335}, 
        {(char *)"^2\\.0\\.", 8831}, 
        {(char *)"^2\\.[23]\\.0", 8196}, 
        {(char *)"^2\\.3\\.", 8192}, 
        {(char *)"^2\\.[2-9]\\.", 0}, 
        {(char *)"^2\\.4$", 16}, 
        {(char *)"^3\\.0 SecureCRT", 16}, 
        {(char *)"^1\\.7 SecureFX", 16}, 
        {(char *)"^1\\.2\\.1[89]", 256}, 
        {(char *)"^1\\.2\\.2[012]", 256}, 
        {(char *)"^1\\.3\\.2", 256}, 
        {(char *)"^SSH Compatible Server", 1024}, 
        {(char *)"^OSU_0", 1024}, 
        {(char *)"^OSU_1\\.[0-4]", 1024}, 
        {(char *)"^OSU_1\\.5alpha[1-3]", 1024}, 
        {(char *)"^SSH_Version_Mapper", 2048}, 
        {(char *)((void *)0), 0}};
#line 60 "compat.c"
void compat_datafellows(char const   *version ) 
{ int i ;
  int ret ;
  char ebuf[1024] ;
  regex_t reg ;

  {
#line 122
  i = 0;
#line 122
  while (check[i].pat) {
#line 123
    ret = regcomp((regex_t * __restrict  )(& reg), (char const   * __restrict  )check[i].pat,
                  1 | (((1 << 1) << 1) << 1));
#line 124
    if (ret != 0) {
#line 125
      regerror(ret, (regex_t const   * __restrict  )(& reg), (char * __restrict  )(ebuf),
               sizeof(ebuf));
#line 126
      ebuf[sizeof(ebuf) - 1U] = (char )'\000';
#line 127
      error("regerror: %s", ebuf);
      goto __Cont;
    }
#line 130
    ret = regexec((regex_t const   * __restrict  )(& reg), (char const   * __restrict  )version,
                  0U, (regmatch_t * __restrict  )((void *)0), 0);
#line 131
    regfree(& reg);
#line 132
    if (ret == 0) {
#line 133
      debug("match: %s pat %s", version, check[i].pat);
#line 134
      datafellows = check[i].bugs;
#line 135
      return;
    }
    __Cont: /* CIL Label */ 
#line 122
    i ++;
  }
#line 138
  debug("no match: %s", version);
#line 139
  return;
}
}
#line 142 "compat.c"
int proto_spec(char const   *spec ) 
{ char *s ;
  char *p ;
  char *q ;
  int ret ;
  char *tmp___14 ;
  char *tmp___30 ;
  int tmp___31 ;

  {
#line 146
  ret = 0;
#line 148
  if ((unsigned int )spec == (unsigned int )((void *)0)) {
#line 149
    return (ret);
  }
#line 150
  s = xstrdup(spec);
#line 150
  q = s;
#line 151
  tmp___14 = __strsep_g(& q, ",");
#line 151
  p = tmp___14;
#line 151
  while (1) {
#line 151
    if (p) {
#line 151
      if (! ((int )*p != 0)) {
#line 151
        break;
      }
    } else {
#line 151
      break;
    }
#line 152
    tmp___31 = atoi((char const   *)p);
#line 152
    switch (tmp___31) {
    case 1: 
#line 154
    if (ret == 0) {
#line 155
      ret |= 2;
    }
#line 156
    ret |= 1;
#line 157
    break;
    case 2: 
#line 159
    ret |= 4;
#line 160
    break;
    default: 
#line 162
    log("ignoring bad proto spec: \'%s\'.", p);
#line 163
    break;
    }
#line 151
    tmp___30 = __strsep_g(& q, ",");
#line 151
    p = tmp___30;
  }
#line 166
  xfree((void *)s);
#line 167
  return (ret);
}
}
#line 170 "compat.c"
char *compat_cipher_proposal(char *cipher_prop ) 
{ char *orig_prop ;
  char *fix_ciphers ;
  char *cp ;
  char *tmp ;
  size_t len ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___41 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___47 ;
  int tmp___50 ;
  int tmp___51 ;
  char *tmp___69 ;

  {
#line 177
  if (! (datafellows & 4096)) {
#line 178
    return (cipher_prop);
  }
#line 180
  tmp___0 = strlen((char const   *)cipher_prop);
#line 180
  len = tmp___0 + 1U;
#line 181
  tmp___1 = xmalloc(len);
#line 181
  fix_ciphers = (char *)tmp___1;
#line 182
  *fix_ciphers = (char )'\000';
#line 183
  orig_prop = xstrdup((char const   *)cipher_prop);
#line 183
  tmp = orig_prop;
#line 184
  while (1) {
#line 184
    tmp___69 = __strsep_g(& tmp, ",");
#line 184
    cp = tmp___69;
#line 184
    if (! ((unsigned int )cp != (unsigned int )((void *)0))) {
#line 184
      break;
    }
#line 185
    if (0) {
#line 185
      if (0) {
#line 185
        __s1_len___0 = strlen((char const   *)cp);
#line 185
        __s2_len___0 = strlen("aes");
#line 185
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___2;
        } else {
#line 185
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 185
            if (! ((unsigned int )((void const   *)("aes" + 1)) - (unsigned int )((void const   *)"aes") == 1U)) {
#line 185
              tmp___25 = 1;
            } else {
#line 185
              if (__s2_len___0 >= 4U) {
#line 185
                tmp___25 = 1;
              } else {
#line 185
                tmp___25 = 0;
              }
            }
          } else {
#line 185
            tmp___25 = 0;
          }
        }
#line 185
        if (tmp___25) {
#line 185
          tmp___21 = __builtin_strcmp((char const   *)cp, "aes");
        } else {
#line 185
          tmp___24 = __builtin_strcmp((char const   *)cp, "aes");
#line 185
          tmp___21 = tmp___24;
        }
      } else {
#line 185
        tmp___24 = __builtin_strcmp((char const   *)cp, "aes");
#line 185
        tmp___21 = tmp___24;
      }
#line 185
      tmp___15 = tmp___21;
    } else {
#line 185
      tmp___15 = strncmp((char const   *)cp, "aes", 3U);
    }
#line 185
    if (tmp___15) {
#line 185
      if (0) {
#line 185
        if (0) {
#line 185
          __s1_len___2 = strlen((char const   *)cp);
#line 185
          __s2_len___2 = strlen("rijndael");
#line 185
          if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
            goto _L___6;
          } else {
#line 185
            if (__s1_len___2 >= 4U) {
              _L___6: /* CIL Label */ 
#line 185
              if (! ((unsigned int )((void const   *)("rijndael" + 1)) - (unsigned int )((void const   *)"rijndael") == 1U)) {
#line 185
                tmp___51 = 1;
              } else {
#line 185
                if (__s2_len___2 >= 4U) {
#line 185
                  tmp___51 = 1;
                } else {
#line 185
                  tmp___51 = 0;
                }
              }
            } else {
#line 185
              tmp___51 = 0;
            }
          }
#line 185
          if (tmp___51) {
#line 185
            tmp___47 = __builtin_strcmp((char const   *)cp, "rijndael");
          } else {
#line 185
            tmp___50 = __builtin_strcmp((char const   *)cp, "rijndael");
#line 185
            tmp___47 = tmp___50;
          }
        } else {
#line 185
          tmp___50 = __builtin_strcmp((char const   *)cp, "rijndael");
#line 185
          tmp___47 = tmp___50;
        }
#line 185
        tmp___41 = tmp___47;
      } else {
#line 185
        tmp___41 = strncmp((char const   *)cp, "rijndael", 8U);
      }
#line 185
      if (tmp___41) {
#line 186
        if (*fix_ciphers) {
#line 187
          strlcat(fix_ciphers, ",", len);
        }
#line 188
        strlcat(fix_ciphers, (char const   *)cp, len);
      }
    }
  }
#line 191
  xfree((void *)orig_prop);
#line 192
  debug2("Original cipher proposal: %s", cipher_prop);
#line 193
  debug2("Compat cipher proposal: %s", fix_ciphers);
#line 194
  if (! *fix_ciphers) {
#line 195
    fatal("No available ciphers found.");
  }
#line 197
  return (fix_ciphers);
}
}
#line 1 "compress.o"
#pragma merger(0,"./compress.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 242 "/usr/include/zlib.h"
extern int deflate(z_streamp strm , int flush ) ;
#line 328
extern int deflateEnd(z_streamp strm ) ;
#line 363
extern int inflate(z_streamp strm , int flush ) ;
#line 462
extern int inflateEnd(z_streamp strm ) ;
#line 1317
extern int deflateInit_(z_streamp strm , int level , char const   *version , int stream_size ) ;
#line 1319
extern int inflateInit_(z_streamp strm , char const   *version , int stream_size ) ;
#line 23 "compress.h"
void buffer_compress_init_send(int level ) ;
#line 24
void buffer_compress_init_recv(void) ;
#line 27
void buffer_compress_uninit(void) ;
#line 37
void buffer_compress(Buffer *input_buffer , Buffer *output_buffer ) ;
#line 47
void buffer_uncompress(Buffer *input_buffer , Buffer *output_buffer ) ;
#line 22 "compress.c"
static z_stream incoming_stream  ;
#line 23 "compress.c"
static z_stream outgoing_stream  ;
#line 24 "compress.c"
static int compress_init_send_called  =    0;
#line 25 "compress.c"
static int compress_init_recv_called  =    0;
#line 32 "compress.c"
void buffer_compress_init_send(int level ) 
{ 

  {
#line 35
  if (compress_init_send_called == 1) {
#line 36
    deflateEnd(& incoming_stream);
  }
#line 37
  compress_init_send_called = 1;
#line 38
  debug("Enabling compression at level %d.", level);
#line 39
  if (level < 1) {
#line 40
    fatal("Bad compression level %d.", level);
  } else {
#line 39
    if (level > 9) {
#line 40
      fatal("Bad compression level %d.", level);
    }
  }
#line 41
  deflateInit_(& outgoing_stream, level, "1.2.3", (int )sizeof(z_stream ));
#line 42
  return;
}
}
#line 43 "compress.c"
void buffer_compress_init_recv(void) 
{ 

  {
#line 46
  if (compress_init_recv_called == 1) {
#line 47
    inflateEnd(& incoming_stream);
  }
#line 48
  compress_init_recv_called = 1;
#line 49
  inflateInit_(& incoming_stream, "1.2.3", (int )sizeof(z_stream ));
#line 50
  return;
}
}
#line 54 "compress.c"
void buffer_compress_uninit(void) 
{ double tmp ;
  double tmp___0 ;

  {
#line 57
  if (outgoing_stream.total_in == 0UL) {
#line 57
    tmp = 0.0;
  } else {
#line 57
    tmp = (double )outgoing_stream.total_out / (double )outgoing_stream.total_in;
  }
#line 57
  debug("compress outgoing: raw data %lu, compressed %lu, factor %.2f", outgoing_stream.total_in,
        outgoing_stream.total_out, tmp);
#line 61
  if (incoming_stream.total_out == 0UL) {
#line 61
    tmp___0 = 0.0;
  } else {
#line 61
    tmp___0 = (double )incoming_stream.total_in / (double )incoming_stream.total_out;
  }
#line 61
  debug("compress incoming: raw data %lu, compressed %lu, factor %.2f", incoming_stream.total_out,
        incoming_stream.total_in, tmp___0);
#line 65
  if (compress_init_recv_called == 1) {
#line 66
    inflateEnd(& incoming_stream);
  }
#line 67
  if (compress_init_send_called == 1) {
#line 68
    deflateEnd(& outgoing_stream);
  }
#line 69
  return;
}
}
#line 80 "compress.c"
void buffer_compress(Buffer *input_buffer , Buffer *output_buffer ) 
{ char buf___2[4096] ;
  int status ;
  u_int tmp ;
  char *tmp___0 ;

  {
#line 87
  tmp = buffer_len(input_buffer);
#line 87
  if (tmp == 0U) {
#line 88
    return;
  }
#line 91
  tmp___0 = buffer_ptr(input_buffer);
#line 91
  outgoing_stream.next_in = (u_char *)tmp___0;
#line 92
  outgoing_stream.avail_in = buffer_len(input_buffer);
#line 95
  while (1) {
#line 97
    outgoing_stream.next_out = (u_char *)(buf___2);
#line 98
    outgoing_stream.avail_out = sizeof(buf___2);
#line 101
    status = deflate(& outgoing_stream, 1);
#line 102
    switch (status) {
    case 0: 
#line 105
    buffer_append(output_buffer, (char const   *)(buf___2), sizeof(buf___2) - outgoing_stream.avail_out);
#line 107
    break;
    default: 
#line 109
    fatal("buffer_compress: deflate returned %d", status);
    }
#line 95
    if (! (outgoing_stream.avail_out == 0U)) {
#line 95
      break;
    }
  }
#line 113
  return;
}
}
#line 124 "compress.c"
void buffer_uncompress(Buffer *input_buffer , Buffer *output_buffer ) 
{ char buf___2[4096] ;
  int status ;
  char *tmp ;

  {
#line 130
  tmp = buffer_ptr(input_buffer);
#line 130
  incoming_stream.next_in = (u_char *)tmp;
#line 131
  incoming_stream.avail_in = buffer_len(input_buffer);
#line 133
  while (1) {
#line 135
    incoming_stream.next_out = (u_char *)(buf___2);
#line 136
    incoming_stream.avail_out = sizeof(buf___2);
#line 138
    status = inflate(& incoming_stream, 1);
#line 139
    switch (status) {
    case 0: 
#line 141
    buffer_append(output_buffer, (char const   *)(buf___2), sizeof(buf___2) - incoming_stream.avail_out);
#line 143
    break;
    case -5: 
#line 150
    return;
    default: 
#line 152
    fatal("buffer_uncompress: inflate returned %d", status);
    }
  }
}
}
#line 1 "crc32.o"
#pragma merger(0,"./crc32.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 23 "crc32.h"
u_int ssh_crc32(u_char const   *s , u_int len ) ;
#line 46 "crc32.c"
static u_int crc32_tab[256]  = 
#line 46 "crc32.c"
  {      (u_int )0L,      (u_int )1996959894L,      (u_int )3993919788UL,      (u_int )2567524794UL, 
        (u_int )124634137L,      (u_int )1886057615L,      (u_int )3915621685UL,      (u_int )2657392035UL, 
        (u_int )249268274L,      (u_int )2044508324L,      (u_int )3772115230UL,      (u_int )2547177864UL, 
        (u_int )162941995L,      (u_int )2125561021L,      (u_int )3887607047UL,      (u_int )2428444049UL, 
        (u_int )498536548L,      (u_int )1789927666L,      (u_int )4089016648UL,      (u_int )2227061214UL, 
        (u_int )450548861L,      (u_int )1843258603L,      (u_int )4107580753UL,      (u_int )2211677639UL, 
        (u_int )325883990L,      (u_int )1684777152L,      (u_int )4251122042UL,      (u_int )2321926636UL, 
        (u_int )335633487L,      (u_int )1661365465L,      (u_int )4195302755UL,      (u_int )2366115317UL, 
        (u_int )997073096L,      (u_int )1281953886L,      (u_int )3579855332UL,      (u_int )2724688242UL, 
        (u_int )1006888145L,      (u_int )1258607687L,      (u_int )3524101629UL,      (u_int )2768942443UL, 
        (u_int )901097722L,      (u_int )1119000684L,      (u_int )3686517206UL,      (u_int )2898065728UL, 
        (u_int )853044451L,      (u_int )1172266101L,      (u_int )3705015759UL,      (u_int )2882616665UL, 
        (u_int )651767980L,      (u_int )1373503546L,      (u_int )3369554304UL,      (u_int )3218104598UL, 
        (u_int )565507253L,      (u_int )1454621731L,      (u_int )3485111705UL,      (u_int )3099436303UL, 
        (u_int )671266974L,      (u_int )1594198024L,      (u_int )3322730930UL,      (u_int )2970347812UL, 
        (u_int )795835527L,      (u_int )1483230225L,      (u_int )3244367275UL,      (u_int )3060149565UL, 
        (u_int )1994146192L,      (u_int )31158534L,      (u_int )2563907772UL,      (u_int )4023717930UL, 
        (u_int )1907459465L,      (u_int )112637215L,      (u_int )2680153253UL,      (u_int )3904427059UL, 
        (u_int )2013776290L,      (u_int )251722036L,      (u_int )2517215374UL,      (u_int )3775830040UL, 
        (u_int )2137656763L,      (u_int )141376813L,      (u_int )2439277719UL,      (u_int )3865271297UL, 
        (u_int )1802195444L,      (u_int )476864866L,      (u_int )2238001368UL,      (u_int )4066508878UL, 
        (u_int )1812370925L,      (u_int )453092731L,      (u_int )2181625025UL,      (u_int )4111451223UL, 
        (u_int )1706088902L,      (u_int )314042704L,      (u_int )2344532202UL,      (u_int )4240017532UL, 
        (u_int )1658658271L,      (u_int )366619977L,      (u_int )2362670323UL,      (u_int )4224994405UL, 
        (u_int )1303535960L,      (u_int )984961486L,      (u_int )2747007092UL,      (u_int )3569037538UL, 
        (u_int )1256170817L,      (u_int )1037604311L,      (u_int )2765210733UL,      (u_int )3554079995UL, 
        (u_int )1131014506L,      (u_int )879679996L,      (u_int )2909243462UL,      (u_int )3663771856UL, 
        (u_int )1141124467L,      (u_int )855842277L,      (u_int )2852801631UL,      (u_int )3708648649UL, 
        (u_int )1342533948L,      (u_int )654459306L,      (u_int )3188396048UL,      (u_int )3373015174UL, 
        (u_int )1466479909L,      (u_int )544179635L,      (u_int )3110523913UL,      (u_int )3462522015UL, 
        (u_int )1591671054L,      (u_int )702138776L,      (u_int )2966460450UL,      (u_int )3352799412UL, 
        (u_int )1504918807L,      (u_int )783551873L,      (u_int )3082640443UL,      (u_int )3233442989UL, 
        (u_int )3988292384UL,      (u_int )2596254646UL,      (u_int )62317068L,      (u_int )1957810842L, 
        (u_int )3939845945UL,      (u_int )2647816111UL,      (u_int )81470997L,      (u_int )1943803523L, 
        (u_int )3814918930UL,      (u_int )2489596804UL,      (u_int )225274430L,      (u_int )2053790376L, 
        (u_int )3826175755UL,      (u_int )2466906013UL,      (u_int )167816743L,      (u_int )2097651377L, 
        (u_int )4027552580UL,      (u_int )2265490386UL,      (u_int )503444072L,      (u_int )1762050814L, 
        (u_int )4150417245UL,      (u_int )2154129355UL,      (u_int )426522225L,      (u_int )1852507879L, 
        (u_int )4275313526UL,      (u_int )2312317920UL,      (u_int )282753626L,      (u_int )1742555852L, 
        (u_int )4189708143UL,      (u_int )2394877945UL,      (u_int )397917763L,      (u_int )1622183637L, 
        (u_int )3604390888UL,      (u_int )2714866558UL,      (u_int )953729732L,      (u_int )1340076626L, 
        (u_int )3518719985UL,      (u_int )2797360999UL,      (u_int )1068828381L,      (u_int )1219638859L, 
        (u_int )3624741850UL,      (u_int )2936675148UL,      (u_int )906185462L,      (u_int )1090812512L, 
        (u_int )3747672003UL,      (u_int )2825379669UL,      (u_int )829329135L,      (u_int )1181335161L, 
        (u_int )3412177804UL,      (u_int )3160834842UL,      (u_int )628085408L,      (u_int )1382605366L, 
        (u_int )3423369109UL,      (u_int )3138078467UL,      (u_int )570562233L,      (u_int )1426400815L, 
        (u_int )3317316542UL,      (u_int )2998733608UL,      (u_int )733239954L,      (u_int )1555261956L, 
        (u_int )3268935591UL,      (u_int )3050360625UL,      (u_int )752459403L,      (u_int )1541320221L, 
        (u_int )2607071920UL,      (u_int )3965973030UL,      (u_int )1969922972L,      (u_int )40735498L, 
        (u_int )2617837225UL,      (u_int )3943577151UL,      (u_int )1913087877L,      (u_int )83908371L, 
        (u_int )2512341634UL,      (u_int )3803740692UL,      (u_int )2075208622L,      (u_int )213261112L, 
        (u_int )2463272603UL,      (u_int )3855990285UL,      (u_int )2094854071L,      (u_int )198958881L, 
        (u_int )2262029012UL,      (u_int )4057260610UL,      (u_int )1759359992L,      (u_int )534414190L, 
        (u_int )2176718541UL,      (u_int )4139329115UL,      (u_int )1873836001L,      (u_int )414664567L, 
        (u_int )2282248934UL,      (u_int )4279200368UL,      (u_int )1711684554L,      (u_int )285281116L, 
        (u_int )2405801727UL,      (u_int )4167216745UL,      (u_int )1634467795L,      (u_int )376229701L, 
        (u_int )2685067896UL,      (u_int )3608007406UL,      (u_int )1308918612L,      (u_int )956543938L, 
        (u_int )2808555105UL,      (u_int )3495958263UL,      (u_int )1231636301L,      (u_int )1047427035L, 
        (u_int )2932959818UL,      (u_int )3654703836UL,      (u_int )1088359270L,      (u_int )936918000L, 
        (u_int )2847714899UL,      (u_int )3736837829UL,      (u_int )1202900863L,      (u_int )817233897L, 
        (u_int )3183342108UL,      (u_int )3401237130UL,      (u_int )1404277552L,      (u_int )615818150L, 
        (u_int )3134207493UL,      (u_int )3453421203UL,      (u_int )1423857449L,      (u_int )601450431L, 
        (u_int )3009837614UL,      (u_int )3294710456UL,      (u_int )1567103746L,      (u_int )711928724L, 
        (u_int )3020668471UL,      (u_int )3272380065UL,      (u_int )1510334235L,      (u_int )755167117L};
#line 103 "crc32.c"
u_int ssh_crc32(u_char const   *s , u_int len ) 
{ u_int i ;
  u_int crc32val ;

  {
#line 109
  crc32val = 0U;
#line 110
  i = 0U;
#line 110
  while (i < len) {
#line 111
    crc32val = crc32_tab[(crc32val ^ (unsigned int )*(s + i)) & 255U] ^ (crc32val >> 8);
#line 110
    i ++;
  }
#line 113
  return (crc32val);
}
}
#line 1 "deattack.o"
#pragma merger(0,"./deattack.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 29 "deattack.h"
int detect_attack(u_char *buf___2 , u_int32_t len , u_char *IV ) ;
#line 50 "deattack.c"
void crc_update(u_int32_t *a , u_int32_t b ) 
{ 

  {
#line 53
  b ^= *a;
#line 54
  *a = ssh_crc32((u_char const   *)((u_char *)(& b)), sizeof(b));
#line 55
  return;
}
}
#line 58 "deattack.c"
int check_crc(u_char *S , u_char *buf___2 , u_int32_t len , u_char *IV ) 
{ u_int32_t crc ;
  u_char *c ;
  int tmp ;
  int tmp___0 ;

  {
#line 65
  crc = 0U;
#line 66
  if (IV) {
#line 66
    tmp = memcmp((void const   *)S, (void const   *)IV, 8U);
#line 66
    if (! tmp) {
#line 67
      crc_update(& crc, 1U);
#line 68
      crc_update(& crc, 0U);
    }
  }
#line 70
  c = buf___2;
#line 70
  while ((unsigned int )c < (unsigned int )(buf___2 + len)) {
#line 71
    tmp___0 = memcmp((void const   *)S, (void const   *)c, 8U);
#line 71
    if (tmp___0) {
#line 75
      crc_update(& crc, 0U);
#line 76
      crc_update(& crc, 0U);
    } else {
#line 72
      crc_update(& crc, 1U);
#line 73
      crc_update(& crc, 0U);
    }
#line 70
    c += 8;
  }
#line 79
  return (crc == 0U);
}
}
#line 87 "deattack.c"
static u_int16_t *h  =    (u_int16_t *)((void *)0);
#line 88 "deattack.c"
static u_int32_t n  =    (u_int32_t )4096;
#line 84 "deattack.c"
int detect_attack(u_char *buf___2 , u_int32_t len , u_char *IV ) 
{ register u_int32_t i ;
  register u_int32_t j ;
  u_int32_t l ;
  register u_char *c ;
  u_char *d ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 94
  if (len > 262144U) {
#line 96
    fatal("detect_attack: bad length %d", len);
  } else {
#line 94
    if (len % 8U != 0U) {
#line 96
      fatal("detect_attack: bad length %d", len);
    }
  }
#line 98
  l = n;
#line 98
  while (l < ((len / 8U) * 3U) / 2U) {
#line 98
    l <<= 2;
  }
#line 101
  if ((unsigned int )h == (unsigned int )((void *)0)) {
#line 102
    debug("Installing crc compensation attack detector.");
#line 103
    n = l;
#line 104
    tmp = xmalloc(n * 2U);
#line 104
    h = (u_int16_t *)tmp;
  } else {
#line 106
    if (l > n) {
#line 107
      n = l;
#line 108
      tmp___0 = xrealloc((void *)h, n * 2U);
#line 108
      h = (u_int16_t *)tmp___0;
    }
  }
#line 112
  if (len <= 56U) {
#line 113
    c = buf___2;
#line 113
    while ((unsigned int )c < (unsigned int )(buf___2 + len)) {
#line 114
      if (IV) {
#line 114
        tmp___2 = memcmp((void const   *)c, (void const   *)IV, 8U);
#line 114
        if (! tmp___2) {
#line 115
          tmp___1 = check_crc(c, buf___2, len, (u_char *)IV);
#line 115
          if (tmp___1) {
#line 116
            return (1);
          } else {
#line 118
            break;
          }
        }
      }
#line 120
      d = buf___2;
#line 120
      while ((unsigned int )d < (unsigned int )c) {
#line 121
        tmp___4 = memcmp((void const   *)c, (void const   *)d, 8U);
#line 121
        if (! tmp___4) {
#line 122
          tmp___3 = check_crc(c, buf___2, len, (u_char *)IV);
#line 122
          if (tmp___3) {
#line 123
            return (1);
          } else {
#line 125
            break;
          }
        }
#line 120
        d += 8;
      }
#line 113
      c += 8;
    }
#line 129
    return (0);
  }
#line 131
  memset((void *)h, 255, n * 2U);
#line 133
  if (IV) {
#line 134
    *(h + ((((((unsigned long )*(IV + 0) << 24) | ((unsigned long )*(IV + 1) << 16)) | ((unsigned long )*(IV + 2) << 8)) | (unsigned long )*(IV + 3)) & (unsigned long )(n - 1U))) = (unsigned short)65534;
  }
#line 136
  c = buf___2;
#line 136
  j = 0U;
#line 136
  while ((unsigned int )c < (unsigned int )(buf___2 + len)) {
#line 137
    i = (unsigned int )((((((unsigned long )*(c + 0) << 24) | ((unsigned long )*(c + 1) << 16)) | ((unsigned long )*(c + 2) << 8)) | (unsigned long )*(c + 3)) & (unsigned long )(n - 1U));
#line 137
    while ((int )*(h + i) != 65535) {
#line 139
      if ((int )*(h + i) == 65534) {
#line 140
        tmp___6 = memcmp((void const   *)c, (void const   *)IV, 8U);
#line 140
        if (! tmp___6) {
#line 141
          tmp___5 = check_crc(c, buf___2, len, (u_char *)IV);
#line 141
          if (tmp___5) {
#line 142
            return (1);
          } else {
#line 144
            break;
          }
        }
      } else {
#line 146
        tmp___8 = memcmp((void const   *)c, (void const   *)(buf___2 + (int )*(h + i) * 8),
                         8U);
#line 146
        if (! tmp___8) {
#line 147
          tmp___7 = check_crc(c, buf___2, len, (u_char *)IV);
#line 147
          if (tmp___7) {
#line 148
            return (1);
          } else {
#line 150
            break;
          }
        }
      }
#line 137
      i = (i + 1U) & (n - 1U);
    }
#line 153
    *(h + i) = (unsigned short )j;
#line 136
    c += 8;
#line 136
    j ++;
  }
#line 155
  return (0);
}
}
#line 1 "dh.o"
#pragma merger(0,"./dh.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 401 "/usr/include/openssl/bn.h"
extern int BN_rand(BIGNUM *rnd , int bits , int top , int bottom ) ;
#line 457
extern int BN_cmp(BIGNUM const   *a , BIGNUM const   *b ) ;
#line 458
extern void BN_free(BIGNUM *a ) ;
#line 459
extern int BN_is_bit_set(BIGNUM const   *a , int n ) ;
#line 497
extern int BN_hex2bn(BIGNUM **a , char const   *str ) ;
#line 173 "/usr/include/openssl/dh.h"
extern DH *DH_new(void) ;
#line 193
extern int DH_generate_key(DH *dh ) ;
#line 35 "dh.h"
DH *choose_dh(int min , int wantbits , int max ) ;
#line 36
DH *dh_new_group_asc(char const   *gen___0 , char const   *modulus ) ;
#line 37
DH *dh_new_group(BIGNUM *gen___0 , BIGNUM *modulus ) ;
#line 38
DH *dh_new_group1(void) ;
#line 40
void dh_gen_key(DH *dh , int need ) ;
#line 41
int dh_pub_is_valid(DH *dh , BIGNUM *dh_pub ) ;
#line 43
int dh_estimate(int bits ) ;
#line 18 "misc.h"
char *strdelim(char **s ) ;
#line 42 "dh.c"
int parse_prime(int linenum , char *line , struct dhgroup *dhg ) 
{ char *cp ;
  char *arg ;
  char *strsize ;
  char *gen___0 ;
  char *prime ;
  char *tmp___14 ;
  char *tmp___30 ;
  char *tmp___46 ;
  char *tmp___62 ;
  char *tmp___78 ;
  char *tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;

  {
#line 48
  cp = line;
#line 49
  arg = strdelim(& cp);
#line 51
  if ((int )*arg == 0) {
#line 52
    arg = strdelim(& cp);
  }
#line 53
  if (! *arg) {
#line 54
    return (0);
  } else {
#line 53
    if ((int )*arg == 35) {
#line 54
      return (0);
    }
  }
#line 57
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 57
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 59
  tmp___14 = __strsep_g(& cp, " ");
#line 59
  arg = tmp___14;
#line 60
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 60
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 62
  tmp___30 = __strsep_g(& cp, " ");
#line 62
  arg = tmp___30;
#line 63
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 63
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 65
  tmp___46 = __strsep_g(& cp, " ");
#line 65
  arg = tmp___46;
#line 66
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 66
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 68
  tmp___62 = __strsep_g(& cp, " ");
#line 68
  strsize = tmp___62;
#line 69
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 69
    if ((int )*strsize == 0) {
      goto fail;
    } else {
#line 69
      dhg->size = atoi((char const   *)strsize);
#line 69
      if (dhg->size == 0) {
        goto fail;
      }
    }
  }
#line 73
  (dhg->size) ++;
#line 74
  tmp___78 = __strsep_g(& cp, " ");
#line 74
  gen___0 = tmp___78;
#line 75
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 75
    if ((int )*gen___0 == 0) {
      goto fail;
    }
  }
#line 77
  tmp___94 = __strsep_g(& cp, " ");
#line 77
  prime = tmp___94;
#line 78
  if ((unsigned int )cp != (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 78
    if ((int )*prime == 0) {
      goto fail;
    }
  }
#line 81
  dhg->g = BN_new();
#line 82
  dhg->p = BN_new();
#line 83
  tmp___95 = BN_hex2bn(& dhg->g, (char const   *)gen___0);
#line 83
  if (tmp___95 == 0) {
    goto failclean;
  }
#line 86
  tmp___96 = BN_hex2bn(& dhg->p, (char const   *)prime);
#line 86
  if (tmp___96 == 0) {
    goto failclean;
  }
#line 89
  tmp___97 = BN_num_bits((BIGNUM const   *)dhg->p);
#line 89
  if (tmp___97 != dhg->size) {
    goto failclean;
  }
#line 92
  return (1);
  failclean: 
#line 95
  BN_free(dhg->g);
#line 96
  BN_free(dhg->p);
  fail: 
#line 98
  error("Bad prime description in line %d", linenum);
#line 99
  return (0);
}
}
#line 102 "dh.c"
DH *choose_dh(int min , int wantbits , int max ) 
{ FILE *f ;
  char line[1024] ;
  int best ;
  int bestcount ;
  int which ;
  int linenum ;
  struct dhgroup dhg ;
  DH *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  DH *tmp___6 ;

  {
#line 111
  f = fopen((char const   * __restrict  )"/usr/local/etc/primes", (char const   * __restrict  )"r");
#line 112
  if (! f) {
#line 113
    log("WARNING: %s does not exist, using old prime", "/usr/local/etc/primes");
#line 114
    tmp = dh_new_group1();
#line 114
    return (tmp);
  }
#line 117
  linenum = 0;
#line 118
  bestcount = 0;
#line 118
  best = bestcount;
#line 119
  while (1) {
#line 119
    tmp___1 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 119
    if (! tmp___1) {
#line 119
      break;
    }
#line 120
    linenum ++;
#line 121
    tmp___0 = parse_prime(linenum, line, & dhg);
#line 121
    if (! tmp___0) {
#line 122
      continue;
    }
#line 123
    BN_free(dhg.g);
#line 124
    BN_free(dhg.p);
#line 126
    if (dhg.size > max) {
#line 127
      continue;
    } else {
#line 126
      if (dhg.size < min) {
#line 127
        continue;
      }
    }
#line 129
    if (dhg.size > wantbits) {
#line 129
      if (dhg.size < best) {
#line 131
        best = dhg.size;
#line 132
        bestcount = 0;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 129
      if (dhg.size > best) {
#line 129
        if (best < wantbits) {
#line 131
          best = dhg.size;
#line 132
          bestcount = 0;
        }
      }
    }
#line 134
    if (dhg.size == best) {
#line 135
      bestcount ++;
    }
  }
#line 137
  fclose(f);
#line 139
  if (bestcount == 0) {
#line 140
    log("WARNING: no suitable primes in %s", "/usr/local/etc/primes");
#line 141
    return ((DH *)((void *)0));
  }
#line 144
  f = fopen((char const   * __restrict  )"/usr/local/etc/primes", (char const   * __restrict  )"r");
#line 145
  if (! f) {
#line 146
    fatal("WARNING: %s disappeared, giving up", "/usr/local/etc/primes");
  }
#line 149
  linenum = 0;
#line 150
  tmp___2 = arc4random();
#line 150
  which = (int )(tmp___2 % (unsigned int )bestcount);
#line 151
  while (1) {
#line 151
    tmp___5 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 151
    if (! tmp___5) {
#line 151
      break;
    }
#line 152
    tmp___3 = parse_prime(linenum, line, & dhg);
#line 152
    if (! tmp___3) {
#line 153
      continue;
    }
#line 154
    if (dhg.size > max) {
#line 157
      BN_free(dhg.g);
#line 158
      BN_free(dhg.p);
#line 159
      continue;
    } else {
#line 154
      if (dhg.size < min) {
#line 157
        BN_free(dhg.g);
#line 158
        BN_free(dhg.p);
#line 159
        continue;
      } else {
#line 154
        if (dhg.size != best) {
#line 157
          BN_free(dhg.g);
#line 158
          BN_free(dhg.p);
#line 159
          continue;
        } else {
#line 154
          tmp___4 = linenum;
#line 154
          linenum ++;
#line 154
          if (tmp___4 != which) {
#line 157
            BN_free(dhg.g);
#line 158
            BN_free(dhg.p);
#line 159
            continue;
          }
        }
      }
    }
#line 161
    break;
  }
#line 163
  fclose(f);
#line 164
  if (linenum != which + 1) {
#line 165
    fatal("WARNING: line %d disappeared in %s, giving up", which, "/usr/local/etc/primes");
  }
#line 168
  tmp___6 = dh_new_group(dhg.g, dhg.p);
#line 168
  return (tmp___6);
}
}
#line 173 "dh.c"
int dh_pub_is_valid(DH *dh , BIGNUM *dh_pub ) 
{ int i ;
  int n___0 ;
  int tmp ;
  int bits_set ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 177
  tmp = BN_num_bits((BIGNUM const   *)dh_pub);
#line 177
  n___0 = tmp;
#line 178
  bits_set = 0;
#line 180
  if (dh_pub->neg) {
#line 181
    log("invalid public DH value: negativ");
#line 182
    return (0);
  }
#line 184
  i = 0;
#line 184
  while (i <= n___0) {
#line 185
    tmp___0 = BN_is_bit_set((BIGNUM const   *)dh_pub, i);
#line 185
    if (tmp___0) {
#line 186
      bits_set ++;
    }
#line 184
    i ++;
  }
#line 187
  tmp___1 = BN_num_bits((BIGNUM const   *)dh->p);
#line 187
  debug("bits set: %d/%d", bits_set, tmp___1);
#line 190
  if (bits_set > 1) {
#line 190
    tmp___2 = BN_cmp((BIGNUM const   *)dh_pub, (BIGNUM const   *)dh->p);
#line 190
    if (tmp___2 == -1) {
#line 191
      return (1);
    }
  }
#line 192
  tmp___3 = BN_num_bits((BIGNUM const   *)dh->p);
#line 192
  log("invalid public DH value (%d/%d)", bits_set, tmp___3);
#line 193
  return (0);
}
}
#line 196 "dh.c"
void dh_gen_key(DH *dh , int need ) 
{ int i ;
  int bits_set ;
  int tries ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 199
  bits_set = 0;
#line 199
  tries = 0;
#line 201
  if ((unsigned int )dh->p == (unsigned int )((void *)0)) {
#line 202
    fatal("dh_gen_key: dh->p == NULL");
  }
#line 203
  tmp___0 = BN_num_bits((BIGNUM const   *)dh->p);
#line 203
  if (2 * need >= tmp___0) {
#line 204
    tmp = BN_num_bits((BIGNUM const   *)dh->p);
#line 204
    fatal("dh_gen_key: group too small: %d (2*need %d)", tmp, 2 * need);
  }
#line 206
  while (1) {
#line 207
    if ((unsigned int )dh->priv_key != (unsigned int )((void *)0)) {
#line 208
      BN_free(dh->priv_key);
    }
#line 209
    dh->priv_key = BN_new();
#line 210
    if ((unsigned int )dh->priv_key == (unsigned int )((void *)0)) {
#line 211
      fatal("dh_gen_key: BN_new failed");
    }
#line 213
    tmp___1 = BN_rand(dh->priv_key, 2 * need, 0, 0);
#line 213
    if (! tmp___1) {
#line 214
      fatal("dh_gen_key: BN_rand failed");
    }
#line 215
    tmp___2 = DH_generate_key(dh);
#line 215
    if (tmp___2 == 0) {
#line 216
      fatal("DH_generate_key");
    }
#line 217
    i = 0;
#line 217
    while (1) {
#line 217
      tmp___4 = BN_num_bits((BIGNUM const   *)dh->priv_key);
#line 217
      if (! (i <= tmp___4)) {
#line 217
        break;
      }
#line 218
      tmp___3 = BN_is_bit_set((BIGNUM const   *)dh->priv_key, i);
#line 218
      if (tmp___3) {
#line 219
        bits_set ++;
      }
#line 217
      i ++;
    }
#line 220
    tmp___5 = BN_num_bits((BIGNUM const   *)dh->priv_key);
#line 220
    debug("dh_gen_key: priv key bits set: %d/%d", bits_set, tmp___5);
#line 222
    tmp___6 = tries;
#line 222
    tries ++;
#line 222
    if (tmp___6 > 10) {
#line 223
      fatal("dh_gen_key: too many bad keys: giving up");
    }
#line 206
    tmp___7 = dh_pub_is_valid(dh, dh->pub_key);
#line 206
    if (tmp___7) {
#line 206
      break;
    }
  }
#line 225
  return;
}
}
#line 227 "dh.c"
DH *dh_new_group_asc(char const   *gen___0 , char const   *modulus ) 
{ DH *dh ;
  int tmp ;
  int tmp___0 ;

  {
#line 232
  dh = DH_new();
#line 233
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 234
    fatal("DH_new");
  }
#line 236
  tmp = BN_hex2bn(& dh->p, modulus);
#line 236
  if (tmp == 0) {
#line 237
    fatal("BN_hex2bn p");
  }
#line 238
  tmp___0 = BN_hex2bn(& dh->g, gen___0);
#line 238
  if (tmp___0 == 0) {
#line 239
    fatal("BN_hex2bn g");
  }
#line 241
  return (dh);
}
}
#line 249 "dh.c"
DH *dh_new_group(BIGNUM *gen___0 , BIGNUM *modulus ) 
{ DH *dh ;

  {
#line 254
  dh = DH_new();
#line 255
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 256
    fatal("DH_new");
  }
#line 257
  dh->p = modulus;
#line 258
  dh->g = gen___0;
#line 260
  return (dh);
}
}
#line 266 "dh.c"
static char *gen  =    (char *)"2";
#line 266 "dh.c"
static char *group1  =    (char *)"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF";
#line 263 "dh.c"
DH *dh_new_group1(void) 
{ DH *tmp ;

  {
#line 274
  tmp = dh_new_group_asc((char const   *)gen, (char const   *)group1);
#line 274
  return (tmp);
}
}
#line 283 "dh.c"
int dh_estimate(int bits ) 
{ 

  {
#line 287
  if (bits < 64) {
#line 288
    return (512);
  }
#line 289
  if (bits < 128) {
#line 290
    return (1024);
  }
#line 291
  if (bits < 192) {
#line 292
    return (2048);
  }
#line 293
  return (4096);
}
}
#line 1 "dispatch.o"
#pragma merger(0,"./dispatch.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 33 "dispatch.h"
void dispatch_init(dispatch_fn *dflt ) ;
#line 34
void dispatch_set(int type , dispatch_fn *fn ) ;
#line 35
void dispatch_run(int mode , int *done , void *ctxt ) ;
#line 36
void dispatch_protocol_error(int type , int plen , void *ctxt ) ;
#line 114 "packet.h"
int packet_read_poll(int *payload_len_ptr ) ;
#line 37 "dispatch.c"
dispatch_fn *dispatch[255]  ;
#line 39 "dispatch.c"
void dispatch_protocol_error(int type , int plen , void *ctxt ) 
{ 

  {
#line 42
  error("Hm, dispatch protocol error: type %d plen %d", type, plen);
#line 43
  if (compat20) {
#line 43
    if (type == 20) {
#line 44
      fatal("dispatch_protocol_error: rekeying is not supported");
    }
  }
#line 45
  return;
}
}
#line 46 "dispatch.c"
void dispatch_init(dispatch_fn *dflt ) 
{ int i ;

  {
#line 50
  i = 0;
#line 50
  while (i < 255) {
#line 51
    dispatch[i] = dflt;
#line 50
    i ++;
  }
#line 52
  return;
}
}
#line 53 "dispatch.c"
void dispatch_set(int type , dispatch_fn *fn ) 
{ 

  {
#line 56
  dispatch[type] = fn;
#line 57
  return;
}
}
#line 58 "dispatch.c"
void dispatch_run(int mode , int *done , void *ctxt ) 
{ int plen ;
  int type ;

  {
#line 61
  while (1) {
#line 65
    if (mode == 0) {
#line 66
      type = packet_read(& plen);
    } else {
#line 68
      type = packet_read_poll(& plen);
#line 69
      if (type == 0) {
#line 70
        return;
      }
    }
#line 72
    if (type > 0) {
#line 72
      if (type < 255) {
#line 72
        if ((unsigned int )dispatch[type] != (unsigned int )((void *)0)) {
#line 73
          (*(dispatch[type]))(type, plen, ctxt);
        } else {
#line 75
          packet_disconnect("protocol error: rcvd type %d", type);
        }
      } else {
#line 75
        packet_disconnect("protocol error: rcvd type %d", type);
      }
    } else {
#line 75
      packet_disconnect("protocol error: rcvd type %d", type);
    }
#line 76
    if ((unsigned int )done != (unsigned int )((void *)0)) {
#line 76
      if (*done) {
#line 77
        return;
      }
    }
  }
}
}
#line 1 "mac.o"
#pragma merger(0,"./mac.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 593 "/usr/include/openssl/evp.h"
extern EVP_MD const   *EVP_md5(void) ;
#line 597
extern EVP_MD const   *EVP_sha1(void) ;
#line 611
extern EVP_MD const   *EVP_ripemd160(void) ;
#line 89 "/usr/include/openssl/hmac.h"
extern void HMAC_CTX_cleanup(HMAC_CTX *ctx ) ;
#line 93
extern void HMAC_Init(HMAC_CTX *ctx , void const   *key , int len , EVP_MD const   *md ) ;
#line 97
extern void HMAC_Update(HMAC_CTX *ctx , unsigned char const   *data , size_t len ) ;
#line 98
extern void HMAC_Final(HMAC_CTX *ctx , unsigned char *md , unsigned int *len ) ;
#line 26 "mac.h"
int mac_valid(char const   *names ) ;
#line 27
int mac_init(Mac *mac , char *name ) ;
#line 28
u_char *mac_compute(Mac *mac , u_int32_t seqno , u_char *data , int datalen ) ;
#line 37 "mac.c"
struct __anonstruct_macs_78 macs[7]  = {      {(char *)"hmac-sha1", (EVP_MD *(*)(void))(& EVP_sha1), 0}, 
        {(char *)"hmac-sha1-96", (EVP_MD *(*)(void))(& EVP_sha1), 96}, 
        {(char *)"hmac-md5", (EVP_MD *(*)(void))(& EVP_md5), 0}, 
        {(char *)"hmac-md5-96", (EVP_MD *(*)(void))(& EVP_md5), 96}, 
        {(char *)"hmac-ripemd160", (EVP_MD *(*)(void))(& EVP_ripemd160), 0}, 
        {(char *)"hmac-ripemd160@openssh.com", (EVP_MD *(*)(void))(& EVP_ripemd160),
      0}, 
        {(char *)((void *)0), (EVP_MD *(*)(void))((void *)0), 0}};
#line 51 "mac.c"
int mac_init(Mac *mac , char *name ) 
{ int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 55
  i = 0;
#line 55
  while (macs[i].name) {
#line 56
    if (0) {
#line 56
      __s1_len = strlen((char const   *)name);
#line 56
      __s2_len = strlen((char const   *)macs[i].name);
#line 56
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___0;
      } else {
#line 56
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 56
          if (! ((unsigned int )((void const   *)(macs[i].name + 1)) - (unsigned int )((void const   *)macs[i].name) == 1U)) {
#line 56
            tmp___8 = 1;
          } else {
#line 56
            if (__s2_len >= 4U) {
#line 56
              tmp___8 = 1;
            } else {
#line 56
              tmp___8 = 0;
            }
          }
        } else {
#line 56
          tmp___8 = 0;
        }
      }
#line 56
      if (tmp___8) {
#line 56
        tmp___4 = __builtin_strcmp((char const   *)name, (char const   *)macs[i].name);
      } else {
#line 56
        tmp___7 = __builtin_strcmp((char const   *)name, (char const   *)macs[i].name);
#line 56
        tmp___4 = tmp___7;
      }
    } else {
#line 56
      tmp___7 = __builtin_strcmp((char const   *)name, (char const   *)macs[i].name);
#line 56
      tmp___4 = tmp___7;
    }
#line 56
    if (tmp___4 == 0) {
#line 57
      if ((unsigned int )mac != (unsigned int )((void *)0)) {
#line 58
        mac->md = (*(macs[i].mdfunc))();
#line 59
        mac->mac_len = (mac->md)->md_size;
#line 59
        mac->key_len = mac->mac_len;
#line 60
        if (macs[i].truncatebits != 0) {
#line 61
          mac->mac_len = macs[i].truncatebits / 8;
        }
      }
#line 63
      debug2("mac_init: found %s", name);
#line 64
      return (0);
    }
#line 55
    i ++;
  }
#line 67
  debug2("mac_init: unknown %s", name);
#line 68
  return (-1);
}
}
#line 75 "mac.c"
static u_char m[64]  ;
#line 71 "mac.c"
u_char *mac_compute(Mac *mac , u_int32_t seqno , u_char *data , int datalen ) 
{ HMAC_CTX c ;
  u_char b[4] ;

  {
#line 78
  if ((unsigned int )mac->key == (unsigned int )((void *)0)) {
#line 79
    fatal("mac_compute: no key");
  }
#line 80
  if ((unsigned int )mac->mac_len > sizeof(m)) {
#line 81
    fatal("mac_compute: mac too long");
  }
#line 82
  HMAC_Init(& c, (void const   *)mac->key, mac->key_len, (EVP_MD const   *)mac->md);
#line 83
  while (1) {
#line 83
    b[0] = (unsigned char )(seqno >> 24);
#line 83
    b[1] = (unsigned char )(seqno >> 16);
#line 83
    b[2] = (unsigned char )(seqno >> 8);
#line 83
    b[3] = (unsigned char )seqno;
#line 83
    break;
  }
#line 84
  HMAC_Update(& c, (unsigned char const   *)(b), sizeof(b));
#line 85
  HMAC_Update(& c, (unsigned char const   *)data, (unsigned int )datalen);
#line 86
  HMAC_Final(& c, m, (unsigned int *)((void *)0));
#line 87
  HMAC_CTX_cleanup(& c);
#line 88
  return (m);
}
}
#line 93 "mac.c"
int mac_valid(char const   *names ) 
{ char *maclist ;
  char *cp ;
  char *p ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___24 ;
  char *tmp___40 ;
  int tmp___41 ;

  {
#line 98
  if ((unsigned int )names == (unsigned int )((void *)0)) {
#line 99
    return (0);
  } else {
#line 98
    if (0) {
#line 98
      __s1_len = strlen(names);
#line 98
      __s2_len = strlen("");
#line 98
      if (! ((unsigned int )((void const   *)(names + 1)) - (unsigned int )((void const   *)names) == 1U)) {
        goto _L___0;
      } else {
#line 98
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 98
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 98
            tmp___8 = 1;
          } else {
#line 98
            if (__s2_len >= 4U) {
#line 98
              tmp___8 = 1;
            } else {
#line 98
              tmp___8 = 0;
            }
          }
        } else {
#line 98
          tmp___8 = 0;
        }
      }
#line 98
      if (tmp___8) {
#line 98
        tmp___4 = __builtin_strcmp(names, "");
      } else {
#line 98
        tmp___7 = __builtin_strcmp(names, "");
#line 98
        tmp___4 = tmp___7;
      }
    } else {
#line 98
      tmp___7 = __builtin_strcmp(names, "");
#line 98
      tmp___4 = tmp___7;
    }
#line 98
    if (tmp___4 == 0) {
#line 99
      return (0);
    }
  }
#line 100
  cp = xstrdup(names);
#line 100
  maclist = cp;
#line 101
  tmp___24 = __strsep_g(& cp, ",");
#line 101
  p = tmp___24;
#line 101
  while (1) {
#line 101
    if (p) {
#line 101
      if (! ((int )*p != 0)) {
#line 101
        break;
      }
    } else {
#line 101
      break;
    }
#line 103
    tmp___41 = mac_init((Mac *)((void *)0), p);
#line 103
    if (tmp___41 < 0) {
#line 104
      debug("bad mac %s [%s]", p, names);
#line 105
      xfree((void *)maclist);
#line 106
      return (0);
    } else {
#line 108
      debug3("mac ok: %s [%s]", p, names);
    }
#line 102
    tmp___40 = __strsep_g(& cp, ",");
#line 102
    p = tmp___40;
  }
#line 111
  debug3("macs ok: [%s]", names);
#line 112
  xfree((void *)maclist);
#line 113
  return (1);
}
}
#line 1 "hostfile.o"
#pragma merger(0,"./hostfile.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 410 "/usr/include/openssl/bn.h"
extern BIGNUM *BN_copy(BIGNUM *a , BIGNUM const   *b ) ;
#line 31 "match.h"
int match_hostname(char const   *host , char const   *pattern , u_int len ) ;
#line 56 "key.h"
int key_equal(Key *a , Key *b ) ;
#line 59
int key_write(Key *key , FILE *f ) ;
#line 61
u_int key_size(Key *k ) ;
#line 17 "hostfile.h"
int auth_rsa_read_key(char **cpp , u_int *bitsp , BIGNUM *e , BIGNUM *n___0 ) ;
#line 30
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , Key *key ,
                                  Key *found , int *numret ) ;
#line 38
int add_host_to_hostfile(char const   *filename , char const   *host , Key *key ) ;
#line 52 "hostfile.c"
int hostfile_read_key(char **cpp , u_int *bitsp , Key *ret ) 
{ char *cp ;
  int tmp ;

  {
#line 58
  cp = *cpp;
#line 58
  while (1) {
#line 58
    if (! ((int )*cp == 32)) {
#line 58
      if (! ((int )*cp == 9)) {
#line 58
        break;
      }
    }
#line 58
    cp ++;
  }
#line 61
  tmp = key_read(ret, & cp);
#line 61
  if (tmp != 1) {
#line 62
    return (0);
  }
#line 65
  while (1) {
#line 65
    if (! ((int )*cp == 32)) {
#line 65
      if (! ((int )*cp == 9)) {
#line 65
        break;
      }
    }
#line 65
    cp ++;
  }
#line 69
  *cpp = cp;
#line 70
  *bitsp = key_size(ret);
#line 71
  return (1);
}
}
#line 74 "hostfile.c"
int auth_rsa_read_key(char **cpp , u_int *bitsp , BIGNUM *e , BIGNUM *n___0 ) 
{ Key *k ;
  Key *tmp ;
  int ret ;
  int tmp___0 ;

  {
#line 77
  tmp = key_new(0);
#line 77
  k = tmp;
#line 78
  tmp___0 = hostfile_read_key(cpp, bitsp, k);
#line 78
  ret = tmp___0;
#line 79
  BN_copy(e, (BIGNUM const   *)(k->rsa)->e);
#line 80
  BN_copy(n___0, (BIGNUM const   *)(k->rsa)->n);
#line 81
  key_free(k);
#line 82
  return (ret);
}
}
#line 85 "hostfile.c"
int hostfile_check_key(int bits , Key *key , char const   *host , char const   *filename ,
                       int linenum ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 88
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 89
    return (1);
  } else {
#line 88
    if (key->type != 0) {
#line 89
      return (1);
    } else {
#line 88
      if ((unsigned int )key->rsa == (unsigned int )((void *)0)) {
#line 89
        return (1);
      }
    }
  }
#line 90
  tmp___1 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 90
  if (bits != tmp___1) {
#line 91
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 91
    log("Warning: %s, line %d: keysize mismatch for host %s: actual %d vs. announced %d.",
        filename, linenum, host, tmp, bits);
#line 94
    tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 94
    log("Warning: replace %d with %d in %s, line %d.", bits, tmp___0, filename, linenum);
  }
#line 97
  return (1);
}
}
#line 107 "hostfile.c"
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , Key *key ,
                                  Key *found , int *numret ) 
{ FILE *f ;
  char line[8192] ;
  int linenum ;
  u_int kbits ;
  char *cp ;
  char *cp2 ;
  HostStatus end_return ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 113
  linenum = 0;
#line 118
  debug3("check_host_in_hostfile: filename %s", filename);
#line 119
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 120
    fatal("no key to look up");
  }
#line 122
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 123
  if (! f) {
#line 124
    return (1);
  }
#line 131
  end_return = 1;
#line 134
  while (1) {
#line 134
    tmp___3 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 134
    if (! tmp___3) {
#line 134
      break;
    }
#line 135
    cp = line;
#line 136
    linenum ++;
#line 139
    while (1) {
#line 139
      if (! ((int )*cp == 32)) {
#line 139
        if (! ((int )*cp == 9)) {
#line 139
          break;
        }
      }
#line 139
      cp ++;
    }
#line 141
    if (! *cp) {
#line 142
      continue;
    } else {
#line 141
      if ((int )*cp == 35) {
#line 142
        continue;
      } else {
#line 141
        if ((int )*cp == 10) {
#line 142
          continue;
        }
      }
    }
#line 145
    cp2 = cp;
#line 145
    while (1) {
#line 145
      if (*cp2) {
#line 145
        if ((int )*cp2 != 32) {
#line 145
          if (! ((int )*cp2 != 9)) {
#line 145
            break;
          }
        } else {
#line 145
          break;
        }
      } else {
#line 145
        break;
      }
#line 145
      cp2 ++;
    }
#line 149
    tmp = match_hostname(host, (char const   *)cp, (unsigned int )(cp2 - cp));
#line 149
    if (tmp != 1) {
#line 150
      continue;
    }
#line 153
    cp = cp2;
#line 159
    tmp___0 = hostfile_read_key(& cp, & kbits, found);
#line 159
    if (! tmp___0) {
#line 160
      continue;
    }
#line 161
    tmp___1 = hostfile_check_key((int )kbits, found, host, filename, linenum);
#line 161
    if (! tmp___1) {
#line 162
      continue;
    }
#line 164
    if ((unsigned int )numret != (unsigned int )((void *)0)) {
#line 165
      *numret = linenum;
    }
#line 168
    tmp___2 = key_equal(key, found);
#line 168
    if (tmp___2) {
#line 170
      debug3("check_host_in_hostfile: match line %d", linenum);
#line 171
      fclose(f);
#line 172
      return (0);
    }
#line 179
    end_return = 2;
  }
#line 182
  fclose(f);
#line 188
  return (end_return);
}
}
#line 196 "hostfile.c"
int add_host_to_hostfile(char const   *filename , char const   *host , Key *key ) 
{ FILE *f ;
  int success ;
  int tmp ;

  {
#line 200
  success = 0;
#line 201
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 202
    return (1);
  }
#line 203
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"a");
#line 204
  if (! f) {
#line 205
    return (0);
  }
#line 206
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s ", host);
#line 207
  tmp = key_write(key, f);
#line 207
  if (tmp) {
#line 208
    success = 1;
  } else {
#line 210
    error("add_host_to_hostfile: saving key in %s failed", filename);
  }
#line 212
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"\n");
#line 213
  fclose(f);
#line 214
  return (success);
}
}
#line 1 "key.o"
#pragma merger(0,"./key.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 496 "/usr/include/openssl/bn.h"
extern char *BN_bn2dec(BIGNUM const   *a ) ;
#line 498
extern int BN_dec2bn(BIGNUM **a , char const   *str ) ;
#line 491 "/usr/include/openssl/evp.h"
extern int EVP_DigestUpdate(EVP_MD_CTX *ctx , void const   *d , size_t cnt ) ;
#line 498
extern int EVP_DigestInit(EVP_MD_CTX *ctx , EVP_MD const   *type ) ;
#line 499
extern int EVP_DigestFinal(EVP_MD_CTX *ctx , unsigned char *md , unsigned int *s ) ;
#line 215 "/usr/include/openssl/rsa.h"
extern RSA *RSA_new(void) ;
#line 221
extern RSA *RSA_generate_key(int bits , unsigned long e , void (*callback)(int  ,
                                                                           int  ,
                                                                           void * ) ,
                             void *cb_arg ) ;
#line 238
extern void RSA_free(RSA *r ) ;
#line 190 "/usr/include/openssl/dsa.h"
extern DSA *DSA_new(void) ;
#line 192
extern void DSA_free(DSA *r ) ;
#line 213
extern DSA *DSA_generate_parameters(int bits , unsigned char *seed , int seed_len ,
                                    int *counter_ret , unsigned long *h_ret , void (*callback)(int  ,
                                                                                               int  ,
                                                                                               void * ) ,
                                    void *cb_arg ) ;
#line 224
extern int DSA_generate_key(DSA *a ) ;
#line 57 "key.h"
char *key_fingerprint(Key *k , enum fp_type dgst_type , enum fp_rep dgst_rep ) ;
#line 63
Key *key_generate(int type , u_int bits ) ;
#line 64
Key *key_from_private(Key *k ) ;
#line 65
int key_type_from_name(char *name ) ;
#line 70
int key_names_valid2(char const   *names ) ;
#line 72
int key_sign(Key *key , u_char **sigp , int *lenp , u_char *data , int datalen ) ;
#line 78
int key_verify(Key *key , u_char *signature , int signaturelen , u_char *data , int datalen ) ;
#line 29 "ssh-dss.h"
int ssh_dss_sign(Key *key , u_char **sigp , int *lenp , u_char *data , int datalen ) ;
#line 35
int ssh_dss_verify(Key *key , u_char *signature , int signaturelen , u_char *data ,
                   int datalen ) ;
#line 29 "ssh-rsa.h"
int ssh_rsa_sign(Key *key , u_char **sigp , int *lenp , u_char *data , int datalen ) ;
#line 35
int ssh_rsa_verify(Key *key , u_char *signature , int signaturelen , u_char *data ,
                   int datalen ) ;
#line 29 "uuencode.h"
int uuencode(u_char *src , u_int srclength , char *target , size_t targsize ) ;
#line 30
int uudecode(char const   *src , u_char *target , size_t targsize ) ;
#line 49 "key.c"
Key *key_new(int type ) 
{ Key *k ;
  RSA *rsa ;
  DSA *dsa ;
  void *tmp ;

  {
#line 55
  tmp = xmalloc(sizeof(*k));
#line 55
  k = (Key *)tmp;
#line 56
  k->type = type;
#line 57
  k->dsa = (DSA *)((void *)0);
#line 58
  k->rsa = (RSA *)((void *)0);
#line 59
  switch (k->type) {
  case 0: 
  case 1: 
#line 62
  rsa = RSA_new();
#line 63
  rsa->n = BN_new();
#line 64
  rsa->e = BN_new();
#line 65
  k->rsa = rsa;
#line 66
  break;
  case 2: 
#line 68
  dsa = DSA_new();
#line 69
  dsa->p = BN_new();
#line 70
  dsa->q = BN_new();
#line 71
  dsa->g = BN_new();
#line 72
  dsa->pub_key = BN_new();
#line 73
  k->dsa = dsa;
#line 74
  break;
  case 3: 
#line 76
  break;
  default: 
#line 78
  fatal("key_new: bad key type %d", k->type);
#line 79
  break;
  }
#line 81
  return (k);
}
}
#line 83 "key.c"
Key *key_new_private(int type ) 
{ Key *k ;
  Key *tmp ;

  {
#line 86
  tmp = key_new(type);
#line 86
  k = tmp;
#line 87
  switch (k->type) {
  case 0: 
  case 1: 
#line 90
  (k->rsa)->d = BN_new();
#line 91
  (k->rsa)->iqmp = BN_new();
#line 92
  (k->rsa)->q = BN_new();
#line 93
  (k->rsa)->p = BN_new();
#line 94
  (k->rsa)->dmq1 = BN_new();
#line 95
  (k->rsa)->dmp1 = BN_new();
#line 96
  break;
  case 2: 
#line 98
  (k->dsa)->priv_key = BN_new();
#line 99
  break;
  case 3: 
#line 101
  break;
  default: ;
#line 103
  break;
  }
#line 105
  return (k);
}
}
#line 107 "key.c"
void key_free(Key *k ) 
{ 

  {
#line 110
  switch (k->type) {
  case 0: 
  case 1: 
#line 113
  if ((unsigned int )k->rsa != (unsigned int )((void *)0)) {
#line 114
    RSA_free(k->rsa);
  }
#line 115
  k->rsa = (RSA *)((void *)0);
#line 116
  break;
  case 2: 
#line 118
  if ((unsigned int )k->dsa != (unsigned int )((void *)0)) {
#line 119
    DSA_free(k->dsa);
  }
#line 120
  k->dsa = (DSA *)((void *)0);
#line 121
  break;
  case 3: 
#line 123
  break;
  default: 
#line 125
  fatal("key_free: bad key type %d", k->type);
#line 126
  break;
  }
#line 128
  xfree((void *)k);
#line 129
  return;
}
}
#line 130 "key.c"
int key_equal(Key *a , Key *b ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 133
  if ((unsigned int )a == (unsigned int )((void *)0)) {
#line 134
    return (0);
  } else {
#line 133
    if ((unsigned int )b == (unsigned int )((void *)0)) {
#line 134
      return (0);
    } else {
#line 133
      if (a->type != b->type) {
#line 134
        return (0);
      }
    }
  }
#line 135
  switch (a->type) {
  case 0: 
  case 1: 
#line 138
  if ((unsigned int )a->rsa != (unsigned int )((void *)0)) {
#line 138
    if ((unsigned int )b->rsa != (unsigned int )((void *)0)) {
#line 138
      tmp = BN_cmp((BIGNUM const   *)(a->rsa)->e, (BIGNUM const   *)(b->rsa)->e);
#line 138
      if (tmp == 0) {
#line 138
        tmp___0 = BN_cmp((BIGNUM const   *)(a->rsa)->n, (BIGNUM const   *)(b->rsa)->n);
#line 138
        if (tmp___0 == 0) {
#line 138
          tmp___1 = 1;
        } else {
#line 138
          tmp___1 = 0;
        }
      } else {
#line 138
        tmp___1 = 0;
      }
    } else {
#line 138
      tmp___1 = 0;
    }
  } else {
#line 138
    tmp___1 = 0;
  }
#line 138
  return (tmp___1);
#line 141
  break;
  case 2: 
#line 143
  if ((unsigned int )a->dsa != (unsigned int )((void *)0)) {
#line 143
    if ((unsigned int )b->dsa != (unsigned int )((void *)0)) {
#line 143
      tmp___2 = BN_cmp((BIGNUM const   *)(a->dsa)->p, (BIGNUM const   *)(b->dsa)->p);
#line 143
      if (tmp___2 == 0) {
#line 143
        tmp___3 = BN_cmp((BIGNUM const   *)(a->dsa)->q, (BIGNUM const   *)(b->dsa)->q);
#line 143
        if (tmp___3 == 0) {
#line 143
          tmp___4 = BN_cmp((BIGNUM const   *)(a->dsa)->g, (BIGNUM const   *)(b->dsa)->g);
#line 143
          if (tmp___4 == 0) {
#line 143
            tmp___5 = BN_cmp((BIGNUM const   *)(a->dsa)->pub_key, (BIGNUM const   *)(b->dsa)->pub_key);
#line 143
            if (tmp___5 == 0) {
#line 143
              tmp___6 = 1;
            } else {
#line 143
              tmp___6 = 0;
            }
          } else {
#line 143
            tmp___6 = 0;
          }
        } else {
#line 143
          tmp___6 = 0;
        }
      } else {
#line 143
        tmp___6 = 0;
      }
    } else {
#line 143
      tmp___6 = 0;
    }
  } else {
#line 143
    tmp___6 = 0;
  }
#line 143
  return (tmp___6);
#line 148
  break;
  default: 
#line 150
  fatal("key_equal: bad key type %d", a->type);
#line 151
  break;
  }
#line 153
  return (0);
}
}
#line 156 "key.c"
u_char *key_fingerprint_raw(Key *k , enum fp_type dgst_type , size_t *dgst_raw_length ) 
{ EVP_MD *md ;
  EVP_MD_CTX ctx ;
  u_char *blob ;
  u_char *retval ;
  int len ;
  int nlen ;
  int elen ;
  EVP_MD const   *tmp ;
  EVP_MD const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 159
  md = (EVP_MD *)((void *)0);
#line 161
  blob = (u_char *)((void *)0);
#line 162
  retval = (u_char *)((void *)0);
#line 163
  len = 0;
#line 166
  *dgst_raw_length = 0U;
#line 168
  switch ((int )dgst_type) {
  case 1: 
#line 170
  tmp = EVP_md5();
#line 170
  md = (EVP_MD *)tmp;
#line 171
  break;
  case 0: 
#line 173
  tmp___0 = EVP_sha1();
#line 173
  md = (EVP_MD *)tmp___0;
#line 174
  break;
  default: 
#line 176
  fatal("key_fingerprint_raw: bad digest type %d", dgst_type);
  }
#line 179
  switch (k->type) {
  case 0: 
#line 181
  tmp___1 = BN_num_bits((BIGNUM const   *)(k->rsa)->n);
#line 181
  nlen = (tmp___1 + 7) / 8;
#line 182
  tmp___2 = BN_num_bits((BIGNUM const   *)(k->rsa)->e);
#line 182
  elen = (tmp___2 + 7) / 8;
#line 183
  len = nlen + elen;
#line 184
  tmp___3 = xmalloc((unsigned int )len);
#line 184
  blob = (u_char *)tmp___3;
#line 185
  BN_bn2bin((BIGNUM const   *)(k->rsa)->n, blob);
#line 186
  BN_bn2bin((BIGNUM const   *)(k->rsa)->e, blob + nlen);
#line 187
  break;
  case 2: 
  case 1: 
#line 190
  key_to_blob(k, & blob, (u_int *)(& len));
#line 191
  break;
  case 3: 
#line 193
  return (retval);
#line 194
  break;
  default: 
#line 196
  fatal("key_fingerprint_raw: bad key type %d", k->type);
#line 197
  break;
  }
#line 199
  if ((unsigned int )blob != (unsigned int )((void *)0)) {
#line 200
    tmp___4 = xmalloc(64U);
#line 200
    retval = (u_char *)tmp___4;
#line 201
    EVP_DigestInit(& ctx, (EVP_MD const   *)md);
#line 202
    EVP_DigestUpdate(& ctx, (void const   *)blob, (unsigned int )len);
#line 203
    EVP_DigestFinal(& ctx, retval, (unsigned int *)((void *)0));
#line 204
    *dgst_raw_length = (unsigned int )md->md_size;
#line 205
    memset((void *)blob, 0, (unsigned int )len);
#line 206
    xfree((void *)blob);
  } else {
#line 208
    fatal("key_fingerprint_raw: blob is null");
  }
#line 210
  return (retval);
}
}
#line 213 "key.c"
char *key_fingerprint_hex(u_char *dgst_raw , size_t dgst_raw_len ) 
{ char *retval ;
  int i ;
  void *tmp ;
  char hex[4] ;

  {
#line 219
  tmp = xmalloc(dgst_raw_len * 3U + 1U);
#line 219
  retval = (char *)tmp;
#line 220
  *(retval + 0) = (char )'\000';
#line 221
  i = 0;
#line 221
  while ((size_t )i < dgst_raw_len) {
#line 223
    snprintf((char * __restrict  )(hex), sizeof(hex), (char const   * __restrict  )"%02x:",
             *(dgst_raw + i));
#line 224
    strlcat(retval, (char const   *)(hex), dgst_raw_len * 3U);
#line 221
    i ++;
  }
#line 226
  *(retval + (dgst_raw_len * 3U - 1U)) = (char )'\000';
#line 227
  return (retval);
}
}
#line 230 "key.c"
char *key_fingerprint_bubblebabble(u_char *dgst_raw , size_t dgst_raw_len ) 
{ char vowels[6] ;
  char consonants[17] ;
  u_int i ;
  u_int j ;
  u_int rounds ;
  u_int seed ;
  char *retval ;
  void *tmp ;
  u_int tmp___0 ;
  u_int idx0 ;
  u_int idx1 ;
  u_int idx2 ;
  u_int idx3 ;
  u_int idx4 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  u_int tmp___6 ;
  u_int tmp___7 ;
  u_int tmp___8 ;
  u_int tmp___9 ;
  u_int tmp___10 ;
  u_int tmp___11 ;

  {
#line 233
  vowels[0] = (char )'a';
#line 233
  vowels[1] = (char )'e';
#line 233
  vowels[2] = (char )'i';
#line 233
  vowels[3] = (char )'o';
#line 233
  vowels[4] = (char )'u';
#line 233
  vowels[5] = (char )'y';
#line 234
  consonants[0] = (char )'b';
#line 234
  consonants[1] = (char )'c';
#line 234
  consonants[2] = (char )'d';
#line 234
  consonants[3] = (char )'f';
#line 234
  consonants[4] = (char )'g';
#line 234
  consonants[5] = (char )'h';
#line 234
  consonants[6] = (char )'k';
#line 234
  consonants[7] = (char )'l';
#line 234
  consonants[8] = (char )'m';
#line 234
  consonants[9] = (char )'n';
#line 234
  consonants[10] = (char )'p';
#line 234
  consonants[11] = (char )'r';
#line 234
  consonants[12] = (char )'s';
#line 234
  consonants[13] = (char )'t';
#line 234
  consonants[14] = (char )'v';
#line 234
  consonants[15] = (char )'z';
#line 234
  consonants[16] = (char )'x';
#line 236
  j = (u_int )0;
#line 236
  seed = (u_int )1;
#line 239
  rounds = dgst_raw_len / 2U + 1U;
#line 240
  tmp = xmalloc(sizeof(char ) * (rounds * 6U));
#line 240
  retval = (char *)tmp;
#line 241
  tmp___0 = j;
#line 241
  j ++;
#line 241
  *(retval + tmp___0) = (char )'x';
#line 242
  i = 0U;
#line 242
  while (i < rounds) {
#line 244
    if (i + 1U < rounds) {
      goto _L;
    } else {
#line 244
      if (dgst_raw_len % 2U != 0U) {
        _L: /* CIL Label */ 
#line 245
        idx0 = ((((unsigned int )*(dgst_raw + 2U * i) >> 6) & 3U) + seed) % 6U;
#line 247
        idx1 = ((unsigned int )*(dgst_raw + 2U * i) >> 2) & 15U;
#line 248
        idx2 = (((unsigned int )*(dgst_raw + 2U * i) & 3U) + seed / 6U) % 6U;
#line 250
        tmp___1 = j;
#line 250
        j ++;
#line 250
        *(retval + tmp___1) = vowels[idx0];
#line 251
        tmp___2 = j;
#line 251
        j ++;
#line 251
        *(retval + tmp___2) = consonants[idx1];
#line 252
        tmp___3 = j;
#line 252
        j ++;
#line 252
        *(retval + tmp___3) = vowels[idx2];
#line 253
        if (i + 1U < rounds) {
#line 254
          idx3 = ((unsigned int )*(dgst_raw + (2U * i + 1U)) >> 4) & 15U;
#line 255
          idx4 = (unsigned int )*(dgst_raw + (2U * i + 1U)) & 15U;
#line 256
          tmp___4 = j;
#line 256
          j ++;
#line 256
          *(retval + tmp___4) = consonants[idx3];
#line 257
          tmp___5 = j;
#line 257
          j ++;
#line 257
          *(retval + tmp___5) = (char )'-';
#line 258
          tmp___6 = j;
#line 258
          j ++;
#line 258
          *(retval + tmp___6) = consonants[idx4];
#line 259
          seed = (seed * 5U + ((unsigned int )*(dgst_raw + 2U * i) * 7U + (unsigned int )*(dgst_raw + (2U * i + 1U)))) % 36U;
        }
      } else {
#line 264
        idx0 = seed % 6U;
#line 265
        idx1 = 16U;
#line 266
        idx2 = seed / 6U;
#line 267
        tmp___7 = j;
#line 267
        j ++;
#line 267
        *(retval + tmp___7) = vowels[idx0];
#line 268
        tmp___8 = j;
#line 268
        j ++;
#line 268
        *(retval + tmp___8) = consonants[idx1];
#line 269
        tmp___9 = j;
#line 269
        j ++;
#line 269
        *(retval + tmp___9) = vowels[idx2];
      }
    }
#line 242
    i ++;
  }
#line 272
  tmp___10 = j;
#line 272
  j ++;
#line 272
  *(retval + tmp___10) = (char )'x';
#line 273
  tmp___11 = j;
#line 273
  j ++;
#line 273
  *(retval + tmp___11) = (char )'\000';
#line 274
  return (retval);
}
}
#line 277 "key.c"
char *key_fingerprint(Key *k , enum fp_type dgst_type , enum fp_rep dgst_rep ) 
{ char *retval ;
  u_char *dgst_raw ;
  size_t dgst_raw_len ;

  {
#line 280
  retval = (char *)((void *)0);
#line 284
  dgst_raw = key_fingerprint_raw(k, dgst_type, & dgst_raw_len);
#line 285
  if (! dgst_raw) {
#line 286
    fatal("key_fingerprint: null from key_fingerprint_raw()");
  }
#line 287
  switch ((int )dgst_rep) {
  case 0: 
#line 289
  retval = key_fingerprint_hex(dgst_raw, dgst_raw_len);
#line 290
  break;
  case 1: 
#line 292
  retval = key_fingerprint_bubblebabble(dgst_raw, dgst_raw_len);
#line 293
  break;
  default: 
#line 295
  fatal("key_fingerprint_ex: bad digest representation %d", dgst_rep);
#line 297
  break;
  }
#line 299
  memset((void *)dgst_raw, 0, dgst_raw_len);
#line 300
  xfree((void *)dgst_raw);
#line 301
  return (retval);
}
}
#line 311 "key.c"
int read_bignum(char **cpp , BIGNUM *value ) 
{ char *cp ;
  int old ;
  int tmp ;

  {
#line 314
  cp = *cpp;
#line 318
  while (1) {
#line 318
    if (! ((int )*cp == 32)) {
#line 318
      if (! ((int )*cp == 9)) {
#line 318
        break;
      }
    }
#line 318
    cp ++;
  }
#line 322
  if ((int )*cp < 48) {
#line 323
    return (0);
  } else {
#line 322
    if ((int )*cp > 57) {
#line 323
      return (0);
    }
  }
#line 326
  *cpp = cp;
#line 329
  while (1) {
#line 329
    if ((int )*cp >= 48) {
#line 329
      if (! ((int )*cp <= 57)) {
#line 329
        break;
      }
    } else {
#line 329
      break;
    }
#line 329
    cp ++;
  }
#line 333
  old = (int )*cp;
#line 334
  *cp = (char)0;
#line 337
  tmp = BN_dec2bn(& value, (char const   *)*cpp);
#line 337
  if (tmp == 0) {
#line 338
    return (0);
  }
#line 341
  *cp = (char )old;
#line 344
  *cpp = cp;
#line 345
  return (1);
}
}
#line 347 "key.c"
int write_bignum(FILE *f , BIGNUM *num ) 
{ char *buf___2 ;
  char *tmp ;

  {
#line 350
  tmp = BN_bn2dec((BIGNUM const   *)num);
#line 350
  buf___2 = tmp;
#line 351
  if ((unsigned int )buf___2 == (unsigned int )((void *)0)) {
#line 352
    error("write_bignum: BN_bn2dec() failed");
#line 353
    return (0);
  }
#line 355
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )" %s", buf___2);
#line 356
  xfree((void *)buf___2);
#line 357
  return (1);
}
}
#line 361 "key.c"
int key_read(Key *ret , char **cpp ) 
{ Key *k ;
  int success ;
  char *cp ;
  char *space ;
  int len ;
  int n___0 ;
  int type ;
  u_int bits ;
  u_char *blob ;
  int tmp ;
  int tmp___0 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
#line 365
  success = -1;
#line 371
  cp = *cpp;
#line 373
  switch (ret->type) {
  case 0: 
#line 376
  if ((int )*cp < 48) {
#line 377
    return (-1);
  } else {
#line 376
    if ((int )*cp > 57) {
#line 377
      return (-1);
    }
  }
#line 378
  bits = 0U;
#line 378
  while (1) {
#line 378
    if ((int )*cp >= 48) {
#line 378
      if (! ((int )*cp <= 57)) {
#line 378
        break;
      }
    } else {
#line 378
      break;
    }
#line 379
    bits = (10U * bits + (u_int )*cp) - 48U;
#line 378
    cp ++;
  }
#line 380
  if (bits == 0U) {
#line 381
    return (-1);
  }
#line 382
  *cpp = cp;
#line 384
  tmp = read_bignum(cpp, (ret->rsa)->e);
#line 384
  if (! tmp) {
#line 385
    return (-1);
  }
#line 386
  tmp___0 = read_bignum(cpp, (ret->rsa)->n);
#line 386
  if (! tmp___0) {
#line 387
    return (-1);
  }
#line 388
  success = 1;
#line 389
  break;
  case 3: 
  case 1: 
  case 2: 
#line 393
  tmp___2 = __builtin_strchr(cp, ' ');
#line 393
  space = tmp___2;
#line 394
  if ((unsigned int )space == (unsigned int )((void *)0)) {
#line 395
    debug3("key_read: no space");
#line 396
    return (-1);
  }
#line 398
  *space = (char )'\000';
#line 399
  type = key_type_from_name(cp);
#line 400
  *space = (char )' ';
#line 401
  if (type == 3) {
#line 402
    debug3("key_read: no key found");
#line 403
    return (-1);
  }
#line 405
  cp = space + 1;
#line 406
  if ((int )*cp == 0) {
#line 407
    debug3("key_read: short string");
#line 408
    return (-1);
  }
#line 410
  if (ret->type == 3) {
#line 411
    ret->type = type;
  } else {
#line 412
    if (ret->type != type) {
#line 414
      debug3("key_read: type mismatch");
#line 415
      return (0);
    }
  }
#line 417
  tmp___3 = strlen((char const   *)cp);
#line 417
  len = (int )(2U * tmp___3);
#line 418
  tmp___4 = xmalloc((unsigned int )len);
#line 418
  blob = (u_char *)tmp___4;
#line 419
  n___0 = uudecode((char const   *)cp, blob, (unsigned int )len);
#line 420
  if (n___0 < 0) {
#line 421
    error("key_read: uudecode %s failed", cp);
#line 422
    return (-1);
  }
#line 424
  k = key_from_blob((char *)blob, n___0);
#line 425
  if ((unsigned int )k == (unsigned int )((void *)0)) {
#line 426
    error("key_read: key_from_blob %s failed", cp);
#line 427
    return (-1);
  }
#line 429
  xfree((void *)blob);
#line 430
  if (k->type != type) {
#line 431
    error("key_read: type mismatch: encoding error");
#line 432
    key_free(k);
#line 433
    return (-1);
  }
#line 436
  if (ret->type == 1) {
#line 437
    if ((unsigned int )ret->rsa != (unsigned int )((void *)0)) {
#line 438
      RSA_free(ret->rsa);
    }
#line 439
    ret->rsa = k->rsa;
#line 440
    k->rsa = (RSA *)((void *)0);
#line 441
    success = 1;
  } else {
#line 446
    if ((unsigned int )ret->dsa != (unsigned int )((void *)0)) {
#line 447
      DSA_free(ret->dsa);
    }
#line 448
    ret->dsa = k->dsa;
#line 449
    k->dsa = (DSA *)((void *)0);
#line 450
    success = 1;
  }
#line 456
  if (success != 1) {
#line 457
    break;
  }
#line 458
  key_free(k);
#line 460
  while (1) {
#line 460
    if (! ((int )*cp == 32)) {
#line 460
      if (! ((int )*cp == 9)) {
#line 460
        break;
      }
    }
#line 461
    cp ++;
  }
#line 462
  while (1) {
#line 462
    if ((int )*cp != 0) {
#line 462
      if ((int )*cp != 32) {
#line 462
        if (! ((int )*cp != 9)) {
#line 462
          break;
        }
      } else {
#line 462
        break;
      }
    } else {
#line 462
      break;
    }
#line 463
    cp ++;
  }
#line 464
  *cpp = cp;
#line 465
  break;
  default: 
#line 467
  fatal("key_read: bad key type: %d", ret->type);
#line 468
  break;
  }
#line 470
  return (success);
}
}
#line 472 "key.c"
int key_write(Key *key , FILE *f ) 
{ int success ;
  u_int bits ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int len ;
  int n___0 ;
  u_char *blob ;
  u_char *uu ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
#line 475
  success = 0;
#line 476
  bits = (u_int )0;
#line 478
  if (key->type == 0) {
#line 478
    if ((unsigned int )key->rsa != (unsigned int )((void *)0)) {
#line 480
      tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 480
      bits = (unsigned int )tmp;
#line 481
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%u", bits);
#line 482
      tmp___0 = write_bignum(f, (key->rsa)->e);
#line 482
      if (tmp___0) {
#line 482
        tmp___1 = write_bignum(f, (key->rsa)->n);
#line 482
        if (tmp___1) {
#line 484
          success = 1;
        } else {
#line 486
          error("key_write: failed for RSA key");
        }
      } else {
#line 486
        error("key_write: failed for RSA key");
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 488
    if (key->type == 2) {
#line 488
      if ((unsigned int )key->dsa != (unsigned int )((void *)0)) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 488
      if (key->type == 1) {
#line 488
        if ((unsigned int )key->rsa != (unsigned int )((void *)0)) {
          _L: /* CIL Label */ 
#line 492
          key_to_blob(key, & blob, (u_int *)(& len));
#line 493
          tmp___2 = xmalloc((unsigned int )(2 * len));
#line 493
          uu = (u_char *)tmp___2;
#line 494
          n___0 = uuencode(blob, (unsigned int )len, (char *)uu, (unsigned int )(2 * len));
#line 495
          if (n___0 > 0) {
#line 496
            tmp___3 = key_ssh_name(key);
#line 496
            fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s",
                    tmp___3, uu);
#line 497
            success = 1;
          }
#line 499
          xfree((void *)blob);
#line 500
          xfree((void *)uu);
        }
      }
    }
  }
#line 502
  return (success);
}
}
#line 504 "key.c"
char *key_type(Key *k ) 
{ 

  {
#line 507
  switch (k->type) {
  case 0: 
#line 509
  return ((char *)"RSA1");
#line 510
  break;
  case 1: 
#line 512
  return ((char *)"RSA");
#line 513
  break;
  case 2: 
#line 515
  return ((char *)"DSA");
#line 516
  break;
  }
#line 518
  return ((char *)"unknown");
}
}
#line 520 "key.c"
char *key_ssh_name(Key *k ) 
{ 

  {
#line 523
  switch (k->type) {
  case 1: 
#line 525
  return ((char *)"ssh-rsa");
#line 526
  break;
  case 2: 
#line 528
  return ((char *)"ssh-dss");
#line 529
  break;
  }
#line 531
  return ((char *)"ssh-unknown");
}
}
#line 533 "key.c"
u_int key_size(Key *k ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 535
  switch (k->type) {
  case 0: 
  case 1: 
#line 538
  tmp = BN_num_bits((BIGNUM const   *)(k->rsa)->n);
#line 538
  return ((unsigned int )tmp);
#line 539
  break;
  case 2: 
#line 541
  tmp___0 = BN_num_bits((BIGNUM const   *)(k->dsa)->p);
#line 541
  return ((unsigned int )tmp___0);
#line 542
  break;
  }
#line 544
  return (0U);
}
}
#line 547 "key.c"
RSA *rsa_generate_private_key(u_int bits ) 
{ RSA *private ;

  {
#line 551
  private = RSA_generate_key((int )bits, 35UL, (void (*)(int  , int  , void * ))((void *)0),
                             (void *)0);
#line 552
  if ((unsigned int )private == (unsigned int )((void *)0)) {
#line 553
    fatal("rsa_generate_private_key: key generation failed.");
  }
#line 554
  return (private);
}
}
#line 557 "key.c"
DSA *dsa_generate_private_key(u_int bits ) 
{ DSA *private ;
  DSA *tmp ;
  int tmp___0 ;

  {
#line 560
  tmp = DSA_generate_parameters((int )bits, (unsigned char *)((void *)0), 0, (int *)((void *)0),
                                (unsigned long *)((void *)0), (void (*)(int  , int  ,
                                                                        void * ))((void *)0),
                                (void *)0);
#line 560
  private = tmp;
#line 561
  if ((unsigned int )private == (unsigned int )((void *)0)) {
#line 562
    fatal("dsa_generate_private_key: DSA_generate_parameters failed");
  }
#line 563
  tmp___0 = DSA_generate_key(private);
#line 563
  if (! tmp___0) {
#line 564
    fatal("dsa_generate_private_key: DSA_generate_key failed.");
  }
#line 565
  if ((unsigned int )private == (unsigned int )((void *)0)) {
#line 566
    fatal("dsa_generate_private_key: NULL.");
  }
#line 567
  return (private);
}
}
#line 570 "key.c"
Key *key_generate(int type , u_int bits ) 
{ Key *k ;
  Key *tmp ;

  {
#line 573
  tmp = key_new(3);
#line 573
  k = tmp;
#line 574
  switch (type) {
  case 2: 
#line 576
  k->dsa = dsa_generate_private_key(bits);
#line 577
  break;
  case 1: 
  case 0: 
#line 580
  k->rsa = rsa_generate_private_key(bits);
#line 581
  break;
  default: 
#line 583
  fatal("key_generate: unknown type %d", type);
  }
#line 585
  k->type = type;
#line 586
  return (k);
}
}
#line 589 "key.c"
Key *key_from_private(Key *k ) 
{ Key *n___0 ;

  {
#line 592
  n___0 = (Key *)((void *)0);
#line 593
  switch (k->type) {
  case 2: 
#line 595
  n___0 = key_new(k->type);
#line 596
  BN_copy((n___0->dsa)->p, (BIGNUM const   *)(k->dsa)->p);
#line 597
  BN_copy((n___0->dsa)->q, (BIGNUM const   *)(k->dsa)->q);
#line 598
  BN_copy((n___0->dsa)->g, (BIGNUM const   *)(k->dsa)->g);
#line 599
  BN_copy((n___0->dsa)->pub_key, (BIGNUM const   *)(k->dsa)->pub_key);
#line 600
  break;
  case 1: 
  case 0: 
#line 603
  n___0 = key_new(k->type);
#line 604
  BN_copy((n___0->rsa)->n, (BIGNUM const   *)(k->rsa)->n);
#line 605
  BN_copy((n___0->rsa)->e, (BIGNUM const   *)(k->rsa)->e);
#line 606
  break;
  default: 
#line 608
  fatal("key_from_private: unknown type %d", k->type);
#line 609
  break;
  }
#line 611
  return (n___0);
}
}
#line 614 "key.c"
int key_type_from_name(char *name ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;

  {
#line 617
  if (0) {
#line 617
    __s1_len___3 = strlen((char const   *)name);
#line 617
    __s2_len___3 = strlen("rsa1");
#line 617
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___8;
    } else {
#line 617
      if (__s1_len___3 >= 4U) {
        _L___8: /* CIL Label */ 
#line 617
        if (! ((unsigned int )((void const   *)("rsa1" + 1)) - (unsigned int )((void const   *)"rsa1") == 1U)) {
#line 617
          tmp___48 = 1;
        } else {
#line 617
          if (__s2_len___3 >= 4U) {
#line 617
            tmp___48 = 1;
          } else {
#line 617
            tmp___48 = 0;
          }
        }
      } else {
#line 617
        tmp___48 = 0;
      }
    }
#line 617
    if (tmp___48) {
#line 617
      tmp___44 = __builtin_strcmp((char const   *)name, "rsa1");
    } else {
#line 617
      tmp___47 = __builtin_strcmp((char const   *)name, "rsa1");
#line 617
      tmp___44 = tmp___47;
    }
  } else {
#line 617
    tmp___47 = __builtin_strcmp((char const   *)name, "rsa1");
#line 617
    tmp___44 = tmp___47;
  }
#line 617
  if (tmp___44 == 0) {
#line 618
    return (0);
  } else {
#line 619
    if (0) {
#line 619
      __s1_len___2 = strlen((char const   *)name);
#line 619
      __s2_len___2 = strlen("rsa");
#line 619
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___6;
      } else {
#line 619
        if (__s1_len___2 >= 4U) {
          _L___6: /* CIL Label */ 
#line 619
          if (! ((unsigned int )((void const   *)("rsa" + 1)) - (unsigned int )((void const   *)"rsa") == 1U)) {
#line 619
            tmp___38 = 1;
          } else {
#line 619
            if (__s2_len___2 >= 4U) {
#line 619
              tmp___38 = 1;
            } else {
#line 619
              tmp___38 = 0;
            }
          }
        } else {
#line 619
          tmp___38 = 0;
        }
      }
#line 619
      if (tmp___38) {
#line 619
        tmp___34 = __builtin_strcmp((char const   *)name, "rsa");
      } else {
#line 619
        tmp___37 = __builtin_strcmp((char const   *)name, "rsa");
#line 619
        tmp___34 = tmp___37;
      }
    } else {
#line 619
      tmp___37 = __builtin_strcmp((char const   *)name, "rsa");
#line 619
      tmp___34 = tmp___37;
    }
#line 619
    if (tmp___34 == 0) {
#line 620
      return (1);
    } else {
#line 621
      if (0) {
#line 621
        __s1_len___1 = strlen((char const   *)name);
#line 621
        __s2_len___1 = strlen("dsa");
#line 621
        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
          goto _L___4;
        } else {
#line 621
          if (__s1_len___1 >= 4U) {
            _L___4: /* CIL Label */ 
#line 621
            if (! ((unsigned int )((void const   *)("dsa" + 1)) - (unsigned int )((void const   *)"dsa") == 1U)) {
#line 621
              tmp___28 = 1;
            } else {
#line 621
              if (__s2_len___1 >= 4U) {
#line 621
                tmp___28 = 1;
              } else {
#line 621
                tmp___28 = 0;
              }
            }
          } else {
#line 621
            tmp___28 = 0;
          }
        }
#line 621
        if (tmp___28) {
#line 621
          tmp___24 = __builtin_strcmp((char const   *)name, "dsa");
        } else {
#line 621
          tmp___27 = __builtin_strcmp((char const   *)name, "dsa");
#line 621
          tmp___24 = tmp___27;
        }
      } else {
#line 621
        tmp___27 = __builtin_strcmp((char const   *)name, "dsa");
#line 621
        tmp___24 = tmp___27;
      }
#line 621
      if (tmp___24 == 0) {
#line 622
        return (2);
      } else {
#line 623
        if (0) {
#line 623
          __s1_len___0 = strlen((char const   *)name);
#line 623
          __s2_len___0 = strlen("ssh-rsa");
#line 623
          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
            goto _L___2;
          } else {
#line 623
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 623
              if (! ((unsigned int )((void const   *)("ssh-rsa" + 1)) - (unsigned int )((void const   *)"ssh-rsa") == 1U)) {
#line 623
                tmp___18 = 1;
              } else {
#line 623
                if (__s2_len___0 >= 4U) {
#line 623
                  tmp___18 = 1;
                } else {
#line 623
                  tmp___18 = 0;
                }
              }
            } else {
#line 623
              tmp___18 = 0;
            }
          }
#line 623
          if (tmp___18) {
#line 623
            tmp___14 = __builtin_strcmp((char const   *)name, "ssh-rsa");
          } else {
#line 623
            tmp___17 = __builtin_strcmp((char const   *)name, "ssh-rsa");
#line 623
            tmp___14 = tmp___17;
          }
        } else {
#line 623
          tmp___17 = __builtin_strcmp((char const   *)name, "ssh-rsa");
#line 623
          tmp___14 = tmp___17;
        }
#line 623
        if (tmp___14 == 0) {
#line 624
          return (1);
        } else {
#line 625
          if (0) {
#line 625
            __s1_len = strlen((char const   *)name);
#line 625
            __s2_len = strlen("ssh-dss");
#line 625
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
              goto _L___0;
            } else {
#line 625
              if (__s1_len >= 4U) {
                _L___0: /* CIL Label */ 
#line 625
                if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
#line 625
                  tmp___8 = 1;
                } else {
#line 625
                  if (__s2_len >= 4U) {
#line 625
                    tmp___8 = 1;
                  } else {
#line 625
                    tmp___8 = 0;
                  }
                }
              } else {
#line 625
                tmp___8 = 0;
              }
            }
#line 625
            if (tmp___8) {
#line 625
              tmp___4 = __builtin_strcmp((char const   *)name, "ssh-dss");
            } else {
#line 625
              tmp___7 = __builtin_strcmp((char const   *)name, "ssh-dss");
#line 625
              tmp___4 = tmp___7;
            }
          } else {
#line 625
            tmp___7 = __builtin_strcmp((char const   *)name, "ssh-dss");
#line 625
            tmp___4 = tmp___7;
          }
#line 625
          if (tmp___4 == 0) {
#line 626
            return (2);
          }
        }
      }
    }
  }
#line 628
  debug2("key_type_from_name: unknown key type \'%s\'", name);
#line 629
  return (3);
}
}
#line 632 "key.c"
int key_names_valid2(char const   *names ) 
{ char *s ;
  char *cp ;
  char *p ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___24 ;
  char *tmp___40 ;
  int tmp___41 ;

  {
#line 637
  if ((unsigned int )names == (unsigned int )((void *)0)) {
#line 638
    return (0);
  } else {
#line 637
    if (0) {
#line 637
      __s1_len = strlen(names);
#line 637
      __s2_len = strlen("");
#line 637
      if (! ((unsigned int )((void const   *)(names + 1)) - (unsigned int )((void const   *)names) == 1U)) {
        goto _L___0;
      } else {
#line 637
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 637
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 637
            tmp___8 = 1;
          } else {
#line 637
            if (__s2_len >= 4U) {
#line 637
              tmp___8 = 1;
            } else {
#line 637
              tmp___8 = 0;
            }
          }
        } else {
#line 637
          tmp___8 = 0;
        }
      }
#line 637
      if (tmp___8) {
#line 637
        tmp___4 = __builtin_strcmp(names, "");
      } else {
#line 637
        tmp___7 = __builtin_strcmp(names, "");
#line 637
        tmp___4 = tmp___7;
      }
    } else {
#line 637
      tmp___7 = __builtin_strcmp(names, "");
#line 637
      tmp___4 = tmp___7;
    }
#line 637
    if (tmp___4 == 0) {
#line 638
      return (0);
    }
  }
#line 639
  cp = xstrdup(names);
#line 639
  s = cp;
#line 640
  tmp___24 = __strsep_g(& cp, ",");
#line 640
  p = tmp___24;
#line 640
  while (1) {
#line 640
    if (p) {
#line 640
      if (! ((int )*p != 0)) {
#line 640
        break;
      }
    } else {
#line 640
      break;
    }
#line 642
    tmp___41 = key_type_from_name(p);
#line 642
    switch (tmp___41) {
    case 0: 
    case 3: 
#line 645
    xfree((void *)s);
#line 646
    return (0);
    }
#line 641
    tmp___40 = __strsep_g(& cp, ",");
#line 641
    p = tmp___40;
  }
#line 649
  debug3("key names ok: [%s]", names);
#line 650
  xfree((void *)s);
#line 651
  return (1);
}
}
#line 654 "key.c"
Key *key_from_blob(char *blob , int blen ) 
{ Buffer b ;
  char *ktype ;
  int rlen ;
  int type ;
  Key *key ;
  u_int tmp ;

  {
#line 660
  key = (Key *)((void *)0);
#line 665
  buffer_init(& b);
#line 666
  buffer_append(& b, (char const   *)blob, (unsigned int )blen);
#line 667
  ktype = buffer_get_string(& b, (u_int *)((void *)0));
#line 668
  type = key_type_from_name(ktype);
#line 670
  switch (type) {
  case 1: 
#line 672
  key = key_new(type);
#line 673
  buffer_get_bignum2(& b, (key->rsa)->e);
#line 674
  buffer_get_bignum2(& b, (key->rsa)->n);
#line 678
  break;
  case 2: 
#line 680
  key = key_new(type);
#line 681
  buffer_get_bignum2(& b, (key->dsa)->p);
#line 682
  buffer_get_bignum2(& b, (key->dsa)->q);
#line 683
  buffer_get_bignum2(& b, (key->dsa)->g);
#line 684
  buffer_get_bignum2(& b, (key->dsa)->pub_key);
#line 688
  break;
  case 3: 
#line 690
  key = key_new(type);
#line 691
  break;
  default: 
#line 693
  error("key_from_blob: cannot handle type %s", ktype);
#line 694
  break;
  }
#line 696
  tmp = buffer_len(& b);
#line 696
  rlen = (int )tmp;
#line 697
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 697
    if (rlen != 0) {
#line 698
      error("key_from_blob: remaining bytes in key blob %d", rlen);
    }
  }
#line 699
  xfree((void *)ktype);
#line 700
  buffer_free(& b);
#line 701
  return (key);
}
}
#line 704 "key.c"
int key_to_blob(Key *key , u_char **blobp , u_int *lenp ) 
{ Buffer b ;
  int len ;
  u_char *buf___2 ;
  char *tmp ;
  char *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 711
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 712
    error("key_to_blob: key == NULL");
#line 713
    return (0);
  }
#line 715
  buffer_init(& b);
#line 716
  switch (key->type) {
  case 2: 
#line 718
  tmp = key_ssh_name(key);
#line 718
  buffer_put_cstring(& b, (char const   *)tmp);
#line 719
  buffer_put_bignum2(& b, (key->dsa)->p);
#line 720
  buffer_put_bignum2(& b, (key->dsa)->q);
#line 721
  buffer_put_bignum2(& b, (key->dsa)->g);
#line 722
  buffer_put_bignum2(& b, (key->dsa)->pub_key);
#line 723
  break;
  case 1: 
#line 725
  tmp___0 = key_ssh_name(key);
#line 725
  buffer_put_cstring(& b, (char const   *)tmp___0);
#line 726
  buffer_put_bignum2(& b, (key->rsa)->e);
#line 727
  buffer_put_bignum2(& b, (key->rsa)->n);
#line 728
  break;
  default: 
#line 730
  error("key_to_blob: illegal key type %d", key->type);
#line 731
  break;
  }
#line 733
  tmp___1 = buffer_len(& b);
#line 733
  len = (int )tmp___1;
#line 734
  tmp___2 = xmalloc((unsigned int )len);
#line 734
  buf___2 = (u_char *)tmp___2;
#line 735
  tmp___3 = buffer_ptr(& b);
#line 735
  memcpy((void * __restrict  )buf___2, (void const   * __restrict  )tmp___3, (unsigned int )len);
#line 736
  tmp___4 = buffer_ptr(& b);
#line 736
  memset((void *)tmp___4, 0, (unsigned int )len);
#line 737
  buffer_free(& b);
#line 738
  if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 739
    *lenp = (unsigned int )len;
  }
#line 740
  if ((unsigned int )blobp != (unsigned int )((void *)0)) {
#line 741
    *blobp = buf___2;
  }
#line 742
  return (len);
}
}
#line 745 "key.c"
int key_sign(Key *key , u_char **sigp , int *lenp , u_char *data , int datalen ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 751
  switch (key->type) {
  case 2: 
#line 753
  tmp = ssh_dss_sign(key, sigp, lenp, data, datalen);
#line 753
  return (tmp);
#line 754
  break;
  case 1: 
#line 756
  tmp___0 = ssh_rsa_sign(key, sigp, lenp, data, datalen);
#line 756
  return (tmp___0);
#line 757
  break;
  default: 
#line 759
  error("key_sign: illegal key type %d", key->type);
#line 760
  return (-1);
#line 761
  break;
  }
#line 763
  return (0);
}
}
#line 765 "key.c"
int key_verify(Key *key , u_char *signature , int signaturelen , u_char *data , int datalen ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 771
  switch (key->type) {
  case 2: 
#line 773
  tmp = ssh_dss_verify(key, signature, signaturelen, data, datalen);
#line 773
  return (tmp);
#line 774
  break;
  case 1: 
#line 776
  tmp___0 = ssh_rsa_verify(key, signature, signaturelen, data, datalen);
#line 776
  return (tmp___0);
#line 777
  break;
  default: 
#line 779
  error("key_verify: illegal key type %d", key->type);
#line 780
  return (-1);
#line 781
  break;
  }
#line 783
  return (0);
}
}
#line 1 "kex.o"
#pragma merger(0,"./kex.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 89 "packet.h"
void packet_put_raw(char const   *buf___2 , u_int len ) ;
#line 104
void packet_read_expect(int *payload_len_ptr , int expected_type ) ;
#line 123
u_int packet_get_char(void) ;
#line 134
char *packet_get_raw(int *length_ptr ) ;
#line 114 "kex.h"
Kex *kex_setup(char **proposal ) ;
#line 115
void kex_finish(Kex *kex ) ;
#line 117
void kex_send_kexinit(Kex *kex ) ;
#line 118
void kex_input_kexinit(int type , int plen , void *ctxt ) ;
#line 119
void kex_derive_keys(Kex *kex , u_char *hash , BIGNUM *shared_secret ) ;
#line 121
void kexdh(Kex *kex ) ;
#line 122
void kexgex(Kex *kex ) ;
#line 124
Newkeys *kex_get_newkeys(int mode ) ;
#line 37 "match.h"
char *match_list(char const   *client , char const   *server , u_int *next ) ;
#line 46 "kex.c"
void kex_kexinit_finish(Kex *kex ) ;
#line 47
void kex_choose_conf(Kex *kex ) ;
#line 50 "kex.c"
void kex_prop2buf(Buffer *b , char **proposal ) 
{ u_int32_t rand___0 ;
  int i ;

  {
#line 53
  rand___0 = (u_int32_t )0;
#line 56
  buffer_clear(b);
#line 57
  i = 0;
#line 57
  while (i < 16) {
#line 58
    if (i % 4 == 0) {
#line 59
      rand___0 = arc4random();
    }
#line 60
    buffer_put_char(b, (int )(rand___0 & 255U));
#line 61
    rand___0 >>= 8;
#line 57
    i ++;
  }
#line 63
  i = 0;
#line 63
  while (i < 10) {
#line 64
    buffer_put_cstring(b, (char const   *)*(proposal + i));
#line 63
    i ++;
  }
#line 65
  buffer_put_char(b, 0);
#line 66
  buffer_put_int(b, 0U);
#line 67
  return;
}
}
#line 70 "kex.c"
char **kex_buf2prop(Buffer *raw ) 
{ Buffer b ;
  int i ;
  char **proposal ;
  void *tmp ;
  u_int tmp___0 ;
  char *tmp___1 ;
  u_int tmp___2 ;

  {
#line 77
  tmp = xmalloc(10U * sizeof(char *));
#line 77
  proposal = (char **)tmp;
#line 79
  buffer_init(& b);
#line 80
  tmp___0 = buffer_len(raw);
#line 80
  tmp___1 = buffer_ptr(raw);
#line 80
  buffer_append(& b, (char const   *)tmp___1, tmp___0);
#line 82
  i = 0;
#line 82
  while (i < 16) {
#line 83
    buffer_get_char(& b);
#line 82
    i ++;
  }
#line 85
  i = 0;
#line 85
  while (i < 10) {
#line 86
    *(proposal + i) = buffer_get_string(& b, (u_int *)((void *)0));
#line 87
    debug2("kex_parse_kexinit: %s", *(proposal + i));
#line 85
    i ++;
  }
#line 90
  i = buffer_get_char(& b);
#line 91
  debug2("kex_parse_kexinit: first_kex_follows %d ", i);
#line 92
  tmp___2 = buffer_get_int(& b);
#line 92
  i = (int )tmp___2;
#line 93
  debug2("kex_parse_kexinit: reserved %d ", i);
#line 94
  buffer_free(& b);
#line 95
  return (proposal);
}
}
#line 98 "kex.c"
void kex_prop_free(char **proposal ) 
{ int i ;

  {
#line 103
  i = 0;
#line 103
  while (i < 10) {
#line 104
    xfree((void *)*(proposal + i));
#line 103
    i ++;
  }
#line 105
  xfree((void *)proposal);
#line 106
  return;
}
}
#line 108 "kex.c"
void kex_protocol_error(int type , int plen , void *ctxt ) 
{ 

  {
#line 111
  error("Hm, kex protocol error: type %d plen %d", type, plen);
#line 112
  return;
}
}
#line 114 "kex.c"
void kex_clear_dispatch(void) 
{ int i ;

  {
#line 120
  i = 30;
#line 120
  while (i <= 49) {
#line 121
    dispatch_set(i, & kex_protocol_error);
#line 120
    i ++;
  }
#line 122
  return;
}
}
#line 124 "kex.c"
void kex_finish(Kex *kex ) 
{ int plen ;

  {
#line 129
  kex_clear_dispatch();
#line 131
  packet_start(21);
#line 132
  packet_send();
#line 134
  debug("SSH2_MSG_NEWKEYS sent");
#line 136
  debug("waiting for SSH2_MSG_NEWKEYS");
#line 137
  packet_read_expect(& plen, 21);
#line 138
  debug("SSH2_MSG_NEWKEYS received");
#line 140
  kex->done = 1;
#line 141
  buffer_clear(& kex->peer);
#line 143
  kex->flags &= -2;
#line 144
  xfree((void *)kex->name);
#line 145
  kex->name = (char *)((void *)0);
#line 146
  return;
}
}
#line 148 "kex.c"
void kex_send_kexinit(Kex *kex ) 
{ u_int tmp ;
  char *tmp___0 ;

  {
#line 151
  if ((unsigned int )kex == (unsigned int )((void *)0)) {
#line 152
    error("kex_send_kexinit: no kex, cannot rekey");
#line 153
    return;
  }
#line 155
  if (kex->flags & 1) {
#line 156
    debug("KEX_INIT_SENT");
#line 157
    return;
  }
#line 159
  kex->done = 0;
#line 160
  packet_start(20);
#line 161
  tmp = buffer_len(& kex->my);
#line 161
  tmp___0 = buffer_ptr(& kex->my);
#line 161
  packet_put_raw((char const   *)tmp___0, tmp);
#line 162
  packet_send();
#line 163
  debug("SSH2_MSG_KEXINIT sent");
#line 164
  kex->flags |= 1;
#line 165
  return;
}
}
#line 167 "kex.c"
void kex_input_kexinit(int type , int plen , void *ctxt ) 
{ char *ptr ;
  int dlen ;
  int i ;
  Kex *kex ;
  char *tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 173
  kex = (Kex *)ctxt;
#line 175
  debug("SSH2_MSG_KEXINIT received");
#line 176
  if ((unsigned int )kex == (unsigned int )((void *)0)) {
#line 177
    fatal("kex_input_kexinit: no kex, cannot rekey");
  }
#line 179
  ptr = packet_get_raw(& dlen);
#line 180
  buffer_append(& kex->peer, (char const   *)ptr, (unsigned int )dlen);
#line 183
  i = 0;
#line 183
  while (i < 16) {
#line 184
    packet_get_char();
#line 183
    i ++;
  }
#line 185
  i = 0;
#line 185
  while (i < 10) {
#line 186
    tmp = packet_get_string((u_int *)((void *)0));
#line 186
    xfree((void *)tmp);
#line 185
    i ++;
  }
#line 187
  packet_get_char();
#line 188
  packet_get_int();
#line 189
  while (1) {
#line 189
    tmp___0 = packet_remaining();
#line 189
    _len = tmp___0;
#line 189
    if (_len > 0) {
#line 189
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kex.c", 189);
#line 189
      packet_disconnect("Packet integrity error.");
    }
#line 189
    break;
  }
#line 191
  kex_kexinit_finish(kex);
#line 192
  return;
}
}
#line 194 "kex.c"
Kex *kex_setup(char **proposal ) 
{ Kex *kex ;
  void *tmp ;

  {
#line 199
  tmp = xmalloc(sizeof(*kex));
#line 199
  kex = (Kex *)tmp;
#line 200
  memset((void *)kex, 0, sizeof(*kex));
#line 201
  buffer_init(& kex->peer);
#line 202
  buffer_init(& kex->my);
#line 203
  kex_prop2buf(& kex->my, proposal);
#line 204
  kex->done = 0;
#line 206
  kex_send_kexinit(kex);
#line 207
  kex_clear_dispatch();
#line 208
  dispatch_set(20, & kex_input_kexinit);
#line 210
  return (kex);
}
}
#line 213 "kex.c"
void kex_kexinit_finish(Kex *kex ) 
{ 

  {
#line 216
  if (! (kex->flags & 1)) {
#line 217
    kex_send_kexinit(kex);
  }
#line 219
  kex_choose_conf(kex);
#line 221
  switch (kex->kex_type) {
  case 0: 
#line 223
  kexdh(kex);
#line 224
  break;
  case 1: 
#line 226
  kexgex(kex);
#line 227
  break;
  default: 
#line 229
  fatal("Unsupported key exchange %d", kex->kex_type);
  }
#line 231
  return;
}
}
#line 233 "kex.c"
void choose_enc(Enc *enc , char *client , char *server ) 
{ char *name ;
  char *tmp ;

  {
#line 236
  tmp = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 236
  name = tmp;
#line 237
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 238
    fatal("no matching cipher found: client %s server %s", client, server);
  }
#line 239
  enc->cipher = cipher_by_name((char const   *)name);
#line 240
  if ((unsigned int )enc->cipher == (unsigned int )((void *)0)) {
#line 241
    fatal("matching cipher is not supported: %s", name);
  }
#line 242
  enc->name = name;
#line 243
  enc->enabled = 0;
#line 244
  enc->iv = (u_char *)((void *)0);
#line 245
  enc->key = (u_char *)((void *)0);
#line 246
  return;
}
}
#line 247 "kex.c"
void choose_mac(Mac *mac , char *client , char *server ) 
{ char *name ;
  char *tmp ;
  int tmp___0 ;

  {
#line 250
  tmp = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 250
  name = tmp;
#line 251
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 252
    fatal("no matching mac found: client %s server %s", client, server);
  }
#line 253
  tmp___0 = mac_init(mac, name);
#line 253
  if (tmp___0 < 0) {
#line 254
    fatal("unsupported mac %s", name);
  }
#line 256
  if (datafellows & 4) {
#line 257
    mac->key_len = 16;
  }
#line 258
  mac->name = name;
#line 259
  mac->key = (u_char *)((void *)0);
#line 260
  mac->enabled = 0;
#line 261
  return;
}
}
#line 262 "kex.c"
void choose_comp(Comp *comp , char *client , char *server ) 
{ char *name ;
  char *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 265
  tmp = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 265
  name = tmp;
#line 266
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 267
    fatal("no matching comp found: client %s server %s", client, server);
  }
#line 268
  if (0) {
#line 268
    __s1_len___0 = strlen((char const   *)name);
#line 268
    __s2_len___0 = strlen("zlib");
#line 268
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___2;
    } else {
#line 268
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 268
        if (! ((unsigned int )((void const   *)("zlib" + 1)) - (unsigned int )((void const   *)"zlib") == 1U)) {
#line 268
          tmp___19 = 1;
        } else {
#line 268
          if (__s2_len___0 >= 4U) {
#line 268
            tmp___19 = 1;
          } else {
#line 268
            tmp___19 = 0;
          }
        }
      } else {
#line 268
        tmp___19 = 0;
      }
    }
#line 268
    if (tmp___19) {
#line 268
      tmp___15 = __builtin_strcmp((char const   *)name, "zlib");
    } else {
#line 268
      tmp___18 = __builtin_strcmp((char const   *)name, "zlib");
#line 268
      tmp___15 = tmp___18;
    }
  } else {
#line 268
    tmp___18 = __builtin_strcmp((char const   *)name, "zlib");
#line 268
    tmp___15 = tmp___18;
  }
#line 268
  if (tmp___15 == 0) {
#line 269
    comp->type = 1;
  } else {
#line 270
    if (0) {
#line 270
      __s1_len = strlen((char const   *)name);
#line 270
      __s2_len = strlen("none");
#line 270
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___0;
      } else {
#line 270
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 270
          if (! ((unsigned int )((void const   *)("none" + 1)) - (unsigned int )((void const   *)"none") == 1U)) {
#line 270
            tmp___9 = 1;
          } else {
#line 270
            if (__s2_len >= 4U) {
#line 270
              tmp___9 = 1;
            } else {
#line 270
              tmp___9 = 0;
            }
          }
        } else {
#line 270
          tmp___9 = 0;
        }
      }
#line 270
      if (tmp___9) {
#line 270
        tmp___5 = __builtin_strcmp((char const   *)name, "none");
      } else {
#line 270
        tmp___8 = __builtin_strcmp((char const   *)name, "none");
#line 270
        tmp___5 = tmp___8;
      }
    } else {
#line 270
      tmp___8 = __builtin_strcmp((char const   *)name, "none");
#line 270
      tmp___5 = tmp___8;
    }
#line 270
    if (tmp___5 == 0) {
#line 271
      comp->type = 0;
    } else {
#line 273
      fatal("unsupported comp %s", name);
    }
  }
#line 275
  comp->name = name;
#line 276
  return;
}
}
#line 277 "kex.c"
void choose_kex(Kex *k , char *client , char *server ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 280
  k->name = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 281
  if ((unsigned int )k->name == (unsigned int )((void *)0)) {
#line 282
    fatal("no kex alg");
  }
#line 283
  if (0) {
#line 283
    __s1_len___0 = strlen((char const   *)k->name);
#line 283
    __s2_len___0 = strlen("diffie-hellman-group1-sha1");
#line 283
    if (! ((unsigned int )((void const   *)(k->name + 1)) - (unsigned int )((void const   *)k->name) == 1U)) {
      goto _L___2;
    } else {
#line 283
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 283
        if (! ((unsigned int )((void const   *)("diffie-hellman-group1-sha1" + 1)) - (unsigned int )((void const   *)"diffie-hellman-group1-sha1") == 1U)) {
#line 283
          tmp___18 = 1;
        } else {
#line 283
          if (__s2_len___0 >= 4U) {
#line 283
            tmp___18 = 1;
          } else {
#line 283
            tmp___18 = 0;
          }
        }
      } else {
#line 283
        tmp___18 = 0;
      }
    }
#line 283
    if (tmp___18) {
#line 283
      tmp___14 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
    } else {
#line 283
      tmp___17 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
#line 283
      tmp___14 = tmp___17;
    }
  } else {
#line 283
    tmp___17 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
#line 283
    tmp___14 = tmp___17;
  }
#line 283
  if (tmp___14 == 0) {
#line 284
    k->kex_type = 0;
  } else {
#line 285
    if (0) {
#line 285
      __s1_len = strlen((char const   *)k->name);
#line 285
      __s2_len = strlen("diffie-hellman-group-exchange-sha1");
#line 285
      if (! ((unsigned int )((void const   *)(k->name + 1)) - (unsigned int )((void const   *)k->name) == 1U)) {
        goto _L___0;
      } else {
#line 285
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 285
          if (! ((unsigned int )((void const   *)("diffie-hellman-group-exchange-sha1" + 1)) - (unsigned int )((void const   *)"diffie-hellman-group-exchange-sha1") == 1U)) {
#line 285
            tmp___8 = 1;
          } else {
#line 285
            if (__s2_len >= 4U) {
#line 285
              tmp___8 = 1;
            } else {
#line 285
              tmp___8 = 0;
            }
          }
        } else {
#line 285
          tmp___8 = 0;
        }
      }
#line 285
      if (tmp___8) {
#line 285
        tmp___4 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha1");
      } else {
#line 285
        tmp___7 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha1");
#line 285
        tmp___4 = tmp___7;
      }
    } else {
#line 285
      tmp___7 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha1");
#line 285
      tmp___4 = tmp___7;
    }
#line 285
    if (tmp___4 == 0) {
#line 286
      k->kex_type = 1;
    } else {
#line 288
      fatal("bad kex alg %s", k->name);
    }
  }
#line 289
  return;
}
}
#line 290 "kex.c"
void choose_hostkeyalg(Kex *k , char *client , char *server ) 
{ char *hostkeyalg ;
  char *tmp ;

  {
#line 293
  tmp = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 293
  hostkeyalg = tmp;
#line 294
  if ((unsigned int )hostkeyalg == (unsigned int )((void *)0)) {
#line 295
    fatal("no hostkey alg");
  }
#line 296
  k->hostkey_type = key_type_from_name(hostkeyalg);
#line 297
  if (k->hostkey_type == 3) {
#line 298
    fatal("bad hostkey alg \'%s\'", hostkeyalg);
  }
#line 299
  xfree((void *)hostkeyalg);
#line 300
  return;
}
}
#line 302 "kex.c"
void kex_choose_conf(Kex *kex ) 
{ Newkeys *newkeys___0 ;
  char **my ;
  char **peer ;
  char **cprop ;
  char **sprop ;
  int nenc ;
  int nmac ;
  int ncomp ;
  int mode ;
  int ctos ;
  int need ;
  void *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 313
  my = kex_buf2prop(& kex->my);
#line 314
  peer = kex_buf2prop(& kex->peer);
#line 316
  if (kex->server) {
#line 317
    cprop = peer;
#line 318
    sprop = my;
  } else {
#line 320
    cprop = my;
#line 321
    sprop = peer;
  }
#line 325
  mode = 0;
#line 325
  while (mode < 2) {
#line 326
    tmp = xmalloc(sizeof(*newkeys___0));
#line 326
    newkeys___0 = (Newkeys *)tmp;
#line 327
    memset((void *)newkeys___0, 0, sizeof(*newkeys___0));
#line 328
    kex->newkeys[mode] = newkeys___0;
#line 329
    if (! kex->server) {
#line 329
      if (mode == 1) {
#line 329
        tmp___0 = 1;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 329
      if (kex->server) {
#line 329
        if (mode == 0) {
#line 329
          tmp___0 = 1;
        } else {
#line 329
          tmp___0 = 0;
        }
      } else {
#line 329
        tmp___0 = 0;
      }
    }
#line 329
    ctos = tmp___0;
#line 330
    if (ctos) {
#line 330
      nenc = 2;
    } else {
#line 330
      nenc = 3;
    }
#line 331
    if (ctos) {
#line 331
      nmac = 4;
    } else {
#line 331
      nmac = 5;
    }
#line 332
    if (ctos) {
#line 332
      ncomp = 6;
    } else {
#line 332
      ncomp = 7;
    }
#line 333
    choose_enc(& newkeys___0->enc, *(cprop + nenc), *(sprop + nenc));
#line 334
    choose_mac(& newkeys___0->mac, *(cprop + nmac), *(sprop + nmac));
#line 335
    choose_comp(& newkeys___0->comp, *(cprop + ncomp), *(sprop + ncomp));
#line 336
    if (ctos) {
#line 336
      tmp___1 = "client->server";
    } else {
#line 336
      tmp___1 = "server->client";
    }
#line 336
    debug("kex: %s %s %s %s", tmp___1, newkeys___0->enc.name, newkeys___0->mac.name,
          newkeys___0->comp.name);
#line 325
    mode ++;
  }
#line 342
  choose_kex(kex, *(cprop + 0), *(sprop + 0));
#line 343
  choose_hostkeyalg(kex, *(cprop + 1), *(sprop + 1));
#line 345
  need = 0;
#line 346
  mode = 0;
#line 346
  while (mode < 2) {
#line 347
    newkeys___0 = kex->newkeys[mode];
#line 348
    if ((u_int )need < (newkeys___0->enc.cipher)->key_len) {
#line 349
      need = (int )(newkeys___0->enc.cipher)->key_len;
    }
#line 350
    if ((u_int )need < (newkeys___0->enc.cipher)->block_size) {
#line 351
      need = (int )(newkeys___0->enc.cipher)->block_size;
    }
#line 352
    if (need < newkeys___0->mac.key_len) {
#line 353
      need = newkeys___0->mac.key_len;
    }
#line 346
    mode ++;
  }
#line 356
  kex->we_need = need;
#line 358
  kex_prop_free(my);
#line 359
  kex_prop_free(peer);
#line 360
  return;
}
}
#line 362 "kex.c"
u_char *derive_key(Kex *kex , int id , int need , u_char *hash , BIGNUM *shared_secret ) 
{ Buffer b ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  char c ;
  int have ;
  int mdsz ;
  u_char *digest___1 ;
  void *tmp___0 ;
  u_int tmp___1 ;
  char *tmp___2 ;
  u_int tmp___3 ;
  char *tmp___4 ;

  {
#line 366
  tmp = EVP_sha1();
#line 366
  evp_md = (EVP_MD *)tmp;
#line 368
  c = (char )id;
#line 370
  mdsz = evp_md->md_size;
#line 371
  tmp___0 = xmalloc((unsigned int )(((need + (mdsz - 1)) / mdsz) * mdsz));
#line 371
  digest___1 = (u_char *)tmp___0;
#line 373
  buffer_init(& b);
#line 374
  buffer_put_bignum2(& b, shared_secret);
#line 377
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 378
  tmp___1 = buffer_len(& b);
#line 378
  tmp___2 = buffer_ptr(& b);
#line 378
  EVP_DigestUpdate(& md, (void const   *)tmp___2, tmp___1);
#line 379
  EVP_DigestUpdate(& md, (void const   *)hash, (unsigned int )mdsz);
#line 380
  EVP_DigestUpdate(& md, (void const   *)(& c), 1U);
#line 381
  EVP_DigestUpdate(& md, (void const   *)kex->session_id, (unsigned int )kex->session_id_len);
#line 382
  EVP_DigestFinal(& md, digest___1, (unsigned int *)((void *)0));
#line 389
  have = mdsz;
#line 389
  while (need > have) {
#line 390
    EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 391
    tmp___3 = buffer_len(& b);
#line 391
    tmp___4 = buffer_ptr(& b);
#line 391
    EVP_DigestUpdate(& md, (void const   *)tmp___4, tmp___3);
#line 392
    EVP_DigestUpdate(& md, (void const   *)hash, (unsigned int )mdsz);
#line 393
    EVP_DigestUpdate(& md, (void const   *)digest___1, (unsigned int )have);
#line 394
    EVP_DigestFinal(& md, digest___1 + have, (unsigned int *)((void *)0));
#line 389
    have += mdsz;
  }
#line 396
  buffer_free(& b);
#line 401
  return (digest___1);
}
}
#line 404 "kex.c"
Newkeys *current_keys[2]  ;
#line 407 "kex.c"
void kex_derive_keys(Kex *kex , u_char *hash , BIGNUM *shared_secret ) 
{ u_char *keys[6] ;
  int i ;
  int mode ;
  int ctos ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 413
  i = 0;
#line 413
  while (i < 6) {
#line 414
    keys[i] = derive_key(kex, 65 + i, kex->we_need, hash, shared_secret);
#line 413
    i ++;
  }
#line 416
  debug("kex_derive_keys");
#line 417
  mode = 0;
#line 417
  while (mode < 2) {
#line 418
    current_keys[mode] = kex->newkeys[mode];
#line 419
    kex->newkeys[mode] = (Newkeys *)((void *)0);
#line 420
    if (! kex->server) {
#line 420
      if (mode == 1) {
#line 420
        tmp = 1;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 420
      if (kex->server) {
#line 420
        if (mode == 0) {
#line 420
          tmp = 1;
        } else {
#line 420
          tmp = 0;
        }
      } else {
#line 420
        tmp = 0;
      }
    }
#line 420
    ctos = tmp;
#line 421
    if (ctos) {
#line 421
      tmp___0 = 0;
    } else {
#line 421
      tmp___0 = 1;
    }
#line 421
    (current_keys[mode])->enc.iv = keys[tmp___0];
#line 422
    if (ctos) {
#line 422
      tmp___1 = 2;
    } else {
#line 422
      tmp___1 = 3;
    }
#line 422
    (current_keys[mode])->enc.key = keys[tmp___1];
#line 423
    if (ctos) {
#line 423
      tmp___2 = 4;
    } else {
#line 423
      tmp___2 = 5;
    }
#line 423
    (current_keys[mode])->mac.key = keys[tmp___2];
#line 417
    mode ++;
  }
#line 425
  return;
}
}
#line 427 "kex.c"
Newkeys *kex_get_newkeys(int mode ) 
{ Newkeys *ret ;

  {
#line 432
  ret = current_keys[mode];
#line 433
  current_keys[mode] = (Newkeys *)((void *)0);
#line 434
  return (ret);
}
}
#line 1 "kexdh.o"
#pragma merger(0,"./kexdh.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 174 "/usr/include/openssl/dh.h"
extern void DH_free(DH *dh ) ;
#line 176
extern int DH_size(DH const   *dh ) ;
#line 194
extern int DH_compute_key(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
#line 84 "packet.h"
void packet_put_bignum2(BIGNUM *value ) ;
#line 133
void packet_get_bignum2(BIGNUM *value , int *length_ptr ) ;
#line 53 "kexdh.c"
static u_char digest[64]  ;
#line 41 "kexdh.c"
u_char *kex_dh_hash(char *client_version_string___0 , char *server_version_string___0 ,
                    char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                    char *serverhostkeyblob , int sbloblen , BIGNUM *client_dh_pub ,
                    BIGNUM *server_dh_pub , BIGNUM *shared_secret ) 
{ Buffer b ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  u_int tmp___2 ;
  char *tmp___3 ;

  {
#line 54
  tmp = EVP_sha1();
#line 54
  evp_md = (EVP_MD *)tmp;
#line 57
  buffer_init(& b);
#line 58
  tmp___0 = strlen((char const   *)client_version_string___0);
#line 58
  buffer_put_string(& b, (void const   *)client_version_string___0, tmp___0);
#line 59
  tmp___1 = strlen((char const   *)server_version_string___0);
#line 59
  buffer_put_string(& b, (void const   *)server_version_string___0, tmp___1);
#line 62
  buffer_put_int(& b, (unsigned int )(ckexinitlen + 1));
#line 63
  buffer_put_char(& b, 20);
#line 64
  buffer_append(& b, (char const   *)ckexinit, (unsigned int )ckexinitlen);
#line 65
  buffer_put_int(& b, (unsigned int )(skexinitlen + 1));
#line 66
  buffer_put_char(& b, 20);
#line 67
  buffer_append(& b, (char const   *)skexinit, (unsigned int )skexinitlen);
#line 69
  buffer_put_string(& b, (void const   *)serverhostkeyblob, (unsigned int )sbloblen);
#line 70
  buffer_put_bignum2(& b, client_dh_pub);
#line 71
  buffer_put_bignum2(& b, server_dh_pub);
#line 72
  buffer_put_bignum2(& b, shared_secret);
#line 77
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 78
  tmp___2 = buffer_len(& b);
#line 78
  tmp___3 = buffer_ptr(& b);
#line 78
  EVP_DigestUpdate(& md, (void const   *)tmp___3, tmp___2);
#line 79
  EVP_DigestFinal(& md, digest, (unsigned int *)((void *)0));
#line 81
  buffer_free(& b);
#line 86
  return (digest);
}
}
#line 91 "kexdh.c"
void kexdh_client(Kex *kex ) 
{ BIGNUM *dh_server_pub ;
  BIGNUM *shared_secret ;
  DH *dh ;
  Key *server_host_key ;
  char *server_host_key_blob ;
  char *signature ;
  u_char *kbuf ;
  u_char *hash ;
  u_int klen ;
  u_int kout ;
  u_int slen ;
  u_int sbloblen ;
  int dlen ;
  int plen ;
  int _len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  u_int tmp___4 ;
  char *tmp___5 ;
  u_int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;

  {
#line 94
  dh_server_pub = (BIGNUM *)((void *)0);
#line 94
  shared_secret = (BIGNUM *)((void *)0);
#line 97
  server_host_key_blob = (char *)((void *)0);
#line 97
  signature = (char *)((void *)0);
#line 103
  dh = dh_new_group1();
#line 104
  dh_gen_key(dh, kex->we_need * 8);
#line 105
  packet_start(30);
#line 106
  packet_put_bignum2(dh->pub_key);
#line 107
  packet_send();
#line 109
  debug("sending SSH2_MSG_KEXDH_INIT");
#line 117
  debug("expecting SSH2_MSG_KEXDH_REPLY");
#line 118
  packet_read_expect(& plen, 31);
#line 121
  server_host_key_blob = packet_get_string(& sbloblen);
#line 122
  server_host_key = key_from_blob(server_host_key_blob, (int )sbloblen);
#line 123
  if ((unsigned int )server_host_key == (unsigned int )((void *)0)) {
#line 124
    fatal("cannot decode server_host_key_blob");
  }
#line 126
  if ((unsigned int )kex->check_host_key == (unsigned int )((void *)0)) {
#line 127
    fatal("cannot check server_host_key");
  }
#line 128
  (*(kex->check_host_key))(server_host_key);
#line 131
  dh_server_pub = BN_new();
#line 132
  if ((unsigned int )dh_server_pub == (unsigned int )((void *)0)) {
#line 133
    fatal("dh_server_pub == NULL");
  }
#line 134
  packet_get_bignum2(dh_server_pub, & dlen);
#line 144
  signature = packet_get_string(& slen);
#line 145
  while (1) {
#line 145
    tmp = packet_remaining();
#line 145
    _len = tmp;
#line 145
    if (_len > 0) {
#line 145
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kexdh.c",
          145);
#line 145
      packet_disconnect("Packet integrity error.");
    }
#line 145
    break;
  }
#line 147
  tmp___0 = dh_pub_is_valid(dh, dh_server_pub);
#line 147
  if (! tmp___0) {
#line 148
    packet_disconnect("bad server public DH value");
  }
#line 150
  tmp___1 = DH_size((DH const   *)dh);
#line 150
  klen = (unsigned int )tmp___1;
#line 151
  tmp___2 = xmalloc(klen);
#line 151
  kbuf = (u_char *)tmp___2;
#line 152
  tmp___3 = DH_compute_key(kbuf, (BIGNUM const   *)dh_server_pub, dh);
#line 152
  kout = (unsigned int )tmp___3;
#line 156
  shared_secret = BN_new();
#line 157
  BN_bin2bn((unsigned char const   *)kbuf, (int )kout, shared_secret);
#line 158
  memset((void *)kbuf, 0, klen);
#line 159
  xfree((void *)kbuf);
#line 162
  tmp___4 = buffer_len(& kex->peer);
#line 162
  tmp___5 = buffer_ptr(& kex->peer);
#line 162
  tmp___6 = buffer_len(& kex->my);
#line 162
  tmp___7 = buffer_ptr(& kex->my);
#line 162
  hash = kex_dh_hash(kex->client_version_string, kex->server_version_string, tmp___7,
                     (int )tmp___6, tmp___5, (int )tmp___4, server_host_key_blob,
                     (int )sbloblen, dh->pub_key, dh_server_pub, shared_secret);
#line 172
  xfree((void *)server_host_key_blob);
#line 173
  BN_free(dh_server_pub);
#line 174
  DH_free(dh);
#line 176
  tmp___8 = key_verify(server_host_key, (u_char *)signature, (int )slen, hash, 20);
#line 176
  if (tmp___8 != 1) {
#line 177
    fatal("key_verify failed for server_host_key");
  }
#line 178
  key_free(server_host_key);
#line 179
  xfree((void *)signature);
#line 182
  if ((unsigned int )kex->session_id == (unsigned int )((void *)0)) {
#line 183
    kex->session_id_len = 20;
#line 184
    tmp___9 = xmalloc((unsigned int )kex->session_id_len);
#line 184
    kex->session_id = (u_char *)tmp___9;
#line 185
    memcpy((void * __restrict  )kex->session_id, (void const   * __restrict  )hash,
           (unsigned int )kex->session_id_len);
  }
#line 188
  kex_derive_keys(kex, hash, shared_secret);
#line 189
  BN_clear_free(shared_secret);
#line 190
  kex_finish(kex);
#line 191
  return;
}
}
#line 195 "kexdh.c"
void kexdh_server(Kex *kex ) 
{ BIGNUM *shared_secret ;
  BIGNUM *dh_client_pub ;
  DH *dh ;
  Key *server_host_key ;
  u_char *kbuf ;
  u_char *hash ;
  u_char *signature ;
  u_char *server_host_key_blob ;
  u_int sbloblen ;
  u_int klen ;
  u_int kout ;
  int dlen ;
  int slen ;
  int plen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  u_int tmp___3 ;
  char *tmp___4 ;
  u_int tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;

  {
#line 198
  shared_secret = (BIGNUM *)((void *)0);
#line 198
  dh_client_pub = (BIGNUM *)((void *)0);
#line 201
  signature = (u_char *)((void *)0);
#line 201
  server_host_key_blob = (u_char *)((void *)0);
#line 206
  dh = dh_new_group1();
#line 207
  dh_gen_key(dh, kex->we_need * 8);
#line 209
  debug("expecting SSH2_MSG_KEXDH_INIT");
#line 210
  packet_read_expect(& plen, 30);
#line 212
  if ((unsigned int )kex->load_host_key == (unsigned int )((void *)0)) {
#line 213
    fatal("Cannot load hostkey");
  }
#line 214
  server_host_key = (*(kex->load_host_key))(kex->hostkey_type);
#line 215
  if ((unsigned int )server_host_key == (unsigned int )((void *)0)) {
#line 216
    fatal("Unsupported hostkey type %d", kex->hostkey_type);
  }
#line 219
  dh_client_pub = BN_new();
#line 220
  if ((unsigned int )dh_client_pub == (unsigned int )((void *)0)) {
#line 221
    fatal("dh_client_pub == NULL");
  }
#line 222
  packet_get_bignum2(dh_client_pub, & dlen);
#line 237
  tmp = dh_pub_is_valid(dh, dh_client_pub);
#line 237
  if (! tmp) {
#line 238
    packet_disconnect("bad client public DH value");
  }
#line 240
  tmp___0 = DH_size((DH const   *)dh);
#line 240
  klen = (unsigned int )tmp___0;
#line 241
  tmp___1 = xmalloc(klen);
#line 241
  kbuf = (u_char *)tmp___1;
#line 242
  tmp___2 = DH_compute_key(kbuf, (BIGNUM const   *)dh_client_pub, dh);
#line 242
  kout = (unsigned int )tmp___2;
#line 246
  shared_secret = BN_new();
#line 247
  BN_bin2bn((unsigned char const   *)kbuf, (int )kout, shared_secret);
#line 248
  memset((void *)kbuf, 0, klen);
#line 249
  xfree((void *)kbuf);
#line 251
  key_to_blob(server_host_key, & server_host_key_blob, & sbloblen);
#line 254
  tmp___3 = buffer_len(& kex->my);
#line 254
  tmp___4 = buffer_ptr(& kex->my);
#line 254
  tmp___5 = buffer_len(& kex->peer);
#line 254
  tmp___6 = buffer_ptr(& kex->peer);
#line 254
  hash = kex_dh_hash(kex->client_version_string, kex->server_version_string, tmp___6,
                     (int )tmp___5, tmp___4, (int )tmp___3, (char *)server_host_key_blob,
                     (int )sbloblen, dh_client_pub, dh->pub_key, shared_secret);
#line 264
  BN_free(dh_client_pub);
#line 268
  if ((unsigned int )kex->session_id == (unsigned int )((void *)0)) {
#line 269
    kex->session_id_len = 20;
#line 270
    tmp___7 = xmalloc((unsigned int )kex->session_id_len);
#line 270
    kex->session_id = (u_char *)tmp___7;
#line 271
    memcpy((void * __restrict  )kex->session_id, (void const   * __restrict  )hash,
           (unsigned int )kex->session_id_len);
  }
#line 276
  key_sign(server_host_key, & signature, & slen, hash, 20);
#line 281
  packet_start(31);
#line 282
  packet_put_string((char const   *)((char *)server_host_key_blob), sbloblen);
#line 283
  packet_put_bignum2(dh->pub_key);
#line 284
  packet_put_string((char const   *)((char *)signature), (unsigned int )slen);
#line 285
  packet_send();
#line 287
  xfree((void *)signature);
#line 288
  xfree((void *)server_host_key_blob);
#line 290
  DH_free(dh);
#line 292
  kex_derive_keys(kex, hash, shared_secret);
#line 293
  BN_clear_free(shared_secret);
#line 294
  kex_finish(kex);
#line 295
  return;
}
}
#line 297 "kexdh.c"
void kexdh(Kex *kex ) 
{ 

  {
#line 300
  if (kex->server) {
#line 301
    kexdh_server(kex);
  } else {
#line 303
    kexdh_client(kex);
  }
#line 304
  return;
}
}
#line 1 "kexgex.o"
#pragma merger(0,"./kexgex.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 55 "kexgex.c"
static u_char digest___0[64]  ;
#line 42 "kexgex.c"
u_char *kexgex_hash(char *client_version_string___0 , char *server_version_string___0 ,
                    char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                    char *serverhostkeyblob , int sbloblen , int min , int wantbits ,
                    int max , BIGNUM *prime , BIGNUM *gen___0 , BIGNUM *client_dh_pub ,
                    BIGNUM *server_dh_pub , BIGNUM *shared_secret ) 
{ Buffer b ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  u_int tmp___2 ;
  char *tmp___3 ;

  {
#line 56
  tmp = EVP_sha1();
#line 56
  evp_md = (EVP_MD *)tmp;
#line 59
  buffer_init(& b);
#line 60
  tmp___0 = strlen((char const   *)client_version_string___0);
#line 60
  buffer_put_string(& b, (void const   *)client_version_string___0, tmp___0);
#line 61
  tmp___1 = strlen((char const   *)server_version_string___0);
#line 61
  buffer_put_string(& b, (void const   *)server_version_string___0, tmp___1);
#line 64
  buffer_put_int(& b, (unsigned int )(ckexinitlen + 1));
#line 65
  buffer_put_char(& b, 20);
#line 66
  buffer_append(& b, (char const   *)ckexinit, (unsigned int )ckexinitlen);
#line 67
  buffer_put_int(& b, (unsigned int )(skexinitlen + 1));
#line 68
  buffer_put_char(& b, 20);
#line 69
  buffer_append(& b, (char const   *)skexinit, (unsigned int )skexinitlen);
#line 71
  buffer_put_string(& b, (void const   *)serverhostkeyblob, (unsigned int )sbloblen);
#line 72
  if (min == -1) {
#line 73
    buffer_put_int(& b, (unsigned int )wantbits);
  } else {
#line 72
    if (max == -1) {
#line 73
      buffer_put_int(& b, (unsigned int )wantbits);
    } else {
#line 75
      buffer_put_int(& b, (unsigned int )min);
#line 76
      buffer_put_int(& b, (unsigned int )wantbits);
#line 77
      buffer_put_int(& b, (unsigned int )max);
    }
  }
#line 79
  buffer_put_bignum2(& b, prime);
#line 80
  buffer_put_bignum2(& b, gen___0);
#line 81
  buffer_put_bignum2(& b, client_dh_pub);
#line 82
  buffer_put_bignum2(& b, server_dh_pub);
#line 83
  buffer_put_bignum2(& b, shared_secret);
#line 88
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 89
  tmp___2 = buffer_len(& b);
#line 89
  tmp___3 = buffer_ptr(& b);
#line 89
  EVP_DigestUpdate(& md, (void const   *)tmp___3, tmp___2);
#line 90
  EVP_DigestFinal(& md, digest___0, (unsigned int *)((void *)0));
#line 92
  buffer_free(& b);
#line 97
  return (digest___0);
}
}
#line 102 "kexgex.c"
void kexgex_client(Kex *kex ) 
{ BIGNUM *dh_server_pub ;
  BIGNUM *shared_secret ;
  BIGNUM *p ;
  BIGNUM *g ;
  Key *server_host_key ;
  u_char *kbuf ;
  u_char *hash ;
  u_char *signature ;
  u_char *server_host_key_blob ;
  u_int klen ;
  u_int kout ;
  u_int slen ;
  u_int sbloblen ;
  int dlen ;
  int plen ;
  int min ;
  int max ;
  int nbits ;
  DH *dh ;
  int _len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int _len___0 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  u_int tmp___10 ;
  char *tmp___11 ;
  u_int tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  void *tmp___15 ;

  {
#line 105
  dh_server_pub = (BIGNUM *)((void *)0);
#line 105
  shared_secret = (BIGNUM *)((void *)0);
#line 106
  p = (BIGNUM *)((void *)0);
#line 106
  g = (BIGNUM *)((void *)0);
#line 108
  signature = (u_char *)((void *)0);
#line 108
  server_host_key_blob = (u_char *)((void *)0);
#line 113
  nbits = dh_estimate(kex->we_need * 8);
#line 115
  if (datafellows & 16384) {
#line 116
    debug("SSH2_MSG_KEX_DH_GEX_REQUEST_OLD sent");
#line 119
    packet_start(30);
#line 120
    packet_put_int((unsigned int )nbits);
#line 121
    min = 1024;
#line 122
    max = 8192;
  } else {
#line 124
    debug("SSH2_MSG_KEX_DH_GEX_REQUEST sent");
#line 127
    min = 1024;
#line 128
    max = 8192;
#line 129
    packet_start(34);
#line 130
    packet_put_int((unsigned int )min);
#line 131
    packet_put_int((unsigned int )nbits);
#line 132
    packet_put_int((unsigned int )max);
  }
#line 138
  packet_send();
#line 140
  debug("expecting SSH2_MSG_KEX_DH_GEX_GROUP");
#line 141
  packet_read_expect(& plen, 31);
#line 143
  p = BN_new();
#line 143
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 144
    fatal("BN_new");
  }
#line 145
  packet_get_bignum2(p, & dlen);
#line 146
  g = BN_new();
#line 146
  if ((unsigned int )g == (unsigned int )((void *)0)) {
#line 147
    fatal("BN_new");
  }
#line 148
  packet_get_bignum2(g, & dlen);
#line 149
  while (1) {
#line 149
    tmp = packet_remaining();
#line 149
    _len = tmp;
#line 149
    if (_len > 0) {
#line 149
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kexgex.c",
          149);
#line 149
      packet_disconnect("Packet integrity error.");
    }
#line 149
    break;
  }
#line 151
  tmp___1 = BN_num_bits((BIGNUM const   *)p);
#line 151
  if (tmp___1 < min) {
#line 152
    tmp___0 = BN_num_bits((BIGNUM const   *)p);
#line 152
    fatal("DH_GEX group out of range: %d !< %d !< %d", min, tmp___0, max);
  } else {
#line 151
    tmp___2 = BN_num_bits((BIGNUM const   *)p);
#line 151
    if (tmp___2 > max) {
#line 152
      tmp___0 = BN_num_bits((BIGNUM const   *)p);
#line 152
      fatal("DH_GEX group out of range: %d !< %d !< %d", min, tmp___0, max);
    }
  }
#line 155
  dh = dh_new_group(g, p);
#line 156
  dh_gen_key(dh, kex->we_need * 8);
#line 165
  debug("SSH2_MSG_KEX_DH_GEX_INIT sent");
#line 167
  packet_start(32);
#line 168
  packet_put_bignum2(dh->pub_key);
#line 169
  packet_send();
#line 171
  debug("expecting SSH2_MSG_KEX_DH_GEX_REPLY");
#line 172
  packet_read_expect(& plen, 33);
#line 175
  tmp___3 = packet_get_string(& sbloblen);
#line 175
  server_host_key_blob = (u_char *)tmp___3;
#line 176
  server_host_key = key_from_blob((char *)server_host_key_blob, (int )sbloblen);
#line 177
  if ((unsigned int )server_host_key == (unsigned int )((void *)0)) {
#line 178
    fatal("cannot decode server_host_key_blob");
  }
#line 180
  if ((unsigned int )kex->check_host_key == (unsigned int )((void *)0)) {
#line 181
    fatal("cannot check server_host_key");
  }
#line 182
  (*(kex->check_host_key))(server_host_key);
#line 185
  dh_server_pub = BN_new();
#line 186
  if ((unsigned int )dh_server_pub == (unsigned int )((void *)0)) {
#line 187
    fatal("dh_server_pub == NULL");
  }
#line 188
  packet_get_bignum2(dh_server_pub, & dlen);
#line 198
  tmp___4 = packet_get_string(& slen);
#line 198
  signature = (u_char *)tmp___4;
#line 199
  while (1) {
#line 199
    tmp___5 = packet_remaining();
#line 199
    _len___0 = tmp___5;
#line 199
    if (_len___0 > 0) {
#line 199
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "kexgex.c",
          199);
#line 199
      packet_disconnect("Packet integrity error.");
    }
#line 199
    break;
  }
#line 201
  tmp___6 = dh_pub_is_valid(dh, dh_server_pub);
#line 201
  if (! tmp___6) {
#line 202
    packet_disconnect("bad server public DH value");
  }
#line 204
  tmp___7 = DH_size((DH const   *)dh);
#line 204
  klen = (unsigned int )tmp___7;
#line 205
  tmp___8 = xmalloc(klen);
#line 205
  kbuf = (u_char *)tmp___8;
#line 206
  tmp___9 = DH_compute_key(kbuf, (BIGNUM const   *)dh_server_pub, dh);
#line 206
  kout = (unsigned int )tmp___9;
#line 210
  shared_secret = BN_new();
#line 211
  BN_bin2bn((unsigned char const   *)kbuf, (int )kout, shared_secret);
#line 212
  memset((void *)kbuf, 0, klen);
#line 213
  xfree((void *)kbuf);
#line 215
  if (datafellows & 16384) {
#line 216
    max = -1;
#line 216
    min = max;
  }
#line 219
  tmp___10 = buffer_len(& kex->peer);
#line 219
  tmp___11 = buffer_ptr(& kex->peer);
#line 219
  tmp___12 = buffer_len(& kex->my);
#line 219
  tmp___13 = buffer_ptr(& kex->my);
#line 219
  hash = kexgex_hash(kex->client_version_string, kex->server_version_string, tmp___13,
                     (int )tmp___12, tmp___11, (int )tmp___10, (char *)server_host_key_blob,
                     (int )sbloblen, min, nbits, max, dh->p, dh->g, dh->pub_key, dh_server_pub,
                     shared_secret);
#line 232
  DH_free(dh);
#line 233
  xfree((void *)server_host_key_blob);
#line 234
  BN_free(dh_server_pub);
#line 236
  tmp___14 = key_verify(server_host_key, signature, (int )slen, hash, 20);
#line 236
  if (tmp___14 != 1) {
#line 237
    fatal("key_verify failed for server_host_key");
  }
#line 238
  key_free(server_host_key);
#line 239
  xfree((void *)signature);
#line 242
  if ((unsigned int )kex->session_id == (unsigned int )((void *)0)) {
#line 243
    kex->session_id_len = 20;
#line 244
    tmp___15 = xmalloc((unsigned int )kex->session_id_len);
#line 244
    kex->session_id = (u_char *)tmp___15;
#line 245
    memcpy((void * __restrict  )kex->session_id, (void const   * __restrict  )hash,
           (unsigned int )kex->session_id_len);
  }
#line 247
  kex_derive_keys(kex, hash, shared_secret);
#line 248
  BN_clear_free(shared_secret);
#line 250
  kex_finish(kex);
#line 251
  return;
}
}
#line 255 "kexgex.c"
void kexgex_server(Kex *kex ) 
{ BIGNUM *shared_secret ;
  BIGNUM *dh_client_pub ;
  Key *server_host_key ;
  DH *dh ;
  u_char *kbuf ;
  u_char *hash ;
  u_char *signature ;
  u_char *server_host_key_blob ;
  u_int sbloblen ;
  u_int klen ;
  u_int kout ;
  int min ;
  int max ;
  int nbits ;
  int type ;
  int plen ;
  int dlen ;
  int slen ;
  u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  int _len ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  u_int tmp___8 ;
  char *tmp___9 ;
  u_int tmp___10 ;
  char *tmp___11 ;
  void *tmp___12 ;

  {
#line 258
  shared_secret = (BIGNUM *)((void *)0);
#line 258
  dh_client_pub = (BIGNUM *)((void *)0);
#line 260
  dh = dh;
#line 261
  signature = (u_char *)((void *)0);
#line 261
  server_host_key_blob = (u_char *)((void *)0);
#line 263
  min = -1;
#line 263
  max = -1;
#line 263
  nbits = -1;
#line 265
  if ((unsigned int )kex->load_host_key == (unsigned int )((void *)0)) {
#line 266
    fatal("Cannot load hostkey");
  }
#line 267
  server_host_key = (*(kex->load_host_key))(kex->hostkey_type);
#line 268
  if ((unsigned int )server_host_key == (unsigned int )((void *)0)) {
#line 269
    fatal("Unsupported hostkey type %d", kex->hostkey_type);
  }
#line 271
  type = packet_read(& plen);
#line 272
  switch (type) {
  case 34: 
#line 274
  debug("SSH2_MSG_KEX_DH_GEX_REQUEST received");
#line 275
  tmp = packet_get_int();
#line 275
  min = (int )tmp;
#line 276
  tmp___0 = packet_get_int();
#line 276
  nbits = (int )tmp___0;
#line 277
  tmp___1 = packet_get_int();
#line 277
  max = (int )tmp___1;
#line 278
  if (1024 > min) {
#line 278
    min = 1024;
  } else {
#line 278
    min = min;
  }
#line 279
  if (8192 < max) {
#line 279
    max = 8192;
  } else {
#line 279
    max = max;
  }
#line 280
  break;
  case 30: 
#line 282
  debug("SSH2_MSG_KEX_DH_GEX_REQUEST_OLD received");
#line 283
  tmp___2 = packet_get_int();
#line 283
  nbits = (int )tmp___2;
#line 284
  min = 1024;
#line 285
  max = 8192;
#line 287
  break;
  default: 
#line 289
  fatal("protocol error during kex, no DH_GEX_REQUEST: %d", type);
  }
#line 291
  while (1) {
#line 291
    tmp___3 = packet_remaining();
#line 291
    _len = tmp___3;
#line 291
    if (_len > 0) {
#line 291
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kexgex.c",
          291);
#line 291
      packet_disconnect("Packet integrity error.");
    }
#line 291
    break;
  }
#line 293
  if (max < min) {
#line 294
    fatal("DH_GEX_REQUEST, bad parameters: %d !< %d !< %d", min, nbits, max);
  } else {
#line 293
    if (nbits < min) {
#line 294
      fatal("DH_GEX_REQUEST, bad parameters: %d !< %d !< %d", min, nbits, max);
    } else {
#line 293
      if (max < nbits) {
#line 294
        fatal("DH_GEX_REQUEST, bad parameters: %d !< %d !< %d", min, nbits, max);
      }
    }
  }
#line 297
  dh = choose_dh(min, nbits, max);
#line 298
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 299
    packet_disconnect("Protocol error: no matching DH grp found");
  }
#line 301
  debug("SSH2_MSG_KEX_DH_GEX_GROUP sent");
#line 302
  packet_start(31);
#line 303
  packet_put_bignum2(dh->p);
#line 304
  packet_put_bignum2(dh->g);
#line 305
  packet_send();
#line 308
  packet_write_wait();
#line 311
  dh_gen_key(dh, kex->we_need * 8);
#line 313
  debug("expecting SSH2_MSG_KEX_DH_GEX_INIT");
#line 314
  packet_read_expect(& plen, 32);
#line 317
  dh_client_pub = BN_new();
#line 318
  if ((unsigned int )dh_client_pub == (unsigned int )((void *)0)) {
#line 319
    fatal("dh_client_pub == NULL");
  }
#line 320
  packet_get_bignum2(dh_client_pub, & dlen);
#line 335
  tmp___4 = dh_pub_is_valid(dh, dh_client_pub);
#line 335
  if (! tmp___4) {
#line 336
    packet_disconnect("bad client public DH value");
  }
#line 338
  tmp___5 = DH_size((DH const   *)dh);
#line 338
  klen = (unsigned int )tmp___5;
#line 339
  tmp___6 = xmalloc(klen);
#line 339
  kbuf = (u_char *)tmp___6;
#line 340
  tmp___7 = DH_compute_key(kbuf, (BIGNUM const   *)dh_client_pub, dh);
#line 340
  kout = (unsigned int )tmp___7;
#line 344
  shared_secret = BN_new();
#line 345
  BN_bin2bn((unsigned char const   *)kbuf, (int )kout, shared_secret);
#line 346
  memset((void *)kbuf, 0, klen);
#line 347
  xfree((void *)kbuf);
#line 349
  key_to_blob(server_host_key, & server_host_key_blob, & sbloblen);
#line 351
  if (type == 30) {
#line 352
    max = -1;
#line 352
    min = max;
  }
#line 355
  tmp___8 = buffer_len(& kex->my);
#line 355
  tmp___9 = buffer_ptr(& kex->my);
#line 355
  tmp___10 = buffer_len(& kex->peer);
#line 355
  tmp___11 = buffer_ptr(& kex->peer);
#line 355
  hash = kexgex_hash(kex->client_version_string, kex->server_version_string, tmp___11,
                     (int )tmp___10, tmp___9, (int )tmp___8, (char *)server_host_key_blob,
                     (int )sbloblen, min, nbits, max, dh->p, dh->g, dh_client_pub,
                     dh->pub_key, shared_secret);
#line 367
  BN_free(dh_client_pub);
#line 371
  if ((unsigned int )kex->session_id == (unsigned int )((void *)0)) {
#line 372
    kex->session_id_len = 20;
#line 373
    tmp___12 = xmalloc((unsigned int )kex->session_id_len);
#line 373
    kex->session_id = (u_char *)tmp___12;
#line 374
    memcpy((void * __restrict  )kex->session_id, (void const   * __restrict  )hash,
           (unsigned int )kex->session_id_len);
  }
#line 379
  key_sign(server_host_key, & signature, & slen, hash, 20);
#line 384
  debug("SSH2_MSG_KEX_DH_GEX_REPLY sent");
#line 385
  packet_start(33);
#line 386
  packet_put_string((char const   *)((char *)server_host_key_blob), sbloblen);
#line 387
  packet_put_bignum2(dh->pub_key);
#line 388
  packet_put_string((char const   *)((char *)signature), (unsigned int )slen);
#line 389
  packet_send();
#line 390
  xfree((void *)signature);
#line 391
  xfree((void *)server_host_key_blob);
#line 393
  DH_free(dh);
#line 395
  kex_derive_keys(kex, hash, shared_secret);
#line 396
  BN_clear_free(shared_secret);
#line 398
  kex_finish(kex);
#line 399
  return;
}
}
#line 401 "kexgex.c"
void kexgex(Kex *kex ) 
{ 

  {
#line 404
  if (kex->server) {
#line 405
    kexgex_server(kex);
  } else {
#line 407
    kexgex_client(kex);
  }
#line 408
  return;
}
}
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 1 "log.o"
#pragma merger(0,"./log.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 361 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 646 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 175 "/usr/include/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 49 "log.h"
void log_init(char *av0 , LogLevel level , SyslogFacility facility , int on_stderr ) ;
#line 52
void do_log(LogLevel level , char const   *fmt , va_list args ) ;
#line 55
SyslogFacility log_facility_number(char *name ) ;
#line 56
LogLevel log_level_number(char *name ) ;
#line 78
void fatal_remove_cleanup(void (*proc)(void *context ) , void *context ) ;
#line 44 "log.c"
static LogLevel log_level  =    3;
#line 45 "log.c"
static int log_on_stderr  =    1;
#line 46 "log.c"
static int log_facility  =    4 << 3;
#line 47 "log.c"
static char *argv0  ;
#line 53 "log.c"
static struct __anonstruct_log_facilities_65 log_facilities[13]  = 
#line 53
  {      {"DAEMON", 0}, 
        {"USER", 1}, 
        {"AUTH", 2}, 
        {"AUTHPRIV", 3}, 
        {"LOCAL0", 4}, 
        {"LOCAL1", 5}, 
        {"LOCAL2", 6}, 
        {"LOCAL3", 7}, 
        {"LOCAL4", 8}, 
        {"LOCAL5", 9}, 
        {"LOCAL6", 10}, 
        {"LOCAL7", 11}, 
        {(char const   *)((void *)0), (SyslogFacility )0}};
#line 74 "log.c"
static struct __anonstruct_log_levels_66 log_levels[10]  = 
#line 74
  {      {"QUIET", 0}, 
        {"FATAL", 1}, 
        {"ERROR", 2}, 
        {"INFO", 3}, 
        {"VERBOSE", 4}, 
        {"DEBUG", 5}, 
        {"DEBUG1", 5}, 
        {"DEBUG2", 6}, 
        {"DEBUG3", 7}, 
        {(char const   *)((void *)0), (LogLevel )0}};
#line 91 "log.c"
SyslogFacility log_facility_number(char *name ) 
{ int i ;
  int tmp ;

  {
#line 95
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 96
    i = 0;
#line 96
    while (log_facilities[i].name) {
#line 97
      tmp = strcasecmp(log_facilities[i].name, (char const   *)name);
#line 97
      if (tmp == 0) {
#line 98
        return (log_facilities[i].val);
      }
#line 96
      i ++;
    }
  }
#line 99
  return ((enum __anonenum_SyslogFacility_63 )-1);
}
}
#line 102 "log.c"
LogLevel log_level_number(char *name ) 
{ int i ;
  int tmp ;

  {
#line 106
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 107
    i = 0;
#line 107
    while (log_levels[i].name) {
#line 108
      tmp = strcasecmp(log_levels[i].name, (char const   *)name);
#line 108
      if (tmp == 0) {
#line 109
        return (log_levels[i].val);
      }
#line 107
      i ++;
    }
  }
#line 110
  return ((enum __anonenum_LogLevel_64 )-1);
}
}
#line 114 "log.c"
void ( /* format attribute */  fatal)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 118
  __builtin_va_start(args, fmt);
#line 119
  do_log(1, fmt, args);
#line 120
  __builtin_va_end(args);
#line 121
  fatal_cleanup();
#line 122
  return;
}
}
#line 126 "log.c"
void ( /* format attribute */  error)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 130
  __builtin_va_start(args, fmt);
#line 131
  do_log(2, fmt, args);
#line 132
  __builtin_va_end(args);
#line 133
  return;
}
}
#line 137 "log.c"
void ( /* format attribute */  log)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 141
  __builtin_va_start(args, fmt);
#line 142
  do_log(3, fmt, args);
#line 143
  __builtin_va_end(args);
#line 144
  return;
}
}
#line 148 "log.c"
void ( /* format attribute */  verbose)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 152
  __builtin_va_start(args, fmt);
#line 153
  do_log(4, fmt, args);
#line 154
  __builtin_va_end(args);
#line 155
  return;
}
}
#line 159 "log.c"
void ( /* format attribute */  debug)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 163
  __builtin_va_start(args, fmt);
#line 164
  do_log(5, fmt, args);
#line 165
  __builtin_va_end(args);
#line 166
  return;
}
}
#line 168 "log.c"
void ( /* format attribute */  debug2)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 172
  __builtin_va_start(args, fmt);
#line 173
  do_log(6, fmt, args);
#line 174
  __builtin_va_end(args);
#line 175
  return;
}
}
#line 177 "log.c"
void ( /* format attribute */  debug3)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 181
  __builtin_va_start(args, fmt);
#line 182
  do_log(7, fmt, args);
#line 183
  __builtin_va_end(args);
#line 184
  return;
}
}
#line 194 "log.c"
static struct fatal_cleanup *fatal_cleanups  =    (struct fatal_cleanup *)((void *)0);
#line 198 "log.c"
void fatal_add_cleanup(void (*proc)(void *context ) , void *context ) 
{ struct fatal_cleanup *cu ;
  void *tmp ;

  {
#line 203
  tmp = xmalloc(sizeof(*cu));
#line 203
  cu = (struct fatal_cleanup *)tmp;
#line 204
  cu->proc = proc;
#line 205
  cu->context = context;
#line 206
  cu->next = fatal_cleanups;
#line 207
  fatal_cleanups = cu;
#line 208
  return;
}
}
#line 212 "log.c"
void fatal_remove_cleanup(void (*proc)(void *context ) , void *context ) 
{ struct fatal_cleanup **cup ;
  struct fatal_cleanup *cu ;

  {
#line 217
  cup = & fatal_cleanups;
#line 217
  while (*cup) {
#line 218
    cu = *cup;
#line 219
    if ((unsigned int )cu->proc == (unsigned int )proc) {
#line 219
      if ((unsigned int )cu->context == (unsigned int )context) {
#line 220
        *cup = cu->next;
#line 221
        xfree((void *)cu);
#line 222
        return;
      }
    }
#line 217
    cup = & cu->next;
  }
#line 225
  fatal("fatal_remove_cleanup: no such cleanup function: 0x%lx 0x%lx", (unsigned long )proc,
        (unsigned long )context);
#line 227
  return;
}
}
#line 234 "log.c"
static int called  =    0;
#line 230 "log.c"
void fatal_cleanup(void) 
{ struct fatal_cleanup *cu ;
  struct fatal_cleanup *next_cu ;

  {
#line 236
  if (called) {
#line 237
    exit(255);
  }
#line 238
  called = 1;
#line 240
  cu = fatal_cleanups;
#line 240
  while (cu) {
#line 241
    next_cu = cu->next;
#line 242
    debug("Calling cleanup 0x%lx(0x%lx)", (unsigned long )cu->proc, (unsigned long )cu->context);
#line 244
    (*(cu->proc))(cu->context);
#line 240
    cu = next_cu;
  }
#line 246
  exit(255);
}
}
#line 254 "log.c"
void log_init(char *av0 , LogLevel level , SyslogFacility facility , int on_stderr ) 
{ 

  {
#line 257
  argv0 = av0;
#line 259
  switch ((int )level) {
  case 0: 
  case 1: 
  case 2: 
  case 3: 
  case 4: 
  case 5: 
  case 6: 
  case 7: 
#line 268
  log_level = level;
#line 269
  break;
  default: 
#line 271
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized internal syslog level code %d\n",
          (int )level);
#line 273
  exit(1);
  }
#line 276
  log_on_stderr = on_stderr;
#line 277
  if (on_stderr) {
#line 278
    return;
  }
#line 280
  switch ((int )facility) {
  case 0: 
#line 282
  log_facility = 3 << 3;
#line 283
  break;
  case 1: 
#line 285
  log_facility = 1 << 3;
#line 286
  break;
  case 2: 
#line 288
  log_facility = 4 << 3;
#line 289
  break;
  case 3: 
#line 292
  log_facility = 10 << 3;
#line 293
  break;
  case 4: 
#line 296
  log_facility = 16 << 3;
#line 297
  break;
  case 5: 
#line 299
  log_facility = 17 << 3;
#line 300
  break;
  case 6: 
#line 302
  log_facility = 18 << 3;
#line 303
  break;
  case 7: 
#line 305
  log_facility = 19 << 3;
#line 306
  break;
  case 8: 
#line 308
  log_facility = 20 << 3;
#line 309
  break;
  case 9: 
#line 311
  log_facility = 21 << 3;
#line 312
  break;
  case 10: 
#line 314
  log_facility = 22 << 3;
#line 315
  break;
  case 11: 
#line 317
  log_facility = 23 << 3;
#line 318
  break;
  default: 
#line 320
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized internal syslog facility code %d\n",
          (int )facility);
#line 323
  exit(1);
  }
#line 325
  return;
}
}
#line 329 "log.c"
void do_log(LogLevel level , char const   *fmt , va_list args ) 
{ char msgbuf[1024] ;
  char fmtbuf[1024] ;
  char *txt ;
  int pri ;
  char *tmp ;

  {
#line 334
  txt = (char *)((void *)0);
#line 335
  pri = 6;
#line 337
  if ((int )level > (int )log_level) {
#line 338
    return;
  }
#line 340
  switch ((int )level) {
  case 1: 
#line 342
  if (! log_on_stderr) {
#line 343
    txt = (char *)"fatal";
  }
#line 344
  pri = 2;
#line 345
  break;
  case 2: 
#line 347
  if (! log_on_stderr) {
#line 348
    txt = (char *)"error";
  }
#line 349
  pri = 3;
#line 350
  break;
  case 3: 
#line 352
  pri = 6;
#line 353
  break;
  case 4: 
#line 355
  pri = 6;
#line 356
  break;
  case 5: 
#line 358
  txt = (char *)"debug1";
#line 359
  pri = 7;
#line 360
  break;
  case 6: 
#line 362
  txt = (char *)"debug2";
#line 363
  pri = 7;
#line 364
  break;
  case 7: 
#line 366
  txt = (char *)"debug3";
#line 367
  pri = 7;
#line 368
  break;
  default: 
#line 370
  txt = (char *)"internal error";
#line 371
  pri = 3;
#line 372
  break;
  }
#line 374
  if ((unsigned int )txt != (unsigned int )((void *)0)) {
#line 375
    snprintf((char * __restrict  )(fmtbuf), sizeof(fmtbuf), (char const   * __restrict  )"%s: %s",
             txt, fmt);
#line 376
    vsnprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )(fmtbuf),
              args);
  } else {
#line 378
    vsnprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )fmt,
              args);
  }
#line 380
  if (log_on_stderr) {
#line 381
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\r\n", msgbuf);
  } else {
#line 383
    if (argv0) {
#line 383
      tmp = argv0;
    } else {
#line 383
      tmp = __progname;
    }
#line 383
    openlog((char const   *)tmp, 1, log_facility);
#line 384
    syslog(pri, "%.500s", msgbuf);
#line 385
    closelog();
  }
#line 387
  return;
}
}
#line 1 "match.o"
#pragma merger(0,"./match.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 116 "/usr/include/ctype.h"
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 23 "match.h"
int match_pattern(char const   *s , char const   *pattern ) ;
#line 48 "match.c"
int match_pattern(char const   *s , char const   *pattern ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 51
  while (1) {
#line 53
    if (! *pattern) {
#line 54
      return (! *s);
    }
#line 56
    if ((int const   )*pattern == 42) {
#line 58
      pattern ++;
#line 61
      if (! *pattern) {
#line 62
        return (1);
      }
#line 65
      if ((int const   )*pattern != 63) {
#line 65
        if ((int const   )*pattern != 42) {
#line 71
          while (*s) {
#line 72
            if ((int const   )*s == (int const   )*pattern) {
#line 72
              tmp = match_pattern(s + 1, pattern + 1);
#line 72
              if (tmp) {
#line 74
                return (1);
              }
            }
#line 71
            s ++;
          }
#line 76
          return (0);
        }
      }
#line 82
      while (*s) {
#line 83
        tmp___0 = match_pattern(s, pattern);
#line 83
        if (tmp___0) {
#line 84
          return (1);
        }
#line 82
        s ++;
      }
#line 86
      return (0);
    }
#line 92
    if (! *s) {
#line 93
      return (0);
    }
#line 96
    if ((int const   )*pattern != 63) {
#line 96
      if ((int const   )*pattern != (int const   )*s) {
#line 97
        return (0);
      }
    }
#line 100
    s ++;
#line 101
    pattern ++;
  }
}
}
#line 113 "match.c"
int match_hostname(char const   *host , char const   *pattern , u_int len ) 
{ char sub[1024] ;
  int negated ;
  int got_positive ;
  u_int i ;
  u_int subi ;
  int __res___0 ;
  __int32_t const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;

  {
#line 121
  got_positive = 0;
#line 122
  i = 0U;
#line 122
  while (i < len) {
#line 124
    if ((int const   )*(pattern + i) == 33) {
#line 125
      negated = 1;
#line 126
      i ++;
    } else {
#line 128
      negated = 0;
    }
#line 134
    subi = 0U;
#line 134
    while (1) {
#line 134
      if (i < len) {
#line 134
        if (subi < sizeof(sub) - 1U) {
#line 134
          if (! ((int const   )*(pattern + i) != 44)) {
#line 134
            break;
          }
        } else {
#line 134
          break;
        }
      } else {
#line 134
        break;
      }
#line 137
      tmp___6 = __ctype_b_loc();
#line 137
      if ((int const   )*(*tmp___6 + (int )*(pattern + i)) & 256) {
#line 137
        if (sizeof(*(pattern + i)) > 1U) {
#line 137
          __res___0 = tolower((int )*(pattern + i));
        } else {
#line 137
          tmp___5 = __ctype_tolower_loc();
#line 137
          __res___0 = (int )*(*tmp___5 + (int )*(pattern + i));
        }
#line 137
        sub[subi] = (char )__res___0;
      } else {
#line 137
        sub[subi] = (char )*(pattern + i);
      }
#line 134
      subi ++;
#line 134
      i ++;
    }
#line 139
    if (subi >= sizeof(sub) - 1U) {
#line 140
      return (0);
    }
#line 143
    if (i < len) {
#line 143
      if ((int const   )*(pattern + i) == 44) {
#line 144
        i ++;
      }
    }
#line 147
    sub[subi] = (char )'\000';
#line 150
    tmp___7 = match_pattern(host, (char const   *)(sub));
#line 150
    if (tmp___7) {
#line 151
      if (negated) {
#line 152
        return (-1);
      } else {
#line 154
        got_positive = 1;
      }
    }
  }
#line 162
  return (got_positive);
}
}
#line 168 "match.c"
char *match_list(char const   *client , char const   *server , u_int *next ) 
{ char *sproposals[20] ;
  char *c ;
  char *s ;
  char *p ;
  char *ret ;
  char *cp ;
  char *sp ;
  int i ;
  int j ;
  int nproposals ;
  char *tmp___14 ;
  char *tmp___30 ;
  char *tmp___46 ;
  char *tmp___62 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___69 ;
  int tmp___72 ;
  int tmp___73 ;

  {
#line 175
  cp = xstrdup(client);
#line 175
  c = cp;
#line 176
  sp = xstrdup(server);
#line 176
  s = sp;
#line 178
  tmp___14 = __strsep_g(& sp, ",");
#line 178
  p = tmp___14;
#line 178
  i = 0;
#line 178
  while (1) {
#line 178
    if (p) {
#line 178
      if (! ((int )*p != 0)) {
#line 178
        break;
      }
    } else {
#line 178
      break;
    }
#line 180
    if (i < 20) {
#line 181
      sproposals[i] = p;
    } else {
#line 183
      break;
    }
#line 179
    tmp___30 = __strsep_g(& sp, ",");
#line 179
    p = tmp___30;
#line 179
    i ++;
  }
#line 185
  nproposals = i;
#line 187
  tmp___46 = __strsep_g(& cp, ",");
#line 187
  p = tmp___46;
#line 187
  i = 0;
#line 187
  while (1) {
#line 187
    if (p) {
#line 187
      if (! ((int )*p != 0)) {
#line 187
        break;
      }
    } else {
#line 187
      break;
    }
#line 189
    j = 0;
#line 189
    while (j < nproposals) {
#line 190
      if (0) {
#line 190
        __s1_len = strlen((char const   *)p);
#line 190
        __s2_len = strlen((char const   *)sproposals[j]);
#line 190
        if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
          goto _L___0;
        } else {
#line 190
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 190
            if (! ((unsigned int )((void const   *)(sproposals[j] + 1)) - (unsigned int )((void const   *)sproposals[j]) == 1U)) {
#line 190
              tmp___73 = 1;
            } else {
#line 190
              if (__s2_len >= 4U) {
#line 190
                tmp___73 = 1;
              } else {
#line 190
                tmp___73 = 0;
              }
            }
          } else {
#line 190
            tmp___73 = 0;
          }
        }
#line 190
        if (tmp___73) {
#line 190
          tmp___69 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
        } else {
#line 190
          tmp___72 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
#line 190
          tmp___69 = tmp___72;
        }
      } else {
#line 190
        tmp___72 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
#line 190
        tmp___69 = tmp___72;
      }
#line 190
      if (tmp___69 == 0) {
#line 191
        ret = xstrdup((char const   *)p);
#line 192
        if ((unsigned int )next != (unsigned int )((void *)0)) {
#line 193
          if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 193
            *next = strlen((char const   *)c);
          } else {
#line 193
            *next = (unsigned int )(cp - c);
          }
        }
#line 195
        xfree((void *)c);
#line 196
        xfree((void *)s);
#line 197
        return (ret);
      }
#line 189
      j ++;
    }
#line 188
    tmp___62 = __strsep_g(& cp, ",");
#line 188
    p = tmp___62;
#line 188
    i ++;
  }
#line 201
  if ((unsigned int )next != (unsigned int )((void *)0)) {
#line 202
    *next = strlen((char const   *)c);
  }
#line 203
  xfree((void *)c);
#line 204
  xfree((void *)s);
#line 205
  return ((char *)((void *)0));
}
}
/* compiler builtin: 
   char *__builtin_strpbrk(char const   * , char const   * ) ;  */
/* compiler builtin: 
   unsigned int __builtin_strspn(char const   * , char const   * ) ;  */
#line 1 "misc.o"
#pragma merger(0,"./misc.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 184 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 15 "misc.h"
char *chop(char *s ) ;
#line 23
struct passwd *pwcopy(struct passwd *pw ) ;
#line 30
int a2port(char const   *s ) ;
#line 34
mysig_t mysignal(int sig , void (*act)(int  ) ) ;
#line 34 "misc.c"
char *chop(char *s ) 
{ char *t ;

  {
#line 37
  t = s;
#line 38
  while (*t) {
#line 39
    if ((int )*t == 10) {
#line 40
      *t = (char )'\000';
#line 41
      return (s);
    } else {
#line 39
      if ((int )*t == 13) {
#line 40
        *t = (char )'\000';
#line 41
        return (s);
      }
    }
#line 43
    t ++;
  }
#line 45
  return (s);
}
}
#line 49 "misc.c"
void set_nonblock(int fd ) 
{ int val ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
#line 53
  val = fcntl(fd, 3, 0);
#line 54
  if (val < 0) {
#line 55
    tmp = __errno_location();
#line 55
    tmp___0 = strerror(*tmp);
#line 55
    error("fcntl(%d, F_GETFL, 0): %s", fd, tmp___0);
#line 56
    return;
  }
#line 58
  if (val & 2048) {
#line 59
    debug("fd %d IS O_NONBLOCK", fd);
#line 60
    return;
  }
#line 62
  debug("fd %d setting O_NONBLOCK", fd);
#line 63
  val |= 2048;
#line 64
  tmp___4 = fcntl(fd, 4, val);
#line 64
  if (tmp___4 == -1) {
#line 65
    tmp___3 = __errno_location();
#line 65
    if (*tmp___3 != 19) {
#line 66
      tmp___1 = __errno_location();
#line 66
      tmp___2 = strerror(*tmp___1);
#line 66
      error("fcntl(%d, F_SETFL, O_NONBLOCK): %s", fd, tmp___2);
    }
  }
#line 68
  return;
}
}
#line 73 "misc.c"
char *strdelim(char **s ) 
{ char *old ;
  int wspace ;
  char *tmp___30 ;
  unsigned int tmp___62 ;
  unsigned int tmp___94 ;

  {
#line 77
  wspace = 0;
#line 79
  if ((unsigned int )*s == (unsigned int )((void *)0)) {
#line 80
    return ((char *)((void *)0));
  }
#line 82
  old = *s;
#line 84
  tmp___30 = __builtin_strpbrk((char const   *)*s, " \t\r\n=");
#line 84
  *s = tmp___30;
#line 85
  if ((unsigned int )*s == (unsigned int )((void *)0)) {
#line 86
    return (old);
  }
#line 89
  if ((int )*(*(s + 0)) == 61) {
#line 90
    wspace = 1;
  }
#line 91
  *(*(s + 0)) = (char )'\000';
#line 93
  tmp___62 = __builtin_strspn((char const   *)(*s + 1), " \t\r\n");
#line 93
  *s += tmp___62 + 1U;
#line 94
  if ((int )*(*(s + 0)) == 61) {
#line 94
    if (! wspace) {
#line 95
      tmp___94 = __builtin_strspn((char const   *)(*s + 1), " \t\r\n");
#line 95
      *s += tmp___94 + 1U;
    }
  }
#line 97
  return (old);
}
}
#line 100 "misc.c"
struct passwd *pwcopy(struct passwd *pw ) 
{ struct passwd *copy ;
  void *tmp ;

  {
#line 103
  tmp = xmalloc(sizeof(*copy));
#line 103
  copy = (struct passwd *)tmp;
#line 105
  memset((void *)copy, 0, sizeof(*copy));
#line 106
  copy->pw_name = xstrdup((char const   *)pw->pw_name);
#line 107
  copy->pw_passwd = xstrdup((char const   *)pw->pw_passwd);
#line 108
  copy->pw_gecos = xstrdup((char const   *)pw->pw_gecos);
#line 109
  copy->pw_uid = pw->pw_uid;
#line 110
  copy->pw_gid = pw->pw_gid;
#line 114
  copy->pw_dir = xstrdup((char const   *)pw->pw_dir);
#line 115
  copy->pw_shell = xstrdup((char const   *)pw->pw_shell);
#line 116
  return (copy);
}
}
#line 119 "misc.c"
int a2port(char const   *s ) 
{ long port ;
  char *endp ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 124
  tmp = __errno_location();
#line 124
  *tmp = 0;
#line 125
  port = strtol((char const   * __restrict  )s, (char ** __restrict  )(& endp), 0);
#line 126
  if ((unsigned int )s == (unsigned int )endp) {
#line 129
    return (0);
  } else {
#line 126
    if ((int )*endp != 0) {
#line 129
      return (0);
    } else {
#line 126
      tmp___0 = __errno_location();
#line 126
      if (*tmp___0 == 34) {
#line 126
        if (port == (-0x7FFFFFFF-1)) {
#line 129
          return (0);
        } else {
#line 126
          if (port == 2147483647L) {
#line 129
            return (0);
          } else {
            goto _L;
          }
        }
      } else {
        _L: /* CIL Label */ 
#line 126
        if (port <= 0L) {
#line 129
          return (0);
        } else {
#line 126
          if (port > 65535L) {
#line 129
            return (0);
          }
        }
      }
    }
  }
#line 131
  return ((int )port);
}
}
#line 134 "misc.c"
mysig_t mysignal(int sig , void (*act)(int  ) ) 
{ struct sigaction sa ;
  struct sigaction osa___0 ;
  int tmp ;
  int tmp___0 ;

  {
#line 140
  tmp = sigaction(sig, (struct sigaction  const  * __restrict  )((void *)0), (struct sigaction * __restrict  )(& osa___0));
#line 140
  if (tmp == -1) {
#line 141
    return ((void (*)(int  ))-1);
  }
#line 142
  if ((unsigned int )osa___0.__sigaction_handler.sa_handler != (unsigned int )act) {
#line 143
    memset((void *)(& sa), 0, sizeof(sa));
#line 144
    sigemptyset(& sa.sa_mask);
#line 145
    sa.sa_flags = 0;
#line 147
    if (sig == 17) {
#line 148
      sa.sa_flags |= 268435456;
    }
#line 151
    if (sig == 14) {
#line 152
      sa.sa_flags |= 536870912;
    }
#line 154
    sa.__sigaction_handler.sa_handler = act;
#line 155
    tmp___0 = sigaction(sig, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
#line 155
    if (tmp___0 == -1) {
#line 156
      return ((void (*)(int  ))-1);
    }
  }
#line 158
  return (osa___0.__sigaction_handler.sa_handler);
}
}
#line 1 "mpaux.o"
#pragma merger(0,"./mpaux.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 25 "mpaux.h"
void compute_session_id(u_char *session_id___0 , u_char *cookie , BIGNUM *host_key_n ,
                        BIGNUM *session_key_n ) ;
#line 26 "mpaux.c"
void compute_session_id(u_char *session_id___0 , u_char *cookie , BIGNUM *host_key_n ,
                        BIGNUM *session_key_n ) 
{ u_int host_key_bytes ;
  int tmp ;
  u_int session_key_bytes ;
  int tmp___0 ;
  u_int bytes ;
  u_char *buf___2 ;
  void *tmp___1 ;
  MD5_CTX md ;

  {
#line 32
  tmp = BN_num_bits((BIGNUM const   *)host_key_n);
#line 32
  host_key_bytes = (u_int )((tmp + 7) / 8);
#line 33
  tmp___0 = BN_num_bits((BIGNUM const   *)session_key_n);
#line 33
  session_key_bytes = (u_int )((tmp___0 + 7) / 8);
#line 34
  bytes = host_key_bytes + session_key_bytes;
#line 35
  tmp___1 = xmalloc(bytes);
#line 35
  buf___2 = (u_char *)tmp___1;
#line 38
  BN_bn2bin((BIGNUM const   *)host_key_n, buf___2);
#line 39
  BN_bn2bin((BIGNUM const   *)session_key_n, buf___2 + host_key_bytes);
#line 40
  MD5_Init(& md);
#line 41
  MD5_Update(& md, (void const   *)buf___2, bytes);
#line 42
  MD5_Update(& md, (void const   *)cookie, 8U);
#line 43
  MD5_Final((unsigned char *)session_id___0, & md);
#line 44
  memset((void *)buf___2, 0, bytes);
#line 45
  xfree((void *)buf___2);
#line 46
  return;
}
}
#line 1 "nchan.o"
#pragma merger(0,"./nchan.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 42 "nchan.c"
chan_event_fn *chan_rcvd_oclose  =    (chan_event_fn *)((void *)0);
#line 43 "nchan.c"
chan_event_fn *chan_read_failed  =    (chan_event_fn *)((void *)0);
#line 44 "nchan.c"
chan_event_fn *chan_ibuf_empty  =    (chan_event_fn *)((void *)0);
#line 46 "nchan.c"
chan_event_fn *chan_rcvd_ieof  =    (chan_event_fn *)((void *)0);
#line 47 "nchan.c"
chan_event_fn *chan_write_failed  =    (chan_event_fn *)((void *)0);
#line 48 "nchan.c"
chan_event_fn *chan_obuf_empty  =    (chan_event_fn *)((void *)0);
#line 52
static void chan_send_ieof1(Channel *c ) ;
#line 53
static void chan_send_oclose1(Channel *c ) ;
#line 54
static void chan_send_close2(Channel *c ) ;
#line 55
static void chan_send_eof2(Channel *c ) ;
#line 58
static void chan_shutdown_write(Channel *c ) ;
#line 59
static void chan_shutdown_read(Channel *c ) ;
#line 65 "nchan.c"
static void chan_rcvd_oclose1(Channel *c ) 
{ 

  {
#line 68
  debug("channel %d: rcvd oclose", c->self);
#line 69
  switch (c->istate) {
  case 4: 
#line 71
  debug("channel %d: input wait_oclose -> closed", c->self);
#line 72
  c->istate = 8;
#line 73
  break;
  case 1: 
#line 75
  debug("channel %d: input open -> closed", c->self);
#line 76
  chan_shutdown_read(c);
#line 77
  chan_send_ieof1(c);
#line 78
  c->istate = 8;
#line 79
  break;
  case 2: 
#line 82
  log("channel %d: input drain -> closed", c->self);
#line 83
  chan_send_ieof1(c);
#line 84
  c->istate = 8;
#line 85
  break;
  default: 
#line 87
  error("channel %d: protocol error: chan_rcvd_oclose for istate %d", c->self, c->istate);
#line 89
  return;
  }
#line 91
  return;
}
}
#line 92 "nchan.c"
static void chan_read_failed_12(Channel *c ) 
{ u_int tmp ;

  {
#line 95
  debug("channel %d: read failed", c->self);
#line 96
  switch (c->istate) {
  case 1: 
#line 98
  debug("channel %d: input open -> drain", c->self);
#line 99
  chan_shutdown_read(c);
#line 100
  c->istate = 2;
#line 101
  tmp = buffer_len(& c->input);
#line 101
  if (tmp == 0U) {
#line 102
    debug("channel %d: input: no drain shortcut", c->self);
#line 103
    (*chan_ibuf_empty)(c);
  }
#line 105
  break;
  default: 
#line 107
  error("channel %d: internal error: we do not read, but chan_read_failed for istate %d",
        c->self, c->istate);
#line 109
  break;
  }
#line 111
  return;
}
}
#line 112 "nchan.c"
static void chan_ibuf_empty1(Channel *c ) 
{ u_int tmp ;

  {
#line 115
  debug("channel %d: ibuf empty", c->self);
#line 116
  tmp = buffer_len(& c->input);
#line 116
  if (tmp) {
#line 117
    error("channel %d: internal error: chan_ibuf_empty for non empty buffer", c->self);
#line 119
    return;
  }
#line 121
  switch (c->istate) {
  case 2: 
#line 123
  debug("channel %d: input drain -> wait_oclose", c->self);
#line 124
  chan_send_ieof1(c);
#line 125
  c->istate = 4;
#line 126
  break;
  default: 
#line 128
  error("channel %d: internal error: chan_ibuf_empty for istate %d", c->self, c->istate);
#line 130
  break;
  }
#line 132
  return;
}
}
#line 133 "nchan.c"
static void chan_rcvd_ieof1(Channel *c ) 
{ 

  {
#line 136
  debug("channel %d: rcvd ieof", c->self);
#line 137
  if (c->type != 4) {
#line 138
    debug("channel %d: non-open", c->self);
#line 139
    if (c->istate == 1) {
#line 140
      debug("channel %d: non-open: input open -> wait_oclose", c->self);
#line 141
      chan_shutdown_read(c);
#line 142
      chan_send_ieof1(c);
#line 143
      c->istate = 4;
    } else {
#line 145
      error("channel %d: istate %d != open", c->self, c->istate);
    }
#line 147
    if (c->ostate == 16) {
#line 148
      debug("channel %d: non-open: output open -> closed", c->self);
#line 149
      chan_send_oclose1(c);
#line 150
      c->ostate = 128;
    } else {
#line 152
      error("channel %d: ostate %d != open", c->self, c->ostate);
    }
#line 154
    return;
  }
#line 156
  switch (c->ostate) {
  case 16: 
#line 158
  debug("channel %d: output open -> drain", c->self);
#line 159
  c->ostate = 32;
#line 160
  break;
  case 64: 
#line 162
  debug("channel %d: output wait_ieof -> closed", c->self);
#line 163
  c->ostate = 128;
#line 164
  break;
  default: 
#line 166
  error("channel %d: protocol error: chan_rcvd_ieof for ostate %d", c->self, c->ostate);
#line 168
  break;
  }
#line 170
  return;
}
}
#line 171 "nchan.c"
static void chan_write_failed1(Channel *c ) 
{ 

  {
#line 174
  debug("channel %d: write failed", c->self);
#line 175
  switch (c->ostate) {
  case 16: 
#line 177
  debug("channel %d: output open -> wait_ieof", c->self);
#line 178
  chan_send_oclose1(c);
#line 179
  c->ostate = 64;
#line 180
  break;
  case 32: 
#line 182
  debug("channel %d: output wait_drain -> closed", c->self);
#line 183
  chan_send_oclose1(c);
#line 184
  c->ostate = 128;
#line 185
  break;
  default: 
#line 187
  error("channel %d: internal error: chan_write_failed for ostate %d", c->self, c->ostate);
#line 189
  break;
  }
#line 191
  return;
}
}
#line 192 "nchan.c"
static void chan_obuf_empty1(Channel *c ) 
{ u_int tmp ;

  {
#line 195
  debug("channel %d: obuf empty", c->self);
#line 196
  tmp = buffer_len(& c->output);
#line 196
  if (tmp) {
#line 197
    error("channel %d: internal error: chan_obuf_empty for non empty buffer", c->self);
#line 199
    return;
  }
#line 201
  switch (c->ostate) {
  case 32: 
#line 203
  debug("channel %d: output drain -> closed", c->self);
#line 204
  chan_send_oclose1(c);
#line 205
  c->ostate = 128;
#line 206
  break;
  default: 
#line 208
  error("channel %d: internal error: chan_obuf_empty for ostate %d", c->self, c->ostate);
#line 210
  break;
  }
#line 212
  return;
}
}
#line 213 "nchan.c"
static void chan_send_ieof1(Channel *c ) 
{ 

  {
#line 216
  debug("channel %d: send ieof", c->self);
#line 217
  switch (c->istate) {
  case 1: 
  case 2: 
#line 220
  packet_start(24);
#line 221
  packet_put_int((unsigned int )c->remote_id);
#line 222
  packet_send();
#line 223
  break;
  default: 
#line 225
  error("channel %d: internal error: cannot send ieof for istate %d", c->self, c->istate);
#line 227
  break;
  }
#line 229
  return;
}
}
#line 230 "nchan.c"
static void chan_send_oclose1(Channel *c ) 
{ u_int tmp ;

  {
#line 233
  debug("channel %d: send oclose", c->self);
#line 234
  switch (c->ostate) {
  case 16: 
  case 32: 
#line 237
  chan_shutdown_write(c);
#line 238
  tmp = buffer_len(& c->output);
#line 238
  buffer_consume(& c->output, tmp);
#line 239
  packet_start(25);
#line 240
  packet_put_int((unsigned int )c->remote_id);
#line 241
  packet_send();
#line 242
  break;
  default: 
#line 244
  error("channel %d: internal error: cannot send oclose for ostate %d", c->self, c->ostate);
#line 246
  break;
  }
#line 248
  return;
}
}
#line 253 "nchan.c"
static void chan_rcvd_oclose2(Channel *c ) 
{ 

  {
#line 256
  debug("channel %d: rcvd close", c->self);
#line 257
  if (c->flags & 2) {
#line 258
    error("channel %d: protocol error: close rcvd twice", c->self);
  }
#line 259
  c->flags |= 2;
#line 260
  if (c->type == 10) {
#line 262
    c->ostate = 128;
#line 263
    c->istate = 8;
#line 264
    return;
  }
#line 266
  switch (c->ostate) {
  case 16: 
#line 269
  debug("channel %d: output open -> drain", c->self);
#line 270
  c->ostate = 32;
#line 271
  break;
  }
#line 273
  switch (c->istate) {
  case 1: 
#line 275
  debug("channel %d: input open -> closed", c->self);
#line 276
  chan_shutdown_read(c);
#line 277
  break;
  case 2: 
#line 279
  debug("channel %d: input drain -> closed", c->self);
#line 280
  chan_send_eof2(c);
#line 281
  break;
  }
#line 283
  c->istate = 8;
#line 284
  return;
}
}
#line 285 "nchan.c"
static void chan_ibuf_empty2(Channel *c ) 
{ u_int tmp ;

  {
#line 288
  debug("channel %d: ibuf empty", c->self);
#line 289
  tmp = buffer_len(& c->input);
#line 289
  if (tmp) {
#line 290
    error("channel %d: internal error: chan_ibuf_empty for non empty buffer", c->self);
#line 292
    return;
  }
#line 294
  switch (c->istate) {
  case 2: 
#line 296
  debug("channel %d: input drain -> closed", c->self);
#line 297
  if (! (c->flags & 1)) {
#line 298
    chan_send_eof2(c);
  }
#line 299
  c->istate = 8;
#line 300
  break;
  default: 
#line 302
  error("channel %d: internal error: chan_ibuf_empty for istate %d", c->self, c->istate);
#line 304
  break;
  }
#line 306
  return;
}
}
#line 307 "nchan.c"
static void chan_rcvd_ieof2(Channel *c ) 
{ 

  {
#line 310
  debug("channel %d: rcvd eof", c->self);
#line 311
  if (c->ostate == 16) {
#line 312
    debug("channel %d: output open -> drain", c->self);
#line 313
    c->ostate = 32;
  }
#line 315
  return;
}
}
#line 316 "nchan.c"
static void chan_write_failed2(Channel *c ) 
{ 

  {
#line 319
  debug("channel %d: write failed", c->self);
#line 320
  switch (c->ostate) {
  case 16: 
#line 322
  debug("channel %d: output open -> closed", c->self);
#line 323
  chan_shutdown_write(c);
#line 324
  c->ostate = 128;
#line 325
  break;
  case 32: 
#line 327
  debug("channel %d: output drain -> closed", c->self);
#line 328
  chan_shutdown_write(c);
#line 329
  c->ostate = 128;
#line 330
  break;
  default: 
#line 332
  error("channel %d: internal error: chan_write_failed for ostate %d", c->self, c->ostate);
#line 334
  break;
  }
#line 336
  return;
}
}
#line 337 "nchan.c"
static void chan_obuf_empty2(Channel *c ) 
{ u_int tmp ;

  {
#line 340
  debug("channel %d: obuf empty", c->self);
#line 341
  tmp = buffer_len(& c->output);
#line 341
  if (tmp) {
#line 342
    error("internal error: chan_obuf_empty %d for non empty buffer", c->self);
#line 344
    return;
  }
#line 346
  switch (c->ostate) {
  case 32: 
#line 348
  debug("channel %d: output drain -> closed", c->self);
#line 349
  chan_shutdown_write(c);
#line 350
  c->ostate = 128;
#line 351
  break;
  default: 
#line 353
  error("channel %d: internal error: chan_obuf_empty for ostate %d", c->self, c->ostate);
#line 355
  break;
  }
#line 357
  return;
}
}
#line 358 "nchan.c"
static void chan_send_eof2(Channel *c ) 
{ 

  {
#line 361
  debug("channel %d: send eof", c->self);
#line 362
  switch (c->istate) {
  case 2: 
#line 364
  packet_start(96);
#line 365
  packet_put_int((unsigned int )c->remote_id);
#line 366
  packet_send();
#line 367
  break;
  default: 
#line 369
  error("channel %d: internal error: cannot send eof for istate %d", c->self, c->istate);
#line 371
  break;
  }
#line 373
  return;
}
}
#line 374 "nchan.c"
static void chan_send_close2(Channel *c ) 
{ 

  {
#line 377
  debug("channel %d: send close", c->self);
#line 378
  if (c->ostate != 128) {
#line 380
    error("channel %d: internal error: cannot send close for istate/ostate %d/%d",
          c->self, c->istate, c->ostate);
  } else {
#line 378
    if (c->istate != 8) {
#line 380
      error("channel %d: internal error: cannot send close for istate/ostate %d/%d",
            c->self, c->istate, c->ostate);
    } else {
#line 382
      if (c->flags & 1) {
#line 383
        error("channel %d: internal error: already sent close", c->self);
      } else {
#line 385
        packet_start(97);
#line 386
        packet_put_int((unsigned int )c->remote_id);
#line 387
        packet_send();
#line 388
        c->flags |= 1;
      }
    }
  }
#line 390
  return;
}
}
#line 394 "nchan.c"
int chan_is_dead(Channel *c ) 
{ char const   *tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;

  {
#line 397
  if (c->istate != 8) {
#line 398
    return (0);
  } else {
#line 397
    if (c->ostate != 128) {
#line 398
      return (0);
    }
  }
#line 399
  if (! compat20) {
#line 400
    debug("channel %d: is dead", c->self);
#line 401
    return (1);
  }
#line 407
  if (c->extended_usage != 0) {
#line 407
    tmp___1 = buffer_len(& c->extended);
#line 407
    if (tmp___1 > 0U) {
#line 414
      if (c->extended_usage == 1) {
#line 414
        tmp = "read";
      } else {
#line 414
        tmp = "write";
      }
#line 414
      tmp___0 = buffer_len(& c->extended);
#line 414
      debug2("channel %d: active efd: %d len %d type %s", c->self, c->efd, tmp___0,
             tmp);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 419
    if (! (c->flags & 1)) {
#line 420
      chan_send_close2(c);
    }
#line 422
    if (c->flags & 1) {
#line 422
      if (c->flags & 2) {
#line 424
        debug("channel %d: is dead", c->self);
#line 425
        return (1);
      }
    }
  }
#line 428
  return (0);
}
}
#line 431 "nchan.c"
void chan_init_iostates(Channel *c ) 
{ 

  {
#line 434
  c->ostate = 16;
#line 435
  c->istate = 1;
#line 436
  c->flags = 0;
#line 437
  return;
}
}
#line 440 "nchan.c"
void chan_init(void) 
{ 

  {
#line 443
  if (compat20) {
#line 444
    chan_rcvd_oclose = & chan_rcvd_oclose2;
#line 445
    chan_read_failed = & chan_read_failed_12;
#line 446
    chan_ibuf_empty = & chan_ibuf_empty2;
#line 448
    chan_rcvd_ieof = & chan_rcvd_ieof2;
#line 449
    chan_write_failed = & chan_write_failed2;
#line 450
    chan_obuf_empty = & chan_obuf_empty2;
  } else {
#line 452
    chan_rcvd_oclose = & chan_rcvd_oclose1;
#line 453
    chan_read_failed = & chan_read_failed_12;
#line 454
    chan_ibuf_empty = & chan_ibuf_empty1;
#line 456
    chan_rcvd_ieof = & chan_rcvd_ieof1;
#line 457
    chan_write_failed = & chan_write_failed1;
#line 458
    chan_obuf_empty = & chan_obuf_empty1;
  }
#line 460
  return;
}
}
#line 463 "nchan.c"
static void chan_shutdown_write(Channel *c ) 
{ u_int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 466
  tmp = buffer_len(& c->output);
#line 466
  buffer_consume(& c->output, tmp);
#line 467
  if (compat20) {
#line 467
    if (c->type == 10) {
#line 468
      return;
    }
  }
#line 470
  debug("channel %d: close_write", c->self);
#line 471
  if (c->sock != -1) {
#line 472
    tmp___2 = shutdown(c->sock, 1);
#line 472
    if (tmp___2 < 0) {
#line 473
      tmp___0 = __errno_location();
#line 473
      tmp___1 = strerror(*tmp___0);
#line 473
      debug("channel %d: chan_shutdown_write: shutdown() failed for fd%d: %.100s",
            c->self, c->sock, tmp___1);
    }
  } else {
#line 476
    tmp___5 = close(c->wfd);
#line 476
    if (tmp___5 < 0) {
#line 477
      tmp___3 = __errno_location();
#line 477
      tmp___4 = strerror(*tmp___3);
#line 477
      log("channel %d: chan_shutdown_write: close() failed for fd%d: %.100s", c->self,
          c->wfd, tmp___4);
    }
#line 479
    c->wfd = -1;
  }
#line 481
  return;
}
}
#line 482 "nchan.c"
static void chan_shutdown_read(Channel *c ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 485
  if (compat20) {
#line 485
    if (c->type == 10) {
#line 486
      return;
    }
  }
#line 487
  debug("channel %d: close_read", c->self);
#line 488
  if (c->sock != -1) {
#line 494
    tmp___1 = shutdown(c->sock, 0);
#line 494
    if (tmp___1 < 0) {
#line 494
      tmp___2 = __errno_location();
#line 494
      if (*tmp___2 != 107) {
#line 494
        tmp___3 = __errno_location();
#line 494
        if (*tmp___3 != 22) {
#line 496
          tmp = __errno_location();
#line 496
          tmp___0 = strerror(*tmp);
#line 496
          error("channel %d: chan_shutdown_read: shutdown() failed for fd%d [i%d o%d]: %.100s",
                c->self, c->sock, c->istate, c->ostate, tmp___0);
        }
      }
    }
  } else {
#line 499
    tmp___6 = close(c->rfd);
#line 499
    if (tmp___6 < 0) {
#line 500
      tmp___4 = __errno_location();
#line 500
      tmp___5 = strerror(*tmp___4);
#line 500
      log("channel %d: chan_shutdown_read: close() failed for fd%d: %.100s", c->self,
          c->rfd, tmp___5);
    }
#line 502
    c->rfd = -1;
  }
#line 504
  return;
}
}
#line 1 "packet.o"
#pragma merger(0,"./packet.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 26 "packet.h"
void packet_set_connection(int fd_in , int fd_out ) ;
#line 29
void packet_set_nonblocking(void) ;
#line 35
int packet_get_connection_out(void) ;
#line 41
void packet_close(void) ;
#line 48
void packet_set_encryption_key(u_char const   *key , u_int keylen , int number ) ;
#line 56
void packet_set_protocol_flags(u_int protocol_flags ) ;
#line 59
u_int packet_get_protocol_flags(void) ;
#line 62
void packet_start_compression(int level ) ;
#line 68
void packet_set_interactive(int interactive ) ;
#line 83
void packet_put_bignum(BIGNUM *value ) ;
#line 120
void packet_process_incoming(char const   *buf___2 , u_int len ) ;
#line 132
void packet_get_bignum(BIGNUM *value , int *length_ptr ) ;
#line 165
void packet_write_poll(void) ;
#line 171
int packet_have_data_to_write(void) ;
#line 174
int packet_not_very_much_data_to_write(void) ;
#line 178
int packet_set_maxsize(int s ) ;
#line 209
int packet_connection_is_ipv4(void) ;
#line 212
void packet_set_ssh2_format(void) ;
#line 221
void packet_inject_ignore(int sumlen ) ;
#line 75 "packet.c"
static int connection_in  =    -1;
#line 76 "packet.c"
static int connection_out  =    -1;
#line 82 "packet.c"
static int cipher_type  =    0;
#line 85 "packet.c"
static u_int remote_protocol_flags  =    (u_int )0;
#line 88 "packet.c"
static CipherContext receive_context  ;
#line 91 "packet.c"
static CipherContext send_context  ;
#line 94 "packet.c"
static Buffer input  ;
#line 97 "packet.c"
static Buffer output  ;
#line 100 "packet.c"
static Buffer outgoing_packet  ;
#line 103 "packet.c"
static Buffer incoming_packet  ;
#line 106 "packet.c"
static Buffer compression_buffer  ;
#line 107 "packet.c"
static int compression_buffer_ready  =    0;
#line 110 "packet.c"
static int packet_compression  =    0;
#line 113 "packet.c"
int max_packet_size  =    32768;
#line 116 "packet.c"
static int initialized  =    0;
#line 119 "packet.c"
static int interactive_mode  =    0;
#line 122 "packet.c"
int use_ssh2_packet_format  =    0;
#line 125 "packet.c"
Newkeys *newkeys[2]  ;
#line 127 "packet.c"
void packet_set_ssh2_format(void) 
{ 

  {
#line 131
  use_ssh2_packet_format = 1;
#line 132
  newkeys[1] = (Newkeys *)((void *)0);
#line 132
  newkeys[0] = newkeys[1];
#line 133
  return;
}
}
#line 139 "packet.c"
void packet_set_connection(int fd_in , int fd_out ) 
{ Cipher *none ;
  Cipher *tmp ;

  {
#line 142
  tmp = cipher_by_name("none");
#line 142
  none = tmp;
#line 143
  if ((unsigned int )none == (unsigned int )((void *)0)) {
#line 144
    fatal("packet_set_connection: cannot load cipher \'none\'");
  }
#line 145
  connection_in = fd_in;
#line 146
  connection_out = fd_out;
#line 147
  cipher_type = 0;
#line 148
  cipher_init(& send_context, none, (u_char const   *)((u_char *)""), 0U, (u_char const   *)((void *)0),
              0U);
#line 149
  cipher_init(& receive_context, none, (u_char const   *)((u_char *)""), 0U, (u_char const   *)((void *)0),
              0U);
#line 150
  if (! initialized) {
#line 151
    initialized = 1;
#line 152
    buffer_init(& input);
#line 153
    buffer_init(& output);
#line 154
    buffer_init(& outgoing_packet);
#line 155
    buffer_init(& incoming_packet);
  }
#line 158
  fatal_add_cleanup((void (*)(void * ))(& packet_close), (void *)0);
#line 159
  return;
}
}
#line 163 "packet.c"
int packet_connection_is_on_socket(void) 
{ struct sockaddr_storage from ;
  struct sockaddr_storage to ;
  socklen_t fromlen ;
  socklen_t tolen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 170
  if (connection_in == connection_out) {
#line 171
    return (1);
  }
#line 172
  fromlen = sizeof(from);
#line 173
  memset((void *)(& from), 0, sizeof(from));
#line 174
  tmp = getpeername(connection_in, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                    (socklen_t * __restrict  )(& fromlen));
#line 174
  if (tmp < 0) {
#line 175
    return (0);
  }
#line 176
  tolen = sizeof(to);
#line 177
  memset((void *)(& to), 0, sizeof(to));
#line 178
  tmp___0 = getpeername(connection_out, (struct sockaddr * __restrict  )((struct sockaddr *)(& to)),
                        (socklen_t * __restrict  )(& tolen));
#line 178
  if (tmp___0 < 0) {
#line 179
    return (0);
  }
#line 180
  if (fromlen != tolen) {
#line 181
    return (0);
  } else {
#line 180
    tmp___1 = memcmp((void const   *)(& from), (void const   *)(& to), fromlen);
#line 180
    if (tmp___1 != 0) {
#line 181
      return (0);
    }
  }
#line 182
  if ((int )from.ss_family != 2) {
#line 182
    if ((int )from.ss_family != 10) {
#line 183
      return (0);
    }
  }
#line 184
  return (1);
}
}
#line 189 "packet.c"
int packet_connection_is_ipv4(void) 
{ struct sockaddr_storage to ;
  socklen_t tolen ;
  int tmp ;

  {
#line 193
  tolen = sizeof(to);
#line 195
  memset((void *)(& to), 0, sizeof(to));
#line 196
  tmp = getsockname(connection_out, (struct sockaddr * __restrict  )((struct sockaddr *)(& to)),
                    (socklen_t * __restrict  )(& tolen));
#line 196
  if (tmp < 0) {
#line 197
    return (0);
  }
#line 198
  if ((int )to.ss_family != 2) {
#line 199
    return (0);
  }
#line 200
  return (1);
}
}
#line 205 "packet.c"
void packet_set_nonblocking(void) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 209
  tmp___1 = fcntl(connection_in, 4, 2048);
#line 209
  if (tmp___1 < 0) {
#line 210
    tmp = __errno_location();
#line 210
    tmp___0 = strerror(*tmp);
#line 210
    error("fcntl O_NONBLOCK: %.100s", tmp___0);
  }
#line 212
  if (connection_out != connection_in) {
#line 213
    tmp___4 = fcntl(connection_out, 4, 2048);
#line 213
    if (tmp___4 < 0) {
#line 214
      tmp___2 = __errno_location();
#line 214
      tmp___3 = strerror(*tmp___2);
#line 214
      error("fcntl O_NONBLOCK: %.100s", tmp___3);
    }
  }
#line 216
  return;
}
}
#line 220 "packet.c"
int packet_get_connection_in(void) 
{ 

  {
#line 223
  return (connection_in);
}
}
#line 228 "packet.c"
int packet_get_connection_out(void) 
{ 

  {
#line 231
  return (connection_out);
}
}
#line 236 "packet.c"
void packet_close(void) 
{ 

  {
#line 239
  if (! initialized) {
#line 240
    return;
  }
#line 241
  initialized = 0;
#line 242
  if (connection_in == connection_out) {
#line 243
    shutdown(connection_out, 2);
#line 244
    close(connection_out);
  } else {
#line 246
    close(connection_in);
#line 247
    close(connection_out);
  }
#line 249
  buffer_free(& input);
#line 250
  buffer_free(& output);
#line 251
  buffer_free(& outgoing_packet);
#line 252
  buffer_free(& incoming_packet);
#line 253
  if (compression_buffer_ready) {
#line 254
    buffer_free(& compression_buffer);
#line 255
    buffer_compress_uninit();
  }
#line 257
  return;
}
}
#line 261 "packet.c"
void packet_set_protocol_flags(u_int protocol_flags ) 
{ 

  {
#line 264
  remote_protocol_flags = protocol_flags;
#line 265
  channel_set_options((protocol_flags & 2U) != 0U);
#line 266
  return;
}
}
#line 270 "packet.c"
u_int packet_get_protocol_flags(void) 
{ 

  {
#line 273
  return (remote_protocol_flags);
}
}
#line 281 "packet.c"
void packet_init_compression(void) 
{ 

  {
#line 284
  if (compression_buffer_ready == 1) {
#line 285
    return;
  }
#line 286
  compression_buffer_ready = 1;
#line 287
  buffer_init(& compression_buffer);
#line 288
  return;
}
}
#line 290 "packet.c"
void packet_start_compression(int level ) 
{ 

  {
#line 293
  if (packet_compression) {
#line 293
    if (! use_ssh2_packet_format) {
#line 294
      fatal("Compression already enabled.");
    }
  }
#line 295
  packet_compression = 1;
#line 296
  packet_init_compression();
#line 297
  buffer_compress_init_send(level);
#line 298
  buffer_compress_init_recv();
#line 299
  return;
}
}
#line 306 "packet.c"
void packet_encrypt(CipherContext *cc , void *dest , void *src , u_int bytes ) 
{ 

  {
#line 310
  cipher_encrypt(cc, (u_char *)dest, (u_char const   *)src, bytes);
#line 311
  return;
}
}
#line 318 "packet.c"
void packet_decrypt(CipherContext *context , void *dest , void *src , u_int bytes ) 
{ int tmp ;

  {
#line 325
  if (! compat20) {
#line 325
    if ((context->cipher)->number != 0) {
#line 325
      tmp = detect_attack((u_char *)src, bytes, (u_char *)((void *)0));
#line 325
      if (tmp == 1) {
#line 328
        packet_disconnect("crc32 compensation attack: network attack detected");
      }
    }
  }
#line 330
  cipher_decrypt(context, (u_char *)dest, (u_char const   *)src, bytes);
#line 331
  return;
}
}
#line 339 "packet.c"
void packet_set_encryption_key(u_char const   *key , u_int keylen , int number ) 
{ Cipher *cipher ;
  Cipher *tmp ;

  {
#line 343
  tmp = cipher_by_number(number);
#line 343
  cipher = tmp;
#line 344
  if ((unsigned int )cipher == (unsigned int )((void *)0)) {
#line 345
    fatal("packet_set_encryption_key: unknown cipher number %d", number);
  }
#line 346
  if (keylen < 20U) {
#line 347
    fatal("packet_set_encryption_key: keylen too small: %d", keylen);
  }
#line 348
  cipher_init(& receive_context, cipher, key, keylen, (u_char const   *)((void *)0),
              0U);
#line 349
  cipher_init(& send_context, cipher, key, keylen, (u_char const   *)((void *)0),
              0U);
#line 350
  return;
}
}
#line 354 "packet.c"
void packet_start1(int type ) 
{ char buf___2[9] ;

  {
#line 359
  buffer_clear(& outgoing_packet);
#line 360
  memset((void *)(buf___2), 0, 8U);
#line 361
  buf___2[8] = (char )type;
#line 362
  buffer_append(& outgoing_packet, (char const   *)(buf___2), 9U);
#line 363
  return;
}
}
#line 365 "packet.c"
void packet_start2(int type ) 
{ char buf___2[6] ;

  {
#line 370
  buffer_clear(& outgoing_packet);
#line 371
  memset((void *)(buf___2), 0, sizeof(buf___2));
#line 374
  buf___2[5] = (char )(type & 255);
#line 375
  buffer_append(& outgoing_packet, (char const   *)(buf___2), sizeof(buf___2));
#line 376
  return;
}
}
#line 378 "packet.c"
void packet_start(int type ) 
{ 

  {
#line 382
  if (use_ssh2_packet_format) {
#line 383
    packet_start2(type);
  } else {
#line 385
    packet_start1(type);
  }
#line 386
  return;
}
}
#line 390 "packet.c"
void packet_put_char(int value ) 
{ char ch ;

  {
#line 393
  ch = (char )value;
#line 394
  buffer_append(& outgoing_packet, (char const   *)(& ch), 1U);
#line 395
  return;
}
}
#line 399 "packet.c"
void packet_put_int(u_int value ) 
{ 

  {
#line 402
  buffer_put_int(& outgoing_packet, value);
#line 403
  return;
}
}
#line 407 "packet.c"
void packet_put_string(char const   *buf___2 , u_int len ) 
{ 

  {
#line 410
  buffer_put_string(& outgoing_packet, (void const   *)buf___2, len);
#line 411
  return;
}
}
#line 412 "packet.c"
void packet_put_cstring(char const   *str ) 
{ size_t tmp ;

  {
#line 415
  tmp = strlen(str);
#line 415
  buffer_put_string(& outgoing_packet, (void const   *)str, tmp);
#line 416
  return;
}
}
#line 418 "packet.c"
void packet_put_raw(char const   *buf___2 , u_int len ) 
{ 

  {
#line 421
  buffer_append(& outgoing_packet, buf___2, len);
#line 422
  return;
}
}
#line 427 "packet.c"
void packet_put_bignum(BIGNUM *value ) 
{ 

  {
#line 430
  buffer_put_bignum(& outgoing_packet, value);
#line 431
  return;
}
}
#line 432 "packet.c"
void packet_put_bignum2(BIGNUM *value ) 
{ 

  {
#line 435
  buffer_put_bignum2(& outgoing_packet, value);
#line 436
  return;
}
}
#line 443 "packet.c"
void packet_send1(void) 
{ char buf___2[8] ;
  char *cp ;
  int i ;
  int padding ;
  int len ;
  u_int checksum ;
  u_int32_t rand___0 ;
  u_int tmp ;
  char *tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  char *tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  char *tmp___6 ;

  {
#line 449
  rand___0 = (u_int32_t )0;
#line 455
  if (packet_compression) {
#line 456
    buffer_clear(& compression_buffer);
#line 458
    buffer_consume(& outgoing_packet, 8U);
#line 460
    buffer_append(& compression_buffer, "\000\000\000\000\000\000\000\000", 8U);
#line 461
    buffer_compress(& outgoing_packet, & compression_buffer);
#line 462
    buffer_clear(& outgoing_packet);
#line 463
    tmp = buffer_len(& compression_buffer);
#line 463
    tmp___0 = buffer_ptr(& compression_buffer);
#line 463
    buffer_append(& outgoing_packet, (char const   *)tmp___0, tmp);
  }
#line 467
  tmp___1 = buffer_len(& outgoing_packet);
#line 467
  len = (int )((tmp___1 + 4U) - 8U);
#line 470
  padding = 8 - len % 8;
#line 471
  if (cipher_type != 0) {
#line 472
    cp = buffer_ptr(& outgoing_packet);
#line 473
    i = 0;
#line 473
    while (i < padding) {
#line 474
      if (i % 4 == 0) {
#line 475
        rand___0 = arc4random();
      }
#line 476
      *(cp + (7 - i)) = (char )(rand___0 & 255U);
#line 477
      rand___0 >>= 8;
#line 473
      i ++;
    }
  }
#line 480
  buffer_consume(& outgoing_packet, (unsigned int )(8 - padding));
#line 483
  tmp___2 = buffer_len(& outgoing_packet);
#line 483
  tmp___3 = buffer_ptr(& outgoing_packet);
#line 483
  checksum = ssh_crc32((u_char const   *)((u_char *)tmp___3), tmp___2);
#line 485
  while (1) {
#line 485
    buf___2[0] = (char )(checksum >> 24);
#line 485
    buf___2[1] = (char )(checksum >> 16);
#line 485
    buf___2[2] = (char )(checksum >> 8);
#line 485
    buf___2[3] = (char )checksum;
#line 485
    break;
  }
#line 486
  buffer_append(& outgoing_packet, (char const   *)(buf___2), 4U);
#line 494
  while (1) {
#line 494
    buf___2[0] = (char )(len >> 24);
#line 494
    buf___2[1] = (char )(len >> 16);
#line 494
    buf___2[2] = (char )(len >> 8);
#line 494
    buf___2[3] = (char )len;
#line 494
    break;
  }
#line 495
  buffer_append(& output, (char const   *)(buf___2), 4U);
#line 496
  tmp___4 = buffer_len(& outgoing_packet);
#line 496
  buffer_append_space(& output, & cp, tmp___4);
#line 497
  tmp___5 = buffer_len(& outgoing_packet);
#line 497
  tmp___6 = buffer_ptr(& outgoing_packet);
#line 497
  packet_encrypt(& send_context, (void *)cp, (void *)tmp___6, tmp___5);
#line 505
  buffer_clear(& outgoing_packet);
#line 512
  return;
}
}
#line 514 "packet.c"
void set_newkeys(int mode ) 
{ Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  CipherContext *cc ;

  {
#line 522
  debug("newkeys: mode %d", mode);
#line 524
  if (mode == 1) {
#line 524
    cc = & send_context;
  } else {
#line 524
    cc = & receive_context;
  }
#line 525
  if ((unsigned int )newkeys[mode] != (unsigned int )((void *)0)) {
#line 526
    debug("newkeys: rekeying");
#line 528
    memset((void *)cc, 0, sizeof(*cc));
#line 529
    enc = & (newkeys[mode])->enc;
#line 530
    mac = & (newkeys[mode])->mac;
#line 531
    comp = & (newkeys[mode])->comp;
#line 532
    memset((void *)mac->key, 0, (unsigned int )mac->key_len);
#line 533
    xfree((void *)enc->name);
#line 534
    xfree((void *)enc->iv);
#line 535
    xfree((void *)enc->key);
#line 536
    xfree((void *)mac->name);
#line 537
    xfree((void *)mac->key);
#line 538
    xfree((void *)comp->name);
#line 539
    xfree((void *)newkeys[mode]);
  }
#line 541
  newkeys[mode] = kex_get_newkeys(mode);
#line 542
  if ((unsigned int )newkeys[mode] == (unsigned int )((void *)0)) {
#line 543
    fatal("newkeys: no keys for mode %d", mode);
  }
#line 544
  enc = & (newkeys[mode])->enc;
#line 545
  mac = & (newkeys[mode])->mac;
#line 546
  comp = & (newkeys[mode])->comp;
#line 547
  if ((unsigned int )mac->md != (unsigned int )((void *)0)) {
#line 548
    mac->enabled = 1;
  }
#line 550
  cipher_init(cc, enc->cipher, (u_char const   *)enc->key, (enc->cipher)->key_len,
              (u_char const   *)enc->iv, (enc->cipher)->block_size);
#line 552
  memset((void *)enc->iv, 0, (enc->cipher)->block_size);
#line 553
  memset((void *)enc->key, 0, (enc->cipher)->key_len);
#line 554
  if (comp->type != 0) {
#line 554
    if (comp->enabled == 0) {
#line 555
      packet_init_compression();
#line 556
      if (mode == 1) {
#line 557
        buffer_compress_init_send(6);
      } else {
#line 559
        buffer_compress_init_recv();
      }
#line 560
      comp->enabled = 1;
    }
  }
#line 562
  return;
}
}
#line 570
void packet_send2(void) ;
#line 570 "packet.c"
static u_int32_t seqnr  =    (u_int32_t )0;
#line 567 "packet.c"
void packet_send2(void) 
{ u_char *macbuf ;
  char *cp ;
  u_int packet_length___0 ;
  u_int i ;
  u_int padlen ;
  u_int len ;
  u_int32_t rand___0 ;
  int type ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  int block_size ;
  u_int tmp ;
  char *tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  char *tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  char *tmp___6 ;

  {
#line 571
  macbuf = (u_char *)((void *)0);
#line 573
  packet_length___0 = (u_int )0;
#line 575
  rand___0 = (u_int32_t )0;
#line 577
  enc = (Enc *)((void *)0);
#line 578
  mac = (Mac *)((void *)0);
#line 579
  comp = (Comp *)((void *)0);
#line 582
  if ((unsigned int )newkeys[1] != (unsigned int )((void *)0)) {
#line 583
    enc = & (newkeys[1])->enc;
#line 584
    mac = & (newkeys[1])->mac;
#line 585
    comp = & (newkeys[1])->comp;
  }
#line 587
  if (enc) {
#line 587
    block_size = (int )(enc->cipher)->block_size;
  } else {
#line 587
    block_size = 8;
  }
#line 589
  cp = buffer_ptr(& outgoing_packet);
#line 590
  type = (int )*(cp + 5) & 255;
#line 597
  if (comp) {
#line 597
    if (comp->enabled) {
#line 598
      len = buffer_len(& outgoing_packet);
#line 600
      buffer_consume(& outgoing_packet, 5U);
#line 601
      buffer_clear(& compression_buffer);
#line 602
      buffer_compress(& outgoing_packet, & compression_buffer);
#line 603
      buffer_clear(& outgoing_packet);
#line 604
      buffer_append(& outgoing_packet, "\000\000\000\000\000", 5U);
#line 605
      tmp = buffer_len(& compression_buffer);
#line 605
      tmp___0 = buffer_ptr(& compression_buffer);
#line 605
      buffer_append(& outgoing_packet, (char const   *)tmp___0, tmp);
    }
  }
#line 612
  len = buffer_len(& outgoing_packet);
#line 618
  padlen = (unsigned int )block_size - len % (unsigned int )block_size;
#line 619
  if (padlen < 4U) {
#line 620
    padlen += (u_int )block_size;
  }
#line 621
  buffer_append_space(& outgoing_packet, & cp, padlen);
#line 622
  if (enc) {
#line 622
    if ((enc->cipher)->number != 0) {
#line 624
      i = 0U;
#line 624
      while (i < padlen) {
#line 625
        if (i % 4U == 0U) {
#line 626
          rand___0 = arc4random();
        }
#line 627
        *(cp + i) = (char )(rand___0 & 255U);
#line 628
        rand___0 >>= 8;
#line 624
        i ++;
      }
    } else {
#line 632
      memset((void *)cp, 0, padlen);
    }
  } else {
#line 632
    memset((void *)cp, 0, padlen);
  }
#line 635
  tmp___1 = buffer_len(& outgoing_packet);
#line 635
  packet_length___0 = tmp___1 - 4U;
#line 636
  cp = buffer_ptr(& outgoing_packet);
#line 637
  while (1) {
#line 637
    *(cp + 0) = (char )(packet_length___0 >> 24);
#line 637
    *(cp + 1) = (char )(packet_length___0 >> 16);
#line 637
    *(cp + 2) = (char )(packet_length___0 >> 8);
#line 637
    *(cp + 3) = (char )packet_length___0;
#line 637
    break;
  }
#line 638
  *(cp + 4) = (char )(padlen & 255U);
#line 642
  if (mac) {
#line 642
    if (mac->enabled) {
#line 643
      tmp___2 = buffer_len(& outgoing_packet);
#line 643
      tmp___3 = buffer_ptr(& outgoing_packet);
#line 643
      macbuf = mac_compute(mac, seqnr, (u_char *)tmp___3, (int )tmp___2);
    }
  }
#line 649
  tmp___4 = buffer_len(& outgoing_packet);
#line 649
  buffer_append_space(& output, & cp, tmp___4);
#line 650
  tmp___5 = buffer_len(& outgoing_packet);
#line 650
  tmp___6 = buffer_ptr(& outgoing_packet);
#line 650
  packet_encrypt(& send_context, (void *)cp, (void *)tmp___6, tmp___5);
#line 653
  if (mac) {
#line 653
    if (mac->enabled) {
#line 654
      buffer_append(& output, (char const   *)((char *)macbuf), (unsigned int )mac->mac_len);
    }
  }
#line 660
  seqnr ++;
#line 660
  if (seqnr == 0U) {
#line 661
    log("outgoing seqnr wraps around");
  }
#line 662
  buffer_clear(& outgoing_packet);
#line 664
  if (type == 21) {
#line 665
    set_newkeys(1);
  }
#line 666
  return;
}
}
#line 668 "packet.c"
void packet_send(void) 
{ 

  {
#line 671
  if (use_ssh2_packet_format) {
#line 672
    packet_send2();
  } else {
#line 674
    packet_send1();
  }
#line 676
  return;
}
}
#line 684 "packet.c"
int packet_read(int *payload_len_ptr ) 
{ int type ;
  int len ;
  fd_set *setp ;
  char buf___2[8192] ;
  void *tmp ;
  int _p ;
  int _e ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char const   *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
#line 692
  tmp = xmalloc((((unsigned int )(connection_in + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 692
  setp = (fd_set *)tmp;
#line 696
  packet_write_wait();
#line 699
  while (1) {
#line 701
    type = packet_read_poll(payload_len_ptr);
#line 702
    if (! use_ssh2_packet_format) {
#line 702
      if (type == 14) {
        goto _L;
      } else {
#line 702
        if (type == 15) {
          goto _L;
        } else {
#line 702
          if (type == 19) {
            goto _L;
          } else {
#line 702
            if (type == 33) {
              _L: /* CIL Label */ 
#line 707
              while (1) {
#line 707
                _p = *payload_len_ptr;
#line 707
                _e = 0;
#line 707
                if (_p != _e) {
#line 707
                  log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "packet.c",
                      707);
#line 707
                  packet_disconnect("Packet integrity error. (%d)", type);
                }
#line 707
                break;
              }
            }
          }
        }
      }
    }
#line 709
    if (type != 0) {
#line 710
      xfree((void *)setp);
#line 711
      return (type);
    }
#line 717
    memset((void *)setp, 0, (((unsigned int )(connection_in + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 719
    __asm__  volatile   ("btsl %1,%0": "=m" (setp->__fds_bits[(unsigned int )connection_in / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 722
    while (1) {
#line 722
      tmp___0 = select(connection_in + 1, (fd_set * __restrict  )setp, (fd_set * __restrict  )((void *)0),
                       (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 722
      if (tmp___0 == -1) {
#line 722
        tmp___1 = __errno_location();
#line 722
        if (! (*tmp___1 == 11)) {
#line 722
          tmp___2 = __errno_location();
#line 722
          if (! (*tmp___2 == 4)) {
#line 722
            break;
          }
        }
      } else {
#line 722
        break;
      }
    }
#line 727
    len = read(connection_in, (void *)(buf___2), sizeof(buf___2));
#line 728
    if (len == 0) {
#line 729
      tmp___3 = get_remote_ipaddr();
#line 729
      log("Connection closed by %.200s", tmp___3);
#line 730
      fatal_cleanup();
    }
#line 732
    if (len < 0) {
#line 733
      tmp___4 = __errno_location();
#line 733
      tmp___5 = strerror(*tmp___4);
#line 733
      fatal("Read from socket failed: %.100s", tmp___5);
    }
#line 735
    packet_process_incoming((char const   *)(buf___2), (unsigned int )len);
  }
}
}
#line 745 "packet.c"
void packet_read_expect(int *payload_len_ptr , int expected_type ) 
{ int type ;

  {
#line 750
  type = packet_read(payload_len_ptr);
#line 751
  if (type != expected_type) {
#line 752
    packet_disconnect("Protocol error: expected packet type %d, got %d", expected_type,
                      type);
  }
#line 754
  return;
}
}
#line 771 "packet.c"
int packet_read_poll1(int *payload_len_ptr ) 
{ u_int len ;
  u_int padded_len ;
  u_char *ucp ;
  char buf___2[8] ;
  char *cp ;
  u_int checksum ;
  u_int stored_checksum ;
  u_int tmp ;
  char *tmp___0 ;
  u_int tmp___1 ;
  char *tmp___2 ;
  u_int tmp___3 ;
  char *tmp___4 ;
  u_int tmp___5 ;
  u_int tmp___6 ;
  char *tmp___7 ;
  u_int tmp___8 ;
  char *tmp___9 ;
  u_int tmp___10 ;

  {
#line 780
  tmp = buffer_len(& input);
#line 780
  if (tmp < 12U) {
#line 781
    return (0);
  }
#line 783
  tmp___0 = buffer_ptr(& input);
#line 783
  ucp = (u_char *)tmp___0;
#line 784
  len = (unsigned int )(((((unsigned long )*(ucp + 0) << 24) | ((unsigned long )*(ucp + 1) << 16)) | ((unsigned long )*(ucp + 2) << 8)) | (unsigned long )*(ucp + 3));
#line 785
  if (len < 5U) {
#line 786
    packet_disconnect("Bad packet length %d.", len);
  } else {
#line 785
    if (len > 262144U) {
#line 786
      packet_disconnect("Bad packet length %d.", len);
    }
  }
#line 787
  padded_len = (len + 8U) & 4294967288U;
#line 790
  tmp___1 = buffer_len(& input);
#line 790
  if (tmp___1 < 4U + padded_len) {
#line 791
    return (0);
  }
#line 796
  buffer_consume(& input, 4U);
#line 799
  buffer_clear(& incoming_packet);
#line 800
  buffer_append_space(& incoming_packet, & cp, padded_len);
#line 801
  tmp___2 = buffer_ptr(& input);
#line 801
  packet_decrypt(& receive_context, (void *)cp, (void *)tmp___2, padded_len);
#line 802
  buffer_consume(& input, padded_len);
#line 810
  tmp___3 = buffer_len(& incoming_packet);
#line 810
  tmp___4 = buffer_ptr(& incoming_packet);
#line 810
  checksum = ssh_crc32((u_char const   *)((u_char *)tmp___4), tmp___3 - 4U);
#line 814
  buffer_consume(& incoming_packet, 8U - len % 8U);
#line 818
  tmp___6 = buffer_len(& incoming_packet);
#line 818
  if (len != tmp___6) {
#line 819
    tmp___5 = buffer_len(& incoming_packet);
#line 819
    packet_disconnect("packet_read_poll: len %d != buffer_len %d.", len, tmp___5);
  }
#line 822
  tmp___7 = buffer_ptr(& incoming_packet);
#line 822
  ucp = ((u_char *)tmp___7 + len) - 4;
#line 823
  stored_checksum = (unsigned int )(((((unsigned long )*(ucp + 0) << 24) | ((unsigned long )*(ucp + 1) << 16)) | ((unsigned long )*(ucp + 2) << 8)) | (unsigned long )*(ucp + 3));
#line 824
  if (checksum != stored_checksum) {
#line 825
    packet_disconnect("Corrupted check bytes on input.");
  }
#line 826
  buffer_consume_end(& incoming_packet, 4U);
#line 829
  if (packet_compression) {
#line 830
    buffer_clear(& compression_buffer);
#line 831
    buffer_uncompress(& incoming_packet, & compression_buffer);
#line 832
    buffer_clear(& incoming_packet);
#line 833
    tmp___8 = buffer_len(& compression_buffer);
#line 833
    tmp___9 = buffer_ptr(& compression_buffer);
#line 833
    buffer_append(& incoming_packet, (char const   *)tmp___9, tmp___8);
  }
#line 837
  buffer_get(& incoming_packet, buf___2, 1U);
#line 840
  tmp___10 = buffer_len(& incoming_packet);
#line 840
  *payload_len_ptr = (int )tmp___10;
#line 843
  return ((int )((unsigned char )buf___2[0]));
}
}
#line 849
int packet_read_poll2(int *payload_len_ptr ) ;
#line 849 "packet.c"
static u_int32_t seqnr___0  =    (u_int32_t )0;
#line 850 "packet.c"
static u_int packet_length  =    (u_int )0;
#line 846 "packet.c"
int packet_read_poll2(int *payload_len_ptr ) 
{ u_int padlen ;
  u_int need ;
  u_char buf___2[8] ;
  u_char *macbuf ;
  u_char *ucp ;
  char *cp ;
  int type ;
  int maclen ;
  int block_size ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  u_int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  u_int tmp___2 ;
  char *tmp___3 ;
  u_int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  u_int tmp___9 ;
  char *tmp___10 ;
  u_int tmp___11 ;

  {
#line 857
  enc = (Enc *)((void *)0);
#line 858
  mac = (Mac *)((void *)0);
#line 859
  comp = (Comp *)((void *)0);
#line 861
  if ((unsigned int )newkeys[0] != (unsigned int )((void *)0)) {
#line 862
    enc = & (newkeys[0])->enc;
#line 863
    mac = & (newkeys[0])->mac;
#line 864
    comp = & (newkeys[0])->comp;
  }
#line 866
  if (mac) {
#line 866
    if (mac->enabled) {
#line 866
      maclen = mac->mac_len;
    } else {
#line 866
      maclen = 0;
    }
  } else {
#line 866
    maclen = 0;
  }
#line 867
  if (enc) {
#line 867
    block_size = (int )(enc->cipher)->block_size;
  } else {
#line 867
    block_size = 8;
  }
#line 869
  if (packet_length == 0U) {
#line 874
    tmp = buffer_len(& input);
#line 874
    if (tmp < (u_int )block_size) {
#line 875
      return (0);
    }
#line 876
    buffer_clear(& incoming_packet);
#line 877
    buffer_append_space(& incoming_packet, & cp, (unsigned int )block_size);
#line 878
    tmp___0 = buffer_ptr(& input);
#line 878
    packet_decrypt(& receive_context, (void *)cp, (void *)tmp___0, (unsigned int )block_size);
#line 880
    tmp___1 = buffer_ptr(& incoming_packet);
#line 880
    ucp = (u_char *)tmp___1;
#line 881
    packet_length = (unsigned int )(((((unsigned long )*(ucp + 0) << 24) | ((unsigned long )*(ucp + 1) << 16)) | ((unsigned long )*(ucp + 2) << 8)) | (unsigned long )*(ucp + 3));
#line 882
    if (packet_length < 5U) {
#line 883
      buffer_dump(& incoming_packet);
#line 884
      packet_disconnect("Bad packet length %d.", packet_length);
    } else {
#line 882
      if (packet_length > 262144U) {
#line 883
        buffer_dump(& incoming_packet);
#line 884
        packet_disconnect("Bad packet length %d.", packet_length);
      }
    }
#line 887
    buffer_consume(& input, (unsigned int )block_size);
  }
#line 890
  need = (4U + packet_length) - (u_int )block_size;
#line 893
  if (need % (unsigned int )block_size != 0U) {
#line 894
    fatal("padding error: need %d block %d mod %d", need, block_size, need % (unsigned int )block_size);
  }
#line 900
  tmp___2 = buffer_len(& input);
#line 900
  if (tmp___2 < need + (u_int )maclen) {
#line 901
    return (0);
  }
#line 906
  buffer_append_space(& incoming_packet, & cp, need);
#line 907
  tmp___3 = buffer_ptr(& input);
#line 907
  packet_decrypt(& receive_context, (void *)cp, (void *)tmp___3, need);
#line 908
  buffer_consume(& input, need);
#line 913
  if (mac) {
#line 913
    if (mac->enabled) {
#line 914
      tmp___4 = buffer_len(& incoming_packet);
#line 914
      tmp___5 = buffer_ptr(& incoming_packet);
#line 914
      macbuf = mac_compute(mac, seqnr___0, (u_char *)tmp___5, (int )tmp___4);
#line 917
      tmp___6 = buffer_ptr(& input);
#line 917
      tmp___7 = memcmp((void const   *)macbuf, (void const   *)tmp___6, (unsigned int )mac->mac_len);
#line 917
      if (tmp___7 != 0) {
#line 918
        packet_disconnect("Corrupted MAC on input.");
      }
#line 920
      buffer_consume(& input, (unsigned int )mac->mac_len);
    }
  }
#line 922
  seqnr___0 ++;
#line 922
  if (seqnr___0 == 0U) {
#line 923
    log("incoming seqnr wraps around");
  }
#line 926
  tmp___8 = buffer_ptr(& incoming_packet);
#line 926
  cp = tmp___8 + 4;
#line 927
  padlen = (unsigned int )((int )*cp & 255);
#line 929
  if (padlen < 4U) {
#line 930
    packet_disconnect("Corrupted padlen %d on input.", padlen);
  }
#line 933
  buffer_consume(& incoming_packet, 5U);
#line 934
  buffer_consume_end(& incoming_packet, padlen);
#line 937
  if (comp) {
#line 937
    if (comp->enabled) {
#line 938
      buffer_clear(& compression_buffer);
#line 939
      buffer_uncompress(& incoming_packet, & compression_buffer);
#line 940
      buffer_clear(& incoming_packet);
#line 941
      tmp___9 = buffer_len(& compression_buffer);
#line 941
      tmp___10 = buffer_ptr(& compression_buffer);
#line 941
      buffer_append(& incoming_packet, (char const   *)tmp___10, tmp___9);
    }
  }
#line 949
  buffer_get(& incoming_packet, (char *)(buf___2), 1U);
#line 950
  tmp___11 = buffer_len(& incoming_packet);
#line 950
  *payload_len_ptr = (int )tmp___11;
#line 953
  packet_length = 0U;
#line 956
  type = (int )buf___2[0];
#line 958
  if (type == 21) {
#line 959
    set_newkeys(0);
  }
#line 965
  return ((int )((unsigned char )type));
}
}
#line 968 "packet.c"
int packet_read_poll(int *payload_len_ptr ) 
{ char *msg ;
  int type ;
  int tmp___1 ;
  int reason ;
  u_int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
#line 972
  while (1) {
#line 973
    if (use_ssh2_packet_format) {
#line 973
      tmp___1 = packet_read_poll2(payload_len_ptr);
    } else {
#line 973
      tmp___1 = packet_read_poll1(payload_len_ptr);
    }
#line 973
    type = tmp___1;
#line 977
    if (compat20) {
#line 979
      if (type != 0) {

      }
#line 981
      switch (type) {
      case 2: 
#line 983
      break;
      case 4: 
#line 985
      packet_get_char();
#line 986
      msg = packet_get_string((u_int *)((void *)0));
#line 987
      debug("Remote: %.900s", msg);
#line 988
      xfree((void *)msg);
#line 989
      msg = packet_get_string((u_int *)((void *)0));
#line 990
      xfree((void *)msg);
#line 991
      break;
      case 1: 
#line 993
      tmp___2 = packet_get_int();
#line 993
      reason = (int )tmp___2;
#line 994
      msg = packet_get_string((u_int *)((void *)0));
#line 995
      tmp___3 = get_remote_ipaddr();
#line 995
      log("Received disconnect from %s: %d: %.400s", tmp___3, reason, msg);
#line 997
      xfree((void *)msg);
#line 998
      fatal_cleanup();
#line 999
      break;
      default: ;
#line 1001
      return (type);
#line 1002
      break;
      }
    } else {
#line 1005
      switch (type) {
      case 32: 
#line 1007
      break;
      case 36: 
#line 1009
      msg = packet_get_string((u_int *)((void *)0));
#line 1010
      debug("Remote: %.900s", msg);
#line 1011
      xfree((void *)msg);
#line 1012
      break;
      case 1: 
#line 1014
      msg = packet_get_string((u_int *)((void *)0));
#line 1015
      tmp___4 = get_remote_ipaddr();
#line 1015
      log("Received disconnect from %s: %.400s", tmp___4, msg);
#line 1017
      fatal_cleanup();
#line 1018
      xfree((void *)msg);
#line 1019
      break;
      default: ;
#line 1021
      if (type != 0) {

      }
#line 1023
      return (type);
#line 1024
      break;
      }
    }
  }
}
}
#line 1035 "packet.c"
void packet_process_incoming(char const   *buf___2 , u_int len ) 
{ 

  {
#line 1038
  buffer_append(& input, buf___2, len);
#line 1039
  return;
}
}
#line 1043 "packet.c"
u_int packet_get_char(void) 
{ char ch ;

  {
#line 1047
  buffer_get(& incoming_packet, & ch, 1U);
#line 1048
  return ((unsigned int )((unsigned char )ch));
}
}
#line 1053 "packet.c"
u_int packet_get_int(void) 
{ u_int tmp ;

  {
#line 1056
  tmp = buffer_get_int(& incoming_packet);
#line 1056
  return (tmp);
}
}
#line 1064 "packet.c"
void packet_get_bignum(BIGNUM *value , int *length_ptr ) 
{ 

  {
#line 1067
  *length_ptr = buffer_get_bignum(& incoming_packet, value);
#line 1068
  return;
}
}
#line 1070 "packet.c"
void packet_get_bignum2(BIGNUM *value , int *length_ptr ) 
{ 

  {
#line 1073
  *length_ptr = buffer_get_bignum2(& incoming_packet, value);
#line 1074
  return;
}
}
#line 1076 "packet.c"
char *packet_get_raw(int *length_ptr ) 
{ int bytes ;
  u_int tmp ;
  char *tmp___0 ;

  {
#line 1079
  tmp = buffer_len(& incoming_packet);
#line 1079
  bytes = (int )tmp;
#line 1080
  if ((unsigned int )length_ptr != (unsigned int )((void *)0)) {
#line 1081
    *length_ptr = bytes;
  }
#line 1082
  tmp___0 = buffer_ptr(& incoming_packet);
#line 1082
  return (tmp___0);
}
}
#line 1085 "packet.c"
int packet_remaining(void) 
{ u_int tmp ;

  {
#line 1088
  tmp = buffer_len(& incoming_packet);
#line 1088
  return ((int )tmp);
}
}
#line 1098 "packet.c"
char *packet_get_string(u_int *length_ptr ) 
{ char *tmp ;

  {
#line 1101
  tmp = buffer_get_string(& incoming_packet, length_ptr);
#line 1101
  return (tmp);
}
}
#line 1113 "packet.c"
void ( /* format attribute */  packet_send_debug)(char const   *fmt  , ...) 
{ char buf___2[1024] ;
  va_list args ;

  {
#line 1119
  if (compat20) {
#line 1119
    if (datafellows & 64) {
#line 1120
      return;
    }
  }
#line 1122
  __builtin_va_start(args, fmt);
#line 1123
  vsnprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )fmt,
            args);
#line 1124
  __builtin_va_end(args);
#line 1126
  if (compat20) {
#line 1127
    packet_start(4);
#line 1128
    packet_put_char(0);
#line 1129
    packet_put_cstring((char const   *)(buf___2));
#line 1130
    packet_put_cstring("");
  } else {
#line 1132
    packet_start(36);
#line 1133
    packet_put_cstring((char const   *)(buf___2));
  }
#line 1135
  packet_send();
#line 1136
  packet_write_wait();
#line 1137
  return;
}
}
#line 1151 "packet.c"
static int disconnecting  =    0;
#line 1146 "packet.c"
void ( /* format attribute */  packet_disconnect)(char const   *fmt  , ...) 
{ char buf___2[1024] ;
  va_list args ;
  size_t tmp ;

  {
#line 1152
  if (disconnecting) {
#line 1153
    fatal("packet_disconnect called recursively.");
  }
#line 1154
  disconnecting = 1;
#line 1160
  __builtin_va_start(args, fmt);
#line 1161
  vsnprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )fmt,
            args);
#line 1162
  __builtin_va_end(args);
#line 1165
  if (compat20) {
#line 1166
    packet_start(1);
#line 1167
    packet_put_int(2U);
#line 1168
    packet_put_cstring((char const   *)(buf___2));
#line 1169
    packet_put_cstring("");
  } else {
#line 1171
    packet_start(1);
#line 1172
    tmp = strlen((char const   *)(buf___2));
#line 1172
    packet_put_string((char const   *)(buf___2), tmp);
  }
#line 1174
  packet_send();
#line 1175
  packet_write_wait();
#line 1178
  channel_stop_listening();
#line 1181
  packet_close();
#line 1184
  log("Disconnecting: %.100s", buf___2);
#line 1185
  fatal_cleanup();
#line 1186
  return;
}
}
#line 1190 "packet.c"
void packet_write_poll(void) 
{ int len ;
  u_int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
#line 1193
  tmp = buffer_len(& output);
#line 1193
  len = (int )tmp;
#line 1194
  if (len > 0) {
#line 1195
    tmp___0 = buffer_ptr(& output);
#line 1195
    len = write(connection_out, (void const   *)tmp___0, (unsigned int )len);
#line 1196
    if (len <= 0) {
#line 1197
      tmp___3 = __errno_location();
#line 1197
      if (*tmp___3 == 11) {
#line 1198
        return;
      } else {
#line 1200
        tmp___1 = __errno_location();
#line 1200
        tmp___2 = strerror(*tmp___1);
#line 1200
        fatal("Write failed: %.100s", tmp___2);
      }
    }
#line 1202
    buffer_consume(& output, (unsigned int )len);
  }
#line 1204
  return;
}
}
#line 1211 "packet.c"
void packet_write_wait(void) 
{ fd_set *setp ;
  void *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
#line 1216
  tmp = xmalloc((((unsigned int )(connection_out + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 1216
  setp = (fd_set *)tmp;
#line 1218
  packet_write_poll();
#line 1219
  while (1) {
#line 1219
    tmp___3 = packet_have_data_to_write();
#line 1219
    if (! tmp___3) {
#line 1219
      break;
    }
#line 1220
    memset((void *)setp, 0, (((unsigned int )(connection_out + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 1222
    __asm__  volatile   ("btsl %1,%0": "=m" (setp->__fds_bits[(unsigned int )connection_out / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 1223
    while (1) {
#line 1223
      tmp___0 = select(connection_out + 1, (fd_set * __restrict  )((void *)0), (fd_set * __restrict  )setp,
                       (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 1223
      if (tmp___0 == -1) {
#line 1223
        tmp___1 = __errno_location();
#line 1223
        if (! (*tmp___1 == 11)) {
#line 1223
          tmp___2 = __errno_location();
#line 1223
          if (! (*tmp___2 == 4)) {
#line 1223
            break;
          }
        }
      } else {
#line 1223
        break;
      }
    }
#line 1226
    packet_write_poll();
  }
#line 1228
  xfree((void *)setp);
#line 1229
  return;
}
}
#line 1233 "packet.c"
int packet_have_data_to_write(void) 
{ u_int tmp ;

  {
#line 1236
  tmp = buffer_len(& output);
#line 1236
  return (tmp != 0U);
}
}
#line 1241 "packet.c"
int packet_not_very_much_data_to_write(void) 
{ u_int tmp ;
  u_int tmp___0 ;

  {
#line 1244
  if (interactive_mode) {
#line 1245
    tmp = buffer_len(& output);
#line 1245
    return (tmp < 16384U);
  } else {
#line 1247
    tmp___0 = buffer_len(& output);
#line 1247
    return (tmp___0 < 131072U);
  }
}
}
#line 1255 "packet.c"
static int called___0  =    0;
#line 1252 "packet.c"
void packet_set_interactive(int interactive ) 
{ int lowdelay ;
  int throughput ;
  int on ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 1257
  lowdelay = 16;
#line 1258
  throughput = 8;
#line 1260
  on = 1;
#line 1262
  if (called___0) {
#line 1263
    return;
  }
#line 1264
  called___0 = 1;
#line 1267
  interactive_mode = interactive;
#line 1270
  tmp = packet_connection_is_on_socket();
#line 1270
  if (! tmp) {
#line 1271
    return;
  }
#line 1275
  if (interactive) {
#line 1281
    tmp___3 = packet_connection_is_ipv4();
#line 1281
    if (tmp___3) {
#line 1282
      tmp___2 = setsockopt(connection_in, 0, 1, (void const   *)((void *)(& lowdelay)),
                           sizeof(lowdelay));
#line 1282
      if (tmp___2 < 0) {
#line 1284
        tmp___0 = __errno_location();
#line 1284
        tmp___1 = strerror(*tmp___0);
#line 1284
        error("setsockopt IPTOS_LOWDELAY: %.100s", tmp___1);
      }
    }
#line 1288
    tmp___6 = setsockopt(connection_in, 6, 1, (void const   *)((void *)(& on)), sizeof(on));
#line 1288
    if (tmp___6 < 0) {
#line 1290
      tmp___4 = __errno_location();
#line 1290
      tmp___5 = strerror(*tmp___4);
#line 1290
      error("setsockopt TCP_NODELAY: %.100s", tmp___5);
    }
  } else {
#line 1291
    tmp___10 = packet_connection_is_ipv4();
#line 1291
    if (tmp___10) {
#line 1297
      tmp___9 = setsockopt(connection_in, 0, 1, (void const   *)((void *)(& throughput)),
                           sizeof(throughput));
#line 1297
      if (tmp___9 < 0) {
#line 1299
        tmp___7 = __errno_location();
#line 1299
        tmp___8 = strerror(*tmp___7);
#line 1299
        error("setsockopt IPTOS_THROUGHPUT: %.100s", tmp___8);
      }
    }
  }
#line 1302
  return;
}
}
#line 1306 "packet.c"
int packet_is_interactive(void) 
{ 

  {
#line 1309
  return (interactive_mode);
}
}
#line 1315 "packet.c"
static int called___1  =    0;
#line 1312 "packet.c"
int packet_set_maxsize(int s ) 
{ 

  {
#line 1316
  if (called___1) {
#line 1317
    log("packet_set_maxsize: called twice: old %d new %d", max_packet_size, s);
#line 1319
    return (-1);
  }
#line 1321
  if (s < 4096) {
#line 1322
    log("packet_set_maxsize: bad size %d", s);
#line 1323
    return (-1);
  } else {
#line 1321
    if (s > 1048576) {
#line 1322
      log("packet_set_maxsize: bad size %d", s);
#line 1323
      return (-1);
    }
  }
#line 1325
  log("packet_set_maxsize: setting to %d", s);
#line 1326
  max_packet_size = s;
#line 1327
  return (s);
}
}
#line 1342 "packet.c"
void packet_inject_ignore(int sumlen ) 
{ int blocksize ;
  int padlen ;
  int have ;
  int need ;
  int nb ;
  int mini ;
  int nbytes ;
  Enc *enc ;
  u_int tmp ;

  {
#line 1346
  enc = (Enc *)((void *)0);
#line 1348
  if (use_ssh2_packet_format == 0) {
#line 1349
    return;
  }
#line 1351
  tmp = buffer_len(& outgoing_packet);
#line 1351
  have = (int )tmp;
#line 1352
  debug2("packet_inject_ignore: current %d", have);
#line 1353
  if ((unsigned int )newkeys[1] != (unsigned int )((void *)0)) {
#line 1354
    enc = & (newkeys[1])->enc;
  }
#line 1355
  if (enc) {
#line 1355
    blocksize = (int )(enc->cipher)->block_size;
  } else {
#line 1355
    blocksize = 8;
  }
#line 1356
  padlen = blocksize - have % blocksize;
#line 1357
  if (padlen < 4) {
#line 1358
    padlen += blocksize;
  }
#line 1359
  have += padlen;
#line 1360
  have /= blocksize;
#line 1362
  nb = (((sumlen + (blocksize - 1)) / blocksize) * blocksize) / blocksize;
#line 1363
  mini = (((14 + (blocksize - 1)) / blocksize) * blocksize) / blocksize;
#line 1364
  need = nb - have % nb;
#line 1365
  if (need <= mini) {
#line 1366
    need += nb;
  }
#line 1367
  nbytes = (need - mini) * blocksize;
#line 1368
  debug2("packet_inject_ignore: block %d have %d nb %d mini %d need %d", blocksize,
         have, nb, mini, need);
#line 1372
  packet_send();
#line 1373
  packet_send_ignore(nbytes);
#line 1374
  return;
}
}
#line 1376 "packet.c"
void packet_send_ignore(int nbytes ) 
{ u_int32_t rand___0 ;
  int i ;
  int tmp ;

  {
#line 1379
  rand___0 = (u_int32_t )0;
#line 1382
  if (compat20) {
#line 1382
    tmp = 2;
  } else {
#line 1382
    tmp = 32;
  }
#line 1382
  packet_start(tmp);
#line 1383
  packet_put_int((unsigned int )nbytes);
#line 1384
  i = 0;
#line 1384
  while (i < nbytes) {
#line 1385
    if (i % 4 == 0) {
#line 1386
      rand___0 = arc4random();
    }
#line 1387
    packet_put_char((int )(rand___0 & 255U));
#line 1388
    rand___0 >>= 8;
#line 1384
    i ++;
  }
#line 1390
  return;
}
}
#line 1 "radix.o"
#pragma merger(0,"./radix.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "rijndael.o"
#pragma merger(0,"./rijndael.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 44 "rijndael.c"
void gen_tabs(void) ;
#line 73 "rijndael.c"
u1byte pow_tab[256]  ;
#line 74 "rijndael.c"
u1byte log_tab[256]  ;
#line 75 "rijndael.c"
u1byte sbx_tab[256]  ;
#line 76 "rijndael.c"
u1byte isb_tab[256]  ;
#line 77 "rijndael.c"
u4byte rco_tab[10]  ;
#line 78 "rijndael.c"
u4byte ft_tab[4][256]  ;
#line 79 "rijndael.c"
u4byte it_tab[4][256]  ;
#line 82 "rijndael.c"
u4byte fl_tab[4][256]  ;
#line 83 "rijndael.c"
u4byte il_tab[4][256]  ;
#line 86 "rijndael.c"
u4byte tab_gen  =    (u4byte )0;
#line 144 "rijndael.c"
void gen_tabs(void) 
{ u4byte i ;
  u4byte t ;
  u1byte p ;
  u1byte q ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 154
  i = 0U;
#line 154
  p = (unsigned char)1;
#line 154
  while (i < 256U) {
#line 155
    pow_tab[i] = p;
#line 155
    log_tab[p] = (unsigned char )i;
#line 157
    if ((int )p & 128) {
#line 157
      tmp = 27;
    } else {
#line 157
      tmp = 0;
    }
#line 157
    p = (unsigned char )(((int )p ^ ((int )p << 1)) ^ tmp);
#line 154
    i ++;
  }
#line 160
  log_tab[1] = (unsigned char)0;
#line 160
  p = (unsigned char)1;
#line 162
  i = 0U;
#line 162
  while (i < 10U) {
#line 163
    rco_tab[i] = (unsigned int )p;
#line 165
    if ((int )p & 128) {
#line 165
      tmp___0 = 27;
    } else {
#line 165
      tmp___0 = 0;
    }
#line 165
    p = (unsigned char )(((int )p << 1) ^ tmp___0);
#line 162
    i ++;
  }
#line 174
  i = 0U;
#line 174
  while (i < 256U) {
#line 175
    if (i) {
#line 175
      p = pow_tab[255 - (int )log_tab[i]];
    } else {
#line 175
      p = (unsigned char)0;
    }
#line 175
    q = p;
#line 176
    q = (unsigned char )(((int )q >> 7) | ((int )q << 1));
#line 176
    p = (unsigned char )((int )p ^ (int )q);
#line 177
    q = (unsigned char )(((int )q >> 7) | ((int )q << 1));
#line 177
    p = (unsigned char )((int )p ^ (int )q);
#line 178
    q = (unsigned char )(((int )q >> 7) | ((int )q << 1));
#line 178
    p = (unsigned char )((int )p ^ (int )q);
#line 179
    q = (unsigned char )(((int )q >> 7) | ((int )q << 1));
#line 179
    p = (unsigned char )((int )p ^ ((int )q ^ 99));
#line 180
    sbx_tab[i] = p;
#line 180
    isb_tab[p] = (unsigned char )i;
#line 174
    i ++;
  }
#line 183
  i = 0U;
#line 183
  while (i < 256U) {
#line 184
    p = sbx_tab[i];
#line 188
    t = (unsigned int )p;
#line 188
    fl_tab[0][i] = t;
#line 189
    fl_tab[1][i] = (t << 8) | (t >> 24);
#line 190
    fl_tab[2][i] = (t << 16) | (t >> 16);
#line 191
    fl_tab[3][i] = (t << 24) | (t >> 8);
#line 193
    if (p) {
#line 193
      tmp___1 = (int )pow_tab[((int )log_tab[2] + (int )log_tab[p]) % 255];
    } else {
#line 193
      tmp___1 = 0;
    }
#line 193
    if (p) {
#line 193
      tmp___2 = (int )pow_tab[((int )log_tab[3] + (int )log_tab[p]) % 255];
    } else {
#line 193
      tmp___2 = 0;
    }
#line 193
    t = (((unsigned int )tmp___1 | ((unsigned int )p << 8)) | ((unsigned int )p << 16)) | ((unsigned int )tmp___2 << 24);
#line 198
    ft_tab[0][i] = t;
#line 199
    ft_tab[1][i] = (t << 8) | (t >> 24);
#line 200
    ft_tab[2][i] = (t << 16) | (t >> 16);
#line 201
    ft_tab[3][i] = (t << 24) | (t >> 8);
#line 203
    p = isb_tab[i];
#line 207
    t = (unsigned int )p;
#line 207
    il_tab[0][i] = t;
#line 208
    il_tab[1][i] = (t << 8) | (t >> 24);
#line 209
    il_tab[2][i] = (t << 16) | (t >> 16);
#line 210
    il_tab[3][i] = (t << 24) | (t >> 8);
#line 212
    if (p) {
#line 212
      tmp___3 = (int )pow_tab[((int )log_tab[14] + (int )log_tab[p]) % 255];
    } else {
#line 212
      tmp___3 = 0;
    }
#line 212
    if (p) {
#line 212
      tmp___4 = (int )pow_tab[((int )log_tab[9] + (int )log_tab[p]) % 255];
    } else {
#line 212
      tmp___4 = 0;
    }
#line 212
    if (p) {
#line 212
      tmp___5 = (int )pow_tab[((int )log_tab[13] + (int )log_tab[p]) % 255];
    } else {
#line 212
      tmp___5 = 0;
    }
#line 212
    if (p) {
#line 212
      tmp___6 = (int )pow_tab[((int )log_tab[11] + (int )log_tab[p]) % 255];
    } else {
#line 212
      tmp___6 = 0;
    }
#line 212
    t = (((unsigned int )tmp___3 | ((unsigned int )tmp___4 << 8)) | ((unsigned int )tmp___5 << 16)) | ((unsigned int )tmp___6 << 24);
#line 217
    it_tab[0][i] = t;
#line 218
    it_tab[1][i] = (t << 8) | (t >> 24);
#line 219
    it_tab[2][i] = (t << 16) | (t >> 16);
#line 220
    it_tab[3][i] = (t << 24) | (t >> 8);
#line 183
    i ++;
  }
#line 223
  tab_gen = 1U;
#line 224
  return;
}
}
#line 271 "rijndael.c"
rijndael_ctx *rijndael_set_key(rijndael_ctx *ctx , u4byte const   *in_key , u4byte key_len ,
                               int encrypt ) 
{ u4byte i ;
  u4byte t ;
  u4byte u ;
  u4byte v ;
  u4byte w ;
  u4byte *e_key ;
  u4byte *d_key ;

  {
#line 276
  e_key = ctx->e_key;
#line 277
  d_key = ctx->d_key;
#line 279
  ctx->decrypt = ! encrypt;
#line 281
  if (! tab_gen) {
#line 282
    gen_tabs();
  }
#line 284
  ctx->k_len = (key_len + 31U) / 32U;
#line 286
  *(e_key + 0) = (unsigned int )*(in_key + 0);
#line 286
  *(e_key + 1) = (unsigned int )*(in_key + 1);
#line 287
  *(e_key + 2) = (unsigned int )*(in_key + 2);
#line 287
  *(e_key + 3) = (unsigned int )*(in_key + 3);
#line 289
  switch ((int )ctx->k_len) {
  case 4: 
#line 290
  t = *(e_key + 3);
#line 291
  i = 0U;
#line 291
  while (i < 10U) {
#line 292
    t = (((fl_tab[0][(unsigned char )((t >> 8) | (t << 24))] ^ fl_tab[1][(unsigned char )(((t >> 8) | (t << 24)) >> 8)]) ^ fl_tab[2][(unsigned char )(((t >> 8) | (t << 24)) >> 16)]) ^ fl_tab[3][(unsigned char )(((t >> 8) | (t << 24)) >> 24)]) ^ rco_tab[i];
#line 292
    t ^= *(e_key + 4U * i);
#line 292
    *(e_key + (4U * i + 4U)) = t;
#line 292
    t ^= *(e_key + (4U * i + 1U));
#line 292
    *(e_key + (4U * i + 5U)) = t;
#line 292
    t ^= *(e_key + (4U * i + 2U));
#line 292
    *(e_key + (4U * i + 6U)) = t;
#line 292
    t ^= *(e_key + (4U * i + 3U));
#line 292
    *(e_key + (4U * i + 7U)) = t;
#line 291
    i ++;
  }
#line 293
  break;
  case 6: 
#line 295
  *(e_key + 4) = (unsigned int )*(in_key + 4);
#line 295
  *(e_key + 5) = (unsigned int )*(in_key + 5);
#line 295
  t = *(e_key + 5);
#line 296
  i = 0U;
#line 296
  while (i < 8U) {
#line 297
    t = (((fl_tab[0][(unsigned char )((t >> 8) | (t << 24))] ^ fl_tab[1][(unsigned char )(((t >> 8) | (t << 24)) >> 8)]) ^ fl_tab[2][(unsigned char )(((t >> 8) | (t << 24)) >> 16)]) ^ fl_tab[3][(unsigned char )(((t >> 8) | (t << 24)) >> 24)]) ^ rco_tab[i];
#line 297
    t ^= *(e_key + 6U * i);
#line 297
    *(e_key + (6U * i + 6U)) = t;
#line 297
    t ^= *(e_key + (6U * i + 1U));
#line 297
    *(e_key + (6U * i + 7U)) = t;
#line 297
    t ^= *(e_key + (6U * i + 2U));
#line 297
    *(e_key + (6U * i + 8U)) = t;
#line 297
    t ^= *(e_key + (6U * i + 3U));
#line 297
    *(e_key + (6U * i + 9U)) = t;
#line 297
    t ^= *(e_key + (6U * i + 4U));
#line 297
    *(e_key + (6U * i + 10U)) = t;
#line 297
    t ^= *(e_key + (6U * i + 5U));
#line 297
    *(e_key + (6U * i + 11U)) = t;
#line 296
    i ++;
  }
#line 298
  break;
  case 8: 
#line 300
  *(e_key + 4) = (unsigned int )*(in_key + 4);
#line 300
  *(e_key + 5) = (unsigned int )*(in_key + 5);
#line 301
  *(e_key + 6) = (unsigned int )*(in_key + 6);
#line 301
  *(e_key + 7) = (unsigned int )*(in_key + 7);
#line 301
  t = *(e_key + 7);
#line 302
  i = 0U;
#line 302
  while (i < 7U) {
#line 303
    t = (((fl_tab[0][(unsigned char )((t >> 8) | (t << 24))] ^ fl_tab[1][(unsigned char )(((t >> 8) | (t << 24)) >> 8)]) ^ fl_tab[2][(unsigned char )(((t >> 8) | (t << 24)) >> 16)]) ^ fl_tab[3][(unsigned char )(((t >> 8) | (t << 24)) >> 24)]) ^ rco_tab[i];
#line 303
    t ^= *(e_key + 8U * i);
#line 303
    *(e_key + (8U * i + 8U)) = t;
#line 303
    t ^= *(e_key + (8U * i + 1U));
#line 303
    *(e_key + (8U * i + 9U)) = t;
#line 303
    t ^= *(e_key + (8U * i + 2U));
#line 303
    *(e_key + (8U * i + 10U)) = t;
#line 303
    t ^= *(e_key + (8U * i + 3U));
#line 303
    *(e_key + (8U * i + 11U)) = t;
#line 303
    t = *(e_key + (8U * i + 4U)) ^ (((fl_tab[0][(unsigned char )t] ^ fl_tab[1][(unsigned char )(t >> 8)]) ^ fl_tab[2][(unsigned char )(t >> 16)]) ^ fl_tab[3][(unsigned char )(t >> 24)]);
#line 303
    *(e_key + (8U * i + 12U)) = t;
#line 303
    t ^= *(e_key + (8U * i + 5U));
#line 303
    *(e_key + (8U * i + 13U)) = t;
#line 303
    t ^= *(e_key + (8U * i + 6U));
#line 303
    *(e_key + (8U * i + 14U)) = t;
#line 303
    t ^= *(e_key + (8U * i + 7U));
#line 303
    *(e_key + (8U * i + 15U)) = t;
#line 302
    i ++;
  }
#line 304
  break;
  }
#line 307
  if (! encrypt) {
#line 308
    *(d_key + 0) = *(e_key + 0);
#line 308
    *(d_key + 1) = *(e_key + 1);
#line 309
    *(d_key + 2) = *(e_key + 2);
#line 309
    *(d_key + 3) = *(e_key + 3);
#line 311
    i = 4U;
#line 311
    while (i < 4U * ctx->k_len + 24U) {
#line 312
      u = ((*(e_key + i) & 2139062143U) << 1) ^ ((*(e_key + i) & 2155905152U) >> 7) * 27U;
#line 312
      v = ((u & 2139062143U) << 1) ^ ((u & 2155905152U) >> 7) * 27U;
#line 312
      w = ((v & 2139062143U) << 1) ^ ((v & 2155905152U) >> 7) * 27U;
#line 312
      t = w ^ *(e_key + i);
#line 312
      *(d_key + i) = (u ^ v) ^ w;
#line 312
      *(d_key + i) ^= ((((u ^ t) >> 8) | ((u ^ t) << 24)) ^ (((v ^ t) >> 16) | ((v ^ t) << 16))) ^ ((t >> 24) | (t << 8));
#line 311
      i ++;
    }
  }
#line 316
  return (ctx);
}
}
#line 334 "rijndael.c"
void rijndael_encrypt(rijndael_ctx *ctx , u4byte const   *in_blk , u4byte *out_blk ) 
{ u4byte k_len ;
  u4byte *e_key ;
  u4byte b0[4] ;
  u4byte b1[4] ;
  u4byte *kp ;

  {
#line 337
  k_len = ctx->k_len;
#line 338
  e_key = ctx->e_key;
#line 341
  b0[0] = (unsigned int )(*(in_blk + 0) ^ (unsigned int const   )*(e_key + 0));
#line 342
  b0[1] = (unsigned int )(*(in_blk + 1) ^ (unsigned int const   )*(e_key + 1));
#line 343
  b0[2] = (unsigned int )(*(in_blk + 2) ^ (unsigned int const   )*(e_key + 2));
#line 344
  b0[3] = (unsigned int )(*(in_blk + 3) ^ (unsigned int const   )*(e_key + 3));
#line 346
  kp = e_key + 4;
#line 348
  if (k_len > 6U) {
#line 349
    b1[0] = (((ft_tab[0][(unsigned char )b0[0]] ^ ft_tab[1][(unsigned char )(b0[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 0);
#line 349
    b1[1] = (((ft_tab[0][(unsigned char )b0[1]] ^ ft_tab[1][(unsigned char )(b0[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 1);
#line 349
    b1[2] = (((ft_tab[0][(unsigned char )b0[2]] ^ ft_tab[1][(unsigned char )(b0[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 2);
#line 349
    b1[3] = (((ft_tab[0][(unsigned char )b0[3]] ^ ft_tab[1][(unsigned char )(b0[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 3);
#line 349
    kp += 4;
#line 349
    b0[0] = (((ft_tab[0][(unsigned char )b1[0]] ^ ft_tab[1][(unsigned char )(b1[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 0);
#line 349
    b0[1] = (((ft_tab[0][(unsigned char )b1[1]] ^ ft_tab[1][(unsigned char )(b1[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 1);
#line 349
    b0[2] = (((ft_tab[0][(unsigned char )b1[2]] ^ ft_tab[1][(unsigned char )(b1[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 2);
#line 349
    b0[3] = (((ft_tab[0][(unsigned char )b1[3]] ^ ft_tab[1][(unsigned char )(b1[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 3);
#line 349
    kp += 4;
  }
#line 352
  if (k_len > 4U) {
#line 353
    b1[0] = (((ft_tab[0][(unsigned char )b0[0]] ^ ft_tab[1][(unsigned char )(b0[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 0);
#line 353
    b1[1] = (((ft_tab[0][(unsigned char )b0[1]] ^ ft_tab[1][(unsigned char )(b0[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 1);
#line 353
    b1[2] = (((ft_tab[0][(unsigned char )b0[2]] ^ ft_tab[1][(unsigned char )(b0[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 2);
#line 353
    b1[3] = (((ft_tab[0][(unsigned char )b0[3]] ^ ft_tab[1][(unsigned char )(b0[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 3);
#line 353
    kp += 4;
#line 353
    b0[0] = (((ft_tab[0][(unsigned char )b1[0]] ^ ft_tab[1][(unsigned char )(b1[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 0);
#line 353
    b0[1] = (((ft_tab[0][(unsigned char )b1[1]] ^ ft_tab[1][(unsigned char )(b1[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 1);
#line 353
    b0[2] = (((ft_tab[0][(unsigned char )b1[2]] ^ ft_tab[1][(unsigned char )(b1[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 2);
#line 353
    b0[3] = (((ft_tab[0][(unsigned char )b1[3]] ^ ft_tab[1][(unsigned char )(b1[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 3);
#line 353
    kp += 4;
  }
#line 356
  b1[0] = (((ft_tab[0][(unsigned char )b0[0]] ^ ft_tab[1][(unsigned char )(b0[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 0);
#line 356
  b1[1] = (((ft_tab[0][(unsigned char )b0[1]] ^ ft_tab[1][(unsigned char )(b0[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 1);
#line 356
  b1[2] = (((ft_tab[0][(unsigned char )b0[2]] ^ ft_tab[1][(unsigned char )(b0[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 2);
#line 356
  b1[3] = (((ft_tab[0][(unsigned char )b0[3]] ^ ft_tab[1][(unsigned char )(b0[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 3);
#line 356
  kp += 4;
#line 356
  b0[0] = (((ft_tab[0][(unsigned char )b1[0]] ^ ft_tab[1][(unsigned char )(b1[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 0);
#line 356
  b0[1] = (((ft_tab[0][(unsigned char )b1[1]] ^ ft_tab[1][(unsigned char )(b1[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 1);
#line 356
  b0[2] = (((ft_tab[0][(unsigned char )b1[2]] ^ ft_tab[1][(unsigned char )(b1[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 2);
#line 356
  b0[3] = (((ft_tab[0][(unsigned char )b1[3]] ^ ft_tab[1][(unsigned char )(b1[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 3);
#line 356
  kp += 4;
#line 357
  b1[0] = (((ft_tab[0][(unsigned char )b0[0]] ^ ft_tab[1][(unsigned char )(b0[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 0);
#line 357
  b1[1] = (((ft_tab[0][(unsigned char )b0[1]] ^ ft_tab[1][(unsigned char )(b0[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 1);
#line 357
  b1[2] = (((ft_tab[0][(unsigned char )b0[2]] ^ ft_tab[1][(unsigned char )(b0[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 2);
#line 357
  b1[3] = (((ft_tab[0][(unsigned char )b0[3]] ^ ft_tab[1][(unsigned char )(b0[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 3);
#line 357
  kp += 4;
#line 357
  b0[0] = (((ft_tab[0][(unsigned char )b1[0]] ^ ft_tab[1][(unsigned char )(b1[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 0);
#line 357
  b0[1] = (((ft_tab[0][(unsigned char )b1[1]] ^ ft_tab[1][(unsigned char )(b1[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 1);
#line 357
  b0[2] = (((ft_tab[0][(unsigned char )b1[2]] ^ ft_tab[1][(unsigned char )(b1[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 2);
#line 357
  b0[3] = (((ft_tab[0][(unsigned char )b1[3]] ^ ft_tab[1][(unsigned char )(b1[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 3);
#line 357
  kp += 4;
#line 358
  b1[0] = (((ft_tab[0][(unsigned char )b0[0]] ^ ft_tab[1][(unsigned char )(b0[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 0);
#line 358
  b1[1] = (((ft_tab[0][(unsigned char )b0[1]] ^ ft_tab[1][(unsigned char )(b0[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 1);
#line 358
  b1[2] = (((ft_tab[0][(unsigned char )b0[2]] ^ ft_tab[1][(unsigned char )(b0[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 2);
#line 358
  b1[3] = (((ft_tab[0][(unsigned char )b0[3]] ^ ft_tab[1][(unsigned char )(b0[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 3);
#line 358
  kp += 4;
#line 358
  b0[0] = (((ft_tab[0][(unsigned char )b1[0]] ^ ft_tab[1][(unsigned char )(b1[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 0);
#line 358
  b0[1] = (((ft_tab[0][(unsigned char )b1[1]] ^ ft_tab[1][(unsigned char )(b1[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 1);
#line 358
  b0[2] = (((ft_tab[0][(unsigned char )b1[2]] ^ ft_tab[1][(unsigned char )(b1[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 2);
#line 358
  b0[3] = (((ft_tab[0][(unsigned char )b1[3]] ^ ft_tab[1][(unsigned char )(b1[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 3);
#line 358
  kp += 4;
#line 359
  b1[0] = (((ft_tab[0][(unsigned char )b0[0]] ^ ft_tab[1][(unsigned char )(b0[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 0);
#line 359
  b1[1] = (((ft_tab[0][(unsigned char )b0[1]] ^ ft_tab[1][(unsigned char )(b0[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 1);
#line 359
  b1[2] = (((ft_tab[0][(unsigned char )b0[2]] ^ ft_tab[1][(unsigned char )(b0[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 2);
#line 359
  b1[3] = (((ft_tab[0][(unsigned char )b0[3]] ^ ft_tab[1][(unsigned char )(b0[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 3);
#line 359
  kp += 4;
#line 359
  b0[0] = (((ft_tab[0][(unsigned char )b1[0]] ^ ft_tab[1][(unsigned char )(b1[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 0);
#line 359
  b0[1] = (((ft_tab[0][(unsigned char )b1[1]] ^ ft_tab[1][(unsigned char )(b1[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 1);
#line 359
  b0[2] = (((ft_tab[0][(unsigned char )b1[2]] ^ ft_tab[1][(unsigned char )(b1[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 2);
#line 359
  b0[3] = (((ft_tab[0][(unsigned char )b1[3]] ^ ft_tab[1][(unsigned char )(b1[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 3);
#line 359
  kp += 4;
#line 360
  b1[0] = (((ft_tab[0][(unsigned char )b0[0]] ^ ft_tab[1][(unsigned char )(b0[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 0);
#line 360
  b1[1] = (((ft_tab[0][(unsigned char )b0[1]] ^ ft_tab[1][(unsigned char )(b0[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 1);
#line 360
  b1[2] = (((ft_tab[0][(unsigned char )b0[2]] ^ ft_tab[1][(unsigned char )(b0[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 2);
#line 360
  b1[3] = (((ft_tab[0][(unsigned char )b0[3]] ^ ft_tab[1][(unsigned char )(b0[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 3);
#line 360
  kp += 4;
#line 360
  b0[0] = (((fl_tab[0][(unsigned char )b1[0]] ^ fl_tab[1][(unsigned char )(b1[1] >> 8)]) ^ fl_tab[2][(unsigned char )(b1[2] >> 16)]) ^ fl_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 0);
#line 360
  b0[1] = (((fl_tab[0][(unsigned char )b1[1]] ^ fl_tab[1][(unsigned char )(b1[2] >> 8)]) ^ fl_tab[2][(unsigned char )(b1[3] >> 16)]) ^ fl_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 1);
#line 360
  b0[2] = (((fl_tab[0][(unsigned char )b1[2]] ^ fl_tab[1][(unsigned char )(b1[3] >> 8)]) ^ fl_tab[2][(unsigned char )(b1[0] >> 16)]) ^ fl_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 2);
#line 360
  b0[3] = (((fl_tab[0][(unsigned char )b1[3]] ^ fl_tab[1][(unsigned char )(b1[0] >> 8)]) ^ fl_tab[2][(unsigned char )(b1[1] >> 16)]) ^ fl_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 3);
#line 362
  *(out_blk + 0) = b0[0];
#line 362
  *(out_blk + 1) = b0[1];
#line 363
  *(out_blk + 2) = b0[2];
#line 363
  *(out_blk + 3) = b0[3];
#line 364
  return;
}
}
#line 381 "rijndael.c"
void rijndael_decrypt(rijndael_ctx *ctx , u4byte const   *in_blk , u4byte *out_blk ) 
{ u4byte b0[4] ;
  u4byte b1[4] ;
  u4byte *kp ;
  u4byte k_len ;
  u4byte *e_key ;
  u4byte *d_key ;

  {
#line 385
  k_len = ctx->k_len;
#line 386
  e_key = ctx->e_key;
#line 387
  d_key = ctx->d_key;
#line 389
  b0[0] = (unsigned int )(*(in_blk + 0) ^ (unsigned int const   )*(e_key + (4U * k_len + 24U)));
#line 390
  b0[1] = (unsigned int )(*(in_blk + 1) ^ (unsigned int const   )*(e_key + (4U * k_len + 25U)));
#line 391
  b0[2] = (unsigned int )(*(in_blk + 2) ^ (unsigned int const   )*(e_key + (4U * k_len + 26U)));
#line 392
  b0[3] = (unsigned int )(*(in_blk + 3) ^ (unsigned int const   )*(e_key + (4U * k_len + 27U)));
#line 394
  kp = d_key + 4U * (k_len + 5U);
#line 396
  if (k_len > 6U) {
#line 397
    b1[0] = (((it_tab[0][(unsigned char )b0[0]] ^ it_tab[1][(unsigned char )(b0[3] >> 8)]) ^ it_tab[2][(unsigned char )(b0[2] >> 16)]) ^ it_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 0);
#line 397
    b1[1] = (((it_tab[0][(unsigned char )b0[1]] ^ it_tab[1][(unsigned char )(b0[0] >> 8)]) ^ it_tab[2][(unsigned char )(b0[3] >> 16)]) ^ it_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 1);
#line 397
    b1[2] = (((it_tab[0][(unsigned char )b0[2]] ^ it_tab[1][(unsigned char )(b0[1] >> 8)]) ^ it_tab[2][(unsigned char )(b0[0] >> 16)]) ^ it_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 2);
#line 397
    b1[3] = (((it_tab[0][(unsigned char )b0[3]] ^ it_tab[1][(unsigned char )(b0[2] >> 8)]) ^ it_tab[2][(unsigned char )(b0[1] >> 16)]) ^ it_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 3);
#line 397
    kp -= 4;
#line 397
    b0[0] = (((it_tab[0][(unsigned char )b1[0]] ^ it_tab[1][(unsigned char )(b1[3] >> 8)]) ^ it_tab[2][(unsigned char )(b1[2] >> 16)]) ^ it_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 0);
#line 397
    b0[1] = (((it_tab[0][(unsigned char )b1[1]] ^ it_tab[1][(unsigned char )(b1[0] >> 8)]) ^ it_tab[2][(unsigned char )(b1[3] >> 16)]) ^ it_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 1);
#line 397
    b0[2] = (((it_tab[0][(unsigned char )b1[2]] ^ it_tab[1][(unsigned char )(b1[1] >> 8)]) ^ it_tab[2][(unsigned char )(b1[0] >> 16)]) ^ it_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 2);
#line 397
    b0[3] = (((it_tab[0][(unsigned char )b1[3]] ^ it_tab[1][(unsigned char )(b1[2] >> 8)]) ^ it_tab[2][(unsigned char )(b1[1] >> 16)]) ^ it_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 3);
#line 397
    kp -= 4;
  }
#line 400
  if (k_len > 4U) {
#line 401
    b1[0] = (((it_tab[0][(unsigned char )b0[0]] ^ it_tab[1][(unsigned char )(b0[3] >> 8)]) ^ it_tab[2][(unsigned char )(b0[2] >> 16)]) ^ it_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 0);
#line 401
    b1[1] = (((it_tab[0][(unsigned char )b0[1]] ^ it_tab[1][(unsigned char )(b0[0] >> 8)]) ^ it_tab[2][(unsigned char )(b0[3] >> 16)]) ^ it_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 1);
#line 401
    b1[2] = (((it_tab[0][(unsigned char )b0[2]] ^ it_tab[1][(unsigned char )(b0[1] >> 8)]) ^ it_tab[2][(unsigned char )(b0[0] >> 16)]) ^ it_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 2);
#line 401
    b1[3] = (((it_tab[0][(unsigned char )b0[3]] ^ it_tab[1][(unsigned char )(b0[2] >> 8)]) ^ it_tab[2][(unsigned char )(b0[1] >> 16)]) ^ it_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 3);
#line 401
    kp -= 4;
#line 401
    b0[0] = (((it_tab[0][(unsigned char )b1[0]] ^ it_tab[1][(unsigned char )(b1[3] >> 8)]) ^ it_tab[2][(unsigned char )(b1[2] >> 16)]) ^ it_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 0);
#line 401
    b0[1] = (((it_tab[0][(unsigned char )b1[1]] ^ it_tab[1][(unsigned char )(b1[0] >> 8)]) ^ it_tab[2][(unsigned char )(b1[3] >> 16)]) ^ it_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 1);
#line 401
    b0[2] = (((it_tab[0][(unsigned char )b1[2]] ^ it_tab[1][(unsigned char )(b1[1] >> 8)]) ^ it_tab[2][(unsigned char )(b1[0] >> 16)]) ^ it_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 2);
#line 401
    b0[3] = (((it_tab[0][(unsigned char )b1[3]] ^ it_tab[1][(unsigned char )(b1[2] >> 8)]) ^ it_tab[2][(unsigned char )(b1[1] >> 16)]) ^ it_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 3);
#line 401
    kp -= 4;
  }
#line 404
  b1[0] = (((it_tab[0][(unsigned char )b0[0]] ^ it_tab[1][(unsigned char )(b0[3] >> 8)]) ^ it_tab[2][(unsigned char )(b0[2] >> 16)]) ^ it_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 0);
#line 404
  b1[1] = (((it_tab[0][(unsigned char )b0[1]] ^ it_tab[1][(unsigned char )(b0[0] >> 8)]) ^ it_tab[2][(unsigned char )(b0[3] >> 16)]) ^ it_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 1);
#line 404
  b1[2] = (((it_tab[0][(unsigned char )b0[2]] ^ it_tab[1][(unsigned char )(b0[1] >> 8)]) ^ it_tab[2][(unsigned char )(b0[0] >> 16)]) ^ it_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 2);
#line 404
  b1[3] = (((it_tab[0][(unsigned char )b0[3]] ^ it_tab[1][(unsigned char )(b0[2] >> 8)]) ^ it_tab[2][(unsigned char )(b0[1] >> 16)]) ^ it_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 3);
#line 404
  kp -= 4;
#line 404
  b0[0] = (((it_tab[0][(unsigned char )b1[0]] ^ it_tab[1][(unsigned char )(b1[3] >> 8)]) ^ it_tab[2][(unsigned char )(b1[2] >> 16)]) ^ it_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 0);
#line 404
  b0[1] = (((it_tab[0][(unsigned char )b1[1]] ^ it_tab[1][(unsigned char )(b1[0] >> 8)]) ^ it_tab[2][(unsigned char )(b1[3] >> 16)]) ^ it_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 1);
#line 404
  b0[2] = (((it_tab[0][(unsigned char )b1[2]] ^ it_tab[1][(unsigned char )(b1[1] >> 8)]) ^ it_tab[2][(unsigned char )(b1[0] >> 16)]) ^ it_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 2);
#line 404
  b0[3] = (((it_tab[0][(unsigned char )b1[3]] ^ it_tab[1][(unsigned char )(b1[2] >> 8)]) ^ it_tab[2][(unsigned char )(b1[1] >> 16)]) ^ it_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 3);
#line 404
  kp -= 4;
#line 405
  b1[0] = (((it_tab[0][(unsigned char )b0[0]] ^ it_tab[1][(unsigned char )(b0[3] >> 8)]) ^ it_tab[2][(unsigned char )(b0[2] >> 16)]) ^ it_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 0);
#line 405
  b1[1] = (((it_tab[0][(unsigned char )b0[1]] ^ it_tab[1][(unsigned char )(b0[0] >> 8)]) ^ it_tab[2][(unsigned char )(b0[3] >> 16)]) ^ it_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 1);
#line 405
  b1[2] = (((it_tab[0][(unsigned char )b0[2]] ^ it_tab[1][(unsigned char )(b0[1] >> 8)]) ^ it_tab[2][(unsigned char )(b0[0] >> 16)]) ^ it_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 2);
#line 405
  b1[3] = (((it_tab[0][(unsigned char )b0[3]] ^ it_tab[1][(unsigned char )(b0[2] >> 8)]) ^ it_tab[2][(unsigned char )(b0[1] >> 16)]) ^ it_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 3);
#line 405
  kp -= 4;
#line 405
  b0[0] = (((it_tab[0][(unsigned char )b1[0]] ^ it_tab[1][(unsigned char )(b1[3] >> 8)]) ^ it_tab[2][(unsigned char )(b1[2] >> 16)]) ^ it_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 0);
#line 405
  b0[1] = (((it_tab[0][(unsigned char )b1[1]] ^ it_tab[1][(unsigned char )(b1[0] >> 8)]) ^ it_tab[2][(unsigned char )(b1[3] >> 16)]) ^ it_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 1);
#line 405
  b0[2] = (((it_tab[0][(unsigned char )b1[2]] ^ it_tab[1][(unsigned char )(b1[1] >> 8)]) ^ it_tab[2][(unsigned char )(b1[0] >> 16)]) ^ it_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 2);
#line 405
  b0[3] = (((it_tab[0][(unsigned char )b1[3]] ^ it_tab[1][(unsigned char )(b1[2] >> 8)]) ^ it_tab[2][(unsigned char )(b1[1] >> 16)]) ^ it_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 3);
#line 405
  kp -= 4;
#line 406
  b1[0] = (((it_tab[0][(unsigned char )b0[0]] ^ it_tab[1][(unsigned char )(b0[3] >> 8)]) ^ it_tab[2][(unsigned char )(b0[2] >> 16)]) ^ it_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 0);
#line 406
  b1[1] = (((it_tab[0][(unsigned char )b0[1]] ^ it_tab[1][(unsigned char )(b0[0] >> 8)]) ^ it_tab[2][(unsigned char )(b0[3] >> 16)]) ^ it_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 1);
#line 406
  b1[2] = (((it_tab[0][(unsigned char )b0[2]] ^ it_tab[1][(unsigned char )(b0[1] >> 8)]) ^ it_tab[2][(unsigned char )(b0[0] >> 16)]) ^ it_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 2);
#line 406
  b1[3] = (((it_tab[0][(unsigned char )b0[3]] ^ it_tab[1][(unsigned char )(b0[2] >> 8)]) ^ it_tab[2][(unsigned char )(b0[1] >> 16)]) ^ it_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 3);
#line 406
  kp -= 4;
#line 406
  b0[0] = (((it_tab[0][(unsigned char )b1[0]] ^ it_tab[1][(unsigned char )(b1[3] >> 8)]) ^ it_tab[2][(unsigned char )(b1[2] >> 16)]) ^ it_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 0);
#line 406
  b0[1] = (((it_tab[0][(unsigned char )b1[1]] ^ it_tab[1][(unsigned char )(b1[0] >> 8)]) ^ it_tab[2][(unsigned char )(b1[3] >> 16)]) ^ it_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 1);
#line 406
  b0[2] = (((it_tab[0][(unsigned char )b1[2]] ^ it_tab[1][(unsigned char )(b1[1] >> 8)]) ^ it_tab[2][(unsigned char )(b1[0] >> 16)]) ^ it_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 2);
#line 406
  b0[3] = (((it_tab[0][(unsigned char )b1[3]] ^ it_tab[1][(unsigned char )(b1[2] >> 8)]) ^ it_tab[2][(unsigned char )(b1[1] >> 16)]) ^ it_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 3);
#line 406
  kp -= 4;
#line 407
  b1[0] = (((it_tab[0][(unsigned char )b0[0]] ^ it_tab[1][(unsigned char )(b0[3] >> 8)]) ^ it_tab[2][(unsigned char )(b0[2] >> 16)]) ^ it_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 0);
#line 407
  b1[1] = (((it_tab[0][(unsigned char )b0[1]] ^ it_tab[1][(unsigned char )(b0[0] >> 8)]) ^ it_tab[2][(unsigned char )(b0[3] >> 16)]) ^ it_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 1);
#line 407
  b1[2] = (((it_tab[0][(unsigned char )b0[2]] ^ it_tab[1][(unsigned char )(b0[1] >> 8)]) ^ it_tab[2][(unsigned char )(b0[0] >> 16)]) ^ it_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 2);
#line 407
  b1[3] = (((it_tab[0][(unsigned char )b0[3]] ^ it_tab[1][(unsigned char )(b0[2] >> 8)]) ^ it_tab[2][(unsigned char )(b0[1] >> 16)]) ^ it_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 3);
#line 407
  kp -= 4;
#line 407
  b0[0] = (((it_tab[0][(unsigned char )b1[0]] ^ it_tab[1][(unsigned char )(b1[3] >> 8)]) ^ it_tab[2][(unsigned char )(b1[2] >> 16)]) ^ it_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 0);
#line 407
  b0[1] = (((it_tab[0][(unsigned char )b1[1]] ^ it_tab[1][(unsigned char )(b1[0] >> 8)]) ^ it_tab[2][(unsigned char )(b1[3] >> 16)]) ^ it_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 1);
#line 407
  b0[2] = (((it_tab[0][(unsigned char )b1[2]] ^ it_tab[1][(unsigned char )(b1[1] >> 8)]) ^ it_tab[2][(unsigned char )(b1[0] >> 16)]) ^ it_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 2);
#line 407
  b0[3] = (((it_tab[0][(unsigned char )b1[3]] ^ it_tab[1][(unsigned char )(b1[2] >> 8)]) ^ it_tab[2][(unsigned char )(b1[1] >> 16)]) ^ it_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 3);
#line 407
  kp -= 4;
#line 408
  b1[0] = (((it_tab[0][(unsigned char )b0[0]] ^ it_tab[1][(unsigned char )(b0[3] >> 8)]) ^ it_tab[2][(unsigned char )(b0[2] >> 16)]) ^ it_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 0);
#line 408
  b1[1] = (((it_tab[0][(unsigned char )b0[1]] ^ it_tab[1][(unsigned char )(b0[0] >> 8)]) ^ it_tab[2][(unsigned char )(b0[3] >> 16)]) ^ it_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 1);
#line 408
  b1[2] = (((it_tab[0][(unsigned char )b0[2]] ^ it_tab[1][(unsigned char )(b0[1] >> 8)]) ^ it_tab[2][(unsigned char )(b0[0] >> 16)]) ^ it_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 2);
#line 408
  b1[3] = (((it_tab[0][(unsigned char )b0[3]] ^ it_tab[1][(unsigned char )(b0[2] >> 8)]) ^ it_tab[2][(unsigned char )(b0[1] >> 16)]) ^ it_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 3);
#line 408
  kp -= 4;
#line 408
  b0[0] = (((il_tab[0][(unsigned char )b1[0]] ^ il_tab[1][(unsigned char )(b1[3] >> 8)]) ^ il_tab[2][(unsigned char )(b1[2] >> 16)]) ^ il_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 0);
#line 408
  b0[1] = (((il_tab[0][(unsigned char )b1[1]] ^ il_tab[1][(unsigned char )(b1[0] >> 8)]) ^ il_tab[2][(unsigned char )(b1[3] >> 16)]) ^ il_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 1);
#line 408
  b0[2] = (((il_tab[0][(unsigned char )b1[2]] ^ il_tab[1][(unsigned char )(b1[1] >> 8)]) ^ il_tab[2][(unsigned char )(b1[0] >> 16)]) ^ il_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 2);
#line 408
  b0[3] = (((il_tab[0][(unsigned char )b1[3]] ^ il_tab[1][(unsigned char )(b1[2] >> 8)]) ^ il_tab[2][(unsigned char )(b1[1] >> 16)]) ^ il_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 3);
#line 410
  *(out_blk + 0) = b0[0];
#line 410
  *(out_blk + 1) = b0[1];
#line 411
  *(out_blk + 2) = b0[2];
#line 411
  *(out_blk + 3) = b0[3];
#line 412
  return;
}
}
#line 1 "entropy.o"
#pragma merger(0,"./entropy.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 31 "entropy.h"
void init_rng(void) ;
#line 105 "/usr/include/openssl/rand.h"
extern void RAND_add(void const   *buf , int num , double entropy ) ;
#line 109
extern int RAND_status(void) ;
#line 381 "/usr/include/openssl/crypto.h"
extern unsigned long SSLeay(void) ;
#line 71 "entropy.c"
void check_openssl_version(void) 
{ unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 74
  tmp___0 = SSLeay();
#line 74
  if (tmp___0 != 9469999UL) {
#line 75
    tmp = SSLeay();
#line 75
    fatal("OpenSSL version mismatch. Built against %lx, you have %lx", 9469999L, tmp);
  }
#line 77
  return;
}
}
#line 185 "entropy.c"
int get_random_bytes(unsigned char *buf___2 , int len ) 
{ int random_pool ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 190
  random_pool = open("/dev/urandom", 0);
#line 191
  if (random_pool == -1) {
#line 192
    tmp = __errno_location();
#line 192
    tmp___0 = strerror(*tmp);
#line 192
    error("Couldn\'t open random pool \"%s\": %s", "/dev/urandom", tmp___0);
#line 194
    return (0);
  }
#line 197
  tmp___3 = atomicio((ssize_t (*)())(& read), random_pool, (void *)buf___2, (unsigned int )len);
#line 197
  if (tmp___3 != len) {
#line 198
    tmp___1 = __errno_location();
#line 198
    tmp___2 = strerror(*tmp___1);
#line 198
    error("Couldn\'t read from random pool \"%s\": %s", "/dev/urandom", tmp___2);
#line 200
    close(random_pool);
#line 201
    return (0);
  }
#line 204
  close(random_pool);
#line 206
  return (1);
}
}
#line 215 "entropy.c"
void seed_rng(void) 
{ unsigned char buf___2[32] ;
  int tmp ;
  int tmp___0 ;

  {
#line 220
  debug("Seeding random number generator");
#line 222
  tmp___0 = get_random_bytes(buf___2, (int )sizeof(buf___2));
#line 222
  if (tmp___0) {
#line 226
    RAND_add((void const   *)(buf___2), (int )sizeof(buf___2), (double )sizeof(buf___2));
  } else {
#line 223
    tmp = RAND_status();
#line 223
    if (! tmp) {
#line 224
      fatal("Entropy collection failed and entropy exhausted");
    }
  }
#line 229
  memset((void *)(buf___2), '\000', sizeof(buf___2));
#line 230
  return;
}
}
#line 232 "entropy.c"
void init_rng(void) 
{ 

  {
#line 235
  check_openssl_version();
#line 236
  return;
}
}
#line 1 "readpass.o"
#pragma merger(0,"./readpass.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 384 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 493
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 537
extern  __attribute__((__nothrow__)) int execlp(char const   *__file , char const   *__arg 
                                                , ...)  __attribute__((__nonnull__(1))) ;
#line 667
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 677
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 723
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 20 "readpass.h"
char *read_passphrase(char const   *prompt , int from_stdin ) ;
#line 45 "readpass.c"
char *ssh_askpass(char *askpass , char *msg ) 
{ pid_t pid ;
  size_t len ;
  char *nl ;
  char *pass ;
  int p[2] ;
  int status ;
  char buf___2[1024] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  __uid_t tmp___7 ;
  __uid_t tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  ssize_t tmp___14 ;
  int *tmp___15 ;
  __pid_t tmp___16 ;
  char *tmp___17 ;
  char *tmp___19 ;

  {
#line 54
  tmp___1 = fflush(stdout);
#line 54
  if (tmp___1 != 0) {
#line 55
    tmp = __errno_location();
#line 55
    tmp___0 = strerror(*tmp);
#line 55
    error("ssh_askpass: fflush: %s", tmp___0);
  }
#line 56
  if ((unsigned int )askpass == (unsigned int )((void *)0)) {
#line 57
    fatal("internal error: askpass undefined");
  }
#line 58
  tmp___4 = pipe((int *)(p));
#line 58
  if (tmp___4 < 0) {
#line 59
    tmp___2 = __errno_location();
#line 59
    tmp___3 = strerror(*tmp___2);
#line 59
    fatal("ssh_askpass: pipe: %s", tmp___3);
  }
#line 60
  pid = fork();
#line 60
  if (pid < 0) {
#line 61
    tmp___5 = __errno_location();
#line 61
    tmp___6 = strerror(*tmp___5);
#line 61
    fatal("ssh_askpass: fork: %s", tmp___6);
  }
#line 62
  if (pid == 0) {
#line 63
    tmp___7 = getuid();
#line 63
    seteuid(tmp___7);
#line 64
    tmp___8 = getuid();
#line 64
    setuid(tmp___8);
#line 65
    close(p[0]);
#line 66
    tmp___11 = dup2(p[1], 1);
#line 66
    if (tmp___11 < 0) {
#line 67
      tmp___9 = __errno_location();
#line 67
      tmp___10 = strerror(*tmp___9);
#line 67
      fatal("ssh_askpass: dup2: %s", tmp___10);
    }
#line 68
    execlp((char const   *)askpass, (char const   *)askpass, msg, (char *)0);
#line 69
    tmp___12 = __errno_location();
#line 69
    tmp___13 = strerror(*tmp___12);
#line 69
    fatal("ssh_askpass: exec(%s): %s", askpass, tmp___13);
  }
#line 71
  close(p[1]);
#line 72
  tmp___14 = read(p[0], (void *)(buf___2), sizeof(buf___2));
#line 72
  len = (unsigned int )tmp___14;
#line 73
  close(p[0]);
#line 74
  while (1) {
#line 74
    tmp___16 = waitpid(pid, & status, 0);
#line 74
    if (! (tmp___16 < 0)) {
#line 74
      break;
    }
#line 75
    tmp___15 = __errno_location();
#line 75
    if (*tmp___15 != 4) {
#line 76
      break;
    }
  }
#line 77
  if (len <= 1U) {
#line 78
    tmp___17 = xstrdup("");
#line 78
    return (tmp___17);
  }
#line 79
  tmp___19 = __builtin_strchr(buf___2, '\n');
#line 79
  nl = tmp___19;
#line 80
  if (nl) {
#line 81
    *nl = (char )'\000';
  }
#line 82
  pass = xstrdup((char const   *)(buf___2));
#line 83
  memset((void *)(buf___2), 0, sizeof(buf___2));
#line 84
  return (pass);
}
}
#line 98 "readpass.c"
char *read_passphrase(char const   *prompt , int from_stdin ) 
{ char *askpass ;
  int use_askpass ;
  int ttyfd ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 101
  askpass = (char *)((void *)0);
#line 102
  use_askpass = 0;
#line 104
  if (from_stdin) {
#line 105
    tmp = isatty(0);
#line 105
    if (! tmp) {
#line 106
      use_askpass = 1;
    }
  } else {
#line 108
    ttyfd = open("/dev/tty", 2);
#line 109
    if (ttyfd >= 0) {
#line 110
      close(ttyfd);
    } else {
#line 112
      use_askpass = 1;
    }
  }
#line 115
  if (use_askpass) {
#line 115
    tmp___2 = getenv("DISPLAY");
#line 115
    if (tmp___2) {
#line 116
      tmp___0 = getenv("SSH_ASKPASS");
#line 116
      if (tmp___0) {
#line 117
        askpass = getenv("SSH_ASKPASS");
      } else {
#line 119
        askpass = (char *)"/usr/local/libexec/ssh-askpass";
      }
#line 120
      tmp___1 = ssh_askpass(askpass, (char *)prompt);
#line 120
      return (tmp___1);
    }
  }
#line 123
  tmp___3 = cli_read_passphrase(prompt, from_stdin, 0);
#line 123
  return (tmp___3);
}
}
#line 1 "rsa.o"
#pragma merger(0,"./rsa.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 230 "/usr/include/openssl/rsa.h"
extern int RSA_public_encrypt(int flen , unsigned char const   *from , unsigned char *to ,
                              RSA *rsa , int padding ) ;
#line 236
extern int RSA_private_decrypt(int flen , unsigned char const   *from , unsigned char *to ,
                               RSA *rsa , int padding ) ;
#line 22 "rsa.h"
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 23
int rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 25
void generate_additional_parameters(RSA *rsa ) ;
#line 69 "rsa.c"
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ u_char *inbuf ;
  u_char *outbuf ;
  int len ;
  int ilen ;
  int olen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 75
  tmp = BN_num_bits((BIGNUM const   *)key->e);
#line 75
  if (tmp < 2) {
#line 76
    fatal("rsa_public_encrypt() exponent too small or not odd");
  } else {
#line 75
    if ((key->e)->top > 0) {
#line 75
      if (! (*((key->e)->d + 0) & 1UL)) {
#line 76
        fatal("rsa_public_encrypt() exponent too small or not odd");
      }
    } else {
#line 76
      fatal("rsa_public_encrypt() exponent too small or not odd");
    }
  }
#line 78
  tmp___0 = BN_num_bits((BIGNUM const   *)key->n);
#line 78
  olen = (tmp___0 + 7) / 8;
#line 79
  tmp___1 = xmalloc((unsigned int )olen);
#line 79
  outbuf = (u_char *)tmp___1;
#line 81
  tmp___2 = BN_num_bits((BIGNUM const   *)in);
#line 81
  ilen = (tmp___2 + 7) / 8;
#line 82
  tmp___3 = xmalloc((unsigned int )ilen);
#line 82
  inbuf = (u_char *)tmp___3;
#line 83
  BN_bn2bin((BIGNUM const   *)in, inbuf);
#line 85
  len = RSA_public_encrypt(ilen, (unsigned char const   *)inbuf, outbuf, key, 1);
#line 85
  if (len <= 0) {
#line 87
    fatal("rsa_public_encrypt() failed");
  }
#line 89
  BN_bin2bn((unsigned char const   *)outbuf, len, out);
#line 91
  memset((void *)outbuf, 0, (unsigned int )olen);
#line 92
  memset((void *)inbuf, 0, (unsigned int )ilen);
#line 93
  xfree((void *)outbuf);
#line 94
  xfree((void *)inbuf);
#line 95
  return;
}
}
#line 97 "rsa.c"
int rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ u_char *inbuf ;
  u_char *outbuf ;
  int len ;
  int ilen ;
  int olen ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 103
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 103
  olen = (tmp + 7) / 8;
#line 104
  tmp___0 = xmalloc((unsigned int )olen);
#line 104
  outbuf = (u_char *)tmp___0;
#line 106
  tmp___1 = BN_num_bits((BIGNUM const   *)in);
#line 106
  ilen = (tmp___1 + 7) / 8;
#line 107
  tmp___2 = xmalloc((unsigned int )ilen);
#line 107
  inbuf = (u_char *)tmp___2;
#line 108
  BN_bn2bin((BIGNUM const   *)in, inbuf);
#line 110
  len = RSA_private_decrypt(ilen, (unsigned char const   *)inbuf, outbuf, key, 1);
#line 110
  if (len <= 0) {
#line 112
    error("rsa_private_decrypt() failed");
  } else {
#line 114
    BN_bin2bn((unsigned char const   *)outbuf, len, out);
  }
#line 116
  memset((void *)outbuf, 0, (unsigned int )olen);
#line 117
  memset((void *)inbuf, 0, (unsigned int )ilen);
#line 118
  xfree((void *)outbuf);
#line 119
  xfree((void *)inbuf);
#line 120
  return (len);
}
}
#line 123 "rsa.c"
void generate_additional_parameters(RSA *rsa ) 
{ BIGNUM *aux ;
  BN_CTX *ctx ;
  BIGNUM const   *tmp ;
  BIGNUM const   *tmp___0 ;

  {
#line 129
  aux = BN_new();
#line 130
  ctx = BN_CTX_new();
#line 132
  tmp = BN_value_one();
#line 132
  BN_sub(aux, (BIGNUM const   *)rsa->q, tmp);
#line 133
  BN_div((BIGNUM *)((void *)0), rsa->dmq1, (BIGNUM const   *)rsa->d, (BIGNUM const   *)aux,
         ctx);
#line 135
  tmp___0 = BN_value_one();
#line 135
  BN_sub(aux, (BIGNUM const   *)rsa->p, tmp___0);
#line 136
  BN_div((BIGNUM *)((void *)0), rsa->dmp1, (BIGNUM const   *)rsa->d, (BIGNUM const   *)aux,
         ctx);
#line 138
  BN_clear_free(aux);
#line 139
  BN_CTX_free(ctx);
#line 140
  return;
}
}
#line 1 "ssh-dss.o"
#pragma merger(0,"./ssh-dss.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 175 "/usr/include/openssl/dsa.h"
extern DSA_SIG *DSA_SIG_new(void) ;
#line 176
extern void DSA_SIG_free(DSA_SIG *a ) ;
#line 180
extern DSA_SIG *DSA_do_sign(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
#line 181
extern int DSA_do_verify(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                         DSA *dsa ) ;
#line 42 "ssh-dss.c"
int ssh_dss_sign(Key *key , u_char **sigp , int *lenp , u_char *data , int datalen ) 
{ u_char *digest___1 ;
  u_char *ret ;
  DSA_SIG *sig ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  u_int rlen ;
  u_int slen ;
  u_int len ;
  u_int dlen ;
  u_char sigblob[40] ;
  Buffer b ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;

  {
#line 51
  tmp = EVP_sha1();
#line 51
  evp_md = (EVP_MD *)tmp;
#line 59
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 60
    error("ssh_dss_sign: no DSA key");
#line 61
    return (-1);
  } else {
#line 59
    if (key->type != 2) {
#line 60
      error("ssh_dss_sign: no DSA key");
#line 61
      return (-1);
    } else {
#line 59
      if ((unsigned int )key->dsa == (unsigned int )((void *)0)) {
#line 60
        error("ssh_dss_sign: no DSA key");
#line 61
        return (-1);
      }
    }
  }
#line 63
  dlen = (unsigned int )evp_md->md_size;
#line 64
  tmp___0 = xmalloc(dlen);
#line 64
  digest___1 = (u_char *)tmp___0;
#line 65
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 66
  EVP_DigestUpdate(& md, (void const   *)data, (unsigned int )datalen);
#line 67
  EVP_DigestFinal(& md, digest___1, (unsigned int *)((void *)0));
#line 69
  sig = DSA_do_sign((unsigned char const   *)digest___1, (int )dlen, key->dsa);
#line 70
  if ((unsigned int )sig == (unsigned int )((void *)0)) {
#line 71
    fatal("ssh_dss_sign: cannot sign");
  }
#line 73
  memset((void *)digest___1, 0, dlen);
#line 74
  xfree((void *)digest___1);
#line 76
  tmp___1 = BN_num_bits((BIGNUM const   *)sig->r);
#line 76
  rlen = (unsigned int )((tmp___1 + 7) / 8);
#line 77
  tmp___2 = BN_num_bits((BIGNUM const   *)sig->s);
#line 77
  slen = (unsigned int )((tmp___2 + 7) / 8);
#line 78
  if (rlen > 20U) {
#line 79
    error("bad sig size %d %d", rlen, slen);
#line 80
    DSA_SIG_free(sig);
#line 81
    return (-1);
  } else {
#line 78
    if (slen > 20U) {
#line 79
      error("bad sig size %d %d", rlen, slen);
#line 80
      DSA_SIG_free(sig);
#line 81
      return (-1);
    }
  }
#line 83
  debug("sig size %d %d", rlen, slen);
#line 85
  memset((void *)(sigblob), 0, 40U);
#line 86
  BN_bn2bin((BIGNUM const   *)sig->r, ((sigblob + 40) - 20) - rlen);
#line 87
  BN_bn2bin((BIGNUM const   *)sig->s, (sigblob + 40) - slen);
#line 88
  DSA_SIG_free(sig);
#line 90
  if (datafellows & 1) {
#line 91
    debug("datafellows");
#line 92
    tmp___3 = xmalloc(40U);
#line 92
    ret = (u_char *)tmp___3;
#line 93
    memcpy((void * __restrict  )ret, (void const   * __restrict  )(sigblob), 40U);
#line 94
    if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 95
      *lenp = 40;
    }
#line 96
    if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 97
      *sigp = ret;
    }
  } else {
#line 100
    buffer_init(& b);
#line 101
    buffer_put_cstring(& b, "ssh-dss");
#line 102
    buffer_put_string(& b, (void const   *)(sigblob), 40U);
#line 103
    len = buffer_len(& b);
#line 104
    tmp___4 = xmalloc(len);
#line 104
    ret = (u_char *)tmp___4;
#line 105
    tmp___5 = buffer_ptr(& b);
#line 105
    memcpy((void * __restrict  )ret, (void const   * __restrict  )tmp___5, len);
#line 106
    buffer_free(& b);
#line 107
    if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 108
      *lenp = (int )len;
    }
#line 109
    if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 110
      *sigp = ret;
    }
  }
#line 112
  return (0);
}
}
#line 114 "ssh-dss.c"
int ssh_dss_verify(Key *key , u_char *signature , int signaturelen , u_char *data ,
                   int datalen ) 
{ Buffer b ;
  u_char *digest___1 ;
  DSA_SIG *sig ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  u_char *sigblob ;
  char *txt ;
  u_int len ;
  u_int dlen ;
  int rlen ;
  int ret ;
  char *ktype ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  u_int tmp___11 ;
  void *tmp___12 ;

  {
#line 123
  tmp = EVP_sha1();
#line 123
  evp_md = (EVP_MD *)tmp;
#line 131
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 132
    error("ssh_dss_verify: no DSA key");
#line 133
    return (-1);
  } else {
#line 131
    if (key->type != 2) {
#line 132
      error("ssh_dss_verify: no DSA key");
#line 133
      return (-1);
    } else {
#line 131
      if ((unsigned int )key->dsa == (unsigned int )((void *)0)) {
#line 132
        error("ssh_dss_verify: no DSA key");
#line 133
        return (-1);
      }
    }
  }
#line 136
  if (! (datafellows & 1)) {
#line 136
    if (signaturelen == 40) {
#line 138
      datafellows |= -2;
#line 139
      log("autodetect SSH_BUG_SIGBLOB");
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 140
    if (datafellows & 1) {
#line 140
      if (signaturelen != 40) {
#line 142
        log("autoremove SSH_BUG_SIGBLOB");
#line 143
        datafellows &= -2;
      }
    }
  }
#line 146
  debug("len %d datafellows %d", signaturelen, datafellows);
#line 149
  if (datafellows & 1) {
#line 150
    sigblob = signature;
#line 151
    len = (unsigned int )signaturelen;
  } else {
#line 155
    buffer_init(& b);
#line 156
    buffer_append(& b, (char const   *)((char *)signature), (unsigned int )signaturelen);
#line 157
    ktype = buffer_get_string(& b, (u_int *)((void *)0));
#line 158
    if (0) {
#line 158
      __s1_len = strlen("ssh-dss");
#line 158
      __s2_len = strlen((char const   *)ktype);
#line 158
      if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
        goto _L___1;
      } else {
#line 158
        if (__s1_len >= 4U) {
          _L___1: /* CIL Label */ 
#line 158
          if (! ((unsigned int )((void const   *)(ktype + 1)) - (unsigned int )((void const   *)ktype) == 1U)) {
#line 158
            tmp___9 = 1;
          } else {
#line 158
            if (__s2_len >= 4U) {
#line 158
              tmp___9 = 1;
            } else {
#line 158
              tmp___9 = 0;
            }
          }
        } else {
#line 158
          tmp___9 = 0;
        }
      }
#line 158
      if (tmp___9) {
#line 158
        tmp___5 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
      } else {
#line 158
        tmp___8 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
#line 158
        tmp___5 = tmp___8;
      }
    } else {
#line 158
      tmp___8 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
#line 158
      tmp___5 = tmp___8;
    }
#line 158
    if (tmp___5 != 0) {
#line 159
      error("ssh_dss_verify: cannot handle type %s", ktype);
#line 160
      buffer_free(& b);
#line 161
      return (-1);
    }
#line 163
    tmp___10 = buffer_get_string(& b, & len);
#line 163
    sigblob = (u_char *)tmp___10;
#line 164
    tmp___11 = buffer_len(& b);
#line 164
    rlen = (int )tmp___11;
#line 165
    if (rlen != 0) {
#line 166
      error("remaining bytes in signature %d", rlen);
#line 167
      buffer_free(& b);
#line 168
      return (-1);
    }
#line 170
    buffer_free(& b);
#line 171
    xfree((void *)ktype);
  }
#line 174
  if (len != 40U) {
#line 175
    fatal("bad sigbloblen %d != SIGBLOB_LEN", len);
  }
#line 179
  sig = DSA_SIG_new();
#line 180
  sig->r = BN_new();
#line 181
  sig->s = BN_new();
#line 182
  BN_bin2bn((unsigned char const   *)sigblob, 20, sig->r);
#line 183
  BN_bin2bn((unsigned char const   *)(sigblob + 20), 20, sig->s);
#line 185
  if (! (datafellows & 1)) {
#line 186
    memset((void *)sigblob, 0, len);
#line 187
    xfree((void *)sigblob);
  }
#line 191
  dlen = (unsigned int )evp_md->md_size;
#line 192
  tmp___12 = xmalloc(dlen);
#line 192
  digest___1 = (u_char *)tmp___12;
#line 193
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 194
  EVP_DigestUpdate(& md, (void const   *)data, (unsigned int )datalen);
#line 195
  EVP_DigestFinal(& md, digest___1, (unsigned int *)((void *)0));
#line 197
  ret = DSA_do_verify((unsigned char const   *)digest___1, (int )dlen, sig, key->dsa);
#line 199
  memset((void *)digest___1, 0, dlen);
#line 200
  xfree((void *)digest___1);
#line 201
  DSA_SIG_free(sig);
#line 203
  switch (ret) {
  case 1: 
#line 205
  txt = (char *)"correct";
#line 206
  break;
  case 0: 
#line 208
  txt = (char *)"incorrect";
#line 209
  break;
  case -1: 
  default: 
#line 212
  txt = (char *)"error";
#line 213
  break;
  }
#line 215
  debug("ssh_dss_verify: signature %s", txt);
#line 216
  return (ret);
}
}
#line 1 "ssh-rsa.o"
#pragma merger(0,"./ssh-rsa.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1006 "/usr/include/openssl/objects.h"
extern char const   *OBJ_nid2sn(int n ) ;
#line 732 "/usr/include/openssl/evp.h"
extern EVP_MD const   *EVP_get_digestbyname(char const   *name ) ;
#line 271 "/usr/include/openssl/err.h"
extern char *ERR_error_string(unsigned long e , char *buf ) ;
#line 217 "/usr/include/openssl/rsa.h"
extern int RSA_size(RSA const   * ) ;
#line 284
extern int RSA_sign(int type , unsigned char const   *m , unsigned int m_length ,
                    unsigned char *sigret , unsigned int *siglen , RSA *rsa ) ;
#line 286
extern int RSA_verify(int type , unsigned char const   *m , unsigned int m_length ,
                      unsigned char *sigbuf , unsigned int siglen , RSA *rsa ) ;
#line 40 "ssh-rsa.c"
int ssh_rsa_sign(Key *key , u_char **sigp , int *lenp , u_char *data , int datalen ) 
{ EVP_MD const   *evp_md ;
  EVP_MD_CTX md ;
  u_char *digest___1 ;
  u_char *sig ;
  u_char *ret ;
  u_int slen ;
  u_int dlen ;
  u_int len ;
  int ok ;
  int nid ;
  Buffer b ;
  char const   *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int ecode ;
  unsigned long tmp___3 ;
  char *tmp___4 ;
  int diff ;
  void *tmp___5 ;
  char *tmp___6 ;

  {
#line 53
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 54
    error("ssh_rsa_sign: no RSA key");
#line 55
    return (-1);
  } else {
#line 53
    if (key->type != 1) {
#line 54
      error("ssh_rsa_sign: no RSA key");
#line 55
      return (-1);
    } else {
#line 53
      if ((unsigned int )key->rsa == (unsigned int )((void *)0)) {
#line 54
        error("ssh_rsa_sign: no RSA key");
#line 55
        return (-1);
      }
    }
  }
#line 57
  if (datafellows & 8192) {
#line 57
    nid = 4;
  } else {
#line 57
    nid = 64;
  }
#line 58
  tmp = OBJ_nid2sn(nid);
#line 58
  evp_md = EVP_get_digestbyname(tmp);
#line 58
  if ((unsigned int )evp_md == (unsigned int )((void *)0)) {
#line 59
    error("ssh_rsa_sign: EVP_get_digestbynid %d failed", nid);
#line 60
    return (-1);
  }
#line 62
  dlen = (unsigned int )evp_md->md_size;
#line 63
  tmp___0 = xmalloc(dlen);
#line 63
  digest___1 = (u_char *)tmp___0;
#line 64
  EVP_DigestInit(& md, evp_md);
#line 65
  EVP_DigestUpdate(& md, (void const   *)data, (unsigned int )datalen);
#line 66
  EVP_DigestFinal(& md, digest___1, (unsigned int *)((void *)0));
#line 68
  tmp___1 = RSA_size((RSA const   *)key->rsa);
#line 68
  slen = (unsigned int )tmp___1;
#line 69
  tmp___2 = xmalloc(slen);
#line 69
  sig = (u_char *)tmp___2;
#line 71
  ok = RSA_sign(nid, (unsigned char const   *)digest___1, dlen, sig, & len, key->rsa);
#line 72
  memset((void *)digest___1, 'd', dlen);
#line 73
  xfree((void *)digest___1);
#line 75
  if (ok != 1) {
#line 76
    tmp___3 = ERR_get_error();
#line 76
    ecode = (int )tmp___3;
#line 77
    tmp___4 = ERR_error_string((unsigned long )ecode, (char *)((void *)0));
#line 77
    error("ssh_rsa_sign: RSA_sign failed: %s", tmp___4);
#line 78
    xfree((void *)sig);
#line 79
    return (-1);
  }
#line 81
  if (len < slen) {
#line 82
    diff = (int )(slen - len);
#line 83
    debug("slen %d > len %d", slen, len);
#line 84
    memmove((void *)(sig + diff), (void const   *)sig, len);
#line 85
    memset((void *)sig, 0, (unsigned int )diff);
  } else {
#line 86
    if (len > slen) {
#line 87
      error("ssh_rsa_sign: slen %d slen2 %d", slen, len);
#line 88
      xfree((void *)sig);
#line 89
      return (-1);
    }
  }
#line 92
  buffer_init(& b);
#line 93
  buffer_put_cstring(& b, "ssh-rsa");
#line 94
  buffer_put_string(& b, (void const   *)sig, slen);
#line 95
  len = buffer_len(& b);
#line 96
  tmp___5 = xmalloc(len);
#line 96
  ret = (u_char *)tmp___5;
#line 97
  tmp___6 = buffer_ptr(& b);
#line 97
  memcpy((void * __restrict  )ret, (void const   * __restrict  )tmp___6, len);
#line 98
  buffer_free(& b);
#line 99
  memset((void *)sig, 's', slen);
#line 100
  xfree((void *)sig);
#line 102
  if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 103
    *lenp = (int )len;
  }
#line 104
  if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 105
    *sigp = ret;
  }
#line 106
  debug2("ssh_rsa_sign: done");
#line 107
  return (0);
}
}
#line 110 "ssh-rsa.c"
int ssh_rsa_verify(Key *key , u_char *signature , int signaturelen , u_char *data ,
                   int datalen ) 
{ Buffer b ;
  EVP_MD const   *evp_md ;
  EVP_MD_CTX md ;
  char *ktype ;
  u_char *sigblob ;
  u_char *digest___1 ;
  u_int len ;
  u_int dlen ;
  int rlen ;
  int ret ;
  int nid ;
  int tmp ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  u_int tmp___12 ;
  char const   *tmp___13 ;
  void *tmp___14 ;
  int ecode ;
  unsigned long tmp___15 ;
  char *tmp___16 ;
  char const   *tmp___17 ;

  {
#line 124
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 125
    error("ssh_rsa_verify: no RSA key");
#line 126
    return (-1);
  } else {
#line 124
    if (key->type != 1) {
#line 125
      error("ssh_rsa_verify: no RSA key");
#line 126
      return (-1);
    } else {
#line 124
      if ((unsigned int )key->rsa == (unsigned int )((void *)0)) {
#line 125
        error("ssh_rsa_verify: no RSA key");
#line 126
        return (-1);
      }
    }
  }
#line 128
  tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 128
  if (tmp___0 < 768) {
#line 129
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 129
    error("ssh_rsa_verify: n too small: %d bits", tmp);
#line 131
    return (-1);
  }
#line 133
  buffer_init(& b);
#line 134
  buffer_append(& b, (char const   *)((char *)signature), (unsigned int )signaturelen);
#line 135
  ktype = buffer_get_string(& b, (u_int *)((void *)0));
#line 136
  if (0) {
#line 136
    __s1_len = strlen("ssh-rsa");
#line 136
    __s2_len = strlen((char const   *)ktype);
#line 136
    if (! ((unsigned int )((void const   *)("ssh-rsa" + 1)) - (unsigned int )((void const   *)"ssh-rsa") == 1U)) {
      goto _L___0;
    } else {
#line 136
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 136
        if (! ((unsigned int )((void const   *)(ktype + 1)) - (unsigned int )((void const   *)ktype) == 1U)) {
#line 136
          tmp___10 = 1;
        } else {
#line 136
          if (__s2_len >= 4U) {
#line 136
            tmp___10 = 1;
          } else {
#line 136
            tmp___10 = 0;
          }
        }
      } else {
#line 136
        tmp___10 = 0;
      }
    }
#line 136
    if (tmp___10) {
#line 136
      tmp___6 = __builtin_strcmp("ssh-rsa", (char const   *)ktype);
    } else {
#line 136
      tmp___9 = __builtin_strcmp("ssh-rsa", (char const   *)ktype);
#line 136
      tmp___6 = tmp___9;
    }
  } else {
#line 136
    tmp___9 = __builtin_strcmp("ssh-rsa", (char const   *)ktype);
#line 136
    tmp___6 = tmp___9;
  }
#line 136
  if (tmp___6 != 0) {
#line 137
    error("ssh_rsa_verify: cannot handle type %s", ktype);
#line 138
    buffer_free(& b);
#line 139
    xfree((void *)ktype);
#line 140
    return (-1);
  }
#line 142
  xfree((void *)ktype);
#line 143
  tmp___11 = buffer_get_string(& b, & len);
#line 143
  sigblob = (u_char *)tmp___11;
#line 144
  tmp___12 = buffer_len(& b);
#line 144
  rlen = (int )tmp___12;
#line 145
  buffer_free(& b);
#line 146
  if (rlen != 0) {
#line 147
    xfree((void *)sigblob);
#line 148
    error("ssh_rsa_verify: remaining bytes in signature %d", rlen);
#line 149
    return (-1);
  }
#line 151
  if (datafellows & 8192) {
#line 151
    nid = 4;
  } else {
#line 151
    nid = 64;
  }
#line 152
  tmp___13 = OBJ_nid2sn(nid);
#line 152
  evp_md = EVP_get_digestbyname(tmp___13);
#line 152
  if ((unsigned int )evp_md == (unsigned int )((void *)0)) {
#line 153
    xfree((void *)sigblob);
#line 154
    error("ssh_rsa_verify: EVP_get_digestbynid %d failed", nid);
#line 155
    return (-1);
  }
#line 157
  dlen = (unsigned int )evp_md->md_size;
#line 158
  tmp___14 = xmalloc(dlen);
#line 158
  digest___1 = (u_char *)tmp___14;
#line 159
  EVP_DigestInit(& md, evp_md);
#line 160
  EVP_DigestUpdate(& md, (void const   *)data, (unsigned int )datalen);
#line 161
  EVP_DigestFinal(& md, digest___1, (unsigned int *)((void *)0));
#line 163
  ret = RSA_verify(nid, (unsigned char const   *)digest___1, dlen, sigblob, len, key->rsa);
#line 164
  memset((void *)digest___1, 'd', dlen);
#line 165
  xfree((void *)digest___1);
#line 166
  memset((void *)sigblob, 's', len);
#line 167
  xfree((void *)sigblob);
#line 168
  if (ret == 0) {
#line 169
    tmp___15 = ERR_get_error();
#line 169
    ecode = (int )tmp___15;
#line 170
    tmp___16 = ERR_error_string((unsigned long )ecode, (char *)((void *)0));
#line 170
    error("ssh_rsa_verify: RSA_verify failed: %s", tmp___16);
  }
#line 172
  if (ret == 0) {
#line 172
    tmp___17 = "in";
  } else {
#line 172
    tmp___17 = "";
  }
#line 172
  debug("ssh_rsa_verify: signature %scorrect", tmp___17);
#line 173
  return (ret);
}
}
#line 1 "tildexpand.o"
#pragma merger(0,"./tildexpand.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 19 "tildexpand.h"
char *tilde_expand_filename(char const   *filename , uid_t my_uid ) ;
#line 24 "tildexpand.c"
char *tilde_expand_filename(char const   *filename , uid_t my_uid ) 
{ char const   *cp ;
  u_int userlen ;
  char *expanded ;
  struct passwd *pw ;
  char user[100] ;
  int len ;
  char *tmp ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;

  {
#line 35
  if ((int const   )*(filename + 0) != 126) {
#line 36
    tmp = xstrdup(filename);
#line 36
    return (tmp);
  }
#line 39
  filename ++;
#line 42
  tmp___1 = __builtin_strchr((char *)filename, '/');
#line 42
  cp = (char const   *)tmp___1;
#line 43
  if (cp) {
#line 44
    userlen = (unsigned int )(cp - filename);
  } else {
#line 46
    userlen = strlen(filename);
  }
#line 47
  if (userlen == 0U) {
#line 48
    pw = getpwuid(my_uid);
  } else {
#line 51
    if (userlen > sizeof(user) - 1U) {
#line 52
      fatal("User name after tilde too long.");
    }
#line 53
    memcpy((void * __restrict  )(user), (void const   * __restrict  )filename, userlen);
#line 54
    user[userlen] = (char)0;
#line 55
    pw = getpwnam((char const   *)(user));
  }
#line 57
  if (! pw) {
#line 58
    fatal("Unknown user %100s.", user);
  }
#line 61
  if (! cp) {
#line 63
    tmp___2 = xstrdup((char const   *)pw->pw_dir);
#line 63
    return (tmp___2);
  }
#line 66
  tmp___3 = strlen((char const   *)pw->pw_dir);
#line 66
  tmp___4 = strlen(cp + 1);
#line 66
  len = (int )((tmp___3 + tmp___4) + 2U);
#line 67
  if (len > 4096) {
#line 68
    fatal("Home directory too long (%d > %d", len - 1, 4095);
  }
#line 69
  tmp___5 = xmalloc((unsigned int )len);
#line 69
  expanded = (char *)tmp___5;
#line 70
  snprintf((char * __restrict  )expanded, (unsigned int )len, (char const   * __restrict  )"%s/%s",
           pw->pw_dir, cp + 1);
#line 71
  return (expanded);
}
}
#line 1 "ttymodes.o"
#pragma merger(0,"./ttymodes.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 49 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) speed_t cfgetospeed(struct termios  const  *__termios_p ) ;
#line 52
extern  __attribute__((__nothrow__)) speed_t cfgetispeed(struct termios  const  *__termios_p ) ;
#line 55
extern  __attribute__((__nothrow__)) int cfsetospeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 58
extern  __attribute__((__nothrow__)) int cfsetispeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 182 "packet.h"
void tty_make_modes(int fd , struct termios *tiop ) ;
#line 185
void tty_parse_modes(int fd , int *n_bytes_ptr ) ;
#line 68 "ttymodes.c"
static int speed_to_baud(speed_t speed ) 
{ 

  {
#line 71
  switch ((int )speed) {
  case 0: 
#line 73
  return (0);
  case 1: 
#line 75
  return (50);
  case 2: 
#line 77
  return (75);
  case 3: 
#line 79
  return (110);
  case 4: 
#line 81
  return (134);
  case 5: 
#line 83
  return (150);
  case 6: 
#line 85
  return (200);
  case 7: 
#line 87
  return (300);
  case 8: 
#line 89
  return (600);
  case 9: 
#line 91
  return (1200);
  case 10: 
#line 93
  return (1800);
  case 11: 
#line 95
  return (2400);
  case 12: 
#line 97
  return (4800);
  case 13: 
#line 99
  return (9600);
  case 14: 
#line 103
  return (19200);
  case 15: 
#line 113
  return (38400);
  case 4097: 
#line 135
  return (57600);
  case 4098: 
#line 143
  return (115200);
  case 4099: 
#line 147
  return (230400);
  default: ;
#line 150
  return (9600);
  }
}
}
#line 157 "ttymodes.c"
static speed_t baud_to_speed(int baud ) 
{ 

  {
#line 160
  switch (baud) {
  case 0: 
#line 162
  return (0U);
  case 50: 
#line 164
  return (1U);
  case 75: 
#line 166
  return (2U);
  case 110: 
#line 168
  return (3U);
  case 134: 
#line 170
  return (4U);
  case 150: 
#line 172
  return (5U);
  case 200: 
#line 174
  return (6U);
  case 300: 
#line 176
  return (7U);
  case 600: 
#line 178
  return (8U);
  case 1200: 
#line 180
  return (9U);
  case 1800: 
#line 182
  return (10U);
  case 2400: 
#line 184
  return (11U);
  case 4800: 
#line 186
  return (12U);
  case 9600: 
#line 188
  return (13U);
  case 19200: 
#line 192
  return (14U);
  case 38400: 
#line 202
  return (15U);
  case 57600: 
#line 224
  return (4097U);
  case 115200: 
#line 232
  return (4098U);
  case 230400: 
#line 236
  return (4099U);
  default: ;
#line 239
  return (13U);
  }
}
}
#line 248 "ttymodes.c"
void tty_make_modes(int fd , struct termios *tiop ) 
{ struct termios tio ;
  int baud ;
  Buffer buf___2 ;
  int tty_op_ospeed ;
  int tty_op_ispeed ;
  void (*put_arg)(Buffer * , u_int  ) ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  speed_t tmp___2 ;
  speed_t tmp___3 ;
  u_int tmp___4 ;
  char *tmp___5 ;
  u_int tmp___6 ;
  char *tmp___7 ;

  {
#line 257
  buffer_init(& buf___2);
#line 258
  if (compat20) {
#line 259
    tty_op_ospeed = 129;
#line 260
    tty_op_ispeed = 128;
#line 261
    put_arg = & buffer_put_int;
  } else {
#line 263
    tty_op_ospeed = 193;
#line 264
    tty_op_ispeed = 192;
#line 265
    put_arg = (void (*)(Buffer * , u_int  ))(& buffer_put_char);
  }
#line 268
  if ((unsigned int )tiop == (unsigned int )((void *)0)) {
#line 269
    tmp___1 = tcgetattr(fd, & tio);
#line 269
    if (tmp___1 == -1) {
#line 270
      tmp = __errno_location();
#line 270
      tmp___0 = strerror(*tmp);
#line 270
      log("tcgetattr: %.100s", tmp___0);
      goto end;
    }
  } else {
#line 274
    tio = *tiop;
  }
#line 277
  tmp___2 = cfgetospeed((struct termios  const  *)(& tio));
#line 277
  baud = speed_to_baud(tmp___2);
#line 278
  debug2("tty_make_modes: ospeed %d", baud);
#line 279
  buffer_put_char(& buf___2, tty_op_ospeed);
#line 280
  buffer_put_int(& buf___2, (unsigned int )baud);
#line 281
  tmp___3 = cfgetispeed((struct termios  const  *)(& tio));
#line 281
  baud = speed_to_baud(tmp___3);
#line 282
  debug2("tty_make_modes: ispeed %d", baud);
#line 283
  buffer_put_char(& buf___2, tty_op_ispeed);
#line 284
  buffer_put_int(& buf___2, (unsigned int )baud);
#line 69 "ttymodes.h"
  debug2("tty_make_modes: %d %d", 1, tio.c_cc[0]);
#line 69
  buffer_put_char(& buf___2, 1);
#line 69
  (*put_arg)(& buf___2, (unsigned int )tio.c_cc[0]);
#line 70
  debug2("tty_make_modes: %d %d", 2, tio.c_cc[1]);
#line 70
  buffer_put_char(& buf___2, 2);
#line 70
  (*put_arg)(& buf___2, (unsigned int )tio.c_cc[1]);
#line 71
  debug2("tty_make_modes: %d %d", 3, tio.c_cc[2]);
#line 71
  buffer_put_char(& buf___2, 3);
#line 71
  (*put_arg)(& buf___2, (unsigned int )tio.c_cc[2]);
#line 73
  debug2("tty_make_modes: %d %d", 4, tio.c_cc[3]);
#line 73
  buffer_put_char(& buf___2, 4);
#line 73
  (*put_arg)(& buf___2, (unsigned int )tio.c_cc[3]);
#line 75
  debug2("tty_make_modes: %d %d", 5, tio.c_cc[4]);
#line 75
  buffer_put_char(& buf___2, 5);
#line 75
  (*put_arg)(& buf___2, (unsigned int )tio.c_cc[4]);
#line 77
  debug2("tty_make_modes: %d %d", 6, tio.c_cc[11]);
#line 77
  buffer_put_char(& buf___2, 6);
#line 77
  (*put_arg)(& buf___2, (unsigned int )tio.c_cc[11]);
#line 80
  debug2("tty_make_modes: %d %d", 7, tio.c_cc[16]);
#line 80
  buffer_put_char(& buf___2, 7);
#line 80
  (*put_arg)(& buf___2, (unsigned int )tio.c_cc[16]);
#line 82
  debug2("tty_make_modes: %d %d", 8, tio.c_cc[8]);
#line 82
  buffer_put_char(& buf___2, 8);
#line 82
  (*put_arg)(& buf___2, (unsigned int )tio.c_cc[8]);
#line 83
  debug2("tty_make_modes: %d %d", 9, tio.c_cc[9]);
#line 83
  buffer_put_char(& buf___2, 9);
#line 83
  (*put_arg)(& buf___2, (unsigned int )tio.c_cc[9]);
#line 85
  debug2("tty_make_modes: %d %d", 10, tio.c_cc[10]);
#line 85
  buffer_put_char(& buf___2, 10);
#line 85
  (*put_arg)(& buf___2, (unsigned int )tio.c_cc[10]);
#line 91
  debug2("tty_make_modes: %d %d", 12, tio.c_cc[12]);
#line 91
  buffer_put_char(& buf___2, 12);
#line 91
  (*put_arg)(& buf___2, (unsigned int )tio.c_cc[12]);
#line 94
  debug2("tty_make_modes: %d %d", 13, tio.c_cc[14]);
#line 94
  buffer_put_char(& buf___2, 13);
#line 94
  (*put_arg)(& buf___2, (unsigned int )tio.c_cc[14]);
#line 97
  debug2("tty_make_modes: %d %d", 14, tio.c_cc[15]);
#line 97
  buffer_put_char(& buf___2, 14);
#line 97
  (*put_arg)(& buf___2, (unsigned int )tio.c_cc[15]);
#line 109
  debug2("tty_make_modes: %d %d", 18, tio.c_cc[13]);
#line 109
  buffer_put_char(& buf___2, 18);
#line 109
  (*put_arg)(& buf___2, (unsigned int )tio.c_cc[13]);
#line 113
  debug2("tty_make_modes: %d %d", 30, (tio.c_iflag & 4U) != 0U);
#line 113
  buffer_put_char(& buf___2, 30);
#line 113
  (*put_arg)(& buf___2, (unsigned int )((tio.c_iflag & 4U) != 0U));
#line 114
  debug2("tty_make_modes: %d %d", 31, (tio.c_iflag & 8U) != 0U);
#line 114
  buffer_put_char(& buf___2, 31);
#line 114
  (*put_arg)(& buf___2, (unsigned int )((tio.c_iflag & 8U) != 0U));
#line 115
  debug2("tty_make_modes: %d %d", 32, (tio.c_iflag & 16U) != 0U);
#line 115
  buffer_put_char(& buf___2, 32);
#line 115
  (*put_arg)(& buf___2, (unsigned int )((tio.c_iflag & 16U) != 0U));
#line 116
  debug2("tty_make_modes: %d %d", 33, (tio.c_iflag & 32U) != 0U);
#line 116
  buffer_put_char(& buf___2, 33);
#line 116
  (*put_arg)(& buf___2, (unsigned int )((tio.c_iflag & 32U) != 0U));
#line 117
  debug2("tty_make_modes: %d %d", 34, (tio.c_iflag & 64U) != 0U);
#line 117
  buffer_put_char(& buf___2, 34);
#line 117
  (*put_arg)(& buf___2, (unsigned int )((tio.c_iflag & 64U) != 0U));
#line 118
  debug2("tty_make_modes: %d %d", 35, (tio.c_iflag & 128U) != 0U);
#line 118
  buffer_put_char(& buf___2, 35);
#line 118
  (*put_arg)(& buf___2, (unsigned int )((tio.c_iflag & 128U) != 0U));
#line 119
  debug2("tty_make_modes: %d %d", 36, (tio.c_iflag & 256U) != 0U);
#line 119
  buffer_put_char(& buf___2, 36);
#line 119
  (*put_arg)(& buf___2, (unsigned int )((tio.c_iflag & 256U) != 0U));
#line 121
  debug2("tty_make_modes: %d %d", 37, (tio.c_iflag & 512U) != 0U);
#line 121
  buffer_put_char(& buf___2, 37);
#line 121
  (*put_arg)(& buf___2, (unsigned int )((tio.c_iflag & 512U) != 0U));
#line 123
  debug2("tty_make_modes: %d %d", 38, (tio.c_iflag & 1024U) != 0U);
#line 123
  buffer_put_char(& buf___2, 38);
#line 123
  (*put_arg)(& buf___2, (unsigned int )((tio.c_iflag & 1024U) != 0U));
#line 124
  debug2("tty_make_modes: %d %d", 39, (tio.c_iflag & 2048U) != 0U);
#line 124
  buffer_put_char(& buf___2, 39);
#line 124
  (*put_arg)(& buf___2, (unsigned int )((tio.c_iflag & 2048U) != 0U));
#line 125
  debug2("tty_make_modes: %d %d", 40, (tio.c_iflag & 4096U) != 0U);
#line 125
  buffer_put_char(& buf___2, 40);
#line 125
  (*put_arg)(& buf___2, (unsigned int )((tio.c_iflag & 4096U) != 0U));
#line 127
  debug2("tty_make_modes: %d %d", 41, (tio.c_iflag & 8192U) != 0U);
#line 127
  buffer_put_char(& buf___2, 41);
#line 127
  (*put_arg)(& buf___2, (unsigned int )((tio.c_iflag & 8192U) != 0U));
#line 130
  debug2("tty_make_modes: %d %d", 50, (tio.c_lflag & 1U) != 0U);
#line 130
  buffer_put_char(& buf___2, 50);
#line 130
  (*put_arg)(& buf___2, (unsigned int )((tio.c_lflag & 1U) != 0U));
#line 131
  debug2("tty_make_modes: %d %d", 51, (tio.c_lflag & 2U) != 0U);
#line 131
  buffer_put_char(& buf___2, 51);
#line 131
  (*put_arg)(& buf___2, (unsigned int )((tio.c_lflag & 2U) != 0U));
#line 133
  debug2("tty_make_modes: %d %d", 52, (tio.c_lflag & 4U) != 0U);
#line 133
  buffer_put_char(& buf___2, 52);
#line 133
  (*put_arg)(& buf___2, (unsigned int )((tio.c_lflag & 4U) != 0U));
#line 135
  debug2("tty_make_modes: %d %d", 53, (tio.c_lflag & 8U) != 0U);
#line 135
  buffer_put_char(& buf___2, 53);
#line 135
  (*put_arg)(& buf___2, (unsigned int )((tio.c_lflag & 8U) != 0U));
#line 136
  debug2("tty_make_modes: %d %d", 54, (tio.c_lflag & 16U) != 0U);
#line 136
  buffer_put_char(& buf___2, 54);
#line 136
  (*put_arg)(& buf___2, (unsigned int )((tio.c_lflag & 16U) != 0U));
#line 137
  debug2("tty_make_modes: %d %d", 55, (tio.c_lflag & 32U) != 0U);
#line 137
  buffer_put_char(& buf___2, 55);
#line 137
  (*put_arg)(& buf___2, (unsigned int )((tio.c_lflag & 32U) != 0U));
#line 138
  debug2("tty_make_modes: %d %d", 56, (tio.c_lflag & 64U) != 0U);
#line 138
  buffer_put_char(& buf___2, 56);
#line 138
  (*put_arg)(& buf___2, (unsigned int )((tio.c_lflag & 64U) != 0U));
#line 139
  debug2("tty_make_modes: %d %d", 57, (tio.c_lflag & 128U) != 0U);
#line 139
  buffer_put_char(& buf___2, 57);
#line 139
  (*put_arg)(& buf___2, (unsigned int )((tio.c_lflag & 128U) != 0U));
#line 140
  debug2("tty_make_modes: %d %d", 58, (tio.c_lflag & 256U) != 0U);
#line 140
  buffer_put_char(& buf___2, 58);
#line 140
  (*put_arg)(& buf___2, (unsigned int )((tio.c_lflag & 256U) != 0U));
#line 142
  debug2("tty_make_modes: %d %d", 59, (tio.c_lflag & 32768U) != 0U);
#line 142
  buffer_put_char(& buf___2, 59);
#line 142
  (*put_arg)(& buf___2, (unsigned int )((tio.c_lflag & 32768U) != 0U));
#line 145
  debug2("tty_make_modes: %d %d", 60, (tio.c_lflag & 512U) != 0U);
#line 145
  buffer_put_char(& buf___2, 60);
#line 145
  (*put_arg)(& buf___2, (unsigned int )((tio.c_lflag & 512U) != 0U));
#line 148
  debug2("tty_make_modes: %d %d", 61, (tio.c_lflag & 2048U) != 0U);
#line 148
  buffer_put_char(& buf___2, 61);
#line 148
  (*put_arg)(& buf___2, (unsigned int )((tio.c_lflag & 2048U) != 0U));
#line 151
  debug2("tty_make_modes: %d %d", 62, (tio.c_lflag & 16384U) != 0U);
#line 151
  buffer_put_char(& buf___2, 62);
#line 151
  (*put_arg)(& buf___2, (unsigned int )((tio.c_lflag & 16384U) != 0U));
#line 154
  debug2("tty_make_modes: %d %d", 70, (tio.c_oflag & 1U) != 0U);
#line 154
  buffer_put_char(& buf___2, 70);
#line 154
  (*put_arg)(& buf___2, (unsigned int )((tio.c_oflag & 1U) != 0U));
#line 156
  debug2("tty_make_modes: %d %d", 71, (tio.c_oflag & 2U) != 0U);
#line 156
  buffer_put_char(& buf___2, 71);
#line 156
  (*put_arg)(& buf___2, (unsigned int )((tio.c_oflag & 2U) != 0U));
#line 158
  debug2("tty_make_modes: %d %d", 72, (tio.c_oflag & 4U) != 0U);
#line 158
  buffer_put_char(& buf___2, 72);
#line 158
  (*put_arg)(& buf___2, (unsigned int )((tio.c_oflag & 4U) != 0U));
#line 160
  debug2("tty_make_modes: %d %d", 73, (tio.c_oflag & 8U) != 0U);
#line 160
  buffer_put_char(& buf___2, 73);
#line 160
  (*put_arg)(& buf___2, (unsigned int )((tio.c_oflag & 8U) != 0U));
#line 163
  debug2("tty_make_modes: %d %d", 74, (tio.c_oflag & 16U) != 0U);
#line 163
  buffer_put_char(& buf___2, 74);
#line 163
  (*put_arg)(& buf___2, (unsigned int )((tio.c_oflag & 16U) != 0U));
#line 166
  debug2("tty_make_modes: %d %d", 75, (tio.c_oflag & 32U) != 0U);
#line 166
  buffer_put_char(& buf___2, 75);
#line 166
  (*put_arg)(& buf___2, (unsigned int )((tio.c_oflag & 32U) != 0U));
#line 169
  debug2("tty_make_modes: %d %d", 90, (tio.c_cflag & 32U) != 0U);
#line 169
  buffer_put_char(& buf___2, 90);
#line 169
  (*put_arg)(& buf___2, (unsigned int )((tio.c_cflag & 32U) != 0U));
#line 170
  debug2("tty_make_modes: %d %d", 91, (tio.c_cflag & 48U) != 0U);
#line 170
  buffer_put_char(& buf___2, 91);
#line 170
  (*put_arg)(& buf___2, (unsigned int )((tio.c_cflag & 48U) != 0U));
#line 171
  debug2("tty_make_modes: %d %d", 92, (tio.c_cflag & 256U) != 0U);
#line 171
  buffer_put_char(& buf___2, 92);
#line 171
  (*put_arg)(& buf___2, (unsigned int )((tio.c_cflag & 256U) != 0U));
#line 172
  debug2("tty_make_modes: %d %d", 93, (tio.c_cflag & 512U) != 0U);
#line 172
  buffer_put_char(& buf___2, 93);
#line 172
  (*put_arg)(& buf___2, (unsigned int )((tio.c_cflag & 512U) != 0U));
  end: 
#line 304 "ttymodes.c"
  buffer_put_char(& buf___2, 0);
#line 305
  if (compat20) {
#line 306
    tmp___4 = buffer_len(& buf___2);
#line 306
    tmp___5 = buffer_ptr(& buf___2);
#line 306
    packet_put_string((char const   *)tmp___5, tmp___4);
  } else {
#line 308
    tmp___6 = buffer_len(& buf___2);
#line 308
    tmp___7 = buffer_ptr(& buf___2);
#line 308
    packet_put_raw((char const   *)tmp___7, tmp___6);
  }
#line 309
  buffer_free(& buf___2);
#line 310
  return;
}
}
#line 317 "ttymodes.c"
void tty_parse_modes(int fd , int *n_bytes_ptr ) 
{ struct termios tio ;
  int opcode ;
  int baud ;
  int n_bytes ;
  int failure ;
  u_int (*get_arg)(void) ;
  int arg ;
  int arg_size ;
  u_int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  u_int tmp___3 ;
  u_int tmp___4 ;
  speed_t tmp___5 ;
  int tmp___6 ;
  u_int tmp___7 ;
  speed_t tmp___8 ;
  int tmp___9 ;
  u_int tmp___10 ;
  u_int tmp___11 ;
  u_int tmp___12 ;
  u_int tmp___13 ;
  u_int tmp___14 ;
  u_int tmp___15 ;
  u_int tmp___16 ;
  u_int tmp___17 ;
  u_int tmp___18 ;
  u_int tmp___19 ;
  u_int tmp___20 ;
  u_int tmp___21 ;
  u_int tmp___22 ;
  u_int tmp___23 ;
  u_int tmp___24 ;
  u_int tmp___25 ;
  u_int tmp___26 ;
  u_int tmp___27 ;
  u_int tmp___28 ;
  u_int tmp___29 ;
  u_int tmp___30 ;
  u_int tmp___31 ;
  u_int tmp___32 ;
  u_int tmp___33 ;
  u_int tmp___34 ;
  u_int tmp___35 ;
  u_int tmp___36 ;
  u_int tmp___37 ;
  u_int tmp___38 ;
  u_int tmp___39 ;
  u_int tmp___40 ;
  u_int tmp___41 ;
  u_int tmp___42 ;
  u_int tmp___43 ;
  u_int tmp___44 ;
  u_int tmp___45 ;
  u_int tmp___46 ;
  u_int tmp___47 ;
  u_int tmp___48 ;
  u_int tmp___49 ;
  u_int tmp___50 ;
  u_int tmp___51 ;
  u_int tmp___52 ;
  u_int tmp___53 ;
  u_int tmp___54 ;
  u_int tmp___55 ;
  u_int tmp___56 ;
  u_int tmp___57 ;
  u_int tmp___58 ;
  int _p ;
  int _e ;
  int *tmp___59 ;
  char *tmp___60 ;
  int tmp___61 ;

  {
#line 322
  n_bytes = 0;
#line 323
  failure = 0;
#line 327
  if (compat20) {
#line 328
    tmp = packet_get_int();
#line 328
    *n_bytes_ptr = (int )tmp;
#line 329
    debug2("tty_parse_modes: SSH2 n_bytes %d", *n_bytes_ptr);
#line 330
    if (*n_bytes_ptr == 0) {
#line 331
      return;
    }
#line 332
    get_arg = & packet_get_int;
#line 333
    arg_size = 4;
  } else {
#line 335
    get_arg = & packet_get_char;
#line 336
    arg_size = 1;
  }
#line 344
  tmp___2 = tcgetattr(fd, & tio);
#line 344
  if (tmp___2 == -1) {
#line 345
    tmp___0 = __errno_location();
#line 345
    tmp___1 = strerror(*tmp___0);
#line 345
    log("tcgetattr: %.100s", tmp___1);
#line 346
    failure = -1;
  }
#line 349
  while (1) {
#line 350
    n_bytes ++;
#line 351
    tmp___3 = packet_get_char();
#line 351
    opcode = (int )tmp___3;
#line 352
    switch (opcode) {
    case 0: 
    goto set;
    case 192: 
    case 128: 
#line 359
    n_bytes += 4;
#line 360
    tmp___4 = packet_get_int();
#line 360
    baud = (int )tmp___4;
#line 361
    debug2("tty_parse_modes: ispeed %d", baud);
#line 362
    if (failure != -1) {
#line 362
      tmp___5 = baud_to_speed(baud);
#line 362
      tmp___6 = cfsetispeed(& tio, tmp___5);
#line 362
      if (tmp___6 == -1) {
#line 363
        error("cfsetispeed failed for %d", baud);
      }
    }
#line 364
    break;
    case 193: 
    case 129: 
#line 369
    n_bytes += 4;
#line 370
    tmp___7 = packet_get_int();
#line 370
    baud = (int )tmp___7;
#line 371
    debug2("tty_parse_modes: ospeed %d", baud);
#line 372
    if (failure != -1) {
#line 372
      tmp___8 = baud_to_speed(baud);
#line 372
      tmp___9 = cfsetospeed(& tio, tmp___8);
#line 372
      if (tmp___9 == -1) {
#line 373
        error("cfsetospeed failed for %d", baud);
      }
    }
#line 374
    break;
    case 1: 
#line 69 "ttymodes.h"
    n_bytes += arg_size;
#line 69
    tmp___10 = (*get_arg)();
#line 69
    tio.c_cc[0] = (unsigned char )tmp___10;
#line 69
    debug2("tty_parse_modes: %d %d", 1, tio.c_cc[0]);
#line 69
    break;
    case 2: 
#line 70
    n_bytes += arg_size;
#line 70
    tmp___11 = (*get_arg)();
#line 70
    tio.c_cc[1] = (unsigned char )tmp___11;
#line 70
    debug2("tty_parse_modes: %d %d", 2, tio.c_cc[1]);
#line 70
    break;
    case 3: 
#line 71
    n_bytes += arg_size;
#line 71
    tmp___12 = (*get_arg)();
#line 71
    tio.c_cc[2] = (unsigned char )tmp___12;
#line 71
    debug2("tty_parse_modes: %d %d", 3, tio.c_cc[2]);
#line 71
    break;
    case 4: 
#line 73
    n_bytes += arg_size;
#line 73
    tmp___13 = (*get_arg)();
#line 73
    tio.c_cc[3] = (unsigned char )tmp___13;
#line 73
    debug2("tty_parse_modes: %d %d", 4, tio.c_cc[3]);
#line 73
    break;
    case 5: 
#line 75
    n_bytes += arg_size;
#line 75
    tmp___14 = (*get_arg)();
#line 75
    tio.c_cc[4] = (unsigned char )tmp___14;
#line 75
    debug2("tty_parse_modes: %d %d", 5, tio.c_cc[4]);
#line 75
    break;
    case 6: 
#line 77
    n_bytes += arg_size;
#line 77
    tmp___15 = (*get_arg)();
#line 77
    tio.c_cc[11] = (unsigned char )tmp___15;
#line 77
    debug2("tty_parse_modes: %d %d", 6, tio.c_cc[11]);
#line 77
    break;
    case 7: 
#line 80
    n_bytes += arg_size;
#line 80
    tmp___16 = (*get_arg)();
#line 80
    tio.c_cc[16] = (unsigned char )tmp___16;
#line 80
    debug2("tty_parse_modes: %d %d", 7, tio.c_cc[16]);
#line 80
    break;
    case 8: 
#line 82
    n_bytes += arg_size;
#line 82
    tmp___17 = (*get_arg)();
#line 82
    tio.c_cc[8] = (unsigned char )tmp___17;
#line 82
    debug2("tty_parse_modes: %d %d", 8, tio.c_cc[8]);
#line 82
    break;
    case 9: 
#line 83
    n_bytes += arg_size;
#line 83
    tmp___18 = (*get_arg)();
#line 83
    tio.c_cc[9] = (unsigned char )tmp___18;
#line 83
    debug2("tty_parse_modes: %d %d", 9, tio.c_cc[9]);
#line 83
    break;
    case 10: 
#line 85
    n_bytes += arg_size;
#line 85
    tmp___19 = (*get_arg)();
#line 85
    tio.c_cc[10] = (unsigned char )tmp___19;
#line 85
    debug2("tty_parse_modes: %d %d", 10, tio.c_cc[10]);
#line 85
    break;
    case 12: 
#line 91
    n_bytes += arg_size;
#line 91
    tmp___20 = (*get_arg)();
#line 91
    tio.c_cc[12] = (unsigned char )tmp___20;
#line 91
    debug2("tty_parse_modes: %d %d", 12, tio.c_cc[12]);
#line 91
    break;
    case 13: 
#line 94
    n_bytes += arg_size;
#line 94
    tmp___21 = (*get_arg)();
#line 94
    tio.c_cc[14] = (unsigned char )tmp___21;
#line 94
    debug2("tty_parse_modes: %d %d", 13, tio.c_cc[14]);
#line 94
    break;
    case 14: 
#line 97
    n_bytes += arg_size;
#line 97
    tmp___22 = (*get_arg)();
#line 97
    tio.c_cc[15] = (unsigned char )tmp___22;
#line 97
    debug2("tty_parse_modes: %d %d", 14, tio.c_cc[15]);
#line 97
    break;
    case 18: 
#line 109
    n_bytes += arg_size;
#line 109
    tmp___23 = (*get_arg)();
#line 109
    tio.c_cc[13] = (unsigned char )tmp___23;
#line 109
    debug2("tty_parse_modes: %d %d", 18, tio.c_cc[13]);
#line 109
    break;
    case 30: 
#line 113
    n_bytes += arg_size;
#line 113
    tmp___24 = (*get_arg)();
#line 113
    arg = (int )tmp___24;
#line 113
    if (arg) {
#line 113
      tio.c_iflag |= 4U;
    } else {
#line 113
      tio.c_iflag &= 4294967291U;
    }
#line 113
    debug2("tty_parse_modes: %d %d", 30, arg);
#line 113
    break;
    case 31: 
#line 114
    n_bytes += arg_size;
#line 114
    tmp___25 = (*get_arg)();
#line 114
    arg = (int )tmp___25;
#line 114
    if (arg) {
#line 114
      tio.c_iflag |= 8U;
    } else {
#line 114
      tio.c_iflag &= 4294967287U;
    }
#line 114
    debug2("tty_parse_modes: %d %d", 31, arg);
#line 114
    break;
    case 32: 
#line 115
    n_bytes += arg_size;
#line 115
    tmp___26 = (*get_arg)();
#line 115
    arg = (int )tmp___26;
#line 115
    if (arg) {
#line 115
      tio.c_iflag |= 16U;
    } else {
#line 115
      tio.c_iflag &= 4294967279U;
    }
#line 115
    debug2("tty_parse_modes: %d %d", 32, arg);
#line 115
    break;
    case 33: 
#line 116
    n_bytes += arg_size;
#line 116
    tmp___27 = (*get_arg)();
#line 116
    arg = (int )tmp___27;
#line 116
    if (arg) {
#line 116
      tio.c_iflag |= 32U;
    } else {
#line 116
      tio.c_iflag &= 4294967263U;
    }
#line 116
    debug2("tty_parse_modes: %d %d", 33, arg);
#line 116
    break;
    case 34: 
#line 117
    n_bytes += arg_size;
#line 117
    tmp___28 = (*get_arg)();
#line 117
    arg = (int )tmp___28;
#line 117
    if (arg) {
#line 117
      tio.c_iflag |= 64U;
    } else {
#line 117
      tio.c_iflag &= 4294967231U;
    }
#line 117
    debug2("tty_parse_modes: %d %d", 34, arg);
#line 117
    break;
    case 35: 
#line 118
    n_bytes += arg_size;
#line 118
    tmp___29 = (*get_arg)();
#line 118
    arg = (int )tmp___29;
#line 118
    if (arg) {
#line 118
      tio.c_iflag |= 128U;
    } else {
#line 118
      tio.c_iflag &= 4294967167U;
    }
#line 118
    debug2("tty_parse_modes: %d %d", 35, arg);
#line 118
    break;
    case 36: 
#line 119
    n_bytes += arg_size;
#line 119
    tmp___30 = (*get_arg)();
#line 119
    arg = (int )tmp___30;
#line 119
    if (arg) {
#line 119
      tio.c_iflag |= 256U;
    } else {
#line 119
      tio.c_iflag &= 4294967039U;
    }
#line 119
    debug2("tty_parse_modes: %d %d", 36, arg);
#line 119
    break;
    case 37: 
#line 121
    n_bytes += arg_size;
#line 121
    tmp___31 = (*get_arg)();
#line 121
    arg = (int )tmp___31;
#line 121
    if (arg) {
#line 121
      tio.c_iflag |= 512U;
    } else {
#line 121
      tio.c_iflag &= 4294966783U;
    }
#line 121
    debug2("tty_parse_modes: %d %d", 37, arg);
#line 121
    break;
    case 38: 
#line 123
    n_bytes += arg_size;
#line 123
    tmp___32 = (*get_arg)();
#line 123
    arg = (int )tmp___32;
#line 123
    if (arg) {
#line 123
      tio.c_iflag |= 1024U;
    } else {
#line 123
      tio.c_iflag &= 4294966271U;
    }
#line 123
    debug2("tty_parse_modes: %d %d", 38, arg);
#line 123
    break;
    case 39: 
#line 124
    n_bytes += arg_size;
#line 124
    tmp___33 = (*get_arg)();
#line 124
    arg = (int )tmp___33;
#line 124
    if (arg) {
#line 124
      tio.c_iflag |= 2048U;
    } else {
#line 124
      tio.c_iflag &= 4294965247U;
    }
#line 124
    debug2("tty_parse_modes: %d %d", 39, arg);
#line 124
    break;
    case 40: 
#line 125
    n_bytes += arg_size;
#line 125
    tmp___34 = (*get_arg)();
#line 125
    arg = (int )tmp___34;
#line 125
    if (arg) {
#line 125
      tio.c_iflag |= 4096U;
    } else {
#line 125
      tio.c_iflag &= 4294963199U;
    }
#line 125
    debug2("tty_parse_modes: %d %d", 40, arg);
#line 125
    break;
    case 41: 
#line 127
    n_bytes += arg_size;
#line 127
    tmp___35 = (*get_arg)();
#line 127
    arg = (int )tmp___35;
#line 127
    if (arg) {
#line 127
      tio.c_iflag |= 8192U;
    } else {
#line 127
      tio.c_iflag &= 4294959103U;
    }
#line 127
    debug2("tty_parse_modes: %d %d", 41, arg);
#line 127
    break;
    case 50: 
#line 130
    n_bytes += arg_size;
#line 130
    tmp___36 = (*get_arg)();
#line 130
    arg = (int )tmp___36;
#line 130
    if (arg) {
#line 130
      tio.c_lflag |= 1U;
    } else {
#line 130
      tio.c_lflag &= 4294967294U;
    }
#line 130
    debug2("tty_parse_modes: %d %d", 50, arg);
#line 130
    break;
    case 51: 
#line 131
    n_bytes += arg_size;
#line 131
    tmp___37 = (*get_arg)();
#line 131
    arg = (int )tmp___37;
#line 131
    if (arg) {
#line 131
      tio.c_lflag |= 2U;
    } else {
#line 131
      tio.c_lflag &= 4294967293U;
    }
#line 131
    debug2("tty_parse_modes: %d %d", 51, arg);
#line 131
    break;
    case 52: 
#line 133
    n_bytes += arg_size;
#line 133
    tmp___38 = (*get_arg)();
#line 133
    arg = (int )tmp___38;
#line 133
    if (arg) {
#line 133
      tio.c_lflag |= 4U;
    } else {
#line 133
      tio.c_lflag &= 4294967291U;
    }
#line 133
    debug2("tty_parse_modes: %d %d", 52, arg);
#line 133
    break;
    case 53: 
#line 135
    n_bytes += arg_size;
#line 135
    tmp___39 = (*get_arg)();
#line 135
    arg = (int )tmp___39;
#line 135
    if (arg) {
#line 135
      tio.c_lflag |= 8U;
    } else {
#line 135
      tio.c_lflag &= 4294967287U;
    }
#line 135
    debug2("tty_parse_modes: %d %d", 53, arg);
#line 135
    break;
    case 54: 
#line 136
    n_bytes += arg_size;
#line 136
    tmp___40 = (*get_arg)();
#line 136
    arg = (int )tmp___40;
#line 136
    if (arg) {
#line 136
      tio.c_lflag |= 16U;
    } else {
#line 136
      tio.c_lflag &= 4294967279U;
    }
#line 136
    debug2("tty_parse_modes: %d %d", 54, arg);
#line 136
    break;
    case 55: 
#line 137
    n_bytes += arg_size;
#line 137
    tmp___41 = (*get_arg)();
#line 137
    arg = (int )tmp___41;
#line 137
    if (arg) {
#line 137
      tio.c_lflag |= 32U;
    } else {
#line 137
      tio.c_lflag &= 4294967263U;
    }
#line 137
    debug2("tty_parse_modes: %d %d", 55, arg);
#line 137
    break;
    case 56: 
#line 138
    n_bytes += arg_size;
#line 138
    tmp___42 = (*get_arg)();
#line 138
    arg = (int )tmp___42;
#line 138
    if (arg) {
#line 138
      tio.c_lflag |= 64U;
    } else {
#line 138
      tio.c_lflag &= 4294967231U;
    }
#line 138
    debug2("tty_parse_modes: %d %d", 56, arg);
#line 138
    break;
    case 57: 
#line 139
    n_bytes += arg_size;
#line 139
    tmp___43 = (*get_arg)();
#line 139
    arg = (int )tmp___43;
#line 139
    if (arg) {
#line 139
      tio.c_lflag |= 128U;
    } else {
#line 139
      tio.c_lflag &= 4294967167U;
    }
#line 139
    debug2("tty_parse_modes: %d %d", 57, arg);
#line 139
    break;
    case 58: 
#line 140
    n_bytes += arg_size;
#line 140
    tmp___44 = (*get_arg)();
#line 140
    arg = (int )tmp___44;
#line 140
    if (arg) {
#line 140
      tio.c_lflag |= 256U;
    } else {
#line 140
      tio.c_lflag &= 4294967039U;
    }
#line 140
    debug2("tty_parse_modes: %d %d", 58, arg);
#line 140
    break;
    case 59: 
#line 142
    n_bytes += arg_size;
#line 142
    tmp___45 = (*get_arg)();
#line 142
    arg = (int )tmp___45;
#line 142
    if (arg) {
#line 142
      tio.c_lflag |= 32768U;
    } else {
#line 142
      tio.c_lflag &= 4294934527U;
    }
#line 142
    debug2("tty_parse_modes: %d %d", 59, arg);
#line 142
    break;
    case 60: 
#line 145
    n_bytes += arg_size;
#line 145
    tmp___46 = (*get_arg)();
#line 145
    arg = (int )tmp___46;
#line 145
    if (arg) {
#line 145
      tio.c_lflag |= 512U;
    } else {
#line 145
      tio.c_lflag &= 4294966783U;
    }
#line 145
    debug2("tty_parse_modes: %d %d", 60, arg);
#line 145
    break;
    case 61: 
#line 148
    n_bytes += arg_size;
#line 148
    tmp___47 = (*get_arg)();
#line 148
    arg = (int )tmp___47;
#line 148
    if (arg) {
#line 148
      tio.c_lflag |= 2048U;
    } else {
#line 148
      tio.c_lflag &= 4294965247U;
    }
#line 148
    debug2("tty_parse_modes: %d %d", 61, arg);
#line 148
    break;
    case 62: 
#line 151
    n_bytes += arg_size;
#line 151
    tmp___48 = (*get_arg)();
#line 151
    arg = (int )tmp___48;
#line 151
    if (arg) {
#line 151
      tio.c_lflag |= 16384U;
    } else {
#line 151
      tio.c_lflag &= 4294950911U;
    }
#line 151
    debug2("tty_parse_modes: %d %d", 62, arg);
#line 151
    break;
    case 70: 
#line 154
    n_bytes += arg_size;
#line 154
    tmp___49 = (*get_arg)();
#line 154
    arg = (int )tmp___49;
#line 154
    if (arg) {
#line 154
      tio.c_oflag |= 1U;
    } else {
#line 154
      tio.c_oflag &= 4294967294U;
    }
#line 154
    debug2("tty_parse_modes: %d %d", 70, arg);
#line 154
    break;
    case 71: 
#line 156
    n_bytes += arg_size;
#line 156
    tmp___50 = (*get_arg)();
#line 156
    arg = (int )tmp___50;
#line 156
    if (arg) {
#line 156
      tio.c_oflag |= 2U;
    } else {
#line 156
      tio.c_oflag &= 4294967293U;
    }
#line 156
    debug2("tty_parse_modes: %d %d", 71, arg);
#line 156
    break;
    case 72: 
#line 158
    n_bytes += arg_size;
#line 158
    tmp___51 = (*get_arg)();
#line 158
    arg = (int )tmp___51;
#line 158
    if (arg) {
#line 158
      tio.c_oflag |= 4U;
    } else {
#line 158
      tio.c_oflag &= 4294967291U;
    }
#line 158
    debug2("tty_parse_modes: %d %d", 72, arg);
#line 158
    break;
    case 73: 
#line 160
    n_bytes += arg_size;
#line 160
    tmp___52 = (*get_arg)();
#line 160
    arg = (int )tmp___52;
#line 160
    if (arg) {
#line 160
      tio.c_oflag |= 8U;
    } else {
#line 160
      tio.c_oflag &= 4294967287U;
    }
#line 160
    debug2("tty_parse_modes: %d %d", 73, arg);
#line 160
    break;
    case 74: 
#line 163
    n_bytes += arg_size;
#line 163
    tmp___53 = (*get_arg)();
#line 163
    arg = (int )tmp___53;
#line 163
    if (arg) {
#line 163
      tio.c_oflag |= 16U;
    } else {
#line 163
      tio.c_oflag &= 4294967279U;
    }
#line 163
    debug2("tty_parse_modes: %d %d", 74, arg);
#line 163
    break;
    case 75: 
#line 166
    n_bytes += arg_size;
#line 166
    tmp___54 = (*get_arg)();
#line 166
    arg = (int )tmp___54;
#line 166
    if (arg) {
#line 166
      tio.c_oflag |= 32U;
    } else {
#line 166
      tio.c_oflag &= 4294967263U;
    }
#line 166
    debug2("tty_parse_modes: %d %d", 75, arg);
#line 166
    break;
    case 90: 
#line 169
    n_bytes += arg_size;
#line 169
    tmp___55 = (*get_arg)();
#line 169
    arg = (int )tmp___55;
#line 169
    if (arg) {
#line 169
      tio.c_cflag |= 32U;
    } else {
#line 169
      tio.c_cflag &= 4294967263U;
    }
#line 169
    debug2("tty_parse_modes: %d %d", 90, arg);
#line 169
    break;
    case 91: 
#line 170
    n_bytes += arg_size;
#line 170
    tmp___56 = (*get_arg)();
#line 170
    arg = (int )tmp___56;
#line 170
    if (arg) {
#line 170
      tio.c_cflag |= 48U;
    } else {
#line 170
      tio.c_cflag &= 4294967247U;
    }
#line 170
    debug2("tty_parse_modes: %d %d", 91, arg);
#line 170
    break;
    case 92: 
#line 171
    n_bytes += arg_size;
#line 171
    tmp___57 = (*get_arg)();
#line 171
    arg = (int )tmp___57;
#line 171
    if (arg) {
#line 171
      tio.c_cflag |= 256U;
    } else {
#line 171
      tio.c_cflag &= 4294967039U;
    }
#line 171
    debug2("tty_parse_modes: %d %d", 92, arg);
#line 171
    break;
    case 93: 
#line 172
    n_bytes += arg_size;
#line 172
    tmp___58 = (*get_arg)();
#line 172
    arg = (int )tmp___58;
#line 172
    if (arg) {
#line 172
      tio.c_cflag |= 512U;
    } else {
#line 172
      tio.c_cflag &= 4294966783U;
    }
#line 172
    debug2("tty_parse_modes: %d %d", 93, arg);
#line 172
    break;
    default: 
#line 398 "ttymodes.c"
    debug("Ignoring unsupported tty mode opcode %d (0x%x)", opcode, opcode);
#line 400
    if (! compat20) {
#line 408
      if (opcode > 0) {
#line 408
        if (opcode < 128) {
#line 409
          n_bytes ++;
#line 410
          packet_get_char();
#line 411
          break;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 412
        if (opcode >= 128) {
#line 412
          if (opcode < 160) {
#line 413
            n_bytes += 4;
#line 414
            packet_get_int();
#line 415
            break;
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 424
          log("parse_tty_modes: unknown opcode %d", opcode);
#line 425
          while (1) {
#line 425
            _p = 0;
#line 425
            _e = 1;
#line 425
            if (_p != _e) {
#line 425
              log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "ttymodes.c",
                  425);
#line 425
              packet_disconnect("Packet integrity error. (%d)", 10);
            }
#line 425
            break;
          }
          goto set;
        }
      }
    } else {
#line 436
      if (opcode > 0) {
#line 436
        if (opcode < 160) {
#line 437
          n_bytes += 4;
#line 438
          packet_get_int();
#line 439
          break;
        } else {
#line 441
          log("parse_tty_modes: unknown opcode %d", opcode);
          goto set;
        }
      } else {
#line 441
        log("parse_tty_modes: unknown opcode %d", opcode);
        goto set;
      }
    }
    }
  }
  set: 
#line 449
  if (*n_bytes_ptr != n_bytes) {
#line 450
    *n_bytes_ptr = n_bytes;
#line 451
    log("parse_tty_modes: n_bytes_ptr != n_bytes: %d %d", *n_bytes_ptr, n_bytes);
#line 453
    return;
  }
#line 455
  if (failure == -1) {
#line 456
    return;
  }
#line 459
  tmp___61 = tcsetattr(fd, 0, (struct termios  const  *)(& tio));
#line 459
  if (tmp___61 == -1) {
#line 460
    tmp___59 = __errno_location();
#line 460
    tmp___60 = strerror(*tmp___59);
#line 460
    log("Setting tty modes failed: %.100s", tmp___60);
  }
#line 461
  return;
}
}
#line 1 "uidswap.o"
#pragma merger(0,"./uidswap.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 651 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 656
extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t *__list ) ;
#line 684
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 694
extern  __attribute__((__nothrow__)) int setegid(__gid_t __gid ) ;
#line 178 "/usr/include/grp.h"
extern  __attribute__((__nothrow__)) int setgroups(size_t __n , __gid_t const   *__groups ) ;
#line 199
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 34 "uidswap.h"
void permanently_set_uid(struct passwd *pw ) ;
#line 34 "uidswap.c"
static uid_t saved_euid  =    (uid_t )0;
#line 35 "uidswap.c"
static gid_t saved_egid  =    (gid_t )0;
#line 39 "uidswap.c"
static int privileged  =    0;
#line 40 "uidswap.c"
static int temporarily_use_uid_effective  =    0;
#line 41 "uidswap.c"
static gid_t saved_egroups[65536]  ;
#line 41 "uidswap.c"
static gid_t user_groups[65536]  ;
#line 42 "uidswap.c"
static int saved_egroupslen  =    -1;
#line 42 "uidswap.c"
static int user_groupslen  =    -1;
#line 48 "uidswap.c"
void temporarily_use_uid(struct passwd *pw ) 
{ int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;

  {
#line 53
  saved_euid = geteuid();
#line 54
  saved_egid = getegid();
#line 55
  debug("temporarily_use_uid: %d/%d (e=%d)", pw->pw_uid, pw->pw_gid, saved_euid);
#line 57
  if (saved_euid != 0U) {
#line 58
    privileged = 0;
#line 59
    return;
  }
#line 68
  privileged = 1;
#line 69
  temporarily_use_uid_effective = 1;
#line 70
  saved_egroupslen = getgroups(65536, saved_egroups);
#line 71
  if (saved_egroupslen < 0) {
#line 72
    tmp = __errno_location();
#line 72
    tmp___0 = strerror(*tmp);
#line 72
    fatal("getgroups: %.100s", tmp___0);
  }
#line 75
  if (user_groupslen == -1) {
#line 76
    tmp___3 = initgroups((char const   *)pw->pw_name, pw->pw_gid);
#line 76
    if (tmp___3 < 0) {
#line 77
      tmp___1 = __errno_location();
#line 77
      tmp___2 = strerror(*tmp___1);
#line 77
      fatal("initgroups: %s: %.100s", pw->pw_name, tmp___2);
    }
#line 79
    user_groupslen = getgroups(65536, user_groups);
#line 80
    if (user_groupslen < 0) {
#line 81
      tmp___4 = __errno_location();
#line 81
      tmp___5 = strerror(*tmp___4);
#line 81
      fatal("getgroups: %.100s", tmp___5);
    }
  }
#line 85
  tmp___8 = setgroups((unsigned int )user_groupslen, (__gid_t const   *)(user_groups));
#line 85
  if (tmp___8 < 0) {
#line 86
    tmp___6 = __errno_location();
#line 86
    tmp___7 = strerror(*tmp___6);
#line 86
    fatal("setgroups: %.100s", tmp___7);
  }
#line 96
  tmp___11 = setegid(pw->pw_gid);
#line 96
  if (tmp___11 < 0) {
#line 97
    tmp___9 = __errno_location();
#line 97
    tmp___10 = strerror(*tmp___9);
#line 97
    fatal("setegid %u: %.100s", pw->pw_gid, tmp___10);
  }
#line 99
  tmp___14 = seteuid(pw->pw_uid);
#line 99
  if (tmp___14 == -1) {
#line 100
    tmp___12 = __errno_location();
#line 100
    tmp___13 = strerror(*tmp___12);
#line 100
    fatal("seteuid %u: %.100s", pw->pw_uid, tmp___13);
  }
#line 102
  return;
}
}
#line 107 "uidswap.c"
void restore_uid(void) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
#line 110
  debug("restore_uid");
#line 112
  if (! privileged) {
#line 113
    return;
  }
#line 114
  if (! temporarily_use_uid_effective) {
#line 115
    fatal("restore_uid: temporarily_use_uid not effective");
  }
#line 119
  tmp___1 = seteuid(saved_euid);
#line 119
  if (tmp___1 < 0) {
#line 120
    tmp = __errno_location();
#line 120
    tmp___0 = strerror(*tmp);
#line 120
    fatal("seteuid %u: %.100s", saved_euid, tmp___0);
  }
#line 122
  tmp___4 = setegid(saved_egid);
#line 122
  if (tmp___4 < 0) {
#line 123
    tmp___2 = __errno_location();
#line 123
    tmp___3 = strerror(*tmp___2);
#line 123
    fatal("setegid %u: %.100s", saved_egid, tmp___3);
  }
#line 136
  tmp___7 = setgroups((unsigned int )saved_egroupslen, (__gid_t const   *)(saved_egroups));
#line 136
  if (tmp___7 < 0) {
#line 137
    tmp___5 = __errno_location();
#line 137
    tmp___6 = strerror(*tmp___5);
#line 137
    fatal("setgroups: %.100s", tmp___6);
  }
#line 139
  temporarily_use_uid_effective = 0;
#line 140
  return;
}
}
#line 146 "uidswap.c"
void permanently_set_uid(struct passwd *pw ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 149
  if (temporarily_use_uid_effective) {
#line 150
    fatal("restore_uid: temporarily_use_uid effective");
  }
#line 151
  tmp___1 = setgid(pw->pw_gid);
#line 151
  if (tmp___1 < 0) {
#line 152
    tmp = __errno_location();
#line 152
    tmp___0 = strerror(*tmp);
#line 152
    fatal("setgid %u: %.100s", pw->pw_gid, tmp___0);
  }
#line 153
  tmp___4 = setuid(pw->pw_uid);
#line 153
  if (tmp___4 < 0) {
#line 154
    tmp___2 = __errno_location();
#line 154
    tmp___3 = strerror(*tmp___2);
#line 154
    fatal("setuid %u: %.100s", pw->pw_uid, tmp___3);
  }
#line 155
  return;
}
}
#line 1 "uuencode.o"
#pragma merger(0,"./uuencode.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 31 "uuencode.h"
void dump_base64(FILE *fp , u_char *data , int len ) ;
#line 33 "uuencode.c"
int uuencode(u_char *src , u_int srclength , char *target , size_t targsize ) 
{ int tmp ;

  {
#line 37
  tmp = b64_ntop((u_char const   *)src, srclength, target, targsize);
#line 37
  return (tmp);
}
}
#line 40 "uuencode.c"
int uudecode(char const   *src , u_char *target , size_t targsize ) 
{ int len ;
  char *encoded ;
  char *p ;

  {
#line 47
  encoded = xstrdup(src);
#line 49
  p = encoded;
#line 49
  while (1) {
#line 49
    if (! ((int )*p == 32)) {
#line 49
      if (! ((int )*p == 9)) {
#line 49
        break;
      }
    }
#line 49
    p ++;
  }
#line 51
  while (1) {
#line 51
    if ((int )*p != 0) {
#line 51
      if ((int )*p != 32) {
#line 51
        if (! ((int )*p != 9)) {
#line 51
          break;
        }
      } else {
#line 51
        break;
      }
    } else {
#line 51
      break;
    }
#line 51
    p ++;
  }
#line 54
  *p = (char )'\000';
#line 55
  len = b64_pton((char const   *)encoded, target, targsize);
#line 56
  xfree((void *)encoded);
#line 57
  return (len);
}
}
#line 60 "uuencode.c"
void dump_base64(FILE *fp , u_char *data , int len ) 
{ u_char *buf___2 ;
  void *tmp ;
  int i ;
  int n___0 ;

  {
#line 63
  tmp = xmalloc((unsigned int )(2 * len));
#line 63
  buf___2 = (u_char *)tmp;
#line 66
  n___0 = uuencode(data, (unsigned int )len, (char *)buf___2, (unsigned int )(2 * len));
#line 67
  i = 0;
#line 67
  while (i < n___0) {
#line 68
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%c", *(buf___2 + i));
#line 69
    if (i % 70 == 69) {
#line 70
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
    }
#line 67
    i ++;
  }
#line 72
  if (i % 70 != 69) {
#line 73
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  }
#line 74
  xfree((void *)buf___2);
#line 75
  return;
}
}
#line 1 "xmalloc.o"
#pragma merger(0,"./xmalloc.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 21 "xmalloc.c"
void *xmalloc(size_t size ) 
{ void *ptr ;

  {
#line 26
  if (size == 0U) {
#line 27
    fatal("xmalloc: zero size");
  }
#line 28
  ptr = malloc(size);
#line 29
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 30
    fatal("xmalloc: out of memory (allocating %lu bytes)", (unsigned long )size);
  }
#line 31
  return (ptr);
}
}
#line 34 "xmalloc.c"
void *xrealloc(void *ptr , size_t new_size ) 
{ void *new_ptr ;

  {
#line 39
  if (new_size == 0U) {
#line 40
    fatal("xrealloc: zero size");
  }
#line 41
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 42
    new_ptr = malloc(new_size);
  } else {
#line 44
    new_ptr = realloc(ptr, new_size);
  }
#line 45
  if ((unsigned int )new_ptr == (unsigned int )((void *)0)) {
#line 46
    fatal("xrealloc: out of memory (new_size %lu bytes)", (unsigned long )new_size);
  }
#line 47
  return (new_ptr);
}
}
#line 50 "xmalloc.c"
void xfree(void *ptr ) 
{ 

  {
#line 53
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 54
    fatal("xfree: NULL pointer given as argument");
  }
#line 55
  free(ptr);
#line 56
  return;
}
}
#line 58 "xmalloc.c"
char *xstrdup(char const   *str ) 
{ size_t len ;
  size_t tmp ;
  char *cp ;
  void *tmp___0 ;

  {
#line 61
  tmp = strlen(str);
#line 61
  len = tmp + 1U;
#line 64
  if (len == 0U) {
#line 65
    fatal("xstrdup: zero size");
  }
#line 66
  tmp___0 = xmalloc(len);
#line 66
  cp = (char *)tmp___0;
#line 67
  strlcpy(cp, str, len);
#line 68
  return (cp);
}
}
#line 1 "sshd.o"
#pragma merger(0,"./sshd.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 393 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 457
extern  __attribute__((__nothrow__)) int chdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 490
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 516
extern  __attribute__((__nothrow__)) int execv(char const   *__path , char * const  *__argv )  __attribute__((__nonnull__(1))) ;
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 73
extern int optind ;
#line 152
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 903 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 92 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 478 "/usr/include/openssl/bn.h"
extern int BN_mask_bits(BIGNUM *a , int n ) ;
#line 133 "servconf.h"
void initialize_server_options(ServerOptions *options___0 ) ;
#line 139
void read_server_config(ServerOptions *options___0 , char const   *filename ) ;
#line 142
void fill_default_server_options(ServerOptions *options___0 ) ;
#line 711 "/usr/include/openssl/evp.h"
extern void OPENSSL_add_all_algorithms_noconf(void) ;
#line 41 "myproposal.h"
static char *myproposal[10]  = 
#line 41 "myproposal.h"
  {      (char *)"diffie-hellman-group-exchange-sha1,diffie-hellman-group1-sha1",      (char *)"ssh-rsa,ssh-dss",      (char *)"aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,arcfour,aes192-cbc,aes256-cbc,rijndael128-cbc,rijndael192-cbc,rijndael256-cbc,rijndael-cbc@lysator.liu.se",      (char *)"aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,arcfour,aes192-cbc,aes256-cbc,rijndael128-cbc,rijndael192-cbc,rijndael256-cbc,rijndael-cbc@lysator.liu.se", 
        (char *)"hmac-md5,hmac-sha1,hmac-ripemd160,hmac-ripemd160@openssh.com,hmac-sha1-96,hmac-md5-96",      (char *)"hmac-md5,hmac-sha1,hmac-ripemd160,hmac-ripemd160@openssh.com,hmac-sha1-96,hmac-md5-96",      (char *)"none,zlib",      (char *)"none,zlib", 
        (char *)"",      (char *)""};
#line 124 "auth.h"
void do_authentication(void) ;
#line 125
void do_authentication2(void) ;
#line 93 "sshd.c"
ServerOptions options  ;
#line 96 "sshd.c"
char *config_file_name  =    (char *)"/usr/local/etc/sshd_config";
#line 105 "sshd.c"
int IPv4or6  =    0;
#line 114 "sshd.c"
int debug_flag  =    0;
#line 117 "sshd.c"
int inetd_flag  =    0;
#line 120 "sshd.c"
int no_daemon_flag  =    0;
#line 123 "sshd.c"
int log_stderr  =    0;
#line 126 "sshd.c"
char **saved_argv  ;
#line 127 "sshd.c"
int saved_argc  ;
#line 134 "sshd.c"
int listen_socks[16]  ;
#line 135 "sshd.c"
int num_listen_socks  =    0;
#line 141 "sshd.c"
char *client_version_string  =    (char *)((void *)0);
#line 142 "sshd.c"
char *server_version_string  =    (char *)((void *)0);
#line 145 "sshd.c"
Kex *xxx_kex  ;
#line 155 "sshd.c"
struct __anonstruct_sensitive_data_80 sensitive_data  ;
#line 168 "sshd.c"
int key_do_regen  =    0;
#line 171 "sshd.c"
int received_sighup  =    0;
#line 174 "sshd.c"
u_char session_id[16]  ;
#line 177 "sshd.c"
u_char *session_id2  =    (u_char *)((void *)0);
#line 178 "sshd.c"
int session_id2_len  =    0;
#line 181 "sshd.c"
u_int utmp_len  =    (u_int )64;
#line 184
void do_ssh1_kex(void) ;
#line 185
void do_ssh2_kex(void) ;
#line 193 "sshd.c"
void close_listen_socks(void) 
{ int i ;

  {
#line 197
  i = 0;
#line 197
  while (i < num_listen_socks) {
#line 198
    close(listen_socks[i]);
#line 197
    i ++;
  }
#line 199
  num_listen_socks = -1;
#line 200
  return;
}
}
#line 207 "sshd.c"
void sighup_handler(int sig ) 
{ 

  {
#line 210
  received_sighup = 1;
#line 211
  signal(1, & sighup_handler);
#line 212
  return;
}
}
#line 218 "sshd.c"
void sighup_restart(void) 
{ int *tmp ;
  char *tmp___0 ;

  {
#line 221
  log("Received SIGHUP; restarting.");
#line 222
  close_listen_socks();
#line 223
  execv((char const   *)*(saved_argv + 0), (char * const  *)saved_argv);
#line 224
  tmp = __errno_location();
#line 224
  tmp___0 = strerror(*tmp);
#line 224
  log("RESTART FAILED: av[0]=\'%.100s\', error: %.100s.", *(saved_argv + 0), tmp___0);
#line 225
  exit(1);
}
}
#line 233 "sshd.c"
void sigterm_handler(int sig ) 
{ 

  {
#line 236
  log("Received signal %d; terminating.", sig);
#line 237
  close_listen_socks();
#line 238
  unlink((char const   *)options.pid_file);
#line 239
  exit(255);
}
}
#line 246 "sshd.c"
void main_sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  int status ;
  __pid_t tmp___0 ;
  int *tmp___1 ;

  {
#line 249
  tmp = __errno_location();
#line 249
  save_errno = *tmp;
#line 252
  while (1) {
#line 252
    tmp___0 = waitpid(-1, & status, 1);
#line 252
    if (! (tmp___0 > 0)) {
#line 252
      break;
    }
  }
#line 255
  signal(17, & main_sigchld_handler);
#line 256
  tmp___1 = __errno_location();
#line 256
  *tmp___1 = save_errno;
#line 257
  return;
}
}
#line 262 "sshd.c"
void grace_alarm_handler(int sig ) 
{ char const   *tmp ;

  {
#line 266
  packet_close();
#line 269
  tmp = get_remote_ipaddr();
#line 269
  fatal("Timeout before authentication for %s.", tmp);
#line 270
  return;
}
}
#line 279 "sshd.c"
void generate_ephemeral_server_key(void) 
{ u_int32_t rand___0 ;
  int i ;
  char const   *tmp ;

  {
#line 282
  rand___0 = (u_int32_t )0;
#line 285
  if (sensitive_data.server_key) {
#line 285
    tmp = "new ";
  } else {
#line 285
    tmp = "";
  }
#line 285
  verbose("Generating %s%d bit RSA key.", tmp, options.server_key_bits);
#line 287
  if ((unsigned int )sensitive_data.server_key != (unsigned int )((void *)0)) {
#line 288
    key_free(sensitive_data.server_key);
  }
#line 289
  sensitive_data.server_key = key_generate(0, (unsigned int )options.server_key_bits);
#line 291
  verbose("RSA key generation complete.");
#line 293
  i = 0;
#line 293
  while (i < 32) {
#line 294
    if (i % 4 == 0) {
#line 295
      rand___0 = arc4random();
    }
#line 296
    sensitive_data.ssh1_cookie[i] = (unsigned char )(rand___0 & 255U);
#line 297
    rand___0 >>= 8;
#line 293
    i ++;
  }
#line 299
  arc4random_stir();
#line 300
  return;
}
}
#line 302 "sshd.c"
void key_regeneration_alarm(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 305
  tmp = __errno_location();
#line 305
  save_errno = *tmp;
#line 306
  signal(14, (void (*)(int  ))0);
#line 307
  tmp___0 = __errno_location();
#line 307
  *tmp___0 = save_errno;
#line 308
  key_do_regen = 1;
#line 309
  return;
}
}
#line 311 "sshd.c"
void sshd_exchange_identification(int sock_in , int sock_out ) 
{ int i ;
  int mismatch ;
  int remote_major ;
  int remote_minor ;
  int major ;
  int minor ;
  char *s ;
  char buf___2[256] ;
  char remote_version[256] ;
  char const   *tmp ;
  size_t tmp___0 ;
  ssize_t tmp___1 ;
  size_t tmp___2 ;
  char const   *tmp___3 ;
  ssize_t tmp___4 ;
  int tmp___18 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t tmp___31 ;
  char const   *tmp___32 ;
  int tmp___33 ;
  char const   *tmp___34 ;
  size_t tmp___35 ;
  char const   *tmp___36 ;

  {
#line 321
  if (options.protocol & 1) {
#line 321
    if (options.protocol & 4) {
#line 323
      major = 1;
#line 324
      minor = 99;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 325
    if (options.protocol & 4) {
#line 326
      major = 2;
#line 327
      minor = 0;
    } else {
#line 329
      major = 1;
#line 330
      minor = 5;
    }
  }
#line 332
  snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"SSH-%d.%d-%.100s\n",
           major, minor, "OpenSSH_2.9p1");
#line 333
  server_version_string = xstrdup((char const   *)(buf___2));
#line 335
  if ((unsigned int )client_version_string == (unsigned int )((void *)0)) {
#line 337
    tmp___0 = strlen((char const   *)server_version_string);
#line 337
    tmp___1 = atomicio((ssize_t (*)())(& write), sock_out, (void *)server_version_string,
                       tmp___0);
#line 337
    tmp___2 = strlen((char const   *)server_version_string);
#line 337
    if ((size_t )tmp___1 != tmp___2) {
#line 339
      tmp = get_remote_ipaddr();
#line 339
      log("Could not write ident string to %s.", tmp);
#line 340
      fatal_cleanup();
    }
#line 344
    memset((void *)(buf___2), 0, sizeof(buf___2));
#line 345
    i = 0;
#line 345
    while ((unsigned int )i < sizeof(buf___2) - 1U) {
#line 346
      tmp___4 = atomicio((ssize_t (*)())(& read), sock_in, (void *)(& buf___2[i]),
                         1U);
#line 346
      if (tmp___4 != 1) {
#line 347
        tmp___3 = get_remote_ipaddr();
#line 347
        log("Did not receive identification string from %s.", tmp___3);
#line 349
        fatal_cleanup();
      }
#line 351
      if ((int )buf___2[i] == 13) {
#line 352
        buf___2[i] = (char)0;
#line 355
        if (i == 12) {
#line 355
          if (0) {
#line 355
            if (0) {
#line 355
              __s1_len___0 = strlen((char const   *)(buf___2));
#line 355
              __s2_len___0 = strlen("SSH-1.5-W1.0");
#line 355
              if (! ((unsigned int )((void const   *)(buf___2 + 1)) - (unsigned int )((void const   *)(buf___2)) == 1U)) {
                goto _L___3;
              } else {
#line 355
                if (__s1_len___0 >= 4U) {
                  _L___3: /* CIL Label */ 
#line 355
                  if (! ((unsigned int )((void const   *)("SSH-1.5-W1.0" + 1)) - (unsigned int )((void const   *)"SSH-1.5-W1.0") == 1U)) {
#line 355
                    tmp___28 = 1;
                  } else {
#line 355
                    if (__s2_len___0 >= 4U) {
#line 355
                      tmp___28 = 1;
                    } else {
#line 355
                      tmp___28 = 0;
                    }
                  }
                } else {
#line 355
                  tmp___28 = 0;
                }
              }
#line 355
              if (tmp___28) {
#line 355
                tmp___24 = __builtin_strcmp((char const   *)(buf___2), "SSH-1.5-W1.0");
              } else {
#line 355
                tmp___27 = __builtin_strcmp((char const   *)(buf___2), "SSH-1.5-W1.0");
#line 355
                tmp___24 = tmp___27;
              }
            } else {
#line 355
              tmp___27 = __builtin_strcmp((char const   *)(buf___2), "SSH-1.5-W1.0");
#line 355
              tmp___24 = tmp___27;
            }
#line 355
            tmp___18 = tmp___24;
          } else {
#line 355
            tmp___18 = strncmp((char const   *)(buf___2), "SSH-1.5-W1.0", 12U);
          }
#line 355
          if (tmp___18 == 0) {
#line 356
            break;
          }
        }
        goto __Cont;
      }
#line 359
      if ((int )buf___2[i] == 10) {
#line 360
        buf___2[i] = (char)0;
#line 361
        break;
      }
      __Cont: /* CIL Label */ 
#line 345
      i ++;
    }
#line 364
    buf___2[sizeof(buf___2) - 1U] = (char)0;
#line 365
    client_version_string = xstrdup((char const   *)(buf___2));
  }
#line 372
  tmp___33 = sscanf((char const   * __restrict  )client_version_string, (char const   * __restrict  )"SSH-%d.%d-%[^\n]\n",
                    & remote_major, & remote_minor, remote_version);
#line 372
  if (tmp___33 != 3) {
#line 374
    s = (char *)"Protocol mismatch.\n";
#line 375
    tmp___31 = strlen((char const   *)s);
#line 375
    atomicio((ssize_t (*)())(& write), sock_out, (void *)s, tmp___31);
#line 376
    close(sock_in);
#line 377
    close(sock_out);
#line 378
    tmp___32 = get_remote_ipaddr();
#line 378
    log("Bad protocol version identification \'%.100s\' from %s", client_version_string,
        tmp___32);
#line 380
    fatal_cleanup();
  }
#line 382
  debug("Client protocol version %d.%d; client software version %.100s", remote_major,
        remote_minor, remote_version);
#line 385
  compat_datafellows((char const   *)(remote_version));
#line 387
  if (datafellows & 2048) {
#line 388
    tmp___34 = get_remote_ipaddr();
#line 388
    log("scanned from %s with %s.  Don\'t panic.", tmp___34, client_version_string);
#line 390
    fatal_cleanup();
  }
#line 393
  mismatch = 0;
#line 394
  switch (remote_major) {
  case 1: 
#line 396
  if (remote_minor == 99) {
#line 397
    if (options.protocol & 4) {
#line 398
      enable_compat20();
    } else {
#line 400
      mismatch = 1;
    }
#line 401
    break;
  }
#line 403
  if (! (options.protocol & 1)) {
#line 404
    mismatch = 1;
#line 405
    break;
  }
#line 407
  if (remote_minor < 3) {
#line 408
    packet_disconnect("Your ssh version is too old and is no longer supported.  Please install a newer version.");
  } else {
#line 410
    if (remote_minor == 3) {
#line 412
      enable_compat13();
    }
  }
#line 414
  break;
  case 2: 
#line 416
  if (options.protocol & 4) {
#line 417
    enable_compat20();
#line 418
    break;
  }
  default: 
#line 422
  mismatch = 1;
#line 423
  break;
  }
#line 425
  chop(server_version_string);
#line 426
  debug("Local version string %.200s", server_version_string);
#line 428
  if (mismatch) {
#line 429
    s = (char *)"Protocol major versions differ.\n";
#line 430
    tmp___35 = strlen((char const   *)s);
#line 430
    atomicio((ssize_t (*)())(& write), sock_out, (void *)s, tmp___35);
#line 431
    close(sock_in);
#line 432
    close(sock_out);
#line 433
    tmp___36 = get_remote_ipaddr();
#line 433
    log("Protocol major versions differ for %s: %.200s vs. %.200s", tmp___36, server_version_string,
        client_version_string);
#line 436
    fatal_cleanup();
  }
#line 438
  if (compat20) {
#line 439
    packet_set_ssh2_format();
  }
#line 440
  return;
}
}
#line 444 "sshd.c"
void destroy_sensitive_data(void) 
{ int i ;

  {
#line 449
  if (sensitive_data.server_key) {
#line 450
    key_free(sensitive_data.server_key);
#line 451
    sensitive_data.server_key = (Key *)((void *)0);
  }
#line 453
  i = 0;
#line 453
  while (i < options.num_host_key_files) {
#line 454
    if (*(sensitive_data.host_keys + i)) {
#line 455
      key_free(*(sensitive_data.host_keys + i));
#line 456
      *(sensitive_data.host_keys + i) = (Key *)((void *)0);
    }
#line 453
    i ++;
  }
#line 459
  sensitive_data.ssh1_host_key = (Key *)((void *)0);
#line 460
  memset((void *)(sensitive_data.ssh1_cookie), 0, 32U);
#line 461
  return;
}
}
#line 466 "sshd.c"
static char buf[1024]  ;
#line 463 "sshd.c"
char *list_hostkey_types(void) 
{ int i ;
  Key *key ;
  char *tmp ;
  size_t tmp___0 ;

  {
#line 468
  buf[0] = (char )'\000';
#line 469
  i = 0;
#line 469
  while (i < options.num_host_key_files) {
#line 470
    key = *(sensitive_data.host_keys + i);
#line 471
    if ((unsigned int )key == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 473
    switch (key->type) {
    case 1: 
    case 2: 
#line 476
    tmp = key_ssh_name(key);
#line 476
    strlcat(buf, (char const   *)tmp, sizeof(buf));
#line 477
    strlcat(buf, ",", sizeof(buf));
#line 478
    break;
    }
    __Cont: /* CIL Label */ 
#line 469
    i ++;
  }
#line 481
  tmp___0 = strlen((char const   *)(buf));
#line 481
  i = (int )tmp___0;
#line 482
  if (i > 0) {
#line 482
    if ((int )buf[i - 1] == 44) {
#line 483
      buf[i - 1] = (char )'\000';
    }
  }
#line 484
  debug("list_hostkey_types: %s", buf);
#line 485
  return (buf);
}
}
#line 488 "sshd.c"
Key *get_hostkey_by_type(int type ) 
{ int i ;
  Key *key ;

  {
#line 492
  i = 0;
#line 492
  while (i < options.num_host_key_files) {
#line 493
    key = *(sensitive_data.host_keys + i);
#line 494
    if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 494
      if (key->type == type) {
#line 495
        return (key);
      }
    }
#line 492
    i ++;
  }
#line 497
  return ((Key *)((void *)0));
}
}
#line 506 "sshd.c"
int drop_connection(int startups ) 
{ double p ;
  double r ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 511
  if (startups < options.max_startups_begin) {
#line 512
    return (0);
  }
#line 513
  if (startups >= options.max_startups) {
#line 514
    return (1);
  }
#line 515
  if (options.max_startups_rate == 100) {
#line 516
    return (1);
  }
#line 518
  p = (double )(100 - options.max_startups_rate);
#line 519
  p *= (double )(startups - options.max_startups_begin);
#line 520
  p /= (double )(options.max_startups - options.max_startups_begin);
#line 521
  p += (double )options.max_startups_rate;
#line 522
  p /= 100.0;
#line 523
  tmp = arc4random();
#line 523
  r = (double )tmp / (double )4294967295U;
#line 525
  debug("drop_connection: p %g, r %g", p, r);
#line 526
  if (r < p) {
#line 526
    tmp___0 = 1;
  } else {
#line 526
    tmp___0 = 0;
  }
#line 526
  return (tmp___0);
}
}
#line 529 "sshd.c"
int *startup_pipes  =    (int *)((void *)0);
#line 530 "sshd.c"
int startup_pipe  ;
#line 535 "sshd.c"
int main(int ac , char **av ) 
{ int opt ;
  int sock_in ;
  int sock_out ;
  int newsock ;
  int j ;
  int i ;
  int fdsetsz ;
  int on ;
  pid_t pid ;
  socklen_t fromlen ;
  fd_set *fdset ;
  struct sockaddr_storage from ;
  char const   *remote_ip ;
  int remote_port ;
  FILE *f ;
  struct linger linger ;
  struct addrinfo *ai ;
  char ntop[1025] ;
  char strport[32] ;
  int listen_sock ;
  int maxfd ;
  int startup_p[2] ;
  int startups ;
  Key *key ;
  int ret ;
  int key_used ;
  u_int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int fd ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int s1 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  __pid_t tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  int *tmp___30 ;
  register char __result ;
  register char __result___0 ;
  int *tmp___31 ;
  char *tmp___32 ;
  int *tmp___33 ;
  int *tmp___34 ;
  int *tmp___35 ;
  char *tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int *tmp___40 ;
  char *tmp___41 ;
  int *tmp___42 ;
  char *tmp___43 ;
  int tmp___44 ;

  {
#line 540
  sock_in = 0;
#line 540
  sock_out = 0;
#line 540
  on = 1;
#line 553
  startups = 0;
#line 555
  key_used = 0;
#line 557
  __progname = get_progname(*(av + 0));
#line 558
  init_rng();
#line 561
  saved_argc = ac;
#line 562
  saved_argv = av;
#line 565
  initialize_server_options(& options);
#line 568
  while (1) {
#line 568
    opt = getopt(ac, (char * const  *)av, "f:p:b:k:h:g:V:u:dDeiqQ46");
#line 568
    if (! (opt != -1)) {
#line 568
      break;
    }
#line 569
    switch (opt) {
    case 52: 
#line 571
    IPv4or6 = 2;
#line 572
    break;
    case 54: 
#line 574
    IPv4or6 = 10;
#line 575
    break;
    case 102: 
#line 577
    config_file_name = optarg;
#line 578
    break;
    case 100: 
#line 580
    if (0 == debug_flag) {
#line 581
      debug_flag = 1;
#line 582
      options.log_level = 5;
    } else {
#line 583
      if ((int )options.log_level < 7) {
#line 584
        options.log_level = (LogLevel )((int )options.log_level + 1);
      } else {
#line 586
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Too high debugging level.\n");
#line 587
        exit(1);
      }
    }
#line 589
    break;
    case 68: 
#line 591
    no_daemon_flag = 1;
#line 592
    break;
    case 101: 
#line 594
    log_stderr = 1;
#line 595
    break;
    case 105: 
#line 597
    inetd_flag = 1;
#line 598
    break;
    case 81: 
#line 601
    break;
    case 113: 
#line 603
    options.log_level = 0;
#line 604
    break;
    case 98: 
#line 606
    options.server_key_bits = atoi((char const   *)optarg);
#line 607
    break;
    case 112: 
#line 609
    options.ports_from_cmdline = 1U;
#line 610
    if (options.num_ports >= 256U) {
#line 611
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"too many ports.\n");
#line 612
      exit(1);
    }
#line 614
    tmp = options.num_ports;
#line 614
    (options.num_ports) ++;
#line 614
    tmp___0 = a2port((char const   *)optarg);
#line 614
    options.ports[tmp] = (unsigned short )tmp___0;
#line 615
    if ((int )options.ports[options.num_ports - 1U] == 0) {
#line 616
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad port number.\n");
#line 617
      exit(1);
    }
#line 619
    break;
    case 103: 
#line 621
    options.login_grace_time = atoi((char const   *)optarg);
#line 622
    break;
    case 107: 
#line 624
    options.key_regeneration_time = atoi((char const   *)optarg);
#line 625
    break;
    case 104: 
#line 627
    if (options.num_host_key_files >= 256) {
#line 628
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"too many host keys.\n");
#line 629
      exit(1);
    }
#line 631
    tmp___1 = options.num_host_key_files;
#line 631
    (options.num_host_key_files) ++;
#line 631
    options.host_key_files[tmp___1] = optarg;
#line 632
    break;
    case 86: 
#line 634
    client_version_string = optarg;
#line 636
    inetd_flag = 1;
#line 637
    break;
    case 117: 
#line 639
    tmp___2 = atoi((char const   *)optarg);
#line 639
    utmp_len = (unsigned int )tmp___2;
#line 640
    break;
    case 63: 
    default: 
#line 643
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"sshd version %s\n",
            "OpenSSH_2.9p1");
#line 644
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: %s [options]\n",
            __progname);
#line 645
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Options:\n");
#line 646
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -f file    Configuration file (default %s)\n",
            "/usr/local/etc/sshd_config");
#line 647
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -d         Debugging mode (multiple -d means more debugging)\n");
#line 648
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -i         Started from inetd\n");
#line 649
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -D         Do not fork into daemon mode\n");
#line 650
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -q         Quiet (no logging)\n");
#line 651
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -p port    Listen on the specified port (default: 22)\n");
#line 652
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -k seconds Regenerate server key every this many seconds (default: 3600)\n");
#line 653
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -g seconds Grace period for authentication (default: 600)\n");
#line 654
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -b bits    Size of server RSA key (default: 768 bits)\n");
#line 655
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -h file    File from which to read host key (default: %s)\n",
            "/usr/local/etc/ssh_host_key");
#line 657
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -u len     Maximum hostname length for utmp recording\n");
#line 658
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -4         Use IPv4 only\n");
#line 659
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -6         Use IPv6 only\n");
#line 660
    exit(1);
    }
  }
#line 663
  OPENSSL_add_all_algorithms_noconf();
#line 669
  if ((int )options.log_facility == -1) {
#line 669
    tmp___3 = 2;
  } else {
#line 669
    tmp___3 = (int )options.log_facility;
  }
#line 669
  if ((int )options.log_level == -1) {
#line 669
    tmp___4 = 3;
  } else {
#line 669
    tmp___4 = (int )options.log_level;
  }
#line 669
  log_init(__progname, (enum __anonenum_LogLevel_64 )tmp___4, (enum __anonenum_SyslogFacility_63 )tmp___3,
           ! inetd_flag);
#line 674
  seed_rng();
#line 677
  read_server_config(& options, (char const   *)config_file_name);
#line 680
  fill_default_server_options(& options);
#line 683
  if (optind < ac) {
#line 684
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Extra argument %s.\n",
            *(av + optind));
#line 685
    exit(1);
  }
#line 688
  debug("sshd version %.100s", "OpenSSH_2.9p1");
#line 691
  tmp___5 = xmalloc((unsigned int )options.num_host_key_files * sizeof(Key *));
#line 691
  sensitive_data.host_keys = (Key **)tmp___5;
#line 692
  i = 0;
#line 692
  while (i < options.num_host_key_files) {
#line 693
    *(sensitive_data.host_keys + i) = (Key *)((void *)0);
#line 692
    i ++;
  }
#line 694
  sensitive_data.server_key = (Key *)((void *)0);
#line 695
  sensitive_data.ssh1_host_key = (Key *)((void *)0);
#line 696
  sensitive_data.have_ssh1_key = 0;
#line 697
  sensitive_data.have_ssh2_key = 0;
#line 699
  i = 0;
#line 699
  while (i < options.num_host_key_files) {
#line 700
    key = key_load_private((char const   *)options.host_key_files[i], "", (char **)((void *)0));
#line 701
    *(sensitive_data.host_keys + i) = key;
#line 702
    if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 703
      error("Could not load host key: %s", options.host_key_files[i]);
#line 705
      *(sensitive_data.host_keys + i) = (Key *)((void *)0);
      goto __Cont;
    }
#line 708
    switch (key->type) {
    case 0: 
#line 710
    sensitive_data.ssh1_host_key = key;
#line 711
    sensitive_data.have_ssh1_key = 1;
#line 712
    break;
    case 1: 
    case 2: 
#line 715
    sensitive_data.have_ssh2_key = 1;
#line 716
    break;
    }
#line 718
    tmp___6 = key_type(key);
#line 718
    debug("private host key: #%d type %d %s", i, key->type, tmp___6);
    __Cont: /* CIL Label */ 
#line 699
    i ++;
  }
#line 721
  if (options.protocol & 1) {
#line 721
    if (! sensitive_data.have_ssh1_key) {
#line 722
      log("Disabling protocol version 1. Could not load host key");
#line 723
      options.protocol &= -2;
    }
  }
#line 725
  if (options.protocol & 4) {
#line 725
    if (! sensitive_data.have_ssh2_key) {
#line 726
      log("Disabling protocol version 2. Could not load host key");
#line 727
      options.protocol &= -5;
    }
  }
#line 729
  if (! (options.protocol & 5)) {
#line 730
    log("sshd: no hostkeys available -- exiting.");
#line 731
    exit(1);
  }
#line 735
  if (options.protocol & 1) {
#line 736
    if (options.server_key_bits < 512) {
#line 738
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 739
      exit(1);
    } else {
#line 736
      if (options.server_key_bits > 32768) {
#line 738
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 739
        exit(1);
      }
    }
#line 746
    tmp___8 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 746
    if (options.server_key_bits > tmp___8 - 128) {
#line 746
      tmp___9 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 746
      if (options.server_key_bits < tmp___9 + 128) {
#line 750
        tmp___7 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 750
        options.server_key_bits = tmp___7 + 128;
#line 752
        debug("Forcing server key to %d bits to make it differ from host key.", options.server_key_bits);
      }
    }
  }
#line 762
  if (debug_flag) {
#line 762
    if (! inetd_flag) {
#line 763
      log_stderr = 1;
    }
  }
#line 764
  log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 771
  if (! debug_flag) {
#line 771
    if (! inetd_flag) {
#line 771
      if (! no_daemon_flag) {
#line 775
        tmp___12 = daemon(0, 0);
#line 775
        if (tmp___12 < 0) {
#line 776
          tmp___10 = __errno_location();
#line 776
          tmp___11 = strerror(*tmp___10);
#line 776
          fatal("daemon() failed: %.200s", tmp___11);
        }
#line 780
        fd = open("/dev/tty", 258);
#line 781
        if (fd >= 0) {
#line 782
          ioctl(fd, 21538UL, (void *)0);
#line 783
          close(fd);
        }
      }
    }
  }
#line 788
  log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 791
  arc4random_stir();
#line 795
  chdir("/");
#line 798
  signal(13, (void (*)(int  ))1);
#line 801
  if (inetd_flag) {
#line 803
    s1 = dup(0);
#line 804
    dup(s1);
#line 805
    sock_in = dup(0);
#line 806
    sock_out = dup(1);
#line 807
    startup_pipe = -1;
#line 813
    debug("inetd sockets after dupping: %d, %d", sock_in, sock_out);
#line 814
    if (options.protocol & 1) {
#line 815
      generate_ephemeral_server_key();
    }
  } else {
#line 817
    ai = options.listen_addrs;
#line 817
    while (ai) {
#line 818
      if (ai->ai_family != 2) {
#line 818
        if (ai->ai_family != 10) {
          goto __Cont___0;
        }
      }
#line 820
      if (num_listen_socks >= 16) {
#line 821
        fatal("Too many listen sockets. Enlarge MAX_LISTEN_SOCKS");
      }
#line 823
      tmp___13 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr,
                             ai->ai_addrlen, (char * __restrict  )(ntop), sizeof(ntop),
                             (char * __restrict  )(strport), sizeof(strport), 3U);
#line 823
      if (tmp___13 != 0) {
#line 826
        error("getnameinfo failed");
        goto __Cont___0;
      }
#line 830
      listen_sock = socket(ai->ai_family, 1, 0);
#line 831
      if (listen_sock < 0) {
#line 833
        tmp___14 = __errno_location();
#line 833
        tmp___15 = strerror(*tmp___14);
#line 833
        verbose("socket: %.100s", tmp___15);
        goto __Cont___0;
      }
#line 836
      tmp___18 = fcntl(listen_sock, 4, 2048);
#line 836
      if (tmp___18 < 0) {
#line 837
        tmp___16 = __errno_location();
#line 837
        tmp___17 = strerror(*tmp___16);
#line 837
        error("listen_sock O_NONBLOCK: %s", tmp___17);
#line 838
        close(listen_sock);
        goto __Cont___0;
      }
#line 847
      setsockopt(listen_sock, 1, 2, (void const   *)((void *)(& on)), sizeof(on));
#line 849
      linger.l_onoff = 1;
#line 850
      linger.l_linger = 5;
#line 851
      setsockopt(listen_sock, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 854
      debug("Bind to port %s on %s.", strport, ntop);
#line 857
      tmp___21 = bind(listen_sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 857
      if (tmp___21 < 0) {
#line 858
        if (! ai->ai_next) {
#line 859
          tmp___19 = __errno_location();
#line 859
          tmp___20 = strerror(*tmp___19);
#line 859
          error("Bind to port %s on %s failed: %.200s.", strport, ntop, tmp___20);
        }
#line 861
        close(listen_sock);
        goto __Cont___0;
      }
#line 864
      listen_socks[num_listen_socks] = listen_sock;
#line 865
      num_listen_socks ++;
#line 868
      log("Server listening on %s port %s.", ntop, strport);
#line 869
      tmp___24 = listen(listen_sock, 5);
#line 869
      if (tmp___24 < 0) {
#line 870
        tmp___22 = __errno_location();
#line 870
        tmp___23 = strerror(*tmp___22);
#line 870
        fatal("listen: %.100s", tmp___23);
      }
      __Cont___0: /* CIL Label */ 
#line 817
      ai = ai->ai_next;
    }
#line 873
    freeaddrinfo(options.listen_addrs);
#line 875
    if (! num_listen_socks) {
#line 876
      fatal("Cannot bind any address.");
    }
#line 878
    if (! debug_flag) {
#line 886
      f = fopen((char const   * __restrict  )options.pid_file, (char const   * __restrict  )"wb");
#line 887
      if (f) {
#line 888
        tmp___25 = getpid();
#line 888
        fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%u\n", (unsigned int )tmp___25);
#line 889
        fclose(f);
      }
    }
#line 892
    if (options.protocol & 1) {
#line 893
      generate_ephemeral_server_key();
    }
#line 896
    signal(1, & sighup_handler);
#line 898
    signal(15, & sigterm_handler);
#line 899
    signal(3, & sigterm_handler);
#line 902
    signal(17, & main_sigchld_handler);
#line 905
    fdset = (fd_set *)((void *)0);
#line 906
    maxfd = 0;
#line 907
    i = 0;
#line 907
    while (i < num_listen_socks) {
#line 908
      if (listen_socks[i] > maxfd) {
#line 909
        maxfd = listen_socks[i];
      }
#line 907
      i ++;
    }
#line 911
    tmp___26 = xmalloc((unsigned int )options.max_startups * sizeof(int ));
#line 911
    startup_pipes = (int *)tmp___26;
#line 912
    i = 0;
#line 912
    while (i < options.max_startups) {
#line 913
      *(startup_pipes + i) = -1;
#line 912
      i ++;
    }
#line 919
    while (1) {
#line 920
      if (received_sighup) {
#line 921
        sighup_restart();
      }
#line 922
      if ((unsigned int )fdset != (unsigned int )((void *)0)) {
#line 923
        xfree((void *)fdset);
      }
#line 924
      fdsetsz = (int )((((unsigned int )(maxfd + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 925
      tmp___27 = xmalloc((unsigned int )fdsetsz);
#line 925
      fdset = (fd_set *)tmp___27;
#line 926
      memset((void *)fdset, 0, (unsigned int )fdsetsz);
#line 928
      i = 0;
#line 928
      while (i < num_listen_socks) {
#line 929
        __asm__  volatile   ("btsl %1,%0": "=m" (fdset->__fds_bits[(unsigned int )listen_socks[i] / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )listen_socks[i] % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
#line 928
        i ++;
      }
#line 930
      i = 0;
#line 930
      while (i < options.max_startups) {
#line 931
        if (*(startup_pipes + i) != -1) {
#line 932
          __asm__  volatile   ("btsl %1,%0": "=m" (fdset->__fds_bits[(unsigned int )*(startup_pipes + i) / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )*(startup_pipes + i) % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        }
#line 930
        i ++;
      }
#line 935
      ret = select(maxfd + 1, (fd_set * __restrict  )fdset, (fd_set * __restrict  )((void *)0),
                   (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 936
      if (ret < 0) {
#line 936
        tmp___30 = __errno_location();
#line 936
        if (*tmp___30 != 4) {
#line 937
          tmp___28 = __errno_location();
#line 937
          tmp___29 = strerror(*tmp___28);
#line 937
          error("select: %.100s", tmp___29);
        }
      }
#line 938
      if (key_used) {
#line 938
        if (key_do_regen) {
#line 939
          generate_ephemeral_server_key();
#line 940
          key_used = 0;
#line 941
          key_do_regen = 0;
        }
      }
#line 943
      if (ret < 0) {
        goto __Cont___1;
      }
#line 946
      i = 0;
#line 946
      while (i < options.max_startups) {
#line 948
        if (*(startup_pipes + i) != -1) {
#line 948
          __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )*(startup_pipes + i) % (8U * sizeof(__fd_mask ))),
                               "m" (fdset->__fds_bits[(unsigned int )*(startup_pipes + i) / (8U * sizeof(__fd_mask ))]): "cc");
#line 948
          if (__result) {
#line 955
            close(*(startup_pipes + i));
#line 956
            *(startup_pipes + i) = -1;
#line 957
            startups --;
          }
        }
#line 946
        i ++;
      }
#line 959
      i = 0;
#line 959
      while (i < num_listen_socks) {
#line 960
        __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )listen_socks[i] % (8U * sizeof(__fd_mask ))),
                             "m" (fdset->__fds_bits[(unsigned int )listen_socks[i] / (8U * sizeof(__fd_mask ))]): "cc");
#line 960
        if (! __result___0) {
          goto __Cont___2;
        }
#line 962
        fromlen = sizeof(from);
#line 963
        newsock = accept(listen_socks[i], (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                         (socklen_t * __restrict  )(& fromlen));
#line 965
        if (newsock < 0) {
#line 966
          tmp___33 = __errno_location();
#line 966
          if (*tmp___33 != 4) {
#line 966
            tmp___34 = __errno_location();
#line 966
            if (*tmp___34 != 11) {
#line 967
              tmp___31 = __errno_location();
#line 967
              tmp___32 = strerror(*tmp___31);
#line 967
              error("accept: %.100s", tmp___32);
            }
          }
          goto __Cont___2;
        }
#line 970
        tmp___37 = fcntl(newsock, 4, 0);
#line 970
        if (tmp___37 < 0) {
#line 971
          tmp___35 = __errno_location();
#line 971
          tmp___36 = strerror(*tmp___35);
#line 971
          error("newsock del O_NONBLOCK: %s", tmp___36);
          goto __Cont___2;
        }
#line 974
        tmp___38 = drop_connection(startups);
#line 974
        if (tmp___38 == 1) {
#line 975
          debug("drop connection #%d", startups);
#line 976
          close(newsock);
          goto __Cont___2;
        }
#line 979
        tmp___39 = pipe((int *)(startup_p));
#line 979
        if (tmp___39 == -1) {
#line 980
          close(newsock);
          goto __Cont___2;
        }
#line 984
        j = 0;
#line 984
        while (j < options.max_startups) {
#line 985
          if (*(startup_pipes + j) == -1) {
#line 986
            *(startup_pipes + j) = startup_p[0];
#line 987
            if (maxfd < startup_p[0]) {
#line 988
              maxfd = startup_p[0];
            }
#line 989
            startups ++;
#line 990
            break;
          }
#line 984
          j ++;
        }
#line 997
        if (debug_flag) {
#line 1003
          debug("Server will not fork when running in debugging mode.");
#line 1004
          close_listen_socks();
#line 1005
          sock_in = newsock;
#line 1006
          sock_out = newsock;
#line 1007
          startup_pipe = -1;
#line 1008
          pid = getpid();
#line 1009
          break;
        } else {
#line 1016
          pid = fork();
#line 1016
          if (pid == 0) {
#line 1024
            startup_pipe = startup_p[1];
#line 1025
            j = 0;
#line 1025
            while (j < options.max_startups) {
#line 1026
              if (*(startup_pipes + j) != -1) {
#line 1027
                close(*(startup_pipes + j));
              }
#line 1025
              j ++;
            }
#line 1028
            close_listen_socks();
#line 1029
            sock_in = newsock;
#line 1030
            sock_out = newsock;
#line 1031
            log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 1032
            break;
          }
        }
#line 1037
        if (pid < 0) {
#line 1038
          tmp___40 = __errno_location();
#line 1038
          tmp___41 = strerror(*tmp___40);
#line 1038
          error("fork: %.100s", tmp___41);
        } else {
#line 1040
          debug("Forked child %d.", pid);
        }
#line 1042
        close(startup_p[1]);
#line 1045
        if (options.protocol & 1) {
#line 1045
          if (key_used == 0) {
#line 1048
            signal(14, & key_regeneration_alarm);
#line 1049
            alarm((unsigned int )options.key_regeneration_time);
#line 1050
            key_used = 1;
          }
        }
#line 1053
        arc4random_stir();
#line 1056
        close(newsock);
        __Cont___2: /* CIL Label */ 
#line 959
        i ++;
      }
#line 1059
      if (num_listen_socks < 0) {
#line 1060
        break;
      }
      __Cont___1: /* CIL Label */ ;
    }
  }
#line 1071
  alarm(0U);
#line 1072
  signal(14, (void (*)(int  ))0);
#line 1073
  signal(1, (void (*)(int  ))0);
#line 1074
  signal(15, (void (*)(int  ))0);
#line 1075
  signal(3, (void (*)(int  ))0);
#line 1076
  signal(17, (void (*)(int  ))0);
#line 1077
  signal(2, (void (*)(int  ))0);
#line 1085
  linger.l_onoff = 1;
#line 1086
  linger.l_linger = 5;
#line 1087
  setsockopt(sock_in, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 1090
  if (options.keepalives) {
#line 1090
    tmp___44 = setsockopt(sock_in, 1, 9, (void const   *)((void *)(& on)), sizeof(on));
#line 1090
    if (tmp___44 < 0) {
#line 1093
      tmp___42 = __errno_location();
#line 1093
      tmp___43 = strerror(*tmp___42);
#line 1093
      error("setsockopt SO_KEEPALIVE: %.100s", tmp___43);
    }
  }
#line 1099
  packet_set_connection(sock_in, sock_out);
#line 1101
  remote_port = get_remote_port();
#line 1102
  remote_ip = get_remote_ipaddr();
#line 1122
  verbose("Connection from %.500s port %d", remote_ip, remote_port);
#line 1132
  signal(14, & grace_alarm_handler);
#line 1133
  if (! debug_flag) {
#line 1134
    alarm((unsigned int )options.login_grace_time);
  }
#line 1136
  sshd_exchange_identification(sock_in, sock_out);
#line 1144
  if (remote_port >= 1024) {
#line 1146
    debug("Rhosts Authentication disabled, originating port not trusted.");
#line 1148
    options.rhosts_authentication = 0;
  } else {
#line 1144
    if (remote_port < 512) {
#line 1146
      debug("Rhosts Authentication disabled, originating port not trusted.");
#line 1148
      options.rhosts_authentication = 0;
    }
  }
#line 1165
  packet_set_nonblocking();
#line 1169
  if (compat20) {
#line 1170
    do_ssh2_kex();
#line 1171
    do_authentication2();
  } else {
#line 1173
    do_ssh1_kex();
#line 1174
    do_authentication();
  }
#line 1184
  verbose("Closing connection to %.100s", remote_ip);
#line 1190
  packet_close();
#line 1191
  exit(0);
}
}
#line 1197 "sshd.c"
void do_ssh1_kex(void) 
{ int i ;
  int len ;
  int plen ;
  int slen ;
  int rsafail ;
  BIGNUM *session_key_int ;
  u_char session_key[32] ;
  u_char cookie[8] ;
  u_int cipher_type___0 ;
  u_int auth_mask ;
  u_int protocol_flags ;
  u_int32_t rand___0 ;
  int tmp ;
  int tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  char *tmp___6 ;
  int _p ;
  int _e ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char const   *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  char const   *tmp___23 ;
  int bytes ;
  int tmp___24 ;
  char *buf___2 ;
  void *tmp___25 ;
  MD5_CTX md ;

  {
#line 1202
  rsafail = 0;
#line 1207
  rand___0 = (u_int32_t )0;
#line 1218
  i = 0;
#line 1218
  while (i < 8) {
#line 1219
    if (i % 4 == 0) {
#line 1220
      rand___0 = arc4random();
    }
#line 1221
    cookie[i] = (unsigned char )(rand___0 & 255U);
#line 1222
    rand___0 >>= 8;
#line 1218
    i ++;
  }
#line 1230
  packet_start(2);
#line 1231
  i = 0;
#line 1231
  while (i < 8) {
#line 1232
    packet_put_char((int )cookie[i]);
#line 1231
    i ++;
  }
#line 1235
  tmp = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1235
  packet_put_int((unsigned int )tmp);
#line 1236
  packet_put_bignum(((sensitive_data.server_key)->rsa)->e);
#line 1237
  packet_put_bignum(((sensitive_data.server_key)->rsa)->n);
#line 1240
  tmp___0 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1240
  packet_put_int((unsigned int )tmp___0);
#line 1241
  packet_put_bignum(((sensitive_data.ssh1_host_key)->rsa)->e);
#line 1242
  packet_put_bignum(((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1245
  packet_put_int(2U);
#line 1248
  tmp___1 = cipher_mask_ssh1(0);
#line 1248
  packet_put_int(tmp___1);
#line 1251
  auth_mask = 0U;
#line 1252
  if (options.rhosts_authentication) {
#line 1253
    auth_mask |= (unsigned int )(1 << 1);
  }
#line 1254
  if (options.rhosts_rsa_authentication) {
#line 1255
    auth_mask |= (unsigned int )(1 << 4);
  }
#line 1256
  if (options.rsa_authentication) {
#line 1257
    auth_mask |= (unsigned int )(1 << 2);
  }
#line 1268
  if (options.challenge_reponse_authentication == 1) {
#line 1269
    auth_mask |= (unsigned int )(1 << 5);
  }
#line 1270
  if (options.password_authentication) {
#line 1271
    auth_mask |= (unsigned int )(1 << 3);
  }
#line 1272
  packet_put_int(auth_mask);
#line 1275
  packet_send();
#line 1276
  packet_write_wait();
#line 1278
  tmp___2 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1278
  tmp___3 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1278
  debug("Sent %d bit server key and %d bit host key.", tmp___3, tmp___2);
#line 1283
  packet_read_expect(& plen, 3);
#line 1286
  cipher_type___0 = packet_get_char();
#line 1288
  tmp___4 = cipher_mask_ssh1(0);
#line 1288
  if (! (tmp___4 & (unsigned int )(1 << cipher_type___0))) {
#line 1289
    packet_disconnect("Warning: client selects unsupported cipher.");
  }
#line 1293
  i = 0;
#line 1293
  while (i < 8) {
#line 1294
    tmp___5 = packet_get_char();
#line 1294
    if ((u_int )cookie[i] != tmp___5) {
#line 1295
      packet_disconnect("IP Spoofing check bytes do not match.");
    }
#line 1293
    i ++;
  }
#line 1297
  tmp___6 = cipher_name((int )cipher_type___0);
#line 1297
  debug("Encryption type: %.200s", tmp___6);
#line 1300
  session_key_int = BN_new();
#line 1301
  packet_get_bignum(session_key_int, & slen);
#line 1303
  protocol_flags = packet_get_int();
#line 1304
  packet_set_protocol_flags(protocol_flags);
#line 1306
  while (1) {
#line 1306
    _p = plen;
#line 1306
    _e = (9 + slen) + 4;
#line 1306
    if (_p != _e) {
#line 1306
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "sshd.c", 1306);
#line 1306
      packet_disconnect("Packet integrity error. (%d)", 3);
    }
#line 1306
    break;
  }
#line 1312
  tmp___21 = BN_cmp((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n, (BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1312
  if (tmp___21 > 0) {
#line 1314
    tmp___10 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1314
    tmp___11 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1314
    if (tmp___10 < tmp___11 + 128) {
#line 1316
      tmp___7 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1316
      tmp___8 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1316
      tmp___9 = get_remote_ipaddr();
#line 1316
      fatal("do_connection: %s: server_key %d < host_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___9, tmp___8, tmp___7, 128);
    }
#line 1322
    tmp___12 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.server_key)->rsa);
#line 1322
    if (tmp___12 <= 0) {
#line 1324
      rsafail ++;
    }
#line 1325
    tmp___13 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.ssh1_host_key)->rsa);
#line 1325
    if (tmp___13 <= 0) {
#line 1327
      rsafail ++;
    }
  } else {
#line 1330
    tmp___17 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1330
    tmp___18 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1330
    if (tmp___17 < tmp___18 + 128) {
#line 1332
      tmp___14 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1332
      tmp___15 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1332
      tmp___16 = get_remote_ipaddr();
#line 1332
      fatal("do_connection: %s: host_key %d < server_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___16, tmp___15, tmp___14, 128);
    }
#line 1338
    tmp___19 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.ssh1_host_key)->rsa);
#line 1338
    if (tmp___19 < 0) {
#line 1340
      rsafail ++;
    }
#line 1341
    tmp___20 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.server_key)->rsa);
#line 1341
    if (tmp___20 < 0) {
#line 1343
      rsafail ++;
    }
  }
#line 1350
  if (! rsafail) {
#line 1351
    BN_mask_bits(session_key_int, (int )(sizeof(session_key) * 8U));
#line 1352
    tmp___22 = BN_num_bits((BIGNUM const   *)session_key_int);
#line 1352
    len = (tmp___22 + 7) / 8;
#line 1353
    if (len < 0) {
#line 1354
      tmp___23 = get_remote_ipaddr();
#line 1354
      error("do_connection: bad session key len from %s: session_key_int %d > sizeof(session_key) %lu",
            tmp___23, len, (unsigned long )sizeof(session_key));
#line 1357
      rsafail ++;
    } else {
#line 1353
      if ((unsigned int )len > sizeof(session_key)) {
#line 1354
        tmp___23 = get_remote_ipaddr();
#line 1354
        error("do_connection: bad session key len from %s: session_key_int %d > sizeof(session_key) %lu",
              tmp___23, len, (unsigned long )sizeof(session_key));
#line 1357
        rsafail ++;
      } else {
#line 1359
        memset((void *)(session_key), 0, sizeof(session_key));
#line 1360
        BN_bn2bin((BIGNUM const   *)session_key_int, (session_key + sizeof(session_key)) - len);
#line 1363
        compute_session_id((u_char *)(session_id), (u_char *)(cookie), ((sensitive_data.ssh1_host_key)->rsa)->n,
                           ((sensitive_data.server_key)->rsa)->n);
#line 1370
        i = 0;
#line 1370
        while (i < 16) {
#line 1371
          session_key[i] = (unsigned char )((int )session_key[i] ^ (int )session_id[i]);
#line 1370
          i ++;
        }
      }
    }
  }
#line 1374
  if (rsafail) {
#line 1375
    tmp___24 = BN_num_bits((BIGNUM const   *)session_key_int);
#line 1375
    bytes = (tmp___24 + 7) / 8;
#line 1376
    tmp___25 = xmalloc((unsigned int )bytes);
#line 1376
    buf___2 = (char *)tmp___25;
#line 1379
    log("do_connection: generating a fake encryption key");
#line 1380
    BN_bn2bin((BIGNUM const   *)session_key_int, (unsigned char *)buf___2);
#line 1381
    MD5_Init(& md);
#line 1382
    MD5_Update(& md, (void const   *)buf___2, (unsigned int )bytes);
#line 1383
    MD5_Update(& md, (void const   *)(sensitive_data.ssh1_cookie), 32U);
#line 1384
    MD5_Final(session_key, & md);
#line 1385
    MD5_Init(& md);
#line 1386
    MD5_Update(& md, (void const   *)(session_key), 16U);
#line 1387
    MD5_Update(& md, (void const   *)buf___2, (unsigned int )bytes);
#line 1388
    MD5_Update(& md, (void const   *)(sensitive_data.ssh1_cookie), 32U);
#line 1389
    MD5_Final(session_key + 16, & md);
#line 1390
    memset((void *)buf___2, 0, (unsigned int )bytes);
#line 1391
    xfree((void *)buf___2);
#line 1392
    i = 0;
#line 1392
    while (i < 16) {
#line 1393
      session_id[i] = (unsigned char )((int )session_key[i] ^ (int )session_key[i + 16]);
#line 1392
      i ++;
    }
  }
#line 1396
  destroy_sensitive_data();
#line 1399
  BN_clear_free(session_key_int);
#line 1402
  packet_set_encryption_key((u_char const   *)(session_key), 32U, (int )cipher_type___0);
#line 1405
  memset((void *)(session_key), 0, sizeof(session_key));
#line 1407
  debug("Received session key; encryption turned on.");
#line 1410
  packet_start(14);
#line 1411
  packet_send();
#line 1412
  packet_write_wait();
#line 1413
  return;
}
}
#line 1418 "sshd.c"
void do_ssh2_kex(void) 
{ Kex *kex ;

  {
#line 1423
  if ((unsigned int )options.ciphers != (unsigned int )((void *)0)) {
#line 1424
    myproposal[3] = options.ciphers;
#line 1424
    myproposal[2] = myproposal[3];
  }
#line 1427
  myproposal[2] = compat_cipher_proposal(myproposal[2]);
#line 1429
  myproposal[3] = compat_cipher_proposal(myproposal[3]);
#line 1432
  if ((unsigned int )options.macs != (unsigned int )((void *)0)) {
#line 1433
    myproposal[5] = options.macs;
#line 1433
    myproposal[4] = myproposal[5];
  }
#line 1436
  myproposal[1] = list_hostkey_types();
#line 1439
  kex = kex_setup((char **)(myproposal));
#line 1440
  kex->server = 1;
#line 1441
  kex->client_version_string = client_version_string;
#line 1442
  kex->server_version_string = server_version_string;
#line 1443
  kex->load_host_key = & get_hostkey_by_type;
#line 1445
  xxx_kex = kex;
#line 1447
  dispatch_run(0, & kex->done, (void *)kex);
#line 1449
  session_id2 = kex->session_id;
#line 1450
  session_id2_len = kex->session_id_len;
#line 1459
  debug("KEX done");
#line 1460
  return;
}
}
#line 1 "auth.o"
#pragma merger(0,"./auth.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 187 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 87 "/usr/include/shadow.h"
extern struct spwd *getspnam(char const   *__name ) ;
#line 36 "groupaccess.h"
int ga_init(char const   *user , gid_t base ) ;
#line 42
int ga_match(char * const  *groups , int n___0 ) ;
#line 47
void ga_free(void) ;
#line 127 "auth.h"
Authctxt *authctxt_new(void) ;
#line 128
void auth_log(Authctxt *authctxt , int authenticated , char *method , char *info ) ;
#line 130
int auth_root_allowed(char *method ) ;
#line 134
int allowed_user(struct passwd *pw ) ;
#line 30 "auth-options.h"
char *forced_command ;
#line 56 "auth.c"
int allowed_user(struct passwd *pw ) 
{ struct stat st ;
  char *shell ;
  int i ;
  struct spwd *spw ;
  int days ;
  time_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 70
  if (! pw) {
#line 71
    return (0);
  } else {
#line 70
    if (! pw->pw_name) {
#line 71
      return (0);
    }
  }
#line 73
  spw = getspnam((char const   *)pw->pw_name);
#line 74
  if ((unsigned int )spw != (unsigned int )((void *)0)) {
#line 75
    tmp = time((time_t *)((void *)0));
#line 75
    days = (int )(tmp / 86400L);
#line 78
    if (spw->sp_expire >= 0L) {
#line 78
      if ((long )days > spw->sp_expire) {
#line 79
        return (0);
      }
    }
#line 82
    if (spw->sp_lstchg >= 0L) {
#line 82
      if (spw->sp_max >= 0L) {
#line 82
        if ((long )days > spw->sp_lstchg + spw->sp_max) {
#line 84
          return (0);
        }
      }
    }
  }
#line 96
  if ((int )*(pw->pw_shell + 0) == 0) {
#line 96
    shell = (char *)"/bin/sh";
  } else {
#line 96
    shell = pw->pw_shell;
  }
#line 99
  tmp___0 = stat((char const   * __restrict  )shell, (struct stat * __restrict  )(& st));
#line 99
  if (tmp___0 != 0) {
#line 100
    return (0);
  }
#line 101
  if (st.st_mode & 32768U) {
#line 101
    if (! (st.st_mode & (unsigned int )((((64 >> 3) >> 3) | 64) | (64 >> 3)))) {
#line 102
      return (0);
    }
  } else {
#line 102
    return (0);
  }
#line 105
  if (options.num_deny_users > 0U) {
#line 106
    i = 0;
#line 106
    while ((u_int )i < options.num_deny_users) {
#line 107
      tmp___1 = match_pattern((char const   *)pw->pw_name, (char const   *)options.deny_users[i]);
#line 107
      if (tmp___1) {
#line 108
        return (0);
      }
#line 106
      i ++;
    }
  }
#line 111
  if (options.num_allow_users > 0U) {
#line 112
    i = 0;
#line 112
    while ((u_int )i < options.num_allow_users) {
#line 113
      tmp___2 = match_pattern((char const   *)pw->pw_name, (char const   *)options.allow_users[i]);
#line 113
      if (tmp___2) {
#line 114
        break;
      }
#line 112
      i ++;
    }
#line 116
    if ((u_int )i >= options.num_allow_users) {
#line 117
      return (0);
    }
  }
#line 119
  if (options.num_deny_groups > 0U) {
    goto _L;
  } else {
#line 119
    if (options.num_allow_groups > 0U) {
      _L: /* CIL Label */ 
#line 121
      tmp___3 = ga_init((char const   *)pw->pw_name, pw->pw_gid);
#line 121
      if (tmp___3 == 0) {
#line 122
        return (0);
      }
#line 125
      if (options.num_deny_groups > 0U) {
#line 126
        tmp___4 = ga_match((char * const  *)(options.deny_groups), (int )options.num_deny_groups);
#line 126
        if (tmp___4) {
#line 128
          ga_free();
#line 129
          return (0);
        }
      }
#line 135
      if (options.num_allow_groups > 0U) {
#line 136
        tmp___5 = ga_match((char * const  *)(options.allow_groups), (int )options.num_allow_groups);
#line 136
        if (! tmp___5) {
#line 138
          ga_free();
#line 139
          return (0);
        }
      }
#line 141
      ga_free();
    }
  }
#line 162
  return (1);
}
}
#line 165 "auth.c"
Authctxt *authctxt_new(void) 
{ Authctxt *authctxt ;
  void *tmp ;

  {
#line 168
  tmp = xmalloc(sizeof(*authctxt));
#line 168
  authctxt = (Authctxt *)tmp;
#line 169
  memset((void *)authctxt, 0, sizeof(*authctxt));
#line 170
  return (authctxt);
}
}
#line 173 "auth.c"
void auth_log(Authctxt *authctxt , int authenticated , char *method , char *info ) 
{ void (*authlog)(char const   *fmt  , ...) ;
  char *authmsg ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;

  {
#line 176
  authlog = (void (*)(char const   *fmt  , ...))(& verbose);
#line 183
  if (authenticated == 1) {
#line 184
    authlog = (void (*)(char const   *fmt  , ...))(& log);
  } else {
#line 183
    if (! authctxt->valid) {
#line 184
      authlog = (void (*)(char const   *fmt  , ...))(& log);
    } else {
#line 183
      if (authctxt->failures >= 3) {
#line 184
        authlog = (void (*)(char const   *fmt  , ...))(& log);
      } else {
#line 183
        if (0) {
#line 183
          __s1_len = strlen((char const   *)method);
#line 183
          __s2_len = strlen("password");
#line 183
          if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
            goto _L___0;
          } else {
#line 183
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 183
              if (! ((unsigned int )((void const   *)("password" + 1)) - (unsigned int )((void const   *)"password") == 1U)) {
#line 183
                tmp___8 = 1;
              } else {
#line 183
                if (__s2_len >= 4U) {
#line 183
                  tmp___8 = 1;
                } else {
#line 183
                  tmp___8 = 0;
                }
              }
            } else {
#line 183
              tmp___8 = 0;
            }
          }
#line 183
          if (tmp___8) {
#line 183
            tmp___4 = __builtin_strcmp((char const   *)method, "password");
          } else {
#line 183
            tmp___7 = __builtin_strcmp((char const   *)method, "password");
#line 183
            tmp___4 = tmp___7;
          }
        } else {
#line 183
          tmp___7 = __builtin_strcmp((char const   *)method, "password");
#line 183
          tmp___4 = tmp___7;
        }
#line 183
        if (tmp___4 == 0) {
#line 184
          authlog = (void (*)(char const   *fmt  , ...))(& log);
        }
      }
    }
  }
#line 186
  if (authctxt->postponed) {
#line 187
    authmsg = (char *)"Postponed";
  } else {
#line 189
    if (authenticated) {
#line 189
      authmsg = (char *)"Accepted";
    } else {
#line 189
      authmsg = (char *)"Failed";
    }
  }
#line 191
  tmp___9 = get_remote_port();
#line 191
  tmp___10 = get_remote_ipaddr();
#line 191
  if (authctxt->valid) {
#line 191
    if ((authctxt->pw)->pw_uid == 0U) {
#line 191
      tmp___11 = "ROOT";
    } else {
#line 191
      tmp___11 = (char const   *)authctxt->user;
    }
  } else {
#line 191
    tmp___11 = (char const   *)authctxt->user;
  }
#line 191
  if (authctxt->valid) {
#line 191
    tmp___12 = "";
  } else {
#line 191
    tmp___12 = "illegal user ";
  }
#line 191
  (*authlog)("%s %s for %s%.100s from %.200s port %d%s", authmsg, method, tmp___12,
             tmp___11, tmp___10, tmp___9, info);
#line 199
  return;
}
}
#line 204 "auth.c"
int auth_root_allowed(char *method ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;

  {
#line 207
  switch (options.permit_root_login) {
  case 3: 
#line 209
  return (1);
#line 210
  break;
  case 2: 
#line 212
  if (0) {
#line 212
    __s1_len = strlen((char const   *)method);
#line 212
    __s2_len = strlen("password");
#line 212
    if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
      goto _L___0;
    } else {
#line 212
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 212
        if (! ((unsigned int )((void const   *)("password" + 1)) - (unsigned int )((void const   *)"password") == 1U)) {
#line 212
          tmp___8 = 1;
        } else {
#line 212
          if (__s2_len >= 4U) {
#line 212
            tmp___8 = 1;
          } else {
#line 212
            tmp___8 = 0;
          }
        }
      } else {
#line 212
        tmp___8 = 0;
      }
    }
#line 212
    if (tmp___8) {
#line 212
      tmp___4 = __builtin_strcmp((char const   *)method, "password");
    } else {
#line 212
      tmp___7 = __builtin_strcmp((char const   *)method, "password");
#line 212
      tmp___4 = tmp___7;
    }
  } else {
#line 212
    tmp___7 = __builtin_strcmp((char const   *)method, "password");
#line 212
    tmp___4 = tmp___7;
  }
#line 212
  if (tmp___4 != 0) {
#line 213
    return (1);
  }
#line 214
  break;
  case 1: 
#line 216
  if (forced_command) {
#line 217
    log("Root login accepted for forced command.");
#line 218
    return (1);
  }
#line 220
  break;
  }
#line 222
  tmp___9 = get_remote_ipaddr();
#line 222
  log("ROOT LOGIN REFUSED FROM %.200s", tmp___9);
#line 223
  return (0);
}
}
#line 1 "auth1.o"
#pragma merger(0,"./auth1.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 59 "auth.h"
int auth_rhosts(struct passwd *pw , char const   *client_user ) ;
#line 70
int auth_rhosts_rsa(struct passwd *pw , char const   *client_user , RSA *client_host_key ) ;
#line 77
int auth_password(Authctxt *authctxt , char const   *password ) ;
#line 84
int auth_rsa(struct passwd *pw , BIGNUM *client_n ) ;
#line 136
char *get_challenge(Authctxt *authctxt , char *devs ) ;
#line 137
int verify_response(Authctxt *authctxt , char *response ) ;
#line 29 "session.h"
void do_authenticated(Authctxt *authctxt ) ;
#line 41 "auth1.c"
static char buf___0[1024]  ;
#line 38 "auth1.c"
char *get_authname(int type ) 
{ 

  {
#line 42
  switch (type) {
  case 9: 
#line 44
  return ((char *)"password");
  case 6: 
#line 46
  return ((char *)"rsa");
  case 35: 
#line 48
  return ((char *)"rhosts-rsa");
  case 5: 
#line 50
  return ((char *)"rhosts");
  case 39: 
  case 41: 
#line 53
  return ((char *)"challenge-response");
  }
#line 59
  snprintf((char * __restrict  )(buf___0), sizeof(buf___0), (char const   * __restrict  )"bad-auth-msg-%d",
           type);
#line 60
  return (buf___0);
}
}
#line 67 "auth1.c"
void do_authloop(Authctxt *authctxt ) 
{ int authenticated ;
  u_int bits ;
  RSA *client_host_key ;
  BIGNUM *n___0 ;
  char *client_user ;
  char *password ;
  char info[1024] ;
  u_int dlen ;
  int plen ;
  int nlen ;
  int elen ;
  u_int ulen ;
  int type ;
  struct passwd *pw ;
  char const   *tmp ;
  int tmp___0 ;
  int _p ;
  int _e ;
  int tmp___1 ;
  int tmp___2 ;
  int _p___0 ;
  int _e___0 ;
  int _p___1 ;
  int _e___1 ;
  int _p___2 ;
  int _e___2 ;
  size_t tmp___3 ;
  char *challenge ;
  char *tmp___4 ;
  char *response ;
  char *tmp___5 ;
  int _p___3 ;
  int _e___3 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;

  {
#line 70
  authenticated = 0;
#line 79
  type = 0;
#line 80
  pw = authctxt->pw;
#line 82
  if (authctxt->valid) {
#line 82
    tmp = "";
  } else {
#line 82
    tmp = "illegal user ";
  }
#line 82
  debug("Attempting authentication for %s%.100s.", tmp, authctxt->user);
#line 86
  if (options.password_authentication) {
#line 86
    tmp___0 = auth_password(authctxt, "");
#line 86
    if (tmp___0) {
#line 97
      auth_log(authctxt, 1, (char *)"without authentication", (char *)"");
#line 98
      return;
    }
  }
#line 102
  packet_start(15);
#line 103
  packet_send();
#line 104
  packet_write_wait();
#line 106
  client_user = (char *)((void *)0);
#line 108
  while (1) {
#line 110
    authenticated = 0;
#line 112
    info[0] = (char )'\000';
#line 115
    type = packet_read(& plen);
#line 118
    switch (type) {
    case 5: 
#line 176
    if (! options.rhosts_authentication) {
#line 177
      verbose("Rhosts authentication disabled.");
#line 178
      break;
    }
#line 186
    client_user = packet_get_string(& ulen);
#line 187
    while (1) {
#line 187
      _p = plen;
#line 187
      _e = (int )(4U + ulen);
#line 187
      if (_p != _e) {
#line 187
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "auth1.c", 187);
#line 187
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 187
      break;
    }
#line 190
    authenticated = auth_rhosts(pw, (char const   *)client_user);
#line 192
    snprintf((char * __restrict  )(info), sizeof(info), (char const   * __restrict  )" ruser %.100s",
             client_user);
#line 193
    break;
    case 35: 
#line 196
    if (! options.rhosts_rsa_authentication) {
#line 197
      verbose("Rhosts with RSA authentication disabled.");
#line 198
      break;
    }
#line 205
    client_user = packet_get_string(& ulen);
#line 208
    client_host_key = RSA_new();
#line 209
    if ((unsigned int )client_host_key == (unsigned int )((void *)0)) {
#line 210
      fatal("RSA_new failed");
    }
#line 211
    client_host_key->e = BN_new();
#line 212
    client_host_key->n = BN_new();
#line 213
    if ((unsigned int )client_host_key->e == (unsigned int )((void *)0)) {
#line 214
      fatal("BN_new failed");
    } else {
#line 213
      if ((unsigned int )client_host_key->n == (unsigned int )((void *)0)) {
#line 214
        fatal("BN_new failed");
      }
    }
#line 215
    bits = packet_get_int();
#line 216
    packet_get_bignum(client_host_key->e, & elen);
#line 217
    packet_get_bignum(client_host_key->n, & nlen);
#line 219
    tmp___2 = BN_num_bits((BIGNUM const   *)client_host_key->n);
#line 219
    if (bits != (u_int )tmp___2) {
#line 220
      tmp___1 = BN_num_bits((BIGNUM const   *)client_host_key->n);
#line 220
      verbose("Warning: keysize mismatch for client_host_key: actual %d, announced %d",
              tmp___1, bits);
    }
#line 222
    while (1) {
#line 222
      _p___0 = plen;
#line 222
      _e___0 = (int )((((4U + ulen) + 4U) + (u_int )elen) + (u_int )nlen);
#line 222
      if (_p___0 != _e___0) {
#line 222
        log("Packet integrity error (%d != %d) at %s:%d", _p___0, _e___0, "auth1.c",
            222);
#line 222
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 222
      break;
    }
#line 224
    authenticated = auth_rhosts_rsa(pw, (char const   *)client_user, client_host_key);
#line 225
    RSA_free(client_host_key);
#line 227
    snprintf((char * __restrict  )(info), sizeof(info), (char const   * __restrict  )" ruser %.100s",
             client_user);
#line 228
    break;
    case 6: 
#line 231
    if (! options.rsa_authentication) {
#line 232
      verbose("RSA authentication disabled.");
#line 233
      break;
    }
#line 236
    n___0 = BN_new();
#line 237
    packet_get_bignum(n___0, & nlen);
#line 238
    while (1) {
#line 238
      _p___1 = plen;
#line 238
      _e___1 = nlen;
#line 238
      if (_p___1 != _e___1) {
#line 238
        log("Packet integrity error (%d != %d) at %s:%d", _p___1, _e___1, "auth1.c",
            238);
#line 238
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 238
      break;
    }
#line 239
    authenticated = auth_rsa(pw, n___0);
#line 240
    BN_clear_free(n___0);
#line 241
    break;
    case 9: 
#line 244
    if (! options.password_authentication) {
#line 245
      verbose("Password authentication disabled.");
#line 246
      break;
    }
#line 253
    password = packet_get_string(& dlen);
#line 254
    while (1) {
#line 254
      _p___2 = plen;
#line 254
      _e___2 = (int )(4U + dlen);
#line 254
      if (_p___2 != _e___2) {
#line 254
        log("Packet integrity error (%d != %d) at %s:%d", _p___2, _e___2, "auth1.c",
            254);
#line 254
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 254
      break;
    }
#line 265
    authenticated = auth_password(authctxt, (char const   *)password);
#line 268
    tmp___3 = strlen((char const   *)password);
#line 268
    memset((void *)password, 0, tmp___3);
#line 269
    xfree((void *)password);
#line 270
    break;
    case 39: 
#line 273
    debug("rcvd SSH_CMSG_AUTH_TIS");
#line 274
    if (options.challenge_reponse_authentication == 1) {
#line 275
      tmp___4 = get_challenge(authctxt, authctxt->style);
#line 275
      challenge = tmp___4;
#line 276
      if ((unsigned int )challenge != (unsigned int )((void *)0)) {
#line 277
        debug("sending challenge \'%s\'", challenge);
#line 278
        packet_start(40);
#line 279
        packet_put_cstring((char const   *)challenge);
#line 280
        packet_send();
#line 281
        packet_write_wait();
        goto __Cont;
      }
    }
#line 285
    break;
    case 41: 
#line 287
    debug("rcvd SSH_CMSG_AUTH_TIS_RESPONSE");
#line 288
    if (options.challenge_reponse_authentication == 1) {
#line 289
      tmp___5 = packet_get_string(& dlen);
#line 289
      response = tmp___5;
#line 290
      debug("got response \'%s\'", response);
#line 291
      while (1) {
#line 291
        _p___3 = plen;
#line 291
        _e___3 = (int )(4U + dlen);
#line 291
        if (_p___3 != _e___3) {
#line 291
          log("Packet integrity error (%d != %d) at %s:%d", _p___3, _e___3, "auth1.c",
              291);
#line 291
          packet_disconnect("Packet integrity error. (%d)", type);
        }
#line 291
        break;
      }
#line 292
      authenticated = verify_response(authctxt, response);
#line 293
      memset((void *)response, 'r', dlen);
#line 294
      xfree((void *)response);
    }
#line 296
    break;
    default: 
#line 303
    log("Unknown message during authentication: type %d", type);
#line 304
    break;
    }
#line 312
    if (! authctxt->valid) {
#line 312
      if (authenticated) {
#line 313
        fatal("INTERNAL ERROR: authenticated invalid user %s", authctxt->user);
      }
    }
#line 325
    if (authenticated) {
#line 325
      if ((authctxt->pw)->pw_uid == 0U) {
#line 325
        tmp___6 = get_authname(type);
#line 325
        tmp___7 = auth_root_allowed(tmp___6);
#line 325
        if (! tmp___7) {
#line 327
          authenticated = 0;
        }
      }
    }
#line 335
    tmp___8 = get_authname(type);
#line 335
    auth_log(authctxt, authenticated, tmp___8, info);
#line 337
    if ((unsigned int )client_user != (unsigned int )((void *)0)) {
#line 338
      xfree((void *)client_user);
#line 339
      client_user = (char *)((void *)0);
    }
#line 342
    if (authenticated) {
#line 343
      return;
    }
#line 345
    tmp___9 = authctxt->failures;
#line 345
    (authctxt->failures) ++;
#line 345
    if (tmp___9 > 6) {
#line 351
      packet_disconnect("Too many authentication failures for %.100s", authctxt->user);
    }
#line 354
    packet_start(15);
#line 355
    packet_send();
#line 356
    packet_write_wait();
    __Cont: /* CIL Label */ ;
  }
}
}
#line 364 "auth1.c"
void do_authentication(void) 
{ Authctxt *authctxt ;
  struct passwd *pw ;
  int plen ;
  u_int ulen ;
  char *user ;
  char *style ;
  int _p ;
  int _e ;
  char *tmp ;
  char *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  __uid_t tmp___4 ;
  __uid_t tmp___5 ;

  {
#line 371
  style = (char *)((void *)0);
#line 374
  packet_read_expect(& plen, 4);
#line 377
  user = packet_get_string(& ulen);
#line 378
  while (1) {
#line 378
    _p = plen;
#line 378
    _e = (int )(4U + ulen);
#line 378
    if (_p != _e) {
#line 378
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "auth1.c", 378);
#line 378
      packet_disconnect("Packet integrity error. (%d)", 4);
    }
#line 378
    break;
  }
#line 380
  tmp___1 = __builtin_strchr(user, ':');
#line 380
  style = tmp___1;
#line 380
  if ((unsigned int )style != (unsigned int )((void *)0)) {
#line 381
    tmp = style;
#line 381
    style ++;
#line 381
    *tmp = (char)0;
  }
#line 383
  authctxt = authctxt_new();
#line 384
  authctxt->user = user;
#line 385
  authctxt->style = style;
#line 388
  pw = getpwnam((char const   *)user);
#line 389
  if (pw) {
#line 389
    tmp___2 = allowed_user(pw);
#line 389
    if (tmp___2) {
#line 390
      authctxt->valid = 1;
#line 391
      pw = pwcopy(pw);
    } else {
#line 393
      debug("do_authentication: illegal user %s", user);
#line 394
      pw = (struct passwd *)((void *)0);
    }
  } else {
#line 393
    debug("do_authentication: illegal user %s", user);
#line 394
    pw = (struct passwd *)((void *)0);
  }
#line 396
  authctxt->pw = pw;
#line 398
  if (pw) {
#line 398
    tmp___3 = (char const   *)user;
  } else {
#line 398
    tmp___3 = "unknown";
  }
#line 398
  setproctitle("%s", tmp___3);
#line 410
  tmp___4 = getuid();
#line 410
  if (tmp___4 != 0U) {
#line 410
    if (pw) {
#line 410
      tmp___5 = getuid();
#line 410
      if (pw->pw_uid != tmp___5) {
#line 411
        packet_disconnect("Cannot change user when server not running as root.");
      }
    }
  }
#line 418
  do_authloop(authctxt);
#line 421
  packet_start(14);
#line 422
  packet_send();
#line 423
  packet_write_wait();
#line 434
  do_authenticated(authctxt);
#line 435
  return;
}
}
#line 1 "auth2.o"
#pragma merger(0,"./auth2.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 212
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 759 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 62 "auth.h"
int auth_rhosts2(struct passwd *pw , char const   *client_user , char const   *hostname ,
                 char const   *ipaddr ) ;
#line 129
void userauth_finish(Authctxt *authctxt , int authenticated , char *method ) ;
#line 132
int auth2_challenge(Authctxt *authctxt , char *devs ) ;
#line 139
struct passwd *auth_get_user(void) ;
#line 37 "auth-options.h"
int auth_parse_options(struct passwd *pw , char *opts , char *file , u_long linenum ) ;
#line 42
void auth_clear_options(void) ;
#line 64 "auth2.c"
static Authctxt *x_authctxt  =    (Authctxt *)((void *)0);
#line 65 "auth2.c"
static int one  =    1;
#line 76
void input_service_request(int type , int plen , void *ctxt ) ;
#line 77
void input_userauth_request(int type , int plen , void *ctxt ) ;
#line 78
void protocol_error(int type , int plen , void *ctxt ) ;
#line 81
Authmethod *authmethod_lookup(char const   *name ) ;
#line 82
char *authmethods_get(void) ;
#line 83
int user_key_allowed(struct passwd *pw , Key *key ) ;
#line 84
int hostbased_key_allowed(struct passwd *pw , char const   *cuser , char *chost ,
                          Key *key ) ;
#line 89
void userauth_banner(void) ;
#line 90
void userauth_reply(Authctxt *authctxt , int authenticated ) ;
#line 91
int userauth_none(Authctxt *authctxt ) ;
#line 92
int userauth_passwd(Authctxt *authctxt ) ;
#line 93
int userauth_pubkey(Authctxt *authctxt ) ;
#line 94
int userauth_hostbased(Authctxt *authctxt ) ;
#line 95
int userauth_kbdint(Authctxt *authctxt ) ;
#line 97 "auth2.c"
Authmethod authmethods[6]  = {      {(char *)"none", & userauth_none, & one}, 
        {(char *)"publickey", & userauth_pubkey, & options.pubkey_authentication}, 
        {(char *)"password", & userauth_passwd, & options.password_authentication}, 
        {(char *)"keyboard-interactive", & userauth_kbdint, & options.kbd_interactive_authentication}, 
        {(char *)"hostbased",
      & userauth_hostbased, & options.hostbased_authentication}, 
        {(char *)((void *)0), (int (*)(Authctxt *authctxt ))((void *)0), (int *)((void *)0)}};
#line 120 "auth2.c"
void do_authentication2(void) 
{ Authctxt *authctxt ;
  Authctxt *tmp ;

  {
#line 123
  tmp = authctxt_new();
#line 123
  authctxt = tmp;
#line 125
  x_authctxt = authctxt;
#line 128
  if (options.challenge_reponse_authentication) {
#line 129
    options.kbd_interactive_authentication = 1;
  }
#line 130
  if (options.pam_authentication_via_kbd_int) {
#line 131
    options.kbd_interactive_authentication = 1;
  }
#line 133
  dispatch_init(& protocol_error);
#line 134
  dispatch_set(5, & input_service_request);
#line 135
  dispatch_run(0, & authctxt->success, (void *)authctxt);
#line 136
  do_authenticated(authctxt);
#line 137
  return;
}
}
#line 139 "auth2.c"
void protocol_error(int type , int plen , void *ctxt ) 
{ 

  {
#line 142
  log("auth: protocol error: type %d plen %d", type, plen);
#line 143
  packet_start(3);
#line 144
  packet_put_int(0U);
#line 145
  packet_send();
#line 146
  packet_write_wait();
#line 147
  return;
}
}
#line 149 "auth2.c"
void input_service_request(int type , int plen , void *ctxt ) 
{ Authctxt *authctxt ;
  u_int len ;
  int accept___0 ;
  char *service ;
  char *tmp ;
  int _len ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 152
  authctxt = (Authctxt *)ctxt;
#line 154
  accept___0 = 0;
#line 155
  tmp = packet_get_string(& len);
#line 155
  service = tmp;
#line 156
  while (1) {
#line 156
    tmp___0 = packet_remaining();
#line 156
    _len = tmp___0;
#line 156
    if (_len > 0) {
#line 156
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
          156);
#line 156
      packet_disconnect("Packet integrity error.");
    }
#line 156
    break;
  }
#line 158
  if ((unsigned int )authctxt == (unsigned int )((void *)0)) {
#line 159
    fatal("input_service_request: no authctxt");
  }
#line 161
  if (0) {
#line 161
    __s1_len = strlen((char const   *)service);
#line 161
    __s2_len = strlen("ssh-userauth");
#line 161
    if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
      goto _L___0;
    } else {
#line 161
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 161
        if (! ((unsigned int )((void const   *)("ssh-userauth" + 1)) - (unsigned int )((void const   *)"ssh-userauth") == 1U)) {
#line 161
          tmp___10 = 1;
        } else {
#line 161
          if (__s2_len >= 4U) {
#line 161
            tmp___10 = 1;
          } else {
#line 161
            tmp___10 = 0;
          }
        }
      } else {
#line 161
        tmp___10 = 0;
      }
    }
#line 161
    if (tmp___10) {
#line 161
      tmp___6 = __builtin_strcmp((char const   *)service, "ssh-userauth");
    } else {
#line 161
      tmp___9 = __builtin_strcmp((char const   *)service, "ssh-userauth");
#line 161
      tmp___6 = tmp___9;
    }
  } else {
#line 161
    tmp___9 = __builtin_strcmp((char const   *)service, "ssh-userauth");
#line 161
    tmp___6 = tmp___9;
  }
#line 161
  if (tmp___6 == 0) {
#line 162
    if (! authctxt->success) {
#line 163
      accept___0 = 1;
#line 165
      dispatch_set(50, & input_userauth_request);
    }
  }
#line 170
  if (accept___0) {
#line 171
    packet_start(6);
#line 172
    packet_put_cstring((char const   *)service);
#line 173
    packet_send();
#line 174
    packet_write_wait();
  } else {
#line 176
    debug("bad service request %s", service);
#line 177
    packet_disconnect("bad service request %s", service);
  }
#line 179
  xfree((void *)service);
#line 180
  return;
}
}
#line 182 "auth2.c"
void input_userauth_request(int type , int plen , void *ctxt ) 
{ Authctxt *authctxt ;
  Authmethod *m___0 ;
  char *user ;
  char *service ;
  char *method ;
  char *style ;
  int authenticated ;
  char *tmp ;
  char *tmp___1 ;
  struct passwd *pw ;
  int tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___30 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;

  {
#line 185
  authctxt = (Authctxt *)ctxt;
#line 186
  m___0 = (Authmethod *)((void *)0);
#line 187
  style = (char *)((void *)0);
#line 188
  authenticated = 0;
#line 190
  if ((unsigned int )authctxt == (unsigned int )((void *)0)) {
#line 191
    fatal("input_userauth_request: no authctxt");
  }
#line 193
  user = packet_get_string((u_int *)((void *)0));
#line 194
  service = packet_get_string((u_int *)((void *)0));
#line 195
  method = packet_get_string((u_int *)((void *)0));
#line 196
  debug("userauth-request for user %s service %s method %s", user, service, method);
#line 197
  debug("attempt %d failures %d", authctxt->attempt, authctxt->failures);
#line 199
  tmp___1 = __builtin_strchr(user, ':');
#line 199
  style = tmp___1;
#line 199
  if ((unsigned int )style != (unsigned int )((void *)0)) {
#line 200
    tmp = style;
#line 200
    style ++;
#line 200
    *tmp = (char)0;
  }
#line 202
  tmp___35 = authctxt->attempt;
#line 202
  (authctxt->attempt) ++;
#line 202
  if (tmp___35 == 0) {
#line 204
    pw = (struct passwd *)((void *)0);
#line 205
    pw = getpwnam((char const   *)user);
#line 206
    if (pw) {
#line 206
      tmp___2 = allowed_user(pw);
#line 206
      if (tmp___2) {
#line 206
        if (0) {
#line 206
          __s1_len = strlen((char const   *)service);
#line 206
          __s2_len = strlen("ssh-connection");
#line 206
          if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
            goto _L___0;
          } else {
#line 206
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 206
              if (! ((unsigned int )((void const   *)("ssh-connection" + 1)) - (unsigned int )((void const   *)"ssh-connection") == 1U)) {
#line 206
                tmp___12 = 1;
              } else {
#line 206
                if (__s2_len >= 4U) {
#line 206
                  tmp___12 = 1;
                } else {
#line 206
                  tmp___12 = 0;
                }
              }
            } else {
#line 206
              tmp___12 = 0;
            }
          }
#line 206
          if (tmp___12) {
#line 206
            tmp___8 = __builtin_strcmp((char const   *)service, "ssh-connection");
          } else {
#line 206
            tmp___11 = __builtin_strcmp((char const   *)service, "ssh-connection");
#line 206
            tmp___8 = tmp___11;
          }
        } else {
#line 206
          tmp___11 = __builtin_strcmp((char const   *)service, "ssh-connection");
#line 206
          tmp___8 = tmp___11;
        }
#line 206
        if (tmp___8 == 0) {
#line 207
          authctxt->pw = pwcopy(pw);
#line 208
          authctxt->valid = 1;
#line 209
          debug2("input_userauth_request: setting up authctxt for %s", user);
        } else {
#line 214
          log("input_userauth_request: illegal user %s", user);
        }
      } else {
#line 214
        log("input_userauth_request: illegal user %s", user);
      }
    } else {
#line 214
      log("input_userauth_request: illegal user %s", user);
    }
#line 219
    if (pw) {
#line 219
      tmp___13 = (char const   *)user;
    } else {
#line 219
      tmp___13 = "unknown";
    }
#line 219
    setproctitle("%s", tmp___13);
#line 220
    authctxt->user = xstrdup((char const   *)user);
#line 221
    authctxt->service = xstrdup((char const   *)service);
#line 222
    if (style) {
#line 222
      authctxt->style = xstrdup((char const   *)style);
    } else {
#line 222
      authctxt->style = (char *)((void *)0);
    }
  } else {
#line 223
    if (authctxt->valid) {
#line 224
      if (0) {
#line 224
        __s1_len___0 = strlen((char const   *)user);
#line 224
        __s2_len___0 = strlen((char const   *)authctxt->user);
#line 224
        if (! ((unsigned int )((void const   *)(user + 1)) - (unsigned int )((void const   *)user) == 1U)) {
          goto _L___2;
        } else {
#line 224
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 224
            if (! ((unsigned int )((void const   *)(authctxt->user + 1)) - (unsigned int )((void const   *)authctxt->user) == 1U)) {
#line 224
              tmp___24 = 1;
            } else {
#line 224
              if (__s2_len___0 >= 4U) {
#line 224
                tmp___24 = 1;
              } else {
#line 224
                tmp___24 = 0;
              }
            }
          } else {
#line 224
            tmp___24 = 0;
          }
        }
#line 224
        if (tmp___24) {
#line 224
          tmp___20 = __builtin_strcmp((char const   *)user, (char const   *)authctxt->user);
        } else {
#line 224
          tmp___23 = __builtin_strcmp((char const   *)user, (char const   *)authctxt->user);
#line 224
          tmp___20 = tmp___23;
        }
      } else {
#line 224
        tmp___23 = __builtin_strcmp((char const   *)user, (char const   *)authctxt->user);
#line 224
        tmp___20 = tmp___23;
      }
#line 225
      if (tmp___20 != 0) {
#line 226
        log("input_userauth_request: mismatch: (%s,%s)!=(%s,%s)", user, service, authctxt->user,
            authctxt->service);
#line 228
        authctxt->valid = 0;
      } else {
#line 225
        if (0) {
#line 225
          __s1_len___1 = strlen((char const   *)service);
#line 225
          __s2_len___1 = strlen((char const   *)authctxt->service);
#line 225
          if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
            goto _L___4;
          } else {
#line 225
            if (__s1_len___1 >= 4U) {
              _L___4: /* CIL Label */ 
#line 225
              if (! ((unsigned int )((void const   *)(authctxt->service + 1)) - (unsigned int )((void const   *)authctxt->service) == 1U)) {
#line 225
                tmp___34 = 1;
              } else {
#line 225
                if (__s2_len___1 >= 4U) {
#line 225
                  tmp___34 = 1;
                } else {
#line 225
                  tmp___34 = 0;
                }
              }
            } else {
#line 225
              tmp___34 = 0;
            }
          }
#line 225
          if (tmp___34) {
#line 225
            tmp___30 = __builtin_strcmp((char const   *)service, (char const   *)authctxt->service);
          } else {
#line 225
            tmp___33 = __builtin_strcmp((char const   *)service, (char const   *)authctxt->service);
#line 225
            tmp___30 = tmp___33;
          }
        } else {
#line 225
          tmp___33 = __builtin_strcmp((char const   *)service, (char const   *)authctxt->service);
#line 225
          tmp___30 = tmp___33;
        }
#line 225
        if (tmp___30 != 0) {
#line 226
          log("input_userauth_request: mismatch: (%s,%s)!=(%s,%s)", user, service,
              authctxt->user, authctxt->service);
#line 228
          authctxt->valid = 0;
        }
      }
    }
  }
#line 232
  dispatch_set(61, & protocol_error);
#line 233
  authctxt->postponed = 0;
#line 242
  m___0 = authmethod_lookup((char const   *)method);
#line 243
  if ((unsigned int )m___0 != (unsigned int )((void *)0)) {
#line 244
    debug2("input_userauth_request: try method %s", method);
#line 245
    authenticated = (*(m___0->userauth))(authctxt);
  }
#line 247
  userauth_finish(authctxt, authenticated, method);
#line 249
  xfree((void *)service);
#line 250
  xfree((void *)user);
#line 251
  xfree((void *)method);
#line 252
  return;
}
}
#line 254 "auth2.c"
void userauth_finish(Authctxt *authctxt , int authenticated , char *method ) 
{ int tmp ;

  {
#line 257
  if (! authctxt->valid) {
#line 257
    if (authenticated) {
#line 258
      fatal("INTERNAL ERROR: authenticated invalid user %s", authctxt->user);
    }
  }
#line 262
  if (authenticated) {
#line 262
    if ((authctxt->pw)->pw_uid == 0U) {
#line 262
      tmp = auth_root_allowed(method);
#line 262
      if (! tmp) {
#line 264
        authenticated = 0;
      }
    }
  }
#line 273
  auth_log(authctxt, authenticated, method, (char *)" ssh2");
#line 275
  if (! authctxt->postponed) {
#line 276
    userauth_reply(authctxt, authenticated);
  }
#line 277
  return;
}
}
#line 279 "auth2.c"
void userauth_banner(void) 
{ struct stat st ;
  char *banner ;
  off_t len ;
  off_t n___0 ;
  int fd ;
  int tmp ;
  void *tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 283
  banner = (char *)((void *)0);
#line 287
  if ((unsigned int )options.banner == (unsigned int )((void *)0)) {
#line 288
    return;
  } else {
#line 287
    if (datafellows & 128) {
#line 288
      return;
    }
  }
#line 289
  fd = open((char const   *)options.banner, 0);
#line 289
  if (fd < 0) {
#line 290
    return;
  }
#line 291
  tmp = fstat(fd, & st);
#line 291
  if (tmp < 0) {
    goto done;
  }
#line 293
  len = st.st_size;
#line 294
  tmp___0 = xmalloc((unsigned int )(len + 1L));
#line 294
  banner = (char *)tmp___0;
#line 295
  tmp___1 = read(fd, (void *)banner, (unsigned int )len);
#line 295
  n___0 = (long )tmp___1;
#line 295
  if (n___0 < 0L) {
    goto done;
  }
#line 297
  *(banner + n___0) = (char )'\000';
#line 298
  packet_start(53);
#line 299
  packet_put_cstring((char const   *)banner);
#line 300
  packet_put_cstring("");
#line 301
  packet_send();
#line 302
  debug("userauth_banner: sent");
  done: 
#line 304
  if (banner) {
#line 305
    xfree((void *)banner);
  }
#line 306
  close(fd);
#line 307
  return;
}
}
#line 310 "auth2.c"
void userauth_reply(Authctxt *authctxt , int authenticated ) 
{ char *methods ;
  int tmp ;

  {
#line 316
  if (authenticated == 1) {
#line 325
    dispatch_set(50, & protocol_error);
#line 326
    packet_start(52);
#line 327
    packet_send();
#line 328
    packet_write_wait();
#line 330
    authctxt->success = 1;
  } else {
#line 332
    tmp = authctxt->failures;
#line 332
    (authctxt->failures) ++;
#line 332
    if (tmp > 6) {
#line 333
      packet_disconnect("Too many authentication failures for %.100s", authctxt->user);
    }
#line 334
    methods = authmethods_get();
#line 335
    packet_start(51);
#line 336
    packet_put_cstring((char const   *)methods);
#line 337
    packet_put_char(0);
#line 338
    packet_send();
#line 339
    packet_write_wait();
#line 340
    xfree((void *)methods);
  }
#line 342
  return;
}
}
#line 344 "auth2.c"
int userauth_none(Authctxt *authctxt ) 
{ Authmethod *m___0 ;
  Authmethod *tmp ;
  int _len ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 348
  tmp = authmethod_lookup("none");
#line 348
  m___0 = tmp;
#line 349
  if ((unsigned int )m___0 != (unsigned int )((void *)0)) {
#line 350
    m___0->enabled = (int *)((void *)0);
  }
#line 351
  while (1) {
#line 351
    tmp___0 = packet_remaining();
#line 351
    _len = tmp___0;
#line 351
    if (_len > 0) {
#line 351
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
          351);
#line 351
      packet_disconnect("Packet integrity error.");
    }
#line 351
    break;
  }
#line 352
  userauth_banner();
#line 354
  if (authctxt->valid == 0) {
#line 355
    return (0);
  }
#line 366
  tmp___1 = auth_password(authctxt, "");
#line 366
  return (tmp___1);
}
}
#line 370 "auth2.c"
int userauth_passwd(Authctxt *authctxt ) 
{ char *password ;
  int authenticated ;
  int change ;
  u_int len ;
  u_int tmp ;
  int _len ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 374
  authenticated = 0;
#line 377
  tmp = packet_get_char();
#line 377
  change = (int )tmp;
#line 378
  if (change) {
#line 379
    log("password change not supported");
  }
#line 380
  password = packet_get_string(& len);
#line 381
  while (1) {
#line 381
    tmp___0 = packet_remaining();
#line 381
    _len = tmp___0;
#line 381
    if (_len > 0) {
#line 381
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
          381);
#line 381
      packet_disconnect("Packet integrity error.");
    }
#line 381
    break;
  }
#line 382
  if (authctxt->valid) {
#line 382
    tmp___1 = auth_password(authctxt, (char const   *)password);
#line 382
    if (tmp___1 == 1) {
#line 393
      authenticated = 1;
    }
  }
#line 394
  memset((void *)password, 0, len);
#line 395
  xfree((void *)password);
#line 396
  return (authenticated);
}
}
#line 399 "auth2.c"
int userauth_kbdint(Authctxt *authctxt ) 
{ int authenticated ;
  char *lang ;
  char *devs ;
  int _len ;
  int tmp ;

  {
#line 402
  authenticated = 0;
#line 403
  lang = (char *)((void *)0);
#line 404
  devs = (char *)((void *)0);
#line 406
  lang = packet_get_string((u_int *)((void *)0));
#line 407
  devs = packet_get_string((u_int *)((void *)0));
#line 408
  while (1) {
#line 408
    tmp = packet_remaining();
#line 408
    _len = tmp;
#line 408
    if (_len > 0) {
#line 408
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
          408);
#line 408
      packet_disconnect("Packet integrity error.");
    }
#line 408
    break;
  }
#line 410
  debug("keyboard-interactive language %s devs %s", lang, devs);
#line 412
  if (options.challenge_reponse_authentication) {
#line 413
    authenticated = auth2_challenge(authctxt, devs);
  }
#line 419
  xfree((void *)lang);
#line 420
  xfree((void *)devs);
#line 425
  return (authenticated);
}
}
#line 428 "auth2.c"
int userauth_pubkey(Authctxt *authctxt ) 
{ Buffer b ;
  Key *key ;
  char *pkalg ;
  char *pkblob ;
  char *sig ;
  u_int alen ;
  u_int blen ;
  u_int slen ;
  int have_sig ;
  int pktype ;
  int authenticated ;
  u_int tmp ;
  int _len ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  u_int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int _len___0 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 436
  authenticated = 0;
#line 438
  if (! authctxt->valid) {
#line 439
    debug2("userauth_pubkey: disabled because of invalid user");
#line 440
    return (0);
  }
#line 442
  tmp = packet_get_char();
#line 442
  have_sig = (int )tmp;
#line 443
  if (datafellows & 32) {
#line 444
    debug2("userauth_pubkey: SSH_BUG_PKAUTH");
#line 446
    pkblob = packet_get_string(& blen);
#line 447
    buffer_init(& b);
#line 448
    buffer_append(& b, (char const   *)pkblob, blen);
#line 450
    pkalg = buffer_get_string(& b, & alen);
#line 451
    buffer_free(& b);
  } else {
#line 453
    pkalg = packet_get_string(& alen);
#line 454
    pkblob = packet_get_string(& blen);
  }
#line 456
  pktype = key_type_from_name(pkalg);
#line 457
  if (pktype == 3) {
#line 459
    log("userauth_pubkey: unsupported public key algorithm: %s", pkalg);
#line 460
    xfree((void *)pkalg);
#line 461
    xfree((void *)pkblob);
#line 462
    return (0);
  }
#line 464
  key = key_from_blob(pkblob, (int )blen);
#line 465
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 466
    if (have_sig) {
#line 467
      sig = packet_get_string(& slen);
#line 468
      while (1) {
#line 468
        tmp___0 = packet_remaining();
#line 468
        _len = tmp___0;
#line 468
        if (_len > 0) {
#line 468
          log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
              468);
#line 468
          packet_disconnect("Packet integrity error.");
        }
#line 468
        break;
      }
#line 469
      buffer_init(& b);
#line 470
      if (datafellows & 16) {
#line 471
        buffer_append(& b, (char const   *)session_id2, (unsigned int )session_id2_len);
      } else {
#line 473
        buffer_put_string(& b, (void const   *)session_id2, (unsigned int )session_id2_len);
      }
#line 476
      buffer_put_char(& b, 50);
#line 477
      buffer_put_cstring(& b, (char const   *)authctxt->user);
#line 478
      if (datafellows & 2) {
#line 478
        tmp___1 = "ssh-userauth";
      } else {
#line 478
        tmp___1 = (char const   *)authctxt->service;
      }
#line 478
      buffer_put_cstring(& b, tmp___1);
#line 482
      if (datafellows & 32) {
#line 483
        buffer_put_char(& b, have_sig);
      } else {
#line 485
        buffer_put_cstring(& b, "publickey");
#line 486
        buffer_put_char(& b, have_sig);
#line 487
        buffer_put_cstring(& b, (char const   *)pkalg);
      }
#line 489
      buffer_put_string(& b, (void const   *)pkblob, blen);
#line 494
      tmp___2 = user_key_allowed(authctxt->pw, key);
#line 494
      if (tmp___2) {
#line 494
        tmp___3 = buffer_len(& b);
#line 494
        tmp___4 = buffer_ptr(& b);
#line 494
        tmp___5 = key_verify(key, (u_char *)sig, (int )slen, (u_char *)tmp___4, (int )tmp___3);
#line 494
        if (tmp___5 == 1) {
#line 496
          authenticated = 1;
        }
      }
#line 497
      buffer_clear(& b);
#line 498
      xfree((void *)sig);
    } else {
#line 500
      debug("test whether pkalg/pkblob are acceptable");
#line 501
      while (1) {
#line 501
        tmp___6 = packet_remaining();
#line 501
        _len___0 = tmp___6;
#line 501
        if (_len___0 > 0) {
#line 501
          log("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "auth2.c",
              501);
#line 501
          packet_disconnect("Packet integrity error.");
        }
#line 501
        break;
      }
#line 511
      tmp___7 = user_key_allowed(authctxt->pw, key);
#line 511
      if (tmp___7) {
#line 512
        packet_start(60);
#line 513
        packet_put_string((char const   *)pkalg, alen);
#line 514
        packet_put_string((char const   *)pkblob, blen);
#line 515
        packet_send();
#line 516
        packet_write_wait();
#line 517
        authctxt->postponed = 1;
      }
    }
#line 520
    if (authenticated != 1) {
#line 521
      auth_clear_options();
    }
#line 522
    key_free(key);
  }
#line 524
  debug2("userauth_pubkey: authenticated %d pkalg %s", authenticated, pkalg);
#line 525
  xfree((void *)pkalg);
#line 526
  xfree((void *)pkblob);
#line 531
  return (authenticated);
}
}
#line 534 "auth2.c"
int userauth_hostbased(Authctxt *authctxt ) 
{ Buffer b ;
  Key *key ;
  char *pkalg ;
  char *pkblob ;
  char *sig ;
  char *cuser ;
  char *chost ;
  char *service ;
  u_int alen ;
  u_int blen ;
  u_int slen ;
  int pktype ;
  int authenticated ;
  int tmp ;
  u_int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 542
  authenticated = 0;
#line 544
  if (! authctxt->valid) {
#line 545
    debug2("userauth_hostbased: disabled because of invalid user");
#line 546
    return (0);
  }
#line 548
  pkalg = packet_get_string(& alen);
#line 549
  pkblob = packet_get_string(& blen);
#line 550
  chost = packet_get_string((u_int *)((void *)0));
#line 551
  cuser = packet_get_string((u_int *)((void *)0));
#line 552
  sig = packet_get_string(& slen);
#line 554
  debug("userauth_hostbased: cuser %s chost %s pkalg %s slen %d", cuser, chost, pkalg,
        slen);
#line 563
  pktype = key_type_from_name(pkalg);
#line 564
  if (pktype == 3) {
#line 566
    log("userauth_hostbased: unsupported public key algorithm: %s", pkalg);
    goto done;
  }
#line 570
  key = key_from_blob(pkblob, (int )blen);
#line 571
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 572
    debug("userauth_hostbased: cannot decode key: %s", pkalg);
    goto done;
  }
#line 575
  if (datafellows & 65536) {
#line 575
    service = (char *)"ssh-userauth";
  } else {
#line 575
    service = authctxt->service;
  }
#line 577
  buffer_init(& b);
#line 578
  buffer_put_string(& b, (void const   *)session_id2, (unsigned int )session_id2_len);
#line 580
  buffer_put_char(& b, 50);
#line 581
  buffer_put_cstring(& b, (char const   *)authctxt->user);
#line 582
  buffer_put_cstring(& b, (char const   *)service);
#line 583
  buffer_put_cstring(& b, "hostbased");
#line 584
  buffer_put_string(& b, (void const   *)pkalg, alen);
#line 585
  buffer_put_string(& b, (void const   *)pkblob, blen);
#line 586
  buffer_put_cstring(& b, (char const   *)chost);
#line 587
  buffer_put_cstring(& b, (char const   *)cuser);
#line 592
  tmp = hostbased_key_allowed(authctxt->pw, (char const   *)cuser, chost, key);
#line 592
  if (tmp) {
#line 592
    tmp___0 = buffer_len(& b);
#line 592
    tmp___1 = buffer_ptr(& b);
#line 592
    tmp___2 = key_verify(key, (u_char *)sig, (int )slen, (u_char *)tmp___1, (int )tmp___0);
#line 592
    if (tmp___2 == 1) {
#line 594
      authenticated = 1;
    }
  }
#line 596
  buffer_clear(& b);
#line 597
  key_free(key);
  done: 
#line 600
  debug2("userauth_hostbased: authenticated %d", authenticated);
#line 601
  xfree((void *)pkalg);
#line 602
  xfree((void *)pkblob);
#line 603
  xfree((void *)cuser);
#line 604
  xfree((void *)chost);
#line 605
  xfree((void *)sig);
#line 606
  return (authenticated);
}
}
#line 611 "auth2.c"
struct passwd *auth_get_user(void) 
{ struct passwd *tmp ;

  {
#line 614
  if ((unsigned int )x_authctxt != (unsigned int )((void *)0)) {
#line 614
    if (x_authctxt->valid) {
#line 614
      tmp = x_authctxt->pw;
    } else {
#line 614
      tmp = (struct passwd *)((void *)0);
    }
  } else {
#line 614
    tmp = (struct passwd *)((void *)0);
  }
#line 614
  return (tmp);
}
}
#line 619 "auth2.c"
char *authmethods_get(void) 
{ Authmethod *method ;
  u_int size ;
  char *list ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___17 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 622
  method = (Authmethod *)((void *)0);
#line 623
  size = (u_int )0;
#line 626
  method = authmethods;
#line 626
  while ((unsigned int )method->name != (unsigned int )((void *)0)) {
#line 627
    if (0) {
#line 627
      __s1_len = strlen((char const   *)method->name);
#line 627
      __s2_len = strlen("none");
#line 627
      if (! ((unsigned int )((void const   *)(method->name + 1)) - (unsigned int )((void const   *)method->name) == 1U)) {
        goto _L___0;
      } else {
#line 627
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 627
          if (! ((unsigned int )((void const   *)("none" + 1)) - (unsigned int )((void const   *)"none") == 1U)) {
#line 627
            tmp___8 = 1;
          } else {
#line 627
            if (__s2_len >= 4U) {
#line 627
              tmp___8 = 1;
            } else {
#line 627
              tmp___8 = 0;
            }
          }
        } else {
#line 627
          tmp___8 = 0;
        }
      }
#line 627
      if (tmp___8) {
#line 627
        tmp___4 = __builtin_strcmp((char const   *)method->name, "none");
      } else {
#line 627
        tmp___7 = __builtin_strcmp((char const   *)method->name, "none");
#line 627
        tmp___4 = tmp___7;
      }
    } else {
#line 627
      tmp___7 = __builtin_strcmp((char const   *)method->name, "none");
#line 627
      tmp___4 = tmp___7;
    }
#line 627
    if (tmp___4 == 0) {
      goto __Cont;
    }
#line 629
    if ((unsigned int )method->enabled != (unsigned int )((void *)0)) {
#line 629
      if (*(method->enabled) != 0) {
#line 630
        if (size != 0U) {
#line 631
          tmp___9 = strlen(",");
#line 631
          size += tmp___9;
        }
#line 632
        tmp___10 = strlen((char const   *)method->name);
#line 632
        size += tmp___10;
      }
    }
    __Cont: /* CIL Label */ 
#line 626
    method ++;
  }
#line 635
  size ++;
#line 636
  tmp___11 = xmalloc(size);
#line 636
  list = (char *)tmp___11;
#line 637
  *(list + 0) = (char )'\000';
#line 639
  method = authmethods;
#line 639
  while ((unsigned int )method->name != (unsigned int )((void *)0)) {
#line 640
    if (0) {
#line 640
      __s1_len___0 = strlen((char const   *)method->name);
#line 640
      __s2_len___0 = strlen("none");
#line 640
      if (! ((unsigned int )((void const   *)(method->name + 1)) - (unsigned int )((void const   *)method->name) == 1U)) {
        goto _L___2;
      } else {
#line 640
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 640
          if (! ((unsigned int )((void const   *)("none" + 1)) - (unsigned int )((void const   *)"none") == 1U)) {
#line 640
            tmp___21 = 1;
          } else {
#line 640
            if (__s2_len___0 >= 4U) {
#line 640
              tmp___21 = 1;
            } else {
#line 640
              tmp___21 = 0;
            }
          }
        } else {
#line 640
          tmp___21 = 0;
        }
      }
#line 640
      if (tmp___21) {
#line 640
        tmp___17 = __builtin_strcmp((char const   *)method->name, "none");
      } else {
#line 640
        tmp___20 = __builtin_strcmp((char const   *)method->name, "none");
#line 640
        tmp___17 = tmp___20;
      }
    } else {
#line 640
      tmp___20 = __builtin_strcmp((char const   *)method->name, "none");
#line 640
      tmp___17 = tmp___20;
    }
#line 640
    if (tmp___17 == 0) {
      goto __Cont___0;
    }
#line 642
    if ((unsigned int )method->enabled != (unsigned int )((void *)0)) {
#line 642
      if (*(method->enabled) != 0) {
#line 643
        if ((int )*(list + 0) != 0) {
#line 644
          strlcat(list, ",", size);
        }
#line 645
        strlcat(list, (char const   *)method->name, size);
      }
    }
    __Cont___0: /* CIL Label */ 
#line 639
    method ++;
  }
#line 648
  return (list);
}
}
#line 651 "auth2.c"
Authmethod *authmethod_lookup(char const   *name ) 
{ Authmethod *method ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;

  {
#line 654
  method = (Authmethod *)((void *)0);
#line 655
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 656
    method = authmethods;
#line 656
    while ((unsigned int )method->name != (unsigned int )((void *)0)) {
#line 659
      if ((unsigned int )method->enabled != (unsigned int )((void *)0)) {
#line 659
        if (*(method->enabled) != 0) {
#line 659
          if (0) {
#line 659
            __s1_len = strlen(name);
#line 659
            __s2_len = strlen((char const   *)method->name);
#line 659
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
              goto _L___0;
            } else {
#line 659
              if (__s1_len >= 4U) {
                _L___0: /* CIL Label */ 
#line 659
                if (! ((unsigned int )((void const   *)(method->name + 1)) - (unsigned int )((void const   *)method->name) == 1U)) {
#line 659
                  tmp___8 = 1;
                } else {
#line 659
                  if (__s2_len >= 4U) {
#line 659
                    tmp___8 = 1;
                  } else {
#line 659
                    tmp___8 = 0;
                  }
                }
              } else {
#line 659
                tmp___8 = 0;
              }
            }
#line 659
            if (tmp___8) {
#line 659
              tmp___4 = __builtin_strcmp(name, (char const   *)method->name);
            } else {
#line 659
              tmp___7 = __builtin_strcmp(name, (char const   *)method->name);
#line 659
              tmp___4 = tmp___7;
            }
          } else {
#line 659
            tmp___7 = __builtin_strcmp(name, (char const   *)method->name);
#line 659
            tmp___4 = tmp___7;
          }
#line 659
          if (tmp___4 == 0) {
#line 660
            return (method);
          }
        }
      }
#line 656
      method ++;
    }
  }
#line 661
  if (name) {
#line 661
    tmp___9 = name;
  } else {
#line 661
    tmp___9 = "NULL";
  }
#line 661
  debug2("Unrecognized authentication method name: %s", tmp___9);
#line 662
  return ((Authmethod *)((void *)0));
}
}
#line 714 "auth2.c"
static char const   *check___0[3]  = {      "",      ".ssh",      (char const   *)((void *)0)};
#line 666 "auth2.c"
int user_key_allowed(struct passwd *pw , Key *key ) 
{ char line[8192] ;
  char file[4096] ;
  int found_key ;
  FILE *f ;
  u_long linenum ;
  struct stat st ;
  Key *found ;
  int tmp ;
  int fail ;
  char buf___2[1024] ;
  char *tmp___0 ;
  int i ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *cp ;
  char *options___0 ;
  int quoted ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;

  {
#line 670
  found_key = 0;
#line 672
  linenum = (u_long )0;
#line 676
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 677
    return (0);
  }
#line 680
  temporarily_use_uid(pw);
#line 683
  snprintf((char * __restrict  )(file), sizeof(file), (char const   * __restrict  )"%.500s/%.100s",
           pw->pw_dir, ".ssh/authorized_keys2");
#line 687
  tmp = stat((char const   * __restrict  )(file), (struct stat * __restrict  )(& st));
#line 687
  if (tmp < 0) {
#line 689
    restore_uid();
#line 690
    return (0);
  }
#line 693
  f = fopen((char const   * __restrict  )(file), (char const   * __restrict  )"r");
#line 694
  if (! f) {
#line 696
    restore_uid();
#line 697
    return (0);
  }
#line 699
  if (options.strict_modes) {
#line 700
    fail = 0;
#line 703
    tmp___3 = fileno(f);
#line 703
    tmp___4 = fstat(tmp___3, & st);
#line 703
    if (tmp___4 < 0) {
#line 706
      tmp___0 = key_type(key);
#line 706
      snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"%s authentication refused for %.100s: bad ownership or modes for \'%s\'.",
               tmp___0, pw->pw_name, file);
#line 710
      fail = 1;
    } else {
#line 703
      if (st.st_uid != 0U) {
#line 703
        if (st.st_uid != pw->pw_uid) {
#line 706
          tmp___0 = key_type(key);
#line 706
          snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"%s authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   tmp___0, pw->pw_name, file);
#line 710
          fail = 1;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 703
        if ((st.st_mode & 18U) != 0U) {
#line 706
          tmp___0 = key_type(key);
#line 706
          snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"%s authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   tmp___0, pw->pw_name, file);
#line 710
          fail = 1;
        } else {
#line 717
          i = 0;
#line 717
          while (check___0[i]) {
#line 718
            snprintf((char * __restrict  )(line), sizeof(line), (char const   * __restrict  )"%.500s/%.100s",
                     pw->pw_dir, check___0[i]);
#line 720
            tmp___2 = stat((char const   * __restrict  )(line), (struct stat * __restrict  )(& st));
#line 720
            if (tmp___2 < 0) {
#line 723
              tmp___1 = key_type(key);
#line 723
              snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"%s authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                       tmp___1, pw->pw_name, line);
#line 727
              fail = 1;
#line 728
              break;
            } else {
#line 720
              if (st.st_uid != 0U) {
#line 720
                if (st.st_uid != pw->pw_uid) {
#line 723
                  tmp___1 = key_type(key);
#line 723
                  snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"%s authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           tmp___1, pw->pw_name, line);
#line 727
                  fail = 1;
#line 728
                  break;
                } else {
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
#line 720
                if ((st.st_mode & 18U) != 0U) {
#line 723
                  tmp___1 = key_type(key);
#line 723
                  snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"%s authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           tmp___1, pw->pw_name, line);
#line 727
                  fail = 1;
#line 728
                  break;
                }
              }
            }
#line 717
            i ++;
          }
        }
      }
    }
#line 732
    if (fail) {
#line 733
      fclose(f);
#line 734
      log("%s", buf___2);
#line 735
      restore_uid();
#line 736
      return (0);
    }
  }
#line 739
  found_key = 0;
#line 740
  found = key_new(key->type);
#line 742
  while (1) {
#line 742
    tmp___9 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 742
    if (! tmp___9) {
#line 742
      break;
    }
#line 743
    options___0 = (char *)((void *)0);
#line 744
    linenum ++;
#line 746
    cp = line;
#line 746
    while (1) {
#line 746
      if (! ((int )*cp == 32)) {
#line 746
        if (! ((int )*cp == 9)) {
#line 746
          break;
        }
      }
#line 746
      cp ++;
    }
#line 748
    if (! *cp) {
#line 749
      continue;
    } else {
#line 748
      if ((int )*cp == 10) {
#line 749
        continue;
      } else {
#line 748
        if ((int )*cp == 35) {
#line 749
          continue;
        }
      }
    }
#line 751
    tmp___6 = key_read(found, & cp);
#line 751
    if (tmp___6 == -1) {
#line 753
      quoted = 0;
#line 754
      debug2("user_key_allowed: check options: \'%s\'", cp);
#line 755
      options___0 = cp;
#line 756
      while (1) {
#line 756
        if (*cp) {
#line 756
          if (! quoted) {
#line 756
            if ((int )*cp != 32) {
#line 756
              if (! ((int )*cp != 9)) {
#line 756
                break;
              }
            } else {
#line 756
              break;
            }
          }
        } else {
#line 756
          break;
        }
#line 757
        if ((int )*cp == 92) {
#line 757
          if ((int )*(cp + 1) == 34) {
#line 758
            cp ++;
          } else {
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
#line 759
          if ((int )*cp == 34) {
#line 760
            quoted = ! quoted;
          }
        }
#line 756
        cp ++;
      }
#line 763
      while (1) {
#line 763
        if (! ((int )*cp == 32)) {
#line 763
          if (! ((int )*cp == 9)) {
#line 763
            break;
          }
        }
#line 763
        cp ++;
      }
#line 765
      tmp___5 = key_read(found, & cp);
#line 765
      if (tmp___5 == -1) {
#line 766
        debug2("user_key_allowed: advance: \'%s\'", cp);
#line 768
        continue;
      }
    }
#line 771
    tmp___7 = key_equal(found, key);
#line 771
    if (tmp___7) {
#line 771
      tmp___8 = auth_parse_options(pw, options___0, file, linenum);
#line 771
      if (tmp___8 == 1) {
#line 773
        found_key = 1;
#line 774
        debug("matching key found: file %s, line %ld", file, linenum);
#line 776
        break;
      }
    }
  }
#line 779
  restore_uid();
#line 780
  fclose(f);
#line 781
  key_free(found);
#line 782
  if (! found_key) {
#line 783
    debug2("key not found");
  }
#line 784
  return (found_key);
}
}
#line 788 "auth2.c"
int hostbased_key_allowed(struct passwd *pw , char const   *cuser , char *chost ,
                          Key *key ) 
{ Key *found ;
  char const   *resolvedname ;
  char const   *ipaddr ;
  char const   *lookup ;
  struct stat st ;
  char *user_hostfile ;
  int host_status ;
  int len ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  HostStatus tmp___3 ;
  HostStatus tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;

  {
#line 798
  resolvedname = get_canonical_hostname(options.reverse_mapping_check);
#line 799
  ipaddr = get_remote_ipaddr();
#line 801
  debug2("userauth_hostbased: chost %s resolvedname %s ipaddr %s", chost, resolvedname,
         ipaddr);
#line 804
  if (options.hostbased_uses_name_from_packet_only) {
#line 805
    tmp = auth_rhosts2(pw, cuser, (char const   *)chost, (char const   *)chost);
#line 805
    if (tmp == 0) {
#line 806
      return (0);
    }
#line 807
    lookup = (char const   *)chost;
  } else {
#line 809
    tmp___0 = strlen((char const   *)chost);
#line 809
    len = (int )tmp___0;
#line 809
    if (len > 0) {
#line 809
      if ((int )*(chost + (len - 1)) == 46) {
#line 810
        debug2("stripping trailing dot from chost %s", chost);
#line 811
        *(chost + (len - 1)) = (char )'\000';
      }
    }
#line 813
    tmp___1 = strcasecmp(resolvedname, (char const   *)chost);
#line 813
    if (tmp___1 != 0) {
#line 814
      log("userauth_hostbased mismatch: client sends %s, but we resolve %s to %s",
          chost, ipaddr, resolvedname);
    }
#line 817
    tmp___2 = auth_rhosts2(pw, cuser, resolvedname, ipaddr);
#line 817
    if (tmp___2 == 0) {
#line 818
      return (0);
    }
#line 819
    lookup = resolvedname;
  }
#line 821
  debug2("userauth_hostbased: access allowed by auth_rhosts2");
#line 824
  found = key_new(key->type);
#line 825
  tmp___3 = check_host_in_hostfile("/usr/local/etc/ssh_known_hosts2", lookup, key,
                                   found, (int *)((void *)0));
#line 825
  host_status = (int )tmp___3;
#line 828
  if (host_status != 0) {
#line 828
    if (! options.ignore_user_known_hosts) {
#line 829
      user_hostfile = tilde_expand_filename("~/.ssh/known_hosts2", pw->pw_uid);
#line 831
      if (options.strict_modes) {
#line 831
        tmp___5 = stat((char const   * __restrict  )user_hostfile, (struct stat * __restrict  )(& st));
#line 831
        if (tmp___5 == 0) {
#line 831
          if (st.st_uid != 0U) {
#line 831
            if (st.st_uid != pw->pw_uid) {
#line 835
              log("Hostbased authentication refused for %.100s: bad owner or modes for %.200s",
                  pw->pw_name, user_hostfile);
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 831
            if ((st.st_mode & 18U) != 0U) {
#line 835
              log("Hostbased authentication refused for %.100s: bad owner or modes for %.200s",
                  pw->pw_name, user_hostfile);
            } else {
#line 839
              temporarily_use_uid(pw);
#line 840
              tmp___4 = check_host_in_hostfile((char const   *)user_hostfile, lookup,
                                               key, found, (int *)((void *)0));
#line 840
              host_status = (int )tmp___4;
#line 842
              restore_uid();
            }
          }
        } else {
#line 839
          temporarily_use_uid(pw);
#line 840
          tmp___4 = check_host_in_hostfile((char const   *)user_hostfile, lookup,
                                           key, found, (int *)((void *)0));
#line 840
          host_status = (int )tmp___4;
#line 842
          restore_uid();
        }
      } else {
#line 839
        temporarily_use_uid(pw);
#line 840
        tmp___4 = check_host_in_hostfile((char const   *)user_hostfile, lookup, key,
                                         found, (int *)((void *)0));
#line 840
        host_status = (int )tmp___4;
#line 842
        restore_uid();
      }
#line 844
      xfree((void *)user_hostfile);
    }
  }
#line 846
  key_free(found);
#line 848
  if (host_status == 0) {
#line 848
    tmp___6 = "ok";
  } else {
#line 848
    tmp___6 = "not found";
  }
#line 848
  debug2("userauth_hostbased: key %s for %s", tmp___6, lookup);
#line 850
  return (host_status == 0);
}
}
#line 1 "auth-chall.o"
#pragma merger(0,"./auth-chall.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 93 "auth-chall.c"
char *get_challenge(Authctxt *authctxt , char *devs ) 
{ 

  {
#line 96
  return ((char *)((void *)0));
}
}
#line 98 "auth-chall.c"
int verify_response(Authctxt *authctxt , char *response ) 
{ 

  {
#line 101
  return (0);
}
}
#line 1 "auth2-chall.o"
#pragma merger(0,"./auth2-chall.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 34 "auth2-chall.c"
void send_userauth_into_request(Authctxt *authctxt , char *challenge , int echo ) ;
#line 35
void input_userauth_info_response(int type , int plen , void *ctxt ) ;
#line 41 "auth2-chall.c"
int auth2_challenge(Authctxt *authctxt , char *devs ) 
{ char *challenge ;

  {
#line 46
  if (! authctxt->valid) {
#line 47
    return (0);
  } else {
#line 46
    if ((unsigned int )authctxt->user == (unsigned int )((void *)0)) {
#line 47
      return (0);
    }
  }
#line 48
  challenge = get_challenge(authctxt, devs);
#line 48
  if ((unsigned int )challenge == (unsigned int )((void *)0)) {
#line 49
    return (0);
  }
#line 50
  send_userauth_into_request(authctxt, challenge, 0);
#line 51
  dispatch_set(61, & input_userauth_info_response);
#line 53
  authctxt->postponed = 1;
#line 54
  return (0);
}
}
#line 57 "auth2-chall.c"
void send_userauth_into_request(Authctxt *authctxt , char *challenge , int echo ) 
{ int nprompts ;

  {
#line 60
  nprompts = 1;
#line 62
  packet_start(60);
#line 64
  packet_put_cstring("");
#line 65
  packet_put_cstring("");
#line 66
  packet_put_cstring("");
#line 67
  packet_put_int((unsigned int )nprompts);
#line 68
  packet_put_cstring((char const   *)challenge);
#line 69
  packet_put_char(echo);
#line 70
  packet_send();
#line 71
  packet_write_wait();
#line 72
  return;
}
}
#line 74 "auth2-chall.c"
void input_userauth_info_response(int type , int plen , void *ctxt ) 
{ Authctxt *authctxt ;
  int authenticated ;
  u_int nresp ;
  u_int rlen ;
  char *response ;
  char *method ;
  int _len ;
  int tmp ;
  char *challenge ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
#line 77
  authctxt = (Authctxt *)ctxt;
#line 78
  authenticated = 0;
#line 80
  method = (char *)"challenge-reponse";
#line 82
  if ((unsigned int )authctxt == (unsigned int )((void *)0)) {
#line 83
    fatal("input_userauth_info_response: no authctxt");
  }
#line 85
  authctxt->postponed = 0;
#line 86
  nresp = packet_get_int();
#line 87
  if (nresp == 1U) {
#line 88
    response = packet_get_string(& rlen);
#line 89
    while (1) {
#line 89
      tmp = packet_remaining();
#line 89
      _len = tmp;
#line 89
      if (_len > 0) {
#line 89
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2-chall.c",
            89);
#line 89
        packet_disconnect("Packet integrity error.");
      }
#line 89
      break;
    }
#line 90
    tmp___1 = strlen((char const   *)response);
#line 90
    if (tmp___1 == 0U) {
#line 95
      tmp___0 = get_challenge(authctxt, (char *)((void *)0));
#line 95
      challenge = tmp___0;
#line 96
      if ((unsigned int )challenge != (unsigned int )((void *)0)) {
#line 97
        send_userauth_into_request(authctxt, challenge, 1);
#line 99
        authctxt->postponed = 1;
      }
    } else {
#line 101
      if (authctxt->valid) {
#line 102
        authenticated = verify_response(authctxt, response);
#line 103
        memset((void *)response, 'r', rlen);
      }
    }
#line 105
    xfree((void *)response);
  }
#line 108
  if (! authctxt->postponed) {
#line 109
    dispatch_set(61, (dispatch_fn *)((void *)0));
  }
#line 111
  userauth_finish(authctxt, authenticated, method);
#line 112
  return;
}
}
#line 1 "auth-rhosts.o"
#pragma merger(0,"./auth-rhosts.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 418 "/usr/include/netdb.h"
extern int innetgr(char const   *__netgroup , char const   *__host , char const   *__user ,
                   char const   *domain ) ;
#line 37 "auth-rhosts.c"
int check_rhosts_file(char const   *filename , char const   *hostname , char const   *ipaddr ,
                      char const   *client_user , char const   *server_user ) 
{ FILE *f ;
  char buf___2[1024] ;
  char hostbuf[1024] ;
  char userbuf[1024] ;
  char dummy[1024] ;
  char *host ;
  char *user ;
  char *cp ;
  int negated ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___45 ;
  int tmp___48 ;
  int tmp___49 ;
  char *tmp___50 ;

  {
#line 46
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 47
  if (! f) {
#line 48
    return (0);
  }
#line 50
  while (1) {
#line 50
    tmp___50 = fgets((char * __restrict  )(buf___2), (int )sizeof(buf___2), (FILE * __restrict  )f);
#line 50
    if (! tmp___50) {
#line 50
      break;
    }
#line 55
    cp = buf___2;
#line 55
    while (1) {
#line 55
      if (! ((int )*cp == 32)) {
#line 55
        if (! ((int )*cp == 9)) {
#line 55
          break;
        }
      }
#line 55
      cp ++;
    }
#line 57
    if ((int )*cp == 35) {
#line 58
      continue;
    } else {
#line 57
      if ((int )*cp == 10) {
#line 58
        continue;
      } else {
#line 57
        if (! *cp) {
#line 58
          continue;
        }
      }
    }
#line 64
    if (0) {
#line 64
      if (0) {
#line 64
        __s1_len___0 = strlen((char const   *)cp);
#line 64
        __s2_len___0 = strlen("NO_PLUS");
#line 64
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___2;
        } else {
#line 64
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 64
            if (! ((unsigned int )((void const   *)("NO_PLUS" + 1)) - (unsigned int )((void const   *)"NO_PLUS") == 1U)) {
#line 64
              tmp___22 = 1;
            } else {
#line 64
              if (__s2_len___0 >= 4U) {
#line 64
                tmp___22 = 1;
              } else {
#line 64
                tmp___22 = 0;
              }
            }
          } else {
#line 64
            tmp___22 = 0;
          }
        }
#line 64
        if (tmp___22) {
#line 64
          tmp___18 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
        } else {
#line 64
          tmp___21 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 64
          tmp___18 = tmp___21;
        }
      } else {
#line 64
        tmp___21 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 64
        tmp___18 = tmp___21;
      }
#line 64
      tmp___12 = tmp___18;
    } else {
#line 64
      tmp___12 = strncmp((char const   *)cp, "NO_PLUS", 7U);
    }
#line 64
    if (tmp___12 == 0) {
#line 65
      continue;
    }
#line 71
    tmp___25 = sscanf((char const   * __restrict  )(buf___2), (char const   * __restrict  )"%s %s %s",
                      hostbuf, userbuf, dummy);
#line 71
    switch (tmp___25) {
    case 0: 
#line 73
    packet_send_debug("Found empty line in %.100s.", filename);
#line 74
    continue;
    case 1: 
#line 77
    strlcpy(userbuf, server_user, sizeof(userbuf));
#line 78
    break;
    case 2: 
#line 81
    break;
    case 3: 
#line 83
    packet_send_debug("Found garbage in %.100s.", filename);
#line 84
    continue;
    default: ;
#line 87
    continue;
    }
#line 90
    host = hostbuf;
#line 91
    user = userbuf;
#line 92
    negated = 0;
#line 95
    if ((int )*(host + 0) == 45) {
#line 96
      negated = 1;
#line 97
      host ++;
    } else {
#line 98
      if ((int )*(host + 0) == 43) {
#line 99
        host ++;
      }
    }
#line 101
    if ((int )*(user + 0) == 45) {
#line 102
      negated = 1;
#line 103
      user ++;
    } else {
#line 104
      if ((int )*(user + 0) == 43) {
#line 105
        user ++;
      }
    }
#line 108
    if (! *(host + 0)) {
#line 110
      packet_send_debug("Ignoring wild host/user names in %.100s.", filename);
#line 112
      continue;
    } else {
#line 108
      if (! *(user + 0)) {
#line 110
        packet_send_debug("Ignoring wild host/user names in %.100s.", filename);
#line 112
        continue;
      }
    }
#line 115
    if ((int )*(host + 0) == 64) {
#line 116
      tmp___26 = innetgr((char const   *)(host + 1), hostname, (char const   *)((void *)0),
                         (char const   *)((void *)0));
#line 116
      if (! tmp___26) {
#line 116
        tmp___27 = innetgr((char const   *)(host + 1), ipaddr, (char const   *)((void *)0),
                           (char const   *)((void *)0));
#line 116
        if (! tmp___27) {
#line 118
          continue;
        }
      }
    } else {
#line 119
      tmp___28 = strcasecmp((char const   *)host, hostname);
#line 119
      if (tmp___28) {
#line 119
        if (0) {
#line 119
          __s1_len___1 = strlen((char const   *)host);
#line 119
          __s2_len___1 = strlen(ipaddr);
#line 119
          if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
            goto _L___4;
          } else {
#line 119
            if (__s1_len___1 >= 4U) {
              _L___4: /* CIL Label */ 
#line 119
              if (! ((unsigned int )((void const   *)(ipaddr + 1)) - (unsigned int )((void const   *)ipaddr) == 1U)) {
#line 119
                tmp___38 = 1;
              } else {
#line 119
                if (__s2_len___1 >= 4U) {
#line 119
                  tmp___38 = 1;
                } else {
#line 119
                  tmp___38 = 0;
                }
              }
            } else {
#line 119
              tmp___38 = 0;
            }
          }
#line 119
          if (tmp___38) {
#line 119
            tmp___34 = __builtin_strcmp((char const   *)host, ipaddr);
          } else {
#line 119
            tmp___37 = __builtin_strcmp((char const   *)host, ipaddr);
#line 119
            tmp___34 = tmp___37;
          }
        } else {
#line 119
          tmp___37 = __builtin_strcmp((char const   *)host, ipaddr);
#line 119
          tmp___34 = tmp___37;
        }
#line 119
        if (tmp___34 != 0) {
#line 120
          continue;
        }
      }
    }
#line 123
    if ((int )*(user + 0) == 64) {
#line 124
      tmp___39 = innetgr((char const   *)(user + 1), (char const   *)((void *)0),
                         client_user, (char const   *)((void *)0));
#line 124
      if (! tmp___39) {
#line 125
        continue;
      }
    } else {
#line 126
      if (0) {
#line 126
        __s1_len___2 = strlen((char const   *)user);
#line 126
        __s2_len___2 = strlen(client_user);
#line 126
        if (! ((unsigned int )((void const   *)(user + 1)) - (unsigned int )((void const   *)user) == 1U)) {
          goto _L___6;
        } else {
#line 126
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 126
            if (! ((unsigned int )((void const   *)(client_user + 1)) - (unsigned int )((void const   *)client_user) == 1U)) {
#line 126
              tmp___49 = 1;
            } else {
#line 126
              if (__s2_len___2 >= 4U) {
#line 126
                tmp___49 = 1;
              } else {
#line 126
                tmp___49 = 0;
              }
            }
          } else {
#line 126
            tmp___49 = 0;
          }
        }
#line 126
        if (tmp___49) {
#line 126
          tmp___45 = __builtin_strcmp((char const   *)user, client_user);
        } else {
#line 126
          tmp___48 = __builtin_strcmp((char const   *)user, client_user);
#line 126
          tmp___45 = tmp___48;
        }
      } else {
#line 126
        tmp___48 = __builtin_strcmp((char const   *)user, client_user);
#line 126
        tmp___45 = tmp___48;
      }
#line 126
      if (tmp___45 != 0) {
#line 127
        continue;
      }
    }
#line 130
    fclose(f);
#line 133
    if (negated) {
#line 134
      packet_send_debug("Matched negative entry in %.100s.", filename);
#line 136
      return (0);
    }
#line 139
    return (1);
  }
#line 143
  fclose(f);
#line 144
  return (0);
}
}
#line 153 "auth-rhosts.c"
int auth_rhosts(struct passwd *pw , char const   *client_user ) 
{ char const   *hostname ;
  char const   *ipaddr ;
  int ret ;

  {
#line 159
  hostname = get_canonical_hostname(options.reverse_mapping_check);
#line 160
  ipaddr = get_remote_ipaddr();
#line 161
  ret = auth_rhosts2(pw, client_user, hostname, ipaddr);
#line 162
  return (ret);
}
}
#line 171 "auth-rhosts.c"
static char const   *rhosts_files[3]  = {      ".shosts",      ".rhosts",      (char const   *)((void *)0)};
#line 165 "auth-rhosts.c"
int auth_rhosts2(struct passwd *pw , char const   *client_user , char const   *hostname ,
                 char const   *ipaddr ) 
{ char buf___2[1024] ;
  struct stat st ;
  u_int rhosts_file_index ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 174
  debug2("auth_rhosts2: clientuser %s hostname %s ipaddr %s", client_user, hostname,
         ipaddr);
#line 178
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 179
    return (0);
  }
#line 182
  temporarily_use_uid(pw);
#line 188
  rhosts_file_index = 0U;
#line 188
  while (rhosts_files[rhosts_file_index]) {
#line 191
    snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"%.500s/%.100s",
             pw->pw_dir, rhosts_files[rhosts_file_index]);
#line 193
    tmp = stat((char const   * __restrict  )(buf___2), (struct stat * __restrict  )(& st));
#line 193
    if (tmp >= 0) {
#line 194
      break;
    }
#line 188
    rhosts_file_index ++;
  }
#line 197
  restore_uid();
#line 200
  if (! rhosts_files[rhosts_file_index]) {
#line 200
    tmp___0 = stat((char const   * __restrict  )"/etc/hosts.equiv", (struct stat * __restrict  )(& st));
#line 200
    if (tmp___0 < 0) {
#line 200
      tmp___1 = stat((char const   * __restrict  )"/usr/local/etc/shosts.equiv", (struct stat * __restrict  )(& st));
#line 200
      if (tmp___1 < 0) {
#line 203
        return (0);
      }
    }
  }
#line 206
  if (pw->pw_uid != 0U) {
#line 207
    tmp___2 = check_rhosts_file("/etc/hosts.equiv", hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 207
    if (tmp___2) {
#line 209
      packet_send_debug("Accepted for %.100s [%.100s] by /etc/hosts.equiv.", hostname,
                        ipaddr);
#line 211
      return (1);
    }
#line 213
    tmp___3 = check_rhosts_file("/usr/local/etc/shosts.equiv", hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 213
    if (tmp___3) {
#line 215
      packet_send_debug("Accepted for %.100s [%.100s] by %.100s.", hostname, ipaddr,
                        "/usr/local/etc/shosts.equiv");
#line 217
      return (1);
    }
  }
#line 224
  tmp___4 = stat((char const   * __restrict  )pw->pw_dir, (struct stat * __restrict  )(& st));
#line 224
  if (tmp___4 < 0) {
#line 225
    log("Rhosts authentication refused for %.100s: no home directory %.200s", pw->pw_name,
        pw->pw_dir);
#line 227
    packet_send_debug("Rhosts authentication refused for %.100s: no home directory %.200s",
                      pw->pw_name, pw->pw_dir);
#line 229
    return (0);
  }
#line 231
  if (options.strict_modes) {
#line 231
    if (st.st_uid != 0U) {
#line 231
      if (st.st_uid != pw->pw_uid) {
#line 234
        log("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
            pw->pw_name);
#line 236
        packet_send_debug("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                          pw->pw_name);
#line 238
        return (0);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 231
      if ((st.st_mode & 18U) != 0U) {
#line 234
        log("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
            pw->pw_name);
#line 236
        packet_send_debug("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                          pw->pw_name);
#line 238
        return (0);
      }
    }
  }
#line 241
  temporarily_use_uid(pw);
#line 244
  rhosts_file_index = 0U;
#line 244
  while (rhosts_files[rhosts_file_index]) {
#line 247
    snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"%.500s/%.100s",
             pw->pw_dir, rhosts_files[rhosts_file_index]);
#line 249
    tmp___5 = stat((char const   * __restrict  )(buf___2), (struct stat * __restrict  )(& st));
#line 249
    if (tmp___5 < 0) {
      goto __Cont;
    }
#line 258
    if (options.strict_modes) {
#line 258
      if (st.st_uid != 0U) {
#line 258
        if (st.st_uid != pw->pw_uid) {
#line 261
          log("Rhosts authentication refused for %.100s: bad modes for %.200s", pw->pw_name,
              buf___2);
#line 263
          packet_send_debug("Bad file modes for %.200s", buf___2);
          goto __Cont;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 258
        if ((st.st_mode & 18U) != 0U) {
#line 261
          log("Rhosts authentication refused for %.100s: bad modes for %.200s", pw->pw_name,
              buf___2);
#line 263
          packet_send_debug("Bad file modes for %.200s", buf___2);
          goto __Cont;
        }
      }
    }
#line 267
    if (options.ignore_rhosts) {
#line 268
      packet_send_debug("Server has been configured to ignore %.100s.", rhosts_files[rhosts_file_index]);
      goto __Cont;
    }
#line 273
    tmp___6 = check_rhosts_file((char const   *)(buf___2), hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 273
    if (tmp___6) {
#line 274
      packet_send_debug("Accepted by %.100s.", rhosts_files[rhosts_file_index]);
#line 277
      restore_uid();
#line 278
      return (1);
    }
    __Cont: /* CIL Label */ 
#line 244
    rhosts_file_index ++;
  }
#line 283
  restore_uid();
#line 284
  return (0);
}
}
#line 1 "auth-options.o"
#pragma merger(0,"./auth-options.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 329 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 184 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 26 "auth-options.h"
int no_port_forwarding_flag ;
#line 27
int no_agent_forwarding_flag ;
#line 28
int no_x11_forwarding_flag ;
#line 29
int no_pty_flag ;
#line 31
struct envstring *custom_environment ;
#line 25 "auth-options.c"
int no_port_forwarding_flag  =    0;
#line 26 "auth-options.c"
int no_agent_forwarding_flag  =    0;
#line 27 "auth-options.c"
int no_x11_forwarding_flag  =    0;
#line 28 "auth-options.c"
int no_pty_flag  =    0;
#line 31 "auth-options.c"
char *forced_command  =    (char *)((void *)0);
#line 34 "auth-options.c"
struct envstring *custom_environment  =    (struct envstring *)((void *)0);
#line 38 "auth-options.c"
void auth_clear_options(void) 
{ struct envstring *ce ;

  {
#line 41
  no_agent_forwarding_flag = 0;
#line 42
  no_port_forwarding_flag = 0;
#line 43
  no_pty_flag = 0;
#line 44
  no_x11_forwarding_flag = 0;
#line 45
  while (custom_environment) {
#line 46
    ce = custom_environment;
#line 47
    custom_environment = ce->next;
#line 48
    xfree((void *)ce->s);
#line 49
    xfree((void *)ce);
  }
#line 51
  if (forced_command) {
#line 52
    xfree((void *)forced_command);
#line 53
    forced_command = (char *)((void *)0);
  }
#line 55
  channel_clear_permitted_opens();
#line 56
  return;
}
}
#line 62 "auth-options.c"
int auth_parse_options(struct passwd *pw , char *opts , char *file , u_long linenum ) 
{ char const   *cp ;
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  size_t tmp___17 ;
  int tmp___18 ;
  char *s ;
  struct envstring *new_envstring ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  void *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  void *tmp___25 ;
  size_t tmp___26 ;
  int tmp___27 ;
  int mname ;
  int mip ;
  char const   *remote_ip ;
  char const   *tmp___28 ;
  char const   *remote_host ;
  char const   *tmp___29 ;
  char *patterns ;
  size_t tmp___30 ;
  void *tmp___31 ;
  size_t tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  char *tmp___35 ;
  size_t tmp___36 ;
  size_t tmp___37 ;
  size_t tmp___38 ;
  int tmp___39 ;
  u_short port ;
  char *c ;
  char *ep ;
  char *patterns___0 ;
  size_t tmp___40 ;
  void *tmp___41 ;
  size_t tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  char *tmp___45 ;
  char *tmp___47 ;
  long tmp___48 ;
  size_t tmp___49 ;
  int tmp___50 ;

  {
#line 69
  auth_clear_options();
#line 71
  if (! opts) {
#line 72
    return (1);
  }
#line 74
  while (1) {
#line 74
    if (*opts) {
#line 74
      if ((int )*opts != 32) {
#line 74
        if (! ((int )*opts != 9)) {
#line 74
          break;
        }
      } else {
#line 74
        break;
      }
    } else {
#line 74
      break;
    }
#line 75
    cp = "no-port-forwarding";
#line 76
    tmp___0 = strlen(cp);
#line 76
    tmp___1 = strncasecmp((char const   *)opts, cp, tmp___0);
#line 76
    if (tmp___1 == 0) {
#line 77
      packet_send_debug("Port forwarding disabled.");
#line 78
      no_port_forwarding_flag = 1;
#line 79
      tmp = strlen(cp);
#line 79
      opts += tmp;
      goto next_option;
    }
#line 82
    cp = "no-agent-forwarding";
#line 83
    tmp___3 = strlen(cp);
#line 83
    tmp___4 = strncasecmp((char const   *)opts, cp, tmp___3);
#line 83
    if (tmp___4 == 0) {
#line 84
      packet_send_debug("Agent forwarding disabled.");
#line 85
      no_agent_forwarding_flag = 1;
#line 86
      tmp___2 = strlen(cp);
#line 86
      opts += tmp___2;
      goto next_option;
    }
#line 89
    cp = "no-X11-forwarding";
#line 90
    tmp___6 = strlen(cp);
#line 90
    tmp___7 = strncasecmp((char const   *)opts, cp, tmp___6);
#line 90
    if (tmp___7 == 0) {
#line 91
      packet_send_debug("X11 forwarding disabled.");
#line 92
      no_x11_forwarding_flag = 1;
#line 93
      tmp___5 = strlen(cp);
#line 93
      opts += tmp___5;
      goto next_option;
    }
#line 96
    cp = "no-pty";
#line 97
    tmp___9 = strlen(cp);
#line 97
    tmp___10 = strncasecmp((char const   *)opts, cp, tmp___9);
#line 97
    if (tmp___10 == 0) {
#line 98
      packet_send_debug("Pty allocation disabled.");
#line 99
      no_pty_flag = 1;
#line 100
      tmp___8 = strlen(cp);
#line 100
      opts += tmp___8;
      goto next_option;
    }
#line 103
    cp = "command=\"";
#line 104
    tmp___17 = strlen(cp);
#line 104
    tmp___18 = strncasecmp((char const   *)opts, cp, tmp___17);
#line 104
    if (tmp___18 == 0) {
#line 105
      tmp___11 = strlen(cp);
#line 105
      opts += tmp___11;
#line 106
      tmp___12 = strlen((char const   *)opts);
#line 106
      tmp___13 = xmalloc(tmp___12 + 1U);
#line 106
      forced_command = (char *)tmp___13;
#line 107
      i = 0;
#line 108
      while (*opts) {
#line 109
        if ((int )*opts == 34) {
#line 110
          break;
        }
#line 111
        if ((int )*opts == 92) {
#line 111
          if ((int )*(opts + 1) == 34) {
#line 112
            opts += 2;
#line 113
            tmp___14 = i;
#line 113
            i ++;
#line 113
            *(forced_command + tmp___14) = (char )'\"';
#line 114
            continue;
          }
        }
#line 116
        tmp___15 = i;
#line 116
        i ++;
#line 116
        tmp___16 = opts;
#line 116
        opts ++;
#line 116
        *(forced_command + tmp___15) = *tmp___16;
      }
#line 118
      if (! *opts) {
#line 119
        debug("%.100s, line %lu: missing end quote", file, linenum);
#line 121
        packet_send_debug("%.100s, line %lu: missing end quote", file, linenum);
#line 123
        xfree((void *)forced_command);
#line 124
        forced_command = (char *)((void *)0);
        goto bad_option;
      }
#line 127
      *(forced_command + i) = (char)0;
#line 128
      packet_send_debug("Forced command: %.900s", forced_command);
#line 129
      opts ++;
      goto next_option;
    }
#line 132
    cp = "environment=\"";
#line 133
    tmp___26 = strlen(cp);
#line 133
    tmp___27 = strncasecmp((char const   *)opts, cp, tmp___26);
#line 133
    if (tmp___27 == 0) {
#line 137
      tmp___19 = strlen(cp);
#line 137
      opts += tmp___19;
#line 138
      tmp___20 = strlen((char const   *)opts);
#line 138
      tmp___21 = xmalloc(tmp___20 + 1U);
#line 138
      s = (char *)tmp___21;
#line 139
      i = 0;
#line 140
      while (*opts) {
#line 141
        if ((int )*opts == 34) {
#line 142
          break;
        }
#line 143
        if ((int )*opts == 92) {
#line 143
          if ((int )*(opts + 1) == 34) {
#line 144
            opts += 2;
#line 145
            tmp___22 = i;
#line 145
            i ++;
#line 145
            *(s + tmp___22) = (char )'\"';
#line 146
            continue;
          }
        }
#line 148
        tmp___23 = i;
#line 148
        i ++;
#line 148
        tmp___24 = opts;
#line 148
        opts ++;
#line 148
        *(s + tmp___23) = *tmp___24;
      }
#line 150
      if (! *opts) {
#line 151
        debug("%.100s, line %lu: missing end quote", file, linenum);
#line 153
        packet_send_debug("%.100s, line %lu: missing end quote", file, linenum);
#line 155
        xfree((void *)s);
        goto bad_option;
      }
#line 158
      *(s + i) = (char)0;
#line 159
      packet_send_debug("Adding to environment: %.900s", s);
#line 160
      debug("Adding to environment: %.900s", s);
#line 161
      opts ++;
#line 162
      tmp___25 = xmalloc(sizeof(struct envstring ));
#line 162
      new_envstring = (struct envstring *)tmp___25;
#line 163
      new_envstring->s = s;
#line 164
      new_envstring->next = custom_environment;
#line 165
      custom_environment = new_envstring;
      goto next_option;
    }
#line 168
    cp = "from=\"";
#line 169
    tmp___38 = strlen(cp);
#line 169
    tmp___39 = strncasecmp((char const   *)opts, cp, tmp___38);
#line 169
    if (tmp___39 == 0) {
#line 171
      tmp___28 = get_remote_ipaddr();
#line 171
      remote_ip = tmp___28;
#line 172
      tmp___29 = get_canonical_hostname(options.reverse_mapping_check);
#line 172
      remote_host = tmp___29;
#line 174
      tmp___30 = strlen((char const   *)opts);
#line 174
      tmp___31 = xmalloc(tmp___30 + 1U);
#line 174
      patterns = (char *)tmp___31;
#line 176
      tmp___32 = strlen(cp);
#line 176
      opts += tmp___32;
#line 177
      i = 0;
#line 178
      while (*opts) {
#line 179
        if ((int )*opts == 34) {
#line 180
          break;
        }
#line 181
        if ((int )*opts == 92) {
#line 181
          if ((int )*(opts + 1) == 34) {
#line 182
            opts += 2;
#line 183
            tmp___33 = i;
#line 183
            i ++;
#line 183
            *(patterns + tmp___33) = (char )'\"';
#line 184
            continue;
          }
        }
#line 186
        tmp___34 = i;
#line 186
        i ++;
#line 186
        tmp___35 = opts;
#line 186
        opts ++;
#line 186
        *(patterns + tmp___34) = *tmp___35;
      }
#line 188
      if (! *opts) {
#line 189
        debug("%.100s, line %lu: missing end quote", file, linenum);
#line 191
        packet_send_debug("%.100s, line %lu: missing end quote", file, linenum);
#line 193
        xfree((void *)patterns);
        goto bad_option;
      }
#line 196
      *(patterns + i) = (char)0;
#line 197
      opts ++;
#line 203
      tmp___36 = strlen((char const   *)patterns);
#line 203
      mname = match_hostname(remote_host, (char const   *)patterns, tmp___36);
#line 205
      tmp___37 = strlen((char const   *)patterns);
#line 205
      mip = match_hostname(remote_ip, (char const   *)patterns, tmp___37);
#line 207
      xfree((void *)patterns);
#line 208
      if (mname == -1) {
#line 210
        log("Authentication tried for %.100s with correct key but not from a permitted host (host=%.200s, ip=%.200s).",
            pw->pw_name, remote_host, remote_ip);
#line 214
        packet_send_debug("Your host \'%.200s\' is not permitted to use this key for login.",
                          remote_host);
#line 218
        return (0);
      } else {
#line 208
        if (mip == -1) {
#line 210
          log("Authentication tried for %.100s with correct key but not from a permitted host (host=%.200s, ip=%.200s).",
              pw->pw_name, remote_host, remote_ip);
#line 214
          packet_send_debug("Your host \'%.200s\' is not permitted to use this key for login.",
                            remote_host);
#line 218
          return (0);
        } else {
#line 208
          if (mname != 1) {
#line 208
            if (mip != 1) {
#line 210
              log("Authentication tried for %.100s with correct key but not from a permitted host (host=%.200s, ip=%.200s).",
                  pw->pw_name, remote_host, remote_ip);
#line 214
              packet_send_debug("Your host \'%.200s\' is not permitted to use this key for login.",
                                remote_host);
#line 218
              return (0);
            }
          }
        }
      }
      goto next_option;
    }
#line 223
    cp = "permitopen=\"";
#line 224
    tmp___49 = strlen(cp);
#line 224
    tmp___50 = strncasecmp((char const   *)opts, cp, tmp___49);
#line 224
    if (tmp___50 == 0) {
#line 227
      tmp___40 = strlen((char const   *)opts);
#line 227
      tmp___41 = xmalloc(tmp___40 + 1U);
#line 227
      patterns___0 = (char *)tmp___41;
#line 229
      tmp___42 = strlen(cp);
#line 229
      opts += tmp___42;
#line 230
      i = 0;
#line 231
      while (*opts) {
#line 232
        if ((int )*opts == 34) {
#line 233
          break;
        }
#line 234
        if ((int )*opts == 92) {
#line 234
          if ((int )*(opts + 1) == 34) {
#line 235
            opts += 2;
#line 236
            tmp___43 = i;
#line 236
            i ++;
#line 236
            *(patterns___0 + tmp___43) = (char )'\"';
#line 237
            continue;
          }
        }
#line 239
        tmp___44 = i;
#line 239
        i ++;
#line 239
        tmp___45 = opts;
#line 239
        opts ++;
#line 239
        *(patterns___0 + tmp___44) = *tmp___45;
      }
#line 241
      if (! *opts) {
#line 242
        debug("%.100s, line %lu: missing end quote", file, linenum);
#line 244
        packet_send_debug("%.100s, line %lu: missing end quote", file, linenum);
#line 246
        xfree((void *)patterns___0);
        goto bad_option;
      }
#line 249
      *(patterns___0 + i) = (char)0;
#line 250
      opts ++;
#line 251
      tmp___47 = __builtin_strchr(patterns___0, ':');
#line 251
      c = tmp___47;
#line 252
      if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 253
        debug("%.100s, line %lu: permitopen: missing colon <%.100s>", file, linenum,
              patterns___0);
#line 255
        packet_send_debug("%.100s, line %lu: missing colon", file, linenum);
#line 257
        xfree((void *)patterns___0);
        goto bad_option;
      }
#line 260
      *c = (char)0;
#line 261
      c ++;
#line 262
      tmp___48 = strtol((char const   * __restrict  )c, (char ** __restrict  )(& ep),
                        0);
#line 262
      port = (unsigned short )tmp___48;
#line 263
      if ((unsigned int )c == (unsigned int )ep) {
#line 264
        debug("%.100s, line %lu: permitopen: missing port <%.100s>", file, linenum,
              patterns___0);
#line 266
        packet_send_debug("%.100s, line %lu: missing port", file, linenum);
#line 268
        xfree((void *)patterns___0);
        goto bad_option;
      }
#line 271
      if (options.allow_tcp_forwarding) {
#line 272
        channel_add_permitted_opens(patterns___0, (int )port);
      }
#line 273
      xfree((void *)patterns___0);
      goto next_option;
    }
    next_option: 
#line 281
    if (! *opts) {
#line 282
      fatal("Bugs in auth-options.c option processing.");
    }
#line 283
    if ((int )*opts == 32) {
#line 284
      break;
    } else {
#line 283
      if ((int )*opts == 9) {
#line 284
        break;
      }
    }
#line 285
    if ((int )*opts != 44) {
      goto bad_option;
    }
#line 287
    opts ++;
  }
#line 291
  return (1);
  bad_option: 
#line 294
  log("Bad options in %.100s file, line %lu: %.50s", file, linenum, opts);
#line 296
  packet_send_debug("Bad options in %.100s file, line %lu: %.50s", file, linenum,
                    opts);
#line 299
  return (0);
}
}
#line 1 "auth-krb4.o"
#pragma merger(0,"./auth-krb4.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "auth-pam.o"
#pragma merger(0,"./auth-pam.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "auth2-pam.o"
#pragma merger(0,"./auth2-pam.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "auth-passwd.o"
#pragma merger(0,"./auth-passwd.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 33 "/usr/include/crypt.h"
extern  __attribute__((__nothrow__)) char *crypt(char const   *__key , char const   *__salt )  __attribute__((__nonnull__(1,2))) ;
#line 90 "auth-passwd.c"
int auth_password(Authctxt *authctxt , char const   *password ) 
{ struct passwd *pw ;
  char *encrypted_password ;
  char *pw_password ;
  char *salt ;
  struct spwd *spw ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 93
  pw = authctxt->pw;
#line 116
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 117
    return (0);
  }
#line 119
  if (pw->pw_uid == 0U) {
#line 119
    if (options.permit_root_login != 3) {
#line 120
      return (0);
    }
  }
#line 129
  if ((int const   )*password == 0) {
#line 129
    if (options.permit_empty_passwd == 0) {
#line 130
      return (0);
    }
  }
#line 164
  pw_password = pw->pw_passwd;
#line 170
  spw = getspnam((char const   *)pw->pw_name);
#line 171
  if ((unsigned int )spw != (unsigned int )((void *)0)) {
#line 172
    pw_password = spw->sp_pwdp;
  }
#line 192
  if ((int const   )*(password + 0) == 0) {
#line 192
    if ((int )*(pw_password + 0) == 0) {
#line 193
      return (1);
    }
  }
#line 195
  if ((int )*(pw_password + 0) != 0) {
#line 196
    salt = pw_password;
  } else {
#line 198
    salt = (char *)"xx";
  }
#line 212
  encrypted_password = crypt(password, (char const   *)salt);
#line 217
  if (0) {
#line 217
    __s1_len = strlen((char const   *)encrypted_password);
#line 217
    __s2_len = strlen((char const   *)pw_password);
#line 217
    if (! ((unsigned int )((void const   *)(encrypted_password + 1)) - (unsigned int )((void const   *)encrypted_password) == 1U)) {
      goto _L___0;
    } else {
#line 217
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 217
        if (! ((unsigned int )((void const   *)(pw_password + 1)) - (unsigned int )((void const   *)pw_password) == 1U)) {
#line 217
          tmp___8 = 1;
        } else {
#line 217
          if (__s2_len >= 4U) {
#line 217
            tmp___8 = 1;
          } else {
#line 217
            tmp___8 = 0;
          }
        }
      } else {
#line 217
        tmp___8 = 0;
      }
    }
#line 217
    if (tmp___8) {
#line 217
      tmp___4 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)pw_password);
    } else {
#line 217
      tmp___7 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)pw_password);
#line 217
      tmp___4 = tmp___7;
    }
  } else {
#line 217
    tmp___7 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)pw_password);
#line 217
    tmp___4 = tmp___7;
  }
#line 217
  return (tmp___4 == 0);
}
}
#line 1 "auth-rsa.o"
#pragma merger(0,"./auth-rsa.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 212
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 97 "auth.h"
int auth_rsa_challenge_dialog(RSA *pk ) ;
#line 60 "auth-rsa.c"
int auth_rsa_challenge_dialog(RSA *pk ) 
{ BIGNUM *challenge ;
  BIGNUM *encrypted_challenge ;
  BN_CTX *ctx ;
  u_char buf___2[32] ;
  u_char mdbuf[16] ;
  u_char response[16] ;
  MD5_CTX md ;
  u_int i ;
  int plen ;
  int len ;
  int _p ;
  int _e ;
  u_int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 70
  encrypted_challenge = BN_new();
#line 71
  challenge = BN_new();
#line 74
  BN_rand(challenge, 256, 0, 0);
#line 75
  ctx = BN_CTX_new();
#line 76
  BN_div((BIGNUM *)((void *)0), challenge, (BIGNUM const   *)challenge, (BIGNUM const   *)pk->n,
         ctx);
#line 77
  BN_CTX_free(ctx);
#line 80
  rsa_public_encrypt(encrypted_challenge, challenge, pk);
#line 83
  packet_start(7);
#line 84
  packet_put_bignum(encrypted_challenge);
#line 85
  packet_send();
#line 86
  BN_clear_free(encrypted_challenge);
#line 87
  packet_write_wait();
#line 90
  packet_read_expect(& plen, 8);
#line 91
  while (1) {
#line 91
    _p = plen;
#line 91
    _e = 16;
#line 91
    if (_p != _e) {
#line 91
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "auth-rsa.c", 91);
#line 91
      packet_disconnect("Packet integrity error. (%d)", 8);
    }
#line 91
    break;
  }
#line 92
  i = 0U;
#line 92
  while (i < 16U) {
#line 93
    tmp = packet_get_char();
#line 93
    response[i] = (unsigned char )tmp;
#line 92
    i ++;
  }
#line 96
  tmp___0 = BN_num_bits((BIGNUM const   *)challenge);
#line 96
  len = (tmp___0 + 7) / 8;
#line 97
  if (len <= 0) {
#line 98
    fatal("auth_rsa_challenge_dialog: bad challenge length %d", len);
  } else {
#line 97
    if (len > 32) {
#line 98
      fatal("auth_rsa_challenge_dialog: bad challenge length %d", len);
    }
  }
#line 99
  memset((void *)(buf___2), 0, 32U);
#line 100
  BN_bn2bin((BIGNUM const   *)challenge, (buf___2 + 32) - len);
#line 101
  MD5_Init(& md);
#line 102
  MD5_Update(& md, (void const   *)(buf___2), 32U);
#line 103
  MD5_Update(& md, (void const   *)(session_id), 16U);
#line 104
  MD5_Final(mdbuf, & md);
#line 105
  BN_clear_free(challenge);
#line 108
  tmp___1 = memcmp((void const   *)(response), (void const   *)(mdbuf), 16U);
#line 108
  if (tmp___1 != 0) {
#line 110
    return (0);
  }
#line 113
  return (1);
}
}
#line 172 "auth-rsa.c"
static char const   *check___1[3]  = {      "",      ".ssh",      (char const   *)((void *)0)};
#line 122 "auth-rsa.c"
int auth_rsa(struct passwd *pw , BIGNUM *client_n ) 
{ char line[8192] ;
  char file[4096] ;
  int authenticated ;
  u_int bits ;
  FILE *f ;
  u_long linenum ;
  struct stat st ;
  RSA *pk ;
  int tmp ;
  int fail ;
  char buf___2[1024] ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *cp ;
  char *options___0 ;
  int quoted ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;

  {
#line 129
  linenum = (u_long )0;
#line 134
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 135
    return (0);
  }
#line 138
  temporarily_use_uid(pw);
#line 141
  snprintf((char * __restrict  )(file), sizeof(file), (char const   * __restrict  )"%.500s/%.100s",
           pw->pw_dir, ".ssh/authorized_keys");
#line 145
  tmp = stat((char const   * __restrict  )(file), (struct stat * __restrict  )(& st));
#line 145
  if (tmp < 0) {
#line 147
    restore_uid();
#line 148
    return (0);
  }
#line 151
  f = fopen((char const   * __restrict  )(file), (char const   * __restrict  )"r");
#line 152
  if (! f) {
#line 154
    restore_uid();
#line 155
    packet_send_debug("Could not open %.900s for reading.", file);
#line 156
    packet_send_debug("If your home is on an NFS volume, it may need to be world-readable.");
#line 157
    return (0);
  }
#line 159
  if (options.strict_modes) {
#line 160
    fail = 0;
#line 163
    tmp___1 = fileno(f);
#line 163
    tmp___2 = fstat(tmp___1, & st);
#line 163
    if (tmp___2 < 0) {
#line 166
      snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
               pw->pw_name, file);
#line 168
      fail = 1;
    } else {
#line 163
      if (st.st_uid != 0U) {
#line 163
        if (st.st_uid != pw->pw_uid) {
#line 166
          snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   pw->pw_name, file);
#line 168
          fail = 1;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 163
        if ((st.st_mode & 18U) != 0U) {
#line 166
          snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   pw->pw_name, file);
#line 168
          fail = 1;
        } else {
#line 175
          i = 0;
#line 175
          while (check___1[i]) {
#line 176
            snprintf((char * __restrict  )(line), sizeof(line), (char const   * __restrict  )"%.500s/%.100s",
                     pw->pw_dir, check___1[i]);
#line 177
            tmp___0 = stat((char const   * __restrict  )(line), (struct stat * __restrict  )(& st));
#line 177
            if (tmp___0 < 0) {
#line 180
              snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                       pw->pw_name, line);
#line 182
              fail = 1;
#line 183
              break;
            } else {
#line 177
              if (st.st_uid != 0U) {
#line 177
                if (st.st_uid != pw->pw_uid) {
#line 180
                  snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           pw->pw_name, line);
#line 182
                  fail = 1;
#line 183
                  break;
                } else {
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
#line 177
                if ((st.st_mode & 18U) != 0U) {
#line 180
                  snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           pw->pw_name, line);
#line 182
                  fail = 1;
#line 183
                  break;
                }
              }
            }
#line 175
            i ++;
          }
        }
      }
    }
#line 187
    if (fail) {
#line 188
      fclose(f);
#line 189
      log("%s", buf___2);
#line 190
      packet_send_debug("%s", buf___2);
#line 191
      restore_uid();
#line 192
      return (0);
    }
  }
#line 196
  authenticated = 0;
#line 198
  pk = RSA_new();
#line 199
  pk->e = BN_new();
#line 200
  pk->n = BN_new();
#line 207
  while (1) {
#line 207
    tmp___9 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 207
    if (! tmp___9) {
#line 207
      break;
    }
#line 211
    linenum ++;
#line 214
    cp = line;
#line 214
    while (1) {
#line 214
      if (! ((int )*cp == 32)) {
#line 214
        if (! ((int )*cp == 9)) {
#line 214
          break;
        }
      }
#line 214
      cp ++;
    }
#line 216
    if (! *cp) {
#line 217
      continue;
    } else {
#line 216
      if ((int )*cp == 10) {
#line 217
        continue;
      } else {
#line 216
        if ((int )*cp == 35) {
#line 217
          continue;
        }
      }
    }
#line 225
    if ((int )*cp < 48) {
      goto _L___2;
    } else {
#line 225
      if ((int )*cp > 57) {
        _L___2: /* CIL Label */ 
#line 226
        quoted = 0;
#line 227
        options___0 = cp;
#line 228
        while (1) {
#line 228
          if (*cp) {
#line 228
            if (! quoted) {
#line 228
              if ((int )*cp != 32) {
#line 228
                if (! ((int )*cp != 9)) {
#line 228
                  break;
                }
              } else {
#line 228
                break;
              }
            }
          } else {
#line 228
            break;
          }
#line 229
          if ((int )*cp == 92) {
#line 229
            if ((int )*(cp + 1) == 34) {
#line 230
              cp ++;
            } else {
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
#line 231
            if ((int )*cp == 34) {
#line 232
              quoted = ! quoted;
            }
          }
#line 228
          cp ++;
        }
      } else {
#line 235
        options___0 = (char *)((void *)0);
      }
    }
#line 238
    tmp___3 = auth_rsa_read_key(& cp, & bits, pk->e, pk->n);
#line 238
    if (! tmp___3) {
#line 239
      debug("%.100s, line %lu: bad key syntax", file, linenum);
#line 241
      packet_send_debug("%.100s, line %lu: bad key syntax", file, linenum);
#line 243
      continue;
    }
#line 248
    tmp___4 = BN_cmp((BIGNUM const   *)pk->n, (BIGNUM const   *)client_n);
#line 248
    if (tmp___4 != 0) {
#line 249
      continue;
    }
#line 252
    tmp___6 = BN_num_bits((BIGNUM const   *)pk->n);
#line 252
    if (bits != (u_int )tmp___6) {
#line 253
      tmp___5 = BN_num_bits((BIGNUM const   *)pk->n);
#line 253
      log("Warning: %s, line %ld: keysize mismatch: actual %d vs. announced %d.",
          file, linenum, tmp___5, bits);
    }
#line 262
    tmp___7 = auth_parse_options(pw, options___0, file, linenum);
#line 262
    if (! tmp___7) {
#line 263
      continue;
    }
#line 266
    tmp___8 = auth_rsa_challenge_dialog(pk);
#line 266
    if (! tmp___8) {
#line 268
      verbose("Wrong response to RSA authentication challenge.");
#line 269
      packet_send_debug("Wrong response to RSA authentication challenge.");
#line 270
      continue;
    }
#line 280
    authenticated = 1;
#line 281
    break;
  }
#line 285
  restore_uid();
#line 288
  fclose(f);
#line 290
  RSA_free(pk);
#line 292
  if (authenticated) {
#line 293
    packet_send_debug("RSA authentication accepted.");
  } else {
#line 295
    auth_clear_options();
  }
#line 298
  return (authenticated);
}
}
#line 1 "auth-rh-rsa.o"
#pragma merger(0,"./auth-rh-rsa.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 35 "auth-rh-rsa.c"
int auth_rhosts_rsa(struct passwd *pw , char const   *client_user , RSA *client_host_key ) 
{ char const   *canonical_hostname ;
  HostStatus host_status ;
  Key *client_key ;
  Key *found ;
  int tmp ;
  struct stat st ;
  char *user_hostfile ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 43
  debug("Trying rhosts with RSA host authentication for client user %.100s", client_user);
#line 45
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 46
    return (0);
  } else {
#line 45
    if ((unsigned int )client_host_key == (unsigned int )((void *)0)) {
#line 46
      return (0);
    }
  }
#line 49
  tmp = auth_rhosts(pw, client_user);
#line 49
  if (! tmp) {
#line 50
    return (0);
  }
#line 52
  canonical_hostname = get_canonical_hostname(options.reverse_mapping_check);
#line 55
  debug("Rhosts RSA authentication: canonical host %.900s", canonical_hostname);
#line 58
  client_key = key_new(0);
#line 59
  BN_copy((client_key->rsa)->e, (BIGNUM const   *)client_host_key->e);
#line 60
  BN_copy((client_key->rsa)->n, (BIGNUM const   *)client_host_key->n);
#line 61
  found = key_new(0);
#line 64
  host_status = check_host_in_hostfile("/usr/local/etc/ssh_known_hosts", canonical_hostname,
                                       client_key, found, (int *)((void *)0));
#line 68
  if ((int )host_status != 0) {
#line 68
    if (! options.ignore_user_known_hosts) {
#line 70
      tmp___0 = tilde_expand_filename("~/.ssh/known_hosts", pw->pw_uid);
#line 70
      user_hostfile = tmp___0;
#line 75
      if (options.strict_modes) {
#line 75
        tmp___1 = stat((char const   * __restrict  )user_hostfile, (struct stat * __restrict  )(& st));
#line 75
        if (tmp___1 == 0) {
#line 75
          if (st.st_uid != 0U) {
#line 75
            if (st.st_uid != pw->pw_uid) {
#line 79
              log("Rhosts RSA authentication refused for %.100s: bad owner or modes for %.200s",
                  pw->pw_name, user_hostfile);
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 75
            if ((st.st_mode & 18U) != 0U) {
#line 79
              log("Rhosts RSA authentication refused for %.100s: bad owner or modes for %.200s",
                  pw->pw_name, user_hostfile);
            } else {
#line 83
              temporarily_use_uid(pw);
#line 84
              host_status = check_host_in_hostfile((char const   *)user_hostfile,
                                                   canonical_hostname, client_key,
                                                   found, (int *)((void *)0));
#line 86
              restore_uid();
            }
          }
        } else {
#line 83
          temporarily_use_uid(pw);
#line 84
          host_status = check_host_in_hostfile((char const   *)user_hostfile, canonical_hostname,
                                               client_key, found, (int *)((void *)0));
#line 86
          restore_uid();
        }
      } else {
#line 83
        temporarily_use_uid(pw);
#line 84
        host_status = check_host_in_hostfile((char const   *)user_hostfile, canonical_hostname,
                                             client_key, found, (int *)((void *)0));
#line 86
        restore_uid();
      }
#line 88
      xfree((void *)user_hostfile);
    }
  }
#line 90
  key_free(client_key);
#line 91
  key_free(found);
#line 93
  if ((int )host_status != 0) {
#line 94
    debug("Rhosts with RSA host authentication denied: unknown or invalid host key");
#line 95
    packet_send_debug("Your host key cannot be verified: unknown or invalid host key.");
#line 96
    return (0);
  }
#line 101
  tmp___2 = auth_rsa_challenge_dialog(client_host_key);
#line 101
  if (! tmp___2) {
#line 102
    log("Client on %.800s failed to respond correctly to host authentication.", canonical_hostname);
#line 104
    return (0);
  }
#line 111
  verbose("Rhosts with RSA host authentication accepted for %.100s, %.100s on %.700s.",
          pw->pw_name, client_user, canonical_hostname);
#line 113
  packet_send_debug("Rhosts with RSA host authentication accepted.");
#line 114
  return (1);
}
}
#line 1 "auth-sia.o"
#pragma merger(0,"./auth-sia.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "sshpty.o"
#pragma merger(0,"./sshpty.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 280
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 433 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group )  __attribute__((__nonnull__(1))) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 736
extern  __attribute__((__nothrow__)) char *ttyname(int __fd ) ;
#line 872
extern  __attribute__((__nothrow__)) int vhangup(void) ;
#line 109 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 26 "sshpty.h"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) ;
#line 32
void pty_release(char const   *ttyname___0 ) ;
#line 38
void pty_make_controlling_tty(int *ttyfd , char const   *ttyname___0 ) ;
#line 41
void pty_change_window_size(int ptyfd , int row , int col , int xpixel , int ypixel ) ;
#line 45
void pty_setowner(struct passwd *pw , char const   *ttyname___0 ) ;
#line 34 "/usr/include/pty.h"
extern  __attribute__((__nothrow__)) int openpty(int *__amaster , int *__aslave ,
                                                 char *__name , struct termios *__termp ,
                                                 struct winsize *__winp ) ;
#line 47 "sshpty.c"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) 
{ char *name ;
  int i ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 55
  i = openpty(ptyfd, ttyfd, (char *)((void *)0), (struct termios *)((void *)0), (struct winsize *)((void *)0));
#line 56
  if (i < 0) {
#line 57
    tmp = __errno_location();
#line 57
    tmp___0 = strerror(*tmp);
#line 57
    error("openpty: %.100s", tmp___0);
#line 58
    return (0);
  }
#line 60
  name = ttyname(*ttyfd);
#line 61
  if (! name) {
#line 62
    fatal("openpty returns device for which ttyname fails.");
  }
#line 64
  strlcpy(namebuf, (char const   *)name, (unsigned int )namebuflen);
#line 65
  return (1);
}
}
#line 203 "sshpty.c"
void pty_release(char const   *ttyname___0 ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 206
  tmp___1 = chown(ttyname___0, 0U, 0U);
#line 206
  if (tmp___1 < 0) {
#line 207
    tmp = __errno_location();
#line 207
    tmp___0 = strerror(*tmp);
#line 207
    error("chown %.100s 0 0 failed: %.100s", ttyname___0, tmp___0);
  }
#line 208
  tmp___4 = chmod(ttyname___0, 438U);
#line 208
  if (tmp___4 < 0) {
#line 209
    tmp___2 = __errno_location();
#line 209
    tmp___3 = strerror(*tmp___2);
#line 209
    error("chmod %.100s 0666 failed: %.100s", ttyname___0, tmp___3);
  }
#line 210
  return;
}
}
#line 214 "sshpty.c"
void pty_make_controlling_tty(int *ttyfd , char const   *ttyname___0 ) 
{ int fd ;
  void *old ;
  int *tmp ;
  char *tmp___0 ;
  __pid_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  __sighandler_t tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;

  {
#line 224
  fd = open("/dev/tty", 258);
#line 225
  if (fd >= 0) {
#line 226
    ioctl(fd, 21538UL, (void *)0);
#line 227
    close(fd);
  }
#line 230
  tmp___1 = setsid();
#line 230
  if (tmp___1 < 0) {
#line 231
    tmp = __errno_location();
#line 231
    tmp___0 = strerror(*tmp);
#line 231
    error("setsid: %.100s", tmp___0);
  }
#line 237
  fd = open("/dev/tty", 258);
#line 238
  if (fd >= 0) {
#line 239
    error("Failed to disconnect from controlling tty.");
#line 240
    close(fd);
  }
#line 244
  debug("Setting controlling tty using TIOCSCTTY.");
#line 245
  tmp___4 = ioctl(*ttyfd, 21518UL, (void *)0);
#line 245
  if (tmp___4 < 0) {
#line 246
    tmp___2 = __errno_location();
#line 246
    tmp___3 = strerror(*tmp___2);
#line 246
    error("ioctl(TIOCSCTTY): %.100s", tmp___3);
  }
#line 253
  tmp___5 = signal(1, (void (*)(int  ))1);
#line 253
  old = (void *)tmp___5;
#line 254
  vhangup();
#line 255
  signal(1, (void (*)(int  ))old);
#line 257
  fd = open(ttyname___0, 2);
#line 258
  if (fd < 0) {
#line 259
    tmp___6 = __errno_location();
#line 259
    tmp___7 = strerror(*tmp___6);
#line 259
    error("%.100s: %.100s", ttyname___0, tmp___7);
  } else {
#line 262
    close(*ttyfd);
#line 263
    *ttyfd = fd;
  }
#line 269
  fd = open("/dev/tty", 1);
#line 270
  if (fd < 0) {
#line 271
    tmp___8 = __errno_location();
#line 271
    tmp___9 = strerror(*tmp___8);
#line 271
    error("open /dev/tty failed - could not set controlling tty: %.100s", tmp___9);
  } else {
#line 274
    close(fd);
  }
#line 276
  return;
}
}
#line 280 "sshpty.c"
void pty_change_window_size(int ptyfd , int row , int col , int xpixel , int ypixel ) 
{ struct winsize w ;

  {
#line 285
  w.ws_row = (unsigned short )row;
#line 286
  w.ws_col = (unsigned short )col;
#line 287
  w.ws_xpixel = (unsigned short )xpixel;
#line 288
  w.ws_ypixel = (unsigned short )ypixel;
#line 289
  ioctl(ptyfd, 21524UL, & w);
#line 290
  return;
}
}
#line 292 "sshpty.c"
void pty_setowner(struct passwd *pw , char const   *ttyname___0 ) 
{ struct group *grp ;
  gid_t gid ;
  mode_t mode ;
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;

  {
#line 301
  grp = getgrnam("tty");
#line 302
  if (grp) {
#line 303
    gid = grp->gr_gid;
#line 304
    mode = (unsigned int )(384 | (128 >> 3));
  } else {
#line 306
    gid = pw->pw_gid;
#line 307
    mode = (unsigned int )((384 | (128 >> 3)) | ((128 >> 3) >> 3));
  }
#line 314
  tmp___1 = stat((char const   * __restrict  )ttyname___0, (struct stat * __restrict  )(& st));
#line 314
  if (tmp___1) {
#line 315
    tmp = __errno_location();
#line 315
    tmp___0 = strerror(*tmp);
#line 315
    fatal("stat(%.100s) failed: %.100s", ttyname___0, tmp___0);
  }
#line 318
  if (st.st_uid != pw->pw_uid) {
    goto _L;
  } else {
#line 318
    if (st.st_gid != gid) {
      _L: /* CIL Label */ 
#line 319
      tmp___7 = chown(ttyname___0, pw->pw_uid, gid);
#line 319
      if (tmp___7 < 0) {
#line 320
        tmp___6 = __errno_location();
#line 320
        if (*tmp___6 == 30) {
#line 320
          if (st.st_uid == pw->pw_uid) {
#line 321
            tmp___2 = __errno_location();
#line 321
            tmp___3 = strerror(*tmp___2);
#line 321
            error("chown(%.100s, %d, %d) failed: %.100s", ttyname___0, pw->pw_uid,
                  gid, tmp___3);
          } else {
#line 325
            tmp___4 = __errno_location();
#line 325
            tmp___5 = strerror(*tmp___4);
#line 325
            fatal("chown(%.100s, %d, %d) failed: %.100s", ttyname___0, pw->pw_uid,
                  gid, tmp___5);
          }
        } else {
#line 325
          tmp___4 = __errno_location();
#line 325
          tmp___5 = strerror(*tmp___4);
#line 325
          fatal("chown(%.100s, %d, %d) failed: %.100s", ttyname___0, pw->pw_uid, gid,
                tmp___5);
        }
      }
    }
  }
#line 331
  if ((st.st_mode & (unsigned int )((448 | (448 >> 3)) | ((448 >> 3) >> 3))) != mode) {
#line 332
    tmp___13 = chmod(ttyname___0, mode);
#line 332
    if (tmp___13 < 0) {
#line 333
      tmp___12 = __errno_location();
#line 333
      if (*tmp___12 == 30) {
#line 333
        if ((st.st_mode & (unsigned int )((256 >> 3) | ((256 >> 3) >> 3))) == 0U) {
#line 335
          tmp___8 = __errno_location();
#line 335
          tmp___9 = strerror(*tmp___8);
#line 335
          error("chmod(%.100s, 0%o) failed: %.100s", ttyname___0, mode, tmp___9);
        } else {
#line 338
          tmp___10 = __errno_location();
#line 338
          tmp___11 = strerror(*tmp___10);
#line 338
          fatal("chmod(%.100s, 0%o) failed: %.100s", ttyname___0, mode, tmp___11);
        }
      } else {
#line 338
        tmp___10 = __errno_location();
#line 338
        tmp___11 = strerror(*tmp___10);
#line 338
        fatal("chmod(%.100s, 0%o) failed: %.100s", ttyname___0, mode, tmp___11);
      }
    }
  }
#line 342
  return;
}
}
#line 1 "sshlogin.o"
#pragma merger(0,"./sshlogin.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 100 "loginrec.h"
struct logininfo *login_alloc_entry(int pid , char const   *username , char const   *hostname ,
                                    char const   *line ) ;
#line 103
void login_free_entry(struct logininfo *li ) ;
#line 111
int login_login(struct logininfo *li ) ;
#line 112
int login_logout(struct logininfo *li ) ;
#line 121
void login_set_addr(struct logininfo *li , struct sockaddr  const  *sa , unsigned int sa_size ) ;
#line 128
struct logininfo *login_get_lastlog(struct logininfo *li , int uid ) ;
#line 52 "sshlogin.c"
u_long get_last_login_time(uid_t uid , char const   *logname , char *buf___2 , u_int bufsize ) 
{ struct logininfo li ;

  {
#line 58
  login_get_lastlog(& li, (int )uid);
#line 59
  strlcpy(buf___2, (char const   *)(li.hostname), bufsize);
#line 60
  return ((unsigned long )li.tv_sec);
}
}
#line 68 "sshlogin.c"
void record_login(pid_t pid , char const   *ttyname___0 , char const   *user , uid_t uid ,
                  char const   *host , struct sockaddr *addr ) 
{ struct logininfo *li ;

  {
#line 74
  li = login_alloc_entry(pid, user, host, ttyname___0);
#line 75
  login_set_addr(li, (struct sockaddr  const  *)addr, sizeof(struct sockaddr ));
#line 76
  login_login(li);
#line 77
  login_free_entry(li);
#line 78
  return;
}
}
#line 82 "sshlogin.c"
void record_logout(pid_t pid , char const   *ttyname___0 ) 
{ struct logininfo *li ;

  {
#line 87
  li = login_alloc_entry(pid, (char const   *)((void *)0), (char const   *)((void *)0),
                         ttyname___0);
#line 88
  login_logout(li);
#line 89
  login_free_entry(li);
#line 90
  return;
}
}
#line 1 "loginrec.o"
#pragma merger(0,"./loginrec.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval * __restrict  __tv ,
                                                      __timezone_ptr_t __tz )  __attribute__((__nonnull__(1))) ;
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 46 "/usr/include/utmp.h"
extern  __attribute__((__nothrow__)) void login(struct utmp  const  *__entry ) ;
#line 49
extern  __attribute__((__nothrow__)) int logout(char const   *__ut_line ) ;
#line 52
extern  __attribute__((__nothrow__)) void logwtmp(char const   *__ut_line , char const   *__ut_name ,
                                                  char const   *__ut_host ) ;
#line 105 "loginrec.h"
int login_init_entry(struct logininfo *li , int pid , char const   *username , char const   *hostname ,
                     char const   *line ) ;
#line 108
void login_set_current_time(struct logininfo *li ) ;
#line 117
int login_write(struct logininfo *li ) ;
#line 130
unsigned int login_get_lastlog_time(int uid ) ;
#line 133
char *line_fullname(char *dst , char const   *src , int dstsize ) ;
#line 134
char *line_stripname(char *dst , char const   *src , int dstsize ) ;
#line 135
char *line_abbrevname(char *dst , char const   *src , int dstsize ) ;
#line 181 "loginrec.c"
void set_utmp_time(struct logininfo *li , struct utmp *ut ) ;
#line 182
void construct_utmp(struct logininfo *li , struct utmp *ut ) ;
#line 194
int lastlog_write_entry(struct logininfo *li ) ;
#line 195
int syslogin_write_entry(struct logininfo *li ) ;
#line 197
int getlast_entry(struct logininfo *li ) ;
#line 198
int lastlog_get_entry(struct logininfo *li ) ;
#line 218 "loginrec.c"
int login_login(struct logininfo *li ) 
{ int tmp ;

  {
#line 221
  li->type = (short)7;
#line 222
  tmp = login_write(li);
#line 222
  return (tmp);
}
}
#line 234 "loginrec.c"
int login_logout(struct logininfo *li ) 
{ int tmp ;

  {
#line 237
  li->type = (short)8;
#line 238
  tmp = login_write(li);
#line 238
  return (tmp);
}
}
#line 258 "loginrec.c"
unsigned int login_get_lastlog_time(int uid ) 
{ struct logininfo li ;
  struct logininfo *tmp ;

  {
#line 263
  tmp = login_get_lastlog(& li, uid);
#line 263
  if (tmp) {
#line 264
    return (li.tv_sec);
  } else {
#line 266
    return (0U);
  }
}
}
#line 282 "loginrec.c"
struct logininfo *login_get_lastlog(struct logininfo *li , int uid ) 
{ struct passwd *pw ;
  int tmp ;

  {
#line 287
  memset((void *)li, '\000', sizeof(*li));
#line 288
  li->uid = uid;
#line 295
  pw = getpwuid((unsigned int )uid);
#line 296
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 297
    fatal("login_get_lastlog: Cannot find account for uid %i", uid);
  }
#line 301
  strlcpy(li->username, (char const   *)pw->pw_name, sizeof(li->username));
#line 303
  tmp = getlast_entry(li);
#line 303
  if (tmp) {
#line 304
    return (li);
  } else {
#line 306
    return ((struct logininfo *)((void *)0));
  }
}
}
#line 319 "loginrec.c"
struct logininfo *login_alloc_entry(int pid , char const   *username , char const   *hostname ,
                                    char const   *line ) 
{ struct logininfo *newli ;
  void *tmp ;

  {
#line 325
  tmp = xmalloc(sizeof(*newli));
#line 325
  newli = (struct logininfo *)tmp;
#line 326
  login_init_entry(newli, pid, username, hostname, line);
#line 327
  return (newli);
}
}
#line 332 "loginrec.c"
void login_free_entry(struct logininfo *li ) 
{ 

  {
#line 335
  xfree((void *)li);
#line 336
  return;
}
}
#line 347 "loginrec.c"
int login_init_entry(struct logininfo *li , int pid , char const   *username , char const   *hostname ,
                     char const   *line ) 
{ struct passwd *pw ;

  {
#line 353
  memset((void *)li, 0, sizeof(*li));
#line 355
  li->pid = pid;
#line 358
  if (line) {
#line 359
    line_fullname(li->line, line, (int )sizeof(li->line));
  }
#line 361
  if (username) {
#line 362
    strlcpy(li->username, username, sizeof(li->username));
#line 363
    pw = getpwnam((char const   *)(li->username));
#line 364
    if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 365
      fatal("login_init_entry: Cannot find user \"%s\"", li->username);
    }
#line 366
    li->uid = (int )pw->pw_uid;
  }
#line 369
  if (hostname) {
#line 370
    strlcpy(li->hostname, hostname, sizeof(li->hostname));
  }
#line 372
  return (1);
}
}
#line 381 "loginrec.c"
void login_set_current_time(struct logininfo *li ) 
{ struct timeval tv ;

  {
#line 386
  gettimeofday((struct timeval * __restrict  )(& tv), (struct timezone * __restrict  )((void *)0));
#line 388
  li->tv_sec = (unsigned int )tv.tv_sec;
#line 389
  li->tv_usec = (unsigned int )tv.tv_usec;
#line 390
  return;
}
}
#line 393 "loginrec.c"
void login_set_addr(struct logininfo *li , struct sockaddr  const  *sa , unsigned int sa_size ) 
{ unsigned int bufsize ;

  {
#line 397
  bufsize = sa_size;
#line 400
  if (sizeof(li->hostaddr) < sa_size) {
#line 401
    bufsize = sizeof(li->hostaddr);
  }
#line 403
  memcpy((void * __restrict  )((void *)(& li->hostaddr.sa)), (void const   * __restrict  )((void const   *)sa),
         bufsize);
#line 404
  return;
}
}
#line 411 "loginrec.c"
int login_write(struct logininfo *li ) 
{ __uid_t tmp ;

  {
#line 415
  tmp = geteuid();
#line 415
  if ((int )tmp != 0) {
#line 416
    log("Attempt to write login records by non-root user (aborting)");
#line 417
    return (1);
  }
#line 422
  login_set_current_time(li);
#line 424
  syslogin_write_entry(li);
#line 427
  if ((int )li->type == 7) {
#line 428
    lastlog_write_entry(li);
  }
#line 443
  return (0);
}
}
#line 452 "loginrec.c"
int getlast_entry(struct logininfo *li ) 
{ int tmp ;

  {
#line 456
  tmp = lastlog_get_entry(li);
#line 456
  return (tmp);
}
}
#line 503 "loginrec.c"
char *line_fullname(char *dst , char const   *src , int dstsize ) 
{ int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  size_t tmp___25 ;

  {
#line 506
  memset((void *)dst, '\000', (unsigned int )dstsize);
#line 507
  if (0) {
#line 507
    if (0) {
#line 507
      __s1_len___0 = strlen(src);
#line 507
      __s2_len___0 = strlen("/dev/");
#line 507
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 507
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 507
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 507
            tmp___22 = 1;
          } else {
#line 507
            if (__s2_len___0 >= 4U) {
#line 507
              tmp___22 = 1;
            } else {
#line 507
              tmp___22 = 0;
            }
          }
        } else {
#line 507
          tmp___22 = 0;
        }
      }
#line 507
      if (tmp___22) {
#line 507
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 507
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 507
        tmp___18 = tmp___21;
      }
    } else {
#line 507
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 507
      tmp___18 = tmp___21;
    }
#line 507
    tmp___12 = tmp___18;
  } else {
#line 507
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 507
  if (tmp___12 == 0) {
#line 508
    strlcpy(dst, src, (unsigned int )dstsize);
  } else {
#line 507
    tmp___25 = strlen(src);
#line 507
    if ((size_t )dstsize < tmp___25 + 5U) {
#line 508
      strlcpy(dst, src, (unsigned int )dstsize);
    } else {
#line 510
      strlcpy(dst, "/dev/", (unsigned int )dstsize);
#line 511
      strlcat(dst, src, (unsigned int )dstsize);
    }
  }
#line 513
  return (dst);
}
}
#line 517 "loginrec.c"
char *line_stripname(char *dst , char const   *src , int dstsize ) 
{ int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 520
  memset((void *)dst, '\000', (unsigned int )dstsize);
#line 521
  if (0) {
#line 521
    if (0) {
#line 521
      __s1_len___0 = strlen(src);
#line 521
      __s2_len___0 = strlen("/dev/");
#line 521
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 521
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 521
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 521
            tmp___22 = 1;
          } else {
#line 521
            if (__s2_len___0 >= 4U) {
#line 521
              tmp___22 = 1;
            } else {
#line 521
              tmp___22 = 0;
            }
          }
        } else {
#line 521
          tmp___22 = 0;
        }
      }
#line 521
      if (tmp___22) {
#line 521
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 521
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 521
        tmp___18 = tmp___21;
      }
    } else {
#line 521
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 521
      tmp___18 = tmp___21;
    }
#line 521
    tmp___12 = tmp___18;
  } else {
#line 521
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 521
  if (tmp___12 == 0) {
#line 522
    strlcpy(dst, src + 5, (unsigned int )dstsize);
  } else {
#line 524
    strlcpy(dst, src, (unsigned int )dstsize);
  }
#line 525
  return (dst);
}
}
#line 534 "loginrec.c"
char *line_abbrevname(char *dst , char const   *src , int dstsize ) 
{ size_t len ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 539
  memset((void *)dst, '\000', (unsigned int )dstsize);
#line 542
  if (0) {
#line 542
    if (0) {
#line 542
      __s1_len___0 = strlen(src);
#line 542
      __s2_len___0 = strlen("/dev/");
#line 542
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 542
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 542
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 542
            tmp___22 = 1;
          } else {
#line 542
            if (__s2_len___0 >= 4U) {
#line 542
              tmp___22 = 1;
            } else {
#line 542
              tmp___22 = 0;
            }
          }
        } else {
#line 542
          tmp___22 = 0;
        }
      }
#line 542
      if (tmp___22) {
#line 542
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 542
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 542
        tmp___18 = tmp___21;
      }
    } else {
#line 542
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 542
      tmp___18 = tmp___21;
    }
#line 542
    tmp___12 = tmp___18;
  } else {
#line 542
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 542
  if (tmp___12 == 0) {
#line 543
    src += 5;
  }
#line 545
  len = strlen(src);
#line 547
  if (len > 0U) {
#line 548
    if ((int )len - dstsize > 0) {
#line 549
      src += (int )len - dstsize;
    }
#line 552
    __builtin_strncpy(dst, src, (unsigned int )dstsize);
  }
#line 555
  return (dst);
}
}
#line 568 "loginrec.c"
void set_utmp_time(struct logininfo *li , struct utmp *ut ) 
{ 

  {
#line 572
  ut->ut_tv.tv_sec = (long )li->tv_sec;
#line 573
  ut->ut_tv.tv_usec = (long )li->tv_usec;
#line 579
  return;
}
}
#line 581 "loginrec.c"
void construct_utmp(struct logininfo *li , struct utmp *ut ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 585
  memset((void *)ut, '\000', sizeof(*ut));
#line 590
  line_abbrevname(ut->ut_id, (char const   *)(li->line), (int )sizeof(ut->ut_id));
#line 595
  switch ((int )li->type) {
  case 7: 
#line 597
  ut->ut_type = (short)7;
#line 598
  break;
  case 8: 
#line 600
  ut->ut_type = (short)8;
#line 601
  break;
  }
#line 604
  set_utmp_time(li, ut);
#line 606
  line_stripname(ut->ut_line, (char const   *)(li->line), (int )sizeof(ut->ut_line));
#line 609
  ut->ut_pid = li->pid;
#line 613
  if ((int )li->type == 8) {
#line 614
    return;
  }
#line 622
  if (sizeof(ut->ut_user) < sizeof(li->username)) {
#line 622
    tmp = sizeof(ut->ut_user);
  } else {
#line 622
    tmp = sizeof(li->username);
  }
#line 622
  __builtin_strncpy(ut->ut_user, (char const   *)(li->username), tmp);
#line 624
  if (sizeof(ut->ut_host) < sizeof(li->hostname)) {
#line 624
    tmp___0 = sizeof(ut->ut_host);
  } else {
#line 624
    tmp___0 = sizeof(li->hostname);
  }
#line 624
  __builtin_strncpy(ut->ut_host, (char const   *)(li->hostname), tmp___0);
#line 628
  if ((int )li->hostaddr.sa.sa_family == 2) {
#line 629
    ut->ut_addr_v6[0] = (int )li->hostaddr.sa_in.sin_addr.s_addr;
  }
#line 631
  return;
}
}
#line 1273 "loginrec.c"
static int syslogin_perform_login(struct logininfo *li ) 
{ struct utmp *ut ;
  void *tmp ;

  {
#line 1278
  tmp = malloc(sizeof(*ut));
#line 1278
  ut = (struct utmp *)tmp;
#line 1278
  if (! ut) {
#line 1279
    log("syslogin_perform_login: couldn\'t malloc()");
#line 1280
    return (0);
  }
#line 1282
  construct_utmp(li, ut);
#line 1283
  login((struct utmp  const  *)ut);
#line 1285
  return (1);
}
}
#line 1288 "loginrec.c"
static int syslogin_perform_logout(struct logininfo *li ) 
{ char line[8] ;
  int tmp ;

  {
#line 1294
  line_stripname(line, (char const   *)(li->line), (int )sizeof(line));
#line 1296
  tmp = logout((char const   *)(line));
#line 1296
  if (tmp) {
#line 1300
    logwtmp((char const   *)(line), "", "");
  } else {
#line 1297
    log("syslogin_perform_logout: logout() returned an error");
  }
#line 1308
  return (1);
}
}
#line 1311 "loginrec.c"
int syslogin_write_entry(struct logininfo *li ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 1314
  switch ((int )li->type) {
  case 7: 
#line 1316
  tmp = syslogin_perform_login(li);
#line 1316
  return (tmp);
  case 8: 
#line 1318
  tmp___0 = syslogin_perform_logout(li);
#line 1318
  return (tmp___0);
  default: 
#line 1320
  log("syslogin_write_entry: Invalid type field");
#line 1321
  return (0);
  }
}
}
#line 1337 "loginrec.c"
static void lastlog_construct(struct logininfo *li , struct lastlog *last ) 
{ unsigned int tmp ;

  {
#line 1341
  memset((void *)last, '\000', sizeof(*last));
#line 1343
  line_stripname(last->ll_line, (char const   *)(li->line), (int )sizeof(last->ll_line));
#line 1344
  if (sizeof(last->ll_host) < sizeof(li->hostname)) {
#line 1344
    tmp = sizeof(last->ll_host);
  } else {
#line 1344
    tmp = sizeof(li->hostname);
  }
#line 1344
  strlcpy(last->ll_host, (char const   *)(li->hostname), tmp);
#line 1346
  last->ll_time = (long )li->tv_sec;
#line 1347
  return;
}
}
#line 1349 "loginrec.c"
static int lastlog_filetype(char *filename ) 
{ struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1354
  tmp___1 = stat((char const   * __restrict  )"/var/log/lastlog", (struct stat * __restrict  )(& st));
#line 1354
  if (tmp___1 != 0) {
#line 1355
    tmp = __errno_location();
#line 1355
    tmp___0 = strerror(*tmp);
#line 1355
    log("lastlog_perform_login: Couldn\'t stat %s: %s", "/var/log/lastlog", tmp___0);
#line 1357
    return (0);
  }
#line 1359
  if ((st.st_mode & 61440U) == 16384U) {
#line 1360
    return (2);
  } else {
#line 1361
    if ((st.st_mode & 61440U) == 32768U) {
#line 1362
      return (1);
    } else {
#line 1364
      return (3);
    }
  }
}
}
#line 1369 "loginrec.c"
static int lastlog_openseek(struct logininfo *li , int *fd , int filemode ) 
{ off_t offset ;
  int type ;
  char lastlog_file[1024] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  __off_t tmp___3 ;

  {
#line 1376
  type = lastlog_filetype((char *)"/var/log/lastlog");
#line 1377
  switch (type) {
  case 1: 
#line 1379
  strlcpy(lastlog_file, "/var/log/lastlog", sizeof(lastlog_file));
#line 1380
  break;
  case 2: 
#line 1382
  snprintf((char * __restrict  )(lastlog_file), sizeof(lastlog_file), (char const   * __restrict  )"%s/%s",
           "/var/log/lastlog", li->username);
#line 1384
  break;
  default: 
#line 1386
  log("lastlog_openseek: %.100s is not a file or directory!", "/var/log/lastlog");
#line 1388
  return (0);
  }
#line 1391
  *fd = open((char const   *)(lastlog_file), filemode);
#line 1392
  if (*fd < 0) {
#line 1393
    tmp = __errno_location();
#line 1393
    tmp___0 = strerror(*tmp);
#line 1393
    debug("lastlog_openseek: Couldn\'t open %s: %s", lastlog_file, tmp___0);
#line 1395
    return (0);
  }
#line 1398
  if (type == 1) {
#line 1400
    offset = (long )((unsigned long )((long )li->uid) * (unsigned long )sizeof(struct lastlog ));
#line 1402
    tmp___3 = lseek(*fd, offset, 0);
#line 1402
    if (tmp___3 != offset) {
#line 1403
      tmp___1 = __errno_location();
#line 1403
      tmp___2 = strerror(*tmp___1);
#line 1403
      log("lastlog_openseek: %s->lseek(): %s", lastlog_file, tmp___2);
#line 1405
      return (0);
    }
  }
#line 1409
  return (1);
}
}
#line 1412 "loginrec.c"
static int lastlog_perform_login(struct logininfo *li ) 
{ struct lastlog last ;
  int fd ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 1419
  lastlog_construct(li, & last);
#line 1421
  tmp = lastlog_openseek(li, & fd, 66);
#line 1421
  if (! tmp) {
#line 1422
    return (0);
  }
#line 1425
  tmp___2 = atomicio((ssize_t (*)())(& write), fd, (void *)(& last), sizeof(last));
#line 1425
  if ((unsigned int )tmp___2 != sizeof(last)) {
#line 1426
    close(fd);
#line 1427
    tmp___0 = __errno_location();
#line 1427
    tmp___1 = strerror(*tmp___0);
#line 1427
    log("lastlog_write_filemode: Error writing to %s: %s", "/var/log/lastlog", tmp___1);
#line 1429
    return (0);
  }
#line 1432
  close(fd);
#line 1433
  return (1);
}
}
#line 1436 "loginrec.c"
int lastlog_write_entry(struct logininfo *li ) 
{ int tmp ;

  {
#line 1439
  switch ((int )li->type) {
  case 7: 
#line 1441
  tmp = lastlog_perform_login(li);
#line 1441
  return (tmp);
  default: 
#line 1443
  log("lastlog_write_entry: Invalid type field");
#line 1444
  return (0);
  }
}
}
#line 1448 "loginrec.c"
static void lastlog_populate_entry(struct logininfo *li , struct lastlog *last ) 
{ unsigned int tmp ;

  {
#line 1451
  line_fullname(li->line, (char const   *)(last->ll_line), (int )sizeof(li->line));
#line 1452
  if (sizeof(li->hostname) < sizeof(last->ll_host)) {
#line 1452
    tmp = sizeof(li->hostname);
  } else {
#line 1452
    tmp = sizeof(last->ll_host);
  }
#line 1452
  strlcpy(li->hostname, (char const   *)(last->ll_host), tmp);
#line 1454
  li->tv_sec = (unsigned int )last->ll_time;
#line 1455
  return;
}
}
#line 1457 "loginrec.c"
int lastlog_get_entry(struct logininfo *li ) 
{ struct lastlog last ;
  int fd ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;

  {
#line 1463
  tmp___2 = lastlog_openseek(li, & fd, 0);
#line 1463
  if (tmp___2) {
#line 1464
    tmp___1 = atomicio((ssize_t (*)())(& read), fd, (void *)(& last), sizeof(last));
#line 1464
    if ((unsigned int )tmp___1 != sizeof(last)) {
#line 1465
      tmp = __errno_location();
#line 1465
      tmp___0 = strerror(*tmp);
#line 1465
      log("lastlog_get_entry: Error reading from %s: %s", "/var/log/lastlog", tmp___0);
#line 1467
      return (0);
    } else {
#line 1469
      lastlog_populate_entry(li, & last);
#line 1470
      return (1);
    }
  } else {
#line 1473
    return (0);
  }
}
}
#line 1 "servconf.o"
#pragma merger(0,"./servconf.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 747 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 34 "servconf.c"
void add_listen_addr(ServerOptions *options___0 , char *addr , u_short port ) ;
#line 35
void add_one_listen_addr(ServerOptions *options___0 , char *addr , u_short port ) ;
#line 42 "servconf.c"
void initialize_server_options(ServerOptions *options___0 ) 
{ 

  {
#line 45
  memset((void *)options___0, 0, sizeof(*options___0));
#line 46
  options___0->num_ports = 0U;
#line 47
  options___0->ports_from_cmdline = 0U;
#line 48
  options___0->listen_addrs = (struct addrinfo *)((void *)0);
#line 49
  options___0->num_host_key_files = 0;
#line 50
  options___0->pid_file = (char *)((void *)0);
#line 51
  options___0->server_key_bits = -1;
#line 52
  options___0->login_grace_time = -1;
#line 53
  options___0->key_regeneration_time = -1;
#line 54
  options___0->permit_root_login = -1;
#line 55
  options___0->ignore_rhosts = -1;
#line 56
  options___0->ignore_user_known_hosts = -1;
#line 57
  options___0->print_motd = -1;
#line 58
  options___0->print_lastlog = -1;
#line 59
  options___0->check_mail = -1;
#line 60
  options___0->x11_forwarding = -1;
#line 61
  options___0->x11_display_offset = -1;
#line 62
  options___0->xauth_location = (char *)((void *)0);
#line 63
  options___0->strict_modes = -1;
#line 64
  options___0->keepalives = -1;
#line 65
  options___0->log_facility = (enum __anonenum_SyslogFacility_63 )-1;
#line 66
  options___0->log_level = (enum __anonenum_LogLevel_64 )-1;
#line 67
  options___0->rhosts_authentication = -1;
#line 68
  options___0->rhosts_rsa_authentication = -1;
#line 69
  options___0->hostbased_authentication = -1;
#line 70
  options___0->hostbased_uses_name_from_packet_only = -1;
#line 71
  options___0->rsa_authentication = -1;
#line 72
  options___0->pubkey_authentication = -1;
#line 82
  options___0->password_authentication = -1;
#line 83
  options___0->kbd_interactive_authentication = -1;
#line 84
  options___0->challenge_reponse_authentication = -1;
#line 85
  options___0->permit_empty_passwd = -1;
#line 86
  options___0->use_login = -1;
#line 87
  options___0->allow_tcp_forwarding = -1;
#line 88
  options___0->num_allow_users = 0U;
#line 89
  options___0->num_deny_users = 0U;
#line 90
  options___0->num_allow_groups = 0U;
#line 91
  options___0->num_deny_groups = 0U;
#line 92
  options___0->ciphers = (char *)((void *)0);
#line 93
  options___0->macs = (char *)((void *)0);
#line 94
  options___0->protocol = 0;
#line 95
  options___0->gateway_ports = -1;
#line 96
  options___0->num_subsystems = 0U;
#line 97
  options___0->max_startups_begin = -1;
#line 98
  options___0->max_startups_rate = -1;
#line 99
  options___0->max_startups = -1;
#line 100
  options___0->banner = (char *)((void *)0);
#line 101
  options___0->reverse_mapping_check = -1;
#line 102
  options___0->client_alive_interval = -1;
#line 103
  options___0->client_alive_count_max = -1;
#line 104
  options___0->pam_authentication_via_kbd_int = -1;
#line 105
  return;
}
}
#line 107 "servconf.c"
void fill_default_server_options(ServerOptions *options___0 ) 
{ int tmp ;
  int tmp___0 ;
  u_int tmp___1 ;

  {
#line 110
  if (options___0->protocol == 0) {
#line 111
    options___0->protocol = 5;
  }
#line 112
  if (options___0->num_host_key_files == 0) {
#line 114
    if (options___0->protocol & 1) {
#line 115
      tmp = options___0->num_host_key_files;
#line 115
      (options___0->num_host_key_files) ++;
#line 115
      options___0->host_key_files[tmp] = (char *)"/usr/local/etc/ssh_host_key";
    }
#line 116
    if (options___0->protocol & 4) {
#line 117
      tmp___0 = options___0->num_host_key_files;
#line 117
      (options___0->num_host_key_files) ++;
#line 117
      options___0->host_key_files[tmp___0] = (char *)"/usr/local/etc/ssh_host_dsa_key";
    }
  }
#line 119
  if (options___0->num_ports == 0U) {
#line 120
    tmp___1 = options___0->num_ports;
#line 120
    (options___0->num_ports) ++;
#line 120
    options___0->ports[tmp___1] = (unsigned short)22;
  }
#line 121
  if ((unsigned int )options___0->listen_addrs == (unsigned int )((void *)0)) {
#line 122
    add_listen_addr(options___0, (char *)((void *)0), (unsigned short)0);
  }
#line 123
  if ((unsigned int )options___0->pid_file == (unsigned int )((void *)0)) {
#line 124
    options___0->pid_file = (char *)"/var/run/sshd.pid";
  }
#line 125
  if (options___0->server_key_bits == -1) {
#line 126
    options___0->server_key_bits = 768;
  }
#line 127
  if (options___0->login_grace_time == -1) {
#line 128
    options___0->login_grace_time = 600;
  }
#line 129
  if (options___0->key_regeneration_time == -1) {
#line 130
    options___0->key_regeneration_time = 3600;
  }
#line 131
  if (options___0->permit_root_login == -1) {
#line 132
    options___0->permit_root_login = 3;
  }
#line 133
  if (options___0->ignore_rhosts == -1) {
#line 134
    options___0->ignore_rhosts = 1;
  }
#line 135
  if (options___0->ignore_user_known_hosts == -1) {
#line 136
    options___0->ignore_user_known_hosts = 0;
  }
#line 137
  if (options___0->check_mail == -1) {
#line 138
    options___0->check_mail = 0;
  }
#line 139
  if (options___0->print_motd == -1) {
#line 140
    options___0->print_motd = 1;
  }
#line 141
  if (options___0->print_lastlog == -1) {
#line 142
    options___0->print_lastlog = 1;
  }
#line 143
  if (options___0->x11_forwarding == -1) {
#line 144
    options___0->x11_forwarding = 0;
  }
#line 145
  if (options___0->x11_display_offset == -1) {
#line 146
    options___0->x11_display_offset = 10;
  }
#line 148
  if ((unsigned int )options___0->xauth_location == (unsigned int )((void *)0)) {
#line 149
    options___0->xauth_location = (char *)"/usr/bin//xauth";
  }
#line 151
  if (options___0->strict_modes == -1) {
#line 152
    options___0->strict_modes = 1;
  }
#line 153
  if (options___0->keepalives == -1) {
#line 154
    options___0->keepalives = 1;
  }
#line 155
  if ((int )options___0->log_facility == (int )((enum __anonenum_SyslogFacility_63 )-1)) {
#line 156
    options___0->log_facility = 2;
  }
#line 157
  if ((int )options___0->log_level == (int )((enum __anonenum_LogLevel_64 )-1)) {
#line 158
    options___0->log_level = 3;
  }
#line 159
  if (options___0->rhosts_authentication == -1) {
#line 160
    options___0->rhosts_authentication = 0;
  }
#line 161
  if (options___0->rhosts_rsa_authentication == -1) {
#line 162
    options___0->rhosts_rsa_authentication = 0;
  }
#line 163
  if (options___0->hostbased_authentication == -1) {
#line 164
    options___0->hostbased_authentication = 0;
  }
#line 165
  if (options___0->hostbased_uses_name_from_packet_only == -1) {
#line 166
    options___0->hostbased_uses_name_from_packet_only = 0;
  }
#line 167
  if (options___0->rsa_authentication == -1) {
#line 168
    options___0->rsa_authentication = 1;
  }
#line 169
  if (options___0->pubkey_authentication == -1) {
#line 170
    options___0->pubkey_authentication = 1;
  }
#line 185
  if (options___0->password_authentication == -1) {
#line 186
    options___0->password_authentication = 1;
  }
#line 187
  if (options___0->kbd_interactive_authentication == -1) {
#line 188
    options___0->kbd_interactive_authentication = 0;
  }
#line 189
  if (options___0->challenge_reponse_authentication == -1) {
#line 190
    options___0->challenge_reponse_authentication = 1;
  }
#line 191
  if (options___0->permit_empty_passwd == -1) {
#line 192
    options___0->permit_empty_passwd = 0;
  }
#line 193
  if (options___0->use_login == -1) {
#line 194
    options___0->use_login = 0;
  }
#line 195
  if (options___0->allow_tcp_forwarding == -1) {
#line 196
    options___0->allow_tcp_forwarding = 1;
  }
#line 197
  if (options___0->gateway_ports == -1) {
#line 198
    options___0->gateway_ports = 0;
  }
#line 199
  if (options___0->max_startups == -1) {
#line 200
    options___0->max_startups = 10;
  }
#line 201
  if (options___0->max_startups_rate == -1) {
#line 202
    options___0->max_startups_rate = 100;
  }
#line 203
  if (options___0->max_startups_begin == -1) {
#line 204
    options___0->max_startups_begin = options___0->max_startups;
  }
#line 205
  if (options___0->reverse_mapping_check == -1) {
#line 206
    options___0->reverse_mapping_check = 0;
  }
#line 207
  if (options___0->client_alive_interval == -1) {
#line 208
    options___0->client_alive_interval = 0;
  }
#line 209
  if (options___0->client_alive_count_max == -1) {
#line 210
    options___0->client_alive_count_max = 3;
  }
#line 211
  if (options___0->pam_authentication_via_kbd_int == -1) {
#line 212
    options___0->pam_authentication_via_kbd_int = 0;
  }
#line 213
  return;
}
}
#line 242 "servconf.c"
static struct __anonstruct_keywords_80 keywords[51]  = 
#line 242
  {      {"port", 1}, 
        {"hostkey", 2}, 
        {"hostdsakey", 2}, 
        {"pidfile", 35}, 
        {"serverkeybits", 3}, 
        {"logingracetime", 4}, 
        {"keyregenerationinterval", 5}, 
        {"permitrootlogin", 6}, 
        {"syslogfacility", 7}, 
        {"loglevel", 8}, 
        {"rhostsauthentication", 9}, 
        {"rhostsrsaauthentication", 10}, 
        {"hostbasedauthentication", 43}, 
        {"hostbasedusesnamefrompacketonly", 44}, 
        {"rsaauthentication", 11}, 
        {"pubkeyauthentication", 37}, 
        {"dsaauthentication", 37}, 
        {"passwordauthentication", 13}, 
        {"kbdinteractiveauthentication", 14}, 
        {"challengeresponseauthentication", 12}, 
        {"skeyauthentication", 12}, 
        {"checkmail", 24}, 
        {"listenaddress", 15}, 
        {"printmotd", 16}, 
        {"printlastlog", 17}, 
        {"ignorerhosts", 18}, 
        {"ignoreuserknownhosts", 31}, 
        {"x11forwarding", 19}, 
        {"x11displayoffset", 20}, 
        {"xauthlocation", 38}, 
        {"strictmodes", 21}, 
        {"permitemptypasswords", 22}, 
        {"uselogin", 25}, 
        {"keepalive", 23}, 
        {"allowtcpforwarding", 26}, 
        {"allowusers", 27}, 
        {"denyusers", 28}, 
        {"allowgroups", 29}, 
        {"denygroups", 30}, 
        {"ciphers", 32}, 
        {"macs", 33}, 
        {"protocol", 34}, 
        {"gatewayports", 36}, 
        {"subsystem", 39}, 
        {"maxstartups", 40}, 
        {"banner", 41}, 
        {"reversemappingcheck", 42}, 
        {"clientaliveinterval", 45}, 
        {"clientalivecountmax", 46}, 
        {"PAMAuthenticationViaKbdInt", 47}, 
        {(char const   *)((void *)0), (ServerOpCodes )0}};
#line 312 "servconf.c"
static ServerOpCodes parse_token(char const   *cp , char const   *filename , int linenum ) 
{ u_int i ;
  int tmp ;

  {
#line 318
  i = 0U;
#line 318
  while (keywords[i].name) {
#line 319
    tmp = strcasecmp(cp, keywords[i].name);
#line 319
    if (tmp == 0) {
#line 320
      return (keywords[i].opcode);
    }
#line 318
    i ++;
  }
#line 322
  error("%s: line %d: Bad configuration option: %s", filename, linenum, cp);
#line 324
  return (0);
}
}
#line 327 "servconf.c"
void add_listen_addr(ServerOptions *options___0 , char *addr , u_short port ) 
{ int i ;
  u_int tmp ;

  {
#line 332
  if (options___0->num_ports == 0U) {
#line 333
    tmp = options___0->num_ports;
#line 333
    (options___0->num_ports) ++;
#line 333
    options___0->ports[tmp] = (unsigned short)22;
  }
#line 334
  if ((int )port == 0) {
#line 335
    i = 0;
#line 335
    while ((u_int )i < options___0->num_ports) {
#line 336
      add_one_listen_addr(options___0, addr, options___0->ports[i]);
#line 335
      i ++;
    }
  } else {
#line 338
    add_one_listen_addr(options___0, addr, port);
  }
#line 339
  return;
}
}
#line 341 "servconf.c"
void add_one_listen_addr(ServerOptions *options___0 , char *addr , u_short port ) 
{ struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 348
  memset((void *)(& hints), 0, sizeof(hints));
#line 349
  hints.ai_family = IPv4or6;
#line 350
  hints.ai_socktype = 1;
#line 351
  if ((unsigned int )addr == (unsigned int )((void *)0)) {
#line 351
    hints.ai_flags = 1;
  } else {
#line 351
    hints.ai_flags = 0;
  }
#line 352
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           port);
#line 353
  gaierr = getaddrinfo((char const   * __restrict  )addr, (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 353
  if (gaierr != 0) {
#line 354
    tmp = gai_strerror(gaierr);
#line 354
    if (addr) {
#line 354
      tmp___0 = (char const   *)addr;
    } else {
#line 354
      tmp___0 = "<NULL>";
    }
#line 354
    fatal("bad addr or host: %s (%s)", tmp___0, tmp);
  }
#line 357
  ai = aitop;
#line 357
  while (ai->ai_next) {
#line 357
    ai = ai->ai_next;
  }
#line 359
  ai->ai_next = options___0->listen_addrs;
#line 360
  options___0->listen_addrs = aitop;
#line 361
  return;
}
}
#line 365 "servconf.c"
void read_server_config(ServerOptions *options___0 , char const   *filename ) 
{ FILE *f ;
  char line[1024] ;
  char *cp ;
  char **charptr ;
  char *arg ;
  char *p ;
  int linenum ;
  int *intptr ;
  int value ;
  int bad_options ;
  ServerOpCodes opcode ;
  int i ;
  u_int tmp ;
  int tmp___0 ;
  int tmp___14 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  char *tmp___28 ;
  size_t tmp___29 ;
  char *tmp___31 ;
  char *tmp___33 ;
  u_short port ;
  int tmp___34 ;
  __uid_t tmp___35 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___41 ;
  int tmp___44 ;
  int tmp___45 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___51 ;
  int tmp___54 ;
  int tmp___55 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___61 ;
  int tmp___64 ;
  int tmp___65 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___71 ;
  int tmp___74 ;
  int tmp___75 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___81 ;
  int tmp___84 ;
  int tmp___85 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___91 ;
  int tmp___94 ;
  int tmp___95 ;
  SyslogFacility tmp___96 ;
  char const   *tmp___97 ;
  LogLevel tmp___98 ;
  char const   *tmp___99 ;
  u_int tmp___100 ;
  u_int tmp___101 ;
  u_int tmp___102 ;
  u_int tmp___103 ;
  char const   *tmp___104 ;
  int tmp___105 ;
  char const   *tmp___106 ;
  int tmp___107 ;
  char const   *tmp___108 ;
  size_t __s1_len___7 ;
  size_t __s2_len___7 ;
  int tmp___114 ;
  int tmp___117 ;
  int tmp___118 ;
  int tmp___119 ;
  char *tmp___120 ;

  {
#line 372
  bad_options = 0;
#line 376
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 377
  if (! f) {
#line 378
    perror(filename);
#line 379
    exit(1);
  }
#line 381
  linenum = 0;
#line 382
  while (1) {
#line 382
    tmp___120 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 382
    if (! tmp___120) {
#line 382
      break;
    }
#line 383
    linenum ++;
#line 384
    cp = line;
#line 385
    arg = strdelim(& cp);
#line 387
    if ((int )*arg == 0) {
#line 388
      arg = strdelim(& cp);
    }
#line 389
    if (! arg) {
#line 390
      continue;
    } else {
#line 389
      if (! *arg) {
#line 390
        continue;
      } else {
#line 389
        if ((int )*arg == 35) {
#line 390
          continue;
        }
      }
    }
#line 391
    intptr = (int *)((void *)0);
#line 392
    charptr = (char **)((void *)0);
#line 393
    opcode = parse_token((char const   *)arg, filename, linenum);
#line 394
    switch ((int )opcode) {
    case 0: 
#line 396
    bad_options ++;
#line 397
    continue;
    case 1: 
#line 400
    if (options___0->ports_from_cmdline) {
#line 401
      continue;
    }
#line 402
    if ((unsigned int )options___0->listen_addrs != (unsigned int )((void *)0)) {
#line 403
      fatal("%s line %d: ports must be specified before ListenAdress.\n", filename,
            linenum);
    }
#line 405
    if (options___0->num_ports >= 256U) {
#line 406
      fatal("%s line %d: too many ports.", filename, linenum);
    }
#line 408
    arg = strdelim(& cp);
#line 409
    if (! arg) {
#line 410
      fatal("%s line %d: missing port number.", filename, linenum);
    } else {
#line 409
      if ((int )*arg == 0) {
#line 410
        fatal("%s line %d: missing port number.", filename, linenum);
      }
    }
#line 412
    tmp = options___0->num_ports;
#line 412
    (options___0->num_ports) ++;
#line 412
    tmp___0 = a2port((char const   *)arg);
#line 412
    options___0->ports[tmp] = (unsigned short )tmp___0;
#line 413
    if ((int )options___0->ports[options___0->num_ports - 1U] == 0) {
#line 414
      fatal("%s line %d: Badly formatted port number.", filename, linenum);
    }
#line 416
    break;
    case 3: 
#line 419
    intptr = & options___0->server_key_bits;
    parse_int: 
#line 421
    arg = strdelim(& cp);
#line 422
    if (! arg) {
#line 423
      fatal("%s line %d: missing integer value.", filename, linenum);
    } else {
#line 422
      if ((int )*arg == 0) {
#line 423
        fatal("%s line %d: missing integer value.", filename, linenum);
      }
    }
#line 425
    value = atoi((char const   *)arg);
#line 426
    if (*intptr == -1) {
#line 427
      *intptr = value;
    }
#line 428
    break;
    case 4: 
#line 431
    intptr = & options___0->login_grace_time;
    goto parse_int;
    case 5: 
#line 435
    intptr = & options___0->key_regeneration_time;
    goto parse_int;
    case 15: 
#line 439
    arg = strdelim(& cp);
#line 440
    if (! arg) {
#line 441
      fatal("%s line %d: missing inet addr.", filename, linenum);
    } else {
#line 440
      if ((int )*arg == 0) {
#line 441
        fatal("%s line %d: missing inet addr.", filename, linenum);
      } else {
#line 440
        if (0) {
#line 440
          if (0) {
#line 440
            __s1_len___0 = strlen((char const   *)arg);
#line 440
            __s2_len___0 = strlen("[]");
#line 440
            if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
              goto _L___2;
            } else {
#line 440
              if (__s1_len___0 >= 4U) {
                _L___2: /* CIL Label */ 
#line 440
                if (! ((unsigned int )((void const   *)("[]" + 1)) - (unsigned int )((void const   *)"[]") == 1U)) {
#line 440
                  tmp___24 = 1;
                } else {
#line 440
                  if (__s2_len___0 >= 4U) {
#line 440
                    tmp___24 = 1;
                  } else {
#line 440
                    tmp___24 = 0;
                  }
                }
              } else {
#line 440
                tmp___24 = 0;
              }
            }
#line 440
            if (tmp___24) {
#line 440
              tmp___20 = __builtin_strcmp((char const   *)arg, "[]");
            } else {
#line 440
              tmp___23 = __builtin_strcmp((char const   *)arg, "[]");
#line 440
              tmp___20 = tmp___23;
            }
          } else {
#line 440
            tmp___23 = __builtin_strcmp((char const   *)arg, "[]");
#line 440
            tmp___20 = tmp___23;
          }
#line 440
          tmp___14 = tmp___20;
        } else {
#line 440
          tmp___14 = strncmp((char const   *)arg, "[]", 2U);
        }
#line 440
        if (tmp___14 == 0) {
#line 441
          fatal("%s line %d: missing inet addr.", filename, linenum);
        }
      }
    }
#line 443
    if ((int )*arg == 91) {
#line 444
      tmp___28 = __builtin_strchr(arg, ']');
#line 444
      p = tmp___28;
#line 444
      if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 445
        fatal("%s line %d: bad ipv6 inet addr usage.", filename, linenum);
      }
#line 447
      arg ++;
#line 448
      tmp___29 = strlen((char const   *)(p + 1));
#line 448
      memmove((void *)p, (void const   *)(p + 1), tmp___29 + 1U);
    } else {
#line 449
      tmp___31 = __builtin_strchr(arg, ':');
#line 449
      p = tmp___31;
#line 449
      if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 451
        add_listen_addr(options___0, arg, (unsigned short)0);
#line 452
        break;
      } else {
#line 449
        tmp___33 = __builtin_strchr(p + 1, ':');
#line 449
        if ((unsigned int )tmp___33 != (unsigned int )((void *)0)) {
#line 451
          add_listen_addr(options___0, arg, (unsigned short)0);
#line 452
          break;
        }
      }
    }
#line 454
    if ((int )*p == 58) {
#line 457
      p ++;
#line 458
      if ((int )*p == 0) {
#line 459
        fatal("%s line %d: bad inet addr:port usage.", filename, linenum);
      } else {
#line 462
        *(p - 1) = (char )'\000';
#line 463
        tmp___34 = a2port((char const   *)p);
#line 463
        port = (unsigned short )tmp___34;
#line 463
        if ((int )port == 0) {
#line 464
          fatal("%s line %d: bad port number.", filename, linenum);
        }
#line 466
        add_listen_addr(options___0, arg, port);
      }
    } else {
#line 468
      if ((int )*p == 0) {
#line 469
        add_listen_addr(options___0, arg, (unsigned short)0);
      } else {
#line 471
        fatal("%s line %d: bad inet addr usage.", filename, linenum);
      }
    }
#line 473
    break;
    case 2: 
#line 476
    intptr = & options___0->num_host_key_files;
#line 477
    if (*intptr >= 256) {
#line 478
      fatal("%s line %d: too many host keys specified (max %d).", filename, linenum,
            256);
    }
#line 480
    charptr = & options___0->host_key_files[*intptr];
    parse_filename: 
#line 482
    arg = strdelim(& cp);
#line 483
    if (! arg) {
#line 484
      fatal("%s line %d: missing file name.", filename, linenum);
    } else {
#line 483
      if ((int )*arg == 0) {
#line 484
        fatal("%s line %d: missing file name.", filename, linenum);
      }
    }
#line 486
    if ((unsigned int )*charptr == (unsigned int )((void *)0)) {
#line 487
      tmp___35 = getuid();
#line 487
      *charptr = tilde_expand_filename((char const   *)arg, tmp___35);
#line 489
      if ((unsigned int )intptr != (unsigned int )((void *)0)) {
#line 490
        (*intptr) ++;
      }
    }
#line 492
    break;
    case 35: 
#line 495
    charptr = & options___0->pid_file;
    goto parse_filename;
    case 6: 
#line 499
    intptr = & options___0->permit_root_login;
#line 500
    arg = strdelim(& cp);
#line 501
    if (! arg) {
#line 502
      fatal("%s line %d: missing yes/without-password/forced-commands-only/no argument.",
            filename, linenum);
    } else {
#line 501
      if ((int )*arg == 0) {
#line 502
        fatal("%s line %d: missing yes/without-password/forced-commands-only/no argument.",
              filename, linenum);
      }
    }
#line 505
    value = 0;
#line 506
    if (0) {
#line 506
      __s1_len___4 = strlen((char const   *)arg);
#line 506
      __s2_len___4 = strlen("without-password");
#line 506
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___10;
      } else {
#line 506
        if (__s1_len___4 >= 4U) {
          _L___10: /* CIL Label */ 
#line 506
          if (! ((unsigned int )((void const   *)("without-password" + 1)) - (unsigned int )((void const   *)"without-password") == 1U)) {
#line 506
            tmp___75 = 1;
          } else {
#line 506
            if (__s2_len___4 >= 4U) {
#line 506
              tmp___75 = 1;
            } else {
#line 506
              tmp___75 = 0;
            }
          }
        } else {
#line 506
          tmp___75 = 0;
        }
      }
#line 506
      if (tmp___75) {
#line 506
        tmp___71 = __builtin_strcmp((char const   *)arg, "without-password");
      } else {
#line 506
        tmp___74 = __builtin_strcmp((char const   *)arg, "without-password");
#line 506
        tmp___71 = tmp___74;
      }
    } else {
#line 506
      tmp___74 = __builtin_strcmp((char const   *)arg, "without-password");
#line 506
      tmp___71 = tmp___74;
    }
#line 506
    if (tmp___71 == 0) {
#line 507
      value = 2;
    } else {
#line 508
      if (0) {
#line 508
        __s1_len___3 = strlen((char const   *)arg);
#line 508
        __s2_len___3 = strlen("forced-commands-only");
#line 508
        if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
          goto _L___8;
        } else {
#line 508
          if (__s1_len___3 >= 4U) {
            _L___8: /* CIL Label */ 
#line 508
            if (! ((unsigned int )((void const   *)("forced-commands-only" + 1)) - (unsigned int )((void const   *)"forced-commands-only") == 1U)) {
#line 508
              tmp___65 = 1;
            } else {
#line 508
              if (__s2_len___3 >= 4U) {
#line 508
                tmp___65 = 1;
              } else {
#line 508
                tmp___65 = 0;
              }
            }
          } else {
#line 508
            tmp___65 = 0;
          }
        }
#line 508
        if (tmp___65) {
#line 508
          tmp___61 = __builtin_strcmp((char const   *)arg, "forced-commands-only");
        } else {
#line 508
          tmp___64 = __builtin_strcmp((char const   *)arg, "forced-commands-only");
#line 508
          tmp___61 = tmp___64;
        }
      } else {
#line 508
        tmp___64 = __builtin_strcmp((char const   *)arg, "forced-commands-only");
#line 508
        tmp___61 = tmp___64;
      }
#line 508
      if (tmp___61 == 0) {
#line 509
        value = 1;
      } else {
#line 510
        if (0) {
#line 510
          __s1_len___2 = strlen((char const   *)arg);
#line 510
          __s2_len___2 = strlen("yes");
#line 510
          if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
            goto _L___6;
          } else {
#line 510
            if (__s1_len___2 >= 4U) {
              _L___6: /* CIL Label */ 
#line 510
              if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 510
                tmp___55 = 1;
              } else {
#line 510
                if (__s2_len___2 >= 4U) {
#line 510
                  tmp___55 = 1;
                } else {
#line 510
                  tmp___55 = 0;
                }
              }
            } else {
#line 510
              tmp___55 = 0;
            }
          }
#line 510
          if (tmp___55) {
#line 510
            tmp___51 = __builtin_strcmp((char const   *)arg, "yes");
          } else {
#line 510
            tmp___54 = __builtin_strcmp((char const   *)arg, "yes");
#line 510
            tmp___51 = tmp___54;
          }
        } else {
#line 510
          tmp___54 = __builtin_strcmp((char const   *)arg, "yes");
#line 510
          tmp___51 = tmp___54;
        }
#line 510
        if (tmp___51 == 0) {
#line 511
          value = 3;
        } else {
#line 512
          if (0) {
#line 512
            __s1_len___1 = strlen((char const   *)arg);
#line 512
            __s2_len___1 = strlen("no");
#line 512
            if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
              goto _L___4;
            } else {
#line 512
              if (__s1_len___1 >= 4U) {
                _L___4: /* CIL Label */ 
#line 512
                if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 512
                  tmp___45 = 1;
                } else {
#line 512
                  if (__s2_len___1 >= 4U) {
#line 512
                    tmp___45 = 1;
                  } else {
#line 512
                    tmp___45 = 0;
                  }
                }
              } else {
#line 512
                tmp___45 = 0;
              }
            }
#line 512
            if (tmp___45) {
#line 512
              tmp___41 = __builtin_strcmp((char const   *)arg, "no");
            } else {
#line 512
              tmp___44 = __builtin_strcmp((char const   *)arg, "no");
#line 512
              tmp___41 = tmp___44;
            }
          } else {
#line 512
            tmp___44 = __builtin_strcmp((char const   *)arg, "no");
#line 512
            tmp___41 = tmp___44;
          }
#line 512
          if (tmp___41 == 0) {
#line 513
            value = 0;
          } else {
#line 515
            fatal("%s line %d: Bad yes/without-password/forced-commands-only/no argument: %s",
                  filename, linenum, arg);
          }
        }
      }
    }
#line 518
    if (*intptr == -1) {
#line 519
      *intptr = value;
    }
#line 520
    break;
    case 18: 
#line 523
    intptr = & options___0->ignore_rhosts;
    parse_flag: 
#line 525
    arg = strdelim(& cp);
#line 526
    if (! arg) {
#line 527
      fatal("%s line %d: missing yes/no argument.", filename, linenum);
    } else {
#line 526
      if ((int )*arg == 0) {
#line 527
        fatal("%s line %d: missing yes/no argument.", filename, linenum);
      }
    }
#line 529
    value = 0;
#line 530
    if (0) {
#line 530
      __s1_len___6 = strlen((char const   *)arg);
#line 530
      __s2_len___6 = strlen("yes");
#line 530
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___14;
      } else {
#line 530
        if (__s1_len___6 >= 4U) {
          _L___14: /* CIL Label */ 
#line 530
          if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 530
            tmp___95 = 1;
          } else {
#line 530
            if (__s2_len___6 >= 4U) {
#line 530
              tmp___95 = 1;
            } else {
#line 530
              tmp___95 = 0;
            }
          }
        } else {
#line 530
          tmp___95 = 0;
        }
      }
#line 530
      if (tmp___95) {
#line 530
        tmp___91 = __builtin_strcmp((char const   *)arg, "yes");
      } else {
#line 530
        tmp___94 = __builtin_strcmp((char const   *)arg, "yes");
#line 530
        tmp___91 = tmp___94;
      }
    } else {
#line 530
      tmp___94 = __builtin_strcmp((char const   *)arg, "yes");
#line 530
      tmp___91 = tmp___94;
    }
#line 530
    if (tmp___91 == 0) {
#line 531
      value = 1;
    } else {
#line 532
      if (0) {
#line 532
        __s1_len___5 = strlen((char const   *)arg);
#line 532
        __s2_len___5 = strlen("no");
#line 532
        if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
          goto _L___12;
        } else {
#line 532
          if (__s1_len___5 >= 4U) {
            _L___12: /* CIL Label */ 
#line 532
            if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 532
              tmp___85 = 1;
            } else {
#line 532
              if (__s2_len___5 >= 4U) {
#line 532
                tmp___85 = 1;
              } else {
#line 532
                tmp___85 = 0;
              }
            }
          } else {
#line 532
            tmp___85 = 0;
          }
        }
#line 532
        if (tmp___85) {
#line 532
          tmp___81 = __builtin_strcmp((char const   *)arg, "no");
        } else {
#line 532
          tmp___84 = __builtin_strcmp((char const   *)arg, "no");
#line 532
          tmp___81 = tmp___84;
        }
      } else {
#line 532
        tmp___84 = __builtin_strcmp((char const   *)arg, "no");
#line 532
        tmp___81 = tmp___84;
      }
#line 532
      if (tmp___81 == 0) {
#line 533
        value = 0;
      } else {
#line 535
        fatal("%s line %d: Bad yes/no argument: %s", filename, linenum, arg);
      }
    }
#line 537
    if (*intptr == -1) {
#line 538
      *intptr = value;
    }
#line 539
    break;
    case 31: 
#line 542
    intptr = & options___0->ignore_user_known_hosts;
    goto parse_flag;
    case 9: 
#line 546
    intptr = & options___0->rhosts_authentication;
    goto parse_flag;
    case 10: 
#line 550
    intptr = & options___0->rhosts_rsa_authentication;
    goto parse_flag;
    case 43: 
#line 554
    intptr = & options___0->hostbased_authentication;
    goto parse_flag;
    case 44: 
#line 558
    intptr = & options___0->hostbased_uses_name_from_packet_only;
    goto parse_flag;
    case 11: 
#line 562
    intptr = & options___0->rsa_authentication;
    goto parse_flag;
    case 37: 
#line 566
    intptr = & options___0->pubkey_authentication;
    goto parse_flag;
    case 13: 
#line 594
    intptr = & options___0->password_authentication;
    goto parse_flag;
    case 14: 
#line 598
    intptr = & options___0->kbd_interactive_authentication;
    goto parse_flag;
    case 24: 
#line 602
    intptr = & options___0->check_mail;
    goto parse_flag;
    case 12: 
#line 606
    intptr = & options___0->challenge_reponse_authentication;
    goto parse_flag;
    case 16: 
#line 610
    intptr = & options___0->print_motd;
    goto parse_flag;
    case 17: 
#line 614
    intptr = & options___0->print_lastlog;
    goto parse_flag;
    case 19: 
#line 618
    intptr = & options___0->x11_forwarding;
    goto parse_flag;
    case 20: 
#line 622
    intptr = & options___0->x11_display_offset;
    goto parse_int;
    case 38: 
#line 626
    charptr = & options___0->xauth_location;
    goto parse_filename;
    case 21: 
#line 630
    intptr = & options___0->strict_modes;
    goto parse_flag;
    case 23: 
#line 634
    intptr = & options___0->keepalives;
    goto parse_flag;
    case 22: 
#line 638
    intptr = & options___0->permit_empty_passwd;
    goto parse_flag;
    case 25: 
#line 642
    intptr = & options___0->use_login;
    goto parse_flag;
    case 36: 
#line 646
    intptr = & options___0->gateway_ports;
    goto parse_flag;
    case 42: 
#line 650
    intptr = & options___0->reverse_mapping_check;
    goto parse_flag;
    case 7: 
#line 654
    intptr = (int *)(& options___0->log_facility);
#line 655
    arg = strdelim(& cp);
#line 656
    tmp___96 = log_facility_number(arg);
#line 656
    value = (int )tmp___96;
#line 657
    if (value == (int )((enum __anonenum_SyslogFacility_63 )-1)) {
#line 658
      if (arg) {
#line 658
        tmp___97 = (char const   *)arg;
      } else {
#line 658
        tmp___97 = "<NONE>";
      }
#line 658
      fatal("%.200s line %d: unsupported log facility \'%s\'", filename, linenum,
            tmp___97);
    }
#line 660
    if (*intptr == -1) {
#line 661
      *intptr = (int )((enum __anonenum_SyslogFacility_63 )value);
    }
#line 662
    break;
    case 8: 
#line 665
    intptr = (int *)(& options___0->log_level);
#line 666
    arg = strdelim(& cp);
#line 667
    tmp___98 = log_level_number(arg);
#line 667
    value = (int )tmp___98;
#line 668
    if (value == (int )((enum __anonenum_LogLevel_64 )-1)) {
#line 669
      if (arg) {
#line 669
        tmp___99 = (char const   *)arg;
      } else {
#line 669
        tmp___99 = "<NONE>";
      }
#line 669
      fatal("%.200s line %d: unsupported log level \'%s\'", filename, linenum, tmp___99);
    }
#line 671
    if (*intptr == -1) {
#line 672
      *intptr = (int )((enum __anonenum_LogLevel_64 )value);
    }
#line 673
    break;
    case 26: 
#line 676
    intptr = & options___0->allow_tcp_forwarding;
    goto parse_flag;
    case 27: 
#line 680
    while (1) {
#line 680
      arg = strdelim(& cp);
#line 680
      if (arg) {
#line 680
        if (! ((int )*arg != 0)) {
#line 680
          break;
        }
      } else {
#line 680
        break;
      }
#line 681
      if (options___0->num_allow_users >= 256U) {
#line 682
        fatal("%s line %d: too many allow users.", filename, linenum);
      }
#line 684
      tmp___100 = options___0->num_allow_users;
#line 684
      (options___0->num_allow_users) ++;
#line 684
      options___0->allow_users[tmp___100] = xstrdup((char const   *)arg);
    }
#line 686
    break;
    case 28: 
#line 689
    while (1) {
#line 689
      arg = strdelim(& cp);
#line 689
      if (arg) {
#line 689
        if (! ((int )*arg != 0)) {
#line 689
          break;
        }
      } else {
#line 689
        break;
      }
#line 690
      if (options___0->num_deny_users >= 256U) {
#line 691
        fatal("%s line %d: too many deny users.", filename, linenum);
      }
#line 693
      tmp___101 = options___0->num_deny_users;
#line 693
      (options___0->num_deny_users) ++;
#line 693
      options___0->deny_users[tmp___101] = xstrdup((char const   *)arg);
    }
#line 695
    break;
    case 29: 
#line 698
    while (1) {
#line 698
      arg = strdelim(& cp);
#line 698
      if (arg) {
#line 698
        if (! ((int )*arg != 0)) {
#line 698
          break;
        }
      } else {
#line 698
        break;
      }
#line 699
      if (options___0->num_allow_groups >= 256U) {
#line 700
        fatal("%s line %d: too many allow groups.", filename, linenum);
      }
#line 702
      tmp___102 = options___0->num_allow_groups;
#line 702
      (options___0->num_allow_groups) ++;
#line 702
      options___0->allow_groups[tmp___102] = xstrdup((char const   *)arg);
    }
#line 704
    break;
    case 30: 
#line 707
    while (1) {
#line 707
      arg = strdelim(& cp);
#line 707
      if (arg) {
#line 707
        if (! ((int )*arg != 0)) {
#line 707
          break;
        }
      } else {
#line 707
        break;
      }
#line 708
      if (options___0->num_deny_groups >= 256U) {
#line 709
        fatal("%s line %d: too many deny groups.", filename, linenum);
      }
#line 711
      tmp___103 = options___0->num_deny_groups;
#line 711
      (options___0->num_deny_groups) ++;
#line 711
      options___0->deny_groups[tmp___103] = xstrdup((char const   *)arg);
    }
#line 713
    break;
    case 32: 
#line 716
    arg = strdelim(& cp);
#line 717
    if (! arg) {
#line 718
      fatal("%s line %d: Missing argument.", filename, linenum);
    } else {
#line 717
      if ((int )*arg == 0) {
#line 718
        fatal("%s line %d: Missing argument.", filename, linenum);
      }
    }
#line 719
    tmp___105 = ciphers_valid((char const   *)arg);
#line 719
    if (! tmp___105) {
#line 720
      if (arg) {
#line 720
        tmp___104 = (char const   *)arg;
      } else {
#line 720
        tmp___104 = "<NONE>";
      }
#line 720
      fatal("%s line %d: Bad SSH2 cipher spec \'%s\'.", filename, linenum, tmp___104);
    }
#line 722
    if ((unsigned int )options___0->ciphers == (unsigned int )((void *)0)) {
#line 723
      options___0->ciphers = xstrdup((char const   *)arg);
    }
#line 724
    break;
    case 33: 
#line 727
    arg = strdelim(& cp);
#line 728
    if (! arg) {
#line 729
      fatal("%s line %d: Missing argument.", filename, linenum);
    } else {
#line 728
      if ((int )*arg == 0) {
#line 729
        fatal("%s line %d: Missing argument.", filename, linenum);
      }
    }
#line 730
    tmp___107 = mac_valid((char const   *)arg);
#line 730
    if (! tmp___107) {
#line 731
      if (arg) {
#line 731
        tmp___106 = (char const   *)arg;
      } else {
#line 731
        tmp___106 = "<NONE>";
      }
#line 731
      fatal("%s line %d: Bad SSH2 mac spec \'%s\'.", filename, linenum, tmp___106);
    }
#line 733
    if ((unsigned int )options___0->macs == (unsigned int )((void *)0)) {
#line 734
      options___0->macs = xstrdup((char const   *)arg);
    }
#line 735
    break;
    case 34: 
#line 738
    intptr = & options___0->protocol;
#line 739
    arg = strdelim(& cp);
#line 740
    if (! arg) {
#line 741
      fatal("%s line %d: Missing argument.", filename, linenum);
    } else {
#line 740
      if ((int )*arg == 0) {
#line 741
        fatal("%s line %d: Missing argument.", filename, linenum);
      }
    }
#line 742
    value = proto_spec((char const   *)arg);
#line 743
    if (value == 0) {
#line 744
      if (arg) {
#line 744
        tmp___108 = (char const   *)arg;
      } else {
#line 744
        tmp___108 = "<NONE>";
      }
#line 744
      fatal("%s line %d: Bad protocol spec \'%s\'.", filename, linenum, tmp___108);
    }
#line 746
    if (*intptr == 0) {
#line 747
      *intptr = value;
    }
#line 748
    break;
    case 39: 
#line 751
    if (options___0->num_subsystems >= 256U) {
#line 752
      fatal("%s line %d: too many subsystems defined.", filename, linenum);
    }
#line 755
    arg = strdelim(& cp);
#line 756
    if (! arg) {
#line 757
      fatal("%s line %d: Missing subsystem name.", filename, linenum);
    } else {
#line 756
      if ((int )*arg == 0) {
#line 757
        fatal("%s line %d: Missing subsystem name.", filename, linenum);
      }
    }
#line 759
    i = 0;
#line 759
    while ((u_int )i < options___0->num_subsystems) {
#line 760
      if (0) {
#line 760
        __s1_len___7 = strlen((char const   *)arg);
#line 760
        __s2_len___7 = strlen((char const   *)options___0->subsystem_name[i]);
#line 760
        if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
          goto _L___16;
        } else {
#line 760
          if (__s1_len___7 >= 4U) {
            _L___16: /* CIL Label */ 
#line 760
            if (! ((unsigned int )((void const   *)(options___0->subsystem_name[i] + 1)) - (unsigned int )((void const   *)options___0->subsystem_name[i]) == 1U)) {
#line 760
              tmp___118 = 1;
            } else {
#line 760
              if (__s2_len___7 >= 4U) {
#line 760
                tmp___118 = 1;
              } else {
#line 760
                tmp___118 = 0;
              }
            }
          } else {
#line 760
            tmp___118 = 0;
          }
        }
#line 760
        if (tmp___118) {
#line 760
          tmp___114 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
        } else {
#line 760
          tmp___117 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
#line 760
          tmp___114 = tmp___117;
        }
      } else {
#line 760
        tmp___117 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
#line 760
        tmp___114 = tmp___117;
      }
#line 760
      if (tmp___114 == 0) {
#line 761
        fatal("%s line %d: Subsystem \'%s\' already defined.", filename, linenum,
              arg);
      }
#line 759
      i ++;
    }
#line 763
    options___0->subsystem_name[options___0->num_subsystems] = xstrdup((char const   *)arg);
#line 764
    arg = strdelim(& cp);
#line 765
    if (! arg) {
#line 766
      fatal("%s line %d: Missing subsystem command.", filename, linenum);
    } else {
#line 765
      if ((int )*arg == 0) {
#line 766
        fatal("%s line %d: Missing subsystem command.", filename, linenum);
      }
    }
#line 768
    options___0->subsystem_command[options___0->num_subsystems] = xstrdup((char const   *)arg);
#line 769
    (options___0->num_subsystems) ++;
#line 770
    break;
    case 40: 
#line 773
    arg = strdelim(& cp);
#line 774
    if (! arg) {
#line 775
      fatal("%s line %d: Missing MaxStartups spec.", filename, linenum);
    } else {
#line 774
      if ((int )*arg == 0) {
#line 775
        fatal("%s line %d: Missing MaxStartups spec.", filename, linenum);
      }
    }
#line 777
    tmp___119 = sscanf((char const   * __restrict  )arg, (char const   * __restrict  )"%d:%d:%d",
                       & options___0->max_startups_begin, & options___0->max_startups_rate,
                       & options___0->max_startups);
#line 777
    if (tmp___119 == 3) {
#line 781
      if (options___0->max_startups_begin > options___0->max_startups) {
#line 785
        fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
      } else {
#line 781
        if (options___0->max_startups_rate > 100) {
#line 785
          fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
        } else {
#line 781
          if (options___0->max_startups_rate < 1) {
#line 785
            fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
          }
        }
      }
#line 787
      break;
    }
#line 789
    intptr = & options___0->max_startups;
    goto parse_int;
    case 41: 
#line 793
    charptr = & options___0->banner;
    goto parse_filename;
    case 45: 
#line 796
    intptr = & options___0->client_alive_interval;
    goto parse_int;
    case 46: 
#line 799
    intptr = & options___0->client_alive_count_max;
    goto parse_int;
    case 47: 
#line 802
    intptr = & options___0->pam_authentication_via_kbd_int;
    goto parse_flag;
    default: 
#line 806
    fatal("%s line %d: Missing handler for opcode %s (%d)", filename, linenum, arg,
          opcode);
    }
#line 809
    arg = strdelim(& cp);
#line 809
    if ((unsigned int )arg != (unsigned int )((void *)0)) {
#line 809
      if ((int )*arg != 0) {
#line 810
        fatal("%s line %d: garbage at end of line; \"%.200s\".", filename, linenum,
              arg);
      }
    }
  }
#line 813
  fclose(f);
#line 814
  if (bad_options > 0) {
#line 815
    fatal("%s: terminating, %d bad configuration options", filename, bad_options);
  }
#line 817
  return;
}
}
#line 1 "serverloop.o"
#pragma merger(0,"./serverloop.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 116 "/usr/include/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 31 "session.h"
int session_open(int chanid ) ;
#line 32
void session_input_channel_req(int id , void *arg ) ;
#line 33
void session_close_by_pid(pid_t pid , int status ) ;
#line 34
void session_close_by_channel(int id , void *arg ) ;
#line 21 "serverloop.h"
void server_loop(pid_t pid , int fdin_arg , int fdout_arg , int fderr_arg ) ;
#line 22
void server_loop2(void) ;
#line 63 "serverloop.c"
static Buffer stdin_buffer  ;
#line 64 "serverloop.c"
static Buffer stdout_buffer  ;
#line 65 "serverloop.c"
static Buffer stderr_buffer  ;
#line 66 "serverloop.c"
static int fdin  ;
#line 67 "serverloop.c"
static int fdout  ;
#line 69 "serverloop.c"
static int fderr  ;
#line 70 "serverloop.c"
static long stdin_bytes  =    0L;
#line 71 "serverloop.c"
static long stdout_bytes  =    0L;
#line 72 "serverloop.c"
static long stderr_bytes  =    0L;
#line 73 "serverloop.c"
static long fdout_bytes  =    0L;
#line 74 "serverloop.c"
static int stdin_eof  =    0;
#line 75 "serverloop.c"
static int fdout_eof  =    0;
#line 76 "serverloop.c"
static int fderr_eof  =    0;
#line 77 "serverloop.c"
static int fdin_is_tty  =    0;
#line 78 "serverloop.c"
static int connection_in___0  ;
#line 79 "serverloop.c"
static int connection_out___0  ;
#line 80 "serverloop.c"
static int connection_closed  =    0;
#line 81 "serverloop.c"
static u_int buffer_high  ;
#line 88 "serverloop.c"
static pid_t child_pid  ;
#line 89 "serverloop.c"
static int volatile   child_terminated  ;
#line 90 "serverloop.c"
static int volatile   child_wait_status  ;
#line 92
void server_init_dispatch(void) ;
#line 94 "serverloop.c"
int client_alive_timeouts  =    0;
#line 96 "serverloop.c"
void sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  pid_t wait_pid ;
  union __anonunion_80 __constr_expr_0 ;
  union __anonunion_81 __constr_expr_1 ;
  int *tmp___0 ;

  {
#line 99
  tmp = __errno_location();
#line 99
  save_errno = *tmp;
#line 102
  debug("Received SIGCHLD.");
#line 103
  wait_pid = wait((union wait *)((int *)(& child_wait_status)));
#line 104
  if (wait_pid != -1) {
#line 105
    if (wait_pid != child_pid) {
#line 106
      error("Strange, got SIGCHLD and wait returned pid %d but child is %d", wait_pid,
            child_pid);
    }
#line 108
    __constr_expr_0.__in = child_wait_status;
#line 108
    if ((__constr_expr_0.__i & 127) == 0) {
#line 110
      child_terminated = (int volatile   )1;
    } else {
#line 108
      __constr_expr_1.__in = child_wait_status;
#line 108
      if ((int )((signed char )((__constr_expr_1.__i & 127) + 1)) >> 1 > 0) {
#line 110
        child_terminated = (int volatile   )1;
      }
    }
  }
#line 112
  signal(17, & sigchld_handler);
#line 113
  tmp___0 = __errno_location();
#line 113
  *tmp___0 = save_errno;
#line 114
  return;
}
}
#line 115 "serverloop.c"
void sigchld_handler2(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 118
  tmp = __errno_location();
#line 118
  save_errno = *tmp;
#line 119
  debug("Received SIGCHLD.");
#line 120
  child_terminated = (int volatile   )1;
#line 121
  mysignal(17, & sigchld_handler2);
#line 122
  tmp___0 = __errno_location();
#line 122
  *tmp___0 = save_errno;
#line 123
  return;
}
}
#line 129 "serverloop.c"
void make_packets_from_stderr_data(void) 
{ int len ;
  u_int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  u_int tmp___2 ;
  int tmp___3 ;

  {
#line 135
  while (1) {
#line 135
    tmp___2 = buffer_len(& stderr_buffer);
#line 135
    if (tmp___2 > 0U) {
#line 135
      tmp___3 = packet_not_very_much_data_to_write();
#line 135
      if (! tmp___3) {
#line 135
        break;
      }
    } else {
#line 135
      break;
    }
#line 137
    tmp = buffer_len(& stderr_buffer);
#line 137
    len = (int )tmp;
#line 138
    tmp___0 = packet_is_interactive();
#line 138
    if (tmp___0) {
#line 139
      if (len > 512) {
#line 140
        len = 512;
      }
    } else {
#line 143
      if (len > max_packet_size) {
#line 144
        len = max_packet_size;
      }
    }
#line 146
    packet_start(18);
#line 147
    tmp___1 = buffer_ptr(& stderr_buffer);
#line 147
    packet_put_string((char const   *)tmp___1, (unsigned int )len);
#line 148
    packet_send();
#line 149
    buffer_consume(& stderr_buffer, (unsigned int )len);
#line 150
    stderr_bytes += (long )len;
  }
#line 152
  return;
}
}
#line 158 "serverloop.c"
void make_packets_from_stdout_data(void) 
{ int len ;
  u_int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  u_int tmp___2 ;
  int tmp___3 ;

  {
#line 164
  while (1) {
#line 164
    tmp___2 = buffer_len(& stdout_buffer);
#line 164
    if (tmp___2 > 0U) {
#line 164
      tmp___3 = packet_not_very_much_data_to_write();
#line 164
      if (! tmp___3) {
#line 164
        break;
      }
    } else {
#line 164
      break;
    }
#line 166
    tmp = buffer_len(& stdout_buffer);
#line 166
    len = (int )tmp;
#line 167
    tmp___0 = packet_is_interactive();
#line 167
    if (tmp___0) {
#line 168
      if (len > 512) {
#line 169
        len = 512;
      }
    } else {
#line 172
      if (len > max_packet_size) {
#line 173
        len = max_packet_size;
      }
    }
#line 175
    packet_start(17);
#line 176
    tmp___1 = buffer_ptr(& stdout_buffer);
#line 176
    packet_put_string((char const   *)tmp___1, (unsigned int )len);
#line 177
    packet_send();
#line 178
    buffer_consume(& stdout_buffer, (unsigned int )len);
#line 179
    stdout_bytes += (long )len;
  }
#line 181
  return;
}
}
#line 189 "serverloop.c"
void wait_until_can_do_something(fd_set **readsetp , fd_set **writesetp , int *maxfdp ,
                                 u_int max_time_milliseconds ) 
{ struct timeval tv ;
  struct timeval *tvp ;
  int ret ;
  int client_alive_scheduled ;
  int tmp ;
  u_int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  u_int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int id ;

  {
#line 195
  client_alive_scheduled = 0;
#line 205
  if (max_time_milliseconds == 0U) {
#line 205
    if (options.client_alive_interval) {
#line 206
      client_alive_scheduled = 1;
#line 207
      max_time_milliseconds = (unsigned int )(options.client_alive_interval * 1000);
    } else {
#line 209
      client_alive_scheduled = 0;
    }
  } else {
#line 209
    client_alive_scheduled = 0;
  }
  retry_select: 
#line 215
  channel_prepare_select(readsetp, writesetp, maxfdp, 0);
#line 217
  if (compat20) {
#line 219
    tmp = channel_not_very_much_buffered_data();
#line 219
    if (tmp) {
#line 220
      __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
  } else {
#line 226
    tmp___0 = buffer_len(& stdin_buffer);
#line 226
    if (tmp___0 < buffer_high) {
#line 226
      tmp___1 = channel_not_very_much_buffered_data();
#line 226
      if (tmp___1) {
#line 228
        __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
#line 233
    tmp___2 = packet_not_very_much_data_to_write();
#line 233
    if (tmp___2) {
#line 234
      if (! fdout_eof) {
#line 235
        __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->__fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
#line 236
      if (! fderr_eof) {
#line 237
        __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->__fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
#line 243
    if (fdin != -1) {
#line 243
      tmp___3 = buffer_len(& stdin_buffer);
#line 243
      if (tmp___3 > 0U) {
#line 244
        __asm__  volatile   ("btsl %1,%0": "=m" ((*writesetp)->__fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
  }
#line 251
  tmp___4 = packet_have_data_to_write();
#line 251
  if (tmp___4) {
#line 252
    __asm__  volatile   ("btsl %1,%0": "=m" ((*writesetp)->__fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 258
  if (child_terminated) {
#line 258
    tmp___5 = packet_not_very_much_data_to_write();
#line 258
    if (tmp___5) {
#line 259
      if (max_time_milliseconds == 0U) {
#line 260
        max_time_milliseconds = 100U;
      } else {
#line 259
        if (client_alive_scheduled) {
#line 260
          max_time_milliseconds = 100U;
        }
      }
    }
  }
#line 262
  if (max_time_milliseconds == 0U) {
#line 263
    tvp = (struct timeval *)((void *)0);
  } else {
#line 265
    tv.tv_sec = (long )(max_time_milliseconds / 1000U);
#line 266
    tv.tv_usec = (long )(1000U * (max_time_milliseconds % 1000U));
#line 267
    tvp = & tv;
  }
#line 269
  if ((unsigned int )tvp != (unsigned int )((void *)0)) {
#line 270
    debug3("tvp!=NULL kid %d mili %d", child_terminated, max_time_milliseconds);
  }
#line 273
  ret = select(*maxfdp + 1, (fd_set * __restrict  )*readsetp, (fd_set * __restrict  )*writesetp,
               (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )tvp);
#line 275
  if (ret == -1) {
#line 276
    tmp___8 = __errno_location();
#line 276
    if (*tmp___8 != 4) {
#line 277
      tmp___6 = __errno_location();
#line 277
      tmp___7 = strerror(*tmp___6);
#line 277
      error("select: %.100s", tmp___7);
    } else {
      goto retry_select;
    }
  }
#line 281
  if (ret == 0) {
#line 281
    if (client_alive_scheduled) {
#line 283
      client_alive_timeouts ++;
#line 285
      if (client_alive_timeouts > options.client_alive_count_max) {
#line 286
        packet_disconnect("Timeout, your session not responding.");
      } else {
#line 295
        id = channel_find_open();
#line 296
        if (id != -1) {
#line 297
          channel_request_start(id, (char *)"keepalive@openssh.com", 1);
#line 299
          packet_send();
        } else {
#line 301
          packet_disconnect("No open channels after timeout!");
        }
      }
    }
  }
#line 305
  return;
}
}
#line 311 "serverloop.c"
void process_input(fd_set *readset ) 
{ int len ;
  char buf___2[16384] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  register char __result ;
  int *tmp___3 ;
  int *tmp___4 ;
  register char __result___0 ;
  int *tmp___5 ;
  int *tmp___6 ;
  register char __result___1 ;

  {
#line 318
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 318
  if (__result) {
#line 319
    len = read(connection_in___0, (void *)(buf___2), sizeof(buf___2));
#line 320
    if (len == 0) {
#line 321
      verbose("Connection closed by remote host.");
#line 322
      connection_closed = 1;
#line 323
      if (compat20) {
#line 324
        return;
      }
#line 325
      fatal_cleanup();
    } else {
#line 326
      if (len < 0) {
#line 327
        tmp___1 = __errno_location();
#line 327
        if (*tmp___1 != 4) {
#line 327
          tmp___2 = __errno_location();
#line 327
          if (*tmp___2 != 11) {
#line 328
            tmp = __errno_location();
#line 328
            tmp___0 = strerror(*tmp);
#line 328
            verbose("Read error from remote host: %.100s", tmp___0);
#line 329
            fatal_cleanup();
          }
        }
      } else {
#line 333
        packet_process_incoming((char const   *)(buf___2), (unsigned int )len);
      }
    }
  }
#line 336
  if (compat20) {
#line 337
    return;
  }
#line 340
  if (! fdout_eof) {
#line 340
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "cc");
#line 340
    if (__result___0) {
#line 341
      len = read(fdout, (void *)(buf___2), sizeof(buf___2));
#line 342
      if (len < 0) {
#line 342
        tmp___3 = __errno_location();
#line 342
        if (! (*tmp___3 == 4)) {
#line 342
          tmp___4 = __errno_location();
#line 342
          if (! (*tmp___4 == 11)) {
            goto _L;
          }
        }
      } else {
        _L: /* CIL Label */ 
#line 344
        if (len <= 0) {
#line 345
          fdout_eof = 1;
        } else {
#line 347
          buffer_append(& stdout_buffer, (char const   *)(buf___2), (unsigned int )len);
#line 348
          fdout_bytes += (long )len;
        }
      }
    }
  }
#line 352
  if (! fderr_eof) {
#line 352
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___1): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "cc");
#line 352
    if (__result___1) {
#line 353
      len = read(fderr, (void *)(buf___2), sizeof(buf___2));
#line 354
      if (len < 0) {
#line 354
        tmp___5 = __errno_location();
#line 354
        if (! (*tmp___5 == 4)) {
#line 354
          tmp___6 = __errno_location();
#line 354
          if (! (*tmp___6 == 11)) {
            goto _L___0;
          }
        }
      } else {
        _L___0: /* CIL Label */ 
#line 356
        if (len <= 0) {
#line 357
          fderr_eof = 1;
        } else {
#line 359
          buffer_append(& stderr_buffer, (char const   *)(buf___2), (unsigned int )len);
        }
      }
    }
  }
#line 362
  return;
}
}
#line 367 "serverloop.c"
void process_output(fd_set *writeset ) 
{ struct termios tio ;
  int len ;
  u_int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  register char __result ;
  register char __result___0 ;

  {
#line 374
  if (! compat20) {
#line 374
    if (fdin != -1) {
#line 374
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))),
                           "m" (writeset->__fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "cc");
#line 374
      if (__result) {
#line 375
        tmp = buffer_len(& stdin_buffer);
#line 375
        tmp___0 = buffer_ptr(& stdin_buffer);
#line 375
        len = write(fdin, (void const   *)tmp___0, tmp);
#line 377
        if (len < 0) {
#line 377
          tmp___2 = __errno_location();
#line 377
          if (! (*tmp___2 == 4)) {
#line 377
            tmp___3 = __errno_location();
#line 377
            if (! (*tmp___3 == 11)) {
              goto _L;
            }
          }
        } else {
          _L: /* CIL Label */ 
#line 379
          if (len <= 0) {
#line 383
            if (fdin != fdout) {
#line 384
              close(fdin);
            } else {
#line 386
              shutdown(fdin, 1);
            }
#line 388
            fdin = -1;
          } else {
#line 391
            if (fdin_is_tty) {
#line 391
              tmp___1 = tcgetattr(fdin, & tio);
#line 391
              if (tmp___1 == 0) {
#line 391
                if (! (tio.c_lflag & 8U)) {
#line 391
                  if (tio.c_lflag & 2U) {
#line 397
                    packet_send_ignore(len);
#line 398
                    packet_send();
                  }
                }
              }
            }
#line 401
            buffer_consume(& stdin_buffer, (unsigned int )len);
#line 403
            stdin_bytes += (long )len;
          }
        }
      }
    }
  }
#line 407
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->__fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 407
  if (__result___0) {
#line 408
    packet_write_poll();
  }
#line 409
  return;
}
}
#line 415 "serverloop.c"
void drain_output(void) 
{ u_int tmp ;
  char *tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  char *tmp___4 ;
  u_int tmp___5 ;
  u_int tmp___6 ;

  {
#line 419
  tmp___2 = buffer_len(& stdout_buffer);
#line 419
  if (tmp___2 > 0U) {
#line 420
    packet_start(17);
#line 421
    tmp = buffer_len(& stdout_buffer);
#line 421
    tmp___0 = buffer_ptr(& stdout_buffer);
#line 421
    packet_put_string((char const   *)tmp___0, tmp);
#line 423
    packet_send();
#line 425
    tmp___1 = buffer_len(& stdout_buffer);
#line 425
    stdout_bytes = (long )((unsigned long )stdout_bytes + (unsigned long )tmp___1);
  }
#line 428
  tmp___6 = buffer_len(& stderr_buffer);
#line 428
  if (tmp___6 > 0U) {
#line 429
    packet_start(18);
#line 430
    tmp___3 = buffer_len(& stderr_buffer);
#line 430
    tmp___4 = buffer_ptr(& stderr_buffer);
#line 430
    packet_put_string((char const   *)tmp___4, tmp___3);
#line 432
    packet_send();
#line 434
    tmp___5 = buffer_len(& stderr_buffer);
#line 434
    stderr_bytes = (long )((unsigned long )stderr_bytes + (unsigned long )tmp___5);
  }
#line 437
  packet_write_wait();
#line 438
  return;
}
}
#line 440 "serverloop.c"
void process_buffered_input_packets(void) 
{ Kex *tmp ;

  {
#line 443
  if (compat20) {
#line 443
    tmp = xxx_kex;
  } else {
#line 443
    tmp = (Kex *)((void *)0);
  }
#line 443
  dispatch_run(1, (int *)((void *)0), (void *)tmp);
#line 444
  return;
}
}
#line 453 "serverloop.c"
void server_loop(pid_t pid , int fdin_arg , int fdout_arg , int fderr_arg ) 
{ fd_set *readset ;
  fd_set *writeset ;
  int max_fd ;
  int wait_status ;
  pid_t wait_pid ;
  int waiting_termination ;
  u_int max_time_milliseconds ;
  u_int previous_stdout_buffer_bytes ;
  u_int stdout_buffer_bytes ;
  int type ;
  int tmp ;
  int tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *s ;
  char *cp ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  u_int tmp___7 ;
  u_int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  union __anonunion_82 __constr_expr_0 ;
  union __anonunion_83 __constr_expr_1 ;
  int plen ;
  union __anonunion_84 __constr_expr_2 ;
  union __anonunion_85 __constr_expr_3 ;
  union __anonunion_86 __constr_expr_4 ;

  {
#line 456
  readset = (fd_set *)((void *)0);
#line 456
  writeset = (fd_set *)((void *)0);
#line 460
  waiting_termination = 0;
#line 466
  debug("Entering interactive session.");
#line 469
  child_pid = pid;
#line 470
  child_terminated = (int volatile   )0;
#line 471
  signal(17, & sigchld_handler);
#line 474
  fdin = fdin_arg;
#line 475
  fdout = fdout_arg;
#line 476
  fderr = fderr_arg;
#line 479
  set_nonblock(fdin);
#line 480
  set_nonblock(fdout);
#line 482
  if (fderr != -1) {
#line 483
    set_nonblock(fderr);
  }
#line 485
  if (! (datafellows & 256)) {
#line 485
    tmp = isatty(fdin);
#line 485
    if (tmp) {
#line 486
      fdin_is_tty = 1;
    }
  }
#line 488
  connection_in___0 = packet_get_connection_in();
#line 489
  connection_out___0 = packet_get_connection_out();
#line 491
  previous_stdout_buffer_bytes = 0U;
#line 494
  tmp___0 = packet_is_interactive();
#line 494
  if (tmp___0) {
#line 495
    buffer_high = 4096U;
  } else {
#line 497
    buffer_high = 65536U;
  }
#line 500
  if (fdin > fdout) {
#line 500
    max_fd = fdin;
  } else {
#line 500
    max_fd = fdout;
  }
#line 501
  if (fderr != -1) {
#line 502
    if (max_fd > fderr) {
#line 502
      max_fd = max_fd;
    } else {
#line 502
      max_fd = fderr;
    }
  }
#line 503
  if (max_fd > connection_in___0) {
#line 503
    max_fd = max_fd;
  } else {
#line 503
    max_fd = connection_in___0;
  }
#line 504
  if (max_fd > connection_out___0) {
#line 504
    max_fd = max_fd;
  } else {
#line 504
    max_fd = connection_out___0;
  }
#line 507
  buffer_init(& stdin_buffer);
#line 508
  buffer_init(& stdout_buffer);
#line 509
  buffer_init(& stderr_buffer);
#line 517
  if (fderr == -1) {
#line 518
    fderr_eof = 1;
  }
#line 520
  server_init_dispatch();
#line 523
  while (1) {
#line 526
    process_buffered_input_packets();
#line 532
    if (stdin_eof) {
#line 532
      if (fdin != -1) {
#line 532
        tmp___1 = buffer_len(& stdin_buffer);
#line 532
        if (tmp___1 == 0U) {
#line 536
          if (fdin != fdout) {
#line 537
            close(fdin);
          } else {
#line 539
            shutdown(fdin, 1);
          }
#line 541
          fdin = -1;
        }
      }
    }
#line 544
    make_packets_from_stderr_data();
#line 553
    max_time_milliseconds = 0U;
#line 554
    stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 555
    if (stdout_buffer_bytes != 0U) {
#line 555
      if (stdout_buffer_bytes < 256U) {
#line 555
        if (stdout_buffer_bytes != previous_stdout_buffer_bytes) {
#line 558
          max_time_milliseconds = 10U;
        } else {
#line 561
          make_packets_from_stdout_data();
        }
      } else {
#line 561
        make_packets_from_stdout_data();
      }
    } else {
#line 561
      make_packets_from_stdout_data();
    }
#line 563
    previous_stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 566
    tmp___2 = packet_not_very_much_data_to_write();
#line 566
    if (tmp___2) {
#line 567
      channel_output_poll();
    }
#line 574
    if (fdout_eof) {
#line 574
      if (fderr_eof) {
#line 574
        tmp___6 = packet_have_data_to_write();
#line 574
        if (! tmp___6) {
#line 574
          tmp___7 = buffer_len(& stdout_buffer);
#line 574
          if (tmp___7 == 0U) {
#line 574
            tmp___8 = buffer_len(& stderr_buffer);
#line 574
            if (tmp___8 == 0U) {
#line 576
              tmp___3 = channel_still_open();
#line 576
              if (! tmp___3) {
#line 577
                break;
              }
#line 578
              if (! waiting_termination) {
#line 579
                s = "Waiting for forwarded connections to terminate...\r\n";
#line 581
                waiting_termination = 1;
#line 582
                tmp___4 = strlen(s);
#line 582
                buffer_append(& stderr_buffer, s, tmp___4);
#line 585
                cp = channel_open_message();
#line 586
                tmp___5 = strlen((char const   *)cp);
#line 586
                buffer_append(& stderr_buffer, (char const   *)cp, tmp___5);
#line 587
                xfree((void *)cp);
              }
            }
          }
        }
      }
    }
#line 591
    wait_until_can_do_something(& readset, & writeset, & max_fd, max_time_milliseconds);
#line 595
    channel_after_select(readset, writeset);
#line 598
    process_input(readset);
#line 601
    process_output(writeset);
  }
#line 603
  if (readset) {
#line 604
    xfree((void *)readset);
  }
#line 605
  if (writeset) {
#line 606
    xfree((void *)writeset);
  }
#line 611
  drain_output();
#line 613
  debug("End of interactive session; stdin %ld, stdout (read %ld, sent %ld), stderr %ld bytes.",
        stdin_bytes, fdout_bytes, stdout_bytes, stderr_bytes);
#line 617
  buffer_free(& stdin_buffer);
#line 618
  buffer_free(& stdout_buffer);
#line 619
  buffer_free(& stderr_buffer);
#line 622
  if (fdout != -1) {
#line 623
    close(fdout);
  }
#line 624
  fdout = -1;
#line 625
  fdout_eof = 1;
#line 626
  if (fderr != -1) {
#line 627
    close(fderr);
  }
#line 628
  fderr = -1;
#line 629
  fderr_eof = 1;
#line 630
  if (fdin != -1) {
#line 631
    close(fdin);
  }
#line 632
  fdin = -1;
#line 635
  channel_stop_listening();
#line 638
  wait_pid = wait((union wait *)(& wait_status));
#line 639
  if (wait_pid == -1) {
#line 645
    if (child_terminated) {
#line 646
      wait_status = (int )child_wait_status;
    } else {
#line 648
      tmp___9 = __errno_location();
#line 648
      tmp___10 = strerror(*tmp___9);
#line 648
      packet_disconnect("wait: %.100s", tmp___10);
    }
  } else {
#line 651
    if (wait_pid != pid) {
#line 652
      error("Strange, wait returned pid %d, expected %d", wait_pid, pid);
    }
  }
#line 657
  signal(17, (void (*)(int  ))0);
#line 660
  __constr_expr_2.__in = wait_status;
#line 660
  if ((__constr_expr_2.__i & 127) == 0) {
#line 662
    __constr_expr_0.__in = wait_status;
#line 662
    debug("Command exited with status %d.", (__constr_expr_0.__i & 65280) >> 8);
#line 663
    packet_start(20);
#line 664
    __constr_expr_1.__in = wait_status;
#line 664
    packet_put_int((unsigned int )((__constr_expr_1.__i & 65280) >> 8));
#line 665
    packet_send();
#line 666
    packet_write_wait();
#line 675
    while (1) {
#line 677
      type = packet_read(& plen);
#line 675
      if (! (type != 33)) {
#line 675
        break;
      }
    }
#line 681
    debug("Received exit confirmation.");
#line 682
    return;
  }
#line 685
  __constr_expr_4.__in = wait_status;
#line 685
  if ((int )((signed char )((__constr_expr_4.__i & 127) + 1)) >> 1 > 0) {
#line 686
    __constr_expr_3.__in = wait_status;
#line 686
    packet_disconnect("Command terminated on signal %d.", __constr_expr_3.__i & 127);
  }
#line 690
  packet_disconnect("wait returned status %04x.", wait_status);
#line 692
  return;
}
}
#line 694 "serverloop.c"
void server_loop2(void) 
{ fd_set *readset ;
  fd_set *writeset ;
  int rekeying ;
  int max_fd ;
  int status ;
  pid_t pid ;
  int tmp ;
  int tmp___0 ;

  {
#line 697
  readset = (fd_set *)((void *)0);
#line 697
  writeset = (fd_set *)((void *)0);
#line 698
  rekeying = 0;
#line 701
  debug("Entering interactive session for SSH2.");
#line 703
  mysignal(17, & sigchld_handler2);
#line 704
  child_terminated = (int volatile   )0;
#line 705
  connection_in___0 = packet_get_connection_in();
#line 706
  connection_out___0 = packet_get_connection_out();
#line 708
  if (connection_in___0 > connection_out___0) {
#line 708
    max_fd = connection_in___0;
  } else {
#line 708
    max_fd = connection_out___0;
  }
#line 710
  server_init_dispatch();
#line 712
  while (1) {
#line 713
    process_buffered_input_packets();
#line 715
    if ((unsigned int )xxx_kex != (unsigned int )((void *)0)) {
#line 715
      if (! xxx_kex->done) {
#line 715
        tmp = 1;
      } else {
#line 715
        tmp = 0;
      }
    } else {
#line 715
      tmp = 0;
    }
#line 715
    rekeying = tmp;
#line 717
    if (! rekeying) {
#line 717
      tmp___0 = packet_not_very_much_data_to_write();
#line 717
      if (tmp___0) {
#line 718
        channel_output_poll();
      }
    }
#line 719
    wait_until_can_do_something(& readset, & writeset, & max_fd, (unsigned int )rekeying);
#line 721
    if (child_terminated) {
#line 722
      while (1) {
#line 722
        pid = waitpid(-1, & status, 1);
#line 722
        if (! (pid > 0)) {
#line 722
          break;
        }
#line 723
        session_close_by_pid(pid, status);
      }
#line 724
      child_terminated = (int volatile   )0;
    }
#line 726
    if (! rekeying) {
#line 727
      channel_after_select(readset, writeset);
    }
#line 728
    process_input(readset);
#line 729
    if (connection_closed) {
#line 730
      break;
    }
#line 731
    process_output(writeset);
  }
#line 733
  if (readset) {
#line 734
    xfree((void *)readset);
  }
#line 735
  if (writeset) {
#line 736
    xfree((void *)writeset);
  }
#line 738
  signal(17, (void (*)(int  ))0);
#line 739
  while (1) {
#line 739
    pid = waitpid(-1, & status, 1);
#line 739
    if (! (pid > 0)) {
#line 739
      break;
    }
#line 740
    session_close_by_pid(pid, status);
  }
#line 741
  channel_stop_listening();
#line 742
  return;
}
}
#line 744 "serverloop.c"
void server_input_channel_failure(int type , int plen , void *ctxt ) 
{ 

  {
#line 747
  debug("Got CHANNEL_FAILURE for keepalive");
#line 753
  client_alive_timeouts = 0;
#line 754
  return;
}
}
#line 757 "serverloop.c"
void server_input_stdin_data(int type , int plen , void *ctxt ) 
{ char *data ;
  u_int data_len ;
  int _p ;
  int _e ;

  {
#line 765
  if (fdin == -1) {
#line 766
    return;
  }
#line 767
  data = packet_get_string(& data_len);
#line 768
  while (1) {
#line 768
    _p = plen;
#line 768
    _e = (int )(4U + data_len);
#line 768
    if (_p != _e) {
#line 768
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "serverloop.c", 768);
#line 768
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 768
    break;
  }
#line 769
  buffer_append(& stdin_buffer, (char const   *)data, data_len);
#line 770
  memset((void *)data, 0, data_len);
#line 771
  xfree((void *)data);
#line 772
  return;
}
}
#line 774 "serverloop.c"
void server_input_eof(int type , int plen , void *ctxt ) 
{ int _p ;
  int _e ;

  {
#line 782
  debug("EOF received for stdin.");
#line 783
  while (1) {
#line 783
    _p = plen;
#line 783
    _e = 0;
#line 783
    if (_p != _e) {
#line 783
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "serverloop.c", 783);
#line 783
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 783
    break;
  }
#line 784
  stdin_eof = 1;
#line 785
  return;
}
}
#line 787 "serverloop.c"
void server_input_window_size(int type , int plen , void *ctxt ) 
{ int row ;
  u_int tmp ;
  int col ;
  u_int tmp___0 ;
  int xpixel ;
  u_int tmp___1 ;
  int ypixel ;
  u_int tmp___2 ;
  int _p ;
  int _e ;

  {
#line 790
  tmp = packet_get_int();
#line 790
  row = (int )tmp;
#line 791
  tmp___0 = packet_get_int();
#line 791
  col = (int )tmp___0;
#line 792
  tmp___1 = packet_get_int();
#line 792
  xpixel = (int )tmp___1;
#line 793
  tmp___2 = packet_get_int();
#line 793
  ypixel = (int )tmp___2;
#line 795
  debug("Window change received.");
#line 796
  while (1) {
#line 796
    _p = plen;
#line 796
    _e = 16;
#line 796
    if (_p != _e) {
#line 796
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "serverloop.c", 796);
#line 796
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 796
    break;
  }
#line 797
  if (fdin != -1) {
#line 798
    pty_change_window_size(fdin, row, col, xpixel, ypixel);
  }
#line 799
  return;
}
}
#line 801 "serverloop.c"
Channel *server_request_direct_tcpip(char *ctype ) 
{ int sock ;
  int newch ;
  char *target ;
  char *originator ;
  int target_port ;
  int originator_port ;
  u_int tmp ;
  u_int tmp___0 ;
  int _len ;
  int tmp___1 ;
  char *tmp___2 ;
  Channel *tmp___4 ;

  {
#line 808
  target = packet_get_string((u_int *)((void *)0));
#line 809
  tmp = packet_get_int();
#line 809
  target_port = (int )tmp;
#line 810
  originator = packet_get_string((u_int *)((void *)0));
#line 811
  tmp___0 = packet_get_int();
#line 811
  originator_port = (int )tmp___0;
#line 812
  while (1) {
#line 812
    tmp___1 = packet_remaining();
#line 812
    _len = tmp___1;
#line 812
    if (_len > 0) {
#line 812
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
          812);
#line 812
      packet_disconnect("Packet integrity error.");
    }
#line 812
    break;
  }
#line 814
  debug("server_request_direct_tcpip: originator %s port %d, target %s port %d", originator,
        originator_port, target, target_port);
#line 818
  sock = channel_connect_to((char const   *)target, (unsigned short )target_port);
#line 819
  xfree((void *)target);
#line 820
  xfree((void *)originator);
#line 821
  if (sock < 0) {
#line 822
    return ((Channel *)((void *)0));
  }
#line 823
  tmp___2 = xstrdup("direct-tcpip");
#line 823
  newch = channel_new(ctype, 12, sock, sock, -1, 32768, 16384, 0, tmp___2, 1);
#line 826
  if (newch >= 0) {
#line 826
    tmp___4 = channel_lookup(newch);
  } else {
#line 826
    tmp___4 = (Channel *)((void *)0);
  }
#line 826
  return (tmp___4);
}
}
#line 829 "serverloop.c"
Channel *server_request_session(char *ctype ) 
{ int newch ;
  int _len ;
  int tmp ;
  char *tmp___0 ;
  Channel *tmp___1 ;
  int tmp___2 ;

  {
#line 834
  debug("input_session_request");
#line 835
  while (1) {
#line 835
    tmp = packet_remaining();
#line 835
    _len = tmp;
#line 835
    if (_len > 0) {
#line 835
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
          835);
#line 835
      packet_disconnect("Packet integrity error.");
    }
#line 835
    break;
  }
#line 842
  tmp___0 = xstrdup("server-session");
#line 842
  newch = channel_new(ctype, 10, -1, -1, -1, 0, 16384, 0, tmp___0, 1);
#line 845
  tmp___2 = session_open(newch);
#line 845
  if (tmp___2 == 1) {
#line 846
    channel_register_callback(newch, 98, & session_input_channel_req, (void *)0);
#line 848
    channel_register_cleanup(newch, & session_close_by_channel);
#line 849
    tmp___1 = channel_lookup(newch);
#line 849
    return (tmp___1);
  } else {
#line 851
    debug("session open failed, free channel %d", newch);
#line 852
    channel_free(newch);
  }
#line 854
  return ((Channel *)((void *)0));
}
}
#line 857 "serverloop.c"
void server_input_channel_open(int type , int plen , void *ctxt ) 
{ Channel *c ;
  char *ctype ;
  u_int len ;
  int rchan ;
  int rmaxpack ;
  int rwindow ;
  u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___17 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 860
  c = (Channel *)((void *)0);
#line 867
  ctype = packet_get_string(& len);
#line 868
  tmp = packet_get_int();
#line 868
  rchan = (int )tmp;
#line 869
  tmp___0 = packet_get_int();
#line 869
  rwindow = (int )tmp___0;
#line 870
  tmp___1 = packet_get_int();
#line 870
  rmaxpack = (int )tmp___1;
#line 872
  debug("server_input_channel_open: ctype %s rchan %d win %d max %d", ctype, rchan,
        rwindow, rmaxpack);
#line 875
  if (0) {
#line 875
    __s1_len___0 = strlen((char const   *)ctype);
#line 875
    __s2_len___0 = strlen("session");
#line 875
    if (! ((unsigned int )((void const   *)(ctype + 1)) - (unsigned int )((void const   *)ctype) == 1U)) {
      goto _L___2;
    } else {
#line 875
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 875
        if (! ((unsigned int )((void const   *)("session" + 1)) - (unsigned int )((void const   *)"session") == 1U)) {
#line 875
          tmp___21 = 1;
        } else {
#line 875
          if (__s2_len___0 >= 4U) {
#line 875
            tmp___21 = 1;
          } else {
#line 875
            tmp___21 = 0;
          }
        }
      } else {
#line 875
        tmp___21 = 0;
      }
    }
#line 875
    if (tmp___21) {
#line 875
      tmp___17 = __builtin_strcmp((char const   *)ctype, "session");
    } else {
#line 875
      tmp___20 = __builtin_strcmp((char const   *)ctype, "session");
#line 875
      tmp___17 = tmp___20;
    }
  } else {
#line 875
    tmp___20 = __builtin_strcmp((char const   *)ctype, "session");
#line 875
    tmp___17 = tmp___20;
  }
#line 875
  if (tmp___17 == 0) {
#line 876
    c = server_request_session(ctype);
  } else {
#line 877
    if (0) {
#line 877
      __s1_len = strlen((char const   *)ctype);
#line 877
      __s2_len = strlen("direct-tcpip");
#line 877
      if (! ((unsigned int )((void const   *)(ctype + 1)) - (unsigned int )((void const   *)ctype) == 1U)) {
        goto _L___0;
      } else {
#line 877
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 877
          if (! ((unsigned int )((void const   *)("direct-tcpip" + 1)) - (unsigned int )((void const   *)"direct-tcpip") == 1U)) {
#line 877
            tmp___11 = 1;
          } else {
#line 877
            if (__s2_len >= 4U) {
#line 877
              tmp___11 = 1;
            } else {
#line 877
              tmp___11 = 0;
            }
          }
        } else {
#line 877
          tmp___11 = 0;
        }
      }
#line 877
      if (tmp___11) {
#line 877
        tmp___7 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
      } else {
#line 877
        tmp___10 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
#line 877
        tmp___7 = tmp___10;
      }
    } else {
#line 877
      tmp___10 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
#line 877
      tmp___7 = tmp___10;
    }
#line 877
    if (tmp___7 == 0) {
#line 878
      c = server_request_direct_tcpip(ctype);
    }
  }
#line 880
  if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 881
    debug("server_input_channel_open: confirm %s", ctype);
#line 882
    c->remote_id = rchan;
#line 883
    c->remote_window = rwindow;
#line 884
    c->remote_maxpacket = rmaxpack;
#line 886
    packet_start(91);
#line 887
    packet_put_int((unsigned int )c->remote_id);
#line 888
    packet_put_int((unsigned int )c->self);
#line 889
    packet_put_int((unsigned int )c->local_window);
#line 890
    packet_put_int((unsigned int )c->local_maxpacket);
#line 891
    packet_send();
  } else {
#line 893
    debug("server_input_channel_open: failure %s", ctype);
#line 894
    packet_start(92);
#line 895
    packet_put_int((unsigned int )rchan);
#line 896
    packet_put_int(1U);
#line 897
    packet_put_cstring("bla bla");
#line 898
    packet_put_cstring("");
#line 899
    packet_send();
  }
#line 901
  xfree((void *)ctype);
#line 902
  return;
}
}
#line 904 "serverloop.c"
void server_input_global_request(int type , int plen , void *ctxt ) 
{ char *rtype ;
  int want_reply ;
  int success ;
  u_int tmp ;
  struct passwd *pw ;
  char *listen_address ;
  u_short listen_port ;
  u_int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 909
  success = 0;
#line 911
  rtype = packet_get_string((u_int *)((void *)0));
#line 912
  tmp = packet_get_char();
#line 912
  want_reply = (int )tmp;
#line 913
  debug("server_input_global_request: rtype %s want_reply %d", rtype, want_reply);
#line 916
  if (0) {
#line 916
    __s1_len = strlen((char const   *)rtype);
#line 916
    __s2_len = strlen("tcpip-forward");
#line 916
    if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
      goto _L___0;
    } else {
#line 916
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 916
        if (! ((unsigned int )((void const   *)("tcpip-forward" + 1)) - (unsigned int )((void const   *)"tcpip-forward") == 1U)) {
#line 916
          tmp___10 = 1;
        } else {
#line 916
          if (__s2_len >= 4U) {
#line 916
            tmp___10 = 1;
          } else {
#line 916
            tmp___10 = 0;
          }
        }
      } else {
#line 916
        tmp___10 = 0;
      }
    }
#line 916
    if (tmp___10) {
#line 916
      tmp___6 = __builtin_strcmp((char const   *)rtype, "tcpip-forward");
    } else {
#line 916
      tmp___9 = __builtin_strcmp((char const   *)rtype, "tcpip-forward");
#line 916
      tmp___6 = tmp___9;
    }
  } else {
#line 916
    tmp___9 = __builtin_strcmp((char const   *)rtype, "tcpip-forward");
#line 916
    tmp___6 = tmp___9;
  }
#line 916
  if (tmp___6 == 0) {
#line 921
    pw = auth_get_user();
#line 922
    if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 923
      fatal("server_input_global_request: no user");
    }
#line 924
    listen_address = packet_get_string((u_int *)((void *)0));
#line 925
    tmp___0 = packet_get_int();
#line 925
    listen_port = (unsigned short )tmp___0;
#line 926
    debug("server_input_global_request: tcpip-forward listen %s port %d", listen_address,
          listen_port);
#line 930
    if (! options.allow_tcp_forwarding) {
#line 933
      success = 0;
#line 934
      packet_send_debug("Server has disabled port forwarding.");
    } else {
#line 930
      if (no_port_forwarding_flag) {
#line 933
        success = 0;
#line 934
        packet_send_debug("Server has disabled port forwarding.");
      } else {
#line 930
        if ((int )listen_port < 1024) {
#line 930
          if (pw->pw_uid != 0U) {
#line 933
            success = 0;
#line 934
            packet_send_debug("Server has disabled port forwarding.");
          } else {
#line 937
            success = channel_request_forwarding((char const   *)listen_address, listen_port,
                                                 "<unspec host>", (unsigned short)0,
                                                 options.gateway_ports, 1);
          }
        } else {
#line 937
          success = channel_request_forwarding((char const   *)listen_address, listen_port,
                                               "<unspec host>", (unsigned short)0,
                                               options.gateway_ports, 1);
        }
      }
    }
#line 943
    xfree((void *)listen_address);
  }
#line 945
  if (want_reply) {
#line 946
    if (success) {
#line 946
      tmp___11 = 81;
    } else {
#line 946
      tmp___11 = 82;
    }
#line 946
    packet_start(tmp___11);
#line 948
    packet_send();
#line 949
    packet_write_wait();
  }
#line 951
  xfree((void *)rtype);
#line 952
  return;
}
}
#line 954 "serverloop.c"
void server_init_dispatch_20(void) 
{ 

  {
#line 957
  debug("server_init_dispatch_20");
#line 958
  dispatch_init(& dispatch_protocol_error);
#line 959
  dispatch_set(97, & channel_input_oclose);
#line 960
  dispatch_set(94, & channel_input_data);
#line 961
  dispatch_set(96, & channel_input_ieof);
#line 962
  dispatch_set(95, & channel_input_extended_data);
#line 963
  dispatch_set(90, & server_input_channel_open);
#line 964
  dispatch_set(91, & channel_input_open_confirmation);
#line 965
  dispatch_set(92, & channel_input_open_failure);
#line 966
  dispatch_set(98, & channel_input_channel_request);
#line 967
  dispatch_set(93, & channel_input_window_adjust);
#line 968
  dispatch_set(80, & server_input_global_request);
#line 970
  dispatch_set(100, & server_input_channel_failure);
#line 972
  dispatch_set(20, & kex_input_kexinit);
#line 973
  return;
}
}
#line 974 "serverloop.c"
void server_init_dispatch_13(void) 
{ 

  {
#line 977
  debug("server_init_dispatch_13");
#line 978
  dispatch_init((dispatch_fn *)((void *)0));
#line 979
  dispatch_set(19, & server_input_eof);
#line 980
  dispatch_set(16, & server_input_stdin_data);
#line 981
  dispatch_set(11, & server_input_window_size);
#line 982
  dispatch_set(24, & channel_input_close);
#line 983
  dispatch_set(25, & channel_input_close_confirmation);
#line 984
  dispatch_set(23, & channel_input_data);
#line 985
  dispatch_set(21, & channel_input_open_confirmation);
#line 986
  dispatch_set(22, & channel_input_open_failure);
#line 987
  dispatch_set(29, & channel_input_port_open);
#line 988
  return;
}
}
#line 989 "serverloop.c"
void server_init_dispatch_15(void) 
{ 

  {
#line 992
  server_init_dispatch_13();
#line 993
  debug("server_init_dispatch_15");
#line 994
  dispatch_set(24, & channel_input_ieof);
#line 995
  dispatch_set(25, & channel_input_oclose);
#line 996
  return;
}
}
#line 997 "serverloop.c"
void server_init_dispatch(void) 
{ 

  {
#line 1000
  if (compat20) {
#line 1001
    server_init_dispatch_20();
  } else {
#line 1002
    if (compat13) {
#line 1003
      server_init_dispatch_13();
    } else {
#line 1005
      server_init_dispatch_15();
    }
  }
#line 1006
  return;
}
}
#line 1 "md5crypt.o"
#pragma merger(0,"./md5crypt.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "session.o"
#pragma merger(0,"./session.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 106 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socketpair(int __domain , int __type , int __protocol ,
                                                    int *__fds ) ;
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 504 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int execve(char const   *__path , char * const  *__argv ,
                                                char * const  *__envp )  __attribute__((__nonnull__(1))) ;
#line 526
extern  __attribute__((__nothrow__)) int execl(char const   *__path , char const   *__arg 
                                               , ...)  __attribute__((__nonnull__(1))) ;
#line 142 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 333
extern int printf(char const   * __restrict  __format  , ...) ;
#line 590
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 774
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 780
extern int pclose(FILE *__stream ) ;
#line 79 "/usr/include/pwd.h"
extern void endpwent(void) ;
#line 69 "/usr/include/grp.h"
extern void endgrent(void) ;
#line 257 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 123 "session.c"
Session *session_new(void) ;
#line 124
void session_set_fds(Session *s , int fdin___0 , int fdout___0 , int fderr___0 ) ;
#line 125
void session_pty_cleanup(Session *s ) ;
#line 126
void session_proctitle(Session *s ) ;
#line 127
void do_exec_pty(Session *s , char const   *command ) ;
#line 128
void do_exec_no_pty(Session *s , char const   *command ) ;
#line 129
void do_login(Session *s , char const   *command ) ;
#line 130
void do_child(Session *s , char const   *command ) ;
#line 131
void do_motd(void) ;
#line 132
int check_quietlogin(Session *s , char const   *command ) ;
#line 134
void do_authenticated1(Authctxt *authctxt ) ;
#line 135
void do_authenticated2(Authctxt *authctxt ) ;
#line 147 "session.c"
static char *xauthfile  ;
#line 150 "session.c"
char *original_command  =    (char *)((void *)0);
#line 154 "session.c"
Session sessions[10]  ;
#line 165 "session.c"
void do_authenticated(Authctxt *authctxt ) 
{ 

  {
#line 172
  alarm(0U);
#line 173
  if (startup_pipe != -1) {
#line 174
    close(startup_pipe);
#line 175
    startup_pipe = -1;
  }
#line 190
  if (! no_port_forwarding_flag) {
#line 190
    if (options.allow_tcp_forwarding) {
#line 191
      channel_permit_all_opens();
    }
  }
#line 193
  if (compat20) {
#line 194
    do_authenticated2(authctxt);
  } else {
#line 196
    do_authenticated1(authctxt);
  }
#line 197
  return;
}
}
#line 202 "session.c"
void xauthfile_cleanup_proc(void *ignore ) 
{ char *p ;

  {
#line 205
  debug("xauthfile_cleanup_proc called");
#line 207
  if ((unsigned int )xauthfile != (unsigned int )((void *)0)) {
#line 209
    unlink((char const   *)xauthfile);
#line 210
    p = strrchr((char const   *)xauthfile, '/');
#line 211
    if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 212
      *p = (char )'\000';
#line 213
      rmdir((char const   *)xauthfile);
    }
#line 215
    xfree((void *)xauthfile);
#line 216
    xauthfile = (char *)((void *)0);
  }
#line 218
  return;
}
}
#line 224 "session.c"
void pty_cleanup_proc(void *session ) 
{ Session *s ;

  {
#line 227
  s = (Session *)session;
#line 228
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 229
    fatal("pty_cleanup_proc: no session");
  }
#line 230
  debug("pty_cleanup_proc: %s", s->tty);
#line 232
  if (s->pid != 0) {
#line 234
    record_logout(s->pid, (char const   *)(s->tty));
  }
#line 238
  pty_release((char const   *)(s->tty));
#line 239
  return;
}
}
#line 247 "session.c"
void do_authenticated1(Authctxt *authctxt ) 
{ Session *s ;
  char *command ;
  int success ;
  int type ;
  int fd ;
  int n_bytes ;
  int plen ;
  int screen_flag ;
  int have_pty ;
  int compression_level ;
  int enable_compression_after_reply ;
  u_int proto_len ;
  u_int data_len ;
  u_int dlen ;
  int _p ;
  int _e ;
  u_int tmp ;
  int tmp___0 ;
  int _p___0 ;
  int _e___0 ;
  size_t tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  u_int tmp___12 ;
  u_int tmp___13 ;
  u_int tmp___14 ;
  u_int tmp___15 ;
  int _p___1 ;
  int _e___1 ;
  u_int tmp___16 ;
  int _p___2 ;
  int _e___2 ;
  u_int tmp___17 ;
  int _p___3 ;
  int _e___3 ;
  int tmp___18 ;
  void *tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  u_int tmp___23 ;
  int tmp___24 ;
  int _p___4 ;
  int _e___4 ;
  int _p___5 ;
  int _e___5 ;
  int tmp___25 ;

  {
#line 252
  have_pty = 0;
#line 253
  compression_level = 0;
#line 253
  enable_compression_after_reply = 0;
#line 256
  s = session_new();
#line 257
  s->pw = authctxt->pw;
#line 263
  while (1) {
#line 264
    success = 0;
#line 267
    type = packet_read(& plen);
#line 270
    switch (type) {
    case 37: 
#line 272
    while (1) {
#line 272
      _p = plen;
#line 272
      _e = 4;
#line 272
      if (_p != _e) {
#line 272
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "session.c", 272);
#line 272
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 272
      break;
    }
#line 273
    tmp = packet_get_int();
#line 273
    compression_level = (int )tmp;
#line 274
    if (compression_level < 1) {
#line 275
      packet_send_debug("Received illegal compression level %d.", compression_level);
#line 277
      break;
    } else {
#line 274
      if (compression_level > 9) {
#line 275
        packet_send_debug("Received illegal compression level %d.", compression_level);
#line 277
        break;
      }
    }
#line 280
    enable_compression_after_reply = 1;
#line 281
    success = 1;
#line 282
    break;
    case 10: 
#line 285
    if (no_pty_flag) {
#line 286
      debug("Allocating a pty not permitted for this authentication.");
#line 287
      break;
    }
#line 289
    if (have_pty) {
#line 290
      packet_disconnect("Protocol error: you already have a pty.");
    }
#line 292
    debug("Allocating pty.");
#line 295
    tmp___0 = pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, (int )sizeof(s->tty));
#line 295
    if (! tmp___0) {
#line 297
      error("Failed to allocate pty.");
#line 298
      break;
    }
#line 300
    fatal_add_cleanup(& pty_cleanup_proc, (void *)s);
#line 301
    pty_setowner(s->pw, (char const   *)(s->tty));
#line 304
    s->term = packet_get_string(& dlen);
#line 305
    while (1) {
#line 305
      _p___0 = (int )dlen;
#line 305
      tmp___1 = strlen((char const   *)s->term);
#line 305
      _e___0 = (int )tmp___1;
#line 305
      if (_p___0 != _e___0) {
#line 305
        log("Packet integrity error (%d != %d) at %s:%d", _p___0, _e___0, "session.c",
            305);
#line 305
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 305
      break;
    }
#line 308
    n_bytes = (int )((u_int )plen - ((4U + dlen) + 16U));
#line 310
    if (0) {
#line 310
      __s1_len = strlen((char const   *)s->term);
#line 310
      __s2_len = strlen("");
#line 310
      if (! ((unsigned int )((void const   *)(s->term + 1)) - (unsigned int )((void const   *)s->term) == 1U)) {
        goto _L___0;
      } else {
#line 310
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 310
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 310
            tmp___11 = 1;
          } else {
#line 310
            if (__s2_len >= 4U) {
#line 310
              tmp___11 = 1;
            } else {
#line 310
              tmp___11 = 0;
            }
          }
        } else {
#line 310
          tmp___11 = 0;
        }
      }
#line 310
      if (tmp___11) {
#line 310
        tmp___7 = __builtin_strcmp((char const   *)s->term, "");
      } else {
#line 310
        tmp___10 = __builtin_strcmp((char const   *)s->term, "");
#line 310
        tmp___7 = tmp___10;
      }
    } else {
#line 310
      tmp___10 = __builtin_strcmp((char const   *)s->term, "");
#line 310
      tmp___7 = tmp___10;
    }
#line 310
    if (tmp___7 == 0) {
#line 311
      xfree((void *)s->term);
#line 312
      s->term = (char *)((void *)0);
    }
#line 315
    tmp___12 = packet_get_int();
#line 315
    s->row = (int )tmp___12;
#line 316
    tmp___13 = packet_get_int();
#line 316
    s->col = (int )tmp___13;
#line 317
    tmp___14 = packet_get_int();
#line 317
    s->xpixel = (int )tmp___14;
#line 318
    tmp___15 = packet_get_int();
#line 318
    s->ypixel = (int )tmp___15;
#line 319
    pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);
#line 322
    tty_parse_modes(s->ttyfd, & n_bytes);
#line 323
    while (1) {
#line 323
      _p___1 = plen;
#line 323
      _e___1 = (int )(((4U + dlen) + 16U) + (u_int )n_bytes);
#line 323
      if (_p___1 != _e___1) {
#line 323
        log("Packet integrity error (%d != %d) at %s:%d", _p___1, _e___1, "session.c",
            323);
#line 323
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 323
      break;
    }
#line 325
    session_proctitle(s);
#line 328
    success = 1;
#line 329
    have_pty = 1;
#line 330
    break;
    case 34: 
#line 333
    if (! options.x11_forwarding) {
#line 334
      packet_send_debug("X11 forwarding disabled in server configuration file.");
#line 335
      break;
    }
#line 337
    if (! options.xauth_location) {
#line 338
      packet_send_debug("No xauth program; cannot forward with spoofing.");
#line 339
      break;
    }
#line 341
    if (no_x11_forwarding_flag) {
#line 342
      packet_send_debug("X11 forwarding not permitted for this authentication.");
#line 343
      break;
    }
#line 345
    debug("Received request for X11 forwarding with auth spoofing.");
#line 346
    if ((unsigned int )s->display != (unsigned int )((void *)0)) {
#line 347
      packet_disconnect("Protocol error: X11 display already set.");
    }
#line 349
    s->auth_proto = packet_get_string(& proto_len);
#line 350
    s->auth_data = packet_get_string(& data_len);
#line 352
    tmp___16 = packet_get_protocol_flags();
#line 352
    screen_flag = (int )(tmp___16 & 1U);
#line 354
    debug2("SSH_PROTOFLAG_SCREEN_NUMBER: %d", screen_flag);
#line 356
    tmp___18 = packet_remaining();
#line 356
    if (tmp___18 == 4) {
#line 357
      if (! screen_flag) {
#line 358
        debug2("Buggy client: X11 screen flag missing");
      }
#line 360
      while (1) {
#line 360
        _p___2 = plen;
#line 360
        _e___2 = (int )((((4U + proto_len) + 4U) + data_len) + 4U);
#line 360
        if (_p___2 != _e___2) {
#line 360
          log("Packet integrity error (%d != %d) at %s:%d", _p___2, _e___2, "session.c",
              361);
#line 360
          packet_disconnect("Packet integrity error. (%d)", type);
        }
#line 360
        break;
      }
#line 362
      tmp___17 = packet_get_int();
#line 362
      s->screen = (int )tmp___17;
    } else {
#line 364
      while (1) {
#line 364
        _p___3 = plen;
#line 364
        _e___3 = (int )(((4U + proto_len) + 4U) + data_len);
#line 364
        if (_p___3 != _e___3) {
#line 364
          log("Packet integrity error (%d != %d) at %s:%d", _p___3, _e___3, "session.c",
              365);
#line 364
          packet_disconnect("Packet integrity error. (%d)", type);
        }
#line 364
        break;
      }
#line 366
      s->screen = 0;
    }
#line 368
    s->display = x11_create_display_inet(s->screen, options.x11_display_offset);
#line 370
    if ((unsigned int )s->display == (unsigned int )((void *)0)) {
#line 371
      break;
    }
#line 374
    tmp___19 = xmalloc(4096U);
#line 374
    xauthfile = (char *)tmp___19;
#line 375
    strlcpy(xauthfile, "/tmp/ssh-XXXXXXXX", 4096U);
#line 376
    temporarily_use_uid(s->pw);
#line 377
    tmp___22 = mkdtemp(xauthfile);
#line 377
    if ((unsigned int )tmp___22 == (unsigned int )((void *)0)) {
#line 378
      restore_uid();
#line 379
      tmp___20 = __errno_location();
#line 379
      tmp___21 = strerror(*tmp___20);
#line 379
      error("private X11 dir: mkdtemp %s failed: %s", xauthfile, tmp___21);
#line 381
      xfree((void *)xauthfile);
#line 382
      xauthfile = (char *)((void *)0);
#line 384
      break;
    }
#line 386
    strlcat(xauthfile, "/cookies", 4096U);
#line 387
    fd = open((char const   *)xauthfile, 194, 384);
#line 388
    if (fd >= 0) {
#line 389
      close(fd);
    }
#line 390
    restore_uid();
#line 391
    fatal_add_cleanup(& xauthfile_cleanup_proc, (void *)0);
#line 392
    success = 1;
#line 393
    break;
    case 30: 
#line 396
    if (no_agent_forwarding_flag) {
#line 397
      debug("Authentication agent forwarding not permitted for this authentication.");
#line 398
      break;
    } else {
#line 396
      if (compat13) {
#line 397
        debug("Authentication agent forwarding not permitted for this authentication.");
#line 398
        break;
      }
    }
#line 400
    debug("Received authentication agent forwarding request.");
#line 401
    success = auth_input_request_forwarding(s->pw);
#line 402
    break;
    case 28: 
#line 405
    if (no_port_forwarding_flag) {
#line 406
      debug("Port forwarding not permitted for this authentication.");
#line 407
      break;
    }
#line 409
    if (! options.allow_tcp_forwarding) {
#line 410
      debug("Port forwarding not permitted.");
#line 411
      break;
    }
#line 413
    debug("Received TCP/IP port forwarding request.");
#line 414
    channel_input_port_forward_request((s->pw)->pw_uid == 0U, options.gateway_ports);
#line 415
    success = 1;
#line 416
    break;
    case 38: 
#line 419
    tmp___23 = packet_get_int();
#line 419
    tmp___24 = packet_set_maxsize((int )tmp___23);
#line 419
    if (tmp___24 > 0) {
#line 420
      success = 1;
    }
#line 421
    break;
    case 12: 
    case 13: 
#line 425
    if (type == 13) {
#line 426
      command = packet_get_string(& dlen);
#line 427
      debug("Exec command \'%.500s\'", command);
#line 428
      while (1) {
#line 428
        _p___4 = plen;
#line 428
        _e___4 = (int )(4U + dlen);
#line 428
        if (_p___4 != _e___4) {
#line 428
          log("Packet integrity error (%d != %d) at %s:%d", _p___4, _e___4, "session.c",
              428);
#line 428
          packet_disconnect("Packet integrity error. (%d)", type);
        }
#line 428
        break;
      }
    } else {
#line 430
      command = (char *)((void *)0);
#line 431
      while (1) {
#line 431
        _p___5 = plen;
#line 431
        _e___5 = 0;
#line 431
        if (_p___5 != _e___5) {
#line 431
          log("Packet integrity error (%d != %d) at %s:%d", _p___5, _e___5, "session.c",
              431);
#line 431
          packet_disconnect("Packet integrity error. (%d)", type);
        }
#line 431
        break;
      }
    }
#line 433
    if ((unsigned int )forced_command != (unsigned int )((void *)0)) {
#line 434
      original_command = command;
#line 435
      command = forced_command;
#line 436
      debug("Forced command \'%.500s\'", forced_command);
    }
#line 438
    if (have_pty) {
#line 439
      do_exec_pty(s, (char const   *)command);
    } else {
#line 441
      do_exec_no_pty(s, (char const   *)command);
    }
#line 443
    if ((unsigned int )command != (unsigned int )((void *)0)) {
#line 444
      xfree((void *)command);
    }
#line 446
    if (xauthfile) {
#line 447
      xauthfile_cleanup_proc((void *)0);
    }
#line 448
    return;
    default: 
#line 455
    log("Unknown packet type received after authentication: %d", type);
    }
#line 457
    if (success) {
#line 457
      tmp___25 = 14;
    } else {
#line 457
      tmp___25 = 15;
    }
#line 457
    packet_start(tmp___25);
#line 458
    packet_send();
#line 459
    packet_write_wait();
#line 462
    if (enable_compression_after_reply) {
#line 463
      enable_compression_after_reply = 0;
#line 464
      packet_start_compression(compression_level);
    }
  }
}
}
#line 474 "session.c"
void do_exec_no_pty(Session *s , char const   *command ) 
{ int pid ;
  int inout[2] ;
  int err[2] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  __pid_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
#line 488
  tmp___1 = socketpair(1, 1, 0, (int *)(inout));
#line 488
  if (tmp___1 < 0) {
#line 490
    tmp = __errno_location();
#line 490
    tmp___0 = strerror(*tmp);
#line 490
    packet_disconnect("Could not create socket pairs: %.100s", tmp___0);
  } else {
#line 488
    tmp___2 = socketpair(1, 1, 0, (int *)(err));
#line 488
    if (tmp___2 < 0) {
#line 490
      tmp = __errno_location();
#line 490
      tmp___0 = strerror(*tmp);
#line 490
      packet_disconnect("Could not create socket pairs: %.100s", tmp___0);
    }
  }
#line 493
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 494
    fatal("do_exec_no_pty: no session");
  }
#line 496
  session_proctitle(s);
#line 503
  pid = fork();
#line 503
  if (pid == 0) {
#line 505
    log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 511
    tmp___5 = setsid();
#line 511
    if (tmp___5 < 0) {
#line 512
      tmp___3 = __errno_location();
#line 512
      tmp___4 = strerror(*tmp___3);
#line 512
      error("setsid failed: %.100s", tmp___4);
    }
#line 541
    close(inout[1]);
#line 542
    close(err[1]);
#line 543
    tmp___6 = dup2(inout[0], 0);
#line 543
    if (tmp___6 < 0) {
#line 544
      perror("dup2 stdin");
    }
#line 545
    tmp___7 = dup2(inout[0], 1);
#line 545
    if (tmp___7 < 0) {
#line 546
      perror("dup2 stdout");
    }
#line 547
    tmp___8 = dup2(err[0], 2);
#line 547
    if (tmp___8 < 0) {
#line 548
      perror("dup2 stderr");
    }
#line 552
    do_child(s, command);
  }
#line 559
  if (pid < 0) {
#line 560
    tmp___9 = __errno_location();
#line 560
    tmp___10 = strerror(*tmp___9);
#line 560
    packet_disconnect("fork failed: %.100s", tmp___10);
  }
#line 561
  s->pid = pid;
#line 563
  packet_set_interactive((unsigned int )s->display != (unsigned int )((void *)0));
#line 579
  close(inout[0]);
#line 580
  close(err[0]);
#line 586
  if (compat20) {
#line 587
    if (s->is_subsystem) {
#line 587
      tmp___11 = -1;
    } else {
#line 587
      tmp___11 = err[1];
    }
#line 587
    session_set_fds(s, inout[1], inout[1], tmp___11);
  } else {
#line 589
    server_loop(pid, inout[1], inout[1], err[1]);
  }
#line 593
  return;
}
}
#line 601 "session.c"
void do_exec_pty(Session *s , char const   *command ) 
{ int fdout___0 ;
  int ptyfd ;
  int ttyfd ;
  int ptymaster ;
  pid_t pid ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;

  {
#line 607
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 608
    fatal("do_exec_pty: no session");
  }
#line 609
  ptyfd = s->ptyfd;
#line 610
  ttyfd = s->ttyfd;
#line 618
  pid = fork();
#line 618
  if (pid == 0) {
#line 620
    log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 623
    close(ptyfd);
#line 626
    pty_make_controlling_tty(& ttyfd, (char const   *)(s->tty));
#line 629
    tmp___1 = fileno(stdin);
#line 629
    tmp___2 = dup2(ttyfd, tmp___1);
#line 629
    if (tmp___2 < 0) {
#line 630
      tmp = __errno_location();
#line 630
      tmp___0 = strerror(*tmp);
#line 630
      error("dup2 stdin failed: %.100s", tmp___0);
    }
#line 633
    tmp___5 = fileno(stdout);
#line 633
    tmp___6 = dup2(ttyfd, tmp___5);
#line 633
    if (tmp___6 < 0) {
#line 634
      tmp___3 = __errno_location();
#line 634
      tmp___4 = strerror(*tmp___3);
#line 634
      error("dup2 stdin failed: %.100s", tmp___4);
    }
#line 637
    tmp___9 = fileno(stderr);
#line 637
    tmp___10 = dup2(ttyfd, tmp___9);
#line 637
    if (tmp___10 < 0) {
#line 638
      tmp___7 = __errno_location();
#line 638
      tmp___8 = strerror(*tmp___7);
#line 638
      error("dup2 stdin failed: %.100s", tmp___8);
    }
#line 641
    close(ttyfd);
#line 645
    if (options.use_login) {
#line 645
      if (! ((unsigned int )command == (unsigned int )((void *)0))) {
#line 646
        do_login(s, command);
      }
    } else {
#line 646
      do_login(s, command);
    }
#line 650
    do_child(s, command);
  }
#line 657
  if (pid < 0) {
#line 658
    tmp___11 = __errno_location();
#line 658
    tmp___12 = strerror(*tmp___11);
#line 658
    packet_disconnect("fork failed: %.100s", tmp___12);
  }
#line 659
  s->pid = pid;
#line 662
  close(ttyfd);
#line 669
  fdout___0 = dup(ptyfd);
#line 670
  if (fdout___0 < 0) {
#line 671
    tmp___13 = __errno_location();
#line 671
    tmp___14 = strerror(*tmp___13);
#line 671
    packet_disconnect("dup #1 failed: %.100s", tmp___14);
  }
#line 674
  ptymaster = dup(ptyfd);
#line 675
  if (ptymaster < 0) {
#line 676
    tmp___15 = __errno_location();
#line 676
    tmp___16 = strerror(*tmp___15);
#line 676
    packet_disconnect("dup #2 failed: %.100s", tmp___16);
  }
#line 677
  s->ptymaster = ptymaster;
#line 680
  packet_set_interactive(1);
#line 681
  if (compat20) {
#line 682
    session_set_fds(s, ptyfd, fdout___0, -1);
  } else {
#line 684
    server_loop(pid, ptyfd, fdout___0, -1);
#line 686
    session_pty_cleanup(s);
  }
#line 688
  return;
}
}
#line 691 "session.c"
void do_login(Session *s , char const   *command ) 
{ char *time_string ;
  char hostname[64] ;
  socklen_t fromlen ;
  struct sockaddr_storage from ;
  time_t last_login_time ;
  struct passwd *pw ;
  pid_t pid ;
  __pid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  u_long tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  char *tmp___9 ;
  char *tmp___11 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___17 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 699
  pw = s->pw;
#line 700
  tmp = getpid();
#line 700
  pid = tmp;
#line 706
  memset((void *)(& from), 0, sizeof(from));
#line 707
  tmp___4 = packet_connection_is_on_socket();
#line 707
  if (tmp___4) {
#line 708
    fromlen = sizeof(from);
#line 709
    tmp___2 = packet_get_connection_in();
#line 709
    tmp___3 = getpeername(tmp___2, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 709
    if (tmp___3 < 0) {
#line 711
      tmp___0 = __errno_location();
#line 711
      tmp___1 = strerror(*tmp___0);
#line 711
      debug("getpeername: %.100s", tmp___1);
#line 712
      fatal_cleanup();
    }
  }
#line 717
  if (options.print_lastlog) {
#line 718
    hostname[0] = (char )'\000';
#line 719
    tmp___5 = get_last_login_time(pw->pw_uid, (char const   *)pw->pw_name, hostname,
                                  sizeof(hostname));
#line 719
    last_login_time = (long )tmp___5;
  }
#line 724
  tmp___6 = get_remote_name_or_ip(utmp_len, options.reverse_mapping_check);
#line 724
  record_login(pid, (char const   *)(s->tty), (char const   *)pw->pw_name, pw->pw_uid,
               tmp___6, (struct sockaddr *)(& from));
#line 739
  tmp___7 = check_quietlogin(s, command);
#line 739
  if (tmp___7) {
#line 740
    return;
  }
#line 751
  if (options.print_lastlog) {
#line 751
    if (last_login_time != 0L) {
#line 752
      time_string = ctime((time_t const   *)(& last_login_time));
#line 753
      tmp___11 = __builtin_strchr(time_string, '\n');
#line 753
      if (tmp___11) {
#line 754
        tmp___9 = __builtin_strchr(time_string, '\n');
#line 754
        *tmp___9 = (char)0;
      }
#line 755
      if (0) {
#line 755
        __s1_len = strlen((char const   *)(hostname));
#line 755
        __s2_len = strlen("");
#line 755
        if (! ((unsigned int )((void const   *)(hostname + 1)) - (unsigned int )((void const   *)(hostname)) == 1U)) {
          goto _L___0;
        } else {
#line 755
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 755
            if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 755
              tmp___21 = 1;
            } else {
#line 755
              if (__s2_len >= 4U) {
#line 755
                tmp___21 = 1;
              } else {
#line 755
                tmp___21 = 0;
              }
            }
          } else {
#line 755
            tmp___21 = 0;
          }
        }
#line 755
        if (tmp___21) {
#line 755
          tmp___17 = __builtin_strcmp((char const   *)(hostname), "");
        } else {
#line 755
          tmp___20 = __builtin_strcmp((char const   *)(hostname), "");
#line 755
          tmp___17 = tmp___20;
        }
      } else {
#line 755
        tmp___20 = __builtin_strcmp((char const   *)(hostname), "");
#line 755
        tmp___17 = tmp___20;
      }
#line 755
      if (tmp___17 == 0) {
#line 756
        printf((char const   * __restrict  )"Last login: %s\r\n", time_string);
      } else {
#line 758
        printf((char const   * __restrict  )"Last login: %s from %s\r\n", time_string,
               hostname);
      }
    }
  }
#line 761
  do_motd();
#line 762
  return;
}
}
#line 767 "session.c"
void do_motd(void) 
{ FILE *f ;
  char buf___2[256] ;
  char *tmp ;

  {
#line 773
  if (options.print_motd) {
#line 778
    f = fopen((char const   * __restrict  )"/etc/motd", (char const   * __restrict  )"r");
#line 780
    if (f) {
#line 781
      while (1) {
#line 781
        tmp = fgets((char * __restrict  )(buf___2), (int )sizeof(buf___2), (FILE * __restrict  )f);
#line 781
        if (! tmp) {
#line 781
          break;
        }
#line 782
        fputs((char const   * __restrict  )(buf___2), (FILE * __restrict  )stdout);
      }
#line 783
      fclose(f);
    }
  }
#line 786
  return;
}
}
#line 792 "session.c"
int check_quietlogin(Session *s , char const   *command ) 
{ char buf___2[256] ;
  struct passwd *pw ;
  struct stat st ;
  int tmp ;

  {
#line 796
  pw = s->pw;
#line 800
  if ((unsigned int )command != (unsigned int )((void *)0)) {
#line 801
    return (1);
  }
#line 802
  snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"%.200s/.hushlogin",
           pw->pw_dir);
#line 807
  tmp = stat((char const   * __restrict  )(buf___2), (struct stat * __restrict  )(& st));
#line 807
  if (tmp >= 0) {
#line 808
    return (1);
  }
#line 810
  return (0);
}
}
#line 817 "session.c"
void child_set_env(char ***envp , u_int *envsizep , char const   *name , char const   *value ) 
{ u_int i ;
  u_int namelen ;
  char **env ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  void *tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  void *tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;

  {
#line 829
  env = *envp;
#line 830
  namelen = strlen(name);
#line 831
  i = 0U;
#line 831
  while (*(env + i)) {
#line 832
    if (0) {
#line 832
      if (0) {
#line 832
        __s1_len___0 = strlen((char const   *)*(env + i));
#line 832
        __s2_len___0 = strlen(name);
#line 832
        if (! ((unsigned int )((void const   *)(*(env + i) + 1)) - (unsigned int )((void const   *)*(env + i)) == 1U)) {
          goto _L___2;
        } else {
#line 832
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 832
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
#line 832
              tmp___22 = 1;
            } else {
#line 832
              if (__s2_len___0 >= 4U) {
#line 832
                tmp___22 = 1;
              } else {
#line 832
                tmp___22 = 0;
              }
            }
          } else {
#line 832
            tmp___22 = 0;
          }
        }
#line 832
        if (tmp___22) {
#line 832
          tmp___18 = __builtin_strcmp((char const   *)*(env + i), name);
        } else {
#line 832
          tmp___21 = __builtin_strcmp((char const   *)*(env + i), name);
#line 832
          tmp___18 = tmp___21;
        }
      } else {
#line 832
        tmp___21 = __builtin_strcmp((char const   *)*(env + i), name);
#line 832
        tmp___18 = tmp___21;
      }
#line 832
      tmp___12 = tmp___18;
    } else {
#line 832
      tmp___12 = strncmp((char const   *)*(env + i), name, namelen);
    }
#line 832
    if (tmp___12 == 0) {
#line 832
      if ((int )*(*(env + i) + namelen) == 61) {
#line 833
        break;
      }
    }
#line 831
    i ++;
  }
#line 834
  if (*(env + i)) {
#line 836
    xfree((void *)*(env + i));
  } else {
#line 839
    if (i >= *envsizep - 1U) {
#line 840
      *envsizep += 50U;
#line 841
      tmp___25 = xrealloc((void *)env, *envsizep * sizeof(char *));
#line 841
      *envp = (char **)tmp___25;
#line 841
      env = *envp;
    }
#line 844
    *(env + (i + 1U)) = (char *)((void *)0);
  }
#line 848
  tmp___26 = strlen(name);
#line 848
  tmp___27 = strlen(value);
#line 848
  tmp___28 = xmalloc(((tmp___26 + 1U) + tmp___27) + 1U);
#line 848
  *(env + i) = (char *)tmp___28;
#line 849
  tmp___29 = strlen(name);
#line 849
  tmp___30 = strlen(value);
#line 849
  snprintf((char * __restrict  )*(env + i), ((tmp___29 + 1U) + tmp___30) + 1U, (char const   * __restrict  )"%s=%s",
           name, value);
#line 850
  return;
}
}
#line 858 "session.c"
void read_environment_file(char ***env , u_int *envsize , char const   *filename ) 
{ FILE *f ;
  char buf___2[4096] ;
  char *cp ;
  char *value ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 866
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 867
  if (! f) {
#line 868
    return;
  }
#line 870
  while (1) {
#line 870
    tmp___5 = fgets((char * __restrict  )(buf___2), (int )sizeof(buf___2), (FILE * __restrict  )f);
#line 870
    if (! tmp___5) {
#line 870
      break;
    }
#line 871
    cp = buf___2;
#line 871
    while (1) {
#line 871
      if (! ((int )*cp == 32)) {
#line 871
        if (! ((int )*cp == 9)) {
#line 871
          break;
        }
      }
#line 871
      cp ++;
    }
#line 873
    if (! *cp) {
#line 874
      continue;
    } else {
#line 873
      if ((int )*cp == 35) {
#line 874
        continue;
      } else {
#line 873
        if ((int )*cp == 10) {
#line 874
          continue;
        }
      }
    }
#line 875
    tmp___2 = __builtin_strchr(cp, '\n');
#line 875
    if (tmp___2) {
#line 876
      tmp___0 = __builtin_strchr(cp, '\n');
#line 876
      *tmp___0 = (char )'\000';
    }
#line 877
    tmp___4 = __builtin_strchr(cp, '=');
#line 877
    value = tmp___4;
#line 878
    if ((unsigned int )value == (unsigned int )((void *)0)) {
#line 879
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad line in %.100s: %.200s\n",
              filename, buf___2);
#line 880
      continue;
    }
#line 886
    *value = (char )'\000';
#line 887
    value ++;
#line 888
    child_set_env(env, envsize, (char const   *)cp, (char const   *)value);
  }
#line 890
  fclose(f);
#line 891
  return;
}
}
#line 1044
extern char **environ ;
#line 1034 "session.c"
void do_child(Session *s , char const   *command ) 
{ char const   *shell ;
  char const   *hostname ;
  char const   *cp ;
  struct passwd *pw ;
  char buf___2[256] ;
  char cmd[1024] ;
  FILE *f ;
  u_int envsize ;
  u_int i ;
  char **env ;
  struct stat st ;
  char *argv[10] ;
  int do_xauth ;
  int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  __uid_t tmp___6 ;
  __uid_t tmp___7 ;
  __uid_t tmp___8 ;
  __uid_t tmp___9 ;
  void *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  struct envstring *ce ;
  char *s___0 ;
  int i___0 ;
  int tmp___13 ;
  int tmp___14 ;
  char const   *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  char *screen ;
  char *tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  char *tmp___30 ;
  char buf___3[256] ;
  char *mailbox ;
  struct stat mailstat ;
  int tmp___31 ;

  {
#line 1037
  hostname = (char const   *)((void *)0);
#line 1037
  cp = (char const   *)((void *)0);
#line 1038
  pw = s->pw;
#line 1041
  f = (FILE *)((void *)0);
#line 1047
  if ((unsigned int )s->auth_proto != (unsigned int )((void *)0)) {
#line 1047
    if ((unsigned int )s->auth_data != (unsigned int )((void *)0)) {
#line 1047
      tmp = 1;
    } else {
#line 1047
      tmp = 0;
    }
  } else {
#line 1047
    tmp = 0;
  }
#line 1047
  do_xauth = tmp;
#line 1060
  destroy_sensitive_data();
#line 1063
  if (options.use_login) {
#line 1063
    if ((unsigned int )command != (unsigned int )((void *)0)) {
#line 1064
      options.use_login = 0;
    }
  }
#line 1067
  if (! options.use_login) {
#line 1073
    if (pw->pw_uid) {
#line 1074
      f = fopen((char const   * __restrict  )"/etc/nologin", (char const   * __restrict  )"r");
    }
#line 1076
    if (f) {
#line 1078
      while (1) {
#line 1078
        tmp___0 = fgets((char * __restrict  )(buf___2), (int )sizeof(buf___2), (FILE * __restrict  )f);
#line 1078
        if (! tmp___0) {
#line 1078
          break;
        }
#line 1079
        fputs((char const   * __restrict  )(buf___2), (FILE * __restrict  )stderr);
      }
#line 1080
      fclose(f);
#line 1081
      exit(254);
    }
  }
#line 1089
  if (! options.use_login) {
#line 1098
    tmp___6 = getuid();
#line 1098
    if (tmp___6 == 0U) {
      goto _L;
    } else {
#line 1098
      tmp___7 = geteuid();
#line 1098
      if (tmp___7 == 0U) {
        _L: /* CIL Label */ 
#line 1116
        tmp___3 = setlogin((char const   *)pw->pw_name);
#line 1116
        if (tmp___3 < 0) {
#line 1117
          tmp___1 = __errno_location();
#line 1117
          tmp___2 = strerror(*tmp___1);
#line 1117
          error("setlogin failed: %s", tmp___2);
        }
#line 1118
        tmp___4 = setgid(pw->pw_gid);
#line 1118
        if (tmp___4 < 0) {
#line 1119
          perror("setgid");
#line 1120
          exit(1);
        }
#line 1123
        tmp___5 = initgroups((char const   *)pw->pw_name, pw->pw_gid);
#line 1123
        if (tmp___5 < 0) {
#line 1124
          perror("initgroups");
#line 1125
          exit(1);
        }
#line 1127
        endgrent();
#line 1190
        permanently_set_uid(pw);
      }
    }
#line 1198
    tmp___8 = getuid();
#line 1198
    if (tmp___8 != pw->pw_uid) {
#line 1199
      fatal("Failed to set uids to %u.", pw->pw_uid);
    } else {
#line 1198
      tmp___9 = geteuid();
#line 1198
      if (tmp___9 != pw->pw_uid) {
#line 1199
        fatal("Failed to set uids to %u.", pw->pw_uid);
      }
    }
  }
#line 1205
  if ((int )*(pw->pw_shell + 0) == 0) {
#line 1205
    shell = "/bin/sh";
  } else {
#line 1205
    shell = (char const   *)pw->pw_shell;
  }
#line 1223
  envsize = 100U;
#line 1224
  tmp___10 = xmalloc(envsize * sizeof(char *));
#line 1224
  env = (char **)tmp___10;
#line 1225
  *(env + 0) = (char *)((void *)0);
#line 1235
  if (! options.use_login) {
#line 1237
    child_set_env(& env, & envsize, "USER", (char const   *)pw->pw_name);
#line 1238
    child_set_env(& env, & envsize, "LOGNAME", (char const   *)pw->pw_name);
#line 1239
    child_set_env(& env, & envsize, "HOME", (char const   *)pw->pw_dir);
#line 1251
    child_set_env(& env, & envsize, "PATH", "/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin");
#line 1255
    snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"%.200s/%.50s",
             "/var/mail", pw->pw_name);
#line 1257
    child_set_env(& env, & envsize, "MAIL", (char const   *)(buf___2));
#line 1260
    child_set_env(& env, & envsize, "SHELL", shell);
  }
#line 1262
  tmp___12 = getenv("TZ");
#line 1262
  if (tmp___12) {
#line 1263
    tmp___11 = getenv("TZ");
#line 1263
    child_set_env(& env, & envsize, "TZ", (char const   *)tmp___11);
  }
#line 1266
  while (custom_environment) {
#line 1267
    ce = custom_environment;
#line 1268
    s___0 = ce->s;
#line 1270
    i___0 = 0;
#line 1270
    while (1) {
#line 1270
      if ((int )*(s___0 + i___0) != 61) {
#line 1270
        if (! *(s___0 + i___0)) {
#line 1270
          break;
        }
      } else {
#line 1270
        break;
      }
#line 1270
      i___0 ++;
    }
#line 1271
    if ((int )*(s___0 + i___0) == 61) {
#line 1272
      *(s___0 + i___0) = (char)0;
#line 1273
      child_set_env(& env, & envsize, (char const   *)s___0, (char const   *)((s___0 + i___0) + 1));
    }
#line 1275
    custom_environment = ce->next;
#line 1276
    xfree((void *)ce->s);
#line 1277
    xfree((void *)ce);
  }
#line 1280
  tmp___13 = get_local_port();
#line 1280
  tmp___14 = get_remote_port();
#line 1280
  tmp___15 = get_remote_ipaddr();
#line 1280
  snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"%.50s %d %d",
           tmp___15, tmp___14, tmp___13);
#line 1282
  child_set_env(& env, & envsize, "SSH_CLIENT", (char const   *)(buf___2));
#line 1284
  if (s->ttyfd != -1) {
#line 1285
    child_set_env(& env, & envsize, "SSH_TTY", (char const   *)(s->tty));
  }
#line 1286
  if (s->term) {
#line 1287
    child_set_env(& env, & envsize, "TERM", (char const   *)s->term);
  }
#line 1288
  if (s->display) {
#line 1289
    child_set_env(& env, & envsize, "DISPLAY", (char const   *)s->display);
  }
#line 1290
  if (original_command) {
#line 1291
    child_set_env(& env, & envsize, "SSH_ORIGINAL_COMMAND", (char const   *)original_command);
  }
#line 1316
  if (xauthfile) {
#line 1317
    child_set_env(& env, & envsize, "XAUTHORITY", (char const   *)xauthfile);
  }
#line 1318
  tmp___17 = auth_get_socket_name();
#line 1318
  if ((unsigned int )tmp___17 != (unsigned int )((void *)0)) {
#line 1319
    tmp___16 = auth_get_socket_name();
#line 1319
    child_set_env(& env, & envsize, "SSH_AUTH_SOCK", (char const   *)tmp___16);
  }
#line 1323
  if (! options.use_login) {
#line 1324
    snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"%.200s/.ssh/environment",
             pw->pw_dir);
#line 1326
    read_environment_file(& env, & envsize, (char const   *)(buf___2));
  }
#line 1328
  if (debug_flag) {
#line 1330
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Environment:\n");
#line 1331
    i = 0U;
#line 1331
    while (*(env + i)) {
#line 1332
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  %.200s\n",
              *(env + i));
#line 1331
      i ++;
    }
  }
#line 1335
  if (options.use_login) {
#line 1336
    hostname = get_remote_name_or_ip(utmp_len, options.reverse_mapping_check);
  }
#line 1345
  tmp___21 = packet_get_connection_in();
#line 1345
  tmp___22 = packet_get_connection_out();
#line 1345
  if (tmp___21 == tmp___22) {
#line 1346
    tmp___18 = packet_get_connection_in();
#line 1346
    close(tmp___18);
  } else {
#line 1348
    tmp___19 = packet_get_connection_in();
#line 1348
    close(tmp___19);
#line 1349
    tmp___20 = packet_get_connection_out();
#line 1349
    close(tmp___20);
  }
#line 1356
  channel_close_all();
#line 1362
  endpwent();
#line 1370
  i = 3U;
#line 1370
  while (i < 64U) {
#line 1371
    close((int )i);
#line 1370
    i ++;
  }
#line 1374
  tmp___25 = chdir((char const   *)pw->pw_dir);
#line 1374
  if (tmp___25 < 0) {
#line 1375
    tmp___23 = __errno_location();
#line 1375
    tmp___24 = strerror(*tmp___23);
#line 1375
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not chdir to home directory %s: %s\n",
            pw->pw_dir, tmp___24);
  }
#line 1387
  environ = env;
#line 1393
  if (! options.use_login) {
#line 1395
    if (! s->is_subsystem) {
#line 1395
      tmp___29 = stat((char const   * __restrict  )".ssh/rc", (struct stat * __restrict  )(& st));
#line 1395
      if (tmp___29 >= 0) {
#line 1396
        if (debug_flag) {
#line 1397
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %s %s\n",
                  "/bin/sh", ".ssh/rc");
        }
#line 1399
        f = popen("/bin/sh .ssh/rc", "w");
#line 1400
        if (f) {
#line 1401
          if (do_xauth) {
#line 1402
            fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                    s->auth_proto, s->auth_data);
          }
#line 1404
          pclose(f);
        } else {
#line 1406
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                  ".ssh/rc");
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 1408
      tmp___28 = stat((char const   * __restrict  )"/usr/local/etc/sshrc", (struct stat * __restrict  )(& st));
#line 1408
      if (tmp___28 >= 0) {
#line 1409
        if (debug_flag) {
#line 1410
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %s %s\n",
                  "/bin/sh", "/usr/local/etc/sshrc");
        }
#line 1413
        f = popen("/bin/sh /usr/local/etc/sshrc", "w");
#line 1414
        if (f) {
#line 1415
          if (do_xauth) {
#line 1416
            fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                    s->auth_proto, s->auth_data);
          }
#line 1418
          pclose(f);
        } else {
#line 1420
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                  "/usr/local/etc/sshrc");
        }
      } else {
#line 1422
        if (do_xauth) {
#line 1422
          if ((unsigned int )options.xauth_location != (unsigned int )((void *)0)) {
#line 1424
            tmp___27 = __builtin_strchr(s->display, ':');
#line 1424
            screen = tmp___27;
#line 1426
            if (debug_flag) {
#line 1427
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %.100s add %.100s %.100s %.100s\n",
                      options.xauth_location, s->display, s->auth_proto, s->auth_data);
#line 1432
              if ((unsigned int )screen != (unsigned int )((void *)0)) {
#line 1433
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Adding %.*s/unix%s %s %s\n",
                        screen - s->display, s->display, screen, s->auth_proto, s->auth_data);
              }
            }
#line 1439
            snprintf((char * __restrict  )(cmd), sizeof(cmd), (char const   * __restrict  )"%s -q -",
                     options.xauth_location);
#line 1441
            f = popen((char const   *)(cmd), "w");
#line 1442
            if (f) {
#line 1443
              fprintf((FILE * __restrict  )f, (char const   * __restrict  )"add %s %s %s\n",
                      s->display, s->auth_proto, s->auth_data);
#line 1445
              if ((unsigned int )screen != (unsigned int )((void *)0)) {
#line 1446
                fprintf((FILE * __restrict  )f, (char const   * __restrict  )"add %.*s/unix%s %s %s\n",
                        screen - s->display, s->display, screen, s->auth_proto, s->auth_data);
              }
#line 1451
              pclose(f);
            } else {
#line 1453
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                      cmd);
            }
          }
        }
      }
    }
#line 1458
    tmp___30 = strrchr(shell, '/');
#line 1458
    cp = (char const   *)tmp___30;
#line 1459
    if (cp) {
#line 1460
      cp ++;
    } else {
#line 1462
      cp = shell;
    }
  }
#line 1466
  signal(13, (void (*)(int  ))0);
#line 1473
  if (! command) {
#line 1474
    if (! options.use_login) {
#line 1481
      if (s->ttyfd != -1) {
#line 1481
        if (options.check_mail) {
#line 1485
          mailbox = getenv("MAIL");
#line 1486
          if ((unsigned int )mailbox != (unsigned int )((void *)0)) {
#line 1487
            tmp___31 = stat((char const   * __restrict  )mailbox, (struct stat * __restrict  )(& mailstat));
#line 1487
            if (tmp___31 != 0) {
#line 1489
              printf((char const   * __restrict  )"No mail.\n");
            } else {
#line 1487
              if (mailstat.st_size == 0L) {
#line 1489
                printf((char const   * __restrict  )"No mail.\n");
              } else {
#line 1490
                if (mailstat.st_mtim.tv_sec < mailstat.st_atim.tv_sec) {
#line 1491
                  printf((char const   * __restrict  )"You have mail.\n");
                } else {
#line 1493
                  printf((char const   * __restrict  )"You have new mail.\n");
                }
              }
            }
          }
        }
      }
#line 1497
      buf___3[0] = (char )'-';
#line 1498
      __builtin_strncpy(buf___3 + 1, cp, sizeof(buf___3) - 1U);
#line 1499
      buf___3[sizeof(buf___3) - 1U] = (char)0;
#line 1502
      argv[0] = buf___3;
#line 1503
      argv[1] = (char *)((void *)0);
#line 1504
      execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 1507
      perror(shell);
#line 1508
      exit(1);
    } else {
#line 1513
      execl("/bin/login", "login", "-h", hostname, "-p", "-f", "--", pw->pw_name,
            (void *)0);
#line 1518
      perror("login");
#line 1519
      exit(1);
    }
  }
#line 1526
  argv[0] = (char *)cp;
#line 1527
  argv[1] = (char *)"-c";
#line 1528
  argv[2] = (char *)command;
#line 1529
  argv[3] = (char *)((void *)0);
#line 1530
  execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 1531
  perror(shell);
#line 1532
  exit(1);
}
}
#line 1539 "session.c"
static int did_init___0  =    0;
#line 1535 "session.c"
Session *session_new(void) 
{ int i ;
  Session *s ;

  {
#line 1540
  if (! did_init___0) {
#line 1541
    debug("session_new: init");
#line 1542
    i = 0;
#line 1542
    while (i < 10) {
#line 1543
      sessions[i].used = 0;
#line 1544
      sessions[i].self = i;
#line 1542
      i ++;
    }
#line 1546
    did_init___0 = 1;
  }
#line 1548
  i = 0;
#line 1548
  while (i < 10) {
#line 1549
    s = & sessions[i];
#line 1550
    if (! s->used) {
#line 1551
      memset((void *)s, 0, sizeof(*s));
#line 1552
      s->chanid = -1;
#line 1553
      s->ptyfd = -1;
#line 1554
      s->ttyfd = -1;
#line 1555
      s->used = 1;
#line 1556
      debug("session_new: session %d", i);
#line 1557
      return (s);
    }
#line 1548
    i ++;
  }
#line 1560
  return ((Session *)((void *)0));
}
}
#line 1563 "session.c"
void session_dump(void) 
{ int i ;
  Session *s ;

  {
#line 1567
  i = 0;
#line 1567
  while (i < 10) {
#line 1568
    s = & sessions[i];
#line 1569
    debug("dump: used %d session %d %p channel %d pid %d", s->used, s->self, s, s->chanid,
          s->pid);
#line 1567
    i ++;
  }
#line 1576
  return;
}
}
#line 1578 "session.c"
int session_open(int chanid ) 
{ Session *s ;
  Session *tmp ;

  {
#line 1581
  tmp = session_new();
#line 1581
  s = tmp;
#line 1582
  debug("session_open: channel %d", chanid);
#line 1583
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1584
    error("no more sessions");
#line 1585
    return (0);
  }
#line 1587
  s->pw = auth_get_user();
#line 1588
  if ((unsigned int )s->pw == (unsigned int )((void *)0)) {
#line 1589
    fatal("no user for session %d", s->self);
  }
#line 1590
  debug("session_open: session %d: link with channel %d", s->self, chanid);
#line 1591
  s->chanid = chanid;
#line 1592
  return (1);
}
}
#line 1595 "session.c"
Session *session_by_channel(int id ) 
{ int i ;
  Session *s ;

  {
#line 1599
  i = 0;
#line 1599
  while (i < 10) {
#line 1600
    s = & sessions[i];
#line 1601
    if (s->used) {
#line 1601
      if (s->chanid == id) {
#line 1602
        debug("session_by_channel: session %d channel %d", i, id);
#line 1603
        return (s);
      }
    }
#line 1599
    i ++;
  }
#line 1606
  debug("session_by_channel: unknown channel %d", id);
#line 1607
  session_dump();
#line 1608
  return ((Session *)((void *)0));
}
}
#line 1611 "session.c"
Session *session_by_pid(pid_t pid ) 
{ int i ;
  Session *s ;

  {
#line 1615
  debug("session_by_pid: pid %d", pid);
#line 1616
  i = 0;
#line 1616
  while (i < 10) {
#line 1617
    s = & sessions[i];
#line 1618
    if (s->used) {
#line 1618
      if (s->pid == pid) {
#line 1619
        return (s);
      }
    }
#line 1616
    i ++;
  }
#line 1621
  error("session_by_pid: unknown pid %d", pid);
#line 1622
  session_dump();
#line 1623
  return ((Session *)((void *)0));
}
}
#line 1626 "session.c"
int session_window_change_req(Session *s ) 
{ u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 1629
  tmp = packet_get_int();
#line 1629
  s->col = (int )tmp;
#line 1630
  tmp___0 = packet_get_int();
#line 1630
  s->row = (int )tmp___0;
#line 1631
  tmp___1 = packet_get_int();
#line 1631
  s->xpixel = (int )tmp___1;
#line 1632
  tmp___2 = packet_get_int();
#line 1632
  s->ypixel = (int )tmp___2;
#line 1633
  while (1) {
#line 1633
    tmp___3 = packet_remaining();
#line 1633
    _len = tmp___3;
#line 1633
    if (_len > 0) {
#line 1633
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1633);
#line 1633
      packet_disconnect("Packet integrity error.");
    }
#line 1633
    break;
  }
#line 1634
  pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);
#line 1635
  return (1);
}
}
#line 1638 "session.c"
int session_pty_req(Session *s ) 
{ u_int len ;
  int n_bytes ;
  u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int _len ;
  int tmp___14 ;

  {
#line 1644
  if (no_pty_flag) {
#line 1645
    return (0);
  }
#line 1646
  if (s->ttyfd != -1) {
#line 1647
    return (0);
  }
#line 1648
  s->term = packet_get_string(& len);
#line 1649
  tmp = packet_get_int();
#line 1649
  s->col = (int )tmp;
#line 1650
  tmp___0 = packet_get_int();
#line 1650
  s->row = (int )tmp___0;
#line 1651
  tmp___1 = packet_get_int();
#line 1651
  s->xpixel = (int )tmp___1;
#line 1652
  tmp___2 = packet_get_int();
#line 1652
  s->ypixel = (int )tmp___2;
#line 1654
  if (0) {
#line 1654
    __s1_len = strlen((char const   *)s->term);
#line 1654
    __s2_len = strlen("");
#line 1654
    if (! ((unsigned int )((void const   *)(s->term + 1)) - (unsigned int )((void const   *)s->term) == 1U)) {
      goto _L___0;
    } else {
#line 1654
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1654
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 1654
          tmp___12 = 1;
        } else {
#line 1654
          if (__s2_len >= 4U) {
#line 1654
            tmp___12 = 1;
          } else {
#line 1654
            tmp___12 = 0;
          }
        }
      } else {
#line 1654
        tmp___12 = 0;
      }
    }
#line 1654
    if (tmp___12) {
#line 1654
      tmp___8 = __builtin_strcmp((char const   *)s->term, "");
    } else {
#line 1654
      tmp___11 = __builtin_strcmp((char const   *)s->term, "");
#line 1654
      tmp___8 = tmp___11;
    }
  } else {
#line 1654
    tmp___11 = __builtin_strcmp((char const   *)s->term, "");
#line 1654
    tmp___8 = tmp___11;
  }
#line 1654
  if (tmp___8 == 0) {
#line 1655
    xfree((void *)s->term);
#line 1656
    s->term = (char *)((void *)0);
  }
#line 1659
  tmp___13 = pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, (int )sizeof(s->tty));
#line 1659
  if (! tmp___13) {
#line 1660
    xfree((void *)s->term);
#line 1661
    s->term = (char *)((void *)0);
#line 1662
    s->ptyfd = -1;
#line 1663
    s->ttyfd = -1;
#line 1664
    error("session_pty_req: session %d alloc failed", s->self);
#line 1665
    return (0);
  }
#line 1667
  debug("session_pty_req: session %d alloc %s", s->self, s->tty);
#line 1672
  fatal_add_cleanup(& pty_cleanup_proc, (void *)s);
#line 1673
  pty_setowner(s->pw, (char const   *)(s->tty));
#line 1675
  pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);
#line 1678
  tty_parse_modes(s->ttyfd, & n_bytes);
#line 1679
  while (1) {
#line 1679
    tmp___14 = packet_remaining();
#line 1679
    _len = tmp___14;
#line 1679
    if (_len > 0) {
#line 1679
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1679);
#line 1679
      packet_disconnect("Packet integrity error.");
    }
#line 1679
    break;
  }
#line 1681
  session_proctitle(s);
#line 1683
  return (1);
}
}
#line 1686 "session.c"
int session_subsystem_req(Session *s ) 
{ u_int len ;
  int success ;
  char *subsys ;
  char *tmp ;
  int i ;
  int _len ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 1690
  success = 0;
#line 1691
  tmp = packet_get_string(& len);
#line 1691
  subsys = tmp;
#line 1694
  while (1) {
#line 1694
    tmp___0 = packet_remaining();
#line 1694
    _len = tmp___0;
#line 1694
    if (_len > 0) {
#line 1694
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1694);
#line 1694
      packet_disconnect("Packet integrity error.");
    }
#line 1694
    break;
  }
#line 1695
  log("subsystem request for %s", subsys);
#line 1697
  i = 0;
#line 1697
  while ((u_int )i < options.num_subsystems) {
#line 1698
    if (0) {
#line 1698
      __s1_len = strlen((char const   *)subsys);
#line 1698
      __s2_len = strlen((char const   *)options.subsystem_name[i]);
#line 1698
      if (! ((unsigned int )((void const   *)(subsys + 1)) - (unsigned int )((void const   *)subsys) == 1U)) {
        goto _L___0;
      } else {
#line 1698
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 1698
          if (! ((unsigned int )((void const   *)(options.subsystem_name[i] + 1)) - (unsigned int )((void const   *)options.subsystem_name[i]) == 1U)) {
#line 1698
            tmp___10 = 1;
          } else {
#line 1698
            if (__s2_len >= 4U) {
#line 1698
              tmp___10 = 1;
            } else {
#line 1698
              tmp___10 = 0;
            }
          }
        } else {
#line 1698
          tmp___10 = 0;
        }
      }
#line 1698
      if (tmp___10) {
#line 1698
        tmp___6 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
      } else {
#line 1698
        tmp___9 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
#line 1698
        tmp___6 = tmp___9;
      }
    } else {
#line 1698
      tmp___9 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
#line 1698
      tmp___6 = tmp___9;
    }
#line 1698
    if (tmp___6 == 0) {
#line 1699
      debug("subsystem: exec() %s", options.subsystem_command[i]);
#line 1700
      s->is_subsystem = 1;
#line 1701
      do_exec_no_pty(s, (char const   *)options.subsystem_command[i]);
#line 1702
      success = 1;
    }
#line 1697
    i ++;
  }
#line 1706
  if (! success) {
#line 1707
    log("subsystem request for %s failed, subsystem not found", subsys);
  }
#line 1709
  xfree((void *)subsys);
#line 1710
  return (success);
}
}
#line 1713 "session.c"
int session_x11_req(Session *s ) 
{ int fd ;
  u_int tmp ;
  u_int tmp___0 ;
  int _len ;
  int tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 1717
  if (no_x11_forwarding_flag) {
#line 1718
    debug("X11 forwarding disabled in user configuration file.");
#line 1719
    return (0);
  }
#line 1721
  if (! options.x11_forwarding) {
#line 1722
    debug("X11 forwarding disabled in server configuration file.");
#line 1723
    return (0);
  }
#line 1725
  if ((unsigned int )xauthfile != (unsigned int )((void *)0)) {
#line 1726
    debug("X11 fwd already started.");
#line 1727
    return (0);
  }
#line 1730
  debug("Received request for X11 forwarding with auth spoofing.");
#line 1731
  if ((unsigned int )s->display != (unsigned int )((void *)0)) {
#line 1732
    packet_disconnect("Protocol error: X11 display already set.");
  }
#line 1734
  tmp = packet_get_char();
#line 1734
  s->single_connection = (int )tmp;
#line 1735
  s->auth_proto = packet_get_string((u_int *)((void *)0));
#line 1736
  s->auth_data = packet_get_string((u_int *)((void *)0));
#line 1737
  tmp___0 = packet_get_int();
#line 1737
  s->screen = (int )tmp___0;
#line 1738
  while (1) {
#line 1738
    tmp___1 = packet_remaining();
#line 1738
    _len = tmp___1;
#line 1738
    if (_len > 0) {
#line 1738
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1738);
#line 1738
      packet_disconnect("Packet integrity error.");
    }
#line 1738
    break;
  }
#line 1740
  s->display = x11_create_display_inet(s->screen, options.x11_display_offset);
#line 1741
  if ((unsigned int )s->display == (unsigned int )((void *)0)) {
#line 1742
    xfree((void *)s->auth_proto);
#line 1743
    xfree((void *)s->auth_data);
#line 1744
    return (0);
  }
#line 1746
  tmp___2 = xmalloc(4096U);
#line 1746
  xauthfile = (char *)tmp___2;
#line 1747
  strlcpy(xauthfile, "/tmp/ssh-XXXXXXXX", 4096U);
#line 1748
  temporarily_use_uid(s->pw);
#line 1749
  tmp___5 = mkdtemp(xauthfile);
#line 1749
  if ((unsigned int )tmp___5 == (unsigned int )((void *)0)) {
#line 1750
    restore_uid();
#line 1751
    tmp___3 = __errno_location();
#line 1751
    tmp___4 = strerror(*tmp___3);
#line 1751
    error("private X11 dir: mkdtemp %s failed: %s", xauthfile, tmp___4);
#line 1753
    xfree((void *)xauthfile);
#line 1754
    xauthfile = (char *)((void *)0);
#line 1755
    xfree((void *)s->auth_proto);
#line 1756
    xfree((void *)s->auth_data);
#line 1758
    return (0);
  }
#line 1760
  strlcat(xauthfile, "/cookies", 4096U);
#line 1761
  fd = open((char const   *)xauthfile, 194, 384);
#line 1762
  if (fd >= 0) {
#line 1763
    close(fd);
  }
#line 1764
  restore_uid();
#line 1765
  fatal_add_cleanup(& xauthfile_cleanup_proc, (void *)s);
#line 1766
  return (1);
}
}
#line 1769 "session.c"
int session_shell_req(Session *s ) 
{ char *shell ;
  int _len ;
  int tmp ;

  {
#line 1773
  shell = forced_command;
#line 1774
  while (1) {
#line 1774
    tmp = packet_remaining();
#line 1774
    _len = tmp;
#line 1774
    if (_len > 0) {
#line 1774
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1774);
#line 1774
      packet_disconnect("Packet integrity error.");
    }
#line 1774
    break;
  }
#line 1775
  if (s->ttyfd == -1) {
#line 1776
    do_exec_no_pty(s, (char const   *)shell);
  } else {
#line 1778
    do_exec_pty(s, (char const   *)shell);
  }
#line 1779
  return (1);
}
}
#line 1782 "session.c"
int session_exec_req(Session *s ) 
{ u_int len ;
  char *command ;
  char *tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 1786
  tmp = packet_get_string(& len);
#line 1786
  command = tmp;
#line 1787
  while (1) {
#line 1787
    tmp___0 = packet_remaining();
#line 1787
    _len = tmp___0;
#line 1787
    if (_len > 0) {
#line 1787
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1787);
#line 1787
      packet_disconnect("Packet integrity error.");
    }
#line 1787
    break;
  }
#line 1788
  if (forced_command) {
#line 1789
    original_command = command;
#line 1790
    command = forced_command;
#line 1791
    debug("Forced command \'%.500s\'", forced_command);
  }
#line 1793
  if (s->ttyfd == -1) {
#line 1794
    do_exec_no_pty(s, (char const   *)command);
  } else {
#line 1796
    do_exec_pty(s, (char const   *)command);
  }
#line 1797
  if ((unsigned int )forced_command == (unsigned int )((void *)0)) {
#line 1798
    xfree((void *)command);
  }
#line 1799
  return (1);
}
}
#line 1805
int session_auth_agent_req(Session *s ) ;
#line 1805 "session.c"
static int called___2  =    0;
#line 1802 "session.c"
int session_auth_agent_req(Session *s ) 
{ int _len ;
  int tmp ;
  int tmp___0 ;

  {
#line 1806
  while (1) {
#line 1806
    tmp = packet_remaining();
#line 1806
    _len = tmp;
#line 1806
    if (_len > 0) {
#line 1806
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1806);
#line 1806
      packet_disconnect("Packet integrity error.");
    }
#line 1806
    break;
  }
#line 1807
  if (no_agent_forwarding_flag) {
#line 1808
    debug("session_auth_agent_req: no_agent_forwarding_flag");
#line 1809
    return (0);
  }
#line 1811
  if (called___2) {
#line 1812
    return (0);
  } else {
#line 1814
    called___2 = 1;
#line 1815
    tmp___0 = auth_input_request_forwarding(s->pw);
#line 1815
    return (tmp___0);
  }
}
}
#line 1819 "session.c"
void session_input_channel_req(int id , void *arg ) 
{ u_int len ;
  int reply ;
  int success ;
  char *rtype ;
  Session *s ;
  Channel *c ;
  u_int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___25 ;
  int tmp___28 ;
  int tmp___29 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___35 ;
  int tmp___38 ;
  int tmp___39 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___45 ;
  int tmp___48 ;
  int tmp___49 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___55 ;
  int tmp___58 ;
  int tmp___59 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___65 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;

  {
#line 1824
  success = 0;
#line 1829
  rtype = packet_get_string(& len);
#line 1830
  tmp = packet_get_char();
#line 1830
  reply = (int )tmp;
#line 1832
  s = session_by_channel(id);
#line 1833
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1834
    fatal("session_input_channel_req: channel %d: no session", id);
  }
#line 1835
  c = channel_lookup(id);
#line 1836
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1837
    fatal("session_input_channel_req: channel %d: bad channel", id);
  }
#line 1839
  debug("session_input_channel_req: session %d channel %d request %s reply %d", s->self,
        id, rtype, reply);
#line 1846
  if (c->type == 10) {
#line 1847
    if (0) {
#line 1847
      __s1_len___4 = strlen((char const   *)rtype);
#line 1847
      __s2_len___4 = strlen("shell");
#line 1847
      if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
        goto _L___10;
      } else {
#line 1847
        if (__s1_len___4 >= 4U) {
          _L___10: /* CIL Label */ 
#line 1847
          if (! ((unsigned int )((void const   *)("shell" + 1)) - (unsigned int )((void const   *)"shell") == 1U)) {
#line 1847
            tmp___59 = 1;
          } else {
#line 1847
            if (__s2_len___4 >= 4U) {
#line 1847
              tmp___59 = 1;
            } else {
#line 1847
              tmp___59 = 0;
            }
          }
        } else {
#line 1847
          tmp___59 = 0;
        }
      }
#line 1847
      if (tmp___59) {
#line 1847
        tmp___55 = __builtin_strcmp((char const   *)rtype, "shell");
      } else {
#line 1847
        tmp___58 = __builtin_strcmp((char const   *)rtype, "shell");
#line 1847
        tmp___55 = tmp___58;
      }
    } else {
#line 1847
      tmp___58 = __builtin_strcmp((char const   *)rtype, "shell");
#line 1847
      tmp___55 = tmp___58;
    }
#line 1847
    if (tmp___55 == 0) {
#line 1848
      success = session_shell_req(s);
    } else {
#line 1849
      if (0) {
#line 1849
        __s1_len___3 = strlen((char const   *)rtype);
#line 1849
        __s2_len___3 = strlen("exec");
#line 1849
        if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
          goto _L___8;
        } else {
#line 1849
          if (__s1_len___3 >= 4U) {
            _L___8: /* CIL Label */ 
#line 1849
            if (! ((unsigned int )((void const   *)("exec" + 1)) - (unsigned int )((void const   *)"exec") == 1U)) {
#line 1849
              tmp___49 = 1;
            } else {
#line 1849
              if (__s2_len___3 >= 4U) {
#line 1849
                tmp___49 = 1;
              } else {
#line 1849
                tmp___49 = 0;
              }
            }
          } else {
#line 1849
            tmp___49 = 0;
          }
        }
#line 1849
        if (tmp___49) {
#line 1849
          tmp___45 = __builtin_strcmp((char const   *)rtype, "exec");
        } else {
#line 1849
          tmp___48 = __builtin_strcmp((char const   *)rtype, "exec");
#line 1849
          tmp___45 = tmp___48;
        }
      } else {
#line 1849
        tmp___48 = __builtin_strcmp((char const   *)rtype, "exec");
#line 1849
        tmp___45 = tmp___48;
      }
#line 1849
      if (tmp___45 == 0) {
#line 1850
        success = session_exec_req(s);
      } else {
#line 1851
        if (0) {
#line 1851
          __s1_len___2 = strlen((char const   *)rtype);
#line 1851
          __s2_len___2 = strlen("pty-req");
#line 1851
          if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
            goto _L___6;
          } else {
#line 1851
            if (__s1_len___2 >= 4U) {
              _L___6: /* CIL Label */ 
#line 1851
              if (! ((unsigned int )((void const   *)("pty-req" + 1)) - (unsigned int )((void const   *)"pty-req") == 1U)) {
#line 1851
                tmp___39 = 1;
              } else {
#line 1851
                if (__s2_len___2 >= 4U) {
#line 1851
                  tmp___39 = 1;
                } else {
#line 1851
                  tmp___39 = 0;
                }
              }
            } else {
#line 1851
              tmp___39 = 0;
            }
          }
#line 1851
          if (tmp___39) {
#line 1851
            tmp___35 = __builtin_strcmp((char const   *)rtype, "pty-req");
          } else {
#line 1851
            tmp___38 = __builtin_strcmp((char const   *)rtype, "pty-req");
#line 1851
            tmp___35 = tmp___38;
          }
        } else {
#line 1851
          tmp___38 = __builtin_strcmp((char const   *)rtype, "pty-req");
#line 1851
          tmp___35 = tmp___38;
        }
#line 1851
        if (tmp___35 == 0) {
#line 1852
          success = session_pty_req(s);
        } else {
#line 1853
          if (0) {
#line 1853
            __s1_len___1 = strlen((char const   *)rtype);
#line 1853
            __s2_len___1 = strlen("x11-req");
#line 1853
            if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
              goto _L___4;
            } else {
#line 1853
              if (__s1_len___1 >= 4U) {
                _L___4: /* CIL Label */ 
#line 1853
                if (! ((unsigned int )((void const   *)("x11-req" + 1)) - (unsigned int )((void const   *)"x11-req") == 1U)) {
#line 1853
                  tmp___29 = 1;
                } else {
#line 1853
                  if (__s2_len___1 >= 4U) {
#line 1853
                    tmp___29 = 1;
                  } else {
#line 1853
                    tmp___29 = 0;
                  }
                }
              } else {
#line 1853
                tmp___29 = 0;
              }
            }
#line 1853
            if (tmp___29) {
#line 1853
              tmp___25 = __builtin_strcmp((char const   *)rtype, "x11-req");
            } else {
#line 1853
              tmp___28 = __builtin_strcmp((char const   *)rtype, "x11-req");
#line 1853
              tmp___25 = tmp___28;
            }
          } else {
#line 1853
            tmp___28 = __builtin_strcmp((char const   *)rtype, "x11-req");
#line 1853
            tmp___25 = tmp___28;
          }
#line 1853
          if (tmp___25 == 0) {
#line 1854
            success = session_x11_req(s);
          } else {
#line 1855
            if (0) {
#line 1855
              __s1_len___0 = strlen((char const   *)rtype);
#line 1855
              __s2_len___0 = strlen("auth-agent-req@openssh.com");
#line 1855
              if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
                goto _L___2;
              } else {
#line 1855
                if (__s1_len___0 >= 4U) {
                  _L___2: /* CIL Label */ 
#line 1855
                  if (! ((unsigned int )((void const   *)("auth-agent-req@openssh.com" + 1)) - (unsigned int )((void const   *)"auth-agent-req@openssh.com") == 1U)) {
#line 1855
                    tmp___19 = 1;
                  } else {
#line 1855
                    if (__s2_len___0 >= 4U) {
#line 1855
                      tmp___19 = 1;
                    } else {
#line 1855
                      tmp___19 = 0;
                    }
                  }
                } else {
#line 1855
                  tmp___19 = 0;
                }
              }
#line 1855
              if (tmp___19) {
#line 1855
                tmp___15 = __builtin_strcmp((char const   *)rtype, "auth-agent-req@openssh.com");
              } else {
#line 1855
                tmp___18 = __builtin_strcmp((char const   *)rtype, "auth-agent-req@openssh.com");
#line 1855
                tmp___15 = tmp___18;
              }
            } else {
#line 1855
              tmp___18 = __builtin_strcmp((char const   *)rtype, "auth-agent-req@openssh.com");
#line 1855
              tmp___15 = tmp___18;
            }
#line 1855
            if (tmp___15 == 0) {
#line 1856
              success = session_auth_agent_req(s);
            } else {
#line 1857
              if (0) {
#line 1857
                __s1_len = strlen((char const   *)rtype);
#line 1857
                __s2_len = strlen("subsystem");
#line 1857
                if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
                  goto _L___0;
                } else {
#line 1857
                  if (__s1_len >= 4U) {
                    _L___0: /* CIL Label */ 
#line 1857
                    if (! ((unsigned int )((void const   *)("subsystem" + 1)) - (unsigned int )((void const   *)"subsystem") == 1U)) {
#line 1857
                      tmp___9 = 1;
                    } else {
#line 1857
                      if (__s2_len >= 4U) {
#line 1857
                        tmp___9 = 1;
                      } else {
#line 1857
                        tmp___9 = 0;
                      }
                    }
                  } else {
#line 1857
                    tmp___9 = 0;
                  }
                }
#line 1857
                if (tmp___9) {
#line 1857
                  tmp___5 = __builtin_strcmp((char const   *)rtype, "subsystem");
                } else {
#line 1857
                  tmp___8 = __builtin_strcmp((char const   *)rtype, "subsystem");
#line 1857
                  tmp___5 = tmp___8;
                }
              } else {
#line 1857
                tmp___8 = __builtin_strcmp((char const   *)rtype, "subsystem");
#line 1857
                tmp___5 = tmp___8;
              }
#line 1857
              if (tmp___5 == 0) {
#line 1858
                success = session_subsystem_req(s);
              }
            }
          }
        }
      }
    }
  }
#line 1861
  if (0) {
#line 1861
    __s1_len___5 = strlen((char const   *)rtype);
#line 1861
    __s2_len___5 = strlen("window-change");
#line 1861
    if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
      goto _L___12;
    } else {
#line 1861
      if (__s1_len___5 >= 4U) {
        _L___12: /* CIL Label */ 
#line 1861
        if (! ((unsigned int )((void const   *)("window-change" + 1)) - (unsigned int )((void const   *)"window-change") == 1U)) {
#line 1861
          tmp___69 = 1;
        } else {
#line 1861
          if (__s2_len___5 >= 4U) {
#line 1861
            tmp___69 = 1;
          } else {
#line 1861
            tmp___69 = 0;
          }
        }
      } else {
#line 1861
        tmp___69 = 0;
      }
    }
#line 1861
    if (tmp___69) {
#line 1861
      tmp___65 = __builtin_strcmp((char const   *)rtype, "window-change");
    } else {
#line 1861
      tmp___68 = __builtin_strcmp((char const   *)rtype, "window-change");
#line 1861
      tmp___65 = tmp___68;
    }
  } else {
#line 1861
    tmp___68 = __builtin_strcmp((char const   *)rtype, "window-change");
#line 1861
    tmp___65 = tmp___68;
  }
#line 1861
  if (tmp___65 == 0) {
#line 1862
    success = session_window_change_req(s);
  }
#line 1865
  if (reply) {
#line 1866
    if (success) {
#line 1866
      tmp___70 = 99;
    } else {
#line 1866
      tmp___70 = 100;
    }
#line 1866
    packet_start(tmp___70);
#line 1868
    packet_put_int((unsigned int )c->remote_id);
#line 1869
    packet_send();
  }
#line 1871
  xfree((void *)rtype);
#line 1872
  return;
}
}
#line 1874 "session.c"
void session_set_fds(Session *s , int fdin___0 , int fdout___0 , int fderr___0 ) 
{ int tmp ;

  {
#line 1877
  if (! compat20) {
#line 1878
    fatal("session_set_fds: called for proto != 2.0");
  }
#line 1883
  if (s->chanid == -1) {
#line 1884
    fatal("no channel for session %d", s->self);
  }
#line 1885
  if (fderr___0 == -1) {
#line 1885
    tmp = 0;
  } else {
#line 1885
    tmp = 1;
  }
#line 1885
  channel_set_fds(s->chanid, fdout___0, fdin___0, fderr___0, tmp, 1);
#line 1889
  return;
}
}
#line 1891 "session.c"
void session_pty_cleanup(Session *s ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1894
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1895
    return;
  } else {
#line 1894
    if (s->ttyfd == -1) {
#line 1895
      return;
    }
  }
#line 1897
  debug("session_pty_cleanup: session %d release %s", s->self, s->tty);
#line 1900
  fatal_remove_cleanup(& pty_cleanup_proc, (void *)s);
#line 1903
  record_logout(s->pid, (char const   *)(s->tty));
#line 1906
  pty_release((char const   *)(s->tty));
#line 1913
  tmp___1 = close(s->ptymaster);
#line 1913
  if (tmp___1 < 0) {
#line 1914
    tmp = __errno_location();
#line 1914
    tmp___0 = strerror(*tmp);
#line 1914
    error("close(s->ptymaster): %s", tmp___0);
  }
#line 1915
  return;
}
}
#line 1917 "session.c"
void session_exit_message(Session *s , int status ) 
{ Channel *c ;
  union __anonunion_70 __constr_expr_0 ;
  union __anonunion_71 __constr_expr_1 ;
  union __anonunion_72 __constr_expr_2 ;
  union __anonunion_73 __constr_expr_3 ;
  union __anonunion_74 __constr_expr_4 ;

  {
#line 1921
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1922
    fatal("session_close: no session");
  }
#line 1923
  c = channel_lookup(s->chanid);
#line 1924
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1925
    fatal("session_close: session %d: no channel %d", s->self, s->chanid);
  }
#line 1927
  debug("session_exit_message: session %d channel %d pid %d", s->self, s->chanid,
        s->pid);
#line 1930
  __constr_expr_4.__in = status;
#line 1930
  if ((__constr_expr_4.__i & 127) == 0) {
#line 1931
    channel_request_start(s->chanid, (char *)"exit-status", 0);
#line 1933
    __constr_expr_0.__in = status;
#line 1933
    packet_put_int((unsigned int )((__constr_expr_0.__i & 65280) >> 8));
#line 1934
    packet_send();
  } else {
#line 1935
    __constr_expr_3.__in = status;
#line 1935
    if ((int )((signed char )((__constr_expr_3.__i & 127) + 1)) >> 1 > 0) {
#line 1936
      channel_request_start(s->chanid, (char *)"exit-signal", 0);
#line 1938
      __constr_expr_1.__in = status;
#line 1938
      packet_put_int((unsigned int )(__constr_expr_1.__i & 127));
#line 1940
      __constr_expr_2.__in = status;
#line 1940
      packet_put_char(__constr_expr_2.__i & 128);
#line 1944
      packet_put_cstring("");
#line 1945
      packet_put_cstring("");
#line 1946
      packet_send();
    } else {
#line 1949
      packet_disconnect("wait returned status %04x.", status);
    }
  }
#line 1953
  debug("session_exit_message: release channel %d", s->chanid);
#line 1954
  channel_cancel_cleanup(s->chanid);
#line 1961
  if (c->ostate != 128) {
#line 1962
    (*chan_write_failed)(c);
  }
#line 1963
  s->chanid = -1;
#line 1964
  return;
}
}
#line 1966 "session.c"
void session_free(Session *s ) 
{ 

  {
#line 1969
  debug("session_free: session %d pid %d", s->self, s->pid);
#line 1970
  if (s->term) {
#line 1971
    xfree((void *)s->term);
  }
#line 1972
  if (s->display) {
#line 1973
    xfree((void *)s->display);
  }
#line 1974
  if (s->auth_data) {
#line 1975
    xfree((void *)s->auth_data);
  }
#line 1976
  if (s->auth_proto) {
#line 1977
    xfree((void *)s->auth_proto);
  }
#line 1978
  s->used = 0;
#line 1979
  return;
}
}
#line 1981 "session.c"
void session_close(Session *s ) 
{ 

  {
#line 1984
  session_pty_cleanup(s);
#line 1985
  session_free(s);
#line 1986
  session_proctitle(s);
#line 1987
  return;
}
}
#line 1989 "session.c"
void session_close_by_pid(pid_t pid , int status ) 
{ Session *s ;
  Session *tmp ;

  {
#line 1992
  tmp = session_by_pid(pid);
#line 1992
  s = tmp;
#line 1993
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1994
    debug("session_close_by_pid: no session for pid %d", s->pid);
#line 1995
    return;
  }
#line 1997
  if (s->chanid != -1) {
#line 1998
    session_exit_message(s, status);
  }
#line 1999
  session_close(s);
#line 2000
  return;
}
}
#line 2006 "session.c"
void session_close_by_channel(int id , void *arg ) 
{ Session *s ;
  Session *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 2009
  tmp = session_by_channel(id);
#line 2009
  s = tmp;
#line 2010
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 2011
    debug("session_close_by_channel: no session for channel %d", id);
#line 2012
    return;
  }
#line 2015
  channel_cancel_cleanup(s->chanid);
#line 2016
  s->chanid = -1;
#line 2018
  debug("session_close_by_channel: channel %d kill %d", id, s->pid);
#line 2019
  if (s->pid == 0) {
#line 2021
    session_close(s);
  } else {
#line 2024
    if (s->ttyfd == -1) {
#line 2024
      tmp___2 = 15;
    } else {
#line 2024
      tmp___2 = 1;
    }
#line 2024
    tmp___3 = kill(s->pid, tmp___2);
#line 2024
    if (tmp___3 < 0) {
#line 2025
      tmp___0 = __errno_location();
#line 2025
      tmp___1 = strerror(*tmp___0);
#line 2025
      error("session_close_by_channel: kill %d: %s", s->pid, tmp___1);
    }
  }
#line 2028
  return;
}
}
#line 2033 "session.c"
static char buf___1[1024]  ;
#line 2030 "session.c"
char *session_tty_list(void) 
{ int i ;
  Session *s ;
  char *tmp ;

  {
#line 2035
  buf___1[0] = (char )'\000';
#line 2036
  i = 0;
#line 2036
  while (i < 10) {
#line 2037
    s = & sessions[i];
#line 2038
    if (s->used) {
#line 2038
      if (s->ttyfd != -1) {
#line 2039
        if ((int )buf___1[0] != 0) {
#line 2040
          strlcat(buf___1, ",", sizeof(buf___1));
        }
#line 2041
        tmp = strrchr((char const   *)(s->tty), '/');
#line 2041
        strlcat(buf___1, (char const   *)(tmp + 1), sizeof(buf___1));
      }
    }
#line 2036
    i ++;
  }
#line 2044
  if ((int )buf___1[0] == 0) {
#line 2045
    strlcpy(buf___1, "notty", sizeof(buf___1));
  }
#line 2046
  return (buf___1);
}
}
#line 2049 "session.c"
void session_proctitle(Session *s ) 
{ char *tmp ;

  {
#line 2052
  if ((unsigned int )s->pw == (unsigned int )((void *)0)) {
#line 2053
    error("no user for session %d", s->self);
  } else {
#line 2055
    tmp = session_tty_list();
#line 2055
    setproctitle("%s@%s", (s->pw)->pw_name, tmp);
  }
#line 2056
  return;
}
}
#line 2058 "session.c"
void do_authenticated2(Authctxt *authctxt ) 
{ 

  {
#line 2062
  server_loop2();
#line 2063
  if (xauthfile) {
#line 2064
    xauthfile_cleanup_proc((void *)0);
  }
#line 2065
  return;
}
}
#line 1 "groupaccess.o"
#pragma merger(0,"./groupaccess.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 103 "/usr/include/grp.h"
extern struct group *getgrgid(__gid_t __gid ) ;
#line 188
extern int getgrouplist(char const   *__user , __gid_t __group , __gid_t *__groups ,
                        int *__ngroups ) ;
#line 34 "groupaccess.c"
static int ngroups  ;
#line 35 "groupaccess.c"
static char *groups_byname[65537]  ;
#line 37 "groupaccess.c"
int ga_init(char const   *user , gid_t base ) 
{ gid_t groups_bygid[65537] ;
  int i ;
  int j ;
  struct group *gr ;
  int tmp ;
  int tmp___0 ;

  {
#line 44
  if (ngroups > 0) {
#line 45
    ga_free();
  }
#line 47
  ngroups = (int )(sizeof(groups_bygid) / sizeof(gid_t ));
#line 48
  tmp = getgrouplist(user, base, groups_bygid, & ngroups);
#line 48
  if (tmp == -1) {
#line 49
    log("getgrouplist: groups list too small");
  }
#line 50
  i = 0;
#line 50
  j = 0;
#line 50
  while (i < ngroups) {
#line 51
    gr = getgrgid(groups_bygid[i]);
#line 51
    if ((unsigned int )gr != (unsigned int )((void *)0)) {
#line 52
      tmp___0 = j;
#line 52
      j ++;
#line 52
      groups_byname[tmp___0] = xstrdup((char const   *)gr->gr_name);
    }
#line 50
    i ++;
  }
#line 53
  ngroups = j;
#line 53
  return (ngroups);
}
}
#line 56 "groupaccess.c"
int ga_match(char * const  *groups , int n___0 ) 
{ int i ;
  int j ;
  int tmp ;

  {
#line 61
  i = 0;
#line 61
  while (i < ngroups) {
#line 62
    j = 0;
#line 62
    while (j < n___0) {
#line 63
      tmp = match_pattern((char const   *)groups_byname[i], (char const   *)*(groups + j));
#line 63
      if (tmp) {
#line 64
        return (1);
      }
#line 62
      j ++;
    }
#line 61
    i ++;
  }
#line 65
  return (0);
}
}
#line 68 "groupaccess.c"
void ga_free(void) 
{ int i ;

  {
#line 73
  if (ngroups > 0) {
#line 74
    i = 0;
#line 74
    while (i < ngroups) {
#line 75
      xfree((void *)groups_byname[i]);
#line 74
      i ++;
    }
#line 76
    ngroups = 0;
  }
#line 78
  return;
}
}
