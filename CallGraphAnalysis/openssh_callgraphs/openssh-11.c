/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

#line 214 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stddef.h"
typedef unsigned int size_t;
#line 71 "/usr/include/openssl/rc4.h"
struct rc4_key_st {
   unsigned int x ;
   unsigned int y ;
   unsigned int data[256] ;
};
#line 71 "/usr/include/openssl/rc4.h"
typedef struct rc4_key_st RC4_KEY;
#line 34 "/usr/include/bits/types.h"
typedef unsigned char __u_char;
#line 35 "/usr/include/sys/types.h"
typedef __u_char u_char;
#line 45 "/usr/include/bits/types.h"
typedef unsigned int __uint32_t;
#line 195 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 202 "/usr/include/sys/types.h"
typedef unsigned short u_int16_t;
#line 36 "/usr/include/bits/socket.h"
typedef __socklen_t socklen_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 145 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 162 "/usr/include/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   __uint32_t __ss_align ;
   char __ss_padding[128U - 2U * sizeof(__uint32_t )] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 92 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 136 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 137 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 193 "/usr/include/netinet/in.h"
union __anonunion_in6_u_21 {
   uint8_t u6_addr8[16] ;
   uint16_t u6_addr16[8] ;
   uint32_t u6_addr32[4] ;
};
#line 193 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion_in6_u_21 in6_u ;
};
#line 219 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 233 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 183 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 36 "/usr/include/bits/types.h"
typedef unsigned int __u_int;
#line 37 "/usr/include/sys/types.h"
typedef __u_int u_int;
#line 30 "/usr/include/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 107 "/usr/include/openssl/ossl_typ.h"
struct bignum_st;
#line 107 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_st BIGNUM;
#line 108
struct bignum_ctx;
#line 108 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_ctx BN_CTX;
#line 109
struct bn_blinding_st;
#line 109 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_blinding_st BN_BLINDING;
#line 110
struct bn_mont_ctx_st;
#line 110 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_mont_ctx_st BN_MONT_CTX;
#line 112
struct bn_gencb_st;
#line 112 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_gencb_st BN_GENCB;
#line 125
struct dsa_st;
#line 125 "/usr/include/openssl/ossl_typ.h"
typedef struct dsa_st DSA;
#line 126
struct dsa_method;
#line 126 "/usr/include/openssl/ossl_typ.h"
typedef struct dsa_method DSA_METHOD;
#line 128
struct rsa_st;
#line 128 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_st RSA;
#line 129
struct rsa_meth_st;
#line 129 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_meth_st RSA_METHOD;
#line 154
struct engine_st;
#line 154 "/usr/include/openssl/ossl_typ.h"
typedef struct engine_st ENGINE;
#line 165
struct crypto_ex_data_st;
#line 165 "/usr/include/openssl/ossl_typ.h"
typedef struct crypto_ex_data_st CRYPTO_EX_DATA;
#line 66 "/usr/include/openssl/stack.h"
struct stack_st {
   int num ;
   char **data ;
   int sorted ;
   int num_alloc ;
   int (*comp)(char const   * const  * , char const   * const  * ) ;
};
#line 66 "/usr/include/openssl/stack.h"
typedef struct stack_st STACK;
#line 283 "/usr/include/openssl/crypto.h"
struct crypto_ex_data_st {
   STACK *sk ;
   int dummy ;
};
#line 285 "/usr/include/openssl/bn.h"
struct bignum_st {
   unsigned long *d ;
   int top ;
   int dmax ;
   int neg ;
   int flags ;
};
#line 296 "/usr/include/openssl/bn.h"
struct bn_mont_ctx_st {
   int ri ;
   BIGNUM RR ;
   BIGNUM N ;
   BIGNUM Ni ;
   unsigned long n0 ;
   int flags ;
};
#line 320 "/usr/include/openssl/bn.h"
union __anonunion_cb_63 {
   void (*cb_1)(int  , int  , void * ) ;
   int (*cb_2)(int  , int  , BN_GENCB * ) ;
};
#line 320 "/usr/include/openssl/bn.h"
struct bn_gencb_st {
   unsigned int ver ;
   void *arg ;
   union __anonunion_cb_63 cb ;
};
#line 85 "/usr/include/openssl/rsa.h"
struct rsa_meth_st {
   char const   *name ;
   int (*rsa_pub_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_pub_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_priv_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_priv_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_mod_exp)(BIGNUM *r0 , BIGNUM const   *I , RSA *rsa , BN_CTX *ctx ) ;
   int (*bn_mod_exp)(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(RSA *rsa ) ;
   int (*finish)(RSA *rsa ) ;
   int flags ;
   char *app_data ;
   int (*rsa_sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
                   unsigned int *siglen , RSA const   *rsa ) ;
   int (*rsa_verify)(int dtype , unsigned char const   *m , unsigned int m_length ,
                     unsigned char *sigbuf , unsigned int siglen , RSA const   *rsa ) ;
   int (*rsa_keygen)(RSA *rsa , int bits , BIGNUM *e , BN_GENCB *cb ) ;
};
#line 128 "/usr/include/openssl/rsa.h"
struct rsa_st {
   int pad ;
   long version ;
   RSA_METHOD const   *meth ;
   ENGINE *engine ;
   BIGNUM *n ;
   BIGNUM *e ;
   BIGNUM *d ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *dmp1 ;
   BIGNUM *dmq1 ;
   BIGNUM *iqmp ;
   CRYPTO_EX_DATA ex_data ;
   int references ;
   int flags ;
   BN_MONT_CTX *_method_mod_n ;
   BN_MONT_CTX *_method_mod_p ;
   BN_MONT_CTX *_method_mod_q ;
   char *bignum_data ;
   BN_BLINDING *blinding ;
   BN_BLINDING *mt_blinding ;
};
#line 19 "buffer.h"
struct __anonstruct_Buffer_66 {
   char *buf ;
   u_int alloc ;
   u_int offset ;
   u_int end ;
};
#line 19 "buffer.h"
typedef struct __anonstruct_Buffer_66 Buffer;
#line 106 "/usr/include/openssl/dsa.h"
struct DSA_SIG_st {
   BIGNUM *r ;
   BIGNUM *s ;
};
#line 106 "/usr/include/openssl/dsa.h"
typedef struct DSA_SIG_st DSA_SIG;
#line 112 "/usr/include/openssl/dsa.h"
struct dsa_method {
   char const   *name ;
   DSA_SIG *(*dsa_do_sign)(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
   int (*dsa_sign_setup)(DSA *dsa , BN_CTX *ctx_in , BIGNUM **kinvp , BIGNUM **rp ) ;
   int (*dsa_do_verify)(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                        DSA *dsa ) ;
   int (*dsa_mod_exp)(DSA *dsa , BIGNUM *rr , BIGNUM *a1 , BIGNUM *p1 , BIGNUM *a2 ,
                      BIGNUM *p2 , BIGNUM *m , BN_CTX *ctx , BN_MONT_CTX *in_mont ) ;
   int (*bn_mod_exp)(DSA *dsa , BIGNUM *r , BIGNUM *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DSA *dsa ) ;
   int (*finish)(DSA *dsa ) ;
   int flags ;
   char *app_data ;
   int (*dsa_paramgen)(DSA *dsa , int bits , unsigned char *seed , int seed_len ,
                       int *counter_ret , unsigned long *h_ret , BN_GENCB *cb ) ;
   int (*dsa_keygen)(DSA *dsa ) ;
};
#line 139 "/usr/include/openssl/dsa.h"
struct dsa_st {
   int pad ;
   long version ;
   int write_params ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *g ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   BIGNUM *kinv ;
   BIGNUM *r ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DSA_METHOD const   *meth ;
   ENGINE *engine ;
};
#line 32 "key.h"
struct Key;
#line 32 "key.h"
typedef struct Key Key;
#line 39 "key.h"
struct Key {
   int type ;
   RSA *rsa ;
   DSA *dsa ;
};
#line 47 "authfd.h"
struct __anonstruct_AuthenticationConnection_67 {
   int fd ;
   Buffer identities ;
   int howmany ;
};
#line 47 "authfd.h"
typedef struct __anonstruct_AuthenticationConnection_67 AuthenticationConnection;
#line 59 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 60 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 137 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 143 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 144 "/usr/include/bits/types.h"
typedef long __off_t;
#line 145 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 152 "/usr/include/bits/types.h"
typedef long __time_t;
#line 167 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 172 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 88 "/usr/include/sys/types.h"
typedef __off_t off_t;
#line 203 "/usr/include/sys/types.h"
typedef unsigned int u_int32_t;
#line 121 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 177 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 183 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 268 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/openssl/ossl_typ.h"
struct asn1_string_st;
#line 79 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_INTEGER;
#line 80 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_ENUMERATED;
#line 81 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_BIT_STRING;
#line 82 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_OCTET_STRING;
#line 83 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_PRINTABLESTRING;
#line 84 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_T61STRING;
#line 85 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_IA5STRING;
#line 86 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_GENERALSTRING;
#line 87 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UNIVERSALSTRING;
#line 88 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_BMPSTRING;
#line 89 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UTCTIME;
#line 91 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_GENERALIZEDTIME;
#line 92 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_VISIBLESTRING;
#line 93 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UTF8STRING;
#line 94 "/usr/include/openssl/ossl_typ.h"
typedef int ASN1_BOOLEAN;
#line 116
struct evp_cipher_st;
#line 116 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_cipher_st EVP_CIPHER;
#line 117
struct evp_cipher_ctx_st;
#line 117 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_cipher_ctx_st EVP_CIPHER_CTX;
#line 120
struct evp_pkey_st;
#line 120 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_pkey_st EVP_PKEY;
#line 122
struct dh_st;
#line 122 "/usr/include/openssl/ossl_typ.h"
typedef struct dh_st DH;
#line 123
struct dh_method;
#line 123 "/usr/include/openssl/ossl_typ.h"
typedef struct dh_method DH_METHOD;
#line 206 "/usr/include/openssl/asn1.h"
struct asn1_object_st {
   char const   *sn ;
   char const   *ln ;
   int nid ;
   int length ;
   unsigned char *data ;
   int flags ;
};
#line 206 "/usr/include/openssl/asn1.h"
typedef struct asn1_object_st ASN1_OBJECT;
#line 222 "/usr/include/openssl/asn1.h"
struct asn1_string_st {
   int length ;
   int type ;
   unsigned char *data ;
   long flags ;
};
#line 222 "/usr/include/openssl/asn1.h"
typedef struct asn1_string_st ASN1_STRING;
#line 488 "/usr/include/openssl/asn1.h"
union __anonunion_value_64 {
   char *ptr ;
   ASN1_BOOLEAN boolean ;
   ASN1_STRING *asn1_string ;
   ASN1_OBJECT *object ;
   ASN1_INTEGER *integer ;
   ASN1_ENUMERATED *enumerated ;
   ASN1_BIT_STRING *bit_string ;
   ASN1_OCTET_STRING *octet_string ;
   ASN1_PRINTABLESTRING *printablestring ;
   ASN1_T61STRING *t61string ;
   ASN1_IA5STRING *ia5string ;
   ASN1_GENERALSTRING *generalstring ;
   ASN1_BMPSTRING *bmpstring ;
   ASN1_UNIVERSALSTRING *universalstring ;
   ASN1_UTCTIME *utctime ;
   ASN1_GENERALIZEDTIME *generalizedtime ;
   ASN1_VISIBLESTRING *visiblestring ;
   ASN1_UTF8STRING *utf8string ;
   ASN1_STRING *set ;
   ASN1_STRING *sequence ;
};
#line 488 "/usr/include/openssl/asn1.h"
struct asn1_type_st {
   int type ;
   union __anonunion_value_64 value ;
};
#line 488 "/usr/include/openssl/asn1.h"
typedef struct asn1_type_st ASN1_TYPE;
#line 126 "/usr/include/openssl/evp.h"
union __anonunion_pkey_65 {
   char *ptr ;
   struct rsa_st *rsa ;
   struct dsa_st *dsa ;
   struct dh_st *dh ;
};
#line 126 "/usr/include/openssl/evp.h"
struct evp_pkey_st {
   int type ;
   int save_type ;
   int references ;
   union __anonunion_pkey_65 pkey ;
   int save_parameters ;
   STACK *attributes ;
};
#line 297 "/usr/include/openssl/evp.h"
struct evp_cipher_st {
   int nid ;
   int block_size ;
   int key_len ;
   int iv_len ;
   unsigned long flags ;
   int (*init)(EVP_CIPHER_CTX *ctx , unsigned char const   *key , unsigned char const   *iv ,
               int enc ) ;
   int (*do_cipher)(EVP_CIPHER_CTX *ctx , unsigned char *out , unsigned char const   *in ,
                    unsigned int inl ) ;
   int (*cleanup)(EVP_CIPHER_CTX * ) ;
   int ctx_size ;
   int (*set_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*get_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*ctrl)(EVP_CIPHER_CTX * , int type , int arg , void *ptr ) ;
   void *app_data ;
};
#line 357 "/usr/include/openssl/evp.h"
struct evp_cipher_ctx_st {
   EVP_CIPHER const   *cipher ;
   ENGINE *engine ;
   int encrypt ;
   int buf_len ;
   unsigned char oiv[16] ;
   unsigned char iv[16] ;
   unsigned char buf[32] ;
   int num ;
   void *app_data ;
   int key_len ;
   unsigned long flags ;
   void *cipher_data ;
   int final_used ;
   int block_mask ;
   unsigned char final[32] ;
};
#line 95 "/usr/include/openssl/dh.h"
struct dh_method {
   char const   *name ;
   int (*generate_key)(DH *dh ) ;
   int (*compute_key)(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
   int (*bn_mod_exp)(DH const   *dh , BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p ,
                     BIGNUM const   *m , BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DH *dh ) ;
   int (*finish)(DH *dh ) ;
   int flags ;
   char *app_data ;
   int (*generate_params)(DH *dh , int prime_len , int generator , BN_GENCB *cb ) ;
};
#line 113 "/usr/include/openssl/dh.h"
struct dh_st {
   int pad ;
   int version ;
   BIGNUM *p ;
   BIGNUM *g ;
   long length ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   BIGNUM *q ;
   BIGNUM *j ;
   unsigned char *seed ;
   int seedlen ;
   BIGNUM *counter ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DH_METHOD const   *meth ;
   ENGINE *engine ;
};
#line 529 "/usr/include/openssl/pem.h"
typedef int pem_password_cb(char *buf , int size , int rwflag , void *userdata );
#line 78 "/usr/include/openssl/des.h"
typedef unsigned char DES_cblock[8];
#line 83 "/usr/include/openssl/des.h"
union __anonunion_ks_72 {
   DES_cblock cblock ;
   unsigned long deslong[2] ;
};
#line 83 "/usr/include/openssl/des.h"
struct DES_ks {
   union __anonunion_ks_72 ks[16] ;
};
#line 83 "/usr/include/openssl/des.h"
typedef struct DES_ks DES_key_schedule;
#line 101 "/usr/include/openssl/blowfish.h"
struct bf_key_st {
   unsigned int P[18] ;
   unsigned int S[1024] ;
};
#line 80 "/usr/include/openssl/cast.h"
struct cast_key_st {
   unsigned long data[32] ;
   int short_key ;
};
#line 80 "/usr/include/openssl/cast.h"
typedef struct cast_key_st CAST_KEY;
#line 12 "rijndael.h"
typedef u_int32_t u4byte;
#line 18 "rijndael.h"
struct _rijndael_ctx {
   u4byte k_len ;
   int decrypt ;
   u4byte e_key[64] ;
   u4byte d_key[64] ;
};
#line 18 "rijndael.h"
typedef struct _rijndael_ctx rijndael_ctx;
#line 62 "cipher.h"
struct Cipher;
#line 62 "cipher.h"
typedef struct Cipher Cipher;
#line 63
struct CipherContext;
#line 63 "cipher.h"
typedef struct CipherContext CipherContext;
#line 65 "cipher.h"
struct __anonstruct_des_75 {
   DES_key_schedule key ;
   DES_cblock iv ;
};
#line 65 "cipher.h"
struct __anonstruct_des3_76 {
   DES_key_schedule key1 ;
   DES_key_schedule key2 ;
   DES_cblock iv2 ;
   DES_key_schedule key3 ;
   DES_cblock iv3 ;
};
#line 65 "cipher.h"
struct __anonstruct_bf_77 {
   struct bf_key_st key ;
   u_char iv[8] ;
};
#line 65 "cipher.h"
struct __anonstruct_cast_78 {
   CAST_KEY key ;
   u_char iv[8] ;
};
#line 65 "cipher.h"
struct __anonstruct_rijndael_79 {
   u4byte iv[4] ;
   rijndael_ctx enc ;
   rijndael_ctx dec ;
};
#line 65 "cipher.h"
union __anonunion_u_74 {
   struct __anonstruct_des_75 des ;
   struct __anonstruct_des3_76 des3 ;
   struct __anonstruct_bf_77 bf ;
   struct __anonstruct_cast_78 cast ;
   struct __anonstruct_rijndael_79 rijndael ;
   RC4_KEY rc4 ;
};
#line 65 "cipher.h"
struct CipherContext {
   union __anonunion_u_74 u ;
   Cipher *cipher ;
};
#line 95 "cipher.h"
struct Cipher {
   char *name ;
   int number ;
   u_int block_size ;
   u_int key_len ;
   void (*setkey)(CipherContext * , u_char const   * , u_int  ) ;
   void (*setiv)(CipherContext * , u_char const   * , u_int  ) ;
   void (*encrypt)(CipherContext * , u_char * , u_char const   * , u_int  ) ;
   void (*decrypt)(CipherContext * , u_char * , u_char const   * , u_int  ) ;
};
#line 204 "/usr/include/sys/types.h"
typedef unsigned long long u_int64_t;
#line 44 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 321 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 538 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 35 "/usr/include/bits/types.h"
typedef unsigned short __u_short;
#line 146 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 36 "/usr/include/sys/types.h"
typedef __u_short u_short;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024U / (8U * sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 85 "/usr/include/sys/select.h"
typedef __fd_mask fd_mask;
#line 314 "/usr/include/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 25 "/usr/include/bits/termios.h"
typedef unsigned char cc_t;
#line 26 "/usr/include/bits/termios.h"
typedef unsigned int speed_t;
#line 27 "/usr/include/bits/termios.h"
typedef unsigned int tcflag_t;
#line 30 "/usr/include/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 60 "channels.h"
struct Channel;
#line 61 "channels.h"
typedef struct Channel Channel;
#line 63 "channels.h"
typedef void channel_callback_fn(int id , void *arg );
#line 64 "channels.h"
typedef int channel_filter_fn(struct Channel *c , char *buf , int len );
#line 66 "channels.h"
struct Channel {
   int type ;
   int self ;
   int remote_id ;
   int istate ;
   int ostate ;
   int flags ;
   int rfd ;
   int wfd ;
   int efd ;
   int sock ;
   int isatty ;
   Buffer input ;
   Buffer output ;
   Buffer extended ;
   char path[200] ;
   int listening_port ;
   int host_port ;
   char *remote_name ;
   int remote_window ;
   int remote_maxpacket ;
   int local_window ;
   int local_window_max ;
   int local_consumed ;
   int local_maxpacket ;
   int extended_usage ;
   char *ctype ;
   channel_callback_fn *cb_fn ;
   void *cb_arg ;
   int cb_event ;
   channel_callback_fn *dettach_user ;
   channel_filter_fn *input_filter ;
};
#line 75 "nchan.h"
typedef void chan_event_fn(Channel *c );
#line 113 "channels.c"
struct __anonstruct_ForwardPermission_69 {
   char *host_to_connect ;
   u_short port_to_connect ;
   u_short listen_port ;
};
#line 113 "channels.c"
typedef struct __anonstruct_ForwardPermission_69 ForwardPermission;
#line 355 "channels.c"
typedef void chan_fn(Channel *c , fd_set *readset , fd_set *writeset );
#line 79 "/usr/include/openssl/des.h"
typedef unsigned char const_DES_cblock[8];
#line 101 "/usr/include/openssl/blowfish.h"
typedef struct bf_key_st BF_KEY;
#line 99 "/usr/include/openssl/md5.h"
struct MD5state_st {
   unsigned int A ;
   unsigned int B ;
   unsigned int C ;
   unsigned int D ;
   unsigned int Nl ;
   unsigned int Nh ;
   unsigned int data[16] ;
   unsigned int num ;
};
#line 99 "/usr/include/openssl/md5.h"
typedef struct MD5state_st MD5_CTX;
#line 148 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 28 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024U / (8U * sizeof(unsigned long ))] ;
};
#line 28 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 33 "/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__kill_26 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__timer_27 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__rt_28 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_29 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_30 {
   void *si_addr ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_31 {
   long si_band ;
   int si_fd ;
};
#line 51 "/usr/include/bits/siginfo.h"
union __anonunion__sifields_25 {
   int _pad[128U / sizeof(int ) - 3U] ;
   struct __anonstruct__kill_26 _kill ;
   struct __anonstruct__timer_27 _timer ;
   struct __anonstruct__rt_28 _rt ;
   struct __anonstruct__sigchld_29 _sigchld ;
   struct __anonstruct__sigfault_30 _sigfault ;
   struct __anonstruct__sigpoll_31 _sigpoll ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_25 _sifields ;
};
#line 51 "/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 25 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_43 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_43 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 44 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 343 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *buffer ;
   unsigned long allocated ;
   unsigned long used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 407 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 410 "/usr/include/regex.h"
typedef int regoff_t;
#line 434 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_63 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 434 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_63 regmatch_t;
#line 66 "compat.c"
struct __anonstruct_check_67 {
   char *pat ;
   int bugs ;
};
#line 261 "/usr/include/zconf.h"
typedef unsigned char Byte;
#line 263 "/usr/include/zconf.h"
typedef unsigned int uInt;
#line 264 "/usr/include/zconf.h"
typedef unsigned long uLong;
#line 270 "/usr/include/zconf.h"
typedef Byte Bytef;
#line 279 "/usr/include/zconf.h"
typedef void *voidpf;
#line 80 "/usr/include/zlib.h"
struct internal_state;
#line 82 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 82 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 103 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 1346 "/usr/include/zlib.h"
struct internal_state {
   int dummy ;
};
#line 31 "dispatch.h"
typedef void dispatch_fn(int type , int plen , void *ctxt );
#line 118 "/usr/include/openssl/ossl_typ.h"
struct env_md_st;
#line 118 "/usr/include/openssl/ossl_typ.h"
typedef struct env_md_st EVP_MD;
#line 119
struct env_md_ctx_st;
#line 119 "/usr/include/openssl/ossl_typ.h"
typedef struct env_md_ctx_st EVP_MD_CTX;
#line 220 "/usr/include/openssl/evp.h"
struct env_md_st {
   int type ;
   int pkey_type ;
   int md_size ;
   unsigned long flags ;
   int (*init)(EVP_MD_CTX *ctx ) ;
   int (*update)(EVP_MD_CTX *ctx , void const   *data , size_t count ) ;
   int (*final)(EVP_MD_CTX *ctx , unsigned char *md ) ;
   int (*copy)(EVP_MD_CTX *to , EVP_MD_CTX const   *from ) ;
   int (*cleanup)(EVP_MD_CTX *ctx ) ;
   int (*sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
               unsigned int *siglen , void *key ) ;
   int (*verify)(int type , unsigned char const   *m , unsigned int m_length , unsigned char const   *sigbuf ,
                 unsigned int siglen , void *key ) ;
   int required_pkey_type[5] ;
   int block_size ;
   int ctx_size ;
};
#line 280 "/usr/include/openssl/evp.h"
struct env_md_ctx_st {
   EVP_MD const   *digest ;
   ENGINE *engine ;
   unsigned long flags ;
   void *md_data ;
};
#line 75 "/usr/include/openssl/hmac.h"
struct hmac_ctx_st {
   EVP_MD const   *md ;
   EVP_MD_CTX md_ctx ;
   EVP_MD_CTX i_ctx ;
   EVP_MD_CTX o_ctx ;
   unsigned int key_length ;
   unsigned char key[128] ;
};
#line 75 "/usr/include/openssl/hmac.h"
typedef struct hmac_ctx_st HMAC_CTX;
#line 61 "kex.h"
struct Mac;
#line 61 "kex.h"
typedef struct Mac Mac;
#line 72 "kex.h"
struct Mac {
   char *name ;
   int enabled ;
   EVP_MD *md ;
   int mac_len ;
   u_char *key ;
   int key_len ;
};
#line 37 "mac.c"
struct __anonstruct_macs_77 {
   char *name ;
   EVP_MD *(*mdfunc)(void) ;
   int truncatebits ;
};
#line 26 "hostfile.h"
enum __anonenum_HostStatus_65 {
    HOST_OK = 0,
    HOST_NEW = 1,
    HOST_CHANGED = 2
} ;
#line 26 "hostfile.h"
typedef enum __anonenum_HostStatus_65 HostStatus;
#line 60 "kex.h"
struct Kex;
#line 60 "kex.h"
typedef struct Kex Kex;
#line 62
struct Comp;
#line 62 "kex.h"
typedef struct Comp Comp;
#line 63
struct Enc;
#line 63 "kex.h"
typedef struct Enc Enc;
#line 65 "kex.h"
struct Enc {
   char *name ;
   Cipher *cipher ;
   int enabled ;
   u_char *key ;
   u_char *iv ;
};
#line 80 "kex.h"
struct Comp {
   int type ;
   int enabled ;
   char *name ;
};
#line 85 "kex.h"
struct Kex {
   Enc enc[2] ;
   Mac mac[2] ;
   Comp comp[2] ;
   int we_need ;
   int server ;
   char *name ;
   int hostkey_type ;
   int kex_type ;
};
#line 43 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 105 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 19 "log.h"
typedef int SyslogFacility;
#line 36
enum __anonenum_LogLevel_63 {
    SYSLOG_LEVEL_QUIET = 0,
    SYSLOG_LEVEL_FATAL = 1,
    SYSLOG_LEVEL_ERROR = 2,
    SYSLOG_LEVEL_INFO = 3,
    SYSLOG_LEVEL_VERBOSE = 4,
    SYSLOG_LEVEL_DEBUG1 = 5,
    SYSLOG_LEVEL_DEBUG2 = 6,
    SYSLOG_LEVEL_DEBUG3 = 7
} ;
#line 36 "log.h"
typedef enum __anonenum_LogLevel_63 LogLevel;
#line 120 "log.c"
struct fatal_cleanup {
   struct fatal_cleanup *next ;
   void (*proc)(void * ) ;
   void *context ;
};
#line 183 "log.c"
struct __anonstruct_log_facilities_64 {
   char const   *name ;
   SyslogFacility val ;
};
#line 204 "log.c"
struct __anonstruct_log_levels_65 {
   char const   *name ;
   LogLevel val ;
};
#line 24 "misc.h"
typedef void (*mysig_t)(int  );
#line 154 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 201 "/usr/include/sys/types.h"
typedef unsigned char u_int8_t;
#line 10 "rijndael.h"
typedef u_int8_t u1byte;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 75 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 36 "servconf.h"
struct __anonstruct_ServerOptions_67 {
   u_int num_ports ;
   u_int ports_from_cmdline ;
   u_short ports[256] ;
   char *listen_addr ;
   struct addrinfo *listen_addrs ;
   char *host_key_files[256] ;
   int num_host_key_files ;
   char *pid_file ;
   int server_key_bits ;
   int login_grace_time ;
   int key_regeneration_time ;
   int permit_root_login ;
   int ignore_rhosts ;
   int ignore_user_known_hosts ;
   int print_motd ;
   int check_mail ;
   int x11_forwarding ;
   int x11_display_offset ;
   char *xauth_location ;
   int strict_modes ;
   int keepalives ;
   char *ciphers ;
   char *macs ;
   int protocol ;
   int gateway_ports ;
   SyslogFacility log_facility ;
   LogLevel log_level ;
   int rhosts_authentication ;
   int rhosts_rsa_authentication ;
   int rsa_authentication ;
   int pubkey_authentication ;
   int password_authentication ;
   int kbd_interactive_authentication ;
   int challenge_reponse_authentication ;
   int permit_empty_passwd ;
   int use_login ;
   int allow_tcp_forwarding ;
   u_int num_allow_users ;
   char *allow_users[256] ;
   u_int num_deny_users ;
   char *deny_users[256] ;
   u_int num_allow_groups ;
   char *allow_groups[256] ;
   u_int num_deny_groups ;
   char *deny_groups[256] ;
   u_int num_subsystems ;
   char *subsystem_name[256] ;
   char *subsystem_command[256] ;
   int max_startups_begin ;
   int max_startups_rate ;
   int max_startups ;
   char *banner ;
   int reverse_mapping_check ;
};
#line 36 "servconf.h"
typedef struct __anonstruct_ServerOptions_67 ServerOptions;
#line 151 "sshd.c"
struct __anonstruct_sensitive_data_78 {
   Key *server_key ;
   Key *ssh1_host_key ;
   Key **host_keys ;
   int have_ssh1_key ;
   int have_ssh2_key ;
};
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 77 "/usr/include/time.h"
typedef __time_t time_t;
#line 40 "/usr/include/shadow.h"
struct spwd {
   char *sp_namp ;
   char *sp_pwdp ;
   long sp_lstchg ;
   long sp_min ;
   long sp_max ;
   long sp_warn ;
   long sp_inact ;
   long sp_expire ;
   unsigned long sp_flag ;
};
#line 38 "auth.h"
struct Authctxt;
#line 38 "auth.h"
typedef struct Authctxt Authctxt;
#line 39 "auth.h"
struct Authctxt {
   int success ;
   int postponed ;
   int valid ;
   int attempt ;
   int failures ;
   char *user ;
   char *service ;
   struct passwd *pw ;
   char *style ;
};
#line 37 "/usr/include/bits/types.h"
typedef unsigned long __u_long;
#line 38 "/usr/include/sys/types.h"
typedef __u_long u_long;
#line 63 "auth2.c"
struct Authmethod;
#line 63 "auth2.c"
typedef struct Authmethod Authmethod;
#line 64 "auth2.c"
struct Authmethod {
   char *name ;
   int (*userauth)(Authctxt *authctxt ) ;
   int *enabled ;
};
#line 20 "auth-options.h"
struct envstring {
   struct envstring *next ;
   char *s ;
};
#line 29 "dh.h"
struct dhgroup {
   int size ;
   BIGNUM *g ;
   BIGNUM *p ;
};
#line 28 "/usr/include/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 43 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 53 "loginrec.h"
union login_netinfo {
   struct sockaddr sa ;
   struct sockaddr_in sa_in ;
   struct sockaddr_storage sa_storage ;
};
#line 73 "loginrec.h"
struct logininfo {
   char progname[64] ;
   int progname_null ;
   short type ;
   int pid ;
   int uid ;
   char line[64] ;
   char username[64] ;
   char hostname[256] ;
   int exit ;
   int termination ;
   unsigned int tv_sec ;
   unsigned int tv_usec ;
   union login_netinfo hostaddr ;
};
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 38 "/usr/include/bits/utmp.h"
struct lastlog {
   __time_t ll_time ;
   char ll_line[32] ;
   char ll_host[256] ;
};
#line 52 "/usr/include/bits/utmp.h"
struct exit_status {
   short e_termination ;
   short e_exit ;
};
#line 60 "/usr/include/bits/utmp.h"
struct utmp {
   short ut_type ;
   pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct exit_status ut_exit ;
   long ut_session ;
   struct timeval ut_tv ;
   int32_t ut_addr_v6[4] ;
   char __unused[20] ;
};
#line 198 "servconf.c"
enum __anonenum_ServerOpCodes_78 {
    sBadOption = 0,
    sPort = 1,
    sHostKeyFile = 2,
    sServerKeyBits = 3,
    sLoginGraceTime = 4,
    sKeyRegenerationTime = 5,
    sPermitRootLogin = 6,
    sLogFacility = 7,
    sLogLevel = 8,
    sRhostsAuthentication = 9,
    sRhostsRSAAuthentication = 10,
    sRSAAuthentication = 11,
    sChallengeResponseAuthentication = 12,
    sPasswordAuthentication = 13,
    sKbdInteractiveAuthentication = 14,
    sListenAddress = 15,
    sPrintMotd = 16,
    sIgnoreRhosts = 17,
    sX11Forwarding = 18,
    sX11DisplayOffset = 19,
    sStrictModes = 20,
    sEmptyPasswd = 21,
    sRandomSeedFile = 22,
    sKeepAlives = 23,
    sCheckMail = 24,
    sUseLogin = 25,
    sAllowTcpForwarding = 26,
    sAllowUsers = 27,
    sDenyUsers = 28,
    sAllowGroups = 29,
    sDenyGroups = 30,
    sIgnoreUserKnownHosts = 31,
    sCiphers = 32,
    sMacs = 33,
    sProtocol = 34,
    sPidFile = 35,
    sGatewayPorts = 36,
    sPubkeyAuthentication = 37,
    sXAuthLocation = 38,
    sSubsystem = 39,
    sMaxStartups = 40,
    sBanner = 41,
    sReverseMappingCheck = 42
} ;
#line 198 "servconf.c"
typedef enum __anonenum_ServerOpCodes_78 ServerOpCodes;
#line 221 "servconf.c"
struct __anonstruct_keywords_79 {
   char const   *name ;
   ServerOpCodes opcode ;
};
#line 63 "/usr/include/sys/wait.h"
union wait;
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_terminated_46 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_stopped_47 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_46 __wait_terminated ;
   struct __anonstruct___wait_stopped_47 __wait_stopped ;
};
#line 101 "serverloop.c"
union __anonunion_70 {
   int volatile   __in ;
   int __i ;
};
#line 101 "serverloop.c"
union __anonunion_71 {
   int volatile   __in ;
   int __i ;
};
#line 616 "serverloop.c"
union __anonunion_72 {
   int __in ;
   int __i ;
};
#line 618 "serverloop.c"
union __anonunion_73 {
   int __in ;
   int __i ;
};
#line 614 "serverloop.c"
union __anonunion_74 {
   int __in ;
   int __i ;
};
#line 640 "serverloop.c"
union __anonunion_75 {
   int __in ;
   int __i ;
};
#line 639 "serverloop.c"
union __anonunion_76 {
   int __in ;
   int __i ;
};
#line 95 "session.c"
struct Session;
#line 95 "session.c"
typedef struct Session Session;
#line 96 "session.c"
struct Session {
   int used ;
   int self ;
   int extended ;
   struct passwd *pw ;
   pid_t pid ;
   char *term ;
   int ptyfd ;
   int ttyfd ;
   int ptymaster ;
   int row ;
   int col ;
   int xpixel ;
   int ypixel ;
   char tty[64] ;
   char *display ;
   int screen ;
   char *auth_proto ;
   char *auth_data ;
   int single_connection ;
   int chanid ;
};
#line 1882 "session.c"
union __anonunion_69 {
   int __in ;
   int __i ;
};
#line 1887 "session.c"
union __anonunion_70___0 {
   int __in ;
   int __i ;
};
#line 1889 "session.c"
union __anonunion_71___0 {
   int __in ;
   int __i ;
};
#line 1884 "session.c"
union __anonunion_72___0 {
   int __in ;
   int __i ;
};
#line 1879 "session.c"
union __anonunion_73___0 {
   int __in ;
   int __i ;
};
#line 1 "bsd-arc4random.o"
#pragma merger(0,"./bsd-arc4random.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 59 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 33 "./openbsd-compat/bsd-arc4random.h"
unsigned int arc4random(void) ;
#line 34
void arc4random_stir(void) ;
#line 30 "./entropy.h"
void seed_rng(void) ;
#line 102 "/usr/include/openssl/rand.h"
extern int RAND_bytes(unsigned char *buf , int num ) ;
#line 79 "/usr/include/openssl/rc4.h"
extern void RC4_set_key(RC4_KEY *key , int len , unsigned char const   *data ) ;
#line 80
extern void RC4(RC4_KEY *key , unsigned long len , unsigned char const   *indata ,
                unsigned char *outdata ) ;
#line 40 "openbsd-compat/bsd-arc4random.c"
static int rc4_ready  =    0;
#line 41 "openbsd-compat/bsd-arc4random.c"
static RC4_KEY rc4  ;
#line 43 "openbsd-compat/bsd-arc4random.c"
unsigned int arc4random(void) 
{ unsigned int r ;

  {
#line 45
  r = 0U;
#line 47
  if (rc4_ready <= 0) {
#line 48
    arc4random_stir();
  }
#line 50
  RC4(& rc4, (unsigned long )sizeof(r), (unsigned char const   *)((unsigned char *)(& r)),
      (unsigned char *)(& r));
#line 52
  rc4_ready = (int )((unsigned int )rc4_ready - sizeof(r));
#line 54
  return (r);
}
}
#line 57 "openbsd-compat/bsd-arc4random.c"
void arc4random_stir(void) 
{ unsigned char rand_buf[20] ;

  {
#line 61
  memset((void *)(& rc4), 0, sizeof(rc4));
#line 63
  seed_rng();
#line 65
  RAND_bytes(rand_buf, (int )sizeof(rand_buf));
#line 67
  RC4_set_key(& rc4, (int )sizeof(rand_buf), (unsigned char const   *)(rand_buf));
#line 69
  memset((void *)(rand_buf), 0, sizeof(rand_buf));
#line 71
  rc4_ready = 1 << 24;
#line 72
  return;
}
}
#line 1 "bsd-cygwin_util.o"
#pragma merger(0,"./bsd-cygwin_util.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "bsd-misc.o"
#pragma merger(0,"./bsd-misc.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 828 "/usr/include/unistd.h"
 __attribute__((__nothrow__)) int setlogin(char const   *name )  __attribute__((__nonnull__(1))) ;
#line 32 "./openbsd-compat/bsd-misc.h"
char *get_progname(char *argv0 ) ;
#line 34 "openbsd-compat/bsd-misc.c"
extern char *__progname ;
#line 31 "openbsd-compat/bsd-misc.c"
char *get_progname(char *argv0 ) 
{ 

  {
#line 36
  return (__progname);
}
}
#line 52
 __attribute__((__nothrow__)) int setlogin(char const   *name )  __attribute__((__nonnull__(1))) ;
#line 52 "openbsd-compat/bsd-misc.c"
int setlogin(char const   *name ) 
{ 

  {
#line 54
  return (0);
}
}
#line 1 "bsd-nextstep.o"
#pragma merger(0,"./bsd-nextstep.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "bsd-snprintf.o"
#pragma merger(0,"./bsd-snprintf.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "bsd-waitpid.o"
#pragma merger(0,"./bsd-waitpid.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "vis.o"
#pragma merger(0,"./vis.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 31 "./openbsd-compat/vis.h"
char *vis(char *dst , int c , int flag , int nextc ) ;
#line 47 "openbsd-compat/vis.c"
char *vis(char *dst , int c , int flag , int nextc ) 
{ char *tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  unsigned short const   **tmp___33 ;

  {
#line 49
  if ((unsigned int )c <= 255U) {
#line 49
    if (((int )((unsigned char )c) & -128) == 0) {
#line 49
      tmp___1 = __ctype_b_loc();
#line 49
      if ((int const   )*(*tmp___1 + (int )((unsigned char )c)) & 32768) {
        goto _L___0;
      } else {
        goto _L___5;
      }
    } else {
      goto _L___5;
    }
  } else {
    _L___5: /* CIL Label */ 
#line 49
    if ((flag & 4) == 0) {
#line 49
      if (c == 32) {
        goto _L___0;
      } else {
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
#line 49
      if ((flag & 8) == 0) {
#line 49
        if (c == 9) {
          goto _L___0;
        } else {
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
#line 49
        if ((flag & 16) == 0) {
#line 49
          if (c == 10) {
            goto _L___0;
          } else {
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
#line 49
          if (flag & 32) {
#line 49
            if (c == 8) {
              goto _L___0;
            } else {
#line 49
              if (c == 7) {
                goto _L___0;
              } else {
#line 49
                if (c == 13) {
                  _L___0: /* CIL Label */ 
#line 55
                  tmp = dst;
#line 55
                  dst ++;
#line 55
                  *tmp = (char )c;
#line 56
                  if (c == 92) {
#line 56
                    if ((flag & 64) == 0) {
#line 57
                      tmp___0 = dst;
#line 57
                      dst ++;
#line 57
                      *tmp___0 = (char )'\\';
                    }
                  }
#line 58
                  *dst = (char )'\000';
#line 59
                  return (dst);
                }
              }
            }
          }
        }
      }
    }
  }
#line 62
  if (flag & 2) {
#line 63
    switch (c) {
    case 10: 
#line 65
    tmp___2 = dst;
#line 65
    dst ++;
#line 65
    *tmp___2 = (char )'\\';
#line 66
    tmp___3 = dst;
#line 66
    dst ++;
#line 66
    *tmp___3 = (char )'n';
    goto done;
    case 13: 
#line 69
    tmp___4 = dst;
#line 69
    dst ++;
#line 69
    *tmp___4 = (char )'\\';
#line 70
    tmp___5 = dst;
#line 70
    dst ++;
#line 70
    *tmp___5 = (char )'r';
    goto done;
    case 8: 
#line 73
    tmp___6 = dst;
#line 73
    dst ++;
#line 73
    *tmp___6 = (char )'\\';
#line 74
    tmp___7 = dst;
#line 74
    dst ++;
#line 74
    *tmp___7 = (char )'b';
    goto done;
    case 7: 
#line 81
    tmp___8 = dst;
#line 81
    dst ++;
#line 81
    *tmp___8 = (char )'\\';
#line 82
    tmp___9 = dst;
#line 82
    dst ++;
#line 82
    *tmp___9 = (char )'a';
    goto done;
    case 11: 
#line 85
    tmp___10 = dst;
#line 85
    dst ++;
#line 85
    *tmp___10 = (char )'\\';
#line 86
    tmp___11 = dst;
#line 86
    dst ++;
#line 86
    *tmp___11 = (char )'v';
    goto done;
    case 9: 
#line 89
    tmp___12 = dst;
#line 89
    dst ++;
#line 89
    *tmp___12 = (char )'\\';
#line 90
    tmp___13 = dst;
#line 90
    dst ++;
#line 90
    *tmp___13 = (char )'t';
    goto done;
    case 12: 
#line 93
    tmp___14 = dst;
#line 93
    dst ++;
#line 93
    *tmp___14 = (char )'\\';
#line 94
    tmp___15 = dst;
#line 94
    dst ++;
#line 94
    *tmp___15 = (char )'f';
    goto done;
    case 32: 
#line 97
    tmp___16 = dst;
#line 97
    dst ++;
#line 97
    *tmp___16 = (char )'\\';
#line 98
    tmp___17 = dst;
#line 98
    dst ++;
#line 98
    *tmp___17 = (char )'s';
    goto done;
    case 0: 
#line 101
    tmp___18 = dst;
#line 101
    dst ++;
#line 101
    *tmp___18 = (char )'\\';
#line 102
    tmp___19 = dst;
#line 102
    dst ++;
#line 102
    *tmp___19 = (char )'0';
#line 103
    if ((int )((unsigned char )nextc) >= 48) {
#line 103
      if ((int )((unsigned char )nextc) <= 55) {
#line 104
        tmp___20 = dst;
#line 104
        dst ++;
#line 104
        *tmp___20 = (char )'0';
#line 105
        tmp___21 = dst;
#line 105
        dst ++;
#line 105
        *tmp___21 = (char )'0';
      }
    }
    goto done;
    }
  }
#line 110
  if ((c & 127) == 32) {
    goto _L___6;
  } else {
#line 110
    if (flag & 1) {
      _L___6: /* CIL Label */ 
#line 111
      tmp___22 = dst;
#line 111
      dst ++;
#line 111
      *tmp___22 = (char )'\\';
#line 112
      tmp___23 = dst;
#line 112
      dst ++;
#line 112
      *tmp___23 = (char )((((int )((unsigned char )c) >> 6) & 7) + 48);
#line 113
      tmp___24 = dst;
#line 113
      dst ++;
#line 113
      *tmp___24 = (char )((((int )((unsigned char )c) >> 3) & 7) + 48);
#line 114
      tmp___25 = dst;
#line 114
      dst ++;
#line 114
      *tmp___25 = (char )(((int )((unsigned char )c) & 7) + 48);
      goto done;
    }
  }
#line 117
  if ((flag & 64) == 0) {
#line 118
    tmp___26 = dst;
#line 118
    dst ++;
#line 118
    *tmp___26 = (char )'\\';
  }
#line 119
  if (c & 128) {
#line 120
    c &= 127;
#line 121
    tmp___27 = dst;
#line 121
    dst ++;
#line 121
    *tmp___27 = (char )'M';
  }
#line 123
  tmp___33 = __ctype_b_loc();
#line 123
  if ((int const   )*(*tmp___33 + c) & 2) {
#line 124
    tmp___28 = dst;
#line 124
    dst ++;
#line 124
    *tmp___28 = (char )'^';
#line 125
    if (c == 127) {
#line 126
      tmp___29 = dst;
#line 126
      dst ++;
#line 126
      *tmp___29 = (char )'?';
    } else {
#line 128
      tmp___30 = dst;
#line 128
      dst ++;
#line 128
      *tmp___30 = (char )(c + 64);
    }
  } else {
#line 130
    tmp___31 = dst;
#line 130
    dst ++;
#line 130
    *tmp___31 = (char )'-';
#line 131
    tmp___32 = dst;
#line 131
    dst ++;
#line 131
    *tmp___32 = (char )c;
  }
  done: 
#line 134
  *dst = (char )'\000';
#line 135
  return (dst);
}
}
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
#line 1 "base64.o"
#pragma merger(0,"./base64.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 628 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 10 "openbsd-compat/base64.h"
int b64_ntop(u_char const   *src , size_t srclength , char *target , size_t targsize ) ;
#line 12
int b64_pton(char const   *src , u_char *target , size_t targsize ) ;
#line 65 "openbsd-compat/base64.c"
static char const   Base64[65]  = 
#line 65 "openbsd-compat/base64.c"
  {      (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'g',      (char const   )'h',      (char const   )'i',      (char const   )'j', 
        (char const   )'k',      (char const   )'l',      (char const   )'m',      (char const   )'n', 
        (char const   )'o',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'+',      (char const   )'/', 
        (char const   )'\000'};
#line 67 "openbsd-compat/base64.c"
static char const   Pad64  =    (char const   )'=';
#line 132 "openbsd-compat/base64.c"
int b64_ntop(u_char const   *src , size_t srclength , char *target , size_t targsize ) 
{ size_t datalength ;
  u_char input___0[3] ;
  u_char output___0[4] ;
  int i ;
  u_char const   *tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  u_char const   *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;

  {
#line 135
  datalength = (size_t )0;
#line 140
  while (2U < srclength) {
#line 141
    tmp = src;
#line 141
    src ++;
#line 141
    input___0[0] = (unsigned char )*tmp;
#line 142
    tmp___0 = src;
#line 142
    src ++;
#line 142
    input___0[1] = (unsigned char )*tmp___0;
#line 143
    tmp___1 = src;
#line 143
    src ++;
#line 143
    input___0[2] = (unsigned char )*tmp___1;
#line 144
    srclength -= 3U;
#line 146
    output___0[0] = (unsigned char )((int )input___0[0] >> 2);
#line 147
    output___0[1] = (unsigned char )((((int )input___0[0] & 3) << 4) + ((int )input___0[1] >> 4));
#line 148
    output___0[2] = (unsigned char )((((int )input___0[1] & 15) << 2) + ((int )input___0[2] >> 6));
#line 149
    output___0[3] = (unsigned char )((int )input___0[2] & 63);
#line 150
    if (! ((int )output___0[0] < 64)) {
#line 150
      abort();
    }
#line 151
    if (! ((int )output___0[1] < 64)) {
#line 151
      abort();
    }
#line 152
    if (! ((int )output___0[2] < 64)) {
#line 152
      abort();
    }
#line 153
    if (! ((int )output___0[3] < 64)) {
#line 153
      abort();
    }
#line 155
    if (datalength + 4U > targsize) {
#line 156
      return (-1);
    }
#line 157
    tmp___2 = datalength;
#line 157
    datalength ++;
#line 157
    *(target + tmp___2) = (char )Base64[output___0[0]];
#line 158
    tmp___3 = datalength;
#line 158
    datalength ++;
#line 158
    *(target + tmp___3) = (char )Base64[output___0[1]];
#line 159
    tmp___4 = datalength;
#line 159
    datalength ++;
#line 159
    *(target + tmp___4) = (char )Base64[output___0[2]];
#line 160
    tmp___5 = datalength;
#line 160
    datalength ++;
#line 160
    *(target + tmp___5) = (char )Base64[output___0[3]];
  }
#line 164
  if (0U != srclength) {
#line 166
    input___0[2] = (unsigned char )'\000';
#line 166
    input___0[1] = input___0[2];
#line 166
    input___0[0] = input___0[1];
#line 167
    i = 0;
#line 167
    while ((size_t )i < srclength) {
#line 168
      tmp___6 = src;
#line 168
      src ++;
#line 168
      input___0[i] = (unsigned char )*tmp___6;
#line 167
      i ++;
    }
#line 170
    output___0[0] = (unsigned char )((int )input___0[0] >> 2);
#line 171
    output___0[1] = (unsigned char )((((int )input___0[0] & 3) << 4) + ((int )input___0[1] >> 4));
#line 172
    output___0[2] = (unsigned char )((((int )input___0[1] & 15) << 2) + ((int )input___0[2] >> 6));
#line 173
    if (! ((int )output___0[0] < 64)) {
#line 173
      abort();
    }
#line 174
    if (! ((int )output___0[1] < 64)) {
#line 174
      abort();
    }
#line 175
    if (! ((int )output___0[2] < 64)) {
#line 175
      abort();
    }
#line 177
    if (datalength + 4U > targsize) {
#line 178
      return (-1);
    }
#line 179
    tmp___7 = datalength;
#line 179
    datalength ++;
#line 179
    *(target + tmp___7) = (char )Base64[output___0[0]];
#line 180
    tmp___8 = datalength;
#line 180
    datalength ++;
#line 180
    *(target + tmp___8) = (char )Base64[output___0[1]];
#line 181
    if (srclength == 1U) {
#line 182
      tmp___9 = datalength;
#line 182
      datalength ++;
#line 182
      *(target + tmp___9) = (char )Pad64;
    } else {
#line 184
      tmp___10 = datalength;
#line 184
      datalength ++;
#line 184
      *(target + tmp___10) = (char )Base64[output___0[2]];
    }
#line 185
    tmp___11 = datalength;
#line 185
    datalength ++;
#line 185
    *(target + tmp___11) = (char )Pad64;
  }
#line 187
  if (datalength >= targsize) {
#line 188
    return (-1);
  }
#line 189
  *(target + datalength) = (char )'\000';
#line 190
  return ((int )datalength);
}
}
#line 199 "openbsd-compat/base64.c"
int b64_pton(char const   *src , u_char *target , size_t targsize ) 
{ int tarindex ;
  int state ;
  int ch ;
  char *pos ;
  unsigned short const   **tmp ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  unsigned short const   **tmp___8 ;

  {
#line 205
  state = 0;
#line 206
  tarindex = 0;
#line 208
  while (1) {
#line 208
    tmp___2 = src;
#line 208
    src ++;
#line 208
    ch = (int )*tmp___2;
#line 208
    if (! (ch != 0)) {
#line 208
      break;
    }
#line 209
    tmp = __ctype_b_loc();
#line 209
    if ((int const   )*(*tmp + ch) & 8192) {
#line 210
      continue;
    }
#line 212
    if (ch == (int )Pad64) {
#line 213
      break;
    }
#line 215
    tmp___1 = __builtin_strchr((char *)(Base64), ch);
#line 215
    pos = tmp___1;
#line 216
    if ((unsigned int )pos == (unsigned int )((char *)0)) {
#line 217
      return (-1);
    }
#line 219
    switch (state) {
    case 0: 
#line 221
    if (target) {
#line 222
      if ((size_t )tarindex >= targsize) {
#line 223
        return (-1);
      }
#line 224
      *(target + tarindex) = (unsigned char )((pos - (char *)(Base64)) << 2);
    }
#line 226
    state = 1;
#line 227
    break;
    case 1: 
#line 229
    if (target) {
#line 230
      if ((size_t )(tarindex + 1) >= targsize) {
#line 231
        return (-1);
      }
#line 232
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | ((pos - (char *)(Base64)) >> 4));
#line 233
      *(target + (tarindex + 1)) = (unsigned char )(((pos - (char *)(Base64)) & 15) << 4);
    }
#line 236
    tarindex ++;
#line 237
    state = 2;
#line 238
    break;
    case 2: 
#line 240
    if (target) {
#line 241
      if ((size_t )(tarindex + 1) >= targsize) {
#line 242
        return (-1);
      }
#line 243
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | ((pos - (char *)(Base64)) >> 2));
#line 244
      *(target + (tarindex + 1)) = (unsigned char )(((pos - (char *)(Base64)) & 3) << 6);
    }
#line 247
    tarindex ++;
#line 248
    state = 3;
#line 249
    break;
    case 3: 
#line 251
    if (target) {
#line 252
      if ((size_t )tarindex >= targsize) {
#line 253
        return (-1);
      }
#line 254
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | (pos - (char *)(Base64)));
    }
#line 256
    tarindex ++;
#line 257
    state = 0;
#line 258
    break;
    }
  }
#line 267
  if (ch == (int )Pad64) {
#line 268
    tmp___3 = src;
#line 268
    src ++;
#line 268
    ch = (int )*tmp___3;
#line 269
    switch (state) {
    case 0: 
    case 1: 
#line 272
    return (-1);
    case 2: 
#line 276
    while (ch != 0) {
#line 277
      tmp___5 = __ctype_b_loc();
#line 277
      if (! ((int const   )*(*tmp___5 + ch) & 8192)) {
#line 278
        break;
      }
#line 276
      tmp___4 = src;
#line 276
      src ++;
#line 276
      ch = (int )*tmp___4;
    }
#line 280
    if (ch != (int )Pad64) {
#line 281
      return (-1);
    }
#line 282
    tmp___6 = src;
#line 282
    src ++;
#line 282
    ch = (int )*tmp___6;
    case 3: 
#line 291
    while (ch != 0) {
#line 292
      tmp___8 = __ctype_b_loc();
#line 292
      if (! ((int const   )*(*tmp___8 + ch) & 8192)) {
#line 293
        return (-1);
      }
#line 291
      tmp___7 = src;
#line 291
      src ++;
#line 291
      ch = (int )*tmp___7;
    }
#line 301
    if (target) {
#line 301
      if ((int )*(target + tarindex) != 0) {
#line 302
        return (-1);
      }
    }
    }
  } else {
#line 309
    if (state != 0) {
#line 310
      return (-1);
    }
  }
#line 313
  return (tarindex);
}
}
#line 1 "bindresvport.o"
#pragma merger(0,"./bindresvport.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 110 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  *__addr ,
                                              socklen_t __len ) ;
#line 114
extern  __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 9 "./openbsd-compat/bindresvport.h"
int bindresvport_sa(int sd , struct sockaddr *sa ) ;
#line 55 "openbsd-compat/bindresvport.c"
int bindresvport_sa(int sd , struct sockaddr *sa ) 
{ int error___0 ;
  int af ;
  struct sockaddr_storage myaddr ;
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;
  u_int16_t *portp ;
  u_int16_t port ;
  socklen_t salen ;
  int i ;
  int tmp ;
  int *tmp___0 ;
  register unsigned short __v ;
  register unsigned short __x ;
  unsigned int tmp___1 ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 69
  if ((unsigned int )sa == (unsigned int )((void *)0)) {
#line 70
    memset((void *)(& myaddr), 0, sizeof(myaddr));
#line 71
    sa = (struct sockaddr *)(& myaddr);
#line 73
    tmp = getsockname(sd, (struct sockaddr * __restrict  )sa, (socklen_t * __restrict  )(& salen));
#line 73
    if (tmp == -1) {
#line 74
      return (-1);
    }
#line 76
    af = (int )sa->sa_family;
#line 77
    memset((void *)(& myaddr), 0, salen);
  } else {
#line 79
    af = (int )sa->sa_family;
  }
#line 81
  if (af == 2) {
#line 82
    sin = (struct sockaddr_in *)sa;
#line 83
    salen = sizeof(struct sockaddr_in );
#line 84
    portp = & sin->sin_port;
  } else {
#line 85
    if (af == 10) {
#line 86
      sin6 = (struct sockaddr_in6 *)sa;
#line 87
      salen = sizeof(struct sockaddr_in6 );
#line 88
      portp = & sin6->sin6_port;
    } else {
#line 90
      tmp___0 = __errno_location();
#line 90
      *tmp___0 = 96;
#line 91
      return (-1);
    }
  }
#line 93
  sa->sa_family = (unsigned short )af;
#line 95
  __x = *portp;
#line 95
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 95
  port = __v;
#line 96
  if ((int )port == 0) {
#line 97
    tmp___1 = arc4random();
#line 97
    port = (unsigned short )(tmp___1 % 424U + 600U);
  }
#line 100
  error___0 = -1;
#line 102
  i = 0;
#line 102
  while (i < 424) {
#line 103
    __x___0 = port;
#line 103
    __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 103
    *portp = __v___0;
#line 105
    error___0 = bind(sd, (struct sockaddr  const  *)sa, salen);
#line 108
    if (error___0 == 0) {
#line 109
      break;
    }
#line 112
    if (error___0 < 0) {
#line 112
      tmp___2 = __errno_location();
#line 112
      if (! (*tmp___2 == 98)) {
#line 112
        tmp___3 = __errno_location();
#line 112
        if (! (*tmp___3 == 22)) {
#line 113
          break;
        }
      }
    }
#line 115
    port = (u_int16_t )((int )port + 1);
#line 116
    if ((int )port > 1023) {
#line 117
      port = (unsigned short)600;
    }
#line 102
    i ++;
  }
#line 120
  return (error___0);
}
}
#line 1 "daemon.o"
#pragma merger(0,"./daemon.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "getcwd.o"
#pragma merger(0,"./getcwd.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "getgrouplist.o"
#pragma merger(0,"./getgrouplist.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "inet_aton.o"
#pragma merger(0,"./inet_aton.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "inet_ntoa.o"
#pragma merger(0,"./inet_ntoa.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "mktemp.o"
#pragma merger(0,"./mktemp.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "realpath.o"
#pragma merger(0,"./realpath.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "rresvport.o"
#pragma merger(0,"./rresvport.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "setenv.o"
#pragma merger(0,"./setenv.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "setproctitle.o"
#pragma merger(0,"./setproctitle.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 9 "./openbsd-compat/setproctitle.h"
void setproctitle(char const   *fmt  , ...) ;
#line 71 "openbsd-compat/setproctitle.c"
void setproctitle(char const   *fmt  , ...) 
{ 

  {
#line 101
  return;
}
}
#line 1 "sigact.o"
#pragma merger(0,"./sigact.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "strlcat.o"
#pragma merger(0,"./strlcat.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 242 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 46 "openbsd-compat/strlcat.c"
size_t strlcat(char *dst , char const   *src , size_t siz ) 
{ register char *d ;
  register char const   *s ;
  register size_t n___0 ;
  size_t dlen ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 51
  d = dst;
#line 52
  s = src;
#line 53
  n___0 = siz;
#line 57
  while (1) {
#line 57
    if ((int )*d != 0) {
#line 57
      tmp = n___0;
#line 57
      n___0 --;
#line 57
      if (! (tmp != 0U)) {
#line 57
        break;
      }
    } else {
#line 57
      break;
    }
#line 58
    d ++;
  }
#line 59
  dlen = (unsigned int )(d - dst);
#line 60
  n___0 = siz - dlen;
#line 62
  if (n___0 == 0U) {
#line 63
    tmp___0 = strlen(s);
#line 63
    return (dlen + tmp___0);
  }
#line 64
  while ((int const   )*s != 0) {
#line 65
    if (n___0 != 1U) {
#line 66
      tmp___1 = d;
#line 66
      d ++;
#line 66
      *tmp___1 = (char )*s;
#line 67
      n___0 --;
    }
#line 69
    s ++;
  }
#line 71
  *d = (char )'\000';
#line 73
  return (dlen + (size_t )(s - src));
}
}
#line 1 "strlcpy.o"
#pragma merger(0,"./strlcpy.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 45 "openbsd-compat/strlcpy.c"
size_t strlcpy(char *dst , char const   *src , size_t siz ) 
{ register char *d ;
  register char const   *s ;
  register size_t n___0 ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 50
  d = dst;
#line 51
  s = src;
#line 52
  n___0 = siz;
#line 55
  if (n___0 != 0U) {
#line 55
    n___0 --;
#line 55
    if (n___0 != 0U) {
#line 56
      while (1) {
#line 57
        tmp = d;
#line 57
        d ++;
#line 57
        tmp___0 = s;
#line 57
        s ++;
#line 57
        *tmp = (char )*tmp___0;
#line 57
        if ((int )*tmp == 0) {
#line 58
          break;
        }
#line 56
        n___0 --;
#line 56
        if (! (n___0 != 0U)) {
#line 56
          break;
        }
      }
    }
  }
#line 63
  if (n___0 == 0U) {
#line 64
    if (siz != 0U) {
#line 65
      *d = (char )'\000';
    }
#line 66
    while (1) {
#line 66
      tmp___1 = s;
#line 66
      s ++;
#line 66
      if (! *tmp___1) {
#line 66
        break;
      }
    }
  }
#line 70
  return ((unsigned int )((s - src) - 1));
}
}
#line 1 "strmode.o"
#pragma merger(0,"./strmode.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 5 "./openbsd-compat/strmode.h"
void strmode(mode_t mode , char *p ) ;
#line 45 "openbsd-compat/strmode.c"
void strmode(mode_t mode , char *p ) 
{ char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;

  {
#line 51
  switch ((int )(mode & 61440U)) {
  case 16384: 
#line 53
  tmp = p;
#line 53
  p ++;
#line 53
  *tmp = (char )'d';
#line 54
  break;
  case 8192: 
#line 56
  tmp___0 = p;
#line 56
  p ++;
#line 56
  *tmp___0 = (char )'c';
#line 57
  break;
  case 24576: 
#line 59
  tmp___1 = p;
#line 59
  p ++;
#line 59
  *tmp___1 = (char )'b';
#line 60
  break;
  case 32768: 
#line 62
  tmp___2 = p;
#line 62
  p ++;
#line 62
  *tmp___2 = (char )'-';
#line 63
  break;
  case 40960: 
#line 65
  tmp___3 = p;
#line 65
  p ++;
#line 65
  *tmp___3 = (char )'l';
#line 66
  break;
  case 49152: 
#line 69
  tmp___4 = p;
#line 69
  p ++;
#line 69
  *tmp___4 = (char )'s';
#line 70
  break;
  case 4096: 
#line 74
  tmp___5 = p;
#line 74
  p ++;
#line 74
  *tmp___5 = (char )'p';
#line 75
  break;
  default: 
#line 83
  tmp___6 = p;
#line 83
  p ++;
#line 83
  *tmp___6 = (char )'?';
#line 84
  break;
  }
#line 87
  if (mode & 256U) {
#line 88
    tmp___7 = p;
#line 88
    p ++;
#line 88
    *tmp___7 = (char )'r';
  } else {
#line 90
    tmp___8 = p;
#line 90
    p ++;
#line 90
    *tmp___8 = (char )'-';
  }
#line 91
  if (mode & 128U) {
#line 92
    tmp___9 = p;
#line 92
    p ++;
#line 92
    *tmp___9 = (char )'w';
  } else {
#line 94
    tmp___10 = p;
#line 94
    p ++;
#line 94
    *tmp___10 = (char )'-';
  }
#line 95
  switch ((int )(mode & 2112U)) {
  case 0: 
#line 97
  tmp___11 = p;
#line 97
  p ++;
#line 97
  *tmp___11 = (char )'-';
#line 98
  break;
  case 64: 
#line 100
  tmp___12 = p;
#line 100
  p ++;
#line 100
  *tmp___12 = (char )'x';
#line 101
  break;
  case 2048: 
#line 103
  tmp___13 = p;
#line 103
  p ++;
#line 103
  *tmp___13 = (char )'S';
#line 104
  break;
  case 2112: 
#line 106
  tmp___14 = p;
#line 106
  p ++;
#line 106
  *tmp___14 = (char )'s';
#line 107
  break;
  }
#line 110
  if (mode & (unsigned int )(256 >> 3)) {
#line 111
    tmp___15 = p;
#line 111
    p ++;
#line 111
    *tmp___15 = (char )'r';
  } else {
#line 113
    tmp___16 = p;
#line 113
    p ++;
#line 113
    *tmp___16 = (char )'-';
  }
#line 114
  if (mode & (unsigned int )(128 >> 3)) {
#line 115
    tmp___17 = p;
#line 115
    p ++;
#line 115
    *tmp___17 = (char )'w';
  } else {
#line 117
    tmp___18 = p;
#line 117
    p ++;
#line 117
    *tmp___18 = (char )'-';
  }
#line 118
  switch ((int )(mode & (unsigned int )((64 >> 3) | 1024))) {
  case 0: 
#line 120
  tmp___19 = p;
#line 120
  p ++;
#line 120
  *tmp___19 = (char )'-';
#line 121
  break;
  case 64 >> 3: 
#line 123
  tmp___20 = p;
#line 123
  p ++;
#line 123
  *tmp___20 = (char )'x';
#line 124
  break;
  case 1024: 
#line 126
  tmp___21 = p;
#line 126
  p ++;
#line 126
  *tmp___21 = (char )'S';
#line 127
  break;
  case (64 >> 3) | 1024: 
#line 129
  tmp___22 = p;
#line 129
  p ++;
#line 129
  *tmp___22 = (char )'s';
#line 130
  break;
  }
#line 133
  if (mode & (unsigned int )((256 >> 3) >> 3)) {
#line 134
    tmp___23 = p;
#line 134
    p ++;
#line 134
    *tmp___23 = (char )'r';
  } else {
#line 136
    tmp___24 = p;
#line 136
    p ++;
#line 136
    *tmp___24 = (char )'-';
  }
#line 137
  if (mode & (unsigned int )((128 >> 3) >> 3)) {
#line 138
    tmp___25 = p;
#line 138
    p ++;
#line 138
    *tmp___25 = (char )'w';
  } else {
#line 140
    tmp___26 = p;
#line 140
    p ++;
#line 140
    *tmp___26 = (char )'-';
  }
#line 141
  switch ((int )(mode & (unsigned int )(((64 >> 3) >> 3) | 512))) {
  case 0: 
#line 143
  tmp___27 = p;
#line 143
  p ++;
#line 143
  *tmp___27 = (char )'-';
#line 144
  break;
  case (64 >> 3) >> 3: 
#line 146
  tmp___28 = p;
#line 146
  p ++;
#line 146
  *tmp___28 = (char )'x';
#line 147
  break;
  case 512: 
#line 149
  tmp___29 = p;
#line 149
  p ++;
#line 149
  *tmp___29 = (char )'T';
#line 150
  break;
  case ((64 >> 3) >> 3) | 512: 
#line 152
  tmp___30 = p;
#line 152
  p ++;
#line 152
  *tmp___30 = (char )'t';
#line 153
  break;
  }
#line 155
  tmp___31 = p;
#line 155
  p ++;
#line 155
  *tmp___31 = (char )' ';
#line 156
  *p = (char )'\000';
#line 157
  return;
}
}
#line 1 "strsep.o"
#pragma merger(0,"./strsep.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "atomicio.o"
#pragma merger(0,"./atomicio.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 31 "atomicio.h"
ssize_t atomicio(ssize_t (*f)() , int fd , void *_s , size_t n___0 ) ;
#line 35 "atomicio.c"
ssize_t atomicio(ssize_t (*f)() , int fd , void *_s , size_t n___0 ) 
{ char *s ;
  ssize_t res ;
  ssize_t pos ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 42
  s = (char *)_s;
#line 43
  pos = 0;
#line 45
  while (n___0 > (size_t )pos) {
#line 46
    res = (*f)(fd, s + pos, n___0 - (size_t )pos);
#line 47
    switch (res) {
    case -1: 
#line 50
    tmp = __errno_location();
#line 50
    if (*tmp == 4) {
#line 54
      continue;
    } else {
#line 50
      tmp___0 = __errno_location();
#line 50
      if (*tmp___0 == 11) {
#line 54
        continue;
      } else {
#line 50
        tmp___1 = __errno_location();
#line 50
        if (*tmp___1 == 11) {
#line 54
          continue;
        }
      }
    }
    case 0: 
#line 56
    return (res);
    default: 
#line 58
    pos += res;
    }
  }
#line 61
  return (pos);
}
}
#line 1 "authfd.o"
#pragma merger(0,"./authfd.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 100 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 124
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 320 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 327
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 333
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 76 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 660 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 405 "/usr/include/openssl/bn.h"
extern int BN_num_bits(BIGNUM const   *a ) ;
#line 26 "buffer.h"
void buffer_init(Buffer *buffer ) ;
#line 29
void buffer_free(Buffer *buffer ) ;
#line 33
void buffer_clear(Buffer *buffer ) ;
#line 36
void buffer_append(Buffer *buffer , char const   *data , u_int len ) ;
#line 46
u_int buffer_len(Buffer *buffer ) ;
#line 58
char *buffer_ptr(Buffer *buffer ) ;
#line 25 "bufaux.h"
void buffer_put_bignum(Buffer *buffer , BIGNUM *value ) ;
#line 26
void buffer_put_bignum2(Buffer *buffer , BIGNUM *value ) ;
#line 29
int buffer_get_bignum(Buffer *buffer , BIGNUM *value ) ;
#line 33
u_int buffer_get_int(Buffer *buffer ) ;
#line 39
void buffer_put_int(Buffer *buffer , u_int value ) ;
#line 45
int buffer_get_char(Buffer *buffer ) ;
#line 48
void buffer_put_char(Buffer *buffer , int value ) ;
#line 58
char *buffer_get_string(Buffer *buffer , u_int *length_ptr ) ;
#line 61
void buffer_put_string(Buffer *buffer , void const   *buf___2 , u_int len ) ;
#line 62
void buffer_put_cstring(Buffer *buffer , char const   *s ) ;
#line 23 "xmalloc.h"
void *xmalloc(size_t size ) ;
#line 29
void xfree(void *ptr ) ;
#line 45 "key.h"
Key *key_new(int type ) ;
#line 59
Key *key_from_blob(char *blob , int blen ) ;
#line 60
int key_to_blob(Key *key , u_char **blobp , u_int *lenp ) ;
#line 61
char *key_ssh_name(Key *k ) ;
#line 54 "authfd.h"
int ssh_get_authentication_socket(void) ;
#line 61
void ssh_close_authentication_socket(int sock ) ;
#line 69
AuthenticationConnection *ssh_get_authentication_connection(void) ;
#line 75
void ssh_close_authentication_connection(AuthenticationConnection *auth ) ;
#line 80
int ssh_get_num_identities(AuthenticationConnection *auth , int version ) ;
#line 87
Key *ssh_get_first_identity(AuthenticationConnection *auth , char **comment , int version ) ;
#line 95
Key *ssh_get_next_identity(AuthenticationConnection *auth , char **comment , int version ) ;
#line 101
int ssh_decrypt_challenge(AuthenticationConnection *auth , Key *key , BIGNUM *challenge ,
                          u_char *session_id___0 , u_int response_type , u_char *response ) ;
#line 109
int ssh_agent_sign(AuthenticationConnection *auth , Key *key , u_char **sigp , int *lenp ,
                   u_char *data , int datalen ) ;
#line 120
int ssh_add_identity(AuthenticationConnection *auth , Key *key , char const   *comment ) ;
#line 129
int ssh_remove_identity(AuthenticationConnection *auth , Key *key ) ;
#line 136
int ssh_remove_all_identities(AuthenticationConnection *auth , int version ) ;
#line 50 "compat.h"
int datafellows ;
#line 57 "log.h"
void ( /* format attribute */  fatal)(char const   *fmt  , ...) ;
#line 58
void ( /* format attribute */  error)(char const   *fmt  , ...) ;
#line 59
void ( /* format attribute */  log)(char const   *fmt  , ...) ;
#line 57 "authfd.c"
int decode_reply(int type ) ;
#line 65 "authfd.c"
int ssh_get_authentication_socket(void) 
{ char const   *authsocket ;
  int sock ;
  int len ;
  struct sockaddr_un sunaddr ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 72
  tmp = getenv("SSH_AUTH_SOCK");
#line 72
  authsocket = (char const   *)tmp;
#line 73
  if (! authsocket) {
#line 74
    return (-1);
  }
#line 76
  sunaddr.sun_family = (unsigned short)1;
#line 77
  strlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));
#line 81
  tmp___0 = strlen((char const   *)(sunaddr.sun_path));
#line 81
  len = (int )(((unsigned int )(((struct sockaddr_un *)0)->sun_path) + tmp___0) + 1U);
#line 84
  sock = socket(1, 1, 0);
#line 85
  if (sock < 0) {
#line 86
    return (-1);
  }
#line 89
  tmp___1 = fcntl(sock, 2, 1);
#line 89
  if (tmp___1 == -1) {
#line 90
    close(sock);
#line 91
    return (-1);
  }
#line 93
  tmp___2 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sunaddr)),
                    (unsigned int )len);
#line 93
  if (tmp___2 < 0) {
#line 94
    close(sock);
#line 95
    return (-1);
  }
#line 97
  return (sock);
}
}
#line 100 "authfd.c"
int ssh_request_reply(AuthenticationConnection *auth , Buffer *request , Buffer *reply ) 
{ int l ;
  int len ;
  char buf___2[1024] ;
  u_int tmp ;
  ssize_t tmp___0 ;
  u_int tmp___1 ;
  char *tmp___2 ;
  ssize_t tmp___3 ;
  u_int tmp___4 ;

  {
#line 107
  tmp = buffer_len(request);
#line 107
  len = (int )tmp;
#line 108
  while (1) {
#line 108
    buf___2[0] = (char )(len >> 24);
#line 108
    buf___2[1] = (char )(len >> 16);
#line 108
    buf___2[2] = (char )(len >> 8);
#line 108
    buf___2[3] = (char )len;
#line 108
    break;
  }
#line 111
  tmp___0 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)(buf___2), 4U);
#line 111
  if (tmp___0 != 4) {
#line 114
    error("Error writing to authentication socket.");
#line 115
    return (0);
  } else {
#line 111
    tmp___1 = buffer_len(request);
#line 111
    tmp___2 = buffer_ptr(request);
#line 111
    tmp___3 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)tmp___2, tmp___1);
#line 111
    tmp___4 = buffer_len(request);
#line 111
    if ((u_int )tmp___3 != tmp___4) {
#line 114
      error("Error writing to authentication socket.");
#line 115
      return (0);
    }
  }
#line 121
  len = 4;
#line 122
  while (len > 0) {
#line 123
    l = read(auth->fd, (void *)((buf___2 + 4) - len), (unsigned int )len);
#line 124
    if (l <= 0) {
#line 125
      error("Error reading response length from authentication socket.");
#line 126
      return (0);
    }
#line 128
    len -= l;
  }
#line 132
  len = (int )(((((unsigned long )((unsigned char )buf___2[0]) << 24) | ((unsigned long )((unsigned char )buf___2[1]) << 16)) | ((unsigned long )((unsigned char )buf___2[2]) << 8)) | (unsigned long )((unsigned char )buf___2[3]));
#line 133
  if (len > 262144) {
#line 134
    fatal("Authentication response too long: %d", len);
  }
#line 137
  buffer_clear(reply);
#line 138
  while (len > 0) {
#line 139
    l = len;
#line 140
    if ((unsigned int )l > sizeof(buf___2)) {
#line 141
      l = (int )sizeof(buf___2);
    }
#line 142
    l = read(auth->fd, (void *)(buf___2), (unsigned int )l);
#line 143
    if (l <= 0) {
#line 144
      error("Error reading response from authentication socket.");
#line 145
      return (0);
    }
#line 147
    buffer_append(reply, (char const   *)(buf___2), (unsigned int )l);
#line 148
    len -= l;
  }
#line 150
  return (1);
}
}
#line 159 "authfd.c"
void ssh_close_authentication_socket(int sock ) 
{ char *tmp ;

  {
#line 162
  tmp = getenv("SSH_AUTH_SOCK");
#line 162
  if (tmp) {
#line 163
    close(sock);
  }
#line 164
  return;
}
}
#line 174 "authfd.c"
AuthenticationConnection *ssh_get_authentication_connection(void) 
{ AuthenticationConnection *auth ;
  int sock ;
  void *tmp ;

  {
#line 180
  sock = ssh_get_authentication_socket();
#line 186
  if (sock < 0) {
#line 187
    return ((AuthenticationConnection *)((void *)0));
  }
#line 189
  tmp = xmalloc(sizeof(*auth));
#line 189
  auth = (AuthenticationConnection *)tmp;
#line 190
  auth->fd = sock;
#line 191
  buffer_init(& auth->identities);
#line 192
  auth->howmany = 0;
#line 194
  return (auth);
}
}
#line 202 "authfd.c"
void ssh_close_authentication_connection(AuthenticationConnection *auth ) 
{ 

  {
#line 205
  buffer_free(& auth->identities);
#line 206
  close(auth->fd);
#line 207
  xfree((void *)auth);
#line 208
  return;
}
}
#line 214 "authfd.c"
int ssh_get_num_identities(AuthenticationConnection *auth , int version ) 
{ int type ;
  int code1 ;
  int code2 ;
  Buffer request ;
  int tmp ;
  u_int tmp___0 ;

  {
#line 217
  code1 = 0;
#line 217
  code2 = 0;
#line 220
  switch (version) {
  case 1: 
#line 222
  code1 = 1;
#line 223
  code2 = 2;
#line 224
  break;
  case 2: 
#line 226
  code1 = 11;
#line 227
  code2 = 12;
#line 228
  break;
  default: ;
#line 230
  return (0);
  }
#line 237
  buffer_init(& request);
#line 238
  buffer_put_char(& request, code1);
#line 240
  buffer_clear(& auth->identities);
#line 241
  tmp = ssh_request_reply(auth, & request, & auth->identities);
#line 241
  if (tmp == 0) {
#line 242
    buffer_free(& request);
#line 243
    return (0);
  }
#line 245
  buffer_free(& request);
#line 248
  type = buffer_get_char(& auth->identities);
#line 249
  if (type == 5) {
#line 250
    return (0);
  } else {
#line 249
    if (type == 102) {
#line 250
      return (0);
    } else {
#line 251
      if (type != code2) {
#line 252
        fatal("Bad authentication reply message type: %d", type);
      }
    }
  }
#line 256
  tmp___0 = buffer_get_int(& auth->identities);
#line 256
  auth->howmany = (int )tmp___0;
#line 257
  if (auth->howmany > 1024) {
#line 258
    fatal("Too many identities in authentication reply: %d\n", auth->howmany);
  }
#line 261
  return (auth->howmany);
}
}
#line 264 "authfd.c"
Key *ssh_get_first_identity(AuthenticationConnection *auth , char **comment , int version ) 
{ Key *tmp ;
  int tmp___0 ;

  {
#line 268
  tmp___0 = ssh_get_num_identities(auth, version);
#line 268
  if (tmp___0 > 0) {
#line 269
    tmp = ssh_get_next_identity(auth, comment, version);
#line 269
    return (tmp);
  }
#line 270
  return ((Key *)((void *)0));
}
}
#line 273 "authfd.c"
Key *ssh_get_next_identity(AuthenticationConnection *auth , char **comment , int version ) 
{ u_int bits ;
  u_char *blob ;
  u_int blen ;
  Key *key ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 279
  key = (Key *)((void *)0);
#line 282
  if (auth->howmany <= 0) {
#line 283
    return ((Key *)((void *)0));
  }
#line 289
  switch (version) {
  case 1: 
#line 291
  key = key_new(0);
#line 292
  bits = buffer_get_int(& auth->identities);
#line 293
  buffer_get_bignum(& auth->identities, (key->rsa)->e);
#line 294
  buffer_get_bignum(& auth->identities, (key->rsa)->n);
#line 295
  *comment = buffer_get_string(& auth->identities, (u_int *)((void *)0));
#line 296
  tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 296
  if (bits != (u_int )tmp___0) {
#line 297
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 297
    log("Warning: identity keysize mismatch: actual %d, announced %u", tmp, bits);
  }
#line 299
  break;
  case 2: 
#line 301
  tmp___1 = buffer_get_string(& auth->identities, & blen);
#line 301
  blob = (u_char *)tmp___1;
#line 302
  *comment = buffer_get_string(& auth->identities, (u_int *)((void *)0));
#line 303
  key = key_from_blob((char *)blob, (int )blen);
#line 304
  xfree((void *)blob);
#line 305
  break;
  default: ;
#line 307
  return ((Key *)((void *)0));
#line 308
  break;
  }
#line 311
  (auth->howmany) --;
#line 312
  return (key);
}
}
#line 323 "authfd.c"
int ssh_decrypt_challenge(AuthenticationConnection *auth , Key *key , BIGNUM *challenge ,
                          u_char *session_id___0 , u_int response_type , u_char *response ) 
{ Buffer buffer ;
  int success ;
  int i ;
  int type ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 331
  success = 0;
#line 335
  if (key->type != 0) {
#line 336
    return (0);
  }
#line 337
  if (response_type == 0U) {
#line 338
    log("Compatibility with ssh protocol version 1.0 no longer supported.");
#line 339
    return (0);
  }
#line 341
  buffer_init(& buffer);
#line 342
  buffer_put_char(& buffer, 3);
#line 343
  tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 343
  buffer_put_int(& buffer, (unsigned int )tmp);
#line 344
  buffer_put_bignum(& buffer, (key->rsa)->e);
#line 345
  buffer_put_bignum(& buffer, (key->rsa)->n);
#line 346
  buffer_put_bignum(& buffer, challenge);
#line 347
  buffer_append(& buffer, (char const   *)((char *)session_id___0), 16U);
#line 348
  buffer_put_int(& buffer, response_type);
#line 350
  tmp___0 = ssh_request_reply(auth, & buffer, & buffer);
#line 350
  if (tmp___0 == 0) {
#line 351
    buffer_free(& buffer);
#line 352
    return (0);
  }
#line 354
  type = buffer_get_char(& buffer);
#line 356
  if (type == 5) {
#line 357
    log("Agent admitted failure to authenticate using the key.");
  } else {
#line 356
    if (type == 102) {
#line 357
      log("Agent admitted failure to authenticate using the key.");
    } else {
#line 358
      if (type != 4) {
#line 359
        fatal("Bad authentication response: %d", type);
      } else {
#line 361
        success = 1;
#line 366
        i = 0;
#line 366
        while (i < 16) {
#line 367
          tmp___1 = buffer_get_char(& buffer);
#line 367
          *(response + i) = (unsigned char )tmp___1;
#line 366
          i ++;
        }
      }
    }
  }
#line 369
  buffer_free(& buffer);
#line 370
  return (success);
}
}
#line 374 "authfd.c"
int ssh_agent_sign(AuthenticationConnection *auth , Key *key , u_char **sigp , int *lenp ,
                   u_char *data , int datalen ) 
{ Buffer msg ;
  u_char *blob ;
  u_int blen ;
  int type ;
  int flags ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 384
  flags = 0;
#line 385
  ret = -1;
#line 387
  tmp = key_to_blob(key, & blob, & blen);
#line 387
  if (tmp == 0) {
#line 388
    return (-1);
  }
#line 390
  if (datafellows & 1) {
#line 391
    flags = 1;
  }
#line 393
  buffer_init(& msg);
#line 394
  buffer_put_char(& msg, 13);
#line 395
  buffer_put_string(& msg, (void const   *)blob, blen);
#line 396
  buffer_put_string(& msg, (void const   *)data, (unsigned int )datalen);
#line 397
  buffer_put_int(& msg, (unsigned int )flags);
#line 398
  xfree((void *)blob);
#line 400
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 400
  if (tmp___0 == 0) {
#line 401
    buffer_free(& msg);
#line 402
    return (-1);
  }
#line 404
  type = buffer_get_char(& msg);
#line 405
  if (type == 5) {
#line 406
    log("Agent admitted failure to sign using the key.");
  } else {
#line 405
    if (type == 102) {
#line 406
      log("Agent admitted failure to sign using the key.");
    } else {
#line 407
      if (type != 14) {
#line 408
        fatal("Bad authentication response: %d", type);
      } else {
#line 410
        ret = 0;
#line 411
        tmp___1 = buffer_get_string(& msg, (u_int *)lenp);
#line 411
        *sigp = (u_char *)tmp___1;
      }
    }
  }
#line 413
  buffer_free(& msg);
#line 414
  return (ret);
}
}
#line 419 "authfd.c"
void ssh_encode_identity_rsa1(Buffer *b , RSA *key , char const   *comment ) 
{ int tmp ;
  size_t tmp___0 ;

  {
#line 422
  buffer_clear(b);
#line 423
  buffer_put_char(b, 7);
#line 424
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 424
  buffer_put_int(b, (unsigned int )tmp);
#line 425
  buffer_put_bignum(b, key->n);
#line 426
  buffer_put_bignum(b, key->e);
#line 427
  buffer_put_bignum(b, key->d);
#line 429
  buffer_put_bignum(b, key->iqmp);
#line 430
  buffer_put_bignum(b, key->q);
#line 431
  buffer_put_bignum(b, key->p);
#line 432
  tmp___0 = strlen(comment);
#line 432
  buffer_put_string(b, (void const   *)comment, tmp___0);
#line 433
  return;
}
}
#line 435 "authfd.c"
void ssh_encode_identity_ssh2(Buffer *b , Key *key , char const   *comment ) 
{ char *tmp ;

  {
#line 438
  buffer_clear(b);
#line 439
  buffer_put_char(b, 17);
#line 440
  tmp = key_ssh_name(key);
#line 440
  buffer_put_cstring(b, (char const   *)tmp);
#line 441
  switch (key->type) {
  case 1: 
#line 443
  buffer_put_bignum2(b, (key->rsa)->n);
#line 444
  buffer_put_bignum2(b, (key->rsa)->e);
#line 445
  buffer_put_bignum2(b, (key->rsa)->d);
#line 446
  buffer_put_bignum2(b, (key->rsa)->iqmp);
#line 447
  buffer_put_bignum2(b, (key->rsa)->p);
#line 448
  buffer_put_bignum2(b, (key->rsa)->q);
#line 449
  break;
  case 2: 
#line 451
  buffer_put_bignum2(b, (key->dsa)->p);
#line 452
  buffer_put_bignum2(b, (key->dsa)->q);
#line 453
  buffer_put_bignum2(b, (key->dsa)->g);
#line 454
  buffer_put_bignum2(b, (key->dsa)->pub_key);
#line 455
  buffer_put_bignum2(b, (key->dsa)->priv_key);
#line 456
  break;
  }
#line 458
  buffer_put_cstring(b, comment);
#line 459
  return;
}
}
#line 466 "authfd.c"
int ssh_add_identity(AuthenticationConnection *auth , Key *key , char const   *comment ) 
{ Buffer msg ;
  int type ;
  int tmp ;
  int tmp___0 ;

  {
#line 472
  buffer_init(& msg);
#line 474
  switch (key->type) {
  case 0: 
#line 476
  ssh_encode_identity_rsa1(& msg, key->rsa, comment);
#line 477
  break;
  case 1: 
  case 2: 
#line 480
  ssh_encode_identity_ssh2(& msg, key, comment);
#line 481
  break;
  default: 
#line 483
  buffer_free(& msg);
#line 484
  return (0);
#line 485
  break;
  }
#line 487
  tmp = ssh_request_reply(auth, & msg, & msg);
#line 487
  if (tmp == 0) {
#line 488
    buffer_free(& msg);
#line 489
    return (0);
  }
#line 491
  type = buffer_get_char(& msg);
#line 492
  buffer_free(& msg);
#line 493
  tmp___0 = decode_reply(type);
#line 493
  return (tmp___0);
}
}
#line 501 "authfd.c"
int ssh_remove_identity(AuthenticationConnection *auth , Key *key ) 
{ Buffer msg ;
  int type ;
  u_char *blob ;
  u_int blen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 509
  buffer_init(& msg);
#line 511
  if (key->type == 0) {
#line 512
    buffer_put_char(& msg, 8);
#line 513
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 513
    buffer_put_int(& msg, (unsigned int )tmp);
#line 514
    buffer_put_bignum(& msg, (key->rsa)->e);
#line 515
    buffer_put_bignum(& msg, (key->rsa)->n);
  } else {
#line 516
    if (key->type == 2) {
#line 517
      key_to_blob(key, & blob, & blen);
#line 518
      buffer_put_char(& msg, 18);
#line 519
      buffer_put_string(& msg, (void const   *)blob, blen);
#line 520
      xfree((void *)blob);
    } else {
#line 516
      if (key->type == 1) {
#line 517
        key_to_blob(key, & blob, & blen);
#line 518
        buffer_put_char(& msg, 18);
#line 519
        buffer_put_string(& msg, (void const   *)blob, blen);
#line 520
        xfree((void *)blob);
      } else {
#line 522
        buffer_free(& msg);
#line 523
        return (0);
      }
    }
  }
#line 525
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 525
  if (tmp___0 == 0) {
#line 526
    buffer_free(& msg);
#line 527
    return (0);
  }
#line 529
  type = buffer_get_char(& msg);
#line 530
  buffer_free(& msg);
#line 531
  tmp___1 = decode_reply(type);
#line 531
  return (tmp___1);
}
}
#line 539 "authfd.c"
int ssh_remove_all_identities(AuthenticationConnection *auth , int version ) 
{ Buffer msg ;
  int type ;
  int code ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 544
  if (version == 1) {
#line 544
    tmp = 9;
  } else {
#line 544
    tmp = 19;
  }
#line 544
  code = tmp;
#line 548
  buffer_init(& msg);
#line 549
  buffer_put_char(& msg, code);
#line 551
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 551
  if (tmp___0 == 0) {
#line 552
    buffer_free(& msg);
#line 553
    return (0);
  }
#line 555
  type = buffer_get_char(& msg);
#line 556
  buffer_free(& msg);
#line 557
  tmp___1 = decode_reply(type);
#line 557
  return (tmp___1);
}
}
#line 560 "authfd.c"
int decode_reply(int type ) 
{ 

  {
#line 563
  switch (type) {
  case 5: 
  case 102: 
#line 566
  log("SSH_AGENT_FAILURE");
#line 567
  return (0);
  case 6: 
#line 569
  return (1);
  default: 
#line 571
  fatal("Bad response from authentication agent: %d", type);
  }
#line 574
  return (0);
}
}
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
#line 1 "authfile.o"
#pragma merger(0,"./authfile.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 256 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 212 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 380
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __attribute__((__nonnull__(3))) ;
#line 447
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 447 "/usr/include/sys/stat.h"
__inline static int fstat(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
#line 450
  tmp = __fxstat(3, __fd, __statbuf);
#line 450
  return (tmp);
}
}
#line 301 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 642
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 792
extern  __attribute__((__nothrow__)) int unlink(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 85 "/usr/include/fcntl.h"
extern int open(char const   *__file , int __oflag  , ...)  __attribute__((__nonnull__(1))) ;
#line 213 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 248
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 280
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 532
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 258 "/usr/include/openssl/err.h"
extern unsigned long ERR_get_error(void) ;
#line 391 "/usr/include/openssl/bn.h"
extern BIGNUM const   *BN_value_one(void) ;
#line 393
extern BN_CTX *BN_CTX_new(void) ;
#line 397
extern void BN_CTX_free(BN_CTX *c ) ;
#line 407
extern BIGNUM *BN_new(void) ;
#line 409
extern void BN_clear_free(BIGNUM *a ) ;
#line 416
extern int BN_sub(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *b ) ;
#line 433
extern int BN_div(BIGNUM *dv , BIGNUM *rem , BIGNUM const   *m , BIGNUM const   *d ,
                  BN_CTX *ctx ) ;
#line 639 "/usr/include/openssl/evp.h"
extern EVP_CIPHER const   *EVP_des_ede3_cbc(void) ;
#line 749
extern struct rsa_st *EVP_PKEY_get1_RSA(EVP_PKEY *pkey ) ;
#line 754
extern struct dsa_st *EVP_PKEY_get1_DSA(EVP_PKEY *pkey ) ;
#line 763
extern void EVP_PKEY_free(EVP_PKEY *pkey ) ;
#line 238 "/usr/include/openssl/rsa.h"
extern void RSA_free(RSA *r ) ;
#line 192 "/usr/include/openssl/dsa.h"
extern void DSA_free(DSA *r ) ;
#line 616 "/usr/include/openssl/pem.h"
extern int PEM_write_RSAPrivateKey(FILE *fp , RSA *x , EVP_CIPHER const   *enc , unsigned char *kstr ,
                                   int klen , pem_password_cb *cb , void *u ) ;
#line 625
extern int PEM_write_DSAPrivateKey(FILE *fp , DSA *x , EVP_CIPHER const   *enc , unsigned char *kstr ,
                                   int klen , pem_password_cb *cb , void *u ) ;
#line 640
extern EVP_PKEY *PEM_read_PrivateKey(FILE *fp , EVP_PKEY **x , pem_password_cb *cb ,
                                     void *u ) ;
#line 108 "cipher.h"
Cipher *cipher_by_number(int id ) ;
#line 113
void cipher_encrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) ;
#line 114
void cipher_decrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) ;
#line 115
void cipher_set_key_string(CipherContext *cc , Cipher *cipher , char const   *passphrase ) ;
#line 32 "xmalloc.h"
char *xstrdup(char const   *str ) ;
#line 43 "buffer.h"
void buffer_append_space(Buffer *buffer , char **datap , u_int len ) ;
#line 52 "key.h"
int key_read(Key *ret , char **cpp ) ;
#line 61 "log.h"
void ( /* format attribute */  debug)(char const   *fmt  , ...) ;
#line 63
void ( /* format attribute */  debug3)(char const   *fmt  , ...) ;
#line 27 "authfile.h"
int save_private_key(char const   *filename , char const   *passphrase , Key *key ,
                     char const   *comment ) ;
#line 37
int load_public_key(char const   *filename , Key *key , char **comment_return ) ;
#line 38
int try_load_public_key(char const   *filename , Key *k , char **commentp ) ;
#line 47
int load_private_key(char const   *filename , char const   *passphrase , Key *key ,
                     char **comment_return ) ;
#line 55 "authfile.c"
static char const   authfile_id_string[33]  = 
#line 55 "authfile.c"
  {      (char const   )'S',      (char const   )'S',      (char const   )'H',      (char const   )' ', 
        (char const   )'P',      (char const   )'R',      (char const   )'I',      (char const   )'V', 
        (char const   )'A',      (char const   )'T',      (char const   )'E',      (char const   )' ', 
        (char const   )'K',      (char const   )'E',      (char const   )'Y',      (char const   )' ', 
        (char const   )'F',      (char const   )'I',      (char const   )'L',      (char const   )'E', 
        (char const   )' ',      (char const   )'F',      (char const   )'O',      (char const   )'R', 
        (char const   )'M',      (char const   )'A',      (char const   )'T',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )'\n', 
        (char const   )'\000'};
#line 65 "authfile.c"
int save_private_key_rsa1(char const   *filename , char const   *passphrase , RSA *key ,
                          char const   *comment ) 
{ Buffer buffer ;
  Buffer encrypted ;
  char buf___2[100] ;
  char *cp ;
  int fd ;
  int i ;
  CipherContext ciphercontext ;
  Cipher *cipher ;
  u_int32_t rand___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  u_int tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  u_int tmp___12 ;
  u_int tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  u_int tmp___17 ;
  char *tmp___18 ;
  ssize_t tmp___19 ;
  u_int tmp___20 ;

  {
#line 80
  if (0) {
#line 80
    __s1_len = strlen(passphrase);
#line 80
    __s2_len = strlen("");
#line 80
    if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
      goto _L___0;
    } else {
#line 80
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 80
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 80
          tmp___8 = 1;
        } else {
#line 80
          if (__s2_len >= 4U) {
#line 80
            tmp___8 = 1;
          } else {
#line 80
            tmp___8 = 0;
          }
        }
      } else {
#line 80
        tmp___8 = 0;
      }
    }
#line 80
    if (tmp___8) {
#line 80
      tmp___4 = __builtin_strcmp(passphrase, "");
    } else {
#line 80
      tmp___7 = __builtin_strcmp(passphrase, "");
#line 80
      tmp___4 = tmp___7;
    }
  } else {
#line 80
    tmp___7 = __builtin_strcmp(passphrase, "");
#line 80
    tmp___4 = tmp___7;
  }
#line 80
  if (tmp___4 == 0) {
#line 81
    cipher = cipher_by_number(0);
  } else {
#line 83
    cipher = cipher_by_number(3);
  }
#line 84
  if ((unsigned int )cipher == (unsigned int )((void *)0)) {
#line 85
    fatal("save_private_key_rsa: bad cipher");
  }
#line 88
  buffer_init(& buffer);
#line 91
  rand___0 = arc4random();
#line 92
  buf___2[0] = (char )(rand___0 & 255U);
#line 93
  buf___2[1] = (char )((rand___0 >> 8) & 255U);
#line 94
  buf___2[2] = buf___2[0];
#line 95
  buf___2[3] = buf___2[1];
#line 96
  buffer_append(& buffer, (char const   *)(buf___2), 4U);
#line 103
  buffer_put_bignum(& buffer, key->d);
#line 104
  buffer_put_bignum(& buffer, key->iqmp);
#line 105
  buffer_put_bignum(& buffer, key->q);
#line 106
  buffer_put_bignum(& buffer, key->p);
#line 109
  while (1) {
#line 109
    tmp___9 = buffer_len(& buffer);
#line 109
    if (! (tmp___9 % 8U != 0U)) {
#line 109
      break;
    }
#line 110
    buffer_put_char(& buffer, 0);
  }
#line 113
  buffer_init(& encrypted);
#line 116
  i = 0;
#line 116
  while (authfile_id_string[i]) {
#line 117
    buffer_put_char(& encrypted, (int )authfile_id_string[i]);
#line 116
    i ++;
  }
#line 118
  buffer_put_char(& encrypted, 0);
#line 121
  buffer_put_char(& encrypted, cipher->number);
#line 122
  buffer_put_int(& encrypted, 0U);
#line 125
  tmp___10 = BN_num_bits((BIGNUM const   *)key->n);
#line 125
  buffer_put_int(& encrypted, (unsigned int )tmp___10);
#line 126
  buffer_put_bignum(& encrypted, key->n);
#line 127
  buffer_put_bignum(& encrypted, key->e);
#line 128
  tmp___11 = strlen(comment);
#line 128
  buffer_put_string(& encrypted, (void const   *)comment, tmp___11);
#line 131
  tmp___12 = buffer_len(& buffer);
#line 131
  buffer_append_space(& encrypted, & cp, tmp___12);
#line 133
  cipher_set_key_string(& ciphercontext, cipher, passphrase);
#line 134
  tmp___13 = buffer_len(& buffer);
#line 134
  tmp___14 = buffer_ptr(& buffer);
#line 134
  cipher_encrypt(& ciphercontext, (u_char *)cp, (u_char const   *)((u_char *)tmp___14),
                 tmp___13);
#line 136
  memset((void *)(& ciphercontext), 0, sizeof(ciphercontext));
#line 139
  memset((void *)(buf___2), 0, sizeof(buf___2));
#line 140
  buffer_free(& buffer);
#line 142
  fd = open(filename, 577, 384);
#line 143
  if (fd < 0) {
#line 144
    return (0);
  }
#line 145
  tmp___17 = buffer_len(& encrypted);
#line 145
  tmp___18 = buffer_ptr(& encrypted);
#line 145
  tmp___19 = write(fd, (void const   *)tmp___18, tmp___17);
#line 145
  tmp___20 = buffer_len(& encrypted);
#line 145
  if ((u_int )tmp___19 != tmp___20) {
#line 147
    tmp___15 = __errno_location();
#line 147
    tmp___16 = strerror(*tmp___15);
#line 147
    debug("Write to key file %.200s failed: %.100s", filename, tmp___16);
#line 149
    buffer_free(& encrypted);
#line 150
    close(fd);
#line 151
    unlink(filename);
#line 152
    return (0);
  }
#line 154
  close(fd);
#line 155
  buffer_free(& encrypted);
#line 156
  return (1);
}
}
#line 160 "authfile.c"
int save_private_key_ssh2(char const   *filename , char const   *_passphrase , Key *key ,
                          char const   *comment ) 
{ FILE *fp ;
  int fd ;
  int success ;
  int len ;
  size_t tmp ;
  char *passphrase ;
  char *tmp___0 ;
  EVP_CIPHER *cipher ;
  EVP_CIPHER const   *tmp___2 ;
  int *tmp___3 ;

  {
#line 166
  success = 0;
#line 167
  tmp = strlen(_passphrase);
#line 167
  len = (int )tmp;
#line 168
  if (len > 0) {
#line 168
    tmp___0 = (char *)_passphrase;
  } else {
#line 168
    tmp___0 = (char *)((void *)0);
  }
#line 168
  passphrase = tmp___0;
#line 169
  if (len > 0) {
#line 169
    tmp___2 = EVP_des_ede3_cbc();
  } else {
#line 169
    tmp___2 = (EVP_CIPHER const   *)((void *)0);
  }
#line 169
  cipher = (EVP_CIPHER *)tmp___2;
#line 171
  if (len > 0) {
#line 171
    if (len <= 4) {
#line 172
      error("passphrase too short: %d bytes", len);
#line 173
      tmp___3 = __errno_location();
#line 173
      *tmp___3 = 0;
#line 174
      return (0);
    }
  }
#line 176
  fd = open(filename, 577, 384);
#line 177
  if (fd < 0) {
#line 178
    debug("open %s failed", filename);
#line 179
    return (0);
  }
#line 181
  fp = fdopen(fd, "w");
#line 182
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 183
    debug("fdopen %s failed", filename);
#line 184
    close(fd);
#line 185
    return (0);
  }
#line 187
  switch (key->type) {
  case 2: 
#line 189
  success = PEM_write_DSAPrivateKey(fp, key->dsa, (EVP_CIPHER const   *)cipher, (unsigned char *)passphrase,
                                    len, (pem_password_cb *)((void *)0), (void *)0);
#line 191
  break;
  case 1: 
#line 193
  success = PEM_write_RSAPrivateKey(fp, key->rsa, (EVP_CIPHER const   *)cipher, (unsigned char *)passphrase,
                                    len, (pem_password_cb *)((void *)0), (void *)0);
#line 195
  break;
  }
#line 197
  fclose(fp);
#line 198
  return (success);
}
}
#line 201 "authfile.c"
int save_private_key(char const   *filename , char const   *passphrase , Key *key ,
                     char const   *comment ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 205
  switch (key->type) {
  case 0: 
#line 207
  tmp = save_private_key_rsa1(filename, passphrase, key->rsa, comment);
#line 207
  return (tmp);
#line 208
  break;
  case 2: 
  case 1: 
#line 211
  tmp___0 = save_private_key_ssh2(filename, passphrase, key, comment);
#line 211
  return (tmp___0);
#line 212
  break;
  default: ;
#line 214
  break;
  }
#line 216
  return (0);
}
}
#line 225 "authfile.c"
int load_public_key_rsa(char const   *filename , RSA *pub , char **comment_return ) 
{ int fd ;
  int i ;
  off_t len ;
  Buffer buffer ;
  char *cp ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;

  {
#line 233
  fd = open(filename, 0);
#line 234
  if (fd < 0) {
#line 235
    return (0);
  }
#line 236
  len = lseek(fd, 0L, 2);
#line 237
  lseek(fd, 0L, 0);
#line 239
  buffer_init(& buffer);
#line 240
  buffer_append_space(& buffer, & cp, (unsigned int )len);
#line 242
  tmp___1 = read(fd, (void *)cp, (unsigned int )len);
#line 242
  if ((unsigned int )tmp___1 != (unsigned int )len) {
#line 243
    tmp = __errno_location();
#line 243
    tmp___0 = strerror(*tmp);
#line 243
    debug("Read from key file %.200s failed: %.100s", filename, tmp___0);
#line 245
    buffer_free(& buffer);
#line 246
    close(fd);
#line 247
    return (0);
  }
#line 249
  close(fd);
#line 252
  if ((unsigned long )len < (unsigned long )sizeof(authfile_id_string)) {
#line 253
    debug3("Bad RSA1 key file %.200s.", filename);
#line 254
    buffer_free(& buffer);
#line 255
    return (0);
  }
#line 261
  i = 0;
#line 261
  while ((unsigned int )i < sizeof(authfile_id_string)) {
#line 262
    tmp___2 = buffer_get_char(& buffer);
#line 262
    if (tmp___2 != (int )authfile_id_string[i]) {
#line 263
      debug3("Bad RSA1 key file %.200s.", filename);
#line 264
      buffer_free(& buffer);
#line 265
      return (0);
    }
#line 261
    i ++;
  }
#line 268
  buffer_get_char(& buffer);
#line 269
  buffer_get_int(& buffer);
#line 272
  buffer_get_int(& buffer);
#line 274
  if ((unsigned int )pub->n == (unsigned int )((void *)0)) {
#line 275
    pub->n = BN_new();
  }
#line 276
  buffer_get_bignum(& buffer, pub->n);
#line 278
  if ((unsigned int )pub->e == (unsigned int )((void *)0)) {
#line 279
    pub->e = BN_new();
  }
#line 280
  buffer_get_bignum(& buffer, pub->e);
#line 281
  if (comment_return) {
#line 282
    *comment_return = buffer_get_string(& buffer, (u_int *)((void *)0));
  }
#line 285
  buffer_free(& buffer);
#line 287
  return (1);
}
}
#line 291 "authfile.c"
int load_public_key(char const   *filename , Key *key , char **comment_return ) 
{ int tmp ;

  {
#line 294
  switch (key->type) {
  case 0: 
#line 296
  tmp = load_public_key_rsa(filename, key->rsa, comment_return);
#line 296
  return (tmp);
#line 297
  break;
  case 2: 
  case 1: 
  default: ;
#line 301
  break;
  }
#line 303
  return (0);
}
}
#line 313 "authfile.c"
int load_private_key_rsa1(int fd , char const   *filename , char const   *passphrase ,
                          RSA *prv , char **comment_return ) 
{ int i ;
  int check1 ;
  int check2 ;
  int cipher_type___0 ;
  off_t len ;
  Buffer buffer ;
  Buffer decrypted ;
  char *cp ;
  CipherContext ciphercontext ;
  Cipher *cipher ;
  BN_CTX *ctx ;
  BIGNUM *aux ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  char *tmp___6 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___12 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  BIGNUM const   *tmp___19 ;
  BIGNUM const   *tmp___20 ;

  {
#line 326
  len = lseek(fd, 0L, 2);
#line 327
  lseek(fd, 0L, 0);
#line 329
  buffer_init(& buffer);
#line 330
  buffer_append_space(& buffer, & cp, (unsigned int )len);
#line 332
  tmp___1 = read(fd, (void *)cp, (unsigned int )len);
#line 332
  if ((unsigned int )tmp___1 != (unsigned int )len) {
#line 333
    tmp = __errno_location();
#line 333
    tmp___0 = strerror(*tmp);
#line 333
    debug("Read from key file %.200s failed: %.100s", filename, tmp___0);
#line 335
    buffer_free(& buffer);
#line 336
    close(fd);
#line 337
    return (0);
  }
#line 339
  close(fd);
#line 342
  if ((unsigned long )len < (unsigned long )sizeof(authfile_id_string)) {
#line 343
    debug3("Bad RSA1 key file %.200s.", filename);
#line 344
    buffer_free(& buffer);
#line 345
    return (0);
  }
#line 351
  i = 0;
#line 351
  while ((unsigned int )i < sizeof(authfile_id_string)) {
#line 352
    tmp___2 = buffer_get_char(& buffer);
#line 352
    if (tmp___2 != (int )authfile_id_string[i]) {
#line 353
      debug3("Bad RSA1 key file %.200s.", filename);
#line 354
      buffer_free(& buffer);
#line 355
      return (0);
    }
#line 351
    i ++;
  }
#line 358
  cipher_type___0 = buffer_get_char(& buffer);
#line 359
  buffer_get_int(& buffer);
#line 362
  buffer_get_int(& buffer);
#line 363
  prv->n = BN_new();
#line 364
  buffer_get_bignum(& buffer, prv->n);
#line 365
  prv->e = BN_new();
#line 366
  buffer_get_bignum(& buffer, prv->e);
#line 367
  if (comment_return) {
#line 368
    *comment_return = buffer_get_string(& buffer, (u_int *)((void *)0));
  } else {
#line 370
    tmp___3 = buffer_get_string(& buffer, (u_int *)((void *)0));
#line 370
    xfree((void *)tmp___3);
  }
#line 373
  cipher = cipher_by_number(cipher_type___0);
#line 374
  if ((unsigned int )cipher == (unsigned int )((void *)0)) {
#line 375
    debug("Unsupported cipher %d used in key file %.200s.", cipher_type___0, filename);
#line 377
    buffer_free(& buffer);
    goto fail;
  }
#line 381
  buffer_init(& decrypted);
#line 382
  tmp___4 = buffer_len(& buffer);
#line 382
  buffer_append_space(& decrypted, & cp, tmp___4);
#line 385
  cipher_set_key_string(& ciphercontext, cipher, passphrase);
#line 386
  tmp___5 = buffer_len(& buffer);
#line 386
  tmp___6 = buffer_ptr(& buffer);
#line 386
  cipher_decrypt(& ciphercontext, (u_char *)cp, (u_char const   *)((u_char *)tmp___6),
                 tmp___5);
#line 388
  memset((void *)(& ciphercontext), 0, sizeof(ciphercontext));
#line 389
  buffer_free(& buffer);
#line 391
  check1 = buffer_get_char(& decrypted);
#line 392
  check2 = buffer_get_char(& decrypted);
#line 393
  tmp___17 = buffer_get_char(& decrypted);
#line 393
  if (check1 != tmp___17) {
    goto _L___1;
  } else {
#line 393
    tmp___18 = buffer_get_char(& decrypted);
#line 393
    if (check2 != tmp___18) {
      _L___1: /* CIL Label */ 
#line 395
      if (0) {
#line 395
        __s1_len = strlen(passphrase);
#line 395
        __s2_len = strlen("");
#line 395
        if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
          goto _L___0;
        } else {
#line 395
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 395
            if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 395
              tmp___16 = 1;
            } else {
#line 395
              if (__s2_len >= 4U) {
#line 395
                tmp___16 = 1;
              } else {
#line 395
                tmp___16 = 0;
              }
            }
          } else {
#line 395
            tmp___16 = 0;
          }
        }
#line 395
        if (tmp___16) {
#line 395
          tmp___12 = __builtin_strcmp(passphrase, "");
        } else {
#line 395
          tmp___15 = __builtin_strcmp(passphrase, "");
#line 395
          tmp___12 = tmp___15;
        }
      } else {
#line 395
        tmp___15 = __builtin_strcmp(passphrase, "");
#line 395
        tmp___12 = tmp___15;
      }
#line 395
      if (tmp___12 != 0) {
#line 396
        debug("Bad passphrase supplied for key file %.200s.", filename);
      }
#line 398
      buffer_free(& decrypted);
      fail: 
#line 400
      BN_clear_free(prv->n);
#line 401
      prv->n = (BIGNUM *)((void *)0);
#line 402
      BN_clear_free(prv->e);
#line 403
      prv->e = (BIGNUM *)((void *)0);
#line 404
      if (comment_return) {
#line 405
        xfree((void *)*comment_return);
      }
#line 406
      return (0);
    }
  }
#line 409
  prv->d = BN_new();
#line 410
  buffer_get_bignum(& decrypted, prv->d);
#line 411
  prv->iqmp = BN_new();
#line 412
  buffer_get_bignum(& decrypted, prv->iqmp);
#line 414
  prv->q = BN_new();
#line 415
  buffer_get_bignum(& decrypted, prv->q);
#line 416
  prv->p = BN_new();
#line 417
  buffer_get_bignum(& decrypted, prv->p);
#line 419
  ctx = BN_CTX_new();
#line 420
  aux = BN_new();
#line 422
  tmp___19 = BN_value_one();
#line 422
  BN_sub(aux, (BIGNUM const   *)prv->q, tmp___19);
#line 423
  prv->dmq1 = BN_new();
#line 424
  BN_div((BIGNUM *)((void *)0), prv->dmq1, (BIGNUM const   *)prv->d, (BIGNUM const   *)aux,
         ctx);
#line 426
  tmp___20 = BN_value_one();
#line 426
  BN_sub(aux, (BIGNUM const   *)prv->p, tmp___20);
#line 427
  prv->dmp1 = BN_new();
#line 428
  BN_div((BIGNUM *)((void *)0), prv->dmp1, (BIGNUM const   *)prv->d, (BIGNUM const   *)aux,
         ctx);
#line 430
  BN_clear_free(aux);
#line 431
  BN_CTX_free(ctx);
#line 433
  buffer_free(& decrypted);
#line 435
  return (1);
}
}
#line 438 "authfile.c"
int load_private_key_ssh2(int fd , char const   *passphrase , Key *k , char **comment_return ) 
{ FILE *fp ;
  int success ;
  EVP_PKEY *pk ;
  char *name ;

  {
#line 442
  success = 0;
#line 443
  pk = (EVP_PKEY *)((void *)0);
#line 444
  name = (char *)"<no key>";
#line 446
  fp = fdopen(fd, "r");
#line 447
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 448
    error("fdopen failed");
#line 449
    return (0);
  }
#line 451
  pk = PEM_read_PrivateKey(fp, (EVP_PKEY **)((void *)0), (pem_password_cb *)((void *)0),
                           (void *)((char *)passphrase));
#line 452
  if ((unsigned int )pk == (unsigned int )((void *)0)) {
#line 453
    debug("PEM_read_PrivateKey failed");
#line 454
    ERR_get_error();
  } else {
#line 455
    if (pk->type == 6) {
#line 457
      if (k->type == 1) {
        goto _L;
      } else {
#line 457
        if (k->type == 3) {
          _L: /* CIL Label */ 
#line 458
          if ((unsigned int )k->rsa != (unsigned int )((void *)0)) {
#line 459
            RSA_free(k->rsa);
          }
#line 460
          k->rsa = EVP_PKEY_get1_RSA(pk);
#line 461
          k->type = 1;
#line 462
          name = (char *)"rsa w/o comment";
#line 463
          success = 1;
        }
      }
    } else {
#line 468
      if (pk->type == 116) {
#line 470
        if (k->type == 2) {
          goto _L___0;
        } else {
#line 470
          if (k->type == 3) {
            _L___0: /* CIL Label */ 
#line 471
            if ((unsigned int )k->dsa != (unsigned int )((void *)0)) {
#line 472
              DSA_free(k->dsa);
            }
#line 473
            k->dsa = EVP_PKEY_get1_DSA(pk);
#line 474
            k->type = 2;
#line 475
            name = (char *)"dsa w/o comment";
#line 479
            success = 1;
          }
        }
      } else {
#line 482
        error("PEM_read_PrivateKey: mismatch or unknown EVP_PKEY save_type %d", pk->save_type);
      }
    }
  }
#line 485
  fclose(fp);
#line 486
  if ((unsigned int )pk != (unsigned int )((void *)0)) {
#line 487
    EVP_PKEY_free(pk);
  }
#line 488
  if (success) {
#line 488
    if (comment_return) {
#line 489
      *comment_return = xstrdup((char const   *)name);
    }
  }
#line 490
  debug("read SSH2 private key done: name %s success %d", name, success);
#line 491
  return (success);
}
}
#line 494 "authfile.c"
int load_private_key(char const   *filename , char const   *passphrase , Key *key ,
                     char **comment_return ) 
{ int fd ;
  int ret ;
  struct stat st ;
  int tmp ;
  __uid_t tmp___0 ;
  __uid_t tmp___1 ;

  {
#line 499
  ret = 0;
#line 502
  fd = open(filename, 0);
#line 503
  if (fd < 0) {
#line 504
    return (0);
  }
#line 510
  tmp = fstat(fd, & st);
#line 510
  if (tmp < 0) {
    goto _L;
  } else {
#line 510
    if (st.st_uid != 0U) {
#line 510
      tmp___0 = getuid();
#line 510
      if (tmp___0 != 0U) {
#line 510
        tmp___1 = getuid();
#line 510
        if (st.st_uid != tmp___1) {
          goto _L;
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 510
      if ((st.st_mode & 63U) != 0U) {
        _L: /* CIL Label */ 
#line 513
        close(fd);
#line 514
        error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 515
        error("@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @");
#line 516
        error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 517
        error("Bad ownership or mode(0%3.3o) for \'%s\'.", st.st_mode & 511U, filename);
#line 519
        error("It is recommended that your private key files are NOT accessible by others.");
#line 520
        return (0);
      }
    }
  }
#line 522
  switch (key->type) {
  case 0: 
#line 524
  if ((unsigned int )(key->rsa)->e != (unsigned int )((void *)0)) {
#line 525
    BN_clear_free((key->rsa)->e);
#line 526
    (key->rsa)->e = (BIGNUM *)((void *)0);
  }
#line 528
  if ((unsigned int )(key->rsa)->n != (unsigned int )((void *)0)) {
#line 529
    BN_clear_free((key->rsa)->n);
#line 530
    (key->rsa)->n = (BIGNUM *)((void *)0);
  }
#line 532
  ret = load_private_key_rsa1(fd, filename, passphrase, key->rsa, comment_return);
#line 534
  break;
  case 2: 
  case 1: 
  case 3: 
#line 538
  ret = load_private_key_ssh2(fd, passphrase, key, comment_return);
  default: ;
#line 540
  break;
  }
#line 542
  close(fd);
#line 543
  return (ret);
}
}
#line 546 "authfile.c"
int do_load_public_key(char const   *filename , Key *k , char **commentp ) 
{ FILE *f ;
  char line[1024] ;
  char *cp ;
  int tmp ;
  char *tmp___0 ;

  {
#line 553
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 554
  if ((unsigned int )f != (unsigned int )((void *)0)) {
#line 555
    while (1) {
#line 555
      tmp___0 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 555
      if (! tmp___0) {
#line 555
        break;
      }
#line 556
      line[sizeof(line) - 1U] = (char )'\000';
#line 557
      cp = line;
#line 558
      switch ((int )*cp) {
      case 35: 
      case 10: 
      case 0: 
#line 562
      continue;
      }
#line 565
      while (1) {
#line 565
        if (*cp) {
#line 565
          if (! ((int )*cp == 32)) {
#line 565
            if (! ((int )*cp == 9)) {
#line 565
              break;
            }
          }
        } else {
#line 565
          break;
        }
#line 565
        cp ++;
      }
#line 567
      if (*cp) {
#line 568
        tmp = key_read(k, & cp);
#line 568
        if (tmp == 1) {
#line 569
          if (commentp) {
#line 570
            *commentp = xstrdup(filename);
          }
#line 571
          fclose(f);
#line 572
          return (1);
        }
      }
    }
#line 576
    fclose(f);
  }
#line 578
  return (0);
}
}
#line 582 "authfile.c"
int try_load_public_key(char const   *filename , Key *k , char **commentp ) 
{ char pub[4096] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 587
  tmp = do_load_public_key(filename, k, commentp);
#line 587
  if (tmp == 1) {
#line 588
    return (1);
  }
#line 589
  tmp___0 = strlcpy(pub, filename, sizeof(pub));
#line 589
  if (tmp___0 >= 4096U) {
#line 590
    return (0);
  }
#line 591
  tmp___1 = strlcat(pub, ".pub", sizeof(pub));
#line 591
  if (tmp___1 >= 4096U) {
#line 592
    return (0);
  }
#line 593
  tmp___2 = do_load_public_key((char const   *)(pub), k, commentp);
#line 593
  if (tmp___2 == 1) {
#line 594
    return (1);
  }
#line 595
  return (0);
}
}
#line 1 "bufaux.o"
#pragma merger(0,"./bufaux.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 412 "/usr/include/openssl/bn.h"
extern BIGNUM *BN_bin2bn(unsigned char const   *s , int len , BIGNUM *ret ) ;
#line 413
extern int BN_bn2bin(BIGNUM const   *a , unsigned char *to ) ;
#line 49 "buffer.h"
void buffer_get(Buffer *buffer , char *buf___2 , u_int len ) ;
#line 52
void buffer_consume(Buffer *buffer , u_int bytes ) ;
#line 30 "bufaux.h"
int buffer_get_bignum2(Buffer *buffer , BIGNUM *value ) ;
#line 35
u_int64_t buffer_get_int64(Buffer *buffer ) ;
#line 41
void buffer_put_int64(Buffer *buffer , u_int64_t value ) ;
#line 52 "bufaux.c"
void buffer_put_bignum(Buffer *buffer , BIGNUM *value ) 
{ int bits ;
  int tmp ;
  int bin_size ;
  u_char *buf___2 ;
  void *tmp___0 ;
  int oi ;
  char msg[2] ;

  {
#line 55
  tmp = BN_num_bits((BIGNUM const   *)value);
#line 55
  bits = tmp;
#line 56
  bin_size = (bits + 7) / 8;
#line 57
  tmp___0 = xmalloc((unsigned int )bin_size);
#line 57
  buf___2 = (u_char *)tmp___0;
#line 62
  oi = BN_bn2bin((BIGNUM const   *)value, buf___2);
#line 63
  if (oi != bin_size) {
#line 64
    fatal("buffer_put_bignum: BN_bn2bin() failed: oi %d != bin_size %d", oi, bin_size);
  }
#line 68
  while (1) {
#line 68
    msg[0] = (char )(bits >> 8);
#line 68
    msg[1] = (char )bits;
#line 68
    break;
  }
#line 69
  buffer_append(buffer, (char const   *)(msg), 2U);
#line 71
  buffer_append(buffer, (char const   *)((char *)buf___2), (unsigned int )oi);
#line 73
  memset((void *)buf___2, 0, (unsigned int )bin_size);
#line 74
  xfree((void *)buf___2);
#line 75
  return;
}
}
#line 80 "bufaux.c"
int buffer_get_bignum(Buffer *buffer , BIGNUM *value ) 
{ int bits ;
  int bytes ;
  u_char buf___2[2] ;
  u_char *bin ;
  u_int tmp ;
  char *tmp___0 ;

  {
#line 87
  buffer_get(buffer, (char *)(buf___2), 2U);
#line 88
  bits = (int )(((unsigned long )buf___2[0] << 8) | (unsigned long )buf___2[1]);
#line 90
  bytes = (bits + 7) / 8;
#line 91
  tmp = buffer_len(buffer);
#line 91
  if (tmp < (u_int )bytes) {
#line 92
    fatal("buffer_get_bignum: input buffer too small");
  }
#line 93
  tmp___0 = buffer_ptr(buffer);
#line 93
  bin = (u_char *)tmp___0;
#line 94
  BN_bin2bn((unsigned char const   *)bin, bytes, value);
#line 95
  buffer_consume(buffer, (unsigned int )bytes);
#line 97
  return (2 + bytes);
}
}
#line 103 "bufaux.c"
void buffer_put_bignum2(Buffer *buffer , BIGNUM *value ) 
{ int bytes ;
  int tmp ;
  u_char *buf___2 ;
  void *tmp___0 ;
  int oi ;
  int hasnohigh ;
  int i ;
  int carry ;
  u_char *uc ;
  int tmp___1 ;

  {
#line 106
  tmp = BN_num_bits((BIGNUM const   *)value);
#line 106
  bytes = (tmp + 7) / 8 + 1;
#line 107
  tmp___0 = xmalloc((unsigned int )bytes);
#line 107
  buf___2 = (u_char *)tmp___0;
#line 109
  hasnohigh = 0;
#line 110
  *(buf___2 + 0) = (unsigned char )'\000';
#line 112
  oi = BN_bn2bin((BIGNUM const   *)value, buf___2 + 1);
#line 113
  if (oi != bytes - 1) {
#line 114
    fatal("buffer_put_bignum: BN_bn2bin() failed: oi %d != bin_size %d", oi, bytes);
  }
#line 116
  if ((int )*(buf___2 + 1) & 128) {
#line 116
    hasnohigh = 0;
  } else {
#line 116
    hasnohigh = 1;
  }
#line 117
  if (value->neg) {
#line 120
    uc = buf___2;
#line 121
    log("negativ!");
#line 122
    i = bytes - 1;
#line 122
    carry = 1;
#line 122
    while (i >= 0) {
#line 123
      *(uc + i) = (unsigned char )((int )*(uc + i) ^ 255);
#line 124
      if (carry) {
#line 125
        *(uc + i) = (u_char )((int )*(uc + i) + 1);
#line 125
        if (*(uc + i)) {
#line 125
          tmp___1 = 0;
        } else {
#line 125
          tmp___1 = 1;
        }
#line 125
        carry = tmp___1;
      }
#line 122
      i --;
    }
  }
#line 128
  buffer_put_string(buffer, (void const   *)(buf___2 + hasnohigh), (unsigned int )(bytes - hasnohigh));
#line 129
  memset((void *)buf___2, 0, (unsigned int )bytes);
#line 130
  xfree((void *)buf___2);
#line 131
  return;
}
}
#line 133 "bufaux.c"
int buffer_get_bignum2(Buffer *buffer , BIGNUM *value ) 
{ int len ;
  u_char *bin ;
  char *tmp ;

  {
#line 138
  tmp = buffer_get_string(buffer, (u_int *)(& len));
#line 138
  bin = (u_char *)tmp;
#line 139
  BN_bin2bn((unsigned char const   *)bin, len, value);
#line 140
  xfree((void *)bin);
#line 141
  return (len);
}
}
#line 147 "bufaux.c"
u_int buffer_get_int(Buffer *buffer ) 
{ u_char buf___2[4] ;

  {
#line 151
  buffer_get(buffer, (char *)(buf___2), 4U);
#line 152
  return ((unsigned int )(((((unsigned long )buf___2[0] << 24) | ((unsigned long )buf___2[1] << 16)) | ((unsigned long )buf___2[2] << 8)) | (unsigned long )buf___2[3]));
}
}
#line 156 "bufaux.c"
u_int64_t buffer_get_int64(Buffer *buffer ) 
{ u_char buf___2[8] ;

  {
#line 160
  buffer_get(buffer, (char *)(buf___2), 8U);
#line 161
  return (((((((((unsigned long long )buf___2[0] << 56) | ((unsigned long long )buf___2[1] << 48)) | ((unsigned long long )buf___2[2] << 40)) | ((unsigned long long )buf___2[3] << 32)) | ((unsigned long long )buf___2[4] << 24)) | ((unsigned long long )buf___2[5] << 16)) | ((unsigned long long )buf___2[6] << 8)) | (unsigned long long )buf___2[7]);
}
}
#line 168 "bufaux.c"
void buffer_put_int(Buffer *buffer , u_int value ) 
{ char buf___2[4] ;

  {
#line 172
  while (1) {
#line 172
    buf___2[0] = (char )(value >> 24);
#line 172
    buf___2[1] = (char )(value >> 16);
#line 172
    buf___2[2] = (char )(value >> 8);
#line 172
    buf___2[3] = (char )value;
#line 172
    break;
  }
#line 173
  buffer_append(buffer, (char const   *)(buf___2), 4U);
#line 174
  return;
}
}
#line 177 "bufaux.c"
void buffer_put_int64(Buffer *buffer , u_int64_t value ) 
{ char buf___2[8] ;

  {
#line 181
  while (1) {
#line 181
    buf___2[0] = (char )(value >> 56);
#line 181
    buf___2[1] = (char )(value >> 48);
#line 181
    buf___2[2] = (char )(value >> 40);
#line 181
    buf___2[3] = (char )(value >> 32);
#line 181
    buf___2[4] = (char )(value >> 24);
#line 181
    buf___2[5] = (char )(value >> 16);
#line 181
    buf___2[6] = (char )(value >> 8);
#line 181
    buf___2[7] = (char )value;
#line 181
    break;
  }
#line 182
  buffer_append(buffer, (char const   *)(buf___2), 8U);
#line 183
  return;
}
}
#line 194 "bufaux.c"
char *buffer_get_string(Buffer *buffer , u_int *length_ptr ) 
{ u_int len ;
  char *value ;
  void *tmp ;

  {
#line 200
  len = buffer_get_int(buffer);
#line 201
  if (len > 262144U) {
#line 202
    fatal("Received packet with bad string length %d", len);
  }
#line 204
  tmp = xmalloc(len + 1U);
#line 204
  value = (char *)tmp;
#line 206
  buffer_get(buffer, value, len);
#line 208
  *(value + len) = (char)0;
#line 210
  if (length_ptr) {
#line 211
    *length_ptr = len;
  }
#line 212
  return (value);
}
}
#line 218 "bufaux.c"
void buffer_put_string(Buffer *buffer , void const   *buf___2 , u_int len ) 
{ 

  {
#line 221
  buffer_put_int(buffer, len);
#line 222
  buffer_append(buffer, (char const   *)buf___2, len);
#line 223
  return;
}
}
#line 224 "bufaux.c"
void buffer_put_cstring(Buffer *buffer , char const   *s ) 
{ size_t tmp ;

  {
#line 227
  tmp = strlen(s);
#line 227
  buffer_put_string(buffer, (void const   *)s, tmp);
#line 228
  return;
}
}
#line 233 "bufaux.c"
int buffer_get_char(Buffer *buffer ) 
{ char ch ;

  {
#line 237
  buffer_get(buffer, & ch, 1U);
#line 238
  return ((int )((unsigned char )ch));
}
}
#line 244 "bufaux.c"
void buffer_put_char(Buffer *buffer , int value ) 
{ char ch ;

  {
#line 247
  ch = (char )value;
#line 248
  buffer_append(buffer, (char const   *)(& ch), 1U);
#line 249
  return;
}
}
#line 1 "buffer.o"
#pragma merger(0,"./buffer.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 38 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                  size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 43
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 144 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 327
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 26 "xmalloc.h"
void *xrealloc(void *ptr , size_t new_size ) ;
#line 55 "buffer.h"
void buffer_consume_end(Buffer *buffer , u_int bytes ) ;
#line 64
void buffer_dump(Buffer *buffer ) ;
#line 23 "buffer.c"
void buffer_init(Buffer *buffer ) 
{ void *tmp ;

  {
#line 26
  buffer->alloc = 4096U;
#line 27
  tmp = xmalloc(buffer->alloc);
#line 27
  buffer->buf = (char *)tmp;
#line 28
  buffer->offset = 0U;
#line 29
  buffer->end = 0U;
#line 30
  return;
}
}
#line 34 "buffer.c"
void buffer_free(Buffer *buffer ) 
{ 

  {
#line 37
  memset((void *)buffer->buf, 0, buffer->alloc);
#line 38
  xfree((void *)buffer->buf);
#line 39
  return;
}
}
#line 46 "buffer.c"
void buffer_clear(Buffer *buffer ) 
{ 

  {
#line 49
  buffer->offset = 0U;
#line 50
  buffer->end = 0U;
#line 51
  return;
}
}
#line 55 "buffer.c"
void buffer_append(Buffer *buffer , char const   *data , u_int len ) 
{ char *cp ;

  {
#line 59
  buffer_append_space(buffer, & cp, len);
#line 60
  memcpy((void * __restrict  )cp, (void const   * __restrict  )data, len);
#line 61
  return;
}
}
#line 69 "buffer.c"
void buffer_append_space(Buffer *buffer , char **datap , u_int len ) 
{ void *tmp ;

  {
#line 73
  if (buffer->offset == buffer->end) {
#line 74
    buffer->offset = 0U;
#line 75
    buffer->end = 0U;
  }
  restart: 
#line 79
  if (buffer->end + len < buffer->alloc) {
#line 80
    *datap = buffer->buf + buffer->end;
#line 81
    buffer->end += len;
#line 82
    return;
  }
#line 88
  if (buffer->offset > buffer->alloc / 2U) {
#line 89
    memmove((void *)buffer->buf, (void const   *)(buffer->buf + buffer->offset), buffer->end - buffer->offset);
#line 91
    buffer->end -= buffer->offset;
#line 92
    buffer->offset = 0U;
    goto restart;
  }
#line 96
  buffer->alloc += len + 32768U;
#line 97
  tmp = xrealloc((void *)buffer->buf, buffer->alloc);
#line 97
  buffer->buf = (char *)tmp;
  goto restart;
}
}
#line 103 "buffer.c"
u_int buffer_len(Buffer *buffer ) 
{ 

  {
#line 106
  return (buffer->end - buffer->offset);
}
}
#line 111 "buffer.c"
void buffer_get(Buffer *buffer , char *buf___2 , u_int len ) 
{ 

  {
#line 114
  if (len > buffer->end - buffer->offset) {
#line 115
    fatal("buffer_get: trying to get more bytes than in buffer");
  }
#line 116
  memcpy((void * __restrict  )buf___2, (void const   * __restrict  )(buffer->buf + buffer->offset),
         len);
#line 117
  buffer->offset += len;
#line 118
  return;
}
}
#line 122 "buffer.c"
void buffer_consume(Buffer *buffer , u_int bytes ) 
{ 

  {
#line 125
  if (bytes > buffer->end - buffer->offset) {
#line 126
    fatal("buffer_consume: trying to get more bytes than in buffer");
  }
#line 127
  buffer->offset += bytes;
#line 128
  return;
}
}
#line 132 "buffer.c"
void buffer_consume_end(Buffer *buffer , u_int bytes ) 
{ 

  {
#line 135
  if (bytes > buffer->end - buffer->offset) {
#line 136
    fatal("buffer_consume_end: trying to get more bytes than in buffer");
  }
#line 137
  buffer->end -= bytes;
#line 138
  return;
}
}
#line 142 "buffer.c"
char *buffer_ptr(Buffer *buffer ) 
{ 

  {
#line 145
  return (buffer->buf + buffer->offset);
}
}
#line 150 "buffer.c"
void buffer_dump(Buffer *buffer ) 
{ int i ;
  u_char *ucp ;

  {
#line 154
  ucp = (u_char *)buffer->buf;
#line 156
  i = (int )buffer->offset;
#line 156
  while ((u_int )i < buffer->end) {
#line 157
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" %02x", *(ucp + i));
#line 156
    i ++;
  }
#line 158
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 159
  return;
}
}
#line 1 "canohost.o"
#pragma merger(0,"./canohost.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 128 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int getpeername(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 185
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
#line 357 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 83 "/usr/include/ctype.h"
extern __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 116
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 190
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 190 "/usr/include/ctype.h"
__inline static int tolower(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
#line 193
  if (__c >= -128) {
#line 193
    if (__c < 256) {
#line 193
      tmp___1 = __ctype_tolower_loc();
#line 193
      tmp___0 = *(*tmp___1 + __c);
    } else {
#line 193
      tmp___0 = (int const   )__c;
    }
  } else {
#line 193
    tmp___0 = (int const   )__c;
  }
#line 193
  return ((int )tmp___0);
}
}
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 290
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   * __restrict  __nptr ,
                                                            char ** __restrict  __endptr ,
                                                            int __base , int __group )  __attribute__((__nonnull__(1))) ;
#line 332
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 332 "/usr/include/stdlib.h"
__inline static long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                            int __base ) 
{ long tmp ;

  {
#line 336
  tmp = __strtol_internal(__nptr, __endptr, __base, 0);
#line 336
  return (tmp);
}
}
#line 401
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 401 "/usr/include/stdlib.h"
__inline static int atoi(char const   *__nptr ) 
{ long tmp ;

  {
#line 404
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 404
  return ((int )tmp);
}
}
#line 352 "/usr/include/netdb.h"
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 631
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 637
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
#line 646
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , unsigned int __flags ) ;
#line 32 "packet.h"
int packet_get_connection_in(void) ;
#line 150
void ( /* format attribute */  packet_disconnect)(char const   *fmt  , ...) ;
#line 208
int packet_connection_is_on_socket(void) ;
#line 66 "log.h"
void fatal_cleanup(void) ;
#line 20 "canohost.h"
char const   *get_canonical_hostname(int reverse_mapping_check ) ;
#line 26
char const   *get_remote_ipaddr(void) ;
#line 29
char *get_peer_ipaddr(int socket___0 ) ;
#line 30
int get_peer_port(int sock ) ;
#line 33
int get_remote_port(void) ;
#line 34
int get_local_port(void) ;
#line 22 "canohost.c"
void check_ip_options(int socket___0 , char *ipaddr ) ;
#line 29 "canohost.c"
char *get_remote_hostname(int socket___0 , int reverse_mapping_check ) 
{ struct sockaddr_storage from ;
  int i ;
  socklen_t fromlen ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char name[1025] ;
  char ntop[1025] ;
  char ntop2[1025] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  struct sockaddr_in6 *from6 ;
  struct sockaddr_in *from4 ;
  struct in_addr addr ;
  u_int16_t port ;
  register unsigned int __v ;
  register unsigned int __x ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int __res ;
  __int32_t const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;

  {
#line 39
  fromlen = sizeof(from);
#line 40
  memset((void *)(& from), 0, sizeof(from));
#line 41
  tmp___1 = getpeername(socket___0, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                        (socklen_t * __restrict  )(& fromlen));
#line 41
  if (tmp___1 < 0) {
#line 42
    tmp = __errno_location();
#line 42
    tmp___0 = strerror(*tmp);
#line 42
    debug("getpeername failed: %.100s", tmp___0);
#line 43
    fatal_cleanup();
  }
#line 46
  if ((int )from.ss_family == 10) {
#line 47
    from6 = (struct sockaddr_in6 *)(& from);
#line 51
    if (*((uint32_t const   *)(& from6->sin6_addr) + 0) == 0U) {
#line 51
      if (*((uint32_t const   *)(& from6->sin6_addr) + 1) == 0U) {
#line 51
        __x = 65535U;
#line 51
        __asm__  ("rorw $8, %w0;"
                  "rorl $16, %0;"
                  "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 51
        if (*((uint32_t const   *)(& from6->sin6_addr) + 2) == (uint32_t const   )__v) {
#line 52
          from4 = (struct sockaddr_in *)(& from);
#line 56
          memcpy((void * __restrict  )(& addr), (void const   * __restrict  )((char *)(& from6->sin6_addr) + 12),
                 sizeof(addr));
#line 57
          port = from6->sin6_port;
#line 59
          memset((void *)(& from), 0, sizeof(from));
#line 61
          from4->sin_family = (unsigned short)2;
#line 62
          memcpy((void * __restrict  )(& from4->sin_addr), (void const   * __restrict  )(& addr),
                 sizeof(addr));
#line 63
          from4->sin_port = port;
        }
      }
    }
  }
#line 67
  if ((int )from.ss_family == 2) {
#line 68
    check_ip_options(socket___0, ntop);
  }
#line 70
  tmp___2 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )((void *)0),
                        0U, 1U);
#line 70
  if (tmp___2 != 0) {
#line 72
    fatal("get_remote_hostname: getnameinfo NI_NUMERICHOST failed");
  }
#line 74
  debug("Trying to reverse map address %.100s.", ntop);
#line 76
  tmp___4 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )(name), sizeof(name), (char * __restrict  )((void *)0),
                        0U, 8U);
#line 76
  if (tmp___4 != 0) {
#line 79
    log("Could not reverse map address %.100s.", ntop);
#line 80
    tmp___3 = xstrdup((char const   *)(ntop));
#line 80
    return (tmp___3);
  }
#line 84
  name[sizeof(name) - 1U] = (char )'\000';
#line 89
  i = 0;
#line 89
  while (name[i]) {
#line 90
    tmp___8 = __ctype_b_loc();
#line 90
    if ((int const   )*(*tmp___8 + (int )name[i]) & 256) {
#line 91
      if (sizeof(name[i]) > 1U) {
#line 91
        __res = tolower((int )name[i]);
      } else {
#line 91
        tmp___7 = __ctype_tolower_loc();
#line 91
        __res = (int )*(*tmp___7 + (int )name[i]);
      }
#line 91
      name[i] = (char )__res;
    }
#line 89
    i ++;
  }
#line 93
  if (! reverse_mapping_check) {
#line 94
    tmp___9 = xstrdup((char const   *)(name));
#line 94
    return (tmp___9);
  }
#line 104
  memset((void *)(& hints), 0, sizeof(hints));
#line 105
  hints.ai_family = (int )from.ss_family;
#line 106
  hints.ai_socktype = 1;
#line 107
  tmp___11 = getaddrinfo((char const   * __restrict  )(name), (char const   * __restrict  )((void *)0),
                         (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 107
  if (tmp___11 != 0) {
#line 108
    log("reverse mapping checking getaddrinfo for %.700s failed - POSSIBLE BREAKIN ATTEMPT!",
        name);
#line 110
    tmp___10 = xstrdup((char const   *)(ntop));
#line 110
    return (tmp___10);
  }
#line 113
  ai = aitop;
#line 113
  while (ai) {
#line 114
    tmp___12 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                           (char * __restrict  )(ntop2), sizeof(ntop2), (char * __restrict  )((void *)0),
                           0U, 1U);
#line 116
    if (tmp___12 == 0) {
#line 116
      if (0) {
#line 116
        __s1_len = strlen((char const   *)(ntop));
#line 116
        __s2_len = strlen((char const   *)(ntop2));
#line 116
        if (! ((unsigned int )((void const   *)(ntop + 1)) - (unsigned int )((void const   *)(ntop)) == 1U)) {
          goto _L___0;
        } else {
#line 116
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 116
            if (! ((unsigned int )((void const   *)(ntop2 + 1)) - (unsigned int )((void const   *)(ntop2)) == 1U)) {
#line 116
              tmp___22 = 1;
            } else {
#line 116
              if (__s2_len >= 4U) {
#line 116
                tmp___22 = 1;
              } else {
#line 116
                tmp___22 = 0;
              }
            }
          } else {
#line 116
            tmp___22 = 0;
          }
        }
#line 116
        if (tmp___22) {
#line 116
          tmp___18 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
        } else {
#line 116
          tmp___21 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
#line 116
          tmp___18 = tmp___21;
        }
      } else {
#line 116
        tmp___21 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
#line 116
        tmp___18 = tmp___21;
      }
#line 116
      if (tmp___18 == 0) {
#line 117
        break;
      }
    }
#line 113
    ai = ai->ai_next;
  }
#line 119
  freeaddrinfo(aitop);
#line 121
  if (! ai) {
#line 123
    log("Address %.100s maps to %.600s, but this does not map back to the address - POSSIBLE BREAKIN ATTEMPT!",
        ntop, name);
#line 126
    tmp___23 = xstrdup((char const   *)(ntop));
#line 126
    return (tmp___23);
  }
#line 128
  tmp___24 = xstrdup((char const   *)(name));
#line 128
  return (tmp___24);
}
}
#line 143 "canohost.c"
void check_ip_options(int socket___0 , char *ipaddr ) 
{ u_char options___0[200] ;
  char text[sizeof(options___0) * 3U + 1U] ;
  socklen_t option_size ;
  int i ;
  int ipproto ;
  struct protoent *ip ;
  int tmp ;

  {
#line 152
  ip = getprotobyname("ip");
#line 152
  if ((unsigned int )ip != (unsigned int )((void *)0)) {
#line 153
    ipproto = ip->p_proto;
  } else {
#line 155
    ipproto = 0;
  }
#line 156
  option_size = sizeof(options___0);
#line 157
  tmp = getsockopt(socket___0, ipproto, 4, (void * __restrict  )((void *)(options___0)),
                   (socklen_t * __restrict  )(& option_size));
#line 157
  if (tmp >= 0) {
#line 157
    if (option_size != 0U) {
#line 159
      text[0] = (char )'\000';
#line 160
      i = 0;
#line 160
      while ((socklen_t )i < option_size) {
#line 161
        snprintf((char * __restrict  )(text + i * 3), sizeof(text) - (unsigned int )(i * 3),
                 (char const   * __restrict  )" %2.2x", options___0[i]);
#line 160
        i ++;
      }
#line 163
      log("Connection from %.100s with IP options:%.800s", ipaddr, text);
#line 165
      packet_disconnect("Connection from %.100s with IP options:%.800s", ipaddr, text);
    }
  }
#line 168
  return;
}
}
#line 179 "canohost.c"
static char *canonical_host_name  =    (char *)((void *)0);
#line 180 "canohost.c"
static int reverse_mapping_checked  =    0;
#line 176 "canohost.c"
char const   *get_canonical_hostname(int reverse_mapping_check ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 183
  if ((unsigned int )canonical_host_name != (unsigned int )((void *)0)) {
#line 184
    if (reverse_mapping_checked != reverse_mapping_check) {
#line 185
      xfree((void *)canonical_host_name);
    } else {
#line 187
      return ((char const   *)canonical_host_name);
    }
  }
#line 191
  tmp___0 = packet_connection_is_on_socket();
#line 191
  if (tmp___0) {
#line 192
    tmp = packet_get_connection_in();
#line 192
    canonical_host_name = get_remote_hostname(tmp, reverse_mapping_check);
  } else {
#line 195
    canonical_host_name = xstrdup("UNKNOWN");
  }
#line 197
  reverse_mapping_checked = reverse_mapping_check;
#line 198
  return ((char const   *)canonical_host_name);
}
}
#line 206 "canohost.c"
char *get_peer_ipaddr(int socket___0 ) 
{ struct sockaddr_storage from ;
  socklen_t fromlen ;
  char ntop[1025] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 214
  fromlen = sizeof(from);
#line 215
  memset((void *)(& from), 0, sizeof(from));
#line 216
  tmp___1 = getpeername(socket___0, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                        (socklen_t * __restrict  )(& fromlen));
#line 216
  if (tmp___1 < 0) {
#line 217
    tmp = __errno_location();
#line 217
    tmp___0 = strerror(*tmp);
#line 217
    debug("get_peer_ipaddr: getpeername failed: %.100s", tmp___0);
#line 218
    return ((char *)((void *)0));
  }
#line 221
  tmp___2 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )((void *)0),
                        0U, 1U);
#line 221
  if (tmp___2 != 0) {
#line 223
    error("get_peer_ipaddr: getnameinfo NI_NUMERICHOST failed");
#line 224
    return ((char *)((void *)0));
  }
#line 226
  tmp___3 = xstrdup((char const   *)(ntop));
#line 226
  return (tmp___3);
}
}
#line 237 "canohost.c"
static char *canonical_host_ip  =    (char *)((void *)0);
#line 234 "canohost.c"
char const   *get_remote_ipaddr(void) 
{ int tmp ;
  int tmp___0 ;

  {
#line 240
  if ((unsigned int )canonical_host_ip == (unsigned int )((void *)0)) {
#line 241
    tmp___0 = packet_connection_is_on_socket();
#line 241
    if (tmp___0) {
#line 242
      tmp = packet_get_connection_in();
#line 242
      canonical_host_ip = get_peer_ipaddr(tmp);
#line 244
      if ((unsigned int )canonical_host_ip == (unsigned int )((void *)0)) {
#line 245
        fatal_cleanup();
      }
    } else {
#line 248
      canonical_host_ip = xstrdup("UNKNOWN");
    }
  }
#line 251
  return ((char const   *)canonical_host_ip);
}
}
#line 256 "canohost.c"
int get_sock_port(int sock , int local ) 
{ struct sockaddr_storage from ;
  socklen_t fromlen ;
  char strport[32] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 264
  fromlen = sizeof(from);
#line 265
  memset((void *)(& from), 0, sizeof(from));
#line 266
  if (local) {
#line 267
    tmp___1 = getsockname(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 267
    if (tmp___1 < 0) {
#line 268
      tmp = __errno_location();
#line 268
      tmp___0 = strerror(*tmp);
#line 268
      error("getsockname failed: %.100s", tmp___0);
#line 269
      return (0);
    }
  } else {
#line 272
    tmp___4 = getpeername(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 272
    if (tmp___4 < 0) {
#line 273
      tmp___2 = __errno_location();
#line 273
      tmp___3 = strerror(*tmp___2);
#line 273
      debug("getpeername failed: %.100s", tmp___3);
#line 274
      fatal_cleanup();
    }
  }
#line 278
  tmp___5 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )((void *)0), 0U, (char * __restrict  )(strport),
                        sizeof(strport), 2U);
#line 278
  if (tmp___5 != 0) {
#line 280
    fatal("get_sock_port: getnameinfo NI_NUMERICSERV failed");
  }
#line 281
  tmp___6 = atoi((char const   *)(strport));
#line 281
  return (tmp___6);
}
}
#line 286 "canohost.c"
int get_port(int local ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 293
  tmp = packet_connection_is_on_socket();
#line 293
  if (! tmp) {
#line 294
    return (65535);
  }
#line 297
  tmp___0 = packet_get_connection_in();
#line 297
  tmp___1 = get_sock_port(tmp___0, local);
#line 297
  return (tmp___1);
}
}
#line 300 "canohost.c"
int get_peer_port(int sock ) 
{ int tmp ;

  {
#line 303
  tmp = get_sock_port(sock, 0);
#line 303
  return (tmp);
}
}
#line 306 "canohost.c"
int get_remote_port(void) 
{ int tmp ;

  {
#line 309
  tmp = get_port(0);
#line 309
  return (tmp);
}
}
#line 312 "canohost.c"
int get_local_port(void) 
{ int tmp ;

  {
#line 315
  tmp = get_port(1);
#line 315
  return (tmp);
}
}
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned int  ) ;  */
#line 1 "channels.o"
#pragma merger(0,"./channels.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 192 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 199
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 209
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 218
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
#line 62 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 102
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 170
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 573 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 745
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 801
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 845
extern  __attribute__((__nothrow__)) int gethostname(char *__name , size_t __len )  __attribute__((__nonnull__(1))) ;
#line 67 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 407 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 632
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) )  __attribute__((__nonnull__(1))) ;
#line 729
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template )  __attribute__((__nonnull__(1))) ;
#line 640 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
#line 71 "packet.h"
int packet_is_interactive(void) ;
#line 74
void packet_start(int type ) ;
#line 77
void packet_put_char(int value ) ;
#line 80
void packet_put_int(u_int value ) ;
#line 87
void packet_put_string(char const   *buf___2 , u_int len ) ;
#line 88
void packet_put_cstring(char const   *str ) ;
#line 95
void packet_send(void) ;
#line 98
int packet_read(int *payload_len_ptr ) ;
#line 126
u_int packet_get_int(void) ;
#line 142
char *packet_get_string(u_int *length_ptr ) ;
#line 162
void ( /* format attribute */  packet_send_debug)(char const   *fmt  , ...) ;
#line 168
void packet_write_wait(void) ;
#line 177
int max_packet_size ;
#line 215
int packet_remaining(void) ;
#line 22 "uidswap.h"
void temporarily_use_uid(uid_t uid ) ;
#line 28
void restore_uid(void) ;
#line 60 "log.h"
void ( /* format attribute */  verbose)(char const   *fmt  , ...) ;
#line 62
void ( /* format attribute */  debug2)(char const   *fmt  , ...) ;
#line 73
void fatal_add_cleanup(void (*proc)(void *context ) , void *context ) ;
#line 21 "misc.h"
void set_nonblock(int fd ) ;
#line 123 "channels.h"
void channel_open(int id ) ;
#line 124
void channel_request(int id , char *service , int wantconfirm ) ;
#line 125
void channel_request_start(int id , char *service , int wantconfirm ) ;
#line 126
void channel_register_callback(int id , int mtype , channel_callback_fn *fn , void *arg ) ;
#line 127
void channel_register_cleanup(int id , channel_callback_fn *fn ) ;
#line 128
void channel_register_filter(int id , channel_filter_fn *fn ) ;
#line 129
void channel_cancel_cleanup(int id ) ;
#line 130
Channel *channel_lookup(int id ) ;
#line 132
int channel_new(char *ctype , int type , int rfd , int wfd , int efd , int window ,
                int maxpack , int extusage , char *remote_name , int nonblock ) ;
#line 136
void channel_set_fds(int id , int rfd , int wfd , int efd , int extusage , int nonblock ) ;
#line 140
void deny_input_open(int type , int plen , void *ctxt ) ;
#line 142
void channel_input_channel_request(int type , int plen , void *ctxt ) ;
#line 143
void channel_input_close(int type , int plen , void *ctxt ) ;
#line 144
void channel_input_close_confirmation(int type , int plen , void *ctxt ) ;
#line 145
void channel_input_data(int type , int plen , void *ctxt ) ;
#line 146
void channel_input_extended_data(int type , int plen , void *ctxt ) ;
#line 147
void channel_input_ieof(int type , int plen , void *ctxt ) ;
#line 148
void channel_input_oclose(int type , int plen , void *ctxt ) ;
#line 149
void channel_input_open_confirmation(int type , int plen , void *ctxt ) ;
#line 150
void channel_input_open_failure(int type , int plen , void *ctxt ) ;
#line 151
void channel_input_port_open(int type , int plen , void *ctxt ) ;
#line 152
void channel_input_window_adjust(int type , int plen , void *ctxt ) ;
#line 155
void channel_set_options(int hostname_in_open ) ;
#line 162
int channel_allocate(int type , int sock , char *remote_name ) ;
#line 165
void channel_free(int id ) ;
#line 171
void channel_prepare_select(fd_set **readsetp , fd_set **writesetp , int *maxfdp ) ;
#line 178
void channel_after_select(fd_set *readset , fd_set *writeset ) ;
#line 181
void channel_output_poll(void) ;
#line 184
int channel_not_very_much_buffered_data(void) ;
#line 188
void channel_stop_listening(void) ;
#line 194
void channel_close_all(void) ;
#line 197
int channel_still_open(void) ;
#line 204
char *channel_open_message(void) ;
#line 210
int channel_request_local_forwarding(u_short listen_port , char const   *host_to_connect ,
                                     u_short port_to_connect , int gateway_ports ) ;
#line 213
int channel_request_forwarding(char const   *listen_address , u_short listen_port ,
                               char const   *host_to_connect , u_short port_to_connect ,
                               int gateway_ports , int remote_fwd ) ;
#line 224
void channel_request_remote_forwarding(u_short listen_port , char const   *host_to_connect ,
                                       u_short port_to_connect ) ;
#line 233
void channel_permit_all_opens(void) ;
#line 240
void channel_input_port_forward_request(int is_root , int gateway_ports ) ;
#line 253
char *x11_create_display_inet(int screen_number , int x11_display_offset ) ;
#line 260
void x11_input_open(int type , int plen , void *ctxt ) ;
#line 272
void x11_request_forwarding_with_spoofing(int client_session_id , char const   *proto ,
                                          char const   *data ) ;
#line 277
void auth_request_forwarding(void) ;
#line 284
char *auth_get_socket_name(void) ;
#line 290
int auth_input_request_forwarding(struct passwd *pw ) ;
#line 293
void auth_input_open_request(int type , int plen , void *ctxt ) ;
#line 296
int channel_connect_to(char const   *host , u_short host_port ) ;
#line 297
int channel_connect_by_listen_adress(u_short listen_port ) ;
#line 298
int x11_connect_display(void) ;
#line 78 "nchan.h"
chan_event_fn *chan_rcvd_oclose ;
#line 79
chan_event_fn *chan_read_failed ;
#line 80
chan_event_fn *chan_ibuf_empty ;
#line 83
chan_event_fn *chan_rcvd_ieof ;
#line 84
chan_event_fn *chan_write_failed ;
#line 85
chan_event_fn *chan_obuf_empty ;
#line 87
chan_event_fn *chan_delete_if_full_closed ;
#line 89
void chan_init_iostates(Channel *c ) ;
#line 90
void chan_init(void) ;
#line 48 "compat.h"
int compat13 ;
#line 49
int compat20 ;
#line 74 "channels.c"
static Channel *channels  =    (Channel *)((void *)0);
#line 81 "channels.c"
static int channels_alloc  =    0;
#line 87 "channels.c"
static int channel_max_fd  =    0;
#line 90 "channels.c"
static char *channel_forwarded_auth_socket_name  =    (char *)((void *)0);
#line 91 "channels.c"
static char *channel_forwarded_auth_socket_dir  =    (char *)((void *)0);
#line 94 "channels.c"
char *x11_saved_proto  =    (char *)((void *)0);
#line 97 "channels.c"
char *x11_saved_data  =    (char *)((void *)0);
#line 98 "channels.c"
u_int x11_saved_data_len  =    (u_int )0;
#line 104 "channels.c"
char *x11_fake_data  =    (char *)((void *)0);
#line 105 "channels.c"
u_int x11_fake_data_len  ;
#line 120 "channels.c"
static ForwardPermission permitted_opens[100]  ;
#line 122 "channels.c"
static int num_permitted_opens  =    0;
#line 128 "channels.c"
static int all_opens_permitted  =    0;
#line 131 "channels.c"
static int have_hostname_in_open  =    0;
#line 134
int IPv4or6 ;
#line 138 "channels.c"
void channel_set_options(int hostname_in_open ) 
{ 

  {
#line 141
  have_hostname_in_open = hostname_in_open;
#line 142
  return;
}
}
#line 150 "channels.c"
void channel_permit_all_opens(void) 
{ 

  {
#line 153
  all_opens_permitted = 1;
#line 154
  return;
}
}
#line 158 "channels.c"
Channel *channel_lookup(int id ) 
{ Channel *c ;

  {
#line 162
  if (id < 0) {
#line 163
    log("channel_lookup: %d: bad id", id);
#line 164
    return ((Channel *)((void *)0));
  } else {
#line 162
    if (id > channels_alloc) {
#line 163
      log("channel_lookup: %d: bad id", id);
#line 164
      return ((Channel *)((void *)0));
    }
  }
#line 166
  c = channels + id;
#line 167
  if (c->type == 0) {
#line 168
    log("channel_lookup: %d: bad id: channel free", id);
#line 169
    return ((Channel *)((void *)0));
  }
#line 171
  return (c);
}
}
#line 179 "channels.c"
void channel_register_fds(Channel *c , int rfd , int wfd , int efd , int extusage ,
                          int nonblock ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 184
  if (channel_max_fd > rfd) {
#line 184
    channel_max_fd = channel_max_fd;
  } else {
#line 184
    channel_max_fd = rfd;
  }
#line 185
  if (channel_max_fd > wfd) {
#line 185
    channel_max_fd = channel_max_fd;
  } else {
#line 185
    channel_max_fd = wfd;
  }
#line 186
  if (channel_max_fd > efd) {
#line 186
    channel_max_fd = channel_max_fd;
  } else {
#line 186
    channel_max_fd = efd;
  }
#line 190
  c->rfd = rfd;
#line 191
  c->wfd = wfd;
#line 192
  if (rfd == wfd) {
#line 192
    c->sock = rfd;
  } else {
#line 192
    c->sock = -1;
  }
#line 193
  c->efd = efd;
#line 194
  c->extended_usage = extusage;
#line 197
  if (nonblock) {
#line 197
    tmp___0 = isatty(c->rfd);
#line 197
    if (tmp___0) {
#line 198
      debug("channel: %d: rfd %d isatty", c->self, c->rfd);
#line 199
      c->isatty = 1;
#line 200
      tmp = isatty(c->wfd);
#line 200
      if (! tmp) {
#line 201
        error("channel: %d: wfd %d is not a tty?", c->self, c->wfd);
      }
    } else {
#line 205
      c->isatty = 0;
    }
  } else {
#line 205
    c->isatty = 0;
  }
#line 209
  if (nonblock) {
#line 210
    if (rfd != -1) {
#line 211
      set_nonblock(rfd);
    }
#line 212
    if (wfd != -1) {
#line 213
      set_nonblock(wfd);
    }
#line 214
    if (efd != -1) {
#line 215
      set_nonblock(efd);
    }
  }
#line 217
  return;
}
}
#line 224 "channels.c"
int channel_new(char *ctype , int type , int rfd , int wfd , int efd , int window ,
                int maxpack , int extusage , char *remote_name , int nonblock ) 
{ int i ;
  int found ;
  Channel *c ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 232
  if (channels_alloc == 0) {
#line 233
    chan_init();
#line 234
    channels_alloc = 10;
#line 235
    tmp = xmalloc((unsigned int )channels_alloc * sizeof(Channel ));
#line 235
    channels = (Channel *)tmp;
#line 236
    i = 0;
#line 236
    while (i < channels_alloc) {
#line 237
      (channels + i)->type = 0;
#line 236
      i ++;
    }
#line 242
    fatal_add_cleanup((void (*)(void * ))(& channel_stop_listening), (void *)0);
  }
#line 245
  found = -1;
#line 245
  i = 0;
#line 245
  while (i < channels_alloc) {
#line 246
    if ((channels + i)->type == 0) {
#line 248
      found = i;
#line 249
      break;
    }
#line 245
    i ++;
  }
#line 251
  if (found == -1) {
#line 253
    found = channels_alloc;
#line 254
    channels_alloc += 10;
#line 255
    debug2("channel: expanding %d", channels_alloc);
#line 256
    tmp___0 = xrealloc((void *)channels, (unsigned int )channels_alloc * sizeof(Channel ));
#line 256
    channels = (Channel *)tmp___0;
#line 257
    i = found;
#line 257
    while (i < channels_alloc) {
#line 258
      (channels + i)->type = 0;
#line 257
      i ++;
    }
  }
#line 261
  c = channels + found;
#line 262
  buffer_init(& c->input);
#line 263
  buffer_init(& c->output);
#line 264
  buffer_init(& c->extended);
#line 265
  chan_init_iostates(c);
#line 266
  channel_register_fds(c, rfd, wfd, efd, extusage, nonblock);
#line 267
  c->self = found;
#line 268
  c->type = type;
#line 269
  c->ctype = ctype;
#line 270
  c->local_window = window;
#line 271
  c->local_window_max = window;
#line 272
  c->local_consumed = 0;
#line 273
  c->local_maxpacket = maxpack;
#line 274
  c->remote_id = -1;
#line 275
  c->remote_name = remote_name;
#line 276
  c->remote_window = 0;
#line 277
  c->remote_maxpacket = 0;
#line 278
  c->cb_fn = (channel_callback_fn *)((void *)0);
#line 279
  c->cb_arg = (void *)0;
#line 280
  c->cb_event = 0;
#line 281
  c->dettach_user = (channel_callback_fn *)((void *)0);
#line 282
  c->input_filter = (channel_filter_fn *)((void *)0);
#line 283
  debug("channel %d: new [%s]", found, remote_name);
#line 284
  return (found);
}
}
#line 287 "channels.c"
int channel_allocate(int type , int sock , char *remote_name ) 
{ int tmp ;

  {
#line 290
  tmp = channel_new((char *)"", type, sock, sock, -1, 0, 0, 0, remote_name, 1);
#line 290
  return (tmp);
}
}
#line 296 "channels.c"
void channel_close_fds(Channel *c ) 
{ 

  {
#line 299
  if (c->sock != -1) {
#line 300
    close(c->sock);
#line 301
    c->sock = -1;
  }
#line 303
  if (c->rfd != -1) {
#line 304
    close(c->rfd);
#line 305
    c->rfd = -1;
  }
#line 307
  if (c->wfd != -1) {
#line 308
    close(c->wfd);
#line 309
    c->wfd = -1;
  }
#line 311
  if (c->efd != -1) {
#line 312
    close(c->efd);
#line 313
    c->efd = -1;
  }
#line 315
  return;
}
}
#line 319 "channels.c"
void channel_free(int id ) 
{ Channel *c ;
  Channel *tmp ;
  char *s ;
  char *tmp___0 ;

  {
#line 322
  tmp = channel_lookup(id);
#line 322
  c = tmp;
#line 323
  tmp___0 = channel_open_message();
#line 323
  s = tmp___0;
#line 325
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 326
    packet_disconnect("channel free: bad local channel %d", id);
  }
#line 327
  debug("channel_free: channel %d: status: %s", id, s);
#line 328
  xfree((void *)s);
#line 330
  if ((unsigned int )c->dettach_user != (unsigned int )((void *)0)) {
#line 331
    debug("channel_free: channel %d: dettaching channel user", id);
#line 332
    (*(c->dettach_user))(c->self, (void *)0);
  }
#line 334
  if (c->sock != -1) {
#line 335
    shutdown(c->sock, 2);
  }
#line 336
  channel_close_fds(c);
#line 337
  buffer_free(& c->input);
#line 338
  buffer_free(& c->output);
#line 339
  buffer_free(& c->extended);
#line 340
  c->type = 0;
#line 341
  if (c->remote_name) {
#line 342
    xfree((void *)c->remote_name);
#line 343
    c->remote_name = (char *)((void *)0);
  }
#line 345
  return;
}
}
#line 356 "channels.c"
chan_fn *channel_pre[13]  ;
#line 357 "channels.c"
chan_fn *channel_post[13]  ;
#line 359 "channels.c"
void channel_pre_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 362
  __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 363
  return;
}
}
#line 365 "channels.c"
void channel_pre_connecting(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 368
  debug3("channel %d: waiting for connection", c->self);
#line 369
  __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 370
  return;
}
}
#line 372 "channels.c"
void channel_pre_open_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int tmp ;
  u_int tmp___0 ;

  {
#line 375
  tmp = buffer_len(& c->input);
#line 375
  if (tmp < (u_int )max_packet_size) {
#line 376
    __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 377
  tmp___0 = buffer_len(& c->output);
#line 377
  if (tmp___0 > 0U) {
#line 378
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 379
  return;
}
}
#line 381 "channels.c"
void channel_pre_open_15(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int tmp ;
  u_int tmp___0 ;

  {
#line 385
  if (c->istate == 1) {
#line 386
    tmp = buffer_len(& c->input);
#line 386
    if (tmp < (u_int )max_packet_size) {
#line 387
      __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
  }
#line 388
  if (c->ostate == 16) {
    goto _L;
  } else {
#line 388
    if (c->ostate == 32) {
      _L: /* CIL Label */ 
#line 390
      tmp___0 = buffer_len(& c->output);
#line 390
      if (tmp___0 > 0U) {
#line 391
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      } else {
#line 392
        if (c->ostate == 32) {
#line 393
          (*chan_obuf_empty)(c);
        }
      }
    }
  }
#line 396
  return;
}
}
#line 398 "channels.c"
void channel_pre_open_20(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;

  {
#line 401
  if (c->istate == 1) {
#line 401
    if (c->remote_window > 0) {
#line 401
      tmp = buffer_len(& c->input);
#line 401
      if (tmp < (u_int )c->remote_window) {
#line 404
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->rfd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->rfd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
  }
#line 405
  if (c->ostate == 16) {
    goto _L;
  } else {
#line 405
    if (c->ostate == 32) {
      _L: /* CIL Label */ 
#line 407
      tmp___0 = buffer_len(& c->output);
#line 407
      if (tmp___0 > 0U) {
#line 408
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->wfd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->wfd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      } else {
#line 409
        if (c->ostate == 32) {
#line 410
          (*chan_obuf_empty)(c);
        }
      }
    }
  }
#line 414
  if (c->efd != -1) {
#line 415
    if (c->extended_usage == 2) {
#line 415
      tmp___2 = buffer_len(& c->extended);
#line 415
      if (tmp___2 > 0U) {
#line 417
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 418
      if (c->extended_usage == 1) {
#line 418
        tmp___1 = buffer_len(& c->extended);
#line 418
        if (tmp___1 < (u_int )c->remote_window) {
#line 420
          __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        }
      }
    }
  }
#line 422
  return;
}
}
#line 424 "channels.c"
void channel_pre_input_draining(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int tmp ;

  {
#line 427
  tmp = buffer_len(& c->input);
#line 427
  if (tmp == 0U) {
#line 428
    packet_start(24);
#line 429
    packet_put_int((unsigned int )c->remote_id);
#line 430
    packet_send();
#line 431
    c->type = 5;
#line 432
    debug("Closing channel %d after input drain.", c->self);
  }
#line 434
  return;
}
}
#line 436 "channels.c"
void channel_pre_output_draining(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int tmp ;

  {
#line 439
  tmp = buffer_len(& c->output);
#line 439
  if (tmp == 0U) {
#line 440
    channel_free(c->self);
  } else {
#line 442
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 443
  return;
}
}
#line 453 "channels.c"
int x11_open_helper(Channel *c ) 
{ u_char *ucp ;
  u_int proto_len ;
  u_int data_len ;
  u_int tmp ;
  char *tmp___0 ;
  u_int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 460
  tmp = buffer_len(& c->output);
#line 460
  if (tmp < 12U) {
#line 461
    return (0);
  }
#line 464
  tmp___0 = buffer_ptr(& c->output);
#line 464
  ucp = (u_char *)tmp___0;
#line 465
  if ((int )*(ucp + 0) == 66) {
#line 466
    proto_len = (unsigned int )(256 * (int )*(ucp + 6) + (int )*(ucp + 7));
#line 467
    data_len = (unsigned int )(256 * (int )*(ucp + 8) + (int )*(ucp + 9));
  } else {
#line 468
    if ((int )*(ucp + 0) == 108) {
#line 469
      proto_len = (unsigned int )((int )*(ucp + 6) + 256 * (int )*(ucp + 7));
#line 470
      data_len = (unsigned int )((int )*(ucp + 8) + 256 * (int )*(ucp + 9));
    } else {
#line 472
      debug("Initial X11 packet contains bad byte order byte: 0x%x", *(ucp + 0));
#line 474
      return (-1);
    }
  }
#line 478
  tmp___1 = buffer_len(& c->output);
#line 478
  if (tmp___1 < (12U + ((proto_len + 3U) & 4294967292U)) + ((data_len + 3U) & 4294967292U)) {
#line 480
    return (0);
  }
#line 483
  tmp___2 = strlen((char const   *)x11_saved_proto);
#line 483
  if (proto_len != tmp___2) {
#line 485
    debug("X11 connection uses different authentication protocol.");
#line 486
    return (-1);
  } else {
#line 483
    tmp___3 = memcmp((void const   *)(ucp + 12), (void const   *)x11_saved_proto,
                     proto_len);
#line 483
    if (tmp___3 != 0) {
#line 485
      debug("X11 connection uses different authentication protocol.");
#line 486
      return (-1);
    }
  }
#line 489
  if (data_len != x11_fake_data_len) {
#line 492
    debug("X11 auth data does not match fake data.");
#line 493
    return (-1);
  } else {
#line 489
    tmp___4 = memcmp((void const   *)((ucp + 12) + ((proto_len + 3U) & 4294967292U)),
                     (void const   *)x11_fake_data, x11_fake_data_len);
#line 489
    if (tmp___4 != 0) {
#line 492
      debug("X11 auth data does not match fake data.");
#line 493
      return (-1);
    }
  }
#line 496
  if (x11_fake_data_len != x11_saved_data_len) {
#line 497
    error("X11 fake_data_len %d != saved_data_len %d", x11_fake_data_len, x11_saved_data_len);
#line 499
    return (-1);
  }
#line 506
  memcpy((void * __restrict  )((ucp + 12) + ((proto_len + 3U) & 4294967292U)), (void const   * __restrict  )x11_saved_data,
         x11_saved_data_len);
#line 508
  return (1);
}
}
#line 511 "channels.c"
void channel_pre_x11_open_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int ret ;
  int tmp ;

  {
#line 514
  tmp = x11_open_helper(c);
#line 514
  ret = tmp;
#line 515
  if (ret == 1) {
#line 517
    c->type = 4;
#line 518
    channel_pre_open_13(c, readset, writeset);
  } else {
#line 519
    if (ret == -1) {
#line 524
      log("X11 connection rejected because of wrong authentication.\r\n");
#line 525
      buffer_clear(& c->input);
#line 526
      buffer_clear(& c->output);
#line 527
      close(c->sock);
#line 528
      c->sock = -1;
#line 529
      c->type = 5;
#line 530
      packet_start(24);
#line 531
      packet_put_int((unsigned int )c->remote_id);
#line 532
      packet_send();
    }
  }
#line 534
  return;
}
}
#line 536 "channels.c"
void channel_pre_x11_open(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int ret ;
  int tmp ;

  {
#line 539
  tmp = x11_open_helper(c);
#line 539
  ret = tmp;
#line 540
  if (ret == 1) {
#line 541
    c->type = 4;
#line 542
    if (compat20) {
#line 543
      channel_pre_open_20(c, readset, writeset);
    } else {
#line 545
      channel_pre_open_15(c, readset, writeset);
    }
  } else {
#line 546
    if (ret == -1) {
#line 547
      debug("X11 rejected %d i%d/o%d", c->self, c->istate, c->ostate);
#line 548
      (*chan_read_failed)(c);
#line 549
      (*chan_write_failed)(c);
#line 550
      debug("X11 closed %d i%d/o%d", c->self, c->istate, c->ostate);
    }
  }
#line 552
  return;
}
}
#line 555 "channels.c"
void channel_post_x11_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ struct sockaddr addr ;
  int newsock ;
  int newch ;
  socklen_t addrlen ;
  char buf___2[16384] ;
  char *remote_ipaddr ;
  int remote_port ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  register char __result ;

  {
#line 564
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 564
  if (__result) {
#line 565
    debug("X11 connection requested.");
#line 566
    addrlen = sizeof(addr);
#line 567
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 568
    if (newsock < 0) {
#line 569
      tmp = __errno_location();
#line 569
      tmp___0 = strerror(*tmp);
#line 569
      error("accept: %.100s", tmp___0);
#line 570
      return;
    }
#line 572
    remote_ipaddr = get_peer_ipaddr(newsock);
#line 573
    remote_port = get_peer_port(newsock);
#line 574
    snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"X11 connection from %.200s port %d",
             remote_ipaddr, remote_port);
#line 577
    tmp___1 = xstrdup((char const   *)(buf___2));
#line 577
    newch = channel_new((char *)"x11", 3, newsock, newsock, -1, c->local_window_max,
                        c->local_maxpacket, 0, tmp___1, 1);
#line 581
    if (compat20) {
#line 582
      packet_start(90);
#line 583
      packet_put_cstring("x11");
#line 584
      packet_put_int((unsigned int )newch);
#line 585
      packet_put_int((unsigned int )c->local_window_max);
#line 586
      packet_put_int((unsigned int )c->local_maxpacket);
#line 588
      packet_put_cstring((char const   *)remote_ipaddr);
#line 589
      if (datafellows & 8) {
#line 590
        debug("ssh2 x11 bug compat mode");
      } else {
#line 592
        packet_put_int((unsigned int )remote_port);
      }
#line 594
      packet_send();
    } else {
#line 596
      packet_start(27);
#line 597
      packet_put_int((unsigned int )newch);
#line 598
      if (have_hostname_in_open) {
#line 599
        tmp___2 = strlen((char const   *)(buf___2));
#line 599
        packet_put_string((char const   *)(buf___2), tmp___2);
      }
#line 600
      packet_send();
    }
#line 602
    xfree((void *)remote_ipaddr);
  }
#line 604
  return;
}
}
#line 609 "channels.c"
void channel_post_port_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ struct sockaddr addr ;
  int newsock ;
  int newch ;
  socklen_t addrlen ;
  char buf___2[1024] ;
  char *remote_ipaddr ;
  char *rtype ;
  int remote_port ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  register char __result ;

  {
#line 618
  if (c->type == 11) {
#line 618
    rtype = (char *)"forwarded-tcpip";
  } else {
#line 618
    rtype = (char *)"direct-tcpip";
  }
#line 621
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 621
  if (__result) {
#line 622
    debug("Connection to port %d forwarding to %.100s port %d requested.", c->listening_port,
          c->path, c->host_port);
#line 625
    addrlen = sizeof(addr);
#line 626
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 627
    if (newsock < 0) {
#line 628
      tmp = __errno_location();
#line 628
      tmp___0 = strerror(*tmp);
#line 628
      error("accept: %.100s", tmp___0);
#line 629
      return;
    }
#line 631
    remote_ipaddr = get_peer_ipaddr(newsock);
#line 632
    remote_port = get_peer_port(newsock);
#line 633
    snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"listen port %d for %.100s port %d, connect from %.200s port %d",
             c->listening_port, c->path, c->host_port, remote_ipaddr, remote_port);
#line 639
    tmp___1 = xstrdup((char const   *)(buf___2));
#line 639
    newch = channel_new(rtype, 3, newsock, newsock, -1, c->local_window_max, c->local_maxpacket,
                        0, tmp___1, 1);
#line 643
    if (compat20) {
#line 644
      packet_start(90);
#line 645
      packet_put_cstring((char const   *)rtype);
#line 646
      packet_put_int((unsigned int )newch);
#line 647
      packet_put_int((unsigned int )c->local_window_max);
#line 648
      packet_put_int((unsigned int )c->local_maxpacket);
#line 649
      if (c->type == 11) {
#line 651
        tmp___2 = strlen((char const   *)(c->path));
#line 651
        packet_put_string((char const   *)(c->path), tmp___2);
#line 652
        packet_put_int((unsigned int )c->listening_port);
      } else {
#line 655
        tmp___3 = strlen((char const   *)(c->path));
#line 655
        packet_put_string((char const   *)(c->path), tmp___3);
#line 656
        packet_put_int((unsigned int )c->host_port);
      }
#line 659
      packet_put_cstring((char const   *)remote_ipaddr);
#line 660
      packet_put_int((unsigned int )remote_port);
#line 661
      packet_send();
    } else {
#line 663
      packet_start(29);
#line 664
      packet_put_int((unsigned int )newch);
#line 665
      tmp___4 = strlen((char const   *)(c->path));
#line 665
      packet_put_string((char const   *)(c->path), tmp___4);
#line 666
      packet_put_int((unsigned int )c->host_port);
#line 667
      if (have_hostname_in_open) {
#line 668
        tmp___5 = strlen((char const   *)(buf___2));
#line 668
        packet_put_string((char const   *)(buf___2), tmp___5);
      }
#line 670
      packet_send();
    }
#line 672
    xfree((void *)remote_ipaddr);
  }
#line 674
  return;
}
}
#line 680 "channels.c"
void channel_post_auth_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ struct sockaddr addr ;
  int newsock ;
  int newch ;
  socklen_t addrlen ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  register char __result ;

  {
#line 687
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 687
  if (__result) {
#line 688
    addrlen = sizeof(addr);
#line 689
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 690
    if (newsock < 0) {
#line 691
      tmp = __errno_location();
#line 691
      tmp___0 = strerror(*tmp);
#line 691
      error("accept from auth socket: %.100s", tmp___0);
#line 692
      return;
    }
#line 694
    tmp___1 = xstrdup("accepted auth socket");
#line 694
    newch = channel_new((char *)"accepted auth socket", 3, newsock, newsock, -1, c->local_window_max,
                        c->local_maxpacket, 0, tmp___1, 1);
#line 698
    if (compat20) {
#line 699
      packet_start(90);
#line 700
      packet_put_cstring("auth-agent@openssh.com");
#line 701
      packet_put_int((unsigned int )newch);
#line 702
      packet_put_int((unsigned int )c->local_window_max);
#line 703
      packet_put_int((unsigned int )c->local_maxpacket);
    } else {
#line 705
      packet_start(31);
#line 706
      packet_put_int((unsigned int )newch);
    }
#line 708
    packet_send();
  }
#line 710
  return;
}
}
#line 712 "channels.c"
void channel_post_connecting(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int err ;
  int sz ;
  char *tmp ;
  int tmp___0 ;
  register char __result ;

  {
#line 715
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 715
  if (__result) {
#line 716
    err = 0;
#line 717
    sz = (int )sizeof(err);
#line 718
    c->type = 4;
#line 719
    tmp___0 = getsockopt(c->sock, 1, 4, (void * __restrict  )((char *)(& err)), (socklen_t * __restrict  )(& sz));
#line 719
    if (tmp___0 < 0) {
#line 720
      debug("getsockopt SO_ERROR failed");
    } else {
#line 722
      if (err == 0) {
#line 723
        debug("channel %d: connected)", c->self);
      } else {
#line 725
        tmp = strerror(err);
#line 725
        debug("channel %d: not connected: %s", c->self, tmp);
#line 727
        (*chan_read_failed)(c);
#line 728
        (*chan_write_failed)(c);
      }
    }
  }
#line 732
  return;
}
}
#line 734 "channels.c"
int channel_handle_rfd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char buf___2[16384] ;
  int len ;
  int *tmp ;
  int *tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;
  register char __result ;

  {
#line 741
  if (c->rfd != -1) {
#line 741
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->rfd % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )c->rfd / (8U * sizeof(__fd_mask ))]): "cc");
#line 741
    if (__result) {
#line 742
      len = read(c->rfd, (void *)(buf___2), sizeof(buf___2));
#line 743
      if (len < 0) {
#line 743
        tmp = __errno_location();
#line 743
        if (*tmp == 4) {
#line 744
          return (1);
        } else {
#line 743
          tmp___0 = __errno_location();
#line 743
          if (*tmp___0 == 11) {
#line 744
            return (1);
          }
        }
      }
#line 745
      if (len <= 0) {
#line 746
        debug("channel %d: read<=0 rfd %d len %d", c->self, c->rfd, len);
#line 748
        if (compat13) {
#line 749
          tmp___1 = buffer_len(& c->output);
#line 749
          buffer_consume(& c->output, tmp___1);
#line 750
          c->type = 8;
#line 751
          debug("Channel %d status set to input draining.", c->self);
        } else {
#line 753
          (*chan_read_failed)(c);
        }
#line 755
        return (-1);
      }
#line 757
      if ((unsigned int )c->input_filter != (unsigned int )((void *)0)) {
#line 758
        tmp___2 = (*(c->input_filter))(c, buf___2, len);
#line 758
        if (tmp___2 == -1) {
#line 759
          debug("filter stops channel %d", c->self);
#line 760
          (*chan_read_failed)(c);
        }
      } else {
#line 763
        buffer_append(& c->input, (char const   *)(buf___2), (unsigned int )len);
      }
    }
  }
#line 766
  return (1);
}
}
#line 768 "channels.c"
int channel_handle_wfd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int len ;
  u_int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  u_int tmp___3 ;
  struct termios tio ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  register char __result ;
  u_int tmp___7 ;

  {
#line 775
  if (c->wfd != -1) {
#line 775
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->wfd % (8U * sizeof(__fd_mask ))),
                         "m" (writeset->__fds_bits[(unsigned int )c->wfd / (8U * sizeof(__fd_mask ))]): "cc");
#line 775
    if (__result) {
#line 775
      tmp___7 = buffer_len(& c->output);
#line 775
      if (tmp___7 > 0U) {
#line 777
        tmp = buffer_len(& c->output);
#line 777
        tmp___0 = buffer_ptr(& c->output);
#line 777
        len = write(c->wfd, (void const   *)tmp___0, tmp);
#line 779
        if (len < 0) {
#line 779
          tmp___1 = __errno_location();
#line 779
          if (*tmp___1 == 4) {
#line 780
            return (1);
          } else {
#line 779
            tmp___2 = __errno_location();
#line 779
            if (*tmp___2 == 11) {
#line 780
              return (1);
            }
          }
        }
#line 781
        if (len <= 0) {
#line 782
          if (compat13) {
#line 783
            tmp___3 = buffer_len(& c->output);
#line 783
            buffer_consume(& c->output, tmp___3);
#line 784
            debug("Channel %d status set to input draining.", c->self);
#line 785
            c->type = 8;
          } else {
#line 787
            (*chan_write_failed)(c);
          }
#line 789
          return (-1);
        }
#line 791
        if (compat20) {
#line 791
          if (c->isatty) {
#line 793
            tmp___6 = tcgetattr(c->wfd, & tio);
#line 793
            if (tmp___6 == 0) {
#line 793
              if (! (tio.c_lflag & 8U)) {
#line 793
                if (tio.c_lflag & 2U) {
#line 799
                  packet_start(2);
#line 800
                  tmp___4 = buffer_ptr(& c->output);
#line 800
                  memset((void *)tmp___4, 0, (unsigned int )len);
#line 801
                  tmp___5 = buffer_ptr(& c->output);
#line 801
                  packet_put_string((char const   *)tmp___5, (unsigned int )len);
#line 802
                  packet_send();
                }
              }
            }
          }
        }
#line 805
        buffer_consume(& c->output, (unsigned int )len);
#line 806
        if (compat20) {
#line 806
          if (len > 0) {
#line 807
            c->local_consumed += len;
          }
        }
      }
    }
  }
#line 810
  return (1);
}
}
#line 812 "channels.c"
int channel_handle_efd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char buf___2[16384] ;
  int len ;
  u_int tmp ;
  char *tmp___0 ;
  register char __result ;
  register char __result___0 ;
  u_int tmp___1 ;

  {
#line 819
  if (c->efd != -1) {
#line 821
    if (c->extended_usage == 2) {
#line 821
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))),
                           "m" (writeset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "cc");
#line 821
      if (__result___0) {
#line 821
        tmp___1 = buffer_len(& c->extended);
#line 821
        if (tmp___1 > 0U) {
#line 823
          tmp = buffer_len(& c->extended);
#line 823
          tmp___0 = buffer_ptr(& c->extended);
#line 823
          len = write(c->efd, (void const   *)tmp___0, tmp);
#line 825
          debug2("channel %d: written %d to efd %d", c->self, len, c->efd);
#line 827
          if (len > 0) {
#line 828
            buffer_consume(& c->extended, (unsigned int )len);
#line 829
            c->local_consumed += len;
          }
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 832
      if (c->extended_usage == 1) {
#line 832
        __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))),
                             "m" (readset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "cc");
#line 832
        if (__result) {
#line 833
          len = read(c->efd, (void *)(buf___2), sizeof(buf___2));
#line 834
          debug2("channel %d: read %d from efd %d", c->self, len, c->efd);
#line 836
          if (len == 0) {
#line 837
            debug("channel %d: closing efd %d", c->self, c->efd);
#line 839
            close(c->efd);
#line 840
            c->efd = -1;
          } else {
#line 841
            if (len > 0) {
#line 842
              buffer_append(& c->extended, (char const   *)(buf___2), (unsigned int )len);
            }
          }
        }
      }
    }
  }
#line 845
  return (1);
}
}
#line 847 "channels.c"
int channel_check_window(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 850
  if (! (c->flags & 3)) {
#line 850
    if (c->local_window < c->local_window_max / 2) {
#line 850
      if (c->local_consumed > 0) {
#line 853
        packet_start(93);
#line 854
        packet_put_int((unsigned int )c->remote_id);
#line 855
        packet_put_int((unsigned int )c->local_consumed);
#line 856
        packet_send();
#line 857
        debug2("channel %d: window %d sent adjust %d", c->self, c->local_window, c->local_consumed);
#line 860
        c->local_window += c->local_consumed;
#line 861
        c->local_consumed = 0;
      }
    }
  }
#line 863
  return (1);
}
}
#line 866 "channels.c"
void channel_post_open_1(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 869
  channel_handle_rfd(c, readset, writeset);
#line 870
  channel_handle_wfd(c, readset, writeset);
#line 871
  return;
}
}
#line 873 "channels.c"
void channel_post_open_2(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 876
  channel_handle_rfd(c, readset, writeset);
#line 877
  channel_handle_wfd(c, readset, writeset);
#line 878
  channel_handle_efd(c, readset, writeset);
#line 879
  channel_check_window(c, readset, writeset);
#line 880
  return;
}
}
#line 882 "channels.c"
void channel_post_output_drain_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int len ;
  u_int tmp ;
  char *tmp___0 ;
  u_int tmp___1 ;
  register char __result ;
  u_int tmp___2 ;

  {
#line 887
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 887
  if (__result) {
#line 887
    tmp___2 = buffer_len(& c->output);
#line 887
    if (tmp___2 > 0U) {
#line 888
      tmp = buffer_len(& c->output);
#line 888
      tmp___0 = buffer_ptr(& c->output);
#line 888
      len = write(c->sock, (void const   *)tmp___0, tmp);
#line 890
      if (len <= 0) {
#line 891
        tmp___1 = buffer_len(& c->output);
#line 891
        buffer_consume(& c->output, tmp___1);
      } else {
#line 893
        buffer_consume(& c->output, (unsigned int )len);
      }
    }
  }
#line 895
  return;
}
}
#line 897 "channels.c"
void channel_handler_init_20(void) 
{ 

  {
#line 900
  channel_pre[4] = & channel_pre_open_20;
#line 901
  channel_pre[7] = & channel_pre_x11_open;
#line 902
  channel_pre[2] = & channel_pre_listener;
#line 903
  channel_pre[11] = & channel_pre_listener;
#line 904
  channel_pre[1] = & channel_pre_listener;
#line 905
  channel_pre[6] = & channel_pre_listener;
#line 906
  channel_pre[12] = & channel_pre_connecting;
#line 908
  channel_post[4] = & channel_post_open_2;
#line 909
  channel_post[2] = & channel_post_port_listener;
#line 910
  channel_post[11] = & channel_post_port_listener;
#line 911
  channel_post[1] = & channel_post_x11_listener;
#line 912
  channel_post[6] = & channel_post_auth_listener;
#line 913
  channel_post[12] = & channel_post_connecting;
#line 914
  return;
}
}
#line 916 "channels.c"
void channel_handler_init_13(void) 
{ 

  {
#line 919
  channel_pre[4] = & channel_pre_open_13;
#line 920
  channel_pre[7] = & channel_pre_x11_open_13;
#line 921
  channel_pre[1] = & channel_pre_listener;
#line 922
  channel_pre[2] = & channel_pre_listener;
#line 923
  channel_pre[6] = & channel_pre_listener;
#line 924
  channel_pre[8] = & channel_pre_input_draining;
#line 925
  channel_pre[9] = & channel_pre_output_draining;
#line 926
  channel_pre[12] = & channel_pre_connecting;
#line 928
  channel_post[4] = & channel_post_open_1;
#line 929
  channel_post[1] = & channel_post_x11_listener;
#line 930
  channel_post[2] = & channel_post_port_listener;
#line 931
  channel_post[6] = & channel_post_auth_listener;
#line 932
  channel_post[9] = & channel_post_output_drain_13;
#line 933
  channel_post[12] = & channel_post_connecting;
#line 934
  return;
}
}
#line 936 "channels.c"
void channel_handler_init_15(void) 
{ 

  {
#line 939
  channel_pre[4] = & channel_pre_open_15;
#line 940
  channel_pre[7] = & channel_pre_x11_open;
#line 941
  channel_pre[1] = & channel_pre_listener;
#line 942
  channel_pre[2] = & channel_pre_listener;
#line 943
  channel_pre[6] = & channel_pre_listener;
#line 944
  channel_pre[12] = & channel_pre_connecting;
#line 946
  channel_post[1] = & channel_post_x11_listener;
#line 947
  channel_post[2] = & channel_post_port_listener;
#line 948
  channel_post[6] = & channel_post_auth_listener;
#line 949
  channel_post[4] = & channel_post_open_1;
#line 950
  channel_post[12] = & channel_post_connecting;
#line 951
  return;
}
}
#line 953 "channels.c"
void channel_handler_init(void) 
{ int i ;

  {
#line 957
  i = 0;
#line 957
  while (i < 13) {
#line 958
    channel_pre[i] = (chan_fn *)((void *)0);
#line 959
    channel_post[i] = (chan_fn *)((void *)0);
#line 957
    i ++;
  }
#line 961
  if (compat20) {
#line 962
    channel_handler_init_20();
  } else {
#line 963
    if (compat13) {
#line 964
      channel_handler_init_13();
    } else {
#line 966
      channel_handler_init_15();
    }
  }
#line 967
  return;
}
}
#line 972
void channel_handler(chan_fn **ftab , fd_set *readset , fd_set *writeset ) ;
#line 972 "channels.c"
static int did_init  =    0;
#line 969 "channels.c"
void channel_handler(chan_fn **ftab , fd_set *readset , fd_set *writeset ) 
{ int i ;
  Channel *c ;

  {
#line 976
  if (! did_init) {
#line 977
    channel_handler_init();
#line 978
    did_init = 1;
  }
#line 980
  i = 0;
#line 980
  while (i < channels_alloc) {
#line 981
    c = channels + i;
#line 982
    if (c->type == 0) {
      goto __Cont;
    }
#line 984
    if ((unsigned int )*(ftab + c->type) == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 986
    (*(*(ftab + c->type)))(c, readset, writeset);
#line 987
    (*chan_delete_if_full_closed)(c);
    __Cont: /* CIL Label */ 
#line 980
    i ++;
  }
#line 989
  return;
}
}
#line 991 "channels.c"
void channel_prepare_select(fd_set **readsetp , fd_set **writesetp , int *maxfdp ) 
{ int n___0 ;
  u_int sz ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 997
  if (*maxfdp > channel_max_fd) {
#line 997
    n___0 = *maxfdp;
  } else {
#line 997
    n___0 = channel_max_fd;
  }
#line 999
  sz = (((unsigned int )(n___0 + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask );
#line 1000
  if ((unsigned int )*readsetp == (unsigned int )((void *)0)) {
    goto _L;
  } else {
#line 1000
    if (n___0 > *maxfdp) {
      _L: /* CIL Label */ 
#line 1001
      if (*readsetp) {
#line 1002
        xfree((void *)*readsetp);
      }
#line 1003
      if (*writesetp) {
#line 1004
        xfree((void *)*writesetp);
      }
#line 1005
      tmp = xmalloc(sz);
#line 1005
      *readsetp = (fd_set *)tmp;
#line 1006
      tmp___0 = xmalloc(sz);
#line 1006
      *writesetp = (fd_set *)tmp___0;
#line 1007
      *maxfdp = n___0;
    }
  }
#line 1009
  memset((void *)*readsetp, 0, sz);
#line 1010
  memset((void *)*writesetp, 0, sz);
#line 1012
  channel_handler(channel_pre, *readsetp, *writesetp);
#line 1013
  return;
}
}
#line 1015 "channels.c"
void channel_after_select(fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 1018
  channel_handler(channel_post, readset, writeset);
#line 1019
  return;
}
}
#line 1023 "channels.c"
void channel_output_poll(void) 
{ int len ;
  int i ;
  Channel *c ;
  u_int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  u_int tmp___4 ;

  {
#line 1029
  i = 0;
#line 1029
  while (i < channels_alloc) {
#line 1030
    c = channels + i;
#line 1033
    if (compat13) {
#line 1034
      if (c->type != 4) {
#line 1034
        if (c->type != 8) {
          goto __Cont;
        }
      }
    } else {
#line 1038
      if (c->type != 4) {
        goto __Cont;
      }
#line 1040
      if (c->istate != 1) {
#line 1040
        if (c->istate != 2) {
          goto __Cont;
        }
      }
    }
#line 1044
    if (compat20) {
#line 1044
      if (c->flags & 3) {
#line 1046
        debug("channel: %d: no data after CLOSE", c->self);
        goto __Cont;
      }
    }
#line 1051
    tmp = buffer_len(& c->input);
#line 1051
    len = (int )tmp;
#line 1052
    if (len > 0) {
#line 1054
      if (compat20) {
#line 1055
        if (len > c->remote_window) {
#line 1056
          len = c->remote_window;
        }
#line 1057
        if (len > c->remote_maxpacket) {
#line 1058
          len = c->remote_maxpacket;
        }
      } else {
#line 1060
        tmp___0 = packet_is_interactive();
#line 1060
        if (tmp___0) {
#line 1061
          if (len > 1024) {
#line 1062
            len = 512;
          }
        } else {
#line 1065
          if (len > max_packet_size / 2) {
#line 1066
            len = max_packet_size / 2;
          }
        }
      }
#line 1069
      if (len > 0) {
#line 1070
        if (compat20) {
#line 1070
          tmp___1 = 94;
        } else {
#line 1070
          tmp___1 = 23;
        }
#line 1070
        packet_start(tmp___1);
#line 1072
        packet_put_int((unsigned int )c->remote_id);
#line 1073
        tmp___2 = buffer_ptr(& c->input);
#line 1073
        packet_put_string((char const   *)tmp___2, (unsigned int )len);
#line 1074
        packet_send();
#line 1075
        buffer_consume(& c->input, (unsigned int )len);
#line 1076
        c->remote_window -= len;
      }
    } else {
#line 1078
      if (c->istate == 2) {
#line 1079
        if (compat13) {
#line 1080
          fatal("cannot happen: istate == INPUT_WAIT_DRAIN for proto 1.3");
        }
#line 1085
        (*chan_ibuf_empty)(c);
      }
    }
#line 1088
    if (compat20) {
#line 1088
      if (c->remote_window > 0) {
#line 1088
        tmp___4 = buffer_len(& c->extended);
#line 1088
        len = (int )tmp___4;
#line 1088
        if (len > 0) {
#line 1088
          if (c->extended_usage == 1) {
#line 1092
            if (len > c->remote_window) {
#line 1093
              len = c->remote_window;
            }
#line 1094
            if (len > c->remote_maxpacket) {
#line 1095
              len = c->remote_maxpacket;
            }
#line 1096
            packet_start(95);
#line 1097
            packet_put_int((unsigned int )c->remote_id);
#line 1098
            packet_put_int(1U);
#line 1099
            tmp___3 = buffer_ptr(& c->extended);
#line 1099
            packet_put_string((char const   *)tmp___3, (unsigned int )len);
#line 1100
            packet_send();
#line 1101
            buffer_consume(& c->extended, (unsigned int )len);
#line 1102
            c->remote_window -= len;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1029
    i ++;
  }
#line 1105
  return;
}
}
#line 1113 "channels.c"
void channel_input_data(int type , int plen , void *ctxt ) 
{ int id ;
  char *data ;
  u_int data_len ;
  Channel *c ;
  u_int tmp ;
  int _len ;
  int tmp___0 ;
  int _p ;
  int _e ;

  {
#line 1122
  tmp = packet_get_int();
#line 1122
  id = (int )tmp;
#line 1123
  c = channel_lookup(id);
#line 1124
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1125
    packet_disconnect("Received data for nonexistent channel %d.", id);
  }
#line 1128
  if (c->type != 4) {
#line 1128
    if (c->type != 7) {
#line 1130
      return;
    }
  }
#line 1133
  if (! compat13) {
#line 1133
    if (c->ostate != 16) {
#line 1134
      return;
    }
  }
#line 1137
  data = packet_get_string(& data_len);
#line 1138
  while (1) {
#line 1138
    tmp___0 = packet_remaining();
#line 1138
    _len = tmp___0;
#line 1138
    if (_len > 0) {
#line 1138
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1138);
#line 1138
      packet_disconnect("Packet integrity error.");
    }
#line 1138
    break;
  }
#line 1140
  if (compat20) {
#line 1141
    if (data_len > (u_int )c->local_maxpacket) {
#line 1142
      log("channel %d: rcvd big packet %d, maxpack %d", c->self, data_len, c->local_maxpacket);
    }
#line 1145
    if (data_len > (u_int )c->local_window) {
#line 1146
      log("channel %d: rcvd too much data %d, win %d", c->self, data_len, c->local_window);
#line 1148
      xfree((void *)data);
#line 1149
      return;
    }
#line 1151
    c->local_window = (int )((u_int )c->local_window - data_len);
  } else {
#line 1153
    while (1) {
#line 1153
      _p = plen;
#line 1153
      _e = (int )(8U + data_len);
#line 1153
      if (_p != _e) {
#line 1153
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1153);
#line 1153
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1153
      break;
    }
  }
#line 1155
  buffer_append(& c->output, (char const   *)data, data_len);
#line 1156
  xfree((void *)data);
#line 1157
  return;
}
}
#line 1158 "channels.c"
void channel_input_extended_data(int type , int plen , void *ctxt ) 
{ int id ;
  int tcode ;
  char *data ;
  u_int data_len ;
  Channel *c ;
  u_int tmp ;
  u_int tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1168
  tmp = packet_get_int();
#line 1168
  id = (int )tmp;
#line 1169
  c = channel_lookup(id);
#line 1171
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1172
    packet_disconnect("Received extended_data for bad channel %d.", id);
  }
#line 1173
  if (c->type != 4) {
#line 1174
    log("channel %d: ext data for non open", id);
#line 1175
    return;
  }
#line 1177
  tmp___0 = packet_get_int();
#line 1177
  tcode = (int )tmp___0;
#line 1178
  if (c->efd == -1) {
#line 1181
    log("channel %d: bad ext data", c->self);
#line 1182
    return;
  } else {
#line 1178
    if (c->extended_usage != 2) {
#line 1181
      log("channel %d: bad ext data", c->self);
#line 1182
      return;
    } else {
#line 1178
      if (tcode != 1) {
#line 1181
        log("channel %d: bad ext data", c->self);
#line 1182
        return;
      }
    }
  }
#line 1184
  data = packet_get_string(& data_len);
#line 1185
  while (1) {
#line 1185
    tmp___1 = packet_remaining();
#line 1185
    _len = tmp___1;
#line 1185
    if (_len > 0) {
#line 1185
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1185);
#line 1185
      packet_disconnect("Packet integrity error.");
    }
#line 1185
    break;
  }
#line 1186
  if (data_len > (u_int )c->local_window) {
#line 1187
    log("channel %d: rcvd too much extended_data %d, win %d", c->self, data_len, c->local_window);
#line 1189
    xfree((void *)data);
#line 1190
    return;
  }
#line 1192
  debug2("channel %d: rcvd ext data %d", c->self, data_len);
#line 1193
  c->local_window = (int )((u_int )c->local_window - data_len);
#line 1194
  buffer_append(& c->extended, (char const   *)data, data_len);
#line 1195
  xfree((void *)data);
#line 1196
  return;
}
}
#line 1204 "channels.c"
int channel_not_very_much_buffered_data(void) 
{ u_int i ;
  Channel *c ;
  u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;

  {
#line 1210
  i = 0U;
#line 1210
  while (i < (u_int )channels_alloc) {
#line 1211
    c = channels + i;
#line 1212
    if (c->type == 4) {
#line 1213
      if (! compat20) {
#line 1213
        tmp___0 = buffer_len(& c->input);
#line 1213
        if (tmp___0 > (u_int )max_packet_size) {
#line 1214
          tmp = buffer_len(& c->input);
#line 1214
          debug("channel %d: big input buffer %d", c->self, tmp);
#line 1216
          return (0);
        }
      }
#line 1218
      tmp___2 = buffer_len(& c->output);
#line 1218
      if (tmp___2 > (u_int )max_packet_size) {
#line 1219
        tmp___1 = buffer_len(& c->output);
#line 1219
        debug("channel %d: big output buffer %d", c->self, tmp___1);
#line 1221
        return (0);
      }
    }
#line 1210
    i ++;
  }
#line 1225
  return (1);
}
}
#line 1228 "channels.c"
void channel_input_ieof(int type , int plen , void *ctxt ) 
{ int id ;
  Channel *c ;
  int _p ;
  int _e ;
  u_int tmp ;

  {
#line 1234
  while (1) {
#line 1234
    _p = plen;
#line 1234
    _e = 4;
#line 1234
    if (_p != _e) {
#line 1234
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1234);
#line 1234
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 1234
    break;
  }
#line 1236
  tmp = packet_get_int();
#line 1236
  id = (int )tmp;
#line 1237
  c = channel_lookup(id);
#line 1238
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1239
    packet_disconnect("Received ieof for nonexistent channel %d.", id);
  }
#line 1240
  (*chan_rcvd_ieof)(c);
#line 1241
  return;
}
}
#line 1243 "channels.c"
void channel_input_close(int type , int plen , void *ctxt ) 
{ int id ;
  Channel *c ;
  int _p ;
  int _e ;
  u_int tmp ;
  u_int tmp___0 ;

  {
#line 1249
  while (1) {
#line 1249
    _p = plen;
#line 1249
    _e = 4;
#line 1249
    if (_p != _e) {
#line 1249
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1249);
#line 1249
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 1249
    break;
  }
#line 1251
  tmp = packet_get_int();
#line 1251
  id = (int )tmp;
#line 1252
  c = channel_lookup(id);
#line 1253
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1254
    packet_disconnect("Received close for nonexistent channel %d.", id);
  }
#line 1260
  packet_start(25);
#line 1261
  packet_put_int((unsigned int )c->remote_id);
#line 1262
  packet_send();
#line 1271
  if (c->type != 5) {
#line 1276
    tmp___0 = buffer_len(& c->input);
#line 1276
    buffer_consume(& c->input, tmp___0);
#line 1277
    c->type = 9;
  }
#line 1279
  return;
}
}
#line 1282 "channels.c"
void channel_input_oclose(int type , int plen , void *ctxt ) 
{ int id ;
  u_int tmp ;
  Channel *c ;
  Channel *tmp___0 ;
  int _p ;
  int _e ;

  {
#line 1285
  tmp = packet_get_int();
#line 1285
  id = (int )tmp;
#line 1286
  tmp___0 = channel_lookup(id);
#line 1286
  c = tmp___0;
#line 1287
  while (1) {
#line 1287
    _p = plen;
#line 1287
    _e = 4;
#line 1287
    if (_p != _e) {
#line 1287
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1287);
#line 1287
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 1287
    break;
  }
#line 1288
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1289
    packet_disconnect("Received oclose for nonexistent channel %d.", id);
  }
#line 1290
  (*chan_rcvd_oclose)(c);
#line 1291
  return;
}
}
#line 1293 "channels.c"
void channel_input_close_confirmation(int type , int plen , void *ctxt ) 
{ int id ;
  u_int tmp ;
  Channel *c ;
  Channel *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1296
  tmp = packet_get_int();
#line 1296
  id = (int )tmp;
#line 1297
  tmp___0 = channel_lookup(id);
#line 1297
  c = tmp___0;
#line 1299
  while (1) {
#line 1299
    tmp___1 = packet_remaining();
#line 1299
    _len = tmp___1;
#line 1299
    if (_len > 0) {
#line 1299
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1299);
#line 1299
      packet_disconnect("Packet integrity error.");
    }
#line 1299
    break;
  }
#line 1300
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1301
    packet_disconnect("Received close confirmation for out-of-range channel %d.",
                      id);
  }
#line 1303
  if (c->type != 5) {
#line 1304
    packet_disconnect("Received close confirmation for non-closed channel %d (type %d).",
                      id, c->type);
  }
#line 1306
  channel_free(c->self);
#line 1307
  return;
}
}
#line 1309 "channels.c"
void channel_input_open_confirmation(int type , int plen , void *ctxt ) 
{ int id ;
  int remote_id ;
  Channel *c ;
  int _p ;
  int _e ;
  u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 1315
  if (! compat20) {
#line 1316
    while (1) {
#line 1316
      _p = plen;
#line 1316
      _e = 8;
#line 1316
      if (_p != _e) {
#line 1316
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1316);
#line 1316
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1316
      break;
    }
  }
#line 1318
  tmp = packet_get_int();
#line 1318
  id = (int )tmp;
#line 1319
  c = channel_lookup(id);
#line 1321
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1322
    packet_disconnect("Received open confirmation for non-opening channel %d.", id);
  } else {
#line 1321
    if (c->type != 3) {
#line 1322
      packet_disconnect("Received open confirmation for non-opening channel %d.",
                        id);
    }
  }
#line 1324
  tmp___0 = packet_get_int();
#line 1324
  remote_id = (int )tmp___0;
#line 1326
  c->remote_id = remote_id;
#line 1327
  c->type = 4;
#line 1329
  if (compat20) {
#line 1330
    tmp___1 = packet_get_int();
#line 1330
    c->remote_window = (int )tmp___1;
#line 1331
    tmp___2 = packet_get_int();
#line 1331
    c->remote_maxpacket = (int )tmp___2;
#line 1332
    while (1) {
#line 1332
      tmp___3 = packet_remaining();
#line 1332
      _len = tmp___3;
#line 1332
      if (_len > 0) {
#line 1332
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            1332);
#line 1332
        packet_disconnect("Packet integrity error.");
      }
#line 1332
      break;
    }
#line 1333
    if ((unsigned int )c->cb_fn != (unsigned int )((void *)0)) {
#line 1333
      if (c->cb_event == type) {
#line 1334
        debug2("callback start");
#line 1335
        (*(c->cb_fn))(c->self, c->cb_arg);
#line 1336
        debug2("callback done");
      }
    }
#line 1338
    debug("channel %d: open confirm rwindow %d rmax %d", c->self, c->remote_window,
          c->remote_maxpacket);
  }
#line 1341
  return;
}
}
#line 1343 "channels.c"
void channel_input_open_failure(int type , int plen , void *ctxt ) 
{ int id ;
  int reason ;
  char *msg ;
  char *lang ;
  Channel *c ;
  int _p ;
  int _e ;
  u_int tmp ;
  u_int tmp___0 ;
  int tmp___1 ;
  int _len ;
  int tmp___2 ;
  char const   *tmp___3 ;

  {
#line 1347
  msg = (char *)((void *)0);
#line 1347
  lang = (char *)((void *)0);
#line 1350
  if (! compat20) {
#line 1351
    while (1) {
#line 1351
      _p = plen;
#line 1351
      _e = 4;
#line 1351
      if (_p != _e) {
#line 1351
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1351);
#line 1351
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1351
      break;
    }
  }
#line 1353
  tmp = packet_get_int();
#line 1353
  id = (int )tmp;
#line 1354
  c = channel_lookup(id);
#line 1356
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1357
    packet_disconnect("Received open failure for non-opening channel %d.", id);
  } else {
#line 1356
    if (c->type != 3) {
#line 1357
      packet_disconnect("Received open failure for non-opening channel %d.", id);
    }
  }
#line 1359
  if (compat20) {
#line 1360
    tmp___0 = packet_get_int();
#line 1360
    reason = (int )tmp___0;
#line 1361
    tmp___1 = packet_remaining();
#line 1361
    if (tmp___1 > 0) {
#line 1362
      msg = packet_get_string((u_int *)((void *)0));
#line 1363
      lang = packet_get_string((u_int *)((void *)0));
    }
#line 1365
    while (1) {
#line 1365
      tmp___2 = packet_remaining();
#line 1365
      _len = tmp___2;
#line 1365
      if (_len > 0) {
#line 1365
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            1365);
#line 1365
        packet_disconnect("Packet integrity error.");
      }
#line 1365
      break;
    }
#line 1366
    if (msg) {
#line 1366
      tmp___3 = (char const   *)msg;
    } else {
#line 1366
      tmp___3 = "<no additional info>";
    }
#line 1366
    log("channel_open_failure: %d: reason %d %s", id, reason, tmp___3);
#line 1368
    if ((unsigned int )msg != (unsigned int )((void *)0)) {
#line 1369
      xfree((void *)msg);
    }
#line 1370
    if ((unsigned int )lang != (unsigned int )((void *)0)) {
#line 1371
      xfree((void *)lang);
    }
  }
#line 1374
  channel_free(id);
#line 1375
  return;
}
}
#line 1377 "channels.c"
void channel_input_channel_request(int type , int plen , void *ctxt ) 
{ int id ;
  Channel *c ;
  u_int tmp ;
  char *service ;
  char *tmp___0 ;

  {
#line 1383
  tmp = packet_get_int();
#line 1383
  id = (int )tmp;
#line 1384
  c = channel_lookup(id);
#line 1386
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1388
    packet_disconnect("Received request for non-open channel %d.", id);
  } else {
#line 1386
    if (c->type != 4) {
#line 1386
      if (c->type != 10) {
#line 1388
        packet_disconnect("Received request for non-open channel %d.", id);
      }
    }
  }
#line 1390
  if ((unsigned int )c->cb_fn != (unsigned int )((void *)0)) {
#line 1390
    if (c->cb_event == type) {
#line 1391
      debug2("callback start");
#line 1392
      (*(c->cb_fn))(c->self, c->cb_arg);
#line 1393
      debug2("callback done");
    } else {
#line 1395
      tmp___0 = packet_get_string((u_int *)((void *)0));
#line 1395
      service = tmp___0;
#line 1396
      debug("channel: %d rcvd request for %s", c->self, service);
#line 1397
      debug("cb_fn %p cb_event %d", c->cb_fn, c->cb_event);
#line 1398
      xfree((void *)service);
    }
  } else {
#line 1395
    tmp___0 = packet_get_string((u_int *)((void *)0));
#line 1395
    service = tmp___0;
#line 1396
    debug("channel: %d rcvd request for %s", c->self, service);
#line 1397
    debug("cb_fn %p cb_event %d", c->cb_fn, c->cb_event);
#line 1398
    xfree((void *)service);
  }
#line 1400
  return;
}
}
#line 1402 "channels.c"
void channel_input_window_adjust(int type , int plen , void *ctxt ) 
{ Channel *c ;
  int id ;
  int adjust ;
  u_int tmp ;
  u_int tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1408
  if (! compat20) {
#line 1409
    return;
  }
#line 1412
  tmp = packet_get_int();
#line 1412
  id = (int )tmp;
#line 1413
  c = channel_lookup(id);
#line 1415
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1416
    log("Received window adjust for non-open channel %d.", id);
#line 1418
    return;
  } else {
#line 1415
    if (c->type != 4) {
#line 1416
      log("Received window adjust for non-open channel %d.", id);
#line 1418
      return;
    }
  }
#line 1420
  tmp___0 = packet_get_int();
#line 1420
  adjust = (int )tmp___0;
#line 1421
  while (1) {
#line 1421
    tmp___1 = packet_remaining();
#line 1421
    _len = tmp___1;
#line 1421
    if (_len > 0) {
#line 1421
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1421);
#line 1421
      packet_disconnect("Packet integrity error.");
    }
#line 1421
    break;
  }
#line 1422
  debug2("channel %d: rcvd adjust %d", id, adjust);
#line 1423
  c->remote_window += adjust;
#line 1424
  return;
}
}
#line 1431 "channels.c"
void channel_stop_listening(void) 
{ int i ;

  {
#line 1435
  i = 0;
#line 1435
  while (i < channels_alloc) {
#line 1436
    switch ((channels + i)->type) {
    case 6: 
#line 1438
    close((channels + i)->sock);
#line 1439
    unlink((char const   *)((channels + i)->path));
#line 1440
    channel_free(i);
#line 1441
    break;
    case 2: 
    case 11: 
    case 1: 
#line 1445
    close((channels + i)->sock);
#line 1446
    channel_free(i);
#line 1447
    break;
    default: ;
#line 1449
    break;
    }
#line 1435
    i ++;
  }
#line 1452
  return;
}
}
#line 1459 "channels.c"
void channel_close_all(void) 
{ int i ;

  {
#line 1463
  i = 0;
#line 1463
  while (i < channels_alloc) {
#line 1464
    if ((channels + i)->type != 0) {
#line 1465
      channel_close_fds(channels + i);
    }
#line 1463
    i ++;
  }
#line 1466
  return;
}
}
#line 1470 "channels.c"
int channel_still_open(void) 
{ u_int i ;

  {
#line 1474
  i = 0U;
#line 1474
  while (i < (u_int )channels_alloc) {
#line 1475
    switch ((channels + i)->type) {
    case 0: 
    case 1: 
    case 2: 
    case 11: 
    case 5: 
    case 6: 
    case 12: 
    goto __Cont;
    case 10: 
#line 1485
    if (! compat20) {
#line 1486
      fatal("cannot happen: SSH_CHANNEL_LARVAL");
    }
    goto __Cont;
    case 3: 
    case 4: 
    case 7: 
#line 1491
    return (1);
    case 8: 
    case 9: 
#line 1494
    if (! compat13) {
#line 1495
      fatal("cannot happen: OUT_DRAIN");
    }
#line 1496
    return (1);
    default: 
#line 1498
    fatal("channel_still_open: bad channel type %d", (channels + i)->type);
    }
    __Cont: /* CIL Label */ 
#line 1474
    i ++;
  }
#line 1501
  return (0);
}
}
#line 1510 "channels.c"
char *channel_open_message(void) 
{ Buffer buffer ;
  int i ;
  char buf___2[512] ;
  char *cp ;
  size_t tmp ;
  Channel *c ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;

  {
#line 1517
  buffer_init(& buffer);
#line 1518
  snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"The following connections are open:\r\n");
#line 1519
  tmp = strlen((char const   *)(buf___2));
#line 1519
  buffer_append(& buffer, (char const   *)(buf___2), tmp);
#line 1520
  i = 0;
#line 1520
  while (i < channels_alloc) {
#line 1521
    c = channels + i;
#line 1522
    switch (c->type) {
    case 0: 
    case 1: 
    case 2: 
    case 11: 
    case 5: 
    case 6: 
    goto __Cont;
    case 10: 
    case 3: 
    case 12: 
    case 4: 
    case 7: 
    case 8: 
    case 9: 
#line 1537
    tmp___0 = buffer_len(& c->output);
#line 1537
    tmp___1 = buffer_len(& c->input);
#line 1537
    snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"  #%d %.300s (t%d r%d i%d/%d o%d/%d fd %d/%d)\r\n",
             c->self, c->remote_name, c->type, c->remote_id, c->istate, tmp___1, c->ostate,
             tmp___0, c->rfd, c->wfd);
#line 1543
    tmp___2 = strlen((char const   *)(buf___2));
#line 1543
    buffer_append(& buffer, (char const   *)(buf___2), tmp___2);
    goto __Cont;
    default: 
#line 1546
    fatal("channel_open_message: bad channel type %d", c->type);
    }
    __Cont: /* CIL Label */ 
#line 1520
    i ++;
  }
#line 1550
  buffer_append(& buffer, "\000", 1U);
#line 1551
  tmp___3 = buffer_ptr(& buffer);
#line 1551
  cp = xstrdup((char const   *)tmp___3);
#line 1552
  buffer_free(& buffer);
#line 1553
  return (cp);
}
}
#line 1560 "channels.c"
int channel_request_local_forwarding(u_short listen_port , char const   *host_to_connect ,
                                     u_short port_to_connect , int gateway_ports ) 
{ int tmp ;

  {
#line 1564
  tmp = channel_request_forwarding((char const   *)((void *)0), listen_port, host_to_connect,
                                   port_to_connect, gateway_ports, 0);
#line 1564
  return (tmp);
}
}
#line 1574 "channels.c"
int channel_request_forwarding(char const   *listen_address , u_short listen_port ,
                               char const   *host_to_connect , u_short port_to_connect ,
                               int gateway_ports , int remote_fwd ) 
{ int success ;
  int ch ;
  int sock ;
  int on ;
  int ctype ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char ntop[1025] ;
  char strport[32] ;
  char const   *host ;
  struct linger linger ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;

  {
#line 1580
  on = 1;
#line 1586
  success = 0;
#line 1588
  if (remote_fwd) {
#line 1589
    host = listen_address;
#line 1590
    ctype = 11;
  } else {
#line 1592
    host = host_to_connect;
#line 1593
    ctype = 2;
  }
#line 1596
  tmp = strlen(host);
#line 1596
  if (tmp > sizeof((channels + 0)->path) - 1U) {
#line 1597
    error("Forward host name too long.");
#line 1598
    return (success);
  }
#line 1606
  memset((void *)(& hints), 0, sizeof(hints));
#line 1607
  hints.ai_family = IPv4or6;
#line 1608
  if (gateway_ports) {
#line 1608
    hints.ai_flags = 1;
  } else {
#line 1608
    hints.ai_flags = 0;
  }
#line 1609
  hints.ai_socktype = 1;
#line 1610
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           listen_port);
#line 1611
  tmp___0 = getaddrinfo((char const   * __restrict  )((void *)0), (char const   * __restrict  )(strport),
                        (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 1611
  if (tmp___0 != 0) {
#line 1612
    packet_disconnect("getaddrinfo: fatal error");
  }
#line 1614
  ai = aitop;
#line 1614
  while (ai) {
#line 1615
    if (ai->ai_family != 2) {
#line 1615
      if (ai->ai_family != 10) {
        goto __Cont;
      }
    }
#line 1617
    tmp___1 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                          (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )(strport),
                          sizeof(strport), 3U);
#line 1617
    if (tmp___1 != 0) {
#line 1619
      error("channel_request_forwarding: getnameinfo failed");
      goto __Cont;
    }
#line 1623
    sock = socket(ai->ai_family, 1, 0);
#line 1624
    if (sock < 0) {
#line 1626
      tmp___2 = __errno_location();
#line 1626
      tmp___3 = strerror(*tmp___2);
#line 1626
      verbose("socket: %.100s", tmp___3);
      goto __Cont;
    }
#line 1633
    setsockopt(sock, 1, 2, (void const   *)((void *)(& on)), sizeof(on));
#line 1634
    linger.l_onoff = 1;
#line 1635
    linger.l_linger = 5;
#line 1636
    setsockopt(sock, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 1637
    debug("Local forwarding listening on %s port %s.", ntop, strport);
#line 1640
    tmp___8 = bind(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 1640
    if (tmp___8 < 0) {
#line 1642
      if (! ai->ai_next) {
#line 1643
        tmp___4 = __errno_location();
#line 1643
        tmp___5 = strerror(*tmp___4);
#line 1643
        error("bind: %.100s", tmp___5);
      } else {
#line 1645
        tmp___6 = __errno_location();
#line 1645
        tmp___7 = strerror(*tmp___6);
#line 1645
        verbose("bind: %.100s", tmp___7);
      }
#line 1647
      close(sock);
      goto __Cont;
    }
#line 1651
    tmp___11 = listen(sock, 5);
#line 1651
    if (tmp___11 < 0) {
#line 1652
      tmp___9 = __errno_location();
#line 1652
      tmp___10 = strerror(*tmp___9);
#line 1652
      error("listen: %.100s", tmp___10);
#line 1653
      close(sock);
      goto __Cont;
    }
#line 1657
    tmp___12 = xstrdup("port listener");
#line 1657
    ch = channel_new((char *)"port listener", ctype, sock, sock, -1, 32768, 16384,
                     0, tmp___12, 1);
#line 1660
    strlcpy((channels + ch)->path, host, sizeof((channels + ch)->path));
#line 1661
    (channels + ch)->host_port = (int )port_to_connect;
#line 1662
    (channels + ch)->listening_port = (int )listen_port;
#line 1663
    success = 1;
    __Cont: /* CIL Label */ 
#line 1614
    ai = ai->ai_next;
  }
#line 1665
  if (success == 0) {
#line 1666
    error("channel_request_forwarding: cannot listen to port: %d", listen_port);
  }
#line 1668
  freeaddrinfo(aitop);
#line 1669
  return (success);
}
}
#line 1677 "channels.c"
void channel_request_remote_forwarding(u_short listen_port , char const   *host_to_connect ,
                                       u_short port_to_connect ) 
{ int payload_len ;
  int type ;
  int success ;
  char const   *address_to_bind ;

  {
#line 1681
  success = 0;
#line 1684
  if (num_permitted_opens >= 100) {
#line 1685
    fatal("channel_request_remote_forwarding: too many forwards");
  }
#line 1688
  if (compat20) {
#line 1689
    address_to_bind = "0.0.0.0";
#line 1690
    packet_start(80);
#line 1691
    packet_put_cstring("tcpip-forward");
#line 1692
    packet_put_char(0);
#line 1693
    packet_put_cstring(address_to_bind);
#line 1694
    packet_put_int((unsigned int )listen_port);
#line 1695
    packet_send();
#line 1696
    packet_write_wait();
#line 1698
    success = 1;
  } else {
#line 1700
    packet_start(28);
#line 1701
    packet_put_int((unsigned int )listen_port);
#line 1702
    packet_put_cstring(host_to_connect);
#line 1703
    packet_put_int((unsigned int )port_to_connect);
#line 1704
    packet_send();
#line 1705
    packet_write_wait();
#line 1708
    type = packet_read(& payload_len);
#line 1709
    switch (type) {
    case 14: 
#line 1711
    success = 1;
#line 1712
    break;
    case 15: 
#line 1714
    log("Warning: Server denied remote port forwarding.");
#line 1715
    break;
    default: 
#line 1718
    packet_disconnect("Protocol error for port forward request:received packet type %d.",
                      type);
    }
  }
#line 1722
  if (success) {
#line 1723
    permitted_opens[num_permitted_opens].host_to_connect = xstrdup(host_to_connect);
#line 1724
    permitted_opens[num_permitted_opens].port_to_connect = port_to_connect;
#line 1725
    permitted_opens[num_permitted_opens].listen_port = listen_port;
#line 1726
    num_permitted_opens ++;
  }
#line 1728
  return;
}
}
#line 1736 "channels.c"
void channel_input_port_forward_request(int is_root , int gateway_ports ) 
{ u_short port ;
  u_short host_port ;
  char *hostname ;
  u_int tmp ;
  u_int tmp___0 ;

  {
#line 1743
  tmp = packet_get_int();
#line 1743
  port = (unsigned short )tmp;
#line 1744
  hostname = packet_get_string((u_int *)((void *)0));
#line 1745
  tmp___0 = packet_get_int();
#line 1745
  host_port = (unsigned short )tmp___0;
#line 1752
  if ((int )port < 1024) {
#line 1752
    if (! is_root) {
#line 1753
      packet_disconnect("Requested forwarding of port %d but user is not root.", port);
    }
  }
#line 1757
  channel_request_local_forwarding(port, (char const   *)hostname, host_port, gateway_ports);
#line 1760
  xfree((void *)hostname);
#line 1761
  return;
}
}
#line 1764 "channels.c"
int channel_connect_to(char const   *host , u_short host_port ) 
{ struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char ntop[1025] ;
  char strport[32] ;
  int gaierr ;
  int sock ;
  char const   *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;

  {
#line 1770
  sock = -1;
#line 1772
  memset((void *)(& hints), 0, sizeof(hints));
#line 1773
  hints.ai_family = IPv4or6;
#line 1774
  hints.ai_socktype = 1;
#line 1775
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           host_port);
#line 1776
  gaierr = getaddrinfo((char const   * __restrict  )host, (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 1776
  if (gaierr != 0) {
#line 1777
    tmp = gai_strerror(gaierr);
#line 1777
    error("%.100s: unknown host (%s)", host, tmp);
#line 1778
    return (-1);
  }
#line 1780
  ai = aitop;
#line 1780
  while (ai) {
#line 1781
    if (ai->ai_family != 2) {
#line 1781
      if (ai->ai_family != 10) {
        goto __Cont;
      }
    }
#line 1783
    tmp___0 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                          (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )(strport),
                          sizeof(strport), 3U);
#line 1783
    if (tmp___0 != 0) {
#line 1785
      error("channel_connect_to: getnameinfo failed");
      goto __Cont;
    }
#line 1789
    sock = socket(ai->ai_family, 1, 0);
#line 1790
    if (sock < 0) {
#line 1791
      tmp___1 = __errno_location();
#line 1791
      tmp___2 = strerror(*tmp___1);
#line 1791
      error("socket: %.100s", tmp___2);
      goto __Cont;
    }
#line 1794
    tmp___5 = fcntl(sock, 4, 2048);
#line 1794
    if (tmp___5 < 0) {
#line 1795
      tmp___3 = __errno_location();
#line 1795
      tmp___4 = strerror(*tmp___3);
#line 1795
      fatal("connect_to: F_SETFL: %s", tmp___4);
    }
#line 1797
    tmp___8 = connect(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 1797
    if (tmp___8 < 0) {
#line 1797
      tmp___9 = __errno_location();
#line 1797
      if (*tmp___9 != 115) {
#line 1799
        tmp___6 = __errno_location();
#line 1799
        tmp___7 = strerror(*tmp___6);
#line 1799
        error("connect %.100s port %s: %.100s", ntop, strport, tmp___7);
#line 1801
        close(sock);
        goto __Cont;
      }
    }
#line 1804
    break;
    __Cont: /* CIL Label */ 
#line 1780
    ai = ai->ai_next;
  }
#line 1807
  freeaddrinfo(aitop);
#line 1808
  if (! ai) {
#line 1809
    error("connect %.100s port %d: failed.", host, host_port);
#line 1810
    return (-1);
  }
#line 1813
  return (sock);
}
}
#line 1815 "channels.c"
int channel_connect_by_listen_adress(u_short listen_port ) 
{ int i ;
  int tmp ;

  {
#line 1819
  i = 0;
#line 1819
  while (i < num_permitted_opens) {
#line 1820
    if ((int )permitted_opens[i].listen_port == (int )listen_port) {
#line 1821
      tmp = channel_connect_to((char const   *)permitted_opens[i].host_to_connect,
                               permitted_opens[i].port_to_connect);
#line 1821
      return (tmp);
    }
#line 1819
    i ++;
  }
#line 1824
  error("WARNING: Server requests forwarding for unknown listen_port %d", listen_port);
#line 1826
  return (-1);
}
}
#line 1835 "channels.c"
void channel_input_port_open(int type , int plen , void *ctxt ) 
{ u_short host_port ;
  char *host ;
  char *originator_string ;
  int remote_channel ;
  int sock ;
  int newch ;
  int i ;
  int denied ;
  u_int host_len ;
  u_int originator_len ;
  u_int tmp ;
  u_int tmp___0 ;
  int _p ;
  int _e ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 1840
  sock = -1;
#line 1844
  tmp = packet_get_int();
#line 1844
  remote_channel = (int )tmp;
#line 1847
  host = packet_get_string(& host_len);
#line 1850
  tmp___0 = packet_get_int();
#line 1850
  host_port = (unsigned short )tmp___0;
#line 1853
  if (have_hostname_in_open) {
#line 1854
    originator_string = packet_get_string(& originator_len);
#line 1855
    originator_len += 4U;
  } else {
#line 1857
    originator_string = xstrdup("unknown (remote did not supply name)");
#line 1858
    originator_len = 0U;
  }
#line 1861
  while (1) {
#line 1861
    _p = plen;
#line 1861
    _e = (int )(((8U + host_len) + 4U) + originator_len);
#line 1861
    if (_p != _e) {
#line 1861
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1862);
#line 1861
      packet_disconnect("Packet integrity error. (%d)", 29);
    }
#line 1861
    break;
  }
#line 1865
  denied = 0;
#line 1866
  if (! all_opens_permitted) {
#line 1868
    i = 0;
#line 1868
    while (i < num_permitted_opens) {
#line 1870
      if ((int )permitted_opens[i].port_to_connect == (int )host_port) {
#line 1870
        if (0) {
#line 1870
          __s1_len = strlen((char const   *)permitted_opens[i].host_to_connect);
#line 1870
          __s2_len = strlen((char const   *)host);
#line 1870
          if (! ((unsigned int )((void const   *)(permitted_opens[i].host_to_connect + 1)) - (unsigned int )((void const   *)permitted_opens[i].host_to_connect) == 1U)) {
            goto _L___0;
          } else {
#line 1870
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 1870
              if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
#line 1870
                tmp___10 = 1;
              } else {
#line 1870
                if (__s2_len >= 4U) {
#line 1870
                  tmp___10 = 1;
                } else {
#line 1870
                  tmp___10 = 0;
                }
              }
            } else {
#line 1870
              tmp___10 = 0;
            }
          }
#line 1870
          if (tmp___10) {
#line 1870
            tmp___6 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                       (char const   *)host);
          } else {
#line 1870
            tmp___9 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                       (char const   *)host);
#line 1870
            tmp___6 = tmp___9;
          }
        } else {
#line 1870
          tmp___9 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                     (char const   *)host);
#line 1870
          tmp___6 = tmp___9;
        }
#line 1870
        if (tmp___6 == 0) {
#line 1871
          break;
        }
      }
#line 1868
      i ++;
    }
#line 1874
    if (i >= num_permitted_opens) {
#line 1876
      log("Received request to connect to %.100s:%d, but the request was denied.",
          host, host_port);
#line 1878
      denied = 1;
    }
  }
#line 1881
  if (denied) {
#line 1881
    sock = -1;
  } else {
#line 1881
    sock = channel_connect_to((char const   *)host, host_port);
  }
#line 1882
  if (sock > 0) {
#line 1884
    newch = channel_allocate(12, sock, originator_string);
#line 1887
    (channels + newch)->remote_id = remote_channel;
#line 1889
    packet_start(21);
#line 1890
    packet_put_int((unsigned int )remote_channel);
#line 1891
    packet_put_int((unsigned int )newch);
#line 1892
    packet_send();
  } else {
#line 1894
    packet_start(22);
#line 1895
    packet_put_int((unsigned int )remote_channel);
#line 1896
    packet_send();
  }
#line 1898
  xfree((void *)host);
#line 1899
  return;
}
}
#line 1909 "channels.c"
char *x11_create_display_inet(int screen_number , int x11_display_offset ) 
{ int display_number ;
  int sock ;
  u_short port ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  int n___0 ;
  int num_socks ;
  int socks[10] ;
  char display[512] ;
  char hostname[64] ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;

  {
#line 1916
  num_socks = 0;
#line 1920
  display_number = x11_display_offset;
#line 1920
  while (display_number < 1000) {
#line 1923
    port = (unsigned short )(6000 + display_number);
#line 1924
    memset((void *)(& hints), 0, sizeof(hints));
#line 1925
    hints.ai_family = IPv4or6;
#line 1926
    hints.ai_flags = 1;
#line 1927
    hints.ai_socktype = 1;
#line 1928
    snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
             port);
#line 1929
    gaierr = getaddrinfo((char const   * __restrict  )((void *)0), (char const   * __restrict  )(strport),
                         (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 1929
    if (gaierr != 0) {
#line 1930
      tmp = gai_strerror(gaierr);
#line 1930
      error("getaddrinfo: %.100s", tmp);
#line 1931
      return ((char *)((void *)0));
    }
#line 1933
    ai = aitop;
#line 1933
    while (ai) {
#line 1934
      if (ai->ai_family != 2) {
#line 1934
        if (ai->ai_family != 10) {
          goto __Cont;
        }
      }
#line 1936
      sock = socket(ai->ai_family, 1, 0);
#line 1937
      if (sock < 0) {
#line 1938
        tmp___2 = __errno_location();
#line 1938
        if (*tmp___2 != 22) {
#line 1938
          tmp___3 = __errno_location();
#line 1938
          if (*tmp___3 != 97) {
#line 1939
            tmp___0 = __errno_location();
#line 1939
            tmp___1 = strerror(*tmp___0);
#line 1939
            error("socket: %.100s", tmp___1);
#line 1940
            return ((char *)((void *)0));
          } else {
#line 1942
            debug("x11_create_display_inet: Socket family %d not supported", ai->ai_family);
            goto __Cont;
          }
        } else {
#line 1942
          debug("x11_create_display_inet: Socket family %d not supported", ai->ai_family);
          goto __Cont;
        }
      }
#line 1947
      tmp___6 = bind(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 1947
      if (tmp___6 < 0) {
#line 1948
        tmp___4 = __errno_location();
#line 1948
        tmp___5 = strerror(*tmp___4);
#line 1948
        debug("bind port %d: %.100s", port, tmp___5);
#line 1949
        shutdown(sock, 2);
#line 1950
        close(sock);
#line 1952
        if (ai->ai_next) {
          goto __Cont;
        }
#line 1955
        n___0 = 0;
#line 1955
        while (n___0 < num_socks) {
#line 1956
          shutdown(socks[n___0], 2);
#line 1957
          close(socks[n___0]);
#line 1955
          n___0 ++;
        }
#line 1959
        num_socks = 0;
#line 1960
        break;
      }
#line 1962
      tmp___7 = num_socks;
#line 1962
      num_socks ++;
#line 1962
      socks[tmp___7] = sock;
#line 1967
      break;
      __Cont: /* CIL Label */ 
#line 1933
      ai = ai->ai_next;
    }
#line 1970
    freeaddrinfo(aitop);
#line 1971
    if (num_socks > 0) {
#line 1972
      break;
    }
#line 1920
    display_number ++;
  }
#line 1974
  if (display_number >= 1000) {
#line 1975
    error("Failed to allocate internet-domain X11 display socket.");
#line 1976
    return ((char *)((void *)0));
  }
#line 1979
  n___0 = 0;
#line 1979
  while (n___0 < num_socks) {
#line 1980
    sock = socks[n___0];
#line 1981
    tmp___10 = listen(sock, 5);
#line 1981
    if (tmp___10 < 0) {
#line 1982
      tmp___8 = __errno_location();
#line 1982
      tmp___9 = strerror(*tmp___8);
#line 1982
      error("listen: %.100s", tmp___9);
#line 1983
      shutdown(sock, 2);
#line 1984
      close(sock);
#line 1985
      return ((char *)((void *)0));
    }
#line 1979
    n___0 ++;
  }
#line 1990
  tmp___13 = gethostname(hostname, sizeof(hostname));
#line 1990
  if (tmp___13 < 0) {
#line 1991
    tmp___11 = __errno_location();
#line 1991
    tmp___12 = strerror(*tmp___11);
#line 1991
    fatal("gethostname: %.100s", tmp___12);
  }
#line 2028
  snprintf((char * __restrict  )(display), sizeof(display), (char const   * __restrict  )"%.400s:%d.%d",
           hostname, display_number, screen_number);
#line 2033
  n___0 = 0;
#line 2033
  while (n___0 < num_socks) {
#line 2034
    sock = socks[n___0];
#line 2035
    tmp___14 = xstrdup("X11 inet listener");
#line 2035
    channel_new((char *)"x11 listener", 1, sock, sock, -1, 4096, 2048, 0, tmp___14,
                1);
#line 2033
    n___0 ++;
  }
#line 2042
  tmp___15 = xstrdup((char const   *)(display));
#line 2042
  return (tmp___15);
}
}
#line 2053
static int connect_local_xsocket(u_int dnr ) ;
#line 2053 "channels.c"
static char const   * const  x_sockets[4]  = {      (char const   * const  )"/tmp/.X11-unix/X%u",      (char const   * const  )"/var/X/.X11-unix/X%u",      (char const   * const  )"/usr/spool/sockets/X11/%u",      (char const   * const  )((void *)0)};
#line 2049 "channels.c"
static int connect_local_xsocket(u_int dnr ) 
{ int sock ;
  struct sockaddr_un addr ;
  char const   * const  *path ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 2063
  path = x_sockets;
#line 2063
  while (*path) {
#line 2064
    sock = socket(1, 1, 0);
#line 2065
    if (sock < 0) {
#line 2066
      tmp = __errno_location();
#line 2066
      tmp___0 = strerror(*tmp);
#line 2066
      error("socket: %.100s", tmp___0);
    }
#line 2067
    memset((void *)(& addr), 0, sizeof(addr));
#line 2068
    addr.sun_family = (unsigned short)1;
#line 2069
    snprintf((char * __restrict  )(addr.sun_path), sizeof(addr.sun_path), (char const   * __restrict  )*path,
             dnr);
#line 2070
    tmp___1 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& addr)),
                      sizeof(addr));
#line 2070
    if (tmp___1 == 0) {
#line 2071
      return (sock);
    }
#line 2072
    close(sock);
#line 2063
    path ++;
  }
#line 2074
  tmp___2 = __errno_location();
#line 2074
  tmp___3 = strerror(*tmp___2);
#line 2074
  error("connect %.100s: %.100s", addr.sun_path, tmp___3);
#line 2075
  return (-1);
}
}
#line 2078 "channels.c"
int x11_connect_display(void) 
{ int display_number ;
  int sock ;
  char const   *display ;
  char buf___2[1024] ;
  char *cp ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___29 ;
  int tmp___30 ;
  char const   *tmp___31 ;
  int *tmp___32 ;
  char *tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  int *tmp___37 ;
  char *tmp___38 ;

  {
#line 2081
  sock = 0;
#line 2089
  tmp = getenv("DISPLAY");
#line 2089
  display = (char const   *)tmp;
#line 2090
  if (! display) {
#line 2091
    error("DISPLAY not set.");
#line 2092
    return (-1);
  }
#line 2103
  if (0) {
#line 2103
    if (0) {
#line 2103
      __s1_len___0 = strlen(display);
#line 2103
      __s2_len___0 = strlen("unix:");
#line 2103
      if (! ((unsigned int )((void const   *)(display + 1)) - (unsigned int )((void const   *)display) == 1U)) {
        goto _L___2;
      } else {
#line 2103
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 2103
          if (! ((unsigned int )((void const   *)("unix:" + 1)) - (unsigned int )((void const   *)"unix:") == 1U)) {
#line 2103
            tmp___25 = 1;
          } else {
#line 2103
            if (__s2_len___0 >= 4U) {
#line 2103
              tmp___25 = 1;
            } else {
#line 2103
              tmp___25 = 0;
            }
          }
        } else {
#line 2103
          tmp___25 = 0;
        }
      }
#line 2103
      if (tmp___25) {
#line 2103
        tmp___21 = __builtin_strcmp(display, "unix:");
      } else {
#line 2103
        tmp___24 = __builtin_strcmp(display, "unix:");
#line 2103
        tmp___21 = tmp___24;
      }
    } else {
#line 2103
      tmp___24 = __builtin_strcmp(display, "unix:");
#line 2103
      tmp___21 = tmp___24;
    }
#line 2103
    tmp___15 = tmp___21;
  } else {
#line 2103
    tmp___15 = strncmp(display, "unix:", 5U);
  }
#line 2103
  if (tmp___15 == 0) {
    goto _L___3;
  } else {
#line 2103
    if ((int const   )*(display + 0) == 58) {
      _L___3: /* CIL Label */ 
#line 2106
      tmp___0 = strrchr(display, ':');
#line 2106
      tmp___1 = sscanf((char const   * __restrict  )(tmp___0 + 1), (char const   * __restrict  )"%d",
                       & display_number);
#line 2106
      if (tmp___1 != 1) {
#line 2107
        error("Could not parse display number from DISPLAY: %.100s", display);
#line 2109
        return (-1);
      }
#line 2112
      sock = connect_local_xsocket((unsigned int )display_number);
#line 2113
      if (sock < 0) {
#line 2114
        return (-1);
      }
#line 2117
      return (sock);
    }
  }
#line 2123
  __builtin_strncpy(buf___2, display, sizeof(buf___2));
#line 2124
  buf___2[sizeof(buf___2) - 1U] = (char)0;
#line 2125
  tmp___29 = __builtin_strchr(buf___2, ':');
#line 2125
  cp = tmp___29;
#line 2126
  if (! cp) {
#line 2127
    error("Could not find \':\' in DISPLAY: %.100s", display);
#line 2128
    return (-1);
  }
#line 2130
  *cp = (char)0;
#line 2132
  tmp___30 = sscanf((char const   * __restrict  )(cp + 1), (char const   * __restrict  )"%d",
                    & display_number);
#line 2132
  if (tmp___30 != 1) {
#line 2133
    error("Could not parse display number from DISPLAY: %.100s", display);
#line 2135
    return (-1);
  }
#line 2139
  memset((void *)(& hints), 0, sizeof(hints));
#line 2140
  hints.ai_family = IPv4or6;
#line 2141
  hints.ai_socktype = 1;
#line 2142
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           6000 + display_number);
#line 2143
  gaierr = getaddrinfo((char const   * __restrict  )(buf___2), (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 2143
  if (gaierr != 0) {
#line 2144
    tmp___31 = gai_strerror(gaierr);
#line 2144
    error("%.100s: unknown host. (%s)", buf___2, tmp___31);
#line 2145
    return (-1);
  }
#line 2147
  ai = aitop;
#line 2147
  while (ai) {
#line 2149
    sock = socket(ai->ai_family, 1, 0);
#line 2150
    if (sock < 0) {
#line 2151
      tmp___32 = __errno_location();
#line 2151
      tmp___33 = strerror(*tmp___32);
#line 2151
      debug("socket: %.100s", tmp___33);
      goto __Cont;
    }
#line 2155
    tmp___36 = connect(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 2155
    if (tmp___36 < 0) {
#line 2156
      tmp___34 = __errno_location();
#line 2156
      tmp___35 = strerror(*tmp___34);
#line 2156
      debug("connect %.100s port %d: %.100s", buf___2, 6000 + display_number, tmp___35);
#line 2158
      close(sock);
      goto __Cont;
    }
#line 2162
    break;
    __Cont: /* CIL Label */ 
#line 2147
    ai = ai->ai_next;
  }
#line 2164
  freeaddrinfo(aitop);
#line 2165
  if (! ai) {
#line 2166
    tmp___37 = __errno_location();
#line 2166
    tmp___38 = strerror(*tmp___37);
#line 2166
    error("connect %.100s port %d: %.100s", buf___2, 6000 + display_number, tmp___38);
#line 2168
    return (-1);
  }
#line 2170
  return (sock);
}
}
#line 2179 "channels.c"
void x11_input_open(int type , int plen , void *ctxt ) 
{ int remote_channel ;
  int sock ;
  int newch ;
  char *remote_host ;
  u_int remote_len ;
  u_int tmp ;
  int _p ;
  int _e ;
  int tmp___0 ;

  {
#line 2182
  sock = 0;
#line 2187
  tmp = packet_get_int();
#line 2187
  remote_channel = (int )tmp;
#line 2190
  if (have_hostname_in_open) {
#line 2191
    remote_host = packet_get_string(& remote_len);
#line 2192
    remote_len += 4U;
  } else {
#line 2194
    remote_host = xstrdup("unknown (remote did not supply name)");
#line 2195
    remote_len = 0U;
  }
#line 2198
  debug("Received X11 open request.");
#line 2199
  while (1) {
#line 2199
    _p = plen;
#line 2199
    _e = (int )(4U + remote_len);
#line 2199
    if (_p != _e) {
#line 2199
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 2199);
#line 2199
      packet_disconnect("Packet integrity error. (%d)", 27);
    }
#line 2199
    break;
  }
#line 2202
  sock = x11_connect_display();
#line 2203
  if (sock == -1) {
#line 2205
    packet_start(22);
#line 2206
    packet_put_int((unsigned int )remote_channel);
#line 2207
    packet_send();
  } else {
#line 2210
    if ((unsigned int )x11_saved_proto == (unsigned int )((void *)0)) {
#line 2210
      tmp___0 = 4;
    } else {
#line 2210
      tmp___0 = 7;
    }
#line 2210
    newch = channel_allocate(tmp___0, sock, remote_host);
#line 2214
    (channels + newch)->remote_id = remote_channel;
#line 2217
    packet_start(21);
#line 2218
    packet_put_int((unsigned int )remote_channel);
#line 2219
    packet_put_int((unsigned int )newch);
#line 2220
    packet_send();
  }
#line 2222
  return;
}
}
#line 2225 "channels.c"
void deny_input_open(int type , int plen , void *ctxt ) 
{ int rchan ;
  u_int tmp ;

  {
#line 2228
  tmp = packet_get_int();
#line 2228
  rchan = (int )tmp;
#line 2229
  switch (type) {
  case 31: 
#line 2231
  error("Warning: ssh server tried agent forwarding.");
#line 2232
  break;
  case 27: 
#line 2234
  error("Warning: ssh server tried X11 forwarding.");
#line 2235
  break;
  default: 
#line 2237
  error("deny_input_open: type %d plen %d", type, plen);
#line 2238
  break;
  }
#line 2240
  error("Warning: this is probably a break in attempt by a malicious server.");
#line 2241
  packet_start(22);
#line 2242
  packet_put_int((unsigned int )rchan);
#line 2243
  packet_send();
#line 2244
  return;
}
}
#line 2251 "channels.c"
void x11_request_forwarding_with_spoofing(int client_session_id , char const   *proto ,
                                          char const   *data ) 
{ u_int data_len ;
  size_t tmp ;
  u_int i ;
  u_int value ;
  u_int len ;
  char *new_data ;
  int screen_number ;
  char const   *cp ;
  u_int32_t rand___0 ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;

  {
#line 2255
  tmp = strlen(data);
#line 2255
  data_len = tmp / 2U;
#line 2260
  rand___0 = (u_int32_t )0;
#line 2262
  tmp___0 = getenv("DISPLAY");
#line 2262
  cp = (char const   *)tmp___0;
#line 2263
  if (cp) {
#line 2264
    tmp___2 = __builtin_strchr((char *)cp, ':');
#line 2264
    cp = (char const   *)tmp___2;
  }
#line 2265
  if (cp) {
#line 2266
    tmp___4 = __builtin_strchr((char *)cp, '.');
#line 2266
    cp = (char const   *)tmp___4;
  }
#line 2267
  if (cp) {
#line 2268
    screen_number = atoi(cp + 1);
  } else {
#line 2270
    screen_number = 0;
  }
#line 2273
  x11_saved_proto = xstrdup(proto);
#line 2279
  tmp___5 = xmalloc(data_len);
#line 2279
  x11_saved_data = (char *)tmp___5;
#line 2280
  tmp___6 = xmalloc(data_len);
#line 2280
  x11_fake_data = (char *)tmp___6;
#line 2281
  i = 0U;
#line 2281
  while (i < data_len) {
#line 2282
    tmp___7 = sscanf((char const   * __restrict  )(data + 2U * i), (char const   * __restrict  )"%2x",
                     & value);
#line 2282
    if (tmp___7 != 1) {
#line 2283
      fatal("x11_request_forwarding: bad authentication data: %.100s", data);
    }
#line 2284
    if (i % 4U == 0U) {
#line 2285
      rand___0 = arc4random();
    }
#line 2286
    *(x11_saved_data + i) = (char )value;
#line 2287
    *(x11_fake_data + i) = (char )(rand___0 & 255U);
#line 2288
    rand___0 >>= 8;
#line 2281
    i ++;
  }
#line 2290
  x11_saved_data_len = data_len;
#line 2291
  x11_fake_data_len = data_len;
#line 2294
  len = 2U * data_len + 1U;
#line 2295
  tmp___8 = xmalloc(len);
#line 2295
  new_data = (char *)tmp___8;
#line 2296
  i = 0U;
#line 2296
  while (i < data_len) {
#line 2297
    snprintf((char * __restrict  )(new_data + 2U * i), len - 2U * i, (char const   * __restrict  )"%02x",
             (unsigned char )*(x11_fake_data + i));
#line 2296
    i ++;
  }
#line 2301
  if (compat20) {
#line 2302
    channel_request_start(client_session_id, (char *)"x11-req", 0);
#line 2303
    packet_put_char(0);
  } else {
#line 2305
    packet_start(34);
  }
#line 2307
  packet_put_cstring(proto);
#line 2308
  packet_put_cstring((char const   *)new_data);
#line 2309
  packet_put_int((unsigned int )screen_number);
#line 2310
  packet_send();
#line 2311
  packet_write_wait();
#line 2312
  xfree((void *)new_data);
#line 2313
  return;
}
}
#line 2317 "channels.c"
void auth_request_forwarding(void) 
{ 

  {
#line 2320
  packet_start(30);
#line 2321
  packet_send();
#line 2322
  packet_write_wait();
#line 2323
  return;
}
}
#line 2331 "channels.c"
char *auth_get_socket_name(void) 
{ 

  {
#line 2334
  return (channel_forwarded_auth_socket_name);
}
}
#line 2339 "channels.c"
void cleanup_socket(void) 
{ 

  {
#line 2342
  unlink((char const   *)channel_forwarded_auth_socket_name);
#line 2343
  rmdir((char const   *)channel_forwarded_auth_socket_dir);
#line 2344
  return;
}
}
#line 2351 "channels.c"
int auth_input_request_forwarding(struct passwd *pw ) 
{ int sock ;
  int newch ;
  struct sockaddr_un sunaddr ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  __pid_t tmp___5 ;
  int saved ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;

  {
#line 2357
  tmp = auth_get_socket_name();
#line 2357
  if ((unsigned int )tmp != (unsigned int )((void *)0)) {
#line 2358
    fatal("Protocol error: authentication forwarding requested twice.");
  }
#line 2361
  temporarily_use_uid(pw->pw_uid);
#line 2364
  tmp___0 = xmalloc(100U);
#line 2364
  channel_forwarded_auth_socket_name = (char *)tmp___0;
#line 2365
  tmp___1 = xmalloc(100U);
#line 2365
  channel_forwarded_auth_socket_dir = (char *)tmp___1;
#line 2366
  strlcpy(channel_forwarded_auth_socket_dir, "/tmp/ssh-XXXXXXXX", 100U);
#line 2369
  tmp___4 = mkdtemp(channel_forwarded_auth_socket_dir);
#line 2369
  if ((unsigned int )tmp___4 == (unsigned int )((void *)0)) {
#line 2370
    tmp___2 = __errno_location();
#line 2370
    tmp___3 = strerror(*tmp___2);
#line 2370
    packet_send_debug("Agent forwarding disabled: mkdtemp() failed: %.100s", tmp___3);
#line 2372
    restore_uid();
#line 2373
    xfree((void *)channel_forwarded_auth_socket_name);
#line 2374
    xfree((void *)channel_forwarded_auth_socket_dir);
#line 2375
    channel_forwarded_auth_socket_name = (char *)((void *)0);
#line 2376
    channel_forwarded_auth_socket_dir = (char *)((void *)0);
#line 2377
    return (0);
  }
#line 2379
  tmp___5 = getpid();
#line 2379
  snprintf((char * __restrict  )channel_forwarded_auth_socket_name, 100U, (char const   * __restrict  )"%s/agent.%d",
           channel_forwarded_auth_socket_dir, tmp___5);
#line 2382
  tmp___8 = atexit(& cleanup_socket);
#line 2382
  if (tmp___8 < 0) {
#line 2383
    tmp___6 = __errno_location();
#line 2383
    saved = *tmp___6;
#line 2384
    cleanup_socket();
#line 2385
    tmp___7 = strerror(saved);
#line 2385
    packet_disconnect("socket: %.100s", tmp___7);
  }
#line 2388
  sock = socket(1, 1, 0);
#line 2389
  if (sock < 0) {
#line 2390
    tmp___9 = __errno_location();
#line 2390
    tmp___10 = strerror(*tmp___9);
#line 2390
    packet_disconnect("socket: %.100s", tmp___10);
  }
#line 2393
  memset((void *)(& sunaddr), 0, sizeof(sunaddr));
#line 2394
  sunaddr.sun_family = (unsigned short)1;
#line 2395
  __builtin_strncpy(sunaddr.sun_path, (char const   *)channel_forwarded_auth_socket_name,
                    sizeof(sunaddr.sun_path));
#line 2398
  tmp___13 = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sunaddr)),
                  sizeof(sunaddr));
#line 2398
  if (tmp___13 < 0) {
#line 2399
    tmp___11 = __errno_location();
#line 2399
    tmp___12 = strerror(*tmp___11);
#line 2399
    packet_disconnect("bind: %.100s", tmp___12);
  }
#line 2402
  restore_uid();
#line 2405
  tmp___16 = listen(sock, 5);
#line 2405
  if (tmp___16 < 0) {
#line 2406
    tmp___14 = __errno_location();
#line 2406
    tmp___15 = strerror(*tmp___14);
#line 2406
    packet_disconnect("listen: %.100s", tmp___15);
  }
#line 2409
  tmp___17 = xstrdup("auth socket");
#line 2409
  newch = channel_new((char *)"auth socket", 6, sock, sock, -1, 4096, 2048, 0, tmp___17,
                      1);
#line 2414
  strlcpy((channels + newch)->path, (char const   *)channel_forwarded_auth_socket_name,
          sizeof((channels + newch)->path));
#line 2416
  return (1);
}
}
#line 2421 "channels.c"
void auth_input_open_request(int type , int plen , void *ctxt ) 
{ int remch ;
  int sock ;
  int newch ;
  char *dummyname ;
  int _p ;
  int _e ;
  u_int tmp ;

  {
#line 2427
  while (1) {
#line 2427
    _p = plen;
#line 2427
    _e = 4;
#line 2427
    if (_p != _e) {
#line 2427
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 2427);
#line 2427
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 2427
    break;
  }
#line 2430
  tmp = packet_get_int();
#line 2430
  remch = (int )tmp;
#line 2436
  sock = ssh_get_authentication_socket();
#line 2444
  if (sock < 0) {
#line 2445
    packet_start(22);
#line 2446
    packet_put_int((unsigned int )remch);
#line 2447
    packet_send();
#line 2448
    return;
  }
#line 2450
  debug("Forwarding authentication connection.");
#line 2457
  dummyname = xstrdup("authentication agent connection");
#line 2459
  newch = channel_allocate(4, sock, dummyname);
#line 2460
  (channels + newch)->remote_id = remch;
#line 2463
  packet_start(21);
#line 2464
  packet_put_int((unsigned int )remch);
#line 2465
  packet_put_int((unsigned int )newch);
#line 2466
  packet_send();
#line 2467
  return;
}
}
#line 2469 "channels.c"
void channel_start_open(int id ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2472
  tmp = channel_lookup(id);
#line 2472
  c = tmp;
#line 2473
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2474
    log("channel_open: %d: bad id", id);
#line 2475
    return;
  }
#line 2477
  debug("send channel open %d", id);
#line 2478
  packet_start(90);
#line 2479
  packet_put_cstring((char const   *)c->ctype);
#line 2480
  packet_put_int((unsigned int )c->self);
#line 2481
  packet_put_int((unsigned int )c->local_window);
#line 2482
  packet_put_int((unsigned int )c->local_maxpacket);
#line 2483
  return;
}
}
#line 2484 "channels.c"
void channel_open(int id ) 
{ 

  {
#line 2488
  channel_start_open(id);
#line 2489
  packet_send();
#line 2490
  return;
}
}
#line 2491 "channels.c"
void channel_request(int id , char *service , int wantconfirm ) 
{ 

  {
#line 2494
  channel_request_start(id, service, wantconfirm);
#line 2495
  packet_send();
#line 2496
  debug("channel request %d: %s", id, service);
#line 2497
  return;
}
}
#line 2498 "channels.c"
void channel_request_start(int id , char *service , int wantconfirm ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2501
  tmp = channel_lookup(id);
#line 2501
  c = tmp;
#line 2502
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2503
    log("channel_request: %d: bad id", id);
#line 2504
    return;
  }
#line 2506
  packet_start(98);
#line 2507
  packet_put_int((unsigned int )c->remote_id);
#line 2508
  packet_put_cstring((char const   *)service);
#line 2509
  packet_put_char(wantconfirm);
#line 2510
  return;
}
}
#line 2511 "channels.c"
void channel_register_callback(int id , int mtype , channel_callback_fn *fn , void *arg ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2514
  tmp = channel_lookup(id);
#line 2514
  c = tmp;
#line 2515
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2516
    log("channel_register_callback: %d: bad id", id);
#line 2517
    return;
  }
#line 2519
  c->cb_event = mtype;
#line 2520
  c->cb_fn = fn;
#line 2521
  c->cb_arg = arg;
#line 2522
  return;
}
}
#line 2523 "channels.c"
void channel_register_cleanup(int id , channel_callback_fn *fn ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2526
  tmp = channel_lookup(id);
#line 2526
  c = tmp;
#line 2527
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2528
    log("channel_register_cleanup: %d: bad id", id);
#line 2529
    return;
  }
#line 2531
  c->dettach_user = fn;
#line 2532
  return;
}
}
#line 2533 "channels.c"
void channel_cancel_cleanup(int id ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2536
  tmp = channel_lookup(id);
#line 2536
  c = tmp;
#line 2537
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2538
    log("channel_cancel_cleanup: %d: bad id", id);
#line 2539
    return;
  }
#line 2541
  c->dettach_user = (channel_callback_fn *)((void *)0);
#line 2542
  return;
}
}
#line 2543 "channels.c"
void channel_register_filter(int id , channel_filter_fn *fn ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2546
  tmp = channel_lookup(id);
#line 2546
  c = tmp;
#line 2547
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2548
    log("channel_register_filter: %d: bad id", id);
#line 2549
    return;
  }
#line 2551
  c->input_filter = fn;
#line 2552
  return;
}
}
#line 2554 "channels.c"
void channel_set_fds(int id , int rfd , int wfd , int efd , int extusage , int nonblock ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2558
  tmp = channel_lookup(id);
#line 2558
  c = tmp;
#line 2559
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2560
    fatal("channel_activate for non-larval channel %d.", id);
  } else {
#line 2559
    if (c->type != 10) {
#line 2560
      fatal("channel_activate for non-larval channel %d.", id);
    }
  }
#line 2561
  channel_register_fds(c, rfd, wfd, efd, extusage, nonblock);
#line 2562
  c->type = 4;
#line 2564
  c->local_window_max = c->local_maxpacket * 2;
#line 2564
  c->local_window = c->local_window_max;
#line 2565
  packet_start(93);
#line 2566
  packet_put_int((unsigned int )c->remote_id);
#line 2567
  packet_put_int((unsigned int )c->local_window);
#line 2568
  packet_send();
#line 2569
  return;
}
}
#line 1 "cipher.o"
#pragma merger(0,"./cipher.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 325 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 1205 "/usr/include/bits/string2.h"
extern char *__strsep_g(char **__stringp , char const   *__delim ) ;
#line 141 "/usr/include/openssl/des.h"
extern void DES_ncbc_encrypt(unsigned char const   *input , unsigned char *output ,
                             long length , DES_key_schedule *schedule , DES_cblock *ivec ,
                             int enc ) ;
#line 176
extern void DES_ede3_cbc_encrypt(unsigned char const   *input , unsigned char *output ,
                                 long length , DES_key_schedule *ks1 , DES_key_schedule *ks2 ,
                                 DES_key_schedule *ks3 , DES_cblock *ivec , int enc ) ;
#line 222
extern int DES_set_key(const_DES_cblock *key , DES_key_schedule *schedule ) ;
#line 108 "/usr/include/openssl/blowfish.h"
extern void BF_set_key(BF_KEY *key , int len , unsigned char const   *data ) ;
#line 115
extern void BF_cbc_encrypt(unsigned char const   *in , unsigned char *out , long length ,
                           BF_KEY const   *schedule , unsigned char *ivec , int enc ) ;
#line 87 "/usr/include/openssl/cast.h"
extern void CAST_set_key(CAST_KEY *key , int len , unsigned char const   *data ) ;
#line 92
extern void CAST_cbc_encrypt(unsigned char const   *in , unsigned char *out , long length ,
                             CAST_KEY *ks , unsigned char *iv , int enc ) ;
#line 31 "rijndael.h"
rijndael_ctx *rijndael_set_key(rijndael_ctx *ctx , u4byte const   *in_key , u4byte key_len ,
                               int encrypt ) ;
#line 32
void rijndael_encrypt(rijndael_ctx *ctx , u4byte const   *in_blk , u4byte *out_blk ) ;
#line 33
void rijndael_decrypt(rijndael_ctx *ctx , u4byte const   *in_blk , u4byte *out_blk ) ;
#line 106 "cipher.h"
u_int cipher_mask_ssh1(int client ) ;
#line 107
Cipher *cipher_by_name(char const   *name ) ;
#line 109
int cipher_number(char const   *name ) ;
#line 110
char *cipher_name(int id ) ;
#line 111
int ciphers_valid(char const   *names ) ;
#line 112
void cipher_init(CipherContext *cc , Cipher *cipher , u_char const   *key , u_int keylen ,
                 u_char const   *iv , u_int ivlen ) ;
#line 107 "/usr/include/openssl/md5.h"
extern int MD5_Init(MD5_CTX *c ) ;
#line 108
extern int MD5_Update(MD5_CTX *c , void const   *data , size_t len ) ;
#line 109
extern int MD5_Final(unsigned char *md , MD5_CTX *c ) ;
#line 48 "cipher.c"
void none_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) 
{ 

  {
#line 51
  return;
}
}
#line 52 "cipher.c"
void none_setiv(CipherContext *cc , u_char const   *iv , u_int ivlen ) 
{ 

  {
#line 55
  return;
}
}
#line 56 "cipher.c"
void none_crypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 59
  memcpy((void * __restrict  )dest, (void const   * __restrict  )src, len);
#line 60
  return;
}
}
#line 66
void des_ssh1_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) ;
#line 66 "cipher.c"
static int dowarn  =    1;
#line 63 "cipher.c"
void des_ssh1_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) 
{ 

  {
#line 67
  if (dowarn) {
#line 68
    error("Warning: use of DES is strongly discouraged due to cryptographic weaknesses");
#line 70
    dowarn = 0;
  }
#line 72
  DES_set_key((const_DES_cblock *)((void *)key), & cc->u.des.key);
#line 73
  return;
}
}
#line 74 "cipher.c"
void des_ssh1_setiv(CipherContext *cc , u_char const   *iv , u_int ivlen ) 
{ 

  {
#line 77
  memset((void *)(cc->u.des.iv), 0, sizeof(cc->u.des.iv));
#line 78
  return;
}
}
#line 79 "cipher.c"
void des_ssh1_encrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 82
  DES_ncbc_encrypt(src, dest, (long )len, & cc->u.des.key, & cc->u.des.iv, 1);
#line 84
  return;
}
}
#line 85 "cipher.c"
void des_ssh1_decrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 88
  DES_ncbc_encrypt(src, dest, (long )len, & cc->u.des.key, & cc->u.des.iv, 0);
#line 90
  return;
}
}
#line 93 "cipher.c"
void des3_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) 
{ 

  {
#line 96
  DES_set_key((const_DES_cblock *)((void *)key), & cc->u.des3.key1);
#line 97
  DES_set_key((const_DES_cblock *)((void *)(key + 8)), & cc->u.des3.key2);
#line 98
  DES_set_key((const_DES_cblock *)((void *)(key + 16)), & cc->u.des3.key3);
#line 99
  return;
}
}
#line 100 "cipher.c"
void des3_setiv(CipherContext *cc , u_char const   *iv , u_int ivlen ) 
{ 

  {
#line 103
  memset((void *)(cc->u.des3.iv2), 0, sizeof(cc->u.des3.iv2));
#line 104
  memset((void *)(cc->u.des3.iv3), 0, sizeof(cc->u.des3.iv3));
#line 105
  if ((unsigned int )iv == (unsigned int )((void *)0)) {
#line 106
    return;
  }
#line 107
  memcpy((void * __restrict  )(cc->u.des3.iv3), (void const   * __restrict  )((char *)iv),
         8U);
#line 108
  return;
}
}
#line 109 "cipher.c"
void des3_cbc_encrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 112
  DES_ede3_cbc_encrypt(src, dest, (long )len, & cc->u.des3.key1, & cc->u.des3.key2,
                       & cc->u.des3.key3, & cc->u.des3.iv3, 1);
#line 115
  return;
}
}
#line 116 "cipher.c"
void des3_cbc_decrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 119
  DES_ede3_cbc_encrypt(src, dest, (long )len, & cc->u.des3.key1, & cc->u.des3.key2,
                       & cc->u.des3.key3, & cc->u.des3.iv3, 0);
#line 122
  return;
}
}
#line 138 "cipher.c"
void des3_ssh1_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) 
{ 

  {
#line 141
  DES_set_key((const_DES_cblock *)((void *)key), & cc->u.des3.key1);
#line 142
  DES_set_key((const_DES_cblock *)((void *)(key + 8)), & cc->u.des3.key2);
#line 143
  if (keylen <= 16U) {
#line 144
    DES_set_key((const_DES_cblock *)((void *)key), & cc->u.des3.key3);
  } else {
#line 146
    DES_set_key((const_DES_cblock *)((void *)(key + 16)), & cc->u.des3.key3);
  }
#line 147
  return;
}
}
#line 148 "cipher.c"
void des3_ssh1_encrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ DES_cblock iv1 ;
  DES_cblock *iv2 ;
  DES_cblock *iv3 ;

  {
#line 153
  iv2 = & cc->u.des3.iv2;
#line 154
  iv3 = & cc->u.des3.iv3;
#line 156
  memcpy((void * __restrict  )(& iv1), (void const   * __restrict  )iv2, 8U);
#line 158
  DES_ncbc_encrypt(src, dest, (long )len, & cc->u.des3.key1, & iv1, 1);
#line 159
  DES_ncbc_encrypt((unsigned char const   *)dest, dest, (long )len, & cc->u.des3.key2,
                   iv2, 0);
#line 160
  DES_ncbc_encrypt((unsigned char const   *)dest, dest, (long )len, & cc->u.des3.key3,
                   iv3, 1);
#line 161
  return;
}
}
#line 162 "cipher.c"
void des3_ssh1_decrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ DES_cblock iv1 ;
  DES_cblock *iv2 ;
  DES_cblock *iv3 ;

  {
#line 167
  iv2 = & cc->u.des3.iv2;
#line 168
  iv3 = & cc->u.des3.iv3;
#line 170
  memcpy((void * __restrict  )(& iv1), (void const   * __restrict  )iv2, 8U);
#line 172
  DES_ncbc_encrypt(src, dest, (long )len, & cc->u.des3.key3, iv3, 0);
#line 173
  DES_ncbc_encrypt((unsigned char const   *)dest, dest, (long )len, & cc->u.des3.key2,
                   iv2, 1);
#line 174
  DES_ncbc_encrypt((unsigned char const   *)dest, dest, (long )len, & cc->u.des3.key1,
                   & iv1, 0);
#line 175
  return;
}
}
#line 178 "cipher.c"
void blowfish_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) 
{ 

  {
#line 181
  BF_set_key(& cc->u.bf.key, (int )keylen, (unsigned char const   *)((u_char *)key));
#line 182
  return;
}
}
#line 183 "cipher.c"
void blowfish_setiv(CipherContext *cc , u_char const   *iv , u_int ivlen ) 
{ 

  {
#line 186
  if ((unsigned int )iv == (unsigned int )((void *)0)) {
#line 187
    memset((void *)(cc->u.bf.iv), 0, 8U);
  } else {
#line 189
    memcpy((void * __restrict  )(cc->u.bf.iv), (void const   * __restrict  )((char *)iv),
           8U);
  }
#line 190
  return;
}
}
#line 191 "cipher.c"
void blowfish_cbc_encrypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                          u_int len ) 
{ 

  {
#line 195
  BF_cbc_encrypt((unsigned char const   *)((void *)src), dest, (long )len, (BF_KEY const   *)(& cc->u.bf.key),
                 cc->u.bf.iv, 1);
#line 197
  return;
}
}
#line 198 "cipher.c"
void blowfish_cbc_decrypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                          u_int len ) 
{ 

  {
#line 202
  BF_cbc_encrypt((unsigned char const   *)((void *)src), dest, (long )len, (BF_KEY const   *)(& cc->u.bf.key),
                 cc->u.bf.iv, 0);
#line 204
  return;
}
}
#line 210 "cipher.c"
static void swap_bytes(u_char const   *src , u_char *dst , int n___0 ) 
{ char c[4] ;
  u_char const   *tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  u_char const   *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  u_char *tmp___6 ;

  {
#line 216
  n___0 /= 4;
#line 216
  while (n___0 > 0) {
#line 217
    tmp = src;
#line 217
    src ++;
#line 217
    c[3] = (char )*tmp;
#line 218
    tmp___0 = src;
#line 218
    src ++;
#line 218
    c[2] = (char )*tmp___0;
#line 219
    tmp___1 = src;
#line 219
    src ++;
#line 219
    c[1] = (char )*tmp___1;
#line 220
    tmp___2 = src;
#line 220
    src ++;
#line 220
    c[0] = (char )*tmp___2;
#line 222
    tmp___3 = dst;
#line 222
    dst ++;
#line 222
    *tmp___3 = (unsigned char )c[0];
#line 223
    tmp___4 = dst;
#line 223
    dst ++;
#line 223
    *tmp___4 = (unsigned char )c[1];
#line 224
    tmp___5 = dst;
#line 224
    dst ++;
#line 224
    *tmp___5 = (unsigned char )c[2];
#line 225
    tmp___6 = dst;
#line 225
    dst ++;
#line 225
    *tmp___6 = (unsigned char )c[3];
#line 216
    n___0 --;
  }
#line 227
  return;
}
}
#line 229 "cipher.c"
void blowfish_ssh1_encrypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                           u_int len ) 
{ 

  {
#line 233
  swap_bytes(src, dest, (int )len);
#line 234
  BF_cbc_encrypt((unsigned char const   *)((void *)dest), dest, (long )len, (BF_KEY const   *)(& cc->u.bf.key),
                 cc->u.bf.iv, 1);
#line 236
  swap_bytes((u_char const   *)dest, dest, (int )len);
#line 237
  return;
}
}
#line 238 "cipher.c"
void blowfish_ssh1_decrypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                           u_int len ) 
{ 

  {
#line 242
  swap_bytes(src, dest, (int )len);
#line 243
  BF_cbc_encrypt((unsigned char const   *)((void *)dest), dest, (long )len, (BF_KEY const   *)(& cc->u.bf.key),
                 cc->u.bf.iv, 0);
#line 245
  swap_bytes((u_char const   *)dest, dest, (int )len);
#line 246
  return;
}
}
#line 249 "cipher.c"
void arcfour_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) 
{ 

  {
#line 252
  RC4_set_key(& cc->u.rc4, (int )keylen, (unsigned char const   *)((u_char *)key));
#line 253
  return;
}
}
#line 254 "cipher.c"
void arcfour_crypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 257
  RC4(& cc->u.rc4, (unsigned long )len, (unsigned char const   *)((u_char *)src),
      dest);
#line 258
  return;
}
}
#line 261 "cipher.c"
void cast_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) 
{ 

  {
#line 264
  CAST_set_key(& cc->u.cast.key, (int )keylen, (unsigned char const   *)((u_char *)key));
#line 265
  return;
}
}
#line 266 "cipher.c"
void cast_setiv(CipherContext *cc , u_char const   *iv , u_int ivlen ) 
{ 

  {
#line 269
  if ((unsigned int )iv == (unsigned int )((void *)0)) {
#line 270
    fatal("no IV for %s.", (cc->cipher)->name);
  }
#line 271
  memcpy((void * __restrict  )(cc->u.cast.iv), (void const   * __restrict  )((char *)iv),
         8U);
#line 272
  return;
}
}
#line 273 "cipher.c"
void cast_cbc_encrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 276
  CAST_cbc_encrypt(src, dest, (long )len, & cc->u.cast.key, cc->u.cast.iv, 1);
#line 278
  return;
}
}
#line 279 "cipher.c"
void cast_cbc_decrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 282
  CAST_cbc_encrypt(src, dest, (long )len, & cc->u.cast.key, cc->u.cast.iv, 0);
#line 284
  return;
}
}
#line 289 "cipher.c"
void rijndael_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) 
{ 

  {
#line 292
  rijndael_set_key(& cc->u.rijndael.enc, (u4byte const   *)((u4byte *)key), 8U * keylen,
                   1);
#line 293
  rijndael_set_key(& cc->u.rijndael.dec, (u4byte const   *)((u4byte *)key), 8U * keylen,
                   0);
#line 294
  return;
}
}
#line 295 "cipher.c"
void rijndael_setiv(CipherContext *cc , u_char const   *iv , u_int ivlen ) 
{ 

  {
#line 298
  if ((unsigned int )iv == (unsigned int )((void *)0)) {
#line 299
    fatal("no IV for %s.", (cc->cipher)->name);
  }
#line 300
  memcpy((void * __restrict  )((u_char *)(cc->u.rijndael.iv)), (void const   * __restrict  )iv,
         16U);
#line 301
  return;
}
}
#line 302 "cipher.c"
void rijndael_cbc_encrypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                          u_int len ) 
{ rijndael_ctx *ctx ;
  u4byte *iv ;
  u4byte in[4] ;
  u4byte *cprev ;
  u4byte *cnow ;
  u4byte *plain ;
  int i ;
  int blocks ;

  {
#line 306
  ctx = & cc->u.rijndael.enc;
#line 307
  iv = cc->u.rijndael.iv;
#line 310
  blocks = (int )(len / 16U);
#line 311
  if (len == 0U) {
#line 312
    return;
  }
#line 313
  if (len % 16U) {
#line 314
    fatal("rijndael_cbc_encrypt: bad len %d", len);
  }
#line 315
  cnow = (u4byte *)dest;
#line 316
  plain = (u4byte *)src;
#line 317
  cprev = iv;
#line 318
  i = 0;
#line 318
  while (i < blocks) {
#line 319
    in[0] = *(plain + 0) ^ *(cprev + 0);
#line 320
    in[1] = *(plain + 1) ^ *(cprev + 1);
#line 321
    in[2] = *(plain + 2) ^ *(cprev + 2);
#line 322
    in[3] = *(plain + 3) ^ *(cprev + 3);
#line 323
    rijndael_encrypt(ctx, (u4byte const   *)(in), cnow);
#line 324
    cprev = cnow;
#line 318
    i ++;
#line 318
    plain += 4;
#line 318
    cnow += 4;
  }
#line 326
  memcpy((void * __restrict  )iv, (void const   * __restrict  )cprev, 16U);
#line 327
  return;
}
}
#line 329 "cipher.c"
void rijndael_cbc_decrypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                          u_int len ) 
{ rijndael_ctx *ctx ;
  u4byte *iv ;
  u4byte ivsaved[4] ;
  u4byte *cnow ;
  u4byte *plain ;
  u4byte *ivp ;
  int i ;
  int blocks ;

  {
#line 333
  ctx = & cc->u.rijndael.dec;
#line 334
  iv = cc->u.rijndael.iv;
#line 336
  cnow = (u4byte *)((src + len) - 16);
#line 337
  plain = (u4byte *)((dest + len) - 16);
#line 339
  blocks = (int )(len / 16U);
#line 340
  if (len == 0U) {
#line 341
    return;
  }
#line 342
  if (len % 16U) {
#line 343
    fatal("rijndael_cbc_decrypt: bad len %d", len);
  }
#line 344
  memcpy((void * __restrict  )(ivsaved), (void const   * __restrict  )cnow, 16U);
#line 345
  i = blocks;
#line 345
  while (i > 0) {
#line 346
    rijndael_decrypt(ctx, (u4byte const   *)cnow, plain);
#line 347
    if (i == 1) {
#line 347
      ivp = iv;
    } else {
#line 347
      ivp = cnow - 4;
    }
#line 348
    *(plain + 0) ^= *(ivp + 0);
#line 349
    *(plain + 1) ^= *(ivp + 1);
#line 350
    *(plain + 2) ^= *(ivp + 2);
#line 351
    *(plain + 3) ^= *(ivp + 3);
#line 345
    i --;
#line 345
    cnow -= 4;
#line 345
    plain -= 4;
  }
#line 353
  memcpy((void * __restrict  )iv, (void const   * __restrict  )(ivsaved), 16U);
#line 354
  return;
}
}
#line 356 "cipher.c"
Cipher ciphers[16]  = 
#line 356
  {      {(char *)"none", 0, (u_int )8, (u_int )0, & none_setkey, & none_setiv, & none_crypt,
      & none_crypt}, 
        {(char *)"des", 2, (u_int )8, (u_int )8, & des_ssh1_setkey, & des_ssh1_setiv,
      & des_ssh1_encrypt, & des_ssh1_decrypt}, 
        {(char *)"3des", 3, (u_int )8, (u_int )16, & des3_ssh1_setkey, & des3_setiv,
      & des3_ssh1_encrypt, & des3_ssh1_decrypt}, 
        {(char *)"blowfish", 6, (u_int )8, (u_int )16, & blowfish_setkey, & blowfish_setiv,
      & blowfish_ssh1_encrypt, & blowfish_ssh1_decrypt}, 
        {(char *)"3des-cbc", -3, (u_int )8, (u_int )24, & des3_setkey, & des3_setiv,
      & des3_cbc_encrypt, & des3_cbc_decrypt}, 
        {(char *)"blowfish-cbc", -3, (u_int )8, (u_int )16, & blowfish_setkey, & blowfish_setiv,
      & blowfish_cbc_encrypt, & blowfish_cbc_decrypt}, 
        {(char *)"cast128-cbc", -3, (u_int )8, (u_int )16, & cast_setkey, & cast_setiv,
      & cast_cbc_encrypt, & cast_cbc_decrypt}, 
        {(char *)"arcfour", -3, (u_int )8, (u_int )16, & arcfour_setkey, & none_setiv,
      & arcfour_crypt, & arcfour_crypt}, 
        {(char *)"aes128-cbc", -3, (u_int )16, (u_int )16, & rijndael_setkey, & rijndael_setiv,
      & rijndael_cbc_encrypt, & rijndael_cbc_decrypt}, 
        {(char *)"aes192-cbc", -3, (u_int )16, (u_int )24, & rijndael_setkey, & rijndael_setiv,
      & rijndael_cbc_encrypt, & rijndael_cbc_decrypt}, 
        {(char *)"aes256-cbc", -3, (u_int )16, (u_int )32, & rijndael_setkey, & rijndael_setiv,
      & rijndael_cbc_encrypt, & rijndael_cbc_decrypt}, 
        {(char *)"rijndael128-cbc", -3, (u_int )16, (u_int )16, & rijndael_setkey, & rijndael_setiv,
      & rijndael_cbc_encrypt, & rijndael_cbc_decrypt}, 
        {(char *)"rijndael192-cbc", -3, (u_int )16, (u_int )24, & rijndael_setkey, & rijndael_setiv,
      & rijndael_cbc_encrypt, & rijndael_cbc_decrypt}, 
        {(char *)"rijndael256-cbc", -3, (u_int )16, (u_int )32, & rijndael_setkey, & rijndael_setiv,
      & rijndael_cbc_encrypt, & rijndael_cbc_decrypt}, 
        {(char *)"rijndael-cbc@lysator.liu.se", -3, (u_int )16, (u_int )32, & rijndael_setkey,
      & rijndael_setiv, & rijndael_cbc_encrypt, & rijndael_cbc_decrypt}, 
        {(char *)((void *)0), -2, (u_int )0, (u_int )0, (void (*)(CipherContext * , u_char const   * ,
                                                               u_int  ))((void *)0),
      (void (*)(CipherContext * , u_char const   * , u_int  ))((void *)0), (void (*)(CipherContext * ,
                                                                                     u_char * ,
                                                                                     u_char const   * ,
                                                                                     u_int  ))((void *)0),
      (void (*)(CipherContext * , u_char * , u_char const   * , u_int  ))((void *)0)}};
#line 423 "cipher.c"
u_int cipher_mask_ssh1(int client ) 
{ u_int mask ;

  {
#line 426
  mask = (u_int )0;
#line 427
  mask |= (unsigned int )(1 << 3);
#line 428
  mask |= (unsigned int )(1 << 6);
#line 429
  if (client) {
#line 430
    mask |= (unsigned int )(1 << 2);
  }
#line 432
  return (mask);
}
}
#line 435 "cipher.c"
Cipher *cipher_by_name(char const   *name ) 
{ Cipher *c ;
  int tmp ;

  {
#line 439
  c = ciphers;
#line 439
  while ((unsigned int )c->name != (unsigned int )((void *)0)) {
#line 440
    tmp = strcasecmp((char const   *)c->name, name);
#line 440
    if (tmp == 0) {
#line 441
      return (c);
    }
#line 439
    c ++;
  }
#line 442
  return ((Cipher *)((void *)0));
}
}
#line 445 "cipher.c"
Cipher *cipher_by_number(int id ) 
{ Cipher *c ;

  {
#line 449
  c = ciphers;
#line 449
  while ((unsigned int )c->name != (unsigned int )((void *)0)) {
#line 450
    if (c->number == id) {
#line 451
      return (c);
    }
#line 449
    c ++;
  }
#line 452
  return ((Cipher *)((void *)0));
}
}
#line 456 "cipher.c"
int ciphers_valid(char const   *names ) 
{ Cipher *c ;
  char *ciphers___0 ;
  char *cp ;
  char *p ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___24 ;
  char *tmp___40 ;

  {
#line 463
  if ((unsigned int )names == (unsigned int )((void *)0)) {
#line 464
    return (0);
  } else {
#line 463
    if (0) {
#line 463
      __s1_len = strlen(names);
#line 463
      __s2_len = strlen("");
#line 463
      if (! ((unsigned int )((void const   *)(names + 1)) - (unsigned int )((void const   *)names) == 1U)) {
        goto _L___0;
      } else {
#line 463
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 463
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 463
            tmp___8 = 1;
          } else {
#line 463
            if (__s2_len >= 4U) {
#line 463
              tmp___8 = 1;
            } else {
#line 463
              tmp___8 = 0;
            }
          }
        } else {
#line 463
          tmp___8 = 0;
        }
      }
#line 463
      if (tmp___8) {
#line 463
        tmp___4 = __builtin_strcmp(names, "");
      } else {
#line 463
        tmp___7 = __builtin_strcmp(names, "");
#line 463
        tmp___4 = tmp___7;
      }
    } else {
#line 463
      tmp___7 = __builtin_strcmp(names, "");
#line 463
      tmp___4 = tmp___7;
    }
#line 463
    if (tmp___4 == 0) {
#line 464
      return (0);
    }
  }
#line 465
  cp = xstrdup(names);
#line 465
  ciphers___0 = cp;
#line 466
  tmp___24 = __strsep_g(& cp, ",");
#line 466
  p = tmp___24;
#line 466
  while (1) {
#line 466
    if (p) {
#line 466
      if (! ((int )*p != 0)) {
#line 466
        break;
      }
    } else {
#line 466
      break;
    }
#line 468
    c = cipher_by_name((char const   *)p);
#line 469
    if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 470
      debug("bad cipher %s [%s]", p, names);
#line 471
      xfree((void *)ciphers___0);
#line 472
      return (0);
    } else {
#line 469
      if (c->number != -3) {
#line 470
        debug("bad cipher %s [%s]", p, names);
#line 471
        xfree((void *)ciphers___0);
#line 472
        return (0);
      } else {
#line 474
        debug3("cipher ok: %s [%s]", p, names);
      }
    }
#line 467
    tmp___40 = __strsep_g(& cp, ",");
#line 467
    p = tmp___40;
  }
#line 477
  debug3("ciphers ok: [%s]", names);
#line 478
  xfree((void *)ciphers___0);
#line 479
  return (1);
}
}
#line 487 "cipher.c"
int cipher_number(char const   *name ) 
{ Cipher *c ;
  int tmp ;

  {
#line 491
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 492
    return (-1);
  }
#line 493
  c = cipher_by_name(name);
#line 494
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 494
    tmp = -1;
  } else {
#line 494
    tmp = c->number;
  }
#line 494
  return (tmp);
}
}
#line 497 "cipher.c"
char *cipher_name(int id ) 
{ Cipher *c ;
  Cipher *tmp ;
  char const   *tmp___0 ;

  {
#line 500
  tmp = cipher_by_number(id);
#line 500
  c = tmp;
#line 501
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 501
    tmp___0 = "<unknown>";
  } else {
#line 501
    tmp___0 = (char const   *)c->name;
  }
#line 501
  return ((char *)tmp___0);
}
}
#line 504 "cipher.c"
void cipher_init(CipherContext *cc , Cipher *cipher , u_char const   *key , u_int keylen ,
                 u_char const   *iv , u_int ivlen ) 
{ 

  {
#line 508
  if (keylen < cipher->key_len) {
#line 509
    fatal("cipher_init: key length %d is insufficient for %s.", keylen, cipher->name);
  }
#line 511
  if ((unsigned int )iv != (unsigned int )((void *)0)) {
#line 511
    if (ivlen < cipher->block_size) {
#line 512
      fatal("cipher_init: iv length %d is insufficient for %s.", ivlen, cipher->name);
    }
  }
#line 514
  cc->cipher = cipher;
#line 515
  (*(cipher->setkey))(cc, key, keylen);
#line 516
  (*(cipher->setiv))(cc, iv, ivlen);
#line 517
  return;
}
}
#line 519 "cipher.c"
void cipher_encrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 522
  if (len % (cc->cipher)->block_size) {
#line 523
    fatal("cipher_encrypt: bad plaintext length %d", len);
  }
#line 524
  (*((cc->cipher)->encrypt))(cc, dest, src, len);
#line 525
  return;
}
}
#line 527 "cipher.c"
void cipher_decrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 530
  if (len % (cc->cipher)->block_size) {
#line 531
    fatal("cipher_decrypt: bad ciphertext length %d", len);
  }
#line 532
  (*((cc->cipher)->decrypt))(cc, dest, src, len);
#line 533
  return;
}
}
#line 540 "cipher.c"
void cipher_set_key_string(CipherContext *cc , Cipher *cipher , char const   *passphrase ) 
{ MD5_CTX md ;
  u_char digest___1[16] ;
  size_t tmp ;

  {
#line 547
  MD5_Init(& md);
#line 548
  tmp = strlen(passphrase);
#line 548
  MD5_Update(& md, (void const   *)((u_char const   *)passphrase), tmp);
#line 549
  MD5_Final(digest___1, & md);
#line 551
  cipher_init(cc, cipher, (u_char const   *)(digest___1), 16U, (u_char const   *)((void *)0),
              0U);
#line 553
  memset((void *)(digest___1), 0, sizeof(digest___1));
#line 554
  memset((void *)(& md), 0, sizeof(md));
#line 555
  return;
}
}
#line 1 "cli.o"
#pragma merger(0,"./cli.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 71 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
#line 117 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 216
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
#line 222
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo )  __attribute__((__nonnull__(1))) ;
#line 249
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
#line 257
extern int sigsuspend(sigset_t const   *__set )  __attribute__((__nonnull__(1))) ;
#line 260
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 143 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 218
extern int fflush(FILE *__stream ) ;
#line 12 "cli.h"
char *cli_read_passphrase(char const   *prompt , int from_stdin , int echo_enable ) ;
#line 14
char *cli_prompt(char *prompt , int echo_enable ) ;
#line 15
void cli_mesg(char *mesg ) ;
#line 8 "cli.c"
static int cli_input  =    -1;
#line 9 "cli.c"
static int cli_output  =    -1;
#line 10 "cli.c"
static int cli_from_stdin  =    0;
#line 12 "cli.c"
sigset_t oset  ;
#line 13 "cli.c"
sigset_t nset  ;
#line 14 "cli.c"
struct sigaction nsa  ;
#line 15 "cli.c"
struct sigaction osa  ;
#line 16 "cli.c"
struct termios ntio  ;
#line 17 "cli.c"
struct termios otio  ;
#line 18 "cli.c"
int echo_modified  ;
#line 20 "cli.c"
int volatile   intr  ;
#line 22 "cli.c"
static int cli_open(int from_stdin ) 
{ int tmp ;

  {
#line 25
  if (cli_input >= 0) {
#line 25
    if (cli_output >= 0) {
#line 25
      if (cli_from_stdin == from_stdin) {
#line 26
        return (1);
      }
    }
  }
#line 28
  if (from_stdin) {
#line 29
    if (! cli_from_stdin) {
#line 29
      if (cli_input >= 0) {
#line 30
        close(cli_input);
      }
    }
#line 32
    cli_input = 0;
#line 33
    cli_output = 2;
  } else {
#line 35
    cli_output = open("/dev/tty", 2);
#line 35
    cli_input = cli_output;
#line 36
    if (cli_input < 0) {
#line 37
      fatal("You have no controlling tty.  Cannot read passphrase.");
    }
  }
#line 40
  cli_from_stdin = from_stdin;
#line 42
  if (cli_input >= 0) {
#line 42
    if (cli_output >= 0) {
#line 42
      if (cli_from_stdin == from_stdin) {
#line 42
        tmp = 1;
      } else {
#line 42
        tmp = 0;
      }
    } else {
#line 42
      tmp = 0;
    }
  } else {
#line 42
    tmp = 0;
  }
#line 42
  return (tmp);
}
}
#line 45 "cli.c"
static void cli_close(void) 
{ 

  {
#line 48
  if (! cli_from_stdin) {
#line 48
    if (cli_input >= 0) {
#line 49
      close(cli_input);
    }
  }
#line 50
  cli_input = -1;
#line 51
  cli_output = -1;
#line 52
  cli_from_stdin = 0;
#line 53
  return;
}
}
#line 56 "cli.c"
void intrcatch(int sig ) 
{ 

  {
#line 59
  intr = (int volatile   )1;
#line 60
  return;
}
}
#line 62 "cli.c"
static void cli_echo_disable(void) 
{ int tmp ;

  {
#line 65
  sigemptyset(& nset);
#line 66
  sigaddset(& nset, 20);
#line 67
  sigprocmask(0, (sigset_t const   * __restrict  )(& nset), (sigset_t * __restrict  )(& oset));
#line 69
  intr = (int volatile   )0;
#line 71
  memset((void *)(& nsa), 0, sizeof(nsa));
#line 72
  nsa.__sigaction_handler.sa_handler = & intrcatch;
#line 73
  sigaction(2, (struct sigaction  const  * __restrict  )(& nsa), (struct sigaction * __restrict  )(& osa));
#line 75
  echo_modified = 0;
#line 76
  tmp = tcgetattr(cli_input, & otio);
#line 76
  if (tmp == 0) {
#line 76
    if (otio.c_lflag & 8U) {
#line 77
      echo_modified = 1;
#line 78
      ntio = otio;
#line 79
      ntio.c_lflag &= 4294967175U;
#line 80
      tcsetattr(cli_input, 0, (struct termios  const  *)(& ntio));
    }
  }
#line 82
  return;
}
}
#line 85 "cli.c"
static void cli_echo_restore(void) 
{ __pid_t tmp ;

  {
#line 88
  if (echo_modified != 0) {
#line 89
    tcsetattr(cli_input, 0, (struct termios  const  *)(& otio));
#line 90
    echo_modified = 0;
  }
#line 93
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((void *)0));
#line 94
  sigaction(2, (struct sigaction  const  * __restrict  )(& osa), (struct sigaction * __restrict  )((void *)0));
#line 96
  if (intr != (int volatile   )0) {
#line 97
    tmp = getpid();
#line 97
    kill(tmp, 2);
#line 98
    sigemptyset(& nset);
#line 100
    sigsuspend((sigset_t const   *)(& nset));
#line 101
    intr = (int volatile   )0;
  }
#line 103
  return;
}
}
#line 106 "cli.c"
static int cli_read(char *buf___2 , int size , int echo ) 
{ char ch ;
  int i ;
  ssize_t tmp ;
  int tmp___0 ;

  {
#line 109
  ch = (char)0;
#line 110
  i = 0;
#line 112
  if (! echo) {
#line 113
    cli_echo_disable();
  }
#line 115
  while ((int )ch != 10) {
#line 116
    tmp = read(cli_input, (void *)(& ch), 1U);
#line 116
    if (tmp != 1) {
#line 117
      break;
    }
#line 118
    if ((int )ch == 10) {
#line 119
      break;
    } else {
#line 118
      if (intr != (int volatile   )0) {
#line 119
        break;
      }
    }
#line 120
    if (i < size) {
#line 121
      tmp___0 = i;
#line 121
      i ++;
#line 121
      *(buf___2 + tmp___0) = ch;
    }
  }
#line 123
  *(buf___2 + i) = (char )'\000';
#line 125
  if (! echo) {
#line 126
    cli_echo_restore();
  }
#line 127
  if (! intr) {
#line 127
    if (! echo) {
#line 128
      write(cli_output, (void const   *)"\n", 1U);
    }
  }
#line 129
  return (i);
}
}
#line 132 "cli.c"
static int cli_write(char const   *buf___2 , int size ) 
{ int i ;
  int len ;
  int pos ;
  int ret ;
  char *output___0 ;
  char *p ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 135
  ret = 0;
#line 138
  tmp = xmalloc((unsigned int )(4 * size));
#line 138
  output___0 = (char *)tmp;
#line 139
  p = output___0;
#line 139
  i = 0;
#line 139
  while (i < size) {
#line 140
    if ((int const   )*(buf___2 + i) == 10) {
#line 141
      tmp___0 = p;
#line 141
      p ++;
#line 141
      *tmp___0 = (char )*(buf___2 + i);
    } else {
#line 140
      if ((int const   )*(buf___2 + i) == 13) {
#line 141
        tmp___0 = p;
#line 141
        p ++;
#line 141
        *tmp___0 = (char )*(buf___2 + i);
      } else {
#line 143
        p = vis(p, (int )*(buf___2 + i), 0, 0);
      }
    }
#line 139
    i ++;
  }
#line 145
  len = p - output___0;
#line 147
  pos = 0;
#line 147
  while (pos < len) {
#line 148
    ret = write(cli_output, (void const   *)(output___0 + pos), (unsigned int )(len - pos));
#line 149
    if (ret == -1) {
#line 150
      xfree((void *)output___0);
#line 151
      return (-1);
    }
#line 147
    pos += ret;
  }
#line 154
  xfree((void *)output___0);
#line 155
  return (0);
}
}
#line 164 "cli.c"
char *cli_read_passphrase(char const   *prompt , int from_stdin , int echo_enable ) 
{ char buf___2[8192] ;
  char *p ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 170
  tmp = cli_open(from_stdin);
#line 170
  if (! tmp) {
#line 171
    fatal("Cannot read passphrase.");
  }
#line 173
  fflush(stdout);
#line 175
  tmp___0 = strlen(prompt);
#line 175
  cli_write(prompt, (int )tmp___0);
#line 176
  cli_read(buf___2, (int )sizeof(buf___2), echo_enable);
#line 178
  cli_close();
#line 180
  p = xstrdup((char const   *)(buf___2));
#line 181
  memset((void *)(buf___2), 0, sizeof(buf___2));
#line 182
  return (p);
}
}
#line 185 "cli.c"
char *cli_prompt(char *prompt , int echo_enable ) 
{ char *tmp ;

  {
#line 188
  tmp = cli_read_passphrase((char const   *)prompt, 0, echo_enable);
#line 188
  return (tmp);
}
}
#line 191 "cli.c"
void cli_mesg(char *mesg ) 
{ size_t tmp ;
  size_t tmp___0 ;

  {
#line 194
  cli_open(0);
#line 195
  tmp = strlen((char const   *)mesg);
#line 195
  cli_write((char const   *)mesg, (int )tmp);
#line 196
  tmp___0 = strlen("\n");
#line 196
  cli_write("\n", (int )tmp___0);
#line 197
  cli_close();
#line 198
  return;
}
}
#line 1 "compat.o"
#pragma merger(0,"./compat.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 537 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 541
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 546
extern size_t regerror(int __errcode , regex_t const   * __restrict  __preg , char * __restrict  __errbuf ,
                       size_t __errbuf_size ) ;
#line 549
extern void regfree(regex_t *__preg ) ;
#line 44 "compat.h"
void enable_compat13(void) ;
#line 45
void enable_compat20(void) ;
#line 46
void compat_datafellows(char const   *version ) ;
#line 47
int proto_spec(char const   *spec ) ;
#line 43 "compat.c"
int compat13  =    0;
#line 44 "compat.c"
int compat20  =    0;
#line 45 "compat.c"
int datafellows  =    0;
#line 47 "compat.c"
void enable_compat20(void) 
{ 

  {
#line 50
  verbose("Enabling compatibility mode for protocol 2.0");
#line 51
  compat20 = 1;
#line 52
  return;
}
}
#line 53 "compat.c"
void enable_compat13(void) 
{ 

  {
#line 56
  verbose("Enabling compatibility mode for protocol 1.3");
#line 57
  compat13 = 1;
#line 58
  return;
}
}
#line 66 "compat.c"
static struct __anonstruct_check_67 check[15]  = 
#line 66
  {      {(char *)"^OpenSSH[-_]2\\.[012]", 144}, 
        {(char *)"^OpenSSH_2\\.3\\.0", 128}, 
        {(char *)"^OpenSSH", 0}, 
        {(char *)"MindTerm", 0}, 
        {(char *)"^2\\.1\\.0", 85}, 
        {(char *)"^2\\.0\\.1[3-9]", 95}, 
        {(char *)"^2\\.0\\.", 127}, 
        {(char *)"^2\\.[23]\\.0", 4}, 
        {(char *)"^2\\.[2-9]\\.", 0}, 
        {(char *)"^2\\.4$", 16}, 
        {(char *)"^3\\.0 SecureCRT", 16}, 
        {(char *)"^1\\.7 SecureFX", 16}, 
        {(char *)"^1\\.2\\.1[89]", 256}, 
        {(char *)"^1\\.2\\.2[012]", 256}, 
        {(char *)((void *)0), 0}};
#line 60 "compat.c"
void compat_datafellows(char const   *version ) 
{ int i ;
  int ret ;
  char ebuf[1024] ;
  regex_t reg ;

  {
#line 94
  i = 0;
#line 94
  while (check[i].pat) {
#line 95
    ret = regcomp((regex_t * __restrict  )(& reg), (char const   * __restrict  )check[i].pat,
                  1 | (((1 << 1) << 1) << 1));
#line 96
    if (ret != 0) {
#line 97
      regerror(ret, (regex_t const   * __restrict  )(& reg), (char * __restrict  )(ebuf),
               sizeof(ebuf));
#line 98
      ebuf[sizeof(ebuf) - 1U] = (char )'\000';
#line 99
      error("regerror: %s", ebuf);
      goto __Cont;
    }
#line 102
    ret = regexec((regex_t const   * __restrict  )(& reg), (char const   * __restrict  )version,
                  0U, (regmatch_t * __restrict  )((void *)0), 0);
#line 103
    regfree(& reg);
#line 104
    if (ret == 0) {
#line 105
      debug("match: %s pat %s", version, check[i].pat);
#line 106
      datafellows = check[i].bugs;
#line 107
      return;
    }
    __Cont: /* CIL Label */ 
#line 94
    i ++;
  }
#line 110
  debug("no match: %s", version);
#line 111
  return;
}
}
#line 114 "compat.c"
int proto_spec(char const   *spec ) 
{ char *s ;
  char *p ;
  char *q ;
  int ret ;
  char *tmp___14 ;
  char *tmp___30 ;
  int tmp___31 ;

  {
#line 118
  ret = 0;
#line 120
  if ((unsigned int )spec == (unsigned int )((void *)0)) {
#line 121
    return (ret);
  }
#line 122
  s = xstrdup(spec);
#line 122
  q = s;
#line 123
  tmp___14 = __strsep_g(& q, ",");
#line 123
  p = tmp___14;
#line 123
  while (1) {
#line 123
    if (p) {
#line 123
      if (! ((int )*p != 0)) {
#line 123
        break;
      }
    } else {
#line 123
      break;
    }
#line 124
    tmp___31 = atoi((char const   *)p);
#line 124
    switch (tmp___31) {
    case 1: 
#line 126
    if (ret == 0) {
#line 127
      ret |= 2;
    }
#line 128
    ret |= 1;
#line 129
    break;
    case 2: 
#line 131
    ret |= 4;
#line 132
    break;
    default: 
#line 134
    log("ignoring bad proto spec: \'%s\'.", p);
#line 135
    break;
    }
#line 123
    tmp___30 = __strsep_g(& q, ",");
#line 123
    p = tmp___30;
  }
#line 138
  xfree((void *)s);
#line 139
  return (ret);
}
}
#line 1 "compress.o"
#pragma merger(0,"./compress.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 242 "/usr/include/zlib.h"
extern int deflate(z_streamp strm , int flush ) ;
#line 328
extern int deflateEnd(z_streamp strm ) ;
#line 363
extern int inflate(z_streamp strm , int flush ) ;
#line 462
extern int inflateEnd(z_streamp strm ) ;
#line 1317
extern int deflateInit_(z_streamp strm , int level , char const   *version , int stream_size ) ;
#line 1319
extern int inflateInit_(z_streamp strm , char const   *version , int stream_size ) ;
#line 23 "compress.h"
void buffer_compress_init(int level ) ;
#line 26
void buffer_compress_uninit(void) ;
#line 36
void buffer_compress(Buffer *input_buffer , Buffer *output_buffer ) ;
#line 46
void buffer_uncompress(Buffer *input_buffer , Buffer *output_buffer ) ;
#line 22 "compress.c"
static z_stream incoming_stream  ;
#line 23 "compress.c"
static z_stream outgoing_stream  ;
#line 30 "compress.c"
void buffer_compress_init(int level ) 
{ 

  {
#line 33
  debug("Enabling compression at level %d.", level);
#line 34
  if (level < 1) {
#line 35
    fatal("Bad compression level %d.", level);
  } else {
#line 34
    if (level > 9) {
#line 35
      fatal("Bad compression level %d.", level);
    }
  }
#line 36
  inflateInit_(& incoming_stream, "1.2.3", (int )sizeof(z_stream ));
#line 37
  deflateInit_(& outgoing_stream, level, "1.2.3", (int )sizeof(z_stream ));
#line 38
  return;
}
}
#line 42 "compress.c"
void buffer_compress_uninit(void) 
{ double tmp ;
  double tmp___0 ;

  {
#line 45
  if (outgoing_stream.total_in == 0UL) {
#line 45
    tmp = 0.0;
  } else {
#line 45
    tmp = (double )outgoing_stream.total_out / (double )outgoing_stream.total_in;
  }
#line 45
  debug("compress outgoing: raw data %lu, compressed %lu, factor %.2f", outgoing_stream.total_in,
        outgoing_stream.total_out, tmp);
#line 49
  if (incoming_stream.total_out == 0UL) {
#line 49
    tmp___0 = 0.0;
  } else {
#line 49
    tmp___0 = (double )incoming_stream.total_in / (double )incoming_stream.total_out;
  }
#line 49
  debug("compress incoming: raw data %lu, compressed %lu, factor %.2f", incoming_stream.total_out,
        incoming_stream.total_in, tmp___0);
#line 53
  inflateEnd(& incoming_stream);
#line 54
  deflateEnd(& outgoing_stream);
#line 55
  return;
}
}
#line 66 "compress.c"
void buffer_compress(Buffer *input_buffer , Buffer *output_buffer ) 
{ char buf___2[4096] ;
  int status ;
  u_int tmp ;
  char *tmp___0 ;

  {
#line 73
  tmp = buffer_len(input_buffer);
#line 73
  if (tmp == 0U) {
#line 74
    return;
  }
#line 77
  tmp___0 = buffer_ptr(input_buffer);
#line 77
  outgoing_stream.next_in = (u_char *)tmp___0;
#line 78
  outgoing_stream.avail_in = buffer_len(input_buffer);
#line 81
  while (1) {
#line 83
    outgoing_stream.next_out = (u_char *)(buf___2);
#line 84
    outgoing_stream.avail_out = sizeof(buf___2);
#line 87
    status = deflate(& outgoing_stream, 1);
#line 88
    switch (status) {
    case 0: 
#line 91
    buffer_append(output_buffer, (char const   *)(buf___2), sizeof(buf___2) - outgoing_stream.avail_out);
#line 93
    break;
    default: 
#line 95
    fatal("buffer_compress: deflate returned %d", status);
    }
#line 81
    if (! (outgoing_stream.avail_out == 0U)) {
#line 81
      break;
    }
  }
#line 99
  return;
}
}
#line 110 "compress.c"
void buffer_uncompress(Buffer *input_buffer , Buffer *output_buffer ) 
{ char buf___2[4096] ;
  int status ;
  char *tmp ;

  {
#line 116
  tmp = buffer_ptr(input_buffer);
#line 116
  incoming_stream.next_in = (u_char *)tmp;
#line 117
  incoming_stream.avail_in = buffer_len(input_buffer);
#line 119
  while (1) {
#line 121
    incoming_stream.next_out = (u_char *)(buf___2);
#line 122
    incoming_stream.avail_out = sizeof(buf___2);
#line 124
    status = inflate(& incoming_stream, 1);
#line 125
    switch (status) {
    case 0: 
#line 127
    buffer_append(output_buffer, (char const   *)(buf___2), sizeof(buf___2) - incoming_stream.avail_out);
#line 129
    break;
    case -5: 
#line 136
    return;
    default: 
#line 138
    fatal("buffer_uncompress: inflate returned %d", status);
    }
  }
}
}
#line 1 "crc32.o"
#pragma merger(0,"./crc32.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 23 "crc32.h"
u_int ssh_crc32(u_char const   *s , u_int len ) ;
#line 46 "crc32.c"
static u_int crc32_tab[256]  = 
#line 46 "crc32.c"
  {      (u_int )0L,      (u_int )1996959894L,      (u_int )3993919788UL,      (u_int )2567524794UL, 
        (u_int )124634137L,      (u_int )1886057615L,      (u_int )3915621685UL,      (u_int )2657392035UL, 
        (u_int )249268274L,      (u_int )2044508324L,      (u_int )3772115230UL,      (u_int )2547177864UL, 
        (u_int )162941995L,      (u_int )2125561021L,      (u_int )3887607047UL,      (u_int )2428444049UL, 
        (u_int )498536548L,      (u_int )1789927666L,      (u_int )4089016648UL,      (u_int )2227061214UL, 
        (u_int )450548861L,      (u_int )1843258603L,      (u_int )4107580753UL,      (u_int )2211677639UL, 
        (u_int )325883990L,      (u_int )1684777152L,      (u_int )4251122042UL,      (u_int )2321926636UL, 
        (u_int )335633487L,      (u_int )1661365465L,      (u_int )4195302755UL,      (u_int )2366115317UL, 
        (u_int )997073096L,      (u_int )1281953886L,      (u_int )3579855332UL,      (u_int )2724688242UL, 
        (u_int )1006888145L,      (u_int )1258607687L,      (u_int )3524101629UL,      (u_int )2768942443UL, 
        (u_int )901097722L,      (u_int )1119000684L,      (u_int )3686517206UL,      (u_int )2898065728UL, 
        (u_int )853044451L,      (u_int )1172266101L,      (u_int )3705015759UL,      (u_int )2882616665UL, 
        (u_int )651767980L,      (u_int )1373503546L,      (u_int )3369554304UL,      (u_int )3218104598UL, 
        (u_int )565507253L,      (u_int )1454621731L,      (u_int )3485111705UL,      (u_int )3099436303UL, 
        (u_int )671266974L,      (u_int )1594198024L,      (u_int )3322730930UL,      (u_int )2970347812UL, 
        (u_int )795835527L,      (u_int )1483230225L,      (u_int )3244367275UL,      (u_int )3060149565UL, 
        (u_int )1994146192L,      (u_int )31158534L,      (u_int )2563907772UL,      (u_int )4023717930UL, 
        (u_int )1907459465L,      (u_int )112637215L,      (u_int )2680153253UL,      (u_int )3904427059UL, 
        (u_int )2013776290L,      (u_int )251722036L,      (u_int )2517215374UL,      (u_int )3775830040UL, 
        (u_int )2137656763L,      (u_int )141376813L,      (u_int )2439277719UL,      (u_int )3865271297UL, 
        (u_int )1802195444L,      (u_int )476864866L,      (u_int )2238001368UL,      (u_int )4066508878UL, 
        (u_int )1812370925L,      (u_int )453092731L,      (u_int )2181625025UL,      (u_int )4111451223UL, 
        (u_int )1706088902L,      (u_int )314042704L,      (u_int )2344532202UL,      (u_int )4240017532UL, 
        (u_int )1658658271L,      (u_int )366619977L,      (u_int )2362670323UL,      (u_int )4224994405UL, 
        (u_int )1303535960L,      (u_int )984961486L,      (u_int )2747007092UL,      (u_int )3569037538UL, 
        (u_int )1256170817L,      (u_int )1037604311L,      (u_int )2765210733UL,      (u_int )3554079995UL, 
        (u_int )1131014506L,      (u_int )879679996L,      (u_int )2909243462UL,      (u_int )3663771856UL, 
        (u_int )1141124467L,      (u_int )855842277L,      (u_int )2852801631UL,      (u_int )3708648649UL, 
        (u_int )1342533948L,      (u_int )654459306L,      (u_int )3188396048UL,      (u_int )3373015174UL, 
        (u_int )1466479909L,      (u_int )544179635L,      (u_int )3110523913UL,      (u_int )3462522015UL, 
        (u_int )1591671054L,      (u_int )702138776L,      (u_int )2966460450UL,      (u_int )3352799412UL, 
        (u_int )1504918807L,      (u_int )783551873L,      (u_int )3082640443UL,      (u_int )3233442989UL, 
        (u_int )3988292384UL,      (u_int )2596254646UL,      (u_int )62317068L,      (u_int )1957810842L, 
        (u_int )3939845945UL,      (u_int )2647816111UL,      (u_int )81470997L,      (u_int )1943803523L, 
        (u_int )3814918930UL,      (u_int )2489596804UL,      (u_int )225274430L,      (u_int )2053790376L, 
        (u_int )3826175755UL,      (u_int )2466906013UL,      (u_int )167816743L,      (u_int )2097651377L, 
        (u_int )4027552580UL,      (u_int )2265490386UL,      (u_int )503444072L,      (u_int )1762050814L, 
        (u_int )4150417245UL,      (u_int )2154129355UL,      (u_int )426522225L,      (u_int )1852507879L, 
        (u_int )4275313526UL,      (u_int )2312317920UL,      (u_int )282753626L,      (u_int )1742555852L, 
        (u_int )4189708143UL,      (u_int )2394877945UL,      (u_int )397917763L,      (u_int )1622183637L, 
        (u_int )3604390888UL,      (u_int )2714866558UL,      (u_int )953729732L,      (u_int )1340076626L, 
        (u_int )3518719985UL,      (u_int )2797360999UL,      (u_int )1068828381L,      (u_int )1219638859L, 
        (u_int )3624741850UL,      (u_int )2936675148UL,      (u_int )906185462L,      (u_int )1090812512L, 
        (u_int )3747672003UL,      (u_int )2825379669UL,      (u_int )829329135L,      (u_int )1181335161L, 
        (u_int )3412177804UL,      (u_int )3160834842UL,      (u_int )628085408L,      (u_int )1382605366L, 
        (u_int )3423369109UL,      (u_int )3138078467UL,      (u_int )570562233L,      (u_int )1426400815L, 
        (u_int )3317316542UL,      (u_int )2998733608UL,      (u_int )733239954L,      (u_int )1555261956L, 
        (u_int )3268935591UL,      (u_int )3050360625UL,      (u_int )752459403L,      (u_int )1541320221L, 
        (u_int )2607071920UL,      (u_int )3965973030UL,      (u_int )1969922972L,      (u_int )40735498L, 
        (u_int )2617837225UL,      (u_int )3943577151UL,      (u_int )1913087877L,      (u_int )83908371L, 
        (u_int )2512341634UL,      (u_int )3803740692UL,      (u_int )2075208622L,      (u_int )213261112L, 
        (u_int )2463272603UL,      (u_int )3855990285UL,      (u_int )2094854071L,      (u_int )198958881L, 
        (u_int )2262029012UL,      (u_int )4057260610UL,      (u_int )1759359992L,      (u_int )534414190L, 
        (u_int )2176718541UL,      (u_int )4139329115UL,      (u_int )1873836001L,      (u_int )414664567L, 
        (u_int )2282248934UL,      (u_int )4279200368UL,      (u_int )1711684554L,      (u_int )285281116L, 
        (u_int )2405801727UL,      (u_int )4167216745UL,      (u_int )1634467795L,      (u_int )376229701L, 
        (u_int )2685067896UL,      (u_int )3608007406UL,      (u_int )1308918612L,      (u_int )956543938L, 
        (u_int )2808555105UL,      (u_int )3495958263UL,      (u_int )1231636301L,      (u_int )1047427035L, 
        (u_int )2932959818UL,      (u_int )3654703836UL,      (u_int )1088359270L,      (u_int )936918000L, 
        (u_int )2847714899UL,      (u_int )3736837829UL,      (u_int )1202900863L,      (u_int )817233897L, 
        (u_int )3183342108UL,      (u_int )3401237130UL,      (u_int )1404277552L,      (u_int )615818150L, 
        (u_int )3134207493UL,      (u_int )3453421203UL,      (u_int )1423857449L,      (u_int )601450431L, 
        (u_int )3009837614UL,      (u_int )3294710456UL,      (u_int )1567103746L,      (u_int )711928724L, 
        (u_int )3020668471UL,      (u_int )3272380065UL,      (u_int )1510334235L,      (u_int )755167117L};
#line 103 "crc32.c"
u_int ssh_crc32(u_char const   *s , u_int len ) 
{ u_int i ;
  u_int crc32val ;

  {
#line 109
  crc32val = 0U;
#line 110
  i = 0U;
#line 110
  while (i < len) {
#line 111
    crc32val = crc32_tab[(crc32val ^ (unsigned int )*(s + i)) & 255U] ^ (crc32val >> 8);
#line 110
    i ++;
  }
#line 113
  return (crc32val);
}
}
#line 1 "deattack.o"
#pragma merger(0,"./deattack.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 29 "deattack.h"
int detect_attack(u_char *buf___2 , u_int32_t len , u_char *IV ) ;
#line 50 "deattack.c"
void crc_update(u_int32_t *a , u_int32_t b ) 
{ 

  {
#line 53
  b ^= *a;
#line 54
  *a = ssh_crc32((u_char const   *)((u_char *)(& b)), sizeof(b));
#line 55
  return;
}
}
#line 58 "deattack.c"
int check_crc(u_char *S , u_char *buf___2 , u_int32_t len , u_char *IV ) 
{ u_int32_t crc ;
  u_char *c ;
  int tmp ;
  int tmp___0 ;

  {
#line 65
  crc = 0U;
#line 66
  if (IV) {
#line 66
    tmp = memcmp((void const   *)S, (void const   *)IV, 8U);
#line 66
    if (! tmp) {
#line 67
      crc_update(& crc, 1U);
#line 68
      crc_update(& crc, 0U);
    }
  }
#line 70
  c = buf___2;
#line 70
  while ((unsigned int )c < (unsigned int )(buf___2 + len)) {
#line 71
    tmp___0 = memcmp((void const   *)S, (void const   *)c, 8U);
#line 71
    if (tmp___0) {
#line 75
      crc_update(& crc, 0U);
#line 76
      crc_update(& crc, 0U);
    } else {
#line 72
      crc_update(& crc, 1U);
#line 73
      crc_update(& crc, 0U);
    }
#line 70
    c += 8;
  }
#line 79
  return (crc == 0U);
}
}
#line 87 "deattack.c"
static u_int16_t *h  =    (u_int16_t *)((void *)0);
#line 88 "deattack.c"
static u_int32_t n  =    (u_int32_t )4096;
#line 84 "deattack.c"
int detect_attack(u_char *buf___2 , u_int32_t len , u_char *IV ) 
{ register u_int32_t i ;
  register u_int32_t j ;
  u_int32_t l ;
  register u_char *c ;
  u_char *d ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 94
  if (len > 262144U) {
#line 96
    fatal("detect_attack: bad length %d", len);
  } else {
#line 94
    if (len % 8U != 0U) {
#line 96
      fatal("detect_attack: bad length %d", len);
    }
  }
#line 98
  l = n;
#line 98
  while (l < ((len / 8U) * 3U) / 2U) {
#line 98
    l <<= 2;
  }
#line 101
  if ((unsigned int )h == (unsigned int )((void *)0)) {
#line 102
    debug("Installing crc compensation attack detector.");
#line 103
    n = l;
#line 104
    tmp = xmalloc(n * 2U);
#line 104
    h = (u_int16_t *)tmp;
  } else {
#line 106
    if (l > n) {
#line 107
      n = l;
#line 108
      tmp___0 = xrealloc((void *)h, n * 2U);
#line 108
      h = (u_int16_t *)tmp___0;
    }
  }
#line 112
  if (len <= 56U) {
#line 113
    c = buf___2;
#line 113
    while ((unsigned int )c < (unsigned int )(buf___2 + len)) {
#line 114
      if (IV) {
#line 114
        tmp___2 = memcmp((void const   *)c, (void const   *)IV, 8U);
#line 114
        if (! tmp___2) {
#line 115
          tmp___1 = check_crc(c, buf___2, len, (u_char *)IV);
#line 115
          if (tmp___1) {
#line 116
            return (1);
          } else {
#line 118
            break;
          }
        }
      }
#line 120
      d = buf___2;
#line 120
      while ((unsigned int )d < (unsigned int )c) {
#line 121
        tmp___4 = memcmp((void const   *)c, (void const   *)d, 8U);
#line 121
        if (! tmp___4) {
#line 122
          tmp___3 = check_crc(c, buf___2, len, (u_char *)IV);
#line 122
          if (tmp___3) {
#line 123
            return (1);
          } else {
#line 125
            break;
          }
        }
#line 120
        d += 8;
      }
#line 113
      c += 8;
    }
#line 129
    return (0);
  }
#line 131
  memset((void *)h, 255, n * 2U);
#line 133
  if (IV) {
#line 134
    *(h + ((((((unsigned long )*(IV + 0) << 24) | ((unsigned long )*(IV + 1) << 16)) | ((unsigned long )*(IV + 2) << 8)) | (unsigned long )*(IV + 3)) & (unsigned long )(n - 1U))) = (unsigned short)65534;
  }
#line 136
  c = buf___2;
#line 136
  j = 0U;
#line 136
  while ((unsigned int )c < (unsigned int )(buf___2 + len)) {
#line 137
    i = (unsigned int )((((((unsigned long )*(c + 0) << 24) | ((unsigned long )*(c + 1) << 16)) | ((unsigned long )*(c + 2) << 8)) | (unsigned long )*(c + 3)) & (unsigned long )(n - 1U));
#line 137
    while ((int )*(h + i) != 65535) {
#line 139
      if ((int )*(h + i) == 65534) {
#line 140
        tmp___6 = memcmp((void const   *)c, (void const   *)IV, 8U);
#line 140
        if (! tmp___6) {
#line 141
          tmp___5 = check_crc(c, buf___2, len, (u_char *)IV);
#line 141
          if (tmp___5) {
#line 142
            return (1);
          } else {
#line 144
            break;
          }
        }
      } else {
#line 146
        tmp___8 = memcmp((void const   *)c, (void const   *)(buf___2 + (int )*(h + i) * 8),
                         8U);
#line 146
        if (! tmp___8) {
#line 147
          tmp___7 = check_crc(c, buf___2, len, (u_char *)IV);
#line 147
          if (tmp___7) {
#line 148
            return (1);
          } else {
#line 150
            break;
          }
        }
      }
#line 137
      i = (i + 1U) & (n - 1U);
    }
#line 153
    *(h + i) = (unsigned short )j;
#line 136
    c += 8;
#line 136
    j ++;
  }
#line 155
  return (0);
}
}
#line 1 "dispatch.o"
#pragma merger(0,"./dispatch.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 33 "dispatch.h"
void dispatch_init(dispatch_fn *dflt ) ;
#line 34
void dispatch_set(int type , dispatch_fn *fn ) ;
#line 35
void dispatch_run(int mode , int *done , void *ctxt ) ;
#line 36
void dispatch_protocol_error(int type , int plen , void *ctxt ) ;
#line 114 "packet.h"
int packet_read_poll(int *payload_len_ptr ) ;
#line 37 "dispatch.c"
dispatch_fn *dispatch[255]  ;
#line 39 "dispatch.c"
void dispatch_protocol_error(int type , int plen , void *ctxt ) 
{ 

  {
#line 42
  error("Hm, dispatch protocol error: type %d plen %d", type, plen);
#line 43
  if (compat20) {
#line 43
    if (type == 20) {
#line 44
      fatal("dispatch_protocol_error: rekeying is not supported");
    }
  }
#line 45
  return;
}
}
#line 46 "dispatch.c"
void dispatch_init(dispatch_fn *dflt ) 
{ int i ;

  {
#line 50
  i = 0;
#line 50
  while (i < 255) {
#line 51
    dispatch[i] = dflt;
#line 50
    i ++;
  }
#line 52
  return;
}
}
#line 53 "dispatch.c"
void dispatch_set(int type , dispatch_fn *fn ) 
{ 

  {
#line 56
  dispatch[type] = fn;
#line 57
  return;
}
}
#line 58 "dispatch.c"
void dispatch_run(int mode , int *done , void *ctxt ) 
{ int plen ;
  int type ;

  {
#line 61
  while (1) {
#line 65
    if (mode == 0) {
#line 66
      type = packet_read(& plen);
    } else {
#line 68
      type = packet_read_poll(& plen);
#line 69
      if (type == 0) {
#line 70
        return;
      }
    }
#line 72
    if (type > 0) {
#line 72
      if (type < 255) {
#line 72
        if ((unsigned int )dispatch[type] != (unsigned int )((void *)0)) {
#line 73
          (*(dispatch[type]))(type, plen, ctxt);
        } else {
#line 75
          packet_disconnect("protocol error: rcvd type %d", type);
        }
      } else {
#line 75
        packet_disconnect("protocol error: rcvd type %d", type);
      }
    } else {
#line 75
      packet_disconnect("protocol error: rcvd type %d", type);
    }
#line 76
    if ((unsigned int )done != (unsigned int )((void *)0)) {
#line 76
      if (*done) {
#line 77
        return;
      }
    }
  }
}
}
#line 1 "mac.o"
#pragma merger(0,"./mac.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 593 "/usr/include/openssl/evp.h"
extern EVP_MD const   *EVP_md5(void) ;
#line 597
extern EVP_MD const   *EVP_sha1(void) ;
#line 611
extern EVP_MD const   *EVP_ripemd160(void) ;
#line 89 "/usr/include/openssl/hmac.h"
extern void HMAC_CTX_cleanup(HMAC_CTX *ctx ) ;
#line 93
extern void HMAC_Init(HMAC_CTX *ctx , void const   *key , int len , EVP_MD const   *md ) ;
#line 97
extern void HMAC_Update(HMAC_CTX *ctx , unsigned char const   *data , size_t len ) ;
#line 98
extern void HMAC_Final(HMAC_CTX *ctx , unsigned char *md , unsigned int *len ) ;
#line 26 "mac.h"
int mac_valid(char const   *names ) ;
#line 27
int mac_init(Mac *mac , char *name ) ;
#line 28
u_char *mac_compute(Mac *mac , u_int32_t seqno , u_char *data , int datalen ) ;
#line 37 "mac.c"
struct __anonstruct_macs_77 macs[7]  = {      {(char *)"hmac-sha1", (EVP_MD *(*)(void))(& EVP_sha1), 0}, 
        {(char *)"hmac-sha1-96", (EVP_MD *(*)(void))(& EVP_sha1), 96}, 
        {(char *)"hmac-md5", (EVP_MD *(*)(void))(& EVP_md5), 0}, 
        {(char *)"hmac-md5-96", (EVP_MD *(*)(void))(& EVP_md5), 96}, 
        {(char *)"hmac-ripemd160", (EVP_MD *(*)(void))(& EVP_ripemd160), 0}, 
        {(char *)"hmac-ripemd160@openssh.com", (EVP_MD *(*)(void))(& EVP_ripemd160),
      0}, 
        {(char *)((void *)0), (EVP_MD *(*)(void))((void *)0), 0}};
#line 51 "mac.c"
int mac_init(Mac *mac , char *name ) 
{ int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 55
  i = 0;
#line 55
  while (macs[i].name) {
#line 56
    if (0) {
#line 56
      __s1_len = strlen((char const   *)name);
#line 56
      __s2_len = strlen((char const   *)macs[i].name);
#line 56
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___0;
      } else {
#line 56
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 56
          if (! ((unsigned int )((void const   *)(macs[i].name + 1)) - (unsigned int )((void const   *)macs[i].name) == 1U)) {
#line 56
            tmp___8 = 1;
          } else {
#line 56
            if (__s2_len >= 4U) {
#line 56
              tmp___8 = 1;
            } else {
#line 56
              tmp___8 = 0;
            }
          }
        } else {
#line 56
          tmp___8 = 0;
        }
      }
#line 56
      if (tmp___8) {
#line 56
        tmp___4 = __builtin_strcmp((char const   *)name, (char const   *)macs[i].name);
      } else {
#line 56
        tmp___7 = __builtin_strcmp((char const   *)name, (char const   *)macs[i].name);
#line 56
        tmp___4 = tmp___7;
      }
    } else {
#line 56
      tmp___7 = __builtin_strcmp((char const   *)name, (char const   *)macs[i].name);
#line 56
      tmp___4 = tmp___7;
    }
#line 56
    if (tmp___4 == 0) {
#line 57
      if ((unsigned int )mac != (unsigned int )((void *)0)) {
#line 58
        mac->md = (*(macs[i].mdfunc))();
#line 59
        mac->mac_len = (mac->md)->md_size;
#line 59
        mac->key_len = mac->mac_len;
#line 60
        if (macs[i].truncatebits != 0) {
#line 61
          mac->mac_len = macs[i].truncatebits / 8;
        }
      }
#line 63
      debug2("mac_init: found %s", name);
#line 64
      return (0);
    }
#line 55
    i ++;
  }
#line 67
  debug2("mac_init: unknown %s", name);
#line 68
  return (-1);
}
}
#line 75 "mac.c"
static u_char m[64]  ;
#line 71 "mac.c"
u_char *mac_compute(Mac *mac , u_int32_t seqno , u_char *data , int datalen ) 
{ HMAC_CTX c ;
  u_char b[4] ;

  {
#line 78
  if ((unsigned int )mac->key == (unsigned int )((void *)0)) {
#line 79
    fatal("mac_compute: no key");
  }
#line 80
  if ((unsigned int )mac->mac_len > sizeof(m)) {
#line 81
    fatal("mac_compute: mac too long");
  }
#line 82
  HMAC_Init(& c, (void const   *)mac->key, mac->key_len, (EVP_MD const   *)mac->md);
#line 83
  while (1) {
#line 83
    b[0] = (unsigned char )(seqno >> 24);
#line 83
    b[1] = (unsigned char )(seqno >> 16);
#line 83
    b[2] = (unsigned char )(seqno >> 8);
#line 83
    b[3] = (unsigned char )seqno;
#line 83
    break;
  }
#line 84
  HMAC_Update(& c, (unsigned char const   *)(b), sizeof(b));
#line 85
  HMAC_Update(& c, (unsigned char const   *)data, (unsigned int )datalen);
#line 86
  HMAC_Final(& c, m, (unsigned int *)((void *)0));
#line 87
  HMAC_CTX_cleanup(& c);
#line 88
  return (m);
}
}
#line 93 "mac.c"
int mac_valid(char const   *names ) 
{ char *maclist ;
  char *cp ;
  char *p ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___24 ;
  char *tmp___40 ;
  int tmp___41 ;

  {
#line 98
  if ((unsigned int )names == (unsigned int )((void *)0)) {
#line 99
    return (0);
  } else {
#line 98
    if (0) {
#line 98
      __s1_len = strlen(names);
#line 98
      __s2_len = strlen("");
#line 98
      if (! ((unsigned int )((void const   *)(names + 1)) - (unsigned int )((void const   *)names) == 1U)) {
        goto _L___0;
      } else {
#line 98
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 98
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 98
            tmp___8 = 1;
          } else {
#line 98
            if (__s2_len >= 4U) {
#line 98
              tmp___8 = 1;
            } else {
#line 98
              tmp___8 = 0;
            }
          }
        } else {
#line 98
          tmp___8 = 0;
        }
      }
#line 98
      if (tmp___8) {
#line 98
        tmp___4 = __builtin_strcmp(names, "");
      } else {
#line 98
        tmp___7 = __builtin_strcmp(names, "");
#line 98
        tmp___4 = tmp___7;
      }
    } else {
#line 98
      tmp___7 = __builtin_strcmp(names, "");
#line 98
      tmp___4 = tmp___7;
    }
#line 98
    if (tmp___4 == 0) {
#line 99
      return (0);
    }
  }
#line 100
  cp = xstrdup(names);
#line 100
  maclist = cp;
#line 101
  tmp___24 = __strsep_g(& cp, ",");
#line 101
  p = tmp___24;
#line 101
  while (1) {
#line 101
    if (p) {
#line 101
      if (! ((int )*p != 0)) {
#line 101
        break;
      }
    } else {
#line 101
      break;
    }
#line 103
    tmp___41 = mac_init((Mac *)((void *)0), p);
#line 103
    if (tmp___41 < 0) {
#line 104
      debug("bad mac %s [%s]", p, names);
#line 105
      xfree((void *)maclist);
#line 106
      return (0);
    } else {
#line 108
      debug3("mac ok: %s [%s]", p, names);
    }
#line 102
    tmp___40 = __strsep_g(& cp, ",");
#line 102
    p = tmp___40;
  }
#line 111
  debug3("macs ok: [%s]", names);
#line 112
  xfree((void *)maclist);
#line 113
  return (1);
}
}
#line 1 "hostfile.o"
#pragma merger(0,"./hostfile.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 410 "/usr/include/openssl/bn.h"
extern BIGNUM *BN_copy(BIGNUM *a , BIGNUM const   *b ) ;
#line 31 "match.h"
int match_hostname(char const   *host , char const   *pattern , u_int len ) ;
#line 47 "key.h"
void key_free(Key *k ) ;
#line 48
int key_equal(Key *a , Key *b ) ;
#line 51
int key_write(Key *key , FILE *f ) ;
#line 53
u_int key_size(Key *k ) ;
#line 17 "hostfile.h"
int auth_rsa_read_key(char **cpp , u_int *bitsp , BIGNUM *e , BIGNUM *n___0 ) ;
#line 30
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , Key *key ,
                                  Key *found , int *numret ) ;
#line 38
int add_host_to_hostfile(char const   *filename , char const   *host , Key *key ) ;
#line 52 "hostfile.c"
int hostfile_read_key(char **cpp , u_int *bitsp , Key *ret ) 
{ char *cp ;
  int tmp ;

  {
#line 58
  cp = *cpp;
#line 58
  while (1) {
#line 58
    if (! ((int )*cp == 32)) {
#line 58
      if (! ((int )*cp == 9)) {
#line 58
        break;
      }
    }
#line 58
    cp ++;
  }
#line 61
  tmp = key_read(ret, & cp);
#line 61
  if (tmp != 1) {
#line 62
    return (0);
  }
#line 65
  while (1) {
#line 65
    if (! ((int )*cp == 32)) {
#line 65
      if (! ((int )*cp == 9)) {
#line 65
        break;
      }
    }
#line 65
    cp ++;
  }
#line 69
  *cpp = cp;
#line 70
  *bitsp = key_size(ret);
#line 71
  return (1);
}
}
#line 74 "hostfile.c"
int auth_rsa_read_key(char **cpp , u_int *bitsp , BIGNUM *e , BIGNUM *n___0 ) 
{ Key *k ;
  Key *tmp ;
  int ret ;
  int tmp___0 ;

  {
#line 77
  tmp = key_new(0);
#line 77
  k = tmp;
#line 78
  tmp___0 = hostfile_read_key(cpp, bitsp, k);
#line 78
  ret = tmp___0;
#line 79
  BN_copy(e, (BIGNUM const   *)(k->rsa)->e);
#line 80
  BN_copy(n___0, (BIGNUM const   *)(k->rsa)->n);
#line 81
  key_free(k);
#line 82
  return (ret);
}
}
#line 85 "hostfile.c"
int hostfile_check_key(int bits , Key *key , char const   *host , char const   *filename ,
                       int linenum ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 88
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 89
    return (1);
  } else {
#line 88
    if (key->type != 0) {
#line 89
      return (1);
    } else {
#line 88
      if ((unsigned int )key->rsa == (unsigned int )((void *)0)) {
#line 89
        return (1);
      }
    }
  }
#line 90
  tmp___1 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 90
  if (bits != tmp___1) {
#line 91
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 91
    log("Warning: %s, line %d: keysize mismatch for host %s: actual %d vs. announced %d.",
        filename, linenum, host, tmp, bits);
#line 94
    tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 94
    log("Warning: replace %d with %d in %s, line %d.", bits, tmp___0, filename, linenum);
  }
#line 97
  return (1);
}
}
#line 107 "hostfile.c"
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , Key *key ,
                                  Key *found , int *numret ) 
{ FILE *f ;
  char line[8192] ;
  int linenum ;
  u_int kbits ;
  u_int hostlen ;
  char *cp ;
  char *cp2 ;
  HostStatus end_return ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 113
  linenum = 0;
#line 118
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 119
    fatal("no key to look up");
  }
#line 121
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 122
  if (! f) {
#line 123
    return (1);
  }
#line 126
  hostlen = strlen(host);
#line 133
  end_return = 1;
#line 136
  while (1) {
#line 136
    tmp___3 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 136
    if (! tmp___3) {
#line 136
      break;
    }
#line 137
    cp = line;
#line 138
    linenum ++;
#line 141
    while (1) {
#line 141
      if (! ((int )*cp == 32)) {
#line 141
        if (! ((int )*cp == 9)) {
#line 141
          break;
        }
      }
#line 141
      cp ++;
    }
#line 143
    if (! *cp) {
#line 144
      continue;
    } else {
#line 143
      if ((int )*cp == 35) {
#line 144
        continue;
      } else {
#line 143
        if ((int )*cp == 10) {
#line 144
          continue;
        }
      }
    }
#line 147
    cp2 = cp;
#line 147
    while (1) {
#line 147
      if (*cp2) {
#line 147
        if ((int )*cp2 != 32) {
#line 147
          if (! ((int )*cp2 != 9)) {
#line 147
            break;
          }
        } else {
#line 147
          break;
        }
      } else {
#line 147
        break;
      }
#line 147
      cp2 ++;
    }
#line 151
    tmp = match_hostname(host, (char const   *)cp, (unsigned int )(cp2 - cp));
#line 151
    if (tmp != 1) {
#line 152
      continue;
    }
#line 155
    cp = cp2;
#line 161
    tmp___0 = hostfile_read_key(& cp, & kbits, found);
#line 161
    if (! tmp___0) {
#line 162
      continue;
    }
#line 163
    tmp___1 = hostfile_check_key((int )kbits, found, host, filename, linenum);
#line 163
    if (! tmp___1) {
#line 164
      continue;
    }
#line 166
    if ((unsigned int )numret != (unsigned int )((void *)0)) {
#line 167
      *numret = linenum;
    }
#line 170
    tmp___2 = key_equal(key, found);
#line 170
    if (tmp___2) {
#line 172
      fclose(f);
#line 173
      return (0);
    }
#line 180
    end_return = 2;
  }
#line 183
  fclose(f);
#line 189
  return (end_return);
}
}
#line 197 "hostfile.c"
int add_host_to_hostfile(char const   *filename , char const   *host , Key *key ) 
{ FILE *f ;
  int success ;
  int tmp ;

  {
#line 201
  success = 0;
#line 202
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 203
    return (1);
  }
#line 204
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"a");
#line 205
  if (! f) {
#line 206
    return (0);
  }
#line 207
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s ", host);
#line 208
  tmp = key_write(key, f);
#line 208
  if (tmp) {
#line 209
    success = 1;
  } else {
#line 211
    error("add_host_to_hostfile: saving key in %s failed", filename);
  }
#line 213
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"\n");
#line 214
  fclose(f);
#line 215
  return (success);
}
}
#line 1 "key.o"
#pragma merger(0,"./key.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 457 "/usr/include/openssl/bn.h"
extern int BN_cmp(BIGNUM const   *a , BIGNUM const   *b ) ;
#line 496
extern char *BN_bn2dec(BIGNUM const   *a ) ;
#line 498
extern int BN_dec2bn(BIGNUM **a , char const   *str ) ;
#line 491 "/usr/include/openssl/evp.h"
extern int EVP_DigestUpdate(EVP_MD_CTX *ctx , void const   *d , size_t cnt ) ;
#line 498
extern int EVP_DigestInit(EVP_MD_CTX *ctx , EVP_MD const   *type ) ;
#line 499
extern int EVP_DigestFinal(EVP_MD_CTX *ctx , unsigned char *md , unsigned int *s ) ;
#line 215 "/usr/include/openssl/rsa.h"
extern RSA *RSA_new(void) ;
#line 221
extern RSA *RSA_generate_key(int bits , unsigned long e , void (*callback)(int  ,
                                                                           int  ,
                                                                           void * ) ,
                             void *cb_arg ) ;
#line 190 "/usr/include/openssl/dsa.h"
extern DSA *DSA_new(void) ;
#line 213
extern DSA *DSA_generate_parameters(int bits , unsigned char *seed , int seed_len ,
                                    int *counter_ret , unsigned long *h_ret , void (*callback)(int  ,
                                                                                               int  ,
                                                                                               void * ) ,
                                    void *cb_arg ) ;
#line 224
extern int DSA_generate_key(DSA *a ) ;
#line 46 "key.h"
Key *key_new_private(int type ) ;
#line 49
char *key_fingerprint(Key *k ) ;
#line 50
char *key_type(Key *k ) ;
#line 55
Key *key_generate(int type , u_int bits ) ;
#line 56
Key *key_from_private(Key *k ) ;
#line 57
int key_type_from_name(char *name ) ;
#line 63
int key_sign(Key *key , u_char **sigp , int *lenp , u_char *data , int datalen ) ;
#line 69
int key_verify(Key *key , u_char *signature , int signaturelen , u_char *data , int datalen ) ;
#line 29 "ssh-dss.h"
int ssh_dss_sign(Key *key , u_char **sigp , int *lenp , u_char *data , int datalen ) ;
#line 35
int ssh_dss_verify(Key *key , u_char *signature , int signaturelen , u_char *data ,
                   int datalen ) ;
#line 29 "ssh-rsa.h"
int ssh_rsa_sign(Key *key , u_char **sigp , int *lenp , u_char *data , int datalen ) ;
#line 35
int ssh_rsa_verify(Key *key , u_char *signature , int signaturelen , u_char *data ,
                   int datalen ) ;
#line 29 "uuencode.h"
int uuencode(u_char *src , u_int srclength , char *target , size_t targsize ) ;
#line 30
int uudecode(char const   *src , u_char *target , size_t targsize ) ;
#line 49 "key.c"
Key *key_new(int type ) 
{ Key *k ;
  RSA *rsa ;
  DSA *dsa ;
  void *tmp ;

  {
#line 55
  tmp = xmalloc(sizeof(*k));
#line 55
  k = (Key *)tmp;
#line 56
  k->type = type;
#line 57
  k->dsa = (DSA *)((void *)0);
#line 58
  k->rsa = (RSA *)((void *)0);
#line 59
  switch (k->type) {
  case 0: 
  case 1: 
#line 62
  rsa = RSA_new();
#line 63
  rsa->n = BN_new();
#line 64
  rsa->e = BN_new();
#line 65
  k->rsa = rsa;
#line 66
  break;
  case 2: 
#line 68
  dsa = DSA_new();
#line 69
  dsa->p = BN_new();
#line 70
  dsa->q = BN_new();
#line 71
  dsa->g = BN_new();
#line 72
  dsa->pub_key = BN_new();
#line 73
  k->dsa = dsa;
#line 74
  break;
  case 3: 
#line 76
  break;
  default: 
#line 78
  fatal("key_new: bad key type %d", k->type);
#line 79
  break;
  }
#line 81
  return (k);
}
}
#line 83 "key.c"
Key *key_new_private(int type ) 
{ Key *k ;
  Key *tmp ;

  {
#line 86
  tmp = key_new(type);
#line 86
  k = tmp;
#line 87
  switch (k->type) {
  case 0: 
  case 1: 
#line 90
  (k->rsa)->d = BN_new();
#line 91
  (k->rsa)->iqmp = BN_new();
#line 92
  (k->rsa)->q = BN_new();
#line 93
  (k->rsa)->p = BN_new();
#line 94
  (k->rsa)->dmq1 = BN_new();
#line 95
  (k->rsa)->dmp1 = BN_new();
#line 96
  break;
  case 2: 
#line 98
  (k->dsa)->priv_key = BN_new();
#line 99
  break;
  case 3: 
#line 101
  break;
  default: ;
#line 103
  break;
  }
#line 105
  return (k);
}
}
#line 107 "key.c"
void key_free(Key *k ) 
{ 

  {
#line 110
  switch (k->type) {
  case 0: 
  case 1: 
#line 113
  if ((unsigned int )k->rsa != (unsigned int )((void *)0)) {
#line 114
    RSA_free(k->rsa);
  }
#line 115
  k->rsa = (RSA *)((void *)0);
#line 116
  break;
  case 2: 
#line 118
  if ((unsigned int )k->dsa != (unsigned int )((void *)0)) {
#line 119
    DSA_free(k->dsa);
  }
#line 120
  k->dsa = (DSA *)((void *)0);
#line 121
  break;
  case 3: 
#line 123
  break;
  default: 
#line 125
  fatal("key_free: bad key type %d", k->type);
#line 126
  break;
  }
#line 128
  xfree((void *)k);
#line 129
  return;
}
}
#line 130 "key.c"
int key_equal(Key *a , Key *b ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 133
  if ((unsigned int )a == (unsigned int )((void *)0)) {
#line 134
    return (0);
  } else {
#line 133
    if ((unsigned int )b == (unsigned int )((void *)0)) {
#line 134
      return (0);
    } else {
#line 133
      if (a->type != b->type) {
#line 134
        return (0);
      }
    }
  }
#line 135
  switch (a->type) {
  case 0: 
  case 1: 
#line 138
  if ((unsigned int )a->rsa != (unsigned int )((void *)0)) {
#line 138
    if ((unsigned int )b->rsa != (unsigned int )((void *)0)) {
#line 138
      tmp = BN_cmp((BIGNUM const   *)(a->rsa)->e, (BIGNUM const   *)(b->rsa)->e);
#line 138
      if (tmp == 0) {
#line 138
        tmp___0 = BN_cmp((BIGNUM const   *)(a->rsa)->n, (BIGNUM const   *)(b->rsa)->n);
#line 138
        if (tmp___0 == 0) {
#line 138
          tmp___1 = 1;
        } else {
#line 138
          tmp___1 = 0;
        }
      } else {
#line 138
        tmp___1 = 0;
      }
    } else {
#line 138
      tmp___1 = 0;
    }
  } else {
#line 138
    tmp___1 = 0;
  }
#line 138
  return (tmp___1);
#line 141
  break;
  case 2: 
#line 143
  if ((unsigned int )a->dsa != (unsigned int )((void *)0)) {
#line 143
    if ((unsigned int )b->dsa != (unsigned int )((void *)0)) {
#line 143
      tmp___2 = BN_cmp((BIGNUM const   *)(a->dsa)->p, (BIGNUM const   *)(b->dsa)->p);
#line 143
      if (tmp___2 == 0) {
#line 143
        tmp___3 = BN_cmp((BIGNUM const   *)(a->dsa)->q, (BIGNUM const   *)(b->dsa)->q);
#line 143
        if (tmp___3 == 0) {
#line 143
          tmp___4 = BN_cmp((BIGNUM const   *)(a->dsa)->g, (BIGNUM const   *)(b->dsa)->g);
#line 143
          if (tmp___4 == 0) {
#line 143
            tmp___5 = BN_cmp((BIGNUM const   *)(a->dsa)->pub_key, (BIGNUM const   *)(b->dsa)->pub_key);
#line 143
            if (tmp___5 == 0) {
#line 143
              tmp___6 = 1;
            } else {
#line 143
              tmp___6 = 0;
            }
          } else {
#line 143
            tmp___6 = 0;
          }
        } else {
#line 143
          tmp___6 = 0;
        }
      } else {
#line 143
        tmp___6 = 0;
      }
    } else {
#line 143
      tmp___6 = 0;
    }
  } else {
#line 143
    tmp___6 = 0;
  }
#line 143
  return (tmp___6);
#line 148
  break;
  default: 
#line 150
  fatal("key_equal: bad key type %d", a->type);
#line 151
  break;
  }
#line 153
  return (0);
}
}
#line 163 "key.c"
static char retval[195]  ;
#line 160 "key.c"
char *key_fingerprint(Key *k ) 
{ u_char *blob ;
  int len ;
  int nlen ;
  int elen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int i ;
  u_char digest___1[64] ;
  EVP_MD *md ;
  EVP_MD const   *tmp___2 ;
  EVP_MD_CTX ctx ;
  char hex[4] ;
  size_t tmp___3 ;

  {
#line 164
  blob = (u_char *)((void *)0);
#line 165
  len = 0;
#line 168
  retval[0] = (char )'\000';
#line 169
  switch (k->type) {
  case 0: 
#line 171
  tmp = BN_num_bits((BIGNUM const   *)(k->rsa)->n);
#line 171
  nlen = (tmp + 7) / 8;
#line 172
  tmp___0 = BN_num_bits((BIGNUM const   *)(k->rsa)->e);
#line 172
  elen = (tmp___0 + 7) / 8;
#line 173
  len = nlen + elen;
#line 174
  tmp___1 = xmalloc((unsigned int )len);
#line 174
  blob = (u_char *)tmp___1;
#line 175
  BN_bn2bin((BIGNUM const   *)(k->rsa)->n, blob);
#line 176
  BN_bn2bin((BIGNUM const   *)(k->rsa)->e, blob + nlen);
#line 177
  break;
  case 2: 
  case 1: 
#line 180
  key_to_blob(k, & blob, (u_int *)(& len));
#line 181
  break;
  case 3: 
#line 183
  return (retval);
#line 184
  break;
  default: 
#line 186
  fatal("key_fingerprint: bad key type %d", k->type);
#line 187
  break;
  }
#line 189
  if ((unsigned int )blob != (unsigned int )((void *)0)) {
#line 192
    tmp___2 = EVP_md5();
#line 192
    md = (EVP_MD *)tmp___2;
#line 194
    EVP_DigestInit(& ctx, (EVP_MD const   *)md);
#line 195
    EVP_DigestUpdate(& ctx, (void const   *)blob, (unsigned int )len);
#line 196
    EVP_DigestFinal(& ctx, digest___1, (unsigned int *)((void *)0));
#line 197
    i = 0;
#line 197
    while (i < md->md_size) {
#line 199
      snprintf((char * __restrict  )(hex), sizeof(hex), (char const   * __restrict  )"%02x:",
               digest___1[i]);
#line 200
      strlcat(retval, (char const   *)(hex), sizeof(retval));
#line 197
      i ++;
    }
#line 202
    tmp___3 = strlen((char const   *)(retval));
#line 202
    retval[tmp___3 - 1U] = (char )'\000';
#line 203
    memset((void *)blob, 0, (unsigned int )len);
#line 204
    xfree((void *)blob);
  }
#line 206
  return (retval);
}
}
#line 216 "key.c"
int read_bignum(char **cpp , BIGNUM *value ) 
{ char *cp ;
  int old ;
  int tmp ;

  {
#line 219
  cp = *cpp;
#line 223
  while (1) {
#line 223
    if (! ((int )*cp == 32)) {
#line 223
      if (! ((int )*cp == 9)) {
#line 223
        break;
      }
    }
#line 223
    cp ++;
  }
#line 227
  if ((int )*cp < 48) {
#line 228
    return (0);
  } else {
#line 227
    if ((int )*cp > 57) {
#line 228
      return (0);
    }
  }
#line 231
  *cpp = cp;
#line 234
  while (1) {
#line 234
    if ((int )*cp >= 48) {
#line 234
      if (! ((int )*cp <= 57)) {
#line 234
        break;
      }
    } else {
#line 234
      break;
    }
#line 234
    cp ++;
  }
#line 238
  old = (int )*cp;
#line 239
  *cp = (char)0;
#line 242
  tmp = BN_dec2bn(& value, (char const   *)*cpp);
#line 242
  if (tmp == 0) {
#line 243
    return (0);
  }
#line 246
  *cp = (char )old;
#line 249
  *cpp = cp;
#line 250
  return (1);
}
}
#line 252 "key.c"
int write_bignum(FILE *f , BIGNUM *num ) 
{ char *buf___2 ;
  char *tmp ;

  {
#line 255
  tmp = BN_bn2dec((BIGNUM const   *)num);
#line 255
  buf___2 = tmp;
#line 256
  if ((unsigned int )buf___2 == (unsigned int )((void *)0)) {
#line 257
    error("write_bignum: BN_bn2dec() failed");
#line 258
    return (0);
  }
#line 260
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )" %s", buf___2);
#line 261
  xfree((void *)buf___2);
#line 262
  return (1);
}
}
#line 266 "key.c"
int key_read(Key *ret , char **cpp ) 
{ Key *k ;
  int success ;
  char *cp ;
  char *space ;
  int len ;
  int n___0 ;
  int type ;
  u_int bits ;
  u_char *blob ;
  int tmp ;
  int tmp___0 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
#line 270
  success = -1;
#line 276
  cp = *cpp;
#line 278
  switch (ret->type) {
  case 0: 
#line 281
  if ((int )*cp < 48) {
#line 282
    return (-1);
  } else {
#line 281
    if ((int )*cp > 57) {
#line 282
      return (-1);
    }
  }
#line 283
  bits = 0U;
#line 283
  while (1) {
#line 283
    if ((int )*cp >= 48) {
#line 283
      if (! ((int )*cp <= 57)) {
#line 283
        break;
      }
    } else {
#line 283
      break;
    }
#line 284
    bits = (10U * bits + (u_int )*cp) - 48U;
#line 283
    cp ++;
  }
#line 285
  if (bits == 0U) {
#line 286
    return (-1);
  }
#line 287
  *cpp = cp;
#line 289
  tmp = read_bignum(cpp, (ret->rsa)->e);
#line 289
  if (! tmp) {
#line 290
    return (-1);
  }
#line 291
  tmp___0 = read_bignum(cpp, (ret->rsa)->n);
#line 291
  if (! tmp___0) {
#line 292
    return (-1);
  }
#line 293
  success = 1;
#line 294
  break;
  case 3: 
  case 1: 
  case 2: 
#line 298
  tmp___2 = __builtin_strchr(cp, ' ');
#line 298
  space = tmp___2;
#line 299
  if ((unsigned int )space == (unsigned int )((void *)0)) {
#line 300
    debug3("key_read: no space");
#line 301
    return (-1);
  }
#line 303
  *space = (char )'\000';
#line 304
  type = key_type_from_name(cp);
#line 305
  *space = (char )' ';
#line 306
  if (type == 3) {
#line 307
    debug3("key_read: no key found");
#line 308
    return (-1);
  }
#line 310
  cp = space + 1;
#line 311
  if ((int )*cp == 0) {
#line 312
    debug3("key_read: short string");
#line 313
    return (-1);
  }
#line 315
  if (ret->type == 3) {
#line 316
    ret->type = type;
  } else {
#line 317
    if (ret->type != type) {
#line 319
      debug3("key_read: type mismatch");
#line 320
      return (0);
    }
  }
#line 322
  tmp___3 = strlen((char const   *)cp);
#line 322
  len = (int )(2U * tmp___3);
#line 323
  tmp___4 = xmalloc((unsigned int )len);
#line 323
  blob = (u_char *)tmp___4;
#line 324
  n___0 = uudecode((char const   *)cp, blob, (unsigned int )len);
#line 325
  if (n___0 < 0) {
#line 326
    error("key_read: uudecode %s failed", cp);
#line 327
    return (-1);
  }
#line 329
  k = key_from_blob((char *)blob, n___0);
#line 330
  if ((unsigned int )k == (unsigned int )((void *)0)) {
#line 331
    error("key_read: key_from_blob %s failed", cp);
#line 332
    return (-1);
  }
#line 334
  xfree((void *)blob);
#line 335
  if (k->type != type) {
#line 336
    error("key_read: type mismatch: encoding error");
#line 337
    key_free(k);
#line 338
    return (-1);
  }
#line 341
  if (ret->type == 1) {
#line 342
    if ((unsigned int )ret->rsa != (unsigned int )((void *)0)) {
#line 343
      RSA_free(ret->rsa);
    }
#line 344
    ret->rsa = k->rsa;
#line 345
    k->rsa = (RSA *)((void *)0);
#line 346
    success = 1;
  } else {
#line 351
    if ((unsigned int )ret->dsa != (unsigned int )((void *)0)) {
#line 352
      DSA_free(ret->dsa);
    }
#line 353
    ret->dsa = k->dsa;
#line 354
    k->dsa = (DSA *)((void *)0);
#line 355
    success = 1;
  }
#line 361
  if (success != 1) {
#line 362
    break;
  }
#line 363
  key_free(k);
#line 365
  while (1) {
#line 365
    if (! ((int )*cp == 32)) {
#line 365
      if (! ((int )*cp == 9)) {
#line 365
        break;
      }
    }
#line 366
    cp ++;
  }
#line 367
  while (1) {
#line 367
    if ((int )*cp != 0) {
#line 367
      if ((int )*cp != 32) {
#line 367
        if (! ((int )*cp != 9)) {
#line 367
          break;
        }
      } else {
#line 367
        break;
      }
    } else {
#line 367
      break;
    }
#line 368
    cp ++;
  }
#line 369
  *cpp = cp;
#line 370
  break;
  default: 
#line 372
  fatal("key_read: bad key type: %d", ret->type);
#line 373
  break;
  }
#line 375
  return (success);
}
}
#line 377 "key.c"
int key_write(Key *key , FILE *f ) 
{ int success ;
  u_int bits ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int len ;
  int n___0 ;
  u_char *blob ;
  u_char *uu ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
#line 380
  success = 0;
#line 381
  bits = (u_int )0;
#line 383
  if (key->type == 0) {
#line 383
    if ((unsigned int )key->rsa != (unsigned int )((void *)0)) {
#line 385
      tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 385
      bits = (unsigned int )tmp;
#line 386
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%u", bits);
#line 387
      tmp___0 = write_bignum(f, (key->rsa)->e);
#line 387
      if (tmp___0) {
#line 387
        tmp___1 = write_bignum(f, (key->rsa)->n);
#line 387
        if (tmp___1) {
#line 389
          success = 1;
        } else {
#line 391
          error("key_write: failed for RSA key");
        }
      } else {
#line 391
        error("key_write: failed for RSA key");
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 393
    if (key->type == 2) {
#line 393
      if ((unsigned int )key->dsa != (unsigned int )((void *)0)) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 393
      if (key->type == 1) {
#line 393
        if ((unsigned int )key->rsa != (unsigned int )((void *)0)) {
          _L: /* CIL Label */ 
#line 397
          key_to_blob(key, & blob, (u_int *)(& len));
#line 398
          tmp___2 = xmalloc((unsigned int )(2 * len));
#line 398
          uu = (u_char *)tmp___2;
#line 399
          n___0 = uuencode(blob, (unsigned int )len, (char *)uu, (unsigned int )(2 * len));
#line 400
          if (n___0 > 0) {
#line 401
            tmp___3 = key_ssh_name(key);
#line 401
            fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s",
                    tmp___3, uu);
#line 402
            success = 1;
          }
#line 404
          xfree((void *)blob);
#line 405
          xfree((void *)uu);
        }
      }
    }
  }
#line 407
  return (success);
}
}
#line 409 "key.c"
char *key_type(Key *k ) 
{ 

  {
#line 412
  switch (k->type) {
  case 0: 
#line 414
  return ((char *)"RSA1");
#line 415
  break;
  case 1: 
#line 417
  return ((char *)"RSA");
#line 418
  break;
  case 2: 
#line 420
  return ((char *)"DSA");
#line 421
  break;
  }
#line 423
  return ((char *)"unknown");
}
}
#line 425 "key.c"
char *key_ssh_name(Key *k ) 
{ 

  {
#line 428
  switch (k->type) {
  case 1: 
#line 430
  return ((char *)"ssh-rsa");
#line 431
  break;
  case 2: 
#line 433
  return ((char *)"ssh-dss");
#line 434
  break;
  }
#line 436
  return ((char *)"ssh-unknown");
}
}
#line 438 "key.c"
u_int key_size(Key *k ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 440
  switch (k->type) {
  case 0: 
  case 1: 
#line 443
  tmp = BN_num_bits((BIGNUM const   *)(k->rsa)->n);
#line 443
  return ((unsigned int )tmp);
#line 444
  break;
  case 2: 
#line 446
  tmp___0 = BN_num_bits((BIGNUM const   *)(k->dsa)->p);
#line 446
  return ((unsigned int )tmp___0);
#line 447
  break;
  }
#line 449
  return (0U);
}
}
#line 452 "key.c"
RSA *rsa_generate_private_key(u_int bits ) 
{ RSA *private ;

  {
#line 456
  private = RSA_generate_key((int )bits, 35UL, (void (*)(int  , int  , void * ))((void *)0),
                             (void *)0);
#line 457
  if ((unsigned int )private == (unsigned int )((void *)0)) {
#line 458
    fatal("rsa_generate_private_key: key generation failed.");
  }
#line 459
  return (private);
}
}
#line 462 "key.c"
DSA *dsa_generate_private_key(u_int bits ) 
{ DSA *private ;
  DSA *tmp ;
  int tmp___0 ;

  {
#line 465
  tmp = DSA_generate_parameters((int )bits, (unsigned char *)((void *)0), 0, (int *)((void *)0),
                                (unsigned long *)((void *)0), (void (*)(int  , int  ,
                                                                        void * ))((void *)0),
                                (void *)0);
#line 465
  private = tmp;
#line 466
  if ((unsigned int )private == (unsigned int )((void *)0)) {
#line 467
    fatal("dsa_generate_private_key: DSA_generate_parameters failed");
  }
#line 468
  tmp___0 = DSA_generate_key(private);
#line 468
  if (! tmp___0) {
#line 469
    fatal("dsa_generate_private_key: DSA_generate_key failed.");
  }
#line 470
  if ((unsigned int )private == (unsigned int )((void *)0)) {
#line 471
    fatal("dsa_generate_private_key: NULL.");
  }
#line 472
  return (private);
}
}
#line 475 "key.c"
Key *key_generate(int type , u_int bits ) 
{ Key *k ;
  Key *tmp ;

  {
#line 478
  tmp = key_new(3);
#line 478
  k = tmp;
#line 479
  switch (type) {
  case 2: 
#line 481
  k->dsa = dsa_generate_private_key(bits);
#line 482
  break;
  case 1: 
  case 0: 
#line 485
  k->rsa = rsa_generate_private_key(bits);
#line 486
  break;
  default: 
#line 488
  fatal("key_generate: unknown type %d", type);
  }
#line 490
  k->type = type;
#line 491
  return (k);
}
}
#line 494 "key.c"
Key *key_from_private(Key *k ) 
{ Key *n___0 ;

  {
#line 497
  n___0 = (Key *)((void *)0);
#line 498
  switch (k->type) {
  case 2: 
#line 500
  n___0 = key_new(k->type);
#line 501
  BN_copy((n___0->dsa)->p, (BIGNUM const   *)(k->dsa)->p);
#line 502
  BN_copy((n___0->dsa)->q, (BIGNUM const   *)(k->dsa)->q);
#line 503
  BN_copy((n___0->dsa)->g, (BIGNUM const   *)(k->dsa)->g);
#line 504
  BN_copy((n___0->dsa)->pub_key, (BIGNUM const   *)(k->dsa)->pub_key);
#line 505
  break;
  case 1: 
  case 0: 
#line 508
  n___0 = key_new(k->type);
#line 509
  BN_copy((n___0->rsa)->n, (BIGNUM const   *)(k->rsa)->n);
#line 510
  BN_copy((n___0->rsa)->e, (BIGNUM const   *)(k->rsa)->e);
#line 511
  break;
  default: 
#line 513
  fatal("key_from_private: unknown type %d", k->type);
#line 514
  break;
  }
#line 516
  return (n___0);
}
}
#line 519 "key.c"
int key_type_from_name(char *name ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;

  {
#line 522
  if (0) {
#line 522
    __s1_len___3 = strlen((char const   *)name);
#line 522
    __s2_len___3 = strlen("rsa1");
#line 522
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___8;
    } else {
#line 522
      if (__s1_len___3 >= 4U) {
        _L___8: /* CIL Label */ 
#line 522
        if (! ((unsigned int )((void const   *)("rsa1" + 1)) - (unsigned int )((void const   *)"rsa1") == 1U)) {
#line 522
          tmp___48 = 1;
        } else {
#line 522
          if (__s2_len___3 >= 4U) {
#line 522
            tmp___48 = 1;
          } else {
#line 522
            tmp___48 = 0;
          }
        }
      } else {
#line 522
        tmp___48 = 0;
      }
    }
#line 522
    if (tmp___48) {
#line 522
      tmp___44 = __builtin_strcmp((char const   *)name, "rsa1");
    } else {
#line 522
      tmp___47 = __builtin_strcmp((char const   *)name, "rsa1");
#line 522
      tmp___44 = tmp___47;
    }
  } else {
#line 522
    tmp___47 = __builtin_strcmp((char const   *)name, "rsa1");
#line 522
    tmp___44 = tmp___47;
  }
#line 522
  if (tmp___44 == 0) {
#line 523
    return (0);
  } else {
#line 524
    if (0) {
#line 524
      __s1_len___2 = strlen((char const   *)name);
#line 524
      __s2_len___2 = strlen("rsa");
#line 524
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___6;
      } else {
#line 524
        if (__s1_len___2 >= 4U) {
          _L___6: /* CIL Label */ 
#line 524
          if (! ((unsigned int )((void const   *)("rsa" + 1)) - (unsigned int )((void const   *)"rsa") == 1U)) {
#line 524
            tmp___38 = 1;
          } else {
#line 524
            if (__s2_len___2 >= 4U) {
#line 524
              tmp___38 = 1;
            } else {
#line 524
              tmp___38 = 0;
            }
          }
        } else {
#line 524
          tmp___38 = 0;
        }
      }
#line 524
      if (tmp___38) {
#line 524
        tmp___34 = __builtin_strcmp((char const   *)name, "rsa");
      } else {
#line 524
        tmp___37 = __builtin_strcmp((char const   *)name, "rsa");
#line 524
        tmp___34 = tmp___37;
      }
    } else {
#line 524
      tmp___37 = __builtin_strcmp((char const   *)name, "rsa");
#line 524
      tmp___34 = tmp___37;
    }
#line 524
    if (tmp___34 == 0) {
#line 525
      return (1);
    } else {
#line 526
      if (0) {
#line 526
        __s1_len___1 = strlen((char const   *)name);
#line 526
        __s2_len___1 = strlen("dsa");
#line 526
        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
          goto _L___4;
        } else {
#line 526
          if (__s1_len___1 >= 4U) {
            _L___4: /* CIL Label */ 
#line 526
            if (! ((unsigned int )((void const   *)("dsa" + 1)) - (unsigned int )((void const   *)"dsa") == 1U)) {
#line 526
              tmp___28 = 1;
            } else {
#line 526
              if (__s2_len___1 >= 4U) {
#line 526
                tmp___28 = 1;
              } else {
#line 526
                tmp___28 = 0;
              }
            }
          } else {
#line 526
            tmp___28 = 0;
          }
        }
#line 526
        if (tmp___28) {
#line 526
          tmp___24 = __builtin_strcmp((char const   *)name, "dsa");
        } else {
#line 526
          tmp___27 = __builtin_strcmp((char const   *)name, "dsa");
#line 526
          tmp___24 = tmp___27;
        }
      } else {
#line 526
        tmp___27 = __builtin_strcmp((char const   *)name, "dsa");
#line 526
        tmp___24 = tmp___27;
      }
#line 526
      if (tmp___24 == 0) {
#line 527
        return (2);
      } else {
#line 528
        if (0) {
#line 528
          __s1_len___0 = strlen((char const   *)name);
#line 528
          __s2_len___0 = strlen("ssh-rsa");
#line 528
          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
            goto _L___2;
          } else {
#line 528
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 528
              if (! ((unsigned int )((void const   *)("ssh-rsa" + 1)) - (unsigned int )((void const   *)"ssh-rsa") == 1U)) {
#line 528
                tmp___18 = 1;
              } else {
#line 528
                if (__s2_len___0 >= 4U) {
#line 528
                  tmp___18 = 1;
                } else {
#line 528
                  tmp___18 = 0;
                }
              }
            } else {
#line 528
              tmp___18 = 0;
            }
          }
#line 528
          if (tmp___18) {
#line 528
            tmp___14 = __builtin_strcmp((char const   *)name, "ssh-rsa");
          } else {
#line 528
            tmp___17 = __builtin_strcmp((char const   *)name, "ssh-rsa");
#line 528
            tmp___14 = tmp___17;
          }
        } else {
#line 528
          tmp___17 = __builtin_strcmp((char const   *)name, "ssh-rsa");
#line 528
          tmp___14 = tmp___17;
        }
#line 528
        if (tmp___14 == 0) {
#line 529
          return (1);
        } else {
#line 530
          if (0) {
#line 530
            __s1_len = strlen((char const   *)name);
#line 530
            __s2_len = strlen("ssh-dss");
#line 530
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
              goto _L___0;
            } else {
#line 530
              if (__s1_len >= 4U) {
                _L___0: /* CIL Label */ 
#line 530
                if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
#line 530
                  tmp___8 = 1;
                } else {
#line 530
                  if (__s2_len >= 4U) {
#line 530
                    tmp___8 = 1;
                  } else {
#line 530
                    tmp___8 = 0;
                  }
                }
              } else {
#line 530
                tmp___8 = 0;
              }
            }
#line 530
            if (tmp___8) {
#line 530
              tmp___4 = __builtin_strcmp((char const   *)name, "ssh-dss");
            } else {
#line 530
              tmp___7 = __builtin_strcmp((char const   *)name, "ssh-dss");
#line 530
              tmp___4 = tmp___7;
            }
          } else {
#line 530
            tmp___7 = __builtin_strcmp((char const   *)name, "ssh-dss");
#line 530
            tmp___4 = tmp___7;
          }
#line 530
          if (tmp___4 == 0) {
#line 531
            return (2);
          }
        }
      }
    }
  }
#line 533
  debug("key_type_from_name: unknown key type \'%s\'", name);
#line 534
  return (3);
}
}
#line 537 "key.c"
Key *key_from_blob(char *blob , int blen ) 
{ Buffer b ;
  char *ktype ;
  int rlen ;
  int type ;
  Key *key ;
  u_int tmp ;

  {
#line 543
  key = (Key *)((void *)0);
#line 548
  buffer_init(& b);
#line 549
  buffer_append(& b, (char const   *)blob, (unsigned int )blen);
#line 550
  ktype = buffer_get_string(& b, (u_int *)((void *)0));
#line 551
  type = key_type_from_name(ktype);
#line 553
  switch (type) {
  case 1: 
#line 555
  key = key_new(type);
#line 556
  buffer_get_bignum2(& b, (key->rsa)->e);
#line 557
  buffer_get_bignum2(& b, (key->rsa)->n);
#line 561
  break;
  case 2: 
#line 563
  key = key_new(type);
#line 564
  buffer_get_bignum2(& b, (key->dsa)->p);
#line 565
  buffer_get_bignum2(& b, (key->dsa)->q);
#line 566
  buffer_get_bignum2(& b, (key->dsa)->g);
#line 567
  buffer_get_bignum2(& b, (key->dsa)->pub_key);
#line 571
  break;
  case 3: 
#line 573
  key = key_new(type);
#line 574
  break;
  default: 
#line 576
  error("key_from_blob: cannot handle type %s", ktype);
#line 577
  break;
  }
#line 579
  tmp = buffer_len(& b);
#line 579
  rlen = (int )tmp;
#line 580
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 580
    if (rlen != 0) {
#line 581
      error("key_from_blob: remaining bytes in key blob %d", rlen);
    }
  }
#line 582
  xfree((void *)ktype);
#line 583
  buffer_free(& b);
#line 584
  return (key);
}
}
#line 587 "key.c"
int key_to_blob(Key *key , u_char **blobp , u_int *lenp ) 
{ Buffer b ;
  int len ;
  u_char *buf___2 ;
  char *tmp ;
  char *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 594
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 595
    error("key_to_blob: key == NULL");
#line 596
    return (0);
  }
#line 598
  buffer_init(& b);
#line 599
  switch (key->type) {
  case 2: 
#line 601
  tmp = key_ssh_name(key);
#line 601
  buffer_put_cstring(& b, (char const   *)tmp);
#line 602
  buffer_put_bignum2(& b, (key->dsa)->p);
#line 603
  buffer_put_bignum2(& b, (key->dsa)->q);
#line 604
  buffer_put_bignum2(& b, (key->dsa)->g);
#line 605
  buffer_put_bignum2(& b, (key->dsa)->pub_key);
#line 606
  break;
  case 1: 
#line 608
  tmp___0 = key_ssh_name(key);
#line 608
  buffer_put_cstring(& b, (char const   *)tmp___0);
#line 609
  buffer_put_bignum2(& b, (key->rsa)->e);
#line 610
  buffer_put_bignum2(& b, (key->rsa)->n);
#line 611
  break;
  default: 
#line 613
  error("key_to_blob: illegal key type %d", key->type);
#line 614
  break;
  }
#line 616
  tmp___1 = buffer_len(& b);
#line 616
  len = (int )tmp___1;
#line 617
  tmp___2 = xmalloc((unsigned int )len);
#line 617
  buf___2 = (u_char *)tmp___2;
#line 618
  tmp___3 = buffer_ptr(& b);
#line 618
  memcpy((void * __restrict  )buf___2, (void const   * __restrict  )tmp___3, (unsigned int )len);
#line 619
  tmp___4 = buffer_ptr(& b);
#line 619
  memset((void *)tmp___4, 0, (unsigned int )len);
#line 620
  buffer_free(& b);
#line 621
  if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 622
    *lenp = (unsigned int )len;
  }
#line 623
  if ((unsigned int )blobp != (unsigned int )((void *)0)) {
#line 624
    *blobp = buf___2;
  }
#line 625
  return (len);
}
}
#line 628 "key.c"
int key_sign(Key *key , u_char **sigp , int *lenp , u_char *data , int datalen ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 634
  switch (key->type) {
  case 2: 
#line 636
  tmp = ssh_dss_sign(key, sigp, lenp, data, datalen);
#line 636
  return (tmp);
#line 637
  break;
  case 1: 
#line 639
  tmp___0 = ssh_rsa_sign(key, sigp, lenp, data, datalen);
#line 639
  return (tmp___0);
#line 640
  break;
  default: 
#line 642
  error("key_sign: illegal key type %d", key->type);
#line 643
  return (-1);
#line 644
  break;
  }
#line 646
  return (0);
}
}
#line 648 "key.c"
int key_verify(Key *key , u_char *signature , int signaturelen , u_char *data , int datalen ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 654
  switch (key->type) {
  case 2: 
#line 656
  tmp = ssh_dss_verify(key, signature, signaturelen, data, datalen);
#line 656
  return (tmp);
#line 657
  break;
  case 1: 
#line 659
  tmp___0 = ssh_rsa_verify(key, signature, signaturelen, data, datalen);
#line 659
  return (tmp___0);
#line 660
  break;
  default: 
#line 662
  error("key_verify: illegal key type %d", key->type);
#line 663
  return (-1);
#line 664
  break;
  }
#line 666
  return (0);
}
}
#line 1 "kex.o"
#pragma merger(0,"./kex.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 459 "/usr/include/openssl/bn.h"
extern int BN_is_bit_set(BIGNUM const   *a , int n ) ;
#line 497
extern int BN_hex2bn(BIGNUM **a , char const   *str ) ;
#line 173 "/usr/include/openssl/dh.h"
extern DH *DH_new(void) ;
#line 193
extern int DH_generate_key(DH *dh ) ;
#line 89 "packet.h"
void packet_put_raw(char const   *buf___2 , u_int len ) ;
#line 104
void packet_read_expect(int *payload_len_ptr , int expected_type ) ;
#line 123
u_int packet_get_char(void) ;
#line 134
char *packet_get_raw(int *length_ptr ) ;
#line 96 "kex.h"
Buffer *kex_init(char **myproposal___0 ) ;
#line 97
void kex_exchange_kexinit(Buffer *my_kexinit , Buffer *peer_kexint , char **peer_proposal ) ;
#line 101
Kex *kex_choose_conf(char **cprop , char **sprop , int server ) ;
#line 104
int kex_derive_keys(Kex *k , u_char *hash , BIGNUM *shared_secret ) ;
#line 106
int dh_pub_is_valid(DH *dh , BIGNUM *dh_pub ) ;
#line 107
DH *dh_new_group_asc(char const   *gen___0 , char const   *modulus ) ;
#line 108
DH *dh_new_group(BIGNUM *gen___0 , BIGNUM *modulus ) ;
#line 109
void dh_gen_key(DH *dh ) ;
#line 110
DH *dh_new_group1(void) ;
#line 112
u_char *kex_hash(char *client_version_string___0 , char *server_version_string___0 ,
                 char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                 char *serverhostkeyblob , int sbloblen , BIGNUM *client_dh_pub ,
                 BIGNUM *server_dh_pub , BIGNUM *shared_secret ) ;
#line 123
u_char *kex_hash_gex(char *client_version_string___0 , char *server_version_string___0 ,
                     char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                     char *serverhostkeyblob , int sbloblen , int minbits , BIGNUM *prime ,
                     BIGNUM *gen___0 , BIGNUM *client_dh_pub , BIGNUM *server_dh_pub ,
                     BIGNUM *shared_secret ) ;
#line 48 "kex.c"
Buffer *kex_init(char **myproposal___0 ) 
{ int first_kex_packet_follows ;
  u_char cookie[16] ;
  u_int32_t rand___0 ;
  int i ;
  Buffer *ki ;
  void *tmp ;

  {
#line 51
  first_kex_packet_follows = 0;
#line 53
  rand___0 = (u_int32_t )0;
#line 55
  tmp = xmalloc(sizeof(*ki));
#line 55
  ki = (Buffer *)tmp;
#line 56
  i = 0;
#line 56
  while (i < 16) {
#line 57
    if (i % 4 == 0) {
#line 58
      rand___0 = arc4random();
    }
#line 59
    cookie[i] = (unsigned char )(rand___0 & 255U);
#line 60
    rand___0 >>= 8;
#line 56
    i ++;
  }
#line 62
  buffer_init(ki);
#line 63
  buffer_append(ki, (char const   *)((char *)(cookie)), sizeof(cookie));
#line 64
  i = 0;
#line 64
  while (i < 10) {
#line 65
    buffer_put_cstring(ki, (char const   *)*(myproposal___0 + i));
#line 64
    i ++;
  }
#line 66
  buffer_put_char(ki, first_kex_packet_follows);
#line 67
  buffer_put_int(ki, 0U);
#line 68
  return (ki);
}
}
#line 72 "kex.c"
void kex_exchange_kexinit(Buffer *my_kexinit , Buffer *peer_kexint , char **peer_proposal ) 
{ int i ;
  char *ptr ;
  int plen ;
  u_int tmp ;
  char *tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 81
  debug("send KEXINIT");
#line 82
  packet_start(20);
#line 83
  tmp = buffer_len(my_kexinit);
#line 83
  tmp___0 = buffer_ptr(my_kexinit);
#line 83
  packet_put_raw((char const   *)tmp___0, tmp);
#line 84
  packet_send();
#line 85
  packet_write_wait();
#line 86
  debug("done");
#line 92
  debug("wait KEXINIT");
#line 93
  packet_read_expect(& plen, 20);
#line 94
  ptr = packet_get_raw(& plen);
#line 95
  buffer_append(peer_kexint, (char const   *)ptr, (unsigned int )plen);
#line 99
  i = 0;
#line 99
  while (i < 16) {
#line 100
    packet_get_char();
#line 99
    i ++;
  }
#line 102
  i = 0;
#line 102
  while (i < 10) {
#line 103
    *(peer_proposal + i) = packet_get_string((u_int *)((void *)0));
#line 104
    debug("got kexinit: %s", *(peer_proposal + i));
#line 102
    i ++;
  }
#line 107
  tmp___1 = packet_get_char();
#line 107
  i = (int )tmp___1;
#line 108
  debug("first kex follow: %d ", i);
#line 109
  tmp___2 = packet_get_int();
#line 109
  i = (int )tmp___2;
#line 110
  debug("reserved: %d ", i);
#line 111
  while (1) {
#line 111
    tmp___3 = packet_remaining();
#line 111
    _len = tmp___3;
#line 111
    if (_len > 0) {
#line 111
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kex.c", 111);
#line 111
      packet_disconnect("Packet integrity error.");
    }
#line 111
    break;
  }
#line 112
  debug("done");
#line 113
  return;
}
}
#line 117 "kex.c"
int dh_pub_is_valid(DH *dh , BIGNUM *dh_pub ) 
{ int i ;
  int n___0 ;
  int tmp ;
  int bits_set ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 121
  tmp = BN_num_bits((BIGNUM const   *)dh_pub);
#line 121
  n___0 = tmp;
#line 122
  bits_set = 0;
#line 124
  if (dh_pub->neg) {
#line 125
    log("invalid public DH value: negativ");
#line 126
    return (0);
  }
#line 128
  i = 0;
#line 128
  while (i <= n___0) {
#line 129
    tmp___0 = BN_is_bit_set((BIGNUM const   *)dh_pub, i);
#line 129
    if (tmp___0) {
#line 130
      bits_set ++;
    }
#line 128
    i ++;
  }
#line 131
  tmp___1 = BN_num_bits((BIGNUM const   *)dh->p);
#line 131
  debug("bits set: %d/%d", bits_set, tmp___1);
#line 134
  if (bits_set > 1) {
#line 134
    tmp___2 = BN_cmp((BIGNUM const   *)dh_pub, (BIGNUM const   *)dh->p);
#line 134
    if (tmp___2 == -1) {
#line 135
      return (1);
    }
  }
#line 136
  tmp___3 = BN_num_bits((BIGNUM const   *)dh->p);
#line 136
  log("invalid public DH value (%d/%d)", bits_set, tmp___3);
#line 137
  return (0);
}
}
#line 140 "kex.c"
void dh_gen_key(DH *dh ) 
{ int tries ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 143
  tries = 0;
#line 145
  while (1) {
#line 146
    tmp = DH_generate_key(dh);
#line 146
    if (tmp == 0) {
#line 147
      fatal("DH_generate_key");
    }
#line 148
    tmp___0 = tries;
#line 148
    tries ++;
#line 148
    if (tmp___0 > 10) {
#line 149
      fatal("dh_new_group1: too many bad keys: giving up");
    }
#line 145
    tmp___1 = dh_pub_is_valid(dh, dh->pub_key);
#line 145
    if (tmp___1) {
#line 145
      break;
    }
  }
#line 151
  return;
}
}
#line 153 "kex.c"
DH *dh_new_group_asc(char const   *gen___0 , char const   *modulus ) 
{ DH *dh ;
  int ret ;

  {
#line 159
  dh = DH_new();
#line 160
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 161
    fatal("DH_new");
  }
#line 163
  ret = BN_hex2bn(& dh->p, modulus);
#line 163
  if (ret < 0) {
#line 164
    fatal("BN_hex2bn p");
  }
#line 165
  ret = BN_hex2bn(& dh->g, gen___0);
#line 165
  if (ret < 0) {
#line 166
    fatal("BN_hex2bn g");
  }
#line 168
  return (dh);
}
}
#line 176 "kex.c"
DH *dh_new_group(BIGNUM *gen___0 , BIGNUM *modulus ) 
{ DH *dh ;

  {
#line 181
  dh = DH_new();
#line 182
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 183
    fatal("DH_new");
  }
#line 184
  dh->p = modulus;
#line 185
  dh->g = gen___0;
#line 187
  return (dh);
}
}
#line 193 "kex.c"
static char *gen  =    (char *)"2";
#line 193 "kex.c"
static char *group1  =    (char *)"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF";
#line 190 "kex.c"
DH *dh_new_group1(void) 
{ DH *tmp ;

  {
#line 201
  tmp = dh_new_group_asc((char const   *)gen, (char const   *)group1);
#line 201
  return (tmp);
}
}
#line 230 "kex.c"
static u_char digest[64]  ;
#line 218 "kex.c"
u_char *kex_hash(char *client_version_string___0 , char *server_version_string___0 ,
                 char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                 char *serverhostkeyblob , int sbloblen , BIGNUM *client_dh_pub ,
                 BIGNUM *server_dh_pub , BIGNUM *shared_secret ) 
{ Buffer b ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  u_int tmp___2 ;
  char *tmp___3 ;

  {
#line 231
  tmp = EVP_sha1();
#line 231
  evp_md = (EVP_MD *)tmp;
#line 234
  buffer_init(& b);
#line 235
  tmp___0 = strlen((char const   *)client_version_string___0);
#line 235
  buffer_put_string(& b, (void const   *)client_version_string___0, tmp___0);
#line 236
  tmp___1 = strlen((char const   *)server_version_string___0);
#line 236
  buffer_put_string(& b, (void const   *)server_version_string___0, tmp___1);
#line 239
  buffer_put_int(& b, (unsigned int )(ckexinitlen + 1));
#line 240
  buffer_put_char(& b, 20);
#line 241
  buffer_append(& b, (char const   *)ckexinit, (unsigned int )ckexinitlen);
#line 242
  buffer_put_int(& b, (unsigned int )(skexinitlen + 1));
#line 243
  buffer_put_char(& b, 20);
#line 244
  buffer_append(& b, (char const   *)skexinit, (unsigned int )skexinitlen);
#line 246
  buffer_put_string(& b, (void const   *)serverhostkeyblob, (unsigned int )sbloblen);
#line 247
  buffer_put_bignum2(& b, client_dh_pub);
#line 248
  buffer_put_bignum2(& b, server_dh_pub);
#line 249
  buffer_put_bignum2(& b, shared_secret);
#line 255
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 256
  tmp___2 = buffer_len(& b);
#line 256
  tmp___3 = buffer_ptr(& b);
#line 256
  EVP_DigestUpdate(& md, (void const   *)tmp___3, tmp___2);
#line 257
  EVP_DigestFinal(& md, digest, (unsigned int *)((void *)0));
#line 259
  buffer_free(& b);
#line 264
  return (digest);
}
}
#line 280 "kex.c"
static u_char digest___0[64]  ;
#line 267 "kex.c"
u_char *kex_hash_gex(char *client_version_string___0 , char *server_version_string___0 ,
                     char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                     char *serverhostkeyblob , int sbloblen , int minbits , BIGNUM *prime ,
                     BIGNUM *gen___0 , BIGNUM *client_dh_pub , BIGNUM *server_dh_pub ,
                     BIGNUM *shared_secret ) 
{ Buffer b ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  u_int tmp___2 ;
  char *tmp___3 ;

  {
#line 281
  tmp = EVP_sha1();
#line 281
  evp_md = (EVP_MD *)tmp;
#line 284
  buffer_init(& b);
#line 285
  tmp___0 = strlen((char const   *)client_version_string___0);
#line 285
  buffer_put_string(& b, (void const   *)client_version_string___0, tmp___0);
#line 286
  tmp___1 = strlen((char const   *)server_version_string___0);
#line 286
  buffer_put_string(& b, (void const   *)server_version_string___0, tmp___1);
#line 289
  buffer_put_int(& b, (unsigned int )(ckexinitlen + 1));
#line 290
  buffer_put_char(& b, 20);
#line 291
  buffer_append(& b, (char const   *)ckexinit, (unsigned int )ckexinitlen);
#line 292
  buffer_put_int(& b, (unsigned int )(skexinitlen + 1));
#line 293
  buffer_put_char(& b, 20);
#line 294
  buffer_append(& b, (char const   *)skexinit, (unsigned int )skexinitlen);
#line 296
  buffer_put_string(& b, (void const   *)serverhostkeyblob, (unsigned int )sbloblen);
#line 297
  buffer_put_int(& b, (unsigned int )minbits);
#line 298
  buffer_put_bignum2(& b, prime);
#line 299
  buffer_put_bignum2(& b, gen___0);
#line 300
  buffer_put_bignum2(& b, client_dh_pub);
#line 301
  buffer_put_bignum2(& b, server_dh_pub);
#line 302
  buffer_put_bignum2(& b, shared_secret);
#line 308
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 309
  tmp___2 = buffer_len(& b);
#line 309
  tmp___3 = buffer_ptr(& b);
#line 309
  EVP_DigestUpdate(& md, (void const   *)tmp___3, tmp___2);
#line 310
  EVP_DigestFinal(& md, digest___0, (unsigned int *)((void *)0));
#line 312
  buffer_free(& b);
#line 317
  return (digest___0);
}
}
#line 320 "kex.c"
u_char *derive_key(int id , int need , u_char *hash , BIGNUM *shared_secret ) 
{ Buffer b ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  char c ;
  int have ;
  int mdsz ;
  u_char *digest___1 ;
  void *tmp___0 ;
  u_int tmp___1 ;
  char *tmp___2 ;
  u_int tmp___3 ;
  char *tmp___4 ;

  {
#line 324
  tmp = EVP_sha1();
#line 324
  evp_md = (EVP_MD *)tmp;
#line 326
  c = (char )id;
#line 328
  mdsz = evp_md->md_size;
#line 329
  tmp___0 = xmalloc((unsigned int )((((need + mdsz) - 1) / mdsz) * mdsz));
#line 329
  digest___1 = (u_char *)tmp___0;
#line 331
  buffer_init(& b);
#line 332
  buffer_put_bignum2(& b, shared_secret);
#line 334
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 335
  tmp___1 = buffer_len(& b);
#line 335
  tmp___2 = buffer_ptr(& b);
#line 335
  EVP_DigestUpdate(& md, (void const   *)tmp___2, tmp___1);
#line 336
  EVP_DigestUpdate(& md, (void const   *)hash, (unsigned int )mdsz);
#line 337
  EVP_DigestUpdate(& md, (void const   *)(& c), 1U);
#line 338
  EVP_DigestUpdate(& md, (void const   *)hash, (unsigned int )mdsz);
#line 339
  EVP_DigestFinal(& md, digest___1, (unsigned int *)((void *)0));
#line 342
  have = mdsz;
#line 342
  while (need > have) {
#line 343
    EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 344
    tmp___3 = buffer_len(& b);
#line 344
    tmp___4 = buffer_ptr(& b);
#line 344
    EVP_DigestUpdate(& md, (void const   *)tmp___4, tmp___3);
#line 345
    EVP_DigestUpdate(& md, (void const   *)hash, (unsigned int )mdsz);
#line 346
    EVP_DigestUpdate(& md, (void const   *)digest___1, (unsigned int )have);
#line 347
    EVP_DigestFinal(& md, digest___1 + have, (unsigned int *)((void *)0));
#line 342
    have += mdsz;
  }
#line 349
  buffer_free(& b);
#line 354
  return (digest___1);
}
}
#line 362 "kex.c"
char *get_match(char *client , char *server ) 
{ char *sproposals[20] ;
  char *c ;
  char *s ;
  char *p ;
  char *ret ;
  char *cp ;
  char *sp ;
  int i ;
  int j ;
  int nproposals ;
  char *tmp___14 ;
  char *tmp___30 ;
  char *tmp___46 ;
  char *tmp___62 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___68 ;
  int tmp___71 ;
  int tmp___72 ;

  {
#line 369
  cp = xstrdup((char const   *)client);
#line 369
  c = cp;
#line 370
  sp = xstrdup((char const   *)server);
#line 370
  s = sp;
#line 372
  tmp___14 = __strsep_g(& sp, ",");
#line 372
  p = tmp___14;
#line 372
  i = 0;
#line 372
  while (1) {
#line 372
    if (p) {
#line 372
      if (! ((int )*p != 0)) {
#line 372
        break;
      }
    } else {
#line 372
      break;
    }
#line 374
    if (i < 20) {
#line 375
      sproposals[i] = p;
    } else {
#line 377
      break;
    }
#line 373
    tmp___30 = __strsep_g(& sp, ",");
#line 373
    p = tmp___30;
#line 373
    i ++;
  }
#line 379
  nproposals = i;
#line 381
  tmp___46 = __strsep_g(& cp, ",");
#line 381
  p = tmp___46;
#line 381
  i = 0;
#line 381
  while (1) {
#line 381
    if (p) {
#line 381
      if (! ((int )*p != 0)) {
#line 381
        break;
      }
    } else {
#line 381
      break;
    }
#line 383
    j = 0;
#line 383
    while (j < nproposals) {
#line 384
      if (0) {
#line 384
        __s1_len = strlen((char const   *)p);
#line 384
        __s2_len = strlen((char const   *)sproposals[j]);
#line 384
        if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
          goto _L___0;
        } else {
#line 384
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 384
            if (! ((unsigned int )((void const   *)(sproposals[j] + 1)) - (unsigned int )((void const   *)sproposals[j]) == 1U)) {
#line 384
              tmp___72 = 1;
            } else {
#line 384
              if (__s2_len >= 4U) {
#line 384
                tmp___72 = 1;
              } else {
#line 384
                tmp___72 = 0;
              }
            }
          } else {
#line 384
            tmp___72 = 0;
          }
        }
#line 384
        if (tmp___72) {
#line 384
          tmp___68 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
        } else {
#line 384
          tmp___71 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
#line 384
          tmp___68 = tmp___71;
        }
      } else {
#line 384
        tmp___71 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
#line 384
        tmp___68 = tmp___71;
      }
#line 384
      if (tmp___68 == 0) {
#line 385
        ret = xstrdup((char const   *)p);
#line 386
        xfree((void *)c);
#line 387
        xfree((void *)s);
#line 388
        return (ret);
      }
#line 383
      j ++;
    }
#line 382
    tmp___62 = __strsep_g(& cp, ",");
#line 382
    p = tmp___62;
#line 382
    i ++;
  }
#line 392
  xfree((void *)c);
#line 393
  xfree((void *)s);
#line 394
  return ((char *)((void *)0));
}
}
#line 396 "kex.c"
void choose_enc(Enc *enc , char *client , char *server ) 
{ char *name ;
  char *tmp ;

  {
#line 399
  tmp = get_match(client, server);
#line 399
  name = tmp;
#line 400
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 401
    fatal("no matching cipher found: client %s server %s", client, server);
  }
#line 402
  enc->cipher = cipher_by_name((char const   *)name);
#line 403
  if ((unsigned int )enc->cipher == (unsigned int )((void *)0)) {
#line 404
    fatal("matching cipher is not supported: %s", name);
  }
#line 405
  enc->name = name;
#line 406
  enc->enabled = 0;
#line 407
  enc->iv = (u_char *)((void *)0);
#line 408
  enc->key = (u_char *)((void *)0);
#line 409
  return;
}
}
#line 410 "kex.c"
void choose_mac(Mac *mac , char *client , char *server ) 
{ char *name ;
  char *tmp ;
  int tmp___0 ;

  {
#line 413
  tmp = get_match(client, server);
#line 413
  name = tmp;
#line 414
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 415
    fatal("no matching mac found: client %s server %s", client, server);
  }
#line 416
  tmp___0 = mac_init(mac, name);
#line 416
  if (tmp___0 < 0) {
#line 417
    fatal("unsupported mac %s", name);
  }
#line 419
  if (datafellows & 4) {
#line 420
    mac->key_len = 16;
  }
#line 421
  mac->name = name;
#line 422
  mac->key = (u_char *)((void *)0);
#line 423
  mac->enabled = 0;
#line 424
  return;
}
}
#line 425 "kex.c"
void choose_comp(Comp *comp , char *client , char *server ) 
{ char *name ;
  char *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 428
  tmp = get_match(client, server);
#line 428
  name = tmp;
#line 429
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 430
    fatal("no matching comp found: client %s server %s", client, server);
  }
#line 431
  if (0) {
#line 431
    __s1_len___0 = strlen((char const   *)name);
#line 431
    __s2_len___0 = strlen("zlib");
#line 431
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___2;
    } else {
#line 431
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 431
        if (! ((unsigned int )((void const   *)("zlib" + 1)) - (unsigned int )((void const   *)"zlib") == 1U)) {
#line 431
          tmp___19 = 1;
        } else {
#line 431
          if (__s2_len___0 >= 4U) {
#line 431
            tmp___19 = 1;
          } else {
#line 431
            tmp___19 = 0;
          }
        }
      } else {
#line 431
        tmp___19 = 0;
      }
    }
#line 431
    if (tmp___19) {
#line 431
      tmp___15 = __builtin_strcmp((char const   *)name, "zlib");
    } else {
#line 431
      tmp___18 = __builtin_strcmp((char const   *)name, "zlib");
#line 431
      tmp___15 = tmp___18;
    }
  } else {
#line 431
    tmp___18 = __builtin_strcmp((char const   *)name, "zlib");
#line 431
    tmp___15 = tmp___18;
  }
#line 431
  if (tmp___15 == 0) {
#line 432
    comp->type = 1;
  } else {
#line 433
    if (0) {
#line 433
      __s1_len = strlen((char const   *)name);
#line 433
      __s2_len = strlen("none");
#line 433
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___0;
      } else {
#line 433
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 433
          if (! ((unsigned int )((void const   *)("none" + 1)) - (unsigned int )((void const   *)"none") == 1U)) {
#line 433
            tmp___9 = 1;
          } else {
#line 433
            if (__s2_len >= 4U) {
#line 433
              tmp___9 = 1;
            } else {
#line 433
              tmp___9 = 0;
            }
          }
        } else {
#line 433
          tmp___9 = 0;
        }
      }
#line 433
      if (tmp___9) {
#line 433
        tmp___5 = __builtin_strcmp((char const   *)name, "none");
      } else {
#line 433
        tmp___8 = __builtin_strcmp((char const   *)name, "none");
#line 433
        tmp___5 = tmp___8;
      }
    } else {
#line 433
      tmp___8 = __builtin_strcmp((char const   *)name, "none");
#line 433
      tmp___5 = tmp___8;
    }
#line 433
    if (tmp___5 == 0) {
#line 434
      comp->type = 0;
    } else {
#line 436
      fatal("unsupported comp %s", name);
    }
  }
#line 438
  comp->name = name;
#line 439
  return;
}
}
#line 440 "kex.c"
void choose_kex(Kex *k , char *client , char *server ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 443
  k->name = get_match(client, server);
#line 444
  if ((unsigned int )k->name == (unsigned int )((void *)0)) {
#line 445
    fatal("no kex alg");
  }
#line 446
  if (0) {
#line 446
    __s1_len___0 = strlen((char const   *)k->name);
#line 446
    __s2_len___0 = strlen("diffie-hellman-group1-sha1");
#line 446
    if (! ((unsigned int )((void const   *)(k->name + 1)) - (unsigned int )((void const   *)k->name) == 1U)) {
      goto _L___2;
    } else {
#line 446
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 446
        if (! ((unsigned int )((void const   *)("diffie-hellman-group1-sha1" + 1)) - (unsigned int )((void const   *)"diffie-hellman-group1-sha1") == 1U)) {
#line 446
          tmp___18 = 1;
        } else {
#line 446
          if (__s2_len___0 >= 4U) {
#line 446
            tmp___18 = 1;
          } else {
#line 446
            tmp___18 = 0;
          }
        }
      } else {
#line 446
        tmp___18 = 0;
      }
    }
#line 446
    if (tmp___18) {
#line 446
      tmp___14 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
    } else {
#line 446
      tmp___17 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
#line 446
      tmp___14 = tmp___17;
    }
  } else {
#line 446
    tmp___17 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
#line 446
    tmp___14 = tmp___17;
  }
#line 446
  if (tmp___14 == 0) {
#line 447
    k->kex_type = 0;
  } else {
#line 448
    if (0) {
#line 448
      __s1_len = strlen((char const   *)k->name);
#line 448
      __s2_len = strlen("diffie-hellman-group-exchange-sha1");
#line 448
      if (! ((unsigned int )((void const   *)(k->name + 1)) - (unsigned int )((void const   *)k->name) == 1U)) {
        goto _L___0;
      } else {
#line 448
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 448
          if (! ((unsigned int )((void const   *)("diffie-hellman-group-exchange-sha1" + 1)) - (unsigned int )((void const   *)"diffie-hellman-group-exchange-sha1") == 1U)) {
#line 448
            tmp___8 = 1;
          } else {
#line 448
            if (__s2_len >= 4U) {
#line 448
              tmp___8 = 1;
            } else {
#line 448
              tmp___8 = 0;
            }
          }
        } else {
#line 448
          tmp___8 = 0;
        }
      }
#line 448
      if (tmp___8) {
#line 448
        tmp___4 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha1");
      } else {
#line 448
        tmp___7 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha1");
#line 448
        tmp___4 = tmp___7;
      }
    } else {
#line 448
      tmp___7 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha1");
#line 448
      tmp___4 = tmp___7;
    }
#line 448
    if (tmp___4 == 0) {
#line 449
      k->kex_type = 1;
    } else {
#line 451
      fatal("bad kex alg %s", k->name);
    }
  }
#line 452
  return;
}
}
#line 453 "kex.c"
void choose_hostkeyalg(Kex *k , char *client , char *server ) 
{ char *hostkeyalg ;
  char *tmp ;

  {
#line 456
  tmp = get_match(client, server);
#line 456
  hostkeyalg = tmp;
#line 457
  if ((unsigned int )hostkeyalg == (unsigned int )((void *)0)) {
#line 458
    fatal("no hostkey alg");
  }
#line 459
  k->hostkey_type = key_type_from_name(hostkeyalg);
#line 460
  if (k->hostkey_type == 3) {
#line 461
    fatal("bad hostkey alg \'%s\'", hostkeyalg);
  }
#line 462
  xfree((void *)hostkeyalg);
#line 463
  return;
}
}
#line 465 "kex.c"
Kex *kex_choose_conf(char **cprop , char **sprop , int server ) 
{ int mode ;
  int ctos ;
  int need ;
  Kex *k ;
  void *tmp ;
  int nenc ;
  int nmac ;
  int ncomp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 473
  tmp = xmalloc(sizeof(*k));
#line 473
  k = (Kex *)tmp;
#line 474
  memset((void *)k, 0, sizeof(*k));
#line 475
  k->server = server;
#line 477
  mode = 0;
#line 477
  while (mode < 2) {
#line 479
    if (! k->server) {
#line 479
      if (mode == 1) {
#line 479
        tmp___0 = 1;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 479
      if (k->server) {
#line 479
        if (mode == 0) {
#line 479
          tmp___0 = 1;
        } else {
#line 479
          tmp___0 = 0;
        }
      } else {
#line 479
        tmp___0 = 0;
      }
    }
#line 479
    ctos = tmp___0;
#line 480
    if (ctos) {
#line 480
      nenc = 2;
    } else {
#line 480
      nenc = 3;
    }
#line 481
    if (ctos) {
#line 481
      nmac = 4;
    } else {
#line 481
      nmac = 5;
    }
#line 482
    if (ctos) {
#line 482
      ncomp = 6;
    } else {
#line 482
      ncomp = 7;
    }
#line 483
    choose_enc(& k->enc[mode], *(cprop + nenc), *(sprop + nenc));
#line 484
    choose_mac(& k->mac[mode], *(cprop + nmac), *(sprop + nmac));
#line 485
    choose_comp(& k->comp[mode], *(cprop + ncomp), *(sprop + ncomp));
#line 486
    if (ctos) {
#line 486
      tmp___1 = "client->server";
    } else {
#line 486
      tmp___1 = "server->client";
    }
#line 486
    debug("kex: %s %s %s %s", tmp___1, k->enc[mode].name, k->mac[mode].name, k->comp[mode].name);
#line 477
    mode ++;
  }
#line 492
  choose_kex(k, *(cprop + 0), *(sprop + 0));
#line 493
  choose_hostkeyalg(k, *(cprop + 1), *(sprop + 1));
#line 495
  need = 0;
#line 496
  mode = 0;
#line 496
  while (mode < 2) {
#line 497
    if ((u_int )need < (k->enc[mode].cipher)->key_len) {
#line 498
      need = (int )(k->enc[mode].cipher)->key_len;
    }
#line 499
    if ((u_int )need < (k->enc[mode].cipher)->block_size) {
#line 500
      need = (int )(k->enc[mode].cipher)->block_size;
    }
#line 501
    if (need < k->mac[mode].key_len) {
#line 502
      need = k->mac[mode].key_len;
    }
#line 496
    mode ++;
  }
#line 505
  k->we_need = need;
#line 506
  return (k);
}
}
#line 509 "kex.c"
int kex_derive_keys(Kex *k , u_char *hash , BIGNUM *shared_secret ) 
{ int i ;
  int mode ;
  int ctos ;
  u_char *keys[6] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 517
  i = 0;
#line 517
  while (i < 6) {
#line 518
    keys[i] = derive_key(65 + i, k->we_need, hash, shared_secret);
#line 517
    i ++;
  }
#line 520
  mode = 0;
#line 520
  while (mode < 2) {
#line 521
    if (! k->server) {
#line 521
      if (mode == 1) {
#line 521
        tmp = 1;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 521
      if (k->server) {
#line 521
        if (mode == 0) {
#line 521
          tmp = 1;
        } else {
#line 521
          tmp = 0;
        }
      } else {
#line 521
        tmp = 0;
      }
    }
#line 521
    ctos = tmp;
#line 522
    if (ctos) {
#line 522
      tmp___0 = 0;
    } else {
#line 522
      tmp___0 = 1;
    }
#line 522
    k->enc[mode].iv = keys[tmp___0];
#line 523
    if (ctos) {
#line 523
      tmp___1 = 2;
    } else {
#line 523
      tmp___1 = 3;
    }
#line 523
    k->enc[mode].key = keys[tmp___1];
#line 524
    if (ctos) {
#line 524
      tmp___2 = 4;
    } else {
#line 524
      tmp___2 = 5;
    }
#line 524
    k->mac[mode].key = keys[tmp___2];
#line 520
    mode ++;
  }
#line 526
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 1 "log.o"
#pragma merger(0,"./log.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 646 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 50 "log.h"
void do_log(LogLevel level , char const   *fmt , va_list args ) ;
#line 53
SyslogFacility log_facility_number(char *name ) ;
#line 54
LogLevel log_level_number(char *name ) ;
#line 76
void fatal_remove_cleanup(void (*proc)(void *context ) , void *context ) ;
#line 46 "log.c"
void ( /* format attribute */  fatal)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 50
  __builtin_va_start(args, fmt);
#line 51
  do_log(1, fmt, args);
#line 52
  __builtin_va_end(args);
#line 53
  fatal_cleanup();
#line 54
  return;
}
}
#line 58 "log.c"
void ( /* format attribute */  error)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 62
  __builtin_va_start(args, fmt);
#line 63
  do_log(2, fmt, args);
#line 64
  __builtin_va_end(args);
#line 65
  return;
}
}
#line 69 "log.c"
void ( /* format attribute */  log)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 73
  __builtin_va_start(args, fmt);
#line 74
  do_log(3, fmt, args);
#line 75
  __builtin_va_end(args);
#line 76
  return;
}
}
#line 80 "log.c"
void ( /* format attribute */  verbose)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 84
  __builtin_va_start(args, fmt);
#line 85
  do_log(4, fmt, args);
#line 86
  __builtin_va_end(args);
#line 87
  return;
}
}
#line 91 "log.c"
void ( /* format attribute */  debug)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 95
  __builtin_va_start(args, fmt);
#line 96
  do_log(5, fmt, args);
#line 97
  __builtin_va_end(args);
#line 98
  return;
}
}
#line 100 "log.c"
void ( /* format attribute */  debug2)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 104
  __builtin_va_start(args, fmt);
#line 105
  do_log(6, fmt, args);
#line 106
  __builtin_va_end(args);
#line 107
  return;
}
}
#line 109 "log.c"
void ( /* format attribute */  debug3)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 113
  __builtin_va_start(args, fmt);
#line 114
  do_log(7, fmt, args);
#line 115
  __builtin_va_end(args);
#line 116
  return;
}
}
#line 126 "log.c"
static struct fatal_cleanup *fatal_cleanups  =    (struct fatal_cleanup *)((void *)0);
#line 130 "log.c"
void fatal_add_cleanup(void (*proc)(void *context ) , void *context ) 
{ struct fatal_cleanup *cu ;
  void *tmp ;

  {
#line 135
  tmp = xmalloc(sizeof(*cu));
#line 135
  cu = (struct fatal_cleanup *)tmp;
#line 136
  cu->proc = proc;
#line 137
  cu->context = context;
#line 138
  cu->next = fatal_cleanups;
#line 139
  fatal_cleanups = cu;
#line 140
  return;
}
}
#line 144 "log.c"
void fatal_remove_cleanup(void (*proc)(void *context ) , void *context ) 
{ struct fatal_cleanup **cup ;
  struct fatal_cleanup *cu ;

  {
#line 149
  cup = & fatal_cleanups;
#line 149
  while (*cup) {
#line 150
    cu = *cup;
#line 151
    if ((unsigned int )cu->proc == (unsigned int )proc) {
#line 151
      if ((unsigned int )cu->context == (unsigned int )context) {
#line 152
        *cup = cu->next;
#line 153
        xfree((void *)cu);
#line 154
        return;
      }
    }
#line 149
    cup = & cu->next;
  }
#line 157
  fatal("fatal_remove_cleanup: no such cleanup function: 0x%lx 0x%lx\n", (unsigned long )proc,
        (unsigned long )context);
#line 159
  return;
}
}
#line 166 "log.c"
static int called  =    0;
#line 162 "log.c"
void fatal_cleanup(void) 
{ struct fatal_cleanup *cu ;
  struct fatal_cleanup *next_cu ;

  {
#line 168
  if (called) {
#line 169
    exit(255);
  }
#line 170
  called = 1;
#line 172
  cu = fatal_cleanups;
#line 172
  while (cu) {
#line 173
    next_cu = cu->next;
#line 174
    debug("Calling cleanup 0x%lx(0x%lx)", (unsigned long )cu->proc, (unsigned long )cu->context);
#line 176
    (*(cu->proc))(cu->context);
#line 172
    cu = next_cu;
  }
#line 178
  exit(255);
}
}
#line 183 "log.c"
static struct __anonstruct_log_facilities_64 log_facilities[12]  = 
#line 183
  {      {"DAEMON", 0}, 
        {"USER", 1}, 
        {"AUTH", 2}, 
        {"LOCAL0", 3}, 
        {"LOCAL1", 4}, 
        {"LOCAL2", 5}, 
        {"LOCAL3", 6}, 
        {"LOCAL4", 7}, 
        {"LOCAL5", 8}, 
        {"LOCAL6", 9}, 
        {"LOCAL7", 10}, 
        {(char const   *)((void *)0), (SyslogFacility )0}};
#line 204 "log.c"
static struct __anonstruct_log_levels_65 log_levels[10]  = 
#line 204
  {      {"QUIET", 0}, 
        {"FATAL", 1}, 
        {"ERROR", 2}, 
        {"INFO", 3}, 
        {"VERBOSE", 4}, 
        {"DEBUG", 5}, 
        {"DEBUG1", 5}, 
        {"DEBUG2", 6}, 
        {"DEBUG3", 7}, 
        {(char const   *)((void *)0), (LogLevel )0}};
#line 221 "log.c"
SyslogFacility log_facility_number(char *name ) 
{ int i ;
  int tmp ;

  {
#line 225
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 226
    i = 0;
#line 226
    while (log_facilities[i].name) {
#line 227
      tmp = strcasecmp(log_facilities[i].name, (char const   *)name);
#line 227
      if (tmp == 0) {
#line 228
        return (log_facilities[i].val);
      }
#line 226
      i ++;
    }
  }
#line 229
  return ((int )-1);
}
}
#line 232 "log.c"
LogLevel log_level_number(char *name ) 
{ int i ;
  int tmp ;

  {
#line 236
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 237
    i = 0;
#line 237
    while (log_levels[i].name) {
#line 238
      tmp = strcasecmp(log_levels[i].name, (char const   *)name);
#line 238
      if (tmp == 0) {
#line 239
        return (log_levels[i].val);
      }
#line 237
      i ++;
    }
  }
#line 240
  return ((enum __anonenum_LogLevel_63 )-1);
}
}
#line 1 "match.o"
#pragma merger(0,"./match.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 116 "/usr/include/ctype.h"
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 23 "match.h"
int match_pattern(char const   *s , char const   *pattern ) ;
#line 24 "match.c"
int match_pattern(char const   *s , char const   *pattern ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 27
  while (1) {
#line 29
    if (! *pattern) {
#line 30
      return (! *s);
    }
#line 32
    if ((int const   )*pattern == 42) {
#line 34
      pattern ++;
#line 37
      if (! *pattern) {
#line 38
        return (1);
      }
#line 41
      if ((int const   )*pattern != 63) {
#line 41
        if ((int const   )*pattern != 42) {
#line 47
          while (*s) {
#line 48
            if ((int const   )*s == (int const   )*pattern) {
#line 48
              tmp = match_pattern(s + 1, pattern + 1);
#line 48
              if (tmp) {
#line 50
                return (1);
              }
            }
#line 47
            s ++;
          }
#line 52
          return (0);
        }
      }
#line 58
      while (*s) {
#line 59
        tmp___0 = match_pattern(s, pattern);
#line 59
        if (tmp___0) {
#line 60
          return (1);
        }
#line 58
        s ++;
      }
#line 62
      return (0);
    }
#line 68
    if (! *s) {
#line 69
      return (0);
    }
#line 72
    if ((int const   )*pattern != 63) {
#line 72
      if ((int const   )*pattern != (int const   )*s) {
#line 73
        return (0);
      }
    }
#line 76
    s ++;
#line 77
    pattern ++;
  }
}
}
#line 89 "match.c"
int match_hostname(char const   *host , char const   *pattern , u_int len ) 
{ char sub[1024] ;
  int negated ;
  int got_positive ;
  u_int i ;
  u_int subi ;
  int __res___0 ;
  __int32_t const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;

  {
#line 97
  got_positive = 0;
#line 98
  i = 0U;
#line 98
  while (i < len) {
#line 100
    if ((int const   )*(pattern + i) == 33) {
#line 101
      negated = 1;
#line 102
      i ++;
    } else {
#line 104
      negated = 0;
    }
#line 110
    subi = 0U;
#line 110
    while (1) {
#line 110
      if (i < len) {
#line 110
        if (subi < sizeof(sub) - 1U) {
#line 110
          if (! ((int const   )*(pattern + i) != 44)) {
#line 110
            break;
          }
        } else {
#line 110
          break;
        }
      } else {
#line 110
        break;
      }
#line 113
      tmp___6 = __ctype_b_loc();
#line 113
      if ((int const   )*(*tmp___6 + (int )*(pattern + i)) & 256) {
#line 113
        if (sizeof(*(pattern + i)) > 1U) {
#line 113
          __res___0 = tolower((int )*(pattern + i));
        } else {
#line 113
          tmp___5 = __ctype_tolower_loc();
#line 113
          __res___0 = (int )*(*tmp___5 + (int )*(pattern + i));
        }
#line 113
        sub[subi] = (char )__res___0;
      } else {
#line 113
        sub[subi] = (char )*(pattern + i);
      }
#line 110
      subi ++;
#line 110
      i ++;
    }
#line 115
    if (subi >= sizeof(sub) - 1U) {
#line 116
      return (0);
    }
#line 119
    if (i < len) {
#line 119
      if ((int const   )*(pattern + i) == 44) {
#line 120
        i ++;
      }
    }
#line 123
    sub[subi] = (char )'\000';
#line 126
    tmp___7 = match_pattern(host, (char const   *)(sub));
#line 126
    if (tmp___7) {
#line 127
      if (negated) {
#line 128
        return (-1);
      } else {
#line 130
        got_positive = 1;
      }
    }
  }
#line 138
  return (got_positive);
}
}
/* compiler builtin: 
   char *__builtin_strpbrk(char const   * , char const   * ) ;  */
/* compiler builtin: 
   unsigned int __builtin_strspn(char const   * , char const   * ) ;  */
#line 1 "misc.o"
#pragma merger(0,"./misc.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 15 "misc.h"
char *chop(char *s ) ;
#line 18
char *strdelim(char **s ) ;
#line 25
mysig_t mysignal(int sig , void (*act)(int  ) ) ;
#line 33 "misc.c"
char *chop(char *s ) 
{ char *t ;

  {
#line 36
  t = s;
#line 37
  while (*t) {
#line 38
    if ((int )*t == 10) {
#line 39
      *t = (char )'\000';
#line 40
      return (s);
    } else {
#line 38
      if ((int )*t == 13) {
#line 39
        *t = (char )'\000';
#line 40
        return (s);
      }
    }
#line 42
    t ++;
  }
#line 44
  return (s);
}
}
#line 48 "misc.c"
void set_nonblock(int fd ) 
{ int val ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
#line 52
  val = fcntl(fd, 3, 0);
#line 53
  if (val < 0) {
#line 54
    tmp = __errno_location();
#line 54
    tmp___0 = strerror(*tmp);
#line 54
    error("fcntl(%d, F_GETFL, 0): %s", fd, tmp___0);
#line 55
    return;
  }
#line 57
  if (val & 2048) {
#line 58
    debug("fd %d IS O_NONBLOCK", fd);
#line 59
    return;
  }
#line 61
  debug("fd %d setting O_NONBLOCK", fd);
#line 62
  val |= 2048;
#line 63
  tmp___4 = fcntl(fd, 4, val);
#line 63
  if (tmp___4 == -1) {
#line 64
    tmp___3 = __errno_location();
#line 64
    if (*tmp___3 != 19) {
#line 65
      tmp___1 = __errno_location();
#line 65
      tmp___2 = strerror(*tmp___1);
#line 65
      error("fcntl(%d, F_SETFL, O_NONBLOCK): %s", fd, tmp___2);
    }
  }
#line 67
  return;
}
}
#line 72 "misc.c"
char *strdelim(char **s ) 
{ char *old ;
  int wspace ;
  char *tmp___30 ;
  unsigned int tmp___62 ;
  unsigned int tmp___94 ;

  {
#line 76
  wspace = 0;
#line 78
  if ((unsigned int )*s == (unsigned int )((void *)0)) {
#line 79
    return ((char *)((void *)0));
  }
#line 81
  old = *s;
#line 83
  tmp___30 = __builtin_strpbrk((char const   *)*s, " \t\r\n=");
#line 83
  *s = tmp___30;
#line 84
  if ((unsigned int )*s == (unsigned int )((void *)0)) {
#line 85
    return (old);
  }
#line 88
  if ((int )*(*(s + 0)) == 61) {
#line 89
    wspace = 1;
  }
#line 90
  *(*(s + 0)) = (char )'\000';
#line 92
  tmp___62 = __builtin_strspn((char const   *)(*s + 1), " \t\r\n");
#line 92
  *s += tmp___62 + 1U;
#line 93
  if ((int )*(*(s + 0)) == 61) {
#line 93
    if (! wspace) {
#line 94
      tmp___94 = __builtin_strspn((char const   *)(*s + 1), " \t\r\n");
#line 94
      *s += tmp___94 + 1U;
    }
  }
#line 96
  return (old);
}
}
#line 99 "misc.c"
mysig_t mysignal(int sig , void (*act)(int  ) ) 
{ struct sigaction sa ;
  struct sigaction osa___0 ;
  int tmp ;
  int tmp___0 ;

  {
#line 105
  tmp = sigaction(sig, (struct sigaction  const  * __restrict  )((void *)0), (struct sigaction * __restrict  )(& osa___0));
#line 105
  if (tmp == -1) {
#line 106
    return ((void (*)(int  ))-1);
  }
#line 107
  if ((unsigned int )osa___0.__sigaction_handler.sa_handler != (unsigned int )act) {
#line 108
    memset((void *)(& sa), 0, sizeof(sa));
#line 109
    sigemptyset(& sa.sa_mask);
#line 110
    sa.sa_flags = 0;
#line 112
    if (sig == 17) {
#line 113
      sa.sa_flags |= 268435456;
    }
#line 116
    if (sig == 14) {
#line 117
      sa.sa_flags |= 536870912;
    }
#line 119
    sa.__sigaction_handler.sa_handler = act;
#line 120
    tmp___0 = sigaction(sig, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
#line 120
    if (tmp___0 == -1) {
#line 121
      return ((void (*)(int  ))-1);
    }
  }
#line 123
  return (osa___0.__sigaction_handler.sa_handler);
}
}
#line 1 "mpaux.o"
#pragma merger(0,"./mpaux.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 25 "mpaux.h"
void compute_session_id(u_char *session_id___0 , u_char *cookie , BIGNUM *host_key_n ,
                        BIGNUM *session_key_n ) ;
#line 26 "mpaux.c"
void compute_session_id(u_char *session_id___0 , u_char *cookie , BIGNUM *host_key_n ,
                        BIGNUM *session_key_n ) 
{ u_int host_key_bytes ;
  int tmp ;
  u_int session_key_bytes ;
  int tmp___0 ;
  u_int bytes ;
  u_char *buf___2 ;
  void *tmp___1 ;
  MD5_CTX md ;

  {
#line 32
  tmp = BN_num_bits((BIGNUM const   *)host_key_n);
#line 32
  host_key_bytes = (u_int )((tmp + 7) / 8);
#line 33
  tmp___0 = BN_num_bits((BIGNUM const   *)session_key_n);
#line 33
  session_key_bytes = (u_int )((tmp___0 + 7) / 8);
#line 34
  bytes = host_key_bytes + session_key_bytes;
#line 35
  tmp___1 = xmalloc(bytes);
#line 35
  buf___2 = (u_char *)tmp___1;
#line 38
  BN_bn2bin((BIGNUM const   *)host_key_n, buf___2);
#line 39
  BN_bn2bin((BIGNUM const   *)session_key_n, buf___2 + host_key_bytes);
#line 40
  MD5_Init(& md);
#line 41
  MD5_Update(& md, (void const   *)buf___2, bytes);
#line 42
  MD5_Update(& md, (void const   *)cookie, 8U);
#line 43
  MD5_Final((unsigned char *)session_id___0, & md);
#line 44
  memset((void *)buf___2, 0, bytes);
#line 45
  xfree((void *)buf___2);
#line 46
  return;
}
}
#line 1 "nchan.o"
#pragma merger(0,"./nchan.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 42 "nchan.c"
chan_event_fn *chan_rcvd_oclose  =    (chan_event_fn *)((void *)0);
#line 43 "nchan.c"
chan_event_fn *chan_read_failed  =    (chan_event_fn *)((void *)0);
#line 44 "nchan.c"
chan_event_fn *chan_ibuf_empty  =    (chan_event_fn *)((void *)0);
#line 46 "nchan.c"
chan_event_fn *chan_rcvd_ieof  =    (chan_event_fn *)((void *)0);
#line 47 "nchan.c"
chan_event_fn *chan_write_failed  =    (chan_event_fn *)((void *)0);
#line 48 "nchan.c"
chan_event_fn *chan_obuf_empty  =    (chan_event_fn *)((void *)0);
#line 52
static void chan_send_ieof1(Channel *c ) ;
#line 53
static void chan_send_oclose1(Channel *c ) ;
#line 54
static void chan_send_close2(Channel *c ) ;
#line 55
static void chan_send_eof2(Channel *c ) ;
#line 58 "nchan.c"
chan_event_fn *chan_delete_if_full_closed  =    (chan_event_fn *)((void *)0);
#line 61
static void chan_shutdown_write(Channel *c ) ;
#line 62
static void chan_shutdown_read(Channel *c ) ;
#line 68 "nchan.c"
static void chan_rcvd_oclose1(Channel *c ) 
{ 

  {
#line 71
  debug("channel %d: rcvd oclose", c->self);
#line 72
  switch (c->istate) {
  case 4: 
#line 74
  debug("channel %d: input wait_oclose -> closed", c->self);
#line 75
  c->istate = 8;
#line 76
  break;
  case 1: 
#line 78
  debug("channel %d: input open -> closed", c->self);
#line 79
  chan_shutdown_read(c);
#line 80
  chan_send_ieof1(c);
#line 81
  c->istate = 8;
#line 82
  break;
  case 2: 
#line 85
  log("channel %d: input drain -> closed", c->self);
#line 86
  chan_send_ieof1(c);
#line 87
  c->istate = 8;
#line 88
  break;
  default: 
#line 90
  error("channel %d: protocol error: chan_rcvd_oclose for istate %d", c->self, c->istate);
#line 92
  return;
  }
#line 94
  return;
}
}
#line 95 "nchan.c"
static void chan_read_failed_12(Channel *c ) 
{ u_int tmp ;

  {
#line 98
  debug("channel %d: read failed", c->self);
#line 99
  switch (c->istate) {
  case 1: 
#line 101
  debug("channel %d: input open -> drain", c->self);
#line 102
  chan_shutdown_read(c);
#line 103
  c->istate = 2;
#line 104
  tmp = buffer_len(& c->input);
#line 104
  if (tmp == 0U) {
#line 105
    debug("channel %d: input: no drain shortcut", c->self);
#line 106
    (*chan_ibuf_empty)(c);
  }
#line 108
  break;
  default: 
#line 110
  error("channel %d: internal error: we do not read, but chan_read_failed for istate %d",
        c->self, c->istate);
#line 112
  break;
  }
#line 114
  return;
}
}
#line 115 "nchan.c"
static void chan_ibuf_empty1(Channel *c ) 
{ u_int tmp ;

  {
#line 118
  debug("channel %d: ibuf empty", c->self);
#line 119
  tmp = buffer_len(& c->input);
#line 119
  if (tmp) {
#line 120
    error("channel %d: internal error: chan_ibuf_empty for non empty buffer", c->self);
#line 122
    return;
  }
#line 124
  switch (c->istate) {
  case 2: 
#line 126
  debug("channel %d: input drain -> wait_oclose", c->self);
#line 127
  chan_send_ieof1(c);
#line 128
  c->istate = 4;
#line 129
  break;
  default: 
#line 131
  error("channel %d: internal error: chan_ibuf_empty for istate %d", c->self, c->istate);
#line 133
  break;
  }
#line 135
  return;
}
}
#line 136 "nchan.c"
static void chan_rcvd_ieof1(Channel *c ) 
{ 

  {
#line 139
  debug("channel %d: rcvd ieof", c->self);
#line 140
  if (c->type != 4) {
#line 141
    debug("channel %d: non-open", c->self);
#line 142
    if (c->istate == 1) {
#line 143
      debug("channel %d: non-open: input open -> wait_oclose", c->self);
#line 144
      chan_shutdown_read(c);
#line 145
      chan_send_ieof1(c);
#line 146
      c->istate = 4;
    } else {
#line 148
      error("channel %d: istate %d != open", c->self, c->istate);
    }
#line 150
    if (c->ostate == 16) {
#line 151
      debug("channel %d: non-open: output open -> closed", c->self);
#line 152
      chan_send_oclose1(c);
#line 153
      c->ostate = 128;
    } else {
#line 155
      error("channel %d: ostate %d != open", c->self, c->ostate);
    }
#line 157
    return;
  }
#line 159
  switch (c->ostate) {
  case 16: 
#line 161
  debug("channel %d: output open -> drain", c->self);
#line 162
  c->ostate = 32;
#line 163
  break;
  case 64: 
#line 165
  debug("channel %d: output wait_ieof -> closed", c->self);
#line 166
  c->ostate = 128;
#line 167
  break;
  default: 
#line 169
  error("channel %d: protocol error: chan_rcvd_ieof for ostate %d", c->self, c->ostate);
#line 171
  break;
  }
#line 173
  return;
}
}
#line 174 "nchan.c"
static void chan_write_failed1(Channel *c ) 
{ 

  {
#line 177
  debug("channel %d: write failed", c->self);
#line 178
  switch (c->ostate) {
  case 16: 
#line 180
  debug("channel %d: output open -> wait_ieof", c->self);
#line 181
  chan_send_oclose1(c);
#line 182
  c->ostate = 64;
#line 183
  break;
  case 32: 
#line 185
  debug("channel %d: output wait_drain -> closed", c->self);
#line 186
  chan_send_oclose1(c);
#line 187
  c->ostate = 128;
#line 188
  break;
  default: 
#line 190
  error("channel %d: internal error: chan_write_failed for ostate %d", c->self, c->ostate);
#line 192
  break;
  }
#line 194
  return;
}
}
#line 195 "nchan.c"
static void chan_obuf_empty1(Channel *c ) 
{ u_int tmp ;

  {
#line 198
  debug("channel %d: obuf empty", c->self);
#line 199
  tmp = buffer_len(& c->output);
#line 199
  if (tmp) {
#line 200
    error("channel %d: internal error: chan_obuf_empty for non empty buffer", c->self);
#line 202
    return;
  }
#line 204
  switch (c->ostate) {
  case 32: 
#line 206
  debug("channel %d: output drain -> closed", c->self);
#line 207
  chan_send_oclose1(c);
#line 208
  c->ostate = 128;
#line 209
  break;
  default: 
#line 211
  error("channel %d: internal error: chan_obuf_empty for ostate %d", c->self, c->ostate);
#line 213
  break;
  }
#line 215
  return;
}
}
#line 216 "nchan.c"
static void chan_send_ieof1(Channel *c ) 
{ 

  {
#line 219
  debug("channel %d: send ieof", c->self);
#line 220
  switch (c->istate) {
  case 1: 
  case 2: 
#line 223
  packet_start(24);
#line 224
  packet_put_int((unsigned int )c->remote_id);
#line 225
  packet_send();
#line 226
  break;
  default: 
#line 228
  error("channel %d: internal error: cannot send ieof for istate %d", c->self, c->istate);
#line 230
  break;
  }
#line 232
  return;
}
}
#line 233 "nchan.c"
static void chan_send_oclose1(Channel *c ) 
{ u_int tmp ;

  {
#line 236
  debug("channel %d: send oclose", c->self);
#line 237
  switch (c->ostate) {
  case 16: 
  case 32: 
#line 240
  chan_shutdown_write(c);
#line 241
  tmp = buffer_len(& c->output);
#line 241
  buffer_consume(& c->output, tmp);
#line 242
  packet_start(25);
#line 243
  packet_put_int((unsigned int )c->remote_id);
#line 244
  packet_send();
#line 245
  break;
  default: 
#line 247
  error("channel %d: internal error: cannot send oclose for ostate %d", c->self, c->ostate);
#line 249
  break;
  }
#line 251
  return;
}
}
#line 252 "nchan.c"
static void chan_delete_if_full_closed1(Channel *c ) 
{ 

  {
#line 255
  debug3("channel %d: chan_delete_if_full_closed1: istate %d ostate %d", c->self,
         c->istate, c->ostate);
#line 257
  if (c->istate == 8) {
#line 257
    if (c->ostate == 128) {
#line 258
      debug("channel %d: full closed", c->self);
#line 259
      channel_free(c->self);
    }
  }
#line 261
  return;
}
}
#line 266 "nchan.c"
static void chan_rcvd_oclose2(Channel *c ) 
{ 

  {
#line 269
  debug("channel %d: rcvd close", c->self);
#line 270
  if (c->flags & 2) {
#line 271
    error("channel %d: protocol error: close rcvd twice", c->self);
  }
#line 272
  c->flags |= 2;
#line 273
  if (c->type == 10) {
#line 275
    c->ostate = 128;
#line 276
    c->istate = 8;
#line 277
    return;
  }
#line 279
  switch (c->ostate) {
  case 16: 
#line 282
  debug("channel %d: output open -> drain", c->self);
#line 283
  c->ostate = 32;
#line 284
  break;
  }
#line 286
  switch (c->istate) {
  case 1: 
#line 288
  debug("channel %d: input open -> closed", c->self);
#line 289
  chan_shutdown_read(c);
#line 290
  break;
  case 2: 
#line 292
  debug("channel %d: input drain -> closed", c->self);
#line 293
  chan_send_eof2(c);
#line 294
  break;
  }
#line 296
  c->istate = 8;
#line 297
  return;
}
}
#line 298 "nchan.c"
static void chan_ibuf_empty2(Channel *c ) 
{ u_int tmp ;

  {
#line 301
  debug("channel %d: ibuf empty", c->self);
#line 302
  tmp = buffer_len(& c->input);
#line 302
  if (tmp) {
#line 303
    error("channel %d: internal error: chan_ibuf_empty for non empty buffer", c->self);
#line 305
    return;
  }
#line 307
  switch (c->istate) {
  case 2: 
#line 309
  debug("channel %d: input drain -> closed", c->self);
#line 310
  if (! (c->flags & 1)) {
#line 311
    chan_send_eof2(c);
  }
#line 312
  c->istate = 8;
#line 313
  break;
  default: 
#line 315
  error("channel %d: internal error: chan_ibuf_empty for istate %d", c->self, c->istate);
#line 317
  break;
  }
#line 319
  return;
}
}
#line 320 "nchan.c"
static void chan_rcvd_ieof2(Channel *c ) 
{ 

  {
#line 323
  debug("channel %d: rcvd eof", c->self);
#line 324
  if (c->ostate == 16) {
#line 325
    debug("channel %d: output open -> drain", c->self);
#line 326
    c->ostate = 32;
  }
#line 328
  return;
}
}
#line 329 "nchan.c"
static void chan_write_failed2(Channel *c ) 
{ 

  {
#line 332
  debug("channel %d: write failed", c->self);
#line 333
  switch (c->ostate) {
  case 16: 
#line 335
  debug("channel %d: output open -> closed", c->self);
#line 336
  chan_shutdown_write(c);
#line 337
  c->ostate = 128;
#line 338
  break;
  case 32: 
#line 340
  debug("channel %d: output drain -> closed", c->self);
#line 341
  chan_shutdown_write(c);
#line 342
  c->ostate = 128;
#line 343
  break;
  default: 
#line 345
  error("channel %d: internal error: chan_write_failed for ostate %d", c->self, c->ostate);
#line 347
  break;
  }
#line 349
  return;
}
}
#line 350 "nchan.c"
static void chan_obuf_empty2(Channel *c ) 
{ u_int tmp ;

  {
#line 353
  debug("channel %d: obuf empty", c->self);
#line 354
  tmp = buffer_len(& c->output);
#line 354
  if (tmp) {
#line 355
    error("internal error: chan_obuf_empty %d for non empty buffer", c->self);
#line 357
    return;
  }
#line 359
  switch (c->ostate) {
  case 32: 
#line 361
  debug("channel %d: output drain -> closed", c->self);
#line 362
  chan_shutdown_write(c);
#line 363
  c->ostate = 128;
#line 364
  break;
  default: 
#line 366
  error("channel %d: internal error: chan_obuf_empty for ostate %d", c->self, c->ostate);
#line 368
  break;
  }
#line 370
  return;
}
}
#line 371 "nchan.c"
static void chan_send_eof2(Channel *c ) 
{ 

  {
#line 374
  debug("channel %d: send eof", c->self);
#line 375
  switch (c->istate) {
  case 2: 
#line 377
  packet_start(96);
#line 378
  packet_put_int((unsigned int )c->remote_id);
#line 379
  packet_send();
#line 380
  break;
  default: 
#line 382
  error("channel %d: internal error: cannot send eof for istate %d", c->self, c->istate);
#line 384
  break;
  }
#line 386
  return;
}
}
#line 387 "nchan.c"
static void chan_send_close2(Channel *c ) 
{ 

  {
#line 390
  debug("channel %d: send close", c->self);
#line 391
  if (c->ostate != 128) {
#line 393
    error("channel %d: internal error: cannot send close for istate/ostate %d/%d",
          c->self, c->istate, c->ostate);
  } else {
#line 391
    if (c->istate != 8) {
#line 393
      error("channel %d: internal error: cannot send close for istate/ostate %d/%d",
            c->self, c->istate, c->ostate);
    } else {
#line 395
      if (c->flags & 1) {
#line 396
        error("channel %d: internal error: already sent close", c->self);
      } else {
#line 398
        packet_start(97);
#line 399
        packet_put_int((unsigned int )c->remote_id);
#line 400
        packet_send();
#line 401
        c->flags |= 1;
      }
    }
  }
#line 403
  return;
}
}
#line 404 "nchan.c"
static void chan_delete_if_full_closed2(Channel *c ) 
{ 

  {
#line 407
  debug3("channel %d: chan_delete_if_full_closed2: istate %d ostate %d", c->self,
         c->istate, c->ostate);
#line 409
  if (c->istate == 8) {
#line 409
    if (c->ostate == 128) {
#line 410
      if (! (c->flags & 1)) {
#line 411
        chan_send_close2(c);
      }
#line 413
      if (c->flags & 1) {
#line 413
        if (c->flags & 2) {
#line 415
          debug("channel %d: full closed2", c->self);
#line 416
          channel_free(c->self);
        }
      }
    }
  }
#line 419
  return;
}
}
#line 422 "nchan.c"
void chan_init_iostates(Channel *c ) 
{ 

  {
#line 425
  c->ostate = 16;
#line 426
  c->istate = 1;
#line 427
  c->flags = 0;
#line 428
  return;
}
}
#line 431 "nchan.c"
void chan_init(void) 
{ 

  {
#line 434
  if (compat20) {
#line 435
    chan_rcvd_oclose = & chan_rcvd_oclose2;
#line 436
    chan_read_failed = & chan_read_failed_12;
#line 437
    chan_ibuf_empty = & chan_ibuf_empty2;
#line 439
    chan_rcvd_ieof = & chan_rcvd_ieof2;
#line 440
    chan_write_failed = & chan_write_failed2;
#line 441
    chan_obuf_empty = & chan_obuf_empty2;
#line 443
    chan_delete_if_full_closed = & chan_delete_if_full_closed2;
  } else {
#line 445
    chan_rcvd_oclose = & chan_rcvd_oclose1;
#line 446
    chan_read_failed = & chan_read_failed_12;
#line 447
    chan_ibuf_empty = & chan_ibuf_empty1;
#line 449
    chan_rcvd_ieof = & chan_rcvd_ieof1;
#line 450
    chan_write_failed = & chan_write_failed1;
#line 451
    chan_obuf_empty = & chan_obuf_empty1;
#line 453
    chan_delete_if_full_closed = & chan_delete_if_full_closed1;
  }
#line 455
  return;
}
}
#line 458 "nchan.c"
static void chan_shutdown_write(Channel *c ) 
{ u_int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 461
  tmp = buffer_len(& c->output);
#line 461
  buffer_consume(& c->output, tmp);
#line 462
  if (compat20) {
#line 462
    if (c->type == 10) {
#line 463
      return;
    }
  }
#line 465
  debug("channel %d: close_write", c->self);
#line 466
  if (c->sock != -1) {
#line 467
    tmp___2 = shutdown(c->sock, 1);
#line 467
    if (tmp___2 < 0) {
#line 468
      tmp___0 = __errno_location();
#line 468
      tmp___1 = strerror(*tmp___0);
#line 468
      debug("channel %d: chan_shutdown_write: shutdown() failed for fd%d: %.100s",
            c->self, c->sock, tmp___1);
    }
  } else {
#line 471
    tmp___5 = close(c->wfd);
#line 471
    if (tmp___5 < 0) {
#line 472
      tmp___3 = __errno_location();
#line 472
      tmp___4 = strerror(*tmp___3);
#line 472
      log("channel %d: chan_shutdown_write: close() failed for fd%d: %.100s", c->self,
          c->wfd, tmp___4);
    }
#line 474
    c->wfd = -1;
  }
#line 476
  return;
}
}
#line 477 "nchan.c"
static void chan_shutdown_read(Channel *c ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 480
  if (compat20) {
#line 480
    if (c->type == 10) {
#line 481
      return;
    }
  }
#line 482
  debug("channel %d: close_read", c->self);
#line 483
  if (c->sock != -1) {
#line 488
    tmp___1 = shutdown(c->sock, 0);
#line 488
    if (tmp___1 < 0) {
#line 488
      tmp___2 = __errno_location();
#line 488
      if (*tmp___2 != 107) {
#line 492
        tmp = __errno_location();
#line 492
        tmp___0 = strerror(*tmp);
#line 492
        error("channel %d: chan_shutdown_read: shutdown() failed for fd%d [i%d o%d]: %.100s",
              c->self, c->sock, c->istate, c->ostate, tmp___0);
      } else {
#line 488
        if (c->ostate == 16) {
#line 492
          tmp = __errno_location();
#line 492
          tmp___0 = strerror(*tmp);
#line 492
          error("channel %d: chan_shutdown_read: shutdown() failed for fd%d [i%d o%d]: %.100s",
                c->self, c->sock, c->istate, c->ostate, tmp___0);
        } else {
#line 488
          if (c->ostate == 32) {
#line 492
            tmp = __errno_location();
#line 492
            tmp___0 = strerror(*tmp);
#line 492
            error("channel %d: chan_shutdown_read: shutdown() failed for fd%d [i%d o%d]: %.100s",
                  c->self, c->sock, c->istate, c->ostate, tmp___0);
          }
        }
      }
    }
  } else {
#line 495
    tmp___5 = close(c->rfd);
#line 495
    if (tmp___5 < 0) {
#line 496
      tmp___3 = __errno_location();
#line 496
      tmp___4 = strerror(*tmp___3);
#line 496
      log("channel %d: chan_shutdown_read: close() failed for fd%d: %.100s", c->self,
          c->rfd, tmp___4);
    }
#line 498
    c->rfd = -1;
  }
#line 500
  return;
}
}
#line 1 "packet.o"
#pragma merger(0,"./packet.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 361 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 26 "packet.h"
void packet_set_connection(int fd_in , int fd_out ) ;
#line 29
void packet_set_nonblocking(void) ;
#line 35
int packet_get_connection_out(void) ;
#line 41
void packet_close(void) ;
#line 48
void packet_set_encryption_key(u_char const   *key , u_int keylen , int number ) ;
#line 56
void packet_set_protocol_flags(u_int protocol_flags ) ;
#line 59
u_int packet_get_protocol_flags(void) ;
#line 62
void packet_start_compression(int level ) ;
#line 68
void packet_set_interactive(int interactive ) ;
#line 83
void packet_put_bignum(BIGNUM *value ) ;
#line 84
void packet_put_bignum2(BIGNUM *value ) ;
#line 120
void packet_process_incoming(char const   *buf___2 , u_int len ) ;
#line 132
void packet_get_bignum(BIGNUM *value , int *length_ptr ) ;
#line 133
void packet_get_bignum2(BIGNUM *value , int *length_ptr ) ;
#line 165
void packet_write_poll(void) ;
#line 171
int packet_have_data_to_write(void) ;
#line 174
int packet_not_very_much_data_to_write(void) ;
#line 178
int packet_set_maxsize(int s ) ;
#line 209
int packet_connection_is_ipv4(void) ;
#line 212
void packet_set_ssh2_format(void) ;
#line 105 "kex.h"
void packet_set_kex(Kex *k ) ;
#line 75 "packet.c"
static int connection_in  =    -1;
#line 76 "packet.c"
static int connection_out  =    -1;
#line 82 "packet.c"
static int cipher_type  =    0;
#line 85 "packet.c"
static u_int remote_protocol_flags  =    (u_int )0;
#line 88 "packet.c"
static CipherContext receive_context  ;
#line 91 "packet.c"
static CipherContext send_context  ;
#line 94 "packet.c"
static Buffer input  ;
#line 97 "packet.c"
static Buffer output  ;
#line 100 "packet.c"
static Buffer outgoing_packet  ;
#line 103 "packet.c"
static Buffer incoming_packet  ;
#line 106 "packet.c"
static Buffer compression_buffer  ;
#line 109 "packet.c"
static int packet_compression  =    0;
#line 112 "packet.c"
int max_packet_size  =    32768;
#line 115 "packet.c"
static int initialized  =    0;
#line 118 "packet.c"
static int interactive_mode  =    0;
#line 121 "packet.c"
int use_ssh2_packet_format  =    0;
#line 124 "packet.c"
Kex *kex  =    (Kex *)((void *)0);
#line 126 "packet.c"
void packet_set_kex(Kex *k ) 
{ 

  {
#line 129
  if ((unsigned int )k->mac[0].key == (unsigned int )((void *)0)) {
#line 135
    fatal("bad KEX");
  } else {
#line 129
    if ((unsigned int )k->enc[0].key == (unsigned int )((void *)0)) {
#line 135
      fatal("bad KEX");
    } else {
#line 129
      if ((unsigned int )k->enc[0].iv == (unsigned int )((void *)0)) {
#line 135
        fatal("bad KEX");
      } else {
#line 129
        if ((unsigned int )k->mac[1].key == (unsigned int )((void *)0)) {
#line 135
          fatal("bad KEX");
        } else {
#line 129
          if ((unsigned int )k->enc[1].key == (unsigned int )((void *)0)) {
#line 135
            fatal("bad KEX");
          } else {
#line 129
            if ((unsigned int )k->enc[1].iv == (unsigned int )((void *)0)) {
#line 135
              fatal("bad KEX");
            }
          }
        }
      }
    }
  }
#line 136
  kex = k;
#line 137
  return;
}
}
#line 138 "packet.c"
void clear_enc_keys(Enc *enc , int len ) 
{ 

  {
#line 141
  memset((void *)enc->iv, 0, (unsigned int )len);
#line 142
  memset((void *)enc->key, 0, (unsigned int )len);
#line 143
  xfree((void *)enc->iv);
#line 144
  xfree((void *)enc->key);
#line 145
  enc->iv = (u_char *)((void *)0);
#line 146
  enc->key = (u_char *)((void *)0);
#line 147
  return;
}
}
#line 148 "packet.c"
void packet_set_ssh2_format(void) 
{ 

  {
#line 152
  use_ssh2_packet_format = 1;
#line 153
  return;
}
}
#line 159 "packet.c"
void packet_set_connection(int fd_in , int fd_out ) 
{ Cipher *none ;
  Cipher *tmp ;

  {
#line 162
  tmp = cipher_by_name("none");
#line 162
  none = tmp;
#line 163
  if ((unsigned int )none == (unsigned int )((void *)0)) {
#line 164
    fatal("packet_set_connection: cannot load cipher \'none\'");
  }
#line 165
  connection_in = fd_in;
#line 166
  connection_out = fd_out;
#line 167
  cipher_type = 0;
#line 168
  cipher_init(& send_context, none, (u_char const   *)((u_char *)""), 0U, (u_char const   *)((void *)0),
              0U);
#line 169
  cipher_init(& receive_context, none, (u_char const   *)((u_char *)""), 0U, (u_char const   *)((void *)0),
              0U);
#line 170
  if (! initialized) {
#line 171
    initialized = 1;
#line 172
    buffer_init(& input);
#line 173
    buffer_init(& output);
#line 174
    buffer_init(& outgoing_packet);
#line 175
    buffer_init(& incoming_packet);
  }
#line 178
  fatal_add_cleanup((void (*)(void * ))(& packet_close), (void *)0);
#line 179
  return;
}
}
#line 183 "packet.c"
int packet_connection_is_on_socket(void) 
{ struct sockaddr_storage from ;
  struct sockaddr_storage to ;
  socklen_t fromlen ;
  socklen_t tolen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 190
  if (connection_in == connection_out) {
#line 191
    return (1);
  }
#line 192
  fromlen = sizeof(from);
#line 193
  memset((void *)(& from), 0, sizeof(from));
#line 194
  tmp = getpeername(connection_in, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                    (socklen_t * __restrict  )(& fromlen));
#line 194
  if (tmp < 0) {
#line 195
    return (0);
  }
#line 196
  tolen = sizeof(to);
#line 197
  memset((void *)(& to), 0, sizeof(to));
#line 198
  tmp___0 = getpeername(connection_out, (struct sockaddr * __restrict  )((struct sockaddr *)(& to)),
                        (socklen_t * __restrict  )(& tolen));
#line 198
  if (tmp___0 < 0) {
#line 199
    return (0);
  }
#line 200
  if (fromlen != tolen) {
#line 201
    return (0);
  } else {
#line 200
    tmp___1 = memcmp((void const   *)(& from), (void const   *)(& to), fromlen);
#line 200
    if (tmp___1 != 0) {
#line 201
      return (0);
    }
  }
#line 202
  if ((int )from.ss_family != 2) {
#line 202
    if ((int )from.ss_family != 10) {
#line 203
      return (0);
    }
  }
#line 204
  return (1);
}
}
#line 209 "packet.c"
int packet_connection_is_ipv4(void) 
{ struct sockaddr_storage to ;
  socklen_t tolen ;
  int tmp ;

  {
#line 213
  tolen = sizeof(to);
#line 215
  memset((void *)(& to), 0, sizeof(to));
#line 216
  tmp = getsockname(connection_out, (struct sockaddr * __restrict  )((struct sockaddr *)(& to)),
                    (socklen_t * __restrict  )(& tolen));
#line 216
  if (tmp < 0) {
#line 217
    return (0);
  }
#line 218
  if ((int )to.ss_family != 2) {
#line 219
    return (0);
  }
#line 220
  return (1);
}
}
#line 225 "packet.c"
void packet_set_nonblocking(void) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 229
  tmp___1 = fcntl(connection_in, 4, 2048);
#line 229
  if (tmp___1 < 0) {
#line 230
    tmp = __errno_location();
#line 230
    tmp___0 = strerror(*tmp);
#line 230
    error("fcntl O_NONBLOCK: %.100s", tmp___0);
  }
#line 232
  if (connection_out != connection_in) {
#line 233
    tmp___4 = fcntl(connection_out, 4, 2048);
#line 233
    if (tmp___4 < 0) {
#line 234
      tmp___2 = __errno_location();
#line 234
      tmp___3 = strerror(*tmp___2);
#line 234
      error("fcntl O_NONBLOCK: %.100s", tmp___3);
    }
  }
#line 236
  return;
}
}
#line 240 "packet.c"
int packet_get_connection_in(void) 
{ 

  {
#line 243
  return (connection_in);
}
}
#line 248 "packet.c"
int packet_get_connection_out(void) 
{ 

  {
#line 251
  return (connection_out);
}
}
#line 256 "packet.c"
void packet_close(void) 
{ 

  {
#line 259
  if (! initialized) {
#line 260
    return;
  }
#line 261
  initialized = 0;
#line 262
  if (connection_in == connection_out) {
#line 263
    shutdown(connection_out, 2);
#line 264
    close(connection_out);
  } else {
#line 266
    close(connection_in);
#line 267
    close(connection_out);
  }
#line 269
  buffer_free(& input);
#line 270
  buffer_free(& output);
#line 271
  buffer_free(& outgoing_packet);
#line 272
  buffer_free(& incoming_packet);
#line 273
  if (packet_compression) {
#line 274
    buffer_free(& compression_buffer);
#line 275
    buffer_compress_uninit();
  }
#line 277
  return;
}
}
#line 281 "packet.c"
void packet_set_protocol_flags(u_int protocol_flags ) 
{ 

  {
#line 284
  remote_protocol_flags = protocol_flags;
#line 285
  channel_set_options((protocol_flags & 2U) != 0U);
#line 286
  return;
}
}
#line 290 "packet.c"
u_int packet_get_protocol_flags(void) 
{ 

  {
#line 293
  return (remote_protocol_flags);
}
}
#line 302 "packet.c"
void packet_start_compression(int level ) 
{ 

  {
#line 305
  if (packet_compression) {
#line 306
    fatal("Compression already enabled.");
  }
#line 307
  packet_compression = 1;
#line 308
  buffer_init(& compression_buffer);
#line 309
  buffer_compress_init(level);
#line 310
  return;
}
}
#line 317 "packet.c"
void packet_encrypt(CipherContext *cc , void *dest , void *src , u_int bytes ) 
{ 

  {
#line 321
  cipher_encrypt(cc, (u_char *)dest, (u_char const   *)src, bytes);
#line 322
  return;
}
}
#line 329 "packet.c"
void packet_decrypt(CipherContext *context , void *dest , void *src , u_int bytes ) 
{ int tmp ;

  {
#line 336
  if (! compat20) {
#line 336
    if ((context->cipher)->number != 0) {
#line 336
      tmp = detect_attack((u_char *)src, bytes, (u_char *)((void *)0));
#line 336
      if (tmp == 1) {
#line 339
        packet_disconnect("crc32 compensation attack: network attack detected");
      }
    }
  }
#line 341
  cipher_decrypt(context, (u_char *)dest, (u_char const   *)src, bytes);
#line 342
  return;
}
}
#line 350 "packet.c"
void packet_set_encryption_key(u_char const   *key , u_int keylen , int number ) 
{ Cipher *cipher ;
  Cipher *tmp ;

  {
#line 354
  tmp = cipher_by_number(number);
#line 354
  cipher = tmp;
#line 355
  if ((unsigned int )cipher == (unsigned int )((void *)0)) {
#line 356
    fatal("packet_set_encryption_key: unknown cipher number %d", number);
  }
#line 357
  if (keylen < 20U) {
#line 358
    fatal("packet_set_encryption_key: keylen too small: %d", keylen);
  }
#line 359
  cipher_init(& receive_context, cipher, key, keylen, (u_char const   *)((void *)0),
              0U);
#line 360
  cipher_init(& send_context, cipher, key, keylen, (u_char const   *)((void *)0),
              0U);
#line 361
  return;
}
}
#line 365 "packet.c"
void packet_start1(int type ) 
{ char buf___2[9] ;

  {
#line 370
  buffer_clear(& outgoing_packet);
#line 371
  memset((void *)(buf___2), 0, 8U);
#line 372
  buf___2[8] = (char )type;
#line 373
  buffer_append(& outgoing_packet, (char const   *)(buf___2), 9U);
#line 374
  return;
}
}
#line 376 "packet.c"
void packet_start2(int type ) 
{ char buf___2[6] ;

  {
#line 381
  buffer_clear(& outgoing_packet);
#line 382
  memset((void *)(buf___2), 0, sizeof(buf___2));
#line 385
  buf___2[5] = (char )(type & 255);
#line 386
  buffer_append(& outgoing_packet, (char const   *)(buf___2), sizeof(buf___2));
#line 387
  return;
}
}
#line 389 "packet.c"
void packet_start(int type ) 
{ 

  {
#line 393
  if (use_ssh2_packet_format) {
#line 394
    packet_start2(type);
  } else {
#line 396
    packet_start1(type);
  }
#line 397
  return;
}
}
#line 401 "packet.c"
void packet_put_char(int value ) 
{ char ch ;

  {
#line 404
  ch = (char )value;
#line 405
  buffer_append(& outgoing_packet, (char const   *)(& ch), 1U);
#line 406
  return;
}
}
#line 410 "packet.c"
void packet_put_int(u_int value ) 
{ 

  {
#line 413
  buffer_put_int(& outgoing_packet, value);
#line 414
  return;
}
}
#line 418 "packet.c"
void packet_put_string(char const   *buf___2 , u_int len ) 
{ 

  {
#line 421
  buffer_put_string(& outgoing_packet, (void const   *)buf___2, len);
#line 422
  return;
}
}
#line 423 "packet.c"
void packet_put_cstring(char const   *str ) 
{ size_t tmp ;

  {
#line 426
  tmp = strlen(str);
#line 426
  buffer_put_string(& outgoing_packet, (void const   *)str, tmp);
#line 427
  return;
}
}
#line 429 "packet.c"
void packet_put_raw(char const   *buf___2 , u_int len ) 
{ 

  {
#line 432
  buffer_append(& outgoing_packet, buf___2, len);
#line 433
  return;
}
}
#line 438 "packet.c"
void packet_put_bignum(BIGNUM *value ) 
{ 

  {
#line 441
  buffer_put_bignum(& outgoing_packet, value);
#line 442
  return;
}
}
#line 443 "packet.c"
void packet_put_bignum2(BIGNUM *value ) 
{ 

  {
#line 446
  buffer_put_bignum2(& outgoing_packet, value);
#line 447
  return;
}
}
#line 454 "packet.c"
void packet_send1(void) 
{ char buf___2[8] ;
  char *cp ;
  int i ;
  int padding ;
  int len ;
  u_int checksum ;
  u_int32_t rand___0 ;
  u_int tmp ;
  char *tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  char *tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  char *tmp___6 ;

  {
#line 460
  rand___0 = (u_int32_t )0;
#line 466
  if (packet_compression) {
#line 467
    buffer_clear(& compression_buffer);
#line 469
    buffer_consume(& outgoing_packet, 8U);
#line 471
    buffer_append(& compression_buffer, "\000\000\000\000\000\000\000\000", 8U);
#line 472
    buffer_compress(& outgoing_packet, & compression_buffer);
#line 473
    buffer_clear(& outgoing_packet);
#line 474
    tmp = buffer_len(& compression_buffer);
#line 474
    tmp___0 = buffer_ptr(& compression_buffer);
#line 474
    buffer_append(& outgoing_packet, (char const   *)tmp___0, tmp);
  }
#line 478
  tmp___1 = buffer_len(& outgoing_packet);
#line 478
  len = (int )((tmp___1 + 4U) - 8U);
#line 481
  padding = 8 - len % 8;
#line 482
  if (cipher_type != 0) {
#line 483
    cp = buffer_ptr(& outgoing_packet);
#line 484
    i = 0;
#line 484
    while (i < padding) {
#line 485
      if (i % 4 == 0) {
#line 486
        rand___0 = arc4random();
      }
#line 487
      *(cp + (7 - i)) = (char )(rand___0 & 255U);
#line 488
      rand___0 >>= 8;
#line 484
      i ++;
    }
  }
#line 491
  buffer_consume(& outgoing_packet, (unsigned int )(8 - padding));
#line 494
  tmp___2 = buffer_len(& outgoing_packet);
#line 494
  tmp___3 = buffer_ptr(& outgoing_packet);
#line 494
  checksum = ssh_crc32((u_char const   *)((u_char *)tmp___3), tmp___2);
#line 496
  while (1) {
#line 496
    buf___2[0] = (char )(checksum >> 24);
#line 496
    buf___2[1] = (char )(checksum >> 16);
#line 496
    buf___2[2] = (char )(checksum >> 8);
#line 496
    buf___2[3] = (char )checksum;
#line 496
    break;
  }
#line 497
  buffer_append(& outgoing_packet, (char const   *)(buf___2), 4U);
#line 505
  while (1) {
#line 505
    buf___2[0] = (char )(len >> 24);
#line 505
    buf___2[1] = (char )(len >> 16);
#line 505
    buf___2[2] = (char )(len >> 8);
#line 505
    buf___2[3] = (char )len;
#line 505
    break;
  }
#line 506
  buffer_append(& output, (char const   *)(buf___2), 4U);
#line 507
  tmp___4 = buffer_len(& outgoing_packet);
#line 507
  buffer_append_space(& output, & cp, tmp___4);
#line 508
  tmp___5 = buffer_len(& outgoing_packet);
#line 508
  tmp___6 = buffer_ptr(& outgoing_packet);
#line 508
  packet_encrypt(& send_context, (void *)cp, (void *)tmp___6, tmp___5);
#line 516
  buffer_clear(& outgoing_packet);
#line 523
  return;
}
}
#line 531
void packet_send2(void) ;
#line 531 "packet.c"
static u_int32_t seqnr  =    (u_int32_t )0;
#line 528 "packet.c"
void packet_send2(void) 
{ u_char *macbuf ;
  char *cp ;
  u_int packet_length___0 ;
  u_int i ;
  u_int padlen ;
  u_int len ;
  u_int32_t rand___0 ;
  int type ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  int block_size ;
  u_int tmp ;
  char *tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  char *tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  char *tmp___6 ;

  {
#line 532
  macbuf = (u_char *)((void *)0);
#line 534
  packet_length___0 = (u_int )0;
#line 536
  rand___0 = (u_int32_t )0;
#line 538
  enc = (Enc *)((void *)0);
#line 539
  mac = (Mac *)((void *)0);
#line 540
  comp = (Comp *)((void *)0);
#line 543
  if ((unsigned int )kex != (unsigned int )((void *)0)) {
#line 544
    enc = & kex->enc[1];
#line 545
    mac = & kex->mac[1];
#line 546
    comp = & kex->comp[1];
  }
#line 548
  if (enc) {
#line 548
    block_size = (int )(enc->cipher)->block_size;
  } else {
#line 548
    block_size = 8;
  }
#line 550
  cp = buffer_ptr(& outgoing_packet);
#line 551
  type = (int )*(cp + 5) & 255;
#line 558
  if (comp) {
#line 558
    if (comp->enabled) {
#line 559
      len = buffer_len(& outgoing_packet);
#line 561
      buffer_consume(& outgoing_packet, 5U);
#line 562
      buffer_clear(& compression_buffer);
#line 563
      buffer_compress(& outgoing_packet, & compression_buffer);
#line 564
      buffer_clear(& outgoing_packet);
#line 565
      buffer_append(& outgoing_packet, "\000\000\000\000\000", 5U);
#line 566
      tmp = buffer_len(& compression_buffer);
#line 566
      tmp___0 = buffer_ptr(& compression_buffer);
#line 566
      buffer_append(& outgoing_packet, (char const   *)tmp___0, tmp);
    }
  }
#line 573
  len = buffer_len(& outgoing_packet);
#line 579
  padlen = (unsigned int )block_size - len % (unsigned int )block_size;
#line 580
  if (padlen < 4U) {
#line 581
    padlen += (u_int )block_size;
  }
#line 582
  buffer_append_space(& outgoing_packet, & cp, padlen);
#line 583
  if (enc) {
#line 583
    if ((enc->cipher)->number != 0) {
#line 585
      i = 0U;
#line 585
      while (i < padlen) {
#line 586
        if (i % 4U == 0U) {
#line 587
          rand___0 = arc4random();
        }
#line 588
        *(cp + i) = (char )(rand___0 & 255U);
#line 589
        rand___0 <<= 8;
#line 585
        i ++;
      }
    } else {
#line 593
      memset((void *)cp, 0, padlen);
    }
  } else {
#line 593
    memset((void *)cp, 0, padlen);
  }
#line 596
  tmp___1 = buffer_len(& outgoing_packet);
#line 596
  packet_length___0 = tmp___1 - 4U;
#line 597
  cp = buffer_ptr(& outgoing_packet);
#line 598
  while (1) {
#line 598
    *(cp + 0) = (char )(packet_length___0 >> 24);
#line 598
    *(cp + 1) = (char )(packet_length___0 >> 16);
#line 598
    *(cp + 2) = (char )(packet_length___0 >> 8);
#line 598
    *(cp + 3) = (char )packet_length___0;
#line 598
    break;
  }
#line 599
  *(cp + 4) = (char )(padlen & 255U);
#line 603
  if (mac) {
#line 603
    if (mac->enabled) {
#line 604
      tmp___2 = buffer_len(& outgoing_packet);
#line 604
      tmp___3 = buffer_ptr(& outgoing_packet);
#line 604
      macbuf = mac_compute(mac, seqnr, (u_char *)tmp___3, (int )tmp___2);
    }
  }
#line 610
  tmp___4 = buffer_len(& outgoing_packet);
#line 610
  buffer_append_space(& output, & cp, tmp___4);
#line 611
  tmp___5 = buffer_len(& outgoing_packet);
#line 611
  tmp___6 = buffer_ptr(& outgoing_packet);
#line 611
  packet_encrypt(& send_context, (void *)cp, (void *)tmp___6, tmp___5);
#line 614
  if (mac) {
#line 614
    if (mac->enabled) {
#line 615
      buffer_append(& output, (char const   *)((char *)macbuf), (unsigned int )mac->mac_len);
    }
  }
#line 621
  seqnr ++;
#line 621
  if (seqnr == 0U) {
#line 622
    log("outgoing seqnr wraps around");
  }
#line 623
  buffer_clear(& outgoing_packet);
#line 625
  if (type == 21) {
#line 626
    if ((unsigned int )kex == (unsigned int )((void *)0)) {
#line 627
      fatal("packet_send2: no KEX");
    } else {
#line 626
      if ((unsigned int )mac == (unsigned int )((void *)0)) {
#line 627
        fatal("packet_send2: no KEX");
      } else {
#line 626
        if ((unsigned int )enc == (unsigned int )((void *)0)) {
#line 627
          fatal("packet_send2: no KEX");
        } else {
#line 626
          if ((unsigned int )comp == (unsigned int )((void *)0)) {
#line 627
            fatal("packet_send2: no KEX");
          }
        }
      }
    }
#line 628
    if ((unsigned int )mac->md != (unsigned int )((void *)0)) {
#line 629
      mac->enabled = 1;
    }
#line 631
    cipher_init(& send_context, enc->cipher, (u_char const   *)enc->key, (enc->cipher)->key_len,
                (u_char const   *)enc->iv, (enc->cipher)->block_size);
#line 634
    clear_enc_keys(enc, kex->we_need);
#line 635
    if (comp->type != 0) {
#line 635
      if (comp->enabled == 0) {
#line 636
        comp->enabled = 1;
#line 637
        if (! packet_compression) {
#line 638
          packet_start_compression(6);
        }
      }
    }
  }
#line 641
  return;
}
}
#line 643 "packet.c"
void packet_send(void) 
{ 

  {
#line 646
  if (use_ssh2_packet_format) {
#line 647
    packet_send2();
  } else {
#line 649
    packet_send1();
  }
#line 651
  return;
}
}
#line 659 "packet.c"
int packet_read(int *payload_len_ptr ) 
{ int type ;
  int len ;
  fd_set set ;
  char buf___2[8192] ;
  int _p ;
  int _e ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;

  {
#line 668
  packet_write_wait();
#line 671
  while (1) {
#line 673
    type = packet_read_poll(payload_len_ptr);
#line 674
    if (! use_ssh2_packet_format) {
#line 674
      if (type == 14) {
        goto _L;
      } else {
#line 674
        if (type == 15) {
          goto _L;
        } else {
#line 674
          if (type == 19) {
            goto _L;
          } else {
#line 674
            if (type == 33) {
              _L: /* CIL Label */ 
#line 679
              while (1) {
#line 679
                _p = *payload_len_ptr;
#line 679
                _e = 0;
#line 679
                if (_p != _e) {
#line 679
                  log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "packet.c",
                      679);
#line 679
                  packet_disconnect("Packet integrity error. (%d)", type);
                }
#line 679
                break;
              }
            }
          }
        }
      }
    }
#line 681
    if (type != 0) {
#line 682
      return (type);
    }
#line 687
    while (1) {
#line 687
      __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& set.__fds_bits[0]): "memory");
#line 687
      break;
    }
#line 688
    __asm__  volatile   ("btsl %1,%0": "=m" (set.__fds_bits[(unsigned int )connection_in / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 691
    while (1) {
#line 691
      tmp = select(connection_in + 1, (fd_set * __restrict  )(& set), (fd_set * __restrict  )((void *)0),
                   (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 691
      if (tmp == -1) {
#line 691
        tmp___0 = __errno_location();
#line 691
        if (! (*tmp___0 == 11)) {
#line 691
          tmp___1 = __errno_location();
#line 691
          if (! (*tmp___1 == 4)) {
#line 691
            break;
          }
        }
      } else {
#line 691
        break;
      }
    }
#line 696
    len = read(connection_in, (void *)(buf___2), sizeof(buf___2));
#line 697
    if (len == 0) {
#line 698
      tmp___2 = get_remote_ipaddr();
#line 698
      log("Connection closed by %.200s", tmp___2);
#line 699
      fatal_cleanup();
    }
#line 701
    if (len < 0) {
#line 702
      tmp___3 = __errno_location();
#line 702
      tmp___4 = strerror(*tmp___3);
#line 702
      fatal("Read from socket failed: %.100s", tmp___4);
    }
#line 704
    packet_process_incoming((char const   *)(buf___2), (unsigned int )len);
  }
}
}
#line 714 "packet.c"
void packet_read_expect(int *payload_len_ptr , int expected_type ) 
{ int type ;

  {
#line 719
  type = packet_read(payload_len_ptr);
#line 720
  if (type != expected_type) {
#line 721
    packet_disconnect("Protocol error: expected packet type %d, got %d", expected_type,
                      type);
  }
#line 723
  return;
}
}
#line 740 "packet.c"
int packet_read_poll1(int *payload_len_ptr ) 
{ u_int len ;
  u_int padded_len ;
  u_char *ucp ;
  char buf___2[8] ;
  char *cp ;
  u_int checksum ;
  u_int stored_checksum ;
  u_int tmp ;
  char *tmp___0 ;
  u_int tmp___1 ;
  char *tmp___2 ;
  u_int tmp___3 ;
  char *tmp___4 ;
  u_int tmp___5 ;
  u_int tmp___6 ;
  char *tmp___7 ;
  u_int tmp___8 ;
  char *tmp___9 ;
  u_int tmp___10 ;

  {
#line 749
  tmp = buffer_len(& input);
#line 749
  if (tmp < 12U) {
#line 750
    return (0);
  }
#line 752
  tmp___0 = buffer_ptr(& input);
#line 752
  ucp = (u_char *)tmp___0;
#line 753
  len = (unsigned int )(((((unsigned long )*(ucp + 0) << 24) | ((unsigned long )*(ucp + 1) << 16)) | ((unsigned long )*(ucp + 2) << 8)) | (unsigned long )*(ucp + 3));
#line 754
  if (len < 5U) {
#line 755
    packet_disconnect("Bad packet length %d.", len);
  } else {
#line 754
    if (len > 262144U) {
#line 755
      packet_disconnect("Bad packet length %d.", len);
    }
  }
#line 756
  padded_len = (len + 8U) & 4294967288U;
#line 759
  tmp___1 = buffer_len(& input);
#line 759
  if (tmp___1 < 4U + padded_len) {
#line 760
    return (0);
  }
#line 765
  buffer_consume(& input, 4U);
#line 768
  buffer_clear(& incoming_packet);
#line 769
  buffer_append_space(& incoming_packet, & cp, padded_len);
#line 770
  tmp___2 = buffer_ptr(& input);
#line 770
  packet_decrypt(& receive_context, (void *)cp, (void *)tmp___2, padded_len);
#line 771
  buffer_consume(& input, padded_len);
#line 779
  tmp___3 = buffer_len(& incoming_packet);
#line 779
  tmp___4 = buffer_ptr(& incoming_packet);
#line 779
  checksum = ssh_crc32((u_char const   *)((u_char *)tmp___4), tmp___3 - 4U);
#line 783
  buffer_consume(& incoming_packet, 8U - len % 8U);
#line 787
  tmp___6 = buffer_len(& incoming_packet);
#line 787
  if (len != tmp___6) {
#line 788
    tmp___5 = buffer_len(& incoming_packet);
#line 788
    packet_disconnect("packet_read_poll: len %d != buffer_len %d.", len, tmp___5);
  }
#line 791
  tmp___7 = buffer_ptr(& incoming_packet);
#line 791
  ucp = ((u_char *)tmp___7 + len) - 4;
#line 792
  stored_checksum = (unsigned int )(((((unsigned long )*(ucp + 0) << 24) | ((unsigned long )*(ucp + 1) << 16)) | ((unsigned long )*(ucp + 2) << 8)) | (unsigned long )*(ucp + 3));
#line 793
  if (checksum != stored_checksum) {
#line 794
    packet_disconnect("Corrupted check bytes on input.");
  }
#line 795
  buffer_consume_end(& incoming_packet, 4U);
#line 798
  if (packet_compression) {
#line 799
    buffer_clear(& compression_buffer);
#line 800
    buffer_uncompress(& incoming_packet, & compression_buffer);
#line 801
    buffer_clear(& incoming_packet);
#line 802
    tmp___8 = buffer_len(& compression_buffer);
#line 802
    tmp___9 = buffer_ptr(& compression_buffer);
#line 802
    buffer_append(& incoming_packet, (char const   *)tmp___9, tmp___8);
  }
#line 806
  buffer_get(& incoming_packet, buf___2, 1U);
#line 809
  tmp___10 = buffer_len(& incoming_packet);
#line 809
  *payload_len_ptr = (int )tmp___10;
#line 812
  return ((int )((unsigned char )buf___2[0]));
}
}
#line 818
int packet_read_poll2(int *payload_len_ptr ) ;
#line 818 "packet.c"
static u_int32_t seqnr___0  =    (u_int32_t )0;
#line 819 "packet.c"
static u_int packet_length  =    (u_int )0;
#line 815 "packet.c"
int packet_read_poll2(int *payload_len_ptr ) 
{ u_int padlen ;
  u_int need ;
  u_char buf___2[8] ;
  u_char *macbuf ;
  u_char *ucp ;
  char *cp ;
  int type ;
  int maclen ;
  int block_size ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  u_int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  u_int tmp___2 ;
  char *tmp___3 ;
  u_int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  u_int tmp___9 ;
  char *tmp___10 ;
  u_int tmp___11 ;

  {
#line 826
  enc = (Enc *)((void *)0);
#line 827
  mac = (Mac *)((void *)0);
#line 828
  comp = (Comp *)((void *)0);
#line 830
  if ((unsigned int )kex != (unsigned int )((void *)0)) {
#line 831
    enc = & kex->enc[0];
#line 832
    mac = & kex->mac[0];
#line 833
    comp = & kex->comp[0];
  }
#line 835
  if (mac) {
#line 835
    if (mac->enabled) {
#line 835
      maclen = mac->mac_len;
    } else {
#line 835
      maclen = 0;
    }
  } else {
#line 835
    maclen = 0;
  }
#line 836
  if (enc) {
#line 836
    block_size = (int )(enc->cipher)->block_size;
  } else {
#line 836
    block_size = 8;
  }
#line 838
  if (packet_length == 0U) {
#line 843
    tmp = buffer_len(& input);
#line 843
    if (tmp < (u_int )block_size) {
#line 844
      return (0);
    }
#line 845
    buffer_clear(& incoming_packet);
#line 846
    buffer_append_space(& incoming_packet, & cp, (unsigned int )block_size);
#line 847
    tmp___0 = buffer_ptr(& input);
#line 847
    packet_decrypt(& receive_context, (void *)cp, (void *)tmp___0, (unsigned int )block_size);
#line 849
    tmp___1 = buffer_ptr(& incoming_packet);
#line 849
    ucp = (u_char *)tmp___1;
#line 850
    packet_length = (unsigned int )(((((unsigned long )*(ucp + 0) << 24) | ((unsigned long )*(ucp + 1) << 16)) | ((unsigned long )*(ucp + 2) << 8)) | (unsigned long )*(ucp + 3));
#line 851
    if (packet_length < 5U) {
#line 852
      buffer_dump(& incoming_packet);
#line 853
      packet_disconnect("Bad packet length %d.", packet_length);
    } else {
#line 851
      if (packet_length > 262144U) {
#line 852
        buffer_dump(& incoming_packet);
#line 853
        packet_disconnect("Bad packet length %d.", packet_length);
      }
    }
#line 856
    buffer_consume(& input, (unsigned int )block_size);
  }
#line 859
  need = (4U + packet_length) - (u_int )block_size;
#line 862
  if (need % (unsigned int )block_size != 0U) {
#line 863
    fatal("padding error: need %d block %d mod %d", need, block_size, need % (unsigned int )block_size);
  }
#line 869
  tmp___2 = buffer_len(& input);
#line 869
  if (tmp___2 < need + (u_int )maclen) {
#line 870
    return (0);
  }
#line 875
  buffer_append_space(& incoming_packet, & cp, need);
#line 876
  tmp___3 = buffer_ptr(& input);
#line 876
  packet_decrypt(& receive_context, (void *)cp, (void *)tmp___3, need);
#line 877
  buffer_consume(& input, need);
#line 882
  if (mac) {
#line 882
    if (mac->enabled) {
#line 883
      tmp___4 = buffer_len(& incoming_packet);
#line 883
      tmp___5 = buffer_ptr(& incoming_packet);
#line 883
      macbuf = mac_compute(mac, seqnr___0, (u_char *)tmp___5, (int )tmp___4);
#line 886
      tmp___6 = buffer_ptr(& input);
#line 886
      tmp___7 = memcmp((void const   *)macbuf, (void const   *)tmp___6, (unsigned int )mac->mac_len);
#line 886
      if (tmp___7 != 0) {
#line 887
        packet_disconnect("Corrupted MAC on input.");
      }
#line 889
      buffer_consume(& input, (unsigned int )mac->mac_len);
    }
  }
#line 891
  seqnr___0 ++;
#line 891
  if (seqnr___0 == 0U) {
#line 892
    log("incoming seqnr wraps around");
  }
#line 895
  tmp___8 = buffer_ptr(& incoming_packet);
#line 895
  cp = tmp___8 + 4;
#line 896
  padlen = (unsigned int )((int )*cp & 255);
#line 898
  if (padlen < 4U) {
#line 899
    packet_disconnect("Corrupted padlen %d on input.", padlen);
  }
#line 902
  buffer_consume(& incoming_packet, 5U);
#line 903
  buffer_consume_end(& incoming_packet, padlen);
#line 906
  if (comp) {
#line 906
    if (comp->enabled) {
#line 907
      buffer_clear(& compression_buffer);
#line 908
      buffer_uncompress(& incoming_packet, & compression_buffer);
#line 909
      buffer_clear(& incoming_packet);
#line 910
      tmp___9 = buffer_len(& compression_buffer);
#line 910
      tmp___10 = buffer_ptr(& compression_buffer);
#line 910
      buffer_append(& incoming_packet, (char const   *)tmp___10, tmp___9);
    }
  }
#line 918
  buffer_get(& incoming_packet, (char *)(buf___2), 1U);
#line 919
  tmp___11 = buffer_len(& incoming_packet);
#line 919
  *payload_len_ptr = (int )tmp___11;
#line 922
  packet_length = 0U;
#line 925
  type = (int )buf___2[0];
#line 927
  if (type == 21) {
#line 928
    if ((unsigned int )kex == (unsigned int )((void *)0)) {
#line 929
      fatal("packet_read_poll2: no KEX");
    } else {
#line 928
      if ((unsigned int )mac == (unsigned int )((void *)0)) {
#line 929
        fatal("packet_read_poll2: no KEX");
      } else {
#line 928
        if ((unsigned int )enc == (unsigned int )((void *)0)) {
#line 929
          fatal("packet_read_poll2: no KEX");
        } else {
#line 928
          if ((unsigned int )comp == (unsigned int )((void *)0)) {
#line 929
            fatal("packet_read_poll2: no KEX");
          }
        }
      }
    }
#line 930
    if ((unsigned int )mac->md != (unsigned int )((void *)0)) {
#line 931
      mac->enabled = 1;
    }
#line 933
    cipher_init(& receive_context, enc->cipher, (u_char const   *)enc->key, (enc->cipher)->key_len,
                (u_char const   *)enc->iv, (enc->cipher)->block_size);
#line 936
    clear_enc_keys(enc, kex->we_need);
#line 937
    if (comp->type != 0) {
#line 937
      if (comp->enabled == 0) {
#line 938
        comp->enabled = 1;
#line 939
        if (! packet_compression) {
#line 940
          packet_start_compression(6);
        }
      }
    }
  }
#line 948
  return ((int )((unsigned char )type));
}
}
#line 951 "packet.c"
int packet_read_poll(int *payload_len_ptr ) 
{ char *msg ;
  int type ;
  int tmp___1 ;
  int reason ;
  u_int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
#line 955
  while (1) {
#line 956
    if (use_ssh2_packet_format) {
#line 956
      tmp___1 = packet_read_poll2(payload_len_ptr);
    } else {
#line 956
      tmp___1 = packet_read_poll1(payload_len_ptr);
    }
#line 956
    type = tmp___1;
#line 960
    if (compat20) {
#line 962
      if (type != 0) {

      }
#line 964
      switch (type) {
      case 2: 
#line 966
      break;
      case 4: 
#line 968
      packet_get_char();
#line 969
      msg = packet_get_string((u_int *)((void *)0));
#line 970
      debug("Remote: %.900s", msg);
#line 971
      xfree((void *)msg);
#line 972
      msg = packet_get_string((u_int *)((void *)0));
#line 973
      xfree((void *)msg);
#line 974
      break;
      case 1: 
#line 976
      tmp___2 = packet_get_int();
#line 976
      reason = (int )tmp___2;
#line 977
      msg = packet_get_string((u_int *)((void *)0));
#line 978
      tmp___3 = get_remote_ipaddr();
#line 978
      log("Received disconnect from %s: %d: %.400s", tmp___3, reason, msg);
#line 980
      xfree((void *)msg);
#line 981
      fatal_cleanup();
#line 982
      break;
      default: ;
#line 984
      return (type);
#line 985
      break;
      }
    } else {
#line 988
      switch (type) {
      case 32: 
#line 990
      break;
      case 36: 
#line 992
      msg = packet_get_string((u_int *)((void *)0));
#line 993
      debug("Remote: %.900s", msg);
#line 994
      xfree((void *)msg);
#line 995
      break;
      case 1: 
#line 997
      msg = packet_get_string((u_int *)((void *)0));
#line 998
      tmp___4 = get_remote_ipaddr();
#line 998
      log("Received disconnect from %s: %.400s", tmp___4, msg);
#line 1000
      fatal_cleanup();
#line 1001
      xfree((void *)msg);
#line 1002
      break;
      default: ;
#line 1004
      if (type != 0) {

      }
#line 1006
      return (type);
#line 1007
      break;
      }
    }
  }
}
}
#line 1018 "packet.c"
void packet_process_incoming(char const   *buf___2 , u_int len ) 
{ 

  {
#line 1021
  buffer_append(& input, buf___2, len);
#line 1022
  return;
}
}
#line 1026 "packet.c"
u_int packet_get_char(void) 
{ char ch ;

  {
#line 1030
  buffer_get(& incoming_packet, & ch, 1U);
#line 1031
  return ((unsigned int )((unsigned char )ch));
}
}
#line 1036 "packet.c"
u_int packet_get_int(void) 
{ u_int tmp ;

  {
#line 1039
  tmp = buffer_get_int(& incoming_packet);
#line 1039
  return (tmp);
}
}
#line 1047 "packet.c"
void packet_get_bignum(BIGNUM *value , int *length_ptr ) 
{ 

  {
#line 1050
  *length_ptr = buffer_get_bignum(& incoming_packet, value);
#line 1051
  return;
}
}
#line 1053 "packet.c"
void packet_get_bignum2(BIGNUM *value , int *length_ptr ) 
{ 

  {
#line 1056
  *length_ptr = buffer_get_bignum2(& incoming_packet, value);
#line 1057
  return;
}
}
#line 1059 "packet.c"
char *packet_get_raw(int *length_ptr ) 
{ int bytes ;
  u_int tmp ;
  char *tmp___0 ;

  {
#line 1062
  tmp = buffer_len(& incoming_packet);
#line 1062
  bytes = (int )tmp;
#line 1063
  if ((unsigned int )length_ptr != (unsigned int )((void *)0)) {
#line 1064
    *length_ptr = bytes;
  }
#line 1065
  tmp___0 = buffer_ptr(& incoming_packet);
#line 1065
  return (tmp___0);
}
}
#line 1068 "packet.c"
int packet_remaining(void) 
{ u_int tmp ;

  {
#line 1071
  tmp = buffer_len(& incoming_packet);
#line 1071
  return ((int )tmp);
}
}
#line 1081 "packet.c"
char *packet_get_string(u_int *length_ptr ) 
{ char *tmp ;

  {
#line 1084
  tmp = buffer_get_string(& incoming_packet, length_ptr);
#line 1084
  return (tmp);
}
}
#line 1096 "packet.c"
void ( /* format attribute */  packet_send_debug)(char const   *fmt  , ...) 
{ char buf___2[1024] ;
  va_list args ;

  {
#line 1102
  if (compat20) {
#line 1102
    if (datafellows & 64) {
#line 1103
      return;
    }
  }
#line 1105
  __builtin_va_start(args, fmt);
#line 1106
  vsnprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )fmt,
            args);
#line 1107
  __builtin_va_end(args);
#line 1109
  if (compat20) {
#line 1110
    packet_start(4);
#line 1111
    packet_put_char(0);
#line 1112
    packet_put_cstring((char const   *)(buf___2));
#line 1113
    packet_put_cstring("");
  } else {
#line 1115
    packet_start(36);
#line 1116
    packet_put_cstring((char const   *)(buf___2));
  }
#line 1118
  packet_send();
#line 1119
  packet_write_wait();
#line 1120
  return;
}
}
#line 1134 "packet.c"
static int disconnecting  =    0;
#line 1129 "packet.c"
void ( /* format attribute */  packet_disconnect)(char const   *fmt  , ...) 
{ char buf___2[1024] ;
  va_list args ;
  size_t tmp ;

  {
#line 1135
  if (disconnecting) {
#line 1136
    fatal("packet_disconnect called recursively.");
  }
#line 1137
  disconnecting = 1;
#line 1143
  __builtin_va_start(args, fmt);
#line 1144
  vsnprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )fmt,
            args);
#line 1145
  __builtin_va_end(args);
#line 1148
  if (compat20) {
#line 1149
    packet_start(1);
#line 1150
    packet_put_int(2U);
#line 1151
    packet_put_cstring((char const   *)(buf___2));
#line 1152
    packet_put_cstring("");
  } else {
#line 1154
    packet_start(1);
#line 1155
    tmp = strlen((char const   *)(buf___2));
#line 1155
    packet_put_string((char const   *)(buf___2), tmp);
  }
#line 1157
  packet_send();
#line 1158
  packet_write_wait();
#line 1161
  channel_stop_listening();
#line 1164
  packet_close();
#line 1167
  log("Disconnecting: %.100s", buf___2);
#line 1168
  fatal_cleanup();
#line 1169
  return;
}
}
#line 1173 "packet.c"
void packet_write_poll(void) 
{ int len ;
  u_int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
#line 1176
  tmp = buffer_len(& output);
#line 1176
  len = (int )tmp;
#line 1177
  if (len > 0) {
#line 1178
    tmp___0 = buffer_ptr(& output);
#line 1178
    len = write(connection_out, (void const   *)tmp___0, (unsigned int )len);
#line 1179
    if (len <= 0) {
#line 1180
      tmp___3 = __errno_location();
#line 1180
      if (*tmp___3 == 11) {
#line 1181
        return;
      } else {
#line 1183
        tmp___1 = __errno_location();
#line 1183
        tmp___2 = strerror(*tmp___1);
#line 1183
        fatal("Write failed: %.100s", tmp___2);
      }
    }
#line 1185
    buffer_consume(& output, (unsigned int )len);
  }
#line 1187
  return;
}
}
#line 1194 "packet.c"
void packet_write_wait(void) 
{ fd_set set ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 1197
  packet_write_poll();
#line 1198
  while (1) {
#line 1198
    tmp___2 = packet_have_data_to_write();
#line 1198
    if (! tmp___2) {
#line 1198
      break;
    }
#line 1201
    while (1) {
#line 1201
      __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& set.__fds_bits[0]): "memory");
#line 1201
      break;
    }
#line 1202
    __asm__  volatile   ("btsl %1,%0": "=m" (set.__fds_bits[(unsigned int )connection_out / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 1203
    while (1) {
#line 1203
      tmp = select(connection_out + 1, (fd_set * __restrict  )((void *)0), (fd_set * __restrict  )(& set),
                   (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 1203
      if (tmp == -1) {
#line 1203
        tmp___0 = __errno_location();
#line 1203
        if (! (*tmp___0 == 11)) {
#line 1203
          tmp___1 = __errno_location();
#line 1203
          if (! (*tmp___1 == 4)) {
#line 1203
            break;
          }
        }
      } else {
#line 1203
        break;
      }
    }
#line 1206
    packet_write_poll();
  }
#line 1208
  return;
}
}
#line 1212 "packet.c"
int packet_have_data_to_write(void) 
{ u_int tmp ;

  {
#line 1215
  tmp = buffer_len(& output);
#line 1215
  return (tmp != 0U);
}
}
#line 1220 "packet.c"
int packet_not_very_much_data_to_write(void) 
{ u_int tmp ;
  u_int tmp___0 ;

  {
#line 1223
  if (interactive_mode) {
#line 1224
    tmp = buffer_len(& output);
#line 1224
    return (tmp < 16384U);
  } else {
#line 1226
    tmp___0 = buffer_len(& output);
#line 1226
    return (tmp___0 < 131072U);
  }
}
}
#line 1234 "packet.c"
static int called___0  =    0;
#line 1231 "packet.c"
void packet_set_interactive(int interactive ) 
{ int lowdelay ;
  int throughput ;
  int on ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 1236
  lowdelay = 16;
#line 1237
  throughput = 8;
#line 1239
  on = 1;
#line 1241
  if (called___0) {
#line 1242
    return;
  }
#line 1243
  called___0 = 1;
#line 1246
  interactive_mode = interactive;
#line 1249
  tmp = packet_connection_is_on_socket();
#line 1249
  if (! tmp) {
#line 1250
    return;
  }
#line 1254
  if (interactive) {
#line 1260
    tmp___3 = packet_connection_is_ipv4();
#line 1260
    if (tmp___3) {
#line 1261
      tmp___2 = setsockopt(connection_in, 0, 1, (void const   *)((void *)(& lowdelay)),
                           sizeof(lowdelay));
#line 1261
      if (tmp___2 < 0) {
#line 1263
        tmp___0 = __errno_location();
#line 1263
        tmp___1 = strerror(*tmp___0);
#line 1263
        error("setsockopt IPTOS_LOWDELAY: %.100s", tmp___1);
      }
    }
#line 1267
    tmp___6 = setsockopt(connection_in, 6, 1, (void const   *)((void *)(& on)), sizeof(on));
#line 1267
    if (tmp___6 < 0) {
#line 1269
      tmp___4 = __errno_location();
#line 1269
      tmp___5 = strerror(*tmp___4);
#line 1269
      error("setsockopt TCP_NODELAY: %.100s", tmp___5);
    }
  } else {
#line 1270
    tmp___10 = packet_connection_is_ipv4();
#line 1270
    if (tmp___10) {
#line 1276
      tmp___9 = setsockopt(connection_in, 0, 1, (void const   *)((void *)(& throughput)),
                           sizeof(throughput));
#line 1276
      if (tmp___9 < 0) {
#line 1278
        tmp___7 = __errno_location();
#line 1278
        tmp___8 = strerror(*tmp___7);
#line 1278
        error("setsockopt IPTOS_THROUGHPUT: %.100s", tmp___8);
      }
    }
  }
#line 1281
  return;
}
}
#line 1285 "packet.c"
int packet_is_interactive(void) 
{ 

  {
#line 1288
  return (interactive_mode);
}
}
#line 1294 "packet.c"
static int called___1  =    0;
#line 1291 "packet.c"
int packet_set_maxsize(int s ) 
{ 

  {
#line 1295
  if (called___1) {
#line 1296
    log("packet_set_maxsize: called twice: old %d new %d", max_packet_size, s);
#line 1298
    return (-1);
  }
#line 1300
  if (s < 4096) {
#line 1301
    log("packet_set_maxsize: bad size %d", s);
#line 1302
    return (-1);
  } else {
#line 1300
    if (s > 1048576) {
#line 1301
      log("packet_set_maxsize: bad size %d", s);
#line 1302
      return (-1);
    }
  }
#line 1304
  log("packet_set_maxsize: setting to %d", s);
#line 1305
  max_packet_size = s;
#line 1306
  return (s);
}
}
#line 1 "radix.o"
#pragma merger(0,"./radix.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "rijndael.o"
#pragma merger(0,"./rijndael.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 44 "rijndael.c"
void gen_tabs(void) ;
#line 73 "rijndael.c"
u1byte pow_tab[256]  ;
#line 74 "rijndael.c"
u1byte log_tab[256]  ;
#line 75 "rijndael.c"
u1byte sbx_tab[256]  ;
#line 76 "rijndael.c"
u1byte isb_tab[256]  ;
#line 77 "rijndael.c"
u4byte rco_tab[10]  ;
#line 78 "rijndael.c"
u4byte ft_tab[4][256]  ;
#line 79 "rijndael.c"
u4byte it_tab[4][256]  ;
#line 82 "rijndael.c"
u4byte fl_tab[4][256]  ;
#line 83 "rijndael.c"
u4byte il_tab[4][256]  ;
#line 86 "rijndael.c"
u4byte tab_gen  =    (u4byte )0;
#line 144 "rijndael.c"
void gen_tabs(void) 
{ u4byte i ;
  u4byte t ;
  u1byte p ;
  u1byte q ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 154
  i = 0U;
#line 154
  p = (unsigned char)1;
#line 154
  while (i < 256U) {
#line 155
    pow_tab[i] = p;
#line 155
    log_tab[p] = (unsigned char )i;
#line 157
    if ((int )p & 128) {
#line 157
      tmp = 27;
    } else {
#line 157
      tmp = 0;
    }
#line 157
    p = (unsigned char )(((int )p ^ ((int )p << 1)) ^ tmp);
#line 154
    i ++;
  }
#line 160
  log_tab[1] = (unsigned char)0;
#line 160
  p = (unsigned char)1;
#line 162
  i = 0U;
#line 162
  while (i < 10U) {
#line 163
    rco_tab[i] = (unsigned int )p;
#line 165
    if ((int )p & 128) {
#line 165
      tmp___0 = 27;
    } else {
#line 165
      tmp___0 = 0;
    }
#line 165
    p = (unsigned char )(((int )p << 1) ^ tmp___0);
#line 162
    i ++;
  }
#line 174
  i = 0U;
#line 174
  while (i < 256U) {
#line 175
    if (i) {
#line 175
      p = pow_tab[255 - (int )log_tab[i]];
    } else {
#line 175
      p = (unsigned char)0;
    }
#line 175
    q = p;
#line 176
    q = (unsigned char )(((int )q >> 7) | ((int )q << 1));
#line 176
    p = (unsigned char )((int )p ^ (int )q);
#line 177
    q = (unsigned char )(((int )q >> 7) | ((int )q << 1));
#line 177
    p = (unsigned char )((int )p ^ (int )q);
#line 178
    q = (unsigned char )(((int )q >> 7) | ((int )q << 1));
#line 178
    p = (unsigned char )((int )p ^ (int )q);
#line 179
    q = (unsigned char )(((int )q >> 7) | ((int )q << 1));
#line 179
    p = (unsigned char )((int )p ^ ((int )q ^ 99));
#line 180
    sbx_tab[i] = p;
#line 180
    isb_tab[p] = (unsigned char )i;
#line 174
    i ++;
  }
#line 183
  i = 0U;
#line 183
  while (i < 256U) {
#line 184
    p = sbx_tab[i];
#line 188
    t = (unsigned int )p;
#line 188
    fl_tab[0][i] = t;
#line 189
    fl_tab[1][i] = (t << 8) | (t >> 24);
#line 190
    fl_tab[2][i] = (t << 16) | (t >> 16);
#line 191
    fl_tab[3][i] = (t << 24) | (t >> 8);
#line 193
    if (p) {
#line 193
      tmp___1 = (int )pow_tab[((int )log_tab[2] + (int )log_tab[p]) % 255];
    } else {
#line 193
      tmp___1 = 0;
    }
#line 193
    if (p) {
#line 193
      tmp___2 = (int )pow_tab[((int )log_tab[3] + (int )log_tab[p]) % 255];
    } else {
#line 193
      tmp___2 = 0;
    }
#line 193
    t = (((unsigned int )tmp___1 | ((unsigned int )p << 8)) | ((unsigned int )p << 16)) | ((unsigned int )tmp___2 << 24);
#line 198
    ft_tab[0][i] = t;
#line 199
    ft_tab[1][i] = (t << 8) | (t >> 24);
#line 200
    ft_tab[2][i] = (t << 16) | (t >> 16);
#line 201
    ft_tab[3][i] = (t << 24) | (t >> 8);
#line 203
    p = isb_tab[i];
#line 207
    t = (unsigned int )p;
#line 207
    il_tab[0][i] = t;
#line 208
    il_tab[1][i] = (t << 8) | (t >> 24);
#line 209
    il_tab[2][i] = (t << 16) | (t >> 16);
#line 210
    il_tab[3][i] = (t << 24) | (t >> 8);
#line 212
    if (p) {
#line 212
      tmp___3 = (int )pow_tab[((int )log_tab[14] + (int )log_tab[p]) % 255];
    } else {
#line 212
      tmp___3 = 0;
    }
#line 212
    if (p) {
#line 212
      tmp___4 = (int )pow_tab[((int )log_tab[9] + (int )log_tab[p]) % 255];
    } else {
#line 212
      tmp___4 = 0;
    }
#line 212
    if (p) {
#line 212
      tmp___5 = (int )pow_tab[((int )log_tab[13] + (int )log_tab[p]) % 255];
    } else {
#line 212
      tmp___5 = 0;
    }
#line 212
    if (p) {
#line 212
      tmp___6 = (int )pow_tab[((int )log_tab[11] + (int )log_tab[p]) % 255];
    } else {
#line 212
      tmp___6 = 0;
    }
#line 212
    t = (((unsigned int )tmp___3 | ((unsigned int )tmp___4 << 8)) | ((unsigned int )tmp___5 << 16)) | ((unsigned int )tmp___6 << 24);
#line 217
    it_tab[0][i] = t;
#line 218
    it_tab[1][i] = (t << 8) | (t >> 24);
#line 219
    it_tab[2][i] = (t << 16) | (t >> 16);
#line 220
    it_tab[3][i] = (t << 24) | (t >> 8);
#line 183
    i ++;
  }
#line 223
  tab_gen = 1U;
#line 224
  return;
}
}
#line 271 "rijndael.c"
rijndael_ctx *rijndael_set_key(rijndael_ctx *ctx , u4byte const   *in_key , u4byte key_len ,
                               int encrypt ) 
{ u4byte i ;
  u4byte t ;
  u4byte u ;
  u4byte v ;
  u4byte w ;
  u4byte *e_key ;
  u4byte *d_key ;

  {
#line 276
  e_key = ctx->e_key;
#line 277
  d_key = ctx->d_key;
#line 279
  ctx->decrypt = ! encrypt;
#line 281
  if (! tab_gen) {
#line 282
    gen_tabs();
  }
#line 284
  ctx->k_len = (key_len + 31U) / 32U;
#line 286
  *(e_key + 0) = (unsigned int )*(in_key + 0);
#line 286
  *(e_key + 1) = (unsigned int )*(in_key + 1);
#line 287
  *(e_key + 2) = (unsigned int )*(in_key + 2);
#line 287
  *(e_key + 3) = (unsigned int )*(in_key + 3);
#line 289
  switch ((int )ctx->k_len) {
  case 4: 
#line 290
  t = *(e_key + 3);
#line 291
  i = 0U;
#line 291
  while (i < 10U) {
#line 292
    t = (((fl_tab[0][(unsigned char )((t >> 8) | (t << 24))] ^ fl_tab[1][(unsigned char )(((t >> 8) | (t << 24)) >> 8)]) ^ fl_tab[2][(unsigned char )(((t >> 8) | (t << 24)) >> 16)]) ^ fl_tab[3][(unsigned char )(((t >> 8) | (t << 24)) >> 24)]) ^ rco_tab[i];
#line 292
    t ^= *(e_key + 4U * i);
#line 292
    *(e_key + (4U * i + 4U)) = t;
#line 292
    t ^= *(e_key + (4U * i + 1U));
#line 292
    *(e_key + (4U * i + 5U)) = t;
#line 292
    t ^= *(e_key + (4U * i + 2U));
#line 292
    *(e_key + (4U * i + 6U)) = t;
#line 292
    t ^= *(e_key + (4U * i + 3U));
#line 292
    *(e_key + (4U * i + 7U)) = t;
#line 291
    i ++;
  }
#line 293
  break;
  case 6: 
#line 295
  *(e_key + 4) = (unsigned int )*(in_key + 4);
#line 295
  *(e_key + 5) = (unsigned int )*(in_key + 5);
#line 295
  t = *(e_key + 5);
#line 296
  i = 0U;
#line 296
  while (i < 8U) {
#line 297
    t = (((fl_tab[0][(unsigned char )((t >> 8) | (t << 24))] ^ fl_tab[1][(unsigned char )(((t >> 8) | (t << 24)) >> 8)]) ^ fl_tab[2][(unsigned char )(((t >> 8) | (t << 24)) >> 16)]) ^ fl_tab[3][(unsigned char )(((t >> 8) | (t << 24)) >> 24)]) ^ rco_tab[i];
#line 297
    t ^= *(e_key + 6U * i);
#line 297
    *(e_key + (6U * i + 6U)) = t;
#line 297
    t ^= *(e_key + (6U * i + 1U));
#line 297
    *(e_key + (6U * i + 7U)) = t;
#line 297
    t ^= *(e_key + (6U * i + 2U));
#line 297
    *(e_key + (6U * i + 8U)) = t;
#line 297
    t ^= *(e_key + (6U * i + 3U));
#line 297
    *(e_key + (6U * i + 9U)) = t;
#line 297
    t ^= *(e_key + (6U * i + 4U));
#line 297
    *(e_key + (6U * i + 10U)) = t;
#line 297
    t ^= *(e_key + (6U * i + 5U));
#line 297
    *(e_key + (6U * i + 11U)) = t;
#line 296
    i ++;
  }
#line 298
  break;
  case 8: 
#line 300
  *(e_key + 4) = (unsigned int )*(in_key + 4);
#line 300
  *(e_key + 5) = (unsigned int )*(in_key + 5);
#line 301
  *(e_key + 6) = (unsigned int )*(in_key + 6);
#line 301
  *(e_key + 7) = (unsigned int )*(in_key + 7);
#line 301
  t = *(e_key + 7);
#line 302
  i = 0U;
#line 302
  while (i < 7U) {
#line 303
    t = (((fl_tab[0][(unsigned char )((t >> 8) | (t << 24))] ^ fl_tab[1][(unsigned char )(((t >> 8) | (t << 24)) >> 8)]) ^ fl_tab[2][(unsigned char )(((t >> 8) | (t << 24)) >> 16)]) ^ fl_tab[3][(unsigned char )(((t >> 8) | (t << 24)) >> 24)]) ^ rco_tab[i];
#line 303
    t ^= *(e_key + 8U * i);
#line 303
    *(e_key + (8U * i + 8U)) = t;
#line 303
    t ^= *(e_key + (8U * i + 1U));
#line 303
    *(e_key + (8U * i + 9U)) = t;
#line 303
    t ^= *(e_key + (8U * i + 2U));
#line 303
    *(e_key + (8U * i + 10U)) = t;
#line 303
    t ^= *(e_key + (8U * i + 3U));
#line 303
    *(e_key + (8U * i + 11U)) = t;
#line 303
    t = *(e_key + (8U * i + 4U)) ^ (((fl_tab[0][(unsigned char )t] ^ fl_tab[1][(unsigned char )(t >> 8)]) ^ fl_tab[2][(unsigned char )(t >> 16)]) ^ fl_tab[3][(unsigned char )(t >> 24)]);
#line 303
    *(e_key + (8U * i + 12U)) = t;
#line 303
    t ^= *(e_key + (8U * i + 5U));
#line 303
    *(e_key + (8U * i + 13U)) = t;
#line 303
    t ^= *(e_key + (8U * i + 6U));
#line 303
    *(e_key + (8U * i + 14U)) = t;
#line 303
    t ^= *(e_key + (8U * i + 7U));
#line 303
    *(e_key + (8U * i + 15U)) = t;
#line 302
    i ++;
  }
#line 304
  break;
  }
#line 307
  if (! encrypt) {
#line 308
    *(d_key + 0) = *(e_key + 0);
#line 308
    *(d_key + 1) = *(e_key + 1);
#line 309
    *(d_key + 2) = *(e_key + 2);
#line 309
    *(d_key + 3) = *(e_key + 3);
#line 311
    i = 4U;
#line 311
    while (i < 4U * ctx->k_len + 24U) {
#line 312
      u = ((*(e_key + i) & 2139062143U) << 1) ^ ((*(e_key + i) & 2155905152U) >> 7) * 27U;
#line 312
      v = ((u & 2139062143U) << 1) ^ ((u & 2155905152U) >> 7) * 27U;
#line 312
      w = ((v & 2139062143U) << 1) ^ ((v & 2155905152U) >> 7) * 27U;
#line 312
      t = w ^ *(e_key + i);
#line 312
      *(d_key + i) = (u ^ v) ^ w;
#line 312
      *(d_key + i) ^= ((((u ^ t) >> 8) | ((u ^ t) << 24)) ^ (((v ^ t) >> 16) | ((v ^ t) << 16))) ^ ((t >> 24) | (t << 8));
#line 311
      i ++;
    }
  }
#line 316
  return (ctx);
}
}
#line 334 "rijndael.c"
void rijndael_encrypt(rijndael_ctx *ctx , u4byte const   *in_blk , u4byte *out_blk ) 
{ u4byte k_len ;
  u4byte *e_key ;
  u4byte b0[4] ;
  u4byte b1[4] ;
  u4byte *kp ;

  {
#line 337
  k_len = ctx->k_len;
#line 338
  e_key = ctx->e_key;
#line 341
  b0[0] = (unsigned int )(*(in_blk + 0) ^ (unsigned int const   )*(e_key + 0));
#line 342
  b0[1] = (unsigned int )(*(in_blk + 1) ^ (unsigned int const   )*(e_key + 1));
#line 343
  b0[2] = (unsigned int )(*(in_blk + 2) ^ (unsigned int const   )*(e_key + 2));
#line 344
  b0[3] = (unsigned int )(*(in_blk + 3) ^ (unsigned int const   )*(e_key + 3));
#line 346
  kp = e_key + 4;
#line 348
  if (k_len > 6U) {
#line 349
    b1[0] = (((ft_tab[0][(unsigned char )b0[0]] ^ ft_tab[1][(unsigned char )(b0[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 0);
#line 349
    b1[1] = (((ft_tab[0][(unsigned char )b0[1]] ^ ft_tab[1][(unsigned char )(b0[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 1);
#line 349
    b1[2] = (((ft_tab[0][(unsigned char )b0[2]] ^ ft_tab[1][(unsigned char )(b0[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 2);
#line 349
    b1[3] = (((ft_tab[0][(unsigned char )b0[3]] ^ ft_tab[1][(unsigned char )(b0[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 3);
#line 349
    kp += 4;
#line 349
    b0[0] = (((ft_tab[0][(unsigned char )b1[0]] ^ ft_tab[1][(unsigned char )(b1[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 0);
#line 349
    b0[1] = (((ft_tab[0][(unsigned char )b1[1]] ^ ft_tab[1][(unsigned char )(b1[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 1);
#line 349
    b0[2] = (((ft_tab[0][(unsigned char )b1[2]] ^ ft_tab[1][(unsigned char )(b1[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 2);
#line 349
    b0[3] = (((ft_tab[0][(unsigned char )b1[3]] ^ ft_tab[1][(unsigned char )(b1[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 3);
#line 349
    kp += 4;
  }
#line 352
  if (k_len > 4U) {
#line 353
    b1[0] = (((ft_tab[0][(unsigned char )b0[0]] ^ ft_tab[1][(unsigned char )(b0[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 0);
#line 353
    b1[1] = (((ft_tab[0][(unsigned char )b0[1]] ^ ft_tab[1][(unsigned char )(b0[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 1);
#line 353
    b1[2] = (((ft_tab[0][(unsigned char )b0[2]] ^ ft_tab[1][(unsigned char )(b0[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 2);
#line 353
    b1[3] = (((ft_tab[0][(unsigned char )b0[3]] ^ ft_tab[1][(unsigned char )(b0[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 3);
#line 353
    kp += 4;
#line 353
    b0[0] = (((ft_tab[0][(unsigned char )b1[0]] ^ ft_tab[1][(unsigned char )(b1[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 0);
#line 353
    b0[1] = (((ft_tab[0][(unsigned char )b1[1]] ^ ft_tab[1][(unsigned char )(b1[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 1);
#line 353
    b0[2] = (((ft_tab[0][(unsigned char )b1[2]] ^ ft_tab[1][(unsigned char )(b1[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 2);
#line 353
    b0[3] = (((ft_tab[0][(unsigned char )b1[3]] ^ ft_tab[1][(unsigned char )(b1[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 3);
#line 353
    kp += 4;
  }
#line 356
  b1[0] = (((ft_tab[0][(unsigned char )b0[0]] ^ ft_tab[1][(unsigned char )(b0[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 0);
#line 356
  b1[1] = (((ft_tab[0][(unsigned char )b0[1]] ^ ft_tab[1][(unsigned char )(b0[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 1);
#line 356
  b1[2] = (((ft_tab[0][(unsigned char )b0[2]] ^ ft_tab[1][(unsigned char )(b0[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 2);
#line 356
  b1[3] = (((ft_tab[0][(unsigned char )b0[3]] ^ ft_tab[1][(unsigned char )(b0[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 3);
#line 356
  kp += 4;
#line 356
  b0[0] = (((ft_tab[0][(unsigned char )b1[0]] ^ ft_tab[1][(unsigned char )(b1[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 0);
#line 356
  b0[1] = (((ft_tab[0][(unsigned char )b1[1]] ^ ft_tab[1][(unsigned char )(b1[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 1);
#line 356
  b0[2] = (((ft_tab[0][(unsigned char )b1[2]] ^ ft_tab[1][(unsigned char )(b1[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 2);
#line 356
  b0[3] = (((ft_tab[0][(unsigned char )b1[3]] ^ ft_tab[1][(unsigned char )(b1[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 3);
#line 356
  kp += 4;
#line 357
  b1[0] = (((ft_tab[0][(unsigned char )b0[0]] ^ ft_tab[1][(unsigned char )(b0[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 0);
#line 357
  b1[1] = (((ft_tab[0][(unsigned char )b0[1]] ^ ft_tab[1][(unsigned char )(b0[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 1);
#line 357
  b1[2] = (((ft_tab[0][(unsigned char )b0[2]] ^ ft_tab[1][(unsigned char )(b0[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 2);
#line 357
  b1[3] = (((ft_tab[0][(unsigned char )b0[3]] ^ ft_tab[1][(unsigned char )(b0[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 3);
#line 357
  kp += 4;
#line 357
  b0[0] = (((ft_tab[0][(unsigned char )b1[0]] ^ ft_tab[1][(unsigned char )(b1[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 0);
#line 357
  b0[1] = (((ft_tab[0][(unsigned char )b1[1]] ^ ft_tab[1][(unsigned char )(b1[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 1);
#line 357
  b0[2] = (((ft_tab[0][(unsigned char )b1[2]] ^ ft_tab[1][(unsigned char )(b1[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 2);
#line 357
  b0[3] = (((ft_tab[0][(unsigned char )b1[3]] ^ ft_tab[1][(unsigned char )(b1[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 3);
#line 357
  kp += 4;
#line 358
  b1[0] = (((ft_tab[0][(unsigned char )b0[0]] ^ ft_tab[1][(unsigned char )(b0[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 0);
#line 358
  b1[1] = (((ft_tab[0][(unsigned char )b0[1]] ^ ft_tab[1][(unsigned char )(b0[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 1);
#line 358
  b1[2] = (((ft_tab[0][(unsigned char )b0[2]] ^ ft_tab[1][(unsigned char )(b0[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 2);
#line 358
  b1[3] = (((ft_tab[0][(unsigned char )b0[3]] ^ ft_tab[1][(unsigned char )(b0[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 3);
#line 358
  kp += 4;
#line 358
  b0[0] = (((ft_tab[0][(unsigned char )b1[0]] ^ ft_tab[1][(unsigned char )(b1[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 0);
#line 358
  b0[1] = (((ft_tab[0][(unsigned char )b1[1]] ^ ft_tab[1][(unsigned char )(b1[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 1);
#line 358
  b0[2] = (((ft_tab[0][(unsigned char )b1[2]] ^ ft_tab[1][(unsigned char )(b1[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 2);
#line 358
  b0[3] = (((ft_tab[0][(unsigned char )b1[3]] ^ ft_tab[1][(unsigned char )(b1[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 3);
#line 358
  kp += 4;
#line 359
  b1[0] = (((ft_tab[0][(unsigned char )b0[0]] ^ ft_tab[1][(unsigned char )(b0[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 0);
#line 359
  b1[1] = (((ft_tab[0][(unsigned char )b0[1]] ^ ft_tab[1][(unsigned char )(b0[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 1);
#line 359
  b1[2] = (((ft_tab[0][(unsigned char )b0[2]] ^ ft_tab[1][(unsigned char )(b0[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 2);
#line 359
  b1[3] = (((ft_tab[0][(unsigned char )b0[3]] ^ ft_tab[1][(unsigned char )(b0[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 3);
#line 359
  kp += 4;
#line 359
  b0[0] = (((ft_tab[0][(unsigned char )b1[0]] ^ ft_tab[1][(unsigned char )(b1[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 0);
#line 359
  b0[1] = (((ft_tab[0][(unsigned char )b1[1]] ^ ft_tab[1][(unsigned char )(b1[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 1);
#line 359
  b0[2] = (((ft_tab[0][(unsigned char )b1[2]] ^ ft_tab[1][(unsigned char )(b1[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 2);
#line 359
  b0[3] = (((ft_tab[0][(unsigned char )b1[3]] ^ ft_tab[1][(unsigned char )(b1[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 3);
#line 359
  kp += 4;
#line 360
  b1[0] = (((ft_tab[0][(unsigned char )b0[0]] ^ ft_tab[1][(unsigned char )(b0[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 0);
#line 360
  b1[1] = (((ft_tab[0][(unsigned char )b0[1]] ^ ft_tab[1][(unsigned char )(b0[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 1);
#line 360
  b1[2] = (((ft_tab[0][(unsigned char )b0[2]] ^ ft_tab[1][(unsigned char )(b0[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 2);
#line 360
  b1[3] = (((ft_tab[0][(unsigned char )b0[3]] ^ ft_tab[1][(unsigned char )(b0[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 3);
#line 360
  kp += 4;
#line 360
  b0[0] = (((fl_tab[0][(unsigned char )b1[0]] ^ fl_tab[1][(unsigned char )(b1[1] >> 8)]) ^ fl_tab[2][(unsigned char )(b1[2] >> 16)]) ^ fl_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 0);
#line 360
  b0[1] = (((fl_tab[0][(unsigned char )b1[1]] ^ fl_tab[1][(unsigned char )(b1[2] >> 8)]) ^ fl_tab[2][(unsigned char )(b1[3] >> 16)]) ^ fl_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 1);
#line 360
  b0[2] = (((fl_tab[0][(unsigned char )b1[2]] ^ fl_tab[1][(unsigned char )(b1[3] >> 8)]) ^ fl_tab[2][(unsigned char )(b1[0] >> 16)]) ^ fl_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 2);
#line 360
  b0[3] = (((fl_tab[0][(unsigned char )b1[3]] ^ fl_tab[1][(unsigned char )(b1[0] >> 8)]) ^ fl_tab[2][(unsigned char )(b1[1] >> 16)]) ^ fl_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 3);
#line 362
  *(out_blk + 0) = b0[0];
#line 362
  *(out_blk + 1) = b0[1];
#line 363
  *(out_blk + 2) = b0[2];
#line 363
  *(out_blk + 3) = b0[3];
#line 364
  return;
}
}
#line 381 "rijndael.c"
void rijndael_decrypt(rijndael_ctx *ctx , u4byte const   *in_blk , u4byte *out_blk ) 
{ u4byte b0[4] ;
  u4byte b1[4] ;
  u4byte *kp ;
  u4byte k_len ;
  u4byte *e_key ;
  u4byte *d_key ;

  {
#line 385
  k_len = ctx->k_len;
#line 386
  e_key = ctx->e_key;
#line 387
  d_key = ctx->d_key;
#line 389
  b0[0] = (unsigned int )(*(in_blk + 0) ^ (unsigned int const   )*(e_key + (4U * k_len + 24U)));
#line 390
  b0[1] = (unsigned int )(*(in_blk + 1) ^ (unsigned int const   )*(e_key + (4U * k_len + 25U)));
#line 391
  b0[2] = (unsigned int )(*(in_blk + 2) ^ (unsigned int const   )*(e_key + (4U * k_len + 26U)));
#line 392
  b0[3] = (unsigned int )(*(in_blk + 3) ^ (unsigned int const   )*(e_key + (4U * k_len + 27U)));
#line 394
  kp = d_key + 4U * (k_len + 5U);
#line 396
  if (k_len > 6U) {
#line 397
    b1[0] = (((it_tab[0][(unsigned char )b0[0]] ^ it_tab[1][(unsigned char )(b0[3] >> 8)]) ^ it_tab[2][(unsigned char )(b0[2] >> 16)]) ^ it_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 0);
#line 397
    b1[1] = (((it_tab[0][(unsigned char )b0[1]] ^ it_tab[1][(unsigned char )(b0[0] >> 8)]) ^ it_tab[2][(unsigned char )(b0[3] >> 16)]) ^ it_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 1);
#line 397
    b1[2] = (((it_tab[0][(unsigned char )b0[2]] ^ it_tab[1][(unsigned char )(b0[1] >> 8)]) ^ it_tab[2][(unsigned char )(b0[0] >> 16)]) ^ it_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 2);
#line 397
    b1[3] = (((it_tab[0][(unsigned char )b0[3]] ^ it_tab[1][(unsigned char )(b0[2] >> 8)]) ^ it_tab[2][(unsigned char )(b0[1] >> 16)]) ^ it_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 3);
#line 397
    kp -= 4;
#line 397
    b0[0] = (((it_tab[0][(unsigned char )b1[0]] ^ it_tab[1][(unsigned char )(b1[3] >> 8)]) ^ it_tab[2][(unsigned char )(b1[2] >> 16)]) ^ it_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 0);
#line 397
    b0[1] = (((it_tab[0][(unsigned char )b1[1]] ^ it_tab[1][(unsigned char )(b1[0] >> 8)]) ^ it_tab[2][(unsigned char )(b1[3] >> 16)]) ^ it_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 1);
#line 397
    b0[2] = (((it_tab[0][(unsigned char )b1[2]] ^ it_tab[1][(unsigned char )(b1[1] >> 8)]) ^ it_tab[2][(unsigned char )(b1[0] >> 16)]) ^ it_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 2);
#line 397
    b0[3] = (((it_tab[0][(unsigned char )b1[3]] ^ it_tab[1][(unsigned char )(b1[2] >> 8)]) ^ it_tab[2][(unsigned char )(b1[1] >> 16)]) ^ it_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 3);
#line 397
    kp -= 4;
  }
#line 400
  if (k_len > 4U) {
#line 401
    b1[0] = (((it_tab[0][(unsigned char )b0[0]] ^ it_tab[1][(unsigned char )(b0[3] >> 8)]) ^ it_tab[2][(unsigned char )(b0[2] >> 16)]) ^ it_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 0);
#line 401
    b1[1] = (((it_tab[0][(unsigned char )b0[1]] ^ it_tab[1][(unsigned char )(b0[0] >> 8)]) ^ it_tab[2][(unsigned char )(b0[3] >> 16)]) ^ it_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 1);
#line 401
    b1[2] = (((it_tab[0][(unsigned char )b0[2]] ^ it_tab[1][(unsigned char )(b0[1] >> 8)]) ^ it_tab[2][(unsigned char )(b0[0] >> 16)]) ^ it_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 2);
#line 401
    b1[3] = (((it_tab[0][(unsigned char )b0[3]] ^ it_tab[1][(unsigned char )(b0[2] >> 8)]) ^ it_tab[2][(unsigned char )(b0[1] >> 16)]) ^ it_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 3);
#line 401
    kp -= 4;
#line 401
    b0[0] = (((it_tab[0][(unsigned char )b1[0]] ^ it_tab[1][(unsigned char )(b1[3] >> 8)]) ^ it_tab[2][(unsigned char )(b1[2] >> 16)]) ^ it_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 0);
#line 401
    b0[1] = (((it_tab[0][(unsigned char )b1[1]] ^ it_tab[1][(unsigned char )(b1[0] >> 8)]) ^ it_tab[2][(unsigned char )(b1[3] >> 16)]) ^ it_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 1);
#line 401
    b0[2] = (((it_tab[0][(unsigned char )b1[2]] ^ it_tab[1][(unsigned char )(b1[1] >> 8)]) ^ it_tab[2][(unsigned char )(b1[0] >> 16)]) ^ it_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 2);
#line 401
    b0[3] = (((it_tab[0][(unsigned char )b1[3]] ^ it_tab[1][(unsigned char )(b1[2] >> 8)]) ^ it_tab[2][(unsigned char )(b1[1] >> 16)]) ^ it_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 3);
#line 401
    kp -= 4;
  }
#line 404
  b1[0] = (((it_tab[0][(unsigned char )b0[0]] ^ it_tab[1][(unsigned char )(b0[3] >> 8)]) ^ it_tab[2][(unsigned char )(b0[2] >> 16)]) ^ it_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 0);
#line 404
  b1[1] = (((it_tab[0][(unsigned char )b0[1]] ^ it_tab[1][(unsigned char )(b0[0] >> 8)]) ^ it_tab[2][(unsigned char )(b0[3] >> 16)]) ^ it_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 1);
#line 404
  b1[2] = (((it_tab[0][(unsigned char )b0[2]] ^ it_tab[1][(unsigned char )(b0[1] >> 8)]) ^ it_tab[2][(unsigned char )(b0[0] >> 16)]) ^ it_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 2);
#line 404
  b1[3] = (((it_tab[0][(unsigned char )b0[3]] ^ it_tab[1][(unsigned char )(b0[2] >> 8)]) ^ it_tab[2][(unsigned char )(b0[1] >> 16)]) ^ it_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 3);
#line 404
  kp -= 4;
#line 404
  b0[0] = (((it_tab[0][(unsigned char )b1[0]] ^ it_tab[1][(unsigned char )(b1[3] >> 8)]) ^ it_tab[2][(unsigned char )(b1[2] >> 16)]) ^ it_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 0);
#line 404
  b0[1] = (((it_tab[0][(unsigned char )b1[1]] ^ it_tab[1][(unsigned char )(b1[0] >> 8)]) ^ it_tab[2][(unsigned char )(b1[3] >> 16)]) ^ it_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 1);
#line 404
  b0[2] = (((it_tab[0][(unsigned char )b1[2]] ^ it_tab[1][(unsigned char )(b1[1] >> 8)]) ^ it_tab[2][(unsigned char )(b1[0] >> 16)]) ^ it_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 2);
#line 404
  b0[3] = (((it_tab[0][(unsigned char )b1[3]] ^ it_tab[1][(unsigned char )(b1[2] >> 8)]) ^ it_tab[2][(unsigned char )(b1[1] >> 16)]) ^ it_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 3);
#line 404
  kp -= 4;
#line 405
  b1[0] = (((it_tab[0][(unsigned char )b0[0]] ^ it_tab[1][(unsigned char )(b0[3] >> 8)]) ^ it_tab[2][(unsigned char )(b0[2] >> 16)]) ^ it_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 0);
#line 405
  b1[1] = (((it_tab[0][(unsigned char )b0[1]] ^ it_tab[1][(unsigned char )(b0[0] >> 8)]) ^ it_tab[2][(unsigned char )(b0[3] >> 16)]) ^ it_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 1);
#line 405
  b1[2] = (((it_tab[0][(unsigned char )b0[2]] ^ it_tab[1][(unsigned char )(b0[1] >> 8)]) ^ it_tab[2][(unsigned char )(b0[0] >> 16)]) ^ it_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 2);
#line 405
  b1[3] = (((it_tab[0][(unsigned char )b0[3]] ^ it_tab[1][(unsigned char )(b0[2] >> 8)]) ^ it_tab[2][(unsigned char )(b0[1] >> 16)]) ^ it_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 3);
#line 405
  kp -= 4;
#line 405
  b0[0] = (((it_tab[0][(unsigned char )b1[0]] ^ it_tab[1][(unsigned char )(b1[3] >> 8)]) ^ it_tab[2][(unsigned char )(b1[2] >> 16)]) ^ it_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 0);
#line 405
  b0[1] = (((it_tab[0][(unsigned char )b1[1]] ^ it_tab[1][(unsigned char )(b1[0] >> 8)]) ^ it_tab[2][(unsigned char )(b1[3] >> 16)]) ^ it_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 1);
#line 405
  b0[2] = (((it_tab[0][(unsigned char )b1[2]] ^ it_tab[1][(unsigned char )(b1[1] >> 8)]) ^ it_tab[2][(unsigned char )(b1[0] >> 16)]) ^ it_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 2);
#line 405
  b0[3] = (((it_tab[0][(unsigned char )b1[3]] ^ it_tab[1][(unsigned char )(b1[2] >> 8)]) ^ it_tab[2][(unsigned char )(b1[1] >> 16)]) ^ it_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 3);
#line 405
  kp -= 4;
#line 406
  b1[0] = (((it_tab[0][(unsigned char )b0[0]] ^ it_tab[1][(unsigned char )(b0[3] >> 8)]) ^ it_tab[2][(unsigned char )(b0[2] >> 16)]) ^ it_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 0);
#line 406
  b1[1] = (((it_tab[0][(unsigned char )b0[1]] ^ it_tab[1][(unsigned char )(b0[0] >> 8)]) ^ it_tab[2][(unsigned char )(b0[3] >> 16)]) ^ it_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 1);
#line 406
  b1[2] = (((it_tab[0][(unsigned char )b0[2]] ^ it_tab[1][(unsigned char )(b0[1] >> 8)]) ^ it_tab[2][(unsigned char )(b0[0] >> 16)]) ^ it_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 2);
#line 406
  b1[3] = (((it_tab[0][(unsigned char )b0[3]] ^ it_tab[1][(unsigned char )(b0[2] >> 8)]) ^ it_tab[2][(unsigned char )(b0[1] >> 16)]) ^ it_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 3);
#line 406
  kp -= 4;
#line 406
  b0[0] = (((it_tab[0][(unsigned char )b1[0]] ^ it_tab[1][(unsigned char )(b1[3] >> 8)]) ^ it_tab[2][(unsigned char )(b1[2] >> 16)]) ^ it_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 0);
#line 406
  b0[1] = (((it_tab[0][(unsigned char )b1[1]] ^ it_tab[1][(unsigned char )(b1[0] >> 8)]) ^ it_tab[2][(unsigned char )(b1[3] >> 16)]) ^ it_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 1);
#line 406
  b0[2] = (((it_tab[0][(unsigned char )b1[2]] ^ it_tab[1][(unsigned char )(b1[1] >> 8)]) ^ it_tab[2][(unsigned char )(b1[0] >> 16)]) ^ it_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 2);
#line 406
  b0[3] = (((it_tab[0][(unsigned char )b1[3]] ^ it_tab[1][(unsigned char )(b1[2] >> 8)]) ^ it_tab[2][(unsigned char )(b1[1] >> 16)]) ^ it_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 3);
#line 406
  kp -= 4;
#line 407
  b1[0] = (((it_tab[0][(unsigned char )b0[0]] ^ it_tab[1][(unsigned char )(b0[3] >> 8)]) ^ it_tab[2][(unsigned char )(b0[2] >> 16)]) ^ it_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 0);
#line 407
  b1[1] = (((it_tab[0][(unsigned char )b0[1]] ^ it_tab[1][(unsigned char )(b0[0] >> 8)]) ^ it_tab[2][(unsigned char )(b0[3] >> 16)]) ^ it_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 1);
#line 407
  b1[2] = (((it_tab[0][(unsigned char )b0[2]] ^ it_tab[1][(unsigned char )(b0[1] >> 8)]) ^ it_tab[2][(unsigned char )(b0[0] >> 16)]) ^ it_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 2);
#line 407
  b1[3] = (((it_tab[0][(unsigned char )b0[3]] ^ it_tab[1][(unsigned char )(b0[2] >> 8)]) ^ it_tab[2][(unsigned char )(b0[1] >> 16)]) ^ it_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 3);
#line 407
  kp -= 4;
#line 407
  b0[0] = (((it_tab[0][(unsigned char )b1[0]] ^ it_tab[1][(unsigned char )(b1[3] >> 8)]) ^ it_tab[2][(unsigned char )(b1[2] >> 16)]) ^ it_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 0);
#line 407
  b0[1] = (((it_tab[0][(unsigned char )b1[1]] ^ it_tab[1][(unsigned char )(b1[0] >> 8)]) ^ it_tab[2][(unsigned char )(b1[3] >> 16)]) ^ it_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 1);
#line 407
  b0[2] = (((it_tab[0][(unsigned char )b1[2]] ^ it_tab[1][(unsigned char )(b1[1] >> 8)]) ^ it_tab[2][(unsigned char )(b1[0] >> 16)]) ^ it_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 2);
#line 407
  b0[3] = (((it_tab[0][(unsigned char )b1[3]] ^ it_tab[1][(unsigned char )(b1[2] >> 8)]) ^ it_tab[2][(unsigned char )(b1[1] >> 16)]) ^ it_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 3);
#line 407
  kp -= 4;
#line 408
  b1[0] = (((it_tab[0][(unsigned char )b0[0]] ^ it_tab[1][(unsigned char )(b0[3] >> 8)]) ^ it_tab[2][(unsigned char )(b0[2] >> 16)]) ^ it_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 0);
#line 408
  b1[1] = (((it_tab[0][(unsigned char )b0[1]] ^ it_tab[1][(unsigned char )(b0[0] >> 8)]) ^ it_tab[2][(unsigned char )(b0[3] >> 16)]) ^ it_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 1);
#line 408
  b1[2] = (((it_tab[0][(unsigned char )b0[2]] ^ it_tab[1][(unsigned char )(b0[1] >> 8)]) ^ it_tab[2][(unsigned char )(b0[0] >> 16)]) ^ it_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 2);
#line 408
  b1[3] = (((it_tab[0][(unsigned char )b0[3]] ^ it_tab[1][(unsigned char )(b0[2] >> 8)]) ^ it_tab[2][(unsigned char )(b0[1] >> 16)]) ^ it_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 3);
#line 408
  kp -= 4;
#line 408
  b0[0] = (((il_tab[0][(unsigned char )b1[0]] ^ il_tab[1][(unsigned char )(b1[3] >> 8)]) ^ il_tab[2][(unsigned char )(b1[2] >> 16)]) ^ il_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 0);
#line 408
  b0[1] = (((il_tab[0][(unsigned char )b1[1]] ^ il_tab[1][(unsigned char )(b1[0] >> 8)]) ^ il_tab[2][(unsigned char )(b1[3] >> 16)]) ^ il_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 1);
#line 408
  b0[2] = (((il_tab[0][(unsigned char )b1[2]] ^ il_tab[1][(unsigned char )(b1[1] >> 8)]) ^ il_tab[2][(unsigned char )(b1[0] >> 16)]) ^ il_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 2);
#line 408
  b0[3] = (((il_tab[0][(unsigned char )b1[3]] ^ il_tab[1][(unsigned char )(b1[2] >> 8)]) ^ il_tab[2][(unsigned char )(b1[1] >> 16)]) ^ il_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 3);
#line 410
  *(out_blk + 0) = b0[0];
#line 410
  *(out_blk + 1) = b0[1];
#line 411
  *(out_blk + 2) = b0[2];
#line 411
  *(out_blk + 3) = b0[3];
#line 412
  return;
}
}
#line 1 "entropy.o"
#pragma merger(0,"./entropy.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 31 "entropy.h"
void init_rng(void) ;
#line 105 "/usr/include/openssl/rand.h"
extern void RAND_add(void const   *buf , int num , double entropy ) ;
#line 109
extern int RAND_status(void) ;
#line 381 "/usr/include/openssl/crypto.h"
extern unsigned long SSLeay(void) ;
#line 71 "entropy.c"
void check_openssl_version(void) 
{ unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 73
  tmp___0 = SSLeay();
#line 73
  if (tmp___0 != 9469999UL) {
#line 74
    tmp = SSLeay();
#line 74
    fatal("OpenSSL version mismatch. Built against %lx, you have %lx", 9469999L, tmp);
  }
#line 76
  return;
}
}
#line 154 "entropy.c"
int get_random_bytes(unsigned char *buf___2 , int len ) 
{ int random_pool ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 158
  random_pool = open("/dev/urandom", 0);
#line 159
  if (random_pool == -1) {
#line 160
    tmp = __errno_location();
#line 160
    tmp___0 = strerror(*tmp);
#line 160
    error("Couldn\'t open random pool \"%s\": %s", "/dev/urandom", tmp___0);
#line 162
    return (0);
  }
#line 165
  tmp___3 = atomicio((ssize_t (*)())(& read), random_pool, (void *)buf___2, (unsigned int )len);
#line 165
  if (tmp___3 != len) {
#line 166
    tmp___1 = __errno_location();
#line 166
    tmp___2 = strerror(*tmp___1);
#line 166
    error("Couldn\'t read from random pool \"%s\": %s", "/dev/urandom", tmp___2);
#line 168
    close(random_pool);
#line 169
    return (0);
  }
#line 172
  close(random_pool);
#line 174
  return (1);
}
}
#line 183 "entropy.c"
void seed_rng(void) 
{ char buf___2[32] ;
  int tmp ;
  int tmp___0 ;

  {
#line 188
  debug("Seeding random number generator");
#line 190
  tmp___0 = get_random_bytes((unsigned char *)(buf___2), (int )sizeof(buf___2));
#line 190
  if (tmp___0) {
#line 194
    RAND_add((void const   *)(buf___2), (int )sizeof(buf___2), (double )sizeof(buf___2));
  } else {
#line 191
    tmp = RAND_status();
#line 191
    if (! tmp) {
#line 192
      fatal("Entropy collection failed and entropy exhausted");
    }
  }
#line 197
  memset((void *)(buf___2), '\000', sizeof(buf___2));
#line 198
  return;
}
}
#line 200 "entropy.c"
void init_rng(void) 
{ 

  {
#line 202
  check_openssl_version();
#line 203
  return;
}
}
#line 1 "readpass.o"
#pragma merger(0,"./readpass.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 20 "readpass.h"
char *read_passphrase(char const   *prompt , int from_stdin ) ;
#line 51 "readpass.c"
char *read_passphrase(char const   *prompt , int from_stdin ) 
{ char *tmp ;

  {
#line 54
  tmp = cli_read_passphrase(prompt, from_stdin, 0);
#line 54
  return (tmp);
}
}
#line 1 "rsa.o"
#pragma merger(0,"./rsa.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 230 "/usr/include/openssl/rsa.h"
extern int RSA_public_encrypt(int flen , unsigned char const   *from , unsigned char *to ,
                              RSA *rsa , int padding ) ;
#line 236
extern int RSA_private_decrypt(int flen , unsigned char const   *from , unsigned char *to ,
                               RSA *rsa , int padding ) ;
#line 22 "rsa.h"
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 23
int rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 69 "rsa.c"
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ u_char *inbuf ;
  u_char *outbuf ;
  int len ;
  int ilen ;
  int olen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 75
  tmp = BN_num_bits((BIGNUM const   *)key->e);
#line 75
  if (tmp < 2) {
#line 76
    fatal("rsa_public_encrypt() exponent too small or not odd");
  } else {
#line 75
    if ((key->e)->top > 0) {
#line 75
      if (! (*((key->e)->d + 0) & 1UL)) {
#line 76
        fatal("rsa_public_encrypt() exponent too small or not odd");
      }
    } else {
#line 76
      fatal("rsa_public_encrypt() exponent too small or not odd");
    }
  }
#line 78
  tmp___0 = BN_num_bits((BIGNUM const   *)key->n);
#line 78
  olen = (tmp___0 + 7) / 8;
#line 79
  tmp___1 = xmalloc((unsigned int )olen);
#line 79
  outbuf = (u_char *)tmp___1;
#line 81
  tmp___2 = BN_num_bits((BIGNUM const   *)in);
#line 81
  ilen = (tmp___2 + 7) / 8;
#line 82
  tmp___3 = xmalloc((unsigned int )ilen);
#line 82
  inbuf = (u_char *)tmp___3;
#line 83
  BN_bn2bin((BIGNUM const   *)in, inbuf);
#line 85
  len = RSA_public_encrypt(ilen, (unsigned char const   *)inbuf, outbuf, key, 1);
#line 85
  if (len <= 0) {
#line 87
    fatal("rsa_public_encrypt() failed");
  }
#line 89
  BN_bin2bn((unsigned char const   *)outbuf, len, out);
#line 91
  memset((void *)outbuf, 0, (unsigned int )olen);
#line 92
  memset((void *)inbuf, 0, (unsigned int )ilen);
#line 93
  xfree((void *)outbuf);
#line 94
  xfree((void *)inbuf);
#line 95
  return;
}
}
#line 97 "rsa.c"
int rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ u_char *inbuf ;
  u_char *outbuf ;
  int len ;
  int ilen ;
  int olen ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 103
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 103
  olen = (tmp + 7) / 8;
#line 104
  tmp___0 = xmalloc((unsigned int )olen);
#line 104
  outbuf = (u_char *)tmp___0;
#line 106
  tmp___1 = BN_num_bits((BIGNUM const   *)in);
#line 106
  ilen = (tmp___1 + 7) / 8;
#line 107
  tmp___2 = xmalloc((unsigned int )ilen);
#line 107
  inbuf = (u_char *)tmp___2;
#line 108
  BN_bn2bin((BIGNUM const   *)in, inbuf);
#line 110
  len = RSA_private_decrypt(ilen, (unsigned char const   *)inbuf, outbuf, key, 1);
#line 110
  if (len <= 0) {
#line 112
    error("rsa_private_decrypt() failed");
  } else {
#line 114
    BN_bin2bn((unsigned char const   *)outbuf, len, out);
  }
#line 116
  memset((void *)outbuf, 0, (unsigned int )olen);
#line 117
  memset((void *)inbuf, 0, (unsigned int )ilen);
#line 118
  xfree((void *)outbuf);
#line 119
  xfree((void *)inbuf);
#line 120
  return (len);
}
}
#line 1 "ssh-dss.o"
#pragma merger(0,"./ssh-dss.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 175 "/usr/include/openssl/dsa.h"
extern DSA_SIG *DSA_SIG_new(void) ;
#line 176
extern void DSA_SIG_free(DSA_SIG *a ) ;
#line 180
extern DSA_SIG *DSA_do_sign(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
#line 181
extern int DSA_do_verify(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                         DSA *dsa ) ;
#line 42 "ssh-dss.c"
int ssh_dss_sign(Key *key , u_char **sigp , int *lenp , u_char *data , int datalen ) 
{ u_char *digest___1 ;
  u_char *ret ;
  DSA_SIG *sig ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  u_int rlen ;
  u_int slen ;
  u_int len ;
  u_int dlen ;
  u_char sigblob[40] ;
  Buffer b ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;

  {
#line 51
  tmp = EVP_sha1();
#line 51
  evp_md = (EVP_MD *)tmp;
#line 59
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 60
    error("ssh_dss_sign: no DSA key");
#line 61
    return (-1);
  } else {
#line 59
    if (key->type != 2) {
#line 60
      error("ssh_dss_sign: no DSA key");
#line 61
      return (-1);
    } else {
#line 59
      if ((unsigned int )key->dsa == (unsigned int )((void *)0)) {
#line 60
        error("ssh_dss_sign: no DSA key");
#line 61
        return (-1);
      }
    }
  }
#line 63
  dlen = (unsigned int )evp_md->md_size;
#line 64
  tmp___0 = xmalloc(dlen);
#line 64
  digest___1 = (u_char *)tmp___0;
#line 65
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 66
  EVP_DigestUpdate(& md, (void const   *)data, (unsigned int )datalen);
#line 67
  EVP_DigestFinal(& md, digest___1, (unsigned int *)((void *)0));
#line 69
  sig = DSA_do_sign((unsigned char const   *)digest___1, (int )dlen, key->dsa);
#line 70
  if ((unsigned int )sig == (unsigned int )((void *)0)) {
#line 71
    fatal("ssh_dss_sign: cannot sign");
  }
#line 73
  memset((void *)digest___1, 0, dlen);
#line 74
  xfree((void *)digest___1);
#line 76
  tmp___1 = BN_num_bits((BIGNUM const   *)sig->r);
#line 76
  rlen = (unsigned int )((tmp___1 + 7) / 8);
#line 77
  tmp___2 = BN_num_bits((BIGNUM const   *)sig->s);
#line 77
  slen = (unsigned int )((tmp___2 + 7) / 8);
#line 78
  if (rlen > 20U) {
#line 79
    error("bad sig size %d %d", rlen, slen);
#line 80
    DSA_SIG_free(sig);
#line 81
    return (-1);
  } else {
#line 78
    if (slen > 20U) {
#line 79
      error("bad sig size %d %d", rlen, slen);
#line 80
      DSA_SIG_free(sig);
#line 81
      return (-1);
    }
  }
#line 83
  debug("sig size %d %d", rlen, slen);
#line 85
  memset((void *)(sigblob), 0, 40U);
#line 86
  BN_bn2bin((BIGNUM const   *)sig->r, ((sigblob + 40) - 20) - rlen);
#line 87
  BN_bn2bin((BIGNUM const   *)sig->s, (sigblob + 40) - slen);
#line 88
  DSA_SIG_free(sig);
#line 90
  if (datafellows & 1) {
#line 91
    debug("datafellows");
#line 92
    tmp___3 = xmalloc(40U);
#line 92
    ret = (u_char *)tmp___3;
#line 93
    memcpy((void * __restrict  )ret, (void const   * __restrict  )(sigblob), 40U);
#line 94
    if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 95
      *lenp = 40;
    }
#line 96
    if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 97
      *sigp = ret;
    }
  } else {
#line 100
    buffer_init(& b);
#line 101
    buffer_put_cstring(& b, "ssh-dss");
#line 102
    buffer_put_string(& b, (void const   *)(sigblob), 40U);
#line 103
    len = buffer_len(& b);
#line 104
    tmp___4 = xmalloc(len);
#line 104
    ret = (u_char *)tmp___4;
#line 105
    tmp___5 = buffer_ptr(& b);
#line 105
    memcpy((void * __restrict  )ret, (void const   * __restrict  )tmp___5, len);
#line 106
    buffer_free(& b);
#line 107
    if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 108
      *lenp = (int )len;
    }
#line 109
    if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 110
      *sigp = ret;
    }
  }
#line 112
  return (0);
}
}
#line 114 "ssh-dss.c"
int ssh_dss_verify(Key *key , u_char *signature , int signaturelen , u_char *data ,
                   int datalen ) 
{ Buffer b ;
  u_char *digest___1 ;
  DSA_SIG *sig ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  u_char *sigblob ;
  char *txt ;
  u_int len ;
  u_int dlen ;
  int rlen ;
  int ret ;
  char *ktype ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  u_int tmp___11 ;
  void *tmp___12 ;

  {
#line 123
  tmp = EVP_sha1();
#line 123
  evp_md = (EVP_MD *)tmp;
#line 131
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 132
    error("ssh_dss_verify: no DSA key");
#line 133
    return (-1);
  } else {
#line 131
    if (key->type != 2) {
#line 132
      error("ssh_dss_verify: no DSA key");
#line 133
      return (-1);
    } else {
#line 131
      if ((unsigned int )key->dsa == (unsigned int )((void *)0)) {
#line 132
        error("ssh_dss_verify: no DSA key");
#line 133
        return (-1);
      }
    }
  }
#line 136
  if (! (datafellows & 1)) {
#line 136
    if (signaturelen == 40) {
#line 138
      datafellows |= -2;
#line 139
      log("autodetect SSH_BUG_SIGBLOB");
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 140
    if (datafellows & 1) {
#line 140
      if (signaturelen != 40) {
#line 142
        log("autoremove SSH_BUG_SIGBLOB");
#line 143
        datafellows &= -2;
      }
    }
  }
#line 146
  debug("len %d datafellows %d", signaturelen, datafellows);
#line 149
  if (datafellows & 1) {
#line 150
    sigblob = signature;
#line 151
    len = (unsigned int )signaturelen;
  } else {
#line 155
    buffer_init(& b);
#line 156
    buffer_append(& b, (char const   *)((char *)signature), (unsigned int )signaturelen);
#line 157
    ktype = buffer_get_string(& b, (u_int *)((void *)0));
#line 158
    if (0) {
#line 158
      __s1_len = strlen("ssh-dss");
#line 158
      __s2_len = strlen((char const   *)ktype);
#line 158
      if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
        goto _L___1;
      } else {
#line 158
        if (__s1_len >= 4U) {
          _L___1: /* CIL Label */ 
#line 158
          if (! ((unsigned int )((void const   *)(ktype + 1)) - (unsigned int )((void const   *)ktype) == 1U)) {
#line 158
            tmp___9 = 1;
          } else {
#line 158
            if (__s2_len >= 4U) {
#line 158
              tmp___9 = 1;
            } else {
#line 158
              tmp___9 = 0;
            }
          }
        } else {
#line 158
          tmp___9 = 0;
        }
      }
#line 158
      if (tmp___9) {
#line 158
        tmp___5 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
      } else {
#line 158
        tmp___8 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
#line 158
        tmp___5 = tmp___8;
      }
    } else {
#line 158
      tmp___8 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
#line 158
      tmp___5 = tmp___8;
    }
#line 158
    if (tmp___5 != 0) {
#line 159
      error("ssh_dss_verify: cannot handle type %s", ktype);
#line 160
      buffer_free(& b);
#line 161
      return (-1);
    }
#line 163
    tmp___10 = buffer_get_string(& b, & len);
#line 163
    sigblob = (u_char *)tmp___10;
#line 164
    tmp___11 = buffer_len(& b);
#line 164
    rlen = (int )tmp___11;
#line 165
    if (rlen != 0) {
#line 166
      error("remaining bytes in signature %d", rlen);
#line 167
      buffer_free(& b);
#line 168
      return (-1);
    }
#line 170
    buffer_free(& b);
#line 171
    xfree((void *)ktype);
  }
#line 174
  if (len != 40U) {
#line 175
    fatal("bad sigbloblen %d != SIGBLOB_LEN", len);
  }
#line 179
  sig = DSA_SIG_new();
#line 180
  sig->r = BN_new();
#line 181
  sig->s = BN_new();
#line 182
  BN_bin2bn((unsigned char const   *)sigblob, 20, sig->r);
#line 183
  BN_bin2bn((unsigned char const   *)(sigblob + 20), 20, sig->s);
#line 185
  if (! (datafellows & 1)) {
#line 186
    memset((void *)sigblob, 0, len);
#line 187
    xfree((void *)sigblob);
  }
#line 191
  dlen = (unsigned int )evp_md->md_size;
#line 192
  tmp___12 = xmalloc(dlen);
#line 192
  digest___1 = (u_char *)tmp___12;
#line 193
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 194
  EVP_DigestUpdate(& md, (void const   *)data, (unsigned int )datalen);
#line 195
  EVP_DigestFinal(& md, digest___1, (unsigned int *)((void *)0));
#line 197
  ret = DSA_do_verify((unsigned char const   *)digest___1, (int )dlen, sig, key->dsa);
#line 199
  memset((void *)digest___1, 0, dlen);
#line 200
  xfree((void *)digest___1);
#line 201
  DSA_SIG_free(sig);
#line 203
  switch (ret) {
  case 1: 
#line 205
  txt = (char *)"correct";
#line 206
  break;
  case 0: 
#line 208
  txt = (char *)"incorrect";
#line 209
  break;
  case -1: 
  default: 
#line 212
  txt = (char *)"error";
#line 213
  break;
  }
#line 215
  debug("ssh_dss_verify: signature %s", txt);
#line 216
  return (ret);
}
}
#line 1 "ssh-rsa.o"
#pragma merger(0,"./ssh-rsa.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 271 "/usr/include/openssl/err.h"
extern char *ERR_error_string(unsigned long e , char *buf ) ;
#line 217 "/usr/include/openssl/rsa.h"
extern int RSA_size(RSA const   * ) ;
#line 284
extern int RSA_sign(int type , unsigned char const   *m , unsigned int m_length ,
                    unsigned char *sigret , unsigned int *siglen , RSA *rsa ) ;
#line 286
extern int RSA_verify(int type , unsigned char const   *m , unsigned int m_length ,
                      unsigned char *sigbuf , unsigned int siglen , RSA *rsa ) ;
#line 39 "ssh-rsa.c"
int ssh_rsa_sign(Key *key , u_char **sigp , int *lenp , u_char *data , int datalen ) 
{ EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  u_char *digest___1 ;
  u_char *sig ;
  u_char *ret ;
  u_int slen ;
  u_int dlen ;
  u_int len ;
  int ok ;
  Buffer b ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int ecode ;
  unsigned long tmp___3 ;
  char *tmp___4 ;
  int diff ;
  void *tmp___5 ;
  char *tmp___6 ;

  {
#line 45
  tmp = EVP_sha1();
#line 45
  evp_md = (EVP_MD *)tmp;
#line 52
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 53
    error("ssh_rsa_sign: no RSA key");
#line 54
    return (-1);
  } else {
#line 52
    if (key->type != 1) {
#line 53
      error("ssh_rsa_sign: no RSA key");
#line 54
      return (-1);
    } else {
#line 52
      if ((unsigned int )key->rsa == (unsigned int )((void *)0)) {
#line 53
        error("ssh_rsa_sign: no RSA key");
#line 54
        return (-1);
      }
    }
  }
#line 56
  tmp___0 = RSA_size((RSA const   *)key->rsa);
#line 56
  slen = (unsigned int )tmp___0;
#line 57
  tmp___1 = xmalloc(slen);
#line 57
  sig = (u_char *)tmp___1;
#line 59
  dlen = (unsigned int )evp_md->md_size;
#line 60
  tmp___2 = xmalloc(dlen);
#line 60
  digest___1 = (u_char *)tmp___2;
#line 61
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 62
  EVP_DigestUpdate(& md, (void const   *)data, (unsigned int )datalen);
#line 63
  EVP_DigestFinal(& md, digest___1, (unsigned int *)((void *)0));
#line 65
  ok = RSA_sign(64, (unsigned char const   *)digest___1, dlen, sig, & len, key->rsa);
#line 66
  memset((void *)digest___1, 'd', dlen);
#line 67
  xfree((void *)digest___1);
#line 69
  if (ok != 1) {
#line 70
    tmp___3 = ERR_get_error();
#line 70
    ecode = (int )tmp___3;
#line 71
    tmp___4 = ERR_error_string((unsigned long )ecode, (char *)((void *)0));
#line 71
    error("ssh_rsa_sign: RSA_sign failed: %s", tmp___4);
#line 72
    xfree((void *)sig);
#line 73
    return (-1);
  }
#line 75
  if (len < slen) {
#line 76
    diff = (int )(slen - len);
#line 77
    debug("slen %d > len %d", slen, len);
#line 78
    memmove((void *)(sig + diff), (void const   *)sig, len);
#line 79
    memset((void *)sig, 0, (unsigned int )diff);
  } else {
#line 80
    if (len > slen) {
#line 81
      error("ssh_rsa_sign: slen %d slen2 %d", slen, len);
#line 82
      xfree((void *)sig);
#line 83
      return (-1);
    }
  }
#line 86
  buffer_init(& b);
#line 87
  buffer_put_cstring(& b, "ssh-rsa");
#line 88
  buffer_put_string(& b, (void const   *)sig, slen);
#line 89
  len = buffer_len(& b);
#line 90
  tmp___5 = xmalloc(len);
#line 90
  ret = (u_char *)tmp___5;
#line 91
  tmp___6 = buffer_ptr(& b);
#line 91
  memcpy((void * __restrict  )ret, (void const   * __restrict  )tmp___6, len);
#line 92
  buffer_free(& b);
#line 93
  memset((void *)sig, 's', slen);
#line 94
  xfree((void *)sig);
#line 96
  if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 97
    *lenp = (int )len;
  }
#line 98
  if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 99
    *sigp = ret;
  }
#line 100
  debug2("ssh_rsa_sign: done");
#line 101
  return (0);
}
}
#line 104 "ssh-rsa.c"
int ssh_rsa_verify(Key *key , u_char *signature , int signaturelen , u_char *data ,
                   int datalen ) 
{ Buffer b ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  char *ktype ;
  u_char *sigblob ;
  u_char *digest___1 ;
  u_int len ;
  u_int dlen ;
  int rlen ;
  int ret ;
  int tmp___0 ;
  int tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  u_int tmp___13 ;
  void *tmp___14 ;
  int ecode ;
  unsigned long tmp___15 ;
  char *tmp___16 ;
  char const   *tmp___17 ;

  {
#line 111
  tmp = EVP_sha1();
#line 111
  evp_md = (EVP_MD *)tmp;
#line 119
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 120
    error("ssh_rsa_verify: no RSA key");
#line 121
    return (-1);
  } else {
#line 119
    if (key->type != 1) {
#line 120
      error("ssh_rsa_verify: no RSA key");
#line 121
      return (-1);
    } else {
#line 119
      if ((unsigned int )key->rsa == (unsigned int )((void *)0)) {
#line 120
        error("ssh_rsa_verify: no RSA key");
#line 121
        return (-1);
      }
    }
  }
#line 123
  tmp___1 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 123
  if (tmp___1 < 768) {
#line 124
    tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 124
    error("ssh_rsa_verify: n too small: %d bits", tmp___0);
#line 126
    return (-1);
  }
#line 128
  buffer_init(& b);
#line 129
  buffer_append(& b, (char const   *)((char *)signature), (unsigned int )signaturelen);
#line 130
  ktype = buffer_get_string(& b, (u_int *)((void *)0));
#line 131
  if (0) {
#line 131
    __s1_len = strlen("ssh-rsa");
#line 131
    __s2_len = strlen((char const   *)ktype);
#line 131
    if (! ((unsigned int )((void const   *)("ssh-rsa" + 1)) - (unsigned int )((void const   *)"ssh-rsa") == 1U)) {
      goto _L___0;
    } else {
#line 131
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 131
        if (! ((unsigned int )((void const   *)(ktype + 1)) - (unsigned int )((void const   *)ktype) == 1U)) {
#line 131
          tmp___11 = 1;
        } else {
#line 131
          if (__s2_len >= 4U) {
#line 131
            tmp___11 = 1;
          } else {
#line 131
            tmp___11 = 0;
          }
        }
      } else {
#line 131
        tmp___11 = 0;
      }
    }
#line 131
    if (tmp___11) {
#line 131
      tmp___7 = __builtin_strcmp("ssh-rsa", (char const   *)ktype);
    } else {
#line 131
      tmp___10 = __builtin_strcmp("ssh-rsa", (char const   *)ktype);
#line 131
      tmp___7 = tmp___10;
    }
  } else {
#line 131
    tmp___10 = __builtin_strcmp("ssh-rsa", (char const   *)ktype);
#line 131
    tmp___7 = tmp___10;
  }
#line 131
  if (tmp___7 != 0) {
#line 132
    error("ssh_rsa_verify: cannot handle type %s", ktype);
#line 133
    buffer_free(& b);
#line 134
    xfree((void *)ktype);
#line 135
    return (-1);
  }
#line 137
  xfree((void *)ktype);
#line 138
  tmp___12 = buffer_get_string(& b, & len);
#line 138
  sigblob = (u_char *)tmp___12;
#line 139
  tmp___13 = buffer_len(& b);
#line 139
  rlen = (int )tmp___13;
#line 140
  buffer_free(& b);
#line 141
  if (rlen != 0) {
#line 142
    error("ssh_rsa_verify: remaining bytes in signature %d", rlen);
#line 143
    return (-1);
  }
#line 146
  dlen = (unsigned int )evp_md->md_size;
#line 147
  tmp___14 = xmalloc(dlen);
#line 147
  digest___1 = (u_char *)tmp___14;
#line 148
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 149
  EVP_DigestUpdate(& md, (void const   *)data, (unsigned int )datalen);
#line 150
  EVP_DigestFinal(& md, digest___1, (unsigned int *)((void *)0));
#line 152
  ret = RSA_verify(64, (unsigned char const   *)digest___1, dlen, sigblob, len, key->rsa);
#line 153
  memset((void *)digest___1, 'd', dlen);
#line 154
  xfree((void *)digest___1);
#line 155
  memset((void *)sigblob, 's', len);
#line 156
  xfree((void *)sigblob);
#line 157
  if (ret == 0) {
#line 158
    tmp___15 = ERR_get_error();
#line 158
    ecode = (int )tmp___15;
#line 159
    tmp___16 = ERR_error_string((unsigned long )ecode, (char *)((void *)0));
#line 159
    error("ssh_rsa_verify: RSA_verify failed: %s", tmp___16);
  }
#line 161
  if (ret == 0) {
#line 161
    tmp___17 = "in";
  } else {
#line 161
    tmp___17 = "";
  }
#line 161
  debug("ssh_rsa_verify: signature %scorrect", tmp___17);
#line 162
  return (ret);
}
}
#line 1 "tildexpand.o"
#pragma merger(0,"./tildexpand.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 111 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 117
extern struct passwd *getpwnam(char const   *__name ) ;
#line 19 "tildexpand.h"
char *tilde_expand_filename(char const   *filename , uid_t my_uid ) ;
#line 24 "tildexpand.c"
char *tilde_expand_filename(char const   *filename , uid_t my_uid ) 
{ char const   *cp ;
  u_int userlen ;
  char *expanded ;
  struct passwd *pw ;
  char user[100] ;
  int len ;
  char *tmp ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;

  {
#line 35
  if ((int const   )*(filename + 0) != 126) {
#line 36
    tmp = xstrdup(filename);
#line 36
    return (tmp);
  }
#line 39
  filename ++;
#line 42
  tmp___1 = __builtin_strchr((char *)filename, '/');
#line 42
  cp = (char const   *)tmp___1;
#line 43
  if (cp) {
#line 44
    userlen = (unsigned int )(cp - filename);
  } else {
#line 46
    userlen = strlen(filename);
  }
#line 47
  if (userlen == 0U) {
#line 48
    pw = getpwuid(my_uid);
  } else {
#line 51
    if (userlen > sizeof(user) - 1U) {
#line 52
      fatal("User name after tilde too long.");
    }
#line 53
    memcpy((void * __restrict  )(user), (void const   * __restrict  )filename, userlen);
#line 54
    user[userlen] = (char)0;
#line 55
    pw = getpwnam((char const   *)(user));
  }
#line 57
  if (! pw) {
#line 58
    fatal("Unknown user %100s.", user);
  }
#line 61
  if (! cp) {
#line 63
    tmp___2 = xstrdup((char const   *)pw->pw_dir);
#line 63
    return (tmp___2);
  }
#line 66
  tmp___3 = strlen((char const   *)pw->pw_dir);
#line 66
  tmp___4 = strlen(cp + 1);
#line 66
  len = (int )((tmp___3 + tmp___4) + 2U);
#line 67
  if (len > 4096) {
#line 68
    fatal("Home directory too long (%d > %d", len - 1, 4095);
  }
#line 69
  tmp___5 = xmalloc((unsigned int )len);
#line 69
  expanded = (char *)tmp___5;
#line 70
  snprintf((char * __restrict  )expanded, (unsigned int )len, (char const   * __restrict  )"%s/%s",
           pw->pw_dir, cp + 1);
#line 71
  return (expanded);
}
}
#line 1 "ttymodes.o"
#pragma merger(0,"./ttymodes.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 49 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) speed_t cfgetospeed(struct termios  const  *__termios_p ) ;
#line 52
extern  __attribute__((__nothrow__)) speed_t cfgetispeed(struct termios  const  *__termios_p ) ;
#line 55
extern  __attribute__((__nothrow__)) int cfsetospeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 58
extern  __attribute__((__nothrow__)) int cfsetispeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 182 "packet.h"
void tty_make_modes(int fd ) ;
#line 185
void tty_parse_modes(int fd , int *n_bytes_ptr ) ;
#line 32 "ttymodes.c"
static int speed_to_baud(speed_t speed ) 
{ 

  {
#line 35
  switch ((int )speed) {
  case 0: 
#line 37
  return (0);
  case 1: 
#line 39
  return (50);
  case 2: 
#line 41
  return (75);
  case 3: 
#line 43
  return (110);
  case 4: 
#line 45
  return (134);
  case 5: 
#line 47
  return (150);
  case 6: 
#line 49
  return (200);
  case 7: 
#line 51
  return (300);
  case 8: 
#line 53
  return (600);
  case 9: 
#line 55
  return (1200);
  case 10: 
#line 57
  return (1800);
  case 11: 
#line 59
  return (2400);
  case 12: 
#line 61
  return (4800);
  case 13: 
#line 63
  return (9600);
  case 14: 
#line 67
  return (19200);
  case 15: 
#line 77
  return (38400);
  case 4097: 
#line 99
  return (57600);
  case 4098: 
#line 107
  return (115200);
  case 4099: 
#line 111
  return (230400);
  default: ;
#line 114
  return (9600);
  }
}
}
#line 121 "ttymodes.c"
static speed_t baud_to_speed(int baud ) 
{ 

  {
#line 124
  switch (baud) {
  case 0: 
#line 126
  return (0U);
  case 50: 
#line 128
  return (1U);
  case 75: 
#line 130
  return (2U);
  case 110: 
#line 132
  return (3U);
  case 134: 
#line 134
  return (4U);
  case 150: 
#line 136
  return (5U);
  case 200: 
#line 138
  return (6U);
  case 300: 
#line 140
  return (7U);
  case 600: 
#line 142
  return (8U);
  case 1200: 
#line 144
  return (9U);
  case 1800: 
#line 146
  return (10U);
  case 2400: 
#line 148
  return (11U);
  case 4800: 
#line 150
  return (12U);
  case 9600: 
#line 152
  return (13U);
  case 19200: 
#line 156
  return (14U);
  case 38400: 
#line 166
  return (15U);
  case 57600: 
#line 188
  return (4097U);
  case 115200: 
#line 196
  return (4098U);
  case 230400: 
#line 200
  return (4099U);
  default: ;
#line 203
  return (13U);
  }
}
}
#line 212 "ttymodes.c"
void tty_make_modes(int fd ) 
{ struct termios tio ;
  int baud ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  speed_t tmp___2 ;
  speed_t tmp___3 ;

  {
#line 218
  tmp___1 = tcgetattr(fd, & tio);
#line 218
  if (tmp___1 < 0) {
#line 219
    packet_put_char(0);
#line 220
    tmp = __errno_location();
#line 220
    tmp___0 = strerror(*tmp);
#line 220
    log("tcgetattr: %.100s", tmp___0);
#line 221
    return;
  }
#line 224
  tmp___2 = cfgetospeed((struct termios  const  *)(& tio));
#line 224
  baud = speed_to_baud(tmp___2);
#line 225
  packet_put_char(193);
#line 226
  packet_put_int((unsigned int )baud);
#line 227
  tmp___3 = cfgetispeed((struct termios  const  *)(& tio));
#line 227
  baud = speed_to_baud(tmp___3);
#line 228
  packet_put_char(192);
#line 229
  packet_put_int((unsigned int )baud);
#line 36 "ttymodes.h"
  packet_put_char(1);
#line 36
  packet_put_char((int )tio.c_cc[0]);
#line 37
  packet_put_char(2);
#line 37
  packet_put_char((int )tio.c_cc[1]);
#line 38
  packet_put_char(3);
#line 38
  packet_put_char((int )tio.c_cc[2]);
#line 40
  packet_put_char(4);
#line 40
  packet_put_char((int )tio.c_cc[3]);
#line 42
  packet_put_char(5);
#line 42
  packet_put_char((int )tio.c_cc[4]);
#line 44
  packet_put_char(6);
#line 44
  packet_put_char((int )tio.c_cc[11]);
#line 47
  packet_put_char(7);
#line 47
  packet_put_char((int )tio.c_cc[16]);
#line 49
  packet_put_char(8);
#line 49
  packet_put_char((int )tio.c_cc[8]);
#line 50
  packet_put_char(9);
#line 50
  packet_put_char((int )tio.c_cc[9]);
#line 52
  packet_put_char(10);
#line 52
  packet_put_char((int )tio.c_cc[10]);
#line 58
  packet_put_char(12);
#line 58
  packet_put_char((int )tio.c_cc[12]);
#line 61
  packet_put_char(13);
#line 61
  packet_put_char((int )tio.c_cc[14]);
#line 64
  packet_put_char(14);
#line 64
  packet_put_char((int )tio.c_cc[15]);
#line 76
  packet_put_char(18);
#line 76
  packet_put_char((int )tio.c_cc[13]);
#line 80
  packet_put_char(30);
#line 80
  packet_put_char((tio.c_iflag & 4U) != 0U);
#line 81
  packet_put_char(31);
#line 81
  packet_put_char((tio.c_iflag & 8U) != 0U);
#line 82
  packet_put_char(32);
#line 82
  packet_put_char((tio.c_iflag & 16U) != 0U);
#line 83
  packet_put_char(33);
#line 83
  packet_put_char((tio.c_iflag & 32U) != 0U);
#line 84
  packet_put_char(34);
#line 84
  packet_put_char((tio.c_iflag & 64U) != 0U);
#line 85
  packet_put_char(35);
#line 85
  packet_put_char((tio.c_iflag & 128U) != 0U);
#line 86
  packet_put_char(36);
#line 86
  packet_put_char((tio.c_iflag & 256U) != 0U);
#line 88
  packet_put_char(37);
#line 88
  packet_put_char((tio.c_iflag & 512U) != 0U);
#line 90
  packet_put_char(38);
#line 90
  packet_put_char((tio.c_iflag & 1024U) != 0U);
#line 91
  packet_put_char(39);
#line 91
  packet_put_char((tio.c_iflag & 2048U) != 0U);
#line 92
  packet_put_char(40);
#line 92
  packet_put_char((tio.c_iflag & 4096U) != 0U);
#line 94
  packet_put_char(41);
#line 94
  packet_put_char((tio.c_iflag & 8192U) != 0U);
#line 97
  packet_put_char(50);
#line 97
  packet_put_char((tio.c_lflag & 1U) != 0U);
#line 98
  packet_put_char(51);
#line 98
  packet_put_char((tio.c_lflag & 2U) != 0U);
#line 100
  packet_put_char(52);
#line 100
  packet_put_char((tio.c_lflag & 4U) != 0U);
#line 102
  packet_put_char(53);
#line 102
  packet_put_char((tio.c_lflag & 8U) != 0U);
#line 103
  packet_put_char(54);
#line 103
  packet_put_char((tio.c_lflag & 16U) != 0U);
#line 104
  packet_put_char(55);
#line 104
  packet_put_char((tio.c_lflag & 32U) != 0U);
#line 105
  packet_put_char(56);
#line 105
  packet_put_char((tio.c_lflag & 64U) != 0U);
#line 106
  packet_put_char(57);
#line 106
  packet_put_char((tio.c_lflag & 128U) != 0U);
#line 107
  packet_put_char(58);
#line 107
  packet_put_char((tio.c_lflag & 256U) != 0U);
#line 109
  packet_put_char(59);
#line 109
  packet_put_char((tio.c_lflag & 32768U) != 0U);
#line 112
  packet_put_char(60);
#line 112
  packet_put_char((tio.c_lflag & 512U) != 0U);
#line 115
  packet_put_char(61);
#line 115
  packet_put_char((tio.c_lflag & 2048U) != 0U);
#line 118
  packet_put_char(62);
#line 118
  packet_put_char((tio.c_lflag & 16384U) != 0U);
#line 121
  packet_put_char(70);
#line 121
  packet_put_char((tio.c_oflag & 1U) != 0U);
#line 123
  packet_put_char(71);
#line 123
  packet_put_char((tio.c_oflag & 2U) != 0U);
#line 125
  packet_put_char(72);
#line 125
  packet_put_char((tio.c_oflag & 4U) != 0U);
#line 127
  packet_put_char(73);
#line 127
  packet_put_char((tio.c_oflag & 8U) != 0U);
#line 130
  packet_put_char(74);
#line 130
  packet_put_char((tio.c_oflag & 16U) != 0U);
#line 133
  packet_put_char(75);
#line 133
  packet_put_char((tio.c_oflag & 32U) != 0U);
#line 136
  packet_put_char(90);
#line 136
  packet_put_char((tio.c_cflag & 32U) != 0U);
#line 137
  packet_put_char(91);
#line 137
  packet_put_char((tio.c_cflag & 48U) != 0U);
#line 138
  packet_put_char(92);
#line 138
  packet_put_char((tio.c_cflag & 256U) != 0U);
#line 139
  packet_put_char(93);
#line 139
  packet_put_char((tio.c_cflag & 512U) != 0U);
#line 249 "ttymodes.c"
  packet_put_char(0);
#line 250
  return;
}
}
#line 256 "ttymodes.c"
void tty_parse_modes(int fd , int *n_bytes_ptr ) 
{ struct termios tio ;
  int opcode ;
  int baud ;
  int n_bytes ;
  int failure ;
  int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  speed_t tmp___2 ;
  int tmp___3 ;
  u_int tmp___4 ;
  speed_t tmp___5 ;
  int tmp___6 ;
  u_int tmp___7 ;
  u_int tmp___8 ;
  u_int tmp___9 ;
  u_int tmp___10 ;
  u_int tmp___11 ;
  u_int tmp___12 ;
  u_int tmp___13 ;
  u_int tmp___14 ;
  u_int tmp___15 ;
  u_int tmp___16 ;
  u_int tmp___17 ;
  u_int tmp___18 ;
  u_int tmp___19 ;
  u_int tmp___20 ;
  u_int tmp___21 ;
  u_int tmp___22 ;
  u_int tmp___23 ;
  u_int tmp___24 ;
  u_int tmp___25 ;
  u_int tmp___26 ;
  u_int tmp___27 ;
  u_int tmp___28 ;
  u_int tmp___29 ;
  u_int tmp___30 ;
  u_int tmp___31 ;
  u_int tmp___32 ;
  u_int tmp___33 ;
  u_int tmp___34 ;
  u_int tmp___35 ;
  u_int tmp___36 ;
  u_int tmp___37 ;
  u_int tmp___38 ;
  u_int tmp___39 ;
  u_int tmp___40 ;
  u_int tmp___41 ;
  u_int tmp___42 ;
  u_int tmp___43 ;
  u_int tmp___44 ;
  u_int tmp___45 ;
  u_int tmp___46 ;
  u_int tmp___47 ;
  u_int tmp___48 ;
  u_int tmp___49 ;
  u_int tmp___50 ;
  u_int tmp___51 ;
  u_int tmp___52 ;
  u_int tmp___53 ;
  u_int tmp___54 ;
  u_int tmp___55 ;
  int _p ;
  int _e ;
  int *tmp___56 ;
  char *tmp___57 ;
  int tmp___58 ;

  {
#line 261
  n_bytes = 0;
#line 262
  failure = 0;
#line 269
  tmp = tcgetattr(fd, & tio);
#line 269
  if (tmp < 0) {
#line 270
    failure = -1;
  }
#line 272
  while (1) {
#line 273
    n_bytes ++;
#line 274
    tmp___0 = packet_get_char();
#line 274
    opcode = (int )tmp___0;
#line 275
    switch (opcode) {
    case 0: 
    goto set;
    case 192: 
#line 280
    n_bytes += 4;
#line 281
    tmp___1 = packet_get_int();
#line 281
    baud = (int )tmp___1;
#line 282
    if (failure != -1) {
#line 282
      tmp___2 = baud_to_speed(baud);
#line 282
      tmp___3 = cfsetispeed(& tio, tmp___2);
#line 282
      if (tmp___3 < 0) {
#line 283
        error("cfsetispeed failed for %d", baud);
      }
    }
#line 284
    break;
    case 193: 
#line 287
    n_bytes += 4;
#line 288
    tmp___4 = packet_get_int();
#line 288
    baud = (int )tmp___4;
#line 289
    if (failure != -1) {
#line 289
      tmp___5 = baud_to_speed(baud);
#line 289
      tmp___6 = cfsetospeed(& tio, tmp___5);
#line 289
      if (tmp___6 < 0) {
#line 290
        error("cfsetospeed failed for %d", baud);
      }
    }
#line 291
    break;
    case 1: 
#line 36 "ttymodes.h"
    n_bytes ++;
#line 36
    tmp___7 = packet_get_char();
#line 36
    tio.c_cc[0] = (unsigned char )tmp___7;
#line 36
    break;
    case 2: 
#line 37
    n_bytes ++;
#line 37
    tmp___8 = packet_get_char();
#line 37
    tio.c_cc[1] = (unsigned char )tmp___8;
#line 37
    break;
    case 3: 
#line 38
    n_bytes ++;
#line 38
    tmp___9 = packet_get_char();
#line 38
    tio.c_cc[2] = (unsigned char )tmp___9;
#line 38
    break;
    case 4: 
#line 40
    n_bytes ++;
#line 40
    tmp___10 = packet_get_char();
#line 40
    tio.c_cc[3] = (unsigned char )tmp___10;
#line 40
    break;
    case 5: 
#line 42
    n_bytes ++;
#line 42
    tmp___11 = packet_get_char();
#line 42
    tio.c_cc[4] = (unsigned char )tmp___11;
#line 42
    break;
    case 6: 
#line 44
    n_bytes ++;
#line 44
    tmp___12 = packet_get_char();
#line 44
    tio.c_cc[11] = (unsigned char )tmp___12;
#line 44
    break;
    case 7: 
#line 47
    n_bytes ++;
#line 47
    tmp___13 = packet_get_char();
#line 47
    tio.c_cc[16] = (unsigned char )tmp___13;
#line 47
    break;
    case 8: 
#line 49
    n_bytes ++;
#line 49
    tmp___14 = packet_get_char();
#line 49
    tio.c_cc[8] = (unsigned char )tmp___14;
#line 49
    break;
    case 9: 
#line 50
    n_bytes ++;
#line 50
    tmp___15 = packet_get_char();
#line 50
    tio.c_cc[9] = (unsigned char )tmp___15;
#line 50
    break;
    case 10: 
#line 52
    n_bytes ++;
#line 52
    tmp___16 = packet_get_char();
#line 52
    tio.c_cc[10] = (unsigned char )tmp___16;
#line 52
    break;
    case 12: 
#line 58
    n_bytes ++;
#line 58
    tmp___17 = packet_get_char();
#line 58
    tio.c_cc[12] = (unsigned char )tmp___17;
#line 58
    break;
    case 13: 
#line 61
    n_bytes ++;
#line 61
    tmp___18 = packet_get_char();
#line 61
    tio.c_cc[14] = (unsigned char )tmp___18;
#line 61
    break;
    case 14: 
#line 64
    n_bytes ++;
#line 64
    tmp___19 = packet_get_char();
#line 64
    tio.c_cc[15] = (unsigned char )tmp___19;
#line 64
    break;
    case 18: 
#line 76
    n_bytes ++;
#line 76
    tmp___20 = packet_get_char();
#line 76
    tio.c_cc[13] = (unsigned char )tmp___20;
#line 76
    break;
    case 30: 
#line 80
    n_bytes ++;
#line 80
    tmp___21 = packet_get_char();
#line 80
    if (tmp___21) {
#line 80
      tio.c_iflag |= 4U;
    } else {
#line 80
      tio.c_iflag &= 4294967291U;
    }
#line 80
    break;
    case 31: 
#line 81
    n_bytes ++;
#line 81
    tmp___22 = packet_get_char();
#line 81
    if (tmp___22) {
#line 81
      tio.c_iflag |= 8U;
    } else {
#line 81
      tio.c_iflag &= 4294967287U;
    }
#line 81
    break;
    case 32: 
#line 82
    n_bytes ++;
#line 82
    tmp___23 = packet_get_char();
#line 82
    if (tmp___23) {
#line 82
      tio.c_iflag |= 16U;
    } else {
#line 82
      tio.c_iflag &= 4294967279U;
    }
#line 82
    break;
    case 33: 
#line 83
    n_bytes ++;
#line 83
    tmp___24 = packet_get_char();
#line 83
    if (tmp___24) {
#line 83
      tio.c_iflag |= 32U;
    } else {
#line 83
      tio.c_iflag &= 4294967263U;
    }
#line 83
    break;
    case 34: 
#line 84
    n_bytes ++;
#line 84
    tmp___25 = packet_get_char();
#line 84
    if (tmp___25) {
#line 84
      tio.c_iflag |= 64U;
    } else {
#line 84
      tio.c_iflag &= 4294967231U;
    }
#line 84
    break;
    case 35: 
#line 85
    n_bytes ++;
#line 85
    tmp___26 = packet_get_char();
#line 85
    if (tmp___26) {
#line 85
      tio.c_iflag |= 128U;
    } else {
#line 85
      tio.c_iflag &= 4294967167U;
    }
#line 85
    break;
    case 36: 
#line 86
    n_bytes ++;
#line 86
    tmp___27 = packet_get_char();
#line 86
    if (tmp___27) {
#line 86
      tio.c_iflag |= 256U;
    } else {
#line 86
      tio.c_iflag &= 4294967039U;
    }
#line 86
    break;
    case 37: 
#line 88
    n_bytes ++;
#line 88
    tmp___28 = packet_get_char();
#line 88
    if (tmp___28) {
#line 88
      tio.c_iflag |= 512U;
    } else {
#line 88
      tio.c_iflag &= 4294966783U;
    }
#line 88
    break;
    case 38: 
#line 90
    n_bytes ++;
#line 90
    tmp___29 = packet_get_char();
#line 90
    if (tmp___29) {
#line 90
      tio.c_iflag |= 1024U;
    } else {
#line 90
      tio.c_iflag &= 4294966271U;
    }
#line 90
    break;
    case 39: 
#line 91
    n_bytes ++;
#line 91
    tmp___30 = packet_get_char();
#line 91
    if (tmp___30) {
#line 91
      tio.c_iflag |= 2048U;
    } else {
#line 91
      tio.c_iflag &= 4294965247U;
    }
#line 91
    break;
    case 40: 
#line 92
    n_bytes ++;
#line 92
    tmp___31 = packet_get_char();
#line 92
    if (tmp___31) {
#line 92
      tio.c_iflag |= 4096U;
    } else {
#line 92
      tio.c_iflag &= 4294963199U;
    }
#line 92
    break;
    case 41: 
#line 94
    n_bytes ++;
#line 94
    tmp___32 = packet_get_char();
#line 94
    if (tmp___32) {
#line 94
      tio.c_iflag |= 8192U;
    } else {
#line 94
      tio.c_iflag &= 4294959103U;
    }
#line 94
    break;
    case 50: 
#line 97
    n_bytes ++;
#line 97
    tmp___33 = packet_get_char();
#line 97
    if (tmp___33) {
#line 97
      tio.c_lflag |= 1U;
    } else {
#line 97
      tio.c_lflag &= 4294967294U;
    }
#line 97
    break;
    case 51: 
#line 98
    n_bytes ++;
#line 98
    tmp___34 = packet_get_char();
#line 98
    if (tmp___34) {
#line 98
      tio.c_lflag |= 2U;
    } else {
#line 98
      tio.c_lflag &= 4294967293U;
    }
#line 98
    break;
    case 52: 
#line 100
    n_bytes ++;
#line 100
    tmp___35 = packet_get_char();
#line 100
    if (tmp___35) {
#line 100
      tio.c_lflag |= 4U;
    } else {
#line 100
      tio.c_lflag &= 4294967291U;
    }
#line 100
    break;
    case 53: 
#line 102
    n_bytes ++;
#line 102
    tmp___36 = packet_get_char();
#line 102
    if (tmp___36) {
#line 102
      tio.c_lflag |= 8U;
    } else {
#line 102
      tio.c_lflag &= 4294967287U;
    }
#line 102
    break;
    case 54: 
#line 103
    n_bytes ++;
#line 103
    tmp___37 = packet_get_char();
#line 103
    if (tmp___37) {
#line 103
      tio.c_lflag |= 16U;
    } else {
#line 103
      tio.c_lflag &= 4294967279U;
    }
#line 103
    break;
    case 55: 
#line 104
    n_bytes ++;
#line 104
    tmp___38 = packet_get_char();
#line 104
    if (tmp___38) {
#line 104
      tio.c_lflag |= 32U;
    } else {
#line 104
      tio.c_lflag &= 4294967263U;
    }
#line 104
    break;
    case 56: 
#line 105
    n_bytes ++;
#line 105
    tmp___39 = packet_get_char();
#line 105
    if (tmp___39) {
#line 105
      tio.c_lflag |= 64U;
    } else {
#line 105
      tio.c_lflag &= 4294967231U;
    }
#line 105
    break;
    case 57: 
#line 106
    n_bytes ++;
#line 106
    tmp___40 = packet_get_char();
#line 106
    if (tmp___40) {
#line 106
      tio.c_lflag |= 128U;
    } else {
#line 106
      tio.c_lflag &= 4294967167U;
    }
#line 106
    break;
    case 58: 
#line 107
    n_bytes ++;
#line 107
    tmp___41 = packet_get_char();
#line 107
    if (tmp___41) {
#line 107
      tio.c_lflag |= 256U;
    } else {
#line 107
      tio.c_lflag &= 4294967039U;
    }
#line 107
    break;
    case 59: 
#line 109
    n_bytes ++;
#line 109
    tmp___42 = packet_get_char();
#line 109
    if (tmp___42) {
#line 109
      tio.c_lflag |= 32768U;
    } else {
#line 109
      tio.c_lflag &= 4294934527U;
    }
#line 109
    break;
    case 60: 
#line 112
    n_bytes ++;
#line 112
    tmp___43 = packet_get_char();
#line 112
    if (tmp___43) {
#line 112
      tio.c_lflag |= 512U;
    } else {
#line 112
      tio.c_lflag &= 4294966783U;
    }
#line 112
    break;
    case 61: 
#line 115
    n_bytes ++;
#line 115
    tmp___44 = packet_get_char();
#line 115
    if (tmp___44) {
#line 115
      tio.c_lflag |= 2048U;
    } else {
#line 115
      tio.c_lflag &= 4294965247U;
    }
#line 115
    break;
    case 62: 
#line 118
    n_bytes ++;
#line 118
    tmp___45 = packet_get_char();
#line 118
    if (tmp___45) {
#line 118
      tio.c_lflag |= 16384U;
    } else {
#line 118
      tio.c_lflag &= 4294950911U;
    }
#line 118
    break;
    case 70: 
#line 121
    n_bytes ++;
#line 121
    tmp___46 = packet_get_char();
#line 121
    if (tmp___46) {
#line 121
      tio.c_oflag |= 1U;
    } else {
#line 121
      tio.c_oflag &= 4294967294U;
    }
#line 121
    break;
    case 71: 
#line 123
    n_bytes ++;
#line 123
    tmp___47 = packet_get_char();
#line 123
    if (tmp___47) {
#line 123
      tio.c_oflag |= 2U;
    } else {
#line 123
      tio.c_oflag &= 4294967293U;
    }
#line 123
    break;
    case 72: 
#line 125
    n_bytes ++;
#line 125
    tmp___48 = packet_get_char();
#line 125
    if (tmp___48) {
#line 125
      tio.c_oflag |= 4U;
    } else {
#line 125
      tio.c_oflag &= 4294967291U;
    }
#line 125
    break;
    case 73: 
#line 127
    n_bytes ++;
#line 127
    tmp___49 = packet_get_char();
#line 127
    if (tmp___49) {
#line 127
      tio.c_oflag |= 8U;
    } else {
#line 127
      tio.c_oflag &= 4294967287U;
    }
#line 127
    break;
    case 74: 
#line 130
    n_bytes ++;
#line 130
    tmp___50 = packet_get_char();
#line 130
    if (tmp___50) {
#line 130
      tio.c_oflag |= 16U;
    } else {
#line 130
      tio.c_oflag &= 4294967279U;
    }
#line 130
    break;
    case 75: 
#line 133
    n_bytes ++;
#line 133
    tmp___51 = packet_get_char();
#line 133
    if (tmp___51) {
#line 133
      tio.c_oflag |= 32U;
    } else {
#line 133
      tio.c_oflag &= 4294967263U;
    }
#line 133
    break;
    case 90: 
#line 136
    n_bytes ++;
#line 136
    tmp___52 = packet_get_char();
#line 136
    if (tmp___52) {
#line 136
      tio.c_cflag |= 32U;
    } else {
#line 136
      tio.c_cflag &= 4294967263U;
    }
#line 136
    break;
    case 91: 
#line 137
    n_bytes ++;
#line 137
    tmp___53 = packet_get_char();
#line 137
    if (tmp___53) {
#line 137
      tio.c_cflag |= 48U;
    } else {
#line 137
      tio.c_cflag &= 4294967247U;
    }
#line 137
    break;
    case 92: 
#line 138
    n_bytes ++;
#line 138
    tmp___54 = packet_get_char();
#line 138
    if (tmp___54) {
#line 138
      tio.c_cflag |= 256U;
    } else {
#line 138
      tio.c_cflag &= 4294967039U;
    }
#line 138
    break;
    case 93: 
#line 139
    n_bytes ++;
#line 139
    tmp___55 = packet_get_char();
#line 139
    if (tmp___55) {
#line 139
      tio.c_cflag |= 512U;
    } else {
#line 139
      tio.c_cflag &= 4294966783U;
    }
#line 139
    break;
    default: 
#line 319 "ttymodes.c"
    debug("Ignoring unsupported tty mode opcode %d (0x%x)", opcode, opcode);
#line 325
    if (opcode >= 0) {
#line 325
      if (opcode < 128) {
#line 326
        n_bytes ++;
#line 327
        packet_get_char();
#line 328
        break;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 334
      if (opcode >= 128) {
#line 334
        if (opcode < 160) {
#line 335
          n_bytes += 4;
#line 336
          packet_get_int();
#line 337
          break;
        }
      }
    }
#line 347
    log("parse_tty_modes: unknown opcode %d", opcode);
#line 348
    while (1) {
#line 348
      _p = 0;
#line 348
      _e = 1;
#line 348
      if (_p != _e) {
#line 348
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "ttymodes.c", 348);
#line 348
        packet_disconnect("Packet integrity error. (%d)", 10);
      }
#line 348
      break;
    }
    goto set;
    }
  }
  set: 
#line 354
  if (*n_bytes_ptr != n_bytes) {
#line 355
    *n_bytes_ptr = n_bytes;
#line 356
    return;
  }
#line 358
  if (failure == -1) {
#line 359
    return;
  }
#line 362
  tmp___58 = tcsetattr(fd, 0, (struct termios  const  *)(& tio));
#line 362
  if (tmp___58 < 0) {
#line 363
    tmp___56 = __errno_location();
#line 363
    tmp___57 = strerror(*tmp___56);
#line 363
    log("Setting tty modes failed: %.100s", tmp___57);
  }
#line 364
  return;
}
}
#line 1 "uidswap.o"
#pragma merger(0,"./uidswap.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 645 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 667
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 677
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 34 "uidswap.h"
void permanently_set_uid(uid_t uid ) ;
#line 34 "uidswap.c"
static uid_t saved_euid  =    (uid_t )0;
#line 41 "uidswap.c"
void temporarily_use_uid(uid_t uid ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 46
  saved_euid = geteuid();
#line 49
  tmp___1 = seteuid(uid);
#line 49
  if (tmp___1 == -1) {
#line 50
    tmp = __errno_location();
#line 50
    tmp___0 = strerror(*tmp);
#line 50
    debug("seteuid %u: %.100s", uid, tmp___0);
  }
#line 60
  return;
}
}
#line 65 "uidswap.c"
void restore_uid(void) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 70
  tmp___1 = seteuid(saved_euid);
#line 70
  if (tmp___1 < 0) {
#line 71
    tmp = __errno_location();
#line 71
    tmp___0 = strerror(*tmp);
#line 71
    debug("seteuid %u: %.100s", saved_euid, tmp___0);
  }
#line 80
  return;
}
}
#line 86 "uidswap.c"
void permanently_set_uid(uid_t uid ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 89
  tmp___1 = setuid(uid);
#line 89
  if (tmp___1 < 0) {
#line 90
    tmp = __errno_location();
#line 90
    tmp___0 = strerror(*tmp);
#line 90
    debug("setuid %u: %.100s", uid, tmp___0);
  }
#line 91
  return;
}
}
#line 1 "uuencode.o"
#pragma merger(0,"./uuencode.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 31 "uuencode.h"
void dump_base64(FILE *fp , u_char *data , int len ) ;
#line 33 "uuencode.c"
int uuencode(u_char *src , u_int srclength , char *target , size_t targsize ) 
{ int tmp ;

  {
#line 37
  tmp = b64_ntop((u_char const   *)src, srclength, target, targsize);
#line 37
  return (tmp);
}
}
#line 40 "uuencode.c"
int uudecode(char const   *src , u_char *target , size_t targsize ) 
{ int len ;
  char *encoded ;
  char *p ;

  {
#line 47
  encoded = xstrdup(src);
#line 49
  p = encoded;
#line 49
  while (1) {
#line 49
    if (! ((int )*p == 32)) {
#line 49
      if (! ((int )*p == 9)) {
#line 49
        break;
      }
    }
#line 49
    p ++;
  }
#line 51
  while (1) {
#line 51
    if ((int )*p != 0) {
#line 51
      if ((int )*p != 32) {
#line 51
        if (! ((int )*p != 9)) {
#line 51
          break;
        }
      } else {
#line 51
        break;
      }
    } else {
#line 51
      break;
    }
#line 51
    p ++;
  }
#line 54
  *p = (char )'\000';
#line 55
  len = b64_pton((char const   *)encoded, target, targsize);
#line 56
  xfree((void *)encoded);
#line 57
  return (len);
}
}
#line 60 "uuencode.c"
void dump_base64(FILE *fp , u_char *data , int len ) 
{ u_char *buf___2 ;
  void *tmp ;
  int i ;
  int n___0 ;

  {
#line 63
  tmp = xmalloc((unsigned int )(2 * len));
#line 63
  buf___2 = (u_char *)tmp;
#line 66
  n___0 = uuencode(data, (unsigned int )len, (char *)buf___2, (unsigned int )(2 * len));
#line 67
  i = 0;
#line 67
  while (i < n___0) {
#line 68
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%c", *(buf___2 + i));
#line 69
    if (i % 70 == 69) {
#line 70
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
    }
#line 67
    i ++;
  }
#line 72
  if (i % 70 != 69) {
#line 73
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  }
#line 74
  xfree((void *)buf___2);
#line 75
  return;
}
}
#line 1 "xmalloc.o"
#pragma merger(0,"./xmalloc.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 589 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 600
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__warn_unused_result__,
__malloc__)) ;
#line 603
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 21 "xmalloc.c"
void *xmalloc(size_t size ) 
{ void *ptr ;

  {
#line 26
  if (size == 0U) {
#line 27
    fatal("xmalloc: zero size");
  }
#line 28
  ptr = malloc(size);
#line 29
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 30
    fatal("xmalloc: out of memory (allocating %lu bytes)", (unsigned long )size);
  }
#line 31
  return (ptr);
}
}
#line 34 "xmalloc.c"
void *xrealloc(void *ptr , size_t new_size ) 
{ void *new_ptr ;

  {
#line 39
  if (new_size == 0U) {
#line 40
    fatal("xrealloc: zero size");
  }
#line 41
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 42
    fatal("xrealloc: NULL pointer given as argument");
  }
#line 43
  new_ptr = realloc(ptr, new_size);
#line 44
  if ((unsigned int )new_ptr == (unsigned int )((void *)0)) {
#line 45
    fatal("xrealloc: out of memory (new_size %lu bytes)", (unsigned long )new_size);
  }
#line 46
  return (new_ptr);
}
}
#line 49 "xmalloc.c"
void xfree(void *ptr ) 
{ 

  {
#line 52
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 53
    fatal("xfree: NULL pointer given as argument");
  }
#line 54
  free(ptr);
#line 55
  return;
}
}
#line 57 "xmalloc.c"
char *xstrdup(char const   *str ) 
{ size_t len ;
  size_t tmp ;
  char *cp ;
  void *tmp___0 ;

  {
#line 60
  tmp = strlen(str);
#line 60
  len = tmp + 1U;
#line 63
  if (len == 0U) {
#line 64
    fatal("xstrdup: zero size");
  }
#line 65
  tmp___0 = xmalloc(len);
#line 65
  cp = (char *)tmp___0;
#line 66
  strlcpy(cp, str, len);
#line 67
  return (cp);
}
}
#line 1 "sshd.o"
#pragma merger(0,"./sshd.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 382
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
#line 433
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 433 "/usr/include/sys/stat.h"
__inline static int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
#line 436
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
#line 436
  return (tmp);
}
}
#line 384 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 393
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 457
extern  __attribute__((__nothrow__)) int chdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 490
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 516
extern  __attribute__((__nothrow__)) int execv(char const   *__path , char * const  *__argv )  __attribute__((__nonnull__(1))) ;
#line 723
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 73
extern int optind ;
#line 152
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 903 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 92 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 747 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 458 "/usr/include/openssl/bn.h"
extern void BN_free(BIGNUM *a ) ;
#line 478
extern int BN_mask_bits(BIGNUM *a , int n ) ;
#line 174 "/usr/include/openssl/dh.h"
extern void DH_free(DH *dh ) ;
#line 176
extern int DH_size(DH const   *dh ) ;
#line 194
extern int DH_compute_key(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
#line 47 "log.h"
void log_init(char *av0 , LogLevel level , SyslogFacility facility , int on_stderr ) ;
#line 121 "servconf.h"
void initialize_server_options(ServerOptions *options___0 ) ;
#line 127
void read_server_config(ServerOptions *options___0 , char const   *filename ) ;
#line 130
void fill_default_server_options(ServerOptions *options___0 ) ;
#line 35 "dh.h"
DH *choose_dh(int minbits ) ;
#line 41 "myproposal.h"
static char *myproposal[10]  = 
#line 41 "myproposal.h"
  {      (char *)"diffie-hellman-group-exchange-sha1,diffie-hellman-group1-sha1",      (char *)"ssh-rsa,ssh-dss",      (char *)"3des-cbc,blowfish-cbc,cast128-cbc,arcfour,aes128-cbc,aes192-cbc,aes256-cbc,rijndael128-cbc,rijndael192-cbc,rijndael256-cbc,rijndael-cbc@lysator.liu.se",      (char *)"3des-cbc,blowfish-cbc,cast128-cbc,arcfour,aes128-cbc,aes192-cbc,aes256-cbc,rijndael128-cbc,rijndael192-cbc,rijndael256-cbc,rijndael-cbc@lysator.liu.se", 
        (char *)"hmac-sha1,hmac-md5,hmac-ripemd160,hmac-ripemd160@openssh.com,hmac-sha1-96,hmac-md5-96",      (char *)"hmac-sha1,hmac-md5,hmac-ripemd160,hmac-ripemd160@openssh.com,hmac-sha1-96,hmac-md5-96",      (char *)"none,zlib",      (char *)"none,zlib", 
        (char *)"",      (char *)""};
#line 119 "auth.h"
void do_authentication(void) ;
#line 120
void do_authentication2(void) ;
#line 92 "sshd.c"
ServerOptions options  ;
#line 95 "sshd.c"
char *config_file_name  =    (char *)"/usr/local/etc/sshd_config";
#line 104 "sshd.c"
int IPv4or6  =    0;
#line 113 "sshd.c"
int debug_flag  =    0;
#line 116 "sshd.c"
int inetd_flag  =    0;
#line 119 "sshd.c"
int no_daemon_flag  =    0;
#line 122 "sshd.c"
int log_stderr  =    0;
#line 125 "sshd.c"
char **saved_argv  ;
#line 126 "sshd.c"
int saved_argc  ;
#line 133 "sshd.c"
int listen_socks[16]  ;
#line 134 "sshd.c"
int num_listen_socks  =    0;
#line 140 "sshd.c"
char *client_version_string  =    (char *)((void *)0);
#line 141 "sshd.c"
char *server_version_string  =    (char *)((void *)0);
#line 151 "sshd.c"
struct __anonstruct_sensitive_data_78 sensitive_data  ;
#line 163 "sshd.c"
int key_do_regen  =    0;
#line 166 "sshd.c"
int received_sighup  =    0;
#line 169 "sshd.c"
u_char session_id[16]  ;
#line 172 "sshd.c"
u_char *session_id2  =    (u_char *)((void *)0);
#line 173 "sshd.c"
int session_id2_len  =    0;
#line 176 "sshd.c"
u_int utmp_len  =    (u_int )64;
#line 179
void do_ssh1_kex(void) ;
#line 180
void do_ssh2_kex(void) ;
#line 182
void ssh_dh1_server(Kex *kex___0 , Buffer *client_kexinit , Buffer *server_kexinit ) ;
#line 183
void ssh_dhgex_server(Kex *kex___0 , Buffer *client_kexinit , Buffer *server_kexinit ) ;
#line 188 "sshd.c"
void close_listen_socks(void) 
{ int i ;

  {
#line 192
  i = 0;
#line 192
  while (i < num_listen_socks) {
#line 193
    close(listen_socks[i]);
#line 192
    i ++;
  }
#line 194
  num_listen_socks = -1;
#line 195
  return;
}
}
#line 202 "sshd.c"
void sighup_handler(int sig ) 
{ 

  {
#line 205
  received_sighup = 1;
#line 206
  signal(1, & sighup_handler);
#line 207
  return;
}
}
#line 213 "sshd.c"
void sighup_restart(void) 
{ int *tmp ;
  char *tmp___0 ;

  {
#line 216
  log("Received SIGHUP; restarting.");
#line 217
  close_listen_socks();
#line 218
  execv((char const   *)*(saved_argv + 0), (char * const  *)saved_argv);
#line 219
  tmp = __errno_location();
#line 219
  tmp___0 = strerror(*tmp);
#line 219
  log("RESTART FAILED: av[0]=\'%.100s\', error: %.100s.", *(saved_argv + 0), tmp___0);
#line 220
  exit(1);
}
}
#line 228 "sshd.c"
void sigterm_handler(int sig ) 
{ 

  {
#line 231
  log("Received signal %d; terminating.", sig);
#line 232
  close_listen_socks();
#line 233
  unlink((char const   *)options.pid_file);
#line 234
  exit(255);
}
}
#line 241 "sshd.c"
void main_sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  int status ;
  __pid_t tmp___0 ;
  int *tmp___1 ;

  {
#line 244
  tmp = __errno_location();
#line 244
  save_errno = *tmp;
#line 247
  while (1) {
#line 247
    tmp___0 = waitpid(-1, & status, 1);
#line 247
    if (! (tmp___0 > 0)) {
#line 247
      break;
    }
  }
#line 250
  signal(17, & main_sigchld_handler);
#line 251
  tmp___1 = __errno_location();
#line 251
  *tmp___1 = save_errno;
#line 252
  return;
}
}
#line 257 "sshd.c"
void grace_alarm_handler(int sig ) 
{ char const   *tmp ;

  {
#line 261
  packet_close();
#line 264
  tmp = get_remote_ipaddr();
#line 264
  fatal("Timeout before authentication for %s.", tmp);
#line 265
  return;
}
}
#line 274 "sshd.c"
void generate_empheral_server_key(void) 
{ char const   *tmp ;

  {
#line 277
  if (sensitive_data.server_key) {
#line 277
    tmp = "new ";
  } else {
#line 277
    tmp = "";
  }
#line 277
  log("Generating %s%d bit RSA key.", tmp, options.server_key_bits);
#line 279
  if ((unsigned int )sensitive_data.server_key != (unsigned int )((void *)0)) {
#line 280
    key_free(sensitive_data.server_key);
  }
#line 281
  sensitive_data.server_key = key_generate(0, (unsigned int )options.server_key_bits);
#line 282
  arc4random_stir();
#line 283
  log("RSA key generation complete.");
#line 284
  return;
}
}
#line 286 "sshd.c"
void key_regeneration_alarm(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 289
  tmp = __errno_location();
#line 289
  save_errno = *tmp;
#line 290
  signal(14, (void (*)(int  ))0);
#line 291
  tmp___0 = __errno_location();
#line 291
  *tmp___0 = save_errno;
#line 292
  key_do_regen = 1;
#line 293
  return;
}
}
#line 295 "sshd.c"
void sshd_exchange_identification(int sock_in , int sock_out ) 
{ int i ;
  int mismatch ;
  int remote_major ;
  int remote_minor ;
  int major ;
  int minor ;
  char *s ;
  char buf___2[256] ;
  char remote_version[256] ;
  char const   *tmp ;
  size_t tmp___0 ;
  ssize_t tmp___1 ;
  size_t tmp___2 ;
  char const   *tmp___3 ;
  ssize_t tmp___4 ;
  int tmp___18 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t tmp___31 ;
  char const   *tmp___32 ;
  int tmp___33 ;
  size_t tmp___34 ;
  char const   *tmp___35 ;

  {
#line 305
  if (options.protocol & 1) {
#line 305
    if (options.protocol & 4) {
#line 307
      major = 1;
#line 308
      minor = 99;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 309
    if (options.protocol & 4) {
#line 310
      major = 2;
#line 311
      minor = 0;
    } else {
#line 313
      major = 1;
#line 314
      minor = 5;
    }
  }
#line 316
  snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"SSH-%d.%d-%.100s\n",
           major, minor, "OpenSSH_2.5.1p2");
#line 317
  server_version_string = xstrdup((char const   *)(buf___2));
#line 319
  if ((unsigned int )client_version_string == (unsigned int )((void *)0)) {
#line 321
    tmp___0 = strlen((char const   *)server_version_string);
#line 321
    tmp___1 = atomicio((ssize_t (*)())(& write), sock_out, (void *)server_version_string,
                       tmp___0);
#line 321
    tmp___2 = strlen((char const   *)server_version_string);
#line 321
    if ((size_t )tmp___1 != tmp___2) {
#line 323
      tmp = get_remote_ipaddr();
#line 323
      log("Could not write ident string to %s.", tmp);
#line 324
      fatal_cleanup();
    }
#line 328
    memset((void *)(buf___2), 0, sizeof(buf___2));
#line 329
    i = 0;
#line 329
    while ((unsigned int )i < sizeof(buf___2) - 1U) {
#line 330
      tmp___4 = atomicio((ssize_t (*)())(& read), sock_in, (void *)(& buf___2[i]),
                         1U);
#line 330
      if (tmp___4 != 1) {
#line 331
        tmp___3 = get_remote_ipaddr();
#line 331
        log("Did not receive identification string from %s.", tmp___3);
#line 333
        fatal_cleanup();
      }
#line 335
      if ((int )buf___2[i] == 13) {
#line 336
        buf___2[i] = (char )'\n';
#line 337
        buf___2[i + 1] = (char)0;
#line 340
        if (i == 12) {
#line 340
          if (0) {
#line 340
            if (0) {
#line 340
              __s1_len___0 = strlen((char const   *)(buf___2));
#line 340
              __s2_len___0 = strlen("SSH-1.5-W1.0");
#line 340
              if (! ((unsigned int )((void const   *)(buf___2 + 1)) - (unsigned int )((void const   *)(buf___2)) == 1U)) {
                goto _L___3;
              } else {
#line 340
                if (__s1_len___0 >= 4U) {
                  _L___3: /* CIL Label */ 
#line 340
                  if (! ((unsigned int )((void const   *)("SSH-1.5-W1.0" + 1)) - (unsigned int )((void const   *)"SSH-1.5-W1.0") == 1U)) {
#line 340
                    tmp___28 = 1;
                  } else {
#line 340
                    if (__s2_len___0 >= 4U) {
#line 340
                      tmp___28 = 1;
                    } else {
#line 340
                      tmp___28 = 0;
                    }
                  }
                } else {
#line 340
                  tmp___28 = 0;
                }
              }
#line 340
              if (tmp___28) {
#line 340
                tmp___24 = __builtin_strcmp((char const   *)(buf___2), "SSH-1.5-W1.0");
              } else {
#line 340
                tmp___27 = __builtin_strcmp((char const   *)(buf___2), "SSH-1.5-W1.0");
#line 340
                tmp___24 = tmp___27;
              }
            } else {
#line 340
              tmp___27 = __builtin_strcmp((char const   *)(buf___2), "SSH-1.5-W1.0");
#line 340
              tmp___24 = tmp___27;
            }
#line 340
            tmp___18 = tmp___24;
          } else {
#line 340
            tmp___18 = strncmp((char const   *)(buf___2), "SSH-1.5-W1.0", 12U);
          }
#line 340
          if (tmp___18 == 0) {
#line 341
            break;
          }
        }
        goto __Cont;
      }
#line 344
      if ((int )buf___2[i] == 10) {
#line 346
        buf___2[i + 1] = (char)0;
#line 347
        break;
      }
      __Cont: /* CIL Label */ 
#line 329
      i ++;
    }
#line 350
    buf___2[sizeof(buf___2) - 1U] = (char)0;
#line 351
    client_version_string = xstrdup((char const   *)(buf___2));
  }
#line 358
  tmp___33 = sscanf((char const   * __restrict  )client_version_string, (char const   * __restrict  )"SSH-%d.%d-%[^\n]\n",
                    & remote_major, & remote_minor, remote_version);
#line 358
  if (tmp___33 != 3) {
#line 360
    s = (char *)"Protocol mismatch.\n";
#line 361
    tmp___31 = strlen((char const   *)s);
#line 361
    atomicio((ssize_t (*)())(& write), sock_out, (void *)s, tmp___31);
#line 362
    close(sock_in);
#line 363
    close(sock_out);
#line 364
    tmp___32 = get_remote_ipaddr();
#line 364
    log("Bad protocol version identification \'%.100s\' from %s", client_version_string,
        tmp___32);
#line 366
    fatal_cleanup();
  }
#line 368
  debug("Client protocol version %d.%d; client software version %.100s", remote_major,
        remote_minor, remote_version);
#line 371
  compat_datafellows((char const   *)(remote_version));
#line 373
  mismatch = 0;
#line 374
  switch (remote_major) {
  case 1: 
#line 376
  if (remote_minor == 99) {
#line 377
    if (options.protocol & 4) {
#line 378
      enable_compat20();
    } else {
#line 380
      mismatch = 1;
    }
#line 381
    break;
  }
#line 383
  if (! (options.protocol & 1)) {
#line 384
    mismatch = 1;
#line 385
    break;
  }
#line 387
  if (remote_minor < 3) {
#line 388
    packet_disconnect("Your ssh version is too old and is no longer supported.  Please install a newer version.");
  } else {
#line 390
    if (remote_minor == 3) {
#line 392
      enable_compat13();
    }
  }
#line 394
  break;
  case 2: 
#line 396
  if (options.protocol & 4) {
#line 397
    enable_compat20();
#line 398
    break;
  }
  default: 
#line 402
  mismatch = 1;
#line 403
  break;
  }
#line 405
  chop(server_version_string);
#line 406
  chop(client_version_string);
#line 407
  debug("Local version string %.200s", server_version_string);
#line 409
  if (mismatch) {
#line 410
    s = (char *)"Protocol major versions differ.\n";
#line 411
    tmp___34 = strlen((char const   *)s);
#line 411
    atomicio((ssize_t (*)())(& write), sock_out, (void *)s, tmp___34);
#line 412
    close(sock_in);
#line 413
    close(sock_out);
#line 414
    tmp___35 = get_remote_ipaddr();
#line 414
    log("Protocol major versions differ for %s: %.200s vs. %.200s", tmp___35, server_version_string,
        client_version_string);
#line 417
    fatal_cleanup();
  }
#line 419
  if (compat20) {
#line 420
    packet_set_ssh2_format();
  }
#line 421
  return;
}
}
#line 425 "sshd.c"
void destroy_sensitive_data(void) 
{ int i ;

  {
#line 430
  if (sensitive_data.server_key) {
#line 431
    key_free(sensitive_data.server_key);
#line 432
    sensitive_data.server_key = (Key *)((void *)0);
  }
#line 434
  i = 0;
#line 434
  while (i < options.num_host_key_files) {
#line 435
    if (*(sensitive_data.host_keys + i)) {
#line 436
      key_free(*(sensitive_data.host_keys + i));
#line 437
      *(sensitive_data.host_keys + i) = (Key *)((void *)0);
    }
#line 434
    i ++;
  }
#line 440
  sensitive_data.ssh1_host_key = (Key *)((void *)0);
#line 441
  return;
}
}
#line 442 "sshd.c"
Key *load_private_key_autodetect(char const   *filename ) 
{ struct stat st ;
  int type ;
  Key *public ;
  Key *private ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 449
  tmp = stat((char const   * __restrict  )filename, (struct stat * __restrict  )(& st));
#line 449
  if (tmp < 0) {
#line 450
    perror(filename);
#line 451
    return ((Key *)((void *)0));
  }
#line 457
  type = 0;
#line 458
  public = key_new(type);
#line 459
  tmp___0 = load_public_key(filename, public, (char **)((void *)0));
#line 459
  if (! tmp___0) {
#line 461
    type = 3;
  }
#line 463
  key_free(public);
#line 466
  private = key_new(type);
#line 467
  tmp___2 = load_private_key(filename, "", private, (char **)((void *)0));
#line 467
  if (tmp___2) {
#line 468
    tmp___1 = key_type(private);
#line 468
    debug("load_private_key_autodetect: type %d %s", private->type, tmp___1);
#line 470
    return (private);
  }
#line 472
  key_free(private);
#line 473
  return ((Key *)((void *)0));
}
}
#line 479 "sshd.c"
static char buf[1024]  ;
#line 476 "sshd.c"
char *list_hostkey_types(void) 
{ int i ;
  Key *key ;
  char *tmp ;
  size_t tmp___0 ;

  {
#line 481
  buf[0] = (char )'\000';
#line 482
  i = 0;
#line 482
  while (i < options.num_host_key_files) {
#line 483
    key = *(sensitive_data.host_keys + i);
#line 484
    if ((unsigned int )key == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 486
    switch (key->type) {
    case 1: 
    case 2: 
#line 489
    tmp = key_ssh_name(key);
#line 489
    strlcat(buf, (char const   *)tmp, sizeof(buf));
#line 490
    strlcat(buf, ",", sizeof(buf));
#line 491
    break;
    }
    __Cont: /* CIL Label */ 
#line 482
    i ++;
  }
#line 494
  tmp___0 = strlen((char const   *)(buf));
#line 494
  i = (int )tmp___0;
#line 495
  if (i > 0) {
#line 495
    if ((int )buf[i - 1] == 44) {
#line 496
      buf[i - 1] = (char )'\000';
    }
  }
#line 497
  debug("list_hostkey_types: %s", buf);
#line 498
  return (buf);
}
}
#line 501 "sshd.c"
Key *get_hostkey_by_type(int type ) 
{ int i ;
  Key *key ;

  {
#line 505
  i = 0;
#line 505
  while (i < options.num_host_key_files) {
#line 506
    key = *(sensitive_data.host_keys + i);
#line 507
    if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 507
      if (key->type == type) {
#line 508
        return (key);
      }
    }
#line 505
    i ++;
  }
#line 510
  return ((Key *)((void *)0));
}
}
#line 519 "sshd.c"
int drop_connection(int startups ) 
{ double p ;
  double r ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 524
  if (startups < options.max_startups_begin) {
#line 525
    return (0);
  }
#line 526
  if (startups >= options.max_startups) {
#line 527
    return (1);
  }
#line 528
  if (options.max_startups_rate == 100) {
#line 529
    return (1);
  }
#line 531
  p = (double )(100 - options.max_startups_rate);
#line 532
  p *= (double )(startups - options.max_startups_begin);
#line 533
  p /= (double )(options.max_startups - options.max_startups_begin);
#line 534
  p += (double )options.max_startups_rate;
#line 535
  p /= 100.0;
#line 536
  tmp = arc4random();
#line 536
  r = (double )tmp / (double )4294967295U;
#line 538
  debug("drop_connection: p %g, r %g", p, r);
#line 539
  if (r < p) {
#line 539
    tmp___0 = 1;
  } else {
#line 539
    tmp___0 = 0;
  }
#line 539
  return (tmp___0);
}
}
#line 542 "sshd.c"
int *startup_pipes  =    (int *)((void *)0);
#line 543 "sshd.c"
int startup_pipe  ;
#line 548 "sshd.c"
int main(int ac , char **av ) 
{ int opt ;
  int sock_in ;
  int sock_out ;
  int newsock ;
  int j ;
  int i ;
  int fdsetsz ;
  int on ;
  pid_t pid ;
  socklen_t fromlen ;
  fd_set *fdset ;
  struct sockaddr_storage from ;
  char const   *remote_ip ;
  int remote_port ;
  FILE *f ;
  struct linger linger ;
  struct addrinfo *ai ;
  char ntop[1025] ;
  char strport[32] ;
  int listen_sock ;
  int maxfd ;
  int startup_p[2] ;
  int startups ;
  int ret ;
  int key_used ;
  u_int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  Key *key ;
  Key *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int fd ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int s1 ;
  int s2 ;
  int tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  int *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  int *tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  __pid_t tmp___27 ;
  void *tmp___28 ;
  void *tmp___29 ;
  int *tmp___30 ;
  char *tmp___31 ;
  int *tmp___32 ;
  register char __result ;
  register char __result___0 ;
  int *tmp___33 ;
  char *tmp___34 ;
  int *tmp___35 ;
  int *tmp___36 ;
  int *tmp___37 ;
  char *tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int *tmp___42 ;
  char *tmp___43 ;
  int *tmp___44 ;
  char *tmp___45 ;
  int tmp___46 ;

  {
#line 553
  sock_in = 0;
#line 553
  sock_out = 0;
#line 553
  on = 1;
#line 566
  startups = 0;
#line 567
  key_used = 0;
#line 569
  __progname = get_progname(*(av + 0));
#line 570
  init_rng();
#line 573
  saved_argc = ac;
#line 574
  saved_argv = av;
#line 577
  initialize_server_options(& options);
#line 580
  while (1) {
#line 580
    opt = getopt(ac, (char * const  *)av, "f:p:b:k:h:g:V:u:dDiqQ46");
#line 580
    if (! (opt != -1)) {
#line 580
      break;
    }
#line 581
    switch (opt) {
    case 52: 
#line 583
    IPv4or6 = 2;
#line 584
    break;
    case 54: 
#line 586
    IPv4or6 = 10;
#line 587
    break;
    case 102: 
#line 589
    config_file_name = optarg;
#line 590
    break;
    case 100: 
#line 592
    if (0 == debug_flag) {
#line 593
      debug_flag = 1;
#line 594
      options.log_level = 5;
    } else {
#line 595
      if ((int )options.log_level < 7) {
#line 596
        options.log_level = (LogLevel )((int )options.log_level + 1);
      } else {
#line 598
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Too high debugging level.\n");
#line 599
        exit(1);
      }
    }
#line 601
    break;
    case 68: 
#line 603
    no_daemon_flag = 1;
#line 604
    break;
    case 105: 
#line 606
    inetd_flag = 1;
#line 607
    break;
    case 81: 
#line 610
    break;
    case 113: 
#line 612
    options.log_level = 0;
#line 613
    break;
    case 98: 
#line 615
    options.server_key_bits = atoi((char const   *)optarg);
#line 616
    break;
    case 112: 
#line 618
    options.ports_from_cmdline = 1U;
#line 619
    if (options.num_ports >= 256U) {
#line 620
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"too many ports.\n");
#line 621
      exit(1);
    }
#line 623
    tmp = options.num_ports;
#line 623
    (options.num_ports) ++;
#line 623
    tmp___0 = atoi((char const   *)optarg);
#line 623
    options.ports[tmp] = (unsigned short )tmp___0;
#line 624
    break;
    case 103: 
#line 626
    options.login_grace_time = atoi((char const   *)optarg);
#line 627
    break;
    case 107: 
#line 629
    options.key_regeneration_time = atoi((char const   *)optarg);
#line 630
    break;
    case 104: 
#line 632
    if (options.num_host_key_files >= 256) {
#line 633
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"too many host keys.\n");
#line 634
      exit(1);
    }
#line 636
    tmp___1 = options.num_host_key_files;
#line 636
    (options.num_host_key_files) ++;
#line 636
    options.host_key_files[tmp___1] = optarg;
#line 637
    break;
    case 86: 
#line 639
    client_version_string = optarg;
#line 641
    inetd_flag = 1;
#line 642
    break;
    case 117: 
#line 644
    tmp___2 = atoi((char const   *)optarg);
#line 644
    utmp_len = (unsigned int )tmp___2;
#line 645
    break;
    case 63: 
    default: 
#line 648
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"sshd version %s\n",
            "OpenSSH_2.5.1p2");
#line 649
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: %s [options]\n",
            __progname);
#line 650
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Options:\n");
#line 651
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -f file    Configuration file (default %s)\n",
            "/usr/local/etc/sshd_config");
#line 652
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -d         Debugging mode (multiple -d means more debugging)\n");
#line 653
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -i         Started from inetd\n");
#line 654
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -D         Do not fork into daemon mode\n");
#line 655
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -q         Quiet (no logging)\n");
#line 656
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -p port    Listen on the specified port (default: 22)\n");
#line 657
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -k seconds Regenerate server key every this many seconds (default: 3600)\n");
#line 658
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -g seconds Grace period for authentication (default: 600)\n");
#line 659
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -b bits    Size of server RSA key (default: 768 bits)\n");
#line 660
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -h file    File from which to read host key (default: %s)\n",
            "/usr/local/etc/ssh_host_key");
#line 662
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -u len     Maximum hostname length for utmp recording\n");
#line 663
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -4         Use IPv4 only\n");
#line 664
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -6         Use IPv6 only\n");
#line 665
    exit(1);
    }
  }
#line 673
  if ((int )options.log_facility == -1) {
#line 673
    tmp___3 = 2;
  } else {
#line 673
    tmp___3 = (int )options.log_facility;
  }
#line 673
  if ((int )options.log_level == -1) {
#line 673
    tmp___4 = 3;
  } else {
#line 673
    tmp___4 = (int )options.log_level;
  }
#line 673
  log_init(__progname, (enum __anonenum_LogLevel_63 )tmp___4, (int )tmp___3, ! inetd_flag);
#line 679
  read_server_config(& options, (char const   *)config_file_name);
#line 682
  fill_default_server_options(& options);
#line 685
  if (optind < ac) {
#line 686
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Extra argument %s.\n",
            *(av + optind));
#line 687
    exit(1);
  }
#line 690
  debug("sshd version %.100s", "OpenSSH_2.5.1p2");
#line 693
  tmp___5 = xmalloc((unsigned int )options.num_host_key_files * sizeof(Key *));
#line 693
  sensitive_data.host_keys = (Key **)tmp___5;
#line 694
  i = 0;
#line 694
  while (i < options.num_host_key_files) {
#line 695
    *(sensitive_data.host_keys + i) = (Key *)((void *)0);
#line 694
    i ++;
  }
#line 696
  sensitive_data.server_key = (Key *)((void *)0);
#line 697
  sensitive_data.ssh1_host_key = (Key *)((void *)0);
#line 698
  sensitive_data.have_ssh1_key = 0;
#line 699
  sensitive_data.have_ssh2_key = 0;
#line 701
  i = 0;
#line 701
  while (i < options.num_host_key_files) {
#line 702
    tmp___6 = load_private_key_autodetect((char const   *)options.host_key_files[i]);
#line 702
    key = tmp___6;
#line 703
    if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 704
      tmp___7 = __errno_location();
#line 704
      tmp___8 = strerror(*tmp___7);
#line 704
      error("Could not load host key: %.200s: %.100s", options.host_key_files[i],
            tmp___8);
      goto __Cont;
    }
#line 708
    switch (key->type) {
    case 0: 
#line 710
    sensitive_data.ssh1_host_key = key;
#line 711
    sensitive_data.have_ssh1_key = 1;
#line 712
    break;
    case 1: 
    case 2: 
#line 715
    sensitive_data.have_ssh2_key = 1;
#line 716
    break;
    }
#line 718
    *(sensitive_data.host_keys + i) = key;
    __Cont: /* CIL Label */ 
#line 701
    i ++;
  }
#line 720
  if (options.protocol & 1) {
#line 720
    if (! sensitive_data.have_ssh1_key) {
#line 721
      log("Disabling protocol version 1. Could not load host key");
#line 722
      options.protocol &= -2;
    }
  }
#line 724
  if (options.protocol & 4) {
#line 724
    if (! sensitive_data.have_ssh2_key) {
#line 725
      log("Disabling protocol version 2. Could not load host key");
#line 726
      options.protocol &= -5;
    }
  }
#line 728
  if (! (options.protocol & 5)) {
#line 729
    log("sshd: no hostkeys available -- exiting.\n");
#line 730
    exit(1);
  }
#line 734
  if (options.protocol & 1) {
#line 735
    if (options.server_key_bits < 512) {
#line 737
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 738
      exit(1);
    } else {
#line 735
      if (options.server_key_bits > 32768) {
#line 737
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 738
        exit(1);
      }
    }
#line 745
    tmp___10 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 745
    if (options.server_key_bits > tmp___10 - 128) {
#line 745
      tmp___11 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 745
      if (options.server_key_bits < tmp___11 + 128) {
#line 749
        tmp___9 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 749
        options.server_key_bits = tmp___9 + 128;
#line 751
        debug("Forcing server key to %d bits to make it differ from host key.", options.server_key_bits);
      }
    }
  }
#line 761
  if (debug_flag) {
#line 761
    if (! inetd_flag) {
#line 762
      log_stderr = 1;
    }
  }
#line 763
  log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 770
  if (! debug_flag) {
#line 770
    if (! inetd_flag) {
#line 770
      if (! no_daemon_flag) {
#line 774
        tmp___14 = daemon(0, 0);
#line 774
        if (tmp___14 < 0) {
#line 775
          tmp___12 = __errno_location();
#line 775
          tmp___13 = strerror(*tmp___12);
#line 775
          fatal("daemon() failed: %.200s", tmp___13);
        }
#line 779
        fd = open("/dev/tty", 258);
#line 780
        if (fd >= 0) {
#line 781
          ioctl(fd, 21538UL, (void *)0);
#line 782
          close(fd);
        }
      }
    }
  }
#line 787
  log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 790
  arc4random_stir();
#line 794
  chdir("/");
#line 797
  if (inetd_flag) {
#line 799
    s1 = dup(0);
#line 800
    s2 = dup(s1);
#line 801
    sock_in = dup(0);
#line 802
    sock_out = dup(1);
#line 803
    startup_pipe = -1;
#line 809
    debug("inetd sockets after dupping: %d, %d", sock_in, sock_out);
#line 810
    if (options.protocol & 1) {
#line 811
      generate_empheral_server_key();
    }
  } else {
#line 813
    ai = options.listen_addrs;
#line 813
    while (ai) {
#line 814
      if (ai->ai_family != 2) {
#line 814
        if (ai->ai_family != 10) {
          goto __Cont___0;
        }
      }
#line 816
      if (num_listen_socks >= 16) {
#line 817
        fatal("Too many listen sockets. Enlarge MAX_LISTEN_SOCKS");
      }
#line 819
      tmp___15 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr,
                             ai->ai_addrlen, (char * __restrict  )(ntop), sizeof(ntop),
                             (char * __restrict  )(strport), sizeof(strport), 3U);
#line 819
      if (tmp___15 != 0) {
#line 822
        error("getnameinfo failed");
        goto __Cont___0;
      }
#line 826
      listen_sock = socket(ai->ai_family, 1, 0);
#line 827
      if (listen_sock < 0) {
#line 829
        tmp___16 = __errno_location();
#line 829
        tmp___17 = strerror(*tmp___16);
#line 829
        verbose("socket: %.100s", tmp___17);
        goto __Cont___0;
      }
#line 832
      tmp___20 = fcntl(listen_sock, 4, 2048);
#line 832
      if (tmp___20 < 0) {
#line 833
        tmp___18 = __errno_location();
#line 833
        tmp___19 = strerror(*tmp___18);
#line 833
        error("listen_sock O_NONBLOCK: %s", tmp___19);
#line 834
        close(listen_sock);
        goto __Cont___0;
      }
#line 843
      setsockopt(listen_sock, 1, 2, (void const   *)((void *)(& on)), sizeof(on));
#line 845
      linger.l_onoff = 1;
#line 846
      linger.l_linger = 5;
#line 847
      setsockopt(listen_sock, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 850
      debug("Bind to port %s on %s.", strport, ntop);
#line 853
      tmp___23 = bind(listen_sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 853
      if (tmp___23 < 0) {
#line 854
        if (! ai->ai_next) {
#line 855
          tmp___21 = __errno_location();
#line 855
          tmp___22 = strerror(*tmp___21);
#line 855
          error("Bind to port %s on %s failed: %.200s.", strport, ntop, tmp___22);
        }
#line 857
        close(listen_sock);
        goto __Cont___0;
      }
#line 860
      listen_socks[num_listen_socks] = listen_sock;
#line 861
      num_listen_socks ++;
#line 864
      log("Server listening on %s port %s.", ntop, strport);
#line 865
      tmp___26 = listen(listen_sock, 5);
#line 865
      if (tmp___26 < 0) {
#line 866
        tmp___24 = __errno_location();
#line 866
        tmp___25 = strerror(*tmp___24);
#line 866
        fatal("listen: %.100s", tmp___25);
      }
      __Cont___0: /* CIL Label */ 
#line 813
      ai = ai->ai_next;
    }
#line 869
    freeaddrinfo(options.listen_addrs);
#line 871
    if (! num_listen_socks) {
#line 872
      fatal("Cannot bind any address.");
    }
#line 874
    if (! debug_flag) {
#line 882
      f = fopen((char const   * __restrict  )options.pid_file, (char const   * __restrict  )"wb");
#line 883
      if (f) {
#line 884
        tmp___27 = getpid();
#line 884
        fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%u\n", (unsigned int )tmp___27);
#line 885
        fclose(f);
      }
    }
#line 888
    if (options.protocol & 1) {
#line 889
      generate_empheral_server_key();
    }
#line 892
    signal(1, & sighup_handler);
#line 894
    signal(15, & sigterm_handler);
#line 895
    signal(3, & sigterm_handler);
#line 898
    signal(17, & main_sigchld_handler);
#line 901
    fdset = (fd_set *)((void *)0);
#line 902
    maxfd = 0;
#line 903
    i = 0;
#line 903
    while (i < num_listen_socks) {
#line 904
      if (listen_socks[i] > maxfd) {
#line 905
        maxfd = listen_socks[i];
      }
#line 903
      i ++;
    }
#line 907
    tmp___28 = xmalloc((unsigned int )options.max_startups * sizeof(int ));
#line 907
    startup_pipes = (int *)tmp___28;
#line 908
    i = 0;
#line 908
    while (i < options.max_startups) {
#line 909
      *(startup_pipes + i) = -1;
#line 908
      i ++;
    }
#line 915
    while (1) {
#line 916
      if (received_sighup) {
#line 917
        sighup_restart();
      }
#line 918
      if ((unsigned int )fdset != (unsigned int )((void *)0)) {
#line 919
        xfree((void *)fdset);
      }
#line 920
      fdsetsz = (int )((((unsigned int )(maxfd + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 921
      tmp___29 = xmalloc((unsigned int )fdsetsz);
#line 921
      fdset = (fd_set *)tmp___29;
#line 922
      memset((void *)fdset, 0, (unsigned int )fdsetsz);
#line 924
      i = 0;
#line 924
      while (i < num_listen_socks) {
#line 925
        __asm__  volatile   ("btsl %1,%0": "=m" (fdset->__fds_bits[(unsigned int )listen_socks[i] / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )listen_socks[i] % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
#line 924
        i ++;
      }
#line 926
      i = 0;
#line 926
      while (i < options.max_startups) {
#line 927
        if (*(startup_pipes + i) != -1) {
#line 928
          __asm__  volatile   ("btsl %1,%0": "=m" (fdset->__fds_bits[(unsigned int )*(startup_pipes + i) / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )*(startup_pipes + i) % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        }
#line 926
        i ++;
      }
#line 931
      ret = select(maxfd + 1, (fd_set * __restrict  )fdset, (fd_set * __restrict  )((void *)0),
                   (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 932
      if (ret < 0) {
#line 932
        tmp___32 = __errno_location();
#line 932
        if (*tmp___32 != 4) {
#line 933
          tmp___30 = __errno_location();
#line 933
          tmp___31 = strerror(*tmp___30);
#line 933
          error("select: %.100s", tmp___31);
        }
      }
#line 934
      if (key_used) {
#line 934
        if (key_do_regen) {
#line 935
          generate_empheral_server_key();
#line 936
          key_used = 0;
#line 937
          key_do_regen = 0;
        }
      }
#line 939
      if (ret < 0) {
        goto __Cont___1;
      }
#line 942
      i = 0;
#line 942
      while (i < options.max_startups) {
#line 944
        if (*(startup_pipes + i) != -1) {
#line 944
          __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )*(startup_pipes + i) % (8U * sizeof(__fd_mask ))),
                               "m" (fdset->__fds_bits[(unsigned int )*(startup_pipes + i) / (8U * sizeof(__fd_mask ))]): "cc");
#line 944
          if (__result) {
#line 951
            close(*(startup_pipes + i));
#line 952
            *(startup_pipes + i) = -1;
#line 953
            startups --;
          }
        }
#line 942
        i ++;
      }
#line 955
      i = 0;
#line 955
      while (i < num_listen_socks) {
#line 956
        __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )listen_socks[i] % (8U * sizeof(__fd_mask ))),
                             "m" (fdset->__fds_bits[(unsigned int )listen_socks[i] / (8U * sizeof(__fd_mask ))]): "cc");
#line 956
        if (! __result___0) {
          goto __Cont___2;
        }
#line 958
        fromlen = sizeof(from);
#line 959
        newsock = accept(listen_socks[i], (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                         (socklen_t * __restrict  )(& fromlen));
#line 961
        if (newsock < 0) {
#line 962
          tmp___35 = __errno_location();
#line 962
          if (*tmp___35 != 4) {
#line 962
            tmp___36 = __errno_location();
#line 962
            if (*tmp___36 != 11) {
#line 963
              tmp___33 = __errno_location();
#line 963
              tmp___34 = strerror(*tmp___33);
#line 963
              error("accept: %.100s", tmp___34);
            }
          }
          goto __Cont___2;
        }
#line 966
        tmp___39 = fcntl(newsock, 4, 0);
#line 966
        if (tmp___39 < 0) {
#line 967
          tmp___37 = __errno_location();
#line 967
          tmp___38 = strerror(*tmp___37);
#line 967
          error("newsock del O_NONBLOCK: %s", tmp___38);
          goto __Cont___2;
        }
#line 970
        tmp___40 = drop_connection(startups);
#line 970
        if (tmp___40 == 1) {
#line 971
          debug("drop connection #%d", startups);
#line 972
          close(newsock);
          goto __Cont___2;
        }
#line 975
        tmp___41 = pipe((int *)(startup_p));
#line 975
        if (tmp___41 == -1) {
#line 976
          close(newsock);
          goto __Cont___2;
        }
#line 980
        j = 0;
#line 980
        while (j < options.max_startups) {
#line 981
          if (*(startup_pipes + j) == -1) {
#line 982
            *(startup_pipes + j) = startup_p[0];
#line 983
            if (maxfd < startup_p[0]) {
#line 984
              maxfd = startup_p[0];
            }
#line 985
            startups ++;
#line 986
            break;
          }
#line 980
          j ++;
        }
#line 993
        if (debug_flag) {
#line 999
          debug("Server will not fork when running in debugging mode.");
#line 1000
          close_listen_socks();
#line 1001
          sock_in = newsock;
#line 1002
          sock_out = newsock;
#line 1003
          startup_pipe = -1;
#line 1004
          pid = getpid();
#line 1005
          break;
        } else {
#line 1012
          pid = fork();
#line 1012
          if (pid == 0) {
#line 1020
            startup_pipe = startup_p[1];
#line 1021
            j = 0;
#line 1021
            while (j < options.max_startups) {
#line 1022
              if (*(startup_pipes + j) != -1) {
#line 1023
                close(*(startup_pipes + j));
              }
#line 1021
              j ++;
            }
#line 1024
            close_listen_socks();
#line 1025
            sock_in = newsock;
#line 1026
            sock_out = newsock;
#line 1027
            log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 1028
            break;
          }
        }
#line 1033
        if (pid < 0) {
#line 1034
          tmp___42 = __errno_location();
#line 1034
          tmp___43 = strerror(*tmp___42);
#line 1034
          error("fork: %.100s", tmp___43);
        } else {
#line 1036
          debug("Forked child %d.", pid);
        }
#line 1038
        close(startup_p[1]);
#line 1041
        if (options.protocol & 1) {
#line 1041
          if (key_used == 0) {
#line 1044
            signal(14, & key_regeneration_alarm);
#line 1045
            alarm((unsigned int )options.key_regeneration_time);
#line 1046
            key_used = 1;
          }
        }
#line 1049
        arc4random_stir();
#line 1052
        close(newsock);
        __Cont___2: /* CIL Label */ 
#line 955
        i ++;
      }
#line 1055
      if (num_listen_socks < 0) {
#line 1056
        break;
      }
      __Cont___1: /* CIL Label */ ;
    }
  }
#line 1067
  alarm(0U);
#line 1068
  signal(14, (void (*)(int  ))0);
#line 1069
  signal(1, (void (*)(int  ))0);
#line 1070
  signal(15, (void (*)(int  ))0);
#line 1071
  signal(3, (void (*)(int  ))0);
#line 1072
  signal(17, (void (*)(int  ))0);
#line 1073
  signal(2, (void (*)(int  ))0);
#line 1081
  linger.l_onoff = 1;
#line 1082
  linger.l_linger = 5;
#line 1083
  setsockopt(sock_in, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 1086
  if (options.keepalives) {
#line 1086
    tmp___46 = setsockopt(sock_in, 1, 9, (void const   *)((void *)(& on)), sizeof(on));
#line 1086
    if (tmp___46 < 0) {
#line 1089
      tmp___44 = __errno_location();
#line 1089
      tmp___45 = strerror(*tmp___44);
#line 1089
      error("setsockopt SO_KEEPALIVE: %.100s", tmp___45);
    }
  }
#line 1095
  packet_set_connection(sock_in, sock_out);
#line 1097
  remote_port = get_remote_port();
#line 1098
  remote_ip = get_remote_ipaddr();
#line 1118
  verbose("Connection from %.500s port %d", remote_ip, remote_port);
#line 1128
  signal(14, & grace_alarm_handler);
#line 1129
  if (! debug_flag) {
#line 1130
    alarm((unsigned int )options.login_grace_time);
  }
#line 1132
  sshd_exchange_identification(sock_in, sock_out);
#line 1140
  if (remote_port >= 1024) {
#line 1142
    debug("Rhosts Authentication disabled, originating port not trusted.");
#line 1144
    options.rhosts_authentication = 0;
  } else {
#line 1140
    if (remote_port < 512) {
#line 1142
      debug("Rhosts Authentication disabled, originating port not trusted.");
#line 1144
      options.rhosts_authentication = 0;
    }
  }
#line 1161
  packet_set_nonblocking();
#line 1165
  if (compat20) {
#line 1166
    do_ssh2_kex();
#line 1167
    do_authentication2();
  } else {
#line 1169
    do_ssh1_kex();
#line 1170
    do_authentication();
  }
#line 1180
  verbose("Closing connection to %.100s", remote_ip);
#line 1186
  packet_close();
#line 1187
  exit(0);
}
}
#line 1193 "sshd.c"
void do_ssh1_kex(void) 
{ int i ;
  int len ;
  int plen ;
  int slen ;
  int rsafail ;
  BIGNUM *session_key_int ;
  u_char session_key[32] ;
  u_char cookie[8] ;
  u_int cipher_type___0 ;
  u_int auth_mask ;
  u_int protocol_flags ;
  u_int32_t rand___0 ;
  int tmp ;
  int tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  char *tmp___6 ;
  int _p ;
  int _e ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char const   *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  char const   *tmp___23 ;

  {
#line 1198
  rsafail = 0;
#line 1203
  rand___0 = (u_int32_t )0;
#line 1214
  i = 0;
#line 1214
  while (i < 8) {
#line 1215
    if (i % 4 == 0) {
#line 1216
      rand___0 = arc4random();
    }
#line 1217
    cookie[i] = (unsigned char )(rand___0 & 255U);
#line 1218
    rand___0 >>= 8;
#line 1214
    i ++;
  }
#line 1226
  packet_start(2);
#line 1227
  i = 0;
#line 1227
  while (i < 8) {
#line 1228
    packet_put_char((int )cookie[i]);
#line 1227
    i ++;
  }
#line 1231
  tmp = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1231
  packet_put_int((unsigned int )tmp);
#line 1232
  packet_put_bignum(((sensitive_data.server_key)->rsa)->e);
#line 1233
  packet_put_bignum(((sensitive_data.server_key)->rsa)->n);
#line 1236
  tmp___0 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1236
  packet_put_int((unsigned int )tmp___0);
#line 1237
  packet_put_bignum(((sensitive_data.ssh1_host_key)->rsa)->e);
#line 1238
  packet_put_bignum(((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1241
  packet_put_int(2U);
#line 1244
  tmp___1 = cipher_mask_ssh1(0);
#line 1244
  packet_put_int(tmp___1);
#line 1247
  auth_mask = 0U;
#line 1248
  if (options.rhosts_authentication) {
#line 1249
    auth_mask |= (unsigned int )(1 << 1);
  }
#line 1250
  if (options.rhosts_rsa_authentication) {
#line 1251
    auth_mask |= (unsigned int )(1 << 4);
  }
#line 1252
  if (options.rsa_authentication) {
#line 1253
    auth_mask |= (unsigned int )(1 << 2);
  }
#line 1264
  if (options.challenge_reponse_authentication == 1) {
#line 1265
    auth_mask |= (unsigned int )(1 << 5);
  }
#line 1266
  if (options.password_authentication) {
#line 1267
    auth_mask |= (unsigned int )(1 << 3);
  }
#line 1268
  packet_put_int(auth_mask);
#line 1271
  packet_send();
#line 1272
  packet_write_wait();
#line 1274
  tmp___2 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1274
  tmp___3 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1274
  debug("Sent %d bit server key and %d bit host key.", tmp___3, tmp___2);
#line 1279
  packet_read_expect(& plen, 3);
#line 1282
  cipher_type___0 = packet_get_char();
#line 1284
  tmp___4 = cipher_mask_ssh1(0);
#line 1284
  if (! (tmp___4 & (unsigned int )(1 << cipher_type___0))) {
#line 1285
    packet_disconnect("Warning: client selects unsupported cipher.");
  }
#line 1289
  i = 0;
#line 1289
  while (i < 8) {
#line 1290
    tmp___5 = packet_get_char();
#line 1290
    if ((u_int )cookie[i] != tmp___5) {
#line 1291
      packet_disconnect("IP Spoofing check bytes do not match.");
    }
#line 1289
    i ++;
  }
#line 1293
  tmp___6 = cipher_name((int )cipher_type___0);
#line 1293
  debug("Encryption type: %.200s", tmp___6);
#line 1296
  session_key_int = BN_new();
#line 1297
  packet_get_bignum(session_key_int, & slen);
#line 1299
  protocol_flags = packet_get_int();
#line 1300
  packet_set_protocol_flags(protocol_flags);
#line 1302
  while (1) {
#line 1302
    _p = plen;
#line 1302
    _e = (9 + slen) + 4;
#line 1302
    if (_p != _e) {
#line 1302
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "sshd.c", 1302);
#line 1302
      packet_disconnect("Packet integrity error. (%d)", 3);
    }
#line 1302
    break;
  }
#line 1308
  tmp___21 = BN_cmp((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n, (BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1308
  if (tmp___21 > 0) {
#line 1310
    tmp___10 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1310
    tmp___11 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1310
    if (tmp___10 < tmp___11 + 128) {
#line 1312
      tmp___7 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1312
      tmp___8 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1312
      tmp___9 = get_remote_ipaddr();
#line 1312
      fatal("do_connection: %s: server_key %d < host_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___9, tmp___8, tmp___7, 128);
    }
#line 1318
    tmp___12 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.server_key)->rsa);
#line 1318
    if (tmp___12 <= 0) {
#line 1320
      rsafail ++;
    }
#line 1321
    tmp___13 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.ssh1_host_key)->rsa);
#line 1321
    if (tmp___13 <= 0) {
#line 1323
      rsafail ++;
    }
  } else {
#line 1326
    tmp___17 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1326
    tmp___18 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1326
    if (tmp___17 < tmp___18 + 128) {
#line 1328
      tmp___14 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1328
      tmp___15 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1328
      tmp___16 = get_remote_ipaddr();
#line 1328
      fatal("do_connection: %s: host_key %d < server_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___16, tmp___15, tmp___14, 128);
    }
#line 1334
    tmp___19 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.ssh1_host_key)->rsa);
#line 1334
    if (tmp___19 < 0) {
#line 1336
      rsafail ++;
    }
#line 1337
    tmp___20 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.server_key)->rsa);
#line 1337
    if (tmp___20 < 0) {
#line 1339
      rsafail ++;
    }
  }
#line 1342
  compute_session_id((u_char *)(session_id), (u_char *)(cookie), ((sensitive_data.ssh1_host_key)->rsa)->n,
                     ((sensitive_data.server_key)->rsa)->n);
#line 1347
  destroy_sensitive_data();
#line 1354
  if (! rsafail) {
#line 1355
    BN_mask_bits(session_key_int, (int )(sizeof(session_key) * 8U));
#line 1356
    tmp___22 = BN_num_bits((BIGNUM const   *)session_key_int);
#line 1356
    len = (tmp___22 + 7) / 8;
#line 1357
    if (len < 0) {
#line 1358
      tmp___23 = get_remote_ipaddr();
#line 1358
      error("do_connection: bad session key len from %s: session_key_int %d > sizeof(session_key) %lu",
            tmp___23, len, (unsigned long )sizeof(session_key));
#line 1361
      rsafail ++;
    } else {
#line 1357
      if ((unsigned int )len > sizeof(session_key)) {
#line 1358
        tmp___23 = get_remote_ipaddr();
#line 1358
        error("do_connection: bad session key len from %s: session_key_int %d > sizeof(session_key) %lu",
              tmp___23, len, (unsigned long )sizeof(session_key));
#line 1361
        rsafail ++;
      } else {
#line 1363
        memset((void *)(session_key), 0, sizeof(session_key));
#line 1364
        BN_bn2bin((BIGNUM const   *)session_key_int, (session_key + sizeof(session_key)) - len);
      }
    }
  }
#line 1368
  if (rsafail) {
#line 1369
    log("do_connection: generating a fake encryption key");
#line 1370
    i = 0;
#line 1370
    while (i < 32) {
#line 1371
      if (i % 4 == 0) {
#line 1372
        rand___0 = arc4random();
      }
#line 1373
      session_key[i] = (unsigned char )(rand___0 & 255U);
#line 1374
      rand___0 >>= 8;
#line 1370
      i ++;
    }
  }
#line 1378
  BN_clear_free(session_key_int);
#line 1381
  i = 0;
#line 1381
  while (i < 16) {
#line 1382
    session_key[i] = (unsigned char )((int )session_key[i] ^ (int )session_id[i]);
#line 1381
    i ++;
  }
#line 1385
  packet_set_encryption_key((u_char const   *)(session_key), 32U, (int )cipher_type___0);
#line 1388
  memset((void *)(session_key), 0, sizeof(session_key));
#line 1390
  debug("Received session key; encryption turned on.");
#line 1393
  packet_start(14);
#line 1394
  packet_send();
#line 1395
  packet_write_wait();
#line 1396
  return;
}
}
#line 1401 "sshd.c"
void do_ssh2_kex(void) 
{ Buffer *server_kexinit ;
  Buffer *client_kexinit ;
  int payload_len ;
  int i ;
  Kex *kex___0 ;
  char *cprop[10] ;
  void *tmp ;

  {
#line 1413
  if ((unsigned int )options.ciphers != (unsigned int )((void *)0)) {
#line 1414
    myproposal[3] = options.ciphers;
#line 1414
    myproposal[2] = myproposal[3];
  }
#line 1417
  if ((unsigned int )options.macs != (unsigned int )((void *)0)) {
#line 1418
    myproposal[5] = options.macs;
#line 1418
    myproposal[4] = myproposal[5];
  }
#line 1421
  myproposal[1] = list_hostkey_types();
#line 1423
  server_kexinit = kex_init((char **)(myproposal));
#line 1424
  tmp = xmalloc(sizeof(*client_kexinit));
#line 1424
  client_kexinit = (Buffer *)tmp;
#line 1425
  buffer_init(client_kexinit);
#line 1428
  kex_exchange_kexinit(server_kexinit, client_kexinit, (char **)(cprop));
#line 1429
  kex___0 = kex_choose_conf((char **)(cprop), (char **)(myproposal), 1);
#line 1430
  i = 0;
#line 1430
  while (i < 10) {
#line 1431
    xfree((void *)cprop[i]);
#line 1430
    i ++;
  }
#line 1433
  switch (kex___0->kex_type) {
  case 0: 
#line 1435
  ssh_dh1_server(kex___0, client_kexinit, server_kexinit);
#line 1436
  break;
  case 1: 
#line 1438
  ssh_dhgex_server(kex___0, client_kexinit, server_kexinit);
#line 1439
  break;
  default: 
#line 1441
  fatal("Unsupported key exchange %d", kex___0->kex_type);
  }
#line 1444
  debug("send SSH2_MSG_NEWKEYS.");
#line 1445
  packet_start(21);
#line 1446
  packet_send();
#line 1447
  packet_write_wait();
#line 1448
  debug("done: send SSH2_MSG_NEWKEYS.");
#line 1450
  debug("Wait SSH2_MSG_NEWKEYS.");
#line 1451
  packet_read_expect(& payload_len, 21);
#line 1452
  debug("GOT SSH2_MSG_NEWKEYS.");
#line 1462
  debug("done: KEX2.");
#line 1463
  return;
}
}
#line 1471 "sshd.c"
void ssh_dh1_server(Kex *kex___0 , Buffer *client_kexinit , Buffer *server_kexinit ) 
{ int payload_len ;
  int dlen ;
  int slen ;
  u_char *signature ;
  u_char *server_host_key_blob ;
  u_int sbloblen ;
  u_int klen ;
  u_int kout ;
  u_char *kbuf ;
  u_char *hash ;
  BIGNUM *shared_secret ;
  DH *dh ;
  BIGNUM *dh_client_pub ;
  Key *hostkey ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  u_int tmp___3 ;
  char *tmp___4 ;
  u_int tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;

  {
#line 1479
  signature = (u_char *)((void *)0);
#line 1480
  server_host_key_blob = (u_char *)((void *)0);
#line 1485
  shared_secret = (BIGNUM *)0;
#line 1487
  dh_client_pub = (BIGNUM *)0;
#line 1490
  hostkey = get_hostkey_by_type(kex___0->hostkey_type);
#line 1491
  if ((unsigned int )hostkey == (unsigned int )((void *)0)) {
#line 1492
    fatal("Unsupported hostkey type %d", kex___0->hostkey_type);
  }
#line 1496
  dh = dh_new_group1();
#line 1497
  dh_gen_key(dh);
#line 1499
  debug("Wait SSH2_MSG_KEXDH_INIT.");
#line 1500
  packet_read_expect(& payload_len, 30);
#line 1503
  dh_client_pub = BN_new();
#line 1504
  if ((unsigned int )dh_client_pub == (unsigned int )((void *)0)) {
#line 1505
    fatal("dh_client_pub == NULL");
  }
#line 1506
  packet_get_bignum2(dh_client_pub, & dlen);
#line 1525
  tmp = dh_pub_is_valid(dh, dh_client_pub);
#line 1525
  if (! tmp) {
#line 1526
    packet_disconnect("bad client public DH value");
  }
#line 1528
  tmp___0 = DH_size((DH const   *)dh);
#line 1528
  klen = (unsigned int )tmp___0;
#line 1529
  tmp___1 = xmalloc(klen);
#line 1529
  kbuf = (u_char *)tmp___1;
#line 1530
  tmp___2 = DH_compute_key(kbuf, (BIGNUM const   *)dh_client_pub, dh);
#line 1530
  kout = (unsigned int )tmp___2;
#line 1539
  shared_secret = BN_new();
#line 1541
  BN_bin2bn((unsigned char const   *)kbuf, (int )kout, shared_secret);
#line 1542
  memset((void *)kbuf, 0, klen);
#line 1543
  xfree((void *)kbuf);
#line 1546
  key_to_blob(hostkey, & server_host_key_blob, & sbloblen);
#line 1549
  tmp___3 = buffer_len(server_kexinit);
#line 1549
  tmp___4 = buffer_ptr(server_kexinit);
#line 1549
  tmp___5 = buffer_len(client_kexinit);
#line 1549
  tmp___6 = buffer_ptr(client_kexinit);
#line 1549
  hash = kex_hash(client_version_string, server_version_string, tmp___6, (int )tmp___5,
                  tmp___4, (int )tmp___3, (char *)server_host_key_blob, (int )sbloblen,
                  dh_client_pub, dh->pub_key, shared_secret);
#line 1559
  buffer_free(client_kexinit);
#line 1560
  buffer_free(server_kexinit);
#line 1561
  xfree((void *)client_kexinit);
#line 1562
  xfree((void *)server_kexinit);
#line 1563
  BN_free(dh_client_pub);
#line 1572
  session_id2_len = 20;
#line 1573
  tmp___7 = xmalloc((unsigned int )session_id2_len);
#line 1573
  session_id2 = (u_char *)tmp___7;
#line 1574
  memcpy((void * __restrict  )session_id2, (void const   * __restrict  )hash, (unsigned int )session_id2_len);
#line 1578
  key_sign(hostkey, & signature, & slen, hash, 20);
#line 1580
  destroy_sensitive_data();
#line 1583
  packet_start(31);
#line 1584
  packet_put_string((char const   *)((char *)server_host_key_blob), sbloblen);
#line 1585
  packet_put_bignum2(dh->pub_key);
#line 1586
  packet_put_string((char const   *)((char *)signature), (unsigned int )slen);
#line 1587
  packet_send();
#line 1588
  xfree((void *)signature);
#line 1589
  xfree((void *)server_host_key_blob);
#line 1590
  packet_write_wait();
#line 1592
  kex_derive_keys(kex___0, hash, shared_secret);
#line 1593
  BN_clear_free(shared_secret);
#line 1594
  packet_set_kex(kex___0);
#line 1597
  DH_free(dh);
#line 1598
  return;
}
}
#line 1602 "sshd.c"
void ssh_dhgex_server(Kex *kex___0 , Buffer *client_kexinit , Buffer *server_kexinit ) 
{ int payload_len ;
  int dlen ;
  int slen ;
  int nbits ;
  u_char *signature ;
  u_char *server_host_key_blob ;
  u_int sbloblen ;
  u_int klen ;
  u_int kout ;
  u_char *kbuf ;
  u_char *hash ;
  BIGNUM *shared_secret ;
  DH *dh ;
  BIGNUM *dh_client_pub ;
  Key *hostkey ;
  u_int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  u_int tmp___4 ;
  char *tmp___5 ;
  u_int tmp___6 ;
  char *tmp___7 ;
  void *tmp___8 ;

  {
#line 1610
  signature = (u_char *)((void *)0);
#line 1611
  server_host_key_blob = (u_char *)((void *)0);
#line 1616
  shared_secret = (BIGNUM *)0;
#line 1618
  dh_client_pub = (BIGNUM *)0;
#line 1621
  hostkey = get_hostkey_by_type(kex___0->hostkey_type);
#line 1622
  if ((unsigned int )hostkey == (unsigned int )((void *)0)) {
#line 1623
    fatal("Unsupported hostkey type %d", kex___0->hostkey_type);
  }
#line 1626
  debug("Wait SSH2_MSG_KEX_DH_GEX_REQUEST.");
#line 1627
  packet_read_expect(& payload_len, 30);
#line 1628
  tmp = packet_get_int();
#line 1628
  nbits = (int )tmp;
#line 1629
  dh = choose_dh(nbits);
#line 1631
  debug("Sending SSH2_MSG_KEX_DH_GEX_GROUP.");
#line 1632
  packet_start(31);
#line 1633
  packet_put_bignum2(dh->p);
#line 1634
  packet_put_bignum2(dh->g);
#line 1635
  packet_send();
#line 1636
  packet_write_wait();
#line 1640
  dh_gen_key(dh);
#line 1642
  debug("Wait SSH2_MSG_KEX_DH_GEX_INIT.");
#line 1643
  packet_read_expect(& payload_len, 32);
#line 1646
  dh_client_pub = BN_new();
#line 1647
  if ((unsigned int )dh_client_pub == (unsigned int )((void *)0)) {
#line 1648
    fatal("dh_client_pub == NULL");
  }
#line 1649
  packet_get_bignum2(dh_client_pub, & dlen);
#line 1668
  tmp___0 = dh_pub_is_valid(dh, dh_client_pub);
#line 1668
  if (! tmp___0) {
#line 1669
    packet_disconnect("bad client public DH value");
  }
#line 1671
  tmp___1 = DH_size((DH const   *)dh);
#line 1671
  klen = (unsigned int )tmp___1;
#line 1672
  tmp___2 = xmalloc(klen);
#line 1672
  kbuf = (u_char *)tmp___2;
#line 1673
  tmp___3 = DH_compute_key(kbuf, (BIGNUM const   *)dh_client_pub, dh);
#line 1673
  kout = (unsigned int )tmp___3;
#line 1682
  shared_secret = BN_new();
#line 1684
  BN_bin2bn((unsigned char const   *)kbuf, (int )kout, shared_secret);
#line 1685
  memset((void *)kbuf, 0, klen);
#line 1686
  xfree((void *)kbuf);
#line 1689
  key_to_blob(hostkey, & server_host_key_blob, & sbloblen);
#line 1692
  tmp___4 = buffer_len(server_kexinit);
#line 1692
  tmp___5 = buffer_ptr(server_kexinit);
#line 1692
  tmp___6 = buffer_len(client_kexinit);
#line 1692
  tmp___7 = buffer_ptr(client_kexinit);
#line 1692
  hash = kex_hash_gex(client_version_string, server_version_string, tmp___7, (int )tmp___6,
                      tmp___5, (int )tmp___4, (char *)server_host_key_blob, (int )sbloblen,
                      nbits, dh->p, dh->g, dh_client_pub, dh->pub_key, shared_secret);
#line 1703
  buffer_free(client_kexinit);
#line 1704
  buffer_free(server_kexinit);
#line 1705
  xfree((void *)client_kexinit);
#line 1706
  xfree((void *)server_kexinit);
#line 1707
  BN_free(dh_client_pub);
#line 1716
  session_id2_len = 20;
#line 1717
  tmp___8 = xmalloc((unsigned int )session_id2_len);
#line 1717
  session_id2 = (u_char *)tmp___8;
#line 1718
  memcpy((void * __restrict  )session_id2, (void const   * __restrict  )hash, (unsigned int )session_id2_len);
#line 1722
  key_sign(hostkey, & signature, & slen, hash, 20);
#line 1724
  destroy_sensitive_data();
#line 1727
  packet_start(33);
#line 1728
  packet_put_string((char const   *)((char *)server_host_key_blob), sbloblen);
#line 1729
  packet_put_bignum2(dh->pub_key);
#line 1730
  packet_put_string((char const   *)((char *)signature), (unsigned int )slen);
#line 1731
  packet_send();
#line 1732
  xfree((void *)signature);
#line 1733
  xfree((void *)server_host_key_blob);
#line 1734
  packet_write_wait();
#line 1736
  kex_derive_keys(kex___0, hash, shared_secret);
#line 1737
  BN_clear_free(shared_secret);
#line 1738
  packet_set_kex(kex___0);
#line 1741
  DH_free(dh);
#line 1742
  return;
}
}
#line 1 "auth.o"
#pragma merger(0,"./auth.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 187 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 87 "/usr/include/shadow.h"
extern struct spwd *getspnam(char const   *__name ) ;
#line 36 "groupaccess.h"
int ga_init(char const   *user , gid_t base ) ;
#line 42
int ga_match(char * const  *groups , int n___0 ) ;
#line 47
void ga_free(void) ;
#line 122 "auth.h"
Authctxt *authctxt_new(void) ;
#line 123
void auth_log(Authctxt *authctxt , int authenticated , char *method , char *info ) ;
#line 125
int auth_root_allowed(char *method ) ;
#line 129
int allowed_user(struct passwd *pw ) ;
#line 135
struct passwd *pwcopy(struct passwd *pw ) ;
#line 30 "auth-options.h"
char *forced_command ;
#line 56 "auth.c"
int allowed_user(struct passwd *pw ) 
{ struct stat st ;
  char *shell ;
  int i ;
  struct spwd *spw ;
  int days ;
  time_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 70
  if (! pw) {
#line 71
    return (0);
  } else {
#line 70
    if (! pw->pw_name) {
#line 71
      return (0);
    }
  }
#line 73
  spw = getspnam((char const   *)pw->pw_name);
#line 74
  if ((unsigned int )spw != (unsigned int )((void *)0)) {
#line 75
    tmp = time((time_t *)((void *)0));
#line 75
    days = (int )(tmp / 86400L);
#line 78
    if (spw->sp_expire >= 0L) {
#line 78
      if ((long )days > spw->sp_expire) {
#line 79
        return (0);
      }
    }
#line 82
    if (spw->sp_lstchg >= 0L) {
#line 82
      if (spw->sp_max >= 0L) {
#line 82
        if ((long )days > spw->sp_lstchg + spw->sp_max) {
#line 84
          return (0);
        }
      }
    }
  }
#line 96
  if ((int )*(pw->pw_shell + 0) == 0) {
#line 96
    shell = (char *)"/bin/sh";
  } else {
#line 96
    shell = pw->pw_shell;
  }
#line 99
  tmp___0 = stat((char const   * __restrict  )shell, (struct stat * __restrict  )(& st));
#line 99
  if (tmp___0 != 0) {
#line 100
    return (0);
  }
#line 101
  if (st.st_mode & 32768U) {
#line 101
    if (! (st.st_mode & (unsigned int )((((64 >> 3) >> 3) | 64) | (64 >> 3)))) {
#line 102
      return (0);
    }
  } else {
#line 102
    return (0);
  }
#line 105
  if (options.num_deny_users > 0U) {
#line 106
    i = 0;
#line 106
    while ((u_int )i < options.num_deny_users) {
#line 107
      tmp___1 = match_pattern((char const   *)pw->pw_name, (char const   *)options.deny_users[i]);
#line 107
      if (tmp___1) {
#line 108
        return (0);
      }
#line 106
      i ++;
    }
  }
#line 111
  if (options.num_allow_users > 0U) {
#line 112
    i = 0;
#line 112
    while ((u_int )i < options.num_allow_users) {
#line 113
      tmp___2 = match_pattern((char const   *)pw->pw_name, (char const   *)options.allow_users[i]);
#line 113
      if (tmp___2) {
#line 114
        break;
      }
#line 112
      i ++;
    }
#line 116
    if ((u_int )i >= options.num_allow_users) {
#line 117
      return (0);
    }
  }
#line 119
  if (options.num_deny_groups > 0U) {
    goto _L;
  } else {
#line 119
    if (options.num_allow_groups > 0U) {
      _L: /* CIL Label */ 
#line 121
      tmp___3 = ga_init((char const   *)pw->pw_name, pw->pw_gid);
#line 121
      if (tmp___3 == 0) {
#line 122
        return (0);
      }
#line 125
      if (options.num_deny_groups > 0U) {
#line 126
        tmp___4 = ga_match((char * const  *)(options.deny_groups), (int )options.num_deny_groups);
#line 126
        if (tmp___4) {
#line 128
          ga_free();
#line 129
          return (0);
        }
      }
#line 135
      if (options.num_allow_groups > 0U) {
#line 136
        tmp___5 = ga_match((char * const  *)(options.allow_groups), (int )options.num_allow_groups);
#line 136
        if (! tmp___5) {
#line 138
          ga_free();
#line 139
          return (0);
        }
      }
#line 141
      ga_free();
    }
  }
#line 162
  return (1);
}
}
#line 165 "auth.c"
Authctxt *authctxt_new(void) 
{ Authctxt *authctxt ;
  void *tmp ;

  {
#line 168
  tmp = xmalloc(sizeof(*authctxt));
#line 168
  authctxt = (Authctxt *)tmp;
#line 169
  memset((void *)authctxt, 0, sizeof(*authctxt));
#line 170
  return (authctxt);
}
}
#line 173 "auth.c"
struct passwd *pwcopy(struct passwd *pw ) 
{ struct passwd *copy ;
  void *tmp ;

  {
#line 176
  tmp = xmalloc(sizeof(*copy));
#line 176
  copy = (struct passwd *)tmp;
#line 177
  memset((void *)copy, 0, sizeof(*copy));
#line 178
  copy->pw_name = xstrdup((char const   *)pw->pw_name);
#line 179
  copy->pw_passwd = xstrdup((char const   *)pw->pw_passwd);
#line 180
  copy->pw_uid = pw->pw_uid;
#line 181
  copy->pw_gid = pw->pw_gid;
#line 188
  copy->pw_dir = xstrdup((char const   *)pw->pw_dir);
#line 189
  copy->pw_shell = xstrdup((char const   *)pw->pw_shell);
#line 190
  return (copy);
}
}
#line 193 "auth.c"
void auth_log(Authctxt *authctxt , int authenticated , char *method , char *info ) 
{ void (*authlog)(char const   *fmt  , ...) ;
  char *authmsg ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;

  {
#line 196
  authlog = (void (*)(char const   *fmt  , ...))(& verbose);
#line 203
  if (authenticated == 1) {
#line 204
    authlog = (void (*)(char const   *fmt  , ...))(& log);
  } else {
#line 203
    if (! authctxt->valid) {
#line 204
      authlog = (void (*)(char const   *fmt  , ...))(& log);
    } else {
#line 203
      if (authctxt->failures >= 3) {
#line 204
        authlog = (void (*)(char const   *fmt  , ...))(& log);
      } else {
#line 203
        if (0) {
#line 203
          __s1_len = strlen((char const   *)method);
#line 203
          __s2_len = strlen("password");
#line 203
          if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
            goto _L___0;
          } else {
#line 203
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 203
              if (! ((unsigned int )((void const   *)("password" + 1)) - (unsigned int )((void const   *)"password") == 1U)) {
#line 203
                tmp___8 = 1;
              } else {
#line 203
                if (__s2_len >= 4U) {
#line 203
                  tmp___8 = 1;
                } else {
#line 203
                  tmp___8 = 0;
                }
              }
            } else {
#line 203
              tmp___8 = 0;
            }
          }
#line 203
          if (tmp___8) {
#line 203
            tmp___4 = __builtin_strcmp((char const   *)method, "password");
          } else {
#line 203
            tmp___7 = __builtin_strcmp((char const   *)method, "password");
#line 203
            tmp___4 = tmp___7;
          }
        } else {
#line 203
          tmp___7 = __builtin_strcmp((char const   *)method, "password");
#line 203
          tmp___4 = tmp___7;
        }
#line 203
        if (tmp___4 == 0) {
#line 204
          authlog = (void (*)(char const   *fmt  , ...))(& log);
        }
      }
    }
  }
#line 206
  if (authctxt->postponed) {
#line 207
    authmsg = (char *)"Postponed";
  } else {
#line 209
    if (authenticated) {
#line 209
      authmsg = (char *)"Accepted";
    } else {
#line 209
      authmsg = (char *)"Failed";
    }
  }
#line 211
  tmp___9 = get_remote_port();
#line 211
  tmp___10 = get_remote_ipaddr();
#line 211
  if (authctxt->valid) {
#line 211
    if ((authctxt->pw)->pw_uid == 0U) {
#line 211
      tmp___11 = "ROOT";
    } else {
#line 211
      tmp___11 = (char const   *)authctxt->user;
    }
  } else {
#line 211
    tmp___11 = (char const   *)authctxt->user;
  }
#line 211
  if (authctxt->valid) {
#line 211
    tmp___12 = "";
  } else {
#line 211
    tmp___12 = "illegal user ";
  }
#line 211
  (*authlog)("%s %s for %s%.100s from %.200s port %d%s", authmsg, method, tmp___12,
             tmp___11, tmp___10, tmp___9, info);
#line 219
  return;
}
}
#line 224 "auth.c"
int auth_root_allowed(char *method ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;

  {
#line 227
  switch (options.permit_root_login) {
  case 3: 
#line 229
  return (1);
#line 230
  break;
  case 2: 
#line 232
  if (0) {
#line 232
    __s1_len = strlen((char const   *)method);
#line 232
    __s2_len = strlen("password");
#line 232
    if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
      goto _L___0;
    } else {
#line 232
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 232
        if (! ((unsigned int )((void const   *)("password" + 1)) - (unsigned int )((void const   *)"password") == 1U)) {
#line 232
          tmp___8 = 1;
        } else {
#line 232
          if (__s2_len >= 4U) {
#line 232
            tmp___8 = 1;
          } else {
#line 232
            tmp___8 = 0;
          }
        }
      } else {
#line 232
        tmp___8 = 0;
      }
    }
#line 232
    if (tmp___8) {
#line 232
      tmp___4 = __builtin_strcmp((char const   *)method, "password");
    } else {
#line 232
      tmp___7 = __builtin_strcmp((char const   *)method, "password");
#line 232
      tmp___4 = tmp___7;
    }
  } else {
#line 232
    tmp___7 = __builtin_strcmp((char const   *)method, "password");
#line 232
    tmp___4 = tmp___7;
  }
#line 232
  if (tmp___4 != 0) {
#line 233
    return (1);
  }
#line 234
  break;
  case 1: 
#line 236
  if (forced_command) {
#line 237
    log("Root login accepted for forced command.");
#line 238
    return (1);
  }
#line 240
  break;
  }
#line 242
  tmp___9 = get_remote_ipaddr();
#line 242
  log("ROOT LOGIN REFUSED FROM %.200s", tmp___9);
#line 243
  return (0);
}
}
#line 1 "auth1.o"
#pragma merger(0,"./auth1.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 59 "auth.h"
int auth_rhosts(struct passwd *pw , char const   *client_user ) ;
#line 65
int auth_rhosts_rsa(struct passwd *pw , char const   *client_user , RSA *client_host_key ) ;
#line 72
int auth_password(Authctxt *authctxt , char const   *password ) ;
#line 79
int auth_rsa(struct passwd *pw , BIGNUM *client_n ) ;
#line 131
char *get_challenge(Authctxt *authctxt , char *devs ) ;
#line 132
int verify_response(Authctxt *authctxt , char *response ) ;
#line 30 "session.h"
void do_authenticated(struct passwd *pw ) ;
#line 41 "auth1.c"
static char buf___0[1024]  ;
#line 38 "auth1.c"
char *get_authname(int type ) 
{ 

  {
#line 42
  switch (type) {
  case 9: 
#line 44
  return ((char *)"password");
  case 6: 
#line 46
  return ((char *)"rsa");
  case 35: 
#line 48
  return ((char *)"rhosts-rsa");
  case 5: 
#line 50
  return ((char *)"rhosts");
  case 39: 
  case 41: 
#line 53
  return ((char *)"challenge-response");
  }
#line 59
  snprintf((char * __restrict  )(buf___0), sizeof(buf___0), (char const   * __restrict  )"bad-auth-msg-%d",
           type);
#line 60
  return (buf___0);
}
}
#line 67 "auth1.c"
void do_authloop(Authctxt *authctxt ) 
{ int authenticated ;
  u_int bits ;
  RSA *client_host_key ;
  BIGNUM *n___0 ;
  char *client_user ;
  char *password ;
  char info[1024] ;
  u_int dlen ;
  int plen ;
  int nlen ;
  int elen ;
  u_int ulen ;
  int type ;
  struct passwd *pw ;
  char const   *tmp ;
  int tmp___0 ;
  int _p ;
  int _e ;
  int tmp___1 ;
  int tmp___2 ;
  int _p___0 ;
  int _e___0 ;
  int _p___1 ;
  int _e___1 ;
  int _p___2 ;
  int _e___2 ;
  size_t tmp___3 ;
  char *challenge ;
  char *tmp___4 ;
  char *response ;
  char *tmp___5 ;
  int _p___3 ;
  int _e___3 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;

  {
#line 70
  authenticated = 0;
#line 79
  type = 0;
#line 80
  pw = authctxt->pw;
#line 82
  if (authctxt->valid) {
#line 82
    tmp = "";
  } else {
#line 82
    tmp = "illegal user ";
  }
#line 82
  debug("Attempting authentication for %s%.100s.", tmp, authctxt->user);
#line 86
  if (options.password_authentication) {
#line 86
    tmp___0 = auth_password(authctxt, "");
#line 86
    if (tmp___0) {
#line 97
      auth_log(authctxt, 1, (char *)"without authentication", (char *)"");
#line 98
      return;
    }
  }
#line 102
  packet_start(15);
#line 103
  packet_send();
#line 104
  packet_write_wait();
#line 106
  client_user = (char *)((void *)0);
#line 108
  while (1) {
#line 110
    authenticated = 0;
#line 112
    info[0] = (char )'\000';
#line 115
    type = packet_read(& plen);
#line 118
    switch (type) {
    case 5: 
#line 176
    if (! options.rhosts_authentication) {
#line 177
      verbose("Rhosts authentication disabled.");
#line 178
      break;
    }
#line 186
    client_user = packet_get_string(& ulen);
#line 187
    while (1) {
#line 187
      _p = plen;
#line 187
      _e = (int )(4U + ulen);
#line 187
      if (_p != _e) {
#line 187
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "auth1.c", 187);
#line 187
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 187
      break;
    }
#line 190
    authenticated = auth_rhosts(pw, (char const   *)client_user);
#line 192
    snprintf((char * __restrict  )(info), sizeof(info), (char const   * __restrict  )" ruser %.100s",
             client_user);
#line 193
    break;
    case 35: 
#line 196
    if (! options.rhosts_rsa_authentication) {
#line 197
      verbose("Rhosts with RSA authentication disabled.");
#line 198
      break;
    }
#line 205
    client_user = packet_get_string(& ulen);
#line 208
    client_host_key = RSA_new();
#line 209
    if ((unsigned int )client_host_key == (unsigned int )((void *)0)) {
#line 210
      fatal("RSA_new failed");
    }
#line 211
    client_host_key->e = BN_new();
#line 212
    client_host_key->n = BN_new();
#line 213
    if ((unsigned int )client_host_key->e == (unsigned int )((void *)0)) {
#line 214
      fatal("BN_new failed");
    } else {
#line 213
      if ((unsigned int )client_host_key->n == (unsigned int )((void *)0)) {
#line 214
        fatal("BN_new failed");
      }
    }
#line 215
    bits = packet_get_int();
#line 216
    packet_get_bignum(client_host_key->e, & elen);
#line 217
    packet_get_bignum(client_host_key->n, & nlen);
#line 219
    tmp___2 = BN_num_bits((BIGNUM const   *)client_host_key->n);
#line 219
    if (bits != (u_int )tmp___2) {
#line 220
      tmp___1 = BN_num_bits((BIGNUM const   *)client_host_key->n);
#line 220
      verbose("Warning: keysize mismatch for client_host_key: actual %d, announced %d",
              tmp___1, bits);
    }
#line 222
    while (1) {
#line 222
      _p___0 = plen;
#line 222
      _e___0 = (int )((((4U + ulen) + 4U) + (u_int )elen) + (u_int )nlen);
#line 222
      if (_p___0 != _e___0) {
#line 222
        log("Packet integrity error (%d != %d) at %s:%d", _p___0, _e___0, "auth1.c",
            222);
#line 222
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 222
      break;
    }
#line 224
    authenticated = auth_rhosts_rsa(pw, (char const   *)client_user, client_host_key);
#line 225
    RSA_free(client_host_key);
#line 227
    snprintf((char * __restrict  )(info), sizeof(info), (char const   * __restrict  )" ruser %.100s",
             client_user);
#line 228
    break;
    case 6: 
#line 231
    if (! options.rsa_authentication) {
#line 232
      verbose("RSA authentication disabled.");
#line 233
      break;
    }
#line 236
    n___0 = BN_new();
#line 237
    packet_get_bignum(n___0, & nlen);
#line 238
    while (1) {
#line 238
      _p___1 = plen;
#line 238
      _e___1 = nlen;
#line 238
      if (_p___1 != _e___1) {
#line 238
        log("Packet integrity error (%d != %d) at %s:%d", _p___1, _e___1, "auth1.c",
            238);
#line 238
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 238
      break;
    }
#line 239
    authenticated = auth_rsa(pw, n___0);
#line 240
    BN_clear_free(n___0);
#line 241
    break;
    case 9: 
#line 244
    if (! options.password_authentication) {
#line 245
      verbose("Password authentication disabled.");
#line 246
      break;
    }
#line 253
    password = packet_get_string(& dlen);
#line 254
    while (1) {
#line 254
      _p___2 = plen;
#line 254
      _e___2 = (int )(4U + dlen);
#line 254
      if (_p___2 != _e___2) {
#line 254
        log("Packet integrity error (%d != %d) at %s:%d", _p___2, _e___2, "auth1.c",
            254);
#line 254
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 254
      break;
    }
#line 265
    authenticated = auth_password(authctxt, (char const   *)password);
#line 268
    tmp___3 = strlen((char const   *)password);
#line 268
    memset((void *)password, 0, tmp___3);
#line 269
    xfree((void *)password);
#line 270
    break;
    case 39: 
#line 273
    debug("rcvd SSH_CMSG_AUTH_TIS");
#line 274
    if (options.challenge_reponse_authentication == 1) {
#line 275
      tmp___4 = get_challenge(authctxt, authctxt->style);
#line 275
      challenge = tmp___4;
#line 276
      if ((unsigned int )challenge != (unsigned int )((void *)0)) {
#line 277
        debug("sending challenge \'%s\'", challenge);
#line 278
        packet_start(40);
#line 279
        packet_put_cstring((char const   *)challenge);
#line 280
        packet_send();
#line 281
        packet_write_wait();
        goto __Cont;
      }
    }
#line 285
    break;
    case 41: 
#line 287
    debug("rcvd SSH_CMSG_AUTH_TIS_RESPONSE");
#line 288
    if (options.challenge_reponse_authentication == 1) {
#line 289
      tmp___5 = packet_get_string(& dlen);
#line 289
      response = tmp___5;
#line 290
      debug("got response \'%s\'", response);
#line 291
      while (1) {
#line 291
        _p___3 = plen;
#line 291
        _e___3 = (int )(4U + dlen);
#line 291
        if (_p___3 != _e___3) {
#line 291
          log("Packet integrity error (%d != %d) at %s:%d", _p___3, _e___3, "auth1.c",
              291);
#line 291
          packet_disconnect("Packet integrity error. (%d)", type);
        }
#line 291
        break;
      }
#line 292
      authenticated = verify_response(authctxt, response);
#line 293
      memset((void *)response, 'r', dlen);
#line 294
      xfree((void *)response);
    }
#line 296
    break;
    default: 
#line 303
    log("Unknown message during authentication: type %d", type);
#line 304
    break;
    }
#line 312
    if (! authctxt->valid) {
#line 312
      if (authenticated) {
#line 313
        fatal("INTERNAL ERROR: authenticated invalid user %s", authctxt->user);
      }
    }
#line 325
    if (authenticated) {
#line 325
      if ((authctxt->pw)->pw_uid == 0U) {
#line 325
        tmp___6 = get_authname(type);
#line 325
        tmp___7 = auth_root_allowed(tmp___6);
#line 325
        if (! tmp___7) {
#line 327
          authenticated = 0;
        }
      }
    }
#line 335
    tmp___8 = get_authname(type);
#line 335
    auth_log(authctxt, authenticated, tmp___8, info);
#line 337
    if ((unsigned int )client_user != (unsigned int )((void *)0)) {
#line 338
      xfree((void *)client_user);
#line 339
      client_user = (char *)((void *)0);
    }
#line 342
    if (authenticated) {
#line 343
      return;
    }
#line 345
    tmp___9 = authctxt->failures;
#line 345
    (authctxt->failures) ++;
#line 345
    if (tmp___9 > 6) {
#line 351
      packet_disconnect("Too many authentication failures for %.100s", authctxt->user);
    }
#line 354
    packet_start(15);
#line 355
    packet_send();
#line 356
    packet_write_wait();
    __Cont: /* CIL Label */ ;
  }
}
}
#line 364 "auth1.c"
void do_authentication(void) 
{ Authctxt *authctxt ;
  struct passwd *pw ;
  int plen ;
  u_int ulen ;
  char *user ;
  char *style ;
  int _p ;
  int _e ;
  char *tmp ;
  char *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  __uid_t tmp___4 ;
  __uid_t tmp___5 ;

  {
#line 371
  style = (char *)((void *)0);
#line 374
  packet_read_expect(& plen, 4);
#line 377
  user = packet_get_string(& ulen);
#line 378
  while (1) {
#line 378
    _p = plen;
#line 378
    _e = (int )(4U + ulen);
#line 378
    if (_p != _e) {
#line 378
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "auth1.c", 378);
#line 378
      packet_disconnect("Packet integrity error. (%d)", 4);
    }
#line 378
    break;
  }
#line 380
  tmp___1 = __builtin_strchr(user, ':');
#line 380
  style = tmp___1;
#line 380
  if ((unsigned int )style != (unsigned int )((void *)0)) {
#line 381
    tmp = style;
#line 381
    style ++;
#line 381
    *tmp = (char)0;
  }
#line 383
  authctxt = authctxt_new();
#line 384
  authctxt->user = user;
#line 385
  authctxt->style = style;
#line 388
  pw = getpwnam((char const   *)user);
#line 389
  if (pw) {
#line 389
    tmp___2 = allowed_user(pw);
#line 389
    if (tmp___2) {
#line 390
      authctxt->valid = 1;
#line 391
      pw = pwcopy(pw);
    } else {
#line 393
      debug("do_authentication: illegal user %s", user);
#line 394
      pw = (struct passwd *)((void *)0);
    }
  } else {
#line 393
    debug("do_authentication: illegal user %s", user);
#line 394
    pw = (struct passwd *)((void *)0);
  }
#line 396
  authctxt->pw = pw;
#line 398
  if (pw) {
#line 398
    tmp___3 = (char const   *)user;
  } else {
#line 398
    tmp___3 = "unknown";
  }
#line 398
  setproctitle("%s", tmp___3);
#line 410
  tmp___4 = getuid();
#line 410
  if (tmp___4 != 0U) {
#line 410
    if (pw) {
#line 410
      tmp___5 = getuid();
#line 410
      if (pw->pw_uid != tmp___5) {
#line 411
        packet_disconnect("Cannot change user when server not running as root.");
      }
    }
  }
#line 418
  do_authloop(authctxt);
#line 421
  packet_start(14);
#line 422
  packet_send();
#line 423
  packet_write_wait();
#line 433
  xfree((void *)authctxt->user);
#line 434
  xfree((void *)authctxt);
#line 437
  do_authenticated(pw);
#line 438
  return;
}
}
#line 1 "auth2.o"
#pragma merger(0,"./auth2.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 212
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 759 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 124 "auth.h"
void userauth_reply(Authctxt *authctxt , int authenticated ) ;
#line 127
int auth2_challenge(Authctxt *authctxt , char *devs ) ;
#line 134
struct passwd *auth_get_user(void) ;
#line 33 "session.h"
void do_authenticated2(Authctxt *authctxt ) ;
#line 37 "auth-options.h"
int auth_parse_options(struct passwd *pw , char *opts , char *file , u_long linenum ) ;
#line 42
void auth_clear_options(void) ;
#line 60 "auth2.c"
static Authctxt *x_authctxt  =    (Authctxt *)((void *)0);
#line 61 "auth2.c"
static int one  =    1;
#line 72
void input_service_request(int type , int plen , void *ctxt ) ;
#line 73
void input_userauth_request(int type , int plen , void *ctxt ) ;
#line 74
void protocol_error(int type , int plen , void *ctxt ) ;
#line 77
Authmethod *authmethod_lookup(char const   *name ) ;
#line 79
int user_key_allowed(struct passwd *pw , Key *key ) ;
#line 80
char *authmethods_get(void) ;
#line 83
void userauth_banner(void) ;
#line 84
int userauth_none(Authctxt *authctxt ) ;
#line 85
int userauth_passwd(Authctxt *authctxt ) ;
#line 86
int userauth_pubkey(Authctxt *authctxt ) ;
#line 87
int userauth_kbdint(Authctxt *authctxt ) ;
#line 89 "auth2.c"
Authmethod authmethods[5]  = {      {(char *)"none", & userauth_none, & one}, 
        {(char *)"publickey", & userauth_pubkey, & options.pubkey_authentication}, 
        {(char *)"password", & userauth_passwd, & options.password_authentication}, 
        {(char *)"keyboard-interactive", & userauth_kbdint, & options.kbd_interactive_authentication}, 
        {(char *)((void *)0),
      (int (*)(Authctxt *authctxt ))((void *)0), (int *)((void *)0)}};
#line 109 "auth2.c"
void do_authentication2(void) 
{ Authctxt *authctxt ;
  Authctxt *tmp ;

  {
#line 112
  tmp = authctxt_new();
#line 112
  authctxt = tmp;
#line 114
  x_authctxt = authctxt;
#line 117
  if (options.challenge_reponse_authentication) {
#line 118
    options.kbd_interactive_authentication = 1;
  }
#line 120
  dispatch_init(& protocol_error);
#line 121
  dispatch_set(5, & input_service_request);
#line 122
  dispatch_run(0, & authctxt->success, (void *)authctxt);
#line 123
  do_authenticated2(authctxt);
#line 124
  return;
}
}
#line 126 "auth2.c"
void protocol_error(int type , int plen , void *ctxt ) 
{ 

  {
#line 129
  log("auth: protocol error: type %d plen %d", type, plen);
#line 130
  packet_start(3);
#line 131
  packet_put_int(0U);
#line 132
  packet_send();
#line 133
  packet_write_wait();
#line 134
  return;
}
}
#line 136 "auth2.c"
void input_service_request(int type , int plen , void *ctxt ) 
{ Authctxt *authctxt ;
  u_int len ;
  int accept___0 ;
  char *service ;
  char *tmp ;
  int _len ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 139
  authctxt = (Authctxt *)ctxt;
#line 141
  accept___0 = 0;
#line 142
  tmp = packet_get_string(& len);
#line 142
  service = tmp;
#line 143
  while (1) {
#line 143
    tmp___0 = packet_remaining();
#line 143
    _len = tmp___0;
#line 143
    if (_len > 0) {
#line 143
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
          143);
#line 143
      packet_disconnect("Packet integrity error.");
    }
#line 143
    break;
  }
#line 145
  if ((unsigned int )authctxt == (unsigned int )((void *)0)) {
#line 146
    fatal("input_service_request: no authctxt");
  }
#line 148
  if (0) {
#line 148
    __s1_len = strlen((char const   *)service);
#line 148
    __s2_len = strlen("ssh-userauth");
#line 148
    if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
      goto _L___0;
    } else {
#line 148
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 148
        if (! ((unsigned int )((void const   *)("ssh-userauth" + 1)) - (unsigned int )((void const   *)"ssh-userauth") == 1U)) {
#line 148
          tmp___10 = 1;
        } else {
#line 148
          if (__s2_len >= 4U) {
#line 148
            tmp___10 = 1;
          } else {
#line 148
            tmp___10 = 0;
          }
        }
      } else {
#line 148
        tmp___10 = 0;
      }
    }
#line 148
    if (tmp___10) {
#line 148
      tmp___6 = __builtin_strcmp((char const   *)service, "ssh-userauth");
    } else {
#line 148
      tmp___9 = __builtin_strcmp((char const   *)service, "ssh-userauth");
#line 148
      tmp___6 = tmp___9;
    }
  } else {
#line 148
    tmp___9 = __builtin_strcmp((char const   *)service, "ssh-userauth");
#line 148
    tmp___6 = tmp___9;
  }
#line 148
  if (tmp___6 == 0) {
#line 149
    if (! authctxt->success) {
#line 150
      accept___0 = 1;
#line 152
      dispatch_set(50, & input_userauth_request);
    }
  }
#line 157
  if (accept___0) {
#line 158
    packet_start(6);
#line 159
    packet_put_cstring((char const   *)service);
#line 160
    packet_send();
#line 161
    packet_write_wait();
  } else {
#line 163
    debug("bad service request %s", service);
#line 164
    packet_disconnect("bad service request %s", service);
  }
#line 166
  xfree((void *)service);
#line 167
  return;
}
}
#line 169 "auth2.c"
void input_userauth_request(int type , int plen , void *ctxt ) 
{ Authctxt *authctxt ;
  Authmethod *m___0 ;
  char *user ;
  char *service ;
  char *method ;
  char *style ;
  int authenticated ;
  char *tmp ;
  char *tmp___1 ;
  struct passwd *pw ;
  int tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___30 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;

  {
#line 172
  authctxt = (Authctxt *)ctxt;
#line 173
  m___0 = (Authmethod *)((void *)0);
#line 174
  style = (char *)((void *)0);
#line 175
  authenticated = 0;
#line 177
  if ((unsigned int )authctxt == (unsigned int )((void *)0)) {
#line 178
    fatal("input_userauth_request: no authctxt");
  }
#line 180
  user = packet_get_string((u_int *)((void *)0));
#line 181
  service = packet_get_string((u_int *)((void *)0));
#line 182
  method = packet_get_string((u_int *)((void *)0));
#line 183
  debug("userauth-request for user %s service %s method %s", user, service, method);
#line 184
  debug("attempt %d failures %d", authctxt->attempt, authctxt->failures);
#line 186
  tmp___1 = __builtin_strchr(user, ':');
#line 186
  style = tmp___1;
#line 186
  if ((unsigned int )style != (unsigned int )((void *)0)) {
#line 187
    tmp = style;
#line 187
    style ++;
#line 187
    *tmp = (char)0;
  }
#line 189
  tmp___35 = authctxt->attempt;
#line 189
  (authctxt->attempt) ++;
#line 189
  if (tmp___35 == 0) {
#line 191
    pw = (struct passwd *)((void *)0);
#line 192
    pw = getpwnam((char const   *)user);
#line 193
    if (pw) {
#line 193
      tmp___2 = allowed_user(pw);
#line 193
      if (tmp___2) {
#line 193
        if (0) {
#line 193
          __s1_len = strlen((char const   *)service);
#line 193
          __s2_len = strlen("ssh-connection");
#line 193
          if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
            goto _L___0;
          } else {
#line 193
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 193
              if (! ((unsigned int )((void const   *)("ssh-connection" + 1)) - (unsigned int )((void const   *)"ssh-connection") == 1U)) {
#line 193
                tmp___12 = 1;
              } else {
#line 193
                if (__s2_len >= 4U) {
#line 193
                  tmp___12 = 1;
                } else {
#line 193
                  tmp___12 = 0;
                }
              }
            } else {
#line 193
              tmp___12 = 0;
            }
          }
#line 193
          if (tmp___12) {
#line 193
            tmp___8 = __builtin_strcmp((char const   *)service, "ssh-connection");
          } else {
#line 193
            tmp___11 = __builtin_strcmp((char const   *)service, "ssh-connection");
#line 193
            tmp___8 = tmp___11;
          }
        } else {
#line 193
          tmp___11 = __builtin_strcmp((char const   *)service, "ssh-connection");
#line 193
          tmp___8 = tmp___11;
        }
#line 193
        if (tmp___8 == 0) {
#line 194
          authctxt->pw = pwcopy(pw);
#line 195
          authctxt->valid = 1;
#line 196
          debug2("input_userauth_request: setting up authctxt for %s", user);
        } else {
#line 201
          log("input_userauth_request: illegal user %s", user);
        }
      } else {
#line 201
        log("input_userauth_request: illegal user %s", user);
      }
    } else {
#line 201
      log("input_userauth_request: illegal user %s", user);
    }
#line 206
    if (pw) {
#line 206
      tmp___13 = (char const   *)user;
    } else {
#line 206
      tmp___13 = "unknown";
    }
#line 206
    setproctitle("%s", tmp___13);
#line 207
    authctxt->user = xstrdup((char const   *)user);
#line 208
    authctxt->service = xstrdup((char const   *)service);
#line 209
    if (style) {
#line 209
      authctxt->style = xstrdup((char const   *)style);
    } else {
#line 209
      authctxt->style = (char *)((void *)0);
    }
  } else {
#line 210
    if (authctxt->valid) {
#line 211
      if (0) {
#line 211
        __s1_len___0 = strlen((char const   *)user);
#line 211
        __s2_len___0 = strlen((char const   *)authctxt->user);
#line 211
        if (! ((unsigned int )((void const   *)(user + 1)) - (unsigned int )((void const   *)user) == 1U)) {
          goto _L___2;
        } else {
#line 211
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 211
            if (! ((unsigned int )((void const   *)(authctxt->user + 1)) - (unsigned int )((void const   *)authctxt->user) == 1U)) {
#line 211
              tmp___24 = 1;
            } else {
#line 211
              if (__s2_len___0 >= 4U) {
#line 211
                tmp___24 = 1;
              } else {
#line 211
                tmp___24 = 0;
              }
            }
          } else {
#line 211
            tmp___24 = 0;
          }
        }
#line 211
        if (tmp___24) {
#line 211
          tmp___20 = __builtin_strcmp((char const   *)user, (char const   *)authctxt->user);
        } else {
#line 211
          tmp___23 = __builtin_strcmp((char const   *)user, (char const   *)authctxt->user);
#line 211
          tmp___20 = tmp___23;
        }
      } else {
#line 211
        tmp___23 = __builtin_strcmp((char const   *)user, (char const   *)authctxt->user);
#line 211
        tmp___20 = tmp___23;
      }
#line 212
      if (tmp___20 != 0) {
#line 213
        log("input_userauth_request: missmatch: (%s,%s)!=(%s,%s)", user, service,
            authctxt->user, authctxt->service);
#line 215
        authctxt->valid = 0;
      } else {
#line 212
        if (0) {
#line 212
          __s1_len___1 = strlen((char const   *)service);
#line 212
          __s2_len___1 = strlen((char const   *)authctxt->service);
#line 212
          if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
            goto _L___4;
          } else {
#line 212
            if (__s1_len___1 >= 4U) {
              _L___4: /* CIL Label */ 
#line 212
              if (! ((unsigned int )((void const   *)(authctxt->service + 1)) - (unsigned int )((void const   *)authctxt->service) == 1U)) {
#line 212
                tmp___34 = 1;
              } else {
#line 212
                if (__s2_len___1 >= 4U) {
#line 212
                  tmp___34 = 1;
                } else {
#line 212
                  tmp___34 = 0;
                }
              }
            } else {
#line 212
              tmp___34 = 0;
            }
          }
#line 212
          if (tmp___34) {
#line 212
            tmp___30 = __builtin_strcmp((char const   *)service, (char const   *)authctxt->service);
          } else {
#line 212
            tmp___33 = __builtin_strcmp((char const   *)service, (char const   *)authctxt->service);
#line 212
            tmp___30 = tmp___33;
          }
        } else {
#line 212
          tmp___33 = __builtin_strcmp((char const   *)service, (char const   *)authctxt->service);
#line 212
          tmp___30 = tmp___33;
        }
#line 212
        if (tmp___30 != 0) {
#line 213
          log("input_userauth_request: missmatch: (%s,%s)!=(%s,%s)", user, service,
              authctxt->user, authctxt->service);
#line 215
          authctxt->valid = 0;
        }
      }
    }
  }
#line 219
  dispatch_set(61, & protocol_error);
#line 220
  authctxt->postponed = 0;
#line 229
  m___0 = authmethod_lookup((char const   *)method);
#line 230
  if ((unsigned int )m___0 != (unsigned int )((void *)0)) {
#line 231
    debug2("input_userauth_request: try method %s", method);
#line 232
    authenticated = (*(m___0->userauth))(authctxt);
  }
#line 234
  if (! authctxt->valid) {
#line 234
    if (authenticated) {
#line 235
      fatal("INTERNAL ERROR: authenticated invalid user %s", authctxt->user);
    }
  }
#line 239
  if (authenticated) {
#line 239
    if ((authctxt->pw)->pw_uid == 0U) {
#line 239
      tmp___36 = auth_root_allowed(method);
#line 239
      if (! tmp___36) {
#line 241
        authenticated = 0;
      }
    }
  }
#line 250
  auth_log(authctxt, authenticated, method, (char *)" ssh2");
#line 252
  if (! authctxt->postponed) {
#line 253
    userauth_reply(authctxt, authenticated);
  }
#line 255
  xfree((void *)service);
#line 256
  xfree((void *)user);
#line 257
  xfree((void *)method);
#line 258
  return;
}
}
#line 260 "auth2.c"
void userauth_banner(void) 
{ struct stat st ;
  char *banner ;
  off_t len ;
  off_t n___0 ;
  int fd ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 264
  banner = (char *)((void *)0);
#line 268
  if ((unsigned int )options.banner == (unsigned int )((void *)0)) {
#line 269
    return;
  } else {
#line 268
    if (datafellows & 128) {
#line 269
      return;
    }
  }
#line 270
  fd = open((char const   *)options.banner, 0);
#line 270
  if (fd < 0) {
#line 271
    tmp = __errno_location();
#line 271
    tmp___0 = strerror(*tmp);
#line 271
    error("userauth_banner: open %s failed: %s", options.banner, tmp___0);
#line 273
    return;
  }
#line 275
  tmp___1 = fstat(fd, & st);
#line 275
  if (tmp___1 < 0) {
    goto done;
  }
#line 277
  len = st.st_size;
#line 278
  tmp___2 = xmalloc((unsigned int )(len + 1L));
#line 278
  banner = (char *)tmp___2;
#line 279
  tmp___3 = read(fd, (void *)banner, (unsigned int )len);
#line 279
  n___0 = (long )tmp___3;
#line 279
  if (n___0 < 0L) {
    goto done;
  }
#line 281
  *(banner + n___0) = (char )'\000';
#line 282
  packet_start(53);
#line 283
  packet_put_cstring((char const   *)banner);
#line 284
  packet_put_cstring("");
#line 285
  packet_send();
#line 286
  debug("userauth_banner: sent");
  done: 
#line 288
  if (banner) {
#line 289
    xfree((void *)banner);
  }
#line 290
  close(fd);
#line 291
  return;
}
}
#line 294 "auth2.c"
void userauth_reply(Authctxt *authctxt , int authenticated ) 
{ char *methods ;
  int tmp ;

  {
#line 300
  if (authenticated == 1) {
#line 309
    dispatch_set(50, & protocol_error);
#line 310
    packet_start(52);
#line 311
    packet_send();
#line 312
    packet_write_wait();
#line 314
    authctxt->success = 1;
  } else {
#line 316
    tmp = authctxt->failures;
#line 316
    (authctxt->failures) ++;
#line 316
    if (tmp > 6) {
#line 317
      packet_disconnect("Too many authentication failures for %.100s", authctxt->user);
    }
#line 318
    methods = authmethods_get();
#line 319
    packet_start(51);
#line 320
    packet_put_cstring((char const   *)methods);
#line 321
    packet_put_char(0);
#line 322
    packet_send();
#line 323
    packet_write_wait();
#line 324
    xfree((void *)methods);
  }
#line 326
  return;
}
}
#line 328 "auth2.c"
int userauth_none(Authctxt *authctxt ) 
{ Authmethod *m___0 ;
  Authmethod *tmp ;
  int _len ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 332
  tmp = authmethod_lookup("none");
#line 332
  m___0 = tmp;
#line 333
  if ((unsigned int )m___0 != (unsigned int )((void *)0)) {
#line 334
    m___0->enabled = (int *)((void *)0);
  }
#line 335
  while (1) {
#line 335
    tmp___0 = packet_remaining();
#line 335
    _len = tmp___0;
#line 335
    if (_len > 0) {
#line 335
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
          335);
#line 335
      packet_disconnect("Packet integrity error.");
    }
#line 335
    break;
  }
#line 336
  userauth_banner();
#line 338
  if (authctxt->valid == 0) {
#line 339
    return (0);
  }
#line 350
  tmp___1 = auth_password(authctxt, "");
#line 350
  return (tmp___1);
}
}
#line 354 "auth2.c"
int userauth_passwd(Authctxt *authctxt ) 
{ char *password ;
  int authenticated ;
  int change ;
  u_int len ;
  u_int tmp ;
  int _len ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 358
  authenticated = 0;
#line 361
  tmp = packet_get_char();
#line 361
  change = (int )tmp;
#line 362
  if (change) {
#line 363
    log("password change not supported");
  }
#line 364
  password = packet_get_string(& len);
#line 365
  while (1) {
#line 365
    tmp___0 = packet_remaining();
#line 365
    _len = tmp___0;
#line 365
    if (_len > 0) {
#line 365
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
          365);
#line 365
      packet_disconnect("Packet integrity error.");
    }
#line 365
    break;
  }
#line 366
  if (authctxt->valid) {
#line 366
    tmp___1 = auth_password(authctxt, (char const   *)password);
#line 366
    if (tmp___1 == 1) {
#line 377
      authenticated = 1;
    }
  }
#line 378
  memset((void *)password, 0, len);
#line 379
  xfree((void *)password);
#line 380
  return (authenticated);
}
}
#line 383 "auth2.c"
int userauth_kbdint(Authctxt *authctxt ) 
{ int authenticated ;
  char *lang ;
  char *devs ;
  int _len ;
  int tmp ;

  {
#line 386
  authenticated = 0;
#line 387
  lang = (char *)((void *)0);
#line 388
  devs = (char *)((void *)0);
#line 390
  lang = packet_get_string((u_int *)((void *)0));
#line 391
  devs = packet_get_string((u_int *)((void *)0));
#line 392
  while (1) {
#line 392
    tmp = packet_remaining();
#line 392
    _len = tmp;
#line 392
    if (_len > 0) {
#line 392
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
          392);
#line 392
      packet_disconnect("Packet integrity error.");
    }
#line 392
    break;
  }
#line 394
  debug("keyboard-interactive language %s devs %s", lang, devs);
#line 396
  if (options.challenge_reponse_authentication) {
#line 397
    authenticated = auth2_challenge(authctxt, devs);
  }
#line 403
  xfree((void *)lang);
#line 404
  xfree((void *)devs);
#line 409
  return (authenticated);
}
}
#line 412 "auth2.c"
int userauth_pubkey(Authctxt *authctxt ) 
{ Buffer b ;
  Key *key ;
  char *pkalg ;
  char *pkblob ;
  char *sig ;
  u_int alen ;
  u_int blen ;
  u_int slen ;
  int have_sig ;
  int pktype ;
  int authenticated ;
  u_int tmp ;
  int _len ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  u_int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int _len___0 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 420
  authenticated = 0;
#line 422
  if (! authctxt->valid) {
#line 423
    debug2("userauth_pubkey: disabled because of invalid user");
#line 424
    return (0);
  }
#line 426
  tmp = packet_get_char();
#line 426
  have_sig = (int )tmp;
#line 427
  if (datafellows & 32) {
#line 428
    debug2("userauth_pubkey: SSH_BUG_PKAUTH");
#line 430
    pkblob = packet_get_string(& blen);
#line 431
    buffer_init(& b);
#line 432
    buffer_append(& b, (char const   *)pkblob, blen);
#line 434
    pkalg = buffer_get_string(& b, & alen);
#line 435
    buffer_free(& b);
  } else {
#line 437
    pkalg = packet_get_string(& alen);
#line 438
    pkblob = packet_get_string(& blen);
  }
#line 440
  pktype = key_type_from_name(pkalg);
#line 441
  if (pktype == 3) {
#line 443
    log("userauth_pubkey: unsupported public key algorithm: %s", pkalg);
#line 444
    xfree((void *)pkalg);
#line 445
    xfree((void *)pkblob);
#line 446
    return (0);
  }
#line 448
  key = key_from_blob(pkblob, (int )blen);
#line 449
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 450
    if (have_sig) {
#line 451
      sig = packet_get_string(& slen);
#line 452
      while (1) {
#line 452
        tmp___0 = packet_remaining();
#line 452
        _len = tmp___0;
#line 452
        if (_len > 0) {
#line 452
          log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
              452);
#line 452
          packet_disconnect("Packet integrity error.");
        }
#line 452
        break;
      }
#line 453
      buffer_init(& b);
#line 454
      if (datafellows & 16) {
#line 455
        buffer_append(& b, (char const   *)session_id2, (unsigned int )session_id2_len);
      } else {
#line 457
        buffer_put_string(& b, (void const   *)session_id2, (unsigned int )session_id2_len);
      }
#line 460
      buffer_put_char(& b, 50);
#line 461
      buffer_put_cstring(& b, (char const   *)authctxt->user);
#line 462
      if (datafellows & 2) {
#line 462
        tmp___1 = "ssh-userauth";
      } else {
#line 462
        tmp___1 = (char const   *)authctxt->service;
      }
#line 462
      buffer_put_cstring(& b, tmp___1);
#line 466
      if (datafellows & 32) {
#line 467
        buffer_put_char(& b, have_sig);
      } else {
#line 469
        buffer_put_cstring(& b, "publickey");
#line 470
        buffer_put_char(& b, have_sig);
#line 471
        tmp___2 = key_ssh_name(key);
#line 471
        buffer_put_cstring(& b, (char const   *)tmp___2);
      }
#line 473
      buffer_put_string(& b, (void const   *)pkblob, blen);
#line 478
      tmp___3 = user_key_allowed(authctxt->pw, key);
#line 478
      if (tmp___3) {
#line 478
        tmp___4 = buffer_len(& b);
#line 478
        tmp___5 = buffer_ptr(& b);
#line 478
        tmp___6 = key_verify(key, (u_char *)sig, (int )slen, (u_char *)tmp___5, (int )tmp___4);
#line 478
        if (tmp___6 == 1) {
#line 480
          authenticated = 1;
        }
      }
#line 481
      buffer_clear(& b);
#line 482
      xfree((void *)sig);
    } else {
#line 484
      debug("test whether pkalg/pkblob are acceptable");
#line 485
      while (1) {
#line 485
        tmp___7 = packet_remaining();
#line 485
        _len___0 = tmp___7;
#line 485
        if (_len___0 > 0) {
#line 485
          log("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "auth2.c",
              485);
#line 485
          packet_disconnect("Packet integrity error.");
        }
#line 485
        break;
      }
#line 495
      tmp___8 = user_key_allowed(authctxt->pw, key);
#line 495
      if (tmp___8) {
#line 496
        packet_start(60);
#line 497
        packet_put_string((char const   *)pkalg, alen);
#line 498
        packet_put_string((char const   *)pkblob, blen);
#line 499
        packet_send();
#line 500
        packet_write_wait();
#line 501
        authctxt->postponed = 1;
      }
    }
#line 504
    if (authenticated != 1) {
#line 505
      auth_clear_options();
    }
#line 506
    key_free(key);
  }
#line 508
  debug2("userauth_pubkey: authenticated %d pkalg %s", authenticated, pkalg);
#line 509
  xfree((void *)pkalg);
#line 510
  xfree((void *)pkblob);
#line 515
  return (authenticated);
}
}
#line 520 "auth2.c"
struct passwd *auth_get_user(void) 
{ struct passwd *tmp ;

  {
#line 523
  if ((unsigned int )x_authctxt != (unsigned int )((void *)0)) {
#line 523
    if (x_authctxt->valid) {
#line 523
      tmp = x_authctxt->pw;
    } else {
#line 523
      tmp = (struct passwd *)((void *)0);
    }
  } else {
#line 523
    tmp = (struct passwd *)((void *)0);
  }
#line 523
  return (tmp);
}
}
#line 528 "auth2.c"
char *authmethods_get(void) 
{ Authmethod *method ;
  u_int size ;
  char *list ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___17 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 531
  method = (Authmethod *)((void *)0);
#line 532
  size = (u_int )0;
#line 535
  method = authmethods;
#line 535
  while ((unsigned int )method->name != (unsigned int )((void *)0)) {
#line 536
    if (0) {
#line 536
      __s1_len = strlen((char const   *)method->name);
#line 536
      __s2_len = strlen("none");
#line 536
      if (! ((unsigned int )((void const   *)(method->name + 1)) - (unsigned int )((void const   *)method->name) == 1U)) {
        goto _L___0;
      } else {
#line 536
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 536
          if (! ((unsigned int )((void const   *)("none" + 1)) - (unsigned int )((void const   *)"none") == 1U)) {
#line 536
            tmp___8 = 1;
          } else {
#line 536
            if (__s2_len >= 4U) {
#line 536
              tmp___8 = 1;
            } else {
#line 536
              tmp___8 = 0;
            }
          }
        } else {
#line 536
          tmp___8 = 0;
        }
      }
#line 536
      if (tmp___8) {
#line 536
        tmp___4 = __builtin_strcmp((char const   *)method->name, "none");
      } else {
#line 536
        tmp___7 = __builtin_strcmp((char const   *)method->name, "none");
#line 536
        tmp___4 = tmp___7;
      }
    } else {
#line 536
      tmp___7 = __builtin_strcmp((char const   *)method->name, "none");
#line 536
      tmp___4 = tmp___7;
    }
#line 536
    if (tmp___4 == 0) {
      goto __Cont;
    }
#line 538
    if ((unsigned int )method->enabled != (unsigned int )((void *)0)) {
#line 538
      if (*(method->enabled) != 0) {
#line 539
        if (size != 0U) {
#line 540
          tmp___9 = strlen(",");
#line 540
          size += tmp___9;
        }
#line 541
        tmp___10 = strlen((char const   *)method->name);
#line 541
        size += tmp___10;
      }
    }
    __Cont: /* CIL Label */ 
#line 535
    method ++;
  }
#line 544
  size ++;
#line 545
  tmp___11 = xmalloc(size);
#line 545
  list = (char *)tmp___11;
#line 546
  *(list + 0) = (char )'\000';
#line 548
  method = authmethods;
#line 548
  while ((unsigned int )method->name != (unsigned int )((void *)0)) {
#line 549
    if (0) {
#line 549
      __s1_len___0 = strlen((char const   *)method->name);
#line 549
      __s2_len___0 = strlen("none");
#line 549
      if (! ((unsigned int )((void const   *)(method->name + 1)) - (unsigned int )((void const   *)method->name) == 1U)) {
        goto _L___2;
      } else {
#line 549
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 549
          if (! ((unsigned int )((void const   *)("none" + 1)) - (unsigned int )((void const   *)"none") == 1U)) {
#line 549
            tmp___21 = 1;
          } else {
#line 549
            if (__s2_len___0 >= 4U) {
#line 549
              tmp___21 = 1;
            } else {
#line 549
              tmp___21 = 0;
            }
          }
        } else {
#line 549
          tmp___21 = 0;
        }
      }
#line 549
      if (tmp___21) {
#line 549
        tmp___17 = __builtin_strcmp((char const   *)method->name, "none");
      } else {
#line 549
        tmp___20 = __builtin_strcmp((char const   *)method->name, "none");
#line 549
        tmp___17 = tmp___20;
      }
    } else {
#line 549
      tmp___20 = __builtin_strcmp((char const   *)method->name, "none");
#line 549
      tmp___17 = tmp___20;
    }
#line 549
    if (tmp___17 == 0) {
      goto __Cont___0;
    }
#line 551
    if ((unsigned int )method->enabled != (unsigned int )((void *)0)) {
#line 551
      if (*(method->enabled) != 0) {
#line 552
        if ((int )*(list + 0) != 0) {
#line 553
          strlcat(list, ",", size);
        }
#line 554
        strlcat(list, (char const   *)method->name, size);
      }
    }
    __Cont___0: /* CIL Label */ 
#line 548
    method ++;
  }
#line 557
  return (list);
}
}
#line 560 "auth2.c"
Authmethod *authmethod_lookup(char const   *name ) 
{ Authmethod *method ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;

  {
#line 563
  method = (Authmethod *)((void *)0);
#line 564
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 565
    method = authmethods;
#line 565
    while ((unsigned int )method->name != (unsigned int )((void *)0)) {
#line 568
      if ((unsigned int )method->enabled != (unsigned int )((void *)0)) {
#line 568
        if (*(method->enabled) != 0) {
#line 568
          if (0) {
#line 568
            __s1_len = strlen(name);
#line 568
            __s2_len = strlen((char const   *)method->name);
#line 568
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
              goto _L___0;
            } else {
#line 568
              if (__s1_len >= 4U) {
                _L___0: /* CIL Label */ 
#line 568
                if (! ((unsigned int )((void const   *)(method->name + 1)) - (unsigned int )((void const   *)method->name) == 1U)) {
#line 568
                  tmp___8 = 1;
                } else {
#line 568
                  if (__s2_len >= 4U) {
#line 568
                    tmp___8 = 1;
                  } else {
#line 568
                    tmp___8 = 0;
                  }
                }
              } else {
#line 568
                tmp___8 = 0;
              }
            }
#line 568
            if (tmp___8) {
#line 568
              tmp___4 = __builtin_strcmp(name, (char const   *)method->name);
            } else {
#line 568
              tmp___7 = __builtin_strcmp(name, (char const   *)method->name);
#line 568
              tmp___4 = tmp___7;
            }
          } else {
#line 568
            tmp___7 = __builtin_strcmp(name, (char const   *)method->name);
#line 568
            tmp___4 = tmp___7;
          }
#line 568
          if (tmp___4 == 0) {
#line 569
            return (method);
          }
        }
      }
#line 565
      method ++;
    }
  }
#line 570
  if (name) {
#line 570
    tmp___9 = name;
  } else {
#line 570
    tmp___9 = "NULL";
  }
#line 570
  debug2("Unrecognized authentication method name: %s", tmp___9);
#line 571
  return ((Authmethod *)((void *)0));
}
}
#line 623 "auth2.c"
static char const   *check___0[3]  = {      "",      ".ssh",      (char const   *)((void *)0)};
#line 575 "auth2.c"
int user_key_allowed(struct passwd *pw , Key *key ) 
{ char line[8192] ;
  char file[4096] ;
  int found_key ;
  FILE *f ;
  u_long linenum ;
  struct stat st ;
  Key *found ;
  int tmp ;
  int fail ;
  char buf___2[1024] ;
  char *tmp___0 ;
  int i ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *cp ;
  char *options___0 ;
  int quoted ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;

  {
#line 579
  found_key = 0;
#line 581
  linenum = (u_long )0;
#line 585
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 586
    return (0);
  }
#line 589
  temporarily_use_uid(pw->pw_uid);
#line 592
  snprintf((char * __restrict  )(file), sizeof(file), (char const   * __restrict  )"%.500s/%.100s",
           pw->pw_dir, ".ssh/authorized_keys2");
#line 596
  tmp = stat((char const   * __restrict  )(file), (struct stat * __restrict  )(& st));
#line 596
  if (tmp < 0) {
#line 598
    restore_uid();
#line 599
    return (0);
  }
#line 602
  f = fopen((char const   * __restrict  )(file), (char const   * __restrict  )"r");
#line 603
  if (! f) {
#line 605
    restore_uid();
#line 606
    return (0);
  }
#line 608
  if (options.strict_modes) {
#line 609
    fail = 0;
#line 612
    tmp___3 = fileno(f);
#line 612
    tmp___4 = fstat(tmp___3, & st);
#line 612
    if (tmp___4 < 0) {
#line 615
      tmp___0 = key_type(key);
#line 615
      snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"%s authentication refused for %.100s: bad ownership or modes for \'%s\'.",
               tmp___0, pw->pw_name, file);
#line 619
      fail = 1;
    } else {
#line 612
      if (st.st_uid != 0U) {
#line 612
        if (st.st_uid != pw->pw_uid) {
#line 615
          tmp___0 = key_type(key);
#line 615
          snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"%s authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   tmp___0, pw->pw_name, file);
#line 619
          fail = 1;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 612
        if ((st.st_mode & 18U) != 0U) {
#line 615
          tmp___0 = key_type(key);
#line 615
          snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"%s authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   tmp___0, pw->pw_name, file);
#line 619
          fail = 1;
        } else {
#line 626
          i = 0;
#line 626
          while (check___0[i]) {
#line 627
            snprintf((char * __restrict  )(line), sizeof(line), (char const   * __restrict  )"%.500s/%.100s",
                     pw->pw_dir, check___0[i]);
#line 629
            tmp___2 = stat((char const   * __restrict  )(line), (struct stat * __restrict  )(& st));
#line 629
            if (tmp___2 < 0) {
#line 632
              tmp___1 = key_type(key);
#line 632
              snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"%s authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                       tmp___1, pw->pw_name, line);
#line 636
              fail = 1;
#line 637
              break;
            } else {
#line 629
              if (st.st_uid != 0U) {
#line 629
                if (st.st_uid != pw->pw_uid) {
#line 632
                  tmp___1 = key_type(key);
#line 632
                  snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"%s authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           tmp___1, pw->pw_name, line);
#line 636
                  fail = 1;
#line 637
                  break;
                } else {
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
#line 629
                if ((st.st_mode & 18U) != 0U) {
#line 632
                  tmp___1 = key_type(key);
#line 632
                  snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"%s authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           tmp___1, pw->pw_name, line);
#line 636
                  fail = 1;
#line 637
                  break;
                }
              }
            }
#line 626
            i ++;
          }
        }
      }
    }
#line 641
    if (fail) {
#line 642
      fclose(f);
#line 643
      log("%s", buf___2);
#line 644
      restore_uid();
#line 645
      return (0);
    }
  }
#line 648
  found_key = 0;
#line 649
  found = key_new(key->type);
#line 651
  while (1) {
#line 651
    tmp___9 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 651
    if (! tmp___9) {
#line 651
      break;
    }
#line 652
    options___0 = (char *)((void *)0);
#line 653
    linenum ++;
#line 655
    cp = line;
#line 655
    while (1) {
#line 655
      if (! ((int )*cp == 32)) {
#line 655
        if (! ((int )*cp == 9)) {
#line 655
          break;
        }
      }
#line 655
      cp ++;
    }
#line 657
    if (! *cp) {
#line 658
      continue;
    } else {
#line 657
      if ((int )*cp == 10) {
#line 658
        continue;
      } else {
#line 657
        if ((int )*cp == 35) {
#line 658
          continue;
        }
      }
    }
#line 660
    tmp___6 = key_read(found, & cp);
#line 660
    if (tmp___6 == -1) {
#line 662
      quoted = 0;
#line 663
      debug2("user_key_allowed: check options: \'%s\'", cp);
#line 664
      options___0 = cp;
#line 665
      while (1) {
#line 665
        if (*cp) {
#line 665
          if (! quoted) {
#line 665
            if ((int )*cp != 32) {
#line 665
              if (! ((int )*cp != 9)) {
#line 665
                break;
              }
            } else {
#line 665
              break;
            }
          }
        } else {
#line 665
          break;
        }
#line 666
        if ((int )*cp == 92) {
#line 666
          if ((int )*(cp + 1) == 34) {
#line 667
            cp ++;
          } else {
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
#line 668
          if ((int )*cp == 34) {
#line 669
            quoted = ! quoted;
          }
        }
#line 665
        cp ++;
      }
#line 672
      while (1) {
#line 672
        if (! ((int )*cp == 32)) {
#line 672
          if (! ((int )*cp == 9)) {
#line 672
            break;
          }
        }
#line 672
        cp ++;
      }
#line 674
      tmp___5 = key_read(found, & cp);
#line 674
      if (tmp___5 == -1) {
#line 675
        debug2("user_key_allowed: advance: \'%s\'", cp);
#line 677
        continue;
      }
    }
#line 680
    tmp___7 = key_equal(found, key);
#line 680
    if (tmp___7) {
#line 680
      tmp___8 = auth_parse_options(pw, options___0, file, linenum);
#line 680
      if (tmp___8 == 1) {
#line 682
        found_key = 1;
#line 683
        debug("matching key found: file %s, line %ld", file, linenum);
#line 685
        break;
      }
    }
  }
#line 688
  restore_uid();
#line 689
  fclose(f);
#line 690
  key_free(found);
#line 691
  return (found_key);
}
}
#line 1 "auth-chall.o"
#pragma merger(0,"./auth-chall.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 93 "auth-chall.c"
char *get_challenge(Authctxt *authctxt , char *devs ) 
{ 

  {
#line 96
  return ((char *)((void *)0));
}
}
#line 98 "auth-chall.c"
int verify_response(Authctxt *authctxt , char *response ) 
{ 

  {
#line 101
  return (0);
}
}
#line 1 "auth2-chall.o"
#pragma merger(0,"./auth2-chall.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 34 "auth2-chall.c"
void send_userauth_into_request(Authctxt *authctxt , char *challenge , int echo ) ;
#line 35
void input_userauth_info_response(int type , int plen , void *ctxt ) ;
#line 41 "auth2-chall.c"
int auth2_challenge(Authctxt *authctxt , char *devs ) 
{ char *challenge ;

  {
#line 46
  if (! authctxt->valid) {
#line 47
    return (0);
  } else {
#line 46
    if ((unsigned int )authctxt->user == (unsigned int )((void *)0)) {
#line 47
      return (0);
    }
  }
#line 48
  challenge = get_challenge(authctxt, devs);
#line 48
  if ((unsigned int )challenge == (unsigned int )((void *)0)) {
#line 49
    return (0);
  }
#line 50
  send_userauth_into_request(authctxt, challenge, 0);
#line 51
  dispatch_set(61, & input_userauth_info_response);
#line 53
  authctxt->postponed = 1;
#line 54
  return (0);
}
}
#line 57 "auth2-chall.c"
void send_userauth_into_request(Authctxt *authctxt , char *challenge , int echo ) 
{ int nprompts ;

  {
#line 60
  nprompts = 1;
#line 62
  packet_start(60);
#line 64
  packet_put_cstring("");
#line 65
  packet_put_cstring("");
#line 66
  packet_put_cstring("");
#line 67
  packet_put_int((unsigned int )nprompts);
#line 68
  packet_put_cstring((char const   *)challenge);
#line 69
  packet_put_char(echo);
#line 70
  packet_send();
#line 71
  packet_write_wait();
#line 72
  return;
}
}
#line 74 "auth2-chall.c"
void input_userauth_info_response(int type , int plen , void *ctxt ) 
{ Authctxt *authctxt ;
  int authenticated ;
  u_int nresp ;
  u_int rlen ;
  char *response ;
  char *method ;
  int _len ;
  int tmp ;
  char *challenge ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
#line 77
  authctxt = (Authctxt *)ctxt;
#line 78
  authenticated = 0;
#line 80
  method = (char *)"challenge-reponse";
#line 82
  if ((unsigned int )authctxt == (unsigned int )((void *)0)) {
#line 83
    fatal("input_userauth_info_response: no authctxt");
  }
#line 85
  authctxt->postponed = 0;
#line 86
  nresp = packet_get_int();
#line 87
  if (nresp == 1U) {
#line 88
    response = packet_get_string(& rlen);
#line 89
    while (1) {
#line 89
      tmp = packet_remaining();
#line 89
      _len = tmp;
#line 89
      if (_len > 0) {
#line 89
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2-chall.c",
            89);
#line 89
        packet_disconnect("Packet integrity error.");
      }
#line 89
      break;
    }
#line 90
    tmp___1 = strlen((char const   *)response);
#line 90
    if (tmp___1 == 0U) {
#line 95
      tmp___0 = get_challenge(authctxt, (char *)((void *)0));
#line 95
      challenge = tmp___0;
#line 96
      if ((unsigned int )challenge != (unsigned int )((void *)0)) {
#line 97
        send_userauth_into_request(authctxt, challenge, 1);
#line 99
        authctxt->postponed = 1;
      }
    } else {
#line 101
      if (authctxt->valid) {
#line 102
        authenticated = verify_response(authctxt, response);
#line 103
        memset((void *)response, 'r', rlen);
      }
    }
#line 105
    xfree((void *)response);
  }
#line 107
  auth_log(authctxt, authenticated, method, (char *)" ssh2");
#line 108
  if (! authctxt->postponed) {
#line 110
    dispatch_set(61, (dispatch_fn *)((void *)0));
#line 111
    userauth_reply(authctxt, authenticated);
  }
#line 113
  return;
}
}
#line 1 "auth-rhosts.o"
#pragma merger(0,"./auth-rhosts.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 418 "/usr/include/netdb.h"
extern int innetgr(char const   *__netgroup , char const   *__host , char const   *__user ,
                   char const   *domain ) ;
#line 34 "auth-rhosts.c"
int check_rhosts_file(char const   *filename , char const   *hostname , char const   *ipaddr ,
                      char const   *client_user , char const   *server_user ) 
{ FILE *f ;
  char buf___2[1024] ;
  char hostbuf[1024] ;
  char userbuf[1024] ;
  char dummy[1024] ;
  char *host ;
  char *user ;
  char *cp ;
  int negated ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___45 ;
  int tmp___48 ;
  int tmp___49 ;
  char *tmp___50 ;

  {
#line 43
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 44
  if (! f) {
#line 45
    return (0);
  }
#line 47
  while (1) {
#line 47
    tmp___50 = fgets((char * __restrict  )(buf___2), (int )sizeof(buf___2), (FILE * __restrict  )f);
#line 47
    if (! tmp___50) {
#line 47
      break;
    }
#line 52
    cp = buf___2;
#line 52
    while (1) {
#line 52
      if (! ((int )*cp == 32)) {
#line 52
        if (! ((int )*cp == 9)) {
#line 52
          break;
        }
      }
#line 52
      cp ++;
    }
#line 54
    if ((int )*cp == 35) {
#line 55
      continue;
    } else {
#line 54
      if ((int )*cp == 10) {
#line 55
        continue;
      } else {
#line 54
        if (! *cp) {
#line 55
          continue;
        }
      }
    }
#line 61
    if (0) {
#line 61
      if (0) {
#line 61
        __s1_len___0 = strlen((char const   *)cp);
#line 61
        __s2_len___0 = strlen("NO_PLUS");
#line 61
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___2;
        } else {
#line 61
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 61
            if (! ((unsigned int )((void const   *)("NO_PLUS" + 1)) - (unsigned int )((void const   *)"NO_PLUS") == 1U)) {
#line 61
              tmp___22 = 1;
            } else {
#line 61
              if (__s2_len___0 >= 4U) {
#line 61
                tmp___22 = 1;
              } else {
#line 61
                tmp___22 = 0;
              }
            }
          } else {
#line 61
            tmp___22 = 0;
          }
        }
#line 61
        if (tmp___22) {
#line 61
          tmp___18 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
        } else {
#line 61
          tmp___21 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 61
          tmp___18 = tmp___21;
        }
      } else {
#line 61
        tmp___21 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 61
        tmp___18 = tmp___21;
      }
#line 61
      tmp___12 = tmp___18;
    } else {
#line 61
      tmp___12 = strncmp((char const   *)cp, "NO_PLUS", 7U);
    }
#line 61
    if (tmp___12 == 0) {
#line 62
      continue;
    }
#line 68
    tmp___25 = sscanf((char const   * __restrict  )(buf___2), (char const   * __restrict  )"%s %s %s",
                      hostbuf, userbuf, dummy);
#line 68
    switch (tmp___25) {
    case 0: 
#line 70
    packet_send_debug("Found empty line in %.100s.", filename);
#line 71
    continue;
    case 1: 
#line 74
    strlcpy(userbuf, server_user, sizeof(userbuf));
#line 75
    break;
    case 2: 
#line 78
    break;
    case 3: 
#line 80
    packet_send_debug("Found garbage in %.100s.", filename);
#line 81
    continue;
    default: ;
#line 84
    continue;
    }
#line 87
    host = hostbuf;
#line 88
    user = userbuf;
#line 89
    negated = 0;
#line 92
    if ((int )*(host + 0) == 45) {
#line 93
      negated = 1;
#line 94
      host ++;
    } else {
#line 95
      if ((int )*(host + 0) == 43) {
#line 96
        host ++;
      }
    }
#line 98
    if ((int )*(user + 0) == 45) {
#line 99
      negated = 1;
#line 100
      user ++;
    } else {
#line 101
      if ((int )*(user + 0) == 43) {
#line 102
        user ++;
      }
    }
#line 105
    if (! *(host + 0)) {
#line 107
      packet_send_debug("Ignoring wild host/user names in %.100s.", filename);
#line 109
      continue;
    } else {
#line 105
      if (! *(user + 0)) {
#line 107
        packet_send_debug("Ignoring wild host/user names in %.100s.", filename);
#line 109
        continue;
      }
    }
#line 112
    if ((int )*(host + 0) == 64) {
#line 113
      tmp___26 = innetgr((char const   *)(host + 1), hostname, (char const   *)((void *)0),
                         (char const   *)((void *)0));
#line 113
      if (! tmp___26) {
#line 113
        tmp___27 = innetgr((char const   *)(host + 1), ipaddr, (char const   *)((void *)0),
                           (char const   *)((void *)0));
#line 113
        if (! tmp___27) {
#line 115
          continue;
        }
      }
    } else {
#line 116
      tmp___28 = strcasecmp((char const   *)host, hostname);
#line 116
      if (tmp___28) {
#line 116
        if (0) {
#line 116
          __s1_len___1 = strlen((char const   *)host);
#line 116
          __s2_len___1 = strlen(ipaddr);
#line 116
          if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
            goto _L___4;
          } else {
#line 116
            if (__s1_len___1 >= 4U) {
              _L___4: /* CIL Label */ 
#line 116
              if (! ((unsigned int )((void const   *)(ipaddr + 1)) - (unsigned int )((void const   *)ipaddr) == 1U)) {
#line 116
                tmp___38 = 1;
              } else {
#line 116
                if (__s2_len___1 >= 4U) {
#line 116
                  tmp___38 = 1;
                } else {
#line 116
                  tmp___38 = 0;
                }
              }
            } else {
#line 116
              tmp___38 = 0;
            }
          }
#line 116
          if (tmp___38) {
#line 116
            tmp___34 = __builtin_strcmp((char const   *)host, ipaddr);
          } else {
#line 116
            tmp___37 = __builtin_strcmp((char const   *)host, ipaddr);
#line 116
            tmp___34 = tmp___37;
          }
        } else {
#line 116
          tmp___37 = __builtin_strcmp((char const   *)host, ipaddr);
#line 116
          tmp___34 = tmp___37;
        }
#line 116
        if (tmp___34 != 0) {
#line 117
          continue;
        }
      }
    }
#line 120
    if ((int )*(user + 0) == 64) {
#line 121
      tmp___39 = innetgr((char const   *)(user + 1), (char const   *)((void *)0),
                         client_user, (char const   *)((void *)0));
#line 121
      if (! tmp___39) {
#line 122
        continue;
      }
    } else {
#line 123
      if (0) {
#line 123
        __s1_len___2 = strlen((char const   *)user);
#line 123
        __s2_len___2 = strlen(client_user);
#line 123
        if (! ((unsigned int )((void const   *)(user + 1)) - (unsigned int )((void const   *)user) == 1U)) {
          goto _L___6;
        } else {
#line 123
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 123
            if (! ((unsigned int )((void const   *)(client_user + 1)) - (unsigned int )((void const   *)client_user) == 1U)) {
#line 123
              tmp___49 = 1;
            } else {
#line 123
              if (__s2_len___2 >= 4U) {
#line 123
                tmp___49 = 1;
              } else {
#line 123
                tmp___49 = 0;
              }
            }
          } else {
#line 123
            tmp___49 = 0;
          }
        }
#line 123
        if (tmp___49) {
#line 123
          tmp___45 = __builtin_strcmp((char const   *)user, client_user);
        } else {
#line 123
          tmp___48 = __builtin_strcmp((char const   *)user, client_user);
#line 123
          tmp___45 = tmp___48;
        }
      } else {
#line 123
        tmp___48 = __builtin_strcmp((char const   *)user, client_user);
#line 123
        tmp___45 = tmp___48;
      }
#line 123
      if (tmp___45 != 0) {
#line 124
        continue;
      }
    }
#line 127
    fclose(f);
#line 130
    if (negated) {
#line 131
      packet_send_debug("Matched negative entry in %.100s.", filename);
#line 133
      return (0);
    }
#line 136
    return (1);
  }
#line 140
  fclose(f);
#line 141
  return (0);
}
}
#line 157 "auth-rhosts.c"
static char const   *rhosts_files[3]  = {      ".shosts",      ".rhosts",      (char const   *)((void *)0)};
#line 150 "auth-rhosts.c"
int auth_rhosts(struct passwd *pw , char const   *client_user ) 
{ char buf___2[1024] ;
  char const   *hostname ;
  char const   *ipaddr ;
  struct stat st ;
  u_int rhosts_file_index ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 161
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 162
    return (0);
  }
#line 164
  temporarily_use_uid(pw->pw_uid);
#line 170
  rhosts_file_index = 0U;
#line 170
  while (rhosts_files[rhosts_file_index]) {
#line 173
    snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"%.500s/%.100s",
             pw->pw_dir, rhosts_files[rhosts_file_index]);
#line 175
    tmp = stat((char const   * __restrict  )(buf___2), (struct stat * __restrict  )(& st));
#line 175
    if (tmp >= 0) {
#line 176
      break;
    }
#line 170
    rhosts_file_index ++;
  }
#line 179
  restore_uid();
#line 182
  if (! rhosts_files[rhosts_file_index]) {
#line 182
    tmp___0 = stat((char const   * __restrict  )"/etc/hosts.equiv", (struct stat * __restrict  )(& st));
#line 182
    if (tmp___0 < 0) {
#line 182
      tmp___1 = stat((char const   * __restrict  )"/usr/local/etc/shosts.equiv", (struct stat * __restrict  )(& st));
#line 182
      if (tmp___1 < 0) {
#line 185
        return (0);
      }
    }
  }
#line 187
  hostname = get_canonical_hostname(options.reverse_mapping_check);
#line 188
  ipaddr = get_remote_ipaddr();
#line 191
  if (pw->pw_uid != 0U) {
#line 192
    tmp___2 = check_rhosts_file("/etc/hosts.equiv", hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 192
    if (tmp___2) {
#line 194
      packet_send_debug("Accepted for %.100s [%.100s] by /etc/hosts.equiv.", hostname,
                        ipaddr);
#line 196
      return (1);
    }
#line 198
    tmp___3 = check_rhosts_file("/usr/local/etc/shosts.equiv", hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 198
    if (tmp___3) {
#line 200
      packet_send_debug("Accepted for %.100s [%.100s] by %.100s.", hostname, ipaddr,
                        "/usr/local/etc/shosts.equiv");
#line 202
      return (1);
    }
  }
#line 209
  tmp___4 = stat((char const   * __restrict  )pw->pw_dir, (struct stat * __restrict  )(& st));
#line 209
  if (tmp___4 < 0) {
#line 210
    log("Rhosts authentication refused for %.100s: no home directory %.200s", pw->pw_name,
        pw->pw_dir);
#line 212
    packet_send_debug("Rhosts authentication refused for %.100s: no home directory %.200s",
                      pw->pw_name, pw->pw_dir);
#line 214
    return (0);
  }
#line 216
  if (options.strict_modes) {
#line 216
    if (st.st_uid != 0U) {
#line 216
      if (st.st_uid != pw->pw_uid) {
#line 219
        log("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
            pw->pw_name);
#line 221
        packet_send_debug("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                          pw->pw_name);
#line 223
        return (0);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 216
      if ((st.st_mode & 18U) != 0U) {
#line 219
        log("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
            pw->pw_name);
#line 221
        packet_send_debug("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                          pw->pw_name);
#line 223
        return (0);
      }
    }
  }
#line 226
  temporarily_use_uid(pw->pw_uid);
#line 229
  rhosts_file_index = 0U;
#line 229
  while (rhosts_files[rhosts_file_index]) {
#line 232
    snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"%.500s/%.100s",
             pw->pw_dir, rhosts_files[rhosts_file_index]);
#line 234
    tmp___5 = stat((char const   * __restrict  )(buf___2), (struct stat * __restrict  )(& st));
#line 234
    if (tmp___5 < 0) {
      goto __Cont;
    }
#line 243
    if (options.strict_modes) {
#line 243
      if (st.st_uid != 0U) {
#line 243
        if (st.st_uid != pw->pw_uid) {
#line 246
          log("Rhosts authentication refused for %.100s: bad modes for %.200s", pw->pw_name,
              buf___2);
#line 248
          packet_send_debug("Bad file modes for %.200s", buf___2);
          goto __Cont;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 243
        if ((st.st_mode & 18U) != 0U) {
#line 246
          log("Rhosts authentication refused for %.100s: bad modes for %.200s", pw->pw_name,
              buf___2);
#line 248
          packet_send_debug("Bad file modes for %.200s", buf___2);
          goto __Cont;
        }
      }
    }
#line 252
    if (options.ignore_rhosts) {
#line 253
      packet_send_debug("Server has been configured to ignore %.100s.", rhosts_files[rhosts_file_index]);
      goto __Cont;
    }
#line 258
    tmp___6 = check_rhosts_file((char const   *)(buf___2), hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 258
    if (tmp___6) {
#line 259
      packet_send_debug("Accepted by %.100s.", rhosts_files[rhosts_file_index]);
#line 262
      restore_uid();
#line 263
      return (1);
    }
    __Cont: /* CIL Label */ 
#line 229
    rhosts_file_index ++;
  }
#line 268
  restore_uid();
#line 269
  return (0);
}
}
#line 1 "auth-options.o"
#pragma merger(0,"./auth-options.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 329 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 26 "auth-options.h"
int no_port_forwarding_flag ;
#line 27
int no_agent_forwarding_flag ;
#line 28
int no_x11_forwarding_flag ;
#line 29
int no_pty_flag ;
#line 31
struct envstring *custom_environment ;
#line 24 "auth-options.c"
int no_port_forwarding_flag  =    0;
#line 25 "auth-options.c"
int no_agent_forwarding_flag  =    0;
#line 26 "auth-options.c"
int no_x11_forwarding_flag  =    0;
#line 27 "auth-options.c"
int no_pty_flag  =    0;
#line 30 "auth-options.c"
char *forced_command  =    (char *)((void *)0);
#line 33 "auth-options.c"
struct envstring *custom_environment  =    (struct envstring *)((void *)0);
#line 37 "auth-options.c"
void auth_clear_options(void) 
{ struct envstring *ce ;

  {
#line 40
  no_agent_forwarding_flag = 0;
#line 41
  no_port_forwarding_flag = 0;
#line 42
  no_pty_flag = 0;
#line 43
  no_x11_forwarding_flag = 0;
#line 44
  while (custom_environment) {
#line 45
    ce = custom_environment;
#line 46
    custom_environment = ce->next;
#line 47
    xfree((void *)ce->s);
#line 48
    xfree((void *)ce);
  }
#line 50
  if (forced_command) {
#line 51
    xfree((void *)forced_command);
#line 52
    forced_command = (char *)((void *)0);
  }
#line 54
  return;
}
}
#line 60 "auth-options.c"
int auth_parse_options(struct passwd *pw , char *opts , char *file , u_long linenum ) 
{ char const   *cp ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  int i ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  size_t tmp___17 ;
  int tmp___18 ;
  int i___0 ;
  char *s ;
  struct envstring *new_envstring ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  void *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  void *tmp___25 ;
  size_t tmp___26 ;
  int tmp___27 ;
  int mname ;
  int mip ;
  char const   *remote_ip ;
  char const   *tmp___28 ;
  char const   *remote_host ;
  char const   *tmp___29 ;
  char *patterns ;
  size_t tmp___30 ;
  void *tmp___31 ;
  int i___1 ;
  size_t tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  char *tmp___35 ;
  size_t tmp___36 ;
  size_t tmp___37 ;
  size_t tmp___38 ;
  int tmp___39 ;

  {
#line 66
  auth_clear_options();
#line 68
  if (! opts) {
#line 69
    return (1);
  }
#line 71
  while (1) {
#line 71
    if (*opts) {
#line 71
      if ((int )*opts != 32) {
#line 71
        if (! ((int )*opts != 9)) {
#line 71
          break;
        }
      } else {
#line 71
        break;
      }
    } else {
#line 71
      break;
    }
#line 72
    cp = "no-port-forwarding";
#line 73
    tmp___0 = strlen(cp);
#line 73
    tmp___1 = strncasecmp((char const   *)opts, cp, tmp___0);
#line 73
    if (tmp___1 == 0) {
#line 74
      packet_send_debug("Port forwarding disabled.");
#line 75
      no_port_forwarding_flag = 1;
#line 76
      tmp = strlen(cp);
#line 76
      opts += tmp;
      goto next_option;
    }
#line 79
    cp = "no-agent-forwarding";
#line 80
    tmp___3 = strlen(cp);
#line 80
    tmp___4 = strncasecmp((char const   *)opts, cp, tmp___3);
#line 80
    if (tmp___4 == 0) {
#line 81
      packet_send_debug("Agent forwarding disabled.");
#line 82
      no_agent_forwarding_flag = 1;
#line 83
      tmp___2 = strlen(cp);
#line 83
      opts += tmp___2;
      goto next_option;
    }
#line 86
    cp = "no-X11-forwarding";
#line 87
    tmp___6 = strlen(cp);
#line 87
    tmp___7 = strncasecmp((char const   *)opts, cp, tmp___6);
#line 87
    if (tmp___7 == 0) {
#line 88
      packet_send_debug("X11 forwarding disabled.");
#line 89
      no_x11_forwarding_flag = 1;
#line 90
      tmp___5 = strlen(cp);
#line 90
      opts += tmp___5;
      goto next_option;
    }
#line 93
    cp = "no-pty";
#line 94
    tmp___9 = strlen(cp);
#line 94
    tmp___10 = strncasecmp((char const   *)opts, cp, tmp___9);
#line 94
    if (tmp___10 == 0) {
#line 95
      packet_send_debug("Pty allocation disabled.");
#line 96
      no_pty_flag = 1;
#line 97
      tmp___8 = strlen(cp);
#line 97
      opts += tmp___8;
      goto next_option;
    }
#line 100
    cp = "command=\"";
#line 101
    tmp___17 = strlen(cp);
#line 101
    tmp___18 = strncasecmp((char const   *)opts, cp, tmp___17);
#line 101
    if (tmp___18 == 0) {
#line 103
      tmp___11 = strlen(cp);
#line 103
      opts += tmp___11;
#line 104
      tmp___12 = strlen((char const   *)opts);
#line 104
      tmp___13 = xmalloc(tmp___12 + 1U);
#line 104
      forced_command = (char *)tmp___13;
#line 105
      i = 0;
#line 106
      while (*opts) {
#line 107
        if ((int )*opts == 34) {
#line 108
          break;
        }
#line 109
        if ((int )*opts == 92) {
#line 109
          if ((int )*(opts + 1) == 34) {
#line 110
            opts += 2;
#line 111
            tmp___14 = i;
#line 111
            i ++;
#line 111
            *(forced_command + tmp___14) = (char )'\"';
#line 112
            continue;
          }
        }
#line 114
        tmp___15 = i;
#line 114
        i ++;
#line 114
        tmp___16 = opts;
#line 114
        opts ++;
#line 114
        *(forced_command + tmp___15) = *tmp___16;
      }
#line 116
      if (! *opts) {
#line 117
        debug("%.100s, line %lu: missing end quote", file, linenum);
#line 119
        packet_send_debug("%.100s, line %lu: missing end quote", file, linenum);
#line 121
        continue;
      }
#line 123
      *(forced_command + i) = (char)0;
#line 124
      packet_send_debug("Forced command: %.900s", forced_command);
#line 125
      opts ++;
      goto next_option;
    }
#line 128
    cp = "environment=\"";
#line 129
    tmp___26 = strlen(cp);
#line 129
    tmp___27 = strncasecmp((char const   *)opts, cp, tmp___26);
#line 129
    if (tmp___27 == 0) {
#line 133
      tmp___19 = strlen(cp);
#line 133
      opts += tmp___19;
#line 134
      tmp___20 = strlen((char const   *)opts);
#line 134
      tmp___21 = xmalloc(tmp___20 + 1U);
#line 134
      s = (char *)tmp___21;
#line 135
      i___0 = 0;
#line 136
      while (*opts) {
#line 137
        if ((int )*opts == 34) {
#line 138
          break;
        }
#line 139
        if ((int )*opts == 92) {
#line 139
          if ((int )*(opts + 1) == 34) {
#line 140
            opts += 2;
#line 141
            tmp___22 = i___0;
#line 141
            i___0 ++;
#line 141
            *(s + tmp___22) = (char )'\"';
#line 142
            continue;
          }
        }
#line 144
        tmp___23 = i___0;
#line 144
        i___0 ++;
#line 144
        tmp___24 = opts;
#line 144
        opts ++;
#line 144
        *(s + tmp___23) = *tmp___24;
      }
#line 146
      if (! *opts) {
#line 147
        debug("%.100s, line %lu: missing end quote", file, linenum);
#line 149
        packet_send_debug("%.100s, line %lu: missing end quote", file, linenum);
#line 151
        continue;
      }
#line 153
      *(s + i___0) = (char)0;
#line 154
      packet_send_debug("Adding to environment: %.900s", s);
#line 155
      debug("Adding to environment: %.900s", s);
#line 156
      opts ++;
#line 157
      tmp___25 = xmalloc(sizeof(struct envstring ));
#line 157
      new_envstring = (struct envstring *)tmp___25;
#line 158
      new_envstring->s = s;
#line 159
      new_envstring->next = custom_environment;
#line 160
      custom_environment = new_envstring;
      goto next_option;
    }
#line 163
    cp = "from=\"";
#line 164
    tmp___38 = strlen(cp);
#line 164
    tmp___39 = strncasecmp((char const   *)opts, cp, tmp___38);
#line 164
    if (tmp___39 == 0) {
#line 166
      tmp___28 = get_remote_ipaddr();
#line 166
      remote_ip = tmp___28;
#line 167
      tmp___29 = get_canonical_hostname(options.reverse_mapping_check);
#line 167
      remote_host = tmp___29;
#line 169
      tmp___30 = strlen((char const   *)opts);
#line 169
      tmp___31 = xmalloc(tmp___30 + 1U);
#line 169
      patterns = (char *)tmp___31;
#line 171
      tmp___32 = strlen(cp);
#line 171
      opts += tmp___32;
#line 172
      i___1 = 0;
#line 173
      while (*opts) {
#line 174
        if ((int )*opts == 34) {
#line 175
          break;
        }
#line 176
        if ((int )*opts == 92) {
#line 176
          if ((int )*(opts + 1) == 34) {
#line 177
            opts += 2;
#line 178
            tmp___33 = i___1;
#line 178
            i___1 ++;
#line 178
            *(patterns + tmp___33) = (char )'\"';
#line 179
            continue;
          }
        }
#line 181
        tmp___34 = i___1;
#line 181
        i___1 ++;
#line 181
        tmp___35 = opts;
#line 181
        opts ++;
#line 181
        *(patterns + tmp___34) = *tmp___35;
      }
#line 183
      if (! *opts) {
#line 184
        debug("%.100s, line %lu: missing end quote", file, linenum);
#line 186
        packet_send_debug("%.100s, line %lu: missing end quote", file, linenum);
#line 188
        continue;
      }
#line 190
      *(patterns + i___1) = (char)0;
#line 191
      opts ++;
#line 197
      tmp___36 = strlen((char const   *)patterns);
#line 197
      mname = match_hostname(remote_host, (char const   *)patterns, tmp___36);
#line 199
      tmp___37 = strlen((char const   *)patterns);
#line 199
      mip = match_hostname(remote_ip, (char const   *)patterns, tmp___37);
#line 201
      xfree((void *)patterns);
#line 202
      if (mname == -1) {
#line 204
        log("Authentication tried for %.100s with correct key but not from a permitted host (host=%.200s, ip=%.200s).",
            pw->pw_name, remote_host, remote_ip);
#line 208
        packet_send_debug("Your host \'%.200s\' is not permitted to use this key for login.",
                          remote_host);
#line 212
        return (0);
      } else {
#line 202
        if (mip == -1) {
#line 204
          log("Authentication tried for %.100s with correct key but not from a permitted host (host=%.200s, ip=%.200s).",
              pw->pw_name, remote_host, remote_ip);
#line 208
          packet_send_debug("Your host \'%.200s\' is not permitted to use this key for login.",
                            remote_host);
#line 212
          return (0);
        } else {
#line 202
          if (mname != 1) {
#line 202
            if (mip != 1) {
#line 204
              log("Authentication tried for %.100s with correct key but not from a permitted host (host=%.200s, ip=%.200s).",
                  pw->pw_name, remote_host, remote_ip);
#line 208
              packet_send_debug("Your host \'%.200s\' is not permitted to use this key for login.",
                                remote_host);
#line 212
              return (0);
            }
          }
        }
      }
      goto next_option;
    }
    next_option: 
#line 222
    if (! *opts) {
#line 223
      fatal("Bugs in auth-options.c option processing.");
    }
#line 224
    if ((int )*opts == 32) {
#line 225
      break;
    } else {
#line 224
      if ((int )*opts == 9) {
#line 225
        break;
      }
    }
#line 226
    if ((int )*opts != 44) {
      goto bad_option;
    }
#line 228
    opts ++;
  }
#line 232
  return (1);
  bad_option: 
#line 235
  log("Bad options in %.100s file, line %lu: %.50s", file, linenum, opts);
#line 237
  packet_send_debug("Bad options in %.100s file, line %lu: %.50s", file, linenum,
                    opts);
#line 240
  return (0);
}
}
#line 1 "auth-krb4.o"
#pragma merger(0,"./auth-krb4.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "auth-pam.o"
#pragma merger(0,"./auth-pam.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "auth2-pam.o"
#pragma merger(0,"./auth2-pam.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "auth-passwd.o"
#pragma merger(0,"./auth-passwd.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 209 "auth-passwd.c"
extern int ( /* missing proto */  crypt)() ;
#line 87 "auth-passwd.c"
int auth_password(Authctxt *authctxt , char const   *password ) 
{ struct passwd *pw ;
  char *encrypted_password ;
  char *pw_password ;
  char *salt ;
  struct spwd *spw ;
  int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 90
  pw = authctxt->pw;
#line 113
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 114
    return (0);
  }
#line 116
  if (pw->pw_uid == 0U) {
#line 116
    if (options.permit_root_login != 3) {
#line 117
      return (0);
    }
  }
#line 126
  if ((int const   )*password == 0) {
#line 126
    if (options.permit_empty_passwd == 0) {
#line 127
      return (0);
    }
  }
#line 161
  pw_password = pw->pw_passwd;
#line 167
  spw = getspnam((char const   *)pw->pw_name);
#line 168
  if ((unsigned int )spw != (unsigned int )((void *)0)) {
#line 169
    pw_password = spw->sp_pwdp;
  }
#line 189
  if ((int const   )*(password + 0) == 0) {
#line 189
    if ((int )*(pw_password + 0) == 0) {
#line 190
      return (1);
    }
  }
#line 192
  if ((int )*(pw_password + 0) != 0) {
#line 193
    salt = pw_password;
  } else {
#line 195
    salt = (char *)"xx";
  }
#line 209
  tmp = crypt(password, salt);
#line 209
  encrypted_password = (char *)tmp;
#line 214
  if (0) {
#line 214
    __s1_len = strlen((char const   *)encrypted_password);
#line 214
    __s2_len = strlen((char const   *)pw_password);
#line 214
    if (! ((unsigned int )((void const   *)(encrypted_password + 1)) - (unsigned int )((void const   *)encrypted_password) == 1U)) {
      goto _L___0;
    } else {
#line 214
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 214
        if (! ((unsigned int )((void const   *)(pw_password + 1)) - (unsigned int )((void const   *)pw_password) == 1U)) {
#line 214
          tmp___9 = 1;
        } else {
#line 214
          if (__s2_len >= 4U) {
#line 214
            tmp___9 = 1;
          } else {
#line 214
            tmp___9 = 0;
          }
        }
      } else {
#line 214
        tmp___9 = 0;
      }
    }
#line 214
    if (tmp___9) {
#line 214
      tmp___5 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)pw_password);
    } else {
#line 214
      tmp___8 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)pw_password);
#line 214
      tmp___5 = tmp___8;
    }
  } else {
#line 214
    tmp___8 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)pw_password);
#line 214
    tmp___5 = tmp___8;
  }
#line 214
  return (tmp___5 == 0);
}
}
#line 1 "auth-rsa.o"
#pragma merger(0,"./auth-rsa.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 212
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 401 "/usr/include/openssl/bn.h"
extern int BN_rand(BIGNUM *rnd , int bits , int top , int bottom ) ;
#line 92 "auth.h"
int auth_rsa_challenge_dialog(RSA *pk ) ;
#line 60 "auth-rsa.c"
int auth_rsa_challenge_dialog(RSA *pk ) 
{ BIGNUM *challenge ;
  BIGNUM *encrypted_challenge ;
  BN_CTX *ctx ;
  u_char buf___2[32] ;
  u_char mdbuf[16] ;
  u_char response[16] ;
  MD5_CTX md ;
  u_int i ;
  int plen ;
  int len ;
  int _p ;
  int _e ;
  u_int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 70
  encrypted_challenge = BN_new();
#line 71
  challenge = BN_new();
#line 74
  BN_rand(challenge, 256, 0, 0);
#line 75
  ctx = BN_CTX_new();
#line 76
  BN_div((BIGNUM *)((void *)0), challenge, (BIGNUM const   *)challenge, (BIGNUM const   *)pk->n,
         ctx);
#line 77
  BN_CTX_free(ctx);
#line 80
  rsa_public_encrypt(encrypted_challenge, challenge, pk);
#line 83
  packet_start(7);
#line 84
  packet_put_bignum(encrypted_challenge);
#line 85
  packet_send();
#line 86
  BN_clear_free(encrypted_challenge);
#line 87
  packet_write_wait();
#line 90
  packet_read_expect(& plen, 8);
#line 91
  while (1) {
#line 91
    _p = plen;
#line 91
    _e = 16;
#line 91
    if (_p != _e) {
#line 91
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "auth-rsa.c", 91);
#line 91
      packet_disconnect("Packet integrity error. (%d)", 8);
    }
#line 91
    break;
  }
#line 92
  i = 0U;
#line 92
  while (i < 16U) {
#line 93
    tmp = packet_get_char();
#line 93
    response[i] = (unsigned char )tmp;
#line 92
    i ++;
  }
#line 96
  tmp___0 = BN_num_bits((BIGNUM const   *)challenge);
#line 96
  len = (tmp___0 + 7) / 8;
#line 97
  if (len <= 0) {
#line 98
    fatal("auth_rsa_challenge_dialog: bad challenge length %d", len);
  } else {
#line 97
    if (len > 32) {
#line 98
      fatal("auth_rsa_challenge_dialog: bad challenge length %d", len);
    }
  }
#line 99
  memset((void *)(buf___2), 0, 32U);
#line 100
  BN_bn2bin((BIGNUM const   *)challenge, (buf___2 + 32) - len);
#line 101
  MD5_Init(& md);
#line 102
  MD5_Update(& md, (void const   *)(buf___2), 32U);
#line 103
  MD5_Update(& md, (void const   *)(session_id), 16U);
#line 104
  MD5_Final(mdbuf, & md);
#line 105
  BN_clear_free(challenge);
#line 108
  tmp___1 = memcmp((void const   *)(response), (void const   *)(mdbuf), 16U);
#line 108
  if (tmp___1 != 0) {
#line 110
    return (0);
  }
#line 113
  return (1);
}
}
#line 172 "auth-rsa.c"
static char const   *check___1[3]  = {      "",      ".ssh",      (char const   *)((void *)0)};
#line 122 "auth-rsa.c"
int auth_rsa(struct passwd *pw , BIGNUM *client_n ) 
{ char line[8192] ;
  char file[4096] ;
  int authenticated ;
  u_int bits ;
  FILE *f ;
  u_long linenum ;
  struct stat st ;
  RSA *pk ;
  int tmp ;
  int fail ;
  char buf___2[1024] ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *cp ;
  char *options___0 ;
  int quoted ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;

  {
#line 129
  linenum = (u_long )0;
#line 134
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 135
    return (0);
  }
#line 138
  temporarily_use_uid(pw->pw_uid);
#line 141
  snprintf((char * __restrict  )(file), sizeof(file), (char const   * __restrict  )"%.500s/%.100s",
           pw->pw_dir, ".ssh/authorized_keys");
#line 145
  tmp = stat((char const   * __restrict  )(file), (struct stat * __restrict  )(& st));
#line 145
  if (tmp < 0) {
#line 147
    restore_uid();
#line 148
    return (0);
  }
#line 151
  f = fopen((char const   * __restrict  )(file), (char const   * __restrict  )"r");
#line 152
  if (! f) {
#line 154
    restore_uid();
#line 155
    packet_send_debug("Could not open %.900s for reading.", file);
#line 156
    packet_send_debug("If your home is on an NFS volume, it may need to be world-readable.");
#line 157
    return (0);
  }
#line 159
  if (options.strict_modes) {
#line 160
    fail = 0;
#line 163
    tmp___1 = fileno(f);
#line 163
    tmp___2 = fstat(tmp___1, & st);
#line 163
    if (tmp___2 < 0) {
#line 166
      snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
               pw->pw_name, file);
#line 168
      fail = 1;
    } else {
#line 163
      if (st.st_uid != 0U) {
#line 163
        if (st.st_uid != pw->pw_uid) {
#line 166
          snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   pw->pw_name, file);
#line 168
          fail = 1;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 163
        if ((st.st_mode & 18U) != 0U) {
#line 166
          snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   pw->pw_name, file);
#line 168
          fail = 1;
        } else {
#line 175
          i = 0;
#line 175
          while (check___1[i]) {
#line 176
            snprintf((char * __restrict  )(line), sizeof(line), (char const   * __restrict  )"%.500s/%.100s",
                     pw->pw_dir, check___1[i]);
#line 177
            tmp___0 = stat((char const   * __restrict  )(line), (struct stat * __restrict  )(& st));
#line 177
            if (tmp___0 < 0) {
#line 180
              snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                       pw->pw_name, line);
#line 182
              fail = 1;
#line 183
              break;
            } else {
#line 177
              if (st.st_uid != 0U) {
#line 177
                if (st.st_uid != pw->pw_uid) {
#line 180
                  snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           pw->pw_name, line);
#line 182
                  fail = 1;
#line 183
                  break;
                } else {
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
#line 177
                if ((st.st_mode & 18U) != 0U) {
#line 180
                  snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           pw->pw_name, line);
#line 182
                  fail = 1;
#line 183
                  break;
                }
              }
            }
#line 175
            i ++;
          }
        }
      }
    }
#line 187
    if (fail) {
#line 188
      fclose(f);
#line 189
      log("%s", buf___2);
#line 190
      packet_send_debug("%s", buf___2);
#line 191
      restore_uid();
#line 192
      return (0);
    }
  }
#line 196
  authenticated = 0;
#line 198
  pk = RSA_new();
#line 199
  pk->e = BN_new();
#line 200
  pk->n = BN_new();
#line 207
  while (1) {
#line 207
    tmp___9 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 207
    if (! tmp___9) {
#line 207
      break;
    }
#line 211
    linenum ++;
#line 214
    cp = line;
#line 214
    while (1) {
#line 214
      if (! ((int )*cp == 32)) {
#line 214
        if (! ((int )*cp == 9)) {
#line 214
          break;
        }
      }
#line 214
      cp ++;
    }
#line 216
    if (! *cp) {
#line 217
      continue;
    } else {
#line 216
      if ((int )*cp == 10) {
#line 217
        continue;
      } else {
#line 216
        if ((int )*cp == 35) {
#line 217
          continue;
        }
      }
    }
#line 225
    if ((int )*cp < 48) {
      goto _L___2;
    } else {
#line 225
      if ((int )*cp > 57) {
        _L___2: /* CIL Label */ 
#line 226
        quoted = 0;
#line 227
        options___0 = cp;
#line 228
        while (1) {
#line 228
          if (*cp) {
#line 228
            if (! quoted) {
#line 228
              if ((int )*cp != 32) {
#line 228
                if (! ((int )*cp != 9)) {
#line 228
                  break;
                }
              } else {
#line 228
                break;
              }
            }
          } else {
#line 228
            break;
          }
#line 229
          if ((int )*cp == 92) {
#line 229
            if ((int )*(cp + 1) == 34) {
#line 230
              cp ++;
            } else {
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
#line 231
            if ((int )*cp == 34) {
#line 232
              quoted = ! quoted;
            }
          }
#line 228
          cp ++;
        }
      } else {
#line 235
        options___0 = (char *)((void *)0);
      }
    }
#line 238
    tmp___3 = auth_rsa_read_key(& cp, & bits, pk->e, pk->n);
#line 238
    if (! tmp___3) {
#line 239
      debug("%.100s, line %lu: bad key syntax", file, linenum);
#line 241
      packet_send_debug("%.100s, line %lu: bad key syntax", file, linenum);
#line 243
      continue;
    }
#line 248
    tmp___4 = BN_cmp((BIGNUM const   *)pk->n, (BIGNUM const   *)client_n);
#line 248
    if (tmp___4 != 0) {
#line 249
      continue;
    }
#line 252
    tmp___6 = BN_num_bits((BIGNUM const   *)pk->n);
#line 252
    if (bits != (u_int )tmp___6) {
#line 253
      tmp___5 = BN_num_bits((BIGNUM const   *)pk->n);
#line 253
      log("Warning: %s, line %ld: keysize mismatch: actual %d vs. announced %d.",
          file, linenum, tmp___5, bits);
    }
#line 262
    tmp___7 = auth_parse_options(pw, options___0, file, linenum);
#line 262
    if (! tmp___7) {
#line 263
      continue;
    }
#line 266
    tmp___8 = auth_rsa_challenge_dialog(pk);
#line 266
    if (! tmp___8) {
#line 268
      verbose("Wrong response to RSA authentication challenge.");
#line 269
      packet_send_debug("Wrong response to RSA authentication challenge.");
#line 270
      continue;
    }
#line 280
    authenticated = 1;
#line 281
    break;
  }
#line 285
  restore_uid();
#line 288
  fclose(f);
#line 290
  RSA_free(pk);
#line 292
  if (authenticated) {
#line 293
    packet_send_debug("RSA authentication accepted.");
  } else {
#line 295
    auth_clear_options();
  }
#line 298
  return (authenticated);
}
}
#line 1 "auth-rh-rsa.o"
#pragma merger(0,"./auth-rh-rsa.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 35 "auth-rh-rsa.c"
int auth_rhosts_rsa(struct passwd *pw , char const   *client_user , RSA *client_host_key ) 
{ char const   *canonical_hostname ;
  HostStatus host_status ;
  Key *client_key ;
  Key *found ;
  int tmp ;
  struct stat st ;
  char *user_hostfile ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 43
  debug("Trying rhosts with RSA host authentication for client user %.100s", client_user);
#line 45
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 46
    return (0);
  } else {
#line 45
    if ((unsigned int )client_host_key == (unsigned int )((void *)0)) {
#line 46
      return (0);
    }
  }
#line 49
  tmp = auth_rhosts(pw, client_user);
#line 49
  if (! tmp) {
#line 50
    return (0);
  }
#line 52
  canonical_hostname = get_canonical_hostname(options.reverse_mapping_check);
#line 55
  debug("Rhosts RSA authentication: canonical host %.900s", canonical_hostname);
#line 58
  client_key = key_new(0);
#line 59
  BN_copy((client_key->rsa)->e, (BIGNUM const   *)client_host_key->e);
#line 60
  BN_copy((client_key->rsa)->n, (BIGNUM const   *)client_host_key->n);
#line 61
  found = key_new(0);
#line 64
  host_status = check_host_in_hostfile("/usr/local/etc/ssh_known_hosts", canonical_hostname,
                                       client_key, found, (int *)((void *)0));
#line 68
  if ((int )host_status != 0) {
#line 68
    if (! options.ignore_user_known_hosts) {
#line 70
      tmp___0 = tilde_expand_filename("~/.ssh/known_hosts", pw->pw_uid);
#line 70
      user_hostfile = tmp___0;
#line 75
      if (options.strict_modes) {
#line 75
        tmp___1 = stat((char const   * __restrict  )user_hostfile, (struct stat * __restrict  )(& st));
#line 75
        if (tmp___1 == 0) {
#line 75
          if (st.st_uid != 0U) {
#line 75
            if (st.st_uid != pw->pw_uid) {
#line 79
              log("Rhosts RSA authentication refused for %.100s: bad owner or modes for %.200s",
                  pw->pw_name, user_hostfile);
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 75
            if ((st.st_mode & 18U) != 0U) {
#line 79
              log("Rhosts RSA authentication refused for %.100s: bad owner or modes for %.200s",
                  pw->pw_name, user_hostfile);
            } else {
#line 83
              temporarily_use_uid(pw->pw_uid);
#line 84
              host_status = check_host_in_hostfile((char const   *)user_hostfile,
                                                   canonical_hostname, client_key,
                                                   found, (int *)((void *)0));
#line 86
              restore_uid();
            }
          }
        } else {
#line 83
          temporarily_use_uid(pw->pw_uid);
#line 84
          host_status = check_host_in_hostfile((char const   *)user_hostfile, canonical_hostname,
                                               client_key, found, (int *)((void *)0));
#line 86
          restore_uid();
        }
      } else {
#line 83
        temporarily_use_uid(pw->pw_uid);
#line 84
        host_status = check_host_in_hostfile((char const   *)user_hostfile, canonical_hostname,
                                             client_key, found, (int *)((void *)0));
#line 86
        restore_uid();
      }
#line 88
      xfree((void *)user_hostfile);
    }
  }
#line 90
  key_free(client_key);
#line 91
  key_free(found);
#line 93
  if ((int )host_status != 0) {
#line 94
    debug("Rhosts with RSA host authentication denied: unknown or invalid host key");
#line 95
    packet_send_debug("Your host key cannot be verified: unknown or invalid host key.");
#line 96
    return (0);
  }
#line 101
  tmp___2 = auth_rsa_challenge_dialog(client_host_key);
#line 101
  if (! tmp___2) {
#line 102
    log("Client on %.800s failed to respond correctly to host authentication.", canonical_hostname);
#line 104
    return (0);
  }
#line 111
  verbose("Rhosts with RSA host authentication accepted for %.100s, %.100s on %.700s.",
          pw->pw_name, client_user, canonical_hostname);
#line 113
  packet_send_debug("Rhosts with RSA host authentication accepted.");
#line 114
  return (1);
}
}
#line 1 "auth-sia.o"
#pragma merger(0,"./auth-sia.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "dh.o"
#pragma merger(0,"./dh.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 42 "dh.c"
int parse_prime(int linenum , char *line , struct dhgroup *dhg ) 
{ char *cp ;
  char *arg ;
  char *strsize ;
  char *gen___0 ;
  char *prime ;
  char *tmp___14 ;
  char *tmp___30 ;
  char *tmp___46 ;
  char *tmp___62 ;
  char *tmp___78 ;
  char *tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;

  {
#line 48
  cp = line;
#line 49
  arg = strdelim(& cp);
#line 51
  if ((int )*arg == 0) {
#line 52
    arg = strdelim(& cp);
  }
#line 53
  if (! *arg) {
#line 54
    return (0);
  } else {
#line 53
    if ((int )*arg == 35) {
#line 54
      return (0);
    }
  }
#line 57
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 57
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 59
  tmp___14 = __strsep_g(& cp, " ");
#line 59
  arg = tmp___14;
#line 60
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 60
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 62
  tmp___30 = __strsep_g(& cp, " ");
#line 62
  arg = tmp___30;
#line 63
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 63
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 65
  tmp___46 = __strsep_g(& cp, " ");
#line 65
  arg = tmp___46;
#line 66
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 66
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 68
  tmp___62 = __strsep_g(& cp, " ");
#line 68
  strsize = tmp___62;
#line 69
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 69
    if ((int )*strsize == 0) {
      goto fail;
    } else {
#line 69
      dhg->size = atoi((char const   *)strsize);
#line 69
      if (dhg->size == 0) {
        goto fail;
      }
    }
  }
#line 72
  tmp___78 = __strsep_g(& cp, " ");
#line 72
  gen___0 = tmp___78;
#line 73
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 73
    if ((int )*gen___0 == 0) {
      goto fail;
    }
  }
#line 75
  tmp___94 = __strsep_g(& cp, " ");
#line 75
  prime = tmp___94;
#line 76
  if ((unsigned int )cp != (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 76
    if ((int )*prime == 0) {
      goto fail;
    }
  }
#line 79
  dhg->g = BN_new();
#line 80
  tmp___95 = BN_hex2bn(& dhg->g, (char const   *)gen___0);
#line 80
  if (tmp___95 < 0) {
#line 81
    BN_free(dhg->g);
    goto fail;
  }
#line 84
  dhg->p = BN_new();
#line 85
  tmp___96 = BN_hex2bn(& dhg->p, (char const   *)prime);
#line 85
  if (tmp___96 < 0) {
#line 86
    BN_free(dhg->g);
#line 87
    BN_free(dhg->p);
    goto fail;
  }
#line 91
  return (1);
  fail: 
#line 93
  error("Bad prime description in line %d\n", linenum);
#line 94
  return (0);
}
}
#line 97 "dh.c"
DH *choose_dh(int minbits ) 
{ FILE *f ;
  char line[1024] ;
  int best ;
  int bestcount ;
  int which ;
  int linenum ;
  struct dhgroup dhg ;
  DH *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  DH *tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  DH *tmp___7 ;

  {
#line 106
  f = fopen((char const   * __restrict  )"/usr/local/etc/primes", (char const   * __restrict  )"r");
#line 107
  if (! f) {
#line 108
    log("WARNING: %s does not exist, using old prime", "/usr/local/etc/primes");
#line 109
    tmp = dh_new_group1();
#line 109
    return (tmp);
  }
#line 112
  linenum = 0;
#line 113
  bestcount = 0;
#line 113
  best = bestcount;
#line 114
  while (1) {
#line 114
    tmp___1 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 114
    if (! tmp___1) {
#line 114
      break;
    }
#line 115
    linenum ++;
#line 116
    tmp___0 = parse_prime(linenum, line, & dhg);
#line 116
    if (! tmp___0) {
#line 117
      continue;
    }
#line 118
    BN_free(dhg.g);
#line 119
    BN_free(dhg.p);
#line 121
    if (dhg.size > minbits) {
#line 121
      if (dhg.size < best) {
#line 123
        best = dhg.size;
#line 124
        bestcount = 0;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 121
      if (dhg.size > best) {
#line 121
        if (best < minbits) {
#line 123
          best = dhg.size;
#line 124
          bestcount = 0;
        }
      }
    }
#line 126
    if (dhg.size == best) {
#line 127
      bestcount ++;
    }
  }
#line 129
  fclose(f);
#line 131
  if (bestcount == 0) {
#line 132
    log("WARNING: no primes in %s, using old prime", "/usr/local/etc/primes");
#line 133
    tmp___2 = dh_new_group1();
#line 133
    return (tmp___2);
  }
#line 136
  f = fopen((char const   * __restrict  )"/usr/local/etc/primes", (char const   * __restrict  )"r");
#line 137
  if (! f) {
#line 138
    fatal("WARNING: %s dissappeared, giving up", "/usr/local/etc/primes");
  }
#line 141
  linenum = 0;
#line 142
  tmp___3 = arc4random();
#line 142
  which = (int )(tmp___3 % (unsigned int )bestcount);
#line 143
  while (1) {
#line 143
    tmp___6 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 143
    if (! tmp___6) {
#line 143
      break;
    }
#line 144
    tmp___4 = parse_prime(linenum, line, & dhg);
#line 144
    if (! tmp___4) {
#line 145
      continue;
    }
#line 146
    if (dhg.size != best) {
#line 147
      continue;
    }
#line 148
    tmp___5 = linenum;
#line 148
    linenum ++;
#line 148
    if (tmp___5 != which) {
#line 149
      BN_free(dhg.g);
#line 150
      BN_free(dhg.p);
#line 151
      continue;
    }
#line 153
    break;
  }
#line 155
  fclose(f);
#line 157
  tmp___7 = dh_new_group(dhg.g, dhg.p);
#line 157
  return (tmp___7);
}
}
#line 1 "sshpty.o"
#pragma merger(0,"./sshpty.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 280
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 433 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group )  __attribute__((__nonnull__(1))) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 736
extern  __attribute__((__nothrow__)) char *ttyname(int __fd ) ;
#line 872
extern  __attribute__((__nothrow__)) int vhangup(void) ;
#line 109 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 26 "sshpty.h"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) ;
#line 32
void pty_release(char const   *ttyname___0 ) ;
#line 38
void pty_make_controlling_tty(int *ttyfd , char const   *ttyname___0 ) ;
#line 41
void pty_change_window_size(int ptyfd , int row , int col , int xpixel , int ypixel ) ;
#line 45
void pty_setowner(struct passwd *pw , char const   *ttyname___0 ) ;
#line 34 "/usr/include/pty.h"
extern  __attribute__((__nothrow__)) int openpty(int *__amaster , int *__aslave ,
                                                 char *__name , struct termios *__termp ,
                                                 struct winsize *__winp ) ;
#line 47 "sshpty.c"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) 
{ char *name ;
  int i ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 55
  i = openpty(ptyfd, ttyfd, (char *)((void *)0), (struct termios *)((void *)0), (struct winsize *)((void *)0));
#line 56
  if (i < 0) {
#line 57
    tmp = __errno_location();
#line 57
    tmp___0 = strerror(*tmp);
#line 57
    error("openpty: %.100s", tmp___0);
#line 58
    return (0);
  }
#line 60
  name = ttyname(*ttyfd);
#line 61
  if (! name) {
#line 62
    fatal("openpty returns device for which ttyname fails.");
  }
#line 64
  strlcpy(namebuf, (char const   *)name, (unsigned int )namebuflen);
#line 65
  return (1);
}
}
#line 203 "sshpty.c"
void pty_release(char const   *ttyname___0 ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 206
  tmp___1 = chown(ttyname___0, 0U, 0U);
#line 206
  if (tmp___1 < 0) {
#line 207
    tmp = __errno_location();
#line 207
    tmp___0 = strerror(*tmp);
#line 207
    error("chown %.100s 0 0 failed: %.100s", ttyname___0, tmp___0);
  }
#line 208
  tmp___4 = chmod(ttyname___0, 438U);
#line 208
  if (tmp___4 < 0) {
#line 209
    tmp___2 = __errno_location();
#line 209
    tmp___3 = strerror(*tmp___2);
#line 209
    error("chmod %.100s 0666 failed: %.100s", ttyname___0, tmp___3);
  }
#line 210
  return;
}
}
#line 214 "sshpty.c"
void pty_make_controlling_tty(int *ttyfd , char const   *ttyname___0 ) 
{ int fd ;
  void *old ;
  int *tmp ;
  char *tmp___0 ;
  __pid_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  __sighandler_t tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;

  {
#line 224
  fd = open("/dev/tty", 258);
#line 225
  if (fd >= 0) {
#line 226
    ioctl(fd, 21538UL, (void *)0);
#line 227
    close(fd);
  }
#line 230
  tmp___1 = setsid();
#line 230
  if (tmp___1 < 0) {
#line 231
    tmp = __errno_location();
#line 231
    tmp___0 = strerror(*tmp);
#line 231
    error("setsid: %.100s", tmp___0);
  }
#line 237
  fd = open("/dev/tty", 258);
#line 238
  if (fd >= 0) {
#line 239
    error("Failed to disconnect from controlling tty.");
#line 240
    close(fd);
  }
#line 244
  debug("Setting controlling tty using TIOCSCTTY.");
#line 245
  tmp___4 = ioctl(*ttyfd, 21518UL, (void *)0);
#line 245
  if (tmp___4 < 0) {
#line 246
    tmp___2 = __errno_location();
#line 246
    tmp___3 = strerror(*tmp___2);
#line 246
    error("ioctl(TIOCSCTTY): %.100s", tmp___3);
  }
#line 253
  tmp___5 = signal(1, (void (*)(int  ))1);
#line 253
  old = (void *)tmp___5;
#line 254
  vhangup();
#line 255
  signal(1, (void (*)(int  ))old);
#line 257
  fd = open(ttyname___0, 2);
#line 258
  if (fd < 0) {
#line 259
    tmp___6 = __errno_location();
#line 259
    tmp___7 = strerror(*tmp___6);
#line 259
    error("%.100s: %.100s", ttyname___0, tmp___7);
  } else {
#line 262
    close(*ttyfd);
#line 263
    *ttyfd = fd;
  }
#line 269
  fd = open("/dev/tty", 1);
#line 270
  if (fd < 0) {
#line 271
    tmp___8 = __errno_location();
#line 271
    tmp___9 = strerror(*tmp___8);
#line 271
    error("open /dev/tty failed - could not set controlling tty: %.100s", tmp___9);
  } else {
#line 274
    close(fd);
  }
#line 276
  return;
}
}
#line 280 "sshpty.c"
void pty_change_window_size(int ptyfd , int row , int col , int xpixel , int ypixel ) 
{ struct winsize w ;

  {
#line 285
  w.ws_row = (unsigned short )row;
#line 286
  w.ws_col = (unsigned short )col;
#line 287
  w.ws_xpixel = (unsigned short )xpixel;
#line 288
  w.ws_ypixel = (unsigned short )ypixel;
#line 289
  ioctl(ptyfd, 21524UL, & w);
#line 290
  return;
}
}
#line 292 "sshpty.c"
void pty_setowner(struct passwd *pw , char const   *ttyname___0 ) 
{ struct group *grp ;
  gid_t gid ;
  mode_t mode ;
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;

  {
#line 301
  grp = getgrnam("tty");
#line 302
  if (grp) {
#line 303
    gid = grp->gr_gid;
#line 304
    mode = (unsigned int )(384 | (128 >> 3));
  } else {
#line 306
    gid = pw->pw_gid;
#line 307
    mode = (unsigned int )((384 | (128 >> 3)) | ((128 >> 3) >> 3));
  }
#line 314
  tmp___1 = stat((char const   * __restrict  )ttyname___0, (struct stat * __restrict  )(& st));
#line 314
  if (tmp___1) {
#line 315
    tmp = __errno_location();
#line 315
    tmp___0 = strerror(*tmp);
#line 315
    fatal("stat(%.100s) failed: %.100s", ttyname___0, tmp___0);
  }
#line 318
  if (st.st_uid != pw->pw_uid) {
    goto _L;
  } else {
#line 318
    if (st.st_gid != gid) {
      _L: /* CIL Label */ 
#line 319
      tmp___7 = chown(ttyname___0, pw->pw_uid, gid);
#line 319
      if (tmp___7 < 0) {
#line 320
        tmp___6 = __errno_location();
#line 320
        if (*tmp___6 == 30) {
#line 320
          if (st.st_uid == pw->pw_uid) {
#line 321
            tmp___2 = __errno_location();
#line 321
            tmp___3 = strerror(*tmp___2);
#line 321
            error("chown(%.100s, %d, %d) failed: %.100s", ttyname___0, pw->pw_uid,
                  gid, tmp___3);
          } else {
#line 325
            tmp___4 = __errno_location();
#line 325
            tmp___5 = strerror(*tmp___4);
#line 325
            fatal("chown(%.100s, %d, %d) failed: %.100s", ttyname___0, pw->pw_uid,
                  gid, tmp___5);
          }
        } else {
#line 325
          tmp___4 = __errno_location();
#line 325
          tmp___5 = strerror(*tmp___4);
#line 325
          fatal("chown(%.100s, %d, %d) failed: %.100s", ttyname___0, pw->pw_uid, gid,
                tmp___5);
        }
      }
    }
  }
#line 331
  if ((st.st_mode & (unsigned int )((448 | (448 >> 3)) | ((448 >> 3) >> 3))) != mode) {
#line 332
    tmp___13 = chmod(ttyname___0, mode);
#line 332
    if (tmp___13 < 0) {
#line 333
      tmp___12 = __errno_location();
#line 333
      if (*tmp___12 == 30) {
#line 333
        if ((st.st_mode & (unsigned int )((256 >> 3) | ((256 >> 3) >> 3))) == 0U) {
#line 335
          tmp___8 = __errno_location();
#line 335
          tmp___9 = strerror(*tmp___8);
#line 335
          error("chmod(%.100s, 0%o) failed: %.100s", ttyname___0, mode, tmp___9);
        } else {
#line 338
          tmp___10 = __errno_location();
#line 338
          tmp___11 = strerror(*tmp___10);
#line 338
          fatal("chmod(%.100s, 0%o) failed: %.100s", ttyname___0, mode, tmp___11);
        }
      } else {
#line 338
        tmp___10 = __errno_location();
#line 338
        tmp___11 = strerror(*tmp___10);
#line 338
        fatal("chmod(%.100s, 0%o) failed: %.100s", ttyname___0, mode, tmp___11);
      }
    }
  }
#line 342
  return;
}
}
#line 1 "log-server.o"
#pragma merger(0,"./log-server.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 175 "/usr/include/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 46 "log-server.c"
static LogLevel log_level  =    3;
#line 47 "log-server.c"
static int log_on_stderr  =    0;
#line 48 "log-server.c"
static int log_facility  =    4 << 3;
#line 56 "log-server.c"
void log_init(char *av0 , LogLevel level , SyslogFacility facility , int on_stderr ) 
{ 

  {
#line 59
  switch ((int )level) {
  case 0: 
  case 1: 
  case 2: 
  case 3: 
  case 4: 
  case 5: 
  case 6: 
  case 7: 
#line 68
  log_level = level;
#line 69
  break;
  default: 
#line 71
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized internal syslog level code %d\n",
          (int )level);
#line 73
  exit(1);
  }
#line 75
  switch ((int )facility) {
  case 0: 
#line 77
  log_facility = 3 << 3;
#line 78
  break;
  case 1: 
#line 80
  log_facility = 1 << 3;
#line 81
  break;
  case 2: 
#line 83
  log_facility = 4 << 3;
#line 84
  break;
  case 3: 
#line 87
  log_facility = 10 << 3;
#line 88
  break;
  case 4: 
#line 91
  log_facility = 16 << 3;
#line 92
  break;
  case 5: 
#line 94
  log_facility = 17 << 3;
#line 95
  break;
  case 6: 
#line 97
  log_facility = 18 << 3;
#line 98
  break;
  case 7: 
#line 100
  log_facility = 19 << 3;
#line 101
  break;
  case 8: 
#line 103
  log_facility = 20 << 3;
#line 104
  break;
  case 9: 
#line 106
  log_facility = 21 << 3;
#line 107
  break;
  case 10: 
#line 109
  log_facility = 22 << 3;
#line 110
  break;
  case 11: 
#line 112
  log_facility = 23 << 3;
#line 113
  break;
  default: 
#line 115
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized internal syslog facility code %d\n",
          (int )facility);
#line 117
  exit(1);
  }
#line 119
  log_on_stderr = on_stderr;
#line 120
  return;
}
}
#line 124 "log-server.c"
void do_log(LogLevel level , char const   *fmt , va_list args ) 
{ char msgbuf[1024] ;
  char fmtbuf[1024] ;
  char *txt ;
  int pri ;

  {
#line 129
  txt = (char *)((void *)0);
#line 130
  pri = 6;
#line 133
  if ((int )level > (int )log_level) {
#line 134
    return;
  }
#line 135
  switch ((int )level) {
  case 1: 
#line 137
  txt = (char *)"fatal";
#line 138
  pri = 2;
#line 139
  break;
  case 2: 
#line 141
  txt = (char *)"error";
#line 142
  pri = 3;
#line 143
  break;
  case 3: 
#line 145
  pri = 6;
#line 146
  break;
  case 4: 
#line 148
  pri = 6;
#line 149
  break;
  case 5: 
#line 151
  txt = (char *)"debug1";
#line 152
  pri = 7;
#line 153
  break;
  case 6: 
#line 155
  txt = (char *)"debug2";
#line 156
  pri = 7;
#line 157
  break;
  case 7: 
#line 159
  txt = (char *)"debug3";
#line 160
  pri = 7;
#line 161
  break;
  default: 
#line 163
  txt = (char *)"internal error";
#line 164
  pri = 3;
#line 165
  break;
  }
#line 167
  if ((unsigned int )txt != (unsigned int )((void *)0)) {
#line 168
    snprintf((char * __restrict  )(fmtbuf), sizeof(fmtbuf), (char const   * __restrict  )"%s: %s",
             txt, fmt);
#line 169
    vsnprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )(fmtbuf),
              args);
  } else {
#line 171
    vsnprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )fmt,
              args);
  }
#line 173
  if (log_on_stderr) {
#line 174
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n", msgbuf);
  } else {
#line 176
    openlog((char const   *)__progname, 1, log_facility);
#line 177
    syslog(pri, "%.500s", msgbuf);
#line 178
    closelog();
  }
#line 180
  return;
}
}
#line 1 "sshlogin.o"
#pragma merger(0,"./sshlogin.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 100 "loginrec.h"
struct logininfo *login_alloc_entry(int pid , char const   *username , char const   *hostname ,
                                    char const   *line ) ;
#line 103
void login_free_entry(struct logininfo *li ) ;
#line 111
int login_login(struct logininfo *li ) ;
#line 112
int login_logout(struct logininfo *li ) ;
#line 121
void login_set_addr(struct logininfo *li , struct sockaddr  const  *sa , unsigned int sa_size ) ;
#line 128
struct logininfo *login_get_lastlog(struct logininfo *li , int uid ) ;
#line 52 "sshlogin.c"
u_long get_last_login_time(uid_t uid , char const   *logname , char *buf___2 , u_int bufsize ) 
{ struct logininfo li ;

  {
#line 58
  login_get_lastlog(& li, (int )uid);
#line 59
  strlcpy(buf___2, (char const   *)(li.hostname), bufsize);
#line 60
  return ((unsigned long )li.tv_sec);
}
}
#line 68 "sshlogin.c"
void record_login(pid_t pid , char const   *ttyname___0 , char const   *user , uid_t uid ,
                  char const   *host , struct sockaddr *addr ) 
{ struct logininfo *li ;

  {
#line 74
  li = login_alloc_entry(pid, user, host, ttyname___0);
#line 75
  login_set_addr(li, (struct sockaddr  const  *)addr, sizeof(struct sockaddr ));
#line 76
  login_login(li);
#line 77
  login_free_entry(li);
#line 78
  return;
}
}
#line 82 "sshlogin.c"
void record_logout(pid_t pid , char const   *ttyname___0 ) 
{ struct logininfo *li ;

  {
#line 87
  li = login_alloc_entry(pid, (char const   *)((void *)0), (char const   *)((void *)0),
                         ttyname___0);
#line 88
  login_logout(li);
#line 89
  login_free_entry(li);
#line 90
  return;
}
}
#line 1 "loginrec.o"
#pragma merger(0,"./loginrec.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval * __restrict  __tv ,
                                                      __timezone_ptr_t __tz )  __attribute__((__nonnull__(1))) ;
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 46 "/usr/include/utmp.h"
extern  __attribute__((__nothrow__)) void login(struct utmp  const  *__entry ) ;
#line 49
extern  __attribute__((__nothrow__)) int logout(char const   *__ut_line ) ;
#line 52
extern  __attribute__((__nothrow__)) void logwtmp(char const   *__ut_line , char const   *__ut_name ,
                                                  char const   *__ut_host ) ;
#line 105 "loginrec.h"
int login_init_entry(struct logininfo *li , int pid , char const   *username , char const   *hostname ,
                     char const   *line ) ;
#line 108
void login_set_current_time(struct logininfo *li ) ;
#line 117
int login_write(struct logininfo *li ) ;
#line 130
unsigned int login_get_lastlog_time(int uid ) ;
#line 133
char *line_fullname(char *dst , char const   *src , int dstsize ) ;
#line 134
char *line_stripname(char *dst , char const   *src , int dstsize ) ;
#line 135
char *line_abbrevname(char *dst , char const   *src , int dstsize ) ;
#line 181 "loginrec.c"
void set_utmp_time(struct logininfo *li , struct utmp *ut ) ;
#line 182
void construct_utmp(struct logininfo *li , struct utmp *ut ) ;
#line 194
int lastlog_write_entry(struct logininfo *li ) ;
#line 195
int syslogin_write_entry(struct logininfo *li ) ;
#line 197
int getlast_entry(struct logininfo *li ) ;
#line 198
int lastlog_get_entry(struct logininfo *li ) ;
#line 218 "loginrec.c"
int login_login(struct logininfo *li ) 
{ int tmp ;

  {
#line 221
  li->type = (short)7;
#line 222
  tmp = login_write(li);
#line 222
  return (tmp);
}
}
#line 234 "loginrec.c"
int login_logout(struct logininfo *li ) 
{ int tmp ;

  {
#line 237
  li->type = (short)8;
#line 238
  tmp = login_write(li);
#line 238
  return (tmp);
}
}
#line 258 "loginrec.c"
unsigned int login_get_lastlog_time(int uid ) 
{ struct logininfo li ;
  struct logininfo *tmp ;

  {
#line 263
  tmp = login_get_lastlog(& li, uid);
#line 263
  if (tmp) {
#line 264
    return (li.tv_sec);
  } else {
#line 266
    return (0U);
  }
}
}
#line 282 "loginrec.c"
struct logininfo *login_get_lastlog(struct logininfo *li , int uid ) 
{ struct passwd *pw ;
  int tmp ;

  {
#line 287
  memset((void *)li, '\000', sizeof(*li));
#line 288
  li->uid = uid;
#line 295
  pw = getpwuid((unsigned int )uid);
#line 296
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 297
    fatal("login_get_lastlog: Cannot find account for uid %i", uid);
  }
#line 301
  strlcpy(li->username, (char const   *)pw->pw_name, sizeof(li->username));
#line 303
  tmp = getlast_entry(li);
#line 303
  if (tmp) {
#line 304
    return (li);
  } else {
#line 306
    return ((struct logininfo *)((void *)0));
  }
}
}
#line 319 "loginrec.c"
struct logininfo *login_alloc_entry(int pid , char const   *username , char const   *hostname ,
                                    char const   *line ) 
{ struct logininfo *newli ;
  void *tmp ;

  {
#line 325
  tmp = xmalloc(sizeof(*newli));
#line 325
  newli = (struct logininfo *)tmp;
#line 326
  login_init_entry(newli, pid, username, hostname, line);
#line 327
  return (newli);
}
}
#line 332 "loginrec.c"
void login_free_entry(struct logininfo *li ) 
{ 

  {
#line 335
  xfree((void *)li);
#line 336
  return;
}
}
#line 347 "loginrec.c"
int login_init_entry(struct logininfo *li , int pid , char const   *username , char const   *hostname ,
                     char const   *line ) 
{ struct passwd *pw ;

  {
#line 353
  memset((void *)li, 0, sizeof(*li));
#line 355
  li->pid = pid;
#line 358
  if (line) {
#line 359
    line_fullname(li->line, line, (int )sizeof(li->line));
  }
#line 361
  if (username) {
#line 362
    strlcpy(li->username, username, sizeof(li->username));
#line 363
    pw = getpwnam((char const   *)(li->username));
#line 364
    if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 365
      fatal("login_init_entry: Cannot find user \"%s\"", li->username);
    }
#line 366
    li->uid = (int )pw->pw_uid;
  }
#line 369
  if (hostname) {
#line 370
    strlcpy(li->hostname, hostname, sizeof(li->hostname));
  }
#line 372
  return (1);
}
}
#line 381 "loginrec.c"
void login_set_current_time(struct logininfo *li ) 
{ struct timeval tv ;

  {
#line 386
  gettimeofday((struct timeval * __restrict  )(& tv), (struct timezone * __restrict  )((void *)0));
#line 388
  li->tv_sec = (unsigned int )tv.tv_sec;
#line 389
  li->tv_usec = (unsigned int )tv.tv_usec;
#line 390
  return;
}
}
#line 393 "loginrec.c"
void login_set_addr(struct logininfo *li , struct sockaddr  const  *sa , unsigned int sa_size ) 
{ unsigned int bufsize ;

  {
#line 397
  bufsize = sa_size;
#line 400
  if (sizeof(li->hostaddr) < sa_size) {
#line 401
    bufsize = sizeof(li->hostaddr);
  }
#line 403
  memcpy((void * __restrict  )((void *)(& li->hostaddr.sa)), (void const   * __restrict  )((void const   *)sa),
         bufsize);
#line 404
  return;
}
}
#line 411 "loginrec.c"
int login_write(struct logininfo *li ) 
{ __uid_t tmp ;

  {
#line 415
  tmp = geteuid();
#line 415
  if ((int )tmp != 0) {
#line 416
    log("Attempt to write login records by non-root user (aborting)");
#line 417
    return (1);
  }
#line 422
  login_set_current_time(li);
#line 424
  syslogin_write_entry(li);
#line 427
  if ((int )li->type == 7) {
#line 428
    lastlog_write_entry(li);
  }
#line 443
  return (0);
}
}
#line 452 "loginrec.c"
int getlast_entry(struct logininfo *li ) 
{ int tmp ;

  {
#line 456
  tmp = lastlog_get_entry(li);
#line 456
  return (tmp);
}
}
#line 503 "loginrec.c"
char *line_fullname(char *dst , char const   *src , int dstsize ) 
{ int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  size_t tmp___25 ;

  {
#line 506
  memset((void *)dst, '\000', (unsigned int )dstsize);
#line 507
  if (0) {
#line 507
    if (0) {
#line 507
      __s1_len___0 = strlen(src);
#line 507
      __s2_len___0 = strlen("/dev/");
#line 507
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 507
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 507
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 507
            tmp___22 = 1;
          } else {
#line 507
            if (__s2_len___0 >= 4U) {
#line 507
              tmp___22 = 1;
            } else {
#line 507
              tmp___22 = 0;
            }
          }
        } else {
#line 507
          tmp___22 = 0;
        }
      }
#line 507
      if (tmp___22) {
#line 507
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 507
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 507
        tmp___18 = tmp___21;
      }
    } else {
#line 507
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 507
      tmp___18 = tmp___21;
    }
#line 507
    tmp___12 = tmp___18;
  } else {
#line 507
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 507
  if (tmp___12 == 0) {
#line 508
    strlcpy(dst, src, (unsigned int )dstsize);
  } else {
#line 507
    tmp___25 = strlen(src);
#line 507
    if ((size_t )dstsize < tmp___25 + 5U) {
#line 508
      strlcpy(dst, src, (unsigned int )dstsize);
    } else {
#line 510
      strlcpy(dst, "/dev/", (unsigned int )dstsize);
#line 511
      strlcat(dst, src, (unsigned int )dstsize);
    }
  }
#line 513
  return (dst);
}
}
#line 517 "loginrec.c"
char *line_stripname(char *dst , char const   *src , int dstsize ) 
{ int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 520
  memset((void *)dst, '\000', (unsigned int )dstsize);
#line 521
  if (0) {
#line 521
    if (0) {
#line 521
      __s1_len___0 = strlen(src);
#line 521
      __s2_len___0 = strlen("/dev/");
#line 521
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 521
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 521
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 521
            tmp___22 = 1;
          } else {
#line 521
            if (__s2_len___0 >= 4U) {
#line 521
              tmp___22 = 1;
            } else {
#line 521
              tmp___22 = 0;
            }
          }
        } else {
#line 521
          tmp___22 = 0;
        }
      }
#line 521
      if (tmp___22) {
#line 521
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 521
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 521
        tmp___18 = tmp___21;
      }
    } else {
#line 521
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 521
      tmp___18 = tmp___21;
    }
#line 521
    tmp___12 = tmp___18;
  } else {
#line 521
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 521
  if (tmp___12 == 0) {
#line 522
    strlcpy(dst, src + 5, (unsigned int )dstsize);
  } else {
#line 524
    strlcpy(dst, src, (unsigned int )dstsize);
  }
#line 525
  return (dst);
}
}
#line 534 "loginrec.c"
char *line_abbrevname(char *dst , char const   *src , int dstsize ) 
{ size_t len ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 539
  memset((void *)dst, '\000', (unsigned int )dstsize);
#line 542
  if (0) {
#line 542
    if (0) {
#line 542
      __s1_len___0 = strlen(src);
#line 542
      __s2_len___0 = strlen("/dev/");
#line 542
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 542
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 542
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 542
            tmp___22 = 1;
          } else {
#line 542
            if (__s2_len___0 >= 4U) {
#line 542
              tmp___22 = 1;
            } else {
#line 542
              tmp___22 = 0;
            }
          }
        } else {
#line 542
          tmp___22 = 0;
        }
      }
#line 542
      if (tmp___22) {
#line 542
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 542
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 542
        tmp___18 = tmp___21;
      }
    } else {
#line 542
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 542
      tmp___18 = tmp___21;
    }
#line 542
    tmp___12 = tmp___18;
  } else {
#line 542
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 542
  if (tmp___12 == 0) {
#line 543
    src += 5;
  }
#line 545
  len = strlen(src);
#line 547
  if (len > 0U) {
#line 548
    if ((int )len - dstsize > 0) {
#line 549
      src += (int )len - dstsize;
    }
#line 552
    __builtin_strncpy(dst, src, (unsigned int )dstsize);
  }
#line 555
  return (dst);
}
}
#line 568 "loginrec.c"
void set_utmp_time(struct logininfo *li , struct utmp *ut ) 
{ 

  {
#line 572
  ut->ut_tv.tv_sec = (long )li->tv_sec;
#line 573
  ut->ut_tv.tv_usec = (long )li->tv_usec;
#line 579
  return;
}
}
#line 581 "loginrec.c"
void construct_utmp(struct logininfo *li , struct utmp *ut ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 585
  memset((void *)ut, '\000', sizeof(*ut));
#line 590
  line_abbrevname(ut->ut_id, (char const   *)(li->line), (int )sizeof(ut->ut_id));
#line 595
  switch ((int )li->type) {
  case 7: 
#line 597
  ut->ut_type = (short)7;
#line 598
  break;
  case 8: 
#line 600
  ut->ut_type = (short)8;
#line 601
  break;
  }
#line 604
  set_utmp_time(li, ut);
#line 606
  line_stripname(ut->ut_line, (char const   *)(li->line), (int )sizeof(ut->ut_line));
#line 609
  ut->ut_pid = li->pid;
#line 613
  if ((int )li->type == 8) {
#line 614
    return;
  }
#line 622
  if (sizeof(ut->ut_user) < sizeof(li->username)) {
#line 622
    tmp = sizeof(ut->ut_user);
  } else {
#line 622
    tmp = sizeof(li->username);
  }
#line 622
  __builtin_strncpy(ut->ut_user, (char const   *)(li->username), tmp);
#line 624
  if (sizeof(ut->ut_host) < sizeof(li->hostname)) {
#line 624
    tmp___0 = sizeof(ut->ut_host);
  } else {
#line 624
    tmp___0 = sizeof(li->hostname);
  }
#line 624
  __builtin_strncpy(ut->ut_host, (char const   *)(li->hostname), tmp___0);
#line 628
  if ((int )li->hostaddr.sa.sa_family == 2) {
#line 629
    ut->ut_addr_v6[0] = (int )li->hostaddr.sa_in.sin_addr.s_addr;
  }
#line 631
  return;
}
}
#line 1273 "loginrec.c"
static int syslogin_perform_login(struct logininfo *li ) 
{ struct utmp *ut ;
  void *tmp ;

  {
#line 1278
  tmp = malloc(sizeof(*ut));
#line 1278
  ut = (struct utmp *)tmp;
#line 1278
  if (! ut) {
#line 1279
    log("syslogin_perform_login: couldn\'t malloc()");
#line 1280
    return (0);
  }
#line 1282
  construct_utmp(li, ut);
#line 1283
  login((struct utmp  const  *)ut);
#line 1285
  return (1);
}
}
#line 1288 "loginrec.c"
static int syslogin_perform_logout(struct logininfo *li ) 
{ char line[8] ;
  int tmp ;

  {
#line 1294
  line_stripname(line, (char const   *)(li->line), (int )sizeof(line));
#line 1296
  tmp = logout((char const   *)(line));
#line 1296
  if (tmp) {
#line 1300
    logwtmp((char const   *)(line), "", "");
  } else {
#line 1297
    log("syslogin_perform_logout: logout() returned an error");
  }
#line 1308
  return (1);
}
}
#line 1311 "loginrec.c"
int syslogin_write_entry(struct logininfo *li ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 1314
  switch ((int )li->type) {
  case 7: 
#line 1316
  tmp = syslogin_perform_login(li);
#line 1316
  return (tmp);
  case 8: 
#line 1318
  tmp___0 = syslogin_perform_logout(li);
#line 1318
  return (tmp___0);
  default: 
#line 1320
  log("syslogin_write_entry: Invalid type field");
#line 1321
  return (0);
  }
}
}
#line 1337 "loginrec.c"
static void lastlog_construct(struct logininfo *li , struct lastlog *last ) 
{ unsigned int tmp ;

  {
#line 1341
  memset((void *)last, '\000', sizeof(*last));
#line 1343
  line_stripname(last->ll_line, (char const   *)(li->line), (int )sizeof(last->ll_line));
#line 1344
  if (sizeof(last->ll_host) < sizeof(li->hostname)) {
#line 1344
    tmp = sizeof(last->ll_host);
  } else {
#line 1344
    tmp = sizeof(li->hostname);
  }
#line 1344
  strlcpy(last->ll_host, (char const   *)(li->hostname), tmp);
#line 1346
  last->ll_time = (long )li->tv_sec;
#line 1347
  return;
}
}
#line 1349 "loginrec.c"
static int lastlog_filetype(char *filename ) 
{ struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1354
  tmp___1 = stat((char const   * __restrict  )"/var/log/lastlog", (struct stat * __restrict  )(& st));
#line 1354
  if (tmp___1 != 0) {
#line 1355
    tmp = __errno_location();
#line 1355
    tmp___0 = strerror(*tmp);
#line 1355
    log("lastlog_perform_login: Couldn\'t stat %s: %s", "/var/log/lastlog", tmp___0);
#line 1357
    return (0);
  }
#line 1359
  if ((st.st_mode & 61440U) == 16384U) {
#line 1360
    return (2);
  } else {
#line 1361
    if ((st.st_mode & 61440U) == 32768U) {
#line 1362
      return (1);
    } else {
#line 1364
      return (3);
    }
  }
}
}
#line 1369 "loginrec.c"
static int lastlog_openseek(struct logininfo *li , int *fd , int filemode ) 
{ off_t offset ;
  int type ;
  char lastlog_file[1024] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  __off_t tmp___3 ;

  {
#line 1376
  type = lastlog_filetype((char *)"/var/log/lastlog");
#line 1377
  switch (type) {
  case 1: 
#line 1379
  strlcpy(lastlog_file, "/var/log/lastlog", sizeof(lastlog_file));
#line 1380
  break;
  case 2: 
#line 1382
  snprintf((char * __restrict  )(lastlog_file), sizeof(lastlog_file), (char const   * __restrict  )"%s/%s",
           "/var/log/lastlog", li->username);
#line 1384
  break;
  default: 
#line 1386
  log("lastlog_openseek: %.100s is not a file or directory!", "/var/log/lastlog");
#line 1388
  return (0);
  }
#line 1391
  *fd = open((char const   *)(lastlog_file), filemode);
#line 1392
  if (*fd < 0) {
#line 1393
    tmp = __errno_location();
#line 1393
    tmp___0 = strerror(*tmp);
#line 1393
    debug("lastlog_openseek: Couldn\'t open %s: %s", lastlog_file, tmp___0);
#line 1395
    return (0);
  }
#line 1398
  if (type == 1) {
#line 1400
    offset = (long )((unsigned long )((long )li->uid) * (unsigned long )sizeof(struct lastlog ));
#line 1402
    tmp___3 = lseek(*fd, offset, 0);
#line 1402
    if (tmp___3 != offset) {
#line 1403
      tmp___1 = __errno_location();
#line 1403
      tmp___2 = strerror(*tmp___1);
#line 1403
      log("lastlog_openseek: %s->lseek(): %s", lastlog_file, tmp___2);
#line 1405
      return (0);
    }
  }
#line 1409
  return (1);
}
}
#line 1412 "loginrec.c"
static int lastlog_perform_login(struct logininfo *li ) 
{ struct lastlog last ;
  int fd ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 1419
  lastlog_construct(li, & last);
#line 1421
  tmp = lastlog_openseek(li, & fd, 66);
#line 1421
  if (! tmp) {
#line 1422
    return (0);
  }
#line 1425
  tmp___2 = atomicio((ssize_t (*)())(& write), fd, (void *)(& last), sizeof(last));
#line 1425
  if ((unsigned int )tmp___2 != sizeof(last)) {
#line 1426
    close(fd);
#line 1427
    tmp___0 = __errno_location();
#line 1427
    tmp___1 = strerror(*tmp___0);
#line 1427
    log("lastlog_write_filemode: Error writing to %s: %s", "/var/log/lastlog", tmp___1);
#line 1429
    return (0);
  }
#line 1432
  close(fd);
#line 1433
  return (1);
}
}
#line 1436 "loginrec.c"
int lastlog_write_entry(struct logininfo *li ) 
{ int tmp ;

  {
#line 1439
  switch ((int )li->type) {
  case 7: 
#line 1441
  tmp = lastlog_perform_login(li);
#line 1441
  return (tmp);
  default: 
#line 1443
  log("lastlog_write_entry: Invalid type field");
#line 1444
  return (0);
  }
}
}
#line 1448 "loginrec.c"
static void lastlog_populate_entry(struct logininfo *li , struct lastlog *last ) 
{ unsigned int tmp ;

  {
#line 1451
  line_fullname(li->line, (char const   *)(last->ll_line), (int )sizeof(li->line));
#line 1452
  if (sizeof(li->hostname) < sizeof(last->ll_host)) {
#line 1452
    tmp = sizeof(li->hostname);
  } else {
#line 1452
    tmp = sizeof(last->ll_host);
  }
#line 1452
  strlcpy(li->hostname, (char const   *)(last->ll_host), tmp);
#line 1454
  li->tv_sec = (unsigned int )last->ll_time;
#line 1455
  return;
}
}
#line 1457 "loginrec.c"
int lastlog_get_entry(struct logininfo *li ) 
{ struct lastlog last ;
  int fd ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;

  {
#line 1463
  tmp___2 = lastlog_openseek(li, & fd, 0);
#line 1463
  if (tmp___2) {
#line 1464
    tmp___1 = atomicio((ssize_t (*)())(& read), fd, (void *)(& last), sizeof(last));
#line 1464
    if ((unsigned int )tmp___1 != sizeof(last)) {
#line 1465
      tmp = __errno_location();
#line 1465
      tmp___0 = strerror(*tmp);
#line 1465
      log("lastlog_get_entry: Error reading from %s: %s", "/var/log/lastlog", tmp___0);
#line 1467
      return (0);
    } else {
#line 1469
      lastlog_populate_entry(li, & last);
#line 1470
      return (1);
    }
  } else {
#line 1473
    return (0);
  }
}
}
#line 1 "servconf.o"
#pragma merger(0,"./servconf.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 35 "servconf.c"
void add_listen_addr(ServerOptions *options___0 , char *addr ) ;
#line 42 "servconf.c"
void initialize_server_options(ServerOptions *options___0 ) 
{ 

  {
#line 45
  memset((void *)options___0, 0, sizeof(*options___0));
#line 46
  options___0->num_ports = 0U;
#line 47
  options___0->ports_from_cmdline = 0U;
#line 48
  options___0->listen_addrs = (struct addrinfo *)((void *)0);
#line 49
  options___0->num_host_key_files = 0;
#line 50
  options___0->pid_file = (char *)((void *)0);
#line 51
  options___0->server_key_bits = -1;
#line 52
  options___0->login_grace_time = -1;
#line 53
  options___0->key_regeneration_time = -1;
#line 54
  options___0->permit_root_login = -1;
#line 55
  options___0->ignore_rhosts = -1;
#line 56
  options___0->ignore_user_known_hosts = -1;
#line 57
  options___0->print_motd = -1;
#line 58
  options___0->check_mail = -1;
#line 59
  options___0->x11_forwarding = -1;
#line 60
  options___0->x11_display_offset = -1;
#line 61
  options___0->xauth_location = (char *)((void *)0);
#line 62
  options___0->strict_modes = -1;
#line 63
  options___0->keepalives = -1;
#line 64
  options___0->log_facility = (int )-1;
#line 65
  options___0->log_level = (enum __anonenum_LogLevel_63 )-1;
#line 66
  options___0->rhosts_authentication = -1;
#line 67
  options___0->rhosts_rsa_authentication = -1;
#line 68
  options___0->rsa_authentication = -1;
#line 69
  options___0->pubkey_authentication = -1;
#line 79
  options___0->password_authentication = -1;
#line 80
  options___0->kbd_interactive_authentication = -1;
#line 81
  options___0->challenge_reponse_authentication = -1;
#line 82
  options___0->permit_empty_passwd = -1;
#line 83
  options___0->use_login = -1;
#line 84
  options___0->allow_tcp_forwarding = -1;
#line 85
  options___0->num_allow_users = 0U;
#line 86
  options___0->num_deny_users = 0U;
#line 87
  options___0->num_allow_groups = 0U;
#line 88
  options___0->num_deny_groups = 0U;
#line 89
  options___0->ciphers = (char *)((void *)0);
#line 90
  options___0->macs = (char *)((void *)0);
#line 91
  options___0->protocol = 0;
#line 92
  options___0->gateway_ports = -1;
#line 93
  options___0->num_subsystems = 0U;
#line 94
  options___0->max_startups_begin = -1;
#line 95
  options___0->max_startups_rate = -1;
#line 96
  options___0->max_startups = -1;
#line 97
  options___0->banner = (char *)((void *)0);
#line 98
  options___0->reverse_mapping_check = -1;
#line 99
  return;
}
}
#line 101 "servconf.c"
void fill_default_server_options(ServerOptions *options___0 ) 
{ int tmp ;
  int tmp___0 ;
  u_int tmp___1 ;

  {
#line 104
  if (options___0->protocol == 0) {
#line 105
    options___0->protocol = 5;
  }
#line 106
  if (options___0->num_host_key_files == 0) {
#line 108
    if (options___0->protocol & 1) {
#line 109
      tmp = options___0->num_host_key_files;
#line 109
      (options___0->num_host_key_files) ++;
#line 109
      options___0->host_key_files[tmp] = (char *)"/usr/local/etc/ssh_host_key";
    }
#line 110
    if (options___0->protocol & 4) {
#line 111
      tmp___0 = options___0->num_host_key_files;
#line 111
      (options___0->num_host_key_files) ++;
#line 111
      options___0->host_key_files[tmp___0] = (char *)"/usr/local/etc/ssh_host_dsa_key";
    }
  }
#line 113
  if (options___0->num_ports == 0U) {
#line 114
    tmp___1 = options___0->num_ports;
#line 114
    (options___0->num_ports) ++;
#line 114
    options___0->ports[tmp___1] = (unsigned short)22;
  }
#line 115
  if ((unsigned int )options___0->listen_addrs == (unsigned int )((void *)0)) {
#line 116
    add_listen_addr(options___0, (char *)((void *)0));
  }
#line 117
  if ((unsigned int )options___0->pid_file == (unsigned int )((void *)0)) {
#line 118
    options___0->pid_file = (char *)"/var/run/sshd.pid";
  }
#line 119
  if (options___0->server_key_bits == -1) {
#line 120
    options___0->server_key_bits = 768;
  }
#line 121
  if (options___0->login_grace_time == -1) {
#line 122
    options___0->login_grace_time = 600;
  }
#line 123
  if (options___0->key_regeneration_time == -1) {
#line 124
    options___0->key_regeneration_time = 3600;
  }
#line 125
  if (options___0->permit_root_login == -1) {
#line 126
    options___0->permit_root_login = 3;
  }
#line 127
  if (options___0->ignore_rhosts == -1) {
#line 128
    options___0->ignore_rhosts = 1;
  }
#line 129
  if (options___0->ignore_user_known_hosts == -1) {
#line 130
    options___0->ignore_user_known_hosts = 0;
  }
#line 131
  if (options___0->check_mail == -1) {
#line 132
    options___0->check_mail = 0;
  }
#line 133
  if (options___0->print_motd == -1) {
#line 134
    options___0->print_motd = 1;
  }
#line 135
  if (options___0->x11_forwarding == -1) {
#line 136
    options___0->x11_forwarding = 0;
  }
#line 137
  if (options___0->x11_display_offset == -1) {
#line 138
    options___0->x11_display_offset = 10;
  }
#line 140
  if ((unsigned int )options___0->xauth_location == (unsigned int )((void *)0)) {
#line 141
    options___0->xauth_location = (char *)"/usr/bin//xauth";
  }
#line 143
  if (options___0->strict_modes == -1) {
#line 144
    options___0->strict_modes = 1;
  }
#line 145
  if (options___0->keepalives == -1) {
#line 146
    options___0->keepalives = 1;
  }
#line 147
  if ((int )options___0->log_facility == (int )((int )-1)) {
#line 148
    options___0->log_facility = 2;
  }
#line 149
  if ((int )options___0->log_level == (int )((enum __anonenum_LogLevel_63 )-1)) {
#line 150
    options___0->log_level = 3;
  }
#line 151
  if (options___0->rhosts_authentication == -1) {
#line 152
    options___0->rhosts_authentication = 0;
  }
#line 153
  if (options___0->rhosts_rsa_authentication == -1) {
#line 154
    options___0->rhosts_rsa_authentication = 0;
  }
#line 155
  if (options___0->rsa_authentication == -1) {
#line 156
    options___0->rsa_authentication = 1;
  }
#line 157
  if (options___0->pubkey_authentication == -1) {
#line 158
    options___0->pubkey_authentication = 1;
  }
#line 173
  if (options___0->password_authentication == -1) {
#line 174
    options___0->password_authentication = 1;
  }
#line 175
  if (options___0->kbd_interactive_authentication == -1) {
#line 176
    options___0->kbd_interactive_authentication = 0;
  }
#line 177
  if (options___0->challenge_reponse_authentication == -1) {
#line 178
    options___0->challenge_reponse_authentication = 1;
  }
#line 179
  if (options___0->permit_empty_passwd == -1) {
#line 180
    options___0->permit_empty_passwd = 0;
  }
#line 181
  if (options___0->use_login == -1) {
#line 182
    options___0->use_login = 0;
  }
#line 183
  if (options___0->allow_tcp_forwarding == -1) {
#line 184
    options___0->allow_tcp_forwarding = 1;
  }
#line 185
  if (options___0->gateway_ports == -1) {
#line 186
    options___0->gateway_ports = 0;
  }
#line 187
  if (options___0->max_startups == -1) {
#line 188
    options___0->max_startups = 10;
  }
#line 189
  if (options___0->max_startups_rate == -1) {
#line 190
    options___0->max_startups_rate = 100;
  }
#line 191
  if (options___0->max_startups_begin == -1) {
#line 192
    options___0->max_startups_begin = options___0->max_startups;
  }
#line 193
  if (options___0->reverse_mapping_check == -1) {
#line 194
    options___0->reverse_mapping_check = 0;
  }
#line 195
  return;
}
}
#line 221 "servconf.c"
static struct __anonstruct_keywords_79 keywords[46]  = 
#line 221
  {      {"port", 1}, 
        {"hostkey", 2}, 
        {"hostdsakey", 2}, 
        {"pidfile", 35}, 
        {"serverkeybits", 3}, 
        {"logingracetime", 4}, 
        {"keyregenerationinterval", 5}, 
        {"permitrootlogin", 6}, 
        {"syslogfacility", 7}, 
        {"loglevel", 8}, 
        {"rhostsauthentication", 9}, 
        {"rhostsrsaauthentication", 10}, 
        {"rsaauthentication", 11}, 
        {"pubkeyauthentication", 37}, 
        {"dsaauthentication", 37}, 
        {"passwordauthentication", 13}, 
        {"kbdinteractiveauthentication", 14}, 
        {"challengeresponseauthentication", 12}, 
        {"skeyauthentication", 12}, 
        {"checkmail", 24}, 
        {"listenaddress", 15}, 
        {"printmotd", 16}, 
        {"ignorerhosts", 17}, 
        {"ignoreuserknownhosts", 31}, 
        {"x11forwarding", 18}, 
        {"x11displayoffset", 19}, 
        {"xauthlocation", 38}, 
        {"strictmodes", 20}, 
        {"permitemptypasswords", 21}, 
        {"uselogin", 25}, 
        {"randomseed", 22}, 
        {"keepalive", 23}, 
        {"allowtcpforwarding", 26}, 
        {"allowusers", 27}, 
        {"denyusers", 28}, 
        {"allowgroups", 29}, 
        {"denygroups", 30}, 
        {"ciphers", 32}, 
        {"macs", 33}, 
        {"protocol", 34}, 
        {"gatewayports", 36}, 
        {"subsystem", 39}, 
        {"maxstartups", 40}, 
        {"banner", 41}, 
        {"reversemappingcheck", 42}, 
        {(char const   *)((void *)0), (ServerOpCodes )0}};
#line 287 "servconf.c"
static ServerOpCodes parse_token(char const   *cp , char const   *filename , int linenum ) 
{ u_int i ;
  int tmp ;

  {
#line 293
  i = 0U;
#line 293
  while (keywords[i].name) {
#line 294
    tmp = strcasecmp(cp, keywords[i].name);
#line 294
    if (tmp == 0) {
#line 295
      return (keywords[i].opcode);
    }
#line 293
    i ++;
  }
#line 297
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: line %d: Bad configuration option: %s\n",
          filename, linenum, cp);
#line 299
  return (0);
}
}
#line 305 "servconf.c"
void add_listen_addr(ServerOptions *options___0 , char *addr ) 
{ struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  int i ;
  u_int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 313
  if (options___0->num_ports == 0U) {
#line 314
    tmp = options___0->num_ports;
#line 314
    (options___0->num_ports) ++;
#line 314
    options___0->ports[tmp] = (unsigned short)22;
  }
#line 315
  i = 0;
#line 315
  while ((u_int )i < options___0->num_ports) {
#line 316
    memset((void *)(& hints), 0, sizeof(hints));
#line 317
    hints.ai_family = IPv4or6;
#line 318
    hints.ai_socktype = 1;
#line 319
    if ((unsigned int )addr == (unsigned int )((void *)0)) {
#line 319
      hints.ai_flags = 1;
    } else {
#line 319
      hints.ai_flags = 0;
    }
#line 320
    snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
             options___0->ports[i]);
#line 321
    gaierr = getaddrinfo((char const   * __restrict  )addr, (char const   * __restrict  )(strport),
                         (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 321
    if (gaierr != 0) {
#line 322
      tmp___0 = gai_strerror(gaierr);
#line 322
      if (addr) {
#line 322
        tmp___1 = (char const   *)addr;
      } else {
#line 322
        tmp___1 = "<NULL>";
      }
#line 322
      fatal("bad addr or host: %s (%s)\n", tmp___1, tmp___0);
    }
#line 325
    ai = aitop;
#line 325
    while (ai->ai_next) {
#line 325
      ai = ai->ai_next;
    }
#line 327
    ai->ai_next = options___0->listen_addrs;
#line 328
    options___0->listen_addrs = aitop;
#line 315
    i ++;
  }
#line 330
  return;
}
}
#line 334 "servconf.c"
void read_server_config(ServerOptions *options___0 , char const   *filename ) 
{ FILE *f ;
  char line[1024] ;
  char *cp ;
  char **charptr ;
  char *arg ;
  int linenum ;
  int *intptr ;
  int value ;
  int bad_options ;
  ServerOpCodes opcode ;
  int i ;
  u_int tmp ;
  int tmp___0 ;
  __uid_t tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___17 ;
  int tmp___20 ;
  int tmp___21 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___27 ;
  int tmp___30 ;
  int tmp___31 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___37 ;
  int tmp___40 ;
  int tmp___41 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___47 ;
  int tmp___50 ;
  int tmp___51 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___57 ;
  int tmp___60 ;
  int tmp___61 ;
  SyslogFacility tmp___62 ;
  char const   *tmp___63 ;
  LogLevel tmp___64 ;
  char const   *tmp___65 ;
  u_int tmp___66 ;
  u_int tmp___67 ;
  u_int tmp___68 ;
  u_int tmp___69 ;
  char const   *tmp___70 ;
  int tmp___71 ;
  char const   *tmp___72 ;
  int tmp___73 ;
  char const   *tmp___74 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___80 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  char *tmp___86 ;

  {
#line 341
  bad_options = 0;
#line 345
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 346
  if (! f) {
#line 347
    perror(filename);
#line 348
    exit(1);
  }
#line 350
  linenum = 0;
#line 351
  while (1) {
#line 351
    tmp___86 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 351
    if (! tmp___86) {
#line 351
      break;
    }
#line 352
    linenum ++;
#line 353
    cp = line;
#line 354
    arg = strdelim(& cp);
#line 356
    if ((int )*arg == 0) {
#line 357
      arg = strdelim(& cp);
    }
#line 358
    if (! arg) {
#line 359
      continue;
    } else {
#line 358
      if (! *arg) {
#line 359
        continue;
      } else {
#line 358
        if ((int )*arg == 35) {
#line 359
          continue;
        }
      }
    }
#line 360
    intptr = (int *)((void *)0);
#line 361
    charptr = (char **)((void *)0);
#line 362
    opcode = parse_token((char const   *)arg, filename, linenum);
#line 363
    switch ((int )opcode) {
    case 0: 
#line 365
    bad_options ++;
#line 366
    continue;
    case 1: 
#line 369
    if (options___0->ports_from_cmdline) {
#line 370
      continue;
    }
#line 371
    if ((unsigned int )options___0->listen_addrs != (unsigned int )((void *)0)) {
#line 372
      fatal("%s line %d: ports must be specified before ListenAdress.\n", filename,
            linenum);
    }
#line 374
    if (options___0->num_ports >= 256U) {
#line 375
      fatal("%s line %d: too many ports.\n", filename, linenum);
    }
#line 377
    arg = strdelim(& cp);
#line 378
    if (! arg) {
#line 379
      fatal("%s line %d: missing port number.\n", filename, linenum);
    } else {
#line 378
      if ((int )*arg == 0) {
#line 379
        fatal("%s line %d: missing port number.\n", filename, linenum);
      }
    }
#line 381
    tmp = options___0->num_ports;
#line 381
    (options___0->num_ports) ++;
#line 381
    tmp___0 = atoi((char const   *)arg);
#line 381
    options___0->ports[tmp] = (unsigned short )tmp___0;
#line 382
    break;
    case 3: 
#line 385
    intptr = & options___0->server_key_bits;
    parse_int: 
#line 387
    arg = strdelim(& cp);
#line 388
    if (! arg) {
#line 389
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing integer value.\n",
              filename, linenum);
#line 391
      exit(1);
    } else {
#line 388
      if ((int )*arg == 0) {
#line 389
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing integer value.\n",
                filename, linenum);
#line 391
        exit(1);
      }
    }
#line 393
    value = atoi((char const   *)arg);
#line 394
    if (*intptr == -1) {
#line 395
      *intptr = value;
    }
#line 396
    break;
    case 4: 
#line 399
    intptr = & options___0->login_grace_time;
    goto parse_int;
    case 5: 
#line 403
    intptr = & options___0->key_regeneration_time;
    goto parse_int;
    case 15: 
#line 407
    arg = strdelim(& cp);
#line 408
    if (! arg) {
#line 409
      fatal("%s line %d: missing inet addr.\n", filename, linenum);
    } else {
#line 408
      if ((int )*arg == 0) {
#line 409
        fatal("%s line %d: missing inet addr.\n", filename, linenum);
      }
    }
#line 411
    add_listen_addr(options___0, arg);
#line 412
    break;
    case 2: 
#line 415
    intptr = & options___0->num_host_key_files;
#line 416
    if (*intptr >= 256) {
#line 417
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: to many host keys specified (max %d).\n",
              filename, linenum, 256);
#line 419
      exit(1);
    }
#line 421
    charptr = & options___0->host_key_files[*intptr];
    parse_filename: 
#line 423
    arg = strdelim(& cp);
#line 424
    if (! arg) {
#line 425
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing file name.\n",
              filename, linenum);
#line 427
      exit(1);
    } else {
#line 424
      if ((int )*arg == 0) {
#line 425
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing file name.\n",
                filename, linenum);
#line 427
        exit(1);
      }
    }
#line 429
    if ((unsigned int )*charptr == (unsigned int )((void *)0)) {
#line 430
      tmp___1 = getuid();
#line 430
      *charptr = tilde_expand_filename((char const   *)arg, tmp___1);
#line 432
      if ((unsigned int )intptr != (unsigned int )((void *)0)) {
#line 433
        (*intptr) ++;
      }
    }
#line 435
    break;
    case 35: 
#line 438
    charptr = & options___0->pid_file;
    goto parse_filename;
    case 22: 
#line 442
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: \"randomseed\" option is obsolete.\n",
            filename, linenum);
#line 444
    arg = strdelim(& cp);
#line 445
    break;
    case 6: 
#line 448
    intptr = & options___0->permit_root_login;
#line 449
    arg = strdelim(& cp);
#line 450
    if (! arg) {
#line 451
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing yes/without-password/no argument.\n",
              filename, linenum);
#line 453
      exit(1);
    } else {
#line 450
      if ((int )*arg == 0) {
#line 451
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing yes/without-password/no argument.\n",
                filename, linenum);
#line 453
        exit(1);
      }
    }
#line 455
    if (0) {
#line 455
      __s1_len___2 = strlen((char const   *)arg);
#line 455
      __s2_len___2 = strlen("without-password");
#line 455
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___6;
      } else {
#line 455
        if (__s1_len___2 >= 4U) {
          _L___6: /* CIL Label */ 
#line 455
          if (! ((unsigned int )((void const   *)("without-password" + 1)) - (unsigned int )((void const   *)"without-password") == 1U)) {
#line 455
            tmp___41 = 1;
          } else {
#line 455
            if (__s2_len___2 >= 4U) {
#line 455
              tmp___41 = 1;
            } else {
#line 455
              tmp___41 = 0;
            }
          }
        } else {
#line 455
          tmp___41 = 0;
        }
      }
#line 455
      if (tmp___41) {
#line 455
        tmp___37 = __builtin_strcmp((char const   *)arg, "without-password");
      } else {
#line 455
        tmp___40 = __builtin_strcmp((char const   *)arg, "without-password");
#line 455
        tmp___37 = tmp___40;
      }
    } else {
#line 455
      tmp___40 = __builtin_strcmp((char const   *)arg, "without-password");
#line 455
      tmp___37 = tmp___40;
    }
#line 455
    if (tmp___37 == 0) {
#line 456
      value = 2;
    } else {
#line 457
      if (0) {
#line 457
        __s1_len___1 = strlen((char const   *)arg);
#line 457
        __s2_len___1 = strlen("forced-commands-only");
#line 457
        if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
          goto _L___4;
        } else {
#line 457
          if (__s1_len___1 >= 4U) {
            _L___4: /* CIL Label */ 
#line 457
            if (! ((unsigned int )((void const   *)("forced-commands-only" + 1)) - (unsigned int )((void const   *)"forced-commands-only") == 1U)) {
#line 457
              tmp___31 = 1;
            } else {
#line 457
              if (__s2_len___1 >= 4U) {
#line 457
                tmp___31 = 1;
              } else {
#line 457
                tmp___31 = 0;
              }
            }
          } else {
#line 457
            tmp___31 = 0;
          }
        }
#line 457
        if (tmp___31) {
#line 457
          tmp___27 = __builtin_strcmp((char const   *)arg, "forced-commands-only");
        } else {
#line 457
          tmp___30 = __builtin_strcmp((char const   *)arg, "forced-commands-only");
#line 457
          tmp___27 = tmp___30;
        }
      } else {
#line 457
        tmp___30 = __builtin_strcmp((char const   *)arg, "forced-commands-only");
#line 457
        tmp___27 = tmp___30;
      }
#line 457
      if (tmp___27 == 0) {
#line 458
        value = 1;
      } else {
#line 459
        if (0) {
#line 459
          __s1_len___0 = strlen((char const   *)arg);
#line 459
          __s2_len___0 = strlen("yes");
#line 459
          if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
            goto _L___2;
          } else {
#line 459
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 459
              if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 459
                tmp___21 = 1;
              } else {
#line 459
                if (__s2_len___0 >= 4U) {
#line 459
                  tmp___21 = 1;
                } else {
#line 459
                  tmp___21 = 0;
                }
              }
            } else {
#line 459
              tmp___21 = 0;
            }
          }
#line 459
          if (tmp___21) {
#line 459
            tmp___17 = __builtin_strcmp((char const   *)arg, "yes");
          } else {
#line 459
            tmp___20 = __builtin_strcmp((char const   *)arg, "yes");
#line 459
            tmp___17 = tmp___20;
          }
        } else {
#line 459
          tmp___20 = __builtin_strcmp((char const   *)arg, "yes");
#line 459
          tmp___17 = tmp___20;
        }
#line 459
        if (tmp___17 == 0) {
#line 460
          value = 3;
        } else {
#line 461
          if (0) {
#line 461
            __s1_len = strlen((char const   *)arg);
#line 461
            __s2_len = strlen("no");
#line 461
            if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
              goto _L___0;
            } else {
#line 461
              if (__s1_len >= 4U) {
                _L___0: /* CIL Label */ 
#line 461
                if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 461
                  tmp___11 = 1;
                } else {
#line 461
                  if (__s2_len >= 4U) {
#line 461
                    tmp___11 = 1;
                  } else {
#line 461
                    tmp___11 = 0;
                  }
                }
              } else {
#line 461
                tmp___11 = 0;
              }
            }
#line 461
            if (tmp___11) {
#line 461
              tmp___7 = __builtin_strcmp((char const   *)arg, "no");
            } else {
#line 461
              tmp___10 = __builtin_strcmp((char const   *)arg, "no");
#line 461
              tmp___7 = tmp___10;
            }
          } else {
#line 461
            tmp___10 = __builtin_strcmp((char const   *)arg, "no");
#line 461
            tmp___7 = tmp___10;
          }
#line 461
          if (tmp___7 == 0) {
#line 462
            value = 0;
          } else {
#line 464
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: Bad yes/without-password/forced-commands-only/no argument: %s\n",
                    filename, linenum, arg);
#line 467
            exit(1);
          }
        }
      }
    }
#line 469
    if (*intptr == -1) {
#line 470
      *intptr = value;
    }
#line 471
    break;
    case 17: 
#line 474
    intptr = & options___0->ignore_rhosts;
    parse_flag: 
#line 476
    arg = strdelim(& cp);
#line 477
    if (! arg) {
#line 478
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing yes/no argument.\n",
              filename, linenum);
#line 480
      exit(1);
    } else {
#line 477
      if ((int )*arg == 0) {
#line 478
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing yes/no argument.\n",
                filename, linenum);
#line 480
        exit(1);
      }
    }
#line 482
    if (0) {
#line 482
      __s1_len___4 = strlen((char const   *)arg);
#line 482
      __s2_len___4 = strlen("yes");
#line 482
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___10;
      } else {
#line 482
        if (__s1_len___4 >= 4U) {
          _L___10: /* CIL Label */ 
#line 482
          if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 482
            tmp___61 = 1;
          } else {
#line 482
            if (__s2_len___4 >= 4U) {
#line 482
              tmp___61 = 1;
            } else {
#line 482
              tmp___61 = 0;
            }
          }
        } else {
#line 482
          tmp___61 = 0;
        }
      }
#line 482
      if (tmp___61) {
#line 482
        tmp___57 = __builtin_strcmp((char const   *)arg, "yes");
      } else {
#line 482
        tmp___60 = __builtin_strcmp((char const   *)arg, "yes");
#line 482
        tmp___57 = tmp___60;
      }
    } else {
#line 482
      tmp___60 = __builtin_strcmp((char const   *)arg, "yes");
#line 482
      tmp___57 = tmp___60;
    }
#line 482
    if (tmp___57 == 0) {
#line 483
      value = 1;
    } else {
#line 484
      if (0) {
#line 484
        __s1_len___3 = strlen((char const   *)arg);
#line 484
        __s2_len___3 = strlen("no");
#line 484
        if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
          goto _L___8;
        } else {
#line 484
          if (__s1_len___3 >= 4U) {
            _L___8: /* CIL Label */ 
#line 484
            if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 484
              tmp___51 = 1;
            } else {
#line 484
              if (__s2_len___3 >= 4U) {
#line 484
                tmp___51 = 1;
              } else {
#line 484
                tmp___51 = 0;
              }
            }
          } else {
#line 484
            tmp___51 = 0;
          }
        }
#line 484
        if (tmp___51) {
#line 484
          tmp___47 = __builtin_strcmp((char const   *)arg, "no");
        } else {
#line 484
          tmp___50 = __builtin_strcmp((char const   *)arg, "no");
#line 484
          tmp___47 = tmp___50;
        }
      } else {
#line 484
        tmp___50 = __builtin_strcmp((char const   *)arg, "no");
#line 484
        tmp___47 = tmp___50;
      }
#line 484
      if (tmp___47 == 0) {
#line 485
        value = 0;
      } else {
#line 487
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: Bad yes/no argument: %s\n",
                filename, linenum, arg);
#line 489
        exit(1);
      }
    }
#line 491
    if (*intptr == -1) {
#line 492
      *intptr = value;
    }
#line 493
    break;
    case 31: 
#line 496
    intptr = & options___0->ignore_user_known_hosts;
    goto parse_flag;
    case 9: 
#line 500
    intptr = & options___0->rhosts_authentication;
    goto parse_flag;
    case 10: 
#line 504
    intptr = & options___0->rhosts_rsa_authentication;
    goto parse_flag;
    case 11: 
#line 508
    intptr = & options___0->rsa_authentication;
    goto parse_flag;
    case 37: 
#line 512
    intptr = & options___0->pubkey_authentication;
    goto parse_flag;
    case 13: 
#line 540
    intptr = & options___0->password_authentication;
    goto parse_flag;
    case 14: 
#line 544
    intptr = & options___0->kbd_interactive_authentication;
    goto parse_flag;
    case 24: 
#line 548
    intptr = & options___0->check_mail;
    goto parse_flag;
    case 12: 
#line 552
    intptr = & options___0->challenge_reponse_authentication;
    goto parse_flag;
    case 16: 
#line 556
    intptr = & options___0->print_motd;
    goto parse_flag;
    case 18: 
#line 560
    intptr = & options___0->x11_forwarding;
    goto parse_flag;
    case 19: 
#line 564
    intptr = & options___0->x11_display_offset;
    goto parse_int;
    case 38: 
#line 568
    charptr = & options___0->xauth_location;
    goto parse_filename;
    case 20: 
#line 572
    intptr = & options___0->strict_modes;
    goto parse_flag;
    case 23: 
#line 576
    intptr = & options___0->keepalives;
    goto parse_flag;
    case 21: 
#line 580
    intptr = & options___0->permit_empty_passwd;
    goto parse_flag;
    case 25: 
#line 584
    intptr = & options___0->use_login;
    goto parse_flag;
    case 36: 
#line 588
    intptr = & options___0->gateway_ports;
    goto parse_flag;
    case 42: 
#line 592
    intptr = & options___0->reverse_mapping_check;
    goto parse_flag;
    case 7: 
#line 596
    intptr = (int *)(& options___0->log_facility);
#line 597
    arg = strdelim(& cp);
#line 598
    tmp___62 = log_facility_number(arg);
#line 598
    value = (int )tmp___62;
#line 599
    if (value == (int )((int )-1)) {
#line 600
      if (arg) {
#line 600
        tmp___63 = (char const   *)arg;
      } else {
#line 600
        tmp___63 = "<NONE>";
      }
#line 600
      fatal("%.200s line %d: unsupported log facility \'%s\'\n", filename, linenum,
            tmp___63);
    }
#line 602
    if (*intptr == -1) {
#line 603
      *intptr = (int )((int )value);
    }
#line 604
    break;
    case 8: 
#line 607
    intptr = (int *)(& options___0->log_level);
#line 608
    arg = strdelim(& cp);
#line 609
    tmp___64 = log_level_number(arg);
#line 609
    value = (int )tmp___64;
#line 610
    if (value == (int )((enum __anonenum_LogLevel_63 )-1)) {
#line 611
      if (arg) {
#line 611
        tmp___65 = (char const   *)arg;
      } else {
#line 611
        tmp___65 = "<NONE>";
      }
#line 611
      fatal("%.200s line %d: unsupported log level \'%s\'\n", filename, linenum, tmp___65);
    }
#line 613
    if (*intptr == -1) {
#line 614
      *intptr = (int )((enum __anonenum_LogLevel_63 )value);
    }
#line 615
    break;
    case 26: 
#line 618
    intptr = & options___0->allow_tcp_forwarding;
    goto parse_flag;
    case 27: 
#line 622
    while (1) {
#line 622
      arg = strdelim(& cp);
#line 622
      if (arg) {
#line 622
        if (! ((int )*arg != 0)) {
#line 622
          break;
        }
      } else {
#line 622
        break;
      }
#line 623
      if (options___0->num_allow_users >= 256U) {
#line 624
        fatal("%s line %d: too many allow users.\n", filename, linenum);
      }
#line 626
      tmp___66 = options___0->num_allow_users;
#line 626
      (options___0->num_allow_users) ++;
#line 626
      options___0->allow_users[tmp___66] = xstrdup((char const   *)arg);
    }
#line 628
    break;
    case 28: 
#line 631
    while (1) {
#line 631
      arg = strdelim(& cp);
#line 631
      if (arg) {
#line 631
        if (! ((int )*arg != 0)) {
#line 631
          break;
        }
      } else {
#line 631
        break;
      }
#line 632
      if (options___0->num_deny_users >= 256U) {
#line 633
        fatal("%s line %d: too many deny users.\n", filename, linenum);
      }
#line 635
      tmp___67 = options___0->num_deny_users;
#line 635
      (options___0->num_deny_users) ++;
#line 635
      options___0->deny_users[tmp___67] = xstrdup((char const   *)arg);
    }
#line 637
    break;
    case 29: 
#line 640
    while (1) {
#line 640
      arg = strdelim(& cp);
#line 640
      if (arg) {
#line 640
        if (! ((int )*arg != 0)) {
#line 640
          break;
        }
      } else {
#line 640
        break;
      }
#line 641
      if (options___0->num_allow_groups >= 256U) {
#line 642
        fatal("%s line %d: too many allow groups.\n", filename, linenum);
      }
#line 644
      tmp___68 = options___0->num_allow_groups;
#line 644
      (options___0->num_allow_groups) ++;
#line 644
      options___0->allow_groups[tmp___68] = xstrdup((char const   *)arg);
    }
#line 646
    break;
    case 30: 
#line 649
    while (1) {
#line 649
      arg = strdelim(& cp);
#line 649
      if (arg) {
#line 649
        if (! ((int )*arg != 0)) {
#line 649
          break;
        }
      } else {
#line 649
        break;
      }
#line 650
      if (options___0->num_deny_groups >= 256U) {
#line 651
        fatal("%s line %d: too many deny groups.\n", filename, linenum);
      }
#line 653
      tmp___69 = options___0->num_deny_groups;
#line 653
      (options___0->num_deny_groups) ++;
#line 653
      options___0->deny_groups[tmp___69] = xstrdup((char const   *)arg);
    }
#line 655
    break;
    case 32: 
#line 658
    arg = strdelim(& cp);
#line 659
    if (! arg) {
#line 660
      fatal("%s line %d: Missing argument.", filename, linenum);
    } else {
#line 659
      if ((int )*arg == 0) {
#line 660
        fatal("%s line %d: Missing argument.", filename, linenum);
      }
    }
#line 661
    tmp___71 = ciphers_valid((char const   *)arg);
#line 661
    if (! tmp___71) {
#line 662
      if (arg) {
#line 662
        tmp___70 = (char const   *)arg;
      } else {
#line 662
        tmp___70 = "<NONE>";
      }
#line 662
      fatal("%s line %d: Bad SSH2 cipher spec \'%s\'.", filename, linenum, tmp___70);
    }
#line 664
    if ((unsigned int )options___0->ciphers == (unsigned int )((void *)0)) {
#line 665
      options___0->ciphers = xstrdup((char const   *)arg);
    }
#line 666
    break;
    case 33: 
#line 669
    arg = strdelim(& cp);
#line 670
    if (! arg) {
#line 671
      fatal("%s line %d: Missing argument.", filename, linenum);
    } else {
#line 670
      if ((int )*arg == 0) {
#line 671
        fatal("%s line %d: Missing argument.", filename, linenum);
      }
    }
#line 672
    tmp___73 = mac_valid((char const   *)arg);
#line 672
    if (! tmp___73) {
#line 673
      if (arg) {
#line 673
        tmp___72 = (char const   *)arg;
      } else {
#line 673
        tmp___72 = "<NONE>";
      }
#line 673
      fatal("%s line %d: Bad SSH2 mac spec \'%s\'.", filename, linenum, tmp___72);
    }
#line 675
    if ((unsigned int )options___0->macs == (unsigned int )((void *)0)) {
#line 676
      options___0->macs = xstrdup((char const   *)arg);
    }
#line 677
    break;
    case 34: 
#line 680
    intptr = & options___0->protocol;
#line 681
    arg = strdelim(& cp);
#line 682
    if (! arg) {
#line 683
      fatal("%s line %d: Missing argument.", filename, linenum);
    } else {
#line 682
      if ((int )*arg == 0) {
#line 683
        fatal("%s line %d: Missing argument.", filename, linenum);
      }
    }
#line 684
    value = proto_spec((char const   *)arg);
#line 685
    if (value == 0) {
#line 686
      if (arg) {
#line 686
        tmp___74 = (char const   *)arg;
      } else {
#line 686
        tmp___74 = "<NONE>";
      }
#line 686
      fatal("%s line %d: Bad protocol spec \'%s\'.", filename, linenum, tmp___74);
    }
#line 688
    if (*intptr == 0) {
#line 689
      *intptr = value;
    }
#line 690
    break;
    case 39: 
#line 693
    if (options___0->num_subsystems >= 256U) {
#line 694
      fatal("%s line %d: too many subsystems defined.", filename, linenum);
    }
#line 697
    arg = strdelim(& cp);
#line 698
    if (! arg) {
#line 699
      fatal("%s line %d: Missing subsystem name.", filename, linenum);
    } else {
#line 698
      if ((int )*arg == 0) {
#line 699
        fatal("%s line %d: Missing subsystem name.", filename, linenum);
      }
    }
#line 701
    i = 0;
#line 701
    while ((u_int )i < options___0->num_subsystems) {
#line 702
      if (0) {
#line 702
        __s1_len___5 = strlen((char const   *)arg);
#line 702
        __s2_len___5 = strlen((char const   *)options___0->subsystem_name[i]);
#line 702
        if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
          goto _L___12;
        } else {
#line 702
          if (__s1_len___5 >= 4U) {
            _L___12: /* CIL Label */ 
#line 702
            if (! ((unsigned int )((void const   *)(options___0->subsystem_name[i] + 1)) - (unsigned int )((void const   *)options___0->subsystem_name[i]) == 1U)) {
#line 702
              tmp___84 = 1;
            } else {
#line 702
              if (__s2_len___5 >= 4U) {
#line 702
                tmp___84 = 1;
              } else {
#line 702
                tmp___84 = 0;
              }
            }
          } else {
#line 702
            tmp___84 = 0;
          }
        }
#line 702
        if (tmp___84) {
#line 702
          tmp___80 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
        } else {
#line 702
          tmp___83 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
#line 702
          tmp___80 = tmp___83;
        }
      } else {
#line 702
        tmp___83 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
#line 702
        tmp___80 = tmp___83;
      }
#line 702
      if (tmp___80 == 0) {
#line 703
        fatal("%s line %d: Subsystem \'%s\' already defined.", filename, linenum,
              arg);
      }
#line 701
      i ++;
    }
#line 705
    options___0->subsystem_name[options___0->num_subsystems] = xstrdup((char const   *)arg);
#line 706
    arg = strdelim(& cp);
#line 707
    if (! arg) {
#line 708
      fatal("%s line %d: Missing subsystem command.", filename, linenum);
    } else {
#line 707
      if ((int )*arg == 0) {
#line 708
        fatal("%s line %d: Missing subsystem command.", filename, linenum);
      }
    }
#line 710
    options___0->subsystem_command[options___0->num_subsystems] = xstrdup((char const   *)arg);
#line 711
    (options___0->num_subsystems) ++;
#line 712
    break;
    case 40: 
#line 715
    arg = strdelim(& cp);
#line 716
    if (! arg) {
#line 717
      fatal("%s line %d: Missing MaxStartups spec.", filename, linenum);
    } else {
#line 716
      if ((int )*arg == 0) {
#line 717
        fatal("%s line %d: Missing MaxStartups spec.", filename, linenum);
      }
    }
#line 719
    tmp___85 = sscanf((char const   * __restrict  )arg, (char const   * __restrict  )"%d:%d:%d",
                      & options___0->max_startups_begin, & options___0->max_startups_rate,
                      & options___0->max_startups);
#line 719
    if (tmp___85 == 3) {
#line 723
      if (options___0->max_startups_begin > options___0->max_startups) {
#line 727
        fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
      } else {
#line 723
        if (options___0->max_startups_rate > 100) {
#line 727
          fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
        } else {
#line 723
          if (options___0->max_startups_rate < 1) {
#line 727
            fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
          }
        }
      }
#line 729
      break;
    }
#line 731
    intptr = & options___0->max_startups;
    goto parse_int;
    case 41: 
#line 735
    charptr = & options___0->banner;
    goto parse_filename;
    default: 
#line 739
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: Missing handler for opcode %s (%d)\n",
            filename, linenum, arg, opcode);
#line 741
    exit(1);
    }
#line 743
    arg = strdelim(& cp);
#line 743
    if ((unsigned int )arg != (unsigned int )((void *)0)) {
#line 743
      if ((int )*arg != 0) {
#line 744
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: garbage at end of line; \"%.200s\".\n",
                filename, linenum, arg);
#line 747
        exit(1);
      }
    }
  }
#line 750
  fclose(f);
#line 751
  if (bad_options > 0) {
#line 752
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: terminating, %d bad configuration options\n",
            filename, bad_options);
#line 754
    exit(1);
  }
#line 756
  return;
}
}
#line 1 "serverloop.o"
#pragma merger(0,"./serverloop.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 116 "/usr/include/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 34 "session.h"
int session_open(int chanid ) ;
#line 35
void session_input_channel_req(int id , void *arg ) ;
#line 36
void session_close_by_pid(pid_t pid , int status ) ;
#line 37
void session_close_by_channel(int id , void *arg ) ;
#line 21 "serverloop.h"
void server_loop(pid_t pid , int fdin_arg , int fdout_arg , int fderr_arg ) ;
#line 22
void server_loop2(void) ;
#line 59 "serverloop.c"
static Buffer stdin_buffer  ;
#line 60 "serverloop.c"
static Buffer stdout_buffer  ;
#line 61 "serverloop.c"
static Buffer stderr_buffer  ;
#line 62 "serverloop.c"
static int fdin  ;
#line 63 "serverloop.c"
static int fdout  ;
#line 65 "serverloop.c"
static int fderr  ;
#line 66 "serverloop.c"
static long stdin_bytes  =    0L;
#line 67 "serverloop.c"
static long stdout_bytes  =    0L;
#line 68 "serverloop.c"
static long stderr_bytes  =    0L;
#line 69 "serverloop.c"
static long fdout_bytes  =    0L;
#line 70 "serverloop.c"
static int stdin_eof  =    0;
#line 71 "serverloop.c"
static int fdout_eof  =    0;
#line 72 "serverloop.c"
static int fderr_eof  =    0;
#line 73 "serverloop.c"
static int fdin_is_tty  =    0;
#line 74 "serverloop.c"
static int connection_in___0  ;
#line 75 "serverloop.c"
static int connection_out___0  ;
#line 76 "serverloop.c"
static u_int buffer_high  ;
#line 83 "serverloop.c"
static pid_t child_pid  ;
#line 84 "serverloop.c"
static int volatile   child_terminated  ;
#line 85 "serverloop.c"
static int volatile   child_wait_status  ;
#line 87
void server_init_dispatch(void) ;
#line 89 "serverloop.c"
void sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  pid_t wait_pid ;
  union __anonunion_70 __constr_expr_0 ;
  union __anonunion_71 __constr_expr_1 ;
  int *tmp___0 ;

  {
#line 92
  tmp = __errno_location();
#line 92
  save_errno = *tmp;
#line 95
  debug("Received SIGCHLD.");
#line 96
  wait_pid = wait((union wait *)((int *)(& child_wait_status)));
#line 97
  if (wait_pid != -1) {
#line 98
    if (wait_pid != child_pid) {
#line 99
      error("Strange, got SIGCHLD and wait returned pid %d but child is %d", wait_pid,
            child_pid);
    }
#line 101
    __constr_expr_0.__in = child_wait_status;
#line 101
    if ((__constr_expr_0.__i & 127) == 0) {
#line 103
      child_terminated = (int volatile   )1;
    } else {
#line 101
      __constr_expr_1.__in = child_wait_status;
#line 101
      if ((int )((signed char )((__constr_expr_1.__i & 127) + 1)) >> 1 > 0) {
#line 103
        child_terminated = (int volatile   )1;
      }
    }
  }
#line 105
  signal(17, & sigchld_handler);
#line 106
  tmp___0 = __errno_location();
#line 106
  *tmp___0 = save_errno;
#line 107
  return;
}
}
#line 108 "serverloop.c"
void sigchld_handler2(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 111
  tmp = __errno_location();
#line 111
  save_errno = *tmp;
#line 112
  debug("Received SIGCHLD.");
#line 113
  child_terminated = (int volatile   )1;
#line 114
  mysignal(17, & sigchld_handler2);
#line 115
  tmp___0 = __errno_location();
#line 115
  *tmp___0 = save_errno;
#line 116
  return;
}
}
#line 122 "serverloop.c"
void make_packets_from_stderr_data(void) 
{ int len ;
  u_int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  u_int tmp___2 ;
  int tmp___3 ;

  {
#line 128
  while (1) {
#line 128
    tmp___2 = buffer_len(& stderr_buffer);
#line 128
    if (tmp___2 > 0U) {
#line 128
      tmp___3 = packet_not_very_much_data_to_write();
#line 128
      if (! tmp___3) {
#line 128
        break;
      }
    } else {
#line 128
      break;
    }
#line 130
    tmp = buffer_len(& stderr_buffer);
#line 130
    len = (int )tmp;
#line 131
    tmp___0 = packet_is_interactive();
#line 131
    if (tmp___0) {
#line 132
      if (len > 512) {
#line 133
        len = 512;
      }
    } else {
#line 136
      if (len > max_packet_size) {
#line 137
        len = max_packet_size;
      }
    }
#line 139
    packet_start(18);
#line 140
    tmp___1 = buffer_ptr(& stderr_buffer);
#line 140
    packet_put_string((char const   *)tmp___1, (unsigned int )len);
#line 141
    packet_send();
#line 142
    buffer_consume(& stderr_buffer, (unsigned int )len);
#line 143
    stderr_bytes += (long )len;
  }
#line 145
  return;
}
}
#line 151 "serverloop.c"
void make_packets_from_stdout_data(void) 
{ int len ;
  u_int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  u_int tmp___2 ;
  int tmp___3 ;

  {
#line 157
  while (1) {
#line 157
    tmp___2 = buffer_len(& stdout_buffer);
#line 157
    if (tmp___2 > 0U) {
#line 157
      tmp___3 = packet_not_very_much_data_to_write();
#line 157
      if (! tmp___3) {
#line 157
        break;
      }
    } else {
#line 157
      break;
    }
#line 159
    tmp = buffer_len(& stdout_buffer);
#line 159
    len = (int )tmp;
#line 160
    tmp___0 = packet_is_interactive();
#line 160
    if (tmp___0) {
#line 161
      if (len > 512) {
#line 162
        len = 512;
      }
    } else {
#line 165
      if (len > max_packet_size) {
#line 166
        len = max_packet_size;
      }
    }
#line 168
    packet_start(17);
#line 169
    tmp___1 = buffer_ptr(& stdout_buffer);
#line 169
    packet_put_string((char const   *)tmp___1, (unsigned int )len);
#line 170
    packet_send();
#line 171
    buffer_consume(& stdout_buffer, (unsigned int )len);
#line 172
    stdout_bytes += (long )len;
  }
#line 174
  return;
}
}
#line 182 "serverloop.c"
void wait_until_can_do_something(fd_set **readsetp , fd_set **writesetp , int *maxfdp ,
                                 u_int max_time_milliseconds ) 
{ struct timeval tv ;
  struct timeval *tvp ;
  int ret ;
  int tmp ;
  u_int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  u_int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;

  {
  retry_select: 
#line 193
  channel_prepare_select(readsetp, writesetp, maxfdp);
#line 195
  if (compat20) {
#line 197
    tmp = channel_not_very_much_buffered_data();
#line 197
    if (tmp) {
#line 198
      __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
  } else {
#line 204
    tmp___0 = buffer_len(& stdin_buffer);
#line 204
    if (tmp___0 < buffer_high) {
#line 204
      tmp___1 = channel_not_very_much_buffered_data();
#line 204
      if (tmp___1) {
#line 206
        __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
#line 211
    tmp___2 = packet_not_very_much_data_to_write();
#line 211
    if (tmp___2) {
#line 212
      if (! fdout_eof) {
#line 213
        __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->__fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
#line 214
      if (! fderr_eof) {
#line 215
        __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->__fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
#line 221
    if (fdin != -1) {
#line 221
      tmp___3 = buffer_len(& stdin_buffer);
#line 221
      if (tmp___3 > 0U) {
#line 222
        __asm__  volatile   ("btsl %1,%0": "=m" ((*writesetp)->__fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
  }
#line 229
  tmp___4 = packet_have_data_to_write();
#line 229
  if (tmp___4) {
#line 230
    __asm__  volatile   ("btsl %1,%0": "=m" ((*writesetp)->__fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 236
  if (child_terminated) {
#line 236
    tmp___5 = packet_not_very_much_data_to_write();
#line 236
    if (tmp___5) {
#line 237
      if (max_time_milliseconds == 0U) {
#line 238
        max_time_milliseconds = 100U;
      }
    }
  }
#line 240
  if (max_time_milliseconds == 0U) {
#line 241
    tvp = (struct timeval *)((void *)0);
  } else {
#line 243
    tv.tv_sec = (long )(max_time_milliseconds / 1000U);
#line 244
    tv.tv_usec = (long )(1000U * (max_time_milliseconds % 1000U));
#line 245
    tvp = & tv;
  }
#line 247
  if ((unsigned int )tvp != (unsigned int )((void *)0)) {
#line 248
    debug2("tvp!=NULL kid %d mili %d", child_terminated, max_time_milliseconds);
  }
#line 251
  ret = select(*maxfdp + 1, (fd_set * __restrict  )*readsetp, (fd_set * __restrict  )*writesetp,
               (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )tvp);
#line 253
  if (ret < 0) {
#line 254
    tmp___8 = __errno_location();
#line 254
    if (*tmp___8 != 4) {
#line 255
      tmp___6 = __errno_location();
#line 255
      tmp___7 = strerror(*tmp___6);
#line 255
      error("select: %.100s", tmp___7);
    } else {
      goto retry_select;
    }
  }
#line 259
  return;
}
}
#line 265 "serverloop.c"
void process_input(fd_set *readset ) 
{ int len ;
  char buf___2[16384] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  register char __result ;
  int *tmp___3 ;
  int *tmp___4 ;
  register char __result___0 ;
  int *tmp___5 ;
  int *tmp___6 ;
  register char __result___1 ;

  {
#line 272
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 272
  if (__result) {
#line 273
    len = read(connection_in___0, (void *)(buf___2), sizeof(buf___2));
#line 274
    if (len == 0) {
#line 275
      verbose("Connection closed by remote host.");
#line 276
      fatal_cleanup();
    } else {
#line 277
      if (len < 0) {
#line 278
        tmp___1 = __errno_location();
#line 278
        if (*tmp___1 != 4) {
#line 278
          tmp___2 = __errno_location();
#line 278
          if (*tmp___2 != 11) {
#line 279
            tmp = __errno_location();
#line 279
            tmp___0 = strerror(*tmp);
#line 279
            verbose("Read error from remote host: %.100s", tmp___0);
#line 280
            fatal_cleanup();
          }
        }
      } else {
#line 284
        packet_process_incoming((char const   *)(buf___2), (unsigned int )len);
      }
    }
  }
#line 287
  if (compat20) {
#line 288
    return;
  }
#line 291
  if (! fdout_eof) {
#line 291
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "cc");
#line 291
    if (__result___0) {
#line 292
      len = read(fdout, (void *)(buf___2), sizeof(buf___2));
#line 293
      if (len < 0) {
#line 293
        tmp___3 = __errno_location();
#line 293
        if (! (*tmp___3 == 4)) {
#line 293
          tmp___4 = __errno_location();
#line 293
          if (! (*tmp___4 == 11)) {
            goto _L;
          }
        }
      } else {
        _L: /* CIL Label */ 
#line 295
        if (len <= 0) {
#line 296
          fdout_eof = 1;
        } else {
#line 298
          buffer_append(& stdout_buffer, (char const   *)(buf___2), (unsigned int )len);
#line 299
          fdout_bytes += (long )len;
        }
      }
    }
  }
#line 303
  if (! fderr_eof) {
#line 303
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___1): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "cc");
#line 303
    if (__result___1) {
#line 304
      len = read(fderr, (void *)(buf___2), sizeof(buf___2));
#line 305
      if (len < 0) {
#line 305
        tmp___5 = __errno_location();
#line 305
        if (! (*tmp___5 == 4)) {
#line 305
          tmp___6 = __errno_location();
#line 305
          if (! (*tmp___6 == 11)) {
            goto _L___0;
          }
        }
      } else {
        _L___0: /* CIL Label */ 
#line 307
        if (len <= 0) {
#line 308
          fderr_eof = 1;
        } else {
#line 310
          buffer_append(& stderr_buffer, (char const   *)(buf___2), (unsigned int )len);
        }
      }
    }
  }
#line 313
  return;
}
}
#line 318 "serverloop.c"
void process_output(fd_set *writeset ) 
{ struct termios tio ;
  int len ;
  u_int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  register char __result ;
  register char __result___0 ;

  {
#line 325
  if (! compat20) {
#line 325
    if (fdin != -1) {
#line 325
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))),
                           "m" (writeset->__fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "cc");
#line 325
      if (__result) {
#line 326
        tmp = buffer_len(& stdin_buffer);
#line 326
        tmp___0 = buffer_ptr(& stdin_buffer);
#line 326
        len = write(fdin, (void const   *)tmp___0, tmp);
#line 328
        if (len < 0) {
#line 328
          tmp___4 = __errno_location();
#line 328
          if (! (*tmp___4 == 4)) {
#line 328
            tmp___5 = __errno_location();
#line 328
            if (! (*tmp___5 == 11)) {
              goto _L;
            }
          }
        } else {
          _L: /* CIL Label */ 
#line 330
          if (len <= 0) {
#line 334
            if (fdin != fdout) {
#line 335
              close(fdin);
            } else {
#line 337
              shutdown(fdin, 1);
            }
#line 339
            fdin = -1;
          } else {
#line 342
            if (fdin_is_tty) {
#line 342
              tmp___3 = tcgetattr(fdin, & tio);
#line 342
              if (tmp___3 == 0) {
#line 342
                if (! (tio.c_lflag & 8U)) {
#line 342
                  if (tio.c_lflag & 2U) {
#line 348
                    packet_start(32);
#line 349
                    tmp___1 = buffer_ptr(& stdin_buffer);
#line 349
                    memset((void *)tmp___1, 0, (unsigned int )len);
#line 350
                    tmp___2 = buffer_ptr(& stdin_buffer);
#line 350
                    packet_put_string((char const   *)tmp___2, (unsigned int )len);
#line 351
                    packet_send();
                  }
                }
              }
            }
#line 354
            buffer_consume(& stdin_buffer, (unsigned int )len);
#line 356
            stdin_bytes += (long )len;
          }
        }
      }
    }
  }
#line 360
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->__fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 360
  if (__result___0) {
#line 361
    packet_write_poll();
  }
#line 362
  return;
}
}
#line 368 "serverloop.c"
void drain_output(void) 
{ u_int tmp ;
  char *tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  char *tmp___4 ;
  u_int tmp___5 ;
  u_int tmp___6 ;

  {
#line 372
  tmp___2 = buffer_len(& stdout_buffer);
#line 372
  if (tmp___2 > 0U) {
#line 373
    packet_start(17);
#line 374
    tmp = buffer_len(& stdout_buffer);
#line 374
    tmp___0 = buffer_ptr(& stdout_buffer);
#line 374
    packet_put_string((char const   *)tmp___0, tmp);
#line 376
    packet_send();
#line 378
    tmp___1 = buffer_len(& stdout_buffer);
#line 378
    stdout_bytes = (long )((unsigned long )stdout_bytes + (unsigned long )tmp___1);
  }
#line 381
  tmp___6 = buffer_len(& stderr_buffer);
#line 381
  if (tmp___6 > 0U) {
#line 382
    packet_start(18);
#line 383
    tmp___3 = buffer_len(& stderr_buffer);
#line 383
    tmp___4 = buffer_ptr(& stderr_buffer);
#line 383
    packet_put_string((char const   *)tmp___4, tmp___3);
#line 385
    packet_send();
#line 387
    tmp___5 = buffer_len(& stderr_buffer);
#line 387
    stderr_bytes = (long )((unsigned long )stderr_bytes + (unsigned long )tmp___5);
  }
#line 390
  packet_write_wait();
#line 391
  return;
}
}
#line 393 "serverloop.c"
void process_buffered_input_packets(void) 
{ 

  {
#line 396
  dispatch_run(1, (int *)((void *)0), (void *)0);
#line 397
  return;
}
}
#line 406 "serverloop.c"
void server_loop(pid_t pid , int fdin_arg , int fdout_arg , int fderr_arg ) 
{ fd_set *readset ;
  fd_set *writeset ;
  int max_fd ;
  int wait_status ;
  pid_t wait_pid ;
  int waiting_termination ;
  u_int max_time_milliseconds ;
  u_int previous_stdout_buffer_bytes ;
  u_int stdout_buffer_bytes ;
  int type ;
  int tmp ;
  int tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *s ;
  char *cp ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  u_int tmp___7 ;
  u_int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  union __anonunion_72 __constr_expr_0 ;
  union __anonunion_73 __constr_expr_1 ;
  int plen ;
  union __anonunion_74 __constr_expr_2 ;
  union __anonunion_75 __constr_expr_3 ;
  union __anonunion_76 __constr_expr_4 ;

  {
#line 409
  readset = (fd_set *)((void *)0);
#line 409
  writeset = (fd_set *)((void *)0);
#line 413
  waiting_termination = 0;
#line 419
  debug("Entering interactive session.");
#line 422
  child_pid = pid;
#line 423
  child_terminated = (int volatile   )0;
#line 424
  signal(17, & sigchld_handler);
#line 425
  signal(13, (void (*)(int  ))1);
#line 428
  fdin = fdin_arg;
#line 429
  fdout = fdout_arg;
#line 430
  fderr = fderr_arg;
#line 433
  set_nonblock(fdin);
#line 434
  set_nonblock(fdout);
#line 436
  if (fderr != -1) {
#line 437
    set_nonblock(fderr);
  }
#line 439
  if (! (datafellows & 256)) {
#line 439
    tmp = isatty(fdin);
#line 439
    if (tmp) {
#line 440
      fdin_is_tty = 1;
    }
  }
#line 442
  connection_in___0 = packet_get_connection_in();
#line 443
  connection_out___0 = packet_get_connection_out();
#line 445
  previous_stdout_buffer_bytes = 0U;
#line 448
  tmp___0 = packet_is_interactive();
#line 448
  if (tmp___0) {
#line 449
    buffer_high = 4096U;
  } else {
#line 451
    buffer_high = 65536U;
  }
#line 454
  if (fdin > fdout) {
#line 454
    max_fd = fdin;
  } else {
#line 454
    max_fd = fdout;
  }
#line 455
  if (fderr != -1) {
#line 456
    if (max_fd > fderr) {
#line 456
      max_fd = max_fd;
    } else {
#line 456
      max_fd = fderr;
    }
  }
#line 457
  if (max_fd > connection_in___0) {
#line 457
    max_fd = max_fd;
  } else {
#line 457
    max_fd = connection_in___0;
  }
#line 458
  if (max_fd > connection_out___0) {
#line 458
    max_fd = max_fd;
  } else {
#line 458
    max_fd = connection_out___0;
  }
#line 461
  buffer_init(& stdin_buffer);
#line 462
  buffer_init(& stdout_buffer);
#line 463
  buffer_init(& stderr_buffer);
#line 471
  if (fderr == -1) {
#line 472
    fderr_eof = 1;
  }
#line 474
  server_init_dispatch();
#line 477
  while (1) {
#line 480
    process_buffered_input_packets();
#line 486
    if (stdin_eof) {
#line 486
      if (fdin != -1) {
#line 486
        tmp___1 = buffer_len(& stdin_buffer);
#line 486
        if (tmp___1 == 0U) {
#line 490
          if (fdin != fdout) {
#line 491
            close(fdin);
          } else {
#line 493
            shutdown(fdin, 1);
          }
#line 495
          fdin = -1;
        }
      }
    }
#line 498
    make_packets_from_stderr_data();
#line 507
    max_time_milliseconds = 0U;
#line 508
    stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 509
    if (stdout_buffer_bytes != 0U) {
#line 509
      if (stdout_buffer_bytes < 256U) {
#line 509
        if (stdout_buffer_bytes != previous_stdout_buffer_bytes) {
#line 512
          max_time_milliseconds = 10U;
        } else {
#line 515
          make_packets_from_stdout_data();
        }
      } else {
#line 515
        make_packets_from_stdout_data();
      }
    } else {
#line 515
      make_packets_from_stdout_data();
    }
#line 517
    previous_stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 520
    tmp___2 = packet_not_very_much_data_to_write();
#line 520
    if (tmp___2) {
#line 521
      channel_output_poll();
    }
#line 528
    if (fdout_eof) {
#line 528
      if (fderr_eof) {
#line 528
        tmp___6 = packet_have_data_to_write();
#line 528
        if (! tmp___6) {
#line 528
          tmp___7 = buffer_len(& stdout_buffer);
#line 528
          if (tmp___7 == 0U) {
#line 528
            tmp___8 = buffer_len(& stderr_buffer);
#line 528
            if (tmp___8 == 0U) {
#line 530
              tmp___3 = channel_still_open();
#line 530
              if (! tmp___3) {
#line 531
                break;
              }
#line 532
              if (! waiting_termination) {
#line 533
                s = "Waiting for forwarded connections to terminate...\r\n";
#line 535
                waiting_termination = 1;
#line 536
                tmp___4 = strlen(s);
#line 536
                buffer_append(& stderr_buffer, s, tmp___4);
#line 539
                cp = channel_open_message();
#line 540
                tmp___5 = strlen((char const   *)cp);
#line 540
                buffer_append(& stderr_buffer, (char const   *)cp, tmp___5);
#line 541
                xfree((void *)cp);
              }
            }
          }
        }
      }
    }
#line 545
    wait_until_can_do_something(& readset, & writeset, & max_fd, max_time_milliseconds);
#line 549
    channel_after_select(readset, writeset);
#line 552
    process_input(readset);
#line 555
    process_output(writeset);
  }
#line 557
  if (readset) {
#line 558
    xfree((void *)readset);
  }
#line 559
  if (writeset) {
#line 560
    xfree((void *)writeset);
  }
#line 565
  drain_output();
#line 567
  debug("End of interactive session; stdin %ld, stdout (read %ld, sent %ld), stderr %ld bytes.",
        stdin_bytes, fdout_bytes, stdout_bytes, stderr_bytes);
#line 571
  buffer_free(& stdin_buffer);
#line 572
  buffer_free(& stdout_buffer);
#line 573
  buffer_free(& stderr_buffer);
#line 576
  if (fdout != -1) {
#line 577
    close(fdout);
  }
#line 578
  fdout = -1;
#line 579
  fdout_eof = 1;
#line 580
  if (fderr != -1) {
#line 581
    close(fderr);
  }
#line 582
  fderr = -1;
#line 583
  fderr_eof = 1;
#line 584
  if (fdin != -1) {
#line 585
    close(fdin);
  }
#line 586
  fdin = -1;
#line 589
  channel_stop_listening();
#line 592
  wait_pid = wait((union wait *)(& wait_status));
#line 593
  if (wait_pid == -1) {
#line 599
    if (child_terminated) {
#line 600
      wait_status = (int )child_wait_status;
    } else {
#line 602
      tmp___9 = __errno_location();
#line 602
      tmp___10 = strerror(*tmp___9);
#line 602
      packet_disconnect("wait: %.100s", tmp___10);
    }
  } else {
#line 605
    if (wait_pid != pid) {
#line 606
      error("Strange, wait returned pid %d, expected %d", wait_pid, pid);
    }
  }
#line 611
  signal(17, (void (*)(int  ))0);
#line 614
  __constr_expr_2.__in = wait_status;
#line 614
  if ((__constr_expr_2.__i & 127) == 0) {
#line 616
    __constr_expr_0.__in = wait_status;
#line 616
    debug("Command exited with status %d.", (__constr_expr_0.__i & 65280) >> 8);
#line 617
    packet_start(20);
#line 618
    __constr_expr_1.__in = wait_status;
#line 618
    packet_put_int((unsigned int )((__constr_expr_1.__i & 65280) >> 8));
#line 619
    packet_send();
#line 620
    packet_write_wait();
#line 629
    while (1) {
#line 631
      type = packet_read(& plen);
#line 629
      if (! (type != 33)) {
#line 629
        break;
      }
    }
#line 635
    debug("Received exit confirmation.");
#line 636
    return;
  }
#line 639
  __constr_expr_4.__in = wait_status;
#line 639
  if ((int )((signed char )((__constr_expr_4.__i & 127) + 1)) >> 1 > 0) {
#line 640
    __constr_expr_3.__in = wait_status;
#line 640
    packet_disconnect("Command terminated on signal %d.", __constr_expr_3.__i & 127);
  }
#line 644
  packet_disconnect("wait returned status %04x.", wait_status);
#line 646
  return;
}
}
#line 648 "serverloop.c"
void server_loop2(void) 
{ fd_set *readset ;
  fd_set *writeset ;
  int max_fd ;
  int had_channel ;
  int status ;
  pid_t pid ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 651
  readset = (fd_set *)((void *)0);
#line 651
  writeset = (fd_set *)((void *)0);
#line 653
  had_channel = 0;
#line 657
  debug("Entering interactive session for SSH2.");
#line 659
  mysignal(17, & sigchld_handler2);
#line 660
  signal(13, (void (*)(int  ))1);
#line 661
  child_terminated = (int volatile   )0;
#line 662
  connection_in___0 = packet_get_connection_in();
#line 663
  connection_out___0 = packet_get_connection_out();
#line 665
  if (connection_in___0 > connection_out___0) {
#line 665
    max_fd = connection_in___0;
  } else {
#line 665
    max_fd = connection_out___0;
  }
#line 667
  server_init_dispatch();
#line 669
  while (1) {
#line 670
    process_buffered_input_packets();
#line 671
    if (! had_channel) {
#line 671
      tmp = channel_still_open();
#line 671
      if (tmp) {
#line 672
        had_channel = 1;
      }
    }
#line 673
    if (had_channel) {
#line 673
      tmp___0 = channel_still_open();
#line 673
      if (! tmp___0) {
#line 674
        debug("!channel_still_open.");
#line 675
        break;
      }
    }
#line 677
    tmp___1 = packet_not_very_much_data_to_write();
#line 677
    if (tmp___1) {
#line 678
      channel_output_poll();
    }
#line 679
    wait_until_can_do_something(& readset, & writeset, & max_fd, 0U);
#line 680
    if (child_terminated) {
#line 681
      while (1) {
#line 681
        pid = waitpid(-1, & status, 1);
#line 681
        if (! (pid > 0)) {
#line 681
          break;
        }
#line 682
        session_close_by_pid(pid, status);
      }
#line 683
      child_terminated = (int volatile   )0;
    }
#line 685
    channel_after_select(readset, writeset);
#line 686
    process_input(readset);
#line 687
    process_output(writeset);
  }
#line 689
  if (readset) {
#line 690
    xfree((void *)readset);
  }
#line 691
  if (writeset) {
#line 692
    xfree((void *)writeset);
  }
#line 694
  signal(17, (void (*)(int  ))0);
#line 695
  while (1) {
#line 695
    pid = waitpid(-1, & status, 1);
#line 695
    if (! (pid > 0)) {
#line 695
      break;
    }
#line 696
    session_close_by_pid(pid, status);
  }
#line 697
  channel_stop_listening();
#line 698
  return;
}
}
#line 700 "serverloop.c"
void server_input_stdin_data(int type , int plen , void *ctxt ) 
{ char *data ;
  u_int data_len ;
  int _p ;
  int _e ;

  {
#line 708
  if (fdin == -1) {
#line 709
    return;
  }
#line 710
  data = packet_get_string(& data_len);
#line 711
  while (1) {
#line 711
    _p = plen;
#line 711
    _e = (int )(4U + data_len);
#line 711
    if (_p != _e) {
#line 711
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "serverloop.c", 711);
#line 711
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 711
    break;
  }
#line 712
  buffer_append(& stdin_buffer, (char const   *)data, data_len);
#line 713
  memset((void *)data, 0, data_len);
#line 714
  xfree((void *)data);
#line 715
  return;
}
}
#line 717 "serverloop.c"
void server_input_eof(int type , int plen , void *ctxt ) 
{ int _p ;
  int _e ;

  {
#line 725
  debug("EOF received for stdin.");
#line 726
  while (1) {
#line 726
    _p = plen;
#line 726
    _e = 0;
#line 726
    if (_p != _e) {
#line 726
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "serverloop.c", 726);
#line 726
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 726
    break;
  }
#line 727
  stdin_eof = 1;
#line 728
  return;
}
}
#line 730 "serverloop.c"
void server_input_window_size(int type , int plen , void *ctxt ) 
{ int row ;
  u_int tmp ;
  int col ;
  u_int tmp___0 ;
  int xpixel ;
  u_int tmp___1 ;
  int ypixel ;
  u_int tmp___2 ;
  int _p ;
  int _e ;

  {
#line 733
  tmp = packet_get_int();
#line 733
  row = (int )tmp;
#line 734
  tmp___0 = packet_get_int();
#line 734
  col = (int )tmp___0;
#line 735
  tmp___1 = packet_get_int();
#line 735
  xpixel = (int )tmp___1;
#line 736
  tmp___2 = packet_get_int();
#line 736
  ypixel = (int )tmp___2;
#line 738
  debug("Window change received.");
#line 739
  while (1) {
#line 739
    _p = plen;
#line 739
    _e = 16;
#line 739
    if (_p != _e) {
#line 739
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "serverloop.c", 739);
#line 739
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 739
    break;
  }
#line 740
  if (fdin != -1) {
#line 741
    pty_change_window_size(fdin, row, col, xpixel, ypixel);
  }
#line 742
  return;
}
}
#line 744 "serverloop.c"
Channel *server_request_direct_tcpip(char *ctype ) 
{ int sock ;
  int newch ;
  char *target ;
  char *originator ;
  int target_port ;
  int originator_port ;
  u_int tmp ;
  u_int tmp___0 ;
  int _len ;
  int tmp___1 ;
  char *tmp___2 ;
  Channel *tmp___4 ;

  {
#line 751
  target = packet_get_string((u_int *)((void *)0));
#line 752
  tmp = packet_get_int();
#line 752
  target_port = (int )tmp;
#line 753
  originator = packet_get_string((u_int *)((void *)0));
#line 754
  tmp___0 = packet_get_int();
#line 754
  originator_port = (int )tmp___0;
#line 755
  while (1) {
#line 755
    tmp___1 = packet_remaining();
#line 755
    _len = tmp___1;
#line 755
    if (_len > 0) {
#line 755
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
          755);
#line 755
      packet_disconnect("Packet integrity error.");
    }
#line 755
    break;
  }
#line 757
  debug("server_request_direct_tcpip: originator %s port %d, target %s port %d", originator,
        originator_port, target, target_port);
#line 761
  if (no_port_forwarding_flag) {
#line 762
    xfree((void *)target);
#line 763
    xfree((void *)originator);
#line 764
    return ((Channel *)((void *)0));
  } else {
#line 761
    if (! options.allow_tcp_forwarding) {
#line 762
      xfree((void *)target);
#line 763
      xfree((void *)originator);
#line 764
      return ((Channel *)((void *)0));
    }
  }
#line 766
  sock = channel_connect_to((char const   *)target, (unsigned short )target_port);
#line 767
  xfree((void *)target);
#line 768
  xfree((void *)originator);
#line 769
  if (sock < 0) {
#line 770
    return ((Channel *)((void *)0));
  }
#line 771
  tmp___2 = xstrdup("direct-tcpip");
#line 771
  newch = channel_new(ctype, 12, sock, sock, -1, 32768, 16384, 0, tmp___2, 1);
#line 774
  if (newch >= 0) {
#line 774
    tmp___4 = channel_lookup(newch);
  } else {
#line 774
    tmp___4 = (Channel *)((void *)0);
  }
#line 774
  return (tmp___4);
}
}
#line 777 "serverloop.c"
Channel *server_request_session(char *ctype ) 
{ int newch ;
  int _len ;
  int tmp ;
  char *tmp___0 ;
  Channel *tmp___1 ;
  int tmp___2 ;

  {
#line 782
  debug("input_session_request");
#line 783
  while (1) {
#line 783
    tmp = packet_remaining();
#line 783
    _len = tmp;
#line 783
    if (_len > 0) {
#line 783
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
          783);
#line 783
      packet_disconnect("Packet integrity error.");
    }
#line 783
    break;
  }
#line 790
  tmp___0 = xstrdup("server-session");
#line 790
  newch = channel_new(ctype, 10, -1, -1, -1, 0, 16384, 0, tmp___0, 1);
#line 793
  tmp___2 = session_open(newch);
#line 793
  if (tmp___2 == 1) {
#line 794
    channel_register_callback(newch, 98, & session_input_channel_req, (void *)0);
#line 796
    channel_register_cleanup(newch, & session_close_by_channel);
#line 797
    tmp___1 = channel_lookup(newch);
#line 797
    return (tmp___1);
  } else {
#line 799
    debug("session open failed, free channel %d", newch);
#line 800
    channel_free(newch);
  }
#line 802
  return ((Channel *)((void *)0));
}
}
#line 805 "serverloop.c"
void server_input_channel_open(int type , int plen , void *ctxt ) 
{ Channel *c ;
  char *ctype ;
  u_int len ;
  int rchan ;
  int rmaxpack ;
  int rwindow ;
  u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___17 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 808
  c = (Channel *)((void *)0);
#line 815
  ctype = packet_get_string(& len);
#line 816
  tmp = packet_get_int();
#line 816
  rchan = (int )tmp;
#line 817
  tmp___0 = packet_get_int();
#line 817
  rwindow = (int )tmp___0;
#line 818
  tmp___1 = packet_get_int();
#line 818
  rmaxpack = (int )tmp___1;
#line 820
  debug("server_input_channel_open: ctype %s rchan %d win %d max %d", ctype, rchan,
        rwindow, rmaxpack);
#line 823
  if (0) {
#line 823
    __s1_len___0 = strlen((char const   *)ctype);
#line 823
    __s2_len___0 = strlen("session");
#line 823
    if (! ((unsigned int )((void const   *)(ctype + 1)) - (unsigned int )((void const   *)ctype) == 1U)) {
      goto _L___2;
    } else {
#line 823
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 823
        if (! ((unsigned int )((void const   *)("session" + 1)) - (unsigned int )((void const   *)"session") == 1U)) {
#line 823
          tmp___21 = 1;
        } else {
#line 823
          if (__s2_len___0 >= 4U) {
#line 823
            tmp___21 = 1;
          } else {
#line 823
            tmp___21 = 0;
          }
        }
      } else {
#line 823
        tmp___21 = 0;
      }
    }
#line 823
    if (tmp___21) {
#line 823
      tmp___17 = __builtin_strcmp((char const   *)ctype, "session");
    } else {
#line 823
      tmp___20 = __builtin_strcmp((char const   *)ctype, "session");
#line 823
      tmp___17 = tmp___20;
    }
  } else {
#line 823
    tmp___20 = __builtin_strcmp((char const   *)ctype, "session");
#line 823
    tmp___17 = tmp___20;
  }
#line 823
  if (tmp___17 == 0) {
#line 824
    c = server_request_session(ctype);
  } else {
#line 825
    if (0) {
#line 825
      __s1_len = strlen((char const   *)ctype);
#line 825
      __s2_len = strlen("direct-tcpip");
#line 825
      if (! ((unsigned int )((void const   *)(ctype + 1)) - (unsigned int )((void const   *)ctype) == 1U)) {
        goto _L___0;
      } else {
#line 825
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 825
          if (! ((unsigned int )((void const   *)("direct-tcpip" + 1)) - (unsigned int )((void const   *)"direct-tcpip") == 1U)) {
#line 825
            tmp___11 = 1;
          } else {
#line 825
            if (__s2_len >= 4U) {
#line 825
              tmp___11 = 1;
            } else {
#line 825
              tmp___11 = 0;
            }
          }
        } else {
#line 825
          tmp___11 = 0;
        }
      }
#line 825
      if (tmp___11) {
#line 825
        tmp___7 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
      } else {
#line 825
        tmp___10 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
#line 825
        tmp___7 = tmp___10;
      }
    } else {
#line 825
      tmp___10 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
#line 825
      tmp___7 = tmp___10;
    }
#line 825
    if (tmp___7 == 0) {
#line 826
      c = server_request_direct_tcpip(ctype);
    }
  }
#line 828
  if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 829
    debug("server_input_channel_open: confirm %s", ctype);
#line 830
    c->remote_id = rchan;
#line 831
    c->remote_window = rwindow;
#line 832
    c->remote_maxpacket = rmaxpack;
#line 834
    packet_start(91);
#line 835
    packet_put_int((unsigned int )c->remote_id);
#line 836
    packet_put_int((unsigned int )c->self);
#line 837
    packet_put_int((unsigned int )c->local_window);
#line 838
    packet_put_int((unsigned int )c->local_maxpacket);
#line 839
    packet_send();
  } else {
#line 841
    debug("server_input_channel_open: failure %s", ctype);
#line 842
    packet_start(92);
#line 843
    packet_put_int((unsigned int )rchan);
#line 844
    packet_put_int(1U);
#line 845
    packet_put_cstring("bla bla");
#line 846
    packet_put_cstring("");
#line 847
    packet_send();
  }
#line 849
  xfree((void *)ctype);
#line 850
  return;
}
}
#line 852 "serverloop.c"
void server_input_global_request(int type , int plen , void *ctxt ) 
{ char *rtype ;
  int want_reply ;
  int success ;
  u_int tmp ;
  struct passwd *pw ;
  char *listen_address ;
  u_short listen_port ;
  u_int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 857
  success = 0;
#line 859
  rtype = packet_get_string((u_int *)((void *)0));
#line 860
  tmp = packet_get_char();
#line 860
  want_reply = (int )tmp;
#line 861
  debug("server_input_global_request: rtype %s want_reply %d", rtype, want_reply);
#line 863
  if (0) {
#line 863
    __s1_len = strlen((char const   *)rtype);
#line 863
    __s2_len = strlen("tcpip-forward");
#line 863
    if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
      goto _L___0;
    } else {
#line 863
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 863
        if (! ((unsigned int )((void const   *)("tcpip-forward" + 1)) - (unsigned int )((void const   *)"tcpip-forward") == 1U)) {
#line 863
          tmp___10 = 1;
        } else {
#line 863
          if (__s2_len >= 4U) {
#line 863
            tmp___10 = 1;
          } else {
#line 863
            tmp___10 = 0;
          }
        }
      } else {
#line 863
        tmp___10 = 0;
      }
    }
#line 863
    if (tmp___10) {
#line 863
      tmp___6 = __builtin_strcmp((char const   *)rtype, "tcpip-forward");
    } else {
#line 863
      tmp___9 = __builtin_strcmp((char const   *)rtype, "tcpip-forward");
#line 863
      tmp___6 = tmp___9;
    }
  } else {
#line 863
    tmp___9 = __builtin_strcmp((char const   *)rtype, "tcpip-forward");
#line 863
    tmp___6 = tmp___9;
  }
#line 863
  if (tmp___6 == 0) {
#line 868
    pw = auth_get_user();
#line 869
    if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 870
      fatal("server_input_global_request: no user");
    }
#line 871
    listen_address = packet_get_string((u_int *)((void *)0));
#line 872
    tmp___0 = packet_get_int();
#line 872
    listen_port = (unsigned short )tmp___0;
#line 873
    debug("server_input_global_request: tcpip-forward listen %s port %d", listen_address,
          listen_port);
#line 877
    if (! options.allow_tcp_forwarding) {
#line 880
      success = 0;
#line 881
      packet_send_debug("Server has disabled port forwarding.");
    } else {
#line 877
      if (no_port_forwarding_flag) {
#line 880
        success = 0;
#line 881
        packet_send_debug("Server has disabled port forwarding.");
      } else {
#line 877
        if ((int )listen_port < 1024) {
#line 877
          if (pw->pw_uid != 0U) {
#line 880
            success = 0;
#line 881
            packet_send_debug("Server has disabled port forwarding.");
          } else {
#line 884
            success = channel_request_forwarding((char const   *)listen_address, listen_port,
                                                 "<unspec host>", (unsigned short)0,
                                                 options.gateway_ports, 1);
          }
        } else {
#line 884
          success = channel_request_forwarding((char const   *)listen_address, listen_port,
                                               "<unspec host>", (unsigned short)0,
                                               options.gateway_ports, 1);
        }
      }
    }
#line 890
    xfree((void *)listen_address);
  }
#line 892
  if (want_reply) {
#line 893
    if (success) {
#line 893
      tmp___11 = 81;
    } else {
#line 893
      tmp___11 = 82;
    }
#line 893
    packet_start(tmp___11);
#line 895
    packet_send();
#line 896
    packet_write_wait();
  }
#line 898
  xfree((void *)rtype);
#line 899
  return;
}
}
#line 901 "serverloop.c"
void server_init_dispatch_20(void) 
{ 

  {
#line 904
  debug("server_init_dispatch_20");
#line 905
  dispatch_init(& dispatch_protocol_error);
#line 906
  dispatch_set(97, & channel_input_oclose);
#line 907
  dispatch_set(94, & channel_input_data);
#line 908
  dispatch_set(96, & channel_input_ieof);
#line 909
  dispatch_set(95, & channel_input_extended_data);
#line 910
  dispatch_set(90, & server_input_channel_open);
#line 911
  dispatch_set(91, & channel_input_open_confirmation);
#line 912
  dispatch_set(92, & channel_input_open_failure);
#line 913
  dispatch_set(98, & channel_input_channel_request);
#line 914
  dispatch_set(93, & channel_input_window_adjust);
#line 915
  dispatch_set(80, & server_input_global_request);
#line 916
  return;
}
}
#line 917 "serverloop.c"
void server_init_dispatch_13(void) 
{ 

  {
#line 920
  debug("server_init_dispatch_13");
#line 921
  dispatch_init((dispatch_fn *)((void *)0));
#line 922
  dispatch_set(19, & server_input_eof);
#line 923
  dispatch_set(16, & server_input_stdin_data);
#line 924
  dispatch_set(11, & server_input_window_size);
#line 925
  dispatch_set(24, & channel_input_close);
#line 926
  dispatch_set(25, & channel_input_close_confirmation);
#line 927
  dispatch_set(23, & channel_input_data);
#line 928
  dispatch_set(21, & channel_input_open_confirmation);
#line 929
  dispatch_set(22, & channel_input_open_failure);
#line 930
  dispatch_set(29, & channel_input_port_open);
#line 931
  return;
}
}
#line 932 "serverloop.c"
void server_init_dispatch_15(void) 
{ 

  {
#line 935
  server_init_dispatch_13();
#line 936
  debug("server_init_dispatch_15");
#line 937
  dispatch_set(24, & channel_input_ieof);
#line 938
  dispatch_set(25, & channel_input_oclose);
#line 939
  return;
}
}
#line 940 "serverloop.c"
void server_init_dispatch(void) 
{ 

  {
#line 943
  if (compat20) {
#line 944
    server_init_dispatch_20();
  } else {
#line 945
    if (compat13) {
#line 946
      server_init_dispatch_13();
    } else {
#line 948
      server_init_dispatch_15();
    }
  }
#line 949
  return;
}
}
#line 1 "md5crypt.o"
#pragma merger(0,"./md5crypt.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "session.o"
#pragma merger(0,"./session.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 106 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socketpair(int __domain , int __type , int __protocol ,
                                                    int *__fds ) ;
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 493 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 504
extern  __attribute__((__nothrow__)) int execve(char const   *__path , char * const  *__argv ,
                                                char * const  *__envp )  __attribute__((__nonnull__(1))) ;
#line 526
extern  __attribute__((__nothrow__)) int execl(char const   *__path , char const   *__arg 
                                               , ...)  __attribute__((__nonnull__(1))) ;
#line 684
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 142 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 333
extern int printf(char const   * __restrict  __format  , ...) ;
#line 590
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 774
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 780
extern int pclose(FILE *__stream ) ;
#line 79 "/usr/include/pwd.h"
extern void endpwent(void) ;
#line 69 "/usr/include/grp.h"
extern void endgrent(void) ;
#line 199
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 257 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 119 "session.c"
Session *session_new(void) ;
#line 120
void session_set_fds(Session *s , int fdin___0 , int fdout___0 , int fderr___0 ) ;
#line 121
void session_pty_cleanup(Session *s ) ;
#line 122
void session_proctitle(Session *s ) ;
#line 123
void do_exec_pty(Session *s , char const   *command , struct passwd *pw ) ;
#line 124
void do_exec_no_pty(Session *s , char const   *command , struct passwd *pw ) ;
#line 125
void do_login(Session *s , char const   *command ) ;
#line 127
void do_child(char const   *command , struct passwd *pw , char const   *term , char const   *display ,
              char const   *auth_proto , char const   *auth_data , char const   *ttyname___0 ) ;
#line 142 "session.c"
static char *xauthfile  ;
#line 145 "session.c"
char *original_command  =    (char *)((void *)0);
#line 149 "session.c"
Session sessions[10]  ;
#line 163 "session.c"
void xauthfile_cleanup_proc(void *ignore ) 
{ char *p ;

  {
#line 166
  debug("xauthfile_cleanup_proc called");
#line 168
  if ((unsigned int )xauthfile != (unsigned int )((void *)0)) {
#line 170
    unlink((char const   *)xauthfile);
#line 171
    p = strrchr((char const   *)xauthfile, '/');
#line 172
    if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 173
      *p = (char )'\000';
#line 174
      rmdir((char const   *)xauthfile);
    }
#line 176
    xfree((void *)xauthfile);
#line 177
    xauthfile = (char *)((void *)0);
  }
#line 179
  return;
}
}
#line 185 "session.c"
void pty_cleanup_proc(void *session ) 
{ Session *s ;

  {
#line 188
  s = (Session *)session;
#line 189
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 190
    fatal("pty_cleanup_proc: no session");
  }
#line 191
  debug("pty_cleanup_proc: %s", s->tty);
#line 193
  if (s->pid != 0) {
#line 195
    record_logout(s->pid, (char const   *)(s->tty));
  }
#line 199
  pty_release((char const   *)(s->tty));
#line 200
  return;
}
}
#line 208 "session.c"
void do_authenticated(struct passwd *pw ) 
{ Session *s ;
  int type ;
  int fd ;
  int compression_level ;
  int enable_compression_after_reply ;
  int have_pty ;
  char *command ;
  int n_bytes ;
  int plen ;
  u_int proto_len ;
  u_int data_len ;
  u_int dlen ;
  int screen_flag ;
  int success ;
  int _p ;
  int _e ;
  u_int tmp ;
  int tmp___0 ;
  int _p___0 ;
  int _e___0 ;
  size_t tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  u_int tmp___12 ;
  u_int tmp___13 ;
  u_int tmp___14 ;
  u_int tmp___15 ;
  int _p___1 ;
  int _e___1 ;
  u_int tmp___16 ;
  int _p___2 ;
  int _e___2 ;
  u_int tmp___17 ;
  int _p___3 ;
  int _e___3 ;
  int tmp___18 ;
  void *tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  u_int tmp___23 ;
  int tmp___24 ;
  int _p___4 ;
  int _e___4 ;
  int _p___5 ;
  int _e___5 ;
  int tmp___25 ;

  {
#line 213
  compression_level = 0;
#line 213
  enable_compression_after_reply = 0;
#line 214
  have_pty = 0;
#line 225
  alarm(0U);
#line 226
  if (startup_pipe != -1) {
#line 227
    close(startup_pipe);
#line 228
    startup_pipe = -1;
  }
#line 238
  if (! no_port_forwarding_flag) {
#line 238
    if (options.allow_tcp_forwarding) {
#line 239
      channel_permit_all_opens();
    }
  }
#line 241
  s = session_new();
#line 242
  s->pw = pw;
#line 255
  while (1) {
#line 256
    success = 0;
#line 259
    type = packet_read(& plen);
#line 262
    switch (type) {
    case 37: 
#line 264
    while (1) {
#line 264
      _p = plen;
#line 264
      _e = 4;
#line 264
      if (_p != _e) {
#line 264
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "session.c", 264);
#line 264
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 264
      break;
    }
#line 265
    tmp = packet_get_int();
#line 265
    compression_level = (int )tmp;
#line 266
    if (compression_level < 1) {
#line 267
      packet_send_debug("Received illegal compression level %d.", compression_level);
#line 269
      break;
    } else {
#line 266
      if (compression_level > 9) {
#line 267
        packet_send_debug("Received illegal compression level %d.", compression_level);
#line 269
        break;
      }
    }
#line 272
    enable_compression_after_reply = 1;
#line 273
    success = 1;
#line 274
    break;
    case 10: 
#line 277
    if (no_pty_flag) {
#line 278
      debug("Allocating a pty not permitted for this authentication.");
#line 279
      break;
    }
#line 281
    if (have_pty) {
#line 282
      packet_disconnect("Protocol error: you already have a pty.");
    }
#line 284
    debug("Allocating pty.");
#line 287
    tmp___0 = pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, (int )sizeof(s->tty));
#line 287
    if (! tmp___0) {
#line 289
      error("Failed to allocate pty.");
#line 290
      break;
    }
#line 292
    fatal_add_cleanup(& pty_cleanup_proc, (void *)s);
#line 293
    pty_setowner(pw, (char const   *)(s->tty));
#line 296
    s->term = packet_get_string(& dlen);
#line 297
    while (1) {
#line 297
      _p___0 = (int )dlen;
#line 297
      tmp___1 = strlen((char const   *)s->term);
#line 297
      _e___0 = (int )tmp___1;
#line 297
      if (_p___0 != _e___0) {
#line 297
        log("Packet integrity error (%d != %d) at %s:%d", _p___0, _e___0, "session.c",
            297);
#line 297
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 297
      break;
    }
#line 300
    n_bytes = (int )((u_int )plen - ((4U + dlen) + 16U));
#line 302
    if (0) {
#line 302
      __s1_len = strlen((char const   *)s->term);
#line 302
      __s2_len = strlen("");
#line 302
      if (! ((unsigned int )((void const   *)(s->term + 1)) - (unsigned int )((void const   *)s->term) == 1U)) {
        goto _L___0;
      } else {
#line 302
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 302
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 302
            tmp___11 = 1;
          } else {
#line 302
            if (__s2_len >= 4U) {
#line 302
              tmp___11 = 1;
            } else {
#line 302
              tmp___11 = 0;
            }
          }
        } else {
#line 302
          tmp___11 = 0;
        }
      }
#line 302
      if (tmp___11) {
#line 302
        tmp___7 = __builtin_strcmp((char const   *)s->term, "");
      } else {
#line 302
        tmp___10 = __builtin_strcmp((char const   *)s->term, "");
#line 302
        tmp___7 = tmp___10;
      }
    } else {
#line 302
      tmp___10 = __builtin_strcmp((char const   *)s->term, "");
#line 302
      tmp___7 = tmp___10;
    }
#line 302
    if (tmp___7 == 0) {
#line 303
      xfree((void *)s->term);
#line 304
      s->term = (char *)((void *)0);
    }
#line 307
    tmp___12 = packet_get_int();
#line 307
    s->row = (int )tmp___12;
#line 308
    tmp___13 = packet_get_int();
#line 308
    s->col = (int )tmp___13;
#line 309
    tmp___14 = packet_get_int();
#line 309
    s->xpixel = (int )tmp___14;
#line 310
    tmp___15 = packet_get_int();
#line 310
    s->ypixel = (int )tmp___15;
#line 311
    pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);
#line 314
    tty_parse_modes(s->ttyfd, & n_bytes);
#line 315
    while (1) {
#line 315
      _p___1 = plen;
#line 315
      _e___1 = (int )(((4U + dlen) + 16U) + (u_int )n_bytes);
#line 315
      if (_p___1 != _e___1) {
#line 315
        log("Packet integrity error (%d != %d) at %s:%d", _p___1, _e___1, "session.c",
            315);
#line 315
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 315
      break;
    }
#line 317
    session_proctitle(s);
#line 320
    success = 1;
#line 321
    have_pty = 1;
#line 322
    break;
    case 34: 
#line 325
    if (! options.x11_forwarding) {
#line 326
      packet_send_debug("X11 forwarding disabled in server configuration file.");
#line 327
      break;
    }
#line 329
    if (! options.xauth_location) {
#line 330
      packet_send_debug("No xauth program; cannot forward with spoofing.");
#line 331
      break;
    }
#line 333
    if (no_x11_forwarding_flag) {
#line 334
      packet_send_debug("X11 forwarding not permitted for this authentication.");
#line 335
      break;
    }
#line 337
    debug("Received request for X11 forwarding with auth spoofing.");
#line 338
    if ((unsigned int )s->display != (unsigned int )((void *)0)) {
#line 339
      packet_disconnect("Protocol error: X11 display already set.");
    }
#line 341
    s->auth_proto = packet_get_string(& proto_len);
#line 342
    s->auth_data = packet_get_string(& data_len);
#line 344
    tmp___16 = packet_get_protocol_flags();
#line 344
    screen_flag = (int )(tmp___16 & 1U);
#line 346
    debug2("SSH_PROTOFLAG_SCREEN_NUMBER: %d", screen_flag);
#line 348
    tmp___18 = packet_remaining();
#line 348
    if (tmp___18 == 4) {
#line 349
      if (! screen_flag) {
#line 350
        debug2("Buggy client: X11 screen flag missing");
      }
#line 352
      while (1) {
#line 352
        _p___2 = plen;
#line 352
        _e___2 = (int )((((4U + proto_len) + 4U) + data_len) + 4U);
#line 352
        if (_p___2 != _e___2) {
#line 352
          log("Packet integrity error (%d != %d) at %s:%d", _p___2, _e___2, "session.c",
              353);
#line 352
          packet_disconnect("Packet integrity error. (%d)", type);
        }
#line 352
        break;
      }
#line 354
      tmp___17 = packet_get_int();
#line 354
      s->screen = (int )tmp___17;
    } else {
#line 356
      while (1) {
#line 356
        _p___3 = plen;
#line 356
        _e___3 = (int )(((4U + proto_len) + 4U) + data_len);
#line 356
        if (_p___3 != _e___3) {
#line 356
          log("Packet integrity error (%d != %d) at %s:%d", _p___3, _e___3, "session.c",
              357);
#line 356
          packet_disconnect("Packet integrity error. (%d)", type);
        }
#line 356
        break;
      }
#line 358
      s->screen = 0;
    }
#line 360
    s->display = x11_create_display_inet(s->screen, options.x11_display_offset);
#line 362
    if ((unsigned int )s->display == (unsigned int )((void *)0)) {
#line 363
      break;
    }
#line 366
    tmp___19 = xmalloc(4096U);
#line 366
    xauthfile = (char *)tmp___19;
#line 367
    strlcpy(xauthfile, "/tmp/ssh-XXXXXXXX", 4096U);
#line 368
    temporarily_use_uid(pw->pw_uid);
#line 369
    tmp___22 = mkdtemp(xauthfile);
#line 369
    if ((unsigned int )tmp___22 == (unsigned int )((void *)0)) {
#line 370
      restore_uid();
#line 371
      tmp___20 = __errno_location();
#line 371
      tmp___21 = strerror(*tmp___20);
#line 371
      error("private X11 dir: mkdtemp %s failed: %s", xauthfile, tmp___21);
#line 373
      xfree((void *)xauthfile);
#line 374
      xauthfile = (char *)((void *)0);
#line 376
      break;
    }
#line 378
    strlcat(xauthfile, "/cookies", 4096U);
#line 379
    fd = open((char const   *)xauthfile, 194, 384);
#line 380
    if (fd >= 0) {
#line 381
      close(fd);
    }
#line 382
    restore_uid();
#line 383
    fatal_add_cleanup(& xauthfile_cleanup_proc, (void *)0);
#line 384
    success = 1;
#line 385
    break;
    case 30: 
#line 388
    if (no_agent_forwarding_flag) {
#line 389
      debug("Authentication agent forwarding not permitted for this authentication.");
#line 390
      break;
    } else {
#line 388
      if (compat13) {
#line 389
        debug("Authentication agent forwarding not permitted for this authentication.");
#line 390
        break;
      }
    }
#line 392
    debug("Received authentication agent forwarding request.");
#line 393
    success = auth_input_request_forwarding(pw);
#line 394
    break;
    case 28: 
#line 397
    if (no_port_forwarding_flag) {
#line 398
      debug("Port forwarding not permitted for this authentication.");
#line 399
      break;
    }
#line 401
    if (! options.allow_tcp_forwarding) {
#line 402
      debug("Port forwarding not permitted.");
#line 403
      break;
    }
#line 405
    debug("Received TCP/IP port forwarding request.");
#line 406
    channel_input_port_forward_request(pw->pw_uid == 0U, options.gateway_ports);
#line 407
    success = 1;
#line 408
    break;
    case 38: 
#line 411
    tmp___23 = packet_get_int();
#line 411
    tmp___24 = packet_set_maxsize((int )tmp___23);
#line 411
    if (tmp___24 > 0) {
#line 412
      success = 1;
    }
#line 413
    break;
    case 12: 
    case 13: 
#line 417
    if (type == 13) {
#line 418
      command = packet_get_string(& dlen);
#line 419
      debug("Exec command \'%.500s\'", command);
#line 420
      while (1) {
#line 420
        _p___4 = plen;
#line 420
        _e___4 = (int )(4U + dlen);
#line 420
        if (_p___4 != _e___4) {
#line 420
          log("Packet integrity error (%d != %d) at %s:%d", _p___4, _e___4, "session.c",
              420);
#line 420
          packet_disconnect("Packet integrity error. (%d)", type);
        }
#line 420
        break;
      }
    } else {
#line 422
      command = (char *)((void *)0);
#line 423
      while (1) {
#line 423
        _p___5 = plen;
#line 423
        _e___5 = 0;
#line 423
        if (_p___5 != _e___5) {
#line 423
          log("Packet integrity error (%d != %d) at %s:%d", _p___5, _e___5, "session.c",
              423);
#line 423
          packet_disconnect("Packet integrity error. (%d)", type);
        }
#line 423
        break;
      }
    }
#line 425
    if ((unsigned int )forced_command != (unsigned int )((void *)0)) {
#line 426
      original_command = command;
#line 427
      command = forced_command;
#line 428
      debug("Forced command \'%.500s\'", forced_command);
    }
#line 430
    if (have_pty) {
#line 431
      do_exec_pty(s, (char const   *)command, pw);
    } else {
#line 433
      do_exec_no_pty(s, (char const   *)command, pw);
    }
#line 435
    if ((unsigned int )command != (unsigned int )((void *)0)) {
#line 436
      xfree((void *)command);
    }
#line 438
    if (xauthfile) {
#line 439
      xauthfile_cleanup_proc((void *)0);
    }
#line 440
    return;
    default: 
#line 447
    log("Unknown packet type received after authentication: %d", type);
    }
#line 449
    if (success) {
#line 449
      tmp___25 = 14;
    } else {
#line 449
      tmp___25 = 15;
    }
#line 449
    packet_start(tmp___25);
#line 450
    packet_send();
#line 451
    packet_write_wait();
#line 454
    if (enable_compression_after_reply) {
#line 455
      enable_compression_after_reply = 0;
#line 456
      packet_start_compression(compression_level);
    }
  }
}
}
#line 466 "session.c"
void do_exec_no_pty(Session *s , char const   *command , struct passwd *pw ) 
{ int pid ;
  int inout[2] ;
  int err[2] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  __pid_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
#line 480
  tmp___1 = socketpair(1, 1, 0, (int *)(inout));
#line 480
  if (tmp___1 < 0) {
#line 482
    tmp = __errno_location();
#line 482
    tmp___0 = strerror(*tmp);
#line 482
    packet_disconnect("Could not create socket pairs: %.100s", tmp___0);
  } else {
#line 480
    tmp___2 = socketpair(1, 1, 0, (int *)(err));
#line 480
    if (tmp___2 < 0) {
#line 482
      tmp = __errno_location();
#line 482
      tmp___0 = strerror(*tmp);
#line 482
      packet_disconnect("Could not create socket pairs: %.100s", tmp___0);
    }
  }
#line 485
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 486
    fatal("do_exec_no_pty: no session");
  }
#line 488
  session_proctitle(s);
#line 495
  pid = fork();
#line 495
  if (pid == 0) {
#line 497
    log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 499
    signal(13, (void (*)(int  ))0);
#line 505
    tmp___5 = setsid();
#line 505
    if (tmp___5 < 0) {
#line 506
      tmp___3 = __errno_location();
#line 506
      tmp___4 = strerror(*tmp___3);
#line 506
      error("setsid failed: %.100s", tmp___4);
    }
#line 535
    close(inout[1]);
#line 536
    close(err[1]);
#line 537
    tmp___6 = dup2(inout[0], 0);
#line 537
    if (tmp___6 < 0) {
#line 538
      perror("dup2 stdin");
    }
#line 539
    tmp___7 = dup2(inout[0], 1);
#line 539
    if (tmp___7 < 0) {
#line 540
      perror("dup2 stdout");
    }
#line 541
    tmp___8 = dup2(err[0], 2);
#line 541
    if (tmp___8 < 0) {
#line 542
      perror("dup2 stderr");
    }
#line 546
    do_child(command, pw, (char const   *)((void *)0), (char const   *)s->display,
             (char const   *)s->auth_proto, (char const   *)s->auth_data, (char const   *)((void *)0));
  }
#line 553
  if (pid < 0) {
#line 554
    tmp___9 = __errno_location();
#line 554
    tmp___10 = strerror(*tmp___9);
#line 554
    packet_disconnect("fork failed: %.100s", tmp___10);
  }
#line 555
  s->pid = pid;
#line 557
  packet_set_interactive((unsigned int )s->display != (unsigned int )((void *)0));
#line 573
  close(inout[0]);
#line 574
  close(err[0]);
#line 580
  if (compat20) {
#line 581
    if (s->extended) {
#line 581
      tmp___11 = err[1];
    } else {
#line 581
      tmp___11 = -1;
    }
#line 581
    session_set_fds(s, inout[1], inout[1], tmp___11);
  } else {
#line 583
    server_loop(pid, inout[1], inout[1], err[1]);
  }
#line 587
  return;
}
}
#line 595 "session.c"
void do_exec_pty(Session *s , char const   *command , struct passwd *pw ) 
{ int fdout___0 ;
  int ptyfd ;
  int ttyfd ;
  int ptymaster ;
  pid_t pid ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;

  {
#line 601
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 602
    fatal("do_exec_pty: no session");
  }
#line 603
  ptyfd = s->ptyfd;
#line 604
  ttyfd = s->ttyfd;
#line 612
  pid = fork();
#line 612
  if (pid == 0) {
#line 614
    log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 616
    signal(13, (void (*)(int  ))0);
#line 619
    close(ptyfd);
#line 622
    pty_make_controlling_tty(& ttyfd, (char const   *)(s->tty));
#line 625
    tmp___1 = fileno(stdin);
#line 625
    tmp___2 = dup2(ttyfd, tmp___1);
#line 625
    if (tmp___2 < 0) {
#line 626
      tmp = __errno_location();
#line 626
      tmp___0 = strerror(*tmp);
#line 626
      error("dup2 stdin failed: %.100s", tmp___0);
    }
#line 629
    tmp___5 = fileno(stdout);
#line 629
    tmp___6 = dup2(ttyfd, tmp___5);
#line 629
    if (tmp___6 < 0) {
#line 630
      tmp___3 = __errno_location();
#line 630
      tmp___4 = strerror(*tmp___3);
#line 630
      error("dup2 stdin failed: %.100s", tmp___4);
    }
#line 633
    tmp___9 = fileno(stderr);
#line 633
    tmp___10 = dup2(ttyfd, tmp___9);
#line 633
    if (tmp___10 < 0) {
#line 634
      tmp___7 = __errno_location();
#line 634
      tmp___8 = strerror(*tmp___7);
#line 634
      error("dup2 stdin failed: %.100s", tmp___8);
    }
#line 637
    close(ttyfd);
#line 640
    if (options.use_login) {
#line 640
      if (! ((unsigned int )command == (unsigned int )((void *)0))) {
#line 641
        do_login(s, command);
      }
    } else {
#line 641
      do_login(s, command);
    }
#line 644
    do_child(command, pw, (char const   *)s->term, (char const   *)s->display, (char const   *)s->auth_proto,
             (char const   *)s->auth_data, (char const   *)(s->tty));
  }
#line 652
  if (pid < 0) {
#line 653
    tmp___11 = __errno_location();
#line 653
    tmp___12 = strerror(*tmp___11);
#line 653
    packet_disconnect("fork failed: %.100s", tmp___12);
  }
#line 654
  s->pid = pid;
#line 657
  close(ttyfd);
#line 664
  fdout___0 = dup(ptyfd);
#line 665
  if (fdout___0 < 0) {
#line 666
    tmp___13 = __errno_location();
#line 666
    tmp___14 = strerror(*tmp___13);
#line 666
    packet_disconnect("dup #1 failed: %.100s", tmp___14);
  }
#line 669
  ptymaster = dup(ptyfd);
#line 670
  if (ptymaster < 0) {
#line 671
    tmp___15 = __errno_location();
#line 671
    tmp___16 = strerror(*tmp___15);
#line 671
    packet_disconnect("dup #2 failed: %.100s", tmp___16);
  }
#line 672
  s->ptymaster = ptymaster;
#line 675
  packet_set_interactive(1);
#line 676
  if (compat20) {
#line 677
    session_set_fds(s, ptyfd, fdout___0, -1);
  } else {
#line 679
    server_loop(pid, ptyfd, fdout___0, -1);
#line 681
    session_pty_cleanup(s);
  }
#line 683
  return;
}
}
#line 688
char const   *get_remote_name_or_ip(void) ;
#line 688 "session.c"
static char const   *remote  =    "";
#line 685 "session.c"
char const   *get_remote_name_or_ip(void) 
{ size_t tmp ;

  {
#line 689
  if (utmp_len > 0U) {
#line 690
    remote = get_canonical_hostname(options.reverse_mapping_check);
  }
#line 691
  if (utmp_len == 0U) {
#line 692
    remote = get_remote_ipaddr();
  } else {
#line 691
    tmp = strlen(remote);
#line 691
    if (tmp > utmp_len) {
#line 692
      remote = get_remote_ipaddr();
    }
  }
#line 693
  return (remote);
}
}
#line 697 "session.c"
void do_login(Session *s , char const   *command ) 
{ FILE *f ;
  char *time_string ;
  char buf___2[256] ;
  char hostname[64] ;
  socklen_t fromlen ;
  struct sockaddr_storage from ;
  struct stat st ;
  time_t last_login_time ;
  struct passwd *pw ;
  pid_t pid ;
  __pid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  u_long tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  char *tmp___9 ;
  char *tmp___11 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___17 ;
  int tmp___20 ;
  int tmp___21 ;
  char *tmp___22 ;

  {
#line 708
  pw = s->pw;
#line 709
  tmp = getpid();
#line 709
  pid = tmp;
#line 715
  memset((void *)(& from), 0, sizeof(from));
#line 716
  tmp___4 = packet_connection_is_on_socket();
#line 716
  if (tmp___4) {
#line 717
    fromlen = sizeof(from);
#line 718
    tmp___2 = packet_get_connection_in();
#line 718
    tmp___3 = getpeername(tmp___2, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 718
    if (tmp___3 < 0) {
#line 720
      tmp___0 = __errno_location();
#line 720
      tmp___1 = strerror(*tmp___0);
#line 720
      debug("getpeername: %.100s", tmp___1);
#line 721
      fatal_cleanup();
    }
  }
#line 726
  hostname[0] = (char )'\000';
#line 727
  tmp___5 = get_last_login_time(pw->pw_uid, (char const   *)pw->pw_name, hostname,
                                sizeof(hostname));
#line 727
  last_login_time = (long )tmp___5;
#line 731
  tmp___6 = get_remote_name_or_ip();
#line 731
  record_login(pid, (char const   *)(s->tty), (char const   *)pw->pw_name, pw->pw_uid,
               tmp___6, (struct sockaddr *)(& from));
#line 746
  if ((unsigned int )command != (unsigned int )((void *)0)) {
#line 747
    return;
  }
#line 748
  snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"%.200s/.hushlogin",
           pw->pw_dir);
#line 752
  tmp___7 = stat((char const   * __restrict  )(buf___2), (struct stat * __restrict  )(& st));
#line 752
  if (tmp___7 >= 0) {
#line 754
    return;
  }
#line 765
  if (last_login_time != 0L) {
#line 766
    time_string = ctime((time_t const   *)(& last_login_time));
#line 767
    tmp___11 = __builtin_strchr(time_string, '\n');
#line 767
    if (tmp___11) {
#line 768
      tmp___9 = __builtin_strchr(time_string, '\n');
#line 768
      *tmp___9 = (char)0;
    }
#line 769
    if (0) {
#line 769
      __s1_len = strlen((char const   *)(hostname));
#line 769
      __s2_len = strlen("");
#line 769
      if (! ((unsigned int )((void const   *)(hostname + 1)) - (unsigned int )((void const   *)(hostname)) == 1U)) {
        goto _L___0;
      } else {
#line 769
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 769
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 769
            tmp___21 = 1;
          } else {
#line 769
            if (__s2_len >= 4U) {
#line 769
              tmp___21 = 1;
            } else {
#line 769
              tmp___21 = 0;
            }
          }
        } else {
#line 769
          tmp___21 = 0;
        }
      }
#line 769
      if (tmp___21) {
#line 769
        tmp___17 = __builtin_strcmp((char const   *)(hostname), "");
      } else {
#line 769
        tmp___20 = __builtin_strcmp((char const   *)(hostname), "");
#line 769
        tmp___17 = tmp___20;
      }
    } else {
#line 769
      tmp___20 = __builtin_strcmp((char const   *)(hostname), "");
#line 769
      tmp___17 = tmp___20;
    }
#line 769
    if (tmp___17 == 0) {
#line 770
      printf((char const   * __restrict  )"Last login: %s\r\n", time_string);
    } else {
#line 772
      printf((char const   * __restrict  )"Last login: %s from %s\r\n", time_string,
             hostname);
    }
  }
#line 774
  if (options.print_motd) {
#line 779
    f = fopen((char const   * __restrict  )"/etc/motd", (char const   * __restrict  )"r");
#line 781
    if (f) {
#line 782
      while (1) {
#line 782
        tmp___22 = fgets((char * __restrict  )(buf___2), (int )sizeof(buf___2), (FILE * __restrict  )f);
#line 782
        if (! tmp___22) {
#line 782
          break;
        }
#line 783
        fputs((char const   * __restrict  )(buf___2), (FILE * __restrict  )stdout);
      }
#line 784
      fclose(f);
    }
  }
#line 787
  return;
}
}
#line 793 "session.c"
void child_set_env(char ***envp , u_int *envsizep , char const   *name , char const   *value ) 
{ u_int i ;
  u_int namelen ;
  char **env ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  void *tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  void *tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;

  {
#line 805
  env = *envp;
#line 806
  namelen = strlen(name);
#line 807
  i = 0U;
#line 807
  while (*(env + i)) {
#line 808
    if (0) {
#line 808
      if (0) {
#line 808
        __s1_len___0 = strlen((char const   *)*(env + i));
#line 808
        __s2_len___0 = strlen(name);
#line 808
        if (! ((unsigned int )((void const   *)(*(env + i) + 1)) - (unsigned int )((void const   *)*(env + i)) == 1U)) {
          goto _L___2;
        } else {
#line 808
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 808
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
#line 808
              tmp___22 = 1;
            } else {
#line 808
              if (__s2_len___0 >= 4U) {
#line 808
                tmp___22 = 1;
              } else {
#line 808
                tmp___22 = 0;
              }
            }
          } else {
#line 808
            tmp___22 = 0;
          }
        }
#line 808
        if (tmp___22) {
#line 808
          tmp___18 = __builtin_strcmp((char const   *)*(env + i), name);
        } else {
#line 808
          tmp___21 = __builtin_strcmp((char const   *)*(env + i), name);
#line 808
          tmp___18 = tmp___21;
        }
      } else {
#line 808
        tmp___21 = __builtin_strcmp((char const   *)*(env + i), name);
#line 808
        tmp___18 = tmp___21;
      }
#line 808
      tmp___12 = tmp___18;
    } else {
#line 808
      tmp___12 = strncmp((char const   *)*(env + i), name, namelen);
    }
#line 808
    if (tmp___12 == 0) {
#line 808
      if ((int )*(*(env + i) + namelen) == 61) {
#line 809
        break;
      }
    }
#line 807
    i ++;
  }
#line 810
  if (*(env + i)) {
#line 812
    xfree((void *)*(env + i));
  } else {
#line 815
    if (i >= *envsizep - 1U) {
#line 816
      *envsizep += 50U;
#line 817
      tmp___25 = xrealloc((void *)env, *envsizep * sizeof(char *));
#line 817
      *envp = (char **)tmp___25;
#line 817
      env = *envp;
    }
#line 820
    *(env + (i + 1U)) = (char *)((void *)0);
  }
#line 824
  tmp___26 = strlen(name);
#line 824
  tmp___27 = strlen(value);
#line 824
  tmp___28 = xmalloc(((tmp___26 + 1U) + tmp___27) + 1U);
#line 824
  *(env + i) = (char *)tmp___28;
#line 825
  tmp___29 = strlen(name);
#line 825
  tmp___30 = strlen(value);
#line 825
  snprintf((char * __restrict  )*(env + i), ((tmp___29 + 1U) + tmp___30) + 1U, (char const   * __restrict  )"%s=%s",
           name, value);
#line 826
  return;
}
}
#line 834 "session.c"
void read_environment_file(char ***env , u_int *envsize , char const   *filename ) 
{ FILE *f ;
  char buf___2[4096] ;
  char *cp ;
  char *value ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 842
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 843
  if (! f) {
#line 844
    return;
  }
#line 846
  while (1) {
#line 846
    tmp___5 = fgets((char * __restrict  )(buf___2), (int )sizeof(buf___2), (FILE * __restrict  )f);
#line 846
    if (! tmp___5) {
#line 846
      break;
    }
#line 847
    cp = buf___2;
#line 847
    while (1) {
#line 847
      if (! ((int )*cp == 32)) {
#line 847
        if (! ((int )*cp == 9)) {
#line 847
          break;
        }
      }
#line 847
      cp ++;
    }
#line 849
    if (! *cp) {
#line 850
      continue;
    } else {
#line 849
      if ((int )*cp == 35) {
#line 850
        continue;
      } else {
#line 849
        if ((int )*cp == 10) {
#line 850
          continue;
        }
      }
    }
#line 851
    tmp___2 = __builtin_strchr(cp, '\n');
#line 851
    if (tmp___2) {
#line 852
      tmp___0 = __builtin_strchr(cp, '\n');
#line 852
      *tmp___0 = (char )'\000';
    }
#line 853
    tmp___4 = __builtin_strchr(cp, '=');
#line 853
    value = tmp___4;
#line 854
    if ((unsigned int )value == (unsigned int )((void *)0)) {
#line 855
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad line in %.100s: %.200s\n",
              filename, buf___2);
#line 856
      continue;
    }
#line 862
    *value = (char )'\000';
#line 863
    value ++;
#line 864
    child_set_env(env, envsize, (char const   *)cp, (char const   *)value);
  }
#line 866
  fclose(f);
#line 867
  return;
}
}
#line 1021
extern char **environ ;
#line 1010 "session.c"
void do_child(char const   *command , struct passwd *pw , char const   *term , char const   *display ,
              char const   *auth_proto , char const   *auth_data , char const   *ttyname___0 ) 
{ char const   *shell ;
  char const   *hostname ;
  char const   *cp ;
  char buf___2[256] ;
  char cmd[1024] ;
  FILE *f ;
  u_int envsize ;
  u_int i ;
  char **env ;
  struct stat st ;
  char *argv[10] ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  __uid_t tmp___5 ;
  __uid_t tmp___6 ;
  __uid_t tmp___7 ;
  __uid_t tmp___8 ;
  void *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  struct envstring *ce ;
  char *s ;
  int i___0 ;
  int tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char *screen ;
  char *tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  char buf___3[256] ;
  char *mailbox ;
  struct stat mailstat ;
  int tmp___30 ;

  {
#line 1015
  hostname = (char const   *)((void *)0);
#line 1015
  cp = (char const   *)((void *)0);
#line 1018
  f = (FILE *)((void *)0);
#line 1036
  if (options.use_login) {
#line 1036
    if ((unsigned int )command != (unsigned int )((void *)0)) {
#line 1037
      options.use_login = 0;
    }
  }
#line 1040
  if (! options.use_login) {
#line 1046
    if (pw->pw_uid) {
#line 1047
      f = fopen((char const   * __restrict  )"/etc/nologin", (char const   * __restrict  )"r");
    }
#line 1049
    if (f) {
#line 1051
      while (1) {
#line 1051
        tmp = fgets((char * __restrict  )(buf___2), (int )sizeof(buf___2), (FILE * __restrict  )f);
#line 1051
        if (! tmp) {
#line 1051
          break;
        }
#line 1052
        fputs((char const   * __restrict  )(buf___2), (FILE * __restrict  )stderr);
      }
#line 1053
      fclose(f);
#line 1054
      exit(254);
    }
  }
#line 1062
  if (! options.use_login) {
#line 1069
    tmp___5 = getuid();
#line 1069
    if (tmp___5 == 0U) {
      goto _L;
    } else {
#line 1069
      tmp___6 = geteuid();
#line 1069
      if (tmp___6 == 0U) {
        _L: /* CIL Label */ 
#line 1094
        tmp___2 = setlogin((char const   *)pw->pw_name);
#line 1094
        if (tmp___2 < 0) {
#line 1095
          tmp___0 = __errno_location();
#line 1095
          tmp___1 = strerror(*tmp___0);
#line 1095
          error("setlogin failed: %s", tmp___1);
        }
#line 1096
        tmp___3 = setgid(pw->pw_gid);
#line 1096
        if (tmp___3 < 0) {
#line 1097
          perror("setgid");
#line 1098
          exit(1);
        }
#line 1101
        tmp___4 = initgroups((char const   *)pw->pw_name, pw->pw_gid);
#line 1101
        if (tmp___4 < 0) {
#line 1102
          perror("initgroups");
#line 1103
          exit(1);
        }
#line 1105
        endgrent();
#line 1140
        permanently_set_uid(pw->pw_uid);
      }
    }
#line 1148
    tmp___7 = getuid();
#line 1148
    if (tmp___7 != pw->pw_uid) {
#line 1149
      fatal("Failed to set uids to %u.", pw->pw_uid);
    } else {
#line 1148
      tmp___8 = geteuid();
#line 1148
      if (tmp___8 != pw->pw_uid) {
#line 1149
        fatal("Failed to set uids to %u.", pw->pw_uid);
      }
    }
  }
#line 1155
  if ((int )*(pw->pw_shell + 0) == 0) {
#line 1155
    shell = "/bin/sh";
  } else {
#line 1155
    shell = (char const   *)pw->pw_shell;
  }
#line 1173
  envsize = 100U;
#line 1174
  tmp___9 = xmalloc(envsize * sizeof(char *));
#line 1174
  env = (char **)tmp___9;
#line 1175
  *(env + 0) = (char *)((void *)0);
#line 1185
  if (! options.use_login) {
#line 1187
    child_set_env(& env, & envsize, "USER", (char const   *)pw->pw_name);
#line 1188
    child_set_env(& env, & envsize, "LOGNAME", (char const   *)pw->pw_name);
#line 1189
    child_set_env(& env, & envsize, "HOME", (char const   *)pw->pw_dir);
#line 1201
    child_set_env(& env, & envsize, "PATH", "/usr/bin:/bin:/usr/sbin:/sbin");
#line 1205
    snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"%.200s/%.50s",
             "/var/mail", pw->pw_name);
#line 1207
    child_set_env(& env, & envsize, "MAIL", (char const   *)(buf___2));
#line 1210
    child_set_env(& env, & envsize, "SHELL", shell);
  }
#line 1212
  tmp___11 = getenv("TZ");
#line 1212
  if (tmp___11) {
#line 1213
    tmp___10 = getenv("TZ");
#line 1213
    child_set_env(& env, & envsize, "TZ", (char const   *)tmp___10);
  }
#line 1216
  while (custom_environment) {
#line 1217
    ce = custom_environment;
#line 1218
    s = ce->s;
#line 1220
    i___0 = 0;
#line 1220
    while (1) {
#line 1220
      if ((int )*(s + i___0) != 61) {
#line 1220
        if (! *(s + i___0)) {
#line 1220
          break;
        }
      } else {
#line 1220
        break;
      }
#line 1220
      i___0 ++;
    }
#line 1221
    if ((int )*(s + i___0) == 61) {
#line 1222
      *(s + i___0) = (char)0;
#line 1223
      child_set_env(& env, & envsize, (char const   *)s, (char const   *)((s + i___0) + 1));
    }
#line 1225
    custom_environment = ce->next;
#line 1226
    xfree((void *)ce->s);
#line 1227
    xfree((void *)ce);
  }
#line 1230
  tmp___12 = get_local_port();
#line 1230
  tmp___13 = get_remote_port();
#line 1230
  tmp___14 = get_remote_ipaddr();
#line 1230
  snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"%.50s %d %d",
           tmp___14, tmp___13, tmp___12);
#line 1232
  child_set_env(& env, & envsize, "SSH_CLIENT", (char const   *)(buf___2));
#line 1234
  if (ttyname___0) {
#line 1235
    child_set_env(& env, & envsize, "SSH_TTY", ttyname___0);
  }
#line 1236
  if (term) {
#line 1237
    child_set_env(& env, & envsize, "TERM", term);
  }
#line 1238
  if (display) {
#line 1239
    child_set_env(& env, & envsize, "DISPLAY", display);
  }
#line 1240
  if (original_command) {
#line 1241
    child_set_env(& env, & envsize, "SSH_ORIGINAL_COMMAND", (char const   *)original_command);
  }
#line 1266
  if (xauthfile) {
#line 1267
    child_set_env(& env, & envsize, "XAUTHORITY", (char const   *)xauthfile);
  }
#line 1268
  tmp___16 = auth_get_socket_name();
#line 1268
  if ((unsigned int )tmp___16 != (unsigned int )((void *)0)) {
#line 1269
    tmp___15 = auth_get_socket_name();
#line 1269
    child_set_env(& env, & envsize, "SSH_AUTH_SOCK", (char const   *)tmp___15);
  }
#line 1273
  if (! options.use_login) {
#line 1274
    snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"%.200s/.ssh/environment",
             pw->pw_dir);
#line 1276
    read_environment_file(& env, & envsize, (char const   *)(buf___2));
  }
#line 1278
  if (debug_flag) {
#line 1280
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Environment:\n");
#line 1281
    i = 0U;
#line 1281
    while (*(env + i)) {
#line 1282
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  %.200s\n",
              *(env + i));
#line 1281
      i ++;
    }
  }
#line 1285
  if (options.use_login) {
#line 1286
    hostname = get_remote_name_or_ip();
  }
#line 1294
  tmp___20 = packet_get_connection_in();
#line 1294
  tmp___21 = packet_get_connection_out();
#line 1294
  if (tmp___20 == tmp___21) {
#line 1295
    tmp___17 = packet_get_connection_in();
#line 1295
    close(tmp___17);
  } else {
#line 1297
    tmp___18 = packet_get_connection_in();
#line 1297
    close(tmp___18);
#line 1298
    tmp___19 = packet_get_connection_out();
#line 1298
    close(tmp___19);
  }
#line 1305
  channel_close_all();
#line 1311
  endpwent();
#line 1319
  i = 3U;
#line 1319
  while (i < 64U) {
#line 1320
    close((int )i);
#line 1319
    i ++;
  }
#line 1323
  tmp___24 = chdir((char const   *)pw->pw_dir);
#line 1323
  if (tmp___24 < 0) {
#line 1324
    tmp___22 = __errno_location();
#line 1324
    tmp___23 = strerror(*tmp___22);
#line 1324
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not chdir to home directory %s: %s\n",
            pw->pw_dir, tmp___23);
  }
#line 1336
  environ = env;
#line 1342
  if (! options.use_login) {
#line 1343
    tmp___28 = stat((char const   * __restrict  )".ssh/rc", (struct stat * __restrict  )(& st));
#line 1343
    if (tmp___28 >= 0) {
#line 1344
      if (debug_flag) {
#line 1345
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %s %s\n",
                "/bin/sh", ".ssh/rc");
      }
#line 1347
      f = popen("/bin/sh .ssh/rc", "w");
#line 1348
      if (f) {
#line 1349
        if ((unsigned int )auth_proto != (unsigned int )((void *)0)) {
#line 1349
          if ((unsigned int )auth_data != (unsigned int )((void *)0)) {
#line 1350
            fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                    auth_proto, auth_data);
          }
        }
#line 1351
        pclose(f);
      } else {
#line 1353
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                ".ssh/rc");
      }
    } else {
#line 1354
      tmp___27 = stat((char const   * __restrict  )"/usr/local/etc/sshrc", (struct stat * __restrict  )(& st));
#line 1354
      if (tmp___27 >= 0) {
#line 1355
        if (debug_flag) {
#line 1356
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %s %s\n",
                  "/bin/sh", "/usr/local/etc/sshrc");
        }
#line 1358
        f = popen("/bin/sh /usr/local/etc/sshrc", "w");
#line 1359
        if (f) {
#line 1360
          if ((unsigned int )auth_proto != (unsigned int )((void *)0)) {
#line 1360
            if ((unsigned int )auth_data != (unsigned int )((void *)0)) {
#line 1361
              fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                      auth_proto, auth_data);
            }
          }
#line 1362
          pclose(f);
        } else {
#line 1364
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                  "/usr/local/etc/sshrc");
        }
      } else {
#line 1365
        if ((unsigned int )options.xauth_location != (unsigned int )((void *)0)) {
#line 1367
          if ((unsigned int )auth_proto != (unsigned int )((void *)0)) {
#line 1367
            if ((unsigned int )auth_data != (unsigned int )((void *)0)) {
#line 1368
              tmp___26 = __builtin_strchr((char *)display, ':');
#line 1368
              screen = tmp___26;
#line 1369
              if (debug_flag) {
#line 1370
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %.100s add %.100s %.100s %.100s\n",
                        options.xauth_location, display, auth_proto, auth_data);
#line 1375
                if ((unsigned int )screen != (unsigned int )((void *)0)) {
#line 1376
                  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Adding %.*s/unix%s %s %s\n",
                          screen - (char *)display, display, screen, auth_proto, auth_data);
                }
              }
#line 1382
              snprintf((char * __restrict  )(cmd), sizeof(cmd), (char const   * __restrict  )"%s -q -",
                       options.xauth_location);
#line 1384
              f = popen((char const   *)(cmd), "w");
#line 1385
              if (f) {
#line 1386
                fprintf((FILE * __restrict  )f, (char const   * __restrict  )"add %s %s %s\n",
                        display, auth_proto, auth_data);
#line 1389
                if ((unsigned int )screen != (unsigned int )((void *)0)) {
#line 1390
                  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"add %.*s/unix%s %s %s\n",
                          screen - (char *)display, display, screen, auth_proto, auth_data);
                }
#line 1394
                pclose(f);
              } else {
#line 1396
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                        cmd);
              }
            }
          }
        }
      }
    }
#line 1402
    tmp___29 = strrchr(shell, '/');
#line 1402
    cp = (char const   *)tmp___29;
#line 1403
    if (cp) {
#line 1404
      cp ++;
    } else {
#line 1406
      cp = shell;
    }
  }
#line 1413
  if (! command) {
#line 1414
    if (! options.use_login) {
#line 1421
      if (ttyname___0) {
#line 1421
        if (options.check_mail) {
#line 1424
          mailbox = getenv("MAIL");
#line 1425
          if ((unsigned int )mailbox != (unsigned int )((void *)0)) {
#line 1426
            tmp___30 = stat((char const   * __restrict  )mailbox, (struct stat * __restrict  )(& mailstat));
#line 1426
            if (tmp___30 != 0) {
#line 1428
              printf((char const   * __restrict  )"No mail.\n");
            } else {
#line 1426
              if (mailstat.st_size == 0L) {
#line 1428
                printf((char const   * __restrict  )"No mail.\n");
              } else {
#line 1429
                if (mailstat.st_mtim.tv_sec < mailstat.st_atim.tv_sec) {
#line 1430
                  printf((char const   * __restrict  )"You have mail.\n");
                } else {
#line 1432
                  printf((char const   * __restrict  )"You have new mail.\n");
                }
              }
            }
          }
        }
      }
#line 1436
      buf___3[0] = (char )'-';
#line 1437
      __builtin_strncpy(buf___3 + 1, cp, sizeof(buf___3) - 1U);
#line 1438
      buf___3[sizeof(buf___3) - 1U] = (char)0;
#line 1441
      argv[0] = buf___3;
#line 1442
      argv[1] = (char *)((void *)0);
#line 1443
      execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 1446
      perror(shell);
#line 1447
      exit(1);
    } else {
#line 1452
      execl("/bin/login", "login", "-h", hostname, "-p", "-f", "--", pw->pw_name,
            (void *)0);
#line 1457
      perror("login");
#line 1458
      exit(1);
    }
  }
#line 1465
  argv[0] = (char *)cp;
#line 1466
  argv[1] = (char *)"-c";
#line 1467
  argv[2] = (char *)command;
#line 1468
  argv[3] = (char *)((void *)0);
#line 1469
  execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 1470
  perror(shell);
#line 1471
  exit(1);
}
}
#line 1478 "session.c"
static int did_init___0  =    0;
#line 1474 "session.c"
Session *session_new(void) 
{ int i ;
  Session *s ;

  {
#line 1479
  if (! did_init___0) {
#line 1480
    debug("session_new: init");
#line 1481
    i = 0;
#line 1481
    while (i < 10) {
#line 1482
      sessions[i].used = 0;
#line 1483
      sessions[i].self = i;
#line 1481
      i ++;
    }
#line 1485
    did_init___0 = 1;
  }
#line 1487
  i = 0;
#line 1487
  while (i < 10) {
#line 1488
    s = & sessions[i];
#line 1489
    if (! s->used) {
#line 1490
      s->pid = 0;
#line 1491
      s->extended = 0;
#line 1492
      s->chanid = -1;
#line 1493
      s->ptyfd = -1;
#line 1494
      s->ttyfd = -1;
#line 1495
      s->term = (char *)((void *)0);
#line 1496
      s->pw = (struct passwd *)((void *)0);
#line 1497
      s->display = (char *)((void *)0);
#line 1498
      s->screen = 0;
#line 1499
      s->auth_data = (char *)((void *)0);
#line 1500
      s->auth_proto = (char *)((void *)0);
#line 1501
      s->used = 1;
#line 1502
      s->pw = (struct passwd *)((void *)0);
#line 1503
      debug("session_new: session %d", i);
#line 1504
      return (s);
    }
#line 1487
    i ++;
  }
#line 1507
  return ((Session *)((void *)0));
}
}
#line 1510 "session.c"
void session_dump(void) 
{ int i ;
  Session *s ;

  {
#line 1514
  i = 0;
#line 1514
  while (i < 10) {
#line 1515
    s = & sessions[i];
#line 1516
    debug("dump: used %d session %d %p channel %d pid %d", s->used, s->self, s, s->chanid,
          s->pid);
#line 1514
    i ++;
  }
#line 1523
  return;
}
}
#line 1525 "session.c"
int session_open(int chanid ) 
{ Session *s ;
  Session *tmp ;

  {
#line 1528
  tmp = session_new();
#line 1528
  s = tmp;
#line 1529
  debug("session_open: channel %d", chanid);
#line 1530
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1531
    error("no more sessions");
#line 1532
    return (0);
  }
#line 1534
  s->pw = auth_get_user();
#line 1535
  if ((unsigned int )s->pw == (unsigned int )((void *)0)) {
#line 1536
    fatal("no user for session %d", s->self);
  }
#line 1537
  debug("session_open: session %d: link with channel %d", s->self, chanid);
#line 1538
  s->chanid = chanid;
#line 1539
  return (1);
}
}
#line 1542 "session.c"
Session *session_by_channel(int id ) 
{ int i ;
  Session *s ;

  {
#line 1546
  i = 0;
#line 1546
  while (i < 10) {
#line 1547
    s = & sessions[i];
#line 1548
    if (s->used) {
#line 1548
      if (s->chanid == id) {
#line 1549
        debug("session_by_channel: session %d channel %d", i, id);
#line 1550
        return (s);
      }
    }
#line 1546
    i ++;
  }
#line 1553
  debug("session_by_channel: unknown channel %d", id);
#line 1554
  session_dump();
#line 1555
  return ((Session *)((void *)0));
}
}
#line 1558 "session.c"
Session *session_by_pid(pid_t pid ) 
{ int i ;
  Session *s ;

  {
#line 1562
  debug("session_by_pid: pid %d", pid);
#line 1563
  i = 0;
#line 1563
  while (i < 10) {
#line 1564
    s = & sessions[i];
#line 1565
    if (s->used) {
#line 1565
      if (s->pid == pid) {
#line 1566
        return (s);
      }
    }
#line 1563
    i ++;
  }
#line 1568
  error("session_by_pid: unknown pid %d", pid);
#line 1569
  session_dump();
#line 1570
  return ((Session *)((void *)0));
}
}
#line 1573 "session.c"
int session_window_change_req(Session *s ) 
{ u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 1576
  tmp = packet_get_int();
#line 1576
  s->col = (int )tmp;
#line 1577
  tmp___0 = packet_get_int();
#line 1577
  s->row = (int )tmp___0;
#line 1578
  tmp___1 = packet_get_int();
#line 1578
  s->xpixel = (int )tmp___1;
#line 1579
  tmp___2 = packet_get_int();
#line 1579
  s->ypixel = (int )tmp___2;
#line 1580
  while (1) {
#line 1580
    tmp___3 = packet_remaining();
#line 1580
    _len = tmp___3;
#line 1580
    if (_len > 0) {
#line 1580
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1580);
#line 1580
      packet_disconnect("Packet integrity error.");
    }
#line 1580
    break;
  }
#line 1581
  pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);
#line 1582
  return (1);
}
}
#line 1585 "session.c"
int session_pty_req(Session *s ) 
{ u_int len ;
  char *term_modes ;
  u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  int _len ;
  int tmp___3 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___9 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 1591
  if (no_pty_flag) {
#line 1592
    return (0);
  }
#line 1593
  if (s->ttyfd != -1) {
#line 1594
    return (0);
  }
#line 1595
  s->term = packet_get_string(& len);
#line 1596
  tmp = packet_get_int();
#line 1596
  s->col = (int )tmp;
#line 1597
  tmp___0 = packet_get_int();
#line 1597
  s->row = (int )tmp___0;
#line 1598
  tmp___1 = packet_get_int();
#line 1598
  s->xpixel = (int )tmp___1;
#line 1599
  tmp___2 = packet_get_int();
#line 1599
  s->ypixel = (int )tmp___2;
#line 1600
  term_modes = packet_get_string(& len);
#line 1601
  while (1) {
#line 1601
    tmp___3 = packet_remaining();
#line 1601
    _len = tmp___3;
#line 1601
    if (_len > 0) {
#line 1601
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1601);
#line 1601
      packet_disconnect("Packet integrity error.");
    }
#line 1601
    break;
  }
#line 1603
  if (0) {
#line 1603
    __s1_len = strlen((char const   *)s->term);
#line 1603
    __s2_len = strlen("");
#line 1603
    if (! ((unsigned int )((void const   *)(s->term + 1)) - (unsigned int )((void const   *)s->term) == 1U)) {
      goto _L___0;
    } else {
#line 1603
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1603
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 1603
          tmp___13 = 1;
        } else {
#line 1603
          if (__s2_len >= 4U) {
#line 1603
            tmp___13 = 1;
          } else {
#line 1603
            tmp___13 = 0;
          }
        }
      } else {
#line 1603
        tmp___13 = 0;
      }
    }
#line 1603
    if (tmp___13) {
#line 1603
      tmp___9 = __builtin_strcmp((char const   *)s->term, "");
    } else {
#line 1603
      tmp___12 = __builtin_strcmp((char const   *)s->term, "");
#line 1603
      tmp___9 = tmp___12;
    }
  } else {
#line 1603
    tmp___12 = __builtin_strcmp((char const   *)s->term, "");
#line 1603
    tmp___9 = tmp___12;
  }
#line 1603
  if (tmp___9 == 0) {
#line 1604
    xfree((void *)s->term);
#line 1605
    s->term = (char *)((void *)0);
  }
#line 1608
  tmp___14 = pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, (int )sizeof(s->tty));
#line 1608
  if (! tmp___14) {
#line 1609
    xfree((void *)s->term);
#line 1610
    s->term = (char *)((void *)0);
#line 1611
    s->ptyfd = -1;
#line 1612
    s->ttyfd = -1;
#line 1613
    error("session_pty_req: session %d alloc failed", s->self);
#line 1614
    xfree((void *)term_modes);
#line 1615
    return (0);
  }
#line 1617
  debug("session_pty_req: session %d alloc %s", s->self, s->tty);
#line 1622
  fatal_add_cleanup(& pty_cleanup_proc, (void *)s);
#line 1623
  pty_setowner(s->pw, (char const   *)(s->tty));
#line 1625
  pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);
#line 1627
  session_proctitle(s);
#line 1630
  xfree((void *)term_modes);
#line 1631
  return (1);
}
}
#line 1634 "session.c"
int session_subsystem_req(Session *s ) 
{ u_int len ;
  int success ;
  char *subsys ;
  char *tmp ;
  int i ;
  int _len ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 1638
  success = 0;
#line 1639
  tmp = packet_get_string(& len);
#line 1639
  subsys = tmp;
#line 1642
  while (1) {
#line 1642
    tmp___0 = packet_remaining();
#line 1642
    _len = tmp___0;
#line 1642
    if (_len > 0) {
#line 1642
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1642);
#line 1642
      packet_disconnect("Packet integrity error.");
    }
#line 1642
    break;
  }
#line 1643
  log("subsystem request for %s", subsys);
#line 1645
  i = 0;
#line 1645
  while ((u_int )i < options.num_subsystems) {
#line 1646
    if (0) {
#line 1646
      __s1_len = strlen((char const   *)subsys);
#line 1646
      __s2_len = strlen((char const   *)options.subsystem_name[i]);
#line 1646
      if (! ((unsigned int )((void const   *)(subsys + 1)) - (unsigned int )((void const   *)subsys) == 1U)) {
        goto _L___0;
      } else {
#line 1646
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 1646
          if (! ((unsigned int )((void const   *)(options.subsystem_name[i] + 1)) - (unsigned int )((void const   *)options.subsystem_name[i]) == 1U)) {
#line 1646
            tmp___10 = 1;
          } else {
#line 1646
            if (__s2_len >= 4U) {
#line 1646
              tmp___10 = 1;
            } else {
#line 1646
              tmp___10 = 0;
            }
          }
        } else {
#line 1646
          tmp___10 = 0;
        }
      }
#line 1646
      if (tmp___10) {
#line 1646
        tmp___6 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
      } else {
#line 1646
        tmp___9 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
#line 1646
        tmp___6 = tmp___9;
      }
    } else {
#line 1646
      tmp___9 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
#line 1646
      tmp___6 = tmp___9;
    }
#line 1646
    if (tmp___6 == 0) {
#line 1647
      debug("subsystem: exec() %s", options.subsystem_command[i]);
#line 1648
      do_exec_no_pty(s, (char const   *)options.subsystem_command[i], s->pw);
#line 1649
      success = 1;
    }
#line 1645
    i ++;
  }
#line 1653
  if (! success) {
#line 1654
    log("subsystem request for %s failed, subsystem not found", subsys);
  }
#line 1656
  xfree((void *)subsys);
#line 1657
  return (success);
}
}
#line 1660 "session.c"
int session_x11_req(Session *s ) 
{ int fd ;
  u_int tmp ;
  u_int tmp___0 ;
  int _len ;
  int tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 1664
  if (no_x11_forwarding_flag) {
#line 1665
    debug("X11 forwarding disabled in user configuration file.");
#line 1666
    return (0);
  }
#line 1668
  if (! options.x11_forwarding) {
#line 1669
    debug("X11 forwarding disabled in server configuration file.");
#line 1670
    return (0);
  }
#line 1672
  if ((unsigned int )xauthfile != (unsigned int )((void *)0)) {
#line 1673
    debug("X11 fwd already started.");
#line 1674
    return (0);
  }
#line 1677
  debug("Received request for X11 forwarding with auth spoofing.");
#line 1678
  if ((unsigned int )s->display != (unsigned int )((void *)0)) {
#line 1679
    packet_disconnect("Protocol error: X11 display already set.");
  }
#line 1681
  tmp = packet_get_char();
#line 1681
  s->single_connection = (int )tmp;
#line 1682
  s->auth_proto = packet_get_string((u_int *)((void *)0));
#line 1683
  s->auth_data = packet_get_string((u_int *)((void *)0));
#line 1684
  tmp___0 = packet_get_int();
#line 1684
  s->screen = (int )tmp___0;
#line 1685
  while (1) {
#line 1685
    tmp___1 = packet_remaining();
#line 1685
    _len = tmp___1;
#line 1685
    if (_len > 0) {
#line 1685
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1685);
#line 1685
      packet_disconnect("Packet integrity error.");
    }
#line 1685
    break;
  }
#line 1687
  s->display = x11_create_display_inet(s->screen, options.x11_display_offset);
#line 1688
  if ((unsigned int )s->display == (unsigned int )((void *)0)) {
#line 1689
    xfree((void *)s->auth_proto);
#line 1690
    xfree((void *)s->auth_data);
#line 1691
    return (0);
  }
#line 1693
  tmp___2 = xmalloc(4096U);
#line 1693
  xauthfile = (char *)tmp___2;
#line 1694
  strlcpy(xauthfile, "/tmp/ssh-XXXXXXXX", 4096U);
#line 1695
  temporarily_use_uid((s->pw)->pw_uid);
#line 1696
  tmp___5 = mkdtemp(xauthfile);
#line 1696
  if ((unsigned int )tmp___5 == (unsigned int )((void *)0)) {
#line 1697
    restore_uid();
#line 1698
    tmp___3 = __errno_location();
#line 1698
    tmp___4 = strerror(*tmp___3);
#line 1698
    error("private X11 dir: mkdtemp %s failed: %s", xauthfile, tmp___4);
#line 1700
    xfree((void *)xauthfile);
#line 1701
    xauthfile = (char *)((void *)0);
#line 1702
    xfree((void *)s->auth_proto);
#line 1703
    xfree((void *)s->auth_data);
#line 1705
    return (0);
  }
#line 1707
  strlcat(xauthfile, "/cookies", 4096U);
#line 1708
  fd = open((char const   *)xauthfile, 194, 384);
#line 1709
  if (fd >= 0) {
#line 1710
    close(fd);
  }
#line 1711
  restore_uid();
#line 1712
  fatal_add_cleanup(& xauthfile_cleanup_proc, (void *)s);
#line 1713
  return (1);
}
}
#line 1716 "session.c"
int session_shell_req(Session *s ) 
{ char *shell ;
  int _len ;
  int tmp ;

  {
#line 1720
  shell = forced_command;
#line 1721
  while (1) {
#line 1721
    tmp = packet_remaining();
#line 1721
    _len = tmp;
#line 1721
    if (_len > 0) {
#line 1721
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1721);
#line 1721
      packet_disconnect("Packet integrity error.");
    }
#line 1721
    break;
  }
#line 1722
  s->extended = 1;
#line 1723
  if (s->ttyfd == -1) {
#line 1724
    do_exec_no_pty(s, (char const   *)shell, s->pw);
  } else {
#line 1726
    do_exec_pty(s, (char const   *)shell, s->pw);
  }
#line 1727
  return (1);
}
}
#line 1730 "session.c"
int session_exec_req(Session *s ) 
{ u_int len ;
  char *command ;
  char *tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 1734
  tmp = packet_get_string(& len);
#line 1734
  command = tmp;
#line 1735
  while (1) {
#line 1735
    tmp___0 = packet_remaining();
#line 1735
    _len = tmp___0;
#line 1735
    if (_len > 0) {
#line 1735
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1735);
#line 1735
      packet_disconnect("Packet integrity error.");
    }
#line 1735
    break;
  }
#line 1736
  if (forced_command) {
#line 1737
    original_command = command;
#line 1738
    command = forced_command;
#line 1739
    debug("Forced command \'%.500s\'", forced_command);
  }
#line 1741
  s->extended = 1;
#line 1742
  if (s->ttyfd == -1) {
#line 1743
    do_exec_no_pty(s, (char const   *)command, s->pw);
  } else {
#line 1745
    do_exec_pty(s, (char const   *)command, s->pw);
  }
#line 1746
  if ((unsigned int )forced_command == (unsigned int )((void *)0)) {
#line 1747
    xfree((void *)command);
  }
#line 1748
  return (1);
}
}
#line 1754
int session_auth_agent_req(Session *s ) ;
#line 1754 "session.c"
static int called___2  =    0;
#line 1751 "session.c"
int session_auth_agent_req(Session *s ) 
{ int _len ;
  int tmp ;
  int tmp___0 ;

  {
#line 1755
  while (1) {
#line 1755
    tmp = packet_remaining();
#line 1755
    _len = tmp;
#line 1755
    if (_len > 0) {
#line 1755
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1755);
#line 1755
      packet_disconnect("Packet integrity error.");
    }
#line 1755
    break;
  }
#line 1756
  if (no_agent_forwarding_flag) {
#line 1757
    debug("session_auth_agent_req: no_agent_forwarding_flag");
#line 1758
    return (0);
  }
#line 1760
  if (called___2) {
#line 1761
    return (0);
  } else {
#line 1763
    called___2 = 1;
#line 1764
    tmp___0 = auth_input_request_forwarding(s->pw);
#line 1764
    return (tmp___0);
  }
}
}
#line 1768 "session.c"
void session_input_channel_req(int id , void *arg ) 
{ u_int len ;
  int reply ;
  int success ;
  char *rtype ;
  Session *s ;
  Channel *c ;
  u_int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___25 ;
  int tmp___28 ;
  int tmp___29 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___35 ;
  int tmp___38 ;
  int tmp___39 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___45 ;
  int tmp___48 ;
  int tmp___49 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___55 ;
  int tmp___58 ;
  int tmp___59 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___65 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;

  {
#line 1773
  success = 0;
#line 1778
  rtype = packet_get_string(& len);
#line 1779
  tmp = packet_get_char();
#line 1779
  reply = (int )tmp;
#line 1781
  s = session_by_channel(id);
#line 1782
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1783
    fatal("session_input_channel_req: channel %d: no session", id);
  }
#line 1784
  c = channel_lookup(id);
#line 1785
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1786
    fatal("session_input_channel_req: channel %d: bad channel", id);
  }
#line 1788
  debug("session_input_channel_req: session %d channel %d request %s reply %d", s->self,
        id, rtype, reply);
#line 1795
  if (c->type == 10) {
#line 1796
    if (0) {
#line 1796
      __s1_len___4 = strlen((char const   *)rtype);
#line 1796
      __s2_len___4 = strlen("shell");
#line 1796
      if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
        goto _L___10;
      } else {
#line 1796
        if (__s1_len___4 >= 4U) {
          _L___10: /* CIL Label */ 
#line 1796
          if (! ((unsigned int )((void const   *)("shell" + 1)) - (unsigned int )((void const   *)"shell") == 1U)) {
#line 1796
            tmp___59 = 1;
          } else {
#line 1796
            if (__s2_len___4 >= 4U) {
#line 1796
              tmp___59 = 1;
            } else {
#line 1796
              tmp___59 = 0;
            }
          }
        } else {
#line 1796
          tmp___59 = 0;
        }
      }
#line 1796
      if (tmp___59) {
#line 1796
        tmp___55 = __builtin_strcmp((char const   *)rtype, "shell");
      } else {
#line 1796
        tmp___58 = __builtin_strcmp((char const   *)rtype, "shell");
#line 1796
        tmp___55 = tmp___58;
      }
    } else {
#line 1796
      tmp___58 = __builtin_strcmp((char const   *)rtype, "shell");
#line 1796
      tmp___55 = tmp___58;
    }
#line 1796
    if (tmp___55 == 0) {
#line 1797
      success = session_shell_req(s);
    } else {
#line 1798
      if (0) {
#line 1798
        __s1_len___3 = strlen((char const   *)rtype);
#line 1798
        __s2_len___3 = strlen("exec");
#line 1798
        if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
          goto _L___8;
        } else {
#line 1798
          if (__s1_len___3 >= 4U) {
            _L___8: /* CIL Label */ 
#line 1798
            if (! ((unsigned int )((void const   *)("exec" + 1)) - (unsigned int )((void const   *)"exec") == 1U)) {
#line 1798
              tmp___49 = 1;
            } else {
#line 1798
              if (__s2_len___3 >= 4U) {
#line 1798
                tmp___49 = 1;
              } else {
#line 1798
                tmp___49 = 0;
              }
            }
          } else {
#line 1798
            tmp___49 = 0;
          }
        }
#line 1798
        if (tmp___49) {
#line 1798
          tmp___45 = __builtin_strcmp((char const   *)rtype, "exec");
        } else {
#line 1798
          tmp___48 = __builtin_strcmp((char const   *)rtype, "exec");
#line 1798
          tmp___45 = tmp___48;
        }
      } else {
#line 1798
        tmp___48 = __builtin_strcmp((char const   *)rtype, "exec");
#line 1798
        tmp___45 = tmp___48;
      }
#line 1798
      if (tmp___45 == 0) {
#line 1799
        success = session_exec_req(s);
      } else {
#line 1800
        if (0) {
#line 1800
          __s1_len___2 = strlen((char const   *)rtype);
#line 1800
          __s2_len___2 = strlen("pty-req");
#line 1800
          if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
            goto _L___6;
          } else {
#line 1800
            if (__s1_len___2 >= 4U) {
              _L___6: /* CIL Label */ 
#line 1800
              if (! ((unsigned int )((void const   *)("pty-req" + 1)) - (unsigned int )((void const   *)"pty-req") == 1U)) {
#line 1800
                tmp___39 = 1;
              } else {
#line 1800
                if (__s2_len___2 >= 4U) {
#line 1800
                  tmp___39 = 1;
                } else {
#line 1800
                  tmp___39 = 0;
                }
              }
            } else {
#line 1800
              tmp___39 = 0;
            }
          }
#line 1800
          if (tmp___39) {
#line 1800
            tmp___35 = __builtin_strcmp((char const   *)rtype, "pty-req");
          } else {
#line 1800
            tmp___38 = __builtin_strcmp((char const   *)rtype, "pty-req");
#line 1800
            tmp___35 = tmp___38;
          }
        } else {
#line 1800
          tmp___38 = __builtin_strcmp((char const   *)rtype, "pty-req");
#line 1800
          tmp___35 = tmp___38;
        }
#line 1800
        if (tmp___35 == 0) {
#line 1801
          success = session_pty_req(s);
        } else {
#line 1802
          if (0) {
#line 1802
            __s1_len___1 = strlen((char const   *)rtype);
#line 1802
            __s2_len___1 = strlen("x11-req");
#line 1802
            if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
              goto _L___4;
            } else {
#line 1802
              if (__s1_len___1 >= 4U) {
                _L___4: /* CIL Label */ 
#line 1802
                if (! ((unsigned int )((void const   *)("x11-req" + 1)) - (unsigned int )((void const   *)"x11-req") == 1U)) {
#line 1802
                  tmp___29 = 1;
                } else {
#line 1802
                  if (__s2_len___1 >= 4U) {
#line 1802
                    tmp___29 = 1;
                  } else {
#line 1802
                    tmp___29 = 0;
                  }
                }
              } else {
#line 1802
                tmp___29 = 0;
              }
            }
#line 1802
            if (tmp___29) {
#line 1802
              tmp___25 = __builtin_strcmp((char const   *)rtype, "x11-req");
            } else {
#line 1802
              tmp___28 = __builtin_strcmp((char const   *)rtype, "x11-req");
#line 1802
              tmp___25 = tmp___28;
            }
          } else {
#line 1802
            tmp___28 = __builtin_strcmp((char const   *)rtype, "x11-req");
#line 1802
            tmp___25 = tmp___28;
          }
#line 1802
          if (tmp___25 == 0) {
#line 1803
            success = session_x11_req(s);
          } else {
#line 1804
            if (0) {
#line 1804
              __s1_len___0 = strlen((char const   *)rtype);
#line 1804
              __s2_len___0 = strlen("auth-agent-req@openssh.com");
#line 1804
              if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
                goto _L___2;
              } else {
#line 1804
                if (__s1_len___0 >= 4U) {
                  _L___2: /* CIL Label */ 
#line 1804
                  if (! ((unsigned int )((void const   *)("auth-agent-req@openssh.com" + 1)) - (unsigned int )((void const   *)"auth-agent-req@openssh.com") == 1U)) {
#line 1804
                    tmp___19 = 1;
                  } else {
#line 1804
                    if (__s2_len___0 >= 4U) {
#line 1804
                      tmp___19 = 1;
                    } else {
#line 1804
                      tmp___19 = 0;
                    }
                  }
                } else {
#line 1804
                  tmp___19 = 0;
                }
              }
#line 1804
              if (tmp___19) {
#line 1804
                tmp___15 = __builtin_strcmp((char const   *)rtype, "auth-agent-req@openssh.com");
              } else {
#line 1804
                tmp___18 = __builtin_strcmp((char const   *)rtype, "auth-agent-req@openssh.com");
#line 1804
                tmp___15 = tmp___18;
              }
            } else {
#line 1804
              tmp___18 = __builtin_strcmp((char const   *)rtype, "auth-agent-req@openssh.com");
#line 1804
              tmp___15 = tmp___18;
            }
#line 1804
            if (tmp___15 == 0) {
#line 1805
              success = session_auth_agent_req(s);
            } else {
#line 1806
              if (0) {
#line 1806
                __s1_len = strlen((char const   *)rtype);
#line 1806
                __s2_len = strlen("subsystem");
#line 1806
                if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
                  goto _L___0;
                } else {
#line 1806
                  if (__s1_len >= 4U) {
                    _L___0: /* CIL Label */ 
#line 1806
                    if (! ((unsigned int )((void const   *)("subsystem" + 1)) - (unsigned int )((void const   *)"subsystem") == 1U)) {
#line 1806
                      tmp___9 = 1;
                    } else {
#line 1806
                      if (__s2_len >= 4U) {
#line 1806
                        tmp___9 = 1;
                      } else {
#line 1806
                        tmp___9 = 0;
                      }
                    }
                  } else {
#line 1806
                    tmp___9 = 0;
                  }
                }
#line 1806
                if (tmp___9) {
#line 1806
                  tmp___5 = __builtin_strcmp((char const   *)rtype, "subsystem");
                } else {
#line 1806
                  tmp___8 = __builtin_strcmp((char const   *)rtype, "subsystem");
#line 1806
                  tmp___5 = tmp___8;
                }
              } else {
#line 1806
                tmp___8 = __builtin_strcmp((char const   *)rtype, "subsystem");
#line 1806
                tmp___5 = tmp___8;
              }
#line 1806
              if (tmp___5 == 0) {
#line 1807
                success = session_subsystem_req(s);
              }
            }
          }
        }
      }
    }
  }
#line 1810
  if (0) {
#line 1810
    __s1_len___5 = strlen((char const   *)rtype);
#line 1810
    __s2_len___5 = strlen("window-change");
#line 1810
    if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
      goto _L___12;
    } else {
#line 1810
      if (__s1_len___5 >= 4U) {
        _L___12: /* CIL Label */ 
#line 1810
        if (! ((unsigned int )((void const   *)("window-change" + 1)) - (unsigned int )((void const   *)"window-change") == 1U)) {
#line 1810
          tmp___69 = 1;
        } else {
#line 1810
          if (__s2_len___5 >= 4U) {
#line 1810
            tmp___69 = 1;
          } else {
#line 1810
            tmp___69 = 0;
          }
        }
      } else {
#line 1810
        tmp___69 = 0;
      }
    }
#line 1810
    if (tmp___69) {
#line 1810
      tmp___65 = __builtin_strcmp((char const   *)rtype, "window-change");
    } else {
#line 1810
      tmp___68 = __builtin_strcmp((char const   *)rtype, "window-change");
#line 1810
      tmp___65 = tmp___68;
    }
  } else {
#line 1810
    tmp___68 = __builtin_strcmp((char const   *)rtype, "window-change");
#line 1810
    tmp___65 = tmp___68;
  }
#line 1810
  if (tmp___65 == 0) {
#line 1811
    success = session_window_change_req(s);
  }
#line 1814
  if (reply) {
#line 1815
    if (success) {
#line 1815
      tmp___70 = 99;
    } else {
#line 1815
      tmp___70 = 100;
    }
#line 1815
    packet_start(tmp___70);
#line 1817
    packet_put_int((unsigned int )c->remote_id);
#line 1818
    packet_send();
  }
#line 1820
  xfree((void *)rtype);
#line 1821
  return;
}
}
#line 1823 "session.c"
void session_set_fds(Session *s , int fdin___0 , int fdout___0 , int fderr___0 ) 
{ int tmp ;

  {
#line 1826
  if (! compat20) {
#line 1827
    fatal("session_set_fds: called for proto != 2.0");
  }
#line 1832
  if (s->chanid == -1) {
#line 1833
    fatal("no channel for session %d", s->self);
  }
#line 1834
  if (fderr___0 == -1) {
#line 1834
    tmp = 0;
  } else {
#line 1834
    tmp = 1;
  }
#line 1834
  channel_set_fds(s->chanid, fdout___0, fdin___0, fderr___0, tmp, 1);
#line 1838
  return;
}
}
#line 1840 "session.c"
void session_pty_cleanup(Session *s ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1843
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1844
    return;
  } else {
#line 1843
    if (s->ttyfd == -1) {
#line 1844
      return;
    }
  }
#line 1846
  debug("session_pty_cleanup: session %d release %s", s->self, s->tty);
#line 1849
  fatal_remove_cleanup(& pty_cleanup_proc, (void *)s);
#line 1852
  record_logout(s->pid, (char const   *)(s->tty));
#line 1855
  pty_release((char const   *)(s->tty));
#line 1862
  tmp___1 = close(s->ptymaster);
#line 1862
  if (tmp___1 < 0) {
#line 1863
    tmp = __errno_location();
#line 1863
    tmp___0 = strerror(*tmp);
#line 1863
    error("close(s->ptymaster): %s", tmp___0);
  }
#line 1864
  return;
}
}
#line 1866 "session.c"
void session_exit_message(Session *s , int status ) 
{ Channel *c ;
  union __anonunion_69 __constr_expr_0 ;
  union __anonunion_70___0 __constr_expr_1 ;
  union __anonunion_71___0 __constr_expr_2 ;
  union __anonunion_72___0 __constr_expr_3 ;
  union __anonunion_73___0 __constr_expr_4 ;

  {
#line 1870
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1871
    fatal("session_close: no session");
  }
#line 1872
  c = channel_lookup(s->chanid);
#line 1873
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1874
    fatal("session_close: session %d: no channel %d", s->self, s->chanid);
  }
#line 1876
  debug("session_exit_message: session %d channel %d pid %d", s->self, s->chanid,
        s->pid);
#line 1879
  __constr_expr_4.__in = status;
#line 1879
  if ((__constr_expr_4.__i & 127) == 0) {
#line 1880
    channel_request_start(s->chanid, (char *)"exit-status", 0);
#line 1882
    __constr_expr_0.__in = status;
#line 1882
    packet_put_int((unsigned int )((__constr_expr_0.__i & 65280) >> 8));
#line 1883
    packet_send();
  } else {
#line 1884
    __constr_expr_3.__in = status;
#line 1884
    if ((int )((signed char )((__constr_expr_3.__i & 127) + 1)) >> 1 > 0) {
#line 1885
      channel_request_start(s->chanid, (char *)"exit-signal", 0);
#line 1887
      __constr_expr_1.__in = status;
#line 1887
      packet_put_int((unsigned int )(__constr_expr_1.__i & 127));
#line 1889
      __constr_expr_2.__in = status;
#line 1889
      packet_put_char(__constr_expr_2.__i & 128);
#line 1893
      packet_put_cstring("");
#line 1894
      packet_put_cstring("");
#line 1895
      packet_send();
    } else {
#line 1898
      packet_disconnect("wait returned status %04x.", status);
    }
  }
#line 1902
  debug("session_exit_message: release channel %d", s->chanid);
#line 1903
  channel_cancel_cleanup(s->chanid);
#line 1910
  if (c->ostate != 128) {
#line 1911
    (*chan_write_failed)(c);
  }
#line 1912
  s->chanid = -1;
#line 1913
  return;
}
}
#line 1915 "session.c"
void session_free(Session *s ) 
{ 

  {
#line 1918
  debug("session_free: session %d pid %d", s->self, s->pid);
#line 1919
  if (s->term) {
#line 1920
    xfree((void *)s->term);
  }
#line 1921
  if (s->display) {
#line 1922
    xfree((void *)s->display);
  }
#line 1923
  if (s->auth_data) {
#line 1924
    xfree((void *)s->auth_data);
  }
#line 1925
  if (s->auth_proto) {
#line 1926
    xfree((void *)s->auth_proto);
  }
#line 1927
  s->used = 0;
#line 1928
  return;
}
}
#line 1930 "session.c"
void session_close(Session *s ) 
{ 

  {
#line 1933
  session_pty_cleanup(s);
#line 1934
  session_free(s);
#line 1935
  session_proctitle(s);
#line 1936
  return;
}
}
#line 1938 "session.c"
void session_close_by_pid(pid_t pid , int status ) 
{ Session *s ;
  Session *tmp ;

  {
#line 1941
  tmp = session_by_pid(pid);
#line 1941
  s = tmp;
#line 1942
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1943
    debug("session_close_by_pid: no session for pid %d", s->pid);
#line 1944
    return;
  }
#line 1946
  if (s->chanid != -1) {
#line 1947
    session_exit_message(s, status);
  }
#line 1948
  session_close(s);
#line 1949
  return;
}
}
#line 1955 "session.c"
void session_close_by_channel(int id , void *arg ) 
{ Session *s ;
  Session *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1958
  tmp = session_by_channel(id);
#line 1958
  s = tmp;
#line 1959
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1960
    debug("session_close_by_channel: no session for channel %d", id);
#line 1961
    return;
  }
#line 1964
  channel_cancel_cleanup(s->chanid);
#line 1965
  s->chanid = -1;
#line 1967
  debug("session_close_by_channel: channel %d kill %d", id, s->pid);
#line 1968
  if (s->pid == 0) {
#line 1970
    session_close(s);
  } else {
#line 1973
    if (s->ttyfd == -1) {
#line 1973
      tmp___2 = 15;
    } else {
#line 1973
      tmp___2 = 1;
    }
#line 1973
    tmp___3 = kill(s->pid, tmp___2);
#line 1973
    if (tmp___3 < 0) {
#line 1974
      tmp___0 = __errno_location();
#line 1974
      tmp___1 = strerror(*tmp___0);
#line 1974
      error("session_close_by_channel: kill %d: %s", s->pid, tmp___1);
    }
  }
#line 1977
  return;
}
}
#line 1982 "session.c"
static char buf___1[1024]  ;
#line 1979 "session.c"
char *session_tty_list(void) 
{ int i ;
  Session *s ;
  char *tmp ;

  {
#line 1984
  buf___1[0] = (char )'\000';
#line 1985
  i = 0;
#line 1985
  while (i < 10) {
#line 1986
    s = & sessions[i];
#line 1987
    if (s->used) {
#line 1987
      if (s->ttyfd != -1) {
#line 1988
        if ((int )buf___1[0] != 0) {
#line 1989
          strlcat(buf___1, ",", sizeof(buf___1));
        }
#line 1990
        tmp = strrchr((char const   *)(s->tty), '/');
#line 1990
        strlcat(buf___1, (char const   *)(tmp + 1), sizeof(buf___1));
      }
    }
#line 1985
    i ++;
  }
#line 1993
  if ((int )buf___1[0] == 0) {
#line 1994
    strlcpy(buf___1, "notty", sizeof(buf___1));
  }
#line 1995
  return (buf___1);
}
}
#line 1998 "session.c"
void session_proctitle(Session *s ) 
{ char *tmp ;

  {
#line 2001
  if ((unsigned int )s->pw == (unsigned int )((void *)0)) {
#line 2002
    error("no user for session %d", s->self);
  } else {
#line 2004
    tmp = session_tty_list();
#line 2004
    setproctitle("%s@%s", (s->pw)->pw_name, tmp);
  }
#line 2005
  return;
}
}
#line 2007 "session.c"
void do_authenticated2(Authctxt *authctxt ) 
{ 

  {
#line 2014
  alarm(0U);
#line 2015
  if (startup_pipe != -1) {
#line 2016
    close(startup_pipe);
#line 2017
    startup_pipe = -1;
  }
#line 2025
  server_loop2();
#line 2026
  if (xauthfile) {
#line 2027
    xauthfile_cleanup_proc((void *)0);
  }
#line 2028
  return;
}
}
#line 1 "groupaccess.o"
#pragma merger(0,"./groupaccess.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 103 "/usr/include/grp.h"
extern struct group *getgrgid(__gid_t __gid ) ;
#line 188
extern int getgrouplist(char const   *__user , __gid_t __group , __gid_t *__groups ,
                        int *__ngroups ) ;
#line 34 "groupaccess.c"
static int ngroups  ;
#line 35 "groupaccess.c"
static char *groups_byname[65537]  ;
#line 37 "groupaccess.c"
int ga_init(char const   *user , gid_t base ) 
{ gid_t groups_bygid[65537] ;
  int i ;
  int j ;
  struct group *gr ;
  int tmp ;
  int tmp___0 ;

  {
#line 44
  if (ngroups > 0) {
#line 45
    ga_free();
  }
#line 47
  ngroups = (int )(sizeof(groups_bygid) / sizeof(gid_t ));
#line 48
  tmp = getgrouplist(user, base, groups_bygid, & ngroups);
#line 48
  if (tmp == -1) {
#line 49
    log("getgrouplist: groups list too small");
  }
#line 50
  i = 0;
#line 50
  j = 0;
#line 50
  while (i < ngroups) {
#line 51
    gr = getgrgid(groups_bygid[i]);
#line 51
    if ((unsigned int )gr != (unsigned int )((void *)0)) {
#line 52
      tmp___0 = j;
#line 52
      j ++;
#line 52
      groups_byname[tmp___0] = xstrdup((char const   *)gr->gr_name);
    }
#line 50
    i ++;
  }
#line 53
  ngroups = j;
#line 53
  return (ngroups);
}
}
#line 56 "groupaccess.c"
int ga_match(char * const  *groups , int n___0 ) 
{ int i ;
  int j ;
  int tmp ;

  {
#line 61
  i = 0;
#line 61
  while (i < ngroups) {
#line 62
    j = 0;
#line 62
    while (j < n___0) {
#line 63
      tmp = match_pattern((char const   *)groups_byname[i], (char const   *)*(groups + j));
#line 63
      if (tmp) {
#line 64
        return (1);
      }
#line 62
      j ++;
    }
#line 61
    i ++;
  }
#line 65
  return (0);
}
}
#line 68 "groupaccess.c"
void ga_free(void) 
{ int i ;

  {
#line 73
  if (ngroups > 0) {
#line 74
    i = 0;
#line 74
    while (i < ngroups) {
#line 75
      xfree((void *)groups_byname[i]);
#line 74
      i ++;
    }
#line 76
    ngroups = 0;
  }
#line 78
  return;
}
}
