/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

#line 214 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stddef.h"
typedef unsigned int size_t;
#line 183 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 195 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 36 "/usr/include/bits/socket.h"
typedef __socklen_t socklen_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 145 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 107 "/usr/include/openssl/ossl_typ.h"
struct bignum_st;
#line 107 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_st BIGNUM;
#line 108
struct bignum_ctx;
#line 108 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_ctx BN_CTX;
#line 109
struct bn_blinding_st;
#line 109 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_blinding_st BN_BLINDING;
#line 110
struct bn_mont_ctx_st;
#line 110 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_mont_ctx_st BN_MONT_CTX;
#line 112
struct bn_gencb_st;
#line 112 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_gencb_st BN_GENCB;
#line 125
struct dsa_st;
#line 125 "/usr/include/openssl/ossl_typ.h"
typedef struct dsa_st DSA;
#line 126
struct dsa_method;
#line 126 "/usr/include/openssl/ossl_typ.h"
typedef struct dsa_method DSA_METHOD;
#line 128
struct rsa_st;
#line 128 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_st RSA;
#line 129
struct rsa_meth_st;
#line 129 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_meth_st RSA_METHOD;
#line 154
struct engine_st;
#line 154 "/usr/include/openssl/ossl_typ.h"
typedef struct engine_st ENGINE;
#line 165
struct crypto_ex_data_st;
#line 165 "/usr/include/openssl/ossl_typ.h"
typedef struct crypto_ex_data_st CRYPTO_EX_DATA;
#line 285 "/usr/include/openssl/bn.h"
struct bignum_st {
   unsigned long *d ;
   int top ;
   int dmax ;
   int neg ;
   int flags ;
};
#line 296 "/usr/include/openssl/bn.h"
struct bn_mont_ctx_st {
   int ri ;
   BIGNUM RR ;
   BIGNUM N ;
   BIGNUM Ni ;
   unsigned long n0 ;
   int flags ;
};
#line 320 "/usr/include/openssl/bn.h"
union __anonunion_cb_62 {
   void (*cb_1)(int  , int  , void * ) ;
   int (*cb_2)(int  , int  , BN_GENCB * ) ;
};
#line 320 "/usr/include/openssl/bn.h"
struct bn_gencb_st {
   unsigned int ver ;
   void *arg ;
   union __anonunion_cb_62 cb ;
};
#line 66 "/usr/include/openssl/stack.h"
struct stack_st {
   int num ;
   char **data ;
   int sorted ;
   int num_alloc ;
   int (*comp)(char const   * const  * , char const   * const  * ) ;
};
#line 66 "/usr/include/openssl/stack.h"
typedef struct stack_st STACK;
#line 283 "/usr/include/openssl/crypto.h"
struct crypto_ex_data_st {
   STACK *sk ;
   int dummy ;
};
#line 85 "/usr/include/openssl/rsa.h"
struct rsa_meth_st {
   char const   *name ;
   int (*rsa_pub_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_pub_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_priv_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_priv_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_mod_exp)(BIGNUM *r0 , BIGNUM const   *I , RSA *rsa , BN_CTX *ctx ) ;
   int (*bn_mod_exp)(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(RSA *rsa ) ;
   int (*finish)(RSA *rsa ) ;
   int flags ;
   char *app_data ;
   int (*rsa_sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
                   unsigned int *siglen , RSA const   *rsa ) ;
   int (*rsa_verify)(int dtype , unsigned char const   *m , unsigned int m_length ,
                     unsigned char *sigbuf , unsigned int siglen , RSA const   *rsa ) ;
   int (*rsa_keygen)(RSA *rsa , int bits , BIGNUM *e , BN_GENCB *cb ) ;
};
#line 128 "/usr/include/openssl/rsa.h"
struct rsa_st {
   int pad ;
   long version ;
   RSA_METHOD const   *meth ;
   ENGINE *engine ;
   BIGNUM *n ;
   BIGNUM *e ;
   BIGNUM *d ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *dmp1 ;
   BIGNUM *dmq1 ;
   BIGNUM *iqmp ;
   CRYPTO_EX_DATA ex_data ;
   int references ;
   int flags ;
   BN_MONT_CTX *_method_mod_n ;
   BN_MONT_CTX *_method_mod_p ;
   BN_MONT_CTX *_method_mod_q ;
   char *bignum_data ;
   BN_BLINDING *blinding ;
   BN_BLINDING *mt_blinding ;
};
#line 19 "buffer.h"
struct __anonstruct_Buffer_75 {
   char *buf ;
   unsigned int alloc ;
   unsigned int offset ;
   unsigned int end ;
};
#line 19 "buffer.h"
typedef struct __anonstruct_Buffer_75 Buffer;
#line 106 "/usr/include/openssl/dsa.h"
struct DSA_SIG_st {
   BIGNUM *r ;
   BIGNUM *s ;
};
#line 106 "/usr/include/openssl/dsa.h"
typedef struct DSA_SIG_st DSA_SIG;
#line 112 "/usr/include/openssl/dsa.h"
struct dsa_method {
   char const   *name ;
   DSA_SIG *(*dsa_do_sign)(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
   int (*dsa_sign_setup)(DSA *dsa , BN_CTX *ctx_in , BIGNUM **kinvp , BIGNUM **rp ) ;
   int (*dsa_do_verify)(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                        DSA *dsa ) ;
   int (*dsa_mod_exp)(DSA *dsa , BIGNUM *rr , BIGNUM *a1 , BIGNUM *p1 , BIGNUM *a2 ,
                      BIGNUM *p2 , BIGNUM *m , BN_CTX *ctx , BN_MONT_CTX *in_mont ) ;
   int (*bn_mod_exp)(DSA *dsa , BIGNUM *r , BIGNUM *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DSA *dsa ) ;
   int (*finish)(DSA *dsa ) ;
   int flags ;
   char *app_data ;
   int (*dsa_paramgen)(DSA *dsa , int bits , unsigned char *seed , int seed_len ,
                       int *counter_ret , unsigned long *h_ret , BN_GENCB *cb ) ;
   int (*dsa_keygen)(DSA *dsa ) ;
};
#line 139 "/usr/include/openssl/dsa.h"
struct dsa_st {
   int pad ;
   long version ;
   int write_params ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *g ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   BIGNUM *kinv ;
   BIGNUM *r ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DSA_METHOD const   *meth ;
   ENGINE *engine ;
};
#line 27 "key.h"
struct Key;
#line 27 "key.h"
typedef struct Key Key;
#line 33 "key.h"
struct Key {
   int type ;
   RSA *rsa ;
   DSA *dsa ;
};
#line 47 "authfd.h"
struct __anonstruct_AuthenticationConnection_77 {
   int fd ;
   Buffer identities ;
   int howmany ;
};
#line 47 "authfd.h"
typedef struct __anonstruct_AuthenticationConnection_77 AuthenticationConnection;
#line 34 "/usr/include/bits/types.h"
typedef unsigned char __u_char;
#line 36 "/usr/include/bits/types.h"
typedef unsigned int __u_int;
#line 59 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 60 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 137 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 143 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 144 "/usr/include/bits/types.h"
typedef long __off_t;
#line 145 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 152 "/usr/include/bits/types.h"
typedef long __time_t;
#line 167 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 172 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 35 "/usr/include/sys/types.h"
typedef __u_char u_char;
#line 37 "/usr/include/sys/types.h"
typedef __u_int u_int;
#line 88 "/usr/include/sys/types.h"
typedef __off_t off_t;
#line 203 "/usr/include/sys/types.h"
typedef unsigned int u_int32_t;
#line 121 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 177 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 183 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 268 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/openssl/ossl_typ.h"
struct asn1_string_st;
#line 79 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_INTEGER;
#line 80 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_ENUMERATED;
#line 81 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_BIT_STRING;
#line 82 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_OCTET_STRING;
#line 83 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_PRINTABLESTRING;
#line 84 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_T61STRING;
#line 85 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_IA5STRING;
#line 86 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_GENERALSTRING;
#line 87 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UNIVERSALSTRING;
#line 88 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_BMPSTRING;
#line 89 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UTCTIME;
#line 91 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_GENERALIZEDTIME;
#line 92 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_VISIBLESTRING;
#line 93 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UTF8STRING;
#line 94 "/usr/include/openssl/ossl_typ.h"
typedef int ASN1_BOOLEAN;
#line 116
struct evp_cipher_st;
#line 116 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_cipher_st EVP_CIPHER;
#line 117
struct evp_cipher_ctx_st;
#line 117 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_cipher_ctx_st EVP_CIPHER_CTX;
#line 281 "/usr/include/openssl/crypto.h"
struct bio_st;
#line 256 "/usr/include/openssl/bio.h"
typedef struct bio_st BIO;
#line 258 "/usr/include/openssl/bio.h"
typedef void bio_info_cb(struct bio_st * , int  , char const   * , int  , long  ,
                         long  );
#line 261 "/usr/include/openssl/bio.h"
struct bio_method_st {
   int type ;
   char const   *name ;
   int (*bwrite)(BIO * , char const   * , int  ) ;
   int (*bread)(BIO * , char * , int  ) ;
   int (*bputs)(BIO * , char const   * ) ;
   int (*bgets)(BIO * , char * , int  ) ;
   long (*ctrl)(BIO * , int  , long  , void * ) ;
   int (*create)(BIO * ) ;
   int (*destroy)(BIO * ) ;
   long (*callback_ctrl)(BIO * , int  , bio_info_cb * ) ;
};
#line 261 "/usr/include/openssl/bio.h"
typedef struct bio_method_st BIO_METHOD;
#line 290 "/usr/include/openssl/bio.h"
struct bio_st {
   BIO_METHOD *method ;
   long (*callback)(struct bio_st * , int  , char const   * , int  , long  , long  ) ;
   char *cb_arg ;
   int init ;
   int shutdown ;
   int flags ;
   int retry_reason ;
   int num ;
   void *ptr ;
   struct bio_st *next_bio ;
   struct bio_st *prev_bio ;
   int references ;
   unsigned long num_read ;
   unsigned long num_write ;
   CRYPTO_EX_DATA ex_data ;
};
#line 206 "/usr/include/openssl/asn1.h"
struct asn1_object_st {
   char const   *sn ;
   char const   *ln ;
   int nid ;
   int length ;
   unsigned char *data ;
   int flags ;
};
#line 206 "/usr/include/openssl/asn1.h"
typedef struct asn1_object_st ASN1_OBJECT;
#line 222 "/usr/include/openssl/asn1.h"
struct asn1_string_st {
   int length ;
   int type ;
   unsigned char *data ;
   long flags ;
};
#line 222 "/usr/include/openssl/asn1.h"
typedef struct asn1_string_st ASN1_STRING;
#line 488 "/usr/include/openssl/asn1.h"
union __anonunion_value_64 {
   char *ptr ;
   ASN1_BOOLEAN boolean ;
   ASN1_STRING *asn1_string ;
   ASN1_OBJECT *object ;
   ASN1_INTEGER *integer ;
   ASN1_ENUMERATED *enumerated ;
   ASN1_BIT_STRING *bit_string ;
   ASN1_OCTET_STRING *octet_string ;
   ASN1_PRINTABLESTRING *printablestring ;
   ASN1_T61STRING *t61string ;
   ASN1_IA5STRING *ia5string ;
   ASN1_GENERALSTRING *generalstring ;
   ASN1_BMPSTRING *bmpstring ;
   ASN1_UNIVERSALSTRING *universalstring ;
   ASN1_UTCTIME *utctime ;
   ASN1_GENERALIZEDTIME *generalizedtime ;
   ASN1_VISIBLESTRING *visiblestring ;
   ASN1_UTF8STRING *utf8string ;
   ASN1_STRING *set ;
   ASN1_STRING *sequence ;
};
#line 488 "/usr/include/openssl/asn1.h"
struct asn1_type_st {
   int type ;
   union __anonunion_value_64 value ;
};
#line 488 "/usr/include/openssl/asn1.h"
typedef struct asn1_type_st ASN1_TYPE;
#line 297 "/usr/include/openssl/evp.h"
struct evp_cipher_st {
   int nid ;
   int block_size ;
   int key_len ;
   int iv_len ;
   unsigned long flags ;
   int (*init)(EVP_CIPHER_CTX *ctx , unsigned char const   *key , unsigned char const   *iv ,
               int enc ) ;
   int (*do_cipher)(EVP_CIPHER_CTX *ctx , unsigned char *out , unsigned char const   *in ,
                    unsigned int inl ) ;
   int (*cleanup)(EVP_CIPHER_CTX * ) ;
   int ctx_size ;
   int (*set_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*get_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*ctrl)(EVP_CIPHER_CTX * , int type , int arg , void *ptr ) ;
   void *app_data ;
};
#line 357 "/usr/include/openssl/evp.h"
struct evp_cipher_ctx_st {
   EVP_CIPHER const   *cipher ;
   ENGINE *engine ;
   int encrypt ;
   int buf_len ;
   unsigned char oiv[16] ;
   unsigned char iv[16] ;
   unsigned char buf[32] ;
   int num ;
   void *app_data ;
   int key_len ;
   unsigned long flags ;
   void *cipher_data ;
   int final_used ;
   int block_mask ;
   unsigned char final[32] ;
};
#line 529 "/usr/include/openssl/pem.h"
typedef int pem_password_cb(char *buf , int size , int rwflag , void *userdata );
#line 78 "/usr/include/openssl/des.h"
typedef unsigned char DES_cblock[8];
#line 83 "/usr/include/openssl/des.h"
union __anonunion_ks_73 {
   DES_cblock cblock ;
   unsigned long deslong[2] ;
};
#line 83 "/usr/include/openssl/des.h"
struct DES_ks {
   union __anonunion_ks_73 ks[16] ;
};
#line 83 "/usr/include/openssl/des.h"
typedef struct DES_ks DES_key_schedule;
#line 101 "/usr/include/openssl/blowfish.h"
struct bf_key_st {
   unsigned int P[18] ;
   unsigned int S[1024] ;
};
#line 71 "/usr/include/openssl/rc4.h"
struct rc4_key_st {
   unsigned int x ;
   unsigned int y ;
   unsigned int data[256] ;
};
#line 71 "/usr/include/openssl/rc4.h"
typedef struct rc4_key_st RC4_KEY;
#line 80 "/usr/include/openssl/cast.h"
struct cast_key_st {
   unsigned long data[32] ;
   int short_key ;
};
#line 80 "/usr/include/openssl/cast.h"
typedef struct cast_key_st CAST_KEY;
#line 10 "rijndael.h"
typedef u_int32_t u4byte;
#line 16 "rijndael.h"
struct _rijndael_ctx {
   u4byte k_len ;
   int decrypt ;
   u4byte e_key[64] ;
   u4byte d_key[64] ;
};
#line 16 "rijndael.h"
typedef struct _rijndael_ctx rijndael_ctx;
#line 62 "cipher.h"
struct Cipher;
#line 62 "cipher.h"
typedef struct Cipher Cipher;
#line 63
struct CipherContext;
#line 63 "cipher.h"
typedef struct CipherContext CipherContext;
#line 65 "cipher.h"
struct __anonstruct_des_76 {
   DES_key_schedule key ;
   DES_cblock iv ;
};
#line 65 "cipher.h"
struct __anonstruct_des3_77 {
   DES_key_schedule key1 ;
   DES_key_schedule key2 ;
   DES_cblock iv2 ;
   DES_key_schedule key3 ;
   DES_cblock iv3 ;
};
#line 65 "cipher.h"
struct __anonstruct_bf_78 {
   struct bf_key_st key ;
   u_char iv[8] ;
};
#line 65 "cipher.h"
struct __anonstruct_cast_79 {
   CAST_KEY key ;
   u_char iv[8] ;
};
#line 65 "cipher.h"
struct __anonstruct_rijndael_80 {
   u4byte iv[4] ;
   rijndael_ctx enc ;
   rijndael_ctx dec ;
};
#line 65 "cipher.h"
union __anonunion_u_75 {
   struct __anonstruct_des_76 des ;
   struct __anonstruct_des3_77 des3 ;
   struct __anonstruct_bf_78 bf ;
   struct __anonstruct_cast_79 cast ;
   struct __anonstruct_rijndael_80 rijndael ;
   RC4_KEY rc4 ;
};
#line 65 "cipher.h"
struct CipherContext {
   union __anonunion_u_75 u ;
   Cipher *cipher ;
};
#line 95 "cipher.h"
struct Cipher {
   char *name ;
   int number ;
   u_int block_size ;
   u_int key_len ;
   void (*setkey)(CipherContext * , u_char const   * , u_int  ) ;
   void (*setiv)(CipherContext * , u_char const   * , u_int  ) ;
   void (*encrypt)(CipherContext * , u_char * , u_char const   * , u_int  ) ;
   void (*decrypt)(CipherContext * , u_char * , u_char const   * , u_int  ) ;
};
#line 44 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 45 "/usr/include/bits/types.h"
typedef unsigned int __uint32_t;
#line 202 "/usr/include/sys/types.h"
typedef unsigned short u_int16_t;
#line 162 "/usr/include/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   __uint32_t __ss_align ;
   char __ss_padding[128U - 2U * sizeof(__uint32_t )] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 92 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 136 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 137 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 193 "/usr/include/netinet/in.h"
union __anonunion_in6_u_21 {
   uint8_t u6_addr8[16] ;
   uint16_t u6_addr16[8] ;
   uint32_t u6_addr32[4] ;
};
#line 193 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion_in6_u_21 in6_u ;
};
#line 219 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 233 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 321 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 538 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 35 "/usr/include/bits/types.h"
typedef unsigned short __u_short;
#line 146 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 36 "/usr/include/sys/types.h"
typedef __u_short u_short;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024U / (8U * sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 314 "/usr/include/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 58 "channels.h"
struct Channel;
#line 59 "channels.h"
typedef struct Channel Channel;
#line 61 "channels.h"
typedef void channel_callback_fn(int id , void *arg );
#line 62 "channels.h"
typedef int channel_filter_fn(struct Channel *c , char *buf , int len );
#line 64 "channels.h"
struct Channel {
   int type ;
   int self ;
   int remote_id ;
   int istate ;
   int ostate ;
   int flags ;
   int rfd ;
   int wfd ;
   int efd ;
   int sock ;
   Buffer input ;
   Buffer output ;
   Buffer extended ;
   char path[200] ;
   int listening_port ;
   int host_port ;
   char *remote_name ;
   int remote_window ;
   int remote_maxpacket ;
   int local_window ;
   int local_window_max ;
   int local_consumed ;
   int local_maxpacket ;
   int extended_usage ;
   char *ctype ;
   channel_callback_fn *cb_fn ;
   void *cb_arg ;
   int cb_event ;
   channel_callback_fn *dettach_user ;
   channel_filter_fn *input_filter ;
};
#line 75 "nchan.h"
typedef void chan_event_fn(Channel *c );
#line 113 "channels.c"
struct __anonstruct_ForwardPermission_80 {
   char *host_to_connect ;
   u_short port_to_connect ;
   u_short listen_port ;
};
#line 113 "channels.c"
typedef struct __anonstruct_ForwardPermission_80 ForwardPermission;
#line 338 "channels.c"
typedef void chan_fn(Channel *c , fd_set *readset , fd_set *writeset );
#line 79 "/usr/include/openssl/des.h"
typedef unsigned char const_DES_cblock[8];
#line 101 "/usr/include/openssl/blowfish.h"
typedef struct bf_key_st BF_KEY;
#line 99 "/usr/include/openssl/md5.h"
struct MD5state_st {
   unsigned int A ;
   unsigned int B ;
   unsigned int C ;
   unsigned int D ;
   unsigned int Nl ;
   unsigned int Nh ;
   unsigned int data[16] ;
   unsigned int num ;
};
#line 99 "/usr/include/openssl/md5.h"
typedef struct MD5state_st MD5_CTX;
#line 148 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 28 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024U / (8U * sizeof(unsigned long ))] ;
};
#line 28 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 25 "/usr/include/bits/termios.h"
typedef unsigned char cc_t;
#line 26 "/usr/include/bits/termios.h"
typedef unsigned int speed_t;
#line 27 "/usr/include/bits/termios.h"
typedef unsigned int tcflag_t;
#line 30 "/usr/include/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 33 "/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__kill_26 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__timer_27 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__rt_28 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_29 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_30 {
   void *si_addr ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_31 {
   long si_band ;
   int si_fd ;
};
#line 51 "/usr/include/bits/siginfo.h"
union __anonunion__sifields_25 {
   int _pad[128U / sizeof(int ) - 3U] ;
   struct __anonstruct__kill_26 _kill ;
   struct __anonstruct__timer_27 _timer ;
   struct __anonstruct__rt_28 _rt ;
   struct __anonstruct__sigchld_29 _sigchld ;
   struct __anonstruct__sigfault_30 _sigfault ;
   struct __anonstruct__sigpoll_31 _sigpoll ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_25 _sifields ;
};
#line 51 "/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 25 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_43 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_43 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 44 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 343 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *buffer ;
   unsigned long allocated ;
   unsigned long used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 407 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 410 "/usr/include/regex.h"
typedef int regoff_t;
#line 434 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_76 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 434 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_76 regmatch_t;
#line 61 "compat.c"
struct __anonstruct_check_77 {
   char *pat ;
   int bugs ;
};
#line 261 "/usr/include/zconf.h"
typedef unsigned char Byte;
#line 263 "/usr/include/zconf.h"
typedef unsigned int uInt;
#line 264 "/usr/include/zconf.h"
typedef unsigned long uLong;
#line 270 "/usr/include/zconf.h"
typedef Byte Bytef;
#line 279 "/usr/include/zconf.h"
typedef void *voidpf;
#line 80 "/usr/include/zlib.h"
struct internal_state;
#line 82 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 82 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 103 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 1346 "/usr/include/zlib.h"
struct internal_state {
   int dummy ;
};
#line 29 "dispatch.h"
typedef void dispatch_fn(int type , int plen , void *ctxt );
#line 118 "/usr/include/openssl/ossl_typ.h"
struct env_md_st;
#line 118 "/usr/include/openssl/ossl_typ.h"
typedef struct env_md_st EVP_MD;
#line 119
struct env_md_ctx_st;
#line 119 "/usr/include/openssl/ossl_typ.h"
typedef struct env_md_ctx_st EVP_MD_CTX;
#line 220 "/usr/include/openssl/evp.h"
struct env_md_st {
   int type ;
   int pkey_type ;
   int md_size ;
   unsigned long flags ;
   int (*init)(EVP_MD_CTX *ctx ) ;
   int (*update)(EVP_MD_CTX *ctx , void const   *data , size_t count ) ;
   int (*final)(EVP_MD_CTX *ctx , unsigned char *md ) ;
   int (*copy)(EVP_MD_CTX *to , EVP_MD_CTX const   *from ) ;
   int (*cleanup)(EVP_MD_CTX *ctx ) ;
   int (*sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
               unsigned int *siglen , void *key ) ;
   int (*verify)(int type , unsigned char const   *m , unsigned int m_length , unsigned char const   *sigbuf ,
                 unsigned int siglen , void *key ) ;
   int required_pkey_type[5] ;
   int block_size ;
   int ctx_size ;
};
#line 280 "/usr/include/openssl/evp.h"
struct env_md_ctx_st {
   EVP_MD const   *digest ;
   ENGINE *engine ;
   unsigned long flags ;
   void *md_data ;
};
#line 75 "/usr/include/openssl/hmac.h"
struct hmac_ctx_st {
   EVP_MD const   *md ;
   EVP_MD_CTX md_ctx ;
   EVP_MD_CTX i_ctx ;
   EVP_MD_CTX o_ctx ;
   unsigned int key_length ;
   unsigned char key[128] ;
};
#line 75 "/usr/include/openssl/hmac.h"
typedef struct hmac_ctx_st HMAC_CTX;
#line 21 "hostfile.h"
enum __anonenum_HostStatus_75 {
    HOST_OK = 0,
    HOST_NEW = 1,
    HOST_CHANGED = 2
} ;
#line 21 "hostfile.h"
typedef enum __anonenum_HostStatus_75 HostStatus;
#line 122 "/usr/include/openssl/ossl_typ.h"
struct dh_st;
#line 122 "/usr/include/openssl/ossl_typ.h"
typedef struct dh_st DH;
#line 123
struct dh_method;
#line 123 "/usr/include/openssl/ossl_typ.h"
typedef struct dh_method DH_METHOD;
#line 95 "/usr/include/openssl/dh.h"
struct dh_method {
   char const   *name ;
   int (*generate_key)(DH *dh ) ;
   int (*compute_key)(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
   int (*bn_mod_exp)(DH const   *dh , BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p ,
                     BIGNUM const   *m , BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DH *dh ) ;
   int (*finish)(DH *dh ) ;
   int flags ;
   char *app_data ;
   int (*generate_params)(DH *dh , int prime_len , int generator , BN_GENCB *cb ) ;
};
#line 113 "/usr/include/openssl/dh.h"
struct dh_st {
   int pad ;
   int version ;
   BIGNUM *p ;
   BIGNUM *g ;
   long length ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   BIGNUM *q ;
   BIGNUM *j ;
   unsigned char *seed ;
   int seedlen ;
   BIGNUM *counter ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DH_METHOD const   *meth ;
   ENGINE *engine ;
};
#line 56 "kex.h"
struct Kex;
#line 56 "kex.h"
typedef struct Kex Kex;
#line 57
struct Mac;
#line 57 "kex.h"
typedef struct Mac Mac;
#line 58
struct Comp;
#line 58 "kex.h"
typedef struct Comp Comp;
#line 59
struct Enc;
#line 59 "kex.h"
typedef struct Enc Enc;
#line 61 "kex.h"
struct Enc {
   char *name ;
   Cipher *cipher ;
   int enabled ;
   unsigned char *key ;
   unsigned char *iv ;
};
#line 68 "kex.h"
struct Mac {
   char *name ;
   int enabled ;
   EVP_MD *md ;
   int mac_len ;
   unsigned char *key ;
   int key_len ;
};
#line 76 "kex.h"
struct Comp {
   int type ;
   int enabled ;
   char *name ;
};
#line 81 "kex.h"
struct Kex {
   Enc enc[2] ;
   Mac mac[2] ;
   Comp comp[2] ;
   int we_need ;
   int server ;
   char *name ;
   char *hostkeyalg ;
   int kex_type ;
};
#line 43 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 105 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 425 "ssh.h"
enum __anonenum_SyslogFacility_73 {
    SYSLOG_FACILITY_DAEMON = 0,
    SYSLOG_FACILITY_USER = 1,
    SYSLOG_FACILITY_AUTH = 2,
    SYSLOG_FACILITY_LOCAL0 = 3,
    SYSLOG_FACILITY_LOCAL1 = 4,
    SYSLOG_FACILITY_LOCAL2 = 5,
    SYSLOG_FACILITY_LOCAL3 = 6,
    SYSLOG_FACILITY_LOCAL4 = 7,
    SYSLOG_FACILITY_LOCAL5 = 8,
    SYSLOG_FACILITY_LOCAL6 = 9,
    SYSLOG_FACILITY_LOCAL7 = 10
} ;
#line 425 "ssh.h"
typedef enum __anonenum_SyslogFacility_73 SyslogFacility;
#line 439
enum __anonenum_LogLevel_74 {
    SYSLOG_LEVEL_QUIET = 0,
    SYSLOG_LEVEL_FATAL = 1,
    SYSLOG_LEVEL_ERROR = 2,
    SYSLOG_LEVEL_INFO = 3,
    SYSLOG_LEVEL_VERBOSE = 4,
    SYSLOG_LEVEL_DEBUG1 = 5,
    SYSLOG_LEVEL_DEBUG2 = 6,
    SYSLOG_LEVEL_DEBUG3 = 7
} ;
#line 439 "ssh.h"
typedef enum __anonenum_LogLevel_74 LogLevel;
#line 120 "log.c"
struct fatal_cleanup {
   struct fatal_cleanup *next ;
   void (*proc)(void * ) ;
   void *context ;
};
#line 183 "log.c"
struct __anonstruct_log_facilities_75 {
   char const   *name ;
   SyslogFacility val ;
};
#line 201 "log.c"
struct __anonstruct_log_levels_76 {
   char const   *name ;
   LogLevel val ;
};
#line 154 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 201 "/usr/include/sys/types.h"
typedef unsigned char u_int8_t;
#line 8 "rijndael.h"
typedef u_int8_t u1byte;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 85 "/usr/include/sys/select.h"
typedef __fd_mask fd_mask;
#line 75 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 27 "servconf.h"
struct __anonstruct_ServerOptions_75 {
   unsigned int num_ports ;
   unsigned int ports_from_cmdline ;
   u_short ports[256] ;
   char *listen_addr ;
   struct addrinfo *listen_addrs ;
   char *host_key_file ;
   char *host_dsa_key_file ;
   char *pid_file ;
   int server_key_bits ;
   int login_grace_time ;
   int key_regeneration_time ;
   int permit_root_login ;
   int ignore_rhosts ;
   int ignore_user_known_hosts ;
   int print_motd ;
   int check_mail ;
   int x11_forwarding ;
   int x11_display_offset ;
   char *xauth_location ;
   int strict_modes ;
   int keepalives ;
   char *ciphers ;
   int protocol ;
   int gateway_ports ;
   SyslogFacility log_facility ;
   LogLevel log_level ;
   int rhosts_authentication ;
   int rhosts_rsa_authentication ;
   int rsa_authentication ;
   int dsa_authentication ;
   int password_authentication ;
   int kbd_interactive_authentication ;
   int permit_empty_passwd ;
   int use_login ;
   int allow_tcp_forwarding ;
   unsigned int num_allow_users ;
   char *allow_users[256] ;
   unsigned int num_deny_users ;
   char *deny_users[256] ;
   unsigned int num_allow_groups ;
   char *allow_groups[256] ;
   unsigned int num_deny_groups ;
   char *deny_groups[256] ;
   unsigned int num_subsystems ;
   char *subsystem_name[256] ;
   char *subsystem_command[256] ;
   int max_startups_begin ;
   int max_startups_rate ;
   int max_startups ;
};
#line 27 "servconf.h"
typedef struct __anonstruct_ServerOptions_75 ServerOptions;
#line 142 "sshd.c"
struct __anonstruct_sensitive_data_77 {
   RSA *private_key ;
   RSA *host_key ;
   Key *dsa_host_key ;
};
#line 43 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 27 "auth.h"
struct Authctxt;
#line 27 "auth.h"
typedef struct Authctxt Authctxt;
#line 28 "auth.h"
struct Authctxt {
   int success ;
   int valid ;
   int attempt ;
   char *user ;
   char *service ;
   struct passwd *pw ;
};
#line 75 "auth2.c"
struct Authmethod;
#line 75 "auth2.c"
typedef struct Authmethod Authmethod;
#line 76 "auth2.c"
struct Authmethod {
   char *name ;
   int (*userauth)(Authctxt *authctxt ) ;
   int *enabled ;
};
#line 512 "ssh.h"
struct envstring {
   struct envstring *next ;
   char *s ;
};
#line 18 "/usr/include/security/_pam_types.h"
struct pam_handle;
#line 18 "/usr/include/security/_pam_types.h"
typedef struct pam_handle pam_handle_t;
#line 244 "/usr/include/security/_pam_types.h"
struct pam_message {
   int msg_style ;
   char const   *msg ;
};
#line 269 "/usr/include/security/_pam_types.h"
struct pam_response {
   char *resp ;
   int resp_retcode ;
};
#line 276 "/usr/include/security/_pam_types.h"
struct pam_conv {
   int (*conv)(int num_msg , struct pam_message  const  **msg , struct pam_response **resp ,
               void *appdata_ptr ) ;
   void *appdata_ptr ;
};
#line 53 "auth-pam.c"
enum __anonenum_pamstates_76 {
    INITIAL_LOGIN = 0,
    OTHER = 1
} ;
#line 53 "auth-pam.c"
typedef enum __anonenum_pamstates_76 pamstates;
#line 27 "dh.h"
struct dhgroup {
   int size ;
   BIGNUM *g ;
   BIGNUM *p ;
};
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 28 "/usr/include/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 53 "loginrec.h"
union login_netinfo {
   struct sockaddr sa ;
   struct sockaddr_in sa_in ;
   struct sockaddr_storage sa_storage ;
};
#line 73 "loginrec.h"
struct logininfo {
   char progname[64] ;
   int progname_null ;
   short type ;
   int pid ;
   int uid ;
   char line[64] ;
   char username[64] ;
   char hostname[256] ;
   int exit ;
   int termination ;
   unsigned int tv_sec ;
   unsigned int tv_usec ;
   union login_netinfo hostaddr ;
};
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 38 "/usr/include/bits/utmp.h"
struct lastlog {
   __time_t ll_time ;
   char ll_line[32] ;
   char ll_host[256] ;
};
#line 52 "/usr/include/bits/utmp.h"
struct exit_status {
   short e_termination ;
   short e_exit ;
};
#line 60 "/usr/include/bits/utmp.h"
struct utmp {
   short ut_type ;
   pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct exit_status ut_exit ;
   long ut_session ;
   struct timeval ut_tv ;
   int32_t ut_addr_v6[4] ;
   char __unused[20] ;
};
#line 178 "servconf.c"
enum __anonenum_ServerOpCodes_76 {
    sBadOption = 0,
    sPort = 1,
    sHostKeyFile = 2,
    sServerKeyBits = 3,
    sLoginGraceTime = 4,
    sKeyRegenerationTime = 5,
    sPermitRootLogin = 6,
    sLogFacility = 7,
    sLogLevel = 8,
    sRhostsAuthentication = 9,
    sRhostsRSAAuthentication = 10,
    sRSAAuthentication = 11,
    sPasswordAuthentication = 12,
    sKbdInteractiveAuthentication = 13,
    sListenAddress = 14,
    sPrintMotd = 15,
    sIgnoreRhosts = 16,
    sX11Forwarding = 17,
    sX11DisplayOffset = 18,
    sStrictModes = 19,
    sEmptyPasswd = 20,
    sRandomSeedFile = 21,
    sKeepAlives = 22,
    sCheckMail = 23,
    sUseLogin = 24,
    sAllowTcpForwarding = 25,
    sAllowUsers = 26,
    sDenyUsers = 27,
    sAllowGroups = 28,
    sDenyGroups = 29,
    sIgnoreUserKnownHosts = 30,
    sHostDSAKeyFile = 31,
    sCiphers = 32,
    sProtocol = 33,
    sPidFile = 34,
    sGatewayPorts = 35,
    sDSAAuthentication = 36,
    sXAuthLocation = 37,
    sSubsystem = 38,
    sMaxStartups = 39
} ;
#line 178 "servconf.c"
typedef enum __anonenum_ServerOpCodes_76 ServerOpCodes;
#line 202 "servconf.c"
struct __anonstruct_keywords_77 {
   char const   *name ;
   ServerOpCodes opcode ;
};
#line 63 "/usr/include/sys/wait.h"
union wait;
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_terminated_46 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_stopped_47 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_46 __wait_terminated ;
   struct __anonstruct___wait_stopped_47 __wait_stopped ;
};
#line 103 "serverloop.c"
union __anonunion_78 {
   int volatile   __in ;
   int __i ;
};
#line 103 "serverloop.c"
union __anonunion_79 {
   int volatile   __in ;
   int __i ;
};
#line 617 "serverloop.c"
union __anonunion_80 {
   int __in ;
   int __i ;
};
#line 619 "serverloop.c"
union __anonunion_81 {
   int __in ;
   int __i ;
};
#line 615 "serverloop.c"
union __anonunion_82 {
   int __in ;
   int __i ;
};
#line 641 "serverloop.c"
union __anonunion_83 {
   int __in ;
   int __i ;
};
#line 640 "serverloop.c"
union __anonunion_84 {
   int __in ;
   int __i ;
};
#line 77 "/usr/include/time.h"
typedef __time_t time_t;
#line 92 "session.c"
struct Session;
#line 92 "session.c"
typedef struct Session Session;
#line 93 "session.c"
struct Session {
   int used ;
   int self ;
   int extended ;
   struct passwd *pw ;
   pid_t pid ;
   char *term ;
   int ptyfd ;
   int ttyfd ;
   int ptymaster ;
   int row ;
   int col ;
   int xpixel ;
   int ypixel ;
   char tty[64] ;
   char *display ;
   int screen ;
   char *auth_proto ;
   char *auth_data ;
   int single_connection ;
   int chanid ;
};
#line 1829 "session.c"
union __anonunion_77 {
   int __in ;
   int __i ;
};
#line 1834 "session.c"
union __anonunion_78___0 {
   int __in ;
   int __i ;
};
#line 1836 "session.c"
union __anonunion_79___0 {
   int __in ;
   int __i ;
};
#line 1831 "session.c"
union __anonunion_80___0 {
   int __in ;
   int __i ;
};
#line 1826 "session.c"
union __anonunion_81___0 {
   int __in ;
   int __i ;
};
#line 1 "atomicio.o"
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 520 "ssh.h"
ssize_t atomicio(ssize_t (*f)() , int fd , void *_s , size_t n___0 ) ;
#line 35 "atomicio.c"
ssize_t atomicio(ssize_t (*f)() , int fd , void *_s , size_t n___0 ) 
{ char *s ;
  ssize_t res ;
  ssize_t pos ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 42
  s = (char *)_s;
#line 43
  pos = 0;
#line 45
  while (n___0 > (size_t )pos) {
#line 46
    res = (*f)(fd, s + pos, n___0 - (size_t )pos);
#line 47
    switch (res) {
    case -1: 
#line 50
    tmp = __errno_location();
#line 50
    if (*tmp == 4) {
#line 54
      continue;
    } else {
#line 50
      tmp___0 = __errno_location();
#line 50
      if (*tmp___0 == 11) {
#line 54
        continue;
      } else {
#line 50
        tmp___1 = __errno_location();
#line 50
        if (*tmp___1 == 11) {
#line 54
          continue;
        }
      }
    }
    case 0: 
#line 56
    return (res);
    default: 
#line 58
    pos += res;
    }
  }
#line 61
  return (pos);
}
}
#line 1 "authfd.o"
#line 100 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 124
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 242 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 320 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 327
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 333
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 76 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 660 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 7 "bsd-strlcpy.h"
size_t strlcpy(char *dst , char const   *src , size_t siz ) ;
#line 405 "/usr/include/openssl/bn.h"
extern int BN_num_bits(BIGNUM const   *a ) ;
#line 460 "ssh.h"
void ( /* format attribute */  fatal)(char const   *fmt  , ...) ;
#line 461
void ( /* format attribute */  error)(char const   *fmt  , ...) ;
#line 462
void ( /* format attribute */  log)(char const   *fmt  , ...) ;
#line 26 "buffer.h"
void buffer_init(Buffer *buffer ) ;
#line 29
void buffer_free(Buffer *buffer ) ;
#line 33
void buffer_clear(Buffer *buffer ) ;
#line 36
void buffer_append(Buffer *buffer , char const   *data , unsigned int len ) ;
#line 46
unsigned int buffer_len(Buffer *buffer ) ;
#line 58
char *buffer_ptr(Buffer *buffer ) ;
#line 24 "bufaux.h"
void buffer_put_bignum(Buffer *buffer , BIGNUM *value ) ;
#line 25
void buffer_put_bignum2(Buffer *buffer , BIGNUM *value ) ;
#line 28
int buffer_get_bignum(Buffer *buffer , BIGNUM *value ) ;
#line 32
unsigned int buffer_get_int(Buffer *buffer ) ;
#line 35
void buffer_put_int(Buffer *buffer , unsigned int value ) ;
#line 38
int buffer_get_char(Buffer *buffer ) ;
#line 41
void buffer_put_char(Buffer *buffer , int value ) ;
#line 51
char *buffer_get_string(Buffer *buffer , unsigned int *length_ptr ) ;
#line 54
void buffer_put_string(Buffer *buffer , void const   *buf___1 , unsigned int len ) ;
#line 55
void buffer_put_cstring(Buffer *buffer , char const   *s ) ;
#line 23 "xmalloc.h"
void *xmalloc(size_t size ) ;
#line 29
void xfree(void *ptr ) ;
#line 39 "key.h"
Key *key_new(int type ) ;
#line 54 "authfd.h"
int ssh_get_authentication_socket(void) ;
#line 61
void ssh_close_authentication_socket(int sock ) ;
#line 69
AuthenticationConnection *ssh_get_authentication_connection(void) ;
#line 75
void ssh_close_authentication_connection(AuthenticationConnection *auth ) ;
#line 82
Key *ssh_get_first_identity(AuthenticationConnection *auth , char **comment , int version ) ;
#line 90
Key *ssh_get_next_identity(AuthenticationConnection *auth , char **comment , int version ) ;
#line 96
int ssh_decrypt_challenge(AuthenticationConnection *auth , Key *key , BIGNUM *challenge ,
                          unsigned char *session_id___0 , unsigned int response_type ,
                          unsigned char *response ) ;
#line 104
int ssh_agent_sign(AuthenticationConnection *auth , Key *key , unsigned char **sigp ,
                   int *lenp , unsigned char *data , int datalen ) ;
#line 115
int ssh_add_identity(AuthenticationConnection *auth , Key *key , char const   *comment ) ;
#line 124
int ssh_remove_identity(AuthenticationConnection *auth , Key *key ) ;
#line 131
int ssh_remove_all_identities(AuthenticationConnection *auth , int version ) ;
#line 27 "dsa.h"
Key *dsa_key_from_blob(char *blob , int blen ) ;
#line 28
int dsa_make_key_blob(Key *key , unsigned char **blobp , unsigned int *lenp ) ;
#line 46 "compat.h"
int datafellows ;
#line 57 "authfd.c"
int decode_reply(int type ) ;
#line 65 "authfd.c"
int ssh_get_authentication_socket(void) 
{ char const   *authsocket ;
  int sock ;
  int len ;
  struct sockaddr_un sunaddr ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 72
  tmp = getenv("SSH_AUTH_SOCK");
#line 72
  authsocket = (char const   *)tmp;
#line 73
  if (! authsocket) {
#line 74
    return (-1);
  }
#line 76
  sunaddr.sun_family = (unsigned short)1;
#line 77
  strlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));
#line 81
  tmp___0 = strlen((char const   *)(sunaddr.sun_path));
#line 81
  len = (int )(((unsigned int )(((struct sockaddr_un *)0)->sun_path) + tmp___0) + 1U);
#line 84
  sock = socket(1, 1, 0);
#line 85
  if (sock < 0) {
#line 86
    return (-1);
  }
#line 89
  tmp___1 = fcntl(sock, 2, 1);
#line 89
  if (tmp___1 == -1) {
#line 90
    close(sock);
#line 91
    return (-1);
  }
#line 93
  tmp___2 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sunaddr)),
                    (unsigned int )len);
#line 93
  if (tmp___2 < 0) {
#line 94
    close(sock);
#line 95
    return (-1);
  }
#line 97
  return (sock);
}
}
#line 100 "authfd.c"
int ssh_request_reply(AuthenticationConnection *auth , Buffer *request , Buffer *reply ) 
{ int l ;
  int len ;
  char buf___1[1024] ;
  unsigned int tmp ;
  ssize_t tmp___0 ;
  unsigned int tmp___1 ;
  char *tmp___2 ;
  ssize_t tmp___3 ;
  unsigned int tmp___4 ;

  {
#line 107
  tmp = buffer_len(request);
#line 107
  len = (int )tmp;
#line 108
  while (1) {
#line 108
    buf___1[0] = (char )(len >> 24);
#line 108
    buf___1[1] = (char )(len >> 16);
#line 108
    buf___1[2] = (char )(len >> 8);
#line 108
    buf___1[3] = (char )len;
#line 108
    break;
  }
#line 111
  tmp___0 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)(buf___1), 4U);
#line 111
  if (tmp___0 != 4) {
#line 114
    error("Error writing to authentication socket.");
#line 115
    return (0);
  } else {
#line 111
    tmp___1 = buffer_len(request);
#line 111
    tmp___2 = buffer_ptr(request);
#line 111
    tmp___3 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)tmp___2, tmp___1);
#line 111
    tmp___4 = buffer_len(request);
#line 111
    if ((unsigned int )tmp___3 != tmp___4) {
#line 114
      error("Error writing to authentication socket.");
#line 115
      return (0);
    }
  }
#line 121
  len = 4;
#line 122
  while (len > 0) {
#line 123
    l = read(auth->fd, (void *)((buf___1 + 4) - len), (unsigned int )len);
#line 124
    if (l <= 0) {
#line 125
      error("Error reading response length from authentication socket.");
#line 126
      return (0);
    }
#line 128
    len -= l;
  }
#line 132
  len = (int )(((((unsigned long )((unsigned char )buf___1[0]) << 24) | ((unsigned long )((unsigned char )buf___1[1]) << 16)) | ((unsigned long )((unsigned char )buf___1[2]) << 8)) | (unsigned long )((unsigned char )buf___1[3]));
#line 133
  if (len > 262144) {
#line 134
    fatal("Authentication response too long: %d", len);
  }
#line 137
  buffer_clear(reply);
#line 138
  while (len > 0) {
#line 139
    l = len;
#line 140
    if ((unsigned int )l > sizeof(buf___1)) {
#line 141
      l = (int )sizeof(buf___1);
    }
#line 142
    l = read(auth->fd, (void *)(buf___1), (unsigned int )l);
#line 143
    if (l <= 0) {
#line 144
      error("Error reading response from authentication socket.");
#line 145
      return (0);
    }
#line 147
    buffer_append(reply, (char const   *)(buf___1), (unsigned int )l);
#line 148
    len -= l;
  }
#line 150
  return (1);
}
}
#line 159 "authfd.c"
void ssh_close_authentication_socket(int sock ) 
{ char *tmp ;

  {
#line 162
  tmp = getenv("SSH_AUTH_SOCK");
#line 162
  if (tmp) {
#line 163
    close(sock);
  }
#line 164
  return;
}
}
#line 174 "authfd.c"
AuthenticationConnection *ssh_get_authentication_connection(void) 
{ AuthenticationConnection *auth ;
  int sock ;
  void *tmp ;

  {
#line 180
  sock = ssh_get_authentication_socket();
#line 186
  if (sock < 0) {
#line 187
    return ((AuthenticationConnection *)((void *)0));
  }
#line 189
  tmp = xmalloc(sizeof(*auth));
#line 189
  auth = (AuthenticationConnection *)tmp;
#line 190
  auth->fd = sock;
#line 191
  buffer_init(& auth->identities);
#line 192
  auth->howmany = 0;
#line 194
  return (auth);
}
}
#line 202 "authfd.c"
void ssh_close_authentication_connection(AuthenticationConnection *auth ) 
{ 

  {
#line 205
  buffer_free(& auth->identities);
#line 206
  close(auth->fd);
#line 207
  xfree((void *)auth);
#line 208
  return;
}
}
#line 214 "authfd.c"
Key *ssh_get_first_identity(AuthenticationConnection *auth , char **comment , int version ) 
{ int type ;
  int code1 ;
  int code2 ;
  Buffer request ;
  int tmp ;
  unsigned int tmp___0 ;
  Key *tmp___1 ;

  {
#line 217
  code1 = 0;
#line 217
  code2 = 0;
#line 220
  switch (version) {
  case 1: 
#line 222
  code1 = 1;
#line 223
  code2 = 2;
#line 224
  break;
  case 2: 
#line 226
  code1 = 11;
#line 227
  code2 = 12;
#line 228
  break;
  default: ;
#line 230
  return ((Key *)((void *)0));
  }
#line 237
  buffer_init(& request);
#line 238
  buffer_put_char(& request, code1);
#line 240
  buffer_clear(& auth->identities);
#line 241
  tmp = ssh_request_reply(auth, & request, & auth->identities);
#line 241
  if (tmp == 0) {
#line 242
    buffer_free(& request);
#line 243
    return ((Key *)((void *)0));
  }
#line 245
  buffer_free(& request);
#line 248
  type = buffer_get_char(& auth->identities);
#line 249
  if (type == 5) {
#line 250
    return ((Key *)((void *)0));
  } else {
#line 249
    if (type == 102) {
#line 250
      return ((Key *)((void *)0));
    } else {
#line 251
      if (type != code2) {
#line 252
        fatal("Bad authentication reply message type: %d", type);
      }
    }
  }
#line 256
  tmp___0 = buffer_get_int(& auth->identities);
#line 256
  auth->howmany = (int )tmp___0;
#line 257
  if (auth->howmany > 1024) {
#line 258
    fatal("Too many identities in authentication reply: %d\n", auth->howmany);
  }
#line 262
  tmp___1 = ssh_get_next_identity(auth, comment, version);
#line 262
  return (tmp___1);
}
}
#line 265 "authfd.c"
Key *ssh_get_next_identity(AuthenticationConnection *auth , char **comment , int version ) 
{ unsigned int bits ;
  unsigned char *blob ;
  unsigned int blen ;
  Key *key ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 271
  key = (Key *)((void *)0);
#line 274
  if (auth->howmany <= 0) {
#line 275
    return ((Key *)((void *)0));
  }
#line 281
  switch (version) {
  case 1: 
#line 283
  key = key_new(0);
#line 284
  bits = buffer_get_int(& auth->identities);
#line 285
  buffer_get_bignum(& auth->identities, (key->rsa)->e);
#line 286
  buffer_get_bignum(& auth->identities, (key->rsa)->n);
#line 287
  *comment = buffer_get_string(& auth->identities, (unsigned int *)((void *)0));
#line 288
  tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 288
  if (bits != (unsigned int )tmp___0) {
#line 289
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 289
    log("Warning: identity keysize mismatch: actual %d, announced %u", tmp, bits);
  }
#line 291
  break;
  case 2: 
#line 293
  tmp___1 = buffer_get_string(& auth->identities, & blen);
#line 293
  blob = (unsigned char *)tmp___1;
#line 294
  *comment = buffer_get_string(& auth->identities, (unsigned int *)((void *)0));
#line 295
  key = dsa_key_from_blob((char *)blob, (int )blen);
#line 296
  xfree((void *)blob);
#line 297
  break;
  default: ;
#line 299
  return ((Key *)((void *)0));
#line 300
  break;
  }
#line 303
  (auth->howmany) --;
#line 304
  return (key);
}
}
#line 315 "authfd.c"
int ssh_decrypt_challenge(AuthenticationConnection *auth , Key *key , BIGNUM *challenge ,
                          unsigned char *session_id___0 , unsigned int response_type ,
                          unsigned char *response ) 
{ Buffer buffer ;
  int success ;
  int i ;
  int type ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 323
  success = 0;
#line 327
  if (key->type != 0) {
#line 328
    return (0);
  }
#line 329
  if (response_type == 0U) {
#line 330
    log("Compatibility with ssh protocol version 1.0 no longer supported.");
#line 331
    return (0);
  }
#line 333
  buffer_init(& buffer);
#line 334
  buffer_put_char(& buffer, 3);
#line 335
  tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 335
  buffer_put_int(& buffer, (unsigned int )tmp);
#line 336
  buffer_put_bignum(& buffer, (key->rsa)->e);
#line 337
  buffer_put_bignum(& buffer, (key->rsa)->n);
#line 338
  buffer_put_bignum(& buffer, challenge);
#line 339
  buffer_append(& buffer, (char const   *)((char *)session_id___0), 16U);
#line 340
  buffer_put_int(& buffer, response_type);
#line 342
  tmp___0 = ssh_request_reply(auth, & buffer, & buffer);
#line 342
  if (tmp___0 == 0) {
#line 343
    buffer_free(& buffer);
#line 344
    return (0);
  }
#line 346
  type = buffer_get_char(& buffer);
#line 348
  if (type == 5) {
#line 349
    log("Agent admitted failure to authenticate using the key.");
  } else {
#line 348
    if (type == 102) {
#line 349
      log("Agent admitted failure to authenticate using the key.");
    } else {
#line 350
      if (type != 4) {
#line 351
        fatal("Bad authentication response: %d", type);
      } else {
#line 353
        success = 1;
#line 358
        i = 0;
#line 358
        while (i < 16) {
#line 359
          tmp___1 = buffer_get_char(& buffer);
#line 359
          *(response + i) = (unsigned char )tmp___1;
#line 358
          i ++;
        }
      }
    }
  }
#line 361
  buffer_free(& buffer);
#line 362
  return (success);
}
}
#line 366 "authfd.c"
int ssh_agent_sign(AuthenticationConnection *auth , Key *key , unsigned char **sigp ,
                   int *lenp , unsigned char *data , int datalen ) 
{ Buffer msg ;
  unsigned char *blob ;
  unsigned int blen ;
  int type ;
  int flags ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 376
  flags = 0;
#line 377
  ret = -1;
#line 379
  tmp = dsa_make_key_blob(key, & blob, & blen);
#line 379
  if (tmp == 0) {
#line 380
    return (-1);
  }
#line 382
  if (datafellows & 1) {
#line 383
    flags = 1;
  }
#line 385
  buffer_init(& msg);
#line 386
  buffer_put_char(& msg, 13);
#line 387
  buffer_put_string(& msg, (void const   *)blob, blen);
#line 388
  buffer_put_string(& msg, (void const   *)data, (unsigned int )datalen);
#line 389
  buffer_put_int(& msg, (unsigned int )flags);
#line 390
  xfree((void *)blob);
#line 392
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 392
  if (tmp___0 == 0) {
#line 393
    buffer_free(& msg);
#line 394
    return (-1);
  }
#line 396
  type = buffer_get_char(& msg);
#line 397
  if (type == 5) {
#line 398
    log("Agent admitted failure to sign using the key.");
  } else {
#line 397
    if (type == 102) {
#line 398
      log("Agent admitted failure to sign using the key.");
    } else {
#line 399
      if (type != 14) {
#line 400
        fatal("Bad authentication response: %d", type);
      } else {
#line 402
        ret = 0;
#line 403
        tmp___1 = buffer_get_string(& msg, (unsigned int *)lenp);
#line 403
        *sigp = (unsigned char *)tmp___1;
      }
    }
  }
#line 405
  buffer_free(& msg);
#line 406
  return (ret);
}
}
#line 411 "authfd.c"
void ssh_encode_identity_rsa(Buffer *b , RSA *key , char const   *comment ) 
{ int tmp ;
  size_t tmp___0 ;

  {
#line 414
  buffer_clear(b);
#line 415
  buffer_put_char(b, 7);
#line 416
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 416
  buffer_put_int(b, (unsigned int )tmp);
#line 417
  buffer_put_bignum(b, key->n);
#line 418
  buffer_put_bignum(b, key->e);
#line 419
  buffer_put_bignum(b, key->d);
#line 421
  buffer_put_bignum(b, key->iqmp);
#line 422
  buffer_put_bignum(b, key->q);
#line 423
  buffer_put_bignum(b, key->p);
#line 424
  tmp___0 = strlen(comment);
#line 424
  buffer_put_string(b, (void const   *)comment, tmp___0);
#line 425
  return;
}
}
#line 427 "authfd.c"
void ssh_encode_identity_dsa(Buffer *b , DSA *key , char const   *comment ) 
{ size_t tmp ;

  {
#line 430
  buffer_clear(b);
#line 431
  buffer_put_char(b, 17);
#line 432
  buffer_put_cstring(b, "ssh-dss");
#line 433
  buffer_put_bignum2(b, key->p);
#line 434
  buffer_put_bignum2(b, key->q);
#line 435
  buffer_put_bignum2(b, key->g);
#line 436
  buffer_put_bignum2(b, key->pub_key);
#line 437
  buffer_put_bignum2(b, key->priv_key);
#line 438
  tmp = strlen(comment);
#line 438
  buffer_put_string(b, (void const   *)comment, tmp);
#line 439
  return;
}
}
#line 446 "authfd.c"
int ssh_add_identity(AuthenticationConnection *auth , Key *key , char const   *comment ) 
{ Buffer msg ;
  int type ;
  int tmp ;
  int tmp___0 ;

  {
#line 452
  buffer_init(& msg);
#line 454
  switch (key->type) {
  case 0: 
#line 456
  ssh_encode_identity_rsa(& msg, key->rsa, comment);
#line 457
  break;
  case 1: 
#line 459
  ssh_encode_identity_dsa(& msg, key->dsa, comment);
#line 460
  break;
  default: 
#line 462
  buffer_free(& msg);
#line 463
  return (0);
#line 464
  break;
  }
#line 466
  tmp = ssh_request_reply(auth, & msg, & msg);
#line 466
  if (tmp == 0) {
#line 467
    buffer_free(& msg);
#line 468
    return (0);
  }
#line 470
  type = buffer_get_char(& msg);
#line 471
  buffer_free(& msg);
#line 472
  tmp___0 = decode_reply(type);
#line 472
  return (tmp___0);
}
}
#line 480 "authfd.c"
int ssh_remove_identity(AuthenticationConnection *auth , Key *key ) 
{ Buffer msg ;
  int type ;
  unsigned char *blob ;
  unsigned int blen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 488
  buffer_init(& msg);
#line 490
  if (key->type == 0) {
#line 491
    buffer_put_char(& msg, 8);
#line 492
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 492
    buffer_put_int(& msg, (unsigned int )tmp);
#line 493
    buffer_put_bignum(& msg, (key->rsa)->e);
#line 494
    buffer_put_bignum(& msg, (key->rsa)->n);
  } else {
#line 495
    if (key->type == 1) {
#line 496
      dsa_make_key_blob(key, & blob, & blen);
#line 497
      buffer_put_char(& msg, 18);
#line 498
      buffer_put_string(& msg, (void const   *)blob, blen);
#line 499
      xfree((void *)blob);
    } else {
#line 501
      buffer_free(& msg);
#line 502
      return (0);
    }
  }
#line 504
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 504
  if (tmp___0 == 0) {
#line 505
    buffer_free(& msg);
#line 506
    return (0);
  }
#line 508
  type = buffer_get_char(& msg);
#line 509
  buffer_free(& msg);
#line 510
  tmp___1 = decode_reply(type);
#line 510
  return (tmp___1);
}
}
#line 518 "authfd.c"
int ssh_remove_all_identities(AuthenticationConnection *auth , int version ) 
{ Buffer msg ;
  int type ;
  int code ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 523
  if (version == 1) {
#line 523
    tmp = 9;
  } else {
#line 523
    tmp = 19;
  }
#line 523
  code = tmp;
#line 527
  buffer_init(& msg);
#line 528
  buffer_put_char(& msg, code);
#line 530
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 530
  if (tmp___0 == 0) {
#line 531
    buffer_free(& msg);
#line 532
    return (0);
  }
#line 534
  type = buffer_get_char(& msg);
#line 535
  buffer_free(& msg);
#line 536
  tmp___1 = decode_reply(type);
#line 536
  return (tmp___1);
}
}
#line 539 "authfd.c"
int decode_reply(int type ) 
{ 

  {
#line 542
  switch (type) {
  case 5: 
  case 102: 
#line 545
  log("SSH_AGENT_FAILURE");
#line 546
  return (0);
  case 6: 
#line 548
  return (1);
  default: 
#line 550
  fatal("Bad response from authentication agent: %d", type);
  }
#line 553
  return (0);
}
}
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
#line 1 "authfile.o"
#line 59 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 256
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 212 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 380
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __attribute__((__nonnull__(3))) ;
#line 447
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 447 "/usr/include/sys/stat.h"
__inline static int fstat(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
#line 450
  tmp = __fxstat(3, __fd, __statbuf);
#line 450
  return (tmp);
}
}
#line 301 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 642
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 792
extern  __attribute__((__nothrow__)) int unlink(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 213 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 248
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 280
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 532
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 85 "/usr/include/fcntl.h"
extern int open(char const   *__file , int __oflag  , ...)  __attribute__((__nonnull__(1))) ;
#line 31 "bsd-arc4random.h"
unsigned int arc4random(void) ;
#line 7 "bsd-strlcat.h"
size_t strlcat(char *dst , char const   *src , size_t siz ) ;
#line 391 "/usr/include/openssl/bn.h"
extern BIGNUM const   *BN_value_one(void) ;
#line 393
extern BN_CTX *BN_CTX_new(void) ;
#line 397
extern void BN_CTX_free(BN_CTX *c ) ;
#line 407
extern BIGNUM *BN_new(void) ;
#line 409
extern void BN_clear_free(BIGNUM *a ) ;
#line 416
extern int BN_sub(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *b ) ;
#line 433
extern int BN_div(BIGNUM *dv , BIGNUM *rem , BIGNUM const   *m , BIGNUM const   *d ,
                  BN_CTX *ctx ) ;
#line 560 "/usr/include/openssl/bio.h"
extern BIO_METHOD *BIO_s_file(void) ;
#line 568
extern BIO *BIO_new(BIO_METHOD *type ) ;
#line 570
extern int BIO_free(BIO *a ) ;
#line 577
extern long BIO_ctrl(BIO *bp , int cmd , long larg , void *parg ) ;
#line 192 "/usr/include/openssl/dsa.h"
extern void DSA_free(DSA *r ) ;
#line 639 "/usr/include/openssl/evp.h"
extern EVP_CIPHER const   *EVP_des_ede3_cbc(void) ;
#line 625 "/usr/include/openssl/pem.h"
extern DSA *PEM_read_bio_DSAPrivateKey(BIO *bp , DSA **x , pem_password_cb *cb , void *u ) ;
#line 625
extern int PEM_write_DSAPrivateKey(FILE *fp , DSA *x , EVP_CIPHER const   *enc , unsigned char *kstr ,
                                   int klen , pem_password_cb *cb , void *u ) ;
#line 32 "xmalloc.h"
char *xstrdup(char const   *str ) ;
#line 43 "buffer.h"
void buffer_append_space(Buffer *buffer , char **datap , unsigned int len ) ;
#line 108 "cipher.h"
Cipher *cipher_by_number(int id ) ;
#line 113
void cipher_encrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) ;
#line 114
void cipher_decrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) ;
#line 115
void cipher_set_key_string(CipherContext *cc , Cipher *cipher , char const   *passphrase ) ;
#line 464 "ssh.h"
void ( /* format attribute */  debug)(char const   *fmt  , ...) ;
#line 45 "key.h"
unsigned int key_read(Key *ret , char **cpp ) ;
#line 63 "authfile.c"
int save_private_key_rsa(char const   *filename , char const   *passphrase , RSA *key ,
                         char const   *comment ) 
{ Buffer buffer ;
  Buffer encrypted ;
  char buf___1[100] ;
  char *cp ;
  int fd ;
  int i ;
  CipherContext ciphercontext ;
  Cipher *cipher ;
  u_int32_t rand___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  unsigned int tmp___17 ;
  char *tmp___18 ;
  ssize_t tmp___19 ;
  unsigned int tmp___20 ;

  {
#line 78
  if (0) {
#line 78
    __s1_len = strlen(passphrase);
#line 78
    __s2_len = strlen("");
#line 78
    if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
      goto _L___0;
    } else {
#line 78
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 78
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 78
          tmp___8 = 1;
        } else {
#line 78
          if (__s2_len >= 4U) {
#line 78
            tmp___8 = 1;
          } else {
#line 78
            tmp___8 = 0;
          }
        }
      } else {
#line 78
        tmp___8 = 0;
      }
    }
#line 78
    if (tmp___8) {
#line 78
      tmp___4 = __builtin_strcmp(passphrase, "");
    } else {
#line 78
      tmp___7 = __builtin_strcmp(passphrase, "");
#line 78
      tmp___4 = tmp___7;
    }
  } else {
#line 78
    tmp___7 = __builtin_strcmp(passphrase, "");
#line 78
    tmp___4 = tmp___7;
  }
#line 78
  if (tmp___4 == 0) {
#line 79
    cipher = cipher_by_number(0);
  } else {
#line 81
    cipher = cipher_by_number(3);
  }
#line 82
  if ((unsigned int )cipher == (unsigned int )((void *)0)) {
#line 83
    fatal("save_private_key_rsa: bad cipher");
  }
#line 86
  buffer_init(& buffer);
#line 89
  rand___0 = arc4random();
#line 90
  buf___1[0] = (char )(rand___0 & 255U);
#line 91
  buf___1[1] = (char )((rand___0 >> 8) & 255U);
#line 92
  buf___1[2] = buf___1[0];
#line 93
  buf___1[3] = buf___1[1];
#line 94
  buffer_append(& buffer, (char const   *)(buf___1), 4U);
#line 101
  buffer_put_bignum(& buffer, key->d);
#line 102
  buffer_put_bignum(& buffer, key->iqmp);
#line 103
  buffer_put_bignum(& buffer, key->q);
#line 104
  buffer_put_bignum(& buffer, key->p);
#line 107
  while (1) {
#line 107
    tmp___9 = buffer_len(& buffer);
#line 107
    if (! (tmp___9 % 8U != 0U)) {
#line 107
      break;
    }
#line 108
    buffer_put_char(& buffer, 0);
  }
#line 111
  buffer_init(& encrypted);
#line 114
  cp = (char *)"SSH PRIVATE KEY FILE FORMAT 1.1\n";
#line 115
  i = 0;
#line 115
  while (*(cp + i)) {
#line 116
    buffer_put_char(& encrypted, (int )*(cp + i));
#line 115
    i ++;
  }
#line 117
  buffer_put_char(& encrypted, 0);
#line 120
  buffer_put_char(& encrypted, cipher->number);
#line 121
  buffer_put_int(& encrypted, 0U);
#line 124
  tmp___10 = BN_num_bits((BIGNUM const   *)key->n);
#line 124
  buffer_put_int(& encrypted, (unsigned int )tmp___10);
#line 125
  buffer_put_bignum(& encrypted, key->n);
#line 126
  buffer_put_bignum(& encrypted, key->e);
#line 127
  tmp___11 = strlen(comment);
#line 127
  buffer_put_string(& encrypted, (void const   *)comment, tmp___11);
#line 130
  tmp___12 = buffer_len(& buffer);
#line 130
  buffer_append_space(& encrypted, & cp, tmp___12);
#line 132
  cipher_set_key_string(& ciphercontext, cipher, passphrase);
#line 133
  tmp___13 = buffer_len(& buffer);
#line 133
  tmp___14 = buffer_ptr(& buffer);
#line 133
  cipher_encrypt(& ciphercontext, (unsigned char *)cp, (u_char const   *)((unsigned char *)tmp___14),
                 tmp___13);
#line 135
  memset((void *)(& ciphercontext), 0, sizeof(ciphercontext));
#line 138
  memset((void *)(buf___1), 0, sizeof(buf___1));
#line 139
  buffer_free(& buffer);
#line 141
  fd = open(filename, 577, 384);
#line 142
  if (fd < 0) {
#line 143
    return (0);
  }
#line 144
  tmp___17 = buffer_len(& encrypted);
#line 144
  tmp___18 = buffer_ptr(& encrypted);
#line 144
  tmp___19 = write(fd, (void const   *)tmp___18, tmp___17);
#line 144
  tmp___20 = buffer_len(& encrypted);
#line 144
  if ((unsigned int )tmp___19 != tmp___20) {
#line 146
    tmp___15 = __errno_location();
#line 146
    tmp___16 = strerror(*tmp___15);
#line 146
    debug("Write to key file %.200s failed: %.100s", filename, tmp___16);
#line 148
    buffer_free(& encrypted);
#line 149
    close(fd);
#line 150
    unlink(filename);
#line 151
    return (0);
  }
#line 153
  close(fd);
#line 154
  buffer_free(& encrypted);
#line 155
  return (1);
}
}
#line 160 "authfile.c"
int save_private_key_dsa(char const   *filename , char const   *passphrase , DSA *dsa ,
                         char const   *comment ) 
{ FILE *fp ;
  int fd ;
  int success ;
  int len ;
  size_t tmp ;
  int *tmp___0 ;
  size_t tmp___1 ;
  EVP_CIPHER const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 166
  success = 1;
#line 167
  tmp = strlen(passphrase);
#line 167
  len = (int )tmp;
#line 169
  if (len > 0) {
#line 169
    if (len <= 4) {
#line 170
      error("passphrase too short: %d bytes", len);
#line 171
      tmp___0 = __errno_location();
#line 171
      *tmp___0 = 0;
#line 172
      return (0);
    }
  }
#line 174
  fd = open(filename, 577, 384);
#line 175
  if (fd < 0) {
#line 176
    debug("open %s failed", filename);
#line 177
    return (0);
  }
#line 179
  fp = fdopen(fd, "w");
#line 180
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 181
    debug("fdopen %s failed", filename);
#line 182
    close(fd);
#line 183
    return (0);
  }
#line 185
  if (len > 0) {
#line 186
    tmp___1 = strlen(passphrase);
#line 186
    tmp___2 = EVP_des_ede3_cbc();
#line 186
    tmp___3 = PEM_write_DSAPrivateKey(fp, dsa, tmp___2, (unsigned char *)((char *)passphrase),
                                      (int )tmp___1, (pem_password_cb *)((void *)0),
                                      (void *)0);
#line 186
    if (! tmp___3) {
#line 188
      success = 0;
    }
  } else {
#line 190
    tmp___4 = PEM_write_DSAPrivateKey(fp, dsa, (EVP_CIPHER const   *)((void *)0),
                                      (unsigned char *)((void *)0), 0, (pem_password_cb *)((void *)0),
                                      (void *)0);
#line 190
    if (! tmp___4) {
#line 192
      success = 0;
    }
  }
#line 194
  fclose(fp);
#line 195
  return (success);
}
}
#line 198 "authfile.c"
int save_private_key(char const   *filename , char const   *passphrase , Key *key ,
                     char const   *comment ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 202
  switch (key->type) {
  case 0: 
#line 204
  tmp = save_private_key_rsa(filename, passphrase, key->rsa, comment);
#line 204
  return (tmp);
#line 205
  break;
  case 1: 
#line 207
  tmp___0 = save_private_key_dsa(filename, passphrase, key->dsa, comment);
#line 207
  return (tmp___0);
#line 208
  break;
  default: ;
#line 210
  break;
  }
#line 212
  return (0);
}
}
#line 221 "authfile.c"
int load_public_key_rsa(char const   *filename , RSA *pub , char **comment_return ) 
{ int fd ;
  int i ;
  off_t len ;
  Buffer buffer ;
  char *cp ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
#line 229
  fd = open(filename, 0);
#line 230
  if (fd < 0) {
#line 231
    return (0);
  }
#line 232
  len = lseek(fd, 0L, 2);
#line 233
  lseek(fd, 0L, 0);
#line 235
  buffer_init(& buffer);
#line 236
  buffer_append_space(& buffer, & cp, (unsigned int )len);
#line 238
  tmp___1 = read(fd, (void *)cp, (unsigned int )len);
#line 238
  if ((unsigned int )tmp___1 != (unsigned int )len) {
#line 239
    tmp = __errno_location();
#line 239
    tmp___0 = strerror(*tmp);
#line 239
    debug("Read from key file %.200s failed: %.100s", filename, tmp___0);
#line 241
    buffer_free(& buffer);
#line 242
    close(fd);
#line 243
    return (0);
  }
#line 245
  close(fd);
#line 248
  tmp___2 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 248
  if ((unsigned long )len < (unsigned long )(tmp___2 + 1U)) {
#line 249
    debug("Bad key file %.200s.", filename);
#line 250
    buffer_free(& buffer);
#line 251
    return (0);
  }
#line 257
  i = 0;
#line 257
  while (1) {
#line 257
    tmp___4 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 257
    if (! ((unsigned int )i < tmp___4 + 1U)) {
#line 257
      break;
    }
#line 258
    tmp___3 = buffer_get_char(& buffer);
#line 258
    if (tmp___3 != (int )((unsigned char )*("SSH PRIVATE KEY FILE FORMAT 1.1\n" + i))) {
#line 259
      debug("Bad key file %.200s.", filename);
#line 260
      buffer_free(& buffer);
#line 261
      return (0);
    }
#line 257
    i ++;
  }
#line 264
  buffer_get_char(& buffer);
#line 265
  buffer_get_int(& buffer);
#line 268
  buffer_get_int(& buffer);
#line 270
  if ((unsigned int )pub->n == (unsigned int )((void *)0)) {
#line 271
    pub->n = BN_new();
  }
#line 272
  buffer_get_bignum(& buffer, pub->n);
#line 274
  if ((unsigned int )pub->e == (unsigned int )((void *)0)) {
#line 275
    pub->e = BN_new();
  }
#line 276
  buffer_get_bignum(& buffer, pub->e);
#line 277
  if (comment_return) {
#line 278
    *comment_return = buffer_get_string(& buffer, (unsigned int *)((void *)0));
  }
#line 281
  buffer_free(& buffer);
#line 283
  return (1);
}
}
#line 287 "authfile.c"
int load_public_key(char const   *filename , Key *key , char **comment_return ) 
{ int tmp ;

  {
#line 290
  switch (key->type) {
  case 0: 
#line 292
  tmp = load_public_key_rsa(filename, key->rsa, comment_return);
#line 292
  return (tmp);
#line 293
  break;
  case 1: 
  default: ;
#line 296
  break;
  }
#line 298
  return (0);
}
}
#line 308 "authfile.c"
int load_private_key_rsa(int fd , char const   *filename , char const   *passphrase ,
                         RSA *prv , char **comment_return ) 
{ int i ;
  int check1 ;
  int check2 ;
  int cipher_type___0 ;
  off_t len ;
  Buffer buffer ;
  Buffer decrypted ;
  char *cp ;
  CipherContext ciphercontext ;
  Cipher *cipher ;
  BN_CTX *ctx ;
  BIGNUM *aux ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  char *tmp___8 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  BIGNUM const   *tmp___21 ;
  BIGNUM const   *tmp___22 ;

  {
#line 321
  len = lseek(fd, 0L, 2);
#line 322
  lseek(fd, 0L, 0);
#line 324
  buffer_init(& buffer);
#line 325
  buffer_append_space(& buffer, & cp, (unsigned int )len);
#line 327
  tmp___1 = read(fd, (void *)cp, (unsigned int )len);
#line 327
  if ((unsigned int )tmp___1 != (unsigned int )len) {
#line 328
    tmp = __errno_location();
#line 328
    tmp___0 = strerror(*tmp);
#line 328
    debug("Read from key file %.200s failed: %.100s", filename, tmp___0);
#line 330
    buffer_free(& buffer);
#line 331
    close(fd);
#line 332
    return (0);
  }
#line 334
  close(fd);
#line 337
  tmp___2 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 337
  if ((unsigned long )len < (unsigned long )(tmp___2 + 1U)) {
#line 338
    debug("Bad key file %.200s.", filename);
#line 339
    buffer_free(& buffer);
#line 340
    return (0);
  }
#line 346
  i = 0;
#line 346
  while (1) {
#line 346
    tmp___4 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 346
    if (! ((unsigned int )i < tmp___4 + 1U)) {
#line 346
      break;
    }
#line 347
    tmp___3 = buffer_get_char(& buffer);
#line 347
    if (tmp___3 != (int )((unsigned char )*("SSH PRIVATE KEY FILE FORMAT 1.1\n" + i))) {
#line 348
      debug("Bad key file %.200s.", filename);
#line 349
      buffer_free(& buffer);
#line 350
      return (0);
    }
#line 346
    i ++;
  }
#line 353
  cipher_type___0 = buffer_get_char(& buffer);
#line 354
  buffer_get_int(& buffer);
#line 357
  buffer_get_int(& buffer);
#line 358
  prv->n = BN_new();
#line 359
  buffer_get_bignum(& buffer, prv->n);
#line 360
  prv->e = BN_new();
#line 361
  buffer_get_bignum(& buffer, prv->e);
#line 362
  if (comment_return) {
#line 363
    *comment_return = buffer_get_string(& buffer, (unsigned int *)((void *)0));
  } else {
#line 365
    tmp___5 = buffer_get_string(& buffer, (unsigned int *)((void *)0));
#line 365
    xfree((void *)tmp___5);
  }
#line 368
  cipher = cipher_by_number(cipher_type___0);
#line 369
  if ((unsigned int )cipher == (unsigned int )((void *)0)) {
#line 370
    debug("Unsupported cipher %d used in key file %.200s.", cipher_type___0, filename);
#line 372
    buffer_free(& buffer);
    goto fail;
  }
#line 376
  buffer_init(& decrypted);
#line 377
  tmp___6 = buffer_len(& buffer);
#line 377
  buffer_append_space(& decrypted, & cp, tmp___6);
#line 380
  cipher_set_key_string(& ciphercontext, cipher, passphrase);
#line 381
  tmp___7 = buffer_len(& buffer);
#line 381
  tmp___8 = buffer_ptr(& buffer);
#line 381
  cipher_decrypt(& ciphercontext, (unsigned char *)cp, (u_char const   *)((unsigned char *)tmp___8),
                 tmp___7);
#line 383
  memset((void *)(& ciphercontext), 0, sizeof(ciphercontext));
#line 384
  buffer_free(& buffer);
#line 386
  check1 = buffer_get_char(& decrypted);
#line 387
  check2 = buffer_get_char(& decrypted);
#line 388
  tmp___19 = buffer_get_char(& decrypted);
#line 388
  if (check1 != tmp___19) {
    goto _L___1;
  } else {
#line 388
    tmp___20 = buffer_get_char(& decrypted);
#line 388
    if (check2 != tmp___20) {
      _L___1: /* CIL Label */ 
#line 390
      if (0) {
#line 390
        __s1_len = strlen(passphrase);
#line 390
        __s2_len = strlen("");
#line 390
        if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
          goto _L___0;
        } else {
#line 390
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 390
            if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 390
              tmp___18 = 1;
            } else {
#line 390
              if (__s2_len >= 4U) {
#line 390
                tmp___18 = 1;
              } else {
#line 390
                tmp___18 = 0;
              }
            }
          } else {
#line 390
            tmp___18 = 0;
          }
        }
#line 390
        if (tmp___18) {
#line 390
          tmp___14 = __builtin_strcmp(passphrase, "");
        } else {
#line 390
          tmp___17 = __builtin_strcmp(passphrase, "");
#line 390
          tmp___14 = tmp___17;
        }
      } else {
#line 390
        tmp___17 = __builtin_strcmp(passphrase, "");
#line 390
        tmp___14 = tmp___17;
      }
#line 390
      if (tmp___14 != 0) {
#line 391
        debug("Bad passphrase supplied for key file %.200s.", filename);
      }
#line 393
      buffer_free(& decrypted);
      fail: 
#line 395
      BN_clear_free(prv->n);
#line 396
      prv->n = (BIGNUM *)((void *)0);
#line 397
      BN_clear_free(prv->e);
#line 398
      prv->e = (BIGNUM *)((void *)0);
#line 399
      if (comment_return) {
#line 400
        xfree((void *)*comment_return);
      }
#line 401
      return (0);
    }
  }
#line 404
  prv->d = BN_new();
#line 405
  buffer_get_bignum(& decrypted, prv->d);
#line 406
  prv->iqmp = BN_new();
#line 407
  buffer_get_bignum(& decrypted, prv->iqmp);
#line 409
  prv->q = BN_new();
#line 410
  buffer_get_bignum(& decrypted, prv->q);
#line 411
  prv->p = BN_new();
#line 412
  buffer_get_bignum(& decrypted, prv->p);
#line 414
  ctx = BN_CTX_new();
#line 415
  aux = BN_new();
#line 417
  tmp___21 = BN_value_one();
#line 417
  BN_sub(aux, (BIGNUM const   *)prv->q, tmp___21);
#line 418
  prv->dmq1 = BN_new();
#line 419
  BN_div((BIGNUM *)((void *)0), prv->dmq1, (BIGNUM const   *)prv->d, (BIGNUM const   *)aux,
         ctx);
#line 421
  tmp___22 = BN_value_one();
#line 421
  BN_sub(aux, (BIGNUM const   *)prv->p, tmp___22);
#line 422
  prv->dmp1 = BN_new();
#line 423
  BN_div((BIGNUM *)((void *)0), prv->dmp1, (BIGNUM const   *)prv->d, (BIGNUM const   *)aux,
         ctx);
#line 425
  BN_clear_free(aux);
#line 426
  BN_CTX_free(ctx);
#line 428
  buffer_free(& decrypted);
#line 430
  return (1);
}
}
#line 433 "authfile.c"
int load_private_key_dsa(int fd , char const   *passphrase , Key *k , char **comment_return ) 
{ DSA *dsa ;
  BIO *in ;
  FILE *fp ;
  BIO_METHOD *tmp ;
  int tmp___0 ;

  {
#line 440
  tmp = BIO_s_file();
#line 440
  in = BIO_new(tmp);
#line 441
  if ((unsigned int )in == (unsigned int )((void *)0)) {
#line 442
    error("BIO_new failed");
#line 443
    return (0);
  }
#line 445
  fp = fdopen(fd, "r");
#line 446
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 447
    error("fdopen failed");
#line 448
    return (0);
  }
#line 450
  BIO_ctrl(in, 106, 0L, (void *)((char *)fp));
#line 451
  dsa = PEM_read_bio_DSAPrivateKey(in, (DSA **)((void *)0), (pem_password_cb *)((void *)0),
                                   (void *)((char *)passphrase));
#line 452
  if ((unsigned int )dsa == (unsigned int )((void *)0)) {
#line 453
    debug("PEM_read_bio_DSAPrivateKey failed");
  } else {
#line 456
    DSA_free(k->dsa);
#line 457
    k->dsa = dsa;
  }
#line 459
  BIO_free(in);
#line 460
  fclose(fp);
#line 461
  if (comment_return) {
#line 462
    *comment_return = xstrdup("dsa w/o comment");
  }
#line 463
  debug("read DSA private key done");
#line 467
  if ((unsigned int )dsa != (unsigned int )((void *)0)) {
#line 467
    tmp___0 = 1;
  } else {
#line 467
    tmp___0 = 0;
  }
#line 467
  return (tmp___0);
}
}
#line 470 "authfile.c"
int load_private_key(char const   *filename , char const   *passphrase , Key *key ,
                     char **comment_return ) 
{ int fd ;
  int ret ;
  struct stat st ;
  int tmp ;
  __uid_t tmp___0 ;

  {
#line 475
  ret = 0;
#line 478
  fd = open(filename, 0);
#line 479
  if (fd < 0) {
#line 480
    return (0);
  }
#line 486
  tmp = fstat(fd, & st);
#line 486
  if (tmp < 0) {
    goto _L;
  } else {
#line 486
    if (st.st_uid != 0U) {
#line 486
      tmp___0 = getuid();
#line 486
      if (st.st_uid != tmp___0) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 486
      if ((st.st_mode & 63U) != 0U) {
        _L: /* CIL Label */ 
#line 489
        close(fd);
#line 490
        error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 491
        error("@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @");
#line 492
        error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 493
        error("Bad ownership or mode(0%3.3o) for \'%s\'.", st.st_mode & 511U, filename);
#line 495
        error("It is recommended that your private key files are NOT accessible by others.");
#line 496
        return (0);
      }
    }
  }
#line 498
  switch (key->type) {
  case 0: 
#line 500
  if ((unsigned int )(key->rsa)->e != (unsigned int )((void *)0)) {
#line 501
    BN_clear_free((key->rsa)->e);
#line 502
    (key->rsa)->e = (BIGNUM *)((void *)0);
  }
#line 504
  if ((unsigned int )(key->rsa)->n != (unsigned int )((void *)0)) {
#line 505
    BN_clear_free((key->rsa)->n);
#line 506
    (key->rsa)->n = (BIGNUM *)((void *)0);
  }
#line 508
  ret = load_private_key_rsa(fd, filename, passphrase, key->rsa, comment_return);
#line 510
  break;
  case 1: 
#line 512
  ret = load_private_key_dsa(fd, passphrase, key, comment_return);
  default: ;
#line 514
  break;
  }
#line 516
  close(fd);
#line 517
  return (ret);
}
}
#line 520 "authfile.c"
int do_load_public_key(char const   *filename , Key *k , char **commentp ) 
{ FILE *f ;
  unsigned int bits ;
  char line[1024] ;
  char *cp ;
  char *tmp ;

  {
#line 528
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 529
  if ((unsigned int )f != (unsigned int )((void *)0)) {
#line 530
    while (1) {
#line 530
      tmp = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 530
      if (! tmp) {
#line 530
        break;
      }
#line 531
      line[sizeof(line) - 1U] = (char )'\000';
#line 532
      cp = line;
#line 533
      switch ((int )*cp) {
      case 35: 
      case 10: 
      case 0: 
#line 537
      continue;
      }
#line 540
      while (1) {
#line 540
        if (*cp) {
#line 540
          if (! ((int )*cp == 32)) {
#line 540
            if (! ((int )*cp == 9)) {
#line 540
              break;
            }
          }
        } else {
#line 540
          break;
        }
#line 540
        cp ++;
      }
#line 542
      if (*cp) {
#line 543
        bits = key_read(k, & cp);
#line 544
        if (bits != 0U) {
#line 545
          if (commentp) {
#line 546
            *commentp = xstrdup(filename);
          }
#line 547
          fclose(f);
#line 548
          return (1);
        }
      }
    }
#line 552
    fclose(f);
  }
#line 554
  return (0);
}
}
#line 558 "authfile.c"
int try_load_public_key(char const   *filename , Key *k , char **commentp ) 
{ char pub[4096] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 563
  tmp = do_load_public_key(filename, k, commentp);
#line 563
  if (tmp == 1) {
#line 564
    return (1);
  }
#line 565
  tmp___0 = strlcpy(pub, filename, sizeof(pub));
#line 565
  if (tmp___0 >= 4096U) {
#line 566
    return (0);
  }
#line 567
  tmp___1 = strlcat(pub, ".pub", sizeof(pub));
#line 567
  if (tmp___1 >= 4096U) {
#line 568
    return (0);
  }
#line 569
  tmp___2 = do_load_public_key((char const   *)(pub), k, commentp);
#line 569
  if (tmp___2 == 1) {
#line 570
    return (1);
  }
#line 571
  return (0);
}
}
#line 1 "bufaux.o"
#line 412 "/usr/include/openssl/bn.h"
extern BIGNUM *BN_bin2bn(unsigned char const   *s , int len , BIGNUM *ret ) ;
#line 413
extern int BN_bn2bin(BIGNUM const   *a , unsigned char *to ) ;
#line 49 "buffer.h"
void buffer_get(Buffer *buffer , char *buf___1 , unsigned int len ) ;
#line 52
void buffer_consume(Buffer *buffer , unsigned int bytes ) ;
#line 29 "bufaux.h"
int buffer_get_bignum2(Buffer *buffer , BIGNUM *value ) ;
#line 52 "bufaux.c"
void buffer_put_bignum(Buffer *buffer , BIGNUM *value ) 
{ int bits ;
  int tmp ;
  int bin_size ;
  unsigned char *buf___1 ;
  void *tmp___0 ;
  int oi ;
  char msg[2] ;

  {
#line 55
  tmp = BN_num_bits((BIGNUM const   *)value);
#line 55
  bits = tmp;
#line 56
  bin_size = (bits + 7) / 8;
#line 57
  tmp___0 = xmalloc((unsigned int )bin_size);
#line 57
  buf___1 = (unsigned char *)tmp___0;
#line 62
  oi = BN_bn2bin((BIGNUM const   *)value, buf___1);
#line 63
  if (oi != bin_size) {
#line 64
    fatal("buffer_put_bignum: BN_bn2bin() failed: oi %d != bin_size %d", oi, bin_size);
  }
#line 68
  while (1) {
#line 68
    msg[0] = (char )(bits >> 8);
#line 68
    msg[1] = (char )bits;
#line 68
    break;
  }
#line 69
  buffer_append(buffer, (char const   *)(msg), 2U);
#line 71
  buffer_append(buffer, (char const   *)((char *)buf___1), (unsigned int )oi);
#line 73
  memset((void *)buf___1, 0, (unsigned int )bin_size);
#line 74
  xfree((void *)buf___1);
#line 75
  return;
}
}
#line 80 "bufaux.c"
int buffer_get_bignum(Buffer *buffer , BIGNUM *value ) 
{ int bits ;
  int bytes ;
  unsigned char buf___1[2] ;
  unsigned char *bin ;
  unsigned int tmp ;
  char *tmp___0 ;

  {
#line 87
  buffer_get(buffer, (char *)(buf___1), 2U);
#line 88
  bits = (int )(((unsigned long )buf___1[0] << 8) | (unsigned long )buf___1[1]);
#line 90
  bytes = (bits + 7) / 8;
#line 91
  tmp = buffer_len(buffer);
#line 91
  if (tmp < (unsigned int )bytes) {
#line 92
    fatal("buffer_get_bignum: input buffer too small");
  }
#line 93
  tmp___0 = buffer_ptr(buffer);
#line 93
  bin = (unsigned char *)tmp___0;
#line 94
  BN_bin2bn((unsigned char const   *)bin, bytes, value);
#line 95
  buffer_consume(buffer, (unsigned int )bytes);
#line 97
  return (2 + bytes);
}
}
#line 103 "bufaux.c"
void buffer_put_bignum2(Buffer *buffer , BIGNUM *value ) 
{ int bytes ;
  int tmp ;
  unsigned char *buf___1 ;
  void *tmp___0 ;
  int oi ;
  int hasnohigh ;
  int i ;
  int carry ;
  unsigned char *uc ;
  int tmp___1 ;

  {
#line 106
  tmp = BN_num_bits((BIGNUM const   *)value);
#line 106
  bytes = (tmp + 7) / 8 + 1;
#line 107
  tmp___0 = xmalloc((unsigned int )bytes);
#line 107
  buf___1 = (unsigned char *)tmp___0;
#line 109
  hasnohigh = 0;
#line 110
  *(buf___1 + 0) = (unsigned char )'\000';
#line 112
  oi = BN_bn2bin((BIGNUM const   *)value, buf___1 + 1);
#line 113
  if (oi != bytes - 1) {
#line 114
    fatal("buffer_put_bignum: BN_bn2bin() failed: oi %d != bin_size %d", oi, bytes);
  }
#line 116
  if ((int )*(buf___1 + 1) & 128) {
#line 116
    hasnohigh = 0;
  } else {
#line 116
    hasnohigh = 1;
  }
#line 117
  if (value->neg) {
#line 120
    uc = buf___1;
#line 121
    log("negativ!");
#line 122
    i = bytes - 1;
#line 122
    carry = 1;
#line 122
    while (i >= 0) {
#line 123
      *(uc + i) = (unsigned char )((int )*(uc + i) ^ 255);
#line 124
      if (carry) {
#line 125
        *(uc + i) = (unsigned char )((int )*(uc + i) + 1);
#line 125
        if (*(uc + i)) {
#line 125
          tmp___1 = 0;
        } else {
#line 125
          tmp___1 = 1;
        }
#line 125
        carry = tmp___1;
      }
#line 122
      i --;
    }
  }
#line 128
  buffer_put_string(buffer, (void const   *)(buf___1 + hasnohigh), (unsigned int )(bytes - hasnohigh));
#line 129
  memset((void *)buf___1, 0, (unsigned int )bytes);
#line 130
  xfree((void *)buf___1);
#line 131
  return;
}
}
#line 133 "bufaux.c"
int buffer_get_bignum2(Buffer *buffer , BIGNUM *value ) 
{ int len ;
  unsigned char *bin ;
  char *tmp ;

  {
#line 138
  tmp = buffer_get_string(buffer, (unsigned int *)(& len));
#line 138
  bin = (unsigned char *)tmp;
#line 139
  BN_bin2bn((unsigned char const   *)bin, len, value);
#line 140
  xfree((void *)bin);
#line 141
  return (len);
}
}
#line 147 "bufaux.c"
unsigned int buffer_get_int(Buffer *buffer ) 
{ unsigned char buf___1[4] ;

  {
#line 151
  buffer_get(buffer, (char *)(buf___1), 4U);
#line 152
  return ((unsigned int )(((((unsigned long )buf___1[0] << 24) | ((unsigned long )buf___1[1] << 16)) | ((unsigned long )buf___1[2] << 8)) | (unsigned long )buf___1[3]));
}
}
#line 158 "bufaux.c"
void buffer_put_int(Buffer *buffer , unsigned int value ) 
{ char buf___1[4] ;

  {
#line 162
  while (1) {
#line 162
    buf___1[0] = (char )(value >> 24);
#line 162
    buf___1[1] = (char )(value >> 16);
#line 162
    buf___1[2] = (char )(value >> 8);
#line 162
    buf___1[3] = (char )value;
#line 162
    break;
  }
#line 163
  buffer_append(buffer, (char const   *)(buf___1), 4U);
#line 164
  return;
}
}
#line 174 "bufaux.c"
char *buffer_get_string(Buffer *buffer , unsigned int *length_ptr ) 
{ unsigned int len ;
  char *value ;
  void *tmp ;

  {
#line 180
  len = buffer_get_int(buffer);
#line 181
  if (len > 262144U) {
#line 182
    fatal("Received packet with bad string length %d", len);
  }
#line 184
  tmp = xmalloc(len + 1U);
#line 184
  value = (char *)tmp;
#line 186
  buffer_get(buffer, value, len);
#line 188
  *(value + len) = (char)0;
#line 190
  if (length_ptr) {
#line 191
    *length_ptr = len;
  }
#line 192
  return (value);
}
}
#line 198 "bufaux.c"
void buffer_put_string(Buffer *buffer , void const   *buf___1 , unsigned int len ) 
{ 

  {
#line 201
  buffer_put_int(buffer, len);
#line 202
  buffer_append(buffer, (char const   *)buf___1, len);
#line 203
  return;
}
}
#line 204 "bufaux.c"
void buffer_put_cstring(Buffer *buffer , char const   *s ) 
{ size_t tmp ;

  {
#line 207
  tmp = strlen(s);
#line 207
  buffer_put_string(buffer, (void const   *)s, tmp);
#line 208
  return;
}
}
#line 213 "bufaux.c"
int buffer_get_char(Buffer *buffer ) 
{ char ch ;

  {
#line 217
  buffer_get(buffer, & ch, 1U);
#line 218
  return ((int )((unsigned char )ch));
}
}
#line 224 "bufaux.c"
void buffer_put_char(Buffer *buffer , int value ) 
{ char ch ;

  {
#line 227
  ch = (char )value;
#line 228
  buffer_append(buffer, (char const   *)(& ch), 1U);
#line 229
  return;
}
}
#line 1 "buffer.o"
#line 38 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                  size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 43
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 144 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 327
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 26 "xmalloc.h"
void *xrealloc(void *ptr , size_t new_size ) ;
#line 55 "buffer.h"
void buffer_consume_end(Buffer *buffer , unsigned int bytes ) ;
#line 64
void buffer_dump(Buffer *buffer ) ;
#line 23 "buffer.c"
void buffer_init(Buffer *buffer ) 
{ void *tmp ;

  {
#line 26
  buffer->alloc = 4096U;
#line 27
  tmp = xmalloc(buffer->alloc);
#line 27
  buffer->buf = (char *)tmp;
#line 28
  buffer->offset = 0U;
#line 29
  buffer->end = 0U;
#line 30
  return;
}
}
#line 34 "buffer.c"
void buffer_free(Buffer *buffer ) 
{ 

  {
#line 37
  memset((void *)buffer->buf, 0, buffer->alloc);
#line 38
  xfree((void *)buffer->buf);
#line 39
  return;
}
}
#line 46 "buffer.c"
void buffer_clear(Buffer *buffer ) 
{ 

  {
#line 49
  buffer->offset = 0U;
#line 50
  buffer->end = 0U;
#line 51
  return;
}
}
#line 55 "buffer.c"
void buffer_append(Buffer *buffer , char const   *data , unsigned int len ) 
{ char *cp ;

  {
#line 59
  buffer_append_space(buffer, & cp, len);
#line 60
  memcpy((void * __restrict  )cp, (void const   * __restrict  )data, len);
#line 61
  return;
}
}
#line 69 "buffer.c"
void buffer_append_space(Buffer *buffer , char **datap , unsigned int len ) 
{ void *tmp ;

  {
#line 73
  if (buffer->offset == buffer->end) {
#line 74
    buffer->offset = 0U;
#line 75
    buffer->end = 0U;
  }
  restart: 
#line 79
  if (buffer->end + len < buffer->alloc) {
#line 80
    *datap = buffer->buf + buffer->end;
#line 81
    buffer->end += len;
#line 82
    return;
  }
#line 88
  if (buffer->offset > buffer->alloc / 2U) {
#line 89
    memmove((void *)buffer->buf, (void const   *)(buffer->buf + buffer->offset), buffer->end - buffer->offset);
#line 91
    buffer->end -= buffer->offset;
#line 92
    buffer->offset = 0U;
    goto restart;
  }
#line 96
  buffer->alloc += len + 32768U;
#line 97
  tmp = xrealloc((void *)buffer->buf, buffer->alloc);
#line 97
  buffer->buf = (char *)tmp;
  goto restart;
}
}
#line 103 "buffer.c"
unsigned int buffer_len(Buffer *buffer ) 
{ 

  {
#line 106
  return (buffer->end - buffer->offset);
}
}
#line 111 "buffer.c"
void buffer_get(Buffer *buffer , char *buf___1 , unsigned int len ) 
{ 

  {
#line 114
  if (len > buffer->end - buffer->offset) {
#line 115
    fatal("buffer_get: trying to get more bytes than in buffer");
  }
#line 116
  memcpy((void * __restrict  )buf___1, (void const   * __restrict  )(buffer->buf + buffer->offset),
         len);
#line 117
  buffer->offset += len;
#line 118
  return;
}
}
#line 122 "buffer.c"
void buffer_consume(Buffer *buffer , unsigned int bytes ) 
{ 

  {
#line 125
  if (bytes > buffer->end - buffer->offset) {
#line 126
    fatal("buffer_consume: trying to get more bytes than in buffer");
  }
#line 127
  buffer->offset += bytes;
#line 128
  return;
}
}
#line 132 "buffer.c"
void buffer_consume_end(Buffer *buffer , unsigned int bytes ) 
{ 

  {
#line 135
  if (bytes > buffer->end - buffer->offset) {
#line 136
    fatal("buffer_consume_end: trying to get more bytes than in buffer");
  }
#line 137
  buffer->end -= bytes;
#line 138
  return;
}
}
#line 142 "buffer.c"
char *buffer_ptr(Buffer *buffer ) 
{ 

  {
#line 145
  return (buffer->buf + buffer->offset);
}
}
#line 150 "buffer.c"
void buffer_dump(Buffer *buffer ) 
{ int i ;
  unsigned char *ucp ;

  {
#line 154
  ucp = (unsigned char *)buffer->buf;
#line 156
  i = (int )buffer->offset;
#line 156
  while ((unsigned int )i < buffer->end) {
#line 157
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" %02x", *(ucp + i));
#line 156
    i ++;
  }
#line 158
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 159
  return;
}
}
#line 1 "canohost.o"
#line 114 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 128
extern  __attribute__((__nothrow__)) int getpeername(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 185
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
#line 352 "/usr/include/netdb.h"
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 631
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 637
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
#line 646
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , unsigned int __flags ) ;
#line 335 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 83
extern __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 116
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 190
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 190 "/usr/include/ctype.h"
__inline static int tolower(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
#line 193
  if (__c >= -128) {
#line 193
    if (__c < 256) {
#line 193
      tmp___1 = __ctype_tolower_loc();
#line 193
      tmp___0 = *(*tmp___1 + __c);
    } else {
#line 193
      tmp___0 = (int const   )__c;
    }
  } else {
#line 193
    tmp___0 = (int const   )__c;
  }
#line 193
  return ((int )tmp___0);
}
}
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 290
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   * __restrict  __nptr ,
                                                            char ** __restrict  __endptr ,
                                                            int __base , int __group )  __attribute__((__nonnull__(1))) ;
#line 332
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 332 "/usr/include/stdlib.h"
__inline static long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                            int __base ) 
{ long tmp ;

  {
#line 336
  tmp = __strtol_internal(__nptr, __endptr, __base, 0);
#line 336
  return (tmp);
}
}
#line 401
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 401 "/usr/include/stdlib.h"
__inline static int atoi(char const   *__nptr ) 
{ long tmp ;

  {
#line 404
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 404
  return ((int )tmp);
}
}
#line 32 "packet.h"
int packet_get_connection_in(void) ;
#line 150
void ( /* format attribute */  packet_disconnect)(char const   *fmt  , ...) ;
#line 208
int packet_connection_is_on_socket(void) ;
#line 384 "ssh.h"
char *get_remote_hostname(int socket___0 ) ;
#line 391
char const   *get_canonical_hostname(void) ;
#line 397
char const   *get_remote_ipaddr(void) ;
#line 400
int get_peer_port(int sock ) ;
#line 403
int get_remote_port(void) ;
#line 404
int get_local_port(void) ;
#line 469
void fatal_cleanup(void) ;
#line 26 "canohost.c"
char *get_remote_hostname(int socket___0 ) 
{ struct sockaddr_storage from ;
  int i ;
  socklen_t fromlen ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char name[64] ;
  char ntop[1025] ;
  char ntop2[1025] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  struct sockaddr_in6 *from6 ;
  struct sockaddr_in *from4 ;
  struct in_addr addr ;
  u_int16_t port ;
  register unsigned int __v ;
  register unsigned int __x ;
  int tmp___2 ;
  int __res ;
  __int32_t const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  unsigned char options___0[200] ;
  unsigned char *ucp ;
  char text[1024] ;
  char *cp ;
  socklen_t option_size ;
  int ipproto ;
  struct protoent *ip ;
  int tmp___20 ;
  char *tmp___21 ;

  {
#line 37
  fromlen = sizeof(from);
#line 38
  memset((void *)(& from), 0, sizeof(from));
#line 39
  tmp___1 = getpeername(socket___0, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                        (socklen_t * __restrict  )(& fromlen));
#line 39
  if (tmp___1 < 0) {
#line 40
    tmp = __errno_location();
#line 40
    tmp___0 = strerror(*tmp);
#line 40
    debug("getpeername failed: %.100s", tmp___0);
#line 41
    fatal_cleanup();
  }
#line 45
  if ((int )from.ss_family == 10) {
#line 46
    from6 = (struct sockaddr_in6 *)(& from);
#line 50
    if (*((uint32_t const   *)(& from6->sin6_addr) + 0) == 0U) {
#line 50
      if (*((uint32_t const   *)(& from6->sin6_addr) + 1) == 0U) {
#line 50
        __x = 65535U;
#line 50
        __asm__  ("rorw $8, %w0;"
                  "rorl $16, %0;"
                  "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 50
        if (*((uint32_t const   *)(& from6->sin6_addr) + 2) == (uint32_t const   )__v) {
#line 51
          from4 = (struct sockaddr_in *)(& from);
#line 55
          memcpy((void * __restrict  )(& addr), (void const   * __restrict  )((char *)(& from6->sin6_addr) + 12),
                 sizeof(addr));
#line 56
          port = from6->sin6_port;
#line 58
          memset((void *)(& from), 0, sizeof(from));
#line 60
          from4->sin_family = (unsigned short)2;
#line 61
          memcpy((void * __restrict  )(& from4->sin_addr), (void const   * __restrict  )(& addr),
                 sizeof(addr));
#line 62
          from4->sin_port = port;
        }
      }
    }
  }
#line 67
  tmp___2 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )((void *)0),
                        0U, 1U);
#line 67
  if (tmp___2 != 0) {
#line 69
    fatal("get_remote_hostname: getnameinfo NI_NUMERICHOST failed");
  }
#line 72
  tmp___19 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                         fromlen, (char * __restrict  )(name), sizeof(name), (char * __restrict  )((void *)0),
                         0U, 8U);
#line 72
  if (tmp___19 == 0) {
#line 75
    name[sizeof(name) - 1U] = (char )'\000';
#line 80
    i = 0;
#line 80
    while (name[i]) {
#line 81
      tmp___6 = __ctype_b_loc();
#line 81
      if ((int const   )*(*tmp___6 + (int )name[i]) & 256) {
#line 82
        if (sizeof(name[i]) > 1U) {
#line 82
          __res = tolower((int )name[i]);
        } else {
#line 82
          tmp___5 = __ctype_tolower_loc();
#line 82
          __res = (int )*(*tmp___5 + (int )name[i]);
        }
#line 82
        name[i] = (char )__res;
      }
#line 80
      i ++;
    }
#line 93
    memset((void *)(& hints), 0, sizeof(hints));
#line 94
    hints.ai_family = (int )from.ss_family;
#line 95
    hints.ai_socktype = 1;
#line 96
    tmp___7 = getaddrinfo((char const   * __restrict  )(name), (char const   * __restrict  )((void *)0),
                          (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 96
    if (tmp___7 != 0) {
#line 97
      log("reverse mapping checking getaddrinfo for %.700s failed - POSSIBLE BREAKIN ATTEMPT!",
          name);
#line 98
      strlcpy(name, (char const   *)(ntop), sizeof(name));
      goto check_ip_options;
    }
#line 102
    ai = aitop;
#line 102
    while (ai) {
#line 103
      tmp___8 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                            (char * __restrict  )(ntop2), sizeof(ntop2), (char * __restrict  )((void *)0),
                            0U, 1U);
#line 105
      if (tmp___8 == 0) {
#line 105
        if (0) {
#line 105
          __s1_len = strlen((char const   *)(ntop));
#line 105
          __s2_len = strlen((char const   *)(ntop2));
#line 105
          if (! ((unsigned int )((void const   *)(ntop + 1)) - (unsigned int )((void const   *)(ntop)) == 1U)) {
            goto _L___0;
          } else {
#line 105
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 105
              if (! ((unsigned int )((void const   *)(ntop2 + 1)) - (unsigned int )((void const   *)(ntop2)) == 1U)) {
#line 105
                tmp___18 = 1;
              } else {
#line 105
                if (__s2_len >= 4U) {
#line 105
                  tmp___18 = 1;
                } else {
#line 105
                  tmp___18 = 0;
                }
              }
            } else {
#line 105
              tmp___18 = 0;
            }
          }
#line 105
          if (tmp___18) {
#line 105
            tmp___14 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
          } else {
#line 105
            tmp___17 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
#line 105
            tmp___14 = tmp___17;
          }
        } else {
#line 105
          tmp___17 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
#line 105
          tmp___14 = tmp___17;
        }
#line 105
        if (tmp___14 == 0) {
#line 106
          break;
        }
      }
#line 102
      ai = ai->ai_next;
    }
#line 108
    freeaddrinfo(aitop);
#line 110
    if (! ai) {
#line 112
      log("Address %.100s maps to %.600s, but this does not map back to the address - POSSIBLE BREAKIN ATTEMPT!",
          ntop, name);
#line 114
      strlcpy(name, (char const   *)(ntop), sizeof(name));
      goto check_ip_options;
    }
  } else {
#line 120
    strlcpy(name, (char const   *)(ntop), sizeof(name));
#line 121
    log("Could not reverse map address %.100s.", name);
  }
  check_ip_options: 
#line 138
  if ((int )from.ss_family == 2) {
#line 145
    ip = getprotobyname("ip");
#line 145
    if ((unsigned int )ip != (unsigned int )((void *)0)) {
#line 146
      ipproto = ip->p_proto;
    } else {
#line 148
      ipproto = 0;
    }
#line 149
    option_size = sizeof(options___0);
#line 150
    tmp___20 = getsockopt(socket___0, ipproto, 4, (void * __restrict  )((char *)(options___0)),
                          (socklen_t * __restrict  )(& option_size));
#line 150
    if (tmp___20 >= 0) {
#line 150
      if (option_size != 0U) {
#line 152
        cp = text;
#line 154
        ucp = options___0;
#line 154
        while (option_size > 0U) {
#line 155
          sprintf((char * __restrict  )cp, (char const   * __restrict  )" %2.2x",
                  *ucp);
#line 154
          ucp ++;
#line 154
          option_size --;
#line 154
          cp += 3;
        }
#line 156
        log("Connection from %.100s with IP options:%.800s", ntop, text);
#line 158
        packet_disconnect("Connection from %.100s with IP options:%.800s", ntop, text);
      }
    }
  }
#line 163
  tmp___21 = xstrdup((char const   *)(name));
#line 163
  return (tmp___21);
}
}
#line 175 "canohost.c"
static char *canonical_host_name  =    (char *)((void *)0);
#line 172 "canohost.c"
char const   *get_canonical_hostname(void) 
{ int tmp ;
  int tmp___0 ;

  {
#line 178
  if ((unsigned int )canonical_host_name != (unsigned int )((void *)0)) {
#line 179
    return ((char const   *)canonical_host_name);
  }
#line 182
  tmp___0 = packet_connection_is_on_socket();
#line 182
  if (tmp___0) {
#line 183
    tmp = packet_get_connection_in();
#line 183
    canonical_host_name = get_remote_hostname(tmp);
  } else {
#line 185
    canonical_host_name = xstrdup("UNKNOWN");
  }
#line 187
  return ((char const   *)canonical_host_name);
}
}
#line 198 "canohost.c"
static char *canonical_host_ip  =    (char *)((void *)0);
#line 195 "canohost.c"
char const   *get_remote_ipaddr(void) 
{ struct sockaddr_storage from ;
  socklen_t fromlen ;
  int socket___0 ;
  char ntop[1025] ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 205
  if ((unsigned int )canonical_host_ip != (unsigned int )((void *)0)) {
#line 206
    return ((char const   *)canonical_host_ip);
  }
#line 209
  tmp = packet_connection_is_on_socket();
#line 209
  if (! tmp) {
#line 210
    canonical_host_ip = xstrdup("UNKNOWN");
#line 211
    return ((char const   *)canonical_host_ip);
  }
#line 214
  socket___0 = packet_get_connection_in();
#line 217
  fromlen = sizeof(from);
#line 218
  memset((void *)(& from), 0, sizeof(from));
#line 219
  tmp___2 = getpeername(socket___0, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                        (socklen_t * __restrict  )(& fromlen));
#line 219
  if (tmp___2 < 0) {
#line 220
    tmp___0 = __errno_location();
#line 220
    tmp___1 = strerror(*tmp___0);
#line 220
    debug("getpeername failed: %.100s", tmp___1);
#line 221
    fatal_cleanup();
  }
#line 224
  tmp___3 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )((void *)0),
                        0U, 1U);
#line 224
  if (tmp___3 != 0) {
#line 226
    fatal("get_remote_hostname: getnameinfo NI_NUMERICHOST failed");
  }
#line 228
  canonical_host_ip = xstrdup((char const   *)(ntop));
#line 231
  return ((char const   *)canonical_host_ip);
}
}
#line 236 "canohost.c"
int get_sock_port(int sock , int local ) 
{ struct sockaddr_storage from ;
  socklen_t fromlen ;
  char strport[32] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 244
  fromlen = sizeof(from);
#line 245
  memset((void *)(& from), 0, sizeof(from));
#line 246
  if (local) {
#line 247
    tmp___1 = getsockname(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 247
    if (tmp___1 < 0) {
#line 248
      tmp = __errno_location();
#line 248
      tmp___0 = strerror(*tmp);
#line 248
      error("getsockname failed: %.100s", tmp___0);
#line 249
      return (0);
    }
  } else {
#line 252
    tmp___4 = getpeername(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 252
    if (tmp___4 < 0) {
#line 253
      tmp___2 = __errno_location();
#line 253
      tmp___3 = strerror(*tmp___2);
#line 253
      debug("getpeername failed: %.100s", tmp___3);
#line 254
      fatal_cleanup();
    }
  }
#line 258
  tmp___5 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )((void *)0), 0U, (char * __restrict  )(strport),
                        sizeof(strport), 2U);
#line 258
  if (tmp___5 != 0) {
#line 260
    fatal("get_sock_port: getnameinfo NI_NUMERICSERV failed");
  }
#line 261
  tmp___6 = atoi((char const   *)(strport));
#line 261
  return (tmp___6);
}
}
#line 266 "canohost.c"
int get_port(int local ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 273
  tmp = packet_connection_is_on_socket();
#line 273
  if (! tmp) {
#line 274
    return (65535);
  }
#line 277
  tmp___0 = packet_get_connection_in();
#line 277
  tmp___1 = get_sock_port(tmp___0, local);
#line 277
  return (tmp___1);
}
}
#line 280 "canohost.c"
int get_peer_port(int sock ) 
{ int tmp ;

  {
#line 283
  tmp = get_sock_port(sock, 0);
#line 283
  return (tmp);
}
}
#line 286 "canohost.c"
int get_remote_port(void) 
{ int tmp ;

  {
#line 289
  tmp = get_port(0);
#line 289
  return (tmp);
}
}
#line 292 "canohost.c"
int get_local_port(void) 
{ int tmp ;

  {
#line 295
  tmp = get_port(1);
#line 295
  return (tmp);
}
}
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned int  ) ;  */
#line 1 "channels.o"
#line 110 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  *__addr ,
                                              socklen_t __len ) ;
#line 192
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 199
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 209
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 218
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
#line 62 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 102
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 170
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 573 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 801
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 845
extern  __attribute__((__nothrow__)) int gethostname(char *__name , size_t __len )  __attribute__((__nonnull__(1))) ;
#line 640 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
#line 357 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 407
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 632
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) )  __attribute__((__nonnull__(1))) ;
#line 729
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template )  __attribute__((__nonnull__(1))) ;
#line 463 "ssh.h"
void ( /* format attribute */  verbose)(char const   *fmt  , ...) ;
#line 465
void ( /* format attribute */  debug2)(char const   *fmt  , ...) ;
#line 476
void fatal_add_cleanup(void (*proc)(void *context ) , void *context ) ;
#line 496
void set_nonblock(int fd ) ;
#line 554
int IPv4or6 ;
#line 71 "packet.h"
int packet_is_interactive(void) ;
#line 74
void packet_start(int type ) ;
#line 77
void packet_put_char(int value ) ;
#line 80
void packet_put_int(unsigned int value ) ;
#line 87
void packet_put_string(char const   *buf___1 , unsigned int len ) ;
#line 88
void packet_put_cstring(char const   *str ) ;
#line 95
void packet_send(void) ;
#line 104
void packet_read_expect(int *payload_len_ptr , int expected_type ) ;
#line 126
unsigned int packet_get_int(void) ;
#line 142
char *packet_get_string(unsigned int *length_ptr ) ;
#line 162
void ( /* format attribute */  packet_send_debug)(char const   *fmt  , ...) ;
#line 168
void packet_write_wait(void) ;
#line 177
int max_packet_size ;
#line 215
int packet_remaining(void) ;
#line 20 "uidswap.h"
void temporarily_use_uid(uid_t uid ) ;
#line 26
void restore_uid(void) ;
#line 120 "channels.h"
void channel_open(int id ) ;
#line 121
void channel_request(int id , char *service , int wantconfirm ) ;
#line 122
void channel_request_start(int id , char *service , int wantconfirm ) ;
#line 123
void channel_register_callback(int id , int mtype , channel_callback_fn *fn , void *arg ) ;
#line 124
void channel_register_cleanup(int id , channel_callback_fn *fn ) ;
#line 125
void channel_register_filter(int id , channel_filter_fn *fn ) ;
#line 126
void channel_cancel_cleanup(int id ) ;
#line 127
Channel *channel_lookup(int id ) ;
#line 129
int channel_new(char *ctype , int type , int rfd , int wfd , int efd , int window ,
                int maxpack , int extusage , char *remote_name , int nonblock ) ;
#line 133
void channel_set_fds(int id , int rfd , int wfd , int efd , int extusage , int nonblock ) ;
#line 137
void deny_input_open(int type , int plen , void *ctxt ) ;
#line 139
void channel_input_channel_request(int type , int plen , void *ctxt ) ;
#line 140
void channel_input_close(int type , int plen , void *ctxt ) ;
#line 141
void channel_input_close_confirmation(int type , int plen , void *ctxt ) ;
#line 142
void channel_input_data(int type , int plen , void *ctxt ) ;
#line 143
void channel_input_extended_data(int type , int plen , void *ctxt ) ;
#line 144
void channel_input_ieof(int type , int plen , void *ctxt ) ;
#line 145
void channel_input_oclose(int type , int plen , void *ctxt ) ;
#line 146
void channel_input_open_confirmation(int type , int plen , void *ctxt ) ;
#line 147
void channel_input_open_failure(int type , int plen , void *ctxt ) ;
#line 148
void channel_input_port_open(int type , int plen , void *ctxt ) ;
#line 149
void channel_input_window_adjust(int type , int plen , void *ctxt ) ;
#line 153
void channel_set_options(int hostname_in_open ) ;
#line 160
int channel_allocate(int type , int sock , char *remote_name ) ;
#line 163
void channel_free(int id ) ;
#line 166
void channel_prepare_select(fd_set *readset , fd_set *writeset ) ;
#line 172
void channel_after_select(fd_set *readset , fd_set *writeset ) ;
#line 175
void channel_output_poll(void) ;
#line 178
int channel_not_very_much_buffered_data(void) ;
#line 182
void channel_stop_listening(void) ;
#line 188
void channel_close_all(void) ;
#line 191
int channel_max_fd(void) ;
#line 194
int channel_still_open(void) ;
#line 201
char *channel_open_message(void) ;
#line 208
void channel_request_local_forwarding(u_short port , char const   *host , u_short host_port ,
                                      int gateway_ports ) ;
#line 218
void channel_request_remote_forwarding(u_short listen_port , char const   *host_to_connect ,
                                       u_short port_to_connect ) ;
#line 227
void channel_permit_all_opens(void) ;
#line 234
void channel_input_port_forward_request(int is_root , int gateway_ports ) ;
#line 247
char *x11_create_display_inet(int screen_number , int x11_display_offset ) ;
#line 254
void x11_input_open(int type , int plen , void *ctxt ) ;
#line 266
void x11_request_forwarding_with_spoofing(int client_session_id , char const   *proto ,
                                          char const   *data ) ;
#line 271
void auth_request_forwarding(void) ;
#line 278
char *auth_get_socket_name(void) ;
#line 284
int auth_input_request_forwarding(struct passwd *pw ) ;
#line 287
void auth_input_open_request(int type , int plen , void *ctxt ) ;
#line 290
int channel_connect_to(char const   *host , u_short host_port ) ;
#line 291
int x11_connect_display(void) ;
#line 78 "nchan.h"
chan_event_fn *chan_rcvd_oclose ;
#line 79
chan_event_fn *chan_read_failed ;
#line 80
chan_event_fn *chan_ibuf_empty ;
#line 83
chan_event_fn *chan_rcvd_ieof ;
#line 84
chan_event_fn *chan_write_failed ;
#line 85
chan_event_fn *chan_obuf_empty ;
#line 87
chan_event_fn *chan_delete_if_full_closed ;
#line 89
void chan_init_iostates(Channel *c ) ;
#line 90
void chan_init(void) ;
#line 44 "compat.h"
int compat13 ;
#line 45
int compat20 ;
#line 74 "channels.c"
static Channel *channels  =    (Channel *)((void *)0);
#line 81 "channels.c"
static int channels_alloc  =    0;
#line 87 "channels.c"
static int channel_max_fd_value  =    0;
#line 90 "channels.c"
static char *channel_forwarded_auth_socket_name  =    (char *)((void *)0);
#line 91 "channels.c"
static char *channel_forwarded_auth_socket_dir  =    (char *)((void *)0);
#line 94 "channels.c"
char *x11_saved_proto  =    (char *)((void *)0);
#line 97 "channels.c"
char *x11_saved_data  =    (char *)((void *)0);
#line 98 "channels.c"
unsigned int x11_saved_data_len  =    0U;
#line 104 "channels.c"
char *x11_fake_data  =    (char *)((void *)0);
#line 105 "channels.c"
unsigned int x11_fake_data_len  ;
#line 120 "channels.c"
static ForwardPermission permitted_opens[100]  ;
#line 122 "channels.c"
static int num_permitted_opens  =    0;
#line 128 "channels.c"
static int all_opens_permitted  =    0;
#line 131 "channels.c"
static int have_hostname_in_open  =    0;
#line 135 "channels.c"
void channel_set_options(int hostname_in_open ) 
{ 

  {
#line 138
  have_hostname_in_open = hostname_in_open;
#line 139
  return;
}
}
#line 147 "channels.c"
void channel_permit_all_opens(void) 
{ 

  {
#line 150
  all_opens_permitted = 1;
#line 151
  return;
}
}
#line 155 "channels.c"
Channel *channel_lookup(int id ) 
{ Channel *c ;

  {
#line 159
  if (id < 0) {
#line 160
    log("channel_lookup: %d: bad id", id);
#line 161
    return ((Channel *)((void *)0));
  } else {
#line 159
    if (id > channels_alloc) {
#line 160
      log("channel_lookup: %d: bad id", id);
#line 161
      return ((Channel *)((void *)0));
    }
  }
#line 163
  c = channels + id;
#line 164
  if (c->type == 0) {
#line 165
    log("channel_lookup: %d: bad id: channel free", id);
#line 166
    return ((Channel *)((void *)0));
  }
#line 168
  return (c);
}
}
#line 176 "channels.c"
void channel_register_fds(Channel *c , int rfd , int wfd , int efd , int extusage ,
                          int nonblock ) 
{ 

  {
#line 181
  if (rfd > channel_max_fd_value) {
#line 182
    channel_max_fd_value = rfd;
  }
#line 183
  if (wfd > channel_max_fd_value) {
#line 184
    channel_max_fd_value = wfd;
  }
#line 185
  if (efd > channel_max_fd_value) {
#line 186
    channel_max_fd_value = efd;
  }
#line 189
  c->rfd = rfd;
#line 190
  c->wfd = wfd;
#line 191
  if (rfd == wfd) {
#line 191
    c->sock = rfd;
  } else {
#line 191
    c->sock = -1;
  }
#line 192
  c->efd = efd;
#line 193
  c->extended_usage = extusage;
#line 196
  if (nonblock) {
#line 197
    if (rfd != -1) {
#line 198
      set_nonblock(rfd);
    }
#line 199
    if (wfd != -1) {
#line 200
      set_nonblock(wfd);
    }
#line 201
    if (efd != -1) {
#line 202
      set_nonblock(efd);
    }
  }
#line 204
  return;
}
}
#line 211 "channels.c"
int channel_new(char *ctype , int type , int rfd , int wfd , int efd , int window ,
                int maxpack , int extusage , char *remote_name , int nonblock ) 
{ int i ;
  int found ;
  Channel *c ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 219
  if (channels_alloc == 0) {
#line 220
    chan_init();
#line 221
    channels_alloc = 10;
#line 222
    tmp = xmalloc((unsigned int )channels_alloc * sizeof(Channel ));
#line 222
    channels = (Channel *)tmp;
#line 223
    i = 0;
#line 223
    while (i < channels_alloc) {
#line 224
      (channels + i)->type = 0;
#line 223
      i ++;
    }
#line 229
    fatal_add_cleanup((void (*)(void * ))(& channel_stop_listening), (void *)0);
  }
#line 232
  found = -1;
#line 232
  i = 0;
#line 232
  while (i < channels_alloc) {
#line 233
    if ((channels + i)->type == 0) {
#line 235
      found = i;
#line 236
      break;
    }
#line 232
    i ++;
  }
#line 238
  if (found == -1) {
#line 240
    found = channels_alloc;
#line 241
    channels_alloc += 10;
#line 242
    debug2("channel: expanding %d", channels_alloc);
#line 243
    tmp___0 = xrealloc((void *)channels, (unsigned int )channels_alloc * sizeof(Channel ));
#line 243
    channels = (Channel *)tmp___0;
#line 244
    i = found;
#line 244
    while (i < channels_alloc) {
#line 245
      (channels + i)->type = 0;
#line 244
      i ++;
    }
  }
#line 248
  c = channels + found;
#line 249
  buffer_init(& c->input);
#line 250
  buffer_init(& c->output);
#line 251
  buffer_init(& c->extended);
#line 252
  chan_init_iostates(c);
#line 253
  channel_register_fds(c, rfd, wfd, efd, extusage, nonblock);
#line 254
  c->self = found;
#line 255
  c->type = type;
#line 256
  c->ctype = ctype;
#line 257
  c->local_window = window;
#line 258
  c->local_window_max = window;
#line 259
  c->local_consumed = 0;
#line 260
  c->local_maxpacket = maxpack;
#line 261
  c->remote_id = -1;
#line 262
  c->remote_name = remote_name;
#line 263
  c->remote_window = 0;
#line 264
  c->remote_maxpacket = 0;
#line 265
  c->cb_fn = (channel_callback_fn *)((void *)0);
#line 266
  c->cb_arg = (void *)0;
#line 267
  c->cb_event = 0;
#line 268
  c->dettach_user = (channel_callback_fn *)((void *)0);
#line 269
  c->input_filter = (channel_filter_fn *)((void *)0);
#line 270
  debug("channel %d: new [%s]", found, remote_name);
#line 271
  return (found);
}
}
#line 274 "channels.c"
int channel_allocate(int type , int sock , char *remote_name ) 
{ int tmp ;

  {
#line 277
  tmp = channel_new((char *)"", type, sock, sock, -1, 0, 0, 0, remote_name, 1);
#line 277
  return (tmp);
}
}
#line 283 "channels.c"
void channel_close_fds(Channel *c ) 
{ 

  {
#line 286
  if (c->sock != -1) {
#line 287
    close(c->sock);
#line 288
    c->sock = -1;
  }
#line 290
  if (c->rfd != -1) {
#line 291
    close(c->rfd);
#line 292
    c->rfd = -1;
  }
#line 294
  if (c->wfd != -1) {
#line 295
    close(c->wfd);
#line 296
    c->wfd = -1;
  }
#line 298
  if (c->efd != -1) {
#line 299
    close(c->efd);
#line 300
    c->efd = -1;
  }
#line 302
  return;
}
}
#line 306 "channels.c"
void channel_free(int id ) 
{ Channel *c ;
  Channel *tmp ;
  char *tmp___0 ;

  {
#line 309
  tmp = channel_lookup(id);
#line 309
  c = tmp;
#line 310
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 311
    packet_disconnect("channel free: bad local channel %d", id);
  }
#line 312
  tmp___0 = channel_open_message();
#line 312
  debug("channel_free: channel %d: status: %s", id, tmp___0);
#line 313
  if ((unsigned int )c->dettach_user != (unsigned int )((void *)0)) {
#line 314
    debug("channel_free: channel %d: dettaching channel user", id);
#line 315
    (*(c->dettach_user))(c->self, (void *)0);
  }
#line 317
  if (c->sock != -1) {
#line 318
    shutdown(c->sock, 2);
  }
#line 319
  channel_close_fds(c);
#line 320
  buffer_free(& c->input);
#line 321
  buffer_free(& c->output);
#line 322
  buffer_free(& c->extended);
#line 323
  c->type = 0;
#line 324
  if (c->remote_name) {
#line 325
    xfree((void *)c->remote_name);
#line 326
    c->remote_name = (char *)((void *)0);
  }
#line 328
  return;
}
}
#line 339 "channels.c"
chan_fn *channel_pre[11]  ;
#line 340 "channels.c"
chan_fn *channel_post[11]  ;
#line 342 "channels.c"
void channel_pre_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 345
  __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 346
  return;
}
}
#line 348 "channels.c"
void channel_pre_open_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 351
  tmp = buffer_len(& c->input);
#line 351
  if (tmp < (unsigned int )max_packet_size) {
#line 352
    __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 353
  tmp___0 = buffer_len(& c->output);
#line 353
  if (tmp___0 > 0U) {
#line 354
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 355
  return;
}
}
#line 357 "channels.c"
void channel_pre_open_15(Channel *c , fd_set *readset , fd_set *writeset ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 361
  if (c->istate == 1) {
#line 362
    tmp = buffer_len(& c->input);
#line 362
    if (tmp < (unsigned int )max_packet_size) {
#line 363
      __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
  }
#line 364
  if (c->ostate == 16) {
    goto _L;
  } else {
#line 364
    if (c->ostate == 32) {
      _L: /* CIL Label */ 
#line 366
      tmp___0 = buffer_len(& c->output);
#line 366
      if (tmp___0 > 0U) {
#line 367
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      } else {
#line 368
        if (c->ostate == 32) {
#line 369
          (*chan_obuf_empty)(c);
        }
      }
    }
  }
#line 372
  return;
}
}
#line 374 "channels.c"
void channel_pre_open_20(Channel *c , fd_set *readset , fd_set *writeset ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 377
  if (c->istate == 1) {
#line 377
    if (c->remote_window > 0) {
#line 377
      tmp = buffer_len(& c->input);
#line 377
      if (tmp < (unsigned int )c->remote_window) {
#line 380
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->rfd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->rfd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
  }
#line 381
  if (c->ostate == 16) {
    goto _L;
  } else {
#line 381
    if (c->ostate == 32) {
      _L: /* CIL Label */ 
#line 383
      tmp___0 = buffer_len(& c->output);
#line 383
      if (tmp___0 > 0U) {
#line 384
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->wfd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->wfd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      } else {
#line 385
        if (c->ostate == 32) {
#line 386
          (*chan_obuf_empty)(c);
        }
      }
    }
  }
#line 390
  if (c->efd != -1) {
#line 391
    if (c->extended_usage == 2) {
#line 391
      tmp___2 = buffer_len(& c->extended);
#line 391
      if (tmp___2 > 0U) {
#line 393
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 394
      if (c->extended_usage == 1) {
#line 394
        tmp___1 = buffer_len(& c->extended);
#line 394
        if (tmp___1 < (unsigned int )c->remote_window) {
#line 396
          __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        }
      }
    }
  }
#line 398
  return;
}
}
#line 400 "channels.c"
void channel_pre_input_draining(Channel *c , fd_set *readset , fd_set *writeset ) 
{ unsigned int tmp ;

  {
#line 403
  tmp = buffer_len(& c->input);
#line 403
  if (tmp == 0U) {
#line 404
    packet_start(24);
#line 405
    packet_put_int((unsigned int )c->remote_id);
#line 406
    packet_send();
#line 407
    c->type = 5;
#line 408
    debug("Closing channel %d after input drain.", c->self);
  }
#line 410
  return;
}
}
#line 412 "channels.c"
void channel_pre_output_draining(Channel *c , fd_set *readset , fd_set *writeset ) 
{ unsigned int tmp ;

  {
#line 415
  tmp = buffer_len(& c->output);
#line 415
  if (tmp == 0U) {
#line 416
    channel_free(c->self);
  } else {
#line 418
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 419
  return;
}
}
#line 429 "channels.c"
int x11_open_helper(Channel *c ) 
{ unsigned char *ucp ;
  unsigned int proto_len ;
  unsigned int data_len ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 436
  tmp = buffer_len(& c->output);
#line 436
  if (tmp < 12U) {
#line 437
    return (0);
  }
#line 440
  tmp___0 = buffer_ptr(& c->output);
#line 440
  ucp = (unsigned char *)tmp___0;
#line 441
  if ((int )*(ucp + 0) == 66) {
#line 442
    proto_len = (unsigned int )(256 * (int )*(ucp + 6) + (int )*(ucp + 7));
#line 443
    data_len = (unsigned int )(256 * (int )*(ucp + 8) + (int )*(ucp + 9));
  } else {
#line 444
    if ((int )*(ucp + 0) == 108) {
#line 445
      proto_len = (unsigned int )((int )*(ucp + 6) + 256 * (int )*(ucp + 7));
#line 446
      data_len = (unsigned int )((int )*(ucp + 8) + 256 * (int )*(ucp + 9));
    } else {
#line 448
      debug("Initial X11 packet contains bad byte order byte: 0x%x", *(ucp + 0));
#line 450
      return (-1);
    }
  }
#line 454
  tmp___1 = buffer_len(& c->output);
#line 454
  if (tmp___1 < (12U + ((proto_len + 3U) & 4294967292U)) + ((data_len + 3U) & 4294967292U)) {
#line 456
    return (0);
  }
#line 459
  tmp___2 = strlen((char const   *)x11_saved_proto);
#line 459
  if (proto_len != tmp___2) {
#line 461
    debug("X11 connection uses different authentication protocol.");
#line 462
    return (-1);
  } else {
#line 459
    tmp___3 = memcmp((void const   *)(ucp + 12), (void const   *)x11_saved_proto,
                     proto_len);
#line 459
    if (tmp___3 != 0) {
#line 461
      debug("X11 connection uses different authentication protocol.");
#line 462
      return (-1);
    }
  }
#line 465
  if (data_len != x11_fake_data_len) {
#line 468
    debug("X11 auth data does not match fake data.");
#line 469
    return (-1);
  } else {
#line 465
    tmp___4 = memcmp((void const   *)((ucp + 12) + ((proto_len + 3U) & 4294967292U)),
                     (void const   *)x11_fake_data, x11_fake_data_len);
#line 465
    if (tmp___4 != 0) {
#line 468
      debug("X11 auth data does not match fake data.");
#line 469
      return (-1);
    }
  }
#line 472
  if (x11_fake_data_len != x11_saved_data_len) {
#line 473
    error("X11 fake_data_len %d != saved_data_len %d", x11_fake_data_len, x11_saved_data_len);
#line 475
    return (-1);
  }
#line 482
  memcpy((void * __restrict  )((ucp + 12) + ((proto_len + 3U) & 4294967292U)), (void const   * __restrict  )x11_saved_data,
         x11_saved_data_len);
#line 484
  return (1);
}
}
#line 487 "channels.c"
void channel_pre_x11_open_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int ret ;
  int tmp ;

  {
#line 490
  tmp = x11_open_helper(c);
#line 490
  ret = tmp;
#line 491
  if (ret == 1) {
#line 493
    c->type = 4;
#line 494
    channel_pre_open_13(c, readset, writeset);
  } else {
#line 495
    if (ret == -1) {
#line 500
      log("X11 connection rejected because of wrong authentication.\r\n");
#line 501
      buffer_clear(& c->input);
#line 502
      buffer_clear(& c->output);
#line 503
      close(c->sock);
#line 504
      c->sock = -1;
#line 505
      c->type = 5;
#line 506
      packet_start(24);
#line 507
      packet_put_int((unsigned int )c->remote_id);
#line 508
      packet_send();
    }
  }
#line 510
  return;
}
}
#line 512 "channels.c"
void channel_pre_x11_open(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int ret ;
  int tmp ;

  {
#line 515
  tmp = x11_open_helper(c);
#line 515
  ret = tmp;
#line 516
  if (ret == 1) {
#line 517
    c->type = 4;
#line 518
    if (compat20) {
#line 519
      channel_pre_open_20(c, readset, writeset);
    } else {
#line 521
      channel_pre_open_15(c, readset, writeset);
    }
  } else {
#line 522
    if (ret == -1) {
#line 523
      debug("X11 rejected %d i%d/o%d", c->self, c->istate, c->ostate);
#line 524
      (*chan_read_failed)(c);
#line 525
      (*chan_write_failed)(c);
#line 526
      debug("X11 closed %d i%d/o%d", c->self, c->istate, c->ostate);
    }
  }
#line 528
  return;
}
}
#line 531 "channels.c"
void channel_post_x11_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ struct sockaddr addr ;
  int newsock ;
  int newch ;
  socklen_t addrlen ;
  char buf___1[16384] ;
  char *remote_hostname ;
  int remote_port ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  register char __result ;

  {
#line 540
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 540
  if (__result) {
#line 541
    debug("X11 connection requested.");
#line 542
    addrlen = sizeof(addr);
#line 543
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 544
    if (newsock < 0) {
#line 545
      tmp = __errno_location();
#line 545
      tmp___0 = strerror(*tmp);
#line 545
      error("accept: %.100s", tmp___0);
#line 546
      return;
    }
#line 548
    remote_hostname = get_remote_hostname(newsock);
#line 549
    remote_port = get_peer_port(newsock);
#line 550
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"X11 connection from %.200s port %d",
             remote_hostname, remote_port);
#line 553
    tmp___1 = xstrdup((char const   *)(buf___1));
#line 553
    newch = channel_new((char *)"x11", 3, newsock, newsock, -1, c->local_window_max,
                        c->local_maxpacket, 0, tmp___1, 1);
#line 557
    if (compat20) {
#line 558
      packet_start(90);
#line 559
      packet_put_cstring("x11");
#line 560
      packet_put_int((unsigned int )newch);
#line 561
      packet_put_int((unsigned int )c->local_window_max);
#line 562
      packet_put_int((unsigned int )c->local_maxpacket);
#line 564
      packet_put_cstring((char const   *)remote_hostname);
#line 565
      if (datafellows & 8) {
#line 566
        debug("ssh2 x11 bug compat mode");
      } else {
#line 568
        packet_put_int((unsigned int )remote_port);
      }
#line 570
      packet_send();
    } else {
#line 572
      packet_start(27);
#line 573
      packet_put_int((unsigned int )newch);
#line 574
      if (have_hostname_in_open) {
#line 575
        tmp___2 = strlen((char const   *)(buf___1));
#line 575
        packet_put_string((char const   *)(buf___1), tmp___2);
      }
#line 576
      packet_send();
    }
#line 578
    xfree((void *)remote_hostname);
  }
#line 580
  return;
}
}
#line 585 "channels.c"
void channel_post_port_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ struct sockaddr addr ;
  int newsock ;
  int newch ;
  socklen_t addrlen ;
  char buf___1[1024] ;
  char *remote_hostname ;
  int remote_port ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  register char __result ;

  {
#line 594
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 594
  if (__result) {
#line 595
    debug("Connection to port %d forwarding to %.100s port %d requested.", c->listening_port,
          c->path, c->host_port);
#line 598
    addrlen = sizeof(addr);
#line 599
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 600
    if (newsock < 0) {
#line 601
      tmp = __errno_location();
#line 601
      tmp___0 = strerror(*tmp);
#line 601
      error("accept: %.100s", tmp___0);
#line 602
      return;
    }
#line 604
    remote_hostname = get_remote_hostname(newsock);
#line 605
    remote_port = get_peer_port(newsock);
#line 606
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"listen port %d for %.100s port %d, connect from %.200s port %d",
             c->listening_port, c->path, c->host_port, remote_hostname, remote_port);
#line 611
    tmp___1 = xstrdup((char const   *)(buf___1));
#line 611
    newch = channel_new((char *)"direct-tcpip", 3, newsock, newsock, -1, c->local_window_max,
                        c->local_maxpacket, 0, tmp___1, 1);
#line 615
    if (compat20) {
#line 616
      packet_start(90);
#line 617
      packet_put_cstring("direct-tcpip");
#line 618
      packet_put_int((unsigned int )newch);
#line 619
      packet_put_int((unsigned int )c->local_window_max);
#line 620
      packet_put_int((unsigned int )c->local_maxpacket);
#line 622
      tmp___2 = strlen((char const   *)(c->path));
#line 622
      packet_put_string((char const   *)(c->path), tmp___2);
#line 623
      packet_put_int((unsigned int )c->host_port);
#line 625
      packet_put_cstring((char const   *)remote_hostname);
#line 626
      packet_put_int((unsigned int )remote_port);
#line 627
      packet_send();
    } else {
#line 629
      packet_start(29);
#line 630
      packet_put_int((unsigned int )newch);
#line 631
      tmp___3 = strlen((char const   *)(c->path));
#line 631
      packet_put_string((char const   *)(c->path), tmp___3);
#line 632
      packet_put_int((unsigned int )c->host_port);
#line 633
      if (have_hostname_in_open) {
#line 634
        tmp___4 = strlen((char const   *)(buf___1));
#line 634
        packet_put_string((char const   *)(buf___1), tmp___4);
      }
#line 636
      packet_send();
    }
#line 638
    xfree((void *)remote_hostname);
  }
#line 640
  return;
}
}
#line 646 "channels.c"
void channel_post_auth_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ struct sockaddr addr ;
  int newsock ;
  int newch ;
  socklen_t addrlen ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  register char __result ;

  {
#line 653
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 653
  if (__result) {
#line 654
    addrlen = sizeof(addr);
#line 655
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 656
    if (newsock < 0) {
#line 657
      tmp = __errno_location();
#line 657
      tmp___0 = strerror(*tmp);
#line 657
      error("accept from auth socket: %.100s", tmp___0);
#line 658
      return;
    }
#line 660
    tmp___1 = xstrdup("accepted auth socket");
#line 660
    newch = channel_allocate(3, newsock, tmp___1);
#line 662
    packet_start(31);
#line 663
    packet_put_int((unsigned int )newch);
#line 664
    packet_send();
  }
#line 666
  return;
}
}
#line 668 "channels.c"
int channel_handle_rfd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char buf___1[16384] ;
  int len ;
  int *tmp ;
  int *tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  register char __result ;

  {
#line 675
  if (c->rfd != -1) {
#line 675
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->rfd % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )c->rfd / (8U * sizeof(__fd_mask ))]): "cc");
#line 675
    if (__result) {
#line 676
      len = read(c->rfd, (void *)(buf___1), sizeof(buf___1));
#line 677
      if (len < 0) {
#line 677
        tmp = __errno_location();
#line 677
        if (*tmp == 4) {
#line 678
          return (1);
        } else {
#line 677
          tmp___0 = __errno_location();
#line 677
          if (*tmp___0 == 11) {
#line 678
            return (1);
          }
        }
      }
#line 679
      if (len <= 0) {
#line 680
        debug("channel %d: read<=0 rfd %d len %d", c->self, c->rfd, len);
#line 682
        if (compat13) {
#line 683
          tmp___1 = buffer_len(& c->output);
#line 683
          buffer_consume(& c->output, tmp___1);
#line 684
          c->type = 8;
#line 685
          debug("Channel %d status set to input draining.", c->self);
        } else {
#line 687
          (*chan_read_failed)(c);
        }
#line 689
        return (-1);
      }
#line 691
      if ((unsigned int )c->input_filter != (unsigned int )((void *)0)) {
#line 692
        tmp___2 = (*(c->input_filter))(c, buf___1, len);
#line 692
        if (tmp___2 == -1) {
#line 693
          debug("filter stops channel %d", c->self);
#line 694
          (*chan_read_failed)(c);
        }
      } else {
#line 697
        buffer_append(& c->input, (char const   *)(buf___1), (unsigned int )len);
      }
    }
  }
#line 700
  return (1);
}
}
#line 702 "channels.c"
int channel_handle_wfd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  unsigned int tmp___3 ;
  register char __result ;
  unsigned int tmp___4 ;

  {
#line 709
  if (c->wfd != -1) {
#line 709
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->wfd % (8U * sizeof(__fd_mask ))),
                         "m" (writeset->__fds_bits[(unsigned int )c->wfd / (8U * sizeof(__fd_mask ))]): "cc");
#line 709
    if (__result) {
#line 709
      tmp___4 = buffer_len(& c->output);
#line 709
      if (tmp___4 > 0U) {
#line 711
        tmp = buffer_len(& c->output);
#line 711
        tmp___0 = buffer_ptr(& c->output);
#line 711
        len = write(c->wfd, (void const   *)tmp___0, tmp);
#line 713
        if (len < 0) {
#line 713
          tmp___1 = __errno_location();
#line 713
          if (*tmp___1 == 4) {
#line 714
            return (1);
          } else {
#line 713
            tmp___2 = __errno_location();
#line 713
            if (*tmp___2 == 11) {
#line 714
              return (1);
            }
          }
        }
#line 715
        if (len <= 0) {
#line 716
          if (compat13) {
#line 717
            tmp___3 = buffer_len(& c->output);
#line 717
            buffer_consume(& c->output, tmp___3);
#line 718
            debug("Channel %d status set to input draining.", c->self);
#line 719
            c->type = 8;
          } else {
#line 721
            (*chan_write_failed)(c);
          }
#line 723
          return (-1);
        }
#line 725
        buffer_consume(& c->output, (unsigned int )len);
#line 726
        if (compat20) {
#line 726
          if (len > 0) {
#line 727
            c->local_consumed += len;
          }
        }
      }
    }
  }
#line 730
  return (1);
}
}
#line 732 "channels.c"
int channel_handle_efd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char buf___1[16384] ;
  int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  register char __result ;
  register char __result___0 ;
  unsigned int tmp___1 ;

  {
#line 739
  if (c->efd != -1) {
#line 741
    if (c->extended_usage == 2) {
#line 741
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))),
                           "m" (writeset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "cc");
#line 741
      if (__result___0) {
#line 741
        tmp___1 = buffer_len(& c->extended);
#line 741
        if (tmp___1 > 0U) {
#line 743
          tmp = buffer_len(& c->extended);
#line 743
          tmp___0 = buffer_ptr(& c->extended);
#line 743
          len = write(c->efd, (void const   *)tmp___0, tmp);
#line 745
          debug2("channel %d: written %d to efd %d", c->self, len, c->efd);
#line 747
          if (len > 0) {
#line 748
            buffer_consume(& c->extended, (unsigned int )len);
#line 749
            c->local_consumed += len;
          }
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 752
      if (c->extended_usage == 1) {
#line 752
        __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))),
                             "m" (readset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "cc");
#line 752
        if (__result) {
#line 753
          len = read(c->efd, (void *)(buf___1), sizeof(buf___1));
#line 754
          debug2("channel %d: read %d from efd %d", c->self, len, c->efd);
#line 756
          if (len == 0) {
#line 757
            debug("channel %d: closing efd %d", c->self, c->efd);
#line 759
            close(c->efd);
#line 760
            c->efd = -1;
          } else {
#line 761
            if (len > 0) {
#line 762
              buffer_append(& c->extended, (char const   *)(buf___1), (unsigned int )len);
            }
          }
        }
      }
    }
  }
#line 765
  return (1);
}
}
#line 767 "channels.c"
int channel_check_window(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 770
  if (! (c->flags & 3)) {
#line 770
    if (c->local_window < c->local_window_max / 2) {
#line 770
      if (c->local_consumed > 0) {
#line 773
        packet_start(93);
#line 774
        packet_put_int((unsigned int )c->remote_id);
#line 775
        packet_put_int((unsigned int )c->local_consumed);
#line 776
        packet_send();
#line 777
        debug2("channel %d: window %d sent adjust %d", c->self, c->local_window, c->local_consumed);
#line 780
        c->local_window += c->local_consumed;
#line 781
        c->local_consumed = 0;
      }
    }
  }
#line 783
  return (1);
}
}
#line 786 "channels.c"
void channel_post_open_1(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 789
  channel_handle_rfd(c, readset, writeset);
#line 790
  channel_handle_wfd(c, readset, writeset);
#line 791
  return;
}
}
#line 793 "channels.c"
void channel_post_open_2(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 796
  channel_handle_rfd(c, readset, writeset);
#line 797
  channel_handle_wfd(c, readset, writeset);
#line 798
  channel_handle_efd(c, readset, writeset);
#line 799
  channel_check_window(c, readset, writeset);
#line 800
  return;
}
}
#line 802 "channels.c"
void channel_post_output_drain_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  register char __result ;
  unsigned int tmp___2 ;

  {
#line 807
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 807
  if (__result) {
#line 807
    tmp___2 = buffer_len(& c->output);
#line 807
    if (tmp___2 > 0U) {
#line 808
      tmp = buffer_len(& c->output);
#line 808
      tmp___0 = buffer_ptr(& c->output);
#line 808
      len = write(c->sock, (void const   *)tmp___0, tmp);
#line 810
      if (len <= 0) {
#line 811
        tmp___1 = buffer_len(& c->output);
#line 811
        buffer_consume(& c->output, tmp___1);
      } else {
#line 813
        buffer_consume(& c->output, (unsigned int )len);
      }
    }
  }
#line 815
  return;
}
}
#line 817 "channels.c"
void channel_handler_init_20(void) 
{ 

  {
#line 820
  channel_pre[4] = & channel_pre_open_20;
#line 821
  channel_pre[7] = & channel_pre_x11_open;
#line 822
  channel_pre[2] = & channel_pre_listener;
#line 823
  channel_pre[1] = & channel_pre_listener;
#line 825
  channel_post[4] = & channel_post_open_2;
#line 826
  channel_post[2] = & channel_post_port_listener;
#line 827
  channel_post[1] = & channel_post_x11_listener;
#line 828
  return;
}
}
#line 830 "channels.c"
void channel_handler_init_13(void) 
{ 

  {
#line 833
  channel_pre[4] = & channel_pre_open_13;
#line 834
  channel_pre[7] = & channel_pre_x11_open_13;
#line 835
  channel_pre[1] = & channel_pre_listener;
#line 836
  channel_pre[2] = & channel_pre_listener;
#line 837
  channel_pre[6] = & channel_pre_listener;
#line 838
  channel_pre[8] = & channel_pre_input_draining;
#line 839
  channel_pre[9] = & channel_pre_output_draining;
#line 841
  channel_post[4] = & channel_post_open_1;
#line 842
  channel_post[1] = & channel_post_x11_listener;
#line 843
  channel_post[2] = & channel_post_port_listener;
#line 844
  channel_post[6] = & channel_post_auth_listener;
#line 845
  channel_post[9] = & channel_post_output_drain_13;
#line 846
  return;
}
}
#line 848 "channels.c"
void channel_handler_init_15(void) 
{ 

  {
#line 851
  channel_pre[4] = & channel_pre_open_15;
#line 852
  channel_pre[7] = & channel_pre_x11_open;
#line 853
  channel_pre[1] = & channel_pre_listener;
#line 854
  channel_pre[2] = & channel_pre_listener;
#line 855
  channel_pre[6] = & channel_pre_listener;
#line 857
  channel_post[1] = & channel_post_x11_listener;
#line 858
  channel_post[2] = & channel_post_port_listener;
#line 859
  channel_post[6] = & channel_post_auth_listener;
#line 860
  channel_post[4] = & channel_post_open_1;
#line 861
  return;
}
}
#line 863 "channels.c"
void channel_handler_init(void) 
{ int i ;

  {
#line 867
  i = 0;
#line 867
  while (i < 11) {
#line 868
    channel_pre[i] = (chan_fn *)((void *)0);
#line 869
    channel_post[i] = (chan_fn *)((void *)0);
#line 867
    i ++;
  }
#line 871
  if (compat20) {
#line 872
    channel_handler_init_20();
  } else {
#line 873
    if (compat13) {
#line 874
      channel_handler_init_13();
    } else {
#line 876
      channel_handler_init_15();
    }
  }
#line 877
  return;
}
}
#line 882
void channel_handler(chan_fn **ftab , fd_set *readset , fd_set *writeset ) ;
#line 882 "channels.c"
static int did_init  =    0;
#line 879 "channels.c"
void channel_handler(chan_fn **ftab , fd_set *readset , fd_set *writeset ) 
{ int i ;
  Channel *c ;

  {
#line 886
  if (! did_init) {
#line 887
    channel_handler_init();
#line 888
    did_init = 1;
  }
#line 890
  i = 0;
#line 890
  while (i < channels_alloc) {
#line 891
    c = channels + i;
#line 892
    if (c->type == 0) {
      goto __Cont;
    }
#line 894
    if ((unsigned int )*(ftab + c->type) == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 896
    (*(*(ftab + c->type)))(c, readset, writeset);
#line 897
    (*chan_delete_if_full_closed)(c);
    __Cont: /* CIL Label */ 
#line 890
    i ++;
  }
#line 899
  return;
}
}
#line 901 "channels.c"
void channel_prepare_select(fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 904
  channel_handler(channel_pre, readset, writeset);
#line 905
  return;
}
}
#line 907 "channels.c"
void channel_after_select(fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 910
  channel_handler(channel_post, readset, writeset);
#line 911
  return;
}
}
#line 915 "channels.c"
void channel_output_poll(void) 
{ int len ;
  int i ;
  Channel *c ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;

  {
#line 921
  i = 0;
#line 921
  while (i < channels_alloc) {
#line 922
    c = channels + i;
#line 925
    if (compat13) {
#line 926
      if (c->type != 4) {
#line 926
        if (c->type != 8) {
          goto __Cont;
        }
      }
    } else {
#line 930
      if (c->type != 4) {
        goto __Cont;
      }
#line 932
      if (c->istate != 1) {
#line 932
        if (c->istate != 2) {
          goto __Cont;
        }
      }
    }
#line 936
    if (compat20) {
#line 936
      if (c->flags & 3) {
#line 938
        debug("channel: %d: no data after CLOSE", c->self);
        goto __Cont;
      }
    }
#line 943
    tmp = buffer_len(& c->input);
#line 943
    len = (int )tmp;
#line 944
    if (len > 0) {
#line 946
      if (compat20) {
#line 947
        if (len > c->remote_window) {
#line 948
          len = c->remote_window;
        }
#line 949
        if (len > c->remote_maxpacket) {
#line 950
          len = c->remote_maxpacket;
        }
      } else {
#line 952
        tmp___0 = packet_is_interactive();
#line 952
        if (tmp___0) {
#line 953
          if (len > 1024) {
#line 954
            len = 512;
          }
        } else {
#line 957
          if (len > max_packet_size / 2) {
#line 958
            len = max_packet_size / 2;
          }
        }
      }
#line 961
      if (len > 0) {
#line 962
        if (compat20) {
#line 962
          tmp___1 = 94;
        } else {
#line 962
          tmp___1 = 23;
        }
#line 962
        packet_start(tmp___1);
#line 964
        packet_put_int((unsigned int )c->remote_id);
#line 965
        tmp___2 = buffer_ptr(& c->input);
#line 965
        packet_put_string((char const   *)tmp___2, (unsigned int )len);
#line 966
        packet_send();
#line 967
        buffer_consume(& c->input, (unsigned int )len);
#line 968
        c->remote_window -= len;
      }
    } else {
#line 970
      if (c->istate == 2) {
#line 971
        if (compat13) {
#line 972
          fatal("cannot happen: istate == INPUT_WAIT_DRAIN for proto 1.3");
        }
#line 977
        (*chan_ibuf_empty)(c);
      }
    }
#line 980
    if (compat20) {
#line 980
      if (c->remote_window > 0) {
#line 980
        tmp___4 = buffer_len(& c->extended);
#line 980
        len = (int )tmp___4;
#line 980
        if (len > 0) {
#line 980
          if (c->extended_usage == 1) {
#line 984
            if (len > c->remote_window) {
#line 985
              len = c->remote_window;
            }
#line 986
            if (len > c->remote_maxpacket) {
#line 987
              len = c->remote_maxpacket;
            }
#line 988
            packet_start(95);
#line 989
            packet_put_int((unsigned int )c->remote_id);
#line 990
            packet_put_int(1U);
#line 991
            tmp___3 = buffer_ptr(& c->extended);
#line 991
            packet_put_string((char const   *)tmp___3, (unsigned int )len);
#line 992
            packet_send();
#line 993
            buffer_consume(& c->extended, (unsigned int )len);
#line 994
            c->remote_window -= len;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 921
    i ++;
  }
#line 997
  return;
}
}
#line 1005 "channels.c"
void channel_input_data(int type , int plen , void *ctxt ) 
{ int id ;
  char *data ;
  unsigned int data_len ;
  Channel *c ;
  unsigned int tmp ;
  int _len ;
  int tmp___0 ;
  int _p ;
  int _e ;

  {
#line 1014
  tmp = packet_get_int();
#line 1014
  id = (int )tmp;
#line 1015
  c = channel_lookup(id);
#line 1016
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1017
    packet_disconnect("Received data for nonexistent channel %d.", id);
  }
#line 1020
  if (c->type != 4) {
#line 1020
    if (c->type != 7) {
#line 1022
      return;
    }
  }
#line 1025
  if (! compat13) {
#line 1025
    if (c->ostate != 16) {
#line 1026
      return;
    }
  }
#line 1029
  data = packet_get_string(& data_len);
#line 1030
  while (1) {
#line 1030
    tmp___0 = packet_remaining();
#line 1030
    _len = tmp___0;
#line 1030
    if (_len > 0) {
#line 1030
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1030);
#line 1030
      packet_disconnect("Packet integrity error.");
    }
#line 1030
    break;
  }
#line 1032
  if (compat20) {
#line 1033
    if (data_len > (unsigned int )c->local_maxpacket) {
#line 1034
      log("channel %d: rcvd big packet %d, maxpack %d", c->self, data_len, c->local_maxpacket);
    }
#line 1037
    if (data_len > (unsigned int )c->local_window) {
#line 1038
      log("channel %d: rcvd too much data %d, win %d", c->self, data_len, c->local_window);
#line 1040
      xfree((void *)data);
#line 1041
      return;
    }
#line 1043
    c->local_window = (int )((unsigned int )c->local_window - data_len);
  } else {
#line 1045
    while (1) {
#line 1045
      _p = plen;
#line 1045
      _e = (int )(8U + data_len);
#line 1045
      if (_p != _e) {
#line 1045
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1045);
#line 1045
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1045
      break;
    }
  }
#line 1047
  buffer_append(& c->output, (char const   *)data, data_len);
#line 1048
  xfree((void *)data);
#line 1049
  return;
}
}
#line 1050 "channels.c"
void channel_input_extended_data(int type , int plen , void *ctxt ) 
{ int id ;
  int tcode ;
  char *data ;
  unsigned int data_len ;
  Channel *c ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1060
  tmp = packet_get_int();
#line 1060
  id = (int )tmp;
#line 1061
  c = channel_lookup(id);
#line 1063
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1064
    packet_disconnect("Received extended_data for bad channel %d.", id);
  }
#line 1065
  if (c->type != 4) {
#line 1066
    log("channel %d: ext data for non open", id);
#line 1067
    return;
  }
#line 1069
  tmp___0 = packet_get_int();
#line 1069
  tcode = (int )tmp___0;
#line 1070
  if (c->efd == -1) {
#line 1073
    log("channel %d: bad ext data", c->self);
#line 1074
    return;
  } else {
#line 1070
    if (c->extended_usage != 2) {
#line 1073
      log("channel %d: bad ext data", c->self);
#line 1074
      return;
    } else {
#line 1070
      if (tcode != 1) {
#line 1073
        log("channel %d: bad ext data", c->self);
#line 1074
        return;
      }
    }
  }
#line 1076
  data = packet_get_string(& data_len);
#line 1077
  while (1) {
#line 1077
    tmp___1 = packet_remaining();
#line 1077
    _len = tmp___1;
#line 1077
    if (_len > 0) {
#line 1077
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1077);
#line 1077
      packet_disconnect("Packet integrity error.");
    }
#line 1077
    break;
  }
#line 1078
  if (data_len > (unsigned int )c->local_window) {
#line 1079
    log("channel %d: rcvd too much extended_data %d, win %d", c->self, data_len, c->local_window);
#line 1081
    xfree((void *)data);
#line 1082
    return;
  }
#line 1084
  debug2("channel %d: rcvd ext data %d", c->self, data_len);
#line 1085
  c->local_window = (int )((unsigned int )c->local_window - data_len);
#line 1086
  buffer_append(& c->extended, (char const   *)data, data_len);
#line 1087
  xfree((void *)data);
#line 1088
  return;
}
}
#line 1096 "channels.c"
int channel_not_very_much_buffered_data(void) 
{ unsigned int i ;
  Channel *c ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 1102
  i = 0U;
#line 1102
  while (i < (unsigned int )channels_alloc) {
#line 1103
    c = channels + i;
#line 1104
    if (c->type == 4) {
#line 1105
      if (! compat20) {
#line 1105
        tmp___0 = buffer_len(& c->input);
#line 1105
        if (tmp___0 > (unsigned int )max_packet_size) {
#line 1106
          tmp = buffer_len(& c->input);
#line 1106
          debug("channel %d: big input buffer %d", c->self, tmp);
#line 1108
          return (0);
        }
      }
#line 1110
      tmp___2 = buffer_len(& c->output);
#line 1110
      if (tmp___2 > (unsigned int )max_packet_size) {
#line 1111
        tmp___1 = buffer_len(& c->output);
#line 1111
        debug("channel %d: big output buffer %d", c->self, tmp___1);
#line 1113
        return (0);
      }
    }
#line 1102
    i ++;
  }
#line 1117
  return (1);
}
}
#line 1120 "channels.c"
void channel_input_ieof(int type , int plen , void *ctxt ) 
{ int id ;
  Channel *c ;
  int _p ;
  int _e ;
  unsigned int tmp ;

  {
#line 1126
  while (1) {
#line 1126
    _p = plen;
#line 1126
    _e = 4;
#line 1126
    if (_p != _e) {
#line 1126
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1126);
#line 1126
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 1126
    break;
  }
#line 1128
  tmp = packet_get_int();
#line 1128
  id = (int )tmp;
#line 1129
  c = channel_lookup(id);
#line 1130
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1131
    packet_disconnect("Received ieof for nonexistent channel %d.", id);
  }
#line 1132
  (*chan_rcvd_ieof)(c);
#line 1133
  return;
}
}
#line 1135 "channels.c"
void channel_input_close(int type , int plen , void *ctxt ) 
{ int id ;
  Channel *c ;
  int _p ;
  int _e ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 1141
  while (1) {
#line 1141
    _p = plen;
#line 1141
    _e = 4;
#line 1141
    if (_p != _e) {
#line 1141
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1141);
#line 1141
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 1141
    break;
  }
#line 1143
  tmp = packet_get_int();
#line 1143
  id = (int )tmp;
#line 1144
  c = channel_lookup(id);
#line 1145
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1146
    packet_disconnect("Received close for nonexistent channel %d.", id);
  }
#line 1152
  packet_start(25);
#line 1153
  packet_put_int((unsigned int )c->remote_id);
#line 1154
  packet_send();
#line 1163
  if (c->type != 5) {
#line 1168
    tmp___0 = buffer_len(& c->input);
#line 1168
    buffer_consume(& c->input, tmp___0);
#line 1169
    c->type = 9;
  }
#line 1171
  return;
}
}
#line 1174 "channels.c"
void channel_input_oclose(int type , int plen , void *ctxt ) 
{ int id ;
  unsigned int tmp ;
  Channel *c ;
  Channel *tmp___0 ;
  int _p ;
  int _e ;

  {
#line 1177
  tmp = packet_get_int();
#line 1177
  id = (int )tmp;
#line 1178
  tmp___0 = channel_lookup(id);
#line 1178
  c = tmp___0;
#line 1179
  while (1) {
#line 1179
    _p = plen;
#line 1179
    _e = 4;
#line 1179
    if (_p != _e) {
#line 1179
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1179);
#line 1179
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 1179
    break;
  }
#line 1180
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1181
    packet_disconnect("Received oclose for nonexistent channel %d.", id);
  }
#line 1182
  (*chan_rcvd_oclose)(c);
#line 1183
  return;
}
}
#line 1185 "channels.c"
void channel_input_close_confirmation(int type , int plen , void *ctxt ) 
{ int id ;
  unsigned int tmp ;
  Channel *c ;
  Channel *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1188
  tmp = packet_get_int();
#line 1188
  id = (int )tmp;
#line 1189
  tmp___0 = channel_lookup(id);
#line 1189
  c = tmp___0;
#line 1191
  while (1) {
#line 1191
    tmp___1 = packet_remaining();
#line 1191
    _len = tmp___1;
#line 1191
    if (_len > 0) {
#line 1191
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1191);
#line 1191
      packet_disconnect("Packet integrity error.");
    }
#line 1191
    break;
  }
#line 1192
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1193
    packet_disconnect("Received close confirmation for out-of-range channel %d.",
                      id);
  }
#line 1195
  if (c->type != 5) {
#line 1196
    packet_disconnect("Received close confirmation for non-closed channel %d (type %d).",
                      id, c->type);
  }
#line 1198
  channel_free(c->self);
#line 1199
  return;
}
}
#line 1201 "channels.c"
void channel_input_open_confirmation(int type , int plen , void *ctxt ) 
{ int id ;
  int remote_id ;
  Channel *c ;
  int _p ;
  int _e ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 1207
  if (! compat20) {
#line 1208
    while (1) {
#line 1208
      _p = plen;
#line 1208
      _e = 8;
#line 1208
      if (_p != _e) {
#line 1208
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1208);
#line 1208
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1208
      break;
    }
  }
#line 1210
  tmp = packet_get_int();
#line 1210
  id = (int )tmp;
#line 1211
  c = channel_lookup(id);
#line 1213
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1214
    packet_disconnect("Received open confirmation for non-opening channel %d.", id);
  } else {
#line 1213
    if (c->type != 3) {
#line 1214
      packet_disconnect("Received open confirmation for non-opening channel %d.",
                        id);
    }
  }
#line 1216
  tmp___0 = packet_get_int();
#line 1216
  remote_id = (int )tmp___0;
#line 1218
  c->remote_id = remote_id;
#line 1219
  c->type = 4;
#line 1221
  if (compat20) {
#line 1222
    tmp___1 = packet_get_int();
#line 1222
    c->remote_window = (int )tmp___1;
#line 1223
    tmp___2 = packet_get_int();
#line 1223
    c->remote_maxpacket = (int )tmp___2;
#line 1224
    while (1) {
#line 1224
      tmp___3 = packet_remaining();
#line 1224
      _len = tmp___3;
#line 1224
      if (_len > 0) {
#line 1224
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            1224);
#line 1224
        packet_disconnect("Packet integrity error.");
      }
#line 1224
      break;
    }
#line 1225
    if ((unsigned int )c->cb_fn != (unsigned int )((void *)0)) {
#line 1225
      if (c->cb_event == type) {
#line 1226
        debug2("callback start");
#line 1227
        (*(c->cb_fn))(c->self, c->cb_arg);
#line 1228
        debug2("callback done");
      }
    }
#line 1230
    debug("channel %d: open confirm rwindow %d rmax %d", c->self, c->remote_window,
          c->remote_maxpacket);
  }
#line 1233
  return;
}
}
#line 1235 "channels.c"
void channel_input_open_failure(int type , int plen , void *ctxt ) 
{ int id ;
  Channel *c ;
  int _p ;
  int _e ;
  unsigned int tmp ;
  int reason ;
  unsigned int tmp___0 ;
  char *msg ;
  char *tmp___1 ;
  char *lang ;
  char *tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 1241
  if (! compat20) {
#line 1242
    while (1) {
#line 1242
      _p = plen;
#line 1242
      _e = 4;
#line 1242
      if (_p != _e) {
#line 1242
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1242);
#line 1242
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1242
      break;
    }
  }
#line 1244
  tmp = packet_get_int();
#line 1244
  id = (int )tmp;
#line 1245
  c = channel_lookup(id);
#line 1247
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1248
    packet_disconnect("Received open failure for non-opening channel %d.", id);
  } else {
#line 1247
    if (c->type != 3) {
#line 1248
      packet_disconnect("Received open failure for non-opening channel %d.", id);
    }
  }
#line 1250
  if (compat20) {
#line 1251
    tmp___0 = packet_get_int();
#line 1251
    reason = (int )tmp___0;
#line 1252
    tmp___1 = packet_get_string((unsigned int *)((void *)0));
#line 1252
    msg = tmp___1;
#line 1253
    tmp___2 = packet_get_string((unsigned int *)((void *)0));
#line 1253
    lang = tmp___2;
#line 1254
    log("channel_open_failure: %d: reason %d: %s", id, reason, msg);
#line 1255
    while (1) {
#line 1255
      tmp___3 = packet_remaining();
#line 1255
      _len = tmp___3;
#line 1255
      if (_len > 0) {
#line 1255
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            1255);
#line 1255
        packet_disconnect("Packet integrity error.");
      }
#line 1255
      break;
    }
#line 1256
    xfree((void *)msg);
#line 1257
    xfree((void *)lang);
  }
#line 1260
  channel_free(id);
#line 1261
  return;
}
}
#line 1263 "channels.c"
void channel_input_channel_request(int type , int plen , void *ctxt ) 
{ int id ;
  Channel *c ;
  unsigned int tmp ;
  char *service ;
  char *tmp___0 ;

  {
#line 1269
  tmp = packet_get_int();
#line 1269
  id = (int )tmp;
#line 1270
  c = channel_lookup(id);
#line 1272
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1274
    packet_disconnect("Received request for non-open channel %d.", id);
  } else {
#line 1272
    if (c->type != 4) {
#line 1272
      if (c->type != 10) {
#line 1274
        packet_disconnect("Received request for non-open channel %d.", id);
      }
    }
  }
#line 1276
  if ((unsigned int )c->cb_fn != (unsigned int )((void *)0)) {
#line 1276
    if (c->cb_event == type) {
#line 1277
      debug2("callback start");
#line 1278
      (*(c->cb_fn))(c->self, c->cb_arg);
#line 1279
      debug2("callback done");
    } else {
#line 1281
      tmp___0 = packet_get_string((unsigned int *)((void *)0));
#line 1281
      service = tmp___0;
#line 1282
      debug("channel: %d rcvd request for %s", c->self, service);
#line 1283
      debug("cb_fn %p cb_event %d", c->cb_fn, c->cb_event);
#line 1284
      xfree((void *)service);
    }
  } else {
#line 1281
    tmp___0 = packet_get_string((unsigned int *)((void *)0));
#line 1281
    service = tmp___0;
#line 1282
    debug("channel: %d rcvd request for %s", c->self, service);
#line 1283
    debug("cb_fn %p cb_event %d", c->cb_fn, c->cb_event);
#line 1284
    xfree((void *)service);
  }
#line 1286
  return;
}
}
#line 1288 "channels.c"
void channel_input_window_adjust(int type , int plen , void *ctxt ) 
{ Channel *c ;
  int id ;
  int adjust ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1294
  if (! compat20) {
#line 1295
    return;
  }
#line 1298
  tmp = packet_get_int();
#line 1298
  id = (int )tmp;
#line 1299
  c = channel_lookup(id);
#line 1301
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1302
    log("Received window adjust for non-open channel %d.", id);
#line 1304
    return;
  } else {
#line 1301
    if (c->type != 4) {
#line 1302
      log("Received window adjust for non-open channel %d.", id);
#line 1304
      return;
    }
  }
#line 1306
  tmp___0 = packet_get_int();
#line 1306
  adjust = (int )tmp___0;
#line 1307
  while (1) {
#line 1307
    tmp___1 = packet_remaining();
#line 1307
    _len = tmp___1;
#line 1307
    if (_len > 0) {
#line 1307
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1307);
#line 1307
      packet_disconnect("Packet integrity error.");
    }
#line 1307
    break;
  }
#line 1308
  debug2("channel %d: rcvd adjust %d", id, adjust);
#line 1309
  c->remote_window += adjust;
#line 1310
  return;
}
}
#line 1317 "channels.c"
void channel_stop_listening(void) 
{ int i ;

  {
#line 1321
  i = 0;
#line 1321
  while (i < channels_alloc) {
#line 1322
    switch ((channels + i)->type) {
    case 6: 
#line 1324
    close((channels + i)->sock);
#line 1325
    unlink((char const   *)((channels + i)->path));
#line 1326
    channel_free(i);
#line 1327
    break;
    case 2: 
    case 1: 
#line 1330
    close((channels + i)->sock);
#line 1331
    channel_free(i);
#line 1332
    break;
    default: ;
#line 1334
    break;
    }
#line 1321
    i ++;
  }
#line 1337
  return;
}
}
#line 1344 "channels.c"
void channel_close_all(void) 
{ int i ;

  {
#line 1348
  i = 0;
#line 1348
  while (i < channels_alloc) {
#line 1349
    if ((channels + i)->type != 0) {
#line 1350
      channel_close_fds(channels + i);
    }
#line 1348
    i ++;
  }
#line 1351
  return;
}
}
#line 1355 "channels.c"
int channel_max_fd(void) 
{ 

  {
#line 1358
  return (channel_max_fd_value);
}
}
#line 1363 "channels.c"
int channel_still_open(void) 
{ unsigned int i ;

  {
#line 1367
  i = 0U;
#line 1367
  while (i < (unsigned int )channels_alloc) {
#line 1368
    switch ((channels + i)->type) {
    case 0: 
    case 1: 
    case 2: 
    case 5: 
    case 6: 
    goto __Cont;
    case 10: 
#line 1376
    if (! compat20) {
#line 1377
      fatal("cannot happen: SSH_CHANNEL_LARVAL");
    }
    goto __Cont;
    case 3: 
    case 4: 
    case 7: 
#line 1382
    return (1);
    case 8: 
    case 9: 
#line 1385
    if (! compat13) {
#line 1386
      fatal("cannot happen: OUT_DRAIN");
    }
#line 1387
    return (1);
    default: 
#line 1389
    fatal("channel_still_open: bad channel type %d", (channels + i)->type);
    }
    __Cont: /* CIL Label */ 
#line 1367
    i ++;
  }
#line 1392
  return (0);
}
}
#line 1401 "channels.c"
char *channel_open_message(void) 
{ Buffer buffer ;
  int i ;
  char buf___1[512] ;
  char *cp ;
  size_t tmp ;
  Channel *c ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;

  {
#line 1408
  buffer_init(& buffer);
#line 1409
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"The following connections are open:\r\n");
#line 1410
  tmp = strlen((char const   *)(buf___1));
#line 1410
  buffer_append(& buffer, (char const   *)(buf___1), tmp);
#line 1411
  i = 0;
#line 1411
  while (i < channels_alloc) {
#line 1412
    c = channels + i;
#line 1413
    switch (c->type) {
    case 0: 
    case 1: 
    case 2: 
    case 5: 
    case 6: 
    goto __Cont;
    case 10: 
    case 3: 
    case 4: 
    case 7: 
    case 8: 
    case 9: 
#line 1426
    tmp___0 = buffer_len(& c->output);
#line 1426
    tmp___1 = buffer_len(& c->input);
#line 1426
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"  #%d %.300s (t%d r%d i%d/%d o%d/%d fd %d/%d)\r\n",
             c->self, c->remote_name, c->type, c->remote_id, c->istate, tmp___1, c->ostate,
             tmp___0, c->rfd, c->wfd);
#line 1432
    tmp___2 = strlen((char const   *)(buf___1));
#line 1432
    buffer_append(& buffer, (char const   *)(buf___1), tmp___2);
    goto __Cont;
    default: 
#line 1435
    fatal("channel_open_message: bad channel type %d", c->type);
    }
    __Cont: /* CIL Label */ 
#line 1411
    i ++;
  }
#line 1439
  buffer_append(& buffer, "\000", 1U);
#line 1440
  tmp___3 = buffer_ptr(& buffer);
#line 1440
  cp = xstrdup((char const   *)tmp___3);
#line 1441
  buffer_free(& buffer);
#line 1442
  return (cp);
}
}
#line 1450 "channels.c"
void channel_request_local_forwarding(u_short port , char const   *host , u_short host_port ,
                                      int gateway_ports ) 
{ int success ;
  int ch ;
  int sock ;
  int on ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char ntop[1025] ;
  char strport[32] ;
  struct linger linger ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;

  {
#line 1454
  on = 1;
#line 1459
  tmp = strlen(host);
#line 1459
  if (tmp > sizeof((channels + 0)->path) - 1U) {
#line 1460
    packet_disconnect("Forward host name too long.");
  }
#line 1466
  memset((void *)(& hints), 0, sizeof(hints));
#line 1467
  hints.ai_family = IPv4or6;
#line 1468
  if (gateway_ports) {
#line 1468
    hints.ai_flags = 1;
  } else {
#line 1468
    hints.ai_flags = 0;
  }
#line 1469
  hints.ai_socktype = 1;
#line 1470
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           port);
#line 1471
  tmp___0 = getaddrinfo((char const   * __restrict  )((void *)0), (char const   * __restrict  )(strport),
                        (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 1471
  if (tmp___0 != 0) {
#line 1472
    packet_disconnect("getaddrinfo: fatal error");
  }
#line 1474
  success = 0;
#line 1475
  ai = aitop;
#line 1475
  while (ai) {
#line 1476
    if (ai->ai_family != 2) {
#line 1476
      if (ai->ai_family != 10) {
        goto __Cont;
      }
    }
#line 1478
    tmp___1 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                          (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )(strport),
                          sizeof(strport), 3U);
#line 1478
    if (tmp___1 != 0) {
#line 1480
      error("channel_request_local_forwarding: getnameinfo failed");
      goto __Cont;
    }
#line 1484
    sock = socket(ai->ai_family, 1, 0);
#line 1485
    if (sock < 0) {
#line 1487
      tmp___2 = __errno_location();
#line 1487
      tmp___3 = strerror(*tmp___2);
#line 1487
      verbose("socket: %.100s", tmp___3);
      goto __Cont;
    }
#line 1494
    setsockopt(sock, 1, 2, (void const   *)((void *)(& on)), sizeof(on));
#line 1495
    linger.l_onoff = 1;
#line 1496
    linger.l_linger = 5;
#line 1497
    setsockopt(sock, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 1498
    debug("Local forwarding listening on %s port %s.", ntop, strport);
#line 1501
    tmp___8 = bind(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 1501
    if (tmp___8 < 0) {
#line 1503
      if (! ai->ai_next) {
#line 1504
        tmp___4 = __errno_location();
#line 1504
        tmp___5 = strerror(*tmp___4);
#line 1504
        error("bind: %.100s", tmp___5);
      } else {
#line 1506
        tmp___6 = __errno_location();
#line 1506
        tmp___7 = strerror(*tmp___6);
#line 1506
        verbose("bind: %.100s", tmp___7);
      }
#line 1508
      close(sock);
      goto __Cont;
    }
#line 1512
    tmp___11 = listen(sock, 5);
#line 1512
    if (tmp___11 < 0) {
#line 1513
      tmp___9 = __errno_location();
#line 1513
      tmp___10 = strerror(*tmp___9);
#line 1513
      error("listen: %.100s", tmp___10);
#line 1514
      close(sock);
      goto __Cont;
    }
#line 1518
    tmp___12 = xstrdup("port listener");
#line 1518
    ch = channel_new((char *)"port listener", 2, sock, sock, -1, 32768, 16384, 0,
                     tmp___12, 1);
#line 1523
    strlcpy((channels + ch)->path, host, sizeof((channels + ch)->path));
#line 1524
    (channels + ch)->host_port = (int )host_port;
#line 1525
    (channels + ch)->listening_port = (int )port;
#line 1526
    success = 1;
    __Cont: /* CIL Label */ 
#line 1475
    ai = ai->ai_next;
  }
#line 1528
  if (success == 0) {
#line 1529
    packet_disconnect("cannot listen port: %d", port);
  }
#line 1530
  freeaddrinfo(aitop);
#line 1531
  return;
}
}
#line 1538 "channels.c"
void channel_request_remote_forwarding(u_short listen_port , char const   *host_to_connect ,
                                       u_short port_to_connect ) 
{ int payload_len ;
  char const   *address_to_bind ;

  {
#line 1544
  if (num_permitted_opens >= 100) {
#line 1545
    fatal("channel_request_remote_forwarding: too many forwards");
  }
#line 1547
  permitted_opens[num_permitted_opens].host_to_connect = xstrdup(host_to_connect);
#line 1548
  permitted_opens[num_permitted_opens].port_to_connect = port_to_connect;
#line 1549
  permitted_opens[num_permitted_opens].listen_port = listen_port;
#line 1550
  num_permitted_opens ++;
#line 1553
  if (compat20) {
#line 1554
    address_to_bind = "0.0.0.0";
#line 1555
    packet_start(80);
#line 1556
    packet_put_cstring("tcpip-forward");
#line 1557
    packet_put_char(0);
#line 1558
    packet_put_cstring(address_to_bind);
#line 1559
    packet_put_int((unsigned int )listen_port);
  } else {
#line 1561
    packet_start(28);
#line 1562
    packet_put_int((unsigned int )listen_port);
#line 1563
    packet_put_cstring(host_to_connect);
#line 1564
    packet_put_int((unsigned int )port_to_connect);
#line 1565
    packet_send();
#line 1566
    packet_write_wait();
#line 1571
    packet_read_expect(& payload_len, 14);
  }
#line 1573
  return;
}
}
#line 1581 "channels.c"
void channel_input_port_forward_request(int is_root , int gateway_ports ) 
{ u_short port ;
  u_short host_port ;
  char *hostname ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 1588
  tmp = packet_get_int();
#line 1588
  port = (unsigned short )tmp;
#line 1589
  hostname = packet_get_string((unsigned int *)((void *)0));
#line 1590
  tmp___0 = packet_get_int();
#line 1590
  host_port = (unsigned short )tmp___0;
#line 1597
  if ((int )port < 1024) {
#line 1597
    if (! is_root) {
#line 1598
      packet_disconnect("Requested forwarding of port %d but user is not root.", port);
    }
  }
#line 1604
  channel_request_local_forwarding(port, (char const   *)hostname, host_port, gateway_ports);
#line 1607
  xfree((void *)hostname);
#line 1608
  return;
}
}
#line 1611 "channels.c"
int channel_connect_to(char const   *host , u_short host_port ) 
{ struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char ntop[1025] ;
  char strport[32] ;
  int gaierr ;
  int sock ;
  char const   *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 1617
  sock = -1;
#line 1619
  memset((void *)(& hints), 0, sizeof(hints));
#line 1620
  hints.ai_family = IPv4or6;
#line 1621
  hints.ai_socktype = 1;
#line 1622
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           host_port);
#line 1623
  gaierr = getaddrinfo((char const   * __restrict  )host, (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 1623
  if (gaierr != 0) {
#line 1624
    tmp = gai_strerror(gaierr);
#line 1624
    error("%.100s: unknown host (%s)", host, tmp);
#line 1625
    return (-1);
  }
#line 1627
  ai = aitop;
#line 1627
  while (ai) {
#line 1628
    if (ai->ai_family != 2) {
#line 1628
      if (ai->ai_family != 10) {
        goto __Cont;
      }
    }
#line 1630
    tmp___0 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                          (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )(strport),
                          sizeof(strport), 3U);
#line 1630
    if (tmp___0 != 0) {
#line 1632
      error("channel_connect_to: getnameinfo failed");
      goto __Cont;
    }
#line 1636
    sock = socket(ai->ai_family, 1, 0);
#line 1637
    if (sock < 0) {
#line 1638
      tmp___1 = __errno_location();
#line 1638
      tmp___2 = strerror(*tmp___1);
#line 1638
      error("socket: %.100s", tmp___2);
      goto __Cont;
    }
#line 1642
    tmp___5 = connect(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 1642
    if (tmp___5 < 0) {
#line 1643
      tmp___3 = __errno_location();
#line 1643
      tmp___4 = strerror(*tmp___3);
#line 1643
      error("connect %.100s port %s: %.100s", ntop, strport, tmp___4);
#line 1645
      close(sock);
      goto __Cont;
    }
#line 1648
    break;
    __Cont: /* CIL Label */ 
#line 1627
    ai = ai->ai_next;
  }
#line 1651
  freeaddrinfo(aitop);
#line 1652
  if (! ai) {
#line 1653
    error("connect %.100s port %d: failed.", host, host_port);
#line 1654
    return (-1);
  }
#line 1657
  return (sock);
}
}
#line 1666 "channels.c"
void channel_input_port_open(int type , int plen , void *ctxt ) 
{ u_short host_port ;
  char *host ;
  char *originator_string ;
  int remote_channel ;
  int sock ;
  int newch ;
  int i ;
  int denied ;
  unsigned int host_len ;
  unsigned int originator_len ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int _p ;
  int _e ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 1671
  sock = -1;
#line 1675
  tmp = packet_get_int();
#line 1675
  remote_channel = (int )tmp;
#line 1678
  host = packet_get_string(& host_len);
#line 1681
  tmp___0 = packet_get_int();
#line 1681
  host_port = (unsigned short )tmp___0;
#line 1684
  if (have_hostname_in_open) {
#line 1685
    originator_string = packet_get_string(& originator_len);
#line 1686
    originator_len += 4U;
  } else {
#line 1688
    originator_string = xstrdup("unknown (remote did not supply name)");
#line 1689
    originator_len = 0U;
  }
#line 1692
  while (1) {
#line 1692
    _p = plen;
#line 1692
    _e = (int )(((8U + host_len) + 4U) + originator_len);
#line 1692
    if (_p != _e) {
#line 1692
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1693);
#line 1692
      packet_disconnect("Packet integrity error. (%d)", 29);
    }
#line 1692
    break;
  }
#line 1696
  denied = 0;
#line 1697
  if (! all_opens_permitted) {
#line 1699
    i = 0;
#line 1699
    while (i < num_permitted_opens) {
#line 1701
      if ((int )permitted_opens[i].port_to_connect == (int )host_port) {
#line 1701
        if (0) {
#line 1701
          __s1_len = strlen((char const   *)permitted_opens[i].host_to_connect);
#line 1701
          __s2_len = strlen((char const   *)host);
#line 1701
          if (! ((unsigned int )((void const   *)(permitted_opens[i].host_to_connect + 1)) - (unsigned int )((void const   *)permitted_opens[i].host_to_connect) == 1U)) {
            goto _L___0;
          } else {
#line 1701
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 1701
              if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
#line 1701
                tmp___10 = 1;
              } else {
#line 1701
                if (__s2_len >= 4U) {
#line 1701
                  tmp___10 = 1;
                } else {
#line 1701
                  tmp___10 = 0;
                }
              }
            } else {
#line 1701
              tmp___10 = 0;
            }
          }
#line 1701
          if (tmp___10) {
#line 1701
            tmp___6 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                       (char const   *)host);
          } else {
#line 1701
            tmp___9 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                       (char const   *)host);
#line 1701
            tmp___6 = tmp___9;
          }
        } else {
#line 1701
          tmp___9 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                     (char const   *)host);
#line 1701
          tmp___6 = tmp___9;
        }
#line 1701
        if (tmp___6 == 0) {
#line 1702
          break;
        }
      }
#line 1699
      i ++;
    }
#line 1705
    if (i >= num_permitted_opens) {
#line 1707
      log("Received request to connect to %.100s:%d, but the request was denied.",
          host, host_port);
#line 1709
      denied = 1;
    }
  }
#line 1712
  if (denied) {
#line 1712
    sock = -1;
  } else {
#line 1712
    sock = channel_connect_to((char const   *)host, host_port);
  }
#line 1713
  if (sock > 0) {
#line 1715
    newch = channel_allocate(4, sock, originator_string);
#line 1716
    (channels + newch)->remote_id = remote_channel;
#line 1718
    packet_start(21);
#line 1719
    packet_put_int((unsigned int )remote_channel);
#line 1720
    packet_put_int((unsigned int )newch);
#line 1721
    packet_send();
  } else {
#line 1723
    packet_start(22);
#line 1724
    packet_put_int((unsigned int )remote_channel);
#line 1725
    packet_send();
  }
#line 1727
  xfree((void *)host);
#line 1728
  return;
}
}
#line 1738 "channels.c"
char *x11_create_display_inet(int screen_number , int x11_display_offset ) 
{ int display_number ;
  int sock ;
  u_short port ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  int n___0 ;
  int num_socks ;
  int socks[10] ;
  char display[512] ;
  char hostname[64] ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;

  {
#line 1745
  num_socks = 0;
#line 1749
  display_number = x11_display_offset;
#line 1749
  while (display_number < 1000) {
#line 1752
    port = (unsigned short )(6000 + display_number);
#line 1753
    memset((void *)(& hints), 0, sizeof(hints));
#line 1754
    hints.ai_family = IPv4or6;
#line 1755
    hints.ai_flags = 1;
#line 1756
    hints.ai_socktype = 1;
#line 1757
    snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
             port);
#line 1758
    gaierr = getaddrinfo((char const   * __restrict  )((void *)0), (char const   * __restrict  )(strport),
                         (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 1758
    if (gaierr != 0) {
#line 1759
      tmp = gai_strerror(gaierr);
#line 1759
      error("getaddrinfo: %.100s", tmp);
#line 1760
      return ((char *)((void *)0));
    }
#line 1762
    ai = aitop;
#line 1762
    while (ai) {
#line 1763
      if (ai->ai_family != 2) {
#line 1763
        if (ai->ai_family != 10) {
          goto __Cont;
        }
      }
#line 1765
      sock = socket(ai->ai_family, 1, 0);
#line 1766
      if (sock < 0) {
#line 1767
        tmp___2 = __errno_location();
#line 1767
        if (*tmp___2 != 22) {
#line 1767
          tmp___3 = __errno_location();
#line 1767
          if (*tmp___3 != 97) {
#line 1768
            tmp___0 = __errno_location();
#line 1768
            tmp___1 = strerror(*tmp___0);
#line 1768
            error("socket: %.100s", tmp___1);
#line 1769
            return ((char *)((void *)0));
          } else {
#line 1771
            debug("x11_create_display_inet: Socket family %d not supported", ai->ai_family);
            goto __Cont;
          }
        } else {
#line 1771
          debug("x11_create_display_inet: Socket family %d not supported", ai->ai_family);
          goto __Cont;
        }
      }
#line 1776
      tmp___6 = bind(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 1776
      if (tmp___6 < 0) {
#line 1777
        tmp___4 = __errno_location();
#line 1777
        tmp___5 = strerror(*tmp___4);
#line 1777
        debug("bind port %d: %.100s", port, tmp___5);
#line 1778
        shutdown(sock, 2);
#line 1779
        close(sock);
#line 1781
        if (ai->ai_next) {
          goto __Cont;
        }
#line 1784
        n___0 = 0;
#line 1784
        while (n___0 < num_socks) {
#line 1785
          shutdown(socks[n___0], 2);
#line 1786
          close(socks[n___0]);
#line 1784
          n___0 ++;
        }
#line 1788
        num_socks = 0;
#line 1789
        break;
      }
#line 1791
      tmp___7 = num_socks;
#line 1791
      num_socks ++;
#line 1791
      socks[tmp___7] = sock;
#line 1796
      break;
      __Cont: /* CIL Label */ 
#line 1762
      ai = ai->ai_next;
    }
#line 1799
    if (num_socks > 0) {
#line 1800
      break;
    }
#line 1749
    display_number ++;
  }
#line 1802
  if (display_number >= 1000) {
#line 1803
    error("Failed to allocate internet-domain X11 display socket.");
#line 1804
    return ((char *)((void *)0));
  }
#line 1807
  n___0 = 0;
#line 1807
  while (n___0 < num_socks) {
#line 1808
    sock = socks[n___0];
#line 1809
    tmp___10 = listen(sock, 5);
#line 1809
    if (tmp___10 < 0) {
#line 1810
      tmp___8 = __errno_location();
#line 1810
      tmp___9 = strerror(*tmp___8);
#line 1810
      error("listen: %.100s", tmp___9);
#line 1811
      shutdown(sock, 2);
#line 1812
      close(sock);
#line 1813
      return ((char *)((void *)0));
    }
#line 1807
    n___0 ++;
  }
#line 1819
  tmp___13 = gethostname(hostname, sizeof(hostname));
#line 1819
  if (tmp___13 < 0) {
#line 1820
    tmp___11 = __errno_location();
#line 1820
    tmp___12 = strerror(*tmp___11);
#line 1820
    fatal("gethostname: %.100s", tmp___12);
  }
#line 1857
  snprintf((char * __restrict  )(display), sizeof(display), (char const   * __restrict  )"%.400s:%d.%d",
           hostname, display_number, screen_number);
#line 1862
  n___0 = 0;
#line 1862
  while (n___0 < num_socks) {
#line 1863
    sock = socks[n___0];
#line 1864
    tmp___14 = xstrdup("X11 inet listener");
#line 1864
    channel_new((char *)"x11 listener", 1, sock, sock, -1, 4096, 2048, 0, tmp___14,
                1);
#line 1862
    n___0 ++;
  }
#line 1871
  tmp___15 = xstrdup((char const   *)(display));
#line 1871
  return (tmp___15);
}
}
#line 1882
static int connect_local_xsocket(unsigned int dnr ) ;
#line 1882 "channels.c"
static char const   * const  x_sockets[4]  = {      (char const   * const  )"/tmp/.X11-unix/X%u",      (char const   * const  )"/var/X/.X11-unix/X%u",      (char const   * const  )"/usr/spool/sockets/X11/%u",      (char const   * const  )((void *)0)};
#line 1878 "channels.c"
static int connect_local_xsocket(unsigned int dnr ) 
{ int sock ;
  struct sockaddr_un addr ;
  char const   * const  *path ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 1892
  path = x_sockets;
#line 1892
  while (*path) {
#line 1893
    sock = socket(1, 1, 0);
#line 1894
    if (sock < 0) {
#line 1895
      tmp = __errno_location();
#line 1895
      tmp___0 = strerror(*tmp);
#line 1895
      error("socket: %.100s", tmp___0);
    }
#line 1896
    memset((void *)(& addr), 0, sizeof(addr));
#line 1897
    addr.sun_family = (unsigned short)1;
#line 1898
    snprintf((char * __restrict  )(addr.sun_path), sizeof(addr.sun_path), (char const   * __restrict  )*path,
             dnr);
#line 1899
    tmp___1 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& addr)),
                      sizeof(addr));
#line 1899
    if (tmp___1 == 0) {
#line 1900
      return (sock);
    }
#line 1901
    close(sock);
#line 1892
    path ++;
  }
#line 1903
  tmp___2 = __errno_location();
#line 1903
  tmp___3 = strerror(*tmp___2);
#line 1903
  error("connect %.100s: %.100s", addr.sun_path, tmp___3);
#line 1904
  return (-1);
}
}
#line 1907 "channels.c"
int x11_connect_display(void) 
{ int display_number ;
  int sock ;
  char const   *display ;
  char buf___1[1024] ;
  char *cp ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___29 ;
  int tmp___30 ;
  char const   *tmp___31 ;
  int *tmp___32 ;
  char *tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  int *tmp___37 ;
  char *tmp___38 ;

  {
#line 1910
  sock = 0;
#line 1918
  tmp = getenv("DISPLAY");
#line 1918
  display = (char const   *)tmp;
#line 1919
  if (! display) {
#line 1920
    error("DISPLAY not set.");
#line 1921
    return (-1);
  }
#line 1932
  if (0) {
#line 1932
    if (0) {
#line 1932
      __s1_len___0 = strlen(display);
#line 1932
      __s2_len___0 = strlen("unix:");
#line 1932
      if (! ((unsigned int )((void const   *)(display + 1)) - (unsigned int )((void const   *)display) == 1U)) {
        goto _L___2;
      } else {
#line 1932
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 1932
          if (! ((unsigned int )((void const   *)("unix:" + 1)) - (unsigned int )((void const   *)"unix:") == 1U)) {
#line 1932
            tmp___25 = 1;
          } else {
#line 1932
            if (__s2_len___0 >= 4U) {
#line 1932
              tmp___25 = 1;
            } else {
#line 1932
              tmp___25 = 0;
            }
          }
        } else {
#line 1932
          tmp___25 = 0;
        }
      }
#line 1932
      if (tmp___25) {
#line 1932
        tmp___21 = __builtin_strcmp(display, "unix:");
      } else {
#line 1932
        tmp___24 = __builtin_strcmp(display, "unix:");
#line 1932
        tmp___21 = tmp___24;
      }
    } else {
#line 1932
      tmp___24 = __builtin_strcmp(display, "unix:");
#line 1932
      tmp___21 = tmp___24;
    }
#line 1932
    tmp___15 = tmp___21;
  } else {
#line 1932
    tmp___15 = strncmp(display, "unix:", 5U);
  }
#line 1932
  if (tmp___15 == 0) {
    goto _L___3;
  } else {
#line 1932
    if ((int const   )*(display + 0) == 58) {
      _L___3: /* CIL Label */ 
#line 1935
      tmp___0 = strrchr(display, ':');
#line 1935
      tmp___1 = sscanf((char const   * __restrict  )(tmp___0 + 1), (char const   * __restrict  )"%d",
                       & display_number);
#line 1935
      if (tmp___1 != 1) {
#line 1936
        error("Could not parse display number from DISPLAY: %.100s", display);
#line 1938
        return (-1);
      }
#line 1941
      sock = connect_local_xsocket((unsigned int )display_number);
#line 1942
      if (sock < 0) {
#line 1943
        return (-1);
      }
#line 1946
      return (sock);
    }
  }
#line 1952
  __builtin_strncpy(buf___1, display, sizeof(buf___1));
#line 1953
  buf___1[sizeof(buf___1) - 1U] = (char)0;
#line 1954
  tmp___29 = __builtin_strchr(buf___1, ':');
#line 1954
  cp = tmp___29;
#line 1955
  if (! cp) {
#line 1956
    error("Could not find \':\' in DISPLAY: %.100s", display);
#line 1957
    return (-1);
  }
#line 1959
  *cp = (char)0;
#line 1961
  tmp___30 = sscanf((char const   * __restrict  )(cp + 1), (char const   * __restrict  )"%d",
                    & display_number);
#line 1961
  if (tmp___30 != 1) {
#line 1962
    error("Could not parse display number from DISPLAY: %.100s", display);
#line 1964
    return (-1);
  }
#line 1968
  memset((void *)(& hints), 0, sizeof(hints));
#line 1969
  hints.ai_family = IPv4or6;
#line 1970
  hints.ai_socktype = 1;
#line 1971
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           6000 + display_number);
#line 1972
  gaierr = getaddrinfo((char const   * __restrict  )(buf___1), (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 1972
  if (gaierr != 0) {
#line 1973
    tmp___31 = gai_strerror(gaierr);
#line 1973
    error("%.100s: unknown host. (%s)", buf___1, tmp___31);
#line 1974
    return (-1);
  }
#line 1976
  ai = aitop;
#line 1976
  while (ai) {
#line 1978
    sock = socket(ai->ai_family, 1, 0);
#line 1979
    if (sock < 0) {
#line 1980
      tmp___32 = __errno_location();
#line 1980
      tmp___33 = strerror(*tmp___32);
#line 1980
      debug("socket: %.100s", tmp___33);
      goto __Cont;
    }
#line 1984
    tmp___36 = connect(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 1984
    if (tmp___36 < 0) {
#line 1985
      tmp___34 = __errno_location();
#line 1985
      tmp___35 = strerror(*tmp___34);
#line 1985
      debug("connect %.100s port %d: %.100s", buf___1, 6000 + display_number, tmp___35);
#line 1987
      close(sock);
      goto __Cont;
    }
#line 1991
    break;
    __Cont: /* CIL Label */ 
#line 1976
    ai = ai->ai_next;
  }
#line 1993
  freeaddrinfo(aitop);
#line 1994
  if (! ai) {
#line 1995
    tmp___37 = __errno_location();
#line 1995
    tmp___38 = strerror(*tmp___37);
#line 1995
    error("connect %.100s port %d: %.100s", buf___1, 6000 + display_number, tmp___38);
#line 1997
    return (-1);
  }
#line 1999
  return (sock);
}
}
#line 2008 "channels.c"
void x11_input_open(int type , int plen , void *ctxt ) 
{ int remote_channel ;
  int sock ;
  int newch ;
  char *remote_host ;
  unsigned int remote_len ;
  unsigned int tmp ;
  int _p ;
  int _e ;
  int tmp___0 ;

  {
#line 2011
  sock = 0;
#line 2016
  tmp = packet_get_int();
#line 2016
  remote_channel = (int )tmp;
#line 2019
  if (have_hostname_in_open) {
#line 2020
    remote_host = packet_get_string(& remote_len);
#line 2021
    remote_len += 4U;
  } else {
#line 2023
    remote_host = xstrdup("unknown (remote did not supply name)");
#line 2024
    remote_len = 0U;
  }
#line 2027
  debug("Received X11 open request.");
#line 2028
  while (1) {
#line 2028
    _p = plen;
#line 2028
    _e = (int )(4U + remote_len);
#line 2028
    if (_p != _e) {
#line 2028
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 2028);
#line 2028
      packet_disconnect("Packet integrity error. (%d)", 27);
    }
#line 2028
    break;
  }
#line 2031
  sock = x11_connect_display();
#line 2032
  if (sock == -1) {
#line 2034
    packet_start(22);
#line 2035
    packet_put_int((unsigned int )remote_channel);
#line 2036
    packet_send();
  } else {
#line 2039
    if ((unsigned int )x11_saved_proto == (unsigned int )((void *)0)) {
#line 2039
      tmp___0 = 4;
    } else {
#line 2039
      tmp___0 = 7;
    }
#line 2039
    newch = channel_allocate(tmp___0, sock, remote_host);
#line 2043
    (channels + newch)->remote_id = remote_channel;
#line 2046
    packet_start(21);
#line 2047
    packet_put_int((unsigned int )remote_channel);
#line 2048
    packet_put_int((unsigned int )newch);
#line 2049
    packet_send();
  }
#line 2051
  return;
}
}
#line 2054 "channels.c"
void deny_input_open(int type , int plen , void *ctxt ) 
{ int rchan ;
  unsigned int tmp ;

  {
#line 2057
  tmp = packet_get_int();
#line 2057
  rchan = (int )tmp;
#line 2058
  switch (type) {
  case 31: 
#line 2060
  error("Warning: ssh server tried agent forwarding.");
#line 2061
  break;
  case 27: 
#line 2063
  error("Warning: ssh server tried X11 forwarding.");
#line 2064
  break;
  default: 
#line 2066
  error("deny_input_open: type %d plen %d", type, plen);
#line 2067
  break;
  }
#line 2069
  error("Warning: this is probably a break in attempt by a malicious server.");
#line 2070
  packet_start(22);
#line 2071
  packet_put_int((unsigned int )rchan);
#line 2072
  packet_send();
#line 2073
  return;
}
}
#line 2080 "channels.c"
void x11_request_forwarding_with_spoofing(int client_session_id , char const   *proto ,
                                          char const   *data ) 
{ unsigned int data_len ;
  size_t tmp ;
  unsigned int i ;
  unsigned int value ;
  char *new_data ;
  int screen_number ;
  char const   *cp ;
  u_int32_t rand___0 ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;

  {
#line 2084
  tmp = strlen(data);
#line 2084
  data_len = tmp / 2U;
#line 2089
  rand___0 = (u_int32_t )0;
#line 2091
  tmp___0 = getenv("DISPLAY");
#line 2091
  cp = (char const   *)tmp___0;
#line 2092
  if (cp) {
#line 2093
    tmp___2 = __builtin_strchr((char *)cp, ':');
#line 2093
    cp = (char const   *)tmp___2;
  }
#line 2094
  if (cp) {
#line 2095
    tmp___4 = __builtin_strchr((char *)cp, '.');
#line 2095
    cp = (char const   *)tmp___4;
  }
#line 2096
  if (cp) {
#line 2097
    screen_number = atoi(cp + 1);
  } else {
#line 2099
    screen_number = 0;
  }
#line 2102
  x11_saved_proto = xstrdup(proto);
#line 2108
  tmp___5 = xmalloc(data_len);
#line 2108
  x11_saved_data = (char *)tmp___5;
#line 2109
  tmp___6 = xmalloc(data_len);
#line 2109
  x11_fake_data = (char *)tmp___6;
#line 2110
  i = 0U;
#line 2110
  while (i < data_len) {
#line 2111
    tmp___7 = sscanf((char const   * __restrict  )(data + 2U * i), (char const   * __restrict  )"%2x",
                     & value);
#line 2111
    if (tmp___7 != 1) {
#line 2112
      fatal("x11_request_forwarding: bad authentication data: %.100s", data);
    }
#line 2113
    if (i % 4U == 0U) {
#line 2114
      rand___0 = arc4random();
    }
#line 2115
    *(x11_saved_data + i) = (char )value;
#line 2116
    *(x11_fake_data + i) = (char )(rand___0 & 255U);
#line 2117
    rand___0 >>= 8;
#line 2110
    i ++;
  }
#line 2119
  x11_saved_data_len = data_len;
#line 2120
  x11_fake_data_len = data_len;
#line 2123
  tmp___8 = xmalloc(2U * data_len + 1U);
#line 2123
  new_data = (char *)tmp___8;
#line 2124
  i = 0U;
#line 2124
  while (i < data_len) {
#line 2125
    sprintf((char * __restrict  )(new_data + 2U * i), (char const   * __restrict  )"%02x",
            (unsigned char )*(x11_fake_data + i));
#line 2124
    i ++;
  }
#line 2128
  if (compat20) {
#line 2129
    channel_request_start(client_session_id, (char *)"x11-req", 0);
#line 2130
    packet_put_char(0);
  } else {
#line 2132
    packet_start(34);
  }
#line 2134
  packet_put_cstring(proto);
#line 2135
  packet_put_cstring((char const   *)new_data);
#line 2136
  packet_put_int((unsigned int )screen_number);
#line 2137
  packet_send();
#line 2138
  packet_write_wait();
#line 2139
  xfree((void *)new_data);
#line 2140
  return;
}
}
#line 2144 "channels.c"
void auth_request_forwarding(void) 
{ 

  {
#line 2147
  packet_start(30);
#line 2148
  packet_send();
#line 2149
  packet_write_wait();
#line 2150
  return;
}
}
#line 2158 "channels.c"
char *auth_get_socket_name(void) 
{ 

  {
#line 2161
  return (channel_forwarded_auth_socket_name);
}
}
#line 2166 "channels.c"
void cleanup_socket(void) 
{ 

  {
#line 2169
  unlink((char const   *)channel_forwarded_auth_socket_name);
#line 2170
  rmdir((char const   *)channel_forwarded_auth_socket_dir);
#line 2171
  return;
}
}
#line 2178 "channels.c"
int auth_input_request_forwarding(struct passwd *pw ) 
{ int sock ;
  int newch ;
  struct sockaddr_un sunaddr ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  __pid_t tmp___5 ;
  int saved ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;

  {
#line 2184
  tmp = auth_get_socket_name();
#line 2184
  if ((unsigned int )tmp != (unsigned int )((void *)0)) {
#line 2185
    fatal("Protocol error: authentication forwarding requested twice.");
  }
#line 2188
  temporarily_use_uid(pw->pw_uid);
#line 2191
  tmp___0 = xmalloc(100U);
#line 2191
  channel_forwarded_auth_socket_name = (char *)tmp___0;
#line 2192
  tmp___1 = xmalloc(100U);
#line 2192
  channel_forwarded_auth_socket_dir = (char *)tmp___1;
#line 2193
  strlcpy(channel_forwarded_auth_socket_dir, "/tmp/ssh-XXXXXXXX", 100U);
#line 2196
  tmp___4 = mkdtemp(channel_forwarded_auth_socket_dir);
#line 2196
  if ((unsigned int )tmp___4 == (unsigned int )((void *)0)) {
#line 2197
    tmp___2 = __errno_location();
#line 2197
    tmp___3 = strerror(*tmp___2);
#line 2197
    packet_send_debug("Agent forwarding disabled: mkdtemp() failed: %.100s", tmp___3);
#line 2199
    restore_uid();
#line 2200
    xfree((void *)channel_forwarded_auth_socket_name);
#line 2201
    xfree((void *)channel_forwarded_auth_socket_dir);
#line 2202
    channel_forwarded_auth_socket_name = (char *)((void *)0);
#line 2203
    channel_forwarded_auth_socket_dir = (char *)((void *)0);
#line 2204
    return (0);
  }
#line 2206
  tmp___5 = getpid();
#line 2206
  snprintf((char * __restrict  )channel_forwarded_auth_socket_name, 100U, (char const   * __restrict  )"%s/agent.%d",
           channel_forwarded_auth_socket_dir, tmp___5);
#line 2209
  tmp___8 = atexit(& cleanup_socket);
#line 2209
  if (tmp___8 < 0) {
#line 2210
    tmp___6 = __errno_location();
#line 2210
    saved = *tmp___6;
#line 2211
    cleanup_socket();
#line 2212
    tmp___7 = strerror(saved);
#line 2212
    packet_disconnect("socket: %.100s", tmp___7);
  }
#line 2215
  sock = socket(1, 1, 0);
#line 2216
  if (sock < 0) {
#line 2217
    tmp___9 = __errno_location();
#line 2217
    tmp___10 = strerror(*tmp___9);
#line 2217
    packet_disconnect("socket: %.100s", tmp___10);
  }
#line 2220
  memset((void *)(& sunaddr), 0, sizeof(sunaddr));
#line 2221
  sunaddr.sun_family = (unsigned short)1;
#line 2222
  __builtin_strncpy(sunaddr.sun_path, (char const   *)channel_forwarded_auth_socket_name,
                    sizeof(sunaddr.sun_path));
#line 2225
  tmp___13 = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sunaddr)),
                  sizeof(sunaddr));
#line 2225
  if (tmp___13 < 0) {
#line 2226
    tmp___11 = __errno_location();
#line 2226
    tmp___12 = strerror(*tmp___11);
#line 2226
    packet_disconnect("bind: %.100s", tmp___12);
  }
#line 2229
  restore_uid();
#line 2232
  tmp___16 = listen(sock, 5);
#line 2232
  if (tmp___16 < 0) {
#line 2233
    tmp___14 = __errno_location();
#line 2233
    tmp___15 = strerror(*tmp___14);
#line 2233
    packet_disconnect("listen: %.100s", tmp___15);
  }
#line 2236
  tmp___17 = xstrdup("auth socket");
#line 2236
  newch = channel_allocate(6, sock, tmp___17);
#line 2238
  strlcpy((channels + newch)->path, (char const   *)channel_forwarded_auth_socket_name,
          sizeof((channels + newch)->path));
#line 2240
  return (1);
}
}
#line 2245 "channels.c"
void auth_input_open_request(int type , int plen , void *ctxt ) 
{ int remch ;
  int sock ;
  int newch ;
  char *dummyname ;
  int _p ;
  int _e ;
  unsigned int tmp ;

  {
#line 2251
  while (1) {
#line 2251
    _p = plen;
#line 2251
    _e = 4;
#line 2251
    if (_p != _e) {
#line 2251
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 2251);
#line 2251
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 2251
    break;
  }
#line 2254
  tmp = packet_get_int();
#line 2254
  remch = (int )tmp;
#line 2260
  sock = ssh_get_authentication_socket();
#line 2268
  if (sock < 0) {
#line 2269
    packet_start(22);
#line 2270
    packet_put_int((unsigned int )remch);
#line 2271
    packet_send();
#line 2272
    return;
  }
#line 2274
  debug("Forwarding authentication connection.");
#line 2281
  dummyname = xstrdup("authentication agent connection");
#line 2283
  newch = channel_allocate(4, sock, dummyname);
#line 2284
  (channels + newch)->remote_id = remch;
#line 2287
  packet_start(21);
#line 2288
  packet_put_int((unsigned int )remch);
#line 2289
  packet_put_int((unsigned int )newch);
#line 2290
  packet_send();
#line 2291
  return;
}
}
#line 2293 "channels.c"
void channel_start_open(int id ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2296
  tmp = channel_lookup(id);
#line 2296
  c = tmp;
#line 2297
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2298
    log("channel_open: %d: bad id", id);
#line 2299
    return;
  }
#line 2301
  debug("send channel open %d", id);
#line 2302
  packet_start(90);
#line 2303
  packet_put_cstring((char const   *)c->ctype);
#line 2304
  packet_put_int((unsigned int )c->self);
#line 2305
  packet_put_int((unsigned int )c->local_window);
#line 2306
  packet_put_int((unsigned int )c->local_maxpacket);
#line 2307
  return;
}
}
#line 2308 "channels.c"
void channel_open(int id ) 
{ 

  {
#line 2312
  channel_start_open(id);
#line 2313
  packet_send();
#line 2314
  return;
}
}
#line 2315 "channels.c"
void channel_request(int id , char *service , int wantconfirm ) 
{ 

  {
#line 2318
  channel_request_start(id, service, wantconfirm);
#line 2319
  packet_send();
#line 2320
  debug("channel request %d: %s", id, service);
#line 2321
  return;
}
}
#line 2322 "channels.c"
void channel_request_start(int id , char *service , int wantconfirm ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2325
  tmp = channel_lookup(id);
#line 2325
  c = tmp;
#line 2326
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2327
    log("channel_request: %d: bad id", id);
#line 2328
    return;
  }
#line 2330
  packet_start(98);
#line 2331
  packet_put_int((unsigned int )c->remote_id);
#line 2332
  packet_put_cstring((char const   *)service);
#line 2333
  packet_put_char(wantconfirm);
#line 2334
  return;
}
}
#line 2335 "channels.c"
void channel_register_callback(int id , int mtype , channel_callback_fn *fn , void *arg ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2338
  tmp = channel_lookup(id);
#line 2338
  c = tmp;
#line 2339
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2340
    log("channel_register_callback: %d: bad id", id);
#line 2341
    return;
  }
#line 2343
  c->cb_event = mtype;
#line 2344
  c->cb_fn = fn;
#line 2345
  c->cb_arg = arg;
#line 2346
  return;
}
}
#line 2347 "channels.c"
void channel_register_cleanup(int id , channel_callback_fn *fn ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2350
  tmp = channel_lookup(id);
#line 2350
  c = tmp;
#line 2351
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2352
    log("channel_register_cleanup: %d: bad id", id);
#line 2353
    return;
  }
#line 2355
  c->dettach_user = fn;
#line 2356
  return;
}
}
#line 2357 "channels.c"
void channel_cancel_cleanup(int id ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2360
  tmp = channel_lookup(id);
#line 2360
  c = tmp;
#line 2361
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2362
    log("channel_cancel_cleanup: %d: bad id", id);
#line 2363
    return;
  }
#line 2365
  c->dettach_user = (channel_callback_fn *)((void *)0);
#line 2366
  return;
}
}
#line 2367 "channels.c"
void channel_register_filter(int id , channel_filter_fn *fn ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2370
  tmp = channel_lookup(id);
#line 2370
  c = tmp;
#line 2371
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2372
    log("channel_register_filter: %d: bad id", id);
#line 2373
    return;
  }
#line 2375
  c->input_filter = fn;
#line 2376
  return;
}
}
#line 2378 "channels.c"
void channel_set_fds(int id , int rfd , int wfd , int efd , int extusage , int nonblock ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2382
  tmp = channel_lookup(id);
#line 2382
  c = tmp;
#line 2383
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2384
    fatal("channel_activate for non-larval channel %d.", id);
  } else {
#line 2383
    if (c->type != 10) {
#line 2384
      fatal("channel_activate for non-larval channel %d.", id);
    }
  }
#line 2385
  channel_register_fds(c, rfd, wfd, efd, extusage, nonblock);
#line 2386
  c->type = 4;
#line 2388
  c->local_window_max = c->local_maxpacket * 2;
#line 2388
  c->local_window = c->local_window_max;
#line 2389
  packet_start(93);
#line 2390
  packet_put_int((unsigned int )c->remote_id);
#line 2391
  packet_put_int((unsigned int )c->local_window);
#line 2392
  packet_send();
#line 2393
  return;
}
}
#line 1 "cipher.o"
#line 325 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 1205 "/usr/include/bits/string2.h"
extern char *__strsep_g(char **__stringp , char const   *__delim ) ;
#line 138 "/usr/include/openssl/des.h"
extern void DES_cbc_encrypt(unsigned char const   *input , unsigned char *output ,
                            long length , DES_key_schedule *schedule , DES_cblock *ivec ,
                            int enc ) ;
#line 141
extern void DES_ncbc_encrypt(unsigned char const   *input , unsigned char *output ,
                             long length , DES_key_schedule *schedule , DES_cblock *ivec ,
                             int enc ) ;
#line 176
extern void DES_ede3_cbc_encrypt(unsigned char const   *input , unsigned char *output ,
                                 long length , DES_key_schedule *ks1 , DES_key_schedule *ks2 ,
                                 DES_key_schedule *ks3 , DES_cblock *ivec , int enc ) ;
#line 222
extern int DES_set_key(const_DES_cblock *key , DES_key_schedule *schedule ) ;
#line 108 "/usr/include/openssl/blowfish.h"
extern void BF_set_key(BF_KEY *key , int len , unsigned char const   *data ) ;
#line 115
extern void BF_cbc_encrypt(unsigned char const   *in , unsigned char *out , long length ,
                           BF_KEY const   *schedule , unsigned char *ivec , int enc ) ;
#line 79 "/usr/include/openssl/rc4.h"
extern void RC4_set_key(RC4_KEY *key , int len , unsigned char const   *data ) ;
#line 80
extern void RC4(RC4_KEY *key , unsigned long len , unsigned char const   *indata ,
                unsigned char *outdata ) ;
#line 87 "/usr/include/openssl/cast.h"
extern void CAST_set_key(CAST_KEY *key , int len , unsigned char const   *data ) ;
#line 92
extern void CAST_cbc_encrypt(unsigned char const   *in , unsigned char *out , long length ,
                             CAST_KEY *ks , unsigned char *iv , int enc ) ;
#line 29 "rijndael.h"
rijndael_ctx *rijndael_set_key(rijndael_ctx *ctx , u4byte const   *in_key , u4byte key_len ,
                               int encrypt ) ;
#line 30
void rijndael_encrypt(rijndael_ctx *ctx , u4byte const   *in_blk , u4byte *out_blk ) ;
#line 31
void rijndael_decrypt(rijndael_ctx *ctx , u4byte const   *in_blk , u4byte *out_blk ) ;
#line 106 "cipher.h"
unsigned int cipher_mask_ssh1(int client ) ;
#line 107
Cipher *cipher_by_name(char const   *name ) ;
#line 109
int cipher_number(char const   *name ) ;
#line 110
char *cipher_name(int id ) ;
#line 111
int ciphers_valid(char const   *names ) ;
#line 112
void cipher_init(CipherContext *cc , Cipher *cipher , u_char const   *key , u_int keylen ,
                 u_char const   *iv , u_int ivlen ) ;
#line 466 "ssh.h"
void ( /* format attribute */  debug3)(char const   *fmt  , ...) ;
#line 107 "/usr/include/openssl/md5.h"
extern int MD5_Init(MD5_CTX *c ) ;
#line 108
extern int MD5_Update(MD5_CTX *c , void const   *data , size_t len ) ;
#line 109
extern int MD5_Final(unsigned char *md , MD5_CTX *c ) ;
#line 47 "cipher.c"
void none_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) 
{ 

  {
#line 50
  return;
}
}
#line 51 "cipher.c"
void none_setiv(CipherContext *cc , u_char const   *iv , u_int ivlen ) 
{ 

  {
#line 54
  return;
}
}
#line 55 "cipher.c"
void none_crypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 58
  memcpy((void * __restrict  )dest, (void const   * __restrict  )src, len);
#line 59
  return;
}
}
#line 65
void des_ssh1_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) ;
#line 65 "cipher.c"
static int dowarn  =    1;
#line 62 "cipher.c"
void des_ssh1_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) 
{ 

  {
#line 66
  if (dowarn) {
#line 67
    error("Warning: use of DES is strongly discouraged due to cryptographic weaknesses");
#line 69
    dowarn = 0;
  }
#line 71
  DES_set_key((const_DES_cblock *)((void *)key), & cc->u.des.key);
#line 72
  return;
}
}
#line 73 "cipher.c"
void des_ssh1_setiv(CipherContext *cc , u_char const   *iv , u_int ivlen ) 
{ 

  {
#line 76
  memset((void *)(cc->u.des.iv), 0, sizeof(cc->u.des.iv));
#line 77
  return;
}
}
#line 78 "cipher.c"
void des_ssh1_encrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 81
  DES_ncbc_encrypt(src, dest, (long )len, & cc->u.des.key, & cc->u.des.iv, 1);
#line 83
  return;
}
}
#line 84 "cipher.c"
void des_ssh1_decrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 87
  DES_ncbc_encrypt(src, dest, (long )len, & cc->u.des.key, & cc->u.des.iv, 0);
#line 89
  return;
}
}
#line 92 "cipher.c"
void des3_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) 
{ 

  {
#line 95
  DES_set_key((const_DES_cblock *)((void *)key), & cc->u.des3.key1);
#line 96
  DES_set_key((const_DES_cblock *)((void *)(key + 8)), & cc->u.des3.key2);
#line 97
  DES_set_key((const_DES_cblock *)((void *)(key + 16)), & cc->u.des3.key3);
#line 98
  return;
}
}
#line 99 "cipher.c"
void des3_setiv(CipherContext *cc , u_char const   *iv , u_int ivlen ) 
{ 

  {
#line 102
  memset((void *)(cc->u.des3.iv2), 0, sizeof(cc->u.des3.iv2));
#line 103
  memset((void *)(cc->u.des3.iv3), 0, sizeof(cc->u.des3.iv3));
#line 104
  if ((unsigned int )iv == (unsigned int )((void *)0)) {
#line 105
    return;
  }
#line 106
  memcpy((void * __restrict  )(cc->u.des3.iv3), (void const   * __restrict  )((char *)iv),
         8U);
#line 107
  return;
}
}
#line 108 "cipher.c"
void des3_cbc_encrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 111
  DES_ede3_cbc_encrypt(src, dest, (long )len, & cc->u.des3.key1, & cc->u.des3.key2,
                       & cc->u.des3.key3, & cc->u.des3.iv3, 1);
#line 114
  return;
}
}
#line 115 "cipher.c"
void des3_cbc_decrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 118
  DES_ede3_cbc_encrypt(src, dest, (long )len, & cc->u.des3.key1, & cc->u.des3.key2,
                       & cc->u.des3.key3, & cc->u.des3.iv3, 0);
#line 121
  return;
}
}
#line 137 "cipher.c"
void des3_ssh1_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) 
{ 

  {
#line 140
  DES_set_key((const_DES_cblock *)((void *)key), & cc->u.des3.key1);
#line 141
  DES_set_key((const_DES_cblock *)((void *)(key + 8)), & cc->u.des3.key2);
#line 142
  if (keylen <= 16U) {
#line 143
    DES_set_key((const_DES_cblock *)((void *)key), & cc->u.des3.key3);
  } else {
#line 145
    DES_set_key((const_DES_cblock *)((void *)(key + 16)), & cc->u.des3.key3);
  }
#line 146
  return;
}
}
#line 147 "cipher.c"
void des3_ssh1_encrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ DES_cblock iv1 ;
  DES_cblock *iv2 ;
  DES_cblock *iv3 ;

  {
#line 152
  iv2 = & cc->u.des3.iv2;
#line 153
  iv3 = & cc->u.des3.iv3;
#line 155
  memcpy((void * __restrict  )(& iv1), (void const   * __restrict  )iv2, 8U);
#line 157
  DES_cbc_encrypt(src, dest, (long )len, & cc->u.des3.key1, & iv1, 1);
#line 158
  memcpy((void * __restrict  )(& iv1), (void const   * __restrict  )((dest + len) - 8),
         8U);
#line 160
  DES_cbc_encrypt((unsigned char const   *)dest, dest, (long )len, & cc->u.des3.key2,
                  iv2, 0);
#line 161
  memcpy((void * __restrict  )iv2, (void const   * __restrict  )(& iv1), 8U);
#line 163
  DES_cbc_encrypt((unsigned char const   *)dest, dest, (long )len, & cc->u.des3.key3,
                  iv3, 1);
#line 164
  memcpy((void * __restrict  )iv3, (void const   * __restrict  )((dest + len) - 8),
         8U);
#line 165
  return;
}
}
#line 166 "cipher.c"
void des3_ssh1_decrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ DES_cblock iv1 ;
  DES_cblock *iv2 ;
  DES_cblock *iv3 ;

  {
#line 171
  iv2 = & cc->u.des3.iv2;
#line 172
  iv3 = & cc->u.des3.iv3;
#line 174
  memcpy((void * __restrict  )(& iv1), (void const   * __restrict  )iv2, 8U);
#line 176
  DES_cbc_encrypt(src, dest, (long )len, & cc->u.des3.key3, iv3, 0);
#line 177
  memcpy((void * __restrict  )iv3, (void const   * __restrict  )((src + len) - 8),
         8U);
#line 179
  DES_cbc_encrypt((unsigned char const   *)dest, dest, (long )len, & cc->u.des3.key2,
                  iv2, 1);
#line 180
  memcpy((void * __restrict  )iv2, (void const   * __restrict  )((dest + len) - 8),
         8U);
#line 182
  DES_cbc_encrypt((unsigned char const   *)dest, dest, (long )len, & cc->u.des3.key1,
                  & iv1, 0);
#line 185
  return;
}
}
#line 188 "cipher.c"
void blowfish_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) 
{ 

  {
#line 191
  BF_set_key(& cc->u.bf.key, (int )keylen, (unsigned char const   *)((unsigned char *)key));
#line 192
  return;
}
}
#line 193 "cipher.c"
void blowfish_setiv(CipherContext *cc , u_char const   *iv , u_int ivlen ) 
{ 

  {
#line 196
  if ((unsigned int )iv == (unsigned int )((void *)0)) {
#line 197
    memset((void *)(cc->u.bf.iv), 0, 8U);
  } else {
#line 199
    memcpy((void * __restrict  )(cc->u.bf.iv), (void const   * __restrict  )((char *)iv),
           8U);
  }
#line 200
  return;
}
}
#line 201 "cipher.c"
void blowfish_cbc_encrypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                          u_int len ) 
{ 

  {
#line 205
  BF_cbc_encrypt((unsigned char const   *)((void *)src), dest, (long )len, (BF_KEY const   *)(& cc->u.bf.key),
                 cc->u.bf.iv, 1);
#line 207
  return;
}
}
#line 208 "cipher.c"
void blowfish_cbc_decrypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                          u_int len ) 
{ 

  {
#line 212
  BF_cbc_encrypt((unsigned char const   *)((void *)src), dest, (long )len, (BF_KEY const   *)(& cc->u.bf.key),
                 cc->u.bf.iv, 0);
#line 214
  return;
}
}
#line 220 "cipher.c"
static void swap_bytes(unsigned char const   *src , unsigned char *dst , int n___0 ) 
{ char c[4] ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;

  {
#line 226
  n___0 /= 4;
#line 226
  while (n___0 > 0) {
#line 227
    tmp = src;
#line 227
    src ++;
#line 227
    c[3] = (char )*tmp;
#line 228
    tmp___0 = src;
#line 228
    src ++;
#line 228
    c[2] = (char )*tmp___0;
#line 229
    tmp___1 = src;
#line 229
    src ++;
#line 229
    c[1] = (char )*tmp___1;
#line 230
    tmp___2 = src;
#line 230
    src ++;
#line 230
    c[0] = (char )*tmp___2;
#line 232
    tmp___3 = dst;
#line 232
    dst ++;
#line 232
    *tmp___3 = (unsigned char )c[0];
#line 233
    tmp___4 = dst;
#line 233
    dst ++;
#line 233
    *tmp___4 = (unsigned char )c[1];
#line 234
    tmp___5 = dst;
#line 234
    dst ++;
#line 234
    *tmp___5 = (unsigned char )c[2];
#line 235
    tmp___6 = dst;
#line 235
    dst ++;
#line 235
    *tmp___6 = (unsigned char )c[3];
#line 226
    n___0 --;
  }
#line 237
  return;
}
}
#line 239 "cipher.c"
void blowfish_ssh1_encrypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                           u_int len ) 
{ 

  {
#line 243
  swap_bytes(src, dest, (int )len);
#line 244
  BF_cbc_encrypt((unsigned char const   *)((void *)dest), dest, (long )len, (BF_KEY const   *)(& cc->u.bf.key),
                 cc->u.bf.iv, 1);
#line 246
  swap_bytes((unsigned char const   *)dest, dest, (int )len);
#line 247
  return;
}
}
#line 248 "cipher.c"
void blowfish_ssh1_decrypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                           u_int len ) 
{ 

  {
#line 252
  swap_bytes(src, dest, (int )len);
#line 253
  BF_cbc_encrypt((unsigned char const   *)((void *)dest), dest, (long )len, (BF_KEY const   *)(& cc->u.bf.key),
                 cc->u.bf.iv, 0);
#line 255
  swap_bytes((unsigned char const   *)dest, dest, (int )len);
#line 256
  return;
}
}
#line 259 "cipher.c"
void arcfour_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) 
{ 

  {
#line 262
  RC4_set_key(& cc->u.rc4, (int )keylen, (unsigned char const   *)((u_char *)key));
#line 263
  return;
}
}
#line 264 "cipher.c"
void arcfour_crypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 267
  RC4(& cc->u.rc4, (unsigned long )len, (unsigned char const   *)((u_char *)src),
      dest);
#line 268
  return;
}
}
#line 271 "cipher.c"
void cast_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) 
{ 

  {
#line 274
  CAST_set_key(& cc->u.cast.key, (int )keylen, (unsigned char const   *)((unsigned char *)key));
#line 275
  return;
}
}
#line 276 "cipher.c"
void cast_setiv(CipherContext *cc , u_char const   *iv , u_int ivlen ) 
{ 

  {
#line 279
  if ((unsigned int )iv == (unsigned int )((void *)0)) {
#line 280
    fatal("no IV for %s.", (cc->cipher)->name);
  }
#line 281
  memcpy((void * __restrict  )(cc->u.cast.iv), (void const   * __restrict  )((char *)iv),
         8U);
#line 282
  return;
}
}
#line 283 "cipher.c"
void cast_cbc_encrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 286
  CAST_cbc_encrypt(src, dest, (long )len, & cc->u.cast.key, cc->u.cast.iv, 1);
#line 288
  return;
}
}
#line 289 "cipher.c"
void cast_cbc_decrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 292
  CAST_cbc_encrypt(src, dest, (long )len, & cc->u.cast.key, cc->u.cast.iv, 0);
#line 294
  return;
}
}
#line 299 "cipher.c"
void rijndael_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) 
{ 

  {
#line 302
  rijndael_set_key(& cc->u.rijndael.enc, (u4byte const   *)((u4byte *)key), 8U * keylen,
                   1);
#line 303
  rijndael_set_key(& cc->u.rijndael.dec, (u4byte const   *)((u4byte *)key), 8U * keylen,
                   0);
#line 304
  return;
}
}
#line 305 "cipher.c"
void rijndael_setiv(CipherContext *cc , u_char const   *iv , u_int ivlen ) 
{ 

  {
#line 308
  if ((unsigned int )iv == (unsigned int )((void *)0)) {
#line 309
    fatal("no IV for %s.", (cc->cipher)->name);
  }
#line 310
  memcpy((void * __restrict  )((u_char *)(cc->u.rijndael.iv)), (void const   * __restrict  )iv,
         16U);
#line 311
  return;
}
}
#line 312 "cipher.c"
void rijndael_cbc_encrypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                          u_int len ) 
{ rijndael_ctx *ctx ;
  u4byte *iv ;
  u4byte in[4] ;
  u4byte *cprev ;
  u4byte *cnow ;
  u4byte *plain ;
  int i ;
  int blocks ;

  {
#line 316
  ctx = & cc->u.rijndael.enc;
#line 317
  iv = cc->u.rijndael.iv;
#line 320
  blocks = (int )(len / 16U);
#line 321
  if (len == 0U) {
#line 322
    return;
  }
#line 323
  if (len % 16U) {
#line 324
    fatal("rijndael_cbc_encrypt: bad len %d", len);
  }
#line 325
  cnow = (u4byte *)dest;
#line 326
  plain = (u4byte *)src;
#line 327
  cprev = iv;
#line 328
  i = 0;
#line 328
  while (i < blocks) {
#line 329
    in[0] = *(plain + 0) ^ *(cprev + 0);
#line 330
    in[1] = *(plain + 1) ^ *(cprev + 1);
#line 331
    in[2] = *(plain + 2) ^ *(cprev + 2);
#line 332
    in[3] = *(plain + 3) ^ *(cprev + 3);
#line 333
    rijndael_encrypt(ctx, (u4byte const   *)(in), cnow);
#line 334
    cprev = cnow;
#line 328
    i ++;
#line 328
    plain += 4;
#line 328
    cnow += 4;
  }
#line 336
  memcpy((void * __restrict  )iv, (void const   * __restrict  )cprev, 16U);
#line 337
  return;
}
}
#line 339 "cipher.c"
void rijndael_cbc_decrypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                          u_int len ) 
{ rijndael_ctx *ctx ;
  u4byte *iv ;
  u4byte ivsaved[4] ;
  u4byte *cnow ;
  u4byte *plain ;
  u4byte *ivp ;
  int i ;
  int blocks ;

  {
#line 343
  ctx = & cc->u.rijndael.dec;
#line 344
  iv = cc->u.rijndael.iv;
#line 346
  cnow = (u4byte *)((src + len) - 16);
#line 347
  plain = (u4byte *)((dest + len) - 16);
#line 349
  blocks = (int )(len / 16U);
#line 350
  if (len == 0U) {
#line 351
    return;
  }
#line 352
  if (len % 16U) {
#line 353
    fatal("rijndael_cbc_decrypt: bad len %d", len);
  }
#line 354
  memcpy((void * __restrict  )(ivsaved), (void const   * __restrict  )cnow, 16U);
#line 355
  i = blocks;
#line 355
  while (i > 0) {
#line 356
    rijndael_decrypt(ctx, (u4byte const   *)cnow, plain);
#line 357
    if (i == 1) {
#line 357
      ivp = iv;
    } else {
#line 357
      ivp = cnow - 4;
    }
#line 358
    *(plain + 0) ^= *(ivp + 0);
#line 359
    *(plain + 1) ^= *(ivp + 1);
#line 360
    *(plain + 2) ^= *(ivp + 2);
#line 361
    *(plain + 3) ^= *(ivp + 3);
#line 355
    i --;
#line 355
    cnow -= 4;
#line 355
    plain -= 4;
  }
#line 363
  memcpy((void * __restrict  )iv, (void const   * __restrict  )(ivsaved), 16U);
#line 364
  return;
}
}
#line 366 "cipher.c"
Cipher ciphers[16]  = 
#line 366
  {      {(char *)"none", 0, (u_int )8, (u_int )0, & none_setkey, & none_setiv, & none_crypt,
      & none_crypt}, 
        {(char *)"des", 2, (u_int )8, (u_int )8, & des_ssh1_setkey, & des_ssh1_setiv,
      & des_ssh1_encrypt, & des_ssh1_decrypt}, 
        {(char *)"3des", 3, (u_int )8, (u_int )16, & des3_ssh1_setkey, & des3_setiv,
      & des3_ssh1_encrypt, & des3_ssh1_decrypt}, 
        {(char *)"blowfish", 6, (u_int )8, (u_int )16, & blowfish_setkey, & blowfish_setiv,
      & blowfish_ssh1_encrypt, & blowfish_ssh1_decrypt}, 
        {(char *)"3des-cbc", -3, (u_int )8, (u_int )24, & des3_setkey, & des3_setiv,
      & des3_cbc_encrypt, & des3_cbc_decrypt}, 
        {(char *)"blowfish-cbc", -3, (u_int )8, (u_int )16, & blowfish_setkey, & blowfish_setiv,
      & blowfish_cbc_encrypt, & blowfish_cbc_decrypt}, 
        {(char *)"cast128-cbc", -3, (u_int )8, (u_int )16, & cast_setkey, & cast_setiv,
      & cast_cbc_encrypt, & cast_cbc_decrypt}, 
        {(char *)"arcfour", -3, (u_int )8, (u_int )16, & arcfour_setkey, & none_setiv,
      & arcfour_crypt, & arcfour_crypt}, 
        {(char *)"aes128-cbc", -3, (u_int )16, (u_int )16, & rijndael_setkey, & rijndael_setiv,
      & rijndael_cbc_encrypt, & rijndael_cbc_decrypt}, 
        {(char *)"aes192-cbc", -3, (u_int )16, (u_int )24, & rijndael_setkey, & rijndael_setiv,
      & rijndael_cbc_encrypt, & rijndael_cbc_decrypt}, 
        {(char *)"aes256-cbc", -3, (u_int )16, (u_int )32, & rijndael_setkey, & rijndael_setiv,
      & rijndael_cbc_encrypt, & rijndael_cbc_decrypt}, 
        {(char *)"rijndael128-cbc", -3, (u_int )16, (u_int )16, & rijndael_setkey, & rijndael_setiv,
      & rijndael_cbc_encrypt, & rijndael_cbc_decrypt}, 
        {(char *)"rijndael192-cbc", -3, (u_int )16, (u_int )24, & rijndael_setkey, & rijndael_setiv,
      & rijndael_cbc_encrypt, & rijndael_cbc_decrypt}, 
        {(char *)"rijndael256-cbc", -3, (u_int )16, (u_int )32, & rijndael_setkey, & rijndael_setiv,
      & rijndael_cbc_encrypt, & rijndael_cbc_decrypt}, 
        {(char *)"rijndael-cbc@lysator.liu.se", -3, (u_int )16, (u_int )32, & rijndael_setkey,
      & rijndael_setiv, & rijndael_cbc_encrypt, & rijndael_cbc_decrypt}, 
        {(char *)((void *)0), -2, (u_int )0, (u_int )0, (void (*)(CipherContext * , u_char const   * ,
                                                               u_int  ))((void *)0),
      (void (*)(CipherContext * , u_char const   * , u_int  ))((void *)0), (void (*)(CipherContext * ,
                                                                                     u_char * ,
                                                                                     u_char const   * ,
                                                                                     u_int  ))((void *)0),
      (void (*)(CipherContext * , u_char * , u_char const   * , u_int  ))((void *)0)}};
#line 433 "cipher.c"
unsigned int cipher_mask_ssh1(int client ) 
{ unsigned int mask ;

  {
#line 436
  mask = 0U;
#line 437
  mask |= (unsigned int )(1 << 3);
#line 438
  mask |= (unsigned int )(1 << 6);
#line 439
  if (client) {
#line 440
    mask |= (unsigned int )(1 << 2);
  }
#line 442
  return (mask);
}
}
#line 445 "cipher.c"
Cipher *cipher_by_name(char const   *name ) 
{ Cipher *c ;
  int tmp ;

  {
#line 449
  c = ciphers;
#line 449
  while ((unsigned int )c->name != (unsigned int )((void *)0)) {
#line 450
    tmp = strcasecmp((char const   *)c->name, name);
#line 450
    if (tmp == 0) {
#line 451
      return (c);
    }
#line 449
    c ++;
  }
#line 452
  return ((Cipher *)((void *)0));
}
}
#line 455 "cipher.c"
Cipher *cipher_by_number(int id ) 
{ Cipher *c ;

  {
#line 459
  c = ciphers;
#line 459
  while ((unsigned int )c->name != (unsigned int )((void *)0)) {
#line 460
    if (c->number == id) {
#line 461
      return (c);
    }
#line 459
    c ++;
  }
#line 462
  return ((Cipher *)((void *)0));
}
}
#line 466 "cipher.c"
int ciphers_valid(char const   *names ) 
{ Cipher *c ;
  char *ciphers___0 ;
  char *cp ;
  char *p ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___24 ;
  char *tmp___40 ;

  {
#line 473
  if ((unsigned int )names == (unsigned int )((void *)0)) {
#line 474
    return (0);
  } else {
#line 473
    if (0) {
#line 473
      __s1_len = strlen(names);
#line 473
      __s2_len = strlen("");
#line 473
      if (! ((unsigned int )((void const   *)(names + 1)) - (unsigned int )((void const   *)names) == 1U)) {
        goto _L___0;
      } else {
#line 473
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 473
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 473
            tmp___8 = 1;
          } else {
#line 473
            if (__s2_len >= 4U) {
#line 473
              tmp___8 = 1;
            } else {
#line 473
              tmp___8 = 0;
            }
          }
        } else {
#line 473
          tmp___8 = 0;
        }
      }
#line 473
      if (tmp___8) {
#line 473
        tmp___4 = __builtin_strcmp(names, "");
      } else {
#line 473
        tmp___7 = __builtin_strcmp(names, "");
#line 473
        tmp___4 = tmp___7;
      }
    } else {
#line 473
      tmp___7 = __builtin_strcmp(names, "");
#line 473
      tmp___4 = tmp___7;
    }
#line 473
    if (tmp___4 == 0) {
#line 474
      return (0);
    }
  }
#line 475
  cp = xstrdup(names);
#line 475
  ciphers___0 = cp;
#line 476
  tmp___24 = __strsep_g(& cp, ",");
#line 476
  p = tmp___24;
#line 476
  while (1) {
#line 476
    if (p) {
#line 476
      if (! ((int )*p != 0)) {
#line 476
        break;
      }
    } else {
#line 476
      break;
    }
#line 478
    c = cipher_by_name((char const   *)p);
#line 479
    if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 480
      debug("bad cipher %s [%s]", p, names);
#line 481
      xfree((void *)ciphers___0);
#line 482
      return (0);
    } else {
#line 479
      if (c->number != -3) {
#line 480
        debug("bad cipher %s [%s]", p, names);
#line 481
        xfree((void *)ciphers___0);
#line 482
        return (0);
      } else {
#line 484
        debug3("cipher ok: %s [%s]", p, names);
      }
    }
#line 477
    tmp___40 = __strsep_g(& cp, ",");
#line 477
    p = tmp___40;
  }
#line 487
  debug3("ciphers ok: [%s]", names);
#line 488
  xfree((void *)ciphers___0);
#line 489
  return (1);
}
}
#line 497 "cipher.c"
int cipher_number(char const   *name ) 
{ Cipher *c ;
  int tmp ;

  {
#line 501
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 502
    return (-1);
  }
#line 503
  c = cipher_by_name(name);
#line 504
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 504
    tmp = -1;
  } else {
#line 504
    tmp = c->number;
  }
#line 504
  return (tmp);
}
}
#line 507 "cipher.c"
char *cipher_name(int id ) 
{ Cipher *c ;
  Cipher *tmp ;
  char const   *tmp___0 ;

  {
#line 510
  tmp = cipher_by_number(id);
#line 510
  c = tmp;
#line 511
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 511
    tmp___0 = "<unknown>";
  } else {
#line 511
    tmp___0 = (char const   *)c->name;
  }
#line 511
  return ((char *)tmp___0);
}
}
#line 514 "cipher.c"
void cipher_init(CipherContext *cc , Cipher *cipher , u_char const   *key , u_int keylen ,
                 u_char const   *iv , u_int ivlen ) 
{ 

  {
#line 518
  if (keylen < cipher->key_len) {
#line 519
    fatal("cipher_init: key length %d is insufficient for %s.", keylen, cipher->name);
  }
#line 521
  if ((unsigned int )iv != (unsigned int )((void *)0)) {
#line 521
    if (ivlen < cipher->block_size) {
#line 522
      fatal("cipher_init: iv length %d is insufficient for %s.", ivlen, cipher->name);
    }
  }
#line 524
  cc->cipher = cipher;
#line 525
  (*(cipher->setkey))(cc, key, keylen);
#line 526
  (*(cipher->setiv))(cc, iv, ivlen);
#line 527
  return;
}
}
#line 529 "cipher.c"
void cipher_encrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 532
  if (len % (cc->cipher)->block_size) {
#line 533
    fatal("cipher_encrypt: bad plaintext length %d", len);
  }
#line 534
  (*((cc->cipher)->encrypt))(cc, dest, src, len);
#line 535
  return;
}
}
#line 537 "cipher.c"
void cipher_decrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 540
  if (len % (cc->cipher)->block_size) {
#line 541
    fatal("cipher_decrypt: bad ciphertext length %d", len);
  }
#line 542
  (*((cc->cipher)->decrypt))(cc, dest, src, len);
#line 543
  return;
}
}
#line 550 "cipher.c"
void cipher_set_key_string(CipherContext *cc , Cipher *cipher , char const   *passphrase ) 
{ MD5_CTX md ;
  unsigned char digest___1[16] ;
  size_t tmp ;

  {
#line 557
  MD5_Init(& md);
#line 558
  tmp = strlen(passphrase);
#line 558
  MD5_Update(& md, (void const   *)((u_char const   *)passphrase), tmp);
#line 559
  MD5_Final(digest___1, & md);
#line 561
  cipher_init(cc, cipher, (u_char const   *)(digest___1), 16U, (u_char const   *)((void *)0),
              0U);
#line 563
  memset((void *)(digest___1), 0, sizeof(digest___1));
#line 564
  memset((void *)(& md), 0, sizeof(md));
#line 565
  return;
}
}
#line 1 "cli.o"
#line 67 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 71
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
#line 117 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 216
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
#line 222
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo )  __attribute__((__nonnull__(1))) ;
#line 249
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
#line 257
extern int sigsuspend(sigset_t const   *__set )  __attribute__((__nonnull__(1))) ;
#line 260
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 143 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 218
extern int fflush(FILE *__stream ) ;
#line 29 "bsd-vis.h"
char *vis(char *dst , int c , int flag , int nextc ) ;
#line 7 "cli.c"
static int cli_input  =    -1;
#line 8 "cli.c"
static int cli_output  =    -1;
#line 9 "cli.c"
static int cli_from_stdin  =    0;
#line 11 "cli.c"
sigset_t oset  ;
#line 12 "cli.c"
sigset_t nset  ;
#line 13 "cli.c"
struct sigaction nsa  ;
#line 14 "cli.c"
struct sigaction osa  ;
#line 15 "cli.c"
struct termios ntio  ;
#line 16 "cli.c"
struct termios otio  ;
#line 17 "cli.c"
int echo_modified  ;
#line 19 "cli.c"
int volatile   intr  ;
#line 21 "cli.c"
static int cli_open(int from_stdin ) 
{ int tmp ;

  {
#line 24
  if (cli_input >= 0) {
#line 24
    if (cli_output >= 0) {
#line 24
      if (cli_from_stdin == from_stdin) {
#line 25
        return (1);
      }
    }
  }
#line 27
  if (from_stdin) {
#line 28
    if (! cli_from_stdin) {
#line 28
      if (cli_input >= 0) {
#line 29
        close(cli_input);
      }
    }
#line 31
    cli_input = 0;
#line 32
    cli_output = 2;
  } else {
#line 34
    cli_output = open("/dev/tty", 2);
#line 34
    cli_input = cli_output;
#line 35
    if (cli_input < 0) {
#line 36
      fatal("You have no controlling tty.  Cannot read passphrase.");
    }
  }
#line 39
  cli_from_stdin = from_stdin;
#line 41
  if (cli_input >= 0) {
#line 41
    if (cli_output >= 0) {
#line 41
      if (cli_from_stdin == from_stdin) {
#line 41
        tmp = 1;
      } else {
#line 41
        tmp = 0;
      }
    } else {
#line 41
      tmp = 0;
    }
  } else {
#line 41
    tmp = 0;
  }
#line 41
  return (tmp);
}
}
#line 44 "cli.c"
static void cli_close(void) 
{ 

  {
#line 47
  if (! cli_from_stdin) {
#line 47
    if (cli_input >= 0) {
#line 48
      close(cli_input);
    }
  }
#line 49
  cli_input = -1;
#line 50
  cli_output = -1;
#line 51
  cli_from_stdin = 0;
#line 52
  return;
}
}
#line 55 "cli.c"
void intrcatch(void) 
{ 

  {
#line 58
  intr = (int volatile   )1;
#line 59
  return;
}
}
#line 61 "cli.c"
static void cli_echo_disable(void) 
{ int tmp ;

  {
#line 64
  sigemptyset(& nset);
#line 65
  sigaddset(& nset, 20);
#line 66
  sigprocmask(0, (sigset_t const   * __restrict  )(& nset), (sigset_t * __restrict  )(& oset));
#line 68
  intr = (int volatile   )0;
#line 70
  memset((void *)(& nsa), 0, sizeof(nsa));
#line 71
  nsa.__sigaction_handler.sa_handler = (void (*)(int  ))(& intrcatch);
#line 72
  sigaction(2, (struct sigaction  const  * __restrict  )(& nsa), (struct sigaction * __restrict  )(& osa));
#line 74
  echo_modified = 0;
#line 75
  tmp = tcgetattr(cli_input, & otio);
#line 75
  if (tmp == 0) {
#line 75
    if (otio.c_lflag & 8U) {
#line 76
      echo_modified = 1;
#line 77
      ntio = otio;
#line 78
      ntio.c_lflag &= 4294967175U;
#line 79
      tcsetattr(cli_input, 0, (struct termios  const  *)(& ntio));
    }
  }
#line 81
  return;
}
}
#line 84 "cli.c"
static void cli_echo_restore(void) 
{ __pid_t tmp ;

  {
#line 87
  if (echo_modified != 0) {
#line 88
    tcsetattr(cli_input, 0, (struct termios  const  *)(& otio));
#line 89
    echo_modified = 0;
  }
#line 92
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((void *)0));
#line 93
  sigaction(2, (struct sigaction  const  * __restrict  )(& osa), (struct sigaction * __restrict  )((void *)0));
#line 95
  if (intr != (int volatile   )0) {
#line 96
    tmp = getpid();
#line 96
    kill(tmp, 2);
#line 97
    sigemptyset(& nset);
#line 99
    sigsuspend((sigset_t const   *)(& nset));
#line 100
    intr = (int volatile   )0;
  }
#line 102
  return;
}
}
#line 105 "cli.c"
static int cli_read(char *buf___1 , int size , int echo ) 
{ char ch ;
  int i ;
  ssize_t tmp ;
  int tmp___0 ;

  {
#line 108
  ch = (char)0;
#line 109
  i = 0;
#line 111
  if (! echo) {
#line 112
    cli_echo_disable();
  }
#line 114
  while ((int )ch != 10) {
#line 115
    tmp = read(cli_input, (void *)(& ch), 1U);
#line 115
    if (tmp != 1) {
#line 116
      break;
    }
#line 117
    if ((int )ch == 10) {
#line 118
      break;
    } else {
#line 117
      if (intr != (int volatile   )0) {
#line 118
        break;
      }
    }
#line 119
    if (i < size) {
#line 120
      tmp___0 = i;
#line 120
      i ++;
#line 120
      *(buf___1 + tmp___0) = ch;
    }
  }
#line 122
  *(buf___1 + i) = (char )'\000';
#line 124
  if (! echo) {
#line 125
    cli_echo_restore();
  }
#line 126
  if (! intr) {
#line 126
    if (! echo) {
#line 127
      write(cli_output, (void const   *)"\n", 1U);
    }
  }
#line 128
  return (i);
}
}
#line 131 "cli.c"
static int cli_write(char *buf___1 , int size ) 
{ int i ;
  int len ;
  int pos ;
  int ret ;
  char *output___0 ;
  char *p ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 134
  ret = 0;
#line 137
  tmp = xmalloc((unsigned int )(4 * size));
#line 137
  output___0 = (char *)tmp;
#line 138
  p = output___0;
#line 138
  i = 0;
#line 138
  while (i < size) {
#line 139
    if ((int )*(buf___1 + i) == 10) {
#line 140
      tmp___0 = p;
#line 140
      p ++;
#line 140
      *tmp___0 = *(buf___1 + i);
    } else {
#line 142
      p = vis(p, (int )*(buf___1 + i), 0, 0);
    }
#line 138
    i ++;
  }
#line 144
  len = p - output___0;
#line 146
  pos = 0;
#line 146
  while (pos < len) {
#line 147
    ret = write(cli_output, (void const   *)(output___0 + pos), (unsigned int )(len - pos));
#line 148
    if (ret == -1) {
#line 149
      return (-1);
    }
#line 146
    pos += ret;
  }
#line 151
  return (0);
}
}
#line 160 "cli.c"
char *cli_read_passphrase(char *prompt , int from_stdin , int echo_enable ) 
{ char buf___1[8192] ;
  char *p ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 166
  tmp = cli_open(from_stdin);
#line 166
  if (! tmp) {
#line 167
    fatal("Cannot read passphrase.");
  }
#line 169
  fflush(stdout);
#line 171
  tmp___0 = strlen((char const   *)prompt);
#line 171
  cli_write(prompt, (int )tmp___0);
#line 172
  cli_read(buf___1, (int )sizeof(buf___1), echo_enable);
#line 174
  cli_close();
#line 176
  p = xstrdup((char const   *)(buf___1));
#line 177
  memset((void *)(buf___1), 0, sizeof(buf___1));
#line 178
  return (p);
}
}
#line 181 "cli.c"
char *cli_prompt(char *prompt , int echo_enable ) 
{ char *tmp ;

  {
#line 184
  tmp = cli_read_passphrase(prompt, 0, echo_enable);
#line 184
  return (tmp);
}
}
#line 187 "cli.c"
void cli_mesg(char *mesg ) 
{ size_t tmp ;
  size_t tmp___0 ;

  {
#line 190
  cli_open(0);
#line 191
  tmp = strlen((char const   *)mesg);
#line 191
  cli_write(mesg, (int )tmp);
#line 192
  tmp___0 = strlen("\n");
#line 192
  cli_write((char *)"\n", (int )tmp___0);
#line 193
  cli_close();
#line 194
  return;
}
}
#line 1 "compat.o"
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 40 "compat.h"
void enable_compat13(void) ;
#line 41
void enable_compat20(void) ;
#line 42
void compat_datafellows(char const   *version ) ;
#line 43
int proto_spec(char const   *spec ) ;
#line 537 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 541
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 546
extern size_t regerror(int __errcode , regex_t const   * __restrict  __preg , char * __restrict  __errbuf ,
                       size_t __errbuf_size ) ;
#line 549
extern void regfree(regex_t *__preg ) ;
#line 38 "compat.c"
int compat13  =    0;
#line 39 "compat.c"
int compat20  =    0;
#line 40 "compat.c"
int datafellows  =    0;
#line 42 "compat.c"
void enable_compat20(void) 
{ 

  {
#line 45
  verbose("Enabling compatibility mode for protocol 2.0");
#line 46
  compat20 = 1;
#line 47
  return;
}
}
#line 48 "compat.c"
void enable_compat13(void) 
{ 

  {
#line 51
  verbose("Enabling compatibility mode for protocol 1.3");
#line 52
  compat13 = 1;
#line 53
  return;
}
}
#line 61 "compat.c"
static struct __anonstruct_check_77 check[11]  = 
#line 61
  {      {(char *)"^OpenSSH[-_]2\\.[012]", 16}, 
        {(char *)"MindTerm", 0}, 
        {(char *)"^2\\.1\\.0 ", 21}, 
        {(char *)"^2\\.0\\.", 31}, 
        {(char *)"^2\\.[23]\\.0 ", 4}, 
        {(char *)"^2\\.[2-9]\\.", 0}, 
        {(char *)"^2\\.4$", 16}, 
        {(char *)"^3\\.0 SecureCRT", 16}, 
        {(char *)"^1\\.7 SecureFX", 16}, 
        {(char *)"^2\\.", 4}, 
        {(char *)((void *)0), 0}};
#line 55 "compat.c"
void compat_datafellows(char const   *version ) 
{ int i ;
  int ret ;
  char ebuf[1024] ;
  regex_t reg ;

  {
#line 81
  i = 0;
#line 81
  while (check[i].pat) {
#line 82
    ret = regcomp((regex_t * __restrict  )(& reg), (char const   * __restrict  )check[i].pat,
                  1 | (((1 << 1) << 1) << 1));
#line 83
    if (ret != 0) {
#line 84
      regerror(ret, (regex_t const   * __restrict  )(& reg), (char * __restrict  )(ebuf),
               sizeof(ebuf));
#line 85
      ebuf[sizeof(ebuf) - 1U] = (char )'\000';
#line 86
      error("regerror: %s", ebuf);
      goto __Cont;
    }
#line 89
    ret = regexec((regex_t const   * __restrict  )(& reg), (char const   * __restrict  )version,
                  0U, (regmatch_t * __restrict  )((void *)0), 0);
#line 90
    regfree(& reg);
#line 91
    if (ret == 0) {
#line 92
      debug("match: %s pat %s\n", version, check[i].pat);
#line 93
      datafellows = check[i].bugs;
#line 94
      return;
    }
    __Cont: /* CIL Label */ 
#line 81
    i ++;
  }
#line 97
  debug("no match: %s", version);
#line 98
  return;
}
}
#line 101 "compat.c"
int proto_spec(char const   *spec ) 
{ char *s ;
  char *p ;
  char *q ;
  int ret ;
  char *tmp___14 ;
  char *tmp___30 ;
  int tmp___31 ;

  {
#line 105
  ret = 0;
#line 107
  if ((unsigned int )spec == (unsigned int )((void *)0)) {
#line 108
    return (ret);
  }
#line 109
  s = xstrdup(spec);
#line 109
  q = s;
#line 110
  tmp___14 = __strsep_g(& q, ",");
#line 110
  p = tmp___14;
#line 110
  while (1) {
#line 110
    if (p) {
#line 110
      if (! ((int )*p != 0)) {
#line 110
        break;
      }
    } else {
#line 110
      break;
    }
#line 111
    tmp___31 = atoi((char const   *)p);
#line 111
    switch (tmp___31) {
    case 1: 
#line 113
    if (ret == 0) {
#line 114
      ret |= 2;
    }
#line 115
    ret |= 1;
#line 116
    break;
    case 2: 
#line 118
    ret |= 4;
#line 119
    break;
    default: 
#line 121
    log("ignoring bad proto spec: \'%s\'.", p);
#line 122
    break;
    }
#line 110
    tmp___30 = __strsep_g(& q, ",");
#line 110
    p = tmp___30;
  }
#line 125
  xfree((void *)s);
#line 126
  return (ret);
}
}
#line 1 "compress.o"
#line 242 "/usr/include/zlib.h"
extern int deflate(z_streamp strm , int flush ) ;
#line 328
extern int deflateEnd(z_streamp strm ) ;
#line 363
extern int inflate(z_streamp strm , int flush ) ;
#line 462
extern int inflateEnd(z_streamp strm ) ;
#line 1317
extern int deflateInit_(z_streamp strm , int level , char const   *version , int stream_size ) ;
#line 1319
extern int inflateInit_(z_streamp strm , char const   *version , int stream_size ) ;
#line 21 "compress.c"
static z_stream incoming_stream  ;
#line 22 "compress.c"
static z_stream outgoing_stream  ;
#line 29 "compress.c"
void buffer_compress_init(int level ) 
{ 

  {
#line 32
  debug("Enabling compression at level %d.", level);
#line 33
  if (level < 1) {
#line 34
    fatal("Bad compression level %d.", level);
  } else {
#line 33
    if (level > 9) {
#line 34
      fatal("Bad compression level %d.", level);
    }
  }
#line 35
  inflateInit_(& incoming_stream, "1.2.3", (int )sizeof(z_stream ));
#line 36
  deflateInit_(& outgoing_stream, level, "1.2.3", (int )sizeof(z_stream ));
#line 37
  return;
}
}
#line 41 "compress.c"
void buffer_compress_uninit(void) 
{ double tmp ;
  double tmp___0 ;

  {
#line 44
  if (outgoing_stream.total_in == 0UL) {
#line 44
    tmp = 0.0;
  } else {
#line 44
    tmp = (double )outgoing_stream.total_out / (double )outgoing_stream.total_in;
  }
#line 44
  debug("compress outgoing: raw data %lu, compressed %lu, factor %.2f", outgoing_stream.total_in,
        outgoing_stream.total_out, tmp);
#line 48
  if (incoming_stream.total_out == 0UL) {
#line 48
    tmp___0 = 0.0;
  } else {
#line 48
    tmp___0 = (double )incoming_stream.total_in / (double )incoming_stream.total_out;
  }
#line 48
  debug("compress incoming: raw data %lu, compressed %lu, factor %.2f", incoming_stream.total_out,
        incoming_stream.total_in, tmp___0);
#line 52
  inflateEnd(& incoming_stream);
#line 53
  deflateEnd(& outgoing_stream);
#line 54
  return;
}
}
#line 65 "compress.c"
void buffer_compress(Buffer *input_buffer , Buffer *output_buffer ) 
{ char buf___1[4096] ;
  int status ;
  unsigned int tmp ;
  char *tmp___0 ;

  {
#line 72
  tmp = buffer_len(input_buffer);
#line 72
  if (tmp == 0U) {
#line 73
    return;
  }
#line 76
  tmp___0 = buffer_ptr(input_buffer);
#line 76
  outgoing_stream.next_in = (unsigned char *)tmp___0;
#line 77
  outgoing_stream.avail_in = buffer_len(input_buffer);
#line 80
  while (1) {
#line 82
    outgoing_stream.next_out = (unsigned char *)(buf___1);
#line 83
    outgoing_stream.avail_out = sizeof(buf___1);
#line 86
    status = deflate(& outgoing_stream, 1);
#line 87
    switch (status) {
    case 0: 
#line 90
    buffer_append(output_buffer, (char const   *)(buf___1), sizeof(buf___1) - outgoing_stream.avail_out);
#line 92
    break;
    default: 
#line 94
    fatal("buffer_compress: deflate returned %d", status);
    }
#line 80
    if (! (outgoing_stream.avail_out == 0U)) {
#line 80
      break;
    }
  }
#line 98
  return;
}
}
#line 109 "compress.c"
void buffer_uncompress(Buffer *input_buffer , Buffer *output_buffer ) 
{ char buf___1[4096] ;
  int status ;
  char *tmp ;

  {
#line 115
  tmp = buffer_ptr(input_buffer);
#line 115
  incoming_stream.next_in = (unsigned char *)tmp;
#line 116
  incoming_stream.avail_in = buffer_len(input_buffer);
#line 118
  while (1) {
#line 120
    incoming_stream.next_out = (unsigned char *)(buf___1);
#line 121
    incoming_stream.avail_out = sizeof(buf___1);
#line 123
    status = inflate(& incoming_stream, 1);
#line 124
    switch (status) {
    case 0: 
#line 126
    buffer_append(output_buffer, (char const   *)(buf___1), sizeof(buf___1) - incoming_stream.avail_out);
#line 128
    break;
    case -5: 
#line 135
    return;
    default: 
#line 137
    fatal("buffer_uncompress: inflate returned %d", status);
    }
  }
}
}
#line 1 "crc32.o"
#line 23 "crc32.h"
unsigned int ssh_crc32(unsigned char const   *s , unsigned int len ) ;
#line 46 "crc32.c"
static unsigned int crc32_tab[256]  = 
#line 46 "crc32.c"
  {      0U,      1996959894U,      3993919788U,      2567524794U, 
        124634137U,      1886057615U,      3915621685U,      2657392035U, 
        249268274U,      2044508324U,      3772115230U,      2547177864U, 
        162941995U,      2125561021U,      3887607047U,      2428444049U, 
        498536548U,      1789927666U,      4089016648U,      2227061214U, 
        450548861U,      1843258603U,      4107580753U,      2211677639U, 
        325883990U,      1684777152U,      4251122042U,      2321926636U, 
        335633487U,      1661365465U,      4195302755U,      2366115317U, 
        997073096U,      1281953886U,      3579855332U,      2724688242U, 
        1006888145U,      1258607687U,      3524101629U,      2768942443U, 
        901097722U,      1119000684U,      3686517206U,      2898065728U, 
        853044451U,      1172266101U,      3705015759U,      2882616665U, 
        651767980U,      1373503546U,      3369554304U,      3218104598U, 
        565507253U,      1454621731U,      3485111705U,      3099436303U, 
        671266974U,      1594198024U,      3322730930U,      2970347812U, 
        795835527U,      1483230225U,      3244367275U,      3060149565U, 
        1994146192U,      31158534U,      2563907772U,      4023717930U, 
        1907459465U,      112637215U,      2680153253U,      3904427059U, 
        2013776290U,      251722036U,      2517215374U,      3775830040U, 
        2137656763U,      141376813U,      2439277719U,      3865271297U, 
        1802195444U,      476864866U,      2238001368U,      4066508878U, 
        1812370925U,      453092731U,      2181625025U,      4111451223U, 
        1706088902U,      314042704U,      2344532202U,      4240017532U, 
        1658658271U,      366619977U,      2362670323U,      4224994405U, 
        1303535960U,      984961486U,      2747007092U,      3569037538U, 
        1256170817U,      1037604311U,      2765210733U,      3554079995U, 
        1131014506U,      879679996U,      2909243462U,      3663771856U, 
        1141124467U,      855842277U,      2852801631U,      3708648649U, 
        1342533948U,      654459306U,      3188396048U,      3373015174U, 
        1466479909U,      544179635U,      3110523913U,      3462522015U, 
        1591671054U,      702138776U,      2966460450U,      3352799412U, 
        1504918807U,      783551873U,      3082640443U,      3233442989U, 
        3988292384U,      2596254646U,      62317068U,      1957810842U, 
        3939845945U,      2647816111U,      81470997U,      1943803523U, 
        3814918930U,      2489596804U,      225274430U,      2053790376U, 
        3826175755U,      2466906013U,      167816743U,      2097651377U, 
        4027552580U,      2265490386U,      503444072U,      1762050814U, 
        4150417245U,      2154129355U,      426522225U,      1852507879U, 
        4275313526U,      2312317920U,      282753626U,      1742555852U, 
        4189708143U,      2394877945U,      397917763U,      1622183637U, 
        3604390888U,      2714866558U,      953729732U,      1340076626U, 
        3518719985U,      2797360999U,      1068828381U,      1219638859U, 
        3624741850U,      2936675148U,      906185462U,      1090812512U, 
        3747672003U,      2825379669U,      829329135U,      1181335161U, 
        3412177804U,      3160834842U,      628085408U,      1382605366U, 
        3423369109U,      3138078467U,      570562233U,      1426400815U, 
        3317316542U,      2998733608U,      733239954U,      1555261956U, 
        3268935591U,      3050360625U,      752459403U,      1541320221U, 
        2607071920U,      3965973030U,      1969922972U,      40735498U, 
        2617837225U,      3943577151U,      1913087877U,      83908371U, 
        2512341634U,      3803740692U,      2075208622U,      213261112U, 
        2463272603U,      3855990285U,      2094854071U,      198958881U, 
        2262029012U,      4057260610U,      1759359992U,      534414190U, 
        2176718541U,      4139329115U,      1873836001U,      414664567U, 
        2282248934U,      4279200368U,      1711684554U,      285281116U, 
        2405801727U,      4167216745U,      1634467795U,      376229701U, 
        2685067896U,      3608007406U,      1308918612U,      956543938U, 
        2808555105U,      3495958263U,      1231636301U,      1047427035U, 
        2932959818U,      3654703836U,      1088359270U,      936918000U, 
        2847714899U,      3736837829U,      1202900863U,      817233897U, 
        3183342108U,      3401237130U,      1404277552U,      615818150U, 
        3134207493U,      3453421203U,      1423857449U,      601450431U, 
        3009837614U,      3294710456U,      1567103746U,      711928724U, 
        3020668471U,      3272380065U,      1510334235U,      755167117U};
#line 103 "crc32.c"
unsigned int ssh_crc32(unsigned char const   *s , unsigned int len ) 
{ unsigned int i ;
  unsigned int crc32val ;

  {
#line 109
  crc32val = 0U;
#line 110
  i = 0U;
#line 110
  while (i < len) {
#line 111
    crc32val = crc32_tab[(crc32val ^ (unsigned int )*(s + i)) & 255U] ^ (crc32val >> 8);
#line 110
    i ++;
  }
#line 113
  return (crc32val);
}
}
#line 1 "cygwin_util.o"
#line 1 "deattack.o"
#line 27 "deattack.h"
int detect_attack(unsigned char *buf___1 , u_int32_t len , unsigned char *IV ) ;
#line 50 "deattack.c"
void crc_update(u_int32_t *a , u_int32_t b ) 
{ 

  {
#line 53
  b ^= *a;
#line 54
  *a = ssh_crc32((unsigned char const   *)((unsigned char *)(& b)), sizeof(b));
#line 55
  return;
}
}
#line 58 "deattack.c"
int check_crc(unsigned char *S , unsigned char *buf___1 , u_int32_t len , unsigned char *IV ) 
{ u_int32_t crc ;
  unsigned char *c ;
  int tmp ;
  int tmp___0 ;

  {
#line 65
  crc = 0U;
#line 66
  if (IV) {
#line 66
    tmp = memcmp((void const   *)S, (void const   *)IV, 8U);
#line 66
    if (! tmp) {
#line 67
      crc_update(& crc, 1U);
#line 68
      crc_update(& crc, 0U);
    }
  }
#line 70
  c = buf___1;
#line 70
  while ((unsigned int )c < (unsigned int )(buf___1 + len)) {
#line 71
    tmp___0 = memcmp((void const   *)S, (void const   *)c, 8U);
#line 71
    if (tmp___0) {
#line 75
      crc_update(& crc, 0U);
#line 76
      crc_update(& crc, 0U);
    } else {
#line 72
      crc_update(& crc, 1U);
#line 73
      crc_update(& crc, 0U);
    }
#line 70
    c += 8;
  }
#line 79
  return (crc == 0U);
}
}
#line 87 "deattack.c"
static u_int16_t *h  =    (u_int16_t *)((void *)0);
#line 88 "deattack.c"
static u_int32_t n  =    (u_int32_t )4096;
#line 84 "deattack.c"
int detect_attack(unsigned char *buf___1 , u_int32_t len , unsigned char *IV ) 
{ register u_int32_t i ;
  register u_int32_t j ;
  u_int32_t l ;
  register unsigned char *c ;
  unsigned char *d ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 94
  if (len > 262144U) {
#line 96
    fatal("detect_attack: bad length %d", len);
  } else {
#line 94
    if (len % 8U != 0U) {
#line 96
      fatal("detect_attack: bad length %d", len);
    }
  }
#line 98
  l = n;
#line 98
  while (l < ((len / 8U) * 3U) / 2U) {
#line 98
    l <<= 2;
  }
#line 101
  if ((unsigned int )h == (unsigned int )((void *)0)) {
#line 102
    debug("Installing crc compensation attack detector.");
#line 103
    n = l;
#line 104
    tmp = xmalloc(n * 2U);
#line 104
    h = (u_int16_t *)tmp;
  } else {
#line 106
    if (l > n) {
#line 107
      n = l;
#line 108
      tmp___0 = xrealloc((void *)h, n * 2U);
#line 108
      h = (u_int16_t *)tmp___0;
    }
  }
#line 112
  if (len <= 56U) {
#line 113
    c = buf___1;
#line 113
    while ((unsigned int )c < (unsigned int )(buf___1 + len)) {
#line 114
      if (IV) {
#line 114
        tmp___2 = memcmp((void const   *)c, (void const   *)IV, 8U);
#line 114
        if (! tmp___2) {
#line 115
          tmp___1 = check_crc(c, buf___1, len, (unsigned char *)IV);
#line 115
          if (tmp___1) {
#line 116
            return (1);
          } else {
#line 118
            break;
          }
        }
      }
#line 120
      d = buf___1;
#line 120
      while ((unsigned int )d < (unsigned int )c) {
#line 121
        tmp___4 = memcmp((void const   *)c, (void const   *)d, 8U);
#line 121
        if (! tmp___4) {
#line 122
          tmp___3 = check_crc(c, buf___1, len, (unsigned char *)IV);
#line 122
          if (tmp___3) {
#line 123
            return (1);
          } else {
#line 125
            break;
          }
        }
#line 120
        d += 8;
      }
#line 113
      c += 8;
    }
#line 129
    return (0);
  }
#line 131
  memset((void *)h, 255, n * 2U);
#line 133
  if (IV) {
#line 134
    *(h + ((((((unsigned long )*(IV + 0) << 24) | ((unsigned long )*(IV + 1) << 16)) | ((unsigned long )*(IV + 2) << 8)) | (unsigned long )*(IV + 3)) & (unsigned long )(n - 1U))) = (unsigned short)65534;
  }
#line 136
  c = buf___1;
#line 136
  j = 0U;
#line 136
  while ((unsigned int )c < (unsigned int )(buf___1 + len)) {
#line 137
    i = (unsigned int )((((((unsigned long )*(c + 0) << 24) | ((unsigned long )*(c + 1) << 16)) | ((unsigned long )*(c + 2) << 8)) | (unsigned long )*(c + 3)) & (unsigned long )(n - 1U));
#line 137
    while ((int )*(h + i) != 65535) {
#line 139
      if ((int )*(h + i) == 65534) {
#line 140
        tmp___6 = memcmp((void const   *)c, (void const   *)IV, 8U);
#line 140
        if (! tmp___6) {
#line 141
          tmp___5 = check_crc(c, buf___1, len, (unsigned char *)IV);
#line 141
          if (tmp___5) {
#line 142
            return (1);
          } else {
#line 144
            break;
          }
        }
      } else {
#line 146
        tmp___8 = memcmp((void const   *)c, (void const   *)(buf___1 + (int )*(h + i) * 8),
                         8U);
#line 146
        if (! tmp___8) {
#line 147
          tmp___7 = check_crc(c, buf___1, len, (unsigned char *)IV);
#line 147
          if (tmp___7) {
#line 148
            return (1);
          } else {
#line 150
            break;
          }
        }
      }
#line 137
      i = (i + 1U) & (n - 1U);
    }
#line 153
    *(h + i) = (unsigned short )j;
#line 136
    c += 8;
#line 136
    j ++;
  }
#line 155
  return (0);
}
}
#line 1 "dispatch.o"
#line 31 "dispatch.h"
void dispatch_init(dispatch_fn *dflt ) ;
#line 32
void dispatch_set(int type , dispatch_fn *fn ) ;
#line 33
void dispatch_run(int mode , int *done , void *ctxt ) ;
#line 34
void dispatch_protocol_error(int type , int plen , void *ctxt ) ;
#line 98 "packet.h"
int packet_read(int *payload_len_ptr ) ;
#line 114
int packet_read_poll(int *payload_len_ptr ) ;
#line 33 "dispatch.c"
dispatch_fn *dispatch[255]  ;
#line 35 "dispatch.c"
void dispatch_protocol_error(int type , int plen , void *ctxt ) 
{ 

  {
#line 38
  error("Hm, dispatch protocol error: type %d plen %d", type, plen);
#line 39
  return;
}
}
#line 40 "dispatch.c"
void dispatch_init(dispatch_fn *dflt ) 
{ int i ;

  {
#line 44
  i = 0;
#line 44
  while (i < 255) {
#line 45
    dispatch[i] = dflt;
#line 44
    i ++;
  }
#line 46
  return;
}
}
#line 47 "dispatch.c"
void dispatch_set(int type , dispatch_fn *fn ) 
{ 

  {
#line 50
  dispatch[type] = fn;
#line 51
  return;
}
}
#line 52 "dispatch.c"
void dispatch_run(int mode , int *done , void *ctxt ) 
{ int plen ;
  int type ;

  {
#line 55
  while (1) {
#line 59
    if (mode == 0) {
#line 60
      type = packet_read(& plen);
    } else {
#line 62
      type = packet_read_poll(& plen);
#line 63
      if (type == 0) {
#line 64
        return;
      }
    }
#line 66
    if (type > 0) {
#line 66
      if (type < 255) {
#line 66
        if ((unsigned int )dispatch[type] != (unsigned int )((void *)0)) {
#line 67
          (*(dispatch[type]))(type, plen, ctxt);
        } else {
#line 69
          packet_disconnect("protocol error: rcvd type %d", type);
        }
      } else {
#line 69
        packet_disconnect("protocol error: rcvd type %d", type);
      }
    } else {
#line 69
      packet_disconnect("protocol error: rcvd type %d", type);
    }
#line 70
    if ((unsigned int )done != (unsigned int )((void *)0)) {
#line 70
      if (*done) {
#line 71
        return;
      }
    }
  }
}
}
#line 1 "dsa.o"
#line 175 "/usr/include/openssl/dsa.h"
extern DSA_SIG *DSA_SIG_new(void) ;
#line 176
extern void DSA_SIG_free(DSA_SIG *a ) ;
#line 180
extern DSA_SIG *DSA_do_sign(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
#line 181
extern int DSA_do_verify(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                         DSA *dsa ) ;
#line 213
extern DSA *DSA_generate_parameters(int bits , unsigned char *seed , int seed_len ,
                                    int *counter_ret , unsigned long *h_ret , void (*callback)(int  ,
                                                                                               int  ,
                                                                                               void * ) ,
                                    void *cb_arg ) ;
#line 224
extern int DSA_generate_key(DSA *a ) ;
#line 491 "/usr/include/openssl/evp.h"
extern int EVP_DigestUpdate(EVP_MD_CTX *ctx , void const   *d , size_t cnt ) ;
#line 498
extern int EVP_DigestInit(EVP_MD_CTX *ctx , EVP_MD const   *type ) ;
#line 499
extern int EVP_DigestFinal(EVP_MD_CTX *ctx , unsigned char *md , unsigned int *s ) ;
#line 597
extern EVP_MD const   *EVP_sha1(void) ;
#line 50 "dsa.c"
Key *dsa_key_from_blob(char *blob , int blen ) 
{ Buffer b ;
  char *ktype ;
  int rlen ;
  DSA *dsa ;
  Key *key ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 63
  buffer_init(& b);
#line 64
  buffer_append(& b, (char const   *)blob, (unsigned int )blen);
#line 65
  ktype = buffer_get_string(& b, (unsigned int *)((void *)0));
#line 66
  if (0) {
#line 66
    __s1_len = strlen("ssh-dss");
#line 66
    __s2_len = strlen((char const   *)ktype);
#line 66
    if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
      goto _L___0;
    } else {
#line 66
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 66
        if (! ((unsigned int )((void const   *)(ktype + 1)) - (unsigned int )((void const   *)ktype) == 1U)) {
#line 66
          tmp___8 = 1;
        } else {
#line 66
          if (__s2_len >= 4U) {
#line 66
            tmp___8 = 1;
          } else {
#line 66
            tmp___8 = 0;
          }
        }
      } else {
#line 66
        tmp___8 = 0;
      }
    }
#line 66
    if (tmp___8) {
#line 66
      tmp___4 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
    } else {
#line 66
      tmp___7 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
#line 66
      tmp___4 = tmp___7;
    }
  } else {
#line 66
    tmp___7 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
#line 66
    tmp___4 = tmp___7;
  }
#line 66
  if (tmp___4 != 0) {
#line 67
    error("dsa_key_from_blob: cannot handle type %s", ktype);
#line 68
    buffer_free(& b);
#line 69
    xfree((void *)ktype);
#line 70
    return ((Key *)((void *)0));
  }
#line 72
  key = key_new(1);
#line 73
  dsa = key->dsa;
#line 74
  buffer_get_bignum2(& b, dsa->p);
#line 75
  buffer_get_bignum2(& b, dsa->q);
#line 76
  buffer_get_bignum2(& b, dsa->g);
#line 77
  buffer_get_bignum2(& b, dsa->pub_key);
#line 78
  tmp___9 = buffer_len(& b);
#line 78
  rlen = (int )tmp___9;
#line 79
  if (rlen != 0) {
#line 80
    error("dsa_key_from_blob: remaining bytes in key blob %d", rlen);
  }
#line 81
  buffer_free(& b);
#line 82
  xfree((void *)ktype);
#line 87
  return (key);
}
}
#line 89 "dsa.c"
int dsa_make_key_blob(Key *key , unsigned char **blobp , unsigned int *lenp ) 
{ Buffer b ;
  int len ;
  unsigned char *buf___1 ;
  unsigned int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 96
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 97
    return (0);
  } else {
#line 96
    if (key->type != 1) {
#line 97
      return (0);
    }
  }
#line 98
  buffer_init(& b);
#line 99
  buffer_put_cstring(& b, "ssh-dss");
#line 100
  buffer_put_bignum2(& b, (key->dsa)->p);
#line 101
  buffer_put_bignum2(& b, (key->dsa)->q);
#line 102
  buffer_put_bignum2(& b, (key->dsa)->g);
#line 103
  buffer_put_bignum2(& b, (key->dsa)->pub_key);
#line 104
  tmp = buffer_len(& b);
#line 104
  len = (int )tmp;
#line 105
  tmp___0 = xmalloc((unsigned int )len);
#line 105
  buf___1 = (unsigned char *)tmp___0;
#line 106
  tmp___1 = buffer_ptr(& b);
#line 106
  memcpy((void * __restrict  )buf___1, (void const   * __restrict  )tmp___1, (unsigned int )len);
#line 107
  tmp___2 = buffer_ptr(& b);
#line 107
  memset((void *)tmp___2, 0, (unsigned int )len);
#line 108
  buffer_free(& b);
#line 109
  if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 110
    *lenp = (unsigned int )len;
  }
#line 111
  if ((unsigned int )blobp != (unsigned int )((void *)0)) {
#line 112
    *blobp = buf___1;
  }
#line 113
  return (len);
}
}
#line 115 "dsa.c"
int dsa_sign(Key *key , unsigned char **sigp , int *lenp , unsigned char *data , int datalen ) 
{ unsigned char *digest___1 ;
  unsigned char *ret ;
  DSA_SIG *sig ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  unsigned int rlen ;
  unsigned int slen ;
  unsigned int len ;
  unsigned char sigblob[40] ;
  Buffer b ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;

  {
#line 124
  tmp = EVP_sha1();
#line 124
  evp_md = (EVP_MD *)tmp;
#line 132
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 133
    error("dsa_sign: no DSA key");
#line 134
    return (-1);
  } else {
#line 132
    if (key->type != 1) {
#line 133
      error("dsa_sign: no DSA key");
#line 134
      return (-1);
    } else {
#line 132
      if ((unsigned int )key->dsa == (unsigned int )((void *)0)) {
#line 133
        error("dsa_sign: no DSA key");
#line 134
        return (-1);
      }
    }
  }
#line 136
  tmp___0 = xmalloc((unsigned int )evp_md->md_size);
#line 136
  digest___1 = (unsigned char *)tmp___0;
#line 137
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 138
  EVP_DigestUpdate(& md, (void const   *)data, (unsigned int )datalen);
#line 139
  EVP_DigestFinal(& md, digest___1, (unsigned int *)((void *)0));
#line 141
  sig = DSA_do_sign((unsigned char const   *)digest___1, evp_md->md_size, key->dsa);
#line 142
  if ((unsigned int )sig == (unsigned int )((void *)0)) {
#line 143
    fatal("dsa_sign: cannot sign");
  }
#line 146
  tmp___1 = BN_num_bits((BIGNUM const   *)sig->r);
#line 146
  rlen = (unsigned int )((tmp___1 + 7) / 8);
#line 147
  tmp___2 = BN_num_bits((BIGNUM const   *)sig->s);
#line 147
  slen = (unsigned int )((tmp___2 + 7) / 8);
#line 148
  if (rlen > 20U) {
#line 149
    error("bad sig size %d %d", rlen, slen);
#line 150
    DSA_SIG_free(sig);
#line 151
    return (-1);
  } else {
#line 148
    if (slen > 20U) {
#line 149
      error("bad sig size %d %d", rlen, slen);
#line 150
      DSA_SIG_free(sig);
#line 151
      return (-1);
    }
  }
#line 153
  debug("sig size %d %d", rlen, slen);
#line 155
  memset((void *)(sigblob), 0, 40U);
#line 156
  BN_bn2bin((BIGNUM const   *)sig->r, ((sigblob + 40) - 20) - rlen);
#line 157
  BN_bn2bin((BIGNUM const   *)sig->s, (sigblob + 40) - slen);
#line 158
  DSA_SIG_free(sig);
#line 160
  if (datafellows & 1) {
#line 161
    debug("datafellows");
#line 162
    tmp___3 = xmalloc(40U);
#line 162
    ret = (unsigned char *)tmp___3;
#line 163
    memcpy((void * __restrict  )ret, (void const   * __restrict  )(sigblob), 40U);
#line 164
    if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 165
      *lenp = 40;
    }
#line 166
    if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 167
      *sigp = ret;
    }
  } else {
#line 170
    buffer_init(& b);
#line 171
    buffer_put_cstring(& b, "ssh-dss");
#line 172
    buffer_put_string(& b, (void const   *)(sigblob), 40U);
#line 173
    len = buffer_len(& b);
#line 174
    tmp___4 = xmalloc(len);
#line 174
    ret = (unsigned char *)tmp___4;
#line 175
    tmp___5 = buffer_ptr(& b);
#line 175
    memcpy((void * __restrict  )ret, (void const   * __restrict  )tmp___5, len);
#line 176
    buffer_free(& b);
#line 177
    if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 178
      *lenp = (int )len;
    }
#line 179
    if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 180
      *sigp = ret;
    }
  }
#line 182
  return (0);
}
}
#line 184 "dsa.c"
int dsa_verify(Key *key , unsigned char *signature , int signaturelen , unsigned char *data ,
               int datalen ) 
{ Buffer b ;
  unsigned char *digest___1 ;
  DSA_SIG *sig ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  unsigned char *sigblob ;
  char *txt ;
  unsigned int len ;
  int rlen ;
  int ret ;
  char *ktype ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  unsigned int tmp___11 ;
  void *tmp___12 ;

  {
#line 193
  tmp = EVP_sha1();
#line 193
  evp_md = (EVP_MD *)tmp;
#line 201
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 202
    error("dsa_verify: no DSA key");
#line 203
    return (-1);
  } else {
#line 201
    if (key->type != 1) {
#line 202
      error("dsa_verify: no DSA key");
#line 203
      return (-1);
    } else {
#line 201
      if ((unsigned int )key->dsa == (unsigned int )((void *)0)) {
#line 202
        error("dsa_verify: no DSA key");
#line 203
        return (-1);
      }
    }
  }
#line 206
  if (! (datafellows & 1)) {
#line 206
    if (signaturelen == 40) {
#line 208
      datafellows |= -2;
#line 209
      log("autodetect SSH_BUG_SIGBLOB");
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 210
    if (datafellows & 1) {
#line 210
      if (signaturelen != 40) {
#line 212
        log("autoremove SSH_BUG_SIGBLOB");
#line 213
        datafellows &= -2;
      }
    }
  }
#line 216
  debug("len %d datafellows %d", signaturelen, datafellows);
#line 219
  if (datafellows & 1) {
#line 220
    sigblob = signature;
#line 221
    len = (unsigned int )signaturelen;
  } else {
#line 225
    buffer_init(& b);
#line 226
    buffer_append(& b, (char const   *)((char *)signature), (unsigned int )signaturelen);
#line 227
    ktype = buffer_get_string(& b, (unsigned int *)((void *)0));
#line 228
    if (0) {
#line 228
      __s1_len = strlen("ssh-dss");
#line 228
      __s2_len = strlen((char const   *)ktype);
#line 228
      if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
        goto _L___1;
      } else {
#line 228
        if (__s1_len >= 4U) {
          _L___1: /* CIL Label */ 
#line 228
          if (! ((unsigned int )((void const   *)(ktype + 1)) - (unsigned int )((void const   *)ktype) == 1U)) {
#line 228
            tmp___9 = 1;
          } else {
#line 228
            if (__s2_len >= 4U) {
#line 228
              tmp___9 = 1;
            } else {
#line 228
              tmp___9 = 0;
            }
          }
        } else {
#line 228
          tmp___9 = 0;
        }
      }
#line 228
      if (tmp___9) {
#line 228
        tmp___5 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
      } else {
#line 228
        tmp___8 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
#line 228
        tmp___5 = tmp___8;
      }
    } else {
#line 228
      tmp___8 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
#line 228
      tmp___5 = tmp___8;
    }
#line 228
    if (tmp___5 != 0) {
#line 229
      error("dsa_verify: cannot handle type %s", ktype);
#line 230
      buffer_free(& b);
#line 231
      return (-1);
    }
#line 233
    tmp___10 = buffer_get_string(& b, & len);
#line 233
    sigblob = (unsigned char *)tmp___10;
#line 234
    tmp___11 = buffer_len(& b);
#line 234
    rlen = (int )tmp___11;
#line 235
    if (rlen != 0) {
#line 236
      error("remaining bytes in signature %d", rlen);
#line 237
      buffer_free(& b);
#line 238
      return (-1);
    }
#line 240
    buffer_free(& b);
#line 241
    xfree((void *)ktype);
  }
#line 244
  if (len != 40U) {
#line 245
    fatal("bad sigbloblen %d != SIGBLOB_LEN", len);
  }
#line 249
  sig = DSA_SIG_new();
#line 250
  sig->r = BN_new();
#line 251
  sig->s = BN_new();
#line 252
  BN_bin2bn((unsigned char const   *)sigblob, 20, sig->r);
#line 253
  BN_bin2bn((unsigned char const   *)(sigblob + 20), 20, sig->s);
#line 255
  if (! (datafellows & 1)) {
#line 256
    memset((void *)sigblob, 0, len);
#line 257
    xfree((void *)sigblob);
  }
#line 261
  tmp___12 = xmalloc((unsigned int )evp_md->md_size);
#line 261
  digest___1 = (unsigned char *)tmp___12;
#line 262
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 263
  EVP_DigestUpdate(& md, (void const   *)data, (unsigned int )datalen);
#line 264
  EVP_DigestFinal(& md, digest___1, (unsigned int *)((void *)0));
#line 266
  ret = DSA_do_verify((unsigned char const   *)digest___1, evp_md->md_size, sig, key->dsa);
#line 268
  memset((void *)digest___1, 0, (unsigned int )evp_md->md_size);
#line 269
  xfree((void *)digest___1);
#line 270
  DSA_SIG_free(sig);
#line 272
  switch (ret) {
  case 1: 
#line 274
  txt = (char *)"correct";
#line 275
  break;
  case 0: 
#line 277
  txt = (char *)"incorrect";
#line 278
  break;
  case -1: 
  default: 
#line 281
  txt = (char *)"error";
#line 282
  break;
  }
#line 284
  debug("dsa_verify: signature %s", txt);
#line 285
  return (ret);
}
}
#line 288 "dsa.c"
Key *dsa_generate_key(unsigned int bits ) 
{ DSA *dsa ;
  DSA *tmp ;
  Key *k ;
  int tmp___0 ;

  {
#line 291
  tmp = DSA_generate_parameters((int )bits, (unsigned char *)((void *)0), 0, (int *)((void *)0),
                                (unsigned long *)((void *)0), (void (*)(int  , int  ,
                                                                        void * ))((void *)0),
                                (void *)0);
#line 291
  dsa = tmp;
#line 293
  if ((unsigned int )dsa == (unsigned int )((void *)0)) {
#line 294
    fatal("DSA_generate_parameters failed");
  }
#line 296
  tmp___0 = DSA_generate_key(dsa);
#line 296
  if (! tmp___0) {
#line 297
    fatal("DSA_generate_keys failed");
  }
#line 300
  k = key_new(2);
#line 301
  k->type = 1;
#line 302
  k->dsa = dsa;
#line 303
  return (k);
}
}
#line 1 "hmac.o"
#line 89 "/usr/include/openssl/hmac.h"
extern void HMAC_CTX_cleanup(HMAC_CTX *ctx ) ;
#line 93
extern void HMAC_Init(HMAC_CTX *ctx , void const   *key , int len , EVP_MD const   *md ) ;
#line 97
extern void HMAC_Update(HMAC_CTX *ctx , unsigned char const   *data , size_t len ) ;
#line 98
extern void HMAC_Final(HMAC_CTX *ctx , unsigned char *md , unsigned int *len ) ;
#line 42 "hmac.c"
static unsigned char m[64]  ;
#line 34 "hmac.c"
unsigned char *hmac(EVP_MD *evp_md , unsigned int seqno , unsigned char *data , int datalen ,
                    unsigned char *key , int keylen ) 
{ HMAC_CTX c ;
  unsigned char b[4] ;

  {
#line 45
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 46
    fatal("hmac: no key");
  }
#line 47
  HMAC_Init(& c, (void const   *)key, keylen, (EVP_MD const   *)evp_md);
#line 48
  while (1) {
#line 48
    b[0] = (unsigned char )(seqno >> 24);
#line 48
    b[1] = (unsigned char )(seqno >> 16);
#line 48
    b[2] = (unsigned char )(seqno >> 8);
#line 48
    b[3] = (unsigned char )seqno;
#line 48
    break;
  }
#line 49
  HMAC_Update(& c, (unsigned char const   *)(b), sizeof(b));
#line 50
  HMAC_Update(& c, (unsigned char const   *)data, (unsigned int )datalen);
#line 51
  HMAC_Final(& c, m, (unsigned int *)((void *)0));
#line 52
  HMAC_CTX_cleanup(& c);
#line 53
  return (m);
}
}
#line 1 "hostfile.o"
#line 410 "/usr/include/openssl/bn.h"
extern BIGNUM *BN_copy(BIGNUM *a , BIGNUM const   *b ) ;
#line 29 "match.h"
int match_hostname(char const   *host , char const   *pattern , unsigned int len ) ;
#line 378 "ssh.h"
int auth_rsa_read_key(char **cpp , unsigned int *bitsp , BIGNUM *e , BIGNUM *n___0 ) ;
#line 40 "key.h"
void key_free(Key *k ) ;
#line 41
int key_equal(Key *a , Key *b ) ;
#line 44
int key_write(Key *key , FILE *f ) ;
#line 24 "hostfile.h"
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , Key *key ,
                                  Key *found ) ;
#line 31
int add_host_to_hostfile(char const   *filename , char const   *host , Key *key ) ;
#line 54 "hostfile.c"
int hostfile_read_key(char **cpp , unsigned int *bitsp , Key *ret ) 
{ unsigned int bits ;
  char *cp ;

  {
#line 61
  cp = *cpp;
#line 61
  while (1) {
#line 61
    if (! ((int )*cp == 32)) {
#line 61
      if (! ((int )*cp == 9)) {
#line 61
        break;
      }
    }
#line 61
    cp ++;
  }
#line 64
  bits = key_read(ret, & cp);
#line 65
  if (bits == 0U) {
#line 66
    return (0);
  }
#line 69
  while (1) {
#line 69
    if (! ((int )*cp == 32)) {
#line 69
      if (! ((int )*cp == 9)) {
#line 69
        break;
      }
    }
#line 69
    cp ++;
  }
#line 73
  *cpp = cp;
#line 74
  *bitsp = bits;
#line 75
  return (1);
}
}
#line 78 "hostfile.c"
int auth_rsa_read_key(char **cpp , unsigned int *bitsp , BIGNUM *e , BIGNUM *n___0 ) 
{ Key *k ;
  Key *tmp ;
  int ret ;
  int tmp___0 ;

  {
#line 81
  tmp = key_new(0);
#line 81
  k = tmp;
#line 82
  tmp___0 = hostfile_read_key(cpp, bitsp, k);
#line 82
  ret = tmp___0;
#line 83
  BN_copy(e, (BIGNUM const   *)(k->rsa)->e);
#line 84
  BN_copy(n___0, (BIGNUM const   *)(k->rsa)->n);
#line 85
  key_free(k);
#line 86
  return (ret);
}
}
#line 89 "hostfile.c"
int hostfile_check_key(int bits , Key *key , char const   *host , char const   *filename ,
                       int linenum ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 92
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 93
    return (1);
  } else {
#line 92
    if (key->type != 0) {
#line 93
      return (1);
    } else {
#line 92
      if ((unsigned int )key->rsa == (unsigned int )((void *)0)) {
#line 93
        return (1);
      }
    }
  }
#line 94
  tmp___1 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 94
  if (bits != tmp___1) {
#line 95
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 95
    log("Warning: %s, line %d: keysize mismatch for host %s: actual %d vs. announced %d.",
        filename, linenum, host, tmp, bits);
#line 98
    tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 98
    log("Warning: replace %d with %d in %s, line %d.", bits, tmp___0, filename, linenum);
  }
#line 101
  return (1);
}
}
#line 111 "hostfile.c"
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , Key *key ,
                                  Key *found ) 
{ FILE *f ;
  char line[8192] ;
  int linenum ;
  unsigned int kbits ;
  unsigned int hostlen ;
  char *cp ;
  char *cp2 ;
  HostStatus end_return ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 116
  linenum = 0;
#line 121
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 122
    fatal("no key to look up");
  }
#line 124
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 125
  if (! f) {
#line 126
    return (1);
  }
#line 129
  hostlen = strlen(host);
#line 136
  end_return = 1;
#line 139
  while (1) {
#line 139
    tmp___3 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 139
    if (! tmp___3) {
#line 139
      break;
    }
#line 140
    cp = line;
#line 141
    linenum ++;
#line 144
    while (1) {
#line 144
      if (! ((int )*cp == 32)) {
#line 144
        if (! ((int )*cp == 9)) {
#line 144
          break;
        }
      }
#line 144
      cp ++;
    }
#line 146
    if (! *cp) {
#line 147
      continue;
    } else {
#line 146
      if ((int )*cp == 35) {
#line 147
        continue;
      } else {
#line 146
        if ((int )*cp == 10) {
#line 147
          continue;
        }
      }
    }
#line 150
    cp2 = cp;
#line 150
    while (1) {
#line 150
      if (*cp2) {
#line 150
        if ((int )*cp2 != 32) {
#line 150
          if (! ((int )*cp2 != 9)) {
#line 150
            break;
          }
        } else {
#line 150
          break;
        }
      } else {
#line 150
        break;
      }
#line 150
      cp2 ++;
    }
#line 154
    tmp = match_hostname(host, (char const   *)cp, (unsigned int )(cp2 - cp));
#line 154
    if (tmp != 1) {
#line 155
      continue;
    }
#line 158
    cp = cp2;
#line 164
    tmp___0 = hostfile_read_key(& cp, & kbits, found);
#line 164
    if (! tmp___0) {
#line 165
      continue;
    }
#line 166
    tmp___1 = hostfile_check_key((int )kbits, found, host, filename, linenum);
#line 166
    if (! tmp___1) {
#line 167
      continue;
    }
#line 170
    tmp___2 = key_equal(key, found);
#line 170
    if (tmp___2) {
#line 172
      fclose(f);
#line 173
      return (0);
    }
#line 180
    end_return = 2;
  }
#line 183
  fclose(f);
#line 189
  return (end_return);
}
}
#line 197 "hostfile.c"
int add_host_to_hostfile(char const   *filename , char const   *host , Key *key ) 
{ FILE *f ;
  int success ;
  int tmp ;

  {
#line 201
  success = 0;
#line 202
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 203
    return (1);
  }
#line 204
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"a");
#line 205
  if (! f) {
#line 206
    return (0);
  }
#line 207
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s ", host);
#line 208
  tmp = key_write(key, f);
#line 208
  if (tmp) {
#line 209
    success = 1;
  } else {
#line 211
    error("add_host_to_hostfile: saving key in %s failed", filename);
  }
#line 213
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"\n");
#line 214
  fclose(f);
#line 215
  return (success);
}
}
#line 1 "key.o"
#line 603 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 457 "/usr/include/openssl/bn.h"
extern int BN_cmp(BIGNUM const   *a , BIGNUM const   *b ) ;
#line 496
extern char *BN_bn2dec(BIGNUM const   *a ) ;
#line 498
extern int BN_dec2bn(BIGNUM **a , char const   *str ) ;
#line 215 "/usr/include/openssl/rsa.h"
extern RSA *RSA_new(void) ;
#line 238
extern void RSA_free(RSA *r ) ;
#line 190 "/usr/include/openssl/dsa.h"
extern DSA *DSA_new(void) ;
#line 593 "/usr/include/openssl/evp.h"
extern EVP_MD const   *EVP_md5(void) ;
#line 42 "key.h"
char *key_fingerprint(Key *k ) ;
#line 43
char *key_type(Key *k ) ;
#line 46
unsigned int key_size(Key *k ) ;
#line 27 "uuencode.h"
int uuencode(unsigned char *src , unsigned int srclength , char *target , size_t targsize ) ;
#line 28
int uudecode(char const   *src , unsigned char *target , size_t targsize ) ;
#line 49 "key.c"
Key *key_new(int type ) 
{ Key *k ;
  RSA *rsa ;
  DSA *dsa ;
  void *tmp ;

  {
#line 55
  tmp = xmalloc(sizeof(*k));
#line 55
  k = (Key *)tmp;
#line 56
  k->type = type;
#line 57
  k->dsa = (DSA *)((void *)0);
#line 58
  k->rsa = (RSA *)((void *)0);
#line 59
  switch (k->type) {
  case 0: 
#line 61
  rsa = RSA_new();
#line 62
  rsa->n = BN_new();
#line 63
  rsa->e = BN_new();
#line 64
  k->rsa = rsa;
#line 65
  break;
  case 1: 
#line 67
  dsa = DSA_new();
#line 68
  dsa->p = BN_new();
#line 69
  dsa->q = BN_new();
#line 70
  dsa->g = BN_new();
#line 71
  dsa->pub_key = BN_new();
#line 72
  k->dsa = dsa;
#line 73
  break;
  case 2: 
#line 75
  break;
  default: 
#line 77
  fatal("key_new: bad key type %d", k->type);
#line 78
  break;
  }
#line 80
  return (k);
}
}
#line 82 "key.c"
void key_free(Key *k ) 
{ 

  {
#line 85
  switch (k->type) {
  case 0: 
#line 87
  if ((unsigned int )k->rsa != (unsigned int )((void *)0)) {
#line 88
    RSA_free(k->rsa);
  }
#line 89
  k->rsa = (RSA *)((void *)0);
#line 90
  break;
  case 1: 
#line 92
  if ((unsigned int )k->dsa != (unsigned int )((void *)0)) {
#line 93
    DSA_free(k->dsa);
  }
#line 94
  k->dsa = (DSA *)((void *)0);
#line 95
  break;
  default: 
#line 97
  fatal("key_free: bad key type %d", k->type);
#line 98
  break;
  }
#line 100
  xfree((void *)k);
#line 101
  return;
}
}
#line 102 "key.c"
int key_equal(Key *a , Key *b ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 105
  if ((unsigned int )a == (unsigned int )((void *)0)) {
#line 106
    return (0);
  } else {
#line 105
    if ((unsigned int )b == (unsigned int )((void *)0)) {
#line 106
      return (0);
    } else {
#line 105
      if (a->type != b->type) {
#line 106
        return (0);
      }
    }
  }
#line 107
  switch (a->type) {
  case 0: 
#line 109
  if ((unsigned int )a->rsa != (unsigned int )((void *)0)) {
#line 109
    if ((unsigned int )b->rsa != (unsigned int )((void *)0)) {
#line 109
      tmp = BN_cmp((BIGNUM const   *)(a->rsa)->e, (BIGNUM const   *)(b->rsa)->e);
#line 109
      if (tmp == 0) {
#line 109
        tmp___0 = BN_cmp((BIGNUM const   *)(a->rsa)->n, (BIGNUM const   *)(b->rsa)->n);
#line 109
        if (tmp___0 == 0) {
#line 109
          tmp___1 = 1;
        } else {
#line 109
          tmp___1 = 0;
        }
      } else {
#line 109
        tmp___1 = 0;
      }
    } else {
#line 109
      tmp___1 = 0;
    }
  } else {
#line 109
    tmp___1 = 0;
  }
#line 109
  return (tmp___1);
#line 112
  break;
  case 1: 
#line 114
  if ((unsigned int )a->dsa != (unsigned int )((void *)0)) {
#line 114
    if ((unsigned int )b->dsa != (unsigned int )((void *)0)) {
#line 114
      tmp___2 = BN_cmp((BIGNUM const   *)(a->dsa)->p, (BIGNUM const   *)(b->dsa)->p);
#line 114
      if (tmp___2 == 0) {
#line 114
        tmp___3 = BN_cmp((BIGNUM const   *)(a->dsa)->q, (BIGNUM const   *)(b->dsa)->q);
#line 114
        if (tmp___3 == 0) {
#line 114
          tmp___4 = BN_cmp((BIGNUM const   *)(a->dsa)->g, (BIGNUM const   *)(b->dsa)->g);
#line 114
          if (tmp___4 == 0) {
#line 114
            tmp___5 = BN_cmp((BIGNUM const   *)(a->dsa)->pub_key, (BIGNUM const   *)(b->dsa)->pub_key);
#line 114
            if (tmp___5 == 0) {
#line 114
              tmp___6 = 1;
            } else {
#line 114
              tmp___6 = 0;
            }
          } else {
#line 114
            tmp___6 = 0;
          }
        } else {
#line 114
          tmp___6 = 0;
        }
      } else {
#line 114
        tmp___6 = 0;
      }
    } else {
#line 114
      tmp___6 = 0;
    }
  } else {
#line 114
    tmp___6 = 0;
  }
#line 114
  return (tmp___6);
#line 119
  break;
  default: 
#line 121
  fatal("key_equal: bad key type %d", a->type);
#line 122
  break;
  }
#line 124
  return (0);
}
}
#line 134 "key.c"
static char retval[195]  ;
#line 131 "key.c"
char *key_fingerprint(Key *k ) 
{ unsigned char *blob ;
  int len ;
  int nlen ;
  int elen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int i ;
  unsigned char digest___1[64] ;
  EVP_MD *md ;
  EVP_MD const   *tmp___2 ;
  EVP_MD_CTX ctx ;
  char hex[4] ;
  size_t tmp___3 ;

  {
#line 135
  blob = (unsigned char *)((void *)0);
#line 136
  len = 0;
#line 139
  switch (k->type) {
  case 0: 
#line 141
  tmp = BN_num_bits((BIGNUM const   *)(k->rsa)->n);
#line 141
  nlen = (tmp + 7) / 8;
#line 142
  tmp___0 = BN_num_bits((BIGNUM const   *)(k->rsa)->e);
#line 142
  elen = (tmp___0 + 7) / 8;
#line 143
  len = nlen + elen;
#line 144
  tmp___1 = xmalloc((unsigned int )len);
#line 144
  blob = (unsigned char *)tmp___1;
#line 145
  BN_bn2bin((BIGNUM const   *)(k->rsa)->n, blob);
#line 146
  BN_bn2bin((BIGNUM const   *)(k->rsa)->e, blob + nlen);
#line 147
  break;
  case 1: 
#line 149
  dsa_make_key_blob(k, & blob, (unsigned int *)(& len));
#line 150
  break;
  default: 
#line 152
  fatal("key_fingerprint: bad key type %d", k->type);
#line 153
  break;
  }
#line 155
  retval[0] = (char )'\000';
#line 157
  if ((unsigned int )blob != (unsigned int )((void *)0)) {
#line 160
    tmp___2 = EVP_md5();
#line 160
    md = (EVP_MD *)tmp___2;
#line 162
    EVP_DigestInit(& ctx, (EVP_MD const   *)md);
#line 163
    EVP_DigestUpdate(& ctx, (void const   *)blob, (unsigned int )len);
#line 164
    EVP_DigestFinal(& ctx, digest___1, (unsigned int *)((void *)0));
#line 165
    i = 0;
#line 165
    while (i < md->md_size) {
#line 167
      snprintf((char * __restrict  )(hex), sizeof(hex), (char const   * __restrict  )"%02x:",
               digest___1[i]);
#line 168
      strlcat(retval, (char const   *)(hex), sizeof(retval));
#line 165
      i ++;
    }
#line 170
    tmp___3 = strlen((char const   *)(retval));
#line 170
    retval[tmp___3 - 1U] = (char )'\000';
#line 171
    memset((void *)blob, 0, (unsigned int )len);
#line 172
    xfree((void *)blob);
  }
#line 174
  return (retval);
}
}
#line 184 "key.c"
int read_bignum(char **cpp , BIGNUM *value ) 
{ char *cp ;
  int old ;
  int tmp ;

  {
#line 187
  cp = *cpp;
#line 191
  while (1) {
#line 191
    if (! ((int )*cp == 32)) {
#line 191
      if (! ((int )*cp == 9)) {
#line 191
        break;
      }
    }
#line 191
    cp ++;
  }
#line 195
  if ((int )*cp < 48) {
#line 196
    return (0);
  } else {
#line 195
    if ((int )*cp > 57) {
#line 196
      return (0);
    }
  }
#line 199
  *cpp = cp;
#line 202
  while (1) {
#line 202
    if ((int )*cp >= 48) {
#line 202
      if (! ((int )*cp <= 57)) {
#line 202
        break;
      }
    } else {
#line 202
      break;
    }
#line 202
    cp ++;
  }
#line 206
  old = (int )*cp;
#line 207
  *cp = (char)0;
#line 210
  tmp = BN_dec2bn(& value, (char const   *)*cpp);
#line 210
  if (tmp == 0) {
#line 211
    return (0);
  }
#line 214
  *cp = (char )old;
#line 217
  *cpp = cp;
#line 218
  return (1);
}
}
#line 220 "key.c"
int write_bignum(FILE *f , BIGNUM *num ) 
{ char *buf___1 ;
  char *tmp ;

  {
#line 223
  tmp = BN_bn2dec((BIGNUM const   *)num);
#line 223
  buf___1 = tmp;
#line 224
  if ((unsigned int )buf___1 == (unsigned int )((void *)0)) {
#line 225
    error("write_bignum: BN_bn2dec() failed");
#line 226
    return (0);
  }
#line 228
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )" %s", buf___1);
#line 229
  free((void *)buf___1);
#line 230
  return (1);
}
}
#line 232 "key.c"
unsigned int key_read(Key *ret , char **cpp ) 
{ Key *k ;
  unsigned int bits ;
  char *cp ;
  int len ;
  int n___0 ;
  unsigned char *blob ;
  int tmp ;
  int tmp___0 ;
  int tmp___14 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  size_t tmp___27 ;
  void *tmp___28 ;
  int tmp___29 ;

  {
#line 236
  bits = 0U;
#line 241
  cp = *cpp;
#line 243
  switch (ret->type) {
  case 0: 
#line 246
  if ((int )*cp < 48) {
#line 247
    return (0U);
  } else {
#line 246
    if ((int )*cp > 57) {
#line 247
      return (0U);
    }
  }
#line 248
  bits = 0U;
#line 248
  while (1) {
#line 248
    if ((int )*cp >= 48) {
#line 248
      if (! ((int )*cp <= 57)) {
#line 248
        break;
      }
    } else {
#line 248
      break;
    }
#line 249
    bits = (10U * bits + (unsigned int )*cp) - 48U;
#line 248
    cp ++;
  }
#line 250
  if (bits == 0U) {
#line 251
    return (0U);
  }
#line 252
  *cpp = cp;
#line 254
  tmp = read_bignum(cpp, (ret->rsa)->e);
#line 254
  if (! tmp) {
#line 255
    return (0U);
  }
#line 256
  tmp___0 = read_bignum(cpp, (ret->rsa)->n);
#line 256
  if (! tmp___0) {
#line 257
    return (0U);
  }
#line 258
  break;
  case 1: 
#line 260
  if (0) {
#line 260
    if (0) {
#line 260
      __s1_len___0 = strlen((char const   *)cp);
#line 260
      __s2_len___0 = strlen("ssh-dss ");
#line 260
      if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
        goto _L___2;
      } else {
#line 260
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 260
          if (! ((unsigned int )((void const   *)("ssh-dss " + 1)) - (unsigned int )((void const   *)"ssh-dss ") == 1U)) {
#line 260
            tmp___24 = 1;
          } else {
#line 260
            if (__s2_len___0 >= 4U) {
#line 260
              tmp___24 = 1;
            } else {
#line 260
              tmp___24 = 0;
            }
          }
        } else {
#line 260
          tmp___24 = 0;
        }
      }
#line 260
      if (tmp___24) {
#line 260
        tmp___20 = __builtin_strcmp((char const   *)cp, "ssh-dss ");
      } else {
#line 260
        tmp___23 = __builtin_strcmp((char const   *)cp, "ssh-dss ");
#line 260
        tmp___20 = tmp___23;
      }
    } else {
#line 260
      tmp___23 = __builtin_strcmp((char const   *)cp, "ssh-dss ");
#line 260
      tmp___20 = tmp___23;
    }
#line 260
    tmp___14 = tmp___20;
  } else {
#line 260
    tmp___14 = strncmp((char const   *)cp, "ssh-dss ", 7U);
  }
#line 260
  if (tmp___14 != 0) {
#line 261
    return (0U);
  }
#line 262
  cp += 7;
#line 263
  tmp___27 = strlen((char const   *)cp);
#line 263
  len = (int )(2U * tmp___27);
#line 264
  tmp___28 = xmalloc((unsigned int )len);
#line 264
  blob = (unsigned char *)tmp___28;
#line 265
  n___0 = uudecode((char const   *)cp, blob, (unsigned int )len);
#line 266
  if (n___0 < 0) {
#line 267
    error("key_read: uudecode %s failed", cp);
#line 268
    return (0U);
  }
#line 270
  k = dsa_key_from_blob((char *)blob, n___0);
#line 271
  if ((unsigned int )k == (unsigned int )((void *)0)) {
#line 272
    error("key_read: dsa_key_from_blob %s failed", cp);
#line 273
    return (0U);
  }
#line 275
  xfree((void *)blob);
#line 276
  if ((unsigned int )ret->dsa != (unsigned int )((void *)0)) {
#line 277
    DSA_free(ret->dsa);
  }
#line 278
  ret->dsa = k->dsa;
#line 279
  k->dsa = (DSA *)((void *)0);
#line 280
  key_free(k);
#line 281
  tmp___29 = BN_num_bits((BIGNUM const   *)(ret->dsa)->p);
#line 281
  bits = (unsigned int )tmp___29;
#line 283
  while (1) {
#line 283
    if (! ((int )*cp == 32)) {
#line 283
      if (! ((int )*cp == 9)) {
#line 283
        break;
      }
    }
#line 284
    cp ++;
  }
#line 285
  while (1) {
#line 285
    if ((int )*cp != 0) {
#line 285
      if ((int )*cp != 32) {
#line 285
        if (! ((int )*cp != 9)) {
#line 285
          break;
        }
      } else {
#line 285
        break;
      }
    } else {
#line 285
      break;
    }
#line 286
    cp ++;
  }
#line 287
  *cpp = cp;
#line 288
  break;
  default: 
#line 290
  fatal("key_read: bad key type: %d", ret->type);
#line 291
  break;
  }
#line 293
  return (bits);
}
}
#line 295 "key.c"
int key_write(Key *key , FILE *f ) 
{ int success ;
  unsigned int bits ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int len ;
  int n___0 ;
  unsigned char *blob ;
  unsigned char *uu ;
  void *tmp___2 ;

  {
#line 298
  success = 0;
#line 299
  bits = 0U;
#line 301
  if (key->type == 0) {
#line 301
    if ((unsigned int )key->rsa != (unsigned int )((void *)0)) {
#line 303
      tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 303
      bits = (unsigned int )tmp;
#line 304
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%u", bits);
#line 305
      tmp___0 = write_bignum(f, (key->rsa)->e);
#line 305
      if (tmp___0) {
#line 305
        tmp___1 = write_bignum(f, (key->rsa)->n);
#line 305
        if (tmp___1) {
#line 307
          success = 1;
        } else {
#line 309
          error("key_write: failed for RSA key");
        }
      } else {
#line 309
        error("key_write: failed for RSA key");
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 311
    if (key->type == 1) {
#line 311
      if ((unsigned int )key->dsa != (unsigned int )((void *)0)) {
#line 314
        dsa_make_key_blob(key, & blob, (unsigned int *)(& len));
#line 315
        tmp___2 = xmalloc((unsigned int )(2 * len));
#line 315
        uu = (unsigned char *)tmp___2;
#line 316
        n___0 = uuencode(blob, (unsigned int )len, (char *)uu, (unsigned int )(2 * len));
#line 317
        if (n___0 > 0) {
#line 318
          fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s", "ssh-dss",
                  uu);
#line 319
          success = 1;
        }
#line 321
        xfree((void *)blob);
#line 322
        xfree((void *)uu);
      }
    }
  }
#line 324
  return (success);
}
}
#line 326 "key.c"
char *key_type(Key *k ) 
{ 

  {
#line 329
  switch (k->type) {
  case 0: 
#line 331
  return ((char *)"RSA");
#line 332
  break;
  case 1: 
#line 334
  return ((char *)"DSA");
#line 335
  break;
  }
#line 337
  return ((char *)"unknown");
}
}
#line 339 "key.c"
unsigned int key_size(Key *k ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 341
  switch (k->type) {
  case 0: 
#line 343
  tmp = BN_num_bits((BIGNUM const   *)(k->rsa)->n);
#line 343
  return ((unsigned int )tmp);
#line 344
  break;
  case 1: 
#line 346
  tmp___0 = BN_num_bits((BIGNUM const   *)(k->dsa)->p);
#line 346
  return ((unsigned int )tmp___0);
#line 347
  break;
  }
#line 349
  return (0U);
}
}
#line 1 "kex.o"
#line 459 "/usr/include/openssl/bn.h"
extern int BN_is_bit_set(BIGNUM const   *a , int n ) ;
#line 497
extern int BN_hex2bn(BIGNUM **a , char const   *str ) ;
#line 89 "packet.h"
void packet_put_raw(char const   *buf___1 , unsigned int len ) ;
#line 123
unsigned int packet_get_char(void) ;
#line 134
char *packet_get_raw(int *length_ptr ) ;
#line 173 "/usr/include/openssl/dh.h"
extern DH *DH_new(void) ;
#line 193
extern int DH_generate_key(DH *dh ) ;
#line 611 "/usr/include/openssl/evp.h"
extern EVP_MD const   *EVP_ripemd160(void) ;
#line 92 "kex.h"
Buffer *kex_init(char **myproposal___0 ) ;
#line 93
void kex_exchange_kexinit(Buffer *my_kexinit , Buffer *peer_kexint , char **peer_proposal ) ;
#line 97
Kex *kex_choose_conf(char **cprop , char **sprop , int server ) ;
#line 100
int kex_derive_keys(Kex *k , unsigned char *hash , BIGNUM *shared_secret ) ;
#line 102
int dh_pub_is_valid(DH *dh , BIGNUM *dh_pub ) ;
#line 103
DH *dh_new_group_asc(char const   *gen___0 , char const   *modulus ) ;
#line 104
DH *dh_new_group(BIGNUM *gen___0 , BIGNUM *modulus ) ;
#line 105
DH *dh_new_group1(void) ;
#line 107
unsigned char *kex_hash(char *client_version_string___0 , char *server_version_string___0 ,
                        char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                        char *serverhostkeyblob , int sbloblen , BIGNUM *client_dh_pub ,
                        BIGNUM *server_dh_pub , BIGNUM *shared_secret ) ;
#line 118
unsigned char *kex_hash_gex(char *client_version_string___0 , char *server_version_string___0 ,
                            char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                            char *serverhostkeyblob , int sbloblen , int minbits ,
                            BIGNUM *prime , BIGNUM *gen___0 , BIGNUM *client_dh_pub ,
                            BIGNUM *server_dh_pub , BIGNUM *shared_secret ) ;
#line 49 "kex.c"
Buffer *kex_init(char **myproposal___0 ) 
{ int first_kex_packet_follows ;
  unsigned char cookie[16] ;
  u_int32_t rand___0 ;
  int i ;
  Buffer *ki ;
  void *tmp ;

  {
#line 52
  first_kex_packet_follows = 0;
#line 54
  rand___0 = (u_int32_t )0;
#line 56
  tmp = xmalloc(sizeof(*ki));
#line 56
  ki = (Buffer *)tmp;
#line 57
  i = 0;
#line 57
  while (i < 16) {
#line 58
    if (i % 4 == 0) {
#line 59
      rand___0 = arc4random();
    }
#line 60
    cookie[i] = (unsigned char )(rand___0 & 255U);
#line 61
    rand___0 >>= 8;
#line 57
    i ++;
  }
#line 63
  buffer_init(ki);
#line 64
  buffer_append(ki, (char const   *)((char *)(cookie)), sizeof(cookie));
#line 65
  i = 0;
#line 65
  while (i < 10) {
#line 66
    buffer_put_cstring(ki, (char const   *)*(myproposal___0 + i));
#line 65
    i ++;
  }
#line 67
  buffer_put_char(ki, first_kex_packet_follows);
#line 68
  buffer_put_int(ki, 0U);
#line 69
  return (ki);
}
}
#line 73 "kex.c"
void kex_exchange_kexinit(Buffer *my_kexinit , Buffer *peer_kexint , char **peer_proposal ) 
{ int i ;
  char *ptr ;
  int plen ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 82
  debug("send KEXINIT");
#line 83
  packet_start(20);
#line 84
  tmp = buffer_len(my_kexinit);
#line 84
  tmp___0 = buffer_ptr(my_kexinit);
#line 84
  packet_put_raw((char const   *)tmp___0, tmp);
#line 85
  packet_send();
#line 86
  packet_write_wait();
#line 87
  debug("done");
#line 93
  debug("wait KEXINIT");
#line 94
  packet_read_expect(& plen, 20);
#line 95
  ptr = packet_get_raw(& plen);
#line 96
  buffer_append(peer_kexint, (char const   *)ptr, (unsigned int )plen);
#line 100
  i = 0;
#line 100
  while (i < 16) {
#line 101
    packet_get_char();
#line 100
    i ++;
  }
#line 103
  i = 0;
#line 103
  while (i < 10) {
#line 104
    *(peer_proposal + i) = packet_get_string((unsigned int *)((void *)0));
#line 105
    debug("got kexinit: %s", *(peer_proposal + i));
#line 103
    i ++;
  }
#line 108
  tmp___1 = packet_get_char();
#line 108
  i = (int )tmp___1;
#line 109
  debug("first kex follow: %d ", i);
#line 110
  tmp___2 = packet_get_int();
#line 110
  i = (int )tmp___2;
#line 111
  debug("reserved: %d ", i);
#line 112
  while (1) {
#line 112
    tmp___3 = packet_remaining();
#line 112
    _len = tmp___3;
#line 112
    if (_len > 0) {
#line 112
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kex.c", 112);
#line 112
      packet_disconnect("Packet integrity error.");
    }
#line 112
    break;
  }
#line 113
  debug("done");
#line 114
  return;
}
}
#line 118 "kex.c"
int dh_pub_is_valid(DH *dh , BIGNUM *dh_pub ) 
{ int i ;
  int n___0 ;
  int tmp ;
  int bits_set ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 122
  tmp = BN_num_bits((BIGNUM const   *)dh_pub);
#line 122
  n___0 = tmp;
#line 123
  bits_set = 0;
#line 125
  if (dh_pub->neg) {
#line 126
    log("invalid public DH value: negativ");
#line 127
    return (0);
  }
#line 129
  i = 0;
#line 129
  while (i <= n___0) {
#line 130
    tmp___0 = BN_is_bit_set((BIGNUM const   *)dh_pub, i);
#line 130
    if (tmp___0) {
#line 131
      bits_set ++;
    }
#line 129
    i ++;
  }
#line 132
  tmp___1 = BN_num_bits((BIGNUM const   *)dh->p);
#line 132
  debug("bits set: %d/%d", bits_set, tmp___1);
#line 135
  if (bits_set > 1) {
#line 135
    tmp___2 = BN_cmp((BIGNUM const   *)dh_pub, (BIGNUM const   *)dh->p);
#line 135
    if (tmp___2 == -1) {
#line 136
      return (1);
    }
  }
#line 137
  tmp___3 = BN_num_bits((BIGNUM const   *)dh->p);
#line 137
  log("invalid public DH value (%d/%d)", bits_set, tmp___3);
#line 138
  return (0);
}
}
#line 141 "kex.c"
DH *dh_gen_key(DH *dh ) 
{ int tries ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 144
  tries = 0;
#line 146
  while (1) {
#line 147
    tmp = DH_generate_key(dh);
#line 147
    if (tmp == 0) {
#line 148
      fatal("DH_generate_key");
    }
#line 149
    tmp___0 = tries;
#line 149
    tries ++;
#line 149
    if (tmp___0 > 10) {
#line 150
      fatal("dh_new_group1: too many bad keys: giving up");
    }
#line 146
    tmp___1 = dh_pub_is_valid(dh, dh->pub_key);
#line 146
    if (tmp___1) {
#line 146
      break;
    }
  }
#line 152
  return (dh);
}
}
#line 155 "kex.c"
DH *dh_new_group_asc(char const   *gen___0 , char const   *modulus ) 
{ DH *dh ;
  int ret ;
  DH *tmp ;

  {
#line 161
  dh = DH_new();
#line 162
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 163
    fatal("DH_new");
  }
#line 165
  ret = BN_hex2bn(& dh->p, modulus);
#line 165
  if (ret < 0) {
#line 166
    fatal("BN_hex2bn p");
  }
#line 167
  ret = BN_hex2bn(& dh->g, gen___0);
#line 167
  if (ret < 0) {
#line 168
    fatal("BN_hex2bn g");
  }
#line 170
  tmp = dh_gen_key(dh);
#line 170
  return (tmp);
}
}
#line 173 "kex.c"
DH *dh_new_group(BIGNUM *gen___0 , BIGNUM *modulus ) 
{ DH *dh ;
  DH *tmp ;

  {
#line 178
  dh = DH_new();
#line 179
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 180
    fatal("DH_new");
  }
#line 181
  dh->p = modulus;
#line 182
  dh->g = gen___0;
#line 184
  tmp = dh_gen_key(dh);
#line 184
  return (tmp);
}
}
#line 190 "kex.c"
static char *gen  =    (char *)"2";
#line 190 "kex.c"
static char *group1  =    (char *)"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF";
#line 187 "kex.c"
DH *dh_new_group1(void) 
{ DH *tmp ;

  {
#line 198
  tmp = dh_new_group_asc((char const   *)gen, (char const   *)group1);
#line 198
  return (tmp);
}
}
#line 201 "kex.c"
void dump_digest(unsigned char *digest___1 , int len ) 
{ int i ;

  {
#line 205
  i = 0;
#line 205
  while (i < len) {
#line 206
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%02x", *(digest___1 + i));
#line 207
    if (i % 2 != 0) {
#line 208
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" ");
    }
#line 205
    i ++;
  }
#line 210
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 211
  return;
}
}
#line 225 "kex.c"
static unsigned char digest[64]  ;
#line 213 "kex.c"
unsigned char *kex_hash(char *client_version_string___0 , char *server_version_string___0 ,
                        char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                        char *serverhostkeyblob , int sbloblen , BIGNUM *client_dh_pub ,
                        BIGNUM *server_dh_pub , BIGNUM *shared_secret ) 
{ Buffer b ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;

  {
#line 226
  tmp = EVP_sha1();
#line 226
  evp_md = (EVP_MD *)tmp;
#line 229
  buffer_init(& b);
#line 230
  tmp___0 = strlen((char const   *)client_version_string___0);
#line 230
  buffer_put_string(& b, (void const   *)client_version_string___0, tmp___0);
#line 231
  tmp___1 = strlen((char const   *)server_version_string___0);
#line 231
  buffer_put_string(& b, (void const   *)server_version_string___0, tmp___1);
#line 234
  buffer_put_int(& b, (unsigned int )(ckexinitlen + 1));
#line 235
  buffer_put_char(& b, 20);
#line 236
  buffer_append(& b, (char const   *)ckexinit, (unsigned int )ckexinitlen);
#line 237
  buffer_put_int(& b, (unsigned int )(skexinitlen + 1));
#line 238
  buffer_put_char(& b, 20);
#line 239
  buffer_append(& b, (char const   *)skexinit, (unsigned int )skexinitlen);
#line 241
  buffer_put_string(& b, (void const   *)serverhostkeyblob, (unsigned int )sbloblen);
#line 242
  buffer_put_bignum2(& b, client_dh_pub);
#line 243
  buffer_put_bignum2(& b, server_dh_pub);
#line 244
  buffer_put_bignum2(& b, shared_secret);
#line 250
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 251
  tmp___2 = buffer_len(& b);
#line 251
  tmp___3 = buffer_ptr(& b);
#line 251
  EVP_DigestUpdate(& md, (void const   *)tmp___3, tmp___2);
#line 252
  EVP_DigestFinal(& md, digest, (unsigned int *)((void *)0));
#line 254
  buffer_free(& b);
#line 259
  return (digest);
}
}
#line 275 "kex.c"
static unsigned char digest___0[64]  ;
#line 262 "kex.c"
unsigned char *kex_hash_gex(char *client_version_string___0 , char *server_version_string___0 ,
                            char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                            char *serverhostkeyblob , int sbloblen , int minbits ,
                            BIGNUM *prime , BIGNUM *gen___0 , BIGNUM *client_dh_pub ,
                            BIGNUM *server_dh_pub , BIGNUM *shared_secret ) 
{ Buffer b ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;

  {
#line 276
  tmp = EVP_sha1();
#line 276
  evp_md = (EVP_MD *)tmp;
#line 279
  buffer_init(& b);
#line 280
  tmp___0 = strlen((char const   *)client_version_string___0);
#line 280
  buffer_put_string(& b, (void const   *)client_version_string___0, tmp___0);
#line 281
  tmp___1 = strlen((char const   *)server_version_string___0);
#line 281
  buffer_put_string(& b, (void const   *)server_version_string___0, tmp___1);
#line 284
  buffer_put_int(& b, (unsigned int )(ckexinitlen + 1));
#line 285
  buffer_put_char(& b, 20);
#line 286
  buffer_append(& b, (char const   *)ckexinit, (unsigned int )ckexinitlen);
#line 287
  buffer_put_int(& b, (unsigned int )(skexinitlen + 1));
#line 288
  buffer_put_char(& b, 20);
#line 289
  buffer_append(& b, (char const   *)skexinit, (unsigned int )skexinitlen);
#line 291
  buffer_put_string(& b, (void const   *)serverhostkeyblob, (unsigned int )sbloblen);
#line 292
  buffer_put_int(& b, (unsigned int )minbits);
#line 293
  buffer_put_bignum2(& b, prime);
#line 294
  buffer_put_bignum2(& b, gen___0);
#line 295
  buffer_put_bignum2(& b, client_dh_pub);
#line 296
  buffer_put_bignum2(& b, server_dh_pub);
#line 297
  buffer_put_bignum2(& b, shared_secret);
#line 303
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 304
  tmp___2 = buffer_len(& b);
#line 304
  tmp___3 = buffer_ptr(& b);
#line 304
  EVP_DigestUpdate(& md, (void const   *)tmp___3, tmp___2);
#line 305
  EVP_DigestFinal(& md, digest___0, (unsigned int *)((void *)0));
#line 307
  buffer_free(& b);
#line 312
  return (digest___0);
}
}
#line 315 "kex.c"
unsigned char *derive_key(int id , int need , unsigned char *hash , BIGNUM *shared_secret ) 
{ Buffer b ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  char c ;
  int have ;
  int mdsz ;
  unsigned char *digest___1 ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  char *tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;

  {
#line 319
  tmp = EVP_sha1();
#line 319
  evp_md = (EVP_MD *)tmp;
#line 321
  c = (char )id;
#line 323
  mdsz = evp_md->md_size;
#line 324
  tmp___0 = xmalloc((unsigned int )((((need + mdsz) - 1) / mdsz) * mdsz));
#line 324
  digest___1 = (unsigned char *)tmp___0;
#line 326
  buffer_init(& b);
#line 327
  buffer_put_bignum2(& b, shared_secret);
#line 329
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 330
  tmp___1 = buffer_len(& b);
#line 330
  tmp___2 = buffer_ptr(& b);
#line 330
  EVP_DigestUpdate(& md, (void const   *)tmp___2, tmp___1);
#line 331
  EVP_DigestUpdate(& md, (void const   *)hash, (unsigned int )mdsz);
#line 332
  EVP_DigestUpdate(& md, (void const   *)(& c), 1U);
#line 333
  EVP_DigestUpdate(& md, (void const   *)hash, (unsigned int )mdsz);
#line 334
  EVP_DigestFinal(& md, digest___1, (unsigned int *)((void *)0));
#line 337
  have = mdsz;
#line 337
  while (need > have) {
#line 338
    EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 339
    tmp___3 = buffer_len(& b);
#line 339
    tmp___4 = buffer_ptr(& b);
#line 339
    EVP_DigestUpdate(& md, (void const   *)tmp___4, tmp___3);
#line 340
    EVP_DigestUpdate(& md, (void const   *)hash, (unsigned int )mdsz);
#line 341
    EVP_DigestUpdate(& md, (void const   *)digest___1, (unsigned int )have);
#line 342
    EVP_DigestFinal(& md, digest___1 + have, (unsigned int *)((void *)0));
#line 337
    have += mdsz;
  }
#line 344
  buffer_free(& b);
#line 349
  return (digest___1);
}
}
#line 357 "kex.c"
char *get_match(char *client , char *server ) 
{ char *sproposals[20] ;
  char *c ;
  char *s ;
  char *p ;
  char *ret ;
  char *cp ;
  char *sp ;
  int i ;
  int j ;
  int nproposals ;
  char *tmp___14 ;
  char *tmp___30 ;
  char *tmp___46 ;
  char *tmp___62 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___68 ;
  int tmp___71 ;
  int tmp___72 ;

  {
#line 364
  cp = xstrdup((char const   *)client);
#line 364
  c = cp;
#line 365
  sp = xstrdup((char const   *)server);
#line 365
  s = sp;
#line 367
  tmp___14 = __strsep_g(& sp, ",");
#line 367
  p = tmp___14;
#line 367
  i = 0;
#line 367
  while (1) {
#line 367
    if (p) {
#line 367
      if (! ((int )*p != 0)) {
#line 367
        break;
      }
    } else {
#line 367
      break;
    }
#line 369
    if (i < 20) {
#line 370
      sproposals[i] = p;
    } else {
#line 372
      break;
    }
#line 368
    tmp___30 = __strsep_g(& sp, ",");
#line 368
    p = tmp___30;
#line 368
    i ++;
  }
#line 374
  nproposals = i;
#line 376
  tmp___46 = __strsep_g(& cp, ",");
#line 376
  p = tmp___46;
#line 376
  i = 0;
#line 376
  while (1) {
#line 376
    if (p) {
#line 376
      if (! ((int )*p != 0)) {
#line 376
        break;
      }
    } else {
#line 376
      break;
    }
#line 378
    j = 0;
#line 378
    while (j < nproposals) {
#line 379
      if (0) {
#line 379
        __s1_len = strlen((char const   *)p);
#line 379
        __s2_len = strlen((char const   *)sproposals[j]);
#line 379
        if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
          goto _L___0;
        } else {
#line 379
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 379
            if (! ((unsigned int )((void const   *)(sproposals[j] + 1)) - (unsigned int )((void const   *)sproposals[j]) == 1U)) {
#line 379
              tmp___72 = 1;
            } else {
#line 379
              if (__s2_len >= 4U) {
#line 379
                tmp___72 = 1;
              } else {
#line 379
                tmp___72 = 0;
              }
            }
          } else {
#line 379
            tmp___72 = 0;
          }
        }
#line 379
        if (tmp___72) {
#line 379
          tmp___68 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
        } else {
#line 379
          tmp___71 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
#line 379
          tmp___68 = tmp___71;
        }
      } else {
#line 379
        tmp___71 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
#line 379
        tmp___68 = tmp___71;
      }
#line 379
      if (tmp___68 == 0) {
#line 380
        ret = xstrdup((char const   *)p);
#line 381
        xfree((void *)c);
#line 382
        xfree((void *)s);
#line 383
        return (ret);
      }
#line 378
      j ++;
    }
#line 377
    tmp___62 = __strsep_g(& cp, ",");
#line 377
    p = tmp___62;
#line 377
    i ++;
  }
#line 387
  xfree((void *)c);
#line 388
  xfree((void *)s);
#line 389
  return ((char *)((void *)0));
}
}
#line 391 "kex.c"
void choose_enc(Enc *enc , char *client , char *server ) 
{ char *name ;
  char *tmp ;

  {
#line 394
  tmp = get_match(client, server);
#line 394
  name = tmp;
#line 395
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 396
    fatal("no matching cipher found: client %s server %s", client, server);
  }
#line 397
  enc->cipher = cipher_by_name((char const   *)name);
#line 398
  if ((unsigned int )enc->cipher == (unsigned int )((void *)0)) {
#line 399
    fatal("matching cipher is not supported: %s", name);
  }
#line 400
  enc->name = name;
#line 401
  enc->enabled = 0;
#line 402
  enc->iv = (unsigned char *)((void *)0);
#line 403
  enc->key = (unsigned char *)((void *)0);
#line 404
  return;
}
}
#line 405 "kex.c"
void choose_mac(Mac *mac , char *client , char *server ) 
{ char *name ;
  char *tmp ;
  EVP_MD const   *tmp___0 ;
  EVP_MD const   *tmp___1 ;
  EVP_MD const   *tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___28 ;
  int tmp___31 ;
  int tmp___32 ;

  {
#line 408
  tmp = get_match(client, server);
#line 408
  name = tmp;
#line 409
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 410
    fatal("no matching mac found: client %s server %s", client, server);
  }
#line 411
  if (0) {
#line 411
    __s1_len___1 = strlen((char const   *)name);
#line 411
    __s2_len___1 = strlen("hmac-md5");
#line 411
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___4;
    } else {
#line 411
      if (__s1_len___1 >= 4U) {
        _L___4: /* CIL Label */ 
#line 411
        if (! ((unsigned int )((void const   *)("hmac-md5" + 1)) - (unsigned int )((void const   *)"hmac-md5") == 1U)) {
#line 411
          tmp___32 = 1;
        } else {
#line 411
          if (__s2_len___1 >= 4U) {
#line 411
            tmp___32 = 1;
          } else {
#line 411
            tmp___32 = 0;
          }
        }
      } else {
#line 411
        tmp___32 = 0;
      }
    }
#line 411
    if (tmp___32) {
#line 411
      tmp___28 = __builtin_strcmp((char const   *)name, "hmac-md5");
    } else {
#line 411
      tmp___31 = __builtin_strcmp((char const   *)name, "hmac-md5");
#line 411
      tmp___28 = tmp___31;
    }
  } else {
#line 411
    tmp___31 = __builtin_strcmp((char const   *)name, "hmac-md5");
#line 411
    tmp___28 = tmp___31;
  }
#line 411
  if (tmp___28 == 0) {
#line 412
    tmp___0 = EVP_md5();
#line 412
    mac->md = (EVP_MD *)tmp___0;
  } else {
#line 413
    if (0) {
#line 413
      __s1_len___0 = strlen((char const   *)name);
#line 413
      __s2_len___0 = strlen("hmac-sha1");
#line 413
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___2;
      } else {
#line 413
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 413
          if (! ((unsigned int )((void const   *)("hmac-sha1" + 1)) - (unsigned int )((void const   *)"hmac-sha1") == 1U)) {
#line 413
            tmp___22 = 1;
          } else {
#line 413
            if (__s2_len___0 >= 4U) {
#line 413
              tmp___22 = 1;
            } else {
#line 413
              tmp___22 = 0;
            }
          }
        } else {
#line 413
          tmp___22 = 0;
        }
      }
#line 413
      if (tmp___22) {
#line 413
        tmp___18 = __builtin_strcmp((char const   *)name, "hmac-sha1");
      } else {
#line 413
        tmp___21 = __builtin_strcmp((char const   *)name, "hmac-sha1");
#line 413
        tmp___18 = tmp___21;
      }
    } else {
#line 413
      tmp___21 = __builtin_strcmp((char const   *)name, "hmac-sha1");
#line 413
      tmp___18 = tmp___21;
    }
#line 413
    if (tmp___18 == 0) {
#line 414
      tmp___1 = EVP_sha1();
#line 414
      mac->md = (EVP_MD *)tmp___1;
    } else {
#line 415
      if (0) {
#line 415
        __s1_len = strlen((char const   *)name);
#line 415
        __s2_len = strlen("hmac-ripemd160@openssh.com");
#line 415
        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
          goto _L___0;
        } else {
#line 415
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 415
            if (! ((unsigned int )((void const   *)("hmac-ripemd160@openssh.com" + 1)) - (unsigned int )((void const   *)"hmac-ripemd160@openssh.com") == 1U)) {
#line 415
              tmp___12 = 1;
            } else {
#line 415
              if (__s2_len >= 4U) {
#line 415
                tmp___12 = 1;
              } else {
#line 415
                tmp___12 = 0;
              }
            }
          } else {
#line 415
            tmp___12 = 0;
          }
        }
#line 415
        if (tmp___12) {
#line 415
          tmp___8 = __builtin_strcmp((char const   *)name, "hmac-ripemd160@openssh.com");
        } else {
#line 415
          tmp___11 = __builtin_strcmp((char const   *)name, "hmac-ripemd160@openssh.com");
#line 415
          tmp___8 = tmp___11;
        }
      } else {
#line 415
        tmp___11 = __builtin_strcmp((char const   *)name, "hmac-ripemd160@openssh.com");
#line 415
        tmp___8 = tmp___11;
      }
#line 415
      if (tmp___8 == 0) {
#line 416
        tmp___2 = EVP_ripemd160();
#line 416
        mac->md = (EVP_MD *)tmp___2;
      } else {
#line 418
        fatal("unsupported mac %s", name);
      }
    }
  }
#line 420
  mac->name = name;
#line 421
  mac->mac_len = (mac->md)->md_size;
#line 422
  if (datafellows & 4) {
#line 422
    mac->key_len = 16;
  } else {
#line 422
    mac->key_len = mac->mac_len;
  }
#line 423
  mac->key = (unsigned char *)((void *)0);
#line 424
  mac->enabled = 0;
#line 425
  return;
}
}
#line 426 "kex.c"
void choose_comp(Comp *comp , char *client , char *server ) 
{ char *name ;
  char *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 429
  tmp = get_match(client, server);
#line 429
  name = tmp;
#line 430
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 431
    fatal("no matching comp found: client %s server %s", client, server);
  }
#line 432
  if (0) {
#line 432
    __s1_len___0 = strlen((char const   *)name);
#line 432
    __s2_len___0 = strlen("zlib");
#line 432
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___2;
    } else {
#line 432
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 432
        if (! ((unsigned int )((void const   *)("zlib" + 1)) - (unsigned int )((void const   *)"zlib") == 1U)) {
#line 432
          tmp___19 = 1;
        } else {
#line 432
          if (__s2_len___0 >= 4U) {
#line 432
            tmp___19 = 1;
          } else {
#line 432
            tmp___19 = 0;
          }
        }
      } else {
#line 432
        tmp___19 = 0;
      }
    }
#line 432
    if (tmp___19) {
#line 432
      tmp___15 = __builtin_strcmp((char const   *)name, "zlib");
    } else {
#line 432
      tmp___18 = __builtin_strcmp((char const   *)name, "zlib");
#line 432
      tmp___15 = tmp___18;
    }
  } else {
#line 432
    tmp___18 = __builtin_strcmp((char const   *)name, "zlib");
#line 432
    tmp___15 = tmp___18;
  }
#line 432
  if (tmp___15 == 0) {
#line 433
    comp->type = 1;
  } else {
#line 434
    if (0) {
#line 434
      __s1_len = strlen((char const   *)name);
#line 434
      __s2_len = strlen("none");
#line 434
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___0;
      } else {
#line 434
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 434
          if (! ((unsigned int )((void const   *)("none" + 1)) - (unsigned int )((void const   *)"none") == 1U)) {
#line 434
            tmp___9 = 1;
          } else {
#line 434
            if (__s2_len >= 4U) {
#line 434
              tmp___9 = 1;
            } else {
#line 434
              tmp___9 = 0;
            }
          }
        } else {
#line 434
          tmp___9 = 0;
        }
      }
#line 434
      if (tmp___9) {
#line 434
        tmp___5 = __builtin_strcmp((char const   *)name, "none");
      } else {
#line 434
        tmp___8 = __builtin_strcmp((char const   *)name, "none");
#line 434
        tmp___5 = tmp___8;
      }
    } else {
#line 434
      tmp___8 = __builtin_strcmp((char const   *)name, "none");
#line 434
      tmp___5 = tmp___8;
    }
#line 434
    if (tmp___5 == 0) {
#line 435
      comp->type = 0;
    } else {
#line 437
      fatal("unsupported comp %s", name);
    }
  }
#line 439
  comp->name = name;
#line 440
  return;
}
}
#line 441 "kex.c"
void choose_kex(Kex *k , char *client , char *server ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 444
  k->name = get_match(client, server);
#line 445
  if ((unsigned int )k->name == (unsigned int )((void *)0)) {
#line 446
    fatal("no kex alg");
  }
#line 447
  if (0) {
#line 447
    __s1_len___0 = strlen((char const   *)k->name);
#line 447
    __s2_len___0 = strlen("diffie-hellman-group1-sha1");
#line 447
    if (! ((unsigned int )((void const   *)(k->name + 1)) - (unsigned int )((void const   *)k->name) == 1U)) {
      goto _L___2;
    } else {
#line 447
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 447
        if (! ((unsigned int )((void const   *)("diffie-hellman-group1-sha1" + 1)) - (unsigned int )((void const   *)"diffie-hellman-group1-sha1") == 1U)) {
#line 447
          tmp___18 = 1;
        } else {
#line 447
          if (__s2_len___0 >= 4U) {
#line 447
            tmp___18 = 1;
          } else {
#line 447
            tmp___18 = 0;
          }
        }
      } else {
#line 447
        tmp___18 = 0;
      }
    }
#line 447
    if (tmp___18) {
#line 447
      tmp___14 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
    } else {
#line 447
      tmp___17 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
#line 447
      tmp___14 = tmp___17;
    }
  } else {
#line 447
    tmp___17 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
#line 447
    tmp___14 = tmp___17;
  }
#line 447
  if (tmp___14 == 0) {
#line 448
    k->kex_type = 0;
  } else {
#line 449
    if (0) {
#line 449
      __s1_len = strlen((char const   *)k->name);
#line 449
      __s2_len = strlen("diffie-hellman-group-exchange-sha1");
#line 449
      if (! ((unsigned int )((void const   *)(k->name + 1)) - (unsigned int )((void const   *)k->name) == 1U)) {
        goto _L___0;
      } else {
#line 449
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 449
          if (! ((unsigned int )((void const   *)("diffie-hellman-group-exchange-sha1" + 1)) - (unsigned int )((void const   *)"diffie-hellman-group-exchange-sha1") == 1U)) {
#line 449
            tmp___8 = 1;
          } else {
#line 449
            if (__s2_len >= 4U) {
#line 449
              tmp___8 = 1;
            } else {
#line 449
              tmp___8 = 0;
            }
          }
        } else {
#line 449
          tmp___8 = 0;
        }
      }
#line 449
      if (tmp___8) {
#line 449
        tmp___4 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha1");
      } else {
#line 449
        tmp___7 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha1");
#line 449
        tmp___4 = tmp___7;
      }
    } else {
#line 449
      tmp___7 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha1");
#line 449
      tmp___4 = tmp___7;
    }
#line 449
    if (tmp___4 == 0) {
#line 450
      k->kex_type = 1;
    } else {
#line 452
      fatal("bad kex alg %s", k->name);
    }
  }
#line 453
  return;
}
}
#line 454 "kex.c"
void choose_hostkeyalg(Kex *k , char *client , char *server ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 457
  k->hostkeyalg = get_match(client, server);
#line 458
  if ((unsigned int )k->hostkeyalg == (unsigned int )((void *)0)) {
#line 459
    fatal("no hostkey alg");
  }
#line 460
  if (0) {
#line 460
    __s1_len = strlen((char const   *)k->hostkeyalg);
#line 460
    __s2_len = strlen("ssh-dss");
#line 460
    if (! ((unsigned int )((void const   *)(k->hostkeyalg + 1)) - (unsigned int )((void const   *)k->hostkeyalg) == 1U)) {
      goto _L___0;
    } else {
#line 460
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 460
        if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
#line 460
          tmp___8 = 1;
        } else {
#line 460
          if (__s2_len >= 4U) {
#line 460
            tmp___8 = 1;
          } else {
#line 460
            tmp___8 = 0;
          }
        }
      } else {
#line 460
        tmp___8 = 0;
      }
    }
#line 460
    if (tmp___8) {
#line 460
      tmp___4 = __builtin_strcmp((char const   *)k->hostkeyalg, "ssh-dss");
    } else {
#line 460
      tmp___7 = __builtin_strcmp((char const   *)k->hostkeyalg, "ssh-dss");
#line 460
      tmp___4 = tmp___7;
    }
  } else {
#line 460
    tmp___7 = __builtin_strcmp((char const   *)k->hostkeyalg, "ssh-dss");
#line 460
    tmp___4 = tmp___7;
  }
#line 460
  if (tmp___4 != 0) {
#line 461
    fatal("bad hostkey alg %s", k->hostkeyalg);
  }
#line 462
  return;
}
}
#line 464 "kex.c"
Kex *kex_choose_conf(char **cprop , char **sprop , int server ) 
{ int mode ;
  int ctos ;
  int need ;
  Kex *k ;
  void *tmp ;
  int nenc ;
  int nmac ;
  int ncomp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 472
  tmp = xmalloc(sizeof(*k));
#line 472
  k = (Kex *)tmp;
#line 473
  memset((void *)k, 0, sizeof(*k));
#line 474
  k->server = server;
#line 476
  mode = 0;
#line 476
  while (mode < 2) {
#line 478
    if (! k->server) {
#line 478
      if (mode == 1) {
#line 478
        tmp___0 = 1;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 478
      if (k->server) {
#line 478
        if (mode == 0) {
#line 478
          tmp___0 = 1;
        } else {
#line 478
          tmp___0 = 0;
        }
      } else {
#line 478
        tmp___0 = 0;
      }
    }
#line 478
    ctos = tmp___0;
#line 479
    if (ctos) {
#line 479
      nenc = 2;
    } else {
#line 479
      nenc = 3;
    }
#line 480
    if (ctos) {
#line 480
      nmac = 4;
    } else {
#line 480
      nmac = 5;
    }
#line 481
    if (ctos) {
#line 481
      ncomp = 6;
    } else {
#line 481
      ncomp = 7;
    }
#line 482
    choose_enc(& k->enc[mode], *(cprop + nenc), *(sprop + nenc));
#line 483
    choose_mac(& k->mac[mode], *(cprop + nmac), *(sprop + nmac));
#line 484
    choose_comp(& k->comp[mode], *(cprop + ncomp), *(sprop + ncomp));
#line 485
    if (ctos) {
#line 485
      tmp___1 = "client->server";
    } else {
#line 485
      tmp___1 = "server->client";
    }
#line 485
    debug("kex: %s %s %s %s", tmp___1, k->enc[mode].name, k->mac[mode].name, k->comp[mode].name);
#line 476
    mode ++;
  }
#line 491
  choose_kex(k, *(cprop + 0), *(sprop + 0));
#line 492
  choose_hostkeyalg(k, *(cprop + 1), *(sprop + 1));
#line 494
  need = 0;
#line 495
  mode = 0;
#line 495
  while (mode < 2) {
#line 496
    if ((u_int )need < (k->enc[mode].cipher)->key_len) {
#line 497
      need = (int )(k->enc[mode].cipher)->key_len;
    }
#line 498
    if ((u_int )need < (k->enc[mode].cipher)->block_size) {
#line 499
      need = (int )(k->enc[mode].cipher)->block_size;
    }
#line 500
    if (need < k->mac[mode].key_len) {
#line 501
      need = k->mac[mode].key_len;
    }
#line 495
    mode ++;
  }
#line 504
  k->we_need = need;
#line 505
  return (k);
}
}
#line 508 "kex.c"
int kex_derive_keys(Kex *k , unsigned char *hash , BIGNUM *shared_secret ) 
{ int i ;
  int mode ;
  int ctos ;
  unsigned char *keys[6] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 516
  i = 0;
#line 516
  while (i < 6) {
#line 517
    keys[i] = derive_key(65 + i, k->we_need, hash, shared_secret);
#line 516
    i ++;
  }
#line 519
  mode = 0;
#line 519
  while (mode < 2) {
#line 520
    if (! k->server) {
#line 520
      if (mode == 1) {
#line 520
        tmp = 1;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 520
      if (k->server) {
#line 520
        if (mode == 0) {
#line 520
          tmp = 1;
        } else {
#line 520
          tmp = 0;
        }
      } else {
#line 520
        tmp = 0;
      }
    }
#line 520
    ctos = tmp;
#line 521
    if (ctos) {
#line 521
      tmp___0 = 0;
    } else {
#line 521
      tmp___0 = 1;
    }
#line 521
    k->enc[mode].iv = keys[tmp___0];
#line 522
    if (ctos) {
#line 522
      tmp___1 = 2;
    } else {
#line 522
      tmp___1 = 3;
    }
#line 522
    k->enc[mode].key = keys[tmp___1];
#line 523
    if (ctos) {
#line 523
      tmp___2 = 4;
    } else {
#line 523
      tmp___2 = 5;
    }
#line 523
    k->mac[mode].key = keys[tmp___2];
#line 519
    mode ++;
  }
#line 525
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 1 "log.o"
#line 646 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 453 "ssh.h"
void do_log(LogLevel level , char const   *fmt , va_list args ) ;
#line 456
SyslogFacility log_facility_number(char *name ) ;
#line 457
LogLevel log_level_number(char *name ) ;
#line 479
void fatal_remove_cleanup(void (*proc)(void *context ) , void *context ) ;
#line 46 "log.c"
void ( /* format attribute */  fatal)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 50
  __builtin_va_start(args, fmt);
#line 51
  do_log(1, fmt, args);
#line 52
  __builtin_va_end(args);
#line 53
  fatal_cleanup();
#line 54
  return;
}
}
#line 58 "log.c"
void ( /* format attribute */  error)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 62
  __builtin_va_start(args, fmt);
#line 63
  do_log(2, fmt, args);
#line 64
  __builtin_va_end(args);
#line 65
  return;
}
}
#line 69 "log.c"
void ( /* format attribute */  log)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 73
  __builtin_va_start(args, fmt);
#line 74
  do_log(3, fmt, args);
#line 75
  __builtin_va_end(args);
#line 76
  return;
}
}
#line 80 "log.c"
void ( /* format attribute */  verbose)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 84
  __builtin_va_start(args, fmt);
#line 85
  do_log(4, fmt, args);
#line 86
  __builtin_va_end(args);
#line 87
  return;
}
}
#line 91 "log.c"
void ( /* format attribute */  debug)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 95
  __builtin_va_start(args, fmt);
#line 96
  do_log(5, fmt, args);
#line 97
  __builtin_va_end(args);
#line 98
  return;
}
}
#line 100 "log.c"
void ( /* format attribute */  debug2)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 104
  __builtin_va_start(args, fmt);
#line 105
  do_log(6, fmt, args);
#line 106
  __builtin_va_end(args);
#line 107
  return;
}
}
#line 109 "log.c"
void ( /* format attribute */  debug3)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 113
  __builtin_va_start(args, fmt);
#line 114
  do_log(7, fmt, args);
#line 115
  __builtin_va_end(args);
#line 116
  return;
}
}
#line 126 "log.c"
static struct fatal_cleanup *fatal_cleanups  =    (struct fatal_cleanup *)((void *)0);
#line 130 "log.c"
void fatal_add_cleanup(void (*proc)(void *context ) , void *context ) 
{ struct fatal_cleanup *cu ;
  void *tmp ;

  {
#line 135
  tmp = xmalloc(sizeof(*cu));
#line 135
  cu = (struct fatal_cleanup *)tmp;
#line 136
  cu->proc = proc;
#line 137
  cu->context = context;
#line 138
  cu->next = fatal_cleanups;
#line 139
  fatal_cleanups = cu;
#line 140
  return;
}
}
#line 144 "log.c"
void fatal_remove_cleanup(void (*proc)(void *context ) , void *context ) 
{ struct fatal_cleanup **cup ;
  struct fatal_cleanup *cu ;

  {
#line 149
  cup = & fatal_cleanups;
#line 149
  while (*cup) {
#line 150
    cu = *cup;
#line 151
    if ((unsigned int )cu->proc == (unsigned int )proc) {
#line 151
      if ((unsigned int )cu->context == (unsigned int )context) {
#line 152
        *cup = cu->next;
#line 153
        xfree((void *)cu);
#line 154
        return;
      }
    }
#line 149
    cup = & cu->next;
  }
#line 157
  fatal("fatal_remove_cleanup: no such cleanup function: 0x%lx 0x%lx\n", (unsigned long )proc,
        (unsigned long )context);
#line 159
  return;
}
}
#line 166 "log.c"
static int called  =    0;
#line 162 "log.c"
void fatal_cleanup(void) 
{ struct fatal_cleanup *cu ;
  struct fatal_cleanup *next_cu ;

  {
#line 168
  if (called) {
#line 169
    exit(255);
  }
#line 170
  called = 1;
#line 172
  cu = fatal_cleanups;
#line 172
  while (cu) {
#line 173
    next_cu = cu->next;
#line 174
    debug("Calling cleanup 0x%lx(0x%lx)", (unsigned long )cu->proc, (unsigned long )cu->context);
#line 176
    (*(cu->proc))(cu->context);
#line 172
    cu = next_cu;
  }
#line 178
  exit(255);
}
}
#line 183 "log.c"
static struct __anonstruct_log_facilities_75 log_facilities[12]  = 
#line 183
  {      {"DAEMON", 0}, 
        {"USER", 1}, 
        {"AUTH", 2}, 
        {"LOCAL0", 3}, 
        {"LOCAL1", 4}, 
        {"LOCAL2", 5}, 
        {"LOCAL3", 6}, 
        {"LOCAL4", 7}, 
        {"LOCAL5", 8}, 
        {"LOCAL6", 9}, 
        {"LOCAL7", 10}, 
        {(char const   *)((void *)0), (SyslogFacility )0}};
#line 201 "log.c"
static struct __anonstruct_log_levels_76 log_levels[10]  = 
#line 201
  {      {"QUIET", 0}, 
        {"FATAL", 1}, 
        {"ERROR", 2}, 
        {"INFO", 3}, 
        {"VERBOSE", 4}, 
        {"DEBUG", 5}, 
        {"DEBUG1", 5}, 
        {"DEBUG2", 6}, 
        {"DEBUG3", 7}, 
        {(char const   *)((void *)0), (LogLevel )0}};
#line 218 "log.c"
SyslogFacility log_facility_number(char *name ) 
{ int i ;
  int tmp ;

  {
#line 222
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 223
    i = 0;
#line 223
    while (log_facilities[i].name) {
#line 224
      tmp = strcasecmp(log_facilities[i].name, (char const   *)name);
#line 224
      if (tmp == 0) {
#line 225
        return (log_facilities[i].val);
      }
#line 223
      i ++;
    }
  }
#line 226
  return ((enum __anonenum_SyslogFacility_73 )-1);
}
}
#line 229 "log.c"
LogLevel log_level_number(char *name ) 
{ int i ;
  int tmp ;

  {
#line 233
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 234
    i = 0;
#line 234
    while (log_levels[i].name) {
#line 235
      tmp = strcasecmp(log_levels[i].name, (char const   *)name);
#line 235
      if (tmp == 0) {
#line 236
        return (log_levels[i].val);
      }
#line 234
      i ++;
    }
  }
#line 237
  return ((enum __anonenum_LogLevel_74 )-1);
}
}
#line 1 "match.o"
#line 116 "/usr/include/ctype.h"
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 24 "match.c"
int match_pattern(char const   *s , char const   *pattern ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 27
  while (1) {
#line 29
    if (! *pattern) {
#line 30
      return (! *s);
    }
#line 32
    if ((int const   )*pattern == 42) {
#line 34
      pattern ++;
#line 37
      if (! *pattern) {
#line 38
        return (1);
      }
#line 41
      if ((int const   )*pattern != 63) {
#line 41
        if ((int const   )*pattern != 42) {
#line 47
          while (*s) {
#line 48
            if ((int const   )*s == (int const   )*pattern) {
#line 48
              tmp = match_pattern(s + 1, pattern + 1);
#line 48
              if (tmp) {
#line 50
                return (1);
              }
            }
#line 47
            s ++;
          }
#line 52
          return (0);
        }
      }
#line 58
      while (*s) {
#line 59
        tmp___0 = match_pattern(s, pattern);
#line 59
        if (tmp___0) {
#line 60
          return (1);
        }
#line 58
        s ++;
      }
#line 62
      return (0);
    }
#line 68
    if (! *s) {
#line 69
      return (0);
    }
#line 72
    if ((int const   )*pattern != 63) {
#line 72
      if ((int const   )*pattern != (int const   )*s) {
#line 73
        return (0);
      }
    }
#line 76
    s ++;
#line 77
    pattern ++;
  }
}
}
#line 89 "match.c"
int match_hostname(char const   *host , char const   *pattern , unsigned int len ) 
{ char sub[1024] ;
  int negated ;
  int got_positive ;
  unsigned int i ;
  unsigned int subi ;
  int __res___0 ;
  __int32_t const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;

  {
#line 97
  got_positive = 0;
#line 98
  i = 0U;
#line 98
  while (i < len) {
#line 100
    if ((int const   )*(pattern + i) == 33) {
#line 101
      negated = 1;
#line 102
      i ++;
    } else {
#line 104
      negated = 0;
    }
#line 110
    subi = 0U;
#line 110
    while (1) {
#line 110
      if (i < len) {
#line 110
        if (subi < sizeof(sub) - 1U) {
#line 110
          if (! ((int const   )*(pattern + i) != 44)) {
#line 110
            break;
          }
        } else {
#line 110
          break;
        }
      } else {
#line 110
        break;
      }
#line 113
      tmp___6 = __ctype_b_loc();
#line 113
      if ((int const   )*(*tmp___6 + (int )*(pattern + i)) & 256) {
#line 113
        if (sizeof(*(pattern + i)) > 1U) {
#line 113
          __res___0 = tolower((int )*(pattern + i));
        } else {
#line 113
          tmp___5 = __ctype_tolower_loc();
#line 113
          __res___0 = (int )*(*tmp___5 + (int )*(pattern + i));
        }
#line 113
        sub[subi] = (char )__res___0;
      } else {
#line 113
        sub[subi] = (char )*(pattern + i);
      }
#line 110
      subi ++;
#line 110
      i ++;
    }
#line 115
    if (subi >= sizeof(sub) - 1U) {
#line 116
      return (0);
    }
#line 119
    if (i < len) {
#line 119
      if ((int const   )*(pattern + i) == 44) {
#line 120
        i ++;
      }
    }
#line 123
    sub[subi] = (char )'\000';
#line 126
    tmp___7 = match_pattern(host, (char const   *)(sub));
#line 126
    if (tmp___7) {
#line 127
      if (negated) {
#line 128
        return (-1);
      } else {
#line 130
        got_positive = 1;
      }
    }
  }
#line 138
  return (got_positive);
}
}
#line 1 "mpaux.o"
#line 24 "mpaux.c"
void compute_session_id(unsigned char *session_id___0 , unsigned char *cookie , BIGNUM *host_key_n ,
                        BIGNUM *session_key_n ) 
{ unsigned int host_key_bytes ;
  int tmp ;
  unsigned int session_key_bytes ;
  int tmp___0 ;
  unsigned int bytes ;
  unsigned char *buf___1 ;
  void *tmp___1 ;
  MD5_CTX md ;

  {
#line 30
  tmp = BN_num_bits((BIGNUM const   *)host_key_n);
#line 30
  host_key_bytes = (unsigned int )((tmp + 7) / 8);
#line 31
  tmp___0 = BN_num_bits((BIGNUM const   *)session_key_n);
#line 31
  session_key_bytes = (unsigned int )((tmp___0 + 7) / 8);
#line 32
  bytes = host_key_bytes + session_key_bytes;
#line 33
  tmp___1 = xmalloc(bytes);
#line 33
  buf___1 = (unsigned char *)tmp___1;
#line 36
  BN_bn2bin((BIGNUM const   *)host_key_n, buf___1);
#line 37
  BN_bn2bin((BIGNUM const   *)session_key_n, buf___1 + host_key_bytes);
#line 38
  MD5_Init(& md);
#line 39
  MD5_Update(& md, (void const   *)buf___1, bytes);
#line 40
  MD5_Update(& md, (void const   *)cookie, 8U);
#line 41
  MD5_Final((unsigned char *)session_id___0, & md);
#line 42
  memset((void *)buf___1, 0, bytes);
#line 43
  xfree((void *)buf___1);
#line 44
  return;
}
}
#line 1 "nchan.o"
#line 43 "nchan.c"
chan_event_fn *chan_rcvd_oclose  =    (chan_event_fn *)((void *)0);
#line 44 "nchan.c"
chan_event_fn *chan_read_failed  =    (chan_event_fn *)((void *)0);
#line 45 "nchan.c"
chan_event_fn *chan_ibuf_empty  =    (chan_event_fn *)((void *)0);
#line 47 "nchan.c"
chan_event_fn *chan_rcvd_ieof  =    (chan_event_fn *)((void *)0);
#line 48 "nchan.c"
chan_event_fn *chan_write_failed  =    (chan_event_fn *)((void *)0);
#line 49 "nchan.c"
chan_event_fn *chan_obuf_empty  =    (chan_event_fn *)((void *)0);
#line 53
static void chan_send_ieof1(Channel *c ) ;
#line 54
static void chan_send_oclose1(Channel *c ) ;
#line 55
static void chan_send_close2(Channel *c ) ;
#line 56
static void chan_send_eof2(Channel *c ) ;
#line 59 "nchan.c"
chan_event_fn *chan_delete_if_full_closed  =    (chan_event_fn *)((void *)0);
#line 62
static void chan_shutdown_write(Channel *c ) ;
#line 63
static void chan_shutdown_read(Channel *c ) ;
#line 69 "nchan.c"
static void chan_rcvd_oclose1(Channel *c ) 
{ 

  {
#line 72
  debug("channel %d: rcvd oclose", c->self);
#line 73
  switch (c->istate) {
  case 4: 
#line 75
  debug("channel %d: input wait_oclose -> closed", c->self);
#line 76
  c->istate = 8;
#line 77
  break;
  case 1: 
#line 79
  debug("channel %d: input open -> closed", c->self);
#line 80
  chan_shutdown_read(c);
#line 81
  chan_send_ieof1(c);
#line 82
  c->istate = 8;
#line 83
  break;
  case 2: 
#line 86
  log("channel %d: input drain -> closed", c->self);
#line 87
  chan_send_ieof1(c);
#line 88
  c->istate = 8;
#line 89
  break;
  default: 
#line 91
  error("channel %d: protocol error: chan_rcvd_oclose for istate %d", c->self, c->istate);
#line 93
  return;
  }
#line 95
  return;
}
}
#line 96 "nchan.c"
static void chan_read_failed_12(Channel *c ) 
{ unsigned int tmp ;

  {
#line 99
  debug("channel %d: read failed", c->self);
#line 100
  switch (c->istate) {
  case 1: 
#line 102
  debug("channel %d: input open -> drain", c->self);
#line 103
  chan_shutdown_read(c);
#line 104
  c->istate = 2;
#line 105
  tmp = buffer_len(& c->input);
#line 105
  if (tmp == 0U) {
#line 106
    debug("channel %d: input: no drain shortcut", c->self);
#line 107
    (*chan_ibuf_empty)(c);
  }
#line 109
  break;
  default: 
#line 111
  error("channel %d: internal error: we do not read, but chan_read_failed for istate %d",
        c->self, c->istate);
#line 113
  break;
  }
#line 115
  return;
}
}
#line 116 "nchan.c"
static void chan_ibuf_empty1(Channel *c ) 
{ unsigned int tmp ;

  {
#line 119
  debug("channel %d: ibuf empty", c->self);
#line 120
  tmp = buffer_len(& c->input);
#line 120
  if (tmp) {
#line 121
    error("channel %d: internal error: chan_ibuf_empty for non empty buffer", c->self);
#line 123
    return;
  }
#line 125
  switch (c->istate) {
  case 2: 
#line 127
  debug("channel %d: input drain -> wait_oclose", c->self);
#line 128
  chan_send_ieof1(c);
#line 129
  c->istate = 4;
#line 130
  break;
  default: 
#line 132
  error("channel %d: internal error: chan_ibuf_empty for istate %d", c->self, c->istate);
#line 134
  break;
  }
#line 136
  return;
}
}
#line 137 "nchan.c"
static void chan_rcvd_ieof1(Channel *c ) 
{ 

  {
#line 140
  debug("channel %d: rcvd ieof", c->self);
#line 141
  if (c->type != 4) {
#line 142
    debug("channel %d: non-open", c->self);
#line 143
    if (c->istate == 1) {
#line 144
      debug("channel %d: non-open: input open -> wait_oclose", c->self);
#line 145
      chan_shutdown_read(c);
#line 146
      chan_send_ieof1(c);
#line 147
      c->istate = 4;
    } else {
#line 149
      error("channel %d: istate %d != open", c->self, c->istate);
    }
#line 151
    if (c->ostate == 16) {
#line 152
      debug("channel %d: non-open: output open -> closed", c->self);
#line 153
      chan_send_oclose1(c);
#line 154
      c->ostate = 128;
    } else {
#line 156
      error("channel %d: ostate %d != open", c->self, c->ostate);
    }
#line 158
    return;
  }
#line 160
  switch (c->ostate) {
  case 16: 
#line 162
  debug("channel %d: output open -> drain", c->self);
#line 163
  c->ostate = 32;
#line 164
  break;
  case 64: 
#line 166
  debug("channel %d: output wait_ieof -> closed", c->self);
#line 167
  c->ostate = 128;
#line 168
  break;
  default: 
#line 170
  error("channel %d: protocol error: chan_rcvd_ieof for ostate %d", c->self, c->ostate);
#line 172
  break;
  }
#line 174
  return;
}
}
#line 175 "nchan.c"
static void chan_write_failed1(Channel *c ) 
{ 

  {
#line 178
  debug("channel %d: write failed", c->self);
#line 179
  switch (c->ostate) {
  case 16: 
#line 181
  debug("channel %d: output open -> wait_ieof", c->self);
#line 182
  chan_send_oclose1(c);
#line 183
  c->ostate = 64;
#line 184
  break;
  case 32: 
#line 186
  debug("channel %d: output wait_drain -> closed", c->self);
#line 187
  chan_send_oclose1(c);
#line 188
  c->ostate = 128;
#line 189
  break;
  default: 
#line 191
  error("channel %d: internal error: chan_write_failed for ostate %d", c->self, c->ostate);
#line 193
  break;
  }
#line 195
  return;
}
}
#line 196 "nchan.c"
static void chan_obuf_empty1(Channel *c ) 
{ unsigned int tmp ;

  {
#line 199
  debug("channel %d: obuf empty", c->self);
#line 200
  tmp = buffer_len(& c->output);
#line 200
  if (tmp) {
#line 201
    error("channel %d: internal error: chan_obuf_empty for non empty buffer", c->self);
#line 203
    return;
  }
#line 205
  switch (c->ostate) {
  case 32: 
#line 207
  debug("channel %d: output drain -> closed", c->self);
#line 208
  chan_send_oclose1(c);
#line 209
  c->ostate = 128;
#line 210
  break;
  default: 
#line 212
  error("channel %d: internal error: chan_obuf_empty for ostate %d", c->self, c->ostate);
#line 214
  break;
  }
#line 216
  return;
}
}
#line 217 "nchan.c"
static void chan_send_ieof1(Channel *c ) 
{ 

  {
#line 220
  debug("channel %d: send ieof", c->self);
#line 221
  switch (c->istate) {
  case 1: 
  case 2: 
#line 224
  packet_start(24);
#line 225
  packet_put_int((unsigned int )c->remote_id);
#line 226
  packet_send();
#line 227
  break;
  default: 
#line 229
  error("channel %d: internal error: cannot send ieof for istate %d", c->self, c->istate);
#line 231
  break;
  }
#line 233
  return;
}
}
#line 234 "nchan.c"
static void chan_send_oclose1(Channel *c ) 
{ unsigned int tmp ;

  {
#line 237
  debug("channel %d: send oclose", c->self);
#line 238
  switch (c->ostate) {
  case 16: 
  case 32: 
#line 241
  chan_shutdown_write(c);
#line 242
  tmp = buffer_len(& c->output);
#line 242
  buffer_consume(& c->output, tmp);
#line 243
  packet_start(25);
#line 244
  packet_put_int((unsigned int )c->remote_id);
#line 245
  packet_send();
#line 246
  break;
  default: 
#line 248
  error("channel %d: internal error: cannot send oclose for ostate %d", c->self, c->ostate);
#line 250
  break;
  }
#line 252
  return;
}
}
#line 253 "nchan.c"
static void chan_delete_if_full_closed1(Channel *c ) 
{ 

  {
#line 256
  if (c->istate == 8) {
#line 256
    if (c->ostate == 128) {
#line 257
      debug("channel %d: full closed", c->self);
#line 258
      channel_free(c->self);
    }
  }
#line 260
  return;
}
}
#line 265 "nchan.c"
static void chan_rcvd_oclose2(Channel *c ) 
{ 

  {
#line 268
  debug("channel %d: rcvd close", c->self);
#line 269
  if (c->flags & 2) {
#line 270
    error("channel %d: protocol error: close rcvd twice", c->self);
  }
#line 271
  c->flags |= 2;
#line 272
  if (c->type == 10) {
#line 274
    c->ostate = 128;
#line 275
    c->istate = 8;
#line 276
    return;
  }
#line 278
  switch (c->ostate) {
  case 16: 
#line 281
  debug("channel %d: output open -> drain", c->self);
#line 282
  c->ostate = 32;
#line 283
  break;
  }
#line 285
  switch (c->istate) {
  case 1: 
#line 287
  debug("channel %d: input open -> closed", c->self);
#line 288
  chan_shutdown_read(c);
#line 289
  break;
  case 2: 
#line 291
  debug("channel %d: input drain -> closed", c->self);
#line 292
  chan_send_eof2(c);
#line 293
  break;
  }
#line 295
  c->istate = 8;
#line 296
  return;
}
}
#line 297 "nchan.c"
static void chan_ibuf_empty2(Channel *c ) 
{ unsigned int tmp ;

  {
#line 300
  debug("channel %d: ibuf empty", c->self);
#line 301
  tmp = buffer_len(& c->input);
#line 301
  if (tmp) {
#line 302
    error("channel %d: internal error: chan_ibuf_empty for non empty buffer", c->self);
#line 304
    return;
  }
#line 306
  switch (c->istate) {
  case 2: 
#line 308
  debug("channel %d: input drain -> closed", c->self);
#line 309
  if (! (c->flags & 1)) {
#line 310
    chan_send_eof2(c);
  }
#line 311
  c->istate = 8;
#line 312
  break;
  default: 
#line 314
  error("channel %d: internal error: chan_ibuf_empty for istate %d", c->self, c->istate);
#line 316
  break;
  }
#line 318
  return;
}
}
#line 319 "nchan.c"
static void chan_rcvd_ieof2(Channel *c ) 
{ 

  {
#line 322
  debug("channel %d: rcvd eof", c->self);
#line 323
  if (c->ostate == 16) {
#line 324
    debug("channel %d: output open -> drain", c->self);
#line 325
    c->ostate = 32;
  }
#line 327
  return;
}
}
#line 328 "nchan.c"
static void chan_write_failed2(Channel *c ) 
{ 

  {
#line 331
  debug("channel %d: write failed", c->self);
#line 332
  switch (c->ostate) {
  case 16: 
#line 334
  debug("channel %d: output open -> closed", c->self);
#line 335
  chan_shutdown_write(c);
#line 336
  c->ostate = 128;
#line 337
  break;
  case 32: 
#line 339
  debug("channel %d: output drain -> closed", c->self);
#line 340
  chan_shutdown_write(c);
#line 341
  c->ostate = 128;
#line 342
  break;
  default: 
#line 344
  error("channel %d: internal error: chan_write_failed for ostate %d", c->self, c->ostate);
#line 346
  break;
  }
#line 348
  return;
}
}
#line 349 "nchan.c"
static void chan_obuf_empty2(Channel *c ) 
{ unsigned int tmp ;

  {
#line 352
  debug("channel %d: obuf empty", c->self);
#line 353
  tmp = buffer_len(& c->output);
#line 353
  if (tmp) {
#line 354
    error("internal error: chan_obuf_empty %d for non empty buffer", c->self);
#line 356
    return;
  }
#line 358
  switch (c->ostate) {
  case 32: 
#line 360
  debug("channel %d: output drain -> closed", c->self);
#line 361
  chan_shutdown_write(c);
#line 362
  c->ostate = 128;
#line 363
  break;
  default: 
#line 365
  error("channel %d: internal error: chan_obuf_empty for ostate %d", c->self, c->ostate);
#line 367
  break;
  }
#line 369
  return;
}
}
#line 370 "nchan.c"
static void chan_send_eof2(Channel *c ) 
{ 

  {
#line 373
  debug("channel %d: send eof", c->self);
#line 374
  switch (c->istate) {
  case 2: 
#line 376
  packet_start(96);
#line 377
  packet_put_int((unsigned int )c->remote_id);
#line 378
  packet_send();
#line 379
  break;
  default: 
#line 381
  error("channel %d: internal error: cannot send eof for istate %d", c->self, c->istate);
#line 383
  break;
  }
#line 385
  return;
}
}
#line 386 "nchan.c"
static void chan_send_close2(Channel *c ) 
{ 

  {
#line 389
  debug("channel %d: send close", c->self);
#line 390
  if (c->ostate != 128) {
#line 392
    error("channel %d: internal error: cannot send close for istate/ostate %d/%d",
          c->self, c->istate, c->ostate);
  } else {
#line 390
    if (c->istate != 8) {
#line 392
      error("channel %d: internal error: cannot send close for istate/ostate %d/%d",
            c->self, c->istate, c->ostate);
    } else {
#line 394
      if (c->flags & 1) {
#line 395
        error("channel %d: internal error: already sent close", c->self);
      } else {
#line 397
        packet_start(97);
#line 398
        packet_put_int((unsigned int )c->remote_id);
#line 399
        packet_send();
#line 400
        c->flags |= 1;
      }
    }
  }
#line 402
  return;
}
}
#line 403 "nchan.c"
static void chan_delete_if_full_closed2(Channel *c ) 
{ 

  {
#line 406
  if (c->istate == 8) {
#line 406
    if (c->ostate == 128) {
#line 407
      if (! (c->flags & 1)) {
#line 408
        chan_send_close2(c);
      }
#line 410
      if (c->flags & 1) {
#line 410
        if (c->flags & 2) {
#line 412
          debug("channel %d: full closed2", c->self);
#line 413
          channel_free(c->self);
        }
      }
    }
  }
#line 416
  return;
}
}
#line 419 "nchan.c"
void chan_init_iostates(Channel *c ) 
{ 

  {
#line 422
  c->ostate = 16;
#line 423
  c->istate = 1;
#line 424
  c->flags = 0;
#line 425
  return;
}
}
#line 428 "nchan.c"
void chan_init(void) 
{ 

  {
#line 431
  if (compat20) {
#line 432
    chan_rcvd_oclose = & chan_rcvd_oclose2;
#line 433
    chan_read_failed = & chan_read_failed_12;
#line 434
    chan_ibuf_empty = & chan_ibuf_empty2;
#line 436
    chan_rcvd_ieof = & chan_rcvd_ieof2;
#line 437
    chan_write_failed = & chan_write_failed2;
#line 438
    chan_obuf_empty = & chan_obuf_empty2;
#line 440
    chan_delete_if_full_closed = & chan_delete_if_full_closed2;
  } else {
#line 442
    chan_rcvd_oclose = & chan_rcvd_oclose1;
#line 443
    chan_read_failed = & chan_read_failed_12;
#line 444
    chan_ibuf_empty = & chan_ibuf_empty1;
#line 446
    chan_rcvd_ieof = & chan_rcvd_ieof1;
#line 447
    chan_write_failed = & chan_write_failed1;
#line 448
    chan_obuf_empty = & chan_obuf_empty1;
#line 450
    chan_delete_if_full_closed = & chan_delete_if_full_closed1;
  }
#line 452
  return;
}
}
#line 455 "nchan.c"
static void chan_shutdown_write(Channel *c ) 
{ unsigned int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 458
  tmp = buffer_len(& c->output);
#line 458
  buffer_consume(& c->output, tmp);
#line 459
  if (compat20) {
#line 459
    if (c->type == 10) {
#line 460
      return;
    }
  }
#line 462
  debug("channel %d: close_write", c->self);
#line 463
  if (c->sock != -1) {
#line 464
    tmp___2 = shutdown(c->sock, 1);
#line 464
    if (tmp___2 < 0) {
#line 465
      tmp___0 = __errno_location();
#line 465
      tmp___1 = strerror(*tmp___0);
#line 465
      debug("channel %d: chan_shutdown_write: shutdown() failed for fd%d: %.100s",
            c->self, c->sock, tmp___1);
    }
  } else {
#line 468
    tmp___5 = close(c->wfd);
#line 468
    if (tmp___5 < 0) {
#line 469
      tmp___3 = __errno_location();
#line 469
      tmp___4 = strerror(*tmp___3);
#line 469
      log("channel %d: chan_shutdown_write: close() failed for fd%d: %.100s", c->self,
          c->wfd, tmp___4);
    }
#line 471
    c->wfd = -1;
  }
#line 473
  return;
}
}
#line 474 "nchan.c"
static void chan_shutdown_read(Channel *c ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 477
  if (compat20) {
#line 477
    if (c->type == 10) {
#line 478
      return;
    }
  }
#line 479
  debug("channel %d: close_read", c->self);
#line 480
  if (c->sock != -1) {
#line 485
    tmp___1 = shutdown(c->sock, 0);
#line 485
    if (tmp___1 < 0) {
#line 485
      tmp___2 = __errno_location();
#line 485
      if (*tmp___2 != 107) {
#line 489
        tmp = __errno_location();
#line 489
        tmp___0 = strerror(*tmp);
#line 489
        error("channel %d: chan_shutdown_read: shutdown() failed for fd%d [i%d o%d]: %.100s",
              c->self, c->sock, c->istate, c->ostate, tmp___0);
      } else {
#line 485
        if (c->ostate == 16) {
#line 489
          tmp = __errno_location();
#line 489
          tmp___0 = strerror(*tmp);
#line 489
          error("channel %d: chan_shutdown_read: shutdown() failed for fd%d [i%d o%d]: %.100s",
                c->self, c->sock, c->istate, c->ostate, tmp___0);
        } else {
#line 485
          if (c->ostate == 32) {
#line 489
            tmp = __errno_location();
#line 489
            tmp___0 = strerror(*tmp);
#line 489
            error("channel %d: chan_shutdown_read: shutdown() failed for fd%d [i%d o%d]: %.100s",
                  c->self, c->sock, c->istate, c->ostate, tmp___0);
          }
        }
      }
    }
  } else {
#line 492
    tmp___5 = close(c->rfd);
#line 492
    if (tmp___5 < 0) {
#line 493
      tmp___3 = __errno_location();
#line 493
      tmp___4 = strerror(*tmp___3);
#line 493
      log("channel %d: chan_shutdown_read: close() failed for fd%d: %.100s", c->self,
          c->rfd, tmp___4);
    }
#line 495
    c->rfd = -1;
  }
#line 497
  return;
}
}
#line 1 "packet.o"
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 361 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 26 "packet.h"
void packet_set_connection(int fd_in , int fd_out ) ;
#line 29
void packet_set_nonblocking(void) ;
#line 35
int packet_get_connection_out(void) ;
#line 41
void packet_close(void) ;
#line 48
void packet_set_encryption_key(unsigned char const   *key , unsigned int keylen ,
                               int number ) ;
#line 56
void packet_set_protocol_flags(unsigned int protocol_flags ) ;
#line 59
unsigned int packet_get_protocol_flags(void) ;
#line 62
void packet_start_compression(int level ) ;
#line 68
void packet_set_interactive(int interactive , int keepalives ) ;
#line 83
void packet_put_bignum(BIGNUM *value ) ;
#line 84
void packet_put_bignum2(BIGNUM *value ) ;
#line 120
void packet_process_incoming(char const   *buf___1 , unsigned int len ) ;
#line 132
void packet_get_bignum(BIGNUM *value , int *length_ptr ) ;
#line 133
void packet_get_bignum2(BIGNUM *value , int *length_ptr ) ;
#line 165
void packet_write_poll(void) ;
#line 171
int packet_have_data_to_write(void) ;
#line 174
int packet_not_very_much_data_to_write(void) ;
#line 178
int packet_set_maxsize(int s ) ;
#line 209
int packet_connection_is_ipv4(void) ;
#line 212
void packet_set_ssh2_format(void) ;
#line 101 "kex.h"
void packet_set_kex(Kex *k ) ;
#line 77 "packet.c"
static int connection_in  =    -1;
#line 78 "packet.c"
static int connection_out  =    -1;
#line 84 "packet.c"
static int cipher_type  =    0;
#line 87 "packet.c"
static unsigned int remote_protocol_flags  =    0U;
#line 90 "packet.c"
static CipherContext receive_context  ;
#line 93 "packet.c"
static CipherContext send_context  ;
#line 96 "packet.c"
static Buffer input  ;
#line 99 "packet.c"
static Buffer output  ;
#line 102 "packet.c"
static Buffer outgoing_packet  ;
#line 105 "packet.c"
static Buffer incoming_packet  ;
#line 108 "packet.c"
static Buffer compression_buffer  ;
#line 111 "packet.c"
static int packet_compression  =    0;
#line 114 "packet.c"
int max_packet_size  =    32768;
#line 117 "packet.c"
static int initialized  =    0;
#line 120 "packet.c"
static int interactive_mode  =    0;
#line 123 "packet.c"
int use_ssh2_packet_format  =    0;
#line 126 "packet.c"
Kex *kex  =    (Kex *)((void *)0);
#line 128 "packet.c"
void packet_set_kex(Kex *k ) 
{ 

  {
#line 131
  if ((unsigned int )k->mac[0].key == (unsigned int )((void *)0)) {
#line 137
    fatal("bad KEX");
  } else {
#line 131
    if ((unsigned int )k->enc[0].key == (unsigned int )((void *)0)) {
#line 137
      fatal("bad KEX");
    } else {
#line 131
      if ((unsigned int )k->enc[0].iv == (unsigned int )((void *)0)) {
#line 137
        fatal("bad KEX");
      } else {
#line 131
        if ((unsigned int )k->mac[1].key == (unsigned int )((void *)0)) {
#line 137
          fatal("bad KEX");
        } else {
#line 131
          if ((unsigned int )k->enc[1].key == (unsigned int )((void *)0)) {
#line 137
            fatal("bad KEX");
          } else {
#line 131
            if ((unsigned int )k->enc[1].iv == (unsigned int )((void *)0)) {
#line 137
              fatal("bad KEX");
            }
          }
        }
      }
    }
  }
#line 138
  kex = k;
#line 139
  return;
}
}
#line 140 "packet.c"
void clear_enc_keys(Enc *enc , int len ) 
{ 

  {
#line 143
  memset((void *)enc->iv, 0, (unsigned int )len);
#line 144
  memset((void *)enc->key, 0, (unsigned int )len);
#line 145
  xfree((void *)enc->iv);
#line 146
  xfree((void *)enc->key);
#line 147
  enc->iv = (unsigned char *)((void *)0);
#line 148
  enc->key = (unsigned char *)((void *)0);
#line 149
  return;
}
}
#line 150 "packet.c"
void packet_set_ssh2_format(void) 
{ 

  {
#line 154
  use_ssh2_packet_format = 1;
#line 155
  return;
}
}
#line 161 "packet.c"
void packet_set_connection(int fd_in , int fd_out ) 
{ Cipher *none ;
  Cipher *tmp ;

  {
#line 164
  tmp = cipher_by_name("none");
#line 164
  none = tmp;
#line 165
  if ((unsigned int )none == (unsigned int )((void *)0)) {
#line 166
    fatal("packet_set_connection: cannot load cipher \'none\'");
  }
#line 167
  connection_in = fd_in;
#line 168
  connection_out = fd_out;
#line 169
  cipher_type = 0;
#line 170
  cipher_init(& send_context, none, (u_char const   *)((unsigned char *)""), 0U, (u_char const   *)((void *)0),
              0U);
#line 171
  cipher_init(& receive_context, none, (u_char const   *)((unsigned char *)""), 0U,
              (u_char const   *)((void *)0), 0U);
#line 172
  if (! initialized) {
#line 173
    initialized = 1;
#line 174
    buffer_init(& input);
#line 175
    buffer_init(& output);
#line 176
    buffer_init(& outgoing_packet);
#line 177
    buffer_init(& incoming_packet);
  }
#line 180
  fatal_add_cleanup((void (*)(void * ))(& packet_close), (void *)0);
#line 181
  return;
}
}
#line 185 "packet.c"
int packet_connection_is_on_socket(void) 
{ struct sockaddr_storage from ;
  struct sockaddr_storage to ;
  socklen_t fromlen ;
  socklen_t tolen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 192
  if (connection_in == connection_out) {
#line 193
    return (1);
  }
#line 194
  fromlen = sizeof(from);
#line 195
  memset((void *)(& from), 0, sizeof(from));
#line 196
  tmp = getpeername(connection_in, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                    (socklen_t * __restrict  )(& fromlen));
#line 196
  if (tmp < 0) {
#line 197
    return (0);
  }
#line 198
  tolen = sizeof(to);
#line 199
  memset((void *)(& to), 0, sizeof(to));
#line 200
  tmp___0 = getpeername(connection_out, (struct sockaddr * __restrict  )((struct sockaddr *)(& to)),
                        (socklen_t * __restrict  )(& tolen));
#line 200
  if (tmp___0 < 0) {
#line 201
    return (0);
  }
#line 202
  if (fromlen != tolen) {
#line 203
    return (0);
  } else {
#line 202
    tmp___1 = memcmp((void const   *)(& from), (void const   *)(& to), fromlen);
#line 202
    if (tmp___1 != 0) {
#line 203
      return (0);
    }
  }
#line 204
  if ((int )from.ss_family != 2) {
#line 204
    if ((int )from.ss_family != 10) {
#line 205
      return (0);
    }
  }
#line 206
  return (1);
}
}
#line 211 "packet.c"
int packet_connection_is_ipv4(void) 
{ struct sockaddr_storage to ;
  socklen_t tolen ;
  int tmp ;

  {
#line 215
  tolen = sizeof(to);
#line 217
  memset((void *)(& to), 0, sizeof(to));
#line 218
  tmp = getsockname(connection_out, (struct sockaddr * __restrict  )((struct sockaddr *)(& to)),
                    (socklen_t * __restrict  )(& tolen));
#line 218
  if (tmp < 0) {
#line 219
    return (0);
  }
#line 220
  if ((int )to.ss_family != 2) {
#line 221
    return (0);
  }
#line 222
  return (1);
}
}
#line 227 "packet.c"
void packet_set_nonblocking(void) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 231
  tmp___1 = fcntl(connection_in, 4, 2048);
#line 231
  if (tmp___1 < 0) {
#line 232
    tmp = __errno_location();
#line 232
    tmp___0 = strerror(*tmp);
#line 232
    error("fcntl O_NONBLOCK: %.100s", tmp___0);
  }
#line 234
  if (connection_out != connection_in) {
#line 235
    tmp___4 = fcntl(connection_out, 4, 2048);
#line 235
    if (tmp___4 < 0) {
#line 236
      tmp___2 = __errno_location();
#line 236
      tmp___3 = strerror(*tmp___2);
#line 236
      error("fcntl O_NONBLOCK: %.100s", tmp___3);
    }
  }
#line 238
  return;
}
}
#line 242 "packet.c"
int packet_get_connection_in(void) 
{ 

  {
#line 245
  return (connection_in);
}
}
#line 250 "packet.c"
int packet_get_connection_out(void) 
{ 

  {
#line 253
  return (connection_out);
}
}
#line 258 "packet.c"
void packet_close(void) 
{ 

  {
#line 261
  if (! initialized) {
#line 262
    return;
  }
#line 263
  initialized = 0;
#line 264
  if (connection_in == connection_out) {
#line 265
    shutdown(connection_out, 2);
#line 266
    close(connection_out);
  } else {
#line 268
    close(connection_in);
#line 269
    close(connection_out);
  }
#line 271
  buffer_free(& input);
#line 272
  buffer_free(& output);
#line 273
  buffer_free(& outgoing_packet);
#line 274
  buffer_free(& incoming_packet);
#line 275
  if (packet_compression) {
#line 276
    buffer_free(& compression_buffer);
#line 277
    buffer_compress_uninit();
  }
#line 279
  return;
}
}
#line 283 "packet.c"
void packet_set_protocol_flags(unsigned int protocol_flags ) 
{ 

  {
#line 286
  remote_protocol_flags = protocol_flags;
#line 287
  channel_set_options((protocol_flags & 2U) != 0U);
#line 288
  return;
}
}
#line 292 "packet.c"
unsigned int packet_get_protocol_flags(void) 
{ 

  {
#line 295
  return (remote_protocol_flags);
}
}
#line 304 "packet.c"
void packet_start_compression(int level ) 
{ 

  {
#line 307
  if (packet_compression) {
#line 308
    fatal("Compression already enabled.");
  }
#line 309
  packet_compression = 1;
#line 310
  buffer_init(& compression_buffer);
#line 311
  buffer_compress_init(level);
#line 312
  return;
}
}
#line 319 "packet.c"
void packet_encrypt(CipherContext *cc , void *dest , void *src , unsigned int bytes ) 
{ 

  {
#line 323
  cipher_encrypt(cc, (u_char *)dest, (u_char const   *)src, bytes);
#line 324
  return;
}
}
#line 331 "packet.c"
void packet_decrypt(CipherContext *context , void *dest , void *src , unsigned int bytes ) 
{ int tmp ;

  {
#line 338
  if (! compat20) {
#line 338
    if ((context->cipher)->number != 0) {
#line 338
      tmp = detect_attack((unsigned char *)src, bytes, (unsigned char *)((void *)0));
#line 338
      if (tmp == 1) {
#line 341
        packet_disconnect("crc32 compensation attack: network attack detected");
      }
    }
  }
#line 343
  cipher_decrypt(context, (u_char *)dest, (u_char const   *)src, bytes);
#line 344
  return;
}
}
#line 352 "packet.c"
void packet_set_encryption_key(unsigned char const   *key , unsigned int keylen ,
                               int number ) 
{ Cipher *cipher ;
  Cipher *tmp ;

  {
#line 356
  tmp = cipher_by_number(number);
#line 356
  cipher = tmp;
#line 357
  if ((unsigned int )cipher == (unsigned int )((void *)0)) {
#line 358
    fatal("packet_set_encryption_key: unknown cipher number %d", number);
  }
#line 359
  if (keylen < 20U) {
#line 360
    fatal("packet_set_encryption_key: keylen too small: %d", keylen);
  }
#line 361
  cipher_init(& receive_context, cipher, key, keylen, (u_char const   *)((void *)0),
              0U);
#line 362
  cipher_init(& send_context, cipher, key, keylen, (u_char const   *)((void *)0),
              0U);
#line 363
  return;
}
}
#line 367 "packet.c"
void packet_start1(int type ) 
{ char buf___1[9] ;

  {
#line 372
  buffer_clear(& outgoing_packet);
#line 373
  memset((void *)(buf___1), 0, 8U);
#line 374
  buf___1[8] = (char )type;
#line 375
  buffer_append(& outgoing_packet, (char const   *)(buf___1), 9U);
#line 376
  return;
}
}
#line 378 "packet.c"
void packet_start2(int type ) 
{ char buf___1[6] ;

  {
#line 383
  buffer_clear(& outgoing_packet);
#line 384
  memset((void *)(buf___1), 0, sizeof(buf___1));
#line 387
  buf___1[5] = (char )(type & 255);
#line 388
  buffer_append(& outgoing_packet, (char const   *)(buf___1), sizeof(buf___1));
#line 389
  return;
}
}
#line 391 "packet.c"
void packet_start(int type ) 
{ 

  {
#line 395
  if (use_ssh2_packet_format) {
#line 396
    packet_start2(type);
  } else {
#line 398
    packet_start1(type);
  }
#line 399
  return;
}
}
#line 403 "packet.c"
void packet_put_char(int value ) 
{ char ch ;

  {
#line 406
  ch = (char )value;
#line 407
  buffer_append(& outgoing_packet, (char const   *)(& ch), 1U);
#line 408
  return;
}
}
#line 412 "packet.c"
void packet_put_int(unsigned int value ) 
{ 

  {
#line 415
  buffer_put_int(& outgoing_packet, value);
#line 416
  return;
}
}
#line 420 "packet.c"
void packet_put_string(char const   *buf___1 , unsigned int len ) 
{ 

  {
#line 423
  buffer_put_string(& outgoing_packet, (void const   *)buf___1, len);
#line 424
  return;
}
}
#line 425 "packet.c"
void packet_put_cstring(char const   *str ) 
{ size_t tmp ;

  {
#line 428
  tmp = strlen(str);
#line 428
  buffer_put_string(& outgoing_packet, (void const   *)str, tmp);
#line 429
  return;
}
}
#line 431 "packet.c"
void packet_put_raw(char const   *buf___1 , unsigned int len ) 
{ 

  {
#line 434
  buffer_append(& outgoing_packet, buf___1, len);
#line 435
  return;
}
}
#line 440 "packet.c"
void packet_put_bignum(BIGNUM *value ) 
{ 

  {
#line 443
  buffer_put_bignum(& outgoing_packet, value);
#line 444
  return;
}
}
#line 445 "packet.c"
void packet_put_bignum2(BIGNUM *value ) 
{ 

  {
#line 448
  buffer_put_bignum2(& outgoing_packet, value);
#line 449
  return;
}
}
#line 456 "packet.c"
void packet_send1(void) 
{ char buf___1[8] ;
  char *cp ;
  int i ;
  int padding ;
  int len ;
  unsigned int checksum ;
  u_int32_t rand___0 ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  char *tmp___6 ;

  {
#line 462
  rand___0 = (u_int32_t )0;
#line 468
  if (packet_compression) {
#line 469
    buffer_clear(& compression_buffer);
#line 471
    buffer_consume(& outgoing_packet, 8U);
#line 473
    buffer_append(& compression_buffer, "\000\000\000\000\000\000\000\000", 8U);
#line 474
    buffer_compress(& outgoing_packet, & compression_buffer);
#line 475
    buffer_clear(& outgoing_packet);
#line 476
    tmp = buffer_len(& compression_buffer);
#line 476
    tmp___0 = buffer_ptr(& compression_buffer);
#line 476
    buffer_append(& outgoing_packet, (char const   *)tmp___0, tmp);
  }
#line 480
  tmp___1 = buffer_len(& outgoing_packet);
#line 480
  len = (int )((tmp___1 + 4U) - 8U);
#line 483
  padding = 8 - len % 8;
#line 484
  if (cipher_type != 0) {
#line 485
    cp = buffer_ptr(& outgoing_packet);
#line 486
    i = 0;
#line 486
    while (i < padding) {
#line 487
      if (i % 4 == 0) {
#line 488
        rand___0 = arc4random();
      }
#line 489
      *(cp + (7 - i)) = (char )(rand___0 & 255U);
#line 490
      rand___0 >>= 8;
#line 486
      i ++;
    }
  }
#line 493
  buffer_consume(& outgoing_packet, (unsigned int )(8 - padding));
#line 496
  tmp___2 = buffer_len(& outgoing_packet);
#line 496
  tmp___3 = buffer_ptr(& outgoing_packet);
#line 496
  checksum = ssh_crc32((unsigned char const   *)((unsigned char *)tmp___3), tmp___2);
#line 498
  while (1) {
#line 498
    buf___1[0] = (char )(checksum >> 24);
#line 498
    buf___1[1] = (char )(checksum >> 16);
#line 498
    buf___1[2] = (char )(checksum >> 8);
#line 498
    buf___1[3] = (char )checksum;
#line 498
    break;
  }
#line 499
  buffer_append(& outgoing_packet, (char const   *)(buf___1), 4U);
#line 507
  while (1) {
#line 507
    buf___1[0] = (char )(len >> 24);
#line 507
    buf___1[1] = (char )(len >> 16);
#line 507
    buf___1[2] = (char )(len >> 8);
#line 507
    buf___1[3] = (char )len;
#line 507
    break;
  }
#line 508
  buffer_append(& output, (char const   *)(buf___1), 4U);
#line 509
  tmp___4 = buffer_len(& outgoing_packet);
#line 509
  buffer_append_space(& output, & cp, tmp___4);
#line 510
  tmp___5 = buffer_len(& outgoing_packet);
#line 510
  tmp___6 = buffer_ptr(& outgoing_packet);
#line 510
  packet_encrypt(& send_context, (void *)cp, (void *)tmp___6, tmp___5);
#line 518
  buffer_clear(& outgoing_packet);
#line 525
  return;
}
}
#line 538
void packet_send2(void) ;
#line 538 "packet.c"
static unsigned int seqnr  =    0U;
#line 530 "packet.c"
void packet_send2(void) 
{ unsigned char *macbuf ;
  char *cp ;
  unsigned int packet_length___0 ;
  unsigned int i ;
  unsigned int padlen ;
  unsigned int len ;
  u_int32_t rand___0 ;
  int type ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  int block_size ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  char *tmp___6 ;

  {
#line 533
  macbuf = (unsigned char *)((void *)0);
#line 535
  packet_length___0 = 0U;
#line 537
  rand___0 = (u_int32_t )0;
#line 540
  enc = (Enc *)((void *)0);
#line 541
  mac = (Mac *)((void *)0);
#line 542
  comp = (Comp *)((void *)0);
#line 545
  if ((unsigned int )kex != (unsigned int )((void *)0)) {
#line 546
    enc = & kex->enc[1];
#line 547
    mac = & kex->mac[1];
#line 548
    comp = & kex->comp[1];
  }
#line 550
  if (enc) {
#line 550
    block_size = (int )(enc->cipher)->block_size;
  } else {
#line 550
    block_size = 8;
  }
#line 552
  cp = buffer_ptr(& outgoing_packet);
#line 553
  type = (int )*(cp + 5) & 255;
#line 560
  if (comp) {
#line 560
    if (comp->enabled) {
#line 561
      len = buffer_len(& outgoing_packet);
#line 563
      buffer_consume(& outgoing_packet, 5U);
#line 564
      buffer_clear(& compression_buffer);
#line 565
      buffer_compress(& outgoing_packet, & compression_buffer);
#line 566
      buffer_clear(& outgoing_packet);
#line 567
      buffer_append(& outgoing_packet, "\000\000\000\000\000", 5U);
#line 568
      tmp = buffer_len(& compression_buffer);
#line 568
      tmp___0 = buffer_ptr(& compression_buffer);
#line 568
      buffer_append(& outgoing_packet, (char const   *)tmp___0, tmp);
    }
  }
#line 575
  len = buffer_len(& outgoing_packet);
#line 581
  padlen = (unsigned int )block_size - len % (unsigned int )block_size;
#line 582
  if (padlen < 4U) {
#line 583
    padlen += (unsigned int )block_size;
  }
#line 584
  buffer_append_space(& outgoing_packet, & cp, padlen);
#line 585
  if (enc) {
#line 585
    if ((enc->cipher)->number != 0) {
#line 587
      i = 0U;
#line 587
      while (i < padlen) {
#line 588
        if (i % 4U == 0U) {
#line 589
          rand___0 = arc4random();
        }
#line 590
        *(cp + i) = (char )(rand___0 & 255U);
#line 591
        rand___0 <<= 8;
#line 587
        i ++;
      }
    } else {
#line 595
      memset((void *)cp, 0, padlen);
    }
  } else {
#line 595
    memset((void *)cp, 0, padlen);
  }
#line 598
  tmp___1 = buffer_len(& outgoing_packet);
#line 598
  packet_length___0 = tmp___1 - 4U;
#line 599
  cp = buffer_ptr(& outgoing_packet);
#line 600
  while (1) {
#line 600
    *(cp + 0) = (char )(packet_length___0 >> 24);
#line 600
    *(cp + 1) = (char )(packet_length___0 >> 16);
#line 600
    *(cp + 2) = (char )(packet_length___0 >> 8);
#line 600
    *(cp + 3) = (char )packet_length___0;
#line 600
    break;
  }
#line 601
  *(cp + 4) = (char )(padlen & 255U);
#line 605
  if (mac) {
#line 605
    if (mac->enabled) {
#line 606
      tmp___2 = buffer_len(& outgoing_packet);
#line 606
      tmp___3 = buffer_ptr(& outgoing_packet);
#line 606
      macbuf = hmac(mac->md, seqnr, (unsigned char *)tmp___3, (int )tmp___2, mac->key,
                    mac->key_len);
    }
  }
#line 614
  tmp___4 = buffer_len(& outgoing_packet);
#line 614
  buffer_append_space(& output, & cp, tmp___4);
#line 615
  tmp___5 = buffer_len(& outgoing_packet);
#line 615
  tmp___6 = buffer_ptr(& outgoing_packet);
#line 615
  packet_encrypt(& send_context, (void *)cp, (void *)tmp___6, tmp___5);
#line 618
  if (mac) {
#line 618
    if (mac->enabled) {
#line 619
      buffer_append(& output, (char const   *)((char *)macbuf), (unsigned int )mac->mac_len);
    }
  }
#line 625
  seqnr ++;
#line 625
  if (seqnr == 0U) {
#line 626
    log("outgoing seqnr wraps around");
  }
#line 627
  buffer_clear(& outgoing_packet);
#line 629
  if (type == 21) {
#line 630
    if ((unsigned int )kex == (unsigned int )((void *)0)) {
#line 631
      fatal("packet_send2: no KEX");
    } else {
#line 630
      if ((unsigned int )mac == (unsigned int )((void *)0)) {
#line 631
        fatal("packet_send2: no KEX");
      } else {
#line 630
        if ((unsigned int )enc == (unsigned int )((void *)0)) {
#line 631
          fatal("packet_send2: no KEX");
        } else {
#line 630
          if ((unsigned int )comp == (unsigned int )((void *)0)) {
#line 631
            fatal("packet_send2: no KEX");
          }
        }
      }
    }
#line 632
    if ((unsigned int )mac->md != (unsigned int )((void *)0)) {
#line 633
      mac->enabled = 1;
    }
#line 635
    cipher_init(& send_context, enc->cipher, (u_char const   *)enc->key, (enc->cipher)->key_len,
                (u_char const   *)enc->iv, (enc->cipher)->block_size);
#line 638
    clear_enc_keys(enc, kex->we_need);
#line 639
    if (comp->type != 0) {
#line 639
      if (comp->enabled == 0) {
#line 640
        comp->enabled = 1;
#line 641
        if (! packet_compression) {
#line 642
          packet_start_compression(6);
        }
      }
    }
  }
#line 645
  return;
}
}
#line 647 "packet.c"
void packet_send(void) 
{ 

  {
#line 650
  if (use_ssh2_packet_format) {
#line 651
    packet_send2();
  } else {
#line 653
    packet_send1();
  }
#line 655
  return;
}
}
#line 663 "packet.c"
int packet_read(int *payload_len_ptr ) 
{ int type ;
  int len ;
  fd_set set ;
  char buf___1[8192] ;
  int _p ;
  int _e ;
  int __d0 ;
  int __d1 ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 672
  packet_write_wait();
#line 675
  while (1) {
#line 677
    type = packet_read_poll(payload_len_ptr);
#line 678
    if (! use_ssh2_packet_format) {
#line 678
      if (type == 14) {
        goto _L;
      } else {
#line 678
        if (type == 15) {
          goto _L;
        } else {
#line 678
          if (type == 19) {
            goto _L;
          } else {
#line 678
            if (type == 33) {
              _L: /* CIL Label */ 
#line 683
              while (1) {
#line 683
                _p = *payload_len_ptr;
#line 683
                _e = 0;
#line 683
                if (_p != _e) {
#line 683
                  log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "packet.c",
                      683);
#line 683
                  packet_disconnect("Packet integrity error. (%d)", type);
                }
#line 683
                break;
              }
            }
          }
        }
      }
    }
#line 685
    if (type != 0) {
#line 686
      return (type);
    }
#line 691
    while (1) {
#line 691
      __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& set.__fds_bits[0]): "memory");
#line 691
      break;
    }
#line 692
    __asm__  volatile   ("btsl %1,%0": "=m" (set.__fds_bits[(unsigned int )connection_in / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 695
    select(connection_in + 1, (fd_set * __restrict  )(& set), (fd_set * __restrict  )((void *)0),
           (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 698
    len = read(connection_in, (void *)(buf___1), sizeof(buf___1));
#line 699
    if (len == 0) {
#line 700
      tmp = get_remote_ipaddr();
#line 700
      log("Connection closed by %.200s", tmp);
#line 701
      fatal_cleanup();
    }
#line 703
    if (len < 0) {
#line 704
      tmp___0 = __errno_location();
#line 704
      tmp___1 = strerror(*tmp___0);
#line 704
      fatal("Read from socket failed: %.100s", tmp___1);
    }
#line 706
    packet_process_incoming((char const   *)(buf___1), (unsigned int )len);
  }
}
}
#line 716 "packet.c"
void packet_read_expect(int *payload_len_ptr , int expected_type ) 
{ int type ;

  {
#line 721
  type = packet_read(payload_len_ptr);
#line 722
  if (type != expected_type) {
#line 723
    packet_disconnect("Protocol error: expected packet type %d, got %d", expected_type,
                      type);
  }
#line 725
  return;
}
}
#line 742 "packet.c"
int packet_read_poll1(int *payload_len_ptr ) 
{ unsigned int len ;
  unsigned int padded_len ;
  unsigned char *ucp ;
  char buf___1[8] ;
  char *cp ;
  unsigned int checksum ;
  unsigned int stored_checksum ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  char *tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  unsigned int tmp___8 ;
  char *tmp___9 ;
  unsigned int tmp___10 ;

  {
#line 751
  tmp = buffer_len(& input);
#line 751
  if (tmp < 12U) {
#line 752
    return (0);
  }
#line 754
  tmp___0 = buffer_ptr(& input);
#line 754
  ucp = (unsigned char *)tmp___0;
#line 755
  len = (unsigned int )(((((unsigned long )*(ucp + 0) << 24) | ((unsigned long )*(ucp + 1) << 16)) | ((unsigned long )*(ucp + 2) << 8)) | (unsigned long )*(ucp + 3));
#line 756
  if (len < 5U) {
#line 757
    packet_disconnect("Bad packet length %d.", len);
  } else {
#line 756
    if (len > 262144U) {
#line 757
      packet_disconnect("Bad packet length %d.", len);
    }
  }
#line 758
  padded_len = (len + 8U) & 4294967288U;
#line 761
  tmp___1 = buffer_len(& input);
#line 761
  if (tmp___1 < 4U + padded_len) {
#line 762
    return (0);
  }
#line 767
  buffer_consume(& input, 4U);
#line 770
  buffer_clear(& incoming_packet);
#line 771
  buffer_append_space(& incoming_packet, & cp, padded_len);
#line 772
  tmp___2 = buffer_ptr(& input);
#line 772
  packet_decrypt(& receive_context, (void *)cp, (void *)tmp___2, padded_len);
#line 773
  buffer_consume(& input, padded_len);
#line 781
  tmp___3 = buffer_len(& incoming_packet);
#line 781
  tmp___4 = buffer_ptr(& incoming_packet);
#line 781
  checksum = ssh_crc32((unsigned char const   *)((unsigned char *)tmp___4), tmp___3 - 4U);
#line 785
  buffer_consume(& incoming_packet, 8U - len % 8U);
#line 789
  tmp___6 = buffer_len(& incoming_packet);
#line 789
  if (len != tmp___6) {
#line 790
    tmp___5 = buffer_len(& incoming_packet);
#line 790
    packet_disconnect("packet_read_poll: len %d != buffer_len %d.", len, tmp___5);
  }
#line 793
  tmp___7 = buffer_ptr(& incoming_packet);
#line 793
  ucp = ((unsigned char *)tmp___7 + len) - 4;
#line 794
  stored_checksum = (unsigned int )(((((unsigned long )*(ucp + 0) << 24) | ((unsigned long )*(ucp + 1) << 16)) | ((unsigned long )*(ucp + 2) << 8)) | (unsigned long )*(ucp + 3));
#line 795
  if (checksum != stored_checksum) {
#line 796
    packet_disconnect("Corrupted check bytes on input.");
  }
#line 797
  buffer_consume_end(& incoming_packet, 4U);
#line 800
  if (packet_compression) {
#line 801
    buffer_clear(& compression_buffer);
#line 802
    buffer_uncompress(& incoming_packet, & compression_buffer);
#line 803
    buffer_clear(& incoming_packet);
#line 804
    tmp___8 = buffer_len(& compression_buffer);
#line 804
    tmp___9 = buffer_ptr(& compression_buffer);
#line 804
    buffer_append(& incoming_packet, (char const   *)tmp___9, tmp___8);
  }
#line 808
  buffer_get(& incoming_packet, buf___1, 1U);
#line 811
  tmp___10 = buffer_len(& incoming_packet);
#line 811
  *payload_len_ptr = (int )tmp___10;
#line 814
  return ((int )((unsigned char )buf___1[0]));
}
}
#line 824
int packet_read_poll2(int *payload_len_ptr ) ;
#line 824 "packet.c"
static unsigned int packet_length  =    0U;
#line 825 "packet.c"
static unsigned int seqnr___0  =    0U;
#line 817 "packet.c"
int packet_read_poll2(int *payload_len_ptr ) 
{ unsigned int padlen ;
  unsigned int need ;
  unsigned char buf___1[8] ;
  unsigned char *macbuf ;
  unsigned char *ucp ;
  char *cp ;
  int type ;
  int maclen ;
  int block_size ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  unsigned int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  unsigned int tmp___9 ;
  char *tmp___10 ;
  unsigned int tmp___11 ;

  {
#line 828
  enc = (Enc *)((void *)0);
#line 829
  mac = (Mac *)((void *)0);
#line 830
  comp = (Comp *)((void *)0);
#line 832
  if ((unsigned int )kex != (unsigned int )((void *)0)) {
#line 833
    enc = & kex->enc[0];
#line 834
    mac = & kex->mac[0];
#line 835
    comp = & kex->comp[0];
  }
#line 837
  if (mac) {
#line 837
    if (mac->enabled) {
#line 837
      maclen = mac->mac_len;
    } else {
#line 837
      maclen = 0;
    }
  } else {
#line 837
    maclen = 0;
  }
#line 838
  if (enc) {
#line 838
    block_size = (int )(enc->cipher)->block_size;
  } else {
#line 838
    block_size = 8;
  }
#line 840
  if (packet_length == 0U) {
#line 845
    tmp = buffer_len(& input);
#line 845
    if (tmp < (unsigned int )block_size) {
#line 846
      return (0);
    }
#line 847
    buffer_clear(& incoming_packet);
#line 848
    buffer_append_space(& incoming_packet, & cp, (unsigned int )block_size);
#line 849
    tmp___0 = buffer_ptr(& input);
#line 849
    packet_decrypt(& receive_context, (void *)cp, (void *)tmp___0, (unsigned int )block_size);
#line 851
    tmp___1 = buffer_ptr(& incoming_packet);
#line 851
    ucp = (unsigned char *)tmp___1;
#line 852
    packet_length = (unsigned int )(((((unsigned long )*(ucp + 0) << 24) | ((unsigned long )*(ucp + 1) << 16)) | ((unsigned long )*(ucp + 2) << 8)) | (unsigned long )*(ucp + 3));
#line 853
    if (packet_length < 5U) {
#line 854
      buffer_dump(& incoming_packet);
#line 855
      packet_disconnect("Bad packet length %d.", packet_length);
    } else {
#line 853
      if (packet_length > 262144U) {
#line 854
        buffer_dump(& incoming_packet);
#line 855
        packet_disconnect("Bad packet length %d.", packet_length);
      }
    }
#line 858
    buffer_consume(& input, (unsigned int )block_size);
  }
#line 861
  need = (4U + packet_length) - (unsigned int )block_size;
#line 864
  if (need % (unsigned int )block_size != 0U) {
#line 865
    fatal("padding error: need %d block %d mod %d", need, block_size, need % (unsigned int )block_size);
  }
#line 871
  tmp___2 = buffer_len(& input);
#line 871
  if (tmp___2 < need + (unsigned int )maclen) {
#line 872
    return (0);
  }
#line 877
  buffer_append_space(& incoming_packet, & cp, need);
#line 878
  tmp___3 = buffer_ptr(& input);
#line 878
  packet_decrypt(& receive_context, (void *)cp, (void *)tmp___3, need);
#line 879
  buffer_consume(& input, need);
#line 884
  if (mac) {
#line 884
    if (mac->enabled) {
#line 885
      tmp___4 = buffer_len(& incoming_packet);
#line 885
      tmp___5 = buffer_ptr(& incoming_packet);
#line 885
      macbuf = hmac(mac->md, seqnr___0, (unsigned char *)tmp___5, (int )tmp___4, mac->key,
                    mac->key_len);
#line 890
      tmp___6 = buffer_ptr(& input);
#line 890
      tmp___7 = memcmp((void const   *)macbuf, (void const   *)tmp___6, (unsigned int )mac->mac_len);
#line 890
      if (tmp___7 != 0) {
#line 891
        packet_disconnect("Corrupted MAC on input.");
      }
#line 893
      buffer_consume(& input, (unsigned int )mac->mac_len);
    }
  }
#line 895
  seqnr___0 ++;
#line 895
  if (seqnr___0 == 0U) {
#line 896
    log("incoming seqnr wraps around");
  }
#line 899
  tmp___8 = buffer_ptr(& incoming_packet);
#line 899
  cp = tmp___8 + 4;
#line 900
  padlen = (unsigned int )((int )*cp & 255);
#line 902
  if (padlen < 4U) {
#line 903
    packet_disconnect("Corrupted padlen %d on input.", padlen);
  }
#line 906
  buffer_consume(& incoming_packet, 5U);
#line 907
  buffer_consume_end(& incoming_packet, padlen);
#line 910
  if (comp) {
#line 910
    if (comp->enabled) {
#line 911
      buffer_clear(& compression_buffer);
#line 912
      buffer_uncompress(& incoming_packet, & compression_buffer);
#line 913
      buffer_clear(& incoming_packet);
#line 914
      tmp___9 = buffer_len(& compression_buffer);
#line 914
      tmp___10 = buffer_ptr(& compression_buffer);
#line 914
      buffer_append(& incoming_packet, (char const   *)tmp___10, tmp___9);
    }
  }
#line 922
  buffer_get(& incoming_packet, (char *)(buf___1), 1U);
#line 923
  tmp___11 = buffer_len(& incoming_packet);
#line 923
  *payload_len_ptr = (int )tmp___11;
#line 926
  packet_length = 0U;
#line 929
  type = (int )buf___1[0];
#line 931
  if (type == 21) {
#line 932
    if ((unsigned int )kex == (unsigned int )((void *)0)) {
#line 933
      fatal("packet_read_poll2: no KEX");
    } else {
#line 932
      if ((unsigned int )mac == (unsigned int )((void *)0)) {
#line 933
        fatal("packet_read_poll2: no KEX");
      } else {
#line 932
        if ((unsigned int )enc == (unsigned int )((void *)0)) {
#line 933
          fatal("packet_read_poll2: no KEX");
        } else {
#line 932
          if ((unsigned int )comp == (unsigned int )((void *)0)) {
#line 933
            fatal("packet_read_poll2: no KEX");
          }
        }
      }
    }
#line 934
    if ((unsigned int )mac->md != (unsigned int )((void *)0)) {
#line 935
      mac->enabled = 1;
    }
#line 937
    cipher_init(& receive_context, enc->cipher, (u_char const   *)enc->key, (enc->cipher)->key_len,
                (u_char const   *)enc->iv, (enc->cipher)->block_size);
#line 940
    clear_enc_keys(enc, kex->we_need);
#line 941
    if (comp->type != 0) {
#line 941
      if (comp->enabled == 0) {
#line 942
        comp->enabled = 1;
#line 943
        if (! packet_compression) {
#line 944
          packet_start_compression(6);
        }
      }
    }
  }
#line 952
  return ((int )((unsigned char )type));
}
}
#line 955 "packet.c"
int packet_read_poll(int *payload_len_ptr ) 
{ char *msg ;
  int type ;
  int tmp___1 ;
  int reason ;
  unsigned int tmp___2 ;

  {
#line 959
  while (1) {
#line 960
    if (use_ssh2_packet_format) {
#line 960
      tmp___1 = packet_read_poll2(payload_len_ptr);
    } else {
#line 960
      tmp___1 = packet_read_poll1(payload_len_ptr);
    }
#line 960
    type = tmp___1;
#line 964
    if (compat20) {
#line 966
      if (type != 0) {

      }
#line 968
      switch (type) {
      case 2: 
#line 970
      break;
      case 4: 
#line 972
      packet_get_char();
#line 973
      msg = packet_get_string((unsigned int *)((void *)0));
#line 974
      debug("Remote: %.900s", msg);
#line 975
      xfree((void *)msg);
#line 976
      msg = packet_get_string((unsigned int *)((void *)0));
#line 977
      xfree((void *)msg);
#line 978
      break;
      case 1: 
#line 980
      tmp___2 = packet_get_int();
#line 980
      reason = (int )tmp___2;
#line 981
      msg = packet_get_string((unsigned int *)((void *)0));
#line 982
      log("Received disconnect: %d: %.900s", reason, msg);
#line 983
      xfree((void *)msg);
#line 984
      fatal_cleanup();
#line 985
      break;
      default: ;
#line 987
      return (type);
#line 988
      break;
      }
    } else {
#line 991
      switch (type) {
      case 32: 
#line 993
      break;
      case 36: 
#line 995
      msg = packet_get_string((unsigned int *)((void *)0));
#line 996
      debug("Remote: %.900s", msg);
#line 997
      xfree((void *)msg);
#line 998
      break;
      case 1: 
#line 1000
      msg = packet_get_string((unsigned int *)((void *)0));
#line 1001
      log("Received disconnect: %.900s", msg);
#line 1002
      fatal_cleanup();
#line 1003
      xfree((void *)msg);
#line 1004
      break;
      default: ;
#line 1006
      if (type != 0) {

      }
#line 1008
      return (type);
#line 1009
      break;
      }
    }
  }
}
}
#line 1020 "packet.c"
void packet_process_incoming(char const   *buf___1 , unsigned int len ) 
{ 

  {
#line 1023
  buffer_append(& input, buf___1, len);
#line 1024
  return;
}
}
#line 1028 "packet.c"
unsigned int packet_get_char(void) 
{ char ch ;

  {
#line 1032
  buffer_get(& incoming_packet, & ch, 1U);
#line 1033
  return ((unsigned int )((unsigned char )ch));
}
}
#line 1038 "packet.c"
unsigned int packet_get_int(void) 
{ unsigned int tmp ;

  {
#line 1041
  tmp = buffer_get_int(& incoming_packet);
#line 1041
  return (tmp);
}
}
#line 1049 "packet.c"
void packet_get_bignum(BIGNUM *value , int *length_ptr ) 
{ 

  {
#line 1052
  *length_ptr = buffer_get_bignum(& incoming_packet, value);
#line 1053
  return;
}
}
#line 1055 "packet.c"
void packet_get_bignum2(BIGNUM *value , int *length_ptr ) 
{ 

  {
#line 1058
  *length_ptr = buffer_get_bignum2(& incoming_packet, value);
#line 1059
  return;
}
}
#line 1061 "packet.c"
char *packet_get_raw(int *length_ptr ) 
{ int bytes ;
  unsigned int tmp ;
  char *tmp___0 ;

  {
#line 1064
  tmp = buffer_len(& incoming_packet);
#line 1064
  bytes = (int )tmp;
#line 1065
  if ((unsigned int )length_ptr != (unsigned int )((void *)0)) {
#line 1066
    *length_ptr = bytes;
  }
#line 1067
  tmp___0 = buffer_ptr(& incoming_packet);
#line 1067
  return (tmp___0);
}
}
#line 1070 "packet.c"
int packet_remaining(void) 
{ unsigned int tmp ;

  {
#line 1073
  tmp = buffer_len(& incoming_packet);
#line 1073
  return ((int )tmp);
}
}
#line 1083 "packet.c"
char *packet_get_string(unsigned int *length_ptr ) 
{ char *tmp ;

  {
#line 1086
  tmp = buffer_get_string(& incoming_packet, length_ptr);
#line 1086
  return (tmp);
}
}
#line 1098 "packet.c"
void ( /* format attribute */  packet_send_debug)(char const   *fmt  , ...) 
{ char buf___1[1024] ;
  va_list args ;

  {
#line 1104
  __builtin_va_start(args, fmt);
#line 1105
  vsnprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )fmt,
            args);
#line 1106
  __builtin_va_end(args);
#line 1108
  if (compat20) {
#line 1109
    packet_start(4);
#line 1110
    packet_put_char(0);
#line 1111
    packet_put_cstring((char const   *)(buf___1));
#line 1112
    packet_put_cstring("");
  } else {
#line 1114
    packet_start(36);
#line 1115
    packet_put_cstring((char const   *)(buf___1));
  }
#line 1117
  packet_send();
#line 1118
  packet_write_wait();
#line 1119
  return;
}
}
#line 1133 "packet.c"
static int disconnecting  =    0;
#line 1128 "packet.c"
void ( /* format attribute */  packet_disconnect)(char const   *fmt  , ...) 
{ char buf___1[1024] ;
  va_list args ;
  size_t tmp ;

  {
#line 1134
  if (disconnecting) {
#line 1135
    fatal("packet_disconnect called recursively.");
  }
#line 1136
  disconnecting = 1;
#line 1142
  __builtin_va_start(args, fmt);
#line 1143
  vsnprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )fmt,
            args);
#line 1144
  __builtin_va_end(args);
#line 1147
  if (compat20) {
#line 1148
    packet_start(1);
#line 1149
    packet_put_int(2U);
#line 1150
    packet_put_cstring((char const   *)(buf___1));
#line 1151
    packet_put_cstring("");
  } else {
#line 1153
    packet_start(1);
#line 1154
    tmp = strlen((char const   *)(buf___1));
#line 1154
    packet_put_string((char const   *)(buf___1), tmp);
  }
#line 1156
  packet_send();
#line 1157
  packet_write_wait();
#line 1160
  channel_stop_listening();
#line 1163
  packet_close();
#line 1166
  log("Disconnecting: %.100s", buf___1);
#line 1167
  fatal_cleanup();
#line 1168
  return;
}
}
#line 1172 "packet.c"
void packet_write_poll(void) 
{ int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
#line 1175
  tmp = buffer_len(& output);
#line 1175
  len = (int )tmp;
#line 1176
  if (len > 0) {
#line 1177
    tmp___0 = buffer_ptr(& output);
#line 1177
    len = write(connection_out, (void const   *)tmp___0, (unsigned int )len);
#line 1178
    if (len <= 0) {
#line 1179
      tmp___3 = __errno_location();
#line 1179
      if (*tmp___3 == 11) {
#line 1180
        return;
      } else {
#line 1182
        tmp___1 = __errno_location();
#line 1182
        tmp___2 = strerror(*tmp___1);
#line 1182
        fatal("Write failed: %.100s", tmp___2);
      }
    }
#line 1184
    buffer_consume(& output, (unsigned int )len);
  }
#line 1186
  return;
}
}
#line 1193 "packet.c"
void packet_write_wait(void) 
{ fd_set set ;
  int __d0 ;
  int __d1 ;
  int tmp ;

  {
#line 1196
  packet_write_poll();
#line 1197
  while (1) {
#line 1197
    tmp = packet_have_data_to_write();
#line 1197
    if (! tmp) {
#line 1197
      break;
    }
#line 1199
    while (1) {
#line 1199
      __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& set.__fds_bits[0]): "memory");
#line 1199
      break;
    }
#line 1200
    __asm__  volatile   ("btsl %1,%0": "=m" (set.__fds_bits[(unsigned int )connection_out / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 1201
    select(connection_out + 1, (fd_set * __restrict  )((void *)0), (fd_set * __restrict  )(& set),
           (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 1202
    packet_write_poll();
  }
#line 1204
  return;
}
}
#line 1208 "packet.c"
int packet_have_data_to_write(void) 
{ unsigned int tmp ;

  {
#line 1211
  tmp = buffer_len(& output);
#line 1211
  return (tmp != 0U);
}
}
#line 1216 "packet.c"
int packet_not_very_much_data_to_write(void) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 1219
  if (interactive_mode) {
#line 1220
    tmp = buffer_len(& output);
#line 1220
    return (tmp < 16384U);
  } else {
#line 1222
    tmp___0 = buffer_len(& output);
#line 1222
    return (tmp___0 < 131072U);
  }
}
}
#line 1227 "packet.c"
void packet_set_interactive(int interactive , int keepalives ) 
{ int on ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int lowdelay ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int throughput ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
#line 1230
  on = 1;
#line 1233
  interactive_mode = interactive;
#line 1236
  tmp = packet_connection_is_on_socket();
#line 1236
  if (! tmp) {
#line 1237
    return;
  }
#line 1238
  if (keepalives) {
#line 1240
    tmp___2 = setsockopt(connection_in, 1, 9, (void const   *)((void *)(& on)), sizeof(on));
#line 1240
    if (tmp___2 < 0) {
#line 1242
      tmp___0 = __errno_location();
#line 1242
      tmp___1 = strerror(*tmp___0);
#line 1242
      error("setsockopt SO_KEEPALIVE: %.100s", tmp___1);
    }
  }
#line 1247
  tmp___3 = packet_connection_is_ipv4();
#line 1247
  if (! tmp___3) {
#line 1248
    return;
  }
#line 1249
  if (interactive) {
#line 1255
    lowdelay = 16;
#line 1256
    tmp___6 = setsockopt(connection_in, 0, 1, (void const   *)((void *)(& lowdelay)),
                         sizeof(lowdelay));
#line 1256
    if (tmp___6 < 0) {
#line 1258
      tmp___4 = __errno_location();
#line 1258
      tmp___5 = strerror(*tmp___4);
#line 1258
      error("setsockopt IPTOS_LOWDELAY: %.100s", tmp___5);
    }
#line 1260
    tmp___9 = setsockopt(connection_in, 6, 1, (void const   *)((void *)(& on)), sizeof(on));
#line 1260
    if (tmp___9 < 0) {
#line 1262
      tmp___7 = __errno_location();
#line 1262
      tmp___8 = strerror(*tmp___7);
#line 1262
      error("setsockopt TCP_NODELAY: %.100s", tmp___8);
    }
  } else {
#line 1269
    throughput = 8;
#line 1270
    tmp___12 = setsockopt(connection_in, 0, 1, (void const   *)((void *)(& throughput)),
                          sizeof(throughput));
#line 1270
    if (tmp___12 < 0) {
#line 1272
      tmp___10 = __errno_location();
#line 1272
      tmp___11 = strerror(*tmp___10);
#line 1272
      error("setsockopt IPTOS_THROUGHPUT: %.100s", tmp___11);
    }
  }
#line 1275
  return;
}
}
#line 1279 "packet.c"
int packet_is_interactive(void) 
{ 

  {
#line 1282
  return (interactive_mode);
}
}
#line 1288 "packet.c"
static int called___0  =    0;
#line 1285 "packet.c"
int packet_set_maxsize(int s ) 
{ 

  {
#line 1289
  if (called___0) {
#line 1290
    log("packet_set_maxsize: called twice: old %d new %d", max_packet_size, s);
#line 1292
    return (-1);
  }
#line 1294
  if (s < 4096) {
#line 1295
    log("packet_set_maxsize: bad size %d", s);
#line 1296
    return (-1);
  } else {
#line 1294
    if (s > 1048576) {
#line 1295
      log("packet_set_maxsize: bad size %d", s);
#line 1296
      return (-1);
    }
  }
#line 1298
  log("packet_set_maxsize: setting to %d", s);
#line 1299
  max_packet_size = s;
#line 1300
  return (s);
}
}
#line 1 "radix.o"
#line 1 "rijndael.o"
#line 44 "rijndael.c"
void gen_tabs(void) ;
#line 158 "rijndael.c"
u1byte pow_tab[256]  ;
#line 159 "rijndael.c"
u1byte log_tab[256]  ;
#line 160 "rijndael.c"
u1byte sbx_tab[256]  ;
#line 161 "rijndael.c"
u1byte isb_tab[256]  ;
#line 162 "rijndael.c"
u4byte rco_tab[10]  ;
#line 163 "rijndael.c"
u4byte ft_tab[4][256]  ;
#line 164 "rijndael.c"
u4byte it_tab[4][256]  ;
#line 167 "rijndael.c"
u4byte fl_tab[4][256]  ;
#line 168 "rijndael.c"
u4byte il_tab[4][256]  ;
#line 171 "rijndael.c"
u4byte tab_gen  =    (u4byte )0;
#line 229 "rijndael.c"
void gen_tabs(void) 
{ u4byte i ;
  u4byte t ;
  u1byte p ;
  u1byte q ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 239
  i = 0U;
#line 239
  p = (unsigned char)1;
#line 239
  while (i < 256U) {
#line 240
    pow_tab[i] = p;
#line 240
    log_tab[p] = (unsigned char )i;
#line 242
    if ((int )p & 128) {
#line 242
      tmp = 27;
    } else {
#line 242
      tmp = 0;
    }
#line 242
    p = (unsigned char )(((int )p ^ ((int )p << 1)) ^ tmp);
#line 239
    i ++;
  }
#line 245
  log_tab[1] = (unsigned char)0;
#line 245
  p = (unsigned char)1;
#line 247
  i = 0U;
#line 247
  while (i < 10U) {
#line 248
    rco_tab[i] = (unsigned int )p;
#line 250
    if ((int )p & 128) {
#line 250
      tmp___0 = 27;
    } else {
#line 250
      tmp___0 = 0;
    }
#line 250
    p = (unsigned char )(((int )p << 1) ^ tmp___0);
#line 247
    i ++;
  }
#line 259
  i = 0U;
#line 259
  while (i < 256U) {
#line 260
    if (i) {
#line 260
      p = pow_tab[255 - (int )log_tab[i]];
    } else {
#line 260
      p = (unsigned char)0;
    }
#line 260
    q = p;
#line 261
    q = (unsigned char )(((int )q >> 7) | ((int )q << 1));
#line 261
    p = (unsigned char )((int )p ^ (int )q);
#line 262
    q = (unsigned char )(((int )q >> 7) | ((int )q << 1));
#line 262
    p = (unsigned char )((int )p ^ (int )q);
#line 263
    q = (unsigned char )(((int )q >> 7) | ((int )q << 1));
#line 263
    p = (unsigned char )((int )p ^ (int )q);
#line 264
    q = (unsigned char )(((int )q >> 7) | ((int )q << 1));
#line 264
    p = (unsigned char )((int )p ^ ((int )q ^ 99));
#line 265
    sbx_tab[i] = p;
#line 265
    isb_tab[p] = (unsigned char )i;
#line 259
    i ++;
  }
#line 268
  i = 0U;
#line 268
  while (i < 256U) {
#line 269
    p = sbx_tab[i];
#line 273
    t = (unsigned int )p;
#line 273
    fl_tab[0][i] = t;
#line 274
    fl_tab[1][i] = (t << 8) | (t >> 24);
#line 275
    fl_tab[2][i] = (t << 16) | (t >> 16);
#line 276
    fl_tab[3][i] = (t << 24) | (t >> 8);
#line 278
    if (p) {
#line 278
      tmp___1 = (int )pow_tab[((int )log_tab[2] + (int )log_tab[p]) % 255];
    } else {
#line 278
      tmp___1 = 0;
    }
#line 278
    if (p) {
#line 278
      tmp___2 = (int )pow_tab[((int )log_tab[3] + (int )log_tab[p]) % 255];
    } else {
#line 278
      tmp___2 = 0;
    }
#line 278
    t = (((unsigned int )tmp___1 | ((unsigned int )p << 8)) | ((unsigned int )p << 16)) | ((unsigned int )tmp___2 << 24);
#line 283
    ft_tab[0][i] = t;
#line 284
    ft_tab[1][i] = (t << 8) | (t >> 24);
#line 285
    ft_tab[2][i] = (t << 16) | (t >> 16);
#line 286
    ft_tab[3][i] = (t << 24) | (t >> 8);
#line 288
    p = isb_tab[i];
#line 292
    t = (unsigned int )p;
#line 292
    il_tab[0][i] = t;
#line 293
    il_tab[1][i] = (t << 8) | (t >> 24);
#line 294
    il_tab[2][i] = (t << 16) | (t >> 16);
#line 295
    il_tab[3][i] = (t << 24) | (t >> 8);
#line 297
    if (p) {
#line 297
      tmp___3 = (int )pow_tab[((int )log_tab[14] + (int )log_tab[p]) % 255];
    } else {
#line 297
      tmp___3 = 0;
    }
#line 297
    if (p) {
#line 297
      tmp___4 = (int )pow_tab[((int )log_tab[9] + (int )log_tab[p]) % 255];
    } else {
#line 297
      tmp___4 = 0;
    }
#line 297
    if (p) {
#line 297
      tmp___5 = (int )pow_tab[((int )log_tab[13] + (int )log_tab[p]) % 255];
    } else {
#line 297
      tmp___5 = 0;
    }
#line 297
    if (p) {
#line 297
      tmp___6 = (int )pow_tab[((int )log_tab[11] + (int )log_tab[p]) % 255];
    } else {
#line 297
      tmp___6 = 0;
    }
#line 297
    t = (((unsigned int )tmp___3 | ((unsigned int )tmp___4 << 8)) | ((unsigned int )tmp___5 << 16)) | ((unsigned int )tmp___6 << 24);
#line 302
    it_tab[0][i] = t;
#line 303
    it_tab[1][i] = (t << 8) | (t >> 24);
#line 304
    it_tab[2][i] = (t << 16) | (t >> 16);
#line 305
    it_tab[3][i] = (t << 24) | (t >> 8);
#line 268
    i ++;
  }
#line 308
  tab_gen = 1U;
#line 309
  return;
}
}
#line 356 "rijndael.c"
rijndael_ctx *rijndael_set_key(rijndael_ctx *ctx , u4byte const   *in_key , u4byte key_len ,
                               int encrypt ) 
{ u4byte i ;
  u4byte t ;
  u4byte u ;
  u4byte v ;
  u4byte w ;
  u4byte *e_key ;
  u4byte *d_key ;

  {
#line 361
  e_key = ctx->e_key;
#line 362
  d_key = ctx->d_key;
#line 364
  ctx->decrypt = ! encrypt;
#line 366
  if (! tab_gen) {
#line 367
    gen_tabs();
  }
#line 369
  ctx->k_len = (key_len + 31U) / 32U;
#line 371
  *(e_key + 0) = (unsigned int )*(in_key + 0);
#line 371
  *(e_key + 1) = (unsigned int )*(in_key + 1);
#line 372
  *(e_key + 2) = (unsigned int )*(in_key + 2);
#line 372
  *(e_key + 3) = (unsigned int )*(in_key + 3);
#line 374
  switch ((int )ctx->k_len) {
  case 4: 
#line 375
  t = *(e_key + 3);
#line 376
  i = 0U;
#line 376
  while (i < 10U) {
#line 377
    t = (((fl_tab[0][(unsigned char )((t >> 8) | (t << 24))] ^ fl_tab[1][(unsigned char )(((t >> 8) | (t << 24)) >> 8)]) ^ fl_tab[2][(unsigned char )(((t >> 8) | (t << 24)) >> 16)]) ^ fl_tab[3][(unsigned char )(((t >> 8) | (t << 24)) >> 24)]) ^ rco_tab[i];
#line 377
    t ^= *(e_key + 4U * i);
#line 377
    *(e_key + (4U * i + 4U)) = t;
#line 377
    t ^= *(e_key + (4U * i + 1U));
#line 377
    *(e_key + (4U * i + 5U)) = t;
#line 377
    t ^= *(e_key + (4U * i + 2U));
#line 377
    *(e_key + (4U * i + 6U)) = t;
#line 377
    t ^= *(e_key + (4U * i + 3U));
#line 377
    *(e_key + (4U * i + 7U)) = t;
#line 376
    i ++;
  }
#line 378
  break;
  case 6: 
#line 380
  *(e_key + 4) = (unsigned int )*(in_key + 4);
#line 380
  *(e_key + 5) = (unsigned int )*(in_key + 5);
#line 380
  t = *(e_key + 5);
#line 381
  i = 0U;
#line 381
  while (i < 8U) {
#line 382
    t = (((fl_tab[0][(unsigned char )((t >> 8) | (t << 24))] ^ fl_tab[1][(unsigned char )(((t >> 8) | (t << 24)) >> 8)]) ^ fl_tab[2][(unsigned char )(((t >> 8) | (t << 24)) >> 16)]) ^ fl_tab[3][(unsigned char )(((t >> 8) | (t << 24)) >> 24)]) ^ rco_tab[i];
#line 382
    t ^= *(e_key + 6U * i);
#line 382
    *(e_key + (6U * i + 6U)) = t;
#line 382
    t ^= *(e_key + (6U * i + 1U));
#line 382
    *(e_key + (6U * i + 7U)) = t;
#line 382
    t ^= *(e_key + (6U * i + 2U));
#line 382
    *(e_key + (6U * i + 8U)) = t;
#line 382
    t ^= *(e_key + (6U * i + 3U));
#line 382
    *(e_key + (6U * i + 9U)) = t;
#line 382
    t ^= *(e_key + (6U * i + 4U));
#line 382
    *(e_key + (6U * i + 10U)) = t;
#line 382
    t ^= *(e_key + (6U * i + 5U));
#line 382
    *(e_key + (6U * i + 11U)) = t;
#line 381
    i ++;
  }
#line 383
  break;
  case 8: 
#line 385
  *(e_key + 4) = (unsigned int )*(in_key + 4);
#line 385
  *(e_key + 5) = (unsigned int )*(in_key + 5);
#line 386
  *(e_key + 6) = (unsigned int )*(in_key + 6);
#line 386
  *(e_key + 7) = (unsigned int )*(in_key + 7);
#line 386
  t = *(e_key + 7);
#line 387
  i = 0U;
#line 387
  while (i < 7U) {
#line 388
    t = (((fl_tab[0][(unsigned char )((t >> 8) | (t << 24))] ^ fl_tab[1][(unsigned char )(((t >> 8) | (t << 24)) >> 8)]) ^ fl_tab[2][(unsigned char )(((t >> 8) | (t << 24)) >> 16)]) ^ fl_tab[3][(unsigned char )(((t >> 8) | (t << 24)) >> 24)]) ^ rco_tab[i];
#line 388
    t ^= *(e_key + 8U * i);
#line 388
    *(e_key + (8U * i + 8U)) = t;
#line 388
    t ^= *(e_key + (8U * i + 1U));
#line 388
    *(e_key + (8U * i + 9U)) = t;
#line 388
    t ^= *(e_key + (8U * i + 2U));
#line 388
    *(e_key + (8U * i + 10U)) = t;
#line 388
    t ^= *(e_key + (8U * i + 3U));
#line 388
    *(e_key + (8U * i + 11U)) = t;
#line 388
    t = *(e_key + (8U * i + 4U)) ^ (((fl_tab[0][(unsigned char )t] ^ fl_tab[1][(unsigned char )(t >> 8)]) ^ fl_tab[2][(unsigned char )(t >> 16)]) ^ fl_tab[3][(unsigned char )(t >> 24)]);
#line 388
    *(e_key + (8U * i + 12U)) = t;
#line 388
    t ^= *(e_key + (8U * i + 5U));
#line 388
    *(e_key + (8U * i + 13U)) = t;
#line 388
    t ^= *(e_key + (8U * i + 6U));
#line 388
    *(e_key + (8U * i + 14U)) = t;
#line 388
    t ^= *(e_key + (8U * i + 7U));
#line 388
    *(e_key + (8U * i + 15U)) = t;
#line 387
    i ++;
  }
#line 389
  break;
  }
#line 392
  if (! encrypt) {
#line 393
    *(d_key + 0) = *(e_key + 0);
#line 393
    *(d_key + 1) = *(e_key + 1);
#line 394
    *(d_key + 2) = *(e_key + 2);
#line 394
    *(d_key + 3) = *(e_key + 3);
#line 396
    i = 4U;
#line 396
    while (i < 4U * ctx->k_len + 24U) {
#line 397
      u = ((*(e_key + i) & 2139062143U) << 1) ^ ((*(e_key + i) & 2155905152U) >> 7) * 27U;
#line 397
      v = ((u & 2139062143U) << 1) ^ ((u & 2155905152U) >> 7) * 27U;
#line 397
      w = ((v & 2139062143U) << 1) ^ ((v & 2155905152U) >> 7) * 27U;
#line 397
      t = w ^ *(e_key + i);
#line 397
      *(d_key + i) = (u ^ v) ^ w;
#line 397
      *(d_key + i) ^= ((((u ^ t) >> 8) | ((u ^ t) << 24)) ^ (((v ^ t) >> 16) | ((v ^ t) << 16))) ^ ((t >> 24) | (t << 8));
#line 396
      i ++;
    }
  }
#line 401
  return (ctx);
}
}
#line 419 "rijndael.c"
void rijndael_encrypt(rijndael_ctx *ctx , u4byte const   *in_blk , u4byte *out_blk ) 
{ u4byte k_len ;
  u4byte *e_key ;
  u4byte b0[4] ;
  u4byte b1[4] ;
  u4byte *kp ;

  {
#line 422
  k_len = ctx->k_len;
#line 423
  e_key = ctx->e_key;
#line 426
  b0[0] = (unsigned int )(*(in_blk + 0) ^ (unsigned int const   )*(e_key + 0));
#line 426
  b0[1] = (unsigned int )(*(in_blk + 1) ^ (unsigned int const   )*(e_key + 1));
#line 427
  b0[2] = (unsigned int )(*(in_blk + 2) ^ (unsigned int const   )*(e_key + 2));
#line 427
  b0[3] = (unsigned int )(*(in_blk + 3) ^ (unsigned int const   )*(e_key + 3));
#line 429
  kp = e_key + 4;
#line 431
  if (k_len > 6U) {
#line 432
    b1[0] = (((ft_tab[0][(unsigned char )b0[0]] ^ ft_tab[1][(unsigned char )(b0[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 0);
#line 432
    b1[1] = (((ft_tab[0][(unsigned char )b0[1]] ^ ft_tab[1][(unsigned char )(b0[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 1);
#line 432
    b1[2] = (((ft_tab[0][(unsigned char )b0[2]] ^ ft_tab[1][(unsigned char )(b0[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 2);
#line 432
    b1[3] = (((ft_tab[0][(unsigned char )b0[3]] ^ ft_tab[1][(unsigned char )(b0[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 3);
#line 432
    kp += 4;
#line 432
    b0[0] = (((ft_tab[0][(unsigned char )b1[0]] ^ ft_tab[1][(unsigned char )(b1[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 0);
#line 432
    b0[1] = (((ft_tab[0][(unsigned char )b1[1]] ^ ft_tab[1][(unsigned char )(b1[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 1);
#line 432
    b0[2] = (((ft_tab[0][(unsigned char )b1[2]] ^ ft_tab[1][(unsigned char )(b1[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 2);
#line 432
    b0[3] = (((ft_tab[0][(unsigned char )b1[3]] ^ ft_tab[1][(unsigned char )(b1[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 3);
#line 432
    kp += 4;
  }
#line 435
  if (k_len > 4U) {
#line 436
    b1[0] = (((ft_tab[0][(unsigned char )b0[0]] ^ ft_tab[1][(unsigned char )(b0[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 0);
#line 436
    b1[1] = (((ft_tab[0][(unsigned char )b0[1]] ^ ft_tab[1][(unsigned char )(b0[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 1);
#line 436
    b1[2] = (((ft_tab[0][(unsigned char )b0[2]] ^ ft_tab[1][(unsigned char )(b0[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 2);
#line 436
    b1[3] = (((ft_tab[0][(unsigned char )b0[3]] ^ ft_tab[1][(unsigned char )(b0[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 3);
#line 436
    kp += 4;
#line 436
    b0[0] = (((ft_tab[0][(unsigned char )b1[0]] ^ ft_tab[1][(unsigned char )(b1[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 0);
#line 436
    b0[1] = (((ft_tab[0][(unsigned char )b1[1]] ^ ft_tab[1][(unsigned char )(b1[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 1);
#line 436
    b0[2] = (((ft_tab[0][(unsigned char )b1[2]] ^ ft_tab[1][(unsigned char )(b1[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 2);
#line 436
    b0[3] = (((ft_tab[0][(unsigned char )b1[3]] ^ ft_tab[1][(unsigned char )(b1[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 3);
#line 436
    kp += 4;
  }
#line 439
  b1[0] = (((ft_tab[0][(unsigned char )b0[0]] ^ ft_tab[1][(unsigned char )(b0[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 0);
#line 439
  b1[1] = (((ft_tab[0][(unsigned char )b0[1]] ^ ft_tab[1][(unsigned char )(b0[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 1);
#line 439
  b1[2] = (((ft_tab[0][(unsigned char )b0[2]] ^ ft_tab[1][(unsigned char )(b0[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 2);
#line 439
  b1[3] = (((ft_tab[0][(unsigned char )b0[3]] ^ ft_tab[1][(unsigned char )(b0[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 3);
#line 439
  kp += 4;
#line 439
  b0[0] = (((ft_tab[0][(unsigned char )b1[0]] ^ ft_tab[1][(unsigned char )(b1[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 0);
#line 439
  b0[1] = (((ft_tab[0][(unsigned char )b1[1]] ^ ft_tab[1][(unsigned char )(b1[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 1);
#line 439
  b0[2] = (((ft_tab[0][(unsigned char )b1[2]] ^ ft_tab[1][(unsigned char )(b1[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 2);
#line 439
  b0[3] = (((ft_tab[0][(unsigned char )b1[3]] ^ ft_tab[1][(unsigned char )(b1[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 3);
#line 439
  kp += 4;
#line 440
  b1[0] = (((ft_tab[0][(unsigned char )b0[0]] ^ ft_tab[1][(unsigned char )(b0[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 0);
#line 440
  b1[1] = (((ft_tab[0][(unsigned char )b0[1]] ^ ft_tab[1][(unsigned char )(b0[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 1);
#line 440
  b1[2] = (((ft_tab[0][(unsigned char )b0[2]] ^ ft_tab[1][(unsigned char )(b0[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 2);
#line 440
  b1[3] = (((ft_tab[0][(unsigned char )b0[3]] ^ ft_tab[1][(unsigned char )(b0[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 3);
#line 440
  kp += 4;
#line 440
  b0[0] = (((ft_tab[0][(unsigned char )b1[0]] ^ ft_tab[1][(unsigned char )(b1[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 0);
#line 440
  b0[1] = (((ft_tab[0][(unsigned char )b1[1]] ^ ft_tab[1][(unsigned char )(b1[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 1);
#line 440
  b0[2] = (((ft_tab[0][(unsigned char )b1[2]] ^ ft_tab[1][(unsigned char )(b1[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 2);
#line 440
  b0[3] = (((ft_tab[0][(unsigned char )b1[3]] ^ ft_tab[1][(unsigned char )(b1[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 3);
#line 440
  kp += 4;
#line 441
  b1[0] = (((ft_tab[0][(unsigned char )b0[0]] ^ ft_tab[1][(unsigned char )(b0[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 0);
#line 441
  b1[1] = (((ft_tab[0][(unsigned char )b0[1]] ^ ft_tab[1][(unsigned char )(b0[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 1);
#line 441
  b1[2] = (((ft_tab[0][(unsigned char )b0[2]] ^ ft_tab[1][(unsigned char )(b0[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 2);
#line 441
  b1[3] = (((ft_tab[0][(unsigned char )b0[3]] ^ ft_tab[1][(unsigned char )(b0[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 3);
#line 441
  kp += 4;
#line 441
  b0[0] = (((ft_tab[0][(unsigned char )b1[0]] ^ ft_tab[1][(unsigned char )(b1[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 0);
#line 441
  b0[1] = (((ft_tab[0][(unsigned char )b1[1]] ^ ft_tab[1][(unsigned char )(b1[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 1);
#line 441
  b0[2] = (((ft_tab[0][(unsigned char )b1[2]] ^ ft_tab[1][(unsigned char )(b1[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 2);
#line 441
  b0[3] = (((ft_tab[0][(unsigned char )b1[3]] ^ ft_tab[1][(unsigned char )(b1[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 3);
#line 441
  kp += 4;
#line 442
  b1[0] = (((ft_tab[0][(unsigned char )b0[0]] ^ ft_tab[1][(unsigned char )(b0[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 0);
#line 442
  b1[1] = (((ft_tab[0][(unsigned char )b0[1]] ^ ft_tab[1][(unsigned char )(b0[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 1);
#line 442
  b1[2] = (((ft_tab[0][(unsigned char )b0[2]] ^ ft_tab[1][(unsigned char )(b0[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 2);
#line 442
  b1[3] = (((ft_tab[0][(unsigned char )b0[3]] ^ ft_tab[1][(unsigned char )(b0[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 3);
#line 442
  kp += 4;
#line 442
  b0[0] = (((ft_tab[0][(unsigned char )b1[0]] ^ ft_tab[1][(unsigned char )(b1[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 0);
#line 442
  b0[1] = (((ft_tab[0][(unsigned char )b1[1]] ^ ft_tab[1][(unsigned char )(b1[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 1);
#line 442
  b0[2] = (((ft_tab[0][(unsigned char )b1[2]] ^ ft_tab[1][(unsigned char )(b1[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 2);
#line 442
  b0[3] = (((ft_tab[0][(unsigned char )b1[3]] ^ ft_tab[1][(unsigned char )(b1[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b1[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 3);
#line 442
  kp += 4;
#line 443
  b1[0] = (((ft_tab[0][(unsigned char )b0[0]] ^ ft_tab[1][(unsigned char )(b0[1] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[2] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 0);
#line 443
  b1[1] = (((ft_tab[0][(unsigned char )b0[1]] ^ ft_tab[1][(unsigned char )(b0[2] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[3] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 1);
#line 443
  b1[2] = (((ft_tab[0][(unsigned char )b0[2]] ^ ft_tab[1][(unsigned char )(b0[3] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[0] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 2);
#line 443
  b1[3] = (((ft_tab[0][(unsigned char )b0[3]] ^ ft_tab[1][(unsigned char )(b0[0] >> 8)]) ^ ft_tab[2][(unsigned char )(b0[1] >> 16)]) ^ ft_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 3);
#line 443
  kp += 4;
#line 443
  b0[0] = (((fl_tab[0][(unsigned char )b1[0]] ^ fl_tab[1][(unsigned char )(b1[1] >> 8)]) ^ fl_tab[2][(unsigned char )(b1[2] >> 16)]) ^ fl_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 0);
#line 443
  b0[1] = (((fl_tab[0][(unsigned char )b1[1]] ^ fl_tab[1][(unsigned char )(b1[2] >> 8)]) ^ fl_tab[2][(unsigned char )(b1[3] >> 16)]) ^ fl_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 1);
#line 443
  b0[2] = (((fl_tab[0][(unsigned char )b1[2]] ^ fl_tab[1][(unsigned char )(b1[3] >> 8)]) ^ fl_tab[2][(unsigned char )(b1[0] >> 16)]) ^ fl_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 2);
#line 443
  b0[3] = (((fl_tab[0][(unsigned char )b1[3]] ^ fl_tab[1][(unsigned char )(b1[0] >> 8)]) ^ fl_tab[2][(unsigned char )(b1[1] >> 16)]) ^ fl_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 3);
#line 445
  *(out_blk + 0) = b0[0];
#line 445
  *(out_blk + 1) = b0[1];
#line 446
  *(out_blk + 2) = b0[2];
#line 446
  *(out_blk + 3) = b0[3];
#line 447
  return;
}
}
#line 464 "rijndael.c"
void rijndael_decrypt(rijndael_ctx *ctx , u4byte const   *in_blk , u4byte *out_blk ) 
{ u4byte b0[4] ;
  u4byte b1[4] ;
  u4byte *kp ;
  u4byte k_len ;
  u4byte *e_key ;
  u4byte *d_key ;

  {
#line 468
  k_len = ctx->k_len;
#line 469
  e_key = ctx->e_key;
#line 470
  d_key = ctx->d_key;
#line 472
  b0[0] = (unsigned int )(*(in_blk + 0) ^ (unsigned int const   )*(e_key + (4U * k_len + 24U)));
#line 472
  b0[1] = (unsigned int )(*(in_blk + 1) ^ (unsigned int const   )*(e_key + (4U * k_len + 25U)));
#line 473
  b0[2] = (unsigned int )(*(in_blk + 2) ^ (unsigned int const   )*(e_key + (4U * k_len + 26U)));
#line 473
  b0[3] = (unsigned int )(*(in_blk + 3) ^ (unsigned int const   )*(e_key + (4U * k_len + 27U)));
#line 475
  kp = d_key + 4U * (k_len + 5U);
#line 477
  if (k_len > 6U) {
#line 478
    b1[0] = (((it_tab[0][(unsigned char )b0[0]] ^ it_tab[1][(unsigned char )(b0[3] >> 8)]) ^ it_tab[2][(unsigned char )(b0[2] >> 16)]) ^ it_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 0);
#line 478
    b1[1] = (((it_tab[0][(unsigned char )b0[1]] ^ it_tab[1][(unsigned char )(b0[0] >> 8)]) ^ it_tab[2][(unsigned char )(b0[3] >> 16)]) ^ it_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 1);
#line 478
    b1[2] = (((it_tab[0][(unsigned char )b0[2]] ^ it_tab[1][(unsigned char )(b0[1] >> 8)]) ^ it_tab[2][(unsigned char )(b0[0] >> 16)]) ^ it_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 2);
#line 478
    b1[3] = (((it_tab[0][(unsigned char )b0[3]] ^ it_tab[1][(unsigned char )(b0[2] >> 8)]) ^ it_tab[2][(unsigned char )(b0[1] >> 16)]) ^ it_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 3);
#line 478
    kp -= 4;
#line 478
    b0[0] = (((it_tab[0][(unsigned char )b1[0]] ^ it_tab[1][(unsigned char )(b1[3] >> 8)]) ^ it_tab[2][(unsigned char )(b1[2] >> 16)]) ^ it_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 0);
#line 478
    b0[1] = (((it_tab[0][(unsigned char )b1[1]] ^ it_tab[1][(unsigned char )(b1[0] >> 8)]) ^ it_tab[2][(unsigned char )(b1[3] >> 16)]) ^ it_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 1);
#line 478
    b0[2] = (((it_tab[0][(unsigned char )b1[2]] ^ it_tab[1][(unsigned char )(b1[1] >> 8)]) ^ it_tab[2][(unsigned char )(b1[0] >> 16)]) ^ it_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 2);
#line 478
    b0[3] = (((it_tab[0][(unsigned char )b1[3]] ^ it_tab[1][(unsigned char )(b1[2] >> 8)]) ^ it_tab[2][(unsigned char )(b1[1] >> 16)]) ^ it_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 3);
#line 478
    kp -= 4;
  }
#line 481
  if (k_len > 4U) {
#line 482
    b1[0] = (((it_tab[0][(unsigned char )b0[0]] ^ it_tab[1][(unsigned char )(b0[3] >> 8)]) ^ it_tab[2][(unsigned char )(b0[2] >> 16)]) ^ it_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 0);
#line 482
    b1[1] = (((it_tab[0][(unsigned char )b0[1]] ^ it_tab[1][(unsigned char )(b0[0] >> 8)]) ^ it_tab[2][(unsigned char )(b0[3] >> 16)]) ^ it_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 1);
#line 482
    b1[2] = (((it_tab[0][(unsigned char )b0[2]] ^ it_tab[1][(unsigned char )(b0[1] >> 8)]) ^ it_tab[2][(unsigned char )(b0[0] >> 16)]) ^ it_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 2);
#line 482
    b1[3] = (((it_tab[0][(unsigned char )b0[3]] ^ it_tab[1][(unsigned char )(b0[2] >> 8)]) ^ it_tab[2][(unsigned char )(b0[1] >> 16)]) ^ it_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 3);
#line 482
    kp -= 4;
#line 482
    b0[0] = (((it_tab[0][(unsigned char )b1[0]] ^ it_tab[1][(unsigned char )(b1[3] >> 8)]) ^ it_tab[2][(unsigned char )(b1[2] >> 16)]) ^ it_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 0);
#line 482
    b0[1] = (((it_tab[0][(unsigned char )b1[1]] ^ it_tab[1][(unsigned char )(b1[0] >> 8)]) ^ it_tab[2][(unsigned char )(b1[3] >> 16)]) ^ it_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 1);
#line 482
    b0[2] = (((it_tab[0][(unsigned char )b1[2]] ^ it_tab[1][(unsigned char )(b1[1] >> 8)]) ^ it_tab[2][(unsigned char )(b1[0] >> 16)]) ^ it_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 2);
#line 482
    b0[3] = (((it_tab[0][(unsigned char )b1[3]] ^ it_tab[1][(unsigned char )(b1[2] >> 8)]) ^ it_tab[2][(unsigned char )(b1[1] >> 16)]) ^ it_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 3);
#line 482
    kp -= 4;
  }
#line 485
  b1[0] = (((it_tab[0][(unsigned char )b0[0]] ^ it_tab[1][(unsigned char )(b0[3] >> 8)]) ^ it_tab[2][(unsigned char )(b0[2] >> 16)]) ^ it_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 0);
#line 485
  b1[1] = (((it_tab[0][(unsigned char )b0[1]] ^ it_tab[1][(unsigned char )(b0[0] >> 8)]) ^ it_tab[2][(unsigned char )(b0[3] >> 16)]) ^ it_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 1);
#line 485
  b1[2] = (((it_tab[0][(unsigned char )b0[2]] ^ it_tab[1][(unsigned char )(b0[1] >> 8)]) ^ it_tab[2][(unsigned char )(b0[0] >> 16)]) ^ it_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 2);
#line 485
  b1[3] = (((it_tab[0][(unsigned char )b0[3]] ^ it_tab[1][(unsigned char )(b0[2] >> 8)]) ^ it_tab[2][(unsigned char )(b0[1] >> 16)]) ^ it_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 3);
#line 485
  kp -= 4;
#line 485
  b0[0] = (((it_tab[0][(unsigned char )b1[0]] ^ it_tab[1][(unsigned char )(b1[3] >> 8)]) ^ it_tab[2][(unsigned char )(b1[2] >> 16)]) ^ it_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 0);
#line 485
  b0[1] = (((it_tab[0][(unsigned char )b1[1]] ^ it_tab[1][(unsigned char )(b1[0] >> 8)]) ^ it_tab[2][(unsigned char )(b1[3] >> 16)]) ^ it_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 1);
#line 485
  b0[2] = (((it_tab[0][(unsigned char )b1[2]] ^ it_tab[1][(unsigned char )(b1[1] >> 8)]) ^ it_tab[2][(unsigned char )(b1[0] >> 16)]) ^ it_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 2);
#line 485
  b0[3] = (((it_tab[0][(unsigned char )b1[3]] ^ it_tab[1][(unsigned char )(b1[2] >> 8)]) ^ it_tab[2][(unsigned char )(b1[1] >> 16)]) ^ it_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 3);
#line 485
  kp -= 4;
#line 486
  b1[0] = (((it_tab[0][(unsigned char )b0[0]] ^ it_tab[1][(unsigned char )(b0[3] >> 8)]) ^ it_tab[2][(unsigned char )(b0[2] >> 16)]) ^ it_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 0);
#line 486
  b1[1] = (((it_tab[0][(unsigned char )b0[1]] ^ it_tab[1][(unsigned char )(b0[0] >> 8)]) ^ it_tab[2][(unsigned char )(b0[3] >> 16)]) ^ it_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 1);
#line 486
  b1[2] = (((it_tab[0][(unsigned char )b0[2]] ^ it_tab[1][(unsigned char )(b0[1] >> 8)]) ^ it_tab[2][(unsigned char )(b0[0] >> 16)]) ^ it_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 2);
#line 486
  b1[3] = (((it_tab[0][(unsigned char )b0[3]] ^ it_tab[1][(unsigned char )(b0[2] >> 8)]) ^ it_tab[2][(unsigned char )(b0[1] >> 16)]) ^ it_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 3);
#line 486
  kp -= 4;
#line 486
  b0[0] = (((it_tab[0][(unsigned char )b1[0]] ^ it_tab[1][(unsigned char )(b1[3] >> 8)]) ^ it_tab[2][(unsigned char )(b1[2] >> 16)]) ^ it_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 0);
#line 486
  b0[1] = (((it_tab[0][(unsigned char )b1[1]] ^ it_tab[1][(unsigned char )(b1[0] >> 8)]) ^ it_tab[2][(unsigned char )(b1[3] >> 16)]) ^ it_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 1);
#line 486
  b0[2] = (((it_tab[0][(unsigned char )b1[2]] ^ it_tab[1][(unsigned char )(b1[1] >> 8)]) ^ it_tab[2][(unsigned char )(b1[0] >> 16)]) ^ it_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 2);
#line 486
  b0[3] = (((it_tab[0][(unsigned char )b1[3]] ^ it_tab[1][(unsigned char )(b1[2] >> 8)]) ^ it_tab[2][(unsigned char )(b1[1] >> 16)]) ^ it_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 3);
#line 486
  kp -= 4;
#line 487
  b1[0] = (((it_tab[0][(unsigned char )b0[0]] ^ it_tab[1][(unsigned char )(b0[3] >> 8)]) ^ it_tab[2][(unsigned char )(b0[2] >> 16)]) ^ it_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 0);
#line 487
  b1[1] = (((it_tab[0][(unsigned char )b0[1]] ^ it_tab[1][(unsigned char )(b0[0] >> 8)]) ^ it_tab[2][(unsigned char )(b0[3] >> 16)]) ^ it_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 1);
#line 487
  b1[2] = (((it_tab[0][(unsigned char )b0[2]] ^ it_tab[1][(unsigned char )(b0[1] >> 8)]) ^ it_tab[2][(unsigned char )(b0[0] >> 16)]) ^ it_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 2);
#line 487
  b1[3] = (((it_tab[0][(unsigned char )b0[3]] ^ it_tab[1][(unsigned char )(b0[2] >> 8)]) ^ it_tab[2][(unsigned char )(b0[1] >> 16)]) ^ it_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 3);
#line 487
  kp -= 4;
#line 487
  b0[0] = (((it_tab[0][(unsigned char )b1[0]] ^ it_tab[1][(unsigned char )(b1[3] >> 8)]) ^ it_tab[2][(unsigned char )(b1[2] >> 16)]) ^ it_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 0);
#line 487
  b0[1] = (((it_tab[0][(unsigned char )b1[1]] ^ it_tab[1][(unsigned char )(b1[0] >> 8)]) ^ it_tab[2][(unsigned char )(b1[3] >> 16)]) ^ it_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 1);
#line 487
  b0[2] = (((it_tab[0][(unsigned char )b1[2]] ^ it_tab[1][(unsigned char )(b1[1] >> 8)]) ^ it_tab[2][(unsigned char )(b1[0] >> 16)]) ^ it_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 2);
#line 487
  b0[3] = (((it_tab[0][(unsigned char )b1[3]] ^ it_tab[1][(unsigned char )(b1[2] >> 8)]) ^ it_tab[2][(unsigned char )(b1[1] >> 16)]) ^ it_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 3);
#line 487
  kp -= 4;
#line 488
  b1[0] = (((it_tab[0][(unsigned char )b0[0]] ^ it_tab[1][(unsigned char )(b0[3] >> 8)]) ^ it_tab[2][(unsigned char )(b0[2] >> 16)]) ^ it_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 0);
#line 488
  b1[1] = (((it_tab[0][(unsigned char )b0[1]] ^ it_tab[1][(unsigned char )(b0[0] >> 8)]) ^ it_tab[2][(unsigned char )(b0[3] >> 16)]) ^ it_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 1);
#line 488
  b1[2] = (((it_tab[0][(unsigned char )b0[2]] ^ it_tab[1][(unsigned char )(b0[1] >> 8)]) ^ it_tab[2][(unsigned char )(b0[0] >> 16)]) ^ it_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 2);
#line 488
  b1[3] = (((it_tab[0][(unsigned char )b0[3]] ^ it_tab[1][(unsigned char )(b0[2] >> 8)]) ^ it_tab[2][(unsigned char )(b0[1] >> 16)]) ^ it_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 3);
#line 488
  kp -= 4;
#line 488
  b0[0] = (((it_tab[0][(unsigned char )b1[0]] ^ it_tab[1][(unsigned char )(b1[3] >> 8)]) ^ it_tab[2][(unsigned char )(b1[2] >> 16)]) ^ it_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 0);
#line 488
  b0[1] = (((it_tab[0][(unsigned char )b1[1]] ^ it_tab[1][(unsigned char )(b1[0] >> 8)]) ^ it_tab[2][(unsigned char )(b1[3] >> 16)]) ^ it_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 1);
#line 488
  b0[2] = (((it_tab[0][(unsigned char )b1[2]] ^ it_tab[1][(unsigned char )(b1[1] >> 8)]) ^ it_tab[2][(unsigned char )(b1[0] >> 16)]) ^ it_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 2);
#line 488
  b0[3] = (((it_tab[0][(unsigned char )b1[3]] ^ it_tab[1][(unsigned char )(b1[2] >> 8)]) ^ it_tab[2][(unsigned char )(b1[1] >> 16)]) ^ it_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 3);
#line 488
  kp -= 4;
#line 489
  b1[0] = (((it_tab[0][(unsigned char )b0[0]] ^ it_tab[1][(unsigned char )(b0[3] >> 8)]) ^ it_tab[2][(unsigned char )(b0[2] >> 16)]) ^ it_tab[3][(unsigned char )(b0[1] >> 24)]) ^ *(kp + 0);
#line 489
  b1[1] = (((it_tab[0][(unsigned char )b0[1]] ^ it_tab[1][(unsigned char )(b0[0] >> 8)]) ^ it_tab[2][(unsigned char )(b0[3] >> 16)]) ^ it_tab[3][(unsigned char )(b0[2] >> 24)]) ^ *(kp + 1);
#line 489
  b1[2] = (((it_tab[0][(unsigned char )b0[2]] ^ it_tab[1][(unsigned char )(b0[1] >> 8)]) ^ it_tab[2][(unsigned char )(b0[0] >> 16)]) ^ it_tab[3][(unsigned char )(b0[3] >> 24)]) ^ *(kp + 2);
#line 489
  b1[3] = (((it_tab[0][(unsigned char )b0[3]] ^ it_tab[1][(unsigned char )(b0[2] >> 8)]) ^ it_tab[2][(unsigned char )(b0[1] >> 16)]) ^ it_tab[3][(unsigned char )(b0[0] >> 24)]) ^ *(kp + 3);
#line 489
  kp -= 4;
#line 489
  b0[0] = (((il_tab[0][(unsigned char )b1[0]] ^ il_tab[1][(unsigned char )(b1[3] >> 8)]) ^ il_tab[2][(unsigned char )(b1[2] >> 16)]) ^ il_tab[3][(unsigned char )(b1[1] >> 24)]) ^ *(kp + 0);
#line 489
  b0[1] = (((il_tab[0][(unsigned char )b1[1]] ^ il_tab[1][(unsigned char )(b1[0] >> 8)]) ^ il_tab[2][(unsigned char )(b1[3] >> 16)]) ^ il_tab[3][(unsigned char )(b1[2] >> 24)]) ^ *(kp + 1);
#line 489
  b0[2] = (((il_tab[0][(unsigned char )b1[2]] ^ il_tab[1][(unsigned char )(b1[1] >> 8)]) ^ il_tab[2][(unsigned char )(b1[0] >> 16)]) ^ il_tab[3][(unsigned char )(b1[3] >> 24)]) ^ *(kp + 2);
#line 489
  b0[3] = (((il_tab[0][(unsigned char )b1[3]] ^ il_tab[1][(unsigned char )(b1[2] >> 8)]) ^ il_tab[2][(unsigned char )(b1[1] >> 16)]) ^ il_tab[3][(unsigned char )(b1[0] >> 24)]) ^ *(kp + 3);
#line 491
  *(out_blk + 0) = b0[0];
#line 491
  *(out_blk + 1) = b0[1];
#line 492
  *(out_blk + 2) = b0[2];
#line 492
  *(out_blk + 3) = b0[3];
#line 493
  return;
}
}
#line 1 "entropy.o"
#line 28 "entropy.h"
void seed_rng(void) ;
#line 29
void init_rng(void) ;
#line 105 "/usr/include/openssl/rand.h"
extern void RAND_add(void const   *buf , int num , double entropy ) ;
#line 109
extern int RAND_status(void) ;
#line 122 "entropy.c"
int get_random_bytes(unsigned char *buf___1 , int len ) 
{ int random_pool ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 126
  random_pool = open("/dev/urandom", 0);
#line 127
  if (random_pool == -1) {
#line 128
    tmp = __errno_location();
#line 128
    tmp___0 = strerror(*tmp);
#line 128
    error("Couldn\'t open random pool \"%s\": %s", "/dev/urandom", tmp___0);
#line 130
    return (0);
  }
#line 133
  tmp___3 = atomicio((ssize_t (*)())(& read), random_pool, (void *)buf___1, (unsigned int )len);
#line 133
  if (tmp___3 != len) {
#line 134
    tmp___1 = __errno_location();
#line 134
    tmp___2 = strerror(*tmp___1);
#line 134
    error("Couldn\'t read from random pool \"%s\": %s", "/dev/urandom", tmp___2);
#line 136
    close(random_pool);
#line 137
    return (0);
  }
#line 140
  close(random_pool);
#line 142
  return (1);
}
}
#line 151 "entropy.c"
void seed_rng(void) 
{ char buf___1[32] ;
  int tmp ;
  int tmp___0 ;

  {
#line 156
  debug("Seeding random number generator");
#line 158
  tmp___0 = get_random_bytes((unsigned char *)(buf___1), (int )sizeof(buf___1));
#line 158
  if (tmp___0) {
#line 162
    RAND_add((void const   *)(buf___1), (int )sizeof(buf___1), (double )sizeof(buf___1));
  } else {
#line 159
    tmp = RAND_status();
#line 159
    if (! tmp) {
#line 160
      fatal("Entropy collection failed and entropy exhausted");
    }
  }
#line 165
  memset((void *)(buf___1), '\000', sizeof(buf___1));
#line 166
  return;
}
}
#line 169 "entropy.c"
void init_rng(void) 
{ 

  {
#line 169
  return;
}
}
#line 1 "readpass.o"
#line 419 "ssh.h"
char *read_passphrase(char *prompt , int from_stdin ) ;
#line 51 "readpass.c"
char *read_passphrase(char *prompt , int from_stdin ) 
{ char *tmp ;

  {
#line 54
  tmp = cli_read_passphrase(prompt, from_stdin, 0);
#line 54
  return (tmp);
}
}
#line 1 "rsa.o"
#line 333 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 221 "/usr/include/openssl/rsa.h"
extern RSA *RSA_generate_key(int bits , unsigned long e , void (*callback)(int  ,
                                                                           int  ,
                                                                           void * ) ,
                             void *cb_arg ) ;
#line 230
extern int RSA_public_encrypt(int flen , unsigned char const   *from , unsigned char *to ,
                              RSA *rsa , int padding ) ;
#line 236
extern int RSA_private_decrypt(int flen , unsigned char const   *from , unsigned char *to ,
                               RSA *rsa , int padding ) ;
#line 23 "rsa.h"
void rsa_generate_key(RSA *prv , RSA *pub , unsigned int bits ) ;
#line 29
void rsa_set_verbose(int verbose___0 ) ;
#line 31
int rsa_alive(void) ;
#line 33
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 34
void rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 70 "rsa.c"
int rsa_verbose  =    1;
#line 72 "rsa.c"
int rsa_alive(void) 
{ RSA *key ;

  {
#line 77
  seed_rng();
#line 78
  key = RSA_generate_key(32, 3UL, (void (*)(int  , int  , void * ))((void *)0), (void *)0);
#line 79
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 80
    return (0);
  }
#line 81
  RSA_free(key);
#line 82
  return (1);
}
}
#line 91 "rsa.c"
void rsa_generate_key(RSA *prv , RSA *pub , unsigned int bits ) 
{ RSA *key ;

  {
#line 96
  seed_rng();
#line 98
  if (rsa_verbose) {
#line 99
    printf((char const   * __restrict  )"Generating RSA keys:  ");
#line 100
    fflush(stdout);
  }
#line 102
  key = RSA_generate_key((int )bits, 35UL, (void (*)(int  , int  , void * ))((void *)0),
                         (void *)0);
#line 103
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 104
    fatal("rsa_generate_key: key generation failed.");
  }
#line 107
  pub->n = BN_new();
#line 108
  BN_copy(pub->n, (BIGNUM const   *)key->n);
#line 109
  pub->e = BN_new();
#line 110
  BN_copy(pub->e, (BIGNUM const   *)key->e);
#line 113
  prv->n = BN_new();
#line 114
  BN_copy(prv->n, (BIGNUM const   *)key->n);
#line 115
  prv->e = BN_new();
#line 116
  BN_copy(prv->e, (BIGNUM const   *)key->e);
#line 117
  prv->d = BN_new();
#line 118
  BN_copy(prv->d, (BIGNUM const   *)key->d);
#line 119
  prv->p = BN_new();
#line 120
  BN_copy(prv->p, (BIGNUM const   *)key->p);
#line 121
  prv->q = BN_new();
#line 122
  BN_copy(prv->q, (BIGNUM const   *)key->q);
#line 124
  prv->dmp1 = BN_new();
#line 125
  BN_copy(prv->dmp1, (BIGNUM const   *)key->dmp1);
#line 127
  prv->dmq1 = BN_new();
#line 128
  BN_copy(prv->dmq1, (BIGNUM const   *)key->dmq1);
#line 130
  prv->iqmp = BN_new();
#line 131
  BN_copy(prv->iqmp, (BIGNUM const   *)key->iqmp);
#line 133
  RSA_free(key);
#line 135
  if (rsa_verbose) {
#line 136
    printf((char const   * __restrict  )"Key generation complete.\n");
  }
#line 137
  return;
}
}
#line 139 "rsa.c"
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ unsigned char *inbuf ;
  unsigned char *outbuf ;
  int len ;
  int ilen ;
  int olen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 145
  tmp = BN_num_bits((BIGNUM const   *)key->e);
#line 145
  if (tmp < 2) {
#line 146
    fatal("rsa_public_encrypt() exponent too small or not odd");
  } else {
#line 145
    if ((key->e)->top > 0) {
#line 145
      if (! (*((key->e)->d + 0) & 1UL)) {
#line 146
        fatal("rsa_public_encrypt() exponent too small or not odd");
      }
    } else {
#line 146
      fatal("rsa_public_encrypt() exponent too small or not odd");
    }
  }
#line 148
  tmp___0 = BN_num_bits((BIGNUM const   *)key->n);
#line 148
  olen = (tmp___0 + 7) / 8;
#line 149
  tmp___1 = xmalloc((unsigned int )olen);
#line 149
  outbuf = (unsigned char *)tmp___1;
#line 151
  tmp___2 = BN_num_bits((BIGNUM const   *)in);
#line 151
  ilen = (tmp___2 + 7) / 8;
#line 152
  tmp___3 = xmalloc((unsigned int )ilen);
#line 152
  inbuf = (unsigned char *)tmp___3;
#line 153
  BN_bn2bin((BIGNUM const   *)in, inbuf);
#line 155
  len = RSA_public_encrypt(ilen, (unsigned char const   *)inbuf, outbuf, key, 1);
#line 155
  if (len <= 0) {
#line 157
    fatal("rsa_public_encrypt() failed");
  }
#line 159
  BN_bin2bn((unsigned char const   *)outbuf, len, out);
#line 161
  memset((void *)outbuf, 0, (unsigned int )olen);
#line 162
  memset((void *)inbuf, 0, (unsigned int )ilen);
#line 163
  xfree((void *)outbuf);
#line 164
  xfree((void *)inbuf);
#line 165
  return;
}
}
#line 167 "rsa.c"
void rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ unsigned char *inbuf ;
  unsigned char *outbuf ;
  int len ;
  int ilen ;
  int olen ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 173
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 173
  olen = (tmp + 7) / 8;
#line 174
  tmp___0 = xmalloc((unsigned int )olen);
#line 174
  outbuf = (unsigned char *)tmp___0;
#line 176
  tmp___1 = BN_num_bits((BIGNUM const   *)in);
#line 176
  ilen = (tmp___1 + 7) / 8;
#line 177
  tmp___2 = xmalloc((unsigned int )ilen);
#line 177
  inbuf = (unsigned char *)tmp___2;
#line 178
  BN_bn2bin((BIGNUM const   *)in, inbuf);
#line 180
  len = RSA_private_decrypt(ilen, (unsigned char const   *)inbuf, outbuf, key, 1);
#line 180
  if (len <= 0) {
#line 182
    fatal("rsa_private_decrypt() failed");
  }
#line 184
  BN_bin2bn((unsigned char const   *)outbuf, len, out);
#line 186
  memset((void *)outbuf, 0, (unsigned int )olen);
#line 187
  memset((void *)inbuf, 0, (unsigned int )ilen);
#line 188
  xfree((void *)outbuf);
#line 189
  xfree((void *)inbuf);
#line 190
  return;
}
}
#line 194 "rsa.c"
void rsa_set_verbose(int verbose___0 ) 
{ 

  {
#line 197
  rsa_verbose = verbose___0;
#line 198
  return;
}
}
#line 1 "tildexpand.o"
#line 111 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 117
extern struct passwd *getpwnam(char const   *__name ) ;
#line 487 "ssh.h"
char *tilde_expand_filename(char const   *filename , uid_t my_uid ) ;
#line 23 "tildexpand.c"
char *tilde_expand_filename(char const   *filename , uid_t my_uid ) 
{ char const   *cp ;
  unsigned int userlen ;
  char *expanded ;
  struct passwd *pw ;
  char user[100] ;
  int len ;
  char *tmp ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;

  {
#line 34
  if ((int const   )*(filename + 0) != 126) {
#line 35
    tmp = xstrdup(filename);
#line 35
    return (tmp);
  }
#line 38
  filename ++;
#line 41
  tmp___1 = __builtin_strchr((char *)filename, '/');
#line 41
  cp = (char const   *)tmp___1;
#line 42
  if (cp) {
#line 43
    userlen = (unsigned int )(cp - filename);
  } else {
#line 45
    userlen = strlen(filename);
  }
#line 46
  if (userlen == 0U) {
#line 47
    pw = getpwuid(my_uid);
  } else {
#line 50
    if (userlen > sizeof(user) - 1U) {
#line 51
      fatal("User name after tilde too long.");
    }
#line 52
    memcpy((void * __restrict  )(user), (void const   * __restrict  )filename, userlen);
#line 53
    user[userlen] = (char)0;
#line 54
    pw = getpwnam((char const   *)(user));
  }
#line 56
  if (! pw) {
#line 57
    fatal("Unknown user %100s.", user);
  }
#line 60
  if (! cp) {
#line 62
    tmp___2 = xstrdup((char const   *)pw->pw_dir);
#line 62
    return (tmp___2);
  }
#line 65
  tmp___3 = strlen((char const   *)pw->pw_dir);
#line 65
  tmp___4 = strlen(cp + 1);
#line 65
  len = (int )((tmp___3 + tmp___4) + 2U);
#line 66
  if (len > 4096) {
#line 67
    fatal("Home directory too long (%d > %d", len - 1, 4095);
  }
#line 68
  tmp___5 = xmalloc((unsigned int )len);
#line 68
  expanded = (char *)tmp___5;
#line 69
  snprintf((char * __restrict  )expanded, (unsigned int )len, (char const   * __restrict  )"%s/%s",
           pw->pw_dir, cp + 1);
#line 70
  return (expanded);
}
}
#line 1 "ttymodes.o"
#line 49 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) speed_t cfgetospeed(struct termios  const  *__termios_p ) ;
#line 52
extern  __attribute__((__nothrow__)) speed_t cfgetispeed(struct termios  const  *__termios_p ) ;
#line 55
extern  __attribute__((__nothrow__)) int cfsetospeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 58
extern  __attribute__((__nothrow__)) int cfsetispeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 182 "packet.h"
void tty_make_modes(int fd ) ;
#line 185
void tty_parse_modes(int fd , int *n_bytes_ptr ) ;
#line 31 "ttymodes.c"
static int speed_to_baud(speed_t speed ) 
{ 

  {
#line 34
  switch ((int )speed) {
  case 0: 
#line 36
  return (0);
  case 1: 
#line 38
  return (50);
  case 2: 
#line 40
  return (75);
  case 3: 
#line 42
  return (110);
  case 4: 
#line 44
  return (134);
  case 5: 
#line 46
  return (150);
  case 6: 
#line 48
  return (200);
  case 7: 
#line 50
  return (300);
  case 8: 
#line 52
  return (600);
  case 9: 
#line 54
  return (1200);
  case 10: 
#line 56
  return (1800);
  case 11: 
#line 58
  return (2400);
  case 12: 
#line 60
  return (4800);
  case 13: 
#line 62
  return (9600);
  case 14: 
#line 66
  return (19200);
  case 15: 
#line 76
  return (38400);
  case 4097: 
#line 98
  return (57600);
  case 4098: 
#line 106
  return (115200);
  case 4099: 
#line 110
  return (230400);
  default: ;
#line 113
  return (9600);
  }
}
}
#line 120 "ttymodes.c"
static speed_t baud_to_speed(int baud ) 
{ 

  {
#line 123
  switch (baud) {
  case 0: 
#line 125
  return (0U);
  case 50: 
#line 127
  return (1U);
  case 75: 
#line 129
  return (2U);
  case 110: 
#line 131
  return (3U);
  case 134: 
#line 133
  return (4U);
  case 150: 
#line 135
  return (5U);
  case 200: 
#line 137
  return (6U);
  case 300: 
#line 139
  return (7U);
  case 600: 
#line 141
  return (8U);
  case 1200: 
#line 143
  return (9U);
  case 1800: 
#line 145
  return (10U);
  case 2400: 
#line 147
  return (11U);
  case 4800: 
#line 149
  return (12U);
  case 9600: 
#line 151
  return (13U);
  case 19200: 
#line 155
  return (14U);
  case 38400: 
#line 165
  return (15U);
  case 57600: 
#line 187
  return (4097U);
  case 115200: 
#line 195
  return (4098U);
  case 230400: 
#line 199
  return (4099U);
  default: ;
#line 202
  return (13U);
  }
}
}
#line 211 "ttymodes.c"
void tty_make_modes(int fd ) 
{ struct termios tio ;
  int baud ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  speed_t tmp___2 ;
  speed_t tmp___3 ;

  {
#line 217
  tmp___1 = tcgetattr(fd, & tio);
#line 217
  if (tmp___1 < 0) {
#line 218
    packet_put_char(0);
#line 219
    tmp = __errno_location();
#line 219
    tmp___0 = strerror(*tmp);
#line 219
    log("tcgetattr: %.100s", tmp___0);
#line 220
    return;
  }
#line 223
  tmp___2 = cfgetospeed((struct termios  const  *)(& tio));
#line 223
  baud = speed_to_baud(tmp___2);
#line 224
  packet_put_char(193);
#line 225
  packet_put_int((unsigned int )baud);
#line 226
  tmp___3 = cfgetispeed((struct termios  const  *)(& tio));
#line 226
  baud = speed_to_baud(tmp___3);
#line 227
  packet_put_char(192);
#line 228
  packet_put_int((unsigned int )baud);
#line 36 "ttymodes.h"
  packet_put_char(1);
#line 36
  packet_put_char((int )tio.c_cc[0]);
#line 37
  packet_put_char(2);
#line 37
  packet_put_char((int )tio.c_cc[1]);
#line 38
  packet_put_char(3);
#line 38
  packet_put_char((int )tio.c_cc[2]);
#line 40
  packet_put_char(4);
#line 40
  packet_put_char((int )tio.c_cc[3]);
#line 42
  packet_put_char(5);
#line 42
  packet_put_char((int )tio.c_cc[4]);
#line 44
  packet_put_char(6);
#line 44
  packet_put_char((int )tio.c_cc[11]);
#line 47
  packet_put_char(7);
#line 47
  packet_put_char((int )tio.c_cc[16]);
#line 49
  packet_put_char(8);
#line 49
  packet_put_char((int )tio.c_cc[8]);
#line 50
  packet_put_char(9);
#line 50
  packet_put_char((int )tio.c_cc[9]);
#line 52
  packet_put_char(10);
#line 52
  packet_put_char((int )tio.c_cc[10]);
#line 58
  packet_put_char(12);
#line 58
  packet_put_char((int )tio.c_cc[12]);
#line 61
  packet_put_char(13);
#line 61
  packet_put_char((int )tio.c_cc[14]);
#line 64
  packet_put_char(14);
#line 64
  packet_put_char((int )tio.c_cc[15]);
#line 76
  packet_put_char(18);
#line 76
  packet_put_char((int )tio.c_cc[13]);
#line 80
  packet_put_char(30);
#line 80
  packet_put_char((tio.c_iflag & 4U) != 0U);
#line 81
  packet_put_char(31);
#line 81
  packet_put_char((tio.c_iflag & 8U) != 0U);
#line 82
  packet_put_char(32);
#line 82
  packet_put_char((tio.c_iflag & 16U) != 0U);
#line 83
  packet_put_char(33);
#line 83
  packet_put_char((tio.c_iflag & 32U) != 0U);
#line 84
  packet_put_char(34);
#line 84
  packet_put_char((tio.c_iflag & 64U) != 0U);
#line 85
  packet_put_char(35);
#line 85
  packet_put_char((tio.c_iflag & 128U) != 0U);
#line 86
  packet_put_char(36);
#line 86
  packet_put_char((tio.c_iflag & 256U) != 0U);
#line 88
  packet_put_char(37);
#line 88
  packet_put_char((tio.c_iflag & 512U) != 0U);
#line 90
  packet_put_char(38);
#line 90
  packet_put_char((tio.c_iflag & 1024U) != 0U);
#line 91
  packet_put_char(39);
#line 91
  packet_put_char((tio.c_iflag & 2048U) != 0U);
#line 92
  packet_put_char(40);
#line 92
  packet_put_char((tio.c_iflag & 4096U) != 0U);
#line 94
  packet_put_char(41);
#line 94
  packet_put_char((tio.c_iflag & 8192U) != 0U);
#line 97
  packet_put_char(50);
#line 97
  packet_put_char((tio.c_lflag & 1U) != 0U);
#line 98
  packet_put_char(51);
#line 98
  packet_put_char((tio.c_lflag & 2U) != 0U);
#line 100
  packet_put_char(52);
#line 100
  packet_put_char((tio.c_lflag & 4U) != 0U);
#line 102
  packet_put_char(53);
#line 102
  packet_put_char((tio.c_lflag & 8U) != 0U);
#line 103
  packet_put_char(54);
#line 103
  packet_put_char((tio.c_lflag & 16U) != 0U);
#line 104
  packet_put_char(55);
#line 104
  packet_put_char((tio.c_lflag & 32U) != 0U);
#line 105
  packet_put_char(56);
#line 105
  packet_put_char((tio.c_lflag & 64U) != 0U);
#line 106
  packet_put_char(57);
#line 106
  packet_put_char((tio.c_lflag & 128U) != 0U);
#line 107
  packet_put_char(58);
#line 107
  packet_put_char((tio.c_lflag & 256U) != 0U);
#line 109
  packet_put_char(59);
#line 109
  packet_put_char((tio.c_lflag & 32768U) != 0U);
#line 112
  packet_put_char(60);
#line 112
  packet_put_char((tio.c_lflag & 512U) != 0U);
#line 115
  packet_put_char(61);
#line 115
  packet_put_char((tio.c_lflag & 2048U) != 0U);
#line 118
  packet_put_char(62);
#line 118
  packet_put_char((tio.c_lflag & 16384U) != 0U);
#line 121
  packet_put_char(70);
#line 121
  packet_put_char((tio.c_oflag & 1U) != 0U);
#line 123
  packet_put_char(71);
#line 123
  packet_put_char((tio.c_oflag & 2U) != 0U);
#line 125
  packet_put_char(72);
#line 125
  packet_put_char((tio.c_oflag & 4U) != 0U);
#line 127
  packet_put_char(73);
#line 127
  packet_put_char((tio.c_oflag & 8U) != 0U);
#line 130
  packet_put_char(74);
#line 130
  packet_put_char((tio.c_oflag & 16U) != 0U);
#line 133
  packet_put_char(75);
#line 133
  packet_put_char((tio.c_oflag & 32U) != 0U);
#line 136
  packet_put_char(90);
#line 136
  packet_put_char((tio.c_cflag & 32U) != 0U);
#line 137
  packet_put_char(91);
#line 137
  packet_put_char((tio.c_cflag & 48U) != 0U);
#line 138
  packet_put_char(92);
#line 138
  packet_put_char((tio.c_cflag & 256U) != 0U);
#line 139
  packet_put_char(93);
#line 139
  packet_put_char((tio.c_cflag & 512U) != 0U);
#line 248 "ttymodes.c"
  packet_put_char(0);
#line 249
  return;
}
}
#line 255 "ttymodes.c"
void tty_parse_modes(int fd , int *n_bytes_ptr ) 
{ struct termios tio ;
  int opcode ;
  int baud ;
  int n_bytes ;
  int failure ;
  int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  speed_t tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  speed_t tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;
  unsigned int tmp___22 ;
  unsigned int tmp___23 ;
  unsigned int tmp___24 ;
  unsigned int tmp___25 ;
  unsigned int tmp___26 ;
  unsigned int tmp___27 ;
  unsigned int tmp___28 ;
  unsigned int tmp___29 ;
  unsigned int tmp___30 ;
  unsigned int tmp___31 ;
  unsigned int tmp___32 ;
  unsigned int tmp___33 ;
  unsigned int tmp___34 ;
  unsigned int tmp___35 ;
  unsigned int tmp___36 ;
  unsigned int tmp___37 ;
  unsigned int tmp___38 ;
  unsigned int tmp___39 ;
  unsigned int tmp___40 ;
  unsigned int tmp___41 ;
  unsigned int tmp___42 ;
  unsigned int tmp___43 ;
  unsigned int tmp___44 ;
  unsigned int tmp___45 ;
  unsigned int tmp___46 ;
  unsigned int tmp___47 ;
  unsigned int tmp___48 ;
  unsigned int tmp___49 ;
  unsigned int tmp___50 ;
  unsigned int tmp___51 ;
  unsigned int tmp___52 ;
  unsigned int tmp___53 ;
  unsigned int tmp___54 ;
  unsigned int tmp___55 ;
  int _p ;
  int _e ;
  int *tmp___56 ;
  char *tmp___57 ;
  int tmp___58 ;

  {
#line 260
  n_bytes = 0;
#line 261
  failure = 0;
#line 268
  tmp = tcgetattr(fd, & tio);
#line 268
  if (tmp < 0) {
#line 269
    failure = -1;
  }
#line 271
  while (1) {
#line 272
    n_bytes ++;
#line 273
    tmp___0 = packet_get_char();
#line 273
    opcode = (int )tmp___0;
#line 274
    switch (opcode) {
    case 0: 
    goto set;
    case 192: 
#line 279
    n_bytes += 4;
#line 280
    tmp___1 = packet_get_int();
#line 280
    baud = (int )tmp___1;
#line 281
    if (failure != -1) {
#line 281
      tmp___2 = baud_to_speed(baud);
#line 281
      tmp___3 = cfsetispeed(& tio, tmp___2);
#line 281
      if (tmp___3 < 0) {
#line 282
        error("cfsetispeed failed for %d", baud);
      }
    }
#line 283
    break;
    case 193: 
#line 286
    n_bytes += 4;
#line 287
    tmp___4 = packet_get_int();
#line 287
    baud = (int )tmp___4;
#line 288
    if (failure != -1) {
#line 288
      tmp___5 = baud_to_speed(baud);
#line 288
      tmp___6 = cfsetospeed(& tio, tmp___5);
#line 288
      if (tmp___6 < 0) {
#line 289
        error("cfsetospeed failed for %d", baud);
      }
    }
#line 290
    break;
    case 1: 
#line 36 "ttymodes.h"
    n_bytes ++;
#line 36
    tmp___7 = packet_get_char();
#line 36
    tio.c_cc[0] = (unsigned char )tmp___7;
#line 36
    break;
    case 2: 
#line 37
    n_bytes ++;
#line 37
    tmp___8 = packet_get_char();
#line 37
    tio.c_cc[1] = (unsigned char )tmp___8;
#line 37
    break;
    case 3: 
#line 38
    n_bytes ++;
#line 38
    tmp___9 = packet_get_char();
#line 38
    tio.c_cc[2] = (unsigned char )tmp___9;
#line 38
    break;
    case 4: 
#line 40
    n_bytes ++;
#line 40
    tmp___10 = packet_get_char();
#line 40
    tio.c_cc[3] = (unsigned char )tmp___10;
#line 40
    break;
    case 5: 
#line 42
    n_bytes ++;
#line 42
    tmp___11 = packet_get_char();
#line 42
    tio.c_cc[4] = (unsigned char )tmp___11;
#line 42
    break;
    case 6: 
#line 44
    n_bytes ++;
#line 44
    tmp___12 = packet_get_char();
#line 44
    tio.c_cc[11] = (unsigned char )tmp___12;
#line 44
    break;
    case 7: 
#line 47
    n_bytes ++;
#line 47
    tmp___13 = packet_get_char();
#line 47
    tio.c_cc[16] = (unsigned char )tmp___13;
#line 47
    break;
    case 8: 
#line 49
    n_bytes ++;
#line 49
    tmp___14 = packet_get_char();
#line 49
    tio.c_cc[8] = (unsigned char )tmp___14;
#line 49
    break;
    case 9: 
#line 50
    n_bytes ++;
#line 50
    tmp___15 = packet_get_char();
#line 50
    tio.c_cc[9] = (unsigned char )tmp___15;
#line 50
    break;
    case 10: 
#line 52
    n_bytes ++;
#line 52
    tmp___16 = packet_get_char();
#line 52
    tio.c_cc[10] = (unsigned char )tmp___16;
#line 52
    break;
    case 12: 
#line 58
    n_bytes ++;
#line 58
    tmp___17 = packet_get_char();
#line 58
    tio.c_cc[12] = (unsigned char )tmp___17;
#line 58
    break;
    case 13: 
#line 61
    n_bytes ++;
#line 61
    tmp___18 = packet_get_char();
#line 61
    tio.c_cc[14] = (unsigned char )tmp___18;
#line 61
    break;
    case 14: 
#line 64
    n_bytes ++;
#line 64
    tmp___19 = packet_get_char();
#line 64
    tio.c_cc[15] = (unsigned char )tmp___19;
#line 64
    break;
    case 18: 
#line 76
    n_bytes ++;
#line 76
    tmp___20 = packet_get_char();
#line 76
    tio.c_cc[13] = (unsigned char )tmp___20;
#line 76
    break;
    case 30: 
#line 80
    n_bytes ++;
#line 80
    tmp___21 = packet_get_char();
#line 80
    if (tmp___21) {
#line 80
      tio.c_iflag |= 4U;
    } else {
#line 80
      tio.c_iflag &= 4294967291U;
    }
#line 80
    break;
    case 31: 
#line 81
    n_bytes ++;
#line 81
    tmp___22 = packet_get_char();
#line 81
    if (tmp___22) {
#line 81
      tio.c_iflag |= 8U;
    } else {
#line 81
      tio.c_iflag &= 4294967287U;
    }
#line 81
    break;
    case 32: 
#line 82
    n_bytes ++;
#line 82
    tmp___23 = packet_get_char();
#line 82
    if (tmp___23) {
#line 82
      tio.c_iflag |= 16U;
    } else {
#line 82
      tio.c_iflag &= 4294967279U;
    }
#line 82
    break;
    case 33: 
#line 83
    n_bytes ++;
#line 83
    tmp___24 = packet_get_char();
#line 83
    if (tmp___24) {
#line 83
      tio.c_iflag |= 32U;
    } else {
#line 83
      tio.c_iflag &= 4294967263U;
    }
#line 83
    break;
    case 34: 
#line 84
    n_bytes ++;
#line 84
    tmp___25 = packet_get_char();
#line 84
    if (tmp___25) {
#line 84
      tio.c_iflag |= 64U;
    } else {
#line 84
      tio.c_iflag &= 4294967231U;
    }
#line 84
    break;
    case 35: 
#line 85
    n_bytes ++;
#line 85
    tmp___26 = packet_get_char();
#line 85
    if (tmp___26) {
#line 85
      tio.c_iflag |= 128U;
    } else {
#line 85
      tio.c_iflag &= 4294967167U;
    }
#line 85
    break;
    case 36: 
#line 86
    n_bytes ++;
#line 86
    tmp___27 = packet_get_char();
#line 86
    if (tmp___27) {
#line 86
      tio.c_iflag |= 256U;
    } else {
#line 86
      tio.c_iflag &= 4294967039U;
    }
#line 86
    break;
    case 37: 
#line 88
    n_bytes ++;
#line 88
    tmp___28 = packet_get_char();
#line 88
    if (tmp___28) {
#line 88
      tio.c_iflag |= 512U;
    } else {
#line 88
      tio.c_iflag &= 4294966783U;
    }
#line 88
    break;
    case 38: 
#line 90
    n_bytes ++;
#line 90
    tmp___29 = packet_get_char();
#line 90
    if (tmp___29) {
#line 90
      tio.c_iflag |= 1024U;
    } else {
#line 90
      tio.c_iflag &= 4294966271U;
    }
#line 90
    break;
    case 39: 
#line 91
    n_bytes ++;
#line 91
    tmp___30 = packet_get_char();
#line 91
    if (tmp___30) {
#line 91
      tio.c_iflag |= 2048U;
    } else {
#line 91
      tio.c_iflag &= 4294965247U;
    }
#line 91
    break;
    case 40: 
#line 92
    n_bytes ++;
#line 92
    tmp___31 = packet_get_char();
#line 92
    if (tmp___31) {
#line 92
      tio.c_iflag |= 4096U;
    } else {
#line 92
      tio.c_iflag &= 4294963199U;
    }
#line 92
    break;
    case 41: 
#line 94
    n_bytes ++;
#line 94
    tmp___32 = packet_get_char();
#line 94
    if (tmp___32) {
#line 94
      tio.c_iflag |= 8192U;
    } else {
#line 94
      tio.c_iflag &= 4294959103U;
    }
#line 94
    break;
    case 50: 
#line 97
    n_bytes ++;
#line 97
    tmp___33 = packet_get_char();
#line 97
    if (tmp___33) {
#line 97
      tio.c_lflag |= 1U;
    } else {
#line 97
      tio.c_lflag &= 4294967294U;
    }
#line 97
    break;
    case 51: 
#line 98
    n_bytes ++;
#line 98
    tmp___34 = packet_get_char();
#line 98
    if (tmp___34) {
#line 98
      tio.c_lflag |= 2U;
    } else {
#line 98
      tio.c_lflag &= 4294967293U;
    }
#line 98
    break;
    case 52: 
#line 100
    n_bytes ++;
#line 100
    tmp___35 = packet_get_char();
#line 100
    if (tmp___35) {
#line 100
      tio.c_lflag |= 4U;
    } else {
#line 100
      tio.c_lflag &= 4294967291U;
    }
#line 100
    break;
    case 53: 
#line 102
    n_bytes ++;
#line 102
    tmp___36 = packet_get_char();
#line 102
    if (tmp___36) {
#line 102
      tio.c_lflag |= 8U;
    } else {
#line 102
      tio.c_lflag &= 4294967287U;
    }
#line 102
    break;
    case 54: 
#line 103
    n_bytes ++;
#line 103
    tmp___37 = packet_get_char();
#line 103
    if (tmp___37) {
#line 103
      tio.c_lflag |= 16U;
    } else {
#line 103
      tio.c_lflag &= 4294967279U;
    }
#line 103
    break;
    case 55: 
#line 104
    n_bytes ++;
#line 104
    tmp___38 = packet_get_char();
#line 104
    if (tmp___38) {
#line 104
      tio.c_lflag |= 32U;
    } else {
#line 104
      tio.c_lflag &= 4294967263U;
    }
#line 104
    break;
    case 56: 
#line 105
    n_bytes ++;
#line 105
    tmp___39 = packet_get_char();
#line 105
    if (tmp___39) {
#line 105
      tio.c_lflag |= 64U;
    } else {
#line 105
      tio.c_lflag &= 4294967231U;
    }
#line 105
    break;
    case 57: 
#line 106
    n_bytes ++;
#line 106
    tmp___40 = packet_get_char();
#line 106
    if (tmp___40) {
#line 106
      tio.c_lflag |= 128U;
    } else {
#line 106
      tio.c_lflag &= 4294967167U;
    }
#line 106
    break;
    case 58: 
#line 107
    n_bytes ++;
#line 107
    tmp___41 = packet_get_char();
#line 107
    if (tmp___41) {
#line 107
      tio.c_lflag |= 256U;
    } else {
#line 107
      tio.c_lflag &= 4294967039U;
    }
#line 107
    break;
    case 59: 
#line 109
    n_bytes ++;
#line 109
    tmp___42 = packet_get_char();
#line 109
    if (tmp___42) {
#line 109
      tio.c_lflag |= 32768U;
    } else {
#line 109
      tio.c_lflag &= 4294934527U;
    }
#line 109
    break;
    case 60: 
#line 112
    n_bytes ++;
#line 112
    tmp___43 = packet_get_char();
#line 112
    if (tmp___43) {
#line 112
      tio.c_lflag |= 512U;
    } else {
#line 112
      tio.c_lflag &= 4294966783U;
    }
#line 112
    break;
    case 61: 
#line 115
    n_bytes ++;
#line 115
    tmp___44 = packet_get_char();
#line 115
    if (tmp___44) {
#line 115
      tio.c_lflag |= 2048U;
    } else {
#line 115
      tio.c_lflag &= 4294965247U;
    }
#line 115
    break;
    case 62: 
#line 118
    n_bytes ++;
#line 118
    tmp___45 = packet_get_char();
#line 118
    if (tmp___45) {
#line 118
      tio.c_lflag |= 16384U;
    } else {
#line 118
      tio.c_lflag &= 4294950911U;
    }
#line 118
    break;
    case 70: 
#line 121
    n_bytes ++;
#line 121
    tmp___46 = packet_get_char();
#line 121
    if (tmp___46) {
#line 121
      tio.c_oflag |= 1U;
    } else {
#line 121
      tio.c_oflag &= 4294967294U;
    }
#line 121
    break;
    case 71: 
#line 123
    n_bytes ++;
#line 123
    tmp___47 = packet_get_char();
#line 123
    if (tmp___47) {
#line 123
      tio.c_oflag |= 2U;
    } else {
#line 123
      tio.c_oflag &= 4294967293U;
    }
#line 123
    break;
    case 72: 
#line 125
    n_bytes ++;
#line 125
    tmp___48 = packet_get_char();
#line 125
    if (tmp___48) {
#line 125
      tio.c_oflag |= 4U;
    } else {
#line 125
      tio.c_oflag &= 4294967291U;
    }
#line 125
    break;
    case 73: 
#line 127
    n_bytes ++;
#line 127
    tmp___49 = packet_get_char();
#line 127
    if (tmp___49) {
#line 127
      tio.c_oflag |= 8U;
    } else {
#line 127
      tio.c_oflag &= 4294967287U;
    }
#line 127
    break;
    case 74: 
#line 130
    n_bytes ++;
#line 130
    tmp___50 = packet_get_char();
#line 130
    if (tmp___50) {
#line 130
      tio.c_oflag |= 16U;
    } else {
#line 130
      tio.c_oflag &= 4294967279U;
    }
#line 130
    break;
    case 75: 
#line 133
    n_bytes ++;
#line 133
    tmp___51 = packet_get_char();
#line 133
    if (tmp___51) {
#line 133
      tio.c_oflag |= 32U;
    } else {
#line 133
      tio.c_oflag &= 4294967263U;
    }
#line 133
    break;
    case 90: 
#line 136
    n_bytes ++;
#line 136
    tmp___52 = packet_get_char();
#line 136
    if (tmp___52) {
#line 136
      tio.c_cflag |= 32U;
    } else {
#line 136
      tio.c_cflag &= 4294967263U;
    }
#line 136
    break;
    case 91: 
#line 137
    n_bytes ++;
#line 137
    tmp___53 = packet_get_char();
#line 137
    if (tmp___53) {
#line 137
      tio.c_cflag |= 48U;
    } else {
#line 137
      tio.c_cflag &= 4294967247U;
    }
#line 137
    break;
    case 92: 
#line 138
    n_bytes ++;
#line 138
    tmp___54 = packet_get_char();
#line 138
    if (tmp___54) {
#line 138
      tio.c_cflag |= 256U;
    } else {
#line 138
      tio.c_cflag &= 4294967039U;
    }
#line 138
    break;
    case 93: 
#line 139
    n_bytes ++;
#line 139
    tmp___55 = packet_get_char();
#line 139
    if (tmp___55) {
#line 139
      tio.c_cflag |= 512U;
    } else {
#line 139
      tio.c_cflag &= 4294966783U;
    }
#line 139
    break;
    default: 
#line 318 "ttymodes.c"
    debug("Ignoring unsupported tty mode opcode %d (0x%x)", opcode, opcode);
#line 324
    if (opcode >= 0) {
#line 324
      if (opcode < 128) {
#line 325
        n_bytes ++;
#line 326
        packet_get_char();
#line 327
        break;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 333
      if (opcode >= 128) {
#line 333
        if (opcode < 160) {
#line 334
          n_bytes += 4;
#line 335
          packet_get_int();
#line 336
          break;
        }
      }
    }
#line 346
    log("parse_tty_modes: unknown opcode %d", opcode);
#line 347
    while (1) {
#line 347
      _p = 0;
#line 347
      _e = 1;
#line 347
      if (_p != _e) {
#line 347
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "ttymodes.c", 347);
#line 347
        packet_disconnect("Packet integrity error. (%d)", 10);
      }
#line 347
      break;
    }
    goto set;
    }
  }
  set: 
#line 353
  if (*n_bytes_ptr != n_bytes) {
#line 354
    *n_bytes_ptr = n_bytes;
#line 355
    return;
  }
#line 357
  if (failure == -1) {
#line 358
    return;
  }
#line 361
  tmp___58 = tcsetattr(fd, 0, (struct termios  const  *)(& tio));
#line 361
  if (tmp___58 < 0) {
#line 362
    tmp___56 = __errno_location();
#line 362
    tmp___57 = strerror(*tmp___56);
#line 362
    log("Setting tty modes failed: %.100s", tmp___57);
  }
#line 363
  return;
}
}
#line 1 "uidswap.o"
#line 645 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 667
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 677
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 32 "uidswap.h"
void permanently_set_uid(uid_t uid ) ;
#line 38 "uidswap.c"
static uid_t saved_euid  =    (uid_t )0;
#line 46 "uidswap.c"
void temporarily_use_uid(uid_t uid ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 51
  saved_euid = geteuid();
#line 54
  tmp___1 = seteuid(uid);
#line 54
  if (tmp___1 == -1) {
#line 55
    tmp = __errno_location();
#line 55
    tmp___0 = strerror(*tmp);
#line 55
    debug("seteuid %u: %.100s", uid, tmp___0);
  }
#line 65
  return;
}
}
#line 70 "uidswap.c"
void restore_uid(void) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 75
  tmp___1 = seteuid(saved_euid);
#line 75
  if (tmp___1 < 0) {
#line 76
    tmp = __errno_location();
#line 76
    tmp___0 = strerror(*tmp);
#line 76
    debug("seteuid %u: %.100s", saved_euid, tmp___0);
  }
#line 85
  return;
}
}
#line 91 "uidswap.c"
void permanently_set_uid(uid_t uid ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 102
  tmp___1 = setuid(uid);
#line 102
  if (tmp___1 < 0) {
#line 103
    tmp = __errno_location();
#line 103
    tmp___0 = strerror(*tmp);
#line 103
    debug("setuid %u: %.100s", uid, tmp___0);
  }
#line 104
  return;
}
}
/* compiler builtin: 
   char *__builtin_strpbrk(char const   * , char const   * ) ;  */
/* compiler builtin: 
   unsigned int __builtin_strspn(char const   * , char const   * ) ;  */
#line 1 "util.o"
#line 490 "ssh.h"
char *chop(char *s ) ;
#line 493
char *strdelim(char **s ) ;
#line 32 "util.c"
char *chop(char *s ) 
{ char *t ;

  {
#line 35
  t = s;
#line 36
  while (*t) {
#line 37
    if ((int )*t == 10) {
#line 38
      *t = (char )'\000';
#line 39
      return (s);
    } else {
#line 37
      if ((int )*t == 13) {
#line 38
        *t = (char )'\000';
#line 39
        return (s);
      }
    }
#line 41
    t ++;
  }
#line 43
  return (s);
}
}
#line 47 "util.c"
void set_nonblock(int fd ) 
{ int val ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
#line 51
  val = fcntl(fd, 3, 0);
#line 52
  if (val < 0) {
#line 53
    tmp = __errno_location();
#line 53
    tmp___0 = strerror(*tmp);
#line 53
    error("fcntl(%d, F_GETFL, 0): %s", fd, tmp___0);
#line 54
    return;
  }
#line 56
  if (val & 2048) {
#line 57
    debug("fd %d IS O_NONBLOCK", fd);
#line 58
    return;
  }
#line 60
  debug("fd %d setting O_NONBLOCK", fd);
#line 61
  val |= 2048;
#line 62
  tmp___4 = fcntl(fd, 4, val);
#line 62
  if (tmp___4 == -1) {
#line 63
    tmp___3 = __errno_location();
#line 63
    if (*tmp___3 != 19) {
#line 64
      tmp___1 = __errno_location();
#line 64
      tmp___2 = strerror(*tmp___1);
#line 64
      error("fcntl(%d, F_SETFL, O_NONBLOCK): %s", fd, tmp___2);
    }
  }
#line 66
  return;
}
}
#line 71 "util.c"
char *strdelim(char **s ) 
{ char *old ;
  int wspace ;
  char *tmp___30 ;
  unsigned int tmp___62 ;
  unsigned int tmp___94 ;

  {
#line 75
  wspace = 0;
#line 77
  if ((unsigned int )*s == (unsigned int )((void *)0)) {
#line 78
    return ((char *)((void *)0));
  }
#line 80
  old = *s;
#line 82
  tmp___30 = __builtin_strpbrk((char const   *)*s, " \t\r\n=");
#line 82
  *s = tmp___30;
#line 83
  if ((unsigned int )*s == (unsigned int )((void *)0)) {
#line 84
    return (old);
  }
#line 87
  if ((int )*(*(s + 0)) == 61) {
#line 88
    wspace = 1;
  }
#line 89
  *(*(s + 0)) = (char )'\000';
#line 91
  tmp___62 = __builtin_strspn((char const   *)(*s + 1), " \t\r\n");
#line 91
  *s += tmp___62 + 1U;
#line 92
  if ((int )*(*(s + 0)) == 61) {
#line 92
    if (! wspace) {
#line 93
      tmp___94 = __builtin_strspn((char const   *)(*s + 1), " \t\r\n");
#line 93
      *s += tmp___94 + 1U;
    }
  }
#line 95
  return (old);
}
}
#line 1 "uuencode.o"
#line 8 "bsd-base64.h"
int b64_ntop(u_char const   *src , size_t srclength , char *target , size_t targsize ) ;
#line 10
int b64_pton(char const   *src , u_char *target , size_t targsize ) ;
#line 32 "uuencode.c"
int uuencode(unsigned char *src , unsigned int srclength , char *target , size_t targsize ) 
{ int tmp ;

  {
#line 36
  tmp = b64_ntop((u_char const   *)src, srclength, target, targsize);
#line 36
  return (tmp);
}
}
#line 39 "uuencode.c"
int uudecode(char const   *src , unsigned char *target , size_t targsize ) 
{ int len ;
  char *encoded ;
  char *p ;

  {
#line 46
  encoded = xstrdup(src);
#line 48
  p = encoded;
#line 48
  while (1) {
#line 48
    if (! ((int )*p == 32)) {
#line 48
      if (! ((int )*p == 9)) {
#line 48
        break;
      }
    }
#line 48
    p ++;
  }
#line 50
  while (1) {
#line 50
    if ((int )*p != 0) {
#line 50
      if ((int )*p != 32) {
#line 50
        if (! ((int )*p != 9)) {
#line 50
          break;
        }
      } else {
#line 50
        break;
      }
    } else {
#line 50
      break;
    }
#line 50
    p ++;
  }
#line 53
  *p = (char )'\000';
#line 54
  len = b64_pton((char const   *)encoded, target, targsize);
#line 55
  xfree((void *)encoded);
#line 56
  return (len);
}
}
#line 59 "uuencode.c"
void dump_base64(FILE *fp , unsigned char *data , int len ) 
{ unsigned char *buf___1 ;
  void *tmp ;
  int i ;
  int n___0 ;

  {
#line 62
  tmp = xmalloc((unsigned int )(2 * len));
#line 62
  buf___1 = (unsigned char *)tmp;
#line 64
  n___0 = uuencode(data, (unsigned int )len, (char *)buf___1, (unsigned int )(2 * len));
#line 65
  i = 0;
#line 65
  while (i < n___0) {
#line 66
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%c", *(buf___1 + i));
#line 67
    if (i % 70 == 69) {
#line 68
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
    }
#line 65
    i ++;
  }
#line 70
  if (i % 70 != 69) {
#line 71
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  }
#line 72
  xfree((void *)buf___1);
#line 73
  return;
}
}
#line 1 "xmalloc.o"
#line 589 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 600
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__warn_unused_result__,
__malloc__)) ;
#line 20 "xmalloc.c"
void *xmalloc(size_t size ) 
{ void *ptr ;
  void *tmp ;

  {
#line 23
  tmp = malloc(size);
#line 23
  ptr = tmp;
#line 24
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 25
    fatal("xmalloc: out of memory (allocating %d bytes)", (int )size);
  }
#line 26
  return (ptr);
}
}
#line 29 "xmalloc.c"
void *xrealloc(void *ptr , size_t new_size ) 
{ void *new_ptr ;

  {
#line 34
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 35
    fatal("xrealloc: NULL pointer given as argument");
  }
#line 36
  new_ptr = realloc(ptr, new_size);
#line 37
  if ((unsigned int )new_ptr == (unsigned int )((void *)0)) {
#line 38
    fatal("xrealloc: out of memory (new_size %d bytes)", (int )new_size);
  }
#line 39
  return (new_ptr);
}
}
#line 42 "xmalloc.c"
void xfree(void *ptr ) 
{ 

  {
#line 45
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 46
    fatal("xfree: NULL pointer given as argument");
  }
#line 47
  free(ptr);
#line 48
  return;
}
}
#line 50 "xmalloc.c"
char *xstrdup(char const   *str ) 
{ int len ;
  size_t tmp ;
  char *cp ;
  void *tmp___0 ;

  {
#line 53
  tmp = strlen(str);
#line 53
  len = (int )(tmp + 1U);
#line 55
  tmp___0 = xmalloc((unsigned int )len);
#line 55
  cp = (char *)tmp___0;
#line 56
  strlcpy(cp, str, (unsigned int )len);
#line 57
  return (cp);
}
}
#line 1 "bsd-arc4random.o"
#line 32 "bsd-arc4random.h"
void arc4random_stir(void) ;
#line 102 "/usr/include/openssl/rand.h"
extern int RAND_bytes(unsigned char *buf , int num ) ;
#line 38 "bsd-arc4random.c"
static int rc4_ready  =    0;
#line 39 "bsd-arc4random.c"
static RC4_KEY rc4  ;
#line 41 "bsd-arc4random.c"
unsigned int arc4random(void) 
{ unsigned int r ;

  {
#line 43
  r = 0U;
#line 45
  if (rc4_ready <= 0) {
#line 46
    arc4random_stir();
  }
#line 48
  RC4(& rc4, (unsigned long )sizeof(r), (unsigned char const   *)((unsigned char *)(& r)),
      (unsigned char *)(& r));
#line 50
  rc4_ready = (int )((unsigned int )rc4_ready - sizeof(r));
#line 52
  return (r);
}
}
#line 55 "bsd-arc4random.c"
void arc4random_stir(void) 
{ unsigned char rand_buf[20] ;

  {
#line 59
  memset((void *)(& rc4), 0, sizeof(rc4));
#line 61
  seed_rng();
#line 63
  RAND_bytes(rand_buf, (int )sizeof(rand_buf));
#line 65
  RC4_set_key(& rc4, (int )sizeof(rand_buf), (unsigned char const   *)(rand_buf));
#line 67
  memset((void *)(rand_buf), 0, sizeof(rand_buf));
#line 69
  rc4_ready = 1 << 24;
#line 70
  return;
}
}
#line 1 "bsd-base64.o"
#line 628 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 65 "bsd-base64.c"
static char const   Base64[65]  = 
#line 65 "bsd-base64.c"
  {      (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'g',      (char const   )'h',      (char const   )'i',      (char const   )'j', 
        (char const   )'k',      (char const   )'l',      (char const   )'m',      (char const   )'n', 
        (char const   )'o',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'+',      (char const   )'/', 
        (char const   )'\000'};
#line 67 "bsd-base64.c"
static char const   Pad64  =    (char const   )'=';
#line 132 "bsd-base64.c"
int b64_ntop(u_char const   *src , size_t srclength , char *target , size_t targsize ) 
{ size_t datalength ;
  u_char input___0[3] ;
  u_char output___0[4] ;
  int i ;
  u_char const   *tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  u_char const   *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;

  {
#line 135
  datalength = (size_t )0;
#line 140
  while (2U < srclength) {
#line 141
    tmp = src;
#line 141
    src ++;
#line 141
    input___0[0] = (unsigned char )*tmp;
#line 142
    tmp___0 = src;
#line 142
    src ++;
#line 142
    input___0[1] = (unsigned char )*tmp___0;
#line 143
    tmp___1 = src;
#line 143
    src ++;
#line 143
    input___0[2] = (unsigned char )*tmp___1;
#line 144
    srclength -= 3U;
#line 146
    output___0[0] = (unsigned char )((int )input___0[0] >> 2);
#line 147
    output___0[1] = (unsigned char )((((int )input___0[0] & 3) << 4) + ((int )input___0[1] >> 4));
#line 148
    output___0[2] = (unsigned char )((((int )input___0[1] & 15) << 2) + ((int )input___0[2] >> 6));
#line 149
    output___0[3] = (unsigned char )((int )input___0[2] & 63);
#line 150
    if (! ((int )output___0[0] < 64)) {
#line 150
      abort();
    }
#line 151
    if (! ((int )output___0[1] < 64)) {
#line 151
      abort();
    }
#line 152
    if (! ((int )output___0[2] < 64)) {
#line 152
      abort();
    }
#line 153
    if (! ((int )output___0[3] < 64)) {
#line 153
      abort();
    }
#line 155
    if (datalength + 4U > targsize) {
#line 156
      return (-1);
    }
#line 157
    tmp___2 = datalength;
#line 157
    datalength ++;
#line 157
    *(target + tmp___2) = (char )Base64[output___0[0]];
#line 158
    tmp___3 = datalength;
#line 158
    datalength ++;
#line 158
    *(target + tmp___3) = (char )Base64[output___0[1]];
#line 159
    tmp___4 = datalength;
#line 159
    datalength ++;
#line 159
    *(target + tmp___4) = (char )Base64[output___0[2]];
#line 160
    tmp___5 = datalength;
#line 160
    datalength ++;
#line 160
    *(target + tmp___5) = (char )Base64[output___0[3]];
  }
#line 164
  if (0U != srclength) {
#line 166
    input___0[2] = (unsigned char )'\000';
#line 166
    input___0[1] = input___0[2];
#line 166
    input___0[0] = input___0[1];
#line 167
    i = 0;
#line 167
    while ((size_t )i < srclength) {
#line 168
      tmp___6 = src;
#line 168
      src ++;
#line 168
      input___0[i] = (unsigned char )*tmp___6;
#line 167
      i ++;
    }
#line 170
    output___0[0] = (unsigned char )((int )input___0[0] >> 2);
#line 171
    output___0[1] = (unsigned char )((((int )input___0[0] & 3) << 4) + ((int )input___0[1] >> 4));
#line 172
    output___0[2] = (unsigned char )((((int )input___0[1] & 15) << 2) + ((int )input___0[2] >> 6));
#line 173
    if (! ((int )output___0[0] < 64)) {
#line 173
      abort();
    }
#line 174
    if (! ((int )output___0[1] < 64)) {
#line 174
      abort();
    }
#line 175
    if (! ((int )output___0[2] < 64)) {
#line 175
      abort();
    }
#line 177
    if (datalength + 4U > targsize) {
#line 178
      return (-1);
    }
#line 179
    tmp___7 = datalength;
#line 179
    datalength ++;
#line 179
    *(target + tmp___7) = (char )Base64[output___0[0]];
#line 180
    tmp___8 = datalength;
#line 180
    datalength ++;
#line 180
    *(target + tmp___8) = (char )Base64[output___0[1]];
#line 181
    if (srclength == 1U) {
#line 182
      tmp___9 = datalength;
#line 182
      datalength ++;
#line 182
      *(target + tmp___9) = (char )Pad64;
    } else {
#line 184
      tmp___10 = datalength;
#line 184
      datalength ++;
#line 184
      *(target + tmp___10) = (char )Base64[output___0[2]];
    }
#line 185
    tmp___11 = datalength;
#line 185
    datalength ++;
#line 185
    *(target + tmp___11) = (char )Pad64;
  }
#line 187
  if (datalength >= targsize) {
#line 188
    return (-1);
  }
#line 189
  *(target + datalength) = (char )'\000';
#line 190
  return ((int )datalength);
}
}
#line 199 "bsd-base64.c"
int b64_pton(char const   *src , u_char *target , size_t targsize ) 
{ int tarindex ;
  int state ;
  int ch ;
  char *pos ;
  unsigned short const   **tmp ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  unsigned short const   **tmp___8 ;

  {
#line 205
  state = 0;
#line 206
  tarindex = 0;
#line 208
  while (1) {
#line 208
    tmp___2 = src;
#line 208
    src ++;
#line 208
    ch = (int )*tmp___2;
#line 208
    if (! (ch != 0)) {
#line 208
      break;
    }
#line 209
    tmp = __ctype_b_loc();
#line 209
    if ((int const   )*(*tmp + ch) & 8192) {
#line 210
      continue;
    }
#line 212
    if (ch == (int )Pad64) {
#line 213
      break;
    }
#line 215
    tmp___1 = __builtin_strchr((char *)(Base64), ch);
#line 215
    pos = tmp___1;
#line 216
    if ((unsigned int )pos == (unsigned int )((char *)0)) {
#line 217
      return (-1);
    }
#line 219
    switch (state) {
    case 0: 
#line 221
    if (target) {
#line 222
      if ((size_t )tarindex >= targsize) {
#line 223
        return (-1);
      }
#line 224
      *(target + tarindex) = (unsigned char )((pos - (char *)(Base64)) << 2);
    }
#line 226
    state = 1;
#line 227
    break;
    case 1: 
#line 229
    if (target) {
#line 230
      if ((size_t )(tarindex + 1) >= targsize) {
#line 231
        return (-1);
      }
#line 232
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | ((pos - (char *)(Base64)) >> 4));
#line 233
      *(target + (tarindex + 1)) = (unsigned char )(((pos - (char *)(Base64)) & 15) << 4);
    }
#line 236
    tarindex ++;
#line 237
    state = 2;
#line 238
    break;
    case 2: 
#line 240
    if (target) {
#line 241
      if ((size_t )(tarindex + 1) >= targsize) {
#line 242
        return (-1);
      }
#line 243
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | ((pos - (char *)(Base64)) >> 2));
#line 244
      *(target + (tarindex + 1)) = (unsigned char )(((pos - (char *)(Base64)) & 3) << 6);
    }
#line 247
    tarindex ++;
#line 248
    state = 3;
#line 249
    break;
    case 3: 
#line 251
    if (target) {
#line 252
      if ((size_t )tarindex >= targsize) {
#line 253
        return (-1);
      }
#line 254
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | (pos - (char *)(Base64)));
    }
#line 256
    tarindex ++;
#line 257
    state = 0;
#line 258
    break;
    }
  }
#line 267
  if (ch == (int )Pad64) {
#line 268
    tmp___3 = src;
#line 268
    src ++;
#line 268
    ch = (int )*tmp___3;
#line 269
    switch (state) {
    case 0: 
    case 1: 
#line 272
    return (-1);
    case 2: 
#line 276
    while (ch != 0) {
#line 277
      tmp___5 = __ctype_b_loc();
#line 277
      if (! ((int const   )*(*tmp___5 + ch) & 8192)) {
#line 278
        break;
      }
#line 276
      tmp___4 = src;
#line 276
      src ++;
#line 276
      ch = (int )*tmp___4;
    }
#line 280
    if (ch != (int )Pad64) {
#line 281
      return (-1);
    }
#line 282
    tmp___6 = src;
#line 282
    src ++;
#line 282
    ch = (int )*tmp___6;
    case 3: 
#line 291
    while (ch != 0) {
#line 292
      tmp___8 = __ctype_b_loc();
#line 292
      if (! ((int const   )*(*tmp___8 + ch) & 8192)) {
#line 293
        return (-1);
      }
#line 291
      tmp___7 = src;
#line 291
      src ++;
#line 291
      ch = (int )*tmp___7;
    }
#line 301
    if (target) {
#line 301
      if ((int )*(target + tarindex) != 0) {
#line 302
        return (-1);
      }
    }
    }
  } else {
#line 309
    if (state != 0) {
#line 310
      return (-1);
    }
  }
#line 313
  return (tarindex);
}
}
#line 1 "bsd-bindresvport.o"
#line 7 "bsd-bindresvport.h"
int bindresvport_af(int sd , struct sockaddr *sa , int af ) ;
#line 53 "bsd-bindresvport.c"
int bindresvport_af(int sd , struct sockaddr *sa , int af ) 
{ int error___0 ;
  struct sockaddr_storage myaddr ;
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;
  u_int16_t *portp ;
  u_int16_t port ;
  int salen ;
  int i ;
  int *tmp ;
  register unsigned short __v ;
  register unsigned short __x ;
  unsigned int tmp___0 ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 68
  if ((unsigned int )sa == (unsigned int )((void *)0)) {
#line 69
    memset((void *)(& myaddr), 0, sizeof(myaddr));
#line 70
    sa = (struct sockaddr *)(& myaddr);
  }
#line 73
  if (af == 2) {
#line 74
    sin = (struct sockaddr_in *)sa;
#line 75
    salen = (int )sizeof(struct sockaddr_in );
#line 76
    portp = & sin->sin_port;
  } else {
#line 77
    if (af == 10) {
#line 78
      sin6 = (struct sockaddr_in6 *)sa;
#line 79
      salen = (int )sizeof(struct sockaddr_in6 );
#line 80
      portp = & sin6->sin6_port;
    } else {
#line 82
      tmp = __errno_location();
#line 82
      *tmp = 96;
#line 83
      return (-1);
    }
  }
#line 85
  sa->sa_family = (unsigned short )af;
#line 87
  __x = *portp;
#line 87
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 87
  port = __v;
#line 88
  if ((int )port == 0) {
#line 89
    tmp___0 = arc4random();
#line 89
    port = (unsigned short )(tmp___0 % 424U + 600U);
  }
#line 91
  i = 0;
#line 91
  while (i < 424) {
#line 92
    __x___0 = port;
#line 92
    __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 92
    *portp = __v___0;
#line 94
    error___0 = bind(sd, (struct sockaddr  const  *)sa, (unsigned int )salen);
#line 97
    if (error___0 == 0) {
#line 98
      break;
    }
#line 101
    if (error___0 < 0) {
#line 101
      tmp___1 = __errno_location();
#line 101
      if (! (*tmp___1 == 98)) {
#line 101
        tmp___2 = __errno_location();
#line 101
        if (! (*tmp___2 == 22)) {
#line 102
          break;
        }
      }
    }
#line 104
    port = (u_int16_t )((int )port + 1);
#line 105
    if ((int )port > 1023) {
#line 106
      port = (unsigned short)600;
    }
#line 91
    i ++;
  }
#line 109
  return (error___0);
}
}
#line 1 "bsd-daemon.o"
#line 1 "bsd-getcwd.o"
#line 1 "bsd-inet_aton.o"
#line 1 "bsd-inet_ntoa.o"
#line 1 "bsd-misc.o"
#line 828 "/usr/include/unistd.h"
 __attribute__((__nothrow__)) int setlogin(char const   *name )  __attribute__((__nonnull__(1))) ;
#line 30 "bsd-misc.c"
 __attribute__((__nothrow__)) int setlogin(char const   *name )  __attribute__((__nonnull__(1))) ;
#line 30 "bsd-misc.c"
int setlogin(char const   *name ) 
{ 

  {
#line 32
  return (0);
}
}
#line 1 "bsd-mktemp.o"
#line 1 "bsd-realpath.o"
#line 1 "bsd-rresvport.o"
#line 1 "bsd-setenv.o"
#line 1 "bsd-sigaction.o"
#line 1 "bsd-snprintf.o"
#line 1 "bsd-strlcat.o"
#line 46 "bsd-strlcat.c"
size_t strlcat(char *dst , char const   *src , size_t siz ) 
{ register char *d ;
  register char const   *s ;
  register size_t n___0 ;
  size_t dlen ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 51
  d = dst;
#line 52
  s = src;
#line 53
  n___0 = siz;
#line 57
  while (1) {
#line 57
    if ((int )*d != 0) {
#line 57
      tmp = n___0;
#line 57
      n___0 --;
#line 57
      if (! (tmp != 0U)) {
#line 57
        break;
      }
    } else {
#line 57
      break;
    }
#line 58
    d ++;
  }
#line 59
  dlen = (unsigned int )(d - dst);
#line 60
  n___0 = siz - dlen;
#line 62
  if (n___0 == 0U) {
#line 63
    tmp___0 = strlen(s);
#line 63
    return (dlen + tmp___0);
  }
#line 64
  while ((int const   )*s != 0) {
#line 65
    if (n___0 != 1U) {
#line 66
      tmp___1 = d;
#line 66
      d ++;
#line 66
      *tmp___1 = (char )*s;
#line 67
      n___0 --;
    }
#line 69
    s ++;
  }
#line 71
  *d = (char )'\000';
#line 73
  return (dlen + (size_t )(s - src));
}
}
#line 1 "bsd-strlcpy.o"
#line 45 "bsd-strlcpy.c"
size_t strlcpy(char *dst , char const   *src , size_t siz ) 
{ register char *d ;
  register char const   *s ;
  register size_t n___0 ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 50
  d = dst;
#line 51
  s = src;
#line 52
  n___0 = siz;
#line 55
  if (n___0 != 0U) {
#line 55
    n___0 --;
#line 55
    if (n___0 != 0U) {
#line 56
      while (1) {
#line 57
        tmp = d;
#line 57
        d ++;
#line 57
        tmp___0 = s;
#line 57
        s ++;
#line 57
        *tmp = (char )*tmp___0;
#line 57
        if ((int )*tmp == 0) {
#line 58
          break;
        }
#line 56
        n___0 --;
#line 56
        if (! (n___0 != 0U)) {
#line 56
          break;
        }
      }
    }
  }
#line 63
  if (n___0 == 0U) {
#line 64
    if (siz != 0U) {
#line 65
      *d = (char )'\000';
    }
#line 66
    while (1) {
#line 66
      tmp___1 = s;
#line 66
      s ++;
#line 66
      if (! *tmp___1) {
#line 66
        break;
      }
    }
  }
#line 70
  return ((unsigned int )((s - src) - 1));
}
}
#line 1 "bsd-strsep.o"
#line 1 "bsd-strtok.o"
#line 1 "bsd-vis.o"
#line 47 "bsd-vis.c"
char *vis(char *dst , int c , int flag , int nextc ) 
{ char *tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  unsigned short const   **tmp___33 ;

  {
#line 49
  if ((unsigned int )c <= 255U) {
#line 49
    if (((int )((unsigned char )c) & -128) == 0) {
#line 49
      tmp___1 = __ctype_b_loc();
#line 49
      if ((int const   )*(*tmp___1 + (int )((unsigned char )c)) & 32768) {
        goto _L___0;
      } else {
        goto _L___5;
      }
    } else {
      goto _L___5;
    }
  } else {
    _L___5: /* CIL Label */ 
#line 49
    if ((flag & 4) == 0) {
#line 49
      if (c == 32) {
        goto _L___0;
      } else {
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
#line 49
      if ((flag & 8) == 0) {
#line 49
        if (c == 9) {
          goto _L___0;
        } else {
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
#line 49
        if ((flag & 16) == 0) {
#line 49
          if (c == 10) {
            goto _L___0;
          } else {
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
#line 49
          if (flag & 32) {
#line 49
            if (c == 8) {
              goto _L___0;
            } else {
#line 49
              if (c == 7) {
                goto _L___0;
              } else {
#line 49
                if (c == 13) {
                  _L___0: /* CIL Label */ 
#line 55
                  tmp = dst;
#line 55
                  dst ++;
#line 55
                  *tmp = (char )c;
#line 56
                  if (c == 92) {
#line 56
                    if ((flag & 64) == 0) {
#line 57
                      tmp___0 = dst;
#line 57
                      dst ++;
#line 57
                      *tmp___0 = (char )'\\';
                    }
                  }
#line 58
                  *dst = (char )'\000';
#line 59
                  return (dst);
                }
              }
            }
          }
        }
      }
    }
  }
#line 62
  if (flag & 2) {
#line 63
    switch (c) {
    case 10: 
#line 65
    tmp___2 = dst;
#line 65
    dst ++;
#line 65
    *tmp___2 = (char )'\\';
#line 66
    tmp___3 = dst;
#line 66
    dst ++;
#line 66
    *tmp___3 = (char )'n';
    goto done;
    case 13: 
#line 69
    tmp___4 = dst;
#line 69
    dst ++;
#line 69
    *tmp___4 = (char )'\\';
#line 70
    tmp___5 = dst;
#line 70
    dst ++;
#line 70
    *tmp___5 = (char )'r';
    goto done;
    case 8: 
#line 73
    tmp___6 = dst;
#line 73
    dst ++;
#line 73
    *tmp___6 = (char )'\\';
#line 74
    tmp___7 = dst;
#line 74
    dst ++;
#line 74
    *tmp___7 = (char )'b';
    goto done;
    case 7: 
#line 81
    tmp___8 = dst;
#line 81
    dst ++;
#line 81
    *tmp___8 = (char )'\\';
#line 82
    tmp___9 = dst;
#line 82
    dst ++;
#line 82
    *tmp___9 = (char )'a';
    goto done;
    case 11: 
#line 85
    tmp___10 = dst;
#line 85
    dst ++;
#line 85
    *tmp___10 = (char )'\\';
#line 86
    tmp___11 = dst;
#line 86
    dst ++;
#line 86
    *tmp___11 = (char )'v';
    goto done;
    case 9: 
#line 89
    tmp___12 = dst;
#line 89
    dst ++;
#line 89
    *tmp___12 = (char )'\\';
#line 90
    tmp___13 = dst;
#line 90
    dst ++;
#line 90
    *tmp___13 = (char )'t';
    goto done;
    case 12: 
#line 93
    tmp___14 = dst;
#line 93
    dst ++;
#line 93
    *tmp___14 = (char )'\\';
#line 94
    tmp___15 = dst;
#line 94
    dst ++;
#line 94
    *tmp___15 = (char )'f';
    goto done;
    case 32: 
#line 97
    tmp___16 = dst;
#line 97
    dst ++;
#line 97
    *tmp___16 = (char )'\\';
#line 98
    tmp___17 = dst;
#line 98
    dst ++;
#line 98
    *tmp___17 = (char )'s';
    goto done;
    case 0: 
#line 101
    tmp___18 = dst;
#line 101
    dst ++;
#line 101
    *tmp___18 = (char )'\\';
#line 102
    tmp___19 = dst;
#line 102
    dst ++;
#line 102
    *tmp___19 = (char )'0';
#line 103
    if ((int )((unsigned char )nextc) >= 48) {
#line 103
      if ((int )((unsigned char )nextc) <= 55) {
#line 104
        tmp___20 = dst;
#line 104
        dst ++;
#line 104
        *tmp___20 = (char )'0';
#line 105
        tmp___21 = dst;
#line 105
        dst ++;
#line 105
        *tmp___21 = (char )'0';
      }
    }
    goto done;
    }
  }
#line 110
  if ((c & 127) == 32) {
    goto _L___6;
  } else {
#line 110
    if (flag & 1) {
      _L___6: /* CIL Label */ 
#line 111
      tmp___22 = dst;
#line 111
      dst ++;
#line 111
      *tmp___22 = (char )'\\';
#line 112
      tmp___23 = dst;
#line 112
      dst ++;
#line 112
      *tmp___23 = (char )((((int )((unsigned char )c) >> 6) & 7) + 48);
#line 113
      tmp___24 = dst;
#line 113
      dst ++;
#line 113
      *tmp___24 = (char )((((int )((unsigned char )c) >> 3) & 7) + 48);
#line 114
      tmp___25 = dst;
#line 114
      dst ++;
#line 114
      *tmp___25 = (char )(((int )((unsigned char )c) & 7) + 48);
      goto done;
    }
  }
#line 117
  if ((flag & 64) == 0) {
#line 118
    tmp___26 = dst;
#line 118
    dst ++;
#line 118
    *tmp___26 = (char )'\\';
  }
#line 119
  if (c & 128) {
#line 120
    c &= 127;
#line 121
    tmp___27 = dst;
#line 121
    dst ++;
#line 121
    *tmp___27 = (char )'M';
  }
#line 123
  tmp___33 = __ctype_b_loc();
#line 123
  if ((int const   )*(*tmp___33 + c) & 2) {
#line 124
    tmp___28 = dst;
#line 124
    dst ++;
#line 124
    *tmp___28 = (char )'^';
#line 125
    if (c == 127) {
#line 126
      tmp___29 = dst;
#line 126
      dst ++;
#line 126
      *tmp___29 = (char )'?';
    } else {
#line 128
      tmp___30 = dst;
#line 128
      dst ++;
#line 128
      *tmp___30 = (char )(c + 64);
    }
  } else {
#line 130
    tmp___31 = dst;
#line 130
    dst ++;
#line 130
    *tmp___31 = (char )'-';
#line 131
    tmp___32 = dst;
#line 131
    dst ++;
#line 131
    *tmp___32 = (char )c;
  }
  done: 
#line 134
  *dst = (char )'\000';
#line 135
  return (dst);
}
}
#line 1 "bsd-setproctitle.o"
#line 7 "bsd-setproctitle.h"
void setproctitle(char const   *fmt  , ...) ;
#line 75 "bsd-setproctitle.c"
void setproctitle(char const   *fmt  , ...) 
{ 

  {
#line 105
  return;
}
}
#line 1 "bsd-waitpid.o"
#line 1 "fake-getaddrinfo.o"
#line 1 "fake-getnameinfo.o"
#line 1 "next-posix.o"
#line 1 "sshd.o"
#line 384 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 393
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 457
extern  __attribute__((__nothrow__)) int chdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 490
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 516
extern  __attribute__((__nothrow__)) int execv(char const   *__path , char * const  *__argv )  __attribute__((__nonnull__(1))) ;
#line 723
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 73
extern int optind ;
#line 152
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 903 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 92 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 478 "/usr/include/openssl/bn.h"
extern int BN_mask_bits(BIGNUM *a , int n ) ;
#line 450 "ssh.h"
void log_init(char *av0___0 , LogLevel level , SyslogFacility facility , int on_stderr ) ;
#line 7 "auth-pam.h"
void finish_pam(void) ;
#line 112 "servconf.h"
void initialize_server_options(ServerOptions *options___0 ) ;
#line 118
void read_server_config(ServerOptions *options___0 , char const   *filename ) ;
#line 121
void fill_default_server_options(ServerOptions *options___0 ) ;
#line 174 "/usr/include/openssl/dh.h"
extern void DH_free(DH *dh ) ;
#line 176
extern int DH_size(DH const   *dh ) ;
#line 194
extern int DH_compute_key(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
#line 33 "dh.h"
DH *choose_dh(int minbits ) ;
#line 37 "auth.h"
void do_authentication(void) ;
#line 38
void do_authentication2(void) ;
#line 36 "myproposal.h"
static char *myproposal[10]  = 
#line 36 "myproposal.h"
  {      (char *)"diffie-hellman-group-exchange-sha1,diffie-hellman-group1-sha1",      (char *)"ssh-dss",      (char *)"3des-cbc,blowfish-cbc,cast128-cbc,arcfour,aes128-cbc,aes192-cbc,aes256-cbc,rijndael128-cbc,rijndael192-cbc,rijndael256-cbc,rijndael-cbc@lysator.liu.se",      (char *)"3des-cbc,blowfish-cbc,cast128-cbc,arcfour,aes128-cbc,aes192-cbc,aes256-cbc,rijndael128-cbc,rijndael192-cbc,rijndael256-cbc,rijndael-cbc@lysator.liu.se", 
        (char *)"hmac-sha1,hmac-md5,hmac-ripemd160@openssh.com",      (char *)"hmac-sha1,hmac-md5,hmac-ripemd160@openssh.com",      (char *)"none,zlib",      (char *)"none,zlib", 
        (char *)"",      (char *)""};
#line 83 "sshd.c"
ServerOptions options  ;
#line 86 "sshd.c"
char *config_file_name  =    (char *)"/usr/local/etc/sshd_config";
#line 95 "sshd.c"
int IPv4or6  =    0;
#line 104 "sshd.c"
int debug_flag  =    0;
#line 107 "sshd.c"
int inetd_flag  =    0;
#line 110 "sshd.c"
int log_stderr  =    0;
#line 113 "sshd.c"
char *av0  ;
#line 116 "sshd.c"
char **saved_argv  ;
#line 117 "sshd.c"
int saved_argc  ;
#line 124 "sshd.c"
int listen_socks[16]  ;
#line 125 "sshd.c"
int num_listen_socks  =    0;
#line 131 "sshd.c"
char *client_version_string  =    (char *)((void *)0);
#line 132 "sshd.c"
char *server_version_string  =    (char *)((void *)0);
#line 142 "sshd.c"
struct __anonstruct_sensitive_data_77 sensitive_data  ;
#line 152 "sshd.c"
int key_used  =    0;
#line 155 "sshd.c"
int received_sighup  =    0;
#line 159 "sshd.c"
RSA *public_key  ;
#line 162 "sshd.c"
unsigned char session_id[16]  ;
#line 165 "sshd.c"
unsigned char *session_id2  =    (unsigned char *)((void *)0);
#line 166 "sshd.c"
int session_id2_len  =    0;
#line 169 "sshd.c"
unsigned int utmp_len  =    64U;
#line 172
void do_ssh1_kex(void) ;
#line 173
void do_ssh2_kex(void) ;
#line 175
void ssh_dh1_server(Kex *kex___0 , Buffer *client_kexinit , Buffer *server_kexinit ) ;
#line 176
void ssh_dhgex_server(Kex *kex___0 , Buffer *client_kexinit , Buffer *server_kexinit ) ;
#line 181 "sshd.c"
void close_listen_socks(void) 
{ int i ;

  {
#line 185
  i = 0;
#line 185
  while (i < num_listen_socks) {
#line 186
    close(listen_socks[i]);
#line 185
    i ++;
  }
#line 187
  num_listen_socks = -1;
#line 188
  return;
}
}
#line 195 "sshd.c"
void sighup_handler(int sig ) 
{ 

  {
#line 198
  received_sighup = 1;
#line 199
  signal(1, & sighup_handler);
#line 200
  return;
}
}
#line 206 "sshd.c"
void sighup_restart(void) 
{ int *tmp ;
  char *tmp___0 ;

  {
#line 209
  log("Received SIGHUP; restarting.");
#line 210
  close_listen_socks();
#line 211
  execv((char const   *)*(saved_argv + 0), (char * const  *)saved_argv);
#line 212
  tmp = __errno_location();
#line 212
  tmp___0 = strerror(*tmp);
#line 212
  log("RESTART FAILED: av0=\'%s\', error: %s.", av0, tmp___0);
#line 213
  exit(1);
}
}
#line 221 "sshd.c"
void sigterm_handler(int sig ) 
{ 

  {
#line 224
  log("Received signal %d; terminating.", sig);
#line 225
  close_listen_socks();
#line 226
  unlink((char const   *)options.pid_file);
#line 227
  exit(255);
}
}
#line 234 "sshd.c"
void main_sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  int status ;
  __pid_t tmp___0 ;
  int *tmp___1 ;

  {
#line 237
  tmp = __errno_location();
#line 237
  save_errno = *tmp;
#line 240
  while (1) {
#line 240
    tmp___0 = waitpid(-1, & status, 1);
#line 240
    if (! (tmp___0 > 0)) {
#line 240
      break;
    }
  }
#line 243
  signal(17, & main_sigchld_handler);
#line 244
  tmp___1 = __errno_location();
#line 244
  *tmp___1 = save_errno;
#line 245
  return;
}
}
#line 250 "sshd.c"
void grace_alarm_handler(int sig ) 
{ char const   *tmp ;

  {
#line 254
  packet_close();
#line 257
  tmp = get_remote_ipaddr();
#line 257
  fatal("Timeout before authentication for %s.", tmp);
#line 258
  return;
}
}
#line 268 "sshd.c"
void key_regeneration_alarm(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 271
  tmp = __errno_location();
#line 271
  save_errno = *tmp;
#line 274
  if (key_used) {
#line 276
    log("Generating new %d bit RSA key.", options.server_key_bits);
#line 278
    if ((unsigned int )sensitive_data.private_key != (unsigned int )((void *)0)) {
#line 279
      RSA_free(sensitive_data.private_key);
    }
#line 280
    sensitive_data.private_key = RSA_new();
#line 282
    if ((unsigned int )public_key != (unsigned int )((void *)0)) {
#line 283
      RSA_free(public_key);
    }
#line 284
    public_key = RSA_new();
#line 286
    rsa_generate_key(sensitive_data.private_key, public_key, (unsigned int )options.server_key_bits);
#line 288
    arc4random_stir();
#line 289
    key_used = 0;
#line 290
    log("RSA key generation complete.");
  }
#line 293
  signal(14, & key_regeneration_alarm);
#line 294
  alarm((unsigned int )options.key_regeneration_time);
#line 295
  tmp___0 = __errno_location();
#line 295
  *tmp___0 = save_errno;
#line 296
  return;
}
}
#line 298 "sshd.c"
void sshd_exchange_identification(int sock_in , int sock_out ) 
{ int i ;
  int mismatch ;
  int remote_major ;
  int remote_minor ;
  int major ;
  int minor ;
  char *s ;
  char buf___1[256] ;
  char remote_version[256] ;
  char const   *tmp ;
  size_t tmp___0 ;
  ssize_t tmp___1 ;
  size_t tmp___2 ;
  char const   *tmp___3 ;
  ssize_t tmp___4 ;
  int tmp___18 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t tmp___31 ;
  char const   *tmp___32 ;
  int tmp___33 ;
  size_t tmp___34 ;
  char const   *tmp___35 ;

  {
#line 308
  if (options.protocol & 1) {
#line 308
    if (options.protocol & 4) {
#line 310
      major = 1;
#line 311
      minor = 99;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 312
    if (options.protocol & 4) {
#line 313
      major = 2;
#line 314
      minor = 0;
    } else {
#line 316
      major = 1;
#line 317
      minor = 5;
    }
  }
#line 319
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"SSH-%d.%d-%.100s\n",
           major, minor, "OpenSSH_2.3.0p1");
#line 320
  server_version_string = xstrdup((char const   *)(buf___1));
#line 322
  if ((unsigned int )client_version_string == (unsigned int )((void *)0)) {
#line 324
    tmp___0 = strlen((char const   *)server_version_string);
#line 324
    tmp___1 = atomicio((ssize_t (*)())(& write), sock_out, (void *)server_version_string,
                       tmp___0);
#line 324
    tmp___2 = strlen((char const   *)server_version_string);
#line 324
    if ((size_t )tmp___1 != tmp___2) {
#line 326
      tmp = get_remote_ipaddr();
#line 326
      log("Could not write ident string to %s.", tmp);
#line 327
      fatal_cleanup();
    }
#line 331
    i = 0;
#line 331
    while ((unsigned int )i < sizeof(buf___1) - 1U) {
#line 332
      tmp___4 = atomicio((ssize_t (*)())(& read), sock_in, (void *)(& buf___1[i]),
                         1U);
#line 332
      if (tmp___4 != 1) {
#line 333
        tmp___3 = get_remote_ipaddr();
#line 333
        log("Did not receive ident string from %s.", tmp___3);
#line 334
        fatal_cleanup();
      }
#line 336
      if ((int )buf___1[i] == 13) {
#line 337
        buf___1[i] = (char )'\n';
#line 338
        buf___1[i + 1] = (char)0;
#line 341
        if (i == 12) {
#line 341
          if (0) {
#line 341
            if (0) {
#line 341
              __s1_len___0 = strlen((char const   *)(buf___1));
#line 341
              __s2_len___0 = strlen("SSH-1.5-W1.0");
#line 341
              if (! ((unsigned int )((void const   *)(buf___1 + 1)) - (unsigned int )((void const   *)(buf___1)) == 1U)) {
                goto _L___3;
              } else {
#line 341
                if (__s1_len___0 >= 4U) {
                  _L___3: /* CIL Label */ 
#line 341
                  if (! ((unsigned int )((void const   *)("SSH-1.5-W1.0" + 1)) - (unsigned int )((void const   *)"SSH-1.5-W1.0") == 1U)) {
#line 341
                    tmp___28 = 1;
                  } else {
#line 341
                    if (__s2_len___0 >= 4U) {
#line 341
                      tmp___28 = 1;
                    } else {
#line 341
                      tmp___28 = 0;
                    }
                  }
                } else {
#line 341
                  tmp___28 = 0;
                }
              }
#line 341
              if (tmp___28) {
#line 341
                tmp___24 = __builtin_strcmp((char const   *)(buf___1), "SSH-1.5-W1.0");
              } else {
#line 341
                tmp___27 = __builtin_strcmp((char const   *)(buf___1), "SSH-1.5-W1.0");
#line 341
                tmp___24 = tmp___27;
              }
            } else {
#line 341
              tmp___27 = __builtin_strcmp((char const   *)(buf___1), "SSH-1.5-W1.0");
#line 341
              tmp___24 = tmp___27;
            }
#line 341
            tmp___18 = tmp___24;
          } else {
#line 341
            tmp___18 = strncmp((char const   *)(buf___1), "SSH-1.5-W1.0", 12U);
          }
#line 341
          if (tmp___18 == 0) {
#line 342
            break;
          }
        }
        goto __Cont;
      }
#line 345
      if ((int )buf___1[i] == 10) {
#line 347
        buf___1[i + 1] = (char)0;
#line 348
        break;
      }
      __Cont: /* CIL Label */ 
#line 331
      i ++;
    }
#line 351
    buf___1[sizeof(buf___1) - 1U] = (char)0;
#line 352
    client_version_string = xstrdup((char const   *)(buf___1));
  }
#line 359
  tmp___33 = sscanf((char const   * __restrict  )client_version_string, (char const   * __restrict  )"SSH-%d.%d-%[^\n]\n",
                    & remote_major, & remote_minor, remote_version);
#line 359
  if (tmp___33 != 3) {
#line 361
    s = (char *)"Protocol mismatch.\n";
#line 362
    tmp___31 = strlen((char const   *)s);
#line 362
    atomicio((ssize_t (*)())(& write), sock_out, (void *)s, tmp___31);
#line 363
    close(sock_in);
#line 364
    close(sock_out);
#line 365
    tmp___32 = get_remote_ipaddr();
#line 365
    log("Bad protocol version identification \'%.100s\' from %s", client_version_string,
        tmp___32);
#line 367
    fatal_cleanup();
  }
#line 369
  debug("Client protocol version %d.%d; client software version %.100s", remote_major,
        remote_minor, remote_version);
#line 372
  compat_datafellows((char const   *)(remote_version));
#line 374
  mismatch = 0;
#line 375
  switch (remote_major) {
  case 1: 
#line 377
  if (remote_minor == 99) {
#line 378
    if (options.protocol & 4) {
#line 379
      enable_compat20();
    } else {
#line 381
      mismatch = 1;
    }
#line 382
    break;
  }
#line 384
  if (! (options.protocol & 1)) {
#line 385
    mismatch = 1;
#line 386
    break;
  }
#line 388
  if (remote_minor < 3) {
#line 389
    packet_disconnect("Your ssh version is too old and is no longer supported.  Please install a newer version.");
  } else {
#line 391
    if (remote_minor == 3) {
#line 393
      enable_compat13();
    }
  }
#line 395
  break;
  case 2: 
#line 397
  if (options.protocol & 4) {
#line 398
    enable_compat20();
#line 399
    break;
  }
  default: 
#line 403
  mismatch = 1;
#line 404
  break;
  }
#line 406
  chop(server_version_string);
#line 407
  chop(client_version_string);
#line 408
  debug("Local version string %.200s", server_version_string);
#line 410
  if (mismatch) {
#line 411
    s = (char *)"Protocol major versions differ.\n";
#line 412
    tmp___34 = strlen((char const   *)s);
#line 412
    atomicio((ssize_t (*)())(& write), sock_out, (void *)s, tmp___34);
#line 413
    close(sock_in);
#line 414
    close(sock_out);
#line 415
    tmp___35 = get_remote_ipaddr();
#line 415
    log("Protocol major versions differ for %s: %.200s vs. %.200s", tmp___35, server_version_string,
        client_version_string);
#line 418
    fatal_cleanup();
  }
#line 420
  if (compat20) {
#line 421
    packet_set_ssh2_format();
  }
#line 422
  return;
}
}
#line 425 "sshd.c"
void destroy_sensitive_data(void) 
{ 

  {
#line 429
  if (public_key) {
#line 430
    RSA_free(public_key);
  }
#line 431
  if (sensitive_data.private_key) {
#line 432
    RSA_free(sensitive_data.private_key);
  }
#line 433
  if (sensitive_data.host_key) {
#line 434
    RSA_free(sensitive_data.host_key);
  }
#line 435
  if ((unsigned int )sensitive_data.dsa_host_key != (unsigned int )((void *)0)) {
#line 436
    key_free(sensitive_data.dsa_host_key);
  }
#line 437
  return;
}
}
#line 445 "sshd.c"
int drop_connection(int startups ) 
{ double p ;
  double r ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 450
  if (startups < options.max_startups_begin) {
#line 451
    return (0);
  }
#line 452
  if (startups >= options.max_startups) {
#line 453
    return (1);
  }
#line 454
  if (options.max_startups_rate == 100) {
#line 455
    return (1);
  }
#line 457
  p = (double )(100 - options.max_startups_rate);
#line 458
  p *= (double )(startups - options.max_startups_begin);
#line 459
  p /= (double )(options.max_startups - options.max_startups_begin);
#line 460
  p += (double )options.max_startups_rate;
#line 461
  p /= 100.0;
#line 462
  tmp = arc4random();
#line 462
  r = (double )tmp / (double )4294967295U;
#line 464
  debug("drop_connection: p %g, r %g", p, r);
#line 465
  if (r < p) {
#line 465
    tmp___0 = 1;
  } else {
#line 465
    tmp___0 = 0;
  }
#line 465
  return (tmp___0);
}
}
#line 468 "sshd.c"
int *startup_pipes  =    (int *)((void *)0);
#line 469 "sshd.c"
int startup_pipe  ;
#line 474 "sshd.c"
int main(int ac , char **av ) 
{ int opt ;
  int sock_in ;
  int sock_out ;
  int newsock ;
  int j ;
  int i ;
  int fdsetsz ;
  int on ;
  pid_t pid ;
  socklen_t fromlen ;
  int silent ;
  fd_set *fdset ;
  struct sockaddr_storage from ;
  char const   *remote_ip ;
  int remote_port ;
  FILE *f ;
  struct linger linger ;
  struct addrinfo *ai ;
  char ntop[1025] ;
  char strport[32] ;
  int listen_sock ;
  int maxfd ;
  int startup_p[2] ;
  int startups ;
  char *tmp ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  Key k ;
  int *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int fd ;
  int *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  int s1 ;
  int s2 ;
  int tmp___20 ;
  int *tmp___21 ;
  char *tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  int *tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  int *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  __pid_t tmp___32 ;
  void *tmp___33 ;
  void *tmp___34 ;
  int *tmp___35 ;
  char *tmp___36 ;
  int *tmp___37 ;
  int tmp___38 ;
  register char __result ;
  register char __result___0 ;
  int *tmp___39 ;
  char *tmp___40 ;
  int *tmp___41 ;
  int *tmp___42 ;
  int *tmp___43 ;
  char *tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int *tmp___48 ;
  char *tmp___49 ;

  {
#line 479
  sock_in = 0;
#line 479
  sock_out = 0;
#line 479
  on = 1;
#line 482
  silent = 0;
#line 493
  startups = 0;
#line 495
  init_rng();
#line 498
  saved_argc = ac;
#line 499
  saved_argv = av;
#line 500
  tmp___1 = __builtin_strchr(*(av + 0), '/');
#line 500
  if (tmp___1) {
#line 501
    tmp = strrchr((char const   *)*(av + 0), '/');
#line 501
    av0 = tmp + 1;
  } else {
#line 503
    av0 = *(av + 0);
  }
#line 506
  initialize_server_options(& options);
#line 509
  while (1) {
#line 509
    opt = getopt(ac, (char * const  *)av, "f:p:b:k:h:g:V:u:diqQ46");
#line 509
    if (! (opt != -1)) {
#line 509
      break;
    }
#line 510
    switch (opt) {
    case 52: 
#line 512
    IPv4or6 = 2;
#line 513
    break;
    case 54: 
#line 515
    IPv4or6 = 10;
#line 516
    break;
    case 102: 
#line 518
    config_file_name = optarg;
#line 519
    break;
    case 100: 
#line 521
    if (0 == debug_flag) {
#line 522
      debug_flag = 1;
#line 523
      options.log_level = 5;
    } else {
#line 524
      if ((int )options.log_level < 7) {
#line 525
        options.log_level = (LogLevel )((int )options.log_level + 1);
      } else {
#line 527
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Too high debugging level.\n");
#line 528
        exit(1);
      }
    }
#line 530
    break;
    case 105: 
#line 532
    inetd_flag = 1;
#line 533
    break;
    case 81: 
#line 535
    silent = 1;
#line 536
    break;
    case 113: 
#line 538
    options.log_level = 0;
#line 539
    break;
    case 98: 
#line 541
    options.server_key_bits = atoi((char const   *)optarg);
#line 542
    break;
    case 112: 
#line 544
    options.ports_from_cmdline = 1U;
#line 545
    if (options.num_ports >= 256U) {
#line 546
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"too many ports.\n");
#line 547
      exit(1);
    }
#line 549
    tmp___2 = options.num_ports;
#line 549
    (options.num_ports) ++;
#line 549
    tmp___3 = atoi((char const   *)optarg);
#line 549
    options.ports[tmp___2] = (unsigned short )tmp___3;
#line 550
    break;
    case 103: 
#line 552
    options.login_grace_time = atoi((char const   *)optarg);
#line 553
    break;
    case 107: 
#line 555
    options.key_regeneration_time = atoi((char const   *)optarg);
#line 556
    break;
    case 104: 
#line 558
    options.host_key_file = optarg;
#line 559
    break;
    case 86: 
#line 561
    client_version_string = optarg;
#line 563
    inetd_flag = 1;
#line 564
    break;
    case 117: 
#line 566
    tmp___4 = atoi((char const   *)optarg);
#line 566
    utmp_len = (unsigned int )tmp___4;
#line 567
    break;
    case 63: 
    default: 
#line 570
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"sshd version %s\n",
            "OpenSSH_2.3.0p1");
#line 571
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: %s [options]\n",
            av0);
#line 572
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Options:\n");
#line 573
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -f file    Configuration file (default %s)\n",
            "/usr/local/etc/sshd_config");
#line 574
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -d         Debugging mode (multiple -d means more debugging)\n");
#line 575
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -i         Started from inetd\n");
#line 576
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -q         Quiet (no logging)\n");
#line 577
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -p port    Listen on the specified port (default: 22)\n");
#line 578
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -k seconds Regenerate server key every this many seconds (default: 3600)\n");
#line 579
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -g seconds Grace period for authentication (default: 300)\n");
#line 580
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -b bits    Size of server RSA key (default: 768 bits)\n");
#line 581
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -h file    File from which to read host key (default: %s)\n",
            "/usr/local/etc/ssh_host_key");
#line 583
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -u len     Maximum hostname length for utmp recording\n");
#line 584
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -4         Use IPv4 only\n");
#line 585
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -6         Use IPv6 only\n");
#line 586
    exit(1);
    }
  }
#line 594
  if (! silent) {
#line 594
    if (! inetd_flag) {
#line 594
      tmp___5 = 1;
    } else {
#line 594
      tmp___5 = 0;
    }
  } else {
#line 594
    tmp___5 = 0;
  }
#line 594
  if ((int )options.log_facility == -1) {
#line 594
    tmp___6 = 2;
  } else {
#line 594
    tmp___6 = (int )options.log_facility;
  }
#line 594
  if ((int )options.log_level == -1) {
#line 594
    tmp___7 = 3;
  } else {
#line 594
    tmp___7 = (int )options.log_level;
  }
#line 594
  log_init(av0, (enum __anonenum_LogLevel_74 )tmp___7, (enum __anonenum_SyslogFacility_73 )tmp___6,
           tmp___5);
#line 600
  read_server_config(& options, (char const   *)config_file_name);
#line 603
  fill_default_server_options(& options);
#line 606
  if (optind < ac) {
#line 607
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Extra argument %s.\n",
            *(av + optind));
#line 608
    exit(1);
  }
#line 611
  debug("sshd version %.100s", "OpenSSH_2.3.0p1");
#line 613
  sensitive_data.dsa_host_key = (Key *)((void *)0);
#line 614
  sensitive_data.host_key = (RSA *)((void *)0);
#line 617
  if (options.protocol & 1) {
#line 617
    tmp___8 = rsa_alive();
#line 617
    if (tmp___8 == 0) {
#line 619
      log("no RSA support in libssl and libcrypto.  See ssl(8)");
#line 620
      log("Disabling protocol version 1");
#line 621
      options.protocol &= -2;
    }
  }
#line 624
  if (options.protocol & 1) {
#line 626
    sensitive_data.host_key = RSA_new();
#line 627
    k.type = 0;
#line 628
    k.rsa = sensitive_data.host_key;
#line 629
    tmp___9 = __errno_location();
#line 629
    *tmp___9 = 0;
#line 630
    tmp___12 = load_private_key((char const   *)options.host_key_file, "", & k, (char **)((void *)0));
#line 630
    if (! tmp___12) {
#line 631
      tmp___10 = __errno_location();
#line 631
      tmp___11 = strerror(*tmp___10);
#line 631
      error("Could not load host key: %.200s: %.100s", options.host_key_file, tmp___11);
#line 633
      log("Disabling protocol version 1");
#line 634
      options.protocol &= -2;
    }
#line 636
    k.rsa = (RSA *)((void *)0);
  }
#line 638
  if (options.protocol & 4) {
#line 639
    sensitive_data.dsa_host_key = key_new(1);
#line 640
    tmp___13 = load_private_key((char const   *)options.host_dsa_key_file, "", sensitive_data.dsa_host_key,
                                (char **)((void *)0));
#line 640
    if (! tmp___13) {
#line 642
      error("Could not load DSA host key: %.200s", options.host_dsa_key_file);
#line 643
      log("Disabling protocol version 2");
#line 644
      options.protocol &= -5;
    }
  }
#line 647
  if (! options.protocol & 5) {
#line 648
    if (silent == 0) {
#line 649
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"sshd: no hostkeys available -- exiting.\n");
    }
#line 650
    log("sshd: no hostkeys available -- exiting.\n");
#line 651
    exit(1);
  }
#line 655
  if (options.protocol & 1) {
#line 656
    if (options.server_key_bits < 512) {
#line 658
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 659
      exit(1);
    } else {
#line 656
      if (options.server_key_bits > 32768) {
#line 658
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 659
        exit(1);
      }
    }
#line 666
    tmp___15 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 666
    if (options.server_key_bits > tmp___15 - 128) {
#line 666
      tmp___16 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 666
      if (options.server_key_bits < tmp___16 + 128) {
#line 670
        tmp___14 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 670
        options.server_key_bits = tmp___14 + 128;
#line 672
        debug("Forcing server key to %d bits to make it differ from host key.", options.server_key_bits);
      }
    }
  }
#line 682
  if (debug_flag) {
#line 682
    if (! inetd_flag) {
#line 683
      log_stderr = 1;
    }
  }
#line 684
  log_init(av0, options.log_level, options.log_facility, log_stderr);
#line 691
  if (! debug_flag) {
#line 691
    if (! inetd_flag) {
#line 695
      tmp___19 = daemon(0, 0);
#line 695
      if (tmp___19 < 0) {
#line 696
        tmp___17 = __errno_location();
#line 696
        tmp___18 = strerror(*tmp___17);
#line 696
        fatal("daemon() failed: %.200s", tmp___18);
      }
#line 700
      fd = open("/dev/tty", 258);
#line 701
      if (fd >= 0) {
#line 702
        ioctl(fd, 21538UL, (void *)0);
#line 703
        close(fd);
      }
    }
  }
#line 708
  log_init(av0, options.log_level, options.log_facility, log_stderr);
#line 711
  rsa_set_verbose(0);
#line 714
  arc4random_stir();
#line 718
  chdir("/");
#line 721
  if (inetd_flag) {
#line 723
    s1 = dup(0);
#line 724
    s2 = dup(s1);
#line 725
    sock_in = dup(0);
#line 726
    sock_out = dup(1);
#line 727
    startup_pipe = -1;
#line 733
    debug("inetd sockets after dupping: %d, %d", sock_in, sock_out);
#line 735
    if (options.protocol & 1) {
#line 736
      public_key = RSA_new();
#line 737
      sensitive_data.private_key = RSA_new();
#line 738
      log("Generating %d bit RSA key.", options.server_key_bits);
#line 739
      rsa_generate_key(sensitive_data.private_key, public_key, (unsigned int )options.server_key_bits);
#line 741
      arc4random_stir();
#line 742
      log("RSA key generation complete.");
    }
  } else {
#line 745
    ai = options.listen_addrs;
#line 745
    while (ai) {
#line 746
      if (ai->ai_family != 2) {
#line 746
        if (ai->ai_family != 10) {
          goto __Cont;
        }
      }
#line 748
      if (num_listen_socks >= 16) {
#line 749
        fatal("Too many listen sockets. Enlarge MAX_LISTEN_SOCKS");
      }
#line 751
      tmp___20 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr,
                             ai->ai_addrlen, (char * __restrict  )(ntop), sizeof(ntop),
                             (char * __restrict  )(strport), sizeof(strport), 3U);
#line 751
      if (tmp___20 != 0) {
#line 754
        error("getnameinfo failed");
        goto __Cont;
      }
#line 758
      listen_sock = socket(ai->ai_family, 1, 0);
#line 759
      if (listen_sock < 0) {
#line 761
        tmp___21 = __errno_location();
#line 761
        tmp___22 = strerror(*tmp___21);
#line 761
        verbose("socket: %.100s", tmp___22);
        goto __Cont;
      }
#line 764
      tmp___25 = fcntl(listen_sock, 4, 2048);
#line 764
      if (tmp___25 < 0) {
#line 765
        tmp___23 = __errno_location();
#line 765
        tmp___24 = strerror(*tmp___23);
#line 765
        error("listen_sock O_NONBLOCK: %s", tmp___24);
#line 766
        close(listen_sock);
        goto __Cont;
      }
#line 775
      setsockopt(listen_sock, 1, 2, (void const   *)((void *)(& on)), sizeof(on));
#line 777
      linger.l_onoff = 1;
#line 778
      linger.l_linger = 5;
#line 779
      setsockopt(listen_sock, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 782
      debug("Bind to port %s on %s.", strport, ntop);
#line 785
      tmp___28 = bind(listen_sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 785
      if (tmp___28 < 0) {
#line 785
        if (! ai->ai_next) {
#line 787
          tmp___26 = __errno_location();
#line 787
          tmp___27 = strerror(*tmp___26);
#line 787
          error("Bind to port %s on %s failed: %.200s.", strport, ntop, tmp___27);
#line 789
          close(listen_sock);
          goto __Cont;
        }
      }
#line 792
      listen_socks[num_listen_socks] = listen_sock;
#line 793
      num_listen_socks ++;
#line 796
      log("Server listening on %s port %s.", ntop, strport);
#line 797
      tmp___31 = listen(listen_sock, 5);
#line 797
      if (tmp___31 < 0) {
#line 798
        tmp___29 = __errno_location();
#line 798
        tmp___30 = strerror(*tmp___29);
#line 798
        fatal("listen: %.100s", tmp___30);
      }
      __Cont: /* CIL Label */ 
#line 745
      ai = ai->ai_next;
    }
#line 801
    freeaddrinfo(options.listen_addrs);
#line 803
    if (! num_listen_socks) {
#line 804
      fatal("Cannot bind any address.");
    }
#line 806
    if (! debug_flag) {
#line 814
      f = fopen((char const   * __restrict  )options.pid_file, (char const   * __restrict  )"wb");
#line 815
      if (f) {
#line 816
        tmp___32 = getpid();
#line 816
        fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%u\n", (unsigned int )tmp___32);
#line 817
        fclose(f);
      }
    }
#line 820
    if (options.protocol & 1) {
#line 821
      public_key = RSA_new();
#line 822
      sensitive_data.private_key = RSA_new();
#line 824
      log("Generating %d bit RSA key.", options.server_key_bits);
#line 825
      rsa_generate_key(sensitive_data.private_key, public_key, (unsigned int )options.server_key_bits);
#line 827
      arc4random_stir();
#line 828
      log("RSA key generation complete.");
#line 831
      signal(14, & key_regeneration_alarm);
#line 832
      alarm((unsigned int )options.key_regeneration_time);
    }
#line 836
    signal(1, & sighup_handler);
#line 838
    signal(15, & sigterm_handler);
#line 839
    signal(3, & sigterm_handler);
#line 842
    signal(17, & main_sigchld_handler);
#line 845
    fdset = (fd_set *)((void *)0);
#line 846
    maxfd = 0;
#line 847
    i = 0;
#line 847
    while (i < num_listen_socks) {
#line 848
      if (listen_socks[i] > maxfd) {
#line 849
        maxfd = listen_socks[i];
      }
#line 847
      i ++;
    }
#line 851
    tmp___33 = xmalloc((unsigned int )options.max_startups * sizeof(int ));
#line 851
    startup_pipes = (int *)tmp___33;
#line 852
    i = 0;
#line 852
    while (i < options.max_startups) {
#line 853
      *(startup_pipes + i) = -1;
#line 852
      i ++;
    }
#line 859
    while (1) {
#line 860
      if (received_sighup) {
#line 861
        sighup_restart();
      }
#line 862
      if ((unsigned int )fdset != (unsigned int )((void *)0)) {
#line 863
        xfree((void *)fdset);
      }
#line 864
      fdsetsz = (int )((((unsigned int )maxfd + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 865
      tmp___34 = xmalloc((unsigned int )fdsetsz);
#line 865
      fdset = (fd_set *)tmp___34;
#line 866
      memset((void *)fdset, 0, (unsigned int )fdsetsz);
#line 868
      i = 0;
#line 868
      while (i < num_listen_socks) {
#line 869
        __asm__  volatile   ("btsl %1,%0": "=m" (fdset->__fds_bits[(unsigned int )listen_socks[i] / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )listen_socks[i] % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
#line 868
        i ++;
      }
#line 870
      i = 0;
#line 870
      while (i < options.max_startups) {
#line 871
        if (*(startup_pipes + i) != -1) {
#line 872
          __asm__  volatile   ("btsl %1,%0": "=m" (fdset->__fds_bits[(unsigned int )*(startup_pipes + i) / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )*(startup_pipes + i) % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        }
#line 870
        i ++;
      }
#line 875
      tmp___38 = select(maxfd + 1, (fd_set * __restrict  )fdset, (fd_set * __restrict  )((void *)0),
                        (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 875
      if (tmp___38 < 0) {
#line 876
        tmp___37 = __errno_location();
#line 876
        if (*tmp___37 != 4) {
#line 877
          tmp___35 = __errno_location();
#line 877
          tmp___36 = strerror(*tmp___35);
#line 877
          error("select: %.100s", tmp___36);
        }
        goto __Cont___0;
      }
#line 880
      i = 0;
#line 880
      while (i < options.max_startups) {
#line 882
        if (*(startup_pipes + i) != -1) {
#line 882
          __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )*(startup_pipes + i) % (8U * sizeof(__fd_mask ))),
                               "m" (fdset->__fds_bits[(unsigned int )*(startup_pipes + i) / (8U * sizeof(__fd_mask ))]): "cc");
#line 882
          if (__result) {
#line 889
            close(*(startup_pipes + i));
#line 890
            *(startup_pipes + i) = -1;
#line 891
            startups --;
          }
        }
#line 880
        i ++;
      }
#line 893
      i = 0;
#line 893
      while (i < num_listen_socks) {
#line 894
        __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )listen_socks[i] % (8U * sizeof(__fd_mask ))),
                             "m" (fdset->__fds_bits[(unsigned int )listen_socks[i] / (8U * sizeof(__fd_mask ))]): "cc");
#line 894
        if (! __result___0) {
          goto __Cont___1;
        }
#line 896
        fromlen = sizeof(from);
#line 897
        newsock = accept(listen_socks[i], (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                         (socklen_t * __restrict  )(& fromlen));
#line 899
        if (newsock < 0) {
#line 900
          tmp___41 = __errno_location();
#line 900
          if (*tmp___41 != 4) {
#line 900
            tmp___42 = __errno_location();
#line 900
            if (*tmp___42 != 11) {
#line 901
              tmp___39 = __errno_location();
#line 901
              tmp___40 = strerror(*tmp___39);
#line 901
              error("accept: %.100s", tmp___40);
            }
          }
          goto __Cont___1;
        }
#line 904
        tmp___45 = fcntl(newsock, 4, 0);
#line 904
        if (tmp___45 < 0) {
#line 905
          tmp___43 = __errno_location();
#line 905
          tmp___44 = strerror(*tmp___43);
#line 905
          error("newsock del O_NONBLOCK: %s", tmp___44);
          goto __Cont___1;
        }
#line 908
        tmp___46 = drop_connection(startups);
#line 908
        if (tmp___46 == 1) {
#line 909
          debug("drop connection #%d", startups);
#line 910
          close(newsock);
          goto __Cont___1;
        }
#line 913
        tmp___47 = pipe((int *)(startup_p));
#line 913
        if (tmp___47 == -1) {
#line 914
          close(newsock);
          goto __Cont___1;
        }
#line 918
        j = 0;
#line 918
        while (j < options.max_startups) {
#line 919
          if (*(startup_pipes + j) == -1) {
#line 920
            *(startup_pipes + j) = startup_p[0];
#line 921
            if (maxfd < startup_p[0]) {
#line 922
              maxfd = startup_p[0];
            }
#line 923
            startups ++;
#line 924
            break;
          }
#line 918
          j ++;
        }
#line 931
        if (debug_flag) {
#line 937
          debug("Server will not fork when running in debugging mode.");
#line 938
          close_listen_socks();
#line 939
          sock_in = newsock;
#line 940
          sock_out = newsock;
#line 941
          startup_pipe = -1;
#line 942
          pid = getpid();
#line 943
          break;
        } else {
#line 950
          pid = fork();
#line 950
          if (pid == 0) {
#line 958
            startup_pipe = startup_p[1];
#line 959
            j = 0;
#line 959
            while (j < options.max_startups) {
#line 960
              if (*(startup_pipes + j) != -1) {
#line 961
                close(*(startup_pipes + j));
              }
#line 959
              j ++;
            }
#line 962
            close_listen_socks();
#line 963
            sock_in = newsock;
#line 964
            sock_out = newsock;
#line 965
            log_init(av0, options.log_level, options.log_facility, log_stderr);
#line 966
            break;
          }
        }
#line 971
        if (pid < 0) {
#line 972
          tmp___48 = __errno_location();
#line 972
          tmp___49 = strerror(*tmp___48);
#line 972
          error("fork: %.100s", tmp___49);
        } else {
#line 974
          debug("Forked child %d.", pid);
        }
#line 976
        close(startup_p[1]);
#line 979
        key_used = 1;
#line 981
        arc4random_stir();
#line 984
        close(newsock);
        __Cont___1: /* CIL Label */ 
#line 893
        i ++;
      }
#line 987
      if (num_listen_socks < 0) {
#line 988
        break;
      }
      __Cont___0: /* CIL Label */ ;
    }
  }
#line 999
  alarm(0U);
#line 1000
  signal(14, (void (*)(int  ))0);
#line 1001
  signal(1, (void (*)(int  ))0);
#line 1002
  signal(15, (void (*)(int  ))0);
#line 1003
  signal(3, (void (*)(int  ))0);
#line 1004
  signal(17, (void (*)(int  ))0);
#line 1005
  signal(2, (void (*)(int  ))0);
#line 1013
  linger.l_onoff = 1;
#line 1014
  linger.l_linger = 5;
#line 1015
  setsockopt(sock_in, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 1021
  packet_set_connection(sock_in, sock_out);
#line 1023
  remote_port = get_remote_port();
#line 1024
  remote_ip = get_remote_ipaddr();
#line 1044
  verbose("Connection from %.500s port %d", remote_ip, remote_port);
#line 1054
  signal(14, & grace_alarm_handler);
#line 1055
  if (! debug_flag) {
#line 1056
    alarm((unsigned int )options.login_grace_time);
  }
#line 1058
  sshd_exchange_identification(sock_in, sock_out);
#line 1066
  if (remote_port >= 1024) {
#line 1068
    options.rhosts_authentication = 0;
#line 1069
    options.rhosts_rsa_authentication = 0;
  } else {
#line 1066
    if (remote_port < 512) {
#line 1068
      options.rhosts_authentication = 0;
#line 1069
      options.rhosts_rsa_authentication = 0;
    }
  }
#line 1079
  packet_set_nonblocking();
#line 1083
  if (compat20) {
#line 1084
    do_ssh2_kex();
#line 1085
    do_authentication2();
  } else {
#line 1087
    do_ssh1_kex();
#line 1088
    do_authentication();
  }
#line 1098
  verbose("Closing connection to %.100s", remote_ip);
#line 1101
  finish_pam();
#line 1104
  packet_close();
#line 1105
  exit(0);
}
}
#line 1111 "sshd.c"
void do_ssh1_kex(void) 
{ int i ;
  int len ;
  int plen ;
  int slen ;
  BIGNUM *session_key_int ;
  unsigned char session_key[32] ;
  unsigned char cookie[8] ;
  unsigned int cipher_type___0 ;
  unsigned int auth_mask ;
  unsigned int protocol_flags ;
  u_int32_t rand___0 ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  char *tmp___6 ;
  int _p ;
  int _e ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char const   *tmp___19 ;

  {
#line 1120
  rand___0 = (u_int32_t )0;
#line 1131
  i = 0;
#line 1131
  while (i < 8) {
#line 1132
    if (i % 4 == 0) {
#line 1133
      rand___0 = arc4random();
    }
#line 1134
    cookie[i] = (unsigned char )(rand___0 & 255U);
#line 1135
    rand___0 >>= 8;
#line 1131
    i ++;
  }
#line 1143
  packet_start(2);
#line 1144
  i = 0;
#line 1144
  while (i < 8) {
#line 1145
    packet_put_char((int )cookie[i]);
#line 1144
    i ++;
  }
#line 1148
  tmp = BN_num_bits((BIGNUM const   *)public_key->n);
#line 1148
  packet_put_int((unsigned int )tmp);
#line 1149
  packet_put_bignum(public_key->e);
#line 1150
  packet_put_bignum(public_key->n);
#line 1153
  tmp___0 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1153
  packet_put_int((unsigned int )tmp___0);
#line 1154
  packet_put_bignum((sensitive_data.host_key)->e);
#line 1155
  packet_put_bignum((sensitive_data.host_key)->n);
#line 1158
  packet_put_int(2U);
#line 1161
  tmp___1 = cipher_mask_ssh1(0);
#line 1161
  packet_put_int(tmp___1);
#line 1164
  auth_mask = 0U;
#line 1165
  if (options.rhosts_authentication) {
#line 1166
    auth_mask |= (unsigned int )(1 << 1);
  }
#line 1167
  if (options.rhosts_rsa_authentication) {
#line 1168
    auth_mask |= (unsigned int )(1 << 4);
  }
#line 1169
  if (options.rsa_authentication) {
#line 1170
    auth_mask |= (unsigned int )(1 << 2);
  }
#line 1185
  if (options.password_authentication) {
#line 1186
    auth_mask |= (unsigned int )(1 << 3);
  }
#line 1187
  packet_put_int(auth_mask);
#line 1190
  packet_send();
#line 1191
  packet_write_wait();
#line 1193
  tmp___2 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1193
  tmp___3 = BN_num_bits((BIGNUM const   *)public_key->n);
#line 1193
  debug("Sent %d bit public key and %d bit host key.", tmp___3, tmp___2);
#line 1197
  packet_read_expect(& plen, 3);
#line 1200
  cipher_type___0 = packet_get_char();
#line 1202
  tmp___4 = cipher_mask_ssh1(0);
#line 1202
  if (! (tmp___4 & (unsigned int )(1 << cipher_type___0))) {
#line 1203
    packet_disconnect("Warning: client selects unsupported cipher.");
  }
#line 1207
  i = 0;
#line 1207
  while (i < 8) {
#line 1208
    tmp___5 = packet_get_char();
#line 1208
    if ((unsigned int )cookie[i] != tmp___5) {
#line 1209
      packet_disconnect("IP Spoofing check bytes do not match.");
    }
#line 1207
    i ++;
  }
#line 1211
  tmp___6 = cipher_name((int )cipher_type___0);
#line 1211
  debug("Encryption type: %.200s", tmp___6);
#line 1214
  session_key_int = BN_new();
#line 1215
  packet_get_bignum(session_key_int, & slen);
#line 1217
  protocol_flags = packet_get_int();
#line 1218
  packet_set_protocol_flags(protocol_flags);
#line 1220
  while (1) {
#line 1220
    _p = plen;
#line 1220
    _e = (9 + slen) + 4;
#line 1220
    if (_p != _e) {
#line 1220
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "sshd.c", 1220);
#line 1220
      packet_disconnect("Packet integrity error. (%d)", 3);
    }
#line 1220
    break;
  }
#line 1226
  tmp___17 = BN_cmp((BIGNUM const   *)(sensitive_data.private_key)->n, (BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1226
  if (tmp___17 > 0) {
#line 1228
    tmp___10 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 1228
    tmp___11 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1228
    if (tmp___10 < tmp___11 + 128) {
#line 1230
      tmp___7 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1230
      tmp___8 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 1230
      tmp___9 = get_remote_ipaddr();
#line 1230
      fatal("do_connection: %s: private_key %d < host_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___9, tmp___8, tmp___7, 128);
    }
#line 1236
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.private_key);
#line 1238
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.host_key);
  } else {
#line 1242
    tmp___15 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1242
    tmp___16 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 1242
    if (tmp___15 < tmp___16 + 128) {
#line 1244
      tmp___12 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 1244
      tmp___13 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1244
      tmp___14 = get_remote_ipaddr();
#line 1244
      fatal("do_connection: %s: host_key %d < private_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___14, tmp___13, tmp___12, 128);
    }
#line 1250
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.host_key);
#line 1252
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.private_key);
  }
#line 1256
  compute_session_id((unsigned char *)(session_id), (unsigned char *)(cookie), (sensitive_data.host_key)->n,
                     (sensitive_data.private_key)->n);
#line 1261
  destroy_sensitive_data();
#line 1268
  BN_mask_bits(session_key_int, (int )(sizeof(session_key) * 8U));
#line 1269
  tmp___18 = BN_num_bits((BIGNUM const   *)session_key_int);
#line 1269
  len = (tmp___18 + 7) / 8;
#line 1270
  if (len < 0) {
#line 1271
    tmp___19 = get_remote_ipaddr();
#line 1271
    fatal("do_connection: bad len from %s: session_key_int %d > sizeof(session_key) %d",
          tmp___19, len, (int )sizeof(session_key));
  } else {
#line 1270
    if ((unsigned int )len > sizeof(session_key)) {
#line 1271
      tmp___19 = get_remote_ipaddr();
#line 1271
      fatal("do_connection: bad len from %s: session_key_int %d > sizeof(session_key) %d",
            tmp___19, len, (int )sizeof(session_key));
    }
  }
#line 1274
  memset((void *)(session_key), 0, sizeof(session_key));
#line 1275
  BN_bn2bin((BIGNUM const   *)session_key_int, (session_key + sizeof(session_key)) - len);
#line 1278
  BN_clear_free(session_key_int);
#line 1281
  i = 0;
#line 1281
  while (i < 16) {
#line 1282
    session_key[i] = (unsigned char )((int )session_key[i] ^ (int )session_id[i]);
#line 1281
    i ++;
  }
#line 1285
  packet_set_encryption_key((unsigned char const   *)(session_key), 32U, (int )cipher_type___0);
#line 1288
  memset((void *)(session_key), 0, sizeof(session_key));
#line 1290
  debug("Received session key; encryption turned on.");
#line 1293
  packet_start(14);
#line 1294
  packet_send();
#line 1295
  packet_write_wait();
#line 1296
  return;
}
}
#line 1301 "sshd.c"
void do_ssh2_kex(void) 
{ Buffer *server_kexinit ;
  Buffer *client_kexinit ;
  int payload_len ;
  int i ;
  Kex *kex___0 ;
  char *cprop[10] ;
  void *tmp ;

  {
#line 1313
  if ((unsigned int )options.ciphers != (unsigned int )((void *)0)) {
#line 1314
    myproposal[3] = options.ciphers;
#line 1314
    myproposal[2] = myproposal[3];
  }
#line 1317
  server_kexinit = kex_init((char **)(myproposal));
#line 1318
  tmp = xmalloc(sizeof(*client_kexinit));
#line 1318
  client_kexinit = (Buffer *)tmp;
#line 1319
  buffer_init(client_kexinit);
#line 1322
  kex_exchange_kexinit(server_kexinit, client_kexinit, (char **)(cprop));
#line 1323
  kex___0 = kex_choose_conf((char **)(cprop), (char **)(myproposal), 1);
#line 1324
  i = 0;
#line 1324
  while (i < 10) {
#line 1325
    xfree((void *)cprop[i]);
#line 1324
    i ++;
  }
#line 1327
  switch (kex___0->kex_type) {
  case 0: 
#line 1329
  ssh_dh1_server(kex___0, client_kexinit, server_kexinit);
#line 1330
  break;
  case 1: 
#line 1332
  ssh_dhgex_server(kex___0, client_kexinit, server_kexinit);
#line 1333
  break;
  default: 
#line 1335
  fatal("Unsupported key exchange %d", kex___0->kex_type);
  }
#line 1338
  debug("send SSH2_MSG_NEWKEYS.");
#line 1339
  packet_start(21);
#line 1340
  packet_send();
#line 1341
  packet_write_wait();
#line 1342
  debug("done: send SSH2_MSG_NEWKEYS.");
#line 1344
  debug("Wait SSH2_MSG_NEWKEYS.");
#line 1345
  packet_read_expect(& payload_len, 21);
#line 1346
  debug("GOT SSH2_MSG_NEWKEYS.");
#line 1356
  debug("done: KEX2.");
#line 1357
  return;
}
}
#line 1365 "sshd.c"
void ssh_dh1_server(Kex *kex___0 , Buffer *client_kexinit , Buffer *server_kexinit ) 
{ int payload_len ;
  int dlen ;
  int slen ;
  unsigned char *signature ;
  unsigned char *server_host_key_blob ;
  unsigned int sbloblen ;
  unsigned int klen ;
  unsigned int kout ;
  unsigned char *kbuf ;
  unsigned char *hash ;
  BIGNUM *shared_secret ;
  DH *dh ;
  BIGNUM *dh_client_pub ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  unsigned int tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;

  {
#line 1373
  signature = (unsigned char *)((void *)0);
#line 1374
  server_host_key_blob = (unsigned char *)((void *)0);
#line 1379
  shared_secret = (BIGNUM *)0;
#line 1381
  dh_client_pub = (BIGNUM *)0;
#line 1384
  debug("Wait SSH2_MSG_KEXDH_INIT.");
#line 1385
  packet_read_expect(& payload_len, 30);
#line 1388
  dh_client_pub = BN_new();
#line 1389
  if ((unsigned int )dh_client_pub == (unsigned int )((void *)0)) {
#line 1390
    fatal("dh_client_pub == NULL");
  }
#line 1391
  packet_get_bignum2(dh_client_pub, & dlen);
#line 1401
  dh = dh_new_group1();
#line 1413
  tmp = dh_pub_is_valid(dh, dh_client_pub);
#line 1413
  if (! tmp) {
#line 1414
    packet_disconnect("bad client public DH value");
  }
#line 1416
  tmp___0 = DH_size((DH const   *)dh);
#line 1416
  klen = (unsigned int )tmp___0;
#line 1417
  tmp___1 = xmalloc(klen);
#line 1417
  kbuf = (unsigned char *)tmp___1;
#line 1418
  tmp___2 = DH_compute_key(kbuf, (BIGNUM const   *)dh_client_pub, dh);
#line 1418
  kout = (unsigned int )tmp___2;
#line 1427
  shared_secret = BN_new();
#line 1429
  BN_bin2bn((unsigned char const   *)kbuf, (int )kout, shared_secret);
#line 1430
  memset((void *)kbuf, 0, klen);
#line 1431
  xfree((void *)kbuf);
#line 1434
  dsa_make_key_blob(sensitive_data.dsa_host_key, & server_host_key_blob, & sbloblen);
#line 1438
  tmp___3 = buffer_len(server_kexinit);
#line 1438
  tmp___4 = buffer_ptr(server_kexinit);
#line 1438
  tmp___5 = buffer_len(client_kexinit);
#line 1438
  tmp___6 = buffer_ptr(client_kexinit);
#line 1438
  hash = kex_hash(client_version_string, server_version_string, tmp___6, (int )tmp___5,
                  tmp___4, (int )tmp___3, (char *)server_host_key_blob, (int )sbloblen,
                  dh_client_pub, dh->pub_key, shared_secret);
#line 1448
  buffer_free(client_kexinit);
#line 1449
  buffer_free(server_kexinit);
#line 1450
  xfree((void *)client_kexinit);
#line 1451
  xfree((void *)server_kexinit);
#line 1460
  session_id2_len = 20;
#line 1461
  tmp___7 = xmalloc((unsigned int )session_id2_len);
#line 1461
  session_id2 = (unsigned char *)tmp___7;
#line 1462
  memcpy((void * __restrict  )session_id2, (void const   * __restrict  )hash, (unsigned int )session_id2_len);
#line 1466
  dsa_sign(sensitive_data.dsa_host_key, & signature, & slen, hash, 20);
#line 1468
  destroy_sensitive_data();
#line 1471
  packet_start(31);
#line 1472
  packet_put_string((char const   *)((char *)server_host_key_blob), sbloblen);
#line 1473
  packet_put_bignum2(dh->pub_key);
#line 1474
  packet_put_string((char const   *)((char *)signature), (unsigned int )slen);
#line 1475
  packet_send();
#line 1476
  xfree((void *)signature);
#line 1477
  xfree((void *)server_host_key_blob);
#line 1478
  packet_write_wait();
#line 1480
  kex_derive_keys(kex___0, hash, shared_secret);
#line 1481
  packet_set_kex(kex___0);
#line 1484
  DH_free(dh);
#line 1485
  return;
}
}
#line 1489 "sshd.c"
void ssh_dhgex_server(Kex *kex___0 , Buffer *client_kexinit , Buffer *server_kexinit ) 
{ int payload_len ;
  int dlen ;
  int slen ;
  int nbits ;
  unsigned char *signature ;
  unsigned char *server_host_key_blob ;
  unsigned int sbloblen ;
  unsigned int klen ;
  unsigned int kout ;
  unsigned char *kbuf ;
  unsigned char *hash ;
  BIGNUM *shared_secret ;
  DH *dh ;
  BIGNUM *dh_client_pub ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  char *tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  void *tmp___8 ;

  {
#line 1497
  signature = (unsigned char *)((void *)0);
#line 1498
  server_host_key_blob = (unsigned char *)((void *)0);
#line 1503
  shared_secret = (BIGNUM *)0;
#line 1505
  dh_client_pub = (BIGNUM *)0;
#line 1508
  debug("Wait SSH2_MSG_KEX_DH_GEX_REQUEST.");
#line 1509
  packet_read_expect(& payload_len, 30);
#line 1510
  tmp = packet_get_int();
#line 1510
  nbits = (int )tmp;
#line 1511
  dh = choose_dh(nbits);
#line 1513
  debug("Sending SSH2_MSG_KEX_DH_GEX_GROUP.");
#line 1514
  packet_start(31);
#line 1515
  packet_put_bignum2(dh->p);
#line 1516
  packet_put_bignum2(dh->g);
#line 1517
  packet_send();
#line 1518
  packet_write_wait();
#line 1520
  debug("Wait SSH2_MSG_KEX_DH_GEX_INIT.");
#line 1521
  packet_read_expect(& payload_len, 32);
#line 1524
  dh_client_pub = BN_new();
#line 1525
  if ((unsigned int )dh_client_pub == (unsigned int )((void *)0)) {
#line 1526
    fatal("dh_client_pub == NULL");
  }
#line 1527
  packet_get_bignum2(dh_client_pub, & dlen);
#line 1546
  tmp___0 = dh_pub_is_valid(dh, dh_client_pub);
#line 1546
  if (! tmp___0) {
#line 1547
    packet_disconnect("bad client public DH value");
  }
#line 1549
  tmp___1 = DH_size((DH const   *)dh);
#line 1549
  klen = (unsigned int )tmp___1;
#line 1550
  tmp___2 = xmalloc(klen);
#line 1550
  kbuf = (unsigned char *)tmp___2;
#line 1551
  tmp___3 = DH_compute_key(kbuf, (BIGNUM const   *)dh_client_pub, dh);
#line 1551
  kout = (unsigned int )tmp___3;
#line 1560
  shared_secret = BN_new();
#line 1562
  BN_bin2bn((unsigned char const   *)kbuf, (int )kout, shared_secret);
#line 1563
  memset((void *)kbuf, 0, klen);
#line 1564
  xfree((void *)kbuf);
#line 1567
  dsa_make_key_blob(sensitive_data.dsa_host_key, & server_host_key_blob, & sbloblen);
#line 1571
  tmp___4 = buffer_len(server_kexinit);
#line 1571
  tmp___5 = buffer_ptr(server_kexinit);
#line 1571
  tmp___6 = buffer_len(client_kexinit);
#line 1571
  tmp___7 = buffer_ptr(client_kexinit);
#line 1571
  hash = kex_hash_gex(client_version_string, server_version_string, tmp___7, (int )tmp___6,
                      tmp___5, (int )tmp___4, (char *)server_host_key_blob, (int )sbloblen,
                      nbits, dh->p, dh->g, dh_client_pub, dh->pub_key, shared_secret);
#line 1582
  buffer_free(client_kexinit);
#line 1583
  buffer_free(server_kexinit);
#line 1584
  xfree((void *)client_kexinit);
#line 1585
  xfree((void *)server_kexinit);
#line 1594
  session_id2_len = 20;
#line 1595
  tmp___8 = xmalloc((unsigned int )session_id2_len);
#line 1595
  session_id2 = (unsigned char *)tmp___8;
#line 1596
  memcpy((void * __restrict  )session_id2, (void const   * __restrict  )hash, (unsigned int )session_id2_len);
#line 1600
  dsa_sign(sensitive_data.dsa_host_key, & signature, & slen, hash, 20);
#line 1602
  destroy_sensitive_data();
#line 1605
  packet_start(33);
#line 1606
  packet_put_string((char const   *)((char *)server_host_key_blob), sbloblen);
#line 1607
  packet_put_bignum2(dh->pub_key);
#line 1608
  packet_put_string((char const   *)((char *)signature), (unsigned int )slen);
#line 1609
  packet_send();
#line 1610
  xfree((void *)signature);
#line 1611
  xfree((void *)server_host_key_blob);
#line 1612
  packet_write_wait();
#line 1614
  kex_derive_keys(kex___0, hash, shared_secret);
#line 1615
  packet_set_kex(kex___0);
#line 1618
  DH_free(dh);
#line 1619
  return;
}
}
#line 1 "auth.o"
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 382
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
#line 433
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 433 "/usr/include/sys/stat.h"
__inline static int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
#line 436
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
#line 436
  return (tmp);
}
}
#line 103 "/usr/include/grp.h"
extern struct group *getgrgid(__gid_t __gid ) ;
#line 45 "auth.h"
int allowed_user(struct passwd *pw ) ;
#line 73 "auth.c"
int allowed_user(struct passwd *pw ) 
{ struct stat st ;
  struct group *grp ;
  char *shell ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 106
  if (! pw) {
#line 107
    return (0);
  }
#line 114
  if ((int )*(pw->pw_shell + 0) == 0) {
#line 114
    shell = (char *)"/bin/sh";
  } else {
#line 114
    shell = pw->pw_shell;
  }
#line 117
  tmp = stat((char const   * __restrict  )shell, (struct stat * __restrict  )(& st));
#line 117
  if (tmp != 0) {
#line 118
    return (0);
  }
#line 119
  if (st.st_mode & 32768U) {
#line 119
    if (! (st.st_mode & (unsigned int )((((64 >> 3) >> 3) | 64) | (64 >> 3)))) {
#line 120
      return (0);
    }
  } else {
#line 120
    return (0);
  }
#line 123
  if (options.num_deny_users > 0U) {
#line 124
    if (! pw->pw_name) {
#line 125
      return (0);
    }
#line 126
    i = 0;
#line 126
    while ((unsigned int )i < options.num_deny_users) {
#line 127
      tmp___0 = match_pattern((char const   *)pw->pw_name, (char const   *)options.deny_users[i]);
#line 127
      if (tmp___0) {
#line 128
        return (0);
      }
#line 126
      i ++;
    }
  }
#line 131
  if (options.num_allow_users > 0U) {
#line 132
    if (! pw->pw_name) {
#line 133
      return (0);
    }
#line 134
    i = 0;
#line 134
    while ((unsigned int )i < options.num_allow_users) {
#line 135
      tmp___1 = match_pattern((char const   *)pw->pw_name, (char const   *)options.allow_users[i]);
#line 135
      if (tmp___1) {
#line 136
        break;
      }
#line 134
      i ++;
    }
#line 138
    if ((unsigned int )i >= options.num_allow_users) {
#line 139
      return (0);
    }
  }
#line 142
  if (options.num_deny_groups > 0U) {
    goto _L;
  } else {
#line 142
    if (options.num_allow_groups > 0U) {
      _L: /* CIL Label */ 
#line 143
      grp = getgrgid(pw->pw_gid);
#line 144
      if (! grp) {
#line 145
        return (0);
      }
#line 148
      if (options.num_deny_groups > 0U) {
#line 149
        if (! grp->gr_name) {
#line 150
          return (0);
        }
#line 151
        i = 0;
#line 151
        while ((unsigned int )i < options.num_deny_groups) {
#line 152
          tmp___2 = match_pattern((char const   *)grp->gr_name, (char const   *)options.deny_groups[i]);
#line 152
          if (tmp___2) {
#line 153
            return (0);
          }
#line 151
          i ++;
        }
      }
#line 159
      if (options.num_allow_groups > 0U) {
#line 160
        if (! grp->gr_name) {
#line 161
          return (0);
        }
#line 162
        i = 0;
#line 162
        while ((unsigned int )i < options.num_allow_groups) {
#line 163
          tmp___3 = match_pattern((char const   *)grp->gr_name, (char const   *)options.allow_groups[i]);
#line 163
          if (tmp___3) {
#line 164
            break;
          }
#line 162
          i ++;
        }
#line 167
        if ((unsigned int )i >= options.num_allow_groups) {
#line 168
          return (0);
        }
      }
    }
  }
#line 190
  return (1);
}
}
#line 1 "auth1.o"
#line 352 "ssh.h"
int auth_rhosts(struct passwd *pw , char const   *client_user ) ;
#line 358
int auth_rhosts_rsa(struct passwd *pw , char const   *client_user , RSA *client_host_key ) ;
#line 372
int auth_rsa(struct passwd *pw , BIGNUM *client_n ) ;
#line 6 "auth-pam.h"
void start_pam(struct passwd *pw ) ;
#line 8
int auth_pam_password(struct passwd *pw , char const   *password ) ;
#line 10
int do_pam_account(char *username , char *remote_user ) ;
#line 28 "session.h"
void do_authenticated(struct passwd *pw ) ;
#line 33 "auth1.c"
char *forced_command ;
#line 49 "auth1.c"
static char buf[1024]  ;
#line 46 "auth1.c"
char *get_authname(int type ) 
{ 

  {
#line 50
  switch (type) {
  case 9: 
#line 52
  return ((char *)"password");
  case 6: 
#line 54
  return ((char *)"rsa");
  case 35: 
#line 56
  return ((char *)"rhosts-rsa");
  case 5: 
#line 58
  return ((char *)"rhosts");
  }
#line 68
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"bad-auth-msg-%d",
           type);
#line 69
  return (buf);
}
}
#line 79 "auth1.c"
void do_authloop(struct passwd *pw , char *luser ) 
{ int authenticated ;
  int attempt ;
  unsigned int bits ;
  RSA *client_host_key ;
  BIGNUM *n___0 ;
  char *client_user ;
  char *password ;
  char user[1024] ;
  unsigned int dlen ;
  int plen ;
  int nlen ;
  int elen ;
  unsigned int ulen ;
  int type ;
  void (*authlog)(char const   *fmt  , ...) ;
  int _p ;
  int _e ;
  int tmp ;
  int tmp___0 ;
  int _p___0 ;
  int _e___0 ;
  int _p___1 ;
  int _e___1 ;
  int _p___2 ;
  int _e___2 ;
  size_t tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;

  {
#line 82
  authenticated = 0;
#line 83
  attempt = 0;
#line 92
  type = 0;
#line 93
  authlog = (void (*)(char const   *fmt  , ...))(& verbose);
#line 96
  packet_start(15);
#line 97
  packet_send();
#line 98
  packet_write_wait();
#line 100
  client_user = (char *)((void *)0);
#line 102
  attempt = 1;
#line 102
  while (1) {
#line 104
    authenticated = 0;
#line 106
    strlcpy(user, "", sizeof(user));
#line 109
    type = packet_read(& plen);
#line 112
    switch (type) {
    case 5: 
#line 171
    if (! options.rhosts_authentication) {
#line 172
      verbose("Rhosts authentication disabled.");
#line 173
      break;
    }
#line 181
    client_user = packet_get_string(& ulen);
#line 182
    while (1) {
#line 182
      _p = plen;
#line 182
      _e = (int )(4U + ulen);
#line 182
      if (_p != _e) {
#line 182
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "auth1.c", 182);
#line 182
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 182
      break;
    }
#line 185
    authenticated = auth_rhosts(pw, (char const   *)client_user);
#line 187
    snprintf((char * __restrict  )(user), sizeof(user), (char const   * __restrict  )" ruser %s",
             client_user);
#line 188
    break;
    case 35: 
#line 191
    if (! options.rhosts_rsa_authentication) {
#line 192
      verbose("Rhosts with RSA authentication disabled.");
#line 193
      break;
    }
#line 200
    client_user = packet_get_string(& ulen);
#line 203
    client_host_key = RSA_new();
#line 204
    if ((unsigned int )client_host_key == (unsigned int )((void *)0)) {
#line 205
      fatal("RSA_new failed");
    }
#line 206
    client_host_key->e = BN_new();
#line 207
    client_host_key->n = BN_new();
#line 208
    if ((unsigned int )client_host_key->e == (unsigned int )((void *)0)) {
#line 209
      fatal("BN_new failed");
    } else {
#line 208
      if ((unsigned int )client_host_key->n == (unsigned int )((void *)0)) {
#line 209
        fatal("BN_new failed");
      }
    }
#line 210
    bits = packet_get_int();
#line 211
    packet_get_bignum(client_host_key->e, & elen);
#line 212
    packet_get_bignum(client_host_key->n, & nlen);
#line 214
    tmp___0 = BN_num_bits((BIGNUM const   *)client_host_key->n);
#line 214
    if (bits != (unsigned int )tmp___0) {
#line 215
      tmp = BN_num_bits((BIGNUM const   *)client_host_key->n);
#line 215
      verbose("Warning: keysize mismatch for client_host_key: actual %d, announced %d",
              tmp, bits);
    }
#line 217
    while (1) {
#line 217
      _p___0 = plen;
#line 217
      _e___0 = (int )((((4U + ulen) + 4U) + (unsigned int )elen) + (unsigned int )nlen);
#line 217
      if (_p___0 != _e___0) {
#line 217
        log("Packet integrity error (%d != %d) at %s:%d", _p___0, _e___0, "auth1.c",
            217);
#line 217
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 217
      break;
    }
#line 219
    authenticated = auth_rhosts_rsa(pw, (char const   *)client_user, client_host_key);
#line 220
    RSA_free(client_host_key);
#line 222
    snprintf((char * __restrict  )(user), sizeof(user), (char const   * __restrict  )" ruser %s",
             client_user);
#line 223
    break;
    case 6: 
#line 226
    if (! options.rsa_authentication) {
#line 227
      verbose("RSA authentication disabled.");
#line 228
      break;
    }
#line 231
    n___0 = BN_new();
#line 232
    packet_get_bignum(n___0, & nlen);
#line 233
    while (1) {
#line 233
      _p___1 = plen;
#line 233
      _e___1 = nlen;
#line 233
      if (_p___1 != _e___1) {
#line 233
        log("Packet integrity error (%d != %d) at %s:%d", _p___1, _e___1, "auth1.c",
            233);
#line 233
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 233
      break;
    }
#line 234
    authenticated = auth_rsa(pw, n___0);
#line 235
    BN_clear_free(n___0);
#line 236
    break;
    case 9: 
#line 239
    if (! options.password_authentication) {
#line 240
      verbose("Password authentication disabled.");
#line 241
      break;
    }
#line 248
    password = packet_get_string(& dlen);
#line 249
    while (1) {
#line 249
      _p___2 = plen;
#line 249
      _e___2 = (int )(4U + dlen);
#line 249
      if (_p___2 != _e___2) {
#line 249
        log("Packet integrity error (%d != %d) at %s:%d", _p___2, _e___2, "auth1.c",
            249);
#line 249
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 249
      break;
    }
#line 253
    authenticated = auth_pam_password(pw, (char const   *)password);
#line 266
    tmp___1 = strlen((char const   *)password);
#line 266
    memset((void *)password, 0, tmp___1);
#line 267
    xfree((void *)password);
#line 268
    break;
    case 39: 
#line 307
    log("TIS authentication unsupported.");
#line 308
    break;
    default: 
#line 316
    log("Unknown message during authentication: type %d", type);
#line 317
    break;
    }
#line 319
    if (authenticated) {
#line 319
      if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 320
        fatal("internal error: authenticated for pw == NULL");
      }
    }
#line 336
    if (authenticated) {
#line 336
      if (pw) {
#line 336
        if (pw->pw_uid == 0U) {
#line 336
          if (! options.permit_root_login) {
#line 337
            if (forced_command) {
#line 338
              log("Root login accepted for forced command.");
            } else {
#line 340
              authenticated = 0;
#line 341
              tmp___2 = get_canonical_hostname();
#line 341
              log("ROOT LOGIN REFUSED FROM %.200s", tmp___2);
            }
          }
        }
      }
    }
#line 347
    if (authenticated) {
#line 350
      authlog = (void (*)(char const   *fmt  , ...))(& log);
    } else {
#line 347
      if (attempt == 3) {
#line 350
        authlog = (void (*)(char const   *fmt  , ...))(& log);
      } else {
#line 347
        if (type == 9) {
#line 350
          authlog = (void (*)(char const   *fmt  , ...))(& log);
        }
      }
    }
#line 352
    tmp___3 = get_remote_port();
#line 352
    tmp___4 = get_remote_ipaddr();
#line 352
    if (pw) {
#line 352
      if (pw->pw_uid == 0U) {
#line 352
        tmp___5 = "ROOT";
      } else {
#line 352
        tmp___5 = (char const   *)luser;
      }
    } else {
#line 352
      tmp___5 = (char const   *)luser;
    }
#line 352
    if (pw) {
#line 352
      tmp___6 = "";
    } else {
#line 352
      tmp___6 = "illegal user ";
    }
#line 352
    tmp___7 = get_authname(type);
#line 352
    if (authenticated) {
#line 352
      tmp___8 = "Accepted";
    } else {
#line 352
      tmp___8 = "Failed";
    }
#line 352
    (*authlog)("%s %s for %s%.100s from %.200s port %d%s", tmp___8, tmp___7, tmp___6,
               tmp___5, tmp___4, tmp___3, user);
#line 362
    if (authenticated) {
#line 362
      tmp___9 = do_pam_account(pw->pw_name, client_user);
#line 362
      if (! tmp___9) {
#line 363
        authenticated = 0;
      }
    }
#line 366
    if ((unsigned int )client_user != (unsigned int )((void *)0)) {
#line 367
      xfree((void *)client_user);
#line 368
      client_user = (char *)((void *)0);
    }
#line 371
    if (authenticated) {
#line 372
      return;
    }
#line 374
    if (attempt > 6) {
#line 378
      packet_disconnect("Too many authentication failures for %.100s", luser);
    }
#line 382
    packet_start(15);
#line 383
    packet_send();
#line 384
    packet_write_wait();
#line 102
    attempt ++;
  }
}
}
#line 392 "auth1.c"
void do_authentication(void) 
{ struct passwd *pw ;
  struct passwd pwcopy___0 ;
  int plen ;
  unsigned int ulen ;
  char *user ;
  int _p ;
  int _e ;
  int tmp ;
  __uid_t tmp___0 ;
  __uid_t tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;

  {
#line 401
  packet_read_expect(& plen, 4);
#line 404
  user = packet_get_string(& ulen);
#line 405
  while (1) {
#line 405
    _p = plen;
#line 405
    _e = (int )(4U + ulen);
#line 405
    if (_p != _e) {
#line 405
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "auth1.c", 405);
#line 405
      packet_disconnect("Packet integrity error. (%d)", 4);
    }
#line 405
    break;
  }
#line 407
  setproctitle("%s", user);
#line 418
  pw = getpwnam((char const   *)user);
#line 419
  if (pw) {
#line 419
    tmp = allowed_user(pw);
#line 419
    if (tmp) {
#line 421
      memset((void *)(& pwcopy___0), 0, sizeof(pwcopy___0));
#line 422
      pwcopy___0.pw_name = xstrdup((char const   *)pw->pw_name);
#line 423
      pwcopy___0.pw_passwd = xstrdup((char const   *)pw->pw_passwd);
#line 424
      pwcopy___0.pw_uid = pw->pw_uid;
#line 425
      pwcopy___0.pw_gid = pw->pw_gid;
#line 429
      pwcopy___0.pw_dir = xstrdup((char const   *)pw->pw_dir);
#line 430
      pwcopy___0.pw_shell = xstrdup((char const   *)pw->pw_shell);
#line 431
      pw = & pwcopy___0;
    } else {
#line 433
      pw = (struct passwd *)((void *)0);
    }
  } else {
#line 433
    pw = (struct passwd *)((void *)0);
  }
#line 437
  if (pw) {
#line 438
    start_pam(pw);
  }
#line 446
  tmp___0 = getuid();
#line 446
  if (tmp___0 != 0U) {
#line 446
    if (pw) {
#line 446
      tmp___1 = getuid();
#line 446
      if (pw->pw_uid != tmp___1) {
#line 447
        packet_disconnect("Cannot change user when server not running as root.");
      }
    }
  }
#line 450
  if (pw) {
#line 450
    tmp___2 = "";
  } else {
#line 450
    tmp___2 = "illegal user ";
  }
#line 450
  debug("Attempting authentication for %s%.100s.", tmp___2, user);
#line 453
  if (options.password_authentication) {
#line 453
    tmp___4 = auth_pam_password(pw, "");
#line 453
    if (tmp___4) {
#line 467
      tmp___3 = get_remote_ipaddr();
#line 467
      log("Login for user %s from %.100s, accepted without authentication.", user,
          tmp___3);
    } else {
#line 473
      do_authloop(pw, user);
    }
  } else {
#line 473
    do_authloop(pw, user);
  }
#line 475
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 476
    fatal("internal error, authentication successfull for user \'%.100s\'", user);
  }
#line 479
  packet_start(14);
#line 480
  packet_send();
#line 481
  packet_write_wait();
#line 490
  do_authenticated(pw);
#line 491
  return;
}
}
#line 1 "auth2.o"
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 212
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 759 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 40 "auth.h"
void userauth_log(Authctxt *authctxt , int authenticated , char *method ) ;
#line 41
void userauth_reply(Authctxt *authctxt , int authenticated ) ;
#line 46
struct passwd *auth_get_user(void) ;
#line 31 "session.h"
void do_authenticated2(void) ;
#line 27 "auth-options.h"
int auth_parse_options(struct passwd *pw , char *options___0 , unsigned long linenum ) ;
#line 29
void auth_clear_options(void) ;
#line 72 "auth2.c"
static Authctxt *x_authctxt  =    (Authctxt *)((void *)0);
#line 73 "auth2.c"
static int one  =    1;
#line 84
void input_service_request(int type , int plen , void *ctxt ) ;
#line 85
void input_userauth_request(int type , int plen , void *ctxt ) ;
#line 86
void protocol_error(int type , int plen , void *ctxt ) ;
#line 90
Authmethod *authmethod_lookup(char const   *name ) ;
#line 91
struct passwd *pwcopy(struct passwd *pw ) ;
#line 92
int user_dsa_key_allowed(struct passwd *pw , Key *key ) ;
#line 93
char *authmethods_get(void) ;
#line 96
int userauth_none(Authctxt *authctxt ) ;
#line 97
int userauth_passwd(Authctxt *authctxt ) ;
#line 98
int userauth_pubkey(Authctxt *authctxt ) ;
#line 99
int userauth_kbdint(Authctxt *authctxt ) ;
#line 101 "auth2.c"
Authmethod authmethods[5]  = {      {(char *)"none", & userauth_none, & one}, 
        {(char *)"publickey", & userauth_pubkey, & options.dsa_authentication}, 
        {(char *)"keyboard-interactive", & userauth_kbdint, & options.kbd_interactive_authentication}, 
        {(char *)"password",
      & userauth_passwd, & options.password_authentication}, 
        {(char *)((void *)0), (int (*)(Authctxt *authctxt ))((void *)0), (int *)((void *)0)}};
#line 121 "auth2.c"
void do_authentication2(void) 
{ Authctxt *authctxt ;
  void *tmp ;

  {
#line 124
  tmp = xmalloc(sizeof(*authctxt));
#line 124
  authctxt = (Authctxt *)tmp;
#line 125
  memset((void *)authctxt, 'a', sizeof(*authctxt));
#line 126
  authctxt->valid = 0;
#line 127
  authctxt->attempt = 0;
#line 128
  authctxt->success = 0;
#line 129
  x_authctxt = authctxt;
#line 135
  dispatch_init(& protocol_error);
#line 136
  dispatch_set(5, & input_service_request);
#line 137
  dispatch_run(0, & authctxt->success, (void *)authctxt);
#line 138
  do_authenticated2();
#line 139
  return;
}
}
#line 141 "auth2.c"
void protocol_error(int type , int plen , void *ctxt ) 
{ 

  {
#line 144
  log("auth: protocol error: type %d plen %d", type, plen);
#line 145
  packet_start(3);
#line 146
  packet_put_int(0U);
#line 147
  packet_send();
#line 148
  packet_write_wait();
#line 149
  return;
}
}
#line 151 "auth2.c"
void input_service_request(int type , int plen , void *ctxt ) 
{ Authctxt *authctxt ;
  unsigned int len ;
  int accept___0 ;
  char *service ;
  char *tmp ;
  int _len ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 154
  authctxt = (Authctxt *)ctxt;
#line 156
  accept___0 = 0;
#line 157
  tmp = packet_get_string(& len);
#line 157
  service = tmp;
#line 158
  while (1) {
#line 158
    tmp___0 = packet_remaining();
#line 158
    _len = tmp___0;
#line 158
    if (_len > 0) {
#line 158
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
          158);
#line 158
      packet_disconnect("Packet integrity error.");
    }
#line 158
    break;
  }
#line 160
  if ((unsigned int )authctxt == (unsigned int )((void *)0)) {
#line 161
    fatal("input_service_request: no authctxt");
  }
#line 163
  if (0) {
#line 163
    __s1_len = strlen((char const   *)service);
#line 163
    __s2_len = strlen("ssh-userauth");
#line 163
    if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
      goto _L___0;
    } else {
#line 163
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 163
        if (! ((unsigned int )((void const   *)("ssh-userauth" + 1)) - (unsigned int )((void const   *)"ssh-userauth") == 1U)) {
#line 163
          tmp___10 = 1;
        } else {
#line 163
          if (__s2_len >= 4U) {
#line 163
            tmp___10 = 1;
          } else {
#line 163
            tmp___10 = 0;
          }
        }
      } else {
#line 163
        tmp___10 = 0;
      }
    }
#line 163
    if (tmp___10) {
#line 163
      tmp___6 = __builtin_strcmp((char const   *)service, "ssh-userauth");
    } else {
#line 163
      tmp___9 = __builtin_strcmp((char const   *)service, "ssh-userauth");
#line 163
      tmp___6 = tmp___9;
    }
  } else {
#line 163
    tmp___9 = __builtin_strcmp((char const   *)service, "ssh-userauth");
#line 163
    tmp___6 = tmp___9;
  }
#line 163
  if (tmp___6 == 0) {
#line 164
    if (! authctxt->success) {
#line 165
      accept___0 = 1;
#line 167
      dispatch_set(50, & input_userauth_request);
    }
  }
#line 172
  if (accept___0) {
#line 173
    packet_start(6);
#line 174
    packet_put_cstring((char const   *)service);
#line 175
    packet_send();
#line 176
    packet_write_wait();
  } else {
#line 178
    debug("bad service request %s", service);
#line 179
    packet_disconnect("bad service request %s", service);
  }
#line 181
  xfree((void *)service);
#line 182
  return;
}
}
#line 184 "auth2.c"
void input_userauth_request(int type , int plen , void *ctxt ) 
{ Authctxt *authctxt ;
  Authmethod *m___0 ;
  char *user ;
  char *service ;
  char *method ;
  int authenticated ;
  int tmp ;
  struct passwd *pw ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___16 ;
  int tmp___19 ;
  int tmp___20 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___26 ;
  int tmp___29 ;
  int tmp___30 ;
  char const   *tmp___31 ;
  int tmp___32 ;

  {
#line 187
  authctxt = (Authctxt *)ctxt;
#line 188
  m___0 = (Authmethod *)((void *)0);
#line 190
  authenticated = 0;
#line 192
  if ((unsigned int )authctxt == (unsigned int )((void *)0)) {
#line 193
    fatal("input_userauth_request: no authctxt");
  }
#line 194
  tmp = authctxt->attempt;
#line 194
  (authctxt->attempt) ++;
#line 194
  if (tmp >= 6) {
#line 199
    packet_disconnect("too many failed userauth_requests");
  }
#line 202
  user = packet_get_string((unsigned int *)((void *)0));
#line 203
  service = packet_get_string((unsigned int *)((void *)0));
#line 204
  method = packet_get_string((unsigned int *)((void *)0));
#line 205
  debug("userauth-request for user %s service %s method %s", user, service, method);
#line 206
  debug("attempt #%d", authctxt->attempt);
#line 208
  if (authctxt->attempt == 1) {
#line 210
    pw = (struct passwd *)((void *)0);
#line 211
    setproctitle("%s", user);
#line 212
    pw = getpwnam((char const   *)user);
#line 213
    if (pw) {
#line 213
      tmp___0 = allowed_user(pw);
#line 213
      if (tmp___0) {
#line 213
        if (0) {
#line 213
          __s1_len = strlen((char const   *)service);
#line 213
          __s2_len = strlen("ssh-connection");
#line 213
          if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
            goto _L___0;
          } else {
#line 213
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 213
              if (! ((unsigned int )((void const   *)("ssh-connection" + 1)) - (unsigned int )((void const   *)"ssh-connection") == 1U)) {
#line 213
                tmp___10 = 1;
              } else {
#line 213
                if (__s2_len >= 4U) {
#line 213
                  tmp___10 = 1;
                } else {
#line 213
                  tmp___10 = 0;
                }
              }
            } else {
#line 213
              tmp___10 = 0;
            }
          }
#line 213
          if (tmp___10) {
#line 213
            tmp___6 = __builtin_strcmp((char const   *)service, "ssh-connection");
          } else {
#line 213
            tmp___9 = __builtin_strcmp((char const   *)service, "ssh-connection");
#line 213
            tmp___6 = tmp___9;
          }
        } else {
#line 213
          tmp___9 = __builtin_strcmp((char const   *)service, "ssh-connection");
#line 213
          tmp___6 = tmp___9;
        }
#line 213
        if (tmp___6 == 0) {
#line 214
          authctxt->pw = pwcopy(pw);
#line 215
          authctxt->valid = 1;
#line 216
          debug2("input_userauth_request: setting up authctxt for %s", user);
#line 218
          start_pam(pw);
        } else {
#line 221
          log("input_userauth_request: illegal user %s", user);
        }
      } else {
#line 221
        log("input_userauth_request: illegal user %s", user);
      }
    } else {
#line 221
      log("input_userauth_request: illegal user %s", user);
    }
#line 223
    authctxt->user = xstrdup((char const   *)user);
#line 224
    authctxt->service = xstrdup((char const   *)service);
  } else {
#line 225
    if (authctxt->valid) {
#line 226
      if (0) {
#line 226
        __s1_len___0 = strlen((char const   *)user);
#line 226
        __s2_len___0 = strlen((char const   *)authctxt->user);
#line 226
        if (! ((unsigned int )((void const   *)(user + 1)) - (unsigned int )((void const   *)user) == 1U)) {
          goto _L___2;
        } else {
#line 226
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 226
            if (! ((unsigned int )((void const   *)(authctxt->user + 1)) - (unsigned int )((void const   *)authctxt->user) == 1U)) {
#line 226
              tmp___20 = 1;
            } else {
#line 226
              if (__s2_len___0 >= 4U) {
#line 226
                tmp___20 = 1;
              } else {
#line 226
                tmp___20 = 0;
              }
            }
          } else {
#line 226
            tmp___20 = 0;
          }
        }
#line 226
        if (tmp___20) {
#line 226
          tmp___16 = __builtin_strcmp((char const   *)user, (char const   *)authctxt->user);
        } else {
#line 226
          tmp___19 = __builtin_strcmp((char const   *)user, (char const   *)authctxt->user);
#line 226
          tmp___16 = tmp___19;
        }
      } else {
#line 226
        tmp___19 = __builtin_strcmp((char const   *)user, (char const   *)authctxt->user);
#line 226
        tmp___16 = tmp___19;
      }
#line 227
      if (tmp___16 != 0) {
#line 228
        log("input_userauth_request: missmatch: (%s,%s)!=(%s,%s)", user, service,
            authctxt->user, authctxt->service);
#line 230
        authctxt->valid = 0;
      } else {
#line 227
        if (0) {
#line 227
          __s1_len___1 = strlen((char const   *)service);
#line 227
          __s2_len___1 = strlen((char const   *)authctxt->service);
#line 227
          if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
            goto _L___4;
          } else {
#line 227
            if (__s1_len___1 >= 4U) {
              _L___4: /* CIL Label */ 
#line 227
              if (! ((unsigned int )((void const   *)(authctxt->service + 1)) - (unsigned int )((void const   *)authctxt->service) == 1U)) {
#line 227
                tmp___30 = 1;
              } else {
#line 227
                if (__s2_len___1 >= 4U) {
#line 227
                  tmp___30 = 1;
                } else {
#line 227
                  tmp___30 = 0;
                }
              }
            } else {
#line 227
              tmp___30 = 0;
            }
          }
#line 227
          if (tmp___30) {
#line 227
            tmp___26 = __builtin_strcmp((char const   *)service, (char const   *)authctxt->service);
          } else {
#line 227
            tmp___29 = __builtin_strcmp((char const   *)service, (char const   *)authctxt->service);
#line 227
            tmp___26 = tmp___29;
          }
        } else {
#line 227
          tmp___29 = __builtin_strcmp((char const   *)service, (char const   *)authctxt->service);
#line 227
          tmp___26 = tmp___29;
        }
#line 227
        if (tmp___26 != 0) {
#line 228
          log("input_userauth_request: missmatch: (%s,%s)!=(%s,%s)", user, service,
              authctxt->user, authctxt->service);
#line 230
          authctxt->valid = 0;
        }
      }
    }
  }
#line 234
  m___0 = authmethod_lookup((char const   *)method);
#line 235
  if ((unsigned int )m___0 != (unsigned int )((void *)0)) {
#line 236
    debug2("input_userauth_request: try method %s", method);
#line 237
    authenticated = (*(m___0->userauth))(authctxt);
  } else {
#line 239
    debug2("input_userauth_request: unsupported method %s", method);
  }
#line 241
  if (! authctxt->valid) {
#line 241
    if (authenticated == 1) {
#line 242
      log("input_userauth_request: INTERNAL ERROR: authenticated invalid user %s service %s",
          user, method);
#line 243
      authenticated = 0;
    }
  }
#line 247
  if (authenticated == 1) {
#line 247
    if (authctxt->valid) {
#line 247
      if ((authctxt->pw)->pw_uid == 0U) {
#line 247
        if (! options.permit_root_login) {
#line 249
          authenticated = 0;
#line 250
          tmp___31 = get_canonical_hostname();
#line 250
          log("ROOT LOGIN REFUSED FROM %.200s", tmp___31);
        }
      }
    }
  }
#line 254
  if (authenticated) {
#line 254
    if (authctxt->user) {
#line 254
      tmp___32 = do_pam_account(authctxt->user, (char *)((void *)0));
#line 254
      if (! tmp___32) {
#line 255
        authenticated = 0;
      }
    }
  }
#line 259
  userauth_log(authctxt, authenticated, method);
#line 260
  userauth_reply(authctxt, authenticated);
#line 262
  xfree((void *)service);
#line 263
  xfree((void *)user);
#line 264
  xfree((void *)method);
#line 265
  return;
}
}
#line 268 "auth2.c"
void userauth_log(Authctxt *authctxt , int authenticated , char *method ) 
{ void (*authlog)(char const   *fmt  , ...) ;
  char *user ;
  char *authmsg ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;

  {
#line 271
  authlog = (void (*)(char const   *fmt  , ...))(& verbose);
#line 272
  user = (char *)((void *)0);
#line 272
  authmsg = (char *)((void *)0);
#line 278
  if (authenticated == 1) {
#line 279
    authlog = (void (*)(char const   *fmt  , ...))(& log);
  } else {
#line 278
    if (! authctxt->valid) {
#line 279
      authlog = (void (*)(char const   *fmt  , ...))(& log);
    } else {
#line 278
      if (authctxt->attempt >= 3) {
#line 279
        authlog = (void (*)(char const   *fmt  , ...))(& log);
      } else {
#line 278
        if (0) {
#line 278
          __s1_len = strlen((char const   *)method);
#line 278
          __s2_len = strlen("password");
#line 278
          if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
            goto _L___0;
          } else {
#line 278
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 278
              if (! ((unsigned int )((void const   *)("password" + 1)) - (unsigned int )((void const   *)"password") == 1U)) {
#line 278
                tmp___8 = 1;
              } else {
#line 278
                if (__s2_len >= 4U) {
#line 278
                  tmp___8 = 1;
                } else {
#line 278
                  tmp___8 = 0;
                }
              }
            } else {
#line 278
              tmp___8 = 0;
            }
          }
#line 278
          if (tmp___8) {
#line 278
            tmp___4 = __builtin_strcmp((char const   *)method, "password");
          } else {
#line 278
            tmp___7 = __builtin_strcmp((char const   *)method, "password");
#line 278
            tmp___4 = tmp___7;
          }
        } else {
#line 278
          tmp___7 = __builtin_strcmp((char const   *)method, "password");
#line 278
          tmp___4 = tmp___7;
        }
#line 278
        if (tmp___4 == 0) {
#line 279
          authlog = (void (*)(char const   *fmt  , ...))(& log);
        }
      }
    }
  }
#line 281
  if (authenticated == 1) {
#line 282
    authmsg = (char *)"Accepted";
  } else {
#line 283
    if (authenticated == 0) {
#line 284
      authmsg = (char *)"Failed";
    } else {
#line 286
      authmsg = (char *)"Postponed";
    }
  }
#line 289
  if (authctxt->valid) {
#line 290
    if ((authctxt->pw)->pw_uid == 0U) {
#line 290
      user = (char *)"ROOT";
    } else {
#line 290
      user = authctxt->user;
    }
  } else {
#line 292
    user = (char *)"NOUSER";
  }
#line 295
  tmp___9 = get_remote_port();
#line 295
  tmp___10 = get_remote_ipaddr();
#line 295
  (*authlog)("%s %s for %.200s from %.200s port %d ssh2", authmsg, method, user, tmp___10,
             tmp___9);
#line 301
  return;
}
}
#line 303 "auth2.c"
void userauth_reply(Authctxt *authctxt , int authenticated ) 
{ char *methods ;
  char *tmp ;

  {
#line 307
  if (authenticated == 1) {
#line 315
    dispatch_set(50, & protocol_error);
#line 316
    packet_start(52);
#line 317
    packet_send();
#line 318
    packet_write_wait();
#line 320
    authctxt->success = 1;
  } else {
#line 321
    if (authenticated == 0) {
#line 322
      tmp = authmethods_get();
#line 322
      methods = tmp;
#line 323
      packet_start(51);
#line 324
      packet_put_cstring((char const   *)methods);
#line 325
      packet_put_char(0);
#line 326
      packet_send();
#line 327
      packet_write_wait();
#line 328
      xfree((void *)methods);
    }
  }
#line 332
  return;
}
}
#line 334 "auth2.c"
int userauth_none(Authctxt *authctxt ) 
{ Authmethod *m___0 ;
  Authmethod *tmp ;
  int _len ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 338
  tmp = authmethod_lookup("none");
#line 338
  m___0 = tmp;
#line 339
  if ((unsigned int )m___0 != (unsigned int )((void *)0)) {
#line 340
    m___0->enabled = (int *)((void *)0);
  }
#line 341
  while (1) {
#line 341
    tmp___0 = packet_remaining();
#line 341
    _len = tmp___0;
#line 341
    if (_len > 0) {
#line 341
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
          341);
#line 341
      packet_disconnect("Packet integrity error.");
    }
#line 341
    break;
  }
#line 343
  if (authctxt->valid == 0) {
#line 344
    return (0);
  }
#line 351
  tmp___1 = auth_pam_password(authctxt->pw, "");
#line 351
  return (tmp___1);
}
}
#line 361 "auth2.c"
int userauth_passwd(Authctxt *authctxt ) 
{ char *password ;
  int authenticated ;
  int change ;
  unsigned int len ;
  unsigned int tmp ;
  int _len ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 365
  authenticated = 0;
#line 368
  tmp = packet_get_char();
#line 368
  change = (int )tmp;
#line 369
  if (change) {
#line 370
    log("password change not supported");
  }
#line 371
  password = packet_get_string(& len);
#line 372
  while (1) {
#line 372
    tmp___0 = packet_remaining();
#line 372
    _len = tmp___0;
#line 372
    if (_len > 0) {
#line 372
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
          372);
#line 372
      packet_disconnect("Packet integrity error.");
    }
#line 372
    break;
  }
#line 373
  if (authctxt->valid) {
#line 373
    tmp___1 = auth_pam_password(authctxt->pw, (char const   *)password);
#line 373
    if (tmp___1 == 1) {
#line 386
      authenticated = 1;
    }
  }
#line 387
  memset((void *)password, 0, len);
#line 388
  xfree((void *)password);
#line 389
  return (authenticated);
}
}
#line 392 "auth2.c"
int userauth_kbdint(Authctxt *authctxt ) 
{ int authenticated ;
  char *lang ;
  char *devs ;
  int _len ;
  int tmp ;

  {
#line 395
  authenticated = 0;
#line 396
  lang = (char *)((void *)0);
#line 397
  devs = (char *)((void *)0);
#line 399
  lang = packet_get_string((unsigned int *)((void *)0));
#line 400
  devs = packet_get_string((unsigned int *)((void *)0));
#line 401
  while (1) {
#line 401
    tmp = packet_remaining();
#line 401
    _len = tmp;
#line 401
    if (_len > 0) {
#line 401
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
          401);
#line 401
      packet_disconnect("Packet integrity error.");
    }
#line 401
    break;
  }
#line 403
  debug("keyboard-interactive language %s devs %s", lang, devs);
#line 409
  xfree((void *)lang);
#line 410
  xfree((void *)devs);
#line 415
  return (authenticated);
}
}
#line 418 "auth2.c"
int userauth_pubkey(Authctxt *authctxt ) 
{ Buffer b ;
  Key *key ;
  char *pkalg ;
  char *pkblob ;
  char *sig ;
  unsigned int alen ;
  unsigned int blen ;
  unsigned int slen ;
  int have_sig ;
  int authenticated ;
  unsigned int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  int _len ;
  int tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  unsigned int tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int _len___0 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 426
  authenticated = 0;
#line 428
  if (! authctxt->valid) {
#line 429
    debug2("userauth_pubkey: disabled because of invalid user");
#line 430
    return (0);
  }
#line 432
  tmp = packet_get_char();
#line 432
  have_sig = (int )tmp;
#line 433
  pkalg = packet_get_string(& alen);
#line 434
  if (0) {
#line 434
    __s1_len = strlen((char const   *)pkalg);
#line 434
    __s2_len = strlen("ssh-dss");
#line 434
    if (! ((unsigned int )((void const   *)(pkalg + 1)) - (unsigned int )((void const   *)pkalg) == 1U)) {
      goto _L___0;
    } else {
#line 434
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 434
        if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
#line 434
          tmp___9 = 1;
        } else {
#line 434
          if (__s2_len >= 4U) {
#line 434
            tmp___9 = 1;
          } else {
#line 434
            tmp___9 = 0;
          }
        }
      } else {
#line 434
        tmp___9 = 0;
      }
    }
#line 434
    if (tmp___9) {
#line 434
      tmp___5 = __builtin_strcmp((char const   *)pkalg, "ssh-dss");
    } else {
#line 434
      tmp___8 = __builtin_strcmp((char const   *)pkalg, "ssh-dss");
#line 434
      tmp___5 = tmp___8;
    }
  } else {
#line 434
    tmp___8 = __builtin_strcmp((char const   *)pkalg, "ssh-dss");
#line 434
    tmp___5 = tmp___8;
  }
#line 434
  if (tmp___5 != 0) {
#line 435
    log("bad pkalg %s", pkalg);
#line 436
    xfree((void *)pkalg);
#line 437
    return (0);
  }
#line 439
  pkblob = packet_get_string(& blen);
#line 440
  key = dsa_key_from_blob(pkblob, (int )blen);
#line 441
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 442
    if (have_sig) {
#line 443
      sig = packet_get_string(& slen);
#line 444
      while (1) {
#line 444
        tmp___10 = packet_remaining();
#line 444
        _len = tmp___10;
#line 444
        if (_len > 0) {
#line 444
          log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
              444);
#line 444
          packet_disconnect("Packet integrity error.");
        }
#line 444
        break;
      }
#line 445
      buffer_init(& b);
#line 446
      if (datafellows & 16) {
#line 447
        buffer_append(& b, (char const   *)session_id2, (unsigned int )session_id2_len);
      } else {
#line 449
        buffer_put_string(& b, (void const   *)session_id2, (unsigned int )session_id2_len);
      }
#line 452
      buffer_put_char(& b, 50);
#line 453
      buffer_put_cstring(& b, (char const   *)authctxt->user);
#line 454
      if (datafellows & 2) {
#line 454
        tmp___11 = "ssh-userauth";
      } else {
#line 454
        tmp___11 = (char const   *)authctxt->service;
      }
#line 454
      buffer_put_cstring(& b, tmp___11);
#line 458
      buffer_put_cstring(& b, "publickey");
#line 459
      buffer_put_char(& b, have_sig);
#line 460
      buffer_put_cstring(& b, "ssh-dss");
#line 461
      buffer_put_string(& b, (void const   *)pkblob, blen);
#line 466
      tmp___12 = user_dsa_key_allowed(authctxt->pw, key);
#line 466
      if (tmp___12) {
#line 466
        tmp___13 = buffer_len(& b);
#line 466
        tmp___14 = buffer_ptr(& b);
#line 466
        tmp___15 = dsa_verify(key, (unsigned char *)sig, (int )slen, (unsigned char *)tmp___14,
                              (int )tmp___13);
#line 466
        if (tmp___15 == 1) {
#line 468
          authenticated = 1;
        }
      }
#line 469
      buffer_clear(& b);
#line 470
      xfree((void *)sig);
    } else {
#line 472
      debug("test whether pkalg/pkblob are acceptable");
#line 473
      while (1) {
#line 473
        tmp___16 = packet_remaining();
#line 473
        _len___0 = tmp___16;
#line 473
        if (_len___0 > 0) {
#line 473
          log("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "auth2.c",
              473);
#line 473
          packet_disconnect("Packet integrity error.");
        }
#line 473
        break;
      }
#line 483
      tmp___17 = user_dsa_key_allowed(authctxt->pw, key);
#line 483
      if (tmp___17) {
#line 484
        packet_start(60);
#line 485
        packet_put_string((char const   *)pkalg, alen);
#line 486
        packet_put_string((char const   *)pkblob, blen);
#line 487
        packet_send();
#line 488
        packet_write_wait();
#line 489
        authenticated = -1;
      }
    }
#line 492
    if (authenticated != 1) {
#line 493
      auth_clear_options();
    }
#line 494
    key_free(key);
  }
#line 496
  xfree((void *)pkalg);
#line 497
  xfree((void *)pkblob);
#line 502
  return (authenticated);
}
}
#line 507 "auth2.c"
struct passwd *auth_get_user(void) 
{ struct passwd *tmp ;

  {
#line 510
  if ((unsigned int )x_authctxt != (unsigned int )((void *)0)) {
#line 510
    if (x_authctxt->valid) {
#line 510
      tmp = x_authctxt->pw;
    } else {
#line 510
      tmp = (struct passwd *)((void *)0);
    }
  } else {
#line 510
    tmp = (struct passwd *)((void *)0);
  }
#line 510
  return (tmp);
}
}
#line 515 "auth2.c"
char *authmethods_get(void) 
{ Authmethod *method ;
  unsigned int size ;
  char *list ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___17 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 518
  method = (Authmethod *)((void *)0);
#line 519
  size = 0U;
#line 522
  method = authmethods;
#line 522
  while ((unsigned int )method->name != (unsigned int )((void *)0)) {
#line 523
    if (0) {
#line 523
      __s1_len = strlen((char const   *)method->name);
#line 523
      __s2_len = strlen("none");
#line 523
      if (! ((unsigned int )((void const   *)(method->name + 1)) - (unsigned int )((void const   *)method->name) == 1U)) {
        goto _L___0;
      } else {
#line 523
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 523
          if (! ((unsigned int )((void const   *)("none" + 1)) - (unsigned int )((void const   *)"none") == 1U)) {
#line 523
            tmp___8 = 1;
          } else {
#line 523
            if (__s2_len >= 4U) {
#line 523
              tmp___8 = 1;
            } else {
#line 523
              tmp___8 = 0;
            }
          }
        } else {
#line 523
          tmp___8 = 0;
        }
      }
#line 523
      if (tmp___8) {
#line 523
        tmp___4 = __builtin_strcmp((char const   *)method->name, "none");
      } else {
#line 523
        tmp___7 = __builtin_strcmp((char const   *)method->name, "none");
#line 523
        tmp___4 = tmp___7;
      }
    } else {
#line 523
      tmp___7 = __builtin_strcmp((char const   *)method->name, "none");
#line 523
      tmp___4 = tmp___7;
    }
#line 523
    if (tmp___4 == 0) {
      goto __Cont;
    }
#line 525
    if ((unsigned int )method->enabled != (unsigned int )((void *)0)) {
#line 525
      if (*(method->enabled) != 0) {
#line 526
        if (size != 0U) {
#line 527
          tmp___9 = strlen(",");
#line 527
          size += tmp___9;
        }
#line 528
        tmp___10 = strlen((char const   *)method->name);
#line 528
        size += tmp___10;
      }
    }
    __Cont: /* CIL Label */ 
#line 522
    method ++;
  }
#line 531
  size ++;
#line 532
  tmp___11 = xmalloc(size);
#line 532
  list = (char *)tmp___11;
#line 533
  *(list + 0) = (char )'\000';
#line 535
  method = authmethods;
#line 535
  while ((unsigned int )method->name != (unsigned int )((void *)0)) {
#line 536
    if (0) {
#line 536
      __s1_len___0 = strlen((char const   *)method->name);
#line 536
      __s2_len___0 = strlen("none");
#line 536
      if (! ((unsigned int )((void const   *)(method->name + 1)) - (unsigned int )((void const   *)method->name) == 1U)) {
        goto _L___2;
      } else {
#line 536
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 536
          if (! ((unsigned int )((void const   *)("none" + 1)) - (unsigned int )((void const   *)"none") == 1U)) {
#line 536
            tmp___21 = 1;
          } else {
#line 536
            if (__s2_len___0 >= 4U) {
#line 536
              tmp___21 = 1;
            } else {
#line 536
              tmp___21 = 0;
            }
          }
        } else {
#line 536
          tmp___21 = 0;
        }
      }
#line 536
      if (tmp___21) {
#line 536
        tmp___17 = __builtin_strcmp((char const   *)method->name, "none");
      } else {
#line 536
        tmp___20 = __builtin_strcmp((char const   *)method->name, "none");
#line 536
        tmp___17 = tmp___20;
      }
    } else {
#line 536
      tmp___20 = __builtin_strcmp((char const   *)method->name, "none");
#line 536
      tmp___17 = tmp___20;
    }
#line 536
    if (tmp___17 == 0) {
      goto __Cont___0;
    }
#line 538
    if ((unsigned int )method->enabled != (unsigned int )((void *)0)) {
#line 538
      if (*(method->enabled) != 0) {
#line 539
        if ((int )*(list + 0) != 0) {
#line 540
          strlcat(list, ",", size);
        }
#line 541
        strlcat(list, (char const   *)method->name, size);
      }
    }
    __Cont___0: /* CIL Label */ 
#line 535
    method ++;
  }
#line 544
  return (list);
}
}
#line 547 "auth2.c"
Authmethod *authmethod_lookup(char const   *name ) 
{ Authmethod *method ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;

  {
#line 550
  method = (Authmethod *)((void *)0);
#line 551
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 552
    method = authmethods;
#line 552
    while ((unsigned int )method->name != (unsigned int )((void *)0)) {
#line 555
      if ((unsigned int )method->enabled != (unsigned int )((void *)0)) {
#line 555
        if (*(method->enabled) != 0) {
#line 555
          if (0) {
#line 555
            __s1_len = strlen(name);
#line 555
            __s2_len = strlen((char const   *)method->name);
#line 555
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
              goto _L___0;
            } else {
#line 555
              if (__s1_len >= 4U) {
                _L___0: /* CIL Label */ 
#line 555
                if (! ((unsigned int )((void const   *)(method->name + 1)) - (unsigned int )((void const   *)method->name) == 1U)) {
#line 555
                  tmp___8 = 1;
                } else {
#line 555
                  if (__s2_len >= 4U) {
#line 555
                    tmp___8 = 1;
                  } else {
#line 555
                    tmp___8 = 0;
                  }
                }
              } else {
#line 555
                tmp___8 = 0;
              }
            }
#line 555
            if (tmp___8) {
#line 555
              tmp___4 = __builtin_strcmp(name, (char const   *)method->name);
            } else {
#line 555
              tmp___7 = __builtin_strcmp(name, (char const   *)method->name);
#line 555
              tmp___4 = tmp___7;
            }
          } else {
#line 555
            tmp___7 = __builtin_strcmp(name, (char const   *)method->name);
#line 555
            tmp___4 = tmp___7;
          }
#line 555
          if (tmp___4 == 0) {
#line 556
            return (method);
          }
        }
      }
#line 552
      method ++;
    }
  }
#line 557
  if (name) {
#line 557
    tmp___9 = name;
  } else {
#line 557
    tmp___9 = "NULL";
  }
#line 557
  debug2("Unrecognized authentication method name: %s", tmp___9);
#line 558
  return ((Authmethod *)((void *)0));
}
}
#line 611 "auth2.c"
static char const   *check___0[3]  = {      "",      ".ssh",      (char const   *)((void *)0)};
#line 562 "auth2.c"
int user_dsa_key_allowed(struct passwd *pw , Key *key ) 
{ char line[8192] ;
  char file[1024] ;
  int found_key ;
  unsigned int bits ;
  FILE *f ;
  unsigned long linenum ;
  struct stat st ;
  Key *found ;
  int tmp ;
  int fail ;
  char buf___1[1024] ;
  char *tmp___0 ;
  int i ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *cp ;
  char *options___0 ;
  int quoted ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;

  {
#line 566
  found_key = 0;
#line 567
  bits = 4294967295U;
#line 569
  linenum = 0UL;
#line 573
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 574
    return (0);
  }
#line 577
  temporarily_use_uid(pw->pw_uid);
#line 580
  snprintf((char * __restrict  )(file), sizeof(file), (char const   * __restrict  )"%.500s/%.100s",
           pw->pw_dir, ".ssh/authorized_keys2");
#line 584
  tmp = stat((char const   * __restrict  )(file), (struct stat * __restrict  )(& st));
#line 584
  if (tmp < 0) {
#line 586
    restore_uid();
#line 587
    return (0);
  }
#line 590
  f = fopen((char const   * __restrict  )(file), (char const   * __restrict  )"r");
#line 591
  if (! f) {
#line 593
    restore_uid();
#line 594
    return (0);
  }
#line 596
  if (options.strict_modes) {
#line 597
    fail = 0;
#line 600
    tmp___3 = fileno(f);
#line 600
    tmp___4 = fstat(tmp___3, & st);
#line 600
    if (tmp___4 < 0) {
#line 603
      tmp___0 = key_type(key);
#line 603
      snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%s authentication refused for %.100s: bad ownership or modes for \'%s\'.",
               tmp___0, pw->pw_name, file);
#line 607
      fail = 1;
    } else {
#line 600
      if (st.st_uid != 0U) {
#line 600
        if (st.st_uid != pw->pw_uid) {
#line 603
          tmp___0 = key_type(key);
#line 603
          snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%s authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   tmp___0, pw->pw_name, file);
#line 607
          fail = 1;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 600
        if ((st.st_mode & 18U) != 0U) {
#line 603
          tmp___0 = key_type(key);
#line 603
          snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%s authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   tmp___0, pw->pw_name, file);
#line 607
          fail = 1;
        } else {
#line 614
          i = 0;
#line 614
          while (check___0[i]) {
#line 615
            snprintf((char * __restrict  )(line), sizeof(line), (char const   * __restrict  )"%.500s/%.100s",
                     pw->pw_dir, check___0[i]);
#line 617
            tmp___2 = stat((char const   * __restrict  )(line), (struct stat * __restrict  )(& st));
#line 617
            if (tmp___2 < 0) {
#line 620
              tmp___1 = key_type(key);
#line 620
              snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%s authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                       tmp___1, pw->pw_name, line);
#line 624
              fail = 1;
#line 625
              break;
            } else {
#line 617
              if (st.st_uid != 0U) {
#line 617
                if (st.st_uid != pw->pw_uid) {
#line 620
                  tmp___1 = key_type(key);
#line 620
                  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%s authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           tmp___1, pw->pw_name, line);
#line 624
                  fail = 1;
#line 625
                  break;
                } else {
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
#line 617
                if ((st.st_mode & 18U) != 0U) {
#line 620
                  tmp___1 = key_type(key);
#line 620
                  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%s authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           tmp___1, pw->pw_name, line);
#line 624
                  fail = 1;
#line 625
                  break;
                }
              }
            }
#line 614
            i ++;
          }
        }
      }
    }
#line 629
    if (fail) {
#line 630
      fclose(f);
#line 631
      log("%s", buf___1);
#line 632
      restore_uid();
#line 633
      return (0);
    }
  }
#line 636
  found_key = 0;
#line 637
  found = key_new(key->type);
#line 639
  while (1) {
#line 639
    tmp___7 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 639
    if (! tmp___7) {
#line 639
      break;
    }
#line 640
    options___0 = (char *)((void *)0);
#line 641
    linenum ++;
#line 643
    cp = line;
#line 643
    while (1) {
#line 643
      if (! ((int )*cp == 32)) {
#line 643
        if (! ((int )*cp == 9)) {
#line 643
          break;
        }
      }
#line 643
      cp ++;
    }
#line 645
    if (! *cp) {
#line 646
      continue;
    } else {
#line 645
      if ((int )*cp == 10) {
#line 646
        continue;
      } else {
#line 645
        if ((int )*cp == 35) {
#line 646
          continue;
        }
      }
    }
#line 648
    bits = key_read(found, & cp);
#line 649
    if (bits == 0U) {
#line 651
      quoted = 0;
#line 652
      options___0 = cp;
#line 653
      while (1) {
#line 653
        if (*cp) {
#line 653
          if (! quoted) {
#line 653
            if ((int )*cp != 32) {
#line 653
              if (! ((int )*cp != 9)) {
#line 653
                break;
              }
            } else {
#line 653
              break;
            }
          }
        } else {
#line 653
          break;
        }
#line 654
        if ((int )*cp == 92) {
#line 654
          if ((int )*(cp + 1) == 34) {
#line 655
            cp ++;
          } else {
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
#line 656
          if ((int )*cp == 34) {
#line 657
            quoted = ! quoted;
          }
        }
#line 653
        cp ++;
      }
#line 660
      while (1) {
#line 660
        if (! ((int )*cp == 32)) {
#line 660
          if (! ((int )*cp == 9)) {
#line 660
            break;
          }
        }
#line 660
        cp ++;
      }
#line 662
      bits = key_read(found, & cp);
#line 663
      if (bits == 0U) {
#line 665
        continue;
      }
    }
#line 668
    tmp___5 = key_equal(found, key);
#line 668
    if (tmp___5) {
#line 668
      tmp___6 = auth_parse_options(pw, options___0, linenum);
#line 668
      if (tmp___6 == 1) {
#line 670
        found_key = 1;
#line 671
        debug("matching key found: file %s, line %ld", file, linenum);
#line 673
        break;
      }
    }
  }
#line 676
  restore_uid();
#line 677
  fclose(f);
#line 678
  key_free(found);
#line 679
  return (found_key);
}
}
#line 682 "auth2.c"
struct passwd *pwcopy(struct passwd *pw ) 
{ struct passwd *copy ;
  void *tmp ;

  {
#line 685
  tmp = xmalloc(sizeof(*copy));
#line 685
  copy = (struct passwd *)tmp;
#line 686
  memset((void *)copy, 0, sizeof(*copy));
#line 687
  copy->pw_name = xstrdup((char const   *)pw->pw_name);
#line 688
  copy->pw_passwd = xstrdup((char const   *)pw->pw_passwd);
#line 689
  copy->pw_uid = pw->pw_uid;
#line 690
  copy->pw_gid = pw->pw_gid;
#line 694
  copy->pw_dir = xstrdup((char const   *)pw->pw_dir);
#line 695
  copy->pw_shell = xstrdup((char const   *)pw->pw_shell);
#line 696
  return (copy);
}
}
#line 1 "auth-skey.o"
#line 1 "auth2-skey.o"
#line 1 "auth-rhosts.o"
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 418 "/usr/include/netdb.h"
extern int innetgr(char const   *__netgroup , char const   *__host , char const   *__user ,
                   char const   *domain ) ;
#line 31 "auth-rhosts.c"
int check_rhosts_file(char const   *filename , char const   *hostname , char const   *ipaddr ,
                      char const   *client_user , char const   *server_user ) 
{ FILE *f ;
  char buf___1[1024] ;
  char hostbuf[1024] ;
  char userbuf[1024] ;
  char dummy[1024] ;
  char *host ;
  char *user ;
  char *cp ;
  int negated ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___45 ;
  int tmp___48 ;
  int tmp___49 ;
  char *tmp___50 ;

  {
#line 40
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 41
  if (! f) {
#line 42
    return (0);
  }
#line 44
  while (1) {
#line 44
    tmp___50 = fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )f);
#line 44
    if (! tmp___50) {
#line 44
      break;
    }
#line 49
    cp = buf___1;
#line 49
    while (1) {
#line 49
      if (! ((int )*cp == 32)) {
#line 49
        if (! ((int )*cp == 9)) {
#line 49
          break;
        }
      }
#line 49
      cp ++;
    }
#line 51
    if ((int )*cp == 35) {
#line 52
      continue;
    } else {
#line 51
      if ((int )*cp == 10) {
#line 52
        continue;
      } else {
#line 51
        if (! *cp) {
#line 52
          continue;
        }
      }
    }
#line 58
    if (0) {
#line 58
      if (0) {
#line 58
        __s1_len___0 = strlen((char const   *)cp);
#line 58
        __s2_len___0 = strlen("NO_PLUS");
#line 58
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___2;
        } else {
#line 58
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 58
            if (! ((unsigned int )((void const   *)("NO_PLUS" + 1)) - (unsigned int )((void const   *)"NO_PLUS") == 1U)) {
#line 58
              tmp___22 = 1;
            } else {
#line 58
              if (__s2_len___0 >= 4U) {
#line 58
                tmp___22 = 1;
              } else {
#line 58
                tmp___22 = 0;
              }
            }
          } else {
#line 58
            tmp___22 = 0;
          }
        }
#line 58
        if (tmp___22) {
#line 58
          tmp___18 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
        } else {
#line 58
          tmp___21 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 58
          tmp___18 = tmp___21;
        }
      } else {
#line 58
        tmp___21 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 58
        tmp___18 = tmp___21;
      }
#line 58
      tmp___12 = tmp___18;
    } else {
#line 58
      tmp___12 = strncmp((char const   *)cp, "NO_PLUS", 7U);
    }
#line 58
    if (tmp___12 == 0) {
#line 59
      continue;
    }
#line 65
    tmp___25 = sscanf((char const   * __restrict  )(buf___1), (char const   * __restrict  )"%s %s %s",
                      hostbuf, userbuf, dummy);
#line 65
    switch (tmp___25) {
    case 0: 
#line 67
    packet_send_debug("Found empty line in %.100s.", filename);
#line 68
    continue;
    case 1: 
#line 71
    strlcpy(userbuf, server_user, sizeof(userbuf));
#line 72
    break;
    case 2: 
#line 75
    break;
    case 3: 
#line 77
    packet_send_debug("Found garbage in %.100s.", filename);
#line 78
    continue;
    default: ;
#line 81
    continue;
    }
#line 84
    host = hostbuf;
#line 85
    user = userbuf;
#line 86
    negated = 0;
#line 89
    if ((int )*(host + 0) == 45) {
#line 90
      negated = 1;
#line 91
      host ++;
    } else {
#line 92
      if ((int )*(host + 0) == 43) {
#line 93
        host ++;
      }
    }
#line 95
    if ((int )*(user + 0) == 45) {
#line 96
      negated = 1;
#line 97
      user ++;
    } else {
#line 98
      if ((int )*(user + 0) == 43) {
#line 99
        user ++;
      }
    }
#line 102
    if (! *(host + 0)) {
#line 104
      packet_send_debug("Ignoring wild host/user names in %.100s.", filename);
#line 106
      continue;
    } else {
#line 102
      if (! *(user + 0)) {
#line 104
        packet_send_debug("Ignoring wild host/user names in %.100s.", filename);
#line 106
        continue;
      }
    }
#line 109
    if ((int )*(host + 0) == 64) {
#line 110
      tmp___26 = innetgr((char const   *)(host + 1), hostname, (char const   *)((void *)0),
                         (char const   *)((void *)0));
#line 110
      if (! tmp___26) {
#line 110
        tmp___27 = innetgr((char const   *)(host + 1), ipaddr, (char const   *)((void *)0),
                           (char const   *)((void *)0));
#line 110
        if (! tmp___27) {
#line 112
          continue;
        }
      }
    } else {
#line 113
      tmp___28 = strcasecmp((char const   *)host, hostname);
#line 113
      if (tmp___28) {
#line 113
        if (0) {
#line 113
          __s1_len___1 = strlen((char const   *)host);
#line 113
          __s2_len___1 = strlen(ipaddr);
#line 113
          if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
            goto _L___4;
          } else {
#line 113
            if (__s1_len___1 >= 4U) {
              _L___4: /* CIL Label */ 
#line 113
              if (! ((unsigned int )((void const   *)(ipaddr + 1)) - (unsigned int )((void const   *)ipaddr) == 1U)) {
#line 113
                tmp___38 = 1;
              } else {
#line 113
                if (__s2_len___1 >= 4U) {
#line 113
                  tmp___38 = 1;
                } else {
#line 113
                  tmp___38 = 0;
                }
              }
            } else {
#line 113
              tmp___38 = 0;
            }
          }
#line 113
          if (tmp___38) {
#line 113
            tmp___34 = __builtin_strcmp((char const   *)host, ipaddr);
          } else {
#line 113
            tmp___37 = __builtin_strcmp((char const   *)host, ipaddr);
#line 113
            tmp___34 = tmp___37;
          }
        } else {
#line 113
          tmp___37 = __builtin_strcmp((char const   *)host, ipaddr);
#line 113
          tmp___34 = tmp___37;
        }
#line 113
        if (tmp___34 != 0) {
#line 114
          continue;
        }
      }
    }
#line 117
    if ((int )*(user + 0) == 64) {
#line 118
      tmp___39 = innetgr((char const   *)(user + 1), (char const   *)((void *)0),
                         client_user, (char const   *)((void *)0));
#line 118
      if (! tmp___39) {
#line 119
        continue;
      }
    } else {
#line 120
      if (0) {
#line 120
        __s1_len___2 = strlen((char const   *)user);
#line 120
        __s2_len___2 = strlen(client_user);
#line 120
        if (! ((unsigned int )((void const   *)(user + 1)) - (unsigned int )((void const   *)user) == 1U)) {
          goto _L___6;
        } else {
#line 120
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 120
            if (! ((unsigned int )((void const   *)(client_user + 1)) - (unsigned int )((void const   *)client_user) == 1U)) {
#line 120
              tmp___49 = 1;
            } else {
#line 120
              if (__s2_len___2 >= 4U) {
#line 120
                tmp___49 = 1;
              } else {
#line 120
                tmp___49 = 0;
              }
            }
          } else {
#line 120
            tmp___49 = 0;
          }
        }
#line 120
        if (tmp___49) {
#line 120
          tmp___45 = __builtin_strcmp((char const   *)user, client_user);
        } else {
#line 120
          tmp___48 = __builtin_strcmp((char const   *)user, client_user);
#line 120
          tmp___45 = tmp___48;
        }
      } else {
#line 120
        tmp___48 = __builtin_strcmp((char const   *)user, client_user);
#line 120
        tmp___45 = tmp___48;
      }
#line 120
      if (tmp___45 != 0) {
#line 121
        continue;
      }
    }
#line 124
    fclose(f);
#line 127
    if (negated) {
#line 128
      packet_send_debug("Matched negative entry in %.100s.", filename);
#line 130
      return (0);
    }
#line 133
    return (1);
  }
#line 137
  fclose(f);
#line 138
  return (0);
}
}
#line 154 "auth-rhosts.c"
static char const   *rhosts_files[3]  = {      ".shosts",      ".rhosts",      (char const   *)((void *)0)};
#line 147 "auth-rhosts.c"
int auth_rhosts(struct passwd *pw , char const   *client_user ) 
{ char buf___1[1024] ;
  char const   *hostname ;
  char const   *ipaddr ;
  struct stat st ;
  unsigned int rhosts_file_index ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 158
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 159
    return (0);
  }
#line 161
  temporarily_use_uid(pw->pw_uid);
#line 167
  rhosts_file_index = 0U;
#line 167
  while (rhosts_files[rhosts_file_index]) {
#line 170
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.500s/%.100s",
             pw->pw_dir, rhosts_files[rhosts_file_index]);
#line 172
    tmp = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )(& st));
#line 172
    if (tmp >= 0) {
#line 173
      break;
    }
#line 167
    rhosts_file_index ++;
  }
#line 176
  restore_uid();
#line 179
  if (! rhosts_files[rhosts_file_index]) {
#line 179
    tmp___0 = stat((char const   * __restrict  )"/etc/hosts.equiv", (struct stat * __restrict  )(& st));
#line 179
    if (tmp___0 < 0) {
#line 179
      tmp___1 = stat((char const   * __restrict  )"/usr/local/etc/shosts.equiv", (struct stat * __restrict  )(& st));
#line 179
      if (tmp___1 < 0) {
#line 182
        return (0);
      }
    }
  }
#line 184
  hostname = get_canonical_hostname();
#line 185
  ipaddr = get_remote_ipaddr();
#line 188
  if (pw->pw_uid != 0U) {
#line 189
    tmp___2 = check_rhosts_file("/etc/hosts.equiv", hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 189
    if (tmp___2) {
#line 191
      packet_send_debug("Accepted for %.100s [%.100s] by /etc/hosts.equiv.", hostname,
                        ipaddr);
#line 193
      return (1);
    }
#line 195
    tmp___3 = check_rhosts_file("/usr/local/etc/shosts.equiv", hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 195
    if (tmp___3) {
#line 197
      packet_send_debug("Accepted for %.100s [%.100s] by %.100s.", hostname, ipaddr,
                        "/usr/local/etc/shosts.equiv");
#line 199
      return (1);
    }
  }
#line 206
  tmp___4 = stat((char const   * __restrict  )pw->pw_dir, (struct stat * __restrict  )(& st));
#line 206
  if (tmp___4 < 0) {
#line 207
    log("Rhosts authentication refused for %.100s: no home directory %.200s", pw->pw_name,
        pw->pw_dir);
#line 209
    packet_send_debug("Rhosts authentication refused for %.100s: no home directory %.200s",
                      pw->pw_name, pw->pw_dir);
#line 211
    return (0);
  }
#line 213
  if (options.strict_modes) {
#line 213
    if (st.st_uid != 0U) {
#line 213
      if (st.st_uid != pw->pw_uid) {
#line 216
        log("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
            pw->pw_name);
#line 218
        packet_send_debug("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                          pw->pw_name);
#line 220
        return (0);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 213
      if ((st.st_mode & 18U) != 0U) {
#line 216
        log("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
            pw->pw_name);
#line 218
        packet_send_debug("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                          pw->pw_name);
#line 220
        return (0);
      }
    }
  }
#line 223
  temporarily_use_uid(pw->pw_uid);
#line 226
  rhosts_file_index = 0U;
#line 226
  while (rhosts_files[rhosts_file_index]) {
#line 229
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.500s/%.100s",
             pw->pw_dir, rhosts_files[rhosts_file_index]);
#line 231
    tmp___5 = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )(& st));
#line 231
    if (tmp___5 < 0) {
      goto __Cont;
    }
#line 240
    if (options.strict_modes) {
#line 240
      if (st.st_uid != 0U) {
#line 240
        if (st.st_uid != pw->pw_uid) {
#line 243
          log("Rhosts authentication refused for %.100s: bad modes for %.200s", pw->pw_name,
              buf___1);
#line 245
          packet_send_debug("Bad file modes for %.200s", buf___1);
          goto __Cont;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 240
        if ((st.st_mode & 18U) != 0U) {
#line 243
          log("Rhosts authentication refused for %.100s: bad modes for %.200s", pw->pw_name,
              buf___1);
#line 245
          packet_send_debug("Bad file modes for %.200s", buf___1);
          goto __Cont;
        }
      }
    }
#line 249
    if (options.ignore_rhosts) {
#line 250
      packet_send_debug("Server has been configured to ignore %.100s.", rhosts_files[rhosts_file_index]);
      goto __Cont;
    }
#line 255
    tmp___6 = check_rhosts_file((char const   *)(buf___1), hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 255
    if (tmp___6) {
#line 256
      packet_send_debug("Accepted by %.100s.", rhosts_files[rhosts_file_index]);
#line 259
      restore_uid();
#line 260
      return (1);
    }
    __Cont: /* CIL Label */ 
#line 226
    rhosts_file_index ++;
  }
#line 265
  restore_uid();
#line 266
  return (0);
}
}
#line 1 "auth-options.o"
#line 25 "auth-options.c"
int no_port_forwarding_flag  =    0;
#line 26 "auth-options.c"
int no_agent_forwarding_flag  =    0;
#line 27 "auth-options.c"
int no_x11_forwarding_flag  =    0;
#line 28 "auth-options.c"
int no_pty_flag  =    0;
#line 31 "auth-options.c"
char *forced_command  =    (char *)((void *)0);
#line 34 "auth-options.c"
struct envstring *custom_environment  =    (struct envstring *)((void *)0);
#line 36 "auth-options.c"
void auth_clear_options(void) 
{ struct envstring *ce ;

  {
#line 39
  no_agent_forwarding_flag = 0;
#line 40
  no_port_forwarding_flag = 0;
#line 41
  no_pty_flag = 0;
#line 42
  no_x11_forwarding_flag = 0;
#line 43
  while (custom_environment) {
#line 44
    ce = custom_environment;
#line 45
    custom_environment = ce->next;
#line 46
    xfree((void *)ce->s);
#line 47
    xfree((void *)ce);
  }
#line 49
  if (forced_command) {
#line 50
    xfree((void *)forced_command);
#line 51
    forced_command = (char *)((void *)0);
  }
#line 53
  return;
}
}
#line 56 "auth-options.c"
int auth_parse_options(struct passwd *pw , char *options___0 , unsigned long linenum ) 
{ char const   *cp ;
  size_t tmp ;
  int tmp___17 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___23 ;
  int tmp___26 ;
  int tmp___27 ;
  size_t tmp___28 ;
  size_t tmp___34 ;
  int tmp___52 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___58 ;
  int tmp___61 ;
  int tmp___62 ;
  size_t tmp___63 ;
  size_t tmp___69 ;
  int tmp___87 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___93 ;
  int tmp___96 ;
  int tmp___97 ;
  size_t tmp___98 ;
  size_t tmp___104 ;
  int tmp___122 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___128 ;
  int tmp___131 ;
  int tmp___132 ;
  size_t tmp___133 ;
  int i ;
  size_t tmp___139 ;
  size_t tmp___140 ;
  void *tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  char *tmp___144 ;
  int tmp___162 ;
  size_t __s1_len___8 ;
  size_t __s2_len___8 ;
  int tmp___168 ;
  int tmp___171 ;
  int tmp___172 ;
  size_t tmp___173 ;
  int i___0 ;
  char *s ;
  struct envstring *new_envstring ;
  size_t tmp___179 ;
  size_t tmp___180 ;
  void *tmp___181 ;
  int tmp___182 ;
  int tmp___183 ;
  char *tmp___184 ;
  void *tmp___185 ;
  int tmp___203 ;
  size_t __s1_len___10 ;
  size_t __s2_len___10 ;
  int tmp___209 ;
  int tmp___212 ;
  int tmp___213 ;
  size_t tmp___214 ;
  int mname ;
  int mip ;
  char *patterns ;
  size_t tmp___220 ;
  void *tmp___221 ;
  int i___1 ;
  size_t tmp___222 ;
  int tmp___223 ;
  int tmp___224 ;
  char *tmp___225 ;
  size_t tmp___226 ;
  char const   *tmp___227 ;
  size_t tmp___228 ;
  char const   *tmp___229 ;
  char const   *tmp___230 ;
  char const   *tmp___231 ;
  char const   *tmp___232 ;
  int tmp___250 ;
  size_t __s1_len___12 ;
  size_t __s2_len___12 ;
  int tmp___256 ;
  int tmp___259 ;
  int tmp___260 ;
  size_t tmp___261 ;

  {
#line 60
  if (! options___0) {
#line 61
    return (1);
  }
#line 64
  auth_clear_options();
#line 66
  while (1) {
#line 66
    if (*options___0) {
#line 66
      if ((int )*options___0 != 32) {
#line 66
        if (! ((int )*options___0 != 9)) {
#line 66
          break;
        }
      } else {
#line 66
        break;
      }
    } else {
#line 66
      break;
    }
#line 67
    cp = "no-port-forwarding";
#line 68
    if (0) {
#line 68
      if (0) {
#line 68
        __s1_len___0 = strlen((char const   *)options___0);
#line 68
        __s2_len___0 = strlen(cp);
#line 68
        if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
          goto _L___2;
        } else {
#line 68
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 68
            if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 68
              tmp___27 = 1;
            } else {
#line 68
              if (__s2_len___0 >= 4U) {
#line 68
                tmp___27 = 1;
              } else {
#line 68
                tmp___27 = 0;
              }
            }
          } else {
#line 68
            tmp___27 = 0;
          }
        }
#line 68
        if (tmp___27) {
#line 68
          tmp___23 = __builtin_strcmp((char const   *)options___0, cp);
        } else {
#line 68
          tmp___26 = __builtin_strcmp((char const   *)options___0, cp);
#line 68
          tmp___23 = tmp___26;
        }
      } else {
#line 68
        tmp___26 = __builtin_strcmp((char const   *)options___0, cp);
#line 68
        tmp___23 = tmp___26;
      }
#line 68
      tmp___17 = tmp___23;
    } else {
#line 68
      tmp___28 = strlen(cp);
#line 68
      tmp___17 = strncmp((char const   *)options___0, cp, tmp___28);
    }
#line 68
    if (tmp___17 == 0) {
#line 69
      packet_send_debug("Port forwarding disabled.");
#line 70
      no_port_forwarding_flag = 1;
#line 71
      tmp = strlen(cp);
#line 71
      options___0 += tmp;
      goto next_option;
    }
#line 74
    cp = "no-agent-forwarding";
#line 75
    if (0) {
#line 75
      if (0) {
#line 75
        __s1_len___2 = strlen((char const   *)options___0);
#line 75
        __s2_len___2 = strlen(cp);
#line 75
        if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
          goto _L___6;
        } else {
#line 75
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 75
            if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 75
              tmp___62 = 1;
            } else {
#line 75
              if (__s2_len___2 >= 4U) {
#line 75
                tmp___62 = 1;
              } else {
#line 75
                tmp___62 = 0;
              }
            }
          } else {
#line 75
            tmp___62 = 0;
          }
        }
#line 75
        if (tmp___62) {
#line 75
          tmp___58 = __builtin_strcmp((char const   *)options___0, cp);
        } else {
#line 75
          tmp___61 = __builtin_strcmp((char const   *)options___0, cp);
#line 75
          tmp___58 = tmp___61;
        }
      } else {
#line 75
        tmp___61 = __builtin_strcmp((char const   *)options___0, cp);
#line 75
        tmp___58 = tmp___61;
      }
#line 75
      tmp___52 = tmp___58;
    } else {
#line 75
      tmp___63 = strlen(cp);
#line 75
      tmp___52 = strncmp((char const   *)options___0, cp, tmp___63);
    }
#line 75
    if (tmp___52 == 0) {
#line 76
      packet_send_debug("Agent forwarding disabled.");
#line 77
      no_agent_forwarding_flag = 1;
#line 78
      tmp___34 = strlen(cp);
#line 78
      options___0 += tmp___34;
      goto next_option;
    }
#line 81
    cp = "no-X11-forwarding";
#line 82
    if (0) {
#line 82
      if (0) {
#line 82
        __s1_len___4 = strlen((char const   *)options___0);
#line 82
        __s2_len___4 = strlen(cp);
#line 82
        if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
          goto _L___10;
        } else {
#line 82
          if (__s1_len___4 >= 4U) {
            _L___10: /* CIL Label */ 
#line 82
            if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 82
              tmp___97 = 1;
            } else {
#line 82
              if (__s2_len___4 >= 4U) {
#line 82
                tmp___97 = 1;
              } else {
#line 82
                tmp___97 = 0;
              }
            }
          } else {
#line 82
            tmp___97 = 0;
          }
        }
#line 82
        if (tmp___97) {
#line 82
          tmp___93 = __builtin_strcmp((char const   *)options___0, cp);
        } else {
#line 82
          tmp___96 = __builtin_strcmp((char const   *)options___0, cp);
#line 82
          tmp___93 = tmp___96;
        }
      } else {
#line 82
        tmp___96 = __builtin_strcmp((char const   *)options___0, cp);
#line 82
        tmp___93 = tmp___96;
      }
#line 82
      tmp___87 = tmp___93;
    } else {
#line 82
      tmp___98 = strlen(cp);
#line 82
      tmp___87 = strncmp((char const   *)options___0, cp, tmp___98);
    }
#line 82
    if (tmp___87 == 0) {
#line 83
      packet_send_debug("X11 forwarding disabled.");
#line 84
      no_x11_forwarding_flag = 1;
#line 85
      tmp___69 = strlen(cp);
#line 85
      options___0 += tmp___69;
      goto next_option;
    }
#line 88
    cp = "no-pty";
#line 89
    if (0) {
#line 89
      if (0) {
#line 89
        __s1_len___6 = strlen((char const   *)options___0);
#line 89
        __s2_len___6 = strlen(cp);
#line 89
        if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
          goto _L___14;
        } else {
#line 89
          if (__s1_len___6 >= 4U) {
            _L___14: /* CIL Label */ 
#line 89
            if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 89
              tmp___132 = 1;
            } else {
#line 89
              if (__s2_len___6 >= 4U) {
#line 89
                tmp___132 = 1;
              } else {
#line 89
                tmp___132 = 0;
              }
            }
          } else {
#line 89
            tmp___132 = 0;
          }
        }
#line 89
        if (tmp___132) {
#line 89
          tmp___128 = __builtin_strcmp((char const   *)options___0, cp);
        } else {
#line 89
          tmp___131 = __builtin_strcmp((char const   *)options___0, cp);
#line 89
          tmp___128 = tmp___131;
        }
      } else {
#line 89
        tmp___131 = __builtin_strcmp((char const   *)options___0, cp);
#line 89
        tmp___128 = tmp___131;
      }
#line 89
      tmp___122 = tmp___128;
    } else {
#line 89
      tmp___133 = strlen(cp);
#line 89
      tmp___122 = strncmp((char const   *)options___0, cp, tmp___133);
    }
#line 89
    if (tmp___122 == 0) {
#line 90
      packet_send_debug("Pty allocation disabled.");
#line 91
      no_pty_flag = 1;
#line 92
      tmp___104 = strlen(cp);
#line 92
      options___0 += tmp___104;
      goto next_option;
    }
#line 95
    cp = "command=\"";
#line 96
    if (0) {
#line 96
      if (0) {
#line 96
        __s1_len___8 = strlen((char const   *)options___0);
#line 96
        __s2_len___8 = strlen(cp);
#line 96
        if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
          goto _L___18;
        } else {
#line 96
          if (__s1_len___8 >= 4U) {
            _L___18: /* CIL Label */ 
#line 96
            if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 96
              tmp___172 = 1;
            } else {
#line 96
              if (__s2_len___8 >= 4U) {
#line 96
                tmp___172 = 1;
              } else {
#line 96
                tmp___172 = 0;
              }
            }
          } else {
#line 96
            tmp___172 = 0;
          }
        }
#line 96
        if (tmp___172) {
#line 96
          tmp___168 = __builtin_strcmp((char const   *)options___0, cp);
        } else {
#line 96
          tmp___171 = __builtin_strcmp((char const   *)options___0, cp);
#line 96
          tmp___168 = tmp___171;
        }
      } else {
#line 96
        tmp___171 = __builtin_strcmp((char const   *)options___0, cp);
#line 96
        tmp___168 = tmp___171;
      }
#line 96
      tmp___162 = tmp___168;
    } else {
#line 96
      tmp___173 = strlen(cp);
#line 96
      tmp___162 = strncmp((char const   *)options___0, cp, tmp___173);
    }
#line 96
    if (tmp___162 == 0) {
#line 98
      tmp___139 = strlen(cp);
#line 98
      options___0 += tmp___139;
#line 99
      tmp___140 = strlen((char const   *)options___0);
#line 99
      tmp___141 = xmalloc(tmp___140 + 1U);
#line 99
      forced_command = (char *)tmp___141;
#line 100
      i = 0;
#line 101
      while (*options___0) {
#line 102
        if ((int )*options___0 == 34) {
#line 103
          break;
        }
#line 104
        if ((int )*options___0 == 92) {
#line 104
          if ((int )*(options___0 + 1) == 34) {
#line 105
            options___0 += 2;
#line 106
            tmp___142 = i;
#line 106
            i ++;
#line 106
            *(forced_command + tmp___142) = (char )'\"';
#line 107
            continue;
          }
        }
#line 109
        tmp___143 = i;
#line 109
        i ++;
#line 109
        tmp___144 = options___0;
#line 109
        options___0 ++;
#line 109
        *(forced_command + tmp___143) = *tmp___144;
      }
#line 111
      if (! *options___0) {
#line 112
        debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys", linenum);
#line 114
        packet_send_debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys",
                          linenum);
#line 116
        continue;
      }
#line 118
      *(forced_command + i) = (char)0;
#line 119
      packet_send_debug("Forced command: %.900s", forced_command);
#line 120
      options___0 ++;
      goto next_option;
    }
#line 123
    cp = "environment=\"";
#line 124
    if (0) {
#line 124
      if (0) {
#line 124
        __s1_len___10 = strlen((char const   *)options___0);
#line 124
        __s2_len___10 = strlen(cp);
#line 124
        if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
          goto _L___22;
        } else {
#line 124
          if (__s1_len___10 >= 4U) {
            _L___22: /* CIL Label */ 
#line 124
            if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 124
              tmp___213 = 1;
            } else {
#line 124
              if (__s2_len___10 >= 4U) {
#line 124
                tmp___213 = 1;
              } else {
#line 124
                tmp___213 = 0;
              }
            }
          } else {
#line 124
            tmp___213 = 0;
          }
        }
#line 124
        if (tmp___213) {
#line 124
          tmp___209 = __builtin_strcmp((char const   *)options___0, cp);
        } else {
#line 124
          tmp___212 = __builtin_strcmp((char const   *)options___0, cp);
#line 124
          tmp___209 = tmp___212;
        }
      } else {
#line 124
        tmp___212 = __builtin_strcmp((char const   *)options___0, cp);
#line 124
        tmp___209 = tmp___212;
      }
#line 124
      tmp___203 = tmp___209;
    } else {
#line 124
      tmp___214 = strlen(cp);
#line 124
      tmp___203 = strncmp((char const   *)options___0, cp, tmp___214);
    }
#line 124
    if (tmp___203 == 0) {
#line 128
      tmp___179 = strlen(cp);
#line 128
      options___0 += tmp___179;
#line 129
      tmp___180 = strlen((char const   *)options___0);
#line 129
      tmp___181 = xmalloc(tmp___180 + 1U);
#line 129
      s = (char *)tmp___181;
#line 130
      i___0 = 0;
#line 131
      while (*options___0) {
#line 132
        if ((int )*options___0 == 34) {
#line 133
          break;
        }
#line 134
        if ((int )*options___0 == 92) {
#line 134
          if ((int )*(options___0 + 1) == 34) {
#line 135
            options___0 += 2;
#line 136
            tmp___182 = i___0;
#line 136
            i___0 ++;
#line 136
            *(s + tmp___182) = (char )'\"';
#line 137
            continue;
          }
        }
#line 139
        tmp___183 = i___0;
#line 139
        i___0 ++;
#line 139
        tmp___184 = options___0;
#line 139
        options___0 ++;
#line 139
        *(s + tmp___183) = *tmp___184;
      }
#line 141
      if (! *options___0) {
#line 142
        debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys", linenum);
#line 144
        packet_send_debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys",
                          linenum);
#line 146
        continue;
      }
#line 148
      *(s + i___0) = (char)0;
#line 149
      packet_send_debug("Adding to environment: %.900s", s);
#line 150
      debug("Adding to environment: %.900s", s);
#line 151
      options___0 ++;
#line 152
      tmp___185 = xmalloc(sizeof(struct envstring ));
#line 152
      new_envstring = (struct envstring *)tmp___185;
#line 153
      new_envstring->s = s;
#line 154
      new_envstring->next = custom_environment;
#line 155
      custom_environment = new_envstring;
      goto next_option;
    }
#line 158
    cp = "from=\"";
#line 159
    if (0) {
#line 159
      if (0) {
#line 159
        __s1_len___12 = strlen((char const   *)options___0);
#line 159
        __s2_len___12 = strlen(cp);
#line 159
        if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
          goto _L___27;
        } else {
#line 159
          if (__s1_len___12 >= 4U) {
            _L___27: /* CIL Label */ 
#line 159
            if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 159
              tmp___260 = 1;
            } else {
#line 159
              if (__s2_len___12 >= 4U) {
#line 159
                tmp___260 = 1;
              } else {
#line 159
                tmp___260 = 0;
              }
            }
          } else {
#line 159
            tmp___260 = 0;
          }
        }
#line 159
        if (tmp___260) {
#line 159
          tmp___256 = __builtin_strcmp((char const   *)options___0, cp);
        } else {
#line 159
          tmp___259 = __builtin_strcmp((char const   *)options___0, cp);
#line 159
          tmp___256 = tmp___259;
        }
      } else {
#line 159
        tmp___259 = __builtin_strcmp((char const   *)options___0, cp);
#line 159
        tmp___256 = tmp___259;
      }
#line 159
      tmp___250 = tmp___256;
    } else {
#line 159
      tmp___261 = strlen(cp);
#line 159
      tmp___250 = strncmp((char const   *)options___0, cp, tmp___261);
    }
#line 159
    if (tmp___250 == 0) {
#line 161
      tmp___220 = strlen((char const   *)options___0);
#line 161
      tmp___221 = xmalloc(tmp___220 + 1U);
#line 161
      patterns = (char *)tmp___221;
#line 163
      tmp___222 = strlen(cp);
#line 163
      options___0 += tmp___222;
#line 164
      i___1 = 0;
#line 165
      while (*options___0) {
#line 166
        if ((int )*options___0 == 34) {
#line 167
          break;
        }
#line 168
        if ((int )*options___0 == 92) {
#line 168
          if ((int )*(options___0 + 1) == 34) {
#line 169
            options___0 += 2;
#line 170
            tmp___223 = i___1;
#line 170
            i___1 ++;
#line 170
            *(patterns + tmp___223) = (char )'\"';
#line 171
            continue;
          }
        }
#line 173
        tmp___224 = i___1;
#line 173
        i___1 ++;
#line 173
        tmp___225 = options___0;
#line 173
        options___0 ++;
#line 173
        *(patterns + tmp___224) = *tmp___225;
      }
#line 175
      if (! *options___0) {
#line 176
        debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys", linenum);
#line 178
        packet_send_debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys",
                          linenum);
#line 180
        continue;
      }
#line 182
      *(patterns + i___1) = (char)0;
#line 183
      options___0 ++;
#line 189
      tmp___226 = strlen((char const   *)patterns);
#line 189
      tmp___227 = get_canonical_hostname();
#line 189
      mname = match_hostname(tmp___227, (char const   *)patterns, tmp___226);
#line 191
      tmp___228 = strlen((char const   *)patterns);
#line 191
      tmp___229 = get_remote_ipaddr();
#line 191
      mip = match_hostname(tmp___229, (char const   *)patterns, tmp___228);
#line 193
      xfree((void *)patterns);
#line 194
      if (mname == -1) {
        goto _L___23;
      } else {
#line 194
        if (mip == -1) {
          goto _L___23;
        } else {
#line 194
          if (mname != 1) {
#line 194
            if (mip != 1) {
              _L___23: /* CIL Label */ 
#line 196
              tmp___230 = get_remote_ipaddr();
#line 196
              tmp___231 = get_canonical_hostname();
#line 196
              log("Authentication tried for %.100s with correct key but not from a permitted host (host=%.200s, ip=%.200s).",
                  pw->pw_name, tmp___231, tmp___230);
#line 199
              tmp___232 = get_canonical_hostname();
#line 199
              packet_send_debug("Your host \'%.200s\' is not permitted to use this key for login.",
                                tmp___232);
#line 202
              return (0);
            }
          }
        }
      }
      goto next_option;
    }
    next_option: 
#line 212
    if (! *options___0) {
#line 213
      fatal("Bugs in auth-options.c option processing.");
    }
#line 214
    if ((int )*options___0 == 32) {
#line 215
      break;
    } else {
#line 214
      if ((int )*options___0 == 9) {
#line 215
        break;
      }
    }
#line 216
    if ((int )*options___0 != 44) {
      goto bad_option;
    }
#line 218
    options___0 ++;
  }
#line 222
  return (1);
  bad_option: 
#line 225
  log("Bad options in %.100s file, line %lu: %.50s", ".ssh/authorized_keys", linenum,
      options___0);
#line 227
  packet_send_debug("Bad options in %.100s file, line %lu: %.50s", ".ssh/authorized_keys",
                    linenum, options___0);
#line 230
  return (0);
}
}
#line 1 "auth-krb4.o"
#line 1 "auth-pam.o"
#line 142 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 590
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 167 "/usr/include/security/_pam_types.h"
extern int __attribute__((__nonnull__(1)))  pam_set_item(pam_handle_t *pamh , int item_type ,
                                                         void const   *item ) ;
#line 173
extern char const   *pam_strerror(pam_handle_t *pamh , int errnum ) ;
#line 182
extern char ** __attribute__((__nonnull__(1))) pam_getenvlist(pam_handle_t *pamh ) ;
#line 22 "/usr/include/security/pam_appl.h"
extern int __attribute__((__nonnull__(1,3,4)))  pam_start(char const   *service_name ,
                                                          char const   *user , struct pam_conv  const  *pam_conversation ,
                                                          pam_handle_t **pamh ) ;
#line 27
extern int __attribute__((__nonnull__(1)))  pam_end(pam_handle_t *pamh , int pam_status ) ;
#line 32
extern int __attribute__((__nonnull__(1)))  pam_authenticate(pam_handle_t *pamh ,
                                                             int flags ) ;
#line 35
extern int __attribute__((__nonnull__(1)))  pam_setcred(pam_handle_t *pamh , int flags ) ;
#line 40
extern int __attribute__((__nonnull__(1)))  pam_acct_mgmt(pam_handle_t *pamh , int flags ) ;
#line 45
extern int __attribute__((__nonnull__(1)))  pam_open_session(pam_handle_t *pamh ,
                                                             int flags ) ;
#line 48
extern int __attribute__((__nonnull__(1)))  pam_close_session(pam_handle_t *pamh ,
                                                              int flags ) ;
#line 53
extern int __attribute__((__nonnull__(1)))  pam_chauthtok(pam_handle_t *pamh , int flags ) ;
#line 9 "auth-pam.h"
char **fetch_pam_environment(void) ;
#line 11
void do_pam_session(char *username , char const   *ttyname___0 ) ;
#line 12
void do_pam_setcred(void) ;
#line 13
void print_pam_messages(void) ;
#line 14
int pam_password_change_required(void) ;
#line 15
void do_pam_chauthtok(void) ;
#line 38 "auth-pam.c"
static int pamconv(int num_msg , struct pam_message  const  **msg , struct pam_response **resp ,
                   void *appdata_ptr ) ;
#line 40
void pam_cleanup_proc(void *context ) ;
#line 41
void pam_msg_cat(char const   *msg ) ;
#line 44 "auth-pam.c"
static struct pam_conv conv  =    {& pamconv, (void *)0};
#line 48 "auth-pam.c"
static pam_handle_t *pamh  =    (pam_handle_t *)((void *)0);
#line 49 "auth-pam.c"
static char const   *pampasswd  =    (char const   *)((void *)0);
#line 50 "auth-pam.c"
static char *pam_msg  =    (char *)((void *)0);
#line 54 "auth-pam.c"
static pamstates pamstate  =    0;
#line 56 "auth-pam.c"
static int password_change_required  =    0;
#line 71 "auth-pam.c"
static int pamconv(int num_msg , struct pam_message  const  **msg , struct pam_response **resp ,
                   void *appdata_ptr ) 
{ struct pam_response *reply ;
  int count ;
  char buf___1[1024] ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 79
  tmp = malloc((unsigned int )num_msg * sizeof(*reply));
#line 79
  reply = (struct pam_response *)tmp;
#line 80
  if ((unsigned int )reply == (unsigned int )((void *)0)) {
#line 81
    return (19);
  }
#line 83
  count = 0;
#line 83
  while (count < num_msg) {
#line 84
    switch ((int )(*msg + count)->msg_style) {
    case 2: 
#line 86
    if ((int )pamstate == 0) {
#line 87
      free((void *)reply);
#line 88
      return (19);
    } else {
#line 90
      fputs((char const   * __restrict  )(*msg + count)->msg, (FILE * __restrict  )stderr);
#line 91
      fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )stdin);
#line 92
      (reply + count)->resp = xstrdup((char const   *)(buf___1));
#line 93
      (reply + count)->resp_retcode = 0;
#line 94
      break;
    }
    case 1: 
#line 97
    if ((int )pamstate == 0) {
#line 98
      if ((unsigned int )pampasswd == (unsigned int )((void *)0)) {
#line 99
        free((void *)reply);
#line 100
        return (19);
      }
#line 102
      (reply + count)->resp = xstrdup(pampasswd);
    } else {
#line 104
      tmp___0 = read_passphrase((char *)(*msg + count)->msg, 1);
#line 104
      (reply + count)->resp = xstrdup((char const   *)tmp___0);
    }
#line 107
    (reply + count)->resp_retcode = 0;
#line 108
    break;
    case 3: 
    case 4: 
#line 111
    if ((unsigned int )(*msg + count)->msg != (unsigned int )((void *)0)) {
#line 112
      if ((int )pamstate == 0) {
#line 113
        pam_msg_cat((char const   *)(*msg + count)->msg);
      } else {
#line 115
        fputs((char const   * __restrict  )(*msg + count)->msg, (FILE * __restrict  )stderr);
#line 116
        fputs((char const   * __restrict  )"\n", (FILE * __restrict  )stderr);
      }
    }
#line 119
    (reply + count)->resp = xstrdup("");
#line 120
    (reply + count)->resp_retcode = 0;
#line 121
    break;
    default: 
#line 123
    free((void *)reply);
#line 124
    return (19);
    }
#line 83
    count ++;
  }
#line 128
  *resp = reply;
#line 130
  return (0);
}
}
#line 134 "auth-pam.c"
void pam_cleanup_proc(void *context ) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1)))  tmp ;
  char const   *tmp___0 ;
  int __attribute__((__nonnull__(1)))  tmp___1 ;
  char const   *tmp___2 ;
  int __attribute__((__nonnull__(1)))  tmp___3 ;
  char const   *tmp___4 ;

  {
#line 138
  if ((unsigned int )pamh != (unsigned int )((void *)0)) {
#line 140
    tmp = pam_close_session(pamh, 0);
#line 140
    pam_retval = (int )tmp;
#line 141
    if (pam_retval != 0) {
#line 142
      tmp___0 = pam_strerror(pamh, pam_retval);
#line 142
      log("Cannot close PAM session[%d]: %.200s", pam_retval, tmp___0);
    }
#line 146
    tmp___1 = pam_setcred(pamh, 4);
#line 146
    pam_retval = (int )tmp___1;
#line 147
    if (pam_retval != 0) {
#line 148
      tmp___2 = pam_strerror(pamh, pam_retval);
#line 148
      debug("Cannot delete credentials[%d]: %.200s", pam_retval, tmp___2);
    }
#line 152
    tmp___3 = pam_end(pamh, pam_retval);
#line 152
    pam_retval = (int )tmp___3;
#line 153
    if (pam_retval != 0) {
#line 154
      tmp___4 = pam_strerror(pamh, pam_retval);
#line 154
      log("Cannot release PAM authentication[%d]: %.200s", pam_retval, tmp___4);
    }
  }
#line 158
  return;
}
}
#line 161 "auth-pam.c"
int auth_pam_password(struct passwd *pw , char const   *password ) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1)))  tmp ;
  char const   *tmp___0 ;

  {
#line 167
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 168
    return (0);
  }
#line 169
  if (pw->pw_uid == 0U) {
#line 169
    if (options.permit_root_login == 2) {
#line 170
      return (0);
    }
  }
#line 171
  if ((int const   )*password == 0) {
#line 171
    if (options.permit_empty_passwd == 0) {
#line 172
      return (0);
    }
  }
#line 174
  pampasswd = password;
#line 176
  pamstate = 0;
#line 177
  tmp = pam_authenticate(pamh, 0);
#line 177
  pam_retval = (int )tmp;
#line 178
  if (pam_retval == 0) {
#line 179
    debug("PAM Password authentication accepted for user \"%.100s\"", pw->pw_name);
#line 181
    return (1);
  } else {
#line 183
    tmp___0 = pam_strerror(pamh, pam_retval);
#line 183
    debug("PAM Password authentication for \"%.100s\" failed[%d]: %s", pw->pw_name,
          pam_retval, tmp___0);
#line 185
    return (0);
  }
}
}
#line 190 "auth-pam.c"
int do_pam_account(char *username , char *remote_user ) 
{ int pam_retval ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int __attribute__((__nonnull__(1)))  tmp___1 ;
  char const   *tmp___2 ;
  int __attribute__((__nonnull__(1)))  tmp___3 ;
  char const   *tmp___4 ;
  int __attribute__((__nonnull__(1)))  tmp___5 ;
  char const   *tmp___6 ;

  {
#line 194
  tmp = get_canonical_hostname();
#line 194
  debug("PAM setting rhost to \"%.200s\"", tmp);
#line 195
  tmp___0 = get_canonical_hostname();
#line 195
  tmp___1 = pam_set_item(pamh, 4, (void const   *)tmp___0);
#line 195
  pam_retval = (int )tmp___1;
#line 197
  if (pam_retval != 0) {
#line 198
    tmp___2 = pam_strerror(pamh, pam_retval);
#line 198
    fatal("PAM set rhost failed[%d]: %.200s", pam_retval, tmp___2);
  }
#line 202
  if ((unsigned int )remote_user != (unsigned int )((void *)0)) {
#line 203
    debug("PAM setting ruser to \"%.200s\"", remote_user);
#line 204
    tmp___3 = pam_set_item(pamh, 8, (void const   *)remote_user);
#line 204
    pam_retval = (int )tmp___3;
#line 205
    if (pam_retval != 0) {
#line 206
      tmp___4 = pam_strerror(pamh, pam_retval);
#line 206
      fatal("PAM set ruser failed[%d]: %.200s", pam_retval, tmp___4);
    }
  }
#line 211
  tmp___5 = pam_acct_mgmt(pamh, 0);
#line 211
  pam_retval = (int )tmp___5;
#line 212
  switch (pam_retval) {
  case 0: 
#line 215
  break;
  case 12: 
#line 217
  pam_msg_cat("Warning: Your password has expired, please change it now");
#line 219
  password_change_required = 1;
#line 220
  break;
  default: 
#line 222
  tmp___6 = pam_strerror(pamh, pam_retval);
#line 222
  log("PAM rejected by account configuration[%d]: %.200s", pam_retval, tmp___6);
#line 224
  return (0);
  }
#line 227
  return (1);
}
}
#line 231 "auth-pam.c"
void do_pam_session(char *username , char const   *ttyname___0 ) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1)))  tmp ;
  char const   *tmp___0 ;
  int __attribute__((__nonnull__(1)))  tmp___1 ;
  char const   *tmp___2 ;

  {
#line 235
  if ((unsigned int )ttyname___0 != (unsigned int )((void *)0)) {
#line 236
    debug("PAM setting tty to \"%.200s\"", ttyname___0);
#line 237
    tmp = pam_set_item(pamh, 3, (void const   *)ttyname___0);
#line 237
    pam_retval = (int )tmp;
#line 238
    if (pam_retval != 0) {
#line 239
      tmp___0 = pam_strerror(pamh, pam_retval);
#line 239
      fatal("PAM set tty failed[%d]: %.200s", pam_retval, tmp___0);
    }
  }
#line 244
  tmp___1 = pam_open_session(pamh, 0);
#line 244
  pam_retval = (int )tmp___1;
#line 245
  if (pam_retval != 0) {
#line 246
    tmp___2 = pam_strerror(pamh, pam_retval);
#line 246
    fatal("PAM session setup failed[%d]: %.200s", pam_retval, tmp___2);
  }
#line 249
  return;
}
}
#line 252 "auth-pam.c"
void do_pam_setcred(void) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1)))  tmp ;
  char const   *tmp___0 ;

  {
#line 256
  debug("PAM establishing creds");
#line 257
  tmp = pam_setcred(pamh, 2);
#line 257
  pam_retval = (int )tmp;
#line 258
  if (pam_retval != 0) {
#line 259
    tmp___0 = pam_strerror(pamh, pam_retval);
#line 259
    fatal("PAM setcred failed[%d]: %.200s", pam_retval, tmp___0);
  }
#line 262
  return;
}
}
#line 265 "auth-pam.c"
int pam_password_change_required(void) 
{ 

  {
#line 267
  return (password_change_required);
}
}
#line 276 "auth-pam.c"
void do_pam_chauthtok(void) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1)))  tmp ;
  char const   *tmp___0 ;

  {
#line 280
  if (password_change_required) {
#line 281
    pamstate = 1;
#line 285
    while (1) {
#line 286
      tmp = pam_chauthtok(pamh, 32);
#line 286
      pam_retval = (int )tmp;
#line 287
      if (pam_retval != 0) {
#line 288
        tmp___0 = pam_strerror(pamh, pam_retval);
#line 288
        log("PAM pam_chauthtok failed[%d]: %.200s", pam_retval, tmp___0);
      }
#line 285
      if (! (pam_retval != 0)) {
#line 285
        break;
      }
    }
  }
#line 293
  return;
}
}
#line 296 "auth-pam.c"
void finish_pam(void) 
{ 

  {
#line 298
  pam_cleanup_proc((void *)0);
#line 299
  fatal_remove_cleanup(& pam_cleanup_proc, (void *)0);
#line 300
  return;
}
}
#line 303 "auth-pam.c"
void start_pam(struct passwd *pw ) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1,3,4)))  tmp ;
  char const   *tmp___0 ;
  int __attribute__((__nonnull__(1)))  tmp___1 ;
  char const   *tmp___2 ;

  {
#line 307
  debug("Starting up PAM with username \"%.200s\"", pw->pw_name);
#line 309
  tmp = pam_start("sshd", (char const   *)pw->pw_name, (struct pam_conv  const  *)(& conv),
                  & pamh);
#line 309
  pam_retval = (int )tmp;
#line 311
  if (pam_retval != 0) {
#line 312
    tmp___0 = pam_strerror(pamh, pam_retval);
#line 312
    fatal("PAM initialisation failed[%d]: %.200s", pam_retval, tmp___0);
  }
#line 324
  tmp___1 = pam_set_item(pamh, 3, (void const   *)"ssh");
#line 324
  pam_retval = (int )tmp___1;
#line 325
  if (pam_retval != 0) {
#line 326
    tmp___2 = pam_strerror(pamh, pam_retval);
#line 326
    fatal("PAM set tty failed[%d]: %.200s", pam_retval, tmp___2);
  }
#line 331
  fatal_add_cleanup(& pam_cleanup_proc, (void *)0);
#line 332
  return;
}
}
#line 335 "auth-pam.c"
char **fetch_pam_environment(void) 
{ char ** __attribute__((__nonnull__(1))) tmp ;

  {
#line 338
  tmp = pam_getenvlist(pamh);
#line 338
  return ((char **)tmp);
}
}
#line 346 "auth-pam.c"
void print_pam_messages(void) 
{ 

  {
#line 348
  if ((unsigned int )pam_msg != (unsigned int )((void *)0)) {
#line 349
    fputs((char const   * __restrict  )pam_msg, (FILE * __restrict  )stderr);
  }
#line 350
  return;
}
}
#line 353 "auth-pam.c"
void pam_msg_cat(char const   *msg ) 
{ char *p ;
  size_t new_msg_len ;
  size_t pam_msg_len ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 359
  new_msg_len = strlen(msg);
#line 361
  if (pam_msg) {
#line 362
    pam_msg_len = strlen((char const   *)pam_msg);
#line 363
    tmp = xrealloc((void *)pam_msg, (new_msg_len + pam_msg_len) + 2U);
#line 363
    pam_msg = (char *)tmp;
#line 364
    p = pam_msg + pam_msg_len;
  } else {
#line 366
    tmp___0 = xmalloc(new_msg_len + 2U);
#line 366
    p = (char *)tmp___0;
#line 366
    pam_msg = p;
  }
#line 369
  memcpy((void * __restrict  )p, (void const   * __restrict  )msg, new_msg_len);
#line 370
  *(p + new_msg_len) = (char )'\n';
#line 371
  *(p + (new_msg_len + 1U)) = (char )'\000';
#line 372
  return;
}
}
#line 1 "auth-passwd.o"
#line 1 "auth-rsa.o"
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 212
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 401 "/usr/include/openssl/bn.h"
extern int BN_rand(BIGNUM *rnd , int bits , int top , int bottom ) ;
#line 412 "ssh.h"
int auth_rsa_challenge_dialog(RSA *pk ) ;
#line 58 "auth-rsa.c"
int auth_rsa_challenge_dialog(RSA *pk ) 
{ BIGNUM *challenge ;
  BIGNUM *encrypted_challenge ;
  BN_CTX *ctx ;
  unsigned char buf___1[32] ;
  unsigned char mdbuf[16] ;
  unsigned char response[16] ;
  MD5_CTX md ;
  unsigned int i ;
  int plen ;
  int len ;
  int _p ;
  int _e ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 68
  encrypted_challenge = BN_new();
#line 69
  challenge = BN_new();
#line 72
  BN_rand(challenge, 256, 0, 0);
#line 73
  ctx = BN_CTX_new();
#line 74
  BN_div((BIGNUM *)((void *)0), challenge, (BIGNUM const   *)challenge, (BIGNUM const   *)pk->n,
         ctx);
#line 75
  BN_CTX_free(ctx);
#line 78
  rsa_public_encrypt(encrypted_challenge, challenge, pk);
#line 81
  packet_start(7);
#line 82
  packet_put_bignum(encrypted_challenge);
#line 83
  packet_send();
#line 84
  BN_clear_free(encrypted_challenge);
#line 85
  packet_write_wait();
#line 88
  packet_read_expect(& plen, 8);
#line 89
  while (1) {
#line 89
    _p = plen;
#line 89
    _e = 16;
#line 89
    if (_p != _e) {
#line 89
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "auth-rsa.c", 89);
#line 89
      packet_disconnect("Packet integrity error. (%d)", 8);
    }
#line 89
    break;
  }
#line 90
  i = 0U;
#line 90
  while (i < 16U) {
#line 91
    tmp = packet_get_char();
#line 91
    response[i] = (unsigned char )tmp;
#line 90
    i ++;
  }
#line 94
  tmp___0 = BN_num_bits((BIGNUM const   *)challenge);
#line 94
  len = (tmp___0 + 7) / 8;
#line 95
  if (len <= 0) {
#line 96
    fatal("auth_rsa_challenge_dialog: bad challenge length %d", len);
  } else {
#line 95
    if (len > 32) {
#line 96
      fatal("auth_rsa_challenge_dialog: bad challenge length %d", len);
    }
  }
#line 97
  memset((void *)(buf___1), 0, 32U);
#line 98
  BN_bn2bin((BIGNUM const   *)challenge, (buf___1 + 32) - len);
#line 99
  MD5_Init(& md);
#line 100
  MD5_Update(& md, (void const   *)(buf___1), 32U);
#line 101
  MD5_Update(& md, (void const   *)(session_id), 16U);
#line 102
  MD5_Final(mdbuf, & md);
#line 103
  BN_clear_free(challenge);
#line 106
  tmp___1 = memcmp((void const   *)(response), (void const   *)(mdbuf), 16U);
#line 106
  if (tmp___1 != 0) {
#line 108
    return (0);
  }
#line 111
  return (1);
}
}
#line 170 "auth-rsa.c"
static char const   *check___1[3]  = {      "",      ".ssh",      (char const   *)((void *)0)};
#line 120 "auth-rsa.c"
int auth_rsa(struct passwd *pw , BIGNUM *client_n ) 
{ char line[8192] ;
  char file[1024] ;
  int authenticated ;
  unsigned int bits ;
  FILE *f ;
  unsigned long linenum ;
  struct stat st ;
  RSA *pk ;
  int tmp ;
  int fail ;
  char buf___1[1024] ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *cp ;
  char *options___0 ;
  int quoted ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;

  {
#line 127
  linenum = 0UL;
#line 132
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 133
    return (0);
  }
#line 136
  temporarily_use_uid(pw->pw_uid);
#line 139
  snprintf((char * __restrict  )(file), sizeof(file), (char const   * __restrict  )"%.500s/%.100s",
           pw->pw_dir, ".ssh/authorized_keys");
#line 143
  tmp = stat((char const   * __restrict  )(file), (struct stat * __restrict  )(& st));
#line 143
  if (tmp < 0) {
#line 145
    restore_uid();
#line 146
    return (0);
  }
#line 149
  f = fopen((char const   * __restrict  )(file), (char const   * __restrict  )"r");
#line 150
  if (! f) {
#line 152
    restore_uid();
#line 153
    packet_send_debug("Could not open %.900s for reading.", file);
#line 154
    packet_send_debug("If your home is on an NFS volume, it may need to be world-readable.");
#line 155
    return (0);
  }
#line 157
  if (options.strict_modes) {
#line 158
    fail = 0;
#line 161
    tmp___1 = fileno(f);
#line 161
    tmp___2 = fstat(tmp___1, & st);
#line 161
    if (tmp___2 < 0) {
#line 164
      snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
               pw->pw_name, file);
#line 166
      fail = 1;
    } else {
#line 161
      if (st.st_uid != 0U) {
#line 161
        if (st.st_uid != pw->pw_uid) {
#line 164
          snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   pw->pw_name, file);
#line 166
          fail = 1;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 161
        if ((st.st_mode & 18U) != 0U) {
#line 164
          snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   pw->pw_name, file);
#line 166
          fail = 1;
        } else {
#line 173
          i = 0;
#line 173
          while (check___1[i]) {
#line 174
            snprintf((char * __restrict  )(line), sizeof(line), (char const   * __restrict  )"%.500s/%.100s",
                     pw->pw_dir, check___1[i]);
#line 175
            tmp___0 = stat((char const   * __restrict  )(line), (struct stat * __restrict  )(& st));
#line 175
            if (tmp___0 < 0) {
#line 178
              snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                       pw->pw_name, line);
#line 180
              fail = 1;
#line 181
              break;
            } else {
#line 175
              if (st.st_uid != 0U) {
#line 175
                if (st.st_uid != pw->pw_uid) {
#line 178
                  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           pw->pw_name, line);
#line 180
                  fail = 1;
#line 181
                  break;
                } else {
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
#line 175
                if ((st.st_mode & 18U) != 0U) {
#line 178
                  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           pw->pw_name, line);
#line 180
                  fail = 1;
#line 181
                  break;
                }
              }
            }
#line 173
            i ++;
          }
        }
      }
    }
#line 185
    if (fail) {
#line 186
      fclose(f);
#line 187
      log("%s", buf___1);
#line 188
      packet_send_debug("%s", buf___1);
#line 189
      restore_uid();
#line 190
      return (0);
    }
  }
#line 194
  authenticated = 0;
#line 196
  pk = RSA_new();
#line 197
  pk->e = BN_new();
#line 198
  pk->n = BN_new();
#line 205
  while (1) {
#line 205
    tmp___9 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 205
    if (! tmp___9) {
#line 205
      break;
    }
#line 209
    linenum ++;
#line 212
    cp = line;
#line 212
    while (1) {
#line 212
      if (! ((int )*cp == 32)) {
#line 212
        if (! ((int )*cp == 9)) {
#line 212
          break;
        }
      }
#line 212
      cp ++;
    }
#line 214
    if (! *cp) {
#line 215
      continue;
    } else {
#line 214
      if ((int )*cp == 10) {
#line 215
        continue;
      } else {
#line 214
        if ((int )*cp == 35) {
#line 215
          continue;
        }
      }
    }
#line 223
    if ((int )*cp < 48) {
      goto _L___2;
    } else {
#line 223
      if ((int )*cp > 57) {
        _L___2: /* CIL Label */ 
#line 224
        quoted = 0;
#line 225
        options___0 = cp;
#line 226
        while (1) {
#line 226
          if (*cp) {
#line 226
            if (! quoted) {
#line 226
              if ((int )*cp != 32) {
#line 226
                if (! ((int )*cp != 9)) {
#line 226
                  break;
                }
              } else {
#line 226
                break;
              }
            }
          } else {
#line 226
            break;
          }
#line 227
          if ((int )*cp == 92) {
#line 227
            if ((int )*(cp + 1) == 34) {
#line 228
              cp ++;
            } else {
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
#line 229
            if ((int )*cp == 34) {
#line 230
              quoted = ! quoted;
            }
          }
#line 226
          cp ++;
        }
      } else {
#line 233
        options___0 = (char *)((void *)0);
      }
    }
#line 238
    tmp___3 = auth_parse_options(pw, options___0, linenum);
#line 238
    if (! tmp___3) {
#line 239
      continue;
    }
#line 242
    tmp___4 = auth_rsa_read_key(& cp, & bits, pk->e, pk->n);
#line 242
    if (! tmp___4) {
#line 243
      debug("%.100s, line %lu: bad key syntax", ".ssh/authorized_keys", linenum);
#line 245
      packet_send_debug("%.100s, line %lu: bad key syntax", ".ssh/authorized_keys",
                        linenum);
#line 247
      continue;
    }
#line 252
    tmp___5 = BN_cmp((BIGNUM const   *)pk->n, (BIGNUM const   *)client_n);
#line 252
    if (tmp___5 != 0) {
#line 253
      continue;
    }
#line 256
    tmp___7 = BN_num_bits((BIGNUM const   *)pk->n);
#line 256
    if (bits != (unsigned int )tmp___7) {
#line 257
      tmp___6 = BN_num_bits((BIGNUM const   *)pk->n);
#line 257
      log("Warning: %s, line %ld: keysize mismatch: actual %d vs. announced %d.",
          file, linenum, tmp___6, bits);
    }
#line 264
    tmp___8 = auth_rsa_challenge_dialog(pk);
#line 264
    if (! tmp___8) {
#line 266
      verbose("Wrong response to RSA authentication challenge.");
#line 267
      packet_send_debug("Wrong response to RSA authentication challenge.");
#line 268
      continue;
    }
#line 278
    authenticated = 1;
#line 279
    break;
  }
#line 283
  restore_uid();
#line 286
  fclose(f);
#line 288
  RSA_free(pk);
#line 290
  if (authenticated) {
#line 291
    packet_send_debug("RSA authentication accepted.");
  } else {
#line 293
    auth_clear_options();
  }
#line 296
  return (authenticated);
}
}
#line 1 "auth-rh-rsa.o"
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 34 "auth-rh-rsa.c"
int auth_rhosts_rsa(struct passwd *pw , char const   *client_user , RSA *client_host_key ) 
{ char const   *canonical_hostname ;
  HostStatus host_status ;
  Key *client_key ;
  Key *found ;
  int tmp ;
  struct stat st ;
  char *user_hostfile ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 42
  debug("Trying rhosts with RSA host authentication for client user %.100s", client_user);
#line 44
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 45
    return (0);
  } else {
#line 44
    if ((unsigned int )client_host_key == (unsigned int )((void *)0)) {
#line 45
      return (0);
    }
  }
#line 48
  tmp = auth_rhosts(pw, client_user);
#line 48
  if (! tmp) {
#line 49
    return (0);
  }
#line 51
  canonical_hostname = get_canonical_hostname();
#line 53
  debug("Rhosts RSA authentication: canonical host %.900s", canonical_hostname);
#line 56
  client_key = key_new(0);
#line 57
  BN_copy((client_key->rsa)->e, (BIGNUM const   *)client_host_key->e);
#line 58
  BN_copy((client_key->rsa)->n, (BIGNUM const   *)client_host_key->n);
#line 59
  found = key_new(0);
#line 62
  host_status = check_host_in_hostfile("/usr/local/etc/ssh_known_hosts", canonical_hostname,
                                       client_key, found);
#line 66
  if ((int )host_status != 0) {
#line 66
    if (! options.ignore_user_known_hosts) {
#line 68
      tmp___0 = tilde_expand_filename("~/.ssh/known_hosts", pw->pw_uid);
#line 68
      user_hostfile = tmp___0;
#line 73
      if (options.strict_modes) {
#line 73
        tmp___1 = stat((char const   * __restrict  )user_hostfile, (struct stat * __restrict  )(& st));
#line 73
        if (tmp___1 == 0) {
#line 73
          if (st.st_uid != 0U) {
#line 73
            if (st.st_uid != pw->pw_uid) {
#line 77
              log("Rhosts RSA authentication refused for %.100s: bad owner or modes for %.200s",
                  pw->pw_name, user_hostfile);
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 73
            if ((st.st_mode & 18U) != 0U) {
#line 77
              log("Rhosts RSA authentication refused for %.100s: bad owner or modes for %.200s",
                  pw->pw_name, user_hostfile);
            } else {
#line 81
              temporarily_use_uid(pw->pw_uid);
#line 82
              host_status = check_host_in_hostfile((char const   *)user_hostfile,
                                                   canonical_hostname, client_key,
                                                   found);
#line 84
              restore_uid();
            }
          }
        } else {
#line 81
          temporarily_use_uid(pw->pw_uid);
#line 82
          host_status = check_host_in_hostfile((char const   *)user_hostfile, canonical_hostname,
                                               client_key, found);
#line 84
          restore_uid();
        }
      } else {
#line 81
        temporarily_use_uid(pw->pw_uid);
#line 82
        host_status = check_host_in_hostfile((char const   *)user_hostfile, canonical_hostname,
                                             client_key, found);
#line 84
        restore_uid();
      }
#line 86
      xfree((void *)user_hostfile);
    }
  }
#line 88
  key_free(client_key);
#line 89
  key_free(found);
#line 91
  if ((int )host_status != 0) {
#line 92
    debug("Rhosts with RSA host authentication denied: unknown or invalid host key");
#line 93
    packet_send_debug("Your host key cannot be verified: unknown or invalid host key.");
#line 94
    return (0);
  }
#line 99
  tmp___2 = auth_rsa_challenge_dialog(client_host_key);
#line 99
  if (! tmp___2) {
#line 100
    log("Client on %.800s failed to respond correctly to host authentication.", canonical_hostname);
#line 102
    return (0);
  }
#line 109
  verbose("Rhosts with RSA host authentication accepted for %.100s, %.100s on %.700s.",
          pw->pw_name, client_user, canonical_hostname);
#line 111
  packet_send_debug("Rhosts with RSA host authentication accepted.");
#line 112
  return (1);
}
}
#line 1 "dh.o"
#line 747 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 458 "/usr/include/openssl/bn.h"
extern void BN_free(BIGNUM *a ) ;
#line 39 "dh.c"
int parse_prime(int linenum , char *line , struct dhgroup *dhg ) 
{ char *cp ;
  char *arg ;
  char *strsize ;
  char *gen___0 ;
  char *prime ;
  char *tmp___14 ;
  char *tmp___30 ;
  char *tmp___46 ;
  char *tmp___62 ;
  char *tmp___78 ;
  char *tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;

  {
#line 45
  cp = line;
#line 46
  arg = strdelim(& cp);
#line 48
  if ((int )*arg == 0) {
#line 49
    arg = strdelim(& cp);
  }
#line 50
  if (! *arg) {
#line 51
    return (0);
  } else {
#line 50
    if ((int )*arg == 35) {
#line 51
      return (0);
    }
  }
#line 54
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 54
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 56
  tmp___14 = __strsep_g(& cp, " ");
#line 56
  arg = tmp___14;
#line 57
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 57
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 59
  tmp___30 = __strsep_g(& cp, " ");
#line 59
  arg = tmp___30;
#line 60
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 60
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 62
  tmp___46 = __strsep_g(& cp, " ");
#line 62
  arg = tmp___46;
#line 63
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 63
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 65
  tmp___62 = __strsep_g(& cp, " ");
#line 65
  strsize = tmp___62;
#line 66
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 66
    if ((int )*strsize == 0) {
      goto fail;
    } else {
#line 66
      dhg->size = atoi((char const   *)strsize);
#line 66
      if (dhg->size == 0) {
        goto fail;
      }
    }
  }
#line 69
  tmp___78 = __strsep_g(& cp, " ");
#line 69
  gen___0 = tmp___78;
#line 70
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 70
    if ((int )*gen___0 == 0) {
      goto fail;
    }
  }
#line 72
  tmp___94 = __strsep_g(& cp, " ");
#line 72
  prime = tmp___94;
#line 73
  if ((unsigned int )cp != (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 73
    if ((int )*prime == 0) {
      goto fail;
    }
  }
#line 76
  dhg->g = BN_new();
#line 77
  tmp___95 = BN_hex2bn(& dhg->g, (char const   *)gen___0);
#line 77
  if (tmp___95 < 0) {
#line 78
    BN_free(dhg->g);
    goto fail;
  }
#line 81
  dhg->p = BN_new();
#line 82
  tmp___96 = BN_hex2bn(& dhg->p, (char const   *)prime);
#line 82
  if (tmp___96 < 0) {
#line 83
    BN_free(dhg->g);
#line 84
    BN_free(dhg->p);
    goto fail;
  }
#line 88
  return (1);
  fail: 
#line 90
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad prime description in line %d\n",
          linenum);
#line 91
  return (0);
}
}
#line 94 "dh.c"
DH *choose_dh(int minbits ) 
{ FILE *f ;
  char line[1024] ;
  int best ;
  int bestcount ;
  int which ;
  int linenum ;
  struct dhgroup dhg ;
  DH *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  DH *tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  DH *tmp___7 ;

  {
#line 103
  f = fopen((char const   * __restrict  )"/usr/local/etc/primes", (char const   * __restrict  )"r");
#line 104
  if (! f) {
#line 105
    perror("/usr/local/etc/primes");
#line 106
    log("WARNING: %s does not exist, using old prime", "/usr/local/etc/primes");
#line 107
    tmp = dh_new_group1();
#line 107
    return (tmp);
  }
#line 110
  linenum = 0;
#line 111
  bestcount = 0;
#line 111
  best = bestcount;
#line 112
  while (1) {
#line 112
    tmp___1 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 112
    if (! tmp___1) {
#line 112
      break;
    }
#line 113
    linenum ++;
#line 114
    tmp___0 = parse_prime(linenum, line, & dhg);
#line 114
    if (! tmp___0) {
#line 115
      continue;
    }
#line 116
    BN_free(dhg.g);
#line 117
    BN_free(dhg.p);
#line 119
    if (dhg.size > minbits) {
#line 119
      if (dhg.size < best) {
#line 121
        best = dhg.size;
#line 122
        bestcount = 0;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 119
      if (dhg.size > best) {
#line 119
        if (best < minbits) {
#line 121
          best = dhg.size;
#line 122
          bestcount = 0;
        }
      }
    }
#line 124
    if (dhg.size == best) {
#line 125
      bestcount ++;
    }
  }
#line 127
  fclose(f);
#line 129
  if (bestcount == 0) {
#line 130
    log("WARNING: no primes in %s, using old prime", "/usr/local/etc/primes");
#line 131
    tmp___2 = dh_new_group1();
#line 131
    return (tmp___2);
  }
#line 134
  f = fopen((char const   * __restrict  )"/usr/local/etc/primes", (char const   * __restrict  )"r");
#line 135
  if (! f) {
#line 136
    perror("/usr/local/etc/primes");
#line 137
    exit(1);
  }
#line 140
  linenum = 0;
#line 141
  tmp___3 = arc4random();
#line 141
  which = (int )(tmp___3 % (unsigned int )bestcount);
#line 142
  while (1) {
#line 142
    tmp___6 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 142
    if (! tmp___6) {
#line 142
      break;
    }
#line 143
    tmp___4 = parse_prime(linenum, line, & dhg);
#line 143
    if (! tmp___4) {
#line 144
      continue;
    }
#line 145
    if (dhg.size != best) {
#line 146
      continue;
    }
#line 147
    tmp___5 = linenum;
#line 147
    linenum ++;
#line 147
    if (tmp___5 != which) {
#line 148
      BN_free(dhg.g);
#line 149
      BN_free(dhg.p);
#line 150
      continue;
    }
#line 152
    break;
  }
#line 154
  fclose(f);
#line 156
  tmp___7 = dh_new_group(dhg.g, dhg.p);
#line 156
  return (tmp___7);
}
}
#line 1 "pty.o"
#line 280 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 433 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group )  __attribute__((__nonnull__(1))) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 872
extern  __attribute__((__nothrow__)) int vhangup(void) ;
#line 109 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 26 "pty.h"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) ;
#line 32
void pty_release(char const   *ttyname___0 ) ;
#line 38
void pty_make_controlling_tty(int *ttyfd , char const   *ttyname___0 ) ;
#line 41
void pty_change_window_size(int ptyfd , int row , int col , int xpixel , int ypixel ) ;
#line 45
void pty_setowner(struct passwd *pw , char const   *ttyname___0 ) ;
#line 55 "pty.c"
extern int ( /* missing proto */  openpty)() ;
#line 47 "pty.c"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) 
{ char buf___1[64] ;
  int i ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 55
  i = openpty(ptyfd, ttyfd, buf___1, (void *)0, (void *)0);
#line 56
  if (i < 0) {
#line 57
    tmp = __errno_location();
#line 57
    tmp___0 = strerror(*tmp);
#line 57
    error("openpty: %.100s", tmp___0);
#line 58
    return (0);
  }
#line 60
  strlcpy(namebuf, (char const   *)(buf___1), (unsigned int )namebuflen);
#line 61
  return (1);
}
}
#line 199 "pty.c"
void pty_release(char const   *ttyname___0 ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 202
  tmp___1 = chown(ttyname___0, 0U, 0U);
#line 202
  if (tmp___1 < 0) {
#line 203
    tmp = __errno_location();
#line 203
    tmp___0 = strerror(*tmp);
#line 203
    error("chown %.100s 0 0 failed: %.100s", ttyname___0, tmp___0);
  }
#line 204
  tmp___4 = chmod(ttyname___0, 438U);
#line 204
  if (tmp___4 < 0) {
#line 205
    tmp___2 = __errno_location();
#line 205
    tmp___3 = strerror(*tmp___2);
#line 205
    error("chmod %.100s 0666 failed: %.100s", ttyname___0, tmp___3);
  }
#line 206
  return;
}
}
#line 210 "pty.c"
void pty_make_controlling_tty(int *ttyfd , char const   *ttyname___0 ) 
{ int fd ;
  void *old ;
  int *tmp ;
  char *tmp___0 ;
  __pid_t tmp___1 ;
  __sighandler_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
#line 220
  fd = open("/dev/tty", 258);
#line 221
  if (fd >= 0) {
#line 222
    ioctl(fd, 21538UL, (void *)0);
#line 223
    close(fd);
  }
#line 226
  tmp___1 = setsid();
#line 226
  if (tmp___1 < 0) {
#line 227
    tmp = __errno_location();
#line 227
    tmp___0 = strerror(*tmp);
#line 227
    error("setsid: %.100s", tmp___0);
  }
#line 233
  fd = open("/dev/tty", 258);
#line 234
  if (fd >= 0) {
#line 235
    error("Failed to disconnect from controlling tty.");
#line 236
    close(fd);
  }
#line 240
  debug("Setting controlling tty using TIOCSCTTY.");
#line 246
  ioctl(*ttyfd, 21518UL, (void *)0);
#line 253
  tmp___2 = signal(1, (void (*)(int  ))1);
#line 253
  old = (void *)tmp___2;
#line 254
  vhangup();
#line 255
  signal(1, (void (*)(int  ))old);
#line 257
  fd = open(ttyname___0, 2);
#line 258
  if (fd < 0) {
#line 259
    tmp___3 = __errno_location();
#line 259
    tmp___4 = strerror(*tmp___3);
#line 259
    error("%.100s: %.100s", ttyname___0, tmp___4);
  } else {
#line 262
    close(*ttyfd);
#line 263
    *ttyfd = fd;
  }
#line 269
  fd = open("/dev/tty", 1);
#line 270
  if (fd < 0) {
#line 271
    tmp___5 = __errno_location();
#line 271
    tmp___6 = strerror(*tmp___5);
#line 271
    error("open /dev/tty failed - could not set controlling tty: %.100s", tmp___6);
  } else {
#line 274
    close(fd);
  }
#line 276
  return;
}
}
#line 280 "pty.c"
void pty_change_window_size(int ptyfd , int row , int col , int xpixel , int ypixel ) 
{ struct winsize w ;

  {
#line 285
  w.ws_row = (unsigned short )row;
#line 286
  w.ws_col = (unsigned short )col;
#line 287
  w.ws_xpixel = (unsigned short )xpixel;
#line 288
  w.ws_ypixel = (unsigned short )ypixel;
#line 289
  ioctl(ptyfd, 21524UL, & w);
#line 290
  return;
}
}
#line 292 "pty.c"
void pty_setowner(struct passwd *pw , char const   *ttyname___0 ) 
{ struct group *grp ;
  gid_t gid ;
  mode_t mode ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 300
  grp = getgrnam("tty");
#line 301
  if (grp) {
#line 302
    gid = grp->gr_gid;
#line 303
    mode = (unsigned int )(384 | (128 >> 3));
  } else {
#line 305
    gid = pw->pw_gid;
#line 306
    mode = (unsigned int )((384 | (128 >> 3)) | ((128 >> 3) >> 3));
  }
#line 310
  tmp___1 = chown(ttyname___0, pw->pw_uid, gid);
#line 310
  if (tmp___1 < 0) {
#line 311
    tmp = __errno_location();
#line 311
    tmp___0 = strerror(*tmp);
#line 311
    fatal("chown(%.100s, %d, %d) failed: %.100s", ttyname___0, pw->pw_uid, gid, tmp___0);
  }
#line 313
  tmp___4 = chmod(ttyname___0, mode);
#line 313
  if (tmp___4 < 0) {
#line 314
    tmp___2 = __errno_location();
#line 314
    tmp___3 = strerror(*tmp___2);
#line 314
    fatal("chmod(%.100s, 0%o) failed: %.100s", ttyname___0, mode, tmp___3);
  }
#line 316
  return;
}
}
#line 1 "log-server.o"
#line 175 "/usr/include/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 47 "log-server.c"
extern char *__progname ;
#line 52 "log-server.c"
static LogLevel log_level  =    3;
#line 53 "log-server.c"
static int log_on_stderr  =    0;
#line 54 "log-server.c"
static int log_facility  =    4 << 3;
#line 62 "log-server.c"
void log_init(char *av0___0 , LogLevel level , SyslogFacility facility , int on_stderr ) 
{ 

  {
#line 65
  switch ((int )level) {
  case 0: 
  case 2: 
  case 1: 
  case 3: 
  case 4: 
  case 5: 
  case 6: 
  case 7: 
#line 74
  log_level = level;
#line 75
  break;
  default: 
#line 77
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized internal syslog level code %d\n",
          (int )level);
#line 79
  exit(1);
  }
#line 81
  switch ((int )facility) {
  case 0: 
#line 83
  log_facility = 3 << 3;
#line 84
  break;
  case 1: 
#line 86
  log_facility = 1 << 3;
#line 87
  break;
  case 2: 
#line 89
  log_facility = 4 << 3;
#line 90
  break;
  case 3: 
#line 92
  log_facility = 16 << 3;
#line 93
  break;
  case 4: 
#line 95
  log_facility = 17 << 3;
#line 96
  break;
  case 5: 
#line 98
  log_facility = 18 << 3;
#line 99
  break;
  case 6: 
#line 101
  log_facility = 19 << 3;
#line 102
  break;
  case 7: 
#line 104
  log_facility = 20 << 3;
#line 105
  break;
  case 8: 
#line 107
  log_facility = 21 << 3;
#line 108
  break;
  case 9: 
#line 110
  log_facility = 22 << 3;
#line 111
  break;
  case 10: 
#line 113
  log_facility = 23 << 3;
#line 114
  break;
  default: 
#line 116
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized internal syslog facility code %d\n",
          (int )facility);
#line 118
  exit(1);
  }
#line 120
  log_on_stderr = on_stderr;
#line 121
  return;
}
}
#line 125 "log-server.c"
void do_log(LogLevel level , char const   *fmt , va_list args ) 
{ char msgbuf[1024] ;
  char fmtbuf[1024] ;
  char *txt ;
  int pri ;

  {
#line 130
  txt = (char *)((void *)0);
#line 131
  pri = 6;
#line 133
  if ((int )level > (int )log_level) {
#line 134
    return;
  }
#line 135
  switch ((int )level) {
  case 2: 
#line 137
  txt = (char *)"error";
#line 138
  pri = 3;
#line 139
  break;
  case 1: 
#line 141
  txt = (char *)"fatal";
#line 142
  pri = 3;
#line 143
  break;
  case 3: 
  case 4: 
#line 146
  pri = 6;
#line 147
  break;
  case 5: 
#line 149
  txt = (char *)"debug1";
#line 150
  pri = 7;
#line 151
  break;
  case 6: 
#line 153
  txt = (char *)"debug2";
#line 154
  pri = 7;
#line 155
  break;
  case 7: 
#line 157
  txt = (char *)"debug3";
#line 158
  pri = 7;
#line 159
  break;
  default: 
#line 161
  txt = (char *)"internal error";
#line 162
  pri = 3;
#line 163
  break;
  }
#line 165
  if ((unsigned int )txt != (unsigned int )((void *)0)) {
#line 166
    snprintf((char * __restrict  )(fmtbuf), sizeof(fmtbuf), (char const   * __restrict  )"%s: %s",
             txt, fmt);
#line 167
    vsnprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )(fmtbuf),
              args);
  } else {
#line 169
    vsnprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )fmt,
              args);
  }
#line 171
  if (log_on_stderr) {
#line 172
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n", msgbuf);
  } else {
#line 174
    openlog((char const   *)__progname, 1, log_facility);
#line 175
    syslog(pri, "%.500s", msgbuf);
#line 176
    closelog();
  }
#line 178
  return;
}
}
#line 1 "login.o"
#line 100 "loginrec.h"
struct logininfo *login_alloc_entry(int pid , char const   *username , char const   *hostname ,
                                    char const   *line ) ;
#line 103
void login_free_entry(struct logininfo *li ) ;
#line 111
int login_login(struct logininfo *li ) ;
#line 112
int login_logout(struct logininfo *li ) ;
#line 121
void login_set_addr(struct logininfo *li , struct sockaddr  const  *sa , unsigned int sa_size ) ;
#line 128
struct logininfo *login_get_lastlog(struct logininfo *li , int uid ) ;
#line 52 "login.c"
unsigned long get_last_login_time(uid_t uid , char const   *logname , char *buf___1 ,
                                  unsigned int bufsize ) 
{ struct logininfo li ;

  {
#line 58
  login_get_lastlog(& li, (int )uid);
#line 59
  strlcpy(buf___1, (char const   *)(li.hostname), bufsize);
#line 60
  return ((unsigned long )li.tv_sec);
}
}
#line 68 "login.c"
void record_login(pid_t pid , char const   *ttyname___0 , char const   *user , uid_t uid ,
                  char const   *host , struct sockaddr *addr ) 
{ struct logininfo *li ;

  {
#line 74
  li = login_alloc_entry(pid, user, host, ttyname___0);
#line 75
  login_set_addr(li, (struct sockaddr  const  *)addr, sizeof(struct sockaddr ));
#line 76
  login_login(li);
#line 77
  login_free_entry(li);
#line 78
  return;
}
}
#line 82 "login.c"
void record_logout(pid_t pid , char const   *ttyname___0 ) 
{ struct logininfo *li ;

  {
#line 87
  li = login_alloc_entry(pid, (char const   *)((void *)0), (char const   *)((void *)0),
                         ttyname___0);
#line 88
  login_logout(li);
#line 89
  login_free_entry(li);
#line 90
  return;
}
}
#line 1 "loginrec.o"
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval * __restrict  __tv ,
                                                      __timezone_ptr_t __tz )  __attribute__((__nonnull__(1))) ;
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 46 "/usr/include/utmp.h"
extern  __attribute__((__nothrow__)) void login(struct utmp  const  *__entry ) ;
#line 49
extern  __attribute__((__nothrow__)) int logout(char const   *__ut_line ) ;
#line 52
extern  __attribute__((__nothrow__)) void logwtmp(char const   *__ut_line , char const   *__ut_name ,
                                                  char const   *__ut_host ) ;
#line 105 "loginrec.h"
int login_init_entry(struct logininfo *li , int pid , char const   *username , char const   *hostname ,
                     char const   *line ) ;
#line 108
void login_set_current_time(struct logininfo *li ) ;
#line 117
int login_write(struct logininfo *li ) ;
#line 130
unsigned int login_get_lastlog_time(int uid ) ;
#line 133
char *line_fullname(char *dst , char const   *src , int dstsize ) ;
#line 134
char *line_stripname(char *dst , char const   *src , int dstsize ) ;
#line 135
char *line_abbrevname(char *dst , char const   *src , int dstsize ) ;
#line 171 "loginrec.c"
void set_utmp_time(struct logininfo *li , struct utmp *ut ) ;
#line 172
void construct_utmp(struct logininfo *li , struct utmp *ut ) ;
#line 184
int lastlog_write_entry(struct logininfo *li ) ;
#line 185
int syslogin_write_entry(struct logininfo *li ) ;
#line 187
int getlast_entry(struct logininfo *li ) ;
#line 188
int lastlog_get_entry(struct logininfo *li ) ;
#line 208 "loginrec.c"
int login_login(struct logininfo *li ) 
{ int tmp ;

  {
#line 211
  li->type = (short)7;
#line 212
  tmp = login_write(li);
#line 212
  return (tmp);
}
}
#line 224 "loginrec.c"
int login_logout(struct logininfo *li ) 
{ int tmp ;

  {
#line 227
  li->type = (short)8;
#line 228
  tmp = login_write(li);
#line 228
  return (tmp);
}
}
#line 248 "loginrec.c"
unsigned int login_get_lastlog_time(int uid ) 
{ struct logininfo li ;
  struct logininfo *tmp ;

  {
#line 253
  tmp = login_get_lastlog(& li, uid);
#line 253
  if (tmp) {
#line 254
    return (li.tv_sec);
  } else {
#line 256
    return (0U);
  }
}
}
#line 272 "loginrec.c"
struct logininfo *login_get_lastlog(struct logininfo *li , int uid ) 
{ struct passwd *pw ;
  int tmp ;

  {
#line 277
  memset((void *)li, '\000', sizeof(*li));
#line 278
  li->uid = uid;
#line 285
  pw = getpwuid((unsigned int )uid);
#line 286
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 287
    fatal("login_get_lastlog: Cannot find account for uid %i", uid);
  }
#line 291
  strlcpy(li->username, (char const   *)pw->pw_name, sizeof(li->username));
#line 293
  tmp = getlast_entry(li);
#line 293
  if (tmp) {
#line 294
    return (li);
  } else {
#line 296
    return ((struct logininfo *)((void *)0));
  }
}
}
#line 309 "loginrec.c"
struct logininfo *login_alloc_entry(int pid , char const   *username , char const   *hostname ,
                                    char const   *line ) 
{ struct logininfo *newli ;
  void *tmp ;

  {
#line 315
  tmp = xmalloc(sizeof(*newli));
#line 315
  newli = (struct logininfo *)tmp;
#line 316
  login_init_entry(newli, pid, username, hostname, line);
#line 317
  return (newli);
}
}
#line 322 "loginrec.c"
void login_free_entry(struct logininfo *li ) 
{ 

  {
#line 325
  xfree((void *)li);
#line 326
  return;
}
}
#line 337 "loginrec.c"
int login_init_entry(struct logininfo *li , int pid , char const   *username , char const   *hostname ,
                     char const   *line ) 
{ struct passwd *pw ;

  {
#line 343
  memset((void *)li, 0, sizeof(*li));
#line 345
  li->pid = pid;
#line 348
  if (line) {
#line 349
    line_fullname(li->line, line, (int )sizeof(li->line));
  }
#line 351
  if (username) {
#line 352
    strlcpy(li->username, username, sizeof(li->username));
#line 353
    pw = getpwnam((char const   *)(li->username));
#line 354
    if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 355
      fatal("login_init_entry: Cannot find user \"%s\"", li->username);
    }
#line 356
    li->uid = (int )pw->pw_uid;
  }
#line 359
  if (hostname) {
#line 360
    strlcpy(li->hostname, hostname, sizeof(li->hostname));
  }
#line 362
  return (1);
}
}
#line 371 "loginrec.c"
void login_set_current_time(struct logininfo *li ) 
{ struct timeval tv ;

  {
#line 376
  gettimeofday((struct timeval * __restrict  )(& tv), (struct timezone * __restrict  )((void *)0));
#line 378
  li->tv_sec = (unsigned int )tv.tv_sec;
#line 379
  li->tv_usec = (unsigned int )tv.tv_usec;
#line 380
  return;
}
}
#line 383 "loginrec.c"
void login_set_addr(struct logininfo *li , struct sockaddr  const  *sa , unsigned int sa_size ) 
{ unsigned int bufsize ;

  {
#line 387
  bufsize = sa_size;
#line 390
  if (sizeof(li->hostaddr) < sa_size) {
#line 391
    bufsize = sizeof(li->hostaddr);
  }
#line 393
  memcpy((void * __restrict  )((void *)(& li->hostaddr.sa)), (void const   * __restrict  )((void const   *)sa),
         bufsize);
#line 394
  return;
}
}
#line 401 "loginrec.c"
int login_write(struct logininfo *li ) 
{ __uid_t tmp ;

  {
#line 405
  tmp = geteuid();
#line 405
  if ((int )tmp != 0) {
#line 406
    log("Attempt to write login records by non-root user (aborting)");
#line 407
    return (1);
  }
#line 412
  login_set_current_time(li);
#line 414
  syslogin_write_entry(li);
#line 417
  if ((int )li->type == 7) {
#line 418
    lastlog_write_entry(li);
  }
#line 433
  return (0);
}
}
#line 442 "loginrec.c"
int getlast_entry(struct logininfo *li ) 
{ int tmp ;

  {
#line 446
  tmp = lastlog_get_entry(li);
#line 446
  return (tmp);
}
}
#line 493 "loginrec.c"
char *line_fullname(char *dst , char const   *src , int dstsize ) 
{ int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  size_t tmp___25 ;

  {
#line 496
  memset((void *)dst, '\000', (unsigned int )dstsize);
#line 497
  if (0) {
#line 497
    if (0) {
#line 497
      __s1_len___0 = strlen(src);
#line 497
      __s2_len___0 = strlen("/dev/");
#line 497
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 497
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 497
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 497
            tmp___22 = 1;
          } else {
#line 497
            if (__s2_len___0 >= 4U) {
#line 497
              tmp___22 = 1;
            } else {
#line 497
              tmp___22 = 0;
            }
          }
        } else {
#line 497
          tmp___22 = 0;
        }
      }
#line 497
      if (tmp___22) {
#line 497
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 497
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 497
        tmp___18 = tmp___21;
      }
    } else {
#line 497
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 497
      tmp___18 = tmp___21;
    }
#line 497
    tmp___12 = tmp___18;
  } else {
#line 497
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 497
  if (tmp___12 == 0) {
#line 498
    strlcpy(dst, src, (unsigned int )dstsize);
  } else {
#line 497
    tmp___25 = strlen(src);
#line 497
    if ((size_t )dstsize < tmp___25 + 5U) {
#line 498
      strlcpy(dst, src, (unsigned int )dstsize);
    } else {
#line 500
      strlcpy(dst, "/dev/", (unsigned int )dstsize);
#line 501
      strlcat(dst, src, (unsigned int )dstsize);
    }
  }
#line 503
  return (dst);
}
}
#line 507 "loginrec.c"
char *line_stripname(char *dst , char const   *src , int dstsize ) 
{ int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 510
  memset((void *)dst, '\000', (unsigned int )dstsize);
#line 515
  if (0) {
#line 515
    if (0) {
#line 515
      __s1_len___0 = strlen(src);
#line 515
      __s2_len___0 = strlen("/dev/");
#line 515
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 515
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 515
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 515
            tmp___22 = 1;
          } else {
#line 515
            if (__s2_len___0 >= 4U) {
#line 515
              tmp___22 = 1;
            } else {
#line 515
              tmp___22 = 0;
            }
          }
        } else {
#line 515
          tmp___22 = 0;
        }
      }
#line 515
      if (tmp___22) {
#line 515
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 515
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 515
        tmp___18 = tmp___21;
      }
    } else {
#line 515
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 515
      tmp___18 = tmp___21;
    }
#line 515
    tmp___12 = tmp___18;
  } else {
#line 515
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 515
  if (tmp___12 == 0) {
#line 516
    strlcpy(dst, src + 5, (unsigned int )dstsize);
  } else {
#line 519
    strlcpy(dst, src, (unsigned int )dstsize);
  }
#line 520
  return (dst);
}
}
#line 529 "loginrec.c"
char *line_abbrevname(char *dst , char const   *src , int dstsize ) 
{ size_t len ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 534
  memset((void *)dst, '\000', (unsigned int )dstsize);
#line 541
  if (0) {
#line 541
    if (0) {
#line 541
      __s1_len___0 = strlen(src);
#line 541
      __s2_len___0 = strlen("/dev/");
#line 541
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 541
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 541
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 541
            tmp___22 = 1;
          } else {
#line 541
            if (__s2_len___0 >= 4U) {
#line 541
              tmp___22 = 1;
            } else {
#line 541
              tmp___22 = 0;
            }
          }
        } else {
#line 541
          tmp___22 = 0;
        }
      }
#line 541
      if (tmp___22) {
#line 541
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 541
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 541
        tmp___18 = tmp___21;
      }
    } else {
#line 541
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 541
      tmp___18 = tmp___21;
    }
#line 541
    tmp___12 = tmp___18;
  } else {
#line 541
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 541
  if (tmp___12 == 0) {
#line 542
    src += 5;
  }
#line 545
  len = strlen(src);
#line 547
  if (len > 0U) {
#line 548
    if ((int )len - dstsize > 0) {
#line 549
      src += (int )len - dstsize;
    }
#line 552
    __builtin_strncpy(dst, src, (unsigned int )dstsize);
  }
#line 555
  return (dst);
}
}
#line 568 "loginrec.c"
void set_utmp_time(struct logininfo *li , struct utmp *ut ) 
{ 

  {
#line 572
  ut->ut_tv.tv_sec = (long )li->tv_sec;
#line 573
  ut->ut_tv.tv_usec = (long )li->tv_usec;
#line 579
  return;
}
}
#line 581 "loginrec.c"
void construct_utmp(struct logininfo *li , struct utmp *ut ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 585
  memset((void *)ut, '\000', sizeof(*ut));
#line 590
  line_abbrevname(ut->ut_id, (char const   *)(li->line), (int )sizeof(ut->ut_id));
#line 595
  switch ((int )li->type) {
  case 7: 
#line 597
  ut->ut_type = (short)7;
#line 598
  break;
  case 8: 
#line 600
  ut->ut_type = (short)8;
#line 601
  break;
  }
#line 604
  set_utmp_time(li, ut);
#line 606
  line_stripname(ut->ut_line, (char const   *)(li->line), (int )sizeof(ut->ut_line));
#line 609
  ut->ut_pid = li->pid;
#line 613
  if ((int )li->type == 8) {
#line 614
    return;
  }
#line 622
  if (sizeof(ut->ut_user) < sizeof(li->username)) {
#line 622
    tmp = sizeof(ut->ut_user);
  } else {
#line 622
    tmp = sizeof(li->username);
  }
#line 622
  __builtin_strncpy(ut->ut_user, (char const   *)(li->username), tmp);
#line 624
  if (sizeof(ut->ut_host) < sizeof(li->hostname)) {
#line 624
    tmp___0 = sizeof(ut->ut_host);
  } else {
#line 624
    tmp___0 = sizeof(li->hostname);
  }
#line 624
  __builtin_strncpy(ut->ut_host, (char const   *)(li->hostname), tmp___0);
#line 628
  if ((int )li->hostaddr.sa.sa_family == 2) {
#line 629
    ut->ut_addr_v6[0] = (int )li->hostaddr.sa_in.sin_addr.s_addr;
  }
#line 631
  return;
}
}
#line 1273 "loginrec.c"
static int syslogin_perform_login(struct logininfo *li ) 
{ struct utmp *ut ;
  void *tmp ;

  {
#line 1278
  tmp = malloc(sizeof(*ut));
#line 1278
  ut = (struct utmp *)tmp;
#line 1278
  if (! ut) {
#line 1279
    log("syslogin_perform_login: couldn\'t malloc()");
#line 1280
    return (0);
  }
#line 1282
  construct_utmp(li, ut);
#line 1283
  login((struct utmp  const  *)ut);
#line 1285
  return (1);
}
}
#line 1288 "loginrec.c"
static int syslogin_perform_logout(struct logininfo *li ) 
{ char line[8] ;
  int tmp ;

  {
#line 1294
  line_stripname(line, (char const   *)(li->line), (int )sizeof(line));
#line 1296
  tmp = logout((char const   *)(line));
#line 1296
  if (tmp) {
#line 1300
    logwtmp((char const   *)(line), "", "");
  } else {
#line 1297
    log("syslogin_perform_logout: logout() returned an error");
  }
#line 1308
  return (1);
}
}
#line 1311 "loginrec.c"
int syslogin_write_entry(struct logininfo *li ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 1314
  switch ((int )li->type) {
  case 7: 
#line 1316
  tmp = syslogin_perform_login(li);
#line 1316
  return (tmp);
  case 8: 
#line 1318
  tmp___0 = syslogin_perform_logout(li);
#line 1318
  return (tmp___0);
  default: 
#line 1320
  log("syslogin_write_entry: Invalid type field");
#line 1321
  return (0);
  }
}
}
#line 1337 "loginrec.c"
static void lastlog_construct(struct logininfo *li , struct lastlog *last ) 
{ unsigned int tmp ;

  {
#line 1341
  memset((void *)last, '\000', sizeof(*last));
#line 1343
  line_stripname(last->ll_line, (char const   *)(li->line), (int )sizeof(last->ll_line));
#line 1344
  if (sizeof(last->ll_host) < sizeof(li->hostname)) {
#line 1344
    tmp = sizeof(last->ll_host);
  } else {
#line 1344
    tmp = sizeof(li->hostname);
  }
#line 1344
  strlcpy(last->ll_host, (char const   *)(li->hostname), tmp);
#line 1346
  last->ll_time = (long )li->tv_sec;
#line 1347
  return;
}
}
#line 1349 "loginrec.c"
static int lastlog_filetype(char *filename ) 
{ struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1354
  tmp___1 = stat((char const   * __restrict  )"/var/log/lastlog", (struct stat * __restrict  )(& st));
#line 1354
  if (tmp___1 != 0) {
#line 1355
    tmp = __errno_location();
#line 1355
    tmp___0 = strerror(*tmp);
#line 1355
    log("lastlog_perform_login: Couldn\'t stat %s: %s", "/var/log/lastlog", tmp___0);
#line 1357
    return (0);
  }
#line 1359
  if ((st.st_mode & 61440U) == 16384U) {
#line 1360
    return (2);
  } else {
#line 1361
    if ((st.st_mode & 61440U) == 32768U) {
#line 1362
      return (1);
    } else {
#line 1364
      return (3);
    }
  }
}
}
#line 1369 "loginrec.c"
static int lastlog_openseek(struct logininfo *li , int *fd , int filemode ) 
{ off_t offset ;
  int type ;
  char lastlog_file[1024] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  __off_t tmp___3 ;

  {
#line 1376
  type = lastlog_filetype((char *)"/var/log/lastlog");
#line 1377
  switch (type) {
  case 1: 
#line 1379
  strlcpy(lastlog_file, "/var/log/lastlog", sizeof(lastlog_file));
#line 1380
  break;
  case 2: 
#line 1382
  snprintf((char * __restrict  )(lastlog_file), sizeof(lastlog_file), (char const   * __restrict  )"%s/%s",
           "/var/log/lastlog", li->username);
#line 1384
  break;
  default: 
#line 1386
  log("lastlog_openseek: %.100s is not a file or directory!", "/var/log/lastlog");
#line 1388
  return (0);
  }
#line 1391
  *fd = open((char const   *)(lastlog_file), filemode);
#line 1392
  if (*fd < 0) {
#line 1393
    tmp = __errno_location();
#line 1393
    tmp___0 = strerror(*tmp);
#line 1393
    debug("lastlog_openseek: Couldn\'t open %s: %s", lastlog_file, tmp___0);
#line 1395
    return (0);
  }
#line 1398
  if (type == 1) {
#line 1400
    offset = (long )((unsigned long )((long )li->uid) * (unsigned long )sizeof(struct lastlog ));
#line 1402
    tmp___3 = lseek(*fd, offset, 0);
#line 1402
    if (tmp___3 != offset) {
#line 1403
      tmp___1 = __errno_location();
#line 1403
      tmp___2 = strerror(*tmp___1);
#line 1403
      log("lastlog_openseek: %s->lseek(): %s", lastlog_file, tmp___2);
#line 1405
      return (0);
    }
  }
#line 1409
  return (1);
}
}
#line 1412 "loginrec.c"
static int lastlog_perform_login(struct logininfo *li ) 
{ struct lastlog last ;
  int fd ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 1419
  lastlog_construct(li, & last);
#line 1421
  tmp = lastlog_openseek(li, & fd, 66);
#line 1421
  if (! tmp) {
#line 1422
    return (0);
  }
#line 1425
  tmp___2 = atomicio((ssize_t (*)())(& write), fd, (void *)(& last), sizeof(last));
#line 1425
  if ((unsigned int )tmp___2 != sizeof(last)) {
#line 1426
    close(fd);
#line 1427
    tmp___0 = __errno_location();
#line 1427
    tmp___1 = strerror(*tmp___0);
#line 1427
    log("lastlog_write_filemode: Error writing to %s: %s", "/var/log/lastlog", tmp___1);
#line 1429
    return (0);
  }
#line 1432
  close(fd);
#line 1433
  return (1);
}
}
#line 1436 "loginrec.c"
int lastlog_write_entry(struct logininfo *li ) 
{ int tmp ;

  {
#line 1439
  switch ((int )li->type) {
  case 7: 
#line 1441
  tmp = lastlog_perform_login(li);
#line 1441
  return (tmp);
  default: 
#line 1443
  log("lastlog_write_entry: Invalid type field");
#line 1444
  return (0);
  }
}
}
#line 1448 "loginrec.c"
static void lastlog_populate_entry(struct logininfo *li , struct lastlog *last ) 
{ unsigned int tmp ;

  {
#line 1451
  line_fullname(li->line, (char const   *)(last->ll_line), (int )sizeof(li->line));
#line 1452
  if (sizeof(li->hostname) < sizeof(last->ll_host)) {
#line 1452
    tmp = sizeof(li->hostname);
  } else {
#line 1452
    tmp = sizeof(last->ll_host);
  }
#line 1452
  strlcpy(li->hostname, (char const   *)(last->ll_host), tmp);
#line 1454
  li->tv_sec = (unsigned int )last->ll_time;
#line 1455
  return;
}
}
#line 1457 "loginrec.c"
int lastlog_get_entry(struct logininfo *li ) 
{ struct lastlog last ;
  int fd ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;

  {
#line 1463
  tmp___2 = lastlog_openseek(li, & fd, 0);
#line 1463
  if (tmp___2) {
#line 1464
    tmp___1 = atomicio((ssize_t (*)())(& read), fd, (void *)(& last), sizeof(last));
#line 1464
    if ((unsigned int )tmp___1 != sizeof(last)) {
#line 1465
      tmp = __errno_location();
#line 1465
      tmp___0 = strerror(*tmp);
#line 1465
      log("lastlog_get_entry: Error reading from %s: %s", "/var/log/lastlog", tmp___0);
#line 1467
      return (0);
    } else {
#line 1469
      lastlog_populate_entry(li, & last);
#line 1470
      return (1);
    }
  } else {
#line 1473
    return (0);
  }
}
}
#line 1 "servconf.o"
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 21 "servconf.c"
void add_listen_addr(ServerOptions *options___0 , char *addr ) ;
#line 25 "servconf.c"
void initialize_server_options(ServerOptions *options___0 ) 
{ 

  {
#line 28
  memset((void *)options___0, 0, sizeof(*options___0));
#line 29
  options___0->num_ports = 0U;
#line 30
  options___0->ports_from_cmdline = 0U;
#line 31
  options___0->listen_addrs = (struct addrinfo *)((void *)0);
#line 32
  options___0->host_key_file = (char *)((void *)0);
#line 33
  options___0->host_dsa_key_file = (char *)((void *)0);
#line 34
  options___0->pid_file = (char *)((void *)0);
#line 35
  options___0->server_key_bits = -1;
#line 36
  options___0->login_grace_time = -1;
#line 37
  options___0->key_regeneration_time = -1;
#line 38
  options___0->permit_root_login = -1;
#line 39
  options___0->ignore_rhosts = -1;
#line 40
  options___0->ignore_user_known_hosts = -1;
#line 41
  options___0->print_motd = -1;
#line 42
  options___0->check_mail = -1;
#line 43
  options___0->x11_forwarding = -1;
#line 44
  options___0->x11_display_offset = -1;
#line 45
  options___0->xauth_location = (char *)((void *)0);
#line 46
  options___0->strict_modes = -1;
#line 47
  options___0->keepalives = -1;
#line 48
  options___0->log_facility = (enum __anonenum_SyslogFacility_73 )-1;
#line 49
  options___0->log_level = (enum __anonenum_LogLevel_74 )-1;
#line 50
  options___0->rhosts_authentication = -1;
#line 51
  options___0->rhosts_rsa_authentication = -1;
#line 52
  options___0->rsa_authentication = -1;
#line 53
  options___0->dsa_authentication = -1;
#line 63
  options___0->password_authentication = -1;
#line 64
  options___0->kbd_interactive_authentication = -1;
#line 68
  options___0->permit_empty_passwd = -1;
#line 69
  options___0->use_login = -1;
#line 70
  options___0->allow_tcp_forwarding = -1;
#line 71
  options___0->num_allow_users = 0U;
#line 72
  options___0->num_deny_users = 0U;
#line 73
  options___0->num_allow_groups = 0U;
#line 74
  options___0->num_deny_groups = 0U;
#line 75
  options___0->ciphers = (char *)((void *)0);
#line 76
  options___0->protocol = 0;
#line 77
  options___0->gateway_ports = -1;
#line 78
  options___0->num_subsystems = 0U;
#line 79
  options___0->max_startups_begin = -1;
#line 80
  options___0->max_startups_rate = -1;
#line 81
  options___0->max_startups = -1;
#line 82
  return;
}
}
#line 84 "servconf.c"
void fill_default_server_options(ServerOptions *options___0 ) 
{ unsigned int tmp ;

  {
#line 87
  if (options___0->num_ports == 0U) {
#line 88
    tmp = options___0->num_ports;
#line 88
    (options___0->num_ports) ++;
#line 88
    options___0->ports[tmp] = (unsigned short)22;
  }
#line 89
  if ((unsigned int )options___0->listen_addrs == (unsigned int )((void *)0)) {
#line 90
    add_listen_addr(options___0, (char *)((void *)0));
  }
#line 91
  if ((unsigned int )options___0->host_key_file == (unsigned int )((void *)0)) {
#line 92
    options___0->host_key_file = (char *)"/usr/local/etc/ssh_host_key";
  }
#line 93
  if ((unsigned int )options___0->host_dsa_key_file == (unsigned int )((void *)0)) {
#line 94
    options___0->host_dsa_key_file = (char *)"/usr/local/etc/ssh_host_dsa_key";
  }
#line 95
  if ((unsigned int )options___0->pid_file == (unsigned int )((void *)0)) {
#line 96
    options___0->pid_file = (char *)"/var/run/sshd.pid";
  }
#line 97
  if (options___0->server_key_bits == -1) {
#line 98
    options___0->server_key_bits = 768;
  }
#line 99
  if (options___0->login_grace_time == -1) {
#line 100
    options___0->login_grace_time = 600;
  }
#line 101
  if (options___0->key_regeneration_time == -1) {
#line 102
    options___0->key_regeneration_time = 3600;
  }
#line 103
  if (options___0->permit_root_login == -1) {
#line 104
    options___0->permit_root_login = 1;
  }
#line 105
  if (options___0->ignore_rhosts == -1) {
#line 106
    options___0->ignore_rhosts = 1;
  }
#line 107
  if (options___0->ignore_user_known_hosts == -1) {
#line 108
    options___0->ignore_user_known_hosts = 0;
  }
#line 109
  if (options___0->check_mail == -1) {
#line 110
    options___0->check_mail = 0;
  }
#line 111
  if (options___0->print_motd == -1) {
#line 112
    options___0->print_motd = 1;
  }
#line 113
  if (options___0->x11_forwarding == -1) {
#line 114
    options___0->x11_forwarding = 0;
  }
#line 115
  if (options___0->x11_display_offset == -1) {
#line 116
    options___0->x11_display_offset = 10;
  }
#line 118
  if ((unsigned int )options___0->xauth_location == (unsigned int )((void *)0)) {
#line 119
    options___0->xauth_location = (char *)"/usr/bin//xauth";
  }
#line 121
  if (options___0->strict_modes == -1) {
#line 122
    options___0->strict_modes = 1;
  }
#line 123
  if (options___0->keepalives == -1) {
#line 124
    options___0->keepalives = 1;
  }
#line 125
  if ((int )options___0->log_facility == (int )((enum __anonenum_SyslogFacility_73 )-1)) {
#line 126
    options___0->log_facility = 2;
  }
#line 127
  if ((int )options___0->log_level == (int )((enum __anonenum_LogLevel_74 )-1)) {
#line 128
    options___0->log_level = 3;
  }
#line 129
  if (options___0->rhosts_authentication == -1) {
#line 130
    options___0->rhosts_authentication = 0;
  }
#line 131
  if (options___0->rhosts_rsa_authentication == -1) {
#line 132
    options___0->rhosts_rsa_authentication = 0;
  }
#line 133
  if (options___0->rsa_authentication == -1) {
#line 134
    options___0->rsa_authentication = 1;
  }
#line 135
  if (options___0->dsa_authentication == -1) {
#line 136
    options___0->dsa_authentication = 1;
  }
#line 151
  if (options___0->password_authentication == -1) {
#line 152
    options___0->password_authentication = 1;
  }
#line 153
  if (options___0->kbd_interactive_authentication == -1) {
#line 154
    options___0->kbd_interactive_authentication = 0;
  }
#line 159
  if (options___0->permit_empty_passwd == -1) {
#line 160
    options___0->permit_empty_passwd = 0;
  }
#line 161
  if (options___0->use_login == -1) {
#line 162
    options___0->use_login = 0;
  }
#line 163
  if (options___0->allow_tcp_forwarding == -1) {
#line 164
    options___0->allow_tcp_forwarding = 1;
  }
#line 165
  if (options___0->protocol == 0) {
#line 166
    options___0->protocol = 5;
  }
#line 167
  if (options___0->gateway_ports == -1) {
#line 168
    options___0->gateway_ports = 0;
  }
#line 169
  if (options___0->max_startups == -1) {
#line 170
    options___0->max_startups = 10;
  }
#line 171
  if (options___0->max_startups_rate == -1) {
#line 172
    options___0->max_startups_rate = 100;
  }
#line 173
  if (options___0->max_startups_begin == -1) {
#line 174
    options___0->max_startups_begin = options___0->max_startups;
  }
#line 175
  return;
}
}
#line 202 "servconf.c"
static struct __anonstruct_keywords_77 keywords[40]  = 
#line 202
  {      {"port", 1}, 
        {"hostkey", 2}, 
        {"hostdsakey", 31}, 
        {"pidfile", 34}, 
        {"serverkeybits", 3}, 
        {"logingracetime", 4}, 
        {"keyregenerationinterval", 5}, 
        {"permitrootlogin", 6}, 
        {"syslogfacility", 7}, 
        {"loglevel", 8}, 
        {"rhostsauthentication", 9}, 
        {"rhostsrsaauthentication", 10}, 
        {"rsaauthentication", 11}, 
        {"dsaauthentication", 36}, 
        {"passwordauthentication", 12}, 
        {"kbdinteractiveauthentication", 13}, 
        {"checkmail", 23}, 
        {"listenaddress", 14}, 
        {"printmotd", 15}, 
        {"ignorerhosts", 16}, 
        {"ignoreuserknownhosts", 30}, 
        {"x11forwarding", 17}, 
        {"x11displayoffset", 18}, 
        {"xauthlocation", 37}, 
        {"strictmodes", 19}, 
        {"permitemptypasswords", 20}, 
        {"uselogin", 24}, 
        {"randomseed", 21}, 
        {"keepalive", 22}, 
        {"allowtcpforwarding", 25}, 
        {"allowusers", 26}, 
        {"denyusers", 27}, 
        {"allowgroups", 28}, 
        {"denygroups", 29}, 
        {"ciphers", 32}, 
        {"protocol", 33}, 
        {"gatewayports", 35}, 
        {"subsystem", 38}, 
        {"maxstartups", 39}, 
        {(char const   *)((void *)0), (ServerOpCodes )0}};
#line 265 "servconf.c"
static ServerOpCodes parse_token(char const   *cp , char const   *filename , int linenum ) 
{ unsigned int i ;
  int tmp ;

  {
#line 271
  i = 0U;
#line 271
  while (keywords[i].name) {
#line 272
    tmp = strcasecmp(cp, keywords[i].name);
#line 272
    if (tmp == 0) {
#line 273
      return (keywords[i].opcode);
    }
#line 271
    i ++;
  }
#line 275
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: line %d: Bad configuration option: %s\n",
          filename, linenum, cp);
#line 277
  return (0);
}
}
#line 283 "servconf.c"
void add_listen_addr(ServerOptions *options___0 , char *addr ) 
{ struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  int i ;
  unsigned int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 292
  if (options___0->num_ports == 0U) {
#line 293
    tmp = options___0->num_ports;
#line 293
    (options___0->num_ports) ++;
#line 293
    options___0->ports[tmp] = (unsigned short)22;
  }
#line 294
  i = 0;
#line 294
  while ((unsigned int )i < options___0->num_ports) {
#line 295
    memset((void *)(& hints), 0, sizeof(hints));
#line 296
    hints.ai_family = IPv4or6;
#line 297
    hints.ai_socktype = 1;
#line 298
    if ((unsigned int )addr == (unsigned int )((void *)0)) {
#line 298
      hints.ai_flags = 1;
    } else {
#line 298
      hints.ai_flags = 0;
    }
#line 299
    snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
             options___0->ports[i]);
#line 300
    gaierr = getaddrinfo((char const   * __restrict  )addr, (char const   * __restrict  )(strport),
                         (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 300
    if (gaierr != 0) {
#line 301
      tmp___0 = gai_strerror(gaierr);
#line 301
      if (addr) {
#line 301
        tmp___1 = (char const   *)addr;
      } else {
#line 301
        tmp___1 = "<NULL>";
      }
#line 301
      fatal("bad addr or host: %s (%s)\n", tmp___1, tmp___0);
    }
#line 304
    ai = aitop;
#line 304
    while (ai->ai_next) {
#line 304
      ai = ai->ai_next;
    }
#line 306
    ai->ai_next = options___0->listen_addrs;
#line 307
    options___0->listen_addrs = aitop;
#line 294
    i ++;
  }
#line 309
  return;
}
}
#line 313 "servconf.c"
void read_server_config(ServerOptions *options___0 , char const   *filename ) 
{ FILE *f ;
  char line[1024] ;
  char *cp ;
  char **charptr ;
  char *arg ;
  int linenum ;
  int *intptr ;
  int value ;
  int bad_options ;
  ServerOpCodes opcode ;
  int i ;
  unsigned int tmp ;
  int tmp___0 ;
  __uid_t tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___17 ;
  int tmp___20 ;
  int tmp___21 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___27 ;
  int tmp___30 ;
  int tmp___31 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___37 ;
  int tmp___40 ;
  int tmp___41 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___47 ;
  int tmp___50 ;
  int tmp___51 ;
  SyslogFacility tmp___52 ;
  char const   *tmp___53 ;
  LogLevel tmp___54 ;
  char const   *tmp___55 ;
  unsigned int tmp___56 ;
  unsigned int tmp___57 ;
  unsigned int tmp___58 ;
  unsigned int tmp___59 ;
  char const   *tmp___60 ;
  int tmp___61 ;
  char const   *tmp___62 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___68 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  char *tmp___74 ;

  {
#line 320
  bad_options = 0;
#line 324
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 325
  if (! f) {
#line 326
    perror(filename);
#line 327
    exit(1);
  }
#line 329
  linenum = 0;
#line 330
  while (1) {
#line 330
    tmp___74 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 330
    if (! tmp___74) {
#line 330
      break;
    }
#line 331
    linenum ++;
#line 332
    cp = line;
#line 333
    arg = strdelim(& cp);
#line 335
    if ((int )*arg == 0) {
#line 336
      arg = strdelim(& cp);
    }
#line 337
    if (! *arg) {
#line 338
      continue;
    } else {
#line 337
      if ((int )*arg == 35) {
#line 338
        continue;
      }
    }
#line 339
    opcode = parse_token((char const   *)arg, filename, linenum);
#line 340
    switch ((int )opcode) {
    case 0: 
#line 342
    bad_options ++;
#line 343
    continue;
    case 1: 
#line 346
    if (options___0->ports_from_cmdline) {
#line 347
      continue;
    }
#line 348
    if ((unsigned int )options___0->listen_addrs != (unsigned int )((void *)0)) {
#line 349
      fatal("%s line %d: ports must be specified before ListenAdress.\n", filename,
            linenum);
    }
#line 351
    if (options___0->num_ports >= 256U) {
#line 352
      fatal("%s line %d: too many ports.\n", filename, linenum);
    }
#line 354
    arg = strdelim(& cp);
#line 355
    if (! arg) {
#line 356
      fatal("%s line %d: missing port number.\n", filename, linenum);
    } else {
#line 355
      if ((int )*arg == 0) {
#line 356
        fatal("%s line %d: missing port number.\n", filename, linenum);
      }
    }
#line 358
    tmp = options___0->num_ports;
#line 358
    (options___0->num_ports) ++;
#line 358
    tmp___0 = atoi((char const   *)arg);
#line 358
    options___0->ports[tmp] = (unsigned short )tmp___0;
#line 359
    break;
    case 3: 
#line 362
    intptr = & options___0->server_key_bits;
    parse_int: 
#line 364
    arg = strdelim(& cp);
#line 365
    if (! arg) {
#line 366
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing integer value.\n",
              filename, linenum);
#line 368
      exit(1);
    } else {
#line 365
      if ((int )*arg == 0) {
#line 366
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing integer value.\n",
                filename, linenum);
#line 368
        exit(1);
      }
    }
#line 370
    value = atoi((char const   *)arg);
#line 371
    if (*intptr == -1) {
#line 372
      *intptr = value;
    }
#line 373
    break;
    case 4: 
#line 376
    intptr = & options___0->login_grace_time;
    goto parse_int;
    case 5: 
#line 380
    intptr = & options___0->key_regeneration_time;
    goto parse_int;
    case 14: 
#line 384
    arg = strdelim(& cp);
#line 385
    if (! arg) {
#line 386
      fatal("%s line %d: missing inet addr.\n", filename, linenum);
    } else {
#line 385
      if ((int )*arg == 0) {
#line 386
        fatal("%s line %d: missing inet addr.\n", filename, linenum);
      }
    }
#line 388
    add_listen_addr(options___0, arg);
#line 389
    break;
    case 2: 
    case 31: 
#line 393
    if ((int )opcode == 2) {
#line 393
      charptr = & options___0->host_key_file;
    } else {
#line 393
      charptr = & options___0->host_dsa_key_file;
    }
    parse_filename: 
#line 396
    arg = strdelim(& cp);
#line 397
    if (! arg) {
#line 398
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing file name.\n",
              filename, linenum);
#line 400
      exit(1);
    } else {
#line 397
      if ((int )*arg == 0) {
#line 398
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing file name.\n",
                filename, linenum);
#line 400
        exit(1);
      }
    }
#line 402
    if ((unsigned int )*charptr == (unsigned int )((void *)0)) {
#line 403
      tmp___1 = getuid();
#line 403
      *charptr = tilde_expand_filename((char const   *)arg, tmp___1);
    }
#line 404
    break;
    case 34: 
#line 407
    charptr = & options___0->pid_file;
    goto parse_filename;
    case 21: 
#line 411
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: \"randomseed\" option is obsolete.\n",
            filename, linenum);
#line 413
    arg = strdelim(& cp);
#line 414
    break;
    case 6: 
#line 417
    intptr = & options___0->permit_root_login;
#line 418
    arg = strdelim(& cp);
#line 419
    if (! arg) {
#line 420
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing yes/without-password/no argument.\n",
              filename, linenum);
#line 422
      exit(1);
    } else {
#line 419
      if ((int )*arg == 0) {
#line 420
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing yes/without-password/no argument.\n",
                filename, linenum);
#line 422
        exit(1);
      }
    }
#line 424
    if (0) {
#line 424
      __s1_len___1 = strlen((char const   *)arg);
#line 424
      __s2_len___1 = strlen("without-password");
#line 424
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___4;
      } else {
#line 424
        if (__s1_len___1 >= 4U) {
          _L___4: /* CIL Label */ 
#line 424
          if (! ((unsigned int )((void const   *)("without-password" + 1)) - (unsigned int )((void const   *)"without-password") == 1U)) {
#line 424
            tmp___31 = 1;
          } else {
#line 424
            if (__s2_len___1 >= 4U) {
#line 424
              tmp___31 = 1;
            } else {
#line 424
              tmp___31 = 0;
            }
          }
        } else {
#line 424
          tmp___31 = 0;
        }
      }
#line 424
      if (tmp___31) {
#line 424
        tmp___27 = __builtin_strcmp((char const   *)arg, "without-password");
      } else {
#line 424
        tmp___30 = __builtin_strcmp((char const   *)arg, "without-password");
#line 424
        tmp___27 = tmp___30;
      }
    } else {
#line 424
      tmp___30 = __builtin_strcmp((char const   *)arg, "without-password");
#line 424
      tmp___27 = tmp___30;
    }
#line 424
    if (tmp___27 == 0) {
#line 425
      value = 2;
    } else {
#line 426
      if (0) {
#line 426
        __s1_len___0 = strlen((char const   *)arg);
#line 426
        __s2_len___0 = strlen("yes");
#line 426
        if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
          goto _L___2;
        } else {
#line 426
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 426
            if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 426
              tmp___21 = 1;
            } else {
#line 426
              if (__s2_len___0 >= 4U) {
#line 426
                tmp___21 = 1;
              } else {
#line 426
                tmp___21 = 0;
              }
            }
          } else {
#line 426
            tmp___21 = 0;
          }
        }
#line 426
        if (tmp___21) {
#line 426
          tmp___17 = __builtin_strcmp((char const   *)arg, "yes");
        } else {
#line 426
          tmp___20 = __builtin_strcmp((char const   *)arg, "yes");
#line 426
          tmp___17 = tmp___20;
        }
      } else {
#line 426
        tmp___20 = __builtin_strcmp((char const   *)arg, "yes");
#line 426
        tmp___17 = tmp___20;
      }
#line 426
      if (tmp___17 == 0) {
#line 427
        value = 1;
      } else {
#line 428
        if (0) {
#line 428
          __s1_len = strlen((char const   *)arg);
#line 428
          __s2_len = strlen("no");
#line 428
          if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
            goto _L___0;
          } else {
#line 428
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 428
              if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 428
                tmp___11 = 1;
              } else {
#line 428
                if (__s2_len >= 4U) {
#line 428
                  tmp___11 = 1;
                } else {
#line 428
                  tmp___11 = 0;
                }
              }
            } else {
#line 428
              tmp___11 = 0;
            }
          }
#line 428
          if (tmp___11) {
#line 428
            tmp___7 = __builtin_strcmp((char const   *)arg, "no");
          } else {
#line 428
            tmp___10 = __builtin_strcmp((char const   *)arg, "no");
#line 428
            tmp___7 = tmp___10;
          }
        } else {
#line 428
          tmp___10 = __builtin_strcmp((char const   *)arg, "no");
#line 428
          tmp___7 = tmp___10;
        }
#line 428
        if (tmp___7 == 0) {
#line 429
          value = 0;
        } else {
#line 431
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: Bad yes/without-password/no argument: %s\n",
                  filename, linenum, arg);
#line 433
          exit(1);
        }
      }
    }
#line 435
    if (*intptr == -1) {
#line 436
      *intptr = value;
    }
#line 437
    break;
    case 16: 
#line 440
    intptr = & options___0->ignore_rhosts;
    parse_flag: 
#line 442
    arg = strdelim(& cp);
#line 443
    if (! arg) {
#line 444
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing yes/no argument.\n",
              filename, linenum);
#line 446
      exit(1);
    } else {
#line 443
      if ((int )*arg == 0) {
#line 444
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing yes/no argument.\n",
                filename, linenum);
#line 446
        exit(1);
      }
    }
#line 448
    if (0) {
#line 448
      __s1_len___3 = strlen((char const   *)arg);
#line 448
      __s2_len___3 = strlen("yes");
#line 448
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___8;
      } else {
#line 448
        if (__s1_len___3 >= 4U) {
          _L___8: /* CIL Label */ 
#line 448
          if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 448
            tmp___51 = 1;
          } else {
#line 448
            if (__s2_len___3 >= 4U) {
#line 448
              tmp___51 = 1;
            } else {
#line 448
              tmp___51 = 0;
            }
          }
        } else {
#line 448
          tmp___51 = 0;
        }
      }
#line 448
      if (tmp___51) {
#line 448
        tmp___47 = __builtin_strcmp((char const   *)arg, "yes");
      } else {
#line 448
        tmp___50 = __builtin_strcmp((char const   *)arg, "yes");
#line 448
        tmp___47 = tmp___50;
      }
    } else {
#line 448
      tmp___50 = __builtin_strcmp((char const   *)arg, "yes");
#line 448
      tmp___47 = tmp___50;
    }
#line 448
    if (tmp___47 == 0) {
#line 449
      value = 1;
    } else {
#line 450
      if (0) {
#line 450
        __s1_len___2 = strlen((char const   *)arg);
#line 450
        __s2_len___2 = strlen("no");
#line 450
        if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
          goto _L___6;
        } else {
#line 450
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 450
            if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 450
              tmp___41 = 1;
            } else {
#line 450
              if (__s2_len___2 >= 4U) {
#line 450
                tmp___41 = 1;
              } else {
#line 450
                tmp___41 = 0;
              }
            }
          } else {
#line 450
            tmp___41 = 0;
          }
        }
#line 450
        if (tmp___41) {
#line 450
          tmp___37 = __builtin_strcmp((char const   *)arg, "no");
        } else {
#line 450
          tmp___40 = __builtin_strcmp((char const   *)arg, "no");
#line 450
          tmp___37 = tmp___40;
        }
      } else {
#line 450
        tmp___40 = __builtin_strcmp((char const   *)arg, "no");
#line 450
        tmp___37 = tmp___40;
      }
#line 450
      if (tmp___37 == 0) {
#line 451
        value = 0;
      } else {
#line 453
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: Bad yes/no argument: %s\n",
                filename, linenum, arg);
#line 455
        exit(1);
      }
    }
#line 457
    if (*intptr == -1) {
#line 458
      *intptr = value;
    }
#line 459
    break;
    case 30: 
#line 462
    intptr = & options___0->ignore_user_known_hosts;
    goto parse_flag;
    case 9: 
#line 466
    intptr = & options___0->rhosts_authentication;
    goto parse_flag;
    case 10: 
#line 470
    intptr = & options___0->rhosts_rsa_authentication;
    goto parse_flag;
    case 11: 
#line 474
    intptr = & options___0->rsa_authentication;
    goto parse_flag;
    case 36: 
#line 478
    intptr = & options___0->dsa_authentication;
    goto parse_flag;
    case 12: 
#line 506
    intptr = & options___0->password_authentication;
    goto parse_flag;
    case 13: 
#line 510
    intptr = & options___0->kbd_interactive_authentication;
    goto parse_flag;
    case 23: 
#line 514
    intptr = & options___0->check_mail;
    goto parse_flag;
    case 15: 
#line 524
    intptr = & options___0->print_motd;
    goto parse_flag;
    case 17: 
#line 528
    intptr = & options___0->x11_forwarding;
    goto parse_flag;
    case 18: 
#line 532
    intptr = & options___0->x11_display_offset;
    goto parse_int;
    case 37: 
#line 536
    charptr = & options___0->xauth_location;
    goto parse_filename;
    case 19: 
#line 540
    intptr = & options___0->strict_modes;
    goto parse_flag;
    case 22: 
#line 544
    intptr = & options___0->keepalives;
    goto parse_flag;
    case 20: 
#line 548
    intptr = & options___0->permit_empty_passwd;
    goto parse_flag;
    case 24: 
#line 552
    intptr = & options___0->use_login;
    goto parse_flag;
    case 35: 
#line 556
    intptr = & options___0->gateway_ports;
    goto parse_flag;
    case 7: 
#line 560
    intptr = (int *)(& options___0->log_facility);
#line 561
    arg = strdelim(& cp);
#line 562
    tmp___52 = log_facility_number(arg);
#line 562
    value = (int )tmp___52;
#line 563
    if (value == (int )((enum __anonenum_SyslogFacility_73 )-1)) {
#line 564
      if (arg) {
#line 564
        tmp___53 = (char const   *)arg;
      } else {
#line 564
        tmp___53 = "<NONE>";
      }
#line 564
      fatal("%.200s line %d: unsupported log facility \'%s\'\n", filename, linenum,
            tmp___53);
    }
#line 566
    if (*intptr == -1) {
#line 567
      *intptr = (int )((enum __anonenum_SyslogFacility_73 )value);
    }
#line 568
    break;
    case 8: 
#line 571
    intptr = (int *)(& options___0->log_level);
#line 572
    arg = strdelim(& cp);
#line 573
    tmp___54 = log_level_number(arg);
#line 573
    value = (int )tmp___54;
#line 574
    if (value == (int )((enum __anonenum_LogLevel_74 )-1)) {
#line 575
      if (arg) {
#line 575
        tmp___55 = (char const   *)arg;
      } else {
#line 575
        tmp___55 = "<NONE>";
      }
#line 575
      fatal("%.200s line %d: unsupported log level \'%s\'\n", filename, linenum, tmp___55);
    }
#line 577
    if (*intptr == -1) {
#line 578
      *intptr = (int )((enum __anonenum_LogLevel_74 )value);
    }
#line 579
    break;
    case 25: 
#line 582
    intptr = & options___0->allow_tcp_forwarding;
    goto parse_flag;
    case 26: 
#line 586
    while (1) {
#line 586
      arg = strdelim(& cp);
#line 586
      if (arg) {
#line 586
        if (! ((int )*arg != 0)) {
#line 586
          break;
        }
      } else {
#line 586
        break;
      }
#line 587
      if (options___0->num_allow_users >= 256U) {
#line 588
        fatal("%s line %d: too many allow users.\n", filename, linenum);
      }
#line 590
      tmp___56 = options___0->num_allow_users;
#line 590
      (options___0->num_allow_users) ++;
#line 590
      options___0->allow_users[tmp___56] = xstrdup((char const   *)arg);
    }
#line 592
    break;
    case 27: 
#line 595
    while (1) {
#line 595
      arg = strdelim(& cp);
#line 595
      if (arg) {
#line 595
        if (! ((int )*arg != 0)) {
#line 595
          break;
        }
      } else {
#line 595
        break;
      }
#line 596
      if (options___0->num_deny_users >= 256U) {
#line 597
        fatal("%s line %d: too many deny users.\n", filename, linenum);
      }
#line 599
      tmp___57 = options___0->num_deny_users;
#line 599
      (options___0->num_deny_users) ++;
#line 599
      options___0->deny_users[tmp___57] = xstrdup((char const   *)arg);
    }
#line 601
    break;
    case 28: 
#line 604
    while (1) {
#line 604
      arg = strdelim(& cp);
#line 604
      if (arg) {
#line 604
        if (! ((int )*arg != 0)) {
#line 604
          break;
        }
      } else {
#line 604
        break;
      }
#line 605
      if (options___0->num_allow_groups >= 256U) {
#line 606
        fatal("%s line %d: too many allow groups.\n", filename, linenum);
      }
#line 608
      tmp___58 = options___0->num_allow_groups;
#line 608
      (options___0->num_allow_groups) ++;
#line 608
      options___0->allow_groups[tmp___58] = xstrdup((char const   *)arg);
    }
#line 610
    break;
    case 29: 
#line 613
    while (1) {
#line 613
      arg = strdelim(& cp);
#line 613
      if (arg) {
#line 613
        if (! ((int )*arg != 0)) {
#line 613
          break;
        }
      } else {
#line 613
        break;
      }
#line 614
      if (options___0->num_deny_groups >= 256U) {
#line 615
        fatal("%s line %d: too many deny groups.\n", filename, linenum);
      }
#line 617
      tmp___59 = options___0->num_deny_groups;
#line 617
      (options___0->num_deny_groups) ++;
#line 617
      options___0->deny_groups[tmp___59] = xstrdup((char const   *)arg);
    }
#line 619
    break;
    case 32: 
#line 622
    arg = strdelim(& cp);
#line 623
    if (! arg) {
#line 624
      fatal("%s line %d: Missing argument.", filename, linenum);
    } else {
#line 623
      if ((int )*arg == 0) {
#line 624
        fatal("%s line %d: Missing argument.", filename, linenum);
      }
    }
#line 625
    tmp___61 = ciphers_valid((char const   *)arg);
#line 625
    if (! tmp___61) {
#line 626
      if (arg) {
#line 626
        tmp___60 = (char const   *)arg;
      } else {
#line 626
        tmp___60 = "<NONE>";
      }
#line 626
      fatal("%s line %d: Bad SSH2 cipher spec \'%s\'.", filename, linenum, tmp___60);
    }
#line 628
    if ((unsigned int )options___0->ciphers == (unsigned int )((void *)0)) {
#line 629
      options___0->ciphers = xstrdup((char const   *)arg);
    }
#line 630
    break;
    case 33: 
#line 633
    intptr = & options___0->protocol;
#line 634
    arg = strdelim(& cp);
#line 635
    if (! arg) {
#line 636
      fatal("%s line %d: Missing argument.", filename, linenum);
    } else {
#line 635
      if ((int )*arg == 0) {
#line 636
        fatal("%s line %d: Missing argument.", filename, linenum);
      }
    }
#line 637
    value = proto_spec((char const   *)arg);
#line 638
    if (value == 0) {
#line 639
      if (arg) {
#line 639
        tmp___62 = (char const   *)arg;
      } else {
#line 639
        tmp___62 = "<NONE>";
      }
#line 639
      fatal("%s line %d: Bad protocol spec \'%s\'.", filename, linenum, tmp___62);
    }
#line 641
    if (*intptr == 0) {
#line 642
      *intptr = value;
    }
#line 643
    break;
    case 38: 
#line 646
    if (options___0->num_subsystems >= 256U) {
#line 647
      fatal("%s line %d: too many subsystems defined.", filename, linenum);
    }
#line 650
    arg = strdelim(& cp);
#line 651
    if (! arg) {
#line 652
      fatal("%s line %d: Missing subsystem name.", filename, linenum);
    } else {
#line 651
      if ((int )*arg == 0) {
#line 652
        fatal("%s line %d: Missing subsystem name.", filename, linenum);
      }
    }
#line 654
    i = 0;
#line 654
    while ((unsigned int )i < options___0->num_subsystems) {
#line 655
      if (0) {
#line 655
        __s1_len___4 = strlen((char const   *)arg);
#line 655
        __s2_len___4 = strlen((char const   *)options___0->subsystem_name[i]);
#line 655
        if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
          goto _L___10;
        } else {
#line 655
          if (__s1_len___4 >= 4U) {
            _L___10: /* CIL Label */ 
#line 655
            if (! ((unsigned int )((void const   *)(options___0->subsystem_name[i] + 1)) - (unsigned int )((void const   *)options___0->subsystem_name[i]) == 1U)) {
#line 655
              tmp___72 = 1;
            } else {
#line 655
              if (__s2_len___4 >= 4U) {
#line 655
                tmp___72 = 1;
              } else {
#line 655
                tmp___72 = 0;
              }
            }
          } else {
#line 655
            tmp___72 = 0;
          }
        }
#line 655
        if (tmp___72) {
#line 655
          tmp___68 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
        } else {
#line 655
          tmp___71 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
#line 655
          tmp___68 = tmp___71;
        }
      } else {
#line 655
        tmp___71 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
#line 655
        tmp___68 = tmp___71;
      }
#line 655
      if (tmp___68 == 0) {
#line 656
        fatal("%s line %d: Subsystem \'%s\' already defined.", filename, linenum,
              arg);
      }
#line 654
      i ++;
    }
#line 658
    options___0->subsystem_name[options___0->num_subsystems] = xstrdup((char const   *)arg);
#line 659
    arg = strdelim(& cp);
#line 660
    if (! arg) {
#line 661
      fatal("%s line %d: Missing subsystem command.", filename, linenum);
    } else {
#line 660
      if ((int )*arg == 0) {
#line 661
        fatal("%s line %d: Missing subsystem command.", filename, linenum);
      }
    }
#line 663
    options___0->subsystem_command[options___0->num_subsystems] = xstrdup((char const   *)arg);
#line 664
    (options___0->num_subsystems) ++;
#line 665
    break;
    case 39: 
#line 668
    arg = strdelim(& cp);
#line 669
    if (! arg) {
#line 670
      fatal("%s line %d: Missing MaxStartups spec.", filename, linenum);
    } else {
#line 669
      if ((int )*arg == 0) {
#line 670
        fatal("%s line %d: Missing MaxStartups spec.", filename, linenum);
      }
    }
#line 672
    tmp___73 = sscanf((char const   * __restrict  )arg, (char const   * __restrict  )"%d:%d:%d",
                      & options___0->max_startups_begin, & options___0->max_startups_rate,
                      & options___0->max_startups);
#line 672
    if (tmp___73 == 3) {
#line 676
      if (options___0->max_startups_begin > options___0->max_startups) {
#line 680
        fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
      } else {
#line 676
        if (options___0->max_startups_rate > 100) {
#line 680
          fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
        } else {
#line 676
          if (options___0->max_startups_rate < 1) {
#line 680
            fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
          }
        }
      }
#line 682
      break;
    }
#line 684
    intptr = & options___0->max_startups;
    goto parse_int;
    default: 
#line 688
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: Missing handler for opcode %s (%d)\n",
            filename, linenum, arg, opcode);
#line 690
    exit(1);
    }
#line 692
    arg = strdelim(& cp);
#line 692
    if ((unsigned int )arg != (unsigned int )((void *)0)) {
#line 692
      if ((int )*arg != 0) {
#line 693
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: garbage at end of line; \"%.200s\".\n",
                filename, linenum, arg);
#line 696
        exit(1);
      }
    }
  }
#line 699
  fclose(f);
#line 700
  if (bad_options > 0) {
#line 701
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: terminating, %d bad configuration options\n",
            filename, bad_options);
#line 703
    exit(1);
  }
#line 705
  return;
}
}
#line 1 "serverloop.o"
#line 116 "/usr/include/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 505 "ssh.h"
void server_loop(pid_t pid , int fdin_arg , int fdout_arg , int fderr_arg ) ;
#line 506
void server_loop2(void) ;
#line 32 "session.h"
int session_open(int chanid ) ;
#line 33
void session_input_channel_req(int id , void *arg ) ;
#line 34
void session_close_by_pid(pid_t pid , int status ) ;
#line 35
void session_close_by_channel(int id , void *arg ) ;
#line 56 "serverloop.c"
static Buffer stdin_buffer  ;
#line 57 "serverloop.c"
static Buffer stdout_buffer  ;
#line 58 "serverloop.c"
static Buffer stderr_buffer  ;
#line 59 "serverloop.c"
static int fdin  ;
#line 60 "serverloop.c"
static int fdout  ;
#line 62 "serverloop.c"
static int fderr  ;
#line 63 "serverloop.c"
static long stdin_bytes  =    0L;
#line 64 "serverloop.c"
static long stdout_bytes  =    0L;
#line 65 "serverloop.c"
static long stderr_bytes  =    0L;
#line 66 "serverloop.c"
static long fdout_bytes  =    0L;
#line 67 "serverloop.c"
static int stdin_eof  =    0;
#line 68 "serverloop.c"
static int fdout_eof  =    0;
#line 69 "serverloop.c"
static int fderr_eof  =    0;
#line 70 "serverloop.c"
static int connection_in___0  ;
#line 71 "serverloop.c"
static int connection_out___0  ;
#line 72 "serverloop.c"
static unsigned int buffer_high  ;
#line 73 "serverloop.c"
static int max_fd  ;
#line 84 "serverloop.c"
static pid_t child_pid  ;
#line 85 "serverloop.c"
static int volatile   child_terminated  ;
#line 86 "serverloop.c"
static int volatile   child_has_selected  ;
#line 87 "serverloop.c"
static int volatile   child_wait_status  ;
#line 89
void server_init_dispatch(void) ;
#line 91 "serverloop.c"
void sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  pid_t wait_pid ;
  union __anonunion_78 __constr_expr_0 ;
  union __anonunion_79 __constr_expr_1 ;
  int *tmp___0 ;

  {
#line 94
  tmp = __errno_location();
#line 94
  save_errno = *tmp;
#line 97
  debug("Received SIGCHLD.");
#line 98
  wait_pid = wait((union wait *)((int *)(& child_wait_status)));
#line 99
  if (wait_pid != -1) {
#line 100
    if (wait_pid != child_pid) {
#line 101
      error("Strange, got SIGCHLD and wait returned pid %d but child is %d", wait_pid,
            child_pid);
    }
#line 103
    __constr_expr_0.__in = child_wait_status;
#line 103
    if ((__constr_expr_0.__i & 127) == 0) {
#line 105
      child_terminated = (int volatile   )1;
#line 106
      child_has_selected = (int volatile   )0;
    } else {
#line 103
      __constr_expr_1.__in = child_wait_status;
#line 103
      if ((int )((signed char )((__constr_expr_1.__i & 127) + 1)) >> 1 > 0) {
#line 105
        child_terminated = (int volatile   )1;
#line 106
        child_has_selected = (int volatile   )0;
      }
    }
  }
#line 109
  signal(17, & sigchld_handler);
#line 110
  tmp___0 = __errno_location();
#line 110
  *tmp___0 = save_errno;
#line 111
  return;
}
}
#line 112 "serverloop.c"
void sigchld_handler2(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 115
  tmp = __errno_location();
#line 115
  save_errno = *tmp;
#line 116
  debug("Received SIGCHLD.");
#line 117
  child_terminated = (int volatile   )1;
#line 118
  child_has_selected = (int volatile   )0;
#line 119
  tmp___0 = __errno_location();
#line 119
  *tmp___0 = save_errno;
#line 120
  return;
}
}
#line 126 "serverloop.c"
void make_packets_from_stderr_data(void) 
{ int len ;
  unsigned int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
#line 132
  while (1) {
#line 132
    tmp___2 = buffer_len(& stderr_buffer);
#line 132
    if (tmp___2 > 0U) {
#line 132
      tmp___3 = packet_not_very_much_data_to_write();
#line 132
      if (! tmp___3) {
#line 132
        break;
      }
    } else {
#line 132
      break;
    }
#line 134
    tmp = buffer_len(& stderr_buffer);
#line 134
    len = (int )tmp;
#line 135
    tmp___0 = packet_is_interactive();
#line 135
    if (tmp___0) {
#line 136
      if (len > 512) {
#line 137
        len = 512;
      }
    } else {
#line 140
      if (len > max_packet_size) {
#line 141
        len = max_packet_size;
      }
    }
#line 143
    packet_start(18);
#line 144
    tmp___1 = buffer_ptr(& stderr_buffer);
#line 144
    packet_put_string((char const   *)tmp___1, (unsigned int )len);
#line 145
    packet_send();
#line 146
    buffer_consume(& stderr_buffer, (unsigned int )len);
#line 147
    stderr_bytes += (long )len;
  }
#line 149
  return;
}
}
#line 155 "serverloop.c"
void make_packets_from_stdout_data(void) 
{ int len ;
  unsigned int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
#line 161
  while (1) {
#line 161
    tmp___2 = buffer_len(& stdout_buffer);
#line 161
    if (tmp___2 > 0U) {
#line 161
      tmp___3 = packet_not_very_much_data_to_write();
#line 161
      if (! tmp___3) {
#line 161
        break;
      }
    } else {
#line 161
      break;
    }
#line 163
    tmp = buffer_len(& stdout_buffer);
#line 163
    len = (int )tmp;
#line 164
    tmp___0 = packet_is_interactive();
#line 164
    if (tmp___0) {
#line 165
      if (len > 512) {
#line 166
        len = 512;
      }
    } else {
#line 169
      if (len > max_packet_size) {
#line 170
        len = max_packet_size;
      }
    }
#line 172
    packet_start(17);
#line 173
    tmp___1 = buffer_ptr(& stdout_buffer);
#line 173
    packet_put_string((char const   *)tmp___1, (unsigned int )len);
#line 174
    packet_send();
#line 175
    buffer_consume(& stdout_buffer, (unsigned int )len);
#line 176
    stdout_bytes += (long )len;
  }
#line 178
  return;
}
}
#line 186 "serverloop.c"
void wait_until_can_do_something(fd_set *readset , fd_set *writeset , unsigned int max_time_milliseconds ) 
{ struct timeval tv ;
  struct timeval *tvp ;
  int ret ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;

  {
  retry_select: 
#line 197
  while (1) {
#line 197
    __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readset->__fds_bits[0]): "memory");
#line 197
    break;
  }
#line 198
  while (1) {
#line 198
    __asm__  volatile   ("cld; rep; stosl": "=c" (__d0___0), "=D" (__d1___0): "a" (0),
                         "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& writeset->__fds_bits[0]): "memory");
#line 198
    break;
  }
#line 200
  if (compat20) {
#line 202
    tmp = channel_not_very_much_buffered_data();
#line 202
    if (tmp) {
#line 203
      __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
  } else {
#line 209
    tmp___0 = buffer_len(& stdin_buffer);
#line 209
    if (tmp___0 < buffer_high) {
#line 209
      tmp___1 = channel_not_very_much_buffered_data();
#line 209
      if (tmp___1) {
#line 211
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
#line 216
    tmp___2 = packet_not_very_much_data_to_write();
#line 216
    if (tmp___2) {
#line 217
      if (! fdout_eof) {
#line 218
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
#line 219
      if (! fderr_eof) {
#line 220
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
#line 226
    if (fdin != -1) {
#line 226
      tmp___3 = buffer_len(& stdin_buffer);
#line 226
      if (tmp___3 > 0U) {
#line 227
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
  }
#line 230
  channel_prepare_select(readset, writeset);
#line 236
  tmp___4 = packet_have_data_to_write();
#line 236
  if (tmp___4) {
#line 237
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 240
  tmp___5 = channel_max_fd();
#line 240
  if (tmp___5 > max_fd) {
#line 241
    max_fd = channel_max_fd();
  }
#line 247
  if (child_terminated) {
#line 247
    tmp___6 = packet_not_very_much_data_to_write();
#line 247
    if (tmp___6) {
#line 248
      if (max_time_milliseconds == 0U) {
#line 249
        max_time_milliseconds = 100U;
      }
    }
  }
#line 251
  if (max_time_milliseconds == 0U) {
#line 252
    tvp = (struct timeval *)((void *)0);
  } else {
#line 254
    tv.tv_sec = (long )(max_time_milliseconds / 1000U);
#line 255
    tv.tv_usec = (long )(1000U * (max_time_milliseconds % 1000U));
#line 256
    tvp = & tv;
  }
#line 258
  if ((unsigned int )tvp != (unsigned int )((void *)0)) {
#line 259
    debug("tvp!=NULL kid %d mili %d", child_terminated, max_time_milliseconds);
  }
#line 262
  ret = select(max_fd + 1, (fd_set * __restrict  )readset, (fd_set * __restrict  )writeset,
               (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )tvp);
#line 264
  if (ret < 0) {
#line 265
    tmp___9 = __errno_location();
#line 265
    if (*tmp___9 != 4) {
#line 266
      tmp___7 = __errno_location();
#line 266
      tmp___8 = strerror(*tmp___7);
#line 266
      error("select: %.100s", tmp___8);
    } else {
      goto retry_select;
    }
  }
#line 271
  if (child_terminated) {
#line 272
    child_has_selected = (int volatile   )1;
  }
#line 273
  return;
}
}
#line 279 "serverloop.c"
void process_input(fd_set *readset ) 
{ int len ;
  char buf___1[16384] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  register char __result ;
  int *tmp___3 ;
  int *tmp___4 ;
  register char __result___0 ;
  int *tmp___5 ;
  int *tmp___6 ;
  register char __result___1 ;

  {
#line 286
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 286
  if (__result) {
#line 287
    len = read(connection_in___0, (void *)(buf___1), sizeof(buf___1));
#line 288
    if (len == 0) {
#line 289
      verbose("Connection closed by remote host.");
#line 290
      fatal_cleanup();
    } else {
#line 291
      if (len < 0) {
#line 292
        tmp___1 = __errno_location();
#line 292
        if (*tmp___1 != 4) {
#line 292
          tmp___2 = __errno_location();
#line 292
          if (*tmp___2 != 11) {
#line 293
            tmp = __errno_location();
#line 293
            tmp___0 = strerror(*tmp);
#line 293
            verbose("Read error from remote host: %.100s", tmp___0);
#line 294
            fatal_cleanup();
          }
        }
      } else {
#line 298
        packet_process_incoming((char const   *)(buf___1), (unsigned int )len);
      }
    }
  }
#line 301
  if (compat20) {
#line 302
    return;
  }
#line 305
  if (! fdout_eof) {
#line 305
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "cc");
#line 305
    if (__result___0) {
#line 306
      len = read(fdout, (void *)(buf___1), sizeof(buf___1));
#line 307
      if (len < 0) {
#line 307
        tmp___3 = __errno_location();
#line 307
        if (! (*tmp___3 == 4)) {
#line 307
          tmp___4 = __errno_location();
#line 307
          if (! (*tmp___4 == 11)) {
            goto _L;
          }
        }
      } else {
        _L: /* CIL Label */ 
#line 309
        if (len <= 0) {
#line 310
          fdout_eof = 1;
        } else {
#line 312
          buffer_append(& stdout_buffer, (char const   *)(buf___1), (unsigned int )len);
#line 313
          fdout_bytes += (long )len;
        }
      }
    }
  }
#line 317
  if (! fderr_eof) {
#line 317
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___1): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "cc");
#line 317
    if (__result___1) {
#line 318
      len = read(fderr, (void *)(buf___1), sizeof(buf___1));
#line 319
      if (len < 0) {
#line 319
        tmp___5 = __errno_location();
#line 319
        if (! (*tmp___5 == 4)) {
#line 319
          tmp___6 = __errno_location();
#line 319
          if (! (*tmp___6 == 11)) {
            goto _L___0;
          }
        }
      } else {
        _L___0: /* CIL Label */ 
#line 321
        if (len <= 0) {
#line 322
          fderr_eof = 1;
        } else {
#line 324
          buffer_append(& stderr_buffer, (char const   *)(buf___1), (unsigned int )len);
        }
      }
    }
  }
#line 327
  return;
}
}
#line 332 "serverloop.c"
void process_output(fd_set *writeset ) 
{ int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  register char __result ;
  register char __result___0 ;

  {
#line 338
  if (! compat20) {
#line 338
    if (fdin != -1) {
#line 338
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))),
                           "m" (writeset->__fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "cc");
#line 338
      if (__result) {
#line 339
        tmp = buffer_len(& stdin_buffer);
#line 339
        tmp___0 = buffer_ptr(& stdin_buffer);
#line 339
        len = write(fdin, (void const   *)tmp___0, tmp);
#line 341
        if (len < 0) {
#line 341
          tmp___1 = __errno_location();
#line 341
          if (! (*tmp___1 == 4)) {
#line 341
            tmp___2 = __errno_location();
#line 341
            if (! (*tmp___2 == 11)) {
              goto _L;
            }
          }
        } else {
          _L: /* CIL Label */ 
#line 343
          if (len <= 0) {
#line 347
            if (fdin != fdout) {
#line 348
              close(fdin);
            } else {
#line 350
              shutdown(fdin, 1);
            }
#line 352
            fdin = -1;
          } else {
#line 355
            buffer_consume(& stdin_buffer, (unsigned int )len);
#line 357
            stdin_bytes += (long )len;
          }
        }
      }
    }
  }
#line 361
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->__fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 361
  if (__result___0) {
#line 362
    packet_write_poll();
  }
#line 363
  return;
}
}
#line 369 "serverloop.c"
void drain_output(void) 
{ unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;

  {
#line 373
  tmp___2 = buffer_len(& stdout_buffer);
#line 373
  if (tmp___2 > 0U) {
#line 374
    packet_start(17);
#line 375
    tmp = buffer_len(& stdout_buffer);
#line 375
    tmp___0 = buffer_ptr(& stdout_buffer);
#line 375
    packet_put_string((char const   *)tmp___0, tmp);
#line 377
    packet_send();
#line 379
    tmp___1 = buffer_len(& stdout_buffer);
#line 379
    stdout_bytes = (long )((unsigned long )stdout_bytes + (unsigned long )tmp___1);
  }
#line 382
  tmp___6 = buffer_len(& stderr_buffer);
#line 382
  if (tmp___6 > 0U) {
#line 383
    packet_start(18);
#line 384
    tmp___3 = buffer_len(& stderr_buffer);
#line 384
    tmp___4 = buffer_ptr(& stderr_buffer);
#line 384
    packet_put_string((char const   *)tmp___4, tmp___3);
#line 386
    packet_send();
#line 388
    tmp___5 = buffer_len(& stderr_buffer);
#line 388
    stderr_bytes = (long )((unsigned long )stderr_bytes + (unsigned long )tmp___5);
  }
#line 391
  packet_write_wait();
#line 392
  return;
}
}
#line 394 "serverloop.c"
void process_buffered_input_packets(void) 
{ 

  {
#line 397
  dispatch_run(1, (int *)((void *)0), (void *)0);
#line 398
  return;
}
}
#line 407 "serverloop.c"
void server_loop(pid_t pid , int fdin_arg , int fdout_arg , int fderr_arg ) 
{ fd_set readset ;
  fd_set writeset ;
  int wait_status ;
  pid_t wait_pid ;
  int waiting_termination ;
  unsigned int max_time_milliseconds ;
  unsigned int previous_stdout_buffer_bytes ;
  unsigned int stdout_buffer_bytes ;
  int type ;
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *s ;
  char *cp ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  union __anonunion_80 __constr_expr_0 ;
  union __anonunion_81 __constr_expr_1 ;
  int plen ;
  union __anonunion_82 __constr_expr_2 ;
  union __anonunion_83 __constr_expr_3 ;
  union __anonunion_84 __constr_expr_4 ;

  {
#line 413
  waiting_termination = 0;
#line 419
  debug("Entering interactive session.");
#line 422
  child_pid = pid;
#line 423
  child_terminated = (int volatile   )0;
#line 424
  child_has_selected = (int volatile   )0;
#line 425
  signal(17, & sigchld_handler);
#line 426
  signal(13, (void (*)(int  ))1);
#line 429
  fdin = fdin_arg;
#line 430
  fdout = fdout_arg;
#line 431
  fderr = fderr_arg;
#line 434
  set_nonblock(fdin);
#line 435
  set_nonblock(fdout);
#line 437
  if (fderr != -1) {
#line 438
    set_nonblock(fderr);
  }
#line 440
  connection_in___0 = packet_get_connection_in();
#line 441
  connection_out___0 = packet_get_connection_out();
#line 443
  previous_stdout_buffer_bytes = 0U;
#line 446
  tmp = packet_is_interactive();
#line 446
  if (tmp) {
#line 447
    buffer_high = 4096U;
  } else {
#line 449
    buffer_high = 65536U;
  }
#line 452
  max_fd = fdin;
#line 453
  if (fdout > max_fd) {
#line 454
    max_fd = fdout;
  }
#line 455
  if (fderr != -1) {
#line 455
    if (fderr > max_fd) {
#line 456
      max_fd = fderr;
    }
  }
#line 457
  if (connection_in___0 > max_fd) {
#line 458
    max_fd = connection_in___0;
  }
#line 459
  if (connection_out___0 > max_fd) {
#line 460
    max_fd = connection_out___0;
  }
#line 463
  buffer_init(& stdin_buffer);
#line 464
  buffer_init(& stdout_buffer);
#line 465
  buffer_init(& stderr_buffer);
#line 473
  if (fderr == -1) {
#line 474
    fderr_eof = 1;
  }
#line 476
  server_init_dispatch();
#line 479
  while (1) {
#line 482
    process_buffered_input_packets();
#line 488
    if (stdin_eof) {
#line 488
      if (fdin != -1) {
#line 488
        tmp___0 = buffer_len(& stdin_buffer);
#line 488
        if (tmp___0 == 0U) {
#line 492
          if (fdin != fdout) {
#line 493
            close(fdin);
          } else {
#line 495
            shutdown(fdin, 1);
          }
#line 497
          fdin = -1;
        }
      }
    }
#line 500
    make_packets_from_stderr_data();
#line 509
    max_time_milliseconds = 0U;
#line 510
    stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 511
    if (stdout_buffer_bytes != 0U) {
#line 511
      if (stdout_buffer_bytes < 256U) {
#line 511
        if (stdout_buffer_bytes != previous_stdout_buffer_bytes) {
#line 514
          max_time_milliseconds = 10U;
        } else {
#line 517
          make_packets_from_stdout_data();
        }
      } else {
#line 517
        make_packets_from_stdout_data();
      }
    } else {
#line 517
      make_packets_from_stdout_data();
    }
#line 519
    previous_stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 522
    tmp___1 = packet_not_very_much_data_to_write();
#line 522
    if (tmp___1) {
#line 523
      channel_output_poll();
    }
#line 530
    if (fdout_eof) {
#line 530
      if (fderr_eof) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 530
      if (child_terminated) {
#line 530
        if (child_has_selected) {
          _L: /* CIL Label */ 
#line 530
          tmp___5 = packet_have_data_to_write();
#line 530
          if (! tmp___5) {
#line 530
            tmp___6 = buffer_len(& stdout_buffer);
#line 530
            if (tmp___6 == 0U) {
#line 530
              tmp___7 = buffer_len(& stderr_buffer);
#line 530
              if (tmp___7 == 0U) {
#line 535
                tmp___2 = channel_still_open();
#line 535
                if (! tmp___2) {
#line 536
                  break;
                }
#line 537
                if (! waiting_termination) {
#line 538
                  s = "Waiting for forwarded connections to terminate...\r\n";
#line 540
                  waiting_termination = 1;
#line 541
                  tmp___3 = strlen(s);
#line 541
                  buffer_append(& stderr_buffer, s, tmp___3);
#line 544
                  cp = channel_open_message();
#line 545
                  tmp___4 = strlen((char const   *)cp);
#line 545
                  buffer_append(& stderr_buffer, (char const   *)cp, tmp___4);
#line 546
                  xfree((void *)cp);
                }
              }
            }
          }
        }
      }
    }
#line 550
    wait_until_can_do_something(& readset, & writeset, max_time_milliseconds);
#line 554
    channel_after_select(& readset, & writeset);
#line 557
    process_input(& readset);
#line 560
    process_output(& writeset);
  }
#line 566
  drain_output();
#line 568
  debug("End of interactive session; stdin %ld, stdout (read %ld, sent %ld), stderr %ld bytes.",
        stdin_bytes, fdout_bytes, stdout_bytes, stderr_bytes);
#line 572
  buffer_free(& stdin_buffer);
#line 573
  buffer_free(& stdout_buffer);
#line 574
  buffer_free(& stderr_buffer);
#line 577
  if (fdout != -1) {
#line 578
    close(fdout);
  }
#line 579
  fdout = -1;
#line 580
  fdout_eof = 1;
#line 581
  if (fderr != -1) {
#line 582
    close(fderr);
  }
#line 583
  fderr = -1;
#line 584
  fderr_eof = 1;
#line 585
  if (fdin != -1) {
#line 586
    close(fdin);
  }
#line 587
  fdin = -1;
#line 590
  channel_stop_listening();
#line 593
  wait_pid = wait((union wait *)(& wait_status));
#line 594
  if (wait_pid < 0) {
#line 600
    if (child_terminated) {
#line 601
      wait_status = (int )child_wait_status;
    } else {
#line 603
      tmp___8 = __errno_location();
#line 603
      tmp___9 = strerror(*tmp___8);
#line 603
      packet_disconnect("wait: %.100s", tmp___9);
    }
  } else {
#line 606
    if (wait_pid != pid) {
#line 607
      error("Strange, wait returned pid %d, expected %d", wait_pid, pid);
    }
  }
#line 612
  signal(17, (void (*)(int  ))0);
#line 615
  __constr_expr_2.__in = wait_status;
#line 615
  if ((__constr_expr_2.__i & 127) == 0) {
#line 617
    __constr_expr_0.__in = wait_status;
#line 617
    debug("Command exited with status %d.", (__constr_expr_0.__i & 65280) >> 8);
#line 618
    packet_start(20);
#line 619
    __constr_expr_1.__in = wait_status;
#line 619
    packet_put_int((unsigned int )((__constr_expr_1.__i & 65280) >> 8));
#line 620
    packet_send();
#line 621
    packet_write_wait();
#line 630
    while (1) {
#line 632
      type = packet_read(& plen);
#line 630
      if (! (type != 33)) {
#line 630
        break;
      }
    }
#line 636
    debug("Received exit confirmation.");
#line 637
    return;
  }
#line 640
  __constr_expr_4.__in = wait_status;
#line 640
  if ((int )((signed char )((__constr_expr_4.__i & 127) + 1)) >> 1 > 0) {
#line 641
    __constr_expr_3.__in = wait_status;
#line 641
    packet_disconnect("Command terminated on signal %d.", __constr_expr_3.__i & 127);
  }
#line 645
  packet_disconnect("wait returned status %04x.", wait_status);
#line 647
  return;
}
}
#line 649 "serverloop.c"
void server_loop2(void) 
{ fd_set readset ;
  fd_set writeset ;
  int had_channel ;
  int status ;
  pid_t pid ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 653
  had_channel = 0;
#line 657
  debug("Entering interactive session for SSH2.");
#line 659
  signal(17, & sigchld_handler2);
#line 660
  signal(13, (void (*)(int  ))1);
#line 661
  child_terminated = (int volatile   )0;
#line 662
  connection_in___0 = packet_get_connection_in();
#line 663
  connection_out___0 = packet_get_connection_out();
#line 664
  max_fd = connection_in___0;
#line 665
  if (connection_out___0 > max_fd) {
#line 666
    max_fd = connection_out___0;
  }
#line 667
  server_init_dispatch();
#line 669
  while (1) {
#line 670
    process_buffered_input_packets();
#line 671
    if (! had_channel) {
#line 671
      tmp = channel_still_open();
#line 671
      if (tmp) {
#line 672
        had_channel = 1;
      }
    }
#line 673
    if (had_channel) {
#line 673
      tmp___0 = channel_still_open();
#line 673
      if (! tmp___0) {
#line 674
        debug("!channel_still_open.");
#line 675
        break;
      }
    }
#line 677
    tmp___1 = packet_not_very_much_data_to_write();
#line 677
    if (tmp___1) {
#line 678
      channel_output_poll();
    }
#line 679
    wait_until_can_do_something(& readset, & writeset, 0U);
#line 680
    if (child_terminated) {
#line 680
      if (child_has_selected) {
#line 682
        while (1) {
#line 682
          pid = waitpid(-1, & status, 1);
#line 682
          if (! (pid > 0)) {
#line 682
            break;
          }
#line 683
          session_close_by_pid(pid, status);
        }
#line 684
        child_terminated = (int volatile   )0;
#line 685
        child_has_selected = (int volatile   )0;
#line 686
        signal(17, & sigchld_handler2);
      }
    }
#line 688
    channel_after_select(& readset, & writeset);
#line 689
    process_input(& readset);
#line 690
    process_output(& writeset);
  }
#line 692
  signal(17, (void (*)(int  ))0);
#line 693
  while (1) {
#line 693
    pid = waitpid(-1, & status, 1);
#line 693
    if (! (pid > 0)) {
#line 693
      break;
    }
#line 694
    session_close_by_pid(pid, status);
  }
#line 695
  channel_stop_listening();
#line 696
  return;
}
}
#line 698 "serverloop.c"
void server_input_stdin_data(int type , int plen , void *ctxt ) 
{ char *data ;
  unsigned int data_len ;
  int _p ;
  int _e ;

  {
#line 706
  if (fdin == -1) {
#line 707
    return;
  }
#line 708
  data = packet_get_string(& data_len);
#line 709
  while (1) {
#line 709
    _p = plen;
#line 709
    _e = (int )(4U + data_len);
#line 709
    if (_p != _e) {
#line 709
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "serverloop.c", 709);
#line 709
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 709
    break;
  }
#line 710
  buffer_append(& stdin_buffer, (char const   *)data, data_len);
#line 711
  memset((void *)data, 0, data_len);
#line 712
  xfree((void *)data);
#line 713
  return;
}
}
#line 715 "serverloop.c"
void server_input_eof(int type , int plen , void *ctxt ) 
{ int _p ;
  int _e ;

  {
#line 723
  debug("EOF received for stdin.");
#line 724
  while (1) {
#line 724
    _p = plen;
#line 724
    _e = 0;
#line 724
    if (_p != _e) {
#line 724
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "serverloop.c", 724);
#line 724
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 724
    break;
  }
#line 725
  stdin_eof = 1;
#line 726
  return;
}
}
#line 728 "serverloop.c"
void server_input_window_size(int type , int plen , void *ctxt ) 
{ int row ;
  unsigned int tmp ;
  int col ;
  unsigned int tmp___0 ;
  int xpixel ;
  unsigned int tmp___1 ;
  int ypixel ;
  unsigned int tmp___2 ;
  int _p ;
  int _e ;

  {
#line 731
  tmp = packet_get_int();
#line 731
  row = (int )tmp;
#line 732
  tmp___0 = packet_get_int();
#line 732
  col = (int )tmp___0;
#line 733
  tmp___1 = packet_get_int();
#line 733
  xpixel = (int )tmp___1;
#line 734
  tmp___2 = packet_get_int();
#line 734
  ypixel = (int )tmp___2;
#line 736
  debug("Window change received.");
#line 737
  while (1) {
#line 737
    _p = plen;
#line 737
    _e = 16;
#line 737
    if (_p != _e) {
#line 737
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "serverloop.c", 737);
#line 737
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 737
    break;
  }
#line 738
  if (fdin != -1) {
#line 739
    pty_change_window_size(fdin, row, col, xpixel, ypixel);
  }
#line 740
  return;
}
}
#line 742 "serverloop.c"
int input_direct_tcpip(void) 
{ int sock ;
  char *target ;
  char *originator ;
  int target_port ;
  int originator_port ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int _len ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 749
  target = packet_get_string((unsigned int *)((void *)0));
#line 750
  tmp = packet_get_int();
#line 750
  target_port = (int )tmp;
#line 751
  originator = packet_get_string((unsigned int *)((void *)0));
#line 752
  tmp___0 = packet_get_int();
#line 752
  originator_port = (int )tmp___0;
#line 753
  while (1) {
#line 753
    tmp___1 = packet_remaining();
#line 753
    _len = tmp___1;
#line 753
    if (_len > 0) {
#line 753
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
          753);
#line 753
      packet_disconnect("Packet integrity error.");
    }
#line 753
    break;
  }
#line 755
  debug("open direct-tcpip: from %s port %d to %s port %d", originator, originator_port,
        target, target_port);
#line 759
  if (no_port_forwarding_flag) {
#line 760
    xfree((void *)target);
#line 761
    xfree((void *)originator);
#line 762
    return (-1);
  } else {
#line 759
    if (! options.allow_tcp_forwarding) {
#line 760
      xfree((void *)target);
#line 761
      xfree((void *)originator);
#line 762
      return (-1);
    }
  }
#line 764
  sock = channel_connect_to((char const   *)target, (unsigned short )target_port);
#line 765
  xfree((void *)target);
#line 766
  xfree((void *)originator);
#line 767
  if (sock < 0) {
#line 768
    return (-1);
  }
#line 769
  tmp___2 = xstrdup("direct-tcpip");
#line 769
  tmp___3 = channel_new((char *)"direct-tcpip", 4, sock, sock, -1, 32768, 16384, 0,
                        tmp___2, 1);
#line 769
  return (tmp___3);
}
}
#line 774 "serverloop.c"
void server_input_channel_open(int type , int plen , void *ctxt ) 
{ Channel *c ;
  char *ctype ;
  int id ;
  unsigned int len ;
  int rchan ;
  int rmaxpack ;
  int rwindow ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  int _len ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___10 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;

  {
#line 777
  c = (Channel *)((void *)0);
#line 785
  ctype = packet_get_string(& len);
#line 786
  tmp = packet_get_int();
#line 786
  rchan = (int )tmp;
#line 787
  tmp___0 = packet_get_int();
#line 787
  rwindow = (int )tmp___0;
#line 788
  tmp___1 = packet_get_int();
#line 788
  rmaxpack = (int )tmp___1;
#line 790
  debug("server_input_channel_open: ctype %s rchan %d win %d max %d", ctype, rchan,
        rwindow, rmaxpack);
#line 793
  if (0) {
#line 793
    __s1_len___0 = strlen((char const   *)ctype);
#line 793
    __s2_len___0 = strlen("session");
#line 793
    if (! ((unsigned int )((void const   *)(ctype + 1)) - (unsigned int )((void const   *)ctype) == 1U)) {
      goto _L___2;
    } else {
#line 793
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 793
        if (! ((unsigned int )((void const   *)("session" + 1)) - (unsigned int )((void const   *)"session") == 1U)) {
#line 793
          tmp___24 = 1;
        } else {
#line 793
          if (__s2_len___0 >= 4U) {
#line 793
            tmp___24 = 1;
          } else {
#line 793
            tmp___24 = 0;
          }
        }
      } else {
#line 793
        tmp___24 = 0;
      }
    }
#line 793
    if (tmp___24) {
#line 793
      tmp___20 = __builtin_strcmp((char const   *)ctype, "session");
    } else {
#line 793
      tmp___23 = __builtin_strcmp((char const   *)ctype, "session");
#line 793
      tmp___20 = tmp___23;
    }
  } else {
#line 793
    tmp___23 = __builtin_strcmp((char const   *)ctype, "session");
#line 793
    tmp___20 = tmp___23;
  }
#line 793
  if (tmp___20 == 0) {
#line 794
    debug("open session");
#line 795
    while (1) {
#line 795
      tmp___2 = packet_remaining();
#line 795
      _len = tmp___2;
#line 795
      if (_len > 0) {
#line 795
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
            795);
#line 795
        packet_disconnect("Packet integrity error.");
      }
#line 795
      break;
    }
#line 803
    tmp___3 = xstrdup("server-session");
#line 803
    id = channel_new(ctype, 10, -1, -1, -1, 0, 16384, 0, tmp___3, 1);
#line 806
    tmp___4 = session_open(id);
#line 806
    if (tmp___4 == 1) {
#line 807
      channel_register_callback(id, 98, & session_input_channel_req, (void *)0);
#line 809
      channel_register_cleanup(id, & session_close_by_channel);
#line 810
      c = channel_lookup(id);
    } else {
#line 812
      debug("session open failed, free channel %d", id);
#line 813
      channel_free(id);
    }
  } else {
#line 815
    if (0) {
#line 815
      __s1_len = strlen((char const   *)ctype);
#line 815
      __s2_len = strlen("direct-tcpip");
#line 815
      if (! ((unsigned int )((void const   *)(ctype + 1)) - (unsigned int )((void const   *)ctype) == 1U)) {
        goto _L___0;
      } else {
#line 815
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 815
          if (! ((unsigned int )((void const   *)("direct-tcpip" + 1)) - (unsigned int )((void const   *)"direct-tcpip") == 1U)) {
#line 815
            tmp___14 = 1;
          } else {
#line 815
            if (__s2_len >= 4U) {
#line 815
              tmp___14 = 1;
            } else {
#line 815
              tmp___14 = 0;
            }
          }
        } else {
#line 815
          tmp___14 = 0;
        }
      }
#line 815
      if (tmp___14) {
#line 815
        tmp___10 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
      } else {
#line 815
        tmp___13 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
#line 815
        tmp___10 = tmp___13;
      }
    } else {
#line 815
      tmp___13 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
#line 815
      tmp___10 = tmp___13;
    }
#line 815
    if (tmp___10 == 0) {
#line 816
      id = input_direct_tcpip();
#line 817
      if (id >= 0) {
#line 818
        c = channel_lookup(id);
      }
    }
  }
#line 820
  if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 821
    debug("confirm %s", ctype);
#line 822
    c->remote_id = rchan;
#line 823
    c->remote_window = rwindow;
#line 824
    c->remote_maxpacket = rmaxpack;
#line 826
    packet_start(91);
#line 827
    packet_put_int((unsigned int )c->remote_id);
#line 828
    packet_put_int((unsigned int )c->self);
#line 829
    packet_put_int((unsigned int )c->local_window);
#line 830
    packet_put_int((unsigned int )c->local_maxpacket);
#line 831
    packet_send();
  } else {
#line 833
    debug("failure %s", ctype);
#line 834
    packet_start(92);
#line 835
    packet_put_int((unsigned int )rchan);
#line 836
    packet_put_int(1U);
#line 837
    packet_put_cstring("bla bla");
#line 838
    packet_put_cstring("");
#line 839
    packet_send();
  }
#line 841
  xfree((void *)ctype);
#line 842
  return;
}
}
#line 844 "serverloop.c"
void server_init_dispatch_20(void) 
{ 

  {
#line 847
  debug("server_init_dispatch_20");
#line 848
  dispatch_init(& dispatch_protocol_error);
#line 849
  dispatch_set(97, & channel_input_oclose);
#line 850
  dispatch_set(94, & channel_input_data);
#line 851
  dispatch_set(96, & channel_input_ieof);
#line 852
  dispatch_set(95, & channel_input_extended_data);
#line 853
  dispatch_set(90, & server_input_channel_open);
#line 854
  dispatch_set(91, & channel_input_open_confirmation);
#line 855
  dispatch_set(92, & channel_input_open_failure);
#line 856
  dispatch_set(98, & channel_input_channel_request);
#line 857
  dispatch_set(93, & channel_input_window_adjust);
#line 858
  return;
}
}
#line 859 "serverloop.c"
void server_init_dispatch_13(void) 
{ 

  {
#line 862
  debug("server_init_dispatch_13");
#line 863
  dispatch_init((dispatch_fn *)((void *)0));
#line 864
  dispatch_set(19, & server_input_eof);
#line 865
  dispatch_set(16, & server_input_stdin_data);
#line 866
  dispatch_set(11, & server_input_window_size);
#line 867
  dispatch_set(24, & channel_input_close);
#line 868
  dispatch_set(25, & channel_input_close_confirmation);
#line 869
  dispatch_set(23, & channel_input_data);
#line 870
  dispatch_set(21, & channel_input_open_confirmation);
#line 871
  dispatch_set(22, & channel_input_open_failure);
#line 872
  dispatch_set(29, & channel_input_port_open);
#line 873
  return;
}
}
#line 874 "serverloop.c"
void server_init_dispatch_15(void) 
{ 

  {
#line 877
  server_init_dispatch_13();
#line 878
  debug("server_init_dispatch_15");
#line 879
  dispatch_set(24, & channel_input_ieof);
#line 880
  dispatch_set(25, & channel_input_oclose);
#line 881
  return;
}
}
#line 882 "serverloop.c"
void server_init_dispatch(void) 
{ 

  {
#line 885
  if (compat20) {
#line 886
    server_init_dispatch_20();
  } else {
#line 887
    if (compat13) {
#line 888
      server_init_dispatch_13();
    } else {
#line 890
      server_init_dispatch_15();
    }
  }
#line 891
  return;
}
}
#line 1 "md5crypt.o"
#line 1 "session.o"
#line 106 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socketpair(int __domain , int __type , int __protocol ,
                                                    int *__fds ) ;
#line 84 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strcpy(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 194
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 493 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 504
extern  __attribute__((__nothrow__)) int execve(char const   *__path , char * const  *__argv ,
                                                char * const  *__envp )  __attribute__((__nonnull__(1))) ;
#line 526
extern  __attribute__((__nothrow__)) int execl(char const   *__path , char const   *__arg 
                                               , ...)  __attribute__((__nonnull__(1))) ;
#line 684
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 774 "/usr/include/stdio.h"
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 780
extern int pclose(FILE *__stream ) ;
#line 79 "/usr/include/pwd.h"
extern void endpwent(void) ;
#line 69 "/usr/include/grp.h"
extern void endgrent(void) ;
#line 199
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 257 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 116 "session.c"
Session *session_new(void) ;
#line 117
void session_set_fds(Session *s , int fdin___0 , int fdout___0 , int fderr___0 ) ;
#line 118
void session_pty_cleanup(Session *s ) ;
#line 119
void session_proctitle(Session *s ) ;
#line 120
void do_exec_pty(Session *s , char const   *command , struct passwd *pw ) ;
#line 121
void do_exec_no_pty(Session *s , char const   *command , struct passwd *pw ) ;
#line 122
void do_login(Session *s , char const   *command ) ;
#line 124
void do_child(char const   *command , struct passwd *pw , char const   *term , char const   *display ,
              char const   *auth_proto , char const   *auth_data , char const   *ttyname___0 ) ;
#line 144 "session.c"
static char *xauthfile  ;
#line 147 "session.c"
char *original_command  =    (char *)((void *)0);
#line 151 "session.c"
Session sessions[10]  ;
#line 165 "session.c"
void xauthfile_cleanup_proc(void *ignore ) 
{ char *p ;

  {
#line 168
  debug("xauthfile_cleanup_proc called");
#line 170
  if ((unsigned int )xauthfile != (unsigned int )((void *)0)) {
#line 172
    unlink((char const   *)xauthfile);
#line 173
    p = strrchr((char const   *)xauthfile, '/');
#line 174
    if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 175
      *p = (char )'\000';
#line 176
      rmdir((char const   *)xauthfile);
    }
#line 178
    xfree((void *)xauthfile);
#line 179
    xauthfile = (char *)((void *)0);
  }
#line 181
  return;
}
}
#line 187 "session.c"
void pty_cleanup_proc(void *session ) 
{ Session *s ;

  {
#line 190
  s = (Session *)session;
#line 191
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 192
    fatal("pty_cleanup_proc: no session");
  }
#line 193
  debug("pty_cleanup_proc: %s", s->tty);
#line 195
  if (s->pid != 0) {
#line 197
    record_logout(s->pid, (char const   *)(s->tty));
  }
#line 201
  pty_release((char const   *)(s->tty));
#line 202
  return;
}
}
#line 210 "session.c"
void do_authenticated(struct passwd *pw ) 
{ Session *s ;
  int type ;
  int fd ;
  int compression_level ;
  int enable_compression_after_reply ;
  int have_pty ;
  char *command ;
  int n_bytes ;
  int plen ;
  unsigned int proto_len ;
  unsigned int data_len ;
  unsigned int dlen ;
  int success ;
  int _p ;
  int _e ;
  unsigned int tmp ;
  int tmp___0 ;
  int _p___0 ;
  int _e___0 ;
  size_t tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  int _p___1 ;
  int _e___1 ;
  int _p___2 ;
  int _e___2 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  void *tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  unsigned int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int _p___3 ;
  int _e___3 ;
  int _p___4 ;
  int _e___4 ;
  int tmp___25 ;

  {
#line 215
  compression_level = 0;
#line 215
  enable_compression_after_reply = 0;
#line 216
  have_pty = 0;
#line 226
  alarm(0U);
#line 227
  if (startup_pipe != -1) {
#line 228
    close(startup_pipe);
#line 229
    startup_pipe = -1;
  }
#line 239
  if (! no_port_forwarding_flag) {
#line 239
    if (options.allow_tcp_forwarding) {
#line 240
      channel_permit_all_opens();
    }
  }
#line 242
  s = session_new();
#line 243
  s->pw = pw;
#line 256
  while (1) {
#line 257
    success = 0;
#line 260
    type = packet_read(& plen);
#line 263
    switch (type) {
    case 37: 
#line 265
    while (1) {
#line 265
      _p = plen;
#line 265
      _e = 4;
#line 265
      if (_p != _e) {
#line 265
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "session.c", 265);
#line 265
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 265
      break;
    }
#line 266
    tmp = packet_get_int();
#line 266
    compression_level = (int )tmp;
#line 267
    if (compression_level < 1) {
#line 268
      packet_send_debug("Received illegal compression level %d.", compression_level);
#line 270
      break;
    } else {
#line 267
      if (compression_level > 9) {
#line 268
        packet_send_debug("Received illegal compression level %d.", compression_level);
#line 270
        break;
      }
    }
#line 273
    enable_compression_after_reply = 1;
#line 274
    success = 1;
#line 275
    break;
    case 10: 
#line 278
    if (no_pty_flag) {
#line 279
      debug("Allocating a pty not permitted for this authentication.");
#line 280
      break;
    }
#line 282
    if (have_pty) {
#line 283
      packet_disconnect("Protocol error: you already have a pty.");
    }
#line 285
    debug("Allocating pty.");
#line 288
    tmp___0 = pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, (int )sizeof(s->tty));
#line 288
    if (! tmp___0) {
#line 290
      error("Failed to allocate pty.");
#line 291
      break;
    }
#line 293
    fatal_add_cleanup(& pty_cleanup_proc, (void *)s);
#line 294
    pty_setowner(pw, (char const   *)(s->tty));
#line 297
    s->term = packet_get_string(& dlen);
#line 298
    while (1) {
#line 298
      _p___0 = (int )dlen;
#line 298
      tmp___1 = strlen((char const   *)s->term);
#line 298
      _e___0 = (int )tmp___1;
#line 298
      if (_p___0 != _e___0) {
#line 298
        log("Packet integrity error (%d != %d) at %s:%d", _p___0, _e___0, "session.c",
            298);
#line 298
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 298
      break;
    }
#line 301
    n_bytes = (int )((unsigned int )plen - ((4U + dlen) + 16U));
#line 303
    if (0) {
#line 303
      __s1_len = strlen((char const   *)s->term);
#line 303
      __s2_len = strlen("");
#line 303
      if (! ((unsigned int )((void const   *)(s->term + 1)) - (unsigned int )((void const   *)s->term) == 1U)) {
        goto _L___0;
      } else {
#line 303
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 303
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 303
            tmp___11 = 1;
          } else {
#line 303
            if (__s2_len >= 4U) {
#line 303
              tmp___11 = 1;
            } else {
#line 303
              tmp___11 = 0;
            }
          }
        } else {
#line 303
          tmp___11 = 0;
        }
      }
#line 303
      if (tmp___11) {
#line 303
        tmp___7 = __builtin_strcmp((char const   *)s->term, "");
      } else {
#line 303
        tmp___10 = __builtin_strcmp((char const   *)s->term, "");
#line 303
        tmp___7 = tmp___10;
      }
    } else {
#line 303
      tmp___10 = __builtin_strcmp((char const   *)s->term, "");
#line 303
      tmp___7 = tmp___10;
    }
#line 303
    if (tmp___7 == 0) {
#line 304
      xfree((void *)s->term);
#line 305
      s->term = (char *)((void *)0);
    }
#line 308
    tmp___12 = packet_get_int();
#line 308
    s->row = (int )tmp___12;
#line 309
    tmp___13 = packet_get_int();
#line 309
    s->col = (int )tmp___13;
#line 310
    tmp___14 = packet_get_int();
#line 310
    s->xpixel = (int )tmp___14;
#line 311
    tmp___15 = packet_get_int();
#line 311
    s->ypixel = (int )tmp___15;
#line 312
    pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);
#line 315
    tty_parse_modes(s->ttyfd, & n_bytes);
#line 316
    while (1) {
#line 316
      _p___1 = plen;
#line 316
      _e___1 = (int )(((4U + dlen) + 16U) + (unsigned int )n_bytes);
#line 316
      if (_p___1 != _e___1) {
#line 316
        log("Packet integrity error (%d != %d) at %s:%d", _p___1, _e___1, "session.c",
            316);
#line 316
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 316
      break;
    }
#line 318
    session_proctitle(s);
#line 321
    success = 1;
#line 322
    have_pty = 1;
#line 323
    break;
    case 34: 
#line 326
    if (! options.x11_forwarding) {
#line 327
      packet_send_debug("X11 forwarding disabled in server configuration file.");
#line 328
      break;
    }
#line 330
    if (! options.xauth_location) {
#line 331
      packet_send_debug("No xauth program; cannot forward with spoofing.");
#line 332
      break;
    }
#line 334
    if (no_x11_forwarding_flag) {
#line 335
      packet_send_debug("X11 forwarding not permitted for this authentication.");
#line 336
      break;
    }
#line 338
    debug("Received request for X11 forwarding with auth spoofing.");
#line 339
    if ((unsigned int )s->display != (unsigned int )((void *)0)) {
#line 340
      packet_disconnect("Protocol error: X11 display already set.");
    }
#line 342
    s->auth_proto = packet_get_string(& proto_len);
#line 343
    s->auth_data = packet_get_string(& data_len);
#line 344
    while (1) {
#line 344
      _p___2 = plen;
#line 344
      _e___2 = (int )((((4U + proto_len) + 4U) + data_len) + 4U);
#line 344
      if (_p___2 != _e___2) {
#line 344
        log("Packet integrity error (%d != %d) at %s:%d", _p___2, _e___2, "session.c",
            344);
#line 344
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 344
      break;
    }
#line 346
    tmp___17 = packet_get_protocol_flags();
#line 346
    if (tmp___17 & 1U) {
#line 347
      tmp___16 = packet_get_int();
#line 347
      s->screen = (int )tmp___16;
    } else {
#line 349
      s->screen = 0;
    }
#line 350
    s->display = x11_create_display_inet(s->screen, options.x11_display_offset);
#line 352
    if ((unsigned int )s->display == (unsigned int )((void *)0)) {
#line 353
      break;
    }
#line 356
    tmp___18 = xmalloc(4096U);
#line 356
    xauthfile = (char *)tmp___18;
#line 357
    strlcpy(xauthfile, "/tmp/ssh-XXXXXXXX", 4096U);
#line 358
    temporarily_use_uid(pw->pw_uid);
#line 359
    tmp___21 = mkdtemp(xauthfile);
#line 359
    if ((unsigned int )tmp___21 == (unsigned int )((void *)0)) {
#line 360
      restore_uid();
#line 361
      tmp___19 = __errno_location();
#line 361
      tmp___20 = strerror(*tmp___19);
#line 361
      error("private X11 dir: mkdtemp %s failed: %s", xauthfile, tmp___20);
#line 363
      xfree((void *)xauthfile);
#line 364
      xauthfile = (char *)((void *)0);
#line 366
      break;
    }
#line 368
    strlcat(xauthfile, "/cookies", 4096U);
#line 369
    fd = open((char const   *)xauthfile, 194, 384);
#line 370
    if (fd >= 0) {
#line 371
      close(fd);
    }
#line 372
    restore_uid();
#line 373
    fatal_add_cleanup(& xauthfile_cleanup_proc, (void *)0);
#line 374
    success = 1;
#line 375
    break;
    case 30: 
#line 378
    if (no_agent_forwarding_flag) {
#line 379
      debug("Authentication agent forwarding not permitted for this authentication.");
#line 380
      break;
    } else {
#line 378
      if (compat13) {
#line 379
        debug("Authentication agent forwarding not permitted for this authentication.");
#line 380
        break;
      }
    }
#line 382
    debug("Received authentication agent forwarding request.");
#line 383
    success = auth_input_request_forwarding(pw);
#line 384
    break;
    case 28: 
#line 387
    if (no_port_forwarding_flag) {
#line 388
      debug("Port forwarding not permitted for this authentication.");
#line 389
      break;
    }
#line 391
    if (! options.allow_tcp_forwarding) {
#line 392
      debug("Port forwarding not permitted.");
#line 393
      break;
    }
#line 395
    debug("Received TCP/IP port forwarding request.");
#line 396
    channel_input_port_forward_request(pw->pw_uid == 0U, options.gateway_ports);
#line 397
    success = 1;
#line 398
    break;
    case 38: 
#line 401
    tmp___22 = packet_get_int();
#line 401
    tmp___23 = packet_set_maxsize((int )tmp___22);
#line 401
    if (tmp___23 > 0) {
#line 402
      success = 1;
    }
#line 403
    break;
    case 12: 
    case 13: 
#line 408
    if (have_pty) {
#line 408
      tmp___24 = 1;
    } else {
#line 408
      if ((unsigned int )s->display != (unsigned int )((void *)0)) {
#line 408
        tmp___24 = 1;
      } else {
#line 408
        tmp___24 = 0;
      }
    }
#line 408
    packet_set_interactive(tmp___24, options.keepalives);
#line 411
    if (type == 13) {
#line 412
      command = packet_get_string(& dlen);
#line 413
      debug("Exec command \'%.500s\'", command);
#line 414
      while (1) {
#line 414
        _p___3 = plen;
#line 414
        _e___3 = (int )(4U + dlen);
#line 414
        if (_p___3 != _e___3) {
#line 414
          log("Packet integrity error (%d != %d) at %s:%d", _p___3, _e___3, "session.c",
              414);
#line 414
          packet_disconnect("Packet integrity error. (%d)", type);
        }
#line 414
        break;
      }
    } else {
#line 416
      command = (char *)((void *)0);
#line 417
      while (1) {
#line 417
        _p___4 = plen;
#line 417
        _e___4 = 0;
#line 417
        if (_p___4 != _e___4) {
#line 417
          log("Packet integrity error (%d != %d) at %s:%d", _p___4, _e___4, "session.c",
              417);
#line 417
          packet_disconnect("Packet integrity error. (%d)", type);
        }
#line 417
        break;
      }
    }
#line 419
    if ((unsigned int )forced_command != (unsigned int )((void *)0)) {
#line 420
      original_command = command;
#line 421
      command = forced_command;
#line 422
      debug("Forced command \'%.500s\'", forced_command);
    }
#line 424
    if (have_pty) {
#line 425
      do_exec_pty(s, (char const   *)command, pw);
    } else {
#line 427
      do_exec_no_pty(s, (char const   *)command, pw);
    }
#line 429
    if ((unsigned int )command != (unsigned int )((void *)0)) {
#line 430
      xfree((void *)command);
    }
#line 432
    if (xauthfile) {
#line 433
      xauthfile_cleanup_proc((void *)0);
    }
#line 434
    return;
    default: 
#line 441
    log("Unknown packet type received after authentication: %d", type);
    }
#line 443
    if (success) {
#line 443
      tmp___25 = 14;
    } else {
#line 443
      tmp___25 = 15;
    }
#line 443
    packet_start(tmp___25);
#line 444
    packet_send();
#line 445
    packet_write_wait();
#line 448
    if (enable_compression_after_reply) {
#line 449
      enable_compression_after_reply = 0;
#line 450
      packet_start_compression(compression_level);
    }
  }
}
}
#line 460 "session.c"
void do_exec_no_pty(Session *s , char const   *command , struct passwd *pw ) 
{ int pid ;
  int inout[2] ;
  int err[2] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  __pid_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
#line 474
  tmp___1 = socketpair(1, 1, 0, (int *)(inout));
#line 474
  if (tmp___1 < 0) {
#line 476
    tmp = __errno_location();
#line 476
    tmp___0 = strerror(*tmp);
#line 476
    packet_disconnect("Could not create socket pairs: %.100s", tmp___0);
  } else {
#line 474
    tmp___2 = socketpair(1, 1, 0, (int *)(err));
#line 474
    if (tmp___2 < 0) {
#line 476
      tmp = __errno_location();
#line 476
      tmp___0 = strerror(*tmp);
#line 476
      packet_disconnect("Could not create socket pairs: %.100s", tmp___0);
    }
  }
#line 479
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 480
    fatal("do_exec_no_pty: no session");
  }
#line 482
  signal(13, (void (*)(int  ))0);
#line 484
  session_proctitle(s);
#line 487
  do_pam_setcred();
#line 491
  pid = fork();
#line 491
  if (pid == 0) {
#line 493
    log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 499
    tmp___5 = setsid();
#line 499
    if (tmp___5 < 0) {
#line 500
      tmp___3 = __errno_location();
#line 500
      tmp___4 = strerror(*tmp___3);
#line 500
      error("setsid failed: %.100s", tmp___4);
    }
#line 529
    close(inout[1]);
#line 530
    close(err[1]);
#line 531
    tmp___6 = dup2(inout[0], 0);
#line 531
    if (tmp___6 < 0) {
#line 532
      perror("dup2 stdin");
    }
#line 533
    tmp___7 = dup2(inout[0], 1);
#line 533
    if (tmp___7 < 0) {
#line 534
      perror("dup2 stdout");
    }
#line 535
    tmp___8 = dup2(err[0], 2);
#line 535
    if (tmp___8 < 0) {
#line 536
      perror("dup2 stderr");
    }
#line 540
    do_child(command, pw, (char const   *)((void *)0), (char const   *)s->display,
             (char const   *)s->auth_proto, (char const   *)s->auth_data, (char const   *)((void *)0));
  }
#line 547
  if (pid < 0) {
#line 548
    tmp___9 = __errno_location();
#line 548
    tmp___10 = strerror(*tmp___9);
#line 548
    packet_disconnect("fork failed: %.100s", tmp___10);
  }
#line 549
  s->pid = pid;
#line 565
  close(inout[0]);
#line 566
  close(err[0]);
#line 572
  if (compat20) {
#line 573
    if (s->extended) {
#line 573
      tmp___11 = err[1];
    } else {
#line 573
      tmp___11 = -1;
    }
#line 573
    session_set_fds(s, inout[1], inout[1], tmp___11);
  } else {
#line 575
    server_loop(pid, inout[1], inout[1], err[1]);
  }
#line 579
  return;
}
}
#line 587 "session.c"
void do_exec_pty(Session *s , char const   *command , struct passwd *pw ) 
{ int fdout___0 ;
  int ptyfd ;
  int ttyfd ;
  int ptymaster ;
  pid_t pid ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;

  {
#line 593
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 594
    fatal("do_exec_pty: no session");
  }
#line 595
  ptyfd = s->ptyfd;
#line 596
  ttyfd = s->ttyfd;
#line 599
  do_pam_session(pw->pw_name, (char const   *)(s->tty));
#line 600
  do_pam_setcred();
#line 604
  pid = fork();
#line 604
  if (pid == 0) {
#line 606
    log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 609
    close(ptyfd);
#line 612
    pty_make_controlling_tty(& ttyfd, (char const   *)(s->tty));
#line 615
    tmp___1 = fileno(stdin);
#line 615
    tmp___2 = dup2(ttyfd, tmp___1);
#line 615
    if (tmp___2 < 0) {
#line 616
      tmp = __errno_location();
#line 616
      tmp___0 = strerror(*tmp);
#line 616
      error("dup2 stdin failed: %.100s", tmp___0);
    }
#line 619
    tmp___5 = fileno(stdout);
#line 619
    tmp___6 = dup2(ttyfd, tmp___5);
#line 619
    if (tmp___6 < 0) {
#line 620
      tmp___3 = __errno_location();
#line 620
      tmp___4 = strerror(*tmp___3);
#line 620
      error("dup2 stdin failed: %.100s", tmp___4);
    }
#line 623
    tmp___9 = fileno(stderr);
#line 623
    tmp___10 = dup2(ttyfd, tmp___9);
#line 623
    if (tmp___10 < 0) {
#line 624
      tmp___7 = __errno_location();
#line 624
      tmp___8 = strerror(*tmp___7);
#line 624
      error("dup2 stdin failed: %.100s", tmp___8);
    }
#line 627
    close(ttyfd);
#line 630
    if (options.use_login) {
#line 630
      if (! ((unsigned int )command == (unsigned int )((void *)0))) {
#line 631
        do_login(s, command);
      }
    } else {
#line 631
      do_login(s, command);
    }
#line 634
    do_child(command, pw, (char const   *)s->term, (char const   *)s->display, (char const   *)s->auth_proto,
             (char const   *)s->auth_data, (char const   *)(s->tty));
  }
#line 642
  if (pid < 0) {
#line 643
    tmp___11 = __errno_location();
#line 643
    tmp___12 = strerror(*tmp___11);
#line 643
    packet_disconnect("fork failed: %.100s", tmp___12);
  }
#line 644
  s->pid = pid;
#line 647
  close(ttyfd);
#line 654
  fdout___0 = dup(ptyfd);
#line 655
  if (fdout___0 < 0) {
#line 656
    tmp___13 = __errno_location();
#line 656
    tmp___14 = strerror(*tmp___13);
#line 656
    packet_disconnect("dup #1 failed: %.100s", tmp___14);
  }
#line 659
  ptymaster = dup(ptyfd);
#line 660
  if (ptymaster < 0) {
#line 661
    tmp___15 = __errno_location();
#line 661
    tmp___16 = strerror(*tmp___15);
#line 661
    packet_disconnect("dup #2 failed: %.100s", tmp___16);
  }
#line 662
  s->ptymaster = ptymaster;
#line 665
  if (compat20) {
#line 666
    session_set_fds(s, ptyfd, fdout___0, -1);
  } else {
#line 668
    server_loop(pid, ptyfd, fdout___0, -1);
#line 670
    session_pty_cleanup(s);
  }
#line 672
  return;
}
}
#line 677
char const   *get_remote_name_or_ip(void) ;
#line 677 "session.c"
static char const   *remote  =    "";
#line 674 "session.c"
char const   *get_remote_name_or_ip(void) 
{ size_t tmp ;

  {
#line 678
  if (utmp_len > 0U) {
#line 679
    remote = get_canonical_hostname();
  }
#line 680
  if (utmp_len == 0U) {
#line 681
    remote = get_remote_ipaddr();
  } else {
#line 680
    tmp = strlen(remote);
#line 680
    if (tmp > utmp_len) {
#line 681
      remote = get_remote_ipaddr();
    }
  }
#line 682
  return (remote);
}
}
#line 686 "session.c"
void do_login(Session *s , char const   *command ) 
{ FILE *f ;
  char *time_string ;
  char buf___1[256] ;
  char hostname[64] ;
  socklen_t fromlen ;
  struct sockaddr_storage from ;
  struct stat st ;
  time_t last_login_time ;
  struct passwd *pw ;
  pid_t pid ;
  __pid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___11 ;
  char *tmp___13 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___19 ;
  int tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;

  {
#line 697
  pw = s->pw;
#line 698
  tmp = getpid();
#line 698
  pid = tmp;
#line 704
  memset((void *)(& from), 0, sizeof(from));
#line 705
  tmp___4 = packet_connection_is_on_socket();
#line 705
  if (tmp___4) {
#line 706
    fromlen = sizeof(from);
#line 707
    tmp___2 = packet_get_connection_in();
#line 707
    tmp___3 = getpeername(tmp___2, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 707
    if (tmp___3 < 0) {
#line 709
      tmp___0 = __errno_location();
#line 709
      tmp___1 = strerror(*tmp___0);
#line 709
      debug("getpeername: %.100s", tmp___1);
#line 710
      fatal_cleanup();
    }
  }
#line 715
  hostname[0] = (char )'\000';
#line 716
  tmp___5 = get_last_login_time(pw->pw_uid, (char const   *)pw->pw_name, hostname,
                                sizeof(hostname));
#line 716
  last_login_time = (long )tmp___5;
#line 720
  tmp___6 = get_remote_name_or_ip();
#line 720
  record_login(pid, (char const   *)(s->tty), (char const   *)pw->pw_name, pw->pw_uid,
               tmp___6, (struct sockaddr *)(& from));
#line 728
  tmp___7 = pam_password_change_required();
#line 728
  if (tmp___7) {
#line 729
    print_pam_messages();
#line 730
    do_pam_chauthtok();
  }
#line 735
  if ((unsigned int )command != (unsigned int )((void *)0)) {
#line 736
    return;
  }
#line 737
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.200s/.hushlogin",
           pw->pw_dir);
#line 741
  tmp___8 = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )(& st));
#line 741
  if (tmp___8 >= 0) {
#line 743
    return;
  }
#line 746
  tmp___9 = pam_password_change_required();
#line 746
  if (! tmp___9) {
#line 747
    print_pam_messages();
  }
#line 754
  if (last_login_time != 0L) {
#line 755
    time_string = ctime((time_t const   *)(& last_login_time));
#line 756
    tmp___13 = __builtin_strchr(time_string, '\n');
#line 756
    if (tmp___13) {
#line 757
      tmp___11 = __builtin_strchr(time_string, '\n');
#line 757
      *tmp___11 = (char)0;
    }
#line 758
    if (0) {
#line 758
      __s1_len = strlen((char const   *)(hostname));
#line 758
      __s2_len = strlen("");
#line 758
      if (! ((unsigned int )((void const   *)(hostname + 1)) - (unsigned int )((void const   *)(hostname)) == 1U)) {
        goto _L___0;
      } else {
#line 758
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 758
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 758
            tmp___23 = 1;
          } else {
#line 758
            if (__s2_len >= 4U) {
#line 758
              tmp___23 = 1;
            } else {
#line 758
              tmp___23 = 0;
            }
          }
        } else {
#line 758
          tmp___23 = 0;
        }
      }
#line 758
      if (tmp___23) {
#line 758
        tmp___19 = __builtin_strcmp((char const   *)(hostname), "");
      } else {
#line 758
        tmp___22 = __builtin_strcmp((char const   *)(hostname), "");
#line 758
        tmp___19 = tmp___22;
      }
    } else {
#line 758
      tmp___22 = __builtin_strcmp((char const   *)(hostname), "");
#line 758
      tmp___19 = tmp___22;
    }
#line 758
    if (tmp___19 == 0) {
#line 759
      printf((char const   * __restrict  )"Last login: %s\r\n", time_string);
    } else {
#line 761
      printf((char const   * __restrict  )"Last login: %s from %s\r\n", time_string,
             hostname);
    }
  }
#line 763
  if (options.print_motd) {
#line 768
    f = fopen((char const   * __restrict  )"/etc/motd", (char const   * __restrict  )"r");
#line 770
    if (f) {
#line 771
      while (1) {
#line 771
        tmp___24 = fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )f);
#line 771
        if (! tmp___24) {
#line 771
          break;
        }
#line 772
        fputs((char const   * __restrict  )(buf___1), (FILE * __restrict  )stdout);
      }
#line 773
      fclose(f);
    }
  }
#line 776
  return;
}
}
#line 782 "session.c"
void child_set_env(char ***envp , unsigned int *envsizep , char const   *name , char const   *value ) 
{ unsigned int i ;
  unsigned int namelen ;
  char **env ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  void *tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  void *tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;

  {
#line 794
  env = *envp;
#line 795
  namelen = strlen(name);
#line 796
  i = 0U;
#line 796
  while (*(env + i)) {
#line 797
    if (0) {
#line 797
      if (0) {
#line 797
        __s1_len___0 = strlen((char const   *)*(env + i));
#line 797
        __s2_len___0 = strlen(name);
#line 797
        if (! ((unsigned int )((void const   *)(*(env + i) + 1)) - (unsigned int )((void const   *)*(env + i)) == 1U)) {
          goto _L___2;
        } else {
#line 797
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 797
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
#line 797
              tmp___22 = 1;
            } else {
#line 797
              if (__s2_len___0 >= 4U) {
#line 797
                tmp___22 = 1;
              } else {
#line 797
                tmp___22 = 0;
              }
            }
          } else {
#line 797
            tmp___22 = 0;
          }
        }
#line 797
        if (tmp___22) {
#line 797
          tmp___18 = __builtin_strcmp((char const   *)*(env + i), name);
        } else {
#line 797
          tmp___21 = __builtin_strcmp((char const   *)*(env + i), name);
#line 797
          tmp___18 = tmp___21;
        }
      } else {
#line 797
        tmp___21 = __builtin_strcmp((char const   *)*(env + i), name);
#line 797
        tmp___18 = tmp___21;
      }
#line 797
      tmp___12 = tmp___18;
    } else {
#line 797
      tmp___12 = strncmp((char const   *)*(env + i), name, namelen);
    }
#line 797
    if (tmp___12 == 0) {
#line 797
      if ((int )*(*(env + i) + namelen) == 61) {
#line 798
        break;
      }
    }
#line 796
    i ++;
  }
#line 799
  if (*(env + i)) {
#line 801
    xfree((void *)*(env + i));
  } else {
#line 804
    if (i >= *envsizep - 1U) {
#line 805
      *envsizep += 50U;
#line 806
      tmp___25 = xrealloc((void *)env, *envsizep * sizeof(char *));
#line 806
      *envp = (char **)tmp___25;
#line 806
      env = *envp;
    }
#line 809
    *(env + (i + 1U)) = (char *)((void *)0);
  }
#line 813
  tmp___26 = strlen(name);
#line 813
  tmp___27 = strlen(value);
#line 813
  tmp___28 = xmalloc(((tmp___26 + 1U) + tmp___27) + 1U);
#line 813
  *(env + i) = (char *)tmp___28;
#line 814
  tmp___29 = strlen(name);
#line 814
  tmp___30 = strlen(value);
#line 814
  snprintf((char * __restrict  )*(env + i), ((tmp___29 + 1U) + tmp___30) + 1U, (char const   * __restrict  )"%s=%s",
           name, value);
#line 815
  return;
}
}
#line 823 "session.c"
void read_environment_file(char ***env , unsigned int *envsize , char const   *filename ) 
{ FILE *f ;
  char buf___1[4096] ;
  char *cp ;
  char *value ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 831
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 832
  if (! f) {
#line 833
    return;
  }
#line 835
  while (1) {
#line 835
    tmp___5 = fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )f);
#line 835
    if (! tmp___5) {
#line 835
      break;
    }
#line 836
    cp = buf___1;
#line 836
    while (1) {
#line 836
      if (! ((int )*cp == 32)) {
#line 836
        if (! ((int )*cp == 9)) {
#line 836
          break;
        }
      }
#line 836
      cp ++;
    }
#line 838
    if (! *cp) {
#line 839
      continue;
    } else {
#line 838
      if ((int )*cp == 35) {
#line 839
        continue;
      } else {
#line 838
        if ((int )*cp == 10) {
#line 839
          continue;
        }
      }
    }
#line 840
    tmp___2 = __builtin_strchr(cp, '\n');
#line 840
    if (tmp___2) {
#line 841
      tmp___0 = __builtin_strchr(cp, '\n');
#line 841
      *tmp___0 = (char )'\000';
    }
#line 842
    tmp___4 = __builtin_strchr(cp, '=');
#line 842
    value = tmp___4;
#line 843
    if ((unsigned int )value == (unsigned int )((void *)0)) {
#line 844
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad line in %.100s: %.200s\n",
              filename, buf___1);
#line 845
      continue;
    }
#line 851
    *value = (char )'\000';
#line 852
    value ++;
#line 853
    child_set_env(env, envsize, (char const   *)cp, (char const   *)value);
  }
#line 855
  fclose(f);
#line 856
  return;
}
}
#line 862 "session.c"
void do_pam_environment(char ***env , int *envsize ) 
{ char *equals ;
  char var_name[512] ;
  char var_val[512] ;
  char **pam_env ;
  int i ;
  size_t tmp ;

  {
#line 868
  pam_env = fetch_pam_environment();
#line 868
  if ((unsigned int )pam_env == (unsigned int )((void *)0)) {
#line 869
    return;
  }
#line 871
  i = 0;
#line 871
  while ((unsigned int )*(pam_env + i) != (unsigned int )((void *)0)) {
#line 872
    equals = strstr((char const   *)*(pam_env + i), "=");
#line 872
    if ((unsigned int )equals == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 875
    tmp = strlen((char const   *)*(pam_env + i));
#line 875
    if (tmp < sizeof(var_name) - 1U) {
#line 876
      memset((void *)(var_name), '\000', sizeof(var_name));
#line 877
      memset((void *)(var_val), '\000', sizeof(var_val));
#line 879
      __builtin_strncpy(var_name, (char const   *)*(pam_env + i), (unsigned int )(equals - *(pam_env + i)));
#line 880
      strcpy((char * __restrict  )(var_val), (char const   * __restrict  )(equals + 1));
#line 882
      debug3("PAM environment: %s=%s", var_name, var_val);
#line 884
      child_set_env(env, (unsigned int *)envsize, (char const   *)(var_name), (char const   *)(var_val));
    }
    __Cont: /* CIL Label */ 
#line 871
    i ++;
  }
#line 887
  return;
}
}
#line 1011
extern char **environ ;
#line 1000 "session.c"
void do_child(char const   *command , struct passwd *pw , char const   *term , char const   *display ,
              char const   *auth_proto , char const   *auth_data , char const   *ttyname___0 ) 
{ char const   *shell ;
  char const   *hostname ;
  char const   *cp ;
  char buf___1[256] ;
  char cmd[1024] ;
  FILE *f ;
  unsigned int envsize ;
  unsigned int i ;
  char **env ;
  struct stat st ;
  char *argv[10] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  __uid_t tmp___4 ;
  __uid_t tmp___5 ;
  __uid_t tmp___6 ;
  __uid_t tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  struct envstring *ce ;
  char *s ;
  int i___0 ;
  int tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  char *screen ;
  char *tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  char *tmp___28 ;
  char buf___2[256] ;
  char *mailbox ;
  struct stat mailstat ;
  int tmp___29 ;

  {
#line 1005
  hostname = (char const   *)((void *)0);
#line 1005
  cp = (char const   *)((void *)0);
#line 1008
  f = (FILE *)((void *)0);
#line 1019
  if (options.use_login) {
#line 1019
    if ((unsigned int )command != (unsigned int )((void *)0)) {
#line 1020
      options.use_login = 0;
    }
  }
#line 1045
  if (! options.use_login) {
#line 1065
    tmp___4 = getuid();
#line 1065
    if (tmp___4 == 0U) {
      goto _L;
    } else {
#line 1065
      tmp___5 = geteuid();
#line 1065
      if (tmp___5 == 0U) {
        _L: /* CIL Label */ 
#line 1077
        tmp___1 = setlogin((char const   *)pw->pw_name);
#line 1077
        if (tmp___1 < 0) {
#line 1078
          tmp = __errno_location();
#line 1078
          tmp___0 = strerror(*tmp);
#line 1078
          error("setlogin failed: %s", tmp___0);
        }
#line 1079
        tmp___2 = setgid(pw->pw_gid);
#line 1079
        if (tmp___2 < 0) {
#line 1080
          perror("setgid");
#line 1081
          exit(1);
        }
#line 1084
        tmp___3 = initgroups((char const   *)pw->pw_name, pw->pw_gid);
#line 1084
        if (tmp___3 < 0) {
#line 1085
          perror("initgroups");
#line 1086
          exit(1);
        }
#line 1088
        endgrent();
#line 1106
        permanently_set_uid(pw->pw_uid);
      }
    }
#line 1114
    tmp___6 = getuid();
#line 1114
    if (tmp___6 != pw->pw_uid) {
#line 1115
      fatal("Failed to set uids to %u.", pw->pw_uid);
    } else {
#line 1114
      tmp___7 = geteuid();
#line 1114
      if (tmp___7 != pw->pw_uid) {
#line 1115
        fatal("Failed to set uids to %u.", pw->pw_uid);
      }
    }
  }
#line 1121
  if ((int )*(pw->pw_shell + 0) == 0) {
#line 1121
    shell = "/bin/sh";
  } else {
#line 1121
    shell = (char const   *)pw->pw_shell;
  }
#line 1139
  envsize = 100U;
#line 1140
  tmp___8 = xmalloc(envsize * sizeof(char *));
#line 1140
  env = (char **)tmp___8;
#line 1141
  *(env + 0) = (char *)((void *)0);
#line 1151
  if (! options.use_login) {
#line 1153
    child_set_env(& env, & envsize, "USER", (char const   *)pw->pw_name);
#line 1154
    child_set_env(& env, & envsize, "LOGNAME", (char const   *)pw->pw_name);
#line 1155
    child_set_env(& env, & envsize, "HOME", (char const   *)pw->pw_dir);
#line 1167
    child_set_env(& env, & envsize, "PATH", "/usr/bin:/bin:/usr/sbin:/sbin");
#line 1171
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.200s/%.50s",
             "/var/mail", pw->pw_name);
#line 1173
    child_set_env(& env, & envsize, "MAIL", (char const   *)(buf___1));
#line 1176
    child_set_env(& env, & envsize, "SHELL", shell);
  }
#line 1178
  tmp___10 = getenv("TZ");
#line 1178
  if (tmp___10) {
#line 1179
    tmp___9 = getenv("TZ");
#line 1179
    child_set_env(& env, & envsize, "TZ", (char const   *)tmp___9);
  }
#line 1182
  while (custom_environment) {
#line 1183
    ce = custom_environment;
#line 1184
    s = ce->s;
#line 1186
    i___0 = 0;
#line 1186
    while (1) {
#line 1186
      if ((int )*(s + i___0) != 61) {
#line 1186
        if (! *(s + i___0)) {
#line 1186
          break;
        }
      } else {
#line 1186
        break;
      }
#line 1186
      i___0 ++;
    }
#line 1187
    if ((int )*(s + i___0) == 61) {
#line 1188
      *(s + i___0) = (char)0;
#line 1189
      child_set_env(& env, & envsize, (char const   *)s, (char const   *)((s + i___0) + 1));
    }
#line 1191
    custom_environment = ce->next;
#line 1192
    xfree((void *)ce->s);
#line 1193
    xfree((void *)ce);
  }
#line 1196
  tmp___11 = get_local_port();
#line 1196
  tmp___12 = get_remote_port();
#line 1196
  tmp___13 = get_remote_ipaddr();
#line 1196
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.50s %d %d",
           tmp___13, tmp___12, tmp___11);
#line 1198
  child_set_env(& env, & envsize, "SSH_CLIENT", (char const   *)(buf___1));
#line 1200
  if (ttyname___0) {
#line 1201
    child_set_env(& env, & envsize, "SSH_TTY", ttyname___0);
  }
#line 1202
  if (term) {
#line 1203
    child_set_env(& env, & envsize, "TERM", term);
  }
#line 1204
  if (display) {
#line 1205
    child_set_env(& env, & envsize, "DISPLAY", display);
  }
#line 1206
  if (original_command) {
#line 1207
    child_set_env(& env, & envsize, "SSH_ORIGINAL_COMMAND", (char const   *)original_command);
  }
#line 1229
  do_pam_environment(& env, (int *)(& envsize));
#line 1232
  if (xauthfile) {
#line 1233
    child_set_env(& env, & envsize, "XAUTHORITY", (char const   *)xauthfile);
  }
#line 1234
  tmp___15 = auth_get_socket_name();
#line 1234
  if ((unsigned int )tmp___15 != (unsigned int )((void *)0)) {
#line 1235
    tmp___14 = auth_get_socket_name();
#line 1235
    child_set_env(& env, & envsize, "SSH_AUTH_SOCK", (char const   *)tmp___14);
  }
#line 1239
  if (! options.use_login) {
#line 1240
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.200s/.ssh/environment",
             pw->pw_dir);
#line 1242
    read_environment_file(& env, & envsize, (char const   *)(buf___1));
  }
#line 1244
  if (debug_flag) {
#line 1246
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Environment:\n");
#line 1247
    i = 0U;
#line 1247
    while (*(env + i)) {
#line 1248
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  %.200s\n",
              *(env + i));
#line 1247
      i ++;
    }
  }
#line 1251
  if (options.use_login) {
#line 1252
    hostname = get_remote_name_or_ip();
  }
#line 1260
  tmp___19 = packet_get_connection_in();
#line 1260
  tmp___20 = packet_get_connection_out();
#line 1260
  if (tmp___19 == tmp___20) {
#line 1261
    tmp___16 = packet_get_connection_in();
#line 1261
    close(tmp___16);
  } else {
#line 1263
    tmp___17 = packet_get_connection_in();
#line 1263
    close(tmp___17);
#line 1264
    tmp___18 = packet_get_connection_out();
#line 1264
    close(tmp___18);
  }
#line 1271
  channel_close_all();
#line 1277
  endpwent();
#line 1285
  i = 3U;
#line 1285
  while (i < 64U) {
#line 1286
    close((int )i);
#line 1285
    i ++;
  }
#line 1289
  tmp___23 = chdir((char const   *)pw->pw_dir);
#line 1289
  if (tmp___23 < 0) {
#line 1290
    tmp___21 = __errno_location();
#line 1290
    tmp___22 = strerror(*tmp___21);
#line 1290
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not chdir to home directory %s: %s\n",
            pw->pw_dir, tmp___22);
  }
#line 1302
  environ = env;
#line 1308
  if (! options.use_login) {
#line 1309
    tmp___27 = stat((char const   * __restrict  )".ssh/rc", (struct stat * __restrict  )(& st));
#line 1309
    if (tmp___27 >= 0) {
#line 1310
      if (debug_flag) {
#line 1311
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running /bin/sh %s\n",
                ".ssh/rc");
      }
#line 1313
      f = popen("/bin/sh .ssh/rc", "w");
#line 1314
      if (f) {
#line 1315
        if ((unsigned int )auth_proto != (unsigned int )((void *)0)) {
#line 1315
          if ((unsigned int )auth_data != (unsigned int )((void *)0)) {
#line 1316
            fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                    auth_proto, auth_data);
          }
        }
#line 1317
        pclose(f);
      } else {
#line 1319
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                ".ssh/rc");
      }
    } else {
#line 1320
      tmp___26 = stat((char const   * __restrict  )"/usr/local/etc/sshrc", (struct stat * __restrict  )(& st));
#line 1320
      if (tmp___26 >= 0) {
#line 1321
        if (debug_flag) {
#line 1322
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running /bin/sh %s\n",
                  "/usr/local/etc/sshrc");
        }
#line 1324
        f = popen("/bin/sh /usr/local/etc/sshrc", "w");
#line 1325
        if (f) {
#line 1326
          if ((unsigned int )auth_proto != (unsigned int )((void *)0)) {
#line 1326
            if ((unsigned int )auth_data != (unsigned int )((void *)0)) {
#line 1327
              fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                      auth_proto, auth_data);
            }
          }
#line 1328
          pclose(f);
        } else {
#line 1330
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                  "/usr/local/etc/sshrc");
        }
      } else {
#line 1331
        if ((unsigned int )options.xauth_location != (unsigned int )((void *)0)) {
#line 1333
          if ((unsigned int )auth_proto != (unsigned int )((void *)0)) {
#line 1333
            if ((unsigned int )auth_data != (unsigned int )((void *)0)) {
#line 1334
              tmp___25 = __builtin_strchr((char *)display, ':');
#line 1334
              screen = tmp___25;
#line 1335
              if (debug_flag) {
#line 1336
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %.100s add %.100s %.100s %.100s\n",
                        options.xauth_location, display, auth_proto, auth_data);
#line 1341
                if ((unsigned int )screen != (unsigned int )((void *)0)) {
#line 1342
                  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Adding %.*s/unix%s %s %s\n",
                          screen - (char *)display, display, screen, auth_proto, auth_data);
                }
              }
#line 1348
              snprintf((char * __restrict  )(cmd), sizeof(cmd), (char const   * __restrict  )"%s -q -",
                       options.xauth_location);
#line 1350
              f = popen((char const   *)(cmd), "w");
#line 1351
              if (f) {
#line 1352
                fprintf((FILE * __restrict  )f, (char const   * __restrict  )"add %s %s %s\n",
                        display, auth_proto, auth_data);
#line 1355
                if ((unsigned int )screen != (unsigned int )((void *)0)) {
#line 1356
                  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"add %.*s/unix%s %s %s\n",
                          screen - (char *)display, display, screen, auth_proto, auth_data);
                }
#line 1360
                pclose(f);
              } else {
#line 1362
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                        cmd);
              }
            }
          }
        }
      }
    }
#line 1368
    tmp___28 = strrchr(shell, '/');
#line 1368
    cp = (char const   *)tmp___28;
#line 1369
    if (cp) {
#line 1370
      cp ++;
    } else {
#line 1372
      cp = shell;
    }
  }
#line 1379
  if (! command) {
#line 1380
    if (! options.use_login) {
#line 1387
      if (ttyname___0) {
#line 1387
        if (options.check_mail) {
#line 1390
          mailbox = getenv("MAIL");
#line 1391
          if ((unsigned int )mailbox != (unsigned int )((void *)0)) {
#line 1392
            tmp___29 = stat((char const   * __restrict  )mailbox, (struct stat * __restrict  )(& mailstat));
#line 1392
            if (tmp___29 != 0) {
#line 1394
              printf((char const   * __restrict  )"No mail.\n");
            } else {
#line 1392
              if (mailstat.st_size == 0L) {
#line 1394
                printf((char const   * __restrict  )"No mail.\n");
              } else {
#line 1395
                if (mailstat.st_mtim.tv_sec < mailstat.st_atim.tv_sec) {
#line 1396
                  printf((char const   * __restrict  )"You have mail.\n");
                } else {
#line 1398
                  printf((char const   * __restrict  )"You have new mail.\n");
                }
              }
            }
          }
        }
      }
#line 1402
      buf___2[0] = (char )'-';
#line 1403
      __builtin_strncpy(buf___2 + 1, cp, sizeof(buf___2) - 1U);
#line 1404
      buf___2[sizeof(buf___2) - 1U] = (char)0;
#line 1407
      argv[0] = buf___2;
#line 1408
      argv[1] = (char *)((void *)0);
#line 1409
      execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 1412
      perror(shell);
#line 1413
      exit(1);
    } else {
#line 1418
      execl("/bin/login", "login", "-h", hostname, "-p", "-f", "--", pw->pw_name,
            (void *)0);
#line 1423
      perror("login");
#line 1424
      exit(1);
    }
  }
#line 1431
  argv[0] = (char *)cp;
#line 1432
  argv[1] = (char *)"-c";
#line 1433
  argv[2] = (char *)command;
#line 1434
  argv[3] = (char *)((void *)0);
#line 1435
  execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 1436
  perror(shell);
#line 1437
  exit(1);
}
}
#line 1444 "session.c"
static int did_init___0  =    0;
#line 1440 "session.c"
Session *session_new(void) 
{ int i ;
  Session *s ;

  {
#line 1445
  if (! did_init___0) {
#line 1446
    debug("session_new: init");
#line 1447
    i = 0;
#line 1447
    while (i < 10) {
#line 1448
      sessions[i].used = 0;
#line 1449
      sessions[i].self = i;
#line 1447
      i ++;
    }
#line 1451
    did_init___0 = 1;
  }
#line 1453
  i = 0;
#line 1453
  while (i < 10) {
#line 1454
    s = & sessions[i];
#line 1455
    if (! s->used) {
#line 1456
      s->pid = 0;
#line 1457
      s->extended = 0;
#line 1458
      s->chanid = -1;
#line 1459
      s->ptyfd = -1;
#line 1460
      s->ttyfd = -1;
#line 1461
      s->term = (char *)((void *)0);
#line 1462
      s->pw = (struct passwd *)((void *)0);
#line 1463
      s->display = (char *)((void *)0);
#line 1464
      s->screen = 0;
#line 1465
      s->auth_data = (char *)((void *)0);
#line 1466
      s->auth_proto = (char *)((void *)0);
#line 1467
      s->used = 1;
#line 1468
      s->pw = (struct passwd *)((void *)0);
#line 1469
      debug("session_new: session %d", i);
#line 1470
      return (s);
    }
#line 1453
    i ++;
  }
#line 1473
  return ((Session *)((void *)0));
}
}
#line 1476 "session.c"
void session_dump(void) 
{ int i ;
  Session *s ;

  {
#line 1480
  i = 0;
#line 1480
  while (i < 10) {
#line 1481
    s = & sessions[i];
#line 1482
    debug("dump: used %d session %d %p channel %d pid %d", s->used, s->self, s, s->chanid,
          s->pid);
#line 1480
    i ++;
  }
#line 1489
  return;
}
}
#line 1491 "session.c"
int session_open(int chanid ) 
{ Session *s ;
  Session *tmp ;

  {
#line 1494
  tmp = session_new();
#line 1494
  s = tmp;
#line 1495
  debug("session_open: channel %d", chanid);
#line 1496
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1497
    error("no more sessions");
#line 1498
    return (0);
  }
#line 1500
  s->pw = auth_get_user();
#line 1501
  if ((unsigned int )s->pw == (unsigned int )((void *)0)) {
#line 1502
    fatal("no user for session %i", s->self);
  }
#line 1503
  debug("session_open: session %d: link with channel %d", s->self, chanid);
#line 1504
  s->chanid = chanid;
#line 1505
  return (1);
}
}
#line 1508 "session.c"
Session *session_by_channel(int id ) 
{ int i ;
  Session *s ;

  {
#line 1512
  i = 0;
#line 1512
  while (i < 10) {
#line 1513
    s = & sessions[i];
#line 1514
    if (s->used) {
#line 1514
      if (s->chanid == id) {
#line 1515
        debug("session_by_channel: session %d channel %d", i, id);
#line 1516
        return (s);
      }
    }
#line 1512
    i ++;
  }
#line 1519
  debug("session_by_channel: unknown channel %d", id);
#line 1520
  session_dump();
#line 1521
  return ((Session *)((void *)0));
}
}
#line 1524 "session.c"
Session *session_by_pid(pid_t pid ) 
{ int i ;
  Session *s ;

  {
#line 1528
  debug("session_by_pid: pid %d", pid);
#line 1529
  i = 0;
#line 1529
  while (i < 10) {
#line 1530
    s = & sessions[i];
#line 1531
    if (s->used) {
#line 1531
      if (s->pid == pid) {
#line 1532
        return (s);
      }
    }
#line 1529
    i ++;
  }
#line 1534
  error("session_by_pid: unknown pid %d", pid);
#line 1535
  session_dump();
#line 1536
  return ((Session *)((void *)0));
}
}
#line 1539 "session.c"
int session_window_change_req(Session *s ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 1542
  tmp = packet_get_int();
#line 1542
  s->col = (int )tmp;
#line 1543
  tmp___0 = packet_get_int();
#line 1543
  s->row = (int )tmp___0;
#line 1544
  tmp___1 = packet_get_int();
#line 1544
  s->xpixel = (int )tmp___1;
#line 1545
  tmp___2 = packet_get_int();
#line 1545
  s->ypixel = (int )tmp___2;
#line 1546
  while (1) {
#line 1546
    tmp___3 = packet_remaining();
#line 1546
    _len = tmp___3;
#line 1546
    if (_len > 0) {
#line 1546
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1546);
#line 1546
      packet_disconnect("Packet integrity error.");
    }
#line 1546
    break;
  }
#line 1547
  pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);
#line 1548
  return (1);
}
}
#line 1551 "session.c"
int session_pty_req(Session *s ) 
{ unsigned int len ;
  char *term_modes ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int _len ;
  int tmp___3 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___9 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 1557
  if (no_pty_flag) {
#line 1558
    return (0);
  }
#line 1559
  if (s->ttyfd != -1) {
#line 1560
    return (0);
  }
#line 1561
  s->term = packet_get_string(& len);
#line 1562
  tmp = packet_get_int();
#line 1562
  s->col = (int )tmp;
#line 1563
  tmp___0 = packet_get_int();
#line 1563
  s->row = (int )tmp___0;
#line 1564
  tmp___1 = packet_get_int();
#line 1564
  s->xpixel = (int )tmp___1;
#line 1565
  tmp___2 = packet_get_int();
#line 1565
  s->ypixel = (int )tmp___2;
#line 1566
  term_modes = packet_get_string(& len);
#line 1567
  while (1) {
#line 1567
    tmp___3 = packet_remaining();
#line 1567
    _len = tmp___3;
#line 1567
    if (_len > 0) {
#line 1567
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1567);
#line 1567
      packet_disconnect("Packet integrity error.");
    }
#line 1567
    break;
  }
#line 1569
  if (0) {
#line 1569
    __s1_len = strlen((char const   *)s->term);
#line 1569
    __s2_len = strlen("");
#line 1569
    if (! ((unsigned int )((void const   *)(s->term + 1)) - (unsigned int )((void const   *)s->term) == 1U)) {
      goto _L___0;
    } else {
#line 1569
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1569
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 1569
          tmp___13 = 1;
        } else {
#line 1569
          if (__s2_len >= 4U) {
#line 1569
            tmp___13 = 1;
          } else {
#line 1569
            tmp___13 = 0;
          }
        }
      } else {
#line 1569
        tmp___13 = 0;
      }
    }
#line 1569
    if (tmp___13) {
#line 1569
      tmp___9 = __builtin_strcmp((char const   *)s->term, "");
    } else {
#line 1569
      tmp___12 = __builtin_strcmp((char const   *)s->term, "");
#line 1569
      tmp___9 = tmp___12;
    }
  } else {
#line 1569
    tmp___12 = __builtin_strcmp((char const   *)s->term, "");
#line 1569
    tmp___9 = tmp___12;
  }
#line 1569
  if (tmp___9 == 0) {
#line 1570
    xfree((void *)s->term);
#line 1571
    s->term = (char *)((void *)0);
  }
#line 1574
  tmp___14 = pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, (int )sizeof(s->tty));
#line 1574
  if (! tmp___14) {
#line 1575
    xfree((void *)s->term);
#line 1576
    s->term = (char *)((void *)0);
#line 1577
    s->ptyfd = -1;
#line 1578
    s->ttyfd = -1;
#line 1579
    error("session_pty_req: session %d alloc failed", s->self);
#line 1580
    xfree((void *)term_modes);
#line 1581
    return (0);
  }
#line 1583
  debug("session_pty_req: session %d alloc %s", s->self, s->tty);
#line 1588
  fatal_add_cleanup(& pty_cleanup_proc, (void *)s);
#line 1589
  pty_setowner(s->pw, (char const   *)(s->tty));
#line 1591
  pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);
#line 1593
  session_proctitle(s);
#line 1596
  xfree((void *)term_modes);
#line 1597
  return (1);
}
}
#line 1600 "session.c"
int session_subsystem_req(Session *s ) 
{ unsigned int len ;
  int success ;
  char *subsys ;
  char *tmp ;
  int i ;
  int _len ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 1604
  success = 0;
#line 1605
  tmp = packet_get_string(& len);
#line 1605
  subsys = tmp;
#line 1608
  while (1) {
#line 1608
    tmp___0 = packet_remaining();
#line 1608
    _len = tmp___0;
#line 1608
    if (_len > 0) {
#line 1608
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1608);
#line 1608
      packet_disconnect("Packet integrity error.");
    }
#line 1608
    break;
  }
#line 1609
  log("subsystem request for %s", subsys);
#line 1611
  i = 0;
#line 1611
  while ((unsigned int )i < options.num_subsystems) {
#line 1612
    if (0) {
#line 1612
      __s1_len = strlen((char const   *)subsys);
#line 1612
      __s2_len = strlen((char const   *)options.subsystem_name[i]);
#line 1612
      if (! ((unsigned int )((void const   *)(subsys + 1)) - (unsigned int )((void const   *)subsys) == 1U)) {
        goto _L___0;
      } else {
#line 1612
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 1612
          if (! ((unsigned int )((void const   *)(options.subsystem_name[i] + 1)) - (unsigned int )((void const   *)options.subsystem_name[i]) == 1U)) {
#line 1612
            tmp___10 = 1;
          } else {
#line 1612
            if (__s2_len >= 4U) {
#line 1612
              tmp___10 = 1;
            } else {
#line 1612
              tmp___10 = 0;
            }
          }
        } else {
#line 1612
          tmp___10 = 0;
        }
      }
#line 1612
      if (tmp___10) {
#line 1612
        tmp___6 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
      } else {
#line 1612
        tmp___9 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
#line 1612
        tmp___6 = tmp___9;
      }
    } else {
#line 1612
      tmp___9 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
#line 1612
      tmp___6 = tmp___9;
    }
#line 1612
    if (tmp___6 == 0) {
#line 1613
      debug("subsystem: exec() %s", options.subsystem_command[i]);
#line 1614
      do_exec_no_pty(s, (char const   *)options.subsystem_command[i], s->pw);
#line 1615
      success = 1;
    }
#line 1611
    i ++;
  }
#line 1619
  if (! success) {
#line 1620
    log("subsystem request for %s failed, subsystem not found", subsys);
  }
#line 1622
  xfree((void *)subsys);
#line 1623
  return (success);
}
}
#line 1626 "session.c"
int session_x11_req(Session *s ) 
{ int fd ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int _len ;
  int tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 1630
  if (no_x11_forwarding_flag) {
#line 1631
    debug("X11 forwarding disabled in user configuration file.");
#line 1632
    return (0);
  }
#line 1634
  if (! options.x11_forwarding) {
#line 1635
    debug("X11 forwarding disabled in server configuration file.");
#line 1636
    return (0);
  }
#line 1638
  if ((unsigned int )xauthfile != (unsigned int )((void *)0)) {
#line 1639
    debug("X11 fwd already started.");
#line 1640
    return (0);
  }
#line 1643
  debug("Received request for X11 forwarding with auth spoofing.");
#line 1644
  if ((unsigned int )s->display != (unsigned int )((void *)0)) {
#line 1645
    packet_disconnect("Protocol error: X11 display already set.");
  }
#line 1647
  tmp = packet_get_char();
#line 1647
  s->single_connection = (int )tmp;
#line 1648
  s->auth_proto = packet_get_string((unsigned int *)((void *)0));
#line 1649
  s->auth_data = packet_get_string((unsigned int *)((void *)0));
#line 1650
  tmp___0 = packet_get_int();
#line 1650
  s->screen = (int )tmp___0;
#line 1651
  while (1) {
#line 1651
    tmp___1 = packet_remaining();
#line 1651
    _len = tmp___1;
#line 1651
    if (_len > 0) {
#line 1651
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1651);
#line 1651
      packet_disconnect("Packet integrity error.");
    }
#line 1651
    break;
  }
#line 1653
  s->display = x11_create_display_inet(s->screen, options.x11_display_offset);
#line 1654
  if ((unsigned int )s->display == (unsigned int )((void *)0)) {
#line 1655
    xfree((void *)s->auth_proto);
#line 1656
    xfree((void *)s->auth_data);
#line 1657
    return (0);
  }
#line 1659
  tmp___2 = xmalloc(4096U);
#line 1659
  xauthfile = (char *)tmp___2;
#line 1660
  strlcpy(xauthfile, "/tmp/ssh-XXXXXXXX", 4096U);
#line 1661
  temporarily_use_uid((s->pw)->pw_uid);
#line 1662
  tmp___5 = mkdtemp(xauthfile);
#line 1662
  if ((unsigned int )tmp___5 == (unsigned int )((void *)0)) {
#line 1663
    restore_uid();
#line 1664
    tmp___3 = __errno_location();
#line 1664
    tmp___4 = strerror(*tmp___3);
#line 1664
    error("private X11 dir: mkdtemp %s failed: %s", xauthfile, tmp___4);
#line 1666
    xfree((void *)xauthfile);
#line 1667
    xauthfile = (char *)((void *)0);
#line 1668
    xfree((void *)s->auth_proto);
#line 1669
    xfree((void *)s->auth_data);
#line 1671
    return (0);
  }
#line 1673
  strlcat(xauthfile, "/cookies", 4096U);
#line 1674
  fd = open((char const   *)xauthfile, 194, 384);
#line 1675
  if (fd >= 0) {
#line 1676
    close(fd);
  }
#line 1677
  restore_uid();
#line 1678
  fatal_add_cleanup(& xauthfile_cleanup_proc, (void *)s);
#line 1679
  return (1);
}
}
#line 1682 "session.c"
int session_shell_req(Session *s ) 
{ char *shell ;
  int _len ;
  int tmp ;

  {
#line 1686
  shell = forced_command;
#line 1687
  while (1) {
#line 1687
    tmp = packet_remaining();
#line 1687
    _len = tmp;
#line 1687
    if (_len > 0) {
#line 1687
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1687);
#line 1687
      packet_disconnect("Packet integrity error.");
    }
#line 1687
    break;
  }
#line 1688
  s->extended = 1;
#line 1689
  if (s->ttyfd == -1) {
#line 1690
    do_exec_no_pty(s, (char const   *)shell, s->pw);
  } else {
#line 1692
    do_exec_pty(s, (char const   *)shell, s->pw);
  }
#line 1693
  return (1);
}
}
#line 1696 "session.c"
int session_exec_req(Session *s ) 
{ unsigned int len ;
  char *command ;
  char *tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 1700
  tmp = packet_get_string(& len);
#line 1700
  command = tmp;
#line 1701
  while (1) {
#line 1701
    tmp___0 = packet_remaining();
#line 1701
    _len = tmp___0;
#line 1701
    if (_len > 0) {
#line 1701
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1701);
#line 1701
      packet_disconnect("Packet integrity error.");
    }
#line 1701
    break;
  }
#line 1702
  if (forced_command) {
#line 1703
    original_command = command;
#line 1704
    command = forced_command;
#line 1705
    debug("Forced command \'%.500s\'", forced_command);
  }
#line 1707
  s->extended = 1;
#line 1708
  if (s->ttyfd == -1) {
#line 1709
    do_exec_no_pty(s, (char const   *)command, s->pw);
  } else {
#line 1711
    do_exec_pty(s, (char const   *)command, s->pw);
  }
#line 1712
  if ((unsigned int )forced_command == (unsigned int )((void *)0)) {
#line 1713
    xfree((void *)command);
  }
#line 1714
  return (1);
}
}
#line 1717 "session.c"
void session_input_channel_req(int id , void *arg ) 
{ unsigned int len ;
  int reply ;
  int success ;
  char *rtype ;
  Session *s ;
  Channel *c ;
  unsigned int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___25 ;
  int tmp___28 ;
  int tmp___29 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___35 ;
  int tmp___38 ;
  int tmp___39 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___45 ;
  int tmp___48 ;
  int tmp___49 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___55 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;

  {
#line 1722
  success = 0;
#line 1727
  rtype = packet_get_string(& len);
#line 1728
  tmp = packet_get_char();
#line 1728
  reply = (int )tmp;
#line 1730
  s = session_by_channel(id);
#line 1731
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1732
    fatal("session_input_channel_req: channel %d: no session", id);
  }
#line 1733
  c = channel_lookup(id);
#line 1734
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1735
    fatal("session_input_channel_req: channel %d: bad channel", id);
  }
#line 1737
  debug("session_input_channel_req: session %d channel %d request %s reply %d", s->self,
        id, rtype, reply);
#line 1744
  if (c->type == 10) {
#line 1745
    if (0) {
#line 1745
      __s1_len___3 = strlen((char const   *)rtype);
#line 1745
      __s2_len___3 = strlen("shell");
#line 1745
      if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
        goto _L___8;
      } else {
#line 1745
        if (__s1_len___3 >= 4U) {
          _L___8: /* CIL Label */ 
#line 1745
          if (! ((unsigned int )((void const   *)("shell" + 1)) - (unsigned int )((void const   *)"shell") == 1U)) {
#line 1745
            tmp___49 = 1;
          } else {
#line 1745
            if (__s2_len___3 >= 4U) {
#line 1745
              tmp___49 = 1;
            } else {
#line 1745
              tmp___49 = 0;
            }
          }
        } else {
#line 1745
          tmp___49 = 0;
        }
      }
#line 1745
      if (tmp___49) {
#line 1745
        tmp___45 = __builtin_strcmp((char const   *)rtype, "shell");
      } else {
#line 1745
        tmp___48 = __builtin_strcmp((char const   *)rtype, "shell");
#line 1745
        tmp___45 = tmp___48;
      }
    } else {
#line 1745
      tmp___48 = __builtin_strcmp((char const   *)rtype, "shell");
#line 1745
      tmp___45 = tmp___48;
    }
#line 1745
    if (tmp___45 == 0) {
#line 1746
      success = session_shell_req(s);
    } else {
#line 1747
      if (0) {
#line 1747
        __s1_len___2 = strlen((char const   *)rtype);
#line 1747
        __s2_len___2 = strlen("exec");
#line 1747
        if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
          goto _L___6;
        } else {
#line 1747
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 1747
            if (! ((unsigned int )((void const   *)("exec" + 1)) - (unsigned int )((void const   *)"exec") == 1U)) {
#line 1747
              tmp___39 = 1;
            } else {
#line 1747
              if (__s2_len___2 >= 4U) {
#line 1747
                tmp___39 = 1;
              } else {
#line 1747
                tmp___39 = 0;
              }
            }
          } else {
#line 1747
            tmp___39 = 0;
          }
        }
#line 1747
        if (tmp___39) {
#line 1747
          tmp___35 = __builtin_strcmp((char const   *)rtype, "exec");
        } else {
#line 1747
          tmp___38 = __builtin_strcmp((char const   *)rtype, "exec");
#line 1747
          tmp___35 = tmp___38;
        }
      } else {
#line 1747
        tmp___38 = __builtin_strcmp((char const   *)rtype, "exec");
#line 1747
        tmp___35 = tmp___38;
      }
#line 1747
      if (tmp___35 == 0) {
#line 1748
        success = session_exec_req(s);
      } else {
#line 1749
        if (0) {
#line 1749
          __s1_len___1 = strlen((char const   *)rtype);
#line 1749
          __s2_len___1 = strlen("pty-req");
#line 1749
          if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
            goto _L___4;
          } else {
#line 1749
            if (__s1_len___1 >= 4U) {
              _L___4: /* CIL Label */ 
#line 1749
              if (! ((unsigned int )((void const   *)("pty-req" + 1)) - (unsigned int )((void const   *)"pty-req") == 1U)) {
#line 1749
                tmp___29 = 1;
              } else {
#line 1749
                if (__s2_len___1 >= 4U) {
#line 1749
                  tmp___29 = 1;
                } else {
#line 1749
                  tmp___29 = 0;
                }
              }
            } else {
#line 1749
              tmp___29 = 0;
            }
          }
#line 1749
          if (tmp___29) {
#line 1749
            tmp___25 = __builtin_strcmp((char const   *)rtype, "pty-req");
          } else {
#line 1749
            tmp___28 = __builtin_strcmp((char const   *)rtype, "pty-req");
#line 1749
            tmp___25 = tmp___28;
          }
        } else {
#line 1749
          tmp___28 = __builtin_strcmp((char const   *)rtype, "pty-req");
#line 1749
          tmp___25 = tmp___28;
        }
#line 1749
        if (tmp___25 == 0) {
#line 1750
          success = session_pty_req(s);
        } else {
#line 1751
          if (0) {
#line 1751
            __s1_len___0 = strlen((char const   *)rtype);
#line 1751
            __s2_len___0 = strlen("x11-req");
#line 1751
            if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
              goto _L___2;
            } else {
#line 1751
              if (__s1_len___0 >= 4U) {
                _L___2: /* CIL Label */ 
#line 1751
                if (! ((unsigned int )((void const   *)("x11-req" + 1)) - (unsigned int )((void const   *)"x11-req") == 1U)) {
#line 1751
                  tmp___19 = 1;
                } else {
#line 1751
                  if (__s2_len___0 >= 4U) {
#line 1751
                    tmp___19 = 1;
                  } else {
#line 1751
                    tmp___19 = 0;
                  }
                }
              } else {
#line 1751
                tmp___19 = 0;
              }
            }
#line 1751
            if (tmp___19) {
#line 1751
              tmp___15 = __builtin_strcmp((char const   *)rtype, "x11-req");
            } else {
#line 1751
              tmp___18 = __builtin_strcmp((char const   *)rtype, "x11-req");
#line 1751
              tmp___15 = tmp___18;
            }
          } else {
#line 1751
            tmp___18 = __builtin_strcmp((char const   *)rtype, "x11-req");
#line 1751
            tmp___15 = tmp___18;
          }
#line 1751
          if (tmp___15 == 0) {
#line 1752
            success = session_x11_req(s);
          } else {
#line 1753
            if (0) {
#line 1753
              __s1_len = strlen((char const   *)rtype);
#line 1753
              __s2_len = strlen("subsystem");
#line 1753
              if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
                goto _L___0;
              } else {
#line 1753
                if (__s1_len >= 4U) {
                  _L___0: /* CIL Label */ 
#line 1753
                  if (! ((unsigned int )((void const   *)("subsystem" + 1)) - (unsigned int )((void const   *)"subsystem") == 1U)) {
#line 1753
                    tmp___9 = 1;
                  } else {
#line 1753
                    if (__s2_len >= 4U) {
#line 1753
                      tmp___9 = 1;
                    } else {
#line 1753
                      tmp___9 = 0;
                    }
                  }
                } else {
#line 1753
                  tmp___9 = 0;
                }
              }
#line 1753
              if (tmp___9) {
#line 1753
                tmp___5 = __builtin_strcmp((char const   *)rtype, "subsystem");
              } else {
#line 1753
                tmp___8 = __builtin_strcmp((char const   *)rtype, "subsystem");
#line 1753
                tmp___5 = tmp___8;
              }
            } else {
#line 1753
              tmp___8 = __builtin_strcmp((char const   *)rtype, "subsystem");
#line 1753
              tmp___5 = tmp___8;
            }
#line 1753
            if (tmp___5 == 0) {
#line 1754
              success = session_subsystem_req(s);
            }
          }
        }
      }
    }
  }
#line 1757
  if (0) {
#line 1757
    __s1_len___4 = strlen((char const   *)rtype);
#line 1757
    __s2_len___4 = strlen("window-change");
#line 1757
    if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
      goto _L___10;
    } else {
#line 1757
      if (__s1_len___4 >= 4U) {
        _L___10: /* CIL Label */ 
#line 1757
        if (! ((unsigned int )((void const   *)("window-change" + 1)) - (unsigned int )((void const   *)"window-change") == 1U)) {
#line 1757
          tmp___59 = 1;
        } else {
#line 1757
          if (__s2_len___4 >= 4U) {
#line 1757
            tmp___59 = 1;
          } else {
#line 1757
            tmp___59 = 0;
          }
        }
      } else {
#line 1757
        tmp___59 = 0;
      }
    }
#line 1757
    if (tmp___59) {
#line 1757
      tmp___55 = __builtin_strcmp((char const   *)rtype, "window-change");
    } else {
#line 1757
      tmp___58 = __builtin_strcmp((char const   *)rtype, "window-change");
#line 1757
      tmp___55 = tmp___58;
    }
  } else {
#line 1757
    tmp___58 = __builtin_strcmp((char const   *)rtype, "window-change");
#line 1757
    tmp___55 = tmp___58;
  }
#line 1757
  if (tmp___55 == 0) {
#line 1758
    success = session_window_change_req(s);
  }
#line 1761
  if (reply) {
#line 1762
    if (success) {
#line 1762
      tmp___60 = 99;
    } else {
#line 1762
      tmp___60 = 100;
    }
#line 1762
    packet_start(tmp___60);
#line 1764
    packet_put_int((unsigned int )c->remote_id);
#line 1765
    packet_send();
  }
#line 1767
  xfree((void *)rtype);
#line 1768
  return;
}
}
#line 1770 "session.c"
void session_set_fds(Session *s , int fdin___0 , int fdout___0 , int fderr___0 ) 
{ int tmp ;

  {
#line 1773
  if (! compat20) {
#line 1774
    fatal("session_set_fds: called for proto != 2.0");
  }
#line 1779
  if (s->chanid == -1) {
#line 1780
    fatal("no channel for session %d", s->self);
  }
#line 1781
  if (fderr___0 == -1) {
#line 1781
    tmp = 0;
  } else {
#line 1781
    tmp = 1;
  }
#line 1781
  channel_set_fds(s->chanid, fdout___0, fdin___0, fderr___0, tmp, 1);
#line 1785
  return;
}
}
#line 1787 "session.c"
void session_pty_cleanup(Session *s ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1790
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1791
    return;
  } else {
#line 1790
    if (s->ttyfd == -1) {
#line 1791
      return;
    }
  }
#line 1793
  debug("session_pty_cleanup: session %i release %s", s->self, s->tty);
#line 1796
  fatal_remove_cleanup(& pty_cleanup_proc, (void *)s);
#line 1799
  record_logout(s->pid, (char const   *)(s->tty));
#line 1802
  pty_release((char const   *)(s->tty));
#line 1809
  tmp___1 = close(s->ptymaster);
#line 1809
  if (tmp___1 < 0) {
#line 1810
    tmp = __errno_location();
#line 1810
    tmp___0 = strerror(*tmp);
#line 1810
    error("close(s->ptymaster): %s", tmp___0);
  }
#line 1811
  return;
}
}
#line 1813 "session.c"
void session_exit_message(Session *s , int status ) 
{ Channel *c ;
  union __anonunion_77 __constr_expr_0 ;
  union __anonunion_78___0 __constr_expr_1 ;
  union __anonunion_79___0 __constr_expr_2 ;
  union __anonunion_80___0 __constr_expr_3 ;
  union __anonunion_81___0 __constr_expr_4 ;

  {
#line 1817
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1818
    fatal("session_close: no session");
  }
#line 1819
  c = channel_lookup(s->chanid);
#line 1820
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1821
    fatal("session_close: session %d: no channel %d", s->self, s->chanid);
  }
#line 1823
  debug("session_exit_message: session %d channel %d pid %d", s->self, s->chanid,
        s->pid);
#line 1826
  __constr_expr_4.__in = status;
#line 1826
  if ((__constr_expr_4.__i & 127) == 0) {
#line 1827
    channel_request_start(s->chanid, (char *)"exit-status", 0);
#line 1829
    __constr_expr_0.__in = status;
#line 1829
    packet_put_int((unsigned int )((__constr_expr_0.__i & 65280) >> 8));
#line 1830
    packet_send();
  } else {
#line 1831
    __constr_expr_3.__in = status;
#line 1831
    if ((int )((signed char )((__constr_expr_3.__i & 127) + 1)) >> 1 > 0) {
#line 1832
      channel_request_start(s->chanid, (char *)"exit-signal", 0);
#line 1834
      __constr_expr_1.__in = status;
#line 1834
      packet_put_int((unsigned int )(__constr_expr_1.__i & 127));
#line 1836
      __constr_expr_2.__in = status;
#line 1836
      packet_put_char(__constr_expr_2.__i & 128);
#line 1840
      packet_put_cstring("");
#line 1841
      packet_put_cstring("");
#line 1842
      packet_send();
    } else {
#line 1845
      packet_disconnect("wait returned status %04x.", status);
    }
  }
#line 1849
  debug("session_exit_message: release channel %d", s->chanid);
#line 1850
  channel_cancel_cleanup(s->chanid);
#line 1859
  if (c->ostate != 128) {
#line 1860
    (*chan_write_failed)(c);
  }
#line 1861
  if (c->istate != 8) {
#line 1862
    (*chan_read_failed)(c);
  }
#line 1863
  s->chanid = -1;
#line 1864
  return;
}
}
#line 1866 "session.c"
void session_free(Session *s ) 
{ 

  {
#line 1869
  debug("session_free: session %d pid %d", s->self, s->pid);
#line 1870
  if (s->term) {
#line 1871
    xfree((void *)s->term);
  }
#line 1872
  if (s->display) {
#line 1873
    xfree((void *)s->display);
  }
#line 1874
  if (s->auth_data) {
#line 1875
    xfree((void *)s->auth_data);
  }
#line 1876
  if (s->auth_proto) {
#line 1877
    xfree((void *)s->auth_proto);
  }
#line 1878
  s->used = 0;
#line 1879
  return;
}
}
#line 1881 "session.c"
void session_close(Session *s ) 
{ 

  {
#line 1884
  session_pty_cleanup(s);
#line 1885
  session_free(s);
#line 1886
  session_proctitle(s);
#line 1887
  return;
}
}
#line 1889 "session.c"
void session_close_by_pid(pid_t pid , int status ) 
{ Session *s ;
  Session *tmp ;

  {
#line 1892
  tmp = session_by_pid(pid);
#line 1892
  s = tmp;
#line 1893
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1894
    debug("session_close_by_pid: no session for pid %d", s->pid);
#line 1895
    return;
  }
#line 1897
  if (s->chanid != -1) {
#line 1898
    session_exit_message(s, status);
  }
#line 1899
  session_close(s);
#line 1900
  return;
}
}
#line 1906 "session.c"
void session_close_by_channel(int id , void *arg ) 
{ Session *s ;
  Session *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1909
  tmp = session_by_channel(id);
#line 1909
  s = tmp;
#line 1910
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1911
    debug("session_close_by_channel: no session for channel %d", id);
#line 1912
    return;
  }
#line 1915
  channel_cancel_cleanup(s->chanid);
#line 1916
  s->chanid = -1;
#line 1918
  debug("session_close_by_channel: channel %d kill %d", id, s->pid);
#line 1919
  if (s->pid == 0) {
#line 1921
    session_close(s);
  } else {
#line 1924
    if (s->pid <= 1) {
#line 1925
      fatal("session_close_by_channel: Unsafe s->pid = %d", s->pid);
    }
#line 1926
    if (s->ttyfd == -1) {
#line 1926
      tmp___2 = 15;
    } else {
#line 1926
      tmp___2 = 1;
    }
#line 1926
    tmp___3 = kill(s->pid, tmp___2);
#line 1926
    if (tmp___3 < 0) {
#line 1927
      tmp___0 = __errno_location();
#line 1927
      tmp___1 = strerror(*tmp___0);
#line 1927
      error("session_close_by_channel: kill %d: %s", s->pid, tmp___1);
    }
  }
#line 1930
  return;
}
}
#line 1935 "session.c"
static char buf___0[1024]  ;
#line 1932 "session.c"
char *session_tty_list(void) 
{ int i ;
  Session *s ;
  char *tmp ;

  {
#line 1937
  buf___0[0] = (char )'\000';
#line 1938
  i = 0;
#line 1938
  while (i < 10) {
#line 1939
    s = & sessions[i];
#line 1940
    if (s->used) {
#line 1940
      if (s->ttyfd != -1) {
#line 1941
        if ((int )buf___0[0] != 0) {
#line 1942
          strlcat(buf___0, ",", sizeof(buf___0));
        }
#line 1943
        tmp = strrchr((char const   *)(s->tty), '/');
#line 1943
        strlcat(buf___0, (char const   *)(tmp + 1), sizeof(buf___0));
      }
    }
#line 1938
    i ++;
  }
#line 1946
  if ((int )buf___0[0] == 0) {
#line 1947
    strlcpy(buf___0, "notty", sizeof(buf___0));
  }
#line 1948
  return (buf___0);
}
}
#line 1951 "session.c"
void session_proctitle(Session *s ) 
{ char *tmp ;

  {
#line 1954
  if ((unsigned int )s->pw == (unsigned int )((void *)0)) {
#line 1955
    error("no user for session %d", s->self);
  } else {
#line 1957
    tmp = session_tty_list();
#line 1957
    setproctitle("%s@%s", (s->pw)->pw_name, tmp);
  }
#line 1958
  return;
}
}
#line 1960 "session.c"
void do_authenticated2(void) 
{ 

  {
#line 1971
  alarm(0U);
#line 1972
  if (startup_pipe != -1) {
#line 1973
    close(startup_pipe);
#line 1974
    startup_pipe = -1;
  }
#line 1983
  server_loop2();
#line 1984
  if (xauthfile) {
#line 1985
    xauthfile_cleanup_proc((void *)0);
  }
#line 1986
  return;
}
}
