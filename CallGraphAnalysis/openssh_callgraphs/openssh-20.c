/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

#line 214 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stddef.h"
typedef unsigned int size_t;
#line 71 "/usr/include/openssl/rc4.h"
struct rc4_key_st {
   unsigned int x ;
   unsigned int y ;
   unsigned int data[256] ;
};
#line 71 "/usr/include/openssl/rc4.h"
typedef struct rc4_key_st RC4_KEY;
#line 34 "/usr/include/bits/types.h"
typedef unsigned char __u_char;
#line 35 "/usr/include/sys/types.h"
typedef __u_char u_char;
#line 45 "/usr/include/bits/types.h"
typedef unsigned int __uint32_t;
#line 195 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 202 "/usr/include/sys/types.h"
typedef unsigned short u_int16_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 36 "/usr/include/bits/socket.h"
typedef __socklen_t socklen_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 145 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 162 "/usr/include/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   __uint32_t __ss_align ;
   char __ss_padding[128U - 2U * sizeof(__uint32_t )] ;
};
#line 92 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 136 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 137 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 193 "/usr/include/netinet/in.h"
union __anonunion_in6_u_53 {
   uint8_t u6_addr8[16] ;
   uint16_t u6_addr16[8] ;
   uint32_t u6_addr32[4] ;
};
#line 193 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion_in6_u_53 in6_u ;
};
#line 219 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 233 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 59 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 144 "/usr/include/bits/types.h"
typedef long __off_t;
#line 145 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 177 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 183 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 268 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t )] ;
};
#line 35 "/usr/include/bits/types.h"
typedef unsigned short __u_short;
#line 36 "/usr/include/bits/types.h"
typedef unsigned int __u_int;
#line 60 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 137 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 141 "/usr/include/bits/types.h"
typedef __u_quad_t __ino64_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 143 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 152 "/usr/include/bits/types.h"
typedef long __time_t;
#line 167 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 173 "/usr/include/bits/types.h"
typedef __quad_t __blkcnt64_t;
#line 36 "/usr/include/sys/types.h"
typedef __u_short u_short;
#line 37 "/usr/include/sys/types.h"
typedef __u_int u_int;
#line 121 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino64_t d_ino ;
   __off64_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t __st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off64_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __ino64_t st_ino ;
};
#line 49 "./openbsd-compat/glob.h"
struct __anonstruct_glob_t_62 {
   int gl_pathc ;
   int gl_matchc ;
   int gl_offs ;
   int gl_flags ;
   char **gl_pathv ;
   int (*gl_errfunc)(char const   * , int  ) ;
   void (*gl_closedir)(void * ) ;
   struct dirent *(*gl_readdir)(void * ) ;
   void *(*gl_opendir)(char const   * ) ;
   int (*gl_lstat)(char const   * , struct stat * ) ;
   int (*gl_stat)(char const   * , struct stat * ) ;
};
#line 49 "./openbsd-compat/glob.h"
typedef struct __anonstruct_glob_t_62 glob_t;
#line 114 "openbsd-compat/glob.c"
typedef u_short Char;
#line 44 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 146 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 148 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 183 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 23 "/usr/include/bits/sigset.h"
typedef int __sig_atomic_t;
#line 28 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_11 {
   unsigned long __val[1024U / (8U * sizeof(unsigned long ))] ;
};
#line 28 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_11 __sigset_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 41 "/usr/include/signal.h"
typedef __sig_atomic_t sig_atomic_t;
#line 33 "/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__kill_26 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__timer_27 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__rt_28 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_29 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_30 {
   void *si_addr ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_31 {
   long si_band ;
   int si_fd ;
};
#line 51 "/usr/include/bits/siginfo.h"
union __anonunion__sifields_25 {
   int _pad[128U / sizeof(int ) - 3U] ;
   struct __anonstruct__kill_26 _kill ;
   struct __anonstruct__timer_27 _timer ;
   struct __anonstruct__rt_28 _rt ;
   struct __anonstruct__sigchld_29 _sigchld ;
   struct __anonstruct__sigfault_30 _sigfault ;
   struct __anonstruct__sigpoll_31 _sigpoll ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_25 _sifields ;
};
#line 51 "/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 25 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_43 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_43 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 25 "/usr/include/bits/termios.h"
typedef unsigned char cc_t;
#line 26 "/usr/include/bits/termios.h"
typedef unsigned int speed_t;
#line 27 "/usr/include/bits/termios.h"
typedef unsigned int tcflag_t;
#line 30 "/usr/include/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 30 "/usr/include/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 107 "/usr/include/openssl/ossl_typ.h"
struct bignum_st;
#line 107 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_st BIGNUM;
#line 108
struct bignum_ctx;
#line 108 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_ctx BN_CTX;
#line 109
struct bn_blinding_st;
#line 109 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_blinding_st BN_BLINDING;
#line 110
struct bn_mont_ctx_st;
#line 110 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_mont_ctx_st BN_MONT_CTX;
#line 112
struct bn_gencb_st;
#line 112 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_gencb_st BN_GENCB;
#line 125
struct dsa_st;
#line 125 "/usr/include/openssl/ossl_typ.h"
typedef struct dsa_st DSA;
#line 126
struct dsa_method;
#line 126 "/usr/include/openssl/ossl_typ.h"
typedef struct dsa_method DSA_METHOD;
#line 128
struct rsa_st;
#line 128 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_st RSA;
#line 129
struct rsa_meth_st;
#line 129 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_meth_st RSA_METHOD;
#line 154
struct engine_st;
#line 154 "/usr/include/openssl/ossl_typ.h"
typedef struct engine_st ENGINE;
#line 165
struct crypto_ex_data_st;
#line 165 "/usr/include/openssl/ossl_typ.h"
typedef struct crypto_ex_data_st CRYPTO_EX_DATA;
#line 66 "/usr/include/openssl/stack.h"
struct stack_st {
   int num ;
   char **data ;
   int sorted ;
   int num_alloc ;
   int (*comp)(char const   * const  * , char const   * const  * ) ;
};
#line 66 "/usr/include/openssl/stack.h"
typedef struct stack_st STACK;
#line 283 "/usr/include/openssl/crypto.h"
struct crypto_ex_data_st {
   STACK *sk ;
   int dummy ;
};
#line 285 "/usr/include/openssl/bn.h"
struct bignum_st {
   unsigned long *d ;
   int top ;
   int dmax ;
   int neg ;
   int flags ;
};
#line 296 "/usr/include/openssl/bn.h"
struct bn_mont_ctx_st {
   int ri ;
   BIGNUM RR ;
   BIGNUM N ;
   BIGNUM Ni ;
   unsigned long n0 ;
   int flags ;
};
#line 320 "/usr/include/openssl/bn.h"
union __anonunion_cb_64 {
   void (*cb_1)(int  , int  , void * ) ;
   int (*cb_2)(int  , int  , BN_GENCB * ) ;
};
#line 320 "/usr/include/openssl/bn.h"
struct bn_gencb_st {
   unsigned int ver ;
   void *arg ;
   union __anonunion_cb_64 cb ;
};
#line 85 "/usr/include/openssl/rsa.h"
struct rsa_meth_st {
   char const   *name ;
   int (*rsa_pub_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_pub_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_priv_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_priv_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_mod_exp)(BIGNUM *r0 , BIGNUM const   *I , RSA *rsa , BN_CTX *ctx ) ;
   int (*bn_mod_exp)(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(RSA *rsa ) ;
   int (*finish)(RSA *rsa ) ;
   int flags ;
   char *app_data ;
   int (*rsa_sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
                   unsigned int *siglen , RSA const   *rsa ) ;
   int (*rsa_verify)(int dtype , unsigned char const   *m , unsigned int m_length ,
                     unsigned char *sigbuf , unsigned int siglen , RSA const   *rsa ) ;
   int (*rsa_keygen)(RSA *rsa , int bits , BIGNUM *e , BN_GENCB *cb ) ;
};
#line 128 "/usr/include/openssl/rsa.h"
struct rsa_st {
   int pad ;
   long version ;
   RSA_METHOD const   *meth ;
   ENGINE *engine ;
   BIGNUM *n ;
   BIGNUM *e ;
   BIGNUM *d ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *dmp1 ;
   BIGNUM *dmq1 ;
   BIGNUM *iqmp ;
   CRYPTO_EX_DATA ex_data ;
   int references ;
   int flags ;
   BN_MONT_CTX *_method_mod_n ;
   BN_MONT_CTX *_method_mod_p ;
   BN_MONT_CTX *_method_mod_q ;
   char *bignum_data ;
   BN_BLINDING *blinding ;
   BN_BLINDING *mt_blinding ;
};
#line 19 "buffer.h"
struct __anonstruct_Buffer_67 {
   u_char *buf ;
   u_int alloc ;
   u_int offset ;
   u_int end ;
};
#line 19 "buffer.h"
typedef struct __anonstruct_Buffer_67 Buffer;
#line 106 "/usr/include/openssl/dsa.h"
struct DSA_SIG_st {
   BIGNUM *r ;
   BIGNUM *s ;
};
#line 106 "/usr/include/openssl/dsa.h"
typedef struct DSA_SIG_st DSA_SIG;
#line 112 "/usr/include/openssl/dsa.h"
struct dsa_method {
   char const   *name ;
   DSA_SIG *(*dsa_do_sign)(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
   int (*dsa_sign_setup)(DSA *dsa , BN_CTX *ctx_in , BIGNUM **kinvp , BIGNUM **rp ) ;
   int (*dsa_do_verify)(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                        DSA *dsa ) ;
   int (*dsa_mod_exp)(DSA *dsa , BIGNUM *rr , BIGNUM *a1 , BIGNUM *p1 , BIGNUM *a2 ,
                      BIGNUM *p2 , BIGNUM *m , BN_CTX *ctx , BN_MONT_CTX *in_mont ) ;
   int (*bn_mod_exp)(DSA *dsa , BIGNUM *r , BIGNUM *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DSA *dsa ) ;
   int (*finish)(DSA *dsa ) ;
   int flags ;
   char *app_data ;
   int (*dsa_paramgen)(DSA *dsa , int bits , unsigned char *seed , int seed_len ,
                       int *counter_ret , unsigned long *h_ret , BN_GENCB *cb ) ;
   int (*dsa_keygen)(DSA *dsa ) ;
};
#line 139 "/usr/include/openssl/dsa.h"
struct dsa_st {
   int pad ;
   long version ;
   int write_params ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *g ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   BIGNUM *kinv ;
   BIGNUM *r ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DSA_METHOD const   *meth ;
   ENGINE *engine ;
};
#line 32 "key.h"
struct Key;
#line 32 "key.h"
typedef struct Key Key;
#line 51 "key.h"
struct Key {
   int type ;
   int flags ;
   RSA *rsa ;
   DSA *dsa ;
};
#line 63 "authfd.h"
struct __anonstruct_AuthenticationConnection_68 {
   int fd ;
   Buffer identities ;
   int howmany ;
};
#line 63 "authfd.h"
typedef struct __anonstruct_AuthenticationConnection_68 AuthenticationConnection;
#line 90 "/usr/include/sys/types.h"
typedef __off64_t off_t;
#line 203 "/usr/include/sys/types.h"
typedef unsigned int u_int32_t;
#line 79 "/usr/include/openssl/ossl_typ.h"
struct asn1_string_st;
#line 79 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_INTEGER;
#line 80 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_ENUMERATED;
#line 81 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_BIT_STRING;
#line 82 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_OCTET_STRING;
#line 83 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_PRINTABLESTRING;
#line 84 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_T61STRING;
#line 85 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_IA5STRING;
#line 86 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_GENERALSTRING;
#line 87 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UNIVERSALSTRING;
#line 88 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_BMPSTRING;
#line 89 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UTCTIME;
#line 91 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_GENERALIZEDTIME;
#line 92 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_VISIBLESTRING;
#line 93 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UTF8STRING;
#line 94 "/usr/include/openssl/ossl_typ.h"
typedef int ASN1_BOOLEAN;
#line 116
struct evp_cipher_st;
#line 116 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_cipher_st EVP_CIPHER;
#line 117
struct evp_cipher_ctx_st;
#line 117 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_cipher_ctx_st EVP_CIPHER_CTX;
#line 120
struct evp_pkey_st;
#line 120 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_pkey_st EVP_PKEY;
#line 122
struct dh_st;
#line 122 "/usr/include/openssl/ossl_typ.h"
typedef struct dh_st DH;
#line 123
struct dh_method;
#line 123 "/usr/include/openssl/ossl_typ.h"
typedef struct dh_method DH_METHOD;
#line 206 "/usr/include/openssl/asn1.h"
struct asn1_object_st {
   char const   *sn ;
   char const   *ln ;
   int nid ;
   int length ;
   unsigned char *data ;
   int flags ;
};
#line 206 "/usr/include/openssl/asn1.h"
typedef struct asn1_object_st ASN1_OBJECT;
#line 222 "/usr/include/openssl/asn1.h"
struct asn1_string_st {
   int length ;
   int type ;
   unsigned char *data ;
   long flags ;
};
#line 222 "/usr/include/openssl/asn1.h"
typedef struct asn1_string_st ASN1_STRING;
#line 488 "/usr/include/openssl/asn1.h"
union __anonunion_value_65 {
   char *ptr ;
   ASN1_BOOLEAN boolean ;
   ASN1_STRING *asn1_string ;
   ASN1_OBJECT *object ;
   ASN1_INTEGER *integer ;
   ASN1_ENUMERATED *enumerated ;
   ASN1_BIT_STRING *bit_string ;
   ASN1_OCTET_STRING *octet_string ;
   ASN1_PRINTABLESTRING *printablestring ;
   ASN1_T61STRING *t61string ;
   ASN1_IA5STRING *ia5string ;
   ASN1_GENERALSTRING *generalstring ;
   ASN1_BMPSTRING *bmpstring ;
   ASN1_UNIVERSALSTRING *universalstring ;
   ASN1_UTCTIME *utctime ;
   ASN1_GENERALIZEDTIME *generalizedtime ;
   ASN1_VISIBLESTRING *visiblestring ;
   ASN1_UTF8STRING *utf8string ;
   ASN1_STRING *set ;
   ASN1_STRING *sequence ;
};
#line 488 "/usr/include/openssl/asn1.h"
struct asn1_type_st {
   int type ;
   union __anonunion_value_65 value ;
};
#line 488 "/usr/include/openssl/asn1.h"
typedef struct asn1_type_st ASN1_TYPE;
#line 126 "/usr/include/openssl/evp.h"
union __anonunion_pkey_66 {
   char *ptr ;
   struct rsa_st *rsa ;
   struct dsa_st *dsa ;
   struct dh_st *dh ;
};
#line 126 "/usr/include/openssl/evp.h"
struct evp_pkey_st {
   int type ;
   int save_type ;
   int references ;
   union __anonunion_pkey_66 pkey ;
   int save_parameters ;
   STACK *attributes ;
};
#line 297 "/usr/include/openssl/evp.h"
struct evp_cipher_st {
   int nid ;
   int block_size ;
   int key_len ;
   int iv_len ;
   unsigned long flags ;
   int (*init)(EVP_CIPHER_CTX *ctx , unsigned char const   *key , unsigned char const   *iv ,
               int enc ) ;
   int (*do_cipher)(EVP_CIPHER_CTX *ctx , unsigned char *out , unsigned char const   *in ,
                    unsigned int inl ) ;
   int (*cleanup)(EVP_CIPHER_CTX * ) ;
   int ctx_size ;
   int (*set_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*get_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*ctrl)(EVP_CIPHER_CTX * , int type , int arg , void *ptr ) ;
   void *app_data ;
};
#line 357 "/usr/include/openssl/evp.h"
struct evp_cipher_ctx_st {
   EVP_CIPHER const   *cipher ;
   ENGINE *engine ;
   int encrypt ;
   int buf_len ;
   unsigned char oiv[16] ;
   unsigned char iv[16] ;
   unsigned char buf[32] ;
   int num ;
   void *app_data ;
   int key_len ;
   unsigned long flags ;
   void *cipher_data ;
   int final_used ;
   int block_mask ;
   unsigned char final[32] ;
};
#line 95 "/usr/include/openssl/dh.h"
struct dh_method {
   char const   *name ;
   int (*generate_key)(DH *dh ) ;
   int (*compute_key)(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
   int (*bn_mod_exp)(DH const   *dh , BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p ,
                     BIGNUM const   *m , BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DH *dh ) ;
   int (*finish)(DH *dh ) ;
   int flags ;
   char *app_data ;
   int (*generate_params)(DH *dh , int prime_len , int generator , BN_GENCB *cb ) ;
};
#line 113 "/usr/include/openssl/dh.h"
struct dh_st {
   int pad ;
   int version ;
   BIGNUM *p ;
   BIGNUM *g ;
   long length ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   BIGNUM *q ;
   BIGNUM *j ;
   unsigned char *seed ;
   int seedlen ;
   BIGNUM *counter ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DH_METHOD const   *meth ;
   ENGINE *engine ;
};
#line 529 "/usr/include/openssl/pem.h"
typedef int pem_password_cb(char *buf , int size , int rwflag , void *userdata );
#line 61 "cipher.h"
struct Cipher;
#line 61 "cipher.h"
typedef struct Cipher Cipher;
#line 62
struct CipherContext;
#line 62 "cipher.h"
typedef struct CipherContext CipherContext;
#line 65 "cipher.h"
struct CipherContext {
   int plaintext ;
   EVP_CIPHER_CTX evp ;
   Cipher *cipher ;
};
#line 204 "/usr/include/sys/types.h"
typedef unsigned long long u_int64_t;
#line 321 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 538 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 201 "/usr/include/sys/types.h"
typedef unsigned char u_int8_t;
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_12 {
   __fd_mask __fds_bits[1024U / (8U * sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_12 fd_set;
#line 85 "/usr/include/sys/select.h"
typedef __fd_mask fd_mask;
#line 314 "/usr/include/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 62 "channels.h"
struct Channel;
#line 63 "channels.h"
typedef struct Channel Channel;
#line 65 "channels.h"
typedef void channel_callback_fn(int  , void * );
#line 66 "channels.h"
typedef int channel_filter_fn(struct Channel * , char * , int  );
#line 68 "channels.h"
struct Channel {
   int type ;
   int self ;
   int remote_id ;
   u_int istate ;
   u_int ostate ;
   int flags ;
   int rfd ;
   int wfd ;
   int efd ;
   int sock ;
   int isatty ;
   int force_drain ;
   int delayed ;
   Buffer input ;
   Buffer output ;
   Buffer extended ;
   char path[256] ;
   int listening_port ;
   int host_port ;
   char *remote_name ;
   u_int remote_window ;
   u_int remote_maxpacket ;
   u_int local_window ;
   u_int local_window_max ;
   u_int local_consumed ;
   u_int local_maxpacket ;
   int extended_usage ;
   int single_connection ;
   char *ctype ;
   channel_callback_fn *confirm ;
   channel_callback_fn *detach_user ;
   channel_filter_fn *input_filter ;
};
#line 88 "channels.c"
struct __anonstruct_ForwardPermission_70 {
   char *host_to_connect ;
   u_short port_to_connect ;
   u_short listen_port ;
};
#line 88 "channels.c"
typedef struct __anonstruct_ForwardPermission_70 ForwardPermission;
#line 667 "channels.c"
typedef void chan_fn(Channel *c , fd_set *readset , fd_set *writeset );
#line 872 "channels.c"
struct __anonstruct_s4_req_71 {
   u_int8_t version ;
   u_int8_t command ;
   u_int16_t dest_port ;
   struct in_addr dest_addr ;
};
#line 99 "/usr/include/openssl/md5.h"
struct MD5state_st {
   unsigned int A ;
   unsigned int B ;
   unsigned int C ;
   unsigned int D ;
   unsigned int Nl ;
   unsigned int Nh ;
   unsigned int data[16] ;
   unsigned int num ;
};
#line 99 "/usr/include/openssl/md5.h"
typedef struct MD5state_st MD5_CTX;
#line 58 "cipher.c"
struct Cipher {
   char *name ;
   int number ;
   u_int block_size ;
   u_int key_len ;
   EVP_CIPHER const   *(*evptype)(void) ;
};
#line 315 "cipher.c"
struct ssh1_3des_ctx {
   EVP_CIPHER_CTX k1 ;
   EVP_CIPHER_CTX k2 ;
   EVP_CIPHER_CTX k3 ;
};
#line 56 "compat.c"
struct __anonstruct_check_67 {
   char *pat ;
   int bugs ;
};
#line 261 "/usr/include/zconf.h"
typedef unsigned char Byte;
#line 263 "/usr/include/zconf.h"
typedef unsigned int uInt;
#line 264 "/usr/include/zconf.h"
typedef unsigned long uLong;
#line 270 "/usr/include/zconf.h"
typedef Byte Bytef;
#line 279 "/usr/include/zconf.h"
typedef void *voidpf;
#line 80 "/usr/include/zlib.h"
struct internal_state;
#line 82 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 82 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 103 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 1346 "/usr/include/zlib.h"
struct internal_state {
   int dummy ;
};
#line 29 "dh.h"
struct dhgroup {
   int size ;
   BIGNUM *g ;
   BIGNUM *p ;
};
#line 31 "dispatch.h"
typedef void dispatch_fn(int  , u_int32_t  , void * );
#line 43 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 105 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 39 "log.h"
enum __anonenum_LogLevel_64 {
    SYSLOG_LEVEL_QUIET = 0,
    SYSLOG_LEVEL_FATAL = 1,
    SYSLOG_LEVEL_ERROR = 2,
    SYSLOG_LEVEL_INFO = 3,
    SYSLOG_LEVEL_VERBOSE = 4,
    SYSLOG_LEVEL_DEBUG1 = 5,
    SYSLOG_LEVEL_DEBUG2 = 6,
    SYSLOG_LEVEL_DEBUG3 = 7,
    SYSLOG_LEVEL_NOT_SET = -1
} ;
#line 39 "log.h"
typedef enum __anonenum_LogLevel_64 LogLevel;
#line 118 "/usr/include/openssl/ossl_typ.h"
struct env_md_st;
#line 118 "/usr/include/openssl/ossl_typ.h"
typedef struct env_md_st EVP_MD;
#line 119
struct env_md_ctx_st;
#line 119 "/usr/include/openssl/ossl_typ.h"
typedef struct env_md_ctx_st EVP_MD_CTX;
#line 220 "/usr/include/openssl/evp.h"
struct env_md_st {
   int type ;
   int pkey_type ;
   int md_size ;
   unsigned long flags ;
   int (*init)(EVP_MD_CTX *ctx ) ;
   int (*update)(EVP_MD_CTX *ctx , void const   *data , size_t count ) ;
   int (*final)(EVP_MD_CTX *ctx , unsigned char *md ) ;
   int (*copy)(EVP_MD_CTX *to , EVP_MD_CTX const   *from ) ;
   int (*cleanup)(EVP_MD_CTX *ctx ) ;
   int (*sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
               unsigned int *siglen , void *key ) ;
   int (*verify)(int type , unsigned char const   *m , unsigned int m_length , unsigned char const   *sigbuf ,
                 unsigned int siglen , void *key ) ;
   int required_pkey_type[5] ;
   int block_size ;
   int ctx_size ;
};
#line 280 "/usr/include/openssl/evp.h"
struct env_md_ctx_st {
   EVP_MD const   *digest ;
   ENGINE *engine ;
   unsigned long flags ;
   void *md_data ;
};
#line 75 "/usr/include/openssl/hmac.h"
struct hmac_ctx_st {
   EVP_MD const   *md ;
   EVP_MD_CTX md_ctx ;
   EVP_MD_CTX i_ctx ;
   EVP_MD_CTX o_ctx ;
   unsigned int key_length ;
   unsigned char key[128] ;
};
#line 75 "/usr/include/openssl/hmac.h"
typedef struct hmac_ctx_st HMAC_CTX;
#line 65 "kex.h"
struct Mac;
#line 65 "kex.h"
typedef struct Mac Mac;
#line 79 "kex.h"
struct Mac {
   char *name ;
   int enabled ;
   EVP_MD const   *md ;
   int mac_len ;
   u_char *key ;
   int key_len ;
};
#line 37 "mac.c"
struct __anonstruct_macs_70 {
   char *name ;
   EVP_MD const   *(*mdfunc)(void) ;
   int truncatebits ;
};
#line 17 "hostfile.h"
enum __anonenum_HostStatus_66 {
    HOST_OK = 0,
    HOST_NEW = 1,
    HOST_CHANGED = 2
} ;
#line 17 "hostfile.h"
typedef enum __anonenum_HostStatus_66 HostStatus;
#line 39 "key.h"
enum fp_type {
    SSH_FP_SHA1 = 0,
    SSH_FP_MD5 = 1
} ;
#line 43
enum fp_rep {
    SSH_FP_HEX = 0,
    SSH_FP_BUBBLEBABBLE = 1
} ;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 64 "kex.h"
struct Kex;
#line 64 "kex.h"
typedef struct Kex Kex;
#line 66
struct Comp;
#line 66 "kex.h"
typedef struct Comp Comp;
#line 67
struct Enc;
#line 67 "kex.h"
typedef struct Enc Enc;
#line 68
struct Newkeys;
#line 68 "kex.h"
typedef struct Newkeys Newkeys;
#line 70 "kex.h"
struct Enc {
   char *name ;
   Cipher *cipher ;
   int enabled ;
   u_int key_len ;
   u_int block_size ;
   u_char *key ;
   u_char *iv ;
};
#line 87 "kex.h"
struct Comp {
   int type ;
   int enabled ;
   char *name ;
};
#line 92 "kex.h"
struct Newkeys {
   Enc enc ;
   Mac mac ;
   Comp comp ;
};
#line 97 "kex.h"
struct Kex {
   u_char *session_id ;
   int session_id_len ;
   Newkeys *newkeys[2] ;
   int we_need ;
   int server ;
   char *name ;
   int hostkey_type ;
   int kex_type ;
   Buffer my ;
   Buffer peer ;
   int done ;
   int flags ;
   char *client_version_string ;
   char *server_version_string ;
   int (*verify_host_key)(Key * ) ;
   Key *(*load_host_key)(int  ) ;
   int (*host_key_index)(Key * ) ;
};
#line 56 "monitor.h"
struct mm_master;
#line 57 "monitor.h"
struct monitor {
   int m_recvfd ;
   int m_sendfd ;
   struct mm_master *m_zback ;
   struct mm_master *m_zlib ;
   struct Kex **m_pkex ;
   pid_t m_pid ;
};
#line 21 "log.h"
enum __anonenum_SyslogFacility_63 {
    SYSLOG_FACILITY_DAEMON = 0,
    SYSLOG_FACILITY_USER = 1,
    SYSLOG_FACILITY_AUTH = 2,
    SYSLOG_FACILITY_AUTHPRIV = 3,
    SYSLOG_FACILITY_LOCAL0 = 4,
    SYSLOG_FACILITY_LOCAL1 = 5,
    SYSLOG_FACILITY_LOCAL2 = 6,
    SYSLOG_FACILITY_LOCAL3 = 7,
    SYSLOG_FACILITY_LOCAL4 = 8,
    SYSLOG_FACILITY_LOCAL5 = 9,
    SYSLOG_FACILITY_LOCAL6 = 10,
    SYSLOG_FACILITY_LOCAL7 = 11,
    SYSLOG_FACILITY_NOT_SET = -1
} ;
#line 21 "log.h"
typedef enum __anonenum_SyslogFacility_63 SyslogFacility;
#line 53 "log.c"
struct __anonstruct_log_facilities_65 {
   char const   *name ;
   SyslogFacility val ;
};
#line 74 "log.c"
struct __anonstruct_log_levels_66 {
   char const   *name ;
   LogLevel val ;
};
#line 177 "log.c"
struct fatal_cleanup {
   struct fatal_cleanup *next ;
   void (*proc)(void * ) ;
   void *context ;
};
#line 27 "misc.h"
struct arglist;
#line 27 "misc.h"
typedef struct arglist arglist;
#line 28 "misc.h"
struct arglist {
   char **list ;
   int num ;
   int nalloc ;
};
#line 36 "misc.h"
typedef void (*mysig_t)(int  );
#line 154 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 35 "rijndael.h"
typedef unsigned char u8;
#line 37 "rijndael.h"
typedef unsigned int u32;
#line 40 "rijndael.h"
struct __anonstruct_rijndael_ctx_63 {
   int decrypt ;
   int Nr ;
   u32 ek[60] ;
   u32 dk[60] ;
};
#line 40 "rijndael.h"
typedef struct __anonstruct_rijndael_ctx_63 rijndael_ctx;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 77 "/usr/include/time.h"
typedef __time_t time_t;
#line 45 "auth.h"
struct Authctxt;
#line 45 "auth.h"
typedef struct Authctxt Authctxt;
#line 49 "auth.h"
struct Authctxt {
   int success ;
   int postponed ;
   int valid ;
   int attempt ;
   int failures ;
   char *user ;
   char *service ;
   struct passwd *pw ;
   char *style ;
   void *kbdintctxt ;
};
#line 31 "monitor.h"
enum monitor_reqtype {
    MONITOR_REQ_MODULI = 0,
    MONITOR_ANS_MODULI = 1,
    MONITOR_REQ_FREE = 2,
    MONITOR_REQ_AUTHSERV = 3,
    MONITOR_REQ_SIGN = 4,
    MONITOR_ANS_SIGN = 5,
    MONITOR_REQ_PWNAM = 6,
    MONITOR_ANS_PWNAM = 7,
    MONITOR_REQ_AUTH2_READ_BANNER = 8,
    MONITOR_ANS_AUTH2_READ_BANNER = 9,
    MONITOR_REQ_AUTHPASSWORD = 10,
    MONITOR_ANS_AUTHPASSWORD = 11,
    MONITOR_REQ_BSDAUTHQUERY = 12,
    MONITOR_ANS_BSDAUTHQUERY = 13,
    MONITOR_REQ_BSDAUTHRESPOND = 14,
    MONITOR_ANS_BSDAUTHRESPOND = 15,
    MONITOR_REQ_SKEYQUERY = 16,
    MONITOR_ANS_SKEYQUERY = 17,
    MONITOR_REQ_SKEYRESPOND = 18,
    MONITOR_ANS_SKEYRESPOND = 19,
    MONITOR_REQ_KEYALLOWED = 20,
    MONITOR_ANS_KEYALLOWED = 21,
    MONITOR_REQ_KEYVERIFY = 22,
    MONITOR_ANS_KEYVERIFY = 23,
    MONITOR_REQ_KEYEXPORT = 24,
    MONITOR_REQ_PTY = 25,
    MONITOR_ANS_PTY = 26,
    MONITOR_REQ_PTYCLEANUP = 27,
    MONITOR_REQ_SESSKEY = 28,
    MONITOR_ANS_SESSKEY = 29,
    MONITOR_REQ_SESSID = 30,
    MONITOR_REQ_RSAKEYALLOWED = 31,
    MONITOR_ANS_RSAKEYALLOWED = 32,
    MONITOR_REQ_RSACHALLENGE = 33,
    MONITOR_ANS_RSACHALLENGE = 34,
    MONITOR_REQ_RSARESPONSE = 35,
    MONITOR_ANS_RSARESPONSE = 36,
    MONITOR_REQ_PAM_START = 37,
    MONITOR_REQ_TERM = 38
} ;
#line 36 "monitor_wrap.h"
enum mm_keytype {
    MM_NOKEY = 0,
    MM_HOSTKEY = 1,
    MM_USERKEY = 2,
    MM_RSAHOSTKEY = 3,
    MM_RSAUSERKEY = 4
} ;
#line 30 "session.h"
struct Session;
#line 30 "session.h"
typedef struct Session Session;
#line 31 "session.h"
struct Session {
   int used ;
   int self ;
   struct passwd *pw ;
   Authctxt *authctxt ;
   pid_t pid ;
   char *term ;
   int ptyfd ;
   int ttyfd ;
   int ptymaster ;
   u_int row ;
   u_int col ;
   u_int xpixel ;
   u_int ypixel ;
   char tty[64] ;
   char hostname[64] ;
   time_t last_login_time ;
   u_int display_number ;
   char *display ;
   u_int screen ;
   char *auth_display ;
   char *auth_proto ;
   char *auth_data ;
   int single_connection ;
   int chanid ;
   int is_subsystem ;
};
#line 44 "/usr/include/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 215 "/usr/include/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 233 "/usr/include/bits/socket.h"
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
#line 75 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 36 "servconf.h"
struct __anonstruct_ServerOptions_68 {
   u_int num_ports ;
   u_int ports_from_cmdline ;
   u_short ports[256] ;
   char *listen_addr ;
   struct addrinfo *listen_addrs ;
   char *host_key_files[256] ;
   int num_host_key_files ;
   char *pid_file ;
   int server_key_bits ;
   int login_grace_time ;
   int key_regeneration_time ;
   int permit_root_login ;
   int ignore_rhosts ;
   int ignore_user_known_hosts ;
   int print_motd ;
   int print_lastlog ;
   int x11_forwarding ;
   int x11_display_offset ;
   int x11_use_localhost ;
   char *xauth_location ;
   int strict_modes ;
   int keepalives ;
   char *ciphers ;
   char *macs ;
   int protocol ;
   int gateway_ports ;
   SyslogFacility log_facility ;
   LogLevel log_level ;
   int rhosts_authentication ;
   int rhosts_rsa_authentication ;
   int hostbased_authentication ;
   int hostbased_uses_name_from_packet_only ;
   int rsa_authentication ;
   int pubkey_authentication ;
   int password_authentication ;
   int kbd_interactive_authentication ;
   int challenge_response_authentication ;
   int permit_empty_passwd ;
   int use_login ;
   int compression ;
   int allow_tcp_forwarding ;
   u_int num_allow_users ;
   char *allow_users[256] ;
   u_int num_deny_users ;
   char *deny_users[256] ;
   u_int num_allow_groups ;
   char *allow_groups[256] ;
   u_int num_deny_groups ;
   char *deny_groups[256] ;
   u_int num_subsystems ;
   char *subsystem_name[256] ;
   char *subsystem_command[256] ;
   int max_startups_begin ;
   int max_startups_rate ;
   int max_startups ;
   char *banner ;
   int verify_reverse_mapping ;
   int client_alive_interval ;
   int client_alive_count_max ;
   char *authorized_keys_file ;
   char *authorized_keys_file2 ;
   int pam_authentication_via_kbd_int ;
};
#line 36 "servconf.h"
typedef struct __anonstruct_ServerOptions_68 ServerOptions;
#line 32 "monitor_mm.h"
struct __anonstruct_next_73 {
   struct mm_share *rbe_left ;
   struct mm_share *rbe_right ;
   struct mm_share *rbe_parent ;
   int rbe_color ;
};
#line 32 "monitor_mm.h"
struct mm_share {
   struct __anonstruct_next_73 next ;
   void *address ;
   size_t size ;
};
#line 38 "monitor_mm.h"
struct mmtree {
   struct mm_share *rbh_root ;
};
#line 38 "monitor_mm.h"
struct mm_master {
   struct mmtree rb_free ;
   struct mmtree rb_allocated ;
   void *address ;
   size_t size ;
   struct mm_master *mmalloc ;
   int write ;
   int read ;
};
#line 171 "sshd.c"
struct __anonstruct_sensitive_data_74 {
   Key *server_key ;
   Key *ssh1_host_key ;
   Key **host_keys ;
   int have_ssh1_key ;
   int have_ssh2_key ;
   u_char ssh1_cookie[32] ;
};
#line 40 "/usr/include/shadow.h"
struct spwd {
   char *sp_namp ;
   char *sp_pwdp ;
   long sp_lstchg ;
   long sp_min ;
   long sp_max ;
   long sp_warn ;
   long sp_inact ;
   long sp_expire ;
   unsigned long sp_flag ;
};
#line 46 "auth.h"
struct Authmethod;
#line 46 "auth.h"
typedef struct Authmethod Authmethod;
#line 75 "auth.h"
struct Authmethod {
   char *name ;
   int (*userauth)(Authctxt *authctxt ) ;
   int *enabled ;
};
#line 37 "/usr/include/bits/types.h"
typedef unsigned long __u_long;
#line 38 "/usr/include/sys/types.h"
typedef __u_long u_long;
#line 47 "auth.h"
struct KbdintDevice;
#line 47 "auth.h"
typedef struct KbdintDevice KbdintDevice;
#line 88 "auth.h"
struct KbdintDevice {
   char const   *name ;
   void *(*init_ctx)(Authctxt * ) ;
   int (*query)(void *ctx , char **name , char **infotxt , u_int *numprompts , char ***prompts ,
                u_int **echo_on ) ;
   int (*respond)(void *ctx , u_int numresp , char **responses ) ;
   void (*free_ctx)(void *ctx ) ;
};
#line 60 "auth2-chall.c"
struct KbdintAuthctxt;
#line 60 "auth2-chall.c"
typedef struct KbdintAuthctxt KbdintAuthctxt;
#line 61 "auth2-chall.c"
struct KbdintAuthctxt {
   char *devices ;
   void *ctxt ;
   KbdintDevice *device ;
   u_int nreq ;
};
#line 20 "auth-options.h"
struct envstring {
   struct envstring *next ;
   char *s ;
};
#line 43 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 28 "/usr/include/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 53 "loginrec.h"
union login_netinfo {
   struct sockaddr sa ;
   struct sockaddr_in sa_in ;
   struct sockaddr_storage sa_storage ;
};
#line 73 "loginrec.h"
struct logininfo {
   char progname[64] ;
   int progname_null ;
   short type ;
   int pid ;
   int uid ;
   char line[64] ;
   char username[64] ;
   char hostname[256] ;
   int exit ;
   int termination ;
   unsigned int tv_sec ;
   unsigned int tv_usec ;
   union login_netinfo hostaddr ;
};
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 38 "/usr/include/bits/utmp.h"
struct lastlog {
   __time_t ll_time ;
   char ll_line[32] ;
   char ll_host[256] ;
};
#line 52 "/usr/include/bits/utmp.h"
struct exit_status {
   short e_termination ;
   short e_exit ;
};
#line 60 "/usr/include/bits/utmp.h"
struct utmp {
   short ut_type ;
   pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct exit_status ut_exit ;
   long ut_session ;
   struct timeval ut_tv ;
   int32_t ut_addr_v6[4] ;
   char __unused[20] ;
};
#line 272 "servconf.c"
enum __anonenum_ServerOpCodes_71 {
    sBadOption = 0,
    sPAMAuthenticationViaKbdInt = 1,
    sPort = 2,
    sHostKeyFile = 3,
    sServerKeyBits = 4,
    sLoginGraceTime = 5,
    sKeyRegenerationTime = 6,
    sPermitRootLogin = 7,
    sLogFacility = 8,
    sLogLevel = 9,
    sRhostsAuthentication = 10,
    sRhostsRSAAuthentication = 11,
    sRSAAuthentication = 12,
    sChallengeResponseAuthentication = 13,
    sPasswordAuthentication = 14,
    sKbdInteractiveAuthentication = 15,
    sListenAddress = 16,
    sPrintMotd = 17,
    sPrintLastLog = 18,
    sIgnoreRhosts = 19,
    sX11Forwarding = 20,
    sX11DisplayOffset = 21,
    sX11UseLocalhost = 22,
    sStrictModes = 23,
    sEmptyPasswd = 24,
    sKeepAlives = 25,
    sUseLogin = 26,
    sAllowTcpForwarding = 27,
    sCompression = 28,
    sAllowUsers = 29,
    sDenyUsers = 30,
    sAllowGroups = 31,
    sDenyGroups = 32,
    sIgnoreUserKnownHosts = 33,
    sCiphers = 34,
    sMacs = 35,
    sProtocol = 36,
    sPidFile = 37,
    sGatewayPorts = 38,
    sPubkeyAuthentication = 39,
    sXAuthLocation = 40,
    sSubsystem = 41,
    sMaxStartups = 42,
    sBanner = 43,
    sVerifyReverseMapping = 44,
    sHostbasedAuthentication = 45,
    sHostbasedUsesNameFromPacketOnly = 46,
    sClientAliveInterval = 47,
    sClientAliveCountMax = 48,
    sAuthorizedKeysFile = 49,
    sAuthorizedKeysFile2 = 50,
    sUsePrivilegeSeparation = 51,
    sDeprecated = 52
} ;
#line 272 "servconf.c"
typedef enum __anonenum_ServerOpCodes_71 ServerOpCodes;
#line 306 "servconf.c"
struct __anonstruct_keywords_72 {
   char const   *name ;
   ServerOpCodes opcode ;
};
#line 683 "serverloop.c"
union __anonunion_73 {
   int __in ;
   int __i ;
};
#line 685 "serverloop.c"
union __anonunion_74 {
   int __in ;
   int __i ;
};
#line 681 "serverloop.c"
union __anonunion_75 {
   int __in ;
   int __i ;
};
#line 706 "serverloop.c"
union __anonunion_76 {
   int __in ;
   int __i ;
};
#line 705 "serverloop.c"
union __anonunion_77 {
   int __in ;
   int __i ;
};
#line 1814 "session.c"
union __anonunion_71 {
   int __in ;
   int __i ;
};
#line 1818 "session.c"
union __anonunion_72 {
   int __in ;
   int __i ;
};
#line 1820 "session.c"
union __anonunion_73___0 {
   int __in ;
   int __i ;
};
#line 1816 "session.c"
union __anonunion_74___0 {
   int __in ;
   int __i ;
};
#line 1812 "session.c"
union __anonunion_75___0 {
   int __in ;
   int __i ;
};
#line 74 "monitor.h"
struct mon_table;
#line 75 "monitor.c"
struct __anonstruct_child_state_73 {
   z_stream incoming ;
   z_stream outgoing ;
   u_char *keyin ;
   u_int keyinlen ;
   u_char *keyout ;
   u_int keyoutlen ;
   u_char *ivin ;
   u_int ivinlen ;
   u_char *ivout ;
   u_int ivoutlen ;
   u_char *ssh1key ;
   u_int ssh1keylen ;
   int ssh1cipher ;
   int ssh1protoflags ;
   u_char *input ;
   u_int ilen ;
   u_char *output ;
   u_int olen ;
};
#line 136 "monitor.c"
struct mon_table {
   enum monitor_reqtype type ;
   int flags ;
   int (*f)(int  , Buffer * ) ;
};
#line 1294 "monitor.c"
union __anonunion_74___1 {
   int __in ;
   int __i ;
};
#line 1294 "monitor.c"
union __anonunion_75___1 {
   int __in ;
   int __i ;
};
#line 1294 "monitor.c"
union __anonunion_76___0 {
   int __in ;
   int __i ;
};
#line 1294 "monitor.c"
union __anonunion_77___0 {
   int __in ;
   int __i ;
};
#line 1 "port-irix.o"
#line 1 "port-aix.o"
#line 1 "bsd-arc4random.o"
#line 59 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 33 "./openbsd-compat/bsd-arc4random.h"
unsigned int arc4random(void) ;
#line 34
void arc4random_stir(void) ;
#line 30 "./entropy.h"
void seed_rng(void) ;
#line 56 "./log.h"
void ( /* format attribute */  fatal)(char const   *fmt  , ...) ;
#line 102 "/usr/include/openssl/rand.h"
extern int RAND_bytes(unsigned char *buf , int num ) ;
#line 79 "/usr/include/openssl/rc4.h"
extern void RC4_set_key(RC4_KEY *key , int len , unsigned char const   *data ) ;
#line 80
extern void RC4(RC4_KEY *key , unsigned long len , unsigned char const   *indata ,
                unsigned char *outdata ) ;
#line 258 "/usr/include/openssl/err.h"
extern unsigned long ERR_get_error(void) ;
#line 42 "openbsd-compat/bsd-arc4random.c"
static int rc4_ready  =    0;
#line 43 "openbsd-compat/bsd-arc4random.c"
static RC4_KEY rc4  ;
#line 48 "openbsd-compat/bsd-arc4random.c"
static int first_time  =    1;
#line 45 "openbsd-compat/bsd-arc4random.c"
unsigned int arc4random(void) 
{ unsigned int r ;

  {
#line 47
  r = 0U;
#line 50
  if (rc4_ready <= 0) {
#line 51
    if (first_time) {
#line 52
      seed_rng();
    }
#line 53
    first_time = 0;
#line 54
    arc4random_stir();
  }
#line 57
  RC4(& rc4, (unsigned long )sizeof(r), (unsigned char const   *)((unsigned char *)(& r)),
      (unsigned char *)(& r));
#line 59
  rc4_ready = (int )((unsigned int )rc4_ready - sizeof(r));
#line 61
  return (r);
}
}
#line 64 "openbsd-compat/bsd-arc4random.c"
void arc4random_stir(void) 
{ unsigned char rand_buf[20] ;
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 68
  memset((void *)(& rc4), 0, sizeof(rc4));
#line 69
  tmp___0 = RAND_bytes(rand_buf, (int )sizeof(rand_buf));
#line 69
  if (! tmp___0) {
#line 70
    tmp = ERR_get_error();
#line 70
    fatal("Couldn\'t obtain random bytes (error %ld)", tmp);
  }
#line 72
  RC4_set_key(& rc4, (int )sizeof(rand_buf), (unsigned char const   *)(rand_buf));
#line 73
  memset((void *)(rand_buf), 0, sizeof(rand_buf));
#line 75
  rc4_ready = 1 << 24;
#line 76
  return;
}
}
#line 1 "bsd-cray.o"
#line 1 "bsd-cygwin_util.o"
#line 1 "bsd-misc.o"
#line 828 "/usr/include/unistd.h"
 __attribute__((__nothrow__)) int setlogin(char const   *name )  __attribute__((__nonnull__(1))) ;
#line 32 "./openbsd-compat/bsd-misc.h"
char *get_progname(char *argv0___0 ) ;
#line 32 "openbsd-compat/bsd-misc.c"
extern char *__progname ;
#line 29 "openbsd-compat/bsd-misc.c"
char *get_progname(char *argv0___0 ) 
{ 

  {
#line 34
  return (__progname);
}
}
#line 50
 __attribute__((__nothrow__)) int setlogin(char const   *name )  __attribute__((__nonnull__(1))) ;
#line 50 "openbsd-compat/bsd-misc.c"
int setlogin(char const   *name ) 
{ 

  {
#line 52
  return (0);
}
}
#line 1 "bsd-nextstep.o"
#line 1 "bsd-snprintf.o"
#line 1 "bsd-waitpid.o"
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
#line 1 "base64.o"
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 628 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 10 "openbsd-compat/base64.h"
int b64_ntop(u_char const   *src , size_t srclength , char *target , size_t targsize ) ;
#line 12
int b64_pton(char const   *src , u_char *target , size_t targsize ) ;
#line 65 "openbsd-compat/base64.c"
static char const   Base64[65]  = 
#line 65 "openbsd-compat/base64.c"
  {      (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'g',      (char const   )'h',      (char const   )'i',      (char const   )'j', 
        (char const   )'k',      (char const   )'l',      (char const   )'m',      (char const   )'n', 
        (char const   )'o',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'+',      (char const   )'/', 
        (char const   )'\000'};
#line 67 "openbsd-compat/base64.c"
static char const   Pad64  =    (char const   )'=';
#line 132 "openbsd-compat/base64.c"
int b64_ntop(u_char const   *src , size_t srclength , char *target , size_t targsize ) 
{ size_t datalength ;
  u_char input___0[3] ;
  u_char output___0[4] ;
  int i ;
  u_char const   *tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  u_char const   *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;

  {
#line 135
  datalength = (size_t )0;
#line 140
  while (2U < srclength) {
#line 141
    tmp = src;
#line 141
    src ++;
#line 141
    input___0[0] = (unsigned char )*tmp;
#line 142
    tmp___0 = src;
#line 142
    src ++;
#line 142
    input___0[1] = (unsigned char )*tmp___0;
#line 143
    tmp___1 = src;
#line 143
    src ++;
#line 143
    input___0[2] = (unsigned char )*tmp___1;
#line 144
    srclength -= 3U;
#line 146
    output___0[0] = (unsigned char )((int )input___0[0] >> 2);
#line 147
    output___0[1] = (unsigned char )((((int )input___0[0] & 3) << 4) + ((int )input___0[1] >> 4));
#line 148
    output___0[2] = (unsigned char )((((int )input___0[1] & 15) << 2) + ((int )input___0[2] >> 6));
#line 149
    output___0[3] = (unsigned char )((int )input___0[2] & 63);
#line 150
    if (! ((int )output___0[0] < 64)) {
#line 150
      abort();
    }
#line 151
    if (! ((int )output___0[1] < 64)) {
#line 151
      abort();
    }
#line 152
    if (! ((int )output___0[2] < 64)) {
#line 152
      abort();
    }
#line 153
    if (! ((int )output___0[3] < 64)) {
#line 153
      abort();
    }
#line 155
    if (datalength + 4U > targsize) {
#line 156
      return (-1);
    }
#line 157
    tmp___2 = datalength;
#line 157
    datalength ++;
#line 157
    *(target + tmp___2) = (char )Base64[output___0[0]];
#line 158
    tmp___3 = datalength;
#line 158
    datalength ++;
#line 158
    *(target + tmp___3) = (char )Base64[output___0[1]];
#line 159
    tmp___4 = datalength;
#line 159
    datalength ++;
#line 159
    *(target + tmp___4) = (char )Base64[output___0[2]];
#line 160
    tmp___5 = datalength;
#line 160
    datalength ++;
#line 160
    *(target + tmp___5) = (char )Base64[output___0[3]];
  }
#line 164
  if (0U != srclength) {
#line 166
    input___0[2] = (unsigned char )'\000';
#line 166
    input___0[1] = input___0[2];
#line 166
    input___0[0] = input___0[1];
#line 167
    i = 0;
#line 167
    while ((size_t )i < srclength) {
#line 168
      tmp___6 = src;
#line 168
      src ++;
#line 168
      input___0[i] = (unsigned char )*tmp___6;
#line 167
      i ++;
    }
#line 170
    output___0[0] = (unsigned char )((int )input___0[0] >> 2);
#line 171
    output___0[1] = (unsigned char )((((int )input___0[0] & 3) << 4) + ((int )input___0[1] >> 4));
#line 172
    output___0[2] = (unsigned char )((((int )input___0[1] & 15) << 2) + ((int )input___0[2] >> 6));
#line 173
    if (! ((int )output___0[0] < 64)) {
#line 173
      abort();
    }
#line 174
    if (! ((int )output___0[1] < 64)) {
#line 174
      abort();
    }
#line 175
    if (! ((int )output___0[2] < 64)) {
#line 175
      abort();
    }
#line 177
    if (datalength + 4U > targsize) {
#line 178
      return (-1);
    }
#line 179
    tmp___7 = datalength;
#line 179
    datalength ++;
#line 179
    *(target + tmp___7) = (char )Base64[output___0[0]];
#line 180
    tmp___8 = datalength;
#line 180
    datalength ++;
#line 180
    *(target + tmp___8) = (char )Base64[output___0[1]];
#line 181
    if (srclength == 1U) {
#line 182
      tmp___9 = datalength;
#line 182
      datalength ++;
#line 182
      *(target + tmp___9) = (char )Pad64;
    } else {
#line 184
      tmp___10 = datalength;
#line 184
      datalength ++;
#line 184
      *(target + tmp___10) = (char )Base64[output___0[2]];
    }
#line 185
    tmp___11 = datalength;
#line 185
    datalength ++;
#line 185
    *(target + tmp___11) = (char )Pad64;
  }
#line 187
  if (datalength >= targsize) {
#line 188
    return (-1);
  }
#line 189
  *(target + datalength) = (char )'\000';
#line 190
  return ((int )datalength);
}
}
#line 199 "openbsd-compat/base64.c"
int b64_pton(char const   *src , u_char *target , size_t targsize ) 
{ int tarindex ;
  int state ;
  int ch ;
  char *pos ;
  unsigned short const   **tmp ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  unsigned short const   **tmp___8 ;

  {
#line 205
  state = 0;
#line 206
  tarindex = 0;
#line 208
  while (1) {
#line 208
    tmp___2 = src;
#line 208
    src ++;
#line 208
    ch = (int )*tmp___2;
#line 208
    if (! (ch != 0)) {
#line 208
      break;
    }
#line 209
    tmp = __ctype_b_loc();
#line 209
    if ((int const   )*(*tmp + ch) & 8192) {
#line 210
      continue;
    }
#line 212
    if (ch == (int )Pad64) {
#line 213
      break;
    }
#line 215
    tmp___1 = __builtin_strchr((char *)(Base64), ch);
#line 215
    pos = tmp___1;
#line 216
    if ((unsigned int )pos == (unsigned int )((char *)0)) {
#line 217
      return (-1);
    }
#line 219
    switch (state) {
    case 0: 
#line 221
    if (target) {
#line 222
      if ((size_t )tarindex >= targsize) {
#line 223
        return (-1);
      }
#line 224
      *(target + tarindex) = (unsigned char )((pos - (char *)(Base64)) << 2);
    }
#line 226
    state = 1;
#line 227
    break;
    case 1: 
#line 229
    if (target) {
#line 230
      if ((size_t )(tarindex + 1) >= targsize) {
#line 231
        return (-1);
      }
#line 232
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | ((pos - (char *)(Base64)) >> 4));
#line 233
      *(target + (tarindex + 1)) = (unsigned char )(((pos - (char *)(Base64)) & 15) << 4);
    }
#line 236
    tarindex ++;
#line 237
    state = 2;
#line 238
    break;
    case 2: 
#line 240
    if (target) {
#line 241
      if ((size_t )(tarindex + 1) >= targsize) {
#line 242
        return (-1);
      }
#line 243
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | ((pos - (char *)(Base64)) >> 2));
#line 244
      *(target + (tarindex + 1)) = (unsigned char )(((pos - (char *)(Base64)) & 3) << 6);
    }
#line 247
    tarindex ++;
#line 248
    state = 3;
#line 249
    break;
    case 3: 
#line 251
    if (target) {
#line 252
      if ((size_t )tarindex >= targsize) {
#line 253
        return (-1);
      }
#line 254
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | (pos - (char *)(Base64)));
    }
#line 256
    tarindex ++;
#line 257
    state = 0;
#line 258
    break;
    }
  }
#line 267
  if (ch == (int )Pad64) {
#line 268
    tmp___3 = src;
#line 268
    src ++;
#line 268
    ch = (int )*tmp___3;
#line 269
    switch (state) {
    case 0: 
    case 1: 
#line 272
    return (-1);
    case 2: 
#line 276
    while (ch != 0) {
#line 277
      tmp___5 = __ctype_b_loc();
#line 277
      if (! ((int const   )*(*tmp___5 + ch) & 8192)) {
#line 278
        break;
      }
#line 276
      tmp___4 = src;
#line 276
      src ++;
#line 276
      ch = (int )*tmp___4;
    }
#line 280
    if (ch != (int )Pad64) {
#line 281
      return (-1);
    }
#line 282
    tmp___6 = src;
#line 282
    src ++;
#line 282
    ch = (int )*tmp___6;
    case 3: 
#line 291
    while (ch != 0) {
#line 292
      tmp___8 = __ctype_b_loc();
#line 292
      if (! ((int const   )*(*tmp___8 + ch) & 8192)) {
#line 293
        return (-1);
      }
#line 291
      tmp___7 = src;
#line 291
      src ++;
#line 291
      ch = (int )*tmp___7;
    }
#line 301
    if (target) {
#line 301
      if ((int )*(target + tarindex) != 0) {
#line 302
        return (-1);
      }
    }
    }
  } else {
#line 309
    if (state != 0) {
#line 310
      return (-1);
    }
  }
#line 313
  return (tarindex);
}
}
#line 1 "bindresvport.o"
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 110 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  *__addr ,
                                              socklen_t __len ) ;
#line 114
extern  __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 9 "./openbsd-compat/bindresvport.h"
int bindresvport_sa(int sd , struct sockaddr *sa ) ;
#line 55 "openbsd-compat/bindresvport.c"
int bindresvport_sa(int sd , struct sockaddr *sa ) 
{ int error___0 ;
  int af ;
  struct sockaddr_storage myaddr ;
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;
  u_int16_t *portp ;
  u_int16_t port ;
  socklen_t salen ;
  int i ;
  int tmp ;
  int *tmp___0 ;
  register unsigned short __v ;
  register unsigned short __x ;
  unsigned int tmp___1 ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 69
  if ((unsigned int )sa == (unsigned int )((void *)0)) {
#line 70
    memset((void *)(& myaddr), 0, sizeof(myaddr));
#line 71
    sa = (struct sockaddr *)(& myaddr);
#line 73
    tmp = getsockname(sd, (struct sockaddr * __restrict  )sa, (socklen_t * __restrict  )(& salen));
#line 73
    if (tmp == -1) {
#line 74
      return (-1);
    }
#line 76
    af = (int )sa->sa_family;
#line 77
    memset((void *)(& myaddr), 0, salen);
  } else {
#line 79
    af = (int )sa->sa_family;
  }
#line 81
  if (af == 2) {
#line 82
    sin = (struct sockaddr_in *)sa;
#line 83
    salen = sizeof(struct sockaddr_in );
#line 84
    portp = & sin->sin_port;
  } else {
#line 85
    if (af == 10) {
#line 86
      sin6 = (struct sockaddr_in6 *)sa;
#line 87
      salen = sizeof(struct sockaddr_in6 );
#line 88
      portp = & sin6->sin6_port;
    } else {
#line 90
      tmp___0 = __errno_location();
#line 90
      *tmp___0 = 96;
#line 91
      return (-1);
    }
  }
#line 93
  sa->sa_family = (unsigned short )af;
#line 95
  __x = *portp;
#line 95
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 95
  port = __v;
#line 96
  if ((int )port == 0) {
#line 97
    tmp___1 = arc4random();
#line 97
    port = (unsigned short )(tmp___1 % 424U + 600U);
  }
#line 100
  error___0 = -1;
#line 102
  i = 0;
#line 102
  while (i < 424) {
#line 103
    __x___0 = port;
#line 103
    __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 103
    *portp = __v___0;
#line 105
    error___0 = bind(sd, (struct sockaddr  const  *)sa, salen);
#line 108
    if (error___0 == 0) {
#line 109
      break;
    }
#line 112
    if (error___0 < 0) {
#line 112
      tmp___2 = __errno_location();
#line 112
      if (! (*tmp___2 == 98)) {
#line 112
        tmp___3 = __errno_location();
#line 112
        if (! (*tmp___3 == 22)) {
#line 113
          break;
        }
      }
    }
#line 115
    port = (u_int16_t )((int )port + 1);
#line 116
    if ((int )port > 1023) {
#line 117
      port = (unsigned short)600;
    }
#line 102
    i ++;
  }
#line 120
  return (error___0);
}
}
#line 1 "daemon.o"
#line 1 "dirname.o"
#line 1 "getcwd.o"
#line 1 "getgrouplist.o"
#line 1 "getopt.o"
#line 144 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 327
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 45 "openbsd-compat/getopt.c"
int BSDopterr  =    1;
#line 45 "openbsd-compat/getopt.c"
int BSDoptind  =    1;
#line 45 "openbsd-compat/getopt.c"
int BSDoptopt  ;
#line 45 "openbsd-compat/getopt.c"
int BSDoptreset  ;
#line 49 "openbsd-compat/getopt.c"
char *BSDoptarg  ;
#line 66
int BSDgetopt(int nargc , char * const  *nargv , char const   *ostr ) ;
#line 66 "openbsd-compat/getopt.c"
static char *place  =    (char *)"";
#line 59 "openbsd-compat/getopt.c"
int BSDgetopt(int nargc , char * const  *nargv , char const   *ostr ) 
{ char *oli ;
  char *tmp ;
  char *tmp___1 ;

  {
#line 69
  if (BSDoptreset) {
    goto _L;
  } else {
#line 69
    if (! *place) {
      _L: /* CIL Label */ 
#line 70
      BSDoptreset = 0;
#line 71
      if (BSDoptind >= nargc) {
#line 72
        place = (char *)"";
#line 73
        return (-1);
      } else {
#line 71
        place = (char *)*(nargv + BSDoptind);
#line 71
        if ((int )*place != 45) {
#line 72
          place = (char *)"";
#line 73
          return (-1);
        }
      }
#line 75
      if (*(place + 1)) {
#line 75
        place ++;
#line 75
        if ((int )*place == 45) {
#line 76
          BSDoptind ++;
#line 77
          place = (char *)"";
#line 78
          return (-1);
        }
      }
    }
  }
#line 81
  tmp = place;
#line 81
  place ++;
#line 81
  BSDoptopt = (int )*tmp;
#line 81
  if (BSDoptopt == 58) {
    goto _L___0;
  } else {
#line 81
    tmp___1 = __builtin_strchr((char *)ostr, BSDoptopt);
#line 81
    oli = tmp___1;
#line 81
    if (! oli) {
      _L___0: /* CIL Label */ 
#line 87
      if (BSDoptopt == 45) {
#line 88
        return (-1);
      }
#line 89
      if (! *place) {
#line 90
        BSDoptind ++;
      }
#line 91
      if (BSDopterr) {
#line 91
        if ((int const   )*ostr != 58) {
#line 92
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: illegal option -- %c\n",
                  __progname, BSDoptopt);
        }
      }
#line 94
      return ('?');
    }
  }
#line 96
  oli ++;
#line 96
  if ((int )*oli != 58) {
#line 97
    BSDoptarg = (char *)((void *)0);
#line 98
    if (! *place) {
#line 99
      BSDoptind ++;
    }
  } else {
#line 102
    if (*place) {
#line 103
      BSDoptarg = place;
    } else {
#line 104
      BSDoptind ++;
#line 104
      if (nargc <= BSDoptind) {
#line 105
        place = (char *)"";
#line 106
        if ((int const   )*ostr == 58) {
#line 107
          return (':');
        }
#line 108
        if (BSDopterr) {
#line 109
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: option requires an argument -- %c\n",
                  __progname, BSDoptopt);
        }
#line 112
        return ('?');
      } else {
#line 115
        BSDoptarg = (char *)*(nargv + BSDoptind);
      }
    }
#line 116
    place = (char *)"";
#line 117
    BSDoptind ++;
  }
#line 119
  return (BSDoptopt);
}
}
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
#line 1 "glob.o"
#line 589 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 600
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__warn_unused_result__,
__malloc__)) ;
#line 603
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 660
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 780
extern void qsort(void *__base , size_t __nmemb , size_t __size , int (*__compar)(void const   * ,
                                                                                  void const   * ) )  __attribute__((__nonnull__(1,4))) ;
#line 84 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strcpy(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 242
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 111 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 117
extern struct passwd *getpwnam(char const   *__name ) ;
#line 135 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 150
extern int closedir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 166
extern struct dirent *readdir(DIR *__dirp )  __asm__("readdir64") __attribute__((__nonnull__(1))) ;
#line 642 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 645
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 263
__inline static  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path ,
                                                        struct stat * __restrict  __statbuf )  __asm__("lstat64") __attribute__((__nonnull__(1,2))) ;
#line 394
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __asm__("__xstat64") __attribute__((__nonnull__(2,3))) ;
#line 397
extern  __attribute__((__nothrow__)) int __lxstat(int __ver , char const   *__filename ,
                                                  struct stat *__stat_buf )  __asm__("__lxstat64") __attribute__((__nonnull__(2,3))) ;
#line 433
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 433 "/usr/include/sys/stat.h"
__inline static int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
#line 436
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
#line 436
  return (tmp);
}
}
#line 440
__inline static  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path ,
                                                        struct stat * __restrict  __statbuf )  __asm__("lstat64") __attribute__((__nonnull__(1,2))) ;
#line 440 "/usr/include/sys/stat.h"
__inline static int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
#line 443
  tmp = __lxstat(3, (char const   *)__path, (struct stat *)__statbuf);
#line 443
  return (tmp);
}
}
#line 94 "./openbsd-compat/glob.h"
int glob(char const   *pattern , int flags , int (*errfunc)(char const   * , int  ) ,
         glob_t *pglob ) ;
#line 95
void globfree(glob_t *pglob ) ;
#line 40 "openbsd-compat/glob.c"
static long get_arg_max(void) 
{ 

  {
#line 44
  return (131072L);
}
}
#line 139
static int compare(void const   *p , void const   *q ) ;
#line 140
static int g_Ctoc(Char const   *str , char *buf___1 , u_int len ) ;
#line 141
static int g_lstat(Char *fn , struct stat *sb , glob_t *pglob ) ;
#line 142
static DIR *g_opendir(Char *str , glob_t *pglob ) ;
#line 143
static Char *g_strchr(Char *str , int ch ) ;
#line 144
static int g_stat(Char *fn , struct stat *sb , glob_t *pglob ) ;
#line 145
static int glob0(Char const   *pattern , glob_t *pglob ) ;
#line 146
static int glob1(Char *pattern , Char *pattern_last , glob_t *pglob , size_t *limitp ) ;
#line 147
static int glob2(Char *pathbuf , Char *pathbuf_last , Char *pathend , Char *pathend_last ,
                 Char *pattern , Char *pattern_last , glob_t *pglob , size_t *limitp ) ;
#line 149
static int glob3(Char *pathbuf , Char *pathbuf_last , Char *pathend , Char *pathend_last ,
                 Char *pattern , Char *pattern_last , Char *restpattern , Char *restpattern_last ,
                 glob_t *pglob , size_t *limitp ) ;
#line 151
static int globextend(Char const   *path , glob_t *pglob , size_t *limitp ) ;
#line 152
static Char const   *globtilde(Char const   *pattern , Char *patbuf , size_t patbuf_len ,
                               glob_t *pglob ) ;
#line 154
static int globexp1(Char const   *pattern , glob_t *pglob ) ;
#line 155
static int globexp2(Char const   *ptr , Char const   *pattern , glob_t *pglob , int *rv ) ;
#line 156
static int match(Char *name , Char *pat , Char *patend ) ;
#line 161 "openbsd-compat/glob.c"
int glob(char const   *pattern , int flags , int (*errfunc)(char const   * , int  ) ,
         glob_t *pglob ) 
{ u_char const   *patnext ;
  int c ;
  Char *bufnext ;
  Char *bufend ;
  Char patbuf[4096] ;
  Char *tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  Char *tmp___2 ;
  Char *tmp___3 ;
  u_char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 171
  patnext = (u_char const   *)((u_char *)pattern);
#line 172
  if (! (flags & 1)) {
#line 173
    pglob->gl_pathc = 0;
#line 174
    pglob->gl_pathv = (char **)((void *)0);
#line 175
    if (! (flags & 2)) {
#line 176
      pglob->gl_offs = 0;
    }
  }
#line 178
  pglob->gl_flags = flags & -257;
#line 179
  pglob->gl_errfunc = errfunc;
#line 180
  pglob->gl_matchc = 0;
#line 182
  bufnext = patbuf;
#line 183
  bufend = (bufnext + 4096) - 1;
#line 184
  if (flags & 4096) {
#line 185
    while (1) {
#line 185
      if ((unsigned int )bufnext < (unsigned int )bufend) {
#line 185
        tmp___0 = patnext;
#line 185
        patnext ++;
#line 185
        c = (int )*tmp___0;
#line 185
        if (! (c != 0)) {
#line 185
          break;
        }
      } else {
#line 185
        break;
      }
#line 186
      tmp = bufnext;
#line 186
      bufnext ++;
#line 186
      *tmp = (unsigned short )c;
    }
  } else {
#line 189
    while (1) {
#line 189
      if ((unsigned int )bufnext < (unsigned int )bufend) {
#line 189
        tmp___4 = patnext;
#line 189
        patnext ++;
#line 189
        c = (int )*tmp___4;
#line 189
        if (! (c != 0)) {
#line 189
          break;
        }
      } else {
#line 189
        break;
      }
#line 190
      if (c == 92) {
#line 191
        tmp___1 = patnext;
#line 191
        patnext ++;
#line 191
        c = (int )*tmp___1;
#line 191
        if (c == 0) {
#line 192
          c = '\\';
#line 193
          patnext --;
        }
#line 195
        tmp___2 = bufnext;
#line 195
        bufnext ++;
#line 195
        *tmp___2 = (unsigned short )(c | 16384);
      } else {
#line 197
        tmp___3 = bufnext;
#line 197
        bufnext ++;
#line 197
        *tmp___3 = (unsigned short )c;
      }
    }
  }
#line 199
  *bufnext = (unsigned short )'\000';
#line 201
  if (flags & 128) {
#line 202
    tmp___5 = globexp1((Char const   *)(patbuf), pglob);
#line 202
    return (tmp___5);
  } else {
#line 204
    tmp___6 = glob0((Char const   *)(patbuf), pglob);
#line 204
    return (tmp___6);
  }
}
}
#line 212 "openbsd-compat/glob.c"
static int globexp1(Char const   *pattern , glob_t *pglob ) 
{ Char const   *ptr ;
  int rv ;
  int tmp ;
  int tmp___0 ;
  Char *tmp___1 ;
  int tmp___2 ;

  {
#line 217
  ptr = pattern;
#line 221
  if ((int const   )*(pattern + 0) == 123) {
#line 221
    if ((int const   )*(pattern + 1) == 125) {
#line 221
      if ((int const   )*(pattern + 2) == 0) {
#line 222
        tmp = glob0(pattern, pglob);
#line 222
        return (tmp);
      }
    }
  }
#line 224
  while (1) {
#line 224
    tmp___1 = g_strchr((Char *)ptr, '{');
#line 224
    ptr = (Char const   *)tmp___1;
#line 224
    if (! ((unsigned int )ptr != (unsigned int )((void *)0))) {
#line 224
      break;
    }
#line 225
    tmp___0 = globexp2(ptr, pattern, pglob, & rv);
#line 225
    if (! tmp___0) {
#line 226
      return (rv);
    }
  }
#line 228
  tmp___2 = glob0(pattern, pglob);
#line 228
  return (tmp___2);
}
}
#line 237 "openbsd-compat/glob.c"
static int globexp2(Char const   *ptr , Char const   *pattern , glob_t *pglob , int *rv ) 
{ int i ;
  Char *lm ;
  Char *ls ;
  Char const   *pe ;
  Char const   *pm ;
  Char const   *pl ;
  Char patbuf[4096] ;
  Char *tmp ;
  Char const   *tmp___0 ;
  Char const   *tmp___1 ;
  Char const   *tmp___2 ;
  Char *tmp___3 ;
  Char const   *tmp___4 ;
  Char *tmp___5 ;
  Char const   *tmp___6 ;

  {
#line 249
  lm = patbuf;
#line 249
  pm = pattern;
#line 249
  while ((unsigned int )pm != (unsigned int )ptr) {
#line 249
    tmp = lm;
#line 249
    lm ++;
#line 249
    tmp___0 = pm;
#line 249
    pm ++;
#line 249
    *tmp = (unsigned short )*tmp___0;
  }
#line 251
  *lm = (unsigned short )'\000';
#line 252
  ls = lm;
#line 255
  i = 0;
#line 255
  ptr ++;
#line 255
  pe = ptr;
#line 255
  while (*pe) {
#line 256
    if ((int const   )*pe == 91) {
#line 258
      tmp___1 = pe;
#line 258
      pe ++;
#line 258
      pm = tmp___1;
#line 258
      while (1) {
#line 258
        if ((int const   )*pe != 93) {
#line 258
          if (! ((int const   )*pe != 0)) {
#line 258
            break;
          }
        } else {
#line 258
          break;
        }
#line 258
        pe ++;
      }
#line 260
      if ((int const   )*pe == 0) {
#line 265
        pe = pm;
      }
    } else {
#line 267
      if ((int const   )*pe == 123) {
#line 268
        i ++;
      } else {
#line 269
        if ((int const   )*pe == 125) {
#line 270
          if (i == 0) {
#line 271
            break;
          }
#line 272
          i --;
        }
      }
    }
#line 255
    pe ++;
  }
#line 276
  if (i != 0) {
#line 277
    *rv = glob0((Char const   *)(patbuf), pglob);
#line 278
    return (0);
  } else {
#line 276
    if ((int const   )*pe == 0) {
#line 277
      *rv = glob0((Char const   *)(patbuf), pglob);
#line 278
      return (0);
    }
  }
#line 281
  i = 0;
#line 281
  pm = ptr;
#line 281
  pl = pm;
#line 281
  while ((unsigned int )pm <= (unsigned int )pe) {
#line 282
    switch ((int )*pm) {
    case 91: 
#line 285
    tmp___2 = pm;
#line 285
    pm ++;
#line 285
    pl = tmp___2;
#line 285
    while (1) {
#line 285
      if ((int const   )*pm != 93) {
#line 285
        if (! ((int const   )*pm != 0)) {
#line 285
          break;
        }
      } else {
#line 285
        break;
      }
#line 285
      pm ++;
    }
#line 287
    if ((int const   )*pm == 0) {
#line 292
      pm = pl;
    }
#line 294
    break;
    case 123: 
#line 297
    i ++;
#line 298
    break;
    case 125: 
#line 301
    if (i) {
#line 302
      i --;
#line 303
      break;
    }
    case 44: 
#line 307
    if (i) {
#line 307
      if ((int const   )*pm == 44) {
#line 308
        break;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 311
      lm = ls;
#line 311
      while ((unsigned int )pl < (unsigned int )pm) {
#line 311
        tmp___3 = lm;
#line 311
        lm ++;
#line 311
        tmp___4 = pl;
#line 311
        pl ++;
#line 311
        *tmp___3 = (unsigned short )*tmp___4;
      }
#line 318
      pl = pe + 1;
#line 318
      while (1) {
#line 318
        tmp___5 = lm;
#line 318
        lm ++;
#line 318
        tmp___6 = pl;
#line 318
        pl ++;
#line 318
        *tmp___5 = (unsigned short )*tmp___6;
#line 318
        if (! ((int )*tmp___5 != 0)) {
#line 318
          break;
        }
      }
#line 325
      *rv = globexp1((Char const   *)(patbuf), pglob);
#line 328
      pl = pm + 1;
    }
#line 330
    break;
    default: ;
#line 333
    break;
    }
#line 281
    pm ++;
  }
#line 336
  *rv = 0;
#line 337
  return (0);
}
}
#line 345 "openbsd-compat/glob.c"
static Char const   *globtilde(Char const   *pattern , Char *patbuf , size_t patbuf_len ,
                               glob_t *pglob ) 
{ struct passwd *pwd ;
  char *h___0 ;
  Char const   *p ;
  Char *b ;
  Char *eb ;
  char *tmp ;
  Char const   *tmp___0 ;
  __uid_t tmp___1 ;
  __uid_t tmp___2 ;
  __uid_t tmp___3 ;
  Char *tmp___4 ;
  char *tmp___5 ;
  Char *tmp___6 ;
  Char const   *tmp___7 ;

  {
#line 357
  if ((int const   )*pattern != 126) {
#line 358
    return (pattern);
  } else {
#line 357
    if (! (pglob->gl_flags & 2048)) {
#line 358
      return (pattern);
    }
  }
#line 361
  eb = patbuf + (patbuf_len - 1U);
#line 362
  p = pattern + 1;
#line 362
  h___0 = (char *)patbuf;
#line 362
  while (1) {
#line 362
    if ((unsigned int )h___0 < (unsigned int )((char *)eb)) {
#line 362
      if (*p) {
#line 362
        if (! ((int const   )*p != 47)) {
#line 362
          break;
        }
      } else {
#line 362
        break;
      }
    } else {
#line 362
      break;
    }
#line 362
    tmp = h___0;
#line 362
    h___0 ++;
#line 362
    tmp___0 = p;
#line 362
    p ++;
#line 362
    *tmp = (char )*tmp___0;
  }
#line 366
  *h___0 = (char )'\000';
#line 373
  if ((int )*((char *)patbuf + 0) == 0) {
#line 381
    tmp___2 = getuid();
#line 381
    tmp___3 = geteuid();
#line 381
    if (tmp___2 != tmp___3) {
      goto _L;
    } else {
#line 381
      h___0 = getenv("HOME");
#line 381
      if ((unsigned int )h___0 == (unsigned int )((void *)0)) {
        _L: /* CIL Label */ 
#line 382
        tmp___1 = getuid();
#line 382
        pwd = getpwuid(tmp___1);
#line 382
        if ((unsigned int )pwd == (unsigned int )((void *)0)) {
#line 383
          return (pattern);
        } else {
#line 385
          h___0 = pwd->pw_dir;
        }
      }
    }
  } else {
#line 391
    pwd = getpwnam((char const   *)((char *)patbuf));
#line 391
    if ((unsigned int )pwd == (unsigned int )((void *)0)) {
#line 392
      return (pattern);
    } else {
#line 394
      h___0 = pwd->pw_dir;
    }
  }
#line 398
  b = patbuf;
#line 398
  while (1) {
#line 398
    if ((unsigned int )b < (unsigned int )eb) {
#line 398
      if (! *h___0) {
#line 398
        break;
      }
    } else {
#line 398
      break;
    }
#line 398
    tmp___4 = b;
#line 398
    b ++;
#line 398
    tmp___5 = h___0;
#line 398
    h___0 ++;
#line 398
    *tmp___4 = (unsigned short )*tmp___5;
  }
#line 402
  while (1) {
#line 402
    if ((unsigned int )b < (unsigned int )eb) {
#line 402
      tmp___6 = b;
#line 402
      b ++;
#line 402
      tmp___7 = p;
#line 402
      p ++;
#line 402
      *tmp___6 = (unsigned short )*tmp___7;
#line 402
      if (! ((int )*tmp___6 != 0)) {
#line 402
        break;
      }
    } else {
#line 402
      break;
    }
  }
#line 404
  *b = (unsigned short )'\000';
#line 406
  return ((Char const   *)patbuf);
}
}
#line 417 "openbsd-compat/glob.c"
static int glob0(Char const   *pattern , glob_t *pglob ) 
{ Char const   *qpatnext ;
  int c ;
  int err ;
  int oldpathc ;
  Char *bufnext ;
  Char patbuf[4096] ;
  size_t limit ;
  Char *tmp ;
  Char *tmp___0 ;
  Char *tmp___1 ;
  Char *tmp___2 ;
  Char const   *tmp___3 ;
  Char *tmp___4 ;
  Char *tmp___5 ;
  Char *tmp___6 ;
  Char const   *tmp___7 ;
  Char *tmp___8 ;
  Char *tmp___9 ;
  Char *tmp___10 ;
  Char *tmp___11 ;
  Char const   *tmp___12 ;
  int tmp___13 ;

  {
#line 425
  limit = (size_t )0;
#line 427
  qpatnext = globtilde(pattern, patbuf, 4096U, pglob);
#line 428
  oldpathc = pglob->gl_pathc;
#line 429
  bufnext = patbuf;
#line 432
  while (1) {
#line 432
    tmp___12 = qpatnext;
#line 432
    qpatnext ++;
#line 432
    c = (int )*tmp___12;
#line 432
    if (! (c != 0)) {
#line 432
      break;
    }
#line 433
    switch (c) {
    case 91: 
#line 435
    c = (int )*qpatnext;
#line 436
    if (c == 33) {
#line 437
      qpatnext ++;
    }
#line 438
    if ((int const   )*qpatnext == 0) {
      goto _L;
    } else {
#line 438
      tmp___0 = g_strchr((Char *)qpatnext + 1, ']');
#line 438
      if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
        _L: /* CIL Label */ 
#line 440
        tmp = bufnext;
#line 440
        bufnext ++;
#line 440
        *tmp = (unsigned short )'[';
#line 441
        if (c == 33) {
#line 442
          qpatnext --;
        }
#line 443
        break;
      }
    }
#line 445
    tmp___1 = bufnext;
#line 445
    bufnext ++;
#line 445
    *tmp___1 = (unsigned short)32859;
#line 446
    if (c == 33) {
#line 447
      tmp___2 = bufnext;
#line 447
      bufnext ++;
#line 447
      *tmp___2 = (unsigned short)32801;
    }
#line 448
    tmp___3 = qpatnext;
#line 448
    qpatnext ++;
#line 448
    c = (int )*tmp___3;
#line 449
    while (1) {
#line 450
      tmp___4 = bufnext;
#line 450
      bufnext ++;
#line 450
      *tmp___4 = (unsigned short )(c & 255);
#line 451
      if ((int const   )*qpatnext == 45) {
#line 451
        c = (int )*(qpatnext + 1);
#line 451
        if (c != 93) {
#line 453
          tmp___5 = bufnext;
#line 453
          bufnext ++;
#line 453
          *tmp___5 = (unsigned short)32813;
#line 454
          tmp___6 = bufnext;
#line 454
          bufnext ++;
#line 454
          *tmp___6 = (unsigned short )(c & 255);
#line 455
          qpatnext += 2;
        }
      }
#line 449
      tmp___7 = qpatnext;
#line 449
      qpatnext ++;
#line 449
      c = (int )*tmp___7;
#line 449
      if (! (c != 93)) {
#line 449
        break;
      }
    }
#line 458
    pglob->gl_flags |= 256;
#line 459
    tmp___8 = bufnext;
#line 459
    bufnext ++;
#line 459
    *tmp___8 = (unsigned short)32861;
#line 460
    break;
    case 63: 
#line 462
    pglob->gl_flags |= 256;
#line 463
    tmp___9 = bufnext;
#line 463
    bufnext ++;
#line 463
    *tmp___9 = (unsigned short)32831;
#line 464
    break;
    case 42: 
#line 466
    pglob->gl_flags |= 256;
#line 470
    if ((unsigned int )bufnext == (unsigned int )(patbuf)) {
#line 471
      tmp___10 = bufnext;
#line 471
      bufnext ++;
#line 471
      *tmp___10 = (unsigned short)32810;
    } else {
#line 470
      if ((int )*(bufnext + -1) != 32810) {
#line 471
        tmp___10 = bufnext;
#line 471
        bufnext ++;
#line 471
        *tmp___10 = (unsigned short)32810;
      }
    }
#line 472
    break;
    default: 
#line 474
    tmp___11 = bufnext;
#line 474
    bufnext ++;
#line 474
    *tmp___11 = (unsigned short )(c & 255);
#line 475
    break;
    }
  }
#line 478
  *bufnext = (unsigned short )'\000';
#line 483
  err = glob1(patbuf, (patbuf + 4096) - 1, pglob, & limit);
#line 483
  if (err != 0) {
#line 484
    return (err);
  }
#line 492
  if (pglob->gl_pathc == oldpathc) {
#line 493
    if (pglob->gl_flags & 16) {
#line 496
      tmp___13 = globextend(pattern, pglob, & limit);
#line 496
      return (tmp___13);
    } else {
#line 493
      if (pglob->gl_flags & 512) {
#line 493
        if (! (pglob->gl_flags & 256)) {
#line 496
          tmp___13 = globextend(pattern, pglob, & limit);
#line 496
          return (tmp___13);
        } else {
#line 498
          return (-3);
        }
      } else {
#line 498
        return (-3);
      }
    }
  }
#line 500
  if (! (pglob->gl_flags & 32)) {
#line 501
    qsort((void *)((pglob->gl_pathv + pglob->gl_offs) + oldpathc), (unsigned int )(pglob->gl_pathc - oldpathc),
          sizeof(char *), & compare);
  }
#line 503
  return (0);
}
}
#line 506 "openbsd-compat/glob.c"
static int compare(void const   *p , void const   *q ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 510
  if (0) {
#line 510
    __s1_len = strlen((char const   *)*((char **)p));
#line 510
    __s2_len = strlen((char const   *)*((char **)q));
#line 510
    if (! ((unsigned int )((void const   *)(*((char **)p) + 1)) - (unsigned int )((void const   *)*((char **)p)) == 1U)) {
      goto _L___0;
    } else {
#line 510
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 510
        if (! ((unsigned int )((void const   *)(*((char **)q) + 1)) - (unsigned int )((void const   *)*((char **)q)) == 1U)) {
#line 510
          tmp___8 = 1;
        } else {
#line 510
          if (__s2_len >= 4U) {
#line 510
            tmp___8 = 1;
          } else {
#line 510
            tmp___8 = 0;
          }
        }
      } else {
#line 510
        tmp___8 = 0;
      }
    }
#line 510
    if (tmp___8) {
#line 510
      tmp___4 = __builtin_strcmp((char const   *)*((char **)p), (char const   *)*((char **)q));
    } else {
#line 510
      tmp___7 = __builtin_strcmp((char const   *)*((char **)p), (char const   *)*((char **)q));
#line 510
      tmp___4 = tmp___7;
    }
  } else {
#line 510
    tmp___7 = __builtin_strcmp((char const   *)*((char **)p), (char const   *)*((char **)q));
#line 510
    tmp___4 = tmp___7;
  }
#line 510
  return (tmp___4);
}
}
#line 513 "openbsd-compat/glob.c"
static int glob1(Char *pattern , Char *pattern_last , glob_t *pglob , size_t *limitp ) 
{ Char pathbuf[4096] ;
  int tmp ;

  {
#line 522
  if ((int )*pattern == 0) {
#line 523
    return (0);
  }
#line 524
  tmp = glob2(pathbuf, (pathbuf + 4096) - 1, pathbuf, (pathbuf + 4096) - 1, pattern,
              pattern_last, pglob, limitp);
#line 524
  return (tmp);
}
}
#line 534 "openbsd-compat/glob.c"
static int glob2(Char *pathbuf , Char *pathbuf_last , Char *pathend , Char *pathend_last ,
                 Char *pattern , Char *pattern_last , glob_t *pglob , size_t *limitp ) 
{ struct stat sb ;
  Char *p ;
  Char *q ;
  int anymeta ;
  int tmp ;
  Char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  Char *tmp___3 ;
  Char *tmp___4 ;
  Char *tmp___5 ;
  Char *tmp___6 ;
  int tmp___7 ;

  {
#line 550
  anymeta = 0;
#line 550
  while (1) {
#line 551
    if ((int )*pattern == 0) {
#line 552
      *pathend = (unsigned short )'\000';
#line 553
      tmp = g_lstat(pathbuf, & sb, pglob);
#line 553
      if (tmp) {
#line 554
        return (0);
      }
#line 556
      if (pglob->gl_flags & 8) {
#line 556
        if ((int )*(pathend + -1) != 47) {
#line 556
          if ((sb.st_mode & 61440U) == 16384U) {
            goto _L;
          } else {
#line 556
            if ((sb.st_mode & 61440U) == 40960U) {
#line 556
              tmp___1 = g_stat(pathbuf, & sb, pglob);
#line 556
              if (tmp___1 == 0) {
#line 556
                if ((sb.st_mode & 61440U) == 16384U) {
                  _L: /* CIL Label */ 
#line 561
                  if ((unsigned int )(pathend + 1) > (unsigned int )pathend_last) {
#line 562
                    return (1);
                  }
#line 563
                  tmp___0 = pathend;
#line 563
                  pathend ++;
#line 563
                  *tmp___0 = (unsigned short )'/';
#line 564
                  *pathend = (unsigned short )'\000';
                }
              }
            }
          }
        }
      }
#line 566
      (pglob->gl_matchc) ++;
#line 567
      tmp___2 = globextend((Char const   *)pathbuf, pglob, limitp);
#line 567
      return (tmp___2);
    }
#line 571
    q = pathend;
#line 572
    p = pattern;
#line 573
    while (1) {
#line 573
      if ((int )*p != 0) {
#line 573
        if (! ((int )*p != 47)) {
#line 573
          break;
        }
      } else {
#line 573
        break;
      }
#line 574
      if (((int )*p & 32768) != 0) {
#line 575
        anymeta = 1;
      }
#line 576
      if ((unsigned int )(q + 1) > (unsigned int )pathend_last) {
#line 577
        return (1);
      }
#line 578
      tmp___3 = q;
#line 578
      q ++;
#line 578
      tmp___4 = p;
#line 578
      p ++;
#line 578
      *tmp___3 = *tmp___4;
    }
#line 581
    if (! anymeta) {
#line 582
      pathend = q;
#line 583
      pattern = p;
#line 584
      while ((int )*pattern == 47) {
#line 585
        if ((unsigned int )(pathend + 1) > (unsigned int )pathend_last) {
#line 586
          return (1);
        }
#line 587
        tmp___5 = pathend;
#line 587
        pathend ++;
#line 587
        tmp___6 = pattern;
#line 587
        pattern ++;
#line 587
        *tmp___5 = *tmp___6;
      }
    } else {
#line 591
      tmp___7 = glob3(pathbuf, pathbuf_last, pathend, pathend_last, pattern, pattern_last,
                      p, pattern_last, pglob, limitp);
#line 591
      return (tmp___7);
    }
  }
}
}
#line 598 "openbsd-compat/glob.c"
static int glob3(Char *pathbuf , Char *pathbuf_last , Char *pathend , Char *pathend_last ,
                 Char *pattern , Char *pattern_last , Char *restpattern , Char *restpattern_last ,
                 glob_t *pglob , size_t *limitp ) 
{ register struct dirent *dp ;
  DIR *dirp ;
  int err ;
  char buf___1[4096] ;
  struct dirent *(*readdirfunc)() ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  register u_char *sc ;
  register Char *dc ;
  Char *tmp___3 ;
  u_char *tmp___4 ;
  int tmp___5 ;

  {
#line 619
  if ((unsigned int )pathend > (unsigned int )pathend_last) {
#line 620
    return (1);
  }
#line 621
  *pathend = (unsigned short )'\000';
#line 622
  tmp = __errno_location();
#line 622
  *tmp = 0;
#line 624
  dirp = g_opendir(pathbuf, pglob);
#line 624
  if ((unsigned int )dirp == (unsigned int )((void *)0)) {
#line 626
    if (pglob->gl_errfunc) {
#line 627
      tmp___0 = g_Ctoc((Char const   *)pathbuf, buf___1, sizeof(buf___1));
#line 627
      if (tmp___0) {
#line 628
        return (-2);
      }
#line 629
      tmp___1 = __errno_location();
#line 629
      tmp___2 = (*(pglob->gl_errfunc))((char const   *)(buf___1), *tmp___1);
#line 629
      if (tmp___2) {
#line 631
        return (-2);
      } else {
#line 629
        if (pglob->gl_flags & 4) {
#line 631
          return (-2);
        }
      }
    }
#line 633
    return (0);
  }
#line 636
  err = 0;
#line 639
  if (pglob->gl_flags & 64) {
#line 640
    readdirfunc = (struct dirent *(*)())pglob->gl_readdir;
  } else {
#line 642
    readdirfunc = (struct dirent *(*)())(& readdir);
  }
#line 643
  while (1) {
#line 643
    dp = (*readdirfunc)(dirp);
#line 643
    if (! dp) {
#line 643
      break;
    }
#line 648
    if ((int )dp->d_name[0] == 46) {
#line 648
      if ((int )*pattern != 46) {
#line 649
        continue;
      }
    }
#line 650
    dc = pathend;
#line 651
    sc = (u_char *)(dp->d_name);
#line 652
    while (1) {
#line 652
      if ((unsigned int )dc < (unsigned int )pathend_last) {
#line 652
        tmp___3 = dc;
#line 652
        dc ++;
#line 652
        tmp___4 = sc;
#line 652
        sc ++;
#line 652
        *tmp___3 = (unsigned short )*tmp___4;
#line 652
        if (! ((int )*tmp___3 != 0)) {
#line 652
          break;
        }
      } else {
#line 652
        break;
      }
    }
#line 654
    if ((unsigned int )dc >= (unsigned int )pathend_last) {
#line 655
      *dc = (unsigned short )'\000';
#line 656
      err = 1;
#line 657
      break;
    }
#line 660
    tmp___5 = match(pathend, pattern, restpattern);
#line 660
    if (! tmp___5) {
#line 661
      *pathend = (unsigned short )'\000';
#line 662
      continue;
    }
#line 664
    dc --;
#line 664
    err = glob2(pathbuf, pathbuf_last, dc, pathend_last, restpattern, restpattern_last,
                pglob, limitp);
#line 666
    if (err) {
#line 667
      break;
    }
  }
#line 670
  if (pglob->gl_flags & 64) {
#line 671
    (*(pglob->gl_closedir))((void *)dirp);
  } else {
#line 673
    closedir(dirp);
  }
#line 674
  return (err);
}
}
#line 692 "openbsd-compat/glob.c"
static int globextend(Char const   *path , glob_t *pglob , size_t *limitp ) 
{ register char **pathv ;
  register int i ;
  u_int newsize ;
  u_int len ;
  char *copy ;
  Char const   *p ;
  void *tmp___1 ;
  void *tmp___2 ;
  Char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;

  {
#line 704
  newsize = sizeof(*pathv) * (unsigned int )((2 + pglob->gl_pathc) + pglob->gl_offs);
#line 705
  if (pglob->gl_pathv) {
#line 705
    tmp___1 = realloc((void *)((char *)pglob->gl_pathv), newsize);
#line 705
    pathv = (char **)tmp___1;
  } else {
#line 705
    tmp___2 = malloc(newsize);
#line 705
    pathv = (char **)tmp___2;
  }
#line 707
  if ((unsigned int )pathv == (unsigned int )((void *)0)) {
#line 708
    if (pglob->gl_pathv) {
#line 709
      free((void *)pglob->gl_pathv);
#line 710
      pglob->gl_pathv = (char **)((void *)0);
    }
#line 712
    return (-1);
  }
#line 715
  if ((unsigned int )pglob->gl_pathv == (unsigned int )((void *)0)) {
#line 715
    if (pglob->gl_offs > 0) {
#line 717
      pathv += pglob->gl_offs;
#line 718
      i = pglob->gl_offs;
#line 718
      while (1) {
#line 718
        i --;
#line 718
        if (! (i >= 0)) {
#line 718
          break;
        }
#line 719
        pathv --;
#line 719
        *pathv = (char *)((void *)0);
      }
    }
  }
#line 721
  pglob->gl_pathv = pathv;
#line 723
  p = path;
#line 723
  while (1) {
#line 723
    tmp___3 = p;
#line 723
    p ++;
#line 723
    if (! *tmp___3) {
#line 723
      break;
    }
  }
#line 725
  len = (unsigned int )(p - path);
#line 726
  *limitp += len;
#line 727
  tmp___6 = malloc(len);
#line 727
  copy = (char *)tmp___6;
#line 727
  if ((unsigned int )copy != (unsigned int )((void *)0)) {
#line 728
    tmp___4 = g_Ctoc(path, copy, len);
#line 728
    if (tmp___4) {
#line 729
      free((void *)copy);
#line 730
      return (-1);
    }
#line 732
    tmp___5 = pglob->gl_pathc;
#line 732
    (pglob->gl_pathc) ++;
#line 732
    *(pathv + (pglob->gl_offs + tmp___5)) = copy;
  }
#line 734
  *(pathv + (pglob->gl_offs + pglob->gl_pathc)) = (char *)((void *)0);
#line 736
  if (pglob->gl_flags & 8192) {
#line 736
    tmp___8 = get_arg_max();
#line 736
    if (newsize + *limitp >= (unsigned int )tmp___8) {
#line 738
      tmp___7 = __errno_location();
#line 738
      *tmp___7 = 0;
#line 739
      return (-1);
    }
  }
#line 742
  if ((unsigned int )copy == (unsigned int )((void *)0)) {
#line 742
    tmp___9 = -1;
  } else {
#line 742
    tmp___9 = 0;
  }
#line 742
  return (tmp___9);
}
}
#line 750 "openbsd-compat/glob.c"
static int match(Char *name , Char *pat , Char *patend ) 
{ int ok ;
  int negate_range ;
  Char c ;
  Char k ;
  Char *tmp ;
  int tmp___0 ;
  Char *tmp___1 ;
  Char *tmp___2 ;
  Char *tmp___3 ;
  Char *tmp___4 ;
  Char *tmp___5 ;

  {
#line 757
  while ((unsigned int )pat < (unsigned int )patend) {
#line 758
    tmp = pat;
#line 758
    pat ++;
#line 758
    c = *tmp;
#line 759
    switch ((int )c & 65535) {
    case (unsigned short)32810: 
#line 761
    if ((unsigned int )pat == (unsigned int )patend) {
#line 762
      return (1);
    }
#line 763
    while (1) {
#line 764
      tmp___0 = match(name, pat, patend);
#line 764
      if (tmp___0) {
#line 765
        return (1);
      }
#line 763
      tmp___1 = name;
#line 763
      name ++;
#line 763
      if (! ((int )*tmp___1 != 0)) {
#line 763
        break;
      }
    }
#line 768
    return (0);
    case (unsigned short)32831: 
#line 770
    tmp___2 = name;
#line 770
    name ++;
#line 770
    if ((int )*tmp___2 == 0) {
#line 771
      return (0);
    }
#line 772
    break;
    case (unsigned short)32859: 
#line 774
    ok = 0;
#line 775
    tmp___3 = name;
#line 775
    name ++;
#line 775
    k = *tmp___3;
#line 775
    if ((int )k == 0) {
#line 776
      return (0);
    }
#line 777
    negate_range = ((int )*pat & 65535) == 32801;
#line 777
    if (negate_range != 0) {
#line 778
      pat ++;
    }
#line 779
    while (1) {
#line 779
      tmp___4 = pat;
#line 779
      pat ++;
#line 779
      c = *tmp___4;
#line 779
      if (! (((int )c & 65535) != 32861)) {
#line 779
        break;
      }
#line 780
      if (((int )*pat & 65535) == 32813) {
#line 781
        if ((int )c <= (int )k) {
#line 781
          if ((int )k <= (int )*(pat + 1)) {
#line 782
            ok = 1;
          }
        }
#line 783
        pat += 2;
      } else {
#line 784
        if ((int )c == (int )k) {
#line 785
          ok = 1;
        }
      }
    }
#line 786
    if (ok == negate_range) {
#line 787
      return (0);
    }
#line 788
    break;
    default: 
#line 790
    tmp___5 = name;
#line 790
    name ++;
#line 790
    if ((int )*tmp___5 != (int )c) {
#line 791
      return (0);
    }
#line 792
    break;
    }
  }
#line 795
  return ((int )*name == 0);
}
}
#line 799 "openbsd-compat/glob.c"
void globfree(glob_t *pglob ) 
{ register int i ;
  register char **pp ;
  int tmp ;

  {
#line 806
  if ((unsigned int )pglob->gl_pathv != (unsigned int )((void *)0)) {
#line 807
    pp = pglob->gl_pathv + pglob->gl_offs;
#line 808
    i = pglob->gl_pathc;
#line 808
    while (1) {
#line 808
      tmp = i;
#line 808
      i --;
#line 808
      if (! tmp) {
#line 808
        break;
      }
#line 809
      if (*pp) {
#line 810
        free((void *)*pp);
      }
#line 808
      pp ++;
    }
#line 811
    free((void *)pglob->gl_pathv);
#line 812
    pglob->gl_pathv = (char **)((void *)0);
  }
#line 814
  return;
}
}
#line 816 "openbsd-compat/glob.c"
static DIR *g_opendir(Char *str , glob_t *pglob ) 
{ char buf___1[4096] ;
  int tmp ;
  void *tmp___0 ;
  DIR *tmp___1 ;

  {
#line 823
  if (! *str) {
#line 824
    strcpy((char * __restrict  )(buf___1), (char const   * __restrict  )".");
  } else {
#line 826
    tmp = g_Ctoc((Char const   *)str, buf___1, sizeof(buf___1));
#line 826
    if (tmp) {
#line 827
      return ((DIR *)((void *)0));
    }
  }
#line 830
  if (pglob->gl_flags & 64) {
#line 831
    tmp___0 = (*(pglob->gl_opendir))((char const   *)(buf___1));
#line 831
    return ((DIR *)tmp___0);
  }
#line 833
  tmp___1 = opendir((char const   *)(buf___1));
#line 833
  return (tmp___1);
}
}
#line 836 "openbsd-compat/glob.c"
static int g_lstat(Char *fn , struct stat *sb , glob_t *pglob ) 
{ char buf___1[4096] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 844
  tmp = g_Ctoc((Char const   *)fn, buf___1, sizeof(buf___1));
#line 844
  if (tmp) {
#line 845
    return (-1);
  }
#line 846
  if (pglob->gl_flags & 64) {
#line 847
    tmp___0 = (*(pglob->gl_lstat))((char const   *)(buf___1), sb);
#line 847
    return (tmp___0);
  }
#line 848
  tmp___1 = lstat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )sb);
#line 848
  return (tmp___1);
}
}
#line 851 "openbsd-compat/glob.c"
static int g_stat(Char *fn , struct stat *sb , glob_t *pglob ) 
{ char buf___1[4096] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 859
  tmp = g_Ctoc((Char const   *)fn, buf___1, sizeof(buf___1));
#line 859
  if (tmp) {
#line 860
    return (-1);
  }
#line 861
  if (pglob->gl_flags & 64) {
#line 862
    tmp___0 = (*(pglob->gl_stat))((char const   *)(buf___1), sb);
#line 862
    return (tmp___0);
  }
#line 863
  tmp___1 = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )sb);
#line 863
  return (tmp___1);
}
}
#line 866 "openbsd-compat/glob.c"
static Char *g_strchr(Char *str , int ch ) 
{ Char *tmp ;

  {
#line 871
  while (1) {
#line 872
    if ((int )*str == ch) {
#line 873
      return (str);
    }
#line 871
    tmp = str;
#line 871
    str ++;
#line 871
    if (! *tmp) {
#line 871
      break;
    }
  }
#line 875
  return ((Char *)((void *)0));
}
}
#line 878 "openbsd-compat/glob.c"
static int g_Ctoc(Char const   *str , char *buf___1 , u_int len ) 
{ char *tmp ;
  Char const   *tmp___0 ;
  u_int tmp___1 ;

  {
#line 885
  while (1) {
#line 885
    tmp___1 = len;
#line 885
    len --;
#line 885
    if (! tmp___1) {
#line 885
      break;
    }
#line 886
    tmp = buf___1;
#line 886
    buf___1 ++;
#line 886
    tmp___0 = str;
#line 886
    str ++;
#line 886
    *tmp = (char )*tmp___0;
#line 886
    if ((int )*tmp == 0) {
#line 887
      return (0);
    }
  }
#line 889
  return (1);
}
}
#line 1 "inet_aton.o"
#line 1 "inet_ntoa.o"
#line 1 "inet_ntop.o"
#line 1 "mktemp.o"
#line 1 "readpassphrase.o"
#line 83 "/usr/include/ctype.h"
extern __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 85
extern __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
#line 116
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 119
__inline static  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 190
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 190 "/usr/include/ctype.h"
__inline static int tolower(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
#line 193
  if (__c >= -128) {
#line 193
    if (__c < 256) {
#line 193
      tmp___1 = __ctype_tolower_loc();
#line 193
      tmp___0 = *(*tmp___1 + __c);
    } else {
#line 193
      tmp___0 = (int const   )__c;
    }
  } else {
#line 193
    tmp___0 = (int const   )__c;
  }
#line 193
  return ((int )tmp___0);
}
}
#line 196
__inline static  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 196 "/usr/include/ctype.h"
__inline static int toupper(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
#line 199
  if (__c >= -128) {
#line 199
    if (__c < 256) {
#line 199
      tmp___1 = __ctype_toupper_loc();
#line 199
      tmp___0 = *(*tmp___1 + __c);
    } else {
#line 199
      tmp___0 = (int const   )__c;
    }
  } else {
#line 199
    tmp___0 = (int const   )__c;
  }
#line 199
  return ((int )tmp___0);
}
}
#line 88 "/usr/include/fcntl.h"
extern int open(char const   *__file , int __oflag  , ...)  __asm__("open64") __attribute__((__nonnull__(1))) ;
#line 117 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 216
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
#line 260
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 38 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                  size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 62
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 320 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 327
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 333
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 573
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 67 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 71
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
#line 44 "./openbsd-compat/readpassphrase.h"
char *readpassphrase(char const   *prompt , char *buf___1 , size_t bufsiz , int flags ) ;
#line 52 "openbsd-compat/readpassphrase.c"
static sig_atomic_t volatile   signo  ;
#line 54
static void handler(int s ) ;
#line 56 "openbsd-compat/readpassphrase.c"
char *readpassphrase(char const   *prompt , char *buf___1 , size_t bufsiz , int flags ) 
{ ssize_t nr ;
  int input___0 ;
  int output___0 ;
  int save_errno ;
  char ch ;
  char *p ;
  char *end ;
  struct termios term ;
  struct termios oterm ;
  struct sigaction sa ;
  struct sigaction saveint ;
  struct sigaction savehup ;
  struct sigaction savequit ;
  struct sigaction saveterm ;
  struct sigaction savetstp ;
  struct sigaction savettin ;
  struct sigaction savettou ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int __res ;
  __int32_t const   **tmp___5 ;
  int __res___0 ;
  __int32_t const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  __pid_t tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;

  {
#line 67
  if (bufsiz == 0U) {
#line 68
    tmp = __errno_location();
#line 68
    *tmp = 22;
#line 69
    return ((char *)((void *)0));
  }
  restart: 
#line 77
  output___0 = open("/dev/tty", 2);
#line 77
  input___0 = output___0;
#line 77
  if (input___0 == -1) {
#line 78
    if (flags & 2) {
#line 79
      tmp___0 = __errno_location();
#line 79
      *tmp___0 = 25;
#line 80
      return ((char *)((void *)0));
    }
#line 82
    input___0 = 0;
#line 83
    output___0 = 2;
  }
#line 91
  sigemptyset(& sa.sa_mask);
#line 92
  sa.sa_flags = 0;
#line 93
  sa.__sigaction_handler.sa_handler = & handler;
#line 94
  sigaction(2, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& saveint));
#line 95
  sigaction(1, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savehup));
#line 96
  sigaction(3, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savequit));
#line 97
  sigaction(15, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& saveterm));
#line 98
  sigaction(20, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savetstp));
#line 99
  sigaction(21, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savettin));
#line 100
  sigaction(22, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savettou));
#line 103
  tmp___1 = tcgetattr(input___0, & oterm);
#line 103
  if (tmp___1 == 0) {
#line 104
    memcpy((void * __restrict  )(& term), (void const   * __restrict  )(& oterm),
           sizeof(term));
#line 105
    if (! (flags & 1)) {
#line 106
      term.c_lflag &= 4294967223U;
    }
#line 111
    tcsetattr(input___0, 2, (struct termios  const  *)(& term));
  } else {
#line 113
    memset((void *)(& term), 0, sizeof(term));
#line 114
    memset((void *)(& oterm), 0, sizeof(oterm));
  }
#line 117
  tmp___2 = strlen(prompt);
#line 117
  write(output___0, (void const   *)prompt, tmp___2);
#line 118
  end = (buf___1 + bufsiz) - 1;
#line 119
  p = buf___1;
#line 119
  while (1) {
#line 119
    nr = read(input___0, (void *)(& ch), 1U);
#line 119
    if (nr == 1) {
#line 119
      if ((int )ch != 10) {
#line 119
        if (! ((int )ch != 13)) {
#line 119
          break;
        }
      } else {
#line 119
        break;
      }
    } else {
#line 119
      break;
    }
#line 120
    if ((unsigned int )p < (unsigned int )end) {
#line 121
      if (flags & 16) {
#line 122
        ch = (char )((int )ch & 127);
      }
#line 123
      tmp___9 = __ctype_b_loc();
#line 123
      if ((int const   )*(*tmp___9 + (int )ch) & 1024) {
#line 124
        if (flags & 4) {
#line 125
          if (sizeof(ch) > 1U) {
#line 125
            __res = tolower((int )ch);
          } else {
#line 125
            tmp___5 = __ctype_tolower_loc();
#line 125
            __res = (int )*(*tmp___5 + (int )ch);
          }
#line 125
          ch = (char )__res;
        }
#line 126
        if (flags & 8) {
#line 127
          if (sizeof(ch) > 1U) {
#line 127
            __res___0 = toupper((int )ch);
          } else {
#line 127
            tmp___8 = __ctype_toupper_loc();
#line 127
            __res___0 = (int )*(*tmp___8 + (int )ch);
          }
#line 127
          ch = (char )__res___0;
        }
      }
#line 129
      tmp___10 = p;
#line 129
      p ++;
#line 129
      *tmp___10 = ch;
    }
  }
#line 132
  *p = (char )'\000';
#line 133
  tmp___11 = __errno_location();
#line 133
  save_errno = *tmp___11;
#line 134
  if (! (term.c_lflag & 8U)) {
#line 135
    write(output___0, (void const   *)"\n", 1U);
  }
#line 138
  tmp___12 = memcmp((void const   *)(& term), (void const   *)(& oterm), sizeof(term));
#line 138
  if (tmp___12 != 0) {
#line 139
    tcsetattr(input___0, 2, (struct termios  const  *)(& oterm));
  }
#line 140
  sigaction(2, (struct sigaction  const  * __restrict  )(& saveint), (struct sigaction * __restrict  )((void *)0));
#line 141
  sigaction(1, (struct sigaction  const  * __restrict  )(& savehup), (struct sigaction * __restrict  )((void *)0));
#line 142
  sigaction(3, (struct sigaction  const  * __restrict  )(& savequit), (struct sigaction * __restrict  )((void *)0));
#line 143
  sigaction(15, (struct sigaction  const  * __restrict  )(& saveterm), (struct sigaction * __restrict  )((void *)0));
#line 144
  sigaction(20, (struct sigaction  const  * __restrict  )(& savetstp), (struct sigaction * __restrict  )((void *)0));
#line 145
  sigaction(21, (struct sigaction  const  * __restrict  )(& savettin), (struct sigaction * __restrict  )((void *)0));
#line 146
  sigaction(22, (struct sigaction  const  * __restrict  )(& savettou), (struct sigaction * __restrict  )((void *)0));
#line 147
  if (input___0 != 0) {
#line 148
    close(input___0);
  }
#line 154
  if (signo) {
#line 155
    tmp___13 = getpid();
#line 155
    kill(tmp___13, (int )signo);
#line 156
    switch ((int )signo) {
    case 20: 
    case 21: 
    case 22: 
#line 160
    signo = (int volatile   )0;
    goto restart;
    }
  }
#line 165
  tmp___14 = __errno_location();
#line 165
  *tmp___14 = save_errno;
#line 166
  if (nr == -1) {
#line 166
    tmp___15 = (char *)((void *)0);
  } else {
#line 166
    tmp___15 = buf___1;
  }
#line 166
  return (tmp___15);
}
}
#line 179 "openbsd-compat/readpassphrase.c"
static void handler(int s ) 
{ 

  {
#line 181
  signo = (int volatile   )s;
#line 182
  return;
}
}
#line 1 "realpath.o"
#line 1 "rresvport.o"
#line 1 "setenv.o"
#line 1 "setproctitle.o"
#line 9 "./openbsd-compat/setproctitle.h"
void setproctitle(char const   *fmt  , ...) ;
#line 71 "openbsd-compat/setproctitle.c"
void setproctitle(char const   *fmt  , ...) 
{ 

  {
#line 101
  return;
}
}
#line 1 "sigact.o"
#line 1 "strlcat.o"
#line 9 "openbsd-compat/strlcat.h"
size_t strlcat(char *dst , char const   *src , size_t siz ) ;
#line 48 "openbsd-compat/strlcat.c"
size_t strlcat(char *dst , char const   *src , size_t siz ) 
{ register char *d ;
  register char const   *s ;
  register size_t n___0 ;
  size_t dlen ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 54
  d = dst;
#line 55
  s = src;
#line 56
  n___0 = siz;
#line 60
  while (1) {
#line 60
    tmp = n___0;
#line 60
    n___0 --;
#line 60
    if (tmp != 0U) {
#line 60
      if (! ((int )*d != 0)) {
#line 60
        break;
      }
    } else {
#line 60
      break;
    }
#line 61
    d ++;
  }
#line 62
  dlen = (unsigned int )(d - dst);
#line 63
  n___0 = siz - dlen;
#line 65
  if (n___0 == 0U) {
#line 66
    tmp___0 = strlen(s);
#line 66
    return (dlen + tmp___0);
  }
#line 67
  while ((int const   )*s != 0) {
#line 68
    if (n___0 != 1U) {
#line 69
      tmp___1 = d;
#line 69
      d ++;
#line 69
      *tmp___1 = (char )*s;
#line 70
      n___0 --;
    }
#line 72
    s ++;
  }
#line 74
  *d = (char )'\000';
#line 76
  return (dlen + (size_t )(s - src));
}
}
#line 1 "strlcpy.o"
#line 9 "openbsd-compat/strlcpy.h"
size_t strlcpy(char *dst , char const   *src , size_t siz ) ;
#line 46 "openbsd-compat/strlcpy.c"
size_t strlcpy(char *dst , char const   *src , size_t siz ) 
{ register char *d ;
  register char const   *s ;
  register size_t n___0 ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 52
  d = dst;
#line 53
  s = src;
#line 54
  n___0 = siz;
#line 57
  if (n___0 != 0U) {
#line 57
    n___0 --;
#line 57
    if (n___0 != 0U) {
#line 58
      while (1) {
#line 59
        tmp = d;
#line 59
        d ++;
#line 59
        tmp___0 = s;
#line 59
        s ++;
#line 59
        *tmp = (char )*tmp___0;
#line 59
        if ((int )*tmp == 0) {
#line 60
          break;
        }
#line 58
        n___0 --;
#line 58
        if (! (n___0 != 0U)) {
#line 58
          break;
        }
      }
    }
  }
#line 65
  if (n___0 == 0U) {
#line 66
    if (siz != 0U) {
#line 67
      *d = (char )'\000';
    }
#line 68
    while (1) {
#line 68
      tmp___1 = s;
#line 68
      s ++;
#line 68
      if (! *tmp___1) {
#line 68
        break;
      }
    }
  }
#line 72
  return ((unsigned int )((s - src) - 1));
}
}
#line 1 "strmode.o"
#line 5 "./openbsd-compat/strmode.h"
void strmode(mode_t mode , char *p ) ;
#line 45 "openbsd-compat/strmode.c"
void strmode(mode_t mode , char *p ) 
{ char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;

  {
#line 49
  switch ((int )(mode & 61440U)) {
  case 16384: 
#line 51
  tmp = p;
#line 51
  p ++;
#line 51
  *tmp = (char )'d';
#line 52
  break;
  case 8192: 
#line 54
  tmp___0 = p;
#line 54
  p ++;
#line 54
  *tmp___0 = (char )'c';
#line 55
  break;
  case 24576: 
#line 57
  tmp___1 = p;
#line 57
  p ++;
#line 57
  *tmp___1 = (char )'b';
#line 58
  break;
  case 32768: 
#line 60
  tmp___2 = p;
#line 60
  p ++;
#line 60
  *tmp___2 = (char )'-';
#line 61
  break;
  case 40960: 
#line 63
  tmp___3 = p;
#line 63
  p ++;
#line 63
  *tmp___3 = (char )'l';
#line 64
  break;
  case 49152: 
#line 67
  tmp___4 = p;
#line 67
  p ++;
#line 67
  *tmp___4 = (char )'s';
#line 68
  break;
  case 4096: 
#line 72
  tmp___5 = p;
#line 72
  p ++;
#line 72
  *tmp___5 = (char )'p';
#line 73
  break;
  default: 
#line 81
  tmp___6 = p;
#line 81
  p ++;
#line 81
  *tmp___6 = (char )'?';
#line 82
  break;
  }
#line 85
  if (mode & 256U) {
#line 86
    tmp___7 = p;
#line 86
    p ++;
#line 86
    *tmp___7 = (char )'r';
  } else {
#line 88
    tmp___8 = p;
#line 88
    p ++;
#line 88
    *tmp___8 = (char )'-';
  }
#line 89
  if (mode & 128U) {
#line 90
    tmp___9 = p;
#line 90
    p ++;
#line 90
    *tmp___9 = (char )'w';
  } else {
#line 92
    tmp___10 = p;
#line 92
    p ++;
#line 92
    *tmp___10 = (char )'-';
  }
#line 93
  switch ((int )(mode & 2112U)) {
  case 0: 
#line 95
  tmp___11 = p;
#line 95
  p ++;
#line 95
  *tmp___11 = (char )'-';
#line 96
  break;
  case 64: 
#line 98
  tmp___12 = p;
#line 98
  p ++;
#line 98
  *tmp___12 = (char )'x';
#line 99
  break;
  case 2048: 
#line 101
  tmp___13 = p;
#line 101
  p ++;
#line 101
  *tmp___13 = (char )'S';
#line 102
  break;
  case 2112: 
#line 104
  tmp___14 = p;
#line 104
  p ++;
#line 104
  *tmp___14 = (char )'s';
#line 105
  break;
  }
#line 108
  if (mode & (unsigned int )(256 >> 3)) {
#line 109
    tmp___15 = p;
#line 109
    p ++;
#line 109
    *tmp___15 = (char )'r';
  } else {
#line 111
    tmp___16 = p;
#line 111
    p ++;
#line 111
    *tmp___16 = (char )'-';
  }
#line 112
  if (mode & (unsigned int )(128 >> 3)) {
#line 113
    tmp___17 = p;
#line 113
    p ++;
#line 113
    *tmp___17 = (char )'w';
  } else {
#line 115
    tmp___18 = p;
#line 115
    p ++;
#line 115
    *tmp___18 = (char )'-';
  }
#line 116
  switch ((int )(mode & (unsigned int )((64 >> 3) | 1024))) {
  case 0: 
#line 118
  tmp___19 = p;
#line 118
  p ++;
#line 118
  *tmp___19 = (char )'-';
#line 119
  break;
  case 64 >> 3: 
#line 121
  tmp___20 = p;
#line 121
  p ++;
#line 121
  *tmp___20 = (char )'x';
#line 122
  break;
  case 1024: 
#line 124
  tmp___21 = p;
#line 124
  p ++;
#line 124
  *tmp___21 = (char )'S';
#line 125
  break;
  case (64 >> 3) | 1024: 
#line 127
  tmp___22 = p;
#line 127
  p ++;
#line 127
  *tmp___22 = (char )'s';
#line 128
  break;
  }
#line 131
  if (mode & (unsigned int )((256 >> 3) >> 3)) {
#line 132
    tmp___23 = p;
#line 132
    p ++;
#line 132
    *tmp___23 = (char )'r';
  } else {
#line 134
    tmp___24 = p;
#line 134
    p ++;
#line 134
    *tmp___24 = (char )'-';
  }
#line 135
  if (mode & (unsigned int )((128 >> 3) >> 3)) {
#line 136
    tmp___25 = p;
#line 136
    p ++;
#line 136
    *tmp___25 = (char )'w';
  } else {
#line 138
    tmp___26 = p;
#line 138
    p ++;
#line 138
    *tmp___26 = (char )'-';
  }
#line 139
  switch ((int )(mode & (unsigned int )(((64 >> 3) >> 3) | 512))) {
  case 0: 
#line 141
  tmp___27 = p;
#line 141
  p ++;
#line 141
  *tmp___27 = (char )'-';
#line 142
  break;
  case (64 >> 3) >> 3: 
#line 144
  tmp___28 = p;
#line 144
  p ++;
#line 144
  *tmp___28 = (char )'x';
#line 145
  break;
  case 512: 
#line 147
  tmp___29 = p;
#line 147
  p ++;
#line 147
  *tmp___29 = (char )'T';
#line 148
  break;
  case ((64 >> 3) >> 3) | 512: 
#line 150
  tmp___30 = p;
#line 150
  p ++;
#line 150
  *tmp___30 = (char )'t';
#line 151
  break;
  }
#line 153
  tmp___31 = p;
#line 153
  p ++;
#line 153
  *tmp___31 = (char )' ';
#line 154
  *p = (char )'\000';
#line 155
  return;
}
}
#line 1 "strsep.o"
#line 1 "atomicio.o"
#line 31 "atomicio.h"
ssize_t atomicio(ssize_t (*f)() , int fd , void *_s , size_t n___0 ) ;
#line 34 "atomicio.c"
ssize_t atomicio(ssize_t (*f)() , int fd , void *_s , size_t n___0 ) 
{ char *s ;
  ssize_t res ;
  ssize_t pos ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 41
  s = (char *)_s;
#line 42
  pos = 0;
#line 44
  while (n___0 > (size_t )pos) {
#line 45
    res = (*f)(fd, s + pos, n___0 - (size_t )pos);
#line 46
    switch (res) {
    case -1: 
#line 49
    tmp = __errno_location();
#line 49
    if (*tmp == 4) {
#line 53
      continue;
    } else {
#line 49
      tmp___0 = __errno_location();
#line 49
      if (*tmp___0 == 11) {
#line 53
        continue;
      } else {
#line 49
        tmp___1 = __errno_location();
#line 49
        if (*tmp___1 == 11) {
#line 53
          continue;
        }
      }
    }
    case 0: 
#line 55
    return (res);
    default: 
#line 57
    pos += res;
    }
  }
#line 60
  return (pos);
}
}
#line 1 "authfd.o"
#line 76 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 100 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 124
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 405 "/usr/include/openssl/bn.h"
extern int BN_num_bits(BIGNUM const   *a ) ;
#line 26 "buffer.h"
void buffer_init(Buffer *buffer ) ;
#line 27
void buffer_clear(Buffer *buffer ) ;
#line 28
void buffer_free(Buffer *buffer ) ;
#line 30
u_int buffer_len(Buffer *buffer ) ;
#line 31
void *buffer_ptr(Buffer *buffer ) ;
#line 33
void buffer_append(Buffer *buffer , void const   *data , u_int len ) ;
#line 21 "bufaux.h"
void buffer_put_bignum(Buffer *buffer , BIGNUM *value ) ;
#line 22
void buffer_put_bignum2(Buffer *buffer , BIGNUM *value ) ;
#line 23
void buffer_get_bignum(Buffer *buffer , BIGNUM *value ) ;
#line 29
u_int buffer_get_int(Buffer *buffer ) ;
#line 30
void buffer_put_int(Buffer *buffer , u_int value ) ;
#line 37
int buffer_get_char(Buffer *buffer ) ;
#line 38
void buffer_put_char(Buffer *buffer , int value ) ;
#line 40
void *buffer_get_string(Buffer *buffer , u_int *length_ptr ) ;
#line 41
void buffer_put_string(Buffer *buffer , void const   *buf___1 , u_int len ) ;
#line 42
void buffer_put_cstring(Buffer *buffer , char const   *s ) ;
#line 22 "xmalloc.h"
void *xmalloc(size_t size ) ;
#line 24
void xfree(void *ptr ) ;
#line 58 "key.h"
Key *key_new(int type ) ;
#line 73
Key *key_from_blob(u_char *blob , int blen ) ;
#line 74
int key_to_blob(Key *key , u_char **blobp , u_int *lenp ) ;
#line 75
char *key_ssh_name(Key *k ) ;
#line 69 "authfd.h"
int ssh_get_authentication_socket(void) ;
#line 70
void ssh_close_authentication_socket(int sock ) ;
#line 72
AuthenticationConnection *ssh_get_authentication_connection(void) ;
#line 73
void ssh_close_authentication_connection(AuthenticationConnection *auth ) ;
#line 74
int ssh_get_num_identities(AuthenticationConnection *auth , int version ) ;
#line 75
Key *ssh_get_first_identity(AuthenticationConnection *auth , char **comment , int version ) ;
#line 76
Key *ssh_get_next_identity(AuthenticationConnection *auth , char **comment , int version ) ;
#line 77
int ssh_add_identity(AuthenticationConnection *auth , Key *key , char const   *comment ) ;
#line 78
int ssh_add_identity_constrained(AuthenticationConnection *auth , Key *key , char const   *comment ,
                                 u_int life ) ;
#line 79
int ssh_remove_identity(AuthenticationConnection *auth , Key *key ) ;
#line 80
int ssh_remove_all_identities(AuthenticationConnection *auth , int version ) ;
#line 81
int ssh_lock_agent(AuthenticationConnection *auth , int lock , char const   *password ) ;
#line 82
int ssh_update_card(AuthenticationConnection *auth , int add , char const   *reader_id ,
                    char const   *pin ) ;
#line 84
int ssh_decrypt_challenge(AuthenticationConnection *auth , Key *key , BIGNUM *challenge ,
                          u_char *session_id___0 , u_int response_type , u_char *response ) ;
#line 88
int ssh_agent_sign(AuthenticationConnection *auth , Key *key , u_char **sigp , u_int *lenp ,
                   u_char *data , u_int datalen ) ;
#line 66 "compat.h"
int datafellows ;
#line 57 "log.h"
void ( /* format attribute */  error)(char const   *fmt  , ...) ;
#line 58
void ( /* format attribute */  log)(char const   *fmt  , ...) ;
#line 57 "authfd.c"
int decode_reply(int type ) ;
#line 66 "authfd.c"
int ssh_get_authentication_socket(void) 
{ char const   *authsocket ;
  int sock ;
  struct sockaddr_un sunaddr ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 73
  tmp = getenv("SSH_AUTH_SOCK");
#line 73
  authsocket = (char const   *)tmp;
#line 74
  if (! authsocket) {
#line 75
    return (-1);
  }
#line 77
  sunaddr.sun_family = (unsigned short)1;
#line 78
  strlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));
#line 80
  sock = socket(1, 1, 0);
#line 81
  if (sock < 0) {
#line 82
    return (-1);
  }
#line 85
  tmp___0 = fcntl(sock, 2, 1);
#line 85
  if (tmp___0 == -1) {
#line 86
    close(sock);
#line 87
    return (-1);
  }
#line 89
  tmp___1 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sunaddr)),
                    sizeof(sunaddr));
#line 89
  if (tmp___1 < 0) {
#line 90
    close(sock);
#line 91
    return (-1);
  }
#line 93
  return (sock);
}
}
#line 96 "authfd.c"
static int ssh_request_reply(AuthenticationConnection *auth , Buffer *request , Buffer *reply ) 
{ int l ;
  int len ;
  char buf___1[1024] ;
  u_int tmp ;
  ssize_t tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  ssize_t tmp___3 ;
  u_int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;

  {
#line 103
  tmp = buffer_len(request);
#line 103
  len = (int )tmp;
#line 104
  while (1) {
#line 104
    buf___1[0] = (char )(len >> 24);
#line 104
    buf___1[1] = (char )(len >> 16);
#line 104
    buf___1[2] = (char )(len >> 8);
#line 104
    buf___1[3] = (char )len;
#line 104
    break;
  }
#line 107
  tmp___0 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)(buf___1), 4U);
#line 107
  if (tmp___0 != 4) {
#line 110
    error("Error writing to authentication socket.");
#line 111
    return (0);
  } else {
#line 107
    tmp___1 = buffer_len(request);
#line 107
    tmp___2 = buffer_ptr(request);
#line 107
    tmp___3 = atomicio((ssize_t (*)())(& write), auth->fd, tmp___2, tmp___1);
#line 107
    tmp___4 = buffer_len(request);
#line 107
    if ((u_int )tmp___3 != tmp___4) {
#line 110
      error("Error writing to authentication socket.");
#line 111
      return (0);
    }
  }
#line 117
  len = 4;
#line 118
  while (len > 0) {
#line 119
    l = read(auth->fd, (void *)((buf___1 + 4) - len), (unsigned int )len);
#line 120
    if (l == -1) {
#line 120
      tmp___5 = __errno_location();
#line 120
      if (*tmp___5 == 11) {
#line 121
        continue;
      } else {
#line 120
        tmp___6 = __errno_location();
#line 120
        if (*tmp___6 == 4) {
#line 121
          continue;
        }
      }
    }
#line 122
    if (l <= 0) {
#line 123
      error("Error reading response length from authentication socket.");
#line 124
      return (0);
    }
#line 126
    len -= l;
  }
#line 130
  len = (int )(((((unsigned long )((unsigned char )buf___1[0]) << 24) | ((unsigned long )((unsigned char )buf___1[1]) << 16)) | ((unsigned long )((unsigned char )buf___1[2]) << 8)) | (unsigned long )((unsigned char )buf___1[3]));
#line 131
  if (len > 262144) {
#line 132
    fatal("Authentication response too long: %d", len);
  }
#line 135
  buffer_clear(reply);
#line 136
  while (len > 0) {
#line 137
    l = len;
#line 138
    if ((unsigned int )l > sizeof(buf___1)) {
#line 139
      l = (int )sizeof(buf___1);
    }
#line 140
    l = read(auth->fd, (void *)(buf___1), (unsigned int )l);
#line 141
    if (l == -1) {
#line 141
      tmp___7 = __errno_location();
#line 141
      if (*tmp___7 == 11) {
#line 142
        continue;
      } else {
#line 141
        tmp___8 = __errno_location();
#line 141
        if (*tmp___8 == 4) {
#line 142
          continue;
        }
      }
    }
#line 143
    if (l <= 0) {
#line 144
      error("Error reading response from authentication socket.");
#line 145
      return (0);
    }
#line 147
    buffer_append(reply, (void const   *)(buf___1), (unsigned int )l);
#line 148
    len -= l;
  }
#line 150
  return (1);
}
}
#line 159 "authfd.c"
void ssh_close_authentication_socket(int sock ) 
{ char *tmp ;

  {
#line 162
  tmp = getenv("SSH_AUTH_SOCK");
#line 162
  if (tmp) {
#line 163
    close(sock);
  }
#line 164
  return;
}
}
#line 174 "authfd.c"
AuthenticationConnection *ssh_get_authentication_connection(void) 
{ AuthenticationConnection *auth ;
  int sock ;
  void *tmp ;

  {
#line 180
  sock = ssh_get_authentication_socket();
#line 186
  if (sock < 0) {
#line 187
    return ((AuthenticationConnection *)((void *)0));
  }
#line 189
  tmp = xmalloc(sizeof(*auth));
#line 189
  auth = (AuthenticationConnection *)tmp;
#line 190
  auth->fd = sock;
#line 191
  buffer_init(& auth->identities);
#line 192
  auth->howmany = 0;
#line 194
  return (auth);
}
}
#line 202 "authfd.c"
void ssh_close_authentication_connection(AuthenticationConnection *auth ) 
{ 

  {
#line 205
  buffer_free(& auth->identities);
#line 206
  close(auth->fd);
#line 207
  xfree((void *)auth);
#line 208
  return;
}
}
#line 211 "authfd.c"
int ssh_lock_agent(AuthenticationConnection *auth , int lock , char const   *password ) 
{ int type ;
  Buffer msg ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 217
  buffer_init(& msg);
#line 218
  if (lock) {
#line 218
    tmp = 22;
  } else {
#line 218
    tmp = 23;
  }
#line 218
  buffer_put_char(& msg, tmp);
#line 219
  buffer_put_cstring(& msg, password);
#line 221
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 221
  if (tmp___0 == 0) {
#line 222
    buffer_free(& msg);
#line 223
    return (0);
  }
#line 225
  type = buffer_get_char(& msg);
#line 226
  buffer_free(& msg);
#line 227
  tmp___1 = decode_reply(type);
#line 227
  return (tmp___1);
}
}
#line 234 "authfd.c"
int ssh_get_num_identities(AuthenticationConnection *auth , int version ) 
{ int type ;
  int code1 ;
  int code2 ;
  Buffer request ;
  int tmp ;
  u_int tmp___0 ;

  {
#line 237
  code1 = 0;
#line 237
  code2 = 0;
#line 240
  switch (version) {
  case 1: 
#line 242
  code1 = 1;
#line 243
  code2 = 2;
#line 244
  break;
  case 2: 
#line 246
  code1 = 11;
#line 247
  code2 = 12;
#line 248
  break;
  default: ;
#line 250
  return (0);
  }
#line 257
  buffer_init(& request);
#line 258
  buffer_put_char(& request, code1);
#line 260
  buffer_clear(& auth->identities);
#line 261
  tmp = ssh_request_reply(auth, & request, & auth->identities);
#line 261
  if (tmp == 0) {
#line 262
    buffer_free(& request);
#line 263
    return (0);
  }
#line 265
  buffer_free(& request);
#line 268
  type = buffer_get_char(& auth->identities);
#line 269
  if (type == 5) {
#line 270
    return (0);
  } else {
#line 269
    if (type == 102) {
#line 270
      return (0);
    } else {
#line 269
      if (type == 30) {
#line 270
        return (0);
      } else {
#line 271
        if (type != code2) {
#line 272
          fatal("Bad authentication reply message type: %d", type);
        }
      }
    }
  }
#line 276
  tmp___0 = buffer_get_int(& auth->identities);
#line 276
  auth->howmany = (int )tmp___0;
#line 277
  if (auth->howmany > 1024) {
#line 278
    fatal("Too many identities in authentication reply: %d", auth->howmany);
  }
#line 281
  return (auth->howmany);
}
}
#line 284 "authfd.c"
Key *ssh_get_first_identity(AuthenticationConnection *auth , char **comment , int version ) 
{ Key *tmp ;
  int tmp___0 ;

  {
#line 288
  tmp___0 = ssh_get_num_identities(auth, version);
#line 288
  if (tmp___0 > 0) {
#line 289
    tmp = ssh_get_next_identity(auth, comment, version);
#line 289
    return (tmp);
  }
#line 290
  return ((Key *)((void *)0));
}
}
#line 293 "authfd.c"
Key *ssh_get_next_identity(AuthenticationConnection *auth , char **comment , int version ) 
{ u_int bits ;
  u_char *blob ;
  u_int blen ;
  Key *key ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 299
  key = (Key *)((void *)0);
#line 302
  if (auth->howmany <= 0) {
#line 303
    return ((Key *)((void *)0));
  }
#line 309
  switch (version) {
  case 1: 
#line 311
  key = key_new(0);
#line 312
  bits = buffer_get_int(& auth->identities);
#line 313
  buffer_get_bignum(& auth->identities, (key->rsa)->e);
#line 314
  buffer_get_bignum(& auth->identities, (key->rsa)->n);
#line 315
  tmp = buffer_get_string(& auth->identities, (u_int *)((void *)0));
#line 315
  *comment = (char *)tmp;
#line 316
  tmp___1 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 316
  if (bits != (u_int )tmp___1) {
#line 317
    tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 317
    log("Warning: identity keysize mismatch: actual %d, announced %u", tmp___0, bits);
  }
#line 319
  break;
  case 2: 
#line 321
  tmp___2 = buffer_get_string(& auth->identities, & blen);
#line 321
  blob = (u_char *)tmp___2;
#line 322
  tmp___3 = buffer_get_string(& auth->identities, (u_int *)((void *)0));
#line 322
  *comment = (char *)tmp___3;
#line 323
  key = key_from_blob(blob, (int )blen);
#line 324
  xfree((void *)blob);
#line 325
  break;
  default: ;
#line 327
  return ((Key *)((void *)0));
#line 328
  break;
  }
#line 331
  (auth->howmany) --;
#line 332
  return (key);
}
}
#line 343 "authfd.c"
int ssh_decrypt_challenge(AuthenticationConnection *auth , Key *key , BIGNUM *challenge ,
                          u_char *session_id___0 , u_int response_type , u_char *response ) 
{ Buffer buffer ;
  int success ;
  int i ;
  int type ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 351
  success = 0;
#line 355
  if (key->type != 0) {
#line 356
    return (0);
  }
#line 357
  if (response_type == 0U) {
#line 358
    log("Compatibility with ssh protocol version 1.0 no longer supported.");
#line 359
    return (0);
  }
#line 361
  buffer_init(& buffer);
#line 362
  buffer_put_char(& buffer, 3);
#line 363
  tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 363
  buffer_put_int(& buffer, (unsigned int )tmp);
#line 364
  buffer_put_bignum(& buffer, (key->rsa)->e);
#line 365
  buffer_put_bignum(& buffer, (key->rsa)->n);
#line 366
  buffer_put_bignum(& buffer, challenge);
#line 367
  buffer_append(& buffer, (void const   *)session_id___0, 16U);
#line 368
  buffer_put_int(& buffer, response_type);
#line 370
  tmp___0 = ssh_request_reply(auth, & buffer, & buffer);
#line 370
  if (tmp___0 == 0) {
#line 371
    buffer_free(& buffer);
#line 372
    return (0);
  }
#line 374
  type = buffer_get_char(& buffer);
#line 376
  if (type == 5) {
#line 377
    log("Agent admitted failure to authenticate using the key.");
  } else {
#line 376
    if (type == 102) {
#line 377
      log("Agent admitted failure to authenticate using the key.");
    } else {
#line 376
      if (type == 30) {
#line 377
        log("Agent admitted failure to authenticate using the key.");
      } else {
#line 378
        if (type != 4) {
#line 379
          fatal("Bad authentication response: %d", type);
        } else {
#line 381
          success = 1;
#line 386
          i = 0;
#line 386
          while (i < 16) {
#line 387
            tmp___1 = buffer_get_char(& buffer);
#line 387
            *(response + i) = (unsigned char )tmp___1;
#line 386
            i ++;
          }
        }
      }
    }
  }
#line 389
  buffer_free(& buffer);
#line 390
  return (success);
}
}
#line 394 "authfd.c"
int ssh_agent_sign(AuthenticationConnection *auth , Key *key , u_char **sigp , u_int *lenp ,
                   u_char *data , u_int datalen ) 
{ Buffer msg ;
  u_char *blob ;
  u_int blen ;
  int type ;
  int flags ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 404
  flags = 0;
#line 405
  ret = -1;
#line 407
  tmp = key_to_blob(key, & blob, & blen);
#line 407
  if (tmp == 0) {
#line 408
    return (-1);
  }
#line 410
  if (datafellows & 1) {
#line 411
    flags = 1;
  }
#line 413
  buffer_init(& msg);
#line 414
  buffer_put_char(& msg, 13);
#line 415
  buffer_put_string(& msg, (void const   *)blob, blen);
#line 416
  buffer_put_string(& msg, (void const   *)data, datalen);
#line 417
  buffer_put_int(& msg, (unsigned int )flags);
#line 418
  xfree((void *)blob);
#line 420
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 420
  if (tmp___0 == 0) {
#line 421
    buffer_free(& msg);
#line 422
    return (-1);
  }
#line 424
  type = buffer_get_char(& msg);
#line 425
  if (type == 5) {
#line 426
    log("Agent admitted failure to sign using the key.");
  } else {
#line 425
    if (type == 102) {
#line 426
      log("Agent admitted failure to sign using the key.");
    } else {
#line 425
      if (type == 30) {
#line 426
        log("Agent admitted failure to sign using the key.");
      } else {
#line 427
        if (type != 14) {
#line 428
          fatal("Bad authentication response: %d", type);
        } else {
#line 430
          ret = 0;
#line 431
          tmp___1 = buffer_get_string(& msg, lenp);
#line 431
          *sigp = (u_char *)tmp___1;
        }
      }
    }
  }
#line 433
  buffer_free(& msg);
#line 434
  return (ret);
}
}
#line 439 "authfd.c"
static void ssh_encode_identity_rsa1(Buffer *b , RSA *key , char const   *comment ) 
{ int tmp ;

  {
#line 442
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 442
  buffer_put_int(b, (unsigned int )tmp);
#line 443
  buffer_put_bignum(b, key->n);
#line 444
  buffer_put_bignum(b, key->e);
#line 445
  buffer_put_bignum(b, key->d);
#line 447
  buffer_put_bignum(b, key->iqmp);
#line 448
  buffer_put_bignum(b, key->q);
#line 449
  buffer_put_bignum(b, key->p);
#line 450
  buffer_put_cstring(b, comment);
#line 451
  return;
}
}
#line 453 "authfd.c"
static void ssh_encode_identity_ssh2(Buffer *b , Key *key , char const   *comment ) 
{ char *tmp ;

  {
#line 456
  tmp = key_ssh_name(key);
#line 456
  buffer_put_cstring(b, (char const   *)tmp);
#line 457
  switch (key->type) {
  case 1: 
#line 459
  buffer_put_bignum2(b, (key->rsa)->n);
#line 460
  buffer_put_bignum2(b, (key->rsa)->e);
#line 461
  buffer_put_bignum2(b, (key->rsa)->d);
#line 462
  buffer_put_bignum2(b, (key->rsa)->iqmp);
#line 463
  buffer_put_bignum2(b, (key->rsa)->p);
#line 464
  buffer_put_bignum2(b, (key->rsa)->q);
#line 465
  break;
  case 2: 
#line 467
  buffer_put_bignum2(b, (key->dsa)->p);
#line 468
  buffer_put_bignum2(b, (key->dsa)->q);
#line 469
  buffer_put_bignum2(b, (key->dsa)->g);
#line 470
  buffer_put_bignum2(b, (key->dsa)->pub_key);
#line 471
  buffer_put_bignum2(b, (key->dsa)->priv_key);
#line 472
  break;
  }
#line 474
  buffer_put_cstring(b, comment);
#line 475
  return;
}
}
#line 482 "authfd.c"
int ssh_add_identity_constrained(AuthenticationConnection *auth , Key *key , char const   *comment ,
                                 u_int life ) 
{ Buffer msg ;
  int type ;
  int constrained ;
  int tmp ;
  int tmp___0 ;

  {
#line 487
  constrained = life != 0U;
#line 489
  buffer_init(& msg);
#line 491
  switch (key->type) {
  case 0: 
#line 493
  if (constrained) {
#line 493
    type = 24;
  } else {
#line 493
    type = 7;
  }
#line 496
  buffer_put_char(& msg, type);
#line 497
  ssh_encode_identity_rsa1(& msg, key->rsa, comment);
#line 498
  break;
  case 1: 
  case 2: 
#line 501
  if (constrained) {
#line 501
    type = 25;
  } else {
#line 501
    type = 17;
  }
#line 504
  buffer_put_char(& msg, type);
#line 505
  ssh_encode_identity_ssh2(& msg, key, comment);
#line 506
  break;
  default: 
#line 508
  buffer_free(& msg);
#line 509
  return (0);
#line 510
  break;
  }
#line 512
  if (constrained) {
#line 513
    if (life != 0U) {
#line 514
      buffer_put_char(& msg, 1);
#line 515
      buffer_put_int(& msg, life);
    }
  }
#line 518
  tmp = ssh_request_reply(auth, & msg, & msg);
#line 518
  if (tmp == 0) {
#line 519
    buffer_free(& msg);
#line 520
    return (0);
  }
#line 522
  type = buffer_get_char(& msg);
#line 523
  buffer_free(& msg);
#line 524
  tmp___0 = decode_reply(type);
#line 524
  return (tmp___0);
}
}
#line 527 "authfd.c"
int ssh_add_identity(AuthenticationConnection *auth , Key *key , char const   *comment ) 
{ int tmp ;

  {
#line 530
  tmp = ssh_add_identity_constrained(auth, key, comment, 0U);
#line 530
  return (tmp);
}
}
#line 538 "authfd.c"
int ssh_remove_identity(AuthenticationConnection *auth , Key *key ) 
{ Buffer msg ;
  int type ;
  u_char *blob ;
  u_int blen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 546
  buffer_init(& msg);
#line 548
  if (key->type == 0) {
#line 549
    buffer_put_char(& msg, 8);
#line 550
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 550
    buffer_put_int(& msg, (unsigned int )tmp);
#line 551
    buffer_put_bignum(& msg, (key->rsa)->e);
#line 552
    buffer_put_bignum(& msg, (key->rsa)->n);
  } else {
#line 553
    if (key->type == 2) {
#line 554
      key_to_blob(key, & blob, & blen);
#line 555
      buffer_put_char(& msg, 18);
#line 556
      buffer_put_string(& msg, (void const   *)blob, blen);
#line 557
      xfree((void *)blob);
    } else {
#line 553
      if (key->type == 1) {
#line 554
        key_to_blob(key, & blob, & blen);
#line 555
        buffer_put_char(& msg, 18);
#line 556
        buffer_put_string(& msg, (void const   *)blob, blen);
#line 557
        xfree((void *)blob);
      } else {
#line 559
        buffer_free(& msg);
#line 560
        return (0);
      }
    }
  }
#line 562
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 562
  if (tmp___0 == 0) {
#line 563
    buffer_free(& msg);
#line 564
    return (0);
  }
#line 566
  type = buffer_get_char(& msg);
#line 567
  buffer_free(& msg);
#line 568
  tmp___1 = decode_reply(type);
#line 568
  return (tmp___1);
}
}
#line 571 "authfd.c"
int ssh_update_card(AuthenticationConnection *auth , int add , char const   *reader_id ,
                    char const   *pin ) 
{ Buffer msg ;
  int type ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 577
  buffer_init(& msg);
#line 578
  if (add) {
#line 578
    tmp = 20;
  } else {
#line 578
    tmp = 21;
  }
#line 578
  buffer_put_char(& msg, tmp);
#line 580
  buffer_put_cstring(& msg, reader_id);
#line 581
  buffer_put_cstring(& msg, pin);
#line 582
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 582
  if (tmp___0 == 0) {
#line 583
    buffer_free(& msg);
#line 584
    return (0);
  }
#line 586
  type = buffer_get_char(& msg);
#line 587
  buffer_free(& msg);
#line 588
  tmp___1 = decode_reply(type);
#line 588
  return (tmp___1);
}
}
#line 596 "authfd.c"
int ssh_remove_all_identities(AuthenticationConnection *auth , int version ) 
{ Buffer msg ;
  int type ;
  int code ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 601
  if (version == 1) {
#line 601
    tmp = 9;
  } else {
#line 601
    tmp = 19;
  }
#line 601
  code = tmp;
#line 605
  buffer_init(& msg);
#line 606
  buffer_put_char(& msg, code);
#line 608
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 608
  if (tmp___0 == 0) {
#line 609
    buffer_free(& msg);
#line 610
    return (0);
  }
#line 612
  type = buffer_get_char(& msg);
#line 613
  buffer_free(& msg);
#line 614
  tmp___1 = decode_reply(type);
#line 614
  return (tmp___1);
}
}
#line 617 "authfd.c"
int decode_reply(int type ) 
{ 

  {
#line 620
  switch (type) {
  case 5: 
  case 102: 
  case 30: 
#line 624
  log("SSH_AGENT_FAILURE");
#line 625
  return (0);
  case 6: 
#line 627
  return (1);
  default: 
#line 629
  fatal("Bad response from authentication agent: %d", type);
  }
#line 632
  return (0);
}
}
#line 1 "authfile.o"
#line 213 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 259
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 280
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 532
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 256 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 304 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off64_t lseek(int __fd , __off64_t __offset ,
                                                     int __whence )  __asm__("lseek64")  ;
#line 792
extern  __attribute__((__nothrow__)) int unlink(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 218 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64") __attribute__((__nonnull__(2))) ;
#line 391
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __asm__("__fxstat64") __attribute__((__nonnull__(3))) ;
#line 447
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64") __attribute__((__nonnull__(2))) ;
#line 447 "/usr/include/sys/stat.h"
__inline static int fstat(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
#line 450
  tmp = __fxstat(3, __fd, __statbuf);
#line 450
  return (tmp);
}
}
#line 639 "/usr/include/openssl/evp.h"
extern EVP_CIPHER const   *EVP_des_ede3_cbc(void) ;
#line 749
extern struct rsa_st *EVP_PKEY_get1_RSA(EVP_PKEY *pkey ) ;
#line 754
extern struct dsa_st *EVP_PKEY_get1_DSA(EVP_PKEY *pkey ) ;
#line 763
extern void EVP_PKEY_free(EVP_PKEY *pkey ) ;
#line 616 "/usr/include/openssl/pem.h"
extern int PEM_write_RSAPrivateKey(FILE *fp , RSA *x , EVP_CIPHER const   *enc , unsigned char *kstr ,
                                   int klen , pem_password_cb *cb , void *u ) ;
#line 625
extern int PEM_write_DSAPrivateKey(FILE *fp , DSA *x , EVP_CIPHER const   *enc , unsigned char *kstr ,
                                   int klen , pem_password_cb *cb , void *u ) ;
#line 640
extern EVP_PKEY *PEM_read_PrivateKey(FILE *fp , EVP_PKEY **x , pem_password_cb *cb ,
                                     void *u ) ;
#line 73 "cipher.h"
Cipher *cipher_by_number(int id ) ;
#line 79
void cipher_crypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) ;
#line 80
void cipher_cleanup(CipherContext *cc ) ;
#line 81
void cipher_set_key_string(CipherContext *cc , Cipher *cipher , char const   *passphrase ,
                           int encrypt ) ;
#line 25 "xmalloc.h"
char *xstrdup(char const   *str ) ;
#line 34 "buffer.h"
void *buffer_append_space(Buffer *buffer , u_int len ) ;
#line 59 "key.h"
Key *key_new_private(int type ) ;
#line 60
void key_free(Key *k ) ;
#line 64
char *key_type(Key *k ) ;
#line 66
int key_read(Key *ret , char **cpp ) ;
#line 60 "log.h"
void ( /* format attribute */  debug)(char const   *fmt  , ...) ;
#line 62
void ( /* format attribute */  debug3)(char const   *fmt  , ...) ;
#line 18 "authfile.h"
int key_save_private(Key *key , char const   *filename , char const   *passphrase ,
                     char const   *comment ) ;
#line 19
Key *key_load_public(char const   *filename , char **commentp ) ;
#line 20
Key *key_load_public_type(int type , char const   *filename , char **commentp ) ;
#line 21
Key *key_load_private(char const   *filename , char const   *passphrase , char **commentp ) ;
#line 22
Key *key_load_private_type(int type , char const   *filename , char const   *passphrase ,
                           char **commentp ) ;
#line 23
Key *key_load_private_pem(int fd , int type , char const   *passphrase , char **commentp ) ;
#line 24 "rsa.h"
void rsa_generate_additional_parameters(RSA *rsa ) ;
#line 56 "authfile.c"
static char const   authfile_id_string[33]  = 
#line 56 "authfile.c"
  {      (char const   )'S',      (char const   )'S',      (char const   )'H',      (char const   )' ', 
        (char const   )'P',      (char const   )'R',      (char const   )'I',      (char const   )'V', 
        (char const   )'A',      (char const   )'T',      (char const   )'E',      (char const   )' ', 
        (char const   )'K',      (char const   )'E',      (char const   )'Y',      (char const   )' ', 
        (char const   )'F',      (char const   )'I',      (char const   )'L',      (char const   )'E', 
        (char const   )' ',      (char const   )'F',      (char const   )'O',      (char const   )'R', 
        (char const   )'M',      (char const   )'A',      (char const   )'T',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )'\n', 
        (char const   )'\000'};
#line 66 "authfile.c"
static int key_save_private_rsa1(Key *key , char const   *filename , char const   *passphrase ,
                                 char const   *comment ) 
{ Buffer buffer ;
  Buffer encrypted ;
  u_char buf___1[100] ;
  u_char *cp ;
  int fd ;
  int i ;
  int cipher_num ;
  CipherContext ciphercontext ;
  Cipher *cipher ;
  u_int32_t rand___0 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  u_int tmp___19 ;
  int tmp___20 ;
  u_int tmp___21 ;
  void *tmp___22 ;
  u_int tmp___23 ;
  void *tmp___24 ;
  int *tmp___25 ;
  char *tmp___26 ;
  int *tmp___27 ;
  char *tmp___28 ;
  u_int tmp___29 ;
  void *tmp___30 ;
  ssize_t tmp___31 ;
  u_int tmp___32 ;

  {
#line 81
  if (0) {
#line 81
    __s1_len___0 = strlen(passphrase);
#line 81
    __s2_len___0 = strlen("");
#line 81
    if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
      goto _L___2;
    } else {
#line 81
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 81
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 81
          tmp___18 = 1;
        } else {
#line 81
          if (__s2_len___0 >= 4U) {
#line 81
            tmp___18 = 1;
          } else {
#line 81
            tmp___18 = 0;
          }
        }
      } else {
#line 81
        tmp___18 = 0;
      }
    }
#line 81
    if (tmp___18) {
#line 81
      tmp___14 = __builtin_strcmp(passphrase, "");
    } else {
#line 81
      tmp___17 = __builtin_strcmp(passphrase, "");
#line 81
      tmp___14 = tmp___17;
    }
  } else {
#line 81
    tmp___17 = __builtin_strcmp(passphrase, "");
#line 81
    tmp___14 = tmp___17;
  }
#line 81
  if (tmp___14 == 0) {
#line 81
    cipher_num = 0;
  } else {
#line 81
    cipher_num = 3;
  }
#line 83
  cipher = cipher_by_number(cipher_num);
#line 83
  if ((unsigned int )cipher == (unsigned int )((void *)0)) {
#line 84
    fatal("save_private_key_rsa: bad cipher");
  }
#line 87
  buffer_init(& buffer);
#line 90
  rand___0 = arc4random();
#line 91
  buf___1[0] = (unsigned char )(rand___0 & 255U);
#line 92
  buf___1[1] = (unsigned char )((rand___0 >> 8) & 255U);
#line 93
  buf___1[2] = buf___1[0];
#line 94
  buf___1[3] = buf___1[1];
#line 95
  buffer_append(& buffer, (void const   *)(buf___1), 4U);
#line 102
  buffer_put_bignum(& buffer, (key->rsa)->d);
#line 103
  buffer_put_bignum(& buffer, (key->rsa)->iqmp);
#line 104
  buffer_put_bignum(& buffer, (key->rsa)->q);
#line 105
  buffer_put_bignum(& buffer, (key->rsa)->p);
#line 108
  while (1) {
#line 108
    tmp___19 = buffer_len(& buffer);
#line 108
    if (! (tmp___19 % 8U != 0U)) {
#line 108
      break;
    }
#line 109
    buffer_put_char(& buffer, 0);
  }
#line 112
  buffer_init(& encrypted);
#line 115
  i = 0;
#line 115
  while (authfile_id_string[i]) {
#line 116
    buffer_put_char(& encrypted, (int )authfile_id_string[i]);
#line 115
    i ++;
  }
#line 117
  buffer_put_char(& encrypted, 0);
#line 120
  buffer_put_char(& encrypted, cipher_num);
#line 121
  buffer_put_int(& encrypted, 0U);
#line 124
  tmp___20 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 124
  buffer_put_int(& encrypted, (unsigned int )tmp___20);
#line 125
  buffer_put_bignum(& encrypted, (key->rsa)->n);
#line 126
  buffer_put_bignum(& encrypted, (key->rsa)->e);
#line 127
  buffer_put_cstring(& encrypted, comment);
#line 130
  tmp___21 = buffer_len(& buffer);
#line 130
  tmp___22 = buffer_append_space(& encrypted, tmp___21);
#line 130
  cp = (u_char *)tmp___22;
#line 132
  cipher_set_key_string(& ciphercontext, cipher, passphrase, 1);
#line 134
  tmp___23 = buffer_len(& buffer);
#line 134
  tmp___24 = buffer_ptr(& buffer);
#line 134
  cipher_crypt(& ciphercontext, cp, (u_char const   *)tmp___24, tmp___23);
#line 136
  cipher_cleanup(& ciphercontext);
#line 137
  memset((void *)(& ciphercontext), 0, sizeof(ciphercontext));
#line 140
  memset((void *)(buf___1), 0, sizeof(buf___1));
#line 141
  buffer_free(& buffer);
#line 143
  fd = open(filename, 577, 384);
#line 144
  if (fd < 0) {
#line 145
    tmp___25 = __errno_location();
#line 145
    tmp___26 = strerror(*tmp___25);
#line 145
    error("open %s failed: %s.", filename, tmp___26);
#line 146
    return (0);
  }
#line 148
  tmp___29 = buffer_len(& encrypted);
#line 148
  tmp___30 = buffer_ptr(& encrypted);
#line 148
  tmp___31 = write(fd, (void const   *)tmp___30, tmp___29);
#line 148
  tmp___32 = buffer_len(& encrypted);
#line 148
  if ((u_int )tmp___31 != tmp___32) {
#line 150
    tmp___27 = __errno_location();
#line 150
    tmp___28 = strerror(*tmp___27);
#line 150
    error("write to key file %s failed: %s", filename, tmp___28);
#line 152
    buffer_free(& encrypted);
#line 153
    close(fd);
#line 154
    unlink(filename);
#line 155
    return (0);
  }
#line 157
  close(fd);
#line 158
  buffer_free(& encrypted);
#line 159
  return (1);
}
}
#line 163 "authfile.c"
static int key_save_private_pem(Key *key , char const   *filename , char const   *_passphrase ,
                                char const   *comment ) 
{ FILE *fp ;
  int fd ;
  int success ;
  int len ;
  size_t tmp ;
  u_char *passphrase ;
  u_char *tmp___0 ;
  EVP_CIPHER const   *cipher ;
  EVP_CIPHER const   *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
#line 169
  success = 0;
#line 170
  tmp = strlen(_passphrase);
#line 170
  len = (int )tmp;
#line 171
  if (len > 0) {
#line 171
    tmp___0 = (u_char *)_passphrase;
  } else {
#line 171
    tmp___0 = (u_char *)((void *)0);
  }
#line 171
  passphrase = tmp___0;
#line 172
  if (len > 0) {
#line 172
    tmp___2 = EVP_des_ede3_cbc();
  } else {
#line 172
    tmp___2 = (EVP_CIPHER const   *)((void *)0);
  }
#line 172
  cipher = tmp___2;
#line 174
  if (len > 0) {
#line 174
    if (len <= 4) {
#line 175
      error("passphrase too short: have %d bytes, need > 4", len);
#line 176
      return (0);
    }
  }
#line 178
  fd = open(filename, 577, 384);
#line 179
  if (fd < 0) {
#line 180
    tmp___3 = __errno_location();
#line 180
    tmp___4 = strerror(*tmp___3);
#line 180
    error("open %s failed: %s.", filename, tmp___4);
#line 181
    return (0);
  }
#line 183
  fp = fdopen(fd, "w");
#line 184
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 185
    tmp___5 = __errno_location();
#line 185
    tmp___6 = strerror(*tmp___5);
#line 185
    error("fdopen %s failed: %s.", filename, tmp___6);
#line 186
    close(fd);
#line 187
    return (0);
  }
#line 189
  switch (key->type) {
  case 2: 
#line 191
  success = PEM_write_DSAPrivateKey(fp, key->dsa, cipher, passphrase, len, (pem_password_cb *)((void *)0),
                                    (void *)0);
#line 193
  break;
  case 1: 
#line 195
  success = PEM_write_RSAPrivateKey(fp, key->rsa, cipher, passphrase, len, (pem_password_cb *)((void *)0),
                                    (void *)0);
#line 197
  break;
  }
#line 199
  fclose(fp);
#line 200
  return (success);
}
}
#line 203 "authfile.c"
int key_save_private(Key *key , char const   *filename , char const   *passphrase ,
                     char const   *comment ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 207
  switch (key->type) {
  case 0: 
#line 209
  tmp = key_save_private_rsa1(key, filename, passphrase, comment);
#line 209
  return (tmp);
#line 211
  break;
  case 2: 
  case 1: 
#line 214
  tmp___0 = key_save_private_pem(key, filename, passphrase, comment);
#line 214
  return (tmp___0);
#line 216
  break;
  default: ;
#line 218
  break;
  }
#line 220
  error("key_save_private: cannot save key type %d", key->type);
#line 221
  return (0);
}
}
#line 230 "authfile.c"
static Key *key_load_public_rsa1(int fd , char const   *filename , char **commentp ) 
{ Buffer buffer ;
  Key *pub ;
  char *cp ;
  int i ;
  off_t len ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  ssize_t tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;

  {
#line 239
  len = lseek(fd, 0LL, 2);
#line 240
  lseek(fd, 0LL, 0);
#line 242
  buffer_init(& buffer);
#line 243
  tmp = buffer_append_space(& buffer, (unsigned int )len);
#line 243
  cp = (char *)tmp;
#line 245
  tmp___2 = read(fd, (void *)cp, (unsigned int )len);
#line 245
  if ((unsigned int )tmp___2 != (unsigned int )len) {
#line 246
    tmp___0 = __errno_location();
#line 246
    tmp___1 = strerror(*tmp___0);
#line 246
    debug("Read from key file %.200s failed: %.100s", filename, tmp___1);
#line 248
    buffer_free(& buffer);
#line 249
    return ((Key *)((void *)0));
  }
#line 253
  if (len < (off_t )sizeof(authfile_id_string)) {
#line 254
    debug3("Not a RSA1 key file %.200s.", filename);
#line 255
    buffer_free(& buffer);
#line 256
    return ((Key *)((void *)0));
  }
#line 262
  i = 0;
#line 262
  while ((unsigned int )i < sizeof(authfile_id_string)) {
#line 263
    tmp___3 = buffer_get_char(& buffer);
#line 263
    if (tmp___3 != (int )authfile_id_string[i]) {
#line 264
      debug3("Not a RSA1 key file %.200s.", filename);
#line 265
      buffer_free(& buffer);
#line 266
      return ((Key *)((void *)0));
    }
#line 262
    i ++;
  }
#line 269
  buffer_get_char(& buffer);
#line 270
  buffer_get_int(& buffer);
#line 273
  buffer_get_int(& buffer);
#line 274
  pub = key_new(0);
#line 275
  buffer_get_bignum(& buffer, (pub->rsa)->n);
#line 276
  buffer_get_bignum(& buffer, (pub->rsa)->e);
#line 277
  if (commentp) {
#line 278
    tmp___4 = buffer_get_string(& buffer, (u_int *)((void *)0));
#line 278
    *commentp = (char *)tmp___4;
  }
#line 281
  buffer_free(& buffer);
#line 282
  return (pub);
}
}
#line 286 "authfile.c"
Key *key_load_public_type(int type , char const   *filename , char **commentp ) 
{ Key *pub ;
  int fd ;

  {
#line 292
  if (type == 0) {
#line 293
    fd = open(filename, 0);
#line 294
    if (fd < 0) {
#line 295
      return ((Key *)((void *)0));
    }
#line 296
    pub = key_load_public_rsa1(fd, filename, commentp);
#line 297
    close(fd);
#line 298
    return (pub);
  }
#line 300
  return ((Key *)((void *)0));
}
}
#line 310 "authfile.c"
static Key *key_load_private_rsa1(int fd , char const   *filename , char const   *passphrase ,
                                  char **commentp ) 
{ int i ;
  int check1 ;
  int check2 ;
  int cipher_type ;
  off_t len ;
  Buffer buffer ;
  Buffer decrypted ;
  u_char *cp ;
  CipherContext ciphercontext ;
  Cipher *cipher ;
  Key *prv ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  ssize_t tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  u_int tmp___6 ;
  void *tmp___7 ;
  u_int tmp___8 ;
  void *tmp___9 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 320
  prv = (Key *)((void *)0);
#line 322
  len = lseek(fd, 0LL, 2);
#line 323
  lseek(fd, 0LL, 0);
#line 325
  buffer_init(& buffer);
#line 326
  tmp = buffer_append_space(& buffer, (unsigned int )len);
#line 326
  cp = (u_char *)tmp;
#line 328
  tmp___2 = read(fd, (void *)cp, (unsigned int )len);
#line 328
  if ((unsigned int )tmp___2 != (unsigned int )len) {
#line 329
    tmp___0 = __errno_location();
#line 329
    tmp___1 = strerror(*tmp___0);
#line 329
    debug("Read from key file %.200s failed: %.100s", filename, tmp___1);
#line 331
    buffer_free(& buffer);
#line 332
    close(fd);
#line 333
    return ((Key *)((void *)0));
  }
#line 337
  if (len < (off_t )sizeof(authfile_id_string)) {
#line 338
    debug3("Not a RSA1 key file %.200s.", filename);
#line 339
    buffer_free(& buffer);
#line 340
    close(fd);
#line 341
    return ((Key *)((void *)0));
  }
#line 347
  i = 0;
#line 347
  while ((unsigned int )i < sizeof(authfile_id_string)) {
#line 348
    tmp___3 = buffer_get_char(& buffer);
#line 348
    if (tmp___3 != (int )authfile_id_string[i]) {
#line 349
      debug3("Not a RSA1 key file %.200s.", filename);
#line 350
      buffer_free(& buffer);
#line 351
      close(fd);
#line 352
      return ((Key *)((void *)0));
    }
#line 347
    i ++;
  }
#line 356
  cipher_type = buffer_get_char(& buffer);
#line 357
  buffer_get_int(& buffer);
#line 360
  buffer_get_int(& buffer);
#line 361
  prv = key_new_private(0);
#line 363
  buffer_get_bignum(& buffer, (prv->rsa)->n);
#line 364
  buffer_get_bignum(& buffer, (prv->rsa)->e);
#line 365
  if (commentp) {
#line 366
    tmp___4 = buffer_get_string(& buffer, (u_int *)((void *)0));
#line 366
    *commentp = (char *)tmp___4;
  } else {
#line 368
    tmp___5 = buffer_get_string(& buffer, (u_int *)((void *)0));
#line 368
    xfree(tmp___5);
  }
#line 371
  cipher = cipher_by_number(cipher_type);
#line 372
  if ((unsigned int )cipher == (unsigned int )((void *)0)) {
#line 373
    debug("Unsupported cipher %d used in key file %.200s.", cipher_type, filename);
#line 375
    buffer_free(& buffer);
    goto fail;
  }
#line 379
  buffer_init(& decrypted);
#line 380
  tmp___6 = buffer_len(& buffer);
#line 380
  tmp___7 = buffer_append_space(& decrypted, tmp___6);
#line 380
  cp = (u_char *)tmp___7;
#line 383
  cipher_set_key_string(& ciphercontext, cipher, passphrase, 0);
#line 385
  tmp___8 = buffer_len(& buffer);
#line 385
  tmp___9 = buffer_ptr(& buffer);
#line 385
  cipher_crypt(& ciphercontext, cp, (u_char const   *)tmp___9, tmp___8);
#line 387
  cipher_cleanup(& ciphercontext);
#line 388
  memset((void *)(& ciphercontext), 0, sizeof(ciphercontext));
#line 389
  buffer_free(& buffer);
#line 391
  check1 = buffer_get_char(& decrypted);
#line 392
  check2 = buffer_get_char(& decrypted);
#line 393
  tmp___20 = buffer_get_char(& decrypted);
#line 393
  if (check1 != tmp___20) {
    goto _L___1;
  } else {
#line 393
    tmp___21 = buffer_get_char(& decrypted);
#line 393
    if (check2 != tmp___21) {
      _L___1: /* CIL Label */ 
#line 395
      if (0) {
#line 395
        __s1_len = strlen(passphrase);
#line 395
        __s2_len = strlen("");
#line 395
        if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
          goto _L___0;
        } else {
#line 395
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 395
            if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 395
              tmp___19 = 1;
            } else {
#line 395
              if (__s2_len >= 4U) {
#line 395
                tmp___19 = 1;
              } else {
#line 395
                tmp___19 = 0;
              }
            }
          } else {
#line 395
            tmp___19 = 0;
          }
        }
#line 395
        if (tmp___19) {
#line 395
          tmp___15 = __builtin_strcmp(passphrase, "");
        } else {
#line 395
          tmp___18 = __builtin_strcmp(passphrase, "");
#line 395
          tmp___15 = tmp___18;
        }
      } else {
#line 395
        tmp___18 = __builtin_strcmp(passphrase, "");
#line 395
        tmp___15 = tmp___18;
      }
#line 395
      if (tmp___15 != 0) {
#line 396
        debug("Bad passphrase supplied for key file %.200s.", filename);
      }
#line 399
      buffer_free(& decrypted);
      goto fail;
    }
  }
#line 403
  buffer_get_bignum(& decrypted, (prv->rsa)->d);
#line 404
  buffer_get_bignum(& decrypted, (prv->rsa)->iqmp);
#line 406
  buffer_get_bignum(& decrypted, (prv->rsa)->q);
#line 407
  buffer_get_bignum(& decrypted, (prv->rsa)->p);
#line 410
  rsa_generate_additional_parameters(prv->rsa);
#line 412
  buffer_free(& decrypted);
#line 413
  close(fd);
#line 414
  return (prv);
  fail: 
#line 417
  if (commentp) {
#line 418
    xfree((void *)*commentp);
  }
#line 419
  close(fd);
#line 420
  key_free(prv);
#line 421
  return ((Key *)((void *)0));
}
}
#line 424 "authfile.c"
Key *key_load_private_pem(int fd , int type , char const   *passphrase , char **commentp ) 
{ FILE *fp ;
  EVP_PKEY *pk ;
  Key *prv ;
  char *name ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___2 ;
  char *tmp___3 ;

  {
#line 429
  pk = (EVP_PKEY *)((void *)0);
#line 430
  prv = (Key *)((void *)0);
#line 431
  name = (char *)"<no key>";
#line 433
  fp = fdopen(fd, "r");
#line 434
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 435
    tmp = __errno_location();
#line 435
    tmp___0 = strerror(*tmp);
#line 435
    error("fdopen failed: %s", tmp___0);
#line 436
    close(fd);
#line 437
    return ((Key *)((void *)0));
  }
#line 439
  pk = PEM_read_PrivateKey(fp, (EVP_PKEY **)((void *)0), (pem_password_cb *)((void *)0),
                           (void *)((char *)passphrase));
#line 440
  if ((unsigned int )pk == (unsigned int )((void *)0)) {
#line 441
    debug("PEM_read_PrivateKey failed");
#line 442
    ERR_get_error();
  } else {
#line 443
    if (pk->type == 6) {
#line 443
      if (type == 3) {
#line 445
        prv = key_new(3);
#line 446
        prv->rsa = EVP_PKEY_get1_RSA(pk);
#line 447
        prv->type = 1;
#line 448
        name = (char *)"rsa w/o comment";
      } else {
#line 443
        if (type == 1) {
#line 445
          prv = key_new(3);
#line 446
          prv->rsa = EVP_PKEY_get1_RSA(pk);
#line 447
          prv->type = 1;
#line 448
          name = (char *)"rsa w/o comment";
        } else {
          goto _L;
        }
      }
    } else {
      _L: /* CIL Label */ 
#line 452
      if (pk->type == 116) {
#line 452
        if (type == 3) {
#line 454
          prv = key_new(3);
#line 455
          prv->dsa = EVP_PKEY_get1_DSA(pk);
#line 456
          prv->type = 2;
#line 457
          name = (char *)"dsa w/o comment";
        } else {
#line 452
          if (type == 2) {
#line 454
            prv = key_new(3);
#line 455
            prv->dsa = EVP_PKEY_get1_DSA(pk);
#line 456
            prv->type = 2;
#line 457
            name = (char *)"dsa w/o comment";
          } else {
#line 462
            error("PEM_read_PrivateKey: mismatch or unknown EVP_PKEY save_type %d",
                  pk->save_type);
          }
        }
      } else {
#line 462
        error("PEM_read_PrivateKey: mismatch or unknown EVP_PKEY save_type %d", pk->save_type);
      }
    }
  }
#line 465
  fclose(fp);
#line 466
  if ((unsigned int )pk != (unsigned int )((void *)0)) {
#line 467
    EVP_PKEY_free(pk);
  }
#line 468
  if ((unsigned int )prv != (unsigned int )((void *)0)) {
#line 468
    if (commentp) {
#line 469
      *commentp = xstrdup((char const   *)name);
    }
  }
#line 470
  if (prv) {
#line 470
    tmp___3 = key_type(prv);
#line 470
    tmp___2 = (char const   *)tmp___3;
  } else {
#line 470
    tmp___2 = "<unknown>";
  }
#line 470
  debug("read PEM private key done: type %s", tmp___2);
#line 472
  return (prv);
}
}
#line 475 "authfile.c"
static int key_perm_ok(int fd , char const   *filename ) 
{ struct stat st ;
  int tmp ;
  __uid_t tmp___0 ;

  {
#line 480
  tmp = fstat(fd, & st);
#line 480
  if (tmp < 0) {
#line 481
    return (0);
  }
#line 490
  tmp___0 = getuid();
#line 490
  if (st.st_uid == tmp___0) {
#line 490
    if ((st.st_mode & 63U) != 0U) {
#line 491
      error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 492
      error("@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @");
#line 493
      error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 494
      error("Permissions 0%3.3o for \'%s\' are too open.", st.st_mode & 511U, filename);
#line 496
      error("It is recommended that your private key files are NOT accessible by others.");
#line 497
      error("This private key will be ignored.");
#line 498
      return (0);
    }
  }
#line 500
  return (1);
}
}
#line 503 "authfile.c"
Key *key_load_private_type(int type , char const   *filename , char const   *passphrase ,
                           char **commentp ) 
{ int fd ;
  int tmp ;
  Key *tmp___0 ;
  Key *tmp___1 ;

  {
#line 509
  fd = open(filename, 0);
#line 510
  if (fd < 0) {
#line 511
    return ((Key *)((void *)0));
  }
#line 512
  tmp = key_perm_ok(fd, filename);
#line 512
  if (! tmp) {
#line 513
    error("bad permissions: ignore key: %s", filename);
#line 514
    close(fd);
#line 515
    return ((Key *)((void *)0));
  }
#line 517
  switch (type) {
  case 0: 
#line 519
  tmp___0 = key_load_private_rsa1(fd, filename, passphrase, commentp);
#line 519
  return (tmp___0);
#line 522
  break;
  case 2: 
  case 1: 
  case 3: 
#line 526
  tmp___1 = key_load_private_pem(fd, type, passphrase, commentp);
#line 526
  return (tmp___1);
#line 528
  break;
  default: 
#line 530
  close(fd);
#line 531
  break;
  }
#line 533
  return ((Key *)((void *)0));
}
}
#line 536 "authfile.c"
Key *key_load_private(char const   *filename , char const   *passphrase , char **commentp ) 
{ Key *pub ;
  Key *prv ;
  int fd ;
  int tmp ;

  {
#line 543
  fd = open(filename, 0);
#line 544
  if (fd < 0) {
#line 545
    return ((Key *)((void *)0));
  }
#line 546
  tmp = key_perm_ok(fd, filename);
#line 546
  if (! tmp) {
#line 547
    error("bad permissions: ignore key: %s", filename);
#line 548
    close(fd);
#line 549
    return ((Key *)((void *)0));
  }
#line 551
  pub = key_load_public_rsa1(fd, filename, commentp);
#line 552
  lseek(fd, 0LL, 0);
#line 553
  if ((unsigned int )pub == (unsigned int )((void *)0)) {
#line 555
    prv = key_load_private_pem(fd, 3, passphrase, (char **)((void *)0));
#line 557
    if (commentp) {
#line 557
      if (prv) {
#line 558
        *commentp = xstrdup(filename);
      }
    }
  } else {
#line 561
    key_free(pub);
#line 563
    prv = key_load_private_rsa1(fd, filename, passphrase, (char **)((void *)0));
  }
#line 565
  return (prv);
}
}
#line 568 "authfile.c"
static int key_try_load_public(Key *k , char const   *filename , char **commentp ) 
{ FILE *f ;
  char line[4096] ;
  char *cp ;
  int tmp ;
  char *tmp___0 ;

  {
#line 575
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 576
  if ((unsigned int )f != (unsigned int )((void *)0)) {
#line 577
    while (1) {
#line 577
      tmp___0 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 577
      if (! tmp___0) {
#line 577
        break;
      }
#line 578
      line[sizeof(line) - 1U] = (char )'\000';
#line 579
      cp = line;
#line 580
      switch ((int )*cp) {
      case 35: 
      case 10: 
      case 0: 
#line 584
      continue;
      }
#line 587
      while (1) {
#line 587
        if (*cp) {
#line 587
          if (! ((int )*cp == 32)) {
#line 587
            if (! ((int )*cp == 9)) {
#line 587
              break;
            }
          }
        } else {
#line 587
          break;
        }
#line 587
        cp ++;
      }
#line 589
      if (*cp) {
#line 590
        tmp = key_read(k, & cp);
#line 590
        if (tmp == 1) {
#line 591
          if (commentp) {
#line 592
            *commentp = xstrdup(filename);
          }
#line 593
          fclose(f);
#line 594
          return (1);
        }
      }
    }
#line 598
    fclose(f);
  }
#line 600
  return (0);
}
}
#line 604 "authfile.c"
Key *key_load_public(char const   *filename , char **commentp ) 
{ Key *pub ;
  char file[4096] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 610
  pub = key_load_public_type(0, filename, commentp);
#line 611
  if ((unsigned int )pub != (unsigned int )((void *)0)) {
#line 612
    return (pub);
  }
#line 613
  pub = key_new(3);
#line 614
  tmp = key_try_load_public(pub, filename, commentp);
#line 614
  if (tmp == 1) {
#line 615
    return (pub);
  }
#line 616
  tmp___0 = strlcpy(file, filename, sizeof(file));
#line 616
  if (tmp___0 < sizeof(file)) {
#line 616
    tmp___1 = strlcat(file, ".pub", sizeof(file));
#line 616
    if (tmp___1 < sizeof(file)) {
#line 616
      tmp___2 = key_try_load_public(pub, (char const   *)(file), commentp);
#line 616
      if (tmp___2 == 1) {
#line 619
        return (pub);
      }
    }
  }
#line 620
  key_free(pub);
#line 621
  return ((Key *)((void *)0));
}
}
#line 1 "bufaux.o"
#line 412 "/usr/include/openssl/bn.h"
extern BIGNUM *BN_bin2bn(unsigned char const   *s , int len , BIGNUM *ret ) ;
#line 413
extern int BN_bn2bin(BIGNUM const   *a , unsigned char *to ) ;
#line 36 "buffer.h"
void buffer_get(Buffer *buffer , void *buf___1 , u_int len ) ;
#line 38
void buffer_consume(Buffer *buffer , u_int bytes ) ;
#line 24 "bufaux.h"
void buffer_get_bignum2(Buffer *buffer , BIGNUM *value ) ;
#line 26
u_short buffer_get_short(Buffer *buffer ) ;
#line 27
void buffer_put_short(Buffer *buffer , u_short value ) ;
#line 33
u_int64_t buffer_get_int64(Buffer *buffer ) ;
#line 34
void buffer_put_int64(Buffer *buffer , u_int64_t value ) ;
#line 52 "bufaux.c"
void buffer_put_bignum(Buffer *buffer , BIGNUM *value ) 
{ int bits ;
  int tmp ;
  int bin_size ;
  u_char *buf___1 ;
  void *tmp___0 ;
  int oi ;
  char msg[2] ;

  {
#line 55
  tmp = BN_num_bits((BIGNUM const   *)value);
#line 55
  bits = tmp;
#line 56
  bin_size = (bits + 7) / 8;
#line 57
  tmp___0 = xmalloc((unsigned int )bin_size);
#line 57
  buf___1 = (u_char *)tmp___0;
#line 62
  oi = BN_bn2bin((BIGNUM const   *)value, buf___1);
#line 63
  if (oi != bin_size) {
#line 64
    fatal("buffer_put_bignum: BN_bn2bin() failed: oi %d != bin_size %d", oi, bin_size);
  }
#line 68
  while (1) {
#line 68
    msg[0] = (char )(bits >> 8);
#line 68
    msg[1] = (char )bits;
#line 68
    break;
  }
#line 69
  buffer_append(buffer, (void const   *)(msg), 2U);
#line 71
  buffer_append(buffer, (void const   *)((char *)buf___1), (unsigned int )oi);
#line 73
  memset((void *)buf___1, 0, (unsigned int )bin_size);
#line 74
  xfree((void *)buf___1);
#line 75
  return;
}
}
#line 80 "bufaux.c"
void buffer_get_bignum(Buffer *buffer , BIGNUM *value ) 
{ int bits ;
  int bytes ;
  u_char buf___1[2] ;
  u_char *bin ;
  u_int tmp ;
  void *tmp___0 ;

  {
#line 87
  buffer_get(buffer, (void *)((char *)(buf___1)), 2U);
#line 88
  bits = (int )(((unsigned long )buf___1[0] << 8) | (unsigned long )buf___1[1]);
#line 90
  bytes = (bits + 7) / 8;
#line 91
  if (bytes > 8192) {
#line 92
    fatal("buffer_get_bignum: cannot handle BN of size %d", bytes);
  }
#line 93
  tmp = buffer_len(buffer);
#line 93
  if (tmp < (u_int )bytes) {
#line 94
    fatal("buffer_get_bignum: input buffer too small");
  }
#line 95
  tmp___0 = buffer_ptr(buffer);
#line 95
  bin = (u_char *)tmp___0;
#line 96
  BN_bin2bn((unsigned char const   *)bin, bytes, value);
#line 97
  buffer_consume(buffer, (unsigned int )bytes);
#line 98
  return;
}
}
#line 103 "bufaux.c"
void buffer_put_bignum2(Buffer *buffer , BIGNUM *value ) 
{ int bytes ;
  int tmp ;
  u_char *buf___1 ;
  void *tmp___0 ;
  int oi ;
  int hasnohigh ;
  int i ;
  int carry ;
  u_char *uc ;
  int tmp___1 ;

  {
#line 106
  tmp = BN_num_bits((BIGNUM const   *)value);
#line 106
  bytes = (tmp + 7) / 8 + 1;
#line 107
  tmp___0 = xmalloc((unsigned int )bytes);
#line 107
  buf___1 = (u_char *)tmp___0;
#line 109
  hasnohigh = 0;
#line 111
  *(buf___1 + 0) = (unsigned char )'\000';
#line 113
  oi = BN_bn2bin((BIGNUM const   *)value, buf___1 + 1);
#line 114
  if (oi != bytes - 1) {
#line 115
    fatal("buffer_put_bignum: BN_bn2bin() failed: oi %d != bin_size %d", oi, bytes);
  }
#line 117
  if ((int )*(buf___1 + 1) & 128) {
#line 117
    hasnohigh = 0;
  } else {
#line 117
    hasnohigh = 1;
  }
#line 118
  if (value->neg) {
#line 121
    uc = buf___1;
#line 122
    log("negativ!");
#line 123
    i = bytes - 1;
#line 123
    carry = 1;
#line 123
    while (i >= 0) {
#line 124
      *(uc + i) = (unsigned char )((int )*(uc + i) ^ 255);
#line 125
      if (carry) {
#line 126
        *(uc + i) = (u_char )((int )*(uc + i) + 1);
#line 126
        if (*(uc + i)) {
#line 126
          tmp___1 = 0;
        } else {
#line 126
          tmp___1 = 1;
        }
#line 126
        carry = tmp___1;
      }
#line 123
      i --;
    }
  }
#line 129
  buffer_put_string(buffer, (void const   *)(buf___1 + hasnohigh), (unsigned int )(bytes - hasnohigh));
#line 130
  memset((void *)buf___1, 0, (unsigned int )bytes);
#line 131
  xfree((void *)buf___1);
#line 132
  return;
}
}
#line 135 "bufaux.c"
void buffer_get_bignum2(Buffer *buffer , BIGNUM *value ) 
{ u_int len ;
  u_char *bin ;
  void *tmp ;

  {
#line 139
  tmp = buffer_get_string(buffer, & len);
#line 139
  bin = (u_char *)tmp;
#line 141
  if (len > 8192U) {
#line 142
    fatal("buffer_get_bignum2: cannot handle BN of size %d", len);
  }
#line 143
  BN_bin2bn((unsigned char const   *)bin, (int )len, value);
#line 144
  xfree((void *)bin);
#line 145
  return;
}
}
#line 150 "bufaux.c"
u_short buffer_get_short(Buffer *buffer ) 
{ u_char buf___1[2] ;

  {
#line 155
  buffer_get(buffer, (void *)((char *)(buf___1)), 2U);
#line 156
  return ((unsigned short )(((unsigned long )buf___1[0] << 8) | (unsigned long )buf___1[1]));
}
}
#line 159 "bufaux.c"
u_int buffer_get_int(Buffer *buffer ) 
{ u_char buf___1[4] ;

  {
#line 164
  buffer_get(buffer, (void *)((char *)(buf___1)), 4U);
#line 165
  return ((unsigned int )(((((unsigned long )buf___1[0] << 24) | ((unsigned long )buf___1[1] << 16)) | ((unsigned long )buf___1[2] << 8)) | (unsigned long )buf___1[3]));
}
}
#line 169 "bufaux.c"
u_int64_t buffer_get_int64(Buffer *buffer ) 
{ u_char buf___1[8] ;

  {
#line 174
  buffer_get(buffer, (void *)((char *)(buf___1)), 8U);
#line 175
  return (((((((((unsigned long long )buf___1[0] << 56) | ((unsigned long long )buf___1[1] << 48)) | ((unsigned long long )buf___1[2] << 40)) | ((unsigned long long )buf___1[3] << 32)) | ((unsigned long long )buf___1[4] << 24)) | ((unsigned long long )buf___1[5] << 16)) | ((unsigned long long )buf___1[6] << 8)) | (unsigned long long )buf___1[7]);
}
}
#line 182 "bufaux.c"
void buffer_put_short(Buffer *buffer , u_short value ) 
{ char buf___1[2] ;

  {
#line 187
  while (1) {
#line 187
    buf___1[0] = (char )((int )value >> 8);
#line 187
    buf___1[1] = (char )value;
#line 187
    break;
  }
#line 188
  buffer_append(buffer, (void const   *)(buf___1), 2U);
#line 189
  return;
}
}
#line 191 "bufaux.c"
void buffer_put_int(Buffer *buffer , u_int value ) 
{ char buf___1[4] ;

  {
#line 196
  while (1) {
#line 196
    buf___1[0] = (char )(value >> 24);
#line 196
    buf___1[1] = (char )(value >> 16);
#line 196
    buf___1[2] = (char )(value >> 8);
#line 196
    buf___1[3] = (char )value;
#line 196
    break;
  }
#line 197
  buffer_append(buffer, (void const   *)(buf___1), 4U);
#line 198
  return;
}
}
#line 201 "bufaux.c"
void buffer_put_int64(Buffer *buffer , u_int64_t value ) 
{ char buf___1[8] ;

  {
#line 206
  while (1) {
#line 206
    buf___1[0] = (char )(value >> 56);
#line 206
    buf___1[1] = (char )(value >> 48);
#line 206
    buf___1[2] = (char )(value >> 40);
#line 206
    buf___1[3] = (char )(value >> 32);
#line 206
    buf___1[4] = (char )(value >> 24);
#line 206
    buf___1[5] = (char )(value >> 16);
#line 206
    buf___1[6] = (char )(value >> 8);
#line 206
    buf___1[7] = (char )value;
#line 206
    break;
  }
#line 207
  buffer_append(buffer, (void const   *)(buf___1), 8U);
#line 208
  return;
}
}
#line 219 "bufaux.c"
void *buffer_get_string(Buffer *buffer , u_int *length_ptr ) 
{ u_char *value ;
  u_int len ;
  void *tmp ;

  {
#line 226
  len = buffer_get_int(buffer);
#line 227
  if (len > 262144U) {
#line 228
    fatal("buffer_get_string: bad string length %d", len);
  }
#line 230
  tmp = xmalloc(len + 1U);
#line 230
  value = (u_char *)tmp;
#line 232
  buffer_get(buffer, (void *)value, len);
#line 234
  *(value + len) = (unsigned char)0;
#line 236
  if (length_ptr) {
#line 237
    *length_ptr = len;
  }
#line 238
  return ((void *)value);
}
}
#line 244 "bufaux.c"
void buffer_put_string(Buffer *buffer , void const   *buf___1 , u_int len ) 
{ 

  {
#line 247
  buffer_put_int(buffer, len);
#line 248
  buffer_append(buffer, buf___1, len);
#line 249
  return;
}
}
#line 250 "bufaux.c"
void buffer_put_cstring(Buffer *buffer , char const   *s ) 
{ size_t tmp ;

  {
#line 253
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 254
    fatal("buffer_put_cstring: s == NULL");
  }
#line 255
  tmp = strlen(s);
#line 255
  buffer_put_string(buffer, (void const   *)s, tmp);
#line 256
  return;
}
}
#line 261 "bufaux.c"
int buffer_get_char(Buffer *buffer ) 
{ char ch ;

  {
#line 266
  buffer_get(buffer, (void *)(& ch), 1U);
#line 267
  return ((int )((unsigned char )ch));
}
}
#line 273 "bufaux.c"
void buffer_put_char(Buffer *buffer , int value ) 
{ char ch ;

  {
#line 276
  ch = (char )value;
#line 278
  buffer_append(buffer, (void const   *)(& ch), 1U);
#line 279
  return;
}
}
#line 1 "buffer.o"
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 23 "xmalloc.h"
void *xrealloc(void *ptr , size_t new_size ) ;
#line 39 "buffer.h"
void buffer_consume_end(Buffer *buffer , u_int bytes ) ;
#line 41
void buffer_dump(Buffer *buffer ) ;
#line 23 "buffer.c"
void buffer_init(Buffer *buffer ) 
{ void *tmp ;

  {
#line 26
  buffer->alloc = 4096U;
#line 27
  tmp = xmalloc(buffer->alloc);
#line 27
  buffer->buf = (u_char *)tmp;
#line 28
  buffer->offset = 0U;
#line 29
  buffer->end = 0U;
#line 30
  return;
}
}
#line 34 "buffer.c"
void buffer_free(Buffer *buffer ) 
{ 

  {
#line 37
  memset((void *)buffer->buf, 0, buffer->alloc);
#line 38
  xfree((void *)buffer->buf);
#line 39
  return;
}
}
#line 46 "buffer.c"
void buffer_clear(Buffer *buffer ) 
{ 

  {
#line 49
  buffer->offset = 0U;
#line 50
  buffer->end = 0U;
#line 51
  return;
}
}
#line 55 "buffer.c"
void buffer_append(Buffer *buffer , void const   *data , u_int len ) 
{ void *p ;

  {
#line 59
  p = buffer_append_space(buffer, len);
#line 60
  memcpy((void * __restrict  )p, (void const   * __restrict  )data, len);
#line 61
  return;
}
}
#line 69 "buffer.c"
void *buffer_append_space(Buffer *buffer , u_int len ) 
{ void *p ;
  void *tmp ;

  {
#line 74
  if (len > 1048576U) {
#line 75
    fatal("buffer_append_space: len %u not supported", len);
  }
#line 78
  if (buffer->offset == buffer->end) {
#line 79
    buffer->offset = 0U;
#line 80
    buffer->end = 0U;
  }
  restart: 
#line 84
  if (buffer->end + len < buffer->alloc) {
#line 85
    p = (void *)(buffer->buf + buffer->end);
#line 86
    buffer->end += len;
#line 87
    return (p);
  }
#line 93
  if (buffer->offset > buffer->alloc / 2U) {
#line 94
    memmove((void *)buffer->buf, (void const   *)(buffer->buf + buffer->offset), buffer->end - buffer->offset);
#line 96
    buffer->end -= buffer->offset;
#line 97
    buffer->offset = 0U;
    goto restart;
  }
#line 101
  buffer->alloc += len + 32768U;
#line 102
  if (buffer->alloc > 10485760U) {
#line 103
    fatal("buffer_append_space: alloc %u not supported", buffer->alloc);
  }
#line 105
  tmp = xrealloc((void *)buffer->buf, buffer->alloc);
#line 105
  buffer->buf = (u_char *)tmp;
  goto restart;
}
}
#line 112 "buffer.c"
u_int buffer_len(Buffer *buffer ) 
{ 

  {
#line 115
  return (buffer->end - buffer->offset);
}
}
#line 120 "buffer.c"
void buffer_get(Buffer *buffer , void *buf___1 , u_int len ) 
{ 

  {
#line 123
  if (len > buffer->end - buffer->offset) {
#line 124
    fatal("buffer_get: trying to get more bytes %d than in buffer %d", len, buffer->end - buffer->offset);
  }
#line 126
  memcpy((void * __restrict  )buf___1, (void const   * __restrict  )(buffer->buf + buffer->offset),
         len);
#line 127
  buffer->offset += len;
#line 128
  return;
}
}
#line 132 "buffer.c"
void buffer_consume(Buffer *buffer , u_int bytes ) 
{ 

  {
#line 135
  if (bytes > buffer->end - buffer->offset) {
#line 136
    fatal("buffer_consume: trying to get more bytes than in buffer");
  }
#line 137
  buffer->offset += bytes;
#line 138
  return;
}
}
#line 142 "buffer.c"
void buffer_consume_end(Buffer *buffer , u_int bytes ) 
{ 

  {
#line 145
  if (bytes > buffer->end - buffer->offset) {
#line 146
    fatal("buffer_consume_end: trying to get more bytes than in buffer");
  }
#line 147
  buffer->end -= bytes;
#line 148
  return;
}
}
#line 152 "buffer.c"
void *buffer_ptr(Buffer *buffer ) 
{ 

  {
#line 155
  return ((void *)(buffer->buf + buffer->offset));
}
}
#line 160 "buffer.c"
void buffer_dump(Buffer *buffer ) 
{ int i ;
  u_char *ucp ;

  {
#line 164
  ucp = buffer->buf;
#line 166
  i = (int )buffer->offset;
#line 166
  while ((u_int )i < buffer->end) {
#line 167
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%02x", *(ucp + i));
#line 168
    if (((u_int )i - buffer->offset) % 16U == 15U) {
#line 169
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\r\n");
    } else {
#line 170
      if (((u_int )i - buffer->offset) % 2U == 1U) {
#line 171
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" ");
      }
    }
#line 166
    i ++;
  }
#line 173
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\r\n");
#line 174
  return;
}
}
#line 1 "canohost.o"
#line 357 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 116 "/usr/include/ctype.h"
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 290
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   * __restrict  __nptr ,
                                                            char ** __restrict  __endptr ,
                                                            int __base , int __group )  __attribute__((__nonnull__(1))) ;
#line 332
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 332 "/usr/include/stdlib.h"
__inline static long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                            int __base ) 
{ long tmp ;

  {
#line 336
  tmp = __strtol_internal(__nptr, __endptr, __base, 0);
#line 336
  return (tmp);
}
}
#line 401
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 401 "/usr/include/stdlib.h"
__inline static int atoi(char const   *__nptr ) 
{ long tmp ;

  {
#line 404
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 404
  return ((int )tmp);
}
}
#line 128 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int getpeername(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 185
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
#line 352 "/usr/include/netdb.h"
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 631
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 637
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
#line 646
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , unsigned int __flags ) ;
#line 23 "packet.h"
int packet_get_connection_in(void) ;
#line 57
void ( /* format attribute */  packet_disconnect)(char const   *fmt  , ...) ;
#line 75
int packet_connection_is_on_socket(void) ;
#line 64 "log.h"
void fatal_cleanup(void) ;
#line 15 "canohost.h"
char const   *get_canonical_hostname(int verify_reverse_mapping ) ;
#line 16
char const   *get_remote_ipaddr(void) ;
#line 17
char const   *get_remote_name_or_ip(u_int utmp_len___0 , int verify_reverse_mapping ) ;
#line 19
char *get_peer_ipaddr(int socket___0 ) ;
#line 20
int get_peer_port(int sock ) ;
#line 21
char *get_local_ipaddr(int socket___0 ) ;
#line 22
char *get_local_name(int socket___0 ) ;
#line 24
int get_remote_port(void) ;
#line 25
int get_local_port(void) ;
#line 22 "canohost.c"
static void check_ip_options(int socket___0 , char *ipaddr ) ;
#line 29 "canohost.c"
static char *get_remote_hostname(int socket___0 , int verify_reverse_mapping ) 
{ struct sockaddr_storage from ;
  int i ;
  socklen_t fromlen ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char name[1025] ;
  char ntop[1025] ;
  char ntop2[1025] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  struct sockaddr_in6 *from6 ;
  struct sockaddr_in *from4 ;
  struct in_addr addr ;
  u_int16_t port ;
  register unsigned int __v ;
  register unsigned int __x ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int __res ;
  __int32_t const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;

  {
#line 39
  fromlen = sizeof(from);
#line 40
  memset((void *)(& from), 0, sizeof(from));
#line 41
  tmp___1 = getpeername(socket___0, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                        (socklen_t * __restrict  )(& fromlen));
#line 41
  if (tmp___1 < 0) {
#line 42
    tmp = __errno_location();
#line 42
    tmp___0 = strerror(*tmp);
#line 42
    debug("getpeername failed: %.100s", tmp___0);
#line 43
    fatal_cleanup();
  }
#line 46
  if ((int )from.ss_family == 10) {
#line 47
    from6 = (struct sockaddr_in6 *)(& from);
#line 51
    if (*((uint32_t const   *)(& from6->sin6_addr) + 0) == 0U) {
#line 51
      if (*((uint32_t const   *)(& from6->sin6_addr) + 1) == 0U) {
#line 51
        __x = 65535U;
#line 51
        __asm__  ("rorw $8, %w0;"
                  "rorl $16, %0;"
                  "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 51
        if (*((uint32_t const   *)(& from6->sin6_addr) + 2) == (uint32_t const   )__v) {
#line 52
          from4 = (struct sockaddr_in *)(& from);
#line 56
          memcpy((void * __restrict  )(& addr), (void const   * __restrict  )((char *)(& from6->sin6_addr) + 12),
                 sizeof(addr));
#line 57
          port = from6->sin6_port;
#line 59
          memset((void *)(& from), 0, sizeof(from));
#line 61
          from4->sin_family = (unsigned short)2;
#line 62
          memcpy((void * __restrict  )(& from4->sin_addr), (void const   * __restrict  )(& addr),
                 sizeof(addr));
#line 63
          from4->sin_port = port;
        }
      }
    }
  }
#line 68
  tmp___2 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )((void *)0),
                        0U, 1U);
#line 68
  if (tmp___2 != 0) {
#line 70
    fatal("get_remote_hostname: getnameinfo NI_NUMERICHOST failed");
  }
#line 72
  if ((int )from.ss_family == 2) {
#line 73
    check_ip_options(socket___0, ntop);
  }
#line 75
  debug3("Trying to reverse map address %.100s.", ntop);
#line 77
  tmp___4 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )(name), sizeof(name), (char * __restrict  )((void *)0),
                        0U, 8U);
#line 77
  if (tmp___4 != 0) {
#line 80
    log("Could not reverse map address %.100s.", ntop);
#line 81
    tmp___3 = xstrdup((char const   *)(ntop));
#line 81
    return (tmp___3);
  }
#line 85
  name[sizeof(name) - 1U] = (char )'\000';
#line 90
  i = 0;
#line 90
  while (name[i]) {
#line 91
    tmp___8 = __ctype_b_loc();
#line 91
    if ((int const   )*(*tmp___8 + (int )name[i]) & 256) {
#line 92
      if (sizeof(name[i]) > 1U) {
#line 92
        __res = tolower((int )name[i]);
      } else {
#line 92
        tmp___7 = __ctype_tolower_loc();
#line 92
        __res = (int )*(*tmp___7 + (int )name[i]);
      }
#line 92
      name[i] = (char )__res;
    }
#line 90
    i ++;
  }
#line 94
  if (! verify_reverse_mapping) {
#line 95
    tmp___9 = xstrdup((char const   *)(name));
#line 95
    return (tmp___9);
  }
#line 105
  memset((void *)(& hints), 0, sizeof(hints));
#line 106
  hints.ai_family = (int )from.ss_family;
#line 107
  hints.ai_socktype = 1;
#line 108
  tmp___11 = getaddrinfo((char const   * __restrict  )(name), (char const   * __restrict  )((void *)0),
                         (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 108
  if (tmp___11 != 0) {
#line 109
    log("reverse mapping checking getaddrinfo for %.700s failed - POSSIBLE BREAKIN ATTEMPT!",
        name);
#line 111
    tmp___10 = xstrdup((char const   *)(ntop));
#line 111
    return (tmp___10);
  }
#line 114
  ai = aitop;
#line 114
  while (ai) {
#line 115
    tmp___12 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                           (char * __restrict  )(ntop2), sizeof(ntop2), (char * __restrict  )((void *)0),
                           0U, 1U);
#line 117
    if (tmp___12 == 0) {
#line 117
      if (0) {
#line 117
        __s1_len = strlen((char const   *)(ntop));
#line 117
        __s2_len = strlen((char const   *)(ntop2));
#line 117
        if (! ((unsigned int )((void const   *)(ntop + 1)) - (unsigned int )((void const   *)(ntop)) == 1U)) {
          goto _L___0;
        } else {
#line 117
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 117
            if (! ((unsigned int )((void const   *)(ntop2 + 1)) - (unsigned int )((void const   *)(ntop2)) == 1U)) {
#line 117
              tmp___22 = 1;
            } else {
#line 117
              if (__s2_len >= 4U) {
#line 117
                tmp___22 = 1;
              } else {
#line 117
                tmp___22 = 0;
              }
            }
          } else {
#line 117
            tmp___22 = 0;
          }
        }
#line 117
        if (tmp___22) {
#line 117
          tmp___18 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
        } else {
#line 117
          tmp___21 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
#line 117
          tmp___18 = tmp___21;
        }
      } else {
#line 117
        tmp___21 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
#line 117
        tmp___18 = tmp___21;
      }
#line 117
      if (tmp___18 == 0) {
#line 118
        break;
      }
    }
#line 114
    ai = ai->ai_next;
  }
#line 120
  freeaddrinfo(aitop);
#line 122
  if (! ai) {
#line 124
    log("Address %.100s maps to %.600s, but this does not map back to the address - POSSIBLE BREAKIN ATTEMPT!",
        ntop, name);
#line 127
    tmp___23 = xstrdup((char const   *)(ntop));
#line 127
    return (tmp___23);
  }
#line 129
  tmp___24 = xstrdup((char const   *)(name));
#line 129
  return (tmp___24);
}
}
#line 144 "canohost.c"
static void check_ip_options(int socket___0 , char *ipaddr ) 
{ u_char options___0[200] ;
  char text[sizeof(options___0) * 3U + 1U] ;
  socklen_t option_size ;
  int i ;
  int ipproto ;
  struct protoent *ip ;
  int tmp ;

  {
#line 153
  ip = getprotobyname("ip");
#line 153
  if ((unsigned int )ip != (unsigned int )((void *)0)) {
#line 154
    ipproto = ip->p_proto;
  } else {
#line 156
    ipproto = 0;
  }
#line 157
  option_size = sizeof(options___0);
#line 158
  tmp = getsockopt(socket___0, ipproto, 4, (void * __restrict  )(options___0), (socklen_t * __restrict  )(& option_size));
#line 158
  if (tmp >= 0) {
#line 158
    if (option_size != 0U) {
#line 160
      text[0] = (char )'\000';
#line 161
      i = 0;
#line 161
      while ((socklen_t )i < option_size) {
#line 162
        snprintf((char * __restrict  )(text + i * 3), sizeof(text) - (unsigned int )(i * 3),
                 (char const   * __restrict  )" %2.2x", options___0[i]);
#line 161
        i ++;
      }
#line 164
      log("Connection from %.100s with IP options:%.800s", ipaddr, text);
#line 166
      packet_disconnect("Connection from %.100s with IP options:%.800s", ipaddr, text);
    }
  }
#line 169
  return;
}
}
#line 180 "canohost.c"
static char *canonical_host_name  =    (char *)((void *)0);
#line 181 "canohost.c"
static int verify_reverse_mapping_done  =    0;
#line 177 "canohost.c"
char const   *get_canonical_hostname(int verify_reverse_mapping ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 184
  if ((unsigned int )canonical_host_name != (unsigned int )((void *)0)) {
#line 185
    if (verify_reverse_mapping_done != verify_reverse_mapping) {
#line 186
      xfree((void *)canonical_host_name);
    } else {
#line 188
      return ((char const   *)canonical_host_name);
    }
  }
#line 192
  tmp___0 = packet_connection_is_on_socket();
#line 192
  if (tmp___0) {
#line 193
    tmp = packet_get_connection_in();
#line 193
    canonical_host_name = get_remote_hostname(tmp, verify_reverse_mapping);
  } else {
#line 196
    canonical_host_name = xstrdup("UNKNOWN");
  }
#line 198
  verify_reverse_mapping_done = verify_reverse_mapping;
#line 199
  return ((char const   *)canonical_host_name);
}
}
#line 206 "canohost.c"
static char *get_socket_address(int socket___0 , int remote___0 , int flags ) 
{ struct sockaddr_storage addr ;
  socklen_t addrlen ;
  char ntop[1025] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
#line 214
  addrlen = sizeof(addr);
#line 215
  memset((void *)(& addr), 0, sizeof(addr));
#line 217
  if (remote___0) {
#line 218
    tmp___1 = getpeername(socket___0, (struct sockaddr * __restrict  )((struct sockaddr *)(& addr)),
                          (socklen_t * __restrict  )(& addrlen));
#line 218
    if (tmp___1 < 0) {
#line 220
      tmp = __errno_location();
#line 220
      tmp___0 = strerror(*tmp);
#line 220
      debug("get_socket_ipaddr: getpeername failed: %.100s", tmp___0);
#line 222
      return ((char *)((void *)0));
    }
  } else {
#line 225
    tmp___4 = getsockname(socket___0, (struct sockaddr * __restrict  )((struct sockaddr *)(& addr)),
                          (socklen_t * __restrict  )(& addrlen));
#line 225
    if (tmp___4 < 0) {
#line 227
      tmp___2 = __errno_location();
#line 227
      tmp___3 = strerror(*tmp___2);
#line 227
      debug("get_socket_ipaddr: getsockname failed: %.100s", tmp___3);
#line 229
      return ((char *)((void *)0));
    }
  }
#line 233
  tmp___5 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& addr)),
                        addrlen, (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )((void *)0),
                        0U, (unsigned int )flags);
#line 233
  if (tmp___5 != 0) {
#line 235
    error("get_socket_ipaddr: getnameinfo %d failed", flags);
#line 236
    return ((char *)((void *)0));
  }
#line 238
  tmp___6 = xstrdup((char const   *)(ntop));
#line 238
  return (tmp___6);
}
}
#line 241 "canohost.c"
char *get_peer_ipaddr(int socket___0 ) 
{ char *tmp ;

  {
#line 244
  tmp = get_socket_address(socket___0, 1, 1);
#line 244
  return (tmp);
}
}
#line 247 "canohost.c"
char *get_local_ipaddr(int socket___0 ) 
{ char *tmp ;

  {
#line 250
  tmp = get_socket_address(socket___0, 0, 1);
#line 250
  return (tmp);
}
}
#line 253 "canohost.c"
char *get_local_name(int socket___0 ) 
{ char *tmp ;

  {
#line 256
  tmp = get_socket_address(socket___0, 0, 8);
#line 256
  return (tmp);
}
}
#line 267 "canohost.c"
static char *canonical_host_ip  =    (char *)((void *)0);
#line 264 "canohost.c"
char const   *get_remote_ipaddr(void) 
{ int tmp ;
  int tmp___0 ;

  {
#line 270
  if ((unsigned int )canonical_host_ip == (unsigned int )((void *)0)) {
#line 271
    tmp___0 = packet_connection_is_on_socket();
#line 271
    if (tmp___0) {
#line 272
      tmp = packet_get_connection_in();
#line 272
      canonical_host_ip = get_peer_ipaddr(tmp);
#line 274
      if ((unsigned int )canonical_host_ip == (unsigned int )((void *)0)) {
#line 275
        fatal_cleanup();
      }
    } else {
#line 278
      canonical_host_ip = xstrdup("UNKNOWN");
    }
  }
#line 281
  return ((char const   *)canonical_host_ip);
}
}
#line 287 "canohost.c"
static char const   *remote  =    "";
#line 284 "canohost.c"
char const   *get_remote_name_or_ip(u_int utmp_len___0 , int verify_reverse_mapping ) 
{ size_t tmp ;

  {
#line 288
  if (utmp_len___0 > 0U) {
#line 289
    remote = get_canonical_hostname(verify_reverse_mapping);
  }
#line 290
  if (utmp_len___0 == 0U) {
#line 291
    remote = get_remote_ipaddr();
  } else {
#line 290
    tmp = strlen(remote);
#line 290
    if (tmp > utmp_len___0) {
#line 291
      remote = get_remote_ipaddr();
    }
  }
#line 292
  return (remote);
}
}
#line 297 "canohost.c"
static int get_sock_port(int sock , int local ) 
{ struct sockaddr_storage from ;
  socklen_t fromlen ;
  char strport[32] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 305
  fromlen = sizeof(from);
#line 306
  memset((void *)(& from), 0, sizeof(from));
#line 307
  if (local) {
#line 308
    tmp___1 = getsockname(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 308
    if (tmp___1 < 0) {
#line 309
      tmp = __errno_location();
#line 309
      tmp___0 = strerror(*tmp);
#line 309
      error("getsockname failed: %.100s", tmp___0);
#line 310
      return (0);
    }
  } else {
#line 313
    tmp___4 = getpeername(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 313
    if (tmp___4 < 0) {
#line 314
      tmp___2 = __errno_location();
#line 314
      tmp___3 = strerror(*tmp___2);
#line 314
      debug("getpeername failed: %.100s", tmp___3);
#line 315
      fatal_cleanup();
    }
  }
#line 319
  tmp___5 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )((void *)0), 0U, (char * __restrict  )(strport),
                        sizeof(strport), 2U);
#line 319
  if (tmp___5 != 0) {
#line 321
    fatal("get_sock_port: getnameinfo NI_NUMERICSERV failed");
  }
#line 322
  tmp___6 = atoi((char const   *)(strport));
#line 322
  return (tmp___6);
}
}
#line 327 "canohost.c"
static int get_port(int local ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 334
  tmp = packet_connection_is_on_socket();
#line 334
  if (! tmp) {
#line 335
    return (65535);
  }
#line 338
  tmp___0 = packet_get_connection_in();
#line 338
  tmp___1 = get_sock_port(tmp___0, local);
#line 338
  return (tmp___1);
}
}
#line 341 "canohost.c"
int get_peer_port(int sock ) 
{ int tmp ;

  {
#line 344
  tmp = get_sock_port(sock, 0);
#line 344
  return (tmp);
}
}
#line 347 "canohost.c"
int get_remote_port(void) 
{ int tmp ;

  {
#line 350
  tmp = get_port(0);
#line 350
  return (tmp);
}
}
#line 353 "canohost.c"
int get_local_port(void) 
{ int tmp ;

  {
#line 356
  tmp = get_port(1);
#line 356
  return (tmp);
}
}
#line 1 "channels.o"
#line 407 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 102 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 170
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 192 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 199
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 209
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 218
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
#line 640 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
#line 745 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 54 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
#line 29 "packet.h"
u_int packet_get_protocol_flags(void) ;
#line 32
int packet_is_interactive(void) ;
#line 34
void packet_start(u_char type ) ;
#line 35
void packet_put_char(int value ) ;
#line 36
void packet_put_int(u_int value ) ;
#line 39
void packet_put_string(void const   *buf___1 , u_int len ) ;
#line 40
void packet_put_cstring(char const   *str ) ;
#line 42
void packet_send(void) ;
#line 44
int packet_read(void) ;
#line 52
u_int packet_get_int(void) ;
#line 56
void *packet_get_string(u_int *length_ptr ) ;
#line 71
void packet_write_wait(void) ;
#line 77
int packet_remaining(void) ;
#line 78
void packet_send_ignore(int nbytes ) ;
#line 84
int max_packet_size ;
#line 59 "log.h"
void ( /* format attribute */  verbose)(char const   *fmt  , ...) ;
#line 61
void ( /* format attribute */  debug2)(char const   *fmt  , ...) ;
#line 65
void fatal_add_cleanup(void (*proc)(void * ) , void *context ) ;
#line 17 "misc.h"
void set_nonblock(int fd ) ;
#line 19
void set_nodelay(int fd ) ;
#line 153 "channels.h"
Channel *channel_lookup(int id ) ;
#line 154
Channel *channel_new(char *ctype , int type , int rfd , int wfd , int efd , u_int window ,
                     u_int maxpack , int extusage , char *remote_name , int nonblock ) ;
#line 155
void channel_set_fds(int id , int rfd , int wfd , int efd , int extusage , int nonblock ,
                     u_int window_max ) ;
#line 156
void channel_free(Channel *c ) ;
#line 157
void channel_free_all(void) ;
#line 158
void channel_stop_listening(void) ;
#line 160
void channel_send_open(int id ) ;
#line 161
void channel_request_start(int local_id , char *service , int wantconfirm ) ;
#line 162
void channel_register_cleanup(int id , channel_callback_fn *fn ) ;
#line 163
void channel_register_confirm(int id , channel_callback_fn *fn ) ;
#line 164
void channel_register_filter(int id , channel_filter_fn *fn ) ;
#line 165
void channel_cancel_cleanup(int id ) ;
#line 166
int channel_close_fd(int *fdp ) ;
#line 170
void channel_input_close(int type , u_int32_t seq , void *ctxt ) ;
#line 171
void channel_input_close_confirmation(int type , u_int32_t seq , void *ctxt ) ;
#line 172
void channel_input_data(int type , u_int32_t seq , void *ctxt ) ;
#line 173
void channel_input_extended_data(int type , u_int32_t seq , void *ctxt ) ;
#line 174
void channel_input_ieof(int type , u_int32_t seq , void *ctxt ) ;
#line 175
void channel_input_oclose(int type , u_int32_t seq , void *ctxt ) ;
#line 176
void channel_input_open_confirmation(int type , u_int32_t seq , void *ctxt ) ;
#line 177
void channel_input_open_failure(int type , u_int32_t seq , void *ctxt ) ;
#line 178
void channel_input_port_open(int type , u_int32_t seq , void *ctxt ) ;
#line 179
void channel_input_window_adjust(int type , u_int32_t seq , void *ctxt ) ;
#line 183
void channel_prepare_select(fd_set **readsetp , fd_set **writesetp , int *maxfdp ,
                            int *nallocp , int rekeying ) ;
#line 184
void channel_after_select(fd_set *readset , fd_set *writeset ) ;
#line 185
void channel_output_poll(void) ;
#line 187
int channel_not_very_much_buffered_data(void) ;
#line 188
void channel_close_all(void) ;
#line 189
int channel_still_open(void) ;
#line 190
char *channel_open_message(void) ;
#line 191
int channel_find_open(void) ;
#line 194
void channel_set_af(int af ) ;
#line 195
void channel_permit_all_opens(void) ;
#line 196
void channel_add_permitted_opens(char *host , int port ) ;
#line 197
void channel_clear_permitted_opens(void) ;
#line 198
void channel_input_port_forward_request(int is_root , int gateway_ports ) ;
#line 199
int channel_connect_to(char const   *host , u_short port ) ;
#line 200
int channel_connect_by_listen_address(u_short listen_port ) ;
#line 201
void channel_request_remote_forwarding(u_short listen_port , char const   *host_to_connect ,
                                       u_short port_to_connect ) ;
#line 202
int channel_setup_local_fwd_listener(u_short listen_port , char const   *host_to_connect ,
                                     u_short port_to_connect , int gateway_ports ) ;
#line 203
int channel_setup_remote_fwd_listener(char const   *listen_address , u_short listen_port ,
                                      int gateway_ports ) ;
#line 207
int x11_connect_display(void) ;
#line 208
int x11_create_display_inet(int x11_display_offset , int x11_use_localhost , int single_connection ,
                            u_int *display_numberp ) ;
#line 209
void x11_input_open(int type , u_int32_t seq , void *ctxt ) ;
#line 210
void x11_request_forwarding_with_spoofing(int client_session_id , char const   *proto ,
                                          char const   *data ) ;
#line 211
void deny_input_open(int type , u_int32_t seq , void *ctxt ) ;
#line 215
void auth_request_forwarding(void) ;
#line 216
void auth_input_open_request(int type , u_int32_t seq , void *ctxt ) ;
#line 220
int chan_is_dead(Channel *c , int send___0 ) ;
#line 221
void chan_mark_dead(Channel *c ) ;
#line 225
void chan_rcvd_oclose(Channel *c ) ;
#line 226
void chan_read_failed(Channel *c ) ;
#line 227
void chan_ibuf_empty(Channel *c ) ;
#line 229
void chan_rcvd_ieof(Channel *c ) ;
#line 230
void chan_write_failed(Channel *c ) ;
#line 231
void chan_obuf_empty(Channel *c ) ;
#line 64 "compat.h"
int compat13 ;
#line 65
int compat20 ;
#line 65 "channels.c"
static Channel **channels  =    (Channel **)((void *)0);
#line 71 "channels.c"
static int channels_alloc  =    0;
#line 77 "channels.c"
static int channel_max_fd  =    0;
#line 95 "channels.c"
static ForwardPermission permitted_opens[100]  ;
#line 98 "channels.c"
static int num_permitted_opens  =    0;
#line 104 "channels.c"
static int all_opens_permitted  =    0;
#line 113 "channels.c"
static char *x11_saved_proto  =    (char *)((void *)0);
#line 116 "channels.c"
static char *x11_saved_data  =    (char *)((void *)0);
#line 117 "channels.c"
static u_int x11_saved_data_len  =    (u_int )0;
#line 123 "channels.c"
static char *x11_fake_data  =    (char *)((void *)0);
#line 124 "channels.c"
static u_int x11_fake_data_len  ;
#line 132 "channels.c"
static int IPv4or6___0  =    0;
#line 135
static void port_open_helper(Channel *c , char *rtype ) ;
#line 139 "channels.c"
Channel *channel_lookup(int id ) 
{ Channel *c ;

  {
#line 144
  if (id < 0) {
#line 145
    log("channel_lookup: %d: bad id", id);
#line 146
    return ((Channel *)((void *)0));
  } else {
#line 144
    if (id >= channels_alloc) {
#line 145
      log("channel_lookup: %d: bad id", id);
#line 146
      return ((Channel *)((void *)0));
    }
  }
#line 148
  c = *(channels + id);
#line 149
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 150
    log("channel_lookup: %d: bad id: channel free", id);
#line 151
    return ((Channel *)((void *)0));
  }
#line 153
  return (c);
}
}
#line 161 "channels.c"
static void channel_register_fds(Channel *c , int rfd , int wfd , int efd , int extusage ,
                                 int nonblock ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 166
  if (channel_max_fd > rfd) {
#line 166
    channel_max_fd = channel_max_fd;
  } else {
#line 166
    channel_max_fd = rfd;
  }
#line 167
  if (channel_max_fd > wfd) {
#line 167
    channel_max_fd = channel_max_fd;
  } else {
#line 167
    channel_max_fd = wfd;
  }
#line 168
  if (channel_max_fd > efd) {
#line 168
    channel_max_fd = channel_max_fd;
  } else {
#line 168
    channel_max_fd = efd;
  }
#line 172
  c->rfd = rfd;
#line 173
  c->wfd = wfd;
#line 174
  if (rfd == wfd) {
#line 174
    c->sock = rfd;
  } else {
#line 174
    c->sock = -1;
  }
#line 175
  c->efd = efd;
#line 176
  c->extended_usage = extusage;
#line 179
  if (nonblock) {
#line 179
    tmp___0 = isatty(c->rfd);
#line 179
    if (tmp___0) {
#line 180
      debug("channel %d: rfd %d isatty", c->self, c->rfd);
#line 181
      c->isatty = 1;
#line 182
      tmp = isatty(c->wfd);
#line 182
      if (! tmp) {
#line 183
        error("channel %d: wfd %d is not a tty?", c->self, c->wfd);
      }
    } else {
#line 187
      c->isatty = 0;
    }
  } else {
#line 187
    c->isatty = 0;
  }
#line 191
  if (nonblock) {
#line 192
    if (rfd != -1) {
#line 193
      set_nonblock(rfd);
    }
#line 194
    if (wfd != -1) {
#line 195
      set_nonblock(wfd);
    }
#line 196
    if (efd != -1) {
#line 197
      set_nonblock(efd);
    }
  }
#line 199
  return;
}
}
#line 206 "channels.c"
Channel *channel_new(char *ctype , int type , int rfd , int wfd , int efd , u_int window ,
                     u_int maxpack , int extusage , char *remote_name , int nonblock ) 
{ int i ;
  int found ;
  Channel *c ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 214
  if (channels_alloc == 0) {
#line 215
    channels_alloc = 10;
#line 216
    tmp = xmalloc((unsigned int )channels_alloc * sizeof(Channel *));
#line 216
    channels = (Channel **)tmp;
#line 217
    i = 0;
#line 217
    while (i < channels_alloc) {
#line 218
      *(channels + i) = (Channel *)((void *)0);
#line 217
      i ++;
    }
#line 219
    fatal_add_cleanup((void (*)(void * ))(& channel_free_all), (void *)0);
  }
#line 222
  found = -1;
#line 222
  i = 0;
#line 222
  while (i < channels_alloc) {
#line 223
    if ((unsigned int )*(channels + i) == (unsigned int )((void *)0)) {
#line 225
      found = i;
#line 226
      break;
    }
#line 222
    i ++;
  }
#line 228
  if (found == -1) {
#line 230
    found = channels_alloc;
#line 231
    channels_alloc += 10;
#line 232
    if (channels_alloc > 10000) {
#line 233
      fatal("channel_new: internal error: channels_alloc %d too big.", channels_alloc);
    }
#line 235
    debug2("channel: expanding %d", channels_alloc);
#line 236
    tmp___0 = xrealloc((void *)channels, (unsigned int )channels_alloc * sizeof(Channel *));
#line 236
    channels = (Channel **)tmp___0;
#line 237
    i = found;
#line 237
    while (i < channels_alloc) {
#line 238
      *(channels + i) = (Channel *)((void *)0);
#line 237
      i ++;
    }
  }
#line 241
  tmp___1 = xmalloc(sizeof(Channel ));
#line 241
  *(channels + found) = (Channel *)tmp___1;
#line 241
  c = *(channels + found);
#line 242
  memset((void *)c, 0, sizeof(Channel ));
#line 243
  buffer_init(& c->input);
#line 244
  buffer_init(& c->output);
#line 245
  buffer_init(& c->extended);
#line 246
  c->ostate = 0U;
#line 247
  c->istate = 0U;
#line 248
  c->flags = 0;
#line 249
  channel_register_fds(c, rfd, wfd, efd, extusage, nonblock);
#line 250
  c->self = found;
#line 251
  c->type = type;
#line 252
  c->ctype = ctype;
#line 253
  c->local_window = window;
#line 254
  c->local_window_max = window;
#line 255
  c->local_consumed = 0U;
#line 256
  c->local_maxpacket = maxpack;
#line 257
  c->remote_id = -1;
#line 258
  c->remote_name = remote_name;
#line 259
  c->remote_window = 0U;
#line 260
  c->remote_maxpacket = 0U;
#line 261
  c->force_drain = 0;
#line 262
  c->single_connection = 0;
#line 263
  c->detach_user = (channel_callback_fn *)((void *)0);
#line 264
  c->confirm = (channel_callback_fn *)((void *)0);
#line 265
  c->input_filter = (channel_filter_fn *)((void *)0);
#line 266
  debug("channel %d: new [%s]", found, remote_name);
#line 267
  return (c);
}
}
#line 270 "channels.c"
static int channel_find_maxfd(void) 
{ int i ;
  int max ;
  Channel *c ;

  {
#line 273
  max = 0;
#line 276
  i = 0;
#line 276
  while (i < channels_alloc) {
#line 277
    c = *(channels + i);
#line 278
    if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 279
      if (max > c->rfd) {
#line 279
        max = max;
      } else {
#line 279
        max = c->rfd;
      }
#line 280
      if (max > c->wfd) {
#line 280
        max = max;
      } else {
#line 280
        max = c->wfd;
      }
#line 281
      if (max > c->efd) {
#line 281
        max = max;
      } else {
#line 281
        max = c->efd;
      }
    }
#line 276
    i ++;
  }
#line 284
  return (max);
}
}
#line 287 "channels.c"
int channel_close_fd(int *fdp ) 
{ int ret ;
  int fd ;

  {
#line 290
  ret = 0;
#line 290
  fd = *fdp;
#line 292
  if (fd != -1) {
#line 293
    ret = close(fd);
#line 294
    *fdp = -1;
#line 295
    if (fd == channel_max_fd) {
#line 296
      channel_max_fd = channel_find_maxfd();
    }
  }
#line 298
  return (ret);
}
}
#line 303 "channels.c"
static void channel_close_fds(Channel *c ) 
{ 

  {
#line 306
  debug3("channel_close_fds: channel %d: r %d w %d e %d", c->self, c->rfd, c->wfd,
         c->efd);
#line 309
  channel_close_fd(& c->sock);
#line 310
  channel_close_fd(& c->rfd);
#line 311
  channel_close_fd(& c->wfd);
#line 312
  channel_close_fd(& c->efd);
#line 313
  return;
}
}
#line 317 "channels.c"
void channel_free(Channel *c ) 
{ char *s ;
  int i ;
  int n___0 ;
  char const   *tmp ;

  {
#line 323
  n___0 = 0;
#line 323
  i = 0;
#line 323
  while (i < channels_alloc) {
#line 324
    if (*(channels + i)) {
#line 325
      n___0 ++;
    }
#line 323
    i ++;
  }
#line 326
  if (c->remote_name) {
#line 326
    tmp = (char const   *)c->remote_name;
  } else {
#line 326
    tmp = "???";
  }
#line 326
  debug("channel_free: channel %d: %s, nchannels %d", c->self, tmp, n___0);
#line 329
  s = channel_open_message();
#line 330
  debug3("channel_free: status: %s", s);
#line 331
  xfree((void *)s);
#line 333
  if (c->sock != -1) {
#line 334
    shutdown(c->sock, 2);
  }
#line 335
  channel_close_fds(c);
#line 336
  buffer_free(& c->input);
#line 337
  buffer_free(& c->output);
#line 338
  buffer_free(& c->extended);
#line 339
  if (c->remote_name) {
#line 340
    xfree((void *)c->remote_name);
#line 341
    c->remote_name = (char *)((void *)0);
  }
#line 343
  *(channels + c->self) = (Channel *)((void *)0);
#line 344
  xfree((void *)c);
#line 345
  return;
}
}
#line 347 "channels.c"
void channel_free_all(void) 
{ int i ;

  {
#line 352
  i = 0;
#line 352
  while (i < channels_alloc) {
#line 353
    if ((unsigned int )*(channels + i) != (unsigned int )((void *)0)) {
#line 354
      channel_free(*(channels + i));
    }
#line 352
    i ++;
  }
#line 355
  return;
}
}
#line 362 "channels.c"
void channel_close_all(void) 
{ int i ;

  {
#line 367
  i = 0;
#line 367
  while (i < channels_alloc) {
#line 368
    if ((unsigned int )*(channels + i) != (unsigned int )((void *)0)) {
#line 369
      channel_close_fds(*(channels + i));
    }
#line 367
    i ++;
  }
#line 370
  return;
}
}
#line 376 "channels.c"
void channel_stop_listening(void) 
{ int i ;
  Channel *c ;

  {
#line 382
  i = 0;
#line 382
  while (i < channels_alloc) {
#line 383
    c = *(channels + i);
#line 384
    if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 385
      switch (c->type) {
      case 6: 
      case 2: 
      case 11: 
      case 1: 
#line 390
      channel_close_fd(& c->sock);
#line 391
      channel_free(c);
#line 392
      break;
      }
    }
#line 382
    i ++;
  }
#line 396
  return;
}
}
#line 403 "channels.c"
int channel_not_very_much_buffered_data(void) 
{ u_int i ;
  Channel *c ;
  u_int tmp ;
  u_int tmp___0 ;

  {
#line 409
  i = 0U;
#line 409
  while (i < (u_int )channels_alloc) {
#line 410
    c = *(channels + i);
#line 411
    if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 411
      if (c->type == 4) {
#line 420
        tmp___0 = buffer_len(& c->output);
#line 420
        if (tmp___0 > (u_int )max_packet_size) {
#line 421
          tmp = buffer_len(& c->output);
#line 421
          debug("channel %d: big output buffer %d > %d", c->self, tmp, max_packet_size);
#line 424
          return (0);
        }
      }
    }
#line 409
    i ++;
  }
#line 428
  return (1);
}
}
#line 433 "channels.c"
int channel_still_open(void) 
{ int i ;
  Channel *c ;

  {
#line 439
  i = 0;
#line 439
  while (i < channels_alloc) {
#line 440
    c = *(channels + i);
#line 441
    if ((unsigned int )c == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 443
    switch (c->type) {
    case 1: 
    case 2: 
    case 11: 
    case 5: 
    case 6: 
    case 13: 
    case 12: 
    case 14: 
    goto __Cont;
    case 10: 
#line 454
    if (! compat20) {
#line 455
      fatal("cannot happen: SSH_CHANNEL_LARVAL");
    }
    goto __Cont;
    case 3: 
    case 4: 
    case 7: 
#line 460
    return (1);
    case 8: 
    case 9: 
#line 463
    if (! compat13) {
#line 464
      fatal("cannot happen: OUT_DRAIN");
    }
#line 465
    return (1);
    default: 
#line 467
    fatal("channel_still_open: bad channel type %d", c->type);
    }
    __Cont: /* CIL Label */ 
#line 439
    i ++;
  }
#line 471
  return (0);
}
}
#line 476 "channels.c"
int channel_find_open(void) 
{ int i ;
  Channel *c ;

  {
#line 482
  i = 0;
#line 482
  while (i < channels_alloc) {
#line 483
    c = *(channels + i);
#line 484
    if ((unsigned int )c == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 486
    switch (c->type) {
    case 5: 
    case 13: 
    case 1: 
    case 2: 
    case 11: 
    case 3: 
    case 12: 
    case 14: 
    goto __Cont;
    case 10: 
    case 6: 
    case 4: 
    case 7: 
#line 500
    return (i);
    case 8: 
    case 9: 
#line 503
    if (! compat13) {
#line 504
      fatal("cannot happen: OUT_DRAIN");
    }
#line 505
    return (i);
    default: 
#line 507
    fatal("channel_find_open: bad channel type %d", c->type);
    }
    __Cont: /* CIL Label */ 
#line 482
    i ++;
  }
#line 511
  return (-1);
}
}
#line 521 "channels.c"
char *channel_open_message(void) 
{ Buffer buffer ;
  Channel *c ;
  char buf___1[1024] ;
  char *cp ;
  int i ;
  size_t tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
#line 529
  buffer_init(& buffer);
#line 530
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"The following connections are open:\r\n");
#line 531
  tmp = strlen((char const   *)(buf___1));
#line 531
  buffer_append(& buffer, (void const   *)(buf___1), tmp);
#line 532
  i = 0;
#line 532
  while (i < channels_alloc) {
#line 533
    c = *(channels + i);
#line 534
    if ((unsigned int )c == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 536
    switch (c->type) {
    case 1: 
    case 2: 
    case 11: 
    case 5: 
    case 6: 
    case 14: 
    goto __Cont;
    case 10: 
    case 3: 
    case 12: 
    case 13: 
    case 4: 
    case 7: 
    case 8: 
    case 9: 
#line 552
    tmp___0 = buffer_len(& c->output);
#line 552
    tmp___1 = buffer_len(& c->input);
#line 552
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"  #%d %.300s (t%d r%d i%d/%d o%d/%d fd %d/%d)\r\n",
             c->self, c->remote_name, c->type, c->remote_id, c->istate, tmp___1, c->ostate,
             tmp___0, c->rfd, c->wfd);
#line 558
    tmp___2 = strlen((char const   *)(buf___1));
#line 558
    buffer_append(& buffer, (void const   *)(buf___1), tmp___2);
    goto __Cont;
    default: 
#line 561
    fatal("channel_open_message: bad channel type %d", c->type);
    }
    __Cont: /* CIL Label */ 
#line 532
    i ++;
  }
#line 565
  buffer_append(& buffer, (void const   *)"\000", 1U);
#line 566
  tmp___3 = buffer_ptr(& buffer);
#line 566
  cp = xstrdup((char const   *)tmp___3);
#line 567
  buffer_free(& buffer);
#line 568
  return (cp);
}
}
#line 571 "channels.c"
void channel_send_open(int id ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 574
  tmp = channel_lookup(id);
#line 574
  c = tmp;
#line 575
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 576
    log("channel_send_open: %d: bad id", id);
#line 577
    return;
  }
#line 579
  debug("send channel open %d", id);
#line 580
  packet_start((unsigned char)90);
#line 581
  packet_put_cstring((char const   *)c->ctype);
#line 582
  packet_put_int((unsigned int )c->self);
#line 583
  packet_put_int(c->local_window);
#line 584
  packet_put_int(c->local_maxpacket);
#line 585
  packet_send();
#line 586
  return;
}
}
#line 588 "channels.c"
void channel_request_start(int local_id , char *service , int wantconfirm ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 591
  tmp = channel_lookup(local_id);
#line 591
  c = tmp;
#line 592
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 593
    log("channel_request_start: %d: unknown channel id", local_id);
#line 594
    return;
  }
#line 596
  debug("channel request %d: %s", local_id, service);
#line 597
  packet_start((unsigned char)98);
#line 598
  packet_put_int((unsigned int )c->remote_id);
#line 599
  packet_put_cstring((char const   *)service);
#line 600
  packet_put_char(wantconfirm);
#line 601
  return;
}
}
#line 602 "channels.c"
void channel_register_confirm(int id , channel_callback_fn *fn ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 605
  tmp = channel_lookup(id);
#line 605
  c = tmp;
#line 606
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 607
    log("channel_register_comfirm: %d: bad id", id);
#line 608
    return;
  }
#line 610
  c->confirm = fn;
#line 611
  return;
}
}
#line 612 "channels.c"
void channel_register_cleanup(int id , channel_callback_fn *fn ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 615
  tmp = channel_lookup(id);
#line 615
  c = tmp;
#line 616
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 617
    log("channel_register_cleanup: %d: bad id", id);
#line 618
    return;
  }
#line 620
  c->detach_user = fn;
#line 621
  return;
}
}
#line 622 "channels.c"
void channel_cancel_cleanup(int id ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 625
  tmp = channel_lookup(id);
#line 625
  c = tmp;
#line 626
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 627
    log("channel_cancel_cleanup: %d: bad id", id);
#line 628
    return;
  }
#line 630
  c->detach_user = (channel_callback_fn *)((void *)0);
#line 631
  return;
}
}
#line 632 "channels.c"
void channel_register_filter(int id , channel_filter_fn *fn ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 635
  tmp = channel_lookup(id);
#line 635
  c = tmp;
#line 636
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 637
    log("channel_register_filter: %d: bad id", id);
#line 638
    return;
  }
#line 640
  c->input_filter = fn;
#line 641
  return;
}
}
#line 643 "channels.c"
void channel_set_fds(int id , int rfd , int wfd , int efd , int extusage , int nonblock ,
                     u_int window_max ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 647
  tmp = channel_lookup(id);
#line 647
  c = tmp;
#line 648
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 649
    fatal("channel_activate for non-larval channel %d.", id);
  } else {
#line 648
    if (c->type != 10) {
#line 649
      fatal("channel_activate for non-larval channel %d.", id);
    }
  }
#line 650
  channel_register_fds(c, rfd, wfd, efd, extusage, nonblock);
#line 651
  c->type = 4;
#line 652
  c->local_window_max = window_max;
#line 652
  c->local_window = c->local_window_max;
#line 653
  packet_start((unsigned char)93);
#line 654
  packet_put_int((unsigned int )c->remote_id);
#line 655
  packet_put_int(c->local_window);
#line 656
  packet_send();
#line 657
  return;
}
}
#line 668 "channels.c"
chan_fn *channel_pre[15]  ;
#line 669 "channels.c"
chan_fn *channel_post[15]  ;
#line 671 "channels.c"
static void channel_pre_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 674
  __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 675
  return;
}
}
#line 677 "channels.c"
static void channel_pre_connecting(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 680
  debug3("channel %d: waiting for connection", c->self);
#line 681
  __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 682
  return;
}
}
#line 684 "channels.c"
static void channel_pre_open_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int tmp ;
  u_int tmp___0 ;

  {
#line 687
  tmp = buffer_len(& c->input);
#line 687
  if (tmp < (u_int )max_packet_size) {
#line 688
    __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 689
  tmp___0 = buffer_len(& c->output);
#line 689
  if (tmp___0 > 0U) {
#line 690
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 691
  return;
}
}
#line 693 "channels.c"
static void channel_pre_open(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int limit ;
  u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;

  {
#line 696
  if (compat20) {
#line 696
    tmp = c->remote_window;
  } else {
#line 696
    tmp = (unsigned int )max_packet_size;
  }
#line 696
  limit = tmp;
#line 698
  if (c->istate == 0U) {
#line 698
    if (limit > 0U) {
#line 698
      tmp___0 = buffer_len(& c->input);
#line 698
      if (tmp___0 < limit) {
#line 701
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->rfd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->rfd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
  }
#line 702
  if (c->ostate == 0U) {
    goto _L___0;
  } else {
#line 702
    if (c->ostate == 1U) {
      _L___0: /* CIL Label */ 
#line 704
      tmp___3 = buffer_len(& c->output);
#line 704
      if (tmp___3 > 0U) {
#line 705
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->wfd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->wfd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      } else {
#line 706
        if (c->ostate == 1U) {
#line 707
          if (compat20) {
#line 707
            if (c->extended_usage == 2) {
#line 707
              if (c->efd != -1) {
#line 707
                if (! (c->flags & 10)) {
#line 708
                  tmp___1 = buffer_len(& c->extended);
#line 708
                  debug2("channel %d: obuf_empty delayed efd %d/(%d)", c->self, c->efd,
                         tmp___1);
                } else {
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
#line 707
                tmp___2 = buffer_len(& c->extended);
#line 707
                if (tmp___2 > 0U) {
#line 708
                  tmp___1 = buffer_len(& c->extended);
#line 708
                  debug2("channel %d: obuf_empty delayed efd %d/(%d)", c->self, c->efd,
                         tmp___1);
                } else {
#line 711
                  chan_obuf_empty(c);
                }
              }
            } else {
#line 711
              chan_obuf_empty(c);
            }
          } else {
#line 711
            chan_obuf_empty(c);
          }
        }
      }
    }
  }
#line 715
  if (compat20) {
#line 715
    if (c->efd != -1) {
#line 716
      if (c->extended_usage == 2) {
#line 716
        tmp___5 = buffer_len(& c->extended);
#line 716
        if (tmp___5 > 0U) {
#line 718
          __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        } else {
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 719
        if (! (c->flags & 4)) {
#line 719
          if (c->extended_usage == 1) {
#line 719
            tmp___4 = buffer_len(& c->extended);
#line 719
            if (tmp___4 < c->remote_window) {
#line 722
              __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))): "cc",
                                   "memory");
            }
          }
        }
      }
    }
  }
#line 724
  return;
}
}
#line 726 "channels.c"
static void channel_pre_input_draining(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int tmp ;

  {
#line 729
  tmp = buffer_len(& c->input);
#line 729
  if (tmp == 0U) {
#line 730
    packet_start((unsigned char)24);
#line 731
    packet_put_int((unsigned int )c->remote_id);
#line 732
    packet_send();
#line 733
    c->type = 5;
#line 734
    debug("channel %d: closing after input drain.", c->self);
  }
#line 736
  return;
}
}
#line 738 "channels.c"
static void channel_pre_output_draining(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int tmp ;

  {
#line 741
  tmp = buffer_len(& c->output);
#line 741
  if (tmp == 0U) {
#line 742
    chan_mark_dead(c);
  } else {
#line 744
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 745
  return;
}
}
#line 756 "channels.c"
static int x11_open_helper(Buffer *b ) 
{ u_char *ucp ;
  u_int proto_len ;
  u_int data_len ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 763
  tmp = buffer_len(b);
#line 763
  if (tmp < 12U) {
#line 764
    return (0);
  }
#line 767
  tmp___0 = buffer_ptr(b);
#line 767
  ucp = (u_char *)tmp___0;
#line 768
  if ((int )*(ucp + 0) == 66) {
#line 769
    proto_len = (unsigned int )(256 * (int )*(ucp + 6) + (int )*(ucp + 7));
#line 770
    data_len = (unsigned int )(256 * (int )*(ucp + 8) + (int )*(ucp + 9));
  } else {
#line 771
    if ((int )*(ucp + 0) == 108) {
#line 772
      proto_len = (unsigned int )((int )*(ucp + 6) + 256 * (int )*(ucp + 7));
#line 773
      data_len = (unsigned int )((int )*(ucp + 8) + 256 * (int )*(ucp + 9));
    } else {
#line 775
      debug("Initial X11 packet contains bad byte order byte: 0x%x", *(ucp + 0));
#line 777
      return (-1);
    }
  }
#line 781
  tmp___1 = buffer_len(b);
#line 781
  if (tmp___1 < (12U + ((proto_len + 3U) & 4294967292U)) + ((data_len + 3U) & 4294967292U)) {
#line 783
    return (0);
  }
#line 786
  tmp___2 = strlen((char const   *)x11_saved_proto);
#line 786
  if (proto_len != tmp___2) {
#line 788
    debug("X11 connection uses different authentication protocol.");
#line 789
    return (-1);
  } else {
#line 786
    tmp___3 = memcmp((void const   *)(ucp + 12), (void const   *)x11_saved_proto,
                     proto_len);
#line 786
    if (tmp___3 != 0) {
#line 788
      debug("X11 connection uses different authentication protocol.");
#line 789
      return (-1);
    }
  }
#line 792
  if (data_len != x11_fake_data_len) {
#line 795
    debug("X11 auth data does not match fake data.");
#line 796
    return (-1);
  } else {
#line 792
    tmp___4 = memcmp((void const   *)((ucp + 12) + ((proto_len + 3U) & 4294967292U)),
                     (void const   *)x11_fake_data, x11_fake_data_len);
#line 792
    if (tmp___4 != 0) {
#line 795
      debug("X11 auth data does not match fake data.");
#line 796
      return (-1);
    }
  }
#line 799
  if (x11_fake_data_len != x11_saved_data_len) {
#line 800
    error("X11 fake_data_len %d != saved_data_len %d", x11_fake_data_len, x11_saved_data_len);
#line 802
    return (-1);
  }
#line 809
  memcpy((void * __restrict  )((ucp + 12) + ((proto_len + 3U) & 4294967292U)), (void const   * __restrict  )x11_saved_data,
         x11_saved_data_len);
#line 811
  return (1);
}
}
#line 814 "channels.c"
static void channel_pre_x11_open_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int ret ;
  int tmp ;

  {
#line 817
  tmp = x11_open_helper(& c->output);
#line 817
  ret = tmp;
#line 818
  if (ret == 1) {
#line 820
    c->type = 4;
#line 821
    channel_pre_open_13(c, readset, writeset);
  } else {
#line 822
    if (ret == -1) {
#line 827
      log("X11 connection rejected because of wrong authentication.");
#line 828
      buffer_clear(& c->input);
#line 829
      buffer_clear(& c->output);
#line 830
      channel_close_fd(& c->sock);
#line 831
      c->sock = -1;
#line 832
      c->type = 5;
#line 833
      packet_start((unsigned char)24);
#line 834
      packet_put_int((unsigned int )c->remote_id);
#line 835
      packet_send();
    }
  }
#line 837
  return;
}
}
#line 839 "channels.c"
static void channel_pre_x11_open(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int ret ;
  int tmp ;

  {
#line 842
  tmp = x11_open_helper(& c->output);
#line 842
  ret = tmp;
#line 846
  if (ret == 1) {
#line 847
    c->type = 4;
#line 848
    channel_pre_open(c, readset, writeset);
  } else {
#line 849
    if (ret == -1) {
#line 850
      log("X11 connection rejected because of wrong authentication.");
#line 851
      debug("X11 rejected %d i%d/o%d", c->self, c->istate, c->ostate);
#line 852
      chan_read_failed(c);
#line 853
      buffer_clear(& c->input);
#line 854
      chan_ibuf_empty(c);
#line 855
      buffer_clear(& c->output);
#line 857
      if (compat20) {
#line 858
        chan_write_failed(c);
      } else {
#line 860
        c->type = 4;
      }
#line 861
      debug("X11 closed %d i%d/o%d", c->self, c->istate, c->ostate);
    }
  }
#line 863
  return;
}
}
#line 866 "channels.c"
static int channel_decode_socks4(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_char *p ;
  u_char *host ;
  int len ;
  int have ;
  int i ;
  int found ;
  char username[256] ;
  struct __anonstruct_s4_req_71 s4_req ;
  struct __anonstruct_s4_req_71 s4_rsp ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  register unsigned short __v ;
  register unsigned short __x ;

  {
#line 879
  debug2("channel %d: decode socks4", c->self);
#line 881
  tmp = buffer_len(& c->input);
#line 881
  have = (int )tmp;
#line 882
  len = (int )sizeof(s4_req);
#line 883
  if (have < len) {
#line 884
    return (0);
  }
#line 885
  tmp___0 = buffer_ptr(& c->input);
#line 885
  p = (u_char *)tmp___0;
#line 886
  found = 0;
#line 886
  i = len;
#line 886
  while (i < have) {
#line 887
    if ((int )*(p + i) == 0) {
#line 888
      found = 1;
#line 889
      break;
    }
#line 891
    if (i > 1024) {
#line 893
      debug("channel %d: decode socks4: too long", c->self);
#line 895
      return (-1);
    }
#line 886
    i ++;
  }
#line 898
  if (! found) {
#line 899
    return (0);
  }
#line 900
  buffer_get(& c->input, (void *)((char *)(& s4_req.version)), 1U);
#line 901
  buffer_get(& c->input, (void *)((char *)(& s4_req.command)), 1U);
#line 902
  buffer_get(& c->input, (void *)((char *)(& s4_req.dest_port)), 2U);
#line 903
  buffer_get(& c->input, (void *)((char *)(& s4_req.dest_addr)), 4U);
#line 904
  tmp___1 = buffer_len(& c->input);
#line 904
  have = (int )tmp___1;
#line 905
  tmp___2 = buffer_ptr(& c->input);
#line 905
  p = (u_char *)tmp___2;
#line 906
  tmp___3 = strlen((char const   *)p);
#line 906
  len = (int )tmp___3;
#line 907
  debug2("channel %d: decode socks4: user %s/%d", c->self, p, len);
#line 908
  if (len > have) {
#line 909
    fatal("channel %d: decode socks4: len %d > have %d", c->self, len, have);
  }
#line 911
  strlcpy(username, (char const   *)p, sizeof(username));
#line 912
  buffer_consume(& c->input, (unsigned int )len);
#line 913
  buffer_consume(& c->input, 1U);
#line 915
  tmp___4 = inet_ntoa(s4_req.dest_addr);
#line 915
  host = (u_char *)tmp___4;
#line 916
  strlcpy(c->path, (char const   *)host, sizeof(c->path));
#line 917
  __x = s4_req.dest_port;
#line 917
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 917
  c->host_port = (int )__v;
#line 919
  debug("channel %d: dynamic request: socks4 host %s port %u command %u", c->self,
        host, c->host_port, s4_req.command);
#line 922
  if ((int )s4_req.command != 1) {
#line 923
    debug("channel %d: cannot handle: socks4 cn %d", c->self, s4_req.command);
#line 925
    return (-1);
  }
#line 927
  s4_rsp.version = (unsigned char)0;
#line 928
  s4_rsp.command = (unsigned char)90;
#line 929
  s4_rsp.dest_port = (unsigned short)0;
#line 930
  s4_rsp.dest_addr.s_addr = 0U;
#line 931
  buffer_append(& c->output, (void const   *)((char *)(& s4_rsp)), sizeof(s4_rsp));
#line 932
  return (1);
}
}
#line 936 "channels.c"
static void channel_pre_dynamic(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_char *p ;
  int have ;
  int ret ;
  u_int tmp ;
  void *tmp___0 ;

  {
#line 942
  tmp = buffer_len(& c->input);
#line 942
  have = (int )tmp;
#line 943
  c->delayed = 0;
#line 944
  debug2("channel %d: pre_dynamic: have %d", c->self, have);
#line 947
  if (have < 4) {
#line 949
    __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 950
    return;
  }
#line 953
  tmp___0 = buffer_ptr(& c->input);
#line 953
  p = (u_char *)tmp___0;
#line 954
  switch ((int )*(p + 0)) {
  case 4: 
#line 956
  ret = channel_decode_socks4(c, readset, writeset);
#line 957
  break;
  default: 
#line 959
  ret = -1;
#line 960
  break;
  }
#line 962
  if (ret < 0) {
#line 963
    chan_mark_dead(c);
  } else {
#line 964
    if (ret == 0) {
#line 965
      debug2("channel %d: pre_dynamic: need more", c->self);
#line 967
      __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    } else {
#line 970
      c->type = 3;
#line 971
      port_open_helper(c, (char *)"direct-tcpip");
    }
  }
#line 973
  return;
}
}
#line 976 "channels.c"
static void channel_post_x11_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ Channel *nc ;
  struct sockaddr addr ;
  int newsock ;
  socklen_t addrlen ;
  char buf___1[16384] ;
  char *remote_ipaddr ;
  int remote_port ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  u_int tmp___2 ;
  register char __result ;

  {
#line 986
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 986
  if (__result) {
#line 987
    debug("X11 connection requested.");
#line 988
    addrlen = sizeof(addr);
#line 989
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 990
    if (c->single_connection) {
#line 991
      debug("single_connection: closing X11 listener.");
#line 992
      channel_close_fd(& c->sock);
#line 993
      chan_mark_dead(c);
    }
#line 995
    if (newsock < 0) {
#line 996
      tmp = __errno_location();
#line 996
      tmp___0 = strerror(*tmp);
#line 996
      error("accept: %.100s", tmp___0);
#line 997
      return;
    }
#line 999
    set_nodelay(newsock);
#line 1000
    remote_ipaddr = get_peer_ipaddr(newsock);
#line 1001
    remote_port = get_peer_port(newsock);
#line 1002
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"X11 connection from %.200s port %d",
             remote_ipaddr, remote_port);
#line 1005
    tmp___1 = xstrdup((char const   *)(buf___1));
#line 1005
    nc = channel_new((char *)"accepted x11 socket", 3, newsock, newsock, -1, c->local_window_max,
                     c->local_maxpacket, 0, tmp___1, 1);
#line 1009
    if (compat20) {
#line 1010
      packet_start((unsigned char)90);
#line 1011
      packet_put_cstring("x11");
#line 1012
      packet_put_int((unsigned int )nc->self);
#line 1013
      packet_put_int(nc->local_window_max);
#line 1014
      packet_put_int(nc->local_maxpacket);
#line 1016
      packet_put_cstring((char const   *)remote_ipaddr);
#line 1017
      if (datafellows & 8) {
#line 1018
        debug("ssh2 x11 bug compat mode");
      } else {
#line 1020
        packet_put_int((unsigned int )remote_port);
      }
#line 1022
      packet_send();
    } else {
#line 1024
      packet_start((unsigned char)27);
#line 1025
      packet_put_int((unsigned int )nc->self);
#line 1026
      tmp___2 = packet_get_protocol_flags();
#line 1026
      if (tmp___2 & 2U) {
#line 1028
        packet_put_cstring((char const   *)(buf___1));
      }
#line 1029
      packet_send();
    }
#line 1031
    xfree((void *)remote_ipaddr);
  }
#line 1033
  return;
}
}
#line 1035 "channels.c"
static void port_open_helper(Channel *c , char *rtype ) 
{ int direct ;
  char buf___1[1024] ;
  char *remote_ipaddr ;
  char *tmp ;
  u_short remote_port ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  u_int tmp___11 ;

  {
#line 1040
  tmp = get_peer_ipaddr(c->sock);
#line 1040
  remote_ipaddr = tmp;
#line 1041
  tmp___0 = get_peer_port(c->sock);
#line 1041
  remote_port = (u_short )tmp___0;
#line 1043
  if (0) {
#line 1043
    __s1_len = strlen((char const   *)rtype);
#line 1043
    __s2_len = strlen("direct-tcpip");
#line 1043
    if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
      goto _L___0;
    } else {
#line 1043
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1043
        if (! ((unsigned int )((void const   *)("direct-tcpip" + 1)) - (unsigned int )((void const   *)"direct-tcpip") == 1U)) {
#line 1043
          tmp___10 = 1;
        } else {
#line 1043
          if (__s2_len >= 4U) {
#line 1043
            tmp___10 = 1;
          } else {
#line 1043
            tmp___10 = 0;
          }
        }
      } else {
#line 1043
        tmp___10 = 0;
      }
    }
#line 1043
    if (tmp___10) {
#line 1043
      tmp___6 = __builtin_strcmp((char const   *)rtype, "direct-tcpip");
    } else {
#line 1043
      tmp___9 = __builtin_strcmp((char const   *)rtype, "direct-tcpip");
#line 1043
      tmp___6 = tmp___9;
    }
  } else {
#line 1043
    tmp___9 = __builtin_strcmp((char const   *)rtype, "direct-tcpip");
#line 1043
    tmp___6 = tmp___9;
  }
#line 1043
  direct = tmp___6 == 0;
#line 1045
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%s: listening port %d for %.100s port %d, connect from %.200s port %d",
           rtype, c->listening_port, c->path, c->host_port, remote_ipaddr, remote_port);
#line 1051
  xfree((void *)c->remote_name);
#line 1052
  c->remote_name = xstrdup((char const   *)(buf___1));
#line 1054
  if (compat20) {
#line 1055
    packet_start((unsigned char)90);
#line 1056
    packet_put_cstring((char const   *)rtype);
#line 1057
    packet_put_int((unsigned int )c->self);
#line 1058
    packet_put_int(c->local_window_max);
#line 1059
    packet_put_int(c->local_maxpacket);
#line 1060
    if (direct) {
#line 1062
      packet_put_cstring((char const   *)(c->path));
#line 1063
      packet_put_int((unsigned int )c->host_port);
    } else {
#line 1066
      packet_put_cstring((char const   *)(c->path));
#line 1067
      packet_put_int((unsigned int )c->listening_port);
    }
#line 1070
    packet_put_cstring((char const   *)remote_ipaddr);
#line 1071
    packet_put_int((unsigned int )remote_port);
#line 1072
    packet_send();
  } else {
#line 1074
    packet_start((unsigned char)29);
#line 1075
    packet_put_int((unsigned int )c->self);
#line 1076
    packet_put_cstring((char const   *)(c->path));
#line 1077
    packet_put_int((unsigned int )c->host_port);
#line 1078
    tmp___11 = packet_get_protocol_flags();
#line 1078
    if (tmp___11 & 2U) {
#line 1080
      packet_put_cstring((char const   *)c->remote_name);
    }
#line 1081
    packet_send();
  }
#line 1083
  xfree((void *)remote_ipaddr);
#line 1084
  return;
}
}
#line 1089 "channels.c"
static void channel_post_port_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ Channel *nc ;
  struct sockaddr addr ;
  int newsock ;
  int nextstate ;
  socklen_t addrlen ;
  char *rtype ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  register char __result ;

  {
#line 1098
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 1098
  if (__result) {
#line 1099
    debug("Connection to port %d forwarding to %.100s port %d requested.", c->listening_port,
          c->path, c->host_port);
#line 1103
    if (c->type == 11) {
#line 1104
      nextstate = 3;
#line 1105
      rtype = (char *)"forwarded-tcpip";
    } else {
#line 1107
      if (c->host_port == 0) {
#line 1108
        nextstate = 13;
#line 1109
        rtype = (char *)"dynamic-tcpip";
      } else {
#line 1111
        nextstate = 3;
#line 1112
        rtype = (char *)"direct-tcpip";
      }
    }
#line 1116
    addrlen = sizeof(addr);
#line 1117
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 1118
    if (newsock < 0) {
#line 1119
      tmp = __errno_location();
#line 1119
      tmp___0 = strerror(*tmp);
#line 1119
      error("accept: %.100s", tmp___0);
#line 1120
      return;
    }
#line 1122
    set_nodelay(newsock);
#line 1123
    tmp___1 = xstrdup((char const   *)rtype);
#line 1123
    nc = channel_new(rtype, nextstate, newsock, newsock, -1, c->local_window_max,
                     c->local_maxpacket, 0, tmp___1, 1);
#line 1127
    nc->listening_port = c->listening_port;
#line 1128
    nc->host_port = c->host_port;
#line 1129
    strlcpy(nc->path, (char const   *)(c->path), sizeof(nc->path));
#line 1131
    if (nextstate == 13) {
#line 1137
      nc->delayed = 1;
    } else {
#line 1139
      port_open_helper(nc, rtype);
    }
  }
#line 1142
  return;
}
}
#line 1148 "channels.c"
static void channel_post_auth_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ Channel *nc ;
  char *name ;
  int newsock ;
  struct sockaddr addr ;
  socklen_t addrlen ;
  int *tmp ;
  char *tmp___0 ;
  register char __result ;

  {
#line 1157
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 1157
  if (__result) {
#line 1158
    addrlen = sizeof(addr);
#line 1159
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 1160
    if (newsock < 0) {
#line 1161
      tmp = __errno_location();
#line 1161
      tmp___0 = strerror(*tmp);
#line 1161
      error("accept from auth socket: %.100s", tmp___0);
#line 1162
      return;
    }
#line 1164
    name = xstrdup("accepted auth socket");
#line 1165
    nc = channel_new((char *)"accepted auth socket", 3, newsock, newsock, -1, c->local_window_max,
                     c->local_maxpacket, 0, name, 1);
#line 1169
    if (compat20) {
#line 1170
      packet_start((unsigned char)90);
#line 1171
      packet_put_cstring("auth-agent@openssh.com");
#line 1172
      packet_put_int((unsigned int )nc->self);
#line 1173
      packet_put_int(c->local_window_max);
#line 1174
      packet_put_int(c->local_maxpacket);
    } else {
#line 1176
      packet_start((unsigned char)31);
#line 1177
      packet_put_int((unsigned int )nc->self);
    }
#line 1179
    packet_send();
  }
#line 1181
  return;
}
}
#line 1183 "channels.c"
static void channel_post_connecting(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int err ;
  socklen_t sz ;
  int *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  register char __result ;

  {
#line 1186
  err = 0;
#line 1187
  sz = sizeof(err);
#line 1189
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 1189
  if (__result) {
#line 1190
    tmp___0 = getsockopt(c->sock, 1, 4, (void * __restrict  )(& err), (socklen_t * __restrict  )(& sz));
#line 1190
    if (tmp___0 < 0) {
#line 1191
      tmp = __errno_location();
#line 1191
      err = *tmp;
#line 1192
      error("getsockopt SO_ERROR failed");
    }
#line 1194
    if (err == 0) {
#line 1195
      debug("channel %d: connected", c->self);
#line 1196
      c->type = 4;
#line 1197
      if (compat20) {
#line 1198
        packet_start((unsigned char)91);
#line 1199
        packet_put_int((unsigned int )c->remote_id);
#line 1200
        packet_put_int((unsigned int )c->self);
#line 1201
        packet_put_int(c->local_window);
#line 1202
        packet_put_int(c->local_maxpacket);
      } else {
#line 1204
        packet_start((unsigned char)21);
#line 1205
        packet_put_int((unsigned int )c->remote_id);
#line 1206
        packet_put_int((unsigned int )c->self);
      }
    } else {
#line 1209
      tmp___1 = strerror(err);
#line 1209
      debug("channel %d: not connected: %s", c->self, tmp___1);
#line 1211
      if (compat20) {
#line 1212
        packet_start((unsigned char)92);
#line 1213
        packet_put_int((unsigned int )c->remote_id);
#line 1214
        packet_put_int(2U);
#line 1215
        if (! (datafellows & 131072)) {
#line 1216
          tmp___2 = strerror(err);
#line 1216
          packet_put_cstring((char const   *)tmp___2);
#line 1217
          packet_put_cstring("");
        }
      } else {
#line 1220
        packet_start((unsigned char)22);
#line 1221
        packet_put_int((unsigned int )c->remote_id);
      }
#line 1223
      chan_mark_dead(c);
    }
#line 1225
    packet_send();
  }
#line 1227
  return;
}
}
#line 1229 "channels.c"
static int channel_handle_rfd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char buf___1[16384] ;
  int len ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  register char __result ;

  {
#line 1236
  if (c->rfd != -1) {
#line 1236
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->rfd % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )c->rfd / (8U * sizeof(__fd_mask ))]): "cc");
#line 1236
    if (__result) {
#line 1237
      len = read(c->rfd, (void *)(buf___1), sizeof(buf___1));
#line 1238
      if (len < 0) {
#line 1238
        tmp = __errno_location();
#line 1238
        if (*tmp == 4) {
#line 1239
          return (1);
        } else {
#line 1238
          tmp___0 = __errno_location();
#line 1238
          if (*tmp___0 == 11) {
#line 1239
            return (1);
          }
        }
      }
#line 1240
      if (len <= 0) {
#line 1241
        debug("channel %d: read<=0 rfd %d len %d", c->self, c->rfd, len);
#line 1243
        if (c->type != 4) {
#line 1244
          debug("channel %d: not open", c->self);
#line 1245
          chan_mark_dead(c);
#line 1246
          return (-1);
        } else {
#line 1247
          if (compat13) {
#line 1248
            buffer_clear(& c->output);
#line 1249
            c->type = 8;
#line 1250
            debug("channel %d: input draining.", c->self);
          } else {
#line 1252
            chan_read_failed(c);
          }
        }
#line 1254
        return (-1);
      }
#line 1256
      if ((unsigned int )c->input_filter != (unsigned int )((void *)0)) {
#line 1257
        tmp___1 = (*(c->input_filter))(c, buf___1, len);
#line 1257
        if (tmp___1 == -1) {
#line 1258
          debug("channel %d: filter stops", c->self);
#line 1259
          chan_read_failed(c);
        }
      } else {
#line 1262
        buffer_append(& c->input, (void const   *)(buf___1), (unsigned int )len);
      }
    }
  }
#line 1265
  return (1);
}
}
#line 1267 "channels.c"
static int channel_handle_wfd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ struct termios tio ;
  u_char *data ;
  u_int dlen ;
  int len ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  register char __result ;
  u_int tmp___3 ;

  {
#line 1277
  if (c->wfd != -1) {
#line 1277
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->wfd % (8U * sizeof(__fd_mask ))),
                         "m" (writeset->__fds_bits[(unsigned int )c->wfd / (8U * sizeof(__fd_mask ))]): "cc");
#line 1277
    if (__result) {
#line 1277
      tmp___3 = buffer_len(& c->output);
#line 1277
      if (tmp___3 > 0U) {
#line 1279
        tmp = buffer_ptr(& c->output);
#line 1279
        data = (u_char *)tmp;
#line 1280
        dlen = buffer_len(& c->output);
#line 1281
        len = write(c->wfd, (void const   *)data, dlen);
#line 1282
        if (len < 0) {
#line 1282
          tmp___0 = __errno_location();
#line 1282
          if (*tmp___0 == 4) {
#line 1283
            return (1);
          } else {
#line 1282
            tmp___1 = __errno_location();
#line 1282
            if (*tmp___1 == 11) {
#line 1283
              return (1);
            }
          }
        }
#line 1284
        if (len <= 0) {
#line 1285
          if (c->type != 4) {
#line 1286
            debug("channel %d: not open", c->self);
#line 1287
            chan_mark_dead(c);
#line 1288
            return (-1);
          } else {
#line 1289
            if (compat13) {
#line 1290
              buffer_clear(& c->output);
#line 1291
              debug("channel %d: input draining.", c->self);
#line 1292
              c->type = 8;
            } else {
#line 1294
              chan_write_failed(c);
            }
          }
#line 1296
          return (-1);
        }
#line 1298
        if (compat20) {
#line 1298
          if (c->isatty) {
#line 1298
            if (dlen >= 1U) {
#line 1298
              if ((int )*(data + 0) != 13) {
#line 1299
                tmp___2 = tcgetattr(c->wfd, & tio);
#line 1299
                if (tmp___2 == 0) {
#line 1299
                  if (! (tio.c_lflag & 8U)) {
#line 1299
                    if (tio.c_lflag & 2U) {
#line 1307
                      packet_send_ignore(4 + len);
#line 1308
                      packet_send();
                    }
                  }
                }
              }
            }
          }
        }
#line 1311
        buffer_consume(& c->output, (unsigned int )len);
#line 1312
        if (compat20) {
#line 1312
          if (len > 0) {
#line 1313
            c->local_consumed += (u_int )len;
          }
        }
      }
    }
  }
#line 1316
  return (1);
}
}
#line 1318 "channels.c"
static int channel_handle_efd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char buf___1[16384] ;
  int len ;
  u_int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  register char __result ;
  register char __result___0 ;
  u_int tmp___5 ;

  {
#line 1325
  if (c->efd != -1) {
#line 1327
    if (c->extended_usage == 2) {
#line 1327
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))),
                           "m" (writeset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "cc");
#line 1327
      if (__result___0) {
#line 1327
        tmp___5 = buffer_len(& c->extended);
#line 1327
        if (tmp___5 > 0U) {
#line 1329
          tmp = buffer_len(& c->extended);
#line 1329
          tmp___0 = buffer_ptr(& c->extended);
#line 1329
          len = write(c->efd, (void const   *)tmp___0, tmp);
#line 1331
          debug2("channel %d: written %d to efd %d", c->self, len, c->efd);
#line 1333
          if (len < 0) {
#line 1333
            tmp___1 = __errno_location();
#line 1333
            if (*tmp___1 == 4) {
#line 1334
              return (1);
            } else {
#line 1333
              tmp___2 = __errno_location();
#line 1333
              if (*tmp___2 == 11) {
#line 1334
                return (1);
              }
            }
          }
#line 1335
          if (len <= 0) {
#line 1336
            debug2("channel %d: closing write-efd %d", c->self, c->efd);
#line 1338
            channel_close_fd(& c->efd);
          } else {
#line 1340
            buffer_consume(& c->extended, (unsigned int )len);
#line 1341
            c->local_consumed += (u_int )len;
          }
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 1344
      if (c->extended_usage == 1) {
#line 1344
        __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))),
                             "m" (readset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "cc");
#line 1344
        if (__result) {
#line 1345
          len = read(c->efd, (void *)(buf___1), sizeof(buf___1));
#line 1346
          debug2("channel %d: read %d from efd %d", c->self, len, c->efd);
#line 1348
          if (len < 0) {
#line 1348
            tmp___3 = __errno_location();
#line 1348
            if (*tmp___3 == 4) {
#line 1349
              return (1);
            } else {
#line 1348
              tmp___4 = __errno_location();
#line 1348
              if (*tmp___4 == 11) {
#line 1349
                return (1);
              }
            }
          }
#line 1350
          if (len <= 0) {
#line 1351
            debug2("channel %d: closing read-efd %d", c->self, c->efd);
#line 1353
            channel_close_fd(& c->efd);
          } else {
#line 1355
            buffer_append(& c->extended, (void const   *)(buf___1), (unsigned int )len);
          }
        }
      }
    }
  }
#line 1359
  return (1);
}
}
#line 1361 "channels.c"
static int channel_check_window(Channel *c ) 
{ 

  {
#line 1364
  if (c->type == 4) {
#line 1364
    if (! (c->flags & 3)) {
#line 1364
      if (c->local_window < c->local_window_max / 2U) {
#line 1364
        if (c->local_consumed > 0U) {
#line 1368
          packet_start((unsigned char)93);
#line 1369
          packet_put_int((unsigned int )c->remote_id);
#line 1370
          packet_put_int(c->local_consumed);
#line 1371
          packet_send();
#line 1372
          debug2("channel %d: window %d sent adjust %d", c->self, c->local_window,
                 c->local_consumed);
#line 1375
          c->local_window += c->local_consumed;
#line 1376
          c->local_consumed = 0U;
        }
      }
    }
  }
#line 1378
  return (1);
}
}
#line 1381 "channels.c"
static void channel_post_open(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 1384
  if (c->delayed) {
#line 1385
    return;
  }
#line 1386
  channel_handle_rfd(c, readset, writeset);
#line 1387
  channel_handle_wfd(c, readset, writeset);
#line 1388
  if (! compat20) {
#line 1389
    return;
  }
#line 1390
  channel_handle_efd(c, readset, writeset);
#line 1391
  channel_check_window(c);
#line 1392
  return;
}
}
#line 1394 "channels.c"
static void channel_post_output_drain_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int len ;
  u_int tmp ;
  void *tmp___0 ;
  register char __result ;
  u_int tmp___1 ;

  {
#line 1399
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 1399
  if (__result) {
#line 1399
    tmp___1 = buffer_len(& c->output);
#line 1399
    if (tmp___1 > 0U) {
#line 1400
      tmp = buffer_len(& c->output);
#line 1400
      tmp___0 = buffer_ptr(& c->output);
#line 1400
      len = write(c->sock, (void const   *)tmp___0, tmp);
#line 1402
      if (len <= 0) {
#line 1403
        buffer_clear(& c->output);
      } else {
#line 1405
        buffer_consume(& c->output, (unsigned int )len);
      }
    }
  }
#line 1407
  return;
}
}
#line 1409 "channels.c"
static void channel_handler_init_20(void) 
{ 

  {
#line 1412
  channel_pre[4] = & channel_pre_open;
#line 1413
  channel_pre[7] = & channel_pre_x11_open;
#line 1414
  channel_pre[2] = & channel_pre_listener;
#line 1415
  channel_pre[11] = & channel_pre_listener;
#line 1416
  channel_pre[1] = & channel_pre_listener;
#line 1417
  channel_pre[6] = & channel_pre_listener;
#line 1418
  channel_pre[12] = & channel_pre_connecting;
#line 1419
  channel_pre[13] = & channel_pre_dynamic;
#line 1421
  channel_post[4] = & channel_post_open;
#line 1422
  channel_post[2] = & channel_post_port_listener;
#line 1423
  channel_post[11] = & channel_post_port_listener;
#line 1424
  channel_post[1] = & channel_post_x11_listener;
#line 1425
  channel_post[6] = & channel_post_auth_listener;
#line 1426
  channel_post[12] = & channel_post_connecting;
#line 1427
  channel_post[13] = & channel_post_open;
#line 1428
  return;
}
}
#line 1430 "channels.c"
static void channel_handler_init_13(void) 
{ 

  {
#line 1433
  channel_pre[4] = & channel_pre_open_13;
#line 1434
  channel_pre[7] = & channel_pre_x11_open_13;
#line 1435
  channel_pre[1] = & channel_pre_listener;
#line 1436
  channel_pre[2] = & channel_pre_listener;
#line 1437
  channel_pre[6] = & channel_pre_listener;
#line 1438
  channel_pre[8] = & channel_pre_input_draining;
#line 1439
  channel_pre[9] = & channel_pre_output_draining;
#line 1440
  channel_pre[12] = & channel_pre_connecting;
#line 1441
  channel_pre[13] = & channel_pre_dynamic;
#line 1443
  channel_post[4] = & channel_post_open;
#line 1444
  channel_post[1] = & channel_post_x11_listener;
#line 1445
  channel_post[2] = & channel_post_port_listener;
#line 1446
  channel_post[6] = & channel_post_auth_listener;
#line 1447
  channel_post[9] = & channel_post_output_drain_13;
#line 1448
  channel_post[12] = & channel_post_connecting;
#line 1449
  channel_post[13] = & channel_post_open;
#line 1450
  return;
}
}
#line 1452 "channels.c"
static void channel_handler_init_15(void) 
{ 

  {
#line 1455
  channel_pre[4] = & channel_pre_open;
#line 1456
  channel_pre[7] = & channel_pre_x11_open;
#line 1457
  channel_pre[1] = & channel_pre_listener;
#line 1458
  channel_pre[2] = & channel_pre_listener;
#line 1459
  channel_pre[6] = & channel_pre_listener;
#line 1460
  channel_pre[12] = & channel_pre_connecting;
#line 1461
  channel_pre[13] = & channel_pre_dynamic;
#line 1463
  channel_post[1] = & channel_post_x11_listener;
#line 1464
  channel_post[2] = & channel_post_port_listener;
#line 1465
  channel_post[6] = & channel_post_auth_listener;
#line 1466
  channel_post[4] = & channel_post_open;
#line 1467
  channel_post[12] = & channel_post_connecting;
#line 1468
  channel_post[13] = & channel_post_open;
#line 1469
  return;
}
}
#line 1471 "channels.c"
static void channel_handler_init(void) 
{ int i ;

  {
#line 1475
  i = 0;
#line 1475
  while (i < 15) {
#line 1476
    channel_pre[i] = (chan_fn *)((void *)0);
#line 1477
    channel_post[i] = (chan_fn *)((void *)0);
#line 1475
    i ++;
  }
#line 1479
  if (compat20) {
#line 1480
    channel_handler_init_20();
  } else {
#line 1481
    if (compat13) {
#line 1482
      channel_handler_init_13();
    } else {
#line 1484
      channel_handler_init_15();
    }
  }
#line 1485
  return;
}
}
#line 1488 "channels.c"
static void channel_garbage_collect(Channel *c ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 1491
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1492
    return;
  }
#line 1493
  if ((unsigned int )c->detach_user != (unsigned int )((void *)0)) {
#line 1494
    tmp = chan_is_dead(c, 0);
#line 1494
    if (! tmp) {
#line 1495
      return;
    }
#line 1496
    debug("channel %d: gc: notify user", c->self);
#line 1497
    (*(c->detach_user))(c->self, (void *)0);
#line 1499
    if ((unsigned int )c->detach_user != (unsigned int )((void *)0)) {
#line 1500
      return;
    }
#line 1501
    debug("channel %d: gc: user detached", c->self);
  }
#line 1503
  tmp___0 = chan_is_dead(c, 1);
#line 1503
  if (! tmp___0) {
#line 1504
    return;
  }
#line 1505
  debug("channel %d: garbage collecting", c->self);
#line 1506
  channel_free(c);
#line 1507
  return;
}
}
#line 1512
static void channel_handler(chan_fn **ftab , fd_set *readset , fd_set *writeset ) ;
#line 1512 "channels.c"
static int did_init  =    0;
#line 1509 "channels.c"
static void channel_handler(chan_fn **ftab , fd_set *readset , fd_set *writeset ) 
{ int i ;
  Channel *c ;

  {
#line 1516
  if (! did_init) {
#line 1517
    channel_handler_init();
#line 1518
    did_init = 1;
  }
#line 1520
  i = 0;
#line 1520
  while (i < channels_alloc) {
#line 1521
    c = *(channels + i);
#line 1522
    if ((unsigned int )c == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 1524
    if ((unsigned int )*(ftab + c->type) != (unsigned int )((void *)0)) {
#line 1525
      (*(*(ftab + c->type)))(c, readset, writeset);
    }
#line 1526
    channel_garbage_collect(c);
    __Cont: /* CIL Label */ 
#line 1520
    i ++;
  }
#line 1528
  return;
}
}
#line 1534 "channels.c"
void channel_prepare_select(fd_set **readsetp , fd_set **writesetp , int *maxfdp ,
                            int *nallocp , int rekeying ) 
{ int n___0 ;
  u_int sz ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1541
  if (*maxfdp > channel_max_fd) {
#line 1541
    n___0 = *maxfdp;
  } else {
#line 1541
    n___0 = channel_max_fd;
  }
#line 1543
  sz = (((unsigned int )(n___0 + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask );
#line 1545
  if ((unsigned int )*readsetp == (unsigned int )((void *)0)) {
#line 1546
    tmp = xrealloc((void *)*readsetp, sz);
#line 1546
    *readsetp = (fd_set *)tmp;
#line 1547
    tmp___0 = xrealloc((void *)*writesetp, sz);
#line 1547
    *writesetp = (fd_set *)tmp___0;
#line 1548
    *nallocp = (int )sz;
  } else {
#line 1545
    if (sz > (u_int )*nallocp) {
#line 1546
      tmp = xrealloc((void *)*readsetp, sz);
#line 1546
      *readsetp = (fd_set *)tmp;
#line 1547
      tmp___0 = xrealloc((void *)*writesetp, sz);
#line 1547
      *writesetp = (fd_set *)tmp___0;
#line 1548
      *nallocp = (int )sz;
    }
  }
#line 1550
  *maxfdp = n___0;
#line 1551
  memset((void *)*readsetp, 0, sz);
#line 1552
  memset((void *)*writesetp, 0, sz);
#line 1554
  if (! rekeying) {
#line 1555
    channel_handler(channel_pre, *readsetp, *writesetp);
  }
#line 1556
  return;
}
}
#line 1562 "channels.c"
void channel_after_select(fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 1565
  channel_handler(channel_post, readset, writeset);
#line 1566
  return;
}
}
#line 1571 "channels.c"
void channel_output_poll(void) 
{ Channel *c ;
  int i ;
  u_int len ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  u_int tmp___4 ;
  void *tmp___5 ;

  {
#line 1578
  i = 0;
#line 1578
  while (i < channels_alloc) {
#line 1579
    c = *(channels + i);
#line 1580
    if ((unsigned int )c == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 1587
    if (compat13) {
#line 1588
      if (c->type != 4) {
#line 1588
        if (c->type != 8) {
          goto __Cont;
        }
      }
    } else {
#line 1592
      if (c->type != 4) {
        goto __Cont;
      }
    }
#line 1595
    if (compat20) {
#line 1595
      if (c->flags & 3) {
#line 1598
        debug3("channel %d: will not send data after close", c->self);
        goto __Cont;
      }
    }
#line 1603
    if (c->istate == 0U) {
      goto _L___0;
    } else {
#line 1603
      if (c->istate == 1U) {
        _L___0: /* CIL Label */ 
#line 1603
        len = buffer_len(& c->input);
#line 1603
        if (len > 0U) {
#line 1610
          if (compat20) {
#line 1611
            if (len > c->remote_window) {
#line 1612
              len = c->remote_window;
            }
#line 1613
            if (len > c->remote_maxpacket) {
#line 1614
              len = c->remote_maxpacket;
            }
          } else {
#line 1616
            tmp = packet_is_interactive();
#line 1616
            if (tmp) {
#line 1617
              if (len > 1024U) {
#line 1618
                len = 512U;
              }
            } else {
#line 1621
              if (len > (u_int )(max_packet_size / 2)) {
#line 1622
                len = (unsigned int )(max_packet_size / 2);
              }
            }
          }
#line 1625
          if (len > 0U) {
#line 1626
            if (compat20) {
#line 1626
              tmp___0 = 94;
            } else {
#line 1626
              tmp___0 = 23;
            }
#line 1626
            packet_start((unsigned char )tmp___0);
#line 1628
            packet_put_int((unsigned int )c->remote_id);
#line 1629
            tmp___1 = buffer_ptr(& c->input);
#line 1629
            packet_put_string((void const   *)tmp___1, len);
#line 1630
            packet_send();
#line 1631
            buffer_consume(& c->input, len);
#line 1632
            c->remote_window -= len;
          }
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 1634
        if (c->istate == 1U) {
#line 1635
          if (compat13) {
#line 1636
            fatal("cannot happen: istate == INPUT_WAIT_DRAIN for proto 1.3");
          }
#line 1642
          if (compat20) {
#line 1642
            if (c->extended_usage == 1) {
#line 1642
              if (c->efd != -1) {
#line 1643
                tmp___2 = buffer_len(& c->extended);
#line 1643
                debug2("channel %d: ibuf_empty delayed efd %d/(%d)", c->self, c->efd,
                       tmp___2);
              } else {
#line 1642
                tmp___3 = buffer_len(& c->extended);
#line 1642
                if (tmp___3 > 0U) {
#line 1643
                  tmp___2 = buffer_len(& c->extended);
#line 1643
                  debug2("channel %d: ibuf_empty delayed efd %d/(%d)", c->self, c->efd,
                         tmp___2);
                } else {
#line 1646
                  chan_ibuf_empty(c);
                }
              }
            } else {
#line 1646
              chan_ibuf_empty(c);
            }
          } else {
#line 1646
            chan_ibuf_empty(c);
          }
        }
      }
    }
#line 1649
    if (compat20) {
#line 1649
      if (! (c->flags & 4)) {
#line 1649
        if (c->remote_window > 0U) {
#line 1649
          len = buffer_len(& c->extended);
#line 1649
          if (len > 0U) {
#line 1649
            if (c->extended_usage == 1) {
#line 1654
              tmp___4 = buffer_len(& c->extended);
#line 1654
              debug2("channel %d: rwin %u elen %u euse %d", c->self, c->remote_window,
                     tmp___4, c->extended_usage);
#line 1657
              if (len > c->remote_window) {
#line 1658
                len = c->remote_window;
              }
#line 1659
              if (len > c->remote_maxpacket) {
#line 1660
                len = c->remote_maxpacket;
              }
#line 1661
              packet_start((unsigned char)95);
#line 1662
              packet_put_int((unsigned int )c->remote_id);
#line 1663
              packet_put_int(1U);
#line 1664
              tmp___5 = buffer_ptr(& c->extended);
#line 1664
              packet_put_string((void const   *)tmp___5, len);
#line 1665
              packet_send();
#line 1666
              buffer_consume(& c->extended, len);
#line 1667
              c->remote_window -= len;
#line 1668
              debug2("channel %d: sent ext data %d", c->self, len);
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1578
    i ++;
  }
#line 1671
  return;
}
}
#line 1676 "channels.c"
void channel_input_data(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  char *data ;
  u_int data_len ;
  Channel *c ;
  u_int tmp ;
  void *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1685
  tmp = packet_get_int();
#line 1685
  id = (int )tmp;
#line 1686
  c = channel_lookup(id);
#line 1687
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1688
    packet_disconnect("Received data for nonexistent channel %d.", id);
  }
#line 1691
  if (c->type != 4) {
#line 1691
    if (c->type != 7) {
#line 1693
      return;
    }
  }
#line 1696
  if (! compat13) {
#line 1696
    if (c->ostate != 0U) {
#line 1697
      return;
    }
  }
#line 1700
  tmp___0 = packet_get_string(& data_len);
#line 1700
  data = (char *)tmp___0;
#line 1702
  if (compat20) {
#line 1703
    if (data_len > c->local_maxpacket) {
#line 1704
      log("channel %d: rcvd big packet %d, maxpack %d", c->self, data_len, c->local_maxpacket);
    }
#line 1707
    if (data_len > c->local_window) {
#line 1708
      log("channel %d: rcvd too much data %d, win %d", c->self, data_len, c->local_window);
#line 1710
      xfree((void *)data);
#line 1711
      return;
    }
#line 1713
    c->local_window -= data_len;
  }
#line 1715
  while (1) {
#line 1715
    tmp___1 = packet_remaining();
#line 1715
    _len = tmp___1;
#line 1715
    if (_len > 0) {
#line 1715
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1715);
#line 1715
      packet_disconnect("Packet integrity error.");
    }
#line 1715
    break;
  }
#line 1716
  buffer_append(& c->output, (void const   *)data, data_len);
#line 1717
  xfree((void *)data);
#line 1718
  return;
}
}
#line 1720 "channels.c"
void channel_input_extended_data(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  char *data ;
  u_int data_len ;
  u_int tcode ;
  Channel *c ;
  u_int tmp ;
  void *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1729
  tmp = packet_get_int();
#line 1729
  id = (int )tmp;
#line 1730
  c = channel_lookup(id);
#line 1732
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1733
    packet_disconnect("Received extended_data for bad channel %d.", id);
  }
#line 1734
  if (c->type != 4) {
#line 1735
    log("channel %d: ext data for non open", id);
#line 1736
    return;
  }
#line 1738
  if (c->flags & 8) {
#line 1739
    if (datafellows & 2097152) {
#line 1740
      debug("channel %d: accepting ext data after eof", id);
    } else {
#line 1742
      packet_disconnect("Received extended_data after EOF on channel %d.", id);
    }
  }
#line 1745
  tcode = packet_get_int();
#line 1746
  if (c->efd == -1) {
#line 1749
    log("channel %d: bad ext data", c->self);
#line 1750
    return;
  } else {
#line 1746
    if (c->extended_usage != 2) {
#line 1749
      log("channel %d: bad ext data", c->self);
#line 1750
      return;
    } else {
#line 1746
      if (tcode != 1U) {
#line 1749
        log("channel %d: bad ext data", c->self);
#line 1750
        return;
      }
    }
  }
#line 1752
  tmp___0 = packet_get_string(& data_len);
#line 1752
  data = (char *)tmp___0;
#line 1753
  while (1) {
#line 1753
    tmp___1 = packet_remaining();
#line 1753
    _len = tmp___1;
#line 1753
    if (_len > 0) {
#line 1753
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1753);
#line 1753
      packet_disconnect("Packet integrity error.");
    }
#line 1753
    break;
  }
#line 1754
  if (data_len > c->local_window) {
#line 1755
    log("channel %d: rcvd too much extended_data %d, win %d", c->self, data_len, c->local_window);
#line 1757
    xfree((void *)data);
#line 1758
    return;
  }
#line 1760
  debug2("channel %d: rcvd ext data %d", c->self, data_len);
#line 1761
  c->local_window -= data_len;
#line 1762
  buffer_append(& c->extended, (void const   *)data, data_len);
#line 1763
  xfree((void *)data);
#line 1764
  return;
}
}
#line 1766 "channels.c"
void channel_input_ieof(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  Channel *c ;
  u_int tmp ;
  int _len ;
  int tmp___0 ;
  u_int tmp___1 ;

  {
#line 1772
  tmp = packet_get_int();
#line 1772
  id = (int )tmp;
#line 1773
  while (1) {
#line 1773
    tmp___0 = packet_remaining();
#line 1773
    _len = tmp___0;
#line 1773
    if (_len > 0) {
#line 1773
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1773);
#line 1773
      packet_disconnect("Packet integrity error.");
    }
#line 1773
    break;
  }
#line 1774
  c = channel_lookup(id);
#line 1775
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1776
    packet_disconnect("Received ieof for nonexistent channel %d.", id);
  }
#line 1777
  chan_rcvd_ieof(c);
#line 1780
  if (c->force_drain) {
#line 1780
    if (c->istate == 0U) {
#line 1781
      debug("channel %d: FORCE input drain", c->self);
#line 1782
      c->istate = 1U;
#line 1783
      tmp___1 = buffer_len(& c->input);
#line 1783
      if (tmp___1 == 0U) {
#line 1784
        chan_ibuf_empty(c);
      }
    }
  }
#line 1787
  return;
}
}
#line 1789 "channels.c"
void channel_input_close(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  Channel *c ;
  u_int tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 1795
  tmp = packet_get_int();
#line 1795
  id = (int )tmp;
#line 1796
  while (1) {
#line 1796
    tmp___0 = packet_remaining();
#line 1796
    _len = tmp___0;
#line 1796
    if (_len > 0) {
#line 1796
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1796);
#line 1796
      packet_disconnect("Packet integrity error.");
    }
#line 1796
    break;
  }
#line 1797
  c = channel_lookup(id);
#line 1798
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1799
    packet_disconnect("Received close for nonexistent channel %d.", id);
  }
#line 1805
  packet_start((unsigned char)25);
#line 1806
  packet_put_int((unsigned int )c->remote_id);
#line 1807
  packet_send();
#line 1816
  if (c->type != 5) {
#line 1821
    buffer_clear(& c->input);
#line 1822
    c->type = 9;
  }
#line 1824
  return;
}
}
#line 1827 "channels.c"
void channel_input_oclose(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  u_int tmp ;
  Channel *c ;
  Channel *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1830
  tmp = packet_get_int();
#line 1830
  id = (int )tmp;
#line 1831
  tmp___0 = channel_lookup(id);
#line 1831
  c = tmp___0;
#line 1833
  while (1) {
#line 1833
    tmp___1 = packet_remaining();
#line 1833
    _len = tmp___1;
#line 1833
    if (_len > 0) {
#line 1833
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1833);
#line 1833
      packet_disconnect("Packet integrity error.");
    }
#line 1833
    break;
  }
#line 1834
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1835
    packet_disconnect("Received oclose for nonexistent channel %d.", id);
  }
#line 1836
  chan_rcvd_oclose(c);
#line 1837
  return;
}
}
#line 1839 "channels.c"
void channel_input_close_confirmation(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  u_int tmp ;
  Channel *c ;
  Channel *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1842
  tmp = packet_get_int();
#line 1842
  id = (int )tmp;
#line 1843
  tmp___0 = channel_lookup(id);
#line 1843
  c = tmp___0;
#line 1845
  while (1) {
#line 1845
    tmp___1 = packet_remaining();
#line 1845
    _len = tmp___1;
#line 1845
    if (_len > 0) {
#line 1845
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1845);
#line 1845
      packet_disconnect("Packet integrity error.");
    }
#line 1845
    break;
  }
#line 1846
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1847
    packet_disconnect("Received close confirmation for out-of-range channel %d.",
                      id);
  }
#line 1849
  if (c->type != 5) {
#line 1850
    packet_disconnect("Received close confirmation for non-closed channel %d (type %d).",
                      id, c->type);
  }
#line 1852
  channel_free(c);
#line 1853
  return;
}
}
#line 1855 "channels.c"
void channel_input_open_confirmation(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  int remote_id ;
  Channel *c ;
  u_int tmp ;
  u_int tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1861
  tmp = packet_get_int();
#line 1861
  id = (int )tmp;
#line 1862
  c = channel_lookup(id);
#line 1864
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1865
    packet_disconnect("Received open confirmation for non-opening channel %d.", id);
  } else {
#line 1864
    if (c->type != 3) {
#line 1865
      packet_disconnect("Received open confirmation for non-opening channel %d.",
                        id);
    }
  }
#line 1867
  tmp___0 = packet_get_int();
#line 1867
  remote_id = (int )tmp___0;
#line 1869
  c->remote_id = remote_id;
#line 1870
  c->type = 4;
#line 1872
  if (compat20) {
#line 1873
    c->remote_window = packet_get_int();
#line 1874
    c->remote_maxpacket = packet_get_int();
#line 1875
    if (c->confirm) {
#line 1876
      debug2("callback start");
#line 1877
      (*(c->confirm))(c->self, (void *)0);
#line 1878
      debug2("callback done");
    }
#line 1880
    debug("channel %d: open confirm rwindow %u rmax %u", c->self, c->remote_window,
          c->remote_maxpacket);
  }
#line 1883
  while (1) {
#line 1883
    tmp___1 = packet_remaining();
#line 1883
    _len = tmp___1;
#line 1883
    if (_len > 0) {
#line 1883
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1883);
#line 1883
      packet_disconnect("Packet integrity error.");
    }
#line 1883
    break;
  }
#line 1884
  return;
}
}
#line 1886 "channels.c"
static char *reason2txt(int reason ) 
{ 

  {
#line 1889
  switch (reason) {
  case 1: 
#line 1891
  return ((char *)"administratively prohibited");
  case 2: 
#line 1893
  return ((char *)"connect failed");
  case 3: 
#line 1895
  return ((char *)"unknown channel type");
  case 4: 
#line 1897
  return ((char *)"resource shortage");
  }
#line 1899
  return ((char *)"unknown reason");
}
}
#line 1902 "channels.c"
void channel_input_open_failure(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  int reason ;
  char *msg ;
  char *lang ;
  Channel *c ;
  u_int tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  int _len ;
  int tmp___6 ;

  {
#line 1906
  msg = (char *)((void *)0);
#line 1906
  lang = (char *)((void *)0);
#line 1909
  tmp = packet_get_int();
#line 1909
  id = (int )tmp;
#line 1910
  c = channel_lookup(id);
#line 1912
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1913
    packet_disconnect("Received open failure for non-opening channel %d.", id);
  } else {
#line 1912
    if (c->type != 3) {
#line 1913
      packet_disconnect("Received open failure for non-opening channel %d.", id);
    }
  }
#line 1915
  if (compat20) {
#line 1916
    tmp___0 = packet_get_int();
#line 1916
    reason = (int )tmp___0;
#line 1917
    if (! (datafellows & 131072)) {
#line 1918
      tmp___1 = packet_get_string((u_int *)((void *)0));
#line 1918
      msg = (char *)tmp___1;
#line 1919
      tmp___2 = packet_get_string((u_int *)((void *)0));
#line 1919
      lang = (char *)tmp___2;
    }
#line 1921
    if (msg) {
#line 1921
      tmp___3 = (char const   *)msg;
    } else {
#line 1921
      tmp___3 = "";
    }
#line 1921
    if (msg) {
#line 1921
      tmp___4 = ": ";
    } else {
#line 1921
      tmp___4 = "";
    }
#line 1921
    tmp___5 = reason2txt(reason);
#line 1921
    log("channel %d: open failed: %s%s%s", id, tmp___5, tmp___4, tmp___3);
#line 1923
    if ((unsigned int )msg != (unsigned int )((void *)0)) {
#line 1924
      xfree((void *)msg);
    }
#line 1925
    if ((unsigned int )lang != (unsigned int )((void *)0)) {
#line 1926
      xfree((void *)lang);
    }
  }
#line 1928
  while (1) {
#line 1928
    tmp___6 = packet_remaining();
#line 1928
    _len = tmp___6;
#line 1928
    if (_len > 0) {
#line 1928
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1928);
#line 1928
      packet_disconnect("Packet integrity error.");
    }
#line 1928
    break;
  }
#line 1930
  channel_free(c);
#line 1931
  return;
}
}
#line 1933 "channels.c"
void channel_input_window_adjust(int type , u_int32_t seq , void *ctxt ) 
{ Channel *c ;
  int id ;
  u_int adjust ;
  u_int tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 1940
  if (! compat20) {
#line 1941
    return;
  }
#line 1944
  tmp = packet_get_int();
#line 1944
  id = (int )tmp;
#line 1945
  c = channel_lookup(id);
#line 1947
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1948
    log("Received window adjust for non-open channel %d.", id);
#line 1950
    return;
  } else {
#line 1947
    if (c->type != 4) {
#line 1948
      log("Received window adjust for non-open channel %d.", id);
#line 1950
      return;
    }
  }
#line 1952
  adjust = packet_get_int();
#line 1953
  while (1) {
#line 1953
    tmp___0 = packet_remaining();
#line 1953
    _len = tmp___0;
#line 1953
    if (_len > 0) {
#line 1953
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1953);
#line 1953
      packet_disconnect("Packet integrity error.");
    }
#line 1953
    break;
  }
#line 1954
  debug2("channel %d: rcvd adjust %u", id, adjust);
#line 1955
  c->remote_window += adjust;
#line 1956
  return;
}
}
#line 1958 "channels.c"
void channel_input_port_open(int type , u_int32_t seq , void *ctxt ) 
{ Channel *c ;
  u_short host_port ;
  char *host ;
  char *originator_string ;
  int remote_id ;
  int sock ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  u_int tmp___3 ;
  int _len ;
  int tmp___4 ;

  {
#line 1961
  c = (Channel *)((void *)0);
#line 1964
  sock = -1;
#line 1966
  tmp = packet_get_int();
#line 1966
  remote_id = (int )tmp;
#line 1967
  tmp___0 = packet_get_string((u_int *)((void *)0));
#line 1967
  host = (char *)tmp___0;
#line 1968
  tmp___1 = packet_get_int();
#line 1968
  host_port = (unsigned short )tmp___1;
#line 1970
  tmp___3 = packet_get_protocol_flags();
#line 1970
  if (tmp___3 & 2U) {
#line 1971
    tmp___2 = packet_get_string((u_int *)((void *)0));
#line 1971
    originator_string = (char *)tmp___2;
  } else {
#line 1973
    originator_string = xstrdup("unknown (remote did not supply name)");
  }
#line 1975
  while (1) {
#line 1975
    tmp___4 = packet_remaining();
#line 1975
    _len = tmp___4;
#line 1975
    if (_len > 0) {
#line 1975
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1975);
#line 1975
      packet_disconnect("Packet integrity error.");
    }
#line 1975
    break;
  }
#line 1976
  sock = channel_connect_to((char const   *)host, host_port);
#line 1977
  if (sock != -1) {
#line 1978
    c = channel_new((char *)"connected socket", 12, sock, sock, -1, 0U, 0U, 0, originator_string,
                    1);
#line 1981
    c->remote_id = remote_id;
  }
#line 1983
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1984
    packet_start((unsigned char)22);
#line 1985
    packet_put_int((unsigned int )remote_id);
#line 1986
    packet_send();
  }
#line 1988
  xfree((void *)host);
#line 1989
  return;
}
}
#line 1994 "channels.c"
void channel_set_af(int af ) 
{ 

  {
#line 1997
  IPv4or6___0 = af;
#line 1998
  return;
}
}
#line 2000 "channels.c"
static int channel_setup_fwd_listener(int type , char const   *listen_addr , u_short listen_port ,
                                      char const   *host_to_connect , u_short port_to_connect ,
                                      int gateway_ports ) 
{ Channel *c ;
  int success ;
  int sock ;
  int on ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char const   *host ;
  char ntop[1025] ;
  char strport[32] ;
  struct linger linger ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;

  {
#line 2005
  on = 1;
#line 2011
  success = 0;
#line 2012
  if (type == 11) {
#line 2012
    host = listen_addr;
  } else {
#line 2012
    host = host_to_connect;
  }
#line 2015
  if ((unsigned int )host == (unsigned int )((void *)0)) {
#line 2016
    error("No forward host name.");
#line 2017
    return (success);
  }
#line 2019
  tmp = strlen(host);
#line 2019
  if (tmp > 255U) {
#line 2020
    error("Forward host name too long.");
#line 2021
    return (success);
  }
#line 2028
  memset((void *)(& hints), 0, sizeof(hints));
#line 2029
  hints.ai_family = IPv4or6___0;
#line 2030
  if (gateway_ports) {
#line 2030
    hints.ai_flags = 1;
  } else {
#line 2030
    hints.ai_flags = 0;
  }
#line 2031
  hints.ai_socktype = 1;
#line 2032
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           listen_port);
#line 2033
  tmp___0 = getaddrinfo((char const   * __restrict  )((void *)0), (char const   * __restrict  )(strport),
                        (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 2033
  if (tmp___0 != 0) {
#line 2034
    packet_disconnect("getaddrinfo: fatal error");
  }
#line 2036
  ai = aitop;
#line 2036
  while (ai) {
#line 2037
    if (ai->ai_family != 2) {
#line 2037
      if (ai->ai_family != 10) {
        goto __Cont;
      }
    }
#line 2039
    tmp___1 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                          (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )(strport),
                          sizeof(strport), 3U);
#line 2039
    if (tmp___1 != 0) {
#line 2041
      error("channel_setup_fwd_listener: getnameinfo failed");
      goto __Cont;
    }
#line 2045
    sock = socket(ai->ai_family, 1, 0);
#line 2046
    if (sock < 0) {
#line 2048
      tmp___2 = __errno_location();
#line 2048
      tmp___3 = strerror(*tmp___2);
#line 2048
      verbose("socket: %.100s", tmp___3);
      goto __Cont;
    }
#line 2055
    setsockopt(sock, 1, 2, (void const   *)(& on), sizeof(on));
#line 2056
    linger.l_onoff = 1;
#line 2057
    linger.l_linger = 5;
#line 2058
    setsockopt(sock, 1, 13, (void const   *)(& linger), sizeof(linger));
#line 2059
    debug("Local forwarding listening on %s port %s.", ntop, strport);
#line 2062
    tmp___8 = bind(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 2062
    if (tmp___8 < 0) {
#line 2064
      if (! ai->ai_next) {
#line 2065
        tmp___4 = __errno_location();
#line 2065
        tmp___5 = strerror(*tmp___4);
#line 2065
        error("bind: %.100s", tmp___5);
      } else {
#line 2067
        tmp___6 = __errno_location();
#line 2067
        tmp___7 = strerror(*tmp___6);
#line 2067
        verbose("bind: %.100s", tmp___7);
      }
#line 2069
      close(sock);
      goto __Cont;
    }
#line 2073
    tmp___11 = listen(sock, 5);
#line 2073
    if (tmp___11 < 0) {
#line 2074
      tmp___9 = __errno_location();
#line 2074
      tmp___10 = strerror(*tmp___9);
#line 2074
      error("listen: %.100s", tmp___10);
#line 2075
      close(sock);
      goto __Cont;
    }
#line 2079
    tmp___12 = xstrdup("port listener");
#line 2079
    c = channel_new((char *)"port listener", type, sock, sock, -1, 131072U, 32768U,
                    0, tmp___12, 1);
#line 2082
    strlcpy(c->path, host, sizeof(c->path));
#line 2083
    c->host_port = (int )port_to_connect;
#line 2084
    c->listening_port = (int )listen_port;
#line 2085
    success = 1;
    __Cont: /* CIL Label */ 
#line 2036
    ai = ai->ai_next;
  }
#line 2087
  if (success == 0) {
#line 2088
    error("channel_setup_fwd_listener: cannot listen to port: %d", listen_port);
  }
#line 2090
  freeaddrinfo(aitop);
#line 2091
  return (success);
}
}
#line 2095 "channels.c"
int channel_setup_local_fwd_listener(u_short listen_port , char const   *host_to_connect ,
                                     u_short port_to_connect , int gateway_ports ) 
{ int tmp ;

  {
#line 2099
  tmp = channel_setup_fwd_listener(2, (char const   *)((void *)0), listen_port, host_to_connect,
                                   port_to_connect, gateway_ports);
#line 2099
  return (tmp);
}
}
#line 2104 "channels.c"
int channel_setup_remote_fwd_listener(char const   *listen_address , u_short listen_port ,
                                      int gateway_ports ) 
{ int tmp ;

  {
#line 2108
  tmp = channel_setup_fwd_listener(11, listen_address, listen_port, (char const   *)((void *)0),
                                   (unsigned short)0, gateway_ports);
#line 2108
  return (tmp);
}
}
#line 2117 "channels.c"
void channel_request_remote_forwarding(u_short listen_port , char const   *host_to_connect ,
                                       u_short port_to_connect ) 
{ int type ;
  int success ;
  char const   *address_to_bind ;

  {
#line 2121
  success = 0;
#line 2124
  if (num_permitted_opens >= 100) {
#line 2125
    fatal("channel_request_remote_forwarding: too many forwards");
  }
#line 2128
  if (compat20) {
#line 2129
    address_to_bind = "0.0.0.0";
#line 2130
    packet_start((unsigned char)80);
#line 2131
    packet_put_cstring("tcpip-forward");
#line 2132
    packet_put_char(1);
#line 2133
    packet_put_cstring(address_to_bind);
#line 2134
    packet_put_int((unsigned int )listen_port);
#line 2135
    packet_send();
#line 2136
    packet_write_wait();
#line 2138
    success = 1;
  } else {
#line 2140
    packet_start((unsigned char)28);
#line 2141
    packet_put_int((unsigned int )listen_port);
#line 2142
    packet_put_cstring(host_to_connect);
#line 2143
    packet_put_int((unsigned int )port_to_connect);
#line 2144
    packet_send();
#line 2145
    packet_write_wait();
#line 2148
    type = packet_read();
#line 2149
    switch (type) {
    case 14: 
#line 2151
    success = 1;
#line 2152
    break;
    case 15: 
#line 2154
    log("Warning: Server denied remote port forwarding.");
#line 2155
    break;
    default: 
#line 2158
    packet_disconnect("Protocol error for port forward request:received packet type %d.",
                      type);
    }
  }
#line 2162
  if (success) {
#line 2163
    permitted_opens[num_permitted_opens].host_to_connect = xstrdup(host_to_connect);
#line 2164
    permitted_opens[num_permitted_opens].port_to_connect = port_to_connect;
#line 2165
    permitted_opens[num_permitted_opens].listen_port = listen_port;
#line 2166
    num_permitted_opens ++;
  }
#line 2168
  return;
}
}
#line 2176 "channels.c"
void channel_input_port_forward_request(int is_root , int gateway_ports ) 
{ u_short port ;
  u_short host_port ;
  char *hostname ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;

  {
#line 2183
  tmp = packet_get_int();
#line 2183
  port = (unsigned short )tmp;
#line 2184
  tmp___0 = packet_get_string((u_int *)((void *)0));
#line 2184
  hostname = (char *)tmp___0;
#line 2185
  tmp___1 = packet_get_int();
#line 2185
  host_port = (unsigned short )tmp___1;
#line 2192
  if ((int )port < 1024) {
#line 2192
    if (! is_root) {
#line 2193
      packet_disconnect("Requested forwarding of port %d but user is not root.", port);
    }
  }
#line 2197
  channel_setup_local_fwd_listener(port, (char const   *)hostname, host_port, gateway_ports);
#line 2200
  xfree((void *)hostname);
#line 2201
  return;
}
}
#line 2208 "channels.c"
void channel_permit_all_opens(void) 
{ 

  {
#line 2211
  if (num_permitted_opens == 0) {
#line 2212
    all_opens_permitted = 1;
  }
#line 2213
  return;
}
}
#line 2215 "channels.c"
void channel_add_permitted_opens(char *host , int port ) 
{ 

  {
#line 2218
  if (num_permitted_opens >= 100) {
#line 2219
    fatal("channel_request_remote_forwarding: too many forwards");
  }
#line 2220
  debug("allow port forwarding to host %s port %d", host, port);
#line 2222
  permitted_opens[num_permitted_opens].host_to_connect = xstrdup((char const   *)host);
#line 2223
  permitted_opens[num_permitted_opens].port_to_connect = (unsigned short )port;
#line 2224
  num_permitted_opens ++;
#line 2226
  all_opens_permitted = 0;
#line 2227
  return;
}
}
#line 2229 "channels.c"
void channel_clear_permitted_opens(void) 
{ int i ;

  {
#line 2234
  i = 0;
#line 2234
  while (i < num_permitted_opens) {
#line 2235
    xfree((void *)permitted_opens[i].host_to_connect);
#line 2234
    i ++;
  }
#line 2236
  num_permitted_opens = 0;
#line 2238
  return;
}
}
#line 2242 "channels.c"
static int connect_to(char const   *host , u_short port ) 
{ struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char ntop[1025] ;
  char strport[32] ;
  int gaierr ;
  int sock ;
  char const   *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;

  {
#line 2248
  sock = -1;
#line 2250
  memset((void *)(& hints), 0, sizeof(hints));
#line 2251
  hints.ai_family = IPv4or6___0;
#line 2252
  hints.ai_socktype = 1;
#line 2253
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           port);
#line 2254
  gaierr = getaddrinfo((char const   * __restrict  )host, (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 2254
  if (gaierr != 0) {
#line 2255
    tmp = gai_strerror(gaierr);
#line 2255
    error("connect_to %.100s: unknown host (%s)", host, tmp);
#line 2257
    return (-1);
  }
#line 2259
  ai = aitop;
#line 2259
  while (ai) {
#line 2260
    if (ai->ai_family != 2) {
#line 2260
      if (ai->ai_family != 10) {
        goto __Cont;
      }
    }
#line 2262
    tmp___0 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                          (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )(strport),
                          sizeof(strport), 3U);
#line 2262
    if (tmp___0 != 0) {
#line 2264
      error("connect_to: getnameinfo failed");
      goto __Cont;
    }
#line 2267
    sock = socket(ai->ai_family, 1, 0);
#line 2268
    if (sock < 0) {
#line 2269
      tmp___1 = __errno_location();
#line 2269
      tmp___2 = strerror(*tmp___1);
#line 2269
      error("socket: %.100s", tmp___2);
      goto __Cont;
    }
#line 2272
    tmp___5 = fcntl(sock, 4, 2048);
#line 2272
    if (tmp___5 < 0) {
#line 2273
      tmp___3 = __errno_location();
#line 2273
      tmp___4 = strerror(*tmp___3);
#line 2273
      fatal("connect_to: F_SETFL: %s", tmp___4);
    }
#line 2274
    tmp___8 = connect(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 2274
    if (tmp___8 < 0) {
#line 2274
      tmp___9 = __errno_location();
#line 2274
      if (*tmp___9 != 115) {
#line 2276
        tmp___6 = __errno_location();
#line 2276
        tmp___7 = strerror(*tmp___6);
#line 2276
        error("connect_to %.100s port %s: %.100s", ntop, strport, tmp___7);
#line 2278
        close(sock);
        goto __Cont;
      }
    }
#line 2281
    break;
    __Cont: /* CIL Label */ 
#line 2259
    ai = ai->ai_next;
  }
#line 2284
  freeaddrinfo(aitop);
#line 2285
  if (! ai) {
#line 2286
    error("connect_to %.100s port %d: failed.", host, port);
#line 2287
    return (-1);
  }
#line 2290
  set_nodelay(sock);
#line 2291
  return (sock);
}
}
#line 2294 "channels.c"
int channel_connect_by_listen_address(u_short listen_port ) 
{ int i ;
  int tmp ;

  {
#line 2299
  i = 0;
#line 2299
  while (i < num_permitted_opens) {
#line 2300
    if ((int )permitted_opens[i].listen_port == (int )listen_port) {
#line 2301
      tmp = connect_to((char const   *)permitted_opens[i].host_to_connect, permitted_opens[i].port_to_connect);
#line 2301
      return (tmp);
    }
#line 2299
    i ++;
  }
#line 2304
  error("WARNING: Server requests forwarding for unknown listen_port %d", listen_port);
#line 2306
  return (-1);
}
}
#line 2310 "channels.c"
int channel_connect_to(char const   *host , u_short port ) 
{ int i ;
  int permit ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 2315
  permit = all_opens_permitted;
#line 2316
  if (! permit) {
#line 2317
    i = 0;
#line 2317
    while (i < num_permitted_opens) {
#line 2319
      if ((int )permitted_opens[i].port_to_connect == (int )port) {
#line 2319
        if (0) {
#line 2319
          __s1_len = strlen((char const   *)permitted_opens[i].host_to_connect);
#line 2319
          __s2_len = strlen(host);
#line 2319
          if (! ((unsigned int )((void const   *)(permitted_opens[i].host_to_connect + 1)) - (unsigned int )((void const   *)permitted_opens[i].host_to_connect) == 1U)) {
            goto _L___0;
          } else {
#line 2319
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 2319
              if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
#line 2319
                tmp___8 = 1;
              } else {
#line 2319
                if (__s2_len >= 4U) {
#line 2319
                  tmp___8 = 1;
                } else {
#line 2319
                  tmp___8 = 0;
                }
              }
            } else {
#line 2319
              tmp___8 = 0;
            }
          }
#line 2319
          if (tmp___8) {
#line 2319
            tmp___4 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                       host);
          } else {
#line 2319
            tmp___7 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                       host);
#line 2319
            tmp___4 = tmp___7;
          }
        } else {
#line 2319
          tmp___7 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                     host);
#line 2319
          tmp___4 = tmp___7;
        }
#line 2319
        if (tmp___4 == 0) {
#line 2320
          permit = 1;
        }
      }
#line 2317
      i ++;
    }
  }
#line 2323
  if (! permit) {
#line 2324
    log("Received request to connect to host %.100s port %d, but the request was denied.",
        host, port);
#line 2326
    return (-1);
  }
#line 2328
  tmp___9 = connect_to(host, port);
#line 2328
  return (tmp___9);
}
}
#line 2338 "channels.c"
int x11_create_display_inet(int x11_display_offset , int x11_use_localhost , int single_connection ,
                            u_int *display_numberp ) 
{ Channel *nc ;
  int display_number ;
  int sock ;
  u_short port ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  int n___0 ;
  int num_socks ;
  int socks[10] ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int on ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;

  {
#line 2342
  nc = (Channel *)((void *)0);
#line 2347
  num_socks = 0;
#line 2349
  display_number = x11_display_offset;
#line 2349
  while (display_number < 1000) {
#line 2352
    port = (unsigned short )(6000 + display_number);
#line 2353
    memset((void *)(& hints), 0, sizeof(hints));
#line 2354
    hints.ai_family = IPv4or6___0;
#line 2355
    if (x11_use_localhost) {
#line 2355
      hints.ai_flags = 0;
    } else {
#line 2355
      hints.ai_flags = 1;
    }
#line 2356
    hints.ai_socktype = 1;
#line 2357
    snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
             port);
#line 2358
    gaierr = getaddrinfo((char const   * __restrict  )((void *)0), (char const   * __restrict  )(strport),
                         (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 2358
    if (gaierr != 0) {
#line 2359
      tmp = gai_strerror(gaierr);
#line 2359
      error("getaddrinfo: %.100s", tmp);
#line 2360
      return (-1);
    }
#line 2362
    ai = aitop;
#line 2362
    while (ai) {
#line 2363
      if (ai->ai_family != 2) {
#line 2363
        if (ai->ai_family != 10) {
          goto __Cont;
        }
      }
#line 2365
      sock = socket(ai->ai_family, 1, 0);
#line 2366
      if (sock < 0) {
#line 2367
        tmp___2 = __errno_location();
#line 2367
        if (*tmp___2 != 22) {
#line 2367
          tmp___3 = __errno_location();
#line 2367
          if (*tmp___3 != 97) {
#line 2368
            tmp___0 = __errno_location();
#line 2368
            tmp___1 = strerror(*tmp___0);
#line 2368
            error("socket: %.100s", tmp___1);
#line 2369
            return (-1);
          } else {
#line 2371
            debug("x11_create_display_inet: Socket family %d not supported", ai->ai_family);
            goto __Cont;
          }
        } else {
#line 2371
          debug("x11_create_display_inet: Socket family %d not supported", ai->ai_family);
          goto __Cont;
        }
      }
#line 2377
      if (ai->ai_family == 10) {
#line 2378
        on = 1;
#line 2379
        tmp___6 = setsockopt(sock, 41, 26, (void const   *)(& on), sizeof(on));
#line 2379
        if (tmp___6 < 0) {
#line 2380
          tmp___4 = __errno_location();
#line 2380
          tmp___5 = strerror(*tmp___4);
#line 2380
          error("setsockopt IPV6_V6ONLY: %.100s", tmp___5);
        }
      }
#line 2383
      tmp___9 = bind(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 2383
      if (tmp___9 < 0) {
#line 2384
        tmp___7 = __errno_location();
#line 2384
        tmp___8 = strerror(*tmp___7);
#line 2384
        debug("bind port %d: %.100s", port, tmp___8);
#line 2385
        close(sock);
#line 2387
        if (ai->ai_next) {
          goto __Cont;
        }
#line 2390
        n___0 = 0;
#line 2390
        while (n___0 < num_socks) {
#line 2391
          close(socks[n___0]);
#line 2390
          n___0 ++;
        }
#line 2393
        num_socks = 0;
#line 2394
        break;
      }
#line 2396
      tmp___10 = num_socks;
#line 2396
      num_socks ++;
#line 2396
      socks[tmp___10] = sock;
#line 2401
      if (x11_use_localhost) {
#line 2402
        if (num_socks == 10) {
#line 2403
          break;
        }
      } else {
#line 2405
        break;
      }
      __Cont: /* CIL Label */ 
#line 2362
      ai = ai->ai_next;
    }
#line 2409
    freeaddrinfo(aitop);
#line 2410
    if (num_socks > 0) {
#line 2411
      break;
    }
#line 2349
    display_number ++;
  }
#line 2413
  if (display_number >= 1000) {
#line 2414
    error("Failed to allocate internet-domain X11 display socket.");
#line 2415
    return (-1);
  }
#line 2418
  n___0 = 0;
#line 2418
  while (n___0 < num_socks) {
#line 2419
    sock = socks[n___0];
#line 2420
    tmp___13 = listen(sock, 5);
#line 2420
    if (tmp___13 < 0) {
#line 2421
      tmp___11 = __errno_location();
#line 2421
      tmp___12 = strerror(*tmp___11);
#line 2421
      error("listen: %.100s", tmp___12);
#line 2422
      close(sock);
#line 2423
      return (-1);
    }
#line 2418
    n___0 ++;
  }
#line 2428
  n___0 = 0;
#line 2428
  while (n___0 < num_socks) {
#line 2429
    sock = socks[n___0];
#line 2430
    tmp___14 = xstrdup("X11 inet listener");
#line 2430
    nc = channel_new((char *)"x11 listener", 1, sock, sock, -1, 65536U, 16384U, 0,
                     tmp___14, 1);
#line 2434
    nc->single_connection = single_connection;
#line 2428
    n___0 ++;
  }
#line 2438
  *display_numberp = (unsigned int )display_number;
#line 2439
  return (0);
}
}
#line 2442 "channels.c"
static int connect_local_xsocket(u_int dnr ) 
{ int sock ;
  struct sockaddr_un addr ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 2448
  sock = socket(1, 1, 0);
#line 2449
  if (sock < 0) {
#line 2450
    tmp = __errno_location();
#line 2450
    tmp___0 = strerror(*tmp);
#line 2450
    error("socket: %.100s", tmp___0);
  }
#line 2451
  memset((void *)(& addr), 0, sizeof(addr));
#line 2452
  addr.sun_family = (unsigned short)1;
#line 2453
  snprintf((char * __restrict  )(addr.sun_path), sizeof(addr.sun_path), (char const   * __restrict  )"/tmp/.X11-unix/X%u",
           dnr);
#line 2454
  tmp___1 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& addr)),
                    sizeof(addr));
#line 2454
  if (tmp___1 == 0) {
#line 2455
    return (sock);
  }
#line 2456
  close(sock);
#line 2457
  tmp___2 = __errno_location();
#line 2457
  tmp___3 = strerror(*tmp___2);
#line 2457
  error("connect %.100s: %.100s", addr.sun_path, tmp___3);
#line 2458
  return (-1);
}
}
#line 2461 "channels.c"
int x11_connect_display(void) 
{ int display_number ;
  int sock ;
  char const   *display ;
  char buf___1[1024] ;
  char *cp ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___29 ;
  int tmp___30 ;
  char const   *tmp___31 ;
  int *tmp___32 ;
  char *tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  int *tmp___37 ;
  char *tmp___38 ;

  {
#line 2464
  sock = 0;
#line 2472
  tmp = getenv("DISPLAY");
#line 2472
  display = (char const   *)tmp;
#line 2473
  if (! display) {
#line 2474
    error("DISPLAY not set.");
#line 2475
    return (-1);
  }
#line 2486
  if (0) {
#line 2486
    if (0) {
#line 2486
      __s1_len___0 = strlen(display);
#line 2486
      __s2_len___0 = strlen("unix:");
#line 2486
      if (! ((unsigned int )((void const   *)(display + 1)) - (unsigned int )((void const   *)display) == 1U)) {
        goto _L___2;
      } else {
#line 2486
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 2486
          if (! ((unsigned int )((void const   *)("unix:" + 1)) - (unsigned int )((void const   *)"unix:") == 1U)) {
#line 2486
            tmp___25 = 1;
          } else {
#line 2486
            if (__s2_len___0 >= 4U) {
#line 2486
              tmp___25 = 1;
            } else {
#line 2486
              tmp___25 = 0;
            }
          }
        } else {
#line 2486
          tmp___25 = 0;
        }
      }
#line 2486
      if (tmp___25) {
#line 2486
        tmp___21 = __builtin_strcmp(display, "unix:");
      } else {
#line 2486
        tmp___24 = __builtin_strcmp(display, "unix:");
#line 2486
        tmp___21 = tmp___24;
      }
    } else {
#line 2486
      tmp___24 = __builtin_strcmp(display, "unix:");
#line 2486
      tmp___21 = tmp___24;
    }
#line 2486
    tmp___15 = tmp___21;
  } else {
#line 2486
    tmp___15 = strncmp(display, "unix:", 5U);
  }
#line 2486
  if (tmp___15 == 0) {
    goto _L___3;
  } else {
#line 2486
    if ((int const   )*(display + 0) == 58) {
      _L___3: /* CIL Label */ 
#line 2489
      tmp___0 = strrchr(display, ':');
#line 2489
      tmp___1 = sscanf((char const   * __restrict  )(tmp___0 + 1), (char const   * __restrict  )"%d",
                       & display_number);
#line 2489
      if (tmp___1 != 1) {
#line 2490
        error("Could not parse display number from DISPLAY: %.100s", display);
#line 2492
        return (-1);
      }
#line 2495
      sock = connect_local_xsocket((unsigned int )display_number);
#line 2496
      if (sock < 0) {
#line 2497
        return (-1);
      }
#line 2500
      return (sock);
    }
  }
#line 2506
  strlcpy(buf___1, display, sizeof(buf___1));
#line 2507
  tmp___29 = __builtin_strchr(buf___1, ':');
#line 2507
  cp = tmp___29;
#line 2508
  if (! cp) {
#line 2509
    error("Could not find \':\' in DISPLAY: %.100s", display);
#line 2510
    return (-1);
  }
#line 2512
  *cp = (char)0;
#line 2514
  tmp___30 = sscanf((char const   * __restrict  )(cp + 1), (char const   * __restrict  )"%d",
                    & display_number);
#line 2514
  if (tmp___30 != 1) {
#line 2515
    error("Could not parse display number from DISPLAY: %.100s", display);
#line 2517
    return (-1);
  }
#line 2521
  memset((void *)(& hints), 0, sizeof(hints));
#line 2522
  hints.ai_family = IPv4or6___0;
#line 2523
  hints.ai_socktype = 1;
#line 2524
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           6000 + display_number);
#line 2525
  gaierr = getaddrinfo((char const   * __restrict  )(buf___1), (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 2525
  if (gaierr != 0) {
#line 2526
    tmp___31 = gai_strerror(gaierr);
#line 2526
    error("%.100s: unknown host. (%s)", buf___1, tmp___31);
#line 2527
    return (-1);
  }
#line 2529
  ai = aitop;
#line 2529
  while (ai) {
#line 2531
    sock = socket(ai->ai_family, 1, 0);
#line 2532
    if (sock < 0) {
#line 2533
      tmp___32 = __errno_location();
#line 2533
      tmp___33 = strerror(*tmp___32);
#line 2533
      debug("socket: %.100s", tmp___33);
      goto __Cont;
    }
#line 2537
    tmp___36 = connect(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 2537
    if (tmp___36 < 0) {
#line 2538
      tmp___34 = __errno_location();
#line 2538
      tmp___35 = strerror(*tmp___34);
#line 2538
      debug("connect %.100s port %d: %.100s", buf___1, 6000 + display_number, tmp___35);
#line 2540
      close(sock);
      goto __Cont;
    }
#line 2544
    break;
    __Cont: /* CIL Label */ 
#line 2529
    ai = ai->ai_next;
  }
#line 2546
  freeaddrinfo(aitop);
#line 2547
  if (! ai) {
#line 2548
    tmp___37 = __errno_location();
#line 2548
    tmp___38 = strerror(*tmp___37);
#line 2548
    error("connect %.100s port %d: %.100s", buf___1, 6000 + display_number, tmp___38);
#line 2550
    return (-1);
  }
#line 2552
  set_nodelay(sock);
#line 2553
  return (sock);
}
}
#line 2562 "channels.c"
void x11_input_open(int type , u_int32_t seq , void *ctxt ) 
{ Channel *c ;
  int remote_id ;
  int sock ;
  char *remote_host ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  int _len ;
  int tmp___2 ;

  {
#line 2565
  c = (Channel *)((void *)0);
#line 2566
  sock = 0;
#line 2569
  debug("Received X11 open request.");
#line 2571
  tmp = packet_get_int();
#line 2571
  remote_id = (int )tmp;
#line 2573
  tmp___1 = packet_get_protocol_flags();
#line 2573
  if (tmp___1 & 2U) {
#line 2574
    tmp___0 = packet_get_string((u_int *)((void *)0));
#line 2574
    remote_host = (char *)tmp___0;
  } else {
#line 2576
    remote_host = xstrdup("unknown (remote did not supply name)");
  }
#line 2578
  while (1) {
#line 2578
    tmp___2 = packet_remaining();
#line 2578
    _len = tmp___2;
#line 2578
    if (_len > 0) {
#line 2578
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          2578);
#line 2578
      packet_disconnect("Packet integrity error.");
    }
#line 2578
    break;
  }
#line 2581
  sock = x11_connect_display();
#line 2582
  if (sock != -1) {
#line 2584
    c = channel_new((char *)"connected x11 socket", 7, sock, sock, -1, 0U, 0U, 0,
                    remote_host, 1);
#line 2587
    c->remote_id = remote_id;
#line 2588
    c->force_drain = 1;
  }
#line 2590
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2592
    packet_start((unsigned char)22);
#line 2593
    packet_put_int((unsigned int )remote_id);
  } else {
#line 2596
    packet_start((unsigned char)21);
#line 2597
    packet_put_int((unsigned int )remote_id);
#line 2598
    packet_put_int((unsigned int )c->self);
  }
#line 2600
  packet_send();
#line 2601
  return;
}
}
#line 2604 "channels.c"
void deny_input_open(int type , u_int32_t seq , void *ctxt ) 
{ int rchan ;
  u_int tmp ;

  {
#line 2607
  tmp = packet_get_int();
#line 2607
  rchan = (int )tmp;
#line 2608
  switch (type) {
  case 31: 
#line 2610
  error("Warning: ssh server tried agent forwarding.");
#line 2611
  break;
  case 27: 
#line 2613
  error("Warning: ssh server tried X11 forwarding.");
#line 2614
  break;
  default: 
#line 2616
  error("deny_input_open: type %d", type);
#line 2617
  break;
  }
#line 2619
  error("Warning: this is probably a break in attempt by a malicious server.");
#line 2620
  packet_start((unsigned char)22);
#line 2621
  packet_put_int((unsigned int )rchan);
#line 2622
  packet_send();
#line 2623
  return;
}
}
#line 2630 "channels.c"
void x11_request_forwarding_with_spoofing(int client_session_id , char const   *proto ,
                                          char const   *data ) 
{ u_int data_len ;
  size_t tmp ;
  u_int i ;
  u_int value ;
  u_int len ;
  char *new_data ;
  int screen_number ;
  char const   *cp ;
  u_int32_t rand___0 ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;

  {
#line 2634
  tmp = strlen(data);
#line 2634
  data_len = tmp / 2U;
#line 2639
  rand___0 = (u_int32_t )0;
#line 2641
  tmp___0 = getenv("DISPLAY");
#line 2641
  cp = (char const   *)tmp___0;
#line 2642
  if (cp) {
#line 2643
    tmp___2 = __builtin_strchr((char *)cp, ':');
#line 2643
    cp = (char const   *)tmp___2;
  }
#line 2644
  if (cp) {
#line 2645
    tmp___4 = __builtin_strchr((char *)cp, '.');
#line 2645
    cp = (char const   *)tmp___4;
  }
#line 2646
  if (cp) {
#line 2647
    screen_number = atoi(cp + 1);
  } else {
#line 2649
    screen_number = 0;
  }
#line 2652
  x11_saved_proto = xstrdup(proto);
#line 2658
  tmp___5 = xmalloc(data_len);
#line 2658
  x11_saved_data = (char *)tmp___5;
#line 2659
  tmp___6 = xmalloc(data_len);
#line 2659
  x11_fake_data = (char *)tmp___6;
#line 2660
  i = 0U;
#line 2660
  while (i < data_len) {
#line 2661
    tmp___7 = sscanf((char const   * __restrict  )(data + 2U * i), (char const   * __restrict  )"%2x",
                     & value);
#line 2661
    if (tmp___7 != 1) {
#line 2662
      fatal("x11_request_forwarding: bad authentication data: %.100s", data);
    }
#line 2663
    if (i % 4U == 0U) {
#line 2664
      rand___0 = arc4random();
    }
#line 2665
    *(x11_saved_data + i) = (char )value;
#line 2666
    *(x11_fake_data + i) = (char )(rand___0 & 255U);
#line 2667
    rand___0 >>= 8;
#line 2660
    i ++;
  }
#line 2669
  x11_saved_data_len = data_len;
#line 2670
  x11_fake_data_len = data_len;
#line 2673
  len = 2U * data_len + 1U;
#line 2674
  tmp___8 = xmalloc(len);
#line 2674
  new_data = (char *)tmp___8;
#line 2675
  i = 0U;
#line 2675
  while (i < data_len) {
#line 2676
    snprintf((char * __restrict  )(new_data + 2U * i), len - 2U * i, (char const   * __restrict  )"%02x",
             (unsigned char )*(x11_fake_data + i));
#line 2675
    i ++;
  }
#line 2680
  if (compat20) {
#line 2681
    channel_request_start(client_session_id, (char *)"x11-req", 0);
#line 2682
    packet_put_char(0);
  } else {
#line 2684
    packet_start((unsigned char)34);
  }
#line 2686
  packet_put_cstring(proto);
#line 2687
  packet_put_cstring((char const   *)new_data);
#line 2688
  packet_put_int((unsigned int )screen_number);
#line 2689
  packet_send();
#line 2690
  packet_write_wait();
#line 2691
  xfree((void *)new_data);
#line 2692
  return;
}
}
#line 2699 "channels.c"
void auth_request_forwarding(void) 
{ 

  {
#line 2702
  packet_start((unsigned char)30);
#line 2703
  packet_send();
#line 2704
  packet_write_wait();
#line 2705
  return;
}
}
#line 2709 "channels.c"
void auth_input_open_request(int type , u_int32_t seq , void *ctxt ) 
{ Channel *c ;
  int remote_id ;
  int sock ;
  char *name ;
  u_int tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 2712
  c = (Channel *)((void *)0);
#line 2717
  tmp = packet_get_int();
#line 2717
  remote_id = (int )tmp;
#line 2718
  while (1) {
#line 2718
    tmp___0 = packet_remaining();
#line 2718
    _len = tmp___0;
#line 2718
    if (_len > 0) {
#line 2718
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          2718);
#line 2718
      packet_disconnect("Packet integrity error.");
    }
#line 2718
    break;
  }
#line 2724
  sock = ssh_get_authentication_socket();
#line 2732
  if (sock >= 0) {
#line 2733
    name = xstrdup("authentication agent connection");
#line 2734
    c = channel_new((char *)"", 4, sock, sock, -1, 0U, 0U, 0, name, 1);
#line 2736
    c->remote_id = remote_id;
#line 2737
    c->force_drain = 1;
  }
#line 2739
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2740
    packet_start((unsigned char)22);
#line 2741
    packet_put_int((unsigned int )remote_id);
  } else {
#line 2744
    debug("Forwarding authentication connection.");
#line 2745
    packet_start((unsigned char)21);
#line 2746
    packet_put_int((unsigned int )remote_id);
#line 2747
    packet_put_int((unsigned int )c->self);
  }
#line 2749
  packet_send();
#line 2750
  return;
}
}
#line 1 "cipher.o"
#line 325 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 1205 "/usr/include/bits/string2.h"
extern char *__strsep_g(char **__stringp , char const   *__delim ) ;
#line 527 "/usr/include/openssl/evp.h"
extern int EVP_CipherInit(EVP_CIPHER_CTX *ctx , EVP_CIPHER const   *cipher , unsigned char const   *key ,
                          unsigned char const   *iv , int enc ) ;
#line 567
extern void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *a ) ;
#line 568
extern int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *a ) ;
#line 571
extern int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x , int keylen ) ;
#line 613
extern EVP_CIPHER const   *EVP_enc_null(void) ;
#line 637
extern EVP_CIPHER const   *EVP_des_cbc(void) ;
#line 652
extern EVP_CIPHER const   *EVP_rc4(void) ;
#line 666
extern EVP_CIPHER const   *EVP_bf_cbc(void) ;
#line 673
extern EVP_CIPHER const   *EVP_cast5_cbc(void) ;
#line 680
extern EVP_CIPHER const   *EVP_aes_128_cbc(void) ;
#line 690
extern EVP_CIPHER const   *EVP_aes_192_cbc(void) ;
#line 700
extern EVP_CIPHER const   *EVP_aes_256_cbc(void) ;
#line 71 "cipher.h"
u_int cipher_mask_ssh1(int client ) ;
#line 72
Cipher *cipher_by_name(char const   *name ) ;
#line 74
int cipher_number(char const   *name ) ;
#line 75
char *cipher_name(int id ) ;
#line 76
int ciphers_valid(char const   *names ) ;
#line 77
void cipher_init(CipherContext *cc , Cipher *cipher , u_char const   *key , u_int keylen ,
                 u_char const   *iv , u_int ivlen , int encrypt ) ;
#line 82
u_int cipher_blocksize(Cipher *c ) ;
#line 83
u_int cipher_keylen(Cipher *c ) ;
#line 85
u_int cipher_get_number(Cipher *c ) ;
#line 86
void cipher_get_keyiv(CipherContext *cc , u_char *iv , u_int len ) ;
#line 87
void cipher_set_keyiv(CipherContext *cc , u_char *iv ) ;
#line 88
int cipher_get_keyiv_len(CipherContext *cc ) ;
#line 89
int cipher_get_keycontext(CipherContext *cc , u_char *dat ) ;
#line 90
void cipher_set_keycontext(CipherContext *cc , u_char *dat ) ;
#line 107 "/usr/include/openssl/md5.h"
extern int MD5_Init(MD5_CTX *c ) ;
#line 108
extern int MD5_Update(MD5_CTX *c , void const   *data , size_t len ) ;
#line 109
extern int MD5_Final(unsigned char *md , MD5_CTX *c ) ;
#line 55 "cipher.c"
static EVP_CIPHER const   *evp_ssh1_3des(void) ;
#line 56
static EVP_CIPHER const   *evp_ssh1_bf(void) ;
#line 58 "cipher.c"
struct Cipher ciphers[13]  = 
#line 58
  {      {(char *)"none", 0, (u_int )8, (u_int )0, & EVP_enc_null}, 
        {(char *)"des", 2, (u_int )8, (u_int )8, & EVP_des_cbc}, 
        {(char *)"3des", 3, (u_int )8, (u_int )16, & evp_ssh1_3des}, 
        {(char *)"blowfish", 6, (u_int )8, (u_int )32, & evp_ssh1_bf}, 
        {(char *)"3des-cbc", -3, (u_int )8, (u_int )24, & EVP_des_ede3_cbc}, 
        {(char *)"blowfish-cbc", -3, (u_int )8, (u_int )16, & EVP_bf_cbc}, 
        {(char *)"cast128-cbc", -3, (u_int )8, (u_int )16, & EVP_cast5_cbc}, 
        {(char *)"arcfour", -3, (u_int )8, (u_int )16, & EVP_rc4}, 
        {(char *)"aes128-cbc", -3, (u_int )16, (u_int )16, & EVP_aes_128_cbc}, 
        {(char *)"aes192-cbc", -3, (u_int )16, (u_int )24, & EVP_aes_192_cbc}, 
        {(char *)"aes256-cbc", -3, (u_int )16, (u_int )32, & EVP_aes_256_cbc}, 
        {(char *)"rijndael-cbc@lysator.liu.se", -3, (u_int )16, (u_int )32, & EVP_aes_256_cbc}, 
        {(char *)((void *)0),
      -2, (u_int )0, (u_int )0, (EVP_CIPHER const   *(*)(void))((void *)0)}};
#line 93 "cipher.c"
u_int cipher_blocksize(Cipher *c ) 
{ 

  {
#line 96
  return (c->block_size);
}
}
#line 99 "cipher.c"
u_int cipher_keylen(Cipher *c ) 
{ 

  {
#line 102
  return (c->key_len);
}
}
#line 105 "cipher.c"
u_int cipher_get_number(Cipher *c ) 
{ 

  {
#line 108
  return ((unsigned int )c->number);
}
}
#line 111 "cipher.c"
u_int cipher_mask_ssh1(int client ) 
{ u_int mask ;

  {
#line 114
  mask = (u_int )0;
#line 115
  mask |= (unsigned int )(1 << 3);
#line 116
  mask |= (unsigned int )(1 << 6);
#line 117
  if (client) {
#line 118
    mask |= (unsigned int )(1 << 2);
  }
#line 120
  return (mask);
}
}
#line 123 "cipher.c"
Cipher *cipher_by_name(char const   *name ) 
{ Cipher *c ;
  int tmp ;

  {
#line 127
  c = ciphers;
#line 127
  while ((unsigned int )c->name != (unsigned int )((void *)0)) {
#line 128
    tmp = strcasecmp((char const   *)c->name, name);
#line 128
    if (tmp == 0) {
#line 129
      return (c);
    }
#line 127
    c ++;
  }
#line 130
  return ((Cipher *)((void *)0));
}
}
#line 133 "cipher.c"
Cipher *cipher_by_number(int id ) 
{ Cipher *c ;

  {
#line 137
  c = ciphers;
#line 137
  while ((unsigned int )c->name != (unsigned int )((void *)0)) {
#line 138
    if (c->number == id) {
#line 139
      return (c);
    }
#line 137
    c ++;
  }
#line 140
  return ((Cipher *)((void *)0));
}
}
#line 144 "cipher.c"
int ciphers_valid(char const   *names ) 
{ Cipher *c ;
  char *ciphers___0 ;
  char *cp ;
  char *p ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___24 ;
  char *tmp___40 ;

  {
#line 151
  if ((unsigned int )names == (unsigned int )((void *)0)) {
#line 152
    return (0);
  } else {
#line 151
    if (0) {
#line 151
      __s1_len = strlen(names);
#line 151
      __s2_len = strlen("");
#line 151
      if (! ((unsigned int )((void const   *)(names + 1)) - (unsigned int )((void const   *)names) == 1U)) {
        goto _L___0;
      } else {
#line 151
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 151
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 151
            tmp___8 = 1;
          } else {
#line 151
            if (__s2_len >= 4U) {
#line 151
              tmp___8 = 1;
            } else {
#line 151
              tmp___8 = 0;
            }
          }
        } else {
#line 151
          tmp___8 = 0;
        }
      }
#line 151
      if (tmp___8) {
#line 151
        tmp___4 = __builtin_strcmp(names, "");
      } else {
#line 151
        tmp___7 = __builtin_strcmp(names, "");
#line 151
        tmp___4 = tmp___7;
      }
    } else {
#line 151
      tmp___7 = __builtin_strcmp(names, "");
#line 151
      tmp___4 = tmp___7;
    }
#line 151
    if (tmp___4 == 0) {
#line 152
      return (0);
    }
  }
#line 153
  cp = xstrdup(names);
#line 153
  ciphers___0 = cp;
#line 154
  tmp___24 = __strsep_g(& cp, ",");
#line 154
  p = tmp___24;
#line 154
  while (1) {
#line 154
    if (p) {
#line 154
      if (! ((int )*p != 0)) {
#line 154
        break;
      }
    } else {
#line 154
      break;
    }
#line 156
    c = cipher_by_name((char const   *)p);
#line 157
    if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 158
      debug("bad cipher %s [%s]", p, names);
#line 159
      xfree((void *)ciphers___0);
#line 160
      return (0);
    } else {
#line 157
      if (c->number != -3) {
#line 158
        debug("bad cipher %s [%s]", p, names);
#line 159
        xfree((void *)ciphers___0);
#line 160
        return (0);
      } else {
#line 162
        debug3("cipher ok: %s [%s]", p, names);
      }
    }
#line 155
    tmp___40 = __strsep_g(& cp, ",");
#line 155
    p = tmp___40;
  }
#line 165
  debug3("ciphers ok: [%s]", names);
#line 166
  xfree((void *)ciphers___0);
#line 167
  return (1);
}
}
#line 175 "cipher.c"
int cipher_number(char const   *name ) 
{ Cipher *c ;
  int tmp ;

  {
#line 179
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 180
    return (-1);
  }
#line 181
  c = cipher_by_name(name);
#line 182
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 182
    tmp = -1;
  } else {
#line 182
    tmp = c->number;
  }
#line 182
  return (tmp);
}
}
#line 185 "cipher.c"
char *cipher_name(int id ) 
{ Cipher *c ;
  Cipher *tmp ;
  char const   *tmp___0 ;

  {
#line 188
  tmp = cipher_by_number(id);
#line 188
  c = tmp;
#line 189
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 189
    tmp___0 = "<unknown>";
  } else {
#line 189
    tmp___0 = (char const   *)c->name;
  }
#line 189
  return ((char *)tmp___0);
}
}
#line 197 "cipher.c"
static int dowarn  =    1;
#line 192 "cipher.c"
void cipher_init(CipherContext *cc , Cipher *cipher , u_char const   *key , u_int keylen ,
                 u_char const   *iv , u_int ivlen , int encrypt ) 
{ EVP_CIPHER const   *type ;
  int klen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 205
  if (cipher->number == 2) {
#line 206
    if (dowarn) {
#line 207
      error("Warning: use of DES is strongly discouraged due to cryptographic weaknesses");
#line 209
      dowarn = 0;
    }
#line 211
    if (keylen > 8U) {
#line 212
      keylen = 8U;
    }
  }
#line 214
  cc->plaintext = cipher->number == 0;
#line 216
  if (keylen < cipher->key_len) {
#line 217
    fatal("cipher_init: key length %d is insufficient for %s.", keylen, cipher->name);
  }
#line 219
  if ((unsigned int )iv != (unsigned int )((void *)0)) {
#line 219
    if (ivlen < cipher->block_size) {
#line 220
      fatal("cipher_init: iv length %d is insufficient for %s.", ivlen, cipher->name);
    }
  }
#line 222
  cc->cipher = cipher;
#line 224
  type = (*(cipher->evptype))();
#line 226
  EVP_CIPHER_CTX_init(& cc->evp);
#line 236
  tmp = EVP_CipherInit(& cc->evp, type, (unsigned char const   *)((void *)0), (unsigned char const   *)((u_char *)iv),
                       encrypt == 1);
#line 236
  if (tmp == 0) {
#line 238
    fatal("cipher_init: EVP_CipherInit failed for %s", cipher->name);
  }
#line 240
  klen = cc->evp.key_len;
#line 241
  if (klen > 0) {
#line 241
    if (keylen != (u_int )klen) {
#line 242
      debug("cipher_init: set keylen (%d -> %d)", klen, keylen);
#line 243
      tmp___0 = EVP_CIPHER_CTX_set_key_length(& cc->evp, (int )keylen);
#line 243
      if (tmp___0 == 0) {
#line 244
        fatal("cipher_init: set keylen failed (%d -> %d)", klen, keylen);
      }
    }
  }
#line 247
  tmp___1 = EVP_CipherInit(& cc->evp, (EVP_CIPHER const   *)((void *)0), (unsigned char const   *)((u_char *)key),
                           (unsigned char const   *)((void *)0), -1);
#line 247
  if (tmp___1 == 0) {
#line 248
    fatal("cipher_init: EVP_CipherInit: set key failed for %s", cipher->name);
  }
#line 251
  return;
}
}
#line 253 "cipher.c"
void cipher_crypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ int tmp ;

  {
#line 256
  if (len % (cc->cipher)->block_size) {
#line 257
    fatal("cipher_encrypt: bad plaintext length %d", len);
  }
#line 261
  tmp = (*((cc->evp.cipher)->do_cipher))(& cc->evp, dest, (unsigned char const   *)((u_char *)src),
                                         len);
#line 261
  if (tmp == 0) {
#line 262
    fatal("evp_crypt: EVP_Cipher failed");
  }
#line 264
  return;
}
}
#line 266 "cipher.c"
void cipher_cleanup(CipherContext *cc ) 
{ int tmp ;

  {
#line 272
  tmp = EVP_CIPHER_CTX_cleanup(& cc->evp);
#line 272
  if (tmp == 0) {
#line 273
    error("cipher_cleanup: EVP_CIPHER_CTX_cleanup failed");
  }
#line 275
  return;
}
}
#line 282 "cipher.c"
void cipher_set_key_string(CipherContext *cc , Cipher *cipher , char const   *passphrase ,
                           int encrypt ) 
{ MD5_CTX md ;
  u_char digest___1[16] ;
  size_t tmp ;

  {
#line 289
  MD5_Init(& md);
#line 290
  tmp = strlen(passphrase);
#line 290
  MD5_Update(& md, (void const   *)((u_char const   *)passphrase), tmp);
#line 291
  MD5_Final(digest___1, & md);
#line 293
  cipher_init(cc, cipher, (u_char const   *)(digest___1), 16U, (u_char const   *)((void *)0),
              0U, encrypt);
#line 295
  memset((void *)(digest___1), 0, sizeof(digest___1));
#line 296
  memset((void *)(& md), 0, sizeof(md));
#line 297
  return;
}
}
#line 320 "cipher.c"
static int ssh1_3des_init(EVP_CIPHER_CTX *ctx , u_char const   *key , u_char const   *iv ,
                          int enc ) 
{ struct ssh1_3des_ctx *c ;
  u_char *k1 ;
  u_char *k2 ;
  u_char *k3 ;
  void *tmp ;
  EVP_CIPHER const   *tmp___0 ;
  int tmp___1 ;
  EVP_CIPHER const   *tmp___2 ;
  int tmp___3 ;
  EVP_CIPHER const   *tmp___4 ;
  int tmp___5 ;

  {
#line 327
  c = (struct ssh1_3des_ctx *)ctx->app_data;
#line 327
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 328
    tmp = xmalloc(sizeof(*c));
#line 328
    c = (struct ssh1_3des_ctx *)tmp;
#line 329
    ctx->app_data = (void *)((char *)c);
  }
#line 331
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 332
    return (1);
  }
#line 333
  if (enc == -1) {
#line 334
    enc = ctx->encrypt;
  }
#line 335
  k3 = (u_char *)key;
#line 335
  k2 = k3;
#line 335
  k1 = k2;
#line 336
  k2 += 8;
#line 337
  if (ctx->key_len >= 24) {
#line 338
    if (enc) {
#line 339
      k3 += 16;
    } else {
#line 341
      k1 += 16;
    }
  }
#line 343
  EVP_CIPHER_CTX_init(& c->k1);
#line 344
  EVP_CIPHER_CTX_init(& c->k2);
#line 345
  EVP_CIPHER_CTX_init(& c->k3);
#line 351
  tmp___0 = EVP_des_cbc();
#line 351
  tmp___1 = EVP_CipherInit(& c->k1, tmp___0, (unsigned char const   *)k1, (unsigned char const   *)((void *)0),
                           enc);
#line 351
  if (tmp___1 == 0) {
#line 354
    memset((void *)c, 0, sizeof(*c));
#line 355
    xfree((void *)c);
#line 356
    ctx->app_data = (void *)((char *)((void *)0));
#line 357
    return (0);
  } else {
#line 351
    tmp___2 = EVP_des_cbc();
#line 351
    tmp___3 = EVP_CipherInit(& c->k2, tmp___2, (unsigned char const   *)k2, (unsigned char const   *)((void *)0),
                             ! enc);
#line 351
    if (tmp___3 == 0) {
#line 354
      memset((void *)c, 0, sizeof(*c));
#line 355
      xfree((void *)c);
#line 356
      ctx->app_data = (void *)((char *)((void *)0));
#line 357
      return (0);
    } else {
#line 351
      tmp___4 = EVP_des_cbc();
#line 351
      tmp___5 = EVP_CipherInit(& c->k3, tmp___4, (unsigned char const   *)k3, (unsigned char const   *)((void *)0),
                               enc);
#line 351
      if (tmp___5 == 0) {
#line 354
        memset((void *)c, 0, sizeof(*c));
#line 355
        xfree((void *)c);
#line 356
        ctx->app_data = (void *)((char *)((void *)0));
#line 357
        return (0);
      }
    }
  }
#line 360
  return (1);
}
}
#line 363 "cipher.c"
static int ssh1_3des_cbc(EVP_CIPHER_CTX *ctx , u_char *dest , u_char const   *src ,
                         u_int len ) 
{ struct ssh1_3des_ctx *c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 368
  c = (struct ssh1_3des_ctx *)ctx->app_data;
#line 368
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 369
    error("ssh1_3des_cbc: no context");
#line 370
    return (0);
  }
#line 377
  tmp = (*((c->k1.cipher)->do_cipher))(& c->k1, dest, (unsigned char const   *)((u_char *)src),
                                       len);
#line 377
  if (tmp == 0) {
#line 380
    return (0);
  } else {
#line 377
    tmp___0 = (*((c->k2.cipher)->do_cipher))(& c->k2, dest, (unsigned char const   *)dest,
                                             len);
#line 377
    if (tmp___0 == 0) {
#line 380
      return (0);
    } else {
#line 377
      tmp___1 = (*((c->k3.cipher)->do_cipher))(& c->k3, dest, (unsigned char const   *)dest,
                                               len);
#line 377
      if (tmp___1 == 0) {
#line 380
        return (0);
      }
    }
  }
#line 382
  return (1);
}
}
#line 385 "cipher.c"
static int ssh1_3des_cleanup(EVP_CIPHER_CTX *ctx ) 
{ struct ssh1_3des_ctx *c ;

  {
#line 390
  c = (struct ssh1_3des_ctx *)ctx->app_data;
#line 390
  if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 391
    memset((void *)c, 0, sizeof(*c));
#line 392
    xfree((void *)c);
#line 393
    ctx->app_data = (void *)((char *)((void *)0));
  }
#line 395
  return (1);
}
}
#line 401 "cipher.c"
static EVP_CIPHER ssh1_3des  ;
#line 398 "cipher.c"
static EVP_CIPHER const   *evp_ssh1_3des(void) 
{ 

  {
#line 403
  memset((void *)(& ssh1_3des), 0, sizeof(EVP_CIPHER ));
#line 404
  ssh1_3des.nid = 0;
#line 405
  ssh1_3des.block_size = 8;
#line 406
  ssh1_3des.iv_len = 0;
#line 407
  ssh1_3des.key_len = 16;
#line 408
  ssh1_3des.init = & ssh1_3des_init;
#line 409
  ssh1_3des.cleanup = & ssh1_3des_cleanup;
#line 410
  ssh1_3des.do_cipher = & ssh1_3des_cbc;
#line 412
  ssh1_3des.flags = 10UL;
#line 414
  return ((EVP_CIPHER const   *)(& ssh1_3des));
}
}
#line 421 "cipher.c"
static void swap_bytes(u_char const   *src , u_char *dst , int n___0 ) 
{ u_char c[4] ;
  u_char const   *tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  u_char const   *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  u_char *tmp___6 ;

  {
#line 427
  n___0 /= 4;
#line 427
  while (n___0 > 0) {
#line 428
    tmp = src;
#line 428
    src ++;
#line 428
    c[3] = (unsigned char )*tmp;
#line 429
    tmp___0 = src;
#line 429
    src ++;
#line 429
    c[2] = (unsigned char )*tmp___0;
#line 430
    tmp___1 = src;
#line 430
    src ++;
#line 430
    c[1] = (unsigned char )*tmp___1;
#line 431
    tmp___2 = src;
#line 431
    src ++;
#line 431
    c[0] = (unsigned char )*tmp___2;
#line 433
    tmp___3 = dst;
#line 433
    dst ++;
#line 433
    *tmp___3 = c[0];
#line 434
    tmp___4 = dst;
#line 434
    dst ++;
#line 434
    *tmp___4 = c[1];
#line 435
    tmp___5 = dst;
#line 435
    dst ++;
#line 435
    *tmp___5 = c[2];
#line 436
    tmp___6 = dst;
#line 436
    dst ++;
#line 436
    *tmp___6 = c[3];
#line 427
    n___0 --;
  }
#line 438
  return;
}
}
#line 440 "cipher.c"
static int (*orig_bf)(EVP_CIPHER_CTX * , u_char * , u_char const   * , u_int  )  =    (int (*)(EVP_CIPHER_CTX * ,
            u_char * , u_char const   * , u_int  ))((void *)0);
#line 442 "cipher.c"
static int bf_ssh1_cipher(EVP_CIPHER_CTX *ctx , u_char *out , u_char const   *in ,
                          u_int len ) 
{ int ret ;

  {
#line 447
  swap_bytes(in, out, (int )len);
#line 448
  ret = (*orig_bf)(ctx, out, (u_char const   *)out, len);
#line 449
  swap_bytes((u_char const   *)out, out, (int )len);
#line 450
  return (ret);
}
}
#line 456 "cipher.c"
static EVP_CIPHER ssh1_bf  ;
#line 453 "cipher.c"
static EVP_CIPHER const   *evp_ssh1_bf(void) 
{ EVP_CIPHER const   *tmp ;

  {
#line 458
  tmp = EVP_bf_cbc();
#line 458
  memcpy((void * __restrict  )(& ssh1_bf), (void const   * __restrict  )tmp, sizeof(EVP_CIPHER ));
#line 459
  orig_bf = ssh1_bf.do_cipher;
#line 460
  ssh1_bf.nid = 0;
#line 461
  ssh1_bf.do_cipher = & bf_ssh1_cipher;
#line 462
  ssh1_bf.key_len = 32;
#line 463
  return ((EVP_CIPHER const   *)(& ssh1_bf));
}
}
#line 582 "cipher.c"
int cipher_get_keyiv_len(CipherContext *cc ) 
{ Cipher *c ;
  int ivlen ;

  {
#line 585
  c = cc->cipher;
#line 588
  if (c->number == 3) {
#line 589
    ivlen = 24;
  } else {
#line 591
    ivlen = (int )(cc->evp.cipher)->iv_len;
  }
#line 592
  return (ivlen);
}
}
#line 595 "cipher.c"
void cipher_get_keyiv(CipherContext *cc , u_char *iv , u_int len ) 
{ Cipher *c ;
  u_char *civ ;
  int evplen ;
  struct ssh1_3des_ctx *desc ;

  {
#line 598
  c = cc->cipher;
#line 599
  civ = (u_char *)((void *)0);
#line 602
  switch (c->number) {
  case -3: 
  case 2: 
  case 6: 
#line 606
  evplen = (int )(cc->evp.cipher)->iv_len;
#line 607
  if (evplen == 0) {
#line 608
    return;
  }
#line 609
  if ((u_int )evplen != len) {
#line 610
    fatal("%s: wrong iv length %d != %d", "cipher_get_keyiv", evplen, len);
  }
#line 624
  civ = cc->evp.iv;
#line 626
  break;
  case 3: 
#line 629
  if (len != 24U) {
#line 630
    fatal("%s: bad 3des iv length: %d", "cipher_get_keyiv", len);
  }
#line 631
  desc = (struct ssh1_3des_ctx *)cc->evp.app_data;
#line 632
  if ((unsigned int )desc == (unsigned int )((void *)0)) {
#line 633
    fatal("%s: no 3des context", "cipher_get_keyiv");
  }
#line 634
  debug3("%s: Copying 3DES IV", "cipher_get_keyiv");
#line 635
  memcpy((void * __restrict  )iv, (void const   * __restrict  )(desc->k1.iv), 8U);
#line 636
  memcpy((void * __restrict  )(iv + 8), (void const   * __restrict  )(desc->k2.iv),
         8U);
#line 637
  memcpy((void * __restrict  )(iv + 16), (void const   * __restrict  )(desc->k3.iv),
         8U);
#line 638
  return;
  default: 
#line 641
  fatal("%s: bad cipher %d", "cipher_get_keyiv", c->number);
  }
#line 643
  memcpy((void * __restrict  )iv, (void const   * __restrict  )civ, len);
#line 644
  return;
}
}
#line 646 "cipher.c"
void cipher_set_keyiv(CipherContext *cc , u_char *iv ) 
{ Cipher *c ;
  u_char *div___0 ;
  int evplen ;
  struct ssh1_3des_ctx *desc ;

  {
#line 649
  c = cc->cipher;
#line 650
  div___0 = (u_char *)((void *)0);
#line 651
  evplen = 0;
#line 653
  switch (c->number) {
  case -3: 
  case 2: 
  case 6: 
#line 657
  evplen = (int )(cc->evp.cipher)->iv_len;
#line 658
  if (evplen == 0) {
#line 659
    return;
  }
#line 672
  div___0 = cc->evp.iv;
#line 674
  break;
  case 3: 
#line 677
  desc = (struct ssh1_3des_ctx *)cc->evp.app_data;
#line 678
  if ((unsigned int )desc == (unsigned int )((void *)0)) {
#line 679
    fatal("%s: no 3des context", "cipher_set_keyiv");
  }
#line 680
  debug3("%s: Installed 3DES IV", "cipher_set_keyiv");
#line 681
  memcpy((void * __restrict  )(desc->k1.iv), (void const   * __restrict  )iv, 8U);
#line 682
  memcpy((void * __restrict  )(desc->k2.iv), (void const   * __restrict  )(iv + 8),
         8U);
#line 683
  memcpy((void * __restrict  )(desc->k3.iv), (void const   * __restrict  )(iv + 16),
         8U);
#line 684
  return;
  default: 
#line 687
  fatal("%s: bad cipher %d", "cipher_set_keyiv", c->number);
  }
#line 689
  memcpy((void * __restrict  )div___0, (void const   * __restrict  )iv, (unsigned int )evplen);
#line 690
  return;
}
}
#line 700 "cipher.c"
int cipher_get_keycontext(CipherContext *cc , u_char *dat ) 
{ Cipher *c ;
  int plen ;

  {
#line 703
  c = cc->cipher;
#line 704
  plen = 0;
#line 706
  if ((unsigned int )c->evptype == (unsigned int )(& EVP_rc4)) {
#line 707
    plen = (int )(cc->evp.cipher)->ctx_size;
#line 708
    if ((unsigned int )dat == (unsigned int )((void *)0)) {
#line 709
      return (plen);
    }
#line 710
    memcpy((void * __restrict  )dat, (void const   * __restrict  )cc->evp.cipher_data,
           (unsigned int )plen);
  }
#line 712
  return (plen);
}
}
#line 715 "cipher.c"
void cipher_set_keycontext(CipherContext *cc , u_char *dat ) 
{ Cipher *c ;
  int plen ;

  {
#line 718
  c = cc->cipher;
#line 721
  if ((unsigned int )c->evptype == (unsigned int )(& EVP_rc4)) {
#line 722
    plen = (int )(cc->evp.cipher)->ctx_size;
#line 723
    memcpy((void * __restrict  )cc->evp.cipher_data, (void const   * __restrict  )dat,
           (unsigned int )plen);
  }
#line 725
  return;
}
}
#line 1 "compat.o"
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 58 "compat.h"
void enable_compat13(void) ;
#line 59
void enable_compat20(void) ;
#line 60
void compat_datafellows(char const   *version ) ;
#line 61
int proto_spec(char const   *spec ) ;
#line 62
char *compat_cipher_proposal(char *cipher_prop ) ;
#line 18 "match.h"
int match_pattern_list(char const   *string , char const   *pattern , u_int len ,
                       int dolower ) ;
#line 35 "compat.c"
int compat13  =    0;
#line 36 "compat.c"
int compat20  =    0;
#line 37 "compat.c"
int datafellows  =    0;
#line 39 "compat.c"
void enable_compat20(void) 
{ 

  {
#line 42
  verbose("Enabling compatibility mode for protocol 2.0");
#line 43
  compat20 = 1;
#line 44
  return;
}
}
#line 45 "compat.c"
void enable_compat13(void) 
{ 

  {
#line 48
  verbose("Enabling compatibility mode for protocol 1.3");
#line 49
  compat13 = 1;
#line 50
  return;
}
}
#line 56 "compat.c"
static struct __anonstruct_check_67 check[29]  = 
#line 56
  {      {(char *)"OpenSSH-2.0*,OpenSSH-2.1*,OpenSSH_2.1*,OpenSSH_2.2*", 2146448}, 
        {(char *)"OpenSSH_2.3.0*", 2150528}, 
        {(char *)"OpenSSH_2.3.*", 2150400}, 
        {(char *)"OpenSSH_2.5.0p1*,OpenSSH_2.5.1p1*", 2150400}, 
        {(char *)"OpenSSH_2.5.0*,OpenSSH_2.5.1*,OpenSSH_2.5.2*", 2146304}, 
        {(char *)"OpenSSH_2.5.3*", 2129920}, 
        {(char *)"OpenSSH_2.*,OpenSSH_3.0*,OpenSSH_3.1*", 2097152}, 
        {(char *)"Sun_SSH_1.0*", 2129920}, 
        {(char *)"OpenSSH*", 0}, 
        {(char *)"*MindTerm*", 0}, 
        {(char *)"2.1.0*", 73813}, 
        {(char *)"2.1 *", 73813}, 
        {(char *)"2.0.13*,2.0.14*,2.0.15*,2.0.16*,2.0.17*,2.0.18*,2.0.19*", 1253983}, 
        {(char *)"2.0.11*,2.0.12*",
      1188479}, 
        {(char *)"2.0.*", 1450623}, 
        {(char *)"2.2.0*,2.3.0*", 8260}, 
        {(char *)"2.3.*", 8256}, 
        {(char *)"2.4", 16}, 
        {(char *)"2.*", 64}, 
        {(char *)"3.0.*", 64}, 
        {(char *)"3.0 SecureCRT*", 16}, 
        {(char *)"1.7 SecureFX*", 16}, 
        {(char *)"1.2.18*,1.2.19*,1.2.20*,1.2.21*,1.2.22*", 4194560}, 
        {(char *)"1.3.2*", 4194560}, 
        {(char *)"1.2.1*,1.2.2*,1.2.3*", 4194304}, 
        {(char *)"*SSH Compatible Server*", 1024}, 
        {(char *)"*OSU_0*,OSU_1.0*,OSU_1.1*,OSU_1.2*,OSU_1.3*,OSU_1.4*,OSU_1.5alpha1*,OSU_1.5alpha2*,OSU_1.5alpha3*",
      1024}, 
        {(char *)"*SSH_Version_Mapper*", 2048}, 
        {(char *)((void *)0), 0}};
#line 52 "compat.c"
void compat_datafellows(char const   *version ) 
{ int i ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 153
  i = 0;
#line 153
  while (check[i].pat) {
#line 154
    tmp = strlen((char const   *)check[i].pat);
#line 154
    tmp___0 = match_pattern_list(version, (char const   *)check[i].pat, tmp, 0);
#line 154
    if (tmp___0 == 1) {
#line 156
      debug("match: %s pat %s", version, check[i].pat);
#line 157
      datafellows = check[i].bugs;
#line 158
      return;
    }
#line 153
    i ++;
  }
#line 161
  debug("no match: %s", version);
#line 162
  return;
}
}
#line 165 "compat.c"
int proto_spec(char const   *spec ) 
{ char *s ;
  char *p ;
  char *q ;
  int ret ;
  char *tmp___14 ;
  char *tmp___30 ;
  int tmp___31 ;

  {
#line 169
  ret = 0;
#line 171
  if ((unsigned int )spec == (unsigned int )((void *)0)) {
#line 172
    return (ret);
  }
#line 173
  s = xstrdup(spec);
#line 173
  q = s;
#line 174
  tmp___14 = __strsep_g(& q, ",");
#line 174
  p = tmp___14;
#line 174
  while (1) {
#line 174
    if (p) {
#line 174
      if (! ((int )*p != 0)) {
#line 174
        break;
      }
    } else {
#line 174
      break;
    }
#line 175
    tmp___31 = atoi((char const   *)p);
#line 175
    switch (tmp___31) {
    case 1: 
#line 177
    if (ret == 0) {
#line 178
      ret |= 2;
    }
#line 179
    ret |= 1;
#line 180
    break;
    case 2: 
#line 182
    ret |= 4;
#line 183
    break;
    default: 
#line 185
    log("ignoring bad proto spec: \'%s\'.", p);
#line 186
    break;
    }
#line 174
    tmp___30 = __strsep_g(& q, ",");
#line 174
    p = tmp___30;
  }
#line 189
  xfree((void *)s);
#line 190
  return (ret);
}
}
#line 193 "compat.c"
char *compat_cipher_proposal(char *cipher_prop ) 
{ Buffer b ;
  char *orig_prop ;
  char *fix_ciphers ;
  char *cp ;
  char *tmp ;
  u_int tmp___0 ;
  size_t tmp___1 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___43 ;
  void *tmp___44 ;

  {
#line 200
  if (! (datafellows & 4096)) {
#line 201
    return (cipher_prop);
  }
#line 203
  buffer_init(& b);
#line 204
  orig_prop = xstrdup((char const   *)cipher_prop);
#line 204
  tmp = orig_prop;
#line 205
  while (1) {
#line 205
    tmp___43 = __strsep_g(& tmp, ",");
#line 205
    cp = tmp___43;
#line 205
    if (! ((unsigned int )cp != (unsigned int )((void *)0))) {
#line 205
      break;
    }
#line 206
    if (0) {
#line 206
      if (0) {
#line 206
        __s1_len___0 = strlen((char const   *)cp);
#line 206
        __s2_len___0 = strlen("aes");
#line 206
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___2;
        } else {
#line 206
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 206
            if (! ((unsigned int )((void const   *)("aes" + 1)) - (unsigned int )((void const   *)"aes") == 1U)) {
#line 206
              tmp___25 = 1;
            } else {
#line 206
              if (__s2_len___0 >= 4U) {
#line 206
                tmp___25 = 1;
              } else {
#line 206
                tmp___25 = 0;
              }
            }
          } else {
#line 206
            tmp___25 = 0;
          }
        }
#line 206
        if (tmp___25) {
#line 206
          tmp___21 = __builtin_strcmp((char const   *)cp, "aes");
        } else {
#line 206
          tmp___24 = __builtin_strcmp((char const   *)cp, "aes");
#line 206
          tmp___21 = tmp___24;
        }
      } else {
#line 206
        tmp___24 = __builtin_strcmp((char const   *)cp, "aes");
#line 206
        tmp___21 = tmp___24;
      }
#line 206
      tmp___15 = tmp___21;
    } else {
#line 206
      tmp___15 = strncmp((char const   *)cp, "aes", 3U);
    }
#line 206
    if (tmp___15 != 0) {
#line 207
      tmp___0 = buffer_len(& b);
#line 207
      if (tmp___0 > 0U) {
#line 208
        buffer_append(& b, (void const   *)",", 1U);
      }
#line 209
      tmp___1 = strlen((char const   *)cp);
#line 209
      buffer_append(& b, (void const   *)cp, tmp___1);
    }
  }
#line 212
  buffer_append(& b, (void const   *)"\000", 1U);
#line 213
  tmp___44 = buffer_ptr(& b);
#line 213
  fix_ciphers = xstrdup((char const   *)tmp___44);
#line 214
  buffer_free(& b);
#line 215
  xfree((void *)orig_prop);
#line 216
  debug2("Original cipher proposal: %s", cipher_prop);
#line 217
  debug2("Compat cipher proposal: %s", fix_ciphers);
#line 218
  if (! *fix_ciphers) {
#line 219
    fatal("No available ciphers found.");
  }
#line 221
  return (fix_ciphers);
}
}
#line 1 "compress.o"
#line 242 "/usr/include/zlib.h"
extern int deflate(z_streamp strm , int flush ) ;
#line 328
extern int deflateEnd(z_streamp strm ) ;
#line 363
extern int inflate(z_streamp strm , int flush ) ;
#line 462
extern int inflateEnd(z_streamp strm ) ;
#line 1317
extern int deflateInit_(z_streamp strm , int level , char const   *version , int stream_size ) ;
#line 1319
extern int inflateInit_(z_streamp strm , char const   *version , int stream_size ) ;
#line 19 "compress.h"
void buffer_compress_init_send(int level ) ;
#line 20
void buffer_compress_init_recv(void) ;
#line 21
void buffer_compress_uninit(void) ;
#line 22
void buffer_compress(Buffer *input_buffer , Buffer *output_buffer ) ;
#line 23
void buffer_uncompress(Buffer *input_buffer , Buffer *output_buffer ) ;
#line 22 "compress.c"
z_stream incoming_stream  ;
#line 23 "compress.c"
z_stream outgoing_stream  ;
#line 24 "compress.c"
static int compress_init_send_called  =    0;
#line 25 "compress.c"
static int compress_init_recv_called  =    0;
#line 26 "compress.c"
static int inflate_failed  =    0;
#line 27 "compress.c"
static int deflate_failed  =    0;
#line 34 "compress.c"
void buffer_compress_init_send(int level ) 
{ 

  {
#line 37
  if (compress_init_send_called == 1) {
#line 38
    deflateEnd(& outgoing_stream);
  }
#line 39
  compress_init_send_called = 1;
#line 40
  debug("Enabling compression at level %d.", level);
#line 41
  if (level < 1) {
#line 42
    fatal("Bad compression level %d.", level);
  } else {
#line 41
    if (level > 9) {
#line 42
      fatal("Bad compression level %d.", level);
    }
  }
#line 43
  deflateInit_(& outgoing_stream, level, "1.2.3", (int )sizeof(z_stream ));
#line 44
  return;
}
}
#line 45 "compress.c"
void buffer_compress_init_recv(void) 
{ 

  {
#line 48
  if (compress_init_recv_called == 1) {
#line 49
    inflateEnd(& incoming_stream);
  }
#line 50
  compress_init_recv_called = 1;
#line 51
  inflateInit_(& incoming_stream, "1.2.3", (int )sizeof(z_stream ));
#line 52
  return;
}
}
#line 56 "compress.c"
void buffer_compress_uninit(void) 
{ double tmp ;
  double tmp___0 ;

  {
#line 59
  if (outgoing_stream.total_in == 0UL) {
#line 59
    tmp = 0.0;
  } else {
#line 59
    tmp = (double )outgoing_stream.total_out / (double )outgoing_stream.total_in;
  }
#line 59
  debug("compress outgoing: raw data %lu, compressed %lu, factor %.2f", outgoing_stream.total_in,
        outgoing_stream.total_out, tmp);
#line 63
  if (incoming_stream.total_out == 0UL) {
#line 63
    tmp___0 = 0.0;
  } else {
#line 63
    tmp___0 = (double )incoming_stream.total_in / (double )incoming_stream.total_out;
  }
#line 63
  debug("compress incoming: raw data %lu, compressed %lu, factor %.2f", incoming_stream.total_out,
        incoming_stream.total_in, tmp___0);
#line 67
  if (compress_init_recv_called == 1) {
#line 67
    if (inflate_failed == 0) {
#line 68
      inflateEnd(& incoming_stream);
    }
  }
#line 69
  if (compress_init_send_called == 1) {
#line 69
    if (deflate_failed == 0) {
#line 70
      deflateEnd(& outgoing_stream);
    }
  }
#line 71
  return;
}
}
#line 82 "compress.c"
void buffer_compress(Buffer *input_buffer , Buffer *output_buffer ) 
{ u_char buf___1[4096] ;
  int status ;
  u_int tmp ;
  void *tmp___0 ;

  {
#line 89
  tmp = buffer_len(input_buffer);
#line 89
  if (tmp == 0U) {
#line 90
    return;
  }
#line 93
  tmp___0 = buffer_ptr(input_buffer);
#line 93
  outgoing_stream.next_in = (Bytef *)tmp___0;
#line 94
  outgoing_stream.avail_in = buffer_len(input_buffer);
#line 97
  while (1) {
#line 99
    outgoing_stream.next_out = buf___1;
#line 100
    outgoing_stream.avail_out = sizeof(buf___1);
#line 103
    status = deflate(& outgoing_stream, 1);
#line 104
    switch (status) {
    case 0: 
#line 107
    buffer_append(output_buffer, (void const   *)(buf___1), sizeof(buf___1) - outgoing_stream.avail_out);
#line 109
    break;
    default: 
#line 111
    deflate_failed = 1;
#line 112
    fatal("buffer_compress: deflate returned %d", status);
    }
#line 97
    if (! (outgoing_stream.avail_out == 0U)) {
#line 97
      break;
    }
  }
#line 116
  return;
}
}
#line 127 "compress.c"
void buffer_uncompress(Buffer *input_buffer , Buffer *output_buffer ) 
{ u_char buf___1[4096] ;
  int status ;
  void *tmp ;

  {
#line 133
  tmp = buffer_ptr(input_buffer);
#line 133
  incoming_stream.next_in = (Bytef *)tmp;
#line 134
  incoming_stream.avail_in = buffer_len(input_buffer);
#line 136
  while (1) {
#line 138
    incoming_stream.next_out = buf___1;
#line 139
    incoming_stream.avail_out = sizeof(buf___1);
#line 141
    status = inflate(& incoming_stream, 1);
#line 142
    switch (status) {
    case 0: 
#line 144
    buffer_append(output_buffer, (void const   *)(buf___1), sizeof(buf___1) - incoming_stream.avail_out);
#line 146
    break;
    case -5: 
#line 153
    return;
    default: 
#line 155
    inflate_failed = 1;
#line 156
    fatal("buffer_uncompress: inflate returned %d", status);
    }
  }
}
}
#line 1 "crc32.o"
#line 19 "crc32.h"
u_int ssh_crc32(u_char const   *s , u_int len ) ;
#line 46 "crc32.c"
static u_int crc32_tab[256]  = 
#line 46 "crc32.c"
  {      (u_int )0L,      (u_int )1996959894L,      (u_int )3993919788UL,      (u_int )2567524794UL, 
        (u_int )124634137L,      (u_int )1886057615L,      (u_int )3915621685UL,      (u_int )2657392035UL, 
        (u_int )249268274L,      (u_int )2044508324L,      (u_int )3772115230UL,      (u_int )2547177864UL, 
        (u_int )162941995L,      (u_int )2125561021L,      (u_int )3887607047UL,      (u_int )2428444049UL, 
        (u_int )498536548L,      (u_int )1789927666L,      (u_int )4089016648UL,      (u_int )2227061214UL, 
        (u_int )450548861L,      (u_int )1843258603L,      (u_int )4107580753UL,      (u_int )2211677639UL, 
        (u_int )325883990L,      (u_int )1684777152L,      (u_int )4251122042UL,      (u_int )2321926636UL, 
        (u_int )335633487L,      (u_int )1661365465L,      (u_int )4195302755UL,      (u_int )2366115317UL, 
        (u_int )997073096L,      (u_int )1281953886L,      (u_int )3579855332UL,      (u_int )2724688242UL, 
        (u_int )1006888145L,      (u_int )1258607687L,      (u_int )3524101629UL,      (u_int )2768942443UL, 
        (u_int )901097722L,      (u_int )1119000684L,      (u_int )3686517206UL,      (u_int )2898065728UL, 
        (u_int )853044451L,      (u_int )1172266101L,      (u_int )3705015759UL,      (u_int )2882616665UL, 
        (u_int )651767980L,      (u_int )1373503546L,      (u_int )3369554304UL,      (u_int )3218104598UL, 
        (u_int )565507253L,      (u_int )1454621731L,      (u_int )3485111705UL,      (u_int )3099436303UL, 
        (u_int )671266974L,      (u_int )1594198024L,      (u_int )3322730930UL,      (u_int )2970347812UL, 
        (u_int )795835527L,      (u_int )1483230225L,      (u_int )3244367275UL,      (u_int )3060149565UL, 
        (u_int )1994146192L,      (u_int )31158534L,      (u_int )2563907772UL,      (u_int )4023717930UL, 
        (u_int )1907459465L,      (u_int )112637215L,      (u_int )2680153253UL,      (u_int )3904427059UL, 
        (u_int )2013776290L,      (u_int )251722036L,      (u_int )2517215374UL,      (u_int )3775830040UL, 
        (u_int )2137656763L,      (u_int )141376813L,      (u_int )2439277719UL,      (u_int )3865271297UL, 
        (u_int )1802195444L,      (u_int )476864866L,      (u_int )2238001368UL,      (u_int )4066508878UL, 
        (u_int )1812370925L,      (u_int )453092731L,      (u_int )2181625025UL,      (u_int )4111451223UL, 
        (u_int )1706088902L,      (u_int )314042704L,      (u_int )2344532202UL,      (u_int )4240017532UL, 
        (u_int )1658658271L,      (u_int )366619977L,      (u_int )2362670323UL,      (u_int )4224994405UL, 
        (u_int )1303535960L,      (u_int )984961486L,      (u_int )2747007092UL,      (u_int )3569037538UL, 
        (u_int )1256170817L,      (u_int )1037604311L,      (u_int )2765210733UL,      (u_int )3554079995UL, 
        (u_int )1131014506L,      (u_int )879679996L,      (u_int )2909243462UL,      (u_int )3663771856UL, 
        (u_int )1141124467L,      (u_int )855842277L,      (u_int )2852801631UL,      (u_int )3708648649UL, 
        (u_int )1342533948L,      (u_int )654459306L,      (u_int )3188396048UL,      (u_int )3373015174UL, 
        (u_int )1466479909L,      (u_int )544179635L,      (u_int )3110523913UL,      (u_int )3462522015UL, 
        (u_int )1591671054L,      (u_int )702138776L,      (u_int )2966460450UL,      (u_int )3352799412UL, 
        (u_int )1504918807L,      (u_int )783551873L,      (u_int )3082640443UL,      (u_int )3233442989UL, 
        (u_int )3988292384UL,      (u_int )2596254646UL,      (u_int )62317068L,      (u_int )1957810842L, 
        (u_int )3939845945UL,      (u_int )2647816111UL,      (u_int )81470997L,      (u_int )1943803523L, 
        (u_int )3814918930UL,      (u_int )2489596804UL,      (u_int )225274430L,      (u_int )2053790376L, 
        (u_int )3826175755UL,      (u_int )2466906013UL,      (u_int )167816743L,      (u_int )2097651377L, 
        (u_int )4027552580UL,      (u_int )2265490386UL,      (u_int )503444072L,      (u_int )1762050814L, 
        (u_int )4150417245UL,      (u_int )2154129355UL,      (u_int )426522225L,      (u_int )1852507879L, 
        (u_int )4275313526UL,      (u_int )2312317920UL,      (u_int )282753626L,      (u_int )1742555852L, 
        (u_int )4189708143UL,      (u_int )2394877945UL,      (u_int )397917763L,      (u_int )1622183637L, 
        (u_int )3604390888UL,      (u_int )2714866558UL,      (u_int )953729732L,      (u_int )1340076626L, 
        (u_int )3518719985UL,      (u_int )2797360999UL,      (u_int )1068828381L,      (u_int )1219638859L, 
        (u_int )3624741850UL,      (u_int )2936675148UL,      (u_int )906185462L,      (u_int )1090812512L, 
        (u_int )3747672003UL,      (u_int )2825379669UL,      (u_int )829329135L,      (u_int )1181335161L, 
        (u_int )3412177804UL,      (u_int )3160834842UL,      (u_int )628085408L,      (u_int )1382605366L, 
        (u_int )3423369109UL,      (u_int )3138078467UL,      (u_int )570562233L,      (u_int )1426400815L, 
        (u_int )3317316542UL,      (u_int )2998733608UL,      (u_int )733239954L,      (u_int )1555261956L, 
        (u_int )3268935591UL,      (u_int )3050360625UL,      (u_int )752459403L,      (u_int )1541320221L, 
        (u_int )2607071920UL,      (u_int )3965973030UL,      (u_int )1969922972L,      (u_int )40735498L, 
        (u_int )2617837225UL,      (u_int )3943577151UL,      (u_int )1913087877L,      (u_int )83908371L, 
        (u_int )2512341634UL,      (u_int )3803740692UL,      (u_int )2075208622L,      (u_int )213261112L, 
        (u_int )2463272603UL,      (u_int )3855990285UL,      (u_int )2094854071L,      (u_int )198958881L, 
        (u_int )2262029012UL,      (u_int )4057260610UL,      (u_int )1759359992L,      (u_int )534414190L, 
        (u_int )2176718541UL,      (u_int )4139329115UL,      (u_int )1873836001L,      (u_int )414664567L, 
        (u_int )2282248934UL,      (u_int )4279200368UL,      (u_int )1711684554L,      (u_int )285281116L, 
        (u_int )2405801727UL,      (u_int )4167216745UL,      (u_int )1634467795L,      (u_int )376229701L, 
        (u_int )2685067896UL,      (u_int )3608007406UL,      (u_int )1308918612L,      (u_int )956543938L, 
        (u_int )2808555105UL,      (u_int )3495958263UL,      (u_int )1231636301L,      (u_int )1047427035L, 
        (u_int )2932959818UL,      (u_int )3654703836UL,      (u_int )1088359270L,      (u_int )936918000L, 
        (u_int )2847714899UL,      (u_int )3736837829UL,      (u_int )1202900863L,      (u_int )817233897L, 
        (u_int )3183342108UL,      (u_int )3401237130UL,      (u_int )1404277552L,      (u_int )615818150L, 
        (u_int )3134207493UL,      (u_int )3453421203UL,      (u_int )1423857449L,      (u_int )601450431L, 
        (u_int )3009837614UL,      (u_int )3294710456UL,      (u_int )1567103746L,      (u_int )711928724L, 
        (u_int )3020668471UL,      (u_int )3272380065UL,      (u_int )1510334235L,      (u_int )755167117L};
#line 103 "crc32.c"
u_int ssh_crc32(u_char const   *s , u_int len ) 
{ u_int i ;
  u_int crc32val ;

  {
#line 109
  crc32val = 0U;
#line 110
  i = 0U;
#line 110
  while (i < len) {
#line 111
    crc32val = crc32_tab[(crc32val ^ (unsigned int )*(s + i)) & 255U] ^ (crc32val >> 8);
#line 110
    i ++;
  }
#line 113
  return (crc32val);
}
}
#line 1 "deattack.o"
#line 29 "deattack.h"
int detect_attack(u_char *buf___1 , u_int32_t len , u_char *IV ) ;
#line 50 "deattack.c"
static void crc_update(u_int32_t *a , u_int32_t b ) 
{ 

  {
#line 53
  b ^= *a;
#line 54
  *a = ssh_crc32((u_char const   *)((u_char *)(& b)), sizeof(b));
#line 55
  return;
}
}
#line 58 "deattack.c"
static int check_crc(u_char *S , u_char *buf___1 , u_int32_t len , u_char *IV ) 
{ u_int32_t crc ;
  u_char *c ;
  int tmp ;
  int tmp___0 ;

  {
#line 65
  crc = 0U;
#line 66
  if (IV) {
#line 66
    tmp = memcmp((void const   *)S, (void const   *)IV, 8U);
#line 66
    if (! tmp) {
#line 67
      crc_update(& crc, 1U);
#line 68
      crc_update(& crc, 0U);
    }
  }
#line 70
  c = buf___1;
#line 70
  while ((unsigned int )c < (unsigned int )(buf___1 + len)) {
#line 71
    tmp___0 = memcmp((void const   *)S, (void const   *)c, 8U);
#line 71
    if (tmp___0) {
#line 75
      crc_update(& crc, 0U);
#line 76
      crc_update(& crc, 0U);
    } else {
#line 72
      crc_update(& crc, 1U);
#line 73
      crc_update(& crc, 0U);
    }
#line 70
    c += 8;
  }
#line 79
  return (crc == 0U);
}
}
#line 87 "deattack.c"
static u_int16_t *h  =    (u_int16_t *)((void *)0);
#line 88 "deattack.c"
static u_int32_t n  =    (u_int32_t )4096;
#line 84 "deattack.c"
int detect_attack(u_char *buf___1 , u_int32_t len , u_char *IV ) 
{ u_int32_t i ;
  u_int32_t j ;
  u_int32_t l ;
  u_char *c ;
  u_char *d ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 94
  if (len > 262144U) {
#line 96
    fatal("detect_attack: bad length %d", len);
  } else {
#line 94
    if (len % 8U != 0U) {
#line 96
      fatal("detect_attack: bad length %d", len);
    }
  }
#line 98
  l = n;
#line 98
  while (l < ((len / 8U) * 3U) / 2U) {
#line 98
    l <<= 2;
  }
#line 101
  if ((unsigned int )h == (unsigned int )((void *)0)) {
#line 102
    debug("Installing crc compensation attack detector.");
#line 103
    n = l;
#line 104
    tmp = xmalloc(n * 2U);
#line 104
    h = (u_int16_t *)tmp;
  } else {
#line 106
    if (l > n) {
#line 107
      n = l;
#line 108
      tmp___0 = xrealloc((void *)h, n * 2U);
#line 108
      h = (u_int16_t *)tmp___0;
    }
  }
#line 112
  if (len <= 56U) {
#line 113
    c = buf___1;
#line 113
    while ((unsigned int )c < (unsigned int )(buf___1 + len)) {
#line 114
      if (IV) {
#line 114
        tmp___2 = memcmp((void const   *)c, (void const   *)IV, 8U);
#line 114
        if (! tmp___2) {
#line 115
          tmp___1 = check_crc(c, buf___1, len, (u_char *)IV);
#line 115
          if (tmp___1) {
#line 116
            return (1);
          } else {
#line 118
            break;
          }
        }
      }
#line 120
      d = buf___1;
#line 120
      while ((unsigned int )d < (unsigned int )c) {
#line 121
        tmp___4 = memcmp((void const   *)c, (void const   *)d, 8U);
#line 121
        if (! tmp___4) {
#line 122
          tmp___3 = check_crc(c, buf___1, len, (u_char *)IV);
#line 122
          if (tmp___3) {
#line 123
            return (1);
          } else {
#line 125
            break;
          }
        }
#line 120
        d += 8;
      }
#line 113
      c += 8;
    }
#line 129
    return (0);
  }
#line 131
  memset((void *)h, 255, n * 2U);
#line 133
  if (IV) {
#line 134
    *(h + ((((((unsigned long )*(IV + 0) << 24) | ((unsigned long )*(IV + 1) << 16)) | ((unsigned long )*(IV + 2) << 8)) | (unsigned long )*(IV + 3)) & (unsigned long )(n - 1U))) = (unsigned short)65534;
  }
#line 136
  c = buf___1;
#line 136
  j = 0U;
#line 136
  while ((unsigned int )c < (unsigned int )(buf___1 + len)) {
#line 137
    i = (unsigned int )((((((unsigned long )*(c + 0) << 24) | ((unsigned long )*(c + 1) << 16)) | ((unsigned long )*(c + 2) << 8)) | (unsigned long )*(c + 3)) & (unsigned long )(n - 1U));
#line 137
    while ((int )*(h + i) != 65535) {
#line 139
      if ((int )*(h + i) == 65534) {
#line 140
        tmp___6 = memcmp((void const   *)c, (void const   *)IV, 8U);
#line 140
        if (! tmp___6) {
#line 141
          tmp___5 = check_crc(c, buf___1, len, (u_char *)IV);
#line 141
          if (tmp___5) {
#line 142
            return (1);
          } else {
#line 144
            break;
          }
        }
      } else {
#line 146
        tmp___8 = memcmp((void const   *)c, (void const   *)(buf___1 + (int )*(h + i) * 8),
                         8U);
#line 146
        if (! tmp___8) {
#line 147
          tmp___7 = check_crc(c, buf___1, len, (u_char *)IV);
#line 147
          if (tmp___7) {
#line 148
            return (1);
          } else {
#line 150
            break;
          }
        }
      }
#line 137
      i = (i + 1U) & (n - 1U);
    }
#line 153
    *(h + i) = (unsigned short )j;
#line 136
    c += 8;
#line 136
    j ++;
  }
#line 155
  return (0);
}
}
#line 1 "dh.o"
#line 660 "/usr/include/stdio.h"
extern void rewind(FILE *__stream ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 401 "/usr/include/openssl/bn.h"
extern int BN_rand(BIGNUM *rnd , int bits , int top , int bottom ) ;
#line 407
extern BIGNUM *BN_new(void) ;
#line 409
extern void BN_clear_free(BIGNUM *a ) ;
#line 457
extern int BN_cmp(BIGNUM const   *a , BIGNUM const   *b ) ;
#line 459
extern int BN_is_bit_set(BIGNUM const   *a , int n ) ;
#line 497
extern int BN_hex2bn(BIGNUM **a , char const   *str ) ;
#line 173 "/usr/include/openssl/dh.h"
extern DH *DH_new(void) ;
#line 193
extern int DH_generate_key(DH *dh ) ;
#line 35 "dh.h"
DH *choose_dh(int min , int wantbits , int max ) ;
#line 36
DH *dh_new_group_asc(char const   *gen___0 , char const   *modulus ) ;
#line 37
DH *dh_new_group(BIGNUM *gen___0 , BIGNUM *modulus ) ;
#line 38
DH *dh_new_group1(void) ;
#line 40
void dh_gen_key(DH *dh , int need ) ;
#line 41
int dh_pub_is_valid(DH *dh , BIGNUM *dh_pub ) ;
#line 43
int dh_estimate(int bits ) ;
#line 16 "misc.h"
char *strdelim(char **s ) ;
#line 42 "dh.c"
static int parse_prime(int linenum , char *line , struct dhgroup *dhg ) 
{ char *cp ;
  char *arg ;
  char *strsize ;
  char *gen___0 ;
  char *prime ;
  char *tmp___14 ;
  char *tmp___30 ;
  char *tmp___46 ;
  char *tmp___62 ;
  char *tmp___78 ;
  char *tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;

  {
#line 48
  cp = line;
#line 49
  arg = strdelim(& cp);
#line 51
  if ((int )*arg == 0) {
#line 52
    arg = strdelim(& cp);
  }
#line 53
  if (! *arg) {
#line 54
    return (0);
  } else {
#line 53
    if ((int )*arg == 35) {
#line 54
      return (0);
    }
  }
#line 57
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 57
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 59
  tmp___14 = __strsep_g(& cp, " ");
#line 59
  arg = tmp___14;
#line 60
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 60
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 62
  tmp___30 = __strsep_g(& cp, " ");
#line 62
  arg = tmp___30;
#line 63
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 63
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 65
  tmp___46 = __strsep_g(& cp, " ");
#line 65
  arg = tmp___46;
#line 66
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 66
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 68
  tmp___62 = __strsep_g(& cp, " ");
#line 68
  strsize = tmp___62;
#line 69
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 69
    if ((int )*strsize == 0) {
      goto fail;
    } else {
#line 69
      dhg->size = atoi((char const   *)strsize);
#line 69
      if (dhg->size == 0) {
        goto fail;
      }
    }
  }
#line 73
  (dhg->size) ++;
#line 74
  tmp___78 = __strsep_g(& cp, " ");
#line 74
  gen___0 = tmp___78;
#line 75
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 75
    if ((int )*gen___0 == 0) {
      goto fail;
    }
  }
#line 77
  tmp___94 = __strsep_g(& cp, " ");
#line 77
  prime = tmp___94;
#line 78
  if ((unsigned int )cp != (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 78
    if ((int )*prime == 0) {
      goto fail;
    }
  }
#line 81
  dhg->g = BN_new();
#line 81
  if ((unsigned int )dhg->g == (unsigned int )((void *)0)) {
#line 82
    fatal("parse_prime: BN_new failed");
  }
#line 83
  dhg->p = BN_new();
#line 83
  if ((unsigned int )dhg->p == (unsigned int )((void *)0)) {
#line 84
    fatal("parse_prime: BN_new failed");
  }
#line 85
  tmp___95 = BN_hex2bn(& dhg->g, (char const   *)gen___0);
#line 85
  if (tmp___95 == 0) {
    goto failclean;
  }
#line 88
  tmp___96 = BN_hex2bn(& dhg->p, (char const   *)prime);
#line 88
  if (tmp___96 == 0) {
    goto failclean;
  }
#line 91
  tmp___97 = BN_num_bits((BIGNUM const   *)dhg->p);
#line 91
  if (tmp___97 != dhg->size) {
    goto failclean;
  }
#line 94
  return (1);
  failclean: 
#line 97
  BN_clear_free(dhg->g);
#line 98
  BN_clear_free(dhg->p);
  fail: 
#line 100
  error("Bad prime description in line %d", linenum);
#line 101
  return (0);
}
}
#line 104 "dh.c"
DH *choose_dh(int min , int wantbits , int max ) 
{ FILE *f ;
  char line[2048] ;
  int best ;
  int bestcount ;
  int which ;
  int linenum ;
  struct dhgroup dhg ;
  DH *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  DH *tmp___6 ;

  {
#line 113
  f = fopen((char const   * __restrict  )"/usr/local/etc/moduli", (char const   * __restrict  )"r");
#line 113
  if ((unsigned int )f == (unsigned int )((void *)0)) {
#line 113
    f = fopen((char const   * __restrict  )"/usr/local/etc/primes", (char const   * __restrict  )"r");
#line 113
    if ((unsigned int )f == (unsigned int )((void *)0)) {
#line 115
      log("WARNING: %s does not exist, using old modulus", "/usr/local/etc/moduli");
#line 116
      tmp = dh_new_group1();
#line 116
      return (tmp);
    }
  }
#line 119
  linenum = 0;
#line 120
  bestcount = 0;
#line 120
  best = bestcount;
#line 121
  while (1) {
#line 121
    tmp___1 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 121
    if (! tmp___1) {
#line 121
      break;
    }
#line 122
    linenum ++;
#line 123
    tmp___0 = parse_prime(linenum, line, & dhg);
#line 123
    if (! tmp___0) {
#line 124
      continue;
    }
#line 125
    BN_clear_free(dhg.g);
#line 126
    BN_clear_free(dhg.p);
#line 128
    if (dhg.size > max) {
#line 129
      continue;
    } else {
#line 128
      if (dhg.size < min) {
#line 129
        continue;
      }
    }
#line 131
    if (dhg.size > wantbits) {
#line 131
      if (dhg.size < best) {
#line 133
        best = dhg.size;
#line 134
        bestcount = 0;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 131
      if (dhg.size > best) {
#line 131
        if (best < wantbits) {
#line 133
          best = dhg.size;
#line 134
          bestcount = 0;
        }
      }
    }
#line 136
    if (dhg.size == best) {
#line 137
      bestcount ++;
    }
  }
#line 139
  rewind(f);
#line 141
  if (bestcount == 0) {
#line 142
    fclose(f);
#line 143
    log("WARNING: no suitable primes in %s", "/usr/local/etc/primes");
#line 144
    return ((DH *)((void *)0));
  }
#line 147
  linenum = 0;
#line 148
  tmp___2 = arc4random();
#line 148
  which = (int )(tmp___2 % (unsigned int )bestcount);
#line 149
  while (1) {
#line 149
    tmp___5 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 149
    if (! tmp___5) {
#line 149
      break;
    }
#line 150
    tmp___3 = parse_prime(linenum, line, & dhg);
#line 150
    if (! tmp___3) {
#line 151
      continue;
    }
#line 152
    if (dhg.size > max) {
#line 155
      BN_clear_free(dhg.g);
#line 156
      BN_clear_free(dhg.p);
#line 157
      continue;
    } else {
#line 152
      if (dhg.size < min) {
#line 155
        BN_clear_free(dhg.g);
#line 156
        BN_clear_free(dhg.p);
#line 157
        continue;
      } else {
#line 152
        if (dhg.size != best) {
#line 155
          BN_clear_free(dhg.g);
#line 156
          BN_clear_free(dhg.p);
#line 157
          continue;
        } else {
#line 152
          tmp___4 = linenum;
#line 152
          linenum ++;
#line 152
          if (tmp___4 != which) {
#line 155
            BN_clear_free(dhg.g);
#line 156
            BN_clear_free(dhg.p);
#line 157
            continue;
          }
        }
      }
    }
#line 159
    break;
  }
#line 161
  fclose(f);
#line 162
  if (linenum != which + 1) {
#line 163
    fatal("WARNING: line %d disappeared in %s, giving up", which, "/usr/local/etc/primes");
  }
#line 166
  tmp___6 = dh_new_group(dhg.g, dhg.p);
#line 166
  return (tmp___6);
}
}
#line 171 "dh.c"
int dh_pub_is_valid(DH *dh , BIGNUM *dh_pub ) 
{ int i ;
  int n___0 ;
  int tmp ;
  int bits_set ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 175
  tmp = BN_num_bits((BIGNUM const   *)dh_pub);
#line 175
  n___0 = tmp;
#line 176
  bits_set = 0;
#line 178
  if (dh_pub->neg) {
#line 179
    log("invalid public DH value: negativ");
#line 180
    return (0);
  }
#line 182
  i = 0;
#line 182
  while (i <= n___0) {
#line 183
    tmp___0 = BN_is_bit_set((BIGNUM const   *)dh_pub, i);
#line 183
    if (tmp___0) {
#line 184
      bits_set ++;
    }
#line 182
    i ++;
  }
#line 185
  tmp___1 = BN_num_bits((BIGNUM const   *)dh->p);
#line 185
  debug("bits set: %d/%d", bits_set, tmp___1);
#line 188
  if (bits_set > 1) {
#line 188
    tmp___2 = BN_cmp((BIGNUM const   *)dh_pub, (BIGNUM const   *)dh->p);
#line 188
    if (tmp___2 == -1) {
#line 189
      return (1);
    }
  }
#line 190
  tmp___3 = BN_num_bits((BIGNUM const   *)dh->p);
#line 190
  log("invalid public DH value (%d/%d)", bits_set, tmp___3);
#line 191
  return (0);
}
}
#line 194 "dh.c"
void dh_gen_key(DH *dh , int need ) 
{ int i ;
  int bits_set ;
  int tries ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 197
  bits_set = 0;
#line 197
  tries = 0;
#line 199
  if ((unsigned int )dh->p == (unsigned int )((void *)0)) {
#line 200
    fatal("dh_gen_key: dh->p == NULL");
  }
#line 201
  tmp___0 = BN_num_bits((BIGNUM const   *)dh->p);
#line 201
  if (2 * need >= tmp___0) {
#line 202
    tmp = BN_num_bits((BIGNUM const   *)dh->p);
#line 202
    fatal("dh_gen_key: group too small: %d (2*need %d)", tmp, 2 * need);
  }
#line 204
  while (1) {
#line 205
    if ((unsigned int )dh->priv_key != (unsigned int )((void *)0)) {
#line 206
      BN_clear_free(dh->priv_key);
    }
#line 207
    dh->priv_key = BN_new();
#line 207
    if ((unsigned int )dh->priv_key == (unsigned int )((void *)0)) {
#line 208
      fatal("dh_gen_key: BN_new failed");
    }
#line 210
    tmp___1 = BN_rand(dh->priv_key, 2 * need, 0, 0);
#line 210
    if (! tmp___1) {
#line 211
      fatal("dh_gen_key: BN_rand failed");
    }
#line 212
    tmp___2 = DH_generate_key(dh);
#line 212
    if (tmp___2 == 0) {
#line 213
      fatal("DH_generate_key");
    }
#line 214
    i = 0;
#line 214
    while (1) {
#line 214
      tmp___4 = BN_num_bits((BIGNUM const   *)dh->priv_key);
#line 214
      if (! (i <= tmp___4)) {
#line 214
        break;
      }
#line 215
      tmp___3 = BN_is_bit_set((BIGNUM const   *)dh->priv_key, i);
#line 215
      if (tmp___3) {
#line 216
        bits_set ++;
      }
#line 214
      i ++;
    }
#line 217
    tmp___5 = BN_num_bits((BIGNUM const   *)dh->priv_key);
#line 217
    debug("dh_gen_key: priv key bits set: %d/%d", bits_set, tmp___5);
#line 219
    tmp___6 = tries;
#line 219
    tries ++;
#line 219
    if (tmp___6 > 10) {
#line 220
      fatal("dh_gen_key: too many bad keys: giving up");
    }
#line 204
    tmp___7 = dh_pub_is_valid(dh, dh->pub_key);
#line 204
    if (tmp___7) {
#line 204
      break;
    }
  }
#line 222
  return;
}
}
#line 224 "dh.c"
DH *dh_new_group_asc(char const   *gen___0 , char const   *modulus ) 
{ DH *dh ;
  int tmp ;
  int tmp___0 ;

  {
#line 229
  dh = DH_new();
#line 229
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 230
    fatal("dh_new_group_asc: DH_new");
  }
#line 232
  tmp = BN_hex2bn(& dh->p, modulus);
#line 232
  if (tmp == 0) {
#line 233
    fatal("BN_hex2bn p");
  }
#line 234
  tmp___0 = BN_hex2bn(& dh->g, gen___0);
#line 234
  if (tmp___0 == 0) {
#line 235
    fatal("BN_hex2bn g");
  }
#line 237
  return (dh);
}
}
#line 245 "dh.c"
DH *dh_new_group(BIGNUM *gen___0 , BIGNUM *modulus ) 
{ DH *dh ;

  {
#line 250
  dh = DH_new();
#line 250
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 251
    fatal("dh_new_group: DH_new");
  }
#line 252
  dh->p = modulus;
#line 253
  dh->g = gen___0;
#line 255
  return (dh);
}
}
#line 261 "dh.c"
static char *gen  =    (char *)"2";
#line 261 "dh.c"
static char *group1  =    (char *)"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF";
#line 258 "dh.c"
DH *dh_new_group1(void) 
{ DH *tmp ;

  {
#line 269
  tmp = dh_new_group_asc((char const   *)gen, (char const   *)group1);
#line 269
  return (tmp);
}
}
#line 278 "dh.c"
int dh_estimate(int bits ) 
{ 

  {
#line 282
  if (bits < 64) {
#line 283
    return (512);
  }
#line 284
  if (bits < 128) {
#line 285
    return (1024);
  }
#line 286
  if (bits < 192) {
#line 287
    return (2048);
  }
#line 288
  return (4096);
}
}
#line 1 "dispatch.o"
#line 33 "dispatch.h"
void dispatch_init(dispatch_fn *dflt ) ;
#line 34
void dispatch_set(int type , dispatch_fn *fn ) ;
#line 35
void dispatch_range(u_int from , u_int to , dispatch_fn *fn ) ;
#line 36
void dispatch_run(int mode , int *done , void *ctxt ) ;
#line 37
void dispatch_protocol_error(int type , u_int32_t seq , void *ctxt ) ;
#line 38
void dispatch_protocol_ignore(int type , u_int32_t seq , void *ctxt ) ;
#line 48 "packet.h"
int packet_read_seqnr(u_int32_t *seqnr_p ) ;
#line 49
int packet_read_poll_seqnr(u_int32_t *seqnr_p ) ;
#line 37 "dispatch.c"
dispatch_fn *dispatch[255]  ;
#line 39 "dispatch.c"
void dispatch_protocol_error(int type , u_int32_t seq , void *ctxt ) 
{ 

  {
#line 42
  log("dispatch_protocol_error: type %d seq %u", type, seq);
#line 43
  if (! compat20) {
#line 44
    fatal("protocol error");
  }
#line 45
  packet_start((unsigned char)3);
#line 46
  packet_put_int(seq);
#line 47
  packet_send();
#line 48
  packet_write_wait();
#line 49
  return;
}
}
#line 50 "dispatch.c"
void dispatch_protocol_ignore(int type , u_int32_t seq , void *ctxt ) 
{ 

  {
#line 53
  log("dispatch_protocol_ignore: type %d seq %u", type, seq);
#line 54
  return;
}
}
#line 55 "dispatch.c"
void dispatch_init(dispatch_fn *dflt ) 
{ u_int i ;

  {
#line 59
  i = 0U;
#line 59
  while (i < 255U) {
#line 60
    dispatch[i] = dflt;
#line 59
    i ++;
  }
#line 61
  return;
}
}
#line 62 "dispatch.c"
void dispatch_range(u_int from , u_int to , dispatch_fn *fn ) 
{ u_int i ;

  {
#line 67
  i = from;
#line 67
  while (i <= to) {
#line 68
    if (i >= 255U) {
#line 69
      break;
    }
#line 70
    dispatch[i] = fn;
#line 67
    i ++;
  }
#line 72
  return;
}
}
#line 73 "dispatch.c"
void dispatch_set(int type , dispatch_fn *fn ) 
{ 

  {
#line 76
  dispatch[type] = fn;
#line 77
  return;
}
}
#line 78 "dispatch.c"
void dispatch_run(int mode , int *done , void *ctxt ) 
{ int type ;
  u_int32_t seqnr ;

  {
#line 81
  while (1) {
#line 85
    if (mode == 0) {
#line 86
      type = packet_read_seqnr(& seqnr);
    } else {
#line 88
      type = packet_read_poll_seqnr(& seqnr);
#line 89
      if (type == 0) {
#line 90
        return;
      }
    }
#line 92
    if (type > 0) {
#line 92
      if (type < 255) {
#line 92
        if ((unsigned int )dispatch[type] != (unsigned int )((void *)0)) {
#line 93
          (*(dispatch[type]))(type, seqnr, ctxt);
        } else {
#line 95
          packet_disconnect("protocol error: rcvd type %d", type);
        }
      } else {
#line 95
        packet_disconnect("protocol error: rcvd type %d", type);
      }
    } else {
#line 95
      packet_disconnect("protocol error: rcvd type %d", type);
    }
#line 96
    if ((unsigned int )done != (unsigned int )((void *)0)) {
#line 96
      if (*done) {
#line 97
        return;
      }
    }
  }
}
}
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 1 "fatal.o"
#line 68 "log.h"
void do_log(LogLevel level , char const   *fmt , va_list args ) ;
#line 32 "fatal.c"
void ( /* format attribute */  fatal)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 36
  __builtin_va_start(args, fmt);
#line 37
  do_log(1, fmt, args);
#line 38
  __builtin_va_end(args);
#line 39
  fatal_cleanup();
#line 40
  return;
}
}
#line 1 "mac.o"
#line 593 "/usr/include/openssl/evp.h"
extern EVP_MD const   *EVP_md5(void) ;
#line 597
extern EVP_MD const   *EVP_sha1(void) ;
#line 611
extern EVP_MD const   *EVP_ripemd160(void) ;
#line 89 "/usr/include/openssl/hmac.h"
extern void HMAC_CTX_cleanup(HMAC_CTX *ctx ) ;
#line 93
extern void HMAC_Init(HMAC_CTX *ctx , void const   *key , int len , EVP_MD const   *md ) ;
#line 97
extern void HMAC_Update(HMAC_CTX *ctx , unsigned char const   *data , size_t len ) ;
#line 98
extern void HMAC_Final(HMAC_CTX *ctx , unsigned char *md , unsigned int *len ) ;
#line 26 "mac.h"
int mac_valid(char const   *names ) ;
#line 27
int mac_init(Mac *mac , char *name ) ;
#line 28
u_char *mac_compute(Mac *mac , u_int32_t seqno , u_char *data , int datalen ) ;
#line 37 "mac.c"
struct __anonstruct_macs_70 macs[7]  = {      {(char *)"hmac-sha1", & EVP_sha1, 0}, 
        {(char *)"hmac-sha1-96", & EVP_sha1, 96}, 
        {(char *)"hmac-md5", & EVP_md5, 0}, 
        {(char *)"hmac-md5-96", & EVP_md5, 96}, 
        {(char *)"hmac-ripemd160", & EVP_ripemd160, 0}, 
        {(char *)"hmac-ripemd160@openssh.com", & EVP_ripemd160, 0}, 
        {(char *)((void *)0), (EVP_MD const   *(*)(void))((void *)0), 0}};
#line 51 "mac.c"
int mac_init(Mac *mac , char *name ) 
{ int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 55
  i = 0;
#line 55
  while (macs[i].name) {
#line 56
    if (0) {
#line 56
      __s1_len = strlen((char const   *)name);
#line 56
      __s2_len = strlen((char const   *)macs[i].name);
#line 56
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___0;
      } else {
#line 56
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 56
          if (! ((unsigned int )((void const   *)(macs[i].name + 1)) - (unsigned int )((void const   *)macs[i].name) == 1U)) {
#line 56
            tmp___8 = 1;
          } else {
#line 56
            if (__s2_len >= 4U) {
#line 56
              tmp___8 = 1;
            } else {
#line 56
              tmp___8 = 0;
            }
          }
        } else {
#line 56
          tmp___8 = 0;
        }
      }
#line 56
      if (tmp___8) {
#line 56
        tmp___4 = __builtin_strcmp((char const   *)name, (char const   *)macs[i].name);
      } else {
#line 56
        tmp___7 = __builtin_strcmp((char const   *)name, (char const   *)macs[i].name);
#line 56
        tmp___4 = tmp___7;
      }
    } else {
#line 56
      tmp___7 = __builtin_strcmp((char const   *)name, (char const   *)macs[i].name);
#line 56
      tmp___4 = tmp___7;
    }
#line 56
    if (tmp___4 == 0) {
#line 57
      if ((unsigned int )mac != (unsigned int )((void *)0)) {
#line 58
        mac->md = (*(macs[i].mdfunc))();
#line 59
        mac->mac_len = (int )(mac->md)->md_size;
#line 59
        mac->key_len = mac->mac_len;
#line 60
        if (macs[i].truncatebits != 0) {
#line 61
          mac->mac_len = macs[i].truncatebits / 8;
        }
      }
#line 63
      debug2("mac_init: found %s", name);
#line 64
      return (0);
    }
#line 55
    i ++;
  }
#line 67
  debug2("mac_init: unknown %s", name);
#line 68
  return (-1);
}
}
#line 75 "mac.c"
static u_char m[64]  ;
#line 71 "mac.c"
u_char *mac_compute(Mac *mac , u_int32_t seqno , u_char *data , int datalen ) 
{ HMAC_CTX c ;
  u_char b[4] ;

  {
#line 78
  if ((unsigned int )mac->key == (unsigned int )((void *)0)) {
#line 79
    fatal("mac_compute: no key");
  }
#line 80
  if ((unsigned int )mac->mac_len > sizeof(m)) {
#line 81
    fatal("mac_compute: mac too long");
  }
#line 82
  HMAC_Init(& c, (void const   *)mac->key, mac->key_len, mac->md);
#line 83
  while (1) {
#line 83
    b[0] = (unsigned char )(seqno >> 24);
#line 83
    b[1] = (unsigned char )(seqno >> 16);
#line 83
    b[2] = (unsigned char )(seqno >> 8);
#line 83
    b[3] = (unsigned char )seqno;
#line 83
    break;
  }
#line 84
  HMAC_Update(& c, (unsigned char const   *)(b), sizeof(b));
#line 85
  HMAC_Update(& c, (unsigned char const   *)data, (unsigned int )datalen);
#line 86
  HMAC_Final(& c, m, (unsigned int *)((void *)0));
#line 87
  HMAC_CTX_cleanup(& c);
#line 88
  return (m);
}
}
#line 93 "mac.c"
int mac_valid(char const   *names ) 
{ char *maclist ;
  char *cp ;
  char *p ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___24 ;
  char *tmp___40 ;
  int tmp___41 ;

  {
#line 98
  if ((unsigned int )names == (unsigned int )((void *)0)) {
#line 99
    return (0);
  } else {
#line 98
    if (0) {
#line 98
      __s1_len = strlen(names);
#line 98
      __s2_len = strlen("");
#line 98
      if (! ((unsigned int )((void const   *)(names + 1)) - (unsigned int )((void const   *)names) == 1U)) {
        goto _L___0;
      } else {
#line 98
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 98
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 98
            tmp___8 = 1;
          } else {
#line 98
            if (__s2_len >= 4U) {
#line 98
              tmp___8 = 1;
            } else {
#line 98
              tmp___8 = 0;
            }
          }
        } else {
#line 98
          tmp___8 = 0;
        }
      }
#line 98
      if (tmp___8) {
#line 98
        tmp___4 = __builtin_strcmp(names, "");
      } else {
#line 98
        tmp___7 = __builtin_strcmp(names, "");
#line 98
        tmp___4 = tmp___7;
      }
    } else {
#line 98
      tmp___7 = __builtin_strcmp(names, "");
#line 98
      tmp___4 = tmp___7;
    }
#line 98
    if (tmp___4 == 0) {
#line 99
      return (0);
    }
  }
#line 100
  cp = xstrdup(names);
#line 100
  maclist = cp;
#line 101
  tmp___24 = __strsep_g(& cp, ",");
#line 101
  p = tmp___24;
#line 101
  while (1) {
#line 101
    if (p) {
#line 101
      if (! ((int )*p != 0)) {
#line 101
        break;
      }
    } else {
#line 101
      break;
    }
#line 103
    tmp___41 = mac_init((Mac *)((void *)0), p);
#line 103
    if (tmp___41 < 0) {
#line 104
      debug("bad mac %s [%s]", p, names);
#line 105
      xfree((void *)maclist);
#line 106
      return (0);
    } else {
#line 108
      debug3("mac ok: %s [%s]", p, names);
    }
#line 102
    tmp___40 = __strsep_g(& cp, ",");
#line 102
    p = tmp___40;
  }
#line 111
  debug3("macs ok: [%s]", names);
#line 112
  xfree((void *)maclist);
#line 113
  return (1);
}
}
#line 1 "msg.o"
#line 28 "msg.h"
void msg_send(int fd , u_char type , Buffer *m___0 ) ;
#line 29
int msg_recv(int fd , Buffer *m___0 ) ;
#line 33 "msg.c"
void msg_send(int fd , u_char type , Buffer *m___0 ) 
{ u_char buf___1[5] ;
  u_int mlen ;
  u_int tmp ;
  ssize_t tmp___0 ;
  void *tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 37
  tmp = buffer_len(m___0);
#line 37
  mlen = tmp;
#line 39
  debug3("msg_send: type %u", (unsigned int )type & 255U);
#line 41
  while (1) {
#line 41
    buf___1[0] = (unsigned char )((mlen + 1U) >> 24);
#line 41
    buf___1[1] = (unsigned char )((mlen + 1U) >> 16);
#line 41
    buf___1[2] = (unsigned char )((mlen + 1U) >> 8);
#line 41
    buf___1[3] = (unsigned char )(mlen + 1U);
#line 41
    break;
  }
#line 42
  buf___1[4] = type;
#line 43
  tmp___0 = atomicio((ssize_t (*)())(& write), fd, (void *)(buf___1), sizeof(buf___1));
#line 43
  if ((unsigned int )tmp___0 != sizeof(buf___1)) {
#line 44
    fatal("msg_send: write");
  }
#line 45
  tmp___1 = buffer_ptr(m___0);
#line 45
  tmp___2 = atomicio((ssize_t (*)())(& write), fd, tmp___1, mlen);
#line 45
  if ((u_int )tmp___2 != mlen) {
#line 46
    fatal("msg_send: write");
  }
#line 47
  return;
}
}
#line 49 "msg.c"
int msg_recv(int fd , Buffer *m___0 ) 
{ u_char buf___1[4] ;
  ssize_t res ;
  u_int msg_len ;
  void *tmp ;

  {
#line 56
  debug3("msg_recv entering");
#line 58
  res = atomicio((ssize_t (*)())(& read), fd, (void *)(buf___1), sizeof(buf___1));
#line 59
  if ((unsigned int )res != sizeof(buf___1)) {
#line 60
    if (res == 0) {
#line 61
      return (-1);
    }
#line 62
    fatal("msg_recv: read: header %ld", (long )res);
  }
#line 64
  msg_len = (unsigned int )(((((unsigned long )buf___1[0] << 24) | ((unsigned long )buf___1[1] << 16)) | ((unsigned long )buf___1[2] << 8)) | (unsigned long )buf___1[3]);
#line 65
  if (msg_len > 262144U) {
#line 66
    fatal("msg_recv: read: bad msg_len %d", msg_len);
  }
#line 67
  buffer_clear(m___0);
#line 68
  buffer_append_space(m___0, msg_len);
#line 69
  tmp = buffer_ptr(m___0);
#line 69
  res = atomicio((ssize_t (*)())(& read), fd, tmp, msg_len);
#line 70
  if ((u_int )res != msg_len) {
#line 71
    fatal("msg_recv: read: %ld != msg_len", (long )res);
  }
#line 72
  return (0);
}
}
#line 1 "hostfile.o"
#line 19 "match.h"
int match_hostname(char const   *host , char const   *pattern , u_int len ) ;
#line 62 "key.h"
int key_equal(Key *a , Key *b ) ;
#line 65
int key_write(Key *key , FILE *f ) ;
#line 67
u_int key_size(Key *k ) ;
#line 21 "hostfile.h"
int hostfile_read_key(char **cpp , u_int *bitsp , Key *ret ) ;
#line 22
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , Key *key ,
                                  Key *found , int *numret ) ;
#line 24
int add_host_to_hostfile(char const   *filename , char const   *host , Key *key ) ;
#line 52 "hostfile.c"
int hostfile_read_key(char **cpp , u_int *bitsp , Key *ret ) 
{ char *cp ;
  int tmp ;

  {
#line 58
  cp = *cpp;
#line 58
  while (1) {
#line 58
    if (! ((int )*cp == 32)) {
#line 58
      if (! ((int )*cp == 9)) {
#line 58
        break;
      }
    }
#line 58
    cp ++;
  }
#line 61
  tmp = key_read(ret, & cp);
#line 61
  if (tmp != 1) {
#line 62
    return (0);
  }
#line 65
  while (1) {
#line 65
    if (! ((int )*cp == 32)) {
#line 65
      if (! ((int )*cp == 9)) {
#line 65
        break;
      }
    }
#line 65
    cp ++;
  }
#line 69
  *cpp = cp;
#line 70
  *bitsp = key_size(ret);
#line 71
  return (1);
}
}
#line 74 "hostfile.c"
static int hostfile_check_key(int bits , Key *key , char const   *host , char const   *filename ,
                              int linenum ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 77
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 78
    return (1);
  } else {
#line 77
    if (key->type != 0) {
#line 78
      return (1);
    } else {
#line 77
      if ((unsigned int )key->rsa == (unsigned int )((void *)0)) {
#line 78
        return (1);
      }
    }
  }
#line 79
  tmp___1 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 79
  if (bits != tmp___1) {
#line 80
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 80
    log("Warning: %s, line %d: keysize mismatch for host %s: actual %d vs. announced %d.",
        filename, linenum, host, tmp, bits);
#line 83
    tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 83
    log("Warning: replace %d with %d in %s, line %d.", bits, tmp___0, filename, linenum);
  }
#line 86
  return (1);
}
}
#line 96 "hostfile.c"
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , Key *key ,
                                  Key *found , int *numret ) 
{ FILE *f ;
  char line[8192] ;
  int linenum ;
  u_int kbits ;
  char *cp ;
  char *cp2 ;
  HostStatus end_return ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 102
  linenum = 0;
#line 107
  debug3("check_host_in_hostfile: filename %s", filename);
#line 108
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 109
    fatal("no key to look up");
  }
#line 111
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 112
  if (! f) {
#line 113
    return (1);
  }
#line 120
  end_return = 1;
#line 123
  while (1) {
#line 123
    tmp___3 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 123
    if (! tmp___3) {
#line 123
      break;
    }
#line 124
    cp = line;
#line 125
    linenum ++;
#line 128
    while (1) {
#line 128
      if (! ((int )*cp == 32)) {
#line 128
        if (! ((int )*cp == 9)) {
#line 128
          break;
        }
      }
#line 128
      cp ++;
    }
#line 130
    if (! *cp) {
#line 131
      continue;
    } else {
#line 130
      if ((int )*cp == 35) {
#line 131
        continue;
      } else {
#line 130
        if ((int )*cp == 10) {
#line 131
          continue;
        }
      }
    }
#line 134
    cp2 = cp;
#line 134
    while (1) {
#line 134
      if (*cp2) {
#line 134
        if ((int )*cp2 != 32) {
#line 134
          if (! ((int )*cp2 != 9)) {
#line 134
            break;
          }
        } else {
#line 134
          break;
        }
      } else {
#line 134
        break;
      }
#line 134
      cp2 ++;
    }
#line 138
    tmp = match_hostname(host, (char const   *)cp, (unsigned int )(cp2 - cp));
#line 138
    if (tmp != 1) {
#line 139
      continue;
    }
#line 142
    cp = cp2;
#line 148
    tmp___0 = hostfile_read_key(& cp, & kbits, found);
#line 148
    if (! tmp___0) {
#line 149
      continue;
    }
#line 150
    tmp___1 = hostfile_check_key((int )kbits, found, host, filename, linenum);
#line 150
    if (! tmp___1) {
#line 151
      continue;
    }
#line 153
    if ((unsigned int )numret != (unsigned int )((void *)0)) {
#line 154
      *numret = linenum;
    }
#line 157
    tmp___2 = key_equal(key, found);
#line 157
    if (tmp___2) {
#line 159
      debug3("check_host_in_hostfile: match line %d", linenum);
#line 160
      fclose(f);
#line 161
      return (0);
    }
#line 168
    end_return = 2;
  }
#line 171
  fclose(f);
#line 177
  return (end_return);
}
}
#line 185 "hostfile.c"
int add_host_to_hostfile(char const   *filename , char const   *host , Key *key ) 
{ FILE *f ;
  int success ;
  int tmp ;

  {
#line 189
  success = 0;
#line 190
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 191
    return (1);
  }
#line 192
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"a");
#line 193
  if (! f) {
#line 194
    return (0);
  }
#line 195
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s ", host);
#line 196
  tmp = key_write(key, f);
#line 196
  if (tmp) {
#line 197
    success = 1;
  } else {
#line 199
    error("add_host_to_hostfile: saving key in %s failed", filename);
  }
#line 201
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"\n");
#line 202
  fclose(f);
#line 203
  return (success);
}
}
#line 1 "key.o"
#line 470 "/usr/include/openssl/crypto.h"
extern void CRYPTO_free(void * ) ;
#line 410 "/usr/include/openssl/bn.h"
extern BIGNUM *BN_copy(BIGNUM *a , BIGNUM const   *b ) ;
#line 491
extern BIGNUM *BN_dup(BIGNUM const   *a ) ;
#line 496
extern char *BN_bn2dec(BIGNUM const   *a ) ;
#line 498
extern int BN_dec2bn(BIGNUM **a , char const   *str ) ;
#line 491 "/usr/include/openssl/evp.h"
extern int EVP_DigestUpdate(EVP_MD_CTX *ctx , void const   *d , size_t cnt ) ;
#line 498
extern int EVP_DigestInit(EVP_MD_CTX *ctx , EVP_MD const   *type ) ;
#line 499
extern int EVP_DigestFinal(EVP_MD_CTX *ctx , unsigned char *md , unsigned int *s ) ;
#line 215 "/usr/include/openssl/rsa.h"
extern RSA *RSA_new(void) ;
#line 221
extern RSA *RSA_generate_key(int bits , unsigned long e , void (*callback)(int  ,
                                                                           int  ,
                                                                           void * ) ,
                             void *cb_arg ) ;
#line 238
extern void RSA_free(RSA *r ) ;
#line 190 "/usr/include/openssl/dsa.h"
extern DSA *DSA_new(void) ;
#line 192
extern void DSA_free(DSA *r ) ;
#line 213
extern DSA *DSA_generate_parameters(int bits , unsigned char *seed , int seed_len ,
                                    int *counter_ret , unsigned long *h_ret , void (*callback)(int  ,
                                                                                               int  ,
                                                                                               void * ) ,
                                    void *cb_arg ) ;
#line 224
extern int DSA_generate_key(DSA *a ) ;
#line 61 "key.h"
Key *key_demote(Key *k ) ;
#line 63
char *key_fingerprint(Key *k , enum fp_type dgst_type , enum fp_rep dgst_rep ) ;
#line 69
Key *key_generate(int type , u_int bits ) ;
#line 70
Key *key_from_private(Key *k ) ;
#line 71
int key_type_from_name(char *name ) ;
#line 76
int key_names_valid2(char const   *names ) ;
#line 78
int key_sign(Key *key , u_char **sigp , u_int *lenp , u_char *data , u_int datalen ) ;
#line 79
int key_verify(Key *key , u_char *signature , u_int signaturelen , u_char *data ,
               u_int datalen ) ;
#line 29 "ssh-dss.h"
int ssh_dss_sign(Key *key , u_char **sigp , u_int *lenp , u_char *data , u_int datalen ) ;
#line 30
int ssh_dss_verify(Key *key , u_char *signature , u_int signaturelen , u_char *data ,
                   u_int datalen ) ;
#line 29 "ssh-rsa.h"
int ssh_rsa_sign(Key *key , u_char **sigp , u_int *lenp , u_char *data , u_int datalen ) ;
#line 30
int ssh_rsa_verify(Key *key , u_char *signature , u_int signaturelen , u_char *data ,
                   u_int datalen ) ;
#line 29 "uuencode.h"
int uuencode(u_char *src , u_int srclength , char *target , size_t targsize ) ;
#line 30
int uudecode(char const   *src , u_char *target , size_t targsize ) ;
#line 49 "key.c"
Key *key_new(int type ) 
{ Key *k ;
  RSA *rsa ;
  DSA *dsa ;
  void *tmp ;

  {
#line 55
  tmp = xmalloc(sizeof(*k));
#line 55
  k = (Key *)tmp;
#line 56
  k->type = type;
#line 57
  k->flags = 0;
#line 58
  k->dsa = (DSA *)((void *)0);
#line 59
  k->rsa = (RSA *)((void *)0);
#line 60
  switch (k->type) {
  case 0: 
  case 1: 
#line 63
  rsa = RSA_new();
#line 63
  if ((unsigned int )rsa == (unsigned int )((void *)0)) {
#line 64
    fatal("key_new: RSA_new failed");
  }
#line 65
  rsa->n = BN_new();
#line 65
  if ((unsigned int )rsa->n == (unsigned int )((void *)0)) {
#line 66
    fatal("key_new: BN_new failed");
  }
#line 67
  rsa->e = BN_new();
#line 67
  if ((unsigned int )rsa->e == (unsigned int )((void *)0)) {
#line 68
    fatal("key_new: BN_new failed");
  }
#line 69
  k->rsa = rsa;
#line 70
  break;
  case 2: 
#line 72
  dsa = DSA_new();
#line 72
  if ((unsigned int )dsa == (unsigned int )((void *)0)) {
#line 73
    fatal("key_new: DSA_new failed");
  }
#line 74
  dsa->p = BN_new();
#line 74
  if ((unsigned int )dsa->p == (unsigned int )((void *)0)) {
#line 75
    fatal("key_new: BN_new failed");
  }
#line 76
  dsa->q = BN_new();
#line 76
  if ((unsigned int )dsa->q == (unsigned int )((void *)0)) {
#line 77
    fatal("key_new: BN_new failed");
  }
#line 78
  dsa->g = BN_new();
#line 78
  if ((unsigned int )dsa->g == (unsigned int )((void *)0)) {
#line 79
    fatal("key_new: BN_new failed");
  }
#line 80
  dsa->pub_key = BN_new();
#line 80
  if ((unsigned int )dsa->pub_key == (unsigned int )((void *)0)) {
#line 81
    fatal("key_new: BN_new failed");
  }
#line 82
  k->dsa = dsa;
#line 83
  break;
  case 3: 
#line 85
  break;
  default: 
#line 87
  fatal("key_new: bad key type %d", k->type);
#line 88
  break;
  }
#line 90
  return (k);
}
}
#line 93 "key.c"
Key *key_new_private(int type ) 
{ Key *k ;
  Key *tmp ;

  {
#line 96
  tmp = key_new(type);
#line 96
  k = tmp;
#line 97
  switch (k->type) {
  case 0: 
  case 1: 
#line 100
  (k->rsa)->d = BN_new();
#line 100
  if ((unsigned int )(k->rsa)->d == (unsigned int )((void *)0)) {
#line 101
    fatal("key_new_private: BN_new failed");
  }
#line 102
  (k->rsa)->iqmp = BN_new();
#line 102
  if ((unsigned int )(k->rsa)->iqmp == (unsigned int )((void *)0)) {
#line 103
    fatal("key_new_private: BN_new failed");
  }
#line 104
  (k->rsa)->q = BN_new();
#line 104
  if ((unsigned int )(k->rsa)->q == (unsigned int )((void *)0)) {
#line 105
    fatal("key_new_private: BN_new failed");
  }
#line 106
  (k->rsa)->p = BN_new();
#line 106
  if ((unsigned int )(k->rsa)->p == (unsigned int )((void *)0)) {
#line 107
    fatal("key_new_private: BN_new failed");
  }
#line 108
  (k->rsa)->dmq1 = BN_new();
#line 108
  if ((unsigned int )(k->rsa)->dmq1 == (unsigned int )((void *)0)) {
#line 109
    fatal("key_new_private: BN_new failed");
  }
#line 110
  (k->rsa)->dmp1 = BN_new();
#line 110
  if ((unsigned int )(k->rsa)->dmp1 == (unsigned int )((void *)0)) {
#line 111
    fatal("key_new_private: BN_new failed");
  }
#line 112
  break;
  case 2: 
#line 114
  (k->dsa)->priv_key = BN_new();
#line 114
  if ((unsigned int )(k->dsa)->priv_key == (unsigned int )((void *)0)) {
#line 115
    fatal("key_new_private: BN_new failed");
  }
#line 116
  break;
  case 3: 
#line 118
  break;
  default: ;
#line 120
  break;
  }
#line 122
  return (k);
}
}
#line 125 "key.c"
void key_free(Key *k ) 
{ 

  {
#line 128
  switch (k->type) {
  case 0: 
  case 1: 
#line 131
  if ((unsigned int )k->rsa != (unsigned int )((void *)0)) {
#line 132
    RSA_free(k->rsa);
  }
#line 133
  k->rsa = (RSA *)((void *)0);
#line 134
  break;
  case 2: 
#line 136
  if ((unsigned int )k->dsa != (unsigned int )((void *)0)) {
#line 137
    DSA_free(k->dsa);
  }
#line 138
  k->dsa = (DSA *)((void *)0);
#line 139
  break;
  case 3: 
#line 141
  break;
  default: 
#line 143
  fatal("key_free: bad key type %d", k->type);
#line 144
  break;
  }
#line 146
  xfree((void *)k);
#line 147
  return;
}
}
#line 148 "key.c"
int key_equal(Key *a , Key *b ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 151
  if ((unsigned int )a == (unsigned int )((void *)0)) {
#line 152
    return (0);
  } else {
#line 151
    if ((unsigned int )b == (unsigned int )((void *)0)) {
#line 152
      return (0);
    } else {
#line 151
      if (a->type != b->type) {
#line 152
        return (0);
      }
    }
  }
#line 153
  switch (a->type) {
  case 0: 
  case 1: 
#line 156
  if ((unsigned int )a->rsa != (unsigned int )((void *)0)) {
#line 156
    if ((unsigned int )b->rsa != (unsigned int )((void *)0)) {
#line 156
      tmp = BN_cmp((BIGNUM const   *)(a->rsa)->e, (BIGNUM const   *)(b->rsa)->e);
#line 156
      if (tmp == 0) {
#line 156
        tmp___0 = BN_cmp((BIGNUM const   *)(a->rsa)->n, (BIGNUM const   *)(b->rsa)->n);
#line 156
        if (tmp___0 == 0) {
#line 156
          tmp___1 = 1;
        } else {
#line 156
          tmp___1 = 0;
        }
      } else {
#line 156
        tmp___1 = 0;
      }
    } else {
#line 156
      tmp___1 = 0;
    }
  } else {
#line 156
    tmp___1 = 0;
  }
#line 156
  return (tmp___1);
#line 159
  break;
  case 2: 
#line 161
  if ((unsigned int )a->dsa != (unsigned int )((void *)0)) {
#line 161
    if ((unsigned int )b->dsa != (unsigned int )((void *)0)) {
#line 161
      tmp___2 = BN_cmp((BIGNUM const   *)(a->dsa)->p, (BIGNUM const   *)(b->dsa)->p);
#line 161
      if (tmp___2 == 0) {
#line 161
        tmp___3 = BN_cmp((BIGNUM const   *)(a->dsa)->q, (BIGNUM const   *)(b->dsa)->q);
#line 161
        if (tmp___3 == 0) {
#line 161
          tmp___4 = BN_cmp((BIGNUM const   *)(a->dsa)->g, (BIGNUM const   *)(b->dsa)->g);
#line 161
          if (tmp___4 == 0) {
#line 161
            tmp___5 = BN_cmp((BIGNUM const   *)(a->dsa)->pub_key, (BIGNUM const   *)(b->dsa)->pub_key);
#line 161
            if (tmp___5 == 0) {
#line 161
              tmp___6 = 1;
            } else {
#line 161
              tmp___6 = 0;
            }
          } else {
#line 161
            tmp___6 = 0;
          }
        } else {
#line 161
          tmp___6 = 0;
        }
      } else {
#line 161
        tmp___6 = 0;
      }
    } else {
#line 161
      tmp___6 = 0;
    }
  } else {
#line 161
    tmp___6 = 0;
  }
#line 161
  return (tmp___6);
#line 166
  break;
  default: 
#line 168
  fatal("key_equal: bad key type %d", a->type);
#line 169
  break;
  }
#line 171
  return (0);
}
}
#line 174 "key.c"
static u_char *key_fingerprint_raw(Key *k , enum fp_type dgst_type , u_int *dgst_raw_length ) 
{ EVP_MD const   *md ;
  EVP_MD_CTX ctx ;
  u_char *blob ;
  u_char *retval ;
  u_int len ;
  int nlen ;
  int elen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 177
  md = (EVP_MD const   *)((void *)0);
#line 179
  blob = (u_char *)((void *)0);
#line 180
  retval = (u_char *)((void *)0);
#line 181
  len = (u_int )0;
#line 184
  *dgst_raw_length = 0U;
#line 186
  switch ((int )dgst_type) {
  case 1: 
#line 188
  md = EVP_md5();
#line 189
  break;
  case 0: 
#line 191
  md = EVP_sha1();
#line 192
  break;
  default: 
#line 194
  fatal("key_fingerprint_raw: bad digest type %d", dgst_type);
  }
#line 197
  switch (k->type) {
  case 0: 
#line 199
  tmp = BN_num_bits((BIGNUM const   *)(k->rsa)->n);
#line 199
  nlen = (tmp + 7) / 8;
#line 200
  tmp___0 = BN_num_bits((BIGNUM const   *)(k->rsa)->e);
#line 200
  elen = (tmp___0 + 7) / 8;
#line 201
  len = (unsigned int )(nlen + elen);
#line 202
  tmp___1 = xmalloc(len);
#line 202
  blob = (u_char *)tmp___1;
#line 203
  BN_bn2bin((BIGNUM const   *)(k->rsa)->n, blob);
#line 204
  BN_bn2bin((BIGNUM const   *)(k->rsa)->e, blob + nlen);
#line 205
  break;
  case 2: 
  case 1: 
#line 208
  key_to_blob(k, & blob, & len);
#line 209
  break;
  case 3: 
#line 211
  return (retval);
#line 212
  break;
  default: 
#line 214
  fatal("key_fingerprint_raw: bad key type %d", k->type);
#line 215
  break;
  }
#line 217
  if ((unsigned int )blob != (unsigned int )((void *)0)) {
#line 218
    tmp___2 = xmalloc(64U);
#line 218
    retval = (u_char *)tmp___2;
#line 219
    EVP_DigestInit(& ctx, md);
#line 220
    EVP_DigestUpdate(& ctx, (void const   *)blob, len);
#line 221
    EVP_DigestFinal(& ctx, retval, dgst_raw_length);
#line 222
    memset((void *)blob, 0, len);
#line 223
    xfree((void *)blob);
  } else {
#line 225
    fatal("key_fingerprint_raw: blob is null");
  }
#line 227
  return (retval);
}
}
#line 230 "key.c"
static char *key_fingerprint_hex(u_char *dgst_raw , u_int dgst_raw_len ) 
{ char *retval ;
  int i ;
  void *tmp ;
  char hex[4] ;

  {
#line 236
  tmp = xmalloc(dgst_raw_len * 3U + 1U);
#line 236
  retval = (char *)tmp;
#line 237
  *(retval + 0) = (char )'\000';
#line 238
  i = 0;
#line 238
  while ((u_int )i < dgst_raw_len) {
#line 240
    snprintf((char * __restrict  )(hex), sizeof(hex), (char const   * __restrict  )"%02x:",
             *(dgst_raw + i));
#line 241
    strlcat(retval, (char const   *)(hex), dgst_raw_len * 3U);
#line 238
    i ++;
  }
#line 243
  *(retval + (dgst_raw_len * 3U - 1U)) = (char )'\000';
#line 244
  return (retval);
}
}
#line 247 "key.c"
static char *key_fingerprint_bubblebabble(u_char *dgst_raw , u_int dgst_raw_len ) 
{ char vowels[6] ;
  char consonants[17] ;
  u_int i ;
  u_int j ;
  u_int rounds ;
  u_int seed ;
  char *retval ;
  void *tmp ;
  u_int tmp___0 ;
  u_int idx0 ;
  u_int idx1 ;
  u_int idx2 ;
  u_int idx3 ;
  u_int idx4 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  u_int tmp___6 ;
  u_int tmp___7 ;
  u_int tmp___8 ;
  u_int tmp___9 ;
  u_int tmp___10 ;
  u_int tmp___11 ;

  {
#line 250
  vowels[0] = (char )'a';
#line 250
  vowels[1] = (char )'e';
#line 250
  vowels[2] = (char )'i';
#line 250
  vowels[3] = (char )'o';
#line 250
  vowels[4] = (char )'u';
#line 250
  vowels[5] = (char )'y';
#line 251
  consonants[0] = (char )'b';
#line 251
  consonants[1] = (char )'c';
#line 251
  consonants[2] = (char )'d';
#line 251
  consonants[3] = (char )'f';
#line 251
  consonants[4] = (char )'g';
#line 251
  consonants[5] = (char )'h';
#line 251
  consonants[6] = (char )'k';
#line 251
  consonants[7] = (char )'l';
#line 251
  consonants[8] = (char )'m';
#line 251
  consonants[9] = (char )'n';
#line 251
  consonants[10] = (char )'p';
#line 251
  consonants[11] = (char )'r';
#line 251
  consonants[12] = (char )'s';
#line 251
  consonants[13] = (char )'t';
#line 251
  consonants[14] = (char )'v';
#line 251
  consonants[15] = (char )'z';
#line 251
  consonants[16] = (char )'x';
#line 253
  j = (u_int )0;
#line 253
  seed = (u_int )1;
#line 256
  rounds = dgst_raw_len / 2U + 1U;
#line 257
  tmp = xmalloc(sizeof(char ) * (rounds * 6U));
#line 257
  retval = (char *)tmp;
#line 258
  tmp___0 = j;
#line 258
  j ++;
#line 258
  *(retval + tmp___0) = (char )'x';
#line 259
  i = 0U;
#line 259
  while (i < rounds) {
#line 261
    if (i + 1U < rounds) {
      goto _L;
    } else {
#line 261
      if (dgst_raw_len % 2U != 0U) {
        _L: /* CIL Label */ 
#line 262
        idx0 = ((((unsigned int )*(dgst_raw + 2U * i) >> 6) & 3U) + seed) % 6U;
#line 264
        idx1 = ((unsigned int )*(dgst_raw + 2U * i) >> 2) & 15U;
#line 265
        idx2 = (((unsigned int )*(dgst_raw + 2U * i) & 3U) + seed / 6U) % 6U;
#line 267
        tmp___1 = j;
#line 267
        j ++;
#line 267
        *(retval + tmp___1) = vowels[idx0];
#line 268
        tmp___2 = j;
#line 268
        j ++;
#line 268
        *(retval + tmp___2) = consonants[idx1];
#line 269
        tmp___3 = j;
#line 269
        j ++;
#line 269
        *(retval + tmp___3) = vowels[idx2];
#line 270
        if (i + 1U < rounds) {
#line 271
          idx3 = ((unsigned int )*(dgst_raw + (2U * i + 1U)) >> 4) & 15U;
#line 272
          idx4 = (unsigned int )*(dgst_raw + (2U * i + 1U)) & 15U;
#line 273
          tmp___4 = j;
#line 273
          j ++;
#line 273
          *(retval + tmp___4) = consonants[idx3];
#line 274
          tmp___5 = j;
#line 274
          j ++;
#line 274
          *(retval + tmp___5) = (char )'-';
#line 275
          tmp___6 = j;
#line 275
          j ++;
#line 275
          *(retval + tmp___6) = consonants[idx4];
#line 276
          seed = (seed * 5U + ((unsigned int )*(dgst_raw + 2U * i) * 7U + (unsigned int )*(dgst_raw + (2U * i + 1U)))) % 36U;
        }
      } else {
#line 281
        idx0 = seed % 6U;
#line 282
        idx1 = 16U;
#line 283
        idx2 = seed / 6U;
#line 284
        tmp___7 = j;
#line 284
        j ++;
#line 284
        *(retval + tmp___7) = vowels[idx0];
#line 285
        tmp___8 = j;
#line 285
        j ++;
#line 285
        *(retval + tmp___8) = consonants[idx1];
#line 286
        tmp___9 = j;
#line 286
        j ++;
#line 286
        *(retval + tmp___9) = vowels[idx2];
      }
    }
#line 259
    i ++;
  }
#line 289
  tmp___10 = j;
#line 289
  j ++;
#line 289
  *(retval + tmp___10) = (char )'x';
#line 290
  tmp___11 = j;
#line 290
  j ++;
#line 290
  *(retval + tmp___11) = (char )'\000';
#line 291
  return (retval);
}
}
#line 294 "key.c"
char *key_fingerprint(Key *k , enum fp_type dgst_type , enum fp_rep dgst_rep ) 
{ char *retval ;
  u_char *dgst_raw ;
  u_int dgst_raw_len ;

  {
#line 297
  retval = (char *)((void *)0);
#line 301
  dgst_raw = key_fingerprint_raw(k, dgst_type, & dgst_raw_len);
#line 302
  if (! dgst_raw) {
#line 303
    fatal("key_fingerprint: null from key_fingerprint_raw()");
  }
#line 304
  switch ((int )dgst_rep) {
  case 0: 
#line 306
  retval = key_fingerprint_hex(dgst_raw, dgst_raw_len);
#line 307
  break;
  case 1: 
#line 309
  retval = key_fingerprint_bubblebabble(dgst_raw, dgst_raw_len);
#line 310
  break;
  default: 
#line 312
  fatal("key_fingerprint_ex: bad digest representation %d", dgst_rep);
#line 314
  break;
  }
#line 316
  memset((void *)dgst_raw, 0, dgst_raw_len);
#line 317
  xfree((void *)dgst_raw);
#line 318
  return (retval);
}
}
#line 328 "key.c"
static int read_bignum(char **cpp , BIGNUM *value ) 
{ char *cp ;
  int old ;
  int tmp ;

  {
#line 331
  cp = *cpp;
#line 335
  while (1) {
#line 335
    if (! ((int )*cp == 32)) {
#line 335
      if (! ((int )*cp == 9)) {
#line 335
        break;
      }
    }
#line 335
    cp ++;
  }
#line 339
  if ((int )*cp < 48) {
#line 340
    return (0);
  } else {
#line 339
    if ((int )*cp > 57) {
#line 340
      return (0);
    }
  }
#line 343
  *cpp = cp;
#line 346
  while (1) {
#line 346
    if ((int )*cp >= 48) {
#line 346
      if (! ((int )*cp <= 57)) {
#line 346
        break;
      }
    } else {
#line 346
      break;
    }
#line 346
    cp ++;
  }
#line 350
  old = (int )*cp;
#line 351
  *cp = (char)0;
#line 354
  tmp = BN_dec2bn(& value, (char const   *)*cpp);
#line 354
  if (tmp == 0) {
#line 355
    return (0);
  }
#line 358
  *cp = (char )old;
#line 361
  *cpp = cp;
#line 362
  return (1);
}
}
#line 365 "key.c"
static int write_bignum(FILE *f , BIGNUM *num ) 
{ char *buf___1 ;
  char *tmp ;

  {
#line 368
  tmp = BN_bn2dec((BIGNUM const   *)num);
#line 368
  buf___1 = tmp;
#line 369
  if ((unsigned int )buf___1 == (unsigned int )((void *)0)) {
#line 370
    error("write_bignum: BN_bn2dec() failed");
#line 371
    return (0);
  }
#line 373
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )" %s", buf___1);
#line 374
  CRYPTO_free((void *)buf___1);
#line 375
  return (1);
}
}
#line 379 "key.c"
int key_read(Key *ret , char **cpp ) 
{ Key *k ;
  int success ;
  char *cp ;
  char *space ;
  int len ;
  int n___0 ;
  int type ;
  u_int bits ;
  u_char *blob ;
  int tmp ;
  int tmp___0 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
#line 383
  success = -1;
#line 389
  cp = *cpp;
#line 391
  switch (ret->type) {
  case 0: 
#line 394
  if ((int )*cp < 48) {
#line 395
    return (-1);
  } else {
#line 394
    if ((int )*cp > 57) {
#line 395
      return (-1);
    }
  }
#line 396
  bits = 0U;
#line 396
  while (1) {
#line 396
    if ((int )*cp >= 48) {
#line 396
      if (! ((int )*cp <= 57)) {
#line 396
        break;
      }
    } else {
#line 396
      break;
    }
#line 397
    bits = (10U * bits + (u_int )*cp) - 48U;
#line 396
    cp ++;
  }
#line 398
  if (bits == 0U) {
#line 399
    return (-1);
  }
#line 400
  *cpp = cp;
#line 402
  tmp = read_bignum(cpp, (ret->rsa)->e);
#line 402
  if (! tmp) {
#line 403
    return (-1);
  }
#line 404
  tmp___0 = read_bignum(cpp, (ret->rsa)->n);
#line 404
  if (! tmp___0) {
#line 405
    return (-1);
  }
#line 406
  success = 1;
#line 407
  break;
  case 3: 
  case 1: 
  case 2: 
#line 411
  tmp___2 = __builtin_strchr(cp, ' ');
#line 411
  space = tmp___2;
#line 412
  if ((unsigned int )space == (unsigned int )((void *)0)) {
#line 413
    debug3("key_read: no space");
#line 414
    return (-1);
  }
#line 416
  *space = (char )'\000';
#line 417
  type = key_type_from_name(cp);
#line 418
  *space = (char )' ';
#line 419
  if (type == 3) {
#line 420
    debug3("key_read: no key found");
#line 421
    return (-1);
  }
#line 423
  cp = space + 1;
#line 424
  if ((int )*cp == 0) {
#line 425
    debug3("key_read: short string");
#line 426
    return (-1);
  }
#line 428
  if (ret->type == 3) {
#line 429
    ret->type = type;
  } else {
#line 430
    if (ret->type != type) {
#line 432
      debug3("key_read: type mismatch");
#line 433
      return (-1);
    }
  }
#line 435
  tmp___3 = strlen((char const   *)cp);
#line 435
  len = (int )(2U * tmp___3);
#line 436
  tmp___4 = xmalloc((unsigned int )len);
#line 436
  blob = (u_char *)tmp___4;
#line 437
  n___0 = uudecode((char const   *)cp, blob, (unsigned int )len);
#line 438
  if (n___0 < 0) {
#line 439
    error("key_read: uudecode %s failed", cp);
#line 440
    xfree((void *)blob);
#line 441
    return (-1);
  }
#line 443
  k = key_from_blob(blob, n___0);
#line 444
  xfree((void *)blob);
#line 445
  if ((unsigned int )k == (unsigned int )((void *)0)) {
#line 446
    error("key_read: key_from_blob %s failed", cp);
#line 447
    return (-1);
  }
#line 449
  if (k->type != type) {
#line 450
    error("key_read: type mismatch: encoding error");
#line 451
    key_free(k);
#line 452
    return (-1);
  }
#line 455
  if (ret->type == 1) {
#line 456
    if ((unsigned int )ret->rsa != (unsigned int )((void *)0)) {
#line 457
      RSA_free(ret->rsa);
    }
#line 458
    ret->rsa = k->rsa;
#line 459
    k->rsa = (RSA *)((void *)0);
#line 460
    success = 1;
  } else {
#line 465
    if ((unsigned int )ret->dsa != (unsigned int )((void *)0)) {
#line 466
      DSA_free(ret->dsa);
    }
#line 467
    ret->dsa = k->dsa;
#line 468
    k->dsa = (DSA *)((void *)0);
#line 469
    success = 1;
  }
#line 475
  key_free(k);
#line 476
  if (success != 1) {
#line 477
    break;
  }
#line 479
  while (1) {
#line 479
    if (! ((int )*cp == 32)) {
#line 479
      if (! ((int )*cp == 9)) {
#line 479
        break;
      }
    }
#line 480
    cp ++;
  }
#line 481
  while (1) {
#line 481
    if ((int )*cp != 0) {
#line 481
      if ((int )*cp != 32) {
#line 481
        if (! ((int )*cp != 9)) {
#line 481
          break;
        }
      } else {
#line 481
        break;
      }
    } else {
#line 481
      break;
    }
#line 482
    cp ++;
  }
#line 483
  *cpp = cp;
#line 484
  break;
  default: 
#line 486
  fatal("key_read: bad key type: %d", ret->type);
#line 487
  break;
  }
#line 489
  return (success);
}
}
#line 492 "key.c"
int key_write(Key *key , FILE *f ) 
{ int n___0 ;
  int success ;
  u_int len ;
  u_int bits ;
  u_char *blob ;
  u_char *uu ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
#line 495
  success = 0;
#line 496
  bits = (u_int )0;
#line 499
  if (key->type == 0) {
#line 499
    if ((unsigned int )key->rsa != (unsigned int )((void *)0)) {
#line 501
      tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 501
      bits = (unsigned int )tmp;
#line 502
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%u", bits);
#line 503
      tmp___0 = write_bignum(f, (key->rsa)->e);
#line 503
      if (tmp___0) {
#line 503
        tmp___1 = write_bignum(f, (key->rsa)->n);
#line 503
        if (tmp___1) {
#line 505
          success = 1;
        } else {
#line 507
          error("key_write: failed for RSA key");
        }
      } else {
#line 507
        error("key_write: failed for RSA key");
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 509
    if (key->type == 2) {
#line 509
      if ((unsigned int )key->dsa != (unsigned int )((void *)0)) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 509
      if (key->type == 1) {
#line 509
        if ((unsigned int )key->rsa != (unsigned int )((void *)0)) {
          _L: /* CIL Label */ 
#line 511
          key_to_blob(key, & blob, & len);
#line 512
          tmp___2 = xmalloc(2U * len);
#line 512
          uu = (u_char *)tmp___2;
#line 513
          n___0 = uuencode(blob, len, (char *)uu, 2U * len);
#line 514
          if (n___0 > 0) {
#line 515
            tmp___3 = key_ssh_name(key);
#line 515
            fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s",
                    tmp___3, uu);
#line 516
            success = 1;
          }
#line 518
          xfree((void *)blob);
#line 519
          xfree((void *)uu);
        }
      }
    }
  }
#line 521
  return (success);
}
}
#line 524 "key.c"
char *key_type(Key *k ) 
{ 

  {
#line 527
  switch (k->type) {
  case 0: 
#line 529
  return ((char *)"RSA1");
#line 530
  break;
  case 1: 
#line 532
  return ((char *)"RSA");
#line 533
  break;
  case 2: 
#line 535
  return ((char *)"DSA");
#line 536
  break;
  }
#line 538
  return ((char *)"unknown");
}
}
#line 541 "key.c"
char *key_ssh_name(Key *k ) 
{ 

  {
#line 544
  switch (k->type) {
  case 1: 
#line 546
  return ((char *)"ssh-rsa");
#line 547
  break;
  case 2: 
#line 549
  return ((char *)"ssh-dss");
#line 550
  break;
  }
#line 552
  return ((char *)"ssh-unknown");
}
}
#line 555 "key.c"
u_int key_size(Key *k ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 558
  switch (k->type) {
  case 0: 
  case 1: 
#line 561
  tmp = BN_num_bits((BIGNUM const   *)(k->rsa)->n);
#line 561
  return ((unsigned int )tmp);
#line 562
  break;
  case 2: 
#line 564
  tmp___0 = BN_num_bits((BIGNUM const   *)(k->dsa)->p);
#line 564
  return ((unsigned int )tmp___0);
#line 565
  break;
  }
#line 567
  return (0U);
}
}
#line 570 "key.c"
static RSA *rsa_generate_private_key(u_int bits ) 
{ RSA *private ;

  {
#line 574
  private = RSA_generate_key((int )bits, 35UL, (void (*)(int  , int  , void * ))((void *)0),
                             (void *)0);
#line 575
  if ((unsigned int )private == (unsigned int )((void *)0)) {
#line 576
    fatal("rsa_generate_private_key: key generation failed.");
  }
#line 577
  return (private);
}
}
#line 580 "key.c"
static DSA *dsa_generate_private_key(u_int bits ) 
{ DSA *private ;
  DSA *tmp ;
  int tmp___0 ;

  {
#line 583
  tmp = DSA_generate_parameters((int )bits, (unsigned char *)((void *)0), 0, (int *)((void *)0),
                                (unsigned long *)((void *)0), (void (*)(int  , int  ,
                                                                        void * ))((void *)0),
                                (void *)0);
#line 583
  private = tmp;
#line 584
  if ((unsigned int )private == (unsigned int )((void *)0)) {
#line 585
    fatal("dsa_generate_private_key: DSA_generate_parameters failed");
  }
#line 586
  tmp___0 = DSA_generate_key(private);
#line 586
  if (! tmp___0) {
#line 587
    fatal("dsa_generate_private_key: DSA_generate_key failed.");
  }
#line 588
  if ((unsigned int )private == (unsigned int )((void *)0)) {
#line 589
    fatal("dsa_generate_private_key: NULL.");
  }
#line 590
  return (private);
}
}
#line 593 "key.c"
Key *key_generate(int type , u_int bits ) 
{ Key *k ;
  Key *tmp ;

  {
#line 596
  tmp = key_new(3);
#line 596
  k = tmp;
#line 597
  switch (type) {
  case 2: 
#line 599
  k->dsa = dsa_generate_private_key(bits);
#line 600
  break;
  case 1: 
  case 0: 
#line 603
  k->rsa = rsa_generate_private_key(bits);
#line 604
  break;
  default: 
#line 606
  fatal("key_generate: unknown type %d", type);
  }
#line 608
  k->type = type;
#line 609
  return (k);
}
}
#line 612 "key.c"
Key *key_from_private(Key *k ) 
{ Key *n___0 ;

  {
#line 615
  n___0 = (Key *)((void *)0);
#line 616
  switch (k->type) {
  case 2: 
#line 618
  n___0 = key_new(k->type);
#line 619
  BN_copy((n___0->dsa)->p, (BIGNUM const   *)(k->dsa)->p);
#line 620
  BN_copy((n___0->dsa)->q, (BIGNUM const   *)(k->dsa)->q);
#line 621
  BN_copy((n___0->dsa)->g, (BIGNUM const   *)(k->dsa)->g);
#line 622
  BN_copy((n___0->dsa)->pub_key, (BIGNUM const   *)(k->dsa)->pub_key);
#line 623
  break;
  case 1: 
  case 0: 
#line 626
  n___0 = key_new(k->type);
#line 627
  BN_copy((n___0->rsa)->n, (BIGNUM const   *)(k->rsa)->n);
#line 628
  BN_copy((n___0->rsa)->e, (BIGNUM const   *)(k->rsa)->e);
#line 629
  break;
  default: 
#line 631
  fatal("key_from_private: unknown type %d", k->type);
#line 632
  break;
  }
#line 634
  return (n___0);
}
}
#line 637 "key.c"
int key_type_from_name(char *name ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;

  {
#line 640
  if (0) {
#line 640
    __s1_len___3 = strlen((char const   *)name);
#line 640
    __s2_len___3 = strlen("rsa1");
#line 640
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___8;
    } else {
#line 640
      if (__s1_len___3 >= 4U) {
        _L___8: /* CIL Label */ 
#line 640
        if (! ((unsigned int )((void const   *)("rsa1" + 1)) - (unsigned int )((void const   *)"rsa1") == 1U)) {
#line 640
          tmp___48 = 1;
        } else {
#line 640
          if (__s2_len___3 >= 4U) {
#line 640
            tmp___48 = 1;
          } else {
#line 640
            tmp___48 = 0;
          }
        }
      } else {
#line 640
        tmp___48 = 0;
      }
    }
#line 640
    if (tmp___48) {
#line 640
      tmp___44 = __builtin_strcmp((char const   *)name, "rsa1");
    } else {
#line 640
      tmp___47 = __builtin_strcmp((char const   *)name, "rsa1");
#line 640
      tmp___44 = tmp___47;
    }
  } else {
#line 640
    tmp___47 = __builtin_strcmp((char const   *)name, "rsa1");
#line 640
    tmp___44 = tmp___47;
  }
#line 640
  if (tmp___44 == 0) {
#line 641
    return (0);
  } else {
#line 642
    if (0) {
#line 642
      __s1_len___2 = strlen((char const   *)name);
#line 642
      __s2_len___2 = strlen("rsa");
#line 642
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___6;
      } else {
#line 642
        if (__s1_len___2 >= 4U) {
          _L___6: /* CIL Label */ 
#line 642
          if (! ((unsigned int )((void const   *)("rsa" + 1)) - (unsigned int )((void const   *)"rsa") == 1U)) {
#line 642
            tmp___38 = 1;
          } else {
#line 642
            if (__s2_len___2 >= 4U) {
#line 642
              tmp___38 = 1;
            } else {
#line 642
              tmp___38 = 0;
            }
          }
        } else {
#line 642
          tmp___38 = 0;
        }
      }
#line 642
      if (tmp___38) {
#line 642
        tmp___34 = __builtin_strcmp((char const   *)name, "rsa");
      } else {
#line 642
        tmp___37 = __builtin_strcmp((char const   *)name, "rsa");
#line 642
        tmp___34 = tmp___37;
      }
    } else {
#line 642
      tmp___37 = __builtin_strcmp((char const   *)name, "rsa");
#line 642
      tmp___34 = tmp___37;
    }
#line 642
    if (tmp___34 == 0) {
#line 643
      return (1);
    } else {
#line 644
      if (0) {
#line 644
        __s1_len___1 = strlen((char const   *)name);
#line 644
        __s2_len___1 = strlen("dsa");
#line 644
        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
          goto _L___4;
        } else {
#line 644
          if (__s1_len___1 >= 4U) {
            _L___4: /* CIL Label */ 
#line 644
            if (! ((unsigned int )((void const   *)("dsa" + 1)) - (unsigned int )((void const   *)"dsa") == 1U)) {
#line 644
              tmp___28 = 1;
            } else {
#line 644
              if (__s2_len___1 >= 4U) {
#line 644
                tmp___28 = 1;
              } else {
#line 644
                tmp___28 = 0;
              }
            }
          } else {
#line 644
            tmp___28 = 0;
          }
        }
#line 644
        if (tmp___28) {
#line 644
          tmp___24 = __builtin_strcmp((char const   *)name, "dsa");
        } else {
#line 644
          tmp___27 = __builtin_strcmp((char const   *)name, "dsa");
#line 644
          tmp___24 = tmp___27;
        }
      } else {
#line 644
        tmp___27 = __builtin_strcmp((char const   *)name, "dsa");
#line 644
        tmp___24 = tmp___27;
      }
#line 644
      if (tmp___24 == 0) {
#line 645
        return (2);
      } else {
#line 646
        if (0) {
#line 646
          __s1_len___0 = strlen((char const   *)name);
#line 646
          __s2_len___0 = strlen("ssh-rsa");
#line 646
          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
            goto _L___2;
          } else {
#line 646
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 646
              if (! ((unsigned int )((void const   *)("ssh-rsa" + 1)) - (unsigned int )((void const   *)"ssh-rsa") == 1U)) {
#line 646
                tmp___18 = 1;
              } else {
#line 646
                if (__s2_len___0 >= 4U) {
#line 646
                  tmp___18 = 1;
                } else {
#line 646
                  tmp___18 = 0;
                }
              }
            } else {
#line 646
              tmp___18 = 0;
            }
          }
#line 646
          if (tmp___18) {
#line 646
            tmp___14 = __builtin_strcmp((char const   *)name, "ssh-rsa");
          } else {
#line 646
            tmp___17 = __builtin_strcmp((char const   *)name, "ssh-rsa");
#line 646
            tmp___14 = tmp___17;
          }
        } else {
#line 646
          tmp___17 = __builtin_strcmp((char const   *)name, "ssh-rsa");
#line 646
          tmp___14 = tmp___17;
        }
#line 646
        if (tmp___14 == 0) {
#line 647
          return (1);
        } else {
#line 648
          if (0) {
#line 648
            __s1_len = strlen((char const   *)name);
#line 648
            __s2_len = strlen("ssh-dss");
#line 648
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
              goto _L___0;
            } else {
#line 648
              if (__s1_len >= 4U) {
                _L___0: /* CIL Label */ 
#line 648
                if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
#line 648
                  tmp___8 = 1;
                } else {
#line 648
                  if (__s2_len >= 4U) {
#line 648
                    tmp___8 = 1;
                  } else {
#line 648
                    tmp___8 = 0;
                  }
                }
              } else {
#line 648
                tmp___8 = 0;
              }
            }
#line 648
            if (tmp___8) {
#line 648
              tmp___4 = __builtin_strcmp((char const   *)name, "ssh-dss");
            } else {
#line 648
              tmp___7 = __builtin_strcmp((char const   *)name, "ssh-dss");
#line 648
              tmp___4 = tmp___7;
            }
          } else {
#line 648
            tmp___7 = __builtin_strcmp((char const   *)name, "ssh-dss");
#line 648
            tmp___4 = tmp___7;
          }
#line 648
          if (tmp___4 == 0) {
#line 649
            return (2);
          }
        }
      }
    }
  }
#line 651
  debug2("key_type_from_name: unknown key type \'%s\'", name);
#line 652
  return (3);
}
}
#line 655 "key.c"
int key_names_valid2(char const   *names ) 
{ char *s ;
  char *cp ;
  char *p ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___24 ;
  char *tmp___40 ;
  int tmp___41 ;

  {
#line 660
  if ((unsigned int )names == (unsigned int )((void *)0)) {
#line 661
    return (0);
  } else {
#line 660
    if (0) {
#line 660
      __s1_len = strlen(names);
#line 660
      __s2_len = strlen("");
#line 660
      if (! ((unsigned int )((void const   *)(names + 1)) - (unsigned int )((void const   *)names) == 1U)) {
        goto _L___0;
      } else {
#line 660
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 660
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 660
            tmp___8 = 1;
          } else {
#line 660
            if (__s2_len >= 4U) {
#line 660
              tmp___8 = 1;
            } else {
#line 660
              tmp___8 = 0;
            }
          }
        } else {
#line 660
          tmp___8 = 0;
        }
      }
#line 660
      if (tmp___8) {
#line 660
        tmp___4 = __builtin_strcmp(names, "");
      } else {
#line 660
        tmp___7 = __builtin_strcmp(names, "");
#line 660
        tmp___4 = tmp___7;
      }
    } else {
#line 660
      tmp___7 = __builtin_strcmp(names, "");
#line 660
      tmp___4 = tmp___7;
    }
#line 660
    if (tmp___4 == 0) {
#line 661
      return (0);
    }
  }
#line 662
  cp = xstrdup(names);
#line 662
  s = cp;
#line 663
  tmp___24 = __strsep_g(& cp, ",");
#line 663
  p = tmp___24;
#line 663
  while (1) {
#line 663
    if (p) {
#line 663
      if (! ((int )*p != 0)) {
#line 663
        break;
      }
    } else {
#line 663
      break;
    }
#line 665
    tmp___41 = key_type_from_name(p);
#line 665
    switch (tmp___41) {
    case 0: 
    case 3: 
#line 668
    xfree((void *)s);
#line 669
    return (0);
    }
#line 664
    tmp___40 = __strsep_g(& cp, ",");
#line 664
    p = tmp___40;
  }
#line 672
  debug3("key names ok: [%s]", names);
#line 673
  xfree((void *)s);
#line 674
  return (1);
}
}
#line 677 "key.c"
Key *key_from_blob(u_char *blob , int blen ) 
{ Buffer b ;
  char *ktype ;
  int rlen ;
  int type ;
  Key *key ;
  void *tmp ;
  u_int tmp___0 ;

  {
#line 683
  key = (Key *)((void *)0);
#line 688
  buffer_init(& b);
#line 689
  buffer_append(& b, (void const   *)blob, (unsigned int )blen);
#line 690
  tmp = buffer_get_string(& b, (u_int *)((void *)0));
#line 690
  ktype = (char *)tmp;
#line 691
  type = key_type_from_name(ktype);
#line 693
  switch (type) {
  case 1: 
#line 695
  key = key_new(type);
#line 696
  buffer_get_bignum2(& b, (key->rsa)->e);
#line 697
  buffer_get_bignum2(& b, (key->rsa)->n);
#line 701
  break;
  case 2: 
#line 703
  key = key_new(type);
#line 704
  buffer_get_bignum2(& b, (key->dsa)->p);
#line 705
  buffer_get_bignum2(& b, (key->dsa)->q);
#line 706
  buffer_get_bignum2(& b, (key->dsa)->g);
#line 707
  buffer_get_bignum2(& b, (key->dsa)->pub_key);
#line 711
  break;
  case 3: 
#line 713
  key = key_new(type);
#line 714
  break;
  default: 
#line 716
  error("key_from_blob: cannot handle type %s", ktype);
#line 717
  break;
  }
#line 719
  tmp___0 = buffer_len(& b);
#line 719
  rlen = (int )tmp___0;
#line 720
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 720
    if (rlen != 0) {
#line 721
      error("key_from_blob: remaining bytes in key blob %d", rlen);
    }
  }
#line 722
  xfree((void *)ktype);
#line 723
  buffer_free(& b);
#line 724
  return (key);
}
}
#line 727 "key.c"
int key_to_blob(Key *key , u_char **blobp , u_int *lenp ) 
{ Buffer b ;
  int len ;
  u_char *buf___1 ;
  char *tmp ;
  char *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 734
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 735
    error("key_to_blob: key == NULL");
#line 736
    return (0);
  }
#line 738
  buffer_init(& b);
#line 739
  switch (key->type) {
  case 2: 
#line 741
  tmp = key_ssh_name(key);
#line 741
  buffer_put_cstring(& b, (char const   *)tmp);
#line 742
  buffer_put_bignum2(& b, (key->dsa)->p);
#line 743
  buffer_put_bignum2(& b, (key->dsa)->q);
#line 744
  buffer_put_bignum2(& b, (key->dsa)->g);
#line 745
  buffer_put_bignum2(& b, (key->dsa)->pub_key);
#line 746
  break;
  case 1: 
#line 748
  tmp___0 = key_ssh_name(key);
#line 748
  buffer_put_cstring(& b, (char const   *)tmp___0);
#line 749
  buffer_put_bignum2(& b, (key->rsa)->e);
#line 750
  buffer_put_bignum2(& b, (key->rsa)->n);
#line 751
  break;
  default: 
#line 753
  error("key_to_blob: unsupported key type %d", key->type);
#line 754
  buffer_free(& b);
#line 755
  return (0);
  }
#line 757
  tmp___1 = buffer_len(& b);
#line 757
  len = (int )tmp___1;
#line 758
  tmp___2 = xmalloc((unsigned int )len);
#line 758
  buf___1 = (u_char *)tmp___2;
#line 759
  tmp___3 = buffer_ptr(& b);
#line 759
  memcpy((void * __restrict  )buf___1, (void const   * __restrict  )tmp___3, (unsigned int )len);
#line 760
  tmp___4 = buffer_ptr(& b);
#line 760
  memset(tmp___4, 0, (unsigned int )len);
#line 761
  buffer_free(& b);
#line 762
  if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 763
    *lenp = (unsigned int )len;
  }
#line 764
  if ((unsigned int )blobp != (unsigned int )((void *)0)) {
#line 765
    *blobp = buf___1;
  }
#line 766
  return (len);
}
}
#line 769 "key.c"
int key_sign(Key *key , u_char **sigp , u_int *lenp , u_char *data , u_int datalen ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 775
  switch (key->type) {
  case 2: 
#line 777
  tmp = ssh_dss_sign(key, sigp, lenp, data, datalen);
#line 777
  return (tmp);
#line 778
  break;
  case 1: 
#line 780
  tmp___0 = ssh_rsa_sign(key, sigp, lenp, data, datalen);
#line 780
  return (tmp___0);
#line 781
  break;
  default: 
#line 783
  error("key_sign: illegal key type %d", key->type);
#line 784
  return (-1);
#line 785
  break;
  }
#line 787
  return (0);
}
}
#line 793 "key.c"
int key_verify(Key *key , u_char *signature , u_int signaturelen , u_char *data ,
               u_int datalen ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 799
  if (signaturelen == 0U) {
#line 800
    return (-1);
  }
#line 802
  switch (key->type) {
  case 2: 
#line 804
  tmp = ssh_dss_verify(key, signature, signaturelen, data, datalen);
#line 804
  return (tmp);
#line 805
  break;
  case 1: 
#line 807
  tmp___0 = ssh_rsa_verify(key, signature, signaturelen, data, datalen);
#line 807
  return (tmp___0);
#line 808
  break;
  default: 
#line 810
  error("key_verify: illegal key type %d", key->type);
#line 811
  return (-1);
#line 812
  break;
  }
#line 814
  return (0);
}
}
#line 817 "key.c"
Key *key_demote(Key *k ) 
{ Key *pk ;
  void *tmp ;

  {
#line 822
  tmp = xmalloc(sizeof(*pk));
#line 822
  pk = (Key *)tmp;
#line 823
  pk->type = k->type;
#line 824
  pk->flags = k->flags;
#line 825
  pk->dsa = (DSA *)((void *)0);
#line 826
  pk->rsa = (RSA *)((void *)0);
#line 828
  switch (k->type) {
  case 0: 
  case 1: 
#line 831
  pk->rsa = RSA_new();
#line 831
  if ((unsigned int )pk->rsa == (unsigned int )((void *)0)) {
#line 832
    fatal("key_demote: RSA_new failed");
  }
#line 833
  (pk->rsa)->e = BN_dup((BIGNUM const   *)(k->rsa)->e);
#line 833
  if ((unsigned int )(pk->rsa)->e == (unsigned int )((void *)0)) {
#line 834
    fatal("key_demote: BN_dup failed");
  }
#line 835
  (pk->rsa)->n = BN_dup((BIGNUM const   *)(k->rsa)->n);
#line 835
  if ((unsigned int )(pk->rsa)->n == (unsigned int )((void *)0)) {
#line 836
    fatal("key_demote: BN_dup failed");
  }
#line 837
  break;
  case 2: 
#line 839
  pk->dsa = DSA_new();
#line 839
  if ((unsigned int )pk->dsa == (unsigned int )((void *)0)) {
#line 840
    fatal("key_demote: DSA_new failed");
  }
#line 841
  (pk->dsa)->p = BN_dup((BIGNUM const   *)(k->dsa)->p);
#line 841
  if ((unsigned int )(pk->dsa)->p == (unsigned int )((void *)0)) {
#line 842
    fatal("key_demote: BN_dup failed");
  }
#line 843
  (pk->dsa)->q = BN_dup((BIGNUM const   *)(k->dsa)->q);
#line 843
  if ((unsigned int )(pk->dsa)->q == (unsigned int )((void *)0)) {
#line 844
    fatal("key_demote: BN_dup failed");
  }
#line 845
  (pk->dsa)->g = BN_dup((BIGNUM const   *)(k->dsa)->g);
#line 845
  if ((unsigned int )(pk->dsa)->g == (unsigned int )((void *)0)) {
#line 846
    fatal("key_demote: BN_dup failed");
  }
#line 847
  (pk->dsa)->pub_key = BN_dup((BIGNUM const   *)(k->dsa)->pub_key);
#line 847
  if ((unsigned int )(pk->dsa)->pub_key == (unsigned int )((void *)0)) {
#line 848
    fatal("key_demote: BN_dup failed");
  }
#line 849
  break;
  default: 
#line 851
  fatal("key_free: bad key type %d", k->type);
#line 852
  break;
  }
#line 855
  return (pk);
}
}
#line 1 "kex.o"
#line 41 "packet.h"
void packet_put_raw(void const   *buf___1 , u_int len ) ;
#line 45
void packet_read_expect(int expected_type ) ;
#line 51
u_int packet_get_char(void) ;
#line 55
void *packet_get_raw(int *length_ptr ) ;
#line 117 "kex.h"
Kex *kex_setup(char **proposal ) ;
#line 118
void kex_finish(Kex *kex ) ;
#line 120
void kex_send_kexinit(Kex *kex ) ;
#line 121
void kex_input_kexinit(int type , u_int32_t seq , void *ctxt ) ;
#line 122
void kex_derive_keys(Kex *kex , u_char *hash , BIGNUM *shared_secret ) ;
#line 124
void kexdh(Kex *kex ) ;
#line 125
void kexgex(Kex *kex ) ;
#line 127
Newkeys *kex_get_newkeys(int mode ) ;
#line 22 "match.h"
char *match_list(char const   *client , char const   *server , u_int *next ) ;
#line 48 "kex.c"
int use_privsep  ;
#line 49 "kex.c"
struct monitor *pmonitor  ;
#line 53
static void kex_kexinit_finish(Kex *kex ) ;
#line 54
static void kex_choose_conf(Kex *kex ) ;
#line 57 "kex.c"
static void kex_prop2buf(Buffer *b , char **proposal ) 
{ int i ;

  {
#line 62
  buffer_clear(b);
#line 67
  i = 0;
#line 67
  while (i < 16) {
#line 68
    buffer_put_char(b, 0);
#line 67
    i ++;
  }
#line 69
  i = 0;
#line 69
  while (i < 10) {
#line 70
    buffer_put_cstring(b, (char const   *)*(proposal + i));
#line 69
    i ++;
  }
#line 71
  buffer_put_char(b, 0);
#line 72
  buffer_put_int(b, 0U);
#line 73
  return;
}
}
#line 76 "kex.c"
static char **kex_buf2prop(Buffer *raw ) 
{ Buffer b ;
  int i ;
  char **proposal ;
  void *tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  u_int tmp___3 ;

  {
#line 83
  tmp = xmalloc(10U * sizeof(char *));
#line 83
  proposal = (char **)tmp;
#line 85
  buffer_init(& b);
#line 86
  tmp___0 = buffer_len(raw);
#line 86
  tmp___1 = buffer_ptr(raw);
#line 86
  buffer_append(& b, (void const   *)tmp___1, tmp___0);
#line 88
  i = 0;
#line 88
  while (i < 16) {
#line 89
    buffer_get_char(& b);
#line 88
    i ++;
  }
#line 91
  i = 0;
#line 91
  while (i < 10) {
#line 92
    tmp___2 = buffer_get_string(& b, (u_int *)((void *)0));
#line 92
    *(proposal + i) = (char *)tmp___2;
#line 93
    debug2("kex_parse_kexinit: %s", *(proposal + i));
#line 91
    i ++;
  }
#line 96
  i = buffer_get_char(& b);
#line 97
  debug2("kex_parse_kexinit: first_kex_follows %d ", i);
#line 98
  tmp___3 = buffer_get_int(& b);
#line 98
  i = (int )tmp___3;
#line 99
  debug2("kex_parse_kexinit: reserved %d ", i);
#line 100
  buffer_free(& b);
#line 101
  return (proposal);
}
}
#line 104 "kex.c"
static void kex_prop_free(char **proposal ) 
{ int i ;

  {
#line 109
  i = 0;
#line 109
  while (i < 10) {
#line 110
    xfree((void *)*(proposal + i));
#line 109
    i ++;
  }
#line 111
  xfree((void *)proposal);
#line 112
  return;
}
}
#line 114 "kex.c"
static void kex_protocol_error(int type , u_int32_t seq , void *ctxt ) 
{ 

  {
#line 117
  error("Hm, kex protocol error: type %d seq %u", type, seq);
#line 118
  return;
}
}
#line 120 "kex.c"
static void kex_reset_dispatch(void) 
{ 

  {
#line 123
  dispatch_range(1U, 49U, & kex_protocol_error);
#line 125
  dispatch_set(20, & kex_input_kexinit);
#line 126
  return;
}
}
#line 128 "kex.c"
void kex_finish(Kex *kex ) 
{ int _len ;
  int tmp ;

  {
#line 131
  kex_reset_dispatch();
#line 133
  packet_start((unsigned char)21);
#line 134
  packet_send();
#line 136
  debug("SSH2_MSG_NEWKEYS sent");
#line 138
  debug("waiting for SSH2_MSG_NEWKEYS");
#line 139
  packet_read_expect(21);
#line 140
  while (1) {
#line 140
    tmp = packet_remaining();
#line 140
    _len = tmp;
#line 140
    if (_len > 0) {
#line 140
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kex.c", 140);
#line 140
      packet_disconnect("Packet integrity error.");
    }
#line 140
    break;
  }
#line 141
  debug("SSH2_MSG_NEWKEYS received");
#line 143
  kex->done = 1;
#line 144
  buffer_clear(& kex->peer);
#line 146
  kex->flags &= -2;
#line 147
  xfree((void *)kex->name);
#line 148
  kex->name = (char *)((void *)0);
#line 149
  return;
}
}
#line 151 "kex.c"
void kex_send_kexinit(Kex *kex ) 
{ u_int32_t rand___0 ;
  u_char *cookie ;
  int i ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;

  {
#line 154
  rand___0 = (u_int32_t )0;
#line 158
  if ((unsigned int )kex == (unsigned int )((void *)0)) {
#line 159
    error("kex_send_kexinit: no kex, cannot rekey");
#line 160
    return;
  }
#line 162
  if (kex->flags & 1) {
#line 163
    debug("KEX_INIT_SENT");
#line 164
    return;
  }
#line 166
  kex->done = 0;
#line 169
  tmp = buffer_len(& kex->my);
#line 169
  if (tmp < 16U) {
#line 170
    fatal("kex_send_kexinit: kex proposal too short");
  }
#line 171
  tmp___0 = buffer_ptr(& kex->my);
#line 171
  cookie = (u_char *)tmp___0;
#line 172
  i = 0;
#line 172
  while (i < 16) {
#line 173
    if (i % 4 == 0) {
#line 174
      rand___0 = arc4random();
    }
#line 175
    *(cookie + i) = (unsigned char )rand___0;
#line 176
    rand___0 >>= 8;
#line 172
    i ++;
  }
#line 178
  packet_start((unsigned char)20);
#line 179
  tmp___1 = buffer_len(& kex->my);
#line 179
  tmp___2 = buffer_ptr(& kex->my);
#line 179
  packet_put_raw((void const   *)tmp___2, tmp___1);
#line 180
  packet_send();
#line 181
  debug("SSH2_MSG_KEXINIT sent");
#line 182
  kex->flags |= 1;
#line 183
  return;
}
}
#line 185 "kex.c"
void kex_input_kexinit(int type , u_int32_t seq , void *ctxt ) 
{ char *ptr ;
  int dlen ;
  int i ;
  Kex *kex ;
  void *tmp ;
  void *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 191
  kex = (Kex *)ctxt;
#line 193
  debug("SSH2_MSG_KEXINIT received");
#line 194
  if ((unsigned int )kex == (unsigned int )((void *)0)) {
#line 195
    fatal("kex_input_kexinit: no kex, cannot rekey");
  }
#line 197
  tmp = packet_get_raw(& dlen);
#line 197
  ptr = (char *)tmp;
#line 198
  buffer_append(& kex->peer, (void const   *)ptr, (unsigned int )dlen);
#line 201
  i = 0;
#line 201
  while (i < 16) {
#line 202
    packet_get_char();
#line 201
    i ++;
  }
#line 203
  i = 0;
#line 203
  while (i < 10) {
#line 204
    tmp___0 = packet_get_string((u_int *)((void *)0));
#line 204
    xfree(tmp___0);
#line 203
    i ++;
  }
#line 205
  packet_get_char();
#line 206
  packet_get_int();
#line 207
  while (1) {
#line 207
    tmp___1 = packet_remaining();
#line 207
    _len = tmp___1;
#line 207
    if (_len > 0) {
#line 207
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kex.c", 207);
#line 207
      packet_disconnect("Packet integrity error.");
    }
#line 207
    break;
  }
#line 209
  kex_kexinit_finish(kex);
#line 210
  return;
}
}
#line 212 "kex.c"
Kex *kex_setup(char **proposal ) 
{ Kex *kex ;
  void *tmp ;

  {
#line 217
  tmp = xmalloc(sizeof(*kex));
#line 217
  kex = (Kex *)tmp;
#line 218
  memset((void *)kex, 0, sizeof(*kex));
#line 219
  buffer_init(& kex->peer);
#line 220
  buffer_init(& kex->my);
#line 221
  kex_prop2buf(& kex->my, proposal);
#line 222
  kex->done = 0;
#line 224
  kex_send_kexinit(kex);
#line 225
  kex_reset_dispatch();
#line 227
  return (kex);
}
}
#line 230 "kex.c"
static void kex_kexinit_finish(Kex *kex ) 
{ 

  {
#line 233
  if (! (kex->flags & 1)) {
#line 234
    kex_send_kexinit(kex);
  }
#line 236
  kex_choose_conf(kex);
#line 238
  switch (kex->kex_type) {
  case 0: 
#line 240
  kexdh(kex);
#line 241
  break;
  case 1: 
#line 243
  kexgex(kex);
#line 244
  break;
  default: 
#line 246
  fatal("Unsupported key exchange %d", kex->kex_type);
  }
#line 248
  return;
}
}
#line 250 "kex.c"
static void choose_enc(Enc *enc , char *client , char *server ) 
{ char *name ;
  char *tmp ;

  {
#line 253
  tmp = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 253
  name = tmp;
#line 254
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 255
    fatal("no matching cipher found: client %s server %s", client, server);
  }
#line 256
  enc->cipher = cipher_by_name((char const   *)name);
#line 256
  if ((unsigned int )enc->cipher == (unsigned int )((void *)0)) {
#line 257
    fatal("matching cipher is not supported: %s", name);
  }
#line 258
  enc->name = name;
#line 259
  enc->enabled = 0;
#line 260
  enc->iv = (u_char *)((void *)0);
#line 261
  enc->key = (u_char *)((void *)0);
#line 262
  enc->key_len = cipher_keylen(enc->cipher);
#line 263
  enc->block_size = cipher_blocksize(enc->cipher);
#line 264
  return;
}
}
#line 265 "kex.c"
static void choose_mac(Mac *mac , char *client , char *server ) 
{ char *name ;
  char *tmp ;
  int tmp___0 ;

  {
#line 268
  tmp = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 268
  name = tmp;
#line 269
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 270
    fatal("no matching mac found: client %s server %s", client, server);
  }
#line 271
  tmp___0 = mac_init(mac, name);
#line 271
  if (tmp___0 < 0) {
#line 272
    fatal("unsupported mac %s", name);
  }
#line 274
  if (datafellows & 4) {
#line 275
    mac->key_len = 16;
  }
#line 276
  mac->name = name;
#line 277
  mac->key = (u_char *)((void *)0);
#line 278
  mac->enabled = 0;
#line 279
  return;
}
}
#line 280 "kex.c"
static void choose_comp(Comp *comp , char *client , char *server ) 
{ char *name ;
  char *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 283
  tmp = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 283
  name = tmp;
#line 284
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 285
    fatal("no matching comp found: client %s server %s", client, server);
  }
#line 286
  if (0) {
#line 286
    __s1_len___0 = strlen((char const   *)name);
#line 286
    __s2_len___0 = strlen("zlib");
#line 286
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___2;
    } else {
#line 286
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 286
        if (! ((unsigned int )((void const   *)("zlib" + 1)) - (unsigned int )((void const   *)"zlib") == 1U)) {
#line 286
          tmp___19 = 1;
        } else {
#line 286
          if (__s2_len___0 >= 4U) {
#line 286
            tmp___19 = 1;
          } else {
#line 286
            tmp___19 = 0;
          }
        }
      } else {
#line 286
        tmp___19 = 0;
      }
    }
#line 286
    if (tmp___19) {
#line 286
      tmp___15 = __builtin_strcmp((char const   *)name, "zlib");
    } else {
#line 286
      tmp___18 = __builtin_strcmp((char const   *)name, "zlib");
#line 286
      tmp___15 = tmp___18;
    }
  } else {
#line 286
    tmp___18 = __builtin_strcmp((char const   *)name, "zlib");
#line 286
    tmp___15 = tmp___18;
  }
#line 286
  if (tmp___15 == 0) {
#line 287
    comp->type = 1;
  } else {
#line 288
    if (0) {
#line 288
      __s1_len = strlen((char const   *)name);
#line 288
      __s2_len = strlen("none");
#line 288
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___0;
      } else {
#line 288
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 288
          if (! ((unsigned int )((void const   *)("none" + 1)) - (unsigned int )((void const   *)"none") == 1U)) {
#line 288
            tmp___9 = 1;
          } else {
#line 288
            if (__s2_len >= 4U) {
#line 288
              tmp___9 = 1;
            } else {
#line 288
              tmp___9 = 0;
            }
          }
        } else {
#line 288
          tmp___9 = 0;
        }
      }
#line 288
      if (tmp___9) {
#line 288
        tmp___5 = __builtin_strcmp((char const   *)name, "none");
      } else {
#line 288
        tmp___8 = __builtin_strcmp((char const   *)name, "none");
#line 288
        tmp___5 = tmp___8;
      }
    } else {
#line 288
      tmp___8 = __builtin_strcmp((char const   *)name, "none");
#line 288
      tmp___5 = tmp___8;
    }
#line 288
    if (tmp___5 == 0) {
#line 289
      comp->type = 0;
    } else {
#line 291
      fatal("unsupported comp %s", name);
    }
  }
#line 293
  comp->name = name;
#line 294
  return;
}
}
#line 295 "kex.c"
static void choose_kex(Kex *k , char *client , char *server ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 298
  k->name = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 299
  if ((unsigned int )k->name == (unsigned int )((void *)0)) {
#line 300
    fatal("no kex alg");
  }
#line 301
  if (0) {
#line 301
    __s1_len___0 = strlen((char const   *)k->name);
#line 301
    __s2_len___0 = strlen("diffie-hellman-group1-sha1");
#line 301
    if (! ((unsigned int )((void const   *)(k->name + 1)) - (unsigned int )((void const   *)k->name) == 1U)) {
      goto _L___2;
    } else {
#line 301
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 301
        if (! ((unsigned int )((void const   *)("diffie-hellman-group1-sha1" + 1)) - (unsigned int )((void const   *)"diffie-hellman-group1-sha1") == 1U)) {
#line 301
          tmp___18 = 1;
        } else {
#line 301
          if (__s2_len___0 >= 4U) {
#line 301
            tmp___18 = 1;
          } else {
#line 301
            tmp___18 = 0;
          }
        }
      } else {
#line 301
        tmp___18 = 0;
      }
    }
#line 301
    if (tmp___18) {
#line 301
      tmp___14 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
    } else {
#line 301
      tmp___17 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
#line 301
      tmp___14 = tmp___17;
    }
  } else {
#line 301
    tmp___17 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
#line 301
    tmp___14 = tmp___17;
  }
#line 301
  if (tmp___14 == 0) {
#line 302
    k->kex_type = 0;
  } else {
#line 303
    if (0) {
#line 303
      __s1_len = strlen((char const   *)k->name);
#line 303
      __s2_len = strlen("diffie-hellman-group-exchange-sha1");
#line 303
      if (! ((unsigned int )((void const   *)(k->name + 1)) - (unsigned int )((void const   *)k->name) == 1U)) {
        goto _L___0;
      } else {
#line 303
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 303
          if (! ((unsigned int )((void const   *)("diffie-hellman-group-exchange-sha1" + 1)) - (unsigned int )((void const   *)"diffie-hellman-group-exchange-sha1") == 1U)) {
#line 303
            tmp___8 = 1;
          } else {
#line 303
            if (__s2_len >= 4U) {
#line 303
              tmp___8 = 1;
            } else {
#line 303
              tmp___8 = 0;
            }
          }
        } else {
#line 303
          tmp___8 = 0;
        }
      }
#line 303
      if (tmp___8) {
#line 303
        tmp___4 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha1");
      } else {
#line 303
        tmp___7 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha1");
#line 303
        tmp___4 = tmp___7;
      }
    } else {
#line 303
      tmp___7 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha1");
#line 303
      tmp___4 = tmp___7;
    }
#line 303
    if (tmp___4 == 0) {
#line 304
      k->kex_type = 1;
    } else {
#line 306
      fatal("bad kex alg %s", k->name);
    }
  }
#line 307
  return;
}
}
#line 308 "kex.c"
static void choose_hostkeyalg(Kex *k , char *client , char *server ) 
{ char *hostkeyalg ;
  char *tmp ;

  {
#line 311
  tmp = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 311
  hostkeyalg = tmp;
#line 312
  if ((unsigned int )hostkeyalg == (unsigned int )((void *)0)) {
#line 313
    fatal("no hostkey alg");
  }
#line 314
  k->hostkey_type = key_type_from_name(hostkeyalg);
#line 315
  if (k->hostkey_type == 3) {
#line 316
    fatal("bad hostkey alg \'%s\'", hostkeyalg);
  }
#line 317
  xfree((void *)hostkeyalg);
#line 318
  return;
}
}
#line 320 "kex.c"
static void kex_choose_conf(Kex *kex ) 
{ Newkeys *newkeys___0 ;
  char **my ;
  char **peer ;
  char **cprop ;
  char **sprop ;
  int nenc ;
  int nmac ;
  int ncomp ;
  int mode ;
  int ctos ;
  int need ;
  void *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 331
  my = kex_buf2prop(& kex->my);
#line 332
  peer = kex_buf2prop(& kex->peer);
#line 334
  if (kex->server) {
#line 335
    cprop = peer;
#line 336
    sprop = my;
  } else {
#line 338
    cprop = my;
#line 339
    sprop = peer;
  }
#line 343
  mode = 0;
#line 343
  while (mode < 2) {
#line 344
    tmp = xmalloc(sizeof(*newkeys___0));
#line 344
    newkeys___0 = (Newkeys *)tmp;
#line 345
    memset((void *)newkeys___0, 0, sizeof(*newkeys___0));
#line 346
    kex->newkeys[mode] = newkeys___0;
#line 347
    if (! kex->server) {
#line 347
      if (mode == 1) {
#line 347
        tmp___0 = 1;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 347
      if (kex->server) {
#line 347
        if (mode == 0) {
#line 347
          tmp___0 = 1;
        } else {
#line 347
          tmp___0 = 0;
        }
      } else {
#line 347
        tmp___0 = 0;
      }
    }
#line 347
    ctos = tmp___0;
#line 348
    if (ctos) {
#line 348
      nenc = 2;
    } else {
#line 348
      nenc = 3;
    }
#line 349
    if (ctos) {
#line 349
      nmac = 4;
    } else {
#line 349
      nmac = 5;
    }
#line 350
    if (ctos) {
#line 350
      ncomp = 6;
    } else {
#line 350
      ncomp = 7;
    }
#line 351
    choose_enc(& newkeys___0->enc, *(cprop + nenc), *(sprop + nenc));
#line 352
    choose_mac(& newkeys___0->mac, *(cprop + nmac), *(sprop + nmac));
#line 353
    choose_comp(& newkeys___0->comp, *(cprop + ncomp), *(sprop + ncomp));
#line 354
    if (ctos) {
#line 354
      tmp___1 = "client->server";
    } else {
#line 354
      tmp___1 = "server->client";
    }
#line 354
    debug("kex: %s %s %s %s", tmp___1, newkeys___0->enc.name, newkeys___0->mac.name,
          newkeys___0->comp.name);
#line 343
    mode ++;
  }
#line 360
  choose_kex(kex, *(cprop + 0), *(sprop + 0));
#line 361
  choose_hostkeyalg(kex, *(cprop + 1), *(sprop + 1));
#line 363
  need = 0;
#line 364
  mode = 0;
#line 364
  while (mode < 2) {
#line 365
    newkeys___0 = kex->newkeys[mode];
#line 366
    if ((u_int )need < newkeys___0->enc.key_len) {
#line 367
      need = (int )newkeys___0->enc.key_len;
    }
#line 368
    if ((u_int )need < newkeys___0->enc.block_size) {
#line 369
      need = (int )newkeys___0->enc.block_size;
    }
#line 370
    if (need < newkeys___0->mac.key_len) {
#line 371
      need = newkeys___0->mac.key_len;
    }
#line 364
    mode ++;
  }
#line 374
  kex->we_need = need;
#line 376
  kex_prop_free(my);
#line 377
  kex_prop_free(peer);
#line 378
  return;
}
}
#line 380 "kex.c"
static u_char *derive_key(Kex *kex , int id , int need , u_char *hash , BIGNUM *shared_secret ) 
{ Buffer b ;
  EVP_MD const   *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  char c ;
  int have ;
  int mdsz ;
  u_char *digest___1 ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  u_int tmp___3 ;
  void *tmp___4 ;

  {
#line 384
  tmp = EVP_sha1();
#line 384
  evp_md = tmp;
#line 386
  c = (char )id;
#line 388
  mdsz = (int )evp_md->md_size;
#line 389
  tmp___0 = xmalloc((unsigned int )(((need + (mdsz - 1)) / mdsz) * mdsz));
#line 389
  digest___1 = (u_char *)tmp___0;
#line 391
  buffer_init(& b);
#line 392
  buffer_put_bignum2(& b, shared_secret);
#line 395
  EVP_DigestInit(& md, evp_md);
#line 396
  if (! (datafellows & 262144)) {
#line 397
    tmp___1 = buffer_len(& b);
#line 397
    tmp___2 = buffer_ptr(& b);
#line 397
    EVP_DigestUpdate(& md, (void const   *)tmp___2, tmp___1);
  }
#line 398
  EVP_DigestUpdate(& md, (void const   *)hash, (unsigned int )mdsz);
#line 399
  EVP_DigestUpdate(& md, (void const   *)(& c), 1U);
#line 400
  EVP_DigestUpdate(& md, (void const   *)kex->session_id, (unsigned int )kex->session_id_len);
#line 401
  EVP_DigestFinal(& md, digest___1, (unsigned int *)((void *)0));
#line 408
  have = mdsz;
#line 408
  while (need > have) {
#line 409
    EVP_DigestInit(& md, evp_md);
#line 410
    if (! (datafellows & 262144)) {
#line 411
      tmp___3 = buffer_len(& b);
#line 411
      tmp___4 = buffer_ptr(& b);
#line 411
      EVP_DigestUpdate(& md, (void const   *)tmp___4, tmp___3);
    }
#line 412
    EVP_DigestUpdate(& md, (void const   *)hash, (unsigned int )mdsz);
#line 413
    EVP_DigestUpdate(& md, (void const   *)digest___1, (unsigned int )have);
#line 414
    EVP_DigestFinal(& md, digest___1 + have, (unsigned int *)((void *)0));
#line 408
    have += mdsz;
  }
#line 416
  buffer_free(& b);
#line 421
  return (digest___1);
}
}
#line 424 "kex.c"
Newkeys *current_keys[2]  ;
#line 427 "kex.c"
void kex_derive_keys(Kex *kex , u_char *hash , BIGNUM *shared_secret ) 
{ u_char *keys[6] ;
  int i ;
  int mode ;
  int ctos ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 433
  i = 0;
#line 433
  while (i < 6) {
#line 434
    keys[i] = derive_key(kex, 65 + i, kex->we_need, hash, shared_secret);
#line 433
    i ++;
  }
#line 436
  debug("kex_derive_keys");
#line 437
  mode = 0;
#line 437
  while (mode < 2) {
#line 438
    current_keys[mode] = kex->newkeys[mode];
#line 439
    kex->newkeys[mode] = (Newkeys *)((void *)0);
#line 440
    if (! kex->server) {
#line 440
      if (mode == 1) {
#line 440
        tmp = 1;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 440
      if (kex->server) {
#line 440
        if (mode == 0) {
#line 440
          tmp = 1;
        } else {
#line 440
          tmp = 0;
        }
      } else {
#line 440
        tmp = 0;
      }
    }
#line 440
    ctos = tmp;
#line 441
    if (ctos) {
#line 441
      tmp___0 = 0;
    } else {
#line 441
      tmp___0 = 1;
    }
#line 441
    (current_keys[mode])->enc.iv = keys[tmp___0];
#line 442
    if (ctos) {
#line 442
      tmp___1 = 2;
    } else {
#line 442
      tmp___1 = 3;
    }
#line 442
    (current_keys[mode])->enc.key = keys[tmp___1];
#line 443
    if (ctos) {
#line 443
      tmp___2 = 4;
    } else {
#line 443
      tmp___2 = 5;
    }
#line 443
    (current_keys[mode])->mac.key = keys[tmp___2];
#line 437
    mode ++;
  }
#line 445
  return;
}
}
#line 447 "kex.c"
Newkeys *kex_get_newkeys(int mode ) 
{ Newkeys *ret ;

  {
#line 452
  ret = current_keys[mode];
#line 453
  current_keys[mode] = (Newkeys *)((void *)0);
#line 454
  return (ret);
}
}
#line 1 "kexdh.o"
#line 174 "/usr/include/openssl/dh.h"
extern void DH_free(DH *dh ) ;
#line 176
extern int DH_size(DH const   *dh ) ;
#line 194
extern int DH_compute_key(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
#line 38 "packet.h"
void packet_put_bignum2(BIGNUM *value ) ;
#line 54
void packet_get_bignum2(BIGNUM *value ) ;
#line 44 "monitor_wrap.h"
int mm_key_sign(Key *key , u_char **sigp , u_int *lenp , u_char *data , u_int datalen ) ;
#line 54 "kexdh.c"
static u_char digest[64]  ;
#line 42 "kexdh.c"
static u_char *kex_dh_hash(char *client_version_string___0 , char *server_version_string___0 ,
                           char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                           u_char *serverhostkeyblob , int sbloblen , BIGNUM *client_dh_pub ,
                           BIGNUM *server_dh_pub , BIGNUM *shared_secret ) 
{ Buffer b ;
  EVP_MD const   *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  u_int tmp___0 ;
  void *tmp___1 ;

  {
#line 55
  tmp = EVP_sha1();
#line 55
  evp_md = tmp;
#line 58
  buffer_init(& b);
#line 59
  buffer_put_cstring(& b, (char const   *)client_version_string___0);
#line 60
  buffer_put_cstring(& b, (char const   *)server_version_string___0);
#line 63
  buffer_put_int(& b, (unsigned int )(ckexinitlen + 1));
#line 64
  buffer_put_char(& b, 20);
#line 65
  buffer_append(& b, (void const   *)ckexinit, (unsigned int )ckexinitlen);
#line 66
  buffer_put_int(& b, (unsigned int )(skexinitlen + 1));
#line 67
  buffer_put_char(& b, 20);
#line 68
  buffer_append(& b, (void const   *)skexinit, (unsigned int )skexinitlen);
#line 70
  buffer_put_string(& b, (void const   *)serverhostkeyblob, (unsigned int )sbloblen);
#line 71
  buffer_put_bignum2(& b, client_dh_pub);
#line 72
  buffer_put_bignum2(& b, server_dh_pub);
#line 73
  buffer_put_bignum2(& b, shared_secret);
#line 78
  EVP_DigestInit(& md, evp_md);
#line 79
  tmp___0 = buffer_len(& b);
#line 79
  tmp___1 = buffer_ptr(& b);
#line 79
  EVP_DigestUpdate(& md, (void const   *)tmp___1, tmp___0);
#line 80
  EVP_DigestFinal(& md, digest, (unsigned int *)((void *)0));
#line 82
  buffer_free(& b);
#line 87
  return (digest);
}
}
#line 92 "kexdh.c"
static void kexdh_client(Kex *kex ) 
{ BIGNUM *dh_server_pub ;
  BIGNUM *shared_secret ;
  DH *dh ;
  Key *server_host_key ;
  u_char *server_host_key_blob ;
  u_char *signature ;
  u_char *kbuf ;
  u_char *hash ;
  u_int klen ;
  u_int kout ;
  u_int slen ;
  u_int sbloblen ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int _len ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  u_int tmp___7 ;
  void *tmp___8 ;
  u_int tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;

  {
#line 95
  dh_server_pub = (BIGNUM *)((void *)0);
#line 95
  shared_secret = (BIGNUM *)((void *)0);
#line 98
  server_host_key_blob = (u_char *)((void *)0);
#line 98
  signature = (u_char *)((void *)0);
#line 103
  dh = dh_new_group1();
#line 104
  dh_gen_key(dh, kex->we_need * 8);
#line 105
  packet_start((unsigned char)30);
#line 106
  packet_put_bignum2(dh->pub_key);
#line 107
  packet_send();
#line 109
  debug("sending SSH2_MSG_KEXDH_INIT");
#line 117
  debug("expecting SSH2_MSG_KEXDH_REPLY");
#line 118
  packet_read_expect(31);
#line 121
  tmp = packet_get_string(& sbloblen);
#line 121
  server_host_key_blob = (u_char *)tmp;
#line 122
  server_host_key = key_from_blob(server_host_key_blob, (int )sbloblen);
#line 123
  if ((unsigned int )server_host_key == (unsigned int )((void *)0)) {
#line 124
    fatal("cannot decode server_host_key_blob");
  }
#line 125
  if (server_host_key->type != kex->hostkey_type) {
#line 126
    fatal("type mismatch for decoded server_host_key_blob");
  }
#line 127
  if ((unsigned int )kex->verify_host_key == (unsigned int )((void *)0)) {
#line 128
    fatal("cannot verify server_host_key");
  }
#line 129
  tmp___0 = (*(kex->verify_host_key))(server_host_key);
#line 129
  if (tmp___0 == -1) {
#line 130
    fatal("server_host_key verification failed");
  }
#line 133
  dh_server_pub = BN_new();
#line 133
  if ((unsigned int )dh_server_pub == (unsigned int )((void *)0)) {
#line 134
    fatal("dh_server_pub == NULL");
  }
#line 135
  packet_get_bignum2(dh_server_pub);
#line 145
  tmp___1 = packet_get_string(& slen);
#line 145
  signature = (u_char *)tmp___1;
#line 146
  while (1) {
#line 146
    tmp___2 = packet_remaining();
#line 146
    _len = tmp___2;
#line 146
    if (_len > 0) {
#line 146
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kexdh.c",
          146);
#line 146
      packet_disconnect("Packet integrity error.");
    }
#line 146
    break;
  }
#line 148
  tmp___3 = dh_pub_is_valid(dh, dh_server_pub);
#line 148
  if (! tmp___3) {
#line 149
    packet_disconnect("bad server public DH value");
  }
#line 151
  tmp___4 = DH_size((DH const   *)dh);
#line 151
  klen = (unsigned int )tmp___4;
#line 152
  tmp___5 = xmalloc(klen);
#line 152
  kbuf = (u_char *)tmp___5;
#line 153
  tmp___6 = DH_compute_key(kbuf, (BIGNUM const   *)dh_server_pub, dh);
#line 153
  kout = (unsigned int )tmp___6;
#line 157
  shared_secret = BN_new();
#line 157
  if ((unsigned int )shared_secret == (unsigned int )((void *)0)) {
#line 158
    fatal("kexdh_client: BN_new failed");
  }
#line 159
  BN_bin2bn((unsigned char const   *)kbuf, (int )kout, shared_secret);
#line 160
  memset((void *)kbuf, 0, klen);
#line 161
  xfree((void *)kbuf);
#line 164
  tmp___7 = buffer_len(& kex->peer);
#line 164
  tmp___8 = buffer_ptr(& kex->peer);
#line 164
  tmp___9 = buffer_len(& kex->my);
#line 164
  tmp___10 = buffer_ptr(& kex->my);
#line 164
  hash = kex_dh_hash(kex->client_version_string, kex->server_version_string, (char *)tmp___10,
                     (int )tmp___9, (char *)tmp___8, (int )tmp___7, server_host_key_blob,
                     (int )sbloblen, dh->pub_key, dh_server_pub, shared_secret);
#line 174
  xfree((void *)server_host_key_blob);
#line 175
  BN_clear_free(dh_server_pub);
#line 176
  DH_free(dh);
#line 178
  tmp___11 = key_verify(server_host_key, signature, slen, hash, 20U);
#line 178
  if (tmp___11 != 1) {
#line 179
    fatal("key_verify failed for server_host_key");
  }
#line 180
  key_free(server_host_key);
#line 181
  xfree((void *)signature);
#line 184
  if ((unsigned int )kex->session_id == (unsigned int )((void *)0)) {
#line 185
    kex->session_id_len = 20;
#line 186
    tmp___12 = xmalloc((unsigned int )kex->session_id_len);
#line 186
    kex->session_id = (u_char *)tmp___12;
#line 187
    memcpy((void * __restrict  )kex->session_id, (void const   * __restrict  )hash,
           (unsigned int )kex->session_id_len);
  }
#line 190
  kex_derive_keys(kex, hash, shared_secret);
#line 191
  BN_clear_free(shared_secret);
#line 192
  kex_finish(kex);
#line 193
  return;
}
}
#line 197 "kexdh.c"
static void kexdh_server(Kex *kex ) 
{ BIGNUM *shared_secret ;
  BIGNUM *dh_client_pub ;
  DH *dh ;
  Key *server_host_key ;
  u_char *kbuf ;
  u_char *hash ;
  u_char *signature ;
  u_char *server_host_key_blob ;
  u_int sbloblen ;
  u_int klen ;
  u_int kout ;
  u_int slen ;
  int _len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  u_int tmp___4 ;
  void *tmp___5 ;
  u_int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;

  {
#line 200
  shared_secret = (BIGNUM *)((void *)0);
#line 200
  dh_client_pub = (BIGNUM *)((void *)0);
#line 203
  signature = (u_char *)((void *)0);
#line 203
  server_host_key_blob = (u_char *)((void *)0);
#line 208
  dh = dh_new_group1();
#line 209
  dh_gen_key(dh, kex->we_need * 8);
#line 211
  debug("expecting SSH2_MSG_KEXDH_INIT");
#line 212
  packet_read_expect(30);
#line 214
  if ((unsigned int )kex->load_host_key == (unsigned int )((void *)0)) {
#line 215
    fatal("Cannot load hostkey");
  }
#line 216
  server_host_key = (*(kex->load_host_key))(kex->hostkey_type);
#line 217
  if ((unsigned int )server_host_key == (unsigned int )((void *)0)) {
#line 218
    fatal("Unsupported hostkey type %d", kex->hostkey_type);
  }
#line 221
  dh_client_pub = BN_new();
#line 221
  if ((unsigned int )dh_client_pub == (unsigned int )((void *)0)) {
#line 222
    fatal("dh_client_pub == NULL");
  }
#line 223
  packet_get_bignum2(dh_client_pub);
#line 224
  while (1) {
#line 224
    tmp = packet_remaining();
#line 224
    _len = tmp;
#line 224
    if (_len > 0) {
#line 224
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kexdh.c",
          224);
#line 224
      packet_disconnect("Packet integrity error.");
    }
#line 224
    break;
  }
#line 239
  tmp___0 = dh_pub_is_valid(dh, dh_client_pub);
#line 239
  if (! tmp___0) {
#line 240
    packet_disconnect("bad client public DH value");
  }
#line 242
  tmp___1 = DH_size((DH const   *)dh);
#line 242
  klen = (unsigned int )tmp___1;
#line 243
  tmp___2 = xmalloc(klen);
#line 243
  kbuf = (u_char *)tmp___2;
#line 244
  tmp___3 = DH_compute_key(kbuf, (BIGNUM const   *)dh_client_pub, dh);
#line 244
  kout = (unsigned int )tmp___3;
#line 248
  shared_secret = BN_new();
#line 248
  if ((unsigned int )shared_secret == (unsigned int )((void *)0)) {
#line 249
    fatal("kexdh_server: BN_new failed");
  }
#line 250
  BN_bin2bn((unsigned char const   *)kbuf, (int )kout, shared_secret);
#line 251
  memset((void *)kbuf, 0, klen);
#line 252
  xfree((void *)kbuf);
#line 254
  key_to_blob(server_host_key, & server_host_key_blob, & sbloblen);
#line 257
  tmp___4 = buffer_len(& kex->my);
#line 257
  tmp___5 = buffer_ptr(& kex->my);
#line 257
  tmp___6 = buffer_len(& kex->peer);
#line 257
  tmp___7 = buffer_ptr(& kex->peer);
#line 257
  hash = kex_dh_hash(kex->client_version_string, kex->server_version_string, (char *)tmp___7,
                     (int )tmp___6, (char *)tmp___5, (int )tmp___4, server_host_key_blob,
                     (int )sbloblen, dh_client_pub, dh->pub_key, shared_secret);
#line 267
  BN_clear_free(dh_client_pub);
#line 271
  if ((unsigned int )kex->session_id == (unsigned int )((void *)0)) {
#line 272
    kex->session_id_len = 20;
#line 273
    tmp___8 = xmalloc((unsigned int )kex->session_id_len);
#line 273
    kex->session_id = (u_char *)tmp___8;
#line 274
    memcpy((void * __restrict  )kex->session_id, (void const   * __restrict  )hash,
           (unsigned int )kex->session_id_len);
  }
#line 279
  if (use_privsep) {
#line 279
    mm_key_sign(server_host_key, & signature, & slen, hash, 20U);
  } else {
#line 279
    key_sign(server_host_key, & signature, & slen, hash, 20U);
  }
#line 284
  packet_start((unsigned char)31);
#line 285
  packet_put_string((void const   *)server_host_key_blob, sbloblen);
#line 286
  packet_put_bignum2(dh->pub_key);
#line 287
  packet_put_string((void const   *)signature, slen);
#line 288
  packet_send();
#line 290
  xfree((void *)signature);
#line 291
  xfree((void *)server_host_key_blob);
#line 293
  DH_free(dh);
#line 295
  kex_derive_keys(kex, hash, shared_secret);
#line 296
  BN_clear_free(shared_secret);
#line 297
  kex_finish(kex);
#line 298
  return;
}
}
#line 300 "kexdh.c"
void kexdh(Kex *kex ) 
{ 

  {
#line 303
  if (kex->server) {
#line 304
    kexdh_server(kex);
  } else {
#line 306
    kexdh_client(kex);
  }
#line 307
  return;
}
}
#line 1 "kexgex.o"
#line 43 "monitor_wrap.h"
DH *mm_choose_dh(int min , int nbits , int max ) ;
#line 56 "kexgex.c"
static u_char digest___0[64]  ;
#line 43 "kexgex.c"
static u_char *kexgex_hash(char *client_version_string___0 , char *server_version_string___0 ,
                           char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                           u_char *serverhostkeyblob , int sbloblen , int min , int wantbits ,
                           int max , BIGNUM *prime , BIGNUM *gen___0 , BIGNUM *client_dh_pub ,
                           BIGNUM *server_dh_pub , BIGNUM *shared_secret ) 
{ Buffer b ;
  EVP_MD const   *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  u_int tmp___0 ;
  void *tmp___1 ;

  {
#line 57
  tmp = EVP_sha1();
#line 57
  evp_md = tmp;
#line 60
  buffer_init(& b);
#line 61
  buffer_put_cstring(& b, (char const   *)client_version_string___0);
#line 62
  buffer_put_cstring(& b, (char const   *)server_version_string___0);
#line 65
  buffer_put_int(& b, (unsigned int )(ckexinitlen + 1));
#line 66
  buffer_put_char(& b, 20);
#line 67
  buffer_append(& b, (void const   *)ckexinit, (unsigned int )ckexinitlen);
#line 68
  buffer_put_int(& b, (unsigned int )(skexinitlen + 1));
#line 69
  buffer_put_char(& b, 20);
#line 70
  buffer_append(& b, (void const   *)skexinit, (unsigned int )skexinitlen);
#line 72
  buffer_put_string(& b, (void const   *)serverhostkeyblob, (unsigned int )sbloblen);
#line 73
  if (min == -1) {
#line 74
    buffer_put_int(& b, (unsigned int )wantbits);
  } else {
#line 73
    if (max == -1) {
#line 74
      buffer_put_int(& b, (unsigned int )wantbits);
    } else {
#line 76
      buffer_put_int(& b, (unsigned int )min);
#line 77
      buffer_put_int(& b, (unsigned int )wantbits);
#line 78
      buffer_put_int(& b, (unsigned int )max);
    }
  }
#line 80
  buffer_put_bignum2(& b, prime);
#line 81
  buffer_put_bignum2(& b, gen___0);
#line 82
  buffer_put_bignum2(& b, client_dh_pub);
#line 83
  buffer_put_bignum2(& b, server_dh_pub);
#line 84
  buffer_put_bignum2(& b, shared_secret);
#line 89
  EVP_DigestInit(& md, evp_md);
#line 90
  tmp___0 = buffer_len(& b);
#line 90
  tmp___1 = buffer_ptr(& b);
#line 90
  EVP_DigestUpdate(& md, (void const   *)tmp___1, tmp___0);
#line 91
  EVP_DigestFinal(& md, digest___0, (unsigned int *)((void *)0));
#line 93
  buffer_free(& b);
#line 98
  return (digest___0);
}
}
#line 103 "kexgex.c"
static void kexgex_client(Kex *kex ) 
{ BIGNUM *dh_server_pub ;
  BIGNUM *shared_secret ;
  BIGNUM *p ;
  BIGNUM *g ;
  Key *server_host_key ;
  u_char *kbuf ;
  u_char *hash ;
  u_char *signature ;
  u_char *server_host_key_blob ;
  u_int klen ;
  u_int kout ;
  u_int slen ;
  u_int sbloblen ;
  int min ;
  int max ;
  int nbits ;
  DH *dh ;
  int _len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int _len___0 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  u_int tmp___11 ;
  void *tmp___12 ;
  u_int tmp___13 ;
  void *tmp___14 ;
  int tmp___15 ;
  void *tmp___16 ;

  {
#line 106
  dh_server_pub = (BIGNUM *)((void *)0);
#line 106
  shared_secret = (BIGNUM *)((void *)0);
#line 107
  p = (BIGNUM *)((void *)0);
#line 107
  g = (BIGNUM *)((void *)0);
#line 109
  signature = (u_char *)((void *)0);
#line 109
  server_host_key_blob = (u_char *)((void *)0);
#line 114
  nbits = dh_estimate(kex->we_need * 8);
#line 116
  if (datafellows & 16384) {
#line 117
    debug("SSH2_MSG_KEX_DH_GEX_REQUEST_OLD sent");
#line 120
    packet_start((unsigned char)30);
#line 121
    packet_put_int((unsigned int )nbits);
#line 122
    min = 1024;
#line 123
    max = 8192;
  } else {
#line 125
    debug("SSH2_MSG_KEX_DH_GEX_REQUEST sent");
#line 128
    min = 1024;
#line 129
    max = 8192;
#line 130
    packet_start((unsigned char)34);
#line 131
    packet_put_int((unsigned int )min);
#line 132
    packet_put_int((unsigned int )nbits);
#line 133
    packet_put_int((unsigned int )max);
  }
#line 139
  packet_send();
#line 141
  debug("expecting SSH2_MSG_KEX_DH_GEX_GROUP");
#line 142
  packet_read_expect(31);
#line 144
  p = BN_new();
#line 144
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 145
    fatal("BN_new");
  }
#line 146
  packet_get_bignum2(p);
#line 147
  g = BN_new();
#line 147
  if ((unsigned int )g == (unsigned int )((void *)0)) {
#line 148
    fatal("BN_new");
  }
#line 149
  packet_get_bignum2(g);
#line 150
  while (1) {
#line 150
    tmp = packet_remaining();
#line 150
    _len = tmp;
#line 150
    if (_len > 0) {
#line 150
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kexgex.c",
          150);
#line 150
      packet_disconnect("Packet integrity error.");
    }
#line 150
    break;
  }
#line 152
  tmp___1 = BN_num_bits((BIGNUM const   *)p);
#line 152
  if (tmp___1 < min) {
#line 153
    tmp___0 = BN_num_bits((BIGNUM const   *)p);
#line 153
    fatal("DH_GEX group out of range: %d !< %d !< %d", min, tmp___0, max);
  } else {
#line 152
    tmp___2 = BN_num_bits((BIGNUM const   *)p);
#line 152
    if (tmp___2 > max) {
#line 153
      tmp___0 = BN_num_bits((BIGNUM const   *)p);
#line 153
      fatal("DH_GEX group out of range: %d !< %d !< %d", min, tmp___0, max);
    }
  }
#line 156
  dh = dh_new_group(g, p);
#line 157
  dh_gen_key(dh, kex->we_need * 8);
#line 166
  debug("SSH2_MSG_KEX_DH_GEX_INIT sent");
#line 168
  packet_start((unsigned char)32);
#line 169
  packet_put_bignum2(dh->pub_key);
#line 170
  packet_send();
#line 172
  debug("expecting SSH2_MSG_KEX_DH_GEX_REPLY");
#line 173
  packet_read_expect(33);
#line 176
  tmp___3 = packet_get_string(& sbloblen);
#line 176
  server_host_key_blob = (u_char *)tmp___3;
#line 177
  server_host_key = key_from_blob(server_host_key_blob, (int )sbloblen);
#line 178
  if ((unsigned int )server_host_key == (unsigned int )((void *)0)) {
#line 179
    fatal("cannot decode server_host_key_blob");
  }
#line 180
  if (server_host_key->type != kex->hostkey_type) {
#line 181
    fatal("type mismatch for decoded server_host_key_blob");
  }
#line 182
  if ((unsigned int )kex->verify_host_key == (unsigned int )((void *)0)) {
#line 183
    fatal("cannot verify server_host_key");
  }
#line 184
  tmp___4 = (*(kex->verify_host_key))(server_host_key);
#line 184
  if (tmp___4 == -1) {
#line 185
    fatal("server_host_key verification failed");
  }
#line 188
  dh_server_pub = BN_new();
#line 188
  if ((unsigned int )dh_server_pub == (unsigned int )((void *)0)) {
#line 189
    fatal("dh_server_pub == NULL");
  }
#line 190
  packet_get_bignum2(dh_server_pub);
#line 200
  tmp___5 = packet_get_string(& slen);
#line 200
  signature = (u_char *)tmp___5;
#line 201
  while (1) {
#line 201
    tmp___6 = packet_remaining();
#line 201
    _len___0 = tmp___6;
#line 201
    if (_len___0 > 0) {
#line 201
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "kexgex.c",
          201);
#line 201
      packet_disconnect("Packet integrity error.");
    }
#line 201
    break;
  }
#line 203
  tmp___7 = dh_pub_is_valid(dh, dh_server_pub);
#line 203
  if (! tmp___7) {
#line 204
    packet_disconnect("bad server public DH value");
  }
#line 206
  tmp___8 = DH_size((DH const   *)dh);
#line 206
  klen = (unsigned int )tmp___8;
#line 207
  tmp___9 = xmalloc(klen);
#line 207
  kbuf = (u_char *)tmp___9;
#line 208
  tmp___10 = DH_compute_key(kbuf, (BIGNUM const   *)dh_server_pub, dh);
#line 208
  kout = (unsigned int )tmp___10;
#line 212
  shared_secret = BN_new();
#line 212
  if ((unsigned int )shared_secret == (unsigned int )((void *)0)) {
#line 213
    fatal("kexgex_client: BN_new failed");
  }
#line 214
  BN_bin2bn((unsigned char const   *)kbuf, (int )kout, shared_secret);
#line 215
  memset((void *)kbuf, 0, klen);
#line 216
  xfree((void *)kbuf);
#line 218
  if (datafellows & 16384) {
#line 219
    max = -1;
#line 219
    min = max;
  }
#line 222
  tmp___11 = buffer_len(& kex->peer);
#line 222
  tmp___12 = buffer_ptr(& kex->peer);
#line 222
  tmp___13 = buffer_len(& kex->my);
#line 222
  tmp___14 = buffer_ptr(& kex->my);
#line 222
  hash = kexgex_hash(kex->client_version_string, kex->server_version_string, (char *)tmp___14,
                     (int )tmp___13, (char *)tmp___12, (int )tmp___11, server_host_key_blob,
                     (int )sbloblen, min, nbits, max, dh->p, dh->g, dh->pub_key, dh_server_pub,
                     shared_secret);
#line 235
  DH_free(dh);
#line 236
  xfree((void *)server_host_key_blob);
#line 237
  BN_clear_free(dh_server_pub);
#line 239
  tmp___15 = key_verify(server_host_key, signature, slen, hash, 20U);
#line 239
  if (tmp___15 != 1) {
#line 240
    fatal("key_verify failed for server_host_key");
  }
#line 241
  key_free(server_host_key);
#line 242
  xfree((void *)signature);
#line 245
  if ((unsigned int )kex->session_id == (unsigned int )((void *)0)) {
#line 246
    kex->session_id_len = 20;
#line 247
    tmp___16 = xmalloc((unsigned int )kex->session_id_len);
#line 247
    kex->session_id = (u_char *)tmp___16;
#line 248
    memcpy((void * __restrict  )kex->session_id, (void const   * __restrict  )hash,
           (unsigned int )kex->session_id_len);
  }
#line 250
  kex_derive_keys(kex, hash, shared_secret);
#line 251
  BN_clear_free(shared_secret);
#line 253
  kex_finish(kex);
#line 254
  return;
}
}
#line 258 "kexgex.c"
static void kexgex_server(Kex *kex ) 
{ BIGNUM *shared_secret ;
  BIGNUM *dh_client_pub ;
  Key *server_host_key ;
  DH *dh ;
  u_char *kbuf ;
  u_char *hash ;
  u_char *signature ;
  u_char *server_host_key_blob ;
  u_int sbloblen ;
  u_int klen ;
  u_int kout ;
  u_int slen ;
  int min ;
  int max ;
  int nbits ;
  int type ;
  u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  int _len ;
  int tmp___3 ;
  int _len___0 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  u_int tmp___11 ;
  void *tmp___12 ;
  u_int tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;

  {
#line 261
  shared_secret = (BIGNUM *)((void *)0);
#line 261
  dh_client_pub = (BIGNUM *)((void *)0);
#line 264
  signature = (u_char *)((void *)0);
#line 264
  server_host_key_blob = (u_char *)((void *)0);
#line 266
  min = -1;
#line 266
  max = -1;
#line 266
  nbits = -1;
#line 268
  if ((unsigned int )kex->load_host_key == (unsigned int )((void *)0)) {
#line 269
    fatal("Cannot load hostkey");
  }
#line 270
  server_host_key = (*(kex->load_host_key))(kex->hostkey_type);
#line 271
  if ((unsigned int )server_host_key == (unsigned int )((void *)0)) {
#line 272
    fatal("Unsupported hostkey type %d", kex->hostkey_type);
  }
#line 274
  type = packet_read();
#line 275
  switch (type) {
  case 34: 
#line 277
  debug("SSH2_MSG_KEX_DH_GEX_REQUEST received");
#line 278
  tmp = packet_get_int();
#line 278
  min = (int )tmp;
#line 279
  tmp___0 = packet_get_int();
#line 279
  nbits = (int )tmp___0;
#line 280
  tmp___1 = packet_get_int();
#line 280
  max = (int )tmp___1;
#line 281
  if (1024 > min) {
#line 281
    min = 1024;
  } else {
#line 281
    min = min;
  }
#line 282
  if (8192 < max) {
#line 282
    max = 8192;
  } else {
#line 282
    max = max;
  }
#line 283
  break;
  case 30: 
#line 285
  debug("SSH2_MSG_KEX_DH_GEX_REQUEST_OLD received");
#line 286
  tmp___2 = packet_get_int();
#line 286
  nbits = (int )tmp___2;
#line 287
  min = 1024;
#line 288
  max = 8192;
#line 290
  break;
  default: 
#line 292
  fatal("protocol error during kex, no DH_GEX_REQUEST: %d", type);
  }
#line 294
  while (1) {
#line 294
    tmp___3 = packet_remaining();
#line 294
    _len = tmp___3;
#line 294
    if (_len > 0) {
#line 294
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kexgex.c",
          294);
#line 294
      packet_disconnect("Packet integrity error.");
    }
#line 294
    break;
  }
#line 296
  if (max < min) {
#line 297
    fatal("DH_GEX_REQUEST, bad parameters: %d !< %d !< %d", min, nbits, max);
  } else {
#line 296
    if (nbits < min) {
#line 297
      fatal("DH_GEX_REQUEST, bad parameters: %d !< %d !< %d", min, nbits, max);
    } else {
#line 296
      if (max < nbits) {
#line 297
        fatal("DH_GEX_REQUEST, bad parameters: %d !< %d !< %d", min, nbits, max);
      }
    }
  }
#line 301
  if (use_privsep) {
#line 301
    dh = mm_choose_dh(min, nbits, max);
  } else {
#line 301
    dh = choose_dh(min, nbits, max);
  }
#line 302
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 303
    packet_disconnect("Protocol error: no matching DH grp found");
  }
#line 305
  debug("SSH2_MSG_KEX_DH_GEX_GROUP sent");
#line 306
  packet_start((unsigned char)31);
#line 307
  packet_put_bignum2(dh->p);
#line 308
  packet_put_bignum2(dh->g);
#line 309
  packet_send();
#line 312
  packet_write_wait();
#line 315
  dh_gen_key(dh, kex->we_need * 8);
#line 317
  debug("expecting SSH2_MSG_KEX_DH_GEX_INIT");
#line 318
  packet_read_expect(32);
#line 321
  dh_client_pub = BN_new();
#line 321
  if ((unsigned int )dh_client_pub == (unsigned int )((void *)0)) {
#line 322
    fatal("dh_client_pub == NULL");
  }
#line 323
  packet_get_bignum2(dh_client_pub);
#line 324
  while (1) {
#line 324
    tmp___6 = packet_remaining();
#line 324
    _len___0 = tmp___6;
#line 324
    if (_len___0 > 0) {
#line 324
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "kexgex.c",
          324);
#line 324
      packet_disconnect("Packet integrity error.");
    }
#line 324
    break;
  }
#line 339
  tmp___7 = dh_pub_is_valid(dh, dh_client_pub);
#line 339
  if (! tmp___7) {
#line 340
    packet_disconnect("bad client public DH value");
  }
#line 342
  tmp___8 = DH_size((DH const   *)dh);
#line 342
  klen = (unsigned int )tmp___8;
#line 343
  tmp___9 = xmalloc(klen);
#line 343
  kbuf = (u_char *)tmp___9;
#line 344
  tmp___10 = DH_compute_key(kbuf, (BIGNUM const   *)dh_client_pub, dh);
#line 344
  kout = (unsigned int )tmp___10;
#line 348
  shared_secret = BN_new();
#line 348
  if ((unsigned int )shared_secret == (unsigned int )((void *)0)) {
#line 349
    fatal("kexgex_server: BN_new failed");
  }
#line 350
  BN_bin2bn((unsigned char const   *)kbuf, (int )kout, shared_secret);
#line 351
  memset((void *)kbuf, 0, klen);
#line 352
  xfree((void *)kbuf);
#line 354
  key_to_blob(server_host_key, & server_host_key_blob, & sbloblen);
#line 356
  if (type == 30) {
#line 357
    max = -1;
#line 357
    min = max;
  }
#line 360
  tmp___11 = buffer_len(& kex->my);
#line 360
  tmp___12 = buffer_ptr(& kex->my);
#line 360
  tmp___13 = buffer_len(& kex->peer);
#line 360
  tmp___14 = buffer_ptr(& kex->peer);
#line 360
  hash = kexgex_hash(kex->client_version_string, kex->server_version_string, (char *)tmp___14,
                     (int )tmp___13, (char *)tmp___12, (int )tmp___11, server_host_key_blob,
                     (int )sbloblen, min, nbits, max, dh->p, dh->g, dh_client_pub,
                     dh->pub_key, shared_secret);
#line 372
  BN_clear_free(dh_client_pub);
#line 376
  if ((unsigned int )kex->session_id == (unsigned int )((void *)0)) {
#line 377
    kex->session_id_len = 20;
#line 378
    tmp___15 = xmalloc((unsigned int )kex->session_id_len);
#line 378
    kex->session_id = (u_char *)tmp___15;
#line 379
    memcpy((void * __restrict  )kex->session_id, (void const   * __restrict  )hash,
           (unsigned int )kex->session_id_len);
  }
#line 384
  if (use_privsep) {
#line 384
    mm_key_sign(server_host_key, & signature, & slen, hash, 20U);
  } else {
#line 384
    key_sign(server_host_key, & signature, & slen, hash, 20U);
  }
#line 389
  debug("SSH2_MSG_KEX_DH_GEX_REPLY sent");
#line 390
  packet_start((unsigned char)33);
#line 391
  packet_put_string((void const   *)server_host_key_blob, sbloblen);
#line 392
  packet_put_bignum2(dh->pub_key);
#line 393
  packet_put_string((void const   *)signature, slen);
#line 394
  packet_send();
#line 396
  xfree((void *)signature);
#line 397
  xfree((void *)server_host_key_blob);
#line 399
  DH_free(dh);
#line 401
  kex_derive_keys(kex, hash, shared_secret);
#line 402
  BN_clear_free(shared_secret);
#line 404
  kex_finish(kex);
#line 405
  return;
}
}
#line 407 "kexgex.c"
void kexgex(Kex *kex ) 
{ 

  {
#line 410
  if (kex->server) {
#line 411
    kexgex_server(kex);
  } else {
#line 413
    kexgex_client(kex);
  }
#line 414
  return;
}
}
#line 1 "log.o"
#line 361 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 646 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 175 "/usr/include/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 51 "log.h"
void log_init(char *av0 , LogLevel level , SyslogFacility facility , int on_stderr ) ;
#line 53
SyslogFacility log_facility_number(char *name ) ;
#line 54
LogLevel log_level_number(char *name ) ;
#line 66
void fatal_remove_cleanup(void (*proc)(void *context ) , void *context ) ;
#line 44 "log.c"
static LogLevel log_level  =    3;
#line 45 "log.c"
static int log_on_stderr  =    1;
#line 46 "log.c"
static int log_facility  =    4 << 3;
#line 47 "log.c"
static char *argv0  ;
#line 53 "log.c"
static struct __anonstruct_log_facilities_65 log_facilities[13]  = 
#line 53
  {      {"DAEMON", 0}, 
        {"USER", 1}, 
        {"AUTH", 2}, 
        {"AUTHPRIV", 3}, 
        {"LOCAL0", 4}, 
        {"LOCAL1", 5}, 
        {"LOCAL2", 6}, 
        {"LOCAL3", 7}, 
        {"LOCAL4", 8}, 
        {"LOCAL5", 9}, 
        {"LOCAL6", 10}, 
        {"LOCAL7", 11}, 
        {(char const   *)((void *)0), -1}};
#line 74 "log.c"
static struct __anonstruct_log_levels_66 log_levels[10]  = 
#line 74
  {      {"QUIET", 0}, 
        {"FATAL", 1}, 
        {"ERROR", 2}, 
        {"INFO", 3}, 
        {"VERBOSE", 4}, 
        {"DEBUG", 5}, 
        {"DEBUG1", 5}, 
        {"DEBUG2", 6}, 
        {"DEBUG3", 7}, 
        {(char const   *)((void *)0), -1}};
#line 91 "log.c"
SyslogFacility log_facility_number(char *name ) 
{ int i ;
  int tmp ;

  {
#line 95
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 96
    i = 0;
#line 96
    while (log_facilities[i].name) {
#line 97
      tmp = strcasecmp(log_facilities[i].name, (char const   *)name);
#line 97
      if (tmp == 0) {
#line 98
        return (log_facilities[i].val);
      }
#line 96
      i ++;
    }
  }
#line 99
  return (-1);
}
}
#line 102 "log.c"
LogLevel log_level_number(char *name ) 
{ int i ;
  int tmp ;

  {
#line 106
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 107
    i = 0;
#line 107
    while (log_levels[i].name) {
#line 108
      tmp = strcasecmp(log_levels[i].name, (char const   *)name);
#line 108
      if (tmp == 0) {
#line 109
        return (log_levels[i].val);
      }
#line 107
      i ++;
    }
  }
#line 110
  return (-1);
}
}
#line 115 "log.c"
void ( /* format attribute */  error)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 119
  __builtin_va_start(args, fmt);
#line 120
  do_log(2, fmt, args);
#line 121
  __builtin_va_end(args);
#line 122
  return;
}
}
#line 126 "log.c"
void ( /* format attribute */  log)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 130
  __builtin_va_start(args, fmt);
#line 131
  do_log(3, fmt, args);
#line 132
  __builtin_va_end(args);
#line 133
  return;
}
}
#line 137 "log.c"
void ( /* format attribute */  verbose)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 141
  __builtin_va_start(args, fmt);
#line 142
  do_log(4, fmt, args);
#line 143
  __builtin_va_end(args);
#line 144
  return;
}
}
#line 148 "log.c"
void ( /* format attribute */  debug)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 152
  __builtin_va_start(args, fmt);
#line 153
  do_log(5, fmt, args);
#line 154
  __builtin_va_end(args);
#line 155
  return;
}
}
#line 157 "log.c"
void ( /* format attribute */  debug2)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 161
  __builtin_va_start(args, fmt);
#line 162
  do_log(6, fmt, args);
#line 163
  __builtin_va_end(args);
#line 164
  return;
}
}
#line 166 "log.c"
void ( /* format attribute */  debug3)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 170
  __builtin_va_start(args, fmt);
#line 171
  do_log(7, fmt, args);
#line 172
  __builtin_va_end(args);
#line 173
  return;
}
}
#line 183 "log.c"
static struct fatal_cleanup *fatal_cleanups  =    (struct fatal_cleanup *)((void *)0);
#line 187 "log.c"
void fatal_add_cleanup(void (*proc)(void * ) , void *context ) 
{ struct fatal_cleanup *cu ;
  void *tmp ;

  {
#line 192
  tmp = xmalloc(sizeof(*cu));
#line 192
  cu = (struct fatal_cleanup *)tmp;
#line 193
  cu->proc = proc;
#line 194
  cu->context = context;
#line 195
  cu->next = fatal_cleanups;
#line 196
  fatal_cleanups = cu;
#line 197
  return;
}
}
#line 201 "log.c"
void fatal_remove_cleanup(void (*proc)(void *context ) , void *context ) 
{ struct fatal_cleanup **cup ;
  struct fatal_cleanup *cu ;

  {
#line 206
  cup = & fatal_cleanups;
#line 206
  while (*cup) {
#line 207
    cu = *cup;
#line 208
    if ((unsigned int )cu->proc == (unsigned int )proc) {
#line 208
      if ((unsigned int )cu->context == (unsigned int )context) {
#line 209
        *cup = cu->next;
#line 210
        xfree((void *)cu);
#line 211
        return;
      }
    }
#line 206
    cup = & cu->next;
  }
#line 214
  fatal("fatal_remove_cleanup: no such cleanup function: 0x%lx 0x%lx", (unsigned long )proc,
        (unsigned long )context);
#line 216
  return;
}
}
#line 223 "log.c"
static int called  =    0;
#line 219 "log.c"
void fatal_cleanup(void) 
{ struct fatal_cleanup *cu ;
  struct fatal_cleanup *next_cu ;

  {
#line 225
  if (called) {
#line 226
    exit(255);
  }
#line 227
  called = 1;
#line 229
  cu = fatal_cleanups;
#line 229
  while (cu) {
#line 230
    next_cu = cu->next;
#line 231
    debug("Calling cleanup 0x%lx(0x%lx)", (unsigned long )cu->proc, (unsigned long )cu->context);
#line 233
    (*(cu->proc))(cu->context);
#line 229
    cu = next_cu;
  }
#line 235
  exit(255);
}
}
#line 243 "log.c"
void log_init(char *av0 , LogLevel level , SyslogFacility facility , int on_stderr ) 
{ 

  {
#line 246
  argv0 = av0;
#line 248
  switch ((int )level) {
  case 0: 
  case 1: 
  case 2: 
  case 3: 
  case 4: 
  case 5: 
  case 6: 
  case 7: 
#line 257
  log_level = level;
#line 258
  break;
  default: 
#line 260
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized internal syslog level code %d\n",
          (int )level);
#line 262
  exit(1);
  }
#line 265
  log_on_stderr = on_stderr;
#line 266
  if (on_stderr) {
#line 267
    return;
  }
#line 269
  switch ((int )facility) {
  case 0: 
#line 271
  log_facility = 3 << 3;
#line 272
  break;
  case 1: 
#line 274
  log_facility = 1 << 3;
#line 275
  break;
  case 2: 
#line 277
  log_facility = 4 << 3;
#line 278
  break;
  case 3: 
#line 281
  log_facility = 10 << 3;
#line 282
  break;
  case 4: 
#line 285
  log_facility = 16 << 3;
#line 286
  break;
  case 5: 
#line 288
  log_facility = 17 << 3;
#line 289
  break;
  case 6: 
#line 291
  log_facility = 18 << 3;
#line 292
  break;
  case 7: 
#line 294
  log_facility = 19 << 3;
#line 295
  break;
  case 8: 
#line 297
  log_facility = 20 << 3;
#line 298
  break;
  case 9: 
#line 300
  log_facility = 21 << 3;
#line 301
  break;
  case 10: 
#line 303
  log_facility = 22 << 3;
#line 304
  break;
  case 11: 
#line 306
  log_facility = 23 << 3;
#line 307
  break;
  default: 
#line 309
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized internal syslog facility code %d\n",
          (int )facility);
#line 312
  exit(1);
  }
#line 314
  return;
}
}
#line 318 "log.c"
void do_log(LogLevel level , char const   *fmt , va_list args ) 
{ char msgbuf[1024] ;
  char fmtbuf[1024] ;
  char *txt ;
  int pri ;
  char *tmp ;

  {
#line 323
  txt = (char *)((void *)0);
#line 324
  pri = 6;
#line 326
  if ((int )level > (int )log_level) {
#line 327
    return;
  }
#line 329
  switch ((int )level) {
  case 1: 
#line 331
  if (! log_on_stderr) {
#line 332
    txt = (char *)"fatal";
  }
#line 333
  pri = 2;
#line 334
  break;
  case 2: 
#line 336
  if (! log_on_stderr) {
#line 337
    txt = (char *)"error";
  }
#line 338
  pri = 3;
#line 339
  break;
  case 3: 
#line 341
  pri = 6;
#line 342
  break;
  case 4: 
#line 344
  pri = 6;
#line 345
  break;
  case 5: 
#line 347
  txt = (char *)"debug1";
#line 348
  pri = 7;
#line 349
  break;
  case 6: 
#line 351
  txt = (char *)"debug2";
#line 352
  pri = 7;
#line 353
  break;
  case 7: 
#line 355
  txt = (char *)"debug3";
#line 356
  pri = 7;
#line 357
  break;
  default: 
#line 359
  txt = (char *)"internal error";
#line 360
  pri = 3;
#line 361
  break;
  }
#line 363
  if ((unsigned int )txt != (unsigned int )((void *)0)) {
#line 364
    snprintf((char * __restrict  )(fmtbuf), sizeof(fmtbuf), (char const   * __restrict  )"%s: %s",
             txt, fmt);
#line 365
    vsnprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )(fmtbuf),
              args);
  } else {
#line 367
    vsnprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )fmt,
              args);
  }
#line 369
  if (log_on_stderr) {
#line 370
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\r\n", msgbuf);
  } else {
#line 372
    if (argv0) {
#line 372
      tmp = argv0;
    } else {
#line 372
      tmp = __progname;
    }
#line 372
    openlog((char const   *)tmp, 1, log_facility);
#line 373
    syslog(pri, "%.500s", msgbuf);
#line 374
    closelog();
  }
#line 376
  return;
}
}
#line 1 "match.o"
#line 116 "/usr/include/ctype.h"
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 17 "match.h"
int match_pattern(char const   *s , char const   *pattern ) ;
#line 20
int match_host_and_ip(char const   *host , char const   *ipaddr , char const   *patterns ) ;
#line 21
int match_user(char const   *user , char const   *host , char const   *ipaddr , char const   *pattern ) ;
#line 48 "match.c"
int match_pattern(char const   *s , char const   *pattern ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 51
  while (1) {
#line 53
    if (! *pattern) {
#line 54
      return (! *s);
    }
#line 56
    if ((int const   )*pattern == 42) {
#line 58
      pattern ++;
#line 61
      if (! *pattern) {
#line 62
        return (1);
      }
#line 65
      if ((int const   )*pattern != 63) {
#line 65
        if ((int const   )*pattern != 42) {
#line 71
          while (*s) {
#line 72
            if ((int const   )*s == (int const   )*pattern) {
#line 72
              tmp = match_pattern(s + 1, pattern + 1);
#line 72
              if (tmp) {
#line 74
                return (1);
              }
            }
#line 71
            s ++;
          }
#line 76
          return (0);
        }
      }
#line 82
      while (*s) {
#line 83
        tmp___0 = match_pattern(s, pattern);
#line 83
        if (tmp___0) {
#line 84
          return (1);
        }
#line 82
        s ++;
      }
#line 86
      return (0);
    }
#line 92
    if (! *s) {
#line 93
      return (0);
    }
#line 96
    if ((int const   )*pattern != 63) {
#line 96
      if ((int const   )*pattern != (int const   )*s) {
#line 97
        return (0);
      }
    }
#line 100
    s ++;
#line 101
    pattern ++;
  }
}
}
#line 113 "match.c"
int match_pattern_list(char const   *string , char const   *pattern , u_int len ,
                       int dolower ) 
{ char sub[1024] ;
  int negated ;
  int got_positive ;
  u_int i ;
  u_int subi ;
  int __res___0 ;
  __int32_t const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;

  {
#line 122
  got_positive = 0;
#line 123
  i = 0U;
#line 123
  while (i < len) {
#line 125
    if ((int const   )*(pattern + i) == 33) {
#line 126
      negated = 1;
#line 127
      i ++;
    } else {
#line 129
      negated = 0;
    }
#line 135
    subi = 0U;
#line 135
    while (1) {
#line 135
      if (i < len) {
#line 135
        if (subi < sizeof(sub) - 1U) {
#line 135
          if (! ((int const   )*(pattern + i) != 44)) {
#line 135
            break;
          }
        } else {
#line 135
          break;
        }
      } else {
#line 135
        break;
      }
#line 139
      if (dolower) {
#line 139
        tmp___6 = __ctype_b_loc();
#line 139
        if ((int const   )*(*tmp___6 + (int )*(pattern + i)) & 256) {
#line 139
          if (sizeof(*(pattern + i)) > 1U) {
#line 139
            __res___0 = tolower((int )*(pattern + i));
          } else {
#line 139
            tmp___5 = __ctype_tolower_loc();
#line 139
            __res___0 = (int )*(*tmp___5 + (int )*(pattern + i));
          }
#line 139
          sub[subi] = (char )__res___0;
        } else {
#line 139
          sub[subi] = (char )*(pattern + i);
        }
      } else {
#line 139
        sub[subi] = (char )*(pattern + i);
      }
#line 135
      subi ++;
#line 135
      i ++;
    }
#line 141
    if (subi >= sizeof(sub) - 1U) {
#line 142
      return (0);
    }
#line 145
    if (i < len) {
#line 145
      if ((int const   )*(pattern + i) == 44) {
#line 146
        i ++;
      }
    }
#line 149
    sub[subi] = (char )'\000';
#line 152
    tmp___7 = match_pattern(string, (char const   *)(sub));
#line 152
    if (tmp___7) {
#line 153
      if (negated) {
#line 154
        return (-1);
      } else {
#line 156
        got_positive = 1;
      }
    }
  }
#line 164
  return (got_positive);
}
}
#line 173 "match.c"
int match_hostname(char const   *host , char const   *pattern , u_int len ) 
{ int tmp ;

  {
#line 176
  tmp = match_pattern_list(host, pattern, len, 1);
#line 176
  return (tmp);
}
}
#line 183 "match.c"
int match_host_and_ip(char const   *host , char const   *ipaddr , char const   *patterns ) 
{ int mhost ;
  int mip ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 190
  tmp = strlen(patterns);
#line 190
  mip = match_hostname(ipaddr, patterns, tmp);
#line 190
  if (mip == -1) {
#line 191
    return (0);
  }
#line 193
  tmp___0 = strlen(patterns);
#line 193
  mhost = match_hostname(host, patterns, tmp___0);
#line 193
  if (mhost == -1) {
#line 194
    return (0);
  }
#line 196
  if (mhost == 0) {
#line 196
    if (mip == 0) {
#line 197
      return (0);
    }
  }
#line 198
  return (1);
}
}
#line 204 "match.c"
int match_user(char const   *user , char const   *host , char const   *ipaddr , char const   *pattern ) 
{ char *p ;
  char *pat ;
  int ret ;
  int tmp ;
  char *tmp___1 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 211
  tmp___1 = __builtin_strchr((char *)pattern, '@');
#line 211
  p = tmp___1;
#line 211
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 212
    tmp = match_pattern(user, pattern);
#line 212
    return (tmp);
  }
#line 214
  pat = xstrdup(pattern);
#line 215
  tmp___3 = __builtin_strchr(pat, '@');
#line 215
  p = tmp___3;
#line 216
  tmp___4 = p;
#line 216
  p ++;
#line 216
  *tmp___4 = (char )'\000';
#line 218
  ret = match_pattern(user, (char const   *)pat);
#line 218
  if (ret == 1) {
#line 219
    ret = match_host_and_ip(host, ipaddr, (char const   *)p);
  }
#line 220
  xfree((void *)pat);
#line 222
  return (ret);
}
}
#line 231 "match.c"
char *match_list(char const   *client , char const   *server , u_int *next ) 
{ char *sproposals[40] ;
  char *c ;
  char *s ;
  char *p ;
  char *ret ;
  char *cp ;
  char *sp ;
  int i ;
  int j ;
  int nproposals ;
  char *tmp___14 ;
  char *tmp___30 ;
  char *tmp___46 ;
  char *tmp___62 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___69 ;
  int tmp___72 ;
  int tmp___73 ;

  {
#line 238
  cp = xstrdup(client);
#line 238
  c = cp;
#line 239
  sp = xstrdup(server);
#line 239
  s = sp;
#line 241
  tmp___14 = __strsep_g(& sp, ",");
#line 241
  p = tmp___14;
#line 241
  i = 0;
#line 241
  while (1) {
#line 241
    if (p) {
#line 241
      if (! ((int )*p != 0)) {
#line 241
        break;
      }
    } else {
#line 241
      break;
    }
#line 243
    if (i < 40) {
#line 244
      sproposals[i] = p;
    } else {
#line 246
      break;
    }
#line 242
    tmp___30 = __strsep_g(& sp, ",");
#line 242
    p = tmp___30;
#line 242
    i ++;
  }
#line 248
  nproposals = i;
#line 250
  tmp___46 = __strsep_g(& cp, ",");
#line 250
  p = tmp___46;
#line 250
  i = 0;
#line 250
  while (1) {
#line 250
    if (p) {
#line 250
      if (! ((int )*p != 0)) {
#line 250
        break;
      }
    } else {
#line 250
      break;
    }
#line 252
    j = 0;
#line 252
    while (j < nproposals) {
#line 253
      if (0) {
#line 253
        __s1_len = strlen((char const   *)p);
#line 253
        __s2_len = strlen((char const   *)sproposals[j]);
#line 253
        if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
          goto _L___0;
        } else {
#line 253
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 253
            if (! ((unsigned int )((void const   *)(sproposals[j] + 1)) - (unsigned int )((void const   *)sproposals[j]) == 1U)) {
#line 253
              tmp___73 = 1;
            } else {
#line 253
              if (__s2_len >= 4U) {
#line 253
                tmp___73 = 1;
              } else {
#line 253
                tmp___73 = 0;
              }
            }
          } else {
#line 253
            tmp___73 = 0;
          }
        }
#line 253
        if (tmp___73) {
#line 253
          tmp___69 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
        } else {
#line 253
          tmp___72 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
#line 253
          tmp___69 = tmp___72;
        }
      } else {
#line 253
        tmp___72 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
#line 253
        tmp___69 = tmp___72;
      }
#line 253
      if (tmp___69 == 0) {
#line 254
        ret = xstrdup((char const   *)p);
#line 255
        if ((unsigned int )next != (unsigned int )((void *)0)) {
#line 256
          if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 256
            *next = strlen((char const   *)c);
          } else {
#line 256
            *next = (unsigned int )(cp - c);
          }
        }
#line 258
        xfree((void *)c);
#line 259
        xfree((void *)s);
#line 260
        return (ret);
      }
#line 252
      j ++;
    }
#line 251
    tmp___62 = __strsep_g(& cp, ",");
#line 251
    p = tmp___62;
#line 251
    i ++;
  }
#line 264
  if ((unsigned int )next != (unsigned int )((void *)0)) {
#line 265
    *next = strlen((char const   *)c);
  }
#line 266
  xfree((void *)c);
#line 267
  xfree((void *)s);
#line 268
  return ((char *)((void *)0));
}
}
/* compiler builtin: 
   char *__builtin_strpbrk(char const   * , char const   * ) ;  */
/* compiler builtin: 
   unsigned int __builtin_strspn(char const   * , char const   * ) ;  */
#line 1 "misc.o"
#line 184 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 15 "misc.h"
char *chop(char *s ) ;
#line 18
void unset_nonblock(int fd ) ;
#line 20
int a2port(char const   *s ) ;
#line 21
char *cleanhostname(char *host ) ;
#line 22
char *colon(char *cp ) ;
#line 23
long convtime(char const   *s ) ;
#line 25
struct passwd *pwcopy(struct passwd *pw ) ;
#line 33
void ( /* format attribute */  addargs)(arglist *args , char *fmt  , ...) ;
#line 37
mysig_t mysignal(int sig , void (*act)(int  ) ) ;
#line 33 "misc.c"
char *chop(char *s ) 
{ char *t ;

  {
#line 36
  t = s;
#line 37
  while (*t) {
#line 38
    if ((int )*t == 10) {
#line 39
      *t = (char )'\000';
#line 40
      return (s);
    } else {
#line 38
      if ((int )*t == 13) {
#line 39
        *t = (char )'\000';
#line 40
        return (s);
      }
    }
#line 42
    t ++;
  }
#line 44
  return (s);
}
}
#line 49 "misc.c"
void set_nonblock(int fd ) 
{ int val ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 54
  val = fcntl(fd, 3, 0);
#line 55
  if (val < 0) {
#line 56
    tmp = __errno_location();
#line 56
    tmp___0 = strerror(*tmp);
#line 56
    error("fcntl(%d, F_GETFL, 0): %s", fd, tmp___0);
#line 57
    return;
  }
#line 59
  if (val & 2048) {
#line 60
    debug2("fd %d is O_NONBLOCK", fd);
#line 61
    return;
  }
#line 63
  debug("fd %d setting O_NONBLOCK", fd);
#line 64
  val |= 2048;
#line 65
  tmp___3 = fcntl(fd, 4, val);
#line 65
  if (tmp___3 == -1) {
#line 66
    tmp___1 = __errno_location();
#line 66
    tmp___2 = strerror(*tmp___1);
#line 66
    debug("fcntl(%d, F_SETFL, O_NONBLOCK): %s", fd, tmp___2);
  }
#line 68
  return;
}
}
#line 70 "misc.c"
void unset_nonblock(int fd ) 
{ int val ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 75
  val = fcntl(fd, 3, 0);
#line 76
  if (val < 0) {
#line 77
    tmp = __errno_location();
#line 77
    tmp___0 = strerror(*tmp);
#line 77
    error("fcntl(%d, F_GETFL, 0): %s", fd, tmp___0);
#line 78
    return;
  }
#line 80
  if (! (val & 2048)) {
#line 81
    debug2("fd %d is not O_NONBLOCK", fd);
#line 82
    return;
  }
#line 84
  debug("fd %d clearing O_NONBLOCK", fd);
#line 85
  val &= -2049;
#line 86
  tmp___3 = fcntl(fd, 4, val);
#line 86
  if (tmp___3 == -1) {
#line 87
    tmp___1 = __errno_location();
#line 87
    tmp___2 = strerror(*tmp___1);
#line 87
    debug("fcntl(%d, F_SETFL, O_NONBLOCK): %s", fd, tmp___2);
  }
#line 89
  return;
}
}
#line 92 "misc.c"
void set_nodelay(int fd ) 
{ int opt ;
  socklen_t optlen ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 98
  optlen = sizeof(opt);
#line 99
  tmp___1 = getsockopt(fd, 6, 1, (void * __restrict  )(& opt), (socklen_t * __restrict  )(& optlen));
#line 99
  if (tmp___1 == -1) {
#line 100
    tmp = __errno_location();
#line 100
    tmp___0 = strerror(*tmp);
#line 100
    error("getsockopt TCP_NODELAY: %.100s", tmp___0);
#line 101
    return;
  }
#line 103
  if (opt == 1) {
#line 104
    debug2("fd %d is TCP_NODELAY", fd);
#line 105
    return;
  }
#line 107
  opt = 1;
#line 108
  debug("fd %d setting TCP_NODELAY", fd);
#line 109
  tmp___4 = setsockopt(fd, 6, 1, (void const   *)(& opt), sizeof(opt));
#line 109
  if (tmp___4 == -1) {
#line 110
    tmp___2 = __errno_location();
#line 110
    tmp___3 = strerror(*tmp___2);
#line 110
    error("setsockopt TCP_NODELAY: %.100s", tmp___3);
  }
#line 111
  return;
}
}
#line 117 "misc.c"
char *strdelim(char **s ) 
{ char *old ;
  int wspace ;
  char *tmp___30 ;
  unsigned int tmp___62 ;
  unsigned int tmp___94 ;

  {
#line 121
  wspace = 0;
#line 123
  if ((unsigned int )*s == (unsigned int )((void *)0)) {
#line 124
    return ((char *)((void *)0));
  }
#line 126
  old = *s;
#line 128
  tmp___30 = __builtin_strpbrk((char const   *)*s, " \t\r\n=");
#line 128
  *s = tmp___30;
#line 129
  if ((unsigned int )*s == (unsigned int )((void *)0)) {
#line 130
    return (old);
  }
#line 133
  if ((int )*(*(s + 0)) == 61) {
#line 134
    wspace = 1;
  }
#line 135
  *(*(s + 0)) = (char )'\000';
#line 137
  tmp___62 = __builtin_strspn((char const   *)(*s + 1), " \t\r\n");
#line 137
  *s += tmp___62 + 1U;
#line 138
  if ((int )*(*(s + 0)) == 61) {
#line 138
    if (! wspace) {
#line 139
      tmp___94 = __builtin_strspn((char const   *)(*s + 1), " \t\r\n");
#line 139
      *s += tmp___94 + 1U;
    }
  }
#line 141
  return (old);
}
}
#line 144 "misc.c"
struct passwd *pwcopy(struct passwd *pw ) 
{ struct passwd *copy ;
  void *tmp ;

  {
#line 147
  tmp = xmalloc(sizeof(*copy));
#line 147
  copy = (struct passwd *)tmp;
#line 149
  memset((void *)copy, 0, sizeof(*copy));
#line 150
  copy->pw_name = xstrdup((char const   *)pw->pw_name);
#line 151
  copy->pw_passwd = xstrdup((char const   *)pw->pw_passwd);
#line 152
  copy->pw_gecos = xstrdup((char const   *)pw->pw_gecos);
#line 153
  copy->pw_uid = pw->pw_uid;
#line 154
  copy->pw_gid = pw->pw_gid;
#line 164
  copy->pw_dir = xstrdup((char const   *)pw->pw_dir);
#line 165
  copy->pw_shell = xstrdup((char const   *)pw->pw_shell);
#line 166
  return (copy);
}
}
#line 174 "misc.c"
int a2port(char const   *s ) 
{ long port ;
  char *endp ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 180
  tmp = __errno_location();
#line 180
  *tmp = 0;
#line 181
  port = strtol((char const   * __restrict  )s, (char ** __restrict  )(& endp), 0);
#line 182
  if ((unsigned int )s == (unsigned int )endp) {
#line 185
    return (0);
  } else {
#line 182
    if ((int )*endp != 0) {
#line 185
      return (0);
    } else {
#line 182
      tmp___0 = __errno_location();
#line 182
      if (*tmp___0 == 34) {
#line 182
        if (port == (-0x7FFFFFFF-1)) {
#line 185
          return (0);
        } else {
#line 182
          if (port == 2147483647L) {
#line 185
            return (0);
          } else {
            goto _L;
          }
        }
      } else {
        _L: /* CIL Label */ 
#line 182
        if (port <= 0L) {
#line 185
          return (0);
        } else {
#line 182
          if (port > 65535L) {
#line 185
            return (0);
          }
        }
      }
    }
  }
#line 187
  return ((int )port);
}
}
#line 217 "misc.c"
long convtime(char const   *s ) 
{ long total ;
  long secs ;
  char const   *p ;
  char *endp ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 224
  tmp = __errno_location();
#line 224
  *tmp = 0;
#line 225
  total = 0L;
#line 226
  p = s;
#line 228
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 229
    return (-1L);
  } else {
#line 228
    if ((int const   )*p == 0) {
#line 229
      return (-1L);
    }
  }
#line 231
  while (*p) {
#line 232
    secs = strtol((char const   * __restrict  )p, (char ** __restrict  )(& endp),
                  10);
#line 233
    if ((unsigned int )p == (unsigned int )endp) {
#line 236
      return (-1L);
    } else {
#line 233
      tmp___0 = __errno_location();
#line 233
      if (*tmp___0 == 34) {
#line 233
        if (secs == (-0x7FFFFFFF-1)) {
#line 236
          return (-1L);
        } else {
#line 233
          if (secs == 2147483647L) {
#line 236
            return (-1L);
          } else {
            goto _L;
          }
        }
      } else {
        _L: /* CIL Label */ 
#line 233
        if (secs < 0L) {
#line 236
          return (-1L);
        }
      }
    }
#line 238
    tmp___1 = endp;
#line 238
    endp ++;
#line 238
    switch ((int )*tmp___1) {
    case 0: 
#line 240
    endp --;
    case 115: 
    case 83: 
#line 243
    break;
    case 109: 
    case 77: 
#line 246
    secs *= 60L;
#line 247
    break;
    case 104: 
    case 72: 
#line 250
    secs *= 3600L;
#line 251
    break;
    case 100: 
    case 68: 
#line 254
    secs *= 86400L;
#line 255
    break;
    case 119: 
    case 87: 
#line 258
    secs *= 604800L;
#line 259
    break;
    default: ;
#line 261
    return (-1L);
    }
#line 263
    total += secs;
#line 264
    if (total < 0L) {
#line 265
      return (-1L);
    }
#line 266
    p = (char const   *)endp;
  }
#line 269
  return (total);
}
}
#line 272 "misc.c"
char *cleanhostname(char *host ) 
{ size_t tmp ;
  size_t tmp___0 ;

  {
#line 275
  if ((int )*host == 91) {
#line 275
    tmp___0 = strlen((char const   *)host);
#line 275
    if ((int )*(host + (tmp___0 - 1U)) == 93) {
#line 276
      tmp = strlen((char const   *)host);
#line 276
      *(host + (tmp - 1U)) = (char )'\000';
#line 277
      return (host + 1);
    } else {
#line 279
      return (host);
    }
  } else {
#line 279
    return (host);
  }
}
}
#line 282 "misc.c"
char *colon(char *cp ) 
{ int flag ;

  {
#line 285
  flag = 0;
#line 287
  if ((int )*cp == 58) {
#line 288
    return ((char *)0);
  }
#line 289
  if ((int )*cp == 91) {
#line 290
    flag = 1;
  }
#line 292
  while (*cp) {
#line 293
    if ((int )*cp == 64) {
#line 293
      if ((int )*(cp + 1) == 91) {
#line 294
        flag = 1;
      }
    }
#line 295
    if ((int )*cp == 93) {
#line 295
      if ((int )*(cp + 1) == 58) {
#line 295
        if (flag) {
#line 296
          return (cp + 1);
        }
      }
    }
#line 297
    if ((int )*cp == 58) {
#line 297
      if (! flag) {
#line 298
        return (cp);
      }
    }
#line 299
    if ((int )*cp == 47) {
#line 300
      return ((char *)0);
    }
#line 292
    cp ++;
  }
#line 302
  return ((char *)0);
}
}
#line 306 "misc.c"
void ( /* format attribute */  addargs)(arglist *args , char *fmt  , ...) 
{ va_list ap ;
  char buf___1[1024] ;
  void *tmp ;
  int tmp___0 ;

  {
#line 312
  __builtin_va_start(ap, fmt);
#line 313
  vsnprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )fmt,
            ap);
#line 314
  __builtin_va_end(ap);
#line 316
  if ((unsigned int )args->list == (unsigned int )((void *)0)) {
#line 317
    args->nalloc = 32;
#line 318
    args->num = 0;
  } else {
#line 319
    if (args->num + 2 >= args->nalloc) {
#line 320
      args->nalloc *= 2;
    }
  }
#line 322
  tmp = xrealloc((void *)args->list, (unsigned int )args->nalloc * sizeof(char *));
#line 322
  args->list = (char **)tmp;
#line 323
  tmp___0 = args->num;
#line 323
  (args->num) ++;
#line 323
  *(args->list + tmp___0) = xstrdup((char const   *)(buf___1));
#line 324
  *(args->list + args->num) = (char *)((void *)0);
#line 325
  return;
}
}
#line 327 "misc.c"
mysig_t mysignal(int sig , void (*act)(int  ) ) 
{ struct sigaction sa ;
  struct sigaction osa ;
  int tmp ;
  int tmp___0 ;

  {
#line 333
  tmp = sigaction(sig, (struct sigaction  const  * __restrict  )((void *)0), (struct sigaction * __restrict  )(& osa));
#line 333
  if (tmp == -1) {
#line 334
    return ((void (*)(int  ))-1);
  }
#line 335
  if ((unsigned int )osa.__sigaction_handler.sa_handler != (unsigned int )act) {
#line 336
    memset((void *)(& sa), 0, sizeof(sa));
#line 337
    sigemptyset(& sa.sa_mask);
#line 338
    sa.sa_flags = 0;
#line 340
    if (sig == 14) {
#line 341
      sa.sa_flags |= 536870912;
    }
#line 343
    sa.__sigaction_handler.sa_handler = act;
#line 344
    tmp___0 = sigaction(sig, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
#line 344
    if (tmp___0 == -1) {
#line 345
      return ((void (*)(int  ))-1);
    }
  }
#line 347
  return (osa.__sigaction_handler.sa_handler);
}
}
#line 1 "mpaux.o"
#line 20 "mpaux.h"
void compute_session_id(u_char *session_id___0 , u_char *cookie , BIGNUM *host_key_n ,
                        BIGNUM *session_key_n ) ;
#line 26 "mpaux.c"
void compute_session_id(u_char *session_id___0 , u_char *cookie , BIGNUM *host_key_n ,
                        BIGNUM *session_key_n ) 
{ u_int host_key_bytes ;
  int tmp ;
  u_int session_key_bytes ;
  int tmp___0 ;
  u_int bytes ;
  u_char *buf___1 ;
  void *tmp___1 ;
  MD5_CTX md ;

  {
#line 32
  tmp = BN_num_bits((BIGNUM const   *)host_key_n);
#line 32
  host_key_bytes = (u_int )((tmp + 7) / 8);
#line 33
  tmp___0 = BN_num_bits((BIGNUM const   *)session_key_n);
#line 33
  session_key_bytes = (u_int )((tmp___0 + 7) / 8);
#line 34
  bytes = host_key_bytes + session_key_bytes;
#line 35
  tmp___1 = xmalloc(bytes);
#line 35
  buf___1 = (u_char *)tmp___1;
#line 38
  BN_bn2bin((BIGNUM const   *)host_key_n, buf___1);
#line 39
  BN_bn2bin((BIGNUM const   *)session_key_n, buf___1 + host_key_bytes);
#line 40
  MD5_Init(& md);
#line 41
  MD5_Update(& md, (void const   *)buf___1, bytes);
#line 42
  MD5_Update(& md, (void const   *)cookie, 8U);
#line 43
  MD5_Final((unsigned char *)session_id___0, & md);
#line 44
  memset((void *)buf___1, 0, bytes);
#line 45
  xfree((void *)buf___1);
#line 46
  return;
}
}
#line 1 "nchan.o"
#line 69 "nchan.c"
static void chan_send_ieof1(Channel *c ) ;
#line 70
static void chan_send_oclose1(Channel *c ) ;
#line 71
static void chan_send_close2(Channel *c ) ;
#line 72
static void chan_send_eof2(Channel *c ) ;
#line 75
static void chan_shutdown_write(Channel *c ) ;
#line 76
static void chan_shutdown_read(Channel *c ) ;
#line 78 "nchan.c"
static char *ostates[4]  = {      (char *)"open",      (char *)"drain",      (char *)"wait_ieof",      (char *)"closed"};
#line 79 "nchan.c"
static char *istates[4]  = {      (char *)"open",      (char *)"drain",      (char *)"wait_oclose",      (char *)"closed"};
#line 81 "nchan.c"
static void chan_set_istate(Channel *c , u_int next ) 
{ 

  {
#line 84
  if (c->istate > 3U) {
#line 85
    fatal("chan_set_istate: bad state %d -> %d", c->istate, next);
  } else {
#line 84
    if (next > 3U) {
#line 85
      fatal("chan_set_istate: bad state %d -> %d", c->istate, next);
    }
  }
#line 86
  debug("channel %d: input %s -> %s", c->self, istates[c->istate], istates[next]);
#line 88
  c->istate = next;
#line 89
  return;
}
}
#line 90 "nchan.c"
static void chan_set_ostate(Channel *c , u_int next ) 
{ 

  {
#line 93
  if (c->ostate > 3U) {
#line 94
    fatal("chan_set_ostate: bad state %d -> %d", c->ostate, next);
  } else {
#line 93
    if (next > 3U) {
#line 94
      fatal("chan_set_ostate: bad state %d -> %d", c->ostate, next);
    }
  }
#line 95
  debug("channel %d: output %s -> %s", c->self, ostates[c->ostate], ostates[next]);
#line 97
  c->ostate = next;
#line 98
  return;
}
}
#line 104 "nchan.c"
static void chan_rcvd_oclose1(Channel *c ) 
{ 

  {
#line 107
  debug("channel %d: rcvd oclose", c->self);
#line 108
  switch ((int )c->istate) {
  case 2: 
#line 110
  chan_set_istate(c, 3U);
#line 111
  break;
  case 0: 
#line 113
  chan_shutdown_read(c);
#line 114
  chan_send_ieof1(c);
#line 115
  chan_set_istate(c, 3U);
#line 116
  break;
  case 1: 
#line 119
  chan_send_ieof1(c);
#line 120
  chan_set_istate(c, 3U);
#line 121
  break;
  default: 
#line 123
  error("channel %d: protocol error: rcvd_oclose for istate %d", c->self, c->istate);
#line 125
  return;
  }
#line 127
  return;
}
}
#line 128 "nchan.c"
void chan_read_failed(Channel *c ) 
{ 

  {
#line 131
  debug("channel %d: read failed", c->self);
#line 132
  switch ((int )c->istate) {
  case 0: 
#line 134
  chan_shutdown_read(c);
#line 135
  chan_set_istate(c, 1U);
#line 136
  break;
  default: 
#line 138
  error("channel %d: chan_read_failed for istate %d", c->self, c->istate);
#line 140
  break;
  }
#line 142
  return;
}
}
#line 143 "nchan.c"
void chan_ibuf_empty(Channel *c ) 
{ u_int tmp ;

  {
#line 146
  debug("channel %d: ibuf empty", c->self);
#line 147
  tmp = buffer_len(& c->input);
#line 147
  if (tmp) {
#line 148
    error("channel %d: chan_ibuf_empty for non empty buffer", c->self);
#line 150
    return;
  }
#line 152
  switch ((int )c->istate) {
  case 1: 
#line 154
  if (compat20) {
#line 155
    if (! (c->flags & 1)) {
#line 156
      chan_send_eof2(c);
    }
#line 157
    chan_set_istate(c, 3U);
  } else {
#line 159
    chan_send_ieof1(c);
#line 160
    chan_set_istate(c, 2U);
  }
#line 162
  break;
  default: 
#line 164
  error("channel %d: chan_ibuf_empty for istate %d", c->self, c->istate);
#line 166
  break;
  }
#line 168
  return;
}
}
#line 169 "nchan.c"
static void chan_rcvd_ieof1(Channel *c ) 
{ 

  {
#line 172
  debug("channel %d: rcvd ieof", c->self);
#line 173
  switch ((int )c->ostate) {
  case 0: 
#line 175
  chan_set_ostate(c, 1U);
#line 176
  break;
  case 2: 
#line 178
  chan_set_ostate(c, 3U);
#line 179
  break;
  default: 
#line 181
  error("channel %d: protocol error: rcvd_ieof for ostate %d", c->self, c->ostate);
#line 183
  break;
  }
#line 185
  return;
}
}
#line 186 "nchan.c"
static void chan_write_failed1(Channel *c ) 
{ 

  {
#line 189
  debug("channel %d: write failed", c->self);
#line 190
  switch ((int )c->ostate) {
  case 0: 
#line 192
  chan_shutdown_write(c);
#line 193
  chan_send_oclose1(c);
#line 194
  chan_set_ostate(c, 2U);
#line 195
  break;
  case 1: 
#line 197
  chan_shutdown_write(c);
#line 198
  chan_send_oclose1(c);
#line 199
  chan_set_ostate(c, 3U);
#line 200
  break;
  default: 
#line 202
  error("channel %d: chan_write_failed for ostate %d", c->self, c->ostate);
#line 204
  break;
  }
#line 206
  return;
}
}
#line 207 "nchan.c"
void chan_obuf_empty(Channel *c ) 
{ u_int tmp ;

  {
#line 210
  debug("channel %d: obuf empty", c->self);
#line 211
  tmp = buffer_len(& c->output);
#line 211
  if (tmp) {
#line 212
    error("channel %d: chan_obuf_empty for non empty buffer", c->self);
#line 214
    return;
  }
#line 216
  switch ((int )c->ostate) {
  case 1: 
#line 218
  chan_shutdown_write(c);
#line 219
  if (! compat20) {
#line 220
    chan_send_oclose1(c);
  }
#line 221
  chan_set_ostate(c, 3U);
#line 222
  break;
  default: 
#line 224
  error("channel %d: internal error: obuf_empty for ostate %d", c->self, c->ostate);
#line 226
  break;
  }
#line 228
  return;
}
}
#line 229 "nchan.c"
static void chan_send_ieof1(Channel *c ) 
{ 

  {
#line 232
  debug("channel %d: send ieof", c->self);
#line 233
  switch ((int )c->istate) {
  case 0: 
  case 1: 
#line 236
  packet_start((unsigned char)24);
#line 237
  packet_put_int((unsigned int )c->remote_id);
#line 238
  packet_send();
#line 239
  break;
  default: 
#line 241
  error("channel %d: cannot send ieof for istate %d", c->self, c->istate);
#line 243
  break;
  }
#line 245
  return;
}
}
#line 246 "nchan.c"
static void chan_send_oclose1(Channel *c ) 
{ 

  {
#line 249
  debug("channel %d: send oclose", c->self);
#line 250
  switch ((int )c->ostate) {
  case 0: 
  case 1: 
#line 253
  buffer_clear(& c->output);
#line 254
  packet_start((unsigned char)25);
#line 255
  packet_put_int((unsigned int )c->remote_id);
#line 256
  packet_send();
#line 257
  break;
  default: 
#line 259
  error("channel %d: cannot send oclose for ostate %d", c->self, c->ostate);
#line 261
  break;
  }
#line 263
  return;
}
}
#line 268 "nchan.c"
static void chan_rcvd_close2(Channel *c ) 
{ 

  {
#line 271
  debug("channel %d: rcvd close", c->self);
#line 272
  if (c->flags & 2) {
#line 273
    error("channel %d: protocol error: close rcvd twice", c->self);
  }
#line 274
  c->flags |= 2;
#line 275
  if (c->type == 10) {
#line 277
    chan_set_ostate(c, 3U);
#line 278
    chan_set_istate(c, 3U);
#line 279
    return;
  }
#line 281
  switch ((int )c->ostate) {
  case 0: 
#line 287
  chan_set_ostate(c, 1U);
#line 288
  break;
  }
#line 290
  switch ((int )c->istate) {
  case 0: 
#line 292
  chan_shutdown_read(c);
#line 293
  chan_set_istate(c, 3U);
#line 294
  break;
  case 1: 
#line 296
  chan_send_eof2(c);
#line 297
  chan_set_istate(c, 3U);
#line 298
  break;
  }
#line 300
  return;
}
}
#line 301 "nchan.c"
static void chan_rcvd_eof2(Channel *c ) 
{ 

  {
#line 304
  debug("channel %d: rcvd eof", c->self);
#line 305
  c->flags |= 8;
#line 306
  if (c->ostate == 0U) {
#line 307
    chan_set_ostate(c, 1U);
  }
#line 308
  return;
}
}
#line 309 "nchan.c"
static void chan_write_failed2(Channel *c ) 
{ 

  {
#line 312
  debug("channel %d: write failed", c->self);
#line 313
  switch ((int )c->ostate) {
  case 0: 
  case 1: 
#line 316
  chan_shutdown_write(c);
#line 317
  chan_set_ostate(c, 3U);
#line 318
  break;
  default: 
#line 320
  error("channel %d: chan_write_failed for ostate %d", c->self, c->ostate);
#line 322
  break;
  }
#line 324
  return;
}
}
#line 325 "nchan.c"
static void chan_send_eof2(Channel *c ) 
{ 

  {
#line 328
  debug("channel %d: send eof", c->self);
#line 329
  switch ((int )c->istate) {
  case 1: 
#line 331
  packet_start((unsigned char)96);
#line 332
  packet_put_int((unsigned int )c->remote_id);
#line 333
  packet_send();
#line 334
  c->flags |= 4;
#line 335
  break;
  default: 
#line 337
  error("channel %d: cannot send eof for istate %d", c->self, c->istate);
#line 339
  break;
  }
#line 341
  return;
}
}
#line 342 "nchan.c"
static void chan_send_close2(Channel *c ) 
{ 

  {
#line 345
  debug("channel %d: send close", c->self);
#line 346
  if (c->ostate != 3U) {
#line 348
    error("channel %d: cannot send close for istate/ostate %d/%d", c->self, c->istate,
          c->ostate);
  } else {
#line 346
    if (c->istate != 3U) {
#line 348
      error("channel %d: cannot send close for istate/ostate %d/%d", c->self, c->istate,
            c->ostate);
    } else {
#line 350
      if (c->flags & 1) {
#line 351
        error("channel %d: already sent close", c->self);
      } else {
#line 353
        packet_start((unsigned char)97);
#line 354
        packet_put_int((unsigned int )c->remote_id);
#line 355
        packet_send();
#line 356
        c->flags |= 1;
      }
    }
  }
#line 358
  return;
}
}
#line 362 "nchan.c"
void chan_rcvd_ieof(Channel *c ) 
{ u_int tmp ;
  u_int tmp___0 ;

  {
#line 365
  if (compat20) {
#line 366
    chan_rcvd_eof2(c);
  } else {
#line 368
    chan_rcvd_ieof1(c);
  }
#line 369
  if (c->ostate == 1U) {
#line 369
    tmp = buffer_len(& c->output);
#line 369
    if (tmp == 0U) {
#line 369
      if (compat20) {
#line 369
        if (c->extended_usage == 2) {
#line 369
          if (c->efd != -1) {
#line 369
            if (! (! (c->flags & 10))) {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 369
            tmp___0 = buffer_len(& c->extended);
#line 369
            if (! (tmp___0 > 0U)) {
#line 372
              chan_obuf_empty(c);
            }
          }
        } else {
#line 372
          chan_obuf_empty(c);
        }
      } else {
#line 372
        chan_obuf_empty(c);
      }
    }
  }
#line 373
  return;
}
}
#line 374 "nchan.c"
void chan_rcvd_oclose(Channel *c ) 
{ 

  {
#line 377
  if (compat20) {
#line 378
    chan_rcvd_close2(c);
  } else {
#line 380
    chan_rcvd_oclose1(c);
  }
#line 381
  return;
}
}
#line 382 "nchan.c"
void chan_write_failed(Channel *c ) 
{ 

  {
#line 385
  if (compat20) {
#line 386
    chan_write_failed2(c);
  } else {
#line 388
    chan_write_failed1(c);
  }
#line 389
  return;
}
}
#line 391 "nchan.c"
void chan_mark_dead(Channel *c ) 
{ 

  {
#line 394
  c->type = 14;
#line 395
  return;
}
}
#line 397 "nchan.c"
int chan_is_dead(Channel *c , int send___0 ) 
{ u_int tmp ;
  u_int tmp___0 ;

  {
#line 400
  if (c->type == 14) {
#line 401
    debug("channel %d: zombie", c->self);
#line 402
    return (1);
  }
#line 404
  if (c->istate != 3U) {
#line 405
    return (0);
  } else {
#line 404
    if (c->ostate != 3U) {
#line 405
      return (0);
    }
  }
#line 406
  if (! compat20) {
#line 407
    debug("channel %d: is dead", c->self);
#line 408
    return (1);
  }
#line 410
  if (datafellows & 2097152) {
#line 410
    if (c->extended_usage == 2) {
#line 410
      if (c->efd != -1) {
#line 410
        tmp___0 = buffer_len(& c->extended);
#line 410
        if (tmp___0 > 0U) {
#line 414
          tmp = buffer_len(& c->extended);
#line 414
          debug2("channel %d: active efd: %d len %d", c->self, c->efd, tmp);
#line 416
          return (0);
        }
      }
    }
  }
#line 418
  if (! (c->flags & 1)) {
#line 419
    if (send___0) {
#line 420
      chan_send_close2(c);
    } else {
#line 423
      if (c->flags & 2) {
#line 424
        debug("channel %d: almost dead", c->self);
#line 426
        return (1);
      }
    }
  }
#line 430
  if (c->flags & 1) {
#line 430
    if (c->flags & 2) {
#line 432
      debug("channel %d: is dead", c->self);
#line 433
      return (1);
    }
  }
#line 435
  return (0);
}
}
#line 439 "nchan.c"
static void chan_shutdown_write(Channel *c ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 442
  buffer_clear(& c->output);
#line 443
  if (compat20) {
#line 443
    if (c->type == 10) {
#line 444
      return;
    }
  }
#line 446
  debug("channel %d: close_write", c->self);
#line 447
  if (c->sock != -1) {
#line 448
    tmp___1 = shutdown(c->sock, 1);
#line 448
    if (tmp___1 < 0) {
#line 449
      tmp = __errno_location();
#line 449
      tmp___0 = strerror(*tmp);
#line 449
      debug("channel %d: chan_shutdown_write: shutdown() failed for fd%d: %.100s",
            c->self, c->sock, tmp___0);
    }
  } else {
#line 453
    tmp___4 = channel_close_fd(& c->wfd);
#line 453
    if (tmp___4 < 0) {
#line 454
      tmp___2 = __errno_location();
#line 454
      tmp___3 = strerror(*tmp___2);
#line 454
      log("channel %d: chan_shutdown_write: close() failed for fd%d: %.100s", c->self,
          c->wfd, tmp___3);
    }
  }
#line 458
  return;
}
}
#line 459 "nchan.c"
static void chan_shutdown_read(Channel *c ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 462
  if (compat20) {
#line 462
    if (c->type == 10) {
#line 463
      return;
    }
  }
#line 464
  debug("channel %d: close_read", c->self);
#line 465
  if (c->sock != -1) {
#line 471
    tmp___1 = shutdown(c->sock, 0);
#line 471
    if (tmp___1 < 0) {
#line 471
      tmp___2 = __errno_location();
#line 471
      if (*tmp___2 != 107) {
#line 473
        tmp = __errno_location();
#line 473
        tmp___0 = strerror(*tmp);
#line 473
        error("channel %d: chan_shutdown_read: shutdown() failed for fd%d [i%d o%d]: %.100s",
              c->self, c->sock, c->istate, c->ostate, tmp___0);
      }
    }
  } else {
#line 478
    tmp___5 = channel_close_fd(& c->rfd);
#line 478
    if (tmp___5 < 0) {
#line 479
      tmp___3 = __errno_location();
#line 479
      tmp___4 = strerror(*tmp___3);
#line 479
      log("channel %d: chan_shutdown_read: close() failed for fd%d: %.100s", c->self,
          c->rfd, tmp___4);
    }
  }
#line 483
  return;
}
}
#line 1 "packet.o"
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 21 "packet.h"
void packet_set_connection(int fd_in , int fd_out ) ;
#line 22
void packet_set_nonblocking(void) ;
#line 24
int packet_get_connection_out(void) ;
#line 25
void packet_close(void) ;
#line 26
void packet_set_encryption_key(u_char const   *key , u_int keylen , int number ) ;
#line 27
u_int packet_get_encryption_key(u_char *key ) ;
#line 28
void packet_set_protocol_flags(u_int protocol_flags ) ;
#line 30
void packet_start_compression(int level ) ;
#line 31
void packet_set_interactive(int interactive ) ;
#line 37
void packet_put_bignum(BIGNUM *value ) ;
#line 46
int packet_read_poll(void) ;
#line 47
void packet_process_incoming(char const   *buf___1 , u_int len ) ;
#line 53
void packet_get_bignum(BIGNUM *value ) ;
#line 58
void ( /* format attribute */  packet_send_debug)(char const   *fmt  , ...) ;
#line 60
void set_newkeys(int mode ) ;
#line 61
int packet_get_keyiv_len(int mode ) ;
#line 62
void packet_get_keyiv(int mode , u_char *iv , u_int len ) ;
#line 63
int packet_get_keycontext(int mode , u_char *dat ) ;
#line 64
void packet_set_keycontext(int mode , u_char *dat ) ;
#line 65
u_int32_t packet_get_seqnr(int mode ) ;
#line 66
void packet_set_seqnr(int mode , u_int32_t seqnr ) ;
#line 67
int packet_get_ssh1_cipher(void) ;
#line 68
void packet_set_iv(int mode , u_char *dat ) ;
#line 70
void packet_write_poll(void) ;
#line 72
int packet_have_data_to_write(void) ;
#line 73
int packet_not_very_much_data_to_write(void) ;
#line 76
int packet_connection_is_ipv4(void) ;
#line 79
void packet_add_padding(u_char pad ) ;
#line 85
int packet_set_maxsize(int s ) ;
#line 77 "packet.c"
static int connection_in  =    -1;
#line 78 "packet.c"
static int connection_out  =    -1;
#line 81 "packet.c"
static u_int remote_protocol_flags  =    (u_int )0;
#line 84 "packet.c"
static CipherContext receive_context  ;
#line 87 "packet.c"
static CipherContext send_context  ;
#line 90 "packet.c"
Buffer input  ;
#line 93 "packet.c"
Buffer output  ;
#line 96 "packet.c"
static Buffer outgoing_packet  ;
#line 99 "packet.c"
static Buffer incoming_packet  ;
#line 102 "packet.c"
static Buffer compression_buffer  ;
#line 103 "packet.c"
static int compression_buffer_ready  =    0;
#line 106 "packet.c"
static int packet_compression  =    0;
#line 109 "packet.c"
int max_packet_size  =    32768;
#line 112 "packet.c"
static int initialized  =    0;
#line 115 "packet.c"
static int interactive_mode  =    0;
#line 118 "packet.c"
Newkeys *newkeys[2]  ;
#line 119 "packet.c"
static u_int32_t read_seqnr  =    (u_int32_t )0;
#line 120 "packet.c"
static u_int32_t send_seqnr  =    (u_int32_t )0;
#line 123 "packet.c"
static u_char ssh1_key[32]  ;
#line 124 "packet.c"
static u_int ssh1_keylen  ;
#line 127 "packet.c"
static u_char extra_pad  =    (u_char )0;
#line 133 "packet.c"
void packet_set_connection(int fd_in , int fd_out ) 
{ Cipher *none ;
  Cipher *tmp ;

  {
#line 136
  tmp = cipher_by_name("none");
#line 136
  none = tmp;
#line 137
  if ((unsigned int )none == (unsigned int )((void *)0)) {
#line 138
    fatal("packet_set_connection: cannot load cipher \'none\'");
  }
#line 139
  connection_in = fd_in;
#line 140
  connection_out = fd_out;
#line 141
  cipher_init(& send_context, none, (u_char const   *)"", 0U, (u_char const   *)((void *)0),
              0U, 1);
#line 142
  cipher_init(& receive_context, none, (u_char const   *)"", 0U, (u_char const   *)((void *)0),
              0U, 0);
#line 143
  newkeys[1] = (Newkeys *)((void *)0);
#line 143
  newkeys[0] = newkeys[1];
#line 144
  if (! initialized) {
#line 145
    initialized = 1;
#line 146
    buffer_init(& input);
#line 147
    buffer_init(& output);
#line 148
    buffer_init(& outgoing_packet);
#line 149
    buffer_init(& incoming_packet);
  }
#line 152
  fatal_add_cleanup((void (*)(void * ))(& packet_close), (void *)0);
#line 153
  return;
}
}
#line 157 "packet.c"
int packet_connection_is_on_socket(void) 
{ struct sockaddr_storage from ;
  struct sockaddr_storage to ;
  socklen_t fromlen ;
  socklen_t tolen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 164
  if (connection_in == connection_out) {
#line 165
    return (1);
  }
#line 166
  fromlen = sizeof(from);
#line 167
  memset((void *)(& from), 0, sizeof(from));
#line 168
  tmp = getpeername(connection_in, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                    (socklen_t * __restrict  )(& fromlen));
#line 168
  if (tmp < 0) {
#line 169
    return (0);
  }
#line 170
  tolen = sizeof(to);
#line 171
  memset((void *)(& to), 0, sizeof(to));
#line 172
  tmp___0 = getpeername(connection_out, (struct sockaddr * __restrict  )((struct sockaddr *)(& to)),
                        (socklen_t * __restrict  )(& tolen));
#line 172
  if (tmp___0 < 0) {
#line 173
    return (0);
  }
#line 174
  if (fromlen != tolen) {
#line 175
    return (0);
  } else {
#line 174
    tmp___1 = memcmp((void const   *)(& from), (void const   *)(& to), fromlen);
#line 174
    if (tmp___1 != 0) {
#line 175
      return (0);
    }
  }
#line 176
  if ((int )from.ss_family != 2) {
#line 176
    if ((int )from.ss_family != 10) {
#line 177
      return (0);
    }
  }
#line 178
  return (1);
}
}
#line 187 "packet.c"
void packet_get_keyiv(int mode , u_char *iv , u_int len ) 
{ CipherContext *cc ;

  {
#line 192
  if (mode == 1) {
#line 193
    cc = & send_context;
  } else {
#line 195
    cc = & receive_context;
  }
#line 197
  cipher_get_keyiv(cc, iv, len);
#line 198
  return;
}
}
#line 200 "packet.c"
int packet_get_keycontext(int mode , u_char *dat ) 
{ CipherContext *cc ;
  int tmp ;

  {
#line 205
  if (mode == 1) {
#line 206
    cc = & send_context;
  } else {
#line 208
    cc = & receive_context;
  }
#line 210
  tmp = cipher_get_keycontext(cc, dat);
#line 210
  return (tmp);
}
}
#line 213 "packet.c"
void packet_set_keycontext(int mode , u_char *dat ) 
{ CipherContext *cc ;

  {
#line 218
  if (mode == 1) {
#line 219
    cc = & send_context;
  } else {
#line 221
    cc = & receive_context;
  }
#line 223
  cipher_set_keycontext(cc, dat);
#line 224
  return;
}
}
#line 226 "packet.c"
int packet_get_keyiv_len(int mode ) 
{ CipherContext *cc ;
  int tmp ;

  {
#line 231
  if (mode == 1) {
#line 232
    cc = & send_context;
  } else {
#line 234
    cc = & receive_context;
  }
#line 236
  tmp = cipher_get_keyiv_len(cc);
#line 236
  return (tmp);
}
}
#line 238 "packet.c"
void packet_set_iv(int mode , u_char *dat ) 
{ CipherContext *cc ;

  {
#line 243
  if (mode == 1) {
#line 244
    cc = & send_context;
  } else {
#line 246
    cc = & receive_context;
  }
#line 248
  cipher_set_keyiv(cc, dat);
#line 249
  return;
}
}
#line 250 "packet.c"
int packet_get_ssh1_cipher(void) 
{ u_int tmp ;

  {
#line 253
  tmp = cipher_get_number(receive_context.cipher);
#line 253
  return ((int )tmp);
}
}
#line 257 "packet.c"
u_int32_t packet_get_seqnr(int mode ) 
{ u_int32_t tmp ;

  {
#line 260
  if (mode == 0) {
#line 260
    tmp = read_seqnr;
  } else {
#line 260
    tmp = send_seqnr;
  }
#line 260
  return (tmp);
}
}
#line 263 "packet.c"
void packet_set_seqnr(int mode , u_int32_t seqnr ) 
{ 

  {
#line 266
  if (mode == 0) {
#line 267
    read_seqnr = seqnr;
  } else {
#line 268
    if (mode == 1) {
#line 269
      send_seqnr = seqnr;
    } else {
#line 271
      fatal("packet_set_seqnr: bad mode %d", mode);
    }
  }
#line 272
  return;
}
}
#line 276 "packet.c"
int packet_connection_is_ipv4(void) 
{ struct sockaddr_storage to ;
  socklen_t tolen ;
  int tmp ;
  register unsigned int __v ;
  register unsigned int __x ;

  {
#line 280
  tolen = sizeof(to);
#line 282
  memset((void *)(& to), 0, sizeof(to));
#line 283
  tmp = getsockname(connection_out, (struct sockaddr * __restrict  )((struct sockaddr *)(& to)),
                    (socklen_t * __restrict  )(& tolen));
#line 283
  if (tmp < 0) {
#line 284
    return (0);
  }
#line 285
  if ((int )to.ss_family == 2) {
#line 286
    return (1);
  }
#line 289
  if ((int )to.ss_family == 10) {
#line 289
    if (*((uint32_t const   *)(& ((struct sockaddr_in6 *)(& to))->sin6_addr) + 0) == 0U) {
#line 289
      if (*((uint32_t const   *)(& ((struct sockaddr_in6 *)(& to))->sin6_addr) + 1) == 0U) {
#line 289
        __x = 65535U;
#line 289
        __asm__  ("rorw $8, %w0;"
                  "rorl $16, %0;"
                  "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 289
        if (*((uint32_t const   *)(& ((struct sockaddr_in6 *)(& to))->sin6_addr) + 2) == (uint32_t const   )__v) {
#line 290
          return (1);
        }
      }
    }
  }
#line 292
  return (0);
}
}
#line 297 "packet.c"
void packet_set_nonblocking(void) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 301
  tmp___1 = fcntl(connection_in, 4, 2048);
#line 301
  if (tmp___1 < 0) {
#line 302
    tmp = __errno_location();
#line 302
    tmp___0 = strerror(*tmp);
#line 302
    error("fcntl O_NONBLOCK: %.100s", tmp___0);
  }
#line 304
  if (connection_out != connection_in) {
#line 305
    tmp___4 = fcntl(connection_out, 4, 2048);
#line 305
    if (tmp___4 < 0) {
#line 306
      tmp___2 = __errno_location();
#line 306
      tmp___3 = strerror(*tmp___2);
#line 306
      error("fcntl O_NONBLOCK: %.100s", tmp___3);
    }
  }
#line 308
  return;
}
}
#line 312 "packet.c"
int packet_get_connection_in(void) 
{ 

  {
#line 315
  return (connection_in);
}
}
#line 320 "packet.c"
int packet_get_connection_out(void) 
{ 

  {
#line 323
  return (connection_out);
}
}
#line 328 "packet.c"
void packet_close(void) 
{ 

  {
#line 331
  if (! initialized) {
#line 332
    return;
  }
#line 333
  initialized = 0;
#line 334
  if (connection_in == connection_out) {
#line 335
    shutdown(connection_out, 2);
#line 336
    close(connection_out);
  } else {
#line 338
    close(connection_in);
#line 339
    close(connection_out);
  }
#line 341
  buffer_free(& input);
#line 342
  buffer_free(& output);
#line 343
  buffer_free(& outgoing_packet);
#line 344
  buffer_free(& incoming_packet);
#line 345
  if (compression_buffer_ready) {
#line 346
    buffer_free(& compression_buffer);
#line 347
    buffer_compress_uninit();
  }
#line 349
  cipher_cleanup(& send_context);
#line 350
  cipher_cleanup(& receive_context);
#line 351
  return;
}
}
#line 355 "packet.c"
void packet_set_protocol_flags(u_int protocol_flags ) 
{ 

  {
#line 358
  remote_protocol_flags = protocol_flags;
#line 359
  return;
}
}
#line 363 "packet.c"
u_int packet_get_protocol_flags(void) 
{ 

  {
#line 366
  return (remote_protocol_flags);
}
}
#line 374 "packet.c"
static void packet_init_compression(void) 
{ 

  {
#line 377
  if (compression_buffer_ready == 1) {
#line 378
    return;
  }
#line 379
  compression_buffer_ready = 1;
#line 380
  buffer_init(& compression_buffer);
#line 381
  return;
}
}
#line 383 "packet.c"
void packet_start_compression(int level ) 
{ 

  {
#line 386
  if (packet_compression) {
#line 386
    if (! compat20) {
#line 387
      fatal("Compression already enabled.");
    }
  }
#line 388
  packet_compression = 1;
#line 389
  packet_init_compression();
#line 390
  buffer_compress_init_send(level);
#line 391
  buffer_compress_init_recv();
#line 392
  return;
}
}
#line 400 "packet.c"
void packet_set_encryption_key(u_char const   *key , u_int keylen , int number ) 
{ Cipher *cipher ;
  Cipher *tmp ;

  {
#line 404
  tmp = cipher_by_number(number);
#line 404
  cipher = tmp;
#line 405
  if ((unsigned int )cipher == (unsigned int )((void *)0)) {
#line 406
    fatal("packet_set_encryption_key: unknown cipher number %d", number);
  }
#line 407
  if (keylen < 20U) {
#line 408
    fatal("packet_set_encryption_key: keylen too small: %d", keylen);
  }
#line 409
  if (keylen > 32U) {
#line 410
    fatal("packet_set_encryption_key: keylen too big: %d", keylen);
  }
#line 411
  memcpy((void * __restrict  )(ssh1_key), (void const   * __restrict  )key, keylen);
#line 412
  ssh1_keylen = keylen;
#line 413
  cipher_init(& send_context, cipher, key, keylen, (u_char const   *)((void *)0),
              0U, 1);
#line 414
  cipher_init(& receive_context, cipher, key, keylen, (u_char const   *)((void *)0),
              0U, 0);
#line 415
  return;
}
}
#line 417 "packet.c"
u_int packet_get_encryption_key(u_char *key ) 
{ 

  {
#line 420
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 421
    return (ssh1_keylen);
  }
#line 422
  memcpy((void * __restrict  )key, (void const   * __restrict  )(ssh1_key), ssh1_keylen);
#line 423
  return (ssh1_keylen);
}
}
#line 427 "packet.c"
void packet_start(u_char type ) 
{ u_char buf___1[9] ;
  int len ;

  {
#line 434
  if (compat20) {
#line 434
    len = 6;
  } else {
#line 434
    len = 9;
  }
#line 435
  memset((void *)(buf___1), 0, (unsigned int )(len - 1));
#line 436
  buf___1[len - 1] = type;
#line 437
  buffer_clear(& outgoing_packet);
#line 438
  buffer_append(& outgoing_packet, (void const   *)(buf___1), (unsigned int )len);
#line 439
  return;
}
}
#line 442 "packet.c"
void packet_put_char(int value ) 
{ char ch ;

  {
#line 445
  ch = (char )value;
#line 446
  buffer_append(& outgoing_packet, (void const   *)(& ch), 1U);
#line 447
  return;
}
}
#line 448 "packet.c"
void packet_put_int(u_int value ) 
{ 

  {
#line 451
  buffer_put_int(& outgoing_packet, value);
#line 452
  return;
}
}
#line 453 "packet.c"
void packet_put_string(void const   *buf___1 , u_int len ) 
{ 

  {
#line 456
  buffer_put_string(& outgoing_packet, buf___1, len);
#line 457
  return;
}
}
#line 458 "packet.c"
void packet_put_cstring(char const   *str ) 
{ 

  {
#line 461
  buffer_put_cstring(& outgoing_packet, str);
#line 462
  return;
}
}
#line 463 "packet.c"
void packet_put_raw(void const   *buf___1 , u_int len ) 
{ 

  {
#line 466
  buffer_append(& outgoing_packet, buf___1, len);
#line 467
  return;
}
}
#line 468 "packet.c"
void packet_put_bignum(BIGNUM *value ) 
{ 

  {
#line 471
  buffer_put_bignum(& outgoing_packet, value);
#line 472
  return;
}
}
#line 473 "packet.c"
void packet_put_bignum2(BIGNUM *value ) 
{ 

  {
#line 476
  buffer_put_bignum2(& outgoing_packet, value);
#line 477
  return;
}
}
#line 484 "packet.c"
static void packet_send1(void) 
{ u_char buf___1[8] ;
  u_char *cp ;
  int i ;
  int padding ;
  int len ;
  u_int checksum ;
  u_int32_t rand___0 ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  u_int tmp___3 ;
  void *tmp___4 ;
  u_int tmp___5 ;
  void *tmp___6 ;
  u_int tmp___7 ;
  void *tmp___8 ;

  {
#line 490
  rand___0 = (u_int32_t )0;
#line 496
  if (packet_compression) {
#line 497
    buffer_clear(& compression_buffer);
#line 499
    buffer_consume(& outgoing_packet, 8U);
#line 501
    buffer_append(& compression_buffer, (void const   *)"\000\000\000\000\000\000\000\000",
                  8U);
#line 502
    buffer_compress(& outgoing_packet, & compression_buffer);
#line 503
    buffer_clear(& outgoing_packet);
#line 504
    tmp = buffer_len(& compression_buffer);
#line 504
    tmp___0 = buffer_ptr(& compression_buffer);
#line 504
    buffer_append(& outgoing_packet, (void const   *)tmp___0, tmp);
  }
#line 508
  tmp___1 = buffer_len(& outgoing_packet);
#line 508
  len = (int )((tmp___1 + 4U) - 8U);
#line 511
  padding = 8 - len % 8;
#line 512
  if (! send_context.plaintext) {
#line 513
    tmp___2 = buffer_ptr(& outgoing_packet);
#line 513
    cp = (u_char *)tmp___2;
#line 514
    i = 0;
#line 514
    while (i < padding) {
#line 515
      if (i % 4 == 0) {
#line 516
        rand___0 = arc4random();
      }
#line 517
      *(cp + (7 - i)) = (unsigned char )(rand___0 & 255U);
#line 518
      rand___0 >>= 8;
#line 514
      i ++;
    }
  }
#line 521
  buffer_consume(& outgoing_packet, (unsigned int )(8 - padding));
#line 524
  tmp___3 = buffer_len(& outgoing_packet);
#line 524
  tmp___4 = buffer_ptr(& outgoing_packet);
#line 524
  checksum = ssh_crc32((u_char const   *)tmp___4, tmp___3);
#line 526
  while (1) {
#line 526
    buf___1[0] = (unsigned char )(checksum >> 24);
#line 526
    buf___1[1] = (unsigned char )(checksum >> 16);
#line 526
    buf___1[2] = (unsigned char )(checksum >> 8);
#line 526
    buf___1[3] = (unsigned char )checksum;
#line 526
    break;
  }
#line 527
  buffer_append(& outgoing_packet, (void const   *)(buf___1), 4U);
#line 535
  while (1) {
#line 535
    buf___1[0] = (unsigned char )(len >> 24);
#line 535
    buf___1[1] = (unsigned char )(len >> 16);
#line 535
    buf___1[2] = (unsigned char )(len >> 8);
#line 535
    buf___1[3] = (unsigned char )len;
#line 535
    break;
  }
#line 536
  buffer_append(& output, (void const   *)(buf___1), 4U);
#line 537
  tmp___5 = buffer_len(& outgoing_packet);
#line 537
  tmp___6 = buffer_append_space(& output, tmp___5);
#line 537
  cp = (u_char *)tmp___6;
#line 538
  tmp___7 = buffer_len(& outgoing_packet);
#line 538
  tmp___8 = buffer_ptr(& outgoing_packet);
#line 538
  cipher_crypt(& send_context, cp, (u_char const   *)tmp___8, tmp___7);
#line 546
  buffer_clear(& outgoing_packet);
#line 553
  return;
}
}
#line 555 "packet.c"
void set_newkeys(int mode ) 
{ Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  CipherContext *cc ;
  int encrypt ;

  {
#line 564
  debug("newkeys: mode %d", mode);
#line 566
  if (mode == 1) {
#line 567
    cc = & send_context;
#line 568
    encrypt = 1;
  } else {
#line 570
    cc = & receive_context;
#line 571
    encrypt = 0;
  }
#line 573
  if ((unsigned int )newkeys[mode] != (unsigned int )((void *)0)) {
#line 574
    debug("newkeys: rekeying");
#line 575
    cipher_cleanup(cc);
#line 576
    enc = & (newkeys[mode])->enc;
#line 577
    mac = & (newkeys[mode])->mac;
#line 578
    comp = & (newkeys[mode])->comp;
#line 579
    memset((void *)mac->key, 0, (unsigned int )mac->key_len);
#line 580
    xfree((void *)enc->name);
#line 581
    xfree((void *)enc->iv);
#line 582
    xfree((void *)enc->key);
#line 583
    xfree((void *)mac->name);
#line 584
    xfree((void *)mac->key);
#line 585
    xfree((void *)comp->name);
#line 586
    xfree((void *)newkeys[mode]);
  }
#line 588
  newkeys[mode] = kex_get_newkeys(mode);
#line 589
  if ((unsigned int )newkeys[mode] == (unsigned int )((void *)0)) {
#line 590
    fatal("newkeys: no keys for mode %d", mode);
  }
#line 591
  enc = & (newkeys[mode])->enc;
#line 592
  mac = & (newkeys[mode])->mac;
#line 593
  comp = & (newkeys[mode])->comp;
#line 594
  if ((unsigned int )mac->md != (unsigned int )((void *)0)) {
#line 595
    mac->enabled = 1;
  }
#line 597
  cipher_init(cc, enc->cipher, (u_char const   *)enc->key, enc->key_len, (u_char const   *)enc->iv,
              enc->block_size, encrypt);
#line 602
  if (comp->type != 0) {
#line 602
    if (comp->enabled == 0) {
#line 603
      packet_init_compression();
#line 604
      if (mode == 1) {
#line 605
        buffer_compress_init_send(6);
      } else {
#line 607
        buffer_compress_init_recv();
      }
#line 608
      comp->enabled = 1;
    }
  }
#line 610
  return;
}
}
#line 615 "packet.c"
static void packet_send2(void) 
{ u_char type ;
  u_char *cp ;
  u_char *macbuf ;
  u_char padlen ;
  u_char pad ;
  u_int packet_length___0 ;
  u_int i ;
  u_int len ;
  u_int32_t rand___0 ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  int block_size ;
  void *tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  u_int tmp___3 ;
  void *tmp___4 ;
  u_int tmp___5 ;
  void *tmp___6 ;
  u_int tmp___7 ;
  void *tmp___8 ;
  u_int tmp___9 ;
  void *tmp___10 ;

  {
#line 618
  macbuf = (u_char *)((void *)0);
#line 620
  packet_length___0 = (u_int )0;
#line 622
  rand___0 = (u_int32_t )0;
#line 623
  enc = (Enc *)((void *)0);
#line 624
  mac = (Mac *)((void *)0);
#line 625
  comp = (Comp *)((void *)0);
#line 628
  if ((unsigned int )newkeys[1] != (unsigned int )((void *)0)) {
#line 629
    enc = & (newkeys[1])->enc;
#line 630
    mac = & (newkeys[1])->mac;
#line 631
    comp = & (newkeys[1])->comp;
  }
#line 633
  if (enc) {
#line 633
    block_size = (int )enc->block_size;
  } else {
#line 633
    block_size = 8;
  }
#line 635
  tmp = buffer_ptr(& outgoing_packet);
#line 635
  cp = (u_char *)tmp;
#line 636
  type = *(cp + 5);
#line 643
  if (comp) {
#line 643
    if (comp->enabled) {
#line 644
      len = buffer_len(& outgoing_packet);
#line 646
      buffer_consume(& outgoing_packet, 5U);
#line 647
      buffer_clear(& compression_buffer);
#line 648
      buffer_compress(& outgoing_packet, & compression_buffer);
#line 649
      buffer_clear(& outgoing_packet);
#line 650
      buffer_append(& outgoing_packet, (void const   *)"\000\000\000\000\000", 5U);
#line 651
      tmp___0 = buffer_len(& compression_buffer);
#line 651
      tmp___1 = buffer_ptr(& compression_buffer);
#line 651
      buffer_append(& outgoing_packet, (void const   *)tmp___1, tmp___0);
    }
  }
#line 658
  len = buffer_len(& outgoing_packet);
#line 664
  padlen = (unsigned char )((unsigned int )block_size - len % (unsigned int )block_size);
#line 665
  if ((int )padlen < 4) {
#line 666
    padlen = (unsigned char )((int )padlen + block_size);
  }
#line 667
  if (extra_pad) {
#line 669
    extra_pad = (unsigned char )((((int )extra_pad + (block_size - 1)) / block_size) * block_size);
#line 670
    pad = (unsigned char )((unsigned int )extra_pad - (len + (u_int )padlen) % (unsigned int )extra_pad);
#line 671
    debug3("packet_send2: adding %d (len %d padlen %d extra_pad %d)", pad, len, padlen,
           extra_pad);
#line 673
    padlen = (unsigned char )((int )padlen + (int )pad);
#line 674
    extra_pad = (unsigned char)0;
  }
#line 676
  tmp___2 = buffer_append_space(& outgoing_packet, (unsigned int )padlen);
#line 676
  cp = (u_char *)tmp___2;
#line 677
  if (enc) {
#line 677
    if (! send_context.plaintext) {
#line 679
      i = 0U;
#line 679
      while (i < (u_int )padlen) {
#line 680
        if (i % 4U == 0U) {
#line 681
          rand___0 = arc4random();
        }
#line 682
        *(cp + i) = (unsigned char )(rand___0 & 255U);
#line 683
        rand___0 >>= 8;
#line 679
        i ++;
      }
    } else {
#line 687
      memset((void *)cp, 0, (unsigned int )padlen);
    }
  } else {
#line 687
    memset((void *)cp, 0, (unsigned int )padlen);
  }
#line 690
  tmp___3 = buffer_len(& outgoing_packet);
#line 690
  packet_length___0 = tmp___3 - 4U;
#line 691
  tmp___4 = buffer_ptr(& outgoing_packet);
#line 691
  cp = (u_char *)tmp___4;
#line 692
  while (1) {
#line 692
    *(cp + 0) = (unsigned char )(packet_length___0 >> 24);
#line 692
    *(cp + 1) = (unsigned char )(packet_length___0 >> 16);
#line 692
    *(cp + 2) = (unsigned char )(packet_length___0 >> 8);
#line 692
    *(cp + 3) = (unsigned char )packet_length___0;
#line 692
    break;
  }
#line 693
  *(cp + 4) = padlen;
#line 697
  if (mac) {
#line 697
    if (mac->enabled) {
#line 698
      tmp___5 = buffer_len(& outgoing_packet);
#line 698
      tmp___6 = buffer_ptr(& outgoing_packet);
#line 698
      macbuf = mac_compute(mac, send_seqnr, (u_char *)tmp___6, (int )tmp___5);
    }
  }
#line 704
  tmp___7 = buffer_len(& outgoing_packet);
#line 704
  tmp___8 = buffer_append_space(& output, tmp___7);
#line 704
  cp = (u_char *)tmp___8;
#line 705
  tmp___9 = buffer_len(& outgoing_packet);
#line 705
  tmp___10 = buffer_ptr(& outgoing_packet);
#line 705
  cipher_crypt(& send_context, cp, (u_char const   *)tmp___10, tmp___9);
#line 708
  if (mac) {
#line 708
    if (mac->enabled) {
#line 709
      buffer_append(& output, (void const   *)((char *)macbuf), (unsigned int )mac->mac_len);
    }
  }
#line 715
  send_seqnr ++;
#line 715
  if (send_seqnr == 0U) {
#line 716
    log("outgoing seqnr wraps around");
  }
#line 717
  buffer_clear(& outgoing_packet);
#line 719
  if ((int )type == 21) {
#line 720
    set_newkeys(1);
  }
#line 721
  return;
}
}
#line 723 "packet.c"
void packet_send(void) 
{ 

  {
#line 726
  if (compat20) {
#line 727
    packet_send2();
  } else {
#line 729
    packet_send1();
  }
#line 731
  return;
}
}
#line 739 "packet.c"
int packet_read_seqnr(u_int32_t *seqnr_p ) 
{ int type ;
  int len ;
  fd_set *setp ;
  char buf___1[8192] ;
  void *tmp ;
  int _len ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char const   *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
#line 747
  tmp = xmalloc((((unsigned int )(connection_in + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 747
  setp = (fd_set *)tmp;
#line 751
  packet_write_wait();
#line 754
  while (1) {
#line 756
    type = packet_read_poll_seqnr(seqnr_p);
#line 757
    if (! compat20) {
#line 757
      if (type == 14) {
        goto _L;
      } else {
#line 757
        if (type == 15) {
          goto _L;
        } else {
#line 757
          if (type == 19) {
            goto _L;
          } else {
#line 757
            if (type == 33) {
              _L: /* CIL Label */ 
#line 762
              while (1) {
#line 762
                tmp___0 = packet_remaining();
#line 762
                _len = tmp___0;
#line 762
                if (_len > 0) {
#line 762
                  log("Packet integrity error (%d bytes remaining) at %s:%d", _len,
                      "packet.c", 762);
#line 762
                  packet_disconnect("Packet integrity error.");
                }
#line 762
                break;
              }
            }
          }
        }
      }
    }
#line 764
    if (type != 0) {
#line 765
      xfree((void *)setp);
#line 766
      return (type);
    }
#line 772
    memset((void *)setp, 0, (((unsigned int )(connection_in + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 774
    __asm__  volatile   ("btsl %1,%0": "=m" (setp->__fds_bits[(unsigned int )connection_in / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 777
    while (1) {
#line 777
      tmp___1 = select(connection_in + 1, (fd_set * __restrict  )setp, (fd_set * __restrict  )((void *)0),
                       (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 777
      if (tmp___1 == -1) {
#line 777
        tmp___2 = __errno_location();
#line 777
        if (! (*tmp___2 == 11)) {
#line 777
          tmp___3 = __errno_location();
#line 777
          if (! (*tmp___3 == 4)) {
#line 777
            break;
          }
        }
      } else {
#line 777
        break;
      }
    }
#line 782
    len = read(connection_in, (void *)(buf___1), sizeof(buf___1));
#line 783
    if (len == 0) {
#line 784
      tmp___4 = get_remote_ipaddr();
#line 784
      log("Connection closed by %.200s", tmp___4);
#line 785
      fatal_cleanup();
    }
#line 787
    if (len < 0) {
#line 788
      tmp___5 = __errno_location();
#line 788
      tmp___6 = strerror(*tmp___5);
#line 788
      fatal("Read from socket failed: %.100s", tmp___6);
    }
#line 790
    packet_process_incoming((char const   *)(buf___1), (unsigned int )len);
  }
}
}
#line 795 "packet.c"
int packet_read(void) 
{ int tmp ;

  {
#line 798
  tmp = packet_read_seqnr((u_int32_t *)((void *)0));
#line 798
  return (tmp);
}
}
#line 806 "packet.c"
void packet_read_expect(int expected_type ) 
{ int type ;

  {
#line 811
  type = packet_read();
#line 812
  if (type != expected_type) {
#line 813
    packet_disconnect("Protocol error: expected packet type %d, got %d", expected_type,
                      type);
  }
#line 815
  return;
}
}
#line 826 "packet.c"
static int packet_read_poll1(void) 
{ u_int len ;
  u_int padded_len ;
  u_char *cp ;
  u_char type ;
  u_int checksum ;
  u_int stored_checksum ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  u_int tmp___6 ;
  void *tmp___7 ;
  u_int tmp___8 ;
  u_int tmp___9 ;
  void *tmp___10 ;
  u_int tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;

  {
#line 834
  tmp = buffer_len(& input);
#line 834
  if (tmp < 12U) {
#line 835
    return (0);
  }
#line 837
  tmp___0 = buffer_ptr(& input);
#line 837
  cp = (u_char *)tmp___0;
#line 838
  len = (unsigned int )(((((unsigned long )*(cp + 0) << 24) | ((unsigned long )*(cp + 1) << 16)) | ((unsigned long )*(cp + 2) << 8)) | (unsigned long )*(cp + 3));
#line 839
  if (len < 5U) {
#line 840
    packet_disconnect("Bad packet length %d.", len);
  } else {
#line 839
    if (len > 262144U) {
#line 840
      packet_disconnect("Bad packet length %d.", len);
    }
  }
#line 841
  padded_len = (len + 8U) & 4294967288U;
#line 844
  tmp___1 = buffer_len(& input);
#line 844
  if (tmp___1 < 4U + padded_len) {
#line 845
    return (0);
  }
#line 850
  buffer_consume(& input, 4U);
#line 857
  if (! receive_context.plaintext) {
#line 857
    tmp___2 = buffer_ptr(& input);
#line 857
    tmp___3 = detect_attack((u_char *)tmp___2, padded_len, (u_char *)((void *)0));
#line 857
    if (tmp___3 == 1) {
#line 859
      packet_disconnect("crc32 compensation attack: network attack detected");
    }
  }
#line 862
  buffer_clear(& incoming_packet);
#line 863
  tmp___4 = buffer_append_space(& incoming_packet, padded_len);
#line 863
  cp = (u_char *)tmp___4;
#line 864
  tmp___5 = buffer_ptr(& input);
#line 864
  cipher_crypt(& receive_context, cp, (u_char const   *)tmp___5, padded_len);
#line 866
  buffer_consume(& input, padded_len);
#line 874
  tmp___6 = buffer_len(& incoming_packet);
#line 874
  tmp___7 = buffer_ptr(& incoming_packet);
#line 874
  checksum = ssh_crc32((u_char const   *)tmp___7, tmp___6 - 4U);
#line 878
  buffer_consume(& incoming_packet, 8U - len % 8U);
#line 881
  tmp___9 = buffer_len(& incoming_packet);
#line 881
  if (len != tmp___9) {
#line 882
    tmp___8 = buffer_len(& incoming_packet);
#line 882
    packet_disconnect("packet_read_poll1: len %d != buffer_len %d.", len, tmp___8);
  }
#line 885
  tmp___10 = buffer_ptr(& incoming_packet);
#line 885
  cp = ((u_char *)tmp___10 + len) - 4;
#line 886
  stored_checksum = (unsigned int )(((((unsigned long )*(cp + 0) << 24) | ((unsigned long )*(cp + 1) << 16)) | ((unsigned long )*(cp + 2) << 8)) | (unsigned long )*(cp + 3));
#line 887
  if (checksum != stored_checksum) {
#line 888
    packet_disconnect("Corrupted check bytes on input.");
  }
#line 889
  buffer_consume_end(& incoming_packet, 4U);
#line 891
  if (packet_compression) {
#line 892
    buffer_clear(& compression_buffer);
#line 893
    buffer_uncompress(& incoming_packet, & compression_buffer);
#line 894
    buffer_clear(& incoming_packet);
#line 895
    tmp___11 = buffer_len(& compression_buffer);
#line 895
    tmp___12 = buffer_ptr(& compression_buffer);
#line 895
    buffer_append(& incoming_packet, (void const   *)tmp___12, tmp___11);
  }
#line 898
  tmp___13 = buffer_get_char(& incoming_packet);
#line 898
  type = (unsigned char )tmp___13;
#line 899
  return ((int )type);
}
}
#line 905
static int packet_read_poll2(u_int32_t *seqnr_p ) ;
#line 905 "packet.c"
static u_int packet_length  =    (u_int )0;
#line 902 "packet.c"
static int packet_read_poll2(u_int32_t *seqnr_p ) 
{ u_int padlen ;
  u_int need ;
  u_char *macbuf ;
  u_char *cp ;
  u_char type ;
  int maclen ;
  int block_size ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  u_int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  u_int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;
  u_int tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;

  {
#line 909
  enc = (Enc *)((void *)0);
#line 910
  mac = (Mac *)((void *)0);
#line 911
  comp = (Comp *)((void *)0);
#line 913
  if ((unsigned int )newkeys[0] != (unsigned int )((void *)0)) {
#line 914
    enc = & (newkeys[0])->enc;
#line 915
    mac = & (newkeys[0])->mac;
#line 916
    comp = & (newkeys[0])->comp;
  }
#line 918
  if (mac) {
#line 918
    if (mac->enabled) {
#line 918
      maclen = mac->mac_len;
    } else {
#line 918
      maclen = 0;
    }
  } else {
#line 918
    maclen = 0;
  }
#line 919
  if (enc) {
#line 919
    block_size = (int )enc->block_size;
  } else {
#line 919
    block_size = 8;
  }
#line 921
  if (packet_length == 0U) {
#line 926
    tmp = buffer_len(& input);
#line 926
    if (tmp < (u_int )block_size) {
#line 927
      return (0);
    }
#line 928
    buffer_clear(& incoming_packet);
#line 929
    tmp___0 = buffer_append_space(& incoming_packet, (unsigned int )block_size);
#line 929
    cp = (u_char *)tmp___0;
#line 930
    tmp___1 = buffer_ptr(& input);
#line 930
    cipher_crypt(& receive_context, cp, (u_char const   *)tmp___1, (unsigned int )block_size);
#line 932
    tmp___2 = buffer_ptr(& incoming_packet);
#line 932
    cp = (u_char *)tmp___2;
#line 933
    packet_length = (unsigned int )(((((unsigned long )*(cp + 0) << 24) | ((unsigned long )*(cp + 1) << 16)) | ((unsigned long )*(cp + 2) << 8)) | (unsigned long )*(cp + 3));
#line 934
    if (packet_length < 5U) {
#line 935
      buffer_dump(& incoming_packet);
#line 936
      packet_disconnect("Bad packet length %d.", packet_length);
    } else {
#line 934
      if (packet_length > 262144U) {
#line 935
        buffer_dump(& incoming_packet);
#line 936
        packet_disconnect("Bad packet length %d.", packet_length);
      }
    }
#line 939
    buffer_consume(& input, (unsigned int )block_size);
  }
#line 942
  need = (4U + packet_length) - (u_int )block_size;
#line 945
  if (need % (unsigned int )block_size != 0U) {
#line 946
    fatal("padding error: need %d block %d mod %d", need, block_size, need % (unsigned int )block_size);
  }
#line 952
  tmp___3 = buffer_len(& input);
#line 952
  if (tmp___3 < need + (u_int )maclen) {
#line 953
    return (0);
  }
#line 958
  tmp___4 = buffer_append_space(& incoming_packet, need);
#line 958
  cp = (u_char *)tmp___4;
#line 959
  tmp___5 = buffer_ptr(& input);
#line 959
  cipher_crypt(& receive_context, cp, (u_char const   *)tmp___5, need);
#line 960
  buffer_consume(& input, need);
#line 965
  if (mac) {
#line 965
    if (mac->enabled) {
#line 966
      tmp___6 = buffer_len(& incoming_packet);
#line 966
      tmp___7 = buffer_ptr(& incoming_packet);
#line 966
      macbuf = mac_compute(mac, read_seqnr, (u_char *)tmp___7, (int )tmp___6);
#line 969
      tmp___8 = buffer_ptr(& input);
#line 969
      tmp___9 = memcmp((void const   *)macbuf, (void const   *)tmp___8, (unsigned int )mac->mac_len);
#line 969
      if (tmp___9 != 0) {
#line 970
        packet_disconnect("Corrupted MAC on input.");
      }
#line 972
      buffer_consume(& input, (unsigned int )mac->mac_len);
    }
  }
#line 974
  if ((unsigned int )seqnr_p != (unsigned int )((void *)0)) {
#line 975
    *seqnr_p = read_seqnr;
  }
#line 976
  read_seqnr ++;
#line 976
  if (read_seqnr == 0U) {
#line 977
    log("incoming seqnr wraps around");
  }
#line 980
  tmp___10 = buffer_ptr(& incoming_packet);
#line 980
  cp = (u_char *)tmp___10;
#line 981
  padlen = (unsigned int )*(cp + 4);
#line 983
  if (padlen < 4U) {
#line 984
    packet_disconnect("Corrupted padlen %d on input.", padlen);
  }
#line 987
  buffer_consume(& incoming_packet, 5U);
#line 988
  buffer_consume_end(& incoming_packet, padlen);
#line 991
  if (comp) {
#line 991
    if (comp->enabled) {
#line 992
      buffer_clear(& compression_buffer);
#line 993
      buffer_uncompress(& incoming_packet, & compression_buffer);
#line 994
      buffer_clear(& incoming_packet);
#line 995
      tmp___11 = buffer_len(& compression_buffer);
#line 995
      tmp___12 = buffer_ptr(& compression_buffer);
#line 995
      buffer_append(& incoming_packet, (void const   *)tmp___12, tmp___11);
    }
  }
#line 1003
  tmp___13 = buffer_get_char(& incoming_packet);
#line 1003
  type = (unsigned char )tmp___13;
#line 1004
  if ((int )type == 21) {
#line 1005
    set_newkeys(0);
  }
#line 1011
  packet_length = 0U;
#line 1012
  return ((int )type);
}
}
#line 1015 "packet.c"
int packet_read_poll_seqnr(u_int32_t *seqnr_p ) 
{ u_int reason ;
  u_int seqnr ;
  u_char type ;
  char *msg ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  char const   *tmp___7 ;

  {
#line 1022
  while (1) {
#line 1023
    if (compat20) {
#line 1024
      tmp = packet_read_poll2(seqnr_p);
#line 1024
      type = (unsigned char )tmp;
#line 1025
      if (type) {

      }
#line 1027
      switch ((int )type) {
      case 2: 
#line 1029
      break;
      case 4: 
#line 1031
      packet_get_char();
#line 1032
      tmp___0 = packet_get_string((u_int *)((void *)0));
#line 1032
      msg = (char *)tmp___0;
#line 1033
      debug("Remote: %.900s", msg);
#line 1034
      xfree((void *)msg);
#line 1035
      tmp___1 = packet_get_string((u_int *)((void *)0));
#line 1035
      msg = (char *)tmp___1;
#line 1036
      xfree((void *)msg);
#line 1037
      break;
      case 1: 
#line 1039
      reason = packet_get_int();
#line 1040
      tmp___2 = packet_get_string((u_int *)((void *)0));
#line 1040
      msg = (char *)tmp___2;
#line 1041
      tmp___3 = get_remote_ipaddr();
#line 1041
      log("Received disconnect from %s: %u: %.400s", tmp___3, reason, msg);
#line 1043
      xfree((void *)msg);
#line 1044
      fatal_cleanup();
#line 1045
      break;
      case 3: 
#line 1047
      seqnr = packet_get_int();
#line 1048
      debug("Received SSH2_MSG_UNIMPLEMENTED for %u", seqnr);
#line 1050
      break;
      default: ;
#line 1052
      return ((int )type);
#line 1053
      break;
      }
    } else {
#line 1056
      tmp___4 = packet_read_poll1();
#line 1056
      type = (unsigned char )tmp___4;
#line 1057
      switch ((int )type) {
      case 32: 
#line 1059
      break;
      case 36: 
#line 1061
      tmp___5 = packet_get_string((u_int *)((void *)0));
#line 1061
      msg = (char *)tmp___5;
#line 1062
      debug("Remote: %.900s", msg);
#line 1063
      xfree((void *)msg);
#line 1064
      break;
      case 1: 
#line 1066
      tmp___6 = packet_get_string((u_int *)((void *)0));
#line 1066
      msg = (char *)tmp___6;
#line 1067
      tmp___7 = get_remote_ipaddr();
#line 1067
      log("Received disconnect from %s: %.400s", tmp___7, msg);
#line 1069
      fatal_cleanup();
#line 1070
      xfree((void *)msg);
#line 1071
      break;
      default: ;
#line 1073
      if (type) {

      }
#line 1075
      return ((int )type);
#line 1076
      break;
      }
    }
  }
}
}
#line 1082 "packet.c"
int packet_read_poll(void) 
{ int tmp ;

  {
#line 1085
  tmp = packet_read_poll_seqnr((u_int32_t *)((void *)0));
#line 1085
  return (tmp);
}
}
#line 1093 "packet.c"
void packet_process_incoming(char const   *buf___1 , u_int len ) 
{ 

  {
#line 1096
  buffer_append(& input, (void const   *)buf___1, len);
#line 1097
  return;
}
}
#line 1101 "packet.c"
u_int packet_get_char(void) 
{ char ch ;

  {
#line 1105
  buffer_get(& incoming_packet, (void *)(& ch), 1U);
#line 1106
  return ((unsigned int )((unsigned char )ch));
}
}
#line 1111 "packet.c"
u_int packet_get_int(void) 
{ u_int tmp ;

  {
#line 1114
  tmp = buffer_get_int(& incoming_packet);
#line 1114
  return (tmp);
}
}
#line 1122 "packet.c"
void packet_get_bignum(BIGNUM *value ) 
{ 

  {
#line 1125
  buffer_get_bignum(& incoming_packet, value);
#line 1126
  return;
}
}
#line 1128 "packet.c"
void packet_get_bignum2(BIGNUM *value ) 
{ 

  {
#line 1131
  buffer_get_bignum2(& incoming_packet, value);
#line 1132
  return;
}
}
#line 1134 "packet.c"
void *packet_get_raw(int *length_ptr ) 
{ int bytes ;
  u_int tmp ;
  void *tmp___0 ;

  {
#line 1137
  tmp = buffer_len(& incoming_packet);
#line 1137
  bytes = (int )tmp;
#line 1138
  if ((unsigned int )length_ptr != (unsigned int )((void *)0)) {
#line 1139
    *length_ptr = bytes;
  }
#line 1140
  tmp___0 = buffer_ptr(& incoming_packet);
#line 1140
  return (tmp___0);
}
}
#line 1143 "packet.c"
int packet_remaining(void) 
{ u_int tmp ;

  {
#line 1146
  tmp = buffer_len(& incoming_packet);
#line 1146
  return ((int )tmp);
}
}
#line 1156 "packet.c"
void *packet_get_string(u_int *length_ptr ) 
{ void *tmp ;

  {
#line 1159
  tmp = buffer_get_string(& incoming_packet, length_ptr);
#line 1159
  return (tmp);
}
}
#line 1171 "packet.c"
void ( /* format attribute */  packet_send_debug)(char const   *fmt  , ...) 
{ char buf___1[1024] ;
  va_list args ;

  {
#line 1177
  if (compat20) {
#line 1177
    if (datafellows & 64) {
#line 1178
      return;
    }
  }
#line 1180
  __builtin_va_start(args, fmt);
#line 1181
  vsnprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )fmt,
            args);
#line 1182
  __builtin_va_end(args);
#line 1184
  if (compat20) {
#line 1185
    packet_start((unsigned char)4);
#line 1186
    packet_put_char(0);
#line 1187
    packet_put_cstring((char const   *)(buf___1));
#line 1188
    packet_put_cstring("");
  } else {
#line 1190
    packet_start((unsigned char)36);
#line 1191
    packet_put_cstring((char const   *)(buf___1));
  }
#line 1193
  packet_send();
#line 1194
  packet_write_wait();
#line 1195
  return;
}
}
#line 1209 "packet.c"
static int disconnecting  =    0;
#line 1204 "packet.c"
void ( /* format attribute */  packet_disconnect)(char const   *fmt  , ...) 
{ char buf___1[1024] ;
  va_list args ;

  {
#line 1210
  if (disconnecting) {
#line 1211
    fatal("packet_disconnect called recursively.");
  }
#line 1212
  disconnecting = 1;
#line 1218
  __builtin_va_start(args, fmt);
#line 1219
  vsnprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )fmt,
            args);
#line 1220
  __builtin_va_end(args);
#line 1223
  if (compat20) {
#line 1224
    packet_start((unsigned char)1);
#line 1225
    packet_put_int(2U);
#line 1226
    packet_put_cstring((char const   *)(buf___1));
#line 1227
    packet_put_cstring("");
  } else {
#line 1229
    packet_start((unsigned char)1);
#line 1230
    packet_put_cstring((char const   *)(buf___1));
  }
#line 1232
  packet_send();
#line 1233
  packet_write_wait();
#line 1236
  channel_close_all();
#line 1239
  packet_close();
#line 1242
  log("Disconnecting: %.100s", buf___1);
#line 1243
  fatal_cleanup();
#line 1244
  return;
}
}
#line 1248 "packet.c"
void packet_write_poll(void) 
{ int len ;
  u_int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
#line 1251
  tmp = buffer_len(& output);
#line 1251
  len = (int )tmp;
#line 1252
  if (len > 0) {
#line 1253
    tmp___0 = buffer_ptr(& output);
#line 1253
    len = write(connection_out, (void const   *)tmp___0, (unsigned int )len);
#line 1254
    if (len <= 0) {
#line 1255
      tmp___3 = __errno_location();
#line 1255
      if (*tmp___3 == 11) {
#line 1256
        return;
      } else {
#line 1258
        tmp___1 = __errno_location();
#line 1258
        tmp___2 = strerror(*tmp___1);
#line 1258
        fatal("Write failed: %.100s", tmp___2);
      }
    }
#line 1260
    buffer_consume(& output, (unsigned int )len);
  }
#line 1262
  return;
}
}
#line 1269 "packet.c"
void packet_write_wait(void) 
{ fd_set *setp ;
  void *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
#line 1274
  tmp = xmalloc((((unsigned int )(connection_out + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 1274
  setp = (fd_set *)tmp;
#line 1276
  packet_write_poll();
#line 1277
  while (1) {
#line 1277
    tmp___3 = packet_have_data_to_write();
#line 1277
    if (! tmp___3) {
#line 1277
      break;
    }
#line 1278
    memset((void *)setp, 0, (((unsigned int )(connection_out + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 1280
    __asm__  volatile   ("btsl %1,%0": "=m" (setp->__fds_bits[(unsigned int )connection_out / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 1281
    while (1) {
#line 1281
      tmp___0 = select(connection_out + 1, (fd_set * __restrict  )((void *)0), (fd_set * __restrict  )setp,
                       (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 1281
      if (tmp___0 == -1) {
#line 1281
        tmp___1 = __errno_location();
#line 1281
        if (! (*tmp___1 == 11)) {
#line 1281
          tmp___2 = __errno_location();
#line 1281
          if (! (*tmp___2 == 4)) {
#line 1281
            break;
          }
        }
      } else {
#line 1281
        break;
      }
    }
#line 1284
    packet_write_poll();
  }
#line 1286
  xfree((void *)setp);
#line 1287
  return;
}
}
#line 1291 "packet.c"
int packet_have_data_to_write(void) 
{ u_int tmp ;

  {
#line 1294
  tmp = buffer_len(& output);
#line 1294
  return (tmp != 0U);
}
}
#line 1299 "packet.c"
int packet_not_very_much_data_to_write(void) 
{ u_int tmp ;
  u_int tmp___0 ;

  {
#line 1302
  if (interactive_mode) {
#line 1303
    tmp = buffer_len(& output);
#line 1303
    return (tmp < 16384U);
  } else {
#line 1305
    tmp___0 = buffer_len(& output);
#line 1305
    return (tmp___0 < 131072U);
  }
}
}
#line 1313 "packet.c"
static int called___0  =    0;
#line 1310 "packet.c"
void packet_set_interactive(int interactive ) 
{ int lowdelay ;
  int throughput ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1315
  lowdelay = 16;
#line 1316
  throughput = 8;
#line 1319
  if (called___0) {
#line 1320
    return;
  }
#line 1321
  called___0 = 1;
#line 1324
  interactive_mode = interactive;
#line 1327
  tmp = packet_connection_is_on_socket();
#line 1327
  if (! tmp) {
#line 1328
    return;
  }
#line 1332
  if (interactive) {
#line 1338
    tmp___3 = packet_connection_is_ipv4();
#line 1338
    if (tmp___3) {
#line 1339
      tmp___2 = setsockopt(connection_in, 0, 1, (void const   *)(& lowdelay), sizeof(lowdelay));
#line 1339
      if (tmp___2 < 0) {
#line 1341
        tmp___0 = __errno_location();
#line 1341
        tmp___1 = strerror(*tmp___0);
#line 1341
        error("setsockopt IPTOS_LOWDELAY: %.100s", tmp___1);
      }
    }
#line 1345
    set_nodelay(connection_in);
  } else {
#line 1346
    tmp___7 = packet_connection_is_ipv4();
#line 1346
    if (tmp___7) {
#line 1352
      tmp___6 = setsockopt(connection_in, 0, 1, (void const   *)(& throughput), sizeof(throughput));
#line 1352
      if (tmp___6 < 0) {
#line 1354
        tmp___4 = __errno_location();
#line 1354
        tmp___5 = strerror(*tmp___4);
#line 1354
        error("setsockopt IPTOS_THROUGHPUT: %.100s", tmp___5);
      }
    }
  }
#line 1357
  return;
}
}
#line 1361 "packet.c"
int packet_is_interactive(void) 
{ 

  {
#line 1364
  return (interactive_mode);
}
}
#line 1370 "packet.c"
static int called___1  =    0;
#line 1367 "packet.c"
int packet_set_maxsize(int s ) 
{ 

  {
#line 1371
  if (called___1) {
#line 1372
    log("packet_set_maxsize: called twice: old %d new %d", max_packet_size, s);
#line 1374
    return (-1);
  }
#line 1376
  if (s < 4096) {
#line 1377
    log("packet_set_maxsize: bad size %d", s);
#line 1378
    return (-1);
  } else {
#line 1376
    if (s > 1048576) {
#line 1377
      log("packet_set_maxsize: bad size %d", s);
#line 1378
      return (-1);
    }
  }
#line 1380
  called___1 = 1;
#line 1381
  debug("packet_set_maxsize: setting to %d", s);
#line 1382
  max_packet_size = s;
#line 1383
  return (s);
}
}
#line 1387 "packet.c"
void packet_add_padding(u_char pad ) 
{ 

  {
#line 1390
  extra_pad = pad;
#line 1391
  return;
}
}
#line 1404 "packet.c"
void packet_send_ignore(int nbytes ) 
{ u_int32_t rand___0 ;
  int i ;
  int tmp ;

  {
#line 1407
  rand___0 = (u_int32_t )0;
#line 1410
  if (compat20) {
#line 1410
    tmp = 2;
  } else {
#line 1410
    tmp = 32;
  }
#line 1410
  packet_start((unsigned char )tmp);
#line 1411
  packet_put_int((unsigned int )nbytes);
#line 1412
  i = 0;
#line 1412
  while (i < nbytes) {
#line 1413
    if (i % 4 == 0) {
#line 1414
      rand___0 = arc4random();
    }
#line 1415
    packet_put_char((int )(rand___0 & 255U));
#line 1416
    rand___0 >>= 8;
#line 1412
    i ++;
  }
#line 1418
  return;
}
}
#line 1 "radix.o"
#line 1 "rijndael.o"
#line 47 "rijndael.h"
void rijndael_set_key(rijndael_ctx *ctx , u_char *key , int bits , int encrypt ) ;
#line 48
void rijndael_decrypt(rijndael_ctx *ctx , u_char *src , u_char *dst ) ;
#line 49
void rijndael_encrypt(rijndael_ctx *ctx , u_char *src , u_char *dst ) ;
#line 51 "rijndael.c"
static u32 const   Te0[256]  = 
#line 51 "rijndael.c"
  {      (u32 const   )3328402341U,      (u32 const   )4168907908U,      (u32 const   )4000806809U,      (u32 const   )4135287693U, 
        (u32 const   )4294111757U,      (u32 const   )3597364157U,      (u32 const   )3731845041U,      (u32 const   )2445657428U, 
        (u32 const   )1613770832U,      (u32 const   )33620227U,      (u32 const   )3462883241U,      (u32 const   )1445669757U, 
        (u32 const   )3892248089U,      (u32 const   )3050821474U,      (u32 const   )1303096294U,      (u32 const   )3967186586U, 
        (u32 const   )2412431941U,      (u32 const   )528646813U,      (u32 const   )2311702848U,      (u32 const   )4202528135U, 
        (u32 const   )4026202645U,      (u32 const   )2992200171U,      (u32 const   )2387036105U,      (u32 const   )4226871307U, 
        (u32 const   )1101901292U,      (u32 const   )3017069671U,      (u32 const   )1604494077U,      (u32 const   )1169141738U, 
        (u32 const   )597466303U,      (u32 const   )1403299063U,      (u32 const   )3832705686U,      (u32 const   )2613100635U, 
        (u32 const   )1974974402U,      (u32 const   )3791519004U,      (u32 const   )1033081774U,      (u32 const   )1277568618U, 
        (u32 const   )1815492186U,      (u32 const   )2118074177U,      (u32 const   )4126668546U,      (u32 const   )2211236943U, 
        (u32 const   )1748251740U,      (u32 const   )1369810420U,      (u32 const   )3521504564U,      (u32 const   )4193382664U, 
        (u32 const   )3799085459U,      (u32 const   )2883115123U,      (u32 const   )1647391059U,      (u32 const   )706024767U, 
        (u32 const   )134480908U,      (u32 const   )2512897874U,      (u32 const   )1176707941U,      (u32 const   )2646852446U, 
        (u32 const   )806885416U,      (u32 const   )932615841U,      (u32 const   )168101135U,      (u32 const   )798661301U, 
        (u32 const   )235341577U,      (u32 const   )605164086U,      (u32 const   )461406363U,      (u32 const   )3756188221U, 
        (u32 const   )3454790438U,      (u32 const   )1311188841U,      (u32 const   )2142417613U,      (u32 const   )3933566367U, 
        (u32 const   )302582043U,      (u32 const   )495158174U,      (u32 const   )1479289972U,      (u32 const   )874125870U, 
        (u32 const   )907746093U,      (u32 const   )3698224818U,      (u32 const   )3025820398U,      (u32 const   )1537253627U, 
        (u32 const   )2756858614U,      (u32 const   )1983593293U,      (u32 const   )3084310113U,      (u32 const   )2108928974U, 
        (u32 const   )1378429307U,      (u32 const   )3722699582U,      (u32 const   )1580150641U,      (u32 const   )327451799U, 
        (u32 const   )2790478837U,      (u32 const   )3117535592U,      (u32 const   )0U,      (u32 const   )3253595436U, 
        (u32 const   )1075847264U,      (u32 const   )3825007647U,      (u32 const   )2041688520U,      (u32 const   )3059440621U, 
        (u32 const   )3563743934U,      (u32 const   )2378943302U,      (u32 const   )1740553945U,      (u32 const   )1916352843U, 
        (u32 const   )2487896798U,      (u32 const   )2555137236U,      (u32 const   )2958579944U,      (u32 const   )2244988746U, 
        (u32 const   )3151024235U,      (u32 const   )3320835882U,      (u32 const   )1336584933U,      (u32 const   )3992714006U, 
        (u32 const   )2252555205U,      (u32 const   )2588757463U,      (u32 const   )1714631509U,      (u32 const   )293963156U, 
        (u32 const   )2319795663U,      (u32 const   )3925473552U,      (u32 const   )67240454U,      (u32 const   )4269768577U, 
        (u32 const   )2689618160U,      (u32 const   )2017213508U,      (u32 const   )631218106U,      (u32 const   )1269344483U, 
        (u32 const   )2723238387U,      (u32 const   )1571005438U,      (u32 const   )2151694528U,      (u32 const   )93294474U, 
        (u32 const   )1066570413U,      (u32 const   )563977660U,      (u32 const   )1882732616U,      (u32 const   )4059428100U, 
        (u32 const   )1673313503U,      (u32 const   )2008463041U,      (u32 const   )2950355573U,      (u32 const   )1109467491U, 
        (u32 const   )537923632U,      (u32 const   )3858759450U,      (u32 const   )4260623118U,      (u32 const   )3218264685U, 
        (u32 const   )2177748300U,      (u32 const   )403442708U,      (u32 const   )638784309U,      (u32 const   )3287084079U, 
        (u32 const   )3193921505U,      (u32 const   )899127202U,      (u32 const   )2286175436U,      (u32 const   )773265209U, 
        (u32 const   )2479146071U,      (u32 const   )1437050866U,      (u32 const   )4236148354U,      (u32 const   )2050833735U, 
        (u32 const   )3362022572U,      (u32 const   )3126681063U,      (u32 const   )840505643U,      (u32 const   )3866325909U, 
        (u32 const   )3227541664U,      (u32 const   )427917720U,      (u32 const   )2655997905U,      (u32 const   )2749160575U, 
        (u32 const   )1143087718U,      (u32 const   )1412049534U,      (u32 const   )999329963U,      (u32 const   )193497219U, 
        (u32 const   )2353415882U,      (u32 const   )3354324521U,      (u32 const   )1807268051U,      (u32 const   )672404540U, 
        (u32 const   )2816401017U,      (u32 const   )3160301282U,      (u32 const   )369822493U,      (u32 const   )2916866934U, 
        (u32 const   )3688947771U,      (u32 const   )1681011286U,      (u32 const   )1949973070U,      (u32 const   )336202270U, 
        (u32 const   )2454276571U,      (u32 const   )201721354U,      (u32 const   )1210328172U,      (u32 const   )3093060836U, 
        (u32 const   )2680341085U,      (u32 const   )3184776046U,      (u32 const   )1135389935U,      (u32 const   )3294782118U, 
        (u32 const   )965841320U,      (u32 const   )831886756U,      (u32 const   )3554993207U,      (u32 const   )4068047243U, 
        (u32 const   )3588745010U,      (u32 const   )2345191491U,      (u32 const   )1849112409U,      (u32 const   )3664604599U, 
        (u32 const   )26054028U,      (u32 const   )2983581028U,      (u32 const   )2622377682U,      (u32 const   )1235855840U, 
        (u32 const   )3630984372U,      (u32 const   )2891339514U,      (u32 const   )4092916743U,      (u32 const   )3488279077U, 
        (u32 const   )3395642799U,      (u32 const   )4101667470U,      (u32 const   )1202630377U,      (u32 const   )268961816U, 
        (u32 const   )1874508501U,      (u32 const   )4034427016U,      (u32 const   )1243948399U,      (u32 const   )1546530418U, 
        (u32 const   )941366308U,      (u32 const   )1470539505U,      (u32 const   )1941222599U,      (u32 const   )2546386513U, 
        (u32 const   )3421038627U,      (u32 const   )2715671932U,      (u32 const   )3899946140U,      (u32 const   )1042226977U, 
        (u32 const   )2521517021U,      (u32 const   )1639824860U,      (u32 const   )227249030U,      (u32 const   )260737669U, 
        (u32 const   )3765465232U,      (u32 const   )2084453954U,      (u32 const   )1907733956U,      (u32 const   )3429263018U, 
        (u32 const   )2420656344U,      (u32 const   )100860677U,      (u32 const   )4160157185U,      (u32 const   )470683154U, 
        (u32 const   )3261161891U,      (u32 const   )1781871967U,      (u32 const   )2924959737U,      (u32 const   )1773779408U, 
        (u32 const   )394692241U,      (u32 const   )2579611992U,      (u32 const   )974986535U,      (u32 const   )664706745U, 
        (u32 const   )3655459128U,      (u32 const   )3958962195U,      (u32 const   )731420851U,      (u32 const   )571543859U, 
        (u32 const   )3530123707U,      (u32 const   )2849626480U,      (u32 const   )126783113U,      (u32 const   )865375399U, 
        (u32 const   )765172662U,      (u32 const   )1008606754U,      (u32 const   )361203602U,      (u32 const   )3387549984U, 
        (u32 const   )2278477385U,      (u32 const   )2857719295U,      (u32 const   )1344809080U,      (u32 const   )2782912378U, 
        (u32 const   )59542671U,      (u32 const   )1503764984U,      (u32 const   )160008576U,      (u32 const   )437062935U, 
        (u32 const   )1707065306U,      (u32 const   )3622233649U,      (u32 const   )2218934982U,      (u32 const   )3496503480U, 
        (u32 const   )2185314755U,      (u32 const   )697932208U,      (u32 const   )1512910199U,      (u32 const   )504303377U, 
        (u32 const   )2075177163U,      (u32 const   )2824099068U,      (u32 const   )1841019862U,      (u32 const   )739644986U};
#line 117 "rijndael.c"
static u32 const   Te1[256]  = 
#line 117
  {      (u32 const   )2781242211U,      (u32 const   )2230877308U,      (u32 const   )2582542199U,      (u32 const   )2381740923U, 
        (u32 const   )234877682U,      (u32 const   )3184946027U,      (u32 const   )2984144751U,      (u32 const   )1418839493U, 
        (u32 const   )1348481072U,      (u32 const   )50462977U,      (u32 const   )2848876391U,      (u32 const   )2102799147U, 
        (u32 const   )434634494U,      (u32 const   )1656084439U,      (u32 const   )3863849899U,      (u32 const   )2599188086U, 
        (u32 const   )1167051466U,      (u32 const   )2636087938U,      (u32 const   )1082771913U,      (u32 const   )2281340285U, 
        (u32 const   )368048890U,      (u32 const   )3954334041U,      (u32 const   )3381544775U,      (u32 const   )201060592U, 
        (u32 const   )3963727277U,      (u32 const   )1739838676U,      (u32 const   )4250903202U,      (u32 const   )3930435503U, 
        (u32 const   )3206782108U,      (u32 const   )4149453988U,      (u32 const   )2531553906U,      (u32 const   )1536934080U, 
        (u32 const   )3262494647U,      (u32 const   )484572669U,      (u32 const   )2923271059U,      (u32 const   )1783375398U, 
        (u32 const   )1517041206U,      (u32 const   )1098792767U,      (u32 const   )49674231U,      (u32 const   )1334037708U, 
        (u32 const   )1550332980U,      (u32 const   )4098991525U,      (u32 const   )886171109U,      (u32 const   )150598129U, 
        (u32 const   )2481090929U,      (u32 const   )1940642008U,      (u32 const   )1398944049U,      (u32 const   )1059722517U, 
        (u32 const   )201851908U,      (u32 const   )1385547719U,      (u32 const   )1699095331U,      (u32 const   )1587397571U, 
        (u32 const   )674240536U,      (u32 const   )2704774806U,      (u32 const   )252314885U,      (u32 const   )3039795866U, 
        (u32 const   )151914247U,      (u32 const   )908333586U,      (u32 const   )2602270848U,      (u32 const   )1038082786U, 
        (u32 const   )651029483U,      (u32 const   )1766729511U,      (u32 const   )3447698098U,      (u32 const   )2682942837U, 
        (u32 const   )454166793U,      (u32 const   )2652734339U,      (u32 const   )1951935532U,      (u32 const   )775166490U, 
        (u32 const   )758520603U,      (u32 const   )3000790638U,      (u32 const   )4004797018U,      (u32 const   )4217086112U, 
        (u32 const   )4137964114U,      (u32 const   )1299594043U,      (u32 const   )1639438038U,      (u32 const   )3464344499U, 
        (u32 const   )2068982057U,      (u32 const   )1054729187U,      (u32 const   )1901997871U,      (u32 const   )2534638724U, 
        (u32 const   )4121318227U,      (u32 const   )1757008337U,      (u32 const   )0U,      (u32 const   )750906861U, 
        (u32 const   )1614815264U,      (u32 const   )535035132U,      (u32 const   )3363418545U,      (u32 const   )3988151131U, 
        (u32 const   )3201591914U,      (u32 const   )1183697867U,      (u32 const   )3647454910U,      (u32 const   )1265776953U, 
        (u32 const   )3734260298U,      (u32 const   )3566750796U,      (u32 const   )3903871064U,      (u32 const   )1250283471U, 
        (u32 const   )1807470800U,      (u32 const   )717615087U,      (u32 const   )3847203498U,      (u32 const   )384695291U, 
        (u32 const   )3313910595U,      (u32 const   )3617213773U,      (u32 const   )1432761139U,      (u32 const   )2484176261U, 
        (u32 const   )3481945413U,      (u32 const   )283769337U,      (u32 const   )100925954U,      (u32 const   )2180939647U, 
        (u32 const   )4037038160U,      (u32 const   )1148730428U,      (u32 const   )3123027871U,      (u32 const   )3813386408U, 
        (u32 const   )4087501137U,      (u32 const   )4267549603U,      (u32 const   )3229630528U,      (u32 const   )2315620239U, 
        (u32 const   )2906624658U,      (u32 const   )3156319645U,      (u32 const   )1215313976U,      (u32 const   )82966005U, 
        (u32 const   )3747855548U,      (u32 const   )3245848246U,      (u32 const   )1974459098U,      (u32 const   )1665278241U, 
        (u32 const   )807407632U,      (u32 const   )451280895U,      (u32 const   )251524083U,      (u32 const   )1841287890U, 
        (u32 const   )1283575245U,      (u32 const   )337120268U,      (u32 const   )891687699U,      (u32 const   )801369324U, 
        (u32 const   )3787349855U,      (u32 const   )2721421207U,      (u32 const   )3431482436U,      (u32 const   )959321879U, 
        (u32 const   )1469301956U,      (u32 const   )4065699751U,      (u32 const   )2197585534U,      (u32 const   )1199193405U, 
        (u32 const   )2898814052U,      (u32 const   )3887750493U,      (u32 const   )724703513U,      (u32 const   )2514908019U, 
        (u32 const   )2696962144U,      (u32 const   )2551808385U,      (u32 const   )3516813135U,      (u32 const   )2141445340U, 
        (u32 const   )1715741218U,      (u32 const   )2119445034U,      (u32 const   )2872807568U,      (u32 const   )2198571144U, 
        (u32 const   )3398190662U,      (u32 const   )700968686U,      (u32 const   )3547052216U,      (u32 const   )1009259540U, 
        (u32 const   )2041044702U,      (u32 const   )3803995742U,      (u32 const   )487983883U,      (u32 const   )1991105499U, 
        (u32 const   )1004265696U,      (u32 const   )1449407026U,      (u32 const   )1316239930U,      (u32 const   )504629770U, 
        (u32 const   )3683797321U,      (u32 const   )168560134U,      (u32 const   )1816667172U,      (u32 const   )3837287516U, 
        (u32 const   )1570751170U,      (u32 const   )1857934291U,      (u32 const   )4014189740U,      (u32 const   )2797888098U, 
        (u32 const   )2822345105U,      (u32 const   )2754712981U,      (u32 const   )936633572U,      (u32 const   )2347923833U, 
        (u32 const   )852879335U,      (u32 const   )1133234376U,      (u32 const   )1500395319U,      (u32 const   )3084545389U, 
        (u32 const   )2348912013U,      (u32 const   )1689376213U,      (u32 const   )3533459022U,      (u32 const   )3762923945U, 
        (u32 const   )3034082412U,      (u32 const   )4205598294U,      (u32 const   )133428468U,      (u32 const   )634383082U, 
        (u32 const   )2949277029U,      (u32 const   )2398386810U,      (u32 const   )3913789102U,      (u32 const   )403703816U, 
        (u32 const   )3580869306U,      (u32 const   )2297460856U,      (u32 const   )1867130149U,      (u32 const   )1918643758U, 
        (u32 const   )607656988U,      (u32 const   )4049053350U,      (u32 const   )3346248884U,      (u32 const   )1368901318U, 
        (u32 const   )600565992U,      (u32 const   )2090982877U,      (u32 const   )2632479860U,      (u32 const   )557719327U, 
        (u32 const   )3717614411U,      (u32 const   )3697393085U,      (u32 const   )2249034635U,      (u32 const   )2232388234U, 
        (u32 const   )2430627952U,      (u32 const   )1115438654U,      (u32 const   )3295786421U,      (u32 const   )2865522278U, 
        (u32 const   )3633334344U,      (u32 const   )84280067U,      (u32 const   )33027830U,      (u32 const   )303828494U, 
        (u32 const   )2747425121U,      (u32 const   )1600795957U,      (u32 const   )4188952407U,      (u32 const   )3496589753U, 
        (u32 const   )2434238086U,      (u32 const   )1486471617U,      (u32 const   )658119965U,      (u32 const   )3106381470U, 
        (u32 const   )953803233U,      (u32 const   )334231800U,      (u32 const   )3005978776U,      (u32 const   )857870609U, 
        (u32 const   )3151128937U,      (u32 const   )1890179545U,      (u32 const   )2298973838U,      (u32 const   )2805175444U, 
        (u32 const   )3056442267U,      (u32 const   )574365214U,      (u32 const   )2450884487U,      (u32 const   )550103529U, 
        (u32 const   )1233637070U,      (u32 const   )4289353045U,      (u32 const   )2018519080U,      (u32 const   )2057691103U, 
        (u32 const   )2399374476U,      (u32 const   )4166623649U,      (u32 const   )2148108681U,      (u32 const   )387583245U, 
        (u32 const   )3664101311U,      (u32 const   )836232934U,      (u32 const   )3330556482U,      (u32 const   )3100665960U, 
        (u32 const   )3280093505U,      (u32 const   )2955516313U,      (u32 const   )2002398509U,      (u32 const   )287182607U, 
        (u32 const   )3413881008U,      (u32 const   )4238890068U,      (u32 const   )3597515707U,      (u32 const   )975967766U};
#line 183 "rijndael.c"
static u32 const   Te2[256]  = 
#line 183
  {      (u32 const   )1671808611U,      (u32 const   )2089089148U,      (u32 const   )2006576759U,      (u32 const   )2072901243U, 
        (u32 const   )4061003762U,      (u32 const   )1807603307U,      (u32 const   )1873927791U,      (u32 const   )3310653893U, 
        (u32 const   )810573872U,      (u32 const   )16974337U,      (u32 const   )1739181671U,      (u32 const   )729634347U, 
        (u32 const   )4263110654U,      (u32 const   )3613570519U,      (u32 const   )2883997099U,      (u32 const   )1989864566U, 
        (u32 const   )3393556426U,      (u32 const   )2191335298U,      (u32 const   )3376449993U,      (u32 const   )2106063485U, 
        (u32 const   )4195741690U,      (u32 const   )1508618841U,      (u32 const   )1204391495U,      (u32 const   )4027317232U, 
        (u32 const   )2917941677U,      (u32 const   )3563566036U,      (u32 const   )2734514082U,      (u32 const   )2951366063U, 
        (u32 const   )2629772188U,      (u32 const   )2767672228U,      (u32 const   )1922491506U,      (u32 const   )3227229120U, 
        (u32 const   )3082974647U,      (u32 const   )4246528509U,      (u32 const   )2477669779U,      (u32 const   )644500518U, 
        (u32 const   )911895606U,      (u32 const   )1061256767U,      (u32 const   )4144166391U,      (u32 const   )3427763148U, 
        (u32 const   )878471220U,      (u32 const   )2784252325U,      (u32 const   )3845444069U,      (u32 const   )4043897329U, 
        (u32 const   )1905517169U,      (u32 const   )3631459288U,      (u32 const   )827548209U,      (u32 const   )356461077U, 
        (u32 const   )67897348U,      (u32 const   )3344078279U,      (u32 const   )593839651U,      (u32 const   )3277757891U, 
        (u32 const   )405286936U,      (u32 const   )2527147926U,      (u32 const   )84871685U,      (u32 const   )2595565466U, 
        (u32 const   )118033927U,      (u32 const   )305538066U,      (u32 const   )2157648768U,      (u32 const   )3795705826U, 
        (u32 const   )3945188843U,      (u32 const   )661212711U,      (u32 const   )2999812018U,      (u32 const   )1973414517U, 
        (u32 const   )152769033U,      (u32 const   )2208177539U,      (u32 const   )745822252U,      (u32 const   )439235610U, 
        (u32 const   )455947803U,      (u32 const   )1857215598U,      (u32 const   )1525593178U,      (u32 const   )2700827552U, 
        (u32 const   )1391895634U,      (u32 const   )994932283U,      (u32 const   )3596728278U,      (u32 const   )3016654259U, 
        (u32 const   )695947817U,      (u32 const   )3812548067U,      (u32 const   )795958831U,      (u32 const   )2224493444U, 
        (u32 const   )1408607827U,      (u32 const   )3513301457U,      (u32 const   )0U,      (u32 const   )3979133421U, 
        (u32 const   )543178784U,      (u32 const   )4229948412U,      (u32 const   )2982705585U,      (u32 const   )1542305371U, 
        (u32 const   )1790891114U,      (u32 const   )3410398667U,      (u32 const   )3201918910U,      (u32 const   )961245753U, 
        (u32 const   )1256100938U,      (u32 const   )1289001036U,      (u32 const   )1491644504U,      (u32 const   )3477767631U, 
        (u32 const   )3496721360U,      (u32 const   )4012557807U,      (u32 const   )2867154858U,      (u32 const   )4212583931U, 
        (u32 const   )1137018435U,      (u32 const   )1305975373U,      (u32 const   )861234739U,      (u32 const   )2241073541U, 
        (u32 const   )1171229253U,      (u32 const   )4178635257U,      (u32 const   )33948674U,      (u32 const   )2139225727U, 
        (u32 const   )1357946960U,      (u32 const   )1011120188U,      (u32 const   )2679776671U,      (u32 const   )2833468328U, 
        (u32 const   )1374921297U,      (u32 const   )2751356323U,      (u32 const   )1086357568U,      (u32 const   )2408187279U, 
        (u32 const   )2460827538U,      (u32 const   )2646352285U,      (u32 const   )944271416U,      (u32 const   )4110742005U, 
        (u32 const   )3168756668U,      (u32 const   )3066132406U,      (u32 const   )3665145818U,      (u32 const   )560153121U, 
        (u32 const   )271589392U,      (u32 const   )4279952895U,      (u32 const   )4077846003U,      (u32 const   )3530407890U, 
        (u32 const   )3444343245U,      (u32 const   )202643468U,      (u32 const   )322250259U,      (u32 const   )3962553324U, 
        (u32 const   )1608629855U,      (u32 const   )2543990167U,      (u32 const   )1154254916U,      (u32 const   )389623319U, 
        (u32 const   )3294073796U,      (u32 const   )2817676711U,      (u32 const   )2122513534U,      (u32 const   )1028094525U, 
        (u32 const   )1689045092U,      (u32 const   )1575467613U,      (u32 const   )422261273U,      (u32 const   )1939203699U, 
        (u32 const   )1621147744U,      (u32 const   )2174228865U,      (u32 const   )1339137615U,      (u32 const   )3699352540U, 
        (u32 const   )577127458U,      (u32 const   )712922154U,      (u32 const   )2427141008U,      (u32 const   )2290289544U, 
        (u32 const   )1187679302U,      (u32 const   )3995715566U,      (u32 const   )3100863416U,      (u32 const   )339486740U, 
        (u32 const   )3732514782U,      (u32 const   )1591917662U,      (u32 const   )186455563U,      (u32 const   )3681988059U, 
        (u32 const   )3762019296U,      (u32 const   )844522546U,      (u32 const   )978220090U,      (u32 const   )169743370U, 
        (u32 const   )1239126601U,      (u32 const   )101321734U,      (u32 const   )611076132U,      (u32 const   )1558493276U, 
        (u32 const   )3260915650U,      (u32 const   )3547250131U,      (u32 const   )2901361580U,      (u32 const   )1655096418U, 
        (u32 const   )2443721105U,      (u32 const   )2510565781U,      (u32 const   )3828863972U,      (u32 const   )2039214713U, 
        (u32 const   )3878868455U,      (u32 const   )3359869896U,      (u32 const   )928607799U,      (u32 const   )1840765549U, 
        (u32 const   )2374762893U,      (u32 const   )3580146133U,      (u32 const   )1322425422U,      (u32 const   )2850048425U, 
        (u32 const   )1823791212U,      (u32 const   )1459268694U,      (u32 const   )4094161908U,      (u32 const   )3928346602U, 
        (u32 const   )1706019429U,      (u32 const   )2056189050U,      (u32 const   )2934523822U,      (u32 const   )135794696U, 
        (u32 const   )3134549946U,      (u32 const   )2022240376U,      (u32 const   )628050469U,      (u32 const   )779246638U, 
        (u32 const   )472135708U,      (u32 const   )2800834470U,      (u32 const   )3032970164U,      (u32 const   )3327236038U, 
        (u32 const   )3894660072U,      (u32 const   )3715932637U,      (u32 const   )1956440180U,      (u32 const   )522272287U, 
        (u32 const   )1272813131U,      (u32 const   )3185336765U,      (u32 const   )2340818315U,      (u32 const   )2323976074U, 
        (u32 const   )1888542832U,      (u32 const   )1044544574U,      (u32 const   )3049550261U,      (u32 const   )1722469478U, 
        (u32 const   )1222152264U,      (u32 const   )50660867U,      (u32 const   )4127324150U,      (u32 const   )236067854U, 
        (u32 const   )1638122081U,      (u32 const   )895445557U,      (u32 const   )1475980887U,      (u32 const   )3117443513U, 
        (u32 const   )2257655686U,      (u32 const   )3243809217U,      (u32 const   )489110045U,      (u32 const   )2662934430U, 
        (u32 const   )3778599393U,      (u32 const   )4162055160U,      (u32 const   )2561878936U,      (u32 const   )288563729U, 
        (u32 const   )1773916777U,      (u32 const   )3648039385U,      (u32 const   )2391345038U,      (u32 const   )2493985684U, 
        (u32 const   )2612407707U,      (u32 const   )505560094U,      (u32 const   )2274497927U,      (u32 const   )3911240169U, 
        (u32 const   )3460925390U,      (u32 const   )1442818645U,      (u32 const   )678973480U,      (u32 const   )3749357023U, 
        (u32 const   )2358182796U,      (u32 const   )2717407649U,      (u32 const   )2306869641U,      (u32 const   )219617805U, 
        (u32 const   )3218761151U,      (u32 const   )3862026214U,      (u32 const   )1120306242U,      (u32 const   )1756942440U, 
        (u32 const   )1103331905U,      (u32 const   )2578459033U,      (u32 const   )762796589U,      (u32 const   )252780047U, 
        (u32 const   )2966125488U,      (u32 const   )1425844308U,      (u32 const   )3151392187U,      (u32 const   )372911126U};
#line 249 "rijndael.c"
static u32 const   Te3[256]  = 
#line 249
  {      (u32 const   )1667474886U,      (u32 const   )2088535288U,      (u32 const   )2004326894U,      (u32 const   )2071694838U, 
        (u32 const   )4075949567U,      (u32 const   )1802223062U,      (u32 const   )1869591006U,      (u32 const   )3318043793U, 
        (u32 const   )808472672U,      (u32 const   )16843522U,      (u32 const   )1734846926U,      (u32 const   )724270422U, 
        (u32 const   )4278065639U,      (u32 const   )3621216949U,      (u32 const   )2880169549U,      (u32 const   )1987484396U, 
        (u32 const   )3402253711U,      (u32 const   )2189597983U,      (u32 const   )3385409673U,      (u32 const   )2105378810U, 
        (u32 const   )4210693615U,      (u32 const   )1499065266U,      (u32 const   )1195886990U,      (u32 const   )4042263547U, 
        (u32 const   )2913856577U,      (u32 const   )3570689971U,      (u32 const   )2728590687U,      (u32 const   )2947541573U, 
        (u32 const   )2627518243U,      (u32 const   )2762274643U,      (u32 const   )1920112356U,      (u32 const   )3233831835U, 
        (u32 const   )3082273397U,      (u32 const   )4261223649U,      (u32 const   )2475929149U,      (u32 const   )640051788U, 
        (u32 const   )909531756U,      (u32 const   )1061110142U,      (u32 const   )4160160501U,      (u32 const   )3435941763U, 
        (u32 const   )875846760U,      (u32 const   )2779116625U,      (u32 const   )3857003729U,      (u32 const   )4059105529U, 
        (u32 const   )1903268834U,      (u32 const   )3638064043U,      (u32 const   )825316194U,      (u32 const   )353713962U, 
        (u32 const   )67374088U,      (u32 const   )3351728789U,      (u32 const   )589522246U,      (u32 const   )3284360861U, 
        (u32 const   )404236336U,      (u32 const   )2526454071U,      (u32 const   )84217610U,      (u32 const   )2593830191U, 
        (u32 const   )117901582U,      (u32 const   )303183396U,      (u32 const   )2155911963U,      (u32 const   )3806477791U, 
        (u32 const   )3958056653U,      (u32 const   )656894286U,      (u32 const   )2998062463U,      (u32 const   )1970642922U, 
        (u32 const   )151591698U,      (u32 const   )2206440989U,      (u32 const   )741110872U,      (u32 const   )437923380U, 
        (u32 const   )454765878U,      (u32 const   )1852748508U,      (u32 const   )1515908788U,      (u32 const   )2694904667U, 
        (u32 const   )1381168804U,      (u32 const   )993742198U,      (u32 const   )3604373943U,      (u32 const   )3014905469U, 
        (u32 const   )690584402U,      (u32 const   )3823320797U,      (u32 const   )791638366U,      (u32 const   )2223281939U, 
        (u32 const   )1398011302U,      (u32 const   )3520161977U,      (u32 const   )0U,      (u32 const   )3991743681U, 
        (u32 const   )538992704U,      (u32 const   )4244381667U,      (u32 const   )2981218425U,      (u32 const   )1532751286U, 
        (u32 const   )1785380564U,      (u32 const   )3419096717U,      (u32 const   )3200178535U,      (u32 const   )960056178U, 
        (u32 const   )1246420628U,      (u32 const   )1280103576U,      (u32 const   )1482221744U,      (u32 const   )3486468741U, 
        (u32 const   )3503319995U,      (u32 const   )4025428677U,      (u32 const   )2863326543U,      (u32 const   )4227536621U, 
        (u32 const   )1128514950U,      (u32 const   )1296947098U,      (u32 const   )859002214U,      (u32 const   )2240123921U, 
        (u32 const   )1162203018U,      (u32 const   )4193849577U,      (u32 const   )33687044U,      (u32 const   )2139062782U, 
        (u32 const   )1347481760U,      (u32 const   )1010582648U,      (u32 const   )2678045221U,      (u32 const   )2829640523U, 
        (u32 const   )1364325282U,      (u32 const   )2745433693U,      (u32 const   )1077985408U,      (u32 const   )2408548869U, 
        (u32 const   )2459086143U,      (u32 const   )2644360225U,      (u32 const   )943212656U,      (u32 const   )4126475505U, 
        (u32 const   )3166494563U,      (u32 const   )3065430391U,      (u32 const   )3671750063U,      (u32 const   )555836226U, 
        (u32 const   )269496352U,      (u32 const   )4294908645U,      (u32 const   )4092792573U,      (u32 const   )3537006015U, 
        (u32 const   )3452783745U,      (u32 const   )202118168U,      (u32 const   )320025894U,      (u32 const   )3974901699U, 
        (u32 const   )1600119230U,      (u32 const   )2543297077U,      (u32 const   )1145359496U,      (u32 const   )387397934U, 
        (u32 const   )3301201811U,      (u32 const   )2812801621U,      (u32 const   )2122220284U,      (u32 const   )1027426170U, 
        (u32 const   )1684319432U,      (u32 const   )1566435258U,      (u32 const   )421079858U,      (u32 const   )1936954854U, 
        (u32 const   )1616945344U,      (u32 const   )2172753945U,      (u32 const   )1330631070U,      (u32 const   )3705438115U, 
        (u32 const   )572679748U,      (u32 const   )707427924U,      (u32 const   )2425400123U,      (u32 const   )2290647819U, 
        (u32 const   )1179044492U,      (u32 const   )4008585671U,      (u32 const   )3099120491U,      (u32 const   )336870440U, 
        (u32 const   )3739122087U,      (u32 const   )1583276732U,      (u32 const   )185277718U,      (u32 const   )3688593069U, 
        (u32 const   )3772791771U,      (u32 const   )842159716U,      (u32 const   )976899700U,      (u32 const   )168435220U, 
        (u32 const   )1229577106U,      (u32 const   )101059084U,      (u32 const   )606366792U,      (u32 const   )1549591736U, 
        (u32 const   )3267517855U,      (u32 const   )3553849021U,      (u32 const   )2897014595U,      (u32 const   )1650632388U, 
        (u32 const   )2442242105U,      (u32 const   )2509612081U,      (u32 const   )3840161747U,      (u32 const   )2038008818U, 
        (u32 const   )3890688725U,      (u32 const   )3368567691U,      (u32 const   )926374254U,      (u32 const   )1835907034U, 
        (u32 const   )2374863873U,      (u32 const   )3587531953U,      (u32 const   )1313788572U,      (u32 const   )2846482505U, 
        (u32 const   )1819063512U,      (u32 const   )1448540844U,      (u32 const   )4109633523U,      (u32 const   )3941213647U, 
        (u32 const   )1701162954U,      (u32 const   )2054852340U,      (u32 const   )2930698567U,      (u32 const   )134748176U, 
        (u32 const   )3132806511U,      (u32 const   )2021165296U,      (u32 const   )623210314U,      (u32 const   )774795868U, 
        (u32 const   )471606328U,      (u32 const   )2795958615U,      (u32 const   )3031746419U,      (u32 const   )3334885783U, 
        (u32 const   )3907527627U,      (u32 const   )3722280097U,      (u32 const   )1953799400U,      (u32 const   )522133822U, 
        (u32 const   )1263263126U,      (u32 const   )3183336545U,      (u32 const   )2341176845U,      (u32 const   )2324333839U, 
        (u32 const   )1886425312U,      (u32 const   )1044267644U,      (u32 const   )3048588401U,      (u32 const   )1718004428U, 
        (u32 const   )1212733584U,      (u32 const   )50529542U,      (u32 const   )4143317495U,      (u32 const   )235803164U, 
        (u32 const   )1633788866U,      (u32 const   )892690282U,      (u32 const   )1465383342U,      (u32 const   )3115962473U, 
        (u32 const   )2256965911U,      (u32 const   )3250673817U,      (u32 const   )488449850U,      (u32 const   )2661202215U, 
        (u32 const   )3789633753U,      (u32 const   )4177007595U,      (u32 const   )2560144171U,      (u32 const   )286339874U, 
        (u32 const   )1768537042U,      (u32 const   )3654906025U,      (u32 const   )2391705863U,      (u32 const   )2492770099U, 
        (u32 const   )2610673197U,      (u32 const   )505291324U,      (u32 const   )2273808917U,      (u32 const   )3924369609U, 
        (u32 const   )3469625735U,      (u32 const   )1431699370U,      (u32 const   )673740880U,      (u32 const   )3755965093U, 
        (u32 const   )2358021891U,      (u32 const   )2711746649U,      (u32 const   )2307489801U,      (u32 const   )218961690U, 
        (u32 const   )3217021541U,      (u32 const   )3873845719U,      (u32 const   )1111672452U,      (u32 const   )1751693520U, 
        (u32 const   )1094828930U,      (u32 const   )2576986153U,      (u32 const   )757954394U,      (u32 const   )252645662U, 
        (u32 const   )2964376443U,      (u32 const   )1414855848U,      (u32 const   )3149649517U,      (u32 const   )370555436U};
#line 316 "rijndael.c"
static u32 const   Te4[256]  = 
#line 316
  {      (u32 const   )1667457891U,      (u32 const   )2088533116U,      (u32 const   )2004318071U,      (u32 const   )2071690107U, 
        (u32 const   )4076008178U,      (u32 const   )1802201963U,      (u32 const   )1869573999U,      (u32 const   )3318072773U, 
        (u32 const   )808464432U,      (u32 const   )16843009U,      (u32 const   )1734829927U,      (u32 const   )724249387U, 
        (u32 const   )4278124286U,      (u32 const   )3621246935U,      (u32 const   )2880154539U,      (u32 const   )1987475062U, 
        (u32 const   )3402287818U,      (u32 const   )2189591170U,      (u32 const   )3385444809U,      (u32 const   )2105376125U, 
        (u32 const   )4210752250U,      (u32 const   )1499027801U,      (u32 const   )1195853639U,      (u32 const   )4042322160U, 
        (u32 const   )2913840557U,      (u32 const   )3570717908U,      (u32 const   )2728567458U,      (u32 const   )2947526575U, 
        (u32 const   )2627509404U,      (u32 const   )2762253476U,      (u32 const   )1920103026U,      (u32 const   )3233857728U, 
        (u32 const   )3082270647U,      (u32 const   )4261281277U,      (u32 const   )2475922323U,      (u32 const   )640034342U, 
        (u32 const   )909522486U,      (u32 const   )1061109567U,      (u32 const   )4160223223U,      (u32 const   )3435973836U, 
        (u32 const   )875836468U,      (u32 const   )2779096485U,      (u32 const   )3857049061U,      (u32 const   )4059165169U, 
        (u32 const   )1903260017U,      (u32 const   )3638089944U,      (u32 const   )825307441U,      (u32 const   )353703189U, 
        (u32 const   )67372036U,      (u32 const   )3351758791U,      (u32 const   )589505315U,      (u32 const   )3284386755U, 
        (u32 const   )404232216U,      (u32 const   )2526451350U,      (u32 const   )84215045U,      (u32 const   )2593823386U, 
        (u32 const   )117901063U,      (u32 const   )303174162U,      (u32 const   )2155905152U,      (u32 const   )3806520034U, 
        (u32 const   )3958107115U,      (u32 const   )656877351U,      (u32 const   )2998055602U,      (u32 const   )1970632053U, 
        (u32 const   )151587081U,      (u32 const   )2206434179U,      (u32 const   )741092396U,      (u32 const   )437918234U, 
        (u32 const   )454761243U,      (u32 const   )1852730990U,      (u32 const   )1515870810U,      (u32 const   )2694881440U, 
        (u32 const   )1381126738U,      (u32 const   )993737531U,      (u32 const   )3604403926U,      (u32 const   )3014898611U, 
        (u32 const   )690563369U,      (u32 const   )3823363043U,      (u32 const   )791621423U,      (u32 const   )2223277188U, 
        (u32 const   )1397969747U,      (u32 const   )3520188881U,      (u32 const   )0U,      (u32 const   )3991793133U, 
        (u32 const   )538976288U,      (u32 const   )4244438268U,      (u32 const   )2981212593U,      (u32 const   )1532713819U, 
        (u32 const   )1785358954U,      (u32 const   )3419130827U,      (u32 const   )3200171710U,      (u32 const   )960051513U, 
        (u32 const   )1246382666U,      (u32 const   )1280068684U,      (u32 const   )1482184792U,      (u32 const   )3486502863U, 
        (u32 const   )3503345872U,      (u32 const   )4025479151U,      (u32 const   )2863311530U,      (u32 const   )4227595259U, 
        (u32 const   )1128481603U,      (u32 const   )1296911693U,      (u32 const   )858993459U,      (u32 const   )2240120197U, 
        (u32 const   )1162167621U,      (u32 const   )4193909241U,      (u32 const   )33686018U,      (u32 const   )2139062143U, 
        (u32 const   )1347440720U,      (u32 const   )1010580540U,      (u32 const   )2678038431U,      (u32 const   )2829625512U, 
        (u32 const   )1364283729U,      (u32 const   )2745410467U,      (u32 const   )1077952576U,      (u32 const   )2408550287U, 
        (u32 const   )2459079314U,      (u32 const   )2644352413U,      (u32 const   )943208504U,      (u32 const   )4126537205U, 
        (u32 const   )3166485692U,      (u32 const   )3065427638U,      (u32 const   )3671775962U,      (u32 const   )555819297U, 
        (u32 const   )269488144U,      (u32 const   )4294967295U,      (u32 const   )4092851187U,      (u32 const   )3537031890U, 
        (u32 const   )3452816845U,      (u32 const   )202116108U,      (u32 const   )320017171U,      (u32 const   )3974950124U, 
        (u32 const   )1600085855U,      (u32 const   )2543294359U,      (u32 const   )1145324612U,      (u32 const   )387389207U, 
        (u32 const   )3301229764U,      (u32 const   )2812782503U,      (u32 const   )2122219134U,      (u32 const   )1027423549U, 
        (u32 const   )1684300900U,      (u32 const   )1566399837U,      (u32 const   )421075225U,      (u32 const   )1936946035U, 
        (u32 const   )1616928864U,      (u32 const   )2172748161U,      (u32 const   )1330597711U,      (u32 const   )3705461980U, 
        (u32 const   )572662306U,      (u32 const   )707406378U,      (u32 const   )2425393296U,      (u32 const   )2290649224U, 
        (u32 const   )1179010630U,      (u32 const   )4008636142U,      (u32 const   )3099113656U,      (u32 const   )336860180U, 
        (u32 const   )3739147998U,      (u32 const   )1583242846U,      (u32 const   )185273099U,      (u32 const   )3688618971U, 
        (u32 const   )3772834016U,      (u32 const   )842150450U,      (u32 const   )976894522U,      (u32 const   )168430090U, 
        (u32 const   )1229539657U,      (u32 const   )101058054U,      (u32 const   )606348324U,      (u32 const   )1549556828U, 
        (u32 const   )3267543746U,      (u32 const   )3553874899U,      (u32 const   )2896997548U,      (u32 const   )1650614882U, 
        (u32 const   )2442236305U,      (u32 const   )2509608341U,      (u32 const   )3840206052U,      (u32 const   )2038004089U, 
        (u32 const   )3890735079U,      (u32 const   )3368601800U,      (u32 const   )926365495U,      (u32 const   )1835887981U, 
        (u32 const   )2374864269U,      (u32 const   )3587560917U,      (u32 const   )1313754702U,      (u32 const   )2846468521U, 
        (u32 const   )1819044972U,      (u32 const   )1448498774U,      (u32 const   )4109694196U,      (u32 const   )3941264106U, 
        (u32 const   )1701143909U,      (u32 const   )2054847098U,      (u32 const   )2930683566U,      (u32 const   )134744072U, 
        (u32 const   )3132799674U,      (u32 const   )2021161080U,      (u32 const   )623191333U,      (u32 const   )774778414U, 
        (u32 const   )471604252U,      (u32 const   )2795939494U,      (u32 const   )3031741620U,      (u32 const   )3334915782U, 
        (u32 const   )3907578088U,      (u32 const   )3722304989U,      (u32 const   )1953789044U,      (u32 const   )522133279U, 
        (u32 const   )1263225675U,      (u32 const   )3183328701U,      (u32 const   )2341178251U,      (u32 const   )2324335242U, 
        (u32 const   )1886417008U,      (u32 const   )1044266558U,      (u32 const   )3048584629U,      (u32 const   )1717986918U, 
        (u32 const   )1212696648U,      (u32 const   )50529027U,      (u32 const   )4143380214U,      (u32 const   )235802126U, 
        (u32 const   )1633771873U,      (u32 const   )892679477U,      (u32 const   )1465341783U,      (u32 const   )3115956665U, 
        (u32 const   )2256963206U,      (u32 const   )3250700737U,      (u32 const   )488447261U,      (u32 const   )2661195422U, 
        (u32 const   )3789677025U,      (u32 const   )4177066232U,      (u32 const   )2560137368U,      (u32 const   )286331153U, 
        (u32 const   )1768515945U,      (u32 const   )3654932953U,      (u32 const   )2391707278U,      (u32 const   )2492765332U, 
        (u32 const   )2610666395U,      (u32 const   )505290270U,      (u32 const   )2273806215U,      (u32 const   )3924421097U, 
        (u32 const   )3469659854U,      (u32 const   )1431655765U,      (u32 const   )673720360U,      (u32 const   )3755991007U, 
        (u32 const   )2358021260U,      (u32 const   )2711724449U,      (u32 const   )2307492233U,      (u32 const   )218959117U, 
        (u32 const   )3217014719U,      (u32 const   )3873892070U,      (u32 const   )1111638594U,      (u32 const   )1751672936U, 
        (u32 const   )1094795585U,      (u32 const   )2576980377U,      (u32 const   )757935405U,      (u32 const   )252645135U, 
        (u32 const   )2964369584U,      (u32 const   )1414812756U,      (u32 const   )3149642683U,      (u32 const   )370546198U};
#line 382 "rijndael.c"
static u32 const   Td0[256]  = 
#line 382
  {      (u32 const   )1374988112U,      (u32 const   )2118214995U,      (u32 const   )437757123U,      (u32 const   )975658646U, 
        (u32 const   )1001089995U,      (u32 const   )530400753U,      (u32 const   )2902087851U,      (u32 const   )1273168787U, 
        (u32 const   )540080725U,      (u32 const   )2910219766U,      (u32 const   )2295101073U,      (u32 const   )4110568485U, 
        (u32 const   )1340463100U,      (u32 const   )3307916247U,      (u32 const   )641025152U,      (u32 const   )3043140495U, 
        (u32 const   )3736164937U,      (u32 const   )632953703U,      (u32 const   )1172967064U,      (u32 const   )1576976609U, 
        (u32 const   )3274667266U,      (u32 const   )2169303058U,      (u32 const   )2370213795U,      (u32 const   )1809054150U, 
        (u32 const   )59727847U,      (u32 const   )361929877U,      (u32 const   )3211623147U,      (u32 const   )2505202138U, 
        (u32 const   )3569255213U,      (u32 const   )1484005843U,      (u32 const   )1239443753U,      (u32 const   )2395588676U, 
        (u32 const   )1975683434U,      (u32 const   )4102977912U,      (u32 const   )2572697195U,      (u32 const   )666464733U, 
        (u32 const   )3202437046U,      (u32 const   )4035489047U,      (u32 const   )3374361702U,      (u32 const   )2110667444U, 
        (u32 const   )1675577880U,      (u32 const   )3843699074U,      (u32 const   )2538681184U,      (u32 const   )1649639237U, 
        (u32 const   )2976151520U,      (u32 const   )3144396420U,      (u32 const   )4269907996U,      (u32 const   )4178062228U, 
        (u32 const   )1883793496U,      (u32 const   )2403728665U,      (u32 const   )2497604743U,      (u32 const   )1383856311U, 
        (u32 const   )2876494627U,      (u32 const   )1917518562U,      (u32 const   )3810496343U,      (u32 const   )1716890410U, 
        (u32 const   )3001755655U,      (u32 const   )800440835U,      (u32 const   )2261089178U,      (u32 const   )3543599269U, 
        (u32 const   )807962610U,      (u32 const   )599762354U,      (u32 const   )33778362U,      (u32 const   )3977675356U, 
        (u32 const   )2328828971U,      (u32 const   )2809771154U,      (u32 const   )4077384432U,      (u32 const   )1315562145U, 
        (u32 const   )1708848333U,      (u32 const   )101039829U,      (u32 const   )3509871135U,      (u32 const   )3299278474U, 
        (u32 const   )875451293U,      (u32 const   )2733856160U,      (u32 const   )92987698U,      (u32 const   )2767645557U, 
        (u32 const   )193195065U,      (u32 const   )1080094634U,      (u32 const   )1584504582U,      (u32 const   )3178106961U, 
        (u32 const   )1042385657U,      (u32 const   )2531067453U,      (u32 const   )3711829422U,      (u32 const   )1306967366U, 
        (u32 const   )2438237621U,      (u32 const   )1908694277U,      (u32 const   )67556463U,      (u32 const   )1615861247U, 
        (u32 const   )429456164U,      (u32 const   )3602770327U,      (u32 const   )2302690252U,      (u32 const   )1742315127U, 
        (u32 const   )2968011453U,      (u32 const   )126454664U,      (u32 const   )3877198648U,      (u32 const   )2043211483U, 
        (u32 const   )2709260871U,      (u32 const   )2084704233U,      (u32 const   )4169408201U,      (u32 const   )0U, 
        (u32 const   )159417987U,      (u32 const   )841739592U,      (u32 const   )504459436U,      (u32 const   )1817866830U, 
        (u32 const   )4245618683U,      (u32 const   )260388950U,      (u32 const   )1034867998U,      (u32 const   )908933415U, 
        (u32 const   )168810852U,      (u32 const   )1750902305U,      (u32 const   )2606453969U,      (u32 const   )607530554U, 
        (u32 const   )202008497U,      (u32 const   )2472011535U,      (u32 const   )3035535058U,      (u32 const   )463180190U, 
        (u32 const   )2160117071U,      (u32 const   )1641816226U,      (u32 const   )1517767529U,      (u32 const   )470948374U, 
        (u32 const   )3801332234U,      (u32 const   )3231722213U,      (u32 const   )1008918595U,      (u32 const   )303765277U, 
        (u32 const   )235474187U,      (u32 const   )4069246893U,      (u32 const   )766945465U,      (u32 const   )337553864U, 
        (u32 const   )1475418501U,      (u32 const   )2943682380U,      (u32 const   )4003061179U,      (u32 const   )2743034109U, 
        (u32 const   )4144047775U,      (u32 const   )1551037884U,      (u32 const   )1147550661U,      (u32 const   )1543208500U, 
        (u32 const   )2336434550U,      (u32 const   )3408119516U,      (u32 const   )3069049960U,      (u32 const   )3102011747U, 
        (u32 const   )3610369226U,      (u32 const   )1113818384U,      (u32 const   )328671808U,      (u32 const   )2227573024U, 
        (u32 const   )2236228733U,      (u32 const   )3535486456U,      (u32 const   )2935566865U,      (u32 const   )3341394285U, 
        (u32 const   )496906059U,      (u32 const   )3702665459U,      (u32 const   )226906860U,      (u32 const   )2009195472U, 
        (u32 const   )733156972U,      (u32 const   )2842737049U,      (u32 const   )294930682U,      (u32 const   )1206477858U, 
        (u32 const   )2835123396U,      (u32 const   )2700099354U,      (u32 const   )1451044056U,      (u32 const   )573804783U, 
        (u32 const   )2269728455U,      (u32 const   )3644379585U,      (u32 const   )2362090238U,      (u32 const   )2564033334U, 
        (u32 const   )2801107407U,      (u32 const   )2776292904U,      (u32 const   )3669462566U,      (u32 const   )1068351396U, 
        (u32 const   )742039012U,      (u32 const   )1350078989U,      (u32 const   )1784663195U,      (u32 const   )1417561698U, 
        (u32 const   )4136440770U,      (u32 const   )2430122216U,      (u32 const   )775550814U,      (u32 const   )2193862645U, 
        (u32 const   )2673705150U,      (u32 const   )1775276924U,      (u32 const   )1876241833U,      (u32 const   )3475313331U, 
        (u32 const   )3366754619U,      (u32 const   )270040487U,      (u32 const   )3902563182U,      (u32 const   )3678124923U, 
        (u32 const   )3441850377U,      (u32 const   )1851332852U,      (u32 const   )3969562369U,      (u32 const   )2203032232U, 
        (u32 const   )3868552805U,      (u32 const   )2868897406U,      (u32 const   )566021896U,      (u32 const   )4011190502U, 
        (u32 const   )3135740889U,      (u32 const   )1248802510U,      (u32 const   )3936291284U,      (u32 const   )699432150U, 
        (u32 const   )832877231U,      (u32 const   )708780849U,      (u32 const   )3332740144U,      (u32 const   )899835584U, 
        (u32 const   )1951317047U,      (u32 const   )4236429990U,      (u32 const   )3767586992U,      (u32 const   )866637845U, 
        (u32 const   )4043610186U,      (u32 const   )1106041591U,      (u32 const   )2144161806U,      (u32 const   )395441711U, 
        (u32 const   )1984812685U,      (u32 const   )1139781709U,      (u32 const   )3433712980U,      (u32 const   )3835036895U, 
        (u32 const   )2664543715U,      (u32 const   )1282050075U,      (u32 const   )3240894392U,      (u32 const   )1181045119U, 
        (u32 const   )2640243204U,      (u32 const   )25965917U,      (u32 const   )4203181171U,      (u32 const   )4211818798U, 
        (u32 const   )3009879386U,      (u32 const   )2463879762U,      (u32 const   )3910161971U,      (u32 const   )1842759443U, 
        (u32 const   )2597806476U,      (u32 const   )933301370U,      (u32 const   )1509430414U,      (u32 const   )3943906441U, 
        (u32 const   )3467192302U,      (u32 const   )3076639029U,      (u32 const   )3776767469U,      (u32 const   )2051518780U, 
        (u32 const   )2631065433U,      (u32 const   )1441952575U,      (u32 const   )404016761U,      (u32 const   )1942435775U, 
        (u32 const   )1408749034U,      (u32 const   )1610459739U,      (u32 const   )3745345300U,      (u32 const   )2017778566U, 
        (u32 const   )3400528769U,      (u32 const   )3110650942U,      (u32 const   )941896748U,      (u32 const   )3265478751U, 
        (u32 const   )371049330U,      (u32 const   )3168937228U,      (u32 const   )675039627U,      (u32 const   )4279080257U, 
        (u32 const   )967311729U,      (u32 const   )135050206U,      (u32 const   )3635733660U,      (u32 const   )1683407248U, 
        (u32 const   )2076935265U,      (u32 const   )3576870512U,      (u32 const   )1215061108U,      (u32 const   )3501741890U};
#line 448 "rijndael.c"
static u32 const   Td1[256]  = 
#line 448
  {      (u32 const   )1347548327U,      (u32 const   )1400783205U,      (u32 const   )3273267108U,      (u32 const   )2520393566U, 
        (u32 const   )3409685355U,      (u32 const   )4045380933U,      (u32 const   )2880240216U,      (u32 const   )2471224067U, 
        (u32 const   )1428173050U,      (u32 const   )4138563181U,      (u32 const   )2441661558U,      (u32 const   )636813900U, 
        (u32 const   )4233094615U,      (u32 const   )3620022987U,      (u32 const   )2149987652U,      (u32 const   )2411029155U, 
        (u32 const   )1239331162U,      (u32 const   )1730525723U,      (u32 const   )2554718734U,      (u32 const   )3781033664U, 
        (u32 const   )46346101U,      (u32 const   )310463728U,      (u32 const   )2743944855U,      (u32 const   )3328955385U, 
        (u32 const   )3875770207U,      (u32 const   )2501218972U,      (u32 const   )3955191162U,      (u32 const   )3667219033U, 
        (u32 const   )768917123U,      (u32 const   )3545789473U,      (u32 const   )692707433U,      (u32 const   )1150208456U, 
        (u32 const   )1786102409U,      (u32 const   )2029293177U,      (u32 const   )1805211710U,      (u32 const   )3710368113U, 
        (u32 const   )3065962831U,      (u32 const   )401639597U,      (u32 const   )1724457132U,      (u32 const   )3028143674U, 
        (u32 const   )409198410U,      (u32 const   )2196052529U,      (u32 const   )1620529459U,      (u32 const   )1164071807U, 
        (u32 const   )3769721975U,      (u32 const   )2226875310U,      (u32 const   )486441376U,      (u32 const   )2499348523U, 
        (u32 const   )1483753576U,      (u32 const   )428819965U,      (u32 const   )2274680428U,      (u32 const   )3075636216U, 
        (u32 const   )598438867U,      (u32 const   )3799141122U,      (u32 const   )1474502543U,      (u32 const   )711349675U, 
        (u32 const   )129166120U,      (u32 const   )53458370U,      (u32 const   )2592523643U,      (u32 const   )2782082824U, 
        (u32 const   )4063242375U,      (u32 const   )2988687269U,      (u32 const   )3120694122U,      (u32 const   )1559041666U, 
        (u32 const   )730517276U,      (u32 const   )2460449204U,      (u32 const   )4042459122U,      (u32 const   )2706270690U, 
        (u32 const   )3446004468U,      (u32 const   )3573941694U,      (u32 const   )533804130U,      (u32 const   )2328143614U, 
        (u32 const   )2637442643U,      (u32 const   )2695033685U,      (u32 const   )839224033U,      (u32 const   )1973745387U, 
        (u32 const   )957055980U,      (u32 const   )2856345839U,      (u32 const   )106852767U,      (u32 const   )1371368976U, 
        (u32 const   )4181598602U,      (u32 const   )1033297158U,      (u32 const   )2933734917U,      (u32 const   )1179510461U, 
        (u32 const   )3046200461U,      (u32 const   )91341917U,      (u32 const   )1862534868U,      (u32 const   )4284502037U, 
        (u32 const   )605657339U,      (u32 const   )2547432937U,      (u32 const   )3431546947U,      (u32 const   )2003294622U, 
        (u32 const   )3182487618U,      (u32 const   )2282195339U,      (u32 const   )954669403U,      (u32 const   )3682191598U, 
        (u32 const   )1201765386U,      (u32 const   )3917234703U,      (u32 const   )3388507166U,      (u32 const   )0U, 
        (u32 const   )2198438022U,      (u32 const   )1211247597U,      (u32 const   )2887651696U,      (u32 const   )1315723890U, 
        (u32 const   )4227665663U,      (u32 const   )1443857720U,      (u32 const   )507358933U,      (u32 const   )657861945U, 
        (u32 const   )1678381017U,      (u32 const   )560487590U,      (u32 const   )3516619604U,      (u32 const   )975451694U, 
        (u32 const   )2970356327U,      (u32 const   )261314535U,      (u32 const   )3535072918U,      (u32 const   )2652609425U, 
        (u32 const   )1333838021U,      (u32 const   )2724322336U,      (u32 const   )1767536459U,      (u32 const   )370938394U, 
        (u32 const   )182621114U,      (u32 const   )3854606378U,      (u32 const   )1128014560U,      (u32 const   )487725847U, 
        (u32 const   )185469197U,      (u32 const   )2918353863U,      (u32 const   )3106780840U,      (u32 const   )3356761769U, 
        (u32 const   )2237133081U,      (u32 const   )1286567175U,      (u32 const   )3152976349U,      (u32 const   )4255350624U, 
        (u32 const   )2683765030U,      (u32 const   )3160175349U,      (u32 const   )3309594171U,      (u32 const   )878443390U, 
        (u32 const   )1988838185U,      (u32 const   )3704300486U,      (u32 const   )1756818940U,      (u32 const   )1673061617U, 
        (u32 const   )3403100636U,      (u32 const   )272786309U,      (u32 const   )1075025698U,      (u32 const   )545572369U, 
        (u32 const   )2105887268U,      (u32 const   )4174560061U,      (u32 const   )296679730U,      (u32 const   )1841768865U, 
        (u32 const   )1260232239U,      (u32 const   )4091327024U,      (u32 const   )3960309330U,      (u32 const   )3497509347U, 
        (u32 const   )1814803222U,      (u32 const   )2578018489U,      (u32 const   )4195456072U,      (u32 const   )575138148U, 
        (u32 const   )3299409036U,      (u32 const   )446754879U,      (u32 const   )3629546796U,      (u32 const   )4011996048U, 
        (u32 const   )3347532110U,      (u32 const   )3252238545U,      (u32 const   )4270639778U,      (u32 const   )915985419U, 
        (u32 const   )3483825537U,      (u32 const   )681933534U,      (u32 const   )651868046U,      (u32 const   )2755636671U, 
        (u32 const   )3828103837U,      (u32 const   )223377554U,      (u32 const   )2607439820U,      (u32 const   )1649704518U, 
        (u32 const   )3270937875U,      (u32 const   )3901806776U,      (u32 const   )1580087799U,      (u32 const   )4118987695U, 
        (u32 const   )3198115200U,      (u32 const   )2087309459U,      (u32 const   )2842678573U,      (u32 const   )3016697106U, 
        (u32 const   )1003007129U,      (u32 const   )2802849917U,      (u32 const   )1860738147U,      (u32 const   )2077965243U, 
        (u32 const   )164439672U,      (u32 const   )4100872472U,      (u32 const   )32283319U,      (u32 const   )2827177882U, 
        (u32 const   )1709610350U,      (u32 const   )2125135846U,      (u32 const   )136428751U,      (u32 const   )3874428392U, 
        (u32 const   )3652904859U,      (u32 const   )3460984630U,      (u32 const   )3572145929U,      (u32 const   )3593056380U, 
        (u32 const   )2939266226U,      (u32 const   )824852259U,      (u32 const   )818324884U,      (u32 const   )3224740454U, 
        (u32 const   )930369212U,      (u32 const   )2801566410U,      (u32 const   )2967507152U,      (u32 const   )355706840U, 
        (u32 const   )1257309336U,      (u32 const   )4148292826U,      (u32 const   )243256656U,      (u32 const   )790073846U, 
        (u32 const   )2373340630U,      (u32 const   )1296297904U,      (u32 const   )1422699085U,      (u32 const   )3756299780U, 
        (u32 const   )3818836405U,      (u32 const   )457992840U,      (u32 const   )3099667487U,      (u32 const   )2135319889U, 
        (u32 const   )77422314U,      (u32 const   )1560382517U,      (u32 const   )1945798516U,      (u32 const   )788204353U, 
        (u32 const   )1521706781U,      (u32 const   )1385356242U,      (u32 const   )870912086U,      (u32 const   )325965383U, 
        (u32 const   )2358957921U,      (u32 const   )2050466060U,      (u32 const   )2388260884U,      (u32 const   )2313884476U, 
        (u32 const   )4006521127U,      (u32 const   )901210569U,      (u32 const   )3990953189U,      (u32 const   )1014646705U, 
        (u32 const   )1503449823U,      (u32 const   )1062597235U,      (u32 const   )2031621326U,      (u32 const   )3212035895U, 
        (u32 const   )3931371469U,      (u32 const   )1533017514U,      (u32 const   )350174575U,      (u32 const   )2256028891U, 
        (u32 const   )2177544179U,      (u32 const   )1052338372U,      (u32 const   )741876788U,      (u32 const   )1606591296U, 
        (u32 const   )1914052035U,      (u32 const   )213705253U,      (u32 const   )2334669897U,      (u32 const   )1107234197U, 
        (u32 const   )1899603969U,      (u32 const   )3725069491U,      (u32 const   )2631447780U,      (u32 const   )2422494913U, 
        (u32 const   )1635502980U,      (u32 const   )1893020342U,      (u32 const   )1950903388U,      (u32 const   )1120974935U};
#line 514 "rijndael.c"
static u32 const   Td2[256]  = 
#line 514
  {      (u32 const   )2807058932U,      (u32 const   )1699970625U,      (u32 const   )2764249623U,      (u32 const   )1586903591U, 
        (u32 const   )1808481195U,      (u32 const   )1173430173U,      (u32 const   )1487645946U,      (u32 const   )59984867U, 
        (u32 const   )4199882800U,      (u32 const   )1844882806U,      (u32 const   )1989249228U,      (u32 const   )1277555970U, 
        (u32 const   )3623636965U,      (u32 const   )3419915562U,      (u32 const   )1149249077U,      (u32 const   )2744104290U, 
        (u32 const   )1514790577U,      (u32 const   )459744698U,      (u32 const   )244860394U,      (u32 const   )3235995134U, 
        (u32 const   )1963115311U,      (u32 const   )4027744588U,      (u32 const   )2544078150U,      (u32 const   )4190530515U, 
        (u32 const   )1608975247U,      (u32 const   )2627016082U,      (u32 const   )2062270317U,      (u32 const   )1507497298U, 
        (u32 const   )2200818878U,      (u32 const   )567498868U,      (u32 const   )1764313568U,      (u32 const   )3359936201U, 
        (u32 const   )2305455554U,      (u32 const   )2037970062U,      (u32 const   )1047239000U,      (u32 const   )1910319033U, 
        (u32 const   )1337376481U,      (u32 const   )2904027272U,      (u32 const   )2892417312U,      (u32 const   )984907214U, 
        (u32 const   )1243112415U,      (u32 const   )830661914U,      (u32 const   )861968209U,      (u32 const   )2135253587U, 
        (u32 const   )2011214180U,      (u32 const   )2927934315U,      (u32 const   )2686254721U,      (u32 const   )731183368U, 
        (u32 const   )1750626376U,      (u32 const   )4246310725U,      (u32 const   )1820824798U,      (u32 const   )4172763771U, 
        (u32 const   )3542330227U,      (u32 const   )48394827U,      (u32 const   )2404901663U,      (u32 const   )2871682645U, 
        (u32 const   )671593195U,      (u32 const   )3254988725U,      (u32 const   )2073724613U,      (u32 const   )145085239U, 
        (u32 const   )2280796200U,      (u32 const   )2779915199U,      (u32 const   )1790575107U,      (u32 const   )2187128086U, 
        (u32 const   )472615631U,      (u32 const   )3029510009U,      (u32 const   )4075877127U,      (u32 const   )3802222185U, 
        (u32 const   )4107101658U,      (u32 const   )3201631749U,      (u32 const   )1646252340U,      (u32 const   )4270507174U, 
        (u32 const   )1402811438U,      (u32 const   )1436590835U,      (u32 const   )3778151818U,      (u32 const   )3950355702U, 
        (u32 const   )3963161475U,      (u32 const   )4020912224U,      (u32 const   )2667994737U,      (u32 const   )273792366U, 
        (u32 const   )2331590177U,      (u32 const   )104699613U,      (u32 const   )95345982U,      (u32 const   )3175501286U, 
        (u32 const   )2377486676U,      (u32 const   )1560637892U,      (u32 const   )3564045318U,      (u32 const   )369057872U, 
        (u32 const   )4213447064U,      (u32 const   )3919042237U,      (u32 const   )1137477952U,      (u32 const   )2658625497U, 
        (u32 const   )1119727848U,      (u32 const   )2340947849U,      (u32 const   )1530455833U,      (u32 const   )4007360968U, 
        (u32 const   )172466556U,      (u32 const   )266959938U,      (u32 const   )516552836U,      (u32 const   )0U, 
        (u32 const   )2256734592U,      (u32 const   )3980931627U,      (u32 const   )1890328081U,      (u32 const   )1917742170U, 
        (u32 const   )4294704398U,      (u32 const   )945164165U,      (u32 const   )3575528878U,      (u32 const   )958871085U, 
        (u32 const   )3647212047U,      (u32 const   )2787207260U,      (u32 const   )1423022939U,      (u32 const   )775562294U, 
        (u32 const   )1739656202U,      (u32 const   )3876557655U,      (u32 const   )2530391278U,      (u32 const   )2443058075U, 
        (u32 const   )3310321856U,      (u32 const   )547512796U,      (u32 const   )1265195639U,      (u32 const   )437656594U, 
        (u32 const   )3121275539U,      (u32 const   )719700128U,      (u32 const   )3762502690U,      (u32 const   )387781147U, 
        (u32 const   )218828297U,      (u32 const   )3350065803U,      (u32 const   )2830708150U,      (u32 const   )2848461854U, 
        (u32 const   )428169201U,      (u32 const   )122466165U,      (u32 const   )3720081049U,      (u32 const   )1627235199U, 
        (u32 const   )648017665U,      (u32 const   )4122762354U,      (u32 const   )1002783846U,      (u32 const   )2117360635U, 
        (u32 const   )695634755U,      (u32 const   )3336358691U,      (u32 const   )4234721005U,      (u32 const   )4049844452U, 
        (u32 const   )3704280881U,      (u32 const   )2232435299U,      (u32 const   )574624663U,      (u32 const   )287343814U, 
        (u32 const   )612205898U,      (u32 const   )1039717051U,      (u32 const   )840019705U,      (u32 const   )2708326185U, 
        (u32 const   )793451934U,      (u32 const   )821288114U,      (u32 const   )1391201670U,      (u32 const   )3822090177U, 
        (u32 const   )376187827U,      (u32 const   )3113855344U,      (u32 const   )1224348052U,      (u32 const   )1679968233U, 
        (u32 const   )2361698556U,      (u32 const   )1058709744U,      (u32 const   )752375421U,      (u32 const   )2431590963U, 
        (u32 const   )1321699145U,      (u32 const   )3519142200U,      (u32 const   )2734591178U,      (u32 const   )188127444U, 
        (u32 const   )2177869557U,      (u32 const   )3727205754U,      (u32 const   )2384911031U,      (u32 const   )3215212461U, 
        (u32 const   )2648976442U,      (u32 const   )2450346104U,      (u32 const   )3432737375U,      (u32 const   )1180849278U, 
        (u32 const   )331544205U,      (u32 const   )3102249176U,      (u32 const   )4150144569U,      (u32 const   )2952102595U, 
        (u32 const   )2159976285U,      (u32 const   )2474404304U,      (u32 const   )766078933U,      (u32 const   )313773861U, 
        (u32 const   )2570832044U,      (u32 const   )2108100632U,      (u32 const   )1668212892U,      (u32 const   )3145456443U, 
        (u32 const   )2013908262U,      (u32 const   )418672217U,      (u32 const   )3070356634U,      (u32 const   )2594734927U, 
        (u32 const   )1852171925U,      (u32 const   )3867060991U,      (u32 const   )3473416636U,      (u32 const   )3907448597U, 
        (u32 const   )2614737639U,      (u32 const   )919489135U,      (u32 const   )164948639U,      (u32 const   )2094410160U, 
        (u32 const   )2997825956U,      (u32 const   )590424639U,      (u32 const   )2486224549U,      (u32 const   )1723872674U, 
        (u32 const   )3157750862U,      (u32 const   )3399941250U,      (u32 const   )3501252752U,      (u32 const   )3625268135U, 
        (u32 const   )2555048196U,      (u32 const   )3673637356U,      (u32 const   )1343127501U,      (u32 const   )4130281361U, 
        (u32 const   )3599595085U,      (u32 const   )2957853679U,      (u32 const   )1297403050U,      (u32 const   )81781910U, 
        (u32 const   )3051593425U,      (u32 const   )2283490410U,      (u32 const   )532201772U,      (u32 const   )1367295589U, 
        (u32 const   )3926170974U,      (u32 const   )895287692U,      (u32 const   )1953757831U,      (u32 const   )1093597963U, 
        (u32 const   )492483431U,      (u32 const   )3528626907U,      (u32 const   )1446242576U,      (u32 const   )1192455638U, 
        (u32 const   )1636604631U,      (u32 const   )209336225U,      (u32 const   )344873464U,      (u32 const   )1015671571U, 
        (u32 const   )669961897U,      (u32 const   )3375740769U,      (u32 const   )3857572124U,      (u32 const   )2973530695U, 
        (u32 const   )3747192018U,      (u32 const   )1933530610U,      (u32 const   )3464042516U,      (u32 const   )935293895U, 
        (u32 const   )3454686199U,      (u32 const   )2858115069U,      (u32 const   )1863638845U,      (u32 const   )3683022916U, 
        (u32 const   )4085369519U,      (u32 const   )3292445032U,      (u32 const   )875313188U,      (u32 const   )1080017571U, 
        (u32 const   )3279033885U,      (u32 const   )621591778U,      (u32 const   )1233856572U,      (u32 const   )2504130317U, 
        (u32 const   )24197544U,      (u32 const   )3017672716U,      (u32 const   )3835484340U,      (u32 const   )3247465558U, 
        (u32 const   )2220981195U,      (u32 const   )3060847922U,      (u32 const   )1551124588U,      (u32 const   )1463996600U};
#line 581 "rijndael.c"
static u32 const   Td3[256]  = 
#line 581
  {      (u32 const   )4104605777U,      (u32 const   )1097159550U,      (u32 const   )396673818U,      (u32 const   )660510266U, 
        (u32 const   )2875968315U,      (u32 const   )2638606623U,      (u32 const   )4200115116U,      (u32 const   )3808662347U, 
        (u32 const   )821712160U,      (u32 const   )1986918061U,      (u32 const   )3430322568U,      (u32 const   )38544885U, 
        (u32 const   )3856137295U,      (u32 const   )718002117U,      (u32 const   )893681702U,      (u32 const   )1654886325U, 
        (u32 const   )2975484382U,      (u32 const   )3122358053U,      (u32 const   )3926825029U,      (u32 const   )4274053469U, 
        (u32 const   )796197571U,      (u32 const   )1290801793U,      (u32 const   )1184342925U,      (u32 const   )3556361835U, 
        (u32 const   )2405426947U,      (u32 const   )2459735317U,      (u32 const   )1836772287U,      (u32 const   )1381620373U, 
        (u32 const   )3196267988U,      (u32 const   )1948373848U,      (u32 const   )3764988233U,      (u32 const   )3385345166U, 
        (u32 const   )3263785589U,      (u32 const   )2390325492U,      (u32 const   )1480485785U,      (u32 const   )3111247143U, 
        (u32 const   )3780097726U,      (u32 const   )2293045232U,      (u32 const   )548169417U,      (u32 const   )3459953789U, 
        (u32 const   )3746175075U,      (u32 const   )439452389U,      (u32 const   )1362321559U,      (u32 const   )1400849762U, 
        (u32 const   )1685577905U,      (u32 const   )1806599355U,      (u32 const   )2174754046U,      (u32 const   )137073913U, 
        (u32 const   )1214797936U,      (u32 const   )1174215055U,      (u32 const   )3731654548U,      (u32 const   )2079897426U, 
        (u32 const   )1943217067U,      (u32 const   )1258480242U,      (u32 const   )529487843U,      (u32 const   )1437280870U, 
        (u32 const   )3945269170U,      (u32 const   )3049390895U,      (u32 const   )3313212038U,      (u32 const   )923313619U, 
        (u32 const   )679998000U,      (u32 const   )3215307299U,      (u32 const   )57326082U,      (u32 const   )377642221U, 
        (u32 const   )3474729866U,      (u32 const   )2041877159U,      (u32 const   )133361907U,      (u32 const   )1776460110U, 
        (u32 const   )3673476453U,      (u32 const   )96392454U,      (u32 const   )878845905U,      (u32 const   )2801699524U, 
        (u32 const   )777231668U,      (u32 const   )4082475170U,      (u32 const   )2330014213U,      (u32 const   )4142626212U, 
        (u32 const   )2213296395U,      (u32 const   )1626319424U,      (u32 const   )1906247262U,      (u32 const   )1846563261U, 
        (u32 const   )562755902U,      (u32 const   )3708173718U,      (u32 const   )1040559837U,      (u32 const   )3871163981U, 
        (u32 const   )1418573201U,      (u32 const   )3294430577U,      (u32 const   )114585348U,      (u32 const   )1343618912U, 
        (u32 const   )2566595609U,      (u32 const   )3186202582U,      (u32 const   )1078185097U,      (u32 const   )3651041127U, 
        (u32 const   )3896688048U,      (u32 const   )2307622919U,      (u32 const   )425408743U,      (u32 const   )3371096953U, 
        (u32 const   )2081048481U,      (u32 const   )1108339068U,      (u32 const   )2216610296U,      (u32 const   )0U, 
        (u32 const   )2156299017U,      (u32 const   )736970802U,      (u32 const   )292596766U,      (u32 const   )1517440620U, 
        (u32 const   )251657213U,      (u32 const   )2235061775U,      (u32 const   )2933202493U,      (u32 const   )758720310U, 
        (u32 const   )265905162U,      (u32 const   )1554391400U,      (u32 const   )1532285339U,      (u32 const   )908999204U, 
        (u32 const   )174567692U,      (u32 const   )1474760595U,      (u32 const   )4002861748U,      (u32 const   )2610011675U, 
        (u32 const   )3234156416U,      (u32 const   )3693126241U,      (u32 const   )2001430874U,      (u32 const   )303699484U, 
        (u32 const   )2478443234U,      (u32 const   )2687165888U,      (u32 const   )585122620U,      (u32 const   )454499602U, 
        (u32 const   )151849742U,      (u32 const   )2345119218U,      (u32 const   )3064510765U,      (u32 const   )514443284U, 
        (u32 const   )4044981591U,      (u32 const   )1963412655U,      (u32 const   )2581445614U,      (u32 const   )2137062819U, 
        (u32 const   )19308535U,      (u32 const   )1928707164U,      (u32 const   )1715193156U,      (u32 const   )4219352155U, 
        (u32 const   )1126790795U,      (u32 const   )600235211U,      (u32 const   )3992742070U,      (u32 const   )3841024952U, 
        (u32 const   )836553431U,      (u32 const   )1669664834U,      (u32 const   )2535604243U,      (u32 const   )3323011204U, 
        (u32 const   )1243905413U,      (u32 const   )3141400786U,      (u32 const   )4180808110U,      (u32 const   )698445255U, 
        (u32 const   )2653899549U,      (u32 const   )2989552604U,      (u32 const   )2253581325U,      (u32 const   )3252932727U, 
        (u32 const   )3004591147U,      (u32 const   )1891211689U,      (u32 const   )2487810577U,      (u32 const   )3915653703U, 
        (u32 const   )4237083816U,      (u32 const   )4030667424U,      (u32 const   )2100090966U,      (u32 const   )865136418U, 
        (u32 const   )1229899655U,      (u32 const   )953270745U,      (u32 const   )3399679628U,      (u32 const   )3557504664U, 
        (u32 const   )4118925222U,      (u32 const   )2061379749U,      (u32 const   )3079546586U,      (u32 const   )2915017791U, 
        (u32 const   )983426092U,      (u32 const   )2022837584U,      (u32 const   )1607244650U,      (u32 const   )2118541908U, 
        (u32 const   )2366882550U,      (u32 const   )3635996816U,      (u32 const   )972512814U,      (u32 const   )3283088770U, 
        (u32 const   )1568718495U,      (u32 const   )3499326569U,      (u32 const   )3576539503U,      (u32 const   )621982671U, 
        (u32 const   )2895723464U,      (u32 const   )410887952U,      (u32 const   )2623762152U,      (u32 const   )1002142683U, 
        (u32 const   )645401037U,      (u32 const   )1494807662U,      (u32 const   )2595684844U,      (u32 const   )1335535747U, 
        (u32 const   )2507040230U,      (u32 const   )4293295786U,      (u32 const   )3167684641U,      (u32 const   )367585007U, 
        (u32 const   )3885750714U,      (u32 const   )1865862730U,      (u32 const   )2668221674U,      (u32 const   )2960971305U, 
        (u32 const   )2763173681U,      (u32 const   )1059270954U,      (u32 const   )2777952454U,      (u32 const   )2724642869U, 
        (u32 const   )1320957812U,      (u32 const   )2194319100U,      (u32 const   )2429595872U,      (u32 const   )2815956275U, 
        (u32 const   )77089521U,      (u32 const   )3973773121U,      (u32 const   )3444575871U,      (u32 const   )2448830231U, 
        (u32 const   )1305906550U,      (u32 const   )4021308739U,      (u32 const   )2857194700U,      (u32 const   )2516901860U, 
        (u32 const   )3518358430U,      (u32 const   )1787304780U,      (u32 const   )740276417U,      (u32 const   )1699839814U, 
        (u32 const   )1592394909U,      (u32 const   )2352307457U,      (u32 const   )2272556026U,      (u32 const   )188821243U, 
        (u32 const   )1729977011U,      (u32 const   )3687994002U,      (u32 const   )274084841U,      (u32 const   )3594982253U, 
        (u32 const   )3613494426U,      (u32 const   )2701949495U,      (u32 const   )4162096729U,      (u32 const   )322734571U, 
        (u32 const   )2837966542U,      (u32 const   )1640576439U,      (u32 const   )484830689U,      (u32 const   )1202797690U, 
        (u32 const   )3537852828U,      (u32 const   )4067639125U,      (u32 const   )349075736U,      (u32 const   )3342319475U, 
        (u32 const   )4157467219U,      (u32 const   )4255800159U,      (u32 const   )1030690015U,      (u32 const   )1155237496U, 
        (u32 const   )2951971274U,      (u32 const   )1757691577U,      (u32 const   )607398968U,      (u32 const   )2738905026U, 
        (u32 const   )499347990U,      (u32 const   )3794078908U,      (u32 const   )1011452712U,      (u32 const   )227885567U, 
        (u32 const   )2818666809U,      (u32 const   )213114376U,      (u32 const   )3034881240U,      (u32 const   )1455525988U, 
        (u32 const   )3414450555U,      (u32 const   )850817237U,      (u32 const   )1817998408U,      (u32 const   )3092726480U};
#line 647 "rijndael.c"
static u32 const   Td4[256]  = 
#line 647
  {      (u32 const   )1381126738U,      (u32 const   )151587081U,      (u32 const   )1785358954U,      (u32 const   )3587560917U, 
        (u32 const   )808464432U,      (u32 const   )909522486U,      (u32 const   )2779096485U,      (u32 const   )943208504U, 
        (u32 const   )3217014719U,      (u32 const   )1077952576U,      (u32 const   )2745410467U,      (u32 const   )2661195422U, 
        (u32 const   )2172748161U,      (u32 const   )4092851187U,      (u32 const   )3621246935U,      (u32 const   )4227595259U, 
        (u32 const   )2088533116U,      (u32 const   )3823363043U,      (u32 const   )960051513U,      (u32 const   )2189591170U, 
        (u32 const   )2610666395U,      (u32 const   )791621423U,      (u32 const   )4294967295U,      (u32 const   )2273806215U, 
        (u32 const   )875836468U,      (u32 const   )2391707278U,      (u32 const   )1128481603U,      (u32 const   )1145324612U, 
        (u32 const   )3301229764U,      (u32 const   )3739147998U,      (u32 const   )3924421097U,      (u32 const   )3419130827U, 
        (u32 const   )1414812756U,      (u32 const   )2071690107U,      (u32 const   )2492765332U,      (u32 const   )842150450U, 
        (u32 const   )2795939494U,      (u32 const   )3267543746U,      (u32 const   )589505315U,      (u32 const   )1027423549U, 
        (u32 const   )4008636142U,      (u32 const   )1280068684U,      (u32 const   )2509608341U,      (u32 const   )185273099U, 
        (u32 const   )1111638594U,      (u32 const   )4210752250U,      (u32 const   )3284386755U,      (u32 const   )1313754702U, 
        (u32 const   )134744072U,      (u32 const   )774778414U,      (u32 const   )2711724449U,      (u32 const   )1717986918U, 
        (u32 const   )673720360U,      (u32 const   )3654932953U,      (u32 const   )606348324U,      (u32 const   )2998055602U, 
        (u32 const   )1987475062U,      (u32 const   )1532713819U,      (u32 const   )2728567458U,      (u32 const   )1229539657U, 
        (u32 const   )1835887981U,      (u32 const   )2341178251U,      (u32 const   )3520188881U,      (u32 const   )623191333U, 
        (u32 const   )1920103026U,      (u32 const   )4177066232U,      (u32 const   )4143380214U,      (u32 const   )1684300900U, 
        (u32 const   )2256963206U,      (u32 const   )1751672936U,      (u32 const   )2560137368U,      (u32 const   )370546198U, 
        (u32 const   )3570717908U,      (u32 const   )2762253476U,      (u32 const   )1549556828U,      (u32 const   )3435973836U, 
        (u32 const   )1566399837U,      (u32 const   )1701143909U,      (u32 const   )3065427638U,      (u32 const   )2459079314U, 
        (u32 const   )1819044972U,      (u32 const   )1886417008U,      (u32 const   )1212696648U,      (u32 const   )1347440720U, 
        (u32 const   )4261281277U,      (u32 const   )3991793133U,      (u32 const   )3115956665U,      (u32 const   )3671775962U, 
        (u32 const   )1583242846U,      (u32 const   )353703189U,      (u32 const   )1179010630U,      (u32 const   )1465341783U, 
        (u32 const   )2812782503U,      (u32 const   )2374864269U,      (u32 const   )2644352413U,      (u32 const   )2223277188U, 
        (u32 const   )2425393296U,      (u32 const   )3638089944U,      (u32 const   )2880154539U,      (u32 const   )0U, 
        (u32 const   )2358021260U,      (u32 const   )3166485692U,      (u32 const   )3553874899U,      (u32 const   )168430090U, 
        (u32 const   )4160223223U,      (u32 const   )3840206052U,      (u32 const   )1482184792U,      (u32 const   )84215045U, 
        (u32 const   )3099113656U,      (u32 const   )3014898611U,      (u32 const   )1162167621U,      (u32 const   )101058054U, 
        (u32 const   )3503345872U,      (u32 const   )741092396U,      (u32 const   )505290270U,      (u32 const   )2408550287U, 
        (u32 const   )3402287818U,      (u32 const   )1061109567U,      (u32 const   )252645135U,      (u32 const   )33686018U, 
        (u32 const   )3250700737U,      (u32 const   )2947526575U,      (u32 const   )3183328701U,      (u32 const   )50529027U, 
        (u32 const   )16843009U,      (u32 const   )320017171U,      (u32 const   )2324335242U,      (u32 const   )1802201963U, 
        (u32 const   )976894522U,      (u32 const   )2442236305U,      (u32 const   )286331153U,      (u32 const   )1094795585U, 
        (u32 const   )1330597711U,      (u32 const   )1734829927U,      (u32 const   )3705461980U,      (u32 const   )3941264106U, 
        (u32 const   )2543294359U,      (u32 const   )4076008178U,      (u32 const   )3486502863U,      (u32 const   )3469659854U, 
        (u32 const   )4042322160U,      (u32 const   )3031741620U,      (u32 const   )3873892070U,      (u32 const   )1936946035U, 
        (u32 const   )2526451350U,      (u32 const   )2896997548U,      (u32 const   )1953789044U,      (u32 const   )572662306U, 
        (u32 const   )3890735079U,      (u32 const   )2913840557U,      (u32 const   )892679477U,      (u32 const   )2240120197U, 
        (u32 const   )3806520034U,      (u32 const   )4193909241U,      (u32 const   )926365495U,      (u32 const   )3907578088U, 
        (u32 const   )471604252U,      (u32 const   )1970632053U,      (u32 const   )3755991007U,      (u32 const   )1852730990U, 
        (u32 const   )1195853639U,      (u32 const   )4059165169U,      (u32 const   )437918234U,      (u32 const   )1903260017U, 
        (u32 const   )488447261U,      (u32 const   )690563369U,      (u32 const   )3318072773U,      (u32 const   )2307492233U, 
        (u32 const   )1869573999U,      (u32 const   )3082270647U,      (u32 const   )1650614882U,      (u32 const   )235802126U, 
        (u32 const   )2863311530U,      (u32 const   )404232216U,      (u32 const   )3200171710U,      (u32 const   )454761243U, 
        (u32 const   )4244438268U,      (u32 const   )1448498774U,      (u32 const   )1044266558U,      (u32 const   )1263225675U, 
        (u32 const   )3334915782U,      (u32 const   )3537031890U,      (u32 const   )2038004089U,      (u32 const   )538976288U, 
        (u32 const   )2593823386U,      (u32 const   )3688618971U,      (u32 const   )3233857728U,      (u32 const   )4278124286U, 
        (u32 const   )2021161080U,      (u32 const   )3452816845U,      (u32 const   )1515870810U,      (u32 const   )4109694196U, 
        (u32 const   )522133279U,      (u32 const   )3722304989U,      (u32 const   )2829625512U,      (u32 const   )858993459U, 
        (u32 const   )2290649224U,      (u32 const   )117901063U,      (u32 const   )3351758791U,      (u32 const   )825307441U, 
        (u32 const   )2981212593U,      (u32 const   )303174162U,      (u32 const   )269488144U,      (u32 const   )1499027801U, 
        (u32 const   )656877351U,      (u32 const   )2155905152U,      (u32 const   )3974950124U,      (u32 const   )1600085855U, 
        (u32 const   )1616928864U,      (u32 const   )1364283729U,      (u32 const   )2139062143U,      (u32 const   )2846468521U, 
        (u32 const   )421075225U,      (u32 const   )3048584629U,      (u32 const   )1246382666U,      (u32 const   )218959117U, 
        (u32 const   )757935405U,      (u32 const   )3857049061U,      (u32 const   )2054847098U,      (u32 const   )2678038431U, 
        (u32 const   )2475922323U,      (u32 const   )3385444809U,      (u32 const   )2627509404U,      (u32 const   )4025479151U, 
        (u32 const   )2694881440U,      (u32 const   )3772834016U,      (u32 const   )993737531U,      (u32 const   )1296911693U, 
        (u32 const   )2930683566U,      (u32 const   )707406378U,      (u32 const   )4126537205U,      (u32 const   )2964369584U, 
        (u32 const   )3368601800U,      (u32 const   )3958107115U,      (u32 const   )3149642683U,      (u32 const   )1010580540U, 
        (u32 const   )2206434179U,      (u32 const   )1397969747U,      (u32 const   )2576980377U,      (u32 const   )1633771873U, 
        (u32 const   )387389207U,      (u32 const   )724249387U,      (u32 const   )67372036U,      (u32 const   )2122219134U, 
        (u32 const   )3132799674U,      (u32 const   )2004318071U,      (u32 const   )3604403926U,      (u32 const   )640034342U, 
        (u32 const   )3789677025U,      (u32 const   )1768515945U,      (u32 const   )336860180U,      (u32 const   )1667457891U, 
        (u32 const   )1431655765U,      (u32 const   )555819297U,      (u32 const   )202116108U,      (u32 const   )2105376125U};
#line 713 "rijndael.c"
static u32 const   rcon[10]  = 
#line 713
  {      (u32 const   )16777216,      (u32 const   )33554432,      (u32 const   )67108864,      (u32 const   )134217728, 
        (u32 const   )268435456,      (u32 const   )536870912,      (u32 const   )1073741824,      (u32 const   )2147483648U, 
        (u32 const   )452984832,      (u32 const   )905969664};
#line 727 "rijndael.c"
static int rijndaelKeySetupEnc(u32 *rk , u8 const   *cipherKey , int keyBits ) 
{ int i ;
  u32 temp ;

  {
#line 728
  i = 0;
#line 731
  *(rk + 0) = ((((unsigned int )*(cipherKey + 0) << 24) ^ ((unsigned int )*(cipherKey + 1) << 16)) ^ ((unsigned int )*(cipherKey + 2) << 8)) ^ (unsigned int )*(cipherKey + 3);
#line 732
  *(rk + 1) = ((((unsigned int )*((cipherKey + 4) + 0) << 24) ^ ((unsigned int )*((cipherKey + 4) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 4) + 2) << 8)) ^ (unsigned int )*((cipherKey + 4) + 3);
#line 733
  *(rk + 2) = ((((unsigned int )*((cipherKey + 8) + 0) << 24) ^ ((unsigned int )*((cipherKey + 8) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 8) + 2) << 8)) ^ (unsigned int )*((cipherKey + 8) + 3);
#line 734
  *(rk + 3) = ((((unsigned int )*((cipherKey + 12) + 0) << 24) ^ ((unsigned int )*((cipherKey + 12) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 12) + 2) << 8)) ^ (unsigned int )*((cipherKey + 12) + 3);
#line 735
  if (keyBits == 128) {
#line 736
    while (1) {
#line 737
      temp = *(rk + 3);
#line 738
      *(rk + 4) = ((((*(rk + 0) ^ (unsigned int )(Te4[(temp >> 16) & 255U] & 4278190080U)) ^ (unsigned int )(Te4[(temp >> 8) & 255U] & 16711680U)) ^ (unsigned int )(Te4[temp & 255U] & 65280U)) ^ (unsigned int )(Te4[temp >> 24] & 255U)) ^ (unsigned int )rcon[i];
#line 744
      *(rk + 5) = *(rk + 1) ^ *(rk + 4);
#line 745
      *(rk + 6) = *(rk + 2) ^ *(rk + 5);
#line 746
      *(rk + 7) = *(rk + 3) ^ *(rk + 6);
#line 747
      i ++;
#line 747
      if (i == 10) {
#line 748
        return (10);
      }
#line 750
      rk += 4;
    }
  }
#line 753
  *(rk + 4) = ((((unsigned int )*((cipherKey + 16) + 0) << 24) ^ ((unsigned int )*((cipherKey + 16) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 16) + 2) << 8)) ^ (unsigned int )*((cipherKey + 16) + 3);
#line 754
  *(rk + 5) = ((((unsigned int )*((cipherKey + 20) + 0) << 24) ^ ((unsigned int )*((cipherKey + 20) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 20) + 2) << 8)) ^ (unsigned int )*((cipherKey + 20) + 3);
#line 755
  if (keyBits == 192) {
#line 756
    while (1) {
#line 757
      temp = *(rk + 5);
#line 758
      *(rk + 6) = ((((*(rk + 0) ^ (unsigned int )(Te4[(temp >> 16) & 255U] & 4278190080U)) ^ (unsigned int )(Te4[(temp >> 8) & 255U] & 16711680U)) ^ (unsigned int )(Te4[temp & 255U] & 65280U)) ^ (unsigned int )(Te4[temp >> 24] & 255U)) ^ (unsigned int )rcon[i];
#line 764
      *(rk + 7) = *(rk + 1) ^ *(rk + 6);
#line 765
      *(rk + 8) = *(rk + 2) ^ *(rk + 7);
#line 766
      *(rk + 9) = *(rk + 3) ^ *(rk + 8);
#line 767
      i ++;
#line 767
      if (i == 8) {
#line 768
        return (12);
      }
#line 770
      *(rk + 10) = *(rk + 4) ^ *(rk + 9);
#line 771
      *(rk + 11) = *(rk + 5) ^ *(rk + 10);
#line 772
      rk += 6;
    }
  }
#line 775
  *(rk + 6) = ((((unsigned int )*((cipherKey + 24) + 0) << 24) ^ ((unsigned int )*((cipherKey + 24) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 24) + 2) << 8)) ^ (unsigned int )*((cipherKey + 24) + 3);
#line 776
  *(rk + 7) = ((((unsigned int )*((cipherKey + 28) + 0) << 24) ^ ((unsigned int )*((cipherKey + 28) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 28) + 2) << 8)) ^ (unsigned int )*((cipherKey + 28) + 3);
#line 777
  if (keyBits == 256) {
#line 778
    while (1) {
#line 779
      temp = *(rk + 7);
#line 780
      *(rk + 8) = ((((*(rk + 0) ^ (unsigned int )(Te4[(temp >> 16) & 255U] & 4278190080U)) ^ (unsigned int )(Te4[(temp >> 8) & 255U] & 16711680U)) ^ (unsigned int )(Te4[temp & 255U] & 65280U)) ^ (unsigned int )(Te4[temp >> 24] & 255U)) ^ (unsigned int )rcon[i];
#line 786
      *(rk + 9) = *(rk + 1) ^ *(rk + 8);
#line 787
      *(rk + 10) = *(rk + 2) ^ *(rk + 9);
#line 788
      *(rk + 11) = *(rk + 3) ^ *(rk + 10);
#line 789
      i ++;
#line 789
      if (i == 7) {
#line 790
        return (14);
      }
#line 792
      temp = *(rk + 11);
#line 793
      *(rk + 12) = (((*(rk + 4) ^ (unsigned int )(Te4[temp >> 24] & 4278190080U)) ^ (unsigned int )(Te4[(temp >> 16) & 255U] & 16711680U)) ^ (unsigned int )(Te4[(temp >> 8) & 255U] & 65280U)) ^ (unsigned int )(Te4[temp & 255U] & 255U);
#line 798
      *(rk + 13) = *(rk + 5) ^ *(rk + 12);
#line 799
      *(rk + 14) = *(rk + 6) ^ *(rk + 13);
#line 800
      *(rk + 15) = *(rk + 7) ^ *(rk + 14);
#line 801
      rk += 8;
    }
  }
#line 804
  return (0);
}
}
#line 812 "rijndael.c"
static int rijndaelKeySetupDec(u32 *rk , u8 const   *cipherKey , int keyBits , int have_encrypt ) 
{ int Nr ;
  int i ;
  int j ;
  u32 temp ;

  {
#line 818
  if (have_encrypt) {
#line 819
    Nr = have_encrypt;
  } else {
#line 822
    Nr = rijndaelKeySetupEnc(rk, cipherKey, keyBits);
  }
#line 825
  i = 0;
#line 825
  j = 4 * Nr;
#line 825
  while (i < j) {
#line 826
    temp = *(rk + i);
#line 826
    *(rk + i) = *(rk + j);
#line 826
    *(rk + j) = temp;
#line 827
    temp = *(rk + (i + 1));
#line 827
    *(rk + (i + 1)) = *(rk + (j + 1));
#line 827
    *(rk + (j + 1)) = temp;
#line 828
    temp = *(rk + (i + 2));
#line 828
    *(rk + (i + 2)) = *(rk + (j + 2));
#line 828
    *(rk + (j + 2)) = temp;
#line 829
    temp = *(rk + (i + 3));
#line 829
    *(rk + (i + 3)) = *(rk + (j + 3));
#line 829
    *(rk + (j + 3)) = temp;
#line 825
    i += 4;
#line 825
    j -= 4;
  }
#line 832
  i = 1;
#line 832
  while (i < Nr) {
#line 833
    rk += 4;
#line 834
    *(rk + 0) = (unsigned int )(((Td0[Te4[*(rk + 0) >> 24] & 255U] ^ Td1[Te4[(*(rk + 0) >> 16) & 255U] & 255U]) ^ Td2[Te4[(*(rk + 0) >> 8) & 255U] & 255U]) ^ Td3[Te4[*(rk + 0) & 255U] & 255U]);
#line 839
    *(rk + 1) = (unsigned int )(((Td0[Te4[*(rk + 1) >> 24] & 255U] ^ Td1[Te4[(*(rk + 1) >> 16) & 255U] & 255U]) ^ Td2[Te4[(*(rk + 1) >> 8) & 255U] & 255U]) ^ Td3[Te4[*(rk + 1) & 255U] & 255U]);
#line 844
    *(rk + 2) = (unsigned int )(((Td0[Te4[*(rk + 2) >> 24] & 255U] ^ Td1[Te4[(*(rk + 2) >> 16) & 255U] & 255U]) ^ Td2[Te4[(*(rk + 2) >> 8) & 255U] & 255U]) ^ Td3[Te4[*(rk + 2) & 255U] & 255U]);
#line 849
    *(rk + 3) = (unsigned int )(((Td0[Te4[*(rk + 3) >> 24] & 255U] ^ Td1[Te4[(*(rk + 3) >> 16) & 255U] & 255U]) ^ Td2[Te4[(*(rk + 3) >> 8) & 255U] & 255U]) ^ Td3[Te4[*(rk + 3) & 255U] & 255U]);
#line 832
    i ++;
  }
#line 855
  return (Nr);
}
}
#line 858 "rijndael.c"
static void rijndaelEncrypt(u32 const   *rk , int Nr , u8 const   *pt , u8 *ct ) 
{ u32 s0 ;
  u32 s1 ;
  u32 s2 ;
  u32 s3 ;
  u32 t0 ;
  u32 t1 ;
  u32 t2 ;
  u32 t3 ;

  {
#line 868
  s0 = (((((unsigned int )*(pt + 0) << 24) ^ ((unsigned int )*(pt + 1) << 16)) ^ ((unsigned int )*(pt + 2) << 8)) ^ (unsigned int )*(pt + 3)) ^ (unsigned int )*(rk + 0);
#line 869
  s1 = (((((unsigned int )*((pt + 4) + 0) << 24) ^ ((unsigned int )*((pt + 4) + 1) << 16)) ^ ((unsigned int )*((pt + 4) + 2) << 8)) ^ (unsigned int )*((pt + 4) + 3)) ^ (unsigned int )*(rk + 1);
#line 870
  s2 = (((((unsigned int )*((pt + 8) + 0) << 24) ^ ((unsigned int )*((pt + 8) + 1) << 16)) ^ ((unsigned int )*((pt + 8) + 2) << 8)) ^ (unsigned int )*((pt + 8) + 3)) ^ (unsigned int )*(rk + 2);
#line 871
  s3 = (((((unsigned int )*((pt + 12) + 0) << 24) ^ ((unsigned int )*((pt + 12) + 1) << 16)) ^ ((unsigned int )*((pt + 12) + 2) << 8)) ^ (unsigned int )*((pt + 12) + 3)) ^ (unsigned int )*(rk + 3);
#line 874
  t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 4));
#line 875
  t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 5));
#line 876
  t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 6));
#line 877
  t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 7));
#line 879
  s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 8));
#line 880
  s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 9));
#line 881
  s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 10));
#line 882
  s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 11));
#line 884
  t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 12));
#line 885
  t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 13));
#line 886
  t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 14));
#line 887
  t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 15));
#line 889
  s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 16));
#line 890
  s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 17));
#line 891
  s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 18));
#line 892
  s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 19));
#line 894
  t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 20));
#line 895
  t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 21));
#line 896
  t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 22));
#line 897
  t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 23));
#line 899
  s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 24));
#line 900
  s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 25));
#line 901
  s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 26));
#line 902
  s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 27));
#line 904
  t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 28));
#line 905
  t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 29));
#line 906
  t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 30));
#line 907
  t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 31));
#line 909
  s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 32));
#line 910
  s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 33));
#line 911
  s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 34));
#line 912
  s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 35));
#line 914
  t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 36));
#line 915
  t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 37));
#line 916
  t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 38));
#line 917
  t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 39));
#line 918
  if (Nr > 10) {
#line 920
    s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 40));
#line 921
    s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 41));
#line 922
    s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 42));
#line 923
    s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 43));
#line 925
    t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 44));
#line 926
    t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 45));
#line 927
    t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 46));
#line 928
    t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 47));
#line 929
    if (Nr > 12) {
#line 931
      s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 48));
#line 932
      s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 49));
#line 933
      s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 50));
#line 934
      s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 51));
#line 936
      t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 52));
#line 937
      t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 53));
#line 938
      t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 54));
#line 939
      t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 55));
    }
  }
#line 942
  rk += Nr << 2;
#line 1009
  s0 = (unsigned int )(((((Te4[t0 >> 24] & 4278190080U) ^ (Te4[(t1 >> 16) & 255U] & 16711680U)) ^ (Te4[(t2 >> 8) & 255U] & 65280U)) ^ (Te4[t3 & 255U] & 255U)) ^ *(rk + 0));
#line 1015
  *(ct + 0) = (unsigned char )(s0 >> 24);
#line 1015
  *(ct + 1) = (unsigned char )(s0 >> 16);
#line 1015
  *(ct + 2) = (unsigned char )(s0 >> 8);
#line 1015
  *(ct + 3) = (unsigned char )s0;
#line 1016
  s1 = (unsigned int )(((((Te4[t1 >> 24] & 4278190080U) ^ (Te4[(t2 >> 16) & 255U] & 16711680U)) ^ (Te4[(t3 >> 8) & 255U] & 65280U)) ^ (Te4[t0 & 255U] & 255U)) ^ *(rk + 1));
#line 1022
  *((ct + 4) + 0) = (unsigned char )(s1 >> 24);
#line 1022
  *((ct + 4) + 1) = (unsigned char )(s1 >> 16);
#line 1022
  *((ct + 4) + 2) = (unsigned char )(s1 >> 8);
#line 1022
  *((ct + 4) + 3) = (unsigned char )s1;
#line 1023
  s2 = (unsigned int )(((((Te4[t2 >> 24] & 4278190080U) ^ (Te4[(t3 >> 16) & 255U] & 16711680U)) ^ (Te4[(t0 >> 8) & 255U] & 65280U)) ^ (Te4[t1 & 255U] & 255U)) ^ *(rk + 2));
#line 1029
  *((ct + 8) + 0) = (unsigned char )(s2 >> 24);
#line 1029
  *((ct + 8) + 1) = (unsigned char )(s2 >> 16);
#line 1029
  *((ct + 8) + 2) = (unsigned char )(s2 >> 8);
#line 1029
  *((ct + 8) + 3) = (unsigned char )s2;
#line 1030
  s3 = (unsigned int )(((((Te4[t3 >> 24] & 4278190080U) ^ (Te4[(t0 >> 16) & 255U] & 16711680U)) ^ (Te4[(t1 >> 8) & 255U] & 65280U)) ^ (Te4[t2 & 255U] & 255U)) ^ *(rk + 3));
#line 1036
  *((ct + 12) + 0) = (unsigned char )(s3 >> 24);
#line 1036
  *((ct + 12) + 1) = (unsigned char )(s3 >> 16);
#line 1036
  *((ct + 12) + 2) = (unsigned char )(s3 >> 8);
#line 1036
  *((ct + 12) + 3) = (unsigned char )s3;
#line 1037
  return;
}
}
#line 1039 "rijndael.c"
static void rijndaelDecrypt(u32 const   *rk , int Nr , u8 const   *ct , u8 *pt ) 
{ u32 s0 ;
  u32 s1 ;
  u32 s2 ;
  u32 s3 ;
  u32 t0 ;
  u32 t1 ;
  u32 t2 ;
  u32 t3 ;

  {
#line 1049
  s0 = (((((unsigned int )*(ct + 0) << 24) ^ ((unsigned int )*(ct + 1) << 16)) ^ ((unsigned int )*(ct + 2) << 8)) ^ (unsigned int )*(ct + 3)) ^ (unsigned int )*(rk + 0);
#line 1050
  s1 = (((((unsigned int )*((ct + 4) + 0) << 24) ^ ((unsigned int )*((ct + 4) + 1) << 16)) ^ ((unsigned int )*((ct + 4) + 2) << 8)) ^ (unsigned int )*((ct + 4) + 3)) ^ (unsigned int )*(rk + 1);
#line 1051
  s2 = (((((unsigned int )*((ct + 8) + 0) << 24) ^ ((unsigned int )*((ct + 8) + 1) << 16)) ^ ((unsigned int )*((ct + 8) + 2) << 8)) ^ (unsigned int )*((ct + 8) + 3)) ^ (unsigned int )*(rk + 2);
#line 1052
  s3 = (((((unsigned int )*((ct + 12) + 0) << 24) ^ ((unsigned int )*((ct + 12) + 1) << 16)) ^ ((unsigned int )*((ct + 12) + 2) << 8)) ^ (unsigned int )*((ct + 12) + 3)) ^ (unsigned int )*(rk + 3);
#line 1055
  t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 4));
#line 1056
  t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 5));
#line 1057
  t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 6));
#line 1058
  t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 7));
#line 1060
  s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 8));
#line 1061
  s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 9));
#line 1062
  s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 10));
#line 1063
  s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 11));
#line 1065
  t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 12));
#line 1066
  t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 13));
#line 1067
  t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 14));
#line 1068
  t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 15));
#line 1070
  s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 16));
#line 1071
  s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 17));
#line 1072
  s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 18));
#line 1073
  s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 19));
#line 1075
  t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 20));
#line 1076
  t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 21));
#line 1077
  t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 22));
#line 1078
  t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 23));
#line 1080
  s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 24));
#line 1081
  s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 25));
#line 1082
  s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 26));
#line 1083
  s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 27));
#line 1085
  t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 28));
#line 1086
  t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 29));
#line 1087
  t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 30));
#line 1088
  t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 31));
#line 1090
  s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 32));
#line 1091
  s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 33));
#line 1092
  s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 34));
#line 1093
  s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 35));
#line 1095
  t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 36));
#line 1096
  t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 37));
#line 1097
  t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 38));
#line 1098
  t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 39));
#line 1099
  if (Nr > 10) {
#line 1101
    s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 40));
#line 1102
    s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 41));
#line 1103
    s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 42));
#line 1104
    s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 43));
#line 1106
    t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 44));
#line 1107
    t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 45));
#line 1108
    t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 46));
#line 1109
    t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 47));
#line 1110
    if (Nr > 12) {
#line 1112
      s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 48));
#line 1113
      s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 49));
#line 1114
      s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 50));
#line 1115
      s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 51));
#line 1117
      t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 52));
#line 1118
      t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 53));
#line 1119
      t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 54));
#line 1120
      t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 55));
    }
  }
#line 1123
  rk += Nr << 2;
#line 1190
  s0 = (unsigned int )(((((Td4[t0 >> 24] & 4278190080U) ^ (Td4[(t3 >> 16) & 255U] & 16711680U)) ^ (Td4[(t2 >> 8) & 255U] & 65280U)) ^ (Td4[t1 & 255U] & 255U)) ^ *(rk + 0));
#line 1196
  *(pt + 0) = (unsigned char )(s0 >> 24);
#line 1196
  *(pt + 1) = (unsigned char )(s0 >> 16);
#line 1196
  *(pt + 2) = (unsigned char )(s0 >> 8);
#line 1196
  *(pt + 3) = (unsigned char )s0;
#line 1197
  s1 = (unsigned int )(((((Td4[t1 >> 24] & 4278190080U) ^ (Td4[(t0 >> 16) & 255U] & 16711680U)) ^ (Td4[(t3 >> 8) & 255U] & 65280U)) ^ (Td4[t2 & 255U] & 255U)) ^ *(rk + 1));
#line 1203
  *((pt + 4) + 0) = (unsigned char )(s1 >> 24);
#line 1203
  *((pt + 4) + 1) = (unsigned char )(s1 >> 16);
#line 1203
  *((pt + 4) + 2) = (unsigned char )(s1 >> 8);
#line 1203
  *((pt + 4) + 3) = (unsigned char )s1;
#line 1204
  s2 = (unsigned int )(((((Td4[t2 >> 24] & 4278190080U) ^ (Td4[(t1 >> 16) & 255U] & 16711680U)) ^ (Td4[(t0 >> 8) & 255U] & 65280U)) ^ (Td4[t3 & 255U] & 255U)) ^ *(rk + 2));
#line 1210
  *((pt + 8) + 0) = (unsigned char )(s2 >> 24);
#line 1210
  *((pt + 8) + 1) = (unsigned char )(s2 >> 16);
#line 1210
  *((pt + 8) + 2) = (unsigned char )(s2 >> 8);
#line 1210
  *((pt + 8) + 3) = (unsigned char )s2;
#line 1211
  s3 = (unsigned int )(((((Td4[t3 >> 24] & 4278190080U) ^ (Td4[(t2 >> 16) & 255U] & 16711680U)) ^ (Td4[(t1 >> 8) & 255U] & 65280U)) ^ (Td4[t0 & 255U] & 255U)) ^ *(rk + 3));
#line 1217
  *((pt + 12) + 0) = (unsigned char )(s3 >> 24);
#line 1217
  *((pt + 12) + 1) = (unsigned char )(s3 >> 16);
#line 1217
  *((pt + 12) + 2) = (unsigned char )(s3 >> 8);
#line 1217
  *((pt + 12) + 3) = (unsigned char )s3;
#line 1218
  return;
}
}
#line 1220 "rijndael.c"
void rijndael_set_key(rijndael_ctx *ctx , u_char *key , int bits , int encrypt ) 
{ 

  {
#line 1223
  ctx->Nr = rijndaelKeySetupEnc(ctx->ek, (u8 const   *)key, bits);
#line 1224
  if (encrypt) {
#line 1225
    ctx->decrypt = 0;
#line 1226
    memset((void *)(ctx->dk), 0, sizeof(ctx->dk));
  } else {
#line 1228
    ctx->decrypt = 1;
#line 1229
    memcpy((void * __restrict  )(ctx->dk), (void const   * __restrict  )(ctx->ek),
           sizeof(ctx->ek));
#line 1230
    rijndaelKeySetupDec(ctx->dk, (u8 const   *)key, bits, ctx->Nr);
  }
#line 1232
  return;
}
}
#line 1234 "rijndael.c"
void rijndael_decrypt(rijndael_ctx *ctx , u_char *src , u_char *dst ) 
{ 

  {
#line 1237
  rijndaelDecrypt((u32 const   *)(ctx->dk), ctx->Nr, (u8 const   *)src, (u8 *)dst);
#line 1238
  return;
}
}
#line 1240 "rijndael.c"
void rijndael_encrypt(rijndael_ctx *ctx , u_char *src , u_char *dst ) 
{ 

  {
#line 1243
  rijndaelEncrypt((u32 const   *)(ctx->ek), ctx->Nr, (u8 const   *)src, (u8 *)dst);
#line 1244
  return;
}
}
#line 1 "entropy.o"
#line 31 "entropy.h"
void init_rng(void) ;
#line 109 "/usr/include/openssl/rand.h"
extern int RAND_status(void) ;
#line 381 "/usr/include/openssl/crypto.h"
extern unsigned long SSLeay(void) ;
#line 55 "entropy.c"
void seed_rng(void) 
{ int tmp ;

  {
#line 132
  tmp = RAND_status();
#line 132
  if (tmp != 1) {
#line 133
    fatal("PRNG is not seeded");
  }
#line 134
  return;
}
}
#line 136 "entropy.c"
void init_rng(void) 
{ unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 143
  tmp___0 = SSLeay();
#line 143
  if ((tmp___0 ^ 9469999UL) & 4294963215UL) {
#line 144
    tmp = SSLeay();
#line 144
    fatal("OpenSSL version mismatch. Built against %lx, you have %lx", 9469999L, tmp);
  }
#line 153
  return;
}
}
/* compiler builtin: 
   unsigned int __builtin_strcspn(char const   * , char const   * ) ;  */
#line 1 "readpass.o"
#line 143 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 218
extern int fflush(FILE *__stream ) ;
#line 384 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 493
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 537
extern  __attribute__((__nothrow__)) int execlp(char const   *__file , char const   *__arg 
                                                , ...)  __attribute__((__nonnull__(1))) ;
#line 667
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 677
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 723
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 19 "readpass.h"
char *read_passphrase(char const   *prompt , int flags ) ;
#line 34 "readpass.c"
static char *ssh_askpass(char *askpass , char const   *msg ) 
{ pid_t pid ;
  size_t len ;
  char *pass ;
  int p[2] ;
  int status ;
  int ret ;
  char buf___1[1024] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  __uid_t tmp___9 ;
  __uid_t tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int *tmp___16 ;
  int *tmp___17 ;
  __pid_t tmp___18 ;
  unsigned int tmp___51 ;

  {
#line 43
  tmp___1 = fflush(stdout);
#line 43
  if (tmp___1 != 0) {
#line 44
    tmp = __errno_location();
#line 44
    tmp___0 = strerror(*tmp);
#line 44
    error("ssh_askpass: fflush: %s", tmp___0);
  }
#line 45
  if ((unsigned int )askpass == (unsigned int )((void *)0)) {
#line 46
    fatal("internal error: askpass undefined");
  }
#line 47
  tmp___5 = pipe((int *)(p));
#line 47
  if (tmp___5 < 0) {
#line 48
    tmp___2 = __errno_location();
#line 48
    tmp___3 = strerror(*tmp___2);
#line 48
    error("ssh_askpass: pipe: %s", tmp___3);
#line 49
    tmp___4 = xstrdup("");
#line 49
    return (tmp___4);
  }
#line 51
  pid = fork();
#line 51
  if (pid < 0) {
#line 52
    tmp___6 = __errno_location();
#line 52
    tmp___7 = strerror(*tmp___6);
#line 52
    error("ssh_askpass: fork: %s", tmp___7);
#line 53
    tmp___8 = xstrdup("");
#line 53
    return (tmp___8);
  }
#line 55
  if (pid == 0) {
#line 56
    tmp___9 = getuid();
#line 56
    seteuid(tmp___9);
#line 57
    tmp___10 = getuid();
#line 57
    setuid(tmp___10);
#line 58
    close(p[0]);
#line 59
    tmp___13 = dup2(p[1], 1);
#line 59
    if (tmp___13 < 0) {
#line 60
      tmp___11 = __errno_location();
#line 60
      tmp___12 = strerror(*tmp___11);
#line 60
      fatal("ssh_askpass: dup2: %s", tmp___12);
    }
#line 61
    execlp((char const   *)askpass, (char const   *)askpass, msg, (char *)0);
#line 62
    tmp___14 = __errno_location();
#line 62
    tmp___15 = strerror(*tmp___14);
#line 62
    fatal("ssh_askpass: exec(%s): %s", askpass, tmp___15);
  }
#line 64
  close(p[1]);
#line 66
  ret = 0;
#line 66
  len = (unsigned int )ret;
#line 67
  while (1) {
#line 68
    ret = read(p[0], (void *)(buf___1 + len), (sizeof(buf___1) - 1U) - len);
#line 69
    if (ret == -1) {
#line 69
      tmp___16 = __errno_location();
#line 69
      if (*tmp___16 == 4) {
        goto __Cont;
      }
    }
#line 71
    if (ret <= 0) {
#line 72
      break;
    }
#line 73
    len += (size_t )ret;
    __Cont: /* CIL Label */ 
#line 67
    if (! ((sizeof(buf___1) - 1U) - len > 0U)) {
#line 67
      break;
    }
  }
#line 75
  buf___1[len] = (char )'\000';
#line 77
  close(p[0]);
#line 78
  while (1) {
#line 78
    tmp___18 = waitpid(pid, & status, 0);
#line 78
    if (! (tmp___18 < 0)) {
#line 78
      break;
    }
#line 79
    tmp___17 = __errno_location();
#line 79
    if (*tmp___17 != 4) {
#line 80
      break;
    }
  }
#line 82
  tmp___51 = __builtin_strcspn((char const   *)(buf___1), "\r\n");
#line 82
  buf___1[tmp___51] = (char )'\000';
#line 83
  pass = xstrdup((char const   *)(buf___1));
#line 84
  memset((void *)(buf___1), 0, sizeof(buf___1));
#line 85
  return (pass);
}
}
#line 94 "readpass.c"
char *read_passphrase(char const   *prompt , int flags ) 
{ char *askpass ;
  char *ret ;
  char buf___1[1024] ;
  int rppflags ;
  int use_askpass ;
  int ttyfd ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 97
  askpass = (char *)((void *)0);
#line 98
  use_askpass = 0;
#line 100
  if (flags & 1) {
#line 100
    rppflags = 1;
  } else {
#line 100
    rppflags = 0;
  }
#line 101
  if (flags & 2) {
#line 102
    tmp = isatty(0);
#line 102
    if (! tmp) {
#line 103
      use_askpass = 1;
    }
  } else {
#line 105
    rppflags |= 2;
#line 106
    ttyfd = open("/dev/tty", 2);
#line 107
    if (ttyfd >= 0) {
#line 108
      close(ttyfd);
    } else {
#line 110
      use_askpass = 1;
    }
  }
#line 113
  if (use_askpass) {
#line 113
    tmp___2 = getenv("DISPLAY");
#line 113
    if (tmp___2) {
#line 114
      tmp___0 = getenv("SSH_ASKPASS");
#line 114
      if (tmp___0) {
#line 115
        askpass = getenv("SSH_ASKPASS");
      } else {
#line 117
        askpass = (char *)"/usr/local/libexec/ssh-askpass";
      }
#line 118
      tmp___1 = ssh_askpass(askpass, prompt);
#line 118
      return (tmp___1);
    }
  }
#line 121
  tmp___4 = readpassphrase(prompt, buf___1, sizeof(buf___1), rppflags);
#line 121
  if ((unsigned int )tmp___4 == (unsigned int )((void *)0)) {
#line 122
    if (flags & 4) {
#line 123
      return ((char *)((void *)0));
    }
#line 124
    tmp___3 = xstrdup("");
#line 124
    return (tmp___3);
  }
#line 127
  ret = xstrdup((char const   *)(buf___1));
#line 128
  memset((void *)(buf___1), 'x', sizeof(buf___1));
#line 129
  return (ret);
}
}
#line 1 "rsa.o"
#line 391 "/usr/include/openssl/bn.h"
extern BIGNUM const   *BN_value_one(void) ;
#line 393
extern BN_CTX *BN_CTX_new(void) ;
#line 397
extern void BN_CTX_free(BN_CTX *c ) ;
#line 416
extern int BN_sub(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *b ) ;
#line 433
extern int BN_div(BIGNUM *dv , BIGNUM *rem , BIGNUM const   *m , BIGNUM const   *d ,
                  BN_CTX *ctx ) ;
#line 230 "/usr/include/openssl/rsa.h"
extern int RSA_public_encrypt(int flen , unsigned char const   *from , unsigned char *to ,
                              RSA *rsa , int padding ) ;
#line 236
extern int RSA_private_decrypt(int flen , unsigned char const   *from , unsigned char *to ,
                               RSA *rsa , int padding ) ;
#line 22 "rsa.h"
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 23
int rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 69 "rsa.c"
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ u_char *inbuf ;
  u_char *outbuf ;
  int len ;
  int ilen ;
  int olen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 75
  tmp = BN_num_bits((BIGNUM const   *)key->e);
#line 75
  if (tmp < 2) {
#line 76
    fatal("rsa_public_encrypt() exponent too small or not odd");
  } else {
#line 75
    if ((key->e)->top > 0) {
#line 75
      if (! (*((key->e)->d + 0) & 1UL)) {
#line 76
        fatal("rsa_public_encrypt() exponent too small or not odd");
      }
    } else {
#line 76
      fatal("rsa_public_encrypt() exponent too small or not odd");
    }
  }
#line 78
  tmp___0 = BN_num_bits((BIGNUM const   *)key->n);
#line 78
  olen = (tmp___0 + 7) / 8;
#line 79
  tmp___1 = xmalloc((unsigned int )olen);
#line 79
  outbuf = (u_char *)tmp___1;
#line 81
  tmp___2 = BN_num_bits((BIGNUM const   *)in);
#line 81
  ilen = (tmp___2 + 7) / 8;
#line 82
  tmp___3 = xmalloc((unsigned int )ilen);
#line 82
  inbuf = (u_char *)tmp___3;
#line 83
  BN_bn2bin((BIGNUM const   *)in, inbuf);
#line 85
  len = RSA_public_encrypt(ilen, (unsigned char const   *)inbuf, outbuf, key, 1);
#line 85
  if (len <= 0) {
#line 87
    fatal("rsa_public_encrypt() failed");
  }
#line 89
  BN_bin2bn((unsigned char const   *)outbuf, len, out);
#line 91
  memset((void *)outbuf, 0, (unsigned int )olen);
#line 92
  memset((void *)inbuf, 0, (unsigned int )ilen);
#line 93
  xfree((void *)outbuf);
#line 94
  xfree((void *)inbuf);
#line 95
  return;
}
}
#line 97 "rsa.c"
int rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ u_char *inbuf ;
  u_char *outbuf ;
  int len ;
  int ilen ;
  int olen ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 103
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 103
  olen = (tmp + 7) / 8;
#line 104
  tmp___0 = xmalloc((unsigned int )olen);
#line 104
  outbuf = (u_char *)tmp___0;
#line 106
  tmp___1 = BN_num_bits((BIGNUM const   *)in);
#line 106
  ilen = (tmp___1 + 7) / 8;
#line 107
  tmp___2 = xmalloc((unsigned int )ilen);
#line 107
  inbuf = (u_char *)tmp___2;
#line 108
  BN_bn2bin((BIGNUM const   *)in, inbuf);
#line 110
  len = RSA_private_decrypt(ilen, (unsigned char const   *)inbuf, outbuf, key, 1);
#line 110
  if (len <= 0) {
#line 112
    error("rsa_private_decrypt() failed");
  } else {
#line 114
    BN_bin2bn((unsigned char const   *)outbuf, len, out);
  }
#line 116
  memset((void *)outbuf, 0, (unsigned int )olen);
#line 117
  memset((void *)inbuf, 0, (unsigned int )ilen);
#line 118
  xfree((void *)outbuf);
#line 119
  xfree((void *)inbuf);
#line 120
  return (len);
}
}
#line 124 "rsa.c"
void rsa_generate_additional_parameters(RSA *rsa ) 
{ BIGNUM *aux ;
  BN_CTX *ctx ;
  BIGNUM const   *tmp ;
  BIGNUM const   *tmp___0 ;

  {
#line 130
  aux = BN_new();
#line 130
  if ((unsigned int )aux == (unsigned int )((void *)0)) {
#line 131
    fatal("rsa_generate_additional_parameters: BN_new failed");
  }
#line 132
  ctx = BN_CTX_new();
#line 132
  if ((unsigned int )ctx == (unsigned int )((void *)0)) {
#line 133
    fatal("rsa_generate_additional_parameters: BN_CTX_new failed");
  }
#line 135
  tmp = BN_value_one();
#line 135
  BN_sub(aux, (BIGNUM const   *)rsa->q, tmp);
#line 136
  BN_div((BIGNUM *)((void *)0), rsa->dmq1, (BIGNUM const   *)rsa->d, (BIGNUM const   *)aux,
         ctx);
#line 138
  tmp___0 = BN_value_one();
#line 138
  BN_sub(aux, (BIGNUM const   *)rsa->p, tmp___0);
#line 139
  BN_div((BIGNUM *)((void *)0), rsa->dmp1, (BIGNUM const   *)rsa->d, (BIGNUM const   *)aux,
         ctx);
#line 141
  BN_clear_free(aux);
#line 142
  BN_CTX_free(ctx);
#line 143
  return;
}
}
#line 1 "scard.o"
#line 1 "scard-opensc.o"
#line 1 "ssh-dss.o"
#line 175 "/usr/include/openssl/dsa.h"
extern DSA_SIG *DSA_SIG_new(void) ;
#line 176
extern void DSA_SIG_free(DSA_SIG *a ) ;
#line 180
extern DSA_SIG *DSA_do_sign(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
#line 181
extern int DSA_do_verify(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                         DSA *dsa ) ;
#line 42 "ssh-dss.c"
int ssh_dss_sign(Key *key , u_char **sigp , u_int *lenp , u_char *data , u_int datalen ) 
{ DSA_SIG *sig ;
  EVP_MD const   *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  u_char *ret ;
  u_char digest___1[64] ;
  u_char sigblob[40] ;
  u_int rlen ;
  u_int slen ;
  u_int len ;
  u_int dlen ;
  Buffer b ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 47
  tmp = EVP_sha1();
#line 47
  evp_md = tmp;
#line 53
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 54
    error("ssh_dss_sign: no DSA key");
#line 55
    return (-1);
  } else {
#line 53
    if (key->type != 2) {
#line 54
      error("ssh_dss_sign: no DSA key");
#line 55
      return (-1);
    } else {
#line 53
      if ((unsigned int )key->dsa == (unsigned int )((void *)0)) {
#line 54
        error("ssh_dss_sign: no DSA key");
#line 55
        return (-1);
      }
    }
  }
#line 57
  EVP_DigestInit(& md, evp_md);
#line 58
  EVP_DigestUpdate(& md, (void const   *)data, datalen);
#line 59
  EVP_DigestFinal(& md, digest___1, & dlen);
#line 61
  sig = DSA_do_sign((unsigned char const   *)(digest___1), (int )dlen, key->dsa);
#line 62
  memset((void *)(digest___1), 'd', sizeof(digest___1));
#line 64
  if ((unsigned int )sig == (unsigned int )((void *)0)) {
#line 65
    error("ssh_dss_sign: sign failed");
#line 66
    return (-1);
  }
#line 69
  tmp___0 = BN_num_bits((BIGNUM const   *)sig->r);
#line 69
  rlen = (unsigned int )((tmp___0 + 7) / 8);
#line 70
  tmp___1 = BN_num_bits((BIGNUM const   *)sig->s);
#line 70
  slen = (unsigned int )((tmp___1 + 7) / 8);
#line 71
  if (rlen > 20U) {
#line 72
    error("bad sig size %u %u", rlen, slen);
#line 73
    DSA_SIG_free(sig);
#line 74
    return (-1);
  } else {
#line 71
    if (slen > 20U) {
#line 72
      error("bad sig size %u %u", rlen, slen);
#line 73
      DSA_SIG_free(sig);
#line 74
      return (-1);
    }
  }
#line 76
  memset((void *)(sigblob), 0, 40U);
#line 77
  BN_bn2bin((BIGNUM const   *)sig->r, ((sigblob + 40) - 20) - rlen);
#line 78
  BN_bn2bin((BIGNUM const   *)sig->s, (sigblob + 40) - slen);
#line 79
  DSA_SIG_free(sig);
#line 81
  if (datafellows & 1) {
#line 82
    tmp___2 = xmalloc(40U);
#line 82
    ret = (u_char *)tmp___2;
#line 83
    memcpy((void * __restrict  )ret, (void const   * __restrict  )(sigblob), 40U);
#line 84
    if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 85
      *lenp = 40U;
    }
#line 86
    if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 87
      *sigp = ret;
    }
  } else {
#line 90
    buffer_init(& b);
#line 91
    buffer_put_cstring(& b, "ssh-dss");
#line 92
    buffer_put_string(& b, (void const   *)(sigblob), 40U);
#line 93
    len = buffer_len(& b);
#line 94
    tmp___3 = xmalloc(len);
#line 94
    ret = (u_char *)tmp___3;
#line 95
    tmp___4 = buffer_ptr(& b);
#line 95
    memcpy((void * __restrict  )ret, (void const   * __restrict  )tmp___4, len);
#line 96
    buffer_free(& b);
#line 97
    if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 98
      *lenp = len;
    }
#line 99
    if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 100
      *sigp = ret;
    }
  }
#line 102
  return (0);
}
}
#line 104 "ssh-dss.c"
int ssh_dss_verify(Key *key , u_char *signature , u_int signaturelen , u_char *data ,
                   u_int datalen ) 
{ DSA_SIG *sig ;
  EVP_MD const   *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  u_char digest___1[64] ;
  u_char *sigblob ;
  u_int len ;
  u_int dlen ;
  int rlen ;
  int ret ;
  Buffer b ;
  char *ktype ;
  void *tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  void *tmp___11 ;
  u_int tmp___12 ;
  char const   *tmp___14 ;

  {
#line 109
  tmp = EVP_sha1();
#line 109
  evp_md = tmp;
#line 116
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 117
    error("ssh_dss_verify: no DSA key");
#line 118
    return (-1);
  } else {
#line 116
    if (key->type != 2) {
#line 117
      error("ssh_dss_verify: no DSA key");
#line 118
      return (-1);
    } else {
#line 116
      if ((unsigned int )key->dsa == (unsigned int )((void *)0)) {
#line 117
        error("ssh_dss_verify: no DSA key");
#line 118
        return (-1);
      }
    }
  }
#line 122
  if (datafellows & 1) {
#line 123
    sigblob = signature;
#line 124
    len = signaturelen;
  } else {
#line 128
    buffer_init(& b);
#line 129
    buffer_append(& b, (void const   *)signature, signaturelen);
#line 130
    tmp___0 = buffer_get_string(& b, (u_int *)((void *)0));
#line 130
    ktype = (char *)tmp___0;
#line 131
    if (0) {
#line 131
      __s1_len = strlen("ssh-dss");
#line 131
      __s2_len = strlen((char const   *)ktype);
#line 131
      if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
        goto _L___0;
      } else {
#line 131
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 131
          if (! ((unsigned int )((void const   *)(ktype + 1)) - (unsigned int )((void const   *)ktype) == 1U)) {
#line 131
            tmp___10 = 1;
          } else {
#line 131
            if (__s2_len >= 4U) {
#line 131
              tmp___10 = 1;
            } else {
#line 131
              tmp___10 = 0;
            }
          }
        } else {
#line 131
          tmp___10 = 0;
        }
      }
#line 131
      if (tmp___10) {
#line 131
        tmp___6 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
      } else {
#line 131
        tmp___9 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
#line 131
        tmp___6 = tmp___9;
      }
    } else {
#line 131
      tmp___9 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
#line 131
      tmp___6 = tmp___9;
    }
#line 131
    if (tmp___6 != 0) {
#line 132
      error("ssh_dss_verify: cannot handle type %s", ktype);
#line 133
      buffer_free(& b);
#line 134
      xfree((void *)ktype);
#line 135
      return (-1);
    }
#line 137
    xfree((void *)ktype);
#line 138
    tmp___11 = buffer_get_string(& b, & len);
#line 138
    sigblob = (u_char *)tmp___11;
#line 139
    tmp___12 = buffer_len(& b);
#line 139
    rlen = (int )tmp___12;
#line 140
    buffer_free(& b);
#line 141
    if (rlen != 0) {
#line 142
      error("ssh_dss_verify: remaining bytes in signature %d", rlen);
#line 144
      xfree((void *)sigblob);
#line 145
      return (-1);
    }
  }
#line 149
  if (len != 40U) {
#line 150
    fatal("bad sigbloblen %u != SIGBLOB_LEN", len);
  }
#line 154
  sig = DSA_SIG_new();
#line 154
  if ((unsigned int )sig == (unsigned int )((void *)0)) {
#line 155
    fatal("ssh_dss_verify: DSA_SIG_new failed");
  }
#line 156
  sig->r = BN_new();
#line 156
  if ((unsigned int )sig->r == (unsigned int )((void *)0)) {
#line 157
    fatal("ssh_dss_verify: BN_new failed");
  }
#line 158
  sig->s = BN_new();
#line 158
  if ((unsigned int )sig->s == (unsigned int )((void *)0)) {
#line 159
    fatal("ssh_dss_verify: BN_new failed");
  }
#line 160
  BN_bin2bn((unsigned char const   *)sigblob, 20, sig->r);
#line 161
  BN_bin2bn((unsigned char const   *)(sigblob + 20), 20, sig->s);
#line 163
  if (! (datafellows & 1)) {
#line 164
    memset((void *)sigblob, 0, len);
#line 165
    xfree((void *)sigblob);
  }
#line 169
  EVP_DigestInit(& md, evp_md);
#line 170
  EVP_DigestUpdate(& md, (void const   *)data, datalen);
#line 171
  EVP_DigestFinal(& md, digest___1, & dlen);
#line 173
  ret = DSA_do_verify((unsigned char const   *)(digest___1), (int )dlen, sig, key->dsa);
#line 174
  memset((void *)(digest___1), 'd', sizeof(digest___1));
#line 176
  DSA_SIG_free(sig);
#line 178
  if (ret == 1) {
#line 178
    tmp___14 = "correct";
  } else {
#line 178
    if (ret == 0) {
#line 178
      tmp___14 = "incorrect";
    } else {
#line 178
      tmp___14 = "error";
    }
  }
#line 178
  debug("ssh_dss_verify: signature %s", tmp___14);
#line 180
  return (ret);
}
}
#line 1 "ssh-rsa.o"
#line 1006 "/usr/include/openssl/objects.h"
extern char const   *OBJ_nid2sn(int n ) ;
#line 732 "/usr/include/openssl/evp.h"
extern EVP_MD const   *EVP_get_digestbyname(char const   *name ) ;
#line 271 "/usr/include/openssl/err.h"
extern char *ERR_error_string(unsigned long e , char *buf ) ;
#line 217 "/usr/include/openssl/rsa.h"
extern int RSA_size(RSA const   * ) ;
#line 284
extern int RSA_sign(int type , unsigned char const   *m , unsigned int m_length ,
                    unsigned char *sigret , unsigned int *siglen , RSA *rsa ) ;
#line 286
extern int RSA_verify(int type , unsigned char const   *m , unsigned int m_length ,
                      unsigned char *sigbuf , unsigned int siglen , RSA *rsa ) ;
#line 41 "ssh-rsa.c"
int ssh_rsa_sign(Key *key , u_char **sigp , u_int *lenp , u_char *data , u_int datalen ) 
{ EVP_MD const   *evp_md ;
  EVP_MD_CTX md ;
  u_char digest___1[64] ;
  u_char *sig ;
  u_char *ret ;
  u_int slen ;
  u_int dlen ;
  u_int len ;
  int ok ;
  int nid ;
  Buffer b ;
  char const   *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int ecode ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  int diff ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
#line 52
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 53
    error("ssh_rsa_sign: no RSA key");
#line 54
    return (-1);
  } else {
#line 52
    if (key->type != 1) {
#line 53
      error("ssh_rsa_sign: no RSA key");
#line 54
      return (-1);
    } else {
#line 52
      if ((unsigned int )key->rsa == (unsigned int )((void *)0)) {
#line 53
        error("ssh_rsa_sign: no RSA key");
#line 54
        return (-1);
      }
    }
  }
#line 56
  if (datafellows & 8192) {
#line 56
    nid = 4;
  } else {
#line 56
    nid = 64;
  }
#line 57
  tmp = OBJ_nid2sn(nid);
#line 57
  evp_md = EVP_get_digestbyname(tmp);
#line 57
  if ((unsigned int )evp_md == (unsigned int )((void *)0)) {
#line 58
    error("ssh_rsa_sign: EVP_get_digestbynid %d failed", nid);
#line 59
    return (-1);
  }
#line 61
  EVP_DigestInit(& md, evp_md);
#line 62
  EVP_DigestUpdate(& md, (void const   *)data, datalen);
#line 63
  EVP_DigestFinal(& md, digest___1, & dlen);
#line 65
  tmp___0 = RSA_size((RSA const   *)key->rsa);
#line 65
  slen = (unsigned int )tmp___0;
#line 66
  tmp___1 = xmalloc(slen);
#line 66
  sig = (u_char *)tmp___1;
#line 68
  ok = RSA_sign(nid, (unsigned char const   *)(digest___1), dlen, sig, & len, key->rsa);
#line 69
  memset((void *)(digest___1), 'd', sizeof(digest___1));
#line 71
  if (ok != 1) {
#line 72
    tmp___2 = ERR_get_error();
#line 72
    ecode = (int )tmp___2;
#line 73
    tmp___3 = ERR_error_string((unsigned long )ecode, (char *)((void *)0));
#line 73
    error("ssh_rsa_sign: RSA_sign failed: %s", tmp___3);
#line 75
    xfree((void *)sig);
#line 76
    return (-1);
  }
#line 78
  if (len < slen) {
#line 79
    diff = (int )(slen - len);
#line 80
    debug("slen %u > len %u", slen, len);
#line 81
    memmove((void *)(sig + diff), (void const   *)sig, len);
#line 82
    memset((void *)sig, 0, (unsigned int )diff);
  } else {
#line 83
    if (len > slen) {
#line 84
      error("ssh_rsa_sign: slen %u slen2 %u", slen, len);
#line 85
      xfree((void *)sig);
#line 86
      return (-1);
    }
  }
#line 89
  buffer_init(& b);
#line 90
  buffer_put_cstring(& b, "ssh-rsa");
#line 91
  buffer_put_string(& b, (void const   *)sig, slen);
#line 92
  len = buffer_len(& b);
#line 93
  tmp___4 = xmalloc(len);
#line 93
  ret = (u_char *)tmp___4;
#line 94
  tmp___5 = buffer_ptr(& b);
#line 94
  memcpy((void * __restrict  )ret, (void const   * __restrict  )tmp___5, len);
#line 95
  buffer_free(& b);
#line 96
  memset((void *)sig, 's', slen);
#line 97
  xfree((void *)sig);
#line 99
  if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 100
    *lenp = len;
  }
#line 101
  if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 102
    *sigp = ret;
  }
#line 103
  return (0);
}
}
#line 106 "ssh-rsa.c"
int ssh_rsa_verify(Key *key , u_char *signature , u_int signaturelen , u_char *data ,
                   u_int datalen ) 
{ Buffer b ;
  EVP_MD const   *evp_md ;
  EVP_MD_CTX md ;
  char *ktype ;
  u_char digest___1[64] ;
  u_char *sigblob ;
  u_int len ;
  u_int dlen ;
  u_int modlen ;
  int rlen ;
  int ret ;
  int nid ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;
  u_int tmp___13 ;
  int tmp___14 ;
  int diff ;
  void *tmp___15 ;
  char const   *tmp___16 ;
  int ecode ;
  unsigned long tmp___17 ;
  char *tmp___18 ;
  char const   *tmp___19 ;

  {
#line 118
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 119
    error("ssh_rsa_verify: no RSA key");
#line 120
    return (-1);
  } else {
#line 118
    if (key->type != 1) {
#line 119
      error("ssh_rsa_verify: no RSA key");
#line 120
      return (-1);
    } else {
#line 118
      if ((unsigned int )key->rsa == (unsigned int )((void *)0)) {
#line 119
        error("ssh_rsa_verify: no RSA key");
#line 120
        return (-1);
      }
    }
  }
#line 122
  tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 122
  if (tmp___0 < 768) {
#line 123
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 123
    error("ssh_rsa_verify: RSA modulus too small: %d < minimum %d bits", tmp, 768);
#line 125
    return (-1);
  }
#line 127
  buffer_init(& b);
#line 128
  buffer_append(& b, (void const   *)signature, signaturelen);
#line 129
  tmp___1 = buffer_get_string(& b, (u_int *)((void *)0));
#line 129
  ktype = (char *)tmp___1;
#line 130
  if (0) {
#line 130
    __s1_len = strlen("ssh-rsa");
#line 130
    __s2_len = strlen((char const   *)ktype);
#line 130
    if (! ((unsigned int )((void const   *)("ssh-rsa" + 1)) - (unsigned int )((void const   *)"ssh-rsa") == 1U)) {
      goto _L___0;
    } else {
#line 130
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 130
        if (! ((unsigned int )((void const   *)(ktype + 1)) - (unsigned int )((void const   *)ktype) == 1U)) {
#line 130
          tmp___11 = 1;
        } else {
#line 130
          if (__s2_len >= 4U) {
#line 130
            tmp___11 = 1;
          } else {
#line 130
            tmp___11 = 0;
          }
        }
      } else {
#line 130
        tmp___11 = 0;
      }
    }
#line 130
    if (tmp___11) {
#line 130
      tmp___7 = __builtin_strcmp("ssh-rsa", (char const   *)ktype);
    } else {
#line 130
      tmp___10 = __builtin_strcmp("ssh-rsa", (char const   *)ktype);
#line 130
      tmp___7 = tmp___10;
    }
  } else {
#line 130
    tmp___10 = __builtin_strcmp("ssh-rsa", (char const   *)ktype);
#line 130
    tmp___7 = tmp___10;
  }
#line 130
  if (tmp___7 != 0) {
#line 131
    error("ssh_rsa_verify: cannot handle type %s", ktype);
#line 132
    buffer_free(& b);
#line 133
    xfree((void *)ktype);
#line 134
    return (-1);
  }
#line 136
  xfree((void *)ktype);
#line 137
  tmp___12 = buffer_get_string(& b, & len);
#line 137
  sigblob = (u_char *)tmp___12;
#line 138
  tmp___13 = buffer_len(& b);
#line 138
  rlen = (int )tmp___13;
#line 139
  buffer_free(& b);
#line 140
  if (rlen != 0) {
#line 141
    error("ssh_rsa_verify: remaining bytes in signature %d", rlen);
#line 142
    xfree((void *)sigblob);
#line 143
    return (-1);
  }
#line 146
  tmp___14 = RSA_size((RSA const   *)key->rsa);
#line 146
  modlen = (unsigned int )tmp___14;
#line 147
  if (len > modlen) {
#line 148
    error("ssh_rsa_verify: len %u > modlen %u", len, modlen);
#line 149
    xfree((void *)sigblob);
#line 150
    return (-1);
  } else {
#line 151
    if (len < modlen) {
#line 152
      diff = (int )(modlen - len);
#line 153
      debug("ssh_rsa_verify: add padding: modlen %u > len %u", modlen, len);
#line 155
      tmp___15 = xrealloc((void *)sigblob, modlen);
#line 155
      sigblob = (u_char *)tmp___15;
#line 156
      memmove((void *)(sigblob + diff), (void const   *)sigblob, len);
#line 157
      memset((void *)sigblob, 0, (unsigned int )diff);
#line 158
      len = modlen;
    }
  }
#line 160
  if (datafellows & 8192) {
#line 160
    nid = 4;
  } else {
#line 160
    nid = 64;
  }
#line 161
  tmp___16 = OBJ_nid2sn(nid);
#line 161
  evp_md = EVP_get_digestbyname(tmp___16);
#line 161
  if ((unsigned int )evp_md == (unsigned int )((void *)0)) {
#line 162
    error("ssh_rsa_verify: EVP_get_digestbynid %d failed", nid);
#line 163
    xfree((void *)sigblob);
#line 164
    return (-1);
  }
#line 166
  EVP_DigestInit(& md, evp_md);
#line 167
  EVP_DigestUpdate(& md, (void const   *)data, datalen);
#line 168
  EVP_DigestFinal(& md, digest___1, & dlen);
#line 170
  ret = RSA_verify(nid, (unsigned char const   *)(digest___1), dlen, sigblob, len,
                   key->rsa);
#line 171
  memset((void *)(digest___1), 'd', sizeof(digest___1));
#line 172
  memset((void *)sigblob, 's', len);
#line 173
  xfree((void *)sigblob);
#line 174
  if (ret == 0) {
#line 175
    tmp___17 = ERR_get_error();
#line 175
    ecode = (int )tmp___17;
#line 176
    tmp___18 = ERR_error_string((unsigned long )ecode, (char *)((void *)0));
#line 176
    error("ssh_rsa_verify: RSA_verify failed: %s", tmp___18);
  }
#line 179
  if (ret == 0) {
#line 179
    tmp___19 = "in";
  } else {
#line 179
    tmp___19 = "";
  }
#line 179
  debug("ssh_rsa_verify: signature %scorrect", tmp___19);
#line 180
  return (ret);
}
}
#line 1 "tildexpand.o"
#line 15 "tildexpand.h"
char *tilde_expand_filename(char const   *filename , uid_t my_uid ) ;
#line 24 "tildexpand.c"
char *tilde_expand_filename(char const   *filename , uid_t my_uid ) 
{ char const   *cp ;
  u_int userlen ;
  char *expanded ;
  struct passwd *pw ;
  char user[100] ;
  int len ;
  char *tmp ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char const   *tmp___16 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;

  {
#line 35
  if ((int const   )*(filename + 0) != 126) {
#line 36
    tmp = xstrdup(filename);
#line 36
    return (tmp);
  }
#line 39
  filename ++;
#line 42
  tmp___1 = __builtin_strchr((char *)filename, '/');
#line 42
  cp = (char const   *)tmp___1;
#line 43
  if (cp) {
#line 44
    userlen = (unsigned int )(cp - filename);
  } else {
#line 46
    userlen = strlen(filename);
  }
#line 47
  if (userlen == 0U) {
#line 48
    pw = getpwuid(my_uid);
  } else {
#line 51
    if (userlen > sizeof(user) - 1U) {
#line 52
      fatal("User name after tilde too long.");
    }
#line 53
    memcpy((void * __restrict  )(user), (void const   * __restrict  )filename, userlen);
#line 54
    user[userlen] = (char)0;
#line 55
    pw = getpwnam((char const   *)(user));
  }
#line 57
  if (! pw) {
#line 58
    fatal("Unknown user %100s.", user);
  }
#line 61
  if (! cp) {
#line 63
    tmp___2 = xstrdup((char const   *)pw->pw_dir);
#line 63
    return (tmp___2);
  }
#line 66
  tmp___3 = strlen((char const   *)pw->pw_dir);
#line 66
  tmp___4 = strlen(cp + 1);
#line 66
  len = (int )((tmp___3 + tmp___4) + 2U);
#line 67
  if (len > 4096) {
#line 68
    fatal("Home directory too long (%d > %d", len - 1, 4095);
  }
#line 69
  tmp___5 = xmalloc((unsigned int )len);
#line 69
  expanded = (char *)tmp___5;
#line 71
  if (0) {
#line 71
    __s1_len___0 = strlen((char const   *)pw->pw_dir);
#line 71
    __s2_len___0 = strlen("/");
#line 71
    if (! ((unsigned int )((void const   *)(pw->pw_dir + 1)) - (unsigned int )((void const   *)pw->pw_dir) == 1U)) {
      goto _L___2;
    } else {
#line 71
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 71
        if (! ((unsigned int )((void const   *)("/" + 1)) - (unsigned int )((void const   *)"/") == 1U)) {
#line 71
          tmp___26 = 1;
        } else {
#line 71
          if (__s2_len___0 >= 4U) {
#line 71
            tmp___26 = 1;
          } else {
#line 71
            tmp___26 = 0;
          }
        }
      } else {
#line 71
        tmp___26 = 0;
      }
    }
#line 71
    if (tmp___26) {
#line 71
      tmp___22 = __builtin_strcmp((char const   *)pw->pw_dir, "/");
    } else {
#line 71
      tmp___25 = __builtin_strcmp((char const   *)pw->pw_dir, "/");
#line 71
      tmp___22 = tmp___25;
    }
  } else {
#line 71
    tmp___25 = __builtin_strcmp((char const   *)pw->pw_dir, "/");
#line 71
    tmp___22 = tmp___25;
  }
#line 71
  if (tmp___22) {
#line 71
    tmp___16 = "/";
  } else {
#line 71
    tmp___16 = "";
  }
#line 71
  snprintf((char * __restrict  )expanded, (unsigned int )len, (char const   * __restrict  )"%s%s%s",
           pw->pw_dir, tmp___16, cp + 1);
#line 72
  return (expanded);
}
}
#line 1 "ttymodes.o"
#line 49 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) speed_t cfgetospeed(struct termios  const  *__termios_p ) ;
#line 52
extern  __attribute__((__nothrow__)) speed_t cfgetispeed(struct termios  const  *__termios_p ) ;
#line 55
extern  __attribute__((__nothrow__)) int cfsetospeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 58
extern  __attribute__((__nothrow__)) int cfsetispeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 81 "packet.h"
void tty_make_modes(int fd , struct termios *tiop ) ;
#line 82
void tty_parse_modes(int fd , int *n_bytes_ptr ) ;
#line 68 "ttymodes.c"
static int speed_to_baud(speed_t speed ) 
{ 

  {
#line 71
  switch ((int )speed) {
  case 0: 
#line 73
  return (0);
  case 1: 
#line 75
  return (50);
  case 2: 
#line 77
  return (75);
  case 3: 
#line 79
  return (110);
  case 4: 
#line 81
  return (134);
  case 5: 
#line 83
  return (150);
  case 6: 
#line 85
  return (200);
  case 7: 
#line 87
  return (300);
  case 8: 
#line 89
  return (600);
  case 9: 
#line 91
  return (1200);
  case 10: 
#line 93
  return (1800);
  case 11: 
#line 95
  return (2400);
  case 12: 
#line 97
  return (4800);
  case 13: 
#line 99
  return (9600);
  case 14: 
#line 103
  return (19200);
  case 15: 
#line 113
  return (38400);
  case 4097: 
#line 135
  return (57600);
  case 4098: 
#line 143
  return (115200);
  case 4099: 
#line 147
  return (230400);
  default: ;
#line 150
  return (9600);
  }
}
}
#line 157 "ttymodes.c"
static speed_t baud_to_speed(int baud ) 
{ 

  {
#line 160
  switch (baud) {
  case 0: 
#line 162
  return (0U);
  case 50: 
#line 164
  return (1U);
  case 75: 
#line 166
  return (2U);
  case 110: 
#line 168
  return (3U);
  case 134: 
#line 170
  return (4U);
  case 150: 
#line 172
  return (5U);
  case 200: 
#line 174
  return (6U);
  case 300: 
#line 176
  return (7U);
  case 600: 
#line 178
  return (8U);
  case 1200: 
#line 180
  return (9U);
  case 1800: 
#line 182
  return (10U);
  case 2400: 
#line 184
  return (11U);
  case 4800: 
#line 186
  return (12U);
  case 9600: 
#line 188
  return (13U);
  case 19200: 
#line 192
  return (14U);
  case 38400: 
#line 202
  return (15U);
  case 57600: 
#line 224
  return (4097U);
  case 115200: 
#line 232
  return (4098U);
  case 230400: 
#line 236
  return (4099U);
  default: ;
#line 239
  return (13U);
  }
}
}
#line 248 "ttymodes.c"
void tty_make_modes(int fd , struct termios *tiop ) 
{ struct termios tio ;
  int baud ;
  Buffer buf___1 ;
  int tty_op_ospeed ;
  int tty_op_ispeed ;
  void (*put_arg)(Buffer * , u_int  ) ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  speed_t tmp___2 ;
  speed_t tmp___3 ;
  u_int tmp___4 ;
  void *tmp___5 ;
  u_int tmp___6 ;
  void *tmp___7 ;

  {
#line 257
  buffer_init(& buf___1);
#line 258
  if (compat20) {
#line 259
    tty_op_ospeed = 129;
#line 260
    tty_op_ispeed = 128;
#line 261
    put_arg = & buffer_put_int;
  } else {
#line 263
    tty_op_ospeed = 193;
#line 264
    tty_op_ispeed = 192;
#line 265
    put_arg = (void (*)(Buffer * , u_int  ))(& buffer_put_char);
  }
#line 268
  if ((unsigned int )tiop == (unsigned int )((void *)0)) {
#line 269
    tmp___1 = tcgetattr(fd, & tio);
#line 269
    if (tmp___1 == -1) {
#line 270
      tmp = __errno_location();
#line 270
      tmp___0 = strerror(*tmp);
#line 270
      log("tcgetattr: %.100s", tmp___0);
      goto end;
    }
  } else {
#line 274
    tio = *tiop;
  }
#line 277
  tmp___2 = cfgetospeed((struct termios  const  *)(& tio));
#line 277
  baud = speed_to_baud(tmp___2);
#line 278
  debug3("tty_make_modes: ospeed %d", baud);
#line 279
  buffer_put_char(& buf___1, tty_op_ospeed);
#line 280
  buffer_put_int(& buf___1, (unsigned int )baud);
#line 281
  tmp___3 = cfgetispeed((struct termios  const  *)(& tio));
#line 281
  baud = speed_to_baud(tmp___3);
#line 282
  debug3("tty_make_modes: ispeed %d", baud);
#line 283
  buffer_put_char(& buf___1, tty_op_ispeed);
#line 284
  buffer_put_int(& buf___1, (unsigned int )baud);
#line 70 "ttymodes.h"
  debug3("tty_make_modes: %d %d", 1, tio.c_cc[0]);
#line 70
  buffer_put_char(& buf___1, 1);
#line 70
  (*put_arg)(& buf___1, (unsigned int )tio.c_cc[0]);
#line 71
  debug3("tty_make_modes: %d %d", 2, tio.c_cc[1]);
#line 71
  buffer_put_char(& buf___1, 2);
#line 71
  (*put_arg)(& buf___1, (unsigned int )tio.c_cc[1]);
#line 72
  debug3("tty_make_modes: %d %d", 3, tio.c_cc[2]);
#line 72
  buffer_put_char(& buf___1, 3);
#line 72
  (*put_arg)(& buf___1, (unsigned int )tio.c_cc[2]);
#line 74
  debug3("tty_make_modes: %d %d", 4, tio.c_cc[3]);
#line 74
  buffer_put_char(& buf___1, 4);
#line 74
  (*put_arg)(& buf___1, (unsigned int )tio.c_cc[3]);
#line 76
  debug3("tty_make_modes: %d %d", 5, tio.c_cc[4]);
#line 76
  buffer_put_char(& buf___1, 5);
#line 76
  (*put_arg)(& buf___1, (unsigned int )tio.c_cc[4]);
#line 78
  debug3("tty_make_modes: %d %d", 6, tio.c_cc[11]);
#line 78
  buffer_put_char(& buf___1, 6);
#line 78
  (*put_arg)(& buf___1, (unsigned int )tio.c_cc[11]);
#line 81
  debug3("tty_make_modes: %d %d", 7, tio.c_cc[16]);
#line 81
  buffer_put_char(& buf___1, 7);
#line 81
  (*put_arg)(& buf___1, (unsigned int )tio.c_cc[16]);
#line 83
  debug3("tty_make_modes: %d %d", 8, tio.c_cc[8]);
#line 83
  buffer_put_char(& buf___1, 8);
#line 83
  (*put_arg)(& buf___1, (unsigned int )tio.c_cc[8]);
#line 84
  debug3("tty_make_modes: %d %d", 9, tio.c_cc[9]);
#line 84
  buffer_put_char(& buf___1, 9);
#line 84
  (*put_arg)(& buf___1, (unsigned int )tio.c_cc[9]);
#line 86
  debug3("tty_make_modes: %d %d", 10, tio.c_cc[10]);
#line 86
  buffer_put_char(& buf___1, 10);
#line 86
  (*put_arg)(& buf___1, (unsigned int )tio.c_cc[10]);
#line 92
  debug3("tty_make_modes: %d %d", 12, tio.c_cc[12]);
#line 92
  buffer_put_char(& buf___1, 12);
#line 92
  (*put_arg)(& buf___1, (unsigned int )tio.c_cc[12]);
#line 95
  debug3("tty_make_modes: %d %d", 13, tio.c_cc[14]);
#line 95
  buffer_put_char(& buf___1, 13);
#line 95
  (*put_arg)(& buf___1, (unsigned int )tio.c_cc[14]);
#line 98
  debug3("tty_make_modes: %d %d", 14, tio.c_cc[15]);
#line 98
  buffer_put_char(& buf___1, 14);
#line 98
  (*put_arg)(& buf___1, (unsigned int )tio.c_cc[15]);
#line 110
  debug3("tty_make_modes: %d %d", 18, tio.c_cc[13]);
#line 110
  buffer_put_char(& buf___1, 18);
#line 110
  (*put_arg)(& buf___1, (unsigned int )tio.c_cc[13]);
#line 114
  debug3("tty_make_modes: %d %d", 30, (tio.c_iflag & 4U) != 0U);
#line 114
  buffer_put_char(& buf___1, 30);
#line 114
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 4U) != 0U));
#line 115
  debug3("tty_make_modes: %d %d", 31, (tio.c_iflag & 8U) != 0U);
#line 115
  buffer_put_char(& buf___1, 31);
#line 115
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 8U) != 0U));
#line 116
  debug3("tty_make_modes: %d %d", 32, (tio.c_iflag & 16U) != 0U);
#line 116
  buffer_put_char(& buf___1, 32);
#line 116
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 16U) != 0U));
#line 117
  debug3("tty_make_modes: %d %d", 33, (tio.c_iflag & 32U) != 0U);
#line 117
  buffer_put_char(& buf___1, 33);
#line 117
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 32U) != 0U));
#line 118
  debug3("tty_make_modes: %d %d", 34, (tio.c_iflag & 64U) != 0U);
#line 118
  buffer_put_char(& buf___1, 34);
#line 118
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 64U) != 0U));
#line 119
  debug3("tty_make_modes: %d %d", 35, (tio.c_iflag & 128U) != 0U);
#line 119
  buffer_put_char(& buf___1, 35);
#line 119
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 128U) != 0U));
#line 120
  debug3("tty_make_modes: %d %d", 36, (tio.c_iflag & 256U) != 0U);
#line 120
  buffer_put_char(& buf___1, 36);
#line 120
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 256U) != 0U));
#line 122
  debug3("tty_make_modes: %d %d", 37, (tio.c_iflag & 512U) != 0U);
#line 122
  buffer_put_char(& buf___1, 37);
#line 122
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 512U) != 0U));
#line 124
  debug3("tty_make_modes: %d %d", 38, (tio.c_iflag & 1024U) != 0U);
#line 124
  buffer_put_char(& buf___1, 38);
#line 124
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 1024U) != 0U));
#line 125
  debug3("tty_make_modes: %d %d", 39, (tio.c_iflag & 2048U) != 0U);
#line 125
  buffer_put_char(& buf___1, 39);
#line 125
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 2048U) != 0U));
#line 126
  debug3("tty_make_modes: %d %d", 40, (tio.c_iflag & 4096U) != 0U);
#line 126
  buffer_put_char(& buf___1, 40);
#line 126
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 4096U) != 0U));
#line 128
  debug3("tty_make_modes: %d %d", 41, (tio.c_iflag & 8192U) != 0U);
#line 128
  buffer_put_char(& buf___1, 41);
#line 128
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 8192U) != 0U));
#line 131
  debug3("tty_make_modes: %d %d", 50, (tio.c_lflag & 1U) != 0U);
#line 131
  buffer_put_char(& buf___1, 50);
#line 131
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 1U) != 0U));
#line 132
  debug3("tty_make_modes: %d %d", 51, (tio.c_lflag & 2U) != 0U);
#line 132
  buffer_put_char(& buf___1, 51);
#line 132
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 2U) != 0U));
#line 134
  debug3("tty_make_modes: %d %d", 52, (tio.c_lflag & 4U) != 0U);
#line 134
  buffer_put_char(& buf___1, 52);
#line 134
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 4U) != 0U));
#line 136
  debug3("tty_make_modes: %d %d", 53, (tio.c_lflag & 8U) != 0U);
#line 136
  buffer_put_char(& buf___1, 53);
#line 136
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 8U) != 0U));
#line 137
  debug3("tty_make_modes: %d %d", 54, (tio.c_lflag & 16U) != 0U);
#line 137
  buffer_put_char(& buf___1, 54);
#line 137
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 16U) != 0U));
#line 138
  debug3("tty_make_modes: %d %d", 55, (tio.c_lflag & 32U) != 0U);
#line 138
  buffer_put_char(& buf___1, 55);
#line 138
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 32U) != 0U));
#line 139
  debug3("tty_make_modes: %d %d", 56, (tio.c_lflag & 64U) != 0U);
#line 139
  buffer_put_char(& buf___1, 56);
#line 139
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 64U) != 0U));
#line 140
  debug3("tty_make_modes: %d %d", 57, (tio.c_lflag & 128U) != 0U);
#line 140
  buffer_put_char(& buf___1, 57);
#line 140
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 128U) != 0U));
#line 141
  debug3("tty_make_modes: %d %d", 58, (tio.c_lflag & 256U) != 0U);
#line 141
  buffer_put_char(& buf___1, 58);
#line 141
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 256U) != 0U));
#line 143
  debug3("tty_make_modes: %d %d", 59, (tio.c_lflag & 32768U) != 0U);
#line 143
  buffer_put_char(& buf___1, 59);
#line 143
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 32768U) != 0U));
#line 146
  debug3("tty_make_modes: %d %d", 60, (tio.c_lflag & 512U) != 0U);
#line 146
  buffer_put_char(& buf___1, 60);
#line 146
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 512U) != 0U));
#line 149
  debug3("tty_make_modes: %d %d", 61, (tio.c_lflag & 2048U) != 0U);
#line 149
  buffer_put_char(& buf___1, 61);
#line 149
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 2048U) != 0U));
#line 152
  debug3("tty_make_modes: %d %d", 62, (tio.c_lflag & 16384U) != 0U);
#line 152
  buffer_put_char(& buf___1, 62);
#line 152
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 16384U) != 0U));
#line 155
  debug3("tty_make_modes: %d %d", 70, (tio.c_oflag & 1U) != 0U);
#line 155
  buffer_put_char(& buf___1, 70);
#line 155
  (*put_arg)(& buf___1, (unsigned int )((tio.c_oflag & 1U) != 0U));
#line 157
  debug3("tty_make_modes: %d %d", 71, (tio.c_oflag & 2U) != 0U);
#line 157
  buffer_put_char(& buf___1, 71);
#line 157
  (*put_arg)(& buf___1, (unsigned int )((tio.c_oflag & 2U) != 0U));
#line 160
  debug3("tty_make_modes: %d %d", 72, (tio.c_oflag & 4U) != 0U);
#line 160
  buffer_put_char(& buf___1, 72);
#line 160
  (*put_arg)(& buf___1, (unsigned int )((tio.c_oflag & 4U) != 0U));
#line 163
  debug3("tty_make_modes: %d %d", 73, (tio.c_oflag & 8U) != 0U);
#line 163
  buffer_put_char(& buf___1, 73);
#line 163
  (*put_arg)(& buf___1, (unsigned int )((tio.c_oflag & 8U) != 0U));
#line 166
  debug3("tty_make_modes: %d %d", 74, (tio.c_oflag & 16U) != 0U);
#line 166
  buffer_put_char(& buf___1, 74);
#line 166
  (*put_arg)(& buf___1, (unsigned int )((tio.c_oflag & 16U) != 0U));
#line 169
  debug3("tty_make_modes: %d %d", 75, (tio.c_oflag & 32U) != 0U);
#line 169
  buffer_put_char(& buf___1, 75);
#line 169
  (*put_arg)(& buf___1, (unsigned int )((tio.c_oflag & 32U) != 0U));
#line 172
  debug3("tty_make_modes: %d %d", 90, (tio.c_cflag & 32U) != 0U);
#line 172
  buffer_put_char(& buf___1, 90);
#line 172
  (*put_arg)(& buf___1, (unsigned int )((tio.c_cflag & 32U) != 0U));
#line 173
  debug3("tty_make_modes: %d %d", 91, (tio.c_cflag & 48U) != 0U);
#line 173
  buffer_put_char(& buf___1, 91);
#line 173
  (*put_arg)(& buf___1, (unsigned int )((tio.c_cflag & 48U) != 0U));
#line 174
  debug3("tty_make_modes: %d %d", 92, (tio.c_cflag & 256U) != 0U);
#line 174
  buffer_put_char(& buf___1, 92);
#line 174
  (*put_arg)(& buf___1, (unsigned int )((tio.c_cflag & 256U) != 0U));
#line 175
  debug3("tty_make_modes: %d %d", 93, (tio.c_cflag & 512U) != 0U);
#line 175
  buffer_put_char(& buf___1, 93);
#line 175
  (*put_arg)(& buf___1, (unsigned int )((tio.c_cflag & 512U) != 0U));
  end: 
#line 304 "ttymodes.c"
  buffer_put_char(& buf___1, 0);
#line 305
  if (compat20) {
#line 306
    tmp___4 = buffer_len(& buf___1);
#line 306
    tmp___5 = buffer_ptr(& buf___1);
#line 306
    packet_put_string((void const   *)tmp___5, tmp___4);
  } else {
#line 308
    tmp___6 = buffer_len(& buf___1);
#line 308
    tmp___7 = buffer_ptr(& buf___1);
#line 308
    packet_put_raw((void const   *)tmp___7, tmp___6);
  }
#line 309
  buffer_free(& buf___1);
#line 310
  return;
}
}
#line 316 "ttymodes.c"
void tty_parse_modes(int fd , int *n_bytes_ptr ) 
{ struct termios tio ;
  int opcode ;
  int baud ;
  int n_bytes ;
  int failure ;
  u_int (*get_arg)(void) ;
  int arg ;
  int arg_size ;
  u_int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  u_int tmp___3 ;
  u_int tmp___4 ;
  speed_t tmp___5 ;
  int tmp___6 ;
  u_int tmp___7 ;
  speed_t tmp___8 ;
  int tmp___9 ;
  u_int tmp___10 ;
  u_int tmp___11 ;
  u_int tmp___12 ;
  u_int tmp___13 ;
  u_int tmp___14 ;
  u_int tmp___15 ;
  u_int tmp___16 ;
  u_int tmp___17 ;
  u_int tmp___18 ;
  u_int tmp___19 ;
  u_int tmp___20 ;
  u_int tmp___21 ;
  u_int tmp___22 ;
  u_int tmp___23 ;
  u_int tmp___24 ;
  u_int tmp___25 ;
  u_int tmp___26 ;
  u_int tmp___27 ;
  u_int tmp___28 ;
  u_int tmp___29 ;
  u_int tmp___30 ;
  u_int tmp___31 ;
  u_int tmp___32 ;
  u_int tmp___33 ;
  u_int tmp___34 ;
  u_int tmp___35 ;
  u_int tmp___36 ;
  u_int tmp___37 ;
  u_int tmp___38 ;
  u_int tmp___39 ;
  u_int tmp___40 ;
  u_int tmp___41 ;
  u_int tmp___42 ;
  u_int tmp___43 ;
  u_int tmp___44 ;
  u_int tmp___45 ;
  u_int tmp___46 ;
  u_int tmp___47 ;
  u_int tmp___48 ;
  u_int tmp___49 ;
  u_int tmp___50 ;
  u_int tmp___51 ;
  u_int tmp___52 ;
  u_int tmp___53 ;
  u_int tmp___54 ;
  u_int tmp___55 ;
  u_int tmp___56 ;
  u_int tmp___57 ;
  u_int tmp___58 ;
  int *tmp___59 ;
  char *tmp___60 ;
  int tmp___61 ;

  {
#line 321
  n_bytes = 0;
#line 322
  failure = 0;
#line 326
  if (compat20) {
#line 327
    tmp = packet_get_int();
#line 327
    *n_bytes_ptr = (int )tmp;
#line 328
    debug3("tty_parse_modes: SSH2 n_bytes %d", *n_bytes_ptr);
#line 329
    if (*n_bytes_ptr == 0) {
#line 330
      return;
    }
#line 331
    get_arg = & packet_get_int;
#line 332
    arg_size = 4;
  } else {
#line 334
    get_arg = & packet_get_char;
#line 335
    arg_size = 1;
  }
#line 343
  tmp___2 = tcgetattr(fd, & tio);
#line 343
  if (tmp___2 == -1) {
#line 344
    tmp___0 = __errno_location();
#line 344
    tmp___1 = strerror(*tmp___0);
#line 344
    log("tcgetattr: %.100s", tmp___1);
#line 345
    failure = -1;
  }
#line 348
  while (1) {
#line 349
    n_bytes ++;
#line 350
    tmp___3 = packet_get_char();
#line 350
    opcode = (int )tmp___3;
#line 351
    switch (opcode) {
    case 0: 
    goto set;
    case 192: 
    case 128: 
#line 358
    n_bytes += 4;
#line 359
    tmp___4 = packet_get_int();
#line 359
    baud = (int )tmp___4;
#line 360
    debug3("tty_parse_modes: ispeed %d", baud);
#line 361
    if (failure != -1) {
#line 361
      tmp___5 = baud_to_speed(baud);
#line 361
      tmp___6 = cfsetispeed(& tio, tmp___5);
#line 361
      if (tmp___6 == -1) {
#line 362
        error("cfsetispeed failed for %d", baud);
      }
    }
#line 363
    break;
    case 193: 
    case 129: 
#line 368
    n_bytes += 4;
#line 369
    tmp___7 = packet_get_int();
#line 369
    baud = (int )tmp___7;
#line 370
    debug3("tty_parse_modes: ospeed %d", baud);
#line 371
    if (failure != -1) {
#line 371
      tmp___8 = baud_to_speed(baud);
#line 371
      tmp___9 = cfsetospeed(& tio, tmp___8);
#line 371
      if (tmp___9 == -1) {
#line 372
        error("cfsetospeed failed for %d", baud);
      }
    }
#line 373
    break;
    case 1: 
#line 70 "ttymodes.h"
    n_bytes += arg_size;
#line 70
    tmp___10 = (*get_arg)();
#line 70
    tio.c_cc[0] = (unsigned char )tmp___10;
#line 70
    debug3("tty_parse_modes: %d %d", 1, tio.c_cc[0]);
#line 70
    break;
    case 2: 
#line 71
    n_bytes += arg_size;
#line 71
    tmp___11 = (*get_arg)();
#line 71
    tio.c_cc[1] = (unsigned char )tmp___11;
#line 71
    debug3("tty_parse_modes: %d %d", 2, tio.c_cc[1]);
#line 71
    break;
    case 3: 
#line 72
    n_bytes += arg_size;
#line 72
    tmp___12 = (*get_arg)();
#line 72
    tio.c_cc[2] = (unsigned char )tmp___12;
#line 72
    debug3("tty_parse_modes: %d %d", 3, tio.c_cc[2]);
#line 72
    break;
    case 4: 
#line 74
    n_bytes += arg_size;
#line 74
    tmp___13 = (*get_arg)();
#line 74
    tio.c_cc[3] = (unsigned char )tmp___13;
#line 74
    debug3("tty_parse_modes: %d %d", 4, tio.c_cc[3]);
#line 74
    break;
    case 5: 
#line 76
    n_bytes += arg_size;
#line 76
    tmp___14 = (*get_arg)();
#line 76
    tio.c_cc[4] = (unsigned char )tmp___14;
#line 76
    debug3("tty_parse_modes: %d %d", 5, tio.c_cc[4]);
#line 76
    break;
    case 6: 
#line 78
    n_bytes += arg_size;
#line 78
    tmp___15 = (*get_arg)();
#line 78
    tio.c_cc[11] = (unsigned char )tmp___15;
#line 78
    debug3("tty_parse_modes: %d %d", 6, tio.c_cc[11]);
#line 78
    break;
    case 7: 
#line 81
    n_bytes += arg_size;
#line 81
    tmp___16 = (*get_arg)();
#line 81
    tio.c_cc[16] = (unsigned char )tmp___16;
#line 81
    debug3("tty_parse_modes: %d %d", 7, tio.c_cc[16]);
#line 81
    break;
    case 8: 
#line 83
    n_bytes += arg_size;
#line 83
    tmp___17 = (*get_arg)();
#line 83
    tio.c_cc[8] = (unsigned char )tmp___17;
#line 83
    debug3("tty_parse_modes: %d %d", 8, tio.c_cc[8]);
#line 83
    break;
    case 9: 
#line 84
    n_bytes += arg_size;
#line 84
    tmp___18 = (*get_arg)();
#line 84
    tio.c_cc[9] = (unsigned char )tmp___18;
#line 84
    debug3("tty_parse_modes: %d %d", 9, tio.c_cc[9]);
#line 84
    break;
    case 10: 
#line 86
    n_bytes += arg_size;
#line 86
    tmp___19 = (*get_arg)();
#line 86
    tio.c_cc[10] = (unsigned char )tmp___19;
#line 86
    debug3("tty_parse_modes: %d %d", 10, tio.c_cc[10]);
#line 86
    break;
    case 12: 
#line 92
    n_bytes += arg_size;
#line 92
    tmp___20 = (*get_arg)();
#line 92
    tio.c_cc[12] = (unsigned char )tmp___20;
#line 92
    debug3("tty_parse_modes: %d %d", 12, tio.c_cc[12]);
#line 92
    break;
    case 13: 
#line 95
    n_bytes += arg_size;
#line 95
    tmp___21 = (*get_arg)();
#line 95
    tio.c_cc[14] = (unsigned char )tmp___21;
#line 95
    debug3("tty_parse_modes: %d %d", 13, tio.c_cc[14]);
#line 95
    break;
    case 14: 
#line 98
    n_bytes += arg_size;
#line 98
    tmp___22 = (*get_arg)();
#line 98
    tio.c_cc[15] = (unsigned char )tmp___22;
#line 98
    debug3("tty_parse_modes: %d %d", 14, tio.c_cc[15]);
#line 98
    break;
    case 18: 
#line 110
    n_bytes += arg_size;
#line 110
    tmp___23 = (*get_arg)();
#line 110
    tio.c_cc[13] = (unsigned char )tmp___23;
#line 110
    debug3("tty_parse_modes: %d %d", 18, tio.c_cc[13]);
#line 110
    break;
    case 30: 
#line 114
    n_bytes += arg_size;
#line 114
    tmp___24 = (*get_arg)();
#line 114
    arg = (int )tmp___24;
#line 114
    if (arg) {
#line 114
      tio.c_iflag |= 4U;
    } else {
#line 114
      tio.c_iflag &= 4294967291U;
    }
#line 114
    debug3("tty_parse_modes: %d %d", 30, arg);
#line 114
    break;
    case 31: 
#line 115
    n_bytes += arg_size;
#line 115
    tmp___25 = (*get_arg)();
#line 115
    arg = (int )tmp___25;
#line 115
    if (arg) {
#line 115
      tio.c_iflag |= 8U;
    } else {
#line 115
      tio.c_iflag &= 4294967287U;
    }
#line 115
    debug3("tty_parse_modes: %d %d", 31, arg);
#line 115
    break;
    case 32: 
#line 116
    n_bytes += arg_size;
#line 116
    tmp___26 = (*get_arg)();
#line 116
    arg = (int )tmp___26;
#line 116
    if (arg) {
#line 116
      tio.c_iflag |= 16U;
    } else {
#line 116
      tio.c_iflag &= 4294967279U;
    }
#line 116
    debug3("tty_parse_modes: %d %d", 32, arg);
#line 116
    break;
    case 33: 
#line 117
    n_bytes += arg_size;
#line 117
    tmp___27 = (*get_arg)();
#line 117
    arg = (int )tmp___27;
#line 117
    if (arg) {
#line 117
      tio.c_iflag |= 32U;
    } else {
#line 117
      tio.c_iflag &= 4294967263U;
    }
#line 117
    debug3("tty_parse_modes: %d %d", 33, arg);
#line 117
    break;
    case 34: 
#line 118
    n_bytes += arg_size;
#line 118
    tmp___28 = (*get_arg)();
#line 118
    arg = (int )tmp___28;
#line 118
    if (arg) {
#line 118
      tio.c_iflag |= 64U;
    } else {
#line 118
      tio.c_iflag &= 4294967231U;
    }
#line 118
    debug3("tty_parse_modes: %d %d", 34, arg);
#line 118
    break;
    case 35: 
#line 119
    n_bytes += arg_size;
#line 119
    tmp___29 = (*get_arg)();
#line 119
    arg = (int )tmp___29;
#line 119
    if (arg) {
#line 119
      tio.c_iflag |= 128U;
    } else {
#line 119
      tio.c_iflag &= 4294967167U;
    }
#line 119
    debug3("tty_parse_modes: %d %d", 35, arg);
#line 119
    break;
    case 36: 
#line 120
    n_bytes += arg_size;
#line 120
    tmp___30 = (*get_arg)();
#line 120
    arg = (int )tmp___30;
#line 120
    if (arg) {
#line 120
      tio.c_iflag |= 256U;
    } else {
#line 120
      tio.c_iflag &= 4294967039U;
    }
#line 120
    debug3("tty_parse_modes: %d %d", 36, arg);
#line 120
    break;
    case 37: 
#line 122
    n_bytes += arg_size;
#line 122
    tmp___31 = (*get_arg)();
#line 122
    arg = (int )tmp___31;
#line 122
    if (arg) {
#line 122
      tio.c_iflag |= 512U;
    } else {
#line 122
      tio.c_iflag &= 4294966783U;
    }
#line 122
    debug3("tty_parse_modes: %d %d", 37, arg);
#line 122
    break;
    case 38: 
#line 124
    n_bytes += arg_size;
#line 124
    tmp___32 = (*get_arg)();
#line 124
    arg = (int )tmp___32;
#line 124
    if (arg) {
#line 124
      tio.c_iflag |= 1024U;
    } else {
#line 124
      tio.c_iflag &= 4294966271U;
    }
#line 124
    debug3("tty_parse_modes: %d %d", 38, arg);
#line 124
    break;
    case 39: 
#line 125
    n_bytes += arg_size;
#line 125
    tmp___33 = (*get_arg)();
#line 125
    arg = (int )tmp___33;
#line 125
    if (arg) {
#line 125
      tio.c_iflag |= 2048U;
    } else {
#line 125
      tio.c_iflag &= 4294965247U;
    }
#line 125
    debug3("tty_parse_modes: %d %d", 39, arg);
#line 125
    break;
    case 40: 
#line 126
    n_bytes += arg_size;
#line 126
    tmp___34 = (*get_arg)();
#line 126
    arg = (int )tmp___34;
#line 126
    if (arg) {
#line 126
      tio.c_iflag |= 4096U;
    } else {
#line 126
      tio.c_iflag &= 4294963199U;
    }
#line 126
    debug3("tty_parse_modes: %d %d", 40, arg);
#line 126
    break;
    case 41: 
#line 128
    n_bytes += arg_size;
#line 128
    tmp___35 = (*get_arg)();
#line 128
    arg = (int )tmp___35;
#line 128
    if (arg) {
#line 128
      tio.c_iflag |= 8192U;
    } else {
#line 128
      tio.c_iflag &= 4294959103U;
    }
#line 128
    debug3("tty_parse_modes: %d %d", 41, arg);
#line 128
    break;
    case 50: 
#line 131
    n_bytes += arg_size;
#line 131
    tmp___36 = (*get_arg)();
#line 131
    arg = (int )tmp___36;
#line 131
    if (arg) {
#line 131
      tio.c_lflag |= 1U;
    } else {
#line 131
      tio.c_lflag &= 4294967294U;
    }
#line 131
    debug3("tty_parse_modes: %d %d", 50, arg);
#line 131
    break;
    case 51: 
#line 132
    n_bytes += arg_size;
#line 132
    tmp___37 = (*get_arg)();
#line 132
    arg = (int )tmp___37;
#line 132
    if (arg) {
#line 132
      tio.c_lflag |= 2U;
    } else {
#line 132
      tio.c_lflag &= 4294967293U;
    }
#line 132
    debug3("tty_parse_modes: %d %d", 51, arg);
#line 132
    break;
    case 52: 
#line 134
    n_bytes += arg_size;
#line 134
    tmp___38 = (*get_arg)();
#line 134
    arg = (int )tmp___38;
#line 134
    if (arg) {
#line 134
      tio.c_lflag |= 4U;
    } else {
#line 134
      tio.c_lflag &= 4294967291U;
    }
#line 134
    debug3("tty_parse_modes: %d %d", 52, arg);
#line 134
    break;
    case 53: 
#line 136
    n_bytes += arg_size;
#line 136
    tmp___39 = (*get_arg)();
#line 136
    arg = (int )tmp___39;
#line 136
    if (arg) {
#line 136
      tio.c_lflag |= 8U;
    } else {
#line 136
      tio.c_lflag &= 4294967287U;
    }
#line 136
    debug3("tty_parse_modes: %d %d", 53, arg);
#line 136
    break;
    case 54: 
#line 137
    n_bytes += arg_size;
#line 137
    tmp___40 = (*get_arg)();
#line 137
    arg = (int )tmp___40;
#line 137
    if (arg) {
#line 137
      tio.c_lflag |= 16U;
    } else {
#line 137
      tio.c_lflag &= 4294967279U;
    }
#line 137
    debug3("tty_parse_modes: %d %d", 54, arg);
#line 137
    break;
    case 55: 
#line 138
    n_bytes += arg_size;
#line 138
    tmp___41 = (*get_arg)();
#line 138
    arg = (int )tmp___41;
#line 138
    if (arg) {
#line 138
      tio.c_lflag |= 32U;
    } else {
#line 138
      tio.c_lflag &= 4294967263U;
    }
#line 138
    debug3("tty_parse_modes: %d %d", 55, arg);
#line 138
    break;
    case 56: 
#line 139
    n_bytes += arg_size;
#line 139
    tmp___42 = (*get_arg)();
#line 139
    arg = (int )tmp___42;
#line 139
    if (arg) {
#line 139
      tio.c_lflag |= 64U;
    } else {
#line 139
      tio.c_lflag &= 4294967231U;
    }
#line 139
    debug3("tty_parse_modes: %d %d", 56, arg);
#line 139
    break;
    case 57: 
#line 140
    n_bytes += arg_size;
#line 140
    tmp___43 = (*get_arg)();
#line 140
    arg = (int )tmp___43;
#line 140
    if (arg) {
#line 140
      tio.c_lflag |= 128U;
    } else {
#line 140
      tio.c_lflag &= 4294967167U;
    }
#line 140
    debug3("tty_parse_modes: %d %d", 57, arg);
#line 140
    break;
    case 58: 
#line 141
    n_bytes += arg_size;
#line 141
    tmp___44 = (*get_arg)();
#line 141
    arg = (int )tmp___44;
#line 141
    if (arg) {
#line 141
      tio.c_lflag |= 256U;
    } else {
#line 141
      tio.c_lflag &= 4294967039U;
    }
#line 141
    debug3("tty_parse_modes: %d %d", 58, arg);
#line 141
    break;
    case 59: 
#line 143
    n_bytes += arg_size;
#line 143
    tmp___45 = (*get_arg)();
#line 143
    arg = (int )tmp___45;
#line 143
    if (arg) {
#line 143
      tio.c_lflag |= 32768U;
    } else {
#line 143
      tio.c_lflag &= 4294934527U;
    }
#line 143
    debug3("tty_parse_modes: %d %d", 59, arg);
#line 143
    break;
    case 60: 
#line 146
    n_bytes += arg_size;
#line 146
    tmp___46 = (*get_arg)();
#line 146
    arg = (int )tmp___46;
#line 146
    if (arg) {
#line 146
      tio.c_lflag |= 512U;
    } else {
#line 146
      tio.c_lflag &= 4294966783U;
    }
#line 146
    debug3("tty_parse_modes: %d %d", 60, arg);
#line 146
    break;
    case 61: 
#line 149
    n_bytes += arg_size;
#line 149
    tmp___47 = (*get_arg)();
#line 149
    arg = (int )tmp___47;
#line 149
    if (arg) {
#line 149
      tio.c_lflag |= 2048U;
    } else {
#line 149
      tio.c_lflag &= 4294965247U;
    }
#line 149
    debug3("tty_parse_modes: %d %d", 61, arg);
#line 149
    break;
    case 62: 
#line 152
    n_bytes += arg_size;
#line 152
    tmp___48 = (*get_arg)();
#line 152
    arg = (int )tmp___48;
#line 152
    if (arg) {
#line 152
      tio.c_lflag |= 16384U;
    } else {
#line 152
      tio.c_lflag &= 4294950911U;
    }
#line 152
    debug3("tty_parse_modes: %d %d", 62, arg);
#line 152
    break;
    case 70: 
#line 155
    n_bytes += arg_size;
#line 155
    tmp___49 = (*get_arg)();
#line 155
    arg = (int )tmp___49;
#line 155
    if (arg) {
#line 155
      tio.c_oflag |= 1U;
    } else {
#line 155
      tio.c_oflag &= 4294967294U;
    }
#line 155
    debug3("tty_parse_modes: %d %d", 70, arg);
#line 155
    break;
    case 71: 
#line 157
    n_bytes += arg_size;
#line 157
    tmp___50 = (*get_arg)();
#line 157
    arg = (int )tmp___50;
#line 157
    if (arg) {
#line 157
      tio.c_oflag |= 2U;
    } else {
#line 157
      tio.c_oflag &= 4294967293U;
    }
#line 157
    debug3("tty_parse_modes: %d %d", 71, arg);
#line 157
    break;
    case 72: 
#line 160
    n_bytes += arg_size;
#line 160
    tmp___51 = (*get_arg)();
#line 160
    arg = (int )tmp___51;
#line 160
    if (arg) {
#line 160
      tio.c_oflag |= 4U;
    } else {
#line 160
      tio.c_oflag &= 4294967291U;
    }
#line 160
    debug3("tty_parse_modes: %d %d", 72, arg);
#line 160
    break;
    case 73: 
#line 163
    n_bytes += arg_size;
#line 163
    tmp___52 = (*get_arg)();
#line 163
    arg = (int )tmp___52;
#line 163
    if (arg) {
#line 163
      tio.c_oflag |= 8U;
    } else {
#line 163
      tio.c_oflag &= 4294967287U;
    }
#line 163
    debug3("tty_parse_modes: %d %d", 73, arg);
#line 163
    break;
    case 74: 
#line 166
    n_bytes += arg_size;
#line 166
    tmp___53 = (*get_arg)();
#line 166
    arg = (int )tmp___53;
#line 166
    if (arg) {
#line 166
      tio.c_oflag |= 16U;
    } else {
#line 166
      tio.c_oflag &= 4294967279U;
    }
#line 166
    debug3("tty_parse_modes: %d %d", 74, arg);
#line 166
    break;
    case 75: 
#line 169
    n_bytes += arg_size;
#line 169
    tmp___54 = (*get_arg)();
#line 169
    arg = (int )tmp___54;
#line 169
    if (arg) {
#line 169
      tio.c_oflag |= 32U;
    } else {
#line 169
      tio.c_oflag &= 4294967263U;
    }
#line 169
    debug3("tty_parse_modes: %d %d", 75, arg);
#line 169
    break;
    case 90: 
#line 172
    n_bytes += arg_size;
#line 172
    tmp___55 = (*get_arg)();
#line 172
    arg = (int )tmp___55;
#line 172
    if (arg) {
#line 172
      tio.c_cflag |= 32U;
    } else {
#line 172
      tio.c_cflag &= 4294967263U;
    }
#line 172
    debug3("tty_parse_modes: %d %d", 90, arg);
#line 172
    break;
    case 91: 
#line 173
    n_bytes += arg_size;
#line 173
    tmp___56 = (*get_arg)();
#line 173
    arg = (int )tmp___56;
#line 173
    if (arg) {
#line 173
      tio.c_cflag |= 48U;
    } else {
#line 173
      tio.c_cflag &= 4294967247U;
    }
#line 173
    debug3("tty_parse_modes: %d %d", 91, arg);
#line 173
    break;
    case 92: 
#line 174
    n_bytes += arg_size;
#line 174
    tmp___57 = (*get_arg)();
#line 174
    arg = (int )tmp___57;
#line 174
    if (arg) {
#line 174
      tio.c_cflag |= 256U;
    } else {
#line 174
      tio.c_cflag &= 4294967039U;
    }
#line 174
    debug3("tty_parse_modes: %d %d", 92, arg);
#line 174
    break;
    case 93: 
#line 175
    n_bytes += arg_size;
#line 175
    tmp___58 = (*get_arg)();
#line 175
    arg = (int )tmp___58;
#line 175
    if (arg) {
#line 175
      tio.c_cflag |= 512U;
    } else {
#line 175
      tio.c_cflag &= 4294966783U;
    }
#line 175
    debug3("tty_parse_modes: %d %d", 93, arg);
#line 175
    break;
    default: 
#line 397 "ttymodes.c"
    debug("Ignoring unsupported tty mode opcode %d (0x%x)", opcode, opcode);
#line 399
    if (! compat20) {
#line 407
      if (opcode > 0) {
#line 407
        if (opcode < 128) {
#line 408
          n_bytes ++;
#line 409
          packet_get_char();
#line 410
          break;
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 411
        if (opcode >= 128) {
#line 411
          if (opcode < 160) {
#line 412
            n_bytes += 4;
#line 413
            packet_get_int();
#line 414
            break;
          } else {
#line 423
            log("parse_tty_modes: unknown opcode %d", opcode);
            goto set;
          }
        } else {
#line 423
          log("parse_tty_modes: unknown opcode %d", opcode);
          goto set;
        }
      }
    } else {
#line 434
      if (opcode > 0) {
#line 434
        if (opcode < 160) {
#line 435
          n_bytes += 4;
#line 436
          packet_get_int();
#line 437
          break;
        } else {
#line 439
          log("parse_tty_modes: unknown opcode %d", opcode);
          goto set;
        }
      } else {
#line 439
        log("parse_tty_modes: unknown opcode %d", opcode);
        goto set;
      }
    }
    }
  }
  set: 
#line 447
  if (*n_bytes_ptr != n_bytes) {
#line 448
    *n_bytes_ptr = n_bytes;
#line 449
    log("parse_tty_modes: n_bytes_ptr != n_bytes: %d %d", *n_bytes_ptr, n_bytes);
#line 451
    return;
  }
#line 453
  if (failure == -1) {
#line 454
    return;
  }
#line 457
  tmp___61 = tcsetattr(fd, 0, (struct termios  const  *)(& tio));
#line 457
  if (tmp___61 == -1) {
#line 458
    tmp___59 = __errno_location();
#line 458
    tmp___60 = strerror(*tmp___59);
#line 458
    log("Setting tty modes failed: %.100s", tmp___60);
  }
#line 459
  return;
}
}
#line 1 "uidswap.o"
#line 178 "/usr/include/grp.h"
extern  __attribute__((__nothrow__)) int setgroups(size_t __n , __gid_t const   *__groups ) ;
#line 199
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 651 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 656
extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t *__list ) ;
#line 684
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 694
extern  __attribute__((__nothrow__)) int setegid(__gid_t __gid ) ;
#line 18 "uidswap.h"
void temporarily_use_uid(struct passwd *pw ) ;
#line 19
void restore_uid(void) ;
#line 20
void permanently_set_uid(struct passwd *pw ) ;
#line 34 "uidswap.c"
static uid_t saved_euid  =    (uid_t )0;
#line 35 "uidswap.c"
static gid_t saved_egid  =    (gid_t )0;
#line 39 "uidswap.c"
static int privileged  =    0;
#line 40 "uidswap.c"
static int temporarily_use_uid_effective  =    0;
#line 41 "uidswap.c"
static gid_t saved_egroups[65536]  ;
#line 41 "uidswap.c"
static gid_t user_groups[65536]  ;
#line 42 "uidswap.c"
static int saved_egroupslen  =    -1;
#line 42 "uidswap.c"
static int user_groupslen  =    -1;
#line 48 "uidswap.c"
void temporarily_use_uid(struct passwd *pw ) 
{ int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;

  {
#line 53
  saved_euid = geteuid();
#line 54
  saved_egid = getegid();
#line 55
  debug("temporarily_use_uid: %u/%u (e=%u)", pw->pw_uid, pw->pw_gid, saved_euid);
#line 57
  if (saved_euid != 0U) {
#line 58
    privileged = 0;
#line 59
    return;
  }
#line 68
  privileged = 1;
#line 69
  temporarily_use_uid_effective = 1;
#line 70
  saved_egroupslen = getgroups(65536, saved_egroups);
#line 71
  if (saved_egroupslen < 0) {
#line 72
    tmp = __errno_location();
#line 72
    tmp___0 = strerror(*tmp);
#line 72
    fatal("getgroups: %.100s", tmp___0);
  }
#line 75
  if (user_groupslen == -1) {
#line 76
    tmp___3 = initgroups((char const   *)pw->pw_name, pw->pw_gid);
#line 76
    if (tmp___3 < 0) {
#line 77
      tmp___1 = __errno_location();
#line 77
      tmp___2 = strerror(*tmp___1);
#line 77
      fatal("initgroups: %s: %.100s", pw->pw_name, tmp___2);
    }
#line 79
    user_groupslen = getgroups(65536, user_groups);
#line 80
    if (user_groupslen < 0) {
#line 81
      tmp___4 = __errno_location();
#line 81
      tmp___5 = strerror(*tmp___4);
#line 81
      fatal("getgroups: %.100s", tmp___5);
    }
  }
#line 84
  tmp___8 = setgroups((unsigned int )user_groupslen, (__gid_t const   *)(user_groups));
#line 84
  if (tmp___8 < 0) {
#line 85
    tmp___6 = __errno_location();
#line 85
    tmp___7 = strerror(*tmp___6);
#line 85
    fatal("setgroups: %.100s", tmp___7);
  }
#line 94
  tmp___11 = setegid(pw->pw_gid);
#line 94
  if (tmp___11 < 0) {
#line 95
    tmp___9 = __errno_location();
#line 95
    tmp___10 = strerror(*tmp___9);
#line 95
    fatal("setegid %u: %.100s", pw->pw_gid, tmp___10);
  }
#line 97
  tmp___14 = seteuid(pw->pw_uid);
#line 97
  if (tmp___14 == -1) {
#line 98
    tmp___12 = __errno_location();
#line 98
    tmp___13 = strerror(*tmp___12);
#line 98
    fatal("seteuid %u: %.100s", pw->pw_uid, tmp___13);
  }
#line 100
  return;
}
}
#line 105 "uidswap.c"
void restore_uid(void) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
#line 108
  debug("restore_uid");
#line 110
  if (! privileged) {
#line 111
    return;
  }
#line 112
  if (! temporarily_use_uid_effective) {
#line 113
    fatal("restore_uid: temporarily_use_uid not effective");
  }
#line 117
  tmp___1 = seteuid(saved_euid);
#line 117
  if (tmp___1 < 0) {
#line 118
    tmp = __errno_location();
#line 118
    tmp___0 = strerror(*tmp);
#line 118
    fatal("seteuid %u: %.100s", saved_euid, tmp___0);
  }
#line 119
  tmp___4 = setegid(saved_egid);
#line 119
  if (tmp___4 < 0) {
#line 120
    tmp___2 = __errno_location();
#line 120
    tmp___3 = strerror(*tmp___2);
#line 120
    fatal("setegid %u: %.100s", saved_egid, tmp___3);
  }
#line 131
  tmp___7 = setgroups((unsigned int )saved_egroupslen, (__gid_t const   *)(saved_egroups));
#line 131
  if (tmp___7 < 0) {
#line 132
    tmp___5 = __errno_location();
#line 132
    tmp___6 = strerror(*tmp___5);
#line 132
    fatal("setgroups: %.100s", tmp___6);
  }
#line 133
  temporarily_use_uid_effective = 0;
#line 134
  return;
}
}
#line 140 "uidswap.c"
void permanently_set_uid(struct passwd *pw ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 143
  if (temporarily_use_uid_effective) {
#line 144
    fatal("permanently_set_uid: temporarily_use_uid effective");
  }
#line 145
  tmp___1 = setgid(pw->pw_gid);
#line 145
  if (tmp___1 < 0) {
#line 146
    tmp = __errno_location();
#line 146
    tmp___0 = strerror(*tmp);
#line 146
    fatal("setgid %u: %.100s", pw->pw_gid, tmp___0);
  }
#line 147
  tmp___4 = setuid(pw->pw_uid);
#line 147
  if (tmp___4 < 0) {
#line 148
    tmp___2 = __errno_location();
#line 148
    tmp___3 = strerror(*tmp___2);
#line 148
    fatal("setuid %u: %.100s", pw->pw_uid, tmp___3);
  }
#line 149
  return;
}
}
#line 1 "uuencode.o"
#line 31 "uuencode.h"
void dump_base64(FILE *fp , u_char *data , u_int len ) ;
#line 30 "uuencode.c"
int uuencode(u_char *src , u_int srclength , char *target , size_t targsize ) 
{ int tmp ;

  {
#line 34
  tmp = b64_ntop((u_char const   *)src, srclength, target, targsize);
#line 34
  return (tmp);
}
}
#line 37 "uuencode.c"
int uudecode(char const   *src , u_char *target , size_t targsize ) 
{ int len ;
  char *encoded ;
  char *p ;

  {
#line 44
  encoded = xstrdup(src);
#line 46
  p = encoded;
#line 46
  while (1) {
#line 46
    if (! ((int )*p == 32)) {
#line 46
      if (! ((int )*p == 9)) {
#line 46
        break;
      }
    }
#line 46
    p ++;
  }
#line 48
  while (1) {
#line 48
    if ((int )*p != 0) {
#line 48
      if ((int )*p != 32) {
#line 48
        if (! ((int )*p != 9)) {
#line 48
          break;
        }
      } else {
#line 48
        break;
      }
    } else {
#line 48
      break;
    }
#line 48
    p ++;
  }
#line 51
  *p = (char )'\000';
#line 52
  len = b64_pton((char const   *)encoded, target, targsize);
#line 53
  xfree((void *)encoded);
#line 54
  return (len);
}
}
#line 57 "uuencode.c"
void dump_base64(FILE *fp , u_char *data , u_int len ) 
{ u_char *buf___1 ;
  void *tmp ;
  int i ;
  int n___0 ;

  {
#line 60
  tmp = xmalloc(2U * len);
#line 60
  buf___1 = (u_char *)tmp;
#line 63
  n___0 = uuencode(data, len, (char *)buf___1, 2U * len);
#line 64
  i = 0;
#line 64
  while (i < n___0) {
#line 65
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%c", *(buf___1 + i));
#line 66
    if (i % 70 == 69) {
#line 67
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
    }
#line 64
    i ++;
  }
#line 69
  if (i % 70 != 69) {
#line 70
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  }
#line 71
  xfree((void *)buf___1);
#line 72
  return;
}
}
#line 1 "xmalloc.o"
#line 21 "xmalloc.c"
void *xmalloc(size_t size ) 
{ void *ptr ;

  {
#line 26
  if (size == 0U) {
#line 27
    fatal("xmalloc: zero size");
  }
#line 28
  ptr = malloc(size);
#line 29
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 30
    fatal("xmalloc: out of memory (allocating %lu bytes)", (unsigned long )size);
  }
#line 31
  return (ptr);
}
}
#line 34 "xmalloc.c"
void *xrealloc(void *ptr , size_t new_size ) 
{ void *new_ptr ;

  {
#line 39
  if (new_size == 0U) {
#line 40
    fatal("xrealloc: zero size");
  }
#line 41
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 42
    new_ptr = malloc(new_size);
  } else {
#line 44
    new_ptr = realloc(ptr, new_size);
  }
#line 45
  if ((unsigned int )new_ptr == (unsigned int )((void *)0)) {
#line 46
    fatal("xrealloc: out of memory (new_size %lu bytes)", (unsigned long )new_size);
  }
#line 47
  return (new_ptr);
}
}
#line 50 "xmalloc.c"
void xfree(void *ptr ) 
{ 

  {
#line 53
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 54
    fatal("xfree: NULL pointer given as argument");
  }
#line 55
  free(ptr);
#line 56
  return;
}
}
#line 58 "xmalloc.c"
char *xstrdup(char const   *str ) 
{ size_t len ;
  char *cp ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 64
  tmp = strlen(str);
#line 64
  len = tmp + 1U;
#line 65
  tmp___0 = xmalloc(len);
#line 65
  cp = (char *)tmp___0;
#line 66
  strlcpy(cp, str, len);
#line 67
  return (cp);
}
}
#line 1 "monitor_wrap.o"
#line 78 "monitor.h"
void mm_request_send(int socket___0 , enum monitor_reqtype type , Buffer *m___0 ) ;
#line 79
void mm_request_receive(int socket___0 , Buffer *m___0 ) ;
#line 80
void mm_request_receive_expect(int socket___0 , enum monitor_reqtype type , Buffer *m___0 ) ;
#line 45 "monitor_wrap.h"
void mm_inform_authserv(char *service , char *style ) ;
#line 46
struct passwd *mm_getpwnamallow(char const   *login___0 ) ;
#line 47
char *mm_auth2_read_banner(void) ;
#line 48
int mm_auth_password(struct Authctxt *authctxt___0 , char *password ) ;
#line 49
int mm_key_allowed(enum mm_keytype type , char *user , char *host , Key *key ) ;
#line 50
int mm_user_key_allowed(struct passwd *pw , Key *key ) ;
#line 51
int mm_hostbased_key_allowed(struct passwd *pw , char *user , char *host , Key *key ) ;
#line 52
int mm_auth_rhosts_rsa_key_allowed(struct passwd *pw , char *user , char *host , Key *key ) ;
#line 53
int mm_key_verify(Key *key , u_char *sig , u_int siglen , u_char *data , u_int datalen ) ;
#line 54
int mm_auth_rsa_key_allowed(struct passwd *pw , BIGNUM *client_n , Key **rkey ) ;
#line 55
int mm_auth_rsa_verify_response(Key *key , BIGNUM *p , u_char *response ) ;
#line 56
BIGNUM *mm_auth_rsa_generate_challenge(Key *key ) ;
#line 62
void mm_terminate(void) ;
#line 63
int mm_pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) ;
#line 64
void mm_session_pty_cleanup2(void *session ) ;
#line 67
void mm_ssh1_session_id(u_char *session_id___0 ) ;
#line 68
int mm_ssh1_session_key(BIGNUM *num ) ;
#line 71
struct Newkeys *mm_newkeys_from_blob(u_char *blob , int blen ) ;
#line 72
int mm_newkeys_to_blob(int mode , u_char **blobp , u_int *lenp ) ;
#line 76
void mm_send_keystate(struct monitor *pmonitor___0 ) ;
#line 79
int mm_bsdauth_query(void *ctx , char **name , char **infotxt , u_int *numprompts ,
                     char ***prompts , u_int **echo_on ) ;
#line 80
int mm_bsdauth_respond(void *ctx , u_int numresponses , char **responses ) ;
#line 83
int mm_skey_query(void *ctx , char **name , char **infotxt , u_int *numprompts , char ***prompts ,
                  u_int **echo_on ) ;
#line 84
int mm_skey_respond(void *ctx , u_int numresponses , char **responses ) ;
#line 32 "monitor_fdpass.h"
int mm_receive_fd(int socket___0 ) ;
#line 62 "monitor_wrap.c"
void mm_request_send(int socket___0 , enum monitor_reqtype type , Buffer *m___0 ) 
{ u_char buf___1[5] ;
  u_int mlen ;
  u_int tmp ;
  ssize_t tmp___0 ;
  void *tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 66
  tmp = buffer_len(m___0);
#line 66
  mlen = tmp;
#line 68
  debug3("%s entering: type %d", "mm_request_send", type);
#line 70
  while (1) {
#line 70
    buf___1[0] = (unsigned char )((mlen + 1U) >> 24);
#line 70
    buf___1[1] = (unsigned char )((mlen + 1U) >> 16);
#line 70
    buf___1[2] = (unsigned char )((mlen + 1U) >> 8);
#line 70
    buf___1[3] = (unsigned char )(mlen + 1U);
#line 70
    break;
  }
#line 71
  buf___1[4] = (unsigned char )type;
#line 72
  tmp___0 = atomicio((ssize_t (*)())(& write), socket___0, (void *)(buf___1), sizeof(buf___1));
#line 72
  if ((unsigned int )tmp___0 != sizeof(buf___1)) {
#line 73
    fatal("%s: write", "mm_request_send");
  }
#line 74
  tmp___1 = buffer_ptr(m___0);
#line 74
  tmp___2 = atomicio((ssize_t (*)())(& write), socket___0, tmp___1, mlen);
#line 74
  if ((u_int )tmp___2 != mlen) {
#line 75
    fatal("%s: write", "mm_request_send");
  }
#line 76
  return;
}
}
#line 78 "monitor_wrap.c"
void mm_request_receive(int socket___0 , Buffer *m___0 ) 
{ u_char buf___1[4] ;
  ssize_t res ;
  u_int msg_len ;
  void *tmp ;

  {
#line 85
  debug3("%s entering", "mm_request_receive");
#line 87
  res = atomicio((ssize_t (*)())(& read), socket___0, (void *)(buf___1), sizeof(buf___1));
#line 88
  if ((unsigned int )res != sizeof(buf___1)) {
#line 89
    if (res == 0) {
#line 90
      fatal_cleanup();
    }
#line 91
    fatal("%s: read: %ld", "mm_request_receive", (long )res);
  }
#line 93
  msg_len = (unsigned int )(((((unsigned long )buf___1[0] << 24) | ((unsigned long )buf___1[1] << 16)) | ((unsigned long )buf___1[2] << 8)) | (unsigned long )buf___1[3]);
#line 94
  if (msg_len > 262144U) {
#line 95
    fatal("%s: read: bad msg_len %d", "mm_request_receive", msg_len);
  }
#line 96
  buffer_clear(m___0);
#line 97
  buffer_append_space(m___0, msg_len);
#line 98
  tmp = buffer_ptr(m___0);
#line 98
  res = atomicio((ssize_t (*)())(& read), socket___0, tmp, msg_len);
#line 99
  if ((u_int )res != msg_len) {
#line 100
    fatal("%s: read: %ld != msg_len", "mm_request_receive", (long )res);
  }
#line 101
  return;
}
}
#line 103 "monitor_wrap.c"
void mm_request_receive_expect(int socket___0 , enum monitor_reqtype type , Buffer *m___0 ) 
{ u_char rtype ;
  int tmp ;

  {
#line 108
  debug3("%s entering: type %d", "mm_request_receive_expect", type);
#line 110
  mm_request_receive(socket___0, m___0);
#line 111
  tmp = buffer_get_char(m___0);
#line 111
  rtype = (unsigned char )tmp;
#line 112
  if ((int )rtype != (int )type) {
#line 113
    fatal("%s: read: rtype %d != type %d", "mm_request_receive_expect", rtype, type);
  }
#line 115
  return;
}
}
#line 117 "monitor_wrap.c"
DH *mm_choose_dh(int min , int nbits , int max ) 
{ BIGNUM *p ;
  BIGNUM *g ;
  int success ;
  Buffer m___0 ;
  u_int tmp ;
  DH *tmp___0 ;

  {
#line 121
  success = 0;
#line 124
  buffer_init(& m___0);
#line 125
  buffer_put_int(& m___0, (unsigned int )min);
#line 126
  buffer_put_int(& m___0, (unsigned int )nbits);
#line 127
  buffer_put_int(& m___0, (unsigned int )max);
#line 129
  mm_request_send(pmonitor->m_recvfd, 0, & m___0);
#line 131
  debug3("%s: waiting for MONITOR_ANS_MODULI", "mm_choose_dh");
#line 132
  mm_request_receive_expect(pmonitor->m_recvfd, 1, & m___0);
#line 134
  success = buffer_get_char(& m___0);
#line 135
  if (success == 0) {
#line 136
    fatal("%s: MONITOR_ANS_MODULI failed", "mm_choose_dh");
  }
#line 138
  p = BN_new();
#line 138
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 139
    fatal("%s: BN_new failed", "mm_choose_dh");
  }
#line 140
  g = BN_new();
#line 140
  if ((unsigned int )g == (unsigned int )((void *)0)) {
#line 141
    fatal("%s: BN_new failed", "mm_choose_dh");
  }
#line 142
  buffer_get_bignum2(& m___0, p);
#line 143
  buffer_get_bignum2(& m___0, g);
#line 145
  tmp = buffer_len(& m___0);
#line 145
  debug3("%s: remaining %d", "mm_choose_dh", tmp);
#line 146
  buffer_free(& m___0);
#line 148
  tmp___0 = dh_new_group(g, p);
#line 148
  return (tmp___0);
}
}
#line 151 "monitor_wrap.c"
int mm_key_sign(Key *key , u_char **sigp , u_int *lenp , u_char *data , u_int datalen ) 
{ Kex *kex ;
  Buffer m___0 ;
  int tmp ;
  void *tmp___0 ;

  {
#line 154
  kex = *(pmonitor->m_pkex);
#line 157
  debug3("%s entering", "mm_key_sign");
#line 159
  buffer_init(& m___0);
#line 160
  tmp = (*(kex->host_key_index))(key);
#line 160
  buffer_put_int(& m___0, (unsigned int )tmp);
#line 161
  buffer_put_string(& m___0, (void const   *)data, datalen);
#line 163
  mm_request_send(pmonitor->m_recvfd, 4, & m___0);
#line 165
  debug3("%s: waiting for MONITOR_ANS_SIGN", "mm_key_sign");
#line 166
  mm_request_receive_expect(pmonitor->m_recvfd, 5, & m___0);
#line 167
  tmp___0 = buffer_get_string(& m___0, lenp);
#line 167
  *sigp = (u_char *)tmp___0;
#line 168
  buffer_free(& m___0);
#line 170
  return (0);
}
}
#line 173 "monitor_wrap.c"
struct passwd *mm_getpwnamallow(char const   *login___0 ) 
{ Buffer m___0 ;
  struct passwd *pw ;
  u_int pwlen ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
#line 180
  debug3("%s entering", "mm_getpwnamallow");
#line 182
  buffer_init(& m___0);
#line 183
  buffer_put_cstring(& m___0, login___0);
#line 185
  mm_request_send(pmonitor->m_recvfd, 6, & m___0);
#line 187
  debug3("%s: waiting for MONITOR_ANS_PWNAM", "mm_getpwnamallow");
#line 188
  mm_request_receive_expect(pmonitor->m_recvfd, 7, & m___0);
#line 190
  tmp = buffer_get_char(& m___0);
#line 190
  if (tmp == 0) {
#line 191
    buffer_free(& m___0);
#line 192
    return ((struct passwd *)((void *)0));
  }
#line 194
  tmp___0 = buffer_get_string(& m___0, & pwlen);
#line 194
  pw = (struct passwd *)tmp___0;
#line 195
  if (pwlen != sizeof(struct passwd )) {
#line 196
    fatal("%s: struct passwd size mismatch", "mm_getpwnamallow");
  }
#line 197
  tmp___1 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 197
  pw->pw_name = (char *)tmp___1;
#line 198
  tmp___2 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 198
  pw->pw_passwd = (char *)tmp___2;
#line 199
  tmp___3 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 199
  pw->pw_gecos = (char *)tmp___3;
#line 203
  tmp___4 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 203
  pw->pw_dir = (char *)tmp___4;
#line 204
  tmp___5 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 204
  pw->pw_shell = (char *)tmp___5;
#line 205
  buffer_free(& m___0);
#line 207
  return (pw);
}
}
#line 210 "monitor_wrap.c"
char *mm_auth2_read_banner(void) 
{ Buffer m___0 ;
  char *banner ;
  void *tmp ;

  {
#line 215
  debug3("%s entering", "mm_auth2_read_banner");
#line 217
  buffer_init(& m___0);
#line 218
  mm_request_send(pmonitor->m_recvfd, 8, & m___0);
#line 219
  buffer_clear(& m___0);
#line 221
  mm_request_receive_expect(pmonitor->m_recvfd, 9, & m___0);
#line 222
  tmp = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 222
  banner = (char *)tmp;
#line 223
  buffer_free(& m___0);
#line 225
  return (banner);
}
}
#line 230 "monitor_wrap.c"
void mm_inform_authserv(char *service , char *style ) 
{ Buffer m___0 ;
  char const   *tmp ;

  {
#line 235
  debug3("%s entering", "mm_inform_authserv");
#line 237
  buffer_init(& m___0);
#line 238
  buffer_put_cstring(& m___0, (char const   *)service);
#line 239
  if (style) {
#line 239
    tmp = (char const   *)style;
  } else {
#line 239
    tmp = "";
  }
#line 239
  buffer_put_cstring(& m___0, tmp);
#line 241
  mm_request_send(pmonitor->m_recvfd, 3, & m___0);
#line 243
  buffer_free(& m___0);
#line 244
  return;
}
}
#line 247 "monitor_wrap.c"
int mm_auth_password(struct Authctxt *authctxt___0 , char *password ) 
{ Buffer m___0 ;
  int authenticated ;
  u_int tmp ;
  char const   *tmp___0 ;

  {
#line 251
  authenticated = 0;
#line 253
  debug3("%s entering", "mm_auth_password");
#line 255
  buffer_init(& m___0);
#line 256
  buffer_put_cstring(& m___0, (char const   *)password);
#line 257
  mm_request_send(pmonitor->m_recvfd, 10, & m___0);
#line 259
  debug3("%s: waiting for MONITOR_ANS_AUTHPASSWORD", "mm_auth_password");
#line 260
  mm_request_receive_expect(pmonitor->m_recvfd, 11, & m___0);
#line 262
  tmp = buffer_get_int(& m___0);
#line 262
  authenticated = (int )tmp;
#line 264
  buffer_free(& m___0);
#line 266
  if (authenticated) {
#line 266
    tmp___0 = "";
  } else {
#line 266
    tmp___0 = "not ";
  }
#line 266
  debug3("%s: user %sauthenticated", "mm_auth_password", tmp___0);
#line 268
  return (authenticated);
}
}
#line 271 "monitor_wrap.c"
int mm_user_key_allowed(struct passwd *pw , Key *key ) 
{ int tmp ;

  {
#line 274
  tmp = mm_key_allowed(2, (char *)((void *)0), (char *)((void *)0), key);
#line 274
  return (tmp);
}
}
#line 277 "monitor_wrap.c"
int mm_hostbased_key_allowed(struct passwd *pw , char *user , char *host , Key *key ) 
{ int tmp ;

  {
#line 281
  tmp = mm_key_allowed(1, user, host, key);
#line 281
  return (tmp);
}
}
#line 284 "monitor_wrap.c"
int mm_auth_rhosts_rsa_key_allowed(struct passwd *pw , char *user , char *host , Key *key ) 
{ int ret ;

  {
#line 290
  key->type = 1;
#line 291
  ret = mm_key_allowed(3, user, host, key);
#line 292
  key->type = 0;
#line 293
  return (ret);
}
}
#line 296 "monitor_wrap.c"
static void mm_send_debug(Buffer *m___0 ) 
{ char *msg ;
  void *tmp ;
  u_int tmp___0 ;

  {
#line 301
  while (1) {
#line 301
    tmp___0 = buffer_len(m___0);
#line 301
    if (! tmp___0) {
#line 301
      break;
    }
#line 302
    tmp = buffer_get_string(m___0, (u_int *)((void *)0));
#line 302
    msg = (char *)tmp;
#line 303
    debug3("%s: Sending debug: %s", "mm_send_debug", msg);
#line 304
    packet_send_debug("%s", msg);
#line 305
    xfree((void *)msg);
  }
#line 307
  return;
}
}
#line 309 "monitor_wrap.c"
int mm_key_allowed(enum mm_keytype type , char *user , char *host , Key *key ) 
{ Buffer m___0 ;
  u_char *blob ;
  u_int len ;
  int allowed ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  u_int tmp___2 ;

  {
#line 315
  allowed = 0;
#line 317
  debug3("%s entering", "mm_key_allowed");
#line 320
  tmp = key_to_blob(key, & blob, & len);
#line 320
  if (! tmp) {
#line 321
    return (0);
  }
#line 323
  buffer_init(& m___0);
#line 324
  buffer_put_int(& m___0, (unsigned int )type);
#line 325
  if (user) {
#line 325
    tmp___0 = (char const   *)user;
  } else {
#line 325
    tmp___0 = "";
  }
#line 325
  buffer_put_cstring(& m___0, tmp___0);
#line 326
  if (host) {
#line 326
    tmp___1 = (char const   *)host;
  } else {
#line 326
    tmp___1 = "";
  }
#line 326
  buffer_put_cstring(& m___0, tmp___1);
#line 327
  buffer_put_string(& m___0, (void const   *)blob, len);
#line 328
  xfree((void *)blob);
#line 330
  mm_request_send(pmonitor->m_recvfd, 20, & m___0);
#line 332
  debug3("%s: waiting for MONITOR_ANS_KEYALLOWED", "mm_key_allowed");
#line 333
  mm_request_receive_expect(pmonitor->m_recvfd, 21, & m___0);
#line 335
  tmp___2 = buffer_get_int(& m___0);
#line 335
  allowed = (int )tmp___2;
#line 338
  mm_send_debug(& m___0);
#line 340
  buffer_free(& m___0);
#line 342
  return (allowed);
}
}
#line 351 "monitor_wrap.c"
int mm_key_verify(Key *key , u_char *sig , u_int siglen , u_char *data , u_int datalen ) 
{ Buffer m___0 ;
  u_char *blob ;
  u_int len ;
  int verified ;
  int tmp ;
  u_int tmp___0 ;

  {
#line 357
  verified = 0;
#line 359
  debug3("%s entering", "mm_key_verify");
#line 362
  tmp = key_to_blob(key, & blob, & len);
#line 362
  if (! tmp) {
#line 363
    return (0);
  }
#line 365
  buffer_init(& m___0);
#line 366
  buffer_put_string(& m___0, (void const   *)blob, len);
#line 367
  buffer_put_string(& m___0, (void const   *)sig, siglen);
#line 368
  buffer_put_string(& m___0, (void const   *)data, datalen);
#line 369
  xfree((void *)blob);
#line 371
  mm_request_send(pmonitor->m_recvfd, 22, & m___0);
#line 373
  debug3("%s: waiting for MONITOR_ANS_KEYVERIFY", "mm_key_verify");
#line 374
  mm_request_receive_expect(pmonitor->m_recvfd, 23, & m___0);
#line 376
  tmp___0 = buffer_get_int(& m___0);
#line 376
  verified = (int )tmp___0;
#line 378
  buffer_free(& m___0);
#line 380
  return (verified);
}
}
#line 384 "monitor_wrap.c"
struct Newkeys *mm_newkeys_from_blob(u_char *blob , int blen ) 
{ Buffer b ;
  u_int len ;
  Newkeys *newkey ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  void *tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  Cipher *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  u_int tmp___7 ;
  void *tmp___8 ;
  u_int tmp___9 ;
  u_int tmp___10 ;
  void *tmp___11 ;

  {
#line 389
  newkey = (Newkeys *)((void *)0);
#line 394
  debug3("%s: %p(%d)", "mm_newkeys_from_blob", blob, blen);
#line 398
  buffer_init(& b);
#line 399
  buffer_append(& b, (void const   *)blob, (unsigned int )blen);
#line 401
  tmp = xmalloc(sizeof(*newkey));
#line 401
  newkey = (Newkeys *)tmp;
#line 402
  enc = & newkey->enc;
#line 403
  mac = & newkey->mac;
#line 404
  comp = & newkey->comp;
#line 407
  tmp___0 = buffer_get_string(& b, (u_int *)((void *)0));
#line 407
  enc->name = (char *)tmp___0;
#line 408
  buffer_get(& b, (void *)(& enc->cipher), sizeof(enc->cipher));
#line 409
  tmp___1 = buffer_get_int(& b);
#line 409
  enc->enabled = (int )tmp___1;
#line 410
  enc->block_size = buffer_get_int(& b);
#line 411
  tmp___2 = buffer_get_string(& b, & enc->key_len);
#line 411
  enc->key = (u_char *)tmp___2;
#line 412
  tmp___3 = buffer_get_string(& b, & len);
#line 412
  enc->iv = (u_char *)tmp___3;
#line 413
  if (len != enc->block_size) {
#line 414
    fatal("%s: bad ivlen: expected %d != %d", "mm_newkeys_from_blob", enc->block_size,
          len);
  }
#line 417
  if ((unsigned int )enc->name == (unsigned int )((void *)0)) {
#line 418
    fatal("%s: bad cipher name %s or pointer %p", "mm_newkeys_from_blob", enc->name,
          enc->cipher);
  } else {
#line 417
    tmp___4 = cipher_by_name((char const   *)enc->name);
#line 417
    if ((unsigned int )tmp___4 != (unsigned int )enc->cipher) {
#line 418
      fatal("%s: bad cipher name %s or pointer %p", "mm_newkeys_from_blob", enc->name,
            enc->cipher);
    }
  }
#line 422
  tmp___5 = buffer_get_string(& b, (u_int *)((void *)0));
#line 422
  mac->name = (char *)tmp___5;
#line 423
  if ((unsigned int )mac->name == (unsigned int )((void *)0)) {
#line 424
    fatal("%s: can not init mac %s", "mm_newkeys_from_blob", mac->name);
  } else {
#line 423
    tmp___6 = mac_init(mac, mac->name);
#line 423
    if (tmp___6 == -1) {
#line 424
      fatal("%s: can not init mac %s", "mm_newkeys_from_blob", mac->name);
    }
  }
#line 425
  tmp___7 = buffer_get_int(& b);
#line 425
  mac->enabled = (int )tmp___7;
#line 426
  tmp___8 = buffer_get_string(& b, & len);
#line 426
  mac->key = (u_char *)tmp___8;
#line 427
  if (len > (u_int )mac->key_len) {
#line 428
    fatal("%s: bad mac key length: %d > %d", "mm_newkeys_from_blob", len, mac->key_len);
  }
#line 430
  mac->key_len = (int )len;
#line 433
  tmp___9 = buffer_get_int(& b);
#line 433
  comp->type = (int )tmp___9;
#line 434
  tmp___10 = buffer_get_int(& b);
#line 434
  comp->enabled = (int )tmp___10;
#line 435
  tmp___11 = buffer_get_string(& b, (u_int *)((void *)0));
#line 435
  comp->name = (char *)tmp___11;
#line 437
  len = buffer_len(& b);
#line 438
  if (len != 0U) {
#line 439
    error("newkeys_from_blob: remaining bytes in blob %d", len);
  }
#line 440
  buffer_free(& b);
#line 441
  return (newkey);
}
}
#line 444 "monitor_wrap.c"
int mm_newkeys_to_blob(int mode , u_char **blobp , u_int *lenp ) 
{ Buffer b ;
  int len ;
  u_char *buf___1 ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  Newkeys *newkey ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 453
  newkey = newkeys[mode];
#line 455
  debug3("%s: converting %p", "mm_newkeys_to_blob", newkey);
#line 457
  if ((unsigned int )newkey == (unsigned int )((void *)0)) {
#line 458
    error("%s: newkey == NULL", "mm_newkeys_to_blob");
#line 459
    return (0);
  }
#line 461
  enc = & newkey->enc;
#line 462
  mac = & newkey->mac;
#line 463
  comp = & newkey->comp;
#line 465
  buffer_init(& b);
#line 467
  buffer_put_cstring(& b, (char const   *)enc->name);
#line 469
  buffer_append(& b, (void const   *)(& enc->cipher), sizeof(enc->cipher));
#line 470
  buffer_put_int(& b, (unsigned int )enc->enabled);
#line 471
  buffer_put_int(& b, enc->block_size);
#line 472
  buffer_put_string(& b, (void const   *)enc->key, enc->key_len);
#line 473
  packet_get_keyiv(mode, enc->iv, enc->block_size);
#line 474
  buffer_put_string(& b, (void const   *)enc->iv, enc->block_size);
#line 477
  buffer_put_cstring(& b, (char const   *)mac->name);
#line 478
  buffer_put_int(& b, (unsigned int )mac->enabled);
#line 479
  buffer_put_string(& b, (void const   *)mac->key, (unsigned int )mac->key_len);
#line 482
  buffer_put_int(& b, (unsigned int )comp->type);
#line 483
  buffer_put_int(& b, (unsigned int )comp->enabled);
#line 484
  buffer_put_cstring(& b, (char const   *)comp->name);
#line 486
  tmp = buffer_len(& b);
#line 486
  len = (int )tmp;
#line 487
  tmp___0 = xmalloc((unsigned int )len);
#line 487
  buf___1 = (u_char *)tmp___0;
#line 488
  tmp___1 = buffer_ptr(& b);
#line 488
  memcpy((void * __restrict  )buf___1, (void const   * __restrict  )tmp___1, (unsigned int )len);
#line 489
  tmp___2 = buffer_ptr(& b);
#line 489
  memset(tmp___2, 0, (unsigned int )len);
#line 490
  buffer_free(& b);
#line 491
  if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 492
    *lenp = (unsigned int )len;
  }
#line 493
  if ((unsigned int )blobp != (unsigned int )((void *)0)) {
#line 494
    *blobp = buf___1;
  }
#line 495
  return (len);
}
}
#line 498 "monitor_wrap.c"
static void mm_send_kex(Buffer *m___0 , Kex *kex ) 
{ u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;

  {
#line 501
  buffer_put_string(m___0, (void const   *)kex->session_id, (unsigned int )kex->session_id_len);
#line 502
  buffer_put_int(m___0, (unsigned int )kex->we_need);
#line 503
  buffer_put_int(m___0, (unsigned int )kex->hostkey_type);
#line 504
  buffer_put_int(m___0, (unsigned int )kex->kex_type);
#line 505
  tmp = buffer_len(& kex->my);
#line 505
  tmp___0 = buffer_ptr(& kex->my);
#line 505
  buffer_put_string(m___0, (void const   *)tmp___0, tmp);
#line 506
  tmp___1 = buffer_len(& kex->peer);
#line 506
  tmp___2 = buffer_ptr(& kex->peer);
#line 506
  buffer_put_string(m___0, (void const   *)tmp___2, tmp___1);
#line 507
  buffer_put_int(m___0, (unsigned int )kex->flags);
#line 508
  buffer_put_cstring(m___0, (char const   *)kex->client_version_string);
#line 509
  buffer_put_cstring(m___0, (char const   *)kex->server_version_string);
#line 510
  return;
}
}
#line 512 "monitor_wrap.c"
void mm_send_keystate(struct monitor *pmonitor___0 ) 
{ Buffer m___0 ;
  u_char *blob ;
  u_char *p ;
  u_int bloblen ;
  u_int plen ;
  u_char iv[24] ;
  u_char *key ;
  u_int ivlen ;
  u_int keylen ;
  u_int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  u_int32_t tmp___6 ;
  u_int32_t tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  void *tmp___11 ;
  u_int tmp___12 ;
  void *tmp___13 ;
  u_int tmp___14 ;
  void *tmp___15 ;

  {
#line 519
  buffer_init(& m___0);
#line 521
  if (! compat20) {
#line 526
    tmp = packet_get_protocol_flags();
#line 526
    buffer_put_int(& m___0, tmp);
#line 528
    tmp___0 = packet_get_ssh1_cipher();
#line 528
    buffer_put_int(& m___0, (unsigned int )tmp___0);
#line 530
    debug3("%s: Sending ssh1 KEY+IV", "mm_send_keystate");
#line 531
    keylen = packet_get_encryption_key((u_char *)((void *)0));
#line 532
    tmp___1 = xmalloc(keylen + 1U);
#line 532
    key = (u_char *)tmp___1;
#line 533
    keylen = packet_get_encryption_key(key);
#line 534
    buffer_put_string(& m___0, (void const   *)key, keylen);
#line 535
    memset((void *)key, 0, keylen);
#line 536
    xfree((void *)key);
#line 538
    tmp___2 = packet_get_keyiv_len(1);
#line 538
    ivlen = (unsigned int )tmp___2;
#line 539
    packet_get_keyiv(1, iv, ivlen);
#line 540
    buffer_put_string(& m___0, (void const   *)(iv), ivlen);
#line 541
    tmp___3 = packet_get_keyiv_len(1);
#line 541
    ivlen = (unsigned int )tmp___3;
#line 542
    packet_get_keyiv(0, iv, ivlen);
#line 543
    buffer_put_string(& m___0, (void const   *)(iv), ivlen);
    goto skip;
  } else {
#line 547
    mm_send_kex(& m___0, *(pmonitor___0->m_pkex));
  }
#line 550
  debug3("%s: Sending new keys: %p %p", "mm_send_keystate", newkeys[1], newkeys[0]);
#line 554
  tmp___4 = mm_newkeys_to_blob(1, & blob, & bloblen);
#line 554
  if (! tmp___4) {
#line 555
    fatal("%s: conversion of newkeys failed", "mm_send_keystate");
  }
#line 557
  buffer_put_string(& m___0, (void const   *)blob, bloblen);
#line 558
  xfree((void *)blob);
#line 560
  tmp___5 = mm_newkeys_to_blob(0, & blob, & bloblen);
#line 560
  if (! tmp___5) {
#line 561
    fatal("%s: conversion of newkeys failed", "mm_send_keystate");
  }
#line 563
  buffer_put_string(& m___0, (void const   *)blob, bloblen);
#line 564
  xfree((void *)blob);
#line 566
  tmp___6 = packet_get_seqnr(1);
#line 566
  buffer_put_int(& m___0, tmp___6);
#line 567
  tmp___7 = packet_get_seqnr(0);
#line 567
  buffer_put_int(& m___0, tmp___7);
#line 569
  debug3("%s: New keys have been sent", "mm_send_keystate");
  skip: 
#line 572
  tmp___8 = packet_get_keycontext(1, (u_char *)((void *)0));
#line 572
  plen = (unsigned int )tmp___8;
#line 573
  tmp___9 = xmalloc(plen + 1U);
#line 573
  p = (u_char *)tmp___9;
#line 574
  packet_get_keycontext(1, p);
#line 575
  buffer_put_string(& m___0, (void const   *)p, plen);
#line 576
  xfree((void *)p);
#line 578
  tmp___10 = packet_get_keycontext(0, (u_char *)((void *)0));
#line 578
  plen = (unsigned int )tmp___10;
#line 579
  tmp___11 = xmalloc(plen + 1U);
#line 579
  p = (u_char *)tmp___11;
#line 580
  packet_get_keycontext(0, p);
#line 581
  buffer_put_string(& m___0, (void const   *)p, plen);
#line 582
  xfree((void *)p);
#line 585
  debug3("%s: Sending compression state", "mm_send_keystate");
#line 586
  buffer_put_string(& m___0, (void const   *)(& outgoing_stream), sizeof(outgoing_stream));
#line 587
  buffer_put_string(& m___0, (void const   *)(& incoming_stream), sizeof(incoming_stream));
#line 590
  tmp___12 = buffer_len(& input);
#line 590
  tmp___13 = buffer_ptr(& input);
#line 590
  buffer_put_string(& m___0, (void const   *)tmp___13, tmp___12);
#line 591
  tmp___14 = buffer_len(& output);
#line 591
  tmp___15 = buffer_ptr(& output);
#line 591
  buffer_put_string(& m___0, (void const   *)tmp___15, tmp___14);
#line 593
  mm_request_send(pmonitor___0->m_recvfd, 24, & m___0);
#line 594
  debug3("%s: Finished sending state", "mm_send_keystate");
#line 596
  buffer_free(& m___0);
#line 597
  return;
}
}
#line 599 "monitor_wrap.c"
int mm_pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) 
{ Buffer m___0 ;
  u_char *p ;
  int success ;
  u_int tmp ;
  void *tmp___0 ;

  {
#line 604
  success = 0;
#line 606
  buffer_init(& m___0);
#line 607
  mm_request_send(pmonitor->m_recvfd, 25, & m___0);
#line 609
  debug3("%s: waiting for MONITOR_ANS_PTY", "mm_pty_allocate");
#line 610
  mm_request_receive_expect(pmonitor->m_recvfd, 26, & m___0);
#line 612
  tmp = buffer_get_int(& m___0);
#line 612
  success = (int )tmp;
#line 613
  if (success == 0) {
#line 614
    debug3("%s: pty alloc failed", "mm_pty_allocate");
#line 615
    buffer_free(& m___0);
#line 616
    return (0);
  }
#line 618
  tmp___0 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 618
  p = (u_char *)tmp___0;
#line 619
  buffer_free(& m___0);
#line 621
  strlcpy(namebuf, (char const   *)p, (unsigned int )namebuflen);
#line 622
  xfree((void *)p);
#line 624
  *ptyfd = mm_receive_fd(pmonitor->m_recvfd);
#line 625
  *ttyfd = mm_receive_fd(pmonitor->m_recvfd);
#line 628
  return (1);
}
}
#line 631 "monitor_wrap.c"
void mm_session_pty_cleanup2(void *session ) 
{ Session *s ;
  Buffer m___0 ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 634
  s = (Session *)session;
#line 637
  if (s->ttyfd == -1) {
#line 638
    return;
  }
#line 639
  buffer_init(& m___0);
#line 640
  buffer_put_cstring(& m___0, (char const   *)(s->tty));
#line 641
  mm_request_send(pmonitor->m_recvfd, 27, & m___0);
#line 642
  buffer_free(& m___0);
#line 645
  tmp___1 = close(s->ptymaster);
#line 645
  if (tmp___1 < 0) {
#line 646
    tmp = __errno_location();
#line 646
    tmp___0 = strerror(*tmp);
#line 646
    error("close(s->ptymaster): %s", tmp___0);
  }
#line 649
  s->ttyfd = -1;
#line 650
  return;
}
}
#line 671 "monitor_wrap.c"
void mm_terminate(void) 
{ Buffer m___0 ;

  {
#line 676
  buffer_init(& m___0);
#line 677
  mm_request_send(pmonitor->m_recvfd, 38, & m___0);
#line 678
  buffer_free(& m___0);
#line 679
  return;
}
}
#line 681 "monitor_wrap.c"
int mm_ssh1_session_key(BIGNUM *num ) 
{ int rsafail ;
  Buffer m___0 ;
  u_int tmp ;

  {
#line 687
  buffer_init(& m___0);
#line 688
  buffer_put_bignum2(& m___0, num);
#line 689
  mm_request_send(pmonitor->m_recvfd, 28, & m___0);
#line 691
  mm_request_receive_expect(pmonitor->m_recvfd, 29, & m___0);
#line 693
  tmp = buffer_get_int(& m___0);
#line 693
  rsafail = (int )tmp;
#line 694
  buffer_get_bignum2(& m___0, num);
#line 696
  buffer_free(& m___0);
#line 698
  return (rsafail);
}
}
#line 701 "monitor_wrap.c"
static void mm_chall_setup(char **name , char **infotxt , u_int *numprompts , char ***prompts ,
                           u_int **echo_on ) 
{ void *tmp ;
  void *tmp___0 ;

  {
#line 705
  *name = xstrdup("");
#line 706
  *infotxt = xstrdup("");
#line 707
  *numprompts = 1U;
#line 708
  tmp = xmalloc(*numprompts * sizeof(char *));
#line 708
  *prompts = (char **)tmp;
#line 709
  tmp___0 = xmalloc(*numprompts * sizeof(u_int ));
#line 709
  *echo_on = (u_int *)tmp___0;
#line 710
  *(*echo_on + 0) = 0U;
#line 711
  return;
}
}
#line 713 "monitor_wrap.c"
int mm_bsdauth_query(void *ctx , char **name , char **infotxt , u_int *numprompts ,
                     char ***prompts , u_int **echo_on ) 
{ Buffer m___0 ;
  int res ;
  char *challenge ;
  u_int tmp ;
  void *tmp___0 ;

  {
#line 721
  debug3("%s: entering", "mm_bsdauth_query");
#line 723
  buffer_init(& m___0);
#line 724
  mm_request_send(pmonitor->m_recvfd, 12, & m___0);
#line 726
  mm_request_receive_expect(pmonitor->m_recvfd, 13, & m___0);
#line 728
  tmp = buffer_get_int(& m___0);
#line 728
  res = (int )tmp;
#line 729
  if (res == -1) {
#line 730
    debug3("%s: no challenge", "mm_bsdauth_query");
#line 731
    buffer_free(& m___0);
#line 732
    return (-1);
  }
#line 736
  tmp___0 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 736
  challenge = (char *)tmp___0;
#line 737
  buffer_free(& m___0);
#line 739
  mm_chall_setup(name, infotxt, numprompts, prompts, echo_on);
#line 740
  *(*prompts + 0) = challenge;
#line 742
  debug3("%s: received challenge: %s", "mm_bsdauth_query", challenge);
#line 744
  return (0);
}
}
#line 747 "monitor_wrap.c"
int mm_bsdauth_respond(void *ctx , u_int numresponses , char **responses ) 
{ Buffer m___0 ;
  int authok ;
  u_int tmp ;
  int tmp___0 ;

  {
#line 753
  debug3("%s: entering", "mm_bsdauth_respond");
#line 754
  if (numresponses != 1U) {
#line 755
    return (-1);
  }
#line 757
  buffer_init(& m___0);
#line 758
  buffer_put_cstring(& m___0, (char const   *)*(responses + 0));
#line 759
  mm_request_send(pmonitor->m_recvfd, 14, & m___0);
#line 761
  mm_request_receive_expect(pmonitor->m_recvfd, 15, & m___0);
#line 764
  tmp = buffer_get_int(& m___0);
#line 764
  authok = (int )tmp;
#line 765
  buffer_free(& m___0);
#line 767
  if (authok == 0) {
#line 767
    tmp___0 = -1;
  } else {
#line 767
    tmp___0 = 0;
  }
#line 767
  return (tmp___0);
}
}
#line 770 "monitor_wrap.c"
int mm_skey_query(void *ctx , char **name , char **infotxt , u_int *numprompts , char ***prompts ,
                  u_int **echo_on ) 
{ Buffer m___0 ;
  int len ;
  int res ;
  char *p ;
  char *challenge ;
  u_int tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
#line 778
  debug3("%s: entering", "mm_skey_query");
#line 780
  buffer_init(& m___0);
#line 781
  mm_request_send(pmonitor->m_recvfd, 16, & m___0);
#line 783
  mm_request_receive_expect(pmonitor->m_recvfd, 17, & m___0);
#line 785
  tmp = buffer_get_int(& m___0);
#line 785
  res = (int )tmp;
#line 786
  if (res == -1) {
#line 787
    debug3("%s: no challenge", "mm_skey_query");
#line 788
    buffer_free(& m___0);
#line 789
    return (-1);
  }
#line 793
  tmp___0 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 793
  challenge = (char *)tmp___0;
#line 794
  buffer_free(& m___0);
#line 796
  debug3("%s: received challenge: %s", "mm_skey_query", challenge);
#line 798
  mm_chall_setup(name, infotxt, numprompts, prompts, echo_on);
#line 800
  tmp___1 = strlen((char const   *)challenge);
#line 800
  tmp___2 = strlen("\nS/Key Password: ");
#line 800
  len = (int )((tmp___1 + tmp___2) + 1U);
#line 801
  tmp___3 = xmalloc((unsigned int )len);
#line 801
  p = (char *)tmp___3;
#line 802
  strlcpy(p, (char const   *)challenge, (unsigned int )len);
#line 803
  strlcat(p, "\nS/Key Password: ", (unsigned int )len);
#line 804
  *(*prompts + 0) = p;
#line 805
  xfree((void *)challenge);
#line 807
  return (0);
}
}
#line 810 "monitor_wrap.c"
int mm_skey_respond(void *ctx , u_int numresponses , char **responses ) 
{ Buffer m___0 ;
  int authok ;
  u_int tmp ;
  int tmp___0 ;

  {
#line 816
  debug3("%s: entering", "mm_skey_respond");
#line 817
  if (numresponses != 1U) {
#line 818
    return (-1);
  }
#line 820
  buffer_init(& m___0);
#line 821
  buffer_put_cstring(& m___0, (char const   *)*(responses + 0));
#line 822
  mm_request_send(pmonitor->m_recvfd, 18, & m___0);
#line 824
  mm_request_receive_expect(pmonitor->m_recvfd, 19, & m___0);
#line 827
  tmp = buffer_get_int(& m___0);
#line 827
  authok = (int )tmp;
#line 828
  buffer_free(& m___0);
#line 830
  if (authok == 0) {
#line 830
    tmp___0 = -1;
  } else {
#line 830
    tmp___0 = 0;
  }
#line 830
  return (tmp___0);
}
}
#line 833 "monitor_wrap.c"
void mm_ssh1_session_id(u_char *session_id___0 ) 
{ Buffer m___0 ;
  int i ;

  {
#line 839
  debug3("%s entering", "mm_ssh1_session_id");
#line 841
  buffer_init(& m___0);
#line 842
  i = 0;
#line 842
  while (i < 16) {
#line 843
    buffer_put_char(& m___0, (int )*(session_id___0 + i));
#line 842
    i ++;
  }
#line 845
  mm_request_send(pmonitor->m_recvfd, 30, & m___0);
#line 846
  buffer_free(& m___0);
#line 847
  return;
}
}
#line 849 "monitor_wrap.c"
int mm_auth_rsa_key_allowed(struct passwd *pw , BIGNUM *client_n , Key **rkey ) 
{ Buffer m___0 ;
  Key *key ;
  u_char *blob ;
  u_int blen ;
  int allowed ;
  u_int tmp ;
  void *tmp___0 ;

  {
#line 856
  allowed = 0;
#line 858
  debug3("%s entering", "mm_auth_rsa_key_allowed");
#line 860
  buffer_init(& m___0);
#line 861
  buffer_put_bignum2(& m___0, client_n);
#line 863
  mm_request_send(pmonitor->m_recvfd, 31, & m___0);
#line 864
  mm_request_receive_expect(pmonitor->m_recvfd, 32, & m___0);
#line 866
  tmp = buffer_get_int(& m___0);
#line 866
  allowed = (int )tmp;
#line 868
  if (allowed) {
#line 868
    if ((unsigned int )rkey != (unsigned int )((void *)0)) {
#line 869
      tmp___0 = buffer_get_string(& m___0, & blen);
#line 869
      blob = (u_char *)tmp___0;
#line 870
      key = key_from_blob(blob, (int )blen);
#line 870
      if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 871
        fatal("%s: key_from_blob failed", "mm_auth_rsa_key_allowed");
      }
#line 872
      *rkey = key;
#line 873
      xfree((void *)blob);
    }
  }
#line 875
  mm_send_debug(& m___0);
#line 876
  buffer_free(& m___0);
#line 878
  return (allowed);
}
}
#line 881 "monitor_wrap.c"
BIGNUM *mm_auth_rsa_generate_challenge(Key *key ) 
{ Buffer m___0 ;
  BIGNUM *challenge ;
  u_char *blob ;
  u_int blen ;
  int tmp ;

  {
#line 889
  debug3("%s entering", "mm_auth_rsa_generate_challenge");
#line 891
  challenge = BN_new();
#line 891
  if ((unsigned int )challenge == (unsigned int )((void *)0)) {
#line 892
    fatal("%s: BN_new failed", "mm_auth_rsa_generate_challenge");
  }
#line 894
  key->type = 1;
#line 895
  tmp = key_to_blob(key, & blob, & blen);
#line 895
  if (tmp == 0) {
#line 896
    fatal("%s: key_to_blob failed", "mm_auth_rsa_generate_challenge");
  }
#line 897
  key->type = 0;
#line 899
  buffer_init(& m___0);
#line 900
  buffer_put_string(& m___0, (void const   *)blob, blen);
#line 901
  xfree((void *)blob);
#line 903
  mm_request_send(pmonitor->m_recvfd, 33, & m___0);
#line 904
  mm_request_receive_expect(pmonitor->m_recvfd, 34, & m___0);
#line 906
  buffer_get_bignum2(& m___0, challenge);
#line 907
  buffer_free(& m___0);
#line 909
  return (challenge);
}
}
#line 912 "monitor_wrap.c"
int mm_auth_rsa_verify_response(Key *key , BIGNUM *p , u_char *response ) 
{ Buffer m___0 ;
  u_char *blob ;
  u_int blen ;
  int success ;
  int tmp ;
  u_int tmp___0 ;

  {
#line 918
  success = 0;
#line 920
  debug3("%s entering", "mm_auth_rsa_verify_response");
#line 922
  key->type = 1;
#line 923
  tmp = key_to_blob(key, & blob, & blen);
#line 923
  if (tmp == 0) {
#line 924
    fatal("%s: key_to_blob failed", "mm_auth_rsa_verify_response");
  }
#line 925
  key->type = 0;
#line 927
  buffer_init(& m___0);
#line 928
  buffer_put_string(& m___0, (void const   *)blob, blen);
#line 929
  buffer_put_string(& m___0, (void const   *)response, 16U);
#line 930
  xfree((void *)blob);
#line 932
  mm_request_send(pmonitor->m_recvfd, 35, & m___0);
#line 933
  mm_request_receive_expect(pmonitor->m_recvfd, 36, & m___0);
#line 935
  tmp___0 = buffer_get_int(& m___0);
#line 935
  success = (int )tmp___0;
#line 936
  buffer_free(& m___0);
#line 938
  return (success);
}
}
#line 1 "monitor_fdpass.o"
#line 171 "/usr/include/sys/socket.h"
extern ssize_t sendmsg(int __fd , struct msghdr  const  *__message , int __flags ) ;
#line 179
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 31 "monitor_fdpass.h"
void mm_send_fd(int socket___0 , int fd ) ;
#line 34 "monitor_fdpass.c"
void mm_send_fd(int socket___0 , int fd ) 
{ struct msghdr msg ;
  struct iovec vec ;
  char ch ;
  int n___0 ;
  char tmp[(((sizeof(int ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U))] ;
  struct cmsghdr *cmsg ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 40
  ch = (char )'\000';
#line 47
  memset((void *)(& msg), 0, sizeof(msg));
#line 52
  msg.msg_control = (void *)(tmp);
#line 53
  msg.msg_controllen = (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U)) + sizeof(int );
#line 54
  if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 54
    cmsg = (struct cmsghdr *)msg.msg_control;
  } else {
#line 54
    cmsg = (struct cmsghdr *)((void *)0);
  }
#line 55
  cmsg->cmsg_len = (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U)) + sizeof(int );
#line 56
  cmsg->cmsg_level = 1;
#line 57
  cmsg->cmsg_type = 1;
#line 58
  *((int *)(cmsg->__cmsg_data)) = fd;
#line 61
  vec.iov_base = (void *)(& ch);
#line 62
  vec.iov_len = 1U;
#line 63
  msg.msg_iov = & vec;
#line 64
  msg.msg_iovlen = 1U;
#line 66
  n___0 = sendmsg(socket___0, (struct msghdr  const  *)(& msg), 0);
#line 66
  if (n___0 == -1) {
#line 67
    tmp___0 = __errno_location();
#line 67
    tmp___1 = strerror(*tmp___0);
#line 67
    fatal("%s: sendmsg(%d): %s", "mm_send_fd", fd, tmp___1);
  }
#line 69
  if (n___0 != 1) {
#line 70
    fatal("%s: sendmsg: expected sent 1 got %d", "mm_send_fd", n___0);
  }
#line 76
  return;
}
}
#line 78 "monitor_fdpass.c"
int mm_receive_fd(int socket___0 ) 
{ struct msghdr msg ;
  struct iovec vec ;
  char ch ;
  int fd ;
  int n___0 ;
  char tmp[(((sizeof(int ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U))] ;
  struct cmsghdr *cmsg ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 91
  memset((void *)(& msg), 0, sizeof(msg));
#line 92
  vec.iov_base = (void *)(& ch);
#line 93
  vec.iov_len = 1U;
#line 94
  msg.msg_iov = & vec;
#line 95
  msg.msg_iovlen = 1U;
#line 100
  msg.msg_control = (void *)(tmp);
#line 101
  msg.msg_controllen = sizeof(tmp);
#line 104
  n___0 = recvmsg(socket___0, & msg, 0);
#line 104
  if (n___0 == -1) {
#line 105
    tmp___0 = __errno_location();
#line 105
    tmp___1 = strerror(*tmp___0);
#line 105
    fatal("%s: recvmsg: %s", "mm_receive_fd", tmp___1);
  }
#line 106
  if (n___0 != 1) {
#line 107
    fatal("%s: recvmsg: expected received 1 got %d", "mm_receive_fd", n___0);
  }
#line 114
  if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 114
    cmsg = (struct cmsghdr *)msg.msg_control;
  } else {
#line 114
    cmsg = (struct cmsghdr *)((void *)0);
  }
#line 115
  if (cmsg->cmsg_type != 1) {
#line 116
    fatal("%s: expected type %d got %d", "mm_receive_fd", 1, cmsg->cmsg_type);
  }
#line 118
  fd = *((int *)(cmsg->__cmsg_data));
#line 120
  return (fd);
}
}
#line 1 "sshd.o"
#line 92 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 79 "/usr/include/pwd.h"
extern void endpwent(void) ;
#line 393 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 457
extern  __attribute__((__nothrow__)) int chdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 490
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 516
extern  __attribute__((__nothrow__)) int execv(char const   *__path , char * const  *__argv )  __attribute__((__nonnull__(1))) ;
#line 903
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
#line 910
extern  __attribute__((__nothrow__)) int chroot(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 478 "/usr/include/openssl/bn.h"
extern int BN_mask_bits(BIGNUM *a , int n ) ;
#line 104 "/usr/include/openssl/rand.h"
extern void RAND_seed(void const   *buf , int num ) ;
#line 136 "servconf.h"
void initialize_server_options(ServerOptions *options___0 ) ;
#line 137
void read_server_config(ServerOptions *options___0 , char const   *filename ) ;
#line 138
void fill_default_server_options(ServerOptions *options___0 ) ;
#line 139
int process_server_config_line(ServerOptions *options___0 , char *line , char const   *filename ,
                               int linenum ) ;
#line 711 "/usr/include/openssl/evp.h"
extern void OPENSSL_add_all_algorithms_noconf(void) ;
#line 39 "myproposal.h"
static char *myproposal[10]  = 
#line 39 "myproposal.h"
  {      (char *)"diffie-hellman-group-exchange-sha1,diffie-hellman-group1-sha1",      (char *)"ssh-rsa,ssh-dss",      (char *)"aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,arcfour,aes192-cbc,aes256-cbc,rijndael-cbc@lysator.liu.se",      (char *)"aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,arcfour,aes192-cbc,aes256-cbc,rijndael-cbc@lysator.liu.se", 
        (char *)"hmac-md5,hmac-sha1,hmac-ripemd160,hmac-ripemd160@openssh.com,hmac-sha1-96,hmac-md5-96",      (char *)"hmac-md5,hmac-sha1,hmac-ripemd160,hmac-ripemd160@openssh.com,hmac-sha1-96,hmac-md5-96",      (char *)"none,zlib",      (char *)"none,zlib", 
        (char *)"",      (char *)""};
#line 138 "auth.h"
Authctxt *do_authentication(void) ;
#line 139
Authctxt *do_authentication2(void) ;
#line 148
void privsep_challenge_enable(void) ;
#line 177
Key *get_hostkey_by_index(int ind ) ;
#line 178
Key *get_hostkey_by_type(int type ) ;
#line 179
int get_hostkey_index(Key *key ) ;
#line 180
int ssh1_session_key(BIGNUM *session_key_int ) ;
#line 58 "session.h"
void do_authenticated(Authctxt *authctxt___0 ) ;
#line 70
void do_setusercontext(struct passwd *pw ) ;
#line 66 "monitor.h"
struct monitor *monitor_init(void) ;
#line 67
void monitor_reinit(struct monitor *mon ) ;
#line 68
void monitor_sync(struct monitor *pmonitor___0 ) ;
#line 71
struct Authctxt *monitor_child_preauth(struct monitor *pmonitor___0 ) ;
#line 72
void monitor_child_postauth(struct monitor *pmonitor___0 ) ;
#line 74 "monitor_wrap.h"
void monitor_apply_keystate(struct monitor *pmonitor___0 ) ;
#line 106 "sshd.c"
ServerOptions options  ;
#line 109 "sshd.c"
char *config_file_name  =    (char *)"/usr/local/etc/sshd_config";
#line 118 "sshd.c"
int IPv4or6  =    0;
#line 127 "sshd.c"
int debug_flag  =    0;
#line 130 "sshd.c"
int test_flag  =    0;
#line 133 "sshd.c"
int inetd_flag  =    0;
#line 136 "sshd.c"
int no_daemon_flag  =    0;
#line 139 "sshd.c"
int log_stderr  =    0;
#line 142 "sshd.c"
char **saved_argv  ;
#line 143 "sshd.c"
int saved_argc  ;
#line 150 "sshd.c"
int listen_socks[16]  ;
#line 151 "sshd.c"
int num_listen_socks  =    0;
#line 157 "sshd.c"
char *client_version_string  =    (char *)((void *)0);
#line 158 "sshd.c"
char *server_version_string  =    (char *)((void *)0);
#line 161 "sshd.c"
Kex *xxx_kex  ;
#line 171 "sshd.c"
struct __anonstruct_sensitive_data_74 sensitive_data  ;
#line 184 "sshd.c"
static int volatile   key_do_regen  =    (sig_atomic_t volatile   )0;
#line 187 "sshd.c"
static int volatile   received_sighup  =    (sig_atomic_t volatile   )0;
#line 188 "sshd.c"
static int volatile   received_sigterm  =    (sig_atomic_t volatile   )0;
#line 191 "sshd.c"
u_char session_id[16]  ;
#line 194 "sshd.c"
u_char *session_id2  =    (u_char *)((void *)0);
#line 195 "sshd.c"
int session_id2_len  =    0;
#line 198 "sshd.c"
u_int utmp_len  =    (u_int )64;
#line 201 "sshd.c"
int *startup_pipes  =    (int *)((void *)0);
#line 202 "sshd.c"
int startup_pipe  ;
#line 209
void destroy_sensitive_data(void) ;
#line 210
void demote_sensitive_data(void) ;
#line 212
static void do_ssh1_kex(void) ;
#line 213
static void do_ssh2_kex(void) ;
#line 218 "sshd.c"
static void close_listen_socks(void) 
{ int i ;

  {
#line 223
  i = 0;
#line 223
  while (i < num_listen_socks) {
#line 224
    close(listen_socks[i]);
#line 223
    i ++;
  }
#line 225
  num_listen_socks = -1;
#line 226
  return;
}
}
#line 228 "sshd.c"
static void close_startup_pipes(void) 
{ int i ;

  {
#line 233
  if (startup_pipes) {
#line 234
    i = 0;
#line 234
    while (i < options.max_startups) {
#line 235
      if (*(startup_pipes + i) != -1) {
#line 236
        close(*(startup_pipes + i));
      }
#line 234
      i ++;
    }
  }
#line 237
  return;
}
}
#line 244 "sshd.c"
static void sighup_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 247
  tmp = __errno_location();
#line 247
  save_errno = *tmp;
#line 249
  received_sighup = (int volatile   )1;
#line 250
  signal(1, & sighup_handler);
#line 251
  tmp___0 = __errno_location();
#line 251
  *tmp___0 = save_errno;
#line 252
  return;
}
}
#line 258 "sshd.c"
static void sighup_restart(void) 
{ int *tmp ;
  char *tmp___0 ;

  {
#line 261
  log("Received SIGHUP; restarting.");
#line 262
  close_listen_socks();
#line 263
  close_startup_pipes();
#line 264
  execv((char const   *)*(saved_argv + 0), (char * const  *)saved_argv);
#line 265
  tmp = __errno_location();
#line 265
  tmp___0 = strerror(*tmp);
#line 265
  log("RESTART FAILED: av[0]=\'%.100s\', error: %.100s.", *(saved_argv + 0), tmp___0);
#line 267
  exit(1);
}
}
#line 273 "sshd.c"
static void sigterm_handler(int sig ) 
{ 

  {
#line 276
  received_sigterm = (int volatile   )sig;
#line 277
  return;
}
}
#line 283 "sshd.c"
static void main_sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  pid_t pid ;
  int status ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 286
  tmp = __errno_location();
#line 286
  save_errno = *tmp;
#line 290
  while (1) {
#line 290
    pid = waitpid(-1, & status, 1);
#line 290
    if (! (pid > 0)) {
#line 290
      if (pid < 0) {
#line 290
        tmp___0 = __errno_location();
#line 290
        if (! (*tmp___0 == 4)) {
#line 290
          break;
        }
      } else {
#line 290
        break;
      }
    }
  }
#line 294
  signal(17, & main_sigchld_handler);
#line 295
  tmp___1 = __errno_location();
#line 295
  *tmp___1 = save_errno;
#line 296
  return;
}
}
#line 301 "sshd.c"
static void grace_alarm_handler(int sig ) 
{ char const   *tmp ;

  {
#line 307
  packet_close();
#line 310
  tmp = get_remote_ipaddr();
#line 310
  fatal("Timeout before authentication for %s.", tmp);
#line 311
  return;
}
}
#line 320 "sshd.c"
static void generate_ephemeral_server_key(void) 
{ u_int32_t rand___0 ;
  int i ;
  char const   *tmp ;

  {
#line 323
  rand___0 = (u_int32_t )0;
#line 326
  if (sensitive_data.server_key) {
#line 326
    tmp = "new ";
  } else {
#line 326
    tmp = "";
  }
#line 326
  verbose("Generating %s%d bit RSA key.", tmp, options.server_key_bits);
#line 328
  if ((unsigned int )sensitive_data.server_key != (unsigned int )((void *)0)) {
#line 329
    key_free(sensitive_data.server_key);
  }
#line 330
  sensitive_data.server_key = key_generate(0, (unsigned int )options.server_key_bits);
#line 332
  verbose("RSA key generation complete.");
#line 334
  i = 0;
#line 334
  while (i < 32) {
#line 335
    if (i % 4 == 0) {
#line 336
      rand___0 = arc4random();
    }
#line 337
    sensitive_data.ssh1_cookie[i] = (unsigned char )(rand___0 & 255U);
#line 338
    rand___0 >>= 8;
#line 334
    i ++;
  }
#line 340
  arc4random_stir();
#line 341
  return;
}
}
#line 343 "sshd.c"
static void key_regeneration_alarm(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 346
  tmp = __errno_location();
#line 346
  save_errno = *tmp;
#line 348
  signal(14, (void (*)(int  ))0);
#line 349
  tmp___0 = __errno_location();
#line 349
  *tmp___0 = save_errno;
#line 350
  key_do_regen = (int volatile   )1;
#line 351
  return;
}
}
#line 353 "sshd.c"
static void sshd_exchange_identification(int sock_in , int sock_out ) 
{ int i ;
  int mismatch ;
  int remote_major ;
  int remote_minor ;
  int major ;
  int minor ;
  char *s ;
  char buf___1[256] ;
  char remote_version[256] ;
  char const   *tmp ;
  size_t tmp___0 ;
  ssize_t tmp___1 ;
  size_t tmp___2 ;
  char const   *tmp___3 ;
  ssize_t tmp___4 ;
  int tmp___18 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t tmp___31 ;
  char const   *tmp___32 ;
  int tmp___33 ;
  char const   *tmp___34 ;
  size_t tmp___35 ;
  char const   *tmp___36 ;

  {
#line 363
  if (options.protocol & 1) {
#line 363
    if (options.protocol & 4) {
#line 365
      major = 1;
#line 366
      minor = 99;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 367
    if (options.protocol & 4) {
#line 368
      major = 2;
#line 369
      minor = 0;
    } else {
#line 371
      major = 1;
#line 372
      minor = 5;
    }
  }
#line 374
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"SSH-%d.%d-%.100s\n",
           major, minor, "OpenSSH_3.4p1");
#line 375
  server_version_string = xstrdup((char const   *)(buf___1));
#line 377
  if ((unsigned int )client_version_string == (unsigned int )((void *)0)) {
#line 379
    tmp___0 = strlen((char const   *)server_version_string);
#line 379
    tmp___1 = atomicio((ssize_t (*)())(& write), sock_out, (void *)server_version_string,
                       tmp___0);
#line 379
    tmp___2 = strlen((char const   *)server_version_string);
#line 379
    if ((size_t )tmp___1 != tmp___2) {
#line 382
      tmp = get_remote_ipaddr();
#line 382
      log("Could not write ident string to %s", tmp);
#line 383
      fatal_cleanup();
    }
#line 387
    memset((void *)(buf___1), 0, sizeof(buf___1));
#line 388
    i = 0;
#line 388
    while ((unsigned int )i < sizeof(buf___1) - 1U) {
#line 389
      tmp___4 = atomicio((ssize_t (*)())(& read), sock_in, (void *)(& buf___1[i]),
                         1U);
#line 389
      if (tmp___4 != 1) {
#line 390
        tmp___3 = get_remote_ipaddr();
#line 390
        log("Did not receive identification string from %s", tmp___3);
#line 392
        fatal_cleanup();
      }
#line 394
      if ((int )buf___1[i] == 13) {
#line 395
        buf___1[i] = (char)0;
#line 398
        if (i == 12) {
#line 398
          if (0) {
#line 398
            if (0) {
#line 398
              __s1_len___0 = strlen((char const   *)(buf___1));
#line 398
              __s2_len___0 = strlen("SSH-1.5-W1.0");
#line 398
              if (! ((unsigned int )((void const   *)(buf___1 + 1)) - (unsigned int )((void const   *)(buf___1)) == 1U)) {
                goto _L___3;
              } else {
#line 398
                if (__s1_len___0 >= 4U) {
                  _L___3: /* CIL Label */ 
#line 398
                  if (! ((unsigned int )((void const   *)("SSH-1.5-W1.0" + 1)) - (unsigned int )((void const   *)"SSH-1.5-W1.0") == 1U)) {
#line 398
                    tmp___28 = 1;
                  } else {
#line 398
                    if (__s2_len___0 >= 4U) {
#line 398
                      tmp___28 = 1;
                    } else {
#line 398
                      tmp___28 = 0;
                    }
                  }
                } else {
#line 398
                  tmp___28 = 0;
                }
              }
#line 398
              if (tmp___28) {
#line 398
                tmp___24 = __builtin_strcmp((char const   *)(buf___1), "SSH-1.5-W1.0");
              } else {
#line 398
                tmp___27 = __builtin_strcmp((char const   *)(buf___1), "SSH-1.5-W1.0");
#line 398
                tmp___24 = tmp___27;
              }
            } else {
#line 398
              tmp___27 = __builtin_strcmp((char const   *)(buf___1), "SSH-1.5-W1.0");
#line 398
              tmp___24 = tmp___27;
            }
#line 398
            tmp___18 = tmp___24;
          } else {
#line 398
            tmp___18 = strncmp((char const   *)(buf___1), "SSH-1.5-W1.0", 12U);
          }
#line 398
          if (tmp___18 == 0) {
#line 399
            break;
          }
        }
        goto __Cont;
      }
#line 402
      if ((int )buf___1[i] == 10) {
#line 403
        buf___1[i] = (char)0;
#line 404
        break;
      }
      __Cont: /* CIL Label */ 
#line 388
      i ++;
    }
#line 407
    buf___1[sizeof(buf___1) - 1U] = (char)0;
#line 408
    client_version_string = xstrdup((char const   *)(buf___1));
  }
#line 415
  tmp___33 = sscanf((char const   * __restrict  )client_version_string, (char const   * __restrict  )"SSH-%d.%d-%[^\n]\n",
                    & remote_major, & remote_minor, remote_version);
#line 415
  if (tmp___33 != 3) {
#line 417
    s = (char *)"Protocol mismatch.\n";
#line 418
    tmp___31 = strlen((char const   *)s);
#line 418
    atomicio((ssize_t (*)())(& write), sock_out, (void *)s, tmp___31);
#line 419
    close(sock_in);
#line 420
    close(sock_out);
#line 421
    tmp___32 = get_remote_ipaddr();
#line 421
    log("Bad protocol version identification \'%.100s\' from %s", client_version_string,
        tmp___32);
#line 423
    fatal_cleanup();
  }
#line 425
  debug("Client protocol version %d.%d; client software version %.100s", remote_major,
        remote_minor, remote_version);
#line 428
  compat_datafellows((char const   *)(remote_version));
#line 430
  if (datafellows & 2048) {
#line 431
    tmp___34 = get_remote_ipaddr();
#line 431
    log("scanned from %s with %s.  Don\'t panic.", tmp___34, client_version_string);
#line 433
    fatal_cleanup();
  }
#line 436
  mismatch = 0;
#line 437
  switch (remote_major) {
  case 1: 
#line 439
  if (remote_minor == 99) {
#line 440
    if (options.protocol & 4) {
#line 441
      enable_compat20();
    } else {
#line 443
      mismatch = 1;
    }
#line 444
    break;
  }
#line 446
  if (! (options.protocol & 1)) {
#line 447
    mismatch = 1;
#line 448
    break;
  }
#line 450
  if (remote_minor < 3) {
#line 451
    packet_disconnect("Your ssh version is too old and is no longer supported.  Please install a newer version.");
  } else {
#line 453
    if (remote_minor == 3) {
#line 455
      enable_compat13();
    }
  }
#line 457
  break;
  case 2: 
#line 459
  if (options.protocol & 4) {
#line 460
    enable_compat20();
#line 461
    break;
  }
  default: 
#line 465
  mismatch = 1;
#line 466
  break;
  }
#line 468
  chop(server_version_string);
#line 469
  debug("Local version string %.200s", server_version_string);
#line 471
  if (mismatch) {
#line 472
    s = (char *)"Protocol major versions differ.\n";
#line 473
    tmp___35 = strlen((char const   *)s);
#line 473
    atomicio((ssize_t (*)())(& write), sock_out, (void *)s, tmp___35);
#line 474
    close(sock_in);
#line 475
    close(sock_out);
#line 476
    tmp___36 = get_remote_ipaddr();
#line 476
    log("Protocol major versions differ for %s: %.200s vs. %.200s", tmp___36, server_version_string,
        client_version_string);
#line 479
    fatal_cleanup();
  }
#line 481
  return;
}
}
#line 484 "sshd.c"
void destroy_sensitive_data(void) 
{ int i ;

  {
#line 489
  if (sensitive_data.server_key) {
#line 490
    key_free(sensitive_data.server_key);
#line 491
    sensitive_data.server_key = (Key *)((void *)0);
  }
#line 493
  i = 0;
#line 493
  while (i < options.num_host_key_files) {
#line 494
    if (*(sensitive_data.host_keys + i)) {
#line 495
      key_free(*(sensitive_data.host_keys + i));
#line 496
      *(sensitive_data.host_keys + i) = (Key *)((void *)0);
    }
#line 493
    i ++;
  }
#line 499
  sensitive_data.ssh1_host_key = (Key *)((void *)0);
#line 500
  memset((void *)(sensitive_data.ssh1_cookie), 0, 32U);
#line 501
  return;
}
}
#line 504 "sshd.c"
void demote_sensitive_data(void) 
{ Key *tmp ;
  int i ;

  {
#line 510
  if (sensitive_data.server_key) {
#line 511
    tmp = key_demote(sensitive_data.server_key);
#line 512
    key_free(sensitive_data.server_key);
#line 513
    sensitive_data.server_key = tmp;
  }
#line 516
  i = 0;
#line 516
  while (i < options.num_host_key_files) {
#line 517
    if (*(sensitive_data.host_keys + i)) {
#line 518
      tmp = key_demote(*(sensitive_data.host_keys + i));
#line 519
      key_free(*(sensitive_data.host_keys + i));
#line 520
      *(sensitive_data.host_keys + i) = tmp;
#line 521
      if (tmp->type == 0) {
#line 522
        sensitive_data.ssh1_host_key = tmp;
      }
    }
#line 516
    i ++;
  }
#line 527
  return;
}
}
#line 529 "sshd.c"
static void privsep_preauth_child(void) 
{ u_int32_t rand___0[256] ;
  gid_t gidset[2] ;
  struct passwd *pw ;
  int i ;
  size_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;

  {
#line 538
  privsep_challenge_enable();
#line 540
  i = 0;
#line 540
  while (i < 256) {
#line 541
    rand___0[i] = arc4random();
#line 540
    i ++;
  }
#line 542
  RAND_seed((void const   *)(rand___0), (int )sizeof(rand___0));
#line 545
  demote_sensitive_data();
#line 547
  pw = getpwnam("sshd");
#line 547
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 548
    fatal("Privilege separation user %s does not exist", "sshd");
  }
#line 550
  tmp = strlen((char const   *)pw->pw_passwd);
#line 550
  memset((void *)pw->pw_passwd, 0, tmp);
#line 551
  endpwent();
#line 554
  tmp___2 = chroot("/var/empty");
#line 554
  if (tmp___2 == -1) {
#line 555
    tmp___0 = __errno_location();
#line 555
    tmp___1 = strerror(*tmp___0);
#line 555
    fatal("chroot(\"%s\"): %s", "/var/empty", tmp___1);
  }
#line 557
  tmp___5 = chdir("/");
#line 557
  if (tmp___5 == -1) {
#line 558
    tmp___3 = __errno_location();
#line 558
    tmp___4 = strerror(*tmp___3);
#line 558
    fatal("chdir(\"/\"): %s", tmp___4);
  }
#line 561
  debug3("privsep user:group %u:%u", pw->pw_uid, pw->pw_gid);
#line 567
  gidset[0] = pw->pw_gid;
#line 568
  tmp___6 = setgid(pw->pw_gid);
#line 568
  if (tmp___6 < 0) {
#line 569
    fatal("setgid failed for %u", pw->pw_gid);
  }
#line 570
  tmp___9 = setgroups(1U, (__gid_t const   *)(gidset));
#line 570
  if (tmp___9 < 0) {
#line 571
    tmp___7 = __errno_location();
#line 571
    tmp___8 = strerror(*tmp___7);
#line 571
    fatal("setgroups: %.100s", tmp___8);
  }
#line 572
  permanently_set_uid(pw);
#line 574
  return;
}
}
#line 576 "sshd.c"
static Authctxt *privsep_preauth(void) 
{ Authctxt *authctxt___0 ;
  int status ;
  pid_t pid ;
  int *tmp ;
  __pid_t tmp___0 ;
  __uid_t tmp___1 ;
  __uid_t tmp___2 ;

  {
#line 579
  authctxt___0 = (Authctxt *)((void *)0);
#line 584
  pmonitor = monitor_init();
#line 586
  pmonitor->m_pkex = & xxx_kex;
#line 588
  pid = fork();
#line 589
  if (pid == -1) {
#line 590
    fatal("fork of unprivileged child failed");
  } else {
#line 591
    if (pid != 0) {
#line 592
      debug2("Network child is on pid %ld", (long )pid);
#line 594
      close(pmonitor->m_recvfd);
#line 595
      authctxt___0 = monitor_child_preauth(pmonitor);
#line 596
      close(pmonitor->m_sendfd);
#line 599
      monitor_sync(pmonitor);
#line 602
      while (1) {
#line 602
        tmp___0 = waitpid(pid, & status, 0);
#line 602
        if (! (tmp___0 < 0)) {
#line 602
          break;
        }
#line 603
        tmp = __errno_location();
#line 603
        if (*tmp != 4) {
#line 604
          break;
        }
      }
#line 605
      return (authctxt___0);
    } else {
#line 609
      close(pmonitor->m_sendfd);
#line 612
      tmp___1 = getuid();
#line 612
      if (tmp___1 == 0U) {
#line 613
        privsep_preauth_child();
      } else {
#line 612
        tmp___2 = geteuid();
#line 612
        if (tmp___2 == 0U) {
#line 613
          privsep_preauth_child();
        }
      }
#line 614
      setproctitle("%s", "[net]");
    }
  }
#line 616
  return ((Authctxt *)((void *)0));
}
}
#line 622
Authctxt *x_authctxt ;
#line 619 "sshd.c"
static void privsep_postauth(Authctxt *authctxt___0 ) 
{ 

  {
#line 625
  x_authctxt = authctxt___0;
#line 630
  if ((authctxt___0->pw)->pw_uid == 0U) {
#line 633
    monitor_apply_keystate(pmonitor);
#line 634
    use_privsep = 0;
#line 635
    return;
  } else {
#line 630
    if (options.use_login) {
#line 633
      monitor_apply_keystate(pmonitor);
#line 634
      use_privsep = 0;
#line 635
      return;
    }
  }
#line 639
  alarm(0U);
#line 640
  if (startup_pipe != -1) {
#line 641
    close(startup_pipe);
#line 642
    startup_pipe = -1;
  }
#line 646
  monitor_reinit(pmonitor);
#line 648
  pmonitor->m_pid = fork();
#line 649
  if (pmonitor->m_pid == -1) {
#line 650
    fatal("fork of unprivileged child failed");
  } else {
#line 651
    if (pmonitor->m_pid != 0) {
#line 652
      debug2("User child is on pid %ld", (long )pmonitor->m_pid);
#line 653
      close(pmonitor->m_recvfd);
#line 654
      monitor_child_postauth(pmonitor);
#line 657
      exit(0);
    }
  }
#line 660
  close(pmonitor->m_sendfd);
#line 663
  demote_sensitive_data();
#line 666
  do_setusercontext(authctxt___0->pw);
#line 669
  monitor_apply_keystate(pmonitor);
#line 670
  return;
}
}
#line 672 "sshd.c"
static char *list_hostkey_types(void) 
{ Buffer b ;
  char *p ;
  int i ;
  Key *key ;
  u_int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 679
  buffer_init(& b);
#line 680
  i = 0;
#line 680
  while (i < options.num_host_key_files) {
#line 681
    key = *(sensitive_data.host_keys + i);
#line 682
    if ((unsigned int )key == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 684
    switch (key->type) {
    case 1: 
    case 2: 
#line 687
    tmp = buffer_len(& b);
#line 687
    if (tmp > 0U) {
#line 688
      buffer_append(& b, (void const   *)",", 1U);
    }
#line 689
    p = key_ssh_name(key);
#line 690
    tmp___0 = strlen((char const   *)p);
#line 690
    buffer_append(& b, (void const   *)p, tmp___0);
#line 691
    break;
    }
    __Cont: /* CIL Label */ 
#line 680
    i ++;
  }
#line 694
  buffer_append(& b, (void const   *)"\000", 1U);
#line 695
  tmp___1 = buffer_ptr(& b);
#line 695
  p = xstrdup((char const   *)tmp___1);
#line 696
  buffer_free(& b);
#line 697
  debug("list_hostkey_types: %s", p);
#line 698
  return (p);
}
}
#line 701 "sshd.c"
Key *get_hostkey_by_type(int type ) 
{ int i ;
  Key *key ;

  {
#line 706
  i = 0;
#line 706
  while (i < options.num_host_key_files) {
#line 707
    key = *(sensitive_data.host_keys + i);
#line 708
    if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 708
      if (key->type == type) {
#line 709
        return (key);
      }
    }
#line 706
    i ++;
  }
#line 711
  return ((Key *)((void *)0));
}
}
#line 714 "sshd.c"
Key *get_hostkey_by_index(int ind ) 
{ 

  {
#line 717
  if (ind < 0) {
#line 718
    return ((Key *)((void *)0));
  } else {
#line 717
    if (ind >= options.num_host_key_files) {
#line 718
      return ((Key *)((void *)0));
    }
  }
#line 719
  return (*(sensitive_data.host_keys + ind));
}
}
#line 722 "sshd.c"
int get_hostkey_index(Key *key ) 
{ int i ;

  {
#line 727
  i = 0;
#line 727
  while (i < options.num_host_key_files) {
#line 728
    if ((unsigned int )key == (unsigned int )*(sensitive_data.host_keys + i)) {
#line 729
      return (i);
    }
#line 727
    i ++;
  }
#line 731
  return (-1);
}
}
#line 740 "sshd.c"
static int drop_connection(int startups ) 
{ double p ;
  double r ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 745
  if (startups < options.max_startups_begin) {
#line 746
    return (0);
  }
#line 747
  if (startups >= options.max_startups) {
#line 748
    return (1);
  }
#line 749
  if (options.max_startups_rate == 100) {
#line 750
    return (1);
  }
#line 752
  p = (double )(100 - options.max_startups_rate);
#line 753
  p *= (double )(startups - options.max_startups_begin);
#line 754
  p /= (double )(options.max_startups - options.max_startups_begin);
#line 755
  p += (double )options.max_startups_rate;
#line 756
  p /= 100.0;
#line 757
  tmp = arc4random();
#line 757
  r = (double )tmp / (double )4294967295U;
#line 759
  debug("drop_connection: p %g, r %g", p, r);
#line 760
  if (r < p) {
#line 760
    tmp___0 = 1;
  } else {
#line 760
    tmp___0 = 0;
  }
#line 760
  return (tmp___0);
}
}
#line 763 "sshd.c"
static void usage(void) 
{ 

  {
#line 766
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"sshd version %s\n",
          "OpenSSH_3.4p1");
#line 767
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: %s [options]\n",
          __progname);
#line 768
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Options:\n");
#line 769
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -f file    Configuration file (default %s)\n",
          "/usr/local/etc/sshd_config");
#line 770
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -d         Debugging mode (multiple -d means more debugging)\n");
#line 771
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -i         Started from inetd\n");
#line 772
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -D         Do not fork into daemon mode\n");
#line 773
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -t         Only test configuration file and keys\n");
#line 774
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -q         Quiet (no logging)\n");
#line 775
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -p port    Listen on the specified port (default: 22)\n");
#line 776
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -k seconds Regenerate server key every this many seconds (default: 3600)\n");
#line 777
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -g seconds Grace period for authentication (default: 600)\n");
#line 778
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -b bits    Size of server RSA key (default: 768 bits)\n");
#line 779
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -h file    File from which to read host key (default: %s)\n",
          "/usr/local/etc/ssh_host_key");
#line 781
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -u len     Maximum hostname length for utmp recording\n");
#line 782
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -4         Use IPv4 only\n");
#line 783
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -6         Use IPv6 only\n");
#line 784
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -o option  Process the option as if it was read from a configuration file.\n");
#line 785
  exit(1);
}
}
#line 791 "sshd.c"
int main(int ac , char **av ) 
{ int opt ;
  int sock_in ;
  int sock_out ;
  int newsock ;
  int j ;
  int i ;
  int fdsetsz ;
  int on ;
  pid_t pid ;
  socklen_t fromlen ;
  fd_set *fdset ;
  struct sockaddr_storage from ;
  char const   *remote_ip ;
  int remote_port ;
  FILE *f ;
  struct linger linger ;
  struct addrinfo *ai ;
  char ntop[1025] ;
  char strport[32] ;
  int listen_sock ;
  int maxfd ;
  int startup_p[2] ;
  int startups ;
  Authctxt *authctxt___0 ;
  Key *key ;
  int ret ;
  int key_used ;
  u_int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  struct passwd *pw ;
  struct stat st ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int fd ;
  int *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  int s1 ;
  int tmp___20 ;
  int *tmp___21 ;
  char *tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  int *tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  int *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  __pid_t tmp___32 ;
  void *tmp___33 ;
  void *tmp___34 ;
  int *tmp___35 ;
  char *tmp___36 ;
  int *tmp___37 ;
  register char __result ;
  register char __result___0 ;
  int *tmp___38 ;
  char *tmp___39 ;
  int *tmp___40 ;
  int *tmp___41 ;
  int *tmp___42 ;
  char *tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int *tmp___47 ;
  char *tmp___48 ;
  int *tmp___49 ;
  char *tmp___50 ;
  int tmp___51 ;

  {
#line 796
  sock_in = 0;
#line 796
  sock_out = 0;
#line 796
  on = 1;
#line 809
  startups = 0;
#line 812
  key_used = 0;
#line 817
  __progname = get_progname(*(av + 0));
#line 818
  init_rng();
#line 821
  saved_argc = ac;
#line 822
  saved_argv = av;
#line 825
  initialize_server_options(& options);
#line 828
  while (1) {
#line 828
    opt = BSDgetopt(ac, (char * const  *)av, "f:p:b:k:h:g:V:u:o:dDeiqtQ46");
#line 828
    if (! (opt != -1)) {
#line 828
      break;
    }
#line 829
    switch (opt) {
    case 52: 
#line 831
    IPv4or6 = 2;
#line 832
    break;
    case 54: 
#line 834
    IPv4or6 = 10;
#line 835
    break;
    case 102: 
#line 837
    config_file_name = BSDoptarg;
#line 838
    break;
    case 100: 
#line 840
    if (0 == debug_flag) {
#line 841
      debug_flag = 1;
#line 842
      options.log_level = 5;
    } else {
#line 843
      if ((int )options.log_level < 7) {
#line 844
        options.log_level = (LogLevel )((int )options.log_level + 1);
      } else {
#line 846
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Too high debugging level.\n");
#line 847
        exit(1);
      }
    }
#line 849
    break;
    case 68: 
#line 851
    no_daemon_flag = 1;
#line 852
    break;
    case 101: 
#line 854
    log_stderr = 1;
#line 855
    break;
    case 105: 
#line 857
    inetd_flag = 1;
#line 858
    break;
    case 81: 
#line 861
    break;
    case 113: 
#line 863
    options.log_level = 0;
#line 864
    break;
    case 98: 
#line 866
    options.server_key_bits = atoi((char const   *)BSDoptarg);
#line 867
    break;
    case 112: 
#line 869
    options.ports_from_cmdline = 1U;
#line 870
    if (options.num_ports >= 256U) {
#line 871
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"too many ports.\n");
#line 872
      exit(1);
    }
#line 874
    tmp = options.num_ports;
#line 874
    (options.num_ports) ++;
#line 874
    tmp___0 = a2port((char const   *)BSDoptarg);
#line 874
    options.ports[tmp] = (unsigned short )tmp___0;
#line 875
    if ((int )options.ports[options.num_ports - 1U] == 0) {
#line 876
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad port number.\n");
#line 877
      exit(1);
    }
#line 879
    break;
    case 103: 
#line 881
    tmp___1 = convtime((char const   *)BSDoptarg);
#line 881
    options.login_grace_time = (int )tmp___1;
#line 881
    if (options.login_grace_time == -1) {
#line 882
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid login grace time.\n");
#line 883
      exit(1);
    }
#line 885
    break;
    case 107: 
#line 887
    tmp___2 = convtime((char const   *)BSDoptarg);
#line 887
    options.key_regeneration_time = (int )tmp___2;
#line 887
    if (options.key_regeneration_time == -1) {
#line 888
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid key regeneration interval.\n");
#line 889
      exit(1);
    }
#line 891
    break;
    case 104: 
#line 893
    if (options.num_host_key_files >= 256) {
#line 894
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"too many host keys.\n");
#line 895
      exit(1);
    }
#line 897
    tmp___3 = options.num_host_key_files;
#line 897
    (options.num_host_key_files) ++;
#line 897
    options.host_key_files[tmp___3] = BSDoptarg;
#line 898
    break;
    case 86: 
#line 900
    client_version_string = BSDoptarg;
#line 902
    inetd_flag = 1;
#line 903
    break;
    case 116: 
#line 905
    test_flag = 1;
#line 906
    break;
    case 117: 
#line 908
    tmp___4 = atoi((char const   *)BSDoptarg);
#line 908
    utmp_len = (unsigned int )tmp___4;
#line 909
    break;
    case 111: 
#line 911
    tmp___5 = process_server_config_line(& options, BSDoptarg, "command-line", 0);
#line 911
    if (tmp___5 != 0) {
#line 913
      exit(1);
    }
#line 914
    break;
    case 63: 
    default: 
#line 917
    usage();
#line 918
    break;
    }
  }
#line 921
  OPENSSL_add_all_algorithms_noconf();
#line 922
  channel_set_af(IPv4or6);
#line 928
  if ((int )options.log_facility == -1) {
#line 928
    tmp___6 = 2;
  } else {
#line 928
    tmp___6 = (int )options.log_facility;
  }
#line 928
  if ((int )options.log_level == -1) {
#line 928
    tmp___7 = 3;
  } else {
#line 928
    tmp___7 = (int )options.log_level;
  }
#line 928
  log_init(__progname, (enum __anonenum_LogLevel_64 )tmp___7, (enum __anonenum_SyslogFacility_63 )tmp___6,
           ! inetd_flag);
#line 942
  seed_rng();
#line 945
  read_server_config(& options, (char const   *)config_file_name);
#line 948
  fill_default_server_options(& options);
#line 951
  if (BSDoptind < ac) {
#line 952
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Extra argument %s.\n",
            *(av + BSDoptind));
#line 953
    exit(1);
  }
#line 956
  debug("sshd version %.100s", "OpenSSH_3.4p1");
#line 959
  tmp___8 = xmalloc((unsigned int )options.num_host_key_files * sizeof(Key *));
#line 959
  sensitive_data.host_keys = (Key **)tmp___8;
#line 960
  i = 0;
#line 960
  while (i < options.num_host_key_files) {
#line 961
    *(sensitive_data.host_keys + i) = (Key *)((void *)0);
#line 960
    i ++;
  }
#line 962
  sensitive_data.server_key = (Key *)((void *)0);
#line 963
  sensitive_data.ssh1_host_key = (Key *)((void *)0);
#line 964
  sensitive_data.have_ssh1_key = 0;
#line 965
  sensitive_data.have_ssh2_key = 0;
#line 967
  i = 0;
#line 967
  while (i < options.num_host_key_files) {
#line 968
    key = key_load_private((char const   *)options.host_key_files[i], "", (char **)((void *)0));
#line 969
    *(sensitive_data.host_keys + i) = key;
#line 970
    if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 971
      error("Could not load host key: %s", options.host_key_files[i]);
#line 973
      *(sensitive_data.host_keys + i) = (Key *)((void *)0);
      goto __Cont;
    }
#line 976
    switch (key->type) {
    case 0: 
#line 978
    sensitive_data.ssh1_host_key = key;
#line 979
    sensitive_data.have_ssh1_key = 1;
#line 980
    break;
    case 1: 
    case 2: 
#line 983
    sensitive_data.have_ssh2_key = 1;
#line 984
    break;
    }
#line 986
    tmp___9 = key_type(key);
#line 986
    debug("private host key: #%d type %d %s", i, key->type, tmp___9);
    __Cont: /* CIL Label */ 
#line 967
    i ++;
  }
#line 989
  if (options.protocol & 1) {
#line 989
    if (! sensitive_data.have_ssh1_key) {
#line 990
      log("Disabling protocol version 1. Could not load host key");
#line 991
      options.protocol &= -2;
    }
  }
#line 993
  if (options.protocol & 4) {
#line 993
    if (! sensitive_data.have_ssh2_key) {
#line 994
      log("Disabling protocol version 2. Could not load host key");
#line 995
      options.protocol &= -5;
    }
  }
#line 997
  if (! (options.protocol & 5)) {
#line 998
    log("sshd: no hostkeys available -- exiting.");
#line 999
    exit(1);
  }
#line 1003
  if (options.protocol & 1) {
#line 1004
    if (options.server_key_bits < 512) {
#line 1006
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 1007
      exit(1);
    } else {
#line 1004
      if (options.server_key_bits > 32768) {
#line 1006
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 1007
        exit(1);
      }
    }
#line 1014
    tmp___11 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1014
    if (options.server_key_bits > tmp___11 - 128) {
#line 1014
      tmp___12 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1014
      if (options.server_key_bits < tmp___12 + 128) {
#line 1019
        tmp___10 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1019
        options.server_key_bits = tmp___10 + 128;
#line 1022
        debug("Forcing server key to %d bits to make it differ from host key.", options.server_key_bits);
      }
    }
  }
#line 1027
  if (use_privsep) {
#line 1031
    pw = getpwnam("sshd");
#line 1031
    if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 1032
      fatal("Privilege separation user %s does not exist", "sshd");
    }
#line 1034
    tmp___13 = stat((char const   * __restrict  )"/var/empty", (struct stat * __restrict  )(& st));
#line 1034
    if (tmp___13 == -1) {
#line 1036
      fatal("Missing privilege separation directory: %s", "/var/empty");
    } else {
#line 1034
      if (((st.st_mode & 61440U) == 16384U) == 0) {
#line 1036
        fatal("Missing privilege separation directory: %s", "/var/empty");
      }
    }
#line 1038
    if (st.st_uid != 0U) {
#line 1039
      fatal("Bad owner or mode for %s", "/var/empty");
    } else {
#line 1038
      if ((st.st_mode & (unsigned int )((128 >> 3) | ((128 >> 3) >> 3))) != 0U) {
#line 1039
        fatal("Bad owner or mode for %s", "/var/empty");
      }
    }
  }
#line 1044
  if (test_flag) {
#line 1045
    exit(0);
  }
#line 1054
  tmp___16 = setgroups(0U, (__gid_t const   *)((void *)0));
#line 1054
  if (tmp___16 < 0) {
#line 1055
    tmp___14 = __errno_location();
#line 1055
    tmp___15 = strerror(*tmp___14);
#line 1055
    debug("setgroups() failed: %.200s", tmp___15);
  }
#line 1058
  if (debug_flag) {
#line 1058
    if (! inetd_flag) {
#line 1059
      log_stderr = 1;
    }
  }
#line 1060
  log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 1067
  if (! debug_flag) {
#line 1067
    if (! inetd_flag) {
#line 1067
      if (! no_daemon_flag) {
#line 1071
        tmp___19 = daemon(0, 0);
#line 1071
        if (tmp___19 < 0) {
#line 1072
          tmp___17 = __errno_location();
#line 1072
          tmp___18 = strerror(*tmp___17);
#line 1072
          fatal("daemon() failed: %.200s", tmp___18);
        }
#line 1076
        fd = open("/dev/tty", 258);
#line 1077
        if (fd >= 0) {
#line 1078
          ioctl(fd, 21538UL, (void *)0);
#line 1079
          close(fd);
        }
      }
    }
  }
#line 1084
  log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 1087
  arc4random_stir();
#line 1091
  chdir("/");
#line 1094
  signal(13, (void (*)(int  ))1);
#line 1097
  if (inetd_flag) {
#line 1099
    s1 = dup(0);
#line 1100
    dup(s1);
#line 1101
    sock_in = dup(0);
#line 1102
    sock_out = dup(1);
#line 1103
    startup_pipe = -1;
#line 1109
    debug("inetd sockets after dupping: %d, %d", sock_in, sock_out);
#line 1110
    if (options.protocol & 1) {
#line 1111
      generate_ephemeral_server_key();
    }
  } else {
#line 1113
    ai = options.listen_addrs;
#line 1113
    while (ai) {
#line 1114
      if (ai->ai_family != 2) {
#line 1114
        if (ai->ai_family != 10) {
          goto __Cont___0;
        }
      }
#line 1116
      if (num_listen_socks >= 16) {
#line 1117
        fatal("Too many listen sockets. Enlarge MAX_LISTEN_SOCKS");
      }
#line 1119
      tmp___20 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr,
                             ai->ai_addrlen, (char * __restrict  )(ntop), sizeof(ntop),
                             (char * __restrict  )(strport), sizeof(strport), 3U);
#line 1119
      if (tmp___20 != 0) {
#line 1122
        error("getnameinfo failed");
        goto __Cont___0;
      }
#line 1126
      listen_sock = socket(ai->ai_family, 1, 0);
#line 1127
      if (listen_sock < 0) {
#line 1129
        tmp___21 = __errno_location();
#line 1129
        tmp___22 = strerror(*tmp___21);
#line 1129
        verbose("socket: %.100s", tmp___22);
        goto __Cont___0;
      }
#line 1132
      tmp___25 = fcntl(listen_sock, 4, 2048);
#line 1132
      if (tmp___25 < 0) {
#line 1133
        tmp___23 = __errno_location();
#line 1133
        tmp___24 = strerror(*tmp___23);
#line 1133
        error("listen_sock O_NONBLOCK: %s", tmp___24);
#line 1134
        close(listen_sock);
        goto __Cont___0;
      }
#line 1143
      setsockopt(listen_sock, 1, 2, (void const   *)(& on), sizeof(on));
#line 1145
      linger.l_onoff = 1;
#line 1146
      linger.l_linger = 5;
#line 1147
      setsockopt(listen_sock, 1, 13, (void const   *)(& linger), sizeof(linger));
#line 1150
      debug("Bind to port %s on %s.", strport, ntop);
#line 1153
      tmp___28 = bind(listen_sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 1153
      if (tmp___28 < 0) {
#line 1154
        if (! ai->ai_next) {
#line 1155
          tmp___26 = __errno_location();
#line 1155
          tmp___27 = strerror(*tmp___26);
#line 1155
          error("Bind to port %s on %s failed: %.200s.", strport, ntop, tmp___27);
        }
#line 1157
        close(listen_sock);
        goto __Cont___0;
      }
#line 1160
      listen_socks[num_listen_socks] = listen_sock;
#line 1161
      num_listen_socks ++;
#line 1164
      log("Server listening on %s port %s.", ntop, strport);
#line 1165
      tmp___31 = listen(listen_sock, 5);
#line 1165
      if (tmp___31 < 0) {
#line 1166
        tmp___29 = __errno_location();
#line 1166
        tmp___30 = strerror(*tmp___29);
#line 1166
        fatal("listen: %.100s", tmp___30);
      }
      __Cont___0: /* CIL Label */ 
#line 1113
      ai = ai->ai_next;
    }
#line 1169
    freeaddrinfo(options.listen_addrs);
#line 1171
    if (! num_listen_socks) {
#line 1172
      fatal("Cannot bind any address.");
    }
#line 1174
    if (options.protocol & 1) {
#line 1175
      generate_ephemeral_server_key();
    }
#line 1181
    signal(1, & sighup_handler);
#line 1183
    signal(15, & sigterm_handler);
#line 1184
    signal(3, & sigterm_handler);
#line 1187
    signal(17, & main_sigchld_handler);
#line 1190
    if (! debug_flag) {
#line 1198
      f = fopen((char const   * __restrict  )options.pid_file, (char const   * __restrict  )"wb");
#line 1199
      if (f) {
#line 1200
        tmp___32 = getpid();
#line 1200
        fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%ld\n", (long )tmp___32);
#line 1201
        fclose(f);
      }
    }
#line 1206
    fdset = (fd_set *)((void *)0);
#line 1207
    maxfd = 0;
#line 1208
    i = 0;
#line 1208
    while (i < num_listen_socks) {
#line 1209
      if (listen_socks[i] > maxfd) {
#line 1210
        maxfd = listen_socks[i];
      }
#line 1208
      i ++;
    }
#line 1212
    tmp___33 = xmalloc((unsigned int )options.max_startups * sizeof(int ));
#line 1212
    startup_pipes = (int *)tmp___33;
#line 1213
    i = 0;
#line 1213
    while (i < options.max_startups) {
#line 1214
      *(startup_pipes + i) = -1;
#line 1213
      i ++;
    }
#line 1220
    while (1) {
#line 1221
      if (received_sighup) {
#line 1222
        sighup_restart();
      }
#line 1223
      if ((unsigned int )fdset != (unsigned int )((void *)0)) {
#line 1224
        xfree((void *)fdset);
      }
#line 1225
      fdsetsz = (int )((((unsigned int )(maxfd + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 1226
      tmp___34 = xmalloc((unsigned int )fdsetsz);
#line 1226
      fdset = (fd_set *)tmp___34;
#line 1227
      memset((void *)fdset, 0, (unsigned int )fdsetsz);
#line 1229
      i = 0;
#line 1229
      while (i < num_listen_socks) {
#line 1230
        __asm__  volatile   ("btsl %1,%0": "=m" (fdset->__fds_bits[(unsigned int )listen_socks[i] / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )listen_socks[i] % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
#line 1229
        i ++;
      }
#line 1231
      i = 0;
#line 1231
      while (i < options.max_startups) {
#line 1232
        if (*(startup_pipes + i) != -1) {
#line 1233
          __asm__  volatile   ("btsl %1,%0": "=m" (fdset->__fds_bits[(unsigned int )*(startup_pipes + i) / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )*(startup_pipes + i) % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        }
#line 1231
        i ++;
      }
#line 1236
      ret = select(maxfd + 1, (fd_set * __restrict  )fdset, (fd_set * __restrict  )((void *)0),
                   (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 1237
      if (ret < 0) {
#line 1237
        tmp___37 = __errno_location();
#line 1237
        if (*tmp___37 != 4) {
#line 1238
          tmp___35 = __errno_location();
#line 1238
          tmp___36 = strerror(*tmp___35);
#line 1238
          error("select: %.100s", tmp___36);
        }
      }
#line 1239
      if (received_sigterm) {
#line 1240
        log("Received signal %d; terminating.", (int )received_sigterm);
#line 1242
        close_listen_socks();
#line 1243
        unlink((char const   *)options.pid_file);
#line 1244
        exit(255);
      }
#line 1246
      if (key_used) {
#line 1246
        if (key_do_regen) {
#line 1247
          generate_ephemeral_server_key();
#line 1248
          key_used = 0;
#line 1249
          key_do_regen = (int volatile   )0;
        }
      }
#line 1251
      if (ret < 0) {
        goto __Cont___1;
      }
#line 1254
      i = 0;
#line 1254
      while (i < options.max_startups) {
#line 1256
        if (*(startup_pipes + i) != -1) {
#line 1256
          __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )*(startup_pipes + i) % (8U * sizeof(__fd_mask ))),
                               "m" (fdset->__fds_bits[(unsigned int )*(startup_pipes + i) / (8U * sizeof(__fd_mask ))]): "cc");
#line 1256
          if (__result) {
#line 1263
            close(*(startup_pipes + i));
#line 1264
            *(startup_pipes + i) = -1;
#line 1265
            startups --;
          }
        }
#line 1254
        i ++;
      }
#line 1267
      i = 0;
#line 1267
      while (i < num_listen_socks) {
#line 1268
        __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )listen_socks[i] % (8U * sizeof(__fd_mask ))),
                             "m" (fdset->__fds_bits[(unsigned int )listen_socks[i] / (8U * sizeof(__fd_mask ))]): "cc");
#line 1268
        if (! __result___0) {
          goto __Cont___2;
        }
#line 1270
        fromlen = sizeof(from);
#line 1271
        newsock = accept(listen_socks[i], (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                         (socklen_t * __restrict  )(& fromlen));
#line 1273
        if (newsock < 0) {
#line 1274
          tmp___40 = __errno_location();
#line 1274
          if (*tmp___40 != 4) {
#line 1274
            tmp___41 = __errno_location();
#line 1274
            if (*tmp___41 != 11) {
#line 1275
              tmp___38 = __errno_location();
#line 1275
              tmp___39 = strerror(*tmp___38);
#line 1275
              error("accept: %.100s", tmp___39);
            }
          }
          goto __Cont___2;
        }
#line 1278
        tmp___44 = fcntl(newsock, 4, 0);
#line 1278
        if (tmp___44 < 0) {
#line 1279
          tmp___42 = __errno_location();
#line 1279
          tmp___43 = strerror(*tmp___42);
#line 1279
          error("newsock del O_NONBLOCK: %s", tmp___43);
#line 1280
          close(newsock);
          goto __Cont___2;
        }
#line 1283
        tmp___45 = drop_connection(startups);
#line 1283
        if (tmp___45 == 1) {
#line 1284
          debug("drop connection #%d", startups);
#line 1285
          close(newsock);
          goto __Cont___2;
        }
#line 1288
        tmp___46 = pipe((int *)(startup_p));
#line 1288
        if (tmp___46 == -1) {
#line 1289
          close(newsock);
          goto __Cont___2;
        }
#line 1293
        j = 0;
#line 1293
        while (j < options.max_startups) {
#line 1294
          if (*(startup_pipes + j) == -1) {
#line 1295
            *(startup_pipes + j) = startup_p[0];
#line 1296
            if (maxfd < startup_p[0]) {
#line 1297
              maxfd = startup_p[0];
            }
#line 1298
            startups ++;
#line 1299
            break;
          }
#line 1293
          j ++;
        }
#line 1306
        if (debug_flag) {
#line 1312
          debug("Server will not fork when running in debugging mode.");
#line 1313
          close_listen_socks();
#line 1314
          sock_in = newsock;
#line 1315
          sock_out = newsock;
#line 1316
          startup_pipe = -1;
#line 1317
          pid = getpid();
#line 1318
          break;
        } else {
#line 1325
          pid = fork();
#line 1325
          if (pid == 0) {
#line 1333
            startup_pipe = startup_p[1];
#line 1334
            close_startup_pipes();
#line 1335
            close_listen_socks();
#line 1336
            sock_in = newsock;
#line 1337
            sock_out = newsock;
#line 1338
            log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 1339
            break;
          }
        }
#line 1344
        if (pid < 0) {
#line 1345
          tmp___47 = __errno_location();
#line 1345
          tmp___48 = strerror(*tmp___47);
#line 1345
          error("fork: %.100s", tmp___48);
        } else {
#line 1347
          debug("Forked child %ld.", (long )pid);
        }
#line 1349
        close(startup_p[1]);
#line 1352
        if (options.protocol & 1) {
#line 1352
          if (key_used == 0) {
#line 1355
            signal(14, & key_regeneration_alarm);
#line 1356
            alarm((unsigned int )options.key_regeneration_time);
#line 1357
            key_used = 1;
          }
        }
#line 1360
        arc4random_stir();
#line 1363
        close(newsock);
        __Cont___2: /* CIL Label */ 
#line 1267
        i ++;
      }
#line 1366
      if (num_listen_socks < 0) {
#line 1367
        break;
      }
      __Cont___1: /* CIL Label */ ;
    }
  }
#line 1389
  alarm(0U);
#line 1390
  signal(14, (void (*)(int  ))0);
#line 1391
  signal(1, (void (*)(int  ))0);
#line 1392
  signal(15, (void (*)(int  ))0);
#line 1393
  signal(3, (void (*)(int  ))0);
#line 1394
  signal(17, (void (*)(int  ))0);
#line 1395
  signal(2, (void (*)(int  ))0);
#line 1403
  linger.l_onoff = 1;
#line 1404
  linger.l_linger = 5;
#line 1405
  setsockopt(sock_in, 1, 13, (void const   *)(& linger), sizeof(linger));
#line 1408
  if (options.keepalives) {
#line 1408
    tmp___51 = setsockopt(sock_in, 1, 9, (void const   *)(& on), sizeof(on));
#line 1408
    if (tmp___51 < 0) {
#line 1411
      tmp___49 = __errno_location();
#line 1411
      tmp___50 = strerror(*tmp___49);
#line 1411
      error("setsockopt SO_KEEPALIVE: %.100s", tmp___50);
    }
  }
#line 1417
  packet_set_connection(sock_in, sock_out);
#line 1419
  remote_port = get_remote_port();
#line 1420
  remote_ip = get_remote_ipaddr();
#line 1440
  verbose("Connection from %.500s port %d", remote_ip, remote_port);
#line 1450
  signal(14, & grace_alarm_handler);
#line 1451
  if (! debug_flag) {
#line 1452
    alarm((unsigned int )options.login_grace_time);
  }
#line 1454
  sshd_exchange_identification(sock_in, sock_out);
#line 1462
  if (options.rhosts_authentication) {
#line 1462
    if (remote_port >= 1024) {
#line 1465
      debug("Rhosts Authentication disabled, originating port %d not trusted.", remote_port);
#line 1467
      options.rhosts_authentication = 0;
    } else {
#line 1462
      if (remote_port < 512) {
#line 1465
        debug("Rhosts Authentication disabled, originating port %d not trusted.",
              remote_port);
#line 1467
        options.rhosts_authentication = 0;
      }
    }
  }
#line 1484
  packet_set_nonblocking();
#line 1486
  if (use_privsep) {
#line 1487
    authctxt___0 = privsep_preauth();
#line 1487
    if ((unsigned int )authctxt___0 != (unsigned int )((void *)0)) {
      goto authenticated;
    }
  }
#line 1492
  if (compat20) {
#line 1493
    do_ssh2_kex();
#line 1494
    authctxt___0 = do_authentication2();
  } else {
#line 1496
    do_ssh1_kex();
#line 1497
    authctxt___0 = do_authentication();
  }
#line 1503
  if (use_privsep) {
#line 1504
    mm_send_keystate(pmonitor);
#line 1505
    exit(0);
  }
  authenticated: 
#line 1513
  if (use_privsep) {
#line 1514
    privsep_postauth(authctxt___0);
#line 1516
    if (! compat20) {
#line 1517
      destroy_sensitive_data();
    }
  }
#line 1521
  do_authenticated(authctxt___0);
#line 1524
  verbose("Closing connection to %.100s", remote_ip);
#line 1530
  packet_close();
#line 1532
  if (use_privsep) {
#line 1533
    mm_terminate();
  }
#line 1535
  exit(0);
}
}
#line 1542 "sshd.c"
int ssh1_session_key(BIGNUM *session_key_int ) 
{ int rsafail ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 1545
  rsafail = 0;
#line 1547
  tmp___13 = BN_cmp((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n, (BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1547
  if (tmp___13 > 0) {
#line 1549
    tmp___2 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1549
    tmp___3 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1549
    if (tmp___2 < tmp___3 + 128) {
#line 1551
      tmp = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1551
      tmp___0 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1551
      tmp___1 = get_remote_ipaddr();
#line 1551
      fatal("do_connection: %s: server_key %d < host_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___1, tmp___0, tmp, 128);
    }
#line 1557
    tmp___4 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.server_key)->rsa);
#line 1557
    if (tmp___4 <= 0) {
#line 1559
      rsafail ++;
    }
#line 1560
    tmp___5 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.ssh1_host_key)->rsa);
#line 1560
    if (tmp___5 <= 0) {
#line 1562
      rsafail ++;
    }
  } else {
#line 1565
    tmp___9 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1565
    tmp___10 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1565
    if (tmp___9 < tmp___10 + 128) {
#line 1567
      tmp___6 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1567
      tmp___7 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1567
      tmp___8 = get_remote_ipaddr();
#line 1567
      fatal("do_connection: %s: host_key %d < server_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___8, tmp___7, tmp___6, 128);
    }
#line 1573
    tmp___11 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.ssh1_host_key)->rsa);
#line 1573
    if (tmp___11 < 0) {
#line 1575
      rsafail ++;
    }
#line 1576
    tmp___12 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.server_key)->rsa);
#line 1576
    if (tmp___12 < 0) {
#line 1578
      rsafail ++;
    }
  }
#line 1580
  return (rsafail);
}
}
#line 1585 "sshd.c"
static void do_ssh1_kex(void) 
{ int i ;
  int len ;
  int rsafail ;
  BIGNUM *session_key_int ;
  u_char session_key[32] ;
  u_char cookie[8] ;
  u_int cipher_type ;
  u_int auth_mask ;
  u_int protocol_flags ;
  u_int32_t rand___0 ;
  int tmp ;
  int tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  char *tmp___6 ;
  int _len ;
  int tmp___7 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  int bytes ;
  int tmp___12 ;
  u_char *buf___1 ;
  void *tmp___13 ;
  MD5_CTX md ;

  {
#line 1589
  rsafail = 0;
#line 1594
  rand___0 = (u_int32_t )0;
#line 1605
  i = 0;
#line 1605
  while (i < 8) {
#line 1606
    if (i % 4 == 0) {
#line 1607
      rand___0 = arc4random();
    }
#line 1608
    cookie[i] = (unsigned char )(rand___0 & 255U);
#line 1609
    rand___0 >>= 8;
#line 1605
    i ++;
  }
#line 1617
  packet_start((unsigned char)2);
#line 1618
  i = 0;
#line 1618
  while (i < 8) {
#line 1619
    packet_put_char((int )cookie[i]);
#line 1618
    i ++;
  }
#line 1622
  tmp = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1622
  packet_put_int((unsigned int )tmp);
#line 1623
  packet_put_bignum(((sensitive_data.server_key)->rsa)->e);
#line 1624
  packet_put_bignum(((sensitive_data.server_key)->rsa)->n);
#line 1627
  tmp___0 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1627
  packet_put_int((unsigned int )tmp___0);
#line 1628
  packet_put_bignum(((sensitive_data.ssh1_host_key)->rsa)->e);
#line 1629
  packet_put_bignum(((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1632
  packet_put_int(2U);
#line 1635
  tmp___1 = cipher_mask_ssh1(0);
#line 1635
  packet_put_int(tmp___1);
#line 1638
  auth_mask = 0U;
#line 1639
  if (options.rhosts_authentication) {
#line 1640
    auth_mask |= (unsigned int )(1 << 1);
  }
#line 1641
  if (options.rhosts_rsa_authentication) {
#line 1642
    auth_mask |= (unsigned int )(1 << 4);
  }
#line 1643
  if (options.rsa_authentication) {
#line 1644
    auth_mask |= (unsigned int )(1 << 2);
  }
#line 1657
  if (options.challenge_response_authentication == 1) {
#line 1658
    auth_mask |= (unsigned int )(1 << 5);
  }
#line 1659
  if (options.password_authentication) {
#line 1660
    auth_mask |= (unsigned int )(1 << 3);
  }
#line 1661
  packet_put_int(auth_mask);
#line 1664
  packet_send();
#line 1665
  packet_write_wait();
#line 1667
  tmp___2 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1667
  tmp___3 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1667
  debug("Sent %d bit server key and %d bit host key.", tmp___3, tmp___2);
#line 1672
  packet_read_expect(3);
#line 1675
  cipher_type = packet_get_char();
#line 1677
  tmp___4 = cipher_mask_ssh1(0);
#line 1677
  if (! (tmp___4 & (unsigned int )(1 << cipher_type))) {
#line 1678
    packet_disconnect("Warning: client selects unsupported cipher.");
  }
#line 1682
  i = 0;
#line 1682
  while (i < 8) {
#line 1683
    tmp___5 = packet_get_char();
#line 1683
    if ((u_int )cookie[i] != tmp___5) {
#line 1684
      packet_disconnect("IP Spoofing check bytes do not match.");
    }
#line 1682
    i ++;
  }
#line 1686
  tmp___6 = cipher_name((int )cipher_type);
#line 1686
  debug("Encryption type: %.200s", tmp___6);
#line 1689
  session_key_int = BN_new();
#line 1689
  if ((unsigned int )session_key_int == (unsigned int )((void *)0)) {
#line 1690
    fatal("do_ssh1_kex: BN_new failed");
  }
#line 1691
  packet_get_bignum(session_key_int);
#line 1693
  protocol_flags = packet_get_int();
#line 1694
  packet_set_protocol_flags(protocol_flags);
#line 1695
  while (1) {
#line 1695
    tmp___7 = packet_remaining();
#line 1695
    _len = tmp___7;
#line 1695
    if (_len > 0) {
#line 1695
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "sshd.c",
          1695);
#line 1695
      packet_disconnect("Packet integrity error.");
    }
#line 1695
    break;
  }
#line 1698
  if (use_privsep) {
#line 1698
    rsafail = mm_ssh1_session_key(session_key_int);
  } else {
#line 1698
    rsafail = ssh1_session_key(session_key_int);
  }
#line 1705
  if (! rsafail) {
#line 1706
    BN_mask_bits(session_key_int, (int )(sizeof(session_key) * 8U));
#line 1707
    tmp___10 = BN_num_bits((BIGNUM const   *)session_key_int);
#line 1707
    len = (tmp___10 + 7) / 8;
#line 1708
    if (len < 0) {
#line 1709
      tmp___11 = get_remote_ipaddr();
#line 1709
      error("do_connection: bad session key len from %s: session_key_int %d > sizeof(session_key) %lu",
            tmp___11, len, (unsigned long )sizeof(session_key));
#line 1712
      rsafail ++;
    } else {
#line 1708
      if ((unsigned int )len > sizeof(session_key)) {
#line 1709
        tmp___11 = get_remote_ipaddr();
#line 1709
        error("do_connection: bad session key len from %s: session_key_int %d > sizeof(session_key) %lu",
              tmp___11, len, (unsigned long )sizeof(session_key));
#line 1712
        rsafail ++;
      } else {
#line 1714
        memset((void *)(session_key), 0, sizeof(session_key));
#line 1715
        BN_bn2bin((BIGNUM const   *)session_key_int, (session_key + sizeof(session_key)) - len);
#line 1718
        compute_session_id((u_char *)(session_id), (u_char *)(cookie), ((sensitive_data.ssh1_host_key)->rsa)->n,
                           ((sensitive_data.server_key)->rsa)->n);
#line 1725
        i = 0;
#line 1725
        while (i < 16) {
#line 1726
          session_key[i] = (unsigned char )((int )session_key[i] ^ (int )session_id[i]);
#line 1725
          i ++;
        }
      }
    }
  }
#line 1729
  if (rsafail) {
#line 1730
    tmp___12 = BN_num_bits((BIGNUM const   *)session_key_int);
#line 1730
    bytes = (tmp___12 + 7) / 8;
#line 1731
    tmp___13 = xmalloc((unsigned int )bytes);
#line 1731
    buf___1 = (u_char *)tmp___13;
#line 1734
    log("do_connection: generating a fake encryption key");
#line 1735
    BN_bn2bin((BIGNUM const   *)session_key_int, buf___1);
#line 1736
    MD5_Init(& md);
#line 1737
    MD5_Update(& md, (void const   *)buf___1, (unsigned int )bytes);
#line 1738
    MD5_Update(& md, (void const   *)(sensitive_data.ssh1_cookie), 32U);
#line 1739
    MD5_Final(session_key, & md);
#line 1740
    MD5_Init(& md);
#line 1741
    MD5_Update(& md, (void const   *)(session_key), 16U);
#line 1742
    MD5_Update(& md, (void const   *)buf___1, (unsigned int )bytes);
#line 1743
    MD5_Update(& md, (void const   *)(sensitive_data.ssh1_cookie), 32U);
#line 1744
    MD5_Final(session_key + 16, & md);
#line 1745
    memset((void *)buf___1, 0, (unsigned int )bytes);
#line 1746
    xfree((void *)buf___1);
#line 1747
    i = 0;
#line 1747
    while (i < 16) {
#line 1748
      session_id[i] = (unsigned char )((int )session_key[i] ^ (int )session_key[i + 16]);
#line 1747
      i ++;
    }
  }
#line 1751
  destroy_sensitive_data();
#line 1753
  if (use_privsep) {
#line 1754
    mm_ssh1_session_id(session_id);
  }
#line 1757
  BN_clear_free(session_key_int);
#line 1760
  packet_set_encryption_key((u_char const   *)(session_key), 32U, (int )cipher_type);
#line 1763
  memset((void *)(session_key), 0, sizeof(session_key));
#line 1765
  debug("Received session key; encryption turned on.");
#line 1768
  packet_start((unsigned char)14);
#line 1769
  packet_send();
#line 1770
  packet_write_wait();
#line 1771
  return;
}
}
#line 1776 "sshd.c"
static void do_ssh2_kex(void) 
{ Kex *kex ;

  {
#line 1781
  if ((unsigned int )options.ciphers != (unsigned int )((void *)0)) {
#line 1782
    myproposal[3] = options.ciphers;
#line 1782
    myproposal[2] = myproposal[3];
  }
#line 1785
  myproposal[2] = compat_cipher_proposal(myproposal[2]);
#line 1787
  myproposal[3] = compat_cipher_proposal(myproposal[3]);
#line 1790
  if ((unsigned int )options.macs != (unsigned int )((void *)0)) {
#line 1791
    myproposal[5] = options.macs;
#line 1791
    myproposal[4] = myproposal[5];
  }
#line 1794
  if (! options.compression) {
#line 1795
    myproposal[7] = (char *)"none";
#line 1795
    myproposal[6] = myproposal[7];
  }
#line 1798
  myproposal[1] = list_hostkey_types();
#line 1801
  kex = kex_setup((char **)(myproposal));
#line 1802
  kex->server = 1;
#line 1803
  kex->client_version_string = client_version_string;
#line 1804
  kex->server_version_string = server_version_string;
#line 1805
  kex->load_host_key = & get_hostkey_by_type;
#line 1806
  kex->host_key_index = & get_hostkey_index;
#line 1808
  xxx_kex = kex;
#line 1810
  dispatch_run(0, & kex->done, (void *)kex);
#line 1812
  session_id2 = kex->session_id;
#line 1813
  session_id2_len = kex->session_id_len;
#line 1822
  debug("KEX done");
#line 1823
  return;
}
}
#line 1 "auth.o"
#line 759 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 756 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *realpath(char const   * __restrict  __name ,
                                                    char * __restrict  __resolved ) ;
#line 187 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 218
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64") __attribute__((__nonnull__(2))) ;
#line 87 "/usr/include/shadow.h"
extern struct spwd *getspnam(char const   *__name ) ;
#line 27 "/usr/include/libgen.h"
extern  __attribute__((__nothrow__)) char *dirname(char *__path ) ;
#line 32 "groupaccess.h"
int ga_init(char const   *user , gid_t base ) ;
#line 33
int ga_match(char * const  *groups , int n___0 ) ;
#line 34
void ga_free(void) ;
#line 141 "auth.h"
Authctxt *authctxt_new(void) ;
#line 142
void auth_log(Authctxt *authctxt___0 , int authenticated , char *method , char *info ) ;
#line 144
int auth_root_allowed(char *method ) ;
#line 157
int allowed_user(struct passwd *pw ) ;
#line 158
struct passwd *getpwnamallow(char const   *user ) ;
#line 165
char *expand_filename(char const   *filename , struct passwd *pw ) ;
#line 166
char *authorized_keys_file(struct passwd *pw ) ;
#line 167
char *authorized_keys_file2(struct passwd *pw ) ;
#line 169
int secure_filename(FILE *f , char const   *file , struct passwd *pw , char *err ,
                    size_t errlen ) ;
#line 172
HostStatus check_key_in_hostfiles(struct passwd *pw , Key *key , char const   *host ,
                                  char const   *sysfile , char const   *userfile ) ;
#line 183
void ( /* format attribute */  auth_debug_add)(char const   *fmt  , ...) ;
#line 184
void auth_debug_send(void) ;
#line 185
void auth_debug_reset(void) ;
#line 30 "auth-options.h"
char *forced_command ;
#line 59 "auth.c"
Buffer auth_debug  ;
#line 60 "auth.c"
int auth_debug_init  ;
#line 71 "auth.c"
int allowed_user(struct passwd *pw ) 
{ struct stat st ;
  char const   *hostname ;
  char const   *ipaddr ;
  char *shell ;
  int i ;
  struct spwd *spw ;
  time_t today ;
  time_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 75
  hostname = (char const   *)((void *)0);
#line 75
  ipaddr = (char const   *)((void *)0);
#line 86
  if (! pw) {
#line 87
    return (0);
  } else {
#line 86
    if (! pw->pw_name) {
#line 87
      return (0);
    }
  }
#line 90
  spw = getspnam((char const   *)pw->pw_name);
#line 91
  if ((unsigned int )spw != (unsigned int )((void *)0)) {
#line 92
    tmp = time((time_t *)((void *)0));
#line 92
    today = tmp / 86400L;
#line 93
    debug3("allowed_user: today %d sp_expire %d sp_lstchg %d sp_max %d", (int )today,
           (int )spw->sp_expire, (int )spw->sp_lstchg, (int )spw->sp_max);
#line 101
    if (spw->sp_expire != -1L) {
#line 101
      if (today > spw->sp_expire) {
#line 102
        log("Account %.100s has expired", pw->pw_name);
#line 103
        return (0);
      }
    }
#line 106
    if (spw->sp_lstchg == 0L) {
#line 107
      log("User %.100s password has expired (root forced)", pw->pw_name);
#line 109
      return (0);
    }
#line 112
    if (spw->sp_max != -1L) {
#line 112
      if (today > spw->sp_lstchg + spw->sp_max) {
#line 114
        log("User %.100s password has expired (password aged)", pw->pw_name);
#line 116
        return (0);
      }
    }
  }
#line 129
  if ((int )*(pw->pw_shell + 0) == 0) {
#line 129
    shell = (char *)"/bin/sh";
  } else {
#line 129
    shell = pw->pw_shell;
  }
#line 132
  tmp___0 = stat((char const   * __restrict  )shell, (struct stat * __restrict  )(& st));
#line 132
  if (tmp___0 != 0) {
#line 133
    log("User %.100s not allowed because shell %.100s does not exist", pw->pw_name,
        shell);
#line 135
    return (0);
  }
#line 137
  if (((st.st_mode & 61440U) == 32768U) == 0) {
#line 139
    log("User %.100s not allowed because shell %.100s is not executable", pw->pw_name,
        shell);
#line 141
    return (0);
  } else {
#line 137
    if ((st.st_mode & (unsigned int )((((64 >> 3) >> 3) | 64) | (64 >> 3))) == 0U) {
#line 139
      log("User %.100s not allowed because shell %.100s is not executable", pw->pw_name,
          shell);
#line 141
      return (0);
    }
  }
#line 144
  if (options.num_deny_users > 0U) {
#line 145
    hostname = get_canonical_hostname(options.verify_reverse_mapping);
#line 146
    ipaddr = get_remote_ipaddr();
  } else {
#line 144
    if (options.num_allow_users > 0U) {
#line 145
      hostname = get_canonical_hostname(options.verify_reverse_mapping);
#line 146
      ipaddr = get_remote_ipaddr();
    }
  }
#line 150
  if (options.num_deny_users > 0U) {
#line 151
    i = 0;
#line 151
    while ((u_int )i < options.num_deny_users) {
#line 152
      tmp___1 = match_user((char const   *)pw->pw_name, hostname, ipaddr, (char const   *)options.deny_users[i]);
#line 152
      if (tmp___1) {
#line 154
        log("User %.100s not allowed because listed in DenyUsers", pw->pw_name);
#line 156
        return (0);
      }
#line 151
      i ++;
    }
  }
#line 160
  if (options.num_allow_users > 0U) {
#line 161
    i = 0;
#line 161
    while ((u_int )i < options.num_allow_users) {
#line 162
      tmp___2 = match_user((char const   *)pw->pw_name, hostname, ipaddr, (char const   *)options.allow_users[i]);
#line 162
      if (tmp___2) {
#line 164
        break;
      }
#line 161
      i ++;
    }
#line 166
    if ((u_int )i >= options.num_allow_users) {
#line 167
      log("User %.100s not allowed because not listed in AllowUsers", pw->pw_name);
#line 169
      return (0);
    }
  }
#line 172
  if (options.num_deny_groups > 0U) {
    goto _L;
  } else {
#line 172
    if (options.num_allow_groups > 0U) {
      _L: /* CIL Label */ 
#line 174
      tmp___3 = ga_init((char const   *)pw->pw_name, pw->pw_gid);
#line 174
      if (tmp___3 == 0) {
#line 175
        log("User %.100s not allowed because not in any group", pw->pw_name);
#line 177
        return (0);
      }
#line 181
      if (options.num_deny_groups > 0U) {
#line 182
        tmp___4 = ga_match((char * const  *)(options.deny_groups), (int )options.num_deny_groups);
#line 182
        if (tmp___4) {
#line 184
          ga_free();
#line 185
          log("User %.100s not allowed because a group is listed in DenyGroups", pw->pw_name);
#line 187
          return (0);
        }
      }
#line 193
      if (options.num_allow_groups > 0U) {
#line 194
        tmp___5 = ga_match((char * const  *)(options.allow_groups), (int )options.num_allow_groups);
#line 194
        if (! tmp___5) {
#line 196
          ga_free();
#line 197
          log("User %.100s not allowed because none of user\'s groups are listed in AllowGroups",
              pw->pw_name);
#line 199
          return (0);
        }
      }
#line 201
      ga_free();
    }
  }
#line 222
  return (1);
}
}
#line 225 "auth.c"
Authctxt *authctxt_new(void) 
{ Authctxt *authctxt___0 ;
  void *tmp ;

  {
#line 228
  tmp = xmalloc(sizeof(*authctxt___0));
#line 228
  authctxt___0 = (Authctxt *)tmp;
#line 229
  memset((void *)authctxt___0, 0, sizeof(*authctxt___0));
#line 230
  return (authctxt___0);
}
}
#line 233 "auth.c"
void auth_log(Authctxt *authctxt___0 , int authenticated , char *method , char *info ) 
{ void (*authlog)(char const   *fmt  , ...) ;
  char *authmsg ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;

  {
#line 236
  authlog = (void (*)(char const   *fmt  , ...))(& verbose);
#line 243
  if (authenticated == 1) {
#line 244
    authlog = (void (*)(char const   *fmt  , ...))(& log);
  } else {
#line 243
    if (! authctxt___0->valid) {
#line 244
      authlog = (void (*)(char const   *fmt  , ...))(& log);
    } else {
#line 243
      if (authctxt___0->failures >= 3) {
#line 244
        authlog = (void (*)(char const   *fmt  , ...))(& log);
      } else {
#line 243
        if (0) {
#line 243
          __s1_len = strlen((char const   *)method);
#line 243
          __s2_len = strlen("password");
#line 243
          if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
            goto _L___0;
          } else {
#line 243
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 243
              if (! ((unsigned int )((void const   *)("password" + 1)) - (unsigned int )((void const   *)"password") == 1U)) {
#line 243
                tmp___8 = 1;
              } else {
#line 243
                if (__s2_len >= 4U) {
#line 243
                  tmp___8 = 1;
                } else {
#line 243
                  tmp___8 = 0;
                }
              }
            } else {
#line 243
              tmp___8 = 0;
            }
          }
#line 243
          if (tmp___8) {
#line 243
            tmp___4 = __builtin_strcmp((char const   *)method, "password");
          } else {
#line 243
            tmp___7 = __builtin_strcmp((char const   *)method, "password");
#line 243
            tmp___4 = tmp___7;
          }
        } else {
#line 243
          tmp___7 = __builtin_strcmp((char const   *)method, "password");
#line 243
          tmp___4 = tmp___7;
        }
#line 243
        if (tmp___4 == 0) {
#line 244
          authlog = (void (*)(char const   *fmt  , ...))(& log);
        }
      }
    }
  }
#line 246
  if (authctxt___0->postponed) {
#line 247
    authmsg = (char *)"Postponed";
  } else {
#line 249
    if (authenticated) {
#line 249
      authmsg = (char *)"Accepted";
    } else {
#line 249
      authmsg = (char *)"Failed";
    }
  }
#line 251
  tmp___9 = get_remote_port();
#line 251
  tmp___10 = get_remote_ipaddr();
#line 251
  if (authctxt___0->valid) {
#line 251
    tmp___11 = "";
  } else {
#line 251
    tmp___11 = "illegal user ";
  }
#line 251
  (*authlog)("%s %s for %s%.100s from %.200s port %d%s", authmsg, method, tmp___11,
             authctxt___0->user, tmp___10, tmp___9, info);
#line 259
  return;
}
}
#line 264 "auth.c"
int auth_root_allowed(char *method ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;

  {
#line 267
  switch (options.permit_root_login) {
  case 3: 
#line 269
  return (1);
#line 270
  break;
  case 2: 
#line 272
  if (0) {
#line 272
    __s1_len = strlen((char const   *)method);
#line 272
    __s2_len = strlen("password");
#line 272
    if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
      goto _L___0;
    } else {
#line 272
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 272
        if (! ((unsigned int )((void const   *)("password" + 1)) - (unsigned int )((void const   *)"password") == 1U)) {
#line 272
          tmp___8 = 1;
        } else {
#line 272
          if (__s2_len >= 4U) {
#line 272
            tmp___8 = 1;
          } else {
#line 272
            tmp___8 = 0;
          }
        }
      } else {
#line 272
        tmp___8 = 0;
      }
    }
#line 272
    if (tmp___8) {
#line 272
      tmp___4 = __builtin_strcmp((char const   *)method, "password");
    } else {
#line 272
      tmp___7 = __builtin_strcmp((char const   *)method, "password");
#line 272
      tmp___4 = tmp___7;
    }
  } else {
#line 272
    tmp___7 = __builtin_strcmp((char const   *)method, "password");
#line 272
    tmp___4 = tmp___7;
  }
#line 272
  if (tmp___4 != 0) {
#line 273
    return (1);
  }
#line 274
  break;
  case 1: 
#line 276
  if (forced_command) {
#line 277
    log("Root login accepted for forced command.");
#line 278
    return (1);
  }
#line 280
  break;
  }
#line 282
  tmp___9 = get_remote_ipaddr();
#line 282
  log("ROOT LOGIN REFUSED FROM %.200s", tmp___9);
#line 283
  return (0);
}
}
#line 294 "auth.c"
char *expand_filename(char const   *filename , struct passwd *pw ) 
{ Buffer buffer ;
  char *file ;
  char const   *cp ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 305
  buffer_init(& buffer);
#line 306
  cp = filename;
#line 306
  while (*cp) {
#line 307
    if ((int const   )*(cp + 0) == 37) {
#line 307
      if ((int const   )*(cp + 1) == 37) {
#line 308
        buffer_append(& buffer, (void const   *)"%", 1U);
#line 309
        cp ++;
        goto __Cont;
      }
    }
#line 312
    if ((int const   )*(cp + 0) == 37) {
#line 312
      if ((int const   )*(cp + 1) == 104) {
#line 313
        tmp = strlen((char const   *)pw->pw_dir);
#line 313
        buffer_append(& buffer, (void const   *)pw->pw_dir, tmp);
#line 314
        cp ++;
        goto __Cont;
      }
    }
#line 317
    if ((int const   )*(cp + 0) == 37) {
#line 317
      if ((int const   )*(cp + 1) == 117) {
#line 318
        tmp___0 = strlen((char const   *)pw->pw_name);
#line 318
        buffer_append(& buffer, (void const   *)pw->pw_name, tmp___0);
#line 320
        cp ++;
        goto __Cont;
      }
    }
#line 323
    buffer_append(& buffer, (void const   *)cp, 1U);
    __Cont: /* CIL Label */ 
#line 306
    cp ++;
  }
#line 325
  buffer_append(& buffer, (void const   *)"\000", 1U);
#line 331
  tmp___1 = xmalloc(4096U);
#line 331
  file = (char *)tmp___1;
#line 332
  tmp___2 = buffer_ptr(& buffer);
#line 332
  cp = (char const   *)tmp___2;
#line 333
  if ((int const   )*cp != 47) {
#line 334
    snprintf((char * __restrict  )file, 4096U, (char const   * __restrict  )"%s/%s",
             pw->pw_dir, cp);
  } else {
#line 336
    strlcpy(file, cp, 4096U);
  }
#line 338
  buffer_free(& buffer);
#line 339
  return (file);
}
}
#line 342 "auth.c"
char *authorized_keys_file(struct passwd *pw ) 
{ char *tmp ;

  {
#line 345
  tmp = expand_filename((char const   *)options.authorized_keys_file, pw);
#line 345
  return (tmp);
}
}
#line 348 "auth.c"
char *authorized_keys_file2(struct passwd *pw ) 
{ char *tmp ;

  {
#line 351
  tmp = expand_filename((char const   *)options.authorized_keys_file2, pw);
#line 351
  return (tmp);
}
}
#line 355 "auth.c"
HostStatus check_key_in_hostfiles(struct passwd *pw , Key *key , char const   *host ,
                                  char const   *sysfile , char const   *userfile ) 
{ Key *found ;
  char *user_hostfile ;
  struct stat st ;
  HostStatus host_status ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 365
  found = key_new(key->type);
#line 366
  host_status = check_host_in_hostfile(sysfile, host, key, found, (int *)((void *)0));
#line 368
  if ((int )host_status != 0) {
#line 368
    if ((unsigned int )userfile != (unsigned int )((void *)0)) {
#line 369
      user_hostfile = tilde_expand_filename(userfile, pw->pw_uid);
#line 370
      if (options.strict_modes) {
#line 370
        tmp = stat((char const   * __restrict  )user_hostfile, (struct stat * __restrict  )(& st));
#line 370
        if (tmp == 0) {
#line 370
          if (st.st_uid != 0U) {
#line 370
            if (st.st_uid != pw->pw_uid) {
#line 374
              log("Authentication refused for %.100s: bad owner or modes for %.200s",
                  pw->pw_name, user_hostfile);
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 370
            if ((st.st_mode & 18U) != 0U) {
#line 374
              log("Authentication refused for %.100s: bad owner or modes for %.200s",
                  pw->pw_name, user_hostfile);
            } else {
#line 378
              temporarily_use_uid(pw);
#line 379
              host_status = check_host_in_hostfile((char const   *)user_hostfile,
                                                   host, key, found, (int *)((void *)0));
#line 381
              restore_uid();
            }
          }
        } else {
#line 378
          temporarily_use_uid(pw);
#line 379
          host_status = check_host_in_hostfile((char const   *)user_hostfile, host,
                                               key, found, (int *)((void *)0));
#line 381
          restore_uid();
        }
      } else {
#line 378
        temporarily_use_uid(pw);
#line 379
        host_status = check_host_in_hostfile((char const   *)user_hostfile, host,
                                             key, found, (int *)((void *)0));
#line 381
        restore_uid();
      }
#line 383
      xfree((void *)user_hostfile);
    }
  }
#line 385
  key_free(found);
#line 387
  if ((int )host_status == 0) {
#line 387
    tmp___0 = "ok";
  } else {
#line 387
    tmp___0 = "not found";
  }
#line 387
  debug2("check_key_in_hostfiles: key %s for %s", tmp___0, host);
#line 389
  return (host_status);
}
}
#line 405 "auth.c"
int secure_filename(FILE *f , char const   *file , struct passwd *pw , char *err ,
                    size_t errlen ) 
{ uid_t uid ;
  char buf___1[4096] ;
  char homedir[4096] ;
  char *cp ;
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___13 ;
  int tmp___16 ;
  int tmp___17 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___23 ;
  int tmp___26 ;
  int tmp___27 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___33 ;
  int tmp___36 ;
  int tmp___37 ;

  {
#line 409
  uid = pw->pw_uid;
#line 414
  tmp___1 = realpath((char const   * __restrict  )file, (char * __restrict  )(buf___1));
#line 414
  if ((unsigned int )tmp___1 == (unsigned int )((void *)0)) {
#line 415
    tmp = __errno_location();
#line 415
    tmp___0 = strerror(*tmp);
#line 415
    snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"realpath %s failed: %s",
             file, tmp___0);
#line 417
    return (-1);
  }
#line 419
  tmp___4 = realpath((char const   * __restrict  )pw->pw_dir, (char * __restrict  )(homedir));
#line 419
  if ((unsigned int )tmp___4 == (unsigned int )((void *)0)) {
#line 420
    tmp___2 = __errno_location();
#line 420
    tmp___3 = strerror(*tmp___2);
#line 420
    snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"realpath %s failed: %s",
             pw->pw_dir, tmp___3);
#line 422
    return (-1);
  }
#line 426
  tmp___5 = fileno(f);
#line 426
  tmp___6 = fstat(tmp___5, & st);
#line 426
  if (tmp___6 < 0) {
#line 429
    snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for file %s",
             buf___1);
#line 431
    return (-1);
  } else {
#line 426
    if (st.st_uid != 0U) {
#line 426
      if (st.st_uid != uid) {
#line 429
        snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for file %s",
                 buf___1);
#line 431
        return (-1);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 426
      if ((st.st_mode & 18U) != 0U) {
#line 429
        snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for file %s",
                 buf___1);
#line 431
        return (-1);
      }
    }
  }
#line 435
  while (1) {
#line 436
    cp = dirname(buf___1);
#line 436
    if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 437
      snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"dirname() failed");
#line 438
      return (-1);
    }
#line 440
    strlcpy(buf___1, (char const   *)cp, sizeof(buf___1));
#line 442
    debug3("secure_filename: checking \'%s\'", buf___1);
#line 443
    tmp___7 = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )(& st));
#line 443
    if (tmp___7 < 0) {
#line 446
      snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for directory %s",
               buf___1);
#line 448
      return (-1);
    } else {
#line 443
      if (st.st_uid != 0U) {
#line 443
        if (st.st_uid != uid) {
#line 446
          snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for directory %s",
                   buf___1);
#line 448
          return (-1);
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 443
        if ((st.st_mode & 18U) != 0U) {
#line 446
          snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for directory %s",
                   buf___1);
#line 448
          return (-1);
        }
      }
    }
#line 452
    if (0) {
#line 452
      __s1_len = strlen((char const   *)(homedir));
#line 452
      __s2_len = strlen((char const   *)(buf___1));
#line 452
      if (! ((unsigned int )((void const   *)(homedir + 1)) - (unsigned int )((void const   *)(homedir)) == 1U)) {
        goto _L___2;
      } else {
#line 452
        if (__s1_len >= 4U) {
          _L___2: /* CIL Label */ 
#line 452
          if (! ((unsigned int )((void const   *)(buf___1 + 1)) - (unsigned int )((void const   *)(buf___1)) == 1U)) {
#line 452
            tmp___17 = 1;
          } else {
#line 452
            if (__s2_len >= 4U) {
#line 452
              tmp___17 = 1;
            } else {
#line 452
              tmp___17 = 0;
            }
          }
        } else {
#line 452
          tmp___17 = 0;
        }
      }
#line 452
      if (tmp___17) {
#line 452
        tmp___13 = __builtin_strcmp((char const   *)(homedir), (char const   *)(buf___1));
      } else {
#line 452
        tmp___16 = __builtin_strcmp((char const   *)(homedir), (char const   *)(buf___1));
#line 452
        tmp___13 = tmp___16;
      }
    } else {
#line 452
      tmp___16 = __builtin_strcmp((char const   *)(homedir), (char const   *)(buf___1));
#line 452
      tmp___13 = tmp___16;
    }
#line 452
    if (tmp___13 == 0) {
#line 453
      debug3("secure_filename: terminating check at \'%s\'", buf___1);
#line 455
      break;
    }
#line 461
    if (0) {
#line 461
      __s1_len___0 = strlen("/");
#line 461
      __s2_len___0 = strlen((char const   *)(buf___1));
#line 461
      if (! ((unsigned int )((void const   *)("/" + 1)) - (unsigned int )((void const   *)"/") == 1U)) {
        goto _L___4;
      } else {
#line 461
        if (__s1_len___0 >= 4U) {
          _L___4: /* CIL Label */ 
#line 461
          if (! ((unsigned int )((void const   *)(buf___1 + 1)) - (unsigned int )((void const   *)(buf___1)) == 1U)) {
#line 461
            tmp___27 = 1;
          } else {
#line 461
            if (__s2_len___0 >= 4U) {
#line 461
              tmp___27 = 1;
            } else {
#line 461
              tmp___27 = 0;
            }
          }
        } else {
#line 461
          tmp___27 = 0;
        }
      }
#line 461
      if (tmp___27) {
#line 461
        tmp___23 = __builtin_strcmp("/", (char const   *)(buf___1));
      } else {
#line 461
        tmp___26 = __builtin_strcmp("/", (char const   *)(buf___1));
#line 461
        tmp___23 = tmp___26;
      }
    } else {
#line 461
      tmp___26 = __builtin_strcmp("/", (char const   *)(buf___1));
#line 461
      tmp___23 = tmp___26;
    }
#line 461
    if (tmp___23 == 0) {
#line 462
      break;
    } else {
#line 461
      if (0) {
#line 461
        __s1_len___1 = strlen(".");
#line 461
        __s2_len___1 = strlen((char const   *)(buf___1));
#line 461
        if (! ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") == 1U)) {
          goto _L___6;
        } else {
#line 461
          if (__s1_len___1 >= 4U) {
            _L___6: /* CIL Label */ 
#line 461
            if (! ((unsigned int )((void const   *)(buf___1 + 1)) - (unsigned int )((void const   *)(buf___1)) == 1U)) {
#line 461
              tmp___37 = 1;
            } else {
#line 461
              if (__s2_len___1 >= 4U) {
#line 461
                tmp___37 = 1;
              } else {
#line 461
                tmp___37 = 0;
              }
            }
          } else {
#line 461
            tmp___37 = 0;
          }
        }
#line 461
        if (tmp___37) {
#line 461
          tmp___33 = __builtin_strcmp(".", (char const   *)(buf___1));
        } else {
#line 461
          tmp___36 = __builtin_strcmp(".", (char const   *)(buf___1));
#line 461
          tmp___33 = tmp___36;
        }
      } else {
#line 461
        tmp___36 = __builtin_strcmp(".", (char const   *)(buf___1));
#line 461
        tmp___33 = tmp___36;
      }
#line 461
      if (tmp___33 == 0) {
#line 462
        break;
      }
    }
  }
#line 464
  return (0);
}
}
#line 467 "auth.c"
struct passwd *getpwnamallow(char const   *user ) 
{ struct passwd *pw ;
  int tmp ;
  struct passwd *tmp___0 ;

  {
#line 478
  pw = getpwnam(user);
#line 479
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 480
    return ((struct passwd *)((void *)0));
  } else {
#line 479
    tmp = allowed_user(pw);
#line 479
    if (! tmp) {
#line 480
      return ((struct passwd *)((void *)0));
    }
  }
#line 496
  if ((unsigned int )pw != (unsigned int )((void *)0)) {
#line 497
    tmp___0 = pwcopy(pw);
#line 497
    return (tmp___0);
  }
#line 498
  return ((struct passwd *)((void *)0));
}
}
#line 501 "auth.c"
void ( /* format attribute */  auth_debug_add)(char const   *fmt  , ...) 
{ char buf___1[1024] ;
  va_list args ;

  {
#line 507
  if (! auth_debug_init) {
#line 508
    return;
  }
#line 510
  __builtin_va_start(args, fmt);
#line 511
  vsnprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )fmt,
            args);
#line 512
  __builtin_va_end(args);
#line 513
  buffer_put_cstring(& auth_debug, (char const   *)(buf___1));
#line 514
  return;
}
}
#line 516 "auth.c"
void auth_debug_send(void) 
{ char *msg ;
  void *tmp ;
  u_int tmp___0 ;

  {
#line 521
  if (! auth_debug_init) {
#line 522
    return;
  }
#line 523
  while (1) {
#line 523
    tmp___0 = buffer_len(& auth_debug);
#line 523
    if (! tmp___0) {
#line 523
      break;
    }
#line 524
    tmp = buffer_get_string(& auth_debug, (u_int *)((void *)0));
#line 524
    msg = (char *)tmp;
#line 525
    packet_send_debug("%s", msg);
#line 526
    xfree((void *)msg);
  }
#line 528
  return;
}
}
#line 530 "auth.c"
void auth_debug_reset(void) 
{ 

  {
#line 533
  if (auth_debug_init) {
#line 534
    buffer_clear(& auth_debug);
  } else {
#line 536
    buffer_init(& auth_debug);
#line 537
    auth_debug_init = 1;
  }
#line 539
  return;
}
}
#line 1 "auth1.o"
#line 98 "auth.h"
int auth_rhosts(struct passwd *pw , char const   *client_user ) ;
#line 102
int auth_rhosts_rsa(struct passwd *pw , char *cuser , Key *client_host_key ) ;
#line 103
int auth_password(Authctxt *authctxt___0 , char const   *password ) ;
#line 104
int auth_rsa(struct passwd *pw , BIGNUM *client_n ) ;
#line 160
char *get_challenge(Authctxt *authctxt___0 ) ;
#line 161
int verify_response(Authctxt *authctxt___0 , char const   *response ) ;
#line 39 "auth1.c"
static char buf[1024]  ;
#line 36 "auth1.c"
static char *get_authname(int type ) 
{ 

  {
#line 40
  switch (type) {
  case 9: 
#line 42
  return ((char *)"password");
  case 6: 
#line 44
  return ((char *)"rsa");
  case 35: 
#line 46
  return ((char *)"rhosts-rsa");
  case 5: 
#line 48
  return ((char *)"rhosts");
  case 39: 
  case 41: 
#line 51
  return ((char *)"challenge-response");
  }
#line 57
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"bad-auth-msg-%d",
           type);
#line 58
  return (buf);
}
}
#line 65 "auth1.c"
static void do_authloop(Authctxt *authctxt___0 ) 
{ int authenticated ;
  u_int bits ;
  Key *client_host_key ;
  BIGNUM *n___0 ;
  char *client_user ;
  char *password ;
  char info[1024] ;
  u_int dlen ;
  u_int ulen ;
  int type ;
  struct passwd *pw ;
  char const   *tmp ;
  int tmp___2 ;
  void *tmp___3 ;
  int _len ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int _len___0 ;
  int tmp___8 ;
  int _len___1 ;
  int tmp___9 ;
  void *tmp___10 ;
  int _len___2 ;
  int tmp___11 ;
  size_t tmp___14 ;
  char *challenge ;
  char *tmp___15 ;
  char *response ;
  void *tmp___16 ;
  int _len___3 ;
  int tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;

  {
#line 68
  authenticated = 0;
#line 76
  type = 0;
#line 77
  pw = authctxt___0->pw;
#line 79
  if (authctxt___0->valid) {
#line 79
    tmp = "";
  } else {
#line 79
    tmp = "illegal user ";
  }
#line 79
  debug("Attempting authentication for %s%.100s.", tmp, authctxt___0->user);
#line 83
  if (options.password_authentication) {
#line 83
    if (use_privsep) {
#line 83
      tmp___2 = mm_auth_password(authctxt___0, (char *)"");
    } else {
#line 83
      tmp___2 = auth_password(authctxt___0, "");
    }
#line 83
    if (tmp___2) {
#line 88
      auth_log(authctxt___0, 1, (char *)"without authentication", (char *)"");
#line 89
      return;
    }
  }
#line 93
  packet_start((unsigned char)15);
#line 94
  packet_send();
#line 95
  packet_write_wait();
#line 97
  client_user = (char *)((void *)0);
#line 99
  while (1) {
#line 101
    authenticated = 0;
#line 103
    info[0] = (char )'\000';
#line 106
    type = packet_read();
#line 109
    switch (type) {
    case 5: 
#line 166
    if (! options.rhosts_authentication) {
#line 167
      verbose("Rhosts authentication disabled.");
#line 168
      break;
    }
#line 176
    tmp___3 = packet_get_string(& ulen);
#line 176
    client_user = (char *)tmp___3;
#line 177
    while (1) {
#line 177
      tmp___4 = packet_remaining();
#line 177
      _len = tmp___4;
#line 177
      if (_len > 0) {
#line 177
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth1.c",
            177);
#line 177
        packet_disconnect("Packet integrity error.");
      }
#line 177
      break;
    }
#line 180
    authenticated = auth_rhosts(pw, (char const   *)client_user);
#line 182
    snprintf((char * __restrict  )(info), sizeof(info), (char const   * __restrict  )" ruser %.100s",
             client_user);
#line 183
    break;
    case 35: 
#line 186
    if (! options.rhosts_rsa_authentication) {
#line 187
      verbose("Rhosts with RSA authentication disabled.");
#line 188
      break;
    }
#line 195
    tmp___5 = packet_get_string(& ulen);
#line 195
    client_user = (char *)tmp___5;
#line 198
    client_host_key = key_new(0);
#line 199
    bits = packet_get_int();
#line 200
    packet_get_bignum((client_host_key->rsa)->e);
#line 201
    packet_get_bignum((client_host_key->rsa)->n);
#line 203
    tmp___7 = BN_num_bits((BIGNUM const   *)(client_host_key->rsa)->n);
#line 203
    if (bits != (u_int )tmp___7) {
#line 204
      tmp___6 = BN_num_bits((BIGNUM const   *)(client_host_key->rsa)->n);
#line 204
      verbose("Warning: keysize mismatch for client_host_key: actual %d, announced %d",
              tmp___6, bits);
    }
#line 207
    while (1) {
#line 207
      tmp___8 = packet_remaining();
#line 207
      _len___0 = tmp___8;
#line 207
      if (_len___0 > 0) {
#line 207
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "auth1.c",
            207);
#line 207
        packet_disconnect("Packet integrity error.");
      }
#line 207
      break;
    }
#line 209
    authenticated = auth_rhosts_rsa(pw, client_user, client_host_key);
#line 211
    key_free(client_host_key);
#line 213
    snprintf((char * __restrict  )(info), sizeof(info), (char const   * __restrict  )" ruser %.100s",
             client_user);
#line 214
    break;
    case 6: 
#line 217
    if (! options.rsa_authentication) {
#line 218
      verbose("RSA authentication disabled.");
#line 219
      break;
    }
#line 222
    n___0 = BN_new();
#line 222
    if ((unsigned int )n___0 == (unsigned int )((void *)0)) {
#line 223
      fatal("do_authloop: BN_new failed");
    }
#line 224
    packet_get_bignum(n___0);
#line 225
    while (1) {
#line 225
      tmp___9 = packet_remaining();
#line 225
      _len___1 = tmp___9;
#line 225
      if (_len___1 > 0) {
#line 225
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len___1, "auth1.c",
            225);
#line 225
        packet_disconnect("Packet integrity error.");
      }
#line 225
      break;
    }
#line 226
    authenticated = auth_rsa(pw, n___0);
#line 227
    BN_clear_free(n___0);
#line 228
    break;
    case 9: 
#line 231
    if (! options.password_authentication) {
#line 232
      verbose("Password authentication disabled.");
#line 233
      break;
    }
#line 240
    tmp___10 = packet_get_string(& dlen);
#line 240
    password = (char *)tmp___10;
#line 241
    while (1) {
#line 241
      tmp___11 = packet_remaining();
#line 241
      _len___2 = tmp___11;
#line 241
      if (_len___2 > 0) {
#line 241
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len___2, "auth1.c",
            241);
#line 241
        packet_disconnect("Packet integrity error.");
      }
#line 241
      break;
    }
#line 244
    if (use_privsep) {
#line 244
      authenticated = mm_auth_password(authctxt___0, password);
    } else {
#line 244
      authenticated = auth_password(authctxt___0, (char const   *)password);
    }
#line 246
    tmp___14 = strlen((char const   *)password);
#line 246
    memset((void *)password, 0, tmp___14);
#line 247
    xfree((void *)password);
#line 248
    break;
    case 39: 
#line 251
    debug("rcvd SSH_CMSG_AUTH_TIS");
#line 252
    if (options.challenge_response_authentication == 1) {
#line 253
      tmp___15 = get_challenge(authctxt___0);
#line 253
      challenge = tmp___15;
#line 254
      if ((unsigned int )challenge != (unsigned int )((void *)0)) {
#line 255
        debug("sending challenge \'%s\'", challenge);
#line 256
        packet_start((unsigned char)40);
#line 257
        packet_put_cstring((char const   *)challenge);
#line 258
        xfree((void *)challenge);
#line 259
        packet_send();
#line 260
        packet_write_wait();
        goto __Cont;
      }
    }
#line 264
    break;
    case 41: 
#line 266
    debug("rcvd SSH_CMSG_AUTH_TIS_RESPONSE");
#line 267
    if (options.challenge_response_authentication == 1) {
#line 268
      tmp___16 = packet_get_string(& dlen);
#line 268
      response = (char *)tmp___16;
#line 269
      debug("got response \'%s\'", response);
#line 270
      while (1) {
#line 270
        tmp___17 = packet_remaining();
#line 270
        _len___3 = tmp___17;
#line 270
        if (_len___3 > 0) {
#line 270
          log("Packet integrity error (%d bytes remaining) at %s:%d", _len___3, "auth1.c",
              270);
#line 270
          packet_disconnect("Packet integrity error.");
        }
#line 270
        break;
      }
#line 271
      authenticated = verify_response(authctxt___0, (char const   *)response);
#line 272
      memset((void *)response, 'r', dlen);
#line 273
      xfree((void *)response);
    }
#line 275
    break;
    default: 
#line 282
    log("Unknown message during authentication: type %d", type);
#line 283
    break;
    }
#line 291
    if (! authctxt___0->valid) {
#line 291
      if (authenticated) {
#line 292
        fatal("INTERNAL ERROR: authenticated invalid user %s", authctxt___0->user);
      }
    }
#line 304
    if (authenticated) {
#line 304
      if ((authctxt___0->pw)->pw_uid == 0U) {
#line 304
        tmp___18 = get_authname(type);
#line 304
        tmp___19 = auth_root_allowed(tmp___18);
#line 304
        if (! tmp___19) {
#line 306
          authenticated = 0;
        }
      }
    }
#line 315
    tmp___20 = get_authname(type);
#line 315
    auth_log(authctxt___0, authenticated, tmp___20, info);
#line 317
    if ((unsigned int )client_user != (unsigned int )((void *)0)) {
#line 318
      xfree((void *)client_user);
#line 319
      client_user = (char *)((void *)0);
    }
#line 322
    if (authenticated) {
#line 323
      return;
    }
#line 325
    tmp___21 = authctxt___0->failures;
#line 325
    (authctxt___0->failures) ++;
#line 325
    if (tmp___21 > 6) {
#line 332
      packet_disconnect("Too many authentication failures for %.100s", authctxt___0->user);
    }
#line 335
    packet_start((unsigned char)15);
#line 336
    packet_send();
#line 337
    packet_write_wait();
    __Cont: /* CIL Label */ ;
  }
}
}
#line 345 "auth1.c"
Authctxt *do_authentication(void) 
{ Authctxt *authctxt___0 ;
  u_int ulen ;
  char *user ;
  char *style ;
  void *tmp ;
  int _len ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___3 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  __uid_t tmp___8 ;
  __uid_t tmp___9 ;

  {
#line 350
  style = (char *)((void *)0);
#line 353
  packet_read_expect(4);
#line 356
  tmp = packet_get_string(& ulen);
#line 356
  user = (char *)tmp;
#line 357
  while (1) {
#line 357
    tmp___0 = packet_remaining();
#line 357
    _len = tmp___0;
#line 357
    if (_len > 0) {
#line 357
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth1.c",
          357);
#line 357
      packet_disconnect("Packet integrity error.");
    }
#line 357
    break;
  }
#line 359
  tmp___3 = __builtin_strchr(user, ':');
#line 359
  style = tmp___3;
#line 359
  if ((unsigned int )style != (unsigned int )((void *)0)) {
#line 360
    tmp___1 = style;
#line 360
    style ++;
#line 360
    *tmp___1 = (char )'\000';
  }
#line 372
  authctxt___0 = authctxt_new();
#line 373
  authctxt___0->user = user;
#line 374
  authctxt___0->style = style;
#line 377
  if (use_privsep) {
#line 377
    authctxt___0->pw = mm_getpwnamallow((char const   *)user);
  } else {
#line 377
    authctxt___0->pw = getpwnamallow((char const   *)user);
  }
#line 377
  if ((unsigned int )authctxt___0->pw != (unsigned int )((void *)0)) {
#line 378
    authctxt___0->valid = 1;
  } else {
#line 380
    debug("do_authentication: illegal user %s", user);
  }
#line 382
  if (use_privsep) {
#line 382
    tmp___6 = " [net]";
  } else {
#line 382
    tmp___6 = "";
  }
#line 382
  if (authctxt___0->pw) {
#line 382
    tmp___7 = (char const   *)user;
  } else {
#line 382
    tmp___7 = "unknown";
  }
#line 382
  setproctitle("%s%s", tmp___7, tmp___6);
#line 394
  if (! use_privsep) {
#line 394
    tmp___8 = getuid();
#line 394
    if (tmp___8 != 0U) {
#line 394
      if (authctxt___0->pw) {
#line 394
        tmp___9 = getuid();
#line 394
        if ((authctxt___0->pw)->pw_uid != tmp___9) {
#line 396
          packet_disconnect("Cannot change user when server not running as root.");
        }
      }
    }
  }
#line 403
  do_authloop(authctxt___0);
#line 406
  packet_start((unsigned char)14);
#line 407
  packet_send();
#line 408
  packet_write_wait();
#line 410
  return (authctxt___0);
}
}
#line 1 "auth2.o"
#line 143 "auth.h"
void userauth_finish(Authctxt *authctxt___0 , int authenticated , char *method ) ;
#line 151
void auth2_challenge_stop(Authctxt *authctxt___0 ) ;
#line 163
struct passwd *auth_get_user(void) ;
#line 44 "auth2.c"
Authctxt *x_authctxt  =    (Authctxt *)((void *)0);
#line 48
Authmethod method_none ;
#line 49
Authmethod method_pubkey ;
#line 50
Authmethod method_passwd ;
#line 51
Authmethod method_kbdint ;
#line 52
Authmethod method_hostbased ;
#line 54 "auth2.c"
Authmethod *authmethods[6]  = {      & method_none,      & method_pubkey,      & method_passwd,      & method_kbdint, 
        & method_hostbased,      (Authmethod *)((void *)0)};
#line 65
static void input_service_request(int type , u_int32_t seq , void *ctxt ) ;
#line 66
static void input_userauth_request(int type , u_int32_t seq , void *ctxt ) ;
#line 69
static Authmethod *authmethod_lookup(char const   *name ) ;
#line 70
static char *authmethods_get(void) ;
#line 78 "auth2.c"
Authctxt *do_authentication2(void) 
{ Authctxt *authctxt___0 ;
  Authctxt *tmp ;

  {
#line 81
  tmp = authctxt_new();
#line 81
  authctxt___0 = tmp;
#line 83
  x_authctxt = authctxt___0;
#line 86
  if (options.challenge_response_authentication) {
#line 87
    options.kbd_interactive_authentication = 1;
  }
#line 88
  if (options.pam_authentication_via_kbd_int) {
#line 89
    options.kbd_interactive_authentication = 1;
  }
#line 90
  if (use_privsep) {
#line 91
    options.pam_authentication_via_kbd_int = 0;
  }
#line 93
  dispatch_init(& dispatch_protocol_error);
#line 94
  dispatch_set(5, & input_service_request);
#line 95
  dispatch_run(0, & authctxt___0->success, (void *)authctxt___0);
#line 97
  return (authctxt___0);
}
}
#line 100 "auth2.c"
static void input_service_request(int type , u_int32_t seq , void *ctxt ) 
{ Authctxt *authctxt___0 ;
  u_int len ;
  int accept___0 ;
  char *service ;
  void *tmp ;
  int _len ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 103
  authctxt___0 = (Authctxt *)ctxt;
#line 105
  accept___0 = 0;
#line 106
  tmp = packet_get_string(& len);
#line 106
  service = (char *)tmp;
#line 107
  while (1) {
#line 107
    tmp___0 = packet_remaining();
#line 107
    _len = tmp___0;
#line 107
    if (_len > 0) {
#line 107
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
          107);
#line 107
      packet_disconnect("Packet integrity error.");
    }
#line 107
    break;
  }
#line 109
  if ((unsigned int )authctxt___0 == (unsigned int )((void *)0)) {
#line 110
    fatal("input_service_request: no authctxt");
  }
#line 112
  if (0) {
#line 112
    __s1_len = strlen((char const   *)service);
#line 112
    __s2_len = strlen("ssh-userauth");
#line 112
    if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
      goto _L___0;
    } else {
#line 112
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 112
        if (! ((unsigned int )((void const   *)("ssh-userauth" + 1)) - (unsigned int )((void const   *)"ssh-userauth") == 1U)) {
#line 112
          tmp___10 = 1;
        } else {
#line 112
          if (__s2_len >= 4U) {
#line 112
            tmp___10 = 1;
          } else {
#line 112
            tmp___10 = 0;
          }
        }
      } else {
#line 112
        tmp___10 = 0;
      }
    }
#line 112
    if (tmp___10) {
#line 112
      tmp___6 = __builtin_strcmp((char const   *)service, "ssh-userauth");
    } else {
#line 112
      tmp___9 = __builtin_strcmp((char const   *)service, "ssh-userauth");
#line 112
      tmp___6 = tmp___9;
    }
  } else {
#line 112
    tmp___9 = __builtin_strcmp((char const   *)service, "ssh-userauth");
#line 112
    tmp___6 = tmp___9;
  }
#line 112
  if (tmp___6 == 0) {
#line 113
    if (! authctxt___0->success) {
#line 114
      accept___0 = 1;
#line 116
      dispatch_set(50, & input_userauth_request);
    }
  }
#line 121
  if (accept___0) {
#line 122
    packet_start((unsigned char)6);
#line 123
    packet_put_cstring((char const   *)service);
#line 124
    packet_send();
#line 125
    packet_write_wait();
  } else {
#line 127
    debug("bad service request %s", service);
#line 128
    packet_disconnect("bad service request %s", service);
  }
#line 130
  xfree((void *)service);
#line 131
  return;
}
}
#line 133 "auth2.c"
static void input_userauth_request(int type , u_int32_t seq , void *ctxt ) 
{ Authctxt *authctxt___0 ;
  Authmethod *m___0 ;
  char *user ;
  char *service ;
  char *method ;
  char *style ;
  int authenticated ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___4 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___12 ;
  int tmp___15 ;
  int tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___25 ;
  int tmp___28 ;
  int tmp___29 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___35 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;

  {
#line 136
  authctxt___0 = (Authctxt *)ctxt;
#line 137
  m___0 = (Authmethod *)((void *)0);
#line 138
  style = (char *)((void *)0);
#line 139
  authenticated = 0;
#line 141
  if ((unsigned int )authctxt___0 == (unsigned int )((void *)0)) {
#line 142
    fatal("input_userauth_request: no authctxt");
  }
#line 144
  tmp = packet_get_string((u_int *)((void *)0));
#line 144
  user = (char *)tmp;
#line 145
  tmp___0 = packet_get_string((u_int *)((void *)0));
#line 145
  service = (char *)tmp___0;
#line 146
  tmp___1 = packet_get_string((u_int *)((void *)0));
#line 146
  method = (char *)tmp___1;
#line 147
  debug("userauth-request for user %s service %s method %s", user, service, method);
#line 148
  debug("attempt %d failures %d", authctxt___0->attempt, authctxt___0->failures);
#line 150
  tmp___4 = __builtin_strchr(user, ':');
#line 150
  style = tmp___4;
#line 150
  if ((unsigned int )style != (unsigned int )((void *)0)) {
#line 151
    tmp___2 = style;
#line 151
    style ++;
#line 151
    *tmp___2 = (char)0;
  }
#line 153
  tmp___40 = authctxt___0->attempt;
#line 153
  (authctxt___0->attempt) ++;
#line 153
  if (tmp___40 == 0) {
#line 155
    if (use_privsep) {
#line 155
      authctxt___0->pw = mm_getpwnamallow((char const   *)user);
    } else {
#line 155
      authctxt___0->pw = getpwnamallow((char const   *)user);
    }
#line 156
    if (authctxt___0->pw) {
#line 156
      if (0) {
#line 156
        __s1_len = strlen((char const   *)service);
#line 156
        __s2_len = strlen("ssh-connection");
#line 156
        if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
          goto _L___0;
        } else {
#line 156
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 156
            if (! ((unsigned int )((void const   *)("ssh-connection" + 1)) - (unsigned int )((void const   *)"ssh-connection") == 1U)) {
#line 156
              tmp___16 = 1;
            } else {
#line 156
              if (__s2_len >= 4U) {
#line 156
                tmp___16 = 1;
              } else {
#line 156
                tmp___16 = 0;
              }
            }
          } else {
#line 156
            tmp___16 = 0;
          }
        }
#line 156
        if (tmp___16) {
#line 156
          tmp___12 = __builtin_strcmp((char const   *)service, "ssh-connection");
        } else {
#line 156
          tmp___15 = __builtin_strcmp((char const   *)service, "ssh-connection");
#line 156
          tmp___12 = tmp___15;
        }
      } else {
#line 156
        tmp___15 = __builtin_strcmp((char const   *)service, "ssh-connection");
#line 156
        tmp___12 = tmp___15;
      }
#line 156
      if (tmp___12 == 0) {
#line 157
        authctxt___0->valid = 1;
#line 158
        debug2("input_userauth_request: setting up authctxt for %s", user);
      } else {
#line 163
        log("input_userauth_request: illegal user %s", user);
      }
    } else {
#line 163
      log("input_userauth_request: illegal user %s", user);
    }
#line 168
    if (use_privsep) {
#line 168
      tmp___17 = " [net]";
    } else {
#line 168
      tmp___17 = "";
    }
#line 168
    if (authctxt___0->pw) {
#line 168
      tmp___18 = (char const   *)user;
    } else {
#line 168
      tmp___18 = "unknown";
    }
#line 168
    setproctitle("%s%s", tmp___18, tmp___17);
#line 170
    authctxt___0->user = xstrdup((char const   *)user);
#line 171
    authctxt___0->service = xstrdup((char const   *)service);
#line 172
    if (style) {
#line 172
      authctxt___0->style = xstrdup((char const   *)style);
    } else {
#line 172
      authctxt___0->style = (char *)((void *)0);
    }
#line 173
    if (use_privsep) {
#line 174
      mm_inform_authserv(service, style);
    }
  } else {
#line 175
    if (0) {
#line 175
      __s1_len___0 = strlen((char const   *)user);
#line 175
      __s2_len___0 = strlen((char const   *)authctxt___0->user);
#line 175
      if (! ((unsigned int )((void const   *)(user + 1)) - (unsigned int )((void const   *)user) == 1U)) {
        goto _L___2;
      } else {
#line 175
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 175
          if (! ((unsigned int )((void const   *)(authctxt___0->user + 1)) - (unsigned int )((void const   *)authctxt___0->user) == 1U)) {
#line 175
            tmp___29 = 1;
          } else {
#line 175
            if (__s2_len___0 >= 4U) {
#line 175
              tmp___29 = 1;
            } else {
#line 175
              tmp___29 = 0;
            }
          }
        } else {
#line 175
          tmp___29 = 0;
        }
      }
#line 175
      if (tmp___29) {
#line 175
        tmp___25 = __builtin_strcmp((char const   *)user, (char const   *)authctxt___0->user);
      } else {
#line 175
        tmp___28 = __builtin_strcmp((char const   *)user, (char const   *)authctxt___0->user);
#line 175
        tmp___25 = tmp___28;
      }
    } else {
#line 175
      tmp___28 = __builtin_strcmp((char const   *)user, (char const   *)authctxt___0->user);
#line 175
      tmp___25 = tmp___28;
    }
#line 176
    if (tmp___25 != 0) {
#line 177
      packet_disconnect("Change of username or service not allowed: (%s,%s) -> (%s,%s)",
                        authctxt___0->user, authctxt___0->service, user, service);
    } else {
#line 176
      if (0) {
#line 176
        __s1_len___1 = strlen((char const   *)service);
#line 176
        __s2_len___1 = strlen((char const   *)authctxt___0->service);
#line 176
        if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
          goto _L___4;
        } else {
#line 176
          if (__s1_len___1 >= 4U) {
            _L___4: /* CIL Label */ 
#line 176
            if (! ((unsigned int )((void const   *)(authctxt___0->service + 1)) - (unsigned int )((void const   *)authctxt___0->service) == 1U)) {
#line 176
              tmp___39 = 1;
            } else {
#line 176
              if (__s2_len___1 >= 4U) {
#line 176
                tmp___39 = 1;
              } else {
#line 176
                tmp___39 = 0;
              }
            }
          } else {
#line 176
            tmp___39 = 0;
          }
        }
#line 176
        if (tmp___39) {
#line 176
          tmp___35 = __builtin_strcmp((char const   *)service, (char const   *)authctxt___0->service);
        } else {
#line 176
          tmp___38 = __builtin_strcmp((char const   *)service, (char const   *)authctxt___0->service);
#line 176
          tmp___35 = tmp___38;
        }
      } else {
#line 176
        tmp___38 = __builtin_strcmp((char const   *)service, (char const   *)authctxt___0->service);
#line 176
        tmp___35 = tmp___38;
      }
#line 176
      if (tmp___35 != 0) {
#line 177
        packet_disconnect("Change of username or service not allowed: (%s,%s) -> (%s,%s)",
                          authctxt___0->user, authctxt___0->service, user, service);
      }
    }
  }
#line 182
  auth2_challenge_stop(authctxt___0);
#line 183
  authctxt___0->postponed = 0;
#line 186
  m___0 = authmethod_lookup((char const   *)method);
#line 187
  if ((unsigned int )m___0 != (unsigned int )((void *)0)) {
#line 188
    debug2("input_userauth_request: try method %s", method);
#line 189
    authenticated = (*(m___0->userauth))(authctxt___0);
  }
#line 191
  userauth_finish(authctxt___0, authenticated, method);
#line 193
  xfree((void *)service);
#line 194
  xfree((void *)user);
#line 195
  xfree((void *)method);
#line 196
  return;
}
}
#line 198 "auth2.c"
void userauth_finish(Authctxt *authctxt___0 , int authenticated , char *method ) 
{ char *methods ;
  int tmp ;
  int tmp___0 ;

  {
#line 203
  if (! authctxt___0->valid) {
#line 203
    if (authenticated) {
#line 204
      fatal("INTERNAL ERROR: authenticated invalid user %s", authctxt___0->user);
    }
  }
#line 208
  if (authenticated) {
#line 208
    if ((authctxt___0->pw)->pw_uid == 0U) {
#line 208
      tmp = auth_root_allowed(method);
#line 208
      if (! tmp) {
#line 210
        authenticated = 0;
      }
    }
  }
#line 219
  auth_log(authctxt___0, authenticated, method, (char *)" ssh2");
#line 221
  if (authctxt___0->postponed) {
#line 222
    return;
  }
#line 225
  if (authenticated == 1) {
#line 227
    dispatch_set(50, & dispatch_protocol_ignore);
#line 228
    packet_start((unsigned char)52);
#line 229
    packet_send();
#line 230
    packet_write_wait();
#line 232
    authctxt___0->success = 1;
  } else {
#line 234
    tmp___0 = authctxt___0->failures;
#line 234
    (authctxt___0->failures) ++;
#line 234
    if (tmp___0 > 6) {
#line 241
      packet_disconnect("Too many authentication failures for %.100s", authctxt___0->user);
    }
#line 243
    methods = authmethods_get();
#line 244
    packet_start((unsigned char)51);
#line 245
    packet_put_cstring((char const   *)methods);
#line 246
    packet_put_char(0);
#line 247
    packet_send();
#line 248
    packet_write_wait();
#line 249
    xfree((void *)methods);
  }
#line 251
  return;
}
}
#line 255 "auth2.c"
struct passwd *auth_get_user(void) 
{ struct passwd *tmp ;

  {
#line 258
  if ((unsigned int )x_authctxt != (unsigned int )((void *)0)) {
#line 258
    if (x_authctxt->valid) {
#line 258
      tmp = x_authctxt->pw;
    } else {
#line 258
      tmp = (struct passwd *)((void *)0);
    }
  } else {
#line 258
    tmp = (struct passwd *)((void *)0);
  }
#line 258
  return (tmp);
}
}
#line 263 "auth2.c"
static char *authmethods_get(void) 
{ Buffer b ;
  char *list ;
  int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  u_int tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;

  {
#line 270
  buffer_init(& b);
#line 271
  i = 0;
#line 271
  while ((unsigned int )authmethods[i] != (unsigned int )((void *)0)) {
#line 272
    if (0) {
#line 272
      __s1_len = strlen((char const   *)(authmethods[i])->name);
#line 272
      __s2_len = strlen("none");
#line 272
      if (! ((unsigned int )((void const   *)((authmethods[i])->name + 1)) - (unsigned int )((void const   *)(authmethods[i])->name) == 1U)) {
        goto _L___0;
      } else {
#line 272
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 272
          if (! ((unsigned int )((void const   *)("none" + 1)) - (unsigned int )((void const   *)"none") == 1U)) {
#line 272
            tmp___8 = 1;
          } else {
#line 272
            if (__s2_len >= 4U) {
#line 272
              tmp___8 = 1;
            } else {
#line 272
              tmp___8 = 0;
            }
          }
        } else {
#line 272
          tmp___8 = 0;
        }
      }
#line 272
      if (tmp___8) {
#line 272
        tmp___4 = __builtin_strcmp((char const   *)(authmethods[i])->name, "none");
      } else {
#line 272
        tmp___7 = __builtin_strcmp((char const   *)(authmethods[i])->name, "none");
#line 272
        tmp___4 = tmp___7;
      }
    } else {
#line 272
      tmp___7 = __builtin_strcmp((char const   *)(authmethods[i])->name, "none");
#line 272
      tmp___4 = tmp___7;
    }
#line 272
    if (tmp___4 == 0) {
      goto __Cont;
    }
#line 274
    if ((unsigned int )(authmethods[i])->enabled != (unsigned int )((void *)0)) {
#line 274
      if (*((authmethods[i])->enabled) != 0) {
#line 276
        tmp___9 = buffer_len(& b);
#line 276
        if (tmp___9 > 0U) {
#line 277
          buffer_append(& b, (void const   *)",", 1U);
        }
#line 278
        tmp___10 = strlen((char const   *)(authmethods[i])->name);
#line 278
        buffer_append(& b, (void const   *)(authmethods[i])->name, tmp___10);
      }
    }
    __Cont: /* CIL Label */ 
#line 271
    i ++;
  }
#line 282
  buffer_append(& b, (void const   *)"\000", 1U);
#line 283
  tmp___11 = buffer_ptr(& b);
#line 283
  list = xstrdup((char const   *)tmp___11);
#line 284
  buffer_free(& b);
#line 285
  return (list);
}
}
#line 288 "auth2.c"
static Authmethod *authmethod_lookup(char const   *name ) 
{ int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;

  {
#line 293
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 294
    i = 0;
#line 294
    while ((unsigned int )authmethods[i] != (unsigned int )((void *)0)) {
#line 297
      if ((unsigned int )(authmethods[i])->enabled != (unsigned int )((void *)0)) {
#line 297
        if (*((authmethods[i])->enabled) != 0) {
#line 297
          if (0) {
#line 297
            __s1_len = strlen(name);
#line 297
            __s2_len = strlen((char const   *)(authmethods[i])->name);
#line 297
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
              goto _L___0;
            } else {
#line 297
              if (__s1_len >= 4U) {
                _L___0: /* CIL Label */ 
#line 297
                if (! ((unsigned int )((void const   *)((authmethods[i])->name + 1)) - (unsigned int )((void const   *)(authmethods[i])->name) == 1U)) {
#line 297
                  tmp___8 = 1;
                } else {
#line 297
                  if (__s2_len >= 4U) {
#line 297
                    tmp___8 = 1;
                  } else {
#line 297
                    tmp___8 = 0;
                  }
                }
              } else {
#line 297
                tmp___8 = 0;
              }
            }
#line 297
            if (tmp___8) {
#line 297
              tmp___4 = __builtin_strcmp(name, (char const   *)(authmethods[i])->name);
            } else {
#line 297
              tmp___7 = __builtin_strcmp(name, (char const   *)(authmethods[i])->name);
#line 297
              tmp___4 = tmp___7;
            }
          } else {
#line 297
            tmp___7 = __builtin_strcmp(name, (char const   *)(authmethods[i])->name);
#line 297
            tmp___4 = tmp___7;
          }
#line 297
          if (tmp___4 == 0) {
#line 298
            return (authmethods[i]);
          }
        }
      }
#line 294
      i ++;
    }
  }
#line 299
  if (name) {
#line 299
    tmp___9 = name;
  } else {
#line 299
    tmp___9 = "NULL";
  }
#line 299
  debug2("Unrecognized authentication method name: %s", tmp___9);
#line 301
  return ((Authmethod *)((void *)0));
}
}
#line 1 "auth2-hostbased.o"
#line 99 "auth.h"
int auth_rhosts2(struct passwd *pw , char const   *client_user , char const   *hostname ,
                 char const   *ipaddr ) ;
#line 111
int hostbased_key_allowed(struct passwd *pw , char const   *cuser , char *chost ,
                          Key *key ) ;
#line 47 "auth2-hostbased.c"
static int userauth_hostbased(Authctxt *authctxt___0 ) 
{ Buffer b ;
  Key *key ;
  char *pkalg ;
  char *cuser ;
  char *chost ;
  char *service ;
  u_char *pkblob ;
  u_char *sig ;
  u_int alen ;
  u_int blen ;
  u_int slen ;
  int pktype ;
  int authenticated ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___6 ;
  int tmp___13 ;
  u_int tmp___14 ;
  void *tmp___15 ;
  u_int tmp___16 ;
  void *tmp___17 ;

  {
#line 51
  key = (Key *)((void *)0);
#line 56
  authenticated = 0;
#line 58
  if (! authctxt___0->valid) {
#line 59
    debug2("userauth_hostbased: disabled because of invalid user");
#line 60
    return (0);
  }
#line 62
  tmp = packet_get_string(& alen);
#line 62
  pkalg = (char *)tmp;
#line 63
  tmp___0 = packet_get_string(& blen);
#line 63
  pkblob = (u_char *)tmp___0;
#line 64
  tmp___1 = packet_get_string((u_int *)((void *)0));
#line 64
  chost = (char *)tmp___1;
#line 65
  tmp___2 = packet_get_string((u_int *)((void *)0));
#line 65
  cuser = (char *)tmp___2;
#line 66
  tmp___3 = packet_get_string(& slen);
#line 66
  sig = (u_char *)tmp___3;
#line 68
  debug("userauth_hostbased: cuser %s chost %s pkalg %s slen %d", cuser, chost, pkalg,
        slen);
#line 77
  pktype = key_type_from_name(pkalg);
#line 78
  if (pktype == 3) {
#line 80
    log("userauth_hostbased: unsupported public key algorithm: %s", pkalg);
    goto done;
  }
#line 84
  key = key_from_blob(pkblob, (int )blen);
#line 85
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 86
    error("userauth_hostbased: cannot decode key: %s", pkalg);
    goto done;
  }
#line 89
  if (key->type != pktype) {
#line 90
    error("userauth_hostbased: type mismatch for decoded key (received %d, expected %d)",
          key->type, pktype);
    goto done;
  }
#line 94
  if (datafellows & 65536) {
#line 94
    service = (char *)"ssh-userauth";
  } else {
#line 94
    service = authctxt___0->service;
  }
#line 96
  buffer_init(& b);
#line 97
  buffer_put_string(& b, (void const   *)session_id2, (unsigned int )session_id2_len);
#line 99
  buffer_put_char(& b, 50);
#line 100
  buffer_put_cstring(& b, (char const   *)authctxt___0->user);
#line 101
  buffer_put_cstring(& b, (char const   *)service);
#line 102
  buffer_put_cstring(& b, "hostbased");
#line 103
  buffer_put_string(& b, (void const   *)pkalg, alen);
#line 104
  buffer_put_string(& b, (void const   *)pkblob, blen);
#line 105
  buffer_put_cstring(& b, (char const   *)chost);
#line 106
  buffer_put_cstring(& b, (char const   *)cuser);
#line 111
  authenticated = 0;
#line 112
  if (use_privsep) {
#line 112
    tmp___6 = mm_hostbased_key_allowed(authctxt___0->pw, cuser, chost, key);
  } else {
#line 112
    tmp___6 = hostbased_key_allowed(authctxt___0->pw, (char const   *)cuser, chost,
                                    key);
  }
#line 112
  if (tmp___6) {
#line 112
    if (use_privsep) {
#line 112
      tmp___14 = buffer_len(& b);
#line 112
      tmp___15 = buffer_ptr(& b);
#line 112
      tmp___13 = mm_key_verify(key, sig, slen, (u_char *)tmp___15, tmp___14);
    } else {
#line 112
      tmp___16 = buffer_len(& b);
#line 112
      tmp___17 = buffer_ptr(& b);
#line 112
      tmp___13 = key_verify(key, sig, slen, (u_char *)tmp___17, tmp___16);
    }
#line 112
    if (tmp___13 == 1) {
#line 115
      authenticated = 1;
    }
  }
#line 117
  buffer_clear(& b);
  done: 
#line 119
  debug2("userauth_hostbased: authenticated %d", authenticated);
#line 120
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 121
    key_free(key);
  }
#line 122
  xfree((void *)pkalg);
#line 123
  xfree((void *)pkblob);
#line 124
  xfree((void *)cuser);
#line 125
  xfree((void *)chost);
#line 126
  xfree((void *)sig);
#line 127
  return (authenticated);
}
}
#line 131 "auth2-hostbased.c"
int hostbased_key_allowed(struct passwd *pw , char const   *cuser , char *chost ,
                          Key *key ) 
{ char const   *resolvedname ;
  char const   *ipaddr ;
  char const   *lookup ;
  HostStatus host_status ;
  int len ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
#line 139
  resolvedname = get_canonical_hostname(options.verify_reverse_mapping);
#line 140
  ipaddr = get_remote_ipaddr();
#line 142
  debug2("userauth_hostbased: chost %s resolvedname %s ipaddr %s", chost, resolvedname,
         ipaddr);
#line 145
  if (options.hostbased_uses_name_from_packet_only) {
#line 146
    tmp = auth_rhosts2(pw, cuser, (char const   *)chost, (char const   *)chost);
#line 146
    if (tmp == 0) {
#line 147
      return (0);
    }
#line 148
    lookup = (char const   *)chost;
  } else {
#line 150
    tmp___0 = strlen((char const   *)chost);
#line 150
    len = (int )tmp___0;
#line 150
    if (len > 0) {
#line 150
      if ((int )*(chost + (len - 1)) == 46) {
#line 151
        debug2("stripping trailing dot from chost %s", chost);
#line 152
        *(chost + (len - 1)) = (char )'\000';
      }
    }
#line 154
    tmp___1 = strcasecmp(resolvedname, (char const   *)chost);
#line 154
    if (tmp___1 != 0) {
#line 155
      log("userauth_hostbased mismatch: client sends %s, but we resolve %s to %s",
          chost, ipaddr, resolvedname);
    }
#line 158
    tmp___2 = auth_rhosts2(pw, cuser, resolvedname, ipaddr);
#line 158
    if (tmp___2 == 0) {
#line 159
      return (0);
    }
#line 160
    lookup = resolvedname;
  }
#line 162
  debug2("userauth_hostbased: access allowed by auth_rhosts2");
#line 164
  if (options.ignore_user_known_hosts) {
#line 164
    tmp___3 = (char const   *)((void *)0);
  } else {
#line 164
    tmp___3 = "~/.ssh/known_hosts";
  }
#line 164
  host_status = check_key_in_hostfiles(pw, key, lookup, "/usr/local/etc/ssh_known_hosts",
                                       tmp___3);
#line 169
  if ((int )host_status == 1) {
#line 170
    if (options.ignore_user_known_hosts) {
#line 170
      tmp___4 = (char const   *)((void *)0);
    } else {
#line 170
      tmp___4 = "~/.ssh/known_hosts2";
    }
#line 170
    host_status = check_key_in_hostfiles(pw, key, lookup, "/usr/local/etc/ssh_known_hosts2",
                                         tmp___4);
  }
#line 175
  return ((int )host_status == 0);
}
}
#line 178 "auth2-hostbased.c"
Authmethod method_hostbased  =    {(char *)"hostbased", & userauth_hostbased, & options.hostbased_authentication};
#line 1 "auth2-kbdint.o"
#line 150 "auth.h"
int auth2_challenge(Authctxt *authctxt___0 , char *devs ) ;
#line 37 "auth2-kbdint.c"
static int userauth_kbdint(Authctxt *authctxt___0 ) 
{ int authenticated ;
  char *lang ;
  char *devs ;
  void *tmp ;
  void *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 40
  authenticated = 0;
#line 43
  tmp = packet_get_string((u_int *)((void *)0));
#line 43
  lang = (char *)tmp;
#line 44
  tmp___0 = packet_get_string((u_int *)((void *)0));
#line 44
  devs = (char *)tmp___0;
#line 45
  while (1) {
#line 45
    tmp___1 = packet_remaining();
#line 45
    _len = tmp___1;
#line 45
    if (_len > 0) {
#line 45
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2-kbdint.c",
          45);
#line 45
      packet_disconnect("Packet integrity error.");
    }
#line 45
    break;
  }
#line 47
  debug("keyboard-interactive devs %s", devs);
#line 49
  if (options.challenge_response_authentication) {
#line 50
    authenticated = auth2_challenge(authctxt___0, devs);
  }
#line 56
  xfree((void *)devs);
#line 57
  xfree((void *)lang);
#line 62
  return (authenticated);
}
}
#line 65 "auth2-kbdint.c"
Authmethod method_kbdint  =    {(char *)"keyboard-interactive", & userauth_kbdint, & options.kbd_interactive_authentication};
#line 1 "auth2-none.o"
#line 218 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64") __attribute__((__nonnull__(2))) ;
#line 146 "auth.h"
char *auth2_read_banner(void) ;
#line 42 "auth2-none.c"
static int none_enabled  =    1;
#line 44 "auth2-none.c"
char *auth2_read_banner(void) 
{ struct stat st ;
  char *banner ;
  off_t len ;
  off_t n___0 ;
  int fd ;
  int tmp ;
  void *tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 48
  banner = (char *)((void *)0);
#line 52
  fd = open((char const   *)options.banner, 0);
#line 52
  if (fd == -1) {
#line 53
    return ((char *)((void *)0));
  }
#line 54
  tmp = fstat(fd, & st);
#line 54
  if (tmp == -1) {
#line 55
    close(fd);
#line 56
    return ((char *)((void *)0));
  }
#line 58
  len = st.st_size;
#line 59
  tmp___0 = xmalloc((unsigned int )(len + 1LL));
#line 59
  banner = (char *)tmp___0;
#line 60
  tmp___1 = atomicio((ssize_t (*)())(& read), fd, (void *)banner, (unsigned int )len);
#line 60
  n___0 = (long long )tmp___1;
#line 61
  close(fd);
#line 63
  if (n___0 != len) {
#line 64
    free((void *)banner);
#line 65
    return ((char *)((void *)0));
  }
#line 67
  *(banner + n___0) = (char )'\000';
#line 69
  return (banner);
}
}
#line 72 "auth2-none.c"
static void userauth_banner(void) 
{ char *banner ;

  {
#line 75
  banner = (char *)((void *)0);
#line 77
  if ((unsigned int )options.banner == (unsigned int )((void *)0)) {
#line 78
    return;
  } else {
#line 77
    if (datafellows & 128) {
#line 78
      return;
    }
  }
#line 80
  if (use_privsep) {
#line 80
    banner = mm_auth2_read_banner();
  } else {
#line 80
    banner = auth2_read_banner();
  }
#line 80
  if ((unsigned int )banner == (unsigned int )((void *)0)) {
    goto done;
  }
#line 83
  packet_start((unsigned char)53);
#line 84
  packet_put_cstring((char const   *)banner);
#line 85
  packet_put_cstring("");
#line 86
  packet_send();
#line 87
  debug("userauth_banner: sent");
  done: 
#line 89
  if (banner) {
#line 90
    xfree((void *)banner);
  }
#line 91
  return;
}
}
#line 93 "auth2-none.c"
static int userauth_none(Authctxt *authctxt___0 ) 
{ int _len ;
  int tmp ;
  int tmp___3 ;

  {
#line 96
  none_enabled = 0;
#line 97
  while (1) {
#line 97
    tmp = packet_remaining();
#line 97
    _len = tmp;
#line 97
    if (_len > 0) {
#line 97
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2-none.c",
          97);
#line 97
      packet_disconnect("Packet integrity error.");
    }
#line 97
    break;
  }
#line 98
  userauth_banner();
#line 103
  if (authctxt___0->valid) {
#line 103
    if (use_privsep) {
#line 103
      tmp___3 = mm_auth_password(authctxt___0, (char *)"");
    } else {
#line 103
      tmp___3 = auth_password(authctxt___0, "");
    }
  } else {
#line 103
    tmp___3 = 0;
  }
#line 103
  return (tmp___3);
}
}
#line 106 "auth2-none.c"
Authmethod method_none  =    {(char *)"none", & userauth_none, & none_enabled};
#line 1 "auth2-passwd.o"
#line 38 "auth2-passwd.c"
static int userauth_passwd(Authctxt *authctxt___0 ) 
{ char *password ;
  int authenticated ;
  int change ;
  u_int len ;
  u_int tmp ;
  void *tmp___0 ;
  int _len ;
  int tmp___1 ;
  int tmp___4 ;

  {
#line 42
  authenticated = 0;
#line 45
  tmp = packet_get_char();
#line 45
  change = (int )tmp;
#line 46
  if (change) {
#line 47
    log("password change not supported");
  }
#line 48
  tmp___0 = packet_get_string(& len);
#line 48
  password = (char *)tmp___0;
#line 49
  while (1) {
#line 49
    tmp___1 = packet_remaining();
#line 49
    _len = tmp___1;
#line 49
    if (_len > 0) {
#line 49
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2-passwd.c",
          49);
#line 49
      packet_disconnect("Packet integrity error.");
    }
#line 49
    break;
  }
#line 50
  if (authctxt___0->valid) {
#line 50
    if (use_privsep) {
#line 50
      tmp___4 = mm_auth_password(authctxt___0, password);
    } else {
#line 50
      tmp___4 = auth_password(authctxt___0, (char const   *)password);
    }
#line 50
    if (tmp___4 == 1) {
#line 55
      authenticated = 1;
    }
  }
#line 56
  memset((void *)password, 0, len);
#line 57
  xfree((void *)password);
#line 58
  return (authenticated);
}
}
#line 61 "auth2-passwd.c"
Authmethod method_passwd  =    {(char *)"password", & userauth_passwd, & options.password_authentication};
#line 1 "auth2-pubkey.o"
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 112 "auth.h"
int user_key_allowed(struct passwd *pw , Key *key ) ;
#line 33 "auth-options.h"
int auth_parse_options(struct passwd *pw , char *opts , char *file , u_long linenum ) ;
#line 34
void auth_clear_options(void) ;
#line 49 "auth2-pubkey.c"
static int userauth_pubkey(Authctxt *authctxt___0 ) 
{ Buffer b ;
  Key *key ;
  char *pkalg ;
  u_char *pkblob ;
  u_char *sig ;
  u_int alen ;
  u_int blen ;
  u_int slen ;
  int have_sig ;
  int pktype ;
  int authenticated ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int _len ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int tmp___9 ;
  int tmp___16 ;
  u_int tmp___17 ;
  void *tmp___18 ;
  u_int tmp___19 ;
  void *tmp___20 ;
  int _len___0 ;
  int tmp___21 ;
  int tmp___24 ;

  {
#line 53
  key = (Key *)((void *)0);
#line 58
  authenticated = 0;
#line 60
  if (! authctxt___0->valid) {
#line 61
    debug2("userauth_pubkey: disabled because of invalid user");
#line 62
    return (0);
  }
#line 64
  tmp = packet_get_char();
#line 64
  have_sig = (int )tmp;
#line 65
  if (datafellows & 32) {
#line 66
    debug2("userauth_pubkey: SSH_BUG_PKAUTH");
#line 68
    tmp___0 = packet_get_string(& blen);
#line 68
    pkblob = (u_char *)tmp___0;
#line 69
    buffer_init(& b);
#line 70
    buffer_append(& b, (void const   *)pkblob, blen);
#line 72
    tmp___1 = buffer_get_string(& b, & alen);
#line 72
    pkalg = (char *)tmp___1;
#line 73
    buffer_free(& b);
  } else {
#line 75
    tmp___2 = packet_get_string(& alen);
#line 75
    pkalg = (char *)tmp___2;
#line 76
    tmp___3 = packet_get_string(& blen);
#line 76
    pkblob = (u_char *)tmp___3;
  }
#line 78
  pktype = key_type_from_name(pkalg);
#line 79
  if (pktype == 3) {
#line 81
    log("userauth_pubkey: unsupported public key algorithm: %s", pkalg);
    goto done;
  }
#line 85
  key = key_from_blob(pkblob, (int )blen);
#line 86
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 87
    error("userauth_pubkey: cannot decode key: %s", pkalg);
    goto done;
  }
#line 90
  if (key->type != pktype) {
#line 91
    error("userauth_pubkey: type mismatch for decoded key (received %d, expected %d)",
          key->type, pktype);
    goto done;
  }
#line 95
  if (have_sig) {
#line 96
    tmp___4 = packet_get_string(& slen);
#line 96
    sig = (u_char *)tmp___4;
#line 97
    while (1) {
#line 97
      tmp___5 = packet_remaining();
#line 97
      _len = tmp___5;
#line 97
      if (_len > 0) {
#line 97
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2-pubkey.c",
            97);
#line 97
        packet_disconnect("Packet integrity error.");
      }
#line 97
      break;
    }
#line 98
    buffer_init(& b);
#line 99
    if (datafellows & 16) {
#line 100
      buffer_append(& b, (void const   *)session_id2, (unsigned int )session_id2_len);
    } else {
#line 102
      buffer_put_string(& b, (void const   *)session_id2, (unsigned int )session_id2_len);
    }
#line 105
    buffer_put_char(& b, 50);
#line 106
    buffer_put_cstring(& b, (char const   *)authctxt___0->user);
#line 107
    if (datafellows & 2) {
#line 107
      tmp___6 = "ssh-userauth";
    } else {
#line 107
      tmp___6 = (char const   *)authctxt___0->service;
    }
#line 107
    buffer_put_cstring(& b, tmp___6);
#line 111
    if (datafellows & 32) {
#line 112
      buffer_put_char(& b, have_sig);
    } else {
#line 114
      buffer_put_cstring(& b, "publickey");
#line 115
      buffer_put_char(& b, have_sig);
#line 116
      buffer_put_cstring(& b, (char const   *)pkalg);
    }
#line 118
    buffer_put_string(& b, (void const   *)pkblob, blen);
#line 123
    authenticated = 0;
#line 124
    if (use_privsep) {
#line 124
      tmp___9 = mm_user_key_allowed(authctxt___0->pw, key);
    } else {
#line 124
      tmp___9 = user_key_allowed(authctxt___0->pw, key);
    }
#line 124
    if (tmp___9) {
#line 124
      if (use_privsep) {
#line 124
        tmp___17 = buffer_len(& b);
#line 124
        tmp___18 = buffer_ptr(& b);
#line 124
        tmp___16 = mm_key_verify(key, sig, slen, (u_char *)tmp___18, tmp___17);
      } else {
#line 124
        tmp___19 = buffer_len(& b);
#line 124
        tmp___20 = buffer_ptr(& b);
#line 124
        tmp___16 = key_verify(key, sig, slen, (u_char *)tmp___20, tmp___19);
      }
#line 124
      if (tmp___16 == 1) {
#line 127
        authenticated = 1;
      }
    }
#line 128
    buffer_clear(& b);
#line 129
    xfree((void *)sig);
  } else {
#line 131
    debug("test whether pkalg/pkblob are acceptable");
#line 132
    while (1) {
#line 132
      tmp___21 = packet_remaining();
#line 132
      _len___0 = tmp___21;
#line 132
      if (_len___0 > 0) {
#line 132
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "auth2-pubkey.c",
            132);
#line 132
        packet_disconnect("Packet integrity error.");
      }
#line 132
      break;
    }
#line 142
    if (use_privsep) {
#line 142
      tmp___24 = mm_user_key_allowed(authctxt___0->pw, key);
    } else {
#line 142
      tmp___24 = user_key_allowed(authctxt___0->pw, key);
    }
#line 142
    if (tmp___24) {
#line 143
      packet_start((unsigned char)60);
#line 144
      packet_put_string((void const   *)pkalg, alen);
#line 145
      packet_put_string((void const   *)pkblob, blen);
#line 146
      packet_send();
#line 147
      packet_write_wait();
#line 148
      authctxt___0->postponed = 1;
    }
  }
#line 151
  if (authenticated != 1) {
#line 152
    auth_clear_options();
  }
  done: 
#line 154
  debug2("userauth_pubkey: authenticated %d pkalg %s", authenticated, pkalg);
#line 155
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 156
    key_free(key);
  }
#line 157
  xfree((void *)pkalg);
#line 158
  xfree((void *)pkblob);
#line 163
  return (authenticated);
}
}
#line 167 "auth2-pubkey.c"
static int user_key_allowed2(struct passwd *pw , Key *key , char *file ) 
{ char line[8192] ;
  int found_key ;
  FILE *f ;
  u_long linenum ;
  struct stat st ;
  Key *found ;
  char *fp ;
  int tmp ;
  int tmp___0 ;
  char *cp ;
  char *options___0 ;
  int quoted ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
#line 171
  found_key = 0;
#line 173
  linenum = (u_long )0;
#line 178
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 179
    return (0);
  }
#line 182
  temporarily_use_uid(pw);
#line 184
  debug("trying public key file %s", file);
#line 187
  tmp = stat((char const   * __restrict  )file, (struct stat * __restrict  )(& st));
#line 187
  if (tmp < 0) {
#line 189
    restore_uid();
#line 190
    return (0);
  }
#line 193
  f = fopen((char const   * __restrict  )file, (char const   * __restrict  )"r");
#line 194
  if (! f) {
#line 196
    restore_uid();
#line 197
    return (0);
  }
#line 199
  if (options.strict_modes) {
#line 199
    tmp___0 = secure_filename(f, (char const   *)file, pw, line, sizeof(line));
#line 199
    if (tmp___0 != 0) {
#line 201
      fclose(f);
#line 202
      log("Authentication refused: %s", line);
#line 203
      restore_uid();
#line 204
      return (0);
    }
  }
#line 207
  found_key = 0;
#line 208
  found = key_new(key->type);
#line 210
  while (1) {
#line 210
    tmp___6 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 210
    if (! tmp___6) {
#line 210
      break;
    }
#line 211
    options___0 = (char *)((void *)0);
#line 212
    linenum ++;
#line 214
    cp = line;
#line 214
    while (1) {
#line 214
      if (! ((int )*cp == 32)) {
#line 214
        if (! ((int )*cp == 9)) {
#line 214
          break;
        }
      }
#line 214
      cp ++;
    }
#line 216
    if (! *cp) {
#line 217
      continue;
    } else {
#line 216
      if ((int )*cp == 10) {
#line 217
        continue;
      } else {
#line 216
        if ((int )*cp == 35) {
#line 217
          continue;
        }
      }
    }
#line 219
    tmp___2 = key_read(found, & cp);
#line 219
    if (tmp___2 != 1) {
#line 221
      quoted = 0;
#line 222
      debug2("user_key_allowed: check options: \'%s\'", cp);
#line 223
      options___0 = cp;
#line 224
      while (1) {
#line 224
        if (*cp) {
#line 224
          if (! quoted) {
#line 224
            if ((int )*cp != 32) {
#line 224
              if (! ((int )*cp != 9)) {
#line 224
                break;
              }
            } else {
#line 224
              break;
            }
          }
        } else {
#line 224
          break;
        }
#line 225
        if ((int )*cp == 92) {
#line 225
          if ((int )*(cp + 1) == 34) {
#line 226
            cp ++;
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 227
          if ((int )*cp == 34) {
#line 228
            quoted = ! quoted;
          }
        }
#line 224
        cp ++;
      }
#line 231
      while (1) {
#line 231
        if (! ((int )*cp == 32)) {
#line 231
          if (! ((int )*cp == 9)) {
#line 231
            break;
          }
        }
#line 231
        cp ++;
      }
#line 233
      tmp___1 = key_read(found, & cp);
#line 233
      if (tmp___1 != 1) {
#line 234
        debug2("user_key_allowed: advance: \'%s\'", cp);
#line 236
        continue;
      }
    }
#line 239
    tmp___4 = key_equal(found, key);
#line 239
    if (tmp___4) {
#line 239
      tmp___5 = auth_parse_options(pw, options___0, file, linenum);
#line 239
      if (tmp___5 == 1) {
#line 241
        found_key = 1;
#line 242
        debug("matching key found: file %s, line %lu", file, linenum);
#line 244
        fp = key_fingerprint(found, 1, 0);
#line 245
        tmp___3 = key_type(found);
#line 245
        verbose("Found matching %s key: %s", tmp___3, fp);
#line 247
        xfree((void *)fp);
#line 248
        break;
      }
    }
  }
#line 251
  restore_uid();
#line 252
  fclose(f);
#line 253
  key_free(found);
#line 254
  if (! found_key) {
#line 255
    debug2("key not found");
  }
#line 256
  return (found_key);
}
}
#line 260 "auth2-pubkey.c"
int user_key_allowed(struct passwd *pw , Key *key ) 
{ int success ;
  char *file ;

  {
#line 266
  file = authorized_keys_file(pw);
#line 267
  success = user_key_allowed2(pw, key, file);
#line 268
  xfree((void *)file);
#line 269
  if (success) {
#line 270
    return (success);
  }
#line 273
  file = authorized_keys_file2(pw);
#line 274
  success = user_key_allowed2(pw, key, file);
#line 275
  xfree((void *)file);
#line 276
  return (success);
}
}
#line 279 "auth2-pubkey.c"
Authmethod method_pubkey  =    {(char *)"publickey", & userauth_pubkey, & options.pubkey_authentication};
#line 1 "auth-chall.o"
#line 34 "auth-chall.c"
KbdintDevice *devices[1] ;
#line 35 "auth-chall.c"
static KbdintDevice *device  ;
#line 37 "auth-chall.c"
char *get_challenge(Authctxt *authctxt___0 ) 
{ char *challenge ;
  char *name ;
  char *info ;
  char **prompts ;
  u_int i ;
  u_int numprompts ;
  u_int *echo_on ;
  int tmp ;

  {
#line 44
  device = devices[0];
#line 45
  if ((unsigned int )device == (unsigned int )((void *)0)) {
#line 46
    return ((char *)((void *)0));
  }
#line 47
  authctxt___0->kbdintctxt = (*(device->init_ctx))(authctxt___0);
#line 47
  if ((unsigned int )authctxt___0->kbdintctxt == (unsigned int )((void *)0)) {
#line 48
    return ((char *)((void *)0));
  }
#line 49
  tmp = (*(device->query))(authctxt___0->kbdintctxt, & name, & info, & numprompts,
                           & prompts, & echo_on);
#line 49
  if (tmp) {
#line 51
    (*(device->free_ctx))(authctxt___0->kbdintctxt);
#line 52
    authctxt___0->kbdintctxt = (void *)0;
#line 53
    return ((char *)((void *)0));
  }
#line 55
  if (numprompts < 1U) {
#line 56
    fatal("get_challenge: numprompts < 1");
  }
#line 57
  challenge = xstrdup((char const   *)*(prompts + 0));
#line 58
  i = 0U;
#line 58
  while (i < numprompts) {
#line 59
    xfree((void *)*(prompts + i));
#line 58
    i ++;
  }
#line 60
  xfree((void *)prompts);
#line 61
  xfree((void *)name);
#line 62
  xfree((void *)echo_on);
#line 63
  xfree((void *)info);
#line 65
  return (challenge);
}
}
#line 67 "auth-chall.c"
int verify_response(Authctxt *authctxt___0 , char const   *response ) 
{ char *resp[1] ;
  int res ;
  int tmp ;

  {
#line 73
  if ((unsigned int )device == (unsigned int )((void *)0)) {
#line 74
    return (0);
  }
#line 75
  if ((unsigned int )authctxt___0->kbdintctxt == (unsigned int )((void *)0)) {
#line 76
    return (0);
  }
#line 77
  resp[0] = (char *)response;
#line 78
  res = (*(device->respond))(authctxt___0->kbdintctxt, 1U, resp);
#line 79
  (*(device->free_ctx))(authctxt___0->kbdintctxt);
#line 80
  authctxt___0->kbdintctxt = (void *)0;
#line 81
  if (res) {
#line 81
    tmp = 0;
  } else {
#line 81
    tmp = 1;
  }
#line 81
  return (tmp);
}
}
#line 1 "auth2-chall.o"
#line 37 "auth2-chall.c"
static int auth2_challenge_start(Authctxt *authctxt___0 ) ;
#line 38
static int send_userauth_info_request(Authctxt *authctxt___0 ) ;
#line 39
static void input_userauth_info_response(int type , u_int32_t seq , void *ctxt ) ;
#line 49 "auth2-chall.c"
KbdintDevice *devices[1]  = {      (KbdintDevice *)((void *)0)};
#line 69 "auth2-chall.c"
static KbdintAuthctxt *kbdint_alloc(char const   *devs ) 
{ KbdintAuthctxt *kbdintctxt ;
  Buffer b ;
  int i ;
  void *tmp ;
  u_int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 76
  tmp = xmalloc(sizeof(KbdintAuthctxt ));
#line 76
  kbdintctxt = (KbdintAuthctxt *)tmp;
#line 77
  if (0) {
#line 77
    __s1_len = strlen(devs);
#line 77
    __s2_len = strlen("");
#line 77
    if (! ((unsigned int )((void const   *)(devs + 1)) - (unsigned int )((void const   *)devs) == 1U)) {
      goto _L___0;
    } else {
#line 77
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 77
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 77
          tmp___12 = 1;
        } else {
#line 77
          if (__s2_len >= 4U) {
#line 77
            tmp___12 = 1;
          } else {
#line 77
            tmp___12 = 0;
          }
        }
      } else {
#line 77
        tmp___12 = 0;
      }
    }
#line 77
    if (tmp___12) {
#line 77
      tmp___8 = __builtin_strcmp(devs, "");
    } else {
#line 77
      tmp___11 = __builtin_strcmp(devs, "");
#line 77
      tmp___8 = tmp___11;
    }
  } else {
#line 77
    tmp___11 = __builtin_strcmp(devs, "");
#line 77
    tmp___8 = tmp___11;
  }
#line 77
  if (tmp___8 == 0) {
#line 78
    buffer_init(& b);
#line 79
    i = 0;
#line 79
    while (devices[i]) {
#line 80
      tmp___0 = buffer_len(& b);
#line 80
      if (tmp___0 > 0U) {
#line 81
        buffer_append(& b, (void const   *)",", 1U);
      }
#line 82
      tmp___1 = strlen((devices[i])->name);
#line 82
      buffer_append(& b, (void const   *)(devices[i])->name, tmp___1);
#line 79
      i ++;
    }
#line 85
    buffer_append(& b, (void const   *)"\000", 1U);
#line 86
    tmp___2 = buffer_ptr(& b);
#line 86
    kbdintctxt->devices = xstrdup((char const   *)tmp___2);
#line 87
    buffer_free(& b);
  } else {
#line 89
    kbdintctxt->devices = xstrdup(devs);
  }
#line 91
  debug("kbdint_alloc: devices \'%s\'", kbdintctxt->devices);
#line 92
  kbdintctxt->ctxt = (void *)0;
#line 93
  kbdintctxt->device = (KbdintDevice *)((void *)0);
#line 94
  kbdintctxt->nreq = 0U;
#line 96
  return (kbdintctxt);
}
}
#line 98 "auth2-chall.c"
static void kbdint_reset_device(KbdintAuthctxt *kbdintctxt ) 
{ 

  {
#line 101
  if (kbdintctxt->ctxt) {
#line 102
    (*((kbdintctxt->device)->free_ctx))(kbdintctxt->ctxt);
#line 103
    kbdintctxt->ctxt = (void *)0;
  }
#line 105
  kbdintctxt->device = (KbdintDevice *)((void *)0);
#line 106
  return;
}
}
#line 107 "auth2-chall.c"
static void kbdint_free(KbdintAuthctxt *kbdintctxt ) 
{ 

  {
#line 110
  if (kbdintctxt->device) {
#line 111
    kbdint_reset_device(kbdintctxt);
  }
#line 112
  if (kbdintctxt->devices) {
#line 113
    xfree((void *)kbdintctxt->devices);
#line 114
    kbdintctxt->devices = (char *)((void *)0);
  }
#line 116
  xfree((void *)kbdintctxt);
#line 117
  return;
}
}
#line 119 "auth2-chall.c"
static int kbdint_next_device(KbdintAuthctxt *kbdintctxt ) 
{ size_t len ;
  char *t ;
  int i ;
  unsigned int tmp___64 ;
  int tmp___78 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___84 ;
  int tmp___87 ;
  int tmp___88 ;
  char const   *tmp___92 ;
  int tmp___93 ;

  {
#line 126
  if (kbdintctxt->device) {
#line 127
    kbdint_reset_device(kbdintctxt);
  }
#line 128
  while (1) {
#line 130
    if (kbdintctxt->devices) {
#line 130
      tmp___64 = __builtin_strcspn((char const   *)kbdintctxt->devices, ",");
#line 130
      len = tmp___64;
    } else {
#line 130
      len = 0U;
    }
#line 132
    if (len == 0U) {
#line 133
      break;
    }
#line 134
    i = 0;
#line 134
    while (devices[i]) {
#line 135
      if (0) {
#line 135
        if (0) {
#line 135
          __s1_len___0 = strlen((char const   *)kbdintctxt->devices);
#line 135
          __s2_len___0 = strlen((devices[i])->name);
#line 135
          if (! ((unsigned int )((void const   *)(kbdintctxt->devices + 1)) - (unsigned int )((void const   *)kbdintctxt->devices) == 1U)) {
            goto _L___2;
          } else {
#line 135
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 135
              if (! ((unsigned int )((void const   *)((devices[i])->name + 1)) - (unsigned int )((void const   *)(devices[i])->name) == 1U)) {
#line 135
                tmp___88 = 1;
              } else {
#line 135
                if (__s2_len___0 >= 4U) {
#line 135
                  tmp___88 = 1;
                } else {
#line 135
                  tmp___88 = 0;
                }
              }
            } else {
#line 135
              tmp___88 = 0;
            }
          }
#line 135
          if (tmp___88) {
#line 135
            tmp___84 = __builtin_strcmp((char const   *)kbdintctxt->devices, (devices[i])->name);
          } else {
#line 135
            tmp___87 = __builtin_strcmp((char const   *)kbdintctxt->devices, (devices[i])->name);
#line 135
            tmp___84 = tmp___87;
          }
        } else {
#line 135
          tmp___87 = __builtin_strcmp((char const   *)kbdintctxt->devices, (devices[i])->name);
#line 135
          tmp___84 = tmp___87;
        }
#line 135
        tmp___78 = tmp___84;
      } else {
#line 135
        tmp___78 = strncmp((char const   *)kbdintctxt->devices, (devices[i])->name,
                           len);
      }
#line 135
      if (tmp___78 == 0) {
#line 136
        kbdintctxt->device = devices[i];
      }
#line 134
      i ++;
    }
#line 137
    t = kbdintctxt->devices;
#line 138
    if (*(t + len)) {
#line 138
      kbdintctxt->devices = xstrdup((char const   *)((t + len) + 1));
    } else {
#line 138
      kbdintctxt->devices = (char *)((void *)0);
    }
#line 139
    xfree((void *)t);
#line 140
    if (kbdintctxt->devices) {
#line 140
      tmp___92 = (char const   *)kbdintctxt->devices;
    } else {
#line 140
      tmp___92 = "<empty>";
    }
#line 140
    debug2("kbdint_next_device: devices %s", tmp___92);
#line 128
    if (kbdintctxt->devices) {
#line 128
      if (! (! kbdintctxt->device)) {
#line 128
        break;
      }
    } else {
#line 128
      break;
    }
  }
#line 144
  if (kbdintctxt->device) {
#line 144
    tmp___93 = 1;
  } else {
#line 144
    tmp___93 = 0;
  }
#line 144
  return (tmp___93);
}
}
#line 151 "auth2-chall.c"
int auth2_challenge(Authctxt *authctxt___0 , char *devs ) 
{ char const   *tmp ;
  char const   *tmp___0 ;
  KbdintAuthctxt *tmp___1 ;
  int tmp___2 ;

  {
#line 154
  if (devs) {
#line 154
    tmp = (char const   *)devs;
  } else {
#line 154
    tmp = "<no devs>";
  }
#line 154
  if (authctxt___0->user) {
#line 154
    tmp___0 = (char const   *)authctxt___0->user;
  } else {
#line 154
    tmp___0 = "<nouser>";
  }
#line 154
  debug("auth2_challenge: user=%s devs=%s", tmp___0, tmp);
#line 158
  if ((unsigned int )authctxt___0->user == (unsigned int )((void *)0)) {
#line 159
    return (0);
  } else {
#line 158
    if (! devs) {
#line 159
      return (0);
    }
  }
#line 160
  if ((unsigned int )authctxt___0->kbdintctxt == (unsigned int )((void *)0)) {
#line 161
    tmp___1 = kbdint_alloc((char const   *)devs);
#line 161
    authctxt___0->kbdintctxt = (void *)tmp___1;
  }
#line 162
  tmp___2 = auth2_challenge_start(authctxt___0);
#line 162
  return (tmp___2);
}
}
#line 166 "auth2-chall.c"
void auth2_challenge_stop(Authctxt *authctxt___0 ) 
{ 

  {
#line 170
  dispatch_set(61, (dispatch_fn *)((void *)0));
#line 171
  if ((unsigned int )authctxt___0->kbdintctxt != (unsigned int )((void *)0)) {
#line 172
    kbdint_free((KbdintAuthctxt *)authctxt___0->kbdintctxt);
#line 173
    authctxt___0->kbdintctxt = (void *)0;
  }
#line 175
  return;
}
}
#line 178 "auth2-chall.c"
static int auth2_challenge_start(Authctxt *authctxt___0 ) 
{ KbdintAuthctxt *kbdintctxt ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 181
  kbdintctxt = (KbdintAuthctxt *)authctxt___0->kbdintctxt;
#line 183
  if (kbdintctxt->devices) {
#line 183
    tmp = (char const   *)kbdintctxt->devices;
  } else {
#line 183
    tmp = "<empty>";
  }
#line 183
  debug2("auth2_challenge_start: devices %s", tmp);
#line 186
  tmp___0 = kbdint_next_device(kbdintctxt);
#line 186
  if (tmp___0 == 0) {
#line 187
    auth2_challenge_stop(authctxt___0);
#line 188
    return (0);
  }
#line 190
  debug("auth2_challenge_start: trying authentication method \'%s\'", (kbdintctxt->device)->name);
#line 193
  kbdintctxt->ctxt = (*((kbdintctxt->device)->init_ctx))(authctxt___0);
#line 193
  if ((unsigned int )kbdintctxt->ctxt == (unsigned int )((void *)0)) {
#line 194
    auth2_challenge_stop(authctxt___0);
#line 195
    return (0);
  }
#line 197
  tmp___1 = send_userauth_info_request(authctxt___0);
#line 197
  if (tmp___1 == 0) {
#line 198
    auth2_challenge_stop(authctxt___0);
#line 199
    return (0);
  }
#line 201
  dispatch_set(61, & input_userauth_info_response);
#line 204
  authctxt___0->postponed = 1;
#line 205
  return (0);
}
}
#line 208 "auth2-chall.c"
static int send_userauth_info_request(Authctxt *authctxt___0 ) 
{ KbdintAuthctxt *kbdintctxt ;
  char *name ;
  char *instr ;
  char **prompts ;
  int i ;
  u_int *echo_on ;
  int tmp ;

  {
#line 216
  kbdintctxt = (KbdintAuthctxt *)authctxt___0->kbdintctxt;
#line 217
  tmp = (*((kbdintctxt->device)->query))(kbdintctxt->ctxt, & name, & instr, & kbdintctxt->nreq,
                                         & prompts, & echo_on);
#line 217
  if (tmp) {
#line 219
    return (0);
  }
#line 221
  packet_start((unsigned char)60);
#line 222
  packet_put_cstring((char const   *)name);
#line 223
  packet_put_cstring((char const   *)instr);
#line 224
  packet_put_cstring("");
#line 225
  packet_put_int(kbdintctxt->nreq);
#line 226
  i = 0;
#line 226
  while ((u_int )i < kbdintctxt->nreq) {
#line 227
    packet_put_cstring((char const   *)*(prompts + i));
#line 228
    packet_put_char((int )*(echo_on + i));
#line 226
    i ++;
  }
#line 230
  packet_send();
#line 231
  packet_write_wait();
#line 233
  i = 0;
#line 233
  while ((u_int )i < kbdintctxt->nreq) {
#line 234
    xfree((void *)*(prompts + i));
#line 233
    i ++;
  }
#line 235
  xfree((void *)prompts);
#line 236
  xfree((void *)echo_on);
#line 237
  xfree((void *)name);
#line 238
  xfree((void *)instr);
#line 239
  return (1);
}
}
#line 242 "auth2-chall.c"
static void input_userauth_info_response(int type , u_int32_t seq , void *ctxt ) 
{ Authctxt *authctxt___0 ;
  KbdintAuthctxt *kbdintctxt ;
  int i ;
  int authenticated ;
  int res ;
  int len ;
  u_int nresp ;
  char **response ;
  char *method ;
  void *tmp ;
  void *tmp___0 ;
  int _len ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;

  {
#line 245
  authctxt___0 = (Authctxt *)ctxt;
#line 247
  authenticated = 0;
#line 249
  response = (char **)((void *)0);
#line 251
  if ((unsigned int )authctxt___0 == (unsigned int )((void *)0)) {
#line 252
    fatal("input_userauth_info_response: no authctxt");
  }
#line 253
  kbdintctxt = (KbdintAuthctxt *)authctxt___0->kbdintctxt;
#line 254
  if ((unsigned int )kbdintctxt == (unsigned int )((void *)0)) {
#line 255
    fatal("input_userauth_info_response: no kbdintctxt");
  } else {
#line 254
    if ((unsigned int )kbdintctxt->ctxt == (unsigned int )((void *)0)) {
#line 255
      fatal("input_userauth_info_response: no kbdintctxt");
    }
  }
#line 256
  if ((unsigned int )kbdintctxt->device == (unsigned int )((void *)0)) {
#line 257
    fatal("input_userauth_info_response: no device");
  }
#line 259
  authctxt___0->postponed = 0;
#line 260
  nresp = packet_get_int();
#line 261
  if (nresp != kbdintctxt->nreq) {
#line 262
    fatal("input_userauth_info_response: wrong number of replies");
  }
#line 263
  if (nresp > 100U) {
#line 264
    fatal("input_userauth_info_response: too many replies");
  }
#line 265
  if (nresp > 0U) {
#line 266
    tmp = xmalloc(nresp * sizeof(char *));
#line 266
    response = (char **)tmp;
#line 267
    i = 0;
#line 267
    while ((u_int )i < nresp) {
#line 268
      tmp___0 = packet_get_string((u_int *)((void *)0));
#line 268
      *(response + i) = (char *)tmp___0;
#line 267
      i ++;
    }
  }
#line 270
  while (1) {
#line 270
    tmp___1 = packet_remaining();
#line 270
    _len = tmp___1;
#line 270
    if (_len > 0) {
#line 270
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2-chall.c",
          270);
#line 270
      packet_disconnect("Packet integrity error.");
    }
#line 270
    break;
  }
#line 272
  if (authctxt___0->valid) {
#line 273
    res = (*((kbdintctxt->device)->respond))(kbdintctxt->ctxt, nresp, response);
  } else {
#line 276
    res = -1;
  }
#line 279
  i = 0;
#line 279
  while ((u_int )i < nresp) {
#line 280
    tmp___2 = strlen((char const   *)*(response + i));
#line 280
    memset((void *)*(response + i), 'r', tmp___2);
#line 281
    xfree((void *)*(response + i));
#line 279
    i ++;
  }
#line 283
  if (response) {
#line 284
    xfree((void *)response);
  }
#line 286
  switch (res) {
  case 0: 
#line 289
  authenticated = 1;
#line 290
  break;
  case 1: 
#line 293
  tmp___3 = send_userauth_info_request(authctxt___0);
#line 293
  if (tmp___3 == 1) {
#line 294
    authctxt___0->postponed = 1;
  }
#line 295
  break;
  default: ;
#line 298
  break;
  }
#line 301
  tmp___4 = strlen("keyboard-interactive");
#line 301
  tmp___5 = strlen((kbdintctxt->device)->name);
#line 301
  len = (int )((tmp___4 + 2U) + tmp___5);
#line 303
  tmp___6 = xmalloc((unsigned int )len);
#line 303
  method = (char *)tmp___6;
#line 304
  snprintf((char * __restrict  )method, (unsigned int )len, (char const   * __restrict  )"keyboard-interactive/%s",
           (kbdintctxt->device)->name);
#line 307
  if (! authctxt___0->postponed) {
#line 308
    if (authenticated) {
#line 309
      auth2_challenge_stop(authctxt___0);
    } else {
#line 313
      auth2_challenge_start(authctxt___0);
    }
  }
#line 316
  userauth_finish(authctxt___0, authenticated, method);
#line 317
  xfree((void *)method);
#line 318
  return;
}
}
#line 320 "auth2-chall.c"
void privsep_challenge_enable(void) 
{ 

  {
#line 337
  return;
}
}
#line 1 "auth-rhosts.o"
#line 418 "/usr/include/netdb.h"
extern int innetgr(char const   *__netgroup , char const   *__host , char const   *__user ,
                   char const   *domain ) ;
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 37 "auth-rhosts.c"
static int check_rhosts_file(char const   *filename , char const   *hostname , char const   *ipaddr ,
                             char const   *client_user , char const   *server_user ) 
{ FILE *f ;
  char buf___1[1024] ;
  char hostbuf[1024] ;
  char userbuf[1024] ;
  char dummy[1024] ;
  char *host ;
  char *user ;
  char *cp ;
  int negated ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___45 ;
  int tmp___48 ;
  int tmp___49 ;
  char *tmp___50 ;

  {
#line 46
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 47
  if (! f) {
#line 48
    return (0);
  }
#line 50
  while (1) {
#line 50
    tmp___50 = fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )f);
#line 50
    if (! tmp___50) {
#line 50
      break;
    }
#line 55
    cp = buf___1;
#line 55
    while (1) {
#line 55
      if (! ((int )*cp == 32)) {
#line 55
        if (! ((int )*cp == 9)) {
#line 55
          break;
        }
      }
#line 55
      cp ++;
    }
#line 57
    if ((int )*cp == 35) {
#line 58
      continue;
    } else {
#line 57
      if ((int )*cp == 10) {
#line 58
        continue;
      } else {
#line 57
        if (! *cp) {
#line 58
          continue;
        }
      }
    }
#line 64
    if (0) {
#line 64
      if (0) {
#line 64
        __s1_len___0 = strlen((char const   *)cp);
#line 64
        __s2_len___0 = strlen("NO_PLUS");
#line 64
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___2;
        } else {
#line 64
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 64
            if (! ((unsigned int )((void const   *)("NO_PLUS" + 1)) - (unsigned int )((void const   *)"NO_PLUS") == 1U)) {
#line 64
              tmp___22 = 1;
            } else {
#line 64
              if (__s2_len___0 >= 4U) {
#line 64
                tmp___22 = 1;
              } else {
#line 64
                tmp___22 = 0;
              }
            }
          } else {
#line 64
            tmp___22 = 0;
          }
        }
#line 64
        if (tmp___22) {
#line 64
          tmp___18 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
        } else {
#line 64
          tmp___21 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 64
          tmp___18 = tmp___21;
        }
      } else {
#line 64
        tmp___21 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 64
        tmp___18 = tmp___21;
      }
#line 64
      tmp___12 = tmp___18;
    } else {
#line 64
      tmp___12 = strncmp((char const   *)cp, "NO_PLUS", 7U);
    }
#line 64
    if (tmp___12 == 0) {
#line 65
      continue;
    }
#line 71
    tmp___25 = sscanf((char const   * __restrict  )(buf___1), (char const   * __restrict  )"%s %s %s",
                      hostbuf, userbuf, dummy);
#line 71
    switch (tmp___25) {
    case 0: 
#line 73
    auth_debug_add("Found empty line in %.100s.", filename);
#line 74
    continue;
    case 1: 
#line 77
    strlcpy(userbuf, server_user, sizeof(userbuf));
#line 78
    break;
    case 2: 
#line 81
    break;
    case 3: 
#line 83
    auth_debug_add("Found garbage in %.100s.", filename);
#line 84
    continue;
    default: ;
#line 87
    continue;
    }
#line 90
    host = hostbuf;
#line 91
    user = userbuf;
#line 92
    negated = 0;
#line 95
    if ((int )*(host + 0) == 45) {
#line 96
      negated = 1;
#line 97
      host ++;
    } else {
#line 98
      if ((int )*(host + 0) == 43) {
#line 99
        host ++;
      }
    }
#line 101
    if ((int )*(user + 0) == 45) {
#line 102
      negated = 1;
#line 103
      user ++;
    } else {
#line 104
      if ((int )*(user + 0) == 43) {
#line 105
        user ++;
      }
    }
#line 108
    if (! *(host + 0)) {
#line 110
      auth_debug_add("Ignoring wild host/user names in %.100s.", filename);
#line 112
      continue;
    } else {
#line 108
      if (! *(user + 0)) {
#line 110
        auth_debug_add("Ignoring wild host/user names in %.100s.", filename);
#line 112
        continue;
      }
    }
#line 115
    if ((int )*(host + 0) == 64) {
#line 116
      tmp___26 = innetgr((char const   *)(host + 1), hostname, (char const   *)((void *)0),
                         (char const   *)((void *)0));
#line 116
      if (! tmp___26) {
#line 116
        tmp___27 = innetgr((char const   *)(host + 1), ipaddr, (char const   *)((void *)0),
                           (char const   *)((void *)0));
#line 116
        if (! tmp___27) {
#line 118
          continue;
        }
      }
    } else {
#line 119
      tmp___28 = strcasecmp((char const   *)host, hostname);
#line 119
      if (tmp___28) {
#line 119
        if (0) {
#line 119
          __s1_len___1 = strlen((char const   *)host);
#line 119
          __s2_len___1 = strlen(ipaddr);
#line 119
          if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
            goto _L___4;
          } else {
#line 119
            if (__s1_len___1 >= 4U) {
              _L___4: /* CIL Label */ 
#line 119
              if (! ((unsigned int )((void const   *)(ipaddr + 1)) - (unsigned int )((void const   *)ipaddr) == 1U)) {
#line 119
                tmp___38 = 1;
              } else {
#line 119
                if (__s2_len___1 >= 4U) {
#line 119
                  tmp___38 = 1;
                } else {
#line 119
                  tmp___38 = 0;
                }
              }
            } else {
#line 119
              tmp___38 = 0;
            }
          }
#line 119
          if (tmp___38) {
#line 119
            tmp___34 = __builtin_strcmp((char const   *)host, ipaddr);
          } else {
#line 119
            tmp___37 = __builtin_strcmp((char const   *)host, ipaddr);
#line 119
            tmp___34 = tmp___37;
          }
        } else {
#line 119
          tmp___37 = __builtin_strcmp((char const   *)host, ipaddr);
#line 119
          tmp___34 = tmp___37;
        }
#line 119
        if (tmp___34 != 0) {
#line 120
          continue;
        }
      }
    }
#line 123
    if ((int )*(user + 0) == 64) {
#line 124
      tmp___39 = innetgr((char const   *)(user + 1), (char const   *)((void *)0),
                         client_user, (char const   *)((void *)0));
#line 124
      if (! tmp___39) {
#line 125
        continue;
      }
    } else {
#line 126
      if (0) {
#line 126
        __s1_len___2 = strlen((char const   *)user);
#line 126
        __s2_len___2 = strlen(client_user);
#line 126
        if (! ((unsigned int )((void const   *)(user + 1)) - (unsigned int )((void const   *)user) == 1U)) {
          goto _L___6;
        } else {
#line 126
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 126
            if (! ((unsigned int )((void const   *)(client_user + 1)) - (unsigned int )((void const   *)client_user) == 1U)) {
#line 126
              tmp___49 = 1;
            } else {
#line 126
              if (__s2_len___2 >= 4U) {
#line 126
                tmp___49 = 1;
              } else {
#line 126
                tmp___49 = 0;
              }
            }
          } else {
#line 126
            tmp___49 = 0;
          }
        }
#line 126
        if (tmp___49) {
#line 126
          tmp___45 = __builtin_strcmp((char const   *)user, client_user);
        } else {
#line 126
          tmp___48 = __builtin_strcmp((char const   *)user, client_user);
#line 126
          tmp___45 = tmp___48;
        }
      } else {
#line 126
        tmp___48 = __builtin_strcmp((char const   *)user, client_user);
#line 126
        tmp___45 = tmp___48;
      }
#line 126
      if (tmp___45 != 0) {
#line 127
        continue;
      }
    }
#line 130
    fclose(f);
#line 133
    if (negated) {
#line 134
      auth_debug_add("Matched negative entry in %.100s.", filename);
#line 136
      return (0);
    }
#line 139
    return (1);
  }
#line 143
  fclose(f);
#line 144
  return (0);
}
}
#line 153 "auth-rhosts.c"
int auth_rhosts(struct passwd *pw , char const   *client_user ) 
{ char const   *hostname ;
  char const   *ipaddr ;
  int tmp ;

  {
#line 158
  hostname = get_canonical_hostname(options.verify_reverse_mapping);
#line 159
  ipaddr = get_remote_ipaddr();
#line 160
  tmp = auth_rhosts2(pw, client_user, hostname, ipaddr);
#line 160
  return (tmp);
}
}
#line 169
static int auth_rhosts2_raw(struct passwd *pw , char const   *client_user , char const   *hostname ,
                            char const   *ipaddr ) ;
#line 169 "auth-rhosts.c"
static char const   *rhosts_files[3]  = {      ".shosts",      ".rhosts",      (char const   *)((void *)0)};
#line 163 "auth-rhosts.c"
static int auth_rhosts2_raw(struct passwd *pw , char const   *client_user , char const   *hostname ,
                            char const   *ipaddr ) 
{ char buf___1[1024] ;
  struct stat st ;
  u_int rhosts_file_index ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 172
  debug2("auth_rhosts2: clientuser %s hostname %s ipaddr %s", client_user, hostname,
         ipaddr);
#line 176
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 177
    return (0);
  }
#line 180
  temporarily_use_uid(pw);
#line 186
  rhosts_file_index = 0U;
#line 186
  while (rhosts_files[rhosts_file_index]) {
#line 189
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.500s/%.100s",
             pw->pw_dir, rhosts_files[rhosts_file_index]);
#line 191
    tmp = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )(& st));
#line 191
    if (tmp >= 0) {
#line 192
      break;
    }
#line 186
    rhosts_file_index ++;
  }
#line 195
  restore_uid();
#line 198
  if (! rhosts_files[rhosts_file_index]) {
#line 198
    tmp___0 = stat((char const   * __restrict  )"/etc/hosts.equiv", (struct stat * __restrict  )(& st));
#line 198
    if (tmp___0 < 0) {
#line 198
      tmp___1 = stat((char const   * __restrict  )"/usr/local/etc/shosts.equiv", (struct stat * __restrict  )(& st));
#line 198
      if (tmp___1 < 0) {
#line 201
        return (0);
      }
    }
  }
#line 204
  if (pw->pw_uid != 0U) {
#line 205
    tmp___2 = check_rhosts_file("/etc/hosts.equiv", hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 205
    if (tmp___2) {
#line 207
      auth_debug_add("Accepted for %.100s [%.100s] by /etc/hosts.equiv.", hostname,
                     ipaddr);
#line 209
      return (1);
    }
#line 211
    tmp___3 = check_rhosts_file("/usr/local/etc/shosts.equiv", hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 211
    if (tmp___3) {
#line 213
      auth_debug_add("Accepted for %.100s [%.100s] by %.100s.", hostname, ipaddr,
                     "/usr/local/etc/shosts.equiv");
#line 215
      return (1);
    }
  }
#line 222
  tmp___4 = stat((char const   * __restrict  )pw->pw_dir, (struct stat * __restrict  )(& st));
#line 222
  if (tmp___4 < 0) {
#line 223
    log("Rhosts authentication refused for %.100s: no home directory %.200s", pw->pw_name,
        pw->pw_dir);
#line 225
    auth_debug_add("Rhosts authentication refused for %.100s: no home directory %.200s",
                   pw->pw_name, pw->pw_dir);
#line 227
    return (0);
  }
#line 229
  if (options.strict_modes) {
#line 229
    if (st.st_uid != 0U) {
#line 229
      if (st.st_uid != pw->pw_uid) {
#line 232
        log("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
            pw->pw_name);
#line 234
        auth_debug_add("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                       pw->pw_name);
#line 236
        return (0);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 229
      if ((st.st_mode & 18U) != 0U) {
#line 232
        log("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
            pw->pw_name);
#line 234
        auth_debug_add("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                       pw->pw_name);
#line 236
        return (0);
      }
    }
  }
#line 239
  temporarily_use_uid(pw);
#line 242
  rhosts_file_index = 0U;
#line 242
  while (rhosts_files[rhosts_file_index]) {
#line 245
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.500s/%.100s",
             pw->pw_dir, rhosts_files[rhosts_file_index]);
#line 247
    tmp___5 = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )(& st));
#line 247
    if (tmp___5 < 0) {
      goto __Cont;
    }
#line 256
    if (options.strict_modes) {
#line 256
      if (st.st_uid != 0U) {
#line 256
        if (st.st_uid != pw->pw_uid) {
#line 259
          log("Rhosts authentication refused for %.100s: bad modes for %.200s", pw->pw_name,
              buf___1);
#line 261
          auth_debug_add("Bad file modes for %.200s", buf___1);
          goto __Cont;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 256
        if ((st.st_mode & 18U) != 0U) {
#line 259
          log("Rhosts authentication refused for %.100s: bad modes for %.200s", pw->pw_name,
              buf___1);
#line 261
          auth_debug_add("Bad file modes for %.200s", buf___1);
          goto __Cont;
        }
      }
    }
#line 265
    if (options.ignore_rhosts) {
#line 266
      auth_debug_add("Server has been configured to ignore %.100s.", rhosts_files[rhosts_file_index]);
      goto __Cont;
    }
#line 271
    tmp___6 = check_rhosts_file((char const   *)(buf___1), hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 271
    if (tmp___6) {
#line 272
      auth_debug_add("Accepted by %.100s.", rhosts_files[rhosts_file_index]);
#line 275
      restore_uid();
#line 276
      auth_debug_add("Accepted host %s ip %s client_user %s server_user %s", hostname,
                     ipaddr, client_user, pw->pw_name);
#line 278
      return (1);
    }
    __Cont: /* CIL Label */ 
#line 242
    rhosts_file_index ++;
  }
#line 283
  restore_uid();
#line 284
  return (0);
}
}
#line 287 "auth-rhosts.c"
int auth_rhosts2(struct passwd *pw , char const   *client_user , char const   *hostname ,
                 char const   *ipaddr ) 
{ int ret ;

  {
#line 293
  auth_debug_reset();
#line 294
  ret = auth_rhosts2_raw(pw, client_user, hostname, ipaddr);
#line 295
  if (! use_privsep) {
#line 296
    auth_debug_send();
  }
#line 297
  return (ret);
}
}
#line 1 "auth-options.o"
#line 329 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 26 "auth-options.h"
int no_port_forwarding_flag ;
#line 27
int no_agent_forwarding_flag ;
#line 28
int no_x11_forwarding_flag ;
#line 29
int no_pty_flag ;
#line 31
struct envstring *custom_environment ;
#line 29 "auth-options.c"
int no_port_forwarding_flag  =    0;
#line 30 "auth-options.c"
int no_agent_forwarding_flag  =    0;
#line 31 "auth-options.c"
int no_x11_forwarding_flag  =    0;
#line 32 "auth-options.c"
int no_pty_flag  =    0;
#line 35 "auth-options.c"
char *forced_command  =    (char *)((void *)0);
#line 38 "auth-options.c"
struct envstring *custom_environment  =    (struct envstring *)((void *)0);
#line 42 "auth-options.c"
void auth_clear_options(void) 
{ struct envstring *ce ;

  {
#line 45
  no_agent_forwarding_flag = 0;
#line 46
  no_port_forwarding_flag = 0;
#line 47
  no_pty_flag = 0;
#line 48
  no_x11_forwarding_flag = 0;
#line 49
  while (custom_environment) {
#line 50
    ce = custom_environment;
#line 51
    custom_environment = ce->next;
#line 52
    xfree((void *)ce->s);
#line 53
    xfree((void *)ce);
  }
#line 55
  if (forced_command) {
#line 56
    xfree((void *)forced_command);
#line 57
    forced_command = (char *)((void *)0);
  }
#line 59
  channel_clear_permitted_opens();
#line 60
  auth_debug_reset();
#line 61
  return;
}
}
#line 67 "auth-options.c"
int auth_parse_options(struct passwd *pw , char *opts , char *file , u_long linenum ) 
{ char const   *cp ;
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  size_t tmp___17 ;
  int tmp___18 ;
  char *s ;
  struct envstring *new_envstring ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  void *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  void *tmp___25 ;
  size_t tmp___26 ;
  int tmp___27 ;
  char const   *remote_ip ;
  char const   *tmp___28 ;
  char const   *remote_host ;
  char const   *tmp___29 ;
  char *patterns ;
  size_t tmp___30 ;
  void *tmp___31 ;
  size_t tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  size_t tmp___37 ;
  int tmp___38 ;
  char host[256] ;
  char sport[6] ;
  u_short port ;
  char *patterns___0 ;
  size_t tmp___39 ;
  void *tmp___40 ;
  size_t tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  char *tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  size_t tmp___48 ;
  int tmp___49 ;

  {
#line 74
  auth_clear_options();
#line 76
  if (! opts) {
#line 77
    return (1);
  }
#line 79
  while (1) {
#line 79
    if (*opts) {
#line 79
      if ((int )*opts != 32) {
#line 79
        if (! ((int )*opts != 9)) {
#line 79
          break;
        }
      } else {
#line 79
        break;
      }
    } else {
#line 79
      break;
    }
#line 80
    cp = "no-port-forwarding";
#line 81
    tmp___0 = strlen(cp);
#line 81
    tmp___1 = strncasecmp((char const   *)opts, cp, tmp___0);
#line 81
    if (tmp___1 == 0) {
#line 82
      auth_debug_add("Port forwarding disabled.");
#line 83
      no_port_forwarding_flag = 1;
#line 84
      tmp = strlen(cp);
#line 84
      opts += tmp;
      goto next_option;
    }
#line 87
    cp = "no-agent-forwarding";
#line 88
    tmp___3 = strlen(cp);
#line 88
    tmp___4 = strncasecmp((char const   *)opts, cp, tmp___3);
#line 88
    if (tmp___4 == 0) {
#line 89
      auth_debug_add("Agent forwarding disabled.");
#line 90
      no_agent_forwarding_flag = 1;
#line 91
      tmp___2 = strlen(cp);
#line 91
      opts += tmp___2;
      goto next_option;
    }
#line 94
    cp = "no-X11-forwarding";
#line 95
    tmp___6 = strlen(cp);
#line 95
    tmp___7 = strncasecmp((char const   *)opts, cp, tmp___6);
#line 95
    if (tmp___7 == 0) {
#line 96
      auth_debug_add("X11 forwarding disabled.");
#line 97
      no_x11_forwarding_flag = 1;
#line 98
      tmp___5 = strlen(cp);
#line 98
      opts += tmp___5;
      goto next_option;
    }
#line 101
    cp = "no-pty";
#line 102
    tmp___9 = strlen(cp);
#line 102
    tmp___10 = strncasecmp((char const   *)opts, cp, tmp___9);
#line 102
    if (tmp___10 == 0) {
#line 103
      auth_debug_add("Pty allocation disabled.");
#line 104
      no_pty_flag = 1;
#line 105
      tmp___8 = strlen(cp);
#line 105
      opts += tmp___8;
      goto next_option;
    }
#line 108
    cp = "command=\"";
#line 109
    tmp___17 = strlen(cp);
#line 109
    tmp___18 = strncasecmp((char const   *)opts, cp, tmp___17);
#line 109
    if (tmp___18 == 0) {
#line 110
      tmp___11 = strlen(cp);
#line 110
      opts += tmp___11;
#line 111
      tmp___12 = strlen((char const   *)opts);
#line 111
      tmp___13 = xmalloc(tmp___12 + 1U);
#line 111
      forced_command = (char *)tmp___13;
#line 112
      i = 0;
#line 113
      while (*opts) {
#line 114
        if ((int )*opts == 34) {
#line 115
          break;
        }
#line 116
        if ((int )*opts == 92) {
#line 116
          if ((int )*(opts + 1) == 34) {
#line 117
            opts += 2;
#line 118
            tmp___14 = i;
#line 118
            i ++;
#line 118
            *(forced_command + tmp___14) = (char )'\"';
#line 119
            continue;
          }
        }
#line 121
        tmp___15 = i;
#line 121
        i ++;
#line 121
        tmp___16 = opts;
#line 121
        opts ++;
#line 121
        *(forced_command + tmp___15) = *tmp___16;
      }
#line 123
      if (! *opts) {
#line 124
        debug("%.100s, line %lu: missing end quote", file, linenum);
#line 126
        auth_debug_add("%.100s, line %lu: missing end quote", file, linenum);
#line 128
        xfree((void *)forced_command);
#line 129
        forced_command = (char *)((void *)0);
        goto bad_option;
      }
#line 132
      *(forced_command + i) = (char)0;
#line 133
      auth_debug_add("Forced command: %.900s", forced_command);
#line 134
      opts ++;
      goto next_option;
    }
#line 137
    cp = "environment=\"";
#line 138
    tmp___26 = strlen(cp);
#line 138
    tmp___27 = strncasecmp((char const   *)opts, cp, tmp___26);
#line 138
    if (tmp___27 == 0) {
#line 142
      tmp___19 = strlen(cp);
#line 142
      opts += tmp___19;
#line 143
      tmp___20 = strlen((char const   *)opts);
#line 143
      tmp___21 = xmalloc(tmp___20 + 1U);
#line 143
      s = (char *)tmp___21;
#line 144
      i = 0;
#line 145
      while (*opts) {
#line 146
        if ((int )*opts == 34) {
#line 147
          break;
        }
#line 148
        if ((int )*opts == 92) {
#line 148
          if ((int )*(opts + 1) == 34) {
#line 149
            opts += 2;
#line 150
            tmp___22 = i;
#line 150
            i ++;
#line 150
            *(s + tmp___22) = (char )'\"';
#line 151
            continue;
          }
        }
#line 153
        tmp___23 = i;
#line 153
        i ++;
#line 153
        tmp___24 = opts;
#line 153
        opts ++;
#line 153
        *(s + tmp___23) = *tmp___24;
      }
#line 155
      if (! *opts) {
#line 156
        debug("%.100s, line %lu: missing end quote", file, linenum);
#line 158
        auth_debug_add("%.100s, line %lu: missing end quote", file, linenum);
#line 160
        xfree((void *)s);
        goto bad_option;
      }
#line 163
      *(s + i) = (char)0;
#line 164
      auth_debug_add("Adding to environment: %.900s", s);
#line 165
      debug("Adding to environment: %.900s", s);
#line 166
      opts ++;
#line 167
      tmp___25 = xmalloc(sizeof(struct envstring ));
#line 167
      new_envstring = (struct envstring *)tmp___25;
#line 168
      new_envstring->s = s;
#line 169
      new_envstring->next = custom_environment;
#line 170
      custom_environment = new_envstring;
      goto next_option;
    }
#line 173
    cp = "from=\"";
#line 174
    tmp___37 = strlen(cp);
#line 174
    tmp___38 = strncasecmp((char const   *)opts, cp, tmp___37);
#line 174
    if (tmp___38 == 0) {
#line 175
      tmp___28 = get_remote_ipaddr();
#line 175
      remote_ip = tmp___28;
#line 176
      tmp___29 = get_canonical_hostname(options.verify_reverse_mapping);
#line 176
      remote_host = tmp___29;
#line 178
      tmp___30 = strlen((char const   *)opts);
#line 178
      tmp___31 = xmalloc(tmp___30 + 1U);
#line 178
      patterns = (char *)tmp___31;
#line 180
      tmp___32 = strlen(cp);
#line 180
      opts += tmp___32;
#line 181
      i = 0;
#line 182
      while (*opts) {
#line 183
        if ((int )*opts == 34) {
#line 184
          break;
        }
#line 185
        if ((int )*opts == 92) {
#line 185
          if ((int )*(opts + 1) == 34) {
#line 186
            opts += 2;
#line 187
            tmp___33 = i;
#line 187
            i ++;
#line 187
            *(patterns + tmp___33) = (char )'\"';
#line 188
            continue;
          }
        }
#line 190
        tmp___34 = i;
#line 190
        i ++;
#line 190
        tmp___35 = opts;
#line 190
        opts ++;
#line 190
        *(patterns + tmp___34) = *tmp___35;
      }
#line 192
      if (! *opts) {
#line 193
        debug("%.100s, line %lu: missing end quote", file, linenum);
#line 195
        auth_debug_add("%.100s, line %lu: missing end quote", file, linenum);
#line 197
        xfree((void *)patterns);
        goto bad_option;
      }
#line 200
      *(patterns + i) = (char)0;
#line 201
      opts ++;
#line 202
      tmp___36 = match_host_and_ip(remote_host, remote_ip, (char const   *)patterns);
#line 202
      if (tmp___36 != 1) {
#line 204
        xfree((void *)patterns);
#line 205
        log("Authentication tried for %.100s with correct key but not from a permitted host (host=%.200s, ip=%.200s).",
            pw->pw_name, remote_host, remote_ip);
#line 209
        auth_debug_add("Your host \'%.200s\' is not permitted to use this key for login.",
                       remote_host);
#line 213
        return (0);
      }
#line 215
      xfree((void *)patterns);
      goto next_option;
    }
#line 219
    cp = "permitopen=\"";
#line 220
    tmp___48 = strlen(cp);
#line 220
    tmp___49 = strncasecmp((char const   *)opts, cp, tmp___48);
#line 220
    if (tmp___49 == 0) {
#line 223
      tmp___39 = strlen((char const   *)opts);
#line 223
      tmp___40 = xmalloc(tmp___39 + 1U);
#line 223
      patterns___0 = (char *)tmp___40;
#line 225
      tmp___41 = strlen(cp);
#line 225
      opts += tmp___41;
#line 226
      i = 0;
#line 227
      while (*opts) {
#line 228
        if ((int )*opts == 34) {
#line 229
          break;
        }
#line 230
        if ((int )*opts == 92) {
#line 230
          if ((int )*(opts + 1) == 34) {
#line 231
            opts += 2;
#line 232
            tmp___42 = i;
#line 232
            i ++;
#line 232
            *(patterns___0 + tmp___42) = (char )'\"';
#line 233
            continue;
          }
        }
#line 235
        tmp___43 = i;
#line 235
        i ++;
#line 235
        tmp___44 = opts;
#line 235
        opts ++;
#line 235
        *(patterns___0 + tmp___43) = *tmp___44;
      }
#line 237
      if (! *opts) {
#line 238
        debug("%.100s, line %lu: missing end quote", file, linenum);
#line 240
        auth_debug_add("%.100s, line %lu: missing end quote", file, linenum);
#line 242
        xfree((void *)patterns___0);
        goto bad_option;
      }
#line 245
      *(patterns___0 + i) = (char)0;
#line 246
      opts ++;
#line 247
      tmp___45 = sscanf((char const   * __restrict  )patterns___0, (char const   * __restrict  )"%255[^:]:%5[0-9]",
                        host, sport);
#line 247
      if (tmp___45 != 2) {
#line 247
        tmp___46 = sscanf((char const   * __restrict  )patterns___0, (char const   * __restrict  )"%255[^/]/%5[0-9]",
                          host, sport);
#line 247
        if (tmp___46 != 2) {
#line 249
          debug("%.100s, line %lu: Bad permitopen specification <%.100s>", file, linenum,
                patterns___0);
#line 251
          auth_debug_add("%.100s, line %lu: Bad permitopen specification", file, linenum);
#line 253
          xfree((void *)patterns___0);
          goto bad_option;
        }
      }
#line 256
      tmp___47 = a2port((char const   *)(sport));
#line 256
      port = (unsigned short )tmp___47;
#line 256
      if ((int )port == 0) {
#line 257
        debug("%.100s, line %lu: Bad permitopen port <%.100s>", file, linenum, sport);
#line 259
        auth_debug_add("%.100s, line %lu: Bad permitopen port", file, linenum);
#line 261
        xfree((void *)patterns___0);
        goto bad_option;
      }
#line 264
      if (options.allow_tcp_forwarding) {
#line 265
        channel_add_permitted_opens(host, (int )port);
      }
#line 266
      xfree((void *)patterns___0);
      goto next_option;
    }
    next_option: 
#line 274
    if (! *opts) {
#line 275
      fatal("Bugs in auth-options.c option processing.");
    }
#line 276
    if ((int )*opts == 32) {
#line 277
      break;
    } else {
#line 276
      if ((int )*opts == 9) {
#line 277
        break;
      }
    }
#line 278
    if ((int )*opts != 44) {
      goto bad_option;
    }
#line 280
    opts ++;
  }
#line 284
  if (! use_privsep) {
#line 285
    auth_debug_send();
  }
#line 288
  return (1);
  bad_option: 
#line 291
  log("Bad options in %.100s file, line %lu: %.50s", file, linenum, opts);
#line 293
  auth_debug_add("Bad options in %.100s file, line %lu: %.50s", file, linenum, opts);
#line 296
  if (! use_privsep) {
#line 297
    auth_debug_send();
  }
#line 300
  return (0);
}
}
#line 1 "auth-krb4.o"
#line 1 "auth-krb5.o"
#line 1 "auth-pam.o"
#line 1 "auth2-pam.o"
#line 1 "auth-passwd.o"
#line 33 "/usr/include/crypt.h"
extern  __attribute__((__nothrow__)) char *crypt(char const   *__key , char const   *__salt )  __attribute__((__nonnull__(1,2))) ;
#line 89 "auth-passwd.c"
int auth_password(Authctxt *authctxt___0 , char const   *password ) 
{ struct passwd *pw ;
  char *encrypted_password ;
  char *pw_password ;
  char *salt ;
  struct spwd *spw ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 101
  pw = authctxt___0->pw;
#line 121
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 122
    return (0);
  }
#line 124
  if (pw->pw_uid == 0U) {
#line 124
    if (options.permit_root_login != 3) {
#line 125
      return (0);
    }
  }
#line 127
  if ((int const   )*password == 0) {
#line 127
    if (options.permit_empty_passwd == 0) {
#line 128
      return (0);
    }
  }
#line 165
  pw_password = pw->pw_passwd;
#line 171
  spw = getspnam((char const   *)pw->pw_name);
#line 172
  if ((unsigned int )spw != (unsigned int )((void *)0)) {
#line 173
    pw_password = spw->sp_pwdp;
  }
#line 192
  if ((int const   )*(password + 0) == 0) {
#line 192
    if ((int )*(pw_password + 0) == 0) {
#line 193
      return (1);
    }
  }
#line 195
  if ((int )*(pw_password + 0) != 0) {
#line 196
    salt = pw_password;
  } else {
#line 198
    salt = (char *)"xx";
  }
#line 215
  encrypted_password = crypt(password, (char const   *)salt);
#line 221
  if (0) {
#line 221
    __s1_len = strlen((char const   *)encrypted_password);
#line 221
    __s2_len = strlen((char const   *)pw_password);
#line 221
    if (! ((unsigned int )((void const   *)(encrypted_password + 1)) - (unsigned int )((void const   *)encrypted_password) == 1U)) {
      goto _L___0;
    } else {
#line 221
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 221
        if (! ((unsigned int )((void const   *)(pw_password + 1)) - (unsigned int )((void const   *)pw_password) == 1U)) {
#line 221
          tmp___8 = 1;
        } else {
#line 221
          if (__s2_len >= 4U) {
#line 221
            tmp___8 = 1;
          } else {
#line 221
            tmp___8 = 0;
          }
        }
      } else {
#line 221
        tmp___8 = 0;
      }
    }
#line 221
    if (tmp___8) {
#line 221
      tmp___4 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)pw_password);
    } else {
#line 221
      tmp___7 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)pw_password);
#line 221
      tmp___4 = tmp___7;
    }
  } else {
#line 221
    tmp___7 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)pw_password);
#line 221
    tmp___4 = tmp___7;
  }
#line 221
  return (tmp___4 == 0);
}
}
#line 1 "auth-rsa.o"
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 105 "auth.h"
int auth_rsa_challenge_dialog(Key *key ) ;
#line 106
BIGNUM *auth_rsa_generate_challenge(Key *key ) ;
#line 107
int auth_rsa_verify_response(Key *key , BIGNUM *challenge , u_char *response ) ;
#line 108
int auth_rsa_key_allowed(struct passwd *pw , BIGNUM *client_n , Key **rkey ) ;
#line 57 "auth-rsa.c"
BIGNUM *auth_rsa_generate_challenge(Key *key ) 
{ BIGNUM *challenge ;
  BN_CTX *ctx ;

  {
#line 63
  challenge = BN_new();
#line 63
  if ((unsigned int )challenge == (unsigned int )((void *)0)) {
#line 64
    fatal("auth_rsa_generate_challenge: BN_new() failed");
  }
#line 66
  BN_rand(challenge, 256, 0, 0);
#line 67
  ctx = BN_CTX_new();
#line 67
  if ((unsigned int )ctx == (unsigned int )((void *)0)) {
#line 68
    fatal("auth_rsa_generate_challenge: BN_CTX_new() failed");
  }
#line 69
  BN_div((BIGNUM *)((void *)0), challenge, (BIGNUM const   *)challenge, (BIGNUM const   *)(key->rsa)->n,
         ctx);
#line 70
  BN_CTX_free(ctx);
#line 72
  return (challenge);
}
}
#line 75 "auth-rsa.c"
int auth_rsa_verify_response(Key *key , BIGNUM *challenge , u_char *response ) 
{ u_char buf___1[32] ;
  u_char mdbuf[16] ;
  MD5_CTX md ;
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 83
  tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 83
  if (tmp___0 < 768) {
#line 84
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 84
    error("auth_rsa_verify_response: RSA modulus too small: %d < minimum %d bits",
          tmp, 768);
#line 86
    return (0);
  }
#line 90
  tmp___1 = BN_num_bits((BIGNUM const   *)challenge);
#line 90
  len = (tmp___1 + 7) / 8;
#line 91
  if (len <= 0) {
#line 92
    fatal("auth_rsa_verify_response: bad challenge length %d", len);
  } else {
#line 91
    if (len > 32) {
#line 92
      fatal("auth_rsa_verify_response: bad challenge length %d", len);
    }
  }
#line 93
  memset((void *)(buf___1), 0, 32U);
#line 94
  BN_bn2bin((BIGNUM const   *)challenge, (buf___1 + 32) - len);
#line 95
  MD5_Init(& md);
#line 96
  MD5_Update(& md, (void const   *)(buf___1), 32U);
#line 97
  MD5_Update(& md, (void const   *)(session_id), 16U);
#line 98
  MD5_Final(mdbuf, & md);
#line 101
  tmp___2 = memcmp((void const   *)response, (void const   *)(mdbuf), 16U);
#line 101
  if (tmp___2 != 0) {
#line 103
    return (0);
  }
#line 106
  return (1);
}
}
#line 115 "auth-rsa.c"
int auth_rsa_challenge_dialog(Key *key ) 
{ BIGNUM *challenge ;
  BIGNUM *encrypted_challenge ;
  u_char response[16] ;
  int i ;
  int success ;
  u_int tmp___1 ;
  int _len ;
  int tmp___2 ;

  {
#line 122
  encrypted_challenge = BN_new();
#line 122
  if ((unsigned int )encrypted_challenge == (unsigned int )((void *)0)) {
#line 123
    fatal("auth_rsa_challenge_dialog: BN_new() failed");
  }
#line 125
  if (use_privsep) {
#line 125
    challenge = mm_auth_rsa_generate_challenge(key);
  } else {
#line 125
    challenge = auth_rsa_generate_challenge(key);
  }
#line 128
  rsa_public_encrypt(encrypted_challenge, challenge, key->rsa);
#line 131
  packet_start((unsigned char)7);
#line 132
  packet_put_bignum(encrypted_challenge);
#line 133
  packet_send();
#line 134
  BN_clear_free(encrypted_challenge);
#line 135
  packet_write_wait();
#line 138
  packet_read_expect(8);
#line 139
  i = 0;
#line 139
  while (i < 16) {
#line 140
    tmp___1 = packet_get_char();
#line 140
    response[i] = (unsigned char )tmp___1;
#line 139
    i ++;
  }
#line 141
  while (1) {
#line 141
    tmp___2 = packet_remaining();
#line 141
    _len = tmp___2;
#line 141
    if (_len > 0) {
#line 141
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth-rsa.c",
          141);
#line 141
      packet_disconnect("Packet integrity error.");
    }
#line 141
    break;
  }
#line 143
  if (use_privsep) {
#line 143
    success = mm_auth_rsa_verify_response(key, challenge, response);
  } else {
#line 143
    success = auth_rsa_verify_response(key, challenge, (u_char *)(response));
  }
#line 144
  BN_clear_free(challenge);
#line 145
  return (success);
}
}
#line 153 "auth-rsa.c"
int auth_rsa_key_allowed(struct passwd *pw , BIGNUM *client_n , Key **rkey ) 
{ char line[8192] ;
  char *file ;
  int allowed ;
  u_int bits ;
  FILE *f ;
  u_long linenum ;
  struct stat st ;
  Key *key ;
  int tmp ;
  int tmp___0 ;
  char *cp ;
  char *options___0 ;
  int quoted ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
#line 157
  allowed = 0;
#line 160
  linenum = (u_long )0;
#line 165
  temporarily_use_uid(pw);
#line 168
  file = authorized_keys_file(pw);
#line 169
  debug("trying public RSA key file %s", file);
#line 172
  tmp = stat((char const   * __restrict  )file, (struct stat * __restrict  )(& st));
#line 172
  if (tmp < 0) {
#line 174
    restore_uid();
#line 175
    xfree((void *)file);
#line 176
    return (0);
  }
#line 179
  f = fopen((char const   * __restrict  )file, (char const   * __restrict  )"r");
#line 180
  if (! f) {
#line 182
    restore_uid();
#line 183
    xfree((void *)file);
#line 184
    return (0);
  }
#line 186
  if (options.strict_modes) {
#line 186
    tmp___0 = secure_filename(f, (char const   *)file, pw, line, sizeof(line));
#line 186
    if (tmp___0 != 0) {
#line 188
      xfree((void *)file);
#line 189
      fclose(f);
#line 190
      log("Authentication refused: %s", line);
#line 191
      restore_uid();
#line 192
      return (0);
    }
  }
#line 196
  allowed = 0;
#line 198
  key = key_new(0);
#line 205
  while (1) {
#line 205
    tmp___6 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 205
    if (! tmp___6) {
#line 205
      break;
    }
#line 209
    linenum ++;
#line 212
    cp = line;
#line 212
    while (1) {
#line 212
      if (! ((int )*cp == 32)) {
#line 212
        if (! ((int )*cp == 9)) {
#line 212
          break;
        }
      }
#line 212
      cp ++;
    }
#line 214
    if (! *cp) {
#line 215
      continue;
    } else {
#line 214
      if ((int )*cp == 10) {
#line 215
        continue;
      } else {
#line 214
        if ((int )*cp == 35) {
#line 215
          continue;
        }
      }
    }
#line 223
    if ((int )*cp < 48) {
      goto _L___0;
    } else {
#line 223
      if ((int )*cp > 57) {
        _L___0: /* CIL Label */ 
#line 224
        quoted = 0;
#line 225
        options___0 = cp;
#line 226
        while (1) {
#line 226
          if (*cp) {
#line 226
            if (! quoted) {
#line 226
              if ((int )*cp != 32) {
#line 226
                if (! ((int )*cp != 9)) {
#line 226
                  break;
                }
              } else {
#line 226
                break;
              }
            }
          } else {
#line 226
            break;
          }
#line 227
          if ((int )*cp == 92) {
#line 227
            if ((int )*(cp + 1) == 34) {
#line 228
              cp ++;
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 229
            if ((int )*cp == 34) {
#line 230
              quoted = ! quoted;
            }
          }
#line 226
          cp ++;
        }
      } else {
#line 233
        options___0 = (char *)((void *)0);
      }
    }
#line 236
    tmp___1 = hostfile_read_key(& cp, & bits, key);
#line 236
    if (tmp___1 == 0) {
#line 237
      debug("%.100s, line %lu: non ssh1 key syntax", file, linenum);
#line 239
      continue;
    }
#line 244
    tmp___2 = BN_cmp((BIGNUM const   *)(key->rsa)->n, (BIGNUM const   *)client_n);
#line 244
    if (tmp___2 != 0) {
#line 245
      continue;
    }
#line 248
    tmp___4 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 248
    if (bits != (u_int )tmp___4) {
#line 249
      tmp___3 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 249
      log("Warning: %s, line %lu: keysize mismatch: actual %d vs. announced %d.",
          file, linenum, tmp___3, bits);
    }
#line 258
    tmp___5 = auth_parse_options(pw, options___0, file, linenum);
#line 258
    if (! tmp___5) {
#line 259
      continue;
    }
#line 262
    allowed = 1;
#line 263
    break;
  }
#line 267
  restore_uid();
#line 270
  xfree((void *)file);
#line 271
  fclose(f);
#line 274
  if (allowed) {
#line 274
    if ((unsigned int )rkey != (unsigned int )((void *)0)) {
#line 275
      *rkey = key;
    } else {
#line 277
      key_free(key);
    }
  } else {
#line 277
    key_free(key);
  }
#line 278
  return (allowed);
}
}
#line 286 "auth-rsa.c"
int auth_rsa(struct passwd *pw , BIGNUM *client_n ) 
{ Key *key ;
  char *fp ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 293
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 294
    return (0);
  }
#line 296
  if (use_privsep) {
#line 296
    tmp___1 = mm_auth_rsa_key_allowed(pw, client_n, & key);
  } else {
#line 296
    tmp___1 = auth_rsa_key_allowed(pw, client_n, & key);
  }
#line 296
  if (! tmp___1) {
#line 297
    auth_clear_options();
#line 298
    return (0);
  }
#line 302
  tmp___2 = auth_rsa_challenge_dialog(key);
#line 302
  if (! tmp___2) {
#line 304
    verbose("Wrong response to RSA authentication challenge.");
#line 305
    packet_send_debug("Wrong response to RSA authentication challenge.");
#line 310
    key_free(key);
#line 311
    return (0);
  }
#line 319
  fp = key_fingerprint(key, 1, 0);
#line 320
  tmp___3 = key_type(key);
#line 320
  verbose("Found matching %s key: %s", tmp___3, fp);
#line 322
  xfree((void *)fp);
#line 323
  key_free(key);
#line 325
  packet_send_debug("RSA authentication accepted.");
#line 326
  return (1);
}
}
#line 1 "auth-rh-rsa.o"
#line 110 "auth.h"
int auth_rhosts_rsa_key_allowed(struct passwd *pw , char *cuser , char *chost , Key *client_host_key ) ;
#line 33 "auth-rh-rsa.c"
int auth_rhosts_rsa_key_allowed(struct passwd *pw , char *cuser , char *chost , Key *client_host_key ) 
{ HostStatus host_status ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 40
  tmp = auth_rhosts(pw, (char const   *)cuser);
#line 40
  if (! tmp) {
#line 41
    return (0);
  }
#line 43
  if (options.ignore_user_known_hosts) {
#line 43
    tmp___0 = (char const   *)((void *)0);
  } else {
#line 43
    tmp___0 = "~/.ssh/known_hosts";
  }
#line 43
  host_status = check_key_in_hostfiles(pw, client_host_key, (char const   *)chost,
                                       "/usr/local/etc/ssh_known_hosts", tmp___0);
#line 47
  return ((int )host_status == 0);
}
}
#line 54 "auth-rh-rsa.c"
int auth_rhosts_rsa(struct passwd *pw , char *cuser , Key *client_host_key ) 
{ char *chost ;
  char const   *tmp ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 59
  debug("Trying rhosts with RSA host authentication for client user %.100s", cuser);
#line 62
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 64
    return (0);
  } else {
#line 62
    if ((unsigned int )client_host_key == (unsigned int )((void *)0)) {
#line 64
      return (0);
    } else {
#line 62
      if ((unsigned int )client_host_key->rsa == (unsigned int )((void *)0)) {
#line 64
        return (0);
      }
    }
  }
#line 66
  tmp = get_canonical_hostname(options.verify_reverse_mapping);
#line 66
  chost = (char *)tmp;
#line 67
  debug("Rhosts RSA authentication: canonical host %.900s", chost);
#line 69
  if (use_privsep) {
#line 69
    tmp___2 = mm_auth_rhosts_rsa_key_allowed(pw, cuser, chost, client_host_key);
  } else {
#line 69
    tmp___2 = auth_rhosts_rsa_key_allowed(pw, cuser, chost, client_host_key);
  }
#line 69
  if (! tmp___2) {
#line 70
    debug("Rhosts with RSA host authentication denied: unknown or invalid host key");
#line 71
    packet_send_debug("Your host key cannot be verified: unknown or invalid host key.");
#line 72
    return (0);
  }
#line 77
  tmp___3 = auth_rsa_challenge_dialog(client_host_key);
#line 77
  if (! tmp___3) {
#line 78
    log("Client on %.800s failed to respond correctly to host authentication.", chost);
#line 80
    return (0);
  }
#line 87
  verbose("Rhosts with RSA host authentication accepted for %.100s, %.100s on %.700s.",
          pw->pw_name, cuser, chost);
#line 89
  packet_send_debug("Rhosts with RSA host authentication accepted.");
#line 90
  return (1);
}
}
#line 1 "auth-sia.o"
#line 1 "sshpty.o"
#line 109 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 433 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group )  __attribute__((__nonnull__(1))) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 736
extern  __attribute__((__nothrow__)) char *ttyname(int __fd ) ;
#line 872
extern  __attribute__((__nothrow__)) int vhangup(void) ;
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 280
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 20 "sshpty.h"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) ;
#line 21
void pty_release(char const   *ttyname___0 ) ;
#line 22
void pty_make_controlling_tty(int *ttyfd , char const   *ttyname___0 ) ;
#line 23
void pty_change_window_size(int ptyfd , int row , int col , int xpixel , int ypixel ) ;
#line 24
void pty_setowner(struct passwd *pw , char const   *ttyname___0 ) ;
#line 34 "/usr/include/pty.h"
extern  __attribute__((__nothrow__)) int openpty(int *__amaster , int *__aslave ,
                                                 char *__name , struct termios *__termp ,
                                                 struct winsize *__winp ) ;
#line 48 "sshpty.c"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) 
{ char *name ;
  int i ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 56
  i = openpty(ptyfd, ttyfd, (char *)((void *)0), (struct termios *)((void *)0), (struct winsize *)((void *)0));
#line 57
  if (i < 0) {
#line 58
    tmp = __errno_location();
#line 58
    tmp___0 = strerror(*tmp);
#line 58
    error("openpty: %.100s", tmp___0);
#line 59
    return (0);
  }
#line 61
  name = ttyname(*ttyfd);
#line 62
  if (! name) {
#line 63
    fatal("openpty returns device for which ttyname fails.");
  }
#line 65
  strlcpy(namebuf, (char const   *)name, (unsigned int )namebuflen);
#line 66
  return (1);
}
}
#line 252 "sshpty.c"
void pty_release(char const   *ttyname___0 ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 255
  tmp___1 = chown(ttyname___0, 0U, 0U);
#line 255
  if (tmp___1 < 0) {
#line 256
    tmp = __errno_location();
#line 256
    tmp___0 = strerror(*tmp);
#line 256
    error("chown %.100s 0 0 failed: %.100s", ttyname___0, tmp___0);
  }
#line 257
  tmp___4 = chmod(ttyname___0, 438U);
#line 257
  if (tmp___4 < 0) {
#line 258
    tmp___2 = __errno_location();
#line 258
    tmp___3 = strerror(*tmp___2);
#line 258
    error("chmod %.100s 0666 failed: %.100s", ttyname___0, tmp___3);
  }
#line 259
  return;
}
}
#line 263 "sshpty.c"
void pty_make_controlling_tty(int *ttyfd , char const   *ttyname___0 ) 
{ int fd ;
  void *old ;
  int *tmp ;
  char *tmp___0 ;
  __pid_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  mysig_t tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;

  {
#line 297
  fd = open("/dev/tty", 258);
#line 298
  if (fd >= 0) {
#line 299
    ioctl(fd, 21538UL, (void *)0);
#line 300
    close(fd);
  }
#line 303
  tmp___1 = setsid();
#line 303
  if (tmp___1 < 0) {
#line 304
    tmp = __errno_location();
#line 304
    tmp___0 = strerror(*tmp);
#line 304
    error("setsid: %.100s", tmp___0);
  }
#line 310
  fd = open("/dev/tty", 258);
#line 311
  if (fd >= 0) {
#line 312
    error("Failed to disconnect from controlling tty.");
#line 313
    close(fd);
  }
#line 317
  debug("Setting controlling tty using TIOCSCTTY.");
#line 318
  tmp___4 = ioctl(*ttyfd, 21518UL, (void *)0);
#line 318
  if (tmp___4 < 0) {
#line 319
    tmp___2 = __errno_location();
#line 319
    tmp___3 = strerror(*tmp___2);
#line 319
    error("ioctl(TIOCSCTTY): %.100s", tmp___3);
  }
#line 326
  tmp___5 = mysignal(1, (void (*)(int  ))1);
#line 326
  old = (void *)tmp___5;
#line 327
  vhangup();
#line 328
  mysignal(1, (void (*)(int  ))old);
#line 330
  fd = open(ttyname___0, 2);
#line 331
  if (fd < 0) {
#line 332
    tmp___6 = __errno_location();
#line 332
    tmp___7 = strerror(*tmp___6);
#line 332
    error("%.100s: %.100s", ttyname___0, tmp___7);
  } else {
#line 335
    close(*ttyfd);
#line 336
    *ttyfd = fd;
  }
#line 342
  fd = open("/dev/tty", 1);
#line 343
  if (fd < 0) {
#line 344
    tmp___8 = __errno_location();
#line 344
    tmp___9 = strerror(*tmp___8);
#line 344
    error("open /dev/tty failed - could not set controlling tty: %.100s", tmp___9);
  } else {
#line 347
    close(fd);
  }
#line 349
  return;
}
}
#line 353 "sshpty.c"
void pty_change_window_size(int ptyfd , int row , int col , int xpixel , int ypixel ) 
{ struct winsize w ;

  {
#line 359
  w.ws_row = (unsigned short )row;
#line 360
  w.ws_col = (unsigned short )col;
#line 361
  w.ws_xpixel = (unsigned short )xpixel;
#line 362
  w.ws_ypixel = (unsigned short )ypixel;
#line 363
  ioctl(ptyfd, 21524UL, & w);
#line 364
  return;
}
}
#line 366 "sshpty.c"
void pty_setowner(struct passwd *pw , char const   *ttyname___0 ) 
{ struct group *grp ;
  gid_t gid ;
  mode_t mode ;
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;

  {
#line 375
  grp = getgrnam("tty");
#line 376
  if (grp) {
#line 377
    gid = grp->gr_gid;
#line 378
    mode = (unsigned int )(384 | (128 >> 3));
  } else {
#line 380
    gid = pw->pw_gid;
#line 381
    mode = (unsigned int )((384 | (128 >> 3)) | ((128 >> 3) >> 3));
  }
#line 389
  tmp___1 = stat((char const   * __restrict  )ttyname___0, (struct stat * __restrict  )(& st));
#line 389
  if (tmp___1) {
#line 390
    tmp = __errno_location();
#line 390
    tmp___0 = strerror(*tmp);
#line 390
    fatal("stat(%.100s) failed: %.100s", ttyname___0, tmp___0);
  }
#line 393
  if (st.st_uid != pw->pw_uid) {
    goto _L;
  } else {
#line 393
    if (st.st_gid != gid) {
      _L: /* CIL Label */ 
#line 394
      tmp___7 = chown(ttyname___0, pw->pw_uid, gid);
#line 394
      if (tmp___7 < 0) {
#line 395
        tmp___6 = __errno_location();
#line 395
        if (*tmp___6 == 30) {
#line 395
          if (st.st_uid == pw->pw_uid) {
#line 397
            tmp___2 = __errno_location();
#line 397
            tmp___3 = strerror(*tmp___2);
#line 397
            error("chown(%.100s, %u, %u) failed: %.100s", ttyname___0, pw->pw_uid,
                  gid, tmp___3);
          } else {
#line 395
            if (st.st_uid == 0U) {
#line 397
              tmp___2 = __errno_location();
#line 397
              tmp___3 = strerror(*tmp___2);
#line 397
              error("chown(%.100s, %u, %u) failed: %.100s", ttyname___0, pw->pw_uid,
                    gid, tmp___3);
            } else {
#line 401
              tmp___4 = __errno_location();
#line 401
              tmp___5 = strerror(*tmp___4);
#line 401
              fatal("chown(%.100s, %u, %u) failed: %.100s", ttyname___0, pw->pw_uid,
                    gid, tmp___5);
            }
          }
        } else {
#line 401
          tmp___4 = __errno_location();
#line 401
          tmp___5 = strerror(*tmp___4);
#line 401
          fatal("chown(%.100s, %u, %u) failed: %.100s", ttyname___0, pw->pw_uid, gid,
                tmp___5);
        }
      }
    }
  }
#line 407
  if ((st.st_mode & (unsigned int )((448 | (448 >> 3)) | ((448 >> 3) >> 3))) != mode) {
#line 408
    tmp___13 = chmod(ttyname___0, mode);
#line 408
    if (tmp___13 < 0) {
#line 409
      tmp___12 = __errno_location();
#line 409
      if (*tmp___12 == 30) {
#line 409
        if ((st.st_mode & (unsigned int )((256 >> 3) | ((256 >> 3) >> 3))) == 0U) {
#line 411
          tmp___8 = __errno_location();
#line 411
          tmp___9 = strerror(*tmp___8);
#line 411
          error("chmod(%.100s, 0%o) failed: %.100s", ttyname___0, mode, tmp___9);
        } else {
#line 414
          tmp___10 = __errno_location();
#line 414
          tmp___11 = strerror(*tmp___10);
#line 414
          fatal("chmod(%.100s, 0%o) failed: %.100s", ttyname___0, mode, tmp___11);
        }
      } else {
#line 414
        tmp___10 = __errno_location();
#line 414
        tmp___11 = strerror(*tmp___10);
#line 414
        fatal("chmod(%.100s, 0%o) failed: %.100s", ttyname___0, mode, tmp___11);
      }
    }
  }
#line 418
  return;
}
}
#line 1 "sshlogin.o"
#line 100 "loginrec.h"
struct logininfo *login_alloc_entry(int pid , char const   *username , char const   *hostname ,
                                    char const   *line ) ;
#line 103
void login_free_entry(struct logininfo *li ) ;
#line 111
int login_login(struct logininfo *li ) ;
#line 112
int login_logout(struct logininfo *li ) ;
#line 124
void login_set_addr(struct logininfo *li , struct sockaddr  const  *sa , unsigned int sa_size ) ;
#line 131
struct logininfo *login_get_lastlog(struct logininfo *li , int uid ) ;
#line 51 "sshlogin.c"
u_long get_last_login_time(uid_t uid , char const   *logname , char *buf___1 , u_int bufsize ) 
{ struct logininfo li ;

  {
#line 57
  login_get_lastlog(& li, (int )uid);
#line 58
  strlcpy(buf___1, (char const   *)(li.hostname), bufsize);
#line 59
  return ((unsigned long )li.tv_sec);
}
}
#line 66 "sshlogin.c"
void record_login(pid_t pid , char const   *ttyname___0 , char const   *user , uid_t uid ,
                  char const   *host , struct sockaddr *addr ) 
{ struct logininfo *li ;

  {
#line 72
  li = login_alloc_entry(pid, user, host, ttyname___0);
#line 73
  login_set_addr(li, (struct sockaddr  const  *)addr, sizeof(struct sockaddr ));
#line 74
  login_login(li);
#line 75
  login_free_entry(li);
#line 76
  return;
}
}
#line 93 "sshlogin.c"
void record_logout(pid_t pid , char const   *ttyname___0 , char const   *user ) 
{ struct logininfo *li ;

  {
#line 98
  li = login_alloc_entry(pid, user, (char const   *)((void *)0), ttyname___0);
#line 99
  login_logout(li);
#line 100
  login_free_entry(li);
#line 101
  return;
}
}
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned int  ) ;  */
#line 1 "loginrec.o"
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval * __restrict  __tv ,
                                                      __timezone_ptr_t __tz )  __attribute__((__nonnull__(1))) ;
#line 46 "/usr/include/utmp.h"
extern  __attribute__((__nothrow__)) void login(struct utmp  const  *__entry ) ;
#line 49
extern  __attribute__((__nothrow__)) int logout(char const   *__ut_line ) ;
#line 52
extern  __attribute__((__nothrow__)) void logwtmp(char const   *__ut_line , char const   *__ut_name ,
                                                  char const   *__ut_host ) ;
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 105 "loginrec.h"
int login_init_entry(struct logininfo *li , int pid , char const   *username , char const   *hostname ,
                     char const   *line ) ;
#line 108
void login_set_current_time(struct logininfo *li ) ;
#line 120
int login_write(struct logininfo *li ) ;
#line 133
unsigned int login_get_lastlog_time(int uid ) ;
#line 136
char *line_fullname(char *dst , char const   *src , int dstsize ) ;
#line 137
char *line_stripname(char *dst , char const   *src , int dstsize ) ;
#line 138
char *line_abbrevname(char *dst , char const   *src , int dstsize ) ;
#line 181 "loginrec.c"
void set_utmp_time(struct logininfo *li , struct utmp *ut ) ;
#line 182
void construct_utmp(struct logininfo *li , struct utmp *ut ) ;
#line 194
int lastlog_write_entry(struct logininfo *li ) ;
#line 195
int syslogin_write_entry(struct logininfo *li ) ;
#line 197
int getlast_entry(struct logininfo *li ) ;
#line 198
int lastlog_get_entry(struct logininfo *li ) ;
#line 218 "loginrec.c"
int login_login(struct logininfo *li ) 
{ int tmp ;

  {
#line 221
  li->type = (short)7;
#line 222
  tmp = login_write(li);
#line 222
  return (tmp);
}
}
#line 234 "loginrec.c"
int login_logout(struct logininfo *li ) 
{ int tmp ;

  {
#line 237
  li->type = (short)8;
#line 238
  tmp = login_write(li);
#line 238
  return (tmp);
}
}
#line 258 "loginrec.c"
unsigned int login_get_lastlog_time(int uid ) 
{ struct logininfo li ;
  struct logininfo *tmp ;

  {
#line 263
  tmp = login_get_lastlog(& li, uid);
#line 263
  if (tmp) {
#line 264
    return (li.tv_sec);
  } else {
#line 266
    return (0U);
  }
}
}
#line 282 "loginrec.c"
struct logininfo *login_get_lastlog(struct logininfo *li , int uid ) 
{ struct passwd *pw ;
  int tmp ;

  {
#line 287
  memset((void *)li, '\000', sizeof(*li));
#line 288
  li->uid = uid;
#line 295
  pw = getpwuid((unsigned int )uid);
#line 296
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 297
    fatal("login_get_lastlog: Cannot find account for uid %i", uid);
  }
#line 301
  strlcpy(li->username, (char const   *)pw->pw_name, sizeof(li->username));
#line 303
  tmp = getlast_entry(li);
#line 303
  if (tmp) {
#line 304
    return (li);
  } else {
#line 306
    return ((struct logininfo *)((void *)0));
  }
}
}
#line 319 "loginrec.c"
struct logininfo *login_alloc_entry(int pid , char const   *username , char const   *hostname ,
                                    char const   *line ) 
{ struct logininfo *newli ;
  void *tmp ;

  {
#line 325
  tmp = xmalloc(sizeof(*newli));
#line 325
  newli = (struct logininfo *)tmp;
#line 326
  login_init_entry(newli, pid, username, hostname, line);
#line 327
  return (newli);
}
}
#line 332 "loginrec.c"
void login_free_entry(struct logininfo *li ) 
{ 

  {
#line 335
  xfree((void *)li);
#line 336
  return;
}
}
#line 347 "loginrec.c"
int login_init_entry(struct logininfo *li , int pid , char const   *username , char const   *hostname ,
                     char const   *line ) 
{ struct passwd *pw ;

  {
#line 353
  memset((void *)li, 0, sizeof(*li));
#line 355
  li->pid = pid;
#line 358
  if (line) {
#line 359
    line_fullname(li->line, line, (int )sizeof(li->line));
  }
#line 361
  if (username) {
#line 362
    strlcpy(li->username, username, sizeof(li->username));
#line 363
    pw = getpwnam((char const   *)(li->username));
#line 364
    if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 365
      fatal("login_init_entry: Cannot find user \"%s\"", li->username);
    }
#line 366
    li->uid = (int )pw->pw_uid;
  }
#line 369
  if (hostname) {
#line 370
    strlcpy(li->hostname, hostname, sizeof(li->hostname));
  }
#line 372
  return (1);
}
}
#line 381 "loginrec.c"
void login_set_current_time(struct logininfo *li ) 
{ struct timeval tv ;

  {
#line 386
  gettimeofday((struct timeval * __restrict  )(& tv), (struct timezone * __restrict  )((void *)0));
#line 388
  li->tv_sec = (unsigned int )tv.tv_sec;
#line 389
  li->tv_usec = (unsigned int )tv.tv_usec;
#line 390
  return;
}
}
#line 393 "loginrec.c"
void login_set_addr(struct logininfo *li , struct sockaddr  const  *sa , unsigned int sa_size ) 
{ unsigned int bufsize ;

  {
#line 397
  bufsize = sa_size;
#line 400
  if (sizeof(li->hostaddr) < sa_size) {
#line 401
    bufsize = sizeof(li->hostaddr);
  }
#line 403
  memcpy((void * __restrict  )((void *)(& li->hostaddr.sa)), (void const   * __restrict  )((void const   *)sa),
         bufsize);
#line 404
  return;
}
}
#line 411 "loginrec.c"
int login_write(struct logininfo *li ) 
{ __uid_t tmp ;

  {
#line 415
  tmp = geteuid();
#line 415
  if ((int )tmp != 0) {
#line 416
    log("Attempt to write login records by non-root user (aborting)");
#line 417
    return (1);
  }
#line 422
  login_set_current_time(li);
#line 424
  syslogin_write_entry(li);
#line 427
  if ((int )li->type == 7) {
#line 428
    lastlog_write_entry(li);
  }
#line 443
  return (0);
}
}
#line 474 "loginrec.c"
int getlast_entry(struct logininfo *li ) 
{ int tmp ;

  {
#line 478
  tmp = lastlog_get_entry(li);
#line 478
  return (tmp);
}
}
#line 525 "loginrec.c"
char *line_fullname(char *dst , char const   *src , int dstsize ) 
{ int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  size_t tmp___25 ;

  {
#line 528
  memset((void *)dst, '\000', (unsigned int )dstsize);
#line 529
  if (0) {
#line 529
    if (0) {
#line 529
      __s1_len___0 = strlen(src);
#line 529
      __s2_len___0 = strlen("/dev/");
#line 529
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 529
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 529
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 529
            tmp___22 = 1;
          } else {
#line 529
            if (__s2_len___0 >= 4U) {
#line 529
              tmp___22 = 1;
            } else {
#line 529
              tmp___22 = 0;
            }
          }
        } else {
#line 529
          tmp___22 = 0;
        }
      }
#line 529
      if (tmp___22) {
#line 529
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 529
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 529
        tmp___18 = tmp___21;
      }
    } else {
#line 529
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 529
      tmp___18 = tmp___21;
    }
#line 529
    tmp___12 = tmp___18;
  } else {
#line 529
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 529
  if (tmp___12 == 0) {
#line 530
    strlcpy(dst, src, (unsigned int )dstsize);
  } else {
#line 529
    tmp___25 = strlen(src);
#line 529
    if ((size_t )dstsize < tmp___25 + 5U) {
#line 530
      strlcpy(dst, src, (unsigned int )dstsize);
    } else {
#line 532
      strlcpy(dst, "/dev/", (unsigned int )dstsize);
#line 533
      strlcat(dst, src, (unsigned int )dstsize);
    }
  }
#line 535
  return (dst);
}
}
#line 539 "loginrec.c"
char *line_stripname(char *dst , char const   *src , int dstsize ) 
{ int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 542
  memset((void *)dst, '\000', (unsigned int )dstsize);
#line 543
  if (0) {
#line 543
    if (0) {
#line 543
      __s1_len___0 = strlen(src);
#line 543
      __s2_len___0 = strlen("/dev/");
#line 543
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 543
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 543
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 543
            tmp___22 = 1;
          } else {
#line 543
            if (__s2_len___0 >= 4U) {
#line 543
              tmp___22 = 1;
            } else {
#line 543
              tmp___22 = 0;
            }
          }
        } else {
#line 543
          tmp___22 = 0;
        }
      }
#line 543
      if (tmp___22) {
#line 543
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 543
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 543
        tmp___18 = tmp___21;
      }
    } else {
#line 543
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 543
      tmp___18 = tmp___21;
    }
#line 543
    tmp___12 = tmp___18;
  } else {
#line 543
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 543
  if (tmp___12 == 0) {
#line 544
    strlcpy(dst, src + 5, (unsigned int )dstsize);
  } else {
#line 546
    strlcpy(dst, src, (unsigned int )dstsize);
  }
#line 547
  return (dst);
}
}
#line 556 "loginrec.c"
char *line_abbrevname(char *dst , char const   *src , int dstsize ) 
{ size_t len ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 561
  memset((void *)dst, '\000', (unsigned int )dstsize);
#line 564
  if (0) {
#line 564
    if (0) {
#line 564
      __s1_len___0 = strlen(src);
#line 564
      __s2_len___0 = strlen("/dev/");
#line 564
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 564
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 564
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 564
            tmp___22 = 1;
          } else {
#line 564
            if (__s2_len___0 >= 4U) {
#line 564
              tmp___22 = 1;
            } else {
#line 564
              tmp___22 = 0;
            }
          }
        } else {
#line 564
          tmp___22 = 0;
        }
      }
#line 564
      if (tmp___22) {
#line 564
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 564
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 564
        tmp___18 = tmp___21;
      }
    } else {
#line 564
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 564
      tmp___18 = tmp___21;
    }
#line 564
    tmp___12 = tmp___18;
  } else {
#line 564
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 564
  if (tmp___12 == 0) {
#line 565
    src += 5;
  }
#line 572
  len = strlen(src);
#line 574
  if (len > 0U) {
#line 575
    if ((int )len - dstsize > 0) {
#line 576
      src += (int )len - dstsize;
    }
#line 579
    __builtin_strncpy(dst, src, (unsigned int )dstsize);
  }
#line 582
  return (dst);
}
}
#line 595 "loginrec.c"
void set_utmp_time(struct logininfo *li , struct utmp *ut ) 
{ 

  {
#line 599
  ut->ut_tv.tv_sec = (long )li->tv_sec;
#line 600
  ut->ut_tv.tv_usec = (long )li->tv_usec;
#line 606
  return;
}
}
#line 608 "loginrec.c"
void construct_utmp(struct logininfo *li , struct utmp *ut ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 612
  memset((void *)ut, '\000', sizeof(*ut));
#line 617
  line_abbrevname(ut->ut_id, (char const   *)(li->line), (int )sizeof(ut->ut_id));
#line 622
  switch ((int )li->type) {
  case 7: 
#line 624
  ut->ut_type = (short)7;
#line 628
  break;
  case 8: 
#line 630
  ut->ut_type = (short)8;
#line 634
  break;
  }
#line 637
  set_utmp_time(li, ut);
#line 639
  line_stripname(ut->ut_line, (char const   *)(li->line), (int )sizeof(ut->ut_line));
#line 642
  ut->ut_pid = li->pid;
#line 646
  if ((int )li->type == 8) {
#line 647
    return;
  }
#line 655
  if (sizeof(ut->ut_user) < sizeof(li->username)) {
#line 655
    tmp = sizeof(ut->ut_user);
  } else {
#line 655
    tmp = sizeof(li->username);
  }
#line 655
  __builtin_strncpy(ut->ut_user, (char const   *)(li->username), tmp);
#line 657
  if (sizeof(ut->ut_host) < sizeof(li->hostname)) {
#line 657
    tmp___0 = sizeof(ut->ut_host);
  } else {
#line 657
    tmp___0 = sizeof(li->hostname);
  }
#line 657
  __builtin_strncpy(ut->ut_host, (char const   *)(li->hostname), tmp___0);
#line 661
  if ((int )li->hostaddr.sa.sa_family == 2) {
#line 662
    ut->ut_addr_v6[0] = (int )li->hostaddr.sa_in.sin_addr.s_addr;
  }
#line 664
  return;
}
}
#line 1304 "loginrec.c"
static int syslogin_perform_login(struct logininfo *li ) 
{ struct utmp *ut ;
  void *tmp ;

  {
#line 1309
  tmp = malloc(sizeof(*ut));
#line 1309
  ut = (struct utmp *)tmp;
#line 1309
  if (! ut) {
#line 1310
    log("syslogin_perform_login: couldn\'t malloc()");
#line 1311
    return (0);
  }
#line 1313
  construct_utmp(li, ut);
#line 1314
  login((struct utmp  const  *)ut);
#line 1316
  return (1);
}
}
#line 1319 "loginrec.c"
static int syslogin_perform_logout(struct logininfo *li ) 
{ char line[8] ;
  int tmp ;

  {
#line 1325
  line_stripname(line, (char const   *)(li->line), (int )sizeof(line));
#line 1327
  tmp = logout((char const   *)(line));
#line 1327
  if (tmp) {
#line 1331
    logwtmp((char const   *)(line), "", "");
  } else {
#line 1328
    log("syslogin_perform_logout: logout() returned an error");
  }
#line 1339
  return (1);
}
}
#line 1342 "loginrec.c"
int syslogin_write_entry(struct logininfo *li ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 1345
  switch ((int )li->type) {
  case 7: 
#line 1347
  tmp = syslogin_perform_login(li);
#line 1347
  return (tmp);
  case 8: 
#line 1349
  tmp___0 = syslogin_perform_logout(li);
#line 1349
  return (tmp___0);
  default: 
#line 1351
  log("syslogin_write_entry: Invalid type field");
#line 1352
  return (0);
  }
}
}
#line 1368 "loginrec.c"
static void lastlog_construct(struct logininfo *li , struct lastlog *last ) 
{ unsigned int tmp ;

  {
#line 1372
  memset((void *)last, '\000', sizeof(*last));
#line 1374
  line_stripname(last->ll_line, (char const   *)(li->line), (int )sizeof(last->ll_line));
#line 1375
  if (sizeof(last->ll_host) < sizeof(li->hostname)) {
#line 1375
    tmp = sizeof(last->ll_host);
  } else {
#line 1375
    tmp = sizeof(li->hostname);
  }
#line 1375
  strlcpy(last->ll_host, (char const   *)(li->hostname), tmp);
#line 1377
  last->ll_time = (long )li->tv_sec;
#line 1378
  return;
}
}
#line 1380 "loginrec.c"
static int lastlog_filetype(char *filename ) 
{ struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1385
  tmp___1 = stat((char const   * __restrict  )"/var/log/lastlog", (struct stat * __restrict  )(& st));
#line 1385
  if (tmp___1 != 0) {
#line 1386
    tmp = __errno_location();
#line 1386
    tmp___0 = strerror(*tmp);
#line 1386
    log("lastlog_perform_login: Couldn\'t stat %s: %s", "/var/log/lastlog", tmp___0);
#line 1388
    return (0);
  }
#line 1390
  if ((st.st_mode & 61440U) == 16384U) {
#line 1391
    return (2);
  } else {
#line 1392
    if ((st.st_mode & 61440U) == 32768U) {
#line 1393
      return (1);
    } else {
#line 1395
      return (3);
    }
  }
}
}
#line 1400 "loginrec.c"
static int lastlog_openseek(struct logininfo *li , int *fd , int filemode ) 
{ off_t offset ;
  int type ;
  char lastlog_file[1024] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  __off64_t tmp___3 ;

  {
#line 1407
  type = lastlog_filetype((char *)"/var/log/lastlog");
#line 1408
  switch (type) {
  case 1: 
#line 1410
  strlcpy(lastlog_file, "/var/log/lastlog", sizeof(lastlog_file));
#line 1411
  break;
  case 2: 
#line 1413
  snprintf((char * __restrict  )(lastlog_file), sizeof(lastlog_file), (char const   * __restrict  )"%s/%s",
           "/var/log/lastlog", li->username);
#line 1415
  break;
  default: 
#line 1417
  log("lastlog_openseek: %.100s is not a file or directory!", "/var/log/lastlog");
#line 1419
  return (0);
  }
#line 1422
  *fd = open((char const   *)(lastlog_file), filemode);
#line 1423
  if (*fd < 0) {
#line 1424
    tmp = __errno_location();
#line 1424
    tmp___0 = strerror(*tmp);
#line 1424
    debug("lastlog_openseek: Couldn\'t open %s: %s", lastlog_file, tmp___0);
#line 1426
    return (0);
  }
#line 1429
  if (type == 1) {
#line 1431
    offset = (long long )((unsigned long )((long )li->uid) * (unsigned long )sizeof(struct lastlog ));
#line 1433
    tmp___3 = lseek(*fd, offset, 0);
#line 1433
    if (tmp___3 != offset) {
#line 1434
      tmp___1 = __errno_location();
#line 1434
      tmp___2 = strerror(*tmp___1);
#line 1434
      log("lastlog_openseek: %s->lseek(): %s", lastlog_file, tmp___2);
#line 1436
      return (0);
    }
  }
#line 1440
  return (1);
}
}
#line 1443 "loginrec.c"
static int lastlog_perform_login(struct logininfo *li ) 
{ struct lastlog last ;
  int fd ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 1450
  lastlog_construct(li, & last);
#line 1452
  tmp = lastlog_openseek(li, & fd, 66);
#line 1452
  if (! tmp) {
#line 1453
    return (0);
  }
#line 1456
  tmp___2 = atomicio((ssize_t (*)())(& write), fd, (void *)(& last), sizeof(last));
#line 1456
  if ((unsigned int )tmp___2 != sizeof(last)) {
#line 1457
    close(fd);
#line 1458
    tmp___0 = __errno_location();
#line 1458
    tmp___1 = strerror(*tmp___0);
#line 1458
    log("lastlog_write_filemode: Error writing to %s: %s", "/var/log/lastlog", tmp___1);
#line 1460
    return (0);
  }
#line 1463
  close(fd);
#line 1464
  return (1);
}
}
#line 1467 "loginrec.c"
int lastlog_write_entry(struct logininfo *li ) 
{ int tmp ;

  {
#line 1470
  switch ((int )li->type) {
  case 7: 
#line 1472
  tmp = lastlog_perform_login(li);
#line 1472
  return (tmp);
  default: 
#line 1474
  log("lastlog_write_entry: Invalid type field");
#line 1475
  return (0);
  }
}
}
#line 1479 "loginrec.c"
static void lastlog_populate_entry(struct logininfo *li , struct lastlog *last ) 
{ unsigned int tmp ;

  {
#line 1482
  line_fullname(li->line, (char const   *)(last->ll_line), (int )sizeof(li->line));
#line 1483
  if (sizeof(li->hostname) < sizeof(last->ll_host)) {
#line 1483
    tmp = sizeof(li->hostname);
  } else {
#line 1483
    tmp = sizeof(last->ll_host);
  }
#line 1483
  strlcpy(li->hostname, (char const   *)(last->ll_host), tmp);
#line 1485
  li->tv_sec = (unsigned int )last->ll_time;
#line 1486
  return;
}
}
#line 1488 "loginrec.c"
int lastlog_get_entry(struct logininfo *li ) 
{ struct lastlog last ;
  int fd ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 1494
  tmp = lastlog_openseek(li, & fd, 0);
#line 1494
  if (! tmp) {
#line 1495
    return (0);
  }
#line 1497
  tmp___2 = atomicio((ssize_t (*)())(& read), fd, (void *)(& last), sizeof(last));
#line 1497
  if ((unsigned int )tmp___2 != sizeof(last)) {
#line 1498
    close(fd);
#line 1499
    tmp___0 = __errno_location();
#line 1499
    tmp___1 = strerror(*tmp___0);
#line 1499
    log("lastlog_get_entry: Error reading from %s: %s", "/var/log/lastlog", tmp___1);
#line 1501
    return (0);
  }
#line 1504
  close(fd);
#line 1506
  lastlog_populate_entry(li, & last);
#line 1508
  return (1);
}
}
#line 1 "servconf.o"
#line 747 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 43 "servconf.c"
static void add_listen_addr(ServerOptions *options___0 , char *addr , u_short port ) ;
#line 44
static void add_one_listen_addr(ServerOptions *options___0 , char *addr , u_short port ) ;
#line 53 "servconf.c"
void initialize_server_options(ServerOptions *options___0 ) 
{ 

  {
#line 56
  memset((void *)options___0, 0, sizeof(*options___0));
#line 59
  options___0->pam_authentication_via_kbd_int = -1;
#line 62
  options___0->num_ports = 0U;
#line 63
  options___0->ports_from_cmdline = 0U;
#line 64
  options___0->listen_addrs = (struct addrinfo *)((void *)0);
#line 65
  options___0->num_host_key_files = 0;
#line 66
  options___0->pid_file = (char *)((void *)0);
#line 67
  options___0->server_key_bits = -1;
#line 68
  options___0->login_grace_time = -1;
#line 69
  options___0->key_regeneration_time = -1;
#line 70
  options___0->permit_root_login = -1;
#line 71
  options___0->ignore_rhosts = -1;
#line 72
  options___0->ignore_user_known_hosts = -1;
#line 73
  options___0->print_motd = -1;
#line 74
  options___0->print_lastlog = -1;
#line 75
  options___0->x11_forwarding = -1;
#line 76
  options___0->x11_display_offset = -1;
#line 77
  options___0->x11_use_localhost = -1;
#line 78
  options___0->xauth_location = (char *)((void *)0);
#line 79
  options___0->strict_modes = -1;
#line 80
  options___0->keepalives = -1;
#line 81
  options___0->log_facility = -1;
#line 82
  options___0->log_level = -1;
#line 83
  options___0->rhosts_authentication = -1;
#line 84
  options___0->rhosts_rsa_authentication = -1;
#line 85
  options___0->hostbased_authentication = -1;
#line 86
  options___0->hostbased_uses_name_from_packet_only = -1;
#line 87
  options___0->rsa_authentication = -1;
#line 88
  options___0->pubkey_authentication = -1;
#line 100
  options___0->password_authentication = -1;
#line 101
  options___0->kbd_interactive_authentication = -1;
#line 102
  options___0->challenge_response_authentication = -1;
#line 103
  options___0->permit_empty_passwd = -1;
#line 104
  options___0->use_login = -1;
#line 105
  options___0->compression = -1;
#line 106
  options___0->allow_tcp_forwarding = -1;
#line 107
  options___0->num_allow_users = 0U;
#line 108
  options___0->num_deny_users = 0U;
#line 109
  options___0->num_allow_groups = 0U;
#line 110
  options___0->num_deny_groups = 0U;
#line 111
  options___0->ciphers = (char *)((void *)0);
#line 112
  options___0->macs = (char *)((void *)0);
#line 113
  options___0->protocol = 0;
#line 114
  options___0->gateway_ports = -1;
#line 115
  options___0->num_subsystems = 0U;
#line 116
  options___0->max_startups_begin = -1;
#line 117
  options___0->max_startups_rate = -1;
#line 118
  options___0->max_startups = -1;
#line 119
  options___0->banner = (char *)((void *)0);
#line 120
  options___0->verify_reverse_mapping = -1;
#line 121
  options___0->client_alive_interval = -1;
#line 122
  options___0->client_alive_count_max = -1;
#line 123
  options___0->authorized_keys_file = (char *)((void *)0);
#line 124
  options___0->authorized_keys_file2 = (char *)((void *)0);
#line 127
  use_privsep = -1;
#line 128
  return;
}
}
#line 130 "servconf.c"
void fill_default_server_options(ServerOptions *options___0 ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  u_int tmp___2 ;

  {
#line 134
  if (options___0->pam_authentication_via_kbd_int == -1) {
#line 135
    options___0->pam_authentication_via_kbd_int = 0;
  }
#line 138
  if (options___0->protocol == 0) {
#line 139
    options___0->protocol = 5;
  }
#line 140
  if (options___0->num_host_key_files == 0) {
#line 142
    if (options___0->protocol & 1) {
#line 143
      tmp = options___0->num_host_key_files;
#line 143
      (options___0->num_host_key_files) ++;
#line 143
      options___0->host_key_files[tmp] = (char *)"/usr/local/etc/ssh_host_key";
    }
#line 145
    if (options___0->protocol & 4) {
#line 146
      tmp___0 = options___0->num_host_key_files;
#line 146
      (options___0->num_host_key_files) ++;
#line 146
      options___0->host_key_files[tmp___0] = (char *)"/usr/local/etc/ssh_host_rsa_key";
#line 148
      tmp___1 = options___0->num_host_key_files;
#line 148
      (options___0->num_host_key_files) ++;
#line 148
      options___0->host_key_files[tmp___1] = (char *)"/usr/local/etc/ssh_host_dsa_key";
    }
  }
#line 152
  if (options___0->num_ports == 0U) {
#line 153
    tmp___2 = options___0->num_ports;
#line 153
    (options___0->num_ports) ++;
#line 153
    options___0->ports[tmp___2] = (unsigned short)22;
  }
#line 154
  if ((unsigned int )options___0->listen_addrs == (unsigned int )((void *)0)) {
#line 155
    add_listen_addr(options___0, (char *)((void *)0), (unsigned short)0);
  }
#line 156
  if ((unsigned int )options___0->pid_file == (unsigned int )((void *)0)) {
#line 157
    options___0->pid_file = (char *)"/var/run/sshd.pid";
  }
#line 158
  if (options___0->server_key_bits == -1) {
#line 159
    options___0->server_key_bits = 768;
  }
#line 160
  if (options___0->login_grace_time == -1) {
#line 161
    options___0->login_grace_time = 600;
  }
#line 162
  if (options___0->key_regeneration_time == -1) {
#line 163
    options___0->key_regeneration_time = 3600;
  }
#line 164
  if (options___0->permit_root_login == -1) {
#line 165
    options___0->permit_root_login = 3;
  }
#line 166
  if (options___0->ignore_rhosts == -1) {
#line 167
    options___0->ignore_rhosts = 1;
  }
#line 168
  if (options___0->ignore_user_known_hosts == -1) {
#line 169
    options___0->ignore_user_known_hosts = 0;
  }
#line 170
  if (options___0->print_motd == -1) {
#line 171
    options___0->print_motd = 1;
  }
#line 172
  if (options___0->print_lastlog == -1) {
#line 173
    options___0->print_lastlog = 1;
  }
#line 174
  if (options___0->x11_forwarding == -1) {
#line 175
    options___0->x11_forwarding = 0;
  }
#line 176
  if (options___0->x11_display_offset == -1) {
#line 177
    options___0->x11_display_offset = 10;
  }
#line 178
  if (options___0->x11_use_localhost == -1) {
#line 179
    options___0->x11_use_localhost = 1;
  }
#line 180
  if ((unsigned int )options___0->xauth_location == (unsigned int )((void *)0)) {
#line 181
    options___0->xauth_location = (char *)"/usr/bin//xauth";
  }
#line 182
  if (options___0->strict_modes == -1) {
#line 183
    options___0->strict_modes = 1;
  }
#line 184
  if (options___0->keepalives == -1) {
#line 185
    options___0->keepalives = 1;
  }
#line 186
  if ((int )options___0->log_facility == -1) {
#line 187
    options___0->log_facility = 2;
  }
#line 188
  if ((int )options___0->log_level == -1) {
#line 189
    options___0->log_level = 3;
  }
#line 190
  if (options___0->rhosts_authentication == -1) {
#line 191
    options___0->rhosts_authentication = 0;
  }
#line 192
  if (options___0->rhosts_rsa_authentication == -1) {
#line 193
    options___0->rhosts_rsa_authentication = 0;
  }
#line 194
  if (options___0->hostbased_authentication == -1) {
#line 195
    options___0->hostbased_authentication = 0;
  }
#line 196
  if (options___0->hostbased_uses_name_from_packet_only == -1) {
#line 197
    options___0->hostbased_uses_name_from_packet_only = 0;
  }
#line 198
  if (options___0->rsa_authentication == -1) {
#line 199
    options___0->rsa_authentication = 1;
  }
#line 200
  if (options___0->pubkey_authentication == -1) {
#line 201
    options___0->pubkey_authentication = 1;
  }
#line 218
  if (options___0->password_authentication == -1) {
#line 219
    options___0->password_authentication = 1;
  }
#line 220
  if (options___0->kbd_interactive_authentication == -1) {
#line 221
    options___0->kbd_interactive_authentication = 0;
  }
#line 222
  if (options___0->challenge_response_authentication == -1) {
#line 223
    options___0->challenge_response_authentication = 1;
  }
#line 224
  if (options___0->permit_empty_passwd == -1) {
#line 225
    options___0->permit_empty_passwd = 0;
  }
#line 226
  if (options___0->use_login == -1) {
#line 227
    options___0->use_login = 0;
  }
#line 228
  if (options___0->compression == -1) {
#line 229
    options___0->compression = 1;
  }
#line 230
  if (options___0->allow_tcp_forwarding == -1) {
#line 231
    options___0->allow_tcp_forwarding = 1;
  }
#line 232
  if (options___0->gateway_ports == -1) {
#line 233
    options___0->gateway_ports = 0;
  }
#line 234
  if (options___0->max_startups == -1) {
#line 235
    options___0->max_startups = 10;
  }
#line 236
  if (options___0->max_startups_rate == -1) {
#line 237
    options___0->max_startups_rate = 100;
  }
#line 238
  if (options___0->max_startups_begin == -1) {
#line 239
    options___0->max_startups_begin = options___0->max_startups;
  }
#line 240
  if (options___0->verify_reverse_mapping == -1) {
#line 241
    options___0->verify_reverse_mapping = 0;
  }
#line 242
  if (options___0->client_alive_interval == -1) {
#line 243
    options___0->client_alive_interval = 0;
  }
#line 244
  if (options___0->client_alive_count_max == -1) {
#line 245
    options___0->client_alive_count_max = 3;
  }
#line 246
  if ((unsigned int )options___0->authorized_keys_file2 == (unsigned int )((void *)0)) {
#line 248
    if ((unsigned int )options___0->authorized_keys_file != (unsigned int )((void *)0)) {
#line 249
      options___0->authorized_keys_file2 = options___0->authorized_keys_file;
    } else {
#line 251
      options___0->authorized_keys_file2 = (char *)".ssh/authorized_keys2";
    }
  }
#line 253
  if ((unsigned int )options___0->authorized_keys_file == (unsigned int )((void *)0)) {
#line 254
    options___0->authorized_keys_file = (char *)".ssh/authorized_keys";
  }
#line 257
  if (use_privsep == -1) {
#line 258
    use_privsep = 1;
  }
#line 269
  return;
}
}
#line 306 "servconf.c"
static struct __anonstruct_keywords_72 keywords[57]  = 
#line 306
  {      {"PAMAuthenticationViaKbdInt", 1}, 
        {"port", 2}, 
        {"hostkey", 3}, 
        {"hostdsakey", 3}, 
        {"pidfile", 37}, 
        {"serverkeybits", 4}, 
        {"logingracetime", 5}, 
        {"keyregenerationinterval", 6}, 
        {"permitrootlogin", 7}, 
        {"syslogfacility", 8}, 
        {"loglevel", 9}, 
        {"rhostsauthentication", 10}, 
        {"rhostsrsaauthentication", 11}, 
        {"hostbasedauthentication", 45}, 
        {"hostbasedusesnamefrompacketonly", 46}, 
        {"rsaauthentication", 12}, 
        {"pubkeyauthentication", 39}, 
        {"dsaauthentication", 39}, 
        {"passwordauthentication", 14}, 
        {"kbdinteractiveauthentication", 15}, 
        {"challengeresponseauthentication", 13}, 
        {"skeyauthentication", 13}, 
        {"checkmail", 52}, 
        {"listenaddress", 16}, 
        {"printmotd", 17}, 
        {"printlastlog", 18}, 
        {"ignorerhosts", 19}, 
        {"ignoreuserknownhosts", 33}, 
        {"x11forwarding", 20}, 
        {"x11displayoffset", 21}, 
        {"x11uselocalhost", 22}, 
        {"xauthlocation", 40}, 
        {"strictmodes", 23}, 
        {"permitemptypasswords", 24}, 
        {"uselogin", 26}, 
        {"compression", 28}, 
        {"keepalive", 25}, 
        {"allowtcpforwarding", 27}, 
        {"allowusers", 29}, 
        {"denyusers", 30}, 
        {"allowgroups", 31}, 
        {"denygroups", 32}, 
        {"ciphers", 34}, 
        {"macs", 35}, 
        {"protocol", 36}, 
        {"gatewayports", 38}, 
        {"subsystem", 41}, 
        {"maxstartups", 42}, 
        {"banner", 43}, 
        {"verifyreversemapping", 44}, 
        {"reversemappingcheck", 44}, 
        {"clientaliveinterval", 47}, 
        {"clientalivecountmax", 48}, 
        {"authorizedkeysfile", 49}, 
        {"authorizedkeysfile2", 50}, 
        {"useprivilegeseparation", 51}, 
        {(char const   *)((void *)0), 0}};
#line 386 "servconf.c"
static ServerOpCodes parse_token(char const   *cp , char const   *filename , int linenum ) 
{ u_int i ;
  int tmp ;

  {
#line 392
  i = 0U;
#line 392
  while (keywords[i].name) {
#line 393
    tmp = strcasecmp(cp, keywords[i].name);
#line 393
    if (tmp == 0) {
#line 394
      return (keywords[i].opcode);
    }
#line 392
    i ++;
  }
#line 396
  error("%s: line %d: Bad configuration option: %s", filename, linenum, cp);
#line 398
  return (0);
}
}
#line 401 "servconf.c"
static void add_listen_addr(ServerOptions *options___0 , char *addr , u_short port ) 
{ int i ;
  u_int tmp ;

  {
#line 406
  if (options___0->num_ports == 0U) {
#line 407
    tmp = options___0->num_ports;
#line 407
    (options___0->num_ports) ++;
#line 407
    options___0->ports[tmp] = (unsigned short)22;
  }
#line 408
  if ((int )port == 0) {
#line 409
    i = 0;
#line 409
    while ((u_int )i < options___0->num_ports) {
#line 410
      add_one_listen_addr(options___0, addr, options___0->ports[i]);
#line 409
      i ++;
    }
  } else {
#line 412
    add_one_listen_addr(options___0, addr, port);
  }
#line 413
  return;
}
}
#line 415 "servconf.c"
static void add_one_listen_addr(ServerOptions *options___0 , char *addr , u_short port ) 
{ struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 422
  memset((void *)(& hints), 0, sizeof(hints));
#line 423
  hints.ai_family = IPv4or6;
#line 424
  hints.ai_socktype = 1;
#line 425
  if ((unsigned int )addr == (unsigned int )((void *)0)) {
#line 425
    hints.ai_flags = 1;
  } else {
#line 425
    hints.ai_flags = 0;
  }
#line 426
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%u",
           port);
#line 427
  gaierr = getaddrinfo((char const   * __restrict  )addr, (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 427
  if (gaierr != 0) {
#line 428
    tmp = gai_strerror(gaierr);
#line 428
    if (addr) {
#line 428
      tmp___0 = (char const   *)addr;
    } else {
#line 428
      tmp___0 = "<NULL>";
    }
#line 428
    fatal("bad addr or host: %s (%s)", tmp___0, tmp);
  }
#line 431
  ai = aitop;
#line 431
  while (ai->ai_next) {
#line 431
    ai = ai->ai_next;
  }
#line 433
  ai->ai_next = options___0->listen_addrs;
#line 434
  options___0->listen_addrs = aitop;
#line 435
  return;
}
}
#line 437 "servconf.c"
int process_server_config_line(ServerOptions *options___0 , char *line , char const   *filename ,
                               int linenum ) 
{ char *cp ;
  char **charptr ;
  char *arg ;
  char *p ;
  int *intptr ;
  int value ;
  int i ;
  int n___0 ;
  ServerOpCodes opcode ;
  u_int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___29 ;
  size_t tmp___30 ;
  char *tmp___32 ;
  char *tmp___34 ;
  u_short port ;
  int tmp___35 ;
  __uid_t tmp___36 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___42 ;
  int tmp___45 ;
  int tmp___46 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___52 ;
  int tmp___55 ;
  int tmp___56 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___62 ;
  int tmp___65 ;
  int tmp___66 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___72 ;
  int tmp___75 ;
  int tmp___76 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___82 ;
  int tmp___85 ;
  int tmp___86 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___92 ;
  int tmp___95 ;
  int tmp___96 ;
  SyslogFacility tmp___97 ;
  char const   *tmp___98 ;
  LogLevel tmp___99 ;
  char const   *tmp___100 ;
  u_int tmp___101 ;
  u_int tmp___102 ;
  u_int tmp___103 ;
  u_int tmp___104 ;
  char const   *tmp___105 ;
  int tmp___106 ;
  char const   *tmp___107 ;
  int tmp___108 ;
  char const   *tmp___109 ;
  size_t __s1_len___7 ;
  size_t __s2_len___7 ;
  int tmp___115 ;
  int tmp___118 ;
  int tmp___119 ;

  {
#line 445
  cp = line;
#line 446
  arg = strdelim(& cp);
#line 448
  if ((int )*arg == 0) {
#line 449
    arg = strdelim(& cp);
  }
#line 450
  if (! arg) {
#line 451
    return (0);
  } else {
#line 450
    if (! *arg) {
#line 451
      return (0);
    } else {
#line 450
      if ((int )*arg == 35) {
#line 451
        return (0);
      }
    }
  }
#line 452
  intptr = (int *)((void *)0);
#line 453
  charptr = (char **)((void *)0);
#line 454
  opcode = parse_token((char const   *)arg, filename, linenum);
#line 455
  switch ((int )opcode) {
  case 1: 
#line 458
  intptr = & options___0->pam_authentication_via_kbd_int;
  goto parse_flag;
  case 0: 
#line 463
  return (-1);
  case 2: 
#line 466
  if (options___0->ports_from_cmdline) {
#line 467
    return (0);
  }
#line 468
  if ((unsigned int )options___0->listen_addrs != (unsigned int )((void *)0)) {
#line 469
    fatal("%s line %d: ports must be specified before ListenAddress.", filename, linenum);
  }
#line 471
  if (options___0->num_ports >= 256U) {
#line 472
    fatal("%s line %d: too many ports.", filename, linenum);
  }
#line 474
  arg = strdelim(& cp);
#line 475
  if (! arg) {
#line 476
    fatal("%s line %d: missing port number.", filename, linenum);
  } else {
#line 475
    if ((int )*arg == 0) {
#line 476
      fatal("%s line %d: missing port number.", filename, linenum);
    }
  }
#line 478
  tmp = options___0->num_ports;
#line 478
  (options___0->num_ports) ++;
#line 478
  tmp___0 = a2port((char const   *)arg);
#line 478
  options___0->ports[tmp] = (unsigned short )tmp___0;
#line 479
  if ((int )options___0->ports[options___0->num_ports - 1U] == 0) {
#line 480
    fatal("%s line %d: Badly formatted port number.", filename, linenum);
  }
#line 482
  break;
  case 4: 
#line 485
  intptr = & options___0->server_key_bits;
  parse_int: 
#line 487
  arg = strdelim(& cp);
#line 488
  if (! arg) {
#line 489
    fatal("%s line %d: missing integer value.", filename, linenum);
  } else {
#line 488
    if ((int )*arg == 0) {
#line 489
      fatal("%s line %d: missing integer value.", filename, linenum);
    }
  }
#line 491
  value = atoi((char const   *)arg);
#line 492
  if (*intptr == -1) {
#line 493
    *intptr = value;
  }
#line 494
  break;
  case 5: 
#line 497
  intptr = & options___0->login_grace_time;
  parse_time: 
#line 499
  arg = strdelim(& cp);
#line 500
  if (! arg) {
#line 501
    fatal("%s line %d: missing time value.", filename, linenum);
  } else {
#line 500
    if ((int )*arg == 0) {
#line 501
      fatal("%s line %d: missing time value.", filename, linenum);
    }
  }
#line 503
  tmp___1 = convtime((char const   *)arg);
#line 503
  value = (int )tmp___1;
#line 503
  if (value == -1) {
#line 504
    fatal("%s line %d: invalid time value.", filename, linenum);
  }
#line 506
  if (*intptr == -1) {
#line 507
    *intptr = value;
  }
#line 508
  break;
  case 6: 
#line 511
  intptr = & options___0->key_regeneration_time;
  goto parse_time;
  case 16: 
#line 515
  arg = strdelim(& cp);
#line 516
  if (! arg) {
#line 517
    fatal("%s line %d: missing inet addr.", filename, linenum);
  } else {
#line 516
    if ((int )*arg == 0) {
#line 517
      fatal("%s line %d: missing inet addr.", filename, linenum);
    } else {
#line 516
      if (0) {
#line 516
        if (0) {
#line 516
          __s1_len___0 = strlen((char const   *)arg);
#line 516
          __s2_len___0 = strlen("[]");
#line 516
          if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
            goto _L___2;
          } else {
#line 516
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 516
              if (! ((unsigned int )((void const   *)("[]" + 1)) - (unsigned int )((void const   *)"[]") == 1U)) {
#line 516
                tmp___25 = 1;
              } else {
#line 516
                if (__s2_len___0 >= 4U) {
#line 516
                  tmp___25 = 1;
                } else {
#line 516
                  tmp___25 = 0;
                }
              }
            } else {
#line 516
              tmp___25 = 0;
            }
          }
#line 516
          if (tmp___25) {
#line 516
            tmp___21 = __builtin_strcmp((char const   *)arg, "[]");
          } else {
#line 516
            tmp___24 = __builtin_strcmp((char const   *)arg, "[]");
#line 516
            tmp___21 = tmp___24;
          }
        } else {
#line 516
          tmp___24 = __builtin_strcmp((char const   *)arg, "[]");
#line 516
          tmp___21 = tmp___24;
        }
#line 516
        tmp___15 = tmp___21;
      } else {
#line 516
        tmp___15 = strncmp((char const   *)arg, "[]", 2U);
      }
#line 516
      if (tmp___15 == 0) {
#line 517
        fatal("%s line %d: missing inet addr.", filename, linenum);
      }
    }
  }
#line 519
  if ((int )*arg == 91) {
#line 520
    tmp___29 = __builtin_strchr(arg, ']');
#line 520
    p = tmp___29;
#line 520
    if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 521
      fatal("%s line %d: bad ipv6 inet addr usage.", filename, linenum);
    }
#line 523
    arg ++;
#line 524
    tmp___30 = strlen((char const   *)(p + 1));
#line 524
    memmove((void *)p, (void const   *)(p + 1), tmp___30 + 1U);
  } else {
#line 525
    tmp___32 = __builtin_strchr(arg, ':');
#line 525
    p = tmp___32;
#line 525
    if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 527
      add_listen_addr(options___0, arg, (unsigned short)0);
#line 528
      break;
    } else {
#line 525
      tmp___34 = __builtin_strchr(p + 1, ':');
#line 525
      if ((unsigned int )tmp___34 != (unsigned int )((void *)0)) {
#line 527
        add_listen_addr(options___0, arg, (unsigned short)0);
#line 528
        break;
      }
    }
  }
#line 530
  if ((int )*p == 58) {
#line 533
    p ++;
#line 534
    if ((int )*p == 0) {
#line 535
      fatal("%s line %d: bad inet addr:port usage.", filename, linenum);
    } else {
#line 538
      *(p - 1) = (char )'\000';
#line 539
      tmp___35 = a2port((char const   *)p);
#line 539
      port = (unsigned short )tmp___35;
#line 539
      if ((int )port == 0) {
#line 540
        fatal("%s line %d: bad port number.", filename, linenum);
      }
#line 542
      add_listen_addr(options___0, arg, port);
    }
  } else {
#line 544
    if ((int )*p == 0) {
#line 545
      add_listen_addr(options___0, arg, (unsigned short)0);
    } else {
#line 547
      fatal("%s line %d: bad inet addr usage.", filename, linenum);
    }
  }
#line 549
  break;
  case 3: 
#line 552
  intptr = & options___0->num_host_key_files;
#line 553
  if (*intptr >= 256) {
#line 554
    fatal("%s line %d: too many host keys specified (max %d).", filename, linenum,
          256);
  }
#line 556
  charptr = & options___0->host_key_files[*intptr];
  parse_filename: 
#line 558
  arg = strdelim(& cp);
#line 559
  if (! arg) {
#line 560
    fatal("%s line %d: missing file name.", filename, linenum);
  } else {
#line 559
    if ((int )*arg == 0) {
#line 560
      fatal("%s line %d: missing file name.", filename, linenum);
    }
  }
#line 562
  if ((unsigned int )*charptr == (unsigned int )((void *)0)) {
#line 563
    tmp___36 = getuid();
#line 563
    *charptr = tilde_expand_filename((char const   *)arg, tmp___36);
#line 565
    if ((unsigned int )intptr != (unsigned int )((void *)0)) {
#line 566
      (*intptr) ++;
    }
  }
#line 568
  break;
  case 37: 
#line 571
  charptr = & options___0->pid_file;
  goto parse_filename;
  case 7: 
#line 575
  intptr = & options___0->permit_root_login;
#line 576
  arg = strdelim(& cp);
#line 577
  if (! arg) {
#line 578
    fatal("%s line %d: missing yes/without-password/forced-commands-only/no argument.",
          filename, linenum);
  } else {
#line 577
    if ((int )*arg == 0) {
#line 578
      fatal("%s line %d: missing yes/without-password/forced-commands-only/no argument.",
            filename, linenum);
    }
  }
#line 581
  value = 0;
#line 582
  if (0) {
#line 582
    __s1_len___4 = strlen((char const   *)arg);
#line 582
    __s2_len___4 = strlen("without-password");
#line 582
    if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
      goto _L___10;
    } else {
#line 582
      if (__s1_len___4 >= 4U) {
        _L___10: /* CIL Label */ 
#line 582
        if (! ((unsigned int )((void const   *)("without-password" + 1)) - (unsigned int )((void const   *)"without-password") == 1U)) {
#line 582
          tmp___76 = 1;
        } else {
#line 582
          if (__s2_len___4 >= 4U) {
#line 582
            tmp___76 = 1;
          } else {
#line 582
            tmp___76 = 0;
          }
        }
      } else {
#line 582
        tmp___76 = 0;
      }
    }
#line 582
    if (tmp___76) {
#line 582
      tmp___72 = __builtin_strcmp((char const   *)arg, "without-password");
    } else {
#line 582
      tmp___75 = __builtin_strcmp((char const   *)arg, "without-password");
#line 582
      tmp___72 = tmp___75;
    }
  } else {
#line 582
    tmp___75 = __builtin_strcmp((char const   *)arg, "without-password");
#line 582
    tmp___72 = tmp___75;
  }
#line 582
  if (tmp___72 == 0) {
#line 583
    value = 2;
  } else {
#line 584
    if (0) {
#line 584
      __s1_len___3 = strlen((char const   *)arg);
#line 584
      __s2_len___3 = strlen("forced-commands-only");
#line 584
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___8;
      } else {
#line 584
        if (__s1_len___3 >= 4U) {
          _L___8: /* CIL Label */ 
#line 584
          if (! ((unsigned int )((void const   *)("forced-commands-only" + 1)) - (unsigned int )((void const   *)"forced-commands-only") == 1U)) {
#line 584
            tmp___66 = 1;
          } else {
#line 584
            if (__s2_len___3 >= 4U) {
#line 584
              tmp___66 = 1;
            } else {
#line 584
              tmp___66 = 0;
            }
          }
        } else {
#line 584
          tmp___66 = 0;
        }
      }
#line 584
      if (tmp___66) {
#line 584
        tmp___62 = __builtin_strcmp((char const   *)arg, "forced-commands-only");
      } else {
#line 584
        tmp___65 = __builtin_strcmp((char const   *)arg, "forced-commands-only");
#line 584
        tmp___62 = tmp___65;
      }
    } else {
#line 584
      tmp___65 = __builtin_strcmp((char const   *)arg, "forced-commands-only");
#line 584
      tmp___62 = tmp___65;
    }
#line 584
    if (tmp___62 == 0) {
#line 585
      value = 1;
    } else {
#line 586
      if (0) {
#line 586
        __s1_len___2 = strlen((char const   *)arg);
#line 586
        __s2_len___2 = strlen("yes");
#line 586
        if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
          goto _L___6;
        } else {
#line 586
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 586
            if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 586
              tmp___56 = 1;
            } else {
#line 586
              if (__s2_len___2 >= 4U) {
#line 586
                tmp___56 = 1;
              } else {
#line 586
                tmp___56 = 0;
              }
            }
          } else {
#line 586
            tmp___56 = 0;
          }
        }
#line 586
        if (tmp___56) {
#line 586
          tmp___52 = __builtin_strcmp((char const   *)arg, "yes");
        } else {
#line 586
          tmp___55 = __builtin_strcmp((char const   *)arg, "yes");
#line 586
          tmp___52 = tmp___55;
        }
      } else {
#line 586
        tmp___55 = __builtin_strcmp((char const   *)arg, "yes");
#line 586
        tmp___52 = tmp___55;
      }
#line 586
      if (tmp___52 == 0) {
#line 587
        value = 3;
      } else {
#line 588
        if (0) {
#line 588
          __s1_len___1 = strlen((char const   *)arg);
#line 588
          __s2_len___1 = strlen("no");
#line 588
          if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
            goto _L___4;
          } else {
#line 588
            if (__s1_len___1 >= 4U) {
              _L___4: /* CIL Label */ 
#line 588
              if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 588
                tmp___46 = 1;
              } else {
#line 588
                if (__s2_len___1 >= 4U) {
#line 588
                  tmp___46 = 1;
                } else {
#line 588
                  tmp___46 = 0;
                }
              }
            } else {
#line 588
              tmp___46 = 0;
            }
          }
#line 588
          if (tmp___46) {
#line 588
            tmp___42 = __builtin_strcmp((char const   *)arg, "no");
          } else {
#line 588
            tmp___45 = __builtin_strcmp((char const   *)arg, "no");
#line 588
            tmp___42 = tmp___45;
          }
        } else {
#line 588
          tmp___45 = __builtin_strcmp((char const   *)arg, "no");
#line 588
          tmp___42 = tmp___45;
        }
#line 588
        if (tmp___42 == 0) {
#line 589
          value = 0;
        } else {
#line 591
          fatal("%s line %d: Bad yes/without-password/forced-commands-only/no argument: %s",
                filename, linenum, arg);
        }
      }
    }
  }
#line 594
  if (*intptr == -1) {
#line 595
    *intptr = value;
  }
#line 596
  break;
  case 19: 
#line 599
  intptr = & options___0->ignore_rhosts;
  parse_flag: 
#line 601
  arg = strdelim(& cp);
#line 602
  if (! arg) {
#line 603
    fatal("%s line %d: missing yes/no argument.", filename, linenum);
  } else {
#line 602
    if ((int )*arg == 0) {
#line 603
      fatal("%s line %d: missing yes/no argument.", filename, linenum);
    }
  }
#line 605
  value = 0;
#line 606
  if (0) {
#line 606
    __s1_len___6 = strlen((char const   *)arg);
#line 606
    __s2_len___6 = strlen("yes");
#line 606
    if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
      goto _L___14;
    } else {
#line 606
      if (__s1_len___6 >= 4U) {
        _L___14: /* CIL Label */ 
#line 606
        if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 606
          tmp___96 = 1;
        } else {
#line 606
          if (__s2_len___6 >= 4U) {
#line 606
            tmp___96 = 1;
          } else {
#line 606
            tmp___96 = 0;
          }
        }
      } else {
#line 606
        tmp___96 = 0;
      }
    }
#line 606
    if (tmp___96) {
#line 606
      tmp___92 = __builtin_strcmp((char const   *)arg, "yes");
    } else {
#line 606
      tmp___95 = __builtin_strcmp((char const   *)arg, "yes");
#line 606
      tmp___92 = tmp___95;
    }
  } else {
#line 606
    tmp___95 = __builtin_strcmp((char const   *)arg, "yes");
#line 606
    tmp___92 = tmp___95;
  }
#line 606
  if (tmp___92 == 0) {
#line 607
    value = 1;
  } else {
#line 608
    if (0) {
#line 608
      __s1_len___5 = strlen((char const   *)arg);
#line 608
      __s2_len___5 = strlen("no");
#line 608
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___12;
      } else {
#line 608
        if (__s1_len___5 >= 4U) {
          _L___12: /* CIL Label */ 
#line 608
          if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 608
            tmp___86 = 1;
          } else {
#line 608
            if (__s2_len___5 >= 4U) {
#line 608
              tmp___86 = 1;
            } else {
#line 608
              tmp___86 = 0;
            }
          }
        } else {
#line 608
          tmp___86 = 0;
        }
      }
#line 608
      if (tmp___86) {
#line 608
        tmp___82 = __builtin_strcmp((char const   *)arg, "no");
      } else {
#line 608
        tmp___85 = __builtin_strcmp((char const   *)arg, "no");
#line 608
        tmp___82 = tmp___85;
      }
    } else {
#line 608
      tmp___85 = __builtin_strcmp((char const   *)arg, "no");
#line 608
      tmp___82 = tmp___85;
    }
#line 608
    if (tmp___82 == 0) {
#line 609
      value = 0;
    } else {
#line 611
      fatal("%s line %d: Bad yes/no argument: %s", filename, linenum, arg);
    }
  }
#line 613
  if (*intptr == -1) {
#line 614
    *intptr = value;
  }
#line 615
  break;
  case 33: 
#line 618
  intptr = & options___0->ignore_user_known_hosts;
  goto parse_flag;
  case 10: 
#line 622
  intptr = & options___0->rhosts_authentication;
  goto parse_flag;
  case 11: 
#line 626
  intptr = & options___0->rhosts_rsa_authentication;
  goto parse_flag;
  case 45: 
#line 630
  intptr = & options___0->hostbased_authentication;
  goto parse_flag;
  case 46: 
#line 634
  intptr = & options___0->hostbased_uses_name_from_packet_only;
  goto parse_flag;
  case 12: 
#line 638
  intptr = & options___0->rsa_authentication;
  goto parse_flag;
  case 39: 
#line 642
  intptr = & options___0->pubkey_authentication;
  goto parse_flag;
  case 14: 
#line 669
  intptr = & options___0->password_authentication;
  goto parse_flag;
  case 15: 
#line 673
  intptr = & options___0->kbd_interactive_authentication;
  goto parse_flag;
  case 13: 
#line 677
  intptr = & options___0->challenge_response_authentication;
  goto parse_flag;
  case 17: 
#line 681
  intptr = & options___0->print_motd;
  goto parse_flag;
  case 18: 
#line 685
  intptr = & options___0->print_lastlog;
  goto parse_flag;
  case 20: 
#line 689
  intptr = & options___0->x11_forwarding;
  goto parse_flag;
  case 21: 
#line 693
  intptr = & options___0->x11_display_offset;
  goto parse_int;
  case 22: 
#line 697
  intptr = & options___0->x11_use_localhost;
  goto parse_flag;
  case 40: 
#line 701
  charptr = & options___0->xauth_location;
  goto parse_filename;
  case 23: 
#line 705
  intptr = & options___0->strict_modes;
  goto parse_flag;
  case 25: 
#line 709
  intptr = & options___0->keepalives;
  goto parse_flag;
  case 24: 
#line 713
  intptr = & options___0->permit_empty_passwd;
  goto parse_flag;
  case 26: 
#line 717
  intptr = & options___0->use_login;
  goto parse_flag;
  case 28: 
#line 721
  intptr = & options___0->compression;
  goto parse_flag;
  case 38: 
#line 725
  intptr = & options___0->gateway_ports;
  goto parse_flag;
  case 44: 
#line 729
  intptr = & options___0->verify_reverse_mapping;
  goto parse_flag;
  case 8: 
#line 733
  intptr = (int *)(& options___0->log_facility);
#line 734
  arg = strdelim(& cp);
#line 735
  tmp___97 = log_facility_number(arg);
#line 735
  value = (int )tmp___97;
#line 736
  if (value == -1) {
#line 737
    if (arg) {
#line 737
      tmp___98 = (char const   *)arg;
    } else {
#line 737
      tmp___98 = "<NONE>";
    }
#line 737
    fatal("%.200s line %d: unsupported log facility \'%s\'", filename, linenum, tmp___98);
  }
#line 739
  if (*intptr == -1) {
#line 740
    *intptr = (int )((enum __anonenum_SyslogFacility_63 )value);
  }
#line 741
  break;
  case 9: 
#line 744
  intptr = (int *)(& options___0->log_level);
#line 745
  arg = strdelim(& cp);
#line 746
  tmp___99 = log_level_number(arg);
#line 746
  value = (int )tmp___99;
#line 747
  if (value == -1) {
#line 748
    if (arg) {
#line 748
      tmp___100 = (char const   *)arg;
    } else {
#line 748
      tmp___100 = "<NONE>";
    }
#line 748
    fatal("%.200s line %d: unsupported log level \'%s\'", filename, linenum, tmp___100);
  }
#line 750
  if (*intptr == -1) {
#line 751
    *intptr = (int )((enum __anonenum_LogLevel_64 )value);
  }
#line 752
  break;
  case 27: 
#line 755
  intptr = & options___0->allow_tcp_forwarding;
  goto parse_flag;
  case 51: 
#line 759
  intptr = & use_privsep;
  goto parse_flag;
  case 29: 
#line 763
  while (1) {
#line 763
    arg = strdelim(& cp);
#line 763
    if (arg) {
#line 763
      if (! ((int )*arg != 0)) {
#line 763
        break;
      }
    } else {
#line 763
      break;
    }
#line 764
    if (options___0->num_allow_users >= 256U) {
#line 765
      fatal("%s line %d: too many allow users.", filename, linenum);
    }
#line 767
    tmp___101 = options___0->num_allow_users;
#line 767
    (options___0->num_allow_users) ++;
#line 767
    options___0->allow_users[tmp___101] = xstrdup((char const   *)arg);
  }
#line 770
  break;
  case 30: 
#line 773
  while (1) {
#line 773
    arg = strdelim(& cp);
#line 773
    if (arg) {
#line 773
      if (! ((int )*arg != 0)) {
#line 773
        break;
      }
    } else {
#line 773
      break;
    }
#line 774
    if (options___0->num_deny_users >= 256U) {
#line 775
      fatal("%s line %d: too many deny users.", filename, linenum);
    }
#line 777
    tmp___102 = options___0->num_deny_users;
#line 777
    (options___0->num_deny_users) ++;
#line 777
    options___0->deny_users[tmp___102] = xstrdup((char const   *)arg);
  }
#line 780
  break;
  case 31: 
#line 783
  while (1) {
#line 783
    arg = strdelim(& cp);
#line 783
    if (arg) {
#line 783
      if (! ((int )*arg != 0)) {
#line 783
        break;
      }
    } else {
#line 783
      break;
    }
#line 784
    if (options___0->num_allow_groups >= 256U) {
#line 785
      fatal("%s line %d: too many allow groups.", filename, linenum);
    }
#line 787
    tmp___103 = options___0->num_allow_groups;
#line 787
    (options___0->num_allow_groups) ++;
#line 787
    options___0->allow_groups[tmp___103] = xstrdup((char const   *)arg);
  }
#line 790
  break;
  case 32: 
#line 793
  while (1) {
#line 793
    arg = strdelim(& cp);
#line 793
    if (arg) {
#line 793
      if (! ((int )*arg != 0)) {
#line 793
        break;
      }
    } else {
#line 793
      break;
    }
#line 794
    if (options___0->num_deny_groups >= 256U) {
#line 795
      fatal("%s line %d: too many deny groups.", filename, linenum);
    }
#line 797
    tmp___104 = options___0->num_deny_groups;
#line 797
    (options___0->num_deny_groups) ++;
#line 797
    options___0->deny_groups[tmp___104] = xstrdup((char const   *)arg);
  }
#line 799
  break;
  case 34: 
#line 802
  arg = strdelim(& cp);
#line 803
  if (! arg) {
#line 804
    fatal("%s line %d: Missing argument.", filename, linenum);
  } else {
#line 803
    if ((int )*arg == 0) {
#line 804
      fatal("%s line %d: Missing argument.", filename, linenum);
    }
  }
#line 805
  tmp___106 = ciphers_valid((char const   *)arg);
#line 805
  if (! tmp___106) {
#line 806
    if (arg) {
#line 806
      tmp___105 = (char const   *)arg;
    } else {
#line 806
      tmp___105 = "<NONE>";
    }
#line 806
    fatal("%s line %d: Bad SSH2 cipher spec \'%s\'.", filename, linenum, tmp___105);
  }
#line 808
  if ((unsigned int )options___0->ciphers == (unsigned int )((void *)0)) {
#line 809
    options___0->ciphers = xstrdup((char const   *)arg);
  }
#line 810
  break;
  case 35: 
#line 813
  arg = strdelim(& cp);
#line 814
  if (! arg) {
#line 815
    fatal("%s line %d: Missing argument.", filename, linenum);
  } else {
#line 814
    if ((int )*arg == 0) {
#line 815
      fatal("%s line %d: Missing argument.", filename, linenum);
    }
  }
#line 816
  tmp___108 = mac_valid((char const   *)arg);
#line 816
  if (! tmp___108) {
#line 817
    if (arg) {
#line 817
      tmp___107 = (char const   *)arg;
    } else {
#line 817
      tmp___107 = "<NONE>";
    }
#line 817
    fatal("%s line %d: Bad SSH2 mac spec \'%s\'.", filename, linenum, tmp___107);
  }
#line 819
  if ((unsigned int )options___0->macs == (unsigned int )((void *)0)) {
#line 820
    options___0->macs = xstrdup((char const   *)arg);
  }
#line 821
  break;
  case 36: 
#line 824
  intptr = & options___0->protocol;
#line 825
  arg = strdelim(& cp);
#line 826
  if (! arg) {
#line 827
    fatal("%s line %d: Missing argument.", filename, linenum);
  } else {
#line 826
    if ((int )*arg == 0) {
#line 827
      fatal("%s line %d: Missing argument.", filename, linenum);
    }
  }
#line 828
  value = proto_spec((char const   *)arg);
#line 829
  if (value == 0) {
#line 830
    if (arg) {
#line 830
      tmp___109 = (char const   *)arg;
    } else {
#line 830
      tmp___109 = "<NONE>";
    }
#line 830
    fatal("%s line %d: Bad protocol spec \'%s\'.", filename, linenum, tmp___109);
  }
#line 832
  if (*intptr == 0) {
#line 833
    *intptr = value;
  }
#line 834
  break;
  case 41: 
#line 837
  if (options___0->num_subsystems >= 256U) {
#line 838
    fatal("%s line %d: too many subsystems defined.", filename, linenum);
  }
#line 841
  arg = strdelim(& cp);
#line 842
  if (! arg) {
#line 843
    fatal("%s line %d: Missing subsystem name.", filename, linenum);
  } else {
#line 842
    if ((int )*arg == 0) {
#line 843
      fatal("%s line %d: Missing subsystem name.", filename, linenum);
    }
  }
#line 845
  i = 0;
#line 845
  while ((u_int )i < options___0->num_subsystems) {
#line 846
    if (0) {
#line 846
      __s1_len___7 = strlen((char const   *)arg);
#line 846
      __s2_len___7 = strlen((char const   *)options___0->subsystem_name[i]);
#line 846
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___16;
      } else {
#line 846
        if (__s1_len___7 >= 4U) {
          _L___16: /* CIL Label */ 
#line 846
          if (! ((unsigned int )((void const   *)(options___0->subsystem_name[i] + 1)) - (unsigned int )((void const   *)options___0->subsystem_name[i]) == 1U)) {
#line 846
            tmp___119 = 1;
          } else {
#line 846
            if (__s2_len___7 >= 4U) {
#line 846
              tmp___119 = 1;
            } else {
#line 846
              tmp___119 = 0;
            }
          }
        } else {
#line 846
          tmp___119 = 0;
        }
      }
#line 846
      if (tmp___119) {
#line 846
        tmp___115 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
      } else {
#line 846
        tmp___118 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
#line 846
        tmp___115 = tmp___118;
      }
    } else {
#line 846
      tmp___118 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
#line 846
      tmp___115 = tmp___118;
    }
#line 846
    if (tmp___115 == 0) {
#line 847
      fatal("%s line %d: Subsystem \'%s\' already defined.", filename, linenum, arg);
    }
#line 845
    i ++;
  }
#line 849
  options___0->subsystem_name[options___0->num_subsystems] = xstrdup((char const   *)arg);
#line 850
  arg = strdelim(& cp);
#line 851
  if (! arg) {
#line 852
    fatal("%s line %d: Missing subsystem command.", filename, linenum);
  } else {
#line 851
    if ((int )*arg == 0) {
#line 852
      fatal("%s line %d: Missing subsystem command.", filename, linenum);
    }
  }
#line 854
  options___0->subsystem_command[options___0->num_subsystems] = xstrdup((char const   *)arg);
#line 855
  (options___0->num_subsystems) ++;
#line 856
  break;
  case 42: 
#line 859
  arg = strdelim(& cp);
#line 860
  if (! arg) {
#line 861
    fatal("%s line %d: Missing MaxStartups spec.", filename, linenum);
  } else {
#line 860
    if ((int )*arg == 0) {
#line 861
      fatal("%s line %d: Missing MaxStartups spec.", filename, linenum);
    }
  }
#line 863
  n___0 = sscanf((char const   * __restrict  )arg, (char const   * __restrict  )"%d:%d:%d",
                 & options___0->max_startups_begin, & options___0->max_startups_rate,
                 & options___0->max_startups);
#line 863
  if (n___0 == 3) {
#line 867
    if (options___0->max_startups_begin > options___0->max_startups) {
#line 871
      fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
    } else {
#line 867
      if (options___0->max_startups_rate > 100) {
#line 871
        fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
      } else {
#line 867
        if (options___0->max_startups_rate < 1) {
#line 871
          fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
        }
      }
    }
  } else {
#line 873
    if (n___0 != 1) {
#line 874
      fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
    } else {
#line 877
      options___0->max_startups = options___0->max_startups_begin;
    }
  }
#line 878
  break;
  case 43: 
#line 881
  charptr = & options___0->banner;
  goto parse_filename;
  case 49: 
  case 50: 
#line 891
  if ((int )opcode == 49) {
#line 891
    charptr = & options___0->authorized_keys_file;
  } else {
#line 891
    charptr = & options___0->authorized_keys_file2;
  }
  goto parse_filename;
  case 47: 
#line 897
  intptr = & options___0->client_alive_interval;
  goto parse_time;
  case 48: 
#line 901
  intptr = & options___0->client_alive_count_max;
  goto parse_int;
  case 52: 
#line 905
  log("%s line %d: Deprecated option %s", filename, linenum, arg);
#line 907
  while (arg) {
#line 908
    arg = strdelim(& cp);
  }
#line 909
  break;
  default: 
#line 912
  fatal("%s line %d: Missing handler for opcode %s (%d)", filename, linenum, arg,
        opcode);
  }
#line 915
  arg = strdelim(& cp);
#line 915
  if ((unsigned int )arg != (unsigned int )((void *)0)) {
#line 915
    if ((int )*arg != 0) {
#line 916
      fatal("%s line %d: garbage at end of line; \"%.200s\".", filename, linenum,
            arg);
    }
  }
#line 918
  return (0);
}
}
#line 923 "servconf.c"
void read_server_config(ServerOptions *options___0 , char const   *filename ) 
{ int linenum ;
  int bad_options ;
  char line[1024] ;
  FILE *f ;
  int tmp ;
  char *tmp___0 ;

  {
#line 926
  bad_options = 0;
#line 930
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 931
  if (! f) {
#line 932
    perror(filename);
#line 933
    exit(1);
  }
#line 935
  linenum = 0;
#line 936
  while (1) {
#line 936
    tmp___0 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 936
    if (! tmp___0) {
#line 936
      break;
    }
#line 938
    linenum ++;
#line 939
    tmp = process_server_config_line(options___0, line, filename, linenum);
#line 939
    if (tmp != 0) {
#line 940
      bad_options ++;
    }
  }
#line 942
  fclose(f);
#line 943
  if (bad_options > 0) {
#line 944
    fatal("%s: terminating, %d bad configuration options", filename, bad_options);
  }
#line 946
  return;
}
}
#line 1 "serverloop.o"
#line 222 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo )  __attribute__((__nonnull__(1))) ;
#line 249
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
#line 60 "session.h"
int session_open(Authctxt *authctxt___0 , int chanid ) ;
#line 61
int session_input_channel_req(Channel *c , char const   *rtype ) ;
#line 62
void session_close_by_pid(pid_t pid , int status ) ;
#line 63
void session_close_by_channel(int id , void *arg ) ;
#line 64
void session_destroy_all(void (*closefunc)(Session * ) ) ;
#line 24 "serverloop.h"
void server_loop(pid_t pid , int fdin_arg , int fdout_arg , int fderr_arg ) ;
#line 25
void server_loop2(Authctxt *authctxt___0 ) ;
#line 62 "serverloop.c"
static Authctxt *xxx_authctxt  ;
#line 64 "serverloop.c"
static Buffer stdin_buffer  ;
#line 65 "serverloop.c"
static Buffer stdout_buffer  ;
#line 66 "serverloop.c"
static Buffer stderr_buffer  ;
#line 67 "serverloop.c"
static int fdin  ;
#line 68 "serverloop.c"
static int fdout  ;
#line 70 "serverloop.c"
static int fderr  ;
#line 71 "serverloop.c"
static long stdin_bytes  =    0L;
#line 72 "serverloop.c"
static long stdout_bytes  =    0L;
#line 73 "serverloop.c"
static long stderr_bytes  =    0L;
#line 74 "serverloop.c"
static long fdout_bytes  =    0L;
#line 75 "serverloop.c"
static int stdin_eof  =    0;
#line 76 "serverloop.c"
static int fdout_eof  =    0;
#line 77 "serverloop.c"
static int fderr_eof  =    0;
#line 78 "serverloop.c"
static int fdin_is_tty  =    0;
#line 79 "serverloop.c"
static int connection_in___0  ;
#line 80 "serverloop.c"
static int connection_out___0  ;
#line 81 "serverloop.c"
static int connection_closed  =    0;
#line 82 "serverloop.c"
static u_int buffer_high  ;
#line 83 "serverloop.c"
static int client_alive_timeouts  =    0;
#line 90 "serverloop.c"
static int volatile   child_terminated  =    (sig_atomic_t volatile   )0;
#line 93
static void server_init_dispatch(void) ;
#line 99 "serverloop.c"
static int notify_pipe[2]  ;
#line 100 "serverloop.c"
static void notify_setup(void) 
{ int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 103
  tmp___5 = pipe((int *)(notify_pipe));
#line 103
  if (tmp___5 < 0) {
#line 104
    tmp = __errno_location();
#line 104
    tmp___0 = strerror(*tmp);
#line 104
    error("pipe(notify_pipe) failed %s", tmp___0);
  } else {
#line 105
    tmp___3 = fcntl(notify_pipe[0], 2, 1);
#line 105
    if (tmp___3 == -1) {
#line 107
      tmp___1 = __errno_location();
#line 107
      tmp___2 = strerror(*tmp___1);
#line 107
      error("fcntl(notify_pipe, F_SETFD) failed %s", tmp___2);
#line 108
      close(notify_pipe[0]);
#line 109
      close(notify_pipe[1]);
    } else {
#line 105
      tmp___4 = fcntl(notify_pipe[1], 2, 1);
#line 105
      if (tmp___4 == -1) {
#line 107
        tmp___1 = __errno_location();
#line 107
        tmp___2 = strerror(*tmp___1);
#line 107
        error("fcntl(notify_pipe, F_SETFD) failed %s", tmp___2);
#line 108
        close(notify_pipe[0]);
#line 109
        close(notify_pipe[1]);
      } else {
#line 111
        set_nonblock(notify_pipe[0]);
#line 112
        set_nonblock(notify_pipe[1]);
#line 113
        return;
      }
    }
  }
#line 115
  notify_pipe[0] = -1;
#line 116
  notify_pipe[1] = -1;
#line 117
  return;
}
}
#line 118 "serverloop.c"
static void notify_parent(void) 
{ 

  {
#line 121
  if (notify_pipe[1] != -1) {
#line 122
    write(notify_pipe[1], (void const   *)"", 1U);
  }
#line 123
  return;
}
}
#line 124 "serverloop.c"
static void notify_prepare(fd_set *readset ) 
{ 

  {
#line 127
  if (notify_pipe[0] != -1) {
#line 128
    __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )notify_pipe[0] / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )notify_pipe[0] % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 129
  return;
}
}
#line 130 "serverloop.c"
static void notify_done(fd_set *readset ) 
{ char c ;
  ssize_t tmp ;
  register char __result ;

  {
#line 135
  if (notify_pipe[0] != -1) {
#line 135
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )notify_pipe[0] % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )notify_pipe[0] / (8U * sizeof(__fd_mask ))]): "cc");
#line 135
    if (__result) {
#line 136
      while (1) {
#line 136
        tmp = read(notify_pipe[0], (void *)(& c), 1U);
#line 136
        if (! (tmp != -1)) {
#line 136
          break;
        }
#line 137
        debug2("notify_done: reading");
      }
    }
  }
#line 138
  return;
}
}
#line 140 "serverloop.c"
static void sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 143
  tmp = __errno_location();
#line 143
  save_errno = *tmp;
#line 144
  debug("Received SIGCHLD.");
#line 145
  child_terminated = (int volatile   )1;
#line 146
  mysignal(17, & sigchld_handler);
#line 147
  notify_parent();
#line 148
  tmp___0 = __errno_location();
#line 148
  *tmp___0 = save_errno;
#line 149
  return;
}
}
#line 155 "serverloop.c"
static void make_packets_from_stderr_data(void) 
{ int len ;
  u_int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  u_int tmp___2 ;
  int tmp___3 ;

  {
#line 161
  while (1) {
#line 161
    tmp___2 = buffer_len(& stderr_buffer);
#line 161
    if (tmp___2 > 0U) {
#line 161
      tmp___3 = packet_not_very_much_data_to_write();
#line 161
      if (! tmp___3) {
#line 161
        break;
      }
    } else {
#line 161
      break;
    }
#line 163
    tmp = buffer_len(& stderr_buffer);
#line 163
    len = (int )tmp;
#line 164
    tmp___0 = packet_is_interactive();
#line 164
    if (tmp___0) {
#line 165
      if (len > 512) {
#line 166
        len = 512;
      }
    } else {
#line 169
      if (len > max_packet_size) {
#line 170
        len = max_packet_size;
      }
    }
#line 172
    packet_start((unsigned char)18);
#line 173
    tmp___1 = buffer_ptr(& stderr_buffer);
#line 173
    packet_put_string((void const   *)tmp___1, (unsigned int )len);
#line 174
    packet_send();
#line 175
    buffer_consume(& stderr_buffer, (unsigned int )len);
#line 176
    stderr_bytes += (long )len;
  }
#line 178
  return;
}
}
#line 184 "serverloop.c"
static void make_packets_from_stdout_data(void) 
{ int len ;
  u_int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  u_int tmp___2 ;
  int tmp___3 ;

  {
#line 190
  while (1) {
#line 190
    tmp___2 = buffer_len(& stdout_buffer);
#line 190
    if (tmp___2 > 0U) {
#line 190
      tmp___3 = packet_not_very_much_data_to_write();
#line 190
      if (! tmp___3) {
#line 190
        break;
      }
    } else {
#line 190
      break;
    }
#line 192
    tmp = buffer_len(& stdout_buffer);
#line 192
    len = (int )tmp;
#line 193
    tmp___0 = packet_is_interactive();
#line 193
    if (tmp___0) {
#line 194
      if (len > 512) {
#line 195
        len = 512;
      }
    } else {
#line 198
      if (len > max_packet_size) {
#line 199
        len = max_packet_size;
      }
    }
#line 201
    packet_start((unsigned char)17);
#line 202
    tmp___1 = buffer_ptr(& stdout_buffer);
#line 202
    packet_put_string((void const   *)tmp___1, (unsigned int )len);
#line 203
    packet_send();
#line 204
    buffer_consume(& stdout_buffer, (unsigned int )len);
#line 205
    stdout_bytes += (long )len;
  }
#line 207
  return;
}
}
#line 212
static void client_alive_check(void) ;
#line 212 "serverloop.c"
static int had_channel  =    0;
#line 209 "serverloop.c"
static void client_alive_check(void) 
{ int id ;

  {
#line 215
  id = channel_find_open();
#line 216
  if (id == -1) {
#line 217
    if (! had_channel) {
#line 218
      return;
    }
#line 219
    packet_disconnect("No open channels after timeout!");
  }
#line 221
  had_channel = 1;
#line 224
  client_alive_timeouts ++;
#line 224
  if (client_alive_timeouts > options.client_alive_count_max) {
#line 225
    packet_disconnect("Timeout, your session not responding.");
  }
#line 231
  channel_request_start(id, (char *)"keepalive@openssh.com", 1);
#line 232
  packet_send();
#line 233
  return;
}
}
#line 241 "serverloop.c"
static void wait_until_can_do_something(fd_set **readsetp , fd_set **writesetp , int *maxfdp ,
                                        int *nallocp , u_int max_time_milliseconds ) 
{ struct timeval tv ;
  struct timeval *tvp ;
  int ret ;
  int client_alive_scheduled ;
  u_int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  u_int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;

  {
#line 247
  client_alive_scheduled = 0;
#line 257
  if (compat20) {
#line 257
    if (max_time_milliseconds == 0U) {
#line 257
      if (options.client_alive_interval) {
#line 259
        client_alive_scheduled = 1;
#line 260
        max_time_milliseconds = (unsigned int )(options.client_alive_interval * 1000);
      }
    }
  }
#line 264
  channel_prepare_select(readsetp, writesetp, maxfdp, nallocp, 0);
#line 266
  if (compat20) {
#line 271
    __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  } else {
#line 277
    tmp = buffer_len(& stdin_buffer);
#line 277
    if (tmp < buffer_high) {
#line 277
      tmp___0 = channel_not_very_much_buffered_data();
#line 277
      if (tmp___0) {
#line 279
        __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
#line 284
    tmp___1 = packet_not_very_much_data_to_write();
#line 284
    if (tmp___1) {
#line 285
      if (! fdout_eof) {
#line 286
        __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->__fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
#line 287
      if (! fderr_eof) {
#line 288
        __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->__fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
#line 294
    if (fdin != -1) {
#line 294
      tmp___2 = buffer_len(& stdin_buffer);
#line 294
      if (tmp___2 > 0U) {
#line 295
        __asm__  volatile   ("btsl %1,%0": "=m" ((*writesetp)->__fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
  }
#line 297
  notify_prepare(*readsetp);
#line 303
  tmp___3 = packet_have_data_to_write();
#line 303
  if (tmp___3) {
#line 304
    __asm__  volatile   ("btsl %1,%0": "=m" ((*writesetp)->__fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 310
  if (child_terminated) {
#line 310
    tmp___4 = packet_not_very_much_data_to_write();
#line 310
    if (tmp___4) {
#line 311
      if (max_time_milliseconds == 0U) {
#line 312
        max_time_milliseconds = 100U;
      } else {
#line 311
        if (client_alive_scheduled) {
#line 312
          max_time_milliseconds = 100U;
        }
      }
    }
  }
#line 314
  if (max_time_milliseconds == 0U) {
#line 315
    tvp = (struct timeval *)((void *)0);
  } else {
#line 317
    tv.tv_sec = (long )(max_time_milliseconds / 1000U);
#line 318
    tv.tv_usec = (long )(1000U * (max_time_milliseconds % 1000U));
#line 319
    tvp = & tv;
  }
#line 323
  ret = select(*maxfdp + 1, (fd_set * __restrict  )*readsetp, (fd_set * __restrict  )*writesetp,
               (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )tvp);
#line 325
  if (ret == -1) {
#line 326
    memset((void *)*readsetp, 0, (unsigned int )*nallocp);
#line 327
    memset((void *)*writesetp, 0, (unsigned int )*nallocp);
#line 328
    tmp___7 = __errno_location();
#line 328
    if (*tmp___7 != 4) {
#line 329
      tmp___5 = __errno_location();
#line 329
      tmp___6 = strerror(*tmp___5);
#line 329
      error("select: %.100s", tmp___6);
    }
  } else {
#line 330
    if (ret == 0) {
#line 330
      if (client_alive_scheduled) {
#line 331
        client_alive_check();
      }
    }
  }
#line 333
  notify_done(*readsetp);
#line 334
  return;
}
}
#line 340 "serverloop.c"
static void process_input(fd_set *readset ) 
{ int len ;
  char buf___1[16384] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  register char __result ;
  int *tmp___3 ;
  int *tmp___4 ;
  register char __result___0 ;
  int *tmp___5 ;
  int *tmp___6 ;
  register char __result___1 ;

  {
#line 347
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 347
  if (__result) {
#line 348
    len = read(connection_in___0, (void *)(buf___1), sizeof(buf___1));
#line 349
    if (len == 0) {
#line 350
      verbose("Connection closed by remote host.");
#line 351
      connection_closed = 1;
#line 352
      if (compat20) {
#line 353
        return;
      }
#line 354
      fatal_cleanup();
    } else {
#line 355
      if (len < 0) {
#line 356
        tmp___1 = __errno_location();
#line 356
        if (*tmp___1 != 4) {
#line 356
          tmp___2 = __errno_location();
#line 356
          if (*tmp___2 != 11) {
#line 357
            tmp = __errno_location();
#line 357
            tmp___0 = strerror(*tmp);
#line 357
            verbose("Read error from remote host: %.100s", tmp___0);
#line 358
            fatal_cleanup();
          }
        }
      } else {
#line 362
        packet_process_incoming((char const   *)(buf___1), (unsigned int )len);
      }
    }
  }
#line 365
  if (compat20) {
#line 366
    return;
  }
#line 369
  if (! fdout_eof) {
#line 369
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "cc");
#line 369
    if (__result___0) {
#line 370
      len = read(fdout, (void *)(buf___1), sizeof(buf___1));
#line 371
      if (len < 0) {
#line 371
        tmp___3 = __errno_location();
#line 371
        if (! (*tmp___3 == 4)) {
#line 371
          tmp___4 = __errno_location();
#line 371
          if (! (*tmp___4 == 11)) {
            goto _L;
          }
        }
      } else {
        _L: /* CIL Label */ 
#line 373
        if (len <= 0) {
#line 374
          fdout_eof = 1;
        } else {
#line 376
          buffer_append(& stdout_buffer, (void const   *)(buf___1), (unsigned int )len);
#line 377
          fdout_bytes += (long )len;
        }
      }
    }
  }
#line 381
  if (! fderr_eof) {
#line 381
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___1): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "cc");
#line 381
    if (__result___1) {
#line 382
      len = read(fderr, (void *)(buf___1), sizeof(buf___1));
#line 383
      if (len < 0) {
#line 383
        tmp___5 = __errno_location();
#line 383
        if (! (*tmp___5 == 4)) {
#line 383
          tmp___6 = __errno_location();
#line 383
          if (! (*tmp___6 == 11)) {
            goto _L___0;
          }
        }
      } else {
        _L___0: /* CIL Label */ 
#line 385
        if (len <= 0) {
#line 386
          fderr_eof = 1;
        } else {
#line 388
          buffer_append(& stderr_buffer, (void const   *)(buf___1), (unsigned int )len);
        }
      }
    }
  }
#line 391
  return;
}
}
#line 396 "serverloop.c"
static void process_output(fd_set *writeset ) 
{ struct termios tio ;
  u_char *data ;
  u_int dlen ;
  int len ;
  void *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  register char __result ;
  register char __result___0 ;

  {
#line 405
  if (! compat20) {
#line 405
    if (fdin != -1) {
#line 405
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))),
                           "m" (writeset->__fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "cc");
#line 405
      if (__result) {
#line 406
        tmp = buffer_ptr(& stdin_buffer);
#line 406
        data = (u_char *)tmp;
#line 407
        dlen = buffer_len(& stdin_buffer);
#line 408
        len = write(fdin, (void const   *)data, dlen);
#line 409
        if (len < 0) {
#line 409
          tmp___1 = __errno_location();
#line 409
          if (! (*tmp___1 == 4)) {
#line 409
            tmp___2 = __errno_location();
#line 409
            if (! (*tmp___2 == 11)) {
              goto _L;
            }
          }
        } else {
          _L: /* CIL Label */ 
#line 411
          if (len <= 0) {
#line 412
            if (fdin != fdout) {
#line 413
              close(fdin);
            } else {
#line 415
              shutdown(fdin, 1);
            }
#line 416
            fdin = -1;
          } else {
#line 419
            if (fdin_is_tty) {
#line 419
              if (dlen >= 1U) {
#line 419
                if ((int )*(data + 0) != 13) {
#line 419
                  tmp___0 = tcgetattr(fdin, & tio);
#line 419
                  if (tmp___0 == 0) {
#line 419
                    if (! (tio.c_lflag & 8U)) {
#line 419
                      if (tio.c_lflag & 2U) {
#line 426
                        packet_send_ignore(len);
#line 427
                        packet_send();
                      }
                    }
                  }
                }
              }
            }
#line 430
            buffer_consume(& stdin_buffer, (unsigned int )len);
#line 432
            stdin_bytes += (long )len;
          }
        }
      }
    }
  }
#line 436
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->__fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 436
  if (__result___0) {
#line 437
    packet_write_poll();
  }
#line 438
  return;
}
}
#line 444 "serverloop.c"
static void drain_output(void) 
{ u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  void *tmp___4 ;
  u_int tmp___5 ;
  u_int tmp___6 ;

  {
#line 448
  tmp___2 = buffer_len(& stdout_buffer);
#line 448
  if (tmp___2 > 0U) {
#line 449
    packet_start((unsigned char)17);
#line 450
    tmp = buffer_len(& stdout_buffer);
#line 450
    tmp___0 = buffer_ptr(& stdout_buffer);
#line 450
    packet_put_string((void const   *)tmp___0, tmp);
#line 452
    packet_send();
#line 454
    tmp___1 = buffer_len(& stdout_buffer);
#line 454
    stdout_bytes = (long )((unsigned long )stdout_bytes + (unsigned long )tmp___1);
  }
#line 457
  tmp___6 = buffer_len(& stderr_buffer);
#line 457
  if (tmp___6 > 0U) {
#line 458
    packet_start((unsigned char)18);
#line 459
    tmp___3 = buffer_len(& stderr_buffer);
#line 459
    tmp___4 = buffer_ptr(& stderr_buffer);
#line 459
    packet_put_string((void const   *)tmp___4, tmp___3);
#line 461
    packet_send();
#line 463
    tmp___5 = buffer_len(& stderr_buffer);
#line 463
    stderr_bytes = (long )((unsigned long )stderr_bytes + (unsigned long )tmp___5);
  }
#line 466
  packet_write_wait();
#line 467
  return;
}
}
#line 469 "serverloop.c"
static void process_buffered_input_packets(void) 
{ Kex *tmp ;

  {
#line 472
  if (compat20) {
#line 472
    tmp = xxx_kex;
  } else {
#line 472
    tmp = (Kex *)((void *)0);
  }
#line 472
  dispatch_run(1, (int *)((void *)0), (void *)tmp);
#line 473
  return;
}
}
#line 482 "serverloop.c"
void server_loop(pid_t pid , int fdin_arg , int fdout_arg , int fderr_arg ) 
{ fd_set *readset ;
  fd_set *writeset ;
  int max_fd ;
  int nalloc ;
  int wait_status ;
  pid_t wait_pid ;
  int waiting_termination ;
  u_int max_time_milliseconds ;
  u_int previous_stdout_buffer_bytes ;
  u_int stdout_buffer_bytes ;
  int type ;
  int tmp ;
  int tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *s ;
  char *cp ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  u_int tmp___7 ;
  u_int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  union __anonunion_73 __constr_expr_0 ;
  union __anonunion_74 __constr_expr_1 ;
  union __anonunion_75 __constr_expr_2 ;
  union __anonunion_76 __constr_expr_3 ;
  union __anonunion_77 __constr_expr_4 ;

  {
#line 485
  readset = (fd_set *)((void *)0);
#line 485
  writeset = (fd_set *)((void *)0);
#line 486
  max_fd = 0;
#line 486
  nalloc = 0;
#line 489
  waiting_termination = 0;
#line 495
  debug("Entering interactive session.");
#line 498
  child_terminated = (int volatile   )0;
#line 499
  mysignal(17, & sigchld_handler);
#line 502
  fdin = fdin_arg;
#line 503
  fdout = fdout_arg;
#line 504
  fderr = fderr_arg;
#line 507
  set_nonblock(fdin);
#line 508
  set_nonblock(fdout);
#line 510
  if (fderr != -1) {
#line 511
    set_nonblock(fderr);
  }
#line 513
  if (! (datafellows & 256)) {
#line 513
    tmp = isatty(fdin);
#line 513
    if (tmp) {
#line 514
      fdin_is_tty = 1;
    }
  }
#line 516
  connection_in___0 = packet_get_connection_in();
#line 517
  connection_out___0 = packet_get_connection_out();
#line 519
  notify_setup();
#line 521
  previous_stdout_buffer_bytes = 0U;
#line 524
  tmp___0 = packet_is_interactive();
#line 524
  if (tmp___0) {
#line 525
    buffer_high = 4096U;
  } else {
#line 527
    buffer_high = 65536U;
  }
#line 539
  buffer_init(& stdin_buffer);
#line 540
  buffer_init(& stdout_buffer);
#line 541
  buffer_init(& stderr_buffer);
#line 549
  if (fderr == -1) {
#line 550
    fderr_eof = 1;
  }
#line 552
  server_init_dispatch();
#line 555
  while (1) {
#line 558
    process_buffered_input_packets();
#line 564
    if (stdin_eof) {
#line 564
      if (fdin != -1) {
#line 564
        tmp___1 = buffer_len(& stdin_buffer);
#line 564
        if (tmp___1 == 0U) {
#line 565
          if (fdin != fdout) {
#line 566
            close(fdin);
          } else {
#line 568
            shutdown(fdin, 1);
          }
#line 569
          fdin = -1;
        }
      }
    }
#line 572
    make_packets_from_stderr_data();
#line 581
    max_time_milliseconds = 0U;
#line 582
    stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 583
    if (stdout_buffer_bytes != 0U) {
#line 583
      if (stdout_buffer_bytes < 256U) {
#line 583
        if (stdout_buffer_bytes != previous_stdout_buffer_bytes) {
#line 586
          max_time_milliseconds = 10U;
        } else {
#line 589
          make_packets_from_stdout_data();
        }
      } else {
#line 589
        make_packets_from_stdout_data();
      }
    } else {
#line 589
      make_packets_from_stdout_data();
    }
#line 591
    previous_stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 594
    tmp___2 = packet_not_very_much_data_to_write();
#line 594
    if (tmp___2) {
#line 595
      channel_output_poll();
    }
#line 602
    if (fdout_eof) {
#line 602
      if (fderr_eof) {
#line 602
        tmp___6 = packet_have_data_to_write();
#line 602
        if (! tmp___6) {
#line 602
          tmp___7 = buffer_len(& stdout_buffer);
#line 602
          if (tmp___7 == 0U) {
#line 602
            tmp___8 = buffer_len(& stderr_buffer);
#line 602
            if (tmp___8 == 0U) {
#line 604
              tmp___3 = channel_still_open();
#line 604
              if (! tmp___3) {
#line 605
                break;
              }
#line 606
              if (! waiting_termination) {
#line 607
                s = "Waiting for forwarded connections to terminate...\r\n";
#line 609
                waiting_termination = 1;
#line 610
                tmp___4 = strlen(s);
#line 610
                buffer_append(& stderr_buffer, (void const   *)s, tmp___4);
#line 613
                cp = channel_open_message();
#line 614
                tmp___5 = strlen((char const   *)cp);
#line 614
                buffer_append(& stderr_buffer, (void const   *)cp, tmp___5);
#line 615
                xfree((void *)cp);
              }
            }
          }
        }
      }
    }
#line 618
    if (connection_in___0 > connection_out___0) {
#line 618
      max_fd = connection_in___0;
    } else {
#line 618
      max_fd = connection_out___0;
    }
#line 619
    if (max_fd > fdin) {
#line 619
      max_fd = max_fd;
    } else {
#line 619
      max_fd = fdin;
    }
#line 620
    if (max_fd > fdout) {
#line 620
      max_fd = max_fd;
    } else {
#line 620
      max_fd = fdout;
    }
#line 621
    if (max_fd > fderr) {
#line 621
      max_fd = max_fd;
    } else {
#line 621
      max_fd = fderr;
    }
#line 622
    if (max_fd > notify_pipe[0]) {
#line 622
      max_fd = max_fd;
    } else {
#line 622
      max_fd = notify_pipe[0];
    }
#line 625
    wait_until_can_do_something(& readset, & writeset, & max_fd, & nalloc, max_time_milliseconds);
#line 629
    channel_after_select(readset, writeset);
#line 632
    process_input(readset);
#line 635
    process_output(writeset);
  }
#line 637
  if (readset) {
#line 638
    xfree((void *)readset);
  }
#line 639
  if (writeset) {
#line 640
    xfree((void *)writeset);
  }
#line 645
  drain_output();
#line 647
  debug("End of interactive session; stdin %ld, stdout (read %ld, sent %ld), stderr %ld bytes.",
        stdin_bytes, fdout_bytes, stdout_bytes, stderr_bytes);
#line 651
  buffer_free(& stdin_buffer);
#line 652
  buffer_free(& stdout_buffer);
#line 653
  buffer_free(& stderr_buffer);
#line 656
  if (fdout != -1) {
#line 657
    close(fdout);
  }
#line 658
  fdout = -1;
#line 659
  fdout_eof = 1;
#line 660
  if (fderr != -1) {
#line 661
    close(fderr);
  }
#line 662
  fderr = -1;
#line 663
  fderr_eof = 1;
#line 664
  if (fdin != -1) {
#line 665
    close(fdin);
  }
#line 666
  fdin = -1;
#line 668
  channel_free_all();
#line 671
  mysignal(17, (void (*)(int  ))0);
#line 673
  while (1) {
#line 673
    wait_pid = waitpid(-1, & wait_status, 0);
#line 673
    if (! (wait_pid < 0)) {
#line 673
      break;
    }
#line 674
    tmp___11 = __errno_location();
#line 674
    if (*tmp___11 != 4) {
#line 675
      tmp___9 = __errno_location();
#line 675
      tmp___10 = strerror(*tmp___9);
#line 675
      packet_disconnect("wait: %.100s", tmp___10);
    }
  }
#line 676
  if (wait_pid != pid) {
#line 677
    error("Strange, wait returned pid %ld, expected %ld", (long )wait_pid, (long )pid);
  }
#line 681
  __constr_expr_2.__in = wait_status;
#line 681
  if ((__constr_expr_2.__i & 127) == 0) {
#line 683
    __constr_expr_0.__in = wait_status;
#line 683
    debug("Command exited with status %d.", (__constr_expr_0.__i & 65280) >> 8);
#line 684
    packet_start((unsigned char)20);
#line 685
    __constr_expr_1.__in = wait_status;
#line 685
    packet_put_int((unsigned int )((__constr_expr_1.__i & 65280) >> 8));
#line 686
    packet_send();
#line 687
    packet_write_wait();
#line 696
    while (1) {
#line 697
      type = packet_read();
#line 696
      if (! (type != 33)) {
#line 696
        break;
      }
    }
#line 701
    debug("Received exit confirmation.");
#line 702
    return;
  }
#line 705
  __constr_expr_4.__in = wait_status;
#line 705
  if ((int )((signed char )((__constr_expr_4.__i & 127) + 1)) >> 1 > 0) {
#line 706
    __constr_expr_3.__in = wait_status;
#line 706
    packet_disconnect("Command terminated on signal %d.", __constr_expr_3.__i & 127);
  }
#line 710
  packet_disconnect("wait returned status %04x.", wait_status);
#line 712
  return;
}
}
#line 714 "serverloop.c"
static void collect_children(void) 
{ pid_t pid ;
  sigset_t oset ;
  sigset_t nset ;
  int status ;
  int *tmp ;

  {
#line 722
  sigemptyset(& nset);
#line 723
  sigaddset(& nset, 17);
#line 724
  sigprocmask(0, (sigset_t const   * __restrict  )(& nset), (sigset_t * __restrict  )(& oset));
#line 725
  if (child_terminated) {
#line 726
    while (1) {
#line 726
      pid = waitpid(-1, & status, 1);
#line 726
      if (! (pid > 0)) {
#line 726
        if (pid < 0) {
#line 726
          tmp = __errno_location();
#line 726
          if (! (*tmp == 4)) {
#line 726
            break;
          }
        } else {
#line 726
          break;
        }
      }
#line 728
      if (pid > 0) {
#line 729
        session_close_by_pid(pid, status);
      }
    }
#line 730
    child_terminated = (int volatile   )0;
  }
#line 732
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((void *)0));
#line 733
  return;
}
}
#line 735 "serverloop.c"
void server_loop2(Authctxt *authctxt___0 ) 
{ fd_set *readset ;
  fd_set *writeset ;
  int rekeying ;
  int max_fd ;
  int nalloc ;
  int tmp ;
  int tmp___0 ;

  {
#line 738
  readset = (fd_set *)((void *)0);
#line 738
  writeset = (fd_set *)((void *)0);
#line 739
  rekeying = 0;
#line 739
  nalloc = 0;
#line 741
  debug("Entering interactive session for SSH2.");
#line 743
  mysignal(17, & sigchld_handler);
#line 744
  child_terminated = (int volatile   )0;
#line 745
  connection_in___0 = packet_get_connection_in();
#line 746
  connection_out___0 = packet_get_connection_out();
#line 748
  notify_setup();
#line 750
  if (connection_in___0 > connection_out___0) {
#line 750
    max_fd = connection_in___0;
  } else {
#line 750
    max_fd = connection_out___0;
  }
#line 751
  if (max_fd > notify_pipe[0]) {
#line 751
    max_fd = max_fd;
  } else {
#line 751
    max_fd = notify_pipe[0];
  }
#line 753
  xxx_authctxt = authctxt___0;
#line 755
  server_init_dispatch();
#line 757
  while (1) {
#line 758
    process_buffered_input_packets();
#line 760
    if ((unsigned int )xxx_kex != (unsigned int )((void *)0)) {
#line 760
      if (! xxx_kex->done) {
#line 760
        tmp = 1;
      } else {
#line 760
        tmp = 0;
      }
    } else {
#line 760
      tmp = 0;
    }
#line 760
    rekeying = tmp;
#line 762
    if (! rekeying) {
#line 762
      tmp___0 = packet_not_very_much_data_to_write();
#line 762
      if (tmp___0) {
#line 763
        channel_output_poll();
      }
    }
#line 764
    wait_until_can_do_something(& readset, & writeset, & max_fd, & nalloc, 0U);
#line 767
    collect_children();
#line 768
    if (! rekeying) {
#line 769
      channel_after_select(readset, writeset);
    }
#line 770
    process_input(readset);
#line 771
    if (connection_closed) {
#line 772
      break;
    }
#line 773
    process_output(writeset);
  }
#line 775
  collect_children();
#line 777
  if (readset) {
#line 778
    xfree((void *)readset);
  }
#line 779
  if (writeset) {
#line 780
    xfree((void *)writeset);
  }
#line 783
  channel_free_all();
#line 786
  session_destroy_all((void (*)(Session * ))((void *)0));
#line 787
  return;
}
}
#line 789 "serverloop.c"
static void server_input_channel_failure(int type , u_int32_t seq , void *ctxt ) 
{ 

  {
#line 792
  debug("Got CHANNEL_FAILURE for keepalive");
#line 798
  client_alive_timeouts = 0;
#line 799
  return;
}
}
#line 802 "serverloop.c"
static void server_input_stdin_data(int type , u_int32_t seq , void *ctxt ) 
{ char *data ;
  u_int data_len ;
  void *tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 810
  if (fdin == -1) {
#line 811
    return;
  }
#line 812
  tmp = packet_get_string(& data_len);
#line 812
  data = (char *)tmp;
#line 813
  while (1) {
#line 813
    tmp___0 = packet_remaining();
#line 813
    _len = tmp___0;
#line 813
    if (_len > 0) {
#line 813
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
          813);
#line 813
      packet_disconnect("Packet integrity error.");
    }
#line 813
    break;
  }
#line 814
  buffer_append(& stdin_buffer, (void const   *)data, data_len);
#line 815
  memset((void *)data, 0, data_len);
#line 816
  xfree((void *)data);
#line 817
  return;
}
}
#line 819 "serverloop.c"
static void server_input_eof(int type , u_int32_t seq , void *ctxt ) 
{ int _len ;
  int tmp ;

  {
#line 827
  debug("EOF received for stdin.");
#line 828
  while (1) {
#line 828
    tmp = packet_remaining();
#line 828
    _len = tmp;
#line 828
    if (_len > 0) {
#line 828
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
          828);
#line 828
      packet_disconnect("Packet integrity error.");
    }
#line 828
    break;
  }
#line 829
  stdin_eof = 1;
#line 830
  return;
}
}
#line 832 "serverloop.c"
static void server_input_window_size(int type , u_int32_t seq , void *ctxt ) 
{ int row ;
  u_int tmp ;
  int col ;
  u_int tmp___0 ;
  int xpixel ;
  u_int tmp___1 ;
  int ypixel ;
  u_int tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 835
  tmp = packet_get_int();
#line 835
  row = (int )tmp;
#line 836
  tmp___0 = packet_get_int();
#line 836
  col = (int )tmp___0;
#line 837
  tmp___1 = packet_get_int();
#line 837
  xpixel = (int )tmp___1;
#line 838
  tmp___2 = packet_get_int();
#line 838
  ypixel = (int )tmp___2;
#line 840
  debug("Window change received.");
#line 841
  while (1) {
#line 841
    tmp___3 = packet_remaining();
#line 841
    _len = tmp___3;
#line 841
    if (_len > 0) {
#line 841
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
          841);
#line 841
      packet_disconnect("Packet integrity error.");
    }
#line 841
    break;
  }
#line 842
  if (fdin != -1) {
#line 843
    pty_change_window_size(fdin, row, col, xpixel, ypixel);
  }
#line 844
  return;
}
}
#line 846 "serverloop.c"
static Channel *server_request_direct_tcpip(char *ctype ) 
{ Channel *c ;
  int sock ;
  char *target ;
  char *originator ;
  int target_port ;
  int originator_port ;
  void *tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  u_int tmp___2 ;
  int _len ;
  int tmp___3 ;
  char *tmp___4 ;

  {
#line 854
  tmp = packet_get_string((u_int *)((void *)0));
#line 854
  target = (char *)tmp;
#line 855
  tmp___0 = packet_get_int();
#line 855
  target_port = (int )tmp___0;
#line 856
  tmp___1 = packet_get_string((u_int *)((void *)0));
#line 856
  originator = (char *)tmp___1;
#line 857
  tmp___2 = packet_get_int();
#line 857
  originator_port = (int )tmp___2;
#line 858
  while (1) {
#line 858
    tmp___3 = packet_remaining();
#line 858
    _len = tmp___3;
#line 858
    if (_len > 0) {
#line 858
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
          858);
#line 858
      packet_disconnect("Packet integrity error.");
    }
#line 858
    break;
  }
#line 860
  debug("server_request_direct_tcpip: originator %s port %d, target %s port %d", originator,
        originator_port, target, target_port);
#line 864
  sock = channel_connect_to((char const   *)target, (unsigned short )target_port);
#line 865
  xfree((void *)target);
#line 866
  xfree((void *)originator);
#line 867
  if (sock < 0) {
#line 868
    return ((Channel *)((void *)0));
  }
#line 869
  tmp___4 = xstrdup("direct-tcpip");
#line 869
  c = channel_new(ctype, 12, sock, sock, -1, 131072U, 32768U, 0, tmp___4, 1);
#line 872
  return (c);
}
}
#line 875 "serverloop.c"
static Channel *server_request_session(char *ctype ) 
{ Channel *c ;
  int _len ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 880
  debug("input_session_request");
#line 881
  while (1) {
#line 881
    tmp = packet_remaining();
#line 881
    _len = tmp;
#line 881
    if (_len > 0) {
#line 881
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
          881);
#line 881
      packet_disconnect("Packet integrity error.");
    }
#line 881
    break;
  }
#line 888
  tmp___0 = xstrdup("server-session");
#line 888
  c = channel_new(ctype, 10, -1, -1, -1, 0U, 32768U, 0, tmp___0, 1);
#line 891
  tmp___1 = session_open(xxx_authctxt, c->self);
#line 891
  if (tmp___1 != 1) {
#line 892
    debug("session open failed, free channel %d", c->self);
#line 893
    channel_free(c);
#line 894
    return ((Channel *)((void *)0));
  }
#line 896
  channel_register_cleanup(c->self, & session_close_by_channel);
#line 897
  return (c);
}
}
#line 900 "serverloop.c"
static void server_input_channel_open(int type , u_int32_t seq , void *ctxt ) 
{ Channel *c ;
  char *ctype ;
  int rchan ;
  u_int rmaxpack ;
  u_int rwindow ;
  u_int len ;
  void *tmp ;
  u_int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___16 ;
  int tmp___19 ;
  int tmp___20 ;

  {
#line 903
  c = (Channel *)((void *)0);
#line 908
  tmp = packet_get_string(& len);
#line 908
  ctype = (char *)tmp;
#line 909
  tmp___0 = packet_get_int();
#line 909
  rchan = (int )tmp___0;
#line 910
  rwindow = packet_get_int();
#line 911
  rmaxpack = packet_get_int();
#line 913
  debug("server_input_channel_open: ctype %s rchan %d win %d max %d", ctype, rchan,
        rwindow, rmaxpack);
#line 916
  if (0) {
#line 916
    __s1_len___0 = strlen((char const   *)ctype);
#line 916
    __s2_len___0 = strlen("session");
#line 916
    if (! ((unsigned int )((void const   *)(ctype + 1)) - (unsigned int )((void const   *)ctype) == 1U)) {
      goto _L___2;
    } else {
#line 916
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 916
        if (! ((unsigned int )((void const   *)("session" + 1)) - (unsigned int )((void const   *)"session") == 1U)) {
#line 916
          tmp___20 = 1;
        } else {
#line 916
          if (__s2_len___0 >= 4U) {
#line 916
            tmp___20 = 1;
          } else {
#line 916
            tmp___20 = 0;
          }
        }
      } else {
#line 916
        tmp___20 = 0;
      }
    }
#line 916
    if (tmp___20) {
#line 916
      tmp___16 = __builtin_strcmp((char const   *)ctype, "session");
    } else {
#line 916
      tmp___19 = __builtin_strcmp((char const   *)ctype, "session");
#line 916
      tmp___16 = tmp___19;
    }
  } else {
#line 916
    tmp___19 = __builtin_strcmp((char const   *)ctype, "session");
#line 916
    tmp___16 = tmp___19;
  }
#line 916
  if (tmp___16 == 0) {
#line 917
    c = server_request_session(ctype);
  } else {
#line 918
    if (0) {
#line 918
      __s1_len = strlen((char const   *)ctype);
#line 918
      __s2_len = strlen("direct-tcpip");
#line 918
      if (! ((unsigned int )((void const   *)(ctype + 1)) - (unsigned int )((void const   *)ctype) == 1U)) {
        goto _L___0;
      } else {
#line 918
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 918
          if (! ((unsigned int )((void const   *)("direct-tcpip" + 1)) - (unsigned int )((void const   *)"direct-tcpip") == 1U)) {
#line 918
            tmp___10 = 1;
          } else {
#line 918
            if (__s2_len >= 4U) {
#line 918
              tmp___10 = 1;
            } else {
#line 918
              tmp___10 = 0;
            }
          }
        } else {
#line 918
          tmp___10 = 0;
        }
      }
#line 918
      if (tmp___10) {
#line 918
        tmp___6 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
      } else {
#line 918
        tmp___9 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
#line 918
        tmp___6 = tmp___9;
      }
    } else {
#line 918
      tmp___9 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
#line 918
      tmp___6 = tmp___9;
    }
#line 918
    if (tmp___6 == 0) {
#line 919
      c = server_request_direct_tcpip(ctype);
    }
  }
#line 921
  if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 922
    debug("server_input_channel_open: confirm %s", ctype);
#line 923
    c->remote_id = rchan;
#line 924
    c->remote_window = rwindow;
#line 925
    c->remote_maxpacket = rmaxpack;
#line 926
    if (c->type != 12) {
#line 927
      packet_start((unsigned char)91);
#line 928
      packet_put_int((unsigned int )c->remote_id);
#line 929
      packet_put_int((unsigned int )c->self);
#line 930
      packet_put_int(c->local_window);
#line 931
      packet_put_int(c->local_maxpacket);
#line 932
      packet_send();
    }
  } else {
#line 935
    debug("server_input_channel_open: failure %s", ctype);
#line 936
    packet_start((unsigned char)92);
#line 937
    packet_put_int((unsigned int )rchan);
#line 938
    packet_put_int(1U);
#line 939
    if (! (datafellows & 131072)) {
#line 940
      packet_put_cstring("open failed");
#line 941
      packet_put_cstring("");
    }
#line 943
    packet_send();
  }
#line 945
  xfree((void *)ctype);
#line 946
  return;
}
}
#line 948 "serverloop.c"
static void server_input_global_request(int type , u_int32_t seq , void *ctxt ) 
{ char *rtype ;
  int want_reply ;
  int success ;
  void *tmp ;
  u_int tmp___0 ;
  struct passwd *pw ;
  char *listen_address ;
  u_short listen_port ;
  void *tmp___1 ;
  u_int tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 953
  success = 0;
#line 955
  tmp = packet_get_string((u_int *)((void *)0));
#line 955
  rtype = (char *)tmp;
#line 956
  tmp___0 = packet_get_char();
#line 956
  want_reply = (int )tmp___0;
#line 957
  debug("server_input_global_request: rtype %s want_reply %d", rtype, want_reply);
#line 960
  if (0) {
#line 960
    __s1_len = strlen((char const   *)rtype);
#line 960
    __s2_len = strlen("tcpip-forward");
#line 960
    if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
      goto _L___0;
    } else {
#line 960
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 960
        if (! ((unsigned int )((void const   *)("tcpip-forward" + 1)) - (unsigned int )((void const   *)"tcpip-forward") == 1U)) {
#line 960
          tmp___12 = 1;
        } else {
#line 960
          if (__s2_len >= 4U) {
#line 960
            tmp___12 = 1;
          } else {
#line 960
            tmp___12 = 0;
          }
        }
      } else {
#line 960
        tmp___12 = 0;
      }
    }
#line 960
    if (tmp___12) {
#line 960
      tmp___8 = __builtin_strcmp((char const   *)rtype, "tcpip-forward");
    } else {
#line 960
      tmp___11 = __builtin_strcmp((char const   *)rtype, "tcpip-forward");
#line 960
      tmp___8 = tmp___11;
    }
  } else {
#line 960
    tmp___11 = __builtin_strcmp((char const   *)rtype, "tcpip-forward");
#line 960
    tmp___8 = tmp___11;
  }
#line 960
  if (tmp___8 == 0) {
#line 965
    pw = auth_get_user();
#line 966
    if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 967
      fatal("server_input_global_request: no user");
    }
#line 968
    tmp___1 = packet_get_string((u_int *)((void *)0));
#line 968
    listen_address = (char *)tmp___1;
#line 969
    tmp___2 = packet_get_int();
#line 969
    listen_port = (unsigned short )tmp___2;
#line 970
    debug("server_input_global_request: tcpip-forward listen %s port %d", listen_address,
          listen_port);
#line 974
    if (! options.allow_tcp_forwarding) {
#line 977
      success = 0;
#line 978
      packet_send_debug("Server has disabled port forwarding.");
    } else {
#line 974
      if (no_port_forwarding_flag) {
#line 977
        success = 0;
#line 978
        packet_send_debug("Server has disabled port forwarding.");
      } else {
#line 974
        if ((int )listen_port < 1024) {
#line 974
          if (pw->pw_uid != 0U) {
#line 977
            success = 0;
#line 978
            packet_send_debug("Server has disabled port forwarding.");
          } else {
#line 981
            success = channel_setup_remote_fwd_listener((char const   *)listen_address,
                                                        listen_port, options.gateway_ports);
          }
        } else {
#line 981
          success = channel_setup_remote_fwd_listener((char const   *)listen_address,
                                                      listen_port, options.gateway_ports);
        }
      }
    }
#line 984
    xfree((void *)listen_address);
  }
#line 986
  if (want_reply) {
#line 987
    if (success) {
#line 987
      tmp___13 = 81;
    } else {
#line 987
      tmp___13 = 82;
    }
#line 987
    packet_start((unsigned char )tmp___13);
#line 989
    packet_send();
#line 990
    packet_write_wait();
  }
#line 992
  xfree((void *)rtype);
#line 993
  return;
}
}
#line 994 "serverloop.c"
static void server_input_channel_req(int type , u_int32_t seq , void *ctxt ) 
{ Channel *c ;
  int id ;
  int reply ;
  int success ;
  char *rtype ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;

  {
#line 998
  success = 0;
#line 1001
  tmp = packet_get_int();
#line 1001
  id = (int )tmp;
#line 1002
  tmp___0 = packet_get_string((u_int *)((void *)0));
#line 1002
  rtype = (char *)tmp___0;
#line 1003
  tmp___1 = packet_get_char();
#line 1003
  reply = (int )tmp___1;
#line 1005
  debug("server_input_channel_req: channel %d request %s reply %d", id, rtype, reply);
#line 1008
  c = channel_lookup(id);
#line 1008
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1009
    packet_disconnect("server_input_channel_req: unknown channel %d", id);
  }
#line 1011
  if (c->type == 10) {
#line 1012
    success = session_input_channel_req(c, (char const   *)rtype);
  } else {
#line 1011
    if (c->type == 4) {
#line 1012
      success = session_input_channel_req(c, (char const   *)rtype);
    }
  }
#line 1013
  if (reply) {
#line 1014
    if (success) {
#line 1014
      tmp___2 = 99;
    } else {
#line 1014
      tmp___2 = 100;
    }
#line 1014
    packet_start((unsigned char )tmp___2);
#line 1016
    packet_put_int((unsigned int )c->remote_id);
#line 1017
    packet_send();
  }
#line 1019
  xfree((void *)rtype);
#line 1020
  return;
}
}
#line 1022 "serverloop.c"
static void server_init_dispatch_20(void) 
{ 

  {
#line 1025
  debug("server_init_dispatch_20");
#line 1026
  dispatch_init(& dispatch_protocol_error);
#line 1027
  dispatch_set(97, & channel_input_oclose);
#line 1028
  dispatch_set(94, & channel_input_data);
#line 1029
  dispatch_set(96, & channel_input_ieof);
#line 1030
  dispatch_set(95, & channel_input_extended_data);
#line 1031
  dispatch_set(90, & server_input_channel_open);
#line 1032
  dispatch_set(91, & channel_input_open_confirmation);
#line 1033
  dispatch_set(92, & channel_input_open_failure);
#line 1034
  dispatch_set(98, & server_input_channel_req);
#line 1035
  dispatch_set(93, & channel_input_window_adjust);
#line 1036
  dispatch_set(80, & server_input_global_request);
#line 1038
  dispatch_set(100, & server_input_channel_failure);
#line 1040
  dispatch_set(20, & kex_input_kexinit);
#line 1041
  return;
}
}
#line 1042 "serverloop.c"
static void server_init_dispatch_13(void) 
{ 

  {
#line 1045
  debug("server_init_dispatch_13");
#line 1046
  dispatch_init((dispatch_fn *)((void *)0));
#line 1047
  dispatch_set(19, & server_input_eof);
#line 1048
  dispatch_set(16, & server_input_stdin_data);
#line 1049
  dispatch_set(11, & server_input_window_size);
#line 1050
  dispatch_set(24, & channel_input_close);
#line 1051
  dispatch_set(25, & channel_input_close_confirmation);
#line 1052
  dispatch_set(23, & channel_input_data);
#line 1053
  dispatch_set(21, & channel_input_open_confirmation);
#line 1054
  dispatch_set(22, & channel_input_open_failure);
#line 1055
  dispatch_set(29, & channel_input_port_open);
#line 1056
  return;
}
}
#line 1057 "serverloop.c"
static void server_init_dispatch_15(void) 
{ 

  {
#line 1060
  server_init_dispatch_13();
#line 1061
  debug("server_init_dispatch_15");
#line 1062
  dispatch_set(24, & channel_input_ieof);
#line 1063
  dispatch_set(25, & channel_input_oclose);
#line 1064
  return;
}
}
#line 1065 "serverloop.c"
static void server_init_dispatch(void) 
{ 

  {
#line 1068
  if (compat20) {
#line 1069
    server_init_dispatch_20();
  } else {
#line 1070
    if (compat13) {
#line 1071
      server_init_dispatch_13();
    } else {
#line 1073
      server_init_dispatch_15();
    }
  }
#line 1074
  return;
}
}
#line 1 "md5crypt.o"
#line 1 "session.o"
#line 333 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 590
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 774
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 780
extern int pclose(FILE *__stream ) ;
#line 729 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template )  __attribute__((__nonnull__(1))) ;
#line 194 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 69 "/usr/include/grp.h"
extern void endgrent(void) ;
#line 257 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 106 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socketpair(int __domain , int __type , int __protocol ,
                                                    int *__fds ) ;
#line 504 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int execve(char const   *__path , char * const  *__argv ,
                                                char * const  *__envp )  __attribute__((__nonnull__(1))) ;
#line 526
extern  __attribute__((__nothrow__)) int execl(char const   *__path , char const   *__arg 
                                               , ...)  __attribute__((__nonnull__(1))) ;
#line 801
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 845
extern  __attribute__((__nothrow__)) int gethostname(char *__name , size_t __len )  __attribute__((__nonnull__(1))) ;
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 65 "session.h"
void session_pty_cleanup2(void *session ) ;
#line 67
Session *session_new(void) ;
#line 68
Session *session_by_tty(char *tty ) ;
#line 69
void session_close(Session *s ) ;
#line 70 "session.c"
void session_set_fds(Session *s , int fdin___0 , int fdout___0 , int fderr___0 ) ;
#line 71
void session_pty_cleanup(void *session ) ;
#line 72
void session_proctitle(Session *s ) ;
#line 73
int session_setup_x11fwd(Session *s ) ;
#line 74
void do_exec_pty(Session *s , char const   *command ) ;
#line 75
void do_exec_no_pty(Session *s , char const   *command ) ;
#line 76
void do_exec(Session *s , char const   *command ) ;
#line 77
void do_login(Session *s , char const   *command ) ;
#line 81
void do_child(Session *s , char const   *command ) ;
#line 82
void do_motd(void) ;
#line 83
int check_quietlogin(Session *s , char const   *command ) ;
#line 85
static void do_authenticated1(Authctxt *authctxt___0 ) ;
#line 86
static void do_authenticated2(Authctxt *authctxt___0 ) ;
#line 88
static int session_pty_req(Session *s ) ;
#line 100 "session.c"
char const   *original_command  =    (char const   *)((void *)0);
#line 104 "session.c"
Session sessions[10]  ;
#line 115 "session.c"
static char *auth_sock_name  =    (char *)((void *)0);
#line 116 "session.c"
static char *auth_sock_dir  =    (char *)((void *)0);
#line 120 "session.c"
static void auth_sock_cleanup_proc(void *_pw ) 
{ struct passwd *pw ;

  {
#line 123
  pw = (struct passwd *)_pw;
#line 125
  if ((unsigned int )auth_sock_name != (unsigned int )((void *)0)) {
#line 126
    temporarily_use_uid(pw);
#line 127
    unlink((char const   *)auth_sock_name);
#line 128
    rmdir((char const   *)auth_sock_dir);
#line 129
    auth_sock_name = (char *)((void *)0);
#line 130
    restore_uid();
  }
#line 132
  return;
}
}
#line 134 "session.c"
static int auth_input_request_forwarding(struct passwd *pw ) 
{ Channel *nc ;
  int sock ;
  struct sockaddr_un sunaddr ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  __pid_t tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;

  {
#line 141
  if ((unsigned int )auth_sock_name != (unsigned int )((void *)0)) {
#line 142
    error("authentication forwarding requested twice.");
#line 143
    return (0);
  }
#line 147
  temporarily_use_uid(pw);
#line 150
  tmp = xmalloc(4096U);
#line 150
  auth_sock_name = (char *)tmp;
#line 151
  tmp___0 = xmalloc(4096U);
#line 151
  auth_sock_dir = (char *)tmp___0;
#line 152
  strlcpy(auth_sock_dir, "/tmp/ssh-XXXXXXXX", 4096U);
#line 155
  tmp___3 = mkdtemp(auth_sock_dir);
#line 155
  if ((unsigned int )tmp___3 == (unsigned int )((void *)0)) {
#line 156
    tmp___1 = __errno_location();
#line 156
    tmp___2 = strerror(*tmp___1);
#line 156
    packet_send_debug("Agent forwarding disabled: mkdtemp() failed: %.100s", tmp___2);
#line 158
    restore_uid();
#line 159
    xfree((void *)auth_sock_name);
#line 160
    xfree((void *)auth_sock_dir);
#line 161
    auth_sock_name = (char *)((void *)0);
#line 162
    auth_sock_dir = (char *)((void *)0);
#line 163
    return (0);
  }
#line 165
  tmp___4 = getpid();
#line 165
  snprintf((char * __restrict  )auth_sock_name, 4096U, (char const   * __restrict  )"%s/agent.%ld",
           auth_sock_dir, (long )tmp___4);
#line 169
  fatal_add_cleanup(& auth_sock_cleanup_proc, (void *)pw);
#line 172
  sock = socket(1, 1, 0);
#line 173
  if (sock < 0) {
#line 174
    tmp___5 = __errno_location();
#line 174
    tmp___6 = strerror(*tmp___5);
#line 174
    packet_disconnect("socket: %.100s", tmp___6);
  }
#line 177
  memset((void *)(& sunaddr), 0, sizeof(sunaddr));
#line 178
  sunaddr.sun_family = (unsigned short)1;
#line 179
  strlcpy(sunaddr.sun_path, (char const   *)auth_sock_name, sizeof(sunaddr.sun_path));
#line 181
  tmp___9 = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sunaddr)),
                 sizeof(sunaddr));
#line 181
  if (tmp___9 < 0) {
#line 182
    tmp___7 = __errno_location();
#line 182
    tmp___8 = strerror(*tmp___7);
#line 182
    packet_disconnect("bind: %.100s", tmp___8);
  }
#line 185
  restore_uid();
#line 188
  tmp___12 = listen(sock, 5);
#line 188
  if (tmp___12 < 0) {
#line 189
    tmp___10 = __errno_location();
#line 189
    tmp___11 = strerror(*tmp___10);
#line 189
    packet_disconnect("listen: %.100s", tmp___11);
  }
#line 192
  tmp___13 = xstrdup("auth socket");
#line 192
  nc = channel_new((char *)"auth socket", 6, sock, sock, -1, 65536U, 16384U, 0, tmp___13,
                   1);
#line 196
  strlcpy(nc->path, (char const   *)auth_sock_name, sizeof(nc->path));
#line 197
  return (1);
}
}
#line 201 "session.c"
void do_authenticated(Authctxt *authctxt___0 ) 
{ 

  {
#line 208
  alarm(0U);
#line 209
  if (startup_pipe != -1) {
#line 210
    close(startup_pipe);
#line 211
    startup_pipe = -1;
  }
#line 222
  if (! no_port_forwarding_flag) {
#line 222
    if (options.allow_tcp_forwarding) {
#line 223
      channel_permit_all_opens();
    }
  }
#line 225
  if (compat20) {
#line 226
    do_authenticated2(authctxt___0);
  } else {
#line 228
    do_authenticated1(authctxt___0);
  }
#line 231
  if ((unsigned int )auth_sock_name != (unsigned int )((void *)0)) {
#line 232
    auth_sock_cleanup_proc((void *)authctxt___0->pw);
  }
#line 241
  return;
}
}
#line 249 "session.c"
static void do_authenticated1(Authctxt *authctxt___0 ) 
{ Session *s ;
  char *command ;
  int success ;
  int type ;
  int screen_flag ;
  int enable_compression_after_reply ;
  u_int proto_len ;
  u_int data_len ;
  u_int dlen ;
  u_int compression_level ;
  int _len ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  u_int tmp___2 ;
  int tmp___3 ;
  int _len___0 ;
  int tmp___4 ;
  u_int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  int _len___1 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 255
  enable_compression_after_reply = 0;
#line 256
  compression_level = (u_int )0;
#line 258
  s = session_new();
#line 259
  s->authctxt = authctxt___0;
#line 260
  s->pw = authctxt___0->pw;
#line 266
  while (1) {
#line 267
    success = 0;
#line 270
    type = packet_read();
#line 273
    switch (type) {
    case 37: 
#line 275
    compression_level = packet_get_int();
#line 276
    while (1) {
#line 276
      tmp = packet_remaining();
#line 276
      _len = tmp;
#line 276
      if (_len > 0) {
#line 276
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            276);
#line 276
        packet_disconnect("Packet integrity error.");
      }
#line 276
      break;
    }
#line 277
    if (compression_level < 1U) {
#line 278
      packet_send_debug("Received illegal compression level %d.", compression_level);
#line 280
      break;
    } else {
#line 277
      if (compression_level > 9U) {
#line 278
        packet_send_debug("Received illegal compression level %d.", compression_level);
#line 280
        break;
      }
    }
#line 282
    if (! options.compression) {
#line 283
      debug2("compression disabled");
#line 284
      break;
    }
#line 287
    enable_compression_after_reply = 1;
#line 288
    success = 1;
#line 289
    break;
    case 10: 
#line 292
    success = session_pty_req(s);
#line 293
    break;
    case 34: 
#line 296
    tmp___0 = packet_get_string(& proto_len);
#line 296
    s->auth_proto = (char *)tmp___0;
#line 297
    tmp___1 = packet_get_string(& data_len);
#line 297
    s->auth_data = (char *)tmp___1;
#line 299
    tmp___2 = packet_get_protocol_flags();
#line 299
    screen_flag = (int )(tmp___2 & 1U);
#line 301
    debug2("SSH_PROTOFLAG_SCREEN_NUMBER: %d", screen_flag);
#line 303
    tmp___3 = packet_remaining();
#line 303
    if (tmp___3 == 4) {
#line 304
      if (! screen_flag) {
#line 305
        debug2("Buggy client: X11 screen flag missing");
      }
#line 307
      s->screen = packet_get_int();
    } else {
#line 309
      s->screen = 0U;
    }
#line 311
    while (1) {
#line 311
      tmp___4 = packet_remaining();
#line 311
      _len___0 = tmp___4;
#line 311
      if (_len___0 > 0) {
#line 311
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "session.c",
            311);
#line 311
        packet_disconnect("Packet integrity error.");
      }
#line 311
      break;
    }
#line 312
    success = session_setup_x11fwd(s);
#line 313
    if (! success) {
#line 314
      xfree((void *)s->auth_proto);
#line 315
      xfree((void *)s->auth_data);
#line 316
      s->auth_proto = (char *)((void *)0);
#line 317
      s->auth_data = (char *)((void *)0);
    }
#line 319
    break;
    case 30: 
#line 322
    if (no_agent_forwarding_flag) {
#line 323
      debug("Authentication agent forwarding not permitted for this authentication.");
#line 324
      break;
    } else {
#line 322
      if (compat13) {
#line 323
        debug("Authentication agent forwarding not permitted for this authentication.");
#line 324
        break;
      }
    }
#line 326
    debug("Received authentication agent forwarding request.");
#line 327
    success = auth_input_request_forwarding(s->pw);
#line 328
    break;
    case 28: 
#line 331
    if (no_port_forwarding_flag) {
#line 332
      debug("Port forwarding not permitted for this authentication.");
#line 333
      break;
    }
#line 335
    if (! options.allow_tcp_forwarding) {
#line 336
      debug("Port forwarding not permitted.");
#line 337
      break;
    }
#line 339
    debug("Received TCP/IP port forwarding request.");
#line 340
    channel_input_port_forward_request((s->pw)->pw_uid == 0U, options.gateway_ports);
#line 341
    success = 1;
#line 342
    break;
    case 38: 
#line 345
    tmp___5 = packet_get_int();
#line 345
    tmp___6 = packet_set_maxsize((int )tmp___5);
#line 345
    if (tmp___6 > 0) {
#line 346
      success = 1;
    }
#line 347
    break;
    case 12: 
    case 13: 
#line 403
    if (type == 13) {
#line 404
      tmp___7 = packet_get_string(& dlen);
#line 404
      command = (char *)tmp___7;
#line 405
      debug("Exec command \'%.500s\'", command);
#line 406
      do_exec(s, (char const   *)command);
#line 407
      xfree((void *)command);
    } else {
#line 409
      do_exec(s, (char const   *)((void *)0));
    }
#line 411
    while (1) {
#line 411
      tmp___8 = packet_remaining();
#line 411
      _len___1 = tmp___8;
#line 411
      if (_len___1 > 0) {
#line 411
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len___1, "session.c",
            411);
#line 411
        packet_disconnect("Packet integrity error.");
      }
#line 411
      break;
    }
#line 412
    session_close(s);
#line 413
    return;
    default: 
#line 420
    log("Unknown packet type received after authentication: %d", type);
    }
#line 422
    if (success) {
#line 422
      tmp___9 = 14;
    } else {
#line 422
      tmp___9 = 15;
    }
#line 422
    packet_start((unsigned char )tmp___9);
#line 423
    packet_send();
#line 424
    packet_write_wait();
#line 427
    if (enable_compression_after_reply) {
#line 428
      enable_compression_after_reply = 0;
#line 429
      packet_start_compression((int )compression_level);
    }
  }
}
}
#line 439 "session.c"
void do_exec_no_pty(Session *s , char const   *command ) 
{ pid_t pid ;
  int inout[2] ;
  int err[2] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  __pid_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
#line 453
  tmp___1 = socketpair(1, 1, 0, (int *)(inout));
#line 453
  if (tmp___1 < 0) {
#line 455
    tmp = __errno_location();
#line 455
    tmp___0 = strerror(*tmp);
#line 455
    packet_disconnect("Could not create socket pairs: %.100s", tmp___0);
  } else {
#line 453
    tmp___2 = socketpair(1, 1, 0, (int *)(err));
#line 453
    if (tmp___2 < 0) {
#line 455
      tmp = __errno_location();
#line 455
      tmp___0 = strerror(*tmp);
#line 455
      packet_disconnect("Could not create socket pairs: %.100s", tmp___0);
    }
  }
#line 458
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 459
    fatal("do_exec_no_pty: no session");
  }
#line 461
  session_proctitle(s);
#line 472
  pid = fork();
#line 472
  if (pid == 0) {
#line 474
    log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 480
    tmp___5 = setsid();
#line 480
    if (tmp___5 < 0) {
#line 481
      tmp___3 = __errno_location();
#line 481
      tmp___4 = strerror(*tmp___3);
#line 481
      error("setsid failed: %.100s", tmp___4);
    }
#line 510
    close(inout[1]);
#line 511
    close(err[1]);
#line 512
    tmp___6 = dup2(inout[0], 0);
#line 512
    if (tmp___6 < 0) {
#line 513
      perror("dup2 stdin");
    }
#line 514
    tmp___7 = dup2(inout[0], 1);
#line 514
    if (tmp___7 < 0) {
#line 515
      perror("dup2 stdout");
    }
#line 516
    tmp___8 = dup2(err[0], 2);
#line 516
    if (tmp___8 < 0) {
#line 517
      perror("dup2 stderr");
    }
#line 521
    do_child(s, command);
  }
#line 528
  if (pid < 0) {
#line 529
    tmp___9 = __errno_location();
#line 529
    tmp___10 = strerror(*tmp___9);
#line 529
    packet_disconnect("fork failed: %.100s", tmp___10);
  }
#line 530
  s->pid = pid;
#line 532
  packet_set_interactive((unsigned int )s->display != (unsigned int )((void *)0));
#line 548
  close(inout[0]);
#line 549
  close(err[0]);
#line 555
  if (compat20) {
#line 556
    if (s->is_subsystem) {
#line 556
      tmp___11 = -1;
    } else {
#line 556
      tmp___11 = err[1];
    }
#line 556
    session_set_fds(s, inout[1], inout[1], tmp___11);
  } else {
#line 558
    server_loop(pid, inout[1], inout[1], err[1]);
  }
#line 562
  return;
}
}
#line 570 "session.c"
void do_exec_pty(Session *s , char const   *command ) 
{ int fdout___0 ;
  int ptyfd ;
  int ttyfd ;
  int ptymaster ;
  pid_t pid ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;

  {
#line 576
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 577
    fatal("do_exec_pty: no session");
  }
#line 578
  ptyfd = s->ptyfd;
#line 579
  ttyfd = s->ttyfd;
#line 587
  pid = fork();
#line 587
  if (pid == 0) {
#line 590
    log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 592
    close(ptyfd);
#line 595
    pty_make_controlling_tty(& ttyfd, (char const   *)(s->tty));
#line 598
    tmp___1 = dup2(ttyfd, 0);
#line 598
    if (tmp___1 < 0) {
#line 599
      tmp = __errno_location();
#line 599
      tmp___0 = strerror(*tmp);
#line 599
      error("dup2 stdin: %s", tmp___0);
    }
#line 600
    tmp___4 = dup2(ttyfd, 1);
#line 600
    if (tmp___4 < 0) {
#line 601
      tmp___2 = __errno_location();
#line 601
      tmp___3 = strerror(*tmp___2);
#line 601
      error("dup2 stdout: %s", tmp___3);
    }
#line 602
    tmp___7 = dup2(ttyfd, 2);
#line 602
    if (tmp___7 < 0) {
#line 603
      tmp___5 = __errno_location();
#line 603
      tmp___6 = strerror(*tmp___5);
#line 603
      error("dup2 stderr: %s", tmp___6);
    }
#line 606
    close(ttyfd);
#line 610
    if (options.use_login) {
#line 610
      if (! ((unsigned int )command == (unsigned int )((void *)0))) {
#line 611
        do_login(s, command);
      }
    } else {
#line 611
      do_login(s, command);
    }
#line 619
    do_child(s, command);
  }
#line 626
  if (pid < 0) {
#line 627
    tmp___8 = __errno_location();
#line 627
    tmp___9 = strerror(*tmp___8);
#line 627
    packet_disconnect("fork failed: %.100s", tmp___9);
  }
#line 628
  s->pid = pid;
#line 631
  close(ttyfd);
#line 638
  fdout___0 = dup(ptyfd);
#line 639
  if (fdout___0 < 0) {
#line 640
    tmp___10 = __errno_location();
#line 640
    tmp___11 = strerror(*tmp___10);
#line 640
    packet_disconnect("dup #1 failed: %.100s", tmp___11);
  }
#line 643
  ptymaster = dup(ptyfd);
#line 644
  if (ptymaster < 0) {
#line 645
    tmp___12 = __errno_location();
#line 645
    tmp___13 = strerror(*tmp___12);
#line 645
    packet_disconnect("dup #2 failed: %.100s", tmp___13);
  }
#line 646
  s->ptymaster = ptymaster;
#line 649
  packet_set_interactive(1);
#line 650
  if (compat20) {
#line 651
    session_set_fds(s, ptyfd, fdout___0, -1);
  } else {
#line 653
    server_loop(pid, ptyfd, fdout___0, -1);
  }
#line 656
  return;
}
}
#line 690 "session.c"
void do_exec(Session *s , char const   *command ) 
{ 

  {
#line 693
  if (forced_command) {
#line 694
    original_command = command;
#line 695
    command = (char const   *)forced_command;
#line 696
    debug("Forced command \'%.900s\'", command);
  }
#line 699
  if (s->ttyfd != -1) {
#line 700
    do_exec_pty(s, command);
  } else {
#line 702
    do_exec_no_pty(s, command);
  }
#line 704
  original_command = (char const   *)((void *)0);
#line 705
  return;
}
}
#line 709 "session.c"
void do_login(Session *s , char const   *command ) 
{ char *time_string ;
  socklen_t fromlen ;
  struct sockaddr_storage from ;
  struct passwd *pw ;
  pid_t pid ;
  __pid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  char *tmp___8 ;
  char *tmp___10 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___16 ;
  int tmp___19 ;
  int tmp___20 ;

  {
#line 715
  pw = s->pw;
#line 716
  tmp = getpid();
#line 716
  pid = tmp;
#line 722
  memset((void *)(& from), 0, sizeof(from));
#line 723
  tmp___4 = packet_connection_is_on_socket();
#line 723
  if (tmp___4) {
#line 724
    fromlen = sizeof(from);
#line 725
    tmp___2 = packet_get_connection_in();
#line 725
    tmp___3 = getpeername(tmp___2, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 725
    if (tmp___3 < 0) {
#line 727
      tmp___0 = __errno_location();
#line 727
      tmp___1 = strerror(*tmp___0);
#line 727
      debug("getpeername: %.100s", tmp___1);
#line 728
      fatal_cleanup();
    }
  }
#line 733
  if (! use_privsep) {
#line 734
    tmp___5 = get_remote_name_or_ip(utmp_len, options.verify_reverse_mapping);
#line 734
    record_login(pid, (char const   *)(s->tty), (char const   *)pw->pw_name, pw->pw_uid,
                 tmp___5, (struct sockaddr *)(& from));
  }
#line 750
  tmp___6 = check_quietlogin(s, command);
#line 750
  if (tmp___6) {
#line 751
    return;
  }
#line 762
  if (options.print_lastlog) {
#line 762
    if (s->last_login_time != 0L) {
#line 763
      time_string = ctime((time_t const   *)(& s->last_login_time));
#line 764
      tmp___10 = __builtin_strchr(time_string, '\n');
#line 764
      if (tmp___10) {
#line 765
        tmp___8 = __builtin_strchr(time_string, '\n');
#line 765
        *tmp___8 = (char)0;
      }
#line 766
      if (0) {
#line 766
        __s1_len = strlen((char const   *)(s->hostname));
#line 766
        __s2_len = strlen("");
#line 766
        if (! ((unsigned int )((void const   *)(s->hostname + 1)) - (unsigned int )((void const   *)(s->hostname)) == 1U)) {
          goto _L___0;
        } else {
#line 766
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 766
            if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 766
              tmp___20 = 1;
            } else {
#line 766
              if (__s2_len >= 4U) {
#line 766
                tmp___20 = 1;
              } else {
#line 766
                tmp___20 = 0;
              }
            }
          } else {
#line 766
            tmp___20 = 0;
          }
        }
#line 766
        if (tmp___20) {
#line 766
          tmp___16 = __builtin_strcmp((char const   *)(s->hostname), "");
        } else {
#line 766
          tmp___19 = __builtin_strcmp((char const   *)(s->hostname), "");
#line 766
          tmp___16 = tmp___19;
        }
      } else {
#line 766
        tmp___19 = __builtin_strcmp((char const   *)(s->hostname), "");
#line 766
        tmp___16 = tmp___19;
      }
#line 766
      if (tmp___16 == 0) {
#line 767
        printf((char const   * __restrict  )"Last login: %s\r\n", time_string);
      } else {
#line 769
        printf((char const   * __restrict  )"Last login: %s from %s\r\n", time_string,
               s->hostname);
      }
    }
  }
#line 773
  do_motd();
#line 774
  return;
}
}
#line 779 "session.c"
void do_motd(void) 
{ FILE *f ;
  char buf___1[256] ;
  char *tmp ;

  {
#line 785
  if (options.print_motd) {
#line 790
    f = fopen((char const   * __restrict  )"/etc/motd", (char const   * __restrict  )"r");
#line 792
    if (f) {
#line 793
      while (1) {
#line 793
        tmp = fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )f);
#line 793
        if (! tmp) {
#line 793
          break;
        }
#line 794
        fputs((char const   * __restrict  )(buf___1), (FILE * __restrict  )stdout);
      }
#line 795
      fclose(f);
    }
  }
#line 798
  return;
}
}
#line 804 "session.c"
int check_quietlogin(Session *s , char const   *command ) 
{ char buf___1[256] ;
  struct passwd *pw ;
  struct stat st ;
  int tmp ;

  {
#line 808
  pw = s->pw;
#line 812
  if ((unsigned int )command != (unsigned int )((void *)0)) {
#line 813
    return (1);
  }
#line 814
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.200s/.hushlogin",
           pw->pw_dir);
#line 819
  tmp = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )(& st));
#line 819
  if (tmp >= 0) {
#line 820
    return (1);
  }
#line 822
  return (0);
}
}
#line 829 "session.c"
static void child_set_env(char ***envp , u_int *envsizep , char const   *name , char const   *value ) 
{ u_int i ;
  u_int namelen ;
  char **env ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  void *tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  void *tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;

  {
#line 841
  env = *envp;
#line 842
  namelen = strlen(name);
#line 843
  i = 0U;
#line 843
  while (*(env + i)) {
#line 844
    if (0) {
#line 844
      if (0) {
#line 844
        __s1_len___0 = strlen((char const   *)*(env + i));
#line 844
        __s2_len___0 = strlen(name);
#line 844
        if (! ((unsigned int )((void const   *)(*(env + i) + 1)) - (unsigned int )((void const   *)*(env + i)) == 1U)) {
          goto _L___2;
        } else {
#line 844
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 844
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
#line 844
              tmp___22 = 1;
            } else {
#line 844
              if (__s2_len___0 >= 4U) {
#line 844
                tmp___22 = 1;
              } else {
#line 844
                tmp___22 = 0;
              }
            }
          } else {
#line 844
            tmp___22 = 0;
          }
        }
#line 844
        if (tmp___22) {
#line 844
          tmp___18 = __builtin_strcmp((char const   *)*(env + i), name);
        } else {
#line 844
          tmp___21 = __builtin_strcmp((char const   *)*(env + i), name);
#line 844
          tmp___18 = tmp___21;
        }
      } else {
#line 844
        tmp___21 = __builtin_strcmp((char const   *)*(env + i), name);
#line 844
        tmp___18 = tmp___21;
      }
#line 844
      tmp___12 = tmp___18;
    } else {
#line 844
      tmp___12 = strncmp((char const   *)*(env + i), name, namelen);
    }
#line 844
    if (tmp___12 == 0) {
#line 844
      if ((int )*(*(env + i) + namelen) == 61) {
#line 845
        break;
      }
    }
#line 843
    i ++;
  }
#line 846
  if (*(env + i)) {
#line 848
    xfree((void *)*(env + i));
  } else {
#line 851
    if (i >= *envsizep - 1U) {
#line 852
      if (*envsizep >= 1000U) {
#line 853
        fatal("child_set_env: too many env vars, skipping: %.100s", name);
      }
#line 855
      *envsizep += 50U;
#line 856
      tmp___25 = xrealloc((void *)env, *envsizep * sizeof(char *));
#line 856
      *envp = (char **)tmp___25;
#line 856
      env = *envp;
    }
#line 859
    *(env + (i + 1U)) = (char *)((void *)0);
  }
#line 863
  tmp___26 = strlen(name);
#line 863
  tmp___27 = strlen(value);
#line 863
  tmp___28 = xmalloc(((tmp___26 + 1U) + tmp___27) + 1U);
#line 863
  *(env + i) = (char *)tmp___28;
#line 864
  tmp___29 = strlen(name);
#line 864
  tmp___30 = strlen(value);
#line 864
  snprintf((char * __restrict  )*(env + i), ((tmp___29 + 1U) + tmp___30) + 1U, (char const   * __restrict  )"%s=%s",
           name, value);
#line 865
  return;
}
}
#line 873 "session.c"
static void read_environment_file(char ***env , u_int *envsize , char const   *filename ) 
{ FILE *f ;
  char buf___1[4096] ;
  char *cp ;
  char *value ;
  u_int lineno ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 880
  lineno = (u_int )0;
#line 882
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 883
  if (! f) {
#line 884
    return;
  }
#line 886
  while (1) {
#line 886
    tmp___5 = fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )f);
#line 886
    if (! tmp___5) {
#line 886
      break;
    }
#line 887
    lineno ++;
#line 887
    if (lineno > 1000U) {
#line 888
      fatal("Too many lines in environment file %s", filename);
    }
#line 889
    cp = buf___1;
#line 889
    while (1) {
#line 889
      if (! ((int )*cp == 32)) {
#line 889
        if (! ((int )*cp == 9)) {
#line 889
          break;
        }
      }
#line 889
      cp ++;
    }
#line 891
    if (! *cp) {
#line 892
      continue;
    } else {
#line 891
      if ((int )*cp == 35) {
#line 892
        continue;
      } else {
#line 891
        if ((int )*cp == 10) {
#line 892
          continue;
        }
      }
    }
#line 893
    tmp___2 = __builtin_strchr(cp, '\n');
#line 893
    if (tmp___2) {
#line 894
      tmp___0 = __builtin_strchr(cp, '\n');
#line 894
      *tmp___0 = (char )'\000';
    }
#line 895
    tmp___4 = __builtin_strchr(cp, '=');
#line 895
    value = tmp___4;
#line 896
    if ((unsigned int )value == (unsigned int )((void *)0)) {
#line 897
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad line %u in %.100s\n",
              lineno, filename);
#line 899
      continue;
    }
#line 905
    *value = (char )'\000';
#line 906
    value ++;
#line 907
    child_set_env(env, envsize, (char const   *)cp, (char const   *)value);
  }
#line 909
  fclose(f);
#line 910
  return;
}
}
#line 912 "session.c"
void copy_environment(char **source , char ***env , u_int *envsize ) 
{ char *var_name ;
  char *var_val ;
  int i ;
  char *tmp ;

  {
#line 917
  if ((unsigned int )source == (unsigned int )((void *)0)) {
#line 918
    return;
  }
#line 920
  i = 0;
#line 920
  while ((unsigned int )*(source + i) != (unsigned int )((void *)0)) {
#line 921
    var_name = xstrdup((char const   *)*(source + i));
#line 922
    var_val = strstr((char const   *)var_name, "=");
#line 922
    if ((unsigned int )var_val == (unsigned int )((void *)0)) {
#line 923
      xfree((void *)var_name);
      goto __Cont;
    }
#line 926
    tmp = var_val;
#line 926
    var_val ++;
#line 926
    *tmp = (char )'\000';
#line 928
    debug3("Copy environment: %s=%s", var_name, var_val);
#line 929
    child_set_env(env, envsize, (char const   *)var_name, (char const   *)var_val);
#line 931
    xfree((void *)var_name);
    __Cont: /* CIL Label */ 
#line 920
    i ++;
  }
#line 933
  return;
}
}
#line 935 "session.c"
static char **do_setup_env(Session *s , char const   *shell ) 
{ char buf___1[256] ;
  u_int i ;
  u_int envsize ;
  char **env ;
  struct passwd *pw ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  struct envstring *ce ;
  char *s___0 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;

  {
#line 941
  pw = s->pw;
#line 944
  envsize = 100U;
#line 945
  tmp = xmalloc(envsize * sizeof(char *));
#line 945
  env = (char **)tmp;
#line 946
  *(env + 0) = (char *)((void *)0);
#line 956
  if (! options.use_login) {
#line 958
    child_set_env(& env, & envsize, "USER", (char const   *)pw->pw_name);
#line 959
    child_set_env(& env, & envsize, "LOGNAME", (char const   *)pw->pw_name);
#line 960
    child_set_env(& env, & envsize, "HOME", (char const   *)pw->pw_dir);
#line 976
    child_set_env(& env, & envsize, "PATH", "/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin");
#line 981
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.200s/%.50s",
             "/var/mail", pw->pw_name);
#line 983
    child_set_env(& env, & envsize, "MAIL", (char const   *)(buf___1));
#line 986
    child_set_env(& env, & envsize, "SHELL", shell);
  }
#line 988
  tmp___1 = getenv("TZ");
#line 988
  if (tmp___1) {
#line 989
    tmp___0 = getenv("TZ");
#line 989
    child_set_env(& env, & envsize, "TZ", (char const   *)tmp___0);
  }
#line 992
  if (! options.use_login) {
#line 993
    while (custom_environment) {
#line 994
      ce = custom_environment;
#line 995
      s___0 = ce->s;
#line 997
      i = 0U;
#line 997
      while (1) {
#line 997
        if ((int )*(s___0 + i) != 61) {
#line 997
          if (! *(s___0 + i)) {
#line 997
            break;
          }
        } else {
#line 997
          break;
        }
#line 997
        i ++;
      }
#line 999
      if ((int )*(s___0 + i) == 61) {
#line 1000
        *(s___0 + i) = (char)0;
#line 1001
        child_set_env(& env, & envsize, (char const   *)s___0, (char const   *)((s___0 + i) + 1));
      }
#line 1003
      custom_environment = ce->next;
#line 1004
      xfree((void *)ce->s);
#line 1005
      xfree((void *)ce);
    }
  }
#line 1009
  tmp___2 = get_local_port();
#line 1009
  tmp___3 = get_remote_port();
#line 1009
  tmp___4 = get_remote_ipaddr();
#line 1009
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.50s %d %d",
           tmp___4, tmp___3, tmp___2);
#line 1011
  child_set_env(& env, & envsize, "SSH_CLIENT", (char const   *)(buf___1));
#line 1013
  if (s->ttyfd != -1) {
#line 1014
    child_set_env(& env, & envsize, "SSH_TTY", (char const   *)(s->tty));
  }
#line 1015
  if (s->term) {
#line 1016
    child_set_env(& env, & envsize, "TERM", (char const   *)s->term);
  }
#line 1017
  if (s->display) {
#line 1018
    child_set_env(& env, & envsize, "DISPLAY", (char const   *)s->display);
  }
#line 1019
  if (original_command) {
#line 1020
    child_set_env(& env, & envsize, "SSH_ORIGINAL_COMMAND", original_command);
  }
#line 1049
  if ((unsigned int )auth_sock_name != (unsigned int )((void *)0)) {
#line 1050
    child_set_env(& env, & envsize, "SSH_AUTH_SOCK", (char const   *)auth_sock_name);
  }
#line 1054
  if (! options.use_login) {
#line 1055
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.200s/.ssh/environment",
             pw->pw_dir);
#line 1057
    read_environment_file(& env, & envsize, (char const   *)(buf___1));
  }
#line 1059
  if (debug_flag) {
#line 1061
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Environment:\n");
#line 1062
    i = 0U;
#line 1062
    while (*(env + i)) {
#line 1063
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  %.200s\n",
              *(env + i));
#line 1062
      i ++;
    }
  }
#line 1065
  return (env);
}
}
#line 1072 "session.c"
static void do_rc_files(Session *s , char const   *shell ) 
{ FILE *f ;
  char cmd[1024] ;
  int do_xauth ;
  struct stat st ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1075
  f = (FILE *)((void *)0);
#line 1080
  if ((unsigned int )s->display != (unsigned int )((void *)0)) {
#line 1080
    if ((unsigned int )s->auth_proto != (unsigned int )((void *)0)) {
#line 1080
      if ((unsigned int )s->auth_data != (unsigned int )((void *)0)) {
#line 1080
        tmp = 1;
      } else {
#line 1080
        tmp = 0;
      }
    } else {
#line 1080
      tmp = 0;
    }
  } else {
#line 1080
    tmp = 0;
  }
#line 1080
  do_xauth = tmp;
#line 1084
  if (! s->is_subsystem) {
#line 1084
    tmp___1 = stat((char const   * __restrict  )".ssh/rc", (struct stat * __restrict  )(& st));
#line 1084
    if (tmp___1 >= 0) {
#line 1085
      snprintf((char * __restrict  )(cmd), sizeof(cmd), (char const   * __restrict  )"%s -c \'%s %s\'",
               shell, "/bin/sh", ".ssh/rc");
#line 1087
      if (debug_flag) {
#line 1088
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %s\n",
                cmd);
      }
#line 1089
      f = popen((char const   *)(cmd), "w");
#line 1090
      if (f) {
#line 1091
        if (do_xauth) {
#line 1092
          fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                  s->auth_proto, s->auth_data);
        }
#line 1094
        pclose(f);
      } else {
#line 1096
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                ".ssh/rc");
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1098
    tmp___0 = stat((char const   * __restrict  )"/usr/local/etc/sshrc", (struct stat * __restrict  )(& st));
#line 1098
    if (tmp___0 >= 0) {
#line 1099
      if (debug_flag) {
#line 1100
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %s %s\n",
                "/bin/sh", "/usr/local/etc/sshrc");
      }
#line 1102
      f = popen("/bin/sh /usr/local/etc/sshrc", "w");
#line 1103
      if (f) {
#line 1104
        if (do_xauth) {
#line 1105
          fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                  s->auth_proto, s->auth_data);
        }
#line 1107
        pclose(f);
      } else {
#line 1109
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                "/usr/local/etc/sshrc");
      }
    } else {
#line 1111
      if (do_xauth) {
#line 1111
        if ((unsigned int )options.xauth_location != (unsigned int )((void *)0)) {
#line 1113
          if (debug_flag) {
#line 1114
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %.500s add %.100s %.100s %.100s\n",
                    options.xauth_location, s->auth_display, s->auth_proto, s->auth_data);
          }
#line 1120
          snprintf((char * __restrict  )(cmd), sizeof(cmd), (char const   * __restrict  )"%s -q -",
                   options.xauth_location);
#line 1122
          f = popen((char const   *)(cmd), "w");
#line 1123
          if (f) {
#line 1124
            fprintf((FILE * __restrict  )f, (char const   * __restrict  )"add %s %s %s\n",
                    s->auth_display, s->auth_proto, s->auth_data);
#line 1127
            pclose(f);
          } else {
#line 1129
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                    cmd);
          }
        }
      }
    }
  }
#line 1133
  return;
}
}
#line 1135 "session.c"
static void do_nologin(struct passwd *pw ) 
{ FILE *f ;
  char buf___1[1024] ;
  char *tmp ;

  {
#line 1138
  f = (FILE *)((void *)0);
#line 1146
  if (pw->pw_uid) {
#line 1147
    f = fopen((char const   * __restrict  )"/etc/nologin", (char const   * __restrict  )"r");
  }
#line 1149
  if (f) {
#line 1151
    while (1) {
#line 1151
      tmp = fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )f);
#line 1151
      if (! tmp) {
#line 1151
        break;
      }
#line 1152
      fputs((char const   * __restrict  )(buf___1), (FILE * __restrict  )stderr);
    }
#line 1153
    fclose(f);
#line 1154
    exit(254);
  }
#line 1156
  return;
}
}
#line 1159 "session.c"
void do_setusercontext(struct passwd *pw ) 
{ char tty ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  __uid_t tmp___4 ;
  __uid_t tmp___5 ;
  __uid_t tmp___6 ;
  __uid_t tmp___7 ;

  {
#line 1162
  tty = (char )'\000';
#line 1167
  tmp___4 = getuid();
#line 1167
  if (tmp___4 == 0U) {
    goto _L;
  } else {
#line 1167
    tmp___5 = geteuid();
#line 1167
    if (tmp___5 == 0U) {
      _L: /* CIL Label */ 
#line 1188
      tmp___1 = setlogin((char const   *)pw->pw_name);
#line 1188
      if (tmp___1 < 0) {
#line 1189
        tmp = __errno_location();
#line 1189
        tmp___0 = strerror(*tmp);
#line 1189
        error("setlogin failed: %s", tmp___0);
      }
#line 1190
      tmp___2 = setgid(pw->pw_gid);
#line 1190
      if (tmp___2 < 0) {
#line 1191
        perror("setgid");
#line 1192
        exit(1);
      }
#line 1195
      tmp___3 = initgroups((char const   *)pw->pw_name, pw->pw_gid);
#line 1195
      if (tmp___3 < 0) {
#line 1196
        perror("initgroups");
#line 1197
        exit(1);
      }
#line 1199
      endgrent();
#line 1216
      permanently_set_uid(pw);
    }
  }
#line 1219
  tmp___6 = getuid();
#line 1219
  if (tmp___6 != pw->pw_uid) {
#line 1220
    fatal("Failed to set uids to %u.", pw->pw_uid);
  } else {
#line 1219
    tmp___7 = geteuid();
#line 1219
    if (tmp___7 != pw->pw_uid) {
#line 1220
      fatal("Failed to set uids to %u.", pw->pw_uid);
    }
  }
#line 1221
  return;
}
}
#line 1223 "session.c"
static void launch_login(struct passwd *pw , char const   *hostname ) 
{ 

  {
#line 1228
  execl("/bin/login", "login", "-h", hostname, "-p", "-f", "--", pw->pw_name, (char *)((void *)0));
#line 1240
  perror("login");
#line 1241
  exit(1);
}
}
#line 1252
extern char **environ ;
#line 1249 "session.c"
void do_child(Session *s , char const   *command ) 
{ char **env ;
  char *argv[10] ;
  char const   *shell ;
  char const   *shell0 ;
  char const   *hostname ;
  struct passwd *pw ;
  u_int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char argv0___0[256] ;
  int *tmp___8 ;
  size_t tmp___9 ;

  {
#line 1255
  hostname = (char const   *)((void *)0);
#line 1256
  pw = s->pw;
#line 1260
  destroy_sensitive_data();
#line 1263
  if (options.use_login) {
#line 1263
    if ((unsigned int )command != (unsigned int )((void *)0)) {
#line 1264
      options.use_login = 0;
    }
  }
#line 1270
  if (! options.use_login) {
#line 1276
    do_nologin(pw);
#line 1277
    do_setusercontext(pw);
  }
#line 1285
  if ((int )*(pw->pw_shell + 0) == 0) {
#line 1285
    shell = "/bin/sh";
  } else {
#line 1285
    shell = (char const   *)pw->pw_shell;
  }
#line 1290
  env = do_setup_env(s, shell);
#line 1293
  if (options.use_login) {
#line 1294
    hostname = get_remote_name_or_ip(utmp_len, options.verify_reverse_mapping);
  }
#line 1303
  tmp___2 = packet_get_connection_in();
#line 1303
  tmp___3 = packet_get_connection_out();
#line 1303
  if (tmp___2 == tmp___3) {
#line 1304
    tmp = packet_get_connection_in();
#line 1304
    close(tmp);
  } else {
#line 1306
    tmp___0 = packet_get_connection_in();
#line 1306
    close(tmp___0);
#line 1307
    tmp___1 = packet_get_connection_out();
#line 1307
    close(tmp___1);
  }
#line 1314
  channel_close_all();
#line 1320
  endpwent();
#line 1328
  i = 3U;
#line 1328
  while (i < 64U) {
#line 1329
    close((int )i);
#line 1328
    i ++;
  }
#line 1335
  environ = env;
#line 1350
  tmp___6 = chdir((char const   *)pw->pw_dir);
#line 1350
  if (tmp___6 < 0) {
#line 1351
    tmp___4 = __errno_location();
#line 1351
    tmp___5 = strerror(*tmp___4);
#line 1351
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not chdir to home directory %s: %s\n",
            pw->pw_dir, tmp___5);
  }
#line 1359
  if (! options.use_login) {
#line 1360
    do_rc_files(s, shell);
  }
#line 1363
  signal(13, (void (*)(int  ))0);
#line 1365
  if (options.use_login) {
#line 1366
    launch_login(pw, hostname);
  }
#line 1371
  tmp___7 = strrchr(shell, '/');
#line 1371
  shell0 = (char const   *)tmp___7;
#line 1371
  if ((unsigned int )shell0 != (unsigned int )((void *)0)) {
#line 1372
    shell0 ++;
  } else {
#line 1374
    shell0 = shell;
  }
#line 1381
  if (! command) {
#line 1385
    argv0___0[0] = (char )'-';
#line 1387
    tmp___9 = strlcpy(argv0___0 + 1, shell0, sizeof(argv0___0) - 1U);
#line 1387
    if (tmp___9 >= sizeof(argv0___0) - 1U) {
#line 1389
      tmp___8 = __errno_location();
#line 1389
      *tmp___8 = 22;
#line 1390
      perror(shell);
#line 1391
      exit(1);
    }
#line 1395
    argv[0] = argv0___0;
#line 1396
    argv[1] = (char *)((void *)0);
#line 1397
    execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 1400
    perror(shell);
#line 1401
    exit(1);
  }
#line 1407
  argv[0] = (char *)shell0;
#line 1408
  argv[1] = (char *)"-c";
#line 1409
  argv[2] = (char *)command;
#line 1410
  argv[3] = (char *)((void *)0);
#line 1411
  execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 1412
  perror(shell);
#line 1413
  exit(1);
}
}
#line 1420 "session.c"
static int did_init___0  =    0;
#line 1416 "session.c"
Session *session_new(void) 
{ int i ;
  Session *s ;

  {
#line 1421
  if (! did_init___0) {
#line 1422
    debug("session_new: init");
#line 1423
    i = 0;
#line 1423
    while (i < 10) {
#line 1424
      sessions[i].used = 0;
#line 1423
      i ++;
    }
#line 1426
    did_init___0 = 1;
  }
#line 1428
  i = 0;
#line 1428
  while (i < 10) {
#line 1429
    s = & sessions[i];
#line 1430
    if (! s->used) {
#line 1431
      memset((void *)s, 0, sizeof(*s));
#line 1432
      s->chanid = -1;
#line 1433
      s->ptyfd = -1;
#line 1434
      s->ttyfd = -1;
#line 1435
      s->used = 1;
#line 1436
      s->self = i;
#line 1437
      debug("session_new: session %d", i);
#line 1438
      return (s);
    }
#line 1428
    i ++;
  }
#line 1441
  return ((Session *)((void *)0));
}
}
#line 1444 "session.c"
static void session_dump(void) 
{ int i ;
  Session *s ;

  {
#line 1448
  i = 0;
#line 1448
  while (i < 10) {
#line 1449
    s = & sessions[i];
#line 1450
    debug("dump: used %d session %d %p channel %d pid %ld", s->used, s->self, s, s->chanid,
          (long )s->pid);
#line 1448
    i ++;
  }
#line 1457
  return;
}
}
#line 1459 "session.c"
int session_open(Authctxt *authctxt___0 , int chanid ) 
{ Session *s ;
  Session *tmp ;

  {
#line 1462
  tmp = session_new();
#line 1462
  s = tmp;
#line 1463
  debug("session_open: channel %d", chanid);
#line 1464
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1465
    error("no more sessions");
#line 1466
    return (0);
  }
#line 1468
  s->authctxt = authctxt___0;
#line 1469
  s->pw = authctxt___0->pw;
#line 1470
  if ((unsigned int )s->pw == (unsigned int )((void *)0)) {
#line 1471
    fatal("no user for session %d", s->self);
  }
#line 1472
  debug("session_open: session %d: link with channel %d", s->self, chanid);
#line 1473
  s->chanid = chanid;
#line 1474
  return (1);
}
}
#line 1477 "session.c"
Session *session_by_tty(char *tty ) 
{ int i ;
  Session *s ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1481
  i = 0;
#line 1481
  while (i < 10) {
#line 1482
    s = & sessions[i];
#line 1483
    if (s->used) {
#line 1483
      if (s->ttyfd != -1) {
#line 1483
        if (0) {
#line 1483
          __s1_len = strlen((char const   *)(s->tty));
#line 1483
          __s2_len = strlen((char const   *)tty);
#line 1483
          if (! ((unsigned int )((void const   *)(s->tty + 1)) - (unsigned int )((void const   *)(s->tty)) == 1U)) {
            goto _L___0;
          } else {
#line 1483
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 1483
              if (! ((unsigned int )((void const   *)(tty + 1)) - (unsigned int )((void const   *)tty) == 1U)) {
#line 1483
                tmp___8 = 1;
              } else {
#line 1483
                if (__s2_len >= 4U) {
#line 1483
                  tmp___8 = 1;
                } else {
#line 1483
                  tmp___8 = 0;
                }
              }
            } else {
#line 1483
              tmp___8 = 0;
            }
          }
#line 1483
          if (tmp___8) {
#line 1483
            tmp___4 = __builtin_strcmp((char const   *)(s->tty), (char const   *)tty);
          } else {
#line 1483
            tmp___7 = __builtin_strcmp((char const   *)(s->tty), (char const   *)tty);
#line 1483
            tmp___4 = tmp___7;
          }
        } else {
#line 1483
          tmp___7 = __builtin_strcmp((char const   *)(s->tty), (char const   *)tty);
#line 1483
          tmp___4 = tmp___7;
        }
#line 1483
        if (tmp___4 == 0) {
#line 1484
          debug("session_by_tty: session %d tty %s", i, tty);
#line 1485
          return (s);
        }
      }
    }
#line 1481
    i ++;
  }
#line 1488
  debug("session_by_tty: unknown tty %.100s", tty);
#line 1489
  session_dump();
#line 1490
  return ((Session *)((void *)0));
}
}
#line 1493 "session.c"
static Session *session_by_channel(int id ) 
{ int i ;
  Session *s ;

  {
#line 1497
  i = 0;
#line 1497
  while (i < 10) {
#line 1498
    s = & sessions[i];
#line 1499
    if (s->used) {
#line 1499
      if (s->chanid == id) {
#line 1500
        debug("session_by_channel: session %d channel %d", i, id);
#line 1501
        return (s);
      }
    }
#line 1497
    i ++;
  }
#line 1504
  debug("session_by_channel: unknown channel %d", id);
#line 1505
  session_dump();
#line 1506
  return ((Session *)((void *)0));
}
}
#line 1509 "session.c"
static Session *session_by_pid(pid_t pid ) 
{ int i ;
  Session *s ;

  {
#line 1513
  debug("session_by_pid: pid %ld", (long )pid);
#line 1514
  i = 0;
#line 1514
  while (i < 10) {
#line 1515
    s = & sessions[i];
#line 1516
    if (s->used) {
#line 1516
      if (s->pid == pid) {
#line 1517
        return (s);
      }
    }
#line 1514
    i ++;
  }
#line 1519
  error("session_by_pid: unknown pid %ld", (long )pid);
#line 1520
  session_dump();
#line 1521
  return ((Session *)((void *)0));
}
}
#line 1524 "session.c"
static int session_window_change_req(Session *s ) 
{ int _len ;
  int tmp ;

  {
#line 1527
  s->col = packet_get_int();
#line 1528
  s->row = packet_get_int();
#line 1529
  s->xpixel = packet_get_int();
#line 1530
  s->ypixel = packet_get_int();
#line 1531
  while (1) {
#line 1531
    tmp = packet_remaining();
#line 1531
    _len = tmp;
#line 1531
    if (_len > 0) {
#line 1531
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1531);
#line 1531
      packet_disconnect("Packet integrity error.");
    }
#line 1531
    break;
  }
#line 1532
  pty_change_window_size(s->ptyfd, (int )s->row, (int )s->col, (int )s->xpixel, (int )s->ypixel);
#line 1533
  return (1);
}
}
#line 1536 "session.c"
static int session_pty_req(Session *s ) 
{ u_int len ;
  int n_bytes ;
  u_long tmp ;
  void *tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___13 ;
  int _len ;
  int tmp___14 ;

  {
#line 1542
  if (no_pty_flag) {
#line 1543
    debug("Allocating a pty not permitted for this authentication.");
#line 1544
    return (0);
  }
#line 1546
  if (s->ttyfd != -1) {
#line 1547
    packet_disconnect("Protocol error: you already have a pty.");
#line 1548
    return (0);
  }
#line 1551
  if (options.print_lastlog) {
#line 1552
    s->hostname[0] = (char )'\000';
#line 1553
    tmp = get_last_login_time((s->pw)->pw_uid, (char const   *)(s->pw)->pw_name, s->hostname,
                              sizeof(s->hostname));
#line 1553
    s->last_login_time = (long )tmp;
  }
#line 1557
  tmp___0 = packet_get_string(& len);
#line 1557
  s->term = (char *)tmp___0;
#line 1559
  if (compat20) {
#line 1560
    s->col = packet_get_int();
#line 1561
    s->row = packet_get_int();
  } else {
#line 1563
    s->row = packet_get_int();
#line 1564
    s->col = packet_get_int();
  }
#line 1566
  s->xpixel = packet_get_int();
#line 1567
  s->ypixel = packet_get_int();
#line 1569
  if (0) {
#line 1569
    __s1_len = strlen((char const   *)s->term);
#line 1569
    __s2_len = strlen("");
#line 1569
    if (! ((unsigned int )((void const   *)(s->term + 1)) - (unsigned int )((void const   *)s->term) == 1U)) {
      goto _L___0;
    } else {
#line 1569
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1569
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 1569
          tmp___10 = 1;
        } else {
#line 1569
          if (__s2_len >= 4U) {
#line 1569
            tmp___10 = 1;
          } else {
#line 1569
            tmp___10 = 0;
          }
        }
      } else {
#line 1569
        tmp___10 = 0;
      }
    }
#line 1569
    if (tmp___10) {
#line 1569
      tmp___6 = __builtin_strcmp((char const   *)s->term, "");
    } else {
#line 1569
      tmp___9 = __builtin_strcmp((char const   *)s->term, "");
#line 1569
      tmp___6 = tmp___9;
    }
  } else {
#line 1569
    tmp___9 = __builtin_strcmp((char const   *)s->term, "");
#line 1569
    tmp___6 = tmp___9;
  }
#line 1569
  if (tmp___6 == 0) {
#line 1570
    xfree((void *)s->term);
#line 1571
    s->term = (char *)((void *)0);
  }
#line 1575
  debug("Allocating pty.");
#line 1576
  if (use_privsep) {
#line 1576
    tmp___13 = mm_pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, (int )sizeof(s->tty));
  } else {
#line 1576
    tmp___13 = pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, (int )sizeof(s->tty));
  }
#line 1576
  if (! tmp___13) {
#line 1577
    if (s->term) {
#line 1578
      xfree((void *)s->term);
    }
#line 1579
    s->term = (char *)((void *)0);
#line 1580
    s->ptyfd = -1;
#line 1581
    s->ttyfd = -1;
#line 1582
    error("session_pty_req: session %d alloc failed", s->self);
#line 1583
    return (0);
  }
#line 1585
  debug("session_pty_req: session %d alloc %s", s->self, s->tty);
#line 1588
  if (! compat20) {
#line 1589
    n_bytes = packet_remaining();
  }
#line 1590
  tty_parse_modes(s->ttyfd, & n_bytes);
#line 1596
  fatal_add_cleanup(& session_pty_cleanup, (void *)s);
#line 1597
  if (! use_privsep) {
#line 1598
    pty_setowner(s->pw, (char const   *)(s->tty));
  }
#line 1601
  pty_change_window_size(s->ptyfd, (int )s->row, (int )s->col, (int )s->xpixel, (int )s->ypixel);
#line 1603
  while (1) {
#line 1603
    tmp___14 = packet_remaining();
#line 1603
    _len = tmp___14;
#line 1603
    if (_len > 0) {
#line 1603
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1603);
#line 1603
      packet_disconnect("Packet integrity error.");
    }
#line 1603
    break;
  }
#line 1604
  session_proctitle(s);
#line 1605
  return (1);
}
}
#line 1608 "session.c"
static int session_subsystem_req(Session *s ) 
{ struct stat st ;
  u_int len ;
  int success ;
  char *cmd ;
  char *subsys ;
  void *tmp ;
  int i ;
  int _len ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___9 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 1613
  success = 0;
#line 1614
  tmp = packet_get_string(& len);
#line 1614
  subsys = (char *)tmp;
#line 1617
  while (1) {
#line 1617
    tmp___0 = packet_remaining();
#line 1617
    _len = tmp___0;
#line 1617
    if (_len > 0) {
#line 1617
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1617);
#line 1617
      packet_disconnect("Packet integrity error.");
    }
#line 1617
    break;
  }
#line 1618
  log("subsystem request for %.100s", subsys);
#line 1620
  i = 0;
#line 1620
  while ((u_int )i < options.num_subsystems) {
#line 1621
    if (0) {
#line 1621
      __s1_len = strlen((char const   *)subsys);
#line 1621
      __s2_len = strlen((char const   *)options.subsystem_name[i]);
#line 1621
      if (! ((unsigned int )((void const   *)(subsys + 1)) - (unsigned int )((void const   *)subsys) == 1U)) {
        goto _L___0;
      } else {
#line 1621
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 1621
          if (! ((unsigned int )((void const   *)(options.subsystem_name[i] + 1)) - (unsigned int )((void const   *)options.subsystem_name[i]) == 1U)) {
#line 1621
            tmp___13 = 1;
          } else {
#line 1621
            if (__s2_len >= 4U) {
#line 1621
              tmp___13 = 1;
            } else {
#line 1621
              tmp___13 = 0;
            }
          }
        } else {
#line 1621
          tmp___13 = 0;
        }
      }
#line 1621
      if (tmp___13) {
#line 1621
        tmp___9 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
      } else {
#line 1621
        tmp___12 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
#line 1621
        tmp___9 = tmp___12;
      }
    } else {
#line 1621
      tmp___12 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
#line 1621
      tmp___9 = tmp___12;
    }
#line 1621
    if (tmp___9 == 0) {
#line 1622
      cmd = options.subsystem_command[i];
#line 1623
      tmp___3 = stat((char const   * __restrict  )cmd, (struct stat * __restrict  )(& st));
#line 1623
      if (tmp___3 < 0) {
#line 1624
        tmp___1 = __errno_location();
#line 1624
        tmp___2 = strerror(*tmp___1);
#line 1624
        error("subsystem: cannot stat %s: %s", cmd, tmp___2);
#line 1626
        break;
      }
#line 1628
      debug("subsystem: exec() %s", cmd);
#line 1629
      s->is_subsystem = 1;
#line 1630
      do_exec(s, (char const   *)cmd);
#line 1631
      success = 1;
#line 1632
      break;
    }
#line 1620
    i ++;
  }
#line 1636
  if (! success) {
#line 1637
    log("subsystem request for %.100s failed, subsystem not found", subsys);
  }
#line 1640
  xfree((void *)subsys);
#line 1641
  return (success);
}
}
#line 1644 "session.c"
static int session_x11_req(Session *s ) 
{ int success ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int _len ;
  int tmp___2 ;

  {
#line 1649
  tmp = packet_get_char();
#line 1649
  s->single_connection = (int )tmp;
#line 1650
  tmp___0 = packet_get_string((u_int *)((void *)0));
#line 1650
  s->auth_proto = (char *)tmp___0;
#line 1651
  tmp___1 = packet_get_string((u_int *)((void *)0));
#line 1651
  s->auth_data = (char *)tmp___1;
#line 1652
  s->screen = packet_get_int();
#line 1653
  while (1) {
#line 1653
    tmp___2 = packet_remaining();
#line 1653
    _len = tmp___2;
#line 1653
    if (_len > 0) {
#line 1653
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1653);
#line 1653
      packet_disconnect("Packet integrity error.");
    }
#line 1653
    break;
  }
#line 1655
  success = session_setup_x11fwd(s);
#line 1656
  if (! success) {
#line 1657
    xfree((void *)s->auth_proto);
#line 1658
    xfree((void *)s->auth_data);
#line 1659
    s->auth_proto = (char *)((void *)0);
#line 1660
    s->auth_data = (char *)((void *)0);
  }
#line 1662
  return (success);
}
}
#line 1665 "session.c"
static int session_shell_req(Session *s ) 
{ int _len ;
  int tmp ;

  {
#line 1668
  while (1) {
#line 1668
    tmp = packet_remaining();
#line 1668
    _len = tmp;
#line 1668
    if (_len > 0) {
#line 1668
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1668);
#line 1668
      packet_disconnect("Packet integrity error.");
    }
#line 1668
    break;
  }
#line 1669
  do_exec(s, (char const   *)((void *)0));
#line 1670
  return (1);
}
}
#line 1673 "session.c"
static int session_exec_req(Session *s ) 
{ u_int len ;
  char *command ;
  void *tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 1677
  tmp = packet_get_string(& len);
#line 1677
  command = (char *)tmp;
#line 1678
  while (1) {
#line 1678
    tmp___0 = packet_remaining();
#line 1678
    _len = tmp___0;
#line 1678
    if (_len > 0) {
#line 1678
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1678);
#line 1678
      packet_disconnect("Packet integrity error.");
    }
#line 1678
    break;
  }
#line 1679
  do_exec(s, (char const   *)command);
#line 1680
  xfree((void *)command);
#line 1681
  return (1);
}
}
#line 1687
static int session_auth_agent_req(Session *s ) ;
#line 1687 "session.c"
static int called___2  =    0;
#line 1684 "session.c"
static int session_auth_agent_req(Session *s ) 
{ int _len ;
  int tmp ;
  int tmp___0 ;

  {
#line 1688
  while (1) {
#line 1688
    tmp = packet_remaining();
#line 1688
    _len = tmp;
#line 1688
    if (_len > 0) {
#line 1688
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1688);
#line 1688
      packet_disconnect("Packet integrity error.");
    }
#line 1688
    break;
  }
#line 1689
  if (no_agent_forwarding_flag) {
#line 1690
    debug("session_auth_agent_req: no_agent_forwarding_flag");
#line 1691
    return (0);
  }
#line 1693
  if (called___2) {
#line 1694
    return (0);
  } else {
#line 1696
    called___2 = 1;
#line 1697
    tmp___0 = auth_input_request_forwarding(s->pw);
#line 1697
    return (tmp___0);
  }
}
}
#line 1701 "session.c"
int session_input_channel_req(Channel *c , char const   *rtype ) 
{ int success ;
  Session *s ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___54 ;
  int tmp___57 ;
  int tmp___58 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___64 ;
  int tmp___67 ;
  int tmp___68 ;

  {
#line 1704
  success = 0;
#line 1707
  s = session_by_channel(c->self);
#line 1707
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1708
    log("session_input_channel_req: no session %d req %.100s", c->self, rtype);
#line 1710
    return (0);
  }
#line 1712
  debug("session_input_channel_req: session %d req %s", s->self, rtype);
#line 1718
  if (c->type == 10) {
#line 1719
    if (0) {
#line 1719
      __s1_len___4 = strlen(rtype);
#line 1719
      __s2_len___4 = strlen("shell");
#line 1719
      if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
        goto _L___10;
      } else {
#line 1719
        if (__s1_len___4 >= 4U) {
          _L___10: /* CIL Label */ 
#line 1719
          if (! ((unsigned int )((void const   *)("shell" + 1)) - (unsigned int )((void const   *)"shell") == 1U)) {
#line 1719
            tmp___58 = 1;
          } else {
#line 1719
            if (__s2_len___4 >= 4U) {
#line 1719
              tmp___58 = 1;
            } else {
#line 1719
              tmp___58 = 0;
            }
          }
        } else {
#line 1719
          tmp___58 = 0;
        }
      }
#line 1719
      if (tmp___58) {
#line 1719
        tmp___54 = __builtin_strcmp(rtype, "shell");
      } else {
#line 1719
        tmp___57 = __builtin_strcmp(rtype, "shell");
#line 1719
        tmp___54 = tmp___57;
      }
    } else {
#line 1719
      tmp___57 = __builtin_strcmp(rtype, "shell");
#line 1719
      tmp___54 = tmp___57;
    }
#line 1719
    if (tmp___54 == 0) {
#line 1720
      success = session_shell_req(s);
    } else {
#line 1721
      if (0) {
#line 1721
        __s1_len___3 = strlen(rtype);
#line 1721
        __s2_len___3 = strlen("exec");
#line 1721
        if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
          goto _L___8;
        } else {
#line 1721
          if (__s1_len___3 >= 4U) {
            _L___8: /* CIL Label */ 
#line 1721
            if (! ((unsigned int )((void const   *)("exec" + 1)) - (unsigned int )((void const   *)"exec") == 1U)) {
#line 1721
              tmp___48 = 1;
            } else {
#line 1721
              if (__s2_len___3 >= 4U) {
#line 1721
                tmp___48 = 1;
              } else {
#line 1721
                tmp___48 = 0;
              }
            }
          } else {
#line 1721
            tmp___48 = 0;
          }
        }
#line 1721
        if (tmp___48) {
#line 1721
          tmp___44 = __builtin_strcmp(rtype, "exec");
        } else {
#line 1721
          tmp___47 = __builtin_strcmp(rtype, "exec");
#line 1721
          tmp___44 = tmp___47;
        }
      } else {
#line 1721
        tmp___47 = __builtin_strcmp(rtype, "exec");
#line 1721
        tmp___44 = tmp___47;
      }
#line 1721
      if (tmp___44 == 0) {
#line 1722
        success = session_exec_req(s);
      } else {
#line 1723
        if (0) {
#line 1723
          __s1_len___2 = strlen(rtype);
#line 1723
          __s2_len___2 = strlen("pty-req");
#line 1723
          if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
            goto _L___6;
          } else {
#line 1723
            if (__s1_len___2 >= 4U) {
              _L___6: /* CIL Label */ 
#line 1723
              if (! ((unsigned int )((void const   *)("pty-req" + 1)) - (unsigned int )((void const   *)"pty-req") == 1U)) {
#line 1723
                tmp___38 = 1;
              } else {
#line 1723
                if (__s2_len___2 >= 4U) {
#line 1723
                  tmp___38 = 1;
                } else {
#line 1723
                  tmp___38 = 0;
                }
              }
            } else {
#line 1723
              tmp___38 = 0;
            }
          }
#line 1723
          if (tmp___38) {
#line 1723
            tmp___34 = __builtin_strcmp(rtype, "pty-req");
          } else {
#line 1723
            tmp___37 = __builtin_strcmp(rtype, "pty-req");
#line 1723
            tmp___34 = tmp___37;
          }
        } else {
#line 1723
          tmp___37 = __builtin_strcmp(rtype, "pty-req");
#line 1723
          tmp___34 = tmp___37;
        }
#line 1723
        if (tmp___34 == 0) {
#line 1724
          success = session_pty_req(s);
        } else {
#line 1725
          if (0) {
#line 1725
            __s1_len___1 = strlen(rtype);
#line 1725
            __s2_len___1 = strlen("x11-req");
#line 1725
            if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
              goto _L___4;
            } else {
#line 1725
              if (__s1_len___1 >= 4U) {
                _L___4: /* CIL Label */ 
#line 1725
                if (! ((unsigned int )((void const   *)("x11-req" + 1)) - (unsigned int )((void const   *)"x11-req") == 1U)) {
#line 1725
                  tmp___28 = 1;
                } else {
#line 1725
                  if (__s2_len___1 >= 4U) {
#line 1725
                    tmp___28 = 1;
                  } else {
#line 1725
                    tmp___28 = 0;
                  }
                }
              } else {
#line 1725
                tmp___28 = 0;
              }
            }
#line 1725
            if (tmp___28) {
#line 1725
              tmp___24 = __builtin_strcmp(rtype, "x11-req");
            } else {
#line 1725
              tmp___27 = __builtin_strcmp(rtype, "x11-req");
#line 1725
              tmp___24 = tmp___27;
            }
          } else {
#line 1725
            tmp___27 = __builtin_strcmp(rtype, "x11-req");
#line 1725
            tmp___24 = tmp___27;
          }
#line 1725
          if (tmp___24 == 0) {
#line 1726
            success = session_x11_req(s);
          } else {
#line 1727
            if (0) {
#line 1727
              __s1_len___0 = strlen(rtype);
#line 1727
              __s2_len___0 = strlen("auth-agent-req@openssh.com");
#line 1727
              if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
                goto _L___2;
              } else {
#line 1727
                if (__s1_len___0 >= 4U) {
                  _L___2: /* CIL Label */ 
#line 1727
                  if (! ((unsigned int )((void const   *)("auth-agent-req@openssh.com" + 1)) - (unsigned int )((void const   *)"auth-agent-req@openssh.com") == 1U)) {
#line 1727
                    tmp___18 = 1;
                  } else {
#line 1727
                    if (__s2_len___0 >= 4U) {
#line 1727
                      tmp___18 = 1;
                    } else {
#line 1727
                      tmp___18 = 0;
                    }
                  }
                } else {
#line 1727
                  tmp___18 = 0;
                }
              }
#line 1727
              if (tmp___18) {
#line 1727
                tmp___14 = __builtin_strcmp(rtype, "auth-agent-req@openssh.com");
              } else {
#line 1727
                tmp___17 = __builtin_strcmp(rtype, "auth-agent-req@openssh.com");
#line 1727
                tmp___14 = tmp___17;
              }
            } else {
#line 1727
              tmp___17 = __builtin_strcmp(rtype, "auth-agent-req@openssh.com");
#line 1727
              tmp___14 = tmp___17;
            }
#line 1727
            if (tmp___14 == 0) {
#line 1728
              success = session_auth_agent_req(s);
            } else {
#line 1729
              if (0) {
#line 1729
                __s1_len = strlen(rtype);
#line 1729
                __s2_len = strlen("subsystem");
#line 1729
                if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
                  goto _L___0;
                } else {
#line 1729
                  if (__s1_len >= 4U) {
                    _L___0: /* CIL Label */ 
#line 1729
                    if (! ((unsigned int )((void const   *)("subsystem" + 1)) - (unsigned int )((void const   *)"subsystem") == 1U)) {
#line 1729
                      tmp___8 = 1;
                    } else {
#line 1729
                      if (__s2_len >= 4U) {
#line 1729
                        tmp___8 = 1;
                      } else {
#line 1729
                        tmp___8 = 0;
                      }
                    }
                  } else {
#line 1729
                    tmp___8 = 0;
                  }
                }
#line 1729
                if (tmp___8) {
#line 1729
                  tmp___4 = __builtin_strcmp(rtype, "subsystem");
                } else {
#line 1729
                  tmp___7 = __builtin_strcmp(rtype, "subsystem");
#line 1729
                  tmp___4 = tmp___7;
                }
              } else {
#line 1729
                tmp___7 = __builtin_strcmp(rtype, "subsystem");
#line 1729
                tmp___4 = tmp___7;
              }
#line 1729
              if (tmp___4 == 0) {
#line 1730
                success = session_subsystem_req(s);
              }
            }
          }
        }
      }
    }
  }
#line 1733
  if (0) {
#line 1733
    __s1_len___5 = strlen(rtype);
#line 1733
    __s2_len___5 = strlen("window-change");
#line 1733
    if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
      goto _L___12;
    } else {
#line 1733
      if (__s1_len___5 >= 4U) {
        _L___12: /* CIL Label */ 
#line 1733
        if (! ((unsigned int )((void const   *)("window-change" + 1)) - (unsigned int )((void const   *)"window-change") == 1U)) {
#line 1733
          tmp___68 = 1;
        } else {
#line 1733
          if (__s2_len___5 >= 4U) {
#line 1733
            tmp___68 = 1;
          } else {
#line 1733
            tmp___68 = 0;
          }
        }
      } else {
#line 1733
        tmp___68 = 0;
      }
    }
#line 1733
    if (tmp___68) {
#line 1733
      tmp___64 = __builtin_strcmp(rtype, "window-change");
    } else {
#line 1733
      tmp___67 = __builtin_strcmp(rtype, "window-change");
#line 1733
      tmp___64 = tmp___67;
    }
  } else {
#line 1733
    tmp___67 = __builtin_strcmp(rtype, "window-change");
#line 1733
    tmp___64 = tmp___67;
  }
#line 1733
  if (tmp___64 == 0) {
#line 1734
    success = session_window_change_req(s);
  }
#line 1736
  return (success);
}
}
#line 1739 "session.c"
void session_set_fds(Session *s , int fdin___0 , int fdout___0 , int fderr___0 ) 
{ int tmp ;

  {
#line 1742
  if (! compat20) {
#line 1743
    fatal("session_set_fds: called for proto != 2.0");
  }
#line 1748
  if (s->chanid == -1) {
#line 1749
    fatal("no channel for session %d", s->self);
  }
#line 1750
  if (fderr___0 == -1) {
#line 1750
    tmp = 0;
  } else {
#line 1750
    tmp = 1;
  }
#line 1750
  channel_set_fds(s->chanid, fdout___0, fdin___0, fderr___0, tmp, 1, 131072U);
#line 1755
  return;
}
}
#line 1761 "session.c"
void session_pty_cleanup2(void *session ) 
{ Session *s ;
  __uid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 1764
  s = (Session *)session;
#line 1766
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1767
    error("session_pty_cleanup: no session");
#line 1768
    return;
  }
#line 1770
  if (s->ttyfd == -1) {
#line 1771
    return;
  }
#line 1773
  debug("session_pty_cleanup: session %d release %s", s->self, s->tty);
#line 1776
  if (s->pid != 0) {
#line 1777
    record_logout(s->pid, (char const   *)(s->tty), (char const   *)(s->pw)->pw_name);
  }
#line 1780
  tmp = getuid();
#line 1780
  if (tmp == 0U) {
#line 1781
    pty_release((char const   *)(s->tty));
  }
#line 1788
  tmp___2 = close(s->ptymaster);
#line 1788
  if (tmp___2 < 0) {
#line 1789
    tmp___0 = __errno_location();
#line 1789
    tmp___1 = strerror(*tmp___0);
#line 1789
    error("close(s->ptymaster/%d): %s", s->ptymaster, tmp___1);
  }
#line 1792
  s->ttyfd = -1;
#line 1793
  return;
}
}
#line 1795 "session.c"
void session_pty_cleanup(void *session ) 
{ 

  {
#line 1798
  if (use_privsep) {
#line 1798
    mm_session_pty_cleanup2(session);
  } else {
#line 1798
    session_pty_cleanup2(session);
  }
#line 1799
  return;
}
}
#line 1801 "session.c"
static void session_exit_message(Session *s , int status ) 
{ Channel *c ;
  union __anonunion_71 __constr_expr_0 ;
  union __anonunion_72 __constr_expr_1 ;
  union __anonunion_73___0 __constr_expr_2 ;
  union __anonunion_74___0 __constr_expr_3 ;
  union __anonunion_75___0 __constr_expr_4 ;

  {
#line 1806
  c = channel_lookup(s->chanid);
#line 1806
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1807
    fatal("session_exit_message: session %d: no channel %d", s->self, s->chanid);
  }
#line 1809
  debug("session_exit_message: session %d channel %d pid %ld", s->self, s->chanid,
        (long )s->pid);
#line 1812
  __constr_expr_4.__in = status;
#line 1812
  if ((__constr_expr_4.__i & 127) == 0) {
#line 1813
    channel_request_start(s->chanid, (char *)"exit-status", 0);
#line 1814
    __constr_expr_0.__in = status;
#line 1814
    packet_put_int((unsigned int )((__constr_expr_0.__i & 65280) >> 8));
#line 1815
    packet_send();
  } else {
#line 1816
    __constr_expr_3.__in = status;
#line 1816
    if ((int )((signed char )((__constr_expr_3.__i & 127) + 1)) >> 1 > 0) {
#line 1817
      channel_request_start(s->chanid, (char *)"exit-signal", 0);
#line 1818
      __constr_expr_1.__in = status;
#line 1818
      packet_put_int((unsigned int )(__constr_expr_1.__i & 127));
#line 1820
      __constr_expr_2.__in = status;
#line 1820
      packet_put_char(__constr_expr_2.__i & 128);
#line 1824
      packet_put_cstring("");
#line 1825
      packet_put_cstring("");
#line 1826
      packet_send();
    } else {
#line 1829
      packet_disconnect("wait returned status %04x.", status);
    }
  }
#line 1833
  debug("session_exit_message: release channel %d", s->chanid);
#line 1834
  channel_cancel_cleanup(s->chanid);
#line 1841
  if (c->ostate != 3U) {
#line 1842
    chan_write_failed(c);
  }
#line 1843
  s->chanid = -1;
#line 1844
  return;
}
}
#line 1846 "session.c"
void session_close(Session *s ) 
{ 

  {
#line 1849
  debug("session_close: session %d pid %ld", s->self, (long )s->pid);
#line 1850
  if (s->ttyfd != -1) {
#line 1851
    fatal_remove_cleanup(& session_pty_cleanup, (void *)s);
#line 1852
    session_pty_cleanup((void *)s);
  }
#line 1854
  if (s->term) {
#line 1855
    xfree((void *)s->term);
  }
#line 1856
  if (s->display) {
#line 1857
    xfree((void *)s->display);
  }
#line 1858
  if (s->auth_display) {
#line 1859
    xfree((void *)s->auth_display);
  }
#line 1860
  if (s->auth_data) {
#line 1861
    xfree((void *)s->auth_data);
  }
#line 1862
  if (s->auth_proto) {
#line 1863
    xfree((void *)s->auth_proto);
  }
#line 1864
  s->used = 0;
#line 1865
  session_proctitle(s);
#line 1866
  return;
}
}
#line 1868 "session.c"
void session_close_by_pid(pid_t pid , int status ) 
{ Session *s ;
  Session *tmp ;

  {
#line 1871
  tmp = session_by_pid(pid);
#line 1871
  s = tmp;
#line 1872
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1873
    debug("session_close_by_pid: no session for pid %ld", (long )pid);
#line 1875
    return;
  }
#line 1877
  if (s->chanid != -1) {
#line 1878
    session_exit_message(s, status);
  }
#line 1879
  session_close(s);
#line 1880
  return;
}
}
#line 1886 "session.c"
void session_close_by_channel(int id , void *arg ) 
{ Session *s ;
  Session *tmp ;

  {
#line 1889
  tmp = session_by_channel(id);
#line 1889
  s = tmp;
#line 1890
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1891
    debug("session_close_by_channel: no session for id %d", id);
#line 1892
    return;
  }
#line 1894
  debug("session_close_by_channel: channel %d child %ld", id, (long )s->pid);
#line 1896
  if (s->pid != 0) {
#line 1897
    debug("session_close_by_channel: channel %d: has child", id);
#line 1902
    if (s->ttyfd != -1) {
#line 1903
      fatal_remove_cleanup(& session_pty_cleanup, (void *)s);
#line 1904
      session_pty_cleanup((void *)s);
    }
#line 1906
    return;
  }
#line 1909
  channel_cancel_cleanup(s->chanid);
#line 1910
  s->chanid = -1;
#line 1911
  session_close(s);
#line 1912
  return;
}
}
#line 1914 "session.c"
void session_destroy_all(void (*closefunc)(Session * ) ) 
{ int i ;
  Session *s ;

  {
#line 1918
  i = 0;
#line 1918
  while (i < 10) {
#line 1919
    s = & sessions[i];
#line 1920
    if (s->used) {
#line 1921
      if ((unsigned int )closefunc != (unsigned int )((void *)0)) {
#line 1922
        (*closefunc)(s);
      } else {
#line 1924
        session_close(s);
      }
    }
#line 1918
    i ++;
  }
#line 1927
  return;
}
}
#line 1932 "session.c"
static char buf___0[1024]  ;
#line 1929 "session.c"
static char *session_tty_list(void) 
{ int i ;
  Session *s ;
  char *tmp ;

  {
#line 1934
  buf___0[0] = (char )'\000';
#line 1935
  i = 0;
#line 1935
  while (i < 10) {
#line 1936
    s = & sessions[i];
#line 1937
    if (s->used) {
#line 1937
      if (s->ttyfd != -1) {
#line 1938
        if ((int )buf___0[0] != 0) {
#line 1939
          strlcat(buf___0, ",", sizeof(buf___0));
        }
#line 1940
        tmp = strrchr((char const   *)(s->tty), '/');
#line 1940
        strlcat(buf___0, (char const   *)(tmp + 1), sizeof(buf___0));
      }
    }
#line 1935
    i ++;
  }
#line 1943
  if ((int )buf___0[0] == 0) {
#line 1944
    strlcpy(buf___0, "notty", sizeof(buf___0));
  }
#line 1945
  return (buf___0);
}
}
#line 1948 "session.c"
void session_proctitle(Session *s ) 
{ char *tmp ;

  {
#line 1951
  if ((unsigned int )s->pw == (unsigned int )((void *)0)) {
#line 1952
    error("no user for session %d", s->self);
  } else {
#line 1954
    tmp = session_tty_list();
#line 1954
    setproctitle("%s@%s", (s->pw)->pw_name, tmp);
  }
#line 1955
  return;
}
}
#line 1957 "session.c"
int session_setup_x11fwd(Session *s ) 
{ struct stat st ;
  char display[512] ;
  char auth_display[512] ;
  char hostname[64] ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 1964
  if (no_x11_forwarding_flag) {
#line 1965
    packet_send_debug("X11 forwarding disabled in user configuration file.");
#line 1966
    return (0);
  }
#line 1968
  if (! options.x11_forwarding) {
#line 1969
    debug("X11 forwarding disabled in server configuration file.");
#line 1970
    return (0);
  }
#line 1972
  if (! options.xauth_location) {
#line 1974
    packet_send_debug("No xauth program; cannot forward with spoofing.");
#line 1975
    return (0);
  } else {
#line 1972
    tmp = stat((char const   * __restrict  )options.xauth_location, (struct stat * __restrict  )(& st));
#line 1972
    if (tmp == -1) {
#line 1974
      packet_send_debug("No xauth program; cannot forward with spoofing.");
#line 1975
      return (0);
    }
  }
#line 1977
  if (options.use_login) {
#line 1978
    packet_send_debug("X11 forwarding disabled; not compatible with UseLogin=yes.");
#line 1980
    return (0);
  }
#line 1982
  if ((unsigned int )s->display != (unsigned int )((void *)0)) {
#line 1983
    debug("X11 display already set.");
#line 1984
    return (0);
  }
#line 1986
  tmp___0 = x11_create_display_inet(options.x11_display_offset, options.x11_use_localhost,
                                    s->single_connection, & s->display_number);
#line 1986
  if (tmp___0 == -1) {
#line 1989
    debug("x11_create_display_inet failed.");
#line 1990
    return (0);
  }
#line 1994
  tmp___3 = gethostname(hostname, sizeof(hostname));
#line 1994
  if (tmp___3 < 0) {
#line 1995
    tmp___1 = __errno_location();
#line 1995
    tmp___2 = strerror(*tmp___1);
#line 1995
    fatal("gethostname: %.100s", tmp___2);
  }
#line 2001
  if (options.x11_use_localhost) {
#line 2002
    snprintf((char * __restrict  )(display), sizeof(display), (char const   * __restrict  )"localhost:%u.%u",
             s->display_number, s->screen);
#line 2004
    snprintf((char * __restrict  )(auth_display), sizeof(auth_display), (char const   * __restrict  )"unix:%u.%u",
             s->display_number, s->screen);
#line 2006
    s->display = xstrdup((char const   *)(display));
#line 2007
    s->auth_display = xstrdup((char const   *)(auth_display));
  } else {
#line 2023
    snprintf((char * __restrict  )(display), sizeof(display), (char const   * __restrict  )"%.400s:%u.%u",
             hostname, s->display_number, s->screen);
#line 2026
    s->display = xstrdup((char const   *)(display));
#line 2027
    s->auth_display = xstrdup((char const   *)(display));
  }
#line 2030
  return (1);
}
}
#line 2033 "session.c"
static void do_authenticated2(Authctxt *authctxt___0 ) 
{ 

  {
#line 2036
  server_loop2(authctxt___0);
#line 2037
  return;
}
}
#line 1 "groupaccess.o"
#line 103 "/usr/include/grp.h"
extern struct group *getgrgid(__gid_t __gid ) ;
#line 188
extern int getgrouplist(char const   *__user , __gid_t __group , __gid_t *__groups ,
                        int *__ngroups ) ;
#line 33 "groupaccess.c"
static int ngroups  ;
#line 34 "groupaccess.c"
static char *groups_byname[65537]  ;
#line 40 "groupaccess.c"
int ga_init(char const   *user , gid_t base ) 
{ gid_t groups_bygid[65537] ;
  int i ;
  int j ;
  struct group *gr ;
  int tmp ;
  int tmp___0 ;

  {
#line 47
  if (ngroups > 0) {
#line 48
    ga_free();
  }
#line 50
  ngroups = (int )(sizeof(groups_bygid) / sizeof(gid_t ));
#line 51
  tmp = getgrouplist(user, base, groups_bygid, & ngroups);
#line 51
  if (tmp == -1) {
#line 52
    log("getgrouplist: groups list too small");
  }
#line 53
  i = 0;
#line 53
  j = 0;
#line 53
  while (i < ngroups) {
#line 54
    gr = getgrgid(groups_bygid[i]);
#line 54
    if ((unsigned int )gr != (unsigned int )((void *)0)) {
#line 55
      tmp___0 = j;
#line 55
      j ++;
#line 55
      groups_byname[tmp___0] = xstrdup((char const   *)gr->gr_name);
    }
#line 53
    i ++;
  }
#line 56
  ngroups = j;
#line 56
  return (ngroups);
}
}
#line 63 "groupaccess.c"
int ga_match(char * const  *groups , int n___0 ) 
{ int i ;
  int j ;
  int tmp ;

  {
#line 68
  i = 0;
#line 68
  while (i < ngroups) {
#line 69
    j = 0;
#line 69
    while (j < n___0) {
#line 70
      tmp = match_pattern((char const   *)groups_byname[i], (char const   *)*(groups + j));
#line 70
      if (tmp) {
#line 71
        return (1);
      }
#line 69
      j ++;
    }
#line 68
    i ++;
  }
#line 72
  return (0);
}
}
#line 78 "groupaccess.c"
void ga_free(void) 
{ int i ;

  {
#line 83
  if (ngroups > 0) {
#line 84
    i = 0;
#line 84
    while (i < ngroups) {
#line 85
      xfree((void *)groups_byname[i]);
#line 84
      i ++;
    }
#line 86
    ngroups = 0;
  }
#line 88
  return;
}
}
#line 1 "auth-skey.o"
#line 1 "auth-bsdauth.o"
#line 1 "monitor_mm.o"
#line 62 "/usr/include/sys/mman.h"
extern  __attribute__((__nothrow__)) void *mmap(void *__addr , size_t __len , int __prot ,
                                                int __flags , int __fd , __off64_t __offset )  __asm__("mmap64")  ;
#line 77
extern  __attribute__((__nothrow__)) int munmap(void *__addr , size_t __len ) ;
#line 50 "monitor_mm.h"
void mmtree_RB_INSERT_COLOR(struct mmtree *head , struct mm_share *elm ) ;
#line 50
void mmtree_RB_REMOVE_COLOR(struct mmtree *head , struct mm_share *parent , struct mm_share *elm ) ;
#line 50
void mmtree_RB_REMOVE(struct mmtree *head , struct mm_share *elm ) ;
#line 50
struct mm_share *mmtree_RB_INSERT(struct mmtree *head , struct mm_share *elm ) ;
#line 50
struct mm_share *mmtree_RB_FIND(struct mmtree *head , struct mm_share *elm ) ;
#line 50
struct mm_share *mmtree_RB_NEXT(struct mmtree *head , struct mm_share *elm ) ;
#line 50
struct mm_share *mmtree_RB_MINMAX(struct mmtree *head , int val ) ;
#line 56
struct mm_master *mm_create(struct mm_master *mmalloc , size_t size ) ;
#line 57
void mm_destroy(struct mm_master *mm ) ;
#line 59
void mm_share_sync(struct mm_master **pmm , struct mm_master **pmmalloc ) ;
#line 61
void *mm_malloc(struct mm_master *mm , size_t size ) ;
#line 62
void *mm_xmalloc(struct mm_master *mm , size_t size ) ;
#line 63
void mm_free(struct mm_master *mm , void *address ) ;
#line 65
void mm_memvalid(struct mm_master *mm , void *address , size_t size ) ;
#line 38 "monitor_mm.c"
static int mm_compare(struct mm_share *a , struct mm_share *b ) 
{ 

  {
#line 41
  return ((char *)a->address - (char *)b->address);
}
}
#line 44 "monitor_mm.c"
void mmtree_RB_INSERT_COLOR(struct mmtree *head , struct mm_share *elm ) 
{ struct mm_share *parent ;
  struct mm_share *gparent ;
  struct mm_share *tmp ;

  {
#line 44
  while (1) {
#line 44
    parent = elm->next.rbe_parent;
#line 44
    if (parent) {
#line 44
      if (! (parent->next.rbe_color == 1)) {
#line 44
        break;
      }
    } else {
#line 44
      break;
    }
#line 44
    gparent = parent->next.rbe_parent;
#line 44
    if ((unsigned int )parent == (unsigned int )gparent->next.rbe_left) {
#line 44
      tmp = gparent->next.rbe_right;
#line 44
      if (tmp) {
#line 44
        if (tmp->next.rbe_color == 1) {
#line 44
          tmp->next.rbe_color = 0;
#line 44
          while (1) {
#line 44
            parent->next.rbe_color = 0;
#line 44
            gparent->next.rbe_color = 1;
#line 44
            break;
          }
#line 44
          elm = gparent;
#line 44
          continue;
        }
      }
#line 44
      if ((unsigned int )parent->next.rbe_right == (unsigned int )elm) {
#line 44
        while (1) {
#line 44
          tmp = parent->next.rbe_right;
#line 44
          parent->next.rbe_right = tmp->next.rbe_left;
#line 44
          if (parent->next.rbe_right) {
#line 44
            (tmp->next.rbe_left)->next.rbe_parent = parent;
          }
#line 44
          tmp->next.rbe_parent = parent->next.rbe_parent;
#line 44
          if (tmp->next.rbe_parent) {
#line 44
            if ((unsigned int )parent == (unsigned int )(parent->next.rbe_parent)->next.rbe_left) {
#line 44
              (parent->next.rbe_parent)->next.rbe_left = tmp;
            } else {
#line 44
              (parent->next.rbe_parent)->next.rbe_right = tmp;
            }
          } else {
#line 44
            head->rbh_root = tmp;
          }
#line 44
          tmp->next.rbe_left = parent;
#line 44
          parent->next.rbe_parent = tmp;
#line 44
          break;
        }
#line 44
        tmp = parent;
#line 44
        parent = elm;
#line 44
        elm = tmp;
      }
#line 44
      while (1) {
#line 44
        parent->next.rbe_color = 0;
#line 44
        gparent->next.rbe_color = 1;
#line 44
        break;
      }
#line 44
      while (1) {
#line 44
        tmp = gparent->next.rbe_left;
#line 44
        gparent->next.rbe_left = tmp->next.rbe_right;
#line 44
        if (gparent->next.rbe_left) {
#line 44
          (tmp->next.rbe_right)->next.rbe_parent = gparent;
        }
#line 44
        tmp->next.rbe_parent = gparent->next.rbe_parent;
#line 44
        if (tmp->next.rbe_parent) {
#line 44
          if ((unsigned int )gparent == (unsigned int )(gparent->next.rbe_parent)->next.rbe_left) {
#line 44
            (gparent->next.rbe_parent)->next.rbe_left = tmp;
          } else {
#line 44
            (gparent->next.rbe_parent)->next.rbe_right = tmp;
          }
        } else {
#line 44
          head->rbh_root = tmp;
        }
#line 44
        tmp->next.rbe_right = gparent;
#line 44
        gparent->next.rbe_parent = tmp;
#line 44
        break;
      }
    } else {
#line 44
      tmp = gparent->next.rbe_left;
#line 44
      if (tmp) {
#line 44
        if (tmp->next.rbe_color == 1) {
#line 44
          tmp->next.rbe_color = 0;
#line 44
          while (1) {
#line 44
            parent->next.rbe_color = 0;
#line 44
            gparent->next.rbe_color = 1;
#line 44
            break;
          }
#line 44
          elm = gparent;
#line 44
          continue;
        }
      }
#line 44
      if ((unsigned int )parent->next.rbe_left == (unsigned int )elm) {
#line 44
        while (1) {
#line 44
          tmp = parent->next.rbe_left;
#line 44
          parent->next.rbe_left = tmp->next.rbe_right;
#line 44
          if (parent->next.rbe_left) {
#line 44
            (tmp->next.rbe_right)->next.rbe_parent = parent;
          }
#line 44
          tmp->next.rbe_parent = parent->next.rbe_parent;
#line 44
          if (tmp->next.rbe_parent) {
#line 44
            if ((unsigned int )parent == (unsigned int )(parent->next.rbe_parent)->next.rbe_left) {
#line 44
              (parent->next.rbe_parent)->next.rbe_left = tmp;
            } else {
#line 44
              (parent->next.rbe_parent)->next.rbe_right = tmp;
            }
          } else {
#line 44
            head->rbh_root = tmp;
          }
#line 44
          tmp->next.rbe_right = parent;
#line 44
          parent->next.rbe_parent = tmp;
#line 44
          break;
        }
#line 44
        tmp = parent;
#line 44
        parent = elm;
#line 44
        elm = tmp;
      }
#line 44
      while (1) {
#line 44
        parent->next.rbe_color = 0;
#line 44
        gparent->next.rbe_color = 1;
#line 44
        break;
      }
#line 44
      while (1) {
#line 44
        tmp = gparent->next.rbe_right;
#line 44
        gparent->next.rbe_right = tmp->next.rbe_left;
#line 44
        if (gparent->next.rbe_right) {
#line 44
          (tmp->next.rbe_left)->next.rbe_parent = gparent;
        }
#line 44
        tmp->next.rbe_parent = gparent->next.rbe_parent;
#line 44
        if (tmp->next.rbe_parent) {
#line 44
          if ((unsigned int )gparent == (unsigned int )(gparent->next.rbe_parent)->next.rbe_left) {
#line 44
            (gparent->next.rbe_parent)->next.rbe_left = tmp;
          } else {
#line 44
            (gparent->next.rbe_parent)->next.rbe_right = tmp;
          }
        } else {
#line 44
          head->rbh_root = tmp;
        }
#line 44
        tmp->next.rbe_left = gparent;
#line 44
        gparent->next.rbe_parent = tmp;
#line 44
        break;
      }
    }
  }
#line 44
  (head->rbh_root)->next.rbe_color = 0;
#line 44
  return;
}
}
#line 44 "monitor_mm.c"
void mmtree_RB_REMOVE_COLOR(struct mmtree *head , struct mm_share *parent , struct mm_share *elm ) 
{ struct mm_share *tmp ;
  struct mm_share *oleft ;
  struct mm_share *oright ;

  {
#line 44
  while (1) {
#line 44
    if ((unsigned int )elm == (unsigned int )((void *)0)) {
      goto _L___5;
    } else {
#line 44
      if (elm->next.rbe_color == 0) {
        _L___5: /* CIL Label */ 
#line 44
        if (! ((unsigned int )elm != (unsigned int )head->rbh_root)) {
#line 44
          break;
        }
      } else {
#line 44
        break;
      }
    }
#line 44
    if ((unsigned int )parent->next.rbe_left == (unsigned int )elm) {
#line 44
      tmp = parent->next.rbe_right;
#line 44
      if (tmp->next.rbe_color == 1) {
#line 44
        while (1) {
#line 44
          tmp->next.rbe_color = 0;
#line 44
          parent->next.rbe_color = 1;
#line 44
          break;
        }
#line 44
        while (1) {
#line 44
          tmp = parent->next.rbe_right;
#line 44
          parent->next.rbe_right = tmp->next.rbe_left;
#line 44
          if (parent->next.rbe_right) {
#line 44
            (tmp->next.rbe_left)->next.rbe_parent = parent;
          }
#line 44
          tmp->next.rbe_parent = parent->next.rbe_parent;
#line 44
          if (tmp->next.rbe_parent) {
#line 44
            if ((unsigned int )parent == (unsigned int )(parent->next.rbe_parent)->next.rbe_left) {
#line 44
              (parent->next.rbe_parent)->next.rbe_left = tmp;
            } else {
#line 44
              (parent->next.rbe_parent)->next.rbe_right = tmp;
            }
          } else {
#line 44
            head->rbh_root = tmp;
          }
#line 44
          tmp->next.rbe_left = parent;
#line 44
          parent->next.rbe_parent = tmp;
#line 44
          break;
        }
#line 44
        tmp = parent->next.rbe_right;
      }
#line 44
      if ((unsigned int )tmp->next.rbe_left == (unsigned int )((void *)0)) {
        goto _L___1;
      } else {
#line 44
        if ((tmp->next.rbe_left)->next.rbe_color == 0) {
          _L___1: /* CIL Label */ 
#line 44
          if ((unsigned int )tmp->next.rbe_right == (unsigned int )((void *)0)) {
#line 44
            tmp->next.rbe_color = 1;
#line 44
            elm = parent;
#line 44
            parent = elm->next.rbe_parent;
          } else {
#line 44
            if ((tmp->next.rbe_right)->next.rbe_color == 0) {
#line 44
              tmp->next.rbe_color = 1;
#line 44
              elm = parent;
#line 44
              parent = elm->next.rbe_parent;
            } else {
              goto _L___0;
            }
          }
        } else {
          _L___0: /* CIL Label */ 
#line 44
          if ((unsigned int )tmp->next.rbe_right == (unsigned int )((void *)0)) {
            goto _L;
          } else {
#line 44
            if ((tmp->next.rbe_right)->next.rbe_color == 0) {
              _L: /* CIL Label */ 
#line 44
              oleft = tmp->next.rbe_left;
#line 44
              if (oleft) {
#line 44
                oleft->next.rbe_color = 0;
              }
#line 44
              tmp->next.rbe_color = 1;
#line 44
              while (1) {
#line 44
                oleft = tmp->next.rbe_left;
#line 44
                tmp->next.rbe_left = oleft->next.rbe_right;
#line 44
                if (tmp->next.rbe_left) {
#line 44
                  (oleft->next.rbe_right)->next.rbe_parent = tmp;
                }
#line 44
                oleft->next.rbe_parent = tmp->next.rbe_parent;
#line 44
                if (oleft->next.rbe_parent) {
#line 44
                  if ((unsigned int )tmp == (unsigned int )(tmp->next.rbe_parent)->next.rbe_left) {
#line 44
                    (tmp->next.rbe_parent)->next.rbe_left = oleft;
                  } else {
#line 44
                    (tmp->next.rbe_parent)->next.rbe_right = oleft;
                  }
                } else {
#line 44
                  head->rbh_root = oleft;
                }
#line 44
                oleft->next.rbe_right = tmp;
#line 44
                tmp->next.rbe_parent = oleft;
#line 44
                break;
              }
#line 44
              tmp = parent->next.rbe_right;
            }
          }
#line 44
          tmp->next.rbe_color = parent->next.rbe_color;
#line 44
          parent->next.rbe_color = 0;
#line 44
          if (tmp->next.rbe_right) {
#line 44
            (tmp->next.rbe_right)->next.rbe_color = 0;
          }
#line 44
          while (1) {
#line 44
            tmp = parent->next.rbe_right;
#line 44
            parent->next.rbe_right = tmp->next.rbe_left;
#line 44
            if (parent->next.rbe_right) {
#line 44
              (tmp->next.rbe_left)->next.rbe_parent = parent;
            }
#line 44
            tmp->next.rbe_parent = parent->next.rbe_parent;
#line 44
            if (tmp->next.rbe_parent) {
#line 44
              if ((unsigned int )parent == (unsigned int )(parent->next.rbe_parent)->next.rbe_left) {
#line 44
                (parent->next.rbe_parent)->next.rbe_left = tmp;
              } else {
#line 44
                (parent->next.rbe_parent)->next.rbe_right = tmp;
              }
            } else {
#line 44
              head->rbh_root = tmp;
            }
#line 44
            tmp->next.rbe_left = parent;
#line 44
            parent->next.rbe_parent = tmp;
#line 44
            break;
          }
#line 44
          elm = head->rbh_root;
#line 44
          break;
        }
      }
    } else {
#line 44
      tmp = parent->next.rbe_left;
#line 44
      if (tmp->next.rbe_color == 1) {
#line 44
        while (1) {
#line 44
          tmp->next.rbe_color = 0;
#line 44
          parent->next.rbe_color = 1;
#line 44
          break;
        }
#line 44
        while (1) {
#line 44
          tmp = parent->next.rbe_left;
#line 44
          parent->next.rbe_left = tmp->next.rbe_right;
#line 44
          if (parent->next.rbe_left) {
#line 44
            (tmp->next.rbe_right)->next.rbe_parent = parent;
          }
#line 44
          tmp->next.rbe_parent = parent->next.rbe_parent;
#line 44
          if (tmp->next.rbe_parent) {
#line 44
            if ((unsigned int )parent == (unsigned int )(parent->next.rbe_parent)->next.rbe_left) {
#line 44
              (parent->next.rbe_parent)->next.rbe_left = tmp;
            } else {
#line 44
              (parent->next.rbe_parent)->next.rbe_right = tmp;
            }
          } else {
#line 44
            head->rbh_root = tmp;
          }
#line 44
          tmp->next.rbe_right = parent;
#line 44
          parent->next.rbe_parent = tmp;
#line 44
          break;
        }
#line 44
        tmp = parent->next.rbe_left;
      }
#line 44
      if ((unsigned int )tmp->next.rbe_left == (unsigned int )((void *)0)) {
        goto _L___4;
      } else {
#line 44
        if ((tmp->next.rbe_left)->next.rbe_color == 0) {
          _L___4: /* CIL Label */ 
#line 44
          if ((unsigned int )tmp->next.rbe_right == (unsigned int )((void *)0)) {
#line 44
            tmp->next.rbe_color = 1;
#line 44
            elm = parent;
#line 44
            parent = elm->next.rbe_parent;
          } else {
#line 44
            if ((tmp->next.rbe_right)->next.rbe_color == 0) {
#line 44
              tmp->next.rbe_color = 1;
#line 44
              elm = parent;
#line 44
              parent = elm->next.rbe_parent;
            } else {
              goto _L___3;
            }
          }
        } else {
          _L___3: /* CIL Label */ 
#line 44
          if ((unsigned int )tmp->next.rbe_left == (unsigned int )((void *)0)) {
            goto _L___2;
          } else {
#line 44
            if ((tmp->next.rbe_left)->next.rbe_color == 0) {
              _L___2: /* CIL Label */ 
#line 44
              oright = tmp->next.rbe_right;
#line 44
              if (oright) {
#line 44
                oright->next.rbe_color = 0;
              }
#line 44
              tmp->next.rbe_color = 1;
#line 44
              while (1) {
#line 44
                oright = tmp->next.rbe_right;
#line 44
                tmp->next.rbe_right = oright->next.rbe_left;
#line 44
                if (tmp->next.rbe_right) {
#line 44
                  (oright->next.rbe_left)->next.rbe_parent = tmp;
                }
#line 44
                oright->next.rbe_parent = tmp->next.rbe_parent;
#line 44
                if (oright->next.rbe_parent) {
#line 44
                  if ((unsigned int )tmp == (unsigned int )(tmp->next.rbe_parent)->next.rbe_left) {
#line 44
                    (tmp->next.rbe_parent)->next.rbe_left = oright;
                  } else {
#line 44
                    (tmp->next.rbe_parent)->next.rbe_right = oright;
                  }
                } else {
#line 44
                  head->rbh_root = oright;
                }
#line 44
                oright->next.rbe_left = tmp;
#line 44
                tmp->next.rbe_parent = oright;
#line 44
                break;
              }
#line 44
              tmp = parent->next.rbe_left;
            }
          }
#line 44
          tmp->next.rbe_color = parent->next.rbe_color;
#line 44
          parent->next.rbe_color = 0;
#line 44
          if (tmp->next.rbe_left) {
#line 44
            (tmp->next.rbe_left)->next.rbe_color = 0;
          }
#line 44
          while (1) {
#line 44
            tmp = parent->next.rbe_left;
#line 44
            parent->next.rbe_left = tmp->next.rbe_right;
#line 44
            if (parent->next.rbe_left) {
#line 44
              (tmp->next.rbe_right)->next.rbe_parent = parent;
            }
#line 44
            tmp->next.rbe_parent = parent->next.rbe_parent;
#line 44
            if (tmp->next.rbe_parent) {
#line 44
              if ((unsigned int )parent == (unsigned int )(parent->next.rbe_parent)->next.rbe_left) {
#line 44
                (parent->next.rbe_parent)->next.rbe_left = tmp;
              } else {
#line 44
                (parent->next.rbe_parent)->next.rbe_right = tmp;
              }
            } else {
#line 44
              head->rbh_root = tmp;
            }
#line 44
            tmp->next.rbe_right = parent;
#line 44
            parent->next.rbe_parent = tmp;
#line 44
            break;
          }
#line 44
          elm = head->rbh_root;
#line 44
          break;
        }
      }
    }
  }
#line 44
  if (elm) {
#line 44
    elm->next.rbe_color = 0;
  }
#line 44
  return;
}
}
#line 44 "monitor_mm.c"
void mmtree_RB_REMOVE(struct mmtree *head , struct mm_share *elm ) 
{ struct mm_share *child ;
  struct mm_share *parent ;
  int color ;
  struct mm_share *old ;
  struct mm_share *left ;

  {
#line 44
  if ((unsigned int )elm->next.rbe_left == (unsigned int )((void *)0)) {
#line 44
    child = elm->next.rbe_right;
  } else {
#line 44
    if ((unsigned int )elm->next.rbe_right == (unsigned int )((void *)0)) {
#line 44
      child = elm->next.rbe_left;
    } else {
#line 44
      old = elm;
#line 44
      elm = elm->next.rbe_right;
#line 44
      while (1) {
#line 44
        left = elm->next.rbe_left;
#line 44
        if (! left) {
#line 44
          break;
        }
#line 44
        elm = left;
      }
#line 44
      child = elm->next.rbe_right;
#line 44
      parent = elm->next.rbe_parent;
#line 44
      color = elm->next.rbe_color;
#line 44
      if (child) {
#line 44
        child->next.rbe_parent = parent;
      }
#line 44
      if (parent) {
#line 44
        if ((unsigned int )parent->next.rbe_left == (unsigned int )elm) {
#line 44
          parent->next.rbe_left = child;
        } else {
#line 44
          parent->next.rbe_right = child;
        }
      } else {
#line 44
        head->rbh_root = child;
      }
#line 44
      if ((unsigned int )elm->next.rbe_parent == (unsigned int )old) {
#line 44
        parent = elm;
      }
#line 44
      elm->next = old->next;
#line 44
      if (old->next.rbe_parent) {
#line 44
        if ((unsigned int )(old->next.rbe_parent)->next.rbe_left == (unsigned int )old) {
#line 44
          (old->next.rbe_parent)->next.rbe_left = elm;
        } else {
#line 44
          (old->next.rbe_parent)->next.rbe_right = elm;
        }
      } else {
#line 44
        head->rbh_root = elm;
      }
#line 44
      (old->next.rbe_left)->next.rbe_parent = elm;
#line 44
      if (old->next.rbe_right) {
#line 44
        (old->next.rbe_right)->next.rbe_parent = elm;
      }
#line 44
      if (parent) {
#line 44
        left = parent;
#line 44
        while (1) {
#line 44
          left = left->next.rbe_parent;
#line 44
          if (! left) {
#line 44
            break;
          }
        }
      }
      goto color;
    }
  }
#line 44
  parent = elm->next.rbe_parent;
#line 44
  color = elm->next.rbe_color;
#line 44
  if (child) {
#line 44
    child->next.rbe_parent = parent;
  }
#line 44
  if (parent) {
#line 44
    if ((unsigned int )parent->next.rbe_left == (unsigned int )elm) {
#line 44
      parent->next.rbe_left = child;
    } else {
#line 44
      parent->next.rbe_right = child;
    }
  } else {
#line 44
    head->rbh_root = child;
  }
  color: 
#line 44
  if (color == 0) {
#line 44
    mmtree_RB_REMOVE_COLOR(head, parent, child);
  }
#line 44
  return;
}
}
#line 44 "monitor_mm.c"
struct mm_share *mmtree_RB_INSERT(struct mmtree *head , struct mm_share *elm ) 
{ struct mm_share *tmp ;
  struct mm_share *parent ;
  int comp ;

  {
#line 44
  parent = (struct mm_share *)((void *)0);
#line 44
  comp = 0;
#line 44
  tmp = head->rbh_root;
#line 44
  while (tmp) {
#line 44
    parent = tmp;
#line 44
    comp = mm_compare(elm, parent);
#line 44
    if (comp < 0) {
#line 44
      tmp = tmp->next.rbe_left;
    } else {
#line 44
      if (comp > 0) {
#line 44
        tmp = tmp->next.rbe_right;
      } else {
#line 44
        return (tmp);
      }
    }
  }
#line 44
  while (1) {
#line 44
    elm->next.rbe_parent = parent;
#line 44
    elm->next.rbe_right = (struct mm_share *)((void *)0);
#line 44
    elm->next.rbe_left = elm->next.rbe_right;
#line 44
    elm->next.rbe_color = 1;
#line 44
    break;
  }
#line 44
  if ((unsigned int )parent != (unsigned int )((void *)0)) {
#line 44
    if (comp < 0) {
#line 44
      parent->next.rbe_left = elm;
    } else {
#line 44
      parent->next.rbe_right = elm;
    }
  } else {
#line 44
    head->rbh_root = elm;
  }
#line 44
  mmtree_RB_INSERT_COLOR(head, elm);
#line 44
  return ((struct mm_share *)((void *)0));
}
}
#line 44 "monitor_mm.c"
struct mm_share *mmtree_RB_FIND(struct mmtree *head , struct mm_share *elm ) 
{ struct mm_share *tmp ;
  int comp ;

  {
#line 44
  tmp = head->rbh_root;
#line 44
  while (tmp) {
#line 44
    comp = mm_compare(elm, tmp);
#line 44
    if (comp < 0) {
#line 44
      tmp = tmp->next.rbe_left;
    } else {
#line 44
      if (comp > 0) {
#line 44
        tmp = tmp->next.rbe_right;
      } else {
#line 44
        return (tmp);
      }
    }
  }
#line 44
  return ((struct mm_share *)((void *)0));
}
}
#line 44 "monitor_mm.c"
struct mm_share *mmtree_RB_NEXT(struct mmtree *head , struct mm_share *elm ) 
{ 

  {
#line 44
  if (elm->next.rbe_right) {
#line 44
    elm = elm->next.rbe_right;
#line 44
    while (elm->next.rbe_left) {
#line 44
      elm = elm->next.rbe_left;
    }
  } else {
#line 44
    if (elm->next.rbe_parent) {
#line 44
      if ((unsigned int )elm == (unsigned int )(elm->next.rbe_parent)->next.rbe_left) {
#line 44
        elm = elm->next.rbe_parent;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 44
      while (1) {
#line 44
        if (elm->next.rbe_parent) {
#line 44
          if (! ((unsigned int )elm == (unsigned int )(elm->next.rbe_parent)->next.rbe_right)) {
#line 44
            break;
          }
        } else {
#line 44
          break;
        }
#line 44
        elm = elm->next.rbe_parent;
      }
#line 44
      elm = elm->next.rbe_parent;
    }
  }
#line 44
  return (elm);
}
}
#line 44 "monitor_mm.c"
struct mm_share *mmtree_RB_MINMAX(struct mmtree *head , int val ) 
{ struct mm_share *tmp ;
  struct mm_share *parent ;

  {
#line 44
  tmp = head->rbh_root;
#line 44
  parent = (struct mm_share *)((void *)0);
#line 44
  while (tmp) {
#line 44
    parent = tmp;
#line 44
    if (val < 0) {
#line 44
      tmp = tmp->next.rbe_left;
    } else {
#line 44
      tmp = tmp->next.rbe_right;
    }
  }
#line 44
  return (parent);
}
}
#line 46 "monitor_mm.c"
static struct mm_share *mm_make_entry(struct mm_master *mm , struct mmtree *head ,
                                      void *address , size_t size ) 
{ struct mm_share *tmp ;
  struct mm_share *tmp2 ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 52
  if ((unsigned int )mm->mmalloc == (unsigned int )((void *)0)) {
#line 53
    tmp___0 = xmalloc(sizeof(struct mm_share ));
#line 53
    tmp = (struct mm_share *)tmp___0;
  } else {
#line 55
    tmp___1 = mm_xmalloc(mm->mmalloc, sizeof(struct mm_share ));
#line 55
    tmp = (struct mm_share *)tmp___1;
  }
#line 56
  tmp->address = address;
#line 57
  tmp->size = size;
#line 59
  tmp2 = mmtree_RB_INSERT(head, tmp);
#line 60
  if ((unsigned int )tmp2 != (unsigned int )((void *)0)) {
#line 61
    fatal("mm_make_entry(%p): double address %p->%p(%lu)", mm, tmp2, address, (unsigned long )size);
  }
#line 64
  return (tmp);
}
}
#line 69 "monitor_mm.c"
struct mm_master *mm_create(struct mm_master *mmalloc , size_t size ) 
{ void *address ;
  struct mm_master *mm ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
#line 75
  if ((unsigned int )mmalloc == (unsigned int )((void *)0)) {
#line 76
    tmp = xmalloc(sizeof(struct mm_master ));
#line 76
    mm = (struct mm_master *)tmp;
  } else {
#line 78
    tmp___0 = mm_xmalloc(mmalloc, sizeof(struct mm_master ));
#line 78
    mm = (struct mm_master *)tmp___0;
  }
#line 85
  mm->mmalloc = mmalloc;
#line 88
  address = mmap((void *)0, size, 3, 33, -1, 0LL);
#line 90
  if ((unsigned int )address == (unsigned int )((void *)-1)) {
#line 91
    tmp___1 = __errno_location();
#line 91
    tmp___2 = strerror(*tmp___1);
#line 91
    fatal("mmap(%lu): %s", (unsigned long )size, tmp___2);
  }
#line 97
  mm->address = address;
#line 98
  mm->size = size;
#line 100
  while (1) {
#line 100
    mm->rb_free.rbh_root = (struct mm_share *)((void *)0);
#line 100
    break;
  }
#line 101
  while (1) {
#line 101
    mm->rb_allocated.rbh_root = (struct mm_share *)((void *)0);
#line 101
    break;
  }
#line 103
  mm_make_entry(mm, & mm->rb_free, address, size);
#line 105
  return (mm);
}
}
#line 110 "monitor_mm.c"
static void mm_freelist(struct mm_master *mmalloc , struct mmtree *head ) 
{ struct mm_share *mms ;
  struct mm_share *next ;

  {
#line 115
  mms = head->rbh_root;
#line 115
  while (mms) {
#line 116
    next = mmtree_RB_NEXT(head, mms);
#line 117
    mmtree_RB_REMOVE(head, mms);
#line 118
    if ((unsigned int )mmalloc == (unsigned int )((void *)0)) {
#line 119
      xfree((void *)mms);
    } else {
#line 121
      mm_free(mmalloc, (void *)mms);
    }
#line 115
    mms = next;
  }
#line 123
  return;
}
}
#line 127 "monitor_mm.c"
void mm_destroy(struct mm_master *mm ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 130
  mm_freelist(mm->mmalloc, & mm->rb_free);
#line 131
  mm_freelist(mm->mmalloc, & mm->rb_allocated);
#line 134
  tmp___1 = munmap(mm->address, mm->size);
#line 134
  if (tmp___1 == -1) {
#line 135
    tmp = __errno_location();
#line 135
    tmp___0 = strerror(*tmp);
#line 135
    fatal("munmap(%p, %lu): %s", mm->address, (unsigned long )mm->size, tmp___0);
  }
#line 141
  if ((unsigned int )mm->mmalloc == (unsigned int )((void *)0)) {
#line 142
    xfree((void *)mm);
  } else {
#line 144
    mm_free(mm->mmalloc, (void *)mm);
  }
#line 145
  return;
}
}
#line 147 "monitor_mm.c"
void *mm_xmalloc(struct mm_master *mm , size_t size ) 
{ void *address ;

  {
#line 152
  address = mm_malloc(mm, size);
#line 153
  if ((unsigned int )address == (unsigned int )((void *)0)) {
#line 154
    fatal("%s: mm_malloc(%lu)", "mm_xmalloc", (unsigned long )size);
  }
#line 155
  return (address);
}
}
#line 161 "monitor_mm.c"
void *mm_malloc(struct mm_master *mm , size_t size ) 
{ struct mm_share *mms ;
  struct mm_share *tmp ;

  {
#line 166
  if (size == 0U) {
#line 167
    fatal("mm_malloc: try to allocate 0 space");
  }
#line 169
  size = (((size + 128U) - 1U) / 128U) * 128U;
#line 171
  mms = mmtree_RB_MINMAX(& mm->rb_free, -1);
#line 171
  while ((unsigned int )mms != (unsigned int )((void *)0)) {
#line 172
    if (mms->size >= size) {
#line 173
      break;
    }
#line 171
    mms = mmtree_RB_NEXT(& mm->rb_free, mms);
  }
#line 176
  if ((unsigned int )mms == (unsigned int )((void *)0)) {
#line 177
    return ((void *)0);
  }
#line 180
  memset(mms->address, 208, size);
#line 182
  tmp = mm_make_entry(mm, & mm->rb_allocated, mms->address, size);
#line 185
  mms->size -= size;
#line 186
  mms->address = (void *)((u_char *)mms->address + size);
#line 188
  if (mms->size == 0U) {
#line 189
    mmtree_RB_REMOVE(& mm->rb_free, mms);
#line 190
    if ((unsigned int )mm->mmalloc == (unsigned int )((void *)0)) {
#line 191
      xfree((void *)mms);
    } else {
#line 193
      mm_free(mm->mmalloc, (void *)mms);
    }
  }
#line 196
  return (tmp->address);
}
}
#line 201 "monitor_mm.c"
void mm_free(struct mm_master *mm , void *address ) 
{ struct mm_share *mms ;
  struct mm_share *prev ;
  struct mm_share tmp ;
  struct mm_share *tmp___0 ;

  {
#line 206
  tmp.address = address;
#line 207
  mms = mmtree_RB_FIND(& mm->rb_allocated, & tmp);
#line 208
  if ((unsigned int )mms == (unsigned int )((void *)0)) {
#line 209
    fatal("mm_free(%p): can not find %p", mm, address);
  }
#line 212
  memset(mms->address, 208, mms->size);
#line 215
  mmtree_RB_REMOVE(& mm->rb_allocated, mms);
#line 216
  tmp___0 = mmtree_RB_INSERT(& mm->rb_free, mms);
#line 216
  if ((unsigned int )tmp___0 != (unsigned int )((void *)0)) {
#line 217
    fatal("mm_free(%p): double address %p", mm, address);
  }
#line 220
  prev = mms;
#line 221
  if (prev->next.rbe_left) {
#line 222
    prev = prev->next.rbe_left;
#line 223
    while (prev->next.rbe_right) {
#line 224
      prev = prev->next.rbe_right;
    }
  } else {
#line 226
    if (prev->next.rbe_parent) {
#line 226
      if ((unsigned int )prev == (unsigned int )(prev->next.rbe_parent)->next.rbe_right) {
#line 228
        prev = prev->next.rbe_parent;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 230
      while (1) {
#line 230
        if (prev->next.rbe_parent) {
#line 230
          if (! ((unsigned int )prev == (unsigned int )(prev->next.rbe_parent)->next.rbe_left)) {
#line 230
            break;
          }
        } else {
#line 230
          break;
        }
#line 232
        prev = prev->next.rbe_parent;
      }
#line 233
      prev = prev->next.rbe_parent;
    }
  }
#line 238
  if ((unsigned int )prev != (unsigned int )((void *)0)) {
#line 238
    if ((unsigned int )((void *)((u_char *)prev->address + prev->size)) > (unsigned int )address) {
#line 239
      fatal("mm_free: memory corruption: %p(%lu) > %p", prev->address, (unsigned long )prev->size,
            address);
    }
  }
#line 243
  if ((unsigned int )prev != (unsigned int )((void *)0)) {
#line 243
    if ((unsigned int )((void *)((u_char *)prev->address + prev->size)) == (unsigned int )address) {
#line 244
      prev->size += mms->size;
#line 245
      mmtree_RB_REMOVE(& mm->rb_free, mms);
#line 246
      if ((unsigned int )mm->mmalloc == (unsigned int )((void *)0)) {
#line 247
        xfree((void *)mms);
      } else {
#line 249
        mm_free(mm->mmalloc, (void *)mms);
      }
    } else {
#line 251
      prev = mms;
    }
  } else {
#line 251
    prev = mms;
  }
#line 253
  if ((unsigned int )prev == (unsigned int )((void *)0)) {
#line 254
    return;
  }
#line 257
  mms = mmtree_RB_NEXT(& mm->rb_free, prev);
#line 258
  if ((unsigned int )mms == (unsigned int )((void *)0)) {
#line 259
    return;
  }
#line 261
  if ((unsigned int )((void *)((u_char *)prev->address + prev->size)) > (unsigned int )mms->address) {
#line 262
    fatal("mm_free: memory corruption: %p < %p(%lu)", mms->address, prev->address,
          (unsigned long )prev->size);
  }
#line 264
  if ((unsigned int )((void *)((u_char *)prev->address + prev->size)) != (unsigned int )mms->address) {
#line 265
    return;
  }
#line 267
  prev->size += mms->size;
#line 268
  mmtree_RB_REMOVE(& mm->rb_free, mms);
#line 270
  if ((unsigned int )mm->mmalloc == (unsigned int )((void *)0)) {
#line 271
    xfree((void *)mms);
  } else {
#line 273
    mm_free(mm->mmalloc, (void *)mms);
  }
#line 274
  return;
}
}
#line 276 "monitor_mm.c"
static void mm_sync_list(struct mmtree *oldtree , struct mmtree *newtree , struct mm_master *mm ,
                         struct mm_master *mmold ) 
{ struct mm_master *mmalloc ;
  struct mm_share *mms ;
  struct mm_share *new ;
  void *tmp ;

  {
#line 280
  mmalloc = mm->mmalloc;
#line 284
  mms = mmtree_RB_MINMAX(oldtree, -1);
#line 284
  while ((unsigned int )mms != (unsigned int )((void *)0)) {
#line 286
    mm_memvalid(mmold, (void *)mms, sizeof(struct mm_share ));
#line 287
    mm_memvalid(mm, mms->address, mms->size);
#line 289
    tmp = mm_xmalloc(mmalloc, sizeof(struct mm_share ));
#line 289
    new = (struct mm_share *)tmp;
#line 290
    memcpy((void * __restrict  )new, (void const   * __restrict  )mms, sizeof(struct mm_share ));
#line 291
    mmtree_RB_INSERT(newtree, new);
#line 284
    mms = mmtree_RB_NEXT(oldtree, mms);
  }
#line 293
  return;
}
}
#line 295 "monitor_mm.c"
void mm_share_sync(struct mm_master **pmm , struct mm_master **pmmalloc ) 
{ struct mm_master *mm ;
  struct mm_master *mmalloc ;
  struct mm_master *mmold ;
  struct mmtree rb_free ;
  struct mmtree rb_allocated ;
  void *tmp ;

  {
#line 303
  debug3("%s: Share sync", "mm_share_sync");
#line 305
  mm = *pmm;
#line 306
  mmold = mm->mmalloc;
#line 307
  mm_memvalid(mmold, (void *)mm, sizeof(*mm));
#line 309
  mmalloc = mm_create((struct mm_master *)((void *)0), mm->size);
#line 310
  tmp = mm_xmalloc(mmalloc, sizeof(struct mm_master ));
#line 310
  mm = (struct mm_master *)tmp;
#line 311
  memcpy((void * __restrict  )mm, (void const   * __restrict  )*pmm, sizeof(struct mm_master ));
#line 312
  mm->mmalloc = mmalloc;
#line 314
  rb_free = mm->rb_free;
#line 315
  rb_allocated = mm->rb_allocated;
#line 317
  while (1) {
#line 317
    mm->rb_free.rbh_root = (struct mm_share *)((void *)0);
#line 317
    break;
  }
#line 318
  while (1) {
#line 318
    mm->rb_allocated.rbh_root = (struct mm_share *)((void *)0);
#line 318
    break;
  }
#line 320
  mm_sync_list(& rb_free, & mm->rb_free, mm, mmold);
#line 321
  mm_sync_list(& rb_allocated, & mm->rb_allocated, mm, mmold);
#line 323
  mm_destroy(mmold);
#line 325
  *pmm = mm;
#line 326
  *pmmalloc = mmalloc;
#line 328
  debug3("%s: Share sync end", "mm_share_sync");
#line 329
  return;
}
}
#line 331 "monitor_mm.c"
void mm_memvalid(struct mm_master *mm , void *address , size_t size ) 
{ void *end ;

  {
#line 334
  end = (void *)((u_char *)address + size);
#line 336
  if ((unsigned int )address < (unsigned int )mm->address) {
#line 337
    fatal("mm_memvalid: address too small: %p", address);
  }
#line 338
  if ((unsigned int )end < (unsigned int )address) {
#line 339
    fatal("mm_memvalid: end < address: %p < %p", end, address);
  }
#line 340
  if ((unsigned int )end > (unsigned int )((void *)((u_char *)mm->address + mm->size))) {
#line 341
    fatal("mm_memvalid: address too large: %p", address);
  }
#line 342
  return;
}
}
#line 1 "monitor.o"
#line 75 "monitor.h"
int monitor_read(struct monitor *pmonitor___0 , struct mon_table *ent , struct mon_table **pent ) ;
#line 75 "monitor_wrap.h"
void mm_get_keystate(struct monitor *pmonitor___0 ) ;
#line 88
void *mm_zalloc(struct mm_master *mm , u_int ncount , u_int size ) ;
#line 89
void mm_zfree(struct mm_master *mm , void *address ) ;
#line 90
void mm_init_compression(struct mm_master *mm ) ;
#line 75 "monitor.c"
struct __anonstruct_child_state_73 child_state  ;
#line 98
int mm_answer_moduli(int socket___0 , Buffer *m___0 ) ;
#line 99
int mm_answer_sign(int socket___0 , Buffer *m___0 ) ;
#line 100
int mm_answer_pwnamallow(int socket___0 , Buffer *m___0 ) ;
#line 101
int mm_answer_auth2_read_banner(int socket___0 , Buffer *m___0 ) ;
#line 102
int mm_answer_authserv(int socket___0 , Buffer *m___0 ) ;
#line 103
int mm_answer_authpassword(int socket___0 , Buffer *m___0 ) ;
#line 108
int mm_answer_keyallowed(int socket___0 , Buffer *m___0 ) ;
#line 109
int mm_answer_keyverify(int socket___0 , Buffer *m___0 ) ;
#line 110
int mm_answer_pty(int socket___0 , Buffer *m___0 ) ;
#line 111
int mm_answer_pty_cleanup(int socket___0 , Buffer *m___0 ) ;
#line 112
int mm_answer_term(int socket___0 , Buffer *req ) ;
#line 113
int mm_answer_rsa_keyallowed(int socket___0 , Buffer *m___0 ) ;
#line 114
int mm_answer_rsa_challenge(int socket___0 , Buffer *m___0 ) ;
#line 115
int mm_answer_rsa_response(int socket___0 , Buffer *m___0 ) ;
#line 116
int mm_answer_sesskey(int socket___0 , Buffer *m___0 ) ;
#line 117
int mm_answer_sessid(int socket___0 , Buffer *m___0 ) ;
#line 123 "monitor.c"
static Authctxt *authctxt  ;
#line 124 "monitor.c"
static BIGNUM *ssh1_challenge  =    (BIGNUM *)((void *)0);
#line 127 "monitor.c"
static u_char *key_blob  =    (u_char *)((void *)0);
#line 128 "monitor.c"
static u_int key_bloblen  =    (u_int )0;
#line 129 "monitor.c"
static int key_blobtype  =    0;
#line 130 "monitor.c"
static u_char *hostbased_cuser  =    (u_char *)((void *)0);
#line 131 "monitor.c"
static u_char *hostbased_chost  =    (u_char *)((void *)0);
#line 132 "monitor.c"
static char *auth_method  =    (char *)"unknown";
#line 133 "monitor.c"
static int session_id2_len___0  =    0;
#line 134 "monitor.c"
static u_char *session_id2___0  =    (u_char *)((void *)0);
#line 150 "monitor.c"
struct mon_table mon_dispatch_proto20[9]  = 
#line 150
  {      {0, 16, & mm_answer_moduli}, 
        {4, 16, & mm_answer_sign}, 
        {6, 16, & mm_answer_pwnamallow}, 
        {3, 16, & mm_answer_authserv}, 
        {8, 16, & mm_answer_auth2_read_banner}, 
        {10, 12, & mm_answer_authpassword}, 
        {20, 4, & mm_answer_keyallowed}, 
        {22, 12, & mm_answer_keyverify}, 
        {(enum monitor_reqtype )0, 0, (int (*)(int  , Buffer * ))((void *)0)}};
#line 173 "monitor.c"
struct mon_table mon_dispatch_postauth20[6]  = {      {0, 0, & mm_answer_moduli}, 
        {4, 0, & mm_answer_sign}, 
        {25, 0, & mm_answer_pty}, 
        {27, 0, & mm_answer_pty_cleanup}, 
        {38, 0, & mm_answer_term}, 
        {(enum monitor_reqtype )0, 0, (int (*)(int  , Buffer * ))((void *)0)}};
#line 182 "monitor.c"
struct mon_table mon_dispatch_proto15[9]  = 
#line 182
  {      {6, 16, & mm_answer_pwnamallow}, 
        {28, 16, & mm_answer_sesskey}, 
        {30, 16, & mm_answer_sessid}, 
        {10, 12, & mm_answer_authpassword}, 
        {31, 4, & mm_answer_rsa_keyallowed}, 
        {20, 4, & mm_answer_keyallowed}, 
        {33, 16, & mm_answer_rsa_challenge}, 
        {35, 24, & mm_answer_rsa_response}, 
        {(enum monitor_reqtype )0, 0, (int (*)(int  , Buffer * ))((void *)0)}};
#line 205 "monitor.c"
struct mon_table mon_dispatch_postauth15[4]  = {      {25, 16, & mm_answer_pty}, 
        {27, 16, & mm_answer_pty_cleanup}, 
        {38, 0, & mm_answer_term}, 
        {(enum monitor_reqtype )0, 0, (int (*)(int  , Buffer * ))((void *)0)}};
#line 212 "monitor.c"
struct mon_table *mon_dispatch  ;
#line 216 "monitor.c"
static void monitor_permit(struct mon_table *ent , enum monitor_reqtype type , int permit ) 
{ int tmp ;

  {
#line 219
  while ((unsigned int )ent->f != (unsigned int )((void *)0)) {
#line 220
    if ((int )ent->type == (int )type) {
#line 221
      ent->flags &= -4097;
#line 222
      if (permit) {
#line 222
        tmp = 4096;
      } else {
#line 222
        tmp = 0;
      }
#line 222
      ent->flags |= tmp;
#line 223
      return;
    }
#line 225
    ent ++;
  }
#line 227
  return;
}
}
#line 229 "monitor.c"
static void monitor_permit_authentications(int permit ) 
{ struct mon_table *ent ;
  int tmp ;

  {
#line 232
  ent = mon_dispatch;
#line 234
  while ((unsigned int )ent->f != (unsigned int )((void *)0)) {
#line 235
    if (ent->flags & 12) {
#line 236
      ent->flags &= -4097;
#line 237
      if (permit) {
#line 237
        tmp = 4096;
      } else {
#line 237
        tmp = 0;
      }
#line 237
      ent->flags |= tmp;
    }
#line 239
    ent ++;
  }
#line 241
  return;
}
}
#line 243 "monitor.c"
struct Authctxt *monitor_child_preauth(struct monitor *pmonitor___0 ) 
{ struct mon_table *ent ;
  int authenticated ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 247
  authenticated = 0;
#line 249
  debug3("preauth child monitor started");
#line 251
  if (compat20) {
#line 252
    mon_dispatch = mon_dispatch_proto20;
#line 255
    monitor_permit(mon_dispatch, 0, 1);
#line 256
    monitor_permit(mon_dispatch, 4, 1);
  } else {
#line 258
    mon_dispatch = mon_dispatch_proto15;
#line 260
    monitor_permit(mon_dispatch, 28, 1);
  }
#line 263
  authctxt = authctxt_new();
#line 266
  while (! authenticated) {
#line 267
    authenticated = monitor_read(pmonitor___0, mon_dispatch, & ent);
#line 268
    if (authenticated) {
#line 269
      if (! (ent->flags & 8)) {
#line 270
        fatal("%s: unexpected authentication from %d", "monitor_child_preauth", ent->type);
      }
#line 272
      if ((authctxt->pw)->pw_uid == 0U) {
#line 272
        tmp = auth_root_allowed(auth_method);
#line 272
        if (! tmp) {
#line 274
          authenticated = 0;
        }
      }
    }
#line 281
    if (ent->flags & 8) {
#line 282
      if (compat20) {
#line 282
        tmp___0 = " ssh2";
      } else {
#line 282
        tmp___0 = "";
      }
#line 282
      auth_log(authctxt, authenticated, auth_method, (char *)tmp___0);
#line 284
      if (! authenticated) {
#line 285
        (authctxt->failures) ++;
      }
    }
  }
#line 289
  if (! authctxt->valid) {
#line 290
    fatal("%s: authenticated invalid user", "monitor_child_preauth");
  }
#line 292
  debug("%s: %s has been authenticated by privileged process", "monitor_child_preauth",
        authctxt->user);
#line 295
  mm_get_keystate(pmonitor___0);
#line 297
  return (authctxt);
}
}
#line 300 "monitor.c"
void monitor_child_postauth(struct monitor *pmonitor___0 ) 
{ 

  {
#line 303
  if (compat20) {
#line 304
    mon_dispatch = mon_dispatch_postauth20;
#line 307
    monitor_permit(mon_dispatch, 0, 1);
#line 308
    monitor_permit(mon_dispatch, 4, 1);
#line 309
    monitor_permit(mon_dispatch, 38, 1);
  } else {
#line 312
    mon_dispatch = mon_dispatch_postauth15;
#line 313
    monitor_permit(mon_dispatch, 38, 1);
  }
#line 315
  if (! no_pty_flag) {
#line 316
    monitor_permit(mon_dispatch, 25, 1);
#line 317
    monitor_permit(mon_dispatch, 27, 1);
  }
#line 320
  while (1) {
#line 321
    monitor_read(pmonitor___0, mon_dispatch, (struct mon_table **)((void *)0));
  }
}
}
#line 324 "monitor.c"
void monitor_sync(struct monitor *pmonitor___0 ) 
{ 

  {
#line 327
  if (options.compression) {
#line 329
    mm_share_sync(& pmonitor___0->m_zlib, & pmonitor___0->m_zback);
  }
#line 331
  return;
}
}
#line 333 "monitor.c"
int monitor_read(struct monitor *pmonitor___0 , struct mon_table *ent , struct mon_table **pent ) 
{ Buffer m___0 ;
  int ret ;
  u_char type ;
  int tmp ;

  {
#line 341
  buffer_init(& m___0);
#line 343
  mm_request_receive(pmonitor___0->m_sendfd, & m___0);
#line 344
  tmp = buffer_get_char(& m___0);
#line 344
  type = (unsigned char )tmp;
#line 346
  debug3("%s: checking request %d", "monitor_read", type);
#line 348
  while ((unsigned int )ent->f != (unsigned int )((void *)0)) {
#line 349
    if ((int )ent->type == (int )type) {
#line 350
      break;
    }
#line 351
    ent ++;
  }
#line 354
  if ((unsigned int )ent->f != (unsigned int )((void *)0)) {
#line 355
    if (! (ent->flags & 4096)) {
#line 356
      fatal("%s: unpermitted request %d", "monitor_read", type);
    }
#line 358
    ret = (*(ent->f))(pmonitor___0->m_sendfd, & m___0);
#line 359
    buffer_free(& m___0);
#line 362
    if (ent->flags & 16) {
#line 363
      debug2("%s: %d used once, disabling now", "monitor_read", type);
#line 365
      ent->flags &= -4097;
    }
#line 368
    if ((unsigned int )pent != (unsigned int )((void *)0)) {
#line 369
      *pent = ent;
    }
#line 371
    return (ret);
  }
#line 374
  fatal("%s: unsupported request: %d", "monitor_read", type);
#line 377
  return (-1);
}
}
#line 381 "monitor.c"
static int monitor_allowed_key(u_char *blob , u_int bloblen ) 
{ int tmp ;

  {
#line 385
  if ((unsigned int )key_blob == (unsigned int )((void *)0)) {
#line 387
    return (0);
  } else {
#line 385
    if (key_bloblen != bloblen) {
#line 387
      return (0);
    } else {
#line 385
      tmp = memcmp((void const   *)key_blob, (void const   *)blob, key_bloblen);
#line 385
      if (tmp) {
#line 387
        return (0);
      }
    }
  }
#line 388
  return (1);
}
}
#line 391 "monitor.c"
static void monitor_reset_key_state(void) 
{ 

  {
#line 395
  if ((unsigned int )key_blob != (unsigned int )((void *)0)) {
#line 396
    xfree((void *)key_blob);
  }
#line 397
  if ((unsigned int )hostbased_cuser != (unsigned int )((void *)0)) {
#line 398
    xfree((void *)hostbased_cuser);
  }
#line 399
  if ((unsigned int )hostbased_chost != (unsigned int )((void *)0)) {
#line 400
    xfree((void *)hostbased_chost);
  }
#line 401
  key_blob = (u_char *)((void *)0);
#line 402
  key_bloblen = 0U;
#line 403
  key_blobtype = 0;
#line 404
  hostbased_cuser = (u_char *)((void *)0);
#line 405
  hostbased_chost = (u_char *)((void *)0);
#line 406
  return;
}
}
#line 408 "monitor.c"
int mm_answer_moduli(int socket___0 , Buffer *m___0 ) 
{ DH *dh ;
  int min ;
  int want ;
  int max ;
  u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;

  {
#line 414
  tmp = buffer_get_int(m___0);
#line 414
  min = (int )tmp;
#line 415
  tmp___0 = buffer_get_int(m___0);
#line 415
  want = (int )tmp___0;
#line 416
  tmp___1 = buffer_get_int(m___0);
#line 416
  max = (int )tmp___1;
#line 418
  debug3("%s: got parameters: %d %d %d", "mm_answer_moduli", min, want, max);
#line 421
  if (max < min) {
#line 422
    fatal("%s: bad parameters: %d %d %d", "mm_answer_moduli", min, want, max);
  } else {
#line 421
    if (want < min) {
#line 422
      fatal("%s: bad parameters: %d %d %d", "mm_answer_moduli", min, want, max);
    } else {
#line 421
      if (max < want) {
#line 422
        fatal("%s: bad parameters: %d %d %d", "mm_answer_moduli", min, want, max);
      }
    }
  }
#line 425
  buffer_clear(m___0);
#line 427
  dh = choose_dh(min, want, max);
#line 428
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 429
    buffer_put_char(m___0, 0);
#line 430
    return (0);
  } else {
#line 433
    buffer_put_char(m___0, 1);
#line 434
    buffer_put_bignum2(m___0, dh->p);
#line 435
    buffer_put_bignum2(m___0, dh->g);
#line 437
    DH_free(dh);
  }
#line 439
  mm_request_send(socket___0, 1, m___0);
#line 440
  return (0);
}
}
#line 443 "monitor.c"
int mm_answer_sign(int socket___0 , Buffer *m___0 ) 
{ Key *key ;
  u_char *p ;
  u_char *signature ;
  u_int siglen ;
  u_int datlen ;
  int keyid ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 452
  debug3("%s", "mm_answer_sign");
#line 454
  tmp = buffer_get_int(m___0);
#line 454
  keyid = (int )tmp;
#line 455
  tmp___0 = buffer_get_string(m___0, & datlen);
#line 455
  p = (u_char *)tmp___0;
#line 457
  if (datlen != 20U) {
#line 458
    fatal("%s: data length incorrect: %d", "mm_answer_sign", datlen);
  }
#line 461
  if (session_id2_len___0 == 0) {
#line 462
    session_id2_len___0 = (int )datlen;
#line 463
    tmp___1 = xmalloc((unsigned int )session_id2_len___0);
#line 463
    session_id2___0 = (u_char *)tmp___1;
#line 464
    memcpy((void * __restrict  )session_id2___0, (void const   * __restrict  )p, (unsigned int )session_id2_len___0);
  }
#line 467
  key = get_hostkey_by_index(keyid);
#line 467
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 468
    fatal("%s: no hostkey from index %d", "mm_answer_sign", keyid);
  }
#line 469
  tmp___2 = key_sign(key, & signature, & siglen, p, datlen);
#line 469
  if (tmp___2 < 0) {
#line 470
    fatal("%s: key_sign failed", "mm_answer_sign");
  }
#line 472
  debug3("%s: signature %p(%d)", "mm_answer_sign", signature, siglen);
#line 474
  buffer_clear(m___0);
#line 475
  buffer_put_string(m___0, (void const   *)signature, siglen);
#line 477
  xfree((void *)p);
#line 478
  xfree((void *)signature);
#line 480
  mm_request_send(socket___0, 5, m___0);
#line 483
  monitor_permit(mon_dispatch, 6, 1);
#line 485
  return (0);
}
}
#line 490 "monitor.c"
int mm_answer_pwnamallow(int socket___0 , Buffer *m___0 ) 
{ char *login___0 ;
  struct passwd *pwent ;
  int allowed ;
  int tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 495
  allowed = 0;
#line 497
  debug3("%s", "mm_answer_pwnamallow");
#line 499
  tmp = authctxt->attempt;
#line 499
  (authctxt->attempt) ++;
#line 499
  if (tmp != 0) {
#line 500
    fatal("%s: multiple attempts for getpwnam", "mm_answer_pwnamallow");
  }
#line 502
  tmp___0 = buffer_get_string(m___0, (u_int *)((void *)0));
#line 502
  login___0 = (char *)tmp___0;
#line 504
  pwent = getpwnamallow((char const   *)login___0);
#line 506
  authctxt->user = xstrdup((char const   *)login___0);
#line 507
  if (pwent) {
#line 507
    tmp___1 = (char const   *)login___0;
  } else {
#line 507
    tmp___1 = "unknown";
  }
#line 507
  setproctitle("%s [priv]", tmp___1);
#line 508
  xfree((void *)login___0);
#line 510
  buffer_clear(m___0);
#line 512
  if ((unsigned int )pwent == (unsigned int )((void *)0)) {
#line 513
    buffer_put_char(m___0, 0);
    goto out;
  }
#line 517
  allowed = 1;
#line 518
  authctxt->pw = pwent;
#line 519
  authctxt->valid = 1;
#line 521
  buffer_put_char(m___0, 1);
#line 522
  buffer_put_string(m___0, (void const   *)pwent, sizeof(struct passwd ));
#line 523
  buffer_put_cstring(m___0, (char const   *)pwent->pw_name);
#line 524
  buffer_put_cstring(m___0, "*");
#line 525
  buffer_put_cstring(m___0, (char const   *)pwent->pw_gecos);
#line 529
  buffer_put_cstring(m___0, (char const   *)pwent->pw_dir);
#line 530
  buffer_put_cstring(m___0, (char const   *)pwent->pw_shell);
  out: 
#line 533
  debug3("%s: sending MONITOR_ANS_PWNAM: %d", "mm_answer_pwnamallow", allowed);
#line 534
  mm_request_send(socket___0, 7, m___0);
#line 537
  if (! compat20) {
#line 538
    monitor_permit_authentications(1);
  } else {
#line 541
    monitor_permit(mon_dispatch, 3, 1);
#line 542
    monitor_permit(mon_dispatch, 8, 1);
  }
#line 549
  return (0);
}
}
#line 552 "monitor.c"
int mm_answer_auth2_read_banner(int socket___0 , Buffer *m___0 ) 
{ char *banner ;
  char const   *tmp ;

  {
#line 556
  buffer_clear(m___0);
#line 557
  banner = auth2_read_banner();
#line 558
  if ((unsigned int )banner != (unsigned int )((void *)0)) {
#line 558
    tmp = (char const   *)banner;
  } else {
#line 558
    tmp = "";
  }
#line 558
  buffer_put_cstring(m___0, tmp);
#line 559
  mm_request_send(socket___0, 9, m___0);
#line 561
  if ((unsigned int )banner != (unsigned int )((void *)0)) {
#line 562
    free((void *)banner);
  }
#line 564
  return (0);
}
}
#line 567 "monitor.c"
int mm_answer_authserv(int socket___0 , Buffer *m___0 ) 
{ void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
#line 570
  monitor_permit_authentications(1);
#line 572
  tmp = buffer_get_string(m___0, (u_int *)((void *)0));
#line 572
  authctxt->service = (char *)tmp;
#line 573
  tmp___0 = buffer_get_string(m___0, (u_int *)((void *)0));
#line 573
  authctxt->style = (char *)tmp___0;
#line 574
  debug3("%s: service=%s, style=%s", "mm_answer_authserv", authctxt->service, authctxt->style);
#line 577
  tmp___1 = strlen((char const   *)authctxt->style);
#line 577
  if (tmp___1 == 0U) {
#line 578
    xfree((void *)authctxt->style);
#line 579
    authctxt->style = (char *)((void *)0);
  }
#line 582
  return (0);
}
}
#line 588 "monitor.c"
static int call_count  ;
#line 585 "monitor.c"
int mm_answer_authpassword(int socket___0 , Buffer *m___0 ) 
{ char *passwd ;
  int authenticated ;
  int plen ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
#line 592
  tmp = buffer_get_string(m___0, (u_int *)(& plen));
#line 592
  passwd = (char *)tmp;
#line 594
  if (options.password_authentication) {
#line 594
    if (authctxt->valid) {
#line 594
      tmp___0 = auth_password(authctxt, (char const   *)passwd);
#line 594
      if (tmp___0) {
#line 594
        tmp___1 = 1;
      } else {
#line 594
        tmp___1 = 0;
      }
    } else {
#line 594
      tmp___1 = 0;
    }
  } else {
#line 594
    tmp___1 = 0;
  }
#line 594
  authenticated = tmp___1;
#line 596
  tmp___2 = strlen((char const   *)passwd);
#line 596
  memset((void *)passwd, 0, tmp___2);
#line 597
  xfree((void *)passwd);
#line 599
  buffer_clear(m___0);
#line 600
  buffer_put_int(m___0, (unsigned int )authenticated);
#line 602
  debug3("%s: sending result %d", "mm_answer_authpassword", authenticated);
#line 603
  mm_request_send(socket___0, 11, m___0);
#line 605
  call_count ++;
#line 606
  if (plen == 0) {
#line 606
    if (call_count == 1) {
#line 607
      auth_method = (char *)"none";
    } else {
#line 609
      auth_method = (char *)"password";
    }
  } else {
#line 609
    auth_method = (char *)"password";
  }
#line 612
  return (authenticated);
}
}
#line 738 "monitor.c"
static void mm_append_debug(Buffer *m___0 ) 
{ u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;

  {
#line 741
  if (auth_debug_init) {
#line 741
    tmp___1 = buffer_len(& auth_debug);
#line 741
    if (tmp___1) {
#line 742
      debug3("%s: Appending debug messages for child", "mm_append_debug");
#line 743
      tmp = buffer_len(& auth_debug);
#line 743
      tmp___0 = buffer_ptr(& auth_debug);
#line 743
      buffer_append(m___0, (void const   *)tmp___0, tmp);
#line 745
      buffer_clear(& auth_debug);
    }
  }
#line 747
  return;
}
}
#line 749 "monitor.c"
int mm_answer_keyallowed(int socket___0 , Buffer *m___0 ) 
{ Key *key ;
  u_char *cuser ;
  u_char *chost ;
  u_char *blob ;
  u_int bloblen ;
  enum mm_keytype type ;
  int allowed ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;

  {
#line 755
  type = (enum mm_keytype )0;
#line 756
  allowed = 0;
#line 758
  debug3("%s entering", "mm_answer_keyallowed");
#line 760
  tmp = buffer_get_int(m___0);
#line 760
  type = (enum mm_keytype )tmp;
#line 761
  tmp___0 = buffer_get_string(m___0, (u_int *)((void *)0));
#line 761
  cuser = (u_char *)tmp___0;
#line 762
  tmp___1 = buffer_get_string(m___0, (u_int *)((void *)0));
#line 762
  chost = (u_char *)tmp___1;
#line 763
  tmp___2 = buffer_get_string(m___0, & bloblen);
#line 763
  blob = (u_char *)tmp___2;
#line 765
  key = key_from_blob(blob, (int )bloblen);
#line 767
  if (compat20) {
#line 767
    if ((int )type == 3) {
#line 769
      fatal("%s: key type and protocol mismatch", "mm_answer_keyallowed");
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 767
    if (! compat20) {
#line 767
      if ((int )type != 3) {
#line 769
        fatal("%s: key type and protocol mismatch", "mm_answer_keyallowed");
      }
    }
  }
#line 771
  debug3("%s: key_from_blob: %p", "mm_answer_keyallowed", key);
#line 773
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 773
    if ((unsigned int )authctxt->pw != (unsigned int )((void *)0)) {
#line 774
      switch ((int )type) {
      case 2: 
#line 776
      if (options.pubkey_authentication) {
#line 776
        tmp___3 = user_key_allowed(authctxt->pw, key);
#line 776
        if (tmp___3) {
#line 776
          tmp___4 = 1;
        } else {
#line 776
          tmp___4 = 0;
        }
      } else {
#line 776
        tmp___4 = 0;
      }
#line 776
      allowed = tmp___4;
#line 778
      break;
      case 1: 
#line 780
      if (options.hostbased_authentication) {
#line 780
        tmp___5 = hostbased_key_allowed(authctxt->pw, (char const   *)cuser, (char *)chost,
                                        key);
#line 780
        if (tmp___5) {
#line 780
          tmp___6 = 1;
        } else {
#line 780
          tmp___6 = 0;
        }
      } else {
#line 780
        tmp___6 = 0;
      }
#line 780
      allowed = tmp___6;
#line 783
      break;
      case 3: 
#line 785
      key->type = 0;
#line 786
      if (options.rhosts_rsa_authentication) {
#line 786
        tmp___7 = auth_rhosts_rsa_key_allowed(authctxt->pw, (char *)cuser, (char *)chost,
                                              key);
#line 786
        if (tmp___7) {
#line 786
          tmp___8 = 1;
        } else {
#line 786
          tmp___8 = 0;
        }
      } else {
#line 786
        tmp___8 = 0;
      }
#line 786
      allowed = tmp___8;
#line 789
      break;
      default: 
#line 791
      fatal("%s: unknown key type %d", "mm_answer_keyallowed", type);
#line 792
      break;
      }
#line 794
      key_free(key);
    }
  }
#line 798
  monitor_reset_key_state();
#line 800
  if (allowed) {
#line 802
    key_blob = blob;
#line 803
    key_bloblen = bloblen;
#line 804
    key_blobtype = (int )type;
#line 805
    hostbased_cuser = cuser;
#line 806
    hostbased_chost = chost;
  }
#line 809
  if (allowed) {
#line 809
    tmp___9 = "allowed";
  } else {
#line 809
    tmp___9 = "disallowed";
  }
#line 809
  debug3("%s: key %p is %s", "mm_answer_keyallowed", key, tmp___9);
#line 812
  buffer_clear(m___0);
#line 813
  buffer_put_int(m___0, (unsigned int )allowed);
#line 815
  mm_append_debug(m___0);
#line 817
  mm_request_send(socket___0, 21, m___0);
#line 819
  if ((int )type == 3) {
#line 820
    monitor_permit(mon_dispatch, 33, allowed);
  }
#line 822
  return (0);
}
}
#line 825 "monitor.c"
static int monitor_valid_userblob(u_char *data , u_int datalen ) 
{ Buffer b ;
  u_char *p ;
  u_int len ;
  int fail ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___10 ;
  int tmp___13 ;
  int tmp___14 ;
  u_int l ;
  u_int tmp___15 ;
  int tmp___16 ;
  void *tmp___17 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___23 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  u_int l___0 ;
  u_int tmp___29 ;
  u_int l___1 ;
  u_int tmp___30 ;
  u_int tmp___31 ;

  {
#line 831
  fail = 0;
#line 833
  buffer_init(& b);
#line 834
  buffer_append(& b, (void const   *)data, datalen);
#line 836
  if (datafellows & 16) {
#line 837
    tmp = buffer_ptr(& b);
#line 837
    p = (u_char *)tmp;
#line 838
    len = buffer_len(& b);
#line 839
    if ((unsigned int )session_id2___0 == (unsigned int )((void *)0)) {
#line 842
      fail ++;
    } else {
#line 839
      if (len < (u_int )session_id2_len___0) {
#line 842
        fail ++;
      } else {
#line 839
        tmp___0 = memcmp((void const   *)p, (void const   *)session_id2___0, (unsigned int )session_id2_len___0);
#line 839
        if (tmp___0 != 0) {
#line 842
          fail ++;
        }
      }
    }
#line 843
    buffer_consume(& b, (unsigned int )session_id2_len___0);
  } else {
#line 845
    tmp___1 = buffer_get_string(& b, & len);
#line 845
    p = (u_char *)tmp___1;
#line 846
    if ((unsigned int )session_id2___0 == (unsigned int )((void *)0)) {
#line 849
      fail ++;
    } else {
#line 846
      if (len != (u_int )session_id2_len___0) {
#line 849
        fail ++;
      } else {
#line 846
        tmp___2 = memcmp((void const   *)p, (void const   *)session_id2___0, (unsigned int )session_id2_len___0);
#line 846
        if (tmp___2 != 0) {
#line 849
          fail ++;
        }
      }
    }
#line 850
    xfree((void *)p);
  }
#line 852
  tmp___3 = buffer_get_char(& b);
#line 852
  if (tmp___3 != 50) {
#line 853
    fail ++;
  }
#line 854
  tmp___4 = buffer_get_string(& b, (u_int *)((void *)0));
#line 854
  p = (u_char *)tmp___4;
#line 855
  if (0) {
#line 855
    __s1_len = strlen((char const   *)authctxt->user);
#line 855
    __s2_len = strlen((char const   *)p);
#line 855
    if (! ((unsigned int )((void const   *)(authctxt->user + 1)) - (unsigned int )((void const   *)authctxt->user) == 1U)) {
      goto _L___0;
    } else {
#line 855
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 855
        if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
#line 855
          tmp___14 = 1;
        } else {
#line 855
          if (__s2_len >= 4U) {
#line 855
            tmp___14 = 1;
          } else {
#line 855
            tmp___14 = 0;
          }
        }
      } else {
#line 855
        tmp___14 = 0;
      }
    }
#line 855
    if (tmp___14) {
#line 855
      tmp___10 = __builtin_strcmp((char const   *)authctxt->user, (char const   *)p);
    } else {
#line 855
      tmp___13 = __builtin_strcmp((char const   *)authctxt->user, (char const   *)p);
#line 855
      tmp___10 = tmp___13;
    }
  } else {
#line 855
    tmp___13 = __builtin_strcmp((char const   *)authctxt->user, (char const   *)p);
#line 855
    tmp___10 = tmp___13;
  }
#line 855
  if (tmp___10 != 0) {
#line 856
    log("wrong user name passed to monitor: expected %s != %.100s", authctxt->user,
        p);
#line 858
    fail ++;
  }
#line 860
  xfree((void *)p);
#line 861
  while (1) {
#line 861
    tmp___15 = buffer_get_int(& b);
#line 861
    l = tmp___15;
#line 861
    buffer_consume(& b, l);
#line 861
    break;
  }
#line 862
  if (datafellows & 32) {
#line 863
    tmp___16 = buffer_get_char(& b);
#line 863
    if (! tmp___16) {
#line 864
      fail ++;
    }
  } else {
#line 866
    tmp___17 = buffer_get_string(& b, (u_int *)((void *)0));
#line 866
    p = (u_char *)tmp___17;
#line 867
    if (0) {
#line 867
      __s1_len___0 = strlen("publickey");
#line 867
      __s2_len___0 = strlen((char const   *)p);
#line 867
      if (! ((unsigned int )((void const   *)("publickey" + 1)) - (unsigned int )((void const   *)"publickey") == 1U)) {
        goto _L___2;
      } else {
#line 867
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 867
          if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
#line 867
            tmp___27 = 1;
          } else {
#line 867
            if (__s2_len___0 >= 4U) {
#line 867
              tmp___27 = 1;
            } else {
#line 867
              tmp___27 = 0;
            }
          }
        } else {
#line 867
          tmp___27 = 0;
        }
      }
#line 867
      if (tmp___27) {
#line 867
        tmp___23 = __builtin_strcmp("publickey", (char const   *)p);
      } else {
#line 867
        tmp___26 = __builtin_strcmp("publickey", (char const   *)p);
#line 867
        tmp___23 = tmp___26;
      }
    } else {
#line 867
      tmp___26 = __builtin_strcmp("publickey", (char const   *)p);
#line 867
      tmp___23 = tmp___26;
    }
#line 867
    if (tmp___23 != 0) {
#line 868
      fail ++;
    }
#line 869
    xfree((void *)p);
#line 870
    tmp___28 = buffer_get_char(& b);
#line 870
    if (! tmp___28) {
#line 871
      fail ++;
    }
#line 872
    while (1) {
#line 872
      tmp___29 = buffer_get_int(& b);
#line 872
      l___0 = tmp___29;
#line 872
      buffer_consume(& b, l___0);
#line 872
      break;
    }
  }
#line 874
  while (1) {
#line 874
    tmp___30 = buffer_get_int(& b);
#line 874
    l___1 = tmp___30;
#line 874
    buffer_consume(& b, l___1);
#line 874
    break;
  }
#line 875
  tmp___31 = buffer_len(& b);
#line 875
  if (tmp___31 != 0U) {
#line 876
    fail ++;
  }
#line 877
  buffer_free(& b);
#line 878
  return (fail == 0);
}
}
#line 881 "monitor.c"
static int monitor_valid_hostbasedblob(u_char *data , u_int datalen , u_char *cuser ,
                                       u_char *chost ) 
{ Buffer b ;
  u_char *p ;
  u_int len ;
  int fail ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  u_int l ;
  u_int tmp___13 ;
  void *tmp___14 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  u_int l___0 ;
  u_int tmp___25 ;
  u_int l___1 ;
  u_int tmp___26 ;
  void *tmp___27 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___33 ;
  int tmp___36 ;
  int tmp___37 ;
  void *tmp___38 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;
  u_int tmp___49 ;

  {
#line 888
  fail = 0;
#line 890
  buffer_init(& b);
#line 891
  buffer_append(& b, (void const   *)data, datalen);
#line 893
  tmp = buffer_get_string(& b, & len);
#line 893
  p = (u_char *)tmp;
#line 894
  if ((unsigned int )session_id2___0 == (unsigned int )((void *)0)) {
#line 897
    fail ++;
  } else {
#line 894
    if (len != (u_int )session_id2_len___0) {
#line 897
      fail ++;
    } else {
#line 894
      tmp___0 = memcmp((void const   *)p, (void const   *)session_id2___0, (unsigned int )session_id2_len___0);
#line 894
      if (tmp___0 != 0) {
#line 897
        fail ++;
      }
    }
  }
#line 898
  xfree((void *)p);
#line 900
  tmp___1 = buffer_get_char(& b);
#line 900
  if (tmp___1 != 50) {
#line 901
    fail ++;
  }
#line 902
  tmp___2 = buffer_get_string(& b, (u_int *)((void *)0));
#line 902
  p = (u_char *)tmp___2;
#line 903
  if (0) {
#line 903
    __s1_len = strlen((char const   *)authctxt->user);
#line 903
    __s2_len = strlen((char const   *)p);
#line 903
    if (! ((unsigned int )((void const   *)(authctxt->user + 1)) - (unsigned int )((void const   *)authctxt->user) == 1U)) {
      goto _L___0;
    } else {
#line 903
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 903
        if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
#line 903
          tmp___12 = 1;
        } else {
#line 903
          if (__s2_len >= 4U) {
#line 903
            tmp___12 = 1;
          } else {
#line 903
            tmp___12 = 0;
          }
        }
      } else {
#line 903
        tmp___12 = 0;
      }
    }
#line 903
    if (tmp___12) {
#line 903
      tmp___8 = __builtin_strcmp((char const   *)authctxt->user, (char const   *)p);
    } else {
#line 903
      tmp___11 = __builtin_strcmp((char const   *)authctxt->user, (char const   *)p);
#line 903
      tmp___8 = tmp___11;
    }
  } else {
#line 903
    tmp___11 = __builtin_strcmp((char const   *)authctxt->user, (char const   *)p);
#line 903
    tmp___8 = tmp___11;
  }
#line 903
  if (tmp___8 != 0) {
#line 904
    log("wrong user name passed to monitor: expected %s != %.100s", authctxt->user,
        p);
#line 906
    fail ++;
  }
#line 908
  xfree((void *)p);
#line 909
  while (1) {
#line 909
    tmp___13 = buffer_get_int(& b);
#line 909
    l = tmp___13;
#line 909
    buffer_consume(& b, l);
#line 909
    break;
  }
#line 910
  tmp___14 = buffer_get_string(& b, (u_int *)((void *)0));
#line 910
  p = (u_char *)tmp___14;
#line 911
  if (0) {
#line 911
    __s1_len___0 = strlen((char const   *)p);
#line 911
    __s2_len___0 = strlen("hostbased");
#line 911
    if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
      goto _L___2;
    } else {
#line 911
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 911
        if (! ((unsigned int )((void const   *)("hostbased" + 1)) - (unsigned int )((void const   *)"hostbased") == 1U)) {
#line 911
          tmp___24 = 1;
        } else {
#line 911
          if (__s2_len___0 >= 4U) {
#line 911
            tmp___24 = 1;
          } else {
#line 911
            tmp___24 = 0;
          }
        }
      } else {
#line 911
        tmp___24 = 0;
      }
    }
#line 911
    if (tmp___24) {
#line 911
      tmp___20 = __builtin_strcmp((char const   *)p, "hostbased");
    } else {
#line 911
      tmp___23 = __builtin_strcmp((char const   *)p, "hostbased");
#line 911
      tmp___20 = tmp___23;
    }
  } else {
#line 911
    tmp___23 = __builtin_strcmp((char const   *)p, "hostbased");
#line 911
    tmp___20 = tmp___23;
  }
#line 911
  if (tmp___20 != 0) {
#line 912
    fail ++;
  }
#line 913
  xfree((void *)p);
#line 914
  while (1) {
#line 914
    tmp___25 = buffer_get_int(& b);
#line 914
    l___0 = tmp___25;
#line 914
    buffer_consume(& b, l___0);
#line 914
    break;
  }
#line 915
  while (1) {
#line 915
    tmp___26 = buffer_get_int(& b);
#line 915
    l___1 = tmp___26;
#line 915
    buffer_consume(& b, l___1);
#line 915
    break;
  }
#line 918
  tmp___27 = buffer_get_string(& b, (u_int *)((void *)0));
#line 918
  p = (u_char *)tmp___27;
#line 919
  len = strlen((char const   *)p);
#line 919
  if (len > 0U) {
#line 919
    if ((int )*(p + (len - 1U)) == 46) {
#line 920
      *(p + (len - 1U)) = (unsigned char )'\000';
    }
  }
#line 921
  if (0) {
#line 921
    __s1_len___1 = strlen((char const   *)p);
#line 921
    __s2_len___1 = strlen((char const   *)chost);
#line 921
    if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
      goto _L___4;
    } else {
#line 921
      if (__s1_len___1 >= 4U) {
        _L___4: /* CIL Label */ 
#line 921
        if (! ((unsigned int )((void const   *)(chost + 1)) - (unsigned int )((void const   *)chost) == 1U)) {
#line 921
          tmp___37 = 1;
        } else {
#line 921
          if (__s2_len___1 >= 4U) {
#line 921
            tmp___37 = 1;
          } else {
#line 921
            tmp___37 = 0;
          }
        }
      } else {
#line 921
        tmp___37 = 0;
      }
    }
#line 921
    if (tmp___37) {
#line 921
      tmp___33 = __builtin_strcmp((char const   *)p, (char const   *)chost);
    } else {
#line 921
      tmp___36 = __builtin_strcmp((char const   *)p, (char const   *)chost);
#line 921
      tmp___33 = tmp___36;
    }
  } else {
#line 921
    tmp___36 = __builtin_strcmp((char const   *)p, (char const   *)chost);
#line 921
    tmp___33 = tmp___36;
  }
#line 921
  if (tmp___33 != 0) {
#line 922
    fail ++;
  }
#line 923
  xfree((void *)p);
#line 926
  tmp___38 = buffer_get_string(& b, (u_int *)((void *)0));
#line 926
  p = (u_char *)tmp___38;
#line 927
  if (0) {
#line 927
    __s1_len___2 = strlen((char const   *)p);
#line 927
    __s2_len___2 = strlen((char const   *)cuser);
#line 927
    if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
      goto _L___6;
    } else {
#line 927
      if (__s1_len___2 >= 4U) {
        _L___6: /* CIL Label */ 
#line 927
        if (! ((unsigned int )((void const   *)(cuser + 1)) - (unsigned int )((void const   *)cuser) == 1U)) {
#line 927
          tmp___48 = 1;
        } else {
#line 927
          if (__s2_len___2 >= 4U) {
#line 927
            tmp___48 = 1;
          } else {
#line 927
            tmp___48 = 0;
          }
        }
      } else {
#line 927
        tmp___48 = 0;
      }
    }
#line 927
    if (tmp___48) {
#line 927
      tmp___44 = __builtin_strcmp((char const   *)p, (char const   *)cuser);
    } else {
#line 927
      tmp___47 = __builtin_strcmp((char const   *)p, (char const   *)cuser);
#line 927
      tmp___44 = tmp___47;
    }
  } else {
#line 927
    tmp___47 = __builtin_strcmp((char const   *)p, (char const   *)cuser);
#line 927
    tmp___44 = tmp___47;
  }
#line 927
  if (tmp___44 != 0) {
#line 928
    fail ++;
  }
#line 929
  xfree((void *)p);
#line 931
  tmp___49 = buffer_len(& b);
#line 931
  if (tmp___49 != 0U) {
#line 932
    fail ++;
  }
#line 933
  buffer_free(& b);
#line 934
  return (fail == 0);
}
}
#line 937 "monitor.c"
int mm_answer_keyverify(int socket___0 , Buffer *m___0 ) 
{ Key *key ;
  u_char *signature ;
  u_char *data ;
  u_char *blob ;
  u_int signaturelen ;
  u_int datalen ;
  u_int bloblen ;
  int verified ;
  int valid_data ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;

  {
#line 943
  verified = 0;
#line 944
  valid_data = 0;
#line 946
  tmp = buffer_get_string(m___0, & bloblen);
#line 946
  blob = (u_char *)tmp;
#line 947
  tmp___0 = buffer_get_string(m___0, & signaturelen);
#line 947
  signature = (u_char *)tmp___0;
#line 948
  tmp___1 = buffer_get_string(m___0, & datalen);
#line 948
  data = (u_char *)tmp___1;
#line 950
  if ((unsigned int )hostbased_cuser == (unsigned int )((void *)0)) {
#line 952
    fatal("%s: bad key, not previously allowed", "mm_answer_keyverify");
  } else {
#line 950
    if ((unsigned int )hostbased_chost == (unsigned int )((void *)0)) {
#line 952
      fatal("%s: bad key, not previously allowed", "mm_answer_keyverify");
    } else {
#line 950
      tmp___2 = monitor_allowed_key(blob, bloblen);
#line 950
      if (! tmp___2) {
#line 952
        fatal("%s: bad key, not previously allowed", "mm_answer_keyverify");
      }
    }
  }
#line 954
  key = key_from_blob(blob, (int )bloblen);
#line 955
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 956
    fatal("%s: bad public key blob", "mm_answer_keyverify");
  }
#line 958
  switch (key_blobtype) {
  case 2: 
#line 960
  valid_data = monitor_valid_userblob(data, datalen);
#line 961
  break;
  case 1: 
#line 963
  valid_data = monitor_valid_hostbasedblob(data, datalen, hostbased_cuser, hostbased_chost);
#line 965
  break;
  default: 
#line 967
  valid_data = 0;
#line 968
  break;
  }
#line 970
  if (! valid_data) {
#line 971
    fatal("%s: bad signature data blob", "mm_answer_keyverify");
  }
#line 973
  verified = key_verify(key, signature, signaturelen, data, datalen);
#line 974
  if (verified) {
#line 974
    tmp___3 = "verified";
  } else {
#line 974
    tmp___3 = "unverified";
  }
#line 974
  debug3("%s: key %p signature %s", "mm_answer_keyverify", key, tmp___3);
#line 977
  key_free(key);
#line 978
  xfree((void *)blob);
#line 979
  xfree((void *)signature);
#line 980
  xfree((void *)data);
#line 982
  if (key_blobtype == 2) {
#line 982
    auth_method = (char *)"publickey";
  } else {
#line 982
    auth_method = (char *)"hostbased";
  }
#line 984
  monitor_reset_key_state();
#line 986
  buffer_clear(m___0);
#line 987
  buffer_put_int(m___0, (unsigned int )verified);
#line 988
  mm_request_send(socket___0, 23, m___0);
#line 990
  return (verified);
}
}
#line 993 "monitor.c"
static void mm_record_login(Session *s , struct passwd *pw ) 
{ socklen_t fromlen ;
  struct sockaddr_storage from ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;

  {
#line 1003
  memset((void *)(& from), 0, sizeof(from));
#line 1004
  tmp___3 = packet_connection_is_on_socket();
#line 1004
  if (tmp___3) {
#line 1005
    fromlen = sizeof(from);
#line 1006
    tmp___1 = packet_get_connection_in();
#line 1006
    tmp___2 = getpeername(tmp___1, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 1006
    if (tmp___2 < 0) {
#line 1008
      tmp = __errno_location();
#line 1008
      tmp___0 = strerror(*tmp);
#line 1008
      debug("getpeername: %.100s", tmp___0);
#line 1009
      fatal_cleanup();
    }
  }
#line 1013
  tmp___4 = get_remote_name_or_ip(utmp_len, options.verify_reverse_mapping);
#line 1013
  record_login(s->pid, (char const   *)(s->tty), (char const   *)pw->pw_name, pw->pw_uid,
               tmp___4, (struct sockaddr *)(& from));
#line 1016
  return;
}
}
#line 1018 "monitor.c"
static void mm_session_close(Session *s ) 
{ 

  {
#line 1021
  debug3("%s: session %d pid %d", "mm_session_close", s->self, s->pid);
#line 1022
  if (s->ttyfd != -1) {
#line 1023
    debug3("%s: tty %s ptyfd %d", "mm_session_close", s->tty, s->ptyfd);
#line 1024
    fatal_remove_cleanup(& session_pty_cleanup2, (void *)s);
#line 1025
    session_pty_cleanup2((void *)s);
  }
#line 1027
  s->used = 0;
#line 1028
  return;
}
}
#line 1030 "monitor.c"
int mm_answer_pty(int socket___0 , Buffer *m___0 ) 
{ Session *s ;
  int res ;
  int fd0 ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 1037
  debug3("%s entering", "mm_answer_pty");
#line 1039
  buffer_clear(m___0);
#line 1040
  s = session_new();
#line 1041
  if ((unsigned int )s == (unsigned int )((void *)0)) {
    goto error;
  }
#line 1043
  s->authctxt = authctxt;
#line 1044
  s->pw = authctxt->pw;
#line 1045
  s->pid = pmonitor->m_pid;
#line 1046
  res = pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, (int )sizeof(s->tty));
#line 1047
  if (res == 0) {
    goto error;
  }
#line 1049
  fatal_add_cleanup(& session_pty_cleanup2, (void *)s);
#line 1050
  pty_setowner(authctxt->pw, (char const   *)(s->tty));
#line 1052
  buffer_put_int(m___0, 1U);
#line 1053
  buffer_put_cstring(m___0, (char const   *)(s->tty));
#line 1054
  mm_request_send(socket___0, 26, m___0);
#line 1056
  mm_send_fd(socket___0, s->ptyfd);
#line 1057
  mm_send_fd(socket___0, s->ttyfd);
#line 1060
  tmp = dup2(s->ttyfd, 0);
#line 1060
  if (tmp == -1) {
#line 1061
    fatal("%s: dup2", "mm_answer_pty");
  }
#line 1063
  mm_record_login(s, authctxt->pw);
#line 1066
  close(0);
#line 1069
  fd0 = open("/dev/null", 0);
#line 1069
  if (fd0 < 0) {
#line 1070
    tmp___0 = __errno_location();
#line 1070
    tmp___1 = strerror(*tmp___0);
#line 1070
    fatal("%s: open(/dev/null): %s", "mm_answer_pty", tmp___1);
  }
#line 1071
  if (fd0 != 0) {
#line 1072
    error("%s: fd0 %d != 0", "mm_answer_pty", fd0);
  }
#line 1075
  close(s->ttyfd);
#line 1076
  s->ttyfd = s->ptyfd;
#line 1078
  s->ptymaster = s->ptyfd;
#line 1080
  debug3("%s: tty %s ptyfd %d", "mm_answer_pty", s->tty, s->ttyfd);
#line 1082
  return (0);
  error: 
#line 1085
  if ((unsigned int )s != (unsigned int )((void *)0)) {
#line 1086
    mm_session_close(s);
  }
#line 1087
  buffer_put_int(m___0, 0U);
#line 1088
  mm_request_send(socket___0, 26, m___0);
#line 1089
  return (0);
}
}
#line 1092 "monitor.c"
int mm_answer_pty_cleanup(int socket___0 , Buffer *m___0 ) 
{ Session *s ;
  char *tty ;
  void *tmp ;

  {
#line 1098
  debug3("%s entering", "mm_answer_pty_cleanup");
#line 1100
  tmp = buffer_get_string(m___0, (u_int *)((void *)0));
#line 1100
  tty = (char *)tmp;
#line 1101
  s = session_by_tty(tty);
#line 1101
  if ((unsigned int )s != (unsigned int )((void *)0)) {
#line 1102
    mm_session_close(s);
  }
#line 1103
  buffer_clear(m___0);
#line 1104
  xfree((void *)tty);
#line 1105
  return (0);
}
}
#line 1108 "monitor.c"
int mm_answer_sesskey(int socket___0 , Buffer *m___0 ) 
{ BIGNUM *p ;
  int rsafail ;

  {
#line 1115
  monitor_permit(mon_dispatch, 28, 1);
#line 1117
  p = BN_new();
#line 1117
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 1118
    fatal("%s: BN_new", "mm_answer_sesskey");
  }
#line 1120
  buffer_get_bignum2(m___0, p);
#line 1122
  rsafail = ssh1_session_key(p);
#line 1124
  buffer_clear(m___0);
#line 1125
  buffer_put_int(m___0, (unsigned int )rsafail);
#line 1126
  buffer_put_bignum2(m___0, p);
#line 1128
  BN_clear_free(p);
#line 1130
  mm_request_send(socket___0, 29, m___0);
#line 1133
  monitor_permit(mon_dispatch, 30, 1);
#line 1135
  return (0);
}
}
#line 1138 "monitor.c"
int mm_answer_sessid(int socket___0 , Buffer *m___0 ) 
{ int i ;
  u_int tmp ;
  int tmp___0 ;

  {
#line 1143
  debug3("%s entering", "mm_answer_sessid");
#line 1145
  tmp = buffer_len(m___0);
#line 1145
  if (tmp != 16U) {
#line 1146
    fatal("%s: bad ssh1 session id", "mm_answer_sessid");
  }
#line 1147
  i = 0;
#line 1147
  while (i < 16) {
#line 1148
    tmp___0 = buffer_get_char(m___0);
#line 1148
    session_id[i] = (unsigned char )tmp___0;
#line 1147
    i ++;
  }
#line 1151
  monitor_permit(mon_dispatch, 6, 1);
#line 1153
  return (0);
}
}
#line 1156 "monitor.c"
int mm_answer_rsa_keyallowed(int socket___0 , Buffer *m___0 ) 
{ BIGNUM *client_n ;
  Key *key ;
  u_char *blob ;
  u_int blen ;
  int allowed ;
  int tmp ;

  {
#line 1160
  key = (Key *)((void *)0);
#line 1161
  blob = (u_char *)((void *)0);
#line 1162
  blen = (u_int )0;
#line 1163
  allowed = 0;
#line 1165
  debug3("%s entering", "mm_answer_rsa_keyallowed");
#line 1167
  if (options.rsa_authentication) {
#line 1167
    if (authctxt->valid) {
#line 1168
      client_n = BN_new();
#line 1168
      if ((unsigned int )client_n == (unsigned int )((void *)0)) {
#line 1169
        fatal("%s: BN_new", "mm_answer_rsa_keyallowed");
      }
#line 1170
      buffer_get_bignum2(m___0, client_n);
#line 1171
      allowed = auth_rsa_key_allowed(authctxt->pw, client_n, & key);
#line 1172
      BN_clear_free(client_n);
    }
  }
#line 1174
  buffer_clear(m___0);
#line 1175
  buffer_put_int(m___0, (unsigned int )allowed);
#line 1178
  monitor_reset_key_state();
#line 1180
  if (allowed) {
#line 1180
    if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 1181
      key->type = 1;
#line 1182
      tmp = key_to_blob(key, & blob, & blen);
#line 1182
      if (tmp == 0) {
#line 1183
        fatal("%s: key_to_blob failed", "mm_answer_rsa_keyallowed");
      }
#line 1184
      buffer_put_string(m___0, (void const   *)blob, blen);
#line 1187
      key_blob = blob;
#line 1188
      key_bloblen = blen;
#line 1189
      key_blobtype = 4;
#line 1190
      key_free(key);
    }
  }
#line 1193
  mm_append_debug(m___0);
#line 1195
  mm_request_send(socket___0, 32, m___0);
#line 1197
  monitor_permit(mon_dispatch, 33, allowed);
#line 1198
  monitor_permit(mon_dispatch, 35, 0);
#line 1199
  return (0);
}
}
#line 1202 "monitor.c"
int mm_answer_rsa_challenge(int socket___0 , Buffer *m___0 ) 
{ Key *key ;
  u_char *blob ;
  u_int blen ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1205
  key = (Key *)((void *)0);
#line 1209
  debug3("%s entering", "mm_answer_rsa_challenge");
#line 1211
  if (! authctxt->valid) {
#line 1212
    fatal("%s: authctxt not valid", "mm_answer_rsa_challenge");
  }
#line 1213
  tmp = buffer_get_string(m___0, & blen);
#line 1213
  blob = (u_char *)tmp;
#line 1214
  tmp___0 = monitor_allowed_key(blob, blen);
#line 1214
  if (! tmp___0) {
#line 1215
    fatal("%s: bad key, not previously allowed", "mm_answer_rsa_challenge");
  }
#line 1216
  if (key_blobtype != 4) {
#line 1216
    if (key_blobtype != 3) {
#line 1217
      fatal("%s: key type mismatch", "mm_answer_rsa_challenge");
    }
  }
#line 1218
  key = key_from_blob(blob, (int )blen);
#line 1218
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 1219
    fatal("%s: received bad key", "mm_answer_rsa_challenge");
  }
#line 1221
  if (ssh1_challenge) {
#line 1222
    BN_clear_free(ssh1_challenge);
  }
#line 1223
  ssh1_challenge = auth_rsa_generate_challenge(key);
#line 1225
  buffer_clear(m___0);
#line 1226
  buffer_put_bignum2(m___0, ssh1_challenge);
#line 1228
  debug3("%s sending reply", "mm_answer_rsa_challenge");
#line 1229
  mm_request_send(socket___0, 34, m___0);
#line 1231
  monitor_permit(mon_dispatch, 35, 1);
#line 1232
  return (0);
}
}
#line 1235 "monitor.c"
int mm_answer_rsa_response(int socket___0 , Buffer *m___0 ) 
{ Key *key ;
  u_char *blob ;
  u_char *response ;
  u_int blen ;
  u_int len ;
  int success ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 1238
  key = (Key *)((void *)0);
#line 1243
  debug3("%s entering", "mm_answer_rsa_response");
#line 1245
  if (! authctxt->valid) {
#line 1246
    fatal("%s: authctxt not valid", "mm_answer_rsa_response");
  }
#line 1247
  if ((unsigned int )ssh1_challenge == (unsigned int )((void *)0)) {
#line 1248
    fatal("%s: no ssh1_challenge", "mm_answer_rsa_response");
  }
#line 1250
  tmp = buffer_get_string(m___0, & blen);
#line 1250
  blob = (u_char *)tmp;
#line 1251
  tmp___0 = monitor_allowed_key(blob, blen);
#line 1251
  if (! tmp___0) {
#line 1252
    fatal("%s: bad key, not previously allowed", "mm_answer_rsa_response");
  }
#line 1253
  if (key_blobtype != 4) {
#line 1253
    if (key_blobtype != 3) {
#line 1254
      fatal("%s: key type mismatch: %d", "mm_answer_rsa_response", key_blobtype);
    }
  }
#line 1255
  key = key_from_blob(blob, (int )blen);
#line 1255
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 1256
    fatal("%s: received bad key", "mm_answer_rsa_response");
  }
#line 1257
  tmp___1 = buffer_get_string(m___0, & len);
#line 1257
  response = (u_char *)tmp___1;
#line 1258
  if (len != 16U) {
#line 1259
    fatal("%s: received bad response to challenge", "mm_answer_rsa_response");
  }
#line 1260
  success = auth_rsa_verify_response(key, ssh1_challenge, response);
#line 1262
  key_free(key);
#line 1263
  xfree((void *)response);
#line 1265
  if (key_blobtype == 4) {
#line 1265
    auth_method = (char *)"rsa";
  } else {
#line 1265
    auth_method = (char *)"rhosts-rsa";
  }
#line 1268
  BN_clear_free(ssh1_challenge);
#line 1269
  ssh1_challenge = (BIGNUM *)((void *)0);
#line 1270
  monitor_reset_key_state();
#line 1272
  buffer_clear(m___0);
#line 1273
  buffer_put_int(m___0, (unsigned int )success);
#line 1274
  mm_request_send(socket___0, 36, m___0);
#line 1276
  return (success);
}
}
#line 1279 "monitor.c"
int mm_answer_term(int socket___0 , Buffer *req ) 
{ int res ;
  int status ;
  int *tmp ;
  __pid_t tmp___0 ;
  union __anonunion_76___0 __constr_expr_2 ;
  union __anonunion_77___0 __constr_expr_3 ;

  {
#line 1285
  debug3("%s: tearing down sessions", "mm_answer_term");
#line 1288
  session_destroy_all(& mm_session_close);
#line 1290
  while (1) {
#line 1290
    tmp___0 = waitpid(pmonitor->m_pid, & status, 0);
#line 1290
    if (! (tmp___0 == -1)) {
#line 1290
      break;
    }
#line 1291
    tmp = __errno_location();
#line 1291
    if (*tmp != 4) {
#line 1292
      exit(1);
    }
  }
#line 1294
  __constr_expr_3.__in = status;
#line 1294
  if ((__constr_expr_3.__i & 127) == 0) {
#line 1294
    __constr_expr_2.__in = status;
#line 1294
    res = (__constr_expr_2.__i & 65280) >> 8;
  } else {
#line 1294
    res = 1;
  }
#line 1297
  exit(res);
}
}
#line 1300 "monitor.c"
void monitor_apply_keystate(struct monitor *pmonitor___0 ) 
{ 

  {
#line 1303
  if (compat20) {
#line 1304
    set_newkeys(0);
#line 1305
    set_newkeys(1);
  } else {
#line 1307
    packet_set_protocol_flags((unsigned int )child_state.ssh1protoflags);
#line 1308
    packet_set_encryption_key((u_char const   *)child_state.ssh1key, child_state.ssh1keylen,
                              child_state.ssh1cipher);
#line 1310
    xfree((void *)child_state.ssh1key);
  }
#line 1314
  packet_set_keycontext(1, child_state.keyout);
#line 1315
  xfree((void *)child_state.keyout);
#line 1316
  packet_set_keycontext(0, child_state.keyin);
#line 1317
  xfree((void *)child_state.keyin);
#line 1319
  if (! compat20) {
#line 1320
    packet_set_iv(1, child_state.ivout);
#line 1321
    xfree((void *)child_state.ivout);
#line 1322
    packet_set_iv(0, child_state.ivin);
#line 1323
    xfree((void *)child_state.ivin);
  }
#line 1326
  memcpy((void * __restrict  )(& incoming_stream), (void const   * __restrict  )(& child_state.incoming),
         sizeof(incoming_stream));
#line 1328
  memcpy((void * __restrict  )(& outgoing_stream), (void const   * __restrict  )(& child_state.outgoing),
         sizeof(outgoing_stream));
#line 1332
  if (options.compression) {
#line 1333
    mm_init_compression(pmonitor___0->m_zlib);
  }
#line 1337
  buffer_clear(& input);
#line 1338
  buffer_append(& input, (void const   *)child_state.input, child_state.ilen);
#line 1339
  memset((void *)child_state.input, 0, child_state.ilen);
#line 1340
  xfree((void *)child_state.input);
#line 1342
  buffer_clear(& output);
#line 1343
  buffer_append(& output, (void const   *)child_state.output, child_state.olen);
#line 1344
  memset((void *)child_state.output, 0, child_state.olen);
#line 1345
  xfree((void *)child_state.output);
#line 1346
  return;
}
}
#line 1348 "monitor.c"
static Kex *mm_get_kex(Buffer *m___0 ) 
{ Kex *kex ;
  void *blob ;
  u_int bloblen ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
#line 1355
  tmp = xmalloc(sizeof(*kex));
#line 1355
  kex = (Kex *)tmp;
#line 1356
  memset((void *)kex, 0, sizeof(*kex));
#line 1357
  tmp___0 = buffer_get_string(m___0, (u_int *)(& kex->session_id_len));
#line 1357
  kex->session_id = (u_char *)tmp___0;
#line 1358
  if ((unsigned int )session_id2___0 == (unsigned int )((void *)0)) {
#line 1361
    fatal("mm_get_get: internal error: bad session id");
  } else {
#line 1358
    if (kex->session_id_len != session_id2_len___0) {
#line 1361
      fatal("mm_get_get: internal error: bad session id");
    } else {
#line 1358
      tmp___1 = memcmp((void const   *)kex->session_id, (void const   *)session_id2___0,
                       (unsigned int )session_id2_len___0);
#line 1358
      if (tmp___1 != 0) {
#line 1361
        fatal("mm_get_get: internal error: bad session id");
      }
    }
  }
#line 1362
  tmp___2 = buffer_get_int(m___0);
#line 1362
  kex->we_need = (int )tmp___2;
#line 1363
  kex->server = 1;
#line 1364
  tmp___3 = buffer_get_int(m___0);
#line 1364
  kex->hostkey_type = (int )tmp___3;
#line 1365
  tmp___4 = buffer_get_int(m___0);
#line 1365
  kex->kex_type = (int )tmp___4;
#line 1366
  blob = buffer_get_string(m___0, & bloblen);
#line 1367
  buffer_init(& kex->my);
#line 1368
  buffer_append(& kex->my, (void const   *)blob, bloblen);
#line 1369
  xfree(blob);
#line 1370
  blob = buffer_get_string(m___0, & bloblen);
#line 1371
  buffer_init(& kex->peer);
#line 1372
  buffer_append(& kex->peer, (void const   *)blob, bloblen);
#line 1373
  xfree(blob);
#line 1374
  kex->done = 1;
#line 1375
  tmp___5 = buffer_get_int(m___0);
#line 1375
  kex->flags = (int )tmp___5;
#line 1376
  tmp___6 = buffer_get_string(m___0, (u_int *)((void *)0));
#line 1376
  kex->client_version_string = (char *)tmp___6;
#line 1377
  tmp___7 = buffer_get_string(m___0, (u_int *)((void *)0));
#line 1377
  kex->server_version_string = (char *)tmp___7;
#line 1378
  kex->load_host_key = & get_hostkey_by_type;
#line 1379
  kex->host_key_index = & get_hostkey_index;
#line 1381
  return (kex);
}
}
#line 1386 "monitor.c"
void mm_get_keystate(struct monitor *pmonitor___0 ) 
{ Buffer m___0 ;
  u_char *blob ;
  u_char *p ;
  u_int bloblen ;
  u_int plen ;
  u_int tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  u_int tmp___6 ;
  u_int tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;

  {
#line 1393
  debug3("%s: Waiting for new keys", "mm_get_keystate");
#line 1395
  buffer_init(& m___0);
#line 1396
  mm_request_receive_expect(pmonitor___0->m_sendfd, 24, & m___0);
#line 1397
  if (! compat20) {
#line 1398
    tmp = buffer_get_int(& m___0);
#line 1398
    child_state.ssh1protoflags = (int )tmp;
#line 1399
    tmp___0 = buffer_get_int(& m___0);
#line 1399
    child_state.ssh1cipher = (int )tmp___0;
#line 1400
    tmp___1 = buffer_get_string(& m___0, & child_state.ssh1keylen);
#line 1400
    child_state.ssh1key = (u_char *)tmp___1;
#line 1402
    tmp___2 = buffer_get_string(& m___0, & child_state.ivoutlen);
#line 1402
    child_state.ivout = (u_char *)tmp___2;
#line 1404
    tmp___3 = buffer_get_string(& m___0, & child_state.ivinlen);
#line 1404
    child_state.ivin = (u_char *)tmp___3;
    goto skip;
  } else {
#line 1408
    *(pmonitor___0->m_pkex) = mm_get_kex(& m___0);
  }
#line 1411
  tmp___4 = buffer_get_string(& m___0, & bloblen);
#line 1411
  blob = (u_char *)tmp___4;
#line 1412
  current_keys[1] = mm_newkeys_from_blob(blob, (int )bloblen);
#line 1413
  xfree((void *)blob);
#line 1415
  debug3("%s: Waiting for second key", "mm_get_keystate");
#line 1416
  tmp___5 = buffer_get_string(& m___0, & bloblen);
#line 1416
  blob = (u_char *)tmp___5;
#line 1417
  current_keys[0] = mm_newkeys_from_blob(blob, (int )bloblen);
#line 1418
  xfree((void *)blob);
#line 1421
  tmp___6 = buffer_get_int(& m___0);
#line 1421
  packet_set_seqnr(1, tmp___6);
#line 1422
  tmp___7 = buffer_get_int(& m___0);
#line 1422
  packet_set_seqnr(0, tmp___7);
  skip: 
#line 1426
  tmp___8 = buffer_get_string(& m___0, & child_state.keyoutlen);
#line 1426
  child_state.keyout = (u_char *)tmp___8;
#line 1427
  tmp___9 = buffer_get_string(& m___0, & child_state.keyinlen);
#line 1427
  child_state.keyin = (u_char *)tmp___9;
#line 1429
  debug3("%s: Getting compression state", "mm_get_keystate");
#line 1431
  tmp___10 = buffer_get_string(& m___0, & plen);
#line 1431
  p = (u_char *)tmp___10;
#line 1432
  if (plen != sizeof(child_state.outgoing)) {
#line 1433
    fatal("%s: bad request size", "mm_get_keystate");
  }
#line 1434
  memcpy((void * __restrict  )(& child_state.outgoing), (void const   * __restrict  )p,
         sizeof(child_state.outgoing));
#line 1435
  xfree((void *)p);
#line 1437
  tmp___11 = buffer_get_string(& m___0, & plen);
#line 1437
  p = (u_char *)tmp___11;
#line 1438
  if (plen != sizeof(child_state.incoming)) {
#line 1439
    fatal("%s: bad request size", "mm_get_keystate");
  }
#line 1440
  memcpy((void * __restrict  )(& child_state.incoming), (void const   * __restrict  )p,
         sizeof(child_state.incoming));
#line 1441
  xfree((void *)p);
#line 1444
  debug3("%s: Getting Network I/O buffers", "mm_get_keystate");
#line 1445
  tmp___12 = buffer_get_string(& m___0, & child_state.ilen);
#line 1445
  child_state.input = (u_char *)tmp___12;
#line 1446
  tmp___13 = buffer_get_string(& m___0, & child_state.olen);
#line 1446
  child_state.output = (u_char *)tmp___13;
#line 1448
  buffer_free(& m___0);
#line 1449
  return;
}
}
#line 1453 "monitor.c"
void *mm_zalloc(struct mm_master *mm , u_int ncount , u_int size ) 
{ int len ;
  void *address ;

  {
#line 1456
  len = (int )(size * ncount);
#line 1459
  if (len <= 0) {
#line 1460
    fatal("%s: mm_zalloc(%u, %u)", "mm_zalloc", ncount, size);
  }
#line 1462
  address = mm_malloc(mm, (unsigned int )len);
#line 1464
  return (address);
}
}
#line 1467 "monitor.c"
void mm_zfree(struct mm_master *mm , void *address ) 
{ 

  {
#line 1470
  mm_free(mm, address);
#line 1471
  return;
}
}
#line 1473 "monitor.c"
void mm_init_compression(struct mm_master *mm ) 
{ 

  {
#line 1476
  outgoing_stream.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))(& mm_zalloc);
#line 1477
  outgoing_stream.zfree = (void (*)(voidpf opaque , voidpf address ))(& mm_zfree);
#line 1478
  outgoing_stream.opaque = (void *)mm;
#line 1480
  incoming_stream.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))(& mm_zalloc);
#line 1481
  incoming_stream.zfree = (void (*)(voidpf opaque , voidpf address ))(& mm_zfree);
#line 1482
  incoming_stream.opaque = (void *)mm;
#line 1483
  return;
}
}
#line 1492 "monitor.c"
static void monitor_socketpair(int *pair ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1496
  tmp = socketpair(1, 1, 0, (int *)pair);
#line 1496
  if (tmp == -1) {
#line 1497
    fatal("%s: socketpair", "monitor_socketpair");
  }
#line 1502
  while (1) {
#line 1502
    tmp___0 = fcntl(*(pair + 0), 2, 1);
#line 1502
    if (tmp___0 == -1) {
#line 1502
      fatal("fcntl(%d, F_SETFD)", *(pair + 0));
    }
#line 1502
    break;
  }
#line 1503
  while (1) {
#line 1503
    tmp___1 = fcntl(*(pair + 1), 2, 1);
#line 1503
    if (tmp___1 == -1) {
#line 1503
      fatal("fcntl(%d, F_SETFD)", *(pair + 1));
    }
#line 1503
    break;
  }
#line 1504
  return;
}
}
#line 1508 "monitor.c"
struct monitor *monitor_init(void) 
{ struct monitor *mon ;
  int pair[2] ;
  void *tmp ;

  {
#line 1514
  tmp = xmalloc(sizeof(*mon));
#line 1514
  mon = (struct monitor *)tmp;
#line 1516
  monitor_socketpair(pair);
#line 1518
  mon->m_recvfd = pair[0];
#line 1519
  mon->m_sendfd = pair[1];
#line 1522
  if (options.compression) {
#line 1523
    mon->m_zback = mm_create((struct mm_master *)((void *)0), 65536U);
#line 1524
    mon->m_zlib = mm_create(mon->m_zback, 1310720U);
#line 1527
    mm_init_compression(mon->m_zlib);
  }
#line 1530
  return (mon);
}
}
#line 1533 "monitor.c"
void monitor_reinit(struct monitor *mon ) 
{ int pair[2] ;

  {
#line 1538
  monitor_socketpair(pair);
#line 1540
  mon->m_recvfd = pair[0];
#line 1541
  mon->m_sendfd = pair[1];
#line 1542
  return;
}
}
