/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

#line 214 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stddef.h"
typedef unsigned int size_t;
#line 183 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 195 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 36 "/usr/include/bits/socket.h"
typedef __socklen_t socklen_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 145 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 107 "/usr/include/openssl/ossl_typ.h"
struct bignum_st;
#line 107 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_st BIGNUM;
#line 108
struct bignum_ctx;
#line 108 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_ctx BN_CTX;
#line 109
struct bn_blinding_st;
#line 109 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_blinding_st BN_BLINDING;
#line 110
struct bn_mont_ctx_st;
#line 110 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_mont_ctx_st BN_MONT_CTX;
#line 112
struct bn_gencb_st;
#line 112 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_gencb_st BN_GENCB;
#line 125
struct dsa_st;
#line 125 "/usr/include/openssl/ossl_typ.h"
typedef struct dsa_st DSA;
#line 126
struct dsa_method;
#line 126 "/usr/include/openssl/ossl_typ.h"
typedef struct dsa_method DSA_METHOD;
#line 128
struct rsa_st;
#line 128 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_st RSA;
#line 129
struct rsa_meth_st;
#line 129 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_meth_st RSA_METHOD;
#line 154
struct engine_st;
#line 154 "/usr/include/openssl/ossl_typ.h"
typedef struct engine_st ENGINE;
#line 165
struct crypto_ex_data_st;
#line 165 "/usr/include/openssl/ossl_typ.h"
typedef struct crypto_ex_data_st CRYPTO_EX_DATA;
#line 285 "/usr/include/openssl/bn.h"
struct bignum_st {
   unsigned long *d ;
   int top ;
   int dmax ;
   int neg ;
   int flags ;
};
#line 296 "/usr/include/openssl/bn.h"
struct bn_mont_ctx_st {
   int ri ;
   BIGNUM RR ;
   BIGNUM N ;
   BIGNUM Ni ;
   unsigned long n0 ;
   int flags ;
};
#line 320 "/usr/include/openssl/bn.h"
union __anonunion_cb_62 {
   void (*cb_1)(int  , int  , void * ) ;
   int (*cb_2)(int  , int  , BN_GENCB * ) ;
};
#line 320 "/usr/include/openssl/bn.h"
struct bn_gencb_st {
   unsigned int ver ;
   void *arg ;
   union __anonunion_cb_62 cb ;
};
#line 66 "/usr/include/openssl/stack.h"
struct stack_st {
   int num ;
   char **data ;
   int sorted ;
   int num_alloc ;
   int (*comp)(char const   * const  * , char const   * const  * ) ;
};
#line 66 "/usr/include/openssl/stack.h"
typedef struct stack_st STACK;
#line 283 "/usr/include/openssl/crypto.h"
struct crypto_ex_data_st {
   STACK *sk ;
   int dummy ;
};
#line 85 "/usr/include/openssl/rsa.h"
struct rsa_meth_st {
   char const   *name ;
   int (*rsa_pub_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_pub_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_priv_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_priv_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_mod_exp)(BIGNUM *r0 , BIGNUM const   *I , RSA *rsa , BN_CTX *ctx ) ;
   int (*bn_mod_exp)(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(RSA *rsa ) ;
   int (*finish)(RSA *rsa ) ;
   int flags ;
   char *app_data ;
   int (*rsa_sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
                   unsigned int *siglen , RSA const   *rsa ) ;
   int (*rsa_verify)(int dtype , unsigned char const   *m , unsigned int m_length ,
                     unsigned char *sigbuf , unsigned int siglen , RSA const   *rsa ) ;
   int (*rsa_keygen)(RSA *rsa , int bits , BIGNUM *e , BN_GENCB *cb ) ;
};
#line 128 "/usr/include/openssl/rsa.h"
struct rsa_st {
   int pad ;
   long version ;
   RSA_METHOD const   *meth ;
   ENGINE *engine ;
   BIGNUM *n ;
   BIGNUM *e ;
   BIGNUM *d ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *dmp1 ;
   BIGNUM *dmq1 ;
   BIGNUM *iqmp ;
   CRYPTO_EX_DATA ex_data ;
   int references ;
   int flags ;
   BN_MONT_CTX *_method_mod_n ;
   BN_MONT_CTX *_method_mod_p ;
   BN_MONT_CTX *_method_mod_q ;
   char *bignum_data ;
   BN_BLINDING *blinding ;
   BN_BLINDING *mt_blinding ;
};
#line 21 "buffer.h"
struct __anonstruct_Buffer_74 {
   char *buf ;
   unsigned int alloc ;
   unsigned int offset ;
   unsigned int end ;
};
#line 21 "buffer.h"
typedef struct __anonstruct_Buffer_74 Buffer;
#line 106 "/usr/include/openssl/dsa.h"
struct DSA_SIG_st {
   BIGNUM *r ;
   BIGNUM *s ;
};
#line 106 "/usr/include/openssl/dsa.h"
typedef struct DSA_SIG_st DSA_SIG;
#line 112 "/usr/include/openssl/dsa.h"
struct dsa_method {
   char const   *name ;
   DSA_SIG *(*dsa_do_sign)(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
   int (*dsa_sign_setup)(DSA *dsa , BN_CTX *ctx_in , BIGNUM **kinvp , BIGNUM **rp ) ;
   int (*dsa_do_verify)(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                        DSA *dsa ) ;
   int (*dsa_mod_exp)(DSA *dsa , BIGNUM *rr , BIGNUM *a1 , BIGNUM *p1 , BIGNUM *a2 ,
                      BIGNUM *p2 , BIGNUM *m , BN_CTX *ctx , BN_MONT_CTX *in_mont ) ;
   int (*bn_mod_exp)(DSA *dsa , BIGNUM *r , BIGNUM *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DSA *dsa ) ;
   int (*finish)(DSA *dsa ) ;
   int flags ;
   char *app_data ;
   int (*dsa_paramgen)(DSA *dsa , int bits , unsigned char *seed , int seed_len ,
                       int *counter_ret , unsigned long *h_ret , BN_GENCB *cb ) ;
   int (*dsa_keygen)(DSA *dsa ) ;
};
#line 139 "/usr/include/openssl/dsa.h"
struct dsa_st {
   int pad ;
   long version ;
   int write_params ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *g ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   BIGNUM *kinv ;
   BIGNUM *r ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DSA_METHOD const   *meth ;
   ENGINE *engine ;
};
#line 4 "key.h"
struct Key;
#line 4 "key.h"
typedef struct Key Key;
#line 10 "key.h"
struct Key {
   int type ;
   RSA *rsa ;
   DSA *dsa ;
};
#line 42 "authfd.h"
struct __anonstruct_AuthenticationConnection_76 {
   int fd ;
   Buffer identities ;
   int howmany ;
};
#line 42 "authfd.h"
typedef struct __anonstruct_AuthenticationConnection_76 AuthenticationConnection;
#line 59 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 60 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 137 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 143 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 144 "/usr/include/bits/types.h"
typedef long __off_t;
#line 145 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 152 "/usr/include/bits/types.h"
typedef long __time_t;
#line 167 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 172 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 88 "/usr/include/sys/types.h"
typedef __off_t off_t;
#line 203 "/usr/include/sys/types.h"
typedef unsigned int u_int32_t;
#line 121 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 177 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 183 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 268 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/openssl/ossl_typ.h"
struct asn1_string_st;
#line 79 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_INTEGER;
#line 80 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_ENUMERATED;
#line 81 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_BIT_STRING;
#line 82 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_OCTET_STRING;
#line 83 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_PRINTABLESTRING;
#line 84 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_T61STRING;
#line 85 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_IA5STRING;
#line 86 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_GENERALSTRING;
#line 87 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UNIVERSALSTRING;
#line 88 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_BMPSTRING;
#line 89 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UTCTIME;
#line 91 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_GENERALIZEDTIME;
#line 92 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_VISIBLESTRING;
#line 93 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UTF8STRING;
#line 94 "/usr/include/openssl/ossl_typ.h"
typedef int ASN1_BOOLEAN;
#line 116
struct evp_cipher_st;
#line 116 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_cipher_st EVP_CIPHER;
#line 117
struct evp_cipher_ctx_st;
#line 117 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_cipher_ctx_st EVP_CIPHER_CTX;
#line 281 "/usr/include/openssl/crypto.h"
struct bio_st;
#line 256 "/usr/include/openssl/bio.h"
typedef struct bio_st BIO;
#line 258 "/usr/include/openssl/bio.h"
typedef void bio_info_cb(struct bio_st * , int  , char const   * , int  , long  ,
                         long  );
#line 261 "/usr/include/openssl/bio.h"
struct bio_method_st {
   int type ;
   char const   *name ;
   int (*bwrite)(BIO * , char const   * , int  ) ;
   int (*bread)(BIO * , char * , int  ) ;
   int (*bputs)(BIO * , char const   * ) ;
   int (*bgets)(BIO * , char * , int  ) ;
   long (*ctrl)(BIO * , int  , long  , void * ) ;
   int (*create)(BIO * ) ;
   int (*destroy)(BIO * ) ;
   long (*callback_ctrl)(BIO * , int  , bio_info_cb * ) ;
};
#line 261 "/usr/include/openssl/bio.h"
typedef struct bio_method_st BIO_METHOD;
#line 290 "/usr/include/openssl/bio.h"
struct bio_st {
   BIO_METHOD *method ;
   long (*callback)(struct bio_st * , int  , char const   * , int  , long  , long  ) ;
   char *cb_arg ;
   int init ;
   int shutdown ;
   int flags ;
   int retry_reason ;
   int num ;
   void *ptr ;
   struct bio_st *next_bio ;
   struct bio_st *prev_bio ;
   int references ;
   unsigned long num_read ;
   unsigned long num_write ;
   CRYPTO_EX_DATA ex_data ;
};
#line 206 "/usr/include/openssl/asn1.h"
struct asn1_object_st {
   char const   *sn ;
   char const   *ln ;
   int nid ;
   int length ;
   unsigned char *data ;
   int flags ;
};
#line 206 "/usr/include/openssl/asn1.h"
typedef struct asn1_object_st ASN1_OBJECT;
#line 222 "/usr/include/openssl/asn1.h"
struct asn1_string_st {
   int length ;
   int type ;
   unsigned char *data ;
   long flags ;
};
#line 222 "/usr/include/openssl/asn1.h"
typedef struct asn1_string_st ASN1_STRING;
#line 488 "/usr/include/openssl/asn1.h"
union __anonunion_value_64 {
   char *ptr ;
   ASN1_BOOLEAN boolean ;
   ASN1_STRING *asn1_string ;
   ASN1_OBJECT *object ;
   ASN1_INTEGER *integer ;
   ASN1_ENUMERATED *enumerated ;
   ASN1_BIT_STRING *bit_string ;
   ASN1_OCTET_STRING *octet_string ;
   ASN1_PRINTABLESTRING *printablestring ;
   ASN1_T61STRING *t61string ;
   ASN1_IA5STRING *ia5string ;
   ASN1_GENERALSTRING *generalstring ;
   ASN1_BMPSTRING *bmpstring ;
   ASN1_UNIVERSALSTRING *universalstring ;
   ASN1_UTCTIME *utctime ;
   ASN1_GENERALIZEDTIME *generalizedtime ;
   ASN1_VISIBLESTRING *visiblestring ;
   ASN1_UTF8STRING *utf8string ;
   ASN1_STRING *set ;
   ASN1_STRING *sequence ;
};
#line 488 "/usr/include/openssl/asn1.h"
struct asn1_type_st {
   int type ;
   union __anonunion_value_64 value ;
};
#line 488 "/usr/include/openssl/asn1.h"
typedef struct asn1_type_st ASN1_TYPE;
#line 297 "/usr/include/openssl/evp.h"
struct evp_cipher_st {
   int nid ;
   int block_size ;
   int key_len ;
   int iv_len ;
   unsigned long flags ;
   int (*init)(EVP_CIPHER_CTX *ctx , unsigned char const   *key , unsigned char const   *iv ,
               int enc ) ;
   int (*do_cipher)(EVP_CIPHER_CTX *ctx , unsigned char *out , unsigned char const   *in ,
                    unsigned int inl ) ;
   int (*cleanup)(EVP_CIPHER_CTX * ) ;
   int ctx_size ;
   int (*set_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*get_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*ctrl)(EVP_CIPHER_CTX * , int type , int arg , void *ptr ) ;
   void *app_data ;
};
#line 357 "/usr/include/openssl/evp.h"
struct evp_cipher_ctx_st {
   EVP_CIPHER const   *cipher ;
   ENGINE *engine ;
   int encrypt ;
   int buf_len ;
   unsigned char oiv[16] ;
   unsigned char iv[16] ;
   unsigned char buf[32] ;
   int num ;
   void *app_data ;
   int key_len ;
   unsigned long flags ;
   void *cipher_data ;
   int final_used ;
   int block_mask ;
   unsigned char final[32] ;
};
#line 529 "/usr/include/openssl/pem.h"
typedef int pem_password_cb(char *buf , int size , int rwflag , void *userdata );
#line 78 "/usr/include/openssl/des.h"
typedef unsigned char DES_cblock[8];
#line 83 "/usr/include/openssl/des.h"
union __anonunion_ks_73 {
   DES_cblock cblock ;
   unsigned long deslong[2] ;
};
#line 83 "/usr/include/openssl/des.h"
struct DES_ks {
   union __anonunion_ks_73 ks[16] ;
};
#line 83 "/usr/include/openssl/des.h"
typedef struct DES_ks DES_key_schedule;
#line 101 "/usr/include/openssl/blowfish.h"
struct bf_key_st {
   unsigned int P[18] ;
   unsigned int S[1024] ;
};
#line 71 "/usr/include/openssl/rc4.h"
struct rc4_key_st {
   unsigned int x ;
   unsigned int y ;
   unsigned int data[256] ;
};
#line 71 "/usr/include/openssl/rc4.h"
typedef struct rc4_key_st RC4_KEY;
#line 80 "/usr/include/openssl/cast.h"
struct cast_key_st {
   unsigned long data[32] ;
   int short_key ;
};
#line 80 "/usr/include/openssl/cast.h"
typedef struct cast_key_st CAST_KEY;
#line 43 "cipher.h"
struct __anonstruct_des3_77 {
   DES_key_schedule key1 ;
   DES_key_schedule key2 ;
   DES_cblock iv2 ;
   DES_key_schedule key3 ;
   DES_cblock iv3 ;
};
#line 43 "cipher.h"
struct __anonstruct_bf_78 {
   struct bf_key_st key ;
   unsigned char iv[8] ;
};
#line 43 "cipher.h"
struct __anonstruct_cast_79 {
   CAST_KEY key ;
   unsigned char iv[8] ;
};
#line 43 "cipher.h"
union __anonunion_u_76 {
   struct __anonstruct_des3_77 des3 ;
   struct __anonstruct_bf_78 bf ;
   struct __anonstruct_cast_79 cast ;
   RC4_KEY rc4 ;
};
#line 43 "cipher.h"
struct __anonstruct_CipherContext_75 {
   unsigned int type ;
   union __anonunion_u_76 u ;
};
#line 43 "cipher.h"
typedef struct __anonstruct_CipherContext_75 CipherContext;
#line 44 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 45 "/usr/include/bits/types.h"
typedef unsigned int __uint32_t;
#line 202 "/usr/include/sys/types.h"
typedef unsigned short u_int16_t;
#line 162 "/usr/include/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   __uint32_t __ss_align ;
   char __ss_padding[128U - 2U * sizeof(__uint32_t )] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 92 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 136 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 137 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 193 "/usr/include/netinet/in.h"
union __anonunion_in6_u_21 {
   uint8_t u6_addr8[16] ;
   uint16_t u6_addr16[8] ;
   uint32_t u6_addr32[4] ;
};
#line 193 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion_in6_u_21 in6_u ;
};
#line 219 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 233 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 321 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 538 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 35 "/usr/include/bits/types.h"
typedef unsigned short __u_short;
#line 146 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 36 "/usr/include/sys/types.h"
typedef __u_short u_short;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024U / (8U * sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 314 "/usr/include/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 24 "channels.h"
struct Channel;
#line 25 "channels.h"
typedef struct Channel Channel;
#line 27 "channels.h"
typedef void channel_callback_fn(int id , void *arg );
#line 28 "channels.h"
typedef int channel_filter_fn(struct Channel *c , char *buf , int len );
#line 30 "channels.h"
struct Channel {
   int type ;
   int self ;
   int remote_id ;
   int istate ;
   int ostate ;
   int flags ;
   int rfd ;
   int wfd ;
   int efd ;
   int sock ;
   Buffer input ;
   Buffer output ;
   Buffer extended ;
   char path[200] ;
   int listening_port ;
   int host_port ;
   char *remote_name ;
   int remote_window ;
   int remote_maxpacket ;
   int local_window ;
   int local_window_max ;
   int local_consumed ;
   int local_maxpacket ;
   int extended_usage ;
   char *ctype ;
   channel_callback_fn *cb_fn ;
   void *cb_arg ;
   int cb_event ;
   channel_callback_fn *dettach_user ;
   channel_filter_fn *input_filter ;
};
#line 80 "nchan.h"
typedef void chan_event_fn(Channel *c );
#line 96 "channels.c"
struct __anonstruct_ForwardPermission_79 {
   char *host_to_connect ;
   u_short port_to_connect ;
   u_short listen_port ;
};
#line 96 "channels.c"
typedef struct __anonstruct_ForwardPermission_79 ForwardPermission;
#line 316 "channels.c"
typedef void chan_fn(Channel *c , fd_set *readset , fd_set *writeset );
#line 79 "/usr/include/openssl/des.h"
typedef unsigned char const_DES_cblock[8];
#line 101 "/usr/include/openssl/blowfish.h"
typedef struct bf_key_st BF_KEY;
#line 99 "/usr/include/openssl/md5.h"
struct MD5state_st {
   unsigned int A ;
   unsigned int B ;
   unsigned int C ;
   unsigned int D ;
   unsigned int Nl ;
   unsigned int Nh ;
   unsigned int data[16] ;
   unsigned int num ;
};
#line 99 "/usr/include/openssl/md5.h"
typedef struct MD5state_st MD5_CTX;
#line 89 "cipher.c"
union __anonunion_t_74 {
   u_int32_t i ;
   char c[4] ;
};
#line 60 "compat.c"
struct __anonstruct_check_74 {
   char *version ;
   int bugs ;
};
#line 261 "/usr/include/zconf.h"
typedef unsigned char Byte;
#line 263 "/usr/include/zconf.h"
typedef unsigned int uInt;
#line 264 "/usr/include/zconf.h"
typedef unsigned long uLong;
#line 270 "/usr/include/zconf.h"
typedef Byte Bytef;
#line 279 "/usr/include/zconf.h"
typedef void *voidpf;
#line 80 "/usr/include/zlib.h"
struct internal_state;
#line 82 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 82 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 103 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 1346 "/usr/include/zlib.h"
struct internal_state {
   int dummy ;
};
#line 6 "dispatch.h"
typedef void dispatch_fn(int type , int plen );
#line 118 "/usr/include/openssl/ossl_typ.h"
struct env_md_st;
#line 118 "/usr/include/openssl/ossl_typ.h"
typedef struct env_md_st EVP_MD;
#line 119
struct env_md_ctx_st;
#line 119 "/usr/include/openssl/ossl_typ.h"
typedef struct env_md_ctx_st EVP_MD_CTX;
#line 220 "/usr/include/openssl/evp.h"
struct env_md_st {
   int type ;
   int pkey_type ;
   int md_size ;
   unsigned long flags ;
   int (*init)(EVP_MD_CTX *ctx ) ;
   int (*update)(EVP_MD_CTX *ctx , void const   *data , size_t count ) ;
   int (*final)(EVP_MD_CTX *ctx , unsigned char *md ) ;
   int (*copy)(EVP_MD_CTX *to , EVP_MD_CTX const   *from ) ;
   int (*cleanup)(EVP_MD_CTX *ctx ) ;
   int (*sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
               unsigned int *siglen , void *key ) ;
   int (*verify)(int type , unsigned char const   *m , unsigned int m_length , unsigned char const   *sigbuf ,
                 unsigned int siglen , void *key ) ;
   int required_pkey_type[5] ;
   int block_size ;
   int ctx_size ;
};
#line 280 "/usr/include/openssl/evp.h"
struct env_md_ctx_st {
   EVP_MD const   *digest ;
   ENGINE *engine ;
   unsigned long flags ;
   void *md_data ;
};
#line 75 "/usr/include/openssl/hmac.h"
struct hmac_ctx_st {
   EVP_MD const   *md ;
   EVP_MD_CTX md_ctx ;
   EVP_MD_CTX i_ctx ;
   EVP_MD_CTX o_ctx ;
   unsigned int key_length ;
   unsigned char key[128] ;
};
#line 75 "/usr/include/openssl/hmac.h"
typedef struct hmac_ctx_st HMAC_CTX;
#line 10 "hostfile.h"
enum __anonenum_HostStatus_74 {
    HOST_OK = 0,
    HOST_NEW = 1,
    HOST_CHANGED = 2
} ;
#line 10 "hostfile.h"
typedef enum __anonenum_HostStatus_74 HostStatus;
#line 122 "/usr/include/openssl/ossl_typ.h"
struct dh_st;
#line 122 "/usr/include/openssl/ossl_typ.h"
typedef struct dh_st DH;
#line 123
struct dh_method;
#line 123 "/usr/include/openssl/ossl_typ.h"
typedef struct dh_method DH_METHOD;
#line 95 "/usr/include/openssl/dh.h"
struct dh_method {
   char const   *name ;
   int (*generate_key)(DH *dh ) ;
   int (*compute_key)(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
   int (*bn_mod_exp)(DH const   *dh , BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p ,
                     BIGNUM const   *m , BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DH *dh ) ;
   int (*finish)(DH *dh ) ;
   int flags ;
   char *app_data ;
   int (*generate_params)(DH *dh , int prime_len , int generator , BN_GENCB *cb ) ;
};
#line 113 "/usr/include/openssl/dh.h"
struct dh_st {
   int pad ;
   int version ;
   BIGNUM *p ;
   BIGNUM *g ;
   long length ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   BIGNUM *q ;
   BIGNUM *j ;
   unsigned char *seed ;
   int seedlen ;
   BIGNUM *counter ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DH_METHOD const   *meth ;
   ENGINE *engine ;
};
#line 55 "kex.h"
struct Kex;
#line 55 "kex.h"
typedef struct Kex Kex;
#line 56
struct Mac;
#line 56 "kex.h"
typedef struct Mac Mac;
#line 57
struct Comp;
#line 57 "kex.h"
typedef struct Comp Comp;
#line 58
struct Enc;
#line 58 "kex.h"
typedef struct Enc Enc;
#line 60 "kex.h"
struct Enc {
   int type ;
   int enabled ;
   int block_size ;
   unsigned char *key ;
   unsigned char *iv ;
   int key_len ;
   int iv_len ;
   char *name ;
};
#line 70 "kex.h"
struct Mac {
   EVP_MD *md ;
   int enabled ;
   int mac_len ;
   unsigned char *key ;
   int key_len ;
   char *name ;
};
#line 78 "kex.h"
struct Comp {
   int type ;
   int enabled ;
   char *name ;
};
#line 83 "kex.h"
struct Kex {
   Enc enc[2] ;
   Mac mac[2] ;
   Comp comp[2] ;
   int we_need ;
   int server ;
   char *name ;
   char *hostkeyalg ;
};
#line 43 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 105 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 433 "ssh.h"
enum __anonenum_SyslogFacility_72 {
    SYSLOG_FACILITY_DAEMON = 0,
    SYSLOG_FACILITY_USER = 1,
    SYSLOG_FACILITY_AUTH = 2,
    SYSLOG_FACILITY_LOCAL0 = 3,
    SYSLOG_FACILITY_LOCAL1 = 4,
    SYSLOG_FACILITY_LOCAL2 = 5,
    SYSLOG_FACILITY_LOCAL3 = 6,
    SYSLOG_FACILITY_LOCAL4 = 7,
    SYSLOG_FACILITY_LOCAL5 = 8,
    SYSLOG_FACILITY_LOCAL6 = 9,
    SYSLOG_FACILITY_LOCAL7 = 10
} ;
#line 433 "ssh.h"
typedef enum __anonenum_SyslogFacility_72 SyslogFacility;
#line 447
enum __anonenum_LogLevel_73 {
    SYSLOG_LEVEL_QUIET = 0,
    SYSLOG_LEVEL_FATAL = 1,
    SYSLOG_LEVEL_ERROR = 2,
    SYSLOG_LEVEL_INFO = 3,
    SYSLOG_LEVEL_VERBOSE = 4,
    SYSLOG_LEVEL_DEBUG = 5
} ;
#line 447 "ssh.h"
typedef enum __anonenum_LogLevel_73 LogLevel;
#line 69 "log.c"
struct fatal_cleanup {
   struct fatal_cleanup *next ;
   void (*proc)(void * ) ;
   void *context ;
};
#line 132 "log.c"
struct __anonstruct_log_facilities_74 {
   char const   *name ;
   SyslogFacility val ;
};
#line 150 "log.c"
struct __anonstruct_log_levels_75 {
   char const   *name ;
   LogLevel val ;
};
#line 154 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 148 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 28 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024U / (8U * sizeof(unsigned long ))] ;
};
#line 28 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 33 "/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__kill_26 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__timer_27 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__rt_28 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_29 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_30 {
   void *si_addr ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_31 {
   long si_band ;
   int si_fd ;
};
#line 51 "/usr/include/bits/siginfo.h"
union __anonunion__sifields_25 {
   int _pad[128U / sizeof(int ) - 3U] ;
   struct __anonstruct__kill_26 _kill ;
   struct __anonstruct__timer_27 _timer ;
   struct __anonstruct__rt_28 _rt ;
   struct __anonstruct__sigchld_29 _sigchld ;
   struct __anonstruct__sigfault_30 _sigfault ;
   struct __anonstruct__sigpoll_31 _sigpoll ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_25 _sifields ;
};
#line 51 "/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 25 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_43 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_43 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 25 "/usr/include/bits/termios.h"
typedef unsigned char cc_t;
#line 26 "/usr/include/bits/termios.h"
typedef unsigned int speed_t;
#line 27 "/usr/include/bits/termios.h"
typedef unsigned int tcflag_t;
#line 30 "/usr/include/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 338 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 34 "/usr/include/bits/types.h"
typedef unsigned char __u_char;
#line 35 "/usr/include/sys/types.h"
typedef __u_char u_char;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 85 "/usr/include/sys/select.h"
typedef __fd_mask fd_mask;
#line 75 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 29 "servconf.h"
struct __anonstruct_ServerOptions_74 {
   unsigned int num_ports ;
   unsigned int ports_from_cmdline ;
   u_short ports[256] ;
   char *listen_addr ;
   struct addrinfo *listen_addrs ;
   char *host_key_file ;
   char *host_dsa_key_file ;
   char *pid_file ;
   int server_key_bits ;
   int login_grace_time ;
   int key_regeneration_time ;
   int permit_root_login ;
   int ignore_rhosts ;
   int ignore_user_known_hosts ;
   int print_motd ;
   int check_mail ;
   int x11_forwarding ;
   int x11_display_offset ;
   char *xauth_location ;
   int strict_modes ;
   int keepalives ;
   char *ciphers ;
   int protocol ;
   int gateway_ports ;
   SyslogFacility log_facility ;
   LogLevel log_level ;
   int rhosts_authentication ;
   int rhosts_rsa_authentication ;
   int rsa_authentication ;
   int dsa_authentication ;
   int password_authentication ;
   int permit_empty_passwd ;
   int use_login ;
   unsigned int num_allow_users ;
   char *allow_users[256] ;
   unsigned int num_deny_users ;
   char *deny_users[256] ;
   unsigned int num_allow_groups ;
   char *allow_groups[256] ;
   unsigned int num_deny_groups ;
   char *deny_groups[256] ;
   unsigned int num_subsystems ;
   char *subsystem_name[256] ;
   char *subsystem_command[256] ;
   int max_startups_begin ;
   int max_startups_rate ;
   int max_startups ;
};
#line 29 "servconf.h"
typedef struct __anonstruct_ServerOptions_74 ServerOptions;
#line 116 "sshd.c"
struct __anonstruct_sensitive_data_76 {
   RSA *private_key ;
   RSA *host_key ;
   Key *dsa_host_key ;
};
#line 43 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 84 "auth2.c"
struct Authctxt;
#line 84 "auth2.c"
typedef struct Authctxt Authctxt;
#line 85 "auth2.c"
struct Authctxt {
   char *user ;
   char *service ;
   struct passwd pw ;
   int valid ;
};
#line 516 "ssh.h"
struct envstring {
   struct envstring *next ;
   char *s ;
};
#line 18 "/usr/include/security/_pam_types.h"
struct pam_handle;
#line 18 "/usr/include/security/_pam_types.h"
typedef struct pam_handle pam_handle_t;
#line 244 "/usr/include/security/_pam_types.h"
struct pam_message {
   int msg_style ;
   char const   *msg ;
};
#line 269 "/usr/include/security/_pam_types.h"
struct pam_response {
   char *resp ;
   int resp_retcode ;
};
#line 276 "/usr/include/security/_pam_types.h"
struct pam_conv {
   int (*conv)(int num_msg , struct pam_message  const  **msg , struct pam_response **resp ,
               void *appdata_ptr ) ;
   void *appdata_ptr ;
};
#line 53 "auth-pam.c"
struct pam_handle_t;
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 28 "/usr/include/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 53 "loginrec.h"
union login_netinfo {
   struct sockaddr sa ;
   struct sockaddr_in sa_in ;
   struct sockaddr_storage sa_storage ;
};
#line 73 "loginrec.h"
struct logininfo {
   char progname[64] ;
   int progname_null ;
   short type ;
   int pid ;
   int uid ;
   char line[64] ;
   char username[64] ;
   char hostname[256] ;
   int exit ;
   int termination ;
   unsigned int tv_sec ;
   unsigned int tv_usec ;
   union login_netinfo hostaddr ;
};
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 38 "/usr/include/bits/utmp.h"
struct lastlog {
   __time_t ll_time ;
   char ll_line[32] ;
   char ll_host[256] ;
};
#line 52 "/usr/include/bits/utmp.h"
struct exit_status {
   short e_termination ;
   short e_exit ;
};
#line 60 "/usr/include/bits/utmp.h"
struct utmp {
   short ut_type ;
   pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct exit_status ut_exit ;
   long ut_session ;
   struct timeval ut_tv ;
   int32_t ut_addr_v6[4] ;
   char __unused[20] ;
};
#line 174 "servconf.c"
enum __anonenum_ServerOpCodes_75 {
    sBadOption = 0,
    sPort = 1,
    sHostKeyFile = 2,
    sServerKeyBits = 3,
    sLoginGraceTime = 4,
    sKeyRegenerationTime = 5,
    sPermitRootLogin = 6,
    sLogFacility = 7,
    sLogLevel = 8,
    sRhostsAuthentication = 9,
    sRhostsRSAAuthentication = 10,
    sRSAAuthentication = 11,
    sPasswordAuthentication = 12,
    sListenAddress = 13,
    sPrintMotd = 14,
    sIgnoreRhosts = 15,
    sX11Forwarding = 16,
    sX11DisplayOffset = 17,
    sStrictModes = 18,
    sEmptyPasswd = 19,
    sRandomSeedFile = 20,
    sKeepAlives = 21,
    sCheckMail = 22,
    sUseLogin = 23,
    sAllowUsers = 24,
    sDenyUsers = 25,
    sAllowGroups = 26,
    sDenyGroups = 27,
    sIgnoreUserKnownHosts = 28,
    sHostDSAKeyFile = 29,
    sCiphers = 30,
    sProtocol = 31,
    sPidFile = 32,
    sGatewayPorts = 33,
    sDSAAuthentication = 34,
    sXAuthLocation = 35,
    sSubsystem = 36,
    sMaxStartups = 37
} ;
#line 174 "servconf.c"
typedef enum __anonenum_ServerOpCodes_75 ServerOpCodes;
#line 197 "servconf.c"
struct __anonstruct_keywords_76 {
   char const   *name ;
   ServerOpCodes opcode ;
};
#line 63 "/usr/include/sys/wait.h"
union wait;
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_terminated_46 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_stopped_47 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_46 __wait_terminated ;
   struct __anonstruct___wait_stopped_47 __wait_stopped ;
};
#line 75 "serverloop.c"
union __anonunion_77 {
   int volatile   __in ;
   int __i ;
};
#line 75 "serverloop.c"
union __anonunion_78 {
   int volatile   __in ;
   int __i ;
};
#line 586 "serverloop.c"
union __anonunion_79 {
   int __in ;
   int __i ;
};
#line 588 "serverloop.c"
union __anonunion_80 {
   int __in ;
   int __i ;
};
#line 584 "serverloop.c"
union __anonunion_81 {
   int __in ;
   int __i ;
};
#line 610 "serverloop.c"
union __anonunion_82 {
   int __in ;
   int __i ;
};
#line 609 "serverloop.c"
union __anonunion_83 {
   int __in ;
   int __i ;
};
#line 77 "/usr/include/time.h"
typedef __time_t time_t;
#line 62 "session.c"
struct Session;
#line 62 "session.c"
typedef struct Session Session;
#line 63 "session.c"
struct Session {
   int used ;
   int self ;
   int extended ;
   struct passwd *pw ;
   pid_t pid ;
   char *term ;
   int ptyfd ;
   int ttyfd ;
   int ptymaster ;
   int row ;
   int col ;
   int xpixel ;
   int ypixel ;
   char tty[64] ;
   char *display ;
   int screen ;
   char *auth_proto ;
   char *auth_data ;
   int single_connection ;
   int chanid ;
};
#line 1710 "session.c"
union __anonunion_76 {
   int __in ;
   int __i ;
};
#line 1715 "session.c"
union __anonunion_77___0 {
   int __in ;
   int __i ;
};
#line 1717 "session.c"
union __anonunion_78___0 {
   int __in ;
   int __i ;
};
#line 1712 "session.c"
union __anonunion_79___0 {
   int __in ;
   int __i ;
};
#line 1707 "session.c"
union __anonunion_80___0 {
   int __in ;
   int __i ;
};
#line 1 "atomicio.o"
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 524 "ssh.h"
ssize_t atomicio(ssize_t (*f)() , int fd , void *_s , size_t n___0 ) ;
#line 35 "atomicio.c"
ssize_t atomicio(ssize_t (*f)() , int fd , void *_s , size_t n___0 ) 
{ char *s ;
  ssize_t res ;
  ssize_t pos ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 42
  s = (char *)_s;
#line 43
  pos = 0;
#line 45
  while (n___0 > (size_t )pos) {
#line 46
    res = (*f)(fd, s + pos, n___0 - (size_t )pos);
#line 47
    switch (res) {
    case -1: 
#line 50
    tmp = __errno_location();
#line 50
    if (*tmp == 4) {
#line 54
      continue;
    } else {
#line 50
      tmp___0 = __errno_location();
#line 50
      if (*tmp___0 == 11) {
#line 54
        continue;
      } else {
#line 50
        tmp___1 = __errno_location();
#line 50
        if (*tmp___1 == 11) {
#line 54
          continue;
        }
      }
    }
    case 0: 
#line 56
    return (res);
    default: 
#line 58
    pos += res;
    }
  }
#line 61
  return (pos);
}
}
#line 1 "authfd.o"
#line 100 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 124
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 242 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 320 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 327
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 333
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 76 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 660 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 7 "bsd-strlcpy.h"
size_t strlcpy(char *dst , char const   *src , size_t siz ) ;
#line 405 "/usr/include/openssl/bn.h"
extern int BN_num_bits(BIGNUM const   *a ) ;
#line 466 "ssh.h"
void ( /* format attribute */  fatal)(char const   *fmt  , ...) ;
#line 467
void ( /* format attribute */  error)(char const   *fmt  , ...) ;
#line 468
void ( /* format attribute */  log)(char const   *fmt  , ...) ;
#line 28 "buffer.h"
void buffer_init(Buffer *buffer ) ;
#line 31
void buffer_free(Buffer *buffer ) ;
#line 35
void buffer_clear(Buffer *buffer ) ;
#line 38
void buffer_append(Buffer *buffer , char const   *data , unsigned int len ) ;
#line 48
unsigned int buffer_len(Buffer *buffer ) ;
#line 60
char *buffer_ptr(Buffer *buffer ) ;
#line 25 "bufaux.h"
void buffer_put_bignum(Buffer *buffer , BIGNUM *value ) ;
#line 26
void buffer_put_bignum2(Buffer *buffer , BIGNUM *value ) ;
#line 29
int buffer_get_bignum(Buffer *buffer , BIGNUM *value ) ;
#line 33
unsigned int buffer_get_int(Buffer *buffer ) ;
#line 36
void buffer_put_int(Buffer *buffer , unsigned int value ) ;
#line 39
int buffer_get_char(Buffer *buffer ) ;
#line 42
void buffer_put_char(Buffer *buffer , int value ) ;
#line 52
char *buffer_get_string(Buffer *buffer , unsigned int *length_ptr ) ;
#line 55
void buffer_put_string(Buffer *buffer , void const   *buf___1 , unsigned int len ) ;
#line 56
void buffer_put_cstring(Buffer *buffer , char const   *s ) ;
#line 23 "xmalloc.h"
void *xmalloc(size_t size ) ;
#line 29
void xfree(void *ptr ) ;
#line 16 "key.h"
Key *key_new(int type ) ;
#line 49 "authfd.h"
int ssh_get_authentication_socket(void) ;
#line 56
void ssh_close_authentication_socket(int sock ) ;
#line 64
AuthenticationConnection *ssh_get_authentication_connection(void) ;
#line 70
void ssh_close_authentication_connection(AuthenticationConnection *auth ) ;
#line 77
Key *ssh_get_first_identity(AuthenticationConnection *auth , char **comment , int version ) ;
#line 85
Key *ssh_get_next_identity(AuthenticationConnection *auth , char **comment , int version ) ;
#line 91
int ssh_decrypt_challenge(AuthenticationConnection *auth , Key *key , BIGNUM *challenge ,
                          unsigned char *session_id___0 , unsigned int response_type ,
                          unsigned char *response ) ;
#line 99
int ssh_agent_sign(AuthenticationConnection *auth , Key *key , unsigned char **sigp ,
                   int *lenp , unsigned char *data , int datalen ) ;
#line 110
int ssh_add_identity(AuthenticationConnection *auth , Key *key , char const   *comment ) ;
#line 119
int ssh_remove_identity(AuthenticationConnection *auth , Key *key ) ;
#line 126
int ssh_remove_all_identities(AuthenticationConnection *auth , int version ) ;
#line 4 "dsa.h"
Key *dsa_key_from_blob(char *blob , int blen ) ;
#line 5
int dsa_make_key_blob(Key *key , unsigned char **blobp , unsigned int *lenp ) ;
#line 38 "authfd.c"
int decode_reply(int type ) ;
#line 42 "authfd.c"
int ssh_get_authentication_socket(void) 
{ char const   *authsocket ;
  int sock ;
  int len ;
  struct sockaddr_un sunaddr ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 49
  tmp = getenv("SSH_AUTH_SOCK");
#line 49
  authsocket = (char const   *)tmp;
#line 50
  if (! authsocket) {
#line 51
    return (-1);
  }
#line 53
  sunaddr.sun_family = (unsigned short)1;
#line 54
  strlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));
#line 58
  tmp___0 = strlen((char const   *)(sunaddr.sun_path));
#line 58
  len = (int )(((unsigned int )(((struct sockaddr_un *)0)->sun_path) + tmp___0) + 1U);
#line 61
  sock = socket(1, 1, 0);
#line 62
  if (sock < 0) {
#line 63
    return (-1);
  }
#line 66
  tmp___1 = fcntl(sock, 2, 1);
#line 66
  if (tmp___1 == -1) {
#line 67
    close(sock);
#line 68
    return (-1);
  }
#line 70
  tmp___2 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sunaddr)),
                    (unsigned int )len);
#line 70
  if (tmp___2 < 0) {
#line 71
    close(sock);
#line 72
    return (-1);
  }
#line 74
  return (sock);
}
}
#line 77 "authfd.c"
int ssh_request_reply(AuthenticationConnection *auth , Buffer *request , Buffer *reply ) 
{ int l ;
  int len ;
  char buf___1[1024] ;
  unsigned int tmp ;
  ssize_t tmp___0 ;
  unsigned int tmp___1 ;
  char *tmp___2 ;
  ssize_t tmp___3 ;
  unsigned int tmp___4 ;

  {
#line 84
  tmp = buffer_len(request);
#line 84
  len = (int )tmp;
#line 85
  while (1) {
#line 85
    buf___1[0] = (char )(len >> 24);
#line 85
    buf___1[1] = (char )(len >> 16);
#line 85
    buf___1[2] = (char )(len >> 8);
#line 85
    buf___1[3] = (char )len;
#line 85
    break;
  }
#line 88
  tmp___0 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)(buf___1), 4U);
#line 88
  if (tmp___0 != 4) {
#line 91
    error("Error writing to authentication socket.");
#line 92
    return (0);
  } else {
#line 88
    tmp___1 = buffer_len(request);
#line 88
    tmp___2 = buffer_ptr(request);
#line 88
    tmp___3 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)tmp___2, tmp___1);
#line 88
    tmp___4 = buffer_len(request);
#line 88
    if ((unsigned int )tmp___3 != tmp___4) {
#line 91
      error("Error writing to authentication socket.");
#line 92
      return (0);
    }
  }
#line 98
  len = 4;
#line 99
  while (len > 0) {
#line 100
    l = read(auth->fd, (void *)((buf___1 + 4) - len), (unsigned int )len);
#line 101
    if (l <= 0) {
#line 102
      error("Error reading response length from authentication socket.");
#line 103
      return (0);
    }
#line 105
    len -= l;
  }
#line 109
  len = (int )(((((unsigned long )((unsigned char )buf___1[0]) << 24) | ((unsigned long )((unsigned char )buf___1[1]) << 16)) | ((unsigned long )((unsigned char )buf___1[2]) << 8)) | (unsigned long )((unsigned char )buf___1[3]));
#line 110
  if (len > 262144) {
#line 111
    fatal("Authentication response too long: %d", len);
  }
#line 114
  buffer_clear(reply);
#line 115
  while (len > 0) {
#line 116
    l = len;
#line 117
    if ((unsigned int )l > sizeof(buf___1)) {
#line 118
      l = (int )sizeof(buf___1);
    }
#line 119
    l = read(auth->fd, (void *)(buf___1), (unsigned int )l);
#line 120
    if (l <= 0) {
#line 121
      error("Error reading response from authentication socket.");
#line 122
      return (0);
    }
#line 124
    buffer_append(reply, (char const   *)(buf___1), (unsigned int )l);
#line 125
    len -= l;
  }
#line 127
  return (1);
}
}
#line 136 "authfd.c"
void ssh_close_authentication_socket(int sock ) 
{ char *tmp ;

  {
#line 139
  tmp = getenv("SSH_AUTH_SOCK");
#line 139
  if (tmp) {
#line 140
    close(sock);
  }
#line 141
  return;
}
}
#line 151 "authfd.c"
AuthenticationConnection *ssh_get_authentication_connection(void) 
{ AuthenticationConnection *auth ;
  int sock ;
  void *tmp ;

  {
#line 157
  sock = ssh_get_authentication_socket();
#line 163
  if (sock < 0) {
#line 164
    return ((AuthenticationConnection *)((void *)0));
  }
#line 166
  tmp = xmalloc(sizeof(*auth));
#line 166
  auth = (AuthenticationConnection *)tmp;
#line 167
  auth->fd = sock;
#line 168
  buffer_init(& auth->identities);
#line 169
  auth->howmany = 0;
#line 171
  return (auth);
}
}
#line 179 "authfd.c"
void ssh_close_authentication_connection(AuthenticationConnection *auth ) 
{ 

  {
#line 182
  buffer_free(& auth->identities);
#line 183
  close(auth->fd);
#line 184
  xfree((void *)auth);
#line 185
  return;
}
}
#line 191 "authfd.c"
Key *ssh_get_first_identity(AuthenticationConnection *auth , char **comment , int version ) 
{ int type ;
  int code1 ;
  int code2 ;
  Buffer request ;
  int tmp ;
  unsigned int tmp___0 ;
  Key *tmp___1 ;

  {
#line 194
  code1 = 0;
#line 194
  code2 = 0;
#line 197
  switch (version) {
  case 1: 
#line 199
  code1 = 1;
#line 200
  code2 = 2;
#line 201
  break;
  case 2: 
#line 203
  code1 = 11;
#line 204
  code2 = 12;
#line 205
  break;
  default: ;
#line 207
  return ((Key *)((void *)0));
  }
#line 214
  buffer_init(& request);
#line 215
  buffer_put_char(& request, code1);
#line 217
  buffer_clear(& auth->identities);
#line 218
  tmp = ssh_request_reply(auth, & request, & auth->identities);
#line 218
  if (tmp == 0) {
#line 219
    buffer_free(& request);
#line 220
    return ((Key *)((void *)0));
  }
#line 222
  buffer_free(& request);
#line 225
  type = buffer_get_char(& auth->identities);
#line 226
  if (type == 5) {
#line 227
    return ((Key *)((void *)0));
  } else {
#line 228
    if (type != code2) {
#line 229
      fatal("Bad authentication reply message type: %d", type);
    }
  }
#line 233
  tmp___0 = buffer_get_int(& auth->identities);
#line 233
  auth->howmany = (int )tmp___0;
#line 234
  if (auth->howmany > 1024) {
#line 235
    fatal("Too many identities in authentication reply: %d\n", auth->howmany);
  }
#line 239
  tmp___1 = ssh_get_next_identity(auth, comment, version);
#line 239
  return (tmp___1);
}
}
#line 242 "authfd.c"
Key *ssh_get_next_identity(AuthenticationConnection *auth , char **comment , int version ) 
{ unsigned int bits ;
  unsigned char *blob ;
  unsigned int blen ;
  Key *key ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 248
  key = (Key *)((void *)0);
#line 251
  if (auth->howmany <= 0) {
#line 252
    return ((Key *)((void *)0));
  }
#line 258
  switch (version) {
  case 1: 
#line 260
  key = key_new(0);
#line 261
  bits = buffer_get_int(& auth->identities);
#line 262
  buffer_get_bignum(& auth->identities, (key->rsa)->e);
#line 263
  buffer_get_bignum(& auth->identities, (key->rsa)->n);
#line 264
  *comment = buffer_get_string(& auth->identities, (unsigned int *)((void *)0));
#line 265
  tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 265
  if (bits != (unsigned int )tmp___0) {
#line 266
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 266
    log("Warning: identity keysize mismatch: actual %d, announced %u", tmp, bits);
  }
#line 268
  break;
  case 2: 
#line 270
  tmp___1 = buffer_get_string(& auth->identities, & blen);
#line 270
  blob = (unsigned char *)tmp___1;
#line 271
  *comment = buffer_get_string(& auth->identities, (unsigned int *)((void *)0));
#line 272
  key = dsa_key_from_blob((char *)blob, (int )blen);
#line 273
  xfree((void *)blob);
#line 274
  break;
  default: ;
#line 276
  return ((Key *)((void *)0));
#line 277
  break;
  }
#line 280
  (auth->howmany) --;
#line 281
  return (key);
}
}
#line 292 "authfd.c"
int ssh_decrypt_challenge(AuthenticationConnection *auth , Key *key , BIGNUM *challenge ,
                          unsigned char *session_id___0 , unsigned int response_type ,
                          unsigned char *response ) 
{ Buffer buffer ;
  int success ;
  int i ;
  int type ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 300
  success = 0;
#line 304
  if (key->type != 0) {
#line 305
    return (0);
  }
#line 306
  if (response_type == 0U) {
#line 307
    log("Compatibility with ssh protocol version 1.0 no longer supported.");
#line 308
    return (0);
  }
#line 310
  buffer_init(& buffer);
#line 311
  buffer_put_char(& buffer, 3);
#line 312
  tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 312
  buffer_put_int(& buffer, (unsigned int )tmp);
#line 313
  buffer_put_bignum(& buffer, (key->rsa)->e);
#line 314
  buffer_put_bignum(& buffer, (key->rsa)->n);
#line 315
  buffer_put_bignum(& buffer, challenge);
#line 316
  buffer_append(& buffer, (char const   *)((char *)session_id___0), 16U);
#line 317
  buffer_put_int(& buffer, response_type);
#line 319
  tmp___0 = ssh_request_reply(auth, & buffer, & buffer);
#line 319
  if (tmp___0 == 0) {
#line 320
    buffer_free(& buffer);
#line 321
    return (0);
  }
#line 323
  type = buffer_get_char(& buffer);
#line 325
  if (type == 5) {
#line 326
    log("Agent admitted failure to authenticate using the key.");
  } else {
#line 327
    if (type != 4) {
#line 328
      fatal("Bad authentication response: %d", type);
    } else {
#line 330
      success = 1;
#line 335
      i = 0;
#line 335
      while (i < 16) {
#line 336
        tmp___1 = buffer_get_char(& buffer);
#line 336
        *(response + i) = (unsigned char )tmp___1;
#line 335
        i ++;
      }
    }
  }
#line 338
  buffer_free(& buffer);
#line 339
  return (success);
}
}
#line 343 "authfd.c"
int ssh_agent_sign(AuthenticationConnection *auth , Key *key , unsigned char **sigp ,
                   int *lenp , unsigned char *data , int datalen ) 
{ Buffer msg ;
  unsigned char *blob ;
  unsigned int blen ;
  int type ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 353
  ret = -1;
#line 355
  tmp = dsa_make_key_blob(key, & blob, & blen);
#line 355
  if (tmp == 0) {
#line 356
    return (-1);
  }
#line 358
  buffer_init(& msg);
#line 359
  buffer_put_char(& msg, 13);
#line 360
  buffer_put_string(& msg, (void const   *)blob, blen);
#line 361
  buffer_put_string(& msg, (void const   *)data, (unsigned int )datalen);
#line 362
  xfree((void *)blob);
#line 364
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 364
  if (tmp___0 == 0) {
#line 365
    buffer_free(& msg);
#line 366
    return (-1);
  }
#line 368
  type = buffer_get_char(& msg);
#line 369
  if (type == 5) {
#line 370
    log("Agent admitted failure to sign using the key.");
  } else {
#line 371
    if (type != 14) {
#line 372
      fatal("Bad authentication response: %d", type);
    } else {
#line 374
      ret = 0;
#line 375
      tmp___1 = buffer_get_string(& msg, (unsigned int *)lenp);
#line 375
      *sigp = (unsigned char *)tmp___1;
    }
  }
#line 377
  buffer_free(& msg);
#line 378
  return (ret);
}
}
#line 383 "authfd.c"
void ssh_encode_identity_rsa(Buffer *b , RSA *key , char const   *comment ) 
{ int tmp ;
  size_t tmp___0 ;

  {
#line 386
  buffer_clear(b);
#line 387
  buffer_put_char(b, 7);
#line 388
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 388
  buffer_put_int(b, (unsigned int )tmp);
#line 389
  buffer_put_bignum(b, key->n);
#line 390
  buffer_put_bignum(b, key->e);
#line 391
  buffer_put_bignum(b, key->d);
#line 393
  buffer_put_bignum(b, key->iqmp);
#line 394
  buffer_put_bignum(b, key->q);
#line 395
  buffer_put_bignum(b, key->p);
#line 396
  tmp___0 = strlen(comment);
#line 396
  buffer_put_string(b, (void const   *)comment, tmp___0);
#line 397
  return;
}
}
#line 399 "authfd.c"
void ssh_encode_identity_dsa(Buffer *b , DSA *key , char const   *comment ) 
{ size_t tmp ;

  {
#line 402
  buffer_clear(b);
#line 403
  buffer_put_char(b, 17);
#line 404
  buffer_put_cstring(b, "ssh-dss");
#line 405
  buffer_put_bignum2(b, key->p);
#line 406
  buffer_put_bignum2(b, key->q);
#line 407
  buffer_put_bignum2(b, key->g);
#line 408
  buffer_put_bignum2(b, key->pub_key);
#line 409
  buffer_put_bignum2(b, key->priv_key);
#line 410
  tmp = strlen(comment);
#line 410
  buffer_put_string(b, (void const   *)comment, tmp);
#line 411
  return;
}
}
#line 418 "authfd.c"
int ssh_add_identity(AuthenticationConnection *auth , Key *key , char const   *comment ) 
{ Buffer msg ;
  int type ;
  int tmp ;
  int tmp___0 ;

  {
#line 424
  buffer_init(& msg);
#line 426
  switch (key->type) {
  case 0: 
#line 428
  ssh_encode_identity_rsa(& msg, key->rsa, comment);
#line 429
  break;
  case 1: 
#line 431
  ssh_encode_identity_dsa(& msg, key->dsa, comment);
#line 432
  break;
  default: 
#line 434
  buffer_free(& msg);
#line 435
  return (0);
#line 436
  break;
  }
#line 438
  tmp = ssh_request_reply(auth, & msg, & msg);
#line 438
  if (tmp == 0) {
#line 439
    buffer_free(& msg);
#line 440
    return (0);
  }
#line 442
  type = buffer_get_char(& msg);
#line 443
  buffer_free(& msg);
#line 444
  tmp___0 = decode_reply(type);
#line 444
  return (tmp___0);
}
}
#line 452 "authfd.c"
int ssh_remove_identity(AuthenticationConnection *auth , Key *key ) 
{ Buffer msg ;
  int type ;
  unsigned char *blob ;
  unsigned int blen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 460
  buffer_init(& msg);
#line 462
  if (key->type == 0) {
#line 463
    buffer_put_char(& msg, 8);
#line 464
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 464
    buffer_put_int(& msg, (unsigned int )tmp);
#line 465
    buffer_put_bignum(& msg, (key->rsa)->e);
#line 466
    buffer_put_bignum(& msg, (key->rsa)->n);
  } else {
#line 467
    if (key->type == 1) {
#line 468
      dsa_make_key_blob(key, & blob, & blen);
#line 469
      buffer_put_char(& msg, 18);
#line 470
      buffer_put_string(& msg, (void const   *)blob, blen);
#line 471
      xfree((void *)blob);
    } else {
#line 473
      buffer_free(& msg);
#line 474
      return (0);
    }
  }
#line 476
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 476
  if (tmp___0 == 0) {
#line 477
    buffer_free(& msg);
#line 478
    return (0);
  }
#line 480
  type = buffer_get_char(& msg);
#line 481
  buffer_free(& msg);
#line 482
  tmp___1 = decode_reply(type);
#line 482
  return (tmp___1);
}
}
#line 490 "authfd.c"
int ssh_remove_all_identities(AuthenticationConnection *auth , int version ) 
{ Buffer msg ;
  int type ;
  int code ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 495
  if (version == 1) {
#line 495
    tmp = 9;
  } else {
#line 495
    tmp = 19;
  }
#line 495
  code = tmp;
#line 499
  buffer_init(& msg);
#line 500
  buffer_put_char(& msg, code);
#line 502
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 502
  if (tmp___0 == 0) {
#line 503
    buffer_free(& msg);
#line 504
    return (0);
  }
#line 506
  type = buffer_get_char(& msg);
#line 507
  buffer_free(& msg);
#line 508
  tmp___1 = decode_reply(type);
#line 508
  return (tmp___1);
}
}
#line 511 "authfd.c"
int decode_reply(int type ) 
{ 

  {
#line 514
  switch (type) {
  case 5: 
#line 516
  log("SSH_AGENT_FAILURE");
#line 517
  return (0);
  case 6: 
#line 519
  return (1);
  default: 
#line 521
  fatal("Bad response from authentication agent: %d", type);
  }
#line 524
  return (0);
}
}
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
#line 1 "authfile.o"
#line 59 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 256
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 212 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 380
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __attribute__((__nonnull__(3))) ;
#line 447
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 447 "/usr/include/sys/stat.h"
__inline static int fstat(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
#line 450
  tmp = __fxstat(3, __fd, __statbuf);
#line 450
  return (tmp);
}
}
#line 301 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 642
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 154 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 213
extern int fclose(FILE *__stream ) ;
#line 280
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 85 "/usr/include/fcntl.h"
extern int open(char const   *__file , int __oflag  , ...)  __attribute__((__nonnull__(1))) ;
#line 36 "bsd-arc4random.h"
unsigned int arc4random(void) ;
#line 391 "/usr/include/openssl/bn.h"
extern BIGNUM const   *BN_value_one(void) ;
#line 393
extern BN_CTX *BN_CTX_new(void) ;
#line 397
extern void BN_CTX_free(BN_CTX *c ) ;
#line 407
extern BIGNUM *BN_new(void) ;
#line 409
extern void BN_clear_free(BIGNUM *a ) ;
#line 416
extern int BN_sub(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *b ) ;
#line 433
extern int BN_div(BIGNUM *dv , BIGNUM *rem , BIGNUM const   *m , BIGNUM const   *d ,
                  BN_CTX *ctx ) ;
#line 560 "/usr/include/openssl/bio.h"
extern BIO_METHOD *BIO_s_file(void) ;
#line 568
extern BIO *BIO_new(BIO_METHOD *type ) ;
#line 570
extern int BIO_free(BIO *a ) ;
#line 577
extern long BIO_ctrl(BIO *bp , int cmd , long larg , void *parg ) ;
#line 192 "/usr/include/openssl/dsa.h"
extern void DSA_free(DSA *r ) ;
#line 639 "/usr/include/openssl/evp.h"
extern EVP_CIPHER const   *EVP_des_ede3_cbc(void) ;
#line 625 "/usr/include/openssl/pem.h"
extern DSA *PEM_read_bio_DSAPrivateKey(BIO *bp , DSA **x , pem_password_cb *cb , void *u ) ;
#line 625
extern int PEM_write_DSAPrivateKey(FILE *fp , DSA *x , EVP_CIPHER const   *enc , unsigned char *kstr ,
                                   int klen , pem_password_cb *cb , void *u ) ;
#line 32 "xmalloc.h"
char *xstrdup(char const   *str ) ;
#line 45 "buffer.h"
void buffer_append_space(Buffer *buffer , char **datap , unsigned int len ) ;
#line 70 "cipher.h"
unsigned int cipher_mask1(void) ;
#line 74
char const   *cipher_name(int cipher ) ;
#line 101
void cipher_set_key_string(CipherContext *context , int cipher , char const   *passphrase ) ;
#line 106
void cipher_encrypt(CipherContext *context , unsigned char *dest , unsigned char const   *src ,
                    unsigned int len ) ;
#line 111
void cipher_decrypt(CipherContext *context , unsigned char *dest , unsigned char const   *src ,
                    unsigned int len ) ;
#line 470 "ssh.h"
void ( /* format attribute */  debug)(char const   *fmt  , ...) ;
#line 43 "authfile.c"
int save_private_key_rsa(char const   *filename , char const   *passphrase , RSA *key ,
                         char const   *comment ) 
{ Buffer buffer ;
  Buffer encrypted ;
  char buf___1[100] ;
  char *cp ;
  int fd ;
  int i ;
  CipherContext cipher ;
  int cipher_type___0 ;
  u_int32_t rand___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  unsigned int tmp___17 ;
  char *tmp___18 ;
  ssize_t tmp___19 ;
  unsigned int tmp___20 ;

  {
#line 58
  if (0) {
#line 58
    __s1_len = strlen(passphrase);
#line 58
    __s2_len = strlen("");
#line 58
    if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
      goto _L___0;
    } else {
#line 58
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 58
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 58
          tmp___8 = 1;
        } else {
#line 58
          if (__s2_len >= 4U) {
#line 58
            tmp___8 = 1;
          } else {
#line 58
            tmp___8 = 0;
          }
        }
      } else {
#line 58
        tmp___8 = 0;
      }
    }
#line 58
    if (tmp___8) {
#line 58
      tmp___4 = __builtin_strcmp(passphrase, "");
    } else {
#line 58
      tmp___7 = __builtin_strcmp(passphrase, "");
#line 58
      tmp___4 = tmp___7;
    }
  } else {
#line 58
    tmp___7 = __builtin_strcmp(passphrase, "");
#line 58
    tmp___4 = tmp___7;
  }
#line 58
  if (tmp___4 == 0) {
#line 59
    cipher_type___0 = 0;
  } else {
#line 61
    cipher_type___0 = 3;
  }
#line 64
  buffer_init(& buffer);
#line 67
  rand___0 = arc4random();
#line 68
  buf___1[0] = (char )(rand___0 & 255U);
#line 69
  buf___1[1] = (char )((rand___0 >> 8) & 255U);
#line 70
  buf___1[2] = buf___1[0];
#line 71
  buf___1[3] = buf___1[1];
#line 72
  buffer_append(& buffer, (char const   *)(buf___1), 4U);
#line 79
  buffer_put_bignum(& buffer, key->d);
#line 80
  buffer_put_bignum(& buffer, key->iqmp);
#line 81
  buffer_put_bignum(& buffer, key->q);
#line 82
  buffer_put_bignum(& buffer, key->p);
#line 85
  while (1) {
#line 85
    tmp___9 = buffer_len(& buffer);
#line 85
    if (! (tmp___9 % 8U != 0U)) {
#line 85
      break;
    }
#line 86
    buffer_put_char(& buffer, 0);
  }
#line 89
  buffer_init(& encrypted);
#line 92
  cp = (char *)"SSH PRIVATE KEY FILE FORMAT 1.1\n";
#line 93
  i = 0;
#line 93
  while (*(cp + i)) {
#line 94
    buffer_put_char(& encrypted, (int )*(cp + i));
#line 93
    i ++;
  }
#line 95
  buffer_put_char(& encrypted, 0);
#line 98
  buffer_put_char(& encrypted, cipher_type___0);
#line 99
  buffer_put_int(& encrypted, 0U);
#line 102
  tmp___10 = BN_num_bits((BIGNUM const   *)key->n);
#line 102
  buffer_put_int(& encrypted, (unsigned int )tmp___10);
#line 103
  buffer_put_bignum(& encrypted, key->n);
#line 104
  buffer_put_bignum(& encrypted, key->e);
#line 105
  tmp___11 = strlen(comment);
#line 105
  buffer_put_string(& encrypted, (void const   *)comment, tmp___11);
#line 108
  tmp___12 = buffer_len(& buffer);
#line 108
  buffer_append_space(& encrypted, & cp, tmp___12);
#line 110
  cipher_set_key_string(& cipher, cipher_type___0, passphrase);
#line 111
  tmp___13 = buffer_len(& buffer);
#line 111
  tmp___14 = buffer_ptr(& buffer);
#line 111
  cipher_encrypt(& cipher, (unsigned char *)cp, (unsigned char const   *)((unsigned char *)tmp___14),
                 tmp___13);
#line 114
  memset((void *)(& cipher), 0, sizeof(cipher));
#line 117
  memset((void *)(buf___1), 0, sizeof(buf___1));
#line 118
  buffer_free(& buffer);
#line 120
  fd = open(filename, 577, 384);
#line 121
  if (fd < 0) {
#line 122
    return (0);
  }
#line 123
  tmp___17 = buffer_len(& encrypted);
#line 123
  tmp___18 = buffer_ptr(& encrypted);
#line 123
  tmp___19 = write(fd, (void const   *)tmp___18, tmp___17);
#line 123
  tmp___20 = buffer_len(& encrypted);
#line 123
  if ((unsigned int )tmp___19 != tmp___20) {
#line 125
    tmp___15 = __errno_location();
#line 125
    tmp___16 = strerror(*tmp___15);
#line 125
    debug("Write to key file %.200s failed: %.100s", filename, tmp___16);
#line 127
    buffer_free(& encrypted);
#line 128
    close(fd);
#line 129
    remove(filename);
#line 130
    return (0);
  }
#line 132
  close(fd);
#line 133
  buffer_free(& encrypted);
#line 134
  return (1);
}
}
#line 139 "authfile.c"
int save_private_key_dsa(char const   *filename , char const   *passphrase , DSA *dsa ,
                         char const   *comment ) 
{ FILE *fp ;
  int fd ;
  int success ;
  int len ;
  size_t tmp ;
  int *tmp___0 ;
  size_t tmp___1 ;
  EVP_CIPHER const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 145
  success = 1;
#line 146
  tmp = strlen(passphrase);
#line 146
  len = (int )tmp;
#line 148
  if (len > 0) {
#line 148
    if (len <= 4) {
#line 149
      error("passphrase too short: %d bytes", len);
#line 150
      tmp___0 = __errno_location();
#line 150
      *tmp___0 = 0;
#line 151
      return (0);
    }
  }
#line 153
  fd = open(filename, 577, 384);
#line 154
  if (fd < 0) {
#line 155
    debug("open %s failed", filename);
#line 156
    return (0);
  }
#line 158
  fp = fdopen(fd, "w");
#line 159
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 160
    debug("fdopen %s failed", filename);
#line 161
    close(fd);
#line 162
    return (0);
  }
#line 164
  if (len > 0) {
#line 165
    tmp___1 = strlen(passphrase);
#line 165
    tmp___2 = EVP_des_ede3_cbc();
#line 165
    tmp___3 = PEM_write_DSAPrivateKey(fp, dsa, tmp___2, (unsigned char *)((char *)passphrase),
                                      (int )tmp___1, (pem_password_cb *)((void *)0),
                                      (void *)0);
#line 165
    if (! tmp___3) {
#line 167
      success = 0;
    }
  } else {
#line 169
    tmp___4 = PEM_write_DSAPrivateKey(fp, dsa, (EVP_CIPHER const   *)((void *)0),
                                      (unsigned char *)((void *)0), 0, (pem_password_cb *)((void *)0),
                                      (void *)0);
#line 169
    if (! tmp___4) {
#line 171
      success = 0;
    }
  }
#line 173
  fclose(fp);
#line 174
  return (success);
}
}
#line 177 "authfile.c"
int save_private_key(char const   *filename , char const   *passphrase , Key *key ,
                     char const   *comment ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 181
  switch (key->type) {
  case 0: 
#line 183
  tmp = save_private_key_rsa(filename, passphrase, key->rsa, comment);
#line 183
  return (tmp);
#line 184
  break;
  case 1: 
#line 186
  tmp___0 = save_private_key_dsa(filename, passphrase, key->dsa, comment);
#line 186
  return (tmp___0);
#line 187
  break;
  default: ;
#line 189
  break;
  }
#line 191
  return (0);
}
}
#line 200 "authfile.c"
int load_public_key_rsa(char const   *filename , RSA *pub , char **comment_return ) 
{ int fd ;
  int i ;
  off_t len ;
  Buffer buffer ;
  char *cp ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
#line 208
  fd = open(filename, 0);
#line 209
  if (fd < 0) {
#line 210
    return (0);
  }
#line 211
  len = lseek(fd, 0L, 2);
#line 212
  lseek(fd, 0L, 0);
#line 214
  buffer_init(& buffer);
#line 215
  buffer_append_space(& buffer, & cp, (unsigned int )len);
#line 217
  tmp___1 = read(fd, (void *)cp, (unsigned int )len);
#line 217
  if ((unsigned int )tmp___1 != (unsigned int )len) {
#line 218
    tmp = __errno_location();
#line 218
    tmp___0 = strerror(*tmp);
#line 218
    debug("Read from key file %.200s failed: %.100s", filename, tmp___0);
#line 220
    buffer_free(& buffer);
#line 221
    close(fd);
#line 222
    return (0);
  }
#line 224
  close(fd);
#line 227
  tmp___2 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 227
  if ((unsigned long )len < (unsigned long )(tmp___2 + 1U)) {
#line 228
    debug("Bad key file %.200s.", filename);
#line 229
    buffer_free(& buffer);
#line 230
    return (0);
  }
#line 236
  i = 0;
#line 236
  while (1) {
#line 236
    tmp___4 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 236
    if (! ((unsigned int )i < tmp___4 + 1U)) {
#line 236
      break;
    }
#line 237
    tmp___3 = buffer_get_char(& buffer);
#line 237
    if (tmp___3 != (int )((unsigned char )*("SSH PRIVATE KEY FILE FORMAT 1.1\n" + i))) {
#line 238
      debug("Bad key file %.200s.", filename);
#line 239
      buffer_free(& buffer);
#line 240
      return (0);
    }
#line 236
    i ++;
  }
#line 243
  buffer_get_char(& buffer);
#line 244
  buffer_get_int(& buffer);
#line 247
  buffer_get_int(& buffer);
#line 249
  if ((unsigned int )pub->n == (unsigned int )((void *)0)) {
#line 250
    pub->n = BN_new();
  }
#line 251
  buffer_get_bignum(& buffer, pub->n);
#line 253
  if ((unsigned int )pub->e == (unsigned int )((void *)0)) {
#line 254
    pub->e = BN_new();
  }
#line 255
  buffer_get_bignum(& buffer, pub->e);
#line 256
  if (comment_return) {
#line 257
    *comment_return = buffer_get_string(& buffer, (unsigned int *)((void *)0));
  }
#line 260
  buffer_free(& buffer);
#line 262
  return (1);
}
}
#line 265 "authfile.c"
int load_public_key(char const   *filename , Key *key , char **comment_return ) 
{ int tmp ;

  {
#line 268
  switch (key->type) {
  case 0: 
#line 270
  tmp = load_public_key_rsa(filename, key->rsa, comment_return);
#line 270
  return (tmp);
#line 271
  break;
  case 1: 
  default: ;
#line 274
  break;
  }
#line 276
  return (0);
}
}
#line 286 "authfile.c"
int load_private_key_rsa(int fd , char const   *filename , char const   *passphrase ,
                         RSA *prv , char **comment_return ) 
{ int i ;
  int check1 ;
  int check2 ;
  int cipher_type___0 ;
  off_t len ;
  Buffer buffer ;
  Buffer decrypted ;
  char *cp ;
  CipherContext cipher ;
  BN_CTX *ctx ;
  BIGNUM *aux ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  char *tmp___10 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___16 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  BIGNUM const   *tmp___23 ;
  BIGNUM const   *tmp___24 ;

  {
#line 298
  len = lseek(fd, 0L, 2);
#line 299
  lseek(fd, 0L, 0);
#line 301
  buffer_init(& buffer);
#line 302
  buffer_append_space(& buffer, & cp, (unsigned int )len);
#line 304
  tmp___1 = read(fd, (void *)cp, (unsigned int )len);
#line 304
  if ((unsigned int )tmp___1 != (unsigned int )len) {
#line 305
    tmp = __errno_location();
#line 305
    tmp___0 = strerror(*tmp);
#line 305
    debug("Read from key file %.200s failed: %.100s", filename, tmp___0);
#line 307
    buffer_free(& buffer);
#line 308
    close(fd);
#line 309
    return (0);
  }
#line 311
  close(fd);
#line 314
  tmp___2 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 314
  if ((unsigned long )len < (unsigned long )(tmp___2 + 1U)) {
#line 315
    debug("Bad key file %.200s.", filename);
#line 316
    buffer_free(& buffer);
#line 317
    return (0);
  }
#line 323
  i = 0;
#line 323
  while (1) {
#line 323
    tmp___4 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 323
    if (! ((unsigned int )i < tmp___4 + 1U)) {
#line 323
      break;
    }
#line 324
    tmp___3 = buffer_get_char(& buffer);
#line 324
    if (tmp___3 != (int )((unsigned char )*("SSH PRIVATE KEY FILE FORMAT 1.1\n" + i))) {
#line 325
      debug("Bad key file %.200s.", filename);
#line 326
      buffer_free(& buffer);
#line 327
      return (0);
    }
#line 323
    i ++;
  }
#line 330
  cipher_type___0 = buffer_get_char(& buffer);
#line 331
  buffer_get_int(& buffer);
#line 334
  buffer_get_int(& buffer);
#line 335
  prv->n = BN_new();
#line 336
  buffer_get_bignum(& buffer, prv->n);
#line 337
  prv->e = BN_new();
#line 338
  buffer_get_bignum(& buffer, prv->e);
#line 339
  if (comment_return) {
#line 340
    *comment_return = buffer_get_string(& buffer, (unsigned int *)((void *)0));
  } else {
#line 342
    tmp___5 = buffer_get_string(& buffer, (unsigned int *)((void *)0));
#line 342
    xfree((void *)tmp___5);
  }
#line 345
  tmp___7 = cipher_mask1();
#line 345
  if (((tmp___7 | 3U) & (unsigned int )(1 << cipher_type___0)) == 0U) {
#line 347
    tmp___6 = cipher_name(cipher_type___0);
#line 347
    debug("Unsupported cipher %.100s used in key file %.200s.", tmp___6, filename);
#line 349
    buffer_free(& buffer);
    goto fail;
  }
#line 353
  buffer_init(& decrypted);
#line 354
  tmp___8 = buffer_len(& buffer);
#line 354
  buffer_append_space(& decrypted, & cp, tmp___8);
#line 357
  cipher_set_key_string(& cipher, cipher_type___0, passphrase);
#line 358
  tmp___9 = buffer_len(& buffer);
#line 358
  tmp___10 = buffer_ptr(& buffer);
#line 358
  cipher_decrypt(& cipher, (unsigned char *)cp, (unsigned char const   *)((unsigned char *)tmp___10),
                 tmp___9);
#line 362
  buffer_free(& buffer);
#line 364
  check1 = buffer_get_char(& decrypted);
#line 365
  check2 = buffer_get_char(& decrypted);
#line 366
  tmp___21 = buffer_get_char(& decrypted);
#line 366
  if (check1 != tmp___21) {
    goto _L___1;
  } else {
#line 366
    tmp___22 = buffer_get_char(& decrypted);
#line 366
    if (check2 != tmp___22) {
      _L___1: /* CIL Label */ 
#line 368
      if (0) {
#line 368
        __s1_len = strlen(passphrase);
#line 368
        __s2_len = strlen("");
#line 368
        if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
          goto _L___0;
        } else {
#line 368
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 368
            if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 368
              tmp___20 = 1;
            } else {
#line 368
              if (__s2_len >= 4U) {
#line 368
                tmp___20 = 1;
              } else {
#line 368
                tmp___20 = 0;
              }
            }
          } else {
#line 368
            tmp___20 = 0;
          }
        }
#line 368
        if (tmp___20) {
#line 368
          tmp___16 = __builtin_strcmp(passphrase, "");
        } else {
#line 368
          tmp___19 = __builtin_strcmp(passphrase, "");
#line 368
          tmp___16 = tmp___19;
        }
      } else {
#line 368
        tmp___19 = __builtin_strcmp(passphrase, "");
#line 368
        tmp___16 = tmp___19;
      }
#line 368
      if (tmp___16 != 0) {
#line 369
        debug("Bad passphrase supplied for key file %.200s.", filename);
      }
#line 371
      buffer_free(& decrypted);
      fail: 
#line 373
      BN_clear_free(prv->n);
#line 374
      prv->n = (BIGNUM *)((void *)0);
#line 375
      BN_clear_free(prv->e);
#line 376
      prv->e = (BIGNUM *)((void *)0);
#line 377
      if (comment_return) {
#line 378
        xfree((void *)*comment_return);
      }
#line 379
      return (0);
    }
  }
#line 382
  prv->d = BN_new();
#line 383
  buffer_get_bignum(& decrypted, prv->d);
#line 384
  prv->iqmp = BN_new();
#line 385
  buffer_get_bignum(& decrypted, prv->iqmp);
#line 387
  prv->q = BN_new();
#line 388
  buffer_get_bignum(& decrypted, prv->q);
#line 389
  prv->p = BN_new();
#line 390
  buffer_get_bignum(& decrypted, prv->p);
#line 392
  ctx = BN_CTX_new();
#line 393
  aux = BN_new();
#line 395
  tmp___23 = BN_value_one();
#line 395
  BN_sub(aux, (BIGNUM const   *)prv->q, tmp___23);
#line 396
  prv->dmq1 = BN_new();
#line 397
  BN_div((BIGNUM *)((void *)0), prv->dmq1, (BIGNUM const   *)prv->d, (BIGNUM const   *)aux,
         ctx);
#line 399
  tmp___24 = BN_value_one();
#line 399
  BN_sub(aux, (BIGNUM const   *)prv->p, tmp___24);
#line 400
  prv->dmp1 = BN_new();
#line 401
  BN_div((BIGNUM *)((void *)0), prv->dmp1, (BIGNUM const   *)prv->d, (BIGNUM const   *)aux,
         ctx);
#line 403
  BN_clear_free(aux);
#line 404
  BN_CTX_free(ctx);
#line 406
  buffer_free(& decrypted);
#line 408
  return (1);
}
}
#line 411 "authfile.c"
int load_private_key_dsa(int fd , char const   *passphrase , Key *k , char **comment_return ) 
{ DSA *dsa ;
  BIO *in ;
  FILE *fp ;
  BIO_METHOD *tmp ;
  int tmp___0 ;

  {
#line 418
  tmp = BIO_s_file();
#line 418
  in = BIO_new(tmp);
#line 419
  if ((unsigned int )in == (unsigned int )((void *)0)) {
#line 420
    error("BIO_new failed");
#line 421
    return (0);
  }
#line 423
  fp = fdopen(fd, "r");
#line 424
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 425
    error("fdopen failed");
#line 426
    return (0);
  }
#line 428
  BIO_ctrl(in, 106, 0L, (void *)((char *)fp));
#line 429
  dsa = PEM_read_bio_DSAPrivateKey(in, (DSA **)((void *)0), (pem_password_cb *)((void *)0),
                                   (void *)((char *)passphrase));
#line 430
  if ((unsigned int )dsa == (unsigned int )((void *)0)) {
#line 431
    debug("PEM_read_bio_DSAPrivateKey failed");
  } else {
#line 434
    DSA_free(k->dsa);
#line 435
    k->dsa = dsa;
  }
#line 437
  BIO_free(in);
#line 438
  fclose(fp);
#line 439
  if (comment_return) {
#line 440
    *comment_return = xstrdup("dsa w/o comment");
  }
#line 441
  debug("read DSA private key done");
#line 445
  if ((unsigned int )dsa != (unsigned int )((void *)0)) {
#line 445
    tmp___0 = 1;
  } else {
#line 445
    tmp___0 = 0;
  }
#line 445
  return (tmp___0);
}
}
#line 448 "authfile.c"
int load_private_key(char const   *filename , char const   *passphrase , Key *key ,
                     char **comment_return ) 
{ int fd ;
  int ret ;
  struct stat st ;
  int tmp ;
  __uid_t tmp___0 ;

  {
#line 453
  ret = 0;
#line 456
  fd = open(filename, 0);
#line 457
  if (fd < 0) {
#line 458
    return (0);
  }
#line 461
  tmp = fstat(fd, & st);
#line 461
  if (tmp < 0) {
    goto _L;
  } else {
#line 461
    if (st.st_uid != 0U) {
#line 461
      tmp___0 = getuid();
#line 461
      if (st.st_uid != tmp___0) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 461
      if ((st.st_mode & 63U) != 0U) {
        _L: /* CIL Label */ 
#line 464
        close(fd);
#line 465
        error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 466
        error("@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @");
#line 467
        error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 468
        error("Bad ownership or mode(0%3.3o) for \'%s\'.", st.st_mode & 511U, filename);
#line 470
        error("It is recommended that your private key files are NOT accessible by others.");
#line 471
        return (0);
      }
    }
  }
#line 473
  switch (key->type) {
  case 0: 
#line 475
  if ((unsigned int )(key->rsa)->e != (unsigned int )((void *)0)) {
#line 476
    BN_clear_free((key->rsa)->e);
#line 477
    (key->rsa)->e = (BIGNUM *)((void *)0);
  }
#line 479
  if ((unsigned int )(key->rsa)->n != (unsigned int )((void *)0)) {
#line 480
    BN_clear_free((key->rsa)->n);
#line 481
    (key->rsa)->n = (BIGNUM *)((void *)0);
  }
#line 483
  ret = load_private_key_rsa(fd, filename, passphrase, key->rsa, comment_return);
#line 485
  break;
  case 1: 
#line 487
  ret = load_private_key_dsa(fd, passphrase, key, comment_return);
  default: ;
#line 489
  break;
  }
#line 491
  close(fd);
#line 492
  return (ret);
}
}
#line 1 "bufaux.o"
#line 412 "/usr/include/openssl/bn.h"
extern BIGNUM *BN_bin2bn(unsigned char const   *s , int len , BIGNUM *ret ) ;
#line 413
extern int BN_bn2bin(BIGNUM const   *a , unsigned char *to ) ;
#line 51 "buffer.h"
void buffer_get(Buffer *buffer , char *buf___1 , unsigned int len ) ;
#line 54
void buffer_consume(Buffer *buffer , unsigned int bytes ) ;
#line 30 "bufaux.h"
int buffer_get_bignum2(Buffer *buffer , BIGNUM *value ) ;
#line 32 "bufaux.c"
void buffer_put_bignum(Buffer *buffer , BIGNUM *value ) 
{ int bits ;
  int tmp ;
  int bin_size ;
  unsigned char *buf___1 ;
  void *tmp___0 ;
  int oi ;
  char msg[2] ;

  {
#line 35
  tmp = BN_num_bits((BIGNUM const   *)value);
#line 35
  bits = tmp;
#line 36
  bin_size = (bits + 7) / 8;
#line 37
  tmp___0 = xmalloc((unsigned int )bin_size);
#line 37
  buf___1 = (unsigned char *)tmp___0;
#line 42
  oi = BN_bn2bin((BIGNUM const   *)value, buf___1);
#line 43
  if (oi != bin_size) {
#line 44
    fatal("buffer_put_bignum: BN_bn2bin() failed: oi %d != bin_size %d", oi, bin_size);
  }
#line 48
  while (1) {
#line 48
    msg[0] = (char )(bits >> 8);
#line 48
    msg[1] = (char )bits;
#line 48
    break;
  }
#line 49
  buffer_append(buffer, (char const   *)(msg), 2U);
#line 51
  buffer_append(buffer, (char const   *)((char *)buf___1), (unsigned int )oi);
#line 53
  memset((void *)buf___1, 0, (unsigned int )bin_size);
#line 54
  xfree((void *)buf___1);
#line 55
  return;
}
}
#line 60 "bufaux.c"
int buffer_get_bignum(Buffer *buffer , BIGNUM *value ) 
{ int bits ;
  int bytes ;
  unsigned char buf___1[2] ;
  unsigned char *bin ;
  unsigned int tmp ;
  char *tmp___0 ;

  {
#line 67
  buffer_get(buffer, (char *)(buf___1), 2U);
#line 68
  bits = (int )(((unsigned long )buf___1[0] << 8) | (unsigned long )buf___1[1]);
#line 70
  bytes = (bits + 7) / 8;
#line 71
  tmp = buffer_len(buffer);
#line 71
  if (tmp < (unsigned int )bytes) {
#line 72
    fatal("buffer_get_bignum: input buffer too small");
  }
#line 73
  tmp___0 = buffer_ptr(buffer);
#line 73
  bin = (unsigned char *)tmp___0;
#line 74
  BN_bin2bn((unsigned char const   *)bin, bytes, value);
#line 75
  buffer_consume(buffer, (unsigned int )bytes);
#line 77
  return (2 + bytes);
}
}
#line 83 "bufaux.c"
void buffer_put_bignum2(Buffer *buffer , BIGNUM *value ) 
{ int bytes ;
  int tmp ;
  unsigned char *buf___1 ;
  void *tmp___0 ;
  int oi ;
  int hasnohigh ;
  int i ;
  int carry ;
  unsigned char *uc ;
  int tmp___1 ;

  {
#line 86
  tmp = BN_num_bits((BIGNUM const   *)value);
#line 86
  bytes = (tmp + 7) / 8 + 1;
#line 87
  tmp___0 = xmalloc((unsigned int )bytes);
#line 87
  buf___1 = (unsigned char *)tmp___0;
#line 89
  hasnohigh = 0;
#line 90
  *(buf___1 + 0) = (unsigned char )'\000';
#line 92
  oi = BN_bn2bin((BIGNUM const   *)value, buf___1 + 1);
#line 93
  if (oi != bytes - 1) {
#line 94
    fatal("buffer_put_bignum: BN_bn2bin() failed: oi %d != bin_size %d", oi, bytes);
  }
#line 96
  if ((int )*(buf___1 + 1) & 128) {
#line 96
    hasnohigh = 0;
  } else {
#line 96
    hasnohigh = 1;
  }
#line 97
  if (value->neg) {
#line 100
    uc = buf___1;
#line 101
    log("negativ!");
#line 102
    i = bytes - 1;
#line 102
    carry = 1;
#line 102
    while (i >= 0) {
#line 103
      *(uc + i) = (unsigned char )((int )*(uc + i) ^ 255);
#line 104
      if (carry) {
#line 105
        *(uc + i) = (unsigned char )((int )*(uc + i) + 1);
#line 105
        if (*(uc + i)) {
#line 105
          tmp___1 = 0;
        } else {
#line 105
          tmp___1 = 1;
        }
#line 105
        carry = tmp___1;
      }
#line 102
      i --;
    }
  }
#line 108
  buffer_put_string(buffer, (void const   *)(buf___1 + hasnohigh), (unsigned int )(bytes - hasnohigh));
#line 109
  memset((void *)buf___1, 0, (unsigned int )bytes);
#line 110
  xfree((void *)buf___1);
#line 111
  return;
}
}
#line 113 "bufaux.c"
int buffer_get_bignum2(Buffer *buffer , BIGNUM *value ) 
{ int len ;
  unsigned char *bin ;
  char *tmp ;

  {
#line 118
  tmp = buffer_get_string(buffer, (unsigned int *)(& len));
#line 118
  bin = (unsigned char *)tmp;
#line 119
  BN_bin2bn((unsigned char const   *)bin, len, value);
#line 120
  xfree((void *)bin);
#line 121
  return (len);
}
}
#line 127 "bufaux.c"
unsigned int buffer_get_int(Buffer *buffer ) 
{ unsigned char buf___1[4] ;

  {
#line 131
  buffer_get(buffer, (char *)(buf___1), 4U);
#line 132
  return ((unsigned int )(((((unsigned long )buf___1[0] << 24) | ((unsigned long )buf___1[1] << 16)) | ((unsigned long )buf___1[2] << 8)) | (unsigned long )buf___1[3]));
}
}
#line 138 "bufaux.c"
void buffer_put_int(Buffer *buffer , unsigned int value ) 
{ char buf___1[4] ;

  {
#line 142
  while (1) {
#line 142
    buf___1[0] = (char )(value >> 24);
#line 142
    buf___1[1] = (char )(value >> 16);
#line 142
    buf___1[2] = (char )(value >> 8);
#line 142
    buf___1[3] = (char )value;
#line 142
    break;
  }
#line 143
  buffer_append(buffer, (char const   *)(buf___1), 4U);
#line 144
  return;
}
}
#line 154 "bufaux.c"
char *buffer_get_string(Buffer *buffer , unsigned int *length_ptr ) 
{ unsigned int len ;
  char *value ;
  void *tmp ;

  {
#line 160
  len = buffer_get_int(buffer);
#line 161
  if (len > 262144U) {
#line 162
    fatal("Received packet with bad string length %d", len);
  }
#line 164
  tmp = xmalloc(len + 1U);
#line 164
  value = (char *)tmp;
#line 166
  buffer_get(buffer, value, len);
#line 168
  *(value + len) = (char)0;
#line 170
  if (length_ptr) {
#line 171
    *length_ptr = len;
  }
#line 172
  return (value);
}
}
#line 178 "bufaux.c"
void buffer_put_string(Buffer *buffer , void const   *buf___1 , unsigned int len ) 
{ 

  {
#line 181
  buffer_put_int(buffer, len);
#line 182
  buffer_append(buffer, (char const   *)buf___1, len);
#line 183
  return;
}
}
#line 184 "bufaux.c"
void buffer_put_cstring(Buffer *buffer , char const   *s ) 
{ size_t tmp ;

  {
#line 187
  tmp = strlen(s);
#line 187
  buffer_put_string(buffer, (void const   *)s, tmp);
#line 188
  return;
}
}
#line 193 "bufaux.c"
int buffer_get_char(Buffer *buffer ) 
{ char ch ;

  {
#line 197
  buffer_get(buffer, & ch, 1U);
#line 198
  return ((int )((unsigned char )ch));
}
}
#line 204 "bufaux.c"
void buffer_put_char(Buffer *buffer , int value ) 
{ char ch ;

  {
#line 207
  ch = (char )value;
#line 208
  buffer_append(buffer, (char const   *)(& ch), 1U);
#line 209
  return;
}
}
#line 1 "buffer.o"
#line 38 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                  size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 43
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 144 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 327
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 26 "xmalloc.h"
void *xrealloc(void *ptr , size_t new_size ) ;
#line 57 "buffer.h"
void buffer_consume_end(Buffer *buffer , unsigned int bytes ) ;
#line 66
void buffer_dump(Buffer *buffer ) ;
#line 25 "buffer.c"
void buffer_init(Buffer *buffer ) 
{ void *tmp ;

  {
#line 28
  buffer->alloc = 4096U;
#line 29
  tmp = xmalloc(buffer->alloc);
#line 29
  buffer->buf = (char *)tmp;
#line 30
  buffer->offset = 0U;
#line 31
  buffer->end = 0U;
#line 32
  return;
}
}
#line 36 "buffer.c"
void buffer_free(Buffer *buffer ) 
{ 

  {
#line 39
  memset((void *)buffer->buf, 0, buffer->alloc);
#line 40
  xfree((void *)buffer->buf);
#line 41
  return;
}
}
#line 48 "buffer.c"
void buffer_clear(Buffer *buffer ) 
{ 

  {
#line 51
  buffer->offset = 0U;
#line 52
  buffer->end = 0U;
#line 53
  return;
}
}
#line 57 "buffer.c"
void buffer_append(Buffer *buffer , char const   *data , unsigned int len ) 
{ char *cp ;

  {
#line 61
  buffer_append_space(buffer, & cp, len);
#line 62
  memcpy((void * __restrict  )cp, (void const   * __restrict  )data, len);
#line 63
  return;
}
}
#line 71 "buffer.c"
void buffer_append_space(Buffer *buffer , char **datap , unsigned int len ) 
{ void *tmp ;

  {
#line 75
  if (buffer->offset == buffer->end) {
#line 76
    buffer->offset = 0U;
#line 77
    buffer->end = 0U;
  }
  restart: 
#line 81
  if (buffer->end + len < buffer->alloc) {
#line 82
    *datap = buffer->buf + buffer->end;
#line 83
    buffer->end += len;
#line 84
    return;
  }
#line 90
  if (buffer->offset > buffer->alloc / 2U) {
#line 91
    memmove((void *)buffer->buf, (void const   *)(buffer->buf + buffer->offset), buffer->end - buffer->offset);
#line 93
    buffer->end -= buffer->offset;
#line 94
    buffer->offset = 0U;
    goto restart;
  }
#line 98
  buffer->alloc += len + 32768U;
#line 99
  tmp = xrealloc((void *)buffer->buf, buffer->alloc);
#line 99
  buffer->buf = (char *)tmp;
  goto restart;
}
}
#line 105 "buffer.c"
unsigned int buffer_len(Buffer *buffer ) 
{ 

  {
#line 108
  return (buffer->end - buffer->offset);
}
}
#line 113 "buffer.c"
void buffer_get(Buffer *buffer , char *buf___1 , unsigned int len ) 
{ 

  {
#line 116
  if (len > buffer->end - buffer->offset) {
#line 117
    fatal("buffer_get: trying to get more bytes than in buffer");
  }
#line 118
  memcpy((void * __restrict  )buf___1, (void const   * __restrict  )(buffer->buf + buffer->offset),
         len);
#line 119
  buffer->offset += len;
#line 120
  return;
}
}
#line 124 "buffer.c"
void buffer_consume(Buffer *buffer , unsigned int bytes ) 
{ 

  {
#line 127
  if (bytes > buffer->end - buffer->offset) {
#line 128
    fatal("buffer_consume: trying to get more bytes than in buffer");
  }
#line 129
  buffer->offset += bytes;
#line 130
  return;
}
}
#line 134 "buffer.c"
void buffer_consume_end(Buffer *buffer , unsigned int bytes ) 
{ 

  {
#line 137
  if (bytes > buffer->end - buffer->offset) {
#line 138
    fatal("buffer_consume_end: trying to get more bytes than in buffer");
  }
#line 139
  buffer->end -= bytes;
#line 140
  return;
}
}
#line 144 "buffer.c"
char *buffer_ptr(Buffer *buffer ) 
{ 

  {
#line 147
  return (buffer->buf + buffer->offset);
}
}
#line 152 "buffer.c"
void buffer_dump(Buffer *buffer ) 
{ int i ;
  unsigned char *ucp ;

  {
#line 156
  ucp = (unsigned char *)buffer->buf;
#line 158
  i = (int )buffer->offset;
#line 158
  while ((unsigned int )i < buffer->end) {
#line 159
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" %02x", *(ucp + i));
#line 158
    i ++;
  }
#line 160
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 161
  return;
}
}
#line 1 "canohost.o"
#line 114 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 128
extern  __attribute__((__nothrow__)) int getpeername(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 185
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
#line 352 "/usr/include/netdb.h"
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 631
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 637
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
#line 646
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , unsigned int __flags ) ;
#line 335 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 83
extern __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 116
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 190
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 190 "/usr/include/ctype.h"
__inline static int tolower(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
#line 193
  if (__c >= -128) {
#line 193
    if (__c < 256) {
#line 193
      tmp___1 = __ctype_tolower_loc();
#line 193
      tmp___0 = *(*tmp___1 + __c);
    } else {
#line 193
      tmp___0 = (int const   )__c;
    }
  } else {
#line 193
    tmp___0 = (int const   )__c;
  }
#line 193
  return ((int )tmp___0);
}
}
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 290
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   * __restrict  __nptr ,
                                                            char ** __restrict  __endptr ,
                                                            int __base , int __group )  __attribute__((__nonnull__(1))) ;
#line 332
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 332 "/usr/include/stdlib.h"
__inline static long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                            int __base ) 
{ long tmp ;

  {
#line 336
  tmp = __strtol_internal(__nptr, __endptr, __base, 0);
#line 336
  return (tmp);
}
}
#line 401
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 401 "/usr/include/stdlib.h"
__inline static int atoi(char const   *__nptr ) 
{ long tmp ;

  {
#line 404
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 404
  return ((int )tmp);
}
}
#line 34 "packet.h"
int packet_get_connection_in(void) ;
#line 152
void ( /* format attribute */  packet_disconnect)(char const   *fmt  , ...) ;
#line 210
int packet_connection_is_on_socket(void) ;
#line 392 "ssh.h"
char *get_remote_hostname(int socket___0 ) ;
#line 399
char const   *get_canonical_hostname(void) ;
#line 405
char const   *get_remote_ipaddr(void) ;
#line 408
int get_peer_port(int sock ) ;
#line 411
int get_remote_port(void) ;
#line 412
int get_local_port(void) ;
#line 473
void fatal_cleanup(void) ;
#line 28 "canohost.c"
char *get_remote_hostname(int socket___0 ) 
{ struct sockaddr_storage from ;
  int i ;
  socklen_t fromlen ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char name[64] ;
  char ntop[1025] ;
  char ntop2[1025] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  struct sockaddr_in6 *from6 ;
  struct sockaddr_in *from4 ;
  struct in_addr addr ;
  u_int16_t port ;
  register unsigned int __v ;
  register unsigned int __x ;
  int tmp___2 ;
  int __res ;
  __int32_t const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  unsigned char options___0[200] ;
  unsigned char *ucp ;
  char text[1024] ;
  char *cp ;
  socklen_t option_size ;
  int ipproto ;
  struct protoent *ip ;
  int tmp___20 ;
  char *tmp___21 ;

  {
#line 39
  fromlen = sizeof(from);
#line 40
  memset((void *)(& from), 0, sizeof(from));
#line 41
  tmp___1 = getpeername(socket___0, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                        (socklen_t * __restrict  )(& fromlen));
#line 41
  if (tmp___1 < 0) {
#line 42
    tmp = __errno_location();
#line 42
    tmp___0 = strerror(*tmp);
#line 42
    debug("getpeername failed: %.100s", tmp___0);
#line 43
    fatal_cleanup();
  }
#line 47
  if ((int )from.ss_family == 10) {
#line 48
    from6 = (struct sockaddr_in6 *)(& from);
#line 52
    if (*((uint32_t const   *)(& from6->sin6_addr) + 0) == 0U) {
#line 52
      if (*((uint32_t const   *)(& from6->sin6_addr) + 1) == 0U) {
#line 52
        __x = 65535U;
#line 52
        __asm__  ("rorw $8, %w0;"
                  "rorl $16, %0;"
                  "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 52
        if (*((uint32_t const   *)(& from6->sin6_addr) + 2) == (uint32_t const   )__v) {
#line 53
          from4 = (struct sockaddr_in *)(& from);
#line 57
          memcpy((void * __restrict  )(& addr), (void const   * __restrict  )((char *)(& from6->sin6_addr) + 12),
                 sizeof(addr));
#line 58
          port = from6->sin6_port;
#line 60
          memset((void *)(& from), 0, sizeof(from));
#line 62
          from4->sin_family = (unsigned short)2;
#line 63
          memcpy((void * __restrict  )(& from4->sin_addr), (void const   * __restrict  )(& addr),
                 sizeof(addr));
#line 64
          from4->sin_port = port;
        }
      }
    }
  }
#line 69
  tmp___2 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )((void *)0),
                        0U, 1U);
#line 69
  if (tmp___2 != 0) {
#line 71
    fatal("get_remote_hostname: getnameinfo NI_NUMERICHOST failed");
  }
#line 74
  tmp___19 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                         fromlen, (char * __restrict  )(name), sizeof(name), (char * __restrict  )((void *)0),
                         0U, 8U);
#line 74
  if (tmp___19 == 0) {
#line 77
    name[sizeof(name) - 1U] = (char )'\000';
#line 82
    i = 0;
#line 82
    while (name[i]) {
#line 83
      tmp___6 = __ctype_b_loc();
#line 83
      if ((int const   )*(*tmp___6 + (int )name[i]) & 256) {
#line 84
        if (sizeof(name[i]) > 1U) {
#line 84
          __res = tolower((int )name[i]);
        } else {
#line 84
          tmp___5 = __ctype_tolower_loc();
#line 84
          __res = (int )*(*tmp___5 + (int )name[i]);
        }
#line 84
        name[i] = (char )__res;
      }
#line 82
      i ++;
    }
#line 95
    memset((void *)(& hints), 0, sizeof(hints));
#line 96
    hints.ai_family = (int )from.ss_family;
#line 97
    hints.ai_socktype = 1;
#line 98
    tmp___7 = getaddrinfo((char const   * __restrict  )(name), (char const   * __restrict  )((void *)0),
                          (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 98
    if (tmp___7 != 0) {
#line 99
      log("reverse mapping checking getaddrinfo for %.700s failed - POSSIBLE BREAKIN ATTEMPT!",
          name);
#line 100
      strlcpy(name, (char const   *)(ntop), sizeof(name));
      goto check_ip_options;
    }
#line 104
    ai = aitop;
#line 104
    while (ai) {
#line 105
      tmp___8 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                            (char * __restrict  )(ntop2), sizeof(ntop2), (char * __restrict  )((void *)0),
                            0U, 1U);
#line 107
      if (tmp___8 == 0) {
#line 107
        if (0) {
#line 107
          __s1_len = strlen((char const   *)(ntop));
#line 107
          __s2_len = strlen((char const   *)(ntop2));
#line 107
          if (! ((unsigned int )((void const   *)(ntop + 1)) - (unsigned int )((void const   *)(ntop)) == 1U)) {
            goto _L___0;
          } else {
#line 107
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 107
              if (! ((unsigned int )((void const   *)(ntop2 + 1)) - (unsigned int )((void const   *)(ntop2)) == 1U)) {
#line 107
                tmp___18 = 1;
              } else {
#line 107
                if (__s2_len >= 4U) {
#line 107
                  tmp___18 = 1;
                } else {
#line 107
                  tmp___18 = 0;
                }
              }
            } else {
#line 107
              tmp___18 = 0;
            }
          }
#line 107
          if (tmp___18) {
#line 107
            tmp___14 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
          } else {
#line 107
            tmp___17 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
#line 107
            tmp___14 = tmp___17;
          }
        } else {
#line 107
          tmp___17 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
#line 107
          tmp___14 = tmp___17;
        }
#line 107
        if (tmp___14 == 0) {
#line 108
          break;
        }
      }
#line 104
      ai = ai->ai_next;
    }
#line 110
    freeaddrinfo(aitop);
#line 112
    if (! ai) {
#line 114
      log("Address %.100s maps to %.600s, but this does not map back to the address - POSSIBLE BREAKIN ATTEMPT!",
          ntop, name);
#line 116
      strlcpy(name, (char const   *)(ntop), sizeof(name));
      goto check_ip_options;
    }
  } else {
#line 122
    strlcpy(name, (char const   *)(ntop), sizeof(name));
#line 123
    log("Could not reverse map address %.100s.", name);
  }
  check_ip_options: 
#line 140
  if ((int )from.ss_family == 2) {
#line 147
    ip = getprotobyname("ip");
#line 147
    if ((unsigned int )ip != (unsigned int )((void *)0)) {
#line 148
      ipproto = ip->p_proto;
    } else {
#line 150
      ipproto = 0;
    }
#line 151
    option_size = sizeof(options___0);
#line 152
    tmp___20 = getsockopt(0, ipproto, 4, (void * __restrict  )((char *)(options___0)),
                          (socklen_t * __restrict  )(& option_size));
#line 152
    if (tmp___20 >= 0) {
#line 152
      if (option_size != 0U) {
#line 154
        cp = text;
#line 156
        ucp = options___0;
#line 156
        while (option_size > 0U) {
#line 157
          sprintf((char * __restrict  )cp, (char const   * __restrict  )" %2.2x",
                  *ucp);
#line 156
          ucp ++;
#line 156
          option_size --;
#line 156
          cp += 3;
        }
#line 158
        log("Connection from %.100s with IP options:%.800s", ntop, text);
#line 160
        packet_disconnect("Connection from %.100s with IP options:%.800s", ntop, text);
      }
    }
  }
#line 165
  tmp___21 = xstrdup((char const   *)(name));
#line 165
  return (tmp___21);
}
}
#line 177 "canohost.c"
static char *canonical_host_name  =    (char *)((void *)0);
#line 174 "canohost.c"
char const   *get_canonical_hostname(void) 
{ int tmp ;
  int tmp___0 ;

  {
#line 180
  if ((unsigned int )canonical_host_name != (unsigned int )((void *)0)) {
#line 181
    return ((char const   *)canonical_host_name);
  }
#line 184
  tmp___0 = packet_connection_is_on_socket();
#line 184
  if (tmp___0) {
#line 185
    tmp = packet_get_connection_in();
#line 185
    canonical_host_name = get_remote_hostname(tmp);
  } else {
#line 187
    canonical_host_name = xstrdup("UNKNOWN");
  }
#line 189
  return ((char const   *)canonical_host_name);
}
}
#line 200 "canohost.c"
static char *canonical_host_ip  =    (char *)((void *)0);
#line 197 "canohost.c"
char const   *get_remote_ipaddr(void) 
{ struct sockaddr_storage from ;
  socklen_t fromlen ;
  int socket___0 ;
  char ntop[1025] ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 207
  if ((unsigned int )canonical_host_ip != (unsigned int )((void *)0)) {
#line 208
    return ((char const   *)canonical_host_ip);
  }
#line 211
  tmp = packet_connection_is_on_socket();
#line 211
  if (! tmp) {
#line 212
    canonical_host_ip = xstrdup("UNKNOWN");
#line 213
    return ((char const   *)canonical_host_ip);
  }
#line 216
  socket___0 = packet_get_connection_in();
#line 219
  fromlen = sizeof(from);
#line 220
  memset((void *)(& from), 0, sizeof(from));
#line 221
  tmp___2 = getpeername(socket___0, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                        (socklen_t * __restrict  )(& fromlen));
#line 221
  if (tmp___2 < 0) {
#line 222
    tmp___0 = __errno_location();
#line 222
    tmp___1 = strerror(*tmp___0);
#line 222
    debug("getpeername failed: %.100s", tmp___1);
#line 223
    fatal_cleanup();
  }
#line 226
  tmp___3 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )((void *)0),
                        0U, 1U);
#line 226
  if (tmp___3 != 0) {
#line 228
    fatal("get_remote_hostname: getnameinfo NI_NUMERICHOST failed");
  }
#line 230
  canonical_host_ip = xstrdup((char const   *)(ntop));
#line 233
  return ((char const   *)canonical_host_ip);
}
}
#line 238 "canohost.c"
int get_sock_port(int sock , int local ) 
{ struct sockaddr_storage from ;
  socklen_t fromlen ;
  char strport[32] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 246
  fromlen = sizeof(from);
#line 247
  memset((void *)(& from), 0, sizeof(from));
#line 248
  if (local) {
#line 249
    tmp___1 = getsockname(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 249
    if (tmp___1 < 0) {
#line 250
      tmp = __errno_location();
#line 250
      tmp___0 = strerror(*tmp);
#line 250
      error("getsockname failed: %.100s", tmp___0);
#line 251
      return (0);
    }
  } else {
#line 254
    tmp___4 = getpeername(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 254
    if (tmp___4 < 0) {
#line 255
      tmp___2 = __errno_location();
#line 255
      tmp___3 = strerror(*tmp___2);
#line 255
      debug("getpeername failed: %.100s", tmp___3);
#line 256
      fatal_cleanup();
    }
  }
#line 260
  tmp___5 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )((void *)0), 0U, (char * __restrict  )(strport),
                        sizeof(strport), 2U);
#line 260
  if (tmp___5 != 0) {
#line 262
    fatal("get_sock_port: getnameinfo NI_NUMERICSERV failed");
  }
#line 263
  tmp___6 = atoi((char const   *)(strport));
#line 263
  return (tmp___6);
}
}
#line 268 "canohost.c"
int get_port(int local ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 275
  tmp = packet_connection_is_on_socket();
#line 275
  if (! tmp) {
#line 276
    return (65535);
  }
#line 279
  tmp___0 = packet_get_connection_in();
#line 279
  tmp___1 = get_sock_port(tmp___0, local);
#line 279
  return (tmp___1);
}
}
#line 282 "canohost.c"
int get_peer_port(int sock ) 
{ int tmp ;

  {
#line 285
  tmp = get_sock_port(sock, 0);
#line 285
  return (tmp);
}
}
#line 288 "canohost.c"
int get_remote_port(void) 
{ int tmp ;

  {
#line 291
  tmp = get_port(0);
#line 291
  return (tmp);
}
}
#line 294 "canohost.c"
int get_local_port(void) 
{ int tmp ;

  {
#line 297
  tmp = get_port(1);
#line 297
  return (tmp);
}
}
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned int  ) ;  */
#line 1 "channels.o"
#line 110 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  *__addr ,
                                              socklen_t __len ) ;
#line 192
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 199
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 209
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 218
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
#line 62 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 102
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 170
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 573 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 801
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 845
extern  __attribute__((__nothrow__)) int gethostname(char *__name , size_t __len )  __attribute__((__nonnull__(1))) ;
#line 640 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
#line 357 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 407
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 632
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) )  __attribute__((__nonnull__(1))) ;
#line 729
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template )  __attribute__((__nonnull__(1))) ;
#line 469 "ssh.h"
void ( /* format attribute */  verbose)(char const   *fmt  , ...) ;
#line 480
void fatal_add_cleanup(void (*proc)(void *context ) , void *context ) ;
#line 500
void set_nonblock(int fd ) ;
#line 558
int IPv4or6 ;
#line 73 "packet.h"
int packet_is_interactive(void) ;
#line 76
void packet_start(int type ) ;
#line 79
void packet_put_char(int value ) ;
#line 82
void packet_put_int(unsigned int value ) ;
#line 89
void packet_put_string(char const   *buf___1 , unsigned int len ) ;
#line 90
void packet_put_cstring(char const   *str ) ;
#line 97
void packet_send(void) ;
#line 106
void packet_read_expect(int *payload_len_ptr , int expected_type ) ;
#line 128
unsigned int packet_get_int(void) ;
#line 144
char *packet_get_string(unsigned int *length_ptr ) ;
#line 164
void ( /* format attribute */  packet_send_debug)(char const   *fmt  , ...) ;
#line 170
void packet_write_wait(void) ;
#line 179
int max_packet_size ;
#line 217
int packet_remaining(void) ;
#line 22 "uidswap.h"
void temporarily_use_uid(uid_t uid ) ;
#line 28
void restore_uid(void) ;
#line 77 "channels.h"
void channel_set_fds(int id , int rfd , int wfd , int efd , int extusage ) ;
#line 78
void channel_open(int id ) ;
#line 79
void channel_request(int id , char *service , int wantconfirm ) ;
#line 80
void channel_request_start(int id , char *service , int wantconfirm ) ;
#line 81
void channel_register_callback(int id , int mtype , channel_callback_fn *fn , void *arg ) ;
#line 82
void channel_register_cleanup(int id , channel_callback_fn *fn ) ;
#line 83
void channel_register_filter(int id , channel_filter_fn *fn ) ;
#line 84
void channel_cancel_cleanup(int id ) ;
#line 85
Channel *channel_lookup(int id ) ;
#line 87
int channel_new(char *ctype , int type , int rfd , int wfd , int efd , int window ,
                int maxpack , int extusage , char *remote_name ) ;
#line 91
void channel_input_channel_request(int type , int plen ) ;
#line 92
void channel_input_close(int type , int plen ) ;
#line 93
void channel_input_close_confirmation(int type , int plen ) ;
#line 94
void channel_input_data(int type , int plen ) ;
#line 95
void channel_input_extended_data(int type , int plen ) ;
#line 96
void channel_input_ieof(int type , int plen ) ;
#line 97
void channel_input_oclose(int type , int plen ) ;
#line 98
void channel_input_open_confirmation(int type , int plen ) ;
#line 99
void channel_input_open_failure(int type , int plen ) ;
#line 100
void channel_input_port_open(int type , int plen ) ;
#line 101
void channel_input_window_adjust(int type , int plen ) ;
#line 105
void channel_set_options(int hostname_in_open ) ;
#line 112
int channel_allocate(int type , int sock , char *remote_name ) ;
#line 115
void channel_free(int id ) ;
#line 118
void channel_prepare_select(fd_set *readset , fd_set *writeset ) ;
#line 124
void channel_after_select(fd_set *readset , fd_set *writeset ) ;
#line 127
void channel_output_poll(void) ;
#line 130
int channel_not_very_much_buffered_data(void) ;
#line 134
void channel_stop_listening(void) ;
#line 140
void channel_close_all(void) ;
#line 143
int channel_max_fd(void) ;
#line 146
int channel_still_open(void) ;
#line 153
char *channel_open_message(void) ;
#line 160
void channel_request_local_forwarding(u_short port , char const   *host , u_short host_port ,
                                      int gateway_ports ) ;
#line 170
void channel_request_remote_forwarding(u_short listen_port , char const   *host_to_connect ,
                                       u_short port_to_connect ) ;
#line 179
void channel_permit_all_opens(void) ;
#line 186
void channel_input_port_forward_request(int is_root , int gateway_ports ) ;
#line 199
char *x11_create_display_inet(int screen_number , int x11_display_offset ) ;
#line 206
void x11_input_open(int type , int plen ) ;
#line 218
void x11_request_forwarding_with_spoofing(int client_session_id , char const   *proto ,
                                          char const   *data ) ;
#line 223
void auth_request_forwarding(void) ;
#line 230
char *auth_get_socket_name(void) ;
#line 236
int auth_input_request_forwarding(struct passwd *pw ) ;
#line 239
void auth_input_open_request(int type , int plen ) ;
#line 242
int channel_connect_to(char const   *host , u_short host_port ) ;
#line 243
int x11_connect_display(void) ;
#line 83 "nchan.h"
chan_event_fn *chan_rcvd_oclose ;
#line 84
chan_event_fn *chan_read_failed ;
#line 85
chan_event_fn *chan_ibuf_empty ;
#line 88
chan_event_fn *chan_rcvd_ieof ;
#line 89
chan_event_fn *chan_write_failed ;
#line 90
chan_event_fn *chan_obuf_empty ;
#line 92
chan_event_fn *chan_delete_if_full_closed ;
#line 94
void chan_init_iostates(Channel *c ) ;
#line 95
void chan_init(void) ;
#line 49 "compat.h"
int compat13 ;
#line 50
int compat20 ;
#line 51
int datafellows ;
#line 57 "channels.c"
static Channel *channels  =    (Channel *)((void *)0);
#line 64 "channels.c"
static int channels_alloc  =    0;
#line 70 "channels.c"
static int channel_max_fd_value  =    0;
#line 73 "channels.c"
static char *channel_forwarded_auth_socket_name  =    (char *)((void *)0);
#line 74 "channels.c"
static char *channel_forwarded_auth_socket_dir  =    (char *)((void *)0);
#line 77 "channels.c"
char *x11_saved_proto  =    (char *)((void *)0);
#line 80 "channels.c"
char *x11_saved_data  =    (char *)((void *)0);
#line 81 "channels.c"
unsigned int x11_saved_data_len  =    0U;
#line 87 "channels.c"
char *x11_fake_data  =    (char *)((void *)0);
#line 88 "channels.c"
unsigned int x11_fake_data_len  ;
#line 103 "channels.c"
static ForwardPermission permitted_opens[100]  ;
#line 105 "channels.c"
static int num_permitted_opens  =    0;
#line 111 "channels.c"
static int all_opens_permitted  =    0;
#line 114 "channels.c"
static int have_hostname_in_open  =    0;
#line 118 "channels.c"
void channel_set_options(int hostname_in_open ) 
{ 

  {
#line 121
  have_hostname_in_open = hostname_in_open;
#line 122
  return;
}
}
#line 130 "channels.c"
void channel_permit_all_opens(void) 
{ 

  {
#line 133
  all_opens_permitted = 1;
#line 134
  return;
}
}
#line 138 "channels.c"
Channel *channel_lookup(int id ) 
{ Channel *c ;

  {
#line 142
  if (id < 0) {
#line 143
    log("channel_lookup: %d: bad id", id);
#line 144
    return ((Channel *)((void *)0));
  } else {
#line 142
    if (id > channels_alloc) {
#line 143
      log("channel_lookup: %d: bad id", id);
#line 144
      return ((Channel *)((void *)0));
    }
  }
#line 146
  c = channels + id;
#line 147
  if (c->type == 0) {
#line 148
    log("channel_lookup: %d: bad id: channel free", id);
#line 149
    return ((Channel *)((void *)0));
  }
#line 151
  return (c);
}
}
#line 159 "channels.c"
void channel_register_fds(Channel *c , int rfd , int wfd , int efd , int extusage ) 
{ 

  {
#line 163
  if (rfd > channel_max_fd_value) {
#line 164
    channel_max_fd_value = rfd;
  }
#line 165
  if (wfd > channel_max_fd_value) {
#line 166
    channel_max_fd_value = wfd;
  }
#line 167
  if (efd > channel_max_fd_value) {
#line 168
    channel_max_fd_value = efd;
  }
#line 171
  c->rfd = rfd;
#line 172
  c->wfd = wfd;
#line 173
  if (rfd == wfd) {
#line 173
    c->sock = rfd;
  } else {
#line 173
    c->sock = -1;
  }
#line 174
  c->efd = efd;
#line 175
  c->extended_usage = extusage;
#line 176
  if (rfd != -1) {
#line 177
    set_nonblock(rfd);
  }
#line 178
  if (wfd != -1) {
#line 179
    set_nonblock(wfd);
  }
#line 180
  if (efd != -1) {
#line 181
    set_nonblock(efd);
  }
#line 182
  return;
}
}
#line 189 "channels.c"
int channel_new(char *ctype , int type , int rfd , int wfd , int efd , int window ,
                int maxpack , int extusage , char *remote_name ) 
{ int i ;
  int found ;
  Channel *c ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 197
  if (channels_alloc == 0) {
#line 198
    chan_init();
#line 199
    channels_alloc = 10;
#line 200
    tmp = xmalloc((unsigned int )channels_alloc * sizeof(Channel ));
#line 200
    channels = (Channel *)tmp;
#line 201
    i = 0;
#line 201
    while (i < channels_alloc) {
#line 202
      (channels + i)->type = 0;
#line 201
      i ++;
    }
#line 207
    fatal_add_cleanup((void (*)(void * ))(& channel_stop_listening), (void *)0);
  }
#line 210
  found = -1;
#line 210
  i = 0;
#line 210
  while (i < channels_alloc) {
#line 211
    if ((channels + i)->type == 0) {
#line 213
      found = i;
#line 214
      break;
    }
#line 210
    i ++;
  }
#line 216
  if (found == -1) {
#line 218
    found = channels_alloc;
#line 219
    channels_alloc += 10;
#line 220
    debug("channel: expanding %d", channels_alloc);
#line 221
    tmp___0 = xrealloc((void *)channels, (unsigned int )channels_alloc * sizeof(Channel ));
#line 221
    channels = (Channel *)tmp___0;
#line 222
    i = found;
#line 222
    while (i < channels_alloc) {
#line 223
      (channels + i)->type = 0;
#line 222
      i ++;
    }
  }
#line 226
  c = channels + found;
#line 227
  buffer_init(& c->input);
#line 228
  buffer_init(& c->output);
#line 229
  buffer_init(& c->extended);
#line 230
  chan_init_iostates(c);
#line 231
  channel_register_fds(c, rfd, wfd, efd, extusage);
#line 232
  c->self = found;
#line 233
  c->type = type;
#line 234
  c->ctype = ctype;
#line 235
  c->local_window = window;
#line 236
  c->local_window_max = window;
#line 237
  c->local_consumed = 0;
#line 238
  c->local_maxpacket = maxpack;
#line 239
  c->remote_id = -1;
#line 240
  c->remote_name = remote_name;
#line 241
  c->remote_window = 0;
#line 242
  c->remote_maxpacket = 0;
#line 243
  c->cb_fn = (channel_callback_fn *)((void *)0);
#line 244
  c->cb_arg = (void *)0;
#line 245
  c->cb_event = 0;
#line 246
  c->dettach_user = (channel_callback_fn *)((void *)0);
#line 247
  c->input_filter = (channel_filter_fn *)((void *)0);
#line 248
  debug("channel %d: new [%s]", found, remote_name);
#line 249
  return (found);
}
}
#line 252 "channels.c"
int channel_allocate(int type , int sock , char *remote_name ) 
{ int tmp ;

  {
#line 255
  tmp = channel_new((char *)"", type, sock, sock, -1, 0, 0, 0, remote_name);
#line 255
  return (tmp);
}
}
#line 261 "channels.c"
void channel_close_fds(Channel *c ) 
{ 

  {
#line 264
  if (c->sock != -1) {
#line 265
    close(c->sock);
#line 266
    c->sock = -1;
  }
#line 268
  if (c->rfd != -1) {
#line 269
    close(c->rfd);
#line 270
    c->rfd = -1;
  }
#line 272
  if (c->wfd != -1) {
#line 273
    close(c->wfd);
#line 274
    c->wfd = -1;
  }
#line 276
  if (c->efd != -1) {
#line 277
    close(c->efd);
#line 278
    c->efd = -1;
  }
#line 280
  return;
}
}
#line 284 "channels.c"
void channel_free(int id ) 
{ Channel *c ;
  Channel *tmp ;
  char *tmp___0 ;

  {
#line 287
  tmp = channel_lookup(id);
#line 287
  c = tmp;
#line 288
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 289
    packet_disconnect("channel free: bad local channel %d", id);
  }
#line 290
  tmp___0 = channel_open_message();
#line 290
  debug("channel_free: channel %d: status: %s", id, tmp___0);
#line 291
  if ((unsigned int )c->dettach_user != (unsigned int )((void *)0)) {
#line 292
    debug("channel_free: channel %d: dettaching channel user", id);
#line 293
    (*(c->dettach_user))(c->self, (void *)0);
  }
#line 295
  if (c->sock != -1) {
#line 296
    shutdown(c->sock, 2);
  }
#line 297
  channel_close_fds(c);
#line 298
  buffer_free(& c->input);
#line 299
  buffer_free(& c->output);
#line 300
  buffer_free(& c->extended);
#line 301
  c->type = 0;
#line 302
  if (c->remote_name) {
#line 303
    xfree((void *)c->remote_name);
#line 304
    c->remote_name = (char *)((void *)0);
  }
#line 306
  return;
}
}
#line 317 "channels.c"
chan_fn *channel_pre[11]  ;
#line 318 "channels.c"
chan_fn *channel_post[11]  ;
#line 320 "channels.c"
void channel_pre_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 323
  __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 324
  return;
}
}
#line 326 "channels.c"
void channel_pre_open_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 329
  tmp = buffer_len(& c->input);
#line 329
  if (tmp < (unsigned int )max_packet_size) {
#line 330
    __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 331
  tmp___0 = buffer_len(& c->output);
#line 331
  if (tmp___0 > 0U) {
#line 332
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 333
  return;
}
}
#line 335 "channels.c"
void channel_pre_open_15(Channel *c , fd_set *readset , fd_set *writeset ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 339
  if (c->istate == 1) {
#line 340
    tmp = buffer_len(& c->input);
#line 340
    if (tmp < (unsigned int )max_packet_size) {
#line 341
      __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
  }
#line 342
  if (c->ostate == 16) {
    goto _L;
  } else {
#line 342
    if (c->ostate == 32) {
      _L: /* CIL Label */ 
#line 344
      tmp___0 = buffer_len(& c->output);
#line 344
      if (tmp___0 > 0U) {
#line 345
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      } else {
#line 346
        if (c->ostate == 32) {
#line 347
          (*chan_obuf_empty)(c);
        }
      }
    }
  }
#line 350
  return;
}
}
#line 352 "channels.c"
void channel_pre_open_20(Channel *c , fd_set *readset , fd_set *writeset ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 355
  if (c->istate == 1) {
#line 355
    if (c->remote_window > 0) {
#line 355
      tmp = buffer_len(& c->input);
#line 355
      if (tmp < (unsigned int )c->remote_window) {
#line 358
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->rfd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->rfd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
  }
#line 359
  if (c->ostate == 16) {
    goto _L;
  } else {
#line 359
    if (c->ostate == 32) {
      _L: /* CIL Label */ 
#line 361
      tmp___0 = buffer_len(& c->output);
#line 361
      if (tmp___0 > 0U) {
#line 362
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->wfd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->wfd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      } else {
#line 363
        if (c->ostate == 32) {
#line 364
          (*chan_obuf_empty)(c);
        }
      }
    }
  }
#line 368
  if (c->efd != -1) {
#line 369
    if (c->extended_usage == 2) {
#line 369
      tmp___2 = buffer_len(& c->extended);
#line 369
      if (tmp___2 > 0U) {
#line 371
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 372
      if (c->extended_usage == 1) {
#line 372
        tmp___1 = buffer_len(& c->extended);
#line 372
        if (tmp___1 < (unsigned int )c->remote_window) {
#line 374
          __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        }
      }
    }
  }
#line 376
  return;
}
}
#line 378 "channels.c"
void channel_pre_input_draining(Channel *c , fd_set *readset , fd_set *writeset ) 
{ unsigned int tmp ;

  {
#line 381
  tmp = buffer_len(& c->input);
#line 381
  if (tmp == 0U) {
#line 382
    packet_start(24);
#line 383
    packet_put_int((unsigned int )c->remote_id);
#line 384
    packet_send();
#line 385
    c->type = 5;
#line 386
    debug("Closing channel %d after input drain.", c->self);
  }
#line 388
  return;
}
}
#line 390 "channels.c"
void channel_pre_output_draining(Channel *c , fd_set *readset , fd_set *writeset ) 
{ unsigned int tmp ;

  {
#line 393
  tmp = buffer_len(& c->output);
#line 393
  if (tmp == 0U) {
#line 394
    channel_free(c->self);
  } else {
#line 396
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 397
  return;
}
}
#line 407 "channels.c"
int x11_open_helper(Channel *c ) 
{ unsigned char *ucp ;
  unsigned int proto_len ;
  unsigned int data_len ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 414
  tmp = buffer_len(& c->output);
#line 414
  if (tmp < 12U) {
#line 415
    return (0);
  }
#line 418
  tmp___0 = buffer_ptr(& c->output);
#line 418
  ucp = (unsigned char *)tmp___0;
#line 419
  if ((int )*(ucp + 0) == 66) {
#line 420
    proto_len = (unsigned int )(256 * (int )*(ucp + 6) + (int )*(ucp + 7));
#line 421
    data_len = (unsigned int )(256 * (int )*(ucp + 8) + (int )*(ucp + 9));
  } else {
#line 422
    if ((int )*(ucp + 0) == 108) {
#line 423
      proto_len = (unsigned int )((int )*(ucp + 6) + 256 * (int )*(ucp + 7));
#line 424
      data_len = (unsigned int )((int )*(ucp + 8) + 256 * (int )*(ucp + 9));
    } else {
#line 426
      debug("Initial X11 packet contains bad byte order byte: 0x%x", *(ucp + 0));
#line 428
      return (-1);
    }
  }
#line 432
  tmp___1 = buffer_len(& c->output);
#line 432
  if (tmp___1 < (12U + ((proto_len + 3U) & 4294967292U)) + ((data_len + 3U) & 4294967292U)) {
#line 434
    return (0);
  }
#line 437
  tmp___2 = strlen((char const   *)x11_saved_proto);
#line 437
  if (proto_len != tmp___2) {
#line 439
    debug("X11 connection uses different authentication protocol.");
#line 440
    return (-1);
  } else {
#line 437
    tmp___3 = memcmp((void const   *)(ucp + 12), (void const   *)x11_saved_proto,
                     proto_len);
#line 437
    if (tmp___3 != 0) {
#line 439
      debug("X11 connection uses different authentication protocol.");
#line 440
      return (-1);
    }
  }
#line 443
  if (data_len != x11_fake_data_len) {
#line 446
    debug("X11 auth data does not match fake data.");
#line 447
    return (-1);
  } else {
#line 443
    tmp___4 = memcmp((void const   *)((ucp + 12) + ((proto_len + 3U) & 4294967292U)),
                     (void const   *)x11_fake_data, x11_fake_data_len);
#line 443
    if (tmp___4 != 0) {
#line 446
      debug("X11 auth data does not match fake data.");
#line 447
      return (-1);
    }
  }
#line 450
  if (x11_fake_data_len != x11_saved_data_len) {
#line 451
    error("X11 fake_data_len %d != saved_data_len %d", x11_fake_data_len, x11_saved_data_len);
#line 453
    return (-1);
  }
#line 460
  memcpy((void * __restrict  )((ucp + 12) + ((proto_len + 3U) & 4294967292U)), (void const   * __restrict  )x11_saved_data,
         x11_saved_data_len);
#line 462
  return (1);
}
}
#line 465 "channels.c"
void channel_pre_x11_open_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int ret ;
  int tmp ;

  {
#line 468
  tmp = x11_open_helper(c);
#line 468
  ret = tmp;
#line 469
  if (ret == 1) {
#line 471
    c->type = 4;
#line 472
    channel_pre_open_13(c, readset, writeset);
  } else {
#line 473
    if (ret == -1) {
#line 478
      log("X11 connection rejected because of wrong authentication.\r\n");
#line 479
      buffer_clear(& c->input);
#line 480
      buffer_clear(& c->output);
#line 481
      close(c->sock);
#line 482
      c->sock = -1;
#line 483
      c->type = 5;
#line 484
      packet_start(24);
#line 485
      packet_put_int((unsigned int )c->remote_id);
#line 486
      packet_send();
    }
  }
#line 488
  return;
}
}
#line 490 "channels.c"
void channel_pre_x11_open(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int ret ;
  int tmp ;

  {
#line 493
  tmp = x11_open_helper(c);
#line 493
  ret = tmp;
#line 494
  if (ret == 1) {
#line 495
    c->type = 4;
#line 496
    if (compat20) {
#line 497
      channel_pre_open_20(c, readset, writeset);
    } else {
#line 499
      channel_pre_open_15(c, readset, writeset);
    }
  } else {
#line 500
    if (ret == -1) {
#line 501
      debug("X11 rejected %d i%d/o%d", c->self, c->istate, c->ostate);
#line 502
      (*chan_read_failed)(c);
#line 503
      (*chan_write_failed)(c);
#line 504
      debug("X11 closed %d i%d/o%d", c->self, c->istate, c->ostate);
    }
  }
#line 506
  return;
}
}
#line 509 "channels.c"
void channel_post_x11_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ struct sockaddr addr ;
  int newsock ;
  int newch ;
  socklen_t addrlen ;
  char buf___1[16384] ;
  char *remote_hostname ;
  int remote_port ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  register char __result ;

  {
#line 518
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 518
  if (__result) {
#line 519
    debug("X11 connection requested.");
#line 520
    addrlen = sizeof(addr);
#line 521
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 522
    if (newsock < 0) {
#line 523
      tmp = __errno_location();
#line 523
      tmp___0 = strerror(*tmp);
#line 523
      error("accept: %.100s", tmp___0);
#line 524
      return;
    }
#line 526
    remote_hostname = get_remote_hostname(newsock);
#line 527
    remote_port = get_peer_port(newsock);
#line 528
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"X11 connection from %.200s port %d",
             remote_hostname, remote_port);
#line 531
    tmp___1 = xstrdup((char const   *)(buf___1));
#line 531
    newch = channel_new((char *)"x11", 3, newsock, newsock, -1, c->local_window_max,
                        c->local_maxpacket, 0, tmp___1);
#line 535
    if (compat20) {
#line 536
      packet_start(90);
#line 537
      packet_put_cstring("x11");
#line 538
      packet_put_int((unsigned int )newch);
#line 539
      packet_put_int((unsigned int )c->local_window_max);
#line 540
      packet_put_int((unsigned int )c->local_maxpacket);
#line 542
      packet_put_cstring((char const   *)remote_hostname);
#line 543
      if (datafellows & 8) {
#line 544
        debug("ssh2 x11 bug compat mode");
      } else {
#line 546
        packet_put_int((unsigned int )remote_port);
      }
#line 548
      packet_send();
    } else {
#line 550
      packet_start(27);
#line 551
      packet_put_int((unsigned int )newch);
#line 552
      if (have_hostname_in_open) {
#line 553
        tmp___2 = strlen((char const   *)(buf___1));
#line 553
        packet_put_string((char const   *)(buf___1), tmp___2);
      }
#line 554
      packet_send();
    }
#line 556
    xfree((void *)remote_hostname);
  }
#line 558
  return;
}
}
#line 563 "channels.c"
void channel_post_port_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ struct sockaddr addr ;
  int newsock ;
  int newch ;
  socklen_t addrlen ;
  char buf___1[1024] ;
  char *remote_hostname ;
  int remote_port ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  register char __result ;

  {
#line 572
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 572
  if (__result) {
#line 573
    debug("Connection to port %d forwarding to %.100s port %d requested.", c->listening_port,
          c->path, c->host_port);
#line 576
    addrlen = sizeof(addr);
#line 577
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 578
    if (newsock < 0) {
#line 579
      tmp = __errno_location();
#line 579
      tmp___0 = strerror(*tmp);
#line 579
      error("accept: %.100s", tmp___0);
#line 580
      return;
    }
#line 582
    remote_hostname = get_remote_hostname(newsock);
#line 583
    remote_port = get_peer_port(newsock);
#line 584
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"listen port %d for %.100s port %d, connect from %.200s port %d",
             c->listening_port, c->path, c->host_port, remote_hostname, remote_port);
#line 589
    tmp___1 = xstrdup((char const   *)(buf___1));
#line 589
    newch = channel_new((char *)"direct-tcpip", 3, newsock, newsock, -1, c->local_window_max,
                        c->local_maxpacket, 0, tmp___1);
#line 593
    if (compat20) {
#line 594
      packet_start(90);
#line 595
      packet_put_cstring("direct-tcpip");
#line 596
      packet_put_int((unsigned int )newch);
#line 597
      packet_put_int((unsigned int )c->local_window_max);
#line 598
      packet_put_int((unsigned int )c->local_maxpacket);
#line 600
      tmp___2 = strlen((char const   *)(c->path));
#line 600
      packet_put_string((char const   *)(c->path), tmp___2);
#line 601
      packet_put_int((unsigned int )c->host_port);
#line 603
      packet_put_cstring((char const   *)remote_hostname);
#line 604
      packet_put_int((unsigned int )remote_port);
#line 605
      packet_send();
    } else {
#line 607
      packet_start(29);
#line 608
      packet_put_int((unsigned int )newch);
#line 609
      tmp___3 = strlen((char const   *)(c->path));
#line 609
      packet_put_string((char const   *)(c->path), tmp___3);
#line 610
      packet_put_int((unsigned int )c->host_port);
#line 611
      if (have_hostname_in_open) {
#line 612
        tmp___4 = strlen((char const   *)(buf___1));
#line 612
        packet_put_string((char const   *)(buf___1), tmp___4);
      }
#line 614
      packet_send();
    }
#line 616
    xfree((void *)remote_hostname);
  }
#line 618
  return;
}
}
#line 624 "channels.c"
void channel_post_auth_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ struct sockaddr addr ;
  int newsock ;
  int newch ;
  socklen_t addrlen ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  register char __result ;

  {
#line 631
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 631
  if (__result) {
#line 632
    addrlen = sizeof(addr);
#line 633
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 634
    if (newsock < 0) {
#line 635
      tmp = __errno_location();
#line 635
      tmp___0 = strerror(*tmp);
#line 635
      error("accept from auth socket: %.100s", tmp___0);
#line 636
      return;
    }
#line 638
    tmp___1 = xstrdup("accepted auth socket");
#line 638
    newch = channel_allocate(3, newsock, tmp___1);
#line 640
    packet_start(31);
#line 641
    packet_put_int((unsigned int )newch);
#line 642
    packet_send();
  }
#line 644
  return;
}
}
#line 646 "channels.c"
int channel_handle_rfd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char buf___1[16384] ;
  int len ;
  int *tmp ;
  int *tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  register char __result ;

  {
#line 653
  if (c->rfd != -1) {
#line 653
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->rfd % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )c->rfd / (8U * sizeof(__fd_mask ))]): "cc");
#line 653
    if (__result) {
#line 654
      len = read(c->rfd, (void *)(buf___1), sizeof(buf___1));
#line 655
      if (len < 0) {
#line 655
        tmp = __errno_location();
#line 655
        if (*tmp == 4) {
#line 656
          return (1);
        } else {
#line 655
          tmp___0 = __errno_location();
#line 655
          if (*tmp___0 == 11) {
#line 656
            return (1);
          }
        }
      }
#line 657
      if (len <= 0) {
#line 658
        debug("channel %d: read<=0 rfd %d len %d", c->self, c->rfd, len);
#line 660
        if (compat13) {
#line 661
          tmp___1 = buffer_len(& c->output);
#line 661
          buffer_consume(& c->output, tmp___1);
#line 662
          c->type = 8;
#line 663
          debug("Channel %d status set to input draining.", c->self);
        } else {
#line 665
          (*chan_read_failed)(c);
        }
#line 667
        return (-1);
      }
#line 669
      if ((unsigned int )c->input_filter != (unsigned int )((void *)0)) {
#line 670
        tmp___2 = (*(c->input_filter))(c, buf___1, len);
#line 670
        if (tmp___2 == -1) {
#line 671
          debug("filter stops channel %d", c->self);
#line 672
          (*chan_read_failed)(c);
        }
      } else {
#line 675
        buffer_append(& c->input, (char const   *)(buf___1), (unsigned int )len);
      }
    }
  }
#line 678
  return (1);
}
}
#line 680 "channels.c"
int channel_handle_wfd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  unsigned int tmp___3 ;
  register char __result ;
  unsigned int tmp___4 ;

  {
#line 687
  if (c->wfd != -1) {
#line 687
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->wfd % (8U * sizeof(__fd_mask ))),
                         "m" (writeset->__fds_bits[(unsigned int )c->wfd / (8U * sizeof(__fd_mask ))]): "cc");
#line 687
    if (__result) {
#line 687
      tmp___4 = buffer_len(& c->output);
#line 687
      if (tmp___4 > 0U) {
#line 689
        tmp = buffer_len(& c->output);
#line 689
        tmp___0 = buffer_ptr(& c->output);
#line 689
        len = write(c->wfd, (void const   *)tmp___0, tmp);
#line 691
        if (len < 0) {
#line 691
          tmp___1 = __errno_location();
#line 691
          if (*tmp___1 == 4) {
#line 692
            return (1);
          } else {
#line 691
            tmp___2 = __errno_location();
#line 691
            if (*tmp___2 == 11) {
#line 692
              return (1);
            }
          }
        }
#line 693
        if (len <= 0) {
#line 694
          if (compat13) {
#line 695
            tmp___3 = buffer_len(& c->output);
#line 695
            buffer_consume(& c->output, tmp___3);
#line 696
            debug("Channel %d status set to input draining.", c->self);
#line 697
            c->type = 8;
          } else {
#line 699
            (*chan_write_failed)(c);
          }
#line 701
          return (-1);
        }
#line 703
        buffer_consume(& c->output, (unsigned int )len);
#line 704
        if (compat20) {
#line 704
          if (len > 0) {
#line 705
            c->local_consumed += len;
          }
        }
      }
    }
  }
#line 708
  return (1);
}
}
#line 710 "channels.c"
int channel_handle_efd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char buf___1[16384] ;
  int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  register char __result ;
  register char __result___0 ;
  unsigned int tmp___1 ;

  {
#line 717
  if (c->efd != -1) {
#line 719
    if (c->extended_usage == 2) {
#line 719
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))),
                           "m" (writeset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "cc");
#line 719
      if (__result___0) {
#line 719
        tmp___1 = buffer_len(& c->extended);
#line 719
        if (tmp___1 > 0U) {
#line 721
          tmp = buffer_len(& c->extended);
#line 721
          tmp___0 = buffer_ptr(& c->extended);
#line 721
          len = write(c->efd, (void const   *)tmp___0, tmp);
#line 723
          debug("channel %d: written %d to efd %d", c->self, len, c->efd);
#line 725
          if (len > 0) {
#line 726
            buffer_consume(& c->extended, (unsigned int )len);
#line 727
            c->local_consumed += len;
          }
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 730
      if (c->extended_usage == 1) {
#line 730
        __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))),
                             "m" (readset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "cc");
#line 730
        if (__result) {
#line 731
          len = read(c->efd, (void *)(buf___1), sizeof(buf___1));
#line 732
          debug("channel %d: read %d from efd %d", c->self, len, c->efd);
#line 734
          if (len == 0) {
#line 735
            debug("channel %d: closing efd %d", c->self, c->efd);
#line 737
            close(c->efd);
#line 738
            c->efd = -1;
          } else {
#line 739
            if (len > 0) {
#line 740
              buffer_append(& c->extended, (char const   *)(buf___1), (unsigned int )len);
            }
          }
        }
      }
    }
  }
#line 743
  return (1);
}
}
#line 745 "channels.c"
int channel_check_window(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 748
  if (! (c->flags & 3)) {
#line 748
    if (c->local_window < c->local_window_max / 2) {
#line 748
      if (c->local_consumed > 0) {
#line 751
        packet_start(93);
#line 752
        packet_put_int((unsigned int )c->remote_id);
#line 753
        packet_put_int((unsigned int )c->local_consumed);
#line 754
        packet_send();
#line 755
        debug("channel %d: window %d sent adjust %d", c->self, c->local_window, c->local_consumed);
#line 758
        c->local_window += c->local_consumed;
#line 759
        c->local_consumed = 0;
      }
    }
  }
#line 761
  return (1);
}
}
#line 764 "channels.c"
void channel_post_open_1(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 767
  channel_handle_rfd(c, readset, writeset);
#line 768
  channel_handle_wfd(c, readset, writeset);
#line 769
  return;
}
}
#line 771 "channels.c"
void channel_post_open_2(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 774
  channel_handle_rfd(c, readset, writeset);
#line 775
  channel_handle_wfd(c, readset, writeset);
#line 776
  channel_handle_efd(c, readset, writeset);
#line 777
  channel_check_window(c, readset, writeset);
#line 778
  return;
}
}
#line 780 "channels.c"
void channel_post_output_drain_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  register char __result ;
  unsigned int tmp___2 ;

  {
#line 785
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 785
  if (__result) {
#line 785
    tmp___2 = buffer_len(& c->output);
#line 785
    if (tmp___2 > 0U) {
#line 786
      tmp = buffer_len(& c->output);
#line 786
      tmp___0 = buffer_ptr(& c->output);
#line 786
      len = write(c->sock, (void const   *)tmp___0, tmp);
#line 788
      if (len <= 0) {
#line 789
        tmp___1 = buffer_len(& c->output);
#line 789
        buffer_consume(& c->output, tmp___1);
      } else {
#line 791
        buffer_consume(& c->output, (unsigned int )len);
      }
    }
  }
#line 793
  return;
}
}
#line 795 "channels.c"
void channel_handler_init_20(void) 
{ 

  {
#line 798
  channel_pre[4] = & channel_pre_open_20;
#line 799
  channel_pre[7] = & channel_pre_x11_open;
#line 800
  channel_pre[2] = & channel_pre_listener;
#line 801
  channel_pre[1] = & channel_pre_listener;
#line 803
  channel_post[4] = & channel_post_open_2;
#line 804
  channel_post[2] = & channel_post_port_listener;
#line 805
  channel_post[1] = & channel_post_x11_listener;
#line 806
  return;
}
}
#line 808 "channels.c"
void channel_handler_init_13(void) 
{ 

  {
#line 811
  channel_pre[4] = & channel_pre_open_13;
#line 812
  channel_pre[7] = & channel_pre_x11_open_13;
#line 813
  channel_pre[1] = & channel_pre_listener;
#line 814
  channel_pre[2] = & channel_pre_listener;
#line 815
  channel_pre[6] = & channel_pre_listener;
#line 816
  channel_pre[8] = & channel_pre_input_draining;
#line 817
  channel_pre[9] = & channel_pre_output_draining;
#line 819
  channel_post[4] = & channel_post_open_1;
#line 820
  channel_post[1] = & channel_post_x11_listener;
#line 821
  channel_post[2] = & channel_post_port_listener;
#line 822
  channel_post[6] = & channel_post_auth_listener;
#line 823
  channel_post[9] = & channel_post_output_drain_13;
#line 824
  return;
}
}
#line 826 "channels.c"
void channel_handler_init_15(void) 
{ 

  {
#line 829
  channel_pre[4] = & channel_pre_open_15;
#line 830
  channel_pre[7] = & channel_pre_x11_open;
#line 831
  channel_pre[1] = & channel_pre_listener;
#line 832
  channel_pre[2] = & channel_pre_listener;
#line 833
  channel_pre[6] = & channel_pre_listener;
#line 835
  channel_post[1] = & channel_post_x11_listener;
#line 836
  channel_post[2] = & channel_post_port_listener;
#line 837
  channel_post[6] = & channel_post_auth_listener;
#line 838
  channel_post[4] = & channel_post_open_1;
#line 839
  return;
}
}
#line 841 "channels.c"
void channel_handler_init(void) 
{ int i ;

  {
#line 845
  i = 0;
#line 845
  while (i < 11) {
#line 846
    channel_pre[i] = (chan_fn *)((void *)0);
#line 847
    channel_post[i] = (chan_fn *)((void *)0);
#line 845
    i ++;
  }
#line 849
  if (compat20) {
#line 850
    channel_handler_init_20();
  } else {
#line 851
    if (compat13) {
#line 852
      channel_handler_init_13();
    } else {
#line 854
      channel_handler_init_15();
    }
  }
#line 855
  return;
}
}
#line 860
void channel_handler(chan_fn **ftab , fd_set *readset , fd_set *writeset ) ;
#line 860 "channels.c"
static int did_init  =    0;
#line 857 "channels.c"
void channel_handler(chan_fn **ftab , fd_set *readset , fd_set *writeset ) 
{ int i ;
  Channel *c ;

  {
#line 864
  if (! did_init) {
#line 865
    channel_handler_init();
#line 866
    did_init = 1;
  }
#line 868
  i = 0;
#line 868
  while (i < channels_alloc) {
#line 869
    c = channels + i;
#line 870
    if (c->type == 0) {
      goto __Cont;
    }
#line 872
    if ((unsigned int )*(ftab + c->type) == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 874
    (*(*(ftab + c->type)))(c, readset, writeset);
#line 875
    (*chan_delete_if_full_closed)(c);
    __Cont: /* CIL Label */ 
#line 868
    i ++;
  }
#line 877
  return;
}
}
#line 879 "channels.c"
void channel_prepare_select(fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 882
  channel_handler(channel_pre, readset, writeset);
#line 883
  return;
}
}
#line 885 "channels.c"
void channel_after_select(fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 888
  channel_handler(channel_post, readset, writeset);
#line 889
  return;
}
}
#line 893 "channels.c"
void channel_output_poll(void) 
{ int len ;
  int i ;
  Channel *c ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;

  {
#line 899
  i = 0;
#line 899
  while (i < channels_alloc) {
#line 900
    c = channels + i;
#line 903
    if (compat13) {
#line 904
      if (c->type != 4) {
#line 904
        if (c->type != 8) {
          goto __Cont;
        }
      }
    } else {
#line 908
      if (c->type != 4) {
        goto __Cont;
      }
#line 910
      if (c->istate != 1) {
#line 910
        if (c->istate != 2) {
          goto __Cont;
        }
      }
    }
#line 914
    if (compat20) {
#line 914
      if (c->flags & 3) {
#line 916
        debug("channel: %d: no data after CLOSE", c->self);
        goto __Cont;
      }
    }
#line 921
    tmp = buffer_len(& c->input);
#line 921
    len = (int )tmp;
#line 922
    if (len > 0) {
#line 924
      if (compat20) {
#line 925
        if (len > c->remote_window) {
#line 926
          len = c->remote_window;
        }
#line 927
        if (len > c->remote_maxpacket) {
#line 928
          len = c->remote_maxpacket;
        }
      } else {
#line 930
        tmp___0 = packet_is_interactive();
#line 930
        if (tmp___0) {
#line 931
          if (len > 1024) {
#line 932
            len = 512;
          }
        } else {
#line 935
          if (len > max_packet_size / 2) {
#line 936
            len = max_packet_size / 2;
          }
        }
      }
#line 939
      if (len > 0) {
#line 940
        if (compat20) {
#line 940
          tmp___1 = 94;
        } else {
#line 940
          tmp___1 = 23;
        }
#line 940
        packet_start(tmp___1);
#line 942
        packet_put_int((unsigned int )c->remote_id);
#line 943
        tmp___2 = buffer_ptr(& c->input);
#line 943
        packet_put_string((char const   *)tmp___2, (unsigned int )len);
#line 944
        packet_send();
#line 945
        buffer_consume(& c->input, (unsigned int )len);
#line 946
        c->remote_window -= len;
      }
    } else {
#line 948
      if (c->istate == 2) {
#line 949
        if (compat13) {
#line 950
          fatal("cannot happen: istate == INPUT_WAIT_DRAIN for proto 1.3");
        }
#line 955
        (*chan_ibuf_empty)(c);
      }
    }
#line 958
    if (compat20) {
#line 958
      if (c->remote_window > 0) {
#line 958
        tmp___4 = buffer_len(& c->extended);
#line 958
        len = (int )tmp___4;
#line 958
        if (len > 0) {
#line 958
          if (c->extended_usage == 1) {
#line 962
            if (len > c->remote_window) {
#line 963
              len = c->remote_window;
            }
#line 964
            if (len > c->remote_maxpacket) {
#line 965
              len = c->remote_maxpacket;
            }
#line 966
            packet_start(95);
#line 967
            packet_put_int((unsigned int )c->remote_id);
#line 968
            packet_put_int(1U);
#line 969
            tmp___3 = buffer_ptr(& c->extended);
#line 969
            packet_put_string((char const   *)tmp___3, (unsigned int )len);
#line 970
            packet_send();
#line 971
            buffer_consume(& c->extended, (unsigned int )len);
#line 972
            c->remote_window -= len;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 899
    i ++;
  }
#line 975
  return;
}
}
#line 983 "channels.c"
void channel_input_data(int type , int plen ) 
{ int id ;
  char *data ;
  unsigned int data_len ;
  Channel *c ;
  unsigned int tmp ;
  int _len ;
  int tmp___0 ;
  int _p ;
  int _e ;

  {
#line 992
  tmp = packet_get_int();
#line 992
  id = (int )tmp;
#line 993
  c = channel_lookup(id);
#line 994
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 995
    packet_disconnect("Received data for nonexistent channel %d.", id);
  }
#line 998
  if (c->type != 4) {
#line 998
    if (c->type != 7) {
#line 1000
      return;
    }
  }
#line 1003
  if (! compat13) {
#line 1003
    if (c->ostate != 16) {
#line 1004
      return;
    }
  }
#line 1007
  data = packet_get_string(& data_len);
#line 1008
  while (1) {
#line 1008
    tmp___0 = packet_remaining();
#line 1008
    _len = tmp___0;
#line 1008
    if (_len > 0) {
#line 1008
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1008);
#line 1008
      packet_disconnect("Packet integrity error.");
    }
#line 1008
    break;
  }
#line 1010
  if (compat20) {
#line 1011
    if (data_len > (unsigned int )c->local_maxpacket) {
#line 1012
      log("channel %d: rcvd big packet %d, maxpack %d", c->self, data_len, c->local_maxpacket);
    }
#line 1015
    if (data_len > (unsigned int )c->local_window) {
#line 1016
      log("channel %d: rcvd too much data %d, win %d", c->self, data_len, c->local_window);
#line 1018
      xfree((void *)data);
#line 1019
      return;
    }
#line 1021
    c->local_window = (int )((unsigned int )c->local_window - data_len);
  } else {
#line 1023
    while (1) {
#line 1023
      _p = plen;
#line 1023
      _e = (int )(8U + data_len);
#line 1023
      if (_p != _e) {
#line 1023
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1023);
#line 1023
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1023
      break;
    }
  }
#line 1025
  buffer_append(& c->output, (char const   *)data, data_len);
#line 1026
  xfree((void *)data);
#line 1027
  return;
}
}
#line 1028 "channels.c"
void channel_input_extended_data(int type , int plen ) 
{ int id ;
  int tcode ;
  char *data ;
  unsigned int data_len ;
  Channel *c ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1038
  tmp = packet_get_int();
#line 1038
  id = (int )tmp;
#line 1039
  c = channel_lookup(id);
#line 1041
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1042
    packet_disconnect("Received extended_data for bad channel %d.", id);
  }
#line 1043
  if (c->type != 4) {
#line 1044
    log("channel %d: ext data for non open", id);
#line 1045
    return;
  }
#line 1047
  tmp___0 = packet_get_int();
#line 1047
  tcode = (int )tmp___0;
#line 1048
  if (c->efd == -1) {
#line 1051
    log("channel %d: bad ext data", c->self);
#line 1052
    return;
  } else {
#line 1048
    if (c->extended_usage != 2) {
#line 1051
      log("channel %d: bad ext data", c->self);
#line 1052
      return;
    } else {
#line 1048
      if (tcode != 1) {
#line 1051
        log("channel %d: bad ext data", c->self);
#line 1052
        return;
      }
    }
  }
#line 1054
  data = packet_get_string(& data_len);
#line 1055
  while (1) {
#line 1055
    tmp___1 = packet_remaining();
#line 1055
    _len = tmp___1;
#line 1055
    if (_len > 0) {
#line 1055
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1055);
#line 1055
      packet_disconnect("Packet integrity error.");
    }
#line 1055
    break;
  }
#line 1056
  if (data_len > (unsigned int )c->local_window) {
#line 1057
    log("channel %d: rcvd too much extended_data %d, win %d", c->self, data_len, c->local_window);
#line 1059
    xfree((void *)data);
#line 1060
    return;
  }
#line 1062
  debug("channel %d: rcvd ext data %d", c->self, data_len);
#line 1063
  c->local_window = (int )((unsigned int )c->local_window - data_len);
#line 1064
  buffer_append(& c->extended, (char const   *)data, data_len);
#line 1065
  xfree((void *)data);
#line 1066
  return;
}
}
#line 1074 "channels.c"
int channel_not_very_much_buffered_data(void) 
{ unsigned int i ;
  Channel *c ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 1080
  i = 0U;
#line 1080
  while (i < (unsigned int )channels_alloc) {
#line 1081
    c = channels + i;
#line 1082
    if (c->type == 4) {
#line 1083
      if (! compat20) {
#line 1083
        tmp___0 = buffer_len(& c->input);
#line 1083
        if (tmp___0 > (unsigned int )max_packet_size) {
#line 1084
          tmp = buffer_len(& c->input);
#line 1084
          debug("channel %d: big input buffer %d", c->self, tmp);
#line 1086
          return (0);
        }
      }
#line 1088
      tmp___2 = buffer_len(& c->output);
#line 1088
      if (tmp___2 > (unsigned int )max_packet_size) {
#line 1089
        tmp___1 = buffer_len(& c->output);
#line 1089
        debug("channel %d: big output buffer %d", c->self, tmp___1);
#line 1091
        return (0);
      }
    }
#line 1080
    i ++;
  }
#line 1095
  return (1);
}
}
#line 1098 "channels.c"
void channel_input_ieof(int type , int plen ) 
{ int id ;
  Channel *c ;
  int _p ;
  int _e ;
  unsigned int tmp ;

  {
#line 1104
  while (1) {
#line 1104
    _p = plen;
#line 1104
    _e = 4;
#line 1104
    if (_p != _e) {
#line 1104
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1104);
#line 1104
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 1104
    break;
  }
#line 1106
  tmp = packet_get_int();
#line 1106
  id = (int )tmp;
#line 1107
  c = channel_lookup(id);
#line 1108
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1109
    packet_disconnect("Received ieof for nonexistent channel %d.", id);
  }
#line 1110
  (*chan_rcvd_ieof)(c);
#line 1111
  return;
}
}
#line 1113 "channels.c"
void channel_input_close(int type , int plen ) 
{ int id ;
  Channel *c ;
  int _p ;
  int _e ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 1119
  while (1) {
#line 1119
    _p = plen;
#line 1119
    _e = 4;
#line 1119
    if (_p != _e) {
#line 1119
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1119);
#line 1119
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 1119
    break;
  }
#line 1121
  tmp = packet_get_int();
#line 1121
  id = (int )tmp;
#line 1122
  c = channel_lookup(id);
#line 1123
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1124
    packet_disconnect("Received close for nonexistent channel %d.", id);
  }
#line 1130
  packet_start(25);
#line 1131
  packet_put_int((unsigned int )c->remote_id);
#line 1132
  packet_send();
#line 1141
  if (c->type != 5) {
#line 1146
    tmp___0 = buffer_len(& c->input);
#line 1146
    buffer_consume(& c->input, tmp___0);
#line 1147
    c->type = 9;
  }
#line 1149
  return;
}
}
#line 1152 "channels.c"
void channel_input_oclose(int type , int plen ) 
{ int id ;
  unsigned int tmp ;
  Channel *c ;
  Channel *tmp___0 ;
  int _p ;
  int _e ;

  {
#line 1155
  tmp = packet_get_int();
#line 1155
  id = (int )tmp;
#line 1156
  tmp___0 = channel_lookup(id);
#line 1156
  c = tmp___0;
#line 1157
  while (1) {
#line 1157
    _p = plen;
#line 1157
    _e = 4;
#line 1157
    if (_p != _e) {
#line 1157
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1157);
#line 1157
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 1157
    break;
  }
#line 1158
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1159
    packet_disconnect("Received oclose for nonexistent channel %d.", id);
  }
#line 1160
  (*chan_rcvd_oclose)(c);
#line 1161
  return;
}
}
#line 1163 "channels.c"
void channel_input_close_confirmation(int type , int plen ) 
{ int id ;
  unsigned int tmp ;
  Channel *c ;
  Channel *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1166
  tmp = packet_get_int();
#line 1166
  id = (int )tmp;
#line 1167
  tmp___0 = channel_lookup(id);
#line 1167
  c = tmp___0;
#line 1169
  while (1) {
#line 1169
    tmp___1 = packet_remaining();
#line 1169
    _len = tmp___1;
#line 1169
    if (_len > 0) {
#line 1169
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1169);
#line 1169
      packet_disconnect("Packet integrity error.");
    }
#line 1169
    break;
  }
#line 1170
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1171
    packet_disconnect("Received close confirmation for out-of-range channel %d.",
                      id);
  }
#line 1173
  if (c->type != 5) {
#line 1174
    packet_disconnect("Received close confirmation for non-closed channel %d (type %d).",
                      id, c->type);
  }
#line 1176
  channel_free(c->self);
#line 1177
  return;
}
}
#line 1179 "channels.c"
void channel_input_open_confirmation(int type , int plen ) 
{ int id ;
  int remote_id ;
  Channel *c ;
  int _p ;
  int _e ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 1185
  if (! compat20) {
#line 1186
    while (1) {
#line 1186
      _p = plen;
#line 1186
      _e = 8;
#line 1186
      if (_p != _e) {
#line 1186
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1186);
#line 1186
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1186
      break;
    }
  }
#line 1188
  tmp = packet_get_int();
#line 1188
  id = (int )tmp;
#line 1189
  c = channel_lookup(id);
#line 1191
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1192
    packet_disconnect("Received open confirmation for non-opening channel %d.", id);
  } else {
#line 1191
    if (c->type != 3) {
#line 1192
      packet_disconnect("Received open confirmation for non-opening channel %d.",
                        id);
    }
  }
#line 1194
  tmp___0 = packet_get_int();
#line 1194
  remote_id = (int )tmp___0;
#line 1196
  c->remote_id = remote_id;
#line 1197
  c->type = 4;
#line 1199
  if (compat20) {
#line 1200
    tmp___1 = packet_get_int();
#line 1200
    c->remote_window = (int )tmp___1;
#line 1201
    tmp___2 = packet_get_int();
#line 1201
    c->remote_maxpacket = (int )tmp___2;
#line 1202
    while (1) {
#line 1202
      tmp___3 = packet_remaining();
#line 1202
      _len = tmp___3;
#line 1202
      if (_len > 0) {
#line 1202
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            1202);
#line 1202
        packet_disconnect("Packet integrity error.");
      }
#line 1202
      break;
    }
#line 1203
    if ((unsigned int )c->cb_fn != (unsigned int )((void *)0)) {
#line 1203
      if (c->cb_event == type) {
#line 1204
        debug("callback start");
#line 1205
        (*(c->cb_fn))(c->self, c->cb_arg);
#line 1206
        debug("callback done");
      }
    }
#line 1208
    debug("channel %d: open confirm rwindow %d rmax %d", c->self, c->remote_window,
          c->remote_maxpacket);
  }
#line 1211
  return;
}
}
#line 1213 "channels.c"
void channel_input_open_failure(int type , int plen ) 
{ int id ;
  Channel *c ;
  int _p ;
  int _e ;
  unsigned int tmp ;
  int reason ;
  unsigned int tmp___0 ;
  char *msg ;
  char *tmp___1 ;
  char *lang ;
  char *tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 1219
  if (! compat20) {
#line 1220
    while (1) {
#line 1220
      _p = plen;
#line 1220
      _e = 4;
#line 1220
      if (_p != _e) {
#line 1220
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1220);
#line 1220
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1220
      break;
    }
  }
#line 1222
  tmp = packet_get_int();
#line 1222
  id = (int )tmp;
#line 1223
  c = channel_lookup(id);
#line 1225
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1226
    packet_disconnect("Received open failure for non-opening channel %d.", id);
  } else {
#line 1225
    if (c->type != 3) {
#line 1226
      packet_disconnect("Received open failure for non-opening channel %d.", id);
    }
  }
#line 1228
  if (compat20) {
#line 1229
    tmp___0 = packet_get_int();
#line 1229
    reason = (int )tmp___0;
#line 1230
    tmp___1 = packet_get_string((unsigned int *)((void *)0));
#line 1230
    msg = tmp___1;
#line 1231
    tmp___2 = packet_get_string((unsigned int *)((void *)0));
#line 1231
    lang = tmp___2;
#line 1232
    log("channel_open_failure: %d: reason %d: %s", id, reason, msg);
#line 1233
    while (1) {
#line 1233
      tmp___3 = packet_remaining();
#line 1233
      _len = tmp___3;
#line 1233
      if (_len > 0) {
#line 1233
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            1233);
#line 1233
        packet_disconnect("Packet integrity error.");
      }
#line 1233
      break;
    }
#line 1234
    xfree((void *)msg);
#line 1235
    xfree((void *)lang);
  }
#line 1238
  channel_free(id);
#line 1239
  return;
}
}
#line 1241 "channels.c"
void channel_input_channel_request(int type , int plen ) 
{ int id ;
  Channel *c ;
  unsigned int tmp ;
  char *service ;
  char *tmp___0 ;

  {
#line 1247
  tmp = packet_get_int();
#line 1247
  id = (int )tmp;
#line 1248
  c = channel_lookup(id);
#line 1250
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1252
    packet_disconnect("Received request for non-open channel %d.", id);
  } else {
#line 1250
    if (c->type != 4) {
#line 1250
      if (c->type != 10) {
#line 1252
        packet_disconnect("Received request for non-open channel %d.", id);
      }
    }
  }
#line 1254
  if ((unsigned int )c->cb_fn != (unsigned int )((void *)0)) {
#line 1254
    if (c->cb_event == type) {
#line 1255
      debug("callback start");
#line 1256
      (*(c->cb_fn))(c->self, c->cb_arg);
#line 1257
      debug("callback done");
    } else {
#line 1259
      tmp___0 = packet_get_string((unsigned int *)((void *)0));
#line 1259
      service = tmp___0;
#line 1260
      debug("channel: %d rcvd request for %s", c->self, service);
#line 1261
      debug("cb_fn %p cb_event %d", c->cb_fn, c->cb_event);
#line 1262
      xfree((void *)service);
    }
  } else {
#line 1259
    tmp___0 = packet_get_string((unsigned int *)((void *)0));
#line 1259
    service = tmp___0;
#line 1260
    debug("channel: %d rcvd request for %s", c->self, service);
#line 1261
    debug("cb_fn %p cb_event %d", c->cb_fn, c->cb_event);
#line 1262
    xfree((void *)service);
  }
#line 1264
  return;
}
}
#line 1266 "channels.c"
void channel_input_window_adjust(int type , int plen ) 
{ Channel *c ;
  int id ;
  int adjust ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1272
  if (! compat20) {
#line 1273
    return;
  }
#line 1276
  tmp = packet_get_int();
#line 1276
  id = (int )tmp;
#line 1277
  c = channel_lookup(id);
#line 1279
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1280
    log("Received window adjust for non-open channel %d.", id);
#line 1282
    return;
  } else {
#line 1279
    if (c->type != 4) {
#line 1280
      log("Received window adjust for non-open channel %d.", id);
#line 1282
      return;
    }
  }
#line 1284
  tmp___0 = packet_get_int();
#line 1284
  adjust = (int )tmp___0;
#line 1285
  while (1) {
#line 1285
    tmp___1 = packet_remaining();
#line 1285
    _len = tmp___1;
#line 1285
    if (_len > 0) {
#line 1285
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1285);
#line 1285
      packet_disconnect("Packet integrity error.");
    }
#line 1285
    break;
  }
#line 1286
  debug("channel %d: rcvd adjust %d", id, adjust);
#line 1287
  c->remote_window += adjust;
#line 1288
  return;
}
}
#line 1295 "channels.c"
void channel_stop_listening(void) 
{ int i ;

  {
#line 1299
  i = 0;
#line 1299
  while (i < channels_alloc) {
#line 1300
    switch ((channels + i)->type) {
    case 6: 
#line 1302
    close((channels + i)->sock);
#line 1303
    remove((char const   *)((channels + i)->path));
#line 1304
    channel_free(i);
#line 1305
    break;
    case 2: 
    case 1: 
#line 1308
    close((channels + i)->sock);
#line 1309
    channel_free(i);
#line 1310
    break;
    default: ;
#line 1312
    break;
    }
#line 1299
    i ++;
  }
#line 1315
  return;
}
}
#line 1322 "channels.c"
void channel_close_all(void) 
{ int i ;

  {
#line 1326
  i = 0;
#line 1326
  while (i < channels_alloc) {
#line 1327
    if ((channels + i)->type != 0) {
#line 1328
      channel_close_fds(channels + i);
    }
#line 1326
    i ++;
  }
#line 1329
  return;
}
}
#line 1333 "channels.c"
int channel_max_fd(void) 
{ 

  {
#line 1336
  return (channel_max_fd_value);
}
}
#line 1341 "channels.c"
int channel_still_open(void) 
{ unsigned int i ;

  {
#line 1345
  i = 0U;
#line 1345
  while (i < (unsigned int )channels_alloc) {
#line 1346
    switch ((channels + i)->type) {
    case 0: 
    case 1: 
    case 2: 
    case 5: 
    case 6: 
    goto __Cont;
    case 10: 
#line 1354
    if (! compat20) {
#line 1355
      fatal("cannot happen: SSH_CHANNEL_LARVAL");
    }
    goto __Cont;
    case 3: 
    case 4: 
    case 7: 
#line 1360
    return (1);
    case 8: 
    case 9: 
#line 1363
    if (! compat13) {
#line 1364
      fatal("cannot happen: OUT_DRAIN");
    }
#line 1365
    return (1);
    default: 
#line 1367
    fatal("channel_still_open: bad channel type %d", (channels + i)->type);
    }
    __Cont: /* CIL Label */ 
#line 1345
    i ++;
  }
#line 1370
  return (0);
}
}
#line 1379 "channels.c"
char *channel_open_message(void) 
{ Buffer buffer ;
  int i ;
  char buf___1[512] ;
  char *cp ;
  size_t tmp ;
  Channel *c ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;

  {
#line 1386
  buffer_init(& buffer);
#line 1387
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"The following connections are open:\r\n");
#line 1388
  tmp = strlen((char const   *)(buf___1));
#line 1388
  buffer_append(& buffer, (char const   *)(buf___1), tmp);
#line 1389
  i = 0;
#line 1389
  while (i < channels_alloc) {
#line 1390
    c = channels + i;
#line 1391
    switch (c->type) {
    case 0: 
    case 1: 
    case 2: 
    case 5: 
    case 6: 
    goto __Cont;
    case 10: 
    case 3: 
    case 4: 
    case 7: 
    case 8: 
    case 9: 
#line 1404
    tmp___0 = buffer_len(& c->output);
#line 1404
    tmp___1 = buffer_len(& c->input);
#line 1404
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"  #%d %.300s (t%d r%d i%d/%d o%d/%d fd %d/%d)\r\n",
             c->self, c->remote_name, c->type, c->remote_id, c->istate, tmp___1, c->ostate,
             tmp___0, c->rfd, c->wfd);
#line 1410
    tmp___2 = strlen((char const   *)(buf___1));
#line 1410
    buffer_append(& buffer, (char const   *)(buf___1), tmp___2);
    goto __Cont;
    default: 
#line 1413
    fatal("channel_open_message: bad channel type %d", c->type);
    }
    __Cont: /* CIL Label */ 
#line 1389
    i ++;
  }
#line 1417
  buffer_append(& buffer, "\000", 1U);
#line 1418
  tmp___3 = buffer_ptr(& buffer);
#line 1418
  cp = xstrdup((char const   *)tmp___3);
#line 1419
  buffer_free(& buffer);
#line 1420
  return (cp);
}
}
#line 1428 "channels.c"
void channel_request_local_forwarding(u_short port , char const   *host , u_short host_port ,
                                      int gateway_ports ) 
{ int success ;
  int ch ;
  int sock ;
  int on ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char ntop[1025] ;
  char strport[32] ;
  struct linger linger ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;

  {
#line 1432
  on = 1;
#line 1437
  tmp = strlen(host);
#line 1437
  if (tmp > sizeof((channels + 0)->path) - 1U) {
#line 1438
    packet_disconnect("Forward host name too long.");
  }
#line 1444
  memset((void *)(& hints), 0, sizeof(hints));
#line 1445
  hints.ai_family = IPv4or6;
#line 1446
  if (gateway_ports) {
#line 1446
    hints.ai_flags = 1;
  } else {
#line 1446
    hints.ai_flags = 0;
  }
#line 1447
  hints.ai_socktype = 1;
#line 1448
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           port);
#line 1449
  tmp___0 = getaddrinfo((char const   * __restrict  )((void *)0), (char const   * __restrict  )(strport),
                        (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 1449
  if (tmp___0 != 0) {
#line 1450
    packet_disconnect("getaddrinfo: fatal error");
  }
#line 1452
  success = 0;
#line 1453
  ai = aitop;
#line 1453
  while (ai) {
#line 1454
    if (ai->ai_family != 2) {
#line 1454
      if (ai->ai_family != 10) {
        goto __Cont;
      }
    }
#line 1456
    tmp___1 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                          (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )(strport),
                          sizeof(strport), 3U);
#line 1456
    if (tmp___1 != 0) {
#line 1458
      error("channel_request_local_forwarding: getnameinfo failed");
      goto __Cont;
    }
#line 1462
    sock = socket(ai->ai_family, 1, 0);
#line 1463
    if (sock < 0) {
#line 1465
      tmp___2 = __errno_location();
#line 1465
      tmp___3 = strerror(*tmp___2);
#line 1465
      verbose("socket: %.100s", tmp___3);
      goto __Cont;
    }
#line 1472
    setsockopt(sock, 1, 2, (void const   *)((void *)(& on)), sizeof(on));
#line 1473
    linger.l_onoff = 1;
#line 1474
    linger.l_linger = 5;
#line 1475
    setsockopt(sock, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 1476
    debug("Local forwarding listening on %s port %s.", ntop, strport);
#line 1479
    tmp___8 = bind(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 1479
    if (tmp___8 < 0) {
#line 1481
      if (! ai->ai_next) {
#line 1482
        tmp___4 = __errno_location();
#line 1482
        tmp___5 = strerror(*tmp___4);
#line 1482
        error("bind: %.100s", tmp___5);
      } else {
#line 1484
        tmp___6 = __errno_location();
#line 1484
        tmp___7 = strerror(*tmp___6);
#line 1484
        verbose("bind: %.100s", tmp___7);
      }
#line 1486
      close(sock);
      goto __Cont;
    }
#line 1490
    tmp___11 = listen(sock, 5);
#line 1490
    if (tmp___11 < 0) {
#line 1491
      tmp___9 = __errno_location();
#line 1491
      tmp___10 = strerror(*tmp___9);
#line 1491
      error("listen: %.100s", tmp___10);
#line 1492
      close(sock);
      goto __Cont;
    }
#line 1496
    tmp___12 = xstrdup("port listener");
#line 1496
    ch = channel_new((char *)"port listener", 2, sock, sock, -1, 8192, 4096, 0, tmp___12);
#line 1501
    strlcpy((channels + ch)->path, host, sizeof((channels + ch)->path));
#line 1502
    (channels + ch)->host_port = (int )host_port;
#line 1503
    (channels + ch)->listening_port = (int )port;
#line 1504
    success = 1;
    __Cont: /* CIL Label */ 
#line 1453
    ai = ai->ai_next;
  }
#line 1506
  if (success == 0) {
#line 1507
    packet_disconnect("cannot listen port: %d", port);
  }
#line 1508
  freeaddrinfo(aitop);
#line 1509
  return;
}
}
#line 1516 "channels.c"
void channel_request_remote_forwarding(u_short listen_port , char const   *host_to_connect ,
                                       u_short port_to_connect ) 
{ int payload_len ;
  char const   *address_to_bind ;

  {
#line 1522
  if (num_permitted_opens >= 100) {
#line 1523
    fatal("channel_request_remote_forwarding: too many forwards");
  }
#line 1525
  permitted_opens[num_permitted_opens].host_to_connect = xstrdup(host_to_connect);
#line 1526
  permitted_opens[num_permitted_opens].port_to_connect = port_to_connect;
#line 1527
  permitted_opens[num_permitted_opens].listen_port = listen_port;
#line 1528
  num_permitted_opens ++;
#line 1531
  if (compat20) {
#line 1532
    address_to_bind = "0.0.0.0";
#line 1533
    packet_start(80);
#line 1534
    packet_put_cstring("tcpip-forward");
#line 1535
    packet_put_char(0);
#line 1536
    packet_put_cstring(address_to_bind);
#line 1537
    packet_put_int((unsigned int )listen_port);
  } else {
#line 1539
    packet_start(28);
#line 1540
    packet_put_int((unsigned int )listen_port);
#line 1541
    packet_put_cstring(host_to_connect);
#line 1542
    packet_put_int((unsigned int )port_to_connect);
#line 1543
    packet_send();
#line 1544
    packet_write_wait();
#line 1549
    packet_read_expect(& payload_len, 14);
  }
#line 1551
  return;
}
}
#line 1559 "channels.c"
void channel_input_port_forward_request(int is_root , int gateway_ports ) 
{ u_short port ;
  u_short host_port ;
  char *hostname ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 1566
  tmp = packet_get_int();
#line 1566
  port = (unsigned short )tmp;
#line 1567
  hostname = packet_get_string((unsigned int *)((void *)0));
#line 1568
  tmp___0 = packet_get_int();
#line 1568
  host_port = (unsigned short )tmp___0;
#line 1574
  if ((int )port < 1024) {
#line 1574
    if (! is_root) {
#line 1575
      packet_disconnect("Requested forwarding of port %d but user is not root.", port);
    }
  }
#line 1580
  channel_request_local_forwarding(port, (char const   *)hostname, host_port, gateway_ports);
#line 1583
  xfree((void *)hostname);
#line 1584
  return;
}
}
#line 1587 "channels.c"
int channel_connect_to(char const   *host , u_short host_port ) 
{ struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char ntop[1025] ;
  char strport[32] ;
  int gaierr ;
  int sock ;
  char const   *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 1593
  sock = -1;
#line 1595
  memset((void *)(& hints), 0, sizeof(hints));
#line 1596
  hints.ai_family = IPv4or6;
#line 1597
  hints.ai_socktype = 1;
#line 1598
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           host_port);
#line 1599
  gaierr = getaddrinfo((char const   * __restrict  )host, (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 1599
  if (gaierr != 0) {
#line 1600
    tmp = gai_strerror(gaierr);
#line 1600
    error("%.100s: unknown host (%s)", host, tmp);
#line 1601
    return (-1);
  }
#line 1603
  ai = aitop;
#line 1603
  while (ai) {
#line 1604
    if (ai->ai_family != 2) {
#line 1604
      if (ai->ai_family != 10) {
        goto __Cont;
      }
    }
#line 1606
    tmp___0 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                          (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )(strport),
                          sizeof(strport), 3U);
#line 1606
    if (tmp___0 != 0) {
#line 1608
      error("channel_connect_to: getnameinfo failed");
      goto __Cont;
    }
#line 1612
    sock = socket(ai->ai_family, 1, 0);
#line 1613
    if (sock < 0) {
#line 1614
      tmp___1 = __errno_location();
#line 1614
      tmp___2 = strerror(*tmp___1);
#line 1614
      error("socket: %.100s", tmp___2);
      goto __Cont;
    }
#line 1618
    tmp___5 = connect(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 1618
    if (tmp___5 < 0) {
#line 1619
      tmp___3 = __errno_location();
#line 1619
      tmp___4 = strerror(*tmp___3);
#line 1619
      error("connect %.100s port %s: %.100s", ntop, strport, tmp___4);
#line 1621
      close(sock);
      goto __Cont;
    }
#line 1624
    break;
    __Cont: /* CIL Label */ 
#line 1603
    ai = ai->ai_next;
  }
#line 1627
  freeaddrinfo(aitop);
#line 1628
  if (! ai) {
#line 1629
    error("connect %.100s port %d: failed.", host, host_port);
#line 1630
    return (-1);
  }
#line 1633
  return (sock);
}
}
#line 1642 "channels.c"
void channel_input_port_open(int type , int plen ) 
{ u_short host_port ;
  char *host ;
  char *originator_string ;
  int remote_channel ;
  int sock ;
  int newch ;
  int i ;
  int denied ;
  unsigned int host_len ;
  unsigned int originator_len ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int _p ;
  int _e ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 1647
  sock = -1;
#line 1651
  tmp = packet_get_int();
#line 1651
  remote_channel = (int )tmp;
#line 1654
  host = packet_get_string(& host_len);
#line 1657
  tmp___0 = packet_get_int();
#line 1657
  host_port = (unsigned short )tmp___0;
#line 1660
  if (have_hostname_in_open) {
#line 1661
    originator_string = packet_get_string(& originator_len);
#line 1662
    originator_len += 4U;
  } else {
#line 1664
    originator_string = xstrdup("unknown (remote did not supply name)");
#line 1665
    originator_len = 0U;
  }
#line 1668
  while (1) {
#line 1668
    _p = plen;
#line 1668
    _e = (int )(((8U + host_len) + 4U) + originator_len);
#line 1668
    if (_p != _e) {
#line 1668
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1669);
#line 1668
      packet_disconnect("Packet integrity error. (%d)", 29);
    }
#line 1668
    break;
  }
#line 1672
  denied = 0;
#line 1673
  if (! all_opens_permitted) {
#line 1675
    i = 0;
#line 1675
    while (i < num_permitted_opens) {
#line 1677
      if ((int )permitted_opens[i].port_to_connect == (int )host_port) {
#line 1677
        if (0) {
#line 1677
          __s1_len = strlen((char const   *)permitted_opens[i].host_to_connect);
#line 1677
          __s2_len = strlen((char const   *)host);
#line 1677
          if (! ((unsigned int )((void const   *)(permitted_opens[i].host_to_connect + 1)) - (unsigned int )((void const   *)permitted_opens[i].host_to_connect) == 1U)) {
            goto _L___0;
          } else {
#line 1677
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 1677
              if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
#line 1677
                tmp___10 = 1;
              } else {
#line 1677
                if (__s2_len >= 4U) {
#line 1677
                  tmp___10 = 1;
                } else {
#line 1677
                  tmp___10 = 0;
                }
              }
            } else {
#line 1677
              tmp___10 = 0;
            }
          }
#line 1677
          if (tmp___10) {
#line 1677
            tmp___6 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                       (char const   *)host);
          } else {
#line 1677
            tmp___9 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                       (char const   *)host);
#line 1677
            tmp___6 = tmp___9;
          }
        } else {
#line 1677
          tmp___9 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                     (char const   *)host);
#line 1677
          tmp___6 = tmp___9;
        }
#line 1677
        if (tmp___6 == 0) {
#line 1678
          break;
        }
      }
#line 1675
      i ++;
    }
#line 1681
    if (i >= num_permitted_opens) {
#line 1683
      log("Received request to connect to %.100s:%d, but the request was denied.",
          host, host_port);
#line 1685
      denied = 1;
    }
  }
#line 1688
  if (denied) {
#line 1688
    sock = -1;
  } else {
#line 1688
    sock = channel_connect_to((char const   *)host, host_port);
  }
#line 1689
  if (sock > 0) {
#line 1691
    newch = channel_allocate(4, sock, originator_string);
#line 1692
    (channels + newch)->remote_id = remote_channel;
#line 1694
    packet_start(21);
#line 1695
    packet_put_int((unsigned int )remote_channel);
#line 1696
    packet_put_int((unsigned int )newch);
#line 1697
    packet_send();
  } else {
#line 1699
    packet_start(22);
#line 1700
    packet_put_int((unsigned int )remote_channel);
#line 1701
    packet_send();
  }
#line 1703
  xfree((void *)host);
#line 1704
  return;
}
}
#line 1714 "channels.c"
char *x11_create_display_inet(int screen_number , int x11_display_offset ) 
{ int display_number ;
  int sock ;
  u_short port ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  int n___0 ;
  int num_socks ;
  int socks[10] ;
  char display[512] ;
  char hostname[64] ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;

  {
#line 1721
  num_socks = 0;
#line 1725
  display_number = x11_display_offset;
#line 1725
  while (display_number < 1000) {
#line 1728
    port = (unsigned short )(6000 + display_number);
#line 1729
    memset((void *)(& hints), 0, sizeof(hints));
#line 1730
    hints.ai_family = IPv4or6;
#line 1731
    hints.ai_flags = 1;
#line 1732
    hints.ai_socktype = 1;
#line 1733
    snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
             port);
#line 1734
    gaierr = getaddrinfo((char const   * __restrict  )((void *)0), (char const   * __restrict  )(strport),
                         (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 1734
    if (gaierr != 0) {
#line 1735
      tmp = gai_strerror(gaierr);
#line 1735
      error("getaddrinfo: %.100s", tmp);
#line 1736
      return ((char *)((void *)0));
    }
#line 1738
    ai = aitop;
#line 1738
    while (ai) {
#line 1739
      if (ai->ai_family != 2) {
#line 1739
        if (ai->ai_family != 10) {
          goto __Cont;
        }
      }
#line 1741
      sock = socket(ai->ai_family, 1, 0);
#line 1742
      if (sock < 0) {
#line 1743
        tmp___2 = __errno_location();
#line 1743
        if (*tmp___2 != 22) {
#line 1744
          tmp___0 = __errno_location();
#line 1744
          tmp___1 = strerror(*tmp___0);
#line 1744
          error("socket: %.100s", tmp___1);
#line 1745
          return ((char *)((void *)0));
        } else {
#line 1747
          debug("Socket family %d not supported [X11 disp create]", ai->ai_family);
          goto __Cont;
        }
      }
#line 1751
      tmp___5 = bind(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 1751
      if (tmp___5 < 0) {
#line 1752
        tmp___3 = __errno_location();
#line 1752
        tmp___4 = strerror(*tmp___3);
#line 1752
        debug("bind port %d: %.100s", port, tmp___4);
#line 1753
        shutdown(sock, 2);
#line 1754
        close(sock);
#line 1756
        if (ai->ai_next) {
          goto __Cont;
        }
#line 1759
        n___0 = 0;
#line 1759
        while (n___0 < num_socks) {
#line 1760
          shutdown(socks[n___0], 2);
#line 1761
          close(socks[n___0]);
#line 1759
          n___0 ++;
        }
#line 1763
        num_socks = 0;
#line 1764
        break;
      }
#line 1766
      tmp___6 = num_socks;
#line 1766
      num_socks ++;
#line 1766
      socks[tmp___6] = sock;
#line 1771
      break;
      __Cont: /* CIL Label */ 
#line 1738
      ai = ai->ai_next;
    }
#line 1774
    if (num_socks > 0) {
#line 1775
      break;
    }
#line 1725
    display_number ++;
  }
#line 1777
  if (display_number >= 1000) {
#line 1778
    error("Failed to allocate internet-domain X11 display socket.");
#line 1779
    return ((char *)((void *)0));
  }
#line 1782
  n___0 = 0;
#line 1782
  while (n___0 < num_socks) {
#line 1783
    sock = socks[n___0];
#line 1784
    tmp___9 = listen(sock, 5);
#line 1784
    if (tmp___9 < 0) {
#line 1785
      tmp___7 = __errno_location();
#line 1785
      tmp___8 = strerror(*tmp___7);
#line 1785
      error("listen: %.100s", tmp___8);
#line 1786
      shutdown(sock, 2);
#line 1787
      close(sock);
#line 1788
      return ((char *)((void *)0));
    }
#line 1782
    n___0 ++;
  }
#line 1794
  tmp___12 = gethostname(hostname, sizeof(hostname));
#line 1794
  if (tmp___12 < 0) {
#line 1795
    tmp___10 = __errno_location();
#line 1795
    tmp___11 = strerror(*tmp___10);
#line 1795
    fatal("gethostname: %.100s", tmp___11);
  }
#line 1832
  snprintf((char * __restrict  )(display), sizeof(display), (char const   * __restrict  )"%.400s:%d.%d",
           hostname, display_number, screen_number);
#line 1837
  n___0 = 0;
#line 1837
  while (n___0 < num_socks) {
#line 1838
    sock = socks[n___0];
#line 1839
    tmp___13 = xstrdup("X11 inet listener");
#line 1839
    channel_new((char *)"x11 listener", 1, sock, sock, -1, 4096, 2048, 0, tmp___13);
#line 1837
    n___0 ++;
  }
#line 1846
  tmp___14 = xstrdup((char const   *)(display));
#line 1846
  return (tmp___14);
}
}
#line 1857
static int connect_local_xsocket(unsigned int dnr ) ;
#line 1857 "channels.c"
static char const   * const  x_sockets[4]  = {      (char const   * const  )"/tmp/.X11-unix/X%u",      (char const   * const  )"/var/X/.X11-unix/X%u",      (char const   * const  )"/usr/spool/sockets/X11/%u",      (char const   * const  )((void *)0)};
#line 1853 "channels.c"
static int connect_local_xsocket(unsigned int dnr ) 
{ int sock ;
  struct sockaddr_un addr ;
  char const   * const  *path ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 1867
  path = x_sockets;
#line 1867
  while (*path) {
#line 1868
    sock = socket(1, 1, 0);
#line 1869
    if (sock < 0) {
#line 1870
      tmp = __errno_location();
#line 1870
      tmp___0 = strerror(*tmp);
#line 1870
      error("socket: %.100s", tmp___0);
    }
#line 1871
    memset((void *)(& addr), 0, sizeof(addr));
#line 1872
    addr.sun_family = (unsigned short)1;
#line 1873
    snprintf((char * __restrict  )(addr.sun_path), sizeof(addr.sun_path), (char const   * __restrict  )*path,
             dnr);
#line 1874
    tmp___1 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& addr)),
                      sizeof(addr));
#line 1874
    if (tmp___1 == 0) {
#line 1875
      return (sock);
    }
#line 1876
    close(sock);
#line 1867
    path ++;
  }
#line 1878
  tmp___2 = __errno_location();
#line 1878
  tmp___3 = strerror(*tmp___2);
#line 1878
  error("connect %.100s: %.100s", addr.sun_path, tmp___3);
#line 1879
  return (-1);
}
}
#line 1882 "channels.c"
int x11_connect_display(void) 
{ int display_number ;
  int sock ;
  char const   *display ;
  char buf___1[1024] ;
  char *cp ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___29 ;
  int tmp___30 ;
  char const   *tmp___31 ;
  int *tmp___32 ;
  char *tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  int *tmp___37 ;
  char *tmp___38 ;

  {
#line 1885
  sock = 0;
#line 1893
  tmp = getenv("DISPLAY");
#line 1893
  display = (char const   *)tmp;
#line 1894
  if (! display) {
#line 1895
    error("DISPLAY not set.");
#line 1896
    return (-1);
  }
#line 1907
  if (0) {
#line 1907
    if (0) {
#line 1907
      __s1_len___0 = strlen(display);
#line 1907
      __s2_len___0 = strlen("unix:");
#line 1907
      if (! ((unsigned int )((void const   *)(display + 1)) - (unsigned int )((void const   *)display) == 1U)) {
        goto _L___2;
      } else {
#line 1907
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 1907
          if (! ((unsigned int )((void const   *)("unix:" + 1)) - (unsigned int )((void const   *)"unix:") == 1U)) {
#line 1907
            tmp___25 = 1;
          } else {
#line 1907
            if (__s2_len___0 >= 4U) {
#line 1907
              tmp___25 = 1;
            } else {
#line 1907
              tmp___25 = 0;
            }
          }
        } else {
#line 1907
          tmp___25 = 0;
        }
      }
#line 1907
      if (tmp___25) {
#line 1907
        tmp___21 = __builtin_strcmp(display, "unix:");
      } else {
#line 1907
        tmp___24 = __builtin_strcmp(display, "unix:");
#line 1907
        tmp___21 = tmp___24;
      }
    } else {
#line 1907
      tmp___24 = __builtin_strcmp(display, "unix:");
#line 1907
      tmp___21 = tmp___24;
    }
#line 1907
    tmp___15 = tmp___21;
  } else {
#line 1907
    tmp___15 = strncmp(display, "unix:", 5U);
  }
#line 1907
  if (tmp___15 == 0) {
    goto _L___3;
  } else {
#line 1907
    if ((int const   )*(display + 0) == 58) {
      _L___3: /* CIL Label */ 
#line 1910
      tmp___0 = strrchr(display, ':');
#line 1910
      tmp___1 = sscanf((char const   * __restrict  )(tmp___0 + 1), (char const   * __restrict  )"%d",
                       & display_number);
#line 1910
      if (tmp___1 != 1) {
#line 1911
        error("Could not parse display number from DISPLAY: %.100s", display);
#line 1913
        return (-1);
      }
#line 1916
      sock = connect_local_xsocket((unsigned int )display_number);
#line 1917
      if (sock < 0) {
#line 1918
        return (-1);
      }
#line 1921
      return (sock);
    }
  }
#line 1927
  __builtin_strncpy(buf___1, display, sizeof(buf___1));
#line 1928
  buf___1[sizeof(buf___1) - 1U] = (char)0;
#line 1929
  tmp___29 = __builtin_strchr(buf___1, ':');
#line 1929
  cp = tmp___29;
#line 1930
  if (! cp) {
#line 1931
    error("Could not find \':\' in DISPLAY: %.100s", display);
#line 1932
    return (-1);
  }
#line 1934
  *cp = (char)0;
#line 1936
  tmp___30 = sscanf((char const   * __restrict  )(cp + 1), (char const   * __restrict  )"%d",
                    & display_number);
#line 1936
  if (tmp___30 != 1) {
#line 1937
    error("Could not parse display number from DISPLAY: %.100s", display);
#line 1939
    return (-1);
  }
#line 1943
  memset((void *)(& hints), 0, sizeof(hints));
#line 1944
  hints.ai_family = IPv4or6;
#line 1945
  hints.ai_socktype = 1;
#line 1946
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           6000 + display_number);
#line 1947
  gaierr = getaddrinfo((char const   * __restrict  )(buf___1), (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 1947
  if (gaierr != 0) {
#line 1948
    tmp___31 = gai_strerror(gaierr);
#line 1948
    error("%.100s: unknown host. (%s)", buf___1, tmp___31);
#line 1949
    return (-1);
  }
#line 1951
  ai = aitop;
#line 1951
  while (ai) {
#line 1953
    sock = socket(ai->ai_family, 1, 0);
#line 1954
    if (sock < 0) {
#line 1955
      tmp___32 = __errno_location();
#line 1955
      tmp___33 = strerror(*tmp___32);
#line 1955
      debug("socket: %.100s", tmp___33);
      goto __Cont;
    }
#line 1959
    tmp___36 = connect(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 1959
    if (tmp___36 < 0) {
#line 1960
      tmp___34 = __errno_location();
#line 1960
      tmp___35 = strerror(*tmp___34);
#line 1960
      debug("connect %.100s port %d: %.100s", buf___1, 6000 + display_number, tmp___35);
#line 1962
      close(sock);
      goto __Cont;
    }
#line 1966
    break;
    __Cont: /* CIL Label */ 
#line 1951
    ai = ai->ai_next;
  }
#line 1968
  freeaddrinfo(aitop);
#line 1969
  if (! ai) {
#line 1970
    tmp___37 = __errno_location();
#line 1970
    tmp___38 = strerror(*tmp___37);
#line 1970
    error("connect %.100s port %d: %.100s", buf___1, 6000 + display_number, tmp___38);
#line 1972
    return (-1);
  }
#line 1974
  return (sock);
}
}
#line 1983 "channels.c"
void x11_input_open(int type , int plen ) 
{ int remote_channel ;
  int sock ;
  int newch ;
  char *remote_host ;
  unsigned int remote_len ;
  unsigned int tmp ;
  int _p ;
  int _e ;
  int tmp___0 ;

  {
#line 1986
  sock = 0;
#line 1991
  tmp = packet_get_int();
#line 1991
  remote_channel = (int )tmp;
#line 1994
  if (have_hostname_in_open) {
#line 1995
    remote_host = packet_get_string(& remote_len);
#line 1996
    remote_len += 4U;
  } else {
#line 1998
    remote_host = xstrdup("unknown (remote did not supply name)");
#line 1999
    remote_len = 0U;
  }
#line 2002
  debug("Received X11 open request.");
#line 2003
  while (1) {
#line 2003
    _p = plen;
#line 2003
    _e = (int )(4U + remote_len);
#line 2003
    if (_p != _e) {
#line 2003
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 2003);
#line 2003
      packet_disconnect("Packet integrity error. (%d)", 27);
    }
#line 2003
    break;
  }
#line 2006
  sock = x11_connect_display();
#line 2007
  if (sock == -1) {
#line 2009
    packet_start(22);
#line 2010
    packet_put_int((unsigned int )remote_channel);
#line 2011
    packet_send();
  } else {
#line 2014
    if ((unsigned int )x11_saved_proto == (unsigned int )((void *)0)) {
#line 2014
      tmp___0 = 4;
    } else {
#line 2014
      tmp___0 = 7;
    }
#line 2014
    newch = channel_allocate(tmp___0, sock, remote_host);
#line 2018
    (channels + newch)->remote_id = remote_channel;
#line 2021
    packet_start(21);
#line 2022
    packet_put_int((unsigned int )remote_channel);
#line 2023
    packet_put_int((unsigned int )newch);
#line 2024
    packet_send();
  }
#line 2026
  return;
}
}
#line 2033 "channels.c"
void x11_request_forwarding_with_spoofing(int client_session_id , char const   *proto ,
                                          char const   *data ) 
{ unsigned int data_len ;
  size_t tmp ;
  unsigned int i ;
  unsigned int value ;
  char *new_data ;
  int screen_number ;
  char const   *cp ;
  u_int32_t rand___0 ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;

  {
#line 2037
  tmp = strlen(data);
#line 2037
  data_len = tmp / 2U;
#line 2042
  rand___0 = (u_int32_t )0;
#line 2044
  tmp___0 = getenv("DISPLAY");
#line 2044
  cp = (char const   *)tmp___0;
#line 2045
  if (cp) {
#line 2046
    tmp___2 = __builtin_strchr((char *)cp, ':');
#line 2046
    cp = (char const   *)tmp___2;
  }
#line 2047
  if (cp) {
#line 2048
    tmp___4 = __builtin_strchr((char *)cp, '.');
#line 2048
    cp = (char const   *)tmp___4;
  }
#line 2049
  if (cp) {
#line 2050
    screen_number = atoi(cp + 1);
  } else {
#line 2052
    screen_number = 0;
  }
#line 2055
  x11_saved_proto = xstrdup(proto);
#line 2061
  tmp___5 = xmalloc(data_len);
#line 2061
  x11_saved_data = (char *)tmp___5;
#line 2062
  tmp___6 = xmalloc(data_len);
#line 2062
  x11_fake_data = (char *)tmp___6;
#line 2063
  i = 0U;
#line 2063
  while (i < data_len) {
#line 2064
    tmp___7 = sscanf((char const   * __restrict  )(data + 2U * i), (char const   * __restrict  )"%2x",
                     & value);
#line 2064
    if (tmp___7 != 1) {
#line 2065
      fatal("x11_request_forwarding: bad authentication data: %.100s", data);
    }
#line 2066
    if (i % 4U == 0U) {
#line 2067
      rand___0 = arc4random();
    }
#line 2068
    *(x11_saved_data + i) = (char )value;
#line 2069
    *(x11_fake_data + i) = (char )(rand___0 & 255U);
#line 2070
    rand___0 >>= 8;
#line 2063
    i ++;
  }
#line 2072
  x11_saved_data_len = data_len;
#line 2073
  x11_fake_data_len = data_len;
#line 2076
  tmp___8 = xmalloc(2U * data_len + 1U);
#line 2076
  new_data = (char *)tmp___8;
#line 2077
  i = 0U;
#line 2077
  while (i < data_len) {
#line 2078
    sprintf((char * __restrict  )(new_data + 2U * i), (char const   * __restrict  )"%02x",
            (unsigned char )*(x11_fake_data + i));
#line 2077
    i ++;
  }
#line 2081
  if (compat20) {
#line 2082
    channel_request_start(client_session_id, (char *)"x11-req", 0);
#line 2083
    packet_put_char(0);
  } else {
#line 2085
    packet_start(34);
  }
#line 2087
  packet_put_cstring(proto);
#line 2088
  packet_put_cstring((char const   *)new_data);
#line 2089
  packet_put_int((unsigned int )screen_number);
#line 2090
  packet_send();
#line 2091
  packet_write_wait();
#line 2092
  xfree((void *)new_data);
#line 2093
  return;
}
}
#line 2097 "channels.c"
void auth_request_forwarding(void) 
{ 

  {
#line 2100
  packet_start(30);
#line 2101
  packet_send();
#line 2102
  packet_write_wait();
#line 2103
  return;
}
}
#line 2111 "channels.c"
char *auth_get_socket_name(void) 
{ 

  {
#line 2114
  return (channel_forwarded_auth_socket_name);
}
}
#line 2119 "channels.c"
void cleanup_socket(void) 
{ 

  {
#line 2122
  remove((char const   *)channel_forwarded_auth_socket_name);
#line 2123
  rmdir((char const   *)channel_forwarded_auth_socket_dir);
#line 2124
  return;
}
}
#line 2131 "channels.c"
int auth_input_request_forwarding(struct passwd *pw ) 
{ int sock ;
  int newch ;
  struct sockaddr_un sunaddr ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  __pid_t tmp___5 ;
  int saved ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;

  {
#line 2137
  tmp = auth_get_socket_name();
#line 2137
  if ((unsigned int )tmp != (unsigned int )((void *)0)) {
#line 2138
    fatal("Protocol error: authentication forwarding requested twice.");
  }
#line 2141
  temporarily_use_uid(pw->pw_uid);
#line 2144
  tmp___0 = xmalloc(100U);
#line 2144
  channel_forwarded_auth_socket_name = (char *)tmp___0;
#line 2145
  tmp___1 = xmalloc(100U);
#line 2145
  channel_forwarded_auth_socket_dir = (char *)tmp___1;
#line 2146
  strlcpy(channel_forwarded_auth_socket_dir, "/tmp/ssh-XXXXXXXX", 100U);
#line 2149
  tmp___4 = mkdtemp(channel_forwarded_auth_socket_dir);
#line 2149
  if ((unsigned int )tmp___4 == (unsigned int )((void *)0)) {
#line 2150
    tmp___2 = __errno_location();
#line 2150
    tmp___3 = strerror(*tmp___2);
#line 2150
    packet_send_debug("Agent forwarding disabled: mkdtemp() failed: %.100s", tmp___3);
#line 2152
    restore_uid();
#line 2153
    xfree((void *)channel_forwarded_auth_socket_name);
#line 2154
    xfree((void *)channel_forwarded_auth_socket_dir);
#line 2155
    channel_forwarded_auth_socket_name = (char *)((void *)0);
#line 2156
    channel_forwarded_auth_socket_dir = (char *)((void *)0);
#line 2157
    return (0);
  }
#line 2159
  tmp___5 = getpid();
#line 2159
  snprintf((char * __restrict  )channel_forwarded_auth_socket_name, 100U, (char const   * __restrict  )"%s/agent.%d",
           channel_forwarded_auth_socket_dir, tmp___5);
#line 2162
  tmp___8 = atexit(& cleanup_socket);
#line 2162
  if (tmp___8 < 0) {
#line 2163
    tmp___6 = __errno_location();
#line 2163
    saved = *tmp___6;
#line 2164
    cleanup_socket();
#line 2165
    tmp___7 = strerror(saved);
#line 2165
    packet_disconnect("socket: %.100s", tmp___7);
  }
#line 2168
  sock = socket(1, 1, 0);
#line 2169
  if (sock < 0) {
#line 2170
    tmp___9 = __errno_location();
#line 2170
    tmp___10 = strerror(*tmp___9);
#line 2170
    packet_disconnect("socket: %.100s", tmp___10);
  }
#line 2173
  memset((void *)(& sunaddr), 0, sizeof(sunaddr));
#line 2174
  sunaddr.sun_family = (unsigned short)1;
#line 2175
  __builtin_strncpy(sunaddr.sun_path, (char const   *)channel_forwarded_auth_socket_name,
                    sizeof(sunaddr.sun_path));
#line 2178
  tmp___13 = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sunaddr)),
                  sizeof(sunaddr));
#line 2178
  if (tmp___13 < 0) {
#line 2179
    tmp___11 = __errno_location();
#line 2179
    tmp___12 = strerror(*tmp___11);
#line 2179
    packet_disconnect("bind: %.100s", tmp___12);
  }
#line 2182
  restore_uid();
#line 2185
  tmp___16 = listen(sock, 5);
#line 2185
  if (tmp___16 < 0) {
#line 2186
    tmp___14 = __errno_location();
#line 2186
    tmp___15 = strerror(*tmp___14);
#line 2186
    packet_disconnect("listen: %.100s", tmp___15);
  }
#line 2189
  tmp___17 = xstrdup("auth socket");
#line 2189
  newch = channel_allocate(6, sock, tmp___17);
#line 2191
  strlcpy((channels + newch)->path, (char const   *)channel_forwarded_auth_socket_name,
          sizeof((channels + newch)->path));
#line 2193
  return (1);
}
}
#line 2198 "channels.c"
void auth_input_open_request(int type , int plen ) 
{ int remch ;
  int sock ;
  int newch ;
  char *dummyname ;
  int _p ;
  int _e ;
  unsigned int tmp ;

  {
#line 2204
  while (1) {
#line 2204
    _p = plen;
#line 2204
    _e = 4;
#line 2204
    if (_p != _e) {
#line 2204
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 2204);
#line 2204
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 2204
    break;
  }
#line 2207
  tmp = packet_get_int();
#line 2207
  remch = (int )tmp;
#line 2213
  sock = ssh_get_authentication_socket();
#line 2221
  if (sock < 0) {
#line 2222
    packet_start(22);
#line 2223
    packet_put_int((unsigned int )remch);
#line 2224
    packet_send();
#line 2225
    return;
  }
#line 2227
  debug("Forwarding authentication connection.");
#line 2234
  dummyname = xstrdup("authentication agent connection");
#line 2236
  newch = channel_allocate(4, sock, dummyname);
#line 2237
  (channels + newch)->remote_id = remch;
#line 2240
  packet_start(21);
#line 2241
  packet_put_int((unsigned int )remch);
#line 2242
  packet_put_int((unsigned int )newch);
#line 2243
  packet_send();
#line 2244
  return;
}
}
#line 2246 "channels.c"
void channel_start_open(int id ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2249
  tmp = channel_lookup(id);
#line 2249
  c = tmp;
#line 2250
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2251
    log("channel_open: %d: bad id", id);
#line 2252
    return;
  }
#line 2254
  debug("send channel open %d", id);
#line 2255
  packet_start(90);
#line 2256
  packet_put_cstring((char const   *)c->ctype);
#line 2257
  packet_put_int((unsigned int )c->self);
#line 2258
  packet_put_int((unsigned int )c->local_window);
#line 2259
  packet_put_int((unsigned int )c->local_maxpacket);
#line 2260
  return;
}
}
#line 2261 "channels.c"
void channel_open(int id ) 
{ 

  {
#line 2265
  channel_start_open(id);
#line 2266
  packet_send();
#line 2267
  return;
}
}
#line 2268 "channels.c"
void channel_request(int id , char *service , int wantconfirm ) 
{ 

  {
#line 2271
  channel_request_start(id, service, wantconfirm);
#line 2272
  packet_send();
#line 2273
  debug("channel request %d: %s", id, service);
#line 2274
  return;
}
}
#line 2275 "channels.c"
void channel_request_start(int id , char *service , int wantconfirm ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2278
  tmp = channel_lookup(id);
#line 2278
  c = tmp;
#line 2279
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2280
    log("channel_request: %d: bad id", id);
#line 2281
    return;
  }
#line 2283
  packet_start(98);
#line 2284
  packet_put_int((unsigned int )c->remote_id);
#line 2285
  packet_put_cstring((char const   *)service);
#line 2286
  packet_put_char(wantconfirm);
#line 2287
  return;
}
}
#line 2288 "channels.c"
void channel_register_callback(int id , int mtype , channel_callback_fn *fn , void *arg ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2291
  tmp = channel_lookup(id);
#line 2291
  c = tmp;
#line 2292
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2293
    log("channel_register_callback: %d: bad id", id);
#line 2294
    return;
  }
#line 2296
  c->cb_event = mtype;
#line 2297
  c->cb_fn = fn;
#line 2298
  c->cb_arg = arg;
#line 2299
  return;
}
}
#line 2300 "channels.c"
void channel_register_cleanup(int id , channel_callback_fn *fn ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2303
  tmp = channel_lookup(id);
#line 2303
  c = tmp;
#line 2304
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2305
    log("channel_register_cleanup: %d: bad id", id);
#line 2306
    return;
  }
#line 2308
  c->dettach_user = fn;
#line 2309
  return;
}
}
#line 2310 "channels.c"
void channel_cancel_cleanup(int id ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2313
  tmp = channel_lookup(id);
#line 2313
  c = tmp;
#line 2314
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2315
    log("channel_cancel_cleanup: %d: bad id", id);
#line 2316
    return;
  }
#line 2318
  c->dettach_user = (channel_callback_fn *)((void *)0);
#line 2319
  return;
}
}
#line 2320 "channels.c"
void channel_register_filter(int id , channel_filter_fn *fn ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2323
  tmp = channel_lookup(id);
#line 2323
  c = tmp;
#line 2324
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2325
    log("channel_register_filter: %d: bad id", id);
#line 2326
    return;
  }
#line 2328
  c->input_filter = fn;
#line 2329
  return;
}
}
#line 2331 "channels.c"
void channel_set_fds(int id , int rfd , int wfd , int efd , int extusage ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2334
  tmp = channel_lookup(id);
#line 2334
  c = tmp;
#line 2335
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2336
    fatal("channel_activate for non-larval channel %d.", id);
  } else {
#line 2335
    if (c->type != 10) {
#line 2336
      fatal("channel_activate for non-larval channel %d.", id);
    }
  }
#line 2338
  channel_register_fds(c, rfd, wfd, efd, extusage);
#line 2339
  c->type = 4;
#line 2341
  c->local_window_max = c->local_maxpacket / 2;
#line 2341
  c->local_window = c->local_window_max;
#line 2342
  packet_start(93);
#line 2343
  packet_put_int((unsigned int )c->remote_id);
#line 2344
  packet_put_int((unsigned int )c->local_window);
#line 2345
  packet_send();
#line 2346
  return;
}
}
#line 1 "cipher.o"
#line 1205 "/usr/include/bits/string2.h"
extern char *__strsep_g(char **__stringp , char const   *__delim ) ;
#line 138 "/usr/include/openssl/des.h"
extern void DES_cbc_encrypt(unsigned char const   *input , unsigned char *output ,
                            long length , DES_key_schedule *schedule , DES_cblock *ivec ,
                            int enc ) ;
#line 176
extern void DES_ede3_cbc_encrypt(unsigned char const   *input , unsigned char *output ,
                                 long length , DES_key_schedule *ks1 , DES_key_schedule *ks2 ,
                                 DES_key_schedule *ks3 , DES_cblock *ivec , int enc ) ;
#line 222
extern int DES_set_key(const_DES_cblock *key , DES_key_schedule *schedule ) ;
#line 108 "/usr/include/openssl/blowfish.h"
extern void BF_set_key(BF_KEY *key , int len , unsigned char const   *data ) ;
#line 115
extern void BF_cbc_encrypt(unsigned char const   *in , unsigned char *out , long length ,
                           BF_KEY const   *schedule , unsigned char *ivec , int enc ) ;
#line 79 "/usr/include/openssl/rc4.h"
extern void RC4_set_key(RC4_KEY *key , int len , unsigned char const   *data ) ;
#line 80
extern void RC4(RC4_KEY *key , unsigned long len , unsigned char const   *indata ,
                unsigned char *outdata ) ;
#line 87 "/usr/include/openssl/cast.h"
extern void CAST_set_key(CAST_KEY *key , int len , unsigned char const   *data ) ;
#line 92
extern void CAST_cbc_encrypt(unsigned char const   *in , unsigned char *out , long length ,
                             CAST_KEY *ks , unsigned char *iv , int enc ) ;
#line 69 "cipher.h"
unsigned int cipher_mask(void) ;
#line 71
unsigned int cipher_mask2(void) ;
#line 80
int cipher_number(char const   *name ) ;
#line 83
int ciphers_valid(char const   *names ) ;
#line 89
void cipher_set_key(CipherContext *context , int cipher , unsigned char const   *key ,
                    int keylen ) ;
#line 92
void cipher_set_key_iv(CipherContext *context , int cipher , unsigned char const   *key ,
                       int keylen , unsigned char const   *iv , int ivlen ) ;
#line 107 "/usr/include/openssl/md5.h"
extern int MD5_Init(MD5_CTX *c ) ;
#line 108
extern int MD5_Update(MD5_CTX *c , void const   *data , size_t len ) ;
#line 109
extern int MD5_Final(unsigned char *md , MD5_CTX *c ) ;
#line 37 "cipher.c"
void SSH_3CBC_ENCRYPT(DES_key_schedule ks1 , DES_key_schedule ks2 , DES_cblock *iv2 ,
                      DES_key_schedule ks3 , DES_cblock *iv3 , unsigned char *dest ,
                      unsigned char *src , unsigned int len ) 
{ DES_cblock iv1 ;

  {
#line 46
  memcpy((void * __restrict  )(& iv1), (void const   * __restrict  )iv2, 8U);
#line 48
  DES_cbc_encrypt((unsigned char const   *)src, dest, (long )len, & ks1, & iv1, 1);
#line 49
  memcpy((void * __restrict  )(& iv1), (void const   * __restrict  )((dest + len) - 8),
         8U);
#line 51
  DES_cbc_encrypt((unsigned char const   *)dest, dest, (long )len, & ks2, iv2, 0);
#line 52
  memcpy((void * __restrict  )iv2, (void const   * __restrict  )(& iv1), 8U);
#line 54
  DES_cbc_encrypt((unsigned char const   *)dest, dest, (long )len, & ks3, iv3, 1);
#line 55
  memcpy((void * __restrict  )iv3, (void const   * __restrict  )((dest + len) - 8),
         8U);
#line 56
  return;
}
}
#line 58 "cipher.c"
void SSH_3CBC_DECRYPT(DES_key_schedule ks1 , DES_key_schedule ks2 , DES_cblock *iv2 ,
                      DES_key_schedule ks3 , DES_cblock *iv3 , unsigned char *dest ,
                      unsigned char *src , unsigned int len ) 
{ DES_cblock iv1 ;

  {
#line 67
  memcpy((void * __restrict  )(& iv1), (void const   * __restrict  )iv2, 8U);
#line 69
  DES_cbc_encrypt((unsigned char const   *)src, dest, (long )len, & ks3, iv3, 0);
#line 70
  memcpy((void * __restrict  )iv3, (void const   * __restrict  )((src + len) - 8),
         8U);
#line 72
  DES_cbc_encrypt((unsigned char const   *)dest, dest, (long )len, & ks2, iv2, 1);
#line 73
  memcpy((void * __restrict  )iv2, (void const   * __restrict  )((dest + len) - 8),
         8U);
#line 75
  DES_cbc_encrypt((unsigned char const   *)dest, dest, (long )len, & ks1, & iv1, 0);
#line 78
  return;
}
}
#line 84 "cipher.c"
static void swap_bytes(unsigned char const   *src , unsigned char *dst_ , int n___0 ) 
{ u_int32_t *dst ;
  union __anonunion_t_74 t ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  u_int32_t *tmp___3 ;
  unsigned char const   *tmp___4 ;
  unsigned char const   *tmp___5 ;
  unsigned char const   *tmp___6 ;
  unsigned char const   *tmp___7 ;
  u_int32_t *tmp___8 ;

  {
#line 88
  dst = (u_int32_t *)dst_;
#line 95
  n___0 /= 8;
#line 95
  while (n___0 > 0) {
#line 96
    tmp = src;
#line 96
    src ++;
#line 96
    t.c[3] = (char )*tmp;
#line 97
    tmp___0 = src;
#line 97
    src ++;
#line 97
    t.c[2] = (char )*tmp___0;
#line 98
    tmp___1 = src;
#line 98
    src ++;
#line 98
    t.c[1] = (char )*tmp___1;
#line 99
    tmp___2 = src;
#line 99
    src ++;
#line 99
    t.c[0] = (char )*tmp___2;
#line 100
    tmp___3 = dst;
#line 100
    dst ++;
#line 100
    *tmp___3 = t.i;
#line 102
    tmp___4 = src;
#line 102
    src ++;
#line 102
    t.c[3] = (char )*tmp___4;
#line 103
    tmp___5 = src;
#line 103
    src ++;
#line 103
    t.c[2] = (char )*tmp___5;
#line 104
    tmp___6 = src;
#line 104
    src ++;
#line 104
    t.c[1] = (char )*tmp___6;
#line 105
    tmp___7 = src;
#line 105
    src ++;
#line 105
    t.c[0] = (char )*tmp___7;
#line 106
    tmp___8 = dst;
#line 106
    dst ++;
#line 106
    *tmp___8 = t.i;
#line 95
    n___0 --;
  }
#line 108
  return;
}
}
#line 114 "cipher.c"
static char *cipher_names[12]  = 
#line 114
  {      (char *)"none",      (char *)"idea",      (char *)"des",      (char *)"3des", 
        (char *)"tss",      (char *)"rc4",      (char *)"blowfish",      (char *)"reserved", 
        (char *)"blowfish-cbc",      (char *)"3des-cbc",      (char *)"arcfour",      (char *)"cast128-cbc"};
#line 136 "cipher.c"
unsigned int cipher_mask1(void) 
{ unsigned int mask ;

  {
#line 139
  mask = 0U;
#line 140
  mask |= (unsigned int )(1 << 3);
#line 141
  mask |= (unsigned int )(1 << 6);
#line 142
  return (mask);
}
}
#line 144 "cipher.c"
unsigned int cipher_mask2(void) 
{ unsigned int mask ;

  {
#line 147
  mask = 0U;
#line 148
  mask |= (unsigned int )(1 << 8);
#line 149
  mask |= (unsigned int )(1 << 9);
#line 150
  mask |= (unsigned int )(1 << 10);
#line 151
  mask |= (unsigned int )(1 << 11);
#line 152
  return (mask);
}
}
#line 154 "cipher.c"
unsigned int cipher_mask(void) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 157
  tmp = cipher_mask1();
#line 157
  tmp___0 = cipher_mask2();
#line 157
  return (tmp | tmp___0);
}
}
#line 162 "cipher.c"
char const   *cipher_name(int cipher ) 
{ 

  {
#line 165
  if (cipher < 0) {
#line 167
    fatal("cipher_name: bad cipher name: %d", cipher);
  } else {
#line 165
    if ((unsigned int )cipher >= sizeof(cipher_names) / sizeof(cipher_names[0])) {
#line 167
      fatal("cipher_name: bad cipher name: %d", cipher);
    } else {
#line 165
      if ((unsigned int )cipher_names[cipher] == (unsigned int )((void *)0)) {
#line 167
        fatal("cipher_name: bad cipher name: %d", cipher);
      }
    }
  }
#line 168
  return ((char const   *)cipher_names[cipher]);
}
}
#line 174 "cipher.c"
int ciphers_valid(char const   *names ) 
{ char *ciphers ;
  char *cp ;
  char *p ;
  int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___24 ;
  char *tmp___40 ;
  unsigned int tmp___41 ;

  {
#line 181
  if ((unsigned int )names == (unsigned int )((void *)0)) {
#line 182
    return (0);
  } else {
#line 181
    if (0) {
#line 181
      __s1_len = strlen(names);
#line 181
      __s2_len = strlen("");
#line 181
      if (! ((unsigned int )((void const   *)(names + 1)) - (unsigned int )((void const   *)names) == 1U)) {
        goto _L___0;
      } else {
#line 181
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 181
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 181
            tmp___8 = 1;
          } else {
#line 181
            if (__s2_len >= 4U) {
#line 181
              tmp___8 = 1;
            } else {
#line 181
              tmp___8 = 0;
            }
          }
        } else {
#line 181
          tmp___8 = 0;
        }
      }
#line 181
      if (tmp___8) {
#line 181
        tmp___4 = __builtin_strcmp(names, "");
      } else {
#line 181
        tmp___7 = __builtin_strcmp(names, "");
#line 181
        tmp___4 = tmp___7;
      }
    } else {
#line 181
      tmp___7 = __builtin_strcmp(names, "");
#line 181
      tmp___4 = tmp___7;
    }
#line 181
    if (tmp___4 == 0) {
#line 182
      return (0);
    }
  }
#line 183
  cp = xstrdup(names);
#line 183
  ciphers = cp;
#line 184
  tmp___24 = __strsep_g(& cp, ",");
#line 184
  p = tmp___24;
#line 184
  while (1) {
#line 184
    if (p) {
#line 184
      if (! ((int )*p != 0)) {
#line 184
        break;
      }
    } else {
#line 184
      break;
    }
#line 186
    i = cipher_number((char const   *)p);
#line 187
    if (i == -1) {
#line 188
      xfree((void *)ciphers);
#line 189
      return (0);
    } else {
#line 187
      tmp___41 = cipher_mask2();
#line 187
      if (! (tmp___41 & (unsigned int )(1 << i))) {
#line 188
        xfree((void *)ciphers);
#line 189
        return (0);
      }
    }
#line 185
    tmp___40 = __strsep_g(& cp, ",");
#line 185
    p = tmp___40;
  }
#line 192
  xfree((void *)ciphers);
#line 193
  return (1);
}
}
#line 201 "cipher.c"
int cipher_number(char const   *name ) 
{ int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 205
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 206
    return (-1);
  }
#line 207
  i = 0;
#line 207
  while ((unsigned int )i < sizeof(cipher_names) / sizeof(cipher_names[0])) {
#line 208
    if (0) {
#line 208
      __s1_len = strlen((char const   *)cipher_names[i]);
#line 208
      __s2_len = strlen(name);
#line 208
      if (! ((unsigned int )((void const   *)(cipher_names[i] + 1)) - (unsigned int )((void const   *)cipher_names[i]) == 1U)) {
        goto _L___0;
      } else {
#line 208
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 208
          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
#line 208
            tmp___8 = 1;
          } else {
#line 208
            if (__s2_len >= 4U) {
#line 208
              tmp___8 = 1;
            } else {
#line 208
              tmp___8 = 0;
            }
          }
        } else {
#line 208
          tmp___8 = 0;
        }
      }
#line 208
      if (tmp___8) {
#line 208
        tmp___4 = __builtin_strcmp((char const   *)cipher_names[i], name);
      } else {
#line 208
        tmp___7 = __builtin_strcmp((char const   *)cipher_names[i], name);
#line 208
        tmp___4 = tmp___7;
      }
    } else {
#line 208
      tmp___7 = __builtin_strcmp((char const   *)cipher_names[i], name);
#line 208
      tmp___4 = tmp___7;
    }
#line 208
    if (tmp___4 == 0) {
#line 208
      tmp___9 = cipher_mask();
#line 208
      if (tmp___9 & (unsigned int )(1 << i)) {
#line 210
        return (i);
      }
    }
#line 207
    i ++;
  }
#line 211
  return (-1);
}
}
#line 219 "cipher.c"
void cipher_set_key_string(CipherContext *context , int cipher , char const   *passphrase ) 
{ MD5_CTX md ;
  unsigned char digest___0[16] ;
  size_t tmp ;

  {
#line 225
  MD5_Init(& md);
#line 226
  tmp = strlen(passphrase);
#line 226
  MD5_Update(& md, (void const   *)((unsigned char const   *)passphrase), tmp);
#line 227
  MD5_Final(digest___0, & md);
#line 229
  cipher_set_key(context, cipher, (unsigned char const   *)(digest___0), 16);
#line 231
  memset((void *)(digest___0), 0, sizeof(digest___0));
#line 232
  memset((void *)(& md), 0, sizeof(md));
#line 233
  return;
}
}
#line 237 "cipher.c"
void cipher_set_key(CipherContext *context , int cipher , unsigned char const   *key ,
                    int keylen ) 
{ unsigned char padded[32] ;
  unsigned int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 244
  context->type = (unsigned int )cipher;
#line 248
  memset((void *)(padded), 0, sizeof(padded));
#line 249
  if ((unsigned int )keylen < sizeof(padded)) {
#line 249
    tmp = (unsigned int )keylen;
  } else {
#line 249
    tmp = sizeof(padded);
  }
#line 249
  memcpy((void * __restrict  )(padded), (void const   * __restrict  )key, tmp);
#line 252
  switch (cipher) {
  case 0: 
#line 258
  break;
  case 3: 
#line 266
  if (keylen < 16) {
#line 267
    error("Key length %d is insufficient for 3DES.", keylen);
  }
#line 268
  DES_set_key((const_DES_cblock *)((void *)(padded)), & context->u.des3.key1);
#line 269
  DES_set_key((const_DES_cblock *)((void *)(padded + 8)), & context->u.des3.key2);
#line 270
  if (keylen <= 16) {
#line 271
    DES_set_key((const_DES_cblock *)((void *)(padded)), & context->u.des3.key3);
  } else {
#line 273
    DES_set_key((const_DES_cblock *)((void *)(padded + 16)), & context->u.des3.key3);
  }
#line 274
  memset((void *)(context->u.des3.iv2), 0, sizeof(context->u.des3.iv2));
#line 275
  memset((void *)(context->u.des3.iv3), 0, sizeof(context->u.des3.iv3));
#line 276
  break;
  case 6: 
#line 279
  if (keylen < 16) {
#line 280
    error("Key length %d is insufficient for blowfish.", keylen);
  }
#line 281
  BF_set_key(& context->u.bf.key, keylen, (unsigned char const   *)(padded));
#line 282
  memset((void *)(context->u.bf.iv), 0, 8U);
#line 283
  break;
  case 9: 
  case 8: 
  case 10: 
  case 11: 
#line 289
  tmp___0 = cipher_name(cipher);
#line 289
  fatal("cipher_set_key: illegal cipher: %s", tmp___0);
#line 290
  break;
  default: 
#line 293
  tmp___1 = cipher_name(cipher);
#line 293
  fatal("cipher_set_key: unknown cipher: %s", tmp___1);
  }
#line 295
  memset((void *)(padded), 0, sizeof(padded));
#line 296
  return;
}
}
#line 298 "cipher.c"
void cipher_set_key_iv(CipherContext *context , int cipher , unsigned char const   *key ,
                       int keylen , unsigned char const   *iv , int ivlen ) 
{ char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 304
  context->type = (unsigned int )cipher;
#line 307
  switch (cipher) {
  case 0: 
#line 309
  break;
  case 3: 
  case 6: 
#line 313
  tmp = cipher_name(cipher);
#line 313
  fatal("cipher_set_key_iv: illegal cipher: %s", tmp);
#line 314
  break;
  case 9: 
#line 317
  if (keylen < 24) {
#line 318
    error("Key length %d is insufficient for 3des-cbc.", keylen);
  }
#line 319
  DES_set_key((const_DES_cblock *)((void *)key), & context->u.des3.key1);
#line 320
  DES_set_key((const_DES_cblock *)((void *)(key + 8)), & context->u.des3.key2);
#line 321
  DES_set_key((const_DES_cblock *)((void *)(key + 16)), & context->u.des3.key3);
#line 322
  if (ivlen < 8) {
#line 323
    error("IV length %d is insufficient for 3des-cbc.", ivlen);
  }
#line 324
  memcpy((void * __restrict  )(context->u.des3.iv3), (void const   * __restrict  )((char *)iv),
         8U);
#line 325
  break;
  case 8: 
#line 328
  if (keylen < 16) {
#line 329
    error("Key length %d is insufficient for blowfish.", keylen);
  }
#line 330
  if (ivlen < 8) {
#line 331
    error("IV length %d is insufficient for blowfish.", ivlen);
  }
#line 332
  BF_set_key(& context->u.bf.key, keylen, (unsigned char const   *)((unsigned char *)key));
#line 333
  memcpy((void * __restrict  )(context->u.bf.iv), (void const   * __restrict  )((char *)iv),
         8U);
#line 334
  break;
  case 10: 
#line 337
  if (keylen < 16) {
#line 338
    error("Key length %d is insufficient for arcfour.", keylen);
  }
#line 339
  RC4_set_key(& context->u.rc4, keylen, (unsigned char const   *)((unsigned char *)key));
#line 340
  break;
  case 11: 
#line 343
  if (keylen < 16) {
#line 344
    error("Key length %d is insufficient for cast128.", keylen);
  }
#line 345
  if (ivlen < 8) {
#line 346
    error("IV length %d is insufficient for cast128.", ivlen);
  }
#line 347
  CAST_set_key(& context->u.cast.key, keylen, (unsigned char const   *)((unsigned char *)key));
#line 348
  memcpy((void * __restrict  )(context->u.cast.iv), (void const   * __restrict  )((char *)iv),
         8U);
#line 349
  break;
  default: 
#line 352
  tmp___0 = cipher_name(cipher);
#line 352
  fatal("cipher_set_key: unknown cipher: %s", tmp___0);
  }
#line 354
  return;
}
}
#line 358 "cipher.c"
void cipher_encrypt(CipherContext *context , unsigned char *dest , unsigned char const   *src ,
                    unsigned int len ) 
{ char const   *tmp ;

  {
#line 362
  if ((len & 7U) != 0U) {
#line 363
    fatal("cipher_encrypt: bad plaintext length %d", len);
  }
#line 365
  switch ((int )context->type) {
  case 0: 
#line 367
  memcpy((void * __restrict  )dest, (void const   * __restrict  )src, len);
#line 368
  break;
  case 3: 
#line 371
  SSH_3CBC_ENCRYPT(context->u.des3.key1, context->u.des3.key2, & context->u.des3.iv2,
                   context->u.des3.key3, & context->u.des3.iv3, dest, (unsigned char *)src,
                   len);
#line 375
  break;
  case 6: 
#line 378
  swap_bytes(src, dest, (int )len);
#line 379
  BF_cbc_encrypt((unsigned char const   *)dest, dest, (long )len, (BF_KEY const   *)(& context->u.bf.key),
                 context->u.bf.iv, 1);
#line 382
  swap_bytes((unsigned char const   *)dest, dest, (int )len);
#line 383
  break;
  case 8: 
#line 386
  BF_cbc_encrypt((unsigned char const   *)((void *)src), dest, (long )len, (BF_KEY const   *)(& context->u.bf.key),
                 context->u.bf.iv, 1);
#line 389
  break;
  case 9: 
#line 392
  DES_ede3_cbc_encrypt(src, dest, (long )len, & context->u.des3.key1, & context->u.des3.key2,
                       & context->u.des3.key3, & context->u.des3.iv3, 1);
#line 395
  break;
  case 10: 
#line 398
  RC4(& context->u.rc4, (unsigned long )len, (unsigned char const   *)((unsigned char *)src),
      dest);
#line 399
  break;
  case 11: 
#line 402
  CAST_cbc_encrypt(src, dest, (long )len, & context->u.cast.key, context->u.cast.iv,
                   1);
#line 404
  break;
  default: 
#line 407
  tmp = cipher_name((int )context->type);
#line 407
  fatal("cipher_encrypt: unknown cipher: %s", tmp);
  }
#line 409
  return;
}
}
#line 413 "cipher.c"
void cipher_decrypt(CipherContext *context , unsigned char *dest , unsigned char const   *src ,
                    unsigned int len ) 
{ char const   *tmp ;

  {
#line 417
  if ((len & 7U) != 0U) {
#line 418
    fatal("cipher_decrypt: bad ciphertext length %d", len);
  }
#line 420
  switch ((int )context->type) {
  case 0: 
#line 422
  memcpy((void * __restrict  )dest, (void const   * __restrict  )src, len);
#line 423
  break;
  case 3: 
#line 426
  SSH_3CBC_DECRYPT(context->u.des3.key1, context->u.des3.key2, & context->u.des3.iv2,
                   context->u.des3.key3, & context->u.des3.iv3, dest, (unsigned char *)src,
                   len);
#line 430
  break;
  case 6: 
#line 433
  swap_bytes(src, dest, (int )len);
#line 434
  BF_cbc_encrypt((unsigned char const   *)((void *)dest), dest, (long )len, (BF_KEY const   *)(& context->u.bf.key),
                 context->u.bf.iv, 0);
#line 437
  swap_bytes((unsigned char const   *)dest, dest, (int )len);
#line 438
  break;
  case 8: 
#line 441
  BF_cbc_encrypt((unsigned char const   *)((void *)src), dest, (long )len, (BF_KEY const   *)(& context->u.bf.key),
                 context->u.bf.iv, 0);
#line 444
  break;
  case 9: 
#line 447
  DES_ede3_cbc_encrypt(src, dest, (long )len, & context->u.des3.key1, & context->u.des3.key2,
                       & context->u.des3.key3, & context->u.des3.iv3, 0);
#line 450
  break;
  case 10: 
#line 453
  RC4(& context->u.rc4, (unsigned long )len, (unsigned char const   *)((unsigned char *)src),
      dest);
#line 454
  break;
  case 11: 
#line 457
  CAST_cbc_encrypt(src, dest, (long )len, & context->u.cast.key, context->u.cast.iv,
                   0);
#line 459
  break;
  default: 
#line 462
  tmp = cipher_name((int )context->type);
#line 462
  fatal("cipher_decrypt: unknown cipher: %s", tmp);
  }
#line 464
  return;
}
}
#line 1 "compat.o"
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 45 "compat.h"
void enable_compat13(void) ;
#line 46
void enable_compat20(void) ;
#line 47
void compat_datafellows(char const   *version ) ;
#line 48
int proto_spec(char const   *spec ) ;
#line 38 "compat.c"
int compat13  =    0;
#line 39 "compat.c"
int compat20  =    0;
#line 40 "compat.c"
int datafellows  =    0;
#line 42 "compat.c"
void enable_compat20(void) 
{ 

  {
#line 45
  verbose("Enabling compatibility mode for protocol 2.0");
#line 46
  compat20 = 1;
#line 47
  return;
}
}
#line 48 "compat.c"
void enable_compat13(void) 
{ 

  {
#line 51
  verbose("Enabling compatibility mode for protocol 1.3");
#line 52
  compat13 = 1;
#line 53
  return;
}
}
#line 55 "compat.c"
void compat_datafellows(char const   *version ) 
{ int i ;
  size_t len ;
  struct __anonstruct_check_74 check___1[4] ;
  size_t tmp ;
  int tmp___13 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___19 ;
  int tmp___22 ;
  int tmp___23 ;

  {
#line 60
  check___1[0].version = (char *)"2.1.0";
#line 60
  check___1[0].bugs = 5;
#line 60
  check___1[1].version = (char *)"2.0.1";
#line 60
  check___1[1].bugs = 15;
#line 60
  check___1[2].version = (char *)"2.";
#line 60
  check___1[2].bugs = 20;
#line 60
  check___1[3].version = (char *)((void *)0);
#line 60
  check___1[3].bugs = 0;
#line 70
  i = 0;
#line 70
  while (check___1[i].version) {
#line 71
    len = strlen((char const   *)check___1[i].version);
#line 72
    tmp = strlen(version);
#line 73
    if (tmp >= len) {
#line 73
      if (0) {
#line 73
        if (0) {
#line 73
          __s1_len___0 = strlen(version);
#line 73
          __s2_len___0 = strlen((char const   *)check___1[i].version);
#line 73
          if (! ((unsigned int )((void const   *)(version + 1)) - (unsigned int )((void const   *)version) == 1U)) {
            goto _L___2;
          } else {
#line 73
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 73
              if (! ((unsigned int )((void const   *)(check___1[i].version + 1)) - (unsigned int )((void const   *)check___1[i].version) == 1U)) {
#line 73
                tmp___23 = 1;
              } else {
#line 73
                if (__s2_len___0 >= 4U) {
#line 73
                  tmp___23 = 1;
                } else {
#line 73
                  tmp___23 = 0;
                }
              }
            } else {
#line 73
              tmp___23 = 0;
            }
          }
#line 73
          if (tmp___23) {
#line 73
            tmp___19 = __builtin_strcmp(version, (char const   *)check___1[i].version);
          } else {
#line 73
            tmp___22 = __builtin_strcmp(version, (char const   *)check___1[i].version);
#line 73
            tmp___19 = tmp___22;
          }
        } else {
#line 73
          tmp___22 = __builtin_strcmp(version, (char const   *)check___1[i].version);
#line 73
          tmp___19 = tmp___22;
        }
#line 73
        tmp___13 = tmp___19;
      } else {
#line 73
        tmp___13 = strncmp(version, (char const   *)check___1[i].version, len);
      }
#line 73
      if (tmp___13 == 0) {
#line 74
        verbose("datafellows: %.200s", version);
#line 75
        datafellows = check___1[i].bugs;
#line 76
        return;
      }
    }
#line 70
    i ++;
  }
#line 79
  return;
}
}
#line 82 "compat.c"
int proto_spec(char const   *spec ) 
{ char *s ;
  char *p ;
  char *q ;
  int ret ;
  char *tmp___14 ;
  char *tmp___30 ;
  int tmp___31 ;

  {
#line 86
  ret = 0;
#line 88
  if ((unsigned int )spec == (unsigned int )((void *)0)) {
#line 89
    return (ret);
  }
#line 90
  s = xstrdup(spec);
#line 90
  q = s;
#line 91
  tmp___14 = __strsep_g(& q, ",");
#line 91
  p = tmp___14;
#line 91
  while (1) {
#line 91
    if (p) {
#line 91
      if (! ((int )*p != 0)) {
#line 91
        break;
      }
    } else {
#line 91
      break;
    }
#line 92
    tmp___31 = atoi((char const   *)p);
#line 92
    switch (tmp___31) {
    case 1: 
#line 94
    if (ret == 0) {
#line 95
      ret |= 2;
    }
#line 96
    ret |= 1;
#line 97
    break;
    case 2: 
#line 99
    ret |= 4;
#line 100
    break;
    default: 
#line 102
    log("ignoring bad proto spec: \'%s\'.", p);
#line 103
    break;
    }
#line 91
    tmp___30 = __strsep_g(& q, ",");
#line 91
    p = tmp___30;
  }
#line 106
  xfree((void *)s);
#line 107
  return (ret);
}
}
#line 1 "compress.o"
#line 242 "/usr/include/zlib.h"
extern int deflate(z_streamp strm , int flush ) ;
#line 328
extern int deflateEnd(z_streamp strm ) ;
#line 363
extern int inflate(z_streamp strm , int flush ) ;
#line 462
extern int inflateEnd(z_streamp strm ) ;
#line 1317
extern int deflateInit_(z_streamp strm , int level , char const   *version , int stream_size ) ;
#line 1319
extern int inflateInit_(z_streamp strm , char const   *version , int stream_size ) ;
#line 23 "compress.c"
static z_stream incoming_stream  ;
#line 24 "compress.c"
static z_stream outgoing_stream  ;
#line 31 "compress.c"
void buffer_compress_init(int level ) 
{ 

  {
#line 34
  debug("Enabling compression at level %d.", level);
#line 35
  if (level < 1) {
#line 36
    fatal("Bad compression level %d.", level);
  } else {
#line 35
    if (level > 9) {
#line 36
      fatal("Bad compression level %d.", level);
    }
  }
#line 37
  inflateInit_(& incoming_stream, "1.2.3", (int )sizeof(z_stream ));
#line 38
  deflateInit_(& outgoing_stream, level, "1.2.3", (int )sizeof(z_stream ));
#line 39
  return;
}
}
#line 43 "compress.c"
void buffer_compress_uninit(void) 
{ double tmp ;
  double tmp___0 ;

  {
#line 46
  if (outgoing_stream.total_in == 0UL) {
#line 46
    tmp = 0.0;
  } else {
#line 46
    tmp = (double )outgoing_stream.total_out / (double )outgoing_stream.total_in;
  }
#line 46
  debug("compress outgoing: raw data %lu, compressed %lu, factor %.2f", outgoing_stream.total_in,
        outgoing_stream.total_out, tmp);
#line 50
  if (incoming_stream.total_out == 0UL) {
#line 50
    tmp___0 = 0.0;
  } else {
#line 50
    tmp___0 = (double )incoming_stream.total_in / (double )incoming_stream.total_out;
  }
#line 50
  debug("compress incoming: raw data %lu, compressed %lu, factor %.2f", incoming_stream.total_out,
        incoming_stream.total_in, tmp___0);
#line 54
  inflateEnd(& incoming_stream);
#line 55
  deflateEnd(& outgoing_stream);
#line 56
  return;
}
}
#line 67 "compress.c"
void buffer_compress(Buffer *input_buffer , Buffer *output_buffer ) 
{ char buf___1[4096] ;
  int status ;
  unsigned int tmp ;
  char *tmp___0 ;

  {
#line 74
  tmp = buffer_len(input_buffer);
#line 74
  if (tmp == 0U) {
#line 75
    return;
  }
#line 78
  tmp___0 = buffer_ptr(input_buffer);
#line 78
  outgoing_stream.next_in = (unsigned char *)tmp___0;
#line 79
  outgoing_stream.avail_in = buffer_len(input_buffer);
#line 82
  while (1) {
#line 84
    outgoing_stream.next_out = (unsigned char *)(buf___1);
#line 85
    outgoing_stream.avail_out = sizeof(buf___1);
#line 88
    status = deflate(& outgoing_stream, 1);
#line 89
    switch (status) {
    case 0: 
#line 92
    buffer_append(output_buffer, (char const   *)(buf___1), sizeof(buf___1) - outgoing_stream.avail_out);
#line 94
    break;
    default: 
#line 96
    fatal("buffer_compress: deflate returned %d", status);
    }
#line 82
    if (! (outgoing_stream.avail_out == 0U)) {
#line 82
      break;
    }
  }
#line 100
  return;
}
}
#line 111 "compress.c"
void buffer_uncompress(Buffer *input_buffer , Buffer *output_buffer ) 
{ char buf___1[4096] ;
  int status ;
  char *tmp ;

  {
#line 117
  tmp = buffer_ptr(input_buffer);
#line 117
  incoming_stream.next_in = (unsigned char *)tmp;
#line 118
  incoming_stream.avail_in = buffer_len(input_buffer);
#line 120
  while (1) {
#line 122
    incoming_stream.next_out = (unsigned char *)(buf___1);
#line 123
    incoming_stream.avail_out = sizeof(buf___1);
#line 125
    status = inflate(& incoming_stream, 1);
#line 126
    switch (status) {
    case 0: 
#line 128
    buffer_append(output_buffer, (char const   *)(buf___1), sizeof(buf___1) - incoming_stream.avail_out);
#line 130
    break;
    case -5: 
#line 137
    return;
    default: 
#line 139
    fatal("buffer_uncompress: inflate returned %d", status);
    }
  }
}
}
#line 1 "crc32.o"
#line 25 "crc32.h"
unsigned int ssh_crc32(unsigned char const   *s , unsigned int len ) ;
#line 53 "crc32.c"
static unsigned int crc32_tab[256]  = 
#line 53 "crc32.c"
  {      0U,      1996959894U,      3993919788U,      2567524794U, 
        124634137U,      1886057615U,      3915621685U,      2657392035U, 
        249268274U,      2044508324U,      3772115230U,      2547177864U, 
        162941995U,      2125561021U,      3887607047U,      2428444049U, 
        498536548U,      1789927666U,      4089016648U,      2227061214U, 
        450548861U,      1843258603U,      4107580753U,      2211677639U, 
        325883990U,      1684777152U,      4251122042U,      2321926636U, 
        335633487U,      1661365465U,      4195302755U,      2366115317U, 
        997073096U,      1281953886U,      3579855332U,      2724688242U, 
        1006888145U,      1258607687U,      3524101629U,      2768942443U, 
        901097722U,      1119000684U,      3686517206U,      2898065728U, 
        853044451U,      1172266101U,      3705015759U,      2882616665U, 
        651767980U,      1373503546U,      3369554304U,      3218104598U, 
        565507253U,      1454621731U,      3485111705U,      3099436303U, 
        671266974U,      1594198024U,      3322730930U,      2970347812U, 
        795835527U,      1483230225U,      3244367275U,      3060149565U, 
        1994146192U,      31158534U,      2563907772U,      4023717930U, 
        1907459465U,      112637215U,      2680153253U,      3904427059U, 
        2013776290U,      251722036U,      2517215374U,      3775830040U, 
        2137656763U,      141376813U,      2439277719U,      3865271297U, 
        1802195444U,      476864866U,      2238001368U,      4066508878U, 
        1812370925U,      453092731U,      2181625025U,      4111451223U, 
        1706088902U,      314042704U,      2344532202U,      4240017532U, 
        1658658271U,      366619977U,      2362670323U,      4224994405U, 
        1303535960U,      984961486U,      2747007092U,      3569037538U, 
        1256170817U,      1037604311U,      2765210733U,      3554079995U, 
        1131014506U,      879679996U,      2909243462U,      3663771856U, 
        1141124467U,      855842277U,      2852801631U,      3708648649U, 
        1342533948U,      654459306U,      3188396048U,      3373015174U, 
        1466479909U,      544179635U,      3110523913U,      3462522015U, 
        1591671054U,      702138776U,      2966460450U,      3352799412U, 
        1504918807U,      783551873U,      3082640443U,      3233442989U, 
        3988292384U,      2596254646U,      62317068U,      1957810842U, 
        3939845945U,      2647816111U,      81470997U,      1943803523U, 
        3814918930U,      2489596804U,      225274430U,      2053790376U, 
        3826175755U,      2466906013U,      167816743U,      2097651377U, 
        4027552580U,      2265490386U,      503444072U,      1762050814U, 
        4150417245U,      2154129355U,      426522225U,      1852507879U, 
        4275313526U,      2312317920U,      282753626U,      1742555852U, 
        4189708143U,      2394877945U,      397917763U,      1622183637U, 
        3604390888U,      2714866558U,      953729732U,      1340076626U, 
        3518719985U,      2797360999U,      1068828381U,      1219638859U, 
        3624741850U,      2936675148U,      906185462U,      1090812512U, 
        3747672003U,      2825379669U,      829329135U,      1181335161U, 
        3412177804U,      3160834842U,      628085408U,      1382605366U, 
        3423369109U,      3138078467U,      570562233U,      1426400815U, 
        3317316542U,      2998733608U,      733239954U,      1555261956U, 
        3268935591U,      3050360625U,      752459403U,      1541320221U, 
        2607071920U,      3965973030U,      1969922972U,      40735498U, 
        2617837225U,      3943577151U,      1913087877U,      83908371U, 
        2512341634U,      3803740692U,      2075208622U,      213261112U, 
        2463272603U,      3855990285U,      2094854071U,      198958881U, 
        2262029012U,      4057260610U,      1759359992U,      534414190U, 
        2176718541U,      4139329115U,      1873836001U,      414664567U, 
        2282248934U,      4279200368U,      1711684554U,      285281116U, 
        2405801727U,      4167216745U,      1634467795U,      376229701U, 
        2685067896U,      3608007406U,      1308918612U,      956543938U, 
        2808555105U,      3495958263U,      1231636301U,      1047427035U, 
        2932959818U,      3654703836U,      1088359270U,      936918000U, 
        2847714899U,      3736837829U,      1202900863U,      817233897U, 
        3183342108U,      3401237130U,      1404277552U,      615818150U, 
        3134207493U,      3453421203U,      1423857449U,      601450431U, 
        3009837614U,      3294710456U,      1567103746U,      711928724U, 
        3020668471U,      3272380065U,      1510334235U,      755167117U};
#line 110 "crc32.c"
unsigned int ssh_crc32(unsigned char const   *s , unsigned int len ) 
{ unsigned int i ;
  unsigned int crc32val ;

  {
#line 116
  crc32val = 0U;
#line 117
  i = 0U;
#line 117
  while (i < len) {
#line 118
    crc32val = crc32_tab[(crc32val ^ (unsigned int )*(s + i)) & 255U] ^ (crc32val >> 8);
#line 117
    i ++;
  }
#line 120
  return (crc32val);
}
}
#line 1 "deattack.o"
#line 27 "deattack.h"
int detect_attack(unsigned char *buf___1 , u_int32_t len , unsigned char *IV ) ;
#line 49 "deattack.c"
void crc_update(u_int32_t *a , u_int32_t b ) 
{ 

  {
#line 52
  b ^= *a;
#line 53
  *a = ssh_crc32((unsigned char const   *)((unsigned char *)(& b)), sizeof(b));
#line 54
  return;
}
}
#line 57 "deattack.c"
int check_crc(unsigned char *S , unsigned char *buf___1 , u_int32_t len , unsigned char *IV ) 
{ u_int32_t crc ;
  unsigned char *c ;
  int tmp ;
  int tmp___0 ;

  {
#line 64
  crc = 0U;
#line 65
  if (IV) {
#line 65
    tmp = memcmp((void const   *)S, (void const   *)IV, 8U);
#line 65
    if (! tmp) {
#line 66
      crc_update(& crc, 1U);
#line 67
      crc_update(& crc, 0U);
    }
  }
#line 69
  c = buf___1;
#line 69
  while ((unsigned int )c < (unsigned int )(buf___1 + len)) {
#line 70
    tmp___0 = memcmp((void const   *)S, (void const   *)c, 8U);
#line 70
    if (tmp___0) {
#line 74
      crc_update(& crc, 0U);
#line 75
      crc_update(& crc, 0U);
    } else {
#line 71
      crc_update(& crc, 1U);
#line 72
      crc_update(& crc, 0U);
    }
#line 69
    c += 8;
  }
#line 78
  return (crc == 0U);
}
}
#line 86 "deattack.c"
static u_int16_t *h  =    (u_int16_t *)((void *)0);
#line 87 "deattack.c"
static u_int16_t n  =    (u_int16_t )4096;
#line 83 "deattack.c"
int detect_attack(unsigned char *buf___1 , u_int32_t len , unsigned char *IV ) 
{ register u_int32_t i ;
  register u_int32_t j ;
  u_int32_t l ;
  register unsigned char *c ;
  unsigned char *d ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 93
  if (len > 262144U) {
#line 95
    fatal("detect_attack: bad length %d", len);
  } else {
#line 93
    if (len % 8U != 0U) {
#line 95
      fatal("detect_attack: bad length %d", len);
    }
  }
#line 97
  l = (unsigned int )n;
#line 97
  while (l < ((len / 8U) * 3U) / 2U) {
#line 97
    l <<= 2;
  }
#line 100
  if ((unsigned int )h == (unsigned int )((void *)0)) {
#line 101
    debug("Installing crc compensation attack detector.");
#line 102
    n = (unsigned short )l;
#line 103
    tmp = xmalloc((unsigned int )((int )n * 2));
#line 103
    h = (u_int16_t *)tmp;
  } else {
#line 105
    if (l > (u_int32_t )n) {
#line 106
      n = (unsigned short )l;
#line 107
      tmp___0 = xrealloc((void *)h, (unsigned int )((int )n * 2));
#line 107
      h = (u_int16_t *)tmp___0;
    }
  }
#line 111
  if (len <= 56U) {
#line 112
    c = buf___1;
#line 112
    while ((unsigned int )c < (unsigned int )(buf___1 + len)) {
#line 113
      if (IV) {
#line 113
        tmp___2 = memcmp((void const   *)c, (void const   *)IV, 8U);
#line 113
        if (! tmp___2) {
#line 114
          tmp___1 = check_crc(c, buf___1, len, (unsigned char *)IV);
#line 114
          if (tmp___1) {
#line 115
            return (1);
          } else {
#line 117
            break;
          }
        }
      }
#line 119
      d = buf___1;
#line 119
      while ((unsigned int )d < (unsigned int )c) {
#line 120
        tmp___4 = memcmp((void const   *)c, (void const   *)d, 8U);
#line 120
        if (! tmp___4) {
#line 121
          tmp___3 = check_crc(c, buf___1, len, (unsigned char *)IV);
#line 121
          if (tmp___3) {
#line 122
            return (1);
          } else {
#line 124
            break;
          }
        }
#line 119
        d += 8;
      }
#line 112
      c += 8;
    }
#line 128
    return (0);
  }
#line 130
  memset((void *)h, 255, (unsigned int )((int )n * 2));
#line 132
  if (IV) {
#line 133
    *(h + ((((((unsigned long )*(IV + 0) << 24) | ((unsigned long )*(IV + 1) << 16)) | ((unsigned long )*(IV + 2) << 8)) | (unsigned long )*(IV + 3)) & (unsigned long )((int )n - 1))) = (unsigned short)65534;
  }
#line 135
  c = buf___1;
#line 135
  j = 0U;
#line 135
  while ((unsigned int )c < (unsigned int )(buf___1 + len)) {
#line 136
    i = (unsigned int )((((((unsigned long )*(c + 0) << 24) | ((unsigned long )*(c + 1) << 16)) | ((unsigned long )*(c + 2) << 8)) | (unsigned long )*(c + 3)) & (unsigned long )((int )n - 1));
#line 136
    while ((int )*(h + i) != 65535) {
#line 138
      if ((int )*(h + i) == 65534) {
#line 139
        tmp___6 = memcmp((void const   *)c, (void const   *)IV, 8U);
#line 139
        if (! tmp___6) {
#line 140
          tmp___5 = check_crc(c, buf___1, len, (unsigned char *)IV);
#line 140
          if (tmp___5) {
#line 141
            return (1);
          } else {
#line 143
            break;
          }
        }
      } else {
#line 145
        tmp___8 = memcmp((void const   *)c, (void const   *)(buf___1 + (int )*(h + i) * 8),
                         8U);
#line 145
        if (! tmp___8) {
#line 146
          tmp___7 = check_crc(c, buf___1, len, (unsigned char *)IV);
#line 146
          if (tmp___7) {
#line 147
            return (1);
          } else {
#line 149
            break;
          }
        }
      }
#line 136
      i = (i + 1U) & (unsigned int )((int )n - 1);
    }
#line 152
    *(h + i) = (unsigned short )j;
#line 135
    c += 8;
#line 135
    j ++;
  }
#line 154
  return (0);
}
}
#line 1 "dispatch.o"
#line 8 "dispatch.h"
void dispatch_init(dispatch_fn *dflt ) ;
#line 9
void dispatch_set(int type , dispatch_fn *fn ) ;
#line 10
void dispatch_run(int mode , int *done ) ;
#line 11
void dispatch_protocol_error(int type , int plen ) ;
#line 100 "packet.h"
int packet_read(int *payload_len_ptr ) ;
#line 116
int packet_read_poll(int *payload_len_ptr ) ;
#line 38 "dispatch.c"
dispatch_fn *dispatch[255]  ;
#line 40 "dispatch.c"
void dispatch_protocol_error(int type , int plen ) 
{ 

  {
#line 43
  error("Hm, dispatch protocol error: type %d plen %d", type, plen);
#line 44
  return;
}
}
#line 45 "dispatch.c"
void dispatch_init(dispatch_fn *dflt ) 
{ int i ;

  {
#line 49
  i = 0;
#line 49
  while (i < 255) {
#line 50
    dispatch[i] = dflt;
#line 49
    i ++;
  }
#line 51
  return;
}
}
#line 52 "dispatch.c"
void dispatch_set(int type , dispatch_fn *fn ) 
{ 

  {
#line 55
  dispatch[type] = fn;
#line 56
  return;
}
}
#line 57 "dispatch.c"
void dispatch_run(int mode , int *done ) 
{ int plen ;
  int type ;

  {
#line 60
  while (1) {
#line 64
    if (mode == 0) {
#line 65
      type = packet_read(& plen);
    } else {
#line 67
      type = packet_read_poll(& plen);
#line 68
      if (type == 0) {
#line 69
        return;
      }
    }
#line 71
    if (type > 0) {
#line 71
      if (type < 255) {
#line 71
        if ((unsigned int )dispatch[type] != (unsigned int )((void *)0)) {
#line 72
          (*(dispatch[type]))(type, plen);
        } else {
#line 74
          packet_disconnect("protocol error: rcvd type %d", type);
        }
      } else {
#line 74
        packet_disconnect("protocol error: rcvd type %d", type);
      }
    } else {
#line 74
      packet_disconnect("protocol error: rcvd type %d", type);
    }
#line 75
    if ((unsigned int )done != (unsigned int )((void *)0)) {
#line 75
      if (*done) {
#line 76
        return;
      }
    }
  }
}
}
#line 1 "dsa.o"
#line 175 "/usr/include/openssl/dsa.h"
extern DSA_SIG *DSA_SIG_new(void) ;
#line 176
extern void DSA_SIG_free(DSA_SIG *a ) ;
#line 180
extern DSA_SIG *DSA_do_sign(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
#line 181
extern int DSA_do_verify(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                         DSA *dsa ) ;
#line 213
extern DSA *DSA_generate_parameters(int bits , unsigned char *seed , int seed_len ,
                                    int *counter_ret , unsigned long *h_ret , void (*callback)(int  ,
                                                                                               int  ,
                                                                                               void * ) ,
                                    void *cb_arg ) ;
#line 224
extern int DSA_generate_key(DSA *a ) ;
#line 491 "/usr/include/openssl/evp.h"
extern int EVP_DigestUpdate(EVP_MD_CTX *ctx , void const   *d , size_t cnt ) ;
#line 498
extern int EVP_DigestInit(EVP_MD_CTX *ctx , EVP_MD const   *type ) ;
#line 499
extern int EVP_DigestFinal(EVP_MD_CTX *ctx , unsigned char *md , unsigned int *s ) ;
#line 597
extern EVP_MD const   *EVP_sha1(void) ;
#line 55 "dsa.c"
Key *dsa_key_from_blob(char *blob , int blen ) 
{ Buffer b ;
  char *ktype ;
  int rlen ;
  DSA *dsa ;
  Key *key ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 68
  buffer_init(& b);
#line 69
  buffer_append(& b, (char const   *)blob, (unsigned int )blen);
#line 70
  ktype = buffer_get_string(& b, (unsigned int *)((void *)0));
#line 71
  if (0) {
#line 71
    __s1_len = strlen("ssh-dss");
#line 71
    __s2_len = strlen((char const   *)ktype);
#line 71
    if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
      goto _L___0;
    } else {
#line 71
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 71
        if (! ((unsigned int )((void const   *)(ktype + 1)) - (unsigned int )((void const   *)ktype) == 1U)) {
#line 71
          tmp___8 = 1;
        } else {
#line 71
          if (__s2_len >= 4U) {
#line 71
            tmp___8 = 1;
          } else {
#line 71
            tmp___8 = 0;
          }
        }
      } else {
#line 71
        tmp___8 = 0;
      }
    }
#line 71
    if (tmp___8) {
#line 71
      tmp___4 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
    } else {
#line 71
      tmp___7 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
#line 71
      tmp___4 = tmp___7;
    }
  } else {
#line 71
    tmp___7 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
#line 71
    tmp___4 = tmp___7;
  }
#line 71
  if (tmp___4 != 0) {
#line 72
    error("dsa_key_from_blob: cannot handle type %s", ktype);
#line 73
    buffer_free(& b);
#line 74
    xfree((void *)ktype);
#line 75
    return ((Key *)((void *)0));
  }
#line 77
  key = key_new(1);
#line 78
  dsa = key->dsa;
#line 79
  buffer_get_bignum2(& b, dsa->p);
#line 80
  buffer_get_bignum2(& b, dsa->q);
#line 81
  buffer_get_bignum2(& b, dsa->g);
#line 82
  buffer_get_bignum2(& b, dsa->pub_key);
#line 83
  tmp___9 = buffer_len(& b);
#line 83
  rlen = (int )tmp___9;
#line 84
  if (rlen != 0) {
#line 85
    error("dsa_key_from_blob: remaining bytes in key blob %d", rlen);
  }
#line 86
  buffer_free(& b);
#line 87
  xfree((void *)ktype);
#line 92
  return (key);
}
}
#line 94 "dsa.c"
int dsa_make_key_blob(Key *key , unsigned char **blobp , unsigned int *lenp ) 
{ Buffer b ;
  int len ;
  unsigned char *buf___1 ;
  unsigned int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 101
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 102
    return (0);
  } else {
#line 101
    if (key->type != 1) {
#line 102
      return (0);
    }
  }
#line 103
  buffer_init(& b);
#line 104
  buffer_put_cstring(& b, "ssh-dss");
#line 105
  buffer_put_bignum2(& b, (key->dsa)->p);
#line 106
  buffer_put_bignum2(& b, (key->dsa)->q);
#line 107
  buffer_put_bignum2(& b, (key->dsa)->g);
#line 108
  buffer_put_bignum2(& b, (key->dsa)->pub_key);
#line 109
  tmp = buffer_len(& b);
#line 109
  len = (int )tmp;
#line 110
  tmp___0 = xmalloc((unsigned int )len);
#line 110
  buf___1 = (unsigned char *)tmp___0;
#line 111
  tmp___1 = buffer_ptr(& b);
#line 111
  memcpy((void * __restrict  )buf___1, (void const   * __restrict  )tmp___1, (unsigned int )len);
#line 112
  tmp___2 = buffer_ptr(& b);
#line 112
  memset((void *)tmp___2, 0, (unsigned int )len);
#line 113
  buffer_free(& b);
#line 114
  if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 115
    *lenp = (unsigned int )len;
  }
#line 116
  if ((unsigned int )blobp != (unsigned int )((void *)0)) {
#line 117
    *blobp = buf___1;
  }
#line 118
  return (len);
}
}
#line 120 "dsa.c"
int dsa_sign(Key *key , unsigned char **sigp , int *lenp , unsigned char *data , int datalen ) 
{ unsigned char *digest___0 ;
  unsigned char *ret ;
  DSA_SIG *sig ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  unsigned int rlen ;
  unsigned int slen ;
  unsigned int len ;
  unsigned char sigblob[40] ;
  Buffer b ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;

  {
#line 129
  tmp = EVP_sha1();
#line 129
  evp_md = (EVP_MD *)tmp;
#line 137
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 138
    error("dsa_sign: no DSA key");
#line 139
    return (-1);
  } else {
#line 137
    if (key->type != 1) {
#line 138
      error("dsa_sign: no DSA key");
#line 139
      return (-1);
    } else {
#line 137
      if ((unsigned int )key->dsa == (unsigned int )((void *)0)) {
#line 138
        error("dsa_sign: no DSA key");
#line 139
        return (-1);
      }
    }
  }
#line 141
  tmp___0 = xmalloc((unsigned int )evp_md->md_size);
#line 141
  digest___0 = (unsigned char *)tmp___0;
#line 142
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 143
  EVP_DigestUpdate(& md, (void const   *)data, (unsigned int )datalen);
#line 144
  EVP_DigestFinal(& md, digest___0, (unsigned int *)((void *)0));
#line 146
  sig = DSA_do_sign((unsigned char const   *)digest___0, evp_md->md_size, key->dsa);
#line 147
  if ((unsigned int )sig == (unsigned int )((void *)0)) {
#line 148
    fatal("dsa_sign: cannot sign");
  }
#line 151
  tmp___1 = BN_num_bits((BIGNUM const   *)sig->r);
#line 151
  rlen = (unsigned int )((tmp___1 + 7) / 8);
#line 152
  tmp___2 = BN_num_bits((BIGNUM const   *)sig->s);
#line 152
  slen = (unsigned int )((tmp___2 + 7) / 8);
#line 153
  if (rlen > 20U) {
#line 154
    error("bad sig size %d %d", rlen, slen);
#line 155
    DSA_SIG_free(sig);
#line 156
    return (-1);
  } else {
#line 153
    if (slen > 20U) {
#line 154
      error("bad sig size %d %d", rlen, slen);
#line 155
      DSA_SIG_free(sig);
#line 156
      return (-1);
    }
  }
#line 158
  debug("sig size %d %d", rlen, slen);
#line 160
  memset((void *)(sigblob), 0, 40U);
#line 161
  BN_bn2bin((BIGNUM const   *)sig->r, ((sigblob + 40) - 20) - rlen);
#line 162
  BN_bn2bin((BIGNUM const   *)sig->s, (sigblob + 40) - slen);
#line 163
  DSA_SIG_free(sig);
#line 165
  if (datafellows & 1) {
#line 166
    debug("datafellows");
#line 167
    tmp___3 = xmalloc(40U);
#line 167
    ret = (unsigned char *)tmp___3;
#line 168
    memcpy((void * __restrict  )ret, (void const   * __restrict  )(sigblob), 40U);
#line 169
    if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 170
      *lenp = 40;
    }
#line 171
    if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 172
      *sigp = ret;
    }
  } else {
#line 175
    buffer_init(& b);
#line 176
    buffer_put_cstring(& b, "ssh-dss");
#line 177
    buffer_put_string(& b, (void const   *)(sigblob), 40U);
#line 178
    len = buffer_len(& b);
#line 179
    tmp___4 = xmalloc(len);
#line 179
    ret = (unsigned char *)tmp___4;
#line 180
    tmp___5 = buffer_ptr(& b);
#line 180
    memcpy((void * __restrict  )ret, (void const   * __restrict  )tmp___5, len);
#line 181
    buffer_free(& b);
#line 182
    if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 183
      *lenp = (int )len;
    }
#line 184
    if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 185
      *sigp = ret;
    }
  }
#line 187
  return (0);
}
}
#line 189 "dsa.c"
int dsa_verify(Key *key , unsigned char *signature , int signaturelen , unsigned char *data ,
               int datalen ) 
{ Buffer b ;
  unsigned char *digest___0 ;
  DSA_SIG *sig ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  unsigned char *sigblob ;
  char *txt ;
  unsigned int len ;
  int rlen ;
  int ret ;
  char *ktype ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  unsigned int tmp___11 ;
  void *tmp___12 ;

  {
#line 198
  tmp = EVP_sha1();
#line 198
  evp_md = (EVP_MD *)tmp;
#line 206
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 207
    error("dsa_verify: no DSA key");
#line 208
    return (-1);
  } else {
#line 206
    if (key->type != 1) {
#line 207
      error("dsa_verify: no DSA key");
#line 208
      return (-1);
    } else {
#line 206
      if ((unsigned int )key->dsa == (unsigned int )((void *)0)) {
#line 207
        error("dsa_verify: no DSA key");
#line 208
        return (-1);
      }
    }
  }
#line 211
  if (! (datafellows & 1)) {
#line 211
    if (signaturelen == 40) {
#line 213
      datafellows |= -2;
#line 214
      log("autodetect SSH_BUG_SIGBLOB");
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 215
    if (datafellows & 1) {
#line 215
      if (signaturelen != 40) {
#line 217
        log("autoremove SSH_BUG_SIGBLOB");
#line 218
        datafellows &= -2;
      }
    }
  }
#line 221
  debug("len %d datafellows %d", signaturelen, datafellows);
#line 224
  if (datafellows & 1) {
#line 225
    sigblob = signature;
#line 226
    len = (unsigned int )signaturelen;
  } else {
#line 230
    buffer_init(& b);
#line 231
    buffer_append(& b, (char const   *)((char *)signature), (unsigned int )signaturelen);
#line 232
    ktype = buffer_get_string(& b, (unsigned int *)((void *)0));
#line 233
    if (0) {
#line 233
      __s1_len = strlen("ssh-dss");
#line 233
      __s2_len = strlen((char const   *)ktype);
#line 233
      if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
        goto _L___1;
      } else {
#line 233
        if (__s1_len >= 4U) {
          _L___1: /* CIL Label */ 
#line 233
          if (! ((unsigned int )((void const   *)(ktype + 1)) - (unsigned int )((void const   *)ktype) == 1U)) {
#line 233
            tmp___9 = 1;
          } else {
#line 233
            if (__s2_len >= 4U) {
#line 233
              tmp___9 = 1;
            } else {
#line 233
              tmp___9 = 0;
            }
          }
        } else {
#line 233
          tmp___9 = 0;
        }
      }
#line 233
      if (tmp___9) {
#line 233
        tmp___5 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
      } else {
#line 233
        tmp___8 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
#line 233
        tmp___5 = tmp___8;
      }
    } else {
#line 233
      tmp___8 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
#line 233
      tmp___5 = tmp___8;
    }
#line 233
    if (tmp___5 != 0) {
#line 234
      error("dsa_verify: cannot handle type %s", ktype);
#line 235
      buffer_free(& b);
#line 236
      return (-1);
    }
#line 238
    tmp___10 = buffer_get_string(& b, & len);
#line 238
    sigblob = (unsigned char *)tmp___10;
#line 239
    tmp___11 = buffer_len(& b);
#line 239
    rlen = (int )tmp___11;
#line 240
    if (rlen != 0) {
#line 241
      error("remaining bytes in signature %d", rlen);
#line 242
      buffer_free(& b);
#line 243
      return (-1);
    }
#line 245
    buffer_free(& b);
#line 246
    xfree((void *)ktype);
  }
#line 249
  if (len != 40U) {
#line 250
    fatal("bad sigbloblen %d != SIGBLOB_LEN", len);
  }
#line 254
  sig = DSA_SIG_new();
#line 255
  sig->r = BN_new();
#line 256
  sig->s = BN_new();
#line 257
  BN_bin2bn((unsigned char const   *)sigblob, 20, sig->r);
#line 258
  BN_bin2bn((unsigned char const   *)(sigblob + 20), 20, sig->s);
#line 260
  if (! (datafellows & 1)) {
#line 261
    memset((void *)sigblob, 0, len);
#line 262
    xfree((void *)sigblob);
  }
#line 266
  tmp___12 = xmalloc((unsigned int )evp_md->md_size);
#line 266
  digest___0 = (unsigned char *)tmp___12;
#line 267
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 268
  EVP_DigestUpdate(& md, (void const   *)data, (unsigned int )datalen);
#line 269
  EVP_DigestFinal(& md, digest___0, (unsigned int *)((void *)0));
#line 271
  ret = DSA_do_verify((unsigned char const   *)digest___0, evp_md->md_size, sig, key->dsa);
#line 273
  memset((void *)digest___0, 0, (unsigned int )evp_md->md_size);
#line 274
  xfree((void *)digest___0);
#line 275
  DSA_SIG_free(sig);
#line 277
  switch (ret) {
  case 1: 
#line 279
  txt = (char *)"correct";
#line 280
  break;
  case 0: 
#line 282
  txt = (char *)"incorrect";
#line 283
  break;
  case -1: 
  default: 
#line 286
  txt = (char *)"error";
#line 287
  break;
  }
#line 289
  debug("dsa_verify: signature %s", txt);
#line 290
  return (ret);
}
}
#line 293 "dsa.c"
Key *dsa_generate_key(unsigned int bits ) 
{ DSA *dsa ;
  DSA *tmp ;
  Key *k ;
  int tmp___0 ;

  {
#line 296
  tmp = DSA_generate_parameters((int )bits, (unsigned char *)((void *)0), 0, (int *)((void *)0),
                                (unsigned long *)((void *)0), (void (*)(int  , int  ,
                                                                        void * ))((void *)0),
                                (void *)0);
#line 296
  dsa = tmp;
#line 298
  if ((unsigned int )dsa == (unsigned int )((void *)0)) {
#line 299
    fatal("DSA_generate_parameters failed");
  }
#line 301
  tmp___0 = DSA_generate_key(dsa);
#line 301
  if (! tmp___0) {
#line 302
    fatal("DSA_generate_keys failed");
  }
#line 305
  k = key_new(2);
#line 306
  k->type = 1;
#line 307
  k->dsa = dsa;
#line 308
  return (k);
}
}
#line 1 "hmac.o"
#line 89 "/usr/include/openssl/hmac.h"
extern void HMAC_CTX_cleanup(HMAC_CTX *ctx ) ;
#line 93
extern void HMAC_Init(HMAC_CTX *ctx , void const   *key , int len , EVP_MD const   *md ) ;
#line 97
extern void HMAC_Update(HMAC_CTX *ctx , unsigned char const   *data , size_t len ) ;
#line 98
extern void HMAC_Final(HMAC_CTX *ctx , unsigned char *md , unsigned int *len ) ;
#line 47 "hmac.c"
static unsigned char m[64]  ;
#line 39 "hmac.c"
unsigned char *hmac(EVP_MD *evp_md , unsigned int seqno , unsigned char *data , int datalen ,
                    unsigned char *key , int keylen ) 
{ HMAC_CTX c ;
  unsigned char b[4] ;

  {
#line 50
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 51
    fatal("hmac: no key");
  }
#line 52
  HMAC_Init(& c, (void const   *)key, keylen, (EVP_MD const   *)evp_md);
#line 53
  while (1) {
#line 53
    b[0] = (unsigned char )(seqno >> 24);
#line 53
    b[1] = (unsigned char )(seqno >> 16);
#line 53
    b[2] = (unsigned char )(seqno >> 8);
#line 53
    b[3] = (unsigned char )seqno;
#line 53
    break;
  }
#line 54
  HMAC_Update(& c, (unsigned char const   *)(b), sizeof(b));
#line 55
  HMAC_Update(& c, (unsigned char const   *)data, (unsigned int )datalen);
#line 56
  HMAC_Final(& c, m, (unsigned int *)((void *)0));
#line 57
  HMAC_CTX_cleanup(& c);
#line 58
  return (m);
}
}
#line 1 "hostfile.o"
#line 248 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 532
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 410 "/usr/include/openssl/bn.h"
extern BIGNUM *BN_copy(BIGNUM *a , BIGNUM const   *b ) ;
#line 16 "match.h"
int match_hostname(char const   *host , char const   *pattern , unsigned int len ) ;
#line 386 "ssh.h"
int auth_rsa_read_key(char **cpp , unsigned int *bitsp , BIGNUM *e , BIGNUM *n___0 ) ;
#line 17 "key.h"
void key_free(Key *k ) ;
#line 18
int key_equal(Key *a , Key *b ) ;
#line 21
int key_write(Key *key , FILE *f ) ;
#line 22
unsigned int key_read(Key *ret , char **cpp ) ;
#line 13 "hostfile.h"
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , Key *key ,
                                  Key *found ) ;
#line 20
int add_host_to_hostfile(char const   *filename , char const   *host , Key *key ) ;
#line 32 "hostfile.c"
int hostfile_read_key(char **cpp , unsigned int *bitsp , Key *ret ) 
{ unsigned int bits ;
  char *cp ;

  {
#line 39
  cp = *cpp;
#line 39
  while (1) {
#line 39
    if (! ((int )*cp == 32)) {
#line 39
      if (! ((int )*cp == 9)) {
#line 39
        break;
      }
    }
#line 39
    cp ++;
  }
#line 42
  bits = key_read(ret, & cp);
#line 43
  if (bits == 0U) {
#line 44
    return (0);
  }
#line 47
  while (1) {
#line 47
    if (! ((int )*cp == 32)) {
#line 47
      if (! ((int )*cp == 9)) {
#line 47
        break;
      }
    }
#line 47
    cp ++;
  }
#line 51
  *cpp = cp;
#line 52
  *bitsp = bits;
#line 53
  return (1);
}
}
#line 56 "hostfile.c"
int auth_rsa_read_key(char **cpp , unsigned int *bitsp , BIGNUM *e , BIGNUM *n___0 ) 
{ Key *k ;
  Key *tmp ;
  int ret ;
  int tmp___0 ;

  {
#line 59
  tmp = key_new(0);
#line 59
  k = tmp;
#line 60
  tmp___0 = hostfile_read_key(cpp, bitsp, k);
#line 60
  ret = tmp___0;
#line 61
  BN_copy(e, (BIGNUM const   *)(k->rsa)->e);
#line 62
  BN_copy(n___0, (BIGNUM const   *)(k->rsa)->n);
#line 63
  key_free(k);
#line 64
  return (ret);
}
}
#line 67 "hostfile.c"
int hostfile_check_key(int bits , Key *key , char const   *host , char const   *filename ,
                       int linenum ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 70
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 71
    return (1);
  } else {
#line 70
    if (key->type != 0) {
#line 71
      return (1);
    } else {
#line 70
      if ((unsigned int )key->rsa == (unsigned int )((void *)0)) {
#line 71
        return (1);
      }
    }
  }
#line 72
  tmp___1 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 72
  if (bits != tmp___1) {
#line 73
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 73
    log("Warning: %s, line %d: keysize mismatch for host %s: actual %d vs. announced %d.",
        filename, linenum, host, tmp, bits);
#line 76
    tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 76
    log("Warning: replace %d with %d in %s, line %d.", bits, tmp___0, filename, linenum);
  }
#line 79
  return (1);
}
}
#line 89 "hostfile.c"
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , Key *key ,
                                  Key *found ) 
{ FILE *f ;
  char line[8192] ;
  int linenum ;
  unsigned int kbits ;
  unsigned int hostlen ;
  char *cp ;
  char *cp2 ;
  HostStatus end_return ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 94
  linenum = 0;
#line 99
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 100
    fatal("no key to look up");
  }
#line 102
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 103
  if (! f) {
#line 104
    return (1);
  }
#line 107
  hostlen = strlen(host);
#line 114
  end_return = 1;
#line 117
  while (1) {
#line 117
    tmp___3 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 117
    if (! tmp___3) {
#line 117
      break;
    }
#line 118
    cp = line;
#line 119
    linenum ++;
#line 122
    while (1) {
#line 122
      if (! ((int )*cp == 32)) {
#line 122
        if (! ((int )*cp == 9)) {
#line 122
          break;
        }
      }
#line 122
      cp ++;
    }
#line 124
    if (! *cp) {
#line 125
      continue;
    } else {
#line 124
      if ((int )*cp == 35) {
#line 125
        continue;
      } else {
#line 124
        if ((int )*cp == 10) {
#line 125
          continue;
        }
      }
    }
#line 128
    cp2 = cp;
#line 128
    while (1) {
#line 128
      if (*cp2) {
#line 128
        if ((int )*cp2 != 32) {
#line 128
          if (! ((int )*cp2 != 9)) {
#line 128
            break;
          }
        } else {
#line 128
          break;
        }
      } else {
#line 128
        break;
      }
#line 128
      cp2 ++;
    }
#line 132
    tmp = match_hostname(host, (char const   *)cp, (unsigned int )(cp2 - cp));
#line 132
    if (tmp != 1) {
#line 133
      continue;
    }
#line 136
    cp = cp2;
#line 142
    tmp___0 = hostfile_read_key(& cp, & kbits, found);
#line 142
    if (! tmp___0) {
#line 143
      continue;
    }
#line 144
    tmp___1 = hostfile_check_key((int )kbits, found, host, filename, linenum);
#line 144
    if (! tmp___1) {
#line 145
      continue;
    }
#line 148
    tmp___2 = key_equal(key, found);
#line 148
    if (tmp___2) {
#line 150
      fclose(f);
#line 151
      return (0);
    }
#line 158
    end_return = 2;
  }
#line 161
  fclose(f);
#line 167
  return (end_return);
}
}
#line 175 "hostfile.c"
int add_host_to_hostfile(char const   *filename , char const   *host , Key *key ) 
{ FILE *f ;
  int success ;
  int tmp ;

  {
#line 179
  success = 0;
#line 180
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 181
    return (1);
  }
#line 182
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"a");
#line 183
  if (! f) {
#line 184
    return (0);
  }
#line 185
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s ", host);
#line 186
  tmp = key_write(key, f);
#line 186
  if (tmp) {
#line 187
    success = 1;
  } else {
#line 189
    error("add_host_to_hostfile: saving key in %s failed", filename);
  }
#line 191
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"\n");
#line 192
  fclose(f);
#line 193
  return (success);
}
}
#line 1 "key.o"
#line 603 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 7 "bsd-strlcat.h"
size_t strlcat(char *dst , char const   *src , size_t siz ) ;
#line 457 "/usr/include/openssl/bn.h"
extern int BN_cmp(BIGNUM const   *a , BIGNUM const   *b ) ;
#line 496
extern char *BN_bn2dec(BIGNUM const   *a ) ;
#line 498
extern int BN_dec2bn(BIGNUM **a , char const   *str ) ;
#line 215 "/usr/include/openssl/rsa.h"
extern RSA *RSA_new(void) ;
#line 238
extern void RSA_free(RSA *r ) ;
#line 190 "/usr/include/openssl/dsa.h"
extern DSA *DSA_new(void) ;
#line 593 "/usr/include/openssl/evp.h"
extern EVP_MD const   *EVP_md5(void) ;
#line 19 "key.h"
char *key_fingerprint(Key *k ) ;
#line 20
char *key_type(Key *k ) ;
#line 23
unsigned int key_size(Key *k ) ;
#line 3 "uuencode.h"
int uuencode(unsigned char *src , unsigned int srclength , char *target , size_t targsize ) ;
#line 4
int uudecode(char const   *src , unsigned char *target , size_t targsize ) ;
#line 48 "key.c"
Key *key_new(int type ) 
{ Key *k ;
  RSA *rsa ;
  DSA *dsa ;
  void *tmp ;

  {
#line 54
  tmp = xmalloc(sizeof(*k));
#line 54
  k = (Key *)tmp;
#line 55
  k->type = type;
#line 56
  k->dsa = (DSA *)((void *)0);
#line 57
  k->rsa = (RSA *)((void *)0);
#line 58
  switch (k->type) {
  case 0: 
#line 60
  rsa = RSA_new();
#line 61
  rsa->n = BN_new();
#line 62
  rsa->e = BN_new();
#line 63
  k->rsa = rsa;
#line 64
  break;
  case 1: 
#line 66
  dsa = DSA_new();
#line 67
  dsa->p = BN_new();
#line 68
  dsa->q = BN_new();
#line 69
  dsa->g = BN_new();
#line 70
  dsa->pub_key = BN_new();
#line 71
  k->dsa = dsa;
#line 72
  break;
  case 2: 
#line 74
  break;
  default: 
#line 76
  fatal("key_new: bad key type %d", k->type);
#line 77
  break;
  }
#line 79
  return (k);
}
}
#line 81 "key.c"
void key_free(Key *k ) 
{ 

  {
#line 84
  switch (k->type) {
  case 0: 
#line 86
  if ((unsigned int )k->rsa != (unsigned int )((void *)0)) {
#line 87
    RSA_free(k->rsa);
  }
#line 88
  k->rsa = (RSA *)((void *)0);
#line 89
  break;
  case 1: 
#line 91
  if ((unsigned int )k->dsa != (unsigned int )((void *)0)) {
#line 92
    DSA_free(k->dsa);
  }
#line 93
  k->dsa = (DSA *)((void *)0);
#line 94
  break;
  default: 
#line 96
  fatal("key_free: bad key type %d", k->type);
#line 97
  break;
  }
#line 99
  xfree((void *)k);
#line 100
  return;
}
}
#line 101 "key.c"
int key_equal(Key *a , Key *b ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 104
  if ((unsigned int )a == (unsigned int )((void *)0)) {
#line 105
    return (0);
  } else {
#line 104
    if ((unsigned int )b == (unsigned int )((void *)0)) {
#line 105
      return (0);
    } else {
#line 104
      if (a->type != b->type) {
#line 105
        return (0);
      }
    }
  }
#line 106
  switch (a->type) {
  case 0: 
#line 108
  if ((unsigned int )a->rsa != (unsigned int )((void *)0)) {
#line 108
    if ((unsigned int )b->rsa != (unsigned int )((void *)0)) {
#line 108
      tmp = BN_cmp((BIGNUM const   *)(a->rsa)->e, (BIGNUM const   *)(b->rsa)->e);
#line 108
      if (tmp == 0) {
#line 108
        tmp___0 = BN_cmp((BIGNUM const   *)(a->rsa)->n, (BIGNUM const   *)(b->rsa)->n);
#line 108
        if (tmp___0 == 0) {
#line 108
          tmp___1 = 1;
        } else {
#line 108
          tmp___1 = 0;
        }
      } else {
#line 108
        tmp___1 = 0;
      }
    } else {
#line 108
      tmp___1 = 0;
    }
  } else {
#line 108
    tmp___1 = 0;
  }
#line 108
  return (tmp___1);
#line 111
  break;
  case 1: 
#line 113
  if ((unsigned int )a->dsa != (unsigned int )((void *)0)) {
#line 113
    if ((unsigned int )b->dsa != (unsigned int )((void *)0)) {
#line 113
      tmp___2 = BN_cmp((BIGNUM const   *)(a->dsa)->p, (BIGNUM const   *)(b->dsa)->p);
#line 113
      if (tmp___2 == 0) {
#line 113
        tmp___3 = BN_cmp((BIGNUM const   *)(a->dsa)->q, (BIGNUM const   *)(b->dsa)->q);
#line 113
        if (tmp___3 == 0) {
#line 113
          tmp___4 = BN_cmp((BIGNUM const   *)(a->dsa)->g, (BIGNUM const   *)(b->dsa)->g);
#line 113
          if (tmp___4 == 0) {
#line 113
            tmp___5 = BN_cmp((BIGNUM const   *)(a->dsa)->pub_key, (BIGNUM const   *)(b->dsa)->pub_key);
#line 113
            if (tmp___5 == 0) {
#line 113
              tmp___6 = 1;
            } else {
#line 113
              tmp___6 = 0;
            }
          } else {
#line 113
            tmp___6 = 0;
          }
        } else {
#line 113
          tmp___6 = 0;
        }
      } else {
#line 113
        tmp___6 = 0;
      }
    } else {
#line 113
      tmp___6 = 0;
    }
  } else {
#line 113
    tmp___6 = 0;
  }
#line 113
  return (tmp___6);
#line 118
  break;
  default: 
#line 120
  fatal("key_equal: bad key type %d", a->type);
#line 121
  break;
  }
#line 123
  return (0);
}
}
#line 133 "key.c"
static char retval[195]  ;
#line 130 "key.c"
char *key_fingerprint(Key *k ) 
{ unsigned char *blob ;
  int len ;
  int nlen ;
  int elen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int i ;
  unsigned char digest___0[64] ;
  EVP_MD *md ;
  EVP_MD const   *tmp___2 ;
  EVP_MD_CTX ctx ;
  char hex[4] ;
  size_t tmp___3 ;

  {
#line 134
  blob = (unsigned char *)((void *)0);
#line 135
  len = 0;
#line 138
  switch (k->type) {
  case 0: 
#line 140
  tmp = BN_num_bits((BIGNUM const   *)(k->rsa)->n);
#line 140
  nlen = (tmp + 7) / 8;
#line 141
  tmp___0 = BN_num_bits((BIGNUM const   *)(k->rsa)->e);
#line 141
  elen = (tmp___0 + 7) / 8;
#line 142
  len = nlen + elen;
#line 143
  tmp___1 = xmalloc((unsigned int )len);
#line 143
  blob = (unsigned char *)tmp___1;
#line 144
  BN_bn2bin((BIGNUM const   *)(k->rsa)->n, blob);
#line 145
  BN_bn2bin((BIGNUM const   *)(k->rsa)->e, blob + nlen);
#line 146
  break;
  case 1: 
#line 148
  dsa_make_key_blob(k, & blob, (unsigned int *)(& len));
#line 149
  break;
  default: 
#line 151
  fatal("key_fingerprint: bad key type %d", k->type);
#line 152
  break;
  }
#line 154
  retval[0] = (char )'\000';
#line 156
  if ((unsigned int )blob != (unsigned int )((void *)0)) {
#line 159
    tmp___2 = EVP_md5();
#line 159
    md = (EVP_MD *)tmp___2;
#line 161
    EVP_DigestInit(& ctx, (EVP_MD const   *)md);
#line 162
    EVP_DigestUpdate(& ctx, (void const   *)blob, (unsigned int )len);
#line 163
    EVP_DigestFinal(& ctx, digest___0, (unsigned int *)((void *)0));
#line 164
    i = 0;
#line 164
    while (i < md->md_size) {
#line 166
      snprintf((char * __restrict  )(hex), sizeof(hex), (char const   * __restrict  )"%02x:",
               digest___0[i]);
#line 167
      strlcat(retval, (char const   *)(hex), sizeof(retval));
#line 164
      i ++;
    }
#line 169
    tmp___3 = strlen((char const   *)(retval));
#line 169
    retval[tmp___3 - 1U] = (char )'\000';
#line 170
    memset((void *)blob, 0, (unsigned int )len);
#line 171
    xfree((void *)blob);
  }
#line 173
  return (retval);
}
}
#line 183 "key.c"
int read_bignum(char **cpp , BIGNUM *value ) 
{ char *cp ;
  int old ;
  int tmp ;

  {
#line 186
  cp = *cpp;
#line 190
  while (1) {
#line 190
    if (! ((int )*cp == 32)) {
#line 190
      if (! ((int )*cp == 9)) {
#line 190
        break;
      }
    }
#line 190
    cp ++;
  }
#line 194
  if ((int )*cp < 48) {
#line 195
    return (0);
  } else {
#line 194
    if ((int )*cp > 57) {
#line 195
      return (0);
    }
  }
#line 198
  *cpp = cp;
#line 201
  while (1) {
#line 201
    if ((int )*cp >= 48) {
#line 201
      if (! ((int )*cp <= 57)) {
#line 201
        break;
      }
    } else {
#line 201
      break;
    }
#line 201
    cp ++;
  }
#line 205
  old = (int )*cp;
#line 206
  *cp = (char)0;
#line 209
  tmp = BN_dec2bn(& value, (char const   *)*cpp);
#line 209
  if (tmp == 0) {
#line 210
    return (0);
  }
#line 213
  *cp = (char )old;
#line 216
  *cpp = cp;
#line 217
  return (1);
}
}
#line 219 "key.c"
int write_bignum(FILE *f , BIGNUM *num ) 
{ char *buf___1 ;
  char *tmp ;

  {
#line 222
  tmp = BN_bn2dec((BIGNUM const   *)num);
#line 222
  buf___1 = tmp;
#line 223
  if ((unsigned int )buf___1 == (unsigned int )((void *)0)) {
#line 224
    error("write_bignum: BN_bn2dec() failed");
#line 225
    return (0);
  }
#line 227
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )" %s", buf___1);
#line 228
  free((void *)buf___1);
#line 229
  return (1);
}
}
#line 231 "key.c"
unsigned int key_read(Key *ret , char **cpp ) 
{ Key *k ;
  unsigned int bits ;
  char *cp ;
  int len ;
  int n___0 ;
  unsigned char *blob ;
  int tmp ;
  int tmp___0 ;
  int tmp___14 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  size_t tmp___27 ;
  void *tmp___28 ;
  int tmp___29 ;

  {
#line 235
  bits = 0U;
#line 240
  cp = *cpp;
#line 242
  switch (ret->type) {
  case 0: 
#line 245
  if ((int )*cp < 48) {
#line 246
    return (0U);
  } else {
#line 245
    if ((int )*cp > 57) {
#line 246
      return (0U);
    }
  }
#line 247
  bits = 0U;
#line 247
  while (1) {
#line 247
    if ((int )*cp >= 48) {
#line 247
      if (! ((int )*cp <= 57)) {
#line 247
        break;
      }
    } else {
#line 247
      break;
    }
#line 248
    bits = (10U * bits + (unsigned int )*cp) - 48U;
#line 247
    cp ++;
  }
#line 249
  if (bits == 0U) {
#line 250
    return (0U);
  }
#line 251
  *cpp = cp;
#line 253
  tmp = read_bignum(cpp, (ret->rsa)->e);
#line 253
  if (! tmp) {
#line 254
    return (0U);
  }
#line 255
  tmp___0 = read_bignum(cpp, (ret->rsa)->n);
#line 255
  if (! tmp___0) {
#line 256
    return (0U);
  }
#line 257
  break;
  case 1: 
#line 259
  if (0) {
#line 259
    if (0) {
#line 259
      __s1_len___0 = strlen((char const   *)cp);
#line 259
      __s2_len___0 = strlen("ssh-dss ");
#line 259
      if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
        goto _L___2;
      } else {
#line 259
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 259
          if (! ((unsigned int )((void const   *)("ssh-dss " + 1)) - (unsigned int )((void const   *)"ssh-dss ") == 1U)) {
#line 259
            tmp___24 = 1;
          } else {
#line 259
            if (__s2_len___0 >= 4U) {
#line 259
              tmp___24 = 1;
            } else {
#line 259
              tmp___24 = 0;
            }
          }
        } else {
#line 259
          tmp___24 = 0;
        }
      }
#line 259
      if (tmp___24) {
#line 259
        tmp___20 = __builtin_strcmp((char const   *)cp, "ssh-dss ");
      } else {
#line 259
        tmp___23 = __builtin_strcmp((char const   *)cp, "ssh-dss ");
#line 259
        tmp___20 = tmp___23;
      }
    } else {
#line 259
      tmp___23 = __builtin_strcmp((char const   *)cp, "ssh-dss ");
#line 259
      tmp___20 = tmp___23;
    }
#line 259
    tmp___14 = tmp___20;
  } else {
#line 259
    tmp___14 = strncmp((char const   *)cp, "ssh-dss ", 7U);
  }
#line 259
  if (tmp___14 != 0) {
#line 260
    return (0U);
  }
#line 261
  cp += 7;
#line 262
  tmp___27 = strlen((char const   *)cp);
#line 262
  len = (int )(2U * tmp___27);
#line 263
  tmp___28 = xmalloc((unsigned int )len);
#line 263
  blob = (unsigned char *)tmp___28;
#line 264
  n___0 = uudecode((char const   *)cp, blob, (unsigned int )len);
#line 265
  if (n___0 < 0) {
#line 266
    error("key_read: uudecode %s failed", cp);
#line 267
    return (0U);
  }
#line 269
  k = dsa_key_from_blob((char *)blob, n___0);
#line 270
  if ((unsigned int )k == (unsigned int )((void *)0)) {
#line 271
    error("key_read: dsa_key_from_blob %s failed", cp);
#line 272
    return (0U);
  }
#line 274
  xfree((void *)blob);
#line 275
  if ((unsigned int )ret->dsa != (unsigned int )((void *)0)) {
#line 276
    DSA_free(ret->dsa);
  }
#line 277
  ret->dsa = k->dsa;
#line 278
  k->dsa = (DSA *)((void *)0);
#line 279
  key_free(k);
#line 280
  tmp___29 = BN_num_bits((BIGNUM const   *)(ret->dsa)->p);
#line 280
  bits = (unsigned int )tmp___29;
#line 282
  while (1) {
#line 282
    if (! ((int )*cp == 32)) {
#line 282
      if (! ((int )*cp == 9)) {
#line 282
        break;
      }
    }
#line 283
    cp ++;
  }
#line 284
  while (1) {
#line 284
    if ((int )*cp != 0) {
#line 284
      if ((int )*cp != 32) {
#line 284
        if (! ((int )*cp != 9)) {
#line 284
          break;
        }
      } else {
#line 284
        break;
      }
    } else {
#line 284
      break;
    }
#line 285
    cp ++;
  }
#line 286
  *cpp = cp;
#line 287
  break;
  default: 
#line 289
  fatal("key_read: bad key type: %d", ret->type);
#line 290
  break;
  }
#line 292
  return (bits);
}
}
#line 294 "key.c"
int key_write(Key *key , FILE *f ) 
{ int success ;
  unsigned int bits ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int len ;
  int n___0 ;
  unsigned char *blob ;
  unsigned char *uu ;
  void *tmp___2 ;

  {
#line 297
  success = 0;
#line 298
  bits = 0U;
#line 300
  if (key->type == 0) {
#line 300
    if ((unsigned int )key->rsa != (unsigned int )((void *)0)) {
#line 302
      tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 302
      bits = (unsigned int )tmp;
#line 303
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%u", bits);
#line 304
      tmp___0 = write_bignum(f, (key->rsa)->e);
#line 304
      if (tmp___0) {
#line 304
        tmp___1 = write_bignum(f, (key->rsa)->n);
#line 304
        if (tmp___1) {
#line 306
          success = 1;
        } else {
#line 308
          error("key_write: failed for RSA key");
        }
      } else {
#line 308
        error("key_write: failed for RSA key");
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 310
    if (key->type == 1) {
#line 310
      if ((unsigned int )key->dsa != (unsigned int )((void *)0)) {
#line 313
        dsa_make_key_blob(key, & blob, (unsigned int *)(& len));
#line 314
        tmp___2 = xmalloc((unsigned int )(2 * len));
#line 314
        uu = (unsigned char *)tmp___2;
#line 315
        n___0 = uuencode(blob, (unsigned int )len, (char *)uu, (unsigned int )(2 * len));
#line 316
        if (n___0 > 0) {
#line 317
          fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s", "ssh-dss",
                  uu);
#line 318
          success = 1;
        }
#line 320
        xfree((void *)blob);
#line 321
        xfree((void *)uu);
      }
    }
  }
#line 323
  return (success);
}
}
#line 325 "key.c"
char *key_type(Key *k ) 
{ 

  {
#line 328
  switch (k->type) {
  case 0: 
#line 330
  return ((char *)"RSA");
#line 331
  break;
  case 1: 
#line 333
  return ((char *)"DSA");
#line 334
  break;
  }
#line 336
  return ((char *)"unknown");
}
}
#line 338 "key.c"
unsigned int key_size(Key *k ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 340
  switch (k->type) {
  case 0: 
#line 342
  tmp = BN_num_bits((BIGNUM const   *)(k->rsa)->n);
#line 342
  return ((unsigned int )tmp);
#line 343
  break;
  case 1: 
#line 345
  tmp___0 = BN_num_bits((BIGNUM const   *)(k->dsa)->p);
#line 345
  return ((unsigned int )tmp___0);
#line 346
  break;
  }
#line 348
  return (0U);
}
}
#line 1 "kex.o"
#line 454 "/usr/include/openssl/bn.h"
extern int BN_set_word(BIGNUM *a , unsigned long w ) ;
#line 459
extern int BN_is_bit_set(BIGNUM const   *a , int n ) ;
#line 497
extern int BN_hex2bn(BIGNUM **a , char const   *str ) ;
#line 91 "packet.h"
void packet_put_raw(char const   *buf___1 , unsigned int len ) ;
#line 125
unsigned int packet_get_char(void) ;
#line 136
char *packet_get_raw(int *length_ptr ) ;
#line 173 "/usr/include/openssl/dh.h"
extern DH *DH_new(void) ;
#line 193
extern int DH_generate_key(DH *dh ) ;
#line 611 "/usr/include/openssl/evp.h"
extern EVP_MD const   *EVP_ripemd160(void) ;
#line 93 "kex.h"
Buffer *kex_init(char **myproposal___0 ) ;
#line 94
void kex_exchange_kexinit(Buffer *my_kexinit , Buffer *peer_kexint , char **peer_proposal ) ;
#line 98
Kex *kex_choose_conf(char **cprop , char **sprop , int server ) ;
#line 101
int kex_derive_keys(Kex *k , unsigned char *hash , BIGNUM *shared_secret ) ;
#line 103
int dh_pub_is_valid(DH *dh , BIGNUM *dh_pub ) ;
#line 104
DH *dh_new_group1(void) ;
#line 106
unsigned char *kex_hash(char *client_version_string___0 , char *server_version_string___0 ,
                        char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                        char *serverhostkeyblob , int sbloblen , BIGNUM *client_dh_pub ,
                        BIGNUM *server_dh_pub , BIGNUM *shared_secret ) ;
#line 55 "kex.c"
Buffer *kex_init(char **myproposal___0 ) 
{ int first_kex_packet_follows ;
  unsigned char cookie[16] ;
  u_int32_t rand___0 ;
  int i ;
  Buffer *ki ;
  void *tmp ;

  {
#line 58
  first_kex_packet_follows = 0;
#line 60
  rand___0 = (u_int32_t )0;
#line 62
  tmp = xmalloc(sizeof(*ki));
#line 62
  ki = (Buffer *)tmp;
#line 63
  i = 0;
#line 63
  while (i < 16) {
#line 64
    if (i % 4 == 0) {
#line 65
      rand___0 = arc4random();
    }
#line 66
    cookie[i] = (unsigned char )(rand___0 & 255U);
#line 67
    rand___0 >>= 8;
#line 63
    i ++;
  }
#line 69
  buffer_init(ki);
#line 70
  buffer_append(ki, (char const   *)((char *)(cookie)), sizeof(cookie));
#line 71
  i = 0;
#line 71
  while (i < 10) {
#line 72
    buffer_put_cstring(ki, (char const   *)*(myproposal___0 + i));
#line 71
    i ++;
  }
#line 73
  buffer_put_char(ki, first_kex_packet_follows);
#line 74
  buffer_put_int(ki, 0U);
#line 75
  return (ki);
}
}
#line 79 "kex.c"
void kex_exchange_kexinit(Buffer *my_kexinit , Buffer *peer_kexint , char **peer_proposal ) 
{ int i ;
  char *ptr ;
  int plen ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 88
  debug("send KEXINIT");
#line 89
  packet_start(20);
#line 90
  tmp = buffer_len(my_kexinit);
#line 90
  tmp___0 = buffer_ptr(my_kexinit);
#line 90
  packet_put_raw((char const   *)tmp___0, tmp);
#line 91
  packet_send();
#line 92
  packet_write_wait();
#line 93
  debug("done");
#line 99
  debug("wait KEXINIT");
#line 100
  packet_read_expect(& plen, 20);
#line 101
  ptr = packet_get_raw(& plen);
#line 102
  buffer_append(peer_kexint, (char const   *)ptr, (unsigned int )plen);
#line 106
  i = 0;
#line 106
  while (i < 16) {
#line 107
    packet_get_char();
#line 106
    i ++;
  }
#line 109
  i = 0;
#line 109
  while (i < 10) {
#line 110
    *(peer_proposal + i) = packet_get_string((unsigned int *)((void *)0));
#line 111
    debug("got kexinit: %s", *(peer_proposal + i));
#line 109
    i ++;
  }
#line 114
  tmp___1 = packet_get_char();
#line 114
  i = (int )tmp___1;
#line 115
  debug("first kex follow: %d ", i);
#line 116
  tmp___2 = packet_get_int();
#line 116
  i = (int )tmp___2;
#line 117
  debug("reserved: %d ", i);
#line 118
  while (1) {
#line 118
    tmp___3 = packet_remaining();
#line 118
    _len = tmp___3;
#line 118
    if (_len > 0) {
#line 118
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kex.c", 118);
#line 118
      packet_disconnect("Packet integrity error.");
    }
#line 118
    break;
  }
#line 119
  debug("done");
#line 120
  return;
}
}
#line 124 "kex.c"
int dh_pub_is_valid(DH *dh , BIGNUM *dh_pub ) 
{ int i ;
  int n___0 ;
  int tmp ;
  int bits_set ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 128
  tmp = BN_num_bits((BIGNUM const   *)dh_pub);
#line 128
  n___0 = tmp;
#line 129
  bits_set = 0;
#line 132
  if ((dh->g)->top == 1) {
#line 132
    if (*((dh->g)->d + 0) == 2UL) {
      goto _L;
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 132
    if (0) {
      _L: /* CIL Label */ 
#line 132
      if (! (! (dh->g)->neg)) {
#line 133
        log("invalid DH base != 2");
#line 134
        return (0);
      }
    } else {
#line 133
      log("invalid DH base != 2");
#line 134
      return (0);
    }
  }
#line 136
  if (dh_pub->neg) {
#line 137
    log("invalid public DH value: negativ");
#line 138
    return (0);
  }
#line 140
  i = 0;
#line 140
  while (i <= n___0) {
#line 141
    tmp___0 = BN_is_bit_set((BIGNUM const   *)dh_pub, i);
#line 141
    if (tmp___0) {
#line 142
      bits_set ++;
    }
#line 140
    i ++;
  }
#line 143
  tmp___1 = BN_num_bits((BIGNUM const   *)dh->p);
#line 143
  debug("bits set: %d/%d", bits_set, tmp___1);
#line 146
  if (bits_set > 1) {
#line 146
    tmp___2 = BN_cmp((BIGNUM const   *)dh_pub, (BIGNUM const   *)dh->p);
#line 146
    if (tmp___2 == -1) {
#line 147
      return (1);
    }
  }
#line 148
  tmp___3 = BN_num_bits((BIGNUM const   *)dh->p);
#line 148
  log("invalid public DH value (%d/%d)", bits_set, tmp___3);
#line 149
  return (0);
}
}
#line 155 "kex.c"
static char *group1  =    (char *)"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF";
#line 152 "kex.c"
DH *dh_new_group1(void) 
{ DH *dh ;
  int ret ;
  int tries ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 163
  tries = 0;
#line 164
  dh = DH_new();
#line 165
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 166
    fatal("DH_new");
  }
#line 167
  ret = BN_hex2bn(& dh->p, (char const   *)group1);
#line 168
  if (ret < 0) {
#line 169
    fatal("BN_hex2bn");
  }
#line 170
  dh->g = BN_new();
#line 171
  if ((unsigned int )dh->g == (unsigned int )((void *)0)) {
#line 172
    fatal("DH_new g");
  }
#line 173
  BN_set_word(dh->g, 2UL);
#line 174
  while (1) {
#line 175
    tmp = DH_generate_key(dh);
#line 175
    if (tmp == 0) {
#line 176
      fatal("DH_generate_key");
    }
#line 177
    tmp___0 = tries;
#line 177
    tries ++;
#line 177
    if (tmp___0 > 10) {
#line 178
      fatal("dh_new_group1: too many bad keys: giving up");
    }
#line 174
    tmp___1 = dh_pub_is_valid(dh, dh->pub_key);
#line 174
    if (tmp___1) {
#line 174
      break;
    }
  }
#line 180
  return (dh);
}
}
#line 183 "kex.c"
void dump_digest(unsigned char *digest___0 , int len ) 
{ int i ;

  {
#line 187
  i = 0;
#line 187
  while (i < len) {
#line 188
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%02x", *(digest___0 + i));
#line 189
    if (i % 2 != 0) {
#line 190
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" ");
    }
#line 187
    i ++;
  }
#line 192
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 193
  return;
}
}
#line 207 "kex.c"
static unsigned char digest[64]  ;
#line 195 "kex.c"
unsigned char *kex_hash(char *client_version_string___0 , char *server_version_string___0 ,
                        char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                        char *serverhostkeyblob , int sbloblen , BIGNUM *client_dh_pub ,
                        BIGNUM *server_dh_pub , BIGNUM *shared_secret ) 
{ Buffer b ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;

  {
#line 208
  tmp = EVP_sha1();
#line 208
  evp_md = (EVP_MD *)tmp;
#line 211
  buffer_init(& b);
#line 212
  tmp___0 = strlen((char const   *)client_version_string___0);
#line 212
  buffer_put_string(& b, (void const   *)client_version_string___0, tmp___0);
#line 213
  tmp___1 = strlen((char const   *)server_version_string___0);
#line 213
  buffer_put_string(& b, (void const   *)server_version_string___0, tmp___1);
#line 216
  buffer_put_int(& b, (unsigned int )(ckexinitlen + 1));
#line 217
  buffer_put_char(& b, 20);
#line 218
  buffer_append(& b, (char const   *)ckexinit, (unsigned int )ckexinitlen);
#line 219
  buffer_put_int(& b, (unsigned int )(skexinitlen + 1));
#line 220
  buffer_put_char(& b, 20);
#line 221
  buffer_append(& b, (char const   *)skexinit, (unsigned int )skexinitlen);
#line 223
  buffer_put_string(& b, (void const   *)serverhostkeyblob, (unsigned int )sbloblen);
#line 224
  buffer_put_bignum2(& b, client_dh_pub);
#line 225
  buffer_put_bignum2(& b, server_dh_pub);
#line 226
  buffer_put_bignum2(& b, shared_secret);
#line 232
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 233
  tmp___2 = buffer_len(& b);
#line 233
  tmp___3 = buffer_ptr(& b);
#line 233
  EVP_DigestUpdate(& md, (void const   *)tmp___3, tmp___2);
#line 234
  EVP_DigestFinal(& md, digest, (unsigned int *)((void *)0));
#line 236
  buffer_free(& b);
#line 241
  return (digest);
}
}
#line 244 "kex.c"
unsigned char *derive_key(int id , int need , unsigned char *hash , BIGNUM *shared_secret ) 
{ Buffer b ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  char c ;
  int have ;
  int mdsz ;
  unsigned char *digest___0 ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  char *tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;

  {
#line 248
  tmp = EVP_sha1();
#line 248
  evp_md = (EVP_MD *)tmp;
#line 250
  c = (char )id;
#line 252
  mdsz = evp_md->md_size;
#line 253
  tmp___0 = xmalloc((unsigned int )((((need + mdsz) - 1) / mdsz) * mdsz));
#line 253
  digest___0 = (unsigned char *)tmp___0;
#line 255
  buffer_init(& b);
#line 256
  buffer_put_bignum2(& b, shared_secret);
#line 258
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 259
  tmp___1 = buffer_len(& b);
#line 259
  tmp___2 = buffer_ptr(& b);
#line 259
  EVP_DigestUpdate(& md, (void const   *)tmp___2, tmp___1);
#line 260
  EVP_DigestUpdate(& md, (void const   *)hash, (unsigned int )mdsz);
#line 261
  EVP_DigestUpdate(& md, (void const   *)(& c), 1U);
#line 262
  EVP_DigestUpdate(& md, (void const   *)hash, (unsigned int )mdsz);
#line 263
  EVP_DigestFinal(& md, digest___0, (unsigned int *)((void *)0));
#line 266
  have = mdsz;
#line 266
  while (need > have) {
#line 267
    EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 268
    tmp___3 = buffer_len(& b);
#line 268
    tmp___4 = buffer_ptr(& b);
#line 268
    EVP_DigestUpdate(& md, (void const   *)tmp___4, tmp___3);
#line 269
    EVP_DigestUpdate(& md, (void const   *)hash, (unsigned int )mdsz);
#line 270
    EVP_DigestUpdate(& md, (void const   *)digest___0, (unsigned int )have);
#line 271
    EVP_DigestFinal(& md, digest___0 + have, (unsigned int *)((void *)0));
#line 266
    have += mdsz;
  }
#line 273
  buffer_free(& b);
#line 278
  return (digest___0);
}
}
#line 286 "kex.c"
char *get_match(char *client , char *server ) 
{ char *sproposals[20] ;
  char *c ;
  char *s ;
  char *p ;
  char *ret ;
  char *cp ;
  char *sp ;
  int i ;
  int j ;
  int nproposals ;
  char *tmp___14 ;
  char *tmp___30 ;
  char *tmp___46 ;
  char *tmp___62 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___68 ;
  int tmp___71 ;
  int tmp___72 ;

  {
#line 293
  cp = xstrdup((char const   *)client);
#line 293
  c = cp;
#line 294
  sp = xstrdup((char const   *)server);
#line 294
  s = sp;
#line 296
  tmp___14 = __strsep_g(& sp, ",");
#line 296
  p = tmp___14;
#line 296
  i = 0;
#line 296
  while (1) {
#line 296
    if (p) {
#line 296
      if (! ((int )*p != 0)) {
#line 296
        break;
      }
    } else {
#line 296
      break;
    }
#line 298
    if (i < 20) {
#line 299
      sproposals[i] = p;
    } else {
#line 301
      break;
    }
#line 297
    tmp___30 = __strsep_g(& sp, ",");
#line 297
    p = tmp___30;
#line 297
    i ++;
  }
#line 303
  nproposals = i;
#line 305
  tmp___46 = __strsep_g(& cp, ",");
#line 305
  p = tmp___46;
#line 305
  i = 0;
#line 305
  while (1) {
#line 305
    if (p) {
#line 305
      if (! ((int )*p != 0)) {
#line 305
        break;
      }
    } else {
#line 305
      break;
    }
#line 307
    j = 0;
#line 307
    while (j < nproposals) {
#line 308
      if (0) {
#line 308
        __s1_len = strlen((char const   *)p);
#line 308
        __s2_len = strlen((char const   *)sproposals[j]);
#line 308
        if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
          goto _L___0;
        } else {
#line 308
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 308
            if (! ((unsigned int )((void const   *)(sproposals[j] + 1)) - (unsigned int )((void const   *)sproposals[j]) == 1U)) {
#line 308
              tmp___72 = 1;
            } else {
#line 308
              if (__s2_len >= 4U) {
#line 308
                tmp___72 = 1;
              } else {
#line 308
                tmp___72 = 0;
              }
            }
          } else {
#line 308
            tmp___72 = 0;
          }
        }
#line 308
        if (tmp___72) {
#line 308
          tmp___68 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
        } else {
#line 308
          tmp___71 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
#line 308
          tmp___68 = tmp___71;
        }
      } else {
#line 308
        tmp___71 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
#line 308
        tmp___68 = tmp___71;
      }
#line 308
      if (tmp___68 == 0) {
#line 309
        ret = xstrdup((char const   *)p);
#line 310
        xfree((void *)c);
#line 311
        xfree((void *)s);
#line 312
        return (ret);
      }
#line 307
      j ++;
    }
#line 306
    tmp___62 = __strsep_g(& cp, ",");
#line 306
    p = tmp___62;
#line 306
    i ++;
  }
#line 316
  xfree((void *)c);
#line 317
  xfree((void *)s);
#line 318
  return ((char *)((void *)0));
}
}
#line 320 "kex.c"
void choose_enc(Enc *enc , char *client , char *server ) 
{ char *name ;
  char *tmp ;

  {
#line 323
  tmp = get_match(client, server);
#line 323
  name = tmp;
#line 324
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 325
    fatal("no matching cipher found: client %s server %s", client, server);
  }
#line 326
  enc->type = cipher_number((char const   *)name);
#line 328
  switch (enc->type) {
  case 9: 
#line 330
  enc->key_len = 24;
#line 331
  enc->iv_len = 8;
#line 332
  enc->block_size = 8;
#line 333
  break;
  case 8: 
  case 11: 
#line 336
  enc->key_len = 16;
#line 337
  enc->iv_len = 8;
#line 338
  enc->block_size = 8;
#line 339
  break;
  case 10: 
#line 341
  enc->key_len = 16;
#line 342
  enc->iv_len = 0;
#line 343
  enc->block_size = 8;
#line 344
  break;
  default: 
#line 346
  fatal("unsupported cipher %s", name);
  }
#line 348
  enc->name = name;
#line 349
  enc->enabled = 0;
#line 350
  enc->iv = (unsigned char *)((void *)0);
#line 351
  enc->key = (unsigned char *)((void *)0);
#line 352
  return;
}
}
#line 353 "kex.c"
void choose_mac(Mac *mac , char *client , char *server ) 
{ char *name ;
  char *tmp ;
  EVP_MD const   *tmp___0 ;
  EVP_MD const   *tmp___1 ;
  EVP_MD const   *tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___28 ;
  int tmp___31 ;
  int tmp___32 ;

  {
#line 356
  tmp = get_match(client, server);
#line 356
  name = tmp;
#line 357
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 358
    fatal("no matching mac found: client %s server %s", client, server);
  }
#line 359
  if (0) {
#line 359
    __s1_len___1 = strlen((char const   *)name);
#line 359
    __s2_len___1 = strlen("hmac-md5");
#line 359
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___4;
    } else {
#line 359
      if (__s1_len___1 >= 4U) {
        _L___4: /* CIL Label */ 
#line 359
        if (! ((unsigned int )((void const   *)("hmac-md5" + 1)) - (unsigned int )((void const   *)"hmac-md5") == 1U)) {
#line 359
          tmp___32 = 1;
        } else {
#line 359
          if (__s2_len___1 >= 4U) {
#line 359
            tmp___32 = 1;
          } else {
#line 359
            tmp___32 = 0;
          }
        }
      } else {
#line 359
        tmp___32 = 0;
      }
    }
#line 359
    if (tmp___32) {
#line 359
      tmp___28 = __builtin_strcmp((char const   *)name, "hmac-md5");
    } else {
#line 359
      tmp___31 = __builtin_strcmp((char const   *)name, "hmac-md5");
#line 359
      tmp___28 = tmp___31;
    }
  } else {
#line 359
    tmp___31 = __builtin_strcmp((char const   *)name, "hmac-md5");
#line 359
    tmp___28 = tmp___31;
  }
#line 359
  if (tmp___28 == 0) {
#line 360
    tmp___0 = EVP_md5();
#line 360
    mac->md = (EVP_MD *)tmp___0;
  } else {
#line 361
    if (0) {
#line 361
      __s1_len___0 = strlen((char const   *)name);
#line 361
      __s2_len___0 = strlen("hmac-sha1");
#line 361
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___2;
      } else {
#line 361
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 361
          if (! ((unsigned int )((void const   *)("hmac-sha1" + 1)) - (unsigned int )((void const   *)"hmac-sha1") == 1U)) {
#line 361
            tmp___22 = 1;
          } else {
#line 361
            if (__s2_len___0 >= 4U) {
#line 361
              tmp___22 = 1;
            } else {
#line 361
              tmp___22 = 0;
            }
          }
        } else {
#line 361
          tmp___22 = 0;
        }
      }
#line 361
      if (tmp___22) {
#line 361
        tmp___18 = __builtin_strcmp((char const   *)name, "hmac-sha1");
      } else {
#line 361
        tmp___21 = __builtin_strcmp((char const   *)name, "hmac-sha1");
#line 361
        tmp___18 = tmp___21;
      }
    } else {
#line 361
      tmp___21 = __builtin_strcmp((char const   *)name, "hmac-sha1");
#line 361
      tmp___18 = tmp___21;
    }
#line 361
    if (tmp___18 == 0) {
#line 362
      tmp___1 = EVP_sha1();
#line 362
      mac->md = (EVP_MD *)tmp___1;
    } else {
#line 363
      if (0) {
#line 363
        __s1_len = strlen((char const   *)name);
#line 363
        __s2_len = strlen("hmac-ripemd160@openssh.com");
#line 363
        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
          goto _L___0;
        } else {
#line 363
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 363
            if (! ((unsigned int )((void const   *)("hmac-ripemd160@openssh.com" + 1)) - (unsigned int )((void const   *)"hmac-ripemd160@openssh.com") == 1U)) {
#line 363
              tmp___12 = 1;
            } else {
#line 363
              if (__s2_len >= 4U) {
#line 363
                tmp___12 = 1;
              } else {
#line 363
                tmp___12 = 0;
              }
            }
          } else {
#line 363
            tmp___12 = 0;
          }
        }
#line 363
        if (tmp___12) {
#line 363
          tmp___8 = __builtin_strcmp((char const   *)name, "hmac-ripemd160@openssh.com");
        } else {
#line 363
          tmp___11 = __builtin_strcmp((char const   *)name, "hmac-ripemd160@openssh.com");
#line 363
          tmp___8 = tmp___11;
        }
      } else {
#line 363
        tmp___11 = __builtin_strcmp((char const   *)name, "hmac-ripemd160@openssh.com");
#line 363
        tmp___8 = tmp___11;
      }
#line 363
      if (tmp___8 == 0) {
#line 364
        tmp___2 = EVP_ripemd160();
#line 364
        mac->md = (EVP_MD *)tmp___2;
      } else {
#line 366
        fatal("unsupported mac %s", name);
      }
    }
  }
#line 368
  mac->name = name;
#line 369
  mac->mac_len = (mac->md)->md_size;
#line 370
  if (datafellows & 4) {
#line 370
    mac->key_len = 16;
  } else {
#line 370
    mac->key_len = mac->mac_len;
  }
#line 371
  mac->key = (unsigned char *)((void *)0);
#line 372
  mac->enabled = 0;
#line 373
  return;
}
}
#line 374 "kex.c"
void choose_comp(Comp *comp , char *client , char *server ) 
{ char *name ;
  char *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 377
  tmp = get_match(client, server);
#line 377
  name = tmp;
#line 378
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 379
    fatal("no matching comp found: client %s server %s", client, server);
  }
#line 380
  if (0) {
#line 380
    __s1_len___0 = strlen((char const   *)name);
#line 380
    __s2_len___0 = strlen("zlib");
#line 380
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___2;
    } else {
#line 380
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 380
        if (! ((unsigned int )((void const   *)("zlib" + 1)) - (unsigned int )((void const   *)"zlib") == 1U)) {
#line 380
          tmp___19 = 1;
        } else {
#line 380
          if (__s2_len___0 >= 4U) {
#line 380
            tmp___19 = 1;
          } else {
#line 380
            tmp___19 = 0;
          }
        }
      } else {
#line 380
        tmp___19 = 0;
      }
    }
#line 380
    if (tmp___19) {
#line 380
      tmp___15 = __builtin_strcmp((char const   *)name, "zlib");
    } else {
#line 380
      tmp___18 = __builtin_strcmp((char const   *)name, "zlib");
#line 380
      tmp___15 = tmp___18;
    }
  } else {
#line 380
    tmp___18 = __builtin_strcmp((char const   *)name, "zlib");
#line 380
    tmp___15 = tmp___18;
  }
#line 380
  if (tmp___15 == 0) {
#line 381
    comp->type = 1;
  } else {
#line 382
    if (0) {
#line 382
      __s1_len = strlen((char const   *)name);
#line 382
      __s2_len = strlen("none");
#line 382
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___0;
      } else {
#line 382
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 382
          if (! ((unsigned int )((void const   *)("none" + 1)) - (unsigned int )((void const   *)"none") == 1U)) {
#line 382
            tmp___9 = 1;
          } else {
#line 382
            if (__s2_len >= 4U) {
#line 382
              tmp___9 = 1;
            } else {
#line 382
              tmp___9 = 0;
            }
          }
        } else {
#line 382
          tmp___9 = 0;
        }
      }
#line 382
      if (tmp___9) {
#line 382
        tmp___5 = __builtin_strcmp((char const   *)name, "none");
      } else {
#line 382
        tmp___8 = __builtin_strcmp((char const   *)name, "none");
#line 382
        tmp___5 = tmp___8;
      }
    } else {
#line 382
      tmp___8 = __builtin_strcmp((char const   *)name, "none");
#line 382
      tmp___5 = tmp___8;
    }
#line 382
    if (tmp___5 == 0) {
#line 383
      comp->type = 0;
    } else {
#line 385
      fatal("unsupported comp %s", name);
    }
  }
#line 387
  comp->name = name;
#line 388
  return;
}
}
#line 389 "kex.c"
void choose_kex(Kex *k , char *client , char *server ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 392
  k->name = get_match(client, server);
#line 393
  if ((unsigned int )k->name == (unsigned int )((void *)0)) {
#line 394
    fatal("no kex alg");
  }
#line 395
  if (0) {
#line 395
    __s1_len = strlen((char const   *)k->name);
#line 395
    __s2_len = strlen("diffie-hellman-group1-sha1");
#line 395
    if (! ((unsigned int )((void const   *)(k->name + 1)) - (unsigned int )((void const   *)k->name) == 1U)) {
      goto _L___0;
    } else {
#line 395
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 395
        if (! ((unsigned int )((void const   *)("diffie-hellman-group1-sha1" + 1)) - (unsigned int )((void const   *)"diffie-hellman-group1-sha1") == 1U)) {
#line 395
          tmp___8 = 1;
        } else {
#line 395
          if (__s2_len >= 4U) {
#line 395
            tmp___8 = 1;
          } else {
#line 395
            tmp___8 = 0;
          }
        }
      } else {
#line 395
        tmp___8 = 0;
      }
    }
#line 395
    if (tmp___8) {
#line 395
      tmp___4 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
    } else {
#line 395
      tmp___7 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
#line 395
      tmp___4 = tmp___7;
    }
  } else {
#line 395
    tmp___7 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
#line 395
    tmp___4 = tmp___7;
  }
#line 395
  if (tmp___4 != 0) {
#line 396
    fatal("bad kex alg %s", k->name);
  }
#line 397
  return;
}
}
#line 398 "kex.c"
void choose_hostkeyalg(Kex *k , char *client , char *server ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 401
  k->hostkeyalg = get_match(client, server);
#line 402
  if ((unsigned int )k->hostkeyalg == (unsigned int )((void *)0)) {
#line 403
    fatal("no hostkey alg");
  }
#line 404
  if (0) {
#line 404
    __s1_len = strlen((char const   *)k->hostkeyalg);
#line 404
    __s2_len = strlen("ssh-dss");
#line 404
    if (! ((unsigned int )((void const   *)(k->hostkeyalg + 1)) - (unsigned int )((void const   *)k->hostkeyalg) == 1U)) {
      goto _L___0;
    } else {
#line 404
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 404
        if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
#line 404
          tmp___8 = 1;
        } else {
#line 404
          if (__s2_len >= 4U) {
#line 404
            tmp___8 = 1;
          } else {
#line 404
            tmp___8 = 0;
          }
        }
      } else {
#line 404
        tmp___8 = 0;
      }
    }
#line 404
    if (tmp___8) {
#line 404
      tmp___4 = __builtin_strcmp((char const   *)k->hostkeyalg, "ssh-dss");
    } else {
#line 404
      tmp___7 = __builtin_strcmp((char const   *)k->hostkeyalg, "ssh-dss");
#line 404
      tmp___4 = tmp___7;
    }
  } else {
#line 404
    tmp___7 = __builtin_strcmp((char const   *)k->hostkeyalg, "ssh-dss");
#line 404
    tmp___4 = tmp___7;
  }
#line 404
  if (tmp___4 != 0) {
#line 405
    fatal("bad hostkey alg %s", k->hostkeyalg);
  }
#line 406
  return;
}
}
#line 408 "kex.c"
Kex *kex_choose_conf(char **cprop , char **sprop , int server ) 
{ int mode ;
  int ctos ;
  int need ;
  Kex *k ;
  void *tmp ;
  int nenc ;
  int nmac ;
  int ncomp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 416
  tmp = xmalloc(sizeof(*k));
#line 416
  k = (Kex *)tmp;
#line 417
  memset((void *)k, 0, sizeof(*k));
#line 418
  k->server = server;
#line 420
  mode = 0;
#line 420
  while (mode < 2) {
#line 422
    if (! k->server) {
#line 422
      if (mode == 1) {
#line 422
        tmp___0 = 1;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 422
      if (k->server) {
#line 422
        if (mode == 0) {
#line 422
          tmp___0 = 1;
        } else {
#line 422
          tmp___0 = 0;
        }
      } else {
#line 422
        tmp___0 = 0;
      }
    }
#line 422
    ctos = tmp___0;
#line 423
    if (ctos) {
#line 423
      nenc = 2;
    } else {
#line 423
      nenc = 3;
    }
#line 424
    if (ctos) {
#line 424
      nmac = 4;
    } else {
#line 424
      nmac = 5;
    }
#line 425
    if (ctos) {
#line 425
      ncomp = 6;
    } else {
#line 425
      ncomp = 7;
    }
#line 426
    choose_enc(& k->enc[mode], *(cprop + nenc), *(sprop + nenc));
#line 427
    choose_mac(& k->mac[mode], *(cprop + nmac), *(sprop + nmac));
#line 428
    choose_comp(& k->comp[mode], *(cprop + ncomp), *(sprop + ncomp));
#line 429
    if (ctos) {
#line 429
      tmp___1 = "client->server";
    } else {
#line 429
      tmp___1 = "server->client";
    }
#line 429
    debug("kex: %s %s %s %s", tmp___1, k->enc[mode].name, k->mac[mode].name, k->comp[mode].name);
#line 420
    mode ++;
  }
#line 435
  choose_kex(k, *(cprop + 0), *(sprop + 0));
#line 436
  choose_hostkeyalg(k, *(cprop + 1), *(sprop + 1));
#line 438
  need = 0;
#line 439
  mode = 0;
#line 439
  while (mode < 2) {
#line 440
    if (need < k->enc[mode].key_len) {
#line 441
      need = k->enc[mode].key_len;
    }
#line 442
    if (need < k->enc[mode].iv_len) {
#line 443
      need = k->enc[mode].iv_len;
    }
#line 444
    if (need < k->mac[mode].key_len) {
#line 445
      need = k->mac[mode].key_len;
    }
#line 439
    mode ++;
  }
#line 448
  k->we_need = need;
#line 449
  return (k);
}
}
#line 452 "kex.c"
int kex_derive_keys(Kex *k , unsigned char *hash , BIGNUM *shared_secret ) 
{ int i ;
  int mode ;
  int ctos ;
  unsigned char *keys[6] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 460
  i = 0;
#line 460
  while (i < 6) {
#line 461
    keys[i] = derive_key(65 + i, k->we_need, hash, shared_secret);
#line 460
    i ++;
  }
#line 463
  mode = 0;
#line 463
  while (mode < 2) {
#line 464
    if (! k->server) {
#line 464
      if (mode == 1) {
#line 464
        tmp = 1;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 464
      if (k->server) {
#line 464
        if (mode == 0) {
#line 464
          tmp = 1;
        } else {
#line 464
          tmp = 0;
        }
      } else {
#line 464
        tmp = 0;
      }
    }
#line 464
    ctos = tmp;
#line 465
    if (ctos) {
#line 465
      tmp___0 = 0;
    } else {
#line 465
      tmp___0 = 1;
    }
#line 465
    k->enc[mode].iv = keys[tmp___0];
#line 466
    if (ctos) {
#line 466
      tmp___1 = 2;
    } else {
#line 466
      tmp___1 = 3;
    }
#line 466
    k->enc[mode].key = keys[tmp___1];
#line 467
    if (ctos) {
#line 467
      tmp___2 = 4;
    } else {
#line 467
      tmp___2 = 5;
    }
#line 467
    k->mac[mode].key = keys[tmp___2];
#line 463
    mode ++;
  }
#line 469
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 1 "log.o"
#line 325 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 646 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 459 "ssh.h"
void do_log(LogLevel level , char const   *fmt , va_list args ) ;
#line 462
SyslogFacility log_facility_number(char *name ) ;
#line 463
LogLevel log_level_number(char *name ) ;
#line 483
void fatal_remove_cleanup(void (*proc)(void *context ) , void *context ) ;
#line 13 "log.c"
void ( /* format attribute */  fatal)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 17
  __builtin_va_start(args, fmt);
#line 18
  do_log(1, fmt, args);
#line 19
  __builtin_va_end(args);
#line 20
  fatal_cleanup();
#line 21
  return;
}
}
#line 25 "log.c"
void ( /* format attribute */  error)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 29
  __builtin_va_start(args, fmt);
#line 30
  do_log(2, fmt, args);
#line 31
  __builtin_va_end(args);
#line 32
  return;
}
}
#line 36 "log.c"
void ( /* format attribute */  log)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 40
  __builtin_va_start(args, fmt);
#line 41
  do_log(3, fmt, args);
#line 42
  __builtin_va_end(args);
#line 43
  return;
}
}
#line 47 "log.c"
void ( /* format attribute */  verbose)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 51
  __builtin_va_start(args, fmt);
#line 52
  do_log(4, fmt, args);
#line 53
  __builtin_va_end(args);
#line 54
  return;
}
}
#line 58 "log.c"
void ( /* format attribute */  debug)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 62
  __builtin_va_start(args, fmt);
#line 63
  do_log(5, fmt, args);
#line 64
  __builtin_va_end(args);
#line 65
  return;
}
}
#line 75 "log.c"
static struct fatal_cleanup *fatal_cleanups  =    (struct fatal_cleanup *)((void *)0);
#line 79 "log.c"
void fatal_add_cleanup(void (*proc)(void *context ) , void *context ) 
{ struct fatal_cleanup *cu ;
  void *tmp ;

  {
#line 84
  tmp = xmalloc(sizeof(*cu));
#line 84
  cu = (struct fatal_cleanup *)tmp;
#line 85
  cu->proc = proc;
#line 86
  cu->context = context;
#line 87
  cu->next = fatal_cleanups;
#line 88
  fatal_cleanups = cu;
#line 89
  return;
}
}
#line 93 "log.c"
void fatal_remove_cleanup(void (*proc)(void *context ) , void *context ) 
{ struct fatal_cleanup **cup ;
  struct fatal_cleanup *cu ;

  {
#line 98
  cup = & fatal_cleanups;
#line 98
  while (*cup) {
#line 99
    cu = *cup;
#line 100
    if ((unsigned int )cu->proc == (unsigned int )proc) {
#line 100
      if ((unsigned int )cu->context == (unsigned int )context) {
#line 101
        *cup = cu->next;
#line 102
        xfree((void *)cu);
#line 103
        return;
      }
    }
#line 98
    cup = & cu->next;
  }
#line 106
  fatal("fatal_remove_cleanup: no such cleanup function: 0x%lx 0x%lx\n", (unsigned long )proc,
        (unsigned long )context);
#line 108
  return;
}
}
#line 115 "log.c"
static int called  =    0;
#line 111 "log.c"
void fatal_cleanup(void) 
{ struct fatal_cleanup *cu ;
  struct fatal_cleanup *next_cu ;

  {
#line 117
  if (called) {
#line 118
    exit(255);
  }
#line 119
  called = 1;
#line 121
  cu = fatal_cleanups;
#line 121
  while (cu) {
#line 122
    next_cu = cu->next;
#line 123
    debug("Calling cleanup 0x%lx(0x%lx)", (unsigned long )cu->proc, (unsigned long )cu->context);
#line 125
    (*(cu->proc))(cu->context);
#line 121
    cu = next_cu;
  }
#line 127
  exit(255);
}
}
#line 132 "log.c"
static struct __anonstruct_log_facilities_74 log_facilities[12]  = 
#line 132
  {      {"DAEMON", 0}, 
        {"USER", 1}, 
        {"AUTH", 2}, 
        {"LOCAL0", 3}, 
        {"LOCAL1", 4}, 
        {"LOCAL2", 5}, 
        {"LOCAL3", 6}, 
        {"LOCAL4", 7}, 
        {"LOCAL5", 8}, 
        {"LOCAL6", 9}, 
        {"LOCAL7", 10}, 
        {(char const   *)((void *)0), (SyslogFacility )0}};
#line 150 "log.c"
static struct __anonstruct_log_levels_75 log_levels[7]  = {      {"QUIET", 0}, 
        {"FATAL", 1}, 
        {"ERROR", 2}, 
        {"INFO", 3}, 
        {"VERBOSE", 4}, 
        {"DEBUG", 5}, 
        {(char const   *)((void *)0), (LogLevel )0}};
#line 164 "log.c"
SyslogFacility log_facility_number(char *name ) 
{ int i ;
  int tmp ;

  {
#line 168
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 169
    i = 0;
#line 169
    while (log_facilities[i].name) {
#line 170
      tmp = strcasecmp(log_facilities[i].name, (char const   *)name);
#line 170
      if (tmp == 0) {
#line 171
        return (log_facilities[i].val);
      }
#line 169
      i ++;
    }
  }
#line 172
  return ((enum __anonenum_SyslogFacility_72 )-1);
}
}
#line 175 "log.c"
LogLevel log_level_number(char *name ) 
{ int i ;
  int tmp ;

  {
#line 179
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 180
    i = 0;
#line 180
    while (log_levels[i].name) {
#line 181
      tmp = strcasecmp(log_levels[i].name, (char const   *)name);
#line 181
      if (tmp == 0) {
#line 182
        return (log_levels[i].val);
      }
#line 180
      i ++;
    }
  }
#line 183
  return ((enum __anonenum_LogLevel_73 )-1);
}
}
#line 1 "match.o"
#line 116 "/usr/include/ctype.h"
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 26 "match.c"
int match_pattern(char const   *s , char const   *pattern ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 29
  while (1) {
#line 31
    if (! *pattern) {
#line 32
      return (! *s);
    }
#line 34
    if ((int const   )*pattern == 42) {
#line 36
      pattern ++;
#line 39
      if (! *pattern) {
#line 40
        return (1);
      }
#line 43
      if ((int const   )*pattern != 63) {
#line 43
        if ((int const   )*pattern != 42) {
#line 49
          while (*s) {
#line 50
            if ((int const   )*s == (int const   )*pattern) {
#line 50
              tmp = match_pattern(s + 1, pattern + 1);
#line 50
              if (tmp) {
#line 52
                return (1);
              }
            }
#line 49
            s ++;
          }
#line 54
          return (0);
        }
      }
#line 60
      while (*s) {
#line 61
        tmp___0 = match_pattern(s, pattern);
#line 61
        if (tmp___0) {
#line 62
          return (1);
        }
#line 60
        s ++;
      }
#line 64
      return (0);
    }
#line 70
    if (! *s) {
#line 71
      return (0);
    }
#line 74
    if ((int const   )*pattern != 63) {
#line 74
      if ((int const   )*pattern != (int const   )*s) {
#line 75
        return (0);
      }
    }
#line 78
    s ++;
#line 79
    pattern ++;
  }
}
}
#line 91 "match.c"
int match_hostname(char const   *host , char const   *pattern , unsigned int len ) 
{ char sub[1024] ;
  int negated ;
  int got_positive ;
  unsigned int i ;
  unsigned int subi ;
  int __res___0 ;
  __int32_t const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;

  {
#line 99
  got_positive = 0;
#line 100
  i = 0U;
#line 100
  while (i < len) {
#line 102
    if ((int const   )*(pattern + i) == 33) {
#line 103
      negated = 1;
#line 104
      i ++;
    } else {
#line 106
      negated = 0;
    }
#line 112
    subi = 0U;
#line 112
    while (1) {
#line 112
      if (i < len) {
#line 112
        if (subi < sizeof(sub) - 1U) {
#line 112
          if (! ((int const   )*(pattern + i) != 44)) {
#line 112
            break;
          }
        } else {
#line 112
          break;
        }
      } else {
#line 112
        break;
      }
#line 115
      tmp___6 = __ctype_b_loc();
#line 115
      if ((int const   )*(*tmp___6 + (int )*(pattern + i)) & 256) {
#line 115
        if (sizeof(*(pattern + i)) > 1U) {
#line 115
          __res___0 = tolower((int )*(pattern + i));
        } else {
#line 115
          tmp___5 = __ctype_tolower_loc();
#line 115
          __res___0 = (int )*(*tmp___5 + (int )*(pattern + i));
        }
#line 115
        sub[subi] = (char )__res___0;
      } else {
#line 115
        sub[subi] = (char )*(pattern + i);
      }
#line 112
      subi ++;
#line 112
      i ++;
    }
#line 117
    if (subi >= sizeof(sub) - 1U) {
#line 118
      return (0);
    }
#line 121
    if (i < len) {
#line 121
      if ((int const   )*(pattern + i) == 44) {
#line 122
        i ++;
      }
    }
#line 125
    sub[subi] = (char )'\000';
#line 128
    tmp___7 = match_pattern(host, (char const   *)(sub));
#line 128
    if (tmp___7) {
#line 129
      if (negated) {
#line 130
        return (-1);
      } else {
#line 132
        got_positive = 1;
      }
    }
  }
#line 140
  return (got_positive);
}
}
#line 1 "mpaux.o"
#line 26 "mpaux.c"
void compute_session_id(unsigned char *session_id___0 , unsigned char *cookie , BIGNUM *host_key_n ,
                        BIGNUM *session_key_n ) 
{ unsigned int host_key_bytes ;
  int tmp ;
  unsigned int session_key_bytes ;
  int tmp___0 ;
  unsigned int bytes ;
  unsigned char *buf___1 ;
  void *tmp___1 ;
  MD5_CTX md ;

  {
#line 32
  tmp = BN_num_bits((BIGNUM const   *)host_key_n);
#line 32
  host_key_bytes = (unsigned int )((tmp + 7) / 8);
#line 33
  tmp___0 = BN_num_bits((BIGNUM const   *)session_key_n);
#line 33
  session_key_bytes = (unsigned int )((tmp___0 + 7) / 8);
#line 34
  bytes = host_key_bytes + session_key_bytes;
#line 35
  tmp___1 = xmalloc(bytes);
#line 35
  buf___1 = (unsigned char *)tmp___1;
#line 38
  BN_bn2bin((BIGNUM const   *)host_key_n, buf___1);
#line 39
  BN_bn2bin((BIGNUM const   *)session_key_n, buf___1 + host_key_bytes);
#line 40
  MD5_Init(& md);
#line 41
  MD5_Update(& md, (void const   *)buf___1, bytes);
#line 42
  MD5_Update(& md, (void const   *)cookie, 8U);
#line 43
  MD5_Final((unsigned char *)session_id___0, & md);
#line 44
  memset((void *)buf___1, 0, bytes);
#line 45
  xfree((void *)buf___1);
#line 46
  return;
}
}
#line 1 "nchan.o"
#line 48 "nchan.c"
chan_event_fn *chan_rcvd_oclose  =    (chan_event_fn *)((void *)0);
#line 49 "nchan.c"
chan_event_fn *chan_read_failed  =    (chan_event_fn *)((void *)0);
#line 50 "nchan.c"
chan_event_fn *chan_ibuf_empty  =    (chan_event_fn *)((void *)0);
#line 52 "nchan.c"
chan_event_fn *chan_rcvd_ieof  =    (chan_event_fn *)((void *)0);
#line 53 "nchan.c"
chan_event_fn *chan_write_failed  =    (chan_event_fn *)((void *)0);
#line 54 "nchan.c"
chan_event_fn *chan_obuf_empty  =    (chan_event_fn *)((void *)0);
#line 58
static void chan_send_ieof1(Channel *c ) ;
#line 59
static void chan_send_oclose1(Channel *c ) ;
#line 60
static void chan_send_close2(Channel *c ) ;
#line 61
static void chan_send_eof2(Channel *c ) ;
#line 64 "nchan.c"
chan_event_fn *chan_delete_if_full_closed  =    (chan_event_fn *)((void *)0);
#line 67
static void chan_shutdown_write(Channel *c ) ;
#line 68
static void chan_shutdown_read(Channel *c ) ;
#line 74 "nchan.c"
static void chan_rcvd_oclose1(Channel *c ) 
{ 

  {
#line 77
  debug("channel %d: rcvd oclose", c->self);
#line 78
  switch (c->istate) {
  case 4: 
#line 80
  debug("channel %d: input wait_oclose -> closed", c->self);
#line 81
  c->istate = 8;
#line 82
  break;
  case 1: 
#line 84
  debug("channel %d: input open -> closed", c->self);
#line 85
  chan_shutdown_read(c);
#line 86
  chan_send_ieof1(c);
#line 87
  c->istate = 8;
#line 88
  break;
  case 2: 
#line 91
  log("channel %d: input drain -> closed", c->self);
#line 92
  chan_send_ieof1(c);
#line 93
  c->istate = 8;
#line 94
  break;
  default: 
#line 96
  error("channel %d: protocol error: chan_rcvd_oclose for istate %d", c->self, c->istate);
#line 98
  return;
  }
#line 100
  return;
}
}
#line 101 "nchan.c"
static void chan_read_failed_12(Channel *c ) 
{ unsigned int tmp ;

  {
#line 104
  debug("channel %d: read failed", c->self);
#line 105
  switch (c->istate) {
  case 1: 
#line 107
  debug("channel %d: input open -> drain", c->self);
#line 108
  chan_shutdown_read(c);
#line 109
  c->istate = 2;
#line 110
  tmp = buffer_len(& c->input);
#line 110
  if (tmp == 0U) {
#line 111
    debug("channel %d: input: no drain shortcut", c->self);
#line 112
    (*chan_ibuf_empty)(c);
  }
#line 114
  break;
  default: 
#line 116
  error("channel %d: internal error: we do not read, but chan_read_failed for istate %d",
        c->self, c->istate);
#line 118
  break;
  }
#line 120
  return;
}
}
#line 121 "nchan.c"
static void chan_ibuf_empty1(Channel *c ) 
{ unsigned int tmp ;

  {
#line 124
  debug("channel %d: ibuf empty", c->self);
#line 125
  tmp = buffer_len(& c->input);
#line 125
  if (tmp) {
#line 126
    error("channel %d: internal error: chan_ibuf_empty for non empty buffer", c->self);
#line 128
    return;
  }
#line 130
  switch (c->istate) {
  case 2: 
#line 132
  debug("channel %d: input drain -> wait_oclose", c->self);
#line 133
  chan_send_ieof1(c);
#line 134
  c->istate = 4;
#line 135
  break;
  default: 
#line 137
  error("channel %d: internal error: chan_ibuf_empty for istate %d", c->self, c->istate);
#line 139
  break;
  }
#line 141
  return;
}
}
#line 142 "nchan.c"
static void chan_rcvd_ieof1(Channel *c ) 
{ 

  {
#line 145
  debug("channel %d: rcvd ieof", c->self);
#line 146
  if (c->type != 4) {
#line 147
    debug("channel %d: non-open", c->self);
#line 148
    if (c->istate == 1) {
#line 149
      debug("channel %d: non-open: input open -> wait_oclose", c->self);
#line 150
      chan_shutdown_read(c);
#line 151
      chan_send_ieof1(c);
#line 152
      c->istate = 4;
    } else {
#line 154
      error("channel %d: istate %d != open", c->self, c->istate);
    }
#line 156
    if (c->ostate == 16) {
#line 157
      debug("channel %d: non-open: output open -> closed", c->self);
#line 158
      chan_send_oclose1(c);
#line 159
      c->ostate = 128;
    } else {
#line 161
      error("channel %d: ostate %d != open", c->self, c->ostate);
    }
#line 163
    return;
  }
#line 165
  switch (c->ostate) {
  case 16: 
#line 167
  debug("channel %d: output open -> drain", c->self);
#line 168
  c->ostate = 32;
#line 169
  break;
  case 64: 
#line 171
  debug("channel %d: output wait_ieof -> closed", c->self);
#line 172
  c->ostate = 128;
#line 173
  break;
  default: 
#line 175
  error("channel %d: protocol error: chan_rcvd_ieof for ostate %d", c->self, c->ostate);
#line 177
  break;
  }
#line 179
  return;
}
}
#line 180 "nchan.c"
static void chan_write_failed1(Channel *c ) 
{ 

  {
#line 183
  debug("channel %d: write failed", c->self);
#line 184
  switch (c->ostate) {
  case 16: 
#line 186
  debug("channel %d: output open -> wait_ieof", c->self);
#line 187
  chan_send_oclose1(c);
#line 188
  c->ostate = 64;
#line 189
  break;
  case 32: 
#line 191
  debug("channel %d: output wait_drain -> closed", c->self);
#line 192
  chan_send_oclose1(c);
#line 193
  c->ostate = 128;
#line 194
  break;
  default: 
#line 196
  error("channel %d: internal error: chan_write_failed for ostate %d", c->self, c->ostate);
#line 198
  break;
  }
#line 200
  return;
}
}
#line 201 "nchan.c"
static void chan_obuf_empty1(Channel *c ) 
{ unsigned int tmp ;

  {
#line 204
  debug("channel %d: obuf empty", c->self);
#line 205
  tmp = buffer_len(& c->output);
#line 205
  if (tmp) {
#line 206
    error("channel %d: internal error: chan_obuf_empty for non empty buffer", c->self);
#line 208
    return;
  }
#line 210
  switch (c->ostate) {
  case 32: 
#line 212
  debug("channel %d: output drain -> closed", c->self);
#line 213
  chan_send_oclose1(c);
#line 214
  c->ostate = 128;
#line 215
  break;
  default: 
#line 217
  error("channel %d: internal error: chan_obuf_empty for ostate %d", c->self, c->ostate);
#line 219
  break;
  }
#line 221
  return;
}
}
#line 222 "nchan.c"
static void chan_send_ieof1(Channel *c ) 
{ 

  {
#line 225
  debug("channel %d: send ieof", c->self);
#line 226
  switch (c->istate) {
  case 1: 
  case 2: 
#line 229
  packet_start(24);
#line 230
  packet_put_int((unsigned int )c->remote_id);
#line 231
  packet_send();
#line 232
  break;
  default: 
#line 234
  error("channel %d: internal error: cannot send ieof for istate %d", c->self, c->istate);
#line 236
  break;
  }
#line 238
  return;
}
}
#line 239 "nchan.c"
static void chan_send_oclose1(Channel *c ) 
{ unsigned int tmp ;

  {
#line 242
  debug("channel %d: send oclose", c->self);
#line 243
  switch (c->ostate) {
  case 16: 
  case 32: 
#line 246
  chan_shutdown_write(c);
#line 247
  tmp = buffer_len(& c->output);
#line 247
  buffer_consume(& c->output, tmp);
#line 248
  packet_start(25);
#line 249
  packet_put_int((unsigned int )c->remote_id);
#line 250
  packet_send();
#line 251
  break;
  default: 
#line 253
  error("channel %d: internal error: cannot send oclose for ostate %d", c->self, c->ostate);
#line 255
  break;
  }
#line 257
  return;
}
}
#line 258 "nchan.c"
static void chan_delete_if_full_closed1(Channel *c ) 
{ 

  {
#line 261
  if (c->istate == 8) {
#line 261
    if (c->ostate == 128) {
#line 262
      debug("channel %d: full closed", c->self);
#line 263
      channel_free(c->self);
    }
  }
#line 265
  return;
}
}
#line 270 "nchan.c"
static void chan_rcvd_oclose2(Channel *c ) 
{ 

  {
#line 273
  debug("channel %d: rcvd close", c->self);
#line 274
  if (c->flags & 2) {
#line 275
    error("channel %d: protocol error: close rcvd twice", c->self);
  }
#line 276
  c->flags |= 2;
#line 277
  if (c->type == 10) {
#line 279
    c->ostate = 128;
#line 280
    c->istate = 8;
#line 281
    return;
  }
#line 283
  switch (c->ostate) {
  case 16: 
#line 286
  debug("channel %d: output open -> drain", c->self);
#line 287
  c->ostate = 32;
#line 288
  break;
  }
#line 290
  switch (c->istate) {
  case 1: 
#line 292
  debug("channel %d: input open -> closed", c->self);
#line 293
  chan_shutdown_read(c);
#line 294
  break;
  case 2: 
#line 296
  debug("channel %d: input drain -> closed", c->self);
#line 297
  chan_send_eof2(c);
#line 298
  break;
  }
#line 300
  c->istate = 8;
#line 301
  return;
}
}
#line 302 "nchan.c"
static void chan_ibuf_empty2(Channel *c ) 
{ unsigned int tmp ;

  {
#line 305
  debug("channel %d: ibuf empty", c->self);
#line 306
  tmp = buffer_len(& c->input);
#line 306
  if (tmp) {
#line 307
    error("channel %d: internal error: chan_ibuf_empty for non empty buffer", c->self);
#line 309
    return;
  }
#line 311
  switch (c->istate) {
  case 2: 
#line 313
  debug("channel %d: input drain -> closed", c->self);
#line 314
  if (! (c->flags & 1)) {
#line 315
    chan_send_eof2(c);
  }
#line 316
  c->istate = 8;
#line 317
  break;
  default: 
#line 319
  error("channel %d: internal error: chan_ibuf_empty for istate %d", c->self, c->istate);
#line 321
  break;
  }
#line 323
  return;
}
}
#line 324 "nchan.c"
static void chan_rcvd_ieof2(Channel *c ) 
{ 

  {
#line 327
  debug("channel %d: rcvd eof", c->self);
#line 328
  if (c->ostate == 16) {
#line 329
    debug("channel %d: output open -> drain", c->self);
#line 330
    c->ostate = 32;
  }
#line 332
  return;
}
}
#line 333 "nchan.c"
static void chan_write_failed2(Channel *c ) 
{ 

  {
#line 336
  debug("channel %d: write failed", c->self);
#line 337
  switch (c->ostate) {
  case 16: 
#line 339
  debug("channel %d: output open -> closed", c->self);
#line 340
  chan_shutdown_write(c);
#line 341
  c->ostate = 128;
#line 342
  break;
  case 32: 
#line 344
  debug("channel %d: output drain -> closed", c->self);
#line 345
  chan_shutdown_write(c);
#line 346
  c->ostate = 128;
#line 347
  break;
  default: 
#line 349
  error("channel %d: internal error: chan_write_failed for ostate %d", c->self, c->ostate);
#line 351
  break;
  }
#line 353
  return;
}
}
#line 354 "nchan.c"
static void chan_obuf_empty2(Channel *c ) 
{ unsigned int tmp ;

  {
#line 357
  debug("channel %d: obuf empty", c->self);
#line 358
  tmp = buffer_len(& c->output);
#line 358
  if (tmp) {
#line 359
    error("internal error: chan_obuf_empty %d for non empty buffer", c->self);
#line 361
    return;
  }
#line 363
  switch (c->ostate) {
  case 32: 
#line 365
  debug("channel %d: output drain -> closed", c->self);
#line 366
  chan_shutdown_write(c);
#line 367
  c->ostate = 128;
#line 368
  break;
  default: 
#line 370
  error("channel %d: internal error: chan_obuf_empty for ostate %d", c->self, c->ostate);
#line 372
  break;
  }
#line 374
  return;
}
}
#line 375 "nchan.c"
static void chan_send_eof2(Channel *c ) 
{ 

  {
#line 378
  debug("channel %d: send eof", c->self);
#line 379
  switch (c->istate) {
  case 2: 
#line 381
  packet_start(96);
#line 382
  packet_put_int((unsigned int )c->remote_id);
#line 383
  packet_send();
#line 384
  break;
  default: 
#line 386
  error("channel %d: internal error: cannot send eof for istate %d", c->self, c->istate);
#line 388
  break;
  }
#line 390
  return;
}
}
#line 391 "nchan.c"
static void chan_send_close2(Channel *c ) 
{ 

  {
#line 394
  debug("channel %d: send close", c->self);
#line 395
  if (c->ostate != 128) {
#line 397
    error("channel %d: internal error: cannot send close for istate/ostate %d/%d",
          c->self, c->istate, c->ostate);
  } else {
#line 395
    if (c->istate != 8) {
#line 397
      error("channel %d: internal error: cannot send close for istate/ostate %d/%d",
            c->self, c->istate, c->ostate);
    } else {
#line 399
      if (c->flags & 1) {
#line 400
        error("channel %d: internal error: already sent close", c->self);
      } else {
#line 402
        packet_start(97);
#line 403
        packet_put_int((unsigned int )c->remote_id);
#line 404
        packet_send();
#line 405
        c->flags |= 1;
      }
    }
  }
#line 407
  return;
}
}
#line 408 "nchan.c"
static void chan_delete_if_full_closed2(Channel *c ) 
{ 

  {
#line 411
  if (c->istate == 8) {
#line 411
    if (c->ostate == 128) {
#line 412
      if (! (c->flags & 1)) {
#line 413
        chan_send_close2(c);
      }
#line 415
      if (c->flags & 1) {
#line 415
        if (c->flags & 2) {
#line 417
          debug("channel %d: full closed2", c->self);
#line 418
          channel_free(c->self);
        }
      }
    }
  }
#line 421
  return;
}
}
#line 424 "nchan.c"
void chan_init_iostates(Channel *c ) 
{ 

  {
#line 427
  c->ostate = 16;
#line 428
  c->istate = 1;
#line 429
  c->flags = 0;
#line 430
  return;
}
}
#line 433 "nchan.c"
void chan_init(void) 
{ 

  {
#line 436
  if (compat20) {
#line 437
    chan_rcvd_oclose = & chan_rcvd_oclose2;
#line 438
    chan_read_failed = & chan_read_failed_12;
#line 439
    chan_ibuf_empty = & chan_ibuf_empty2;
#line 441
    chan_rcvd_ieof = & chan_rcvd_ieof2;
#line 442
    chan_write_failed = & chan_write_failed2;
#line 443
    chan_obuf_empty = & chan_obuf_empty2;
#line 445
    chan_delete_if_full_closed = & chan_delete_if_full_closed2;
  } else {
#line 447
    chan_rcvd_oclose = & chan_rcvd_oclose1;
#line 448
    chan_read_failed = & chan_read_failed_12;
#line 449
    chan_ibuf_empty = & chan_ibuf_empty1;
#line 451
    chan_rcvd_ieof = & chan_rcvd_ieof1;
#line 452
    chan_write_failed = & chan_write_failed1;
#line 453
    chan_obuf_empty = & chan_obuf_empty1;
#line 455
    chan_delete_if_full_closed = & chan_delete_if_full_closed1;
  }
#line 457
  return;
}
}
#line 460 "nchan.c"
static void chan_shutdown_write(Channel *c ) 
{ unsigned int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 463
  tmp = buffer_len(& c->output);
#line 463
  buffer_consume(& c->output, tmp);
#line 464
  if (compat20) {
#line 464
    if (c->type == 10) {
#line 465
      return;
    }
  }
#line 467
  debug("channel %d: close_write", c->self);
#line 468
  if (c->sock != -1) {
#line 469
    tmp___2 = shutdown(c->sock, 1);
#line 469
    if (tmp___2 < 0) {
#line 470
      tmp___0 = __errno_location();
#line 470
      tmp___1 = strerror(*tmp___0);
#line 470
      debug("channel %d: chan_shutdown_write: shutdown() failed for fd%d: %.100s",
            c->self, c->sock, tmp___1);
    }
  } else {
#line 473
    tmp___5 = close(c->wfd);
#line 473
    if (tmp___5 < 0) {
#line 474
      tmp___3 = __errno_location();
#line 474
      tmp___4 = strerror(*tmp___3);
#line 474
      log("channel %d: chan_shutdown_write: close() failed for fd%d: %.100s", c->self,
          c->wfd, tmp___4);
    }
#line 476
    c->wfd = -1;
  }
#line 478
  return;
}
}
#line 479 "nchan.c"
static void chan_shutdown_read(Channel *c ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 482
  if (compat20) {
#line 482
    if (c->type == 10) {
#line 483
      return;
    }
  }
#line 484
  debug("channel %d: close_read", c->self);
#line 485
  if (c->sock != -1) {
#line 490
    tmp___1 = shutdown(c->sock, 0);
#line 490
    if (tmp___1 < 0) {
#line 490
      tmp___2 = __errno_location();
#line 490
      if (*tmp___2 != 107) {
#line 494
        tmp = __errno_location();
#line 494
        tmp___0 = strerror(*tmp);
#line 494
        error("channel %d: chan_shutdown_read: shutdown() failed for fd%d [i%d o%d]: %.100s",
              c->self, c->sock, c->istate, c->ostate, tmp___0);
      } else {
#line 490
        if (c->ostate == 16) {
#line 494
          tmp = __errno_location();
#line 494
          tmp___0 = strerror(*tmp);
#line 494
          error("channel %d: chan_shutdown_read: shutdown() failed for fd%d [i%d o%d]: %.100s",
                c->self, c->sock, c->istate, c->ostate, tmp___0);
        } else {
#line 490
          if (c->ostate == 32) {
#line 494
            tmp = __errno_location();
#line 494
            tmp___0 = strerror(*tmp);
#line 494
            error("channel %d: chan_shutdown_read: shutdown() failed for fd%d [i%d o%d]: %.100s",
                  c->self, c->sock, c->istate, c->ostate, tmp___0);
          }
        }
      }
    }
  } else {
#line 497
    tmp___5 = close(c->rfd);
#line 497
    if (tmp___5 < 0) {
#line 498
      tmp___3 = __errno_location();
#line 498
      tmp___4 = strerror(*tmp___3);
#line 498
      log("channel %d: chan_shutdown_read: close() failed for fd%d: %.100s", c->self,
          c->rfd, tmp___4);
    }
#line 500
    c->rfd = -1;
  }
#line 502
  return;
}
}
#line 1 "packet.o"
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 361 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 28 "packet.h"
void packet_set_connection(int fd_in , int fd_out ) ;
#line 31
void packet_set_nonblocking(void) ;
#line 37
int packet_get_connection_out(void) ;
#line 43
void packet_close(void) ;
#line 50
void packet_set_encryption_key(unsigned char const   *key , unsigned int keylen ,
                               int cipher ) ;
#line 58
void packet_set_protocol_flags(unsigned int protocol_flags ) ;
#line 61
unsigned int packet_get_protocol_flags(void) ;
#line 64
void packet_start_compression(int level ) ;
#line 70
void packet_set_interactive(int interactive , int keepalives ) ;
#line 85
void packet_put_bignum(BIGNUM *value ) ;
#line 86
void packet_put_bignum2(BIGNUM *value ) ;
#line 122
void packet_process_incoming(char const   *buf___1 , unsigned int len ) ;
#line 134
void packet_get_bignum(BIGNUM *value , int *length_ptr ) ;
#line 135
void packet_get_bignum2(BIGNUM *value , int *length_ptr ) ;
#line 167
void packet_write_poll(void) ;
#line 173
int packet_have_data_to_write(void) ;
#line 176
int packet_not_very_much_data_to_write(void) ;
#line 180
int packet_set_maxsize(int s ) ;
#line 211
int packet_connection_is_ipv4(void) ;
#line 214
void packet_set_ssh2_format(void) ;
#line 102 "kex.h"
void packet_set_kex(Kex *k ) ;
#line 57 "packet.c"
static int connection_in  =    -1;
#line 58 "packet.c"
static int connection_out  =    -1;
#line 64 "packet.c"
static int cipher_type  =    0;
#line 67 "packet.c"
static unsigned int remote_protocol_flags  =    0U;
#line 70 "packet.c"
static CipherContext receive_context  ;
#line 73 "packet.c"
static CipherContext send_context  ;
#line 76 "packet.c"
static Buffer input  ;
#line 79 "packet.c"
static Buffer output  ;
#line 82 "packet.c"
static Buffer outgoing_packet  ;
#line 85 "packet.c"
static Buffer incoming_packet  ;
#line 88 "packet.c"
static Buffer compression_buffer  ;
#line 91 "packet.c"
static int packet_compression  =    0;
#line 94 "packet.c"
int max_packet_size  =    32768;
#line 97 "packet.c"
static int initialized  =    0;
#line 100 "packet.c"
static int interactive_mode  =    0;
#line 103 "packet.c"
int use_ssh2_packet_format  =    0;
#line 106 "packet.c"
Kex *kex  =    (Kex *)((void *)0);
#line 108 "packet.c"
void packet_set_kex(Kex *k ) 
{ 

  {
#line 111
  if ((unsigned int )k->mac[0].key == (unsigned int )((void *)0)) {
#line 117
    fatal("bad KEX");
  } else {
#line 111
    if ((unsigned int )k->enc[0].key == (unsigned int )((void *)0)) {
#line 117
      fatal("bad KEX");
    } else {
#line 111
      if ((unsigned int )k->enc[0].iv == (unsigned int )((void *)0)) {
#line 117
        fatal("bad KEX");
      } else {
#line 111
        if ((unsigned int )k->mac[1].key == (unsigned int )((void *)0)) {
#line 117
          fatal("bad KEX");
        } else {
#line 111
          if ((unsigned int )k->enc[1].key == (unsigned int )((void *)0)) {
#line 117
            fatal("bad KEX");
          } else {
#line 111
            if ((unsigned int )k->enc[1].iv == (unsigned int )((void *)0)) {
#line 117
              fatal("bad KEX");
            }
          }
        }
      }
    }
  }
#line 118
  kex = k;
#line 119
  return;
}
}
#line 120 "packet.c"
void clear_enc_keys(Enc *enc , int len ) 
{ 

  {
#line 123
  memset((void *)enc->iv, 0, (unsigned int )len);
#line 124
  memset((void *)enc->key, 0, (unsigned int )len);
#line 125
  xfree((void *)enc->iv);
#line 126
  xfree((void *)enc->key);
#line 127
  enc->iv = (unsigned char *)((void *)0);
#line 128
  enc->key = (unsigned char *)((void *)0);
#line 129
  return;
}
}
#line 130 "packet.c"
void packet_set_ssh2_format(void) 
{ 

  {
#line 134
  use_ssh2_packet_format = 1;
#line 135
  return;
}
}
#line 141 "packet.c"
void packet_set_connection(int fd_in , int fd_out ) 
{ 

  {
#line 144
  connection_in = fd_in;
#line 145
  connection_out = fd_out;
#line 146
  cipher_type = 0;
#line 147
  cipher_set_key(& send_context, 0, (unsigned char const   *)((unsigned char *)""),
                 0);
#line 148
  cipher_set_key(& receive_context, 0, (unsigned char const   *)((unsigned char *)""),
                 0);
#line 149
  if (! initialized) {
#line 150
    initialized = 1;
#line 151
    buffer_init(& input);
#line 152
    buffer_init(& output);
#line 153
    buffer_init(& outgoing_packet);
#line 154
    buffer_init(& incoming_packet);
  }
#line 157
  fatal_add_cleanup((void (*)(void * ))(& packet_close), (void *)0);
#line 158
  return;
}
}
#line 162 "packet.c"
int packet_connection_is_on_socket(void) 
{ struct sockaddr_storage from ;
  struct sockaddr_storage to ;
  socklen_t fromlen ;
  socklen_t tolen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 169
  if (connection_in == connection_out) {
#line 170
    return (1);
  }
#line 171
  fromlen = sizeof(from);
#line 172
  memset((void *)(& from), 0, sizeof(from));
#line 173
  tmp = getpeername(connection_in, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                    (socklen_t * __restrict  )(& fromlen));
#line 173
  if (tmp < 0) {
#line 174
    return (0);
  }
#line 175
  tolen = sizeof(to);
#line 176
  memset((void *)(& to), 0, sizeof(to));
#line 177
  tmp___0 = getpeername(connection_out, (struct sockaddr * __restrict  )((struct sockaddr *)(& to)),
                        (socklen_t * __restrict  )(& tolen));
#line 177
  if (tmp___0 < 0) {
#line 178
    return (0);
  }
#line 179
  if (fromlen != tolen) {
#line 180
    return (0);
  } else {
#line 179
    tmp___1 = memcmp((void const   *)(& from), (void const   *)(& to), fromlen);
#line 179
    if (tmp___1 != 0) {
#line 180
      return (0);
    }
  }
#line 181
  if ((int )from.ss_family != 2) {
#line 181
    if ((int )from.ss_family != 10) {
#line 182
      return (0);
    }
  }
#line 183
  return (1);
}
}
#line 188 "packet.c"
int packet_connection_is_ipv4(void) 
{ struct sockaddr_storage to ;
  socklen_t tolen ;
  int tmp ;

  {
#line 192
  tolen = sizeof(to);
#line 194
  memset((void *)(& to), 0, sizeof(to));
#line 195
  tmp = getsockname(connection_out, (struct sockaddr * __restrict  )((struct sockaddr *)(& to)),
                    (socklen_t * __restrict  )(& tolen));
#line 195
  if (tmp < 0) {
#line 196
    return (0);
  }
#line 197
  if ((int )to.ss_family != 2) {
#line 198
    return (0);
  }
#line 199
  return (1);
}
}
#line 204 "packet.c"
void packet_set_nonblocking(void) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 208
  tmp___1 = fcntl(connection_in, 4, 2048);
#line 208
  if (tmp___1 < 0) {
#line 209
    tmp = __errno_location();
#line 209
    tmp___0 = strerror(*tmp);
#line 209
    error("fcntl O_NONBLOCK: %.100s", tmp___0);
  }
#line 211
  if (connection_out != connection_in) {
#line 212
    tmp___4 = fcntl(connection_out, 4, 2048);
#line 212
    if (tmp___4 < 0) {
#line 213
      tmp___2 = __errno_location();
#line 213
      tmp___3 = strerror(*tmp___2);
#line 213
      error("fcntl O_NONBLOCK: %.100s", tmp___3);
    }
  }
#line 215
  return;
}
}
#line 219 "packet.c"
int packet_get_connection_in(void) 
{ 

  {
#line 222
  return (connection_in);
}
}
#line 227 "packet.c"
int packet_get_connection_out(void) 
{ 

  {
#line 230
  return (connection_out);
}
}
#line 235 "packet.c"
void packet_close(void) 
{ 

  {
#line 238
  if (! initialized) {
#line 239
    return;
  }
#line 240
  initialized = 0;
#line 241
  if (connection_in == connection_out) {
#line 242
    shutdown(connection_out, 2);
#line 243
    close(connection_out);
  } else {
#line 245
    close(connection_in);
#line 246
    close(connection_out);
  }
#line 248
  buffer_free(& input);
#line 249
  buffer_free(& output);
#line 250
  buffer_free(& outgoing_packet);
#line 251
  buffer_free(& incoming_packet);
#line 252
  if (packet_compression) {
#line 253
    buffer_free(& compression_buffer);
#line 254
    buffer_compress_uninit();
  }
#line 256
  return;
}
}
#line 260 "packet.c"
void packet_set_protocol_flags(unsigned int protocol_flags ) 
{ 

  {
#line 263
  remote_protocol_flags = protocol_flags;
#line 264
  channel_set_options((protocol_flags & 2U) != 0U);
#line 265
  return;
}
}
#line 269 "packet.c"
unsigned int packet_get_protocol_flags(void) 
{ 

  {
#line 272
  return (remote_protocol_flags);
}
}
#line 281 "packet.c"
void packet_start_compression(int level ) 
{ 

  {
#line 284
  if (packet_compression) {
#line 285
    fatal("Compression already enabled.");
  }
#line 286
  packet_compression = 1;
#line 287
  buffer_init(& compression_buffer);
#line 288
  buffer_compress_init(level);
#line 289
  return;
}
}
#line 296 "packet.c"
void packet_encrypt(CipherContext *cc , void *dest , void *src , unsigned int bytes ) 
{ 

  {
#line 300
  cipher_encrypt(cc, (unsigned char *)dest, (unsigned char const   *)src, bytes);
#line 301
  return;
}
}
#line 308 "packet.c"
void packet_decrypt(CipherContext *cc , void *dest , void *src , unsigned int bytes ) 
{ int i ;

  {
#line 314
  if (bytes % 8U != 0U) {
#line 315
    fatal("packet_decrypt: bad ciphertext length %d", bytes);
  }
#line 322
  if (cc->type == 0U) {
#line 323
    i = 0;
  } else {
#line 322
    if (compat20) {
#line 323
      i = 0;
    } else {
#line 325
      i = detect_attack((unsigned char *)src, bytes, (unsigned char *)((void *)0));
    }
  }
#line 327
  if (i == 1) {
#line 328
    packet_disconnect("crc32 compensation attack: network attack detected");
  }
#line 330
  cipher_decrypt(cc, (unsigned char *)dest, (unsigned char const   *)src, bytes);
#line 331
  return;
}
}
#line 339 "packet.c"
void packet_set_encryption_key(unsigned char const   *key , unsigned int keylen ,
                               int cipher ) 
{ 

  {
#line 343
  if (keylen < 20U) {
#line 344
    fatal("keylen too small: %d", keylen);
  }
#line 347
  cipher_set_key(& receive_context, cipher, key, (int )keylen);
#line 348
  cipher_set_key(& send_context, cipher, key, (int )keylen);
#line 349
  return;
}
}
#line 353 "packet.c"
void packet_start1(int type ) 
{ char buf___1[9] ;

  {
#line 358
  buffer_clear(& outgoing_packet);
#line 359
  memset((void *)(buf___1), 0, 8U);
#line 360
  buf___1[8] = (char )type;
#line 361
  buffer_append(& outgoing_packet, (char const   *)(buf___1), 9U);
#line 362
  return;
}
}
#line 364 "packet.c"
void packet_start2(int type ) 
{ char buf___1[6] ;

  {
#line 369
  buffer_clear(& outgoing_packet);
#line 370
  memset((void *)(buf___1), 0, sizeof(buf___1));
#line 373
  buf___1[5] = (char )(type & 255);
#line 374
  buffer_append(& outgoing_packet, (char const   *)(buf___1), sizeof(buf___1));
#line 375
  return;
}
}
#line 377 "packet.c"
void packet_start(int type ) 
{ 

  {
#line 381
  if (use_ssh2_packet_format) {
#line 382
    packet_start2(type);
  } else {
#line 384
    packet_start1(type);
  }
#line 385
  return;
}
}
#line 389 "packet.c"
void packet_put_char(int value ) 
{ char ch ;

  {
#line 392
  ch = (char )value;
#line 393
  buffer_append(& outgoing_packet, (char const   *)(& ch), 1U);
#line 394
  return;
}
}
#line 398 "packet.c"
void packet_put_int(unsigned int value ) 
{ 

  {
#line 401
  buffer_put_int(& outgoing_packet, value);
#line 402
  return;
}
}
#line 406 "packet.c"
void packet_put_string(char const   *buf___1 , unsigned int len ) 
{ 

  {
#line 409
  buffer_put_string(& outgoing_packet, (void const   *)buf___1, len);
#line 410
  return;
}
}
#line 411 "packet.c"
void packet_put_cstring(char const   *str ) 
{ size_t tmp ;

  {
#line 414
  tmp = strlen(str);
#line 414
  buffer_put_string(& outgoing_packet, (void const   *)str, tmp);
#line 415
  return;
}
}
#line 417 "packet.c"
void packet_put_raw(char const   *buf___1 , unsigned int len ) 
{ 

  {
#line 420
  buffer_append(& outgoing_packet, buf___1, len);
#line 421
  return;
}
}
#line 426 "packet.c"
void packet_put_bignum(BIGNUM *value ) 
{ 

  {
#line 429
  buffer_put_bignum(& outgoing_packet, value);
#line 430
  return;
}
}
#line 431 "packet.c"
void packet_put_bignum2(BIGNUM *value ) 
{ 

  {
#line 434
  buffer_put_bignum2(& outgoing_packet, value);
#line 435
  return;
}
}
#line 442 "packet.c"
void packet_send1(void) 
{ char buf___1[8] ;
  char *cp ;
  int i ;
  int padding ;
  int len ;
  unsigned int checksum ;
  u_int32_t rand___0 ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  char *tmp___6 ;

  {
#line 448
  rand___0 = (u_int32_t )0;
#line 454
  if (packet_compression) {
#line 455
    buffer_clear(& compression_buffer);
#line 457
    buffer_consume(& outgoing_packet, 8U);
#line 459
    buffer_append(& compression_buffer, "\000\000\000\000\000\000\000\000", 8U);
#line 460
    buffer_compress(& outgoing_packet, & compression_buffer);
#line 461
    buffer_clear(& outgoing_packet);
#line 462
    tmp = buffer_len(& compression_buffer);
#line 462
    tmp___0 = buffer_ptr(& compression_buffer);
#line 462
    buffer_append(& outgoing_packet, (char const   *)tmp___0, tmp);
  }
#line 466
  tmp___1 = buffer_len(& outgoing_packet);
#line 466
  len = (int )((tmp___1 + 4U) - 8U);
#line 469
  padding = 8 - len % 8;
#line 470
  if (cipher_type != 0) {
#line 471
    cp = buffer_ptr(& outgoing_packet);
#line 472
    i = 0;
#line 472
    while (i < padding) {
#line 473
      if (i % 4 == 0) {
#line 474
        rand___0 = arc4random();
      }
#line 475
      *(cp + (7 - i)) = (char )(rand___0 & 255U);
#line 476
      rand___0 >>= 8;
#line 472
      i ++;
    }
  }
#line 479
  buffer_consume(& outgoing_packet, (unsigned int )(8 - padding));
#line 482
  tmp___2 = buffer_len(& outgoing_packet);
#line 482
  tmp___3 = buffer_ptr(& outgoing_packet);
#line 482
  checksum = ssh_crc32((unsigned char const   *)((unsigned char *)tmp___3), tmp___2);
#line 484
  while (1) {
#line 484
    buf___1[0] = (char )(checksum >> 24);
#line 484
    buf___1[1] = (char )(checksum >> 16);
#line 484
    buf___1[2] = (char )(checksum >> 8);
#line 484
    buf___1[3] = (char )checksum;
#line 484
    break;
  }
#line 485
  buffer_append(& outgoing_packet, (char const   *)(buf___1), 4U);
#line 493
  while (1) {
#line 493
    buf___1[0] = (char )(len >> 24);
#line 493
    buf___1[1] = (char )(len >> 16);
#line 493
    buf___1[2] = (char )(len >> 8);
#line 493
    buf___1[3] = (char )len;
#line 493
    break;
  }
#line 494
  buffer_append(& output, (char const   *)(buf___1), 4U);
#line 495
  tmp___4 = buffer_len(& outgoing_packet);
#line 495
  buffer_append_space(& output, & cp, tmp___4);
#line 496
  tmp___5 = buffer_len(& outgoing_packet);
#line 496
  tmp___6 = buffer_ptr(& outgoing_packet);
#line 496
  packet_encrypt(& send_context, (void *)cp, (void *)tmp___6, tmp___5);
#line 504
  buffer_clear(& outgoing_packet);
#line 511
  return;
}
}
#line 524
void packet_send2(void) ;
#line 524 "packet.c"
static unsigned int seqnr  =    0U;
#line 516 "packet.c"
void packet_send2(void) 
{ unsigned char *macbuf ;
  char *cp ;
  unsigned int packet_length___0 ;
  unsigned int i ;
  unsigned int padlen ;
  unsigned int len ;
  u_int32_t rand___0 ;
  int type ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  int block_size ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  char *tmp___6 ;

  {
#line 519
  macbuf = (unsigned char *)((void *)0);
#line 521
  packet_length___0 = 0U;
#line 523
  rand___0 = (u_int32_t )0;
#line 526
  enc = (Enc *)((void *)0);
#line 527
  mac = (Mac *)((void *)0);
#line 528
  comp = (Comp *)((void *)0);
#line 531
  if ((unsigned int )kex != (unsigned int )((void *)0)) {
#line 532
    enc = & kex->enc[1];
#line 533
    mac = & kex->mac[1];
#line 534
    comp = & kex->comp[1];
  }
#line 536
  if (enc) {
#line 536
    block_size = enc->block_size;
  } else {
#line 536
    block_size = 8;
  }
#line 538
  cp = buffer_ptr(& outgoing_packet);
#line 539
  type = (int )*(cp + 5) & 255;
#line 546
  if (comp) {
#line 546
    if (comp->enabled) {
#line 547
      len = buffer_len(& outgoing_packet);
#line 549
      buffer_consume(& outgoing_packet, 5U);
#line 550
      buffer_clear(& compression_buffer);
#line 551
      buffer_compress(& outgoing_packet, & compression_buffer);
#line 552
      buffer_clear(& outgoing_packet);
#line 553
      buffer_append(& outgoing_packet, "\000\000\000\000\000", 5U);
#line 554
      tmp = buffer_len(& compression_buffer);
#line 554
      tmp___0 = buffer_ptr(& compression_buffer);
#line 554
      buffer_append(& outgoing_packet, (char const   *)tmp___0, tmp);
    }
  }
#line 561
  len = buffer_len(& outgoing_packet);
#line 567
  padlen = (unsigned int )block_size - len % (unsigned int )block_size;
#line 568
  if (padlen < 4U) {
#line 569
    padlen += (unsigned int )block_size;
  }
#line 570
  buffer_append_space(& outgoing_packet, & cp, padlen);
#line 571
  if (enc) {
#line 571
    if (enc->type != 0) {
#line 573
      i = 0U;
#line 573
      while (i < padlen) {
#line 574
        if (i % 4U == 0U) {
#line 575
          rand___0 = arc4random();
        }
#line 576
        *(cp + i) = (char )(rand___0 & 255U);
#line 577
        rand___0 <<= 8;
#line 573
        i ++;
      }
    } else {
#line 581
      memset((void *)cp, 0, padlen);
    }
  } else {
#line 581
    memset((void *)cp, 0, padlen);
  }
#line 584
  tmp___1 = buffer_len(& outgoing_packet);
#line 584
  packet_length___0 = tmp___1 - 4U;
#line 585
  cp = buffer_ptr(& outgoing_packet);
#line 586
  while (1) {
#line 586
    *(cp + 0) = (char )(packet_length___0 >> 24);
#line 586
    *(cp + 1) = (char )(packet_length___0 >> 16);
#line 586
    *(cp + 2) = (char )(packet_length___0 >> 8);
#line 586
    *(cp + 3) = (char )packet_length___0;
#line 586
    break;
  }
#line 587
  *(cp + 4) = (char )(padlen & 255U);
#line 591
  if (mac) {
#line 591
    if (mac->enabled) {
#line 592
      tmp___2 = buffer_len(& outgoing_packet);
#line 592
      tmp___3 = buffer_ptr(& outgoing_packet);
#line 592
      macbuf = hmac(mac->md, seqnr, (unsigned char *)tmp___3, (int )tmp___2, mac->key,
                    mac->key_len);
    }
  }
#line 600
  tmp___4 = buffer_len(& outgoing_packet);
#line 600
  buffer_append_space(& output, & cp, tmp___4);
#line 601
  tmp___5 = buffer_len(& outgoing_packet);
#line 601
  tmp___6 = buffer_ptr(& outgoing_packet);
#line 601
  packet_encrypt(& send_context, (void *)cp, (void *)tmp___6, tmp___5);
#line 604
  if (mac) {
#line 604
    if (mac->enabled) {
#line 605
      buffer_append(& output, (char const   *)((char *)macbuf), (unsigned int )mac->mac_len);
    }
  }
#line 611
  seqnr ++;
#line 611
  if (seqnr == 0U) {
#line 612
    log("outgoing seqnr wraps around");
  }
#line 613
  buffer_clear(& outgoing_packet);
#line 615
  if (type == 21) {
#line 616
    if ((unsigned int )kex == (unsigned int )((void *)0)) {
#line 617
      fatal("packet_send2: no KEX");
    } else {
#line 616
      if ((unsigned int )mac == (unsigned int )((void *)0)) {
#line 617
        fatal("packet_send2: no KEX");
      } else {
#line 616
        if ((unsigned int )enc == (unsigned int )((void *)0)) {
#line 617
          fatal("packet_send2: no KEX");
        } else {
#line 616
          if ((unsigned int )comp == (unsigned int )((void *)0)) {
#line 617
            fatal("packet_send2: no KEX");
          }
        }
      }
    }
#line 618
    if ((unsigned int )mac->md != (unsigned int )((void *)0)) {
#line 619
      mac->enabled = 1;
    }
#line 621
    cipher_set_key_iv(& send_context, enc->type, (unsigned char const   *)enc->key,
                      enc->key_len, (unsigned char const   *)enc->iv, enc->iv_len);
#line 624
    clear_enc_keys(enc, kex->we_need);
#line 625
    if (comp->type != 0) {
#line 625
      if (comp->enabled == 0) {
#line 626
        comp->enabled = 1;
#line 627
        if (! packet_compression) {
#line 628
          packet_start_compression(6);
        }
      }
    }
  }
#line 631
  return;
}
}
#line 633 "packet.c"
void packet_send(void) 
{ 

  {
#line 636
  if (use_ssh2_packet_format) {
#line 637
    packet_send2();
  } else {
#line 639
    packet_send1();
  }
#line 641
  return;
}
}
#line 649 "packet.c"
int packet_read(int *payload_len_ptr ) 
{ int type ;
  int len ;
  fd_set set ;
  char buf___1[8192] ;
  int _p ;
  int _e ;
  int __d0 ;
  int __d1 ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 658
  packet_write_wait();
#line 661
  while (1) {
#line 663
    type = packet_read_poll(payload_len_ptr);
#line 664
    if (! use_ssh2_packet_format) {
#line 664
      if (type == 14) {
        goto _L;
      } else {
#line 664
        if (type == 15) {
          goto _L;
        } else {
#line 664
          if (type == 19) {
            goto _L;
          } else {
#line 664
            if (type == 33) {
              _L: /* CIL Label */ 
#line 669
              while (1) {
#line 669
                _p = *payload_len_ptr;
#line 669
                _e = 0;
#line 669
                if (_p != _e) {
#line 669
                  log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "packet.c",
                      669);
#line 669
                  packet_disconnect("Packet integrity error. (%d)", type);
                }
#line 669
                break;
              }
            }
          }
        }
      }
    }
#line 671
    if (type != 0) {
#line 672
      return (type);
    }
#line 677
    while (1) {
#line 677
      __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& set.__fds_bits[0]): "memory");
#line 677
      break;
    }
#line 678
    __asm__  volatile   ("btsl %1,%0": "=m" (set.__fds_bits[(unsigned int )connection_in / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 681
    select(connection_in + 1, (fd_set * __restrict  )(& set), (fd_set * __restrict  )((void *)0),
           (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 684
    len = read(connection_in, (void *)(buf___1), sizeof(buf___1));
#line 685
    if (len == 0) {
#line 686
      tmp = get_remote_ipaddr();
#line 686
      log("Connection closed by %.200s", tmp);
#line 687
      fatal_cleanup();
    }
#line 689
    if (len < 0) {
#line 690
      tmp___0 = __errno_location();
#line 690
      tmp___1 = strerror(*tmp___0);
#line 690
      fatal("Read from socket failed: %.100s", tmp___1);
    }
#line 692
    packet_process_incoming((char const   *)(buf___1), (unsigned int )len);
  }
}
}
#line 702 "packet.c"
void packet_read_expect(int *payload_len_ptr , int expected_type ) 
{ int type ;

  {
#line 707
  type = packet_read(payload_len_ptr);
#line 708
  if (type != expected_type) {
#line 709
    packet_disconnect("Protocol error: expected packet type %d, got %d", expected_type,
                      type);
  }
#line 711
  return;
}
}
#line 728 "packet.c"
int packet_read_poll1(int *payload_len_ptr ) 
{ unsigned int len ;
  unsigned int padded_len ;
  unsigned char *ucp ;
  char buf___1[8] ;
  char *cp ;
  unsigned int checksum ;
  unsigned int stored_checksum ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  char *tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  unsigned int tmp___8 ;
  char *tmp___9 ;
  unsigned int tmp___10 ;

  {
#line 737
  tmp = buffer_len(& input);
#line 737
  if (tmp < 12U) {
#line 738
    return (0);
  }
#line 740
  tmp___0 = buffer_ptr(& input);
#line 740
  ucp = (unsigned char *)tmp___0;
#line 741
  len = (unsigned int )(((((unsigned long )*(ucp + 0) << 24) | ((unsigned long )*(ucp + 1) << 16)) | ((unsigned long )*(ucp + 2) << 8)) | (unsigned long )*(ucp + 3));
#line 742
  if (len < 5U) {
#line 743
    packet_disconnect("Bad packet length %d.", len);
  } else {
#line 742
    if (len > 262144U) {
#line 743
      packet_disconnect("Bad packet length %d.", len);
    }
  }
#line 744
  padded_len = (len + 8U) & 4294967288U;
#line 747
  tmp___1 = buffer_len(& input);
#line 747
  if (tmp___1 < 4U + padded_len) {
#line 748
    return (0);
  }
#line 753
  buffer_consume(& input, 4U);
#line 756
  buffer_clear(& incoming_packet);
#line 757
  buffer_append_space(& incoming_packet, & cp, padded_len);
#line 758
  tmp___2 = buffer_ptr(& input);
#line 758
  packet_decrypt(& receive_context, (void *)cp, (void *)tmp___2, padded_len);
#line 759
  buffer_consume(& input, padded_len);
#line 767
  tmp___3 = buffer_len(& incoming_packet);
#line 767
  tmp___4 = buffer_ptr(& incoming_packet);
#line 767
  checksum = ssh_crc32((unsigned char const   *)((unsigned char *)tmp___4), tmp___3 - 4U);
#line 771
  buffer_consume(& incoming_packet, 8U - len % 8U);
#line 775
  tmp___6 = buffer_len(& incoming_packet);
#line 775
  if (len != tmp___6) {
#line 776
    tmp___5 = buffer_len(& incoming_packet);
#line 776
    packet_disconnect("packet_read_poll: len %d != buffer_len %d.", len, tmp___5);
  }
#line 779
  tmp___7 = buffer_ptr(& incoming_packet);
#line 779
  ucp = ((unsigned char *)tmp___7 + len) - 4;
#line 780
  stored_checksum = (unsigned int )(((((unsigned long )*(ucp + 0) << 24) | ((unsigned long )*(ucp + 1) << 16)) | ((unsigned long )*(ucp + 2) << 8)) | (unsigned long )*(ucp + 3));
#line 781
  if (checksum != stored_checksum) {
#line 782
    packet_disconnect("Corrupted check bytes on input.");
  }
#line 783
  buffer_consume_end(& incoming_packet, 4U);
#line 786
  if (packet_compression) {
#line 787
    buffer_clear(& compression_buffer);
#line 788
    buffer_uncompress(& incoming_packet, & compression_buffer);
#line 789
    buffer_clear(& incoming_packet);
#line 790
    tmp___8 = buffer_len(& compression_buffer);
#line 790
    tmp___9 = buffer_ptr(& compression_buffer);
#line 790
    buffer_append(& incoming_packet, (char const   *)tmp___9, tmp___8);
  }
#line 794
  buffer_get(& incoming_packet, buf___1, 1U);
#line 797
  tmp___10 = buffer_len(& incoming_packet);
#line 797
  *payload_len_ptr = (int )tmp___10;
#line 800
  return ((int )((unsigned char )buf___1[0]));
}
}
#line 810
int packet_read_poll2(int *payload_len_ptr ) ;
#line 810 "packet.c"
static unsigned int packet_length  =    0U;
#line 811 "packet.c"
static unsigned int seqnr___0  =    0U;
#line 803 "packet.c"
int packet_read_poll2(int *payload_len_ptr ) 
{ unsigned int padlen ;
  unsigned int need ;
  unsigned char buf___1[8] ;
  unsigned char *macbuf ;
  unsigned char *ucp ;
  char *cp ;
  int type ;
  int maclen ;
  int block_size ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  unsigned int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  unsigned int tmp___9 ;
  char *tmp___10 ;
  unsigned int tmp___11 ;

  {
#line 814
  enc = (Enc *)((void *)0);
#line 815
  mac = (Mac *)((void *)0);
#line 816
  comp = (Comp *)((void *)0);
#line 818
  if ((unsigned int )kex != (unsigned int )((void *)0)) {
#line 819
    enc = & kex->enc[0];
#line 820
    mac = & kex->mac[0];
#line 821
    comp = & kex->comp[0];
  }
#line 823
  if (mac) {
#line 823
    if (mac->enabled) {
#line 823
      maclen = mac->mac_len;
    } else {
#line 823
      maclen = 0;
    }
  } else {
#line 823
    maclen = 0;
  }
#line 824
  if (enc) {
#line 824
    block_size = enc->block_size;
  } else {
#line 824
    block_size = 8;
  }
#line 826
  if (packet_length == 0U) {
#line 831
    tmp = buffer_len(& input);
#line 831
    if (tmp < (unsigned int )block_size) {
#line 832
      return (0);
    }
#line 833
    buffer_clear(& incoming_packet);
#line 834
    buffer_append_space(& incoming_packet, & cp, (unsigned int )block_size);
#line 835
    tmp___0 = buffer_ptr(& input);
#line 835
    packet_decrypt(& receive_context, (void *)cp, (void *)tmp___0, (unsigned int )block_size);
#line 837
    tmp___1 = buffer_ptr(& incoming_packet);
#line 837
    ucp = (unsigned char *)tmp___1;
#line 838
    packet_length = (unsigned int )(((((unsigned long )*(ucp + 0) << 24) | ((unsigned long )*(ucp + 1) << 16)) | ((unsigned long )*(ucp + 2) << 8)) | (unsigned long )*(ucp + 3));
#line 839
    if (packet_length < 5U) {
#line 840
      buffer_dump(& incoming_packet);
#line 841
      packet_disconnect("Bad packet length %d.", packet_length);
    } else {
#line 839
      if (packet_length > 262144U) {
#line 840
        buffer_dump(& incoming_packet);
#line 841
        packet_disconnect("Bad packet length %d.", packet_length);
      }
    }
#line 844
    buffer_consume(& input, (unsigned int )block_size);
  }
#line 847
  need = (4U + packet_length) - (unsigned int )block_size;
#line 850
  if (need % (unsigned int )block_size != 0U) {
#line 851
    fatal("padding error: need %d block %d mod %d", need, block_size, need % (unsigned int )block_size);
  }
#line 857
  tmp___2 = buffer_len(& input);
#line 857
  if (tmp___2 < need + (unsigned int )maclen) {
#line 858
    return (0);
  }
#line 863
  buffer_append_space(& incoming_packet, & cp, need);
#line 864
  tmp___3 = buffer_ptr(& input);
#line 864
  packet_decrypt(& receive_context, (void *)cp, (void *)tmp___3, need);
#line 865
  buffer_consume(& input, need);
#line 870
  if (mac) {
#line 870
    if (mac->enabled) {
#line 871
      tmp___4 = buffer_len(& incoming_packet);
#line 871
      tmp___5 = buffer_ptr(& incoming_packet);
#line 871
      macbuf = hmac(mac->md, seqnr___0, (unsigned char *)tmp___5, (int )tmp___4, mac->key,
                    mac->key_len);
#line 876
      tmp___6 = buffer_ptr(& input);
#line 876
      tmp___7 = memcmp((void const   *)macbuf, (void const   *)tmp___6, (unsigned int )mac->mac_len);
#line 876
      if (tmp___7 != 0) {
#line 877
        packet_disconnect("Corrupted HMAC on input.");
      }
#line 879
      buffer_consume(& input, (unsigned int )mac->mac_len);
    }
  }
#line 881
  seqnr___0 ++;
#line 881
  if (seqnr___0 == 0U) {
#line 882
    log("incoming seqnr wraps around");
  }
#line 885
  tmp___8 = buffer_ptr(& incoming_packet);
#line 885
  cp = tmp___8 + 4;
#line 886
  padlen = (unsigned int )((int )*cp & 255);
#line 888
  if (padlen < 4U) {
#line 889
    packet_disconnect("Corrupted padlen %d on input.", padlen);
  }
#line 892
  buffer_consume(& incoming_packet, 5U);
#line 893
  buffer_consume_end(& incoming_packet, padlen);
#line 896
  if (comp) {
#line 896
    if (comp->enabled) {
#line 897
      buffer_clear(& compression_buffer);
#line 898
      buffer_uncompress(& incoming_packet, & compression_buffer);
#line 899
      buffer_clear(& incoming_packet);
#line 900
      tmp___9 = buffer_len(& compression_buffer);
#line 900
      tmp___10 = buffer_ptr(& compression_buffer);
#line 900
      buffer_append(& incoming_packet, (char const   *)tmp___10, tmp___9);
    }
  }
#line 908
  buffer_get(& incoming_packet, (char *)(buf___1), 1U);
#line 909
  tmp___11 = buffer_len(& incoming_packet);
#line 909
  *payload_len_ptr = (int )tmp___11;
#line 912
  packet_length = 0U;
#line 915
  type = (int )buf___1[0];
#line 917
  if (type == 21) {
#line 918
    if ((unsigned int )kex == (unsigned int )((void *)0)) {
#line 919
      fatal("packet_read_poll2: no KEX");
    } else {
#line 918
      if ((unsigned int )mac == (unsigned int )((void *)0)) {
#line 919
        fatal("packet_read_poll2: no KEX");
      } else {
#line 918
        if ((unsigned int )enc == (unsigned int )((void *)0)) {
#line 919
          fatal("packet_read_poll2: no KEX");
        } else {
#line 918
          if ((unsigned int )comp == (unsigned int )((void *)0)) {
#line 919
            fatal("packet_read_poll2: no KEX");
          }
        }
      }
    }
#line 920
    if ((unsigned int )mac->md != (unsigned int )((void *)0)) {
#line 921
      mac->enabled = 1;
    }
#line 923
    cipher_set_key_iv(& receive_context, enc->type, (unsigned char const   *)enc->key,
                      enc->key_len, (unsigned char const   *)enc->iv, enc->iv_len);
#line 926
    clear_enc_keys(enc, kex->we_need);
#line 927
    if (comp->type != 0) {
#line 927
      if (comp->enabled == 0) {
#line 928
        comp->enabled = 1;
#line 929
        if (! packet_compression) {
#line 930
          packet_start_compression(6);
        }
      }
    }
  }
#line 938
  return ((int )((unsigned char )type));
}
}
#line 941 "packet.c"
int packet_read_poll(int *payload_len_ptr ) 
{ char *msg ;
  int type ;
  int tmp___1 ;
  int reason ;
  unsigned int tmp___2 ;

  {
#line 945
  while (1) {
#line 946
    if (use_ssh2_packet_format) {
#line 946
      tmp___1 = packet_read_poll2(payload_len_ptr);
    } else {
#line 946
      tmp___1 = packet_read_poll1(payload_len_ptr);
    }
#line 946
    type = tmp___1;
#line 950
    if (compat20) {
#line 952
      if (type != 0) {

      }
#line 954
      switch (type) {
      case 2: 
#line 956
      break;
      case 4: 
#line 958
      packet_get_char();
#line 959
      msg = packet_get_string((unsigned int *)((void *)0));
#line 960
      debug("Remote: %.900s", msg);
#line 961
      xfree((void *)msg);
#line 962
      msg = packet_get_string((unsigned int *)((void *)0));
#line 963
      xfree((void *)msg);
#line 964
      break;
      case 1: 
#line 966
      tmp___2 = packet_get_int();
#line 966
      reason = (int )tmp___2;
#line 967
      msg = packet_get_string((unsigned int *)((void *)0));
#line 968
      log("Received disconnect: %d: %.900s", reason, msg);
#line 969
      xfree((void *)msg);
#line 970
      fatal_cleanup();
#line 971
      break;
      default: ;
#line 973
      return (type);
#line 974
      break;
      }
    } else {
#line 977
      switch (type) {
      case 32: 
#line 979
      break;
      case 36: 
#line 981
      msg = packet_get_string((unsigned int *)((void *)0));
#line 982
      debug("Remote: %.900s", msg);
#line 983
      xfree((void *)msg);
#line 984
      break;
      case 1: 
#line 986
      msg = packet_get_string((unsigned int *)((void *)0));
#line 987
      log("Received disconnect: %.900s", msg);
#line 988
      fatal_cleanup();
#line 989
      xfree((void *)msg);
#line 990
      break;
      default: ;
#line 992
      if (type != 0) {

      }
#line 994
      return (type);
#line 995
      break;
      }
    }
  }
}
}
#line 1006 "packet.c"
void packet_process_incoming(char const   *buf___1 , unsigned int len ) 
{ 

  {
#line 1009
  buffer_append(& input, buf___1, len);
#line 1010
  return;
}
}
#line 1014 "packet.c"
unsigned int packet_get_char(void) 
{ char ch ;

  {
#line 1018
  buffer_get(& incoming_packet, & ch, 1U);
#line 1019
  return ((unsigned int )((unsigned char )ch));
}
}
#line 1024 "packet.c"
unsigned int packet_get_int(void) 
{ unsigned int tmp ;

  {
#line 1027
  tmp = buffer_get_int(& incoming_packet);
#line 1027
  return (tmp);
}
}
#line 1035 "packet.c"
void packet_get_bignum(BIGNUM *value , int *length_ptr ) 
{ 

  {
#line 1038
  *length_ptr = buffer_get_bignum(& incoming_packet, value);
#line 1039
  return;
}
}
#line 1041 "packet.c"
void packet_get_bignum2(BIGNUM *value , int *length_ptr ) 
{ 

  {
#line 1044
  *length_ptr = buffer_get_bignum2(& incoming_packet, value);
#line 1045
  return;
}
}
#line 1047 "packet.c"
char *packet_get_raw(int *length_ptr ) 
{ int bytes ;
  unsigned int tmp ;
  char *tmp___0 ;

  {
#line 1050
  tmp = buffer_len(& incoming_packet);
#line 1050
  bytes = (int )tmp;
#line 1051
  if ((unsigned int )length_ptr != (unsigned int )((void *)0)) {
#line 1052
    *length_ptr = bytes;
  }
#line 1053
  tmp___0 = buffer_ptr(& incoming_packet);
#line 1053
  return (tmp___0);
}
}
#line 1056 "packet.c"
int packet_remaining(void) 
{ unsigned int tmp ;

  {
#line 1059
  tmp = buffer_len(& incoming_packet);
#line 1059
  return ((int )tmp);
}
}
#line 1069 "packet.c"
char *packet_get_string(unsigned int *length_ptr ) 
{ char *tmp ;

  {
#line 1072
  tmp = buffer_get_string(& incoming_packet, length_ptr);
#line 1072
  return (tmp);
}
}
#line 1084 "packet.c"
void ( /* format attribute */  packet_send_debug)(char const   *fmt  , ...) 
{ char buf___1[1024] ;
  va_list args ;

  {
#line 1090
  __builtin_va_start(args, fmt);
#line 1091
  vsnprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )fmt,
            args);
#line 1092
  __builtin_va_end(args);
#line 1094
  if (compat20) {
#line 1095
    packet_start(4);
#line 1096
    packet_put_char(0);
#line 1097
    packet_put_cstring((char const   *)(buf___1));
#line 1098
    packet_put_cstring("");
  } else {
#line 1100
    packet_start(36);
#line 1101
    packet_put_cstring((char const   *)(buf___1));
  }
#line 1103
  packet_send();
#line 1104
  packet_write_wait();
#line 1105
  return;
}
}
#line 1119 "packet.c"
static int disconnecting  =    0;
#line 1114 "packet.c"
void ( /* format attribute */  packet_disconnect)(char const   *fmt  , ...) 
{ char buf___1[1024] ;
  va_list args ;
  size_t tmp ;

  {
#line 1120
  if (disconnecting) {
#line 1121
    fatal("packet_disconnect called recursively.");
  }
#line 1122
  disconnecting = 1;
#line 1128
  __builtin_va_start(args, fmt);
#line 1129
  vsnprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )fmt,
            args);
#line 1130
  __builtin_va_end(args);
#line 1133
  if (compat20) {
#line 1134
    packet_start(1);
#line 1135
    packet_put_int(2U);
#line 1136
    packet_put_cstring((char const   *)(buf___1));
#line 1137
    packet_put_cstring("");
  } else {
#line 1139
    packet_start(1);
#line 1140
    tmp = strlen((char const   *)(buf___1));
#line 1140
    packet_put_string((char const   *)(buf___1), tmp);
  }
#line 1142
  packet_send();
#line 1143
  packet_write_wait();
#line 1146
  channel_stop_listening();
#line 1149
  packet_close();
#line 1152
  log("Disconnecting: %.100s", buf___1);
#line 1153
  fatal_cleanup();
#line 1154
  return;
}
}
#line 1158 "packet.c"
void packet_write_poll(void) 
{ int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
#line 1161
  tmp = buffer_len(& output);
#line 1161
  len = (int )tmp;
#line 1162
  if (len > 0) {
#line 1163
    tmp___0 = buffer_ptr(& output);
#line 1163
    len = write(connection_out, (void const   *)tmp___0, (unsigned int )len);
#line 1164
    if (len <= 0) {
#line 1165
      tmp___3 = __errno_location();
#line 1165
      if (*tmp___3 == 11) {
#line 1166
        return;
      } else {
#line 1168
        tmp___1 = __errno_location();
#line 1168
        tmp___2 = strerror(*tmp___1);
#line 1168
        fatal("Write failed: %.100s", tmp___2);
      }
    }
#line 1170
    buffer_consume(& output, (unsigned int )len);
  }
#line 1172
  return;
}
}
#line 1179 "packet.c"
void packet_write_wait(void) 
{ fd_set set ;
  int __d0 ;
  int __d1 ;
  int tmp ;

  {
#line 1182
  packet_write_poll();
#line 1183
  while (1) {
#line 1183
    tmp = packet_have_data_to_write();
#line 1183
    if (! tmp) {
#line 1183
      break;
    }
#line 1185
    while (1) {
#line 1185
      __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& set.__fds_bits[0]): "memory");
#line 1185
      break;
    }
#line 1186
    __asm__  volatile   ("btsl %1,%0": "=m" (set.__fds_bits[(unsigned int )connection_out / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 1187
    select(connection_out + 1, (fd_set * __restrict  )((void *)0), (fd_set * __restrict  )(& set),
           (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 1188
    packet_write_poll();
  }
#line 1190
  return;
}
}
#line 1194 "packet.c"
int packet_have_data_to_write(void) 
{ unsigned int tmp ;

  {
#line 1197
  tmp = buffer_len(& output);
#line 1197
  return (tmp != 0U);
}
}
#line 1202 "packet.c"
int packet_not_very_much_data_to_write(void) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 1205
  if (interactive_mode) {
#line 1206
    tmp = buffer_len(& output);
#line 1206
    return (tmp < 16384U);
  } else {
#line 1208
    tmp___0 = buffer_len(& output);
#line 1208
    return (tmp___0 < 131072U);
  }
}
}
#line 1213 "packet.c"
void packet_set_interactive(int interactive , int keepalives ) 
{ int on ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int lowdelay ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int throughput ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
#line 1216
  on = 1;
#line 1219
  interactive_mode = interactive;
#line 1222
  tmp = packet_connection_is_on_socket();
#line 1222
  if (! tmp) {
#line 1223
    return;
  }
#line 1224
  if (keepalives) {
#line 1226
    tmp___2 = setsockopt(connection_in, 1, 9, (void const   *)((void *)(& on)), sizeof(on));
#line 1226
    if (tmp___2 < 0) {
#line 1228
      tmp___0 = __errno_location();
#line 1228
      tmp___1 = strerror(*tmp___0);
#line 1228
      error("setsockopt SO_KEEPALIVE: %.100s", tmp___1);
    }
  }
#line 1233
  tmp___3 = packet_connection_is_ipv4();
#line 1233
  if (! tmp___3) {
#line 1234
    return;
  }
#line 1235
  if (interactive) {
#line 1241
    lowdelay = 16;
#line 1242
    tmp___6 = setsockopt(connection_in, 0, 1, (void const   *)((void *)(& lowdelay)),
                         sizeof(lowdelay));
#line 1242
    if (tmp___6 < 0) {
#line 1244
      tmp___4 = __errno_location();
#line 1244
      tmp___5 = strerror(*tmp___4);
#line 1244
      error("setsockopt IPTOS_LOWDELAY: %.100s", tmp___5);
    }
#line 1246
    tmp___9 = setsockopt(connection_in, 6, 1, (void const   *)((void *)(& on)), sizeof(on));
#line 1246
    if (tmp___9 < 0) {
#line 1248
      tmp___7 = __errno_location();
#line 1248
      tmp___8 = strerror(*tmp___7);
#line 1248
      error("setsockopt TCP_NODELAY: %.100s", tmp___8);
    }
  } else {
#line 1255
    throughput = 8;
#line 1256
    tmp___12 = setsockopt(connection_in, 0, 1, (void const   *)((void *)(& throughput)),
                          sizeof(throughput));
#line 1256
    if (tmp___12 < 0) {
#line 1258
      tmp___10 = __errno_location();
#line 1258
      tmp___11 = strerror(*tmp___10);
#line 1258
      error("setsockopt IPTOS_THROUGHPUT: %.100s", tmp___11);
    }
  }
#line 1261
  return;
}
}
#line 1265 "packet.c"
int packet_is_interactive(void) 
{ 

  {
#line 1268
  return (interactive_mode);
}
}
#line 1274 "packet.c"
static int called___0  =    0;
#line 1271 "packet.c"
int packet_set_maxsize(int s ) 
{ 

  {
#line 1275
  if (called___0) {
#line 1276
    log("packet_set_maxsize: called twice: old %d new %d", max_packet_size, s);
#line 1278
    return (-1);
  }
#line 1280
  if (s < 4096) {
#line 1281
    log("packet_set_maxsize: bad size %d", s);
#line 1282
    return (-1);
  } else {
#line 1280
    if (s > 1048576) {
#line 1281
      log("packet_set_maxsize: bad size %d", s);
#line 1282
      return (-1);
    }
  }
#line 1284
  log("packet_set_maxsize: setting to %d", s);
#line 1285
  max_packet_size = s;
#line 1286
  return (s);
}
}
#line 1 "radix.o"
#line 1 "entropy.o"
#line 33 "entropy.h"
void seed_rng(void) ;
#line 34
void init_rng(void) ;
#line 105 "/usr/include/openssl/rand.h"
extern void RAND_add(void const   *buf , int num , double entropy ) ;
#line 109
extern int RAND_status(void) ;
#line 130 "entropy.c"
int get_random_bytes(unsigned char *buf___1 , int len ) 
{ int random_pool ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 134
  random_pool = open("/dev/urandom", 0);
#line 135
  if (random_pool == -1) {
#line 136
    tmp = __errno_location();
#line 136
    tmp___0 = strerror(*tmp);
#line 136
    error("Couldn\'t open random pool \"%s\": %s", "/dev/urandom", tmp___0);
#line 138
    return (0);
  }
#line 141
  tmp___3 = atomicio((ssize_t (*)())(& read), random_pool, (void *)buf___1, (unsigned int )len);
#line 141
  if (tmp___3 != len) {
#line 142
    tmp___1 = __errno_location();
#line 142
    tmp___2 = strerror(*tmp___1);
#line 142
    error("Couldn\'t read from random pool \"%s\": %s", "/dev/urandom", tmp___2);
#line 144
    close(random_pool);
#line 145
    return (0);
  }
#line 148
  close(random_pool);
#line 150
  return (1);
}
}
#line 159 "entropy.c"
void seed_rng(void) 
{ char buf___1[32] ;
  int tmp ;
  int tmp___0 ;

  {
#line 164
  debug("Seeding random number generator");
#line 166
  tmp___0 = get_random_bytes((unsigned char *)(buf___1), (int )sizeof(buf___1));
#line 166
  if (tmp___0) {
#line 170
    RAND_add((void const   *)(buf___1), (int )sizeof(buf___1), (double )sizeof(buf___1));
  } else {
#line 167
    tmp = RAND_status();
#line 167
    if (! tmp) {
#line 168
      fatal("Entropy collection failed and entropy exhausted");
    }
  }
#line 173
  memset((void *)(buf___1), '\000', sizeof(buf___1));
#line 174
  return;
}
}
#line 177 "entropy.c"
void init_rng(void) 
{ 

  {
#line 177
  return;
}
}
#line 1 "readpass.o"
#line 117 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 216
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
#line 222
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo )  __attribute__((__nonnull__(1))) ;
#line 249
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
#line 257
extern int sigsuspend(sigset_t const   *__set )  __attribute__((__nonnull__(1))) ;
#line 260
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 143 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 218
extern int fflush(FILE *__stream ) ;
#line 67 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 71
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
#line 427 "ssh.h"
char *read_passphrase(char const   *prompt , int from_stdin ) ;
#line 40 "readpass.c"
int volatile   intr  ;
#line 42 "readpass.c"
void intcatch(void) 
{ 

  {
#line 45
  intr = (int volatile   )1;
#line 46
  return;
}
}
#line 53 "readpass.c"
char *read_passphrase(char const   *prompt , int from_stdin ) 
{ char buf___1[1024] ;
  char *p ;
  char ch ;
  struct termios tio ;
  struct termios saved_tio ;
  sigset_t oset ;
  sigset_t nset ;
  struct sigaction sa ;
  struct sigaction osa ;
  int input___0 ;
  int output___0 ;
  int echo ;
  int tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  ssize_t tmp___2 ;
  __pid_t tmp___3 ;

  {
#line 60
  echo = 0;
#line 62
  if (from_stdin) {
#line 63
    input___0 = 0;
#line 64
    output___0 = 2;
  } else {
#line 66
    output___0 = open("/dev/tty", 2);
#line 66
    input___0 = output___0;
  }
#line 68
  if (input___0 == -1) {
#line 69
    fatal("You have no controlling tty.  Cannot read passphrase.\n");
  }
#line 72
  sigemptyset(& nset);
#line 73
  sigaddset(& nset, 20);
#line 74
  sigprocmask(0, (sigset_t const   * __restrict  )(& nset), (sigset_t * __restrict  )(& oset));
#line 75
  memset((void *)(& sa), 0, sizeof(sa));
#line 76
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))(& intcatch);
#line 77
  sigaction(2, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& osa));
#line 79
  intr = (int volatile   )0;
#line 81
  tmp = tcgetattr(input___0, & saved_tio);
#line 81
  if (tmp == 0) {
#line 81
    if (saved_tio.c_lflag & 8U) {
#line 82
      echo = 1;
#line 83
      tio = saved_tio;
#line 84
      tio.c_lflag &= 4294967175U;
#line 85
      tcsetattr(input___0, 0, (struct termios  const  *)(& tio));
    }
  }
#line 88
  fflush(stdout);
#line 90
  tmp___0 = strlen(prompt);
#line 90
  write(output___0, (void const   *)prompt, tmp___0);
#line 91
  p = buf___1;
#line 91
  while (1) {
#line 91
    tmp___2 = read(input___0, (void *)(& ch), 1U);
#line 91
    if (tmp___2 == 1) {
#line 91
      if (! ((int )ch != 10)) {
#line 91
        break;
      }
    } else {
#line 91
      break;
    }
#line 92
    if (intr) {
#line 93
      break;
    }
#line 94
    if ((unsigned int )p < (unsigned int )((buf___1 + sizeof(buf___1)) - 1)) {
#line 95
      tmp___1 = p;
#line 95
      p ++;
#line 95
      *tmp___1 = ch;
    }
  }
#line 97
  *p = (char )'\000';
#line 98
  if (! intr) {
#line 99
    write(output___0, (void const   *)"\n", 1U);
  }
#line 102
  if (echo) {
#line 103
    tcsetattr(input___0, 0, (struct termios  const  *)(& saved_tio));
  }
#line 104
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((void *)0));
#line 105
  sigaction(2, (struct sigaction  const  * __restrict  )(& osa), (struct sigaction * __restrict  )((void *)0));
#line 107
  if (intr) {
#line 108
    tmp___3 = getpid();
#line 108
    kill(tmp___3, 2);
#line 109
    sigemptyset(& nset);
#line 111
    sigsuspend((sigset_t const   *)(& nset));
  }
#line 114
  if (! from_stdin) {
#line 115
    close(input___0);
  }
#line 116
  p = xstrdup((char const   *)(buf___1));
#line 117
  memset((void *)(buf___1), 0, sizeof(buf___1));
#line 118
  return (p);
}
}
#line 1 "rsa.o"
#line 452 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 333 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 490
__inline static int putchar(int __c ) ;
#line 75 "/usr/include/bits/stdio.h"
__inline static int putchar(int __c ) 
{ int tmp ;

  {
#line 78
  tmp = _IO_putc(__c, stdout);
#line 78
  return (tmp);
}
}
#line 221 "/usr/include/openssl/rsa.h"
extern RSA *RSA_generate_key(int bits , unsigned long e , void (*callback)(int  ,
                                                                           int  ,
                                                                           void * ) ,
                             void *cb_arg ) ;
#line 230
extern int RSA_public_encrypt(int flen , unsigned char const   *from , unsigned char *to ,
                              RSA *rsa , int padding ) ;
#line 236
extern int RSA_private_decrypt(int flen , unsigned char const   *from , unsigned char *to ,
                               RSA *rsa , int padding ) ;
#line 25 "rsa.h"
void rsa_generate_key(RSA *prv , RSA *pub , unsigned int bits ) ;
#line 31
void rsa_set_verbose(int verbose___0 ) ;
#line 33
int rsa_alive(void) ;
#line 35
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 36
void rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 45 "rsa.c"
int rsa_verbose  =    1;
#line 47 "rsa.c"
int rsa_alive(void) 
{ RSA *key ;

  {
#line 52
  seed_rng();
#line 53
  key = RSA_generate_key(32, 3UL, (void (*)(int  , int  , void * ))((void *)0), (void *)0);
#line 54
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 55
    return (0);
  }
#line 56
  RSA_free(key);
#line 57
  return (1);
}
}
#line 63 "rsa.c"
void keygen_progress(int p , int n___0 , void *arg ) 
{ char progress_chars[6] ;

  {
#line 66
  progress_chars[0] = (char )'.';
#line 66
  progress_chars[1] = (char )'o';
#line 66
  progress_chars[2] = (char )'+';
#line 66
  progress_chars[3] = (char )'O';
#line 66
  progress_chars[4] = (char )'?';
#line 66
  progress_chars[5] = (char )'\000';
#line 68
  if (p < 0) {
#line 69
    p = (int )(sizeof(progress_chars) - 2U);
  } else {
#line 68
    if ((unsigned int )p > sizeof(progress_chars) - 2U) {
#line 69
      p = (int )(sizeof(progress_chars) - 2U);
    }
  }
#line 71
  putchar((int )progress_chars[p]);
#line 72
  fflush(stdout);
#line 73
  return;
}
}
#line 81 "rsa.c"
void rsa_generate_key(RSA *prv , RSA *pub , unsigned int bits ) 
{ RSA *key ;

  {
#line 86
  seed_rng();
#line 88
  if (rsa_verbose) {
#line 89
    printf((char const   * __restrict  )"Generating RSA keys:  ");
#line 90
    fflush(stdout);
#line 91
    key = RSA_generate_key((int )bits, 35UL, & keygen_progress, (void *)0);
#line 92
    printf((char const   * __restrict  )"\n");
  } else {
#line 94
    key = RSA_generate_key((int )bits, 35UL, (void (*)(int  , int  , void * ))((void *)0),
                           (void *)0);
  }
#line 96
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 97
    fatal("rsa_generate_key: key generation failed.");
  }
#line 100
  pub->n = BN_new();
#line 101
  BN_copy(pub->n, (BIGNUM const   *)key->n);
#line 102
  pub->e = BN_new();
#line 103
  BN_copy(pub->e, (BIGNUM const   *)key->e);
#line 106
  prv->n = BN_new();
#line 107
  BN_copy(prv->n, (BIGNUM const   *)key->n);
#line 108
  prv->e = BN_new();
#line 109
  BN_copy(prv->e, (BIGNUM const   *)key->e);
#line 110
  prv->d = BN_new();
#line 111
  BN_copy(prv->d, (BIGNUM const   *)key->d);
#line 112
  prv->p = BN_new();
#line 113
  BN_copy(prv->p, (BIGNUM const   *)key->p);
#line 114
  prv->q = BN_new();
#line 115
  BN_copy(prv->q, (BIGNUM const   *)key->q);
#line 117
  prv->dmp1 = BN_new();
#line 118
  BN_copy(prv->dmp1, (BIGNUM const   *)key->dmp1);
#line 120
  prv->dmq1 = BN_new();
#line 121
  BN_copy(prv->dmq1, (BIGNUM const   *)key->dmq1);
#line 123
  prv->iqmp = BN_new();
#line 124
  BN_copy(prv->iqmp, (BIGNUM const   *)key->iqmp);
#line 126
  RSA_free(key);
#line 128
  if (rsa_verbose) {
#line 129
    printf((char const   * __restrict  )"Key generation complete.\n");
  }
#line 130
  return;
}
}
#line 132 "rsa.c"
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ unsigned char *inbuf ;
  unsigned char *outbuf ;
  int len ;
  int ilen ;
  int olen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 138
  tmp = BN_num_bits((BIGNUM const   *)key->e);
#line 138
  if (tmp < 2) {
#line 139
    fatal("rsa_public_encrypt() exponent too small or not odd");
  } else {
#line 138
    if ((key->e)->top > 0) {
#line 138
      if (! (*((key->e)->d + 0) & 1UL)) {
#line 139
        fatal("rsa_public_encrypt() exponent too small or not odd");
      }
    } else {
#line 139
      fatal("rsa_public_encrypt() exponent too small or not odd");
    }
  }
#line 141
  tmp___0 = BN_num_bits((BIGNUM const   *)key->n);
#line 141
  olen = (tmp___0 + 7) / 8;
#line 142
  tmp___1 = xmalloc((unsigned int )olen);
#line 142
  outbuf = (unsigned char *)tmp___1;
#line 144
  tmp___2 = BN_num_bits((BIGNUM const   *)in);
#line 144
  ilen = (tmp___2 + 7) / 8;
#line 145
  tmp___3 = xmalloc((unsigned int )ilen);
#line 145
  inbuf = (unsigned char *)tmp___3;
#line 146
  BN_bn2bin((BIGNUM const   *)in, inbuf);
#line 148
  len = RSA_public_encrypt(ilen, (unsigned char const   *)inbuf, outbuf, key, 1);
#line 148
  if (len <= 0) {
#line 150
    fatal("rsa_public_encrypt() failed");
  }
#line 152
  BN_bin2bn((unsigned char const   *)outbuf, len, out);
#line 154
  memset((void *)outbuf, 0, (unsigned int )olen);
#line 155
  memset((void *)inbuf, 0, (unsigned int )ilen);
#line 156
  xfree((void *)outbuf);
#line 157
  xfree((void *)inbuf);
#line 158
  return;
}
}
#line 160 "rsa.c"
void rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ unsigned char *inbuf ;
  unsigned char *outbuf ;
  int len ;
  int ilen ;
  int olen ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 166
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 166
  olen = (tmp + 7) / 8;
#line 167
  tmp___0 = xmalloc((unsigned int )olen);
#line 167
  outbuf = (unsigned char *)tmp___0;
#line 169
  tmp___1 = BN_num_bits((BIGNUM const   *)in);
#line 169
  ilen = (tmp___1 + 7) / 8;
#line 170
  tmp___2 = xmalloc((unsigned int )ilen);
#line 170
  inbuf = (unsigned char *)tmp___2;
#line 171
  BN_bn2bin((BIGNUM const   *)in, inbuf);
#line 173
  len = RSA_private_decrypt(ilen, (unsigned char const   *)inbuf, outbuf, key, 1);
#line 173
  if (len <= 0) {
#line 175
    fatal("rsa_private_decrypt() failed");
  }
#line 177
  BN_bin2bn((unsigned char const   *)outbuf, len, out);
#line 179
  memset((void *)outbuf, 0, (unsigned int )olen);
#line 180
  memset((void *)inbuf, 0, (unsigned int )ilen);
#line 181
  xfree((void *)outbuf);
#line 182
  xfree((void *)inbuf);
#line 183
  return;
}
}
#line 187 "rsa.c"
void rsa_set_verbose(int verbose___0 ) 
{ 

  {
#line 190
  rsa_verbose = verbose___0;
#line 191
  return;
}
}
#line 1 "tildexpand.o"
#line 111 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 117
extern struct passwd *getpwnam(char const   *__name ) ;
#line 491 "ssh.h"
char *tilde_expand_filename(char const   *filename , uid_t my_uid ) ;
#line 18 "tildexpand.c"
char *tilde_expand_filename(char const   *filename , uid_t my_uid ) 
{ char const   *cp ;
  unsigned int userlen ;
  char *expanded ;
  struct passwd *pw ;
  char user[100] ;
  int len ;
  char *tmp ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;

  {
#line 29
  if ((int const   )*(filename + 0) != 126) {
#line 30
    tmp = xstrdup(filename);
#line 30
    return (tmp);
  }
#line 33
  filename ++;
#line 36
  tmp___1 = __builtin_strchr((char *)filename, '/');
#line 36
  cp = (char const   *)tmp___1;
#line 37
  if (cp) {
#line 38
    userlen = (unsigned int )(cp - filename);
  } else {
#line 40
    userlen = strlen(filename);
  }
#line 41
  if (userlen == 0U) {
#line 42
    pw = getpwuid(my_uid);
  } else {
#line 45
    if (userlen > sizeof(user) - 1U) {
#line 46
      fatal("User name after tilde too long.");
    }
#line 47
    memcpy((void * __restrict  )(user), (void const   * __restrict  )filename, userlen);
#line 48
    user[userlen] = (char)0;
#line 49
    pw = getpwnam((char const   *)(user));
  }
#line 51
  if (! pw) {
#line 52
    fatal("Unknown user %100s.", user);
  }
#line 55
  if (! cp) {
#line 57
    tmp___2 = xstrdup((char const   *)pw->pw_dir);
#line 57
    return (tmp___2);
  }
#line 60
  tmp___3 = strlen((char const   *)pw->pw_dir);
#line 60
  tmp___4 = strlen(cp + 1);
#line 60
  len = (int )((tmp___3 + tmp___4) + 2U);
#line 61
  if (len > 4096) {
#line 62
    fatal("Home directory too long (%d > %d", len - 1, 4095);
  }
#line 63
  tmp___5 = xmalloc((unsigned int )len);
#line 63
  expanded = (char *)tmp___5;
#line 64
  snprintf((char * __restrict  )expanded, (unsigned int )len, (char const   * __restrict  )"%s/%s",
           pw->pw_dir, cp + 1);
#line 65
  return (expanded);
}
}
#line 1 "ttymodes.o"
#line 49 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) speed_t cfgetospeed(struct termios  const  *__termios_p ) ;
#line 52
extern  __attribute__((__nothrow__)) speed_t cfgetispeed(struct termios  const  *__termios_p ) ;
#line 55
extern  __attribute__((__nothrow__)) int cfsetospeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 58
extern  __attribute__((__nothrow__)) int cfsetispeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 184 "packet.h"
void tty_make_modes(int fd ) ;
#line 187
void tty_parse_modes(int fd , int *n_bytes_ptr ) ;
#line 26 "ttymodes.c"
static int speed_to_baud(speed_t speed ) 
{ 

  {
#line 29
  switch ((int )speed) {
  case 0: 
#line 31
  return (0);
  case 1: 
#line 33
  return (50);
  case 2: 
#line 35
  return (75);
  case 3: 
#line 37
  return (110);
  case 4: 
#line 39
  return (134);
  case 5: 
#line 41
  return (150);
  case 6: 
#line 43
  return (200);
  case 7: 
#line 45
  return (300);
  case 8: 
#line 47
  return (600);
  case 9: 
#line 49
  return (1200);
  case 10: 
#line 51
  return (1800);
  case 11: 
#line 53
  return (2400);
  case 12: 
#line 55
  return (4800);
  case 13: 
#line 57
  return (9600);
  case 14: 
#line 61
  return (19200);
  case 15: 
#line 71
  return (38400);
  case 4097: 
#line 93
  return (57600);
  case 4098: 
#line 101
  return (115200);
  case 4099: 
#line 105
  return (230400);
  default: ;
#line 108
  return (9600);
  }
}
}
#line 115 "ttymodes.c"
static speed_t baud_to_speed(int baud ) 
{ 

  {
#line 118
  switch (baud) {
  case 0: 
#line 120
  return (0U);
  case 50: 
#line 122
  return (1U);
  case 75: 
#line 124
  return (2U);
  case 110: 
#line 126
  return (3U);
  case 134: 
#line 128
  return (4U);
  case 150: 
#line 130
  return (5U);
  case 200: 
#line 132
  return (6U);
  case 300: 
#line 134
  return (7U);
  case 600: 
#line 136
  return (8U);
  case 1200: 
#line 138
  return (9U);
  case 1800: 
#line 140
  return (10U);
  case 2400: 
#line 142
  return (11U);
  case 4800: 
#line 144
  return (12U);
  case 9600: 
#line 146
  return (13U);
  case 19200: 
#line 150
  return (14U);
  case 38400: 
#line 160
  return (15U);
  case 57600: 
#line 182
  return (4097U);
  case 115200: 
#line 190
  return (4098U);
  case 230400: 
#line 194
  return (4099U);
  default: ;
#line 197
  return (13U);
  }
}
}
#line 206 "ttymodes.c"
void tty_make_modes(int fd ) 
{ struct termios tio ;
  int baud ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  speed_t tmp___2 ;
  speed_t tmp___3 ;

  {
#line 212
  tmp___1 = tcgetattr(fd, & tio);
#line 212
  if (tmp___1 < 0) {
#line 213
    packet_put_char(0);
#line 214
    tmp = __errno_location();
#line 214
    tmp___0 = strerror(*tmp);
#line 214
    log("tcgetattr: %.100s", tmp___0);
#line 215
    return;
  }
#line 218
  tmp___2 = cfgetospeed((struct termios  const  *)(& tio));
#line 218
  baud = speed_to_baud(tmp___2);
#line 219
  packet_put_char(193);
#line 220
  packet_put_int((unsigned int )baud);
#line 221
  tmp___3 = cfgetispeed((struct termios  const  *)(& tio));
#line 221
  baud = speed_to_baud(tmp___3);
#line 222
  packet_put_char(192);
#line 223
  packet_put_int((unsigned int )baud);
#line 37 "ttymodes.h"
  packet_put_char(1);
#line 37
  packet_put_char((int )tio.c_cc[0]);
#line 38
  packet_put_char(2);
#line 38
  packet_put_char((int )tio.c_cc[1]);
#line 39
  packet_put_char(3);
#line 39
  packet_put_char((int )tio.c_cc[2]);
#line 41
  packet_put_char(4);
#line 41
  packet_put_char((int )tio.c_cc[3]);
#line 43
  packet_put_char(5);
#line 43
  packet_put_char((int )tio.c_cc[4]);
#line 45
  packet_put_char(6);
#line 45
  packet_put_char((int )tio.c_cc[11]);
#line 48
  packet_put_char(7);
#line 48
  packet_put_char((int )tio.c_cc[16]);
#line 50
  packet_put_char(8);
#line 50
  packet_put_char((int )tio.c_cc[8]);
#line 51
  packet_put_char(9);
#line 51
  packet_put_char((int )tio.c_cc[9]);
#line 53
  packet_put_char(10);
#line 53
  packet_put_char((int )tio.c_cc[10]);
#line 59
  packet_put_char(12);
#line 59
  packet_put_char((int )tio.c_cc[12]);
#line 62
  packet_put_char(13);
#line 62
  packet_put_char((int )tio.c_cc[14]);
#line 65
  packet_put_char(14);
#line 65
  packet_put_char((int )tio.c_cc[15]);
#line 77
  packet_put_char(18);
#line 77
  packet_put_char((int )tio.c_cc[13]);
#line 81
  packet_put_char(30);
#line 81
  packet_put_char((tio.c_iflag & 4U) != 0U);
#line 82
  packet_put_char(31);
#line 82
  packet_put_char((tio.c_iflag & 8U) != 0U);
#line 83
  packet_put_char(32);
#line 83
  packet_put_char((tio.c_iflag & 16U) != 0U);
#line 84
  packet_put_char(33);
#line 84
  packet_put_char((tio.c_iflag & 32U) != 0U);
#line 85
  packet_put_char(34);
#line 85
  packet_put_char((tio.c_iflag & 64U) != 0U);
#line 86
  packet_put_char(35);
#line 86
  packet_put_char((tio.c_iflag & 128U) != 0U);
#line 87
  packet_put_char(36);
#line 87
  packet_put_char((tio.c_iflag & 256U) != 0U);
#line 89
  packet_put_char(37);
#line 89
  packet_put_char((tio.c_iflag & 512U) != 0U);
#line 91
  packet_put_char(38);
#line 91
  packet_put_char((tio.c_iflag & 1024U) != 0U);
#line 92
  packet_put_char(39);
#line 92
  packet_put_char((tio.c_iflag & 2048U) != 0U);
#line 93
  packet_put_char(40);
#line 93
  packet_put_char((tio.c_iflag & 4096U) != 0U);
#line 95
  packet_put_char(41);
#line 95
  packet_put_char((tio.c_iflag & 8192U) != 0U);
#line 98
  packet_put_char(50);
#line 98
  packet_put_char((tio.c_lflag & 1U) != 0U);
#line 99
  packet_put_char(51);
#line 99
  packet_put_char((tio.c_lflag & 2U) != 0U);
#line 101
  packet_put_char(52);
#line 101
  packet_put_char((tio.c_lflag & 4U) != 0U);
#line 103
  packet_put_char(53);
#line 103
  packet_put_char((tio.c_lflag & 8U) != 0U);
#line 104
  packet_put_char(54);
#line 104
  packet_put_char((tio.c_lflag & 16U) != 0U);
#line 105
  packet_put_char(55);
#line 105
  packet_put_char((tio.c_lflag & 32U) != 0U);
#line 106
  packet_put_char(56);
#line 106
  packet_put_char((tio.c_lflag & 64U) != 0U);
#line 107
  packet_put_char(57);
#line 107
  packet_put_char((tio.c_lflag & 128U) != 0U);
#line 108
  packet_put_char(58);
#line 108
  packet_put_char((tio.c_lflag & 256U) != 0U);
#line 110
  packet_put_char(59);
#line 110
  packet_put_char((tio.c_lflag & 32768U) != 0U);
#line 113
  packet_put_char(60);
#line 113
  packet_put_char((tio.c_lflag & 512U) != 0U);
#line 116
  packet_put_char(61);
#line 116
  packet_put_char((tio.c_lflag & 2048U) != 0U);
#line 119
  packet_put_char(62);
#line 119
  packet_put_char((tio.c_lflag & 16384U) != 0U);
#line 122
  packet_put_char(70);
#line 122
  packet_put_char((tio.c_oflag & 1U) != 0U);
#line 124
  packet_put_char(71);
#line 124
  packet_put_char((tio.c_oflag & 2U) != 0U);
#line 126
  packet_put_char(72);
#line 126
  packet_put_char((tio.c_oflag & 4U) != 0U);
#line 128
  packet_put_char(73);
#line 128
  packet_put_char((tio.c_oflag & 8U) != 0U);
#line 131
  packet_put_char(74);
#line 131
  packet_put_char((tio.c_oflag & 16U) != 0U);
#line 134
  packet_put_char(75);
#line 134
  packet_put_char((tio.c_oflag & 32U) != 0U);
#line 137
  packet_put_char(90);
#line 137
  packet_put_char((tio.c_cflag & 32U) != 0U);
#line 138
  packet_put_char(91);
#line 138
  packet_put_char((tio.c_cflag & 48U) != 0U);
#line 139
  packet_put_char(92);
#line 139
  packet_put_char((tio.c_cflag & 256U) != 0U);
#line 140
  packet_put_char(93);
#line 140
  packet_put_char((tio.c_cflag & 512U) != 0U);
#line 243 "ttymodes.c"
  packet_put_char(0);
#line 244
  return;
}
}
#line 250 "ttymodes.c"
void tty_parse_modes(int fd , int *n_bytes_ptr ) 
{ struct termios tio ;
  int opcode ;
  int baud ;
  int n_bytes ;
  int failure ;
  int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  speed_t tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  speed_t tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;
  unsigned int tmp___22 ;
  unsigned int tmp___23 ;
  unsigned int tmp___24 ;
  unsigned int tmp___25 ;
  unsigned int tmp___26 ;
  unsigned int tmp___27 ;
  unsigned int tmp___28 ;
  unsigned int tmp___29 ;
  unsigned int tmp___30 ;
  unsigned int tmp___31 ;
  unsigned int tmp___32 ;
  unsigned int tmp___33 ;
  unsigned int tmp___34 ;
  unsigned int tmp___35 ;
  unsigned int tmp___36 ;
  unsigned int tmp___37 ;
  unsigned int tmp___38 ;
  unsigned int tmp___39 ;
  unsigned int tmp___40 ;
  unsigned int tmp___41 ;
  unsigned int tmp___42 ;
  unsigned int tmp___43 ;
  unsigned int tmp___44 ;
  unsigned int tmp___45 ;
  unsigned int tmp___46 ;
  unsigned int tmp___47 ;
  unsigned int tmp___48 ;
  unsigned int tmp___49 ;
  unsigned int tmp___50 ;
  unsigned int tmp___51 ;
  unsigned int tmp___52 ;
  unsigned int tmp___53 ;
  unsigned int tmp___54 ;
  unsigned int tmp___55 ;
  int _p ;
  int _e ;
  int *tmp___56 ;
  char *tmp___57 ;
  int tmp___58 ;

  {
#line 255
  n_bytes = 0;
#line 256
  failure = 0;
#line 263
  tmp = tcgetattr(fd, & tio);
#line 263
  if (tmp < 0) {
#line 264
    failure = -1;
  }
#line 266
  while (1) {
#line 267
    n_bytes ++;
#line 268
    tmp___0 = packet_get_char();
#line 268
    opcode = (int )tmp___0;
#line 269
    switch (opcode) {
    case 0: 
    goto set;
    case 192: 
#line 274
    n_bytes += 4;
#line 275
    tmp___1 = packet_get_int();
#line 275
    baud = (int )tmp___1;
#line 276
    if (failure != -1) {
#line 276
      tmp___2 = baud_to_speed(baud);
#line 276
      tmp___3 = cfsetispeed(& tio, tmp___2);
#line 276
      if (tmp___3 < 0) {
#line 277
        error("cfsetispeed failed for %d", baud);
      }
    }
#line 278
    break;
    case 193: 
#line 281
    n_bytes += 4;
#line 282
    tmp___4 = packet_get_int();
#line 282
    baud = (int )tmp___4;
#line 283
    if (failure != -1) {
#line 283
      tmp___5 = baud_to_speed(baud);
#line 283
      tmp___6 = cfsetospeed(& tio, tmp___5);
#line 283
      if (tmp___6 < 0) {
#line 284
        error("cfsetospeed failed for %d", baud);
      }
    }
#line 285
    break;
    case 1: 
#line 37 "ttymodes.h"
    n_bytes ++;
#line 37
    tmp___7 = packet_get_char();
#line 37
    tio.c_cc[0] = (unsigned char )tmp___7;
#line 37
    break;
    case 2: 
#line 38
    n_bytes ++;
#line 38
    tmp___8 = packet_get_char();
#line 38
    tio.c_cc[1] = (unsigned char )tmp___8;
#line 38
    break;
    case 3: 
#line 39
    n_bytes ++;
#line 39
    tmp___9 = packet_get_char();
#line 39
    tio.c_cc[2] = (unsigned char )tmp___9;
#line 39
    break;
    case 4: 
#line 41
    n_bytes ++;
#line 41
    tmp___10 = packet_get_char();
#line 41
    tio.c_cc[3] = (unsigned char )tmp___10;
#line 41
    break;
    case 5: 
#line 43
    n_bytes ++;
#line 43
    tmp___11 = packet_get_char();
#line 43
    tio.c_cc[4] = (unsigned char )tmp___11;
#line 43
    break;
    case 6: 
#line 45
    n_bytes ++;
#line 45
    tmp___12 = packet_get_char();
#line 45
    tio.c_cc[11] = (unsigned char )tmp___12;
#line 45
    break;
    case 7: 
#line 48
    n_bytes ++;
#line 48
    tmp___13 = packet_get_char();
#line 48
    tio.c_cc[16] = (unsigned char )tmp___13;
#line 48
    break;
    case 8: 
#line 50
    n_bytes ++;
#line 50
    tmp___14 = packet_get_char();
#line 50
    tio.c_cc[8] = (unsigned char )tmp___14;
#line 50
    break;
    case 9: 
#line 51
    n_bytes ++;
#line 51
    tmp___15 = packet_get_char();
#line 51
    tio.c_cc[9] = (unsigned char )tmp___15;
#line 51
    break;
    case 10: 
#line 53
    n_bytes ++;
#line 53
    tmp___16 = packet_get_char();
#line 53
    tio.c_cc[10] = (unsigned char )tmp___16;
#line 53
    break;
    case 12: 
#line 59
    n_bytes ++;
#line 59
    tmp___17 = packet_get_char();
#line 59
    tio.c_cc[12] = (unsigned char )tmp___17;
#line 59
    break;
    case 13: 
#line 62
    n_bytes ++;
#line 62
    tmp___18 = packet_get_char();
#line 62
    tio.c_cc[14] = (unsigned char )tmp___18;
#line 62
    break;
    case 14: 
#line 65
    n_bytes ++;
#line 65
    tmp___19 = packet_get_char();
#line 65
    tio.c_cc[15] = (unsigned char )tmp___19;
#line 65
    break;
    case 18: 
#line 77
    n_bytes ++;
#line 77
    tmp___20 = packet_get_char();
#line 77
    tio.c_cc[13] = (unsigned char )tmp___20;
#line 77
    break;
    case 30: 
#line 81
    n_bytes ++;
#line 81
    tmp___21 = packet_get_char();
#line 81
    if (tmp___21) {
#line 81
      tio.c_iflag |= 4U;
    } else {
#line 81
      tio.c_iflag &= 4294967291U;
    }
#line 81
    break;
    case 31: 
#line 82
    n_bytes ++;
#line 82
    tmp___22 = packet_get_char();
#line 82
    if (tmp___22) {
#line 82
      tio.c_iflag |= 8U;
    } else {
#line 82
      tio.c_iflag &= 4294967287U;
    }
#line 82
    break;
    case 32: 
#line 83
    n_bytes ++;
#line 83
    tmp___23 = packet_get_char();
#line 83
    if (tmp___23) {
#line 83
      tio.c_iflag |= 16U;
    } else {
#line 83
      tio.c_iflag &= 4294967279U;
    }
#line 83
    break;
    case 33: 
#line 84
    n_bytes ++;
#line 84
    tmp___24 = packet_get_char();
#line 84
    if (tmp___24) {
#line 84
      tio.c_iflag |= 32U;
    } else {
#line 84
      tio.c_iflag &= 4294967263U;
    }
#line 84
    break;
    case 34: 
#line 85
    n_bytes ++;
#line 85
    tmp___25 = packet_get_char();
#line 85
    if (tmp___25) {
#line 85
      tio.c_iflag |= 64U;
    } else {
#line 85
      tio.c_iflag &= 4294967231U;
    }
#line 85
    break;
    case 35: 
#line 86
    n_bytes ++;
#line 86
    tmp___26 = packet_get_char();
#line 86
    if (tmp___26) {
#line 86
      tio.c_iflag |= 128U;
    } else {
#line 86
      tio.c_iflag &= 4294967167U;
    }
#line 86
    break;
    case 36: 
#line 87
    n_bytes ++;
#line 87
    tmp___27 = packet_get_char();
#line 87
    if (tmp___27) {
#line 87
      tio.c_iflag |= 256U;
    } else {
#line 87
      tio.c_iflag &= 4294967039U;
    }
#line 87
    break;
    case 37: 
#line 89
    n_bytes ++;
#line 89
    tmp___28 = packet_get_char();
#line 89
    if (tmp___28) {
#line 89
      tio.c_iflag |= 512U;
    } else {
#line 89
      tio.c_iflag &= 4294966783U;
    }
#line 89
    break;
    case 38: 
#line 91
    n_bytes ++;
#line 91
    tmp___29 = packet_get_char();
#line 91
    if (tmp___29) {
#line 91
      tio.c_iflag |= 1024U;
    } else {
#line 91
      tio.c_iflag &= 4294966271U;
    }
#line 91
    break;
    case 39: 
#line 92
    n_bytes ++;
#line 92
    tmp___30 = packet_get_char();
#line 92
    if (tmp___30) {
#line 92
      tio.c_iflag |= 2048U;
    } else {
#line 92
      tio.c_iflag &= 4294965247U;
    }
#line 92
    break;
    case 40: 
#line 93
    n_bytes ++;
#line 93
    tmp___31 = packet_get_char();
#line 93
    if (tmp___31) {
#line 93
      tio.c_iflag |= 4096U;
    } else {
#line 93
      tio.c_iflag &= 4294963199U;
    }
#line 93
    break;
    case 41: 
#line 95
    n_bytes ++;
#line 95
    tmp___32 = packet_get_char();
#line 95
    if (tmp___32) {
#line 95
      tio.c_iflag |= 8192U;
    } else {
#line 95
      tio.c_iflag &= 4294959103U;
    }
#line 95
    break;
    case 50: 
#line 98
    n_bytes ++;
#line 98
    tmp___33 = packet_get_char();
#line 98
    if (tmp___33) {
#line 98
      tio.c_lflag |= 1U;
    } else {
#line 98
      tio.c_lflag &= 4294967294U;
    }
#line 98
    break;
    case 51: 
#line 99
    n_bytes ++;
#line 99
    tmp___34 = packet_get_char();
#line 99
    if (tmp___34) {
#line 99
      tio.c_lflag |= 2U;
    } else {
#line 99
      tio.c_lflag &= 4294967293U;
    }
#line 99
    break;
    case 52: 
#line 101
    n_bytes ++;
#line 101
    tmp___35 = packet_get_char();
#line 101
    if (tmp___35) {
#line 101
      tio.c_lflag |= 4U;
    } else {
#line 101
      tio.c_lflag &= 4294967291U;
    }
#line 101
    break;
    case 53: 
#line 103
    n_bytes ++;
#line 103
    tmp___36 = packet_get_char();
#line 103
    if (tmp___36) {
#line 103
      tio.c_lflag |= 8U;
    } else {
#line 103
      tio.c_lflag &= 4294967287U;
    }
#line 103
    break;
    case 54: 
#line 104
    n_bytes ++;
#line 104
    tmp___37 = packet_get_char();
#line 104
    if (tmp___37) {
#line 104
      tio.c_lflag |= 16U;
    } else {
#line 104
      tio.c_lflag &= 4294967279U;
    }
#line 104
    break;
    case 55: 
#line 105
    n_bytes ++;
#line 105
    tmp___38 = packet_get_char();
#line 105
    if (tmp___38) {
#line 105
      tio.c_lflag |= 32U;
    } else {
#line 105
      tio.c_lflag &= 4294967263U;
    }
#line 105
    break;
    case 56: 
#line 106
    n_bytes ++;
#line 106
    tmp___39 = packet_get_char();
#line 106
    if (tmp___39) {
#line 106
      tio.c_lflag |= 64U;
    } else {
#line 106
      tio.c_lflag &= 4294967231U;
    }
#line 106
    break;
    case 57: 
#line 107
    n_bytes ++;
#line 107
    tmp___40 = packet_get_char();
#line 107
    if (tmp___40) {
#line 107
      tio.c_lflag |= 128U;
    } else {
#line 107
      tio.c_lflag &= 4294967167U;
    }
#line 107
    break;
    case 58: 
#line 108
    n_bytes ++;
#line 108
    tmp___41 = packet_get_char();
#line 108
    if (tmp___41) {
#line 108
      tio.c_lflag |= 256U;
    } else {
#line 108
      tio.c_lflag &= 4294967039U;
    }
#line 108
    break;
    case 59: 
#line 110
    n_bytes ++;
#line 110
    tmp___42 = packet_get_char();
#line 110
    if (tmp___42) {
#line 110
      tio.c_lflag |= 32768U;
    } else {
#line 110
      tio.c_lflag &= 4294934527U;
    }
#line 110
    break;
    case 60: 
#line 113
    n_bytes ++;
#line 113
    tmp___43 = packet_get_char();
#line 113
    if (tmp___43) {
#line 113
      tio.c_lflag |= 512U;
    } else {
#line 113
      tio.c_lflag &= 4294966783U;
    }
#line 113
    break;
    case 61: 
#line 116
    n_bytes ++;
#line 116
    tmp___44 = packet_get_char();
#line 116
    if (tmp___44) {
#line 116
      tio.c_lflag |= 2048U;
    } else {
#line 116
      tio.c_lflag &= 4294965247U;
    }
#line 116
    break;
    case 62: 
#line 119
    n_bytes ++;
#line 119
    tmp___45 = packet_get_char();
#line 119
    if (tmp___45) {
#line 119
      tio.c_lflag |= 16384U;
    } else {
#line 119
      tio.c_lflag &= 4294950911U;
    }
#line 119
    break;
    case 70: 
#line 122
    n_bytes ++;
#line 122
    tmp___46 = packet_get_char();
#line 122
    if (tmp___46) {
#line 122
      tio.c_oflag |= 1U;
    } else {
#line 122
      tio.c_oflag &= 4294967294U;
    }
#line 122
    break;
    case 71: 
#line 124
    n_bytes ++;
#line 124
    tmp___47 = packet_get_char();
#line 124
    if (tmp___47) {
#line 124
      tio.c_oflag |= 2U;
    } else {
#line 124
      tio.c_oflag &= 4294967293U;
    }
#line 124
    break;
    case 72: 
#line 126
    n_bytes ++;
#line 126
    tmp___48 = packet_get_char();
#line 126
    if (tmp___48) {
#line 126
      tio.c_oflag |= 4U;
    } else {
#line 126
      tio.c_oflag &= 4294967291U;
    }
#line 126
    break;
    case 73: 
#line 128
    n_bytes ++;
#line 128
    tmp___49 = packet_get_char();
#line 128
    if (tmp___49) {
#line 128
      tio.c_oflag |= 8U;
    } else {
#line 128
      tio.c_oflag &= 4294967287U;
    }
#line 128
    break;
    case 74: 
#line 131
    n_bytes ++;
#line 131
    tmp___50 = packet_get_char();
#line 131
    if (tmp___50) {
#line 131
      tio.c_oflag |= 16U;
    } else {
#line 131
      tio.c_oflag &= 4294967279U;
    }
#line 131
    break;
    case 75: 
#line 134
    n_bytes ++;
#line 134
    tmp___51 = packet_get_char();
#line 134
    if (tmp___51) {
#line 134
      tio.c_oflag |= 32U;
    } else {
#line 134
      tio.c_oflag &= 4294967263U;
    }
#line 134
    break;
    case 90: 
#line 137
    n_bytes ++;
#line 137
    tmp___52 = packet_get_char();
#line 137
    if (tmp___52) {
#line 137
      tio.c_cflag |= 32U;
    } else {
#line 137
      tio.c_cflag &= 4294967263U;
    }
#line 137
    break;
    case 91: 
#line 138
    n_bytes ++;
#line 138
    tmp___53 = packet_get_char();
#line 138
    if (tmp___53) {
#line 138
      tio.c_cflag |= 48U;
    } else {
#line 138
      tio.c_cflag &= 4294967247U;
    }
#line 138
    break;
    case 92: 
#line 139
    n_bytes ++;
#line 139
    tmp___54 = packet_get_char();
#line 139
    if (tmp___54) {
#line 139
      tio.c_cflag |= 256U;
    } else {
#line 139
      tio.c_cflag &= 4294967039U;
    }
#line 139
    break;
    case 93: 
#line 140
    n_bytes ++;
#line 140
    tmp___55 = packet_get_char();
#line 140
    if (tmp___55) {
#line 140
      tio.c_cflag |= 512U;
    } else {
#line 140
      tio.c_cflag &= 4294966783U;
    }
#line 140
    break;
    default: 
#line 313 "ttymodes.c"
    debug("Ignoring unsupported tty mode opcode %d (0x%x)", opcode, opcode);
#line 319
    if (opcode >= 0) {
#line 319
      if (opcode < 128) {
#line 320
        n_bytes ++;
#line 321
        packet_get_char();
#line 322
        break;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 328
      if (opcode >= 128) {
#line 328
        if (opcode < 160) {
#line 329
          n_bytes += 4;
#line 330
          packet_get_int();
#line 331
          break;
        }
      }
    }
#line 341
    log("parse_tty_modes: unknown opcode %d", opcode);
#line 342
    while (1) {
#line 342
      _p = 0;
#line 342
      _e = 1;
#line 342
      if (_p != _e) {
#line 342
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "ttymodes.c", 342);
#line 342
        packet_disconnect("Packet integrity error. (%d)", 10);
      }
#line 342
      break;
    }
    goto set;
    }
  }
  set: 
#line 348
  if (*n_bytes_ptr != n_bytes) {
#line 349
    *n_bytes_ptr = n_bytes;
#line 350
    return;
  }
#line 352
  if (failure == -1) {
#line 353
    return;
  }
#line 356
  tmp___58 = tcsetattr(fd, 0, (struct termios  const  *)(& tio));
#line 356
  if (tmp___58 < 0) {
#line 357
    tmp___56 = __errno_location();
#line 357
    tmp___57 = strerror(*tmp___56);
#line 357
    log("Setting tty modes failed: %.100s", tmp___57);
  }
#line 358
  return;
}
}
#line 1 "uidswap.o"
#line 645 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 667
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 677
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 34 "uidswap.h"
void permanently_set_uid(uid_t uid ) ;
#line 33 "uidswap.c"
static uid_t saved_euid  =    (uid_t )0;
#line 41 "uidswap.c"
void temporarily_use_uid(uid_t uid ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 46
  saved_euid = geteuid();
#line 49
  tmp___1 = seteuid(uid);
#line 49
  if (tmp___1 == -1) {
#line 50
    tmp = __errno_location();
#line 50
    tmp___0 = strerror(*tmp);
#line 50
    debug("seteuid %u: %.100s", uid, tmp___0);
  }
#line 60
  return;
}
}
#line 65 "uidswap.c"
void restore_uid(void) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 70
  tmp___1 = seteuid(saved_euid);
#line 70
  if (tmp___1 < 0) {
#line 71
    tmp = __errno_location();
#line 71
    tmp___0 = strerror(*tmp);
#line 71
    debug("seteuid %u: %.100s", saved_euid, tmp___0);
  }
#line 80
  return;
}
}
#line 86 "uidswap.c"
void permanently_set_uid(uid_t uid ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 97
  tmp___1 = setuid(uid);
#line 97
  if (tmp___1 < 0) {
#line 98
    tmp = __errno_location();
#line 98
    tmp___0 = strerror(*tmp);
#line 98
    debug("setuid %u: %.100s", uid, tmp___0);
  }
#line 99
  return;
}
}
/* compiler builtin: 
   char *__builtin_strpbrk(char const   * , char const   * ) ;  */
/* compiler builtin: 
   unsigned int __builtin_strspn(char const   * , char const   * ) ;  */
#line 1 "util.o"
#line 745 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 494 "ssh.h"
char *chop(char *s ) ;
#line 497
char *strdelim(char **s ) ;
#line 6 "util.c"
char *chop(char *s ) 
{ char *t ;

  {
#line 9
  t = s;
#line 10
  while (*t) {
#line 11
    if ((int )*t == 10) {
#line 12
      *t = (char )'\000';
#line 13
      return (s);
    } else {
#line 11
      if ((int )*t == 13) {
#line 12
        *t = (char )'\000';
#line 13
        return (s);
      }
    }
#line 15
    t ++;
  }
#line 17
  return (s);
}
}
#line 21 "util.c"
void set_nonblock(int fd ) 
{ int val ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 25
  tmp = isatty(fd);
#line 25
  if (tmp) {
#line 27
    debug("no set_nonblock for tty fd %d", fd);
#line 28
    return;
  }
#line 30
  val = fcntl(fd, 3, 0);
#line 31
  if (val < 0) {
#line 32
    tmp___0 = __errno_location();
#line 32
    tmp___1 = strerror(*tmp___0);
#line 32
    error("fcntl(%d, F_GETFL, 0): %s", fd, tmp___1);
#line 33
    return;
  }
#line 35
  if (val & 2048) {
#line 36
    return;
  }
#line 37
  debug("fd %d setting O_NONBLOCK", fd);
#line 38
  val |= 2048;
#line 39
  tmp___5 = fcntl(fd, 4, val);
#line 39
  if (tmp___5 == -1) {
#line 40
    tmp___4 = __errno_location();
#line 40
    if (*tmp___4 != 19) {
#line 41
      tmp___2 = __errno_location();
#line 41
      tmp___3 = strerror(*tmp___2);
#line 41
      error("fcntl(%d, F_SETFL, O_NONBLOCK): %s", fd, tmp___3);
    }
  }
#line 43
  return;
}
}
#line 48 "util.c"
char *strdelim(char **s ) 
{ char *old ;
  int wspace ;
  char *tmp___30 ;
  unsigned int tmp___62 ;
  unsigned int tmp___94 ;

  {
#line 52
  wspace = 0;
#line 54
  if ((unsigned int )*s == (unsigned int )((void *)0)) {
#line 55
    return ((char *)((void *)0));
  }
#line 57
  old = *s;
#line 59
  tmp___30 = __builtin_strpbrk((char const   *)*s, " \t\r\n=");
#line 59
  *s = tmp___30;
#line 60
  if ((unsigned int )*s == (unsigned int )((void *)0)) {
#line 61
    return (old);
  }
#line 64
  if ((int )*(*(s + 0)) == 61) {
#line 65
    wspace = 1;
  }
#line 66
  *(*(s + 0)) = (char )'\000';
#line 68
  tmp___62 = __builtin_strspn((char const   *)(*s + 1), " \t\r\n");
#line 68
  *s += tmp___62 + 1U;
#line 69
  if ((int )*(*(s + 0)) == 61) {
#line 69
    if (! wspace) {
#line 70
      tmp___94 = __builtin_strspn((char const   *)(*s + 1), " \t\r\n");
#line 70
      *s += tmp___94 + 1U;
    }
  }
#line 72
  return (old);
}
}
#line 1 "uuencode.o"
#line 8 "bsd-base64.h"
int b64_ntop(u_char const   *src , size_t srclength , char *target , size_t targsize ) ;
#line 10
int b64_pton(char const   *src , u_char *target , size_t targsize ) ;
#line 9 "uuencode.c"
int uuencode(unsigned char *src , unsigned int srclength , char *target , size_t targsize ) 
{ int tmp ;

  {
#line 13
  tmp = b64_ntop((u_char const   *)src, srclength, target, targsize);
#line 13
  return (tmp);
}
}
#line 16 "uuencode.c"
int uudecode(char const   *src , unsigned char *target , size_t targsize ) 
{ int len ;
  char *encoded ;
  char *p ;

  {
#line 23
  encoded = xstrdup(src);
#line 25
  p = encoded;
#line 25
  while (1) {
#line 25
    if (! ((int )*p == 32)) {
#line 25
      if (! ((int )*p == 9)) {
#line 25
        break;
      }
    }
#line 25
    p ++;
  }
#line 27
  while (1) {
#line 27
    if ((int )*p != 0) {
#line 27
      if ((int )*p != 32) {
#line 27
        if (! ((int )*p != 9)) {
#line 27
          break;
        }
      } else {
#line 27
        break;
      }
    } else {
#line 27
      break;
    }
#line 27
    p ++;
  }
#line 30
  *p = (char )'\000';
#line 31
  len = b64_pton((char const   *)encoded, target, targsize);
#line 32
  xfree((void *)encoded);
#line 33
  return (len);
}
}
#line 36 "uuencode.c"
void dump_base64(FILE *fp , unsigned char *data , int len ) 
{ unsigned char *buf___1 ;
  void *tmp ;
  int i ;
  int n___0 ;

  {
#line 39
  tmp = xmalloc((unsigned int )(2 * len));
#line 39
  buf___1 = (unsigned char *)tmp;
#line 41
  n___0 = uuencode(data, (unsigned int )len, (char *)buf___1, (unsigned int )(2 * len));
#line 42
  i = 0;
#line 42
  while (i < n___0) {
#line 43
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%c", *(buf___1 + i));
#line 44
    if (i % 70 == 69) {
#line 45
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
    }
#line 42
    i ++;
  }
#line 47
  if (i % 70 != 69) {
#line 48
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  }
#line 49
  xfree((void *)buf___1);
#line 50
  return;
}
}
#line 1 "xmalloc.o"
#line 589 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 600
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__warn_unused_result__,
__malloc__)) ;
#line 15 "xmalloc.c"
void *xmalloc(size_t size ) 
{ void *ptr ;
  void *tmp ;

  {
#line 18
  tmp = malloc(size);
#line 18
  ptr = tmp;
#line 19
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 20
    fatal("xmalloc: out of memory (allocating %d bytes)", (int )size);
  }
#line 21
  return (ptr);
}
}
#line 24 "xmalloc.c"
void *xrealloc(void *ptr , size_t new_size ) 
{ void *new_ptr ;

  {
#line 29
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 30
    fatal("xrealloc: NULL pointer given as argument");
  }
#line 31
  new_ptr = realloc(ptr, new_size);
#line 32
  if ((unsigned int )new_ptr == (unsigned int )((void *)0)) {
#line 33
    fatal("xrealloc: out of memory (new_size %d bytes)", (int )new_size);
  }
#line 34
  return (new_ptr);
}
}
#line 37 "xmalloc.c"
void xfree(void *ptr ) 
{ 

  {
#line 40
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 41
    fatal("xfree: NULL pointer given as argument");
  }
#line 42
  free(ptr);
#line 43
  return;
}
}
#line 45 "xmalloc.c"
char *xstrdup(char const   *str ) 
{ int len ;
  size_t tmp ;
  char *cp ;
  void *tmp___0 ;

  {
#line 48
  tmp = strlen(str);
#line 48
  len = (int )(tmp + 1U);
#line 50
  tmp___0 = xmalloc((unsigned int )len);
#line 50
  cp = (char *)tmp___0;
#line 51
  strlcpy(cp, str, (unsigned int )len);
#line 52
  return (cp);
}
}
#line 1 "bsd-arc4random.o"
#line 37 "bsd-arc4random.h"
void arc4random_stir(void) ;
#line 102 "/usr/include/openssl/rand.h"
extern int RAND_bytes(unsigned char *buf , int num ) ;
#line 42 "bsd-arc4random.c"
static int rc4_ready  =    0;
#line 43 "bsd-arc4random.c"
static RC4_KEY rc4  ;
#line 45 "bsd-arc4random.c"
unsigned int arc4random(void) 
{ unsigned int r ;

  {
#line 47
  r = 0U;
#line 49
  if (rc4_ready <= 0) {
#line 50
    arc4random_stir();
  }
#line 52
  RC4(& rc4, (unsigned long )sizeof(r), (unsigned char const   *)((unsigned char *)(& r)),
      (unsigned char *)(& r));
#line 54
  rc4_ready = (int )((unsigned int )rc4_ready - sizeof(r));
#line 56
  return (r);
}
}
#line 59 "bsd-arc4random.c"
void arc4random_stir(void) 
{ unsigned char rand_buf[20] ;

  {
#line 63
  memset((void *)(& rc4), 0, sizeof(rc4));
#line 65
  seed_rng();
#line 67
  RAND_bytes(rand_buf, (int )sizeof(rand_buf));
#line 69
  RC4_set_key(& rc4, (int )sizeof(rand_buf), (unsigned char const   *)(rand_buf));
#line 71
  memset((void *)(rand_buf), 0, sizeof(rand_buf));
#line 73
  rc4_ready = 1 << 18;
#line 74
  return;
}
}
#line 1 "bsd-base64.o"
#line 628 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 65 "bsd-base64.c"
static char const   Base64[65]  = 
#line 65 "bsd-base64.c"
  {      (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'g',      (char const   )'h',      (char const   )'i',      (char const   )'j', 
        (char const   )'k',      (char const   )'l',      (char const   )'m',      (char const   )'n', 
        (char const   )'o',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'+',      (char const   )'/', 
        (char const   )'\000'};
#line 67 "bsd-base64.c"
static char const   Pad64  =    (char const   )'=';
#line 132 "bsd-base64.c"
int b64_ntop(u_char const   *src , size_t srclength , char *target , size_t targsize ) 
{ size_t datalength ;
  u_char input___0[3] ;
  u_char output___0[4] ;
  int i ;
  u_char const   *tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  u_char const   *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;

  {
#line 135
  datalength = (size_t )0;
#line 140
  while (2U < srclength) {
#line 141
    tmp = src;
#line 141
    src ++;
#line 141
    input___0[0] = (unsigned char )*tmp;
#line 142
    tmp___0 = src;
#line 142
    src ++;
#line 142
    input___0[1] = (unsigned char )*tmp___0;
#line 143
    tmp___1 = src;
#line 143
    src ++;
#line 143
    input___0[2] = (unsigned char )*tmp___1;
#line 144
    srclength -= 3U;
#line 146
    output___0[0] = (unsigned char )((int )input___0[0] >> 2);
#line 147
    output___0[1] = (unsigned char )((((int )input___0[0] & 3) << 4) + ((int )input___0[1] >> 4));
#line 148
    output___0[2] = (unsigned char )((((int )input___0[1] & 15) << 2) + ((int )input___0[2] >> 6));
#line 149
    output___0[3] = (unsigned char )((int )input___0[2] & 63);
#line 150
    if (! ((int )output___0[0] < 64)) {
#line 150
      abort();
    }
#line 151
    if (! ((int )output___0[1] < 64)) {
#line 151
      abort();
    }
#line 152
    if (! ((int )output___0[2] < 64)) {
#line 152
      abort();
    }
#line 153
    if (! ((int )output___0[3] < 64)) {
#line 153
      abort();
    }
#line 155
    if (datalength + 4U > targsize) {
#line 156
      return (-1);
    }
#line 157
    tmp___2 = datalength;
#line 157
    datalength ++;
#line 157
    *(target + tmp___2) = (char )Base64[output___0[0]];
#line 158
    tmp___3 = datalength;
#line 158
    datalength ++;
#line 158
    *(target + tmp___3) = (char )Base64[output___0[1]];
#line 159
    tmp___4 = datalength;
#line 159
    datalength ++;
#line 159
    *(target + tmp___4) = (char )Base64[output___0[2]];
#line 160
    tmp___5 = datalength;
#line 160
    datalength ++;
#line 160
    *(target + tmp___5) = (char )Base64[output___0[3]];
  }
#line 164
  if (0U != srclength) {
#line 166
    input___0[2] = (unsigned char )'\000';
#line 166
    input___0[1] = input___0[2];
#line 166
    input___0[0] = input___0[1];
#line 167
    i = 0;
#line 167
    while ((size_t )i < srclength) {
#line 168
      tmp___6 = src;
#line 168
      src ++;
#line 168
      input___0[i] = (unsigned char )*tmp___6;
#line 167
      i ++;
    }
#line 170
    output___0[0] = (unsigned char )((int )input___0[0] >> 2);
#line 171
    output___0[1] = (unsigned char )((((int )input___0[0] & 3) << 4) + ((int )input___0[1] >> 4));
#line 172
    output___0[2] = (unsigned char )((((int )input___0[1] & 15) << 2) + ((int )input___0[2] >> 6));
#line 173
    if (! ((int )output___0[0] < 64)) {
#line 173
      abort();
    }
#line 174
    if (! ((int )output___0[1] < 64)) {
#line 174
      abort();
    }
#line 175
    if (! ((int )output___0[2] < 64)) {
#line 175
      abort();
    }
#line 177
    if (datalength + 4U > targsize) {
#line 178
      return (-1);
    }
#line 179
    tmp___7 = datalength;
#line 179
    datalength ++;
#line 179
    *(target + tmp___7) = (char )Base64[output___0[0]];
#line 180
    tmp___8 = datalength;
#line 180
    datalength ++;
#line 180
    *(target + tmp___8) = (char )Base64[output___0[1]];
#line 181
    if (srclength == 1U) {
#line 182
      tmp___9 = datalength;
#line 182
      datalength ++;
#line 182
      *(target + tmp___9) = (char )Pad64;
    } else {
#line 184
      tmp___10 = datalength;
#line 184
      datalength ++;
#line 184
      *(target + tmp___10) = (char )Base64[output___0[2]];
    }
#line 185
    tmp___11 = datalength;
#line 185
    datalength ++;
#line 185
    *(target + tmp___11) = (char )Pad64;
  }
#line 187
  if (datalength >= targsize) {
#line 188
    return (-1);
  }
#line 189
  *(target + datalength) = (char )'\000';
#line 190
  return ((int )datalength);
}
}
#line 199 "bsd-base64.c"
int b64_pton(char const   *src , u_char *target , size_t targsize ) 
{ int tarindex ;
  int state ;
  int ch ;
  char *pos ;
  unsigned short const   **tmp ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  unsigned short const   **tmp___8 ;

  {
#line 205
  state = 0;
#line 206
  tarindex = 0;
#line 208
  while (1) {
#line 208
    tmp___2 = src;
#line 208
    src ++;
#line 208
    ch = (int )*tmp___2;
#line 208
    if (! (ch != 0)) {
#line 208
      break;
    }
#line 209
    tmp = __ctype_b_loc();
#line 209
    if ((int const   )*(*tmp + ch) & 8192) {
#line 210
      continue;
    }
#line 212
    if (ch == (int )Pad64) {
#line 213
      break;
    }
#line 215
    tmp___1 = __builtin_strchr((char *)(Base64), ch);
#line 215
    pos = tmp___1;
#line 216
    if ((unsigned int )pos == (unsigned int )((char *)0)) {
#line 217
      return (-1);
    }
#line 219
    switch (state) {
    case 0: 
#line 221
    if (target) {
#line 222
      if ((size_t )tarindex >= targsize) {
#line 223
        return (-1);
      }
#line 224
      *(target + tarindex) = (unsigned char )((pos - (char *)(Base64)) << 2);
    }
#line 226
    state = 1;
#line 227
    break;
    case 1: 
#line 229
    if (target) {
#line 230
      if ((size_t )(tarindex + 1) >= targsize) {
#line 231
        return (-1);
      }
#line 232
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | ((pos - (char *)(Base64)) >> 4));
#line 233
      *(target + (tarindex + 1)) = (unsigned char )(((pos - (char *)(Base64)) & 15) << 4);
    }
#line 236
    tarindex ++;
#line 237
    state = 2;
#line 238
    break;
    case 2: 
#line 240
    if (target) {
#line 241
      if ((size_t )(tarindex + 1) >= targsize) {
#line 242
        return (-1);
      }
#line 243
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | ((pos - (char *)(Base64)) >> 2));
#line 244
      *(target + (tarindex + 1)) = (unsigned char )(((pos - (char *)(Base64)) & 3) << 6);
    }
#line 247
    tarindex ++;
#line 248
    state = 3;
#line 249
    break;
    case 3: 
#line 251
    if (target) {
#line 252
      if ((size_t )tarindex >= targsize) {
#line 253
        return (-1);
      }
#line 254
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | (pos - (char *)(Base64)));
    }
#line 256
    tarindex ++;
#line 257
    state = 0;
#line 258
    break;
    }
  }
#line 267
  if (ch == (int )Pad64) {
#line 268
    tmp___3 = src;
#line 268
    src ++;
#line 268
    ch = (int )*tmp___3;
#line 269
    switch (state) {
    case 0: 
    case 1: 
#line 272
    return (-1);
    case 2: 
#line 276
    while (ch != 0) {
#line 277
      tmp___5 = __ctype_b_loc();
#line 277
      if (! ((int const   )*(*tmp___5 + ch) & 8192)) {
#line 278
        break;
      }
#line 276
      tmp___4 = src;
#line 276
      src ++;
#line 276
      ch = (int )*tmp___4;
    }
#line 280
    if (ch != (int )Pad64) {
#line 281
      return (-1);
    }
#line 282
    tmp___6 = src;
#line 282
    src ++;
#line 282
    ch = (int )*tmp___6;
    case 3: 
#line 291
    while (ch != 0) {
#line 292
      tmp___8 = __ctype_b_loc();
#line 292
      if (! ((int const   )*(*tmp___8 + ch) & 8192)) {
#line 293
        return (-1);
      }
#line 291
      tmp___7 = src;
#line 291
      src ++;
#line 291
      ch = (int )*tmp___7;
    }
#line 301
    if (target) {
#line 301
      if ((int )*(target + tarindex) != 0) {
#line 302
        return (-1);
      }
    }
    }
  } else {
#line 309
    if (state != 0) {
#line 310
      return (-1);
    }
  }
#line 313
  return (tarindex);
}
}
#line 1 "bsd-bindresvport.o"
#line 7 "bsd-bindresvport.h"
int bindresvport_af(int sd , struct sockaddr *sa , int af ) ;
#line 53 "bsd-bindresvport.c"
int bindresvport_af(int sd , struct sockaddr *sa , int af ) 
{ int error___0 ;
  struct sockaddr_storage myaddr ;
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;
  u_int16_t *portp ;
  u_int16_t port ;
  int salen ;
  int i ;
  int *tmp ;
  register unsigned short __v ;
  register unsigned short __x ;
  unsigned int tmp___0 ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 68
  if ((unsigned int )sa == (unsigned int )((void *)0)) {
#line 69
    memset((void *)(& myaddr), 0, sizeof(myaddr));
#line 70
    sa = (struct sockaddr *)(& myaddr);
  }
#line 73
  if (af == 2) {
#line 74
    sin = (struct sockaddr_in *)sa;
#line 75
    salen = (int )sizeof(struct sockaddr_in );
#line 76
    portp = & sin->sin_port;
  } else {
#line 77
    if (af == 10) {
#line 78
      sin6 = (struct sockaddr_in6 *)sa;
#line 79
      salen = (int )sizeof(struct sockaddr_in6 );
#line 80
      portp = & sin6->sin6_port;
    } else {
#line 82
      tmp = __errno_location();
#line 82
      *tmp = 96;
#line 83
      return (-1);
    }
  }
#line 85
  sa->sa_family = (unsigned short )af;
#line 87
  __x = *portp;
#line 87
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 87
  port = __v;
#line 88
  if ((int )port == 0) {
#line 89
    tmp___0 = arc4random();
#line 89
    port = (unsigned short )(tmp___0 % 424U + 600U);
  }
#line 91
  i = 0;
#line 91
  while (i < 424) {
#line 92
    __x___0 = port;
#line 92
    __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 92
    *portp = __v___0;
#line 94
    error___0 = bind(sd, (struct sockaddr  const  *)sa, (unsigned int )salen);
#line 97
    if (error___0 == 0) {
#line 98
      break;
    }
#line 101
    if (error___0 < 0) {
#line 101
      tmp___1 = __errno_location();
#line 101
      if (! (*tmp___1 == 98)) {
#line 101
        tmp___2 = __errno_location();
#line 101
        if (! (*tmp___2 == 22)) {
#line 102
          break;
        }
      }
    }
#line 104
    port = (u_int16_t )((int )port + 1);
#line 105
    if ((int )port > 1023) {
#line 106
      port = (unsigned short)600;
    }
#line 91
    i ++;
  }
#line 109
  return (error___0);
}
}
#line 1 "bsd-daemon.o"
#line 1 "bsd-inet_aton.o"
#line 1 "bsd-inet_ntoa.o"
#line 1 "bsd-misc.o"
#line 828 "/usr/include/unistd.h"
 __attribute__((__nothrow__)) int setlogin(char const   *name )  __attribute__((__nonnull__(1))) ;
#line 36 "bsd-misc.h"
void setproctitle(char const   *fmt  , ...) ;
#line 35 "bsd-misc.c"
void setproctitle(char const   *fmt  , ...) 
{ 

  {
#line 38
  return;
}
}
#line 42
 __attribute__((__nothrow__)) int setlogin(char const   *name )  __attribute__((__nonnull__(1))) ;
#line 42 "bsd-misc.c"
int setlogin(char const   *name ) 
{ 

  {
#line 44
  return (0);
}
}
#line 1 "bsd-mktemp.o"
#line 1 "bsd-rresvport.o"
#line 1 "bsd-setenv.o"
#line 1 "bsd-sigaction.o"
#line 1 "bsd-snprintf.o"
#line 1 "bsd-strlcat.o"
#line 46 "bsd-strlcat.c"
size_t strlcat(char *dst , char const   *src , size_t siz ) 
{ register char *d ;
  register char const   *s ;
  register size_t n___0 ;
  size_t dlen ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 51
  d = dst;
#line 52
  s = src;
#line 53
  n___0 = siz;
#line 57
  while (1) {
#line 57
    if ((int )*d != 0) {
#line 57
      tmp = n___0;
#line 57
      n___0 --;
#line 57
      if (! (tmp != 0U)) {
#line 57
        break;
      }
    } else {
#line 57
      break;
    }
#line 58
    d ++;
  }
#line 59
  dlen = (unsigned int )(d - dst);
#line 60
  n___0 = siz - dlen;
#line 62
  if (n___0 == 0U) {
#line 63
    tmp___0 = strlen(s);
#line 63
    return (dlen + tmp___0);
  }
#line 64
  while ((int const   )*s != 0) {
#line 65
    if (n___0 != 1U) {
#line 66
      tmp___1 = d;
#line 66
      d ++;
#line 66
      *tmp___1 = (char )*s;
#line 67
      n___0 --;
    }
#line 69
    s ++;
  }
#line 71
  *d = (char )'\000';
#line 73
  return (dlen + (size_t )(s - src));
}
}
#line 1 "bsd-strlcpy.o"
#line 45 "bsd-strlcpy.c"
size_t strlcpy(char *dst , char const   *src , size_t siz ) 
{ register char *d ;
  register char const   *s ;
  register size_t n___0 ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 50
  d = dst;
#line 51
  s = src;
#line 52
  n___0 = siz;
#line 55
  if (n___0 != 0U) {
#line 55
    n___0 --;
#line 55
    if (n___0 != 0U) {
#line 56
      while (1) {
#line 57
        tmp = d;
#line 57
        d ++;
#line 57
        tmp___0 = s;
#line 57
        s ++;
#line 57
        *tmp = (char )*tmp___0;
#line 57
        if ((int )*tmp == 0) {
#line 58
          break;
        }
#line 56
        n___0 --;
#line 56
        if (! (n___0 != 0U)) {
#line 56
          break;
        }
      }
    }
  }
#line 63
  if (n___0 == 0U) {
#line 64
    if (siz != 0U) {
#line 65
      *d = (char )'\000';
    }
#line 66
    while (1) {
#line 66
      tmp___1 = s;
#line 66
      s ++;
#line 66
      if (! *tmp___1) {
#line 66
        break;
      }
    }
  }
#line 70
  return ((unsigned int )((s - src) - 1));
}
}
#line 1 "bsd-strsep.o"
#line 1 "fake-getaddrinfo.o"
#line 1 "fake-getnameinfo.o"
#line 1 "next-posix.o"
#line 1 "sshd.o"
#line 384 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 393
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 457
extern  __attribute__((__nothrow__)) int chdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 490
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 516
extern  __attribute__((__nothrow__)) int execv(char const   *__path , char * const  *__argv )  __attribute__((__nonnull__(1))) ;
#line 723
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 792
extern  __attribute__((__nothrow__)) int unlink(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 73
extern int optind ;
#line 152
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 903 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 92 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 478 "/usr/include/openssl/bn.h"
extern int BN_mask_bits(BIGNUM *a , int n ) ;
#line 456 "ssh.h"
void log_init(char *av0___0 , LogLevel level , SyslogFacility facility , int on_stderr ) ;
#line 7 "auth-pam.h"
void finish_pam(void) ;
#line 112 "servconf.h"
void initialize_server_options(ServerOptions *options___0 ) ;
#line 118
void read_server_config(ServerOptions *options___0 , char const   *filename ) ;
#line 121
void fill_default_server_options(ServerOptions *options___0 ) ;
#line 174 "/usr/include/openssl/dh.h"
extern void DH_free(DH *dh ) ;
#line 176
extern int DH_size(DH const   *dh ) ;
#line 194
extern int DH_compute_key(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
#line 4 "auth.h"
void do_authentication(void) ;
#line 5
void do_authentication2(void) ;
#line 9 "myproposal.h"
static char *myproposal[10]  = 
#line 9 "myproposal.h"
  {      (char *)"diffie-hellman-group1-sha1",      (char *)"ssh-dss",      (char *)"3des-cbc,blowfish-cbc,arcfour,cast128-cbc",      (char *)"3des-cbc,blowfish-cbc,arcfour,cast128-cbc", 
        (char *)"hmac-sha1,hmac-md5,hmac-ripemd160@openssh.com",      (char *)"hmac-sha1,hmac-md5,hmac-ripemd160@openssh.com",      (char *)"zlib,none",      (char *)"zlib,none", 
        (char *)"",      (char *)""};
#line 57 "sshd.c"
ServerOptions options  ;
#line 60 "sshd.c"
char *config_file_name  =    (char *)"/usr/local/etc/sshd_config";
#line 69 "sshd.c"
int IPv4or6  =    0;
#line 78 "sshd.c"
int debug_flag  =    0;
#line 81 "sshd.c"
int inetd_flag  =    0;
#line 84 "sshd.c"
int log_stderr  =    0;
#line 87 "sshd.c"
char *av0  ;
#line 90 "sshd.c"
char **saved_argv  ;
#line 91 "sshd.c"
int saved_argc  ;
#line 98 "sshd.c"
int listen_socks[16]  ;
#line 99 "sshd.c"
int num_listen_socks  =    0;
#line 105 "sshd.c"
char *client_version_string  =    (char *)((void *)0);
#line 106 "sshd.c"
char *server_version_string  =    (char *)((void *)0);
#line 116 "sshd.c"
struct __anonstruct_sensitive_data_76 sensitive_data  ;
#line 126 "sshd.c"
int key_used  =    0;
#line 129 "sshd.c"
int received_sighup  =    0;
#line 133 "sshd.c"
RSA *public_key  ;
#line 136 "sshd.c"
unsigned char session_id[16]  ;
#line 139 "sshd.c"
unsigned char *session_id2  =    (unsigned char *)((void *)0);
#line 140 "sshd.c"
int session_id2_len  =    0;
#line 143 "sshd.c"
unsigned int utmp_len  =    64U;
#line 146
void do_ssh1_kex(void) ;
#line 147
void do_ssh2_kex(void) ;
#line 152 "sshd.c"
void close_listen_socks(void) 
{ int i ;

  {
#line 156
  i = 0;
#line 156
  while (i < num_listen_socks) {
#line 157
    close(listen_socks[i]);
#line 156
    i ++;
  }
#line 158
  num_listen_socks = -1;
#line 159
  return;
}
}
#line 166 "sshd.c"
void sighup_handler(int sig ) 
{ 

  {
#line 169
  received_sighup = 1;
#line 170
  signal(1, & sighup_handler);
#line 171
  return;
}
}
#line 177 "sshd.c"
void sighup_restart(void) 
{ int *tmp ;
  char *tmp___0 ;

  {
#line 180
  log("Received SIGHUP; restarting.");
#line 181
  close_listen_socks();
#line 182
  execv((char const   *)*(saved_argv + 0), (char * const  *)saved_argv);
#line 183
  tmp = __errno_location();
#line 183
  tmp___0 = strerror(*tmp);
#line 183
  log("RESTART FAILED: av0=\'%s\', error: %s.", av0, tmp___0);
#line 184
  exit(1);
}
}
#line 192 "sshd.c"
void sigterm_handler(int sig ) 
{ 

  {
#line 195
  log("Received signal %d; terminating.", sig);
#line 196
  close_listen_socks();
#line 197
  unlink((char const   *)options.pid_file);
#line 198
  exit(255);
}
}
#line 205 "sshd.c"
void main_sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  int status ;
  __pid_t tmp___0 ;
  int *tmp___1 ;

  {
#line 208
  tmp = __errno_location();
#line 208
  save_errno = *tmp;
#line 211
  while (1) {
#line 211
    tmp___0 = waitpid(-1, & status, 1);
#line 211
    if (! (tmp___0 > 0)) {
#line 211
      break;
    }
  }
#line 214
  signal(17, & main_sigchld_handler);
#line 215
  tmp___1 = __errno_location();
#line 215
  *tmp___1 = save_errno;
#line 216
  return;
}
}
#line 221 "sshd.c"
void grace_alarm_handler(int sig ) 
{ char const   *tmp ;

  {
#line 225
  packet_close();
#line 228
  tmp = get_remote_ipaddr();
#line 228
  fatal("Timeout before authentication for %s.", tmp);
#line 229
  return;
}
}
#line 239 "sshd.c"
void key_regeneration_alarm(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 242
  tmp = __errno_location();
#line 242
  save_errno = *tmp;
#line 245
  if (key_used) {
#line 247
    log("Generating new %d bit RSA key.", options.server_key_bits);
#line 249
    if ((unsigned int )sensitive_data.private_key != (unsigned int )((void *)0)) {
#line 250
      RSA_free(sensitive_data.private_key);
    }
#line 251
    sensitive_data.private_key = RSA_new();
#line 253
    if ((unsigned int )public_key != (unsigned int )((void *)0)) {
#line 254
      RSA_free(public_key);
    }
#line 255
    public_key = RSA_new();
#line 257
    rsa_generate_key(sensitive_data.private_key, public_key, (unsigned int )options.server_key_bits);
#line 259
    arc4random_stir();
#line 260
    key_used = 0;
#line 261
    log("RSA key generation complete.");
  }
#line 264
  signal(14, & key_regeneration_alarm);
#line 265
  alarm((unsigned int )options.key_regeneration_time);
#line 266
  tmp___0 = __errno_location();
#line 266
  *tmp___0 = save_errno;
#line 267
  return;
}
}
#line 269 "sshd.c"
void sshd_exchange_identification(int sock_in , int sock_out ) 
{ int i ;
  int mismatch ;
  int remote_major ;
  int remote_minor ;
  int major ;
  int minor ;
  char *s ;
  char buf___1[256] ;
  char remote_version[256] ;
  char const   *tmp ;
  size_t tmp___0 ;
  ssize_t tmp___1 ;
  size_t tmp___2 ;
  char const   *tmp___3 ;
  ssize_t tmp___4 ;
  size_t tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  char const   *tmp___9 ;

  {
#line 279
  if (options.protocol & 1) {
#line 279
    if (options.protocol & 4) {
#line 281
      major = 1;
#line 282
      minor = 99;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 283
    if (options.protocol & 4) {
#line 284
      major = 2;
#line 285
      minor = 0;
    } else {
#line 287
      major = 1;
#line 288
      minor = 5;
    }
  }
#line 290
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"SSH-%d.%d-%.100s\n",
           major, minor, "OpenSSH_2.2.0p1");
#line 291
  server_version_string = xstrdup((char const   *)(buf___1));
#line 293
  if ((unsigned int )client_version_string == (unsigned int )((void *)0)) {
#line 295
    tmp___0 = strlen((char const   *)server_version_string);
#line 295
    tmp___1 = atomicio((ssize_t (*)())(& write), sock_out, (void *)server_version_string,
                       tmp___0);
#line 295
    tmp___2 = strlen((char const   *)server_version_string);
#line 295
    if ((size_t )tmp___1 != tmp___2) {
#line 297
      tmp = get_remote_ipaddr();
#line 297
      log("Could not write ident string to %s.", tmp);
#line 298
      fatal_cleanup();
    }
#line 302
    i = 0;
#line 302
    while ((unsigned int )i < sizeof(buf___1) - 1U) {
#line 303
      tmp___4 = atomicio((ssize_t (*)())(& read), sock_in, (void *)(& buf___1[i]),
                         1U);
#line 303
      if (tmp___4 != 1) {
#line 304
        tmp___3 = get_remote_ipaddr();
#line 304
        log("Did not receive ident string from %s.", tmp___3);
#line 305
        fatal_cleanup();
      }
#line 307
      if ((int )buf___1[i] == 13) {
#line 308
        buf___1[i] = (char )'\n';
#line 309
        buf___1[i + 1] = (char)0;
        goto __Cont;
      }
#line 312
      if ((int )buf___1[i] == 10) {
#line 314
        buf___1[i + 1] = (char)0;
#line 315
        break;
      }
      __Cont: /* CIL Label */ 
#line 302
      i ++;
    }
#line 318
    buf___1[sizeof(buf___1) - 1U] = (char)0;
#line 319
    client_version_string = xstrdup((char const   *)(buf___1));
  }
#line 326
  tmp___7 = sscanf((char const   * __restrict  )client_version_string, (char const   * __restrict  )"SSH-%d.%d-%[^\n]\n",
                   & remote_major, & remote_minor, remote_version);
#line 326
  if (tmp___7 != 3) {
#line 328
    s = (char *)"Protocol mismatch.\n";
#line 329
    tmp___5 = strlen((char const   *)s);
#line 329
    atomicio((ssize_t (*)())(& write), sock_out, (void *)s, tmp___5);
#line 330
    close(sock_in);
#line 331
    close(sock_out);
#line 332
    tmp___6 = get_remote_ipaddr();
#line 332
    log("Bad protocol version identification \'%.100s\' from %s", client_version_string,
        tmp___6);
#line 334
    fatal_cleanup();
  }
#line 336
  debug("Client protocol version %d.%d; client software version %.100s", remote_major,
        remote_minor, remote_version);
#line 339
  compat_datafellows((char const   *)(remote_version));
#line 341
  mismatch = 0;
#line 342
  switch (remote_major) {
  case 1: 
#line 344
  if (remote_minor == 99) {
#line 345
    if (options.protocol & 4) {
#line 346
      enable_compat20();
    } else {
#line 348
      mismatch = 1;
    }
#line 349
    break;
  }
#line 351
  if (! (options.protocol & 1)) {
#line 352
    mismatch = 1;
#line 353
    break;
  }
#line 355
  if (remote_minor < 3) {
#line 356
    packet_disconnect("Your ssh version is too old and is no longer supported.  Please install a newer version.");
  } else {
#line 358
    if (remote_minor == 3) {
#line 360
      enable_compat13();
    }
  }
#line 362
  break;
  case 2: 
#line 364
  if (options.protocol & 4) {
#line 365
    enable_compat20();
#line 366
    break;
  }
  default: 
#line 370
  mismatch = 1;
#line 371
  break;
  }
#line 373
  chop(server_version_string);
#line 374
  chop(client_version_string);
#line 375
  debug("Local version string %.200s", server_version_string);
#line 377
  if (mismatch) {
#line 378
    s = (char *)"Protocol major versions differ.\n";
#line 379
    tmp___8 = strlen((char const   *)s);
#line 379
    atomicio((ssize_t (*)())(& write), sock_out, (void *)s, tmp___8);
#line 380
    close(sock_in);
#line 381
    close(sock_out);
#line 382
    tmp___9 = get_remote_ipaddr();
#line 382
    log("Protocol major versions differ for %s: %.200s vs. %.200s", tmp___9, server_version_string,
        client_version_string);
#line 385
    fatal_cleanup();
  }
#line 387
  if (compat20) {
#line 388
    packet_set_ssh2_format();
  }
#line 389
  return;
}
}
#line 392 "sshd.c"
void destroy_sensitive_data(void) 
{ 

  {
#line 396
  if (public_key) {
#line 397
    RSA_free(public_key);
  }
#line 398
  if (sensitive_data.private_key) {
#line 399
    RSA_free(sensitive_data.private_key);
  }
#line 400
  if (sensitive_data.host_key) {
#line 401
    RSA_free(sensitive_data.host_key);
  }
#line 402
  if ((unsigned int )sensitive_data.dsa_host_key != (unsigned int )((void *)0)) {
#line 403
    key_free(sensitive_data.dsa_host_key);
  }
#line 404
  return;
}
}
#line 412 "sshd.c"
int drop_connection(int startups ) 
{ double p ;
  double r ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 417
  if (startups < options.max_startups_begin) {
#line 418
    return (0);
  }
#line 419
  if (startups >= options.max_startups) {
#line 420
    return (1);
  }
#line 421
  if (options.max_startups_rate == 100) {
#line 422
    return (1);
  }
#line 424
  p = (double )(100 - options.max_startups_rate);
#line 425
  p *= (double )(startups - options.max_startups_begin);
#line 426
  p /= (double )(options.max_startups - options.max_startups_begin);
#line 427
  p += (double )options.max_startups_rate;
#line 428
  p /= 100.0;
#line 429
  tmp = arc4random();
#line 429
  r = (double )tmp / (double )4294967295U;
#line 431
  debug("drop_connection: p %g, r %g", p, r);
#line 432
  if (r < p) {
#line 432
    tmp___0 = 1;
  } else {
#line 432
    tmp___0 = 0;
  }
#line 432
  return (tmp___0);
}
}
#line 435 "sshd.c"
int *startup_pipes  =    (int *)((void *)0);
#line 436 "sshd.c"
int startup_pipe  ;
#line 441 "sshd.c"
int main(int ac , char **av ) 
{ int opt ;
  int sock_in ;
  int sock_out ;
  int newsock ;
  int j ;
  int i ;
  int fdsetsz ;
  int on ;
  pid_t pid ;
  socklen_t fromlen ;
  int silent ;
  fd_set *fdset ;
  struct sockaddr_storage from ;
  char const   *remote_ip ;
  int remote_port ;
  FILE *f ;
  struct linger linger ;
  struct addrinfo *ai ;
  char ntop[1025] ;
  char strport[32] ;
  int listen_sock ;
  int maxfd ;
  int startup_p[2] ;
  int startups ;
  char *tmp ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  Key k ;
  int *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int fd ;
  int *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  int s1 ;
  int s2 ;
  int tmp___20 ;
  int *tmp___21 ;
  char *tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  int *tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  int *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  __pid_t tmp___32 ;
  void *tmp___33 ;
  void *tmp___34 ;
  int *tmp___35 ;
  char *tmp___36 ;
  int *tmp___37 ;
  int tmp___38 ;
  register char __result ;
  register char __result___0 ;
  int *tmp___39 ;
  char *tmp___40 ;
  int *tmp___41 ;
  int *tmp___42 ;
  int *tmp___43 ;
  char *tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int *tmp___48 ;
  char *tmp___49 ;

  {
#line 446
  sock_in = 0;
#line 446
  sock_out = 0;
#line 446
  on = 1;
#line 449
  silent = 0;
#line 460
  startups = 0;
#line 462
  init_rng();
#line 465
  saved_argc = ac;
#line 466
  saved_argv = av;
#line 467
  tmp___1 = __builtin_strchr(*(av + 0), '/');
#line 467
  if (tmp___1) {
#line 468
    tmp = strrchr((char const   *)*(av + 0), '/');
#line 468
    av0 = tmp + 1;
  } else {
#line 470
    av0 = *(av + 0);
  }
#line 473
  initialize_server_options(& options);
#line 476
  while (1) {
#line 476
    opt = getopt(ac, (char * const  *)av, "f:p:b:k:h:g:V:u:diqQ46");
#line 476
    if (! (opt != -1)) {
#line 476
      break;
    }
#line 477
    switch (opt) {
    case 52: 
#line 479
    IPv4or6 = 2;
#line 480
    break;
    case 54: 
#line 482
    IPv4or6 = 10;
#line 483
    break;
    case 102: 
#line 485
    config_file_name = optarg;
#line 486
    break;
    case 100: 
#line 488
    debug_flag = 1;
#line 489
    options.log_level = 5;
#line 490
    break;
    case 105: 
#line 492
    inetd_flag = 1;
#line 493
    break;
    case 81: 
#line 495
    silent = 1;
#line 496
    break;
    case 113: 
#line 498
    options.log_level = 0;
#line 499
    break;
    case 98: 
#line 501
    options.server_key_bits = atoi((char const   *)optarg);
#line 502
    break;
    case 112: 
#line 504
    options.ports_from_cmdline = 1U;
#line 505
    if (options.num_ports >= 256U) {
#line 506
      fatal("too many ports.\n");
    }
#line 507
    tmp___2 = options.num_ports;
#line 507
    (options.num_ports) ++;
#line 507
    tmp___3 = atoi((char const   *)optarg);
#line 507
    options.ports[tmp___2] = (unsigned short )tmp___3;
#line 508
    break;
    case 103: 
#line 510
    options.login_grace_time = atoi((char const   *)optarg);
#line 511
    break;
    case 107: 
#line 513
    options.key_regeneration_time = atoi((char const   *)optarg);
#line 514
    break;
    case 104: 
#line 516
    options.host_key_file = optarg;
#line 517
    break;
    case 86: 
#line 519
    client_version_string = optarg;
#line 521
    inetd_flag = 1;
#line 522
    break;
    case 117: 
#line 524
    tmp___4 = atoi((char const   *)optarg);
#line 524
    utmp_len = (unsigned int )tmp___4;
#line 525
    break;
    case 63: 
    default: 
#line 528
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"sshd version %s\n",
            "OpenSSH_2.2.0p1");
#line 529
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: %s [options]\n",
            av0);
#line 530
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Options:\n");
#line 531
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -f file    Configuration file (default %s)\n",
            "/usr/local/etc/sshd_config");
#line 532
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -d         Debugging mode\n");
#line 533
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -i         Started from inetd\n");
#line 534
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -q         Quiet (no logging)\n");
#line 535
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -p port    Listen on the specified port (default: 22)\n");
#line 536
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -k seconds Regenerate server key every this many seconds (default: 3600)\n");
#line 537
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -g seconds Grace period for authentication (default: 300)\n");
#line 538
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -b bits    Size of server RSA key (default: 768 bits)\n");
#line 539
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -h file    File from which to read host key (default: %s)\n",
            "/usr/local/etc/ssh_host_key");
#line 541
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -u len     Maximum hostname length for utmp recording\n");
#line 542
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -4         Use IPv4 only\n");
#line 543
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -6         Use IPv6 only\n");
#line 544
    exit(1);
    }
  }
#line 552
  if (! silent) {
#line 552
    if (! inetd_flag) {
#line 552
      tmp___5 = 1;
    } else {
#line 552
      tmp___5 = 0;
    }
  } else {
#line 552
    tmp___5 = 0;
  }
#line 552
  if ((int )options.log_facility == -1) {
#line 552
    tmp___6 = 2;
  } else {
#line 552
    tmp___6 = (int )options.log_facility;
  }
#line 552
  if ((int )options.log_level == -1) {
#line 552
    tmp___7 = 3;
  } else {
#line 552
    tmp___7 = (int )options.log_level;
  }
#line 552
  log_init(av0, (enum __anonenum_LogLevel_73 )tmp___7, (enum __anonenum_SyslogFacility_72 )tmp___6,
           tmp___5);
#line 558
  read_server_config(& options, (char const   *)config_file_name);
#line 561
  fill_default_server_options(& options);
#line 564
  if (optind < ac) {
#line 565
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Extra argument %s.\n",
            *(av + optind));
#line 566
    exit(1);
  }
#line 569
  debug("sshd version %.100s", "OpenSSH_2.2.0p1");
#line 571
  sensitive_data.dsa_host_key = (Key *)((void *)0);
#line 572
  sensitive_data.host_key = (RSA *)((void *)0);
#line 575
  if (options.protocol & 1) {
#line 575
    tmp___8 = rsa_alive();
#line 575
    if (tmp___8 == 0) {
#line 577
      log("no RSA support in libssl and libcrypto.  See ssl(8)");
#line 578
      log("Disabling protocol version 1");
#line 579
      options.protocol &= -2;
    }
  }
#line 582
  if (options.protocol & 1) {
#line 584
    sensitive_data.host_key = RSA_new();
#line 585
    k.type = 0;
#line 586
    k.rsa = sensitive_data.host_key;
#line 587
    tmp___9 = __errno_location();
#line 587
    *tmp___9 = 0;
#line 588
    tmp___12 = load_private_key((char const   *)options.host_key_file, "", & k, (char **)((void *)0));
#line 588
    if (! tmp___12) {
#line 589
      tmp___10 = __errno_location();
#line 589
      tmp___11 = strerror(*tmp___10);
#line 589
      error("Could not load host key: %.200s: %.100s", options.host_key_file, tmp___11);
#line 591
      log("Disabling protocol version 1");
#line 592
      options.protocol &= -2;
    }
#line 594
    k.rsa = (RSA *)((void *)0);
  }
#line 596
  if (options.protocol & 4) {
#line 597
    sensitive_data.dsa_host_key = key_new(1);
#line 598
    tmp___13 = load_private_key((char const   *)options.host_dsa_key_file, "", sensitive_data.dsa_host_key,
                                (char **)((void *)0));
#line 598
    if (! tmp___13) {
#line 600
      error("Could not load DSA host key: %.200s", options.host_dsa_key_file);
#line 601
      log("Disabling protocol version 2");
#line 602
      options.protocol &= -5;
    }
  }
#line 605
  if (! options.protocol & 5) {
#line 606
    if (silent == 0) {
#line 607
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"sshd: no hostkeys available -- exiting.\n");
    }
#line 608
    log("sshd: no hostkeys available -- exiting.\n");
#line 609
    exit(1);
  }
#line 613
  if (options.protocol & 1) {
#line 614
    if (options.server_key_bits < 512) {
#line 616
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 617
      exit(1);
    } else {
#line 614
      if (options.server_key_bits > 32768) {
#line 616
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 617
        exit(1);
      }
    }
#line 624
    tmp___15 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 624
    if (options.server_key_bits > tmp___15 - 128) {
#line 624
      tmp___16 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 624
      if (options.server_key_bits < tmp___16 + 128) {
#line 628
        tmp___14 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 628
        options.server_key_bits = tmp___14 + 128;
#line 630
        debug("Forcing server key to %d bits to make it differ from host key.", options.server_key_bits);
      }
    }
  }
#line 636
  if (debug_flag) {
#line 636
    if (! inetd_flag) {
#line 637
      log_stderr = 1;
    }
  }
#line 638
  log_init(av0, options.log_level, options.log_facility, log_stderr);
#line 645
  if (! debug_flag) {
#line 645
    if (! inetd_flag) {
#line 649
      tmp___19 = daemon(0, 0);
#line 649
      if (tmp___19 < 0) {
#line 650
        tmp___17 = __errno_location();
#line 650
        tmp___18 = strerror(*tmp___17);
#line 650
        fatal("daemon() failed: %.200s", tmp___18);
      }
#line 654
      fd = open("/dev/tty", 258);
#line 655
      if (fd >= 0) {
#line 656
        ioctl(fd, 21538UL, (void *)0);
#line 657
        close(fd);
      }
    }
  }
#line 662
  log_init(av0, options.log_level, options.log_facility, log_stderr);
#line 665
  rsa_set_verbose(0);
#line 668
  arc4random_stir();
#line 672
  chdir("/");
#line 675
  if (inetd_flag) {
#line 677
    s1 = dup(0);
#line 678
    s2 = dup(s1);
#line 679
    sock_in = dup(0);
#line 680
    sock_out = dup(1);
#line 681
    startup_pipe = -1;
#line 687
    debug("inetd sockets after dupping: %d, %d", sock_in, sock_out);
#line 689
    if (options.protocol & 1) {
#line 690
      public_key = RSA_new();
#line 691
      sensitive_data.private_key = RSA_new();
#line 692
      log("Generating %d bit RSA key.", options.server_key_bits);
#line 693
      rsa_generate_key(sensitive_data.private_key, public_key, (unsigned int )options.server_key_bits);
#line 695
      arc4random_stir();
#line 696
      log("RSA key generation complete.");
    }
  } else {
#line 699
    ai = options.listen_addrs;
#line 699
    while (ai) {
#line 700
      if (ai->ai_family != 2) {
#line 700
        if (ai->ai_family != 10) {
          goto __Cont;
        }
      }
#line 702
      if (num_listen_socks >= 16) {
#line 703
        fatal("Too many listen sockets. Enlarge MAX_LISTEN_SOCKS");
      }
#line 705
      tmp___20 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr,
                             ai->ai_addrlen, (char * __restrict  )(ntop), sizeof(ntop),
                             (char * __restrict  )(strport), sizeof(strport), 3U);
#line 705
      if (tmp___20 != 0) {
#line 708
        error("getnameinfo failed");
        goto __Cont;
      }
#line 712
      listen_sock = socket(ai->ai_family, 1, 0);
#line 713
      if (listen_sock < 0) {
#line 715
        tmp___21 = __errno_location();
#line 715
        tmp___22 = strerror(*tmp___21);
#line 715
        verbose("socket: %.100s", tmp___22);
        goto __Cont;
      }
#line 718
      tmp___25 = fcntl(listen_sock, 4, 2048);
#line 718
      if (tmp___25 < 0) {
#line 719
        tmp___23 = __errno_location();
#line 719
        tmp___24 = strerror(*tmp___23);
#line 719
        error("listen_sock O_NONBLOCK: %s", tmp___24);
#line 720
        close(listen_sock);
        goto __Cont;
      }
#line 729
      setsockopt(listen_sock, 1, 2, (void const   *)((void *)(& on)), sizeof(on));
#line 731
      linger.l_onoff = 1;
#line 732
      linger.l_linger = 5;
#line 733
      setsockopt(listen_sock, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 736
      debug("Bind to port %s on %s.", strport, ntop);
#line 739
      tmp___28 = bind(listen_sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 739
      if (tmp___28 < 0) {
#line 739
        if (! ai->ai_next) {
#line 741
          tmp___26 = __errno_location();
#line 741
          tmp___27 = strerror(*tmp___26);
#line 741
          error("Bind to port %s on %s failed: %.200s.", strport, ntop, tmp___27);
#line 743
          close(listen_sock);
          goto __Cont;
        }
      }
#line 746
      listen_socks[num_listen_socks] = listen_sock;
#line 747
      num_listen_socks ++;
#line 750
      log("Server listening on %s port %s.", ntop, strport);
#line 751
      tmp___31 = listen(listen_sock, 5);
#line 751
      if (tmp___31 < 0) {
#line 752
        tmp___29 = __errno_location();
#line 752
        tmp___30 = strerror(*tmp___29);
#line 752
        fatal("listen: %.100s", tmp___30);
      }
      __Cont: /* CIL Label */ 
#line 699
      ai = ai->ai_next;
    }
#line 755
    freeaddrinfo(options.listen_addrs);
#line 757
    if (! num_listen_socks) {
#line 758
      fatal("Cannot bind any address.");
    }
#line 760
    if (! debug_flag) {
#line 768
      f = fopen((char const   * __restrict  )options.pid_file, (char const   * __restrict  )"w");
#line 769
      if (f) {
#line 770
        tmp___32 = getpid();
#line 770
        fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%u\n", (unsigned int )tmp___32);
#line 771
        fclose(f);
      }
    }
#line 774
    if (options.protocol & 1) {
#line 775
      public_key = RSA_new();
#line 776
      sensitive_data.private_key = RSA_new();
#line 778
      log("Generating %d bit RSA key.", options.server_key_bits);
#line 779
      rsa_generate_key(sensitive_data.private_key, public_key, (unsigned int )options.server_key_bits);
#line 781
      arc4random_stir();
#line 782
      log("RSA key generation complete.");
#line 785
      signal(14, & key_regeneration_alarm);
#line 786
      alarm((unsigned int )options.key_regeneration_time);
    }
#line 790
    signal(1, & sighup_handler);
#line 792
    signal(15, & sigterm_handler);
#line 793
    signal(3, & sigterm_handler);
#line 796
    signal(17, & main_sigchld_handler);
#line 799
    fdset = (fd_set *)((void *)0);
#line 800
    maxfd = 0;
#line 801
    i = 0;
#line 801
    while (i < num_listen_socks) {
#line 802
      if (listen_socks[i] > maxfd) {
#line 803
        maxfd = listen_socks[i];
      }
#line 801
      i ++;
    }
#line 805
    tmp___33 = xmalloc((unsigned int )options.max_startups * sizeof(int ));
#line 805
    startup_pipes = (int *)tmp___33;
#line 806
    i = 0;
#line 806
    while (i < options.max_startups) {
#line 807
      *(startup_pipes + i) = -1;
#line 806
      i ++;
    }
#line 813
    while (1) {
#line 814
      if (received_sighup) {
#line 815
        sighup_restart();
      }
#line 816
      if ((unsigned int )fdset != (unsigned int )((void *)0)) {
#line 817
        xfree((void *)fdset);
      }
#line 818
      fdsetsz = (int )((((unsigned int )maxfd + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 819
      tmp___34 = xmalloc((unsigned int )fdsetsz);
#line 819
      fdset = (fd_set *)tmp___34;
#line 820
      memset((void *)fdset, 0, (unsigned int )fdsetsz);
#line 822
      i = 0;
#line 822
      while (i < num_listen_socks) {
#line 823
        __asm__  volatile   ("btsl %1,%0": "=m" (fdset->__fds_bits[(unsigned int )listen_socks[i] / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )listen_socks[i] % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
#line 822
        i ++;
      }
#line 824
      i = 0;
#line 824
      while (i < options.max_startups) {
#line 825
        if (*(startup_pipes + i) != -1) {
#line 826
          __asm__  volatile   ("btsl %1,%0": "=m" (fdset->__fds_bits[(unsigned int )*(startup_pipes + i) / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )*(startup_pipes + i) % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        }
#line 824
        i ++;
      }
#line 829
      tmp___38 = select(maxfd + 1, (fd_set * __restrict  )fdset, (fd_set * __restrict  )((void *)0),
                        (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 829
      if (tmp___38 < 0) {
#line 830
        tmp___37 = __errno_location();
#line 830
        if (*tmp___37 != 4) {
#line 831
          tmp___35 = __errno_location();
#line 831
          tmp___36 = strerror(*tmp___35);
#line 831
          error("select: %.100s", tmp___36);
        }
        goto __Cont___0;
      }
#line 834
      i = 0;
#line 834
      while (i < options.max_startups) {
#line 836
        if (*(startup_pipes + i) != -1) {
#line 836
          __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )*(startup_pipes + i) % (8U * sizeof(__fd_mask ))),
                               "m" (fdset->__fds_bits[(unsigned int )*(startup_pipes + i) / (8U * sizeof(__fd_mask ))]): "cc");
#line 836
          if (__result) {
#line 843
            close(*(startup_pipes + i));
#line 844
            *(startup_pipes + i) = -1;
#line 845
            startups --;
          }
        }
#line 834
        i ++;
      }
#line 847
      i = 0;
#line 847
      while (i < num_listen_socks) {
#line 848
        __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )listen_socks[i] % (8U * sizeof(__fd_mask ))),
                             "m" (fdset->__fds_bits[(unsigned int )listen_socks[i] / (8U * sizeof(__fd_mask ))]): "cc");
#line 848
        if (! __result___0) {
          goto __Cont___1;
        }
#line 850
        fromlen = sizeof(from);
#line 851
        newsock = accept(listen_socks[i], (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                         (socklen_t * __restrict  )(& fromlen));
#line 853
        if (newsock < 0) {
#line 854
          tmp___41 = __errno_location();
#line 854
          if (*tmp___41 != 4) {
#line 854
            tmp___42 = __errno_location();
#line 854
            if (*tmp___42 != 11) {
#line 855
              tmp___39 = __errno_location();
#line 855
              tmp___40 = strerror(*tmp___39);
#line 855
              error("accept: %.100s", tmp___40);
            }
          }
          goto __Cont___1;
        }
#line 858
        tmp___45 = fcntl(newsock, 4, 0);
#line 858
        if (tmp___45 < 0) {
#line 859
          tmp___43 = __errno_location();
#line 859
          tmp___44 = strerror(*tmp___43);
#line 859
          error("newsock del O_NONBLOCK: %s", tmp___44);
          goto __Cont___1;
        }
#line 862
        tmp___46 = drop_connection(startups);
#line 862
        if (tmp___46 == 1) {
#line 863
          debug("drop connection #%d", startups);
#line 864
          close(newsock);
          goto __Cont___1;
        }
#line 867
        tmp___47 = pipe((int *)(startup_p));
#line 867
        if (tmp___47 == -1) {
#line 868
          close(newsock);
          goto __Cont___1;
        }
#line 872
        j = 0;
#line 872
        while (j < options.max_startups) {
#line 873
          if (*(startup_pipes + j) == -1) {
#line 874
            *(startup_pipes + j) = startup_p[0];
#line 875
            if (maxfd < startup_p[0]) {
#line 876
              maxfd = startup_p[0];
            }
#line 877
            startups ++;
#line 878
            break;
          }
#line 872
          j ++;
        }
#line 885
        if (debug_flag) {
#line 891
          debug("Server will not fork when running in debugging mode.");
#line 892
          close_listen_socks();
#line 893
          sock_in = newsock;
#line 894
          sock_out = newsock;
#line 895
          startup_pipe = -1;
#line 896
          pid = getpid();
#line 897
          break;
        } else {
#line 904
          pid = fork();
#line 904
          if (pid == 0) {
#line 912
            startup_pipe = startup_p[1];
#line 913
            j = 0;
#line 913
            while (j < options.max_startups) {
#line 914
              if (*(startup_pipes + j) != -1) {
#line 915
                close(*(startup_pipes + j));
              }
#line 913
              j ++;
            }
#line 916
            close_listen_socks();
#line 917
            sock_in = newsock;
#line 918
            sock_out = newsock;
#line 919
            log_init(av0, options.log_level, options.log_facility, log_stderr);
#line 920
            break;
          }
        }
#line 925
        if (pid < 0) {
#line 926
          tmp___48 = __errno_location();
#line 926
          tmp___49 = strerror(*tmp___48);
#line 926
          error("fork: %.100s", tmp___49);
        } else {
#line 928
          debug("Forked child %d.", pid);
        }
#line 930
        close(startup_p[1]);
#line 933
        key_used = 1;
#line 935
        arc4random_stir();
#line 938
        close(newsock);
        __Cont___1: /* CIL Label */ 
#line 847
        i ++;
      }
#line 941
      if (num_listen_socks < 0) {
#line 942
        break;
      }
      __Cont___0: /* CIL Label */ ;
    }
  }
#line 953
  alarm(0U);
#line 954
  signal(14, (void (*)(int  ))0);
#line 955
  signal(1, (void (*)(int  ))0);
#line 956
  signal(15, (void (*)(int  ))0);
#line 957
  signal(3, (void (*)(int  ))0);
#line 958
  signal(17, (void (*)(int  ))0);
#line 959
  signal(2, (void (*)(int  ))0);
#line 967
  linger.l_onoff = 1;
#line 968
  linger.l_linger = 5;
#line 969
  setsockopt(sock_in, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 975
  packet_set_connection(sock_in, sock_out);
#line 977
  remote_port = get_remote_port();
#line 978
  remote_ip = get_remote_ipaddr();
#line 998
  verbose("Connection from %.500s port %d", remote_ip, remote_port);
#line 1008
  signal(14, & grace_alarm_handler);
#line 1009
  if (! debug_flag) {
#line 1010
    alarm((unsigned int )options.login_grace_time);
  }
#line 1012
  sshd_exchange_identification(sock_in, sock_out);
#line 1020
  if (remote_port >= 1024) {
#line 1022
    options.rhosts_authentication = 0;
#line 1023
    options.rhosts_rsa_authentication = 0;
  } else {
#line 1020
    if (remote_port < 512) {
#line 1022
      options.rhosts_authentication = 0;
#line 1023
      options.rhosts_rsa_authentication = 0;
    }
  }
#line 1033
  packet_set_nonblocking();
#line 1037
  if (compat20) {
#line 1038
    do_ssh2_kex();
#line 1039
    do_authentication2();
  } else {
#line 1041
    do_ssh1_kex();
#line 1042
    do_authentication();
  }
#line 1052
  verbose("Closing connection to %.100s", remote_ip);
#line 1055
  finish_pam();
#line 1058
  packet_close();
#line 1059
  exit(0);
}
}
#line 1065 "sshd.c"
void do_ssh1_kex(void) 
{ int i ;
  int len ;
  int plen ;
  int slen ;
  BIGNUM *session_key_int ;
  unsigned char session_key[32] ;
  unsigned char cookie[8] ;
  unsigned int cipher_type___0 ;
  unsigned int auth_mask ;
  unsigned int protocol_flags ;
  u_int32_t rand___0 ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  char const   *tmp___6 ;
  int _p ;
  int _e ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char const   *tmp___19 ;

  {
#line 1074
  rand___0 = (u_int32_t )0;
#line 1085
  i = 0;
#line 1085
  while (i < 8) {
#line 1086
    if (i % 4 == 0) {
#line 1087
      rand___0 = arc4random();
    }
#line 1088
    cookie[i] = (unsigned char )(rand___0 & 255U);
#line 1089
    rand___0 >>= 8;
#line 1085
    i ++;
  }
#line 1097
  packet_start(2);
#line 1098
  i = 0;
#line 1098
  while (i < 8) {
#line 1099
    packet_put_char((int )cookie[i]);
#line 1098
    i ++;
  }
#line 1102
  tmp = BN_num_bits((BIGNUM const   *)public_key->n);
#line 1102
  packet_put_int((unsigned int )tmp);
#line 1103
  packet_put_bignum(public_key->e);
#line 1104
  packet_put_bignum(public_key->n);
#line 1107
  tmp___0 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1107
  packet_put_int((unsigned int )tmp___0);
#line 1108
  packet_put_bignum((sensitive_data.host_key)->e);
#line 1109
  packet_put_bignum((sensitive_data.host_key)->n);
#line 1112
  packet_put_int(2U);
#line 1115
  tmp___1 = cipher_mask1();
#line 1115
  packet_put_int(tmp___1);
#line 1118
  auth_mask = 0U;
#line 1119
  if (options.rhosts_authentication) {
#line 1120
    auth_mask |= (unsigned int )(1 << 1);
  }
#line 1121
  if (options.rhosts_rsa_authentication) {
#line 1122
    auth_mask |= (unsigned int )(1 << 4);
  }
#line 1123
  if (options.rsa_authentication) {
#line 1124
    auth_mask |= (unsigned int )(1 << 2);
  }
#line 1139
  if (options.password_authentication) {
#line 1140
    auth_mask |= (unsigned int )(1 << 3);
  }
#line 1141
  packet_put_int(auth_mask);
#line 1144
  packet_send();
#line 1145
  packet_write_wait();
#line 1147
  tmp___2 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1147
  tmp___3 = BN_num_bits((BIGNUM const   *)public_key->n);
#line 1147
  debug("Sent %d bit public key and %d bit host key.", tmp___3, tmp___2);
#line 1151
  packet_read_expect(& plen, 3);
#line 1154
  cipher_type___0 = packet_get_char();
#line 1156
  tmp___4 = cipher_mask();
#line 1156
  if (! (tmp___4 & (unsigned int )(1 << cipher_type___0))) {
#line 1157
    packet_disconnect("Warning: client selects unsupported cipher.");
  }
#line 1161
  i = 0;
#line 1161
  while (i < 8) {
#line 1162
    tmp___5 = packet_get_char();
#line 1162
    if ((unsigned int )cookie[i] != tmp___5) {
#line 1163
      packet_disconnect("IP Spoofing check bytes do not match.");
    }
#line 1161
    i ++;
  }
#line 1165
  tmp___6 = cipher_name((int )cipher_type___0);
#line 1165
  debug("Encryption type: %.200s", tmp___6);
#line 1168
  session_key_int = BN_new();
#line 1169
  packet_get_bignum(session_key_int, & slen);
#line 1171
  protocol_flags = packet_get_int();
#line 1172
  packet_set_protocol_flags(protocol_flags);
#line 1174
  while (1) {
#line 1174
    _p = plen;
#line 1174
    _e = (9 + slen) + 4;
#line 1174
    if (_p != _e) {
#line 1174
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "sshd.c", 1174);
#line 1174
      packet_disconnect("Packet integrity error. (%d)", 3);
    }
#line 1174
    break;
  }
#line 1180
  tmp___17 = BN_cmp((BIGNUM const   *)(sensitive_data.private_key)->n, (BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1180
  if (tmp___17 > 0) {
#line 1182
    tmp___10 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 1182
    tmp___11 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1182
    if (tmp___10 < tmp___11 + 128) {
#line 1184
      tmp___7 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1184
      tmp___8 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 1184
      tmp___9 = get_remote_ipaddr();
#line 1184
      fatal("do_connection: %s: private_key %d < host_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___9, tmp___8, tmp___7, 128);
    }
#line 1190
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.private_key);
#line 1192
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.host_key);
  } else {
#line 1196
    tmp___15 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1196
    tmp___16 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 1196
    if (tmp___15 < tmp___16 + 128) {
#line 1198
      tmp___12 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 1198
      tmp___13 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1198
      tmp___14 = get_remote_ipaddr();
#line 1198
      fatal("do_connection: %s: host_key %d < private_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___14, tmp___13, tmp___12, 128);
    }
#line 1204
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.host_key);
#line 1206
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.private_key);
  }
#line 1210
  compute_session_id((unsigned char *)(session_id), (unsigned char *)(cookie), (sensitive_data.host_key)->n,
                     (sensitive_data.private_key)->n);
#line 1215
  destroy_sensitive_data();
#line 1222
  BN_mask_bits(session_key_int, (int )(sizeof(session_key) * 8U));
#line 1223
  tmp___18 = BN_num_bits((BIGNUM const   *)session_key_int);
#line 1223
  len = (tmp___18 + 7) / 8;
#line 1224
  if (len < 0) {
#line 1225
    tmp___19 = get_remote_ipaddr();
#line 1225
    fatal("do_connection: bad len from %s: session_key_int %d > sizeof(session_key) %d",
          tmp___19, len, sizeof(session_key));
  } else {
#line 1224
    if ((unsigned int )len > sizeof(session_key)) {
#line 1225
      tmp___19 = get_remote_ipaddr();
#line 1225
      fatal("do_connection: bad len from %s: session_key_int %d > sizeof(session_key) %d",
            tmp___19, len, sizeof(session_key));
    }
  }
#line 1228
  memset((void *)(session_key), 0, sizeof(session_key));
#line 1229
  BN_bn2bin((BIGNUM const   *)session_key_int, (session_key + sizeof(session_key)) - len);
#line 1232
  BN_clear_free(session_key_int);
#line 1235
  i = 0;
#line 1235
  while (i < 16) {
#line 1236
    session_key[i] = (unsigned char )((int )session_key[i] ^ (int )session_id[i]);
#line 1235
    i ++;
  }
#line 1239
  packet_set_encryption_key((unsigned char const   *)(session_key), 32U, (int )cipher_type___0);
#line 1242
  memset((void *)(session_key), 0, sizeof(session_key));
#line 1244
  debug("Received session key; encryption turned on.");
#line 1247
  packet_start(14);
#line 1248
  packet_send();
#line 1249
  packet_write_wait();
#line 1250
  return;
}
}
#line 1255 "sshd.c"
void do_ssh2_kex(void) 
{ Buffer *server_kexinit ;
  Buffer *client_kexinit ;
  int payload_len ;
  int dlen ;
  int slen ;
  unsigned int klen ;
  unsigned int kout ;
  unsigned char *signature ;
  unsigned char *server_host_key_blob ;
  unsigned int sbloblen ;
  DH *dh ;
  BIGNUM *dh_client_pub ;
  BIGNUM *shared_secret ;
  int i ;
  unsigned char *kbuf ;
  unsigned char *hash ;
  Kex *kex___0 ;
  char *cprop[10] ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  char *tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  void *tmp___8 ;

  {
#line 1263
  signature = (unsigned char *)((void *)0);
#line 1264
  server_host_key_blob = (unsigned char *)((void *)0);
#line 1267
  dh_client_pub = (BIGNUM *)0;
#line 1268
  shared_secret = (BIGNUM *)0;
#line 1277
  if ((unsigned int )options.ciphers != (unsigned int )((void *)0)) {
#line 1278
    myproposal[3] = options.ciphers;
#line 1278
    myproposal[2] = myproposal[3];
  }
#line 1281
  server_kexinit = kex_init((char **)(myproposal));
#line 1282
  tmp = xmalloc(sizeof(*client_kexinit));
#line 1282
  client_kexinit = (Buffer *)tmp;
#line 1283
  buffer_init(client_kexinit);
#line 1286
  kex_exchange_kexinit(server_kexinit, client_kexinit, (char **)(cprop));
#line 1287
  kex___0 = kex_choose_conf((char **)(cprop), (char **)(myproposal), 1);
#line 1288
  i = 0;
#line 1288
  while (i < 10) {
#line 1289
    xfree((void *)cprop[i]);
#line 1288
    i ++;
  }
#line 1293
  debug("Wait SSH2_MSG_KEXDH_INIT.");
#line 1294
  packet_read_expect(& payload_len, 30);
#line 1297
  dh_client_pub = BN_new();
#line 1298
  if ((unsigned int )dh_client_pub == (unsigned int )((void *)0)) {
#line 1299
    fatal("dh_client_pub == NULL");
  }
#line 1300
  packet_get_bignum2(dh_client_pub, & dlen);
#line 1310
  dh = dh_new_group1();
#line 1321
  tmp___0 = dh_pub_is_valid(dh, dh_client_pub);
#line 1321
  if (! tmp___0) {
#line 1322
    packet_disconnect("bad client public DH value");
  }
#line 1324
  tmp___1 = DH_size((DH const   *)dh);
#line 1324
  klen = (unsigned int )tmp___1;
#line 1325
  tmp___2 = xmalloc(klen);
#line 1325
  kbuf = (unsigned char *)tmp___2;
#line 1326
  tmp___3 = DH_compute_key(kbuf, (BIGNUM const   *)dh_client_pub, dh);
#line 1326
  kout = (unsigned int )tmp___3;
#line 1335
  shared_secret = BN_new();
#line 1337
  BN_bin2bn((unsigned char const   *)kbuf, (int )kout, shared_secret);
#line 1338
  memset((void *)kbuf, 0, klen);
#line 1339
  xfree((void *)kbuf);
#line 1342
  dsa_make_key_blob(sensitive_data.dsa_host_key, & server_host_key_blob, & sbloblen);
#line 1345
  tmp___4 = buffer_len(server_kexinit);
#line 1345
  tmp___5 = buffer_ptr(server_kexinit);
#line 1345
  tmp___6 = buffer_len(client_kexinit);
#line 1345
  tmp___7 = buffer_ptr(client_kexinit);
#line 1345
  hash = kex_hash(client_version_string, server_version_string, tmp___7, (int )tmp___6,
                  tmp___5, (int )tmp___4, (char *)server_host_key_blob, (int )sbloblen,
                  dh_client_pub, dh->pub_key, shared_secret);
#line 1355
  buffer_free(client_kexinit);
#line 1356
  buffer_free(server_kexinit);
#line 1357
  xfree((void *)client_kexinit);
#line 1358
  xfree((void *)server_kexinit);
#line 1367
  session_id2_len = 20;
#line 1368
  tmp___8 = xmalloc((unsigned int )session_id2_len);
#line 1368
  session_id2 = (unsigned char *)tmp___8;
#line 1369
  memcpy((void * __restrict  )session_id2, (void const   * __restrict  )hash, (unsigned int )session_id2_len);
#line 1373
  dsa_sign(sensitive_data.dsa_host_key, & signature, & slen, hash, 20);
#line 1375
  destroy_sensitive_data();
#line 1378
  packet_start(31);
#line 1379
  packet_put_string((char const   *)((char *)server_host_key_blob), sbloblen);
#line 1380
  packet_put_bignum2(dh->pub_key);
#line 1381
  packet_put_string((char const   *)((char *)signature), (unsigned int )slen);
#line 1382
  packet_send();
#line 1383
  xfree((void *)signature);
#line 1384
  xfree((void *)server_host_key_blob);
#line 1385
  packet_write_wait();
#line 1387
  kex_derive_keys(kex___0, hash, shared_secret);
#line 1388
  packet_set_kex(kex___0);
#line 1391
  DH_free(dh);
#line 1393
  debug("send SSH2_MSG_NEWKEYS.");
#line 1394
  packet_start(21);
#line 1395
  packet_send();
#line 1396
  packet_write_wait();
#line 1397
  debug("done: send SSH2_MSG_NEWKEYS.");
#line 1399
  debug("Wait SSH2_MSG_NEWKEYS.");
#line 1400
  packet_read_expect(& payload_len, 21);
#line 1401
  debug("GOT SSH2_MSG_NEWKEYS.");
#line 1410
  debug("done: KEX2.");
#line 1411
  return;
}
}
#line 1 "auth.o"
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 382
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
#line 433
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 433 "/usr/include/sys/stat.h"
__inline static int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
#line 436
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
#line 436
  return (tmp);
}
}
#line 103 "/usr/include/grp.h"
extern struct group *getgrgid(__gid_t __gid ) ;
#line 10 "auth.h"
int allowed_user(struct passwd *pw ) ;
#line 47 "auth.c"
int allowed_user(struct passwd *pw ) 
{ struct stat st ;
  struct group *grp ;
  char *shell ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 80
  if (! pw) {
#line 81
    return (0);
  }
#line 88
  if ((int )*(pw->pw_shell + 0) == 0) {
#line 88
    shell = (char *)"/bin/sh";
  } else {
#line 88
    shell = pw->pw_shell;
  }
#line 91
  tmp = stat((char const   * __restrict  )shell, (struct stat * __restrict  )(& st));
#line 91
  if (tmp != 0) {
#line 92
    return (0);
  }
#line 93
  if (st.st_mode & 32768U) {
#line 93
    if (! (st.st_mode & (unsigned int )((((64 >> 3) >> 3) | 64) | (64 >> 3)))) {
#line 94
      return (0);
    }
  } else {
#line 94
    return (0);
  }
#line 97
  if (options.num_deny_users > 0U) {
#line 98
    if (! pw->pw_name) {
#line 99
      return (0);
    }
#line 100
    i = 0;
#line 100
    while ((unsigned int )i < options.num_deny_users) {
#line 101
      tmp___0 = match_pattern((char const   *)pw->pw_name, (char const   *)options.deny_users[i]);
#line 101
      if (tmp___0) {
#line 102
        return (0);
      }
#line 100
      i ++;
    }
  }
#line 105
  if (options.num_allow_users > 0U) {
#line 106
    if (! pw->pw_name) {
#line 107
      return (0);
    }
#line 108
    i = 0;
#line 108
    while ((unsigned int )i < options.num_allow_users) {
#line 109
      tmp___1 = match_pattern((char const   *)pw->pw_name, (char const   *)options.allow_users[i]);
#line 109
      if (tmp___1) {
#line 110
        break;
      }
#line 108
      i ++;
    }
#line 112
    if ((unsigned int )i >= options.num_allow_users) {
#line 113
      return (0);
    }
  }
#line 116
  if (options.num_deny_groups > 0U) {
    goto _L;
  } else {
#line 116
    if (options.num_allow_groups > 0U) {
      _L: /* CIL Label */ 
#line 117
      grp = getgrgid(pw->pw_gid);
#line 118
      if (! grp) {
#line 119
        return (0);
      }
#line 122
      if (options.num_deny_groups > 0U) {
#line 123
        if (! grp->gr_name) {
#line 124
          return (0);
        }
#line 125
        i = 0;
#line 125
        while ((unsigned int )i < options.num_deny_groups) {
#line 126
          tmp___2 = match_pattern((char const   *)grp->gr_name, (char const   *)options.deny_groups[i]);
#line 126
          if (tmp___2) {
#line 127
            return (0);
          }
#line 125
          i ++;
        }
      }
#line 133
      if (options.num_allow_groups > 0U) {
#line 134
        if (! grp->gr_name) {
#line 135
          return (0);
        }
#line 136
        i = 0;
#line 136
        while ((unsigned int )i < options.num_allow_groups) {
#line 137
          tmp___3 = match_pattern((char const   *)grp->gr_name, (char const   *)options.allow_groups[i]);
#line 137
          if (tmp___3) {
#line 138
            break;
          }
#line 136
          i ++;
        }
#line 141
        if ((unsigned int )i >= options.num_allow_groups) {
#line 142
          return (0);
        }
      }
    }
  }
#line 164
  return (1);
}
}
#line 1 "auth1.o"
#line 360 "ssh.h"
int auth_rhosts(struct passwd *pw , char const   *client_user ) ;
#line 366
int auth_rhosts_rsa(struct passwd *pw , char const   *client_user , RSA *client_host_key ) ;
#line 380
int auth_rsa(struct passwd *pw , BIGNUM *client_n ) ;
#line 6 "auth-pam.h"
void start_pam(struct passwd *pw ) ;
#line 8
int auth_pam_password(struct passwd *pw , char const   *password ) ;
#line 10
int do_pam_account(char *username , char *remote_user ) ;
#line 5 "session.h"
void do_authenticated(struct passwd *pw ) ;
#line 28 "auth1.c"
char *forced_command ;
#line 40 "auth1.c"
static char buf[1024]  ;
#line 37 "auth1.c"
char *get_authname(int type ) 
{ 

  {
#line 41
  switch (type) {
  case 9: 
#line 43
  return ((char *)"password");
  case 6: 
#line 45
  return ((char *)"rsa");
  case 35: 
#line 47
  return ((char *)"rhosts-rsa");
  case 5: 
#line 49
  return ((char *)"rhosts");
  }
#line 59
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"bad-auth-msg-%d",
           type);
#line 60
  return (buf);
}
}
#line 67 "auth1.c"
void do_fake_authloop1(char *user ) 
{ int attempt___0 ;
  int tmp ;
  char const   *tmp___0 ;
  int plen ;

  {
#line 70
  attempt___0 = 0;
#line 72
  tmp = get_remote_port();
#line 72
  tmp___0 = get_remote_ipaddr();
#line 72
  log("Faking authloop for illegal user %.200s from %.200s port %d", user, tmp___0,
      tmp);
#line 82
  packet_start(15);
#line 83
  packet_send();
#line 84
  packet_write_wait();
#line 90
  attempt___0 = 1;
#line 90
  while (1) {
#line 94
    packet_read(& plen);
#line 120
    if (attempt___0 > 6) {
#line 121
      packet_disconnect("Too many authentication failures for %.100s", user);
    }
#line 127
    packet_start(15);
#line 128
    packet_send();
#line 129
    packet_write_wait();
#line 90
    attempt___0 ++;
  }
#line 132
  abort();
}
}
#line 139 "auth1.c"
void do_authloop(struct passwd *pw ) 
{ int attempt___0 ;
  unsigned int bits ;
  RSA *client_host_key ;
  BIGNUM *n___0 ;
  char *client_user ;
  char *password ;
  char user[1024] ;
  unsigned int dlen ;
  int plen ;
  int nlen ;
  int elen ;
  unsigned int ulen ;
  int type ;
  void (*authlog___0)(char const   *fmt  , ...) ;
  int authenticated ;
  int _p ;
  int _e ;
  int tmp ;
  int tmp___0 ;
  int _p___0 ;
  int _e___0 ;
  int _p___1 ;
  int _e___1 ;
  int _p___2 ;
  int _e___2 ;
  size_t tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;

  {
#line 142
  attempt___0 = 0;
#line 146
  client_user = (char *)((void *)0);
#line 146
  password = (char *)((void *)0);
#line 151
  type = 0;
#line 152
  authlog___0 = (void (*)(char const   *fmt  , ...))(& verbose);
#line 155
  packet_start(15);
#line 156
  packet_send();
#line 157
  packet_write_wait();
#line 159
  attempt___0 = 1;
#line 159
  while (1) {
#line 160
    authenticated = 0;
#line 161
    strlcpy(user, "", sizeof(user));
#line 164
    type = packet_read(& plen);
#line 167
    switch (type) {
    case 5: 
#line 227
    if (! options.rhosts_authentication) {
#line 228
      verbose("Rhosts authentication disabled.");
#line 229
      break;
    }
#line 237
    client_user = packet_get_string(& ulen);
#line 238
    while (1) {
#line 238
      _p = plen;
#line 238
      _e = (int )(4U + ulen);
#line 238
      if (_p != _e) {
#line 238
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "auth1.c", 238);
#line 238
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 238
      break;
    }
#line 242
    authenticated = auth_rhosts(pw, (char const   *)client_user);
#line 244
    snprintf((char * __restrict  )(user), sizeof(user), (char const   * __restrict  )" ruser %s",
             client_user);
#line 245
    break;
    case 35: 
#line 248
    if (! options.rhosts_rsa_authentication) {
#line 249
      verbose("Rhosts with RSA authentication disabled.");
#line 250
      break;
    }
#line 257
    client_user = packet_get_string(& ulen);
#line 260
    client_host_key = RSA_new();
#line 261
    if ((unsigned int )client_host_key == (unsigned int )((void *)0)) {
#line 262
      fatal("RSA_new failed");
    }
#line 263
    client_host_key->e = BN_new();
#line 264
    client_host_key->n = BN_new();
#line 265
    if ((unsigned int )client_host_key->e == (unsigned int )((void *)0)) {
#line 266
      fatal("BN_new failed");
    } else {
#line 265
      if ((unsigned int )client_host_key->n == (unsigned int )((void *)0)) {
#line 266
        fatal("BN_new failed");
      }
    }
#line 267
    bits = packet_get_int();
#line 268
    packet_get_bignum(client_host_key->e, & elen);
#line 269
    packet_get_bignum(client_host_key->n, & nlen);
#line 271
    tmp___0 = BN_num_bits((BIGNUM const   *)client_host_key->n);
#line 271
    if (bits != (unsigned int )tmp___0) {
#line 272
      tmp = BN_num_bits((BIGNUM const   *)client_host_key->n);
#line 272
      log("Warning: keysize mismatch for client_host_key: actual %d, announced %d",
          tmp, bits);
    }
#line 274
    while (1) {
#line 274
      _p___0 = plen;
#line 274
      _e___0 = (int )((((4U + ulen) + 4U) + (unsigned int )elen) + (unsigned int )nlen);
#line 274
      if (_p___0 != _e___0) {
#line 274
        log("Packet integrity error (%d != %d) at %s:%d", _p___0, _e___0, "auth1.c",
            274);
#line 274
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 274
      break;
    }
#line 276
    authenticated = auth_rhosts_rsa(pw, (char const   *)client_user, client_host_key);
#line 277
    RSA_free(client_host_key);
#line 279
    snprintf((char * __restrict  )(user), sizeof(user), (char const   * __restrict  )" ruser %s",
             client_user);
#line 280
    break;
    case 6: 
#line 283
    if (! options.rsa_authentication) {
#line 284
      verbose("RSA authentication disabled.");
#line 285
      break;
    }
#line 288
    n___0 = BN_new();
#line 289
    packet_get_bignum(n___0, & nlen);
#line 290
    while (1) {
#line 290
      _p___1 = plen;
#line 290
      _e___1 = nlen;
#line 290
      if (_p___1 != _e___1) {
#line 290
        log("Packet integrity error (%d != %d) at %s:%d", _p___1, _e___1, "auth1.c",
            290);
#line 290
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 290
      break;
    }
#line 291
    authenticated = auth_rsa(pw, n___0);
#line 292
    BN_clear_free(n___0);
#line 293
    break;
    case 9: 
#line 296
    if (! options.password_authentication) {
#line 297
      verbose("Password authentication disabled.");
#line 298
      break;
    }
#line 305
    password = packet_get_string(& dlen);
#line 306
    while (1) {
#line 306
      _p___2 = plen;
#line 306
      _e___2 = (int )(4U + dlen);
#line 306
      if (_p___2 != _e___2) {
#line 306
        log("Packet integrity error (%d != %d) at %s:%d", _p___2, _e___2, "auth1.c",
            306);
#line 306
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 306
      break;
    }
#line 310
    authenticated = auth_pam_password(pw, (char const   *)password);
#line 323
    tmp___1 = strlen((char const   *)password);
#line 323
    memset((void *)password, 0, tmp___1);
#line 324
    xfree((void *)password);
#line 325
    break;
    case 39: 
#line 361
    log("TIS authentication unsupported.");
#line 362
    break;
    default: 
#line 370
    log("Unknown message during authentication: type %d", type);
#line 371
    break;
    }
#line 379
    if (authenticated) {
#line 379
      if (pw->pw_uid == 0U) {
#line 379
        if (! options.permit_root_login) {
#line 380
          if (forced_command) {
#line 381
            log("Root login accepted for forced command.");
          } else {
#line 383
            authenticated = 0;
#line 384
            tmp___2 = get_canonical_hostname();
#line 384
            log("ROOT LOGIN REFUSED FROM %.200s", tmp___2);
          }
        }
      }
    }
#line 390
    if (authenticated) {
#line 393
      authlog___0 = (void (*)(char const   *fmt  , ...))(& log);
    } else {
#line 390
      if (attempt___0 == 3) {
#line 393
        authlog___0 = (void (*)(char const   *fmt  , ...))(& log);
      } else {
#line 390
        if (type == 9) {
#line 393
          authlog___0 = (void (*)(char const   *fmt  , ...))(& log);
        }
      }
    }
#line 395
    tmp___3 = get_remote_port();
#line 395
    tmp___4 = get_remote_ipaddr();
#line 395
    if (pw->pw_uid == 0U) {
#line 395
      tmp___5 = "ROOT";
    } else {
#line 395
      tmp___5 = (char const   *)pw->pw_name;
    }
#line 395
    tmp___6 = get_authname(type);
#line 395
    if (authenticated) {
#line 395
      tmp___7 = "Accepted";
    } else {
#line 395
      tmp___7 = "Failed";
    }
#line 395
    (*authlog___0)("%s %s for %.200s from %.200s port %d%s", tmp___7, tmp___6, tmp___5,
                   tmp___4, tmp___3, user);
#line 404
    if (authenticated) {
#line 405
      tmp___8 = do_pam_account(pw->pw_name, client_user);
#line 405
      if (! tmp___8) {
#line 406
        if ((unsigned int )client_user != (unsigned int )((void *)0)) {
#line 407
          xfree((void *)client_user);
#line 408
          client_user = (char *)((void *)0);
        }
#line 410
        do_fake_authloop1(pw->pw_name);
      }
#line 412
      return;
    }
#line 420
    if ((unsigned int )client_user != (unsigned int )((void *)0)) {
#line 421
      xfree((void *)client_user);
#line 422
      client_user = (char *)((void *)0);
    }
#line 425
    if (attempt___0 > 6) {
#line 429
      packet_disconnect("Too many authentication failures for %.100s", pw->pw_name);
    }
#line 433
    packet_start(15);
#line 434
    packet_send();
#line 435
    packet_write_wait();
#line 159
    attempt___0 ++;
  }
}
}
#line 443 "auth1.c"
void do_authentication(void) 
{ struct passwd *pw ;
  struct passwd pwcopy ;
  int plen ;
  unsigned int ulen ;
  char *user ;
  int _p ;
  int _e ;
  int tmp ;
  __uid_t tmp___0 ;
  __uid_t tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
#line 455
  packet_read_expect(& plen, 4);
#line 458
  user = packet_get_string(& ulen);
#line 459
  while (1) {
#line 459
    _p = plen;
#line 459
    _e = (int )(4U + ulen);
#line 459
    if (_p != _e) {
#line 459
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "auth1.c", 459);
#line 459
      packet_disconnect("Packet integrity error. (%d)", 4);
    }
#line 459
    break;
  }
#line 461
  setproctitle("%s", user);
#line 472
  pw = getpwnam((char const   *)user);
#line 473
  if (! pw) {
#line 474
    do_fake_authloop1(user);
  } else {
#line 473
    tmp = allowed_user(pw);
#line 473
    if (! tmp) {
#line 474
      do_fake_authloop1(user);
    }
  }
#line 475
  xfree((void *)user);
#line 478
  memset((void *)(& pwcopy), 0, sizeof(pwcopy));
#line 479
  pwcopy.pw_name = xstrdup((char const   *)pw->pw_name);
#line 480
  pwcopy.pw_passwd = xstrdup((char const   *)pw->pw_passwd);
#line 481
  pwcopy.pw_uid = pw->pw_uid;
#line 482
  pwcopy.pw_gid = pw->pw_gid;
#line 486
  pwcopy.pw_dir = xstrdup((char const   *)pw->pw_dir);
#line 487
  pwcopy.pw_shell = xstrdup((char const   *)pw->pw_shell);
#line 488
  pw = & pwcopy;
#line 491
  start_pam(pw);
#line 498
  tmp___0 = getuid();
#line 498
  if (tmp___0 != 0U) {
#line 498
    tmp___1 = getuid();
#line 498
    if (pw->pw_uid != tmp___1) {
#line 499
      packet_disconnect("Cannot change user when server not running as root.");
    }
  }
#line 501
  debug("Attempting authentication for %.100s.", pw->pw_name);
#line 504
  if (options.password_authentication) {
#line 504
    tmp___3 = auth_pam_password(pw, "");
#line 504
    if (tmp___3) {
#line 518
      tmp___2 = get_remote_ipaddr();
#line 518
      log("Login for user %s from %.100s, accepted without authentication.", pw->pw_name,
          tmp___2);
    } else {
#line 524
      do_authloop(pw);
    }
  } else {
#line 524
    do_authloop(pw);
  }
#line 533
  packet_start(14);
#line 534
  packet_send();
#line 535
  packet_write_wait();
#line 538
  do_authenticated(pw);
#line 539
  return;
}
}
#line 1 "auth2.o"
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 212
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 759 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 7 "auth.h"
struct passwd *auth_get_user(void) ;
#line 8 "session.h"
void do_authenticated2(void) ;
#line 12 "auth-options.h"
int auth_parse_options(struct passwd *pw , char *options___0 , unsigned long linenum ) ;
#line 71 "auth2.c"
void input_service_request(int type , int plen ) ;
#line 72
void input_userauth_request(int type , int plen ) ;
#line 73
void protocol_error(int type , int plen ) ;
#line 76
int ssh2_auth_none(struct passwd *pw ) ;
#line 77
int ssh2_auth_password(struct passwd *pw ) ;
#line 78
int ssh2_auth_pubkey(struct passwd *pw , char *service ) ;
#line 81
struct passwd *auth_set_user(char *u , char *s ) ;
#line 82
int user_dsa_key_allowed(struct passwd *pw , Key *key ) ;
#line 91 "auth2.c"
static Authctxt *authctxt  =    (Authctxt *)((void *)0);
#line 92 "auth2.c"
static int userauth_success  =    0;
#line 98 "auth2.c"
void do_authentication2(void) 
{ 

  {
#line 109
  dispatch_init(& protocol_error);
#line 110
  dispatch_set(5, & input_service_request);
#line 111
  dispatch_run(0, & userauth_success);
#line 112
  do_authenticated2();
#line 113
  return;
}
}
#line 115 "auth2.c"
void protocol_error(int type , int plen ) 
{ 

  {
#line 118
  log("auth: protocol error: type %d plen %d", type, plen);
#line 119
  packet_start(3);
#line 120
  packet_put_int(0U);
#line 121
  packet_send();
#line 122
  packet_write_wait();
#line 123
  return;
}
}
#line 125 "auth2.c"
void input_service_request(int type , int plen ) 
{ unsigned int len ;
  int accept___0 ;
  char *service ;
  char *tmp ;
  int _len ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 129
  accept___0 = 0;
#line 130
  tmp = packet_get_string(& len);
#line 130
  service = tmp;
#line 131
  while (1) {
#line 131
    tmp___0 = packet_remaining();
#line 131
    _len = tmp___0;
#line 131
    if (_len > 0) {
#line 131
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
          131);
#line 131
      packet_disconnect("Packet integrity error.");
    }
#line 131
    break;
  }
#line 133
  if (0) {
#line 133
    __s1_len = strlen((char const   *)service);
#line 133
    __s2_len = strlen("ssh-userauth");
#line 133
    if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
      goto _L___0;
    } else {
#line 133
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 133
        if (! ((unsigned int )((void const   *)("ssh-userauth" + 1)) - (unsigned int )((void const   *)"ssh-userauth") == 1U)) {
#line 133
          tmp___10 = 1;
        } else {
#line 133
          if (__s2_len >= 4U) {
#line 133
            tmp___10 = 1;
          } else {
#line 133
            tmp___10 = 0;
          }
        }
      } else {
#line 133
        tmp___10 = 0;
      }
    }
#line 133
    if (tmp___10) {
#line 133
      tmp___6 = __builtin_strcmp((char const   *)service, "ssh-userauth");
    } else {
#line 133
      tmp___9 = __builtin_strcmp((char const   *)service, "ssh-userauth");
#line 133
      tmp___6 = tmp___9;
    }
  } else {
#line 133
    tmp___9 = __builtin_strcmp((char const   *)service, "ssh-userauth");
#line 133
    tmp___6 = tmp___9;
  }
#line 133
  if (tmp___6 == 0) {
#line 134
    if (! userauth_success) {
#line 135
      accept___0 = 1;
#line 137
      dispatch_set(50, & input_userauth_request);
    }
  }
#line 142
  if (accept___0) {
#line 143
    packet_start(6);
#line 144
    packet_put_cstring((char const   *)service);
#line 145
    packet_send();
#line 146
    packet_write_wait();
  } else {
#line 148
    debug("bad service request %s", service);
#line 149
    packet_disconnect("bad service request %s", service);
  }
#line 151
  xfree((void *)service);
#line 152
  return;
}
}
#line 157 "auth2.c"
static void (*authlog)(char const   *fmt  , ...)  =    (void (*)(char const   *fmt  , ...))(& verbose);
#line 158 "auth2.c"
static int attempt  =    0;
#line 154 "auth2.c"
void input_userauth_request(int type , int plen ) 
{ unsigned int len ;
  int authenticated ;
  char *user ;
  char *service ;
  char *method ;
  char *authmsg ;
  struct passwd *pw ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  char const   *tmp___39 ;
  int tmp___40 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___46 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  char const   *tmp___52 ;
  char const   *tmp___53 ;

  {
#line 160
  authenticated = 0;
#line 161
  authmsg = (char *)((void *)0);
#line 167
  user = packet_get_string(& len);
#line 168
  service = packet_get_string(& len);
#line 169
  method = packet_get_string(& len);
#line 170
  attempt ++;
#line 170
  if (attempt == 6) {
#line 174
    packet_disconnect("too many failed userauth_requests");
  }
#line 176
  debug("userauth-request for user %s service %s method %s", user, service, method);
#line 179
  pw = auth_set_user(user, service);
#line 180
  if (pw) {
#line 180
    if (0) {
#line 180
      __s1_len___2 = strlen((char const   *)service);
#line 180
      __s2_len___2 = strlen("ssh-connection");
#line 180
      if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
        goto _L___6;
      } else {
#line 180
        if (__s1_len___2 >= 4U) {
          _L___6: /* CIL Label */ 
#line 180
          if (! ((unsigned int )((void const   *)("ssh-connection" + 1)) - (unsigned int )((void const   *)"ssh-connection") == 1U)) {
#line 180
            tmp___38 = 1;
          } else {
#line 180
            if (__s2_len___2 >= 4U) {
#line 180
              tmp___38 = 1;
            } else {
#line 180
              tmp___38 = 0;
            }
          }
        } else {
#line 180
          tmp___38 = 0;
        }
      }
#line 180
      if (tmp___38) {
#line 180
        tmp___34 = __builtin_strcmp((char const   *)service, "ssh-connection");
      } else {
#line 180
        tmp___37 = __builtin_strcmp((char const   *)service, "ssh-connection");
#line 180
        tmp___34 = tmp___37;
      }
    } else {
#line 180
      tmp___37 = __builtin_strcmp((char const   *)service, "ssh-connection");
#line 180
      tmp___34 = tmp___37;
    }
#line 180
    if (tmp___34 == 0) {
#line 181
      if (0) {
#line 181
        __s1_len___1 = strlen((char const   *)method);
#line 181
        __s2_len___1 = strlen("none");
#line 181
        if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
          goto _L___4;
        } else {
#line 181
          if (__s1_len___1 >= 4U) {
            _L___4: /* CIL Label */ 
#line 181
            if (! ((unsigned int )((void const   *)("none" + 1)) - (unsigned int )((void const   *)"none") == 1U)) {
#line 181
              tmp___28 = 1;
            } else {
#line 181
              if (__s2_len___1 >= 4U) {
#line 181
                tmp___28 = 1;
              } else {
#line 181
                tmp___28 = 0;
              }
            }
          } else {
#line 181
            tmp___28 = 0;
          }
        }
#line 181
        if (tmp___28) {
#line 181
          tmp___24 = __builtin_strcmp((char const   *)method, "none");
        } else {
#line 181
          tmp___27 = __builtin_strcmp((char const   *)method, "none");
#line 181
          tmp___24 = tmp___27;
        }
      } else {
#line 181
        tmp___27 = __builtin_strcmp((char const   *)method, "none");
#line 181
        tmp___24 = tmp___27;
      }
#line 181
      if (tmp___24 == 0) {
#line 182
        authenticated = ssh2_auth_none(pw);
      } else {
#line 183
        if (0) {
#line 183
          __s1_len___0 = strlen((char const   *)method);
#line 183
          __s2_len___0 = strlen("password");
#line 183
          if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
            goto _L___2;
          } else {
#line 183
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 183
              if (! ((unsigned int )((void const   *)("password" + 1)) - (unsigned int )((void const   *)"password") == 1U)) {
#line 183
                tmp___18 = 1;
              } else {
#line 183
                if (__s2_len___0 >= 4U) {
#line 183
                  tmp___18 = 1;
                } else {
#line 183
                  tmp___18 = 0;
                }
              }
            } else {
#line 183
              tmp___18 = 0;
            }
          }
#line 183
          if (tmp___18) {
#line 183
            tmp___14 = __builtin_strcmp((char const   *)method, "password");
          } else {
#line 183
            tmp___17 = __builtin_strcmp((char const   *)method, "password");
#line 183
            tmp___14 = tmp___17;
          }
        } else {
#line 183
          tmp___17 = __builtin_strcmp((char const   *)method, "password");
#line 183
          tmp___14 = tmp___17;
        }
#line 183
        if (tmp___14 == 0) {
#line 184
          authenticated = ssh2_auth_password(pw);
        } else {
#line 185
          if (0) {
#line 185
            __s1_len = strlen((char const   *)method);
#line 185
            __s2_len = strlen("publickey");
#line 185
            if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
              goto _L___0;
            } else {
#line 185
              if (__s1_len >= 4U) {
                _L___0: /* CIL Label */ 
#line 185
                if (! ((unsigned int )((void const   *)("publickey" + 1)) - (unsigned int )((void const   *)"publickey") == 1U)) {
#line 185
                  tmp___8 = 1;
                } else {
#line 185
                  if (__s2_len >= 4U) {
#line 185
                    tmp___8 = 1;
                  } else {
#line 185
                    tmp___8 = 0;
                  }
                }
              } else {
#line 185
                tmp___8 = 0;
              }
            }
#line 185
            if (tmp___8) {
#line 185
              tmp___4 = __builtin_strcmp((char const   *)method, "publickey");
            } else {
#line 185
              tmp___7 = __builtin_strcmp((char const   *)method, "publickey");
#line 185
              tmp___4 = tmp___7;
            }
          } else {
#line 185
            tmp___7 = __builtin_strcmp((char const   *)method, "publickey");
#line 185
            tmp___4 = tmp___7;
          }
#line 185
          if (tmp___4 == 0) {
#line 186
            authenticated = ssh2_auth_pubkey(pw, service);
          }
        }
      }
    }
  }
#line 189
  if (authenticated) {
#line 189
    if (pw) {
#line 189
      if (pw->pw_uid == 0U) {
#line 189
        if (! options.permit_root_login) {
#line 190
          authenticated = 0;
#line 191
          tmp___39 = get_canonical_hostname();
#line 191
          log("ROOT LOGIN REFUSED FROM %.200s", tmp___39);
        }
      }
    }
  }
#line 196
  if (authenticated) {
#line 196
    tmp___40 = do_pam_account(pw->pw_name, (char *)((void *)0));
#line 196
    if (! tmp___40) {
#line 197
      authenticated = 0;
    }
  }
#line 203
  if (authenticated == 1) {
#line 204
    authlog = (void (*)(char const   *fmt  , ...))(& log);
  } else {
#line 203
    if (attempt == 3) {
#line 204
      authlog = (void (*)(char const   *fmt  , ...))(& log);
    } else {
#line 203
      if (0) {
#line 203
        __s1_len___3 = strlen((char const   *)method);
#line 203
        __s2_len___3 = strlen("password");
#line 203
        if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
          goto _L___8;
        } else {
#line 203
          if (__s1_len___3 >= 4U) {
            _L___8: /* CIL Label */ 
#line 203
            if (! ((unsigned int )((void const   *)("password" + 1)) - (unsigned int )((void const   *)"password") == 1U)) {
#line 203
              tmp___50 = 1;
            } else {
#line 203
              if (__s2_len___3 >= 4U) {
#line 203
                tmp___50 = 1;
              } else {
#line 203
                tmp___50 = 0;
              }
            }
          } else {
#line 203
            tmp___50 = 0;
          }
        }
#line 203
        if (tmp___50) {
#line 203
          tmp___46 = __builtin_strcmp((char const   *)method, "password");
        } else {
#line 203
          tmp___49 = __builtin_strcmp((char const   *)method, "password");
#line 203
          tmp___46 = tmp___49;
        }
      } else {
#line 203
        tmp___49 = __builtin_strcmp((char const   *)method, "password");
#line 203
        tmp___46 = tmp___49;
      }
#line 203
      if (tmp___46 == 0) {
#line 204
        authlog = (void (*)(char const   *fmt  , ...))(& log);
      }
    }
  }
#line 207
  if (authenticated == 1) {
#line 208
    authmsg = (char *)"Accepted";
  } else {
#line 209
    if (authenticated == 0) {
#line 210
      authmsg = (char *)"Failed";
    } else {
#line 212
      authmsg = (char *)"Postponed";
    }
  }
#line 214
  tmp___51 = get_remote_port();
#line 214
  tmp___52 = get_remote_ipaddr();
#line 214
  if (pw) {
#line 214
    if (pw->pw_uid == 0U) {
#line 214
      tmp___53 = "ROOT";
    } else {
#line 214
      tmp___53 = (char const   *)user;
    }
  } else {
#line 214
    tmp___53 = (char const   *)user;
  }
#line 214
  (*authlog)("%s %s for %.200s from %.200s port %d ssh2", authmsg, method, tmp___53,
             tmp___52, tmp___51);
#line 222
  if (authenticated == 1) {
#line 230
    dispatch_set(50, & protocol_error);
#line 231
    packet_start(52);
#line 232
    packet_send();
#line 233
    packet_write_wait();
#line 235
    userauth_success = 1;
  } else {
#line 236
    if (authenticated == 0) {
#line 237
      packet_start(51);
#line 238
      packet_put_cstring("publickey,password");
#line 239
      packet_put_char(0);
#line 240
      packet_send();
#line 241
      packet_write_wait();
    }
  }
#line 244
  xfree((void *)service);
#line 245
  xfree((void *)user);
#line 246
  xfree((void *)method);
#line 247
  return;
}
}
#line 249 "auth2.c"
int ssh2_auth_none(struct passwd *pw ) 
{ int _len ;
  int tmp ;
  int tmp___0 ;

  {
#line 257
  while (1) {
#line 257
    tmp = packet_remaining();
#line 257
    _len = tmp;
#line 257
    if (_len > 0) {
#line 257
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
          257);
#line 257
      packet_disconnect("Packet integrity error.");
    }
#line 257
    break;
  }
#line 260
  tmp___0 = auth_pam_password(pw, "");
#line 260
  return (tmp___0);
}
}
#line 269 "auth2.c"
int ssh2_auth_password(struct passwd *pw ) 
{ char *password ;
  int authenticated ;
  int change ;
  unsigned int len ;
  unsigned int tmp ;
  int _len ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 273
  authenticated = 0;
#line 280
  tmp = packet_get_char();
#line 280
  change = (int )tmp;
#line 281
  if (change) {
#line 282
    log("password change not supported");
  }
#line 283
  password = packet_get_string(& len);
#line 284
  while (1) {
#line 284
    tmp___0 = packet_remaining();
#line 284
    _len = tmp___0;
#line 284
    if (_len > 0) {
#line 284
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
          284);
#line 284
      packet_disconnect("Packet integrity error.");
    }
#line 284
    break;
  }
#line 285
  if (options.password_authentication) {
#line 285
    tmp___1 = auth_pam_password(pw, (char const   *)password);
#line 285
    if (tmp___1 == 1) {
#line 295
      authenticated = 1;
    }
  }
#line 296
  memset((void *)password, 0, len);
#line 297
  xfree((void *)password);
#line 298
  return (authenticated);
}
}
#line 300 "auth2.c"
int ssh2_auth_pubkey(struct passwd *pw , char *service ) 
{ Buffer b ;
  Key *key ;
  char *pkalg ;
  char *pkblob ;
  char *sig ;
  unsigned int alen ;
  unsigned int blen ;
  unsigned int slen ;
  int have_sig ;
  int authenticated ;
  unsigned int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  int _len ;
  int tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  unsigned int tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int _len___0 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 308
  authenticated = 0;
#line 310
  if (options.dsa_authentication == 0) {
#line 311
    debug("pubkey auth disabled");
#line 312
    return (0);
  }
#line 314
  tmp = packet_get_char();
#line 314
  have_sig = (int )tmp;
#line 315
  pkalg = packet_get_string(& alen);
#line 316
  if (0) {
#line 316
    __s1_len = strlen((char const   *)pkalg);
#line 316
    __s2_len = strlen("ssh-dss");
#line 316
    if (! ((unsigned int )((void const   *)(pkalg + 1)) - (unsigned int )((void const   *)pkalg) == 1U)) {
      goto _L___0;
    } else {
#line 316
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 316
        if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
#line 316
          tmp___9 = 1;
        } else {
#line 316
          if (__s2_len >= 4U) {
#line 316
            tmp___9 = 1;
          } else {
#line 316
            tmp___9 = 0;
          }
        }
      } else {
#line 316
        tmp___9 = 0;
      }
    }
#line 316
    if (tmp___9) {
#line 316
      tmp___5 = __builtin_strcmp((char const   *)pkalg, "ssh-dss");
    } else {
#line 316
      tmp___8 = __builtin_strcmp((char const   *)pkalg, "ssh-dss");
#line 316
      tmp___5 = tmp___8;
    }
  } else {
#line 316
    tmp___8 = __builtin_strcmp((char const   *)pkalg, "ssh-dss");
#line 316
    tmp___5 = tmp___8;
  }
#line 316
  if (tmp___5 != 0) {
#line 317
    xfree((void *)pkalg);
#line 318
    log("bad pkalg %s", pkalg);
#line 319
    return (0);
  }
#line 321
  pkblob = packet_get_string(& blen);
#line 322
  key = dsa_key_from_blob(pkblob, (int )blen);
#line 323
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 324
    if (have_sig) {
#line 325
      sig = packet_get_string(& slen);
#line 326
      while (1) {
#line 326
        tmp___10 = packet_remaining();
#line 326
        _len = tmp___10;
#line 326
        if (_len > 0) {
#line 326
          log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
              326);
#line 326
          packet_disconnect("Packet integrity error.");
        }
#line 326
        break;
      }
#line 327
      buffer_init(& b);
#line 328
      if (datafellows & 16) {
#line 329
        buffer_put_string(& b, (void const   *)session_id2, (unsigned int )session_id2_len);
      } else {
#line 331
        buffer_append(& b, (char const   *)session_id2, (unsigned int )session_id2_len);
      }
#line 334
      buffer_put_char(& b, 50);
#line 335
      buffer_put_cstring(& b, (char const   *)pw->pw_name);
#line 336
      if (datafellows & 2) {
#line 336
        tmp___11 = "ssh-userauth";
      } else {
#line 336
        tmp___11 = (char const   *)service;
      }
#line 336
      buffer_put_cstring(& b, tmp___11);
#line 340
      buffer_put_cstring(& b, "publickey");
#line 341
      buffer_put_char(& b, have_sig);
#line 342
      buffer_put_cstring(& b, "ssh-dss");
#line 343
      buffer_put_string(& b, (void const   *)pkblob, blen);
#line 348
      tmp___12 = user_dsa_key_allowed(pw, key);
#line 348
      if (tmp___12) {
#line 348
        tmp___13 = buffer_len(& b);
#line 348
        tmp___14 = buffer_ptr(& b);
#line 348
        tmp___15 = dsa_verify(key, (unsigned char *)sig, (int )slen, (unsigned char *)tmp___14,
                              (int )tmp___13);
#line 348
        if (tmp___15 == 1) {
#line 350
          authenticated = 1;
        }
      }
#line 351
      buffer_clear(& b);
#line 352
      xfree((void *)sig);
    } else {
#line 354
      while (1) {
#line 354
        tmp___16 = packet_remaining();
#line 354
        _len___0 = tmp___16;
#line 354
        if (_len___0 > 0) {
#line 354
          log("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "auth2.c",
              354);
#line 354
          packet_disconnect("Packet integrity error.");
        }
#line 354
        break;
      }
#line 355
      debug("test key...");
#line 365
      tmp___17 = user_dsa_key_allowed(pw, key);
#line 365
      if (tmp___17) {
#line 366
        packet_start(60);
#line 367
        packet_put_string((char const   *)pkalg, alen);
#line 368
        packet_put_string((char const   *)pkblob, blen);
#line 369
        packet_send();
#line 370
        packet_write_wait();
#line 371
        authenticated = -1;
      }
    }
#line 374
    key_free(key);
  }
#line 376
  xfree((void *)pkalg);
#line 377
  xfree((void *)pkblob);
#line 378
  return (authenticated);
}
}
#line 383 "auth2.c"
struct passwd *auth_get_user(void) 
{ struct passwd *tmp ;

  {
#line 386
  if ((unsigned int )authctxt != (unsigned int )((void *)0)) {
#line 386
    if (authctxt->valid) {
#line 386
      tmp = & authctxt->pw;
    } else {
#line 386
      tmp = (struct passwd *)((void *)0);
    }
  } else {
#line 386
    tmp = (struct passwd *)((void *)0);
  }
#line 386
  return (tmp);
}
}
#line 389 "auth2.c"
struct passwd *auth_set_user(char *u , char *s ) 
{ struct passwd *pw ;
  struct passwd *copy ;
  void *tmp ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___16 ;
  int tmp___19 ;
  int tmp___20 ;
  struct passwd *tmp___21 ;

  {
#line 394
  if ((unsigned int )authctxt == (unsigned int )((void *)0)) {
#line 395
    tmp = xmalloc(sizeof(*authctxt));
#line 395
    authctxt = (Authctxt *)tmp;
#line 396
    authctxt->valid = 0;
#line 397
    authctxt->user = xstrdup((char const   *)u);
#line 398
    authctxt->service = xstrdup((char const   *)s);
#line 399
    setproctitle("%s", u);
#line 400
    pw = getpwnam((char const   *)u);
#line 401
    if (! pw) {
#line 402
      log("auth_set_user: illegal user %s", u);
#line 403
      return ((struct passwd *)((void *)0));
    } else {
#line 401
      tmp___0 = allowed_user(pw);
#line 401
      if (! tmp___0) {
#line 402
        log("auth_set_user: illegal user %s", u);
#line 403
        return ((struct passwd *)((void *)0));
      }
    }
#line 406
    start_pam(pw);
#line 408
    copy = & authctxt->pw;
#line 409
    memset((void *)copy, 0, sizeof(*copy));
#line 410
    copy->pw_name = xstrdup((char const   *)pw->pw_name);
#line 411
    copy->pw_passwd = xstrdup((char const   *)pw->pw_passwd);
#line 412
    copy->pw_uid = pw->pw_uid;
#line 413
    copy->pw_gid = pw->pw_gid;
#line 417
    copy->pw_dir = xstrdup((char const   *)pw->pw_dir);
#line 418
    copy->pw_shell = xstrdup((char const   *)pw->pw_shell);
#line 419
    authctxt->valid = 1;
  } else {
#line 421
    if (0) {
#line 421
      __s1_len = strlen((char const   *)u);
#line 421
      __s2_len = strlen((char const   *)authctxt->user);
#line 421
      if (! ((unsigned int )((void const   *)(u + 1)) - (unsigned int )((void const   *)u) == 1U)) {
        goto _L___0;
      } else {
#line 421
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 421
          if (! ((unsigned int )((void const   *)(authctxt->user + 1)) - (unsigned int )((void const   *)authctxt->user) == 1U)) {
#line 421
            tmp___10 = 1;
          } else {
#line 421
            if (__s2_len >= 4U) {
#line 421
              tmp___10 = 1;
            } else {
#line 421
              tmp___10 = 0;
            }
          }
        } else {
#line 421
          tmp___10 = 0;
        }
      }
#line 421
      if (tmp___10) {
#line 421
        tmp___6 = __builtin_strcmp((char const   *)u, (char const   *)authctxt->user);
      } else {
#line 421
        tmp___9 = __builtin_strcmp((char const   *)u, (char const   *)authctxt->user);
#line 421
        tmp___6 = tmp___9;
      }
    } else {
#line 421
      tmp___9 = __builtin_strcmp((char const   *)u, (char const   *)authctxt->user);
#line 421
      tmp___6 = tmp___9;
    }
#line 422
    if (tmp___6 != 0) {
#line 423
      log("auth_set_user: missmatch: (%s,%s)!=(%s,%s)", u, s, authctxt->user, authctxt->service);
#line 425
      return ((struct passwd *)((void *)0));
    } else {
#line 422
      if (0) {
#line 422
        __s1_len___0 = strlen((char const   *)s);
#line 422
        __s2_len___0 = strlen((char const   *)authctxt->service);
#line 422
        if (! ((unsigned int )((void const   *)(s + 1)) - (unsigned int )((void const   *)s) == 1U)) {
          goto _L___2;
        } else {
#line 422
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 422
            if (! ((unsigned int )((void const   *)(authctxt->service + 1)) - (unsigned int )((void const   *)authctxt->service) == 1U)) {
#line 422
              tmp___20 = 1;
            } else {
#line 422
              if (__s2_len___0 >= 4U) {
#line 422
                tmp___20 = 1;
              } else {
#line 422
                tmp___20 = 0;
              }
            }
          } else {
#line 422
            tmp___20 = 0;
          }
        }
#line 422
        if (tmp___20) {
#line 422
          tmp___16 = __builtin_strcmp((char const   *)s, (char const   *)authctxt->service);
        } else {
#line 422
          tmp___19 = __builtin_strcmp((char const   *)s, (char const   *)authctxt->service);
#line 422
          tmp___16 = tmp___19;
        }
      } else {
#line 422
        tmp___19 = __builtin_strcmp((char const   *)s, (char const   *)authctxt->service);
#line 422
        tmp___16 = tmp___19;
      }
#line 422
      if (tmp___16 != 0) {
#line 423
        log("auth_set_user: missmatch: (%s,%s)!=(%s,%s)", u, s, authctxt->user, authctxt->service);
#line 425
        return ((struct passwd *)((void *)0));
      }
    }
  }
#line 428
  tmp___21 = auth_get_user();
#line 428
  return (tmp___21);
}
}
#line 476 "auth2.c"
static char const   *check[3]  = {      "",      ".ssh",      (char const   *)((void *)0)};
#line 432 "auth2.c"
int user_dsa_key_allowed(struct passwd *pw , Key *key ) 
{ char line[8192] ;
  char file[1024] ;
  int found_key ;
  unsigned int bits ;
  FILE *f ;
  unsigned long linenum ;
  struct stat st ;
  Key *found ;
  int tmp ;
  int fail ;
  char buf___1[1024] ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *cp ;
  char *options___0 ;
  int quoted ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
#line 436
  found_key = 0;
#line 437
  bits = 4294967295U;
#line 439
  linenum = 0UL;
#line 444
  temporarily_use_uid(pw->pw_uid);
#line 447
  snprintf((char * __restrict  )(file), sizeof(file), (char const   * __restrict  )"%.500s/%.100s",
           pw->pw_dir, ".ssh/authorized_keys2");
#line 451
  tmp = stat((char const   * __restrict  )(file), (struct stat * __restrict  )(& st));
#line 451
  if (tmp < 0) {
#line 453
    restore_uid();
#line 454
    return (0);
  }
#line 457
  f = fopen((char const   * __restrict  )(file), (char const   * __restrict  )"r");
#line 458
  if (! f) {
#line 460
    restore_uid();
#line 461
    return (0);
  }
#line 463
  if (options.strict_modes) {
#line 464
    fail = 0;
#line 467
    tmp___1 = fileno(f);
#line 467
    tmp___2 = fstat(tmp___1, & st);
#line 467
    if (tmp___2 < 0) {
#line 470
      snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"DSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
               pw->pw_name, file);
#line 472
      fail = 1;
    } else {
#line 467
      if (st.st_uid != 0U) {
#line 467
        if (st.st_uid != pw->pw_uid) {
#line 470
          snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"DSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   pw->pw_name, file);
#line 472
          fail = 1;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 467
        if ((st.st_mode & 18U) != 0U) {
#line 470
          snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"DSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   pw->pw_name, file);
#line 472
          fail = 1;
        } else {
#line 479
          i = 0;
#line 479
          while (check[i]) {
#line 480
            snprintf((char * __restrict  )(line), sizeof(line), (char const   * __restrict  )"%.500s/%.100s",
                     pw->pw_dir, check[i]);
#line 482
            tmp___0 = stat((char const   * __restrict  )(line), (struct stat * __restrict  )(& st));
#line 482
            if (tmp___0 < 0) {
#line 485
              snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"DSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                       pw->pw_name, line);
#line 489
              fail = 1;
#line 490
              break;
            } else {
#line 482
              if (st.st_uid != 0U) {
#line 482
                if (st.st_uid != pw->pw_uid) {
#line 485
                  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"DSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           pw->pw_name, line);
#line 489
                  fail = 1;
#line 490
                  break;
                } else {
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
#line 482
                if ((st.st_mode & 18U) != 0U) {
#line 485
                  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"DSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           pw->pw_name, line);
#line 489
                  fail = 1;
#line 490
                  break;
                }
              }
            }
#line 479
            i ++;
          }
        }
      }
    }
#line 494
    if (fail) {
#line 495
      fclose(f);
#line 496
      log("%s", buf___1);
#line 497
      restore_uid();
#line 498
      return (0);
    }
  }
#line 501
  found_key = 0;
#line 502
  found = key_new(1);
#line 504
  while (1) {
#line 504
    tmp___5 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 504
    if (! tmp___5) {
#line 504
      break;
    }
#line 505
    options___0 = (char *)((void *)0);
#line 506
    linenum ++;
#line 508
    cp = line;
#line 508
    while (1) {
#line 508
      if (! ((int )*cp == 32)) {
#line 508
        if (! ((int )*cp == 9)) {
#line 508
          break;
        }
      }
#line 508
      cp ++;
    }
#line 510
    if (! *cp) {
#line 511
      continue;
    } else {
#line 510
      if ((int )*cp == 10) {
#line 511
        continue;
      } else {
#line 510
        if ((int )*cp == 35) {
#line 511
          continue;
        }
      }
    }
#line 513
    bits = key_read(found, & cp);
#line 514
    if (bits == 0U) {
#line 516
      quoted = 0;
#line 517
      options___0 = cp;
#line 518
      while (1) {
#line 518
        if (*cp) {
#line 518
          if (! quoted) {
#line 518
            if ((int )*cp != 32) {
#line 518
              if (! ((int )*cp != 9)) {
#line 518
                break;
              }
            } else {
#line 518
              break;
            }
          }
        } else {
#line 518
          break;
        }
#line 519
        if ((int )*cp == 92) {
#line 519
          if ((int )*(cp + 1) == 34) {
#line 520
            cp ++;
          } else {
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
#line 521
          if ((int )*cp == 34) {
#line 522
            quoted = ! quoted;
          }
        }
#line 518
        cp ++;
      }
#line 525
      while (1) {
#line 525
        if (! ((int )*cp == 32)) {
#line 525
          if (! ((int )*cp == 9)) {
#line 525
            break;
          }
        }
#line 525
        cp ++;
      }
#line 527
      bits = key_read(found, & cp);
#line 528
      if (bits == 0U) {
#line 530
        continue;
      }
    }
#line 533
    tmp___3 = key_equal(found, key);
#line 533
    if (tmp___3) {
#line 533
      tmp___4 = auth_parse_options(pw, options___0, linenum);
#line 533
      if (tmp___4 == 1) {
#line 535
        found_key = 1;
#line 536
        debug("matching key found: file %s, line %ld", file, linenum);
#line 538
        break;
      }
    }
  }
#line 541
  restore_uid();
#line 542
  fclose(f);
#line 543
  key_free(found);
#line 544
  return (found_key);
}
}
#line 1 "auth-rhosts.o"
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 418 "/usr/include/netdb.h"
extern int innetgr(char const   *__netgroup , char const   *__host , char const   *__user ,
                   char const   *domain ) ;
#line 33 "auth-rhosts.c"
int check_rhosts_file(char const   *filename , char const   *hostname , char const   *ipaddr ,
                      char const   *client_user , char const   *server_user ) 
{ FILE *f ;
  char buf___1[1024] ;
  char hostbuf[1024] ;
  char userbuf[1024] ;
  char dummy[1024] ;
  char *host ;
  char *user ;
  char *cp ;
  int negated ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___45 ;
  int tmp___48 ;
  int tmp___49 ;
  char *tmp___50 ;

  {
#line 42
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 43
  if (! f) {
#line 44
    return (0);
  }
#line 46
  while (1) {
#line 46
    tmp___50 = fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )f);
#line 46
    if (! tmp___50) {
#line 46
      break;
    }
#line 51
    cp = buf___1;
#line 51
    while (1) {
#line 51
      if (! ((int )*cp == 32)) {
#line 51
        if (! ((int )*cp == 9)) {
#line 51
          break;
        }
      }
#line 51
      cp ++;
    }
#line 53
    if ((int )*cp == 35) {
#line 54
      continue;
    } else {
#line 53
      if ((int )*cp == 10) {
#line 54
        continue;
      } else {
#line 53
        if (! *cp) {
#line 54
          continue;
        }
      }
    }
#line 60
    if (0) {
#line 60
      if (0) {
#line 60
        __s1_len___0 = strlen((char const   *)cp);
#line 60
        __s2_len___0 = strlen("NO_PLUS");
#line 60
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___2;
        } else {
#line 60
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 60
            if (! ((unsigned int )((void const   *)("NO_PLUS" + 1)) - (unsigned int )((void const   *)"NO_PLUS") == 1U)) {
#line 60
              tmp___22 = 1;
            } else {
#line 60
              if (__s2_len___0 >= 4U) {
#line 60
                tmp___22 = 1;
              } else {
#line 60
                tmp___22 = 0;
              }
            }
          } else {
#line 60
            tmp___22 = 0;
          }
        }
#line 60
        if (tmp___22) {
#line 60
          tmp___18 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
        } else {
#line 60
          tmp___21 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 60
          tmp___18 = tmp___21;
        }
      } else {
#line 60
        tmp___21 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 60
        tmp___18 = tmp___21;
      }
#line 60
      tmp___12 = tmp___18;
    } else {
#line 60
      tmp___12 = strncmp((char const   *)cp, "NO_PLUS", 7U);
    }
#line 60
    if (tmp___12 == 0) {
#line 61
      continue;
    }
#line 67
    tmp___25 = sscanf((char const   * __restrict  )(buf___1), (char const   * __restrict  )"%s %s %s",
                      hostbuf, userbuf, dummy);
#line 67
    switch (tmp___25) {
    case 0: 
#line 69
    packet_send_debug("Found empty line in %.100s.", filename);
#line 70
    continue;
    case 1: 
#line 73
    strlcpy(userbuf, server_user, sizeof(userbuf));
#line 74
    break;
    case 2: 
#line 77
    break;
    case 3: 
#line 79
    packet_send_debug("Found garbage in %.100s.", filename);
#line 80
    continue;
    default: ;
#line 83
    continue;
    }
#line 86
    host = hostbuf;
#line 87
    user = userbuf;
#line 88
    negated = 0;
#line 91
    if ((int )*(host + 0) == 45) {
#line 92
      negated = 1;
#line 93
      host ++;
    } else {
#line 94
      if ((int )*(host + 0) == 43) {
#line 95
        host ++;
      }
    }
#line 97
    if ((int )*(user + 0) == 45) {
#line 98
      negated = 1;
#line 99
      user ++;
    } else {
#line 100
      if ((int )*(user + 0) == 43) {
#line 101
        user ++;
      }
    }
#line 104
    if (! *(host + 0)) {
#line 106
      packet_send_debug("Ignoring wild host/user names in %.100s.", filename);
#line 108
      continue;
    } else {
#line 104
      if (! *(user + 0)) {
#line 106
        packet_send_debug("Ignoring wild host/user names in %.100s.", filename);
#line 108
        continue;
      }
    }
#line 111
    if ((int )*(host + 0) == 64) {
#line 112
      tmp___26 = innetgr((char const   *)(host + 1), hostname, (char const   *)((void *)0),
                         (char const   *)((void *)0));
#line 112
      if (! tmp___26) {
#line 112
        tmp___27 = innetgr((char const   *)(host + 1), ipaddr, (char const   *)((void *)0),
                           (char const   *)((void *)0));
#line 112
        if (! tmp___27) {
#line 114
          continue;
        }
      }
    } else {
#line 115
      tmp___28 = strcasecmp((char const   *)host, hostname);
#line 115
      if (tmp___28) {
#line 115
        if (0) {
#line 115
          __s1_len___1 = strlen((char const   *)host);
#line 115
          __s2_len___1 = strlen(ipaddr);
#line 115
          if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
            goto _L___4;
          } else {
#line 115
            if (__s1_len___1 >= 4U) {
              _L___4: /* CIL Label */ 
#line 115
              if (! ((unsigned int )((void const   *)(ipaddr + 1)) - (unsigned int )((void const   *)ipaddr) == 1U)) {
#line 115
                tmp___38 = 1;
              } else {
#line 115
                if (__s2_len___1 >= 4U) {
#line 115
                  tmp___38 = 1;
                } else {
#line 115
                  tmp___38 = 0;
                }
              }
            } else {
#line 115
              tmp___38 = 0;
            }
          }
#line 115
          if (tmp___38) {
#line 115
            tmp___34 = __builtin_strcmp((char const   *)host, ipaddr);
          } else {
#line 115
            tmp___37 = __builtin_strcmp((char const   *)host, ipaddr);
#line 115
            tmp___34 = tmp___37;
          }
        } else {
#line 115
          tmp___37 = __builtin_strcmp((char const   *)host, ipaddr);
#line 115
          tmp___34 = tmp___37;
        }
#line 115
        if (tmp___34 != 0) {
#line 116
          continue;
        }
      }
    }
#line 119
    if ((int )*(user + 0) == 64) {
#line 120
      tmp___39 = innetgr((char const   *)(user + 1), (char const   *)((void *)0),
                         client_user, (char const   *)((void *)0));
#line 120
      if (! tmp___39) {
#line 121
        continue;
      }
    } else {
#line 122
      if (0) {
#line 122
        __s1_len___2 = strlen((char const   *)user);
#line 122
        __s2_len___2 = strlen(client_user);
#line 122
        if (! ((unsigned int )((void const   *)(user + 1)) - (unsigned int )((void const   *)user) == 1U)) {
          goto _L___6;
        } else {
#line 122
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 122
            if (! ((unsigned int )((void const   *)(client_user + 1)) - (unsigned int )((void const   *)client_user) == 1U)) {
#line 122
              tmp___49 = 1;
            } else {
#line 122
              if (__s2_len___2 >= 4U) {
#line 122
                tmp___49 = 1;
              } else {
#line 122
                tmp___49 = 0;
              }
            }
          } else {
#line 122
            tmp___49 = 0;
          }
        }
#line 122
        if (tmp___49) {
#line 122
          tmp___45 = __builtin_strcmp((char const   *)user, client_user);
        } else {
#line 122
          tmp___48 = __builtin_strcmp((char const   *)user, client_user);
#line 122
          tmp___45 = tmp___48;
        }
      } else {
#line 122
        tmp___48 = __builtin_strcmp((char const   *)user, client_user);
#line 122
        tmp___45 = tmp___48;
      }
#line 122
      if (tmp___45 != 0) {
#line 123
        continue;
      }
    }
#line 126
    fclose(f);
#line 129
    if (negated) {
#line 130
      packet_send_debug("Matched negative entry in %.100s.", filename);
#line 132
      return (0);
    }
#line 135
    return (1);
  }
#line 139
  fclose(f);
#line 140
  return (0);
}
}
#line 156 "auth-rhosts.c"
static char const   *rhosts_files[3]  = {      ".shosts",      ".rhosts",      (char const   *)((void *)0)};
#line 149 "auth-rhosts.c"
int auth_rhosts(struct passwd *pw , char const   *client_user ) 
{ char buf___1[1024] ;
  char const   *hostname ;
  char const   *ipaddr ;
  struct stat st ;
  unsigned int rhosts_file_index ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 160
  temporarily_use_uid(pw->pw_uid);
#line 166
  rhosts_file_index = 0U;
#line 166
  while (rhosts_files[rhosts_file_index]) {
#line 169
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.500s/%.100s",
             pw->pw_dir, rhosts_files[rhosts_file_index]);
#line 171
    tmp = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )(& st));
#line 171
    if (tmp >= 0) {
#line 172
      break;
    }
#line 166
    rhosts_file_index ++;
  }
#line 175
  restore_uid();
#line 178
  if (! rhosts_files[rhosts_file_index]) {
#line 178
    tmp___0 = stat((char const   * __restrict  )"/etc/hosts.equiv", (struct stat * __restrict  )(& st));
#line 178
    if (tmp___0 < 0) {
#line 178
      tmp___1 = stat((char const   * __restrict  )"/usr/local/etc/shosts.equiv", (struct stat * __restrict  )(& st));
#line 178
      if (tmp___1 < 0) {
#line 181
        return (0);
      }
    }
  }
#line 183
  hostname = get_canonical_hostname();
#line 184
  ipaddr = get_remote_ipaddr();
#line 187
  if (pw->pw_uid != 0U) {
#line 188
    tmp___2 = check_rhosts_file("/etc/hosts.equiv", hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 188
    if (tmp___2) {
#line 190
      packet_send_debug("Accepted for %.100s [%.100s] by /etc/hosts.equiv.", hostname,
                        ipaddr);
#line 192
      return (1);
    }
#line 194
    tmp___3 = check_rhosts_file("/usr/local/etc/shosts.equiv", hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 194
    if (tmp___3) {
#line 196
      packet_send_debug("Accepted for %.100s [%.100s] by %.100s.", hostname, ipaddr,
                        "/usr/local/etc/shosts.equiv");
#line 198
      return (1);
    }
  }
#line 205
  tmp___4 = stat((char const   * __restrict  )pw->pw_dir, (struct stat * __restrict  )(& st));
#line 205
  if (tmp___4 < 0) {
#line 206
    log("Rhosts authentication refused for %.100s: no home directory %.200s", pw->pw_name,
        pw->pw_dir);
#line 208
    packet_send_debug("Rhosts authentication refused for %.100s: no home directory %.200s",
                      pw->pw_name, pw->pw_dir);
#line 210
    return (0);
  }
#line 212
  if (options.strict_modes) {
#line 212
    if (st.st_uid != 0U) {
#line 212
      if (st.st_uid != pw->pw_uid) {
#line 215
        log("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
            pw->pw_name);
#line 217
        packet_send_debug("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                          pw->pw_name);
#line 219
        return (0);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 212
      if ((st.st_mode & 18U) != 0U) {
#line 215
        log("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
            pw->pw_name);
#line 217
        packet_send_debug("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                          pw->pw_name);
#line 219
        return (0);
      }
    }
  }
#line 222
  temporarily_use_uid(pw->pw_uid);
#line 225
  rhosts_file_index = 0U;
#line 225
  while (rhosts_files[rhosts_file_index]) {
#line 228
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.500s/%.100s",
             pw->pw_dir, rhosts_files[rhosts_file_index]);
#line 230
    tmp___5 = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )(& st));
#line 230
    if (tmp___5 < 0) {
      goto __Cont;
    }
#line 239
    if (options.strict_modes) {
#line 239
      if (st.st_uid != 0U) {
#line 239
        if (st.st_uid != pw->pw_uid) {
#line 242
          log("Rhosts authentication refused for %.100s: bad modes for %.200s", pw->pw_name,
              buf___1);
#line 244
          packet_send_debug("Bad file modes for %.200s", buf___1);
          goto __Cont;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 239
        if ((st.st_mode & 18U) != 0U) {
#line 242
          log("Rhosts authentication refused for %.100s: bad modes for %.200s", pw->pw_name,
              buf___1);
#line 244
          packet_send_debug("Bad file modes for %.200s", buf___1);
          goto __Cont;
        }
      }
    }
#line 248
    if (options.ignore_rhosts) {
#line 249
      packet_send_debug("Server has been configured to ignore %.100s.", rhosts_files[rhosts_file_index]);
      goto __Cont;
    }
#line 254
    tmp___6 = check_rhosts_file((char const   *)(buf___1), hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 254
    if (tmp___6) {
#line 255
      packet_send_debug("Accepted by %.100s.", rhosts_files[rhosts_file_index]);
#line 258
      restore_uid();
#line 259
      return (1);
    }
    __Cont: /* CIL Label */ 
#line 225
    rhosts_file_index ++;
  }
#line 264
  restore_uid();
#line 265
  return (0);
}
}
#line 1 "auth-options.o"
#line 10 "auth-options.c"
int no_port_forwarding_flag  =    0;
#line 11 "auth-options.c"
int no_agent_forwarding_flag  =    0;
#line 12 "auth-options.c"
int no_x11_forwarding_flag  =    0;
#line 13 "auth-options.c"
int no_pty_flag  =    0;
#line 16 "auth-options.c"
char *forced_command  =    (char *)((void *)0);
#line 19 "auth-options.c"
struct envstring *custom_environment  =    (struct envstring *)((void *)0);
#line 22 "auth-options.c"
int auth_parse_options(struct passwd *pw , char *options___0 , unsigned long linenum ) 
{ char const   *cp ;
  size_t tmp ;
  int tmp___17 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___23 ;
  int tmp___26 ;
  int tmp___27 ;
  size_t tmp___28 ;
  size_t tmp___34 ;
  int tmp___52 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___58 ;
  int tmp___61 ;
  int tmp___62 ;
  size_t tmp___63 ;
  size_t tmp___69 ;
  int tmp___87 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___93 ;
  int tmp___96 ;
  int tmp___97 ;
  size_t tmp___98 ;
  size_t tmp___104 ;
  int tmp___122 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___128 ;
  int tmp___131 ;
  int tmp___132 ;
  size_t tmp___133 ;
  int i ;
  size_t tmp___139 ;
  size_t tmp___140 ;
  void *tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  char *tmp___144 ;
  int tmp___162 ;
  size_t __s1_len___8 ;
  size_t __s2_len___8 ;
  int tmp___168 ;
  int tmp___171 ;
  int tmp___172 ;
  size_t tmp___173 ;
  int i___0 ;
  char *s ;
  struct envstring *new_envstring ;
  size_t tmp___179 ;
  size_t tmp___180 ;
  void *tmp___181 ;
  int tmp___182 ;
  int tmp___183 ;
  char *tmp___184 ;
  void *tmp___185 ;
  int tmp___203 ;
  size_t __s1_len___10 ;
  size_t __s2_len___10 ;
  int tmp___209 ;
  int tmp___212 ;
  int tmp___213 ;
  size_t tmp___214 ;
  int mname ;
  int mip ;
  char *patterns ;
  size_t tmp___220 ;
  void *tmp___221 ;
  int i___1 ;
  size_t tmp___222 ;
  int tmp___223 ;
  int tmp___224 ;
  char *tmp___225 ;
  size_t tmp___226 ;
  char const   *tmp___227 ;
  size_t tmp___228 ;
  char const   *tmp___229 ;
  char const   *tmp___230 ;
  char const   *tmp___231 ;
  char const   *tmp___232 ;
  struct envstring *ce ;
  int tmp___250 ;
  size_t __s1_len___12 ;
  size_t __s2_len___12 ;
  int tmp___256 ;
  int tmp___259 ;
  int tmp___260 ;
  size_t tmp___261 ;

  {
#line 26
  if (! options___0) {
#line 27
    return (1);
  }
#line 28
  while (1) {
#line 28
    if (*options___0) {
#line 28
      if ((int )*options___0 != 32) {
#line 28
        if (! ((int )*options___0 != 9)) {
#line 28
          break;
        }
      } else {
#line 28
        break;
      }
    } else {
#line 28
      break;
    }
#line 29
    cp = "no-port-forwarding";
#line 30
    if (0) {
#line 30
      if (0) {
#line 30
        __s1_len___0 = strlen((char const   *)options___0);
#line 30
        __s2_len___0 = strlen(cp);
#line 30
        if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
          goto _L___2;
        } else {
#line 30
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 30
            if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 30
              tmp___27 = 1;
            } else {
#line 30
              if (__s2_len___0 >= 4U) {
#line 30
                tmp___27 = 1;
              } else {
#line 30
                tmp___27 = 0;
              }
            }
          } else {
#line 30
            tmp___27 = 0;
          }
        }
#line 30
        if (tmp___27) {
#line 30
          tmp___23 = __builtin_strcmp((char const   *)options___0, cp);
        } else {
#line 30
          tmp___26 = __builtin_strcmp((char const   *)options___0, cp);
#line 30
          tmp___23 = tmp___26;
        }
      } else {
#line 30
        tmp___26 = __builtin_strcmp((char const   *)options___0, cp);
#line 30
        tmp___23 = tmp___26;
      }
#line 30
      tmp___17 = tmp___23;
    } else {
#line 30
      tmp___28 = strlen(cp);
#line 30
      tmp___17 = strncmp((char const   *)options___0, cp, tmp___28);
    }
#line 30
    if (tmp___17 == 0) {
#line 31
      packet_send_debug("Port forwarding disabled.");
#line 32
      no_port_forwarding_flag = 1;
#line 33
      tmp = strlen(cp);
#line 33
      options___0 += tmp;
      goto next_option;
    }
#line 36
    cp = "no-agent-forwarding";
#line 37
    if (0) {
#line 37
      if (0) {
#line 37
        __s1_len___2 = strlen((char const   *)options___0);
#line 37
        __s2_len___2 = strlen(cp);
#line 37
        if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
          goto _L___6;
        } else {
#line 37
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 37
            if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 37
              tmp___62 = 1;
            } else {
#line 37
              if (__s2_len___2 >= 4U) {
#line 37
                tmp___62 = 1;
              } else {
#line 37
                tmp___62 = 0;
              }
            }
          } else {
#line 37
            tmp___62 = 0;
          }
        }
#line 37
        if (tmp___62) {
#line 37
          tmp___58 = __builtin_strcmp((char const   *)options___0, cp);
        } else {
#line 37
          tmp___61 = __builtin_strcmp((char const   *)options___0, cp);
#line 37
          tmp___58 = tmp___61;
        }
      } else {
#line 37
        tmp___61 = __builtin_strcmp((char const   *)options___0, cp);
#line 37
        tmp___58 = tmp___61;
      }
#line 37
      tmp___52 = tmp___58;
    } else {
#line 37
      tmp___63 = strlen(cp);
#line 37
      tmp___52 = strncmp((char const   *)options___0, cp, tmp___63);
    }
#line 37
    if (tmp___52 == 0) {
#line 38
      packet_send_debug("Agent forwarding disabled.");
#line 39
      no_agent_forwarding_flag = 1;
#line 40
      tmp___34 = strlen(cp);
#line 40
      options___0 += tmp___34;
      goto next_option;
    }
#line 43
    cp = "no-X11-forwarding";
#line 44
    if (0) {
#line 44
      if (0) {
#line 44
        __s1_len___4 = strlen((char const   *)options___0);
#line 44
        __s2_len___4 = strlen(cp);
#line 44
        if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
          goto _L___10;
        } else {
#line 44
          if (__s1_len___4 >= 4U) {
            _L___10: /* CIL Label */ 
#line 44
            if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 44
              tmp___97 = 1;
            } else {
#line 44
              if (__s2_len___4 >= 4U) {
#line 44
                tmp___97 = 1;
              } else {
#line 44
                tmp___97 = 0;
              }
            }
          } else {
#line 44
            tmp___97 = 0;
          }
        }
#line 44
        if (tmp___97) {
#line 44
          tmp___93 = __builtin_strcmp((char const   *)options___0, cp);
        } else {
#line 44
          tmp___96 = __builtin_strcmp((char const   *)options___0, cp);
#line 44
          tmp___93 = tmp___96;
        }
      } else {
#line 44
        tmp___96 = __builtin_strcmp((char const   *)options___0, cp);
#line 44
        tmp___93 = tmp___96;
      }
#line 44
      tmp___87 = tmp___93;
    } else {
#line 44
      tmp___98 = strlen(cp);
#line 44
      tmp___87 = strncmp((char const   *)options___0, cp, tmp___98);
    }
#line 44
    if (tmp___87 == 0) {
#line 45
      packet_send_debug("X11 forwarding disabled.");
#line 46
      no_x11_forwarding_flag = 1;
#line 47
      tmp___69 = strlen(cp);
#line 47
      options___0 += tmp___69;
      goto next_option;
    }
#line 50
    cp = "no-pty";
#line 51
    if (0) {
#line 51
      if (0) {
#line 51
        __s1_len___6 = strlen((char const   *)options___0);
#line 51
        __s2_len___6 = strlen(cp);
#line 51
        if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
          goto _L___14;
        } else {
#line 51
          if (__s1_len___6 >= 4U) {
            _L___14: /* CIL Label */ 
#line 51
            if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 51
              tmp___132 = 1;
            } else {
#line 51
              if (__s2_len___6 >= 4U) {
#line 51
                tmp___132 = 1;
              } else {
#line 51
                tmp___132 = 0;
              }
            }
          } else {
#line 51
            tmp___132 = 0;
          }
        }
#line 51
        if (tmp___132) {
#line 51
          tmp___128 = __builtin_strcmp((char const   *)options___0, cp);
        } else {
#line 51
          tmp___131 = __builtin_strcmp((char const   *)options___0, cp);
#line 51
          tmp___128 = tmp___131;
        }
      } else {
#line 51
        tmp___131 = __builtin_strcmp((char const   *)options___0, cp);
#line 51
        tmp___128 = tmp___131;
      }
#line 51
      tmp___122 = tmp___128;
    } else {
#line 51
      tmp___133 = strlen(cp);
#line 51
      tmp___122 = strncmp((char const   *)options___0, cp, tmp___133);
    }
#line 51
    if (tmp___122 == 0) {
#line 52
      packet_send_debug("Pty allocation disabled.");
#line 53
      no_pty_flag = 1;
#line 54
      tmp___104 = strlen(cp);
#line 54
      options___0 += tmp___104;
      goto next_option;
    }
#line 57
    cp = "command=\"";
#line 58
    if (0) {
#line 58
      if (0) {
#line 58
        __s1_len___8 = strlen((char const   *)options___0);
#line 58
        __s2_len___8 = strlen(cp);
#line 58
        if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
          goto _L___18;
        } else {
#line 58
          if (__s1_len___8 >= 4U) {
            _L___18: /* CIL Label */ 
#line 58
            if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 58
              tmp___172 = 1;
            } else {
#line 58
              if (__s2_len___8 >= 4U) {
#line 58
                tmp___172 = 1;
              } else {
#line 58
                tmp___172 = 0;
              }
            }
          } else {
#line 58
            tmp___172 = 0;
          }
        }
#line 58
        if (tmp___172) {
#line 58
          tmp___168 = __builtin_strcmp((char const   *)options___0, cp);
        } else {
#line 58
          tmp___171 = __builtin_strcmp((char const   *)options___0, cp);
#line 58
          tmp___168 = tmp___171;
        }
      } else {
#line 58
        tmp___171 = __builtin_strcmp((char const   *)options___0, cp);
#line 58
        tmp___168 = tmp___171;
      }
#line 58
      tmp___162 = tmp___168;
    } else {
#line 58
      tmp___173 = strlen(cp);
#line 58
      tmp___162 = strncmp((char const   *)options___0, cp, tmp___173);
    }
#line 58
    if (tmp___162 == 0) {
#line 60
      tmp___139 = strlen(cp);
#line 60
      options___0 += tmp___139;
#line 61
      tmp___140 = strlen((char const   *)options___0);
#line 61
      tmp___141 = xmalloc(tmp___140 + 1U);
#line 61
      forced_command = (char *)tmp___141;
#line 62
      i = 0;
#line 63
      while (*options___0) {
#line 64
        if ((int )*options___0 == 34) {
#line 65
          break;
        }
#line 66
        if ((int )*options___0 == 92) {
#line 66
          if ((int )*(options___0 + 1) == 34) {
#line 67
            options___0 += 2;
#line 68
            tmp___142 = i;
#line 68
            i ++;
#line 68
            *(forced_command + tmp___142) = (char )'\"';
#line 69
            continue;
          }
        }
#line 71
        tmp___143 = i;
#line 71
        i ++;
#line 71
        tmp___144 = options___0;
#line 71
        options___0 ++;
#line 71
        *(forced_command + tmp___143) = *tmp___144;
      }
#line 73
      if (! *options___0) {
#line 74
        debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys", linenum);
#line 76
        packet_send_debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys",
                          linenum);
#line 78
        continue;
      }
#line 80
      *(forced_command + i) = (char)0;
#line 81
      packet_send_debug("Forced command: %.900s", forced_command);
#line 82
      options___0 ++;
      goto next_option;
    }
#line 85
    cp = "environment=\"";
#line 86
    if (0) {
#line 86
      if (0) {
#line 86
        __s1_len___10 = strlen((char const   *)options___0);
#line 86
        __s2_len___10 = strlen(cp);
#line 86
        if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
          goto _L___22;
        } else {
#line 86
          if (__s1_len___10 >= 4U) {
            _L___22: /* CIL Label */ 
#line 86
            if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 86
              tmp___213 = 1;
            } else {
#line 86
              if (__s2_len___10 >= 4U) {
#line 86
                tmp___213 = 1;
              } else {
#line 86
                tmp___213 = 0;
              }
            }
          } else {
#line 86
            tmp___213 = 0;
          }
        }
#line 86
        if (tmp___213) {
#line 86
          tmp___209 = __builtin_strcmp((char const   *)options___0, cp);
        } else {
#line 86
          tmp___212 = __builtin_strcmp((char const   *)options___0, cp);
#line 86
          tmp___209 = tmp___212;
        }
      } else {
#line 86
        tmp___212 = __builtin_strcmp((char const   *)options___0, cp);
#line 86
        tmp___209 = tmp___212;
      }
#line 86
      tmp___203 = tmp___209;
    } else {
#line 86
      tmp___214 = strlen(cp);
#line 86
      tmp___203 = strncmp((char const   *)options___0, cp, tmp___214);
    }
#line 86
    if (tmp___203 == 0) {
#line 90
      tmp___179 = strlen(cp);
#line 90
      options___0 += tmp___179;
#line 91
      tmp___180 = strlen((char const   *)options___0);
#line 91
      tmp___181 = xmalloc(tmp___180 + 1U);
#line 91
      s = (char *)tmp___181;
#line 92
      i___0 = 0;
#line 93
      while (*options___0) {
#line 94
        if ((int )*options___0 == 34) {
#line 95
          break;
        }
#line 96
        if ((int )*options___0 == 92) {
#line 96
          if ((int )*(options___0 + 1) == 34) {
#line 97
            options___0 += 2;
#line 98
            tmp___182 = i___0;
#line 98
            i___0 ++;
#line 98
            *(s + tmp___182) = (char )'\"';
#line 99
            continue;
          }
        }
#line 101
        tmp___183 = i___0;
#line 101
        i___0 ++;
#line 101
        tmp___184 = options___0;
#line 101
        options___0 ++;
#line 101
        *(s + tmp___183) = *tmp___184;
      }
#line 103
      if (! *options___0) {
#line 104
        debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys", linenum);
#line 106
        packet_send_debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys",
                          linenum);
#line 108
        continue;
      }
#line 110
      *(s + i___0) = (char)0;
#line 111
      packet_send_debug("Adding to environment: %.900s", s);
#line 112
      debug("Adding to environment: %.900s", s);
#line 113
      options___0 ++;
#line 114
      tmp___185 = xmalloc(sizeof(struct envstring ));
#line 114
      new_envstring = (struct envstring *)tmp___185;
#line 115
      new_envstring->s = s;
#line 116
      new_envstring->next = custom_environment;
#line 117
      custom_environment = new_envstring;
      goto next_option;
    }
#line 120
    cp = "from=\"";
#line 121
    if (0) {
#line 121
      if (0) {
#line 121
        __s1_len___12 = strlen((char const   *)options___0);
#line 121
        __s2_len___12 = strlen(cp);
#line 121
        if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
          goto _L___27;
        } else {
#line 121
          if (__s1_len___12 >= 4U) {
            _L___27: /* CIL Label */ 
#line 121
            if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 121
              tmp___260 = 1;
            } else {
#line 121
              if (__s2_len___12 >= 4U) {
#line 121
                tmp___260 = 1;
              } else {
#line 121
                tmp___260 = 0;
              }
            }
          } else {
#line 121
            tmp___260 = 0;
          }
        }
#line 121
        if (tmp___260) {
#line 121
          tmp___256 = __builtin_strcmp((char const   *)options___0, cp);
        } else {
#line 121
          tmp___259 = __builtin_strcmp((char const   *)options___0, cp);
#line 121
          tmp___256 = tmp___259;
        }
      } else {
#line 121
        tmp___259 = __builtin_strcmp((char const   *)options___0, cp);
#line 121
        tmp___256 = tmp___259;
      }
#line 121
      tmp___250 = tmp___256;
    } else {
#line 121
      tmp___261 = strlen(cp);
#line 121
      tmp___250 = strncmp((char const   *)options___0, cp, tmp___261);
    }
#line 121
    if (tmp___250 == 0) {
#line 123
      tmp___220 = strlen((char const   *)options___0);
#line 123
      tmp___221 = xmalloc(tmp___220 + 1U);
#line 123
      patterns = (char *)tmp___221;
#line 125
      tmp___222 = strlen(cp);
#line 125
      options___0 += tmp___222;
#line 126
      i___1 = 0;
#line 127
      while (*options___0) {
#line 128
        if ((int )*options___0 == 34) {
#line 129
          break;
        }
#line 130
        if ((int )*options___0 == 92) {
#line 130
          if ((int )*(options___0 + 1) == 34) {
#line 131
            options___0 += 2;
#line 132
            tmp___223 = i___1;
#line 132
            i___1 ++;
#line 132
            *(patterns + tmp___223) = (char )'\"';
#line 133
            continue;
          }
        }
#line 135
        tmp___224 = i___1;
#line 135
        i___1 ++;
#line 135
        tmp___225 = options___0;
#line 135
        options___0 ++;
#line 135
        *(patterns + tmp___224) = *tmp___225;
      }
#line 137
      if (! *options___0) {
#line 138
        debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys", linenum);
#line 140
        packet_send_debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys",
                          linenum);
#line 142
        continue;
      }
#line 144
      *(patterns + i___1) = (char)0;
#line 145
      options___0 ++;
#line 151
      tmp___226 = strlen((char const   *)patterns);
#line 151
      tmp___227 = get_canonical_hostname();
#line 151
      mname = match_hostname(tmp___227, (char const   *)patterns, tmp___226);
#line 153
      tmp___228 = strlen((char const   *)patterns);
#line 153
      tmp___229 = get_remote_ipaddr();
#line 153
      mip = match_hostname(tmp___229, (char const   *)patterns, tmp___228);
#line 155
      xfree((void *)patterns);
#line 156
      if (mname == -1) {
        goto _L___23;
      } else {
#line 156
        if (mip == -1) {
          goto _L___23;
        } else {
#line 156
          if (mname != 1) {
#line 156
            if (mip != 1) {
              _L___23: /* CIL Label */ 
#line 158
              tmp___230 = get_remote_ipaddr();
#line 158
              tmp___231 = get_canonical_hostname();
#line 158
              log("Authentication tried for %.100s with correct key but not from a permitted host (host=%.200s, ip=%.200s).",
                  pw->pw_name, tmp___231, tmp___230);
#line 161
              tmp___232 = get_canonical_hostname();
#line 161
              packet_send_debug("Your host \'%.200s\' is not permitted to use this key for login.",
                                tmp___232);
#line 164
              no_agent_forwarding_flag = 0;
#line 165
              no_port_forwarding_flag = 0;
#line 166
              no_pty_flag = 0;
#line 167
              no_x11_forwarding_flag = 0;
#line 168
              while (custom_environment) {
#line 169
                ce = custom_environment;
#line 170
                custom_environment = ce->next;
#line 171
                xfree((void *)ce->s);
#line 172
                xfree((void *)ce);
              }
#line 174
              if (forced_command) {
#line 175
                xfree((void *)forced_command);
#line 176
                forced_command = (char *)((void *)0);
              }
#line 179
              return (0);
            }
          }
        }
      }
      goto next_option;
    }
    next_option: 
#line 189
    if (! *options___0) {
#line 190
      fatal("Bugs in auth-options.c option processing.");
    }
#line 191
    if ((int )*options___0 == 32) {
#line 192
      break;
    } else {
#line 191
      if ((int )*options___0 == 9) {
#line 192
        break;
      }
    }
#line 193
    if ((int )*options___0 != 44) {
      goto bad_option;
    }
#line 195
    options___0 ++;
  }
#line 199
  return (1);
  bad_option: 
#line 202
  log("Bad options in %.100s file, line %lu: %.50s", ".ssh/authorized_keys", linenum,
      options___0);
#line 204
  packet_send_debug("Bad options in %.100s file, line %lu: %.50s", ".ssh/authorized_keys",
                    linenum, options___0);
#line 207
  return (0);
}
}
#line 1 "auth-krb4.o"
#line 1 "auth-pam.o"
#line 590 "/usr/include/stdio.h"
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 167 "/usr/include/security/_pam_types.h"
extern int __attribute__((__nonnull__(1)))  pam_set_item(pam_handle_t *pamh , int item_type ,
                                                         void const   *item ) ;
#line 173
extern char const   *pam_strerror(pam_handle_t *pamh , int errnum ) ;
#line 182
extern char ** __attribute__((__nonnull__(1))) pam_getenvlist(pam_handle_t *pamh ) ;
#line 22 "/usr/include/security/pam_appl.h"
extern int __attribute__((__nonnull__(1,3,4)))  pam_start(char const   *service_name ,
                                                          char const   *user , struct pam_conv  const  *pam_conversation ,
                                                          pam_handle_t **pamh ) ;
#line 27
extern int __attribute__((__nonnull__(1)))  pam_end(pam_handle_t *pamh , int pam_status ) ;
#line 32
extern int __attribute__((__nonnull__(1)))  pam_authenticate(pam_handle_t *pamh ,
                                                             int flags ) ;
#line 35
extern int __attribute__((__nonnull__(1)))  pam_setcred(pam_handle_t *pamh , int flags ) ;
#line 40
extern int __attribute__((__nonnull__(1)))  pam_acct_mgmt(pam_handle_t *pamh , int flags ) ;
#line 45
extern int __attribute__((__nonnull__(1)))  pam_open_session(pam_handle_t *pamh ,
                                                             int flags ) ;
#line 48
extern int __attribute__((__nonnull__(1)))  pam_close_session(pam_handle_t *pamh ,
                                                              int flags ) ;
#line 9 "auth-pam.h"
char **fetch_pam_environment(void) ;
#line 11
void do_pam_session(char *username , char const   *ttyname___0 ) ;
#line 12
void do_pam_setcred(void) ;
#line 13
void print_pam_messages(void) ;
#line 43 "auth-pam.c"
static int pamconv(int num_msg , struct pam_message  const  **msg , struct pam_response **resp ,
                   void *appdata_ptr ) ;
#line 45
void pam_cleanup_proc(void *context ) ;
#line 46
void pam_msg_cat(char const   *msg ) ;
#line 49 "auth-pam.c"
static struct pam_conv conv  =    {& pamconv, (void *)0};
#line 53 "auth-pam.c"
static struct pam_handle_t *pamh  =    (struct pam_handle_t *)((void *)0);
#line 54 "auth-pam.c"
static char const   *pampasswd  =    (char const   *)((void *)0);
#line 55 "auth-pam.c"
static char *pam_msg  =    (char *)((void *)0);
#line 59 "auth-pam.c"
static int pamconv(int num_msg , struct pam_message  const  **msg , struct pam_response **resp ,
                   void *appdata_ptr ) 
{ struct pam_response *reply ;
  int count ;
  void *tmp ;

  {
#line 66
  tmp = malloc((unsigned int )num_msg * sizeof(*reply));
#line 66
  reply = (struct pam_response *)tmp;
#line 67
  if ((unsigned int )reply == (unsigned int )((void *)0)) {
#line 68
    return (19);
  }
#line 70
  count = 0;
#line 70
  while (count < num_msg) {
#line 71
    switch ((int )(*(msg + count))->msg_style) {
    case 1: 
#line 73
    if ((unsigned int )pampasswd == (unsigned int )((void *)0)) {
#line 74
      free((void *)reply);
#line 75
      return (19);
    }
#line 77
    (reply + count)->resp_retcode = 0;
#line 78
    (reply + count)->resp = xstrdup(pampasswd);
#line 79
    break;
    case 4: 
#line 81
    (reply + count)->resp_retcode = 0;
#line 82
    (reply + count)->resp = xstrdup("");
#line 84
    if ((unsigned int )(*(msg + count))->msg != (unsigned int )((void *)0)) {
#line 85
      pam_msg_cat((char const   *)(*(msg + count))->msg);
    }
#line 87
    break;
    default: 
#line 89
    free((void *)reply);
#line 90
    return (19);
    }
#line 70
    count ++;
  }
#line 94
  *resp = reply;
#line 96
  return (0);
}
}
#line 100 "auth-pam.c"
void pam_cleanup_proc(void *context ) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1)))  tmp ;
  char const   *tmp___0 ;
  int __attribute__((__nonnull__(1)))  tmp___1 ;
  char const   *tmp___2 ;
  int __attribute__((__nonnull__(1)))  tmp___3 ;
  char const   *tmp___4 ;

  {
#line 104
  if ((unsigned int )pamh != (unsigned int )((void *)0)) {
#line 106
    tmp = pam_close_session((pam_handle_t *)pamh, 0);
#line 106
    pam_retval = (int )tmp;
#line 107
    if (pam_retval != 0) {
#line 108
      tmp___0 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 108
      log("Cannot close PAM session: %.200s", tmp___0);
    }
#line 112
    tmp___1 = pam_setcred((pam_handle_t *)pamh, 4);
#line 112
    pam_retval = (int )tmp___1;
#line 113
    if (pam_retval != 0) {
#line 114
      tmp___2 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 114
      debug("Cannot delete credentials: %.200s", tmp___2);
    }
#line 118
    tmp___3 = pam_end((pam_handle_t *)pamh, pam_retval);
#line 118
    pam_retval = (int )tmp___3;
#line 119
    if (pam_retval != 0) {
#line 120
      tmp___4 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 120
      log("Cannot release PAM authentication: %.200s", tmp___4);
    }
  }
#line 124
  return;
}
}
#line 127 "auth-pam.c"
int auth_pam_password(struct passwd *pw , char const   *password ) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1)))  tmp ;
  char const   *tmp___0 ;

  {
#line 133
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 134
    return (0);
  }
#line 135
  if (pw->pw_uid == 0U) {
#line 135
    if (options.permit_root_login == 2) {
#line 136
      return (0);
    }
  }
#line 137
  if ((int const   )*password == 0) {
#line 137
    if (options.permit_empty_passwd == 0) {
#line 138
      return (0);
    }
  }
#line 140
  pampasswd = password;
#line 142
  tmp = pam_authenticate((pam_handle_t *)pamh, 0);
#line 142
  pam_retval = (int )tmp;
#line 143
  if (pam_retval == 0) {
#line 144
    debug("PAM Password authentication accepted for user \"%.100s\"", pw->pw_name);
#line 146
    return (1);
  } else {
#line 148
    tmp___0 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 148
    debug("PAM Password authentication for \"%.100s\" failed: %s", pw->pw_name, tmp___0);
#line 150
    return (0);
  }
}
}
#line 155 "auth-pam.c"
int do_pam_account(char *username , char *remote_user ) 
{ int pam_retval ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int __attribute__((__nonnull__(1)))  tmp___1 ;
  char const   *tmp___2 ;
  int __attribute__((__nonnull__(1)))  tmp___3 ;
  char const   *tmp___4 ;
  int __attribute__((__nonnull__(1)))  tmp___5 ;
  char const   *tmp___6 ;

  {
#line 159
  tmp = get_canonical_hostname();
#line 159
  debug("PAM setting rhost to \"%.200s\"", tmp);
#line 160
  tmp___0 = get_canonical_hostname();
#line 160
  tmp___1 = pam_set_item((pam_handle_t *)pamh, 4, (void const   *)tmp___0);
#line 160
  pam_retval = (int )tmp___1;
#line 162
  if (pam_retval != 0) {
#line 163
    tmp___2 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 163
    fatal("PAM set rhost failed: %.200s", tmp___2);
  }
#line 167
  if ((unsigned int )remote_user != (unsigned int )((void *)0)) {
#line 168
    debug("PAM setting ruser to \"%.200s\"", remote_user);
#line 169
    tmp___3 = pam_set_item((pam_handle_t *)pamh, 8, (void const   *)remote_user);
#line 169
    pam_retval = (int )tmp___3;
#line 170
    if (pam_retval != 0) {
#line 171
      tmp___4 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 171
      fatal("PAM set ruser failed: %.200s", tmp___4);
    }
  }
#line 176
  tmp___5 = pam_acct_mgmt((pam_handle_t *)pamh, 0);
#line 176
  pam_retval = (int )tmp___5;
#line 177
  switch (pam_retval) {
  case 0: 
#line 180
  break;
  case 12: 
#line 182
  pam_msg_cat("Warning: You password has expired, please change it now");
#line 183
  break;
  default: 
#line 185
  tmp___6 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 185
  log("PAM rejected by account configuration: %.200s", tmp___6);
#line 187
  return (0);
  }
#line 190
  return (1);
}
}
#line 194 "auth-pam.c"
void do_pam_session(char *username , char const   *ttyname___0 ) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1)))  tmp ;
  char const   *tmp___0 ;
  int __attribute__((__nonnull__(1)))  tmp___1 ;
  char const   *tmp___2 ;

  {
#line 198
  if ((unsigned int )ttyname___0 != (unsigned int )((void *)0)) {
#line 199
    debug("PAM setting tty to \"%.200s\"", ttyname___0);
#line 200
    tmp = pam_set_item((pam_handle_t *)pamh, 3, (void const   *)ttyname___0);
#line 200
    pam_retval = (int )tmp;
#line 201
    if (pam_retval != 0) {
#line 202
      tmp___0 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 202
      fatal("PAM set tty failed: %.200s", tmp___0);
    }
  }
#line 207
  tmp___1 = pam_open_session((pam_handle_t *)pamh, 0);
#line 207
  pam_retval = (int )tmp___1;
#line 208
  if (pam_retval != 0) {
#line 209
    tmp___2 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 209
    fatal("PAM session setup failed: %.200s", tmp___2);
  }
#line 212
  return;
}
}
#line 215 "auth-pam.c"
void do_pam_setcred(void) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1)))  tmp ;
  char const   *tmp___0 ;

  {
#line 219
  debug("PAM establishing creds");
#line 220
  tmp = pam_setcred((pam_handle_t *)pamh, 2);
#line 220
  pam_retval = (int )tmp;
#line 221
  if (pam_retval != 0) {
#line 222
    tmp___0 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 222
    fatal("PAM setcred failed: %.200s", tmp___0);
  }
#line 225
  return;
}
}
#line 228 "auth-pam.c"
void finish_pam(void) 
{ 

  {
#line 230
  pam_cleanup_proc((void *)0);
#line 231
  fatal_remove_cleanup(& pam_cleanup_proc, (void *)0);
#line 232
  return;
}
}
#line 235 "auth-pam.c"
void start_pam(struct passwd *pw ) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1,3,4)))  tmp ;
  char const   *tmp___0 ;
  int __attribute__((__nonnull__(1)))  tmp___1 ;
  char const   *tmp___2 ;

  {
#line 239
  debug("Starting up PAM with username \"%.200s\"", pw->pw_name);
#line 241
  tmp = pam_start("sshd", (char const   *)pw->pw_name, (struct pam_conv  const  *)(& conv),
                  (pam_handle_t **)(& pamh));
#line 241
  pam_retval = (int )tmp;
#line 244
  if (pam_retval != 0) {
#line 245
    tmp___0 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 245
    fatal("PAM initialisation failed: %.200s", tmp___0);
  }
#line 257
  tmp___1 = pam_set_item((pam_handle_t *)pamh, 3, (void const   *)"ssh");
#line 257
  pam_retval = (int )tmp___1;
#line 258
  if (pam_retval != 0) {
#line 259
    tmp___2 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 259
    fatal("PAM set tty failed: %.200s", tmp___2);
  }
#line 264
  fatal_add_cleanup(& pam_cleanup_proc, (void *)0);
#line 265
  return;
}
}
#line 268 "auth-pam.c"
char **fetch_pam_environment(void) 
{ char ** __attribute__((__nonnull__(1))) tmp ;

  {
#line 271
  tmp = pam_getenvlist((pam_handle_t *)pamh);
#line 271
  return ((char **)tmp);
}
}
#line 279 "auth-pam.c"
void print_pam_messages(void) 
{ 

  {
#line 281
  if ((unsigned int )pam_msg != (unsigned int )((void *)0)) {
#line 282
    fputs((char const   * __restrict  )pam_msg, (FILE * __restrict  )stderr);
  }
#line 283
  return;
}
}
#line 286 "auth-pam.c"
void pam_msg_cat(char const   *msg ) 
{ char *p ;
  size_t new_msg_len ;
  size_t pam_msg_len ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 292
  new_msg_len = strlen(msg);
#line 294
  if (pam_msg) {
#line 295
    pam_msg_len = strlen((char const   *)pam_msg);
#line 296
    tmp = xrealloc((void *)pam_msg, (new_msg_len + pam_msg_len) + 2U);
#line 296
    pam_msg = (char *)tmp;
#line 297
    p = pam_msg + pam_msg_len;
  } else {
#line 299
    tmp___0 = xmalloc(new_msg_len + 2U);
#line 299
    p = (char *)tmp___0;
#line 299
    pam_msg = p;
  }
#line 302
  memcpy((void * __restrict  )p, (void const   * __restrict  )msg, new_msg_len);
#line 303
  *(p + new_msg_len) = (char )'\n';
#line 304
  *(p + (new_msg_len + 1U)) = (char )'\000';
#line 305
  return;
}
}
#line 1 "auth-passwd.o"
#line 1 "auth-rsa.o"
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 212
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 401 "/usr/include/openssl/bn.h"
extern int BN_rand(BIGNUM *rnd , int bits , int top , int bottom ) ;
#line 420 "ssh.h"
int auth_rsa_challenge_dialog(RSA *pk ) ;
#line 56 "auth-rsa.c"
int auth_rsa_challenge_dialog(RSA *pk ) 
{ BIGNUM *challenge ;
  BIGNUM *encrypted_challenge ;
  BN_CTX *ctx ;
  unsigned char buf___1[32] ;
  unsigned char mdbuf[16] ;
  unsigned char response[16] ;
  MD5_CTX md ;
  unsigned int i ;
  int plen ;
  int len ;
  int _p ;
  int _e ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 66
  encrypted_challenge = BN_new();
#line 67
  challenge = BN_new();
#line 70
  BN_rand(challenge, 256, 0, 0);
#line 71
  ctx = BN_CTX_new();
#line 72
  BN_div((BIGNUM *)((void *)0), challenge, (BIGNUM const   *)challenge, (BIGNUM const   *)pk->n,
         ctx);
#line 73
  BN_CTX_free(ctx);
#line 76
  rsa_public_encrypt(encrypted_challenge, challenge, pk);
#line 79
  packet_start(7);
#line 80
  packet_put_bignum(encrypted_challenge);
#line 81
  packet_send();
#line 82
  BN_clear_free(encrypted_challenge);
#line 83
  packet_write_wait();
#line 86
  packet_read_expect(& plen, 8);
#line 87
  while (1) {
#line 87
    _p = plen;
#line 87
    _e = 16;
#line 87
    if (_p != _e) {
#line 87
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "auth-rsa.c", 87);
#line 87
      packet_disconnect("Packet integrity error. (%d)", 8);
    }
#line 87
    break;
  }
#line 88
  i = 0U;
#line 88
  while (i < 16U) {
#line 89
    tmp = packet_get_char();
#line 89
    response[i] = (unsigned char )tmp;
#line 88
    i ++;
  }
#line 92
  tmp___0 = BN_num_bits((BIGNUM const   *)challenge);
#line 92
  len = (tmp___0 + 7) / 8;
#line 93
  if (len <= 0) {
#line 94
    fatal("auth_rsa_challenge_dialog: bad challenge length %d", len);
  } else {
#line 93
    if (len > 32) {
#line 94
      fatal("auth_rsa_challenge_dialog: bad challenge length %d", len);
    }
  }
#line 95
  memset((void *)(buf___1), 0, 32U);
#line 96
  BN_bn2bin((BIGNUM const   *)challenge, (buf___1 + 32) - len);
#line 97
  MD5_Init(& md);
#line 98
  MD5_Update(& md, (void const   *)(buf___1), 32U);
#line 99
  MD5_Update(& md, (void const   *)(session_id), 16U);
#line 100
  MD5_Final(mdbuf, & md);
#line 101
  BN_clear_free(challenge);
#line 104
  tmp___1 = memcmp((void const   *)(response), (void const   *)(mdbuf), 16U);
#line 104
  if (tmp___1 != 0) {
#line 106
    return (0);
  }
#line 109
  return (1);
}
}
#line 165 "auth-rsa.c"
static char const   *check___0[3]  = {      "",      ".ssh",      (char const   *)((void *)0)};
#line 118 "auth-rsa.c"
int auth_rsa(struct passwd *pw , BIGNUM *client_n ) 
{ char line[8192] ;
  char file[1024] ;
  int authenticated ;
  unsigned int bits ;
  FILE *f ;
  unsigned long linenum ;
  struct stat st ;
  RSA *pk ;
  int tmp ;
  int fail ;
  char buf___1[1024] ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *cp ;
  char *options___0 ;
  int quoted ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;

  {
#line 126
  linenum = 0UL;
#line 131
  temporarily_use_uid(pw->pw_uid);
#line 134
  snprintf((char * __restrict  )(file), sizeof(file), (char const   * __restrict  )"%.500s/%.100s",
           pw->pw_dir, ".ssh/authorized_keys");
#line 138
  tmp = stat((char const   * __restrict  )(file), (struct stat * __restrict  )(& st));
#line 138
  if (tmp < 0) {
#line 140
    restore_uid();
#line 141
    return (0);
  }
#line 144
  f = fopen((char const   * __restrict  )(file), (char const   * __restrict  )"r");
#line 145
  if (! f) {
#line 147
    restore_uid();
#line 148
    packet_send_debug("Could not open %.900s for reading.", file);
#line 149
    packet_send_debug("If your home is on an NFS volume, it may need to be world-readable.");
#line 150
    return (0);
  }
#line 152
  if (options.strict_modes) {
#line 153
    fail = 0;
#line 156
    tmp___1 = fileno(f);
#line 156
    tmp___2 = fstat(tmp___1, & st);
#line 156
    if (tmp___2 < 0) {
#line 159
      snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
               pw->pw_name, file);
#line 161
      fail = 1;
    } else {
#line 156
      if (st.st_uid != 0U) {
#line 156
        if (st.st_uid != pw->pw_uid) {
#line 159
          snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   pw->pw_name, file);
#line 161
          fail = 1;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 156
        if ((st.st_mode & 18U) != 0U) {
#line 159
          snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   pw->pw_name, file);
#line 161
          fail = 1;
        } else {
#line 168
          i = 0;
#line 168
          while (check___0[i]) {
#line 169
            snprintf((char * __restrict  )(line), sizeof(line), (char const   * __restrict  )"%.500s/%.100s",
                     pw->pw_dir, check___0[i]);
#line 170
            tmp___0 = stat((char const   * __restrict  )(line), (struct stat * __restrict  )(& st));
#line 170
            if (tmp___0 < 0) {
#line 173
              snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                       pw->pw_name, line);
#line 175
              fail = 1;
#line 176
              break;
            } else {
#line 170
              if (st.st_uid != 0U) {
#line 170
                if (st.st_uid != pw->pw_uid) {
#line 173
                  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           pw->pw_name, line);
#line 175
                  fail = 1;
#line 176
                  break;
                } else {
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
#line 170
                if ((st.st_mode & 18U) != 0U) {
#line 173
                  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           pw->pw_name, line);
#line 175
                  fail = 1;
#line 176
                  break;
                }
              }
            }
#line 168
            i ++;
          }
        }
      }
    }
#line 180
    if (fail) {
#line 181
      fclose(f);
#line 182
      log("%s", buf___1);
#line 183
      packet_send_debug("%s", buf___1);
#line 184
      restore_uid();
#line 185
      return (0);
    }
  }
#line 189
  authenticated = 0;
#line 191
  pk = RSA_new();
#line 192
  pk->e = BN_new();
#line 193
  pk->n = BN_new();
#line 200
  while (1) {
#line 200
    tmp___8 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 200
    if (! tmp___8) {
#line 200
      break;
    }
#line 204
    linenum ++;
#line 207
    cp = line;
#line 207
    while (1) {
#line 207
      if (! ((int )*cp == 32)) {
#line 207
        if (! ((int )*cp == 9)) {
#line 207
          break;
        }
      }
#line 207
      cp ++;
    }
#line 209
    if (! *cp) {
#line 210
      continue;
    } else {
#line 209
      if ((int )*cp == 10) {
#line 210
        continue;
      } else {
#line 209
        if ((int )*cp == 35) {
#line 210
          continue;
        }
      }
    }
#line 218
    if ((int )*cp < 48) {
      goto _L___2;
    } else {
#line 218
      if ((int )*cp > 57) {
        _L___2: /* CIL Label */ 
#line 219
        quoted = 0;
#line 220
        options___0 = cp;
#line 221
        while (1) {
#line 221
          if (*cp) {
#line 221
            if (! quoted) {
#line 221
              if ((int )*cp != 32) {
#line 221
                if (! ((int )*cp != 9)) {
#line 221
                  break;
                }
              } else {
#line 221
                break;
              }
            }
          } else {
#line 221
            break;
          }
#line 222
          if ((int )*cp == 92) {
#line 222
            if ((int )*(cp + 1) == 34) {
#line 223
              cp ++;
            } else {
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
#line 224
            if ((int )*cp == 34) {
#line 225
              quoted = ! quoted;
            }
          }
#line 221
          cp ++;
        }
      } else {
#line 228
        options___0 = (char *)((void *)0);
      }
    }
#line 231
    tmp___3 = auth_rsa_read_key(& cp, & bits, pk->e, pk->n);
#line 231
    if (! tmp___3) {
#line 232
      debug("%.100s, line %lu: bad key syntax", ".ssh/authorized_keys", linenum);
#line 234
      packet_send_debug("%.100s, line %lu: bad key syntax", ".ssh/authorized_keys",
                        linenum);
#line 236
      continue;
    }
#line 241
    tmp___4 = BN_cmp((BIGNUM const   *)pk->n, (BIGNUM const   *)client_n);
#line 241
    if (tmp___4 != 0) {
#line 242
      continue;
    }
#line 245
    tmp___6 = BN_num_bits((BIGNUM const   *)pk->n);
#line 245
    if (bits != (unsigned int )tmp___6) {
#line 246
      tmp___5 = BN_num_bits((BIGNUM const   *)pk->n);
#line 246
      log("Warning: %s, line %ld: keysize mismatch: actual %d vs. announced %d.",
          file, linenum, tmp___5, bits);
    }
#line 253
    tmp___7 = auth_rsa_challenge_dialog(pk);
#line 253
    if (! tmp___7) {
#line 255
      verbose("Wrong response to RSA authentication challenge.");
#line 256
      packet_send_debug("Wrong response to RSA authentication challenge.");
#line 257
      continue;
    }
#line 267
    authenticated = auth_parse_options(pw, options___0, linenum);
#line 268
    if (authenticated) {
#line 269
      break;
    }
  }
#line 273
  restore_uid();
#line 276
  fclose(f);
#line 278
  RSA_free(pk);
#line 280
  if (authenticated) {
#line 281
    packet_send_debug("RSA authentication accepted.");
  }
#line 284
  return (authenticated);
}
}
#line 1 "auth-rh-rsa.o"
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 36 "auth-rh-rsa.c"
int auth_rhosts_rsa(struct passwd *pw , char const   *client_user , RSA *client_host_key ) 
{ char const   *canonical_hostname ;
  HostStatus host_status ;
  Key *client_key ;
  Key *found ;
  int tmp ;
  struct stat st ;
  char *user_hostfile ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 44
  debug("Trying rhosts with RSA host authentication for %.100s", client_user);
#line 46
  if ((unsigned int )client_host_key == (unsigned int )((void *)0)) {
#line 47
    return (0);
  }
#line 50
  tmp = auth_rhosts(pw, client_user);
#line 50
  if (! tmp) {
#line 51
    return (0);
  }
#line 53
  canonical_hostname = get_canonical_hostname();
#line 55
  debug("Rhosts RSA authentication: canonical host %.900s", canonical_hostname);
#line 58
  client_key = key_new(0);
#line 59
  BN_copy((client_key->rsa)->e, (BIGNUM const   *)client_host_key->e);
#line 60
  BN_copy((client_key->rsa)->n, (BIGNUM const   *)client_host_key->n);
#line 61
  found = key_new(0);
#line 64
  host_status = check_host_in_hostfile("/usr/local/etc/ssh_known_hosts", canonical_hostname,
                                       client_key, found);
#line 68
  if ((int )host_status != 0) {
#line 68
    if (! options.ignore_user_known_hosts) {
#line 70
      tmp___0 = tilde_expand_filename("~/.ssh/known_hosts", pw->pw_uid);
#line 70
      user_hostfile = tmp___0;
#line 75
      if (options.strict_modes) {
#line 75
        tmp___1 = stat((char const   * __restrict  )user_hostfile, (struct stat * __restrict  )(& st));
#line 75
        if (tmp___1 == 0) {
#line 75
          if (st.st_uid != 0U) {
#line 75
            if (st.st_uid != pw->pw_uid) {
#line 79
              log("Rhosts RSA authentication refused for %.100s: bad owner or modes for %.200s",
                  pw->pw_name, user_hostfile);
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 75
            if ((st.st_mode & 18U) != 0U) {
#line 79
              log("Rhosts RSA authentication refused for %.100s: bad owner or modes for %.200s",
                  pw->pw_name, user_hostfile);
            } else {
#line 83
              temporarily_use_uid(pw->pw_uid);
#line 84
              host_status = check_host_in_hostfile((char const   *)user_hostfile,
                                                   canonical_hostname, client_key,
                                                   found);
#line 86
              restore_uid();
            }
          }
        } else {
#line 83
          temporarily_use_uid(pw->pw_uid);
#line 84
          host_status = check_host_in_hostfile((char const   *)user_hostfile, canonical_hostname,
                                               client_key, found);
#line 86
          restore_uid();
        }
      } else {
#line 83
        temporarily_use_uid(pw->pw_uid);
#line 84
        host_status = check_host_in_hostfile((char const   *)user_hostfile, canonical_hostname,
                                             client_key, found);
#line 86
        restore_uid();
      }
#line 88
      xfree((void *)user_hostfile);
    }
  }
#line 90
  key_free(client_key);
#line 91
  key_free(found);
#line 93
  if ((int )host_status != 0) {
#line 94
    debug("Rhosts with RSA host authentication denied: unknown or invalid host key");
#line 95
    packet_send_debug("Your host key cannot be verified: unknown or invalid host key.");
#line 96
    return (0);
  }
#line 101
  tmp___2 = auth_rsa_challenge_dialog(client_host_key);
#line 101
  if (! tmp___2) {
#line 102
    log("Client on %.800s failed to respond correctly to host authentication.", canonical_hostname);
#line 104
    return (0);
  }
#line 111
  verbose("Rhosts with RSA host authentication accepted for %.100s, %.100s on %.700s.",
          pw->pw_name, client_user, canonical_hostname);
#line 113
  packet_send_debug("Rhosts with RSA host authentication accepted.");
#line 114
  return (1);
}
}
#line 1 "pty.o"
#line 280 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 433 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group )  __attribute__((__nonnull__(1))) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 872
extern  __attribute__((__nothrow__)) int vhangup(void) ;
#line 109 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 27 "pty.h"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) ;
#line 33
void pty_release(char const   *ttyname___0 ) ;
#line 39
void pty_make_controlling_tty(int *ttyfd , char const   *ttyname___0 ) ;
#line 42
void pty_change_window_size(int ptyfd , int row , int col , int xpixel , int ypixel ) ;
#line 46
void pty_setowner(struct passwd *pw , char const   *ttyname___0 ) ;
#line 57 "pty.c"
extern int ( /* missing proto */  openpty)() ;
#line 49 "pty.c"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) 
{ char buf___1[64] ;
  int i ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 57
  i = openpty(ptyfd, ttyfd, buf___1, (void *)0, (void *)0);
#line 58
  if (i < 0) {
#line 59
    tmp = __errno_location();
#line 59
    tmp___0 = strerror(*tmp);
#line 59
    error("openpty: %.100s", tmp___0);
#line 60
    return (0);
  }
#line 62
  strlcpy(namebuf, (char const   *)(buf___1), (unsigned int )namebuflen);
#line 63
  return (1);
}
}
#line 196 "pty.c"
void pty_release(char const   *ttyname___0 ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 199
  tmp___1 = chown(ttyname___0, 0U, 0U);
#line 199
  if (tmp___1 < 0) {
#line 200
    tmp = __errno_location();
#line 200
    tmp___0 = strerror(*tmp);
#line 200
    error("chown %.100s 0 0 failed: %.100s", ttyname___0, tmp___0);
  }
#line 201
  tmp___4 = chmod(ttyname___0, 438U);
#line 201
  if (tmp___4 < 0) {
#line 202
    tmp___2 = __errno_location();
#line 202
    tmp___3 = strerror(*tmp___2);
#line 202
    error("chmod %.100s 0666 failed: %.100s", ttyname___0, tmp___3);
  }
#line 203
  return;
}
}
#line 207 "pty.c"
void pty_make_controlling_tty(int *ttyfd , char const   *ttyname___0 ) 
{ int fd ;
  void *old ;
  int *tmp ;
  char *tmp___0 ;
  __pid_t tmp___1 ;
  __sighandler_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
#line 217
  fd = open("/dev/tty", 258);
#line 218
  if (fd >= 0) {
#line 219
    ioctl(fd, 21538UL, (void *)0);
#line 220
    close(fd);
  }
#line 223
  tmp___1 = setsid();
#line 223
  if (tmp___1 < 0) {
#line 224
    tmp = __errno_location();
#line 224
    tmp___0 = strerror(*tmp);
#line 224
    error("setsid: %.100s", tmp___0);
  }
#line 230
  fd = open("/dev/tty", 258);
#line 231
  if (fd >= 0) {
#line 232
    error("Failed to disconnect from controlling tty.");
#line 233
    close(fd);
  }
#line 237
  debug("Setting controlling tty using TIOCSCTTY.");
#line 243
  ioctl(*ttyfd, 21518UL, (void *)0);
#line 246
  tmp___2 = signal(1, (void (*)(int  ))1);
#line 246
  old = (void *)tmp___2;
#line 247
  vhangup();
#line 248
  signal(1, (void (*)(int  ))old);
#line 250
  fd = open(ttyname___0, 2);
#line 251
  if (fd < 0) {
#line 252
    tmp___3 = __errno_location();
#line 252
    tmp___4 = strerror(*tmp___3);
#line 252
    error("%.100s: %.100s", ttyname___0, tmp___4);
  } else {
#line 255
    close(*ttyfd);
#line 256
    *ttyfd = fd;
  }
#line 262
  fd = open("/dev/tty", 1);
#line 263
  if (fd < 0) {
#line 264
    tmp___5 = __errno_location();
#line 264
    tmp___6 = strerror(*tmp___5);
#line 264
    error("open /dev/tty failed - could not set controlling tty: %.100s", tmp___6);
  } else {
#line 267
    close(fd);
  }
#line 269
  return;
}
}
#line 273 "pty.c"
void pty_change_window_size(int ptyfd , int row , int col , int xpixel , int ypixel ) 
{ struct winsize w ;

  {
#line 278
  w.ws_row = (unsigned short )row;
#line 279
  w.ws_col = (unsigned short )col;
#line 280
  w.ws_xpixel = (unsigned short )xpixel;
#line 281
  w.ws_ypixel = (unsigned short )ypixel;
#line 282
  ioctl(ptyfd, 21524UL, & w);
#line 283
  return;
}
}
#line 285 "pty.c"
void pty_setowner(struct passwd *pw , char const   *ttyname___0 ) 
{ struct group *grp ;
  gid_t gid ;
  mode_t mode ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 293
  grp = getgrnam("tty");
#line 294
  if (grp) {
#line 295
    gid = grp->gr_gid;
#line 296
    mode = (unsigned int )(384 | (128 >> 3));
  } else {
#line 298
    gid = pw->pw_gid;
#line 299
    mode = (unsigned int )((384 | (128 >> 3)) | ((128 >> 3) >> 3));
  }
#line 303
  tmp___1 = chown(ttyname___0, pw->pw_uid, gid);
#line 303
  if (tmp___1 < 0) {
#line 304
    tmp = __errno_location();
#line 304
    tmp___0 = strerror(*tmp);
#line 304
    fatal("chown(%.100s, %d, %d) failed: %.100s", ttyname___0, pw->pw_uid, gid, tmp___0);
  }
#line 306
  tmp___4 = chmod(ttyname___0, mode);
#line 306
  if (tmp___4 < 0) {
#line 307
    tmp___2 = __errno_location();
#line 307
    tmp___3 = strerror(*tmp___2);
#line 307
    fatal("chmod(%.100s, 0%o) failed: %.100s", ttyname___0, mode, tmp___3);
  }
#line 309
  return;
}
}
#line 1 "log-server.o"
#line 175 "/usr/include/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 26 "log-server.c"
extern char *__progname ;
#line 31 "log-server.c"
static LogLevel log_level  =    3;
#line 32 "log-server.c"
static int log_on_stderr  =    0;
#line 33 "log-server.c"
static int log_facility  =    4 << 3;
#line 41 "log-server.c"
void log_init(char *av0___0 , LogLevel level , SyslogFacility facility , int on_stderr ) 
{ 

  {
#line 44
  switch ((int )level) {
  case 0: 
  case 2: 
  case 1: 
  case 3: 
  case 4: 
  case 5: 
#line 51
  log_level = level;
#line 52
  break;
  default: 
#line 54
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized internal syslog level code %d\n",
          (int )level);
#line 56
  exit(1);
  }
#line 58
  switch ((int )facility) {
  case 0: 
#line 60
  log_facility = 3 << 3;
#line 61
  break;
  case 1: 
#line 63
  log_facility = 1 << 3;
#line 64
  break;
  case 2: 
#line 66
  log_facility = 4 << 3;
#line 67
  break;
  case 3: 
#line 69
  log_facility = 16 << 3;
#line 70
  break;
  case 4: 
#line 72
  log_facility = 17 << 3;
#line 73
  break;
  case 5: 
#line 75
  log_facility = 18 << 3;
#line 76
  break;
  case 6: 
#line 78
  log_facility = 19 << 3;
#line 79
  break;
  case 7: 
#line 81
  log_facility = 20 << 3;
#line 82
  break;
  case 8: 
#line 84
  log_facility = 21 << 3;
#line 85
  break;
  case 9: 
#line 87
  log_facility = 22 << 3;
#line 88
  break;
  case 10: 
#line 90
  log_facility = 23 << 3;
#line 91
  break;
  default: 
#line 93
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized internal syslog facility code %d\n",
          (int )facility);
#line 95
  exit(1);
  }
#line 97
  log_on_stderr = on_stderr;
#line 98
  return;
}
}
#line 102 "log-server.c"
void do_log(LogLevel level , char const   *fmt , va_list args ) 
{ char msgbuf[1024] ;
  char fmtbuf[1024] ;
  char *txt ;
  int pri ;

  {
#line 107
  txt = (char *)((void *)0);
#line 108
  pri = 6;
#line 110
  if ((int )level > (int )log_level) {
#line 111
    return;
  }
#line 112
  switch ((int )level) {
  case 2: 
#line 114
  txt = (char *)"error";
#line 115
  pri = 3;
#line 116
  break;
  case 1: 
#line 118
  txt = (char *)"fatal";
#line 119
  pri = 3;
#line 120
  break;
  case 3: 
  case 4: 
#line 123
  pri = 6;
#line 124
  break;
  case 5: 
#line 126
  txt = (char *)"debug";
#line 127
  pri = 7;
#line 128
  break;
  default: 
#line 130
  txt = (char *)"internal error";
#line 131
  pri = 3;
#line 132
  break;
  }
#line 134
  if ((unsigned int )txt != (unsigned int )((void *)0)) {
#line 135
    snprintf((char * __restrict  )(fmtbuf), sizeof(fmtbuf), (char const   * __restrict  )"%s: %s",
             txt, fmt);
#line 136
    vsnprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )(fmtbuf),
              args);
  } else {
#line 138
    vsnprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )fmt,
              args);
  }
#line 140
  if (log_on_stderr) {
#line 141
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n", msgbuf);
  } else {
#line 143
    openlog((char const   *)__progname, 1, log_facility);
#line 144
    syslog(pri, "%.500s", msgbuf);
#line 145
    closelog();
  }
#line 147
  return;
}
}
#line 1 "login.o"
#line 100 "loginrec.h"
struct logininfo *login_alloc_entry(int pid , char const   *username , char const   *hostname ,
                                    char const   *line ) ;
#line 103
void login_free_entry(struct logininfo *li ) ;
#line 111
int login_login(struct logininfo *li ) ;
#line 112
int login_logout(struct logininfo *li ) ;
#line 121
void login_set_addr(struct logininfo *li , struct sockaddr  const  *sa , unsigned int sa_size ) ;
#line 128
struct logininfo *login_get_lastlog(struct logininfo *li , int uid ) ;
#line 31 "login.c"
unsigned long get_last_login_time(uid_t uid , char const   *logname , char *buf___1 ,
                                  unsigned int bufsize ) 
{ struct logininfo li ;

  {
#line 37
  login_get_lastlog(& li, (int )uid);
#line 38
  strlcpy(buf___1, (char const   *)(li.hostname), bufsize);
#line 39
  return ((unsigned long )li.tv_sec);
}
}
#line 47 "login.c"
void record_login(pid_t pid , char const   *ttyname___0 , char const   *user , uid_t uid ,
                  char const   *host , struct sockaddr *addr ) 
{ struct logininfo *li ;

  {
#line 53
  li = login_alloc_entry(pid, user, host, ttyname___0);
#line 54
  login_set_addr(li, (struct sockaddr  const  *)addr, sizeof(struct sockaddr ));
#line 55
  login_login(li);
#line 56
  login_free_entry(li);
#line 57
  return;
}
}
#line 61 "login.c"
void record_logout(pid_t pid , char const   *ttyname___0 ) 
{ struct logininfo *li ;

  {
#line 66
  li = login_alloc_entry(pid, (char const   *)((void *)0), (char const   *)((void *)0),
                         ttyname___0);
#line 67
  login_logout(li);
#line 68
  login_free_entry(li);
#line 69
  return;
}
}
#line 1 "loginrec.o"
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval * __restrict  __tv ,
                                                      __timezone_ptr_t __tz )  __attribute__((__nonnull__(1))) ;
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 46 "/usr/include/utmp.h"
extern  __attribute__((__nothrow__)) void login(struct utmp  const  *__entry ) ;
#line 49
extern  __attribute__((__nothrow__)) int logout(char const   *__ut_line ) ;
#line 52
extern  __attribute__((__nothrow__)) void logwtmp(char const   *__ut_line , char const   *__ut_name ,
                                                  char const   *__ut_host ) ;
#line 105 "loginrec.h"
int login_init_entry(struct logininfo *li , int pid , char const   *username , char const   *hostname ,
                     char const   *line ) ;
#line 108
void login_set_current_time(struct logininfo *li ) ;
#line 117
int login_write(struct logininfo *li ) ;
#line 130
unsigned int login_get_lastlog_time(int uid ) ;
#line 133
char *line_fullname(char *dst , char const   *src , int dstsize ) ;
#line 134
char *line_stripname(char *dst , char const   *src , int dstsize ) ;
#line 135
char *line_abbrevname(char *dst , char const   *src , int dstsize ) ;
#line 171 "loginrec.c"
void set_utmp_time(struct logininfo *li , struct utmp *ut ) ;
#line 172
void construct_utmp(struct logininfo *li , struct utmp *ut ) ;
#line 184
int lastlog_write_entry(struct logininfo *li ) ;
#line 185
int syslogin_write_entry(struct logininfo *li ) ;
#line 187
int getlast_entry(struct logininfo *li ) ;
#line 188
int lastlog_get_entry(struct logininfo *li ) ;
#line 208 "loginrec.c"
int login_login(struct logininfo *li ) 
{ int tmp ;

  {
#line 211
  li->type = (short)7;
#line 212
  tmp = login_write(li);
#line 212
  return (tmp);
}
}
#line 224 "loginrec.c"
int login_logout(struct logininfo *li ) 
{ int tmp ;

  {
#line 227
  li->type = (short)8;
#line 228
  tmp = login_write(li);
#line 228
  return (tmp);
}
}
#line 248 "loginrec.c"
unsigned int login_get_lastlog_time(int uid ) 
{ struct logininfo li ;
  struct logininfo *tmp ;

  {
#line 253
  tmp = login_get_lastlog(& li, uid);
#line 253
  if (tmp) {
#line 254
    return (li.tv_sec);
  } else {
#line 256
    return (0U);
  }
}
}
#line 272 "loginrec.c"
struct logininfo *login_get_lastlog(struct logininfo *li , int uid ) 
{ struct passwd *pw ;
  int tmp ;

  {
#line 277
  memset((void *)li, '\000', sizeof(*li));
#line 278
  li->uid = uid;
#line 285
  pw = getpwuid((unsigned int )uid);
#line 286
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 287
    fatal("login_get_lastlog: Cannot find account for uid %i", uid);
  }
#line 291
  strlcpy(li->username, (char const   *)pw->pw_name, sizeof(li->username));
#line 293
  tmp = getlast_entry(li);
#line 293
  if (tmp) {
#line 294
    return (li);
  } else {
#line 296
    return ((struct logininfo *)((void *)0));
  }
}
}
#line 309 "loginrec.c"
struct logininfo *login_alloc_entry(int pid , char const   *username , char const   *hostname ,
                                    char const   *line ) 
{ struct logininfo *newli ;
  void *tmp ;

  {
#line 315
  tmp = xmalloc(sizeof(*newli));
#line 315
  newli = (struct logininfo *)tmp;
#line 316
  login_init_entry(newli, pid, username, hostname, line);
#line 317
  return (newli);
}
}
#line 322 "loginrec.c"
void login_free_entry(struct logininfo *li ) 
{ 

  {
#line 325
  xfree((void *)li);
#line 326
  return;
}
}
#line 337 "loginrec.c"
int login_init_entry(struct logininfo *li , int pid , char const   *username , char const   *hostname ,
                     char const   *line ) 
{ struct passwd *pw ;

  {
#line 343
  memset((void *)li, 0, sizeof(*li));
#line 345
  li->pid = pid;
#line 348
  if (line) {
#line 349
    line_fullname(li->line, line, (int )sizeof(li->line));
  }
#line 351
  if (username) {
#line 352
    strlcpy(li->username, username, sizeof(li->username));
#line 353
    pw = getpwnam((char const   *)(li->username));
#line 354
    if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 355
      fatal("login_init_entry: Cannot find user \"%s\"", li->username);
    }
#line 356
    li->uid = (int )pw->pw_uid;
  }
#line 359
  if (hostname) {
#line 360
    strlcpy(li->hostname, hostname, sizeof(li->hostname));
  }
#line 362
  return (1);
}
}
#line 371 "loginrec.c"
void login_set_current_time(struct logininfo *li ) 
{ struct timeval tv ;

  {
#line 376
  gettimeofday((struct timeval * __restrict  )(& tv), (struct timezone * __restrict  )((void *)0));
#line 378
  li->tv_sec = (unsigned int )tv.tv_sec;
#line 379
  li->tv_usec = (unsigned int )tv.tv_usec;
#line 380
  return;
}
}
#line 383 "loginrec.c"
void login_set_addr(struct logininfo *li , struct sockaddr  const  *sa , unsigned int sa_size ) 
{ unsigned int bufsize ;

  {
#line 387
  bufsize = sa_size;
#line 390
  if (sizeof(li->hostaddr) < sa_size) {
#line 391
    bufsize = sizeof(li->hostaddr);
  }
#line 393
  memcpy((void * __restrict  )((void *)(& li->hostaddr.sa)), (void const   * __restrict  )((void const   *)sa),
         bufsize);
#line 394
  return;
}
}
#line 401 "loginrec.c"
int login_write(struct logininfo *li ) 
{ __uid_t tmp ;

  {
#line 404
  tmp = geteuid();
#line 404
  if ((int )tmp != 0) {
#line 405
    log("Attempt to write login records by non-root user (aborting)");
#line 406
    return (1);
  }
#line 410
  login_set_current_time(li);
#line 412
  syslogin_write_entry(li);
#line 415
  if ((int )li->type == 7) {
#line 416
    lastlog_write_entry(li);
  }
#line 431
  return (0);
}
}
#line 440 "loginrec.c"
int getlast_entry(struct logininfo *li ) 
{ int tmp ;

  {
#line 444
  tmp = lastlog_get_entry(li);
#line 444
  return (tmp);
}
}
#line 491 "loginrec.c"
char *line_fullname(char *dst , char const   *src , int dstsize ) 
{ int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  size_t tmp___25 ;

  {
#line 494
  memset((void *)dst, '\000', (unsigned int )dstsize);
#line 495
  if (0) {
#line 495
    if (0) {
#line 495
      __s1_len___0 = strlen(src);
#line 495
      __s2_len___0 = strlen("/dev/");
#line 495
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 495
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 495
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 495
            tmp___22 = 1;
          } else {
#line 495
            if (__s2_len___0 >= 4U) {
#line 495
              tmp___22 = 1;
            } else {
#line 495
              tmp___22 = 0;
            }
          }
        } else {
#line 495
          tmp___22 = 0;
        }
      }
#line 495
      if (tmp___22) {
#line 495
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 495
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 495
        tmp___18 = tmp___21;
      }
    } else {
#line 495
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 495
      tmp___18 = tmp___21;
    }
#line 495
    tmp___12 = tmp___18;
  } else {
#line 495
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 495
  if (tmp___12 == 0) {
#line 496
    strlcpy(dst, src, (unsigned int )dstsize);
  } else {
#line 495
    tmp___25 = strlen(src);
#line 495
    if ((size_t )dstsize < tmp___25 + 5U) {
#line 496
      strlcpy(dst, src, (unsigned int )dstsize);
    } else {
#line 498
      strlcpy(dst, "/dev/", (unsigned int )dstsize);
#line 499
      strlcat(dst, src, (unsigned int )dstsize);
    }
  }
#line 501
  return (dst);
}
}
#line 505 "loginrec.c"
char *line_stripname(char *dst , char const   *src , int dstsize ) 
{ int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 508
  memset((void *)dst, '\000', (unsigned int )dstsize);
#line 509
  if (0) {
#line 509
    if (0) {
#line 509
      __s1_len___0 = strlen(src);
#line 509
      __s2_len___0 = strlen("/dev/");
#line 509
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 509
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 509
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 509
            tmp___22 = 1;
          } else {
#line 509
            if (__s2_len___0 >= 4U) {
#line 509
              tmp___22 = 1;
            } else {
#line 509
              tmp___22 = 0;
            }
          }
        } else {
#line 509
          tmp___22 = 0;
        }
      }
#line 509
      if (tmp___22) {
#line 509
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 509
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 509
        tmp___18 = tmp___21;
      }
    } else {
#line 509
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 509
      tmp___18 = tmp___21;
    }
#line 509
    tmp___12 = tmp___18;
  } else {
#line 509
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 509
  if (tmp___12 == 0) {
#line 510
    strlcpy(dst, src + 5, (unsigned int )dstsize);
  } else {
#line 512
    strlcpy(dst, src, (unsigned int )dstsize);
  }
#line 513
  return (dst);
}
}
#line 522 "loginrec.c"
char *line_abbrevname(char *dst , char const   *src , int dstsize ) 
{ size_t len ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 527
  memset((void *)dst, '\000', (unsigned int )dstsize);
#line 530
  if (0) {
#line 530
    if (0) {
#line 530
      __s1_len___0 = strlen(src);
#line 530
      __s2_len___0 = strlen("/dev/");
#line 530
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 530
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 530
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 530
            tmp___22 = 1;
          } else {
#line 530
            if (__s2_len___0 >= 4U) {
#line 530
              tmp___22 = 1;
            } else {
#line 530
              tmp___22 = 0;
            }
          }
        } else {
#line 530
          tmp___22 = 0;
        }
      }
#line 530
      if (tmp___22) {
#line 530
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 530
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 530
        tmp___18 = tmp___21;
      }
    } else {
#line 530
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 530
      tmp___18 = tmp___21;
    }
#line 530
    tmp___12 = tmp___18;
  } else {
#line 530
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 530
  if (tmp___12 == 0) {
#line 531
    src += 5;
  }
#line 533
  len = strlen(src);
#line 535
  if (len > 0U) {
#line 536
    if ((int )len - dstsize > 0) {
#line 537
      src += (int )len - dstsize;
    }
#line 540
    __builtin_strncpy(dst, src, (unsigned int )dstsize);
  }
#line 543
  return (dst);
}
}
#line 556 "loginrec.c"
void set_utmp_time(struct logininfo *li , struct utmp *ut ) 
{ 

  {
#line 560
  ut->ut_tv.tv_sec = (long )li->tv_sec;
#line 561
  ut->ut_tv.tv_usec = (long )li->tv_usec;
#line 567
  return;
}
}
#line 569 "loginrec.c"
void construct_utmp(struct logininfo *li , struct utmp *ut ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 573
  memset((void *)ut, '\000', sizeof(*ut));
#line 578
  line_abbrevname(ut->ut_id, (char const   *)(li->line), (int )sizeof(ut->ut_id));
#line 583
  switch ((int )li->type) {
  case 7: 
#line 585
  ut->ut_type = (short)7;
#line 586
  break;
  case 8: 
#line 588
  ut->ut_type = (short)8;
#line 589
  break;
  }
#line 592
  set_utmp_time(li, ut);
#line 594
  line_stripname(ut->ut_line, (char const   *)(li->line), (int )sizeof(ut->ut_line));
#line 597
  ut->ut_pid = li->pid;
#line 601
  if ((int )li->type == 8) {
#line 602
    return;
  }
#line 610
  if (sizeof(ut->ut_user) < sizeof(li->username)) {
#line 610
    tmp = sizeof(ut->ut_user);
  } else {
#line 610
    tmp = sizeof(li->username);
  }
#line 610
  __builtin_strncpy(ut->ut_user, (char const   *)(li->username), tmp);
#line 612
  if (sizeof(ut->ut_host) < sizeof(li->hostname)) {
#line 612
    tmp___0 = sizeof(ut->ut_host);
  } else {
#line 612
    tmp___0 = sizeof(li->hostname);
  }
#line 612
  __builtin_strncpy(ut->ut_host, (char const   *)(li->hostname), tmp___0);
#line 616
  if ((int )li->hostaddr.sa.sa_family == 2) {
#line 617
    ut->ut_addr_v6[0] = (int )li->hostaddr.sa_in.sin_addr.s_addr;
  }
#line 619
  return;
}
}
#line 1259 "loginrec.c"
static int syslogin_perform_login(struct logininfo *li ) 
{ struct utmp *ut ;
  void *tmp ;

  {
#line 1264
  tmp = malloc(sizeof(*ut));
#line 1264
  ut = (struct utmp *)tmp;
#line 1264
  if (! ut) {
#line 1265
    log("syslogin_perform_login: couldn\'t malloc()");
#line 1266
    return (0);
  }
#line 1268
  construct_utmp(li, ut);
#line 1269
  login((struct utmp  const  *)ut);
#line 1271
  return (1);
}
}
#line 1274 "loginrec.c"
static int syslogin_perform_logout(struct logininfo *li ) 
{ char line[8] ;
  int tmp ;

  {
#line 1280
  line_stripname(line, (char const   *)(li->line), (int )sizeof(line));
#line 1282
  tmp = logout((char const   *)(line));
#line 1282
  if (tmp) {
#line 1286
    logwtmp((char const   *)(line), "", "");
  } else {
#line 1283
    log("syslogin_perform_logout: logout() returned an error");
  }
#line 1294
  return (1);
}
}
#line 1297 "loginrec.c"
int syslogin_write_entry(struct logininfo *li ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 1300
  switch ((int )li->type) {
  case 7: 
#line 1302
  tmp = syslogin_perform_login(li);
#line 1302
  return (tmp);
  case 8: 
#line 1304
  tmp___0 = syslogin_perform_logout(li);
#line 1304
  return (tmp___0);
  default: 
#line 1306
  log("syslogin_write_entry: Invalid type field");
#line 1307
  return (0);
  }
}
}
#line 1323 "loginrec.c"
static void lastlog_construct(struct logininfo *li , struct lastlog *last ) 
{ unsigned int tmp ;

  {
#line 1327
  memset((void *)last, '\000', sizeof(*last));
#line 1329
  line_stripname(last->ll_line, (char const   *)(li->line), (int )sizeof(last->ll_line));
#line 1330
  if (sizeof(last->ll_host) < sizeof(li->hostname)) {
#line 1330
    tmp = sizeof(last->ll_host);
  } else {
#line 1330
    tmp = sizeof(li->hostname);
  }
#line 1330
  strlcpy(last->ll_host, (char const   *)(li->hostname), tmp);
#line 1332
  last->ll_time = (long )li->tv_sec;
#line 1333
  return;
}
}
#line 1335 "loginrec.c"
static int lastlog_filetype(char *filename ) 
{ struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1340
  tmp___1 = stat((char const   * __restrict  )"/var/log/lastlog", (struct stat * __restrict  )(& st));
#line 1340
  if (tmp___1 != 0) {
#line 1341
    tmp = __errno_location();
#line 1341
    tmp___0 = strerror(*tmp);
#line 1341
    log("lastlog_perform_login: Couldn\'t stat %s: %s", "/var/log/lastlog", tmp___0);
#line 1343
    return (0);
  }
#line 1345
  if ((st.st_mode & 61440U) == 16384U) {
#line 1346
    return (2);
  } else {
#line 1347
    if ((st.st_mode & 61440U) == 32768U) {
#line 1348
      return (1);
    } else {
#line 1350
      return (3);
    }
  }
}
}
#line 1355 "loginrec.c"
static int lastlog_openseek(struct logininfo *li , int *fd , int filemode ) 
{ off_t offset ;
  int type ;
  char lastlog_file[1024] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  __off_t tmp___3 ;

  {
#line 1362
  type = lastlog_filetype((char *)"/var/log/lastlog");
#line 1363
  switch (type) {
  case 1: 
#line 1365
  strlcpy(lastlog_file, "/var/log/lastlog", sizeof(lastlog_file));
#line 1366
  break;
  case 2: 
#line 1368
  snprintf((char * __restrict  )(lastlog_file), sizeof(lastlog_file), (char const   * __restrict  )"%s/%s",
           "/var/log/lastlog", li->username);
#line 1370
  break;
  default: 
#line 1372
  log("lastlog_openseek: %.100s is not a file or directory!", "/var/log/lastlog");
#line 1374
  return (0);
  }
#line 1377
  *fd = open((char const   *)(lastlog_file), filemode);
#line 1378
  if (*fd < 0) {
#line 1379
    tmp = __errno_location();
#line 1379
    tmp___0 = strerror(*tmp);
#line 1379
    debug("lastlog_openseek: Couldn\'t open %s: %s", lastlog_file, tmp___0);
#line 1381
    return (0);
  }
#line 1384
  if (type == 1) {
#line 1386
    offset = (long )((unsigned long )((long )li->uid) * (unsigned long )sizeof(struct lastlog ));
#line 1388
    tmp___3 = lseek(*fd, offset, 0);
#line 1388
    if (tmp___3 != offset) {
#line 1389
      tmp___1 = __errno_location();
#line 1389
      tmp___2 = strerror(*tmp___1);
#line 1389
      log("lastlog_openseek: %s->lseek(): %s", lastlog_file, tmp___2);
#line 1391
      return (0);
    }
  }
#line 1395
  return (1);
}
}
#line 1398 "loginrec.c"
static int lastlog_perform_login(struct logininfo *li ) 
{ struct lastlog last ;
  int fd ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 1405
  lastlog_construct(li, & last);
#line 1407
  tmp = lastlog_openseek(li, & fd, 66);
#line 1407
  if (! tmp) {
#line 1408
    return (0);
  }
#line 1411
  tmp___2 = atomicio((ssize_t (*)())(& write), fd, (void *)(& last), sizeof(last));
#line 1411
  if ((unsigned int )tmp___2 != sizeof(last)) {
#line 1412
    close(fd);
#line 1413
    tmp___0 = __errno_location();
#line 1413
    tmp___1 = strerror(*tmp___0);
#line 1413
    log("lastlog_write_filemode: Error writing to %s: %s", "/var/log/lastlog", tmp___1);
#line 1415
    return (0);
  }
#line 1418
  close(fd);
#line 1419
  return (1);
}
}
#line 1422 "loginrec.c"
int lastlog_write_entry(struct logininfo *li ) 
{ int tmp ;

  {
#line 1425
  switch ((int )li->type) {
  case 7: 
#line 1427
  tmp = lastlog_perform_login(li);
#line 1427
  return (tmp);
  default: 
#line 1429
  log("lastlog_write_entry: Invalid type field");
#line 1430
  return (0);
  }
}
}
#line 1434 "loginrec.c"
static void lastlog_populate_entry(struct logininfo *li , struct lastlog *last ) 
{ unsigned int tmp ;

  {
#line 1437
  line_fullname(li->line, (char const   *)(last->ll_line), (int )sizeof(li->line));
#line 1438
  if (sizeof(li->hostname) < sizeof(last->ll_host)) {
#line 1438
    tmp = sizeof(li->hostname);
  } else {
#line 1438
    tmp = sizeof(last->ll_host);
  }
#line 1438
  strlcpy(li->hostname, (char const   *)(last->ll_host), tmp);
#line 1440
  li->tv_sec = (unsigned int )last->ll_time;
#line 1441
  return;
}
}
#line 1443 "loginrec.c"
int lastlog_get_entry(struct logininfo *li ) 
{ struct lastlog last ;
  int fd ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;

  {
#line 1449
  tmp___2 = lastlog_openseek(li, & fd, 0);
#line 1449
  if (tmp___2) {
#line 1450
    tmp___1 = atomicio((ssize_t (*)())(& read), fd, (void *)(& last), sizeof(last));
#line 1450
    if ((unsigned int )tmp___1 != sizeof(last)) {
#line 1451
      tmp = __errno_location();
#line 1451
      tmp___0 = strerror(*tmp);
#line 1451
      log("lastlog_get_entry: Error reading from %s: %s", "/var/log/lastlog", tmp___0);
#line 1453
      return (0);
    } else {
#line 1455
      lastlog_populate_entry(li, & last);
#line 1456
      return (1);
    }
  } else {
#line 1459
    return (0);
  }
}
}
#line 1 "servconf.o"
#line 747 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 23 "servconf.c"
void add_listen_addr(ServerOptions *options___0 , char *addr ) ;
#line 27 "servconf.c"
void initialize_server_options(ServerOptions *options___0 ) 
{ 

  {
#line 30
  memset((void *)options___0, 0, sizeof(*options___0));
#line 31
  options___0->num_ports = 0U;
#line 32
  options___0->ports_from_cmdline = 0U;
#line 33
  options___0->listen_addrs = (struct addrinfo *)((void *)0);
#line 34
  options___0->host_key_file = (char *)((void *)0);
#line 35
  options___0->host_dsa_key_file = (char *)((void *)0);
#line 36
  options___0->pid_file = (char *)((void *)0);
#line 37
  options___0->server_key_bits = -1;
#line 38
  options___0->login_grace_time = -1;
#line 39
  options___0->key_regeneration_time = -1;
#line 40
  options___0->permit_root_login = -1;
#line 41
  options___0->ignore_rhosts = -1;
#line 42
  options___0->ignore_user_known_hosts = -1;
#line 43
  options___0->print_motd = -1;
#line 44
  options___0->check_mail = -1;
#line 45
  options___0->x11_forwarding = -1;
#line 46
  options___0->x11_display_offset = -1;
#line 47
  options___0->xauth_location = (char *)((void *)0);
#line 48
  options___0->strict_modes = -1;
#line 49
  options___0->keepalives = -1;
#line 50
  options___0->log_facility = (enum __anonenum_SyslogFacility_72 )-1;
#line 51
  options___0->log_level = (enum __anonenum_LogLevel_73 )-1;
#line 52
  options___0->rhosts_authentication = -1;
#line 53
  options___0->rhosts_rsa_authentication = -1;
#line 54
  options___0->rsa_authentication = -1;
#line 55
  options___0->dsa_authentication = -1;
#line 65
  options___0->password_authentication = -1;
#line 69
  options___0->permit_empty_passwd = -1;
#line 70
  options___0->use_login = -1;
#line 71
  options___0->num_allow_users = 0U;
#line 72
  options___0->num_deny_users = 0U;
#line 73
  options___0->num_allow_groups = 0U;
#line 74
  options___0->num_deny_groups = 0U;
#line 75
  options___0->ciphers = (char *)((void *)0);
#line 76
  options___0->protocol = 0;
#line 77
  options___0->gateway_ports = -1;
#line 78
  options___0->num_subsystems = 0U;
#line 79
  options___0->max_startups_begin = -1;
#line 80
  options___0->max_startups_rate = -1;
#line 81
  options___0->max_startups = -1;
#line 82
  return;
}
}
#line 84 "servconf.c"
void fill_default_server_options(ServerOptions *options___0 ) 
{ unsigned int tmp ;

  {
#line 87
  if (options___0->num_ports == 0U) {
#line 88
    tmp = options___0->num_ports;
#line 88
    (options___0->num_ports) ++;
#line 88
    options___0->ports[tmp] = (unsigned short)22;
  }
#line 89
  if ((unsigned int )options___0->listen_addrs == (unsigned int )((void *)0)) {
#line 90
    add_listen_addr(options___0, (char *)((void *)0));
  }
#line 91
  if ((unsigned int )options___0->host_key_file == (unsigned int )((void *)0)) {
#line 92
    options___0->host_key_file = (char *)"/usr/local/etc/ssh_host_key";
  }
#line 93
  if ((unsigned int )options___0->host_dsa_key_file == (unsigned int )((void *)0)) {
#line 94
    options___0->host_dsa_key_file = (char *)"/usr/local/etc/ssh_host_dsa_key";
  }
#line 95
  if ((unsigned int )options___0->pid_file == (unsigned int )((void *)0)) {
#line 96
    options___0->pid_file = (char *)"/var/run/sshd.pid";
  }
#line 97
  if (options___0->server_key_bits == -1) {
#line 98
    options___0->server_key_bits = 768;
  }
#line 99
  if (options___0->login_grace_time == -1) {
#line 100
    options___0->login_grace_time = 600;
  }
#line 101
  if (options___0->key_regeneration_time == -1) {
#line 102
    options___0->key_regeneration_time = 3600;
  }
#line 103
  if (options___0->permit_root_login == -1) {
#line 104
    options___0->permit_root_login = 1;
  }
#line 105
  if (options___0->ignore_rhosts == -1) {
#line 106
    options___0->ignore_rhosts = 1;
  }
#line 107
  if (options___0->ignore_user_known_hosts == -1) {
#line 108
    options___0->ignore_user_known_hosts = 0;
  }
#line 109
  if (options___0->check_mail == -1) {
#line 110
    options___0->check_mail = 0;
  }
#line 111
  if (options___0->print_motd == -1) {
#line 112
    options___0->print_motd = 1;
  }
#line 113
  if (options___0->x11_forwarding == -1) {
#line 114
    options___0->x11_forwarding = 0;
  }
#line 115
  if (options___0->x11_display_offset == -1) {
#line 116
    options___0->x11_display_offset = 10;
  }
#line 118
  if ((unsigned int )options___0->xauth_location == (unsigned int )((void *)0)) {
#line 119
    options___0->xauth_location = (char *)"/usr/bin//xauth";
  }
#line 121
  if (options___0->strict_modes == -1) {
#line 122
    options___0->strict_modes = 1;
  }
#line 123
  if (options___0->keepalives == -1) {
#line 124
    options___0->keepalives = 1;
  }
#line 125
  if ((int )options___0->log_facility == (int )((enum __anonenum_SyslogFacility_72 )-1)) {
#line 126
    options___0->log_facility = 2;
  }
#line 127
  if ((int )options___0->log_level == (int )((enum __anonenum_LogLevel_73 )-1)) {
#line 128
    options___0->log_level = 3;
  }
#line 129
  if (options___0->rhosts_authentication == -1) {
#line 130
    options___0->rhosts_authentication = 0;
  }
#line 131
  if (options___0->rhosts_rsa_authentication == -1) {
#line 132
    options___0->rhosts_rsa_authentication = 0;
  }
#line 133
  if (options___0->rsa_authentication == -1) {
#line 134
    options___0->rsa_authentication = 1;
  }
#line 135
  if (options___0->dsa_authentication == -1) {
#line 136
    options___0->dsa_authentication = 1;
  }
#line 151
  if (options___0->password_authentication == -1) {
#line 152
    options___0->password_authentication = 1;
  }
#line 157
  if (options___0->permit_empty_passwd == -1) {
#line 158
    options___0->permit_empty_passwd = 0;
  }
#line 159
  if (options___0->use_login == -1) {
#line 160
    options___0->use_login = 0;
  }
#line 161
  if (options___0->protocol == 0) {
#line 162
    options___0->protocol = 5;
  }
#line 163
  if (options___0->gateway_ports == -1) {
#line 164
    options___0->gateway_ports = 0;
  }
#line 165
  if (options___0->max_startups == -1) {
#line 166
    options___0->max_startups = 10;
  }
#line 167
  if (options___0->max_startups_rate == -1) {
#line 168
    options___0->max_startups_rate = 100;
  }
#line 169
  if (options___0->max_startups_begin == -1) {
#line 170
    options___0->max_startups_begin = options___0->max_startups;
  }
#line 171
  return;
}
}
#line 197 "servconf.c"
static struct __anonstruct_keywords_76 keywords[38]  = 
#line 197
  {      {"port", 1}, 
        {"hostkey", 2}, 
        {"hostdsakey", 29}, 
        {"pidfile", 32}, 
        {"serverkeybits", 3}, 
        {"logingracetime", 4}, 
        {"keyregenerationinterval", 5}, 
        {"permitrootlogin", 6}, 
        {"syslogfacility", 7}, 
        {"loglevel", 8}, 
        {"rhostsauthentication", 9}, 
        {"rhostsrsaauthentication", 10}, 
        {"rsaauthentication", 11}, 
        {"dsaauthentication", 34}, 
        {"passwordauthentication", 12}, 
        {"checkmail", 22}, 
        {"listenaddress", 13}, 
        {"printmotd", 14}, 
        {"ignorerhosts", 15}, 
        {"ignoreuserknownhosts", 28}, 
        {"x11forwarding", 16}, 
        {"x11displayoffset", 17}, 
        {"xauthlocation", 35}, 
        {"strictmodes", 18}, 
        {"permitemptypasswords", 19}, 
        {"uselogin", 23}, 
        {"randomseed", 20}, 
        {"keepalive", 21}, 
        {"allowusers", 24}, 
        {"denyusers", 25}, 
        {"allowgroups", 26}, 
        {"denygroups", 27}, 
        {"ciphers", 30}, 
        {"protocol", 31}, 
        {"gatewayports", 33}, 
        {"subsystem", 36}, 
        {"maxstartups", 37}, 
        {(char const   *)((void *)0), (ServerOpCodes )0}};
#line 258 "servconf.c"
static ServerOpCodes parse_token(char const   *cp , char const   *filename , int linenum ) 
{ unsigned int i ;
  int tmp ;

  {
#line 264
  i = 0U;
#line 264
  while (keywords[i].name) {
#line 265
    tmp = strcasecmp(cp, keywords[i].name);
#line 265
    if (tmp == 0) {
#line 266
      return (keywords[i].opcode);
    }
#line 264
    i ++;
  }
#line 268
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: line %d: Bad configuration option: %s\n",
          filename, linenum, cp);
#line 270
  return (0);
}
}
#line 276 "servconf.c"
void add_listen_addr(ServerOptions *options___0 , char *addr ) 
{ struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  int i ;
  unsigned int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 285
  if (options___0->num_ports == 0U) {
#line 286
    tmp = options___0->num_ports;
#line 286
    (options___0->num_ports) ++;
#line 286
    options___0->ports[tmp] = (unsigned short)22;
  }
#line 287
  i = 0;
#line 287
  while ((unsigned int )i < options___0->num_ports) {
#line 288
    memset((void *)(& hints), 0, sizeof(hints));
#line 289
    hints.ai_family = IPv4or6;
#line 290
    hints.ai_socktype = 1;
#line 291
    if ((unsigned int )addr == (unsigned int )((void *)0)) {
#line 291
      hints.ai_flags = 1;
    } else {
#line 291
      hints.ai_flags = 0;
    }
#line 292
    snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
             options___0->ports[i]);
#line 293
    gaierr = getaddrinfo((char const   * __restrict  )addr, (char const   * __restrict  )(strport),
                         (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 293
    if (gaierr != 0) {
#line 294
      tmp___0 = gai_strerror(gaierr);
#line 294
      if (addr) {
#line 294
        tmp___1 = (char const   *)addr;
      } else {
#line 294
        tmp___1 = "<NULL>";
      }
#line 294
      fatal("bad addr or host: %s (%s)\n", tmp___1, tmp___0);
    }
#line 297
    ai = aitop;
#line 297
    while (ai->ai_next) {
#line 297
      ai = ai->ai_next;
    }
#line 299
    ai->ai_next = options___0->listen_addrs;
#line 300
    options___0->listen_addrs = aitop;
#line 287
    i ++;
  }
#line 302
  return;
}
}
#line 306 "servconf.c"
void read_server_config(ServerOptions *options___0 , char const   *filename ) 
{ FILE *f ;
  char line[1024] ;
  char *cp ;
  char **charptr ;
  char *arg ;
  int linenum ;
  int *intptr ;
  int value ;
  int bad_options ;
  ServerOpCodes opcode ;
  int i ;
  unsigned int tmp ;
  int tmp___0 ;
  __uid_t tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___17 ;
  int tmp___20 ;
  int tmp___21 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___27 ;
  int tmp___30 ;
  int tmp___31 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___37 ;
  int tmp___40 ;
  int tmp___41 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___47 ;
  int tmp___50 ;
  int tmp___51 ;
  SyslogFacility tmp___52 ;
  char const   *tmp___53 ;
  LogLevel tmp___54 ;
  char const   *tmp___55 ;
  unsigned int tmp___56 ;
  unsigned int tmp___57 ;
  unsigned int tmp___58 ;
  unsigned int tmp___59 ;
  char const   *tmp___60 ;
  int tmp___61 ;
  char const   *tmp___62 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___68 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  char *tmp___74 ;

  {
#line 313
  bad_options = 0;
#line 317
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 318
  if (! f) {
#line 319
    perror(filename);
#line 320
    exit(1);
  }
#line 322
  linenum = 0;
#line 323
  while (1) {
#line 323
    tmp___74 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 323
    if (! tmp___74) {
#line 323
      break;
    }
#line 324
    linenum ++;
#line 325
    cp = line;
#line 326
    arg = strdelim(& cp);
#line 328
    if ((int )*arg == 0) {
#line 329
      arg = strdelim(& cp);
    }
#line 330
    if (! *arg) {
#line 331
      continue;
    } else {
#line 330
      if ((int )*arg == 35) {
#line 331
        continue;
      }
    }
#line 332
    opcode = parse_token((char const   *)arg, filename, linenum);
#line 333
    switch ((int )opcode) {
    case 0: 
#line 335
    bad_options ++;
#line 336
    continue;
    case 1: 
#line 339
    if (options___0->ports_from_cmdline) {
#line 340
      continue;
    }
#line 341
    if ((unsigned int )options___0->listen_addrs != (unsigned int )((void *)0)) {
#line 342
      fatal("%s line %d: ports must be specified before ListenAdress.\n", filename,
            linenum);
    }
#line 344
    if (options___0->num_ports >= 256U) {
#line 345
      fatal("%s line %d: too many ports.\n", filename, linenum);
    }
#line 347
    arg = strdelim(& cp);
#line 348
    if (! arg) {
#line 349
      fatal("%s line %d: missing port number.\n", filename, linenum);
    } else {
#line 348
      if ((int )*arg == 0) {
#line 349
        fatal("%s line %d: missing port number.\n", filename, linenum);
      }
    }
#line 351
    tmp = options___0->num_ports;
#line 351
    (options___0->num_ports) ++;
#line 351
    tmp___0 = atoi((char const   *)arg);
#line 351
    options___0->ports[tmp] = (unsigned short )tmp___0;
#line 352
    break;
    case 3: 
#line 355
    intptr = & options___0->server_key_bits;
    parse_int: 
#line 357
    arg = strdelim(& cp);
#line 358
    if (! arg) {
#line 359
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing integer value.\n",
              filename, linenum);
#line 361
      exit(1);
    } else {
#line 358
      if ((int )*arg == 0) {
#line 359
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing integer value.\n",
                filename, linenum);
#line 361
        exit(1);
      }
    }
#line 363
    value = atoi((char const   *)arg);
#line 364
    if (*intptr == -1) {
#line 365
      *intptr = value;
    }
#line 366
    break;
    case 4: 
#line 369
    intptr = & options___0->login_grace_time;
    goto parse_int;
    case 5: 
#line 373
    intptr = & options___0->key_regeneration_time;
    goto parse_int;
    case 13: 
#line 377
    arg = strdelim(& cp);
#line 378
    if (! arg) {
#line 379
      fatal("%s line %d: missing inet addr.\n", filename, linenum);
    } else {
#line 378
      if ((int )*arg == 0) {
#line 379
        fatal("%s line %d: missing inet addr.\n", filename, linenum);
      }
    }
#line 381
    add_listen_addr(options___0, arg);
#line 382
    break;
    case 2: 
    case 29: 
#line 386
    if ((int )opcode == 2) {
#line 386
      charptr = & options___0->host_key_file;
    } else {
#line 386
      charptr = & options___0->host_dsa_key_file;
    }
    parse_filename: 
#line 389
    arg = strdelim(& cp);
#line 390
    if (! arg) {
#line 391
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing file name.\n",
              filename, linenum);
#line 393
      exit(1);
    } else {
#line 390
      if ((int )*arg == 0) {
#line 391
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing file name.\n",
                filename, linenum);
#line 393
        exit(1);
      }
    }
#line 395
    if ((unsigned int )*charptr == (unsigned int )((void *)0)) {
#line 396
      tmp___1 = getuid();
#line 396
      *charptr = tilde_expand_filename((char const   *)arg, tmp___1);
    }
#line 397
    break;
    case 32: 
#line 400
    charptr = & options___0->pid_file;
    goto parse_filename;
    case 20: 
#line 404
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: \"randomseed\" option is obsolete.\n",
            filename, linenum);
#line 406
    arg = strdelim(& cp);
#line 407
    break;
    case 6: 
#line 410
    intptr = & options___0->permit_root_login;
#line 411
    arg = strdelim(& cp);
#line 412
    if (! arg) {
#line 413
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing yes/without-password/no argument.\n",
              filename, linenum);
#line 415
      exit(1);
    } else {
#line 412
      if ((int )*arg == 0) {
#line 413
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing yes/without-password/no argument.\n",
                filename, linenum);
#line 415
        exit(1);
      }
    }
#line 417
    if (0) {
#line 417
      __s1_len___1 = strlen((char const   *)arg);
#line 417
      __s2_len___1 = strlen("without-password");
#line 417
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___4;
      } else {
#line 417
        if (__s1_len___1 >= 4U) {
          _L___4: /* CIL Label */ 
#line 417
          if (! ((unsigned int )((void const   *)("without-password" + 1)) - (unsigned int )((void const   *)"without-password") == 1U)) {
#line 417
            tmp___31 = 1;
          } else {
#line 417
            if (__s2_len___1 >= 4U) {
#line 417
              tmp___31 = 1;
            } else {
#line 417
              tmp___31 = 0;
            }
          }
        } else {
#line 417
          tmp___31 = 0;
        }
      }
#line 417
      if (tmp___31) {
#line 417
        tmp___27 = __builtin_strcmp((char const   *)arg, "without-password");
      } else {
#line 417
        tmp___30 = __builtin_strcmp((char const   *)arg, "without-password");
#line 417
        tmp___27 = tmp___30;
      }
    } else {
#line 417
      tmp___30 = __builtin_strcmp((char const   *)arg, "without-password");
#line 417
      tmp___27 = tmp___30;
    }
#line 417
    if (tmp___27 == 0) {
#line 418
      value = 2;
    } else {
#line 419
      if (0) {
#line 419
        __s1_len___0 = strlen((char const   *)arg);
#line 419
        __s2_len___0 = strlen("yes");
#line 419
        if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
          goto _L___2;
        } else {
#line 419
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 419
            if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 419
              tmp___21 = 1;
            } else {
#line 419
              if (__s2_len___0 >= 4U) {
#line 419
                tmp___21 = 1;
              } else {
#line 419
                tmp___21 = 0;
              }
            }
          } else {
#line 419
            tmp___21 = 0;
          }
        }
#line 419
        if (tmp___21) {
#line 419
          tmp___17 = __builtin_strcmp((char const   *)arg, "yes");
        } else {
#line 419
          tmp___20 = __builtin_strcmp((char const   *)arg, "yes");
#line 419
          tmp___17 = tmp___20;
        }
      } else {
#line 419
        tmp___20 = __builtin_strcmp((char const   *)arg, "yes");
#line 419
        tmp___17 = tmp___20;
      }
#line 419
      if (tmp___17 == 0) {
#line 420
        value = 1;
      } else {
#line 421
        if (0) {
#line 421
          __s1_len = strlen((char const   *)arg);
#line 421
          __s2_len = strlen("no");
#line 421
          if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
            goto _L___0;
          } else {
#line 421
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 421
              if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 421
                tmp___11 = 1;
              } else {
#line 421
                if (__s2_len >= 4U) {
#line 421
                  tmp___11 = 1;
                } else {
#line 421
                  tmp___11 = 0;
                }
              }
            } else {
#line 421
              tmp___11 = 0;
            }
          }
#line 421
          if (tmp___11) {
#line 421
            tmp___7 = __builtin_strcmp((char const   *)arg, "no");
          } else {
#line 421
            tmp___10 = __builtin_strcmp((char const   *)arg, "no");
#line 421
            tmp___7 = tmp___10;
          }
        } else {
#line 421
          tmp___10 = __builtin_strcmp((char const   *)arg, "no");
#line 421
          tmp___7 = tmp___10;
        }
#line 421
        if (tmp___7 == 0) {
#line 422
          value = 0;
        } else {
#line 424
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: Bad yes/without-password/no argument: %s\n",
                  filename, linenum, arg);
#line 426
          exit(1);
        }
      }
    }
#line 428
    if (*intptr == -1) {
#line 429
      *intptr = value;
    }
#line 430
    break;
    case 15: 
#line 433
    intptr = & options___0->ignore_rhosts;
    parse_flag: 
#line 435
    arg = strdelim(& cp);
#line 436
    if (! arg) {
#line 437
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing yes/no argument.\n",
              filename, linenum);
#line 439
      exit(1);
    } else {
#line 436
      if ((int )*arg == 0) {
#line 437
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing yes/no argument.\n",
                filename, linenum);
#line 439
        exit(1);
      }
    }
#line 441
    if (0) {
#line 441
      __s1_len___3 = strlen((char const   *)arg);
#line 441
      __s2_len___3 = strlen("yes");
#line 441
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___8;
      } else {
#line 441
        if (__s1_len___3 >= 4U) {
          _L___8: /* CIL Label */ 
#line 441
          if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 441
            tmp___51 = 1;
          } else {
#line 441
            if (__s2_len___3 >= 4U) {
#line 441
              tmp___51 = 1;
            } else {
#line 441
              tmp___51 = 0;
            }
          }
        } else {
#line 441
          tmp___51 = 0;
        }
      }
#line 441
      if (tmp___51) {
#line 441
        tmp___47 = __builtin_strcmp((char const   *)arg, "yes");
      } else {
#line 441
        tmp___50 = __builtin_strcmp((char const   *)arg, "yes");
#line 441
        tmp___47 = tmp___50;
      }
    } else {
#line 441
      tmp___50 = __builtin_strcmp((char const   *)arg, "yes");
#line 441
      tmp___47 = tmp___50;
    }
#line 441
    if (tmp___47 == 0) {
#line 442
      value = 1;
    } else {
#line 443
      if (0) {
#line 443
        __s1_len___2 = strlen((char const   *)arg);
#line 443
        __s2_len___2 = strlen("no");
#line 443
        if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
          goto _L___6;
        } else {
#line 443
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 443
            if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 443
              tmp___41 = 1;
            } else {
#line 443
              if (__s2_len___2 >= 4U) {
#line 443
                tmp___41 = 1;
              } else {
#line 443
                tmp___41 = 0;
              }
            }
          } else {
#line 443
            tmp___41 = 0;
          }
        }
#line 443
        if (tmp___41) {
#line 443
          tmp___37 = __builtin_strcmp((char const   *)arg, "no");
        } else {
#line 443
          tmp___40 = __builtin_strcmp((char const   *)arg, "no");
#line 443
          tmp___37 = tmp___40;
        }
      } else {
#line 443
        tmp___40 = __builtin_strcmp((char const   *)arg, "no");
#line 443
        tmp___37 = tmp___40;
      }
#line 443
      if (tmp___37 == 0) {
#line 444
        value = 0;
      } else {
#line 446
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: Bad yes/no argument: %s\n",
                filename, linenum, arg);
#line 448
        exit(1);
      }
    }
#line 450
    if (*intptr == -1) {
#line 451
      *intptr = value;
    }
#line 452
    break;
    case 28: 
#line 455
    intptr = & options___0->ignore_user_known_hosts;
    goto parse_flag;
    case 9: 
#line 459
    intptr = & options___0->rhosts_authentication;
    goto parse_flag;
    case 10: 
#line 463
    intptr = & options___0->rhosts_rsa_authentication;
    goto parse_flag;
    case 11: 
#line 467
    intptr = & options___0->rsa_authentication;
    goto parse_flag;
    case 34: 
#line 471
    intptr = & options___0->dsa_authentication;
    goto parse_flag;
    case 12: 
#line 499
    intptr = & options___0->password_authentication;
    goto parse_flag;
    case 22: 
#line 503
    intptr = & options___0->check_mail;
    goto parse_flag;
    case 14: 
#line 513
    intptr = & options___0->print_motd;
    goto parse_flag;
    case 16: 
#line 517
    intptr = & options___0->x11_forwarding;
    goto parse_flag;
    case 17: 
#line 521
    intptr = & options___0->x11_display_offset;
    goto parse_int;
    case 35: 
#line 525
    charptr = & options___0->xauth_location;
    goto parse_filename;
    case 18: 
#line 529
    intptr = & options___0->strict_modes;
    goto parse_flag;
    case 21: 
#line 533
    intptr = & options___0->keepalives;
    goto parse_flag;
    case 19: 
#line 537
    intptr = & options___0->permit_empty_passwd;
    goto parse_flag;
    case 23: 
#line 541
    intptr = & options___0->use_login;
    goto parse_flag;
    case 33: 
#line 545
    intptr = & options___0->gateway_ports;
    goto parse_flag;
    case 7: 
#line 549
    intptr = (int *)(& options___0->log_facility);
#line 550
    arg = strdelim(& cp);
#line 551
    tmp___52 = log_facility_number(arg);
#line 551
    value = (int )tmp___52;
#line 552
    if (value == (int )((enum __anonenum_SyslogFacility_72 )-1)) {
#line 553
      if (arg) {
#line 553
        tmp___53 = (char const   *)arg;
      } else {
#line 553
        tmp___53 = "<NONE>";
      }
#line 553
      fatal("%.200s line %d: unsupported log facility \'%s\'\n", filename, linenum,
            tmp___53);
    }
#line 555
    if (*intptr == -1) {
#line 556
      *intptr = (int )((enum __anonenum_SyslogFacility_72 )value);
    }
#line 557
    break;
    case 8: 
#line 560
    intptr = (int *)(& options___0->log_level);
#line 561
    arg = strdelim(& cp);
#line 562
    tmp___54 = log_level_number(arg);
#line 562
    value = (int )tmp___54;
#line 563
    if (value == (int )((enum __anonenum_LogLevel_73 )-1)) {
#line 564
      if (arg) {
#line 564
        tmp___55 = (char const   *)arg;
      } else {
#line 564
        tmp___55 = "<NONE>";
      }
#line 564
      fatal("%.200s line %d: unsupported log level \'%s\'\n", filename, linenum, tmp___55);
    }
#line 566
    if (*intptr == -1) {
#line 567
      *intptr = (int )((enum __anonenum_LogLevel_73 )value);
    }
#line 568
    break;
    case 24: 
#line 571
    while (1) {
#line 571
      arg = strdelim(& cp);
#line 571
      if (arg) {
#line 571
        if (! ((int )*arg != 0)) {
#line 571
          break;
        }
      } else {
#line 571
        break;
      }
#line 572
      if (options___0->num_allow_users >= 256U) {
#line 573
        fatal("%s line %d: too many allow users.\n", filename, linenum);
      }
#line 575
      tmp___56 = options___0->num_allow_users;
#line 575
      (options___0->num_allow_users) ++;
#line 575
      options___0->allow_users[tmp___56] = xstrdup((char const   *)arg);
    }
#line 577
    break;
    case 25: 
#line 580
    while (1) {
#line 580
      arg = strdelim(& cp);
#line 580
      if (arg) {
#line 580
        if (! ((int )*arg != 0)) {
#line 580
          break;
        }
      } else {
#line 580
        break;
      }
#line 581
      if (options___0->num_deny_users >= 256U) {
#line 582
        fatal("%s line %d: too many deny users.\n", filename, linenum);
      }
#line 584
      tmp___57 = options___0->num_deny_users;
#line 584
      (options___0->num_deny_users) ++;
#line 584
      options___0->deny_users[tmp___57] = xstrdup((char const   *)arg);
    }
#line 586
    break;
    case 26: 
#line 589
    while (1) {
#line 589
      arg = strdelim(& cp);
#line 589
      if (arg) {
#line 589
        if (! ((int )*arg != 0)) {
#line 589
          break;
        }
      } else {
#line 589
        break;
      }
#line 590
      if (options___0->num_allow_groups >= 256U) {
#line 591
        fatal("%s line %d: too many allow groups.\n", filename, linenum);
      }
#line 593
      tmp___58 = options___0->num_allow_groups;
#line 593
      (options___0->num_allow_groups) ++;
#line 593
      options___0->allow_groups[tmp___58] = xstrdup((char const   *)arg);
    }
#line 595
    break;
    case 27: 
#line 598
    while (1) {
#line 598
      arg = strdelim(& cp);
#line 598
      if (arg) {
#line 598
        if (! ((int )*arg != 0)) {
#line 598
          break;
        }
      } else {
#line 598
        break;
      }
#line 599
      if (options___0->num_deny_groups >= 256U) {
#line 600
        fatal("%s line %d: too many deny groups.\n", filename, linenum);
      }
#line 602
      tmp___59 = options___0->num_deny_groups;
#line 602
      (options___0->num_deny_groups) ++;
#line 602
      options___0->deny_groups[tmp___59] = xstrdup((char const   *)arg);
    }
#line 604
    break;
    case 30: 
#line 607
    arg = strdelim(& cp);
#line 608
    if (! arg) {
#line 609
      fatal("%s line %d: Missing argument.", filename, linenum);
    } else {
#line 608
      if ((int )*arg == 0) {
#line 609
        fatal("%s line %d: Missing argument.", filename, linenum);
      }
    }
#line 610
    tmp___61 = ciphers_valid((char const   *)arg);
#line 610
    if (! tmp___61) {
#line 611
      if (arg) {
#line 611
        tmp___60 = (char const   *)arg;
      } else {
#line 611
        tmp___60 = "<NONE>";
      }
#line 611
      fatal("%s line %d: Bad SSH2 cipher spec \'%s\'.", filename, linenum, tmp___60);
    }
#line 613
    if ((unsigned int )options___0->ciphers == (unsigned int )((void *)0)) {
#line 614
      options___0->ciphers = xstrdup((char const   *)arg);
    }
#line 615
    break;
    case 31: 
#line 618
    intptr = & options___0->protocol;
#line 619
    arg = strdelim(& cp);
#line 620
    if (! arg) {
#line 621
      fatal("%s line %d: Missing argument.", filename, linenum);
    } else {
#line 620
      if ((int )*arg == 0) {
#line 621
        fatal("%s line %d: Missing argument.", filename, linenum);
      }
    }
#line 622
    value = proto_spec((char const   *)arg);
#line 623
    if (value == 0) {
#line 624
      if (arg) {
#line 624
        tmp___62 = (char const   *)arg;
      } else {
#line 624
        tmp___62 = "<NONE>";
      }
#line 624
      fatal("%s line %d: Bad protocol spec \'%s\'.", filename, linenum, tmp___62);
    }
#line 626
    if (*intptr == 0) {
#line 627
      *intptr = value;
    }
#line 628
    break;
    case 36: 
#line 631
    if (options___0->num_subsystems >= 256U) {
#line 632
      fatal("%s line %d: too many subsystems defined.", filename, linenum);
    }
#line 635
    arg = strdelim(& cp);
#line 636
    if (! arg) {
#line 637
      fatal("%s line %d: Missing subsystem name.", filename, linenum);
    } else {
#line 636
      if ((int )*arg == 0) {
#line 637
        fatal("%s line %d: Missing subsystem name.", filename, linenum);
      }
    }
#line 639
    i = 0;
#line 639
    while ((unsigned int )i < options___0->num_subsystems) {
#line 640
      if (0) {
#line 640
        __s1_len___4 = strlen((char const   *)arg);
#line 640
        __s2_len___4 = strlen((char const   *)options___0->subsystem_name[i]);
#line 640
        if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
          goto _L___10;
        } else {
#line 640
          if (__s1_len___4 >= 4U) {
            _L___10: /* CIL Label */ 
#line 640
            if (! ((unsigned int )((void const   *)(options___0->subsystem_name[i] + 1)) - (unsigned int )((void const   *)options___0->subsystem_name[i]) == 1U)) {
#line 640
              tmp___72 = 1;
            } else {
#line 640
              if (__s2_len___4 >= 4U) {
#line 640
                tmp___72 = 1;
              } else {
#line 640
                tmp___72 = 0;
              }
            }
          } else {
#line 640
            tmp___72 = 0;
          }
        }
#line 640
        if (tmp___72) {
#line 640
          tmp___68 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
        } else {
#line 640
          tmp___71 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
#line 640
          tmp___68 = tmp___71;
        }
      } else {
#line 640
        tmp___71 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
#line 640
        tmp___68 = tmp___71;
      }
#line 640
      if (tmp___68 == 0) {
#line 641
        fatal("%s line %d: Subsystem \'%s\' already defined.", filename, linenum,
              arg);
      }
#line 639
      i ++;
    }
#line 643
    options___0->subsystem_name[options___0->num_subsystems] = xstrdup((char const   *)arg);
#line 644
    arg = strdelim(& cp);
#line 645
    if (! arg) {
#line 646
      fatal("%s line %d: Missing subsystem command.", filename, linenum);
    } else {
#line 645
      if ((int )*arg == 0) {
#line 646
        fatal("%s line %d: Missing subsystem command.", filename, linenum);
      }
    }
#line 648
    options___0->subsystem_command[options___0->num_subsystems] = xstrdup((char const   *)arg);
#line 649
    (options___0->num_subsystems) ++;
#line 650
    break;
    case 37: 
#line 653
    arg = strdelim(& cp);
#line 654
    if (! arg) {
#line 655
      fatal("%s line %d: Missing MaxStartups spec.", filename, linenum);
    } else {
#line 654
      if ((int )*arg == 0) {
#line 655
        fatal("%s line %d: Missing MaxStartups spec.", filename, linenum);
      }
    }
#line 657
    tmp___73 = sscanf((char const   * __restrict  )arg, (char const   * __restrict  )"%d:%d:%d",
                      & options___0->max_startups_begin, & options___0->max_startups_rate,
                      & options___0->max_startups);
#line 657
    if (tmp___73 == 3) {
#line 661
      if (options___0->max_startups_begin > options___0->max_startups) {
#line 665
        fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
      } else {
#line 661
        if (options___0->max_startups_rate > 100) {
#line 665
          fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
        } else {
#line 661
          if (options___0->max_startups_rate < 1) {
#line 665
            fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
          }
        }
      }
#line 667
      break;
    }
#line 669
    intptr = & options___0->max_startups;
    goto parse_int;
    default: 
#line 673
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: Missing handler for opcode %s (%d)\n",
            filename, linenum, arg, opcode);
#line 675
    exit(1);
    }
#line 677
    arg = strdelim(& cp);
#line 677
    if ((unsigned int )arg != (unsigned int )((void *)0)) {
#line 677
      if ((int )*arg != 0) {
#line 678
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: garbage at end of line; \"%.200s\".\n",
                filename, linenum, arg);
#line 681
        exit(1);
      }
    }
  }
#line 684
  fclose(f);
#line 685
  if (bad_options > 0) {
#line 686
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: terminating, %d bad configuration options\n",
            filename, bad_options);
#line 688
    exit(1);
  }
#line 690
  return;
}
}
#line 1 "serverloop.o"
#line 116 "/usr/include/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 509 "ssh.h"
void server_loop(pid_t pid , int fdin_arg , int fdout_arg , int fderr_arg ) ;
#line 510
void server_loop2(void) ;
#line 9 "session.h"
int session_open(int chanid ) ;
#line 10
void session_input_channel_req(int id , void *arg ) ;
#line 11
void session_close_by_pid(pid_t pid , int status ) ;
#line 12
void session_close_by_channel(int id , void *arg ) ;
#line 28 "serverloop.c"
static Buffer stdin_buffer  ;
#line 29 "serverloop.c"
static Buffer stdout_buffer  ;
#line 30 "serverloop.c"
static Buffer stderr_buffer  ;
#line 31 "serverloop.c"
static int fdin  ;
#line 32 "serverloop.c"
static int fdout  ;
#line 34 "serverloop.c"
static int fderr  ;
#line 35 "serverloop.c"
static long stdin_bytes  =    0L;
#line 36 "serverloop.c"
static long stdout_bytes  =    0L;
#line 37 "serverloop.c"
static long stderr_bytes  =    0L;
#line 38 "serverloop.c"
static long fdout_bytes  =    0L;
#line 39 "serverloop.c"
static int stdin_eof  =    0;
#line 40 "serverloop.c"
static int fdout_eof  =    0;
#line 41 "serverloop.c"
static int fderr_eof  =    0;
#line 42 "serverloop.c"
static int connection_in___0  ;
#line 43 "serverloop.c"
static int connection_out___0  ;
#line 44 "serverloop.c"
static unsigned int buffer_high  ;
#line 45 "serverloop.c"
static int max_fd  ;
#line 56 "serverloop.c"
static pid_t child_pid  ;
#line 57 "serverloop.c"
static int volatile   child_terminated  ;
#line 58 "serverloop.c"
static int volatile   child_has_selected  ;
#line 59 "serverloop.c"
static int volatile   child_wait_status  ;
#line 61
void server_init_dispatch(void) ;
#line 63 "serverloop.c"
void sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  pid_t wait_pid ;
  union __anonunion_77 __constr_expr_0 ;
  union __anonunion_78 __constr_expr_1 ;
  int *tmp___0 ;

  {
#line 66
  tmp = __errno_location();
#line 66
  save_errno = *tmp;
#line 69
  debug("Received SIGCHLD.");
#line 70
  wait_pid = wait((union wait *)((int *)(& child_wait_status)));
#line 71
  if (wait_pid != -1) {
#line 72
    if (wait_pid != child_pid) {
#line 73
      error("Strange, got SIGCHLD and wait returned pid %d but child is %d", wait_pid,
            child_pid);
    }
#line 75
    __constr_expr_0.__in = child_wait_status;
#line 75
    if ((__constr_expr_0.__i & 127) == 0) {
#line 77
      child_terminated = (int volatile   )1;
    } else {
#line 75
      __constr_expr_1.__in = child_wait_status;
#line 75
      if ((int )((signed char )((__constr_expr_1.__i & 127) + 1)) >> 1 > 0) {
#line 77
        child_terminated = (int volatile   )1;
      }
    }
#line 78
    child_has_selected = (int volatile   )0;
  }
#line 80
  signal(17, & sigchld_handler);
#line 81
  tmp___0 = __errno_location();
#line 81
  *tmp___0 = save_errno;
#line 82
  return;
}
}
#line 83 "serverloop.c"
void sigchld_handler2(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 86
  tmp = __errno_location();
#line 86
  save_errno = *tmp;
#line 87
  debug("Received SIGCHLD.");
#line 88
  child_terminated = (int volatile   )1;
#line 89
  tmp___0 = __errno_location();
#line 89
  *tmp___0 = save_errno;
#line 90
  return;
}
}
#line 96 "serverloop.c"
void make_packets_from_stderr_data(void) 
{ int len ;
  unsigned int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
#line 102
  while (1) {
#line 102
    tmp___2 = buffer_len(& stderr_buffer);
#line 102
    if (tmp___2 > 0U) {
#line 102
      tmp___3 = packet_not_very_much_data_to_write();
#line 102
      if (! tmp___3) {
#line 102
        break;
      }
    } else {
#line 102
      break;
    }
#line 104
    tmp = buffer_len(& stderr_buffer);
#line 104
    len = (int )tmp;
#line 105
    tmp___0 = packet_is_interactive();
#line 105
    if (tmp___0) {
#line 106
      if (len > 512) {
#line 107
        len = 512;
      }
    } else {
#line 110
      if (len > max_packet_size) {
#line 111
        len = max_packet_size;
      }
    }
#line 113
    packet_start(18);
#line 114
    tmp___1 = buffer_ptr(& stderr_buffer);
#line 114
    packet_put_string((char const   *)tmp___1, (unsigned int )len);
#line 115
    packet_send();
#line 116
    buffer_consume(& stderr_buffer, (unsigned int )len);
#line 117
    stderr_bytes += (long )len;
  }
#line 119
  return;
}
}
#line 125 "serverloop.c"
void make_packets_from_stdout_data(void) 
{ int len ;
  unsigned int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
#line 131
  while (1) {
#line 131
    tmp___2 = buffer_len(& stdout_buffer);
#line 131
    if (tmp___2 > 0U) {
#line 131
      tmp___3 = packet_not_very_much_data_to_write();
#line 131
      if (! tmp___3) {
#line 131
        break;
      }
    } else {
#line 131
      break;
    }
#line 133
    tmp = buffer_len(& stdout_buffer);
#line 133
    len = (int )tmp;
#line 134
    tmp___0 = packet_is_interactive();
#line 134
    if (tmp___0) {
#line 135
      if (len > 512) {
#line 136
        len = 512;
      }
    } else {
#line 139
      if (len > max_packet_size) {
#line 140
        len = max_packet_size;
      }
    }
#line 142
    packet_start(17);
#line 143
    tmp___1 = buffer_ptr(& stdout_buffer);
#line 143
    packet_put_string((char const   *)tmp___1, (unsigned int )len);
#line 144
    packet_send();
#line 145
    buffer_consume(& stdout_buffer, (unsigned int )len);
#line 146
    stdout_bytes += (long )len;
  }
#line 148
  return;
}
}
#line 156 "serverloop.c"
void wait_until_can_do_something(fd_set *readset , fd_set *writeset , unsigned int max_time_milliseconds ) 
{ struct timeval tv ;
  struct timeval *tvp ;
  int ret ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;

  {
  retry_select: 
#line 167
  while (1) {
#line 167
    __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readset->__fds_bits[0]): "memory");
#line 167
    break;
  }
#line 168
  while (1) {
#line 168
    __asm__  volatile   ("cld; rep; stosl": "=c" (__d0___0), "=D" (__d1___0): "a" (0),
                         "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& writeset->__fds_bits[0]): "memory");
#line 168
    break;
  }
#line 170
  if (compat20) {
#line 172
    tmp = channel_not_very_much_buffered_data();
#line 172
    if (tmp) {
#line 173
      __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
  } else {
#line 179
    tmp___0 = buffer_len(& stdin_buffer);
#line 179
    if (tmp___0 < buffer_high) {
#line 179
      tmp___1 = channel_not_very_much_buffered_data();
#line 179
      if (tmp___1) {
#line 181
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
#line 186
    tmp___2 = packet_not_very_much_data_to_write();
#line 186
    if (tmp___2) {
#line 187
      if (! fdout_eof) {
#line 188
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
#line 189
      if (! fderr_eof) {
#line 190
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
#line 196
    if (fdin != -1) {
#line 196
      tmp___3 = buffer_len(& stdin_buffer);
#line 196
      if (tmp___3 > 0U) {
#line 197
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
  }
#line 200
  channel_prepare_select(readset, writeset);
#line 206
  tmp___4 = packet_have_data_to_write();
#line 206
  if (tmp___4) {
#line 207
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 210
  tmp___5 = channel_max_fd();
#line 210
  if (tmp___5 > max_fd) {
#line 211
    max_fd = channel_max_fd();
  }
#line 217
  if (child_terminated) {
#line 217
    tmp___6 = packet_not_very_much_data_to_write();
#line 217
    if (tmp___6) {
#line 218
      if (max_time_milliseconds == 0U) {
#line 219
        max_time_milliseconds = 100U;
      }
    }
  }
#line 221
  if (max_time_milliseconds == 0U) {
#line 222
    tvp = (struct timeval *)((void *)0);
  } else {
#line 224
    tv.tv_sec = (long )(max_time_milliseconds / 1000U);
#line 225
    tv.tv_usec = (long )(1000U * (max_time_milliseconds % 1000U));
#line 226
    tvp = & tv;
  }
#line 228
  if ((unsigned int )tvp != (unsigned int )((void *)0)) {
#line 229
    debug("tvp!=NULL kid %d mili %d", child_terminated, max_time_milliseconds);
  }
#line 232
  ret = select(max_fd + 1, (fd_set * __restrict  )readset, (fd_set * __restrict  )writeset,
               (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )tvp);
#line 234
  if (ret < 0) {
#line 235
    tmp___9 = __errno_location();
#line 235
    if (*tmp___9 != 4) {
#line 236
      tmp___7 = __errno_location();
#line 236
      tmp___8 = strerror(*tmp___7);
#line 236
      error("select: %.100s", tmp___8);
    } else {
      goto retry_select;
    }
  }
#line 241
  if (child_terminated) {
#line 242
    child_has_selected = (int volatile   )1;
  }
#line 243
  return;
}
}
#line 249 "serverloop.c"
void process_input(fd_set *readset ) 
{ int len ;
  char buf___1[16384] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  register char __result ;
  int *tmp___3 ;
  int *tmp___4 ;
  register char __result___0 ;
  int *tmp___5 ;
  int *tmp___6 ;
  register char __result___1 ;

  {
#line 256
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 256
  if (__result) {
#line 257
    len = read(connection_in___0, (void *)(buf___1), sizeof(buf___1));
#line 258
    if (len == 0) {
#line 259
      verbose("Connection closed by remote host.");
#line 260
      fatal_cleanup();
    } else {
#line 261
      if (len < 0) {
#line 262
        tmp___1 = __errno_location();
#line 262
        if (*tmp___1 != 4) {
#line 262
          tmp___2 = __errno_location();
#line 262
          if (*tmp___2 != 11) {
#line 263
            tmp = __errno_location();
#line 263
            tmp___0 = strerror(*tmp);
#line 263
            verbose("Read error from remote host: %.100s", tmp___0);
#line 264
            fatal_cleanup();
          }
        }
      } else {
#line 268
        packet_process_incoming((char const   *)(buf___1), (unsigned int )len);
      }
    }
  }
#line 271
  if (compat20) {
#line 272
    return;
  }
#line 275
  if (! fdout_eof) {
#line 275
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "cc");
#line 275
    if (__result___0) {
#line 276
      len = read(fdout, (void *)(buf___1), sizeof(buf___1));
#line 277
      if (len < 0) {
#line 277
        tmp___3 = __errno_location();
#line 277
        if (! (*tmp___3 == 4)) {
#line 277
          tmp___4 = __errno_location();
#line 277
          if (! (*tmp___4 == 11)) {
            goto _L;
          }
        }
      } else {
        _L: /* CIL Label */ 
#line 279
        if (len <= 0) {
#line 280
          fdout_eof = 1;
        } else {
#line 282
          buffer_append(& stdout_buffer, (char const   *)(buf___1), (unsigned int )len);
#line 283
          fdout_bytes += (long )len;
        }
      }
    }
  }
#line 287
  if (! fderr_eof) {
#line 287
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___1): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "cc");
#line 287
    if (__result___1) {
#line 288
      len = read(fderr, (void *)(buf___1), sizeof(buf___1));
#line 289
      if (len < 0) {
#line 289
        tmp___5 = __errno_location();
#line 289
        if (! (*tmp___5 == 4)) {
#line 289
          tmp___6 = __errno_location();
#line 289
          if (! (*tmp___6 == 11)) {
            goto _L___0;
          }
        }
      } else {
        _L___0: /* CIL Label */ 
#line 291
        if (len <= 0) {
#line 292
          fderr_eof = 1;
        } else {
#line 294
          buffer_append(& stderr_buffer, (char const   *)(buf___1), (unsigned int )len);
        }
      }
    }
  }
#line 297
  return;
}
}
#line 302 "serverloop.c"
void process_output(fd_set *writeset ) 
{ int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  register char __result ;
  register char __result___0 ;

  {
#line 308
  if (! compat20) {
#line 308
    if (fdin != -1) {
#line 308
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))),
                           "m" (writeset->__fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "cc");
#line 308
      if (__result) {
#line 309
        tmp = buffer_len(& stdin_buffer);
#line 309
        tmp___0 = buffer_ptr(& stdin_buffer);
#line 309
        len = write(fdin, (void const   *)tmp___0, tmp);
#line 311
        if (len < 0) {
#line 311
          tmp___1 = __errno_location();
#line 311
          if (! (*tmp___1 == 4)) {
#line 311
            tmp___2 = __errno_location();
#line 311
            if (! (*tmp___2 == 11)) {
              goto _L;
            }
          }
        } else {
          _L: /* CIL Label */ 
#line 313
          if (len <= 0) {
#line 317
            if (fdin != fdout) {
#line 318
              close(fdin);
            } else {
#line 320
              shutdown(fdin, 1);
            }
#line 322
            fdin = -1;
          } else {
#line 325
            buffer_consume(& stdin_buffer, (unsigned int )len);
#line 327
            stdin_bytes += (long )len;
          }
        }
      }
    }
  }
#line 331
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->__fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 331
  if (__result___0) {
#line 332
    packet_write_poll();
  }
#line 333
  return;
}
}
#line 339 "serverloop.c"
void drain_output(void) 
{ unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;

  {
#line 343
  tmp___2 = buffer_len(& stdout_buffer);
#line 343
  if (tmp___2 > 0U) {
#line 344
    packet_start(17);
#line 345
    tmp = buffer_len(& stdout_buffer);
#line 345
    tmp___0 = buffer_ptr(& stdout_buffer);
#line 345
    packet_put_string((char const   *)tmp___0, tmp);
#line 347
    packet_send();
#line 349
    tmp___1 = buffer_len(& stdout_buffer);
#line 349
    stdout_bytes = (long )((unsigned long )stdout_bytes + (unsigned long )tmp___1);
  }
#line 352
  tmp___6 = buffer_len(& stderr_buffer);
#line 352
  if (tmp___6 > 0U) {
#line 353
    packet_start(18);
#line 354
    tmp___3 = buffer_len(& stderr_buffer);
#line 354
    tmp___4 = buffer_ptr(& stderr_buffer);
#line 354
    packet_put_string((char const   *)tmp___4, tmp___3);
#line 356
    packet_send();
#line 358
    tmp___5 = buffer_len(& stderr_buffer);
#line 358
    stderr_bytes = (long )((unsigned long )stderr_bytes + (unsigned long )tmp___5);
  }
#line 361
  packet_write_wait();
#line 362
  return;
}
}
#line 364 "serverloop.c"
void process_buffered_input_packets(void) 
{ 

  {
#line 367
  dispatch_run(1, (int *)((void *)0));
#line 368
  return;
}
}
#line 377 "serverloop.c"
void server_loop(pid_t pid , int fdin_arg , int fdout_arg , int fderr_arg ) 
{ fd_set readset ;
  fd_set writeset ;
  int wait_status ;
  pid_t wait_pid ;
  int waiting_termination ;
  unsigned int max_time_milliseconds ;
  unsigned int previous_stdout_buffer_bytes ;
  unsigned int stdout_buffer_bytes ;
  int type ;
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *s ;
  char *cp ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  union __anonunion_79 __constr_expr_0 ;
  union __anonunion_80 __constr_expr_1 ;
  int plen ;
  union __anonunion_81 __constr_expr_2 ;
  union __anonunion_82 __constr_expr_3 ;
  union __anonunion_83 __constr_expr_4 ;

  {
#line 383
  waiting_termination = 0;
#line 389
  debug("Entering interactive session.");
#line 392
  child_pid = pid;
#line 393
  child_terminated = (int volatile   )0;
#line 394
  child_has_selected = (int volatile   )0;
#line 395
  signal(17, & sigchld_handler);
#line 398
  fdin = fdin_arg;
#line 399
  fdout = fdout_arg;
#line 400
  fderr = fderr_arg;
#line 403
  set_nonblock(fdin);
#line 404
  set_nonblock(fdout);
#line 406
  if (fderr != -1) {
#line 407
    set_nonblock(fderr);
  }
#line 409
  connection_in___0 = packet_get_connection_in();
#line 410
  connection_out___0 = packet_get_connection_out();
#line 412
  previous_stdout_buffer_bytes = 0U;
#line 415
  tmp = packet_is_interactive();
#line 415
  if (tmp) {
#line 416
    buffer_high = 4096U;
  } else {
#line 418
    buffer_high = 65536U;
  }
#line 421
  max_fd = fdin;
#line 422
  if (fdout > max_fd) {
#line 423
    max_fd = fdout;
  }
#line 424
  if (fderr != -1) {
#line 424
    if (fderr > max_fd) {
#line 425
      max_fd = fderr;
    }
  }
#line 426
  if (connection_in___0 > max_fd) {
#line 427
    max_fd = connection_in___0;
  }
#line 428
  if (connection_out___0 > max_fd) {
#line 429
    max_fd = connection_out___0;
  }
#line 432
  buffer_init(& stdin_buffer);
#line 433
  buffer_init(& stdout_buffer);
#line 434
  buffer_init(& stderr_buffer);
#line 442
  if (fderr == -1) {
#line 443
    fderr_eof = 1;
  }
#line 445
  server_init_dispatch();
#line 448
  while (1) {
#line 451
    process_buffered_input_packets();
#line 457
    if (stdin_eof) {
#line 457
      if (fdin != -1) {
#line 457
        tmp___0 = buffer_len(& stdin_buffer);
#line 457
        if (tmp___0 == 0U) {
#line 461
          if (fdin != fdout) {
#line 462
            close(fdin);
          } else {
#line 464
            shutdown(fdin, 1);
          }
#line 466
          fdin = -1;
        }
      }
    }
#line 469
    make_packets_from_stderr_data();
#line 478
    max_time_milliseconds = 0U;
#line 479
    stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 480
    if (stdout_buffer_bytes != 0U) {
#line 480
      if (stdout_buffer_bytes < 256U) {
#line 480
        if (stdout_buffer_bytes != previous_stdout_buffer_bytes) {
#line 483
          max_time_milliseconds = 10U;
        } else {
#line 486
          make_packets_from_stdout_data();
        }
      } else {
#line 486
        make_packets_from_stdout_data();
      }
    } else {
#line 486
      make_packets_from_stdout_data();
    }
#line 488
    previous_stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 491
    tmp___1 = packet_not_very_much_data_to_write();
#line 491
    if (tmp___1) {
#line 492
      channel_output_poll();
    }
#line 499
    if (fdout_eof) {
#line 499
      if (fderr_eof) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 499
      if (child_terminated) {
#line 499
        if (child_has_selected) {
          _L: /* CIL Label */ 
#line 499
          tmp___5 = packet_have_data_to_write();
#line 499
          if (! tmp___5) {
#line 499
            tmp___6 = buffer_len(& stdout_buffer);
#line 499
            if (tmp___6 == 0U) {
#line 499
              tmp___7 = buffer_len(& stderr_buffer);
#line 499
              if (tmp___7 == 0U) {
#line 504
                tmp___2 = channel_still_open();
#line 504
                if (! tmp___2) {
#line 505
                  break;
                }
#line 506
                if (! waiting_termination) {
#line 507
                  s = "Waiting for forwarded connections to terminate...\r\n";
#line 509
                  waiting_termination = 1;
#line 510
                  tmp___3 = strlen(s);
#line 510
                  buffer_append(& stderr_buffer, s, tmp___3);
#line 513
                  cp = channel_open_message();
#line 514
                  tmp___4 = strlen((char const   *)cp);
#line 514
                  buffer_append(& stderr_buffer, (char const   *)cp, tmp___4);
#line 515
                  xfree((void *)cp);
                }
              }
            }
          }
        }
      }
    }
#line 519
    wait_until_can_do_something(& readset, & writeset, max_time_milliseconds);
#line 523
    channel_after_select(& readset, & writeset);
#line 526
    process_input(& readset);
#line 529
    process_output(& writeset);
  }
#line 535
  drain_output();
#line 537
  debug("End of interactive session; stdin %ld, stdout (read %ld, sent %ld), stderr %ld bytes.",
        stdin_bytes, fdout_bytes, stdout_bytes, stderr_bytes);
#line 541
  buffer_free(& stdin_buffer);
#line 542
  buffer_free(& stdout_buffer);
#line 543
  buffer_free(& stderr_buffer);
#line 546
  if (fdout != -1) {
#line 547
    close(fdout);
  }
#line 548
  fdout = -1;
#line 549
  fdout_eof = 1;
#line 550
  if (fderr != -1) {
#line 551
    close(fderr);
  }
#line 552
  fderr = -1;
#line 553
  fderr_eof = 1;
#line 554
  if (fdin != -1) {
#line 555
    close(fdin);
  }
#line 556
  fdin = -1;
#line 559
  channel_stop_listening();
#line 562
  wait_pid = wait((union wait *)(& wait_status));
#line 563
  if (wait_pid < 0) {
#line 569
    if (child_terminated) {
#line 570
      wait_status = (int )child_wait_status;
    } else {
#line 572
      tmp___8 = __errno_location();
#line 572
      tmp___9 = strerror(*tmp___8);
#line 572
      packet_disconnect("wait: %.100s", tmp___9);
    }
  } else {
#line 575
    if (wait_pid != pid) {
#line 576
      error("Strange, wait returned pid %d, expected %d", wait_pid, pid);
    }
  }
#line 581
  signal(17, (void (*)(int  ))0);
#line 584
  __constr_expr_2.__in = wait_status;
#line 584
  if ((__constr_expr_2.__i & 127) == 0) {
#line 586
    __constr_expr_0.__in = wait_status;
#line 586
    debug("Command exited with status %d.", (__constr_expr_0.__i & 65280) >> 8);
#line 587
    packet_start(20);
#line 588
    __constr_expr_1.__in = wait_status;
#line 588
    packet_put_int((unsigned int )((__constr_expr_1.__i & 65280) >> 8));
#line 589
    packet_send();
#line 590
    packet_write_wait();
#line 599
    while (1) {
#line 601
      type = packet_read(& plen);
#line 599
      if (! (type != 33)) {
#line 599
        break;
      }
    }
#line 605
    debug("Received exit confirmation.");
#line 606
    return;
  }
#line 609
  __constr_expr_4.__in = wait_status;
#line 609
  if ((int )((signed char )((__constr_expr_4.__i & 127) + 1)) >> 1 > 0) {
#line 610
    __constr_expr_3.__in = wait_status;
#line 610
    packet_disconnect("Command terminated on signal %d.", __constr_expr_3.__i & 127);
  }
#line 614
  packet_disconnect("wait returned status %04x.", wait_status);
#line 616
  return;
}
}
#line 618 "serverloop.c"
void server_loop2(void) 
{ fd_set readset ;
  fd_set writeset ;
  int had_channel ;
  int status ;
  pid_t pid ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 622
  had_channel = 0;
#line 626
  debug("Entering interactive session for SSH2.");
#line 628
  signal(17, & sigchld_handler2);
#line 629
  child_terminated = (int volatile   )0;
#line 630
  connection_in___0 = packet_get_connection_in();
#line 631
  connection_out___0 = packet_get_connection_out();
#line 632
  max_fd = connection_in___0;
#line 633
  if (connection_out___0 > max_fd) {
#line 634
    max_fd = connection_out___0;
  }
#line 635
  server_init_dispatch();
#line 637
  while (1) {
#line 638
    process_buffered_input_packets();
#line 639
    if (! had_channel) {
#line 639
      tmp = channel_still_open();
#line 639
      if (tmp) {
#line 640
        had_channel = 1;
      }
    }
#line 641
    if (had_channel) {
#line 641
      tmp___0 = channel_still_open();
#line 641
      if (! tmp___0) {
#line 642
        debug("!channel_still_open.");
#line 643
        break;
      }
    }
#line 645
    tmp___1 = packet_not_very_much_data_to_write();
#line 645
    if (tmp___1) {
#line 646
      channel_output_poll();
    }
#line 647
    wait_until_can_do_something(& readset, & writeset, 0U);
#line 648
    if (child_terminated) {
#line 649
      while (1) {
#line 649
        pid = waitpid(-1, & status, 1);
#line 649
        if (! (pid > 0)) {
#line 649
          break;
        }
#line 650
        session_close_by_pid(pid, status);
      }
#line 651
      child_terminated = (int volatile   )0;
#line 652
      signal(17, & sigchld_handler2);
    }
#line 654
    channel_after_select(& readset, & writeset);
#line 655
    process_input(& readset);
#line 656
    process_output(& writeset);
  }
#line 658
  signal(17, (void (*)(int  ))0);
#line 659
  while (1) {
#line 659
    pid = waitpid(-1, & status, 1);
#line 659
    if (! (pid > 0)) {
#line 659
      break;
    }
#line 660
    session_close_by_pid(pid, status);
  }
#line 661
  channel_stop_listening();
#line 662
  return;
}
}
#line 664 "serverloop.c"
void server_input_stdin_data(int type , int plen ) 
{ char *data ;
  unsigned int data_len ;
  int _p ;
  int _e ;

  {
#line 672
  if (fdin == -1) {
#line 673
    return;
  }
#line 674
  data = packet_get_string(& data_len);
#line 675
  while (1) {
#line 675
    _p = plen;
#line 675
    _e = (int )(4U + data_len);
#line 675
    if (_p != _e) {
#line 675
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "serverloop.c", 675);
#line 675
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 675
    break;
  }
#line 676
  buffer_append(& stdin_buffer, (char const   *)data, data_len);
#line 677
  memset((void *)data, 0, data_len);
#line 678
  xfree((void *)data);
#line 679
  return;
}
}
#line 681 "serverloop.c"
void server_input_eof(int type , int plen ) 
{ int _p ;
  int _e ;

  {
#line 689
  debug("EOF received for stdin.");
#line 690
  while (1) {
#line 690
    _p = plen;
#line 690
    _e = 0;
#line 690
    if (_p != _e) {
#line 690
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "serverloop.c", 690);
#line 690
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 690
    break;
  }
#line 691
  stdin_eof = 1;
#line 692
  return;
}
}
#line 694 "serverloop.c"
void server_input_window_size(int type , int plen ) 
{ int row ;
  unsigned int tmp ;
  int col ;
  unsigned int tmp___0 ;
  int xpixel ;
  unsigned int tmp___1 ;
  int ypixel ;
  unsigned int tmp___2 ;
  int _p ;
  int _e ;

  {
#line 697
  tmp = packet_get_int();
#line 697
  row = (int )tmp;
#line 698
  tmp___0 = packet_get_int();
#line 698
  col = (int )tmp___0;
#line 699
  tmp___1 = packet_get_int();
#line 699
  xpixel = (int )tmp___1;
#line 700
  tmp___2 = packet_get_int();
#line 700
  ypixel = (int )tmp___2;
#line 702
  debug("Window change received.");
#line 703
  while (1) {
#line 703
    _p = plen;
#line 703
    _e = 16;
#line 703
    if (_p != _e) {
#line 703
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "serverloop.c", 703);
#line 703
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 703
    break;
  }
#line 704
  if (fdin != -1) {
#line 705
    pty_change_window_size(fdin, row, col, xpixel, ypixel);
  }
#line 706
  return;
}
}
#line 708 "serverloop.c"
int input_direct_tcpip(void) 
{ int sock ;
  char *target ;
  char *originator ;
  int target_port ;
  int originator_port ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int _len ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 715
  target = packet_get_string((unsigned int *)((void *)0));
#line 716
  tmp = packet_get_int();
#line 716
  target_port = (int )tmp;
#line 717
  originator = packet_get_string((unsigned int *)((void *)0));
#line 718
  tmp___0 = packet_get_int();
#line 718
  originator_port = (int )tmp___0;
#line 719
  while (1) {
#line 719
    tmp___1 = packet_remaining();
#line 719
    _len = tmp___1;
#line 719
    if (_len > 0) {
#line 719
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
          719);
#line 719
      packet_disconnect("Packet integrity error.");
    }
#line 719
    break;
  }
#line 721
  debug("open direct-tcpip: from %s port %d to %s port %d", originator, originator_port,
        target, target_port);
#line 725
  if (no_port_forwarding_flag) {
#line 726
    xfree((void *)target);
#line 727
    xfree((void *)originator);
#line 728
    return (-1);
  }
#line 730
  sock = channel_connect_to((char const   *)target, (unsigned short )target_port);
#line 731
  xfree((void *)target);
#line 732
  xfree((void *)originator);
#line 733
  if (sock < 0) {
#line 734
    return (-1);
  }
#line 735
  tmp___2 = xstrdup("direct-tcpip");
#line 735
  tmp___3 = channel_new((char *)"direct-tcpip", 4, sock, sock, -1, 4096, 32768, 0,
                        tmp___2);
#line 735
  return (tmp___3);
}
}
#line 739 "serverloop.c"
void server_input_channel_open(int type , int plen ) 
{ Channel *c ;
  char *ctype ;
  int id ;
  unsigned int len ;
  int rchan ;
  int rmaxpack ;
  int rwindow ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  int _len ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___10 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;

  {
#line 742
  c = (Channel *)((void *)0);
#line 750
  ctype = packet_get_string(& len);
#line 751
  tmp = packet_get_int();
#line 751
  rchan = (int )tmp;
#line 752
  tmp___0 = packet_get_int();
#line 752
  rwindow = (int )tmp___0;
#line 753
  tmp___1 = packet_get_int();
#line 753
  rmaxpack = (int )tmp___1;
#line 755
  debug("channel_input_open: ctype %s rchan %d win %d max %d", ctype, rchan, rwindow,
        rmaxpack);
#line 758
  if (0) {
#line 758
    __s1_len___0 = strlen((char const   *)ctype);
#line 758
    __s2_len___0 = strlen("session");
#line 758
    if (! ((unsigned int )((void const   *)(ctype + 1)) - (unsigned int )((void const   *)ctype) == 1U)) {
      goto _L___2;
    } else {
#line 758
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 758
        if (! ((unsigned int )((void const   *)("session" + 1)) - (unsigned int )((void const   *)"session") == 1U)) {
#line 758
          tmp___24 = 1;
        } else {
#line 758
          if (__s2_len___0 >= 4U) {
#line 758
            tmp___24 = 1;
          } else {
#line 758
            tmp___24 = 0;
          }
        }
      } else {
#line 758
        tmp___24 = 0;
      }
    }
#line 758
    if (tmp___24) {
#line 758
      tmp___20 = __builtin_strcmp((char const   *)ctype, "session");
    } else {
#line 758
      tmp___23 = __builtin_strcmp((char const   *)ctype, "session");
#line 758
      tmp___20 = tmp___23;
    }
  } else {
#line 758
    tmp___23 = __builtin_strcmp((char const   *)ctype, "session");
#line 758
    tmp___20 = tmp___23;
  }
#line 758
  if (tmp___20 == 0) {
#line 759
    debug("open session");
#line 760
    while (1) {
#line 760
      tmp___2 = packet_remaining();
#line 760
      _len = tmp___2;
#line 760
      if (_len > 0) {
#line 760
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
            760);
#line 760
        packet_disconnect("Packet integrity error.");
      }
#line 760
      break;
    }
#line 768
    tmp___3 = xstrdup("server-session");
#line 768
    id = channel_new(ctype, 10, -1, -1, -1, 0, 32768, 0, tmp___3);
#line 770
    tmp___4 = session_open(id);
#line 770
    if (tmp___4 == 1) {
#line 771
      channel_register_callback(id, 98, & session_input_channel_req, (void *)0);
#line 773
      channel_register_cleanup(id, & session_close_by_channel);
#line 774
      c = channel_lookup(id);
    } else {
#line 776
      debug("session open failed, free channel %d", id);
#line 777
      channel_free(id);
    }
  } else {
#line 779
    if (0) {
#line 779
      __s1_len = strlen((char const   *)ctype);
#line 779
      __s2_len = strlen("direct-tcpip");
#line 779
      if (! ((unsigned int )((void const   *)(ctype + 1)) - (unsigned int )((void const   *)ctype) == 1U)) {
        goto _L___0;
      } else {
#line 779
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 779
          if (! ((unsigned int )((void const   *)("direct-tcpip" + 1)) - (unsigned int )((void const   *)"direct-tcpip") == 1U)) {
#line 779
            tmp___14 = 1;
          } else {
#line 779
            if (__s2_len >= 4U) {
#line 779
              tmp___14 = 1;
            } else {
#line 779
              tmp___14 = 0;
            }
          }
        } else {
#line 779
          tmp___14 = 0;
        }
      }
#line 779
      if (tmp___14) {
#line 779
        tmp___10 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
      } else {
#line 779
        tmp___13 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
#line 779
        tmp___10 = tmp___13;
      }
    } else {
#line 779
      tmp___13 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
#line 779
      tmp___10 = tmp___13;
    }
#line 779
    if (tmp___10 == 0) {
#line 780
      id = input_direct_tcpip();
#line 781
      if (id >= 0) {
#line 782
        c = channel_lookup(id);
      }
    }
  }
#line 784
  if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 785
    debug("confirm %s", ctype);
#line 786
    c->remote_id = rchan;
#line 787
    c->remote_window = rwindow;
#line 788
    c->remote_maxpacket = rmaxpack;
#line 790
    packet_start(91);
#line 791
    packet_put_int((unsigned int )c->remote_id);
#line 792
    packet_put_int((unsigned int )c->self);
#line 793
    packet_put_int((unsigned int )c->local_window);
#line 794
    packet_put_int((unsigned int )c->local_maxpacket);
#line 795
    packet_send();
  } else {
#line 797
    debug("failure %s", ctype);
#line 798
    packet_start(92);
#line 799
    packet_put_int((unsigned int )rchan);
#line 800
    packet_put_int(1U);
#line 801
    packet_put_cstring("bla bla");
#line 802
    packet_put_cstring("");
#line 803
    packet_send();
  }
#line 805
  xfree((void *)ctype);
#line 806
  return;
}
}
#line 808 "serverloop.c"
void server_init_dispatch_20(void) 
{ 

  {
#line 811
  debug("server_init_dispatch_20");
#line 812
  dispatch_init(& dispatch_protocol_error);
#line 813
  dispatch_set(97, & channel_input_oclose);
#line 814
  dispatch_set(94, & channel_input_data);
#line 815
  dispatch_set(96, & channel_input_ieof);
#line 816
  dispatch_set(95, & channel_input_extended_data);
#line 817
  dispatch_set(90, & server_input_channel_open);
#line 818
  dispatch_set(91, & channel_input_open_confirmation);
#line 819
  dispatch_set(92, & channel_input_open_failure);
#line 820
  dispatch_set(98, & channel_input_channel_request);
#line 821
  dispatch_set(93, & channel_input_window_adjust);
#line 822
  return;
}
}
#line 823 "serverloop.c"
void server_init_dispatch_13(void) 
{ 

  {
#line 826
  debug("server_init_dispatch_13");
#line 827
  dispatch_init((dispatch_fn *)((void *)0));
#line 828
  dispatch_set(19, & server_input_eof);
#line 829
  dispatch_set(16, & server_input_stdin_data);
#line 830
  dispatch_set(11, & server_input_window_size);
#line 831
  dispatch_set(24, & channel_input_close);
#line 832
  dispatch_set(25, & channel_input_close_confirmation);
#line 833
  dispatch_set(23, & channel_input_data);
#line 834
  dispatch_set(21, & channel_input_open_confirmation);
#line 835
  dispatch_set(22, & channel_input_open_failure);
#line 836
  dispatch_set(29, & channel_input_port_open);
#line 837
  return;
}
}
#line 838 "serverloop.c"
void server_init_dispatch_15(void) 
{ 

  {
#line 841
  server_init_dispatch_13();
#line 842
  debug("server_init_dispatch_15");
#line 843
  dispatch_set(24, & channel_input_ieof);
#line 844
  dispatch_set(25, & channel_input_oclose);
#line 845
  return;
}
}
#line 846 "serverloop.c"
void server_init_dispatch(void) 
{ 

  {
#line 849
  if (compat20) {
#line 850
    server_init_dispatch_20();
  } else {
#line 851
    if (compat13) {
#line 852
      server_init_dispatch_13();
    } else {
#line 854
      server_init_dispatch_15();
    }
  }
#line 855
  return;
}
}
#line 1 "md5crypt.o"
#line 1 "session.o"
#line 106 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socketpair(int __domain , int __type , int __protocol ,
                                                    int *__fds ) ;
#line 84 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strcpy(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 194
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 493 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 504
extern  __attribute__((__nothrow__)) int execve(char const   *__path , char * const  *__argv ,
                                                char * const  *__envp )  __attribute__((__nonnull__(1))) ;
#line 526
extern  __attribute__((__nothrow__)) int execl(char const   *__path , char const   *__arg 
                                               , ...)  __attribute__((__nonnull__(1))) ;
#line 684
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 142 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 774
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 780
extern int pclose(FILE *__stream ) ;
#line 79 "/usr/include/pwd.h"
extern void endpwent(void) ;
#line 69 "/usr/include/grp.h"
extern void endgrent(void) ;
#line 199
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 257 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 86 "session.c"
Session *session_new(void) ;
#line 87
void session_set_fds(Session *s , int fdin___0 , int fdout___0 , int fderr___0 ) ;
#line 88
void session_pty_cleanup(Session *s ) ;
#line 89
void session_proctitle(Session *s ) ;
#line 90
void do_exec_pty(Session *s , char const   *command , struct passwd *pw ) ;
#line 91
void do_exec_no_pty(Session *s , char const   *command , struct passwd *pw ) ;
#line 92
void do_login(Session *s ) ;
#line 94
void do_child(char const   *command , struct passwd *pw , char const   *term , char const   *display ,
              char const   *auth_proto , char const   *auth_data , char const   *ttyname___0 ) ;
#line 114 "session.c"
static char *xauthfile  ;
#line 118 "session.c"
Session sessions[10]  ;
#line 131 "session.c"
void xauthfile_cleanup_proc(void *ignore ) 
{ char *p ;

  {
#line 134
  debug("xauthfile_cleanup_proc called");
#line 136
  if ((unsigned int )xauthfile != (unsigned int )((void *)0)) {
#line 138
    unlink((char const   *)xauthfile);
#line 139
    p = strrchr((char const   *)xauthfile, '/');
#line 140
    if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 141
      *p = (char )'\000';
#line 142
      rmdir((char const   *)xauthfile);
    }
#line 144
    xfree((void *)xauthfile);
#line 145
    xauthfile = (char *)((void *)0);
  }
#line 147
  return;
}
}
#line 153 "session.c"
void pty_cleanup_proc(void *session ) 
{ Session *s ;

  {
#line 156
  s = (Session *)session;
#line 157
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 158
    fatal("pty_cleanup_proc: no session");
  }
#line 159
  debug("pty_cleanup_proc: %s", s->tty);
#line 161
  if (s->pid != 0) {
#line 163
    record_logout(s->pid, (char const   *)(s->tty));
  }
#line 167
  pty_release((char const   *)(s->tty));
#line 168
  return;
}
}
#line 176 "session.c"
void do_authenticated(struct passwd *pw ) 
{ Session *s ;
  int type ;
  int compression_level ;
  int enable_compression_after_reply ;
  int have_pty ;
  char *command ;
  int n_bytes ;
  int plen ;
  unsigned int proto_len ;
  unsigned int data_len ;
  unsigned int dlen ;
  int success ;
  int _p ;
  int _e ;
  unsigned int tmp ;
  int tmp___0 ;
  int _p___0 ;
  int _e___0 ;
  size_t tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  int _p___1 ;
  int _e___1 ;
  int _p___2 ;
  int _e___2 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  void *tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  unsigned int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int _p___3 ;
  int _e___3 ;
  int _p___4 ;
  int _e___4 ;
  int tmp___25 ;

  {
#line 181
  compression_level = 0;
#line 181
  enable_compression_after_reply = 0;
#line 182
  have_pty = 0;
#line 192
  alarm(0U);
#line 193
  if (startup_pipe != -1) {
#line 194
    close(startup_pipe);
#line 195
    startup_pipe = -1;
  }
#line 205
  if (! no_port_forwarding_flag) {
#line 206
    channel_permit_all_opens();
  }
#line 208
  s = session_new();
#line 209
  s->pw = pw;
#line 222
  while (1) {
#line 223
    success = 0;
#line 226
    type = packet_read(& plen);
#line 229
    switch (type) {
    case 37: 
#line 231
    while (1) {
#line 231
      _p = plen;
#line 231
      _e = 4;
#line 231
      if (_p != _e) {
#line 231
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "session.c", 231);
#line 231
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 231
      break;
    }
#line 232
    tmp = packet_get_int();
#line 232
    compression_level = (int )tmp;
#line 233
    if (compression_level < 1) {
#line 234
      packet_send_debug("Received illegal compression level %d.", compression_level);
#line 236
      break;
    } else {
#line 233
      if (compression_level > 9) {
#line 234
        packet_send_debug("Received illegal compression level %d.", compression_level);
#line 236
        break;
      }
    }
#line 239
    enable_compression_after_reply = 1;
#line 240
    success = 1;
#line 241
    break;
    case 10: 
#line 244
    if (no_pty_flag) {
#line 245
      debug("Allocating a pty not permitted for this authentication.");
#line 246
      break;
    }
#line 248
    if (have_pty) {
#line 249
      packet_disconnect("Protocol error: you already have a pty.");
    }
#line 251
    debug("Allocating pty.");
#line 254
    tmp___0 = pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, (int )sizeof(s->tty));
#line 254
    if (! tmp___0) {
#line 256
      error("Failed to allocate pty.");
#line 257
      break;
    }
#line 259
    fatal_add_cleanup(& pty_cleanup_proc, (void *)s);
#line 260
    pty_setowner(pw, (char const   *)(s->tty));
#line 263
    s->term = packet_get_string(& dlen);
#line 264
    while (1) {
#line 264
      _p___0 = (int )dlen;
#line 264
      tmp___1 = strlen((char const   *)s->term);
#line 264
      _e___0 = (int )tmp___1;
#line 264
      if (_p___0 != _e___0) {
#line 264
        log("Packet integrity error (%d != %d) at %s:%d", _p___0, _e___0, "session.c",
            264);
#line 264
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 264
      break;
    }
#line 267
    n_bytes = (int )((unsigned int )plen - ((4U + dlen) + 16U));
#line 269
    if (0) {
#line 269
      __s1_len = strlen((char const   *)s->term);
#line 269
      __s2_len = strlen("");
#line 269
      if (! ((unsigned int )((void const   *)(s->term + 1)) - (unsigned int )((void const   *)s->term) == 1U)) {
        goto _L___0;
      } else {
#line 269
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 269
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 269
            tmp___11 = 1;
          } else {
#line 269
            if (__s2_len >= 4U) {
#line 269
              tmp___11 = 1;
            } else {
#line 269
              tmp___11 = 0;
            }
          }
        } else {
#line 269
          tmp___11 = 0;
        }
      }
#line 269
      if (tmp___11) {
#line 269
        tmp___7 = __builtin_strcmp((char const   *)s->term, "");
      } else {
#line 269
        tmp___10 = __builtin_strcmp((char const   *)s->term, "");
#line 269
        tmp___7 = tmp___10;
      }
    } else {
#line 269
      tmp___10 = __builtin_strcmp((char const   *)s->term, "");
#line 269
      tmp___7 = tmp___10;
    }
#line 269
    if (tmp___7 == 0) {
#line 270
      xfree((void *)s->term);
#line 271
      s->term = (char *)((void *)0);
    }
#line 274
    tmp___12 = packet_get_int();
#line 274
    s->row = (int )tmp___12;
#line 275
    tmp___13 = packet_get_int();
#line 275
    s->col = (int )tmp___13;
#line 276
    tmp___14 = packet_get_int();
#line 276
    s->xpixel = (int )tmp___14;
#line 277
    tmp___15 = packet_get_int();
#line 277
    s->ypixel = (int )tmp___15;
#line 278
    pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);
#line 281
    tty_parse_modes(s->ttyfd, & n_bytes);
#line 282
    while (1) {
#line 282
      _p___1 = plen;
#line 282
      _e___1 = (int )(((4U + dlen) + 16U) + (unsigned int )n_bytes);
#line 282
      if (_p___1 != _e___1) {
#line 282
        log("Packet integrity error (%d != %d) at %s:%d", _p___1, _e___1, "session.c",
            282);
#line 282
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 282
      break;
    }
#line 284
    session_proctitle(s);
#line 287
    success = 1;
#line 288
    have_pty = 1;
#line 289
    break;
    case 34: 
#line 292
    if (! options.x11_forwarding) {
#line 293
      packet_send_debug("X11 forwarding disabled in server configuration file.");
#line 294
      break;
    }
#line 296
    if (! options.xauth_location) {
#line 297
      packet_send_debug("No xauth program; cannot forward with spoofing.");
#line 298
      break;
    }
#line 300
    if (no_x11_forwarding_flag) {
#line 301
      packet_send_debug("X11 forwarding not permitted for this authentication.");
#line 302
      break;
    }
#line 304
    debug("Received request for X11 forwarding with auth spoofing.");
#line 305
    if ((unsigned int )s->display != (unsigned int )((void *)0)) {
#line 306
      packet_disconnect("Protocol error: X11 display already set.");
    }
#line 308
    s->auth_proto = packet_get_string(& proto_len);
#line 309
    s->auth_data = packet_get_string(& data_len);
#line 310
    while (1) {
#line 310
      _p___2 = plen;
#line 310
      _e___2 = (int )((((4U + proto_len) + 4U) + data_len) + 4U);
#line 310
      if (_p___2 != _e___2) {
#line 310
        log("Packet integrity error (%d != %d) at %s:%d", _p___2, _e___2, "session.c",
            310);
#line 310
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 310
      break;
    }
#line 312
    tmp___17 = packet_get_protocol_flags();
#line 312
    if (tmp___17 & 1U) {
#line 313
      tmp___16 = packet_get_int();
#line 313
      s->screen = (int )tmp___16;
    } else {
#line 315
      s->screen = 0;
    }
#line 316
    s->display = x11_create_display_inet(s->screen, options.x11_display_offset);
#line 318
    if ((unsigned int )s->display == (unsigned int )((void *)0)) {
#line 319
      break;
    }
#line 322
    tmp___18 = xmalloc(4096U);
#line 322
    xauthfile = (char *)tmp___18;
#line 323
    strlcpy(xauthfile, "/tmp/ssh-XXXXXXXX", 4096U);
#line 324
    temporarily_use_uid(pw->pw_uid);
#line 325
    tmp___21 = mkdtemp(xauthfile);
#line 325
    if ((unsigned int )tmp___21 == (unsigned int )((void *)0)) {
#line 326
      restore_uid();
#line 327
      tmp___19 = __errno_location();
#line 327
      tmp___20 = strerror(*tmp___19);
#line 327
      error("private X11 dir: mkdtemp %s failed: %s", xauthfile, tmp___20);
#line 329
      xfree((void *)xauthfile);
#line 330
      xauthfile = (char *)((void *)0);
#line 332
      break;
    }
#line 334
    strlcat(xauthfile, "/cookies", 4096U);
#line 335
    open((char const   *)xauthfile, 194, 384);
#line 336
    restore_uid();
#line 337
    fatal_add_cleanup(& xauthfile_cleanup_proc, (void *)0);
#line 338
    success = 1;
#line 339
    break;
    case 30: 
#line 342
    if (no_agent_forwarding_flag) {
#line 343
      debug("Authentication agent forwarding not permitted for this authentication.");
#line 344
      break;
    } else {
#line 342
      if (compat13) {
#line 343
        debug("Authentication agent forwarding not permitted for this authentication.");
#line 344
        break;
      }
    }
#line 346
    debug("Received authentication agent forwarding request.");
#line 347
    success = auth_input_request_forwarding(pw);
#line 348
    break;
    case 28: 
#line 351
    if (no_port_forwarding_flag) {
#line 352
      debug("Port forwarding not permitted for this authentication.");
#line 353
      break;
    }
#line 355
    debug("Received TCP/IP port forwarding request.");
#line 356
    channel_input_port_forward_request(pw->pw_uid == 0U, options.gateway_ports);
#line 357
    success = 1;
#line 358
    break;
    case 38: 
#line 361
    tmp___22 = packet_get_int();
#line 361
    tmp___23 = packet_set_maxsize((int )tmp___22);
#line 361
    if (tmp___23 > 0) {
#line 362
      success = 1;
    }
#line 363
    break;
    case 12: 
    case 13: 
#line 368
    if (have_pty) {
#line 368
      tmp___24 = 1;
    } else {
#line 368
      if ((unsigned int )s->display != (unsigned int )((void *)0)) {
#line 368
        tmp___24 = 1;
      } else {
#line 368
        tmp___24 = 0;
      }
    }
#line 368
    packet_set_interactive(tmp___24, options.keepalives);
#line 371
    if (type == 13) {
#line 372
      command = packet_get_string(& dlen);
#line 373
      debug("Exec command \'%.500s\'", command);
#line 374
      while (1) {
#line 374
        _p___3 = plen;
#line 374
        _e___3 = (int )(4U + dlen);
#line 374
        if (_p___3 != _e___3) {
#line 374
          log("Packet integrity error (%d != %d) at %s:%d", _p___3, _e___3, "session.c",
              374);
#line 374
          packet_disconnect("Packet integrity error. (%d)", type);
        }
#line 374
        break;
      }
    } else {
#line 376
      command = (char *)((void *)0);
#line 377
      while (1) {
#line 377
        _p___4 = plen;
#line 377
        _e___4 = 0;
#line 377
        if (_p___4 != _e___4) {
#line 377
          log("Packet integrity error (%d != %d) at %s:%d", _p___4, _e___4, "session.c",
              377);
#line 377
          packet_disconnect("Packet integrity error. (%d)", type);
        }
#line 377
        break;
      }
    }
#line 379
    if ((unsigned int )forced_command != (unsigned int )((void *)0)) {
#line 380
      command = forced_command;
#line 381
      debug("Forced command \'%.500s\'", forced_command);
    }
#line 383
    if (have_pty) {
#line 384
      do_exec_pty(s, (char const   *)command, pw);
    } else {
#line 386
      do_exec_no_pty(s, (char const   *)command, pw);
    }
#line 388
    if ((unsigned int )command != (unsigned int )((void *)0)) {
#line 389
      xfree((void *)command);
    }
#line 391
    if (xauthfile) {
#line 392
      xauthfile_cleanup_proc((void *)0);
    }
#line 393
    return;
    default: 
#line 400
    log("Unknown packet type received after authentication: %d", type);
    }
#line 402
    if (success) {
#line 402
      tmp___25 = 14;
    } else {
#line 402
      tmp___25 = 15;
    }
#line 402
    packet_start(tmp___25);
#line 403
    packet_send();
#line 404
    packet_write_wait();
#line 407
    if (enable_compression_after_reply) {
#line 408
      enable_compression_after_reply = 0;
#line 409
      packet_start_compression(compression_level);
    }
  }
}
}
#line 419 "session.c"
void do_exec_no_pty(Session *s , char const   *command , struct passwd *pw ) 
{ int pid ;
  int inout[2] ;
  int err[2] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  __pid_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
#line 433
  tmp___1 = socketpair(1, 1, 0, (int *)(inout));
#line 433
  if (tmp___1 < 0) {
#line 435
    tmp = __errno_location();
#line 435
    tmp___0 = strerror(*tmp);
#line 435
    packet_disconnect("Could not create socket pairs: %.100s", tmp___0);
  } else {
#line 433
    tmp___2 = socketpair(1, 1, 0, (int *)(err));
#line 433
    if (tmp___2 < 0) {
#line 435
      tmp = __errno_location();
#line 435
      tmp___0 = strerror(*tmp);
#line 435
      packet_disconnect("Could not create socket pairs: %.100s", tmp___0);
    }
  }
#line 438
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 439
    fatal("do_exec_no_pty: no session");
  }
#line 441
  session_proctitle(s);
#line 444
  do_pam_setcred();
#line 448
  pid = fork();
#line 448
  if (pid == 0) {
#line 450
    log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 456
    tmp___5 = setsid();
#line 456
    if (tmp___5 < 0) {
#line 457
      tmp___3 = __errno_location();
#line 457
      tmp___4 = strerror(*tmp___3);
#line 457
      error("setsid failed: %.100s", tmp___4);
    }
#line 486
    close(inout[1]);
#line 487
    close(err[1]);
#line 488
    tmp___6 = dup2(inout[0], 0);
#line 488
    if (tmp___6 < 0) {
#line 489
      perror("dup2 stdin");
    }
#line 490
    tmp___7 = dup2(inout[0], 1);
#line 490
    if (tmp___7 < 0) {
#line 491
      perror("dup2 stdout");
    }
#line 492
    tmp___8 = dup2(err[0], 2);
#line 492
    if (tmp___8 < 0) {
#line 493
      perror("dup2 stderr");
    }
#line 497
    do_child(command, pw, (char const   *)((void *)0), (char const   *)s->display,
             (char const   *)s->auth_proto, (char const   *)s->auth_data, (char const   *)((void *)0));
  }
#line 500
  if (pid < 0) {
#line 501
    tmp___9 = __errno_location();
#line 501
    tmp___10 = strerror(*tmp___9);
#line 501
    packet_disconnect("fork failed: %.100s", tmp___10);
  }
#line 502
  s->pid = pid;
#line 518
  close(inout[0]);
#line 519
  close(err[0]);
#line 525
  if (compat20) {
#line 526
    if (s->extended) {
#line 526
      tmp___11 = err[1];
    } else {
#line 526
      tmp___11 = -1;
    }
#line 526
    session_set_fds(s, inout[1], inout[1], tmp___11);
  } else {
#line 528
    server_loop(pid, inout[1], inout[1], err[1]);
  }
#line 532
  return;
}
}
#line 540 "session.c"
void do_exec_pty(Session *s , char const   *command , struct passwd *pw ) 
{ int fdout___0 ;
  int ptyfd ;
  int ttyfd ;
  int ptymaster ;
  pid_t pid ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;

  {
#line 546
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 547
    fatal("do_exec_pty: no session");
  }
#line 548
  ptyfd = s->ptyfd;
#line 549
  ttyfd = s->ttyfd;
#line 552
  do_pam_session(pw->pw_name, (char const   *)(s->tty));
#line 553
  do_pam_setcred();
#line 557
  pid = fork();
#line 557
  if (pid == 0) {
#line 559
    log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 562
    close(ptyfd);
#line 565
    pty_make_controlling_tty(& ttyfd, (char const   *)(s->tty));
#line 568
    tmp___1 = fileno(stdin);
#line 568
    tmp___2 = dup2(ttyfd, tmp___1);
#line 568
    if (tmp___2 < 0) {
#line 569
      tmp = __errno_location();
#line 569
      tmp___0 = strerror(*tmp);
#line 569
      error("dup2 stdin failed: %.100s", tmp___0);
    }
#line 572
    tmp___5 = fileno(stdout);
#line 572
    tmp___6 = dup2(ttyfd, tmp___5);
#line 572
    if (tmp___6 < 0) {
#line 573
      tmp___3 = __errno_location();
#line 573
      tmp___4 = strerror(*tmp___3);
#line 573
      error("dup2 stdin failed: %.100s", tmp___4);
    }
#line 576
    tmp___9 = fileno(stderr);
#line 576
    tmp___10 = dup2(ttyfd, tmp___9);
#line 576
    if (tmp___10 < 0) {
#line 577
      tmp___7 = __errno_location();
#line 577
      tmp___8 = strerror(*tmp___7);
#line 577
      error("dup2 stdin failed: %.100s", tmp___8);
    }
#line 580
    close(ttyfd);
#line 583
    if ((unsigned int )command == (unsigned int )((void *)0)) {
#line 583
      if (! options.use_login) {
#line 584
        do_login(s);
      }
    }
#line 587
    do_child(command, pw, (char const   *)s->term, (char const   *)s->display, (char const   *)s->auth_proto,
             (char const   *)s->auth_data, (char const   *)(s->tty));
  }
#line 591
  if (pid < 0) {
#line 592
    tmp___11 = __errno_location();
#line 592
    tmp___12 = strerror(*tmp___11);
#line 592
    packet_disconnect("fork failed: %.100s", tmp___12);
  }
#line 593
  s->pid = pid;
#line 596
  close(ttyfd);
#line 603
  fdout___0 = dup(ptyfd);
#line 604
  if (fdout___0 < 0) {
#line 605
    tmp___13 = __errno_location();
#line 605
    tmp___14 = strerror(*tmp___13);
#line 605
    packet_disconnect("dup #1 failed: %.100s", tmp___14);
  }
#line 608
  ptymaster = dup(ptyfd);
#line 609
  if (ptymaster < 0) {
#line 610
    tmp___15 = __errno_location();
#line 610
    tmp___16 = strerror(*tmp___15);
#line 610
    packet_disconnect("dup #2 failed: %.100s", tmp___16);
  }
#line 611
  s->ptymaster = ptymaster;
#line 614
  if (compat20) {
#line 615
    session_set_fds(s, ptyfd, fdout___0, -1);
  } else {
#line 617
    server_loop(pid, ptyfd, fdout___0, -1);
#line 619
    session_pty_cleanup(s);
  }
#line 621
  return;
}
}
#line 626
char const   *get_remote_name_or_ip(void) ;
#line 626 "session.c"
static char const   *remote  =    "";
#line 623 "session.c"
char const   *get_remote_name_or_ip(void) 
{ size_t tmp ;

  {
#line 627
  if (utmp_len > 0U) {
#line 628
    remote = get_canonical_hostname();
  }
#line 629
  if (utmp_len == 0U) {
#line 630
    remote = get_remote_ipaddr();
  } else {
#line 629
    tmp = strlen(remote);
#line 629
    if (tmp > utmp_len) {
#line 630
      remote = get_remote_ipaddr();
    }
  }
#line 631
  return (remote);
}
}
#line 635 "session.c"
void do_login(Session *s ) 
{ FILE *f ;
  char *time_string ;
  char buf___1[256] ;
  socklen_t fromlen ;
  struct sockaddr_storage from ;
  struct stat st ;
  time_t last_login_time ;
  struct passwd *pw ;
  pid_t pid ;
  __pid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  unsigned long tmp___7 ;
  char *tmp___9 ;
  char *tmp___11 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___17 ;
  int tmp___20 ;
  int tmp___21 ;
  char *tmp___22 ;

  {
#line 645
  pw = s->pw;
#line 646
  tmp = getpid();
#line 646
  pid = tmp;
#line 652
  memset((void *)(& from), 0, sizeof(from));
#line 653
  tmp___4 = packet_connection_is_on_socket();
#line 653
  if (tmp___4) {
#line 654
    fromlen = sizeof(from);
#line 655
    tmp___2 = packet_get_connection_in();
#line 655
    tmp___3 = getpeername(tmp___2, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 655
    if (tmp___3 < 0) {
#line 657
      tmp___0 = __errno_location();
#line 657
      tmp___1 = strerror(*tmp___0);
#line 657
      debug("getpeername: %.100s", tmp___1);
#line 658
      fatal_cleanup();
    }
  }
#line 663
  tmp___5 = get_remote_name_or_ip();
#line 663
  record_login(pid, (char const   *)(s->tty), (char const   *)pw->pw_name, pw->pw_uid,
               tmp___5, (struct sockaddr *)(& from));
#line 667
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.200s/.hushlogin",
           pw->pw_dir);
#line 671
  tmp___6 = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )(& st));
#line 671
  if (tmp___6 >= 0) {
#line 673
    return;
  }
#line 676
  print_pam_messages();
#line 687
  tmp___7 = get_last_login_time(pw->pw_uid, (char const   *)pw->pw_name, buf___1,
                                sizeof(buf___1));
#line 687
  last_login_time = (long )tmp___7;
#line 689
  if (last_login_time != 0L) {
#line 690
    time_string = ctime((time_t const   *)(& last_login_time));
#line 691
    tmp___11 = __builtin_strchr(time_string, '\n');
#line 691
    if (tmp___11) {
#line 692
      tmp___9 = __builtin_strchr(time_string, '\n');
#line 692
      *tmp___9 = (char)0;
    }
#line 693
    if (0) {
#line 693
      __s1_len = strlen((char const   *)(buf___1));
#line 693
      __s2_len = strlen("");
#line 693
      if (! ((unsigned int )((void const   *)(buf___1 + 1)) - (unsigned int )((void const   *)(buf___1)) == 1U)) {
        goto _L___0;
      } else {
#line 693
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 693
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 693
            tmp___21 = 1;
          } else {
#line 693
            if (__s2_len >= 4U) {
#line 693
              tmp___21 = 1;
            } else {
#line 693
              tmp___21 = 0;
            }
          }
        } else {
#line 693
          tmp___21 = 0;
        }
      }
#line 693
      if (tmp___21) {
#line 693
        tmp___17 = __builtin_strcmp((char const   *)(buf___1), "");
      } else {
#line 693
        tmp___20 = __builtin_strcmp((char const   *)(buf___1), "");
#line 693
        tmp___17 = tmp___20;
      }
    } else {
#line 693
      tmp___20 = __builtin_strcmp((char const   *)(buf___1), "");
#line 693
      tmp___17 = tmp___20;
    }
#line 693
    if (tmp___17 == 0) {
#line 694
      printf((char const   * __restrict  )"Last login: %s\r\n", time_string);
    } else {
#line 696
      printf((char const   * __restrict  )"Last login: %s from %s\r\n", time_string,
             buf___1);
    }
  }
#line 698
  if (options.print_motd) {
#line 703
    f = fopen((char const   * __restrict  )"/etc/motd", (char const   * __restrict  )"r");
#line 705
    if (f) {
#line 706
      while (1) {
#line 706
        tmp___22 = fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )f);
#line 706
        if (! tmp___22) {
#line 706
          break;
        }
#line 707
        fputs((char const   * __restrict  )(buf___1), (FILE * __restrict  )stdout);
      }
#line 708
      fclose(f);
    }
  }
#line 711
  return;
}
}
#line 717 "session.c"
void child_set_env(char ***envp , unsigned int *envsizep , char const   *name , char const   *value ) 
{ unsigned int i ;
  unsigned int namelen ;
  char **env ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  void *tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  void *tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;

  {
#line 729
  env = *envp;
#line 730
  namelen = strlen(name);
#line 731
  i = 0U;
#line 731
  while (*(env + i)) {
#line 732
    if (0) {
#line 732
      if (0) {
#line 732
        __s1_len___0 = strlen((char const   *)*(env + i));
#line 732
        __s2_len___0 = strlen(name);
#line 732
        if (! ((unsigned int )((void const   *)(*(env + i) + 1)) - (unsigned int )((void const   *)*(env + i)) == 1U)) {
          goto _L___2;
        } else {
#line 732
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 732
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
#line 732
              tmp___22 = 1;
            } else {
#line 732
              if (__s2_len___0 >= 4U) {
#line 732
                tmp___22 = 1;
              } else {
#line 732
                tmp___22 = 0;
              }
            }
          } else {
#line 732
            tmp___22 = 0;
          }
        }
#line 732
        if (tmp___22) {
#line 732
          tmp___18 = __builtin_strcmp((char const   *)*(env + i), name);
        } else {
#line 732
          tmp___21 = __builtin_strcmp((char const   *)*(env + i), name);
#line 732
          tmp___18 = tmp___21;
        }
      } else {
#line 732
        tmp___21 = __builtin_strcmp((char const   *)*(env + i), name);
#line 732
        tmp___18 = tmp___21;
      }
#line 732
      tmp___12 = tmp___18;
    } else {
#line 732
      tmp___12 = strncmp((char const   *)*(env + i), name, namelen);
    }
#line 732
    if (tmp___12 == 0) {
#line 732
      if ((int )*(*(env + i) + namelen) == 61) {
#line 733
        break;
      }
    }
#line 731
    i ++;
  }
#line 734
  if (*(env + i)) {
#line 736
    xfree((void *)*(env + i));
  } else {
#line 739
    if (i >= *envsizep - 1U) {
#line 740
      *envsizep += 50U;
#line 741
      tmp___25 = xrealloc((void *)env, *envsizep * sizeof(char *));
#line 741
      *envp = (char **)tmp___25;
#line 741
      env = *envp;
    }
#line 744
    *(env + (i + 1U)) = (char *)((void *)0);
  }
#line 748
  tmp___26 = strlen(name);
#line 748
  tmp___27 = strlen(value);
#line 748
  tmp___28 = xmalloc(((tmp___26 + 1U) + tmp___27) + 1U);
#line 748
  *(env + i) = (char *)tmp___28;
#line 749
  tmp___29 = strlen(name);
#line 749
  tmp___30 = strlen(value);
#line 749
  snprintf((char * __restrict  )*(env + i), ((tmp___29 + 1U) + tmp___30) + 1U, (char const   * __restrict  )"%s=%s",
           name, value);
#line 750
  return;
}
}
#line 758 "session.c"
void read_environment_file(char ***env , unsigned int *envsize , char const   *filename ) 
{ FILE *f ;
  char buf___1[4096] ;
  char *cp ;
  char *value ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 766
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 767
  if (! f) {
#line 768
    return;
  }
#line 770
  while (1) {
#line 770
    tmp___5 = fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )f);
#line 770
    if (! tmp___5) {
#line 770
      break;
    }
#line 771
    cp = buf___1;
#line 771
    while (1) {
#line 771
      if (! ((int )*cp == 32)) {
#line 771
        if (! ((int )*cp == 9)) {
#line 771
          break;
        }
      }
#line 771
      cp ++;
    }
#line 773
    if (! *cp) {
#line 774
      continue;
    } else {
#line 773
      if ((int )*cp == 35) {
#line 774
        continue;
      } else {
#line 773
        if ((int )*cp == 10) {
#line 774
          continue;
        }
      }
    }
#line 775
    tmp___2 = __builtin_strchr(cp, '\n');
#line 775
    if (tmp___2) {
#line 776
      tmp___0 = __builtin_strchr(cp, '\n');
#line 776
      *tmp___0 = (char )'\000';
    }
#line 777
    tmp___4 = __builtin_strchr(cp, '=');
#line 777
    value = tmp___4;
#line 778
    if ((unsigned int )value == (unsigned int )((void *)0)) {
#line 779
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad line in %.100s: %.200s\n",
              filename, buf___1);
#line 780
      continue;
    }
#line 786
    *value = (char )'\000';
#line 787
    value ++;
#line 788
    child_set_env(env, envsize, (char const   *)cp, (char const   *)value);
  }
#line 790
  fclose(f);
#line 791
  return;
}
}
#line 797 "session.c"
void do_pam_environment(char ***env , int *envsize ) 
{ char *equals ;
  char var_name[512] ;
  char var_val[512] ;
  char **pam_env ;
  int i ;
  size_t tmp ;

  {
#line 803
  pam_env = fetch_pam_environment();
#line 803
  if ((unsigned int )pam_env == (unsigned int )((void *)0)) {
#line 804
    return;
  }
#line 806
  i = 0;
#line 806
  while ((unsigned int )*(pam_env + i) != (unsigned int )((void *)0)) {
#line 807
    equals = strstr((char const   *)*(pam_env + i), "=");
#line 807
    if ((unsigned int )equals == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 810
    tmp = strlen((char const   *)*(pam_env + i));
#line 810
    if (tmp < sizeof(var_name) - 1U) {
#line 811
      memset((void *)(var_name), '\000', sizeof(var_name));
#line 812
      memset((void *)(var_val), '\000', sizeof(var_val));
#line 814
      __builtin_strncpy(var_name, (char const   *)*(pam_env + i), (unsigned int )(equals - *(pam_env + i)));
#line 815
      strcpy((char * __restrict  )(var_val), (char const   * __restrict  )(equals + 1));
#line 817
      debug("PAM environment: %s=%s", var_name, var_val);
#line 819
      child_set_env(env, (unsigned int *)envsize, (char const   *)(var_name), (char const   *)(var_val));
    }
    __Cont: /* CIL Label */ 
#line 806
    i ++;
  }
#line 822
  return;
}
}
#line 920
extern char **environ ;
#line 909 "session.c"
void do_child(char const   *command , struct passwd *pw , char const   *term , char const   *display ,
              char const   *auth_proto , char const   *auth_data , char const   *ttyname___0 ) 
{ char const   *shell ;
  char const   *hostname ;
  char const   *cp ;
  char buf___1[256] ;
  char cmd[1024] ;
  FILE *f ;
  unsigned int envsize ;
  unsigned int i ;
  char **env ;
  struct stat st ;
  char *argv[10] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  __uid_t tmp___4 ;
  __uid_t tmp___5 ;
  __uid_t tmp___6 ;
  __uid_t tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  struct envstring *ce ;
  char *s ;
  int i___0 ;
  int tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  char *screen ;
  char *tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  char *tmp___28 ;
  char buf___2[256] ;
  char *mailbox ;
  struct stat mailstat ;
  int tmp___29 ;

  {
#line 914
  cp = (char const   *)((void *)0);
#line 917
  f = (FILE *)((void *)0);
#line 928
  if (options.use_login) {
#line 928
    if ((unsigned int )command != (unsigned int )((void *)0)) {
#line 929
      options.use_login = 0;
    }
  }
#line 954
  if (! options.use_login) {
#line 971
    tmp___4 = getuid();
#line 971
    if (tmp___4 == 0U) {
      goto _L;
    } else {
#line 971
      tmp___5 = geteuid();
#line 971
      if (tmp___5 == 0U) {
        _L: /* CIL Label */ 
#line 982
        tmp___1 = setlogin((char const   *)pw->pw_name);
#line 982
        if (tmp___1 < 0) {
#line 983
          tmp = __errno_location();
#line 983
          tmp___0 = strerror(*tmp);
#line 983
          error("setlogin failed: %s", tmp___0);
        }
#line 984
        tmp___2 = setgid(pw->pw_gid);
#line 984
        if (tmp___2 < 0) {
#line 985
          perror("setgid");
#line 986
          exit(1);
        }
#line 989
        tmp___3 = initgroups((char const   *)pw->pw_name, pw->pw_gid);
#line 989
        if (tmp___3 < 0) {
#line 990
          perror("initgroups");
#line 991
          exit(1);
        }
#line 993
        endgrent();
#line 1011
        permanently_set_uid(pw->pw_uid);
      }
    }
#line 1016
    tmp___6 = getuid();
#line 1016
    if (tmp___6 != pw->pw_uid) {
#line 1017
      fatal("Failed to set uids to %u.", pw->pw_uid);
    } else {
#line 1016
      tmp___7 = geteuid();
#line 1016
      if (tmp___7 != pw->pw_uid) {
#line 1017
        fatal("Failed to set uids to %u.", pw->pw_uid);
      }
    }
  }
#line 1023
  if ((int )*(pw->pw_shell + 0) == 0) {
#line 1023
    shell = "/bin/sh";
  } else {
#line 1023
    shell = (char const   *)pw->pw_shell;
  }
#line 1041
  envsize = 100U;
#line 1042
  tmp___8 = xmalloc(envsize * sizeof(char *));
#line 1042
  env = (char **)tmp___8;
#line 1043
  *(env + 0) = (char *)((void *)0);
#line 1045
  if (! options.use_login) {
#line 1047
    child_set_env(& env, & envsize, "USER", (char const   *)pw->pw_name);
#line 1048
    child_set_env(& env, & envsize, "LOGNAME", (char const   *)pw->pw_name);
#line 1049
    child_set_env(& env, & envsize, "HOME", (char const   *)pw->pw_dir);
#line 1054
    child_set_env(& env, & envsize, "PATH", "/usr/bin:/bin:/usr/sbin:/sbin");
#line 1057
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.200s/%.50s",
             "/var/mail", pw->pw_name);
#line 1059
    child_set_env(& env, & envsize, "MAIL", (char const   *)(buf___1));
#line 1062
    child_set_env(& env, & envsize, "SHELL", shell);
  }
#line 1064
  tmp___10 = getenv("TZ");
#line 1064
  if (tmp___10) {
#line 1065
    tmp___9 = getenv("TZ");
#line 1065
    child_set_env(& env, & envsize, "TZ", (char const   *)tmp___9);
  }
#line 1068
  while (custom_environment) {
#line 1069
    ce = custom_environment;
#line 1070
    s = ce->s;
#line 1072
    i___0 = 0;
#line 1072
    while (1) {
#line 1072
      if ((int )*(s + i___0) != 61) {
#line 1072
        if (! *(s + i___0)) {
#line 1072
          break;
        }
      } else {
#line 1072
        break;
      }
#line 1072
      i___0 ++;
    }
#line 1073
    if ((int )*(s + i___0) == 61) {
#line 1074
      *(s + i___0) = (char)0;
#line 1075
      child_set_env(& env, & envsize, (char const   *)s, (char const   *)((s + i___0) + 1));
    }
#line 1077
    custom_environment = ce->next;
#line 1078
    xfree((void *)ce->s);
#line 1079
    xfree((void *)ce);
  }
#line 1082
  tmp___11 = get_local_port();
#line 1082
  tmp___12 = get_remote_port();
#line 1082
  tmp___13 = get_remote_ipaddr();
#line 1082
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.50s %d %d",
           tmp___13, tmp___12, tmp___11);
#line 1084
  child_set_env(& env, & envsize, "SSH_CLIENT", (char const   *)(buf___1));
#line 1086
  if (ttyname___0) {
#line 1087
    child_set_env(& env, & envsize, "SSH_TTY", ttyname___0);
  }
#line 1088
  if (term) {
#line 1089
    child_set_env(& env, & envsize, "TERM", term);
  }
#line 1090
  if (display) {
#line 1091
    child_set_env(& env, & envsize, "DISPLAY", display);
  }
#line 1116
  do_pam_environment(& env, (int *)(& envsize));
#line 1119
  read_environment_file(& env, & envsize, "/etc/environment");
#line 1121
  if (xauthfile) {
#line 1122
    child_set_env(& env, & envsize, "XAUTHORITY", (char const   *)xauthfile);
  }
#line 1123
  tmp___15 = auth_get_socket_name();
#line 1123
  if ((unsigned int )tmp___15 != (unsigned int )((void *)0)) {
#line 1124
    tmp___14 = auth_get_socket_name();
#line 1124
    child_set_env(& env, & envsize, "SSH_AUTH_SOCK", (char const   *)tmp___14);
  }
#line 1128
  if (! options.use_login) {
#line 1129
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.200s/.ssh/environment",
             pw->pw_dir);
#line 1131
    read_environment_file(& env, & envsize, (char const   *)(buf___1));
  }
#line 1133
  if (debug_flag) {
#line 1135
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Environment:\n");
#line 1136
    i = 0U;
#line 1136
    while (*(env + i)) {
#line 1137
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  %.200s\n",
              *(env + i));
#line 1136
      i ++;
    }
  }
#line 1140
  if (options.use_login) {
#line 1141
    hostname = get_remote_name_or_ip();
  }
#line 1149
  tmp___19 = packet_get_connection_in();
#line 1149
  tmp___20 = packet_get_connection_out();
#line 1149
  if (tmp___19 == tmp___20) {
#line 1150
    tmp___16 = packet_get_connection_in();
#line 1150
    close(tmp___16);
  } else {
#line 1152
    tmp___17 = packet_get_connection_in();
#line 1152
    close(tmp___17);
#line 1153
    tmp___18 = packet_get_connection_out();
#line 1153
    close(tmp___18);
  }
#line 1160
  channel_close_all();
#line 1166
  endpwent();
#line 1174
  i = 3U;
#line 1174
  while (i < 64U) {
#line 1175
    close((int )i);
#line 1174
    i ++;
  }
#line 1178
  tmp___23 = chdir((char const   *)pw->pw_dir);
#line 1178
  if (tmp___23 < 0) {
#line 1179
    tmp___21 = __errno_location();
#line 1179
    tmp___22 = strerror(*tmp___21);
#line 1179
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not chdir to home directory %s: %s\n",
            pw->pw_dir, tmp___22);
  }
#line 1191
  environ = env;
#line 1197
  if (! options.use_login) {
#line 1198
    tmp___27 = stat((char const   * __restrict  )".ssh/rc", (struct stat * __restrict  )(& st));
#line 1198
    if (tmp___27 >= 0) {
#line 1199
      if (debug_flag) {
#line 1200
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running /bin/sh %s\n",
                ".ssh/rc");
      }
#line 1202
      f = popen("/bin/sh .ssh/rc", "w");
#line 1203
      if (f) {
#line 1204
        if ((unsigned int )auth_proto != (unsigned int )((void *)0)) {
#line 1204
          if ((unsigned int )auth_data != (unsigned int )((void *)0)) {
#line 1205
            fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                    auth_proto, auth_data);
          }
        }
#line 1206
        pclose(f);
      } else {
#line 1208
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                ".ssh/rc");
      }
    } else {
#line 1209
      tmp___26 = stat((char const   * __restrict  )"/usr/local/etc/sshrc", (struct stat * __restrict  )(& st));
#line 1209
      if (tmp___26 >= 0) {
#line 1210
        if (debug_flag) {
#line 1211
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running /bin/sh %s\n",
                  "/usr/local/etc/sshrc");
        }
#line 1213
        f = popen("/bin/sh /usr/local/etc/sshrc", "w");
#line 1214
        if (f) {
#line 1215
          if ((unsigned int )auth_proto != (unsigned int )((void *)0)) {
#line 1215
            if ((unsigned int )auth_data != (unsigned int )((void *)0)) {
#line 1216
              fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                      auth_proto, auth_data);
            }
          }
#line 1217
          pclose(f);
        } else {
#line 1219
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                  "/usr/local/etc/sshrc");
        }
      } else {
#line 1220
        if ((unsigned int )options.xauth_location != (unsigned int )((void *)0)) {
#line 1222
          if ((unsigned int )auth_proto != (unsigned int )((void *)0)) {
#line 1222
            if ((unsigned int )auth_data != (unsigned int )((void *)0)) {
#line 1223
              tmp___25 = __builtin_strchr((char *)display, ':');
#line 1223
              screen = tmp___25;
#line 1224
              if (debug_flag) {
#line 1225
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %.100s add %.100s %.100s %.100s\n",
                        options.xauth_location, display, auth_proto, auth_data);
#line 1229
                if ((unsigned int )screen != (unsigned int )((void *)0)) {
#line 1230
                  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Adding %.*s/unix%s %s %s\n",
                          screen - (char *)display, display, screen, auth_proto, auth_data);
                }
              }
#line 1235
              snprintf((char * __restrict  )(cmd), sizeof(cmd), (char const   * __restrict  )"%s -q -",
                       options.xauth_location);
#line 1237
              f = popen((char const   *)(cmd), "w");
#line 1238
              if (f) {
#line 1239
                fprintf((FILE * __restrict  )f, (char const   * __restrict  )"add %s %s %s\n",
                        display, auth_proto, auth_data);
#line 1241
                if ((unsigned int )screen != (unsigned int )((void *)0)) {
#line 1242
                  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"add %.*s/unix%s %s %s\n",
                          screen - (char *)display, display, screen, auth_proto, auth_data);
                }
#line 1245
                pclose(f);
              } else {
#line 1247
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                        cmd);
              }
            }
          }
        }
      }
    }
#line 1253
    tmp___28 = strrchr(shell, '/');
#line 1253
    cp = (char const   *)tmp___28;
#line 1254
    if (cp) {
#line 1255
      cp ++;
    } else {
#line 1257
      cp = shell;
    }
  }
#line 1264
  if (! command) {
#line 1265
    if (! options.use_login) {
#line 1272
      if (ttyname___0) {
#line 1272
        if (options.check_mail) {
#line 1275
          mailbox = getenv("MAIL");
#line 1276
          if ((unsigned int )mailbox != (unsigned int )((void *)0)) {
#line 1277
            tmp___29 = stat((char const   * __restrict  )mailbox, (struct stat * __restrict  )(& mailstat));
#line 1277
            if (tmp___29 != 0) {
#line 1279
              printf((char const   * __restrict  )"No mail.\n");
            } else {
#line 1277
              if (mailstat.st_size == 0L) {
#line 1279
                printf((char const   * __restrict  )"No mail.\n");
              } else {
#line 1280
                if (mailstat.st_mtim.tv_sec < mailstat.st_atim.tv_sec) {
#line 1281
                  printf((char const   * __restrict  )"You have mail.\n");
                } else {
#line 1283
                  printf((char const   * __restrict  )"You have new mail.\n");
                }
              }
            }
          }
        }
      }
#line 1287
      buf___2[0] = (char )'-';
#line 1288
      __builtin_strncpy(buf___2 + 1, cp, sizeof(buf___2) - 1U);
#line 1289
      buf___2[sizeof(buf___2) - 1U] = (char)0;
#line 1292
      argv[0] = buf___2;
#line 1293
      argv[1] = (char *)((void *)0);
#line 1294
      execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 1297
      perror(shell);
#line 1298
      exit(1);
    } else {
#line 1303
      execl("/bin/login", "login", "-h", hostname, "-p", "-f", "--", pw->pw_name,
            (void *)0);
#line 1308
      perror("login");
#line 1309
      exit(1);
    }
  }
#line 1316
  argv[0] = (char *)cp;
#line 1317
  argv[1] = (char *)"-c";
#line 1318
  argv[2] = (char *)command;
#line 1319
  argv[3] = (char *)((void *)0);
#line 1320
  execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 1321
  perror(shell);
#line 1322
  exit(1);
}
}
#line 1329 "session.c"
static int did_init___0  =    0;
#line 1325 "session.c"
Session *session_new(void) 
{ int i ;
  Session *s ;

  {
#line 1330
  if (! did_init___0) {
#line 1331
    debug("session_new: init");
#line 1332
    i = 0;
#line 1332
    while (i < 10) {
#line 1333
      sessions[i].used = 0;
#line 1334
      sessions[i].self = i;
#line 1332
      i ++;
    }
#line 1336
    did_init___0 = 1;
  }
#line 1338
  i = 0;
#line 1338
  while (i < 10) {
#line 1339
    s = & sessions[i];
#line 1340
    if (! s->used) {
#line 1341
      s->pid = 0;
#line 1342
      s->extended = 0;
#line 1343
      s->chanid = -1;
#line 1344
      s->ptyfd = -1;
#line 1345
      s->ttyfd = -1;
#line 1346
      s->term = (char *)((void *)0);
#line 1347
      s->pw = (struct passwd *)((void *)0);
#line 1348
      s->display = (char *)((void *)0);
#line 1349
      s->screen = 0;
#line 1350
      s->auth_data = (char *)((void *)0);
#line 1351
      s->auth_proto = (char *)((void *)0);
#line 1352
      s->used = 1;
#line 1353
      s->pw = (struct passwd *)((void *)0);
#line 1354
      debug("session_new: session %d", i);
#line 1355
      return (s);
    }
#line 1338
    i ++;
  }
#line 1358
  return ((Session *)((void *)0));
}
}
#line 1361 "session.c"
void session_dump(void) 
{ int i ;
  Session *s ;

  {
#line 1365
  i = 0;
#line 1365
  while (i < 10) {
#line 1366
    s = & sessions[i];
#line 1367
    debug("dump: used %d session %d %p channel %d pid %d", s->used, s->self, s, s->chanid,
          s->pid);
#line 1365
    i ++;
  }
#line 1374
  return;
}
}
#line 1376 "session.c"
int session_open(int chanid ) 
{ Session *s ;
  Session *tmp ;

  {
#line 1379
  tmp = session_new();
#line 1379
  s = tmp;
#line 1380
  debug("session_open: channel %d", chanid);
#line 1381
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1382
    error("no more sessions");
#line 1383
    return (0);
  }
#line 1385
  s->pw = auth_get_user();
#line 1386
  if ((unsigned int )s->pw == (unsigned int )((void *)0)) {
#line 1387
    fatal("no user for session %i", s->self);
  }
#line 1388
  debug("session_open: session %d: link with channel %d", s->self, chanid);
#line 1389
  s->chanid = chanid;
#line 1390
  return (1);
}
}
#line 1393 "session.c"
Session *session_by_channel(int id ) 
{ int i ;
  Session *s ;

  {
#line 1397
  i = 0;
#line 1397
  while (i < 10) {
#line 1398
    s = & sessions[i];
#line 1399
    if (s->used) {
#line 1399
      if (s->chanid == id) {
#line 1400
        debug("session_by_channel: session %d channel %d", i, id);
#line 1401
        return (s);
      }
    }
#line 1397
    i ++;
  }
#line 1404
  debug("session_by_channel: unknown channel %d", id);
#line 1405
  session_dump();
#line 1406
  return ((Session *)((void *)0));
}
}
#line 1409 "session.c"
Session *session_by_pid(pid_t pid ) 
{ int i ;
  Session *s ;

  {
#line 1413
  debug("session_by_pid: pid %d", pid);
#line 1414
  i = 0;
#line 1414
  while (i < 10) {
#line 1415
    s = & sessions[i];
#line 1416
    if (s->used) {
#line 1416
      if (s->pid == pid) {
#line 1417
        return (s);
      }
    }
#line 1414
    i ++;
  }
#line 1419
  error("session_by_pid: unknown pid %d", pid);
#line 1420
  session_dump();
#line 1421
  return ((Session *)((void *)0));
}
}
#line 1424 "session.c"
int session_window_change_req(Session *s ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 1427
  tmp = packet_get_int();
#line 1427
  s->col = (int )tmp;
#line 1428
  tmp___0 = packet_get_int();
#line 1428
  s->row = (int )tmp___0;
#line 1429
  tmp___1 = packet_get_int();
#line 1429
  s->xpixel = (int )tmp___1;
#line 1430
  tmp___2 = packet_get_int();
#line 1430
  s->ypixel = (int )tmp___2;
#line 1431
  while (1) {
#line 1431
    tmp___3 = packet_remaining();
#line 1431
    _len = tmp___3;
#line 1431
    if (_len > 0) {
#line 1431
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1431);
#line 1431
      packet_disconnect("Packet integrity error.");
    }
#line 1431
    break;
  }
#line 1432
  pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);
#line 1433
  return (1);
}
}
#line 1436 "session.c"
int session_pty_req(Session *s ) 
{ unsigned int len ;
  char *term_modes ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int _len ;
  int tmp___3 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___9 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 1442
  if (no_pty_flag) {
#line 1443
    return (0);
  }
#line 1444
  if (s->ttyfd != -1) {
#line 1445
    return (0);
  }
#line 1446
  s->term = packet_get_string(& len);
#line 1447
  tmp = packet_get_int();
#line 1447
  s->col = (int )tmp;
#line 1448
  tmp___0 = packet_get_int();
#line 1448
  s->row = (int )tmp___0;
#line 1449
  tmp___1 = packet_get_int();
#line 1449
  s->xpixel = (int )tmp___1;
#line 1450
  tmp___2 = packet_get_int();
#line 1450
  s->ypixel = (int )tmp___2;
#line 1451
  term_modes = packet_get_string(& len);
#line 1452
  while (1) {
#line 1452
    tmp___3 = packet_remaining();
#line 1452
    _len = tmp___3;
#line 1452
    if (_len > 0) {
#line 1452
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1452);
#line 1452
      packet_disconnect("Packet integrity error.");
    }
#line 1452
    break;
  }
#line 1454
  if (0) {
#line 1454
    __s1_len = strlen((char const   *)s->term);
#line 1454
    __s2_len = strlen("");
#line 1454
    if (! ((unsigned int )((void const   *)(s->term + 1)) - (unsigned int )((void const   *)s->term) == 1U)) {
      goto _L___0;
    } else {
#line 1454
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1454
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 1454
          tmp___13 = 1;
        } else {
#line 1454
          if (__s2_len >= 4U) {
#line 1454
            tmp___13 = 1;
          } else {
#line 1454
            tmp___13 = 0;
          }
        }
      } else {
#line 1454
        tmp___13 = 0;
      }
    }
#line 1454
    if (tmp___13) {
#line 1454
      tmp___9 = __builtin_strcmp((char const   *)s->term, "");
    } else {
#line 1454
      tmp___12 = __builtin_strcmp((char const   *)s->term, "");
#line 1454
      tmp___9 = tmp___12;
    }
  } else {
#line 1454
    tmp___12 = __builtin_strcmp((char const   *)s->term, "");
#line 1454
    tmp___9 = tmp___12;
  }
#line 1454
  if (tmp___9 == 0) {
#line 1455
    xfree((void *)s->term);
#line 1456
    s->term = (char *)((void *)0);
  }
#line 1459
  tmp___14 = pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, (int )sizeof(s->tty));
#line 1459
  if (! tmp___14) {
#line 1460
    xfree((void *)s->term);
#line 1461
    s->term = (char *)((void *)0);
#line 1462
    s->ptyfd = -1;
#line 1463
    s->ttyfd = -1;
#line 1464
    error("session_pty_req: session %d alloc failed", s->self);
#line 1465
    xfree((void *)term_modes);
#line 1466
    return (0);
  }
#line 1468
  debug("session_pty_req: session %d alloc %s", s->self, s->tty);
#line 1473
  fatal_add_cleanup(& pty_cleanup_proc, (void *)s);
#line 1474
  pty_setowner(s->pw, (char const   *)(s->tty));
#line 1476
  pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);
#line 1478
  session_proctitle(s);
#line 1481
  xfree((void *)term_modes);
#line 1482
  return (1);
}
}
#line 1485 "session.c"
int session_subsystem_req(Session *s ) 
{ unsigned int len ;
  int success ;
  char *subsys ;
  char *tmp ;
  int i ;
  int _len ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 1489
  success = 0;
#line 1490
  tmp = packet_get_string(& len);
#line 1490
  subsys = tmp;
#line 1493
  while (1) {
#line 1493
    tmp___0 = packet_remaining();
#line 1493
    _len = tmp___0;
#line 1493
    if (_len > 0) {
#line 1493
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1493);
#line 1493
      packet_disconnect("Packet integrity error.");
    }
#line 1493
    break;
  }
#line 1494
  log("subsystem request for %s", subsys);
#line 1496
  i = 0;
#line 1496
  while ((unsigned int )i < options.num_subsystems) {
#line 1497
    if (0) {
#line 1497
      __s1_len = strlen((char const   *)subsys);
#line 1497
      __s2_len = strlen((char const   *)options.subsystem_name[i]);
#line 1497
      if (! ((unsigned int )((void const   *)(subsys + 1)) - (unsigned int )((void const   *)subsys) == 1U)) {
        goto _L___0;
      } else {
#line 1497
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 1497
          if (! ((unsigned int )((void const   *)(options.subsystem_name[i] + 1)) - (unsigned int )((void const   *)options.subsystem_name[i]) == 1U)) {
#line 1497
            tmp___10 = 1;
          } else {
#line 1497
            if (__s2_len >= 4U) {
#line 1497
              tmp___10 = 1;
            } else {
#line 1497
              tmp___10 = 0;
            }
          }
        } else {
#line 1497
          tmp___10 = 0;
        }
      }
#line 1497
      if (tmp___10) {
#line 1497
        tmp___6 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
      } else {
#line 1497
        tmp___9 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
#line 1497
        tmp___6 = tmp___9;
      }
    } else {
#line 1497
      tmp___9 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
#line 1497
      tmp___6 = tmp___9;
    }
#line 1497
    if (tmp___6 == 0) {
#line 1498
      debug("subsystem: exec() %s", options.subsystem_command[i]);
#line 1499
      do_exec_no_pty(s, (char const   *)options.subsystem_command[i], s->pw);
#line 1500
      success = 1;
    }
#line 1496
    i ++;
  }
#line 1504
  if (! success) {
#line 1505
    log("subsystem request for %s failed, subsystem not found", subsys);
  }
#line 1507
  xfree((void *)subsys);
#line 1508
  return (success);
}
}
#line 1511 "session.c"
int session_x11_req(Session *s ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;
  int _len ;
  int tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 1514
  if (no_x11_forwarding_flag) {
#line 1515
    debug("X11 forwarding disabled in user configuration file.");
#line 1516
    return (0);
  }
#line 1518
  if (! options.x11_forwarding) {
#line 1519
    debug("X11 forwarding disabled in server configuration file.");
#line 1520
    return (0);
  }
#line 1522
  if ((unsigned int )xauthfile != (unsigned int )((void *)0)) {
#line 1523
    debug("X11 fwd already started.");
#line 1524
    return (0);
  }
#line 1527
  debug("Received request for X11 forwarding with auth spoofing.");
#line 1528
  if ((unsigned int )s->display != (unsigned int )((void *)0)) {
#line 1529
    packet_disconnect("Protocol error: X11 display already set.");
  }
#line 1531
  tmp = packet_get_char();
#line 1531
  s->single_connection = (int )tmp;
#line 1532
  s->auth_proto = packet_get_string((unsigned int *)((void *)0));
#line 1533
  s->auth_data = packet_get_string((unsigned int *)((void *)0));
#line 1534
  tmp___0 = packet_get_int();
#line 1534
  s->screen = (int )tmp___0;
#line 1535
  while (1) {
#line 1535
    tmp___1 = packet_remaining();
#line 1535
    _len = tmp___1;
#line 1535
    if (_len > 0) {
#line 1535
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1535);
#line 1535
      packet_disconnect("Packet integrity error.");
    }
#line 1535
    break;
  }
#line 1537
  s->display = x11_create_display_inet(s->screen, options.x11_display_offset);
#line 1538
  if ((unsigned int )s->display == (unsigned int )((void *)0)) {
#line 1539
    xfree((void *)s->auth_proto);
#line 1540
    xfree((void *)s->auth_data);
#line 1541
    return (0);
  }
#line 1543
  tmp___2 = xmalloc(4096U);
#line 1543
  xauthfile = (char *)tmp___2;
#line 1544
  strlcpy(xauthfile, "/tmp/ssh-XXXXXXXX", 4096U);
#line 1545
  temporarily_use_uid((s->pw)->pw_uid);
#line 1546
  tmp___5 = mkdtemp(xauthfile);
#line 1546
  if ((unsigned int )tmp___5 == (unsigned int )((void *)0)) {
#line 1547
    restore_uid();
#line 1548
    tmp___3 = __errno_location();
#line 1548
    tmp___4 = strerror(*tmp___3);
#line 1548
    error("private X11 dir: mkdtemp %s failed: %s", xauthfile, tmp___4);
#line 1550
    xfree((void *)xauthfile);
#line 1551
    xauthfile = (char *)((void *)0);
#line 1552
    xfree((void *)s->auth_proto);
#line 1553
    xfree((void *)s->auth_data);
#line 1555
    return (0);
  }
#line 1557
  strlcat(xauthfile, "/cookies", 4096U);
#line 1558
  open((char const   *)xauthfile, 194, 384);
#line 1559
  restore_uid();
#line 1560
  fatal_add_cleanup(& xauthfile_cleanup_proc, (void *)s);
#line 1561
  return (1);
}
}
#line 1564 "session.c"
int session_shell_req(Session *s ) 
{ char *shell ;
  int _len ;
  int tmp ;

  {
#line 1568
  shell = forced_command;
#line 1569
  while (1) {
#line 1569
    tmp = packet_remaining();
#line 1569
    _len = tmp;
#line 1569
    if (_len > 0) {
#line 1569
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1569);
#line 1569
      packet_disconnect("Packet integrity error.");
    }
#line 1569
    break;
  }
#line 1570
  s->extended = 1;
#line 1571
  if (s->ttyfd == -1) {
#line 1572
    do_exec_no_pty(s, (char const   *)shell, s->pw);
  } else {
#line 1574
    do_exec_pty(s, (char const   *)shell, s->pw);
  }
#line 1575
  return (1);
}
}
#line 1578 "session.c"
int session_exec_req(Session *s ) 
{ unsigned int len ;
  char *command ;
  char *tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 1582
  tmp = packet_get_string(& len);
#line 1582
  command = tmp;
#line 1583
  while (1) {
#line 1583
    tmp___0 = packet_remaining();
#line 1583
    _len = tmp___0;
#line 1583
    if (_len > 0) {
#line 1583
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1583);
#line 1583
      packet_disconnect("Packet integrity error.");
    }
#line 1583
    break;
  }
#line 1584
  if (forced_command) {
#line 1585
    xfree((void *)command);
#line 1586
    command = forced_command;
#line 1587
    debug("Forced command \'%.500s\'", forced_command);
  }
#line 1589
  s->extended = 1;
#line 1590
  if (s->ttyfd == -1) {
#line 1591
    do_exec_no_pty(s, (char const   *)command, s->pw);
  } else {
#line 1593
    do_exec_pty(s, (char const   *)command, s->pw);
  }
#line 1594
  if ((unsigned int )forced_command == (unsigned int )((void *)0)) {
#line 1595
    xfree((void *)command);
  }
#line 1596
  return (1);
}
}
#line 1599 "session.c"
void session_input_channel_req(int id , void *arg ) 
{ unsigned int len ;
  int reply ;
  int success ;
  char *rtype ;
  Session *s ;
  Channel *c ;
  unsigned int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___25 ;
  int tmp___28 ;
  int tmp___29 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___35 ;
  int tmp___38 ;
  int tmp___39 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___45 ;
  int tmp___48 ;
  int tmp___49 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___55 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;

  {
#line 1604
  success = 0;
#line 1609
  rtype = packet_get_string(& len);
#line 1610
  tmp = packet_get_char();
#line 1610
  reply = (int )tmp;
#line 1612
  s = session_by_channel(id);
#line 1613
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1614
    fatal("session_input_channel_req: channel %d: no session", id);
  }
#line 1615
  c = channel_lookup(id);
#line 1616
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1617
    fatal("session_input_channel_req: channel %d: bad channel", id);
  }
#line 1619
  debug("session_input_channel_req: session %d channel %d request %s reply %d", s->self,
        id, rtype, reply);
#line 1626
  if (c->type == 10) {
#line 1627
    if (0) {
#line 1627
      __s1_len___3 = strlen((char const   *)rtype);
#line 1627
      __s2_len___3 = strlen("shell");
#line 1627
      if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
        goto _L___8;
      } else {
#line 1627
        if (__s1_len___3 >= 4U) {
          _L___8: /* CIL Label */ 
#line 1627
          if (! ((unsigned int )((void const   *)("shell" + 1)) - (unsigned int )((void const   *)"shell") == 1U)) {
#line 1627
            tmp___49 = 1;
          } else {
#line 1627
            if (__s2_len___3 >= 4U) {
#line 1627
              tmp___49 = 1;
            } else {
#line 1627
              tmp___49 = 0;
            }
          }
        } else {
#line 1627
          tmp___49 = 0;
        }
      }
#line 1627
      if (tmp___49) {
#line 1627
        tmp___45 = __builtin_strcmp((char const   *)rtype, "shell");
      } else {
#line 1627
        tmp___48 = __builtin_strcmp((char const   *)rtype, "shell");
#line 1627
        tmp___45 = tmp___48;
      }
    } else {
#line 1627
      tmp___48 = __builtin_strcmp((char const   *)rtype, "shell");
#line 1627
      tmp___45 = tmp___48;
    }
#line 1627
    if (tmp___45 == 0) {
#line 1628
      success = session_shell_req(s);
    } else {
#line 1629
      if (0) {
#line 1629
        __s1_len___2 = strlen((char const   *)rtype);
#line 1629
        __s2_len___2 = strlen("exec");
#line 1629
        if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
          goto _L___6;
        } else {
#line 1629
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 1629
            if (! ((unsigned int )((void const   *)("exec" + 1)) - (unsigned int )((void const   *)"exec") == 1U)) {
#line 1629
              tmp___39 = 1;
            } else {
#line 1629
              if (__s2_len___2 >= 4U) {
#line 1629
                tmp___39 = 1;
              } else {
#line 1629
                tmp___39 = 0;
              }
            }
          } else {
#line 1629
            tmp___39 = 0;
          }
        }
#line 1629
        if (tmp___39) {
#line 1629
          tmp___35 = __builtin_strcmp((char const   *)rtype, "exec");
        } else {
#line 1629
          tmp___38 = __builtin_strcmp((char const   *)rtype, "exec");
#line 1629
          tmp___35 = tmp___38;
        }
      } else {
#line 1629
        tmp___38 = __builtin_strcmp((char const   *)rtype, "exec");
#line 1629
        tmp___35 = tmp___38;
      }
#line 1629
      if (tmp___35 == 0) {
#line 1630
        success = session_exec_req(s);
      } else {
#line 1631
        if (0) {
#line 1631
          __s1_len___1 = strlen((char const   *)rtype);
#line 1631
          __s2_len___1 = strlen("pty-req");
#line 1631
          if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
            goto _L___4;
          } else {
#line 1631
            if (__s1_len___1 >= 4U) {
              _L___4: /* CIL Label */ 
#line 1631
              if (! ((unsigned int )((void const   *)("pty-req" + 1)) - (unsigned int )((void const   *)"pty-req") == 1U)) {
#line 1631
                tmp___29 = 1;
              } else {
#line 1631
                if (__s2_len___1 >= 4U) {
#line 1631
                  tmp___29 = 1;
                } else {
#line 1631
                  tmp___29 = 0;
                }
              }
            } else {
#line 1631
              tmp___29 = 0;
            }
          }
#line 1631
          if (tmp___29) {
#line 1631
            tmp___25 = __builtin_strcmp((char const   *)rtype, "pty-req");
          } else {
#line 1631
            tmp___28 = __builtin_strcmp((char const   *)rtype, "pty-req");
#line 1631
            tmp___25 = tmp___28;
          }
        } else {
#line 1631
          tmp___28 = __builtin_strcmp((char const   *)rtype, "pty-req");
#line 1631
          tmp___25 = tmp___28;
        }
#line 1631
        if (tmp___25 == 0) {
#line 1632
          success = session_pty_req(s);
        } else {
#line 1633
          if (0) {
#line 1633
            __s1_len___0 = strlen((char const   *)rtype);
#line 1633
            __s2_len___0 = strlen("x11-req");
#line 1633
            if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
              goto _L___2;
            } else {
#line 1633
              if (__s1_len___0 >= 4U) {
                _L___2: /* CIL Label */ 
#line 1633
                if (! ((unsigned int )((void const   *)("x11-req" + 1)) - (unsigned int )((void const   *)"x11-req") == 1U)) {
#line 1633
                  tmp___19 = 1;
                } else {
#line 1633
                  if (__s2_len___0 >= 4U) {
#line 1633
                    tmp___19 = 1;
                  } else {
#line 1633
                    tmp___19 = 0;
                  }
                }
              } else {
#line 1633
                tmp___19 = 0;
              }
            }
#line 1633
            if (tmp___19) {
#line 1633
              tmp___15 = __builtin_strcmp((char const   *)rtype, "x11-req");
            } else {
#line 1633
              tmp___18 = __builtin_strcmp((char const   *)rtype, "x11-req");
#line 1633
              tmp___15 = tmp___18;
            }
          } else {
#line 1633
            tmp___18 = __builtin_strcmp((char const   *)rtype, "x11-req");
#line 1633
            tmp___15 = tmp___18;
          }
#line 1633
          if (tmp___15 == 0) {
#line 1634
            success = session_x11_req(s);
          } else {
#line 1635
            if (0) {
#line 1635
              __s1_len = strlen((char const   *)rtype);
#line 1635
              __s2_len = strlen("subsystem");
#line 1635
              if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
                goto _L___0;
              } else {
#line 1635
                if (__s1_len >= 4U) {
                  _L___0: /* CIL Label */ 
#line 1635
                  if (! ((unsigned int )((void const   *)("subsystem" + 1)) - (unsigned int )((void const   *)"subsystem") == 1U)) {
#line 1635
                    tmp___9 = 1;
                  } else {
#line 1635
                    if (__s2_len >= 4U) {
#line 1635
                      tmp___9 = 1;
                    } else {
#line 1635
                      tmp___9 = 0;
                    }
                  }
                } else {
#line 1635
                  tmp___9 = 0;
                }
              }
#line 1635
              if (tmp___9) {
#line 1635
                tmp___5 = __builtin_strcmp((char const   *)rtype, "subsystem");
              } else {
#line 1635
                tmp___8 = __builtin_strcmp((char const   *)rtype, "subsystem");
#line 1635
                tmp___5 = tmp___8;
              }
            } else {
#line 1635
              tmp___8 = __builtin_strcmp((char const   *)rtype, "subsystem");
#line 1635
              tmp___5 = tmp___8;
            }
#line 1635
            if (tmp___5 == 0) {
#line 1636
              success = session_subsystem_req(s);
            }
          }
        }
      }
    }
  }
#line 1639
  if (0) {
#line 1639
    __s1_len___4 = strlen((char const   *)rtype);
#line 1639
    __s2_len___4 = strlen("window-change");
#line 1639
    if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
      goto _L___10;
    } else {
#line 1639
      if (__s1_len___4 >= 4U) {
        _L___10: /* CIL Label */ 
#line 1639
        if (! ((unsigned int )((void const   *)("window-change" + 1)) - (unsigned int )((void const   *)"window-change") == 1U)) {
#line 1639
          tmp___59 = 1;
        } else {
#line 1639
          if (__s2_len___4 >= 4U) {
#line 1639
            tmp___59 = 1;
          } else {
#line 1639
            tmp___59 = 0;
          }
        }
      } else {
#line 1639
        tmp___59 = 0;
      }
    }
#line 1639
    if (tmp___59) {
#line 1639
      tmp___55 = __builtin_strcmp((char const   *)rtype, "window-change");
    } else {
#line 1639
      tmp___58 = __builtin_strcmp((char const   *)rtype, "window-change");
#line 1639
      tmp___55 = tmp___58;
    }
  } else {
#line 1639
    tmp___58 = __builtin_strcmp((char const   *)rtype, "window-change");
#line 1639
    tmp___55 = tmp___58;
  }
#line 1639
  if (tmp___55 == 0) {
#line 1640
    success = session_window_change_req(s);
  }
#line 1643
  if (reply) {
#line 1644
    if (success) {
#line 1644
      tmp___60 = 99;
    } else {
#line 1644
      tmp___60 = 100;
    }
#line 1644
    packet_start(tmp___60);
#line 1646
    packet_put_int((unsigned int )c->remote_id);
#line 1647
    packet_send();
  }
#line 1649
  xfree((void *)rtype);
#line 1650
  return;
}
}
#line 1652 "session.c"
void session_set_fds(Session *s , int fdin___0 , int fdout___0 , int fderr___0 ) 
{ int tmp ;

  {
#line 1655
  if (! compat20) {
#line 1656
    fatal("session_set_fds: called for proto != 2.0");
  }
#line 1661
  if (s->chanid == -1) {
#line 1662
    fatal("no channel for session %d", s->self);
  }
#line 1663
  if (fderr___0 == -1) {
#line 1663
    tmp = 0;
  } else {
#line 1663
    tmp = 1;
  }
#line 1663
  channel_set_fds(s->chanid, fdout___0, fdin___0, fderr___0, tmp);
#line 1666
  return;
}
}
#line 1668 "session.c"
void session_pty_cleanup(Session *s ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1671
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1672
    return;
  } else {
#line 1671
    if (s->ttyfd == -1) {
#line 1672
      return;
    }
  }
#line 1674
  debug("session_pty_cleanup: session %i release %s", s->self, s->tty);
#line 1677
  fatal_remove_cleanup(& pty_cleanup_proc, (void *)s);
#line 1680
  record_logout(s->pid, (char const   *)(s->tty));
#line 1683
  pty_release((char const   *)(s->tty));
#line 1690
  tmp___1 = close(s->ptymaster);
#line 1690
  if (tmp___1 < 0) {
#line 1691
    tmp = __errno_location();
#line 1691
    tmp___0 = strerror(*tmp);
#line 1691
    error("close(s->ptymaster): %s", tmp___0);
  }
#line 1692
  return;
}
}
#line 1694 "session.c"
void session_exit_message(Session *s , int status ) 
{ Channel *c ;
  union __anonunion_76 __constr_expr_0 ;
  union __anonunion_77___0 __constr_expr_1 ;
  union __anonunion_78___0 __constr_expr_2 ;
  union __anonunion_79___0 __constr_expr_3 ;
  union __anonunion_80___0 __constr_expr_4 ;

  {
#line 1698
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1699
    fatal("session_close: no session");
  }
#line 1700
  c = channel_lookup(s->chanid);
#line 1701
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1702
    fatal("session_close: session %d: no channel %d", s->self, s->chanid);
  }
#line 1704
  debug("session_exit_message: session %d channel %d pid %d", s->self, s->chanid,
        s->pid);
#line 1707
  __constr_expr_4.__in = status;
#line 1707
  if ((__constr_expr_4.__i & 127) == 0) {
#line 1708
    channel_request_start(s->chanid, (char *)"exit-status", 0);
#line 1710
    __constr_expr_0.__in = status;
#line 1710
    packet_put_int((unsigned int )((__constr_expr_0.__i & 65280) >> 8));
#line 1711
    packet_send();
  } else {
#line 1712
    __constr_expr_3.__in = status;
#line 1712
    if ((int )((signed char )((__constr_expr_3.__i & 127) + 1)) >> 1 > 0) {
#line 1713
      channel_request_start(s->chanid, (char *)"exit-signal", 0);
#line 1715
      __constr_expr_1.__in = status;
#line 1715
      packet_put_int((unsigned int )(__constr_expr_1.__i & 127));
#line 1717
      __constr_expr_2.__in = status;
#line 1717
      packet_put_char(__constr_expr_2.__i & 128);
#line 1721
      packet_put_cstring("");
#line 1722
      packet_put_cstring("");
#line 1723
      packet_send();
    } else {
#line 1726
      packet_disconnect("wait returned status %04x.", status);
    }
  }
#line 1730
  debug("session_exit_message: release channel %d", s->chanid);
#line 1731
  channel_cancel_cleanup(s->chanid);
#line 1738
  if (c->ostate != 128) {
#line 1739
    (*chan_write_failed)(c);
  }
#line 1740
  s->chanid = -1;
#line 1741
  return;
}
}
#line 1743 "session.c"
void session_free(Session *s ) 
{ 

  {
#line 1746
  debug("session_free: session %d pid %d", s->self, s->pid);
#line 1747
  if (s->term) {
#line 1748
    xfree((void *)s->term);
  }
#line 1749
  if (s->display) {
#line 1750
    xfree((void *)s->display);
  }
#line 1751
  if (s->auth_data) {
#line 1752
    xfree((void *)s->auth_data);
  }
#line 1753
  if (s->auth_proto) {
#line 1754
    xfree((void *)s->auth_proto);
  }
#line 1755
  s->used = 0;
#line 1756
  return;
}
}
#line 1758 "session.c"
void session_close(Session *s ) 
{ 

  {
#line 1761
  session_pty_cleanup(s);
#line 1762
  session_free(s);
#line 1763
  session_proctitle(s);
#line 1764
  return;
}
}
#line 1766 "session.c"
void session_close_by_pid(pid_t pid , int status ) 
{ Session *s ;
  Session *tmp ;

  {
#line 1769
  tmp = session_by_pid(pid);
#line 1769
  s = tmp;
#line 1770
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1771
    debug("session_close_by_pid: no session for pid %d", s->pid);
#line 1772
    return;
  }
#line 1774
  if (s->chanid != -1) {
#line 1775
    session_exit_message(s, status);
  }
#line 1776
  session_close(s);
#line 1777
  return;
}
}
#line 1783 "session.c"
void session_close_by_channel(int id , void *arg ) 
{ Session *s ;
  Session *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1786
  tmp = session_by_channel(id);
#line 1786
  s = tmp;
#line 1787
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1788
    debug("session_close_by_channel: no session for channel %d", id);
#line 1789
    return;
  }
#line 1792
  channel_cancel_cleanup(s->chanid);
#line 1793
  s->chanid = -1;
#line 1795
  debug("session_close_by_channel: channel %d kill %d", id, s->pid);
#line 1796
  if (s->pid == 0) {
#line 1798
    session_close(s);
  } else {
#line 1801
    if (s->pid <= 1) {
#line 1802
      fatal("session_close_by_channel: Unsafe s->pid = %d", s->pid);
    }
#line 1803
    if (s->ttyfd == -1) {
#line 1803
      tmp___2 = 15;
    } else {
#line 1803
      tmp___2 = 1;
    }
#line 1803
    tmp___3 = kill(s->pid, tmp___2);
#line 1803
    if (tmp___3 < 0) {
#line 1804
      tmp___0 = __errno_location();
#line 1804
      tmp___1 = strerror(*tmp___0);
#line 1804
      error("session_close_by_channel: kill %d: %s", s->pid, tmp___1);
    }
  }
#line 1807
  return;
}
}
#line 1812 "session.c"
static char buf___0[1024]  ;
#line 1809 "session.c"
char *session_tty_list(void) 
{ int i ;
  Session *s ;
  char *tmp ;

  {
#line 1814
  buf___0[0] = (char )'\000';
#line 1815
  i = 0;
#line 1815
  while (i < 10) {
#line 1816
    s = & sessions[i];
#line 1817
    if (s->used) {
#line 1817
      if (s->ttyfd != -1) {
#line 1818
        if ((int )buf___0[0] != 0) {
#line 1819
          strlcat(buf___0, ",", sizeof(buf___0));
        }
#line 1820
        tmp = strrchr((char const   *)(s->tty), '/');
#line 1820
        strlcat(buf___0, (char const   *)(tmp + 1), sizeof(buf___0));
      }
    }
#line 1815
    i ++;
  }
#line 1823
  if ((int )buf___0[0] == 0) {
#line 1824
    strlcpy(buf___0, "notty", sizeof(buf___0));
  }
#line 1825
  return (buf___0);
}
}
#line 1828 "session.c"
void session_proctitle(Session *s ) 
{ char *tmp ;

  {
#line 1831
  if ((unsigned int )s->pw == (unsigned int )((void *)0)) {
#line 1832
    error("no user for session %d", s->self);
  } else {
#line 1834
    tmp = session_tty_list();
#line 1834
    setproctitle("%s@%s", (s->pw)->pw_name, tmp);
  }
#line 1835
  return;
}
}
#line 1837 "session.c"
void do_authenticated2(void) 
{ 

  {
#line 1848
  alarm(0U);
#line 1849
  if (startup_pipe != -1) {
#line 1850
    close(startup_pipe);
#line 1851
    startup_pipe = -1;
  }
#line 1860
  server_loop2();
#line 1861
  if (xauthfile) {
#line 1862
    xauthfile_cleanup_proc((void *)0);
  }
#line 1863
  return;
}
}
